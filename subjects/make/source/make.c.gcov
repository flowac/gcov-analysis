        -:    0:Source:make.c
        -:    0:Graph:make.gcno
        -:    0:Data:make.gcda
        -:    0:Runs:1
        -:    1:#include "FaultSeeds.h"
        -:    2:/* modification by J. Ruthruff, 8/25 */
        -:    3:#define ALIASPATH "/usr/local/share/locale:."
        -:    4:#define LOCALEDIR "/usr/local/share/locale"
        -:    5:#define LIBDIR "/usr/local/lib"
        -:    6:#define INCLUDEDIR "/usr/local/include"
        -:    7:#define HAVE_CONFIG_H
        -:    8:
        -:    9:#define inline
        -:   10:
        -:   11:#undef stderr
        -:   12:#define stderr stdout
        -:   13:
        -:   14:/*************************************************************
        -:   15:  ============================================================
        -:   16:  ************************************************************
        -:   17:  ============================================================
        -:   18:  ************************************************************
        -:   19:                         ar.c
        -:   20:  ************************************************************
        -:   21:  ============================================================
        -:   22:  ************************************************************
        -:   23:  ============================================================
        -:   24:  *************************************************************/
        -:   25:
        -:   26:/* Interface to `ar' archives for GNU Make.
        -:   27:Copyright (C) 1988,89,90,91,92,93,97 Free Software Foundation, Inc.
        -:   28:This file is part of GNU Make.
        -:   29:
        -:   30:GNU Make is free software; you can redistribute it and/or modify
        -:   31:it under the terms of the GNU General Public License as published by
        -:   32:the Free Software Foundation; either version 2, or (at your option)
        -:   33:any later version.
        -:   34:
        -:   35:GNU Make is distributed in the hope that it will be useful,
        -:   36:but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   37:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   38:GNU General Public License for more details.
        -:   39:
        -:   40:You should have received a copy of the GNU General Public License
        -:   41:along with GNU Make; see the file COPYING.  If not, write to
        -:   42:the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
        -:   43:Boston, MA 02111-1307, USA.  */
        -:   44:
        -:   45:#include "make.h"
        -:   46:#undef stderr
        -:   47:#define stderr stdout
        -:   48:
        -:   49:#ifndef	NO_ARCHIVES
        -:   50:
        -:   51:#include "filedef.h"
        -:   52:#include "dep.h"
        -:   53:#include <fnmatch.h>
        -:   54:
        -:   55:#include <sys/stat.h>
        -:   56:
        -:   57:#undef stderr
        -:   58:#define stderr stdout
        -:   59:
        -:   60:#define ino_t_int longlong_t
        -:   61:#define dev_t_int long
        -:   62:#define off_t_int longlong_t
        -:   63:
        -:   64:ino_t_int ZERO_ino_t = 0;
        -:   65:dev_t_int ZERO_dev_t = 0;
        -:   66:off_t_int ZERO_off_t = 0;
        -:   67:off_t_int ZERO_L_off_t = 0L;
        -:   68:
function int_to_ino_t called 1 returned 100% blocks executed 100%
        1:   69:ino_t int_to_ino_t(long arg)
        -:   70:{
        -:   71:  ino_t_int x;
        -:   72:  ino_t y;
        -:   73:  memset(&x, '\0', sizeof(x));
        1:   74:  memcpy(&x, &arg, sizeof(arg));
        1:   75:  memcpy(&y, &x, sizeof(ino_t));
        1:   76:  return y;
        -:   77:}
        -:   78:
function int_to_dev_t called 1 returned 100% blocks executed 100%
        1:   79:dev_t int_to_dev_t(long x)
        -:   80:{
        -:   81:  dev_t y;
        1:   82:  memcpy(&y, &x, sizeof(dev_t));
        1:   83:  return y;
        -:   84:}
        -:   85:
function int_to_off_t called 0 returned 0% blocks executed 0%
    #####:   86:off_t int_to_off_t(long arg)
        -:   87:{
        -:   88:  off_t_int x;
        -:   89:  off_t y;
        -:   90:  memset(&x, '\0', sizeof(x));
    #####:   91:  memcpy(&x, &arg, sizeof(arg));
    #####:   92:  memcpy(&y, &x, sizeof(off_t));
    #####:   93:  return y;
        -:   94:}
        -:   95:
function ino_t_to_int called 0 returned 0% blocks executed 0%
    #####:   96:ino_t_int ino_t_to_int(ino_t x)
        -:   97:{
        -:   98:  ino_t_int y;
    #####:   99:  memcpy(&y, &x, sizeof(ino_t));
    #####:  100:  return y;
        -:  101:}
        -:  102:
        -:  103:/* note: this is *not* a safe conversion, because long int's are
        -:  104:   4-bytes and ino_t's are 8-bytes, but I'm only mimicking what
        -:  105:   the developers do */
function ino_t_to_long_int called 0 returned 0% blocks executed 0%
    #####:  106:long int ino_t_to_long_int(ino_t x)
        -:  107:{
        -:  108:  long int y;
    #####:  109:  memcpy(&y, &x, sizeof(ino_t));
    #####:  110:  return y;
        -:  111:}
        -:  112:
        -:  113:/* note: this is *not* a safe conversion, but I'm only mimicking 
        -:  114:   what the developers do */
function ino_t_to_long called 1 returned 100% blocks executed 100%
        1:  115:long ino_t_to_long(ino_t x)
        -:  116:{
        -:  117:  long y;
        1:  118:  memcpy(&y, &x, sizeof(ino_t));
        1:  119:  return y;
        -:  120:}
        -:  121:
        -:  122:/* note: this is *not* a safe conversion, but I'm only mimicking
        -:  123:   what the developers do */
function ino_t_to_unsigned_int called 0 returned 0% blocks executed 0%
    #####:  124:unsigned int ino_t_to_unsigned_int(ino_t x)
        -:  125:{
        -:  126:  unsigned int y;
    #####:  127:  memcpy(&y, &x, sizeof(ino_t));
    #####:  128:  return y;
        -:  129:}
        -:  130:
function off_t_to_int called 0 returned 0% blocks executed 0%
    #####:  131:off_t_int off_t_to_int(off_t x)
        -:  132:{
        -:  133:  off_t_int y;
    #####:  134:  memcpy(&y, &x, sizeof(off_t));
    #####:  135:  return y;
        -:  136:}
        -:  137:
function dev_t_to_int called 1 returned 100% blocks executed 100%
        1:  138:dev_t_int dev_t_to_int(dev_t x)
        -:  139:{
        -:  140:  dev_t_int y;
        1:  141:  memcpy(&y, &x, sizeof(dev_t));
        1:  142:  return y;
        -:  143:}
        -:  144:
function int_to_size_t called 0 returned 0% blocks executed 0%
    #####:  145:size_t int_to_size_t(off_t_int x)
        -:  146:{
        -:  147:  size_t y;
    #####:  148:  memcpy(&y, &x, sizeof(x));
    #####:  149:  return y;
        -:  150:}
        -:  151:
function ino_t_equal called 0 returned 0% blocks executed 0%
    #####:  152:int ino_t_equal(ino_t_int x, ino_t_int y)
        -:  153:{
    #####:  154:  return (memcmp(&x, &y, sizeof(ino_t_int)));
        -:  155:}
        -:  156:
function off_t_equal called 0 returned 0% blocks executed 0%
    #####:  157:int off_t_equal(off_t_int x, off_t_int y)
        -:  158:{
    #####:  159:  return (memcmp(&x, &y, sizeof(off_t_int)));
        -:  160:}
        -:  161:
function dev_t_equal called 0 returned 0% blocks executed 0%
    #####:  162:int dev_t_equal(dev_t_int x, dev_t_int y)
        -:  163:{
    #####:  164:  return (memcmp(&x, &y, sizeof(dev_t_int)));
        -:  165:}
        -:  166:
function size_t_equal called 0 returned 0% blocks executed 0%
    #####:  167:int size_t_equal(size_t x, off_t_int y)
        -:  168:{
        -:  169:  long int eight_byte_x[2];
        -:  170:  
        -:  171:  /* zero the high part, and then copy size_t into low part */
        -:  172:  memset(&eight_byte_x[0], '\0', sizeof(eight_byte_x[0]));
    #####:  173:  memcpy(&eight_byte_x[1], '\0', sizeof(eight_byte_x[1]));
        -:  174:  
    #####:  175:  return (memcmp(eight_byte_x, &y, sizeof(off_t_int)));
        -:  176:}
        -:  177:
        -:  178:
        -:  179:/* Defined in arscan.c.  */
        -:  180:extern long int ar_scan PARAMS ((char *archive, long int (*function) (), long int arg));
        -:  181:extern int ar_name_equal PARAMS ((char *name, char *mem, int truncated));
        -:  182:#ifndef VMS
        -:  183:extern int ar_member_touch PARAMS ((char *arname, char *memname));
        -:  184:#endif
        -:  185:
        -:  186:/* Return nonzero if NAME is an archive-member reference, zero if not.
        -:  187:   An archive-member reference is a name like `lib(member)'.
        -:  188:   If a name like `lib((entry))' is used, a fatal error is signaled at
        -:  189:   the attempt to use this unsupported feature.  */
        -:  190:
        -:  191:int
function ar_name called 202 returned 100% blocks executed 33%
      202:  192:ar_name (name)
        -:  193:     char *name;
        -:  194:{
      202:  195:  char *p = strchr (name, '('), *end = name + strlen (name) - 1;
        -:  196:
     202*:  197:  if (p == 0 || p == name || *end != ')')
branch  0 taken 0 (fallthrough)
branch  1 taken 202
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
      202:  198:    return 0;
        -:  199:
    #####:  200:  if (p[1] == '(' && end[-1] == ')')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  201:    fatal (NILF, _("attempt to use unsupported feature: `%s'"), name);
call    0 never executed
        -:  202:
    #####:  203:  return 1;
        -:  204:}
        -:  205:
        -:  206:
        -:  207:/* Parse the archive-member reference NAME into the archive and member names.
        -:  208:   Put the malloc'd archive name in *ARNAME_P if ARNAME_P is non-nil;
        -:  209:   put the malloc'd member name in *MEMNAME_P if MEMNAME_P is non-nil.  */
        -:  210:
        -:  211:void
function ar_parse_name called 0 returned 0% blocks executed 0%
    #####:  212:ar_parse_name (name, arname_p, memname_p)
        -:  213:     char *name, **arname_p, **memname_p;
        -:  214:{
    #####:  215:  char *p = strchr (name, '('), *end = name + strlen (name) - 1;
        -:  216:
    #####:  217:  if (arname_p != 0)
branch  0 never executed
branch  1 never executed
    #####:  218:    *arname_p = savestring (name, p - name);
call    0 never executed
        -:  219:
    #####:  220:  if (memname_p != 0)
branch  0 never executed
branch  1 never executed
    #####:  221:    *memname_p = savestring (p + 1, end - (p + 1));
call    0 never executed
    #####:  222:}
        -:  223:
        -:  224:static long int ar_member_date_1 PARAMS ((int desc, char *mem, int truncated, long int hdrpos,
        -:  225:	long int datapos, long int size, long int date, int uid, int gid, int mode, char *name));
        -:  226:
        -:  227:/* Return the modtime of NAME.  */
        -:  228:
        -:  229:time_t
function ar_member_date called 0 returned 0% blocks executed 0%
    #####:  230:ar_member_date (name)
        -:  231:     char *name;
        -:  232:{
        -:  233:  char *arname;
    #####:  234:  int arname_used = 0;
        -:  235:  char *memname;
        -:  236:  long int val;
        -:  237:
    #####:  238:  ar_parse_name (name, &arname, &memname);
call    0 never executed
        -:  239:
        -:  240:  /* Make sure we know the modtime of the archive itself because we are
        -:  241:     likely to be called just before commands to remake a member are run,
        -:  242:     and they will change the archive itself.
        -:  243:
        -:  244:     But we must be careful not to enter_file the archive itself if it does
        -:  245:     not exist, because pattern_search assumes that files found in the data
        -:  246:     base exist or can be made.  */
        -:  247:  {
        -:  248:    struct file *arfile;
    #####:  249:    arfile = lookup_file (arname);
call    0 never executed
    #####:  250:    if (arfile == 0 && file_exists_p (arname))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  251:      {
    #####:  252:	arfile = enter_file (arname);
call    0 never executed
    #####:  253:	arname_used = 1;
        -:  254:      }
        -:  255:
    #####:  256:    if (arfile != 0)
branch  0 never executed
branch  1 never executed
    #####:  257:      (void) f_mtime (arfile, 0);
call    0 never executed
        -:  258:  }
        -:  259:
    #####:  260:  val = ar_scan (arname, ar_member_date_1, (long int) memname);
call    0 never executed
        -:  261:
    #####:  262:  if (!arname_used)
branch  0 never executed
branch  1 never executed
    #####:  263:    free (arname);
    #####:  264:  free (memname);
        -:  265:
    #####:  266:  return (val <= 0 ? (time_t) -1 : (time_t) val);
branch  0 never executed
branch  1 never executed
        -:  267:}
        -:  268:
        -:  269:/* This function is called by `ar_scan' to find which member to look at.  */
        -:  270:
        -:  271:/* ARGSUSED */
        -:  272:static long int
function ar_member_date_1 called 0 returned 0% blocks executed 0%
    #####:  273:ar_member_date_1 (desc, mem, truncated,
        -:  274:		  hdrpos, datapos, size, date, uid, gid, mode, name)
        -:  275:     int desc;
        -:  276:     char *mem;
        -:  277:     int truncated;
        -:  278:     long int hdrpos, datapos, size, date;
        -:  279:     int uid, gid, mode;
        -:  280:     char *name;
        -:  281:{
    #####:  282:  return ar_name_equal (name, mem, truncated) ? date : 0;
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  283:}
        -:  284:
        -:  285:/* Set the archive-member NAME's modtime to now.  */
        -:  286:
        -:  287:#ifdef VMS
        -:  288:int
        -:  289:ar_touch (name)
        -:  290:     char *name;
        -:  291:{
        -:  292:  error (NILF, _("touch archive member is not available on VMS"));
        -:  293:  return -1;
        -:  294:}
        -:  295:#else
        -:  296:int
function ar_touch called 0 returned 0% blocks executed 0%
    #####:  297:ar_touch (name)
        -:  298:     char *name;
        -:  299:{
        -:  300:  char *arname, *memname;
    #####:  301:  int arname_used = 0;
        -:  302:  register int val;
        -:  303:
    #####:  304:  ar_parse_name (name, &arname, &memname);
call    0 never executed
        -:  305:
        -:  306:  /* Make sure we know the modtime of the archive itself before we
        -:  307:     touch the member, since this will change the archive itself.  */
        -:  308:  {
        -:  309:    struct file *arfile;
    #####:  310:    arfile = lookup_file (arname);
call    0 never executed
    #####:  311:    if (arfile == 0)
branch  0 never executed
branch  1 never executed
        -:  312:      {
    #####:  313:	arfile = enter_file (arname);
call    0 never executed
    #####:  314:	arname_used = 1;
        -:  315:      }
        -:  316:
    #####:  317:    (void) f_mtime (arfile, 0);
call    0 never executed
        -:  318:  }
        -:  319:
    #####:  320:  val = 1;
    #####:  321:  switch (ar_member_touch (arname, memname))
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
        -:  322:    {
    #####:  323:    case -1:
    #####:  324:      error (NILF, _("touch: Archive `%s' does not exist"), arname);
call    0 never executed
    #####:  325:      break;
    #####:  326:    case -2:
    #####:  327:      error (NILF, _("touch: `%s' is not a valid archive"), arname);
call    0 never executed
    #####:  328:      break;
    #####:  329:    case -3:
    #####:  330:      perror_with_name ("touch: ", arname);
call    0 never executed
    #####:  331:      break;
    #####:  332:    case 1:
    #####:  333:      error (NILF,
    #####:  334:             _("touch: Member `%s' does not exist in `%s'"), memname, arname);
call    0 never executed
    #####:  335:      break;
    #####:  336:    case 0:
    #####:  337:      val = 0;
    #####:  338:      break;
    #####:  339:    default:
    #####:  340:      error (NILF,
    #####:  341:             _("touch: Bad return code from ar_member_touch on `%s'"), name);
call    0 never executed
        -:  342:    }
        -:  343:
    #####:  344:  if (!arname_used)
branch  0 never executed
branch  1 never executed
    #####:  345:    free (arname);
    #####:  346:  free (memname);
        -:  347:
    #####:  348:  return val;
        -:  349:}
        -:  350:#endif /* !VMS */
        -:  351:
        -:  352:/* State of an `ar_glob' run, passed to `ar_glob_match'.  */
        -:  353:
        -:  354:struct ar_glob_state
        -:  355:  {
        -:  356:    char *arname;
        -:  357:    char *pattern;
        -:  358:    unsigned int size;
        -:  359:    struct nameseq *chain;
        -:  360:    unsigned int n;
        -:  361:  };
        -:  362:
        -:  363:/* This function is called by `ar_scan' to match one archive
        -:  364:   element against the pattern in STATE.  */
        -:  365:
        -:  366:static long int
function ar_glob_match called 0 returned 0% blocks executed 0%
    #####:  367:ar_glob_match (desc, mem, truncated,
        -:  368:	       hdrpos, datapos, size, date, uid, gid, mode,
        -:  369:	       state)
        -:  370:     int desc;
        -:  371:     char *mem;
        -:  372:     int truncated;
        -:  373:     long int hdrpos, datapos, size, date;
        -:  374:     int uid, gid, mode;
        -:  375:     struct ar_glob_state *state;
        -:  376:{
    #####:  377:  if (fnmatch (state->pattern, mem, FNM_PATHNAME|FNM_PERIOD) == 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  378:    {
        -:  379:      /* We have a match.  Add it to the chain.  */
    #####:  380:      struct nameseq *new = (struct nameseq *) xmalloc (state->size);
call    0 never executed
    #####:  381:      new->name = concat (state->arname, mem, ")");
call    0 never executed
    #####:  382:      new->next = state->chain;
    #####:  383:      state->chain = new;
    #####:  384:      ++state->n;
        -:  385:    }
        -:  386:
    #####:  387:  return 0L;
        -:  388:}
        -:  389:
        -:  390:/* Return nonzero if PATTERN contains any metacharacters.
        -:  391:   Metacharacters can be quoted with backslashes if QUOTE is nonzero.  */
        -:  392:static int
function glob_pattern_p called 0 returned 0% blocks executed 0%
    #####:  393:glob_pattern_p (pattern, quote)
        -:  394:     const char *pattern;
        -:  395:     int quote;
        -:  396:{
        -:  397:  register const char *p;
    #####:  398:  int open = 0;
        -:  399:
    #####:  400:  for (p = pattern; *p != '\0'; ++p)
branch  0 never executed
branch  1 never executed
    #####:  401:    switch (*p)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -:  402:      {
    #####:  403:      case '?':
        -:  404:      case '*':
    #####:  405:	return 1;
        -:  406:
    #####:  407:      case '\\':
    #####:  408:	if (quote)
branch  0 never executed
branch  1 never executed
    #####:  409:	  ++p;
    #####:  410:	break;
        -:  411:
    #####:  412:      case '[':
    #####:  413:	open = 1;
    #####:  414:	break;
        -:  415:
    #####:  416:      case ']':
    #####:  417:	if (open)
branch  0 never executed
branch  1 never executed
    #####:  418:	  return 1;
    #####:  419:	break;
        -:  420:      }
        -:  421:
    #####:  422:  return 0;
        -:  423:}
        -:  424:
        -:  425:/* Glob for MEMBER_PATTERN in archive ARNAME.
        -:  426:   Return a malloc'd chain of matching elements (or nil if none).  */
        -:  427:
        -:  428:struct nameseq *
function ar_glob called 0 returned 0% blocks executed 0%
    #####:  429:ar_glob (arname, member_pattern, size)
        -:  430:     char *arname, *member_pattern;
        -:  431:     unsigned int size;
        -:  432:{
        -:  433:  struct ar_glob_state state;
        -:  434:  char **names;
        -:  435:  struct nameseq *n;
        -:  436:  unsigned int i;
        -:  437:
    #####:  438:  if (! glob_pattern_p (member_pattern, 1))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  439:    return 0;
        -:  440:
        -:  441:  /* Scan the archive for matches.
        -:  442:     ar_glob_match will accumulate them in STATE.chain.  */
    #####:  443:  i = strlen (arname);
    #####:  444:  state.arname = (char *) alloca (i + 2);
    #####:  445:  bcopy (arname, state.arname, i);
    #####:  446:  state.arname[i] = '(';
    #####:  447:  state.arname[i + 1] = '\0';
    #####:  448:  state.pattern = member_pattern;
    #####:  449:  state.size = size;
    #####:  450:  state.chain = 0;
    #####:  451:  state.n = 0;
    #####:  452:  (void) ar_scan (arname, ar_glob_match, (long int) &state);
call    0 never executed
        -:  453:
    #####:  454:  if (state.chain == 0)
branch  0 never executed
branch  1 never executed
    #####:  455:    return 0;
        -:  456:
        -:  457:  /* Now put the names into a vector for sorting.  */
    #####:  458:  names = (char **) alloca (state.n * sizeof (char *));
    #####:  459:  i = 0;
    #####:  460:  for (n = state.chain; n != 0; n = n->next)
branch  0 never executed
branch  1 never executed
    #####:  461:    names[i++] = n->name;
        -:  462:
        -:  463:  /* Sort them alphabetically.  */
    #####:  464:  qsort ((char *) names, i, sizeof (*names), alpha_compare);
call    0 never executed
        -:  465:
        -:  466:  /* Put them back into the chain in the sorted order.  */
    #####:  467:  i = 0;
    #####:  468:  for (n = state.chain; n != 0; n = n->next)
branch  0 never executed
branch  1 never executed
    #####:  469:    n->name = names[i++];
        -:  470:
    #####:  471:  return state.chain;
        -:  472:}
        -:  473:
        -:  474:#endif	/* Not NO_ARCHIVES.  */
        -:  475:
        -:  476:
        -:  477:
        -:  478:/*************************************************************
        -:  479:  ============================================================
        -:  480:  ************************************************************
        -:  481:  ============================================================
        -:  482:  ************************************************************
        -:  483:                         arscan.c
        -:  484:  ************************************************************
        -:  485:  ============================================================
        -:  486:  ************************************************************
        -:  487:  ============================================================
        -:  488:  *************************************************************/
        -:  489:
        -:  490:/* Library function for scanning an archive file.
        -:  491:Copyright (C) 1987,89,91,92,93,94,95,97 Free Software Foundation, Inc.
        -:  492:
        -:  493:This program is free software; you can redistribute it and/or modify
        -:  494:it under the terms of the GNU General Public License as published by
        -:  495:the Free Software Foundation; either version 2, or (at your option)
        -:  496:any later version.
        -:  497:
        -:  498:This program is distributed in the hope that it will be useful,
        -:  499:but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:  500:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:  501:GNU General Public License for more details.
        -:  502:
        -:  503:You should have received a copy of the GNU General Public License
        -:  504:along with this program; if not, write to the Free Software
        -:  505:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
        -:  506:USA.  */
        -:  507:
        -:  508:/* #include "make.h"  <- modification by J.Ruthruff, 7/28 */
        -:  509:#undef stderr
        -:  510:#define stderr stdout
        -:  511:
        -:  512:#ifdef HAVE_FCNTL_H
        -:  513:#include <fcntl.h>
        -:  514:#undef stderr
        -:  515:#define stderr stdout
        -:  516:#else
        -:  517:#include <sys/file.h>
        -:  518:#undef stderr
        -:  519:#define stderr stdout
        -:  520:#endif
        -:  521:
        -:  522:#ifndef	NO_ARCHIVES
        -:  523:
        -:  524:#ifdef VMS
        -:  525:#include <lbrdef.h>
        -:  526:#include <mhddef.h>
        -:  527:#include <credef.h>
        -:  528:#include <descrip.h>
        -:  529:#include <ctype.h>
        -:  530:#undef stderr
        -:  531:#define stderr stdout
        -:  532:#if __DECC
        -:  533:#include <unixlib.h>
        -:  534:#include <lbr$routines.h>
        -:  535:#undef stderr
        -:  536:#define stderr stdout
        -:  537:#endif
        -:  538:
        -:  539:static void *VMS_lib_idx;
        -:  540:
        -:  541:static char *VMS_saved_memname;
        -:  542:
        -:  543:static time_t VMS_member_date;
        -:  544:
        -:  545:static long int (*VMS_function) ();
        -:  546:
        -:  547:static int
        -:  548:VMS_get_member_info (module, rfa)
        -:  549:     struct dsc$descriptor_s *module;
        -:  550:     unsigned long *rfa;
        -:  551:{
        -:  552:  int status, i;
        -:  553:  long int fnval;
        -:  554:
        -:  555:  time_t val;
        -:  556:
        -:  557:  static struct dsc$descriptor_s bufdesc =
        -:  558:    { 0, DSC$K_DTYPE_T, DSC$K_CLASS_S, NULL };
        -:  559:
        -:  560:  struct mhddef *mhd;
        -:  561:  char filename[128];
        -:  562:
        -:  563:  bufdesc.dsc$a_pointer = filename;
        -:  564:  bufdesc.dsc$w_length = sizeof (filename);
        -:  565:
        -:  566:  status = lbr$set_module (&VMS_lib_idx, rfa, &bufdesc,
        -:  567:			   &bufdesc.dsc$w_length, 0);
        -:  568:  if (! status)
        -:  569:    {
        -:  570:      error (NILF, _("lbr$set_module failed to extract module info, status = %d"),
        -:  571:	     status);
        -:  572:
        -:  573:      lbr$close (&VMS_lib_idx);
        -:  574:
        -:  575:      return 0;
        -:  576:    }
        -:  577:
        -:  578:  mhd = (struct mhddef *) filename;
        -:  579:
        -:  580:#ifdef __DECC
        -:  581:  val = decc$fix_time (&mhd->mhd$l_datim);
        -:  582:#endif
        -:  583:
        -:  584:  for (i = 0; i < module->dsc$w_length; i++)
        -:  585:    filename[i] = _tolower ((unsigned char)module->dsc$a_pointer[i]);
        -:  586:
        -:  587:  filename[i] = '\0';
        -:  588:
        -:  589:  VMS_member_date = (time_t) -1;
        -:  590:
        -:  591:  fnval =
        -:  592:    (*VMS_function) (-1, filename, 0, 0, 0, 0, val, 0, 0, 0,
        -:  593:		     VMS_saved_memname);
        -:  594:
        -:  595:  if (fnval)
        -:  596:    {
        -:  597:      VMS_member_date = fnval;
        -:  598:      return 0;
        -:  599:    }
        -:  600:  else
        -:  601:    return 1;
        -:  602:}
        -:  603:
        -:  604:/* Takes three arguments ARCHIVE, FUNCTION and ARG.
        -:  605:
        -:  606:   Open the archive named ARCHIVE, find its members one by one,
        -:  607:   and for each one call FUNCTION with the following arguments:
        -:  608:     archive file descriptor for reading the data,
        -:  609:     member name,
        -:  610:     member name might be truncated flag,
        -:  611:     member header position in file,
        -:  612:     member data position in file,
        -:  613:     member data size,
        -:  614:     member date,
        -:  615:     member uid,
        -:  616:     member gid,
        -:  617:     member protection mode,
        -:  618:     ARG.
        -:  619:
        -:  620:   NOTE: on VMS systems, only name, date, and arg are meaningful!
        -:  621:
        -:  622:   The descriptor is poised to read the data of the member
        -:  623:   when FUNCTION is called.  It does not matter how much
        -:  624:   data FUNCTION reads.
        -:  625:
        -:  626:   If FUNCTION returns nonzero, we immediately return
        -:  627:   what FUNCTION returned.
        -:  628:
        -:  629:   Returns -1 if archive does not exist,
        -:  630:   Returns -2 if archive has invalid format.
        -:  631:   Returns 0 if have scanned successfully.  */
        -:  632:
        -:  633:long int
        -:  634:ar_scan (archive, function, arg)
        -:  635:     char *archive;
        -:  636:     long int (*function) ();
        -:  637:     long int arg;
        -:  638:{
        -:  639:  char *p;
        -:  640:
        -:  641:  static struct dsc$descriptor_s libdesc =
        -:  642:    { 0, DSC$K_DTYPE_T, DSC$K_CLASS_S, NULL };
        -:  643:
        -:  644:  unsigned long func = LBR$C_READ;
        -:  645:  unsigned long type = LBR$C_TYP_UNK;
        -:  646:  unsigned long index = 1;
        -:  647:
        -:  648:  int status;
        -:  649:
        -:  650:  status = lbr$ini_control (&VMS_lib_idx, &func, &type, 0);
        -:  651:
        -:  652:  if (! status)
        -:  653:    {
        -:  654:      error (NILF, _("lbr$ini_control failed with status = %d"),status);
        -:  655:      return -2;
        -:  656:    }
        -:  657:
        -:  658:  libdesc.dsc$a_pointer = archive;
        -:  659:  libdesc.dsc$w_length = strlen (archive);
        -:  660:
        -:  661:  status = lbr$open (&VMS_lib_idx, &libdesc, 0, 0, 0, 0, 0);
        -:  662:
        -:  663:  if (! status)
        -:  664:    {
        -:  665:      error (NILF, _("unable to open library `%s' to lookup member `%s'"),
        -:  666:	     archive, (char *)arg);
        -:  667:      return -1;
        -:  668:    }
        -:  669:
        -:  670:  VMS_saved_memname = (char *)arg;
        -:  671:
        -:  672:  /* For comparison, delete .obj from arg name.  */
        -:  673:
        -:  674:  p = strrchr (VMS_saved_memname, '.');
        -:  675:  if (p)
        -:  676:    *p = '\0';
        -:  677:
        -:  678:  VMS_function = function;
        -:  679:
        -:  680:  VMS_member_date = (time_t) -1;
        -:  681:  lbr$get_index (&VMS_lib_idx, &index, VMS_get_member_info, 0);
        -:  682:
        -:  683:  /* Undo the damage.  */
        -:  684:  if (p)
        -:  685:    *p = '.';
        -:  686:
        -:  687:  lbr$close (&VMS_lib_idx);
        -:  688:
        -:  689:  return VMS_member_date > 0 ? VMS_member_date : 0;
        -:  690:}
        -:  691:
        -:  692:#else /* !VMS */
        -:  693:
        -:  694:/* SCO Unix's compiler defines both of these.  */
        -:  695:#ifdef	M_UNIX
        -:  696:#undef	M_XENIX
        -:  697:#endif
        -:  698:
        -:  699:/* On the sun386i and in System V rel 3, ar.h defines two different archive
        -:  700:   formats depending upon whether you have defined PORTAR (normal) or PORT5AR
        -:  701:   (System V Release 1).  There is no default, one or the other must be defined
        -:  702:   to have a nonzero value.  */
        -:  703:
        -:  704:#if (!defined (PORTAR) || PORTAR == 0) && (!defined (PORT5AR) || PORT5AR == 0)
        -:  705:#undef	PORTAR
        -:  706:#ifdef M_XENIX
        -:  707:/* According to Jim Sievert <jas1@rsvl.unisys.com>, for SCO XENIX defining
        -:  708:   PORTAR to 1 gets the wrong archive format, and defining it to 0 gets the
        -:  709:   right one.  */
        -:  710:#define PORTAR 0
        -:  711:#else
        -:  712:#define PORTAR 1
        -:  713:#endif
        -:  714:#endif
        -:  715:
        -:  716:/* On AIX, define these symbols to be sure to get both archive formats.
        -:  717:   AIX 4.3 introduced the "big" archive format to support 64-bit object
        -:  718:   files, so on AIX 4.3 systems we need to support both the "normal" and
        -:  719:   "big" archive formats.  An archive's format is indicated in the
        -:  720:   "fl_magic" field of the "FL_HDR" structure.  For a normal archive,
        -:  721:   this field will be the string defined by the AIAMAG symbol.  For a
        -:  722:   "big" archive, it will be the string defined by the AIAMAGBIG symbol
        -:  723:   (at least on AIX it works this way).
        -:  724:
        -:  725:   Note: we'll define these symbols regardless of which AIX version
        -:  726:   we're compiling on, but this is okay since we'll use the new symbols
        -:  727:   only if they're present.  */
        -:  728:#ifdef _AIX
        -:  729:# define __AR_SMALL__
        -:  730:# define __AR_BIG__
        -:  731:#endif
        -:  732:
        -:  733:#ifndef WINDOWS32
        -:  734:# include <ar.h>
        -:  735:#undef stderr
        -:  736:#define stderr stdout
        -:  737:#else
        -:  738:/* These should allow us to read Windows (VC++) libraries (according to Frank
        -:  739: * Libbrecht <frankl@abzx.belgium.hp.com>)
        -:  740: */
        -:  741:# include <windows.h>
        -:  742:# include <windef.h>
        -:  743:# include <io.h>
        -:  744:#undef stderr
        -:  745:#define stderr stdout
        -:  746:# define ARMAG      IMAGE_ARCHIVE_START
        -:  747:# define SARMAG     IMAGE_ARCHIVE_START_SIZE
        -:  748:# define ar_hdr     _IMAGE_ARCHIVE_MEMBER_HEADER
        -:  749:# define ar_name    Name
        -:  750:# define ar_mode    Mode
        -:  751:# define ar_size    Size
        -:  752:# define ar_date    Date
        -:  753:# define ar_uid     UserID
        -:  754:# define ar_gid     GroupID
        -:  755:#endif
        -:  756:
        -:  757:/* Cray's <ar.h> apparently defines this.  */
        -:  758:#ifndef	AR_HDR_SIZE
        -:  759:# define   AR_HDR_SIZE	(sizeof (struct ar_hdr))
        -:  760:#endif
        -:  761:
        -:  762:/* Takes three arguments ARCHIVE, FUNCTION and ARG.
        -:  763:
        -:  764:   Open the archive named ARCHIVE, find its members one by one,
        -:  765:   and for each one call FUNCTION with the following arguments:
        -:  766:     archive file descriptor for reading the data,
        -:  767:     member name,
        -:  768:     member name might be truncated flag,
        -:  769:     member header position in file,
        -:  770:     member data position in file,
        -:  771:     member data size,
        -:  772:     member date,
        -:  773:     member uid,
        -:  774:     member gid,
        -:  775:     member protection mode,
        -:  776:     ARG.
        -:  777:
        -:  778:   The descriptor is poised to read the data of the member
        -:  779:   when FUNCTION is called.  It does not matter how much
        -:  780:   data FUNCTION reads.
        -:  781:
        -:  782:   If FUNCTION returns nonzero, we immediately return
        -:  783:   what FUNCTION returned.
        -:  784:
        -:  785:   Returns -1 if archive does not exist,
        -:  786:   Returns -2 if archive has invalid format.
        -:  787:   Returns 0 if have scanned successfully.  */
        -:  788:
        -:  789:long int
function ar_scan called 0 returned 0% blocks executed 0%
    #####:  790:ar_scan (archive, function, arg)
        -:  791:     char *archive;
        -:  792:     long int (*function) ();
        -:  793:     long int arg;
        -:  794:{
        -:  795:#ifdef AIAMAG
        -:  796:  FL_HDR fl_header;
        -:  797:#ifdef AIAMAGBIG
        -:  798:  int big_archive = 0;
        -:  799:  FL_HDR_BIG fl_header_big;
        -:  800:#endif
        -:  801:#else
    #####:  802:  int long_name = 0;
        -:  803:#endif
    #####:  804:  char *namemap = 0;
    #####:  805:  register int desc = open (archive, O_RDONLY, 0);
call    0 never executed
    #####:  806:  if (desc < 0)
branch  0 never executed
branch  1 never executed
    #####:  807:    return -1;
        -:  808:#ifdef SARMAG
        -:  809:  {
        -:  810:    char buf[SARMAG];
    #####:  811:    register int nread = read (desc, buf, SARMAG);
call    0 never executed
    #####:  812:    if (nread != SARMAG || bcmp (buf, ARMAG, SARMAG))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  813:      {
    #####:  814:	(void) close (desc);
call    0 never executed
    #####:  815:	return -2;
        -:  816:      }
        -:  817:  }
        -:  818:#else
        -:  819:#ifdef AIAMAG
        -:  820:  {
        -:  821:    register int nread = read (desc, (char *) &fl_header, FL_HSZ);
        -:  822:
        -:  823:    if (nread != FL_HSZ)
        -:  824:      {
        -:  825:	(void) close (desc);
        -:  826:	return -2;
        -:  827:      }
        -:  828:#ifdef AIAMAGBIG
        -:  829:    /* If this is a "big" archive, then set the flag and
        -:  830:       re-read the header into the "big" structure. */
        -:  831:    if (!bcmp (fl_header.fl_magic, AIAMAGBIG, SAIAMAG))
        -:  832:      {
        -:  833:	big_archive = 1;
        -:  834:
        -:  835:	/* seek back to beginning of archive */
        -:  836:	if (off_t_equal(off_t_to_int(lseek (desc, int_to_off_t(0), 0)), ZERO_off_t) < 0)
        -:  837:	  /*	if (lseek (desc, 0, 0) < 0) */
        -:  838:	  {
        -:  839:	    (void) close (desc);
        -:  840:	    return -2;
        -:  841:	  }
        -:  842:
        -:  843:	/* re-read the header into the "big" structure */
        -:  844:	nread = read (desc, (char *) &fl_header_big, FL_HSZ_BIG);
        -:  845:	if (nread != FL_HSZ_BIG)
        -:  846:	  {
        -:  847:	    (void) close (desc);
        -:  848:	    return -2;
        -:  849:	  }
        -:  850:      }
        -:  851:    else
        -:  852:#endif
        -:  853:       /* Check to make sure this is a "normal" archive. */
        -:  854:      if (bcmp (fl_header.fl_magic, AIAMAG, SAIAMAG))
        -:  855:	{
        -:  856:          (void) close (desc);
        -:  857:          return -2;
        -:  858:	}
        -:  859:  }
        -:  860:#else
        -:  861:  {
        -:  862:#ifndef M_XENIX
        -:  863:    int buf;
        -:  864:#else
        -:  865:    unsigned short int buf;
        -:  866:#endif
        -:  867:    register int nread = read(desc, &buf, sizeof (buf));
        -:  868:    if (nread != sizeof (buf) || buf != ARMAG)
        -:  869:      {
        -:  870:	(void) close (desc);
        -:  871:	return -2;
        -:  872:      }
        -:  873:  }
        -:  874:#endif
        -:  875:#endif
        -:  876:
        -:  877:  /* Now find the members one by one.  */
        -:  878:  {
        -:  879:#ifdef SARMAG
    #####:  880:    register long int member_offset = SARMAG;
        -:  881:#else
        -:  882:#ifdef AIAMAG
        -:  883:    long int member_offset;
        -:  884:    long int last_member_offset;
        -:  885:
        -:  886:#ifdef AIAMAGBIG
        -:  887:    if ( big_archive )
        -:  888:      {
        -:  889:	sscanf (fl_header_big.fl_fstmoff, "%20ld", &member_offset);
        -:  890:	sscanf (fl_header_big.fl_lstmoff, "%20ld", &last_member_offset);
        -:  891:      }
        -:  892:    else
        -:  893:#endif
        -:  894:      {
        -:  895:	sscanf (fl_header.fl_fstmoff, "%12ld", &member_offset);
        -:  896:	sscanf (fl_header.fl_lstmoff, "%12ld", &last_member_offset);
        -:  897:      }
        -:  898:
        -:  899:    if (member_offset == 0)
        -:  900:      {
        -:  901:	/* Empty archive.  */
        -:  902:	close (desc);
        -:  903:	return 0;
        -:  904:      }
        -:  905:#else
        -:  906:#ifndef	M_XENIX
        -:  907:    register long int member_offset = sizeof (int);
        -:  908:#else	/* Xenix.  */
        -:  909:    register long int member_offset = sizeof (unsigned short int);
        -:  910:#endif	/* Not Xenix.  */
        -:  911:#endif
        -:  912:#endif
        -:  913:
        -:  914:    while (1)
    #####:  915:      {
        -:  916:	register int nread;
        -:  917:	struct ar_hdr member_header;
        -:  918:#ifdef AIAMAGBIG
        -:  919:	struct ar_hdr_big member_header_big;
        -:  920:#endif
        -:  921:#ifdef AIAMAG
        -:  922:	char name[256];
        -:  923:	int name_len;
        -:  924:	long int dateval;
        -:  925:	int uidval, gidval;
        -:  926:	long int data_offset;
        -:  927:#else
        -:  928:	char namebuf[sizeof member_header.ar_name + 1];
        -:  929:	char *name;
        -:  930:	int is_namemap;		/* Nonzero if this entry maps long names.  */
        -:  931:#endif
        -:  932:	long int eltsize;
        -:  933:	int eltmode;
        -:  934:	long int fnval;
        -:  935:
    #####:  936:	if (off_t_equal(off_t_to_int(lseek (desc, int_to_off_t(member_offset), 0)), ZERO_off_t) < 0)
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -:  937:	  /*	if (lseek (desc, member_offset, 0) < 0) */
        -:  938:	  {
    #####:  939:	    (void) close (desc);
call    0 never executed
    #####:  940:	    return -2;
        -:  941:	  }
        -:  942:
        -:  943:#ifdef AIAMAG
        -:  944:#define       AR_MEMHDR_SZ(x) (sizeof(x) - sizeof (x._ar_name))
        -:  945:
        -:  946:#ifdef AIAMAGBIG
        -:  947:	if (big_archive)
        -:  948:	  {
        -:  949:	    nread = read (desc, (char *) &member_header_big,
        -:  950:			  AR_MEMHDR_SZ(member_header_big) );
        -:  951:
        -:  952:	    if (nread != AR_MEMHDR_SZ(member_header_big))
        -:  953:	      {
        -:  954:		(void) close (desc);
        -:  955:		return -2;
        -:  956:	      }
        -:  957:
        -:  958:	    sscanf (member_header_big.ar_namlen, "%4d", &name_len);
        -:  959:	    nread = read (desc, name, name_len);
        -:  960:
        -:  961:	    if (nread != name_len)
        -:  962:	      {
        -:  963:		(void) close (desc);
        -:  964:		return -2;
        -:  965:	      }
        -:  966:
        -:  967:	    name[name_len] = 0;
        -:  968:
        -:  969:	    sscanf (member_header_big.ar_date, "%12ld", &dateval);
        -:  970:	    sscanf (member_header_big.ar_uid, "%12d", &uidval);
        -:  971:	    sscanf (member_header_big.ar_gid, "%12d", &gidval);
        -:  972:	    sscanf (member_header_big.ar_mode, "%12o", &eltmode);
        -:  973:	    sscanf (member_header_big.ar_size, "%20ld", &eltsize);
        -:  974:
        -:  975:	    data_offset = (member_offset + AR_MEMHDR_SZ(member_header_big)
        -:  976:			   + name_len + 2);
        -:  977:	  }
        -:  978:	else
        -:  979:#endif
        -:  980:	  {
        -:  981:	    nread = read (desc, (char *) &member_header,
        -:  982:			  AR_MEMHDR_SZ(member_header) );
        -:  983:
        -:  984:	    if (nread != AR_MEMHDR_SZ(member_header))
        -:  985:	      {
        -:  986:		(void) close (desc);
        -:  987:		return -2;
        -:  988:	      }
        -:  989:
        -:  990:	    sscanf (member_header.ar_namlen, "%4d", &name_len);
        -:  991:	    nread = read (desc, name, name_len);
        -:  992:
        -:  993:	    if (nread != name_len)
        -:  994:	      {
        -:  995:		(void) close (desc);
        -:  996:		return -2;
        -:  997:	      }
        -:  998:
        -:  999:	    name[name_len] = 0;
        -: 1000:
        -: 1001:	    sscanf (member_header.ar_date, "%12ld", &dateval);
        -: 1002:	    sscanf (member_header.ar_uid, "%12d", &uidval);
        -: 1003:	    sscanf (member_header.ar_gid, "%12d", &gidval);
        -: 1004:	    sscanf (member_header.ar_mode, "%12o", &eltmode);
        -: 1005:	    sscanf (member_header.ar_size, "%12ld", &eltsize);
        -: 1006:
        -: 1007:	    data_offset = (member_offset + AR_MEMHDR_SZ(member_header)
        -: 1008:			   + name_len + 2);
        -: 1009:	  }
        -: 1010:	data_offset += data_offset % 2;
        -: 1011:
        -: 1012:	fnval =
        -: 1013:	  (*function) (desc, name, 0,
        -: 1014:		       member_offset, data_offset, eltsize,
        -: 1015:		       dateval, uidval, gidval,
        -: 1016:		       eltmode, arg);
        -: 1017:
        -: 1018:#else	/* Not AIAMAG.  */
    #####: 1019:	nread = read (desc, (char *) &member_header, AR_HDR_SIZE);
call    0 never executed
    #####: 1020:	if (nread == 0)
branch  0 never executed
branch  1 never executed
        -: 1021:	  /* No data left means end of file; that is OK.  */
    #####: 1022:	  break;
        -: 1023:
    #####: 1024:	if (nread != AR_HDR_SIZE
branch  0 never executed
branch  1 never executed
        -: 1025:#if defined(ARFMAG) || defined(ARFZMAG)
    #####: 1026:	    || (
        -: 1027:# ifdef ARFMAG
    #####: 1028:                bcmp (member_header.ar_fmag, ARFMAG, 2)
branch  0 never executed
branch  1 never executed
        -: 1029:# else
        -: 1030:                1
        -: 1031:# endif
        -: 1032:                &&
        -: 1033:# ifdef ARFZMAG
        -: 1034:                bcmp (member_header.ar_fmag, ARFZMAG, 2)
        -: 1035:# else
        -: 1036:                1
        -: 1037:# endif
        -: 1038:               )
        -: 1039:#endif
        -: 1040:	    )
        -: 1041:	  {
    #####: 1042:	    (void) close (desc);
call    0 never executed
    #####: 1043:	    return -2;
        -: 1044:	  }
        -: 1045:
    #####: 1046:	name = namebuf;
    #####: 1047:	bcopy (member_header.ar_name, name, sizeof member_header.ar_name);
        -: 1048:	{
    #####: 1049:	  register char *p = name + sizeof member_header.ar_name;
        -: 1050:	  do
    #####: 1051:	    *p = '\0';
    #####: 1052:	  while (p > name && *--p == ' ');
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1053:
        -: 1054:#ifndef AIAMAG
        -: 1055:	  /* If the member name is "//" or "ARFILENAMES/" this may be
        -: 1056:	     a list of file name mappings.  The maximum file name
        -: 1057: 	     length supported by the standard archive format is 14
        -: 1058: 	     characters.  This member will actually always be the
        -: 1059: 	     first or second entry in the archive, but we don't check
        -: 1060: 	     that.  */
    #####: 1061: 	  is_namemap = (!strcmp (name, "//")
    #####: 1062:			|| !strcmp (name, "ARFILENAMES/"));
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1063:#endif	/* Not AIAMAG. */
        -: 1064:	  /* On some systems, there is a slash after each member name.  */
    #####: 1065:	  if (*p == '/')
branch  0 never executed
branch  1 never executed
    #####: 1066:	    *p = '\0';
        -: 1067:
        -: 1068:#ifndef AIAMAG
        -: 1069: 	  /* If the member name starts with a space or a slash, this
        -: 1070: 	     is an index into the file name mappings (used by GNU ar).
        -: 1071: 	     Otherwise if the member name looks like #1/NUMBER the
        -: 1072: 	     real member name appears in the element data (used by
        -: 1073: 	     4.4BSD).  */
    #####: 1074: 	  if (! is_namemap
branch  0 never executed
branch  1 never executed
    #####: 1075: 	      && (name[0] == ' ' || name[0] == '/')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1076: 	      && namemap != 0)
branch  0 never executed
branch  1 never executed
        -: 1077:	    {
    #####: 1078:	      name = namemap + atoi (name + 1);
    #####: 1079:	      long_name = 1;
        -: 1080:	    }
    #####: 1081: 	  else if (name[0] == '#'
branch  0 never executed
branch  1 never executed
    #####: 1082: 		   && name[1] == '1'
branch  0 never executed
branch  1 never executed
    #####: 1083: 		   && name[2] == '/')
branch  0 never executed
branch  1 never executed
        -: 1084: 	    {
    #####: 1085: 	      int namesize = atoi (name + 3);
        -: 1086:
    #####: 1087: 	      name = (char *) alloca (namesize + 1);
    #####: 1088: 	      nread = read (desc, name, namesize);
call    0 never executed
    #####: 1089: 	      if (nread != namesize)
branch  0 never executed
branch  1 never executed
        -: 1090: 		{
    #####: 1091: 		  close (desc);
call    0 never executed
    #####: 1092: 		  return -2;
        -: 1093: 		}
    #####: 1094: 	      name[namesize] = '\0';
        -: 1095:
    #####: 1096:	      long_name = 1;
        -: 1097: 	    }
        -: 1098:#endif /* Not AIAMAG. */
        -: 1099:	}
        -: 1100:
        -: 1101:#ifndef	M_XENIX
    #####: 1102:	sscanf (member_header.ar_mode, "%o", &eltmode);
    #####: 1103:	eltsize = atol (member_header.ar_size);
        -: 1104:#else	/* Xenix.  */
        -: 1105:	eltmode = (unsigned short int) member_header.ar_mode;
        -: 1106:	eltsize = member_header.ar_size;
        -: 1107:#endif	/* Not Xenix.  */
        -: 1108:
        -: 1109:	fnval =
    #####: 1110:	  (*function) (desc, name, ! long_name, member_offset,
call    0 never executed
        -: 1111:		       member_offset + AR_HDR_SIZE, eltsize,
        -: 1112:#ifndef	M_XENIX
        -: 1113:		       atol (member_header.ar_date),
        -: 1114:		       atoi (member_header.ar_uid),
        -: 1115:		       atoi (member_header.ar_gid),
        -: 1116:#else	/* Xenix.  */
        -: 1117:		       member_header.ar_date,
        -: 1118:		       member_header.ar_uid,
        -: 1119:		       member_header.ar_gid,
        -: 1120:#endif	/* Not Xenix.  */
        -: 1121:		       eltmode, arg);
        -: 1122:
        -: 1123:#endif  /* AIAMAG.  */
        -: 1124:
    #####: 1125:	if (fnval)
branch  0 never executed
branch  1 never executed
        -: 1126:	  {
    #####: 1127:	    (void) close (desc);
call    0 never executed
    #####: 1128:	    return fnval;
        -: 1129:	  }
        -: 1130:
        -: 1131:#ifdef AIAMAG
        -: 1132:	if (member_offset == last_member_offset)
        -: 1133:	  /* End of the chain.  */
        -: 1134:	  break;
        -: 1135:
        -: 1136:#ifdef AIAMAGBIG
        -: 1137:	if (big_archive)
        -: 1138:          sscanf (member_header_big.ar_nxtmem, "%20ld", &member_offset);
        -: 1139:	else
        -: 1140:#endif
        -: 1141:	  sscanf (member_header.ar_nxtmem, "%12ld", &member_offset);
        -: 1142:
        -: 1143:	if (off_t_to_int(lseek (desc, int_to_off_t(member_offset), 0)) != member_offset)
        -: 1144:	  /*	if (lseek (desc, member_offset, 0) != member_offset) */
        -: 1145:	  {
        -: 1146:	    (void) close (desc);
        -: 1147:	    return -2;
        -: 1148:	  }
        -: 1149:#else
        -: 1150:
        -: 1151: 	/* If this member maps archive names, we must read it in.  The
        -: 1152: 	   name map will always precede any members whose names must
        -: 1153: 	   be mapped.  */
    #####: 1154:	if (is_namemap)
branch  0 never executed
branch  1 never executed
        -: 1155: 	  {
        -: 1156: 	    char *clear;
        -: 1157: 	    char *limit;
        -: 1158:
    #####: 1159: 	    namemap = (char *) alloca (eltsize);
    #####: 1160: 	    nread = read (desc, namemap, eltsize);
call    0 never executed
    #####: 1161: 	    if (nread != eltsize)
branch  0 never executed
branch  1 never executed
        -: 1162: 	      {
    #####: 1163: 		(void) close (desc);
call    0 never executed
    #####: 1164: 		return -2;
        -: 1165: 	      }
        -: 1166:
        -: 1167: 	    /* The names are separated by newlines.  Some formats have
        -: 1168: 	       a trailing slash.  Null terminate the strings for
        -: 1169: 	       convenience.  */
    #####: 1170: 	    limit = namemap + eltsize;
    #####: 1171: 	    for (clear = namemap; clear < limit; clear++)
branch  0 never executed
branch  1 never executed
        -: 1172: 	      {
    #####: 1173: 		if (*clear == '\n')
branch  0 never executed
branch  1 never executed
        -: 1174: 		  {
    #####: 1175: 		    *clear = '\0';
    #####: 1176: 		    if (clear[-1] == '/')
branch  0 never executed
branch  1 never executed
    #####: 1177: 		      clear[-1] = '\0';
        -: 1178: 		  }
        -: 1179: 	      }
        -: 1180:
    #####: 1181:	    is_namemap = 0;
        -: 1182: 	  }
        -: 1183:
    #####: 1184:	member_offset += AR_HDR_SIZE + eltsize;
    #####: 1185:	if (member_offset % 2 != 0)
branch  0 never executed
branch  1 never executed
    #####: 1186:	  member_offset++;
        -: 1187:#endif
        -: 1188:      }
        -: 1189:  }
        -: 1190:
    #####: 1191:  close (desc);
call    0 never executed
    #####: 1192:  return 0;
        -: 1193:}
        -: 1194:#endif /* !VMS */
        -: 1195:
        -: 1196:/* Return nonzero iff NAME matches MEM.
        -: 1197:   If TRUNCATED is nonzero, MEM may be truncated to
        -: 1198:   sizeof (struct ar_hdr.ar_name) - 1.  */
        -: 1199:
        -: 1200:int
function ar_name_equal called 0 returned 0% blocks executed 0%
    #####: 1201:ar_name_equal (name, mem, truncated)
        -: 1202:     char *name, *mem;
        -: 1203:     int truncated;
        -: 1204:{
        -: 1205:  char *p;
        -: 1206:
    #####: 1207:  p = strrchr (name, '/');
    #####: 1208:  if (p != 0)
branch  0 never executed
branch  1 never executed
    #####: 1209:    name = p + 1;
        -: 1210:
        -: 1211:#ifndef VMS
    #####: 1212:  if (truncated)
branch  0 never executed
branch  1 never executed
        -: 1213:    {
        -: 1214:#ifdef AIAMAG
        -: 1215:      /* TRUNCATED should never be set on this system.  */
        -: 1216:      abort ();
        -: 1217:#else
        -: 1218:      struct ar_hdr hdr;
        -: 1219:#if !defined (__hpux) && !defined (cray)
    #####: 1220:      return strneq (name, mem, sizeof(hdr.ar_name) - 1);
        -: 1221:#else
        -: 1222:      return strneq (name, mem, sizeof(hdr.ar_name) - 2);
        -: 1223:#endif /* !__hpux && !cray */
        -: 1224:#endif /* !AIAMAG */
        -: 1225:    }
        -: 1226:#endif /* !VMS */
        -: 1227:
    #####: 1228:  return !strcmp (name, mem);
        -: 1229:}
        -: 1230:
        -: 1231:#ifndef VMS
        -: 1232:/* ARGSUSED */
        -: 1233:static long int
function ar_member_pos called 0 returned 0% blocks executed 0%
    #####: 1234:ar_member_pos (desc, mem, truncated,
        -: 1235:	       hdrpos, datapos, size, date, uid, gid, mode, name)
        -: 1236:     int desc;
        -: 1237:     char *mem;
        -: 1238:     int truncated;
        -: 1239:     long int hdrpos, datapos, size, date;
        -: 1240:     int uid, gid, mode;
        -: 1241:     char *name;
        -: 1242:{
    #####: 1243:  if (!ar_name_equal (name, mem, truncated))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1244:    return 0;
    #####: 1245:  return hdrpos;
        -: 1246:}
        -: 1247:
        -: 1248:/* Set date of member MEMNAME in archive ARNAME to current time.
        -: 1249:   Returns 0 if successful,
        -: 1250:   -1 if file ARNAME does not exist,
        -: 1251:   -2 if not a valid archive,
        -: 1252:   -3 if other random system call error (including file read-only),
        -: 1253:   1 if valid but member MEMNAME does not exist.  */
        -: 1254:
        -: 1255:int
function ar_member_touch called 0 returned 0% blocks executed 0%
    #####: 1256:ar_member_touch (arname, memname)
        -: 1257:     char *arname, *memname;
        -: 1258:{
    #####: 1259:  register long int pos = ar_scan (arname, ar_member_pos, (long int) memname);
call    0 never executed
        -: 1260:  register int fd;
        -: 1261:  struct ar_hdr ar_hdr;
        -: 1262:  register int i;
        -: 1263:  struct stat statbuf;
        -: 1264:
    #####: 1265:  if (pos < 0)
branch  0 never executed
branch  1 never executed
    #####: 1266:    return (int) pos;
    #####: 1267:  if (!pos)
branch  0 never executed
branch  1 never executed
    #####: 1268:    return 1;
        -: 1269:
    #####: 1270:  fd = open (arname, O_RDWR, 0666);
call    0 never executed
    #####: 1271:  if (fd < 0)
branch  0 never executed
branch  1 never executed
    #####: 1272:    return -3;
        -: 1273:  /* Read in this member's header */
    #####: 1274:  if (off_t_equal(off_t_to_int(lseek (fd, int_to_off_t(pos), 0)), ZERO_off_t) < 0)
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -: 1275:    /*  if (lseek (fd, pos, 0) < 0) */
    #####: 1276:    goto lose;
    #####: 1277:  if (AR_HDR_SIZE != read (fd, (char *) &ar_hdr, AR_HDR_SIZE))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1278:    goto lose;
        -: 1279:  /* Write back the header, thus touching the archive file.  */
    #####: 1280:  if (off_t_equal(off_t_to_int(lseek (fd, int_to_off_t(pos), 0)), ZERO_off_t) < 0)
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -: 1281:    /*  if (lseek (fd, pos, 0) < 0) */
    #####: 1282:  if (off_t_equal(off_t_to_int(lseek (fd, int_to_off_t(pos), 0)), ZERO_off_t) < 0)
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -: 1283:      /*  if (lseek (fd, pos, 0) < 0) */
    #####: 1284:    goto lose;
    #####: 1285:  if (AR_HDR_SIZE != write (fd, (char *) &ar_hdr, AR_HDR_SIZE))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1286:    goto lose;
        -: 1287:  /* The file's mtime is the time we we want.  */
    #####: 1288:  while (fstat (fd, &statbuf) < 0 && EINTR_SET)
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -: 1289:    ;
        -: 1290:#if defined(ARFMAG) || defined(ARFZMAG) || defined(AIAMAG) || defined(WINDOWS32)
        -: 1291:  /* Advance member's time to that time */
    #####: 1292:  for (i = 0; i < sizeof ar_hdr.ar_date; i++)
branch  0 never executed
branch  1 never executed
    #####: 1293:    ar_hdr.ar_date[i] = ' ';
    #####: 1294:  sprintf (ar_hdr.ar_date, "%ld", (long int) statbuf.st_mtime);
        -: 1295:#ifdef AIAMAG
        -: 1296:  ar_hdr.ar_date[strlen(ar_hdr.ar_date)] = ' ';
        -: 1297:#endif
        -: 1298:#else
        -: 1299:  ar_hdr.ar_date = statbuf.st_mtime;
        -: 1300:#endif
        -: 1301:  /* Write back this member's header */
    #####: 1302:  if (off_t_equal(off_t_to_int(lseek (fd, int_to_off_t(pos), 0)), ZERO_off_t) < 0)
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -: 1303:      /*  if (lseek (fd, pos, 0) < 0) */
    #####: 1304:    goto lose;
    #####: 1305:  if (AR_HDR_SIZE != write (fd, (char *) &ar_hdr, AR_HDR_SIZE))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1306:    goto lose;
    #####: 1307:  close (fd);
call    0 never executed
    #####: 1308:  return 0;
        -: 1309:
    #####: 1310: lose:
    #####: 1311:  i = errno;
    #####: 1312:  close (fd);
call    0 never executed
    #####: 1313:  errno = i;
    #####: 1314:  return -3;
        -: 1315:}
        -: 1316:#endif
        -: 1317:
        -: 1318:#ifdef TEST
        -: 1319:
        -: 1320:long int
        -: 1321:describe_member (desc, name, truncated,
        -: 1322:		 hdrpos, datapos, size, date, uid, gid, mode)
        -: 1323:     int desc;
        -: 1324:     char *name;
        -: 1325:     int truncated;
        -: 1326:     long int hdrpos, datapos, size, date;
        -: 1327:     int uid, gid, mode;
        -: 1328:{
        -: 1329:  extern char *ctime ();
        -: 1330:
        -: 1331:  printf (_("Member `%s'%s: %ld bytes at %ld (%ld).\n"),
        -: 1332:	  name, truncated ? _(" (name might be truncated)") : "",
        -: 1333:	  size, hdrpos, datapos);
        -: 1334:  printf (_("  Date %s"), ctime (&date));
        -: 1335:  printf (_("  uid = %d, gid = %d, mode = 0%o.\n"), uid, gid, mode);
        -: 1336:
        -: 1337:  return 0;
        -: 1338:}
        -: 1339:
        -: 1340:main (argc, argv)
        -: 1341:     int argc;
        -: 1342:     char **argv;
        -: 1343:{
        -: 1344:  ar_scan (argv[1], describe_member);
        -: 1345:  return 0;
        -: 1346:}
        -: 1347:
        -: 1348:#endif	/* TEST.  */
        -: 1349:
        -: 1350:#endif	/* NO_ARCHIVES.  */
        -: 1351:
        -: 1352:
        -: 1353:
        -: 1354:/*************************************************************
        -: 1355:  ============================================================
        -: 1356:  ************************************************************
        -: 1357:  ============================================================
        -: 1358:  ************************************************************
        -: 1359:                         commands.c
        -: 1360:  ************************************************************
        -: 1361:  ============================================================
        -: 1362:  ************************************************************
        -: 1363:  ============================================================
        -: 1364:  *************************************************************/
        -: 1365:
        -: 1366:/* Command processing for GNU Make.
        -: 1367:Copyright (C) 1988,89,91,92,93,94,95,96,97 Free Software Foundation, Inc.
        -: 1368:This file is part of GNU Make.
        -: 1369:
        -: 1370:GNU Make is free software; you can redistribute it and/or modify
        -: 1371:it under the terms of the GNU General Public License as published by
        -: 1372:the Free Software Foundation; either version 2, or (at your option)
        -: 1373:any later version.
        -: 1374:
        -: 1375:GNU Make is distributed in the hope that it will be useful,
        -: 1376:but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 1377:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 1378:GNU General Public License for more details.
        -: 1379:
        -: 1380:You should have received a copy of the GNU General Public License
        -: 1381:along with GNU Make; see the file COPYING.  If not, write to
        -: 1382:the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
        -: 1383:Boston, MA 02111-1307, USA.  */
        -: 1384:
        -: 1385:/* #include "make.h"  <- modification by J.Ruthruff, 7/28 */
        -: 1386:/* #include "dep.h"  <- modification by J.Ruthruff, 7/28 */
        -: 1387:/* #include "filedef.h"  <- modification by J.Ruthruff, 7/28 */
        -: 1388:#include "variable.h"
        -: 1389:#include "job.h"
        -: 1390:#include "commands.h"
        -: 1391:#undef stderr
        -: 1392:#define stderr stdout
        -: 1393:
        -: 1394:extern int remote_kill PARAMS ((int id, int sig));
        -: 1395:
        -: 1396:#ifndef	HAVE_UNISTD_H
        -: 1397:extern int getpid ();
        -: 1398:#endif
        -: 1399:
        -: 1400:/* Set FILE's automatic variables up.  */
        -: 1401:
        -: 1402:static void
function set_file_variables called 0 returned 0% blocks executed 0%
    #####: 1403:set_file_variables (file)
        -: 1404:     register struct file *file;
        -: 1405:{
        -: 1406:  register char *p;
        -: 1407:  char *at, *percent, *star, *less;
        -: 1408:
        -: 1409:#ifndef	NO_ARCHIVES
        -: 1410:  /* If the target is an archive member `lib(member)',
        -: 1411:     then $@ is `lib' and $% is `member'.  */
        -: 1412:
    #####: 1413:  if (ar_name (file->name))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1414:    {
        -: 1415:      unsigned int len;
    #####: 1416:      p = strchr (file->name, '(');
    #####: 1417:      at = (char *) alloca (p - file->name + 1);
    #####: 1418:      bcopy (file->name, at, p - file->name);
    #####: 1419:      at[p - file->name] = '\0';
    #####: 1420:      len = strlen (p + 1);
    #####: 1421:      percent = (char *) alloca (len);
    #####: 1422:      bcopy (p + 1, percent, len - 1);
    #####: 1423:      percent[len - 1] = '\0';
        -: 1424:    }
        -: 1425:  else
        -: 1426:#endif	/* NO_ARCHIVES.  */
        -: 1427:    {
    #####: 1428:      at = file->name;
    #####: 1429:      percent = "";
        -: 1430:    }
        -: 1431:
        -: 1432:  /* $* is the stem from an implicit or static pattern rule.  */
    #####: 1433:  if (file->stem == 0)
branch  0 never executed
branch  1 never executed
        -: 1434:    {
        -: 1435:      /* In Unix make, $* is set to the target name with
        -: 1436:	 any suffix in the .SUFFIXES list stripped off for
        -: 1437:	 explicit rules.  We store this in the `stem' member.  */
        -: 1438:      register struct dep *d;
        -: 1439:      char *name;
        -: 1440:      unsigned int len;
        -: 1441:
        -: 1442:#ifndef	NO_ARCHIVES
    #####: 1443:      if (ar_name (file->name))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1444:	{
    #####: 1445:	  name = strchr (file->name, '(') + 1;
    #####: 1446:	  len = strlen (name) - 1;
        -: 1447:	}
        -: 1448:      else
        -: 1449:#endif
        -: 1450:	{
    #####: 1451:	  name = file->name;
    #####: 1452:	  len = strlen (name);
        -: 1453:	}
        -: 1454:
    #####: 1455:      for (d = enter_file (".SUFFIXES")->deps; d != 0; d = d->next)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1456:	{
    #####: 1457:	  unsigned int slen = strlen (dep_name (d));
branch  0 never executed
branch  1 never executed
    #####: 1458:	  if (len > slen && strneq (dep_name (d), name + (len - slen), slen))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1459:	    {
    #####: 1460:	      file->stem = savestring (name, len - slen);
call    0 never executed
    #####: 1461:	      break;
        -: 1462:	    }
        -: 1463:	}
    #####: 1464:      if (d == 0)
branch  0 never executed
branch  1 never executed
    #####: 1465:	file->stem = "";
        -: 1466:    }
    #####: 1467:  star = file->stem;
        -: 1468:
        -: 1469:  /* $< is the first dependency.  */
    #####: 1470:  less = file->deps != 0 ? dep_name (file->deps) : "";
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1471:
    #####: 1472:  if (file->cmds == default_file->cmds)
branch  0 never executed
branch  1 never executed
        -: 1473:    /* This file got its commands from .DEFAULT.
        -: 1474:       In this case $< is the same as $@.  */
    #####: 1475:    less = at;
        -: 1476:
        -: 1477:#define	DEFINE_VARIABLE(name, len, value) \
        -: 1478:  (void) define_variable_for_file (name,len,value,o_automatic,0,file)
        -: 1479:
        -: 1480:  /* Define the variables.  */
        -: 1481:
    #####: 1482:  DEFINE_VARIABLE ("<", 1, less);
call    0 never executed
    #####: 1483:  DEFINE_VARIABLE ("*", 1, star);
call    0 never executed
    #####: 1484:  DEFINE_VARIABLE ("@", 1, at);
call    0 never executed
    #####: 1485:  DEFINE_VARIABLE ("%", 1, percent);
call    0 never executed
        -: 1486:
        -: 1487:  /* Compute the values for $^, $+, and $?.  */
        -: 1488:
        -: 1489:  {
        -: 1490:    register unsigned int qmark_len, plus_len;
        -: 1491:    char *caret_value, *plus_value;
        -: 1492:    register char *cp;
        -: 1493:    char *qmark_value;
        -: 1494:    register char *qp;
        -: 1495:    register struct dep *d;
        -: 1496:    unsigned int len;
        -: 1497:
        -: 1498:    /* Compute first the value for $+, which is supposed to contain
        -: 1499:       duplicate dependencies as they were listed in the makefile.  */
        -: 1500:
    #####: 1501:    plus_len = 0;
    #####: 1502:    for (d = file->deps; d != 0; d = d->next)
branch  0 never executed
branch  1 never executed
    #####: 1503:      plus_len += strlen (dep_name (d)) + 1;
branch  0 never executed
branch  1 never executed
        -: 1504:
    #####: 1505:    len = plus_len == 0 ? 1 : plus_len;
branch  0 never executed
branch  1 never executed
    #####: 1506:    cp = plus_value = (char *) alloca (len);
        -: 1507:
    #####: 1508:    qmark_len = plus_len;	/* Will be this or less.  */
    #####: 1509:    for (d = file->deps; d != 0; d = d->next)
branch  0 never executed
branch  1 never executed
        -: 1510:      {
    #####: 1511:	char *c = dep_name (d);
branch  0 never executed
branch  1 never executed
        -: 1512:
        -: 1513:#ifndef	NO_ARCHIVES
    #####: 1514:	if (ar_name (c))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1515:	  {
    #####: 1516:	    c = strchr (c, '(') + 1;
    #####: 1517:	    len = strlen (c) - 1;
        -: 1518:	  }
        -: 1519:	else
        -: 1520:#endif
    #####: 1521:	  len = strlen (c);
        -: 1522:
    #####: 1523:	bcopy (c, cp, len);
    #####: 1524:	cp += len;
        -: 1525:#if VMS
        -: 1526:        *cp++ = ',';
        -: 1527:#else
    #####: 1528:	*cp++ = ' ';
        -: 1529:#endif
    #####: 1530:	if (! d->changed)
branch  0 never executed
branch  1 never executed
    #####: 1531:	  qmark_len -= len + 1;	/* Don't space in $? for this one.  */
        -: 1532:      }
        -: 1533:
        -: 1534:    /* Kill the last space and define the variable.  */
        -: 1535:
    #####: 1536:    cp[cp > plus_value ? -1 : 0] = '\0';
branch  0 never executed
branch  1 never executed
    #####: 1537:    DEFINE_VARIABLE ("+", 1, plus_value);
call    0 never executed
        -: 1538:
        -: 1539:    /* Make sure that no dependencies are repeated.  This does not
        -: 1540:       really matter for the purpose of updating targets, but it
        -: 1541:       might make some names be listed twice for $^ and $?.  */
        -: 1542:
    #####: 1543:    uniquize_deps (file->deps);
call    0 never executed
        -: 1544:
        -: 1545:    /* Compute the values for $^ and $?.  */
        -: 1546:
    #####: 1547:    cp = caret_value = plus_value; /* Reuse the buffer; it's big enough.  */
    #####: 1548:    len = qmark_len == 0 ? 1 : qmark_len;
branch  0 never executed
branch  1 never executed
    #####: 1549:    qp = qmark_value = (char *) alloca (len);
        -: 1550:
    #####: 1551:    for (d = file->deps; d != 0; d = d->next)
branch  0 never executed
branch  1 never executed
        -: 1552:      {
    #####: 1553:	char *c = dep_name (d);
branch  0 never executed
branch  1 never executed
        -: 1554:
        -: 1555:#ifndef	NO_ARCHIVES
    #####: 1556:	if (ar_name (c))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1557:	  {
    #####: 1558:	    c = strchr (c, '(') + 1;
    #####: 1559:	    len = strlen (c) - 1;
        -: 1560:	  }
        -: 1561:	else
        -: 1562:#endif
    #####: 1563:	  len = strlen (c);
        -: 1564:
    #####: 1565:	bcopy (c, cp, len);
    #####: 1566:	cp += len;
        -: 1567:#if VMS
        -: 1568:	*cp++ = ',';
        -: 1569:#else
    #####: 1570:	*cp++ = ' ';
        -: 1571:#endif
    #####: 1572:	if (d->changed)
branch  0 never executed
branch  1 never executed
        -: 1573:	  {
    #####: 1574:	    bcopy (c, qp, len);
    #####: 1575:	    qp += len;
        -: 1576:#if VMS
        -: 1577:	    *qp++ = ',';
        -: 1578:#else
    #####: 1579:	    *qp++ = ' ';
        -: 1580:#endif
        -: 1581:	  }
        -: 1582:      }
        -: 1583:
        -: 1584:    /* Kill the last spaces and define the variables.  */
        -: 1585:
    #####: 1586:    cp[cp > caret_value ? -1 : 0] = '\0';
branch  0 never executed
branch  1 never executed
    #####: 1587:    DEFINE_VARIABLE ("^", 1, caret_value);
call    0 never executed
        -: 1588:
    #####: 1589:    qp[qp > qmark_value ? -1 : 0] = '\0';
branch  0 never executed
branch  1 never executed
    #####: 1590:    DEFINE_VARIABLE ("?", 1, qmark_value);
call    0 never executed
        -: 1591:  }
        -: 1592:
        -: 1593:#undef	DEFINE_VARIABLE
    #####: 1594:}
        -: 1595:
        -: 1596:/* Chop CMDS up into individual command lines if necessary.
        -: 1597:   Also set the `lines_flag' and `any_recurse' members.  */
        -: 1598:
        -: 1599:void
function chop_commands called 0 returned 0% blocks executed 0%
    #####: 1600:chop_commands (cmds)
        -: 1601:     register struct commands *cmds;
        -: 1602:{
        -: 1603:  register char *p;
        -: 1604:  unsigned int nlines, idx;
        -: 1605:  char **lines;
        -: 1606:
        -: 1607:  /* If we don't have any commands,
        -: 1608:     or we already parsed them, never mind.  */
        -: 1609:
    #####: 1610:  if (!cmds || cmds->command_lines != 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1611:    return;
        -: 1612:
        -: 1613:  /* Chop CMDS->commands up into lines in CMDS->command_lines.
        -: 1614:	 Also set the corresponding CMDS->lines_flags elements,
        -: 1615:	 and the CMDS->any_recurse flag.  */
        -: 1616:
    #####: 1617:  nlines = 5;
    #####: 1618:  lines = (char **) xmalloc (5 * sizeof (char *));
call    0 never executed
    #####: 1619:  idx = 0;
    #####: 1620:  p = cmds->commands;
    #####: 1621:  while (*p != '\0')
branch  0 never executed
branch  1 never executed
        -: 1622:    {
    #####: 1623:      char *end = p;
    #####: 1624:    find_end:;
    #####: 1625:      end = strchr (end, '\n');
    #####: 1626:      if (end == 0)
branch  0 never executed
branch  1 never executed
    #####: 1627:        end = p + strlen (p);
    #####: 1628:      else if (end > p && end[-1] == '\\')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1629:        {
    #####: 1630:          int backslash = 1;
        -: 1631:          register char *b;
    #####: 1632:          for (b = end - 2; b >= p && *b == '\\'; --b)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1633:            backslash = !backslash;
    #####: 1634:          if (backslash)
branch  0 never executed
branch  1 never executed
        -: 1635:            {
    #####: 1636:              ++end;
    #####: 1637:              goto find_end;
        -: 1638:            }
        -: 1639:        }
        -: 1640:
    #####: 1641:      if (idx == nlines)
branch  0 never executed
branch  1 never executed
        -: 1642:        {
    #####: 1643:          nlines += 2;
    #####: 1644:          lines = (char **) xrealloc ((char *) lines,
call    0 never executed
        -: 1645:                                      nlines * sizeof (char *));
        -: 1646:        }
    #####: 1647:      lines[idx++] = savestring (p, end - p);
call    0 never executed
    #####: 1648:      p = end;
    #####: 1649:      if (*p != '\0')
branch  0 never executed
branch  1 never executed
    #####: 1650:        ++p;
        -: 1651:    }
        -: 1652:
    #####: 1653:  if (idx != nlines)
branch  0 never executed
branch  1 never executed
        -: 1654:    {
    #####: 1655:      nlines = idx;
    #####: 1656:      lines = (char **) xrealloc ((char *) lines,
call    0 never executed
        -: 1657:                                  nlines * sizeof (char *));
        -: 1658:    }
        -: 1659:
    #####: 1660:  cmds->ncommand_lines = nlines;
    #####: 1661:  cmds->command_lines = lines;
        -: 1662:
    #####: 1663:  cmds->any_recurse = 0;
    #####: 1664:  cmds->lines_flags = (char *) xmalloc (nlines);
call    0 never executed
    #####: 1665:  for (idx = 0; idx < nlines; ++idx)
branch  0 never executed
branch  1 never executed
        -: 1666:    {
    #####: 1667:      int flags = 0;
        -: 1668:
    #####: 1669:      for (p = lines[idx];
    #####: 1670:           isblank (*p) || *p == '-' || *p == '@' || *p == '+';
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####: 1671:           ++p)
    #####: 1672:        switch (*p)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1673:          {
    #####: 1674:          case '+':
    #####: 1675:            flags |= COMMANDS_RECURSE;
    #####: 1676:            break;
    #####: 1677:          case '@':
    #####: 1678:            flags |= COMMANDS_SILENT;
    #####: 1679:            break;
    #####: 1680:          case '-':
    #####: 1681:            flags |= COMMANDS_NOERROR;
    #####: 1682:            break;
        -: 1683:          }
    #####: 1684:      if (!(flags & COMMANDS_RECURSE))
branch  0 never executed
branch  1 never executed
        -: 1685:        {
    #####: 1686:          unsigned int len = strlen (p);
    #####: 1687:          if (sindex (p, len, "$(MAKE)", 7) != 0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1688:              || sindex (p, len, "${MAKE}", 7) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1689:            flags |= COMMANDS_RECURSE;
        -: 1690:        }
        -: 1691:
    #####: 1692:      cmds->lines_flags[idx] = flags;
    #####: 1693:      cmds->any_recurse |= flags & COMMANDS_RECURSE;
        -: 1694:    }
        -: 1695:}
        -: 1696:
        -: 1697:/* Execute the commands to remake FILE.  If they are currently executing,
        -: 1698:   return or have already finished executing, just return.  Otherwise,
        -: 1699:   fork off a child process to run the first command line in the sequence.  */
        -: 1700:
        -: 1701:void
function execute_file_commands called 0 returned 0% blocks executed 0%
    #####: 1702:execute_file_commands (file)
        -: 1703:     struct file *file;
        -: 1704:{
        -: 1705:  register char *p;
        -: 1706:
        -: 1707:  /* Don't go through all the preparations if
        -: 1708:     the commands are nothing but whitespace.  */
        -: 1709:
    #####: 1710:  for (p = file->cmds->commands; *p != '\0'; ++p)
branch  0 never executed
branch  1 never executed
    #####: 1711:    if (!isspace ((unsigned char)*p) && *p != '-' && *p != '@')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1712:      break;
    #####: 1713:  if (*p == '\0')
branch  0 never executed
branch  1 never executed
        -: 1714:    {
        -: 1715:      /* If there are no commands, assume everything worked.  */
    #####: 1716:      set_command_state (file, cs_running);
call    0 never executed
    #####: 1717:      file->update_status = 0;
    #####: 1718:      notice_finished_file (file);
call    0 never executed
    #####: 1719:      return;
        -: 1720:    }
        -: 1721:
        -: 1722:  /* First set the automatic variables according to this file.  */
        -: 1723:
    #####: 1724:  initialize_file_variables (file, 0);
call    0 never executed
        -: 1725:
    #####: 1726:  set_file_variables (file);
call    0 never executed
        -: 1727:
        -: 1728:  /* Start the commands running.  */
    #####: 1729:  new_job (file);
call    0 never executed
        -: 1730:}
        -: 1731:
        -: 1732:/* This is set while we are inside fatal_error_signal,
        -: 1733:   so things can avoid nonreentrant operations.  */
        -: 1734:
        -: 1735:int handling_fatal_signal = 0;
        -: 1736:
        -: 1737:/* Handle fatal signals.  */
        -: 1738:
        -: 1739:RETSIGTYPE
function fatal_error_signal called 0 returned 0% blocks executed 0%
    #####: 1740:fatal_error_signal (sig)
        -: 1741:     int sig;
        -: 1742:{
        -: 1743:#ifdef __MSDOS__
        -: 1744:  extern int dos_status, dos_command_running;
        -: 1745:
        -: 1746:  if (dos_command_running)
        -: 1747:    {
        -: 1748:      /* That was the child who got the signal, not us.  */
        -: 1749:      dos_status |= (sig << 8);
        -: 1750:      return;
        -: 1751:    }
        -: 1752:  remove_intermediates (1);
        -: 1753:  exit (EXIT_FAILURE);
        -: 1754:#else /* not __MSDOS__ */
        -: 1755:#ifdef _AMIGA
        -: 1756:  remove_intermediates (1);
        -: 1757:  if (sig == SIGINT)
        -: 1758:     fputs (_("*** Break.\n"), stderr);
        -: 1759:
        -: 1760:  exit (10);
        -: 1761:#else /* not Amiga */
    #####: 1762:  handling_fatal_signal = 1;
        -: 1763:
        -: 1764:  /* Set the handling for this signal to the default.
        -: 1765:     It is blocked now while we run this handler.  */
    #####: 1766:  signal (sig, SIG_DFL);
call    0 never executed
        -: 1767:
        -: 1768:  /* A termination signal won't be sent to the entire
        -: 1769:     process group, but it means we want to kill the children.  */
        -: 1770:
    #####: 1771:  if (sig == SIGTERM)
branch  0 never executed
branch  1 never executed
        -: 1772:    {
        -: 1773:      register struct child *c;
    #####: 1774:      for (c = children; c != 0; c = c->next)
branch  0 never executed
branch  1 never executed
    #####: 1775:	if (!c->remote)
branch  0 never executed
branch  1 never executed
    #####: 1776:	  (void) kill (c->pid, SIGTERM);
call    0 never executed
        -: 1777:    }
        -: 1778:
        -: 1779:  /* If we got a signal that means the user
        -: 1780:     wanted to kill make, remove pending targets.  */
        -: 1781:
    #####: 1782:  if (sig == SIGTERM || sig == SIGINT
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1783:#ifdef SIGHUP
    #####: 1784:    || sig == SIGHUP
branch  0 never executed
branch  1 never executed
        -: 1785:#endif
        -: 1786:#ifdef SIGQUIT
    #####: 1787:    || sig == SIGQUIT
branch  0 never executed
branch  1 never executed
        -: 1788:#endif
        -: 1789:    )
    #####: 1790:    {
        -: 1791:      register struct child *c;
        -: 1792:
        -: 1793:      /* Remote children won't automatically get signals sent
        -: 1794:	 to the process group, so we must send them.  */
    #####: 1795:      for (c = children; c != 0; c = c->next)
branch  0 never executed
branch  1 never executed
    #####: 1796:	if (c->remote)
branch  0 never executed
branch  1 never executed
    #####: 1797:	  (void) remote_kill (c->pid, sig);
call    0 never executed
        -: 1798:
    #####: 1799:      for (c = children; c != 0; c = c->next)
branch  0 never executed
branch  1 never executed
    #####: 1800:	delete_child_targets (c);
call    0 never executed
        -: 1801:
        -: 1802:      /* Clean up the children.  We don't just use the call below because
        -: 1803:	 we don't want to print the "Waiting for children" message.  */
    #####: 1804:      while (job_slots_used > 0)
branch  0 never executed
branch  1 never executed
    #####: 1805:	reap_children (1, 0);
call    0 never executed
        -: 1806:    }
        -: 1807:  else
        -: 1808:    /* Wait for our children to die.  */
    #####: 1809:    while (job_slots_used > 0)
branch  0 never executed
branch  1 never executed
    #####: 1810:      reap_children (1, 1);
call    0 never executed
        -: 1811:
        -: 1812:  /* Delete any non-precious intermediate files that were made.  */
        -: 1813:
    #####: 1814:  remove_intermediates (1);
call    0 never executed
        -: 1815:
        -: 1816:#ifdef SIGQUIT
    #####: 1817:  if (sig == SIGQUIT)
branch  0 never executed
branch  1 never executed
        -: 1818:    /* We don't want to send ourselves SIGQUIT, because it will
        -: 1819:       cause a core dump.  Just exit instead.  */
    #####: 1820:    exit (EXIT_FAILURE);
call    0 never executed
        -: 1821:#endif
        -: 1822:
        -: 1823:  /* Signal the same code; this time it will really be fatal.  The signal
        -: 1824:     will be unblocked when we return and arrive then to kill us.  */
    #####: 1825:  if (kill (getpid (), sig) < 0)
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1826:    pfatal_with_name ("kill");
call    0 never executed
        -: 1827:#endif /* not Amiga */
        -: 1828:#endif /* not __MSDOS__  */
    #####: 1829:}
        -: 1830:
        -: 1831:/* Delete FILE unless it's precious or not actually a file (phony),
        -: 1832:   and it has changed on disk since we last stat'd it.  */
        -: 1833:
        -: 1834:static void
function delete_target called 0 returned 0% blocks executed 0%
    #####: 1835:delete_target (file, on_behalf_of)
        -: 1836:     struct file *file;
        -: 1837:     char *on_behalf_of;
        -: 1838:{
        -: 1839:  struct stat st;
        -: 1840:
    #####: 1841:  if (file->precious || file->phony)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1842:    return;
        -: 1843:
        -: 1844:#ifndef NO_ARCHIVES
    #####: 1845:  if (ar_name (file->name))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1846:    {
    #####: 1847:      if (ar_member_date (file->name) != FILE_TIMESTAMP_S (file->last_mtime))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1848:	{
    #####: 1849:	  if (on_behalf_of)
branch  0 never executed
branch  1 never executed
    #####: 1850:	    error (NILF, _("*** [%s] Archive member `%s' may be bogus; not deleted"),
call    0 never executed
        -: 1851:		   on_behalf_of, file->name);
        -: 1852:	  else
    #####: 1853:	    error (NILF, _("*** Archive member `%s' may be bogus; not deleted"),
call    0 never executed
        -: 1854:		   file->name);
        -: 1855:	}
    #####: 1856:      return;
        -: 1857:    }
        -: 1858:#endif
        -: 1859:
    #####: 1860:  if (stat (file->name, &st) == 0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1861:      && S_ISREG (st.st_mode)
branch  0 never executed
branch  1 never executed
    #####: 1862:      && FILE_TIMESTAMP_STAT_MODTIME (st) != file->last_mtime)
branch  0 never executed
branch  1 never executed
        -: 1863:    {
    #####: 1864:      if (on_behalf_of)
branch  0 never executed
branch  1 never executed
    #####: 1865:	error (NILF, _("*** [%s] Deleting file `%s'"), on_behalf_of, file->name);
call    0 never executed
        -: 1866:      else
    #####: 1867:	error (NILF, _("*** Deleting file `%s'"), file->name);
call    0 never executed
    #####: 1868:      if (unlink (file->name) < 0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1869:	  && errno != ENOENT)	/* It disappeared; so what.  */
branch  0 never executed
branch  1 never executed
    #####: 1870:	perror_with_name ("unlink: ", file->name);
call    0 never executed
        -: 1871:    }
        -: 1872:}
        -: 1873:
        -: 1874:
        -: 1875:/* Delete all non-precious targets of CHILD unless they were already deleted.
        -: 1876:   Set the flag in CHILD to say they've been deleted.  */
        -: 1877:
        -: 1878:void
function delete_child_targets called 0 returned 0% blocks executed 0%
    #####: 1879:delete_child_targets (child)
        -: 1880:     struct child *child;
        -: 1881:{
        -: 1882:  struct dep *d;
        -: 1883:
    #####: 1884:  if (child->deleted)
branch  0 never executed
branch  1 never executed
    #####: 1885:    return;
        -: 1886:
        -: 1887:  /* Delete the target file if it changed.  */
    #####: 1888:  delete_target (child->file, (char *) 0);
call    0 never executed
        -: 1889:
        -: 1890:  /* Also remove any non-precious targets listed in the `also_make' member.  */
    #####: 1891:  for (d = child->file->also_make; d != 0; d = d->next)
branch  0 never executed
branch  1 never executed
    #####: 1892:    delete_target (d->file, child->file->name);
call    0 never executed
        -: 1893:
    #####: 1894:  child->deleted = 1;
        -: 1895:}
        -: 1896:
        -: 1897:/* Print out the commands in CMDS.  */
        -: 1898:
        -: 1899:void
function print_commands called 99 returned 100% blocks executed 93%
       99: 1900:print_commands (cmds)
        -: 1901:     register struct commands *cmds;
        -: 1902:{
        -: 1903:  register char *s;
        -: 1904:
       99: 1905:  fputs (_("#  commands to execute"), stdout);
call    0 returned 99
        -: 1906:
       99: 1907:  if (cmds->fileinfo.filenm == 0)
branch  0 taken 99 (fallthrough)
branch  1 taken 0
       99: 1908:    puts (_(" (built-in):"));
call    0 returned 99
        -: 1909:  else
    #####: 1910:    printf (_(" (from `%s', line %lu):\n"),
call    0 never executed
        -: 1911:            cmds->fileinfo.filenm, cmds->fileinfo.lineno);
        -: 1912:
       99: 1913:  s = cmds->commands;
      217: 1914:  while (*s != '\0')
branch  0 taken 118
branch  1 taken 99 (fallthrough)
        -: 1915:    {
        -: 1916:      char *end;
        -: 1917:
      154: 1918:      while (isspace ((unsigned char)*s))
branch  0 taken 36
branch  1 taken 118 (fallthrough)
       36: 1919:	++s;
        -: 1920:
      118: 1921:      end = strchr (s, '\n');
      118: 1922:      if (end == 0)
branch  0 taken 99 (fallthrough)
branch  1 taken 19
       99: 1923:	end = s + strlen (s);
        -: 1924:
      118: 1925:      printf ("\t%.*s\n", (int) (end - s), s);
call    0 returned 118
        -: 1926:
      118: 1927:      s = end;
        -: 1928:    }
       99: 1929:}
        -: 1930:
        -: 1931:
        -: 1932:
        -: 1933:/*************************************************************
        -: 1934:  ============================================================
        -: 1935:  ************************************************************
        -: 1936:  ============================================================
        -: 1937:  ************************************************************
        -: 1938:                         dir.c
        -: 1939:  ************************************************************
        -: 1940:  ============================================================
        -: 1941:  ************************************************************
        -: 1942:  ============================================================
        -: 1943:  *************************************************************/
        -: 1944:
        -: 1945:/* Directory hashing for GNU Make.
        -: 1946:Copyright (C) 1988,89,91,92,93,94,95,96,97 Free Software Foundation, Inc.
        -: 1947:This file is part of GNU Make.
        -: 1948:
        -: 1949:GNU Make is free software; you can redistribute it and/or modify
        -: 1950:it under the terms of the GNU General Public License as published by
        -: 1951:the Free Software Foundation; either version 2, or (at your option)
        -: 1952:any later version.
        -: 1953:
        -: 1954:GNU Make is distributed in the hope that it will be useful,
        -: 1955:but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 1956:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 1957:GNU General Public License for more details.
        -: 1958:
        -: 1959:You should have received a copy of the GNU General Public License
        -: 1960:along with GNU Make; see the file COPYING.  If not, write to
        -: 1961:the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
        -: 1962:Boston, MA 02111-1307, USA.  */
        -: 1963:
        -: 1964:/* #include "make.h"  <- modification by J.Ruthruff, 7/28 */
        -: 1965:#undef stderr
        -: 1966:#define stderr stdout
        -: 1967:
        -: 1968:#ifdef	HAVE_DIRENT_H
        -: 1969:# include <dirent.h>
        -: 1970:#undef stderr
        -: 1971:#define stderr stdout
        -: 1972:# define NAMLEN(dirent) strlen((dirent)->d_name)
        -: 1973:# ifdef VMS
        -: 1974:extern char *vmsify PARAMS ((char *name, int type));
        -: 1975:# endif
        -: 1976:#else
        -: 1977:# define dirent direct
        -: 1978:# define NAMLEN(dirent) (dirent)->d_namlen
        -: 1979:# ifdef HAVE_SYS_NDIR_H
        -: 1980:#  include <sys/ndir.h>
        -: 1981:#undef stderr
        -: 1982:#define stderr stdout
        -: 1983:# endif
        -: 1984:# ifdef HAVE_SYS_DIR_H
        -: 1985:#  include <sys/dir.h>
        -: 1986:#undef stderr
        -: 1987:#define stderr stdout
        -: 1988:# endif
        -: 1989:# ifdef HAVE_NDIR_H
        -: 1990:#  include <ndir.h>
        -: 1991:#undef stderr
        -: 1992:#define stderr stdout
        -: 1993:# endif
        -: 1994:# ifdef HAVE_VMSDIR_H
        -: 1995:#  include "vmsdir.h"
        -: 1996:#undef stderr
        -: 1997:#define stderr stdout
        -: 1998:# endif /* HAVE_VMSDIR_H */
        -: 1999:#endif
        -: 2000:
        -: 2001:/* In GNU systems, <dirent.h> defines this macro for us.  */
        -: 2002:#ifdef _D_NAMLEN
        -: 2003:# undef NAMLEN
        -: 2004:# define NAMLEN(d) _D_NAMLEN(d)
        -: 2005:#endif
        -: 2006:
        -: 2007:#if (defined (POSIX) || defined (VMS) || defined (WINDOWS32)) && !defined (__GNU_LIBRARY__)
        -: 2008:/* Posix does not require that the d_ino field be present, and some
        -: 2009:   systems do not provide it. */
        -: 2010:# define REAL_DIR_ENTRY(dp) 1
        -: 2011:# define FAKE_DIR_ENTRY(dp)
        -: 2012:#else
        -: 2013:# define REAL_DIR_ENTRY(dp) (dp->d_ino != 0)
        -: 2014:# define FAKE_DIR_ENTRY(dp) (dp->d_ino = 1)
        -: 2015:#endif /* POSIX */
        -: 2016:
        -: 2017:#ifdef __MSDOS__
        -: 2018:#include <ctype.h>
        -: 2019:#include <fcntl.h>
        -: 2020:#undef stderr
        -: 2021:#define stderr stdout
        -: 2022:
        -: 2023:/* If it's MSDOS that doesn't have _USE_LFN, disable LFN support.  */
        -: 2024:#ifndef _USE_LFN
        -: 2025:#define _USE_LFN 0
        -: 2026:#endif
        -: 2027:
        -: 2028:static char *
        -: 2029:dosify (filename)
        -: 2030:     char *filename;
        -: 2031:{
        -: 2032:  static char dos_filename[14];
        -: 2033:  char *df;
        -: 2034:  int i;
        -: 2035:
        -: 2036:  if (filename == 0 || _USE_LFN)
        -: 2037:    return filename;
        -: 2038:
        -: 2039:  /* FIXME: what about filenames which violate
        -: 2040:     8+3 constraints, like "config.h.in", or ".emacs"?  */
        -: 2041:  if (strpbrk (filename, "\"*+,;<=>?[\\]|") != 0)
        -: 2042:    return filename;
        -: 2043:
        -: 2044:  df = dos_filename;
        -: 2045:
        -: 2046:  /* First, transform the name part.  */
        -: 2047:  for (i = 0; *filename != '\0' && i < 8 && *filename != '.'; ++i)
        -: 2048:    *df++ = tolower ((unsigned char)*filename++);
        -: 2049:
        -: 2050:  /* Now skip to the next dot.  */
        -: 2051:  while (*filename != '\0' && *filename != '.')
        -: 2052:    ++filename;
        -: 2053:  if (*filename != '\0')
        -: 2054:    {
        -: 2055:      *df++ = *filename++;
        -: 2056:      for (i = 0; *filename != '\0' && i < 3 && *filename != '.'; ++i)
        -: 2057:	*df++ = tolower ((unsigned char)*filename++);
        -: 2058:    }
        -: 2059:
        -: 2060:  /* Look for more dots.  */
        -: 2061:  while (*filename != '\0' && *filename != '.')
        -: 2062:    ++filename;
        -: 2063:  if (*filename == '.')
        -: 2064:    return filename;
        -: 2065:  *df = 0;
        -: 2066:  return dos_filename;
        -: 2067:}
        -: 2068:#endif /* __MSDOS__ */
        -: 2069:
        -: 2070:#ifdef WINDOWS32
        -: 2071:#include "pathstuff.h"
        -: 2072:#undef stderr
        -: 2073:#define stderr stdout
        -: 2074:#endif
        -: 2075:
        -: 2076:#ifdef _AMIGA
        -: 2077:#include <ctype.h>
        -: 2078:#undef stderr
        -: 2079:#define stderr stdout
        -: 2080:#endif
        -: 2081:
        -: 2082:#ifdef HAVE_CASE_INSENSITIVE_FS
        -: 2083:static char *
        -: 2084:downcase (filename)
        -: 2085:     char *filename;
        -: 2086:{
        -: 2087:#ifdef _AMIGA
        -: 2088:  static char new_filename[136];
        -: 2089:#else
        -: 2090:  static char new_filename[PATH_MAX];
        -: 2091:#endif
        -: 2092:  char *df;
        -: 2093:  int i;
        -: 2094:
        -: 2095:  if (filename == 0)
        -: 2096:    return 0;
        -: 2097:
        -: 2098:  df = new_filename;
        -: 2099:
        -: 2100:  /* First, transform the name part.  */
        -: 2101:  for (i = 0; *filename != '\0'; ++i)
        -: 2102:  {
        -: 2103:    *df++ = tolower ((unsigned char)*filename);
        -: 2104:    ++filename;
        -: 2105:  }
        -: 2106:
        -: 2107:  *df = 0;
        -: 2108:
        -: 2109:  return new_filename;
        -: 2110:}
        -: 2111:#endif /* HAVE_CASE_INSENSITIVE_FS */
        -: 2112:
        -: 2113:#ifdef VMS
        -: 2114:
        -: 2115:static int
        -: 2116:vms_hash (name)
        -: 2117:    char *name;
        -: 2118:{
        -: 2119:  int h = 0;
        -: 2120:  int g;
        -: 2121:
        -: 2122:  while (*name)
        -: 2123:    {
        -: 2124:      h = (h << 4) + (isupper (*name) ? tolower (*name) : *name);
        -: 2125:      name++;
        -: 2126:      g = h & 0xf0000000;
        -: 2127:      if (g)
        -: 2128:	{
        -: 2129:	  h = h ^ (g >> 24);
        -: 2130:	  h = h ^ g;
        -: 2131:	}
        -: 2132:    }
        -: 2133:  return h;
        -: 2134:}
        -: 2135:
        -: 2136:/* fake stat entry for a directory */
        -: 2137:static int
        -: 2138:vmsstat_dir (name, st)
        -: 2139:    char *name;
        -: 2140:    struct stat *st;
        -: 2141:{
        -: 2142:  char *s;
        -: 2143:  int h;
        -: 2144:  DIR *dir;
        -: 2145:
        -: 2146:  dir = opendir (name);
        -: 2147:  if (dir == 0)
        -: 2148:    return -1;
        -: 2149:  closedir (dir);
        -: 2150:  s = strchr (name, ':');	/* find device */
        -: 2151:  if (s)
        -: 2152:    {
        -: 2153:      *s++ = 0;
        -: 2154:      st->st_dev = (char *)vms_hash (name);
        -: 2155:      h = vms_hash (s);
        -: 2156:      *(s-1) = ':';
        -: 2157:    }
        -: 2158:  else
        -: 2159:    {
        -: 2160:      st->st_dev = 0;
        -: 2161:      s = name;
        -: 2162:      h = vms_hash (s);
        -: 2163:    }
        -: 2164:
        -: 2165:  st->st_ino[0] = h & 0xff;
        -: 2166:  st->st_ino[1] = h & 0xff00;
        -: 2167:  st->st_ino[2] = h >> 16;
        -: 2168:
        -: 2169:  return 0;
        -: 2170:}
        -: 2171:#endif /* VMS */
        -: 2172:
        -: 2173:/* Hash table of directories.  */
        -: 2174:
        -: 2175:#ifndef	DIRECTORY_BUCKETS
        -: 2176:#define DIRECTORY_BUCKETS 199
        -: 2177:#endif
        -: 2178:
        -: 2179:struct directory_contents
        -: 2180:  {
        -: 2181:    struct directory_contents *next;
        -: 2182:
        -: 2183:    dev_t dev;			/* Device and inode numbers of this dir.  */
        -: 2184:#ifdef WINDOWS32
        -: 2185:    /*
        -: 2186:     * Inode means nothing on WINDOWS32. Even file key information is
        -: 2187:     * unreliable because it is random per file open and undefined
        -: 2188:     * for remote filesystems. The most unique attribute I can
        -: 2189:     * come up with is the fully qualified name of the directory. Beware
        -: 2190:     * though, this is also unreliable. I'm open to suggestion on a better
        -: 2191:     * way to emulate inode.
        -: 2192:     */
        -: 2193:    char *path_key;
        -: 2194:    int   mtime;        /* controls check for stale directory cache */
        -: 2195:    int   fs_flags;     /* FS_FAT, FS_NTFS, ... */
        -: 2196:#define FS_FAT      0x1
        -: 2197:#define FS_NTFS     0x2
        -: 2198:#define FS_UNKNOWN  0x4
        -: 2199:#else
        -: 2200:#ifdef VMS
        -: 2201:    ino_t ino[3];
        -: 2202:#else
        -: 2203:    ino_t ino;
        -: 2204:#endif
        -: 2205:#endif /* WINDOWS32 */
        -: 2206:    struct dirfile **files;	/* Files in this directory.  */
        -: 2207:    DIR *dirstream;		/* Stream reading this directory.  */
        -: 2208:  };
        -: 2209:
        -: 2210:/* Table of directory contents hashed by device and inode number.  */
        -: 2211:static struct directory_contents *directories_contents[DIRECTORY_BUCKETS];
        -: 2212:
        -: 2213:struct directory
        -: 2214:  {
        -: 2215:    struct directory *next;
        -: 2216:
        -: 2217:    char *name;			/* Name of the directory.  */
        -: 2218:
        -: 2219:    /* The directory's contents.  This data may be shared by several
        -: 2220:       entries in the hash table, which refer to the same directory
        -: 2221:       (identified uniquely by `dev' and `ino') under different names.  */
        -: 2222:    struct directory_contents *contents;
        -: 2223:  };
        -: 2224:
        -: 2225:/* Table of directories hashed by name.  */
        -: 2226:static struct directory *table_of_directories[DIRECTORY_BUCKETS];
        -: 2227:
        -: 2228:
        -: 2229:/* Never have more than this many directories open at once.  */
        -: 2230:
        -: 2231:#define MAX_OPEN_DIRECTORIES 10
        -: 2232:
        -: 2233:static unsigned int open_directories = 0;
        -: 2234:
        -: 2235:
        -: 2236:/* Hash table of files in each directory.  */
        -: 2237:
        -: 2238:struct dirfile
        -: 2239:  {
        -: 2240:    struct dirfile *next;
        -: 2241:    char *name;			/* Name of the file.  */
        -: 2242:    char impossible;		/* This file is impossible.  */
        -: 2243:  };
        -: 2244:
        -: 2245:#ifndef	DIRFILE_BUCKETS
        -: 2246:#define DIRFILE_BUCKETS 107
        -: 2247:#endif
        -: 2248:
        -: 2249:static int dir_contents_file_exists_p PARAMS ((struct directory_contents *dir, char *filename));
        -: 2250:static struct directory *find_directory PARAMS ((char *name));
        -: 2251:
        -: 2252:/* Find the directory named NAME and return its `struct directory'.  */
        -: 2253:
        -: 2254:static struct directory *
function find_directory called 314 returned 100% blocks executed 46%
      314: 2255:find_directory (name)
        -: 2256:     register char *name;
        -: 2257:{
      314: 2258:  register unsigned int hash = 0;
        -: 2259:  register char *p;
        -: 2260:  register struct directory *dir;
        -: 2261:#ifdef WINDOWS32
        -: 2262:  char* w32_path;
        -: 2263:  char  fs_label[BUFSIZ];
        -: 2264:  char  fs_type[BUFSIZ];
        -: 2265:  long  fs_serno;
        -: 2266:  long  fs_flags;
        -: 2267:  long  fs_len;
        -: 2268:#endif
        -: 2269:#ifdef VMS
        -: 2270:  if ((*name == '.') && (*(name+1) == 0))
        -: 2271:    name = "[]";
        -: 2272:  else
        -: 2273:    name = vmsify (name,1);
        -: 2274:#endif
        -: 2275:
    11055: 2276:  for (p = name; *p != '\0'; ++p)
branch  0 taken 10741
branch  1 taken 314 (fallthrough)
    10741: 2277:    HASHI (hash, *p);
      314: 2278:  hash %= DIRECTORY_BUCKETS;
        -: 2279:
     314*: 2280:  for (dir = table_of_directories[hash]; dir != 0; dir = dir->next)
branch  0 taken 309
branch  1 taken 5 (fallthrough)
      309: 2281:    if (strieq (dir->name, name))
branch  0 taken 309 (fallthrough)
branch  1 taken 0
branch  2 taken 309 (fallthrough)
branch  3 taken 0
branch  4 taken 309 (fallthrough)
branch  5 taken 0
branch  6 taken 0 (fallthrough)
branch  7 taken 309
        -: 2282:      break;
        -: 2283:
      314: 2284:  if (dir == 0)
branch  0 taken 5 (fallthrough)
branch  1 taken 309
        -: 2285:    {
        -: 2286:      struct stat st;
        -: 2287:
        -: 2288:      /* The directory was not found.  Create a new entry for it.  */
        -: 2289:
        5: 2290:      dir = (struct directory *) xmalloc (sizeof (struct directory));
call    0 returned 5
        5: 2291:      dir->next = table_of_directories[hash];
        5: 2292:      table_of_directories[hash] = dir;
        5: 2293:      dir->name = savestring (name, p - name);
call    0 returned 5
        -: 2294:
        -: 2295:      /* The directory is not in the name hash table.
        -: 2296:	 Find its device and inode numbers, and look it up by them.  */
        -: 2297:
        -: 2298:#ifdef VMS
        -: 2299:      if (vmsstat_dir (name, &st) < 0)
        -: 2300:#else
        -: 2301:
        -: 2302:# ifdef WINDOWS32
        -: 2303:      /* Remove any trailing '\'.  Windows32 stat fails even on valid
        -: 2304:         directories if they end in '\'. */
        -: 2305:      if (p[-1] == '\\')
        -: 2306:        p[-1] = '\0';
        -: 2307:# endif
        5: 2308:      if (stat (name, &st) < 0)
call    0 returned 5
branch  1 taken 5 (fallthrough)
branch  2 taken 0
        -: 2309:#endif
        -: 2310:	{
        -: 2311:	/* Couldn't stat the directory.  Mark this by
        -: 2312:	   setting the `contents' member to a nil pointer.  */
        5: 2313:	  dir->contents = 0;
        -: 2314:	}
        -: 2315:      else
        -: 2316:	{
        -: 2317:	  /* Search the contents hash table; device and inode are the key.  */
        -: 2318:
        -: 2319:	  struct directory_contents *dc;
        -: 2320:
        -: 2321:#ifdef WINDOWS32
        -: 2322:          w32_path = w32ify(name, 1);
        -: 2323:          hash = ((unsigned int) st.st_dev << 16) | (unsigned int) st.st_ctime;
        -: 2324:#else
        -: 2325:# ifdef VMS
        -: 2326:          hash = (((unsigned int) st.st_dev << 16)
        -: 2327:                  | ((unsigned int) st.st_ino[0]
        -: 2328:                     + (unsigned int) st.st_ino[1]
        -: 2329:                     + (unsigned int) st.st_ino[2]));
        -: 2330:# else
    #####: 2331:	  hash = ((unsigned int) (dev_t_to_int(st.st_dev)) << 16) | (ino_t_to_unsigned_int(st.st_ino));
call    0 never executed
call    1 never executed
        -: 2332:	  /*	  hash = ((unsigned int) st.st_dev << 16) | (unsigned int) st.st_ino; */
        -: 2333:# endif
        -: 2334:#endif
    #####: 2335:	  hash %= DIRECTORY_BUCKETS;
        -: 2336:
    #####: 2337:	  for (dc = directories_contents[hash]; dc != 0; dc = dc->next)
branch  0 never executed
branch  1 never executed
        -: 2338:#ifdef WINDOWS32
        -: 2339:            if (strieq(dc->path_key, w32_path))
        -: 2340:#else
    #####: 2341:	    if (dc->dev == st.st_dev
branch  0 never executed
branch  1 never executed
        -: 2342:# ifdef VMS
        -: 2343:		&& dc->ino[0] == st.st_ino[0]
        -: 2344:		&& dc->ino[1] == st.st_ino[1]
        -: 2345:		&& dc->ino[2] == st.st_ino[2]
        -: 2346:# else
    #####: 2347:                && ino_t_equal(ino_t_to_int(dc->ino), ino_t_to_int(st.st_ino)) == 0
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 2348:		/*                && dc->ino == st.st_ino */
        -: 2349:# endif
        -: 2350:                )
        -: 2351:#endif /* WINDOWS32 */
    #####: 2352:	      break;
        -: 2353:
    #####: 2354:	  if (dc == 0)
branch  0 never executed
branch  1 never executed
        -: 2355:	    {
        -: 2356:	      /* Nope; this really is a directory we haven't seen before.  */
        -: 2357:
        -: 2358:	      dc = (struct directory_contents *)
    #####: 2359:		xmalloc (sizeof (struct directory_contents));
call    0 never executed
        -: 2360:
        -: 2361:	      /* Enter it in the contents hash table.  */
    #####: 2362:	      dc->dev = st.st_dev;
        -: 2363:#ifdef WINDOWS32
        -: 2364:              dc->path_key = xstrdup(w32_path);
        -: 2365:              dc->mtime = st.st_mtime;
        -: 2366:
        -: 2367:              /*
        -: 2368:               * NTFS is the only WINDOWS32 filesystem that bumps mtime
        -: 2369:               * on a directory when files are added/deleted from
        -: 2370:               * a directory.
        -: 2371:               */
        -: 2372:              w32_path[3] = '\0';
        -: 2373:              if (GetVolumeInformation(w32_path,
        -: 2374:                     fs_label, sizeof (fs_label),
        -: 2375:                     &fs_serno, &fs_len,
        -: 2376:                     &fs_flags, fs_type, sizeof (fs_type)) == FALSE)
        -: 2377:                dc->fs_flags = FS_UNKNOWN;
        -: 2378:              else if (!strcmp(fs_type, "FAT"))
        -: 2379:                dc->fs_flags = FS_FAT;
        -: 2380:              else if (!strcmp(fs_type, "NTFS"))
        -: 2381:                dc->fs_flags = FS_NTFS;
        -: 2382:              else
        -: 2383:                dc->fs_flags = FS_UNKNOWN;
        -: 2384:#else
        -: 2385:# ifdef VMS
        -: 2386:	      dc->ino[0] = st.st_ino[0];
        -: 2387:	      dc->ino[1] = st.st_ino[1];
        -: 2388:	      dc->ino[2] = st.st_ino[2];
        -: 2389:# else
    #####: 2390:	      dc->ino = st.st_ino;
        -: 2391:# endif
        -: 2392:#endif /* WINDOWS32 */
    #####: 2393:	      dc->next = directories_contents[hash];
    #####: 2394:	      directories_contents[hash] = dc;
        -: 2395:
    #####: 2396:	      dc->dirstream = opendir (name);
call    0 never executed
    #####: 2397:	      if (dc->dirstream == 0)
branch  0 never executed
branch  1 never executed
        -: 2398:                /* Couldn't open the directory.  Mark this by
        -: 2399:                   setting the `files' member to a nil pointer.  */
    #####: 2400:                dc->files = 0;
        -: 2401:	      else
        -: 2402:		{
        -: 2403:		  /* Allocate an array of buckets for files and zero it.  */
    #####: 2404:		  dc->files = (struct dirfile **)
    #####: 2405:		    xmalloc (sizeof (struct dirfile *) * DIRFILE_BUCKETS);
call    0 never executed
    #####: 2406:		  bzero ((char *) dc->files,
        -: 2407:			 sizeof (struct dirfile *) * DIRFILE_BUCKETS);
        -: 2408:
        -: 2409:		  /* Keep track of how many directories are open.  */
    #####: 2410:		  ++open_directories;
    #####: 2411:		  if (open_directories == MAX_OPEN_DIRECTORIES)
branch  0 never executed
branch  1 never executed
        -: 2412:		    /* We have too many directories open already.
        -: 2413:		       Read the entire directory and then close it.  */
    #####: 2414:		    (void) dir_contents_file_exists_p (dc, (char *) 0);
call    0 never executed
        -: 2415:		}
        -: 2416:	    }
        -: 2417:
        -: 2418:	  /* Point the name-hashed entry for DIR at its contents data.  */
    #####: 2419:	  dir->contents = dc;
        -: 2420:	}
        -: 2421:    }
        -: 2422:
      314: 2423:  return dir;
        -: 2424:}
        -: 2425:
        -: 2426:/* Return 1 if the name FILENAME is entered in DIR's hash table.
        -: 2427:   FILENAME must contain no slashes.  */
        -: 2428:
        -: 2429:static int
function dir_contents_file_exists_p called 142 returned 100% blocks executed 44%
      142: 2430:dir_contents_file_exists_p (dir, filename)
        -: 2431:     register struct directory_contents *dir;
        -: 2432:     register char *filename;
        -: 2433:{
        -: 2434:  register unsigned int hash;
        -: 2435:  register char *p;
        -: 2436:  register struct dirfile *df;
        -: 2437:  register struct dirent *d;
        -: 2438:#ifdef WINDOWS32
        -: 2439:  struct stat st;
        -: 2440:  int rehash = 0;
        -: 2441:#endif
        -: 2442:
      142: 2443:  if (dir == 0 || dir->files == 0)
branch  0 taken 46 (fallthrough)
branch  1 taken 96
branch  2 taken 0 (fallthrough)
branch  3 taken 46
        -: 2444:    {
        -: 2445:    /* The directory could not be stat'd or opened.  */
       96: 2446:      return 0;
        -: 2447:    }
        -: 2448:#ifdef __MSDOS__
        -: 2449:  filename = dosify (filename);
        -: 2450:#endif
        -: 2451:
        -: 2452:#ifdef HAVE_CASE_INSENSITIVE_FS
        -: 2453:  filename = downcase (filename);
        -: 2454:#endif
        -: 2455:
        -: 2456:#ifdef VMS
        -: 2457:  filename = vmsify (filename,0);
        -: 2458:#endif
        -: 2459:
       46: 2460:  hash = 0;
       46: 2461:  if (filename != 0)
branch  0 taken 46 (fallthrough)
branch  1 taken 0
        -: 2462:    {
       46: 2463:      if (*filename == '\0')
branch  0 taken 0 (fallthrough)
branch  1 taken 46
        -: 2464:	{
        -: 2465:	/* Checking if the directory exists.  */
    #####: 2466:	  return 1;
        -: 2467:	}
        -: 2468:
      726: 2469:      for (p = filename; *p != '\0'; ++p)
branch  0 taken 680
branch  1 taken 46 (fallthrough)
      680: 2470:	HASH (hash, *p);
       46: 2471:      hash %= DIRFILE_BUCKETS;
        -: 2472:
        -: 2473:      /* Search the list of hashed files.  */
        -: 2474:
       49: 2475:      for (df = dir->files[hash]; df != 0; df = df->next)
branch  0 taken 3
branch  1 taken 46 (fallthrough)
        -: 2476:	{
        3: 2477:	  if (strieq (df->name, filename))
branch  0 taken 3 (fallthrough)
branch  1 taken 0
branch  2 taken 1 (fallthrough)
branch  3 taken 2
branch  4 taken 1 (fallthrough)
branch  5 taken 0
branch  6 taken 0 (fallthrough)
branch  7 taken 1
        -: 2478:	    {
    #####: 2479:	      return !df->impossible;
        -: 2480:	    }
        -: 2481:	}
        -: 2482:    }
        -: 2483:
        -: 2484:  /* The file was not found in the hashed list.
        -: 2485:     Try to read the directory further.  */
        -: 2486:
       46: 2487:  if (dir->dirstream == 0)
branch  0 taken 46 (fallthrough)
branch  1 taken 0
        -: 2488:    {
        -: 2489:#ifdef WINDOWS32
        -: 2490:      /*
        -: 2491:       * Check to see if directory has changed since last read. FAT
        -: 2492:       * filesystems force a rehash always as mtime does not change
        -: 2493:       * on directories (ugh!).
        -: 2494:       */
        -: 2495:      if (dir->path_key &&
        -: 2496:          (dir->fs_flags & FS_FAT ||
        -: 2497:           (stat(dir->path_key, &st) == 0 &&
        -: 2498:            st.st_mtime > dir->mtime))) {
        -: 2499:
        -: 2500:        /* reset date stamp to show most recent re-process */
        -: 2501:        dir->mtime = st.st_mtime;
        -: 2502:
        -: 2503:        /* make sure directory can still be opened */
        -: 2504:        dir->dirstream = opendir(dir->path_key);
        -: 2505:
        -: 2506:        if (dir->dirstream)
        -: 2507:          rehash = 1;
        -: 2508:        else
        -: 2509:          return 0; /* couldn't re-read - fail */
        -: 2510:      } else
        -: 2511:#endif
        -: 2512:    /* The directory has been all read in.  */
       46: 2513:      return 0;
        -: 2514:    }
        -: 2515:
    #####: 2516:  while ((d = readdir (dir->dirstream)) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2517:    {
        -: 2518:      /* Enter the file in the hash table.  */
    #####: 2519:      register unsigned int newhash = 0;
        -: 2520:      unsigned int len;
        -: 2521:      register unsigned int i;
        -: 2522:
        -: 2523:#if defined(VMS) && defined(HAVE_DIRENT_H)
        -: 2524:      /* In VMS we get file versions too, which have to be stripped off */
        -: 2525:      {
        -: 2526:        char *p = strrchr (d->d_name, ';');
        -: 2527:        if (p)
        -: 2528:          *p = '\0';
        -: 2529:      }
        -: 2530:#endif
    #####: 2531:      if (!REAL_DIR_ENTRY (d))
branch  0 never executed
branch  1 never executed
    #####: 2532:	continue;
        -: 2533:
    #####: 2534:      len = NAMLEN (d);
    #####: 2535:      for (i = 0; i < len; ++i)
branch  0 never executed
branch  1 never executed
    #####: 2536:	HASHI (newhash, d->d_name[i]);
    #####: 2537:      newhash %= DIRFILE_BUCKETS;
        -: 2538:#ifdef WINDOWS32
        -: 2539:      /*
        -: 2540:       * If re-reading a directory, check that this file isn't already
        -: 2541:       * in the cache.
        -: 2542:       */
        -: 2543:      if (rehash) {
        -: 2544:        for (df = dir->files[newhash]; df != 0; df = df->next)
        -: 2545:          if (streq(df->name, d->d_name))
        -: 2546:            break;
        -: 2547:      } else
        -: 2548:        df = 0;
        -: 2549:
        -: 2550:      /*
        -: 2551:       * If re-reading a directory, don't cache files that have
        -: 2552:       * already been discovered.
        -: 2553:       */
        -: 2554:      if (!df) {
        -: 2555:#endif
        -: 2556:
    #####: 2557:      df = (struct dirfile *) xmalloc (sizeof (struct dirfile));
call    0 never executed
    #####: 2558:      df->next = dir->files[newhash];
    #####: 2559:      dir->files[newhash] = df;
    #####: 2560:      df->name = savestring (d->d_name, len);
call    0 never executed
    #####: 2561:      df->impossible = 0;
        -: 2562:#ifdef WINDOWS32
        -: 2563:      }
        -: 2564:#endif
        -: 2565:      /* Check if the name matches the one we're searching for.  */
    #####: 2566:      if (filename != 0
branch  0 never executed
branch  1 never executed
    #####: 2567:	  && newhash == hash && strieq (d->d_name, filename))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
        -: 2568:	{
    #####: 2569:	  return 1;
        -: 2570:	}
        -: 2571:    }
        -: 2572:
        -: 2573:  /* If the directory has been completely read in,
        -: 2574:     close the stream and reset the pointer to nil.  */
    #####: 2575:  if (d == 0)
branch  0 never executed
branch  1 never executed
        -: 2576:    {
    #####: 2577:      --open_directories;
    #####: 2578:      closedir (dir->dirstream);
call    0 never executed
    #####: 2579:      dir->dirstream = 0;
        -: 2580:    }
    #####: 2581:  return 0;
        -: 2582:}
        -: 2583:
        -: 2584:/* Return 1 if the name FILENAME in directory DIRNAME
        -: 2585:   is entered in the dir hash table.
        -: 2586:   FILENAME must contain no slashes.  */
        -: 2587:
        -: 2588:int
function dir_file_exists_p called 142 returned 100% blocks executed 100%
      142: 2589:dir_file_exists_p (dirname, filename)
        -: 2590:     register char *dirname;
        -: 2591:     register char *filename;
        -: 2592:{
      142: 2593:  return dir_contents_file_exists_p (find_directory (dirname)->contents,
call    0 returned 142
call    1 returned 142
        -: 2594:				     filename);
        -: 2595:}
        -: 2596:
        -: 2597:/* Return 1 if the file named NAME exists.  */
        -: 2598:
        -: 2599:int
function file_exists_p called 139 returned 100% blocks executed 58%
      139: 2600:file_exists_p (name)
        -: 2601:     register char *name;
        -: 2602:{
        -: 2603:  char *dirend;
        -: 2604:  char *dirname;
        -: 2605:  char *slash;
        -: 2606:
        -: 2607:#ifndef	NO_ARCHIVES
      139: 2608:  if (ar_name (name))
call    0 returned 139
branch  1 taken 0 (fallthrough)
branch  2 taken 139
    #####: 2609:    return ar_member_date (name) != (time_t) -1;
call    0 never executed
        -: 2610:#endif
        -: 2611:
        -: 2612:#ifdef VMS
        -: 2613:  dirend = strrchr (name, ']');
        -: 2614:  if (dirend == 0)
        -: 2615:    dirend = strrchr (name, ':');
        -: 2616:  dirend++;
        -: 2617:  if (dirend == (char *)1)
        -: 2618:    return dir_file_exists_p ("[]", name);
        -: 2619:#else /* !VMS */
      139: 2620:  dirend = strrchr (name, '/');
        -: 2621:#if defined (WINDOWS32) || defined (__MSDOS__)
        -: 2622:  /* Forward and backslashes might be mixed.  We need the rightmost one.  */
        -: 2623:  {
        -: 2624:    char *bslash = strrchr(name, '\\');
        -: 2625:    if (!dirend || bslash > dirend)
        -: 2626:      dirend = bslash;
        -: 2627:    /* The case of "d:file".  */
        -: 2628:    if (!dirend && name[0] && name[1] == ':')
        -: 2629:      dirend = name + 1;
        -: 2630:  }
        -: 2631:#endif /* WINDOWS32 || __MSDOS__ */
      139: 2632:  if (dirend == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 139
        -: 2633:#ifndef _AMIGA
    #####: 2634:    return dir_file_exists_p (".", name);
call    0 never executed
        -: 2635:#else /* !VMS && !AMIGA */
        -: 2636:    return dir_file_exists_p ("", name);
        -: 2637:#endif /* AMIGA */
        -: 2638:#endif /* VMS */
        -: 2639:
      139: 2640:  slash = dirend;
      139: 2641:  if (dirend == name)
branch  0 taken 0 (fallthrough)
branch  1 taken 139
    #####: 2642:    dirname = "/";
        -: 2643:  else
        -: 2644:    {
        -: 2645:#if defined (WINDOWS32) || defined (__MSDOS__)
        -: 2646:  /* d:/ and d: are *very* different...  */
        -: 2647:      if (dirend < name + 3 && name[1] == ':' &&
        -: 2648:	  (*dirend == '/' || *dirend == '\\' || *dirend == ':'))
        -: 2649:	dirend++;
        -: 2650:#endif
      139: 2651:      dirname = (char *) alloca (dirend - name + 1);
      139: 2652:      bcopy (name, dirname, dirend - name);
      139: 2653:      dirname[dirend - name] = '\0';
        -: 2654:    }
      139: 2655:  return dir_file_exists_p (dirname, slash + 1);
call    0 returned 139
        -: 2656:}
        -: 2657:
        -: 2658:/* Mark FILENAME as `impossible' for `file_impossible_p'.
        -: 2659:   This means an attempt has been made to search for FILENAME
        -: 2660:   as an intermediate file, and it has failed.  */
        -: 2661:
        -: 2662:void
function file_impossible called 17 returned 100% blocks executed 90%
       17: 2663:file_impossible (filename)
        -: 2664:     register char *filename;
        -: 2665:{
        -: 2666:  char *dirend;
       17: 2667:  register char *p = filename;
        -: 2668:  register unsigned int hash;
        -: 2669:  register struct directory *dir;
        -: 2670:  register struct dirfile *new;
        -: 2671:
        -: 2672:#ifdef VMS
        -: 2673:  dirend = strrchr (p, ']');
        -: 2674:  if (dirend == 0)
        -: 2675:    dirend = strrchr (p, ':');
        -: 2676:  dirend++;
        -: 2677:  if (dirend == (char *)1)
        -: 2678:    dir = find_directory ("[]");
        -: 2679:#else
       17: 2680:  dirend = strrchr (p, '/');
        -: 2681:#if defined (WINDOWS32) || defined (__MSDOS__)
        -: 2682:  /* Forward and backslashes might be mixed.  We need the rightmost one.  */
        -: 2683:  {
        -: 2684:    char *bslash = strrchr(p, '\\');
        -: 2685:    if (!dirend || bslash > dirend)
        -: 2686:      dirend = bslash;
        -: 2687:    /* The case of "d:file".  */
        -: 2688:    if (!dirend && p[0] && p[1] == ':')
        -: 2689:      dirend = p + 1;
        -: 2690:  }
        -: 2691:#endif /* WINDOWS32 or __MSDOS__ */
       17: 2692:  if (dirend == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 17
        -: 2693:#ifdef _AMIGA
        -: 2694:    dir = find_directory ("");
        -: 2695:#else /* !VMS && !AMIGA */
    #####: 2696:    dir = find_directory (".");
call    0 never executed
        -: 2697:#endif /* AMIGA */
        -: 2698:#endif /* VMS */
        -: 2699:  else
        -: 2700:    {
        -: 2701:      char *dirname;
       17: 2702:      char *slash = dirend;
       17: 2703:      if (dirend == p)
branch  0 taken 0 (fallthrough)
branch  1 taken 17
    #####: 2704:	dirname = "/";
        -: 2705:      else
        -: 2706:	{
        -: 2707:#if defined (WINDOWS32) || defined (__MSDOS__)
        -: 2708:	  /* d:/ and d: are *very* different...  */
        -: 2709:	  if (dirend < p + 3 && p[1] == ':' &&
        -: 2710:	      (*dirend == '/' || *dirend == '\\' || *dirend == ':'))
        -: 2711:	    dirend++;
        -: 2712:#endif
       17: 2713:	  dirname = (char *) alloca (dirend - p + 1);
       17: 2714:	  bcopy (p, dirname, dirend - p);
       17: 2715:	  dirname[dirend - p] = '\0';
        -: 2716:	}
       17: 2717:      dir = find_directory (dirname);
call    0 returned 17
       17: 2718:      filename = p = slash + 1;
        -: 2719:    }
        -: 2720:
      246: 2721:  for (hash = 0; *p != '\0'; ++p)
branch  0 taken 229
branch  1 taken 17 (fallthrough)
      229: 2722:    HASHI (hash, *p);
       17: 2723:  hash %= DIRFILE_BUCKETS;
        -: 2724:
       17: 2725:  if (dir->contents == 0)
branch  0 taken 1 (fallthrough)
branch  1 taken 16
        -: 2726:    {
        -: 2727:      /* The directory could not be stat'd.  We allocate a contents
        -: 2728:	 structure for it, but leave it out of the contents hash table.  */
        1: 2729:      dir->contents = (struct directory_contents *)
        1: 2730:	xmalloc (sizeof (struct directory_contents));
call    0 returned 1
        -: 2731:#ifdef WINDOWS32
        -: 2732:      dir->contents->path_key = NULL;
        -: 2733:      dir->contents->mtime = 0;
        -: 2734:#else  /* WINDOWS32 */
        -: 2735:#ifdef VMS
        -: 2736:      dir->contents->dev = 0;
        -: 2737:      dir->contents->ino[0] = dir->contents->ino[1] =
        -: 2738:	dir->contents->ino[2] = 0;
        -: 2739:#else
        1: 2740:      dir->contents->dev = int_to_dev_t(0);
call    0 returned 1
        1: 2741:      dir->contents->ino = int_to_ino_t(0);
call    0 returned 1
        -: 2742:      /*      dir->contents->dev = dir->contents->ino = 0; */
        -: 2743:#endif
        -: 2744:#endif /* WINDOWS32 */
        1: 2745:      dir->contents->files = 0;
        1: 2746:      dir->contents->dirstream = 0;
        -: 2747:    }
        -: 2748:
       17: 2749:  if (dir->contents->files == 0)
branch  0 taken 1 (fallthrough)
branch  1 taken 16
        -: 2750:    {
        -: 2751:      /* The directory was not opened; we must allocate the hash buckets.  */
        2: 2752:      dir->contents->files = (struct dirfile **)
        1: 2753:	xmalloc (sizeof (struct dirfile) * DIRFILE_BUCKETS);
call    0 returned 1
        1: 2754:      bzero ((char *) dir->contents->files,
        -: 2755:	     sizeof (struct dirfile) * DIRFILE_BUCKETS);
        -: 2756:    }
        -: 2757:
        -: 2758:  /* Make a new entry and put it in the table.  */
        -: 2759:
       17: 2760:  new = (struct dirfile *) xmalloc (sizeof (struct dirfile));
call    0 returned 17
       17: 2761:  new->next = dir->contents->files[hash];
       17: 2762:  dir->contents->files[hash] = new;
       17: 2763:  new->name = xstrdup (filename);
call    0 returned 17
       17: 2764:  new->impossible = 1;
       17: 2765:}
        -: 2766:
        -: 2767:/* Return nonzero if FILENAME has been marked impossible.  */
        -: 2768:
        -: 2769:int
function file_impossible_p called 155 returned 100% blocks executed 88%
      155: 2770:file_impossible_p (filename)
        -: 2771:     char *filename;
        -: 2772:{
        -: 2773:  char *dirend;
      155: 2774:  register char *p = filename;
        -: 2775:  register unsigned int hash;
        -: 2776:  register struct directory_contents *dir;
        -: 2777:  register struct dirfile *next;
        -: 2778:
        -: 2779:#ifdef VMS
        -: 2780:  dirend = strrchr (filename, ']');
        -: 2781:  if (dirend == 0)
        -: 2782:    dir = find_directory ("[]")->contents;
        -: 2783:#else
      155: 2784:  dirend = strrchr (filename, '/');
        -: 2785:#if defined (WINDOWS32) || defined (__MSDOS__)
        -: 2786:  /* Forward and backslashes might be mixed.  We need the rightmost one.  */
        -: 2787:  {
        -: 2788:    char *bslash = strrchr(filename, '\\');
        -: 2789:    if (!dirend || bslash > dirend)
        -: 2790:      dirend = bslash;
        -: 2791:    /* The case of "d:file".  */
        -: 2792:    if (!dirend && filename[0] && filename[1] == ':')
        -: 2793:      dirend = filename + 1;
        -: 2794:  }
        -: 2795:#endif /* WINDOWS32 || __MSDOS__ */
      155: 2796:  if (dirend == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 155
        -: 2797:#ifdef _AMIGA
        -: 2798:    dir = find_directory ("")->contents;
        -: 2799:#else /* !VMS && !AMIGA */
    #####: 2800:    dir = find_directory (".")->contents;
call    0 never executed
        -: 2801:#endif /* AMIGA */
        -: 2802:#endif /* VMS */
        -: 2803:  else
        -: 2804:    {
        -: 2805:      char *dirname;
      155: 2806:      char *slash = dirend;
      155: 2807:      if (dirend == filename)
branch  0 taken 0 (fallthrough)
branch  1 taken 155
    #####: 2808:	dirname = "/";
        -: 2809:      else
        -: 2810:	{
        -: 2811:#if defined (WINDOWS32) || defined (__MSDOS__)
        -: 2812:	  /* d:/ and d: are *very* different...  */
        -: 2813:	  if (dirend < filename + 3 && filename[1] == ':' &&
        -: 2814:	      (*dirend == '/' || *dirend == '\\' || *dirend == ':'))
        -: 2815:	    dirend++;
        -: 2816:#endif
      155: 2817:	  dirname = (char *) alloca (dirend - filename + 1);
      155: 2818:	  bcopy (p, dirname, dirend - p);
      155: 2819:	  dirname[dirend - p] = '\0';
        -: 2820:	}
      155: 2821:      dir = find_directory (dirname)->contents;
call    0 returned 155
      155: 2822:      p = filename = slash + 1;
        -: 2823:    }
        -: 2824:
      155: 2825:  if (dir == 0 || dir->files == 0)
branch  0 taken 62 (fallthrough)
branch  1 taken 93
branch  2 taken 0 (fallthrough)
branch  3 taken 62
        -: 2826:    /* There are no files entered for this directory.  */
       93: 2827:    return 0;
        -: 2828:
        -: 2829:#ifdef __MSDOS__
        -: 2830:  p = filename = dosify (p);
        -: 2831:#endif
        -: 2832:#ifdef HAVE_CASE_INSENSITIVE_FS
        -: 2833:  p = filename = downcase (p);
        -: 2834:#endif
        -: 2835:#ifdef VMS
        -: 2836:  p = filename = vmsify (p, 1);
        -: 2837:#endif
        -: 2838:
      955: 2839:  for (hash = 0; *p != '\0'; ++p)
branch  0 taken 893
branch  1 taken 62 (fallthrough)
      893: 2840:    HASH (hash, *p);
       62: 2841:  hash %= DIRFILE_BUCKETS;
        -: 2842:
       65: 2843:  for (next = dir->files[hash]; next != 0; next = next->next)
branch  0 taken 19
branch  1 taken 46 (fallthrough)
       19: 2844:    if (strieq (filename, next->name))
branch  0 taken 19 (fallthrough)
branch  1 taken 0
branch  2 taken 17 (fallthrough)
branch  3 taken 2
branch  4 taken 17 (fallthrough)
branch  5 taken 0
branch  6 taken 16 (fallthrough)
branch  7 taken 1
       16: 2845:      return next->impossible;
        -: 2846:
       46: 2847:  return 0;
        -: 2848:}
        -: 2849:
        -: 2850:/* Return the already allocated name in the
        -: 2851:   directory hash table that matches DIR.  */
        -: 2852:
        -: 2853:char *
function dir_name called 0 returned 0% blocks executed 0%
    #####: 2854:dir_name (dir)
        -: 2855:     char *dir;
        -: 2856:{
    #####: 2857:  return find_directory (dir)->name;
call    0 never executed
        -: 2858:}
        -: 2859:
        -: 2860:/* Print the data base of directories.  */
        -: 2861:
        -: 2862:void
function print_dir_data_base called 1 returned 100% blocks executed 83%
        1: 2863:print_dir_data_base ()
        -: 2864:{
        -: 2865:  register unsigned int i, dirs, files, impossible;
        -: 2866:  register struct directory *dir;
        -: 2867:
        1: 2868:  puts (_("\n# Directories\n"));
call    0 returned 1
        -: 2869:
        1: 2870:  dirs = files = impossible = 0;
      200: 2871:  for (i = 0; i < DIRECTORY_BUCKETS; ++i)
branch  0 taken 199
branch  1 taken 1 (fallthrough)
      204: 2872:    for (dir = table_of_directories[i]; dir != 0; dir = dir->next)
branch  0 taken 5
branch  1 taken 199 (fallthrough)
        -: 2873:      {
        5: 2874:	++dirs;
        5: 2875:	if (dir->contents == 0)
branch  0 taken 4 (fallthrough)
branch  1 taken 1
        4: 2876:	  printf (_("# %s: could not be stat'd.\n"), dir->name);
call    0 returned 4
        1: 2877:	else if (dir->contents->files == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -: 2878:#ifdef WINDOWS32
        -: 2879:          printf (_("# %s (key %s, mtime %d): could not be opened.\n"),
        -: 2880:                  dir->name, dir->contents->path_key,dir->contents->mtime);
        -: 2881:#else  /* WINDOWS32 */
        -: 2882:#ifdef VMS
        -: 2883:	  printf (_("# %s (device %d, inode [%d,%d,%d]): could not be opened.\n"),
        -: 2884:		  dir->name, dir->contents->dev,
        -: 2885:		  dir->contents->ino[0], dir->contents->ino[1],
        -: 2886:		  dir->contents->ino[2]);
        -: 2887:#else
    #####: 2888:	  printf (_("# %s (device %ld, inode %ld): could not be opened.\n"),
    #####: 2889:		  dir->name, (long int) dir->contents->dev,
call    0 never executed
    #####: 2890:		  (ino_t_to_long_int(dir->contents->ino)));
call    0 never executed
        -: 2891:	  /*		  (long int) dir->contents->ino); */
        -: 2892:#endif
        -: 2893:#endif /* WINDOWS32 */
        -: 2894:	else
        -: 2895:	  {
        1: 2896:	    register unsigned int f = 0, im = 0;
        -: 2897:	    register unsigned int j;
        -: 2898:	    register struct dirfile *df;
      108: 2899:	    for (j = 0; j < DIRFILE_BUCKETS; ++j)
branch  0 taken 107
branch  1 taken 1 (fallthrough)
      124: 2900:	      for (df = dir->contents->files[j]; df != 0; df = df->next)
branch  0 taken 17
branch  1 taken 107 (fallthrough)
       17: 2901:		if (df->impossible)
branch  0 taken 17 (fallthrough)
branch  1 taken 0
       17: 2902:		  ++im;
        -: 2903:		else
    #####: 2904:		  ++f;
        -: 2905:#ifdef WINDOWS32
        -: 2906:            printf (_("# %s (key %s, mtime %d): "),
        -: 2907:                    dir->name, dir->contents->path_key, dir->contents->mtime);
        -: 2908:#else  /* WINDOWS32 */
        -: 2909:#ifdef VMS
        -: 2910:	    printf (_("# %s (device %d, inode [%d,%d,%d]): "),
        -: 2911:		    dir->name, dir->contents->dev,
        -: 2912:			dir->contents->ino[0], dir->contents->ino[1],
        -: 2913:			dir->contents->ino[2]);
        -: 2914:#else
        1: 2915:	    printf (_("# %s (device %ld, inode %ld): "),
call    0 returned 1
        -: 2916:		    dir->name,
        1: 2917:                    (long)(dev_t_to_int(dir->contents->dev)), (ino_t_to_long(dir->contents->ino)));
call    0 returned 1
call    1 returned 1
        -: 2918:	    /*                    (long)dir->contents->dev, (long)dir->contents->ino); */
        -: 2919:#endif
        -: 2920:#endif /* WINDOWS32 */
        1: 2921:	    if (f == 0)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 2922:	      fputs (_("No"), stdout);
call    0 returned 1
        -: 2923:	    else
    #####: 2924:	      printf ("%u", f);
call    0 never executed
        1: 2925:	    fputs (_(" files, "), stdout);
call    0 returned 1
        1: 2926:	    if (im == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 2927:	      fputs (_("no"), stdout);
call    0 never executed
        -: 2928:	    else
        1: 2929:	      printf ("%u", im);
call    0 returned 1
        1: 2930:	    fputs (_(" impossibilities"), stdout);
call    0 returned 1
        1: 2931:	    if (dir->contents->dirstream == 0)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 2932:	      puts (".");
call    0 returned 1
        -: 2933:	    else
    #####: 2934:	      puts (_(" so far."));
call    0 never executed
        1: 2935:	    files += f;
        1: 2936:	    impossible += im;
        -: 2937:	  }
        -: 2938:      }
        -: 2939:
        1: 2940:  fputs ("\n# ", stdout);
call    0 returned 1
        1: 2941:  if (files == 0)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 2942:    fputs (_("No"), stdout);
call    0 returned 1
        -: 2943:  else
    #####: 2944:    printf ("%u", files);
call    0 never executed
        1: 2945:  fputs (_(" files, "), stdout);
call    0 returned 1
        1: 2946:  if (impossible == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 2947:    fputs (_("no"), stdout);
call    0 never executed
        -: 2948:  else
        1: 2949:    printf ("%u", impossible);
call    0 returned 1
        1: 2950:  printf (_(" impossibilities in %u directories.\n"), dirs);
call    0 returned 1
        1: 2951:}
        -: 2952:
        -: 2953:/* Hooks for globbing.  */
        -: 2954:
        -: 2955:#include <glob.h>
        -: 2956:#undef stderr
        -: 2957:#define stderr stdout
        -: 2958:
        -: 2959:/* Structure describing state of iterating through a directory hash table.  */
        -: 2960:
        -: 2961:struct dirstream
        -: 2962:  {
        -: 2963:    struct directory_contents *contents; /* The directory being read.  */
        -: 2964:
        -: 2965:    unsigned int bucket;	/* Current hash bucket.  */
        -: 2966:    struct dirfile *elt;	/* Current elt in bucket.  */
        -: 2967:  };
        -: 2968:
        -: 2969:/* Forward declarations.  */
        -: 2970:static __ptr_t open_dirstream PARAMS ((const char *));
        -: 2971:static struct dirent *read_dirstream PARAMS ((__ptr_t));
        -: 2972:
        -: 2973:static __ptr_t
function open_dirstream called 0 returned 0% blocks executed 0%
    #####: 2974:open_dirstream (directory)
        -: 2975:     const char *directory;
        -: 2976:{
        -: 2977:  struct dirstream *new;
    #####: 2978:  struct directory *dir = find_directory ((char *)directory);
call    0 never executed
        -: 2979:
    #####: 2980:  if (dir->contents == 0 || dir->contents->files == 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2981:    /* DIR->contents is nil if the directory could not be stat'd.
        -: 2982:       DIR->contents->files is nil if it could not be opened.  */
    #####: 2983:    return 0;
        -: 2984:
        -: 2985:  /* Read all the contents of the directory now.  There is no benefit
        -: 2986:     in being lazy, since glob will want to see every file anyway.  */
        -: 2987:
    #####: 2988:  (void) dir_contents_file_exists_p (dir->contents, (char *) 0);
call    0 never executed
        -: 2989:
    #####: 2990:  new = (struct dirstream *) xmalloc (sizeof (struct dirstream));
call    0 never executed
    #####: 2991:  new->contents = dir->contents;
    #####: 2992:  new->bucket = 0;
    #####: 2993:  new->elt = new->contents->files[0];
        -: 2994:
    #####: 2995:  return (__ptr_t) new;
        -: 2996:}
        -: 2997:
        -: 2998:static struct dirent *
function read_dirstream called 0 returned 0% blocks executed 0%
    #####: 2999:read_dirstream (stream)
        -: 3000:     __ptr_t stream;
        -: 3001:{
    #####: 3002:  struct dirstream *const ds = (struct dirstream *) stream;
        -: 3003:  register struct dirfile *df;
        -: 3004:  static char *buf;
        -: 3005:  static unsigned int bufsz;
        -: 3006:
    #####: 3007:  while (ds->bucket < DIRFILE_BUCKETS)
branch  0 never executed
branch  1 never executed
        -: 3008:    {
    #####: 3009:      while ((df = ds->elt) != 0)
branch  0 never executed
branch  1 never executed
        -: 3010:	{
    #####: 3011:	  ds->elt = df->next;
    #####: 3012:	  if (!df->impossible)
branch  0 never executed
branch  1 never executed
        -: 3013:	    {
        -: 3014:	      /* The glob interface wants a `struct dirent',
        -: 3015:		 so mock one up.  */
        -: 3016:	      struct dirent *d;
    #####: 3017:	      unsigned int len = strlen (df->name) + 1;
    #####: 3018:	      if (sizeof *d - sizeof d->d_name + len > bufsz)
branch  0 never executed
branch  1 never executed
        -: 3019:		{
    #####: 3020:		  if (buf != 0)
branch  0 never executed
branch  1 never executed
    #####: 3021:		    free (buf);
    #####: 3022:		  bufsz *= 2;
    #####: 3023:		  if (sizeof *d - sizeof d->d_name + len > bufsz)
branch  0 never executed
branch  1 never executed
    #####: 3024:		    bufsz = sizeof *d - sizeof d->d_name + len;
    #####: 3025:		  buf = xmalloc (bufsz);
call    0 never executed
        -: 3026:		}
    #####: 3027:	      d = (struct dirent *) buf;
    #####: 3028:	      FAKE_DIR_ENTRY (d);
        -: 3029:#ifdef _DIRENT_HAVE_D_NAMLEN
        -: 3030:	      d->d_namlen = len - 1;
        -: 3031:#endif
        -: 3032:#ifdef _DIRENT_HAVE_D_TYPE
    #####: 3033:	      d->d_type = DT_UNKNOWN;
        -: 3034:#endif
    #####: 3035:	      memcpy (d->d_name, df->name, len);
    #####: 3036:	      return d;
        -: 3037:	    }
        -: 3038:	}
    #####: 3039:      if (++ds->bucket == DIRFILE_BUCKETS)
branch  0 never executed
branch  1 never executed
    #####: 3040:	break;
    #####: 3041:      ds->elt = ds->contents->files[ds->bucket];
        -: 3042:    }
        -: 3043:
    #####: 3044:  return 0;
        -: 3045:}
        -: 3046:
        -: 3047:static void
function ansi_free called 0 returned 0% blocks executed 0%
    #####: 3048:ansi_free(p)
        -: 3049:  void *p;
        -: 3050:{
    #####: 3051:    if (p)
branch  0 never executed
branch  1 never executed
    #####: 3052:      free(p);
    #####: 3053:}
        -: 3054:
        -: 3055:/* On 64 bit ReliantUNIX (5.44 and above) in LFS mode, stat() is actually a
        -: 3056: * macro for stat64().  If stat is a macro, make a local wrapper function to
        -: 3057: * invoke it.
        -: 3058: */
        -: 3059:#ifndef stat
        -: 3060:# ifndef VMS
        -: 3061:extern int stat ();
        -: 3062:# endif
        -: 3063:# define local_stat stat
        -: 3064:#else
        -: 3065:static int local_stat (path, buf)
        -: 3066:    char *path;
        -: 3067:    struct stat *buf;
        -: 3068:{
        -: 3069:  return stat (path, buf);
        -: 3070:}
        -: 3071:#endif
        -: 3072:
        -: 3073:void
function dir_setup_glob called 10 returned 100% blocks executed 100%
       10: 3074:dir_setup_glob (gl)
        -: 3075:     glob_t *gl;
        -: 3076:{
        -: 3077:  /* Bogus sunos4 compiler complains (!) about & before functions.  */
       10: 3078:  gl->gl_opendir = open_dirstream;
       10: 3079:  gl->gl_readdir = read_dirstream;
       10: 3080:  gl->gl_closedir = ansi_free;
       10: 3081:  gl->gl_stat = local_stat;
        -: 3082:  /* We don't bother setting gl_lstat, since glob never calls it.
        -: 3083:     The slot is only there for compatibility with 4.4 BSD.  */
       10: 3084:}
        -: 3085:
        -: 3086:
        -: 3087:
        -: 3088:/*************************************************************
        -: 3089:  ============================================================
        -: 3090:  ************************************************************
        -: 3091:  ============================================================
        -: 3092:  ************************************************************
        -: 3093:                         expand.c
        -: 3094:  ************************************************************
        -: 3095:  ============================================================
        -: 3096:  ************************************************************
        -: 3097:  ============================================================
        -: 3098:  *************************************************************/
        -: 3099:
        -: 3100:/* Variable expansion functions for GNU Make.
        -: 3101:Copyright (C) 1988, 89, 91, 92, 93, 95 Free Software Foundation, Inc.
        -: 3102:This file is part of GNU Make.
        -: 3103:
        -: 3104:GNU Make is free software; you can redistribute it and/or modify
        -: 3105:it under the terms of the GNU General Public License as published by
        -: 3106:the Free Software Foundation; either version 2, or (at your option)
        -: 3107:any later version.
        -: 3108:
        -: 3109:GNU Make is distributed in the hope that it will be useful,
        -: 3110:but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 3111:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 3112:GNU General Public License for more details.
        -: 3113:
        -: 3114:You should have received a copy of the GNU General Public License
        -: 3115:along with GNU Make; see the file COPYING.  If not, write to
        -: 3116:the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
        -: 3117:Boston, MA 02111-1307, USA.  */
        -: 3118:
        -: 3119:#include <assert.h>
        -: 3120:#undef stderr
        -: 3121:#define stderr stdout
        -: 3122:
        -: 3123:/* #include "make.h"  <- modification by J.Ruthruff, 7/28 */
        -: 3124:/* #include "filedef.h"  <- modification by J.Ruthruff, 7/28 */
        -: 3125:#include "job.h"
        -: 3126:/* #include "commands.h"  <- modification by J.Ruthruff, 7/28 */
        -: 3127:/* #include "variable.h"  <- modification by J.Ruthruff, 7/28 */
        -: 3128:#include "rule.h"
        -: 3129:#undef stderr
        -: 3130:#define stderr stdout
        -: 3131:
        -: 3132:/* The next two describe the variable output buffer.
        -: 3133:   This buffer is used to hold the variable-expansion of a line of the
        -: 3134:   makefile.  It is made bigger with realloc whenever it is too small.
        -: 3135:   variable_buffer_length is the size currently allocated.
        -: 3136:   variable_buffer is the address of the buffer.
        -: 3137:
        -: 3138:   For efficiency, it's guaranteed that the buffer will always have
        -: 3139:   VARIABLE_BUFFER_ZONE extra bytes allocated.  This allows you to add a few
        -: 3140:   extra chars without having to call a function.  Note you should never use
        -: 3141:   these bytes unless you're _sure_ you have room (you know when the buffer
        -: 3142:   length was last checked.  */
        -: 3143:
        -: 3144:#define VARIABLE_BUFFER_ZONE    5
        -: 3145:
        -: 3146:static unsigned int variable_buffer_length;
        -: 3147:char *variable_buffer;
        -: 3148:
        -: 3149:/* Subroutine of variable_expand and friends:
        -: 3150:   The text to add is LENGTH chars starting at STRING to the variable_buffer.
        -: 3151:   The text is added to the buffer at PTR, and the updated pointer into
        -: 3152:   the buffer is returned as the value.  Thus, the value returned by
        -: 3153:   each call to variable_buffer_output should be the first argument to
        -: 3154:   the following call.  */
        -: 3155:
        -: 3156:char *
function variable_buffer_output called 24 returned 100% blocks executed 60%
       24: 3157:variable_buffer_output (ptr, string, length)
        -: 3158:     char *ptr, *string;
        -: 3159:     unsigned int length;
        -: 3160:{
       24: 3161:  register unsigned int newlen = length + (ptr - variable_buffer);
        -: 3162:
       24: 3163:  if ((newlen + VARIABLE_BUFFER_ZONE) > variable_buffer_length)
branch  0 taken 0 (fallthrough)
branch  1 taken 24
        -: 3164:    {
    #####: 3165:      unsigned int offset = ptr - variable_buffer;
    #####: 3166:      variable_buffer_length = (newlen + 100 > 2 * variable_buffer_length
        -: 3167:				? newlen + 100
    #####: 3168:				: 2 * variable_buffer_length);
    #####: 3169:      variable_buffer = (char *) xrealloc (variable_buffer,
call    0 never executed
        -: 3170:					   variable_buffer_length);
    #####: 3171:      ptr = variable_buffer + offset;
        -: 3172:    }
        -: 3173:
       24: 3174:  bcopy (string, ptr, length);
       24: 3175:  return ptr + length;
        -: 3176:}
        -: 3177:
        -: 3178:/* Return a pointer to the beginning of the variable buffer.  */
        -: 3179:
        -: 3180:static char *
function initialize_variable_output called 8 returned 100% blocks executed 100%
        8: 3181:initialize_variable_output ()
        -: 3182:{
        -: 3183:  /* If we don't have a variable output buffer yet, get one.  */
        -: 3184:
        8: 3185:  if (variable_buffer == 0)
branch  0 taken 5 (fallthrough)
branch  1 taken 3
        -: 3186:    {
        5: 3187:      variable_buffer_length = 200;
        5: 3188:      variable_buffer = (char *) xmalloc (variable_buffer_length);
call    0 returned 5
        5: 3189:      variable_buffer[0] = '\0';
        -: 3190:    }
        -: 3191:
        8: 3192:  return variable_buffer;
        -: 3193:}
        -: 3194:
        -: 3195:/* Recursively expand V.  The returned string is malloc'd.  */
        -: 3196:
        -: 3197:static char *allocated_variable_append PARAMS ((struct variable *v));
        -: 3198:
        -: 3199:char *
function recursively_expand called 1 returned 100% blocks executed 71%
        1: 3200:recursively_expand (v)
        -: 3201:     register struct variable *v;
        -: 3202:{
        -: 3203:  char *value;
        -: 3204:
        1: 3205:  if (v->expanding)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -: 3206:    /* Expanding V causes infinite recursion.  Lose.  */
    #####: 3207:    fatal (reading_file,
    #####: 3208:           _("Recursive variable `%s' references itself (eventually)"),
call    0 never executed
        -: 3209:           v->name);
        -: 3210:
        1: 3211:  v->expanding = 1;
        1: 3212:  if (v->append)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 3213:    value = allocated_variable_append (v);
call    0 never executed
        -: 3214:  else
        1: 3215:    value = allocated_variable_expand (v->value);
call    0 returned 1
        1: 3216:  v->expanding = 0;
        -: 3217:
        1: 3218:  return value;
        -: 3219:}
        -: 3220:
        -: 3221:/* Warn that NAME is an undefined variable.  */
        -: 3222:
        -: 3223:#ifdef __GNUC__
        -: 3224:__inline
        -: 3225:#endif
        -: 3226:static void
function warn_undefined called 3 returned 100% blocks executed 67%
        3: 3227:warn_undefined (name, length)
        -: 3228:     char *name;
        -: 3229:     unsigned int length;
        -: 3230:{
        3: 3231:  if (warn_undefined_variables_flag)
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####: 3232:    error (reading_file,
    #####: 3233:           _("warning: undefined variable `%.*s'"), (int)length, name);
call    0 never executed
        3: 3234:}
        -: 3235:
        -: 3236:/* Expand a simple reference to variable NAME, which is LENGTH chars long.  */
        -: 3237:
        -: 3238:#ifdef __GNUC__
        -: 3239:__inline
        -: 3240:#endif
        -: 3241:static char *
function reference_variable called 5 returned 100% blocks executed 93%
        5: 3242:reference_variable (o, name, length)
        -: 3243:     char *o;
        -: 3244:     char *name;
        -: 3245:     unsigned int length;
        -: 3246:{
        -: 3247:  register struct variable *v;
        -: 3248:  char *value;
        -: 3249:
        5: 3250:  v = lookup_variable (name, length);
call    0 returned 5
        -: 3251:
        5: 3252:  if (v == 0)
branch  0 taken 3 (fallthrough)
branch  1 taken 2
        3: 3253:    warn_undefined (name, length);
call    0 returned 3
        -: 3254:
        5: 3255:  if (v == 0 || *v->value == '\0')
branch  0 taken 2 (fallthrough)
branch  1 taken 3
branch  2 taken 1 (fallthrough)
branch  3 taken 1
        4: 3256:    return o;
        -: 3257:
       1*: 3258:  value = (v->recursive ? recursively_expand (v) : v->value);
branch  0 taken 1 (fallthrough)
branch  1 taken 0
call    2 returned 1
        -: 3259:
        1: 3260:  o = variable_buffer_output (o, value, strlen (value));
call    0 returned 1
        -: 3261:
        1: 3262:  if (v->recursive)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 3263:    free (value);
        -: 3264:
        1: 3265:  return o;
        -: 3266:}
        -: 3267:
        -: 3268:/* Scan STRING for variable references and expansion-function calls.  Only
        -: 3269:   LENGTH bytes of STRING are actually scanned.  If LENGTH is -1, scan until
        -: 3270:   a null byte is found.
        -: 3271:
        -: 3272:   Write the results to LINE, which must point into `variable_buffer'.  If
        -: 3273:   LINE is NULL, start at the beginning of the buffer.
        -: 3274:   Return a pointer to LINE, or to the beginning of the buffer if LINE is
        -: 3275:   NULL.  */
        -: 3276:
        -: 3277:char *
function variable_expand_string called 8 returned 100% blocks executed 41%
        8: 3278:variable_expand_string (line, string, length)
        -: 3279:     register char *line;
        -: 3280:     char *string;
        -: 3281:     long length;
        -: 3282:{
        -: 3283:  register struct variable *v;
        -: 3284:  register char *p, *o, *p1;
        8: 3285:  char save_char = '\0';
        -: 3286:  unsigned int line_offset;
        -: 3287:
        8: 3288:  if (!line)
branch  0 taken 8 (fallthrough)
branch  1 taken 0
        8: 3289:    line = initialize_variable_output();
call    0 returned 8
        -: 3290:
        8: 3291:  p = string;
        8: 3292:  o = line;
        8: 3293:  line_offset = line - variable_buffer;
        -: 3294:
        8: 3295:  if (length >= 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 8
        -: 3296:    {
    #####: 3297:      save_char = string[length];
    #####: 3298:      string[length] = '\0';
        -: 3299:    }
        -: 3300:
        -: 3301:  while (1)
        -: 3302:    {
        -: 3303:      /* Copy all following uninteresting chars all at once to the
        -: 3304:         variable output buffer, and skip them.  Uninteresting chars end
        -: 3305:	 at the next $ or the end of the input.  */
        -: 3306:
       22: 3307:      p1 = strchr (p, '$');
        -: 3308:
       15: 3309:      o = variable_buffer_output (o, p, p1 != 0 ? p1 - p : strlen (p) + 1);
branch  0 taken 7 (fallthrough)
branch  1 taken 8
call    2 returned 15
        -: 3310:
       15: 3311:      if (p1 == 0)
branch  0 taken 8 (fallthrough)
branch  1 taken 7
        8: 3312:	break;
        7: 3313:      p = p1 + 1;
        -: 3314:
        -: 3315:      /* Dispatch on the char that follows the $.  */
        -: 3316:
        7: 3317:      switch (*p)
branch  0 taken 0
branch  1 taken 7
branch  2 taken 0
branch  3 taken 0
        -: 3318:	{
    #####: 3319:	case '$':
        -: 3320:	  /* $$ seen means output one $ to the variable output buffer.  */
    #####: 3321:	  o = variable_buffer_output (o, p, 1);
call    0 never executed
    #####: 3322:	  break;
        -: 3323:
        7: 3324:	case '(':
        -: 3325:	case '{':
        -: 3326:	  /* $(...) or ${...} is the general case of substitution.  */
        -: 3327:	  {
        7: 3328:	    char openparen = *p;
       7*: 3329:	    char closeparen = (openparen == '(') ? ')' : '}';
branch  0 taken 7 (fallthrough)
branch  1 taken 0
        7: 3330:	    register char *beg = p + 1;
        7: 3331:	    int free_beg = 0;
        -: 3332:	    char *op, *begp;
        -: 3333:	    char *end, *colon;
        -: 3334:
        7: 3335:	    op = o;
        7: 3336:	    begp = p;
        7: 3337:	    if (handle_function (&op, &begp))
call    0 returned 7
branch  1 taken 2 (fallthrough)
branch  2 taken 5
        -: 3338:	      {
        2: 3339:		o = op;
        2: 3340:		p = begp;
        2: 3341:		break;
        -: 3342:	      }
        -: 3343:
        -: 3344:	    /* Is there a variable reference inside the parens or braces?
        -: 3345:	       If so, expand it before expanding the entire reference.  */
        -: 3346:
        5: 3347:	    end = strchr (beg, closeparen);
        5: 3348:	    if (end == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 5
        -: 3349:              /* Unterminated variable reference.  */
    #####: 3350:              fatal (reading_file, _("unterminated variable reference"));
call    0 never executed
        5: 3351:	    p1 = lindex (beg, end, '$');
call    0 returned 5
        5: 3352:	    if (p1 != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 5
        -: 3353:	      {
        -: 3354:		/* BEG now points past the opening paren or brace.
        -: 3355:		   Count parens or braces until it is matched.  */
    #####: 3356:		int count = 0;
    #####: 3357:		for (p = beg; *p != '\0'; ++p)
branch  0 never executed
branch  1 never executed
        -: 3358:		  {
    #####: 3359:		    if (*p == openparen)
branch  0 never executed
branch  1 never executed
    #####: 3360:		      ++count;
    #####: 3361:		    else if (*p == closeparen && --count < 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3362:		      break;
        -: 3363:		  }
        -: 3364:		/* If COUNT is >= 0, there were unmatched opening parens
        -: 3365:		   or braces, so we go to the simple case of a variable name
        -: 3366:		   such as `$($(a)'.  */
    #####: 3367:		if (count < 0)
branch  0 never executed
branch  1 never executed
        -: 3368:		  {
    #####: 3369:		    beg = expand_argument (beg, p); /* Expand the name.  */
call    0 never executed
    #####: 3370:		    free_beg = 1; /* Remember to free BEG when finished.  */
    #####: 3371:		    end = strchr (beg, '\0');
        -: 3372:		  }
        -: 3373:	      }
        -: 3374:	    else
        -: 3375:	      /* Advance P to the end of this reference.  After we are
        -: 3376:                 finished expanding this one, P will be incremented to
        -: 3377:                 continue the scan.  */
        5: 3378:	      p = end;
        -: 3379:
        -: 3380:	    /* This is not a reference to a built-in function and
        -: 3381:	       any variable references inside are now expanded.
        -: 3382:	       Is the resultant text a substitution reference?  */
        -: 3383:
        5: 3384:	    colon = lindex (beg, end, ':');
call    0 returned 5
        5: 3385:	    if (colon != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 5
        -: 3386:	      {
        -: 3387:		/* This looks like a substitution reference: $(FOO:A=B).  */
        -: 3388:		char *subst_beg, *subst_end, *replace_beg, *replace_end;
        -: 3389:
    #####: 3390:		subst_beg = colon + 1;
    #####: 3391:		subst_end = strchr (subst_beg, '=');
    #####: 3392:		if (subst_end == 0)
branch  0 never executed
branch  1 never executed
        -: 3393:		  /* There is no = in sight.  Punt on the substitution
        -: 3394:		     reference and treat this as a variable name containing
        -: 3395:		     a colon, in the code below.  */
    #####: 3396:		  colon = 0;
        -: 3397:		else
        -: 3398:		  {
    #####: 3399:		    replace_beg = subst_end + 1;
    #####: 3400:		    replace_end = end;
        -: 3401:
        -: 3402:		    /* Extract the variable name before the colon
        -: 3403:		       and look up that variable.  */
    #####: 3404:		    v = lookup_variable (beg, colon - beg);
call    0 never executed
    #####: 3405:		    if (v == 0)
branch  0 never executed
branch  1 never executed
    #####: 3406:		      warn_undefined (beg, colon - beg);
call    0 never executed
        -: 3407:
    #####: 3408:		    if (v != 0 && *v->value != '\0')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 3409:		      {
    #####: 3410:			char *value = (v->recursive ? recursively_expand (v)
call    0 never executed
    #####: 3411:				       : v->value);
branch  0 never executed
branch  1 never executed
        -: 3412:			char *pattern, *percent;
    #####: 3413:			if (free_beg)
branch  0 never executed
branch  1 never executed
        -: 3414:			  {
    #####: 3415:			    *subst_end = '\0';
    #####: 3416:			    pattern = subst_beg;
        -: 3417:			  }
        -: 3418:			else
        -: 3419:			  {
    #####: 3420:			    pattern = (char *) alloca (subst_end - subst_beg
        -: 3421:						       + 1);
    #####: 3422:			    bcopy (subst_beg, pattern, subst_end - subst_beg);
    #####: 3423:			    pattern[subst_end - subst_beg] = '\0';
        -: 3424:			  }
    #####: 3425:			percent = find_percent (pattern);
call    0 never executed
    #####: 3426:			if (percent != 0)
branch  0 never executed
branch  1 never executed
        -: 3427:			  {
        -: 3428:			    char *replace;
    #####: 3429:			    if (free_beg)
branch  0 never executed
branch  1 never executed
        -: 3430:			      {
    #####: 3431:				*replace_end = '\0';
    #####: 3432:				replace = replace_beg;
        -: 3433:			      }
        -: 3434:			    else
        -: 3435:			      {
    #####: 3436:				replace = (char *) alloca (replace_end
        -: 3437:							   - replace_beg
        -: 3438:							   + 1);
    #####: 3439:				bcopy (replace_beg, replace,
        -: 3440:				       replace_end - replace_beg);
    #####: 3441:				replace[replace_end - replace_beg] = '\0';
        -: 3442:			      }
        -: 3443:
    #####: 3444:			    o = patsubst_expand (o, value, pattern, replace,
call    0 never executed
        -: 3445:						 percent, (char *) 0);
        -: 3446:			  }
        -: 3447:			else
    #####: 3448:			  o = subst_expand (o, value,
        -: 3449:					    pattern, replace_beg,
    #####: 3450:					    strlen (pattern),
    #####: 3451:					    end - replace_beg,
call    0 never executed
        -: 3452:					    0, 1);
    #####: 3453:			if (v->recursive)
branch  0 never executed
branch  1 never executed
    #####: 3454:			  free (value);
        -: 3455:		      }
        -: 3456:		  }
        -: 3457:	      }
        -: 3458:
        5: 3459:	    if (colon == 0)
branch  0 taken 5 (fallthrough)
branch  1 taken 0
        -: 3460:	      /* This is an ordinary variable reference.
        -: 3461:		 Look up the value of the variable.  */
        5: 3462:		o = reference_variable (o, beg, end - beg);
call    0 returned 5
        -: 3463:
        5: 3464:	  if (free_beg)
branch  0 taken 0 (fallthrough)
branch  1 taken 5
    #####: 3465:	    free (beg);
        -: 3466:	  }
        5: 3467:	  break;
        -: 3468:
    #####: 3469:	case '\0':
    #####: 3470:	  break;
        -: 3471:
    #####: 3472:	default:
    #####: 3473:	  if (isblank (p[-1]))
branch  0 never executed
branch  1 never executed
    #####: 3474:	    break;
        -: 3475:
        -: 3476:	  /* A $ followed by a random char is a variable reference:
        -: 3477:	     $a is equivalent to $(a).  */
        -: 3478:	  {
        -: 3479:	    /* We could do the expanding here, but this way
        -: 3480:	       avoids code repetition at a small performance cost.  */
        -: 3481:	    char name[5];
    #####: 3482:	    name[0] = '$';
    #####: 3483:	    name[1] = '(';
    #####: 3484:	    name[2] = *p;
    #####: 3485:	    name[3] = ')';
    #####: 3486:	    name[4] = '\0';
    #####: 3487:	    p1 = allocated_variable_expand (name);
call    0 never executed
    #####: 3488:	    o = variable_buffer_output (o, p1, strlen (p1));
call    0 never executed
    #####: 3489:	    free (p1);
        -: 3490:	  }
        -: 3491:
    #####: 3492:	  break;
        -: 3493:	}
        -: 3494:
        7: 3495:      if (*p == '\0')
branch  0 taken 0 (fallthrough)
branch  1 taken 7
    #####: 3496:	break;
        -: 3497:      else
        7: 3498:	++p;
        -: 3499:    }
        -: 3500:
        8: 3501:  if (save_char)
branch  0 taken 0 (fallthrough)
branch  1 taken 8
    #####: 3502:    string[length] = save_char;
        -: 3503:
        8: 3504:  (void)variable_buffer_output (o, "", 1);
call    0 returned 8
        8: 3505:  return (variable_buffer + line_offset);
        -: 3506:}
        -: 3507:
        -: 3508:/* Scan LINE for variable references and expansion-function calls.
        -: 3509:   Build in `variable_buffer' the result of expanding the references and calls.
        -: 3510:   Return the address of the resulting string, which is null-terminated
        -: 3511:   and is valid only until the next time this function is called.  */
        -: 3512:
        -: 3513:char *
function variable_expand called 8 returned 100% blocks executed 100%
        8: 3514:variable_expand (line)
        -: 3515:     char *line;
        -: 3516:{
        8: 3517:  return variable_expand_string(NULL, line, (long)-1);
call    0 returned 8
        -: 3518:}
        -: 3519:
        -: 3520:/* Expand an argument for an expansion function.
        -: 3521:   The text starting at STR and ending at END is variable-expanded
        -: 3522:   into a null-terminated string that is returned as the value.
        -: 3523:   This is done without clobbering `variable_buffer' or the current
        -: 3524:   variable-expansion that is in progress.  */
        -: 3525:
        -: 3526:char *
function expand_argument called 2 returned 100% blocks executed 83%
        2: 3527:expand_argument (str, end)
        -: 3528:     char *str, *end;
        -: 3529:{
        -: 3530:  char *tmp;
        -: 3531:
        2: 3532:  if (!end || *end == '\0')
branch  0 taken 2 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 2
    #####: 3533:    tmp = str;
        -: 3534:  else
        -: 3535:    {
        2: 3536:      tmp = (char *) alloca (end - str + 1);
        2: 3537:      bcopy (str, tmp, end - str);
        2: 3538:      tmp[end - str] = '\0';
        -: 3539:    }
        -: 3540:
        2: 3541:  return allocated_variable_expand (tmp);
call    0 returned 2
        -: 3542:}
        -: 3543:
        -: 3544:/* Expand LINE for FILE.  Error messages refer to the file and line where
        -: 3545:   FILE's commands were found.  Expansion uses FILE's variable set list.  */
        -: 3546:
        -: 3547:static char *
function variable_expand_for_file called 4 returned 100% blocks executed 40%
        4: 3548:variable_expand_for_file (line, file)
        -: 3549:     char *line;
        -: 3550:     register struct file *file;
        -: 3551:{
        -: 3552:  char *result;
        -: 3553:  struct variable_set_list *save;
        -: 3554:
        4: 3555:  if (file == 0)
branch  0 taken 4 (fallthrough)
branch  1 taken 0
        4: 3556:    return variable_expand (line);
call    0 returned 4
        -: 3557:
    #####: 3558:  save = current_variable_set_list;
    #####: 3559:  current_variable_set_list = file->variables;
    #####: 3560:  if (file->cmds && file->cmds->fileinfo.filenm)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3561:    reading_file = &file->cmds->fileinfo;
        -: 3562:  else
    #####: 3563:    reading_file = 0;
    #####: 3564:  result = variable_expand (line);
call    0 never executed
    #####: 3565:  current_variable_set_list = save;
    #####: 3566:  reading_file = 0;
        -: 3567:
    #####: 3568:  return result;
        -: 3569:}
        -: 3570:
        -: 3571:/* Like allocated_variable_expand, but we first expand this variable in the
        -: 3572:    context of the next variable set, then we append the expanded value.  */
        -: 3573:
        -: 3574:static char *
function allocated_variable_append called 0 returned 0% blocks executed 0%
    #####: 3575:allocated_variable_append (v)
        -: 3576:     struct variable *v;
        -: 3577:{
        -: 3578:  struct variable_set_list *save;
    #####: 3579:  int len = strlen (v->name);
    #####: 3580:  char *var = alloca (len + 4);
        -: 3581:  char *value;
        -: 3582:
    #####: 3583:  char *obuf = variable_buffer;
    #####: 3584:  unsigned int olen = variable_buffer_length;
        -: 3585:
    #####: 3586:  variable_buffer = 0;
        -: 3587:
    #####: 3588:  assert(current_variable_set_list->next != 0);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 3589:  save = current_variable_set_list;
    #####: 3590:  current_variable_set_list = current_variable_set_list->next;
        -: 3591:
    #####: 3592:  var[0] = '$';
    #####: 3593:  var[1] = '(';
    #####: 3594:  strcpy (&var[2], v->name);
    #####: 3595:  var[len+2] = ')';
    #####: 3596:  var[len+3] = '\0';
        -: 3597:
    #####: 3598:  value = variable_expand_for_file (var, 0);
call    0 never executed
        -: 3599:
    #####: 3600:  current_variable_set_list = save;
        -: 3601:
    #####: 3602:  value += strlen (value);
    #####: 3603:  value = variable_buffer_output (value, " ", 1);
call    0 never executed
    #####: 3604:  value = variable_expand_string (value, v->value, (long)-1);
call    0 never executed
        -: 3605:
    #####: 3606:  value = variable_buffer;
        -: 3607:
        -: 3608:#if 0
        -: 3609:  /* Waste a little memory and save time.  */
        -: 3610:  value = xrealloc (value, strlen (value))
        -: 3611:#endif
        -: 3612:
    #####: 3613:  variable_buffer = obuf;
    #####: 3614:  variable_buffer_length = olen;
        -: 3615:
    #####: 3616:  return value;
        -: 3617:}
        -: 3618:
        -: 3619:/* Like variable_expand_for_file, but the returned string is malloc'd.
        -: 3620:   This function is called a lot.  It wants to be efficient.  */
        -: 3621:
        -: 3622:char *
function allocated_variable_expand_for_file called 4 returned 100% blocks executed 100%
        4: 3623:allocated_variable_expand_for_file (line, file)
        -: 3624:     char *line;
        -: 3625:     struct file *file;
        -: 3626:{
        -: 3627:  char *value;
        -: 3628:
        4: 3629:  char *obuf = variable_buffer;
        4: 3630:  unsigned int olen = variable_buffer_length;
        -: 3631:
        4: 3632:  variable_buffer = 0;
        -: 3633:
        4: 3634:  value = variable_expand_for_file (line, file);
call    0 returned 4
        -: 3635:
        -: 3636:#if 0
        -: 3637:  /* Waste a little memory and save time.  */
        -: 3638:  value = xrealloc (value, strlen (value))
        -: 3639:#endif
        -: 3640:
        4: 3641:  variable_buffer = obuf;
        4: 3642:  variable_buffer_length = olen;
        -: 3643:
        4: 3644:  return value;
        -: 3645:}
        -: 3646:
        -: 3647:
        -: 3648:
        -: 3649:/*************************************************************
        -: 3650:  ============================================================
        -: 3651:  ************************************************************
        -: 3652:  ============================================================
        -: 3653:  ************************************************************
        -: 3654:                         file.c
        -: 3655:  ************************************************************
        -: 3656:  ============================================================
        -: 3657:  ************************************************************
        -: 3658:  ============================================================
        -: 3659:  *************************************************************/
        -: 3660:
        -: 3661:/* Target file hash table management for GNU Make.
        -: 3662:Copyright (C) 1988,89,90,91,92,93,94,95,96,97 Free Software Foundation, Inc.
        -: 3663:This file is part of GNU Make.
        -: 3664:
        -: 3665:GNU Make is free software; you can redistribute it and/or modify
        -: 3666:it under the terms of the GNU General Public License as published by
        -: 3667:the Free Software Foundation; either version 2, or (at your option)
        -: 3668:any later version.
        -: 3669:
        -: 3670:GNU Make is distributed in the hope that it will be useful,
        -: 3671:but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 3672:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 3673:GNU General Public License for more details.
        -: 3674:
        -: 3675:You should have received a copy of the GNU General Public License
        -: 3676:along with GNU Make; see the file COPYING.  If not, write to
        -: 3677:the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
        -: 3678:Boston, MA 02111-1307, USA.  */
        -: 3679:
        -: 3680:#include <assert.h>
        -: 3681:
        -: 3682:/* #include "make.h"  <- modification by J.Ruthruff, 7/28 */
        -: 3683:/* #include "dep.h"  <- modification by J.Ruthruff, 7/28 */
        -: 3684:/* #include "filedef.h"  <- modification by J.Ruthruff, 7/28 */
        -: 3685:#include "job.h"
        -: 3686:/* #include "commands.h"  <- modification by J.Ruthruff, 7/28 */
        -: 3687:/* #include "variable.h"  <- modification by J.Ruthruff, 7/28 */
        -: 3688:#undef stderr
        -: 3689:#define stderr stdout
        -: 3690:
        -: 3691:
        -: 3692:/* Hash table of files the makefile knows how to make.  */
        -: 3693:
        -: 3694:#ifndef	FILE_BUCKETS
        -: 3695:#define FILE_BUCKETS	1007
        -: 3696:#endif
        -: 3697:static struct file *files[FILE_BUCKETS];
        -: 3698:
        -: 3699:/* Number of files with the `intermediate' flag set.  */
        -: 3700:
        -: 3701:unsigned int num_intermediates = 0;
        -: 3702:
        -: 3703:/* Current value for pruning the scan of the goal chain (toggle 0/1).  */
        -: 3704:
        -: 3705:unsigned int considered = 0;
        -: 3706:
        -: 3707:/* Access the hash table of all file records.
        -: 3708:   lookup_file  given a name, return the struct file * for that name,
        -: 3709:           or nil if there is none.
        -: 3710:   enter_file   similar, but create one if there is none.  */
        -: 3711:
        -: 3712:struct file *
function lookup_file called 1173 returned 100% blocks executed 75%
     1173: 3713:lookup_file (name)
        -: 3714:     char *name;
        -: 3715:{
        -: 3716:  register struct file *f;
        -: 3717:  register char *n;
        -: 3718:  register unsigned int hashval;
        -: 3719:#if defined(VMS) && !defined(WANT_CASE_SENSITIVE_TARGETS)
        -: 3720:  register char *lname, *ln;
        -: 3721:#endif
        -: 3722:
    1173*: 3723:  assert (*name != '\0');
branch  0 taken 0 (fallthrough)
branch  1 taken 1173
call    2 never executed
        -: 3724:
        -: 3725:  /* This is also done in parse_file_seq, so this is redundant
        -: 3726:     for names read from makefiles.  It is here for names passed
        -: 3727:     on the command line.  */
        -: 3728:#ifdef VMS
        -: 3729:# ifndef WANT_CASE_SENSITIVE_TARGETS
        -: 3730:  lname = (char *)malloc(strlen(name) + 1);
        -: 3731:  for (n=name, ln=lname; *n != '\0'; ++n, ++ln)
        -: 3732:    *ln = isupper((unsigned char)*n) ? tolower((unsigned char)*n) : *n;
        -: 3733:  *ln = '\0';
        -: 3734:  name = lname;
        -: 3735:# endif
        -: 3736:
        -: 3737:  while (name[0] == '[' && name[1] == ']' && name[2] != '\0')
        -: 3738:      name += 2;
        -: 3739:#endif
    1173*: 3740:  while (name[0] == '.' && name[1] == '/' && name[2] != '\0')
branch  0 taken 1033 (fallthrough)
branch  1 taken 140
branch  2 taken 0 (fallthrough)
branch  3 taken 1033
branch  4 never executed
branch  5 never executed
        -: 3741:    {
    #####: 3742:      name += 2;
    #####: 3743:      while (*name == '/')
branch  0 never executed
branch  1 never executed
        -: 3744:	/* Skip following slashes: ".//foo" is "foo", not "/foo".  */
    #####: 3745:	++name;
        -: 3746:    }
        -: 3747:
     1173: 3748:  if (*name == '\0')
branch  0 taken 0 (fallthrough)
branch  1 taken 1173
        -: 3749:    /* It was all slashes after a dot.  */
        -: 3750:#ifdef VMS
        -: 3751:    name = "[]";
        -: 3752:#else
        -: 3753:#ifdef _AMIGA
        -: 3754:    name = "";
        -: 3755:#else
    #####: 3756:    name = "./";
        -: 3757:#endif /* AMIGA */
        -: 3758:#endif /* VMS */
        -: 3759:
     1173: 3760:  hashval = 0;
    14823: 3761:  for (n = name; *n != '\0'; ++n)
branch  0 taken 13650
branch  1 taken 1173 (fallthrough)
    13650: 3762:    HASHI (hashval, *n);
     1173: 3763:  hashval %= FILE_BUCKETS;
        -: 3764:
     1264: 3765:  for (f = files[hashval]; f != 0; f = f->next)
branch  0 taken 136
branch  1 taken 1128 (fallthrough)
        -: 3766:    {
      136: 3767:      if (strieq (f->hname, name))
branch  0 taken 136 (fallthrough)
branch  1 taken 0
branch  2 taken 128 (fallthrough)
branch  3 taken 8
branch  4 taken 128 (fallthrough)
branch  5 taken 0
branch  6 taken 45 (fallthrough)
branch  7 taken 83
        -: 3768:	{
        -: 3769:#if defined(VMS) && !defined(WANT_CASE_SENSITIVE_TARGETS)
        -: 3770:	  free (lname);
        -: 3771:#endif
       45: 3772:	  return f;
        -: 3773:	}
        -: 3774:    }
        -: 3775:#if defined(VMS) && !defined(WANT_CASE_SENSITIVE_TARGETS)
        -: 3776:  free (lname);
        -: 3777:#endif
     1128: 3778:  return 0;
        -: 3779:}
        -: 3780:
        -: 3781:struct file *
function enter_file called 67 returned 100% blocks executed 71%
       67: 3782:enter_file (name)
        -: 3783:     char *name;
        -: 3784:{
        -: 3785:  register struct file *f, *new;
        -: 3786:  register char *n;
        -: 3787:  register unsigned int hashval;
        -: 3788:#if defined(VMS) && !defined(WANT_CASE_SENSITIVE_TARGETS)
        -: 3789:  char *lname, *ln;
        -: 3790:#endif
        -: 3791:
      67*: 3792:  assert (*name != '\0');
branch  0 taken 0 (fallthrough)
branch  1 taken 67
call    2 never executed
        -: 3793:
        -: 3794:#if defined(VMS) && !defined(WANT_CASE_SENSITIVE_TARGETS)
        -: 3795:  lname = (char *)malloc (strlen (name) + 1);
        -: 3796:  for (n = name, ln = lname; *n != '\0'; ++n, ++ln)
        -: 3797:    {
        -: 3798:      if (isupper((unsigned char)*n))
        -: 3799:	*ln = tolower((unsigned char)*n);
        -: 3800:      else
        -: 3801:	*ln = *n;
        -: 3802:    }
        -: 3803:  *ln = 0;
        -: 3804:  /* Creates a possible leak, old value of name is unreachable, but I
        -: 3805:     currently don't know how to fix it. */
        -: 3806:  name = lname;
        -: 3807:#endif
        -: 3808:
       67: 3809:  hashval = 0;
      428: 3810:  for (n = name; *n != '\0'; ++n)
branch  0 taken 361
branch  1 taken 67 (fallthrough)
      361: 3811:    HASHI (hashval, *n);
       67: 3812:  hashval %= FILE_BUCKETS;
        -: 3813:
       70: 3814:  for (f = files[hashval]; f != 0; f = f->next)
branch  0 taken 3
branch  1 taken 67 (fallthrough)
        3: 3815:    if (strieq (f->hname, name))
branch  0 taken 3 (fallthrough)
branch  1 taken 0
branch  2 taken 3 (fallthrough)
branch  3 taken 0
branch  4 taken 3 (fallthrough)
branch  5 taken 0
branch  6 taken 3 (fallthrough)
branch  7 taken 0
        -: 3816:      break;
        -: 3817:
      67*: 3818:  if (f != 0 && !f->double_colon)
branch  0 taken 0 (fallthrough)
branch  1 taken 67
branch  2 never executed
branch  3 never executed
        -: 3819:    {
        -: 3820:#if defined(VMS) && !defined(WANT_CASE_SENSITIVE_TARGETS)
        -: 3821:      free(lname);
        -: 3822:#endif
    #####: 3823:      return f;
        -: 3824:    }
        -: 3825:
       67: 3826:  new = (struct file *) xmalloc (sizeof (struct file));
call    0 returned 67
       67: 3827:  bzero ((char *) new, sizeof (struct file));
       67: 3828:  new->name = new->hname = name;
       67: 3829:  new->update_status = -1;
        -: 3830:
       67: 3831:  if (f == 0)
branch  0 taken 67 (fallthrough)
branch  1 taken 0
        -: 3832:    {
        -: 3833:      /* This is a completely new file.  */
       67: 3834:      new->next = files[hashval];
       67: 3835:      files[hashval] = new;
        -: 3836:    }
        -: 3837:  else
        -: 3838:    {
        -: 3839:      /* There is already a double-colon entry for this file.  */
    #####: 3840:      new->double_colon = f;
    #####: 3841:      while (f->prev != 0)
branch  0 never executed
branch  1 never executed
    #####: 3842:	f = f->prev;
    #####: 3843:      f->prev = new;
        -: 3844:    }
        -: 3845:
       67: 3846:  return new;
        -: 3847:}
        -: 3848:
        -: 3849:/* Rehash FILE to NAME.  This is not as simple as resetting
        -: 3850:   the `hname' member, since it must be put in a new hash bucket,
        -: 3851:   and possibly merged with an existing file called NAME.  */
        -: 3852:
        -: 3853:void
function rehash_file called 0 returned 0% blocks executed 0%
    #####: 3854:rehash_file (file, name)
        -: 3855:     register struct file *file;
        -: 3856:     char *name;
        -: 3857:{
    #####: 3858:  char *oldname = file->hname;
        -: 3859:  register unsigned int oldhash;
        -: 3860:  register char *n;
        -: 3861:
    #####: 3862:  while (file->renamed != 0)
branch  0 never executed
branch  1 never executed
    #####: 3863:    file = file->renamed;
        -: 3864:
        -: 3865:  /* Find the hash values of the old and new names.  */
        -: 3866:
    #####: 3867:  oldhash = 0;
    #####: 3868:  for (n = oldname; *n != '\0'; ++n)
branch  0 never executed
branch  1 never executed
    #####: 3869:    HASHI (oldhash, *n);
        -: 3870:
    #####: 3871:  file_hash_enter (file, name, oldhash, file->name);
call    0 never executed
    #####: 3872:}
        -: 3873:
        -: 3874:/* Rename FILE to NAME.  This is not as simple as resetting
        -: 3875:   the `name' member, since it must be put in a new hash bucket,
        -: 3876:   and possibly merged with an existing file called NAME.  */
        -: 3877:
        -: 3878:void
function rename_file called 0 returned 0% blocks executed 0%
    #####: 3879:rename_file (file, name)
        -: 3880:     register struct file *file;
        -: 3881:     char *name;
        -: 3882:{
    #####: 3883:  rehash_file(file, name);
call    0 never executed
    #####: 3884:  while (file)
branch  0 never executed
branch  1 never executed
        -: 3885:    {
    #####: 3886:      file->name = file->hname;
    #####: 3887:      file = file->prev;
        -: 3888:    }
    #####: 3889:}
        -: 3890:
        -: 3891:void
function file_hash_enter called 0 returned 0% blocks executed 0%
    #####: 3892:file_hash_enter (file, name, oldhash, oldname)
        -: 3893:     register struct file *file;
        -: 3894:     char *name;
        -: 3895:     unsigned int oldhash;
        -: 3896:     char *oldname;
        -: 3897:{
    #####: 3898:  unsigned int oldbucket = oldhash % FILE_BUCKETS;
        -: 3899:  register unsigned int newhash, newbucket;
        -: 3900:  struct file *oldfile;
        -: 3901:  register char *n;
        -: 3902:  register struct file *f;
        -: 3903:
    #####: 3904:  newhash = 0;
    #####: 3905:  for (n = name; *n != '\0'; ++n)
branch  0 never executed
branch  1 never executed
    #####: 3906:    HASHI (newhash, *n);
    #####: 3907:  newbucket = newhash % FILE_BUCKETS;
        -: 3908:
        -: 3909:  /* Look for an existing file under the new name.  */
        -: 3910:
    #####: 3911:  for (oldfile = files[newbucket]; oldfile != 0; oldfile = oldfile->next)
branch  0 never executed
branch  1 never executed
    #####: 3912:    if (strieq (oldfile->hname, name))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -: 3913:      break;
        -: 3914:
        -: 3915:  /* If the old file is the same as the new file, never mind.  */
    #####: 3916:  if (oldfile == file)
branch  0 never executed
branch  1 never executed
    #####: 3917:    return;
        -: 3918:
    #####: 3919:  if (oldhash != 0 && (newbucket != oldbucket || oldfile != 0))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 3920:    {
        -: 3921:      /* Remove FILE from its hash bucket.  */
        -: 3922:
    #####: 3923:      struct file *lastf = 0;
        -: 3924:
    #####: 3925:      for (f = files[oldbucket]; f != file; f = f->next)
branch  0 never executed
branch  1 never executed
    #####: 3926:	lastf = f;
        -: 3927:
    #####: 3928:      if (lastf == 0)
branch  0 never executed
branch  1 never executed
    #####: 3929:	files[oldbucket] = f->next;
        -: 3930:      else
    #####: 3931:	lastf->next = f->next;
        -: 3932:    }
        -: 3933:
        -: 3934:  /* Give FILE its new name.  */
        -: 3935:
    #####: 3936:  file->hname = name;
    #####: 3937:  for (f = file->double_colon; f != 0; f = f->prev)
branch  0 never executed
branch  1 never executed
    #####: 3938:    f->hname = name;
        -: 3939:
    #####: 3940:  if (oldfile == 0)
branch  0 never executed
branch  1 never executed
        -: 3941:    {
        -: 3942:      /* There is no existing file with the new name.  */
        -: 3943:
    #####: 3944:      if (newbucket != oldbucket)
branch  0 never executed
branch  1 never executed
        -: 3945:	{
        -: 3946:	  /* Put FILE in its new hash bucket.  */
    #####: 3947:	  file->next = files[newbucket];
    #####: 3948:	  files[newbucket] = file;
        -: 3949:	}
        -: 3950:    }
        -: 3951:  else
        -: 3952:    {
        -: 3953:      /* There is an existing file with the new name.
        -: 3954:	 We must merge FILE into the existing file.  */
        -: 3955:
        -: 3956:      register struct dep *d;
        -: 3957:
    #####: 3958:      if (file->cmds != 0)
branch  0 never executed
branch  1 never executed
        -: 3959:	{
    #####: 3960:	  if (oldfile->cmds == 0)
branch  0 never executed
branch  1 never executed
    #####: 3961:	    oldfile->cmds = file->cmds;
    #####: 3962:	  else if (file->cmds != oldfile->cmds)
branch  0 never executed
branch  1 never executed
        -: 3963:	    {
        -: 3964:	      /* We have two sets of commands.  We will go with the
        -: 3965:		 one given in the rule explicitly mentioning this name,
        -: 3966:		 but give a message to let the user know what's going on.  */
    #####: 3967:	      if (oldfile->cmds->fileinfo.filenm != 0)
branch  0 never executed
branch  1 never executed
    #####: 3968:                error (&file->cmds->fileinfo,
    #####: 3969:                                _("Commands were specified for \
        -: 3970:file `%s' at %s:%lu,"),
    #####: 3971:                                oldname, oldfile->cmds->fileinfo.filenm,
    #####: 3972:                                oldfile->cmds->fileinfo.lineno);
call    0 never executed
        -: 3973:	      else
    #####: 3974:		error (&file->cmds->fileinfo,
    #####: 3975:				_("Commands for file `%s' were found by \
call    0 never executed
        -: 3976:implicit rule search,"),
        -: 3977:				oldname);
    #####: 3978:	      error (&file->cmds->fileinfo,
    #####: 3979:			      _("but `%s' is now considered the same file \
call    0 never executed
        -: 3980:as `%s'."),
        -: 3981:			      oldname, name);
    #####: 3982:	      error (&file->cmds->fileinfo,
    #####: 3983:			      _("Commands for `%s' will be ignored \
call    0 never executed
        -: 3984:in favor of those for `%s'."),
        -: 3985:			      name, oldname);
        -: 3986:	    }
        -: 3987:	}
        -: 3988:
        -: 3989:      /* Merge the dependencies of the two files.  */
        -: 3990:
    #####: 3991:      d = oldfile->deps;
    #####: 3992:      if (d == 0)
branch  0 never executed
branch  1 never executed
    #####: 3993:	oldfile->deps = file->deps;
        -: 3994:      else
        -: 3995:	{
    #####: 3996:	  while (d->next != 0)
branch  0 never executed
branch  1 never executed
    #####: 3997:	    d = d->next;
    #####: 3998:	  d->next = file->deps;
        -: 3999:	}
        -: 4000:
    #####: 4001:      merge_variable_set_lists (&oldfile->variables, file->variables);
call    0 never executed
        -: 4002:
    #####: 4003:      if (oldfile->double_colon && file->is_target && !file->double_colon)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 4004:	fatal (NILF, _("can't rename single-colon `%s' to double-colon `%s'"),
call    0 never executed
        -: 4005:	       oldname, name);
    #####: 4006:      if (!oldfile->double_colon  && file->double_colon)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 4007:	{
    #####: 4008:	  if (oldfile->is_target)
branch  0 never executed
branch  1 never executed
    #####: 4009:	    fatal (NILF, _("can't rename double-colon `%s' to single-colon `%s'"),
call    0 never executed
        -: 4010:		   oldname, name);
        -: 4011:	  else
    #####: 4012:	    oldfile->double_colon = file->double_colon;
        -: 4013:	}
        -: 4014:
    #####: 4015:      if (file->last_mtime > oldfile->last_mtime)
branch  0 never executed
branch  1 never executed
        -: 4016:	/* %%% Kludge so -W wins on a file that gets vpathized.  */
    #####: 4017:	oldfile->last_mtime = file->last_mtime;
        -: 4018:
    #####: 4019:      oldfile->mtime_before_update = file->mtime_before_update;
        -: 4020:
        -: 4021:#define MERGE(field) oldfile->field |= file->field
    #####: 4022:      MERGE (precious);
    #####: 4023:      MERGE (tried_implicit);
    #####: 4024:      MERGE (updating);
    #####: 4025:      MERGE (updated);
    #####: 4026:      MERGE (is_target);
    #####: 4027:      MERGE (cmd_target);
    #####: 4028:      MERGE (phony);
    #####: 4029:      MERGE (ignore_vpath);
        -: 4030:#undef MERGE
        -: 4031:
    #####: 4032:      file->renamed = oldfile;
        -: 4033:    }
        -: 4034:}
        -: 4035:
        -: 4036:/* Remove all nonprecious intermediate files.
        -: 4037:   If SIG is nonzero, this was caused by a fatal signal,
        -: 4038:   meaning that a different message will be printed, and
        -: 4039:   the message will go to stderr rather than stdout.  */
        -: 4040:
        -: 4041:void
function remove_intermediates called 1 returned 100% blocks executed 29%
        1: 4042:remove_intermediates (sig)
        -: 4043:     int sig;
        -: 4044:{
        -: 4045:  register int i;
        -: 4046:  register struct file *f;
        -: 4047:  char doneany;
        -: 4048:
        1: 4049:  if (question_flag || touch_flag)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 1
    #####: 4050:    return;
       1*: 4051:  if (sig && just_print_flag)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
branch  2 never executed
branch  3 never executed
    #####: 4052:    return;
        -: 4053:
        1: 4054:  doneany = 0;
     1008: 4055:  for (i = 0; i < FILE_BUCKETS; ++i)
branch  0 taken 1007
branch  1 taken 1 (fallthrough)
     1074: 4056:    for (f = files[i]; f != 0; f = f->next)
branch  0 taken 67
branch  1 taken 1007 (fallthrough)
      67*: 4057:      if (f->intermediate && (f->dontcare || !f->precious)
branch  0 taken 0 (fallthrough)
branch  1 taken 67
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 4058:	  && !f->secondary && !f->cmd_target)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 4059:	{
        -: 4060:	  int status;
    #####: 4061:	  if (f->update_status == -1)
branch  0 never executed
branch  1 never executed
        -: 4062:	    /* If nothing would have created this file yet,
        -: 4063:	       don't print an "rm" command for it.  */
    #####: 4064:            continue;
    #####: 4065: 	  else if (just_print_flag)
branch  0 never executed
branch  1 never executed
    #####: 4066:  	    status = 0;
        -: 4067:	  else
        -: 4068:	    {
    #####: 4069:	      status = unlink (f->name);
call    0 never executed
    #####: 4070:	      if (status < 0 && errno == ENOENT)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4071:		continue;
        -: 4072:	    }
    #####: 4073:	  if (!f->dontcare)
branch  0 never executed
branch  1 never executed
        -: 4074:	    {
    #####: 4075:	      if (sig)
branch  0 never executed
branch  1 never executed
    #####: 4076:		error (NILF, _("*** Deleting intermediate file `%s'"), f->name);
call    0 never executed
    #####: 4077:	      else if (!silent_flag)
branch  0 never executed
branch  1 never executed
        -: 4078:		{
    #####: 4079:		  if (! doneany)
branch  0 never executed
branch  1 never executed
        -: 4080:		    {
    #####: 4081:		      fputs ("rm ", stdout);
call    0 never executed
    #####: 4082:		      doneany = 1;
        -: 4083:		    }
        -: 4084:		  else
    #####: 4085:		    putchar (' ');
call    0 never executed
    #####: 4086:		  fputs (f->name, stdout);
call    0 never executed
    #####: 4087:		  fflush (stdout);
call    0 never executed
        -: 4088:		}
    #####: 4089:	      if (status < 0)
branch  0 never executed
branch  1 never executed
    #####: 4090:		perror_with_name ("unlink: ", f->name);
call    0 never executed
        -: 4091:	    }
        -: 4092:	}
        -: 4093:
       1*: 4094:  if (doneany && !sig)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
branch  2 never executed
branch  3 never executed
        -: 4095:    {
    #####: 4096:      putchar ('\n');
call    0 never executed
    #####: 4097:      fflush (stdout);
call    0 never executed
        -: 4098:    }
        -: 4099:}
        -: 4100:
        -: 4101:/* For each dependency of each file, make the `struct dep' point
        -: 4102:   at the appropriate `struct file' (which may have to be created).
        -: 4103:
        -: 4104:   Also mark the files depended on by .PRECIOUS, .PHONY, .SILENT,
        -: 4105:   and various other special targets.  */
        -: 4106:
        -: 4107:void
function snap_deps called 1 returned 100% blocks executed 39%
        1: 4108:snap_deps ()
        -: 4109:{
        -: 4110:  register struct file *f, *f2;
        -: 4111:  register struct dep *d;
        -: 4112:  register int i;
        -: 4113:
        -: 4114:  /* Enter each dependency name as a file.  */
     1008: 4115:  for (i = 0; i < FILE_BUCKETS; ++i)
branch  0 taken 1007
branch  1 taken 1 (fallthrough)
     1066: 4116:    for (f = files[i]; f != 0; f = f->next)
branch  0 taken 59
branch  1 taken 1007 (fallthrough)
      118: 4117:      for (f2 = f; f2 != 0; f2 = f2->prev)
branch  0 taken 59
branch  1 taken 59 (fallthrough)
       91: 4118:	for (d = f2->deps; d != 0; d = d->next)
branch  0 taken 32
branch  1 taken 59 (fallthrough)
       32: 4119:	  if (d->name != 0)
branch  0 taken 32 (fallthrough)
branch  1 taken 0
        -: 4120:	    {
       32: 4121:	      d->file = lookup_file (d->name);
call    0 returned 32
       32: 4122:	      if (d->file == 0)
branch  0 taken 19 (fallthrough)
branch  1 taken 13
       19: 4123:		d->file = enter_file (d->name);
call    0 returned 19
        -: 4124:	      else
       13: 4125:		free (d->name);
       32: 4126:	      d->name = 0;
        -: 4127:	    }
        -: 4128:
       1*: 4129:  for (f = lookup_file (".PRECIOUS"); f != 0; f = f->prev)
call    0 returned 1
branch  1 taken 0
branch  2 taken 1 (fallthrough)
    #####: 4130:    for (d = f->deps; d != 0; d = d->next)
branch  0 never executed
branch  1 never executed
    #####: 4131:      for (f2 = d->file; f2 != 0; f2 = f2->prev)
branch  0 never executed
branch  1 never executed
    #####: 4132:	f2->precious = 1;
        -: 4133:
       1*: 4134:  for (f = lookup_file (".PHONY"); f != 0; f = f->prev)
call    0 returned 1
branch  1 taken 0
branch  2 taken 1 (fallthrough)
    #####: 4135:    for (d = f->deps; d != 0; d = d->next)
branch  0 never executed
branch  1 never executed
    #####: 4136:      for (f2 = d->file; f2 != 0; f2 = f2->prev)
branch  0 never executed
branch  1 never executed
        -: 4137:	{
        -: 4138:	  /* Mark this file as phony and nonexistent.  */
    #####: 4139:	  f2->phony = 1;
    #####: 4140:	  f2->last_mtime = (FILE_TIMESTAMP) -1;
    #####: 4141:	  f2->mtime_before_update = (FILE_TIMESTAMP) -1;
        -: 4142:	}
        -: 4143:
       1*: 4144:  for (f = lookup_file (".INTERMEDIATE"); f != 0; f = f->prev)
call    0 returned 1
branch  1 taken 0
branch  2 taken 1 (fallthrough)
        -: 4145:    {
        -: 4146:      /* .INTERMEDIATE with deps listed
        -: 4147:	 marks those deps as intermediate files.  */
    #####: 4148:      for (d = f->deps; d != 0; d = d->next)
branch  0 never executed
branch  1 never executed
    #####: 4149:	for (f2 = d->file; f2 != 0; f2 = f2->prev)
branch  0 never executed
branch  1 never executed
    #####: 4150:	  f2->intermediate = 1;
        -: 4151:      /* .INTERMEDIATE with no deps does nothing.
        -: 4152:	 Marking all files as intermediates is useless
        -: 4153:	 since the goal targets would be deleted after they are built.  */
        -: 4154:    }
        -: 4155:
       1*: 4156:  for (f = lookup_file (".SECONDARY"); f != 0; f = f->prev)
call    0 returned 1
branch  1 taken 0
branch  2 taken 1 (fallthrough)
        -: 4157:    {
        -: 4158:      /* .SECONDARY with deps listed
        -: 4159:	 marks those deps as intermediate files
        -: 4160:	 in that they don't get rebuilt if not actually needed;
        -: 4161:	 but unlike real intermediate files,
        -: 4162:	 these are not deleted after make finishes.  */
    #####: 4163:      if (f->deps)
branch  0 never executed
branch  1 never executed
        -: 4164:	{
    #####: 4165:	  for (d = f->deps; d != 0; d = d->next)
branch  0 never executed
branch  1 never executed
    #####: 4166:	    for (f2 = d->file; f2 != 0; f2 = f2->prev)
branch  0 never executed
branch  1 never executed
    #####: 4167:	      f2->intermediate = f2->secondary = 1;
        -: 4168:	}
        -: 4169:      /* .SECONDARY with no deps listed marks *all* files that way.  */
        -: 4170:      else
        -: 4171:	{
        -: 4172:	  int i;
    #####: 4173:	  for (i = 0; i < FILE_BUCKETS; i++)
branch  0 never executed
branch  1 never executed
    #####: 4174:	    for (f2 = files[i]; f2; f2= f2->next)
branch  0 never executed
branch  1 never executed
    #####: 4175:	      f2->intermediate = f2->secondary = 1;
        -: 4176:	}
        -: 4177:    }
        -: 4178:
        1: 4179:  f = lookup_file (".EXPORT_ALL_VARIABLES");
call    0 returned 1
       1*: 4180:  if (f != 0 && f->is_target)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
branch  2 never executed
branch  3 never executed
    #####: 4181:    export_all_variables = 1;
        -: 4182:
        1: 4183:  f = lookup_file (".IGNORE");
call    0 returned 1
       1*: 4184:  if (f != 0 && f->is_target)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
branch  2 never executed
branch  3 never executed
        -: 4185:    {
    #####: 4186:      if (f->deps == 0)
branch  0 never executed
branch  1 never executed
    #####: 4187:	ignore_errors_flag = 1;
        -: 4188:      else
    #####: 4189:	for (d = f->deps; d != 0; d = d->next)
branch  0 never executed
branch  1 never executed
    #####: 4190:	  for (f2 = d->file; f2 != 0; f2 = f2->prev)
branch  0 never executed
branch  1 never executed
    #####: 4191:	    f2->command_flags |= COMMANDS_NOERROR;
        -: 4192:    }
        -: 4193:
        1: 4194:  f = lookup_file (".SILENT");
call    0 returned 1
       1*: 4195:  if (f != 0 && f->is_target)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
branch  2 never executed
branch  3 never executed
        -: 4196:    {
    #####: 4197:      if (f->deps == 0)
branch  0 never executed
branch  1 never executed
    #####: 4198:	silent_flag = 1;
        -: 4199:      else
    #####: 4200:	for (d = f->deps; d != 0; d = d->next)
branch  0 never executed
branch  1 never executed
    #####: 4201:	  for (f2 = d->file; f2 != 0; f2 = f2->prev)
branch  0 never executed
branch  1 never executed
    #####: 4202:	    f2->command_flags |= COMMANDS_SILENT;
        -: 4203:    }
        -: 4204:
        1: 4205:  f = lookup_file (".POSIX");
call    0 returned 1
       1*: 4206:  if (f != 0 && f->is_target)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
branch  2 never executed
branch  3 never executed
    #####: 4207:    posix_pedantic = 1;
        -: 4208:
        1: 4209:  f = lookup_file (".NOTPARALLEL");
call    0 returned 1
       1*: 4210:  if (f != 0 && f->is_target)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
branch  2 never executed
branch  3 never executed
    #####: 4211:    not_parallel = 1;
        1: 4212:}
        -: 4213:
        -: 4214:/* Set the `command_state' member of FILE and all its `also_make's.  */
        -: 4215:
        -: 4216:void
function set_command_state called 0 returned 0% blocks executed 0%
    #####: 4217:set_command_state (file, state)
        -: 4218:     struct file *file;
        -: 4219:     int state;
        -: 4220:{
        -: 4221:  struct dep *d;
        -: 4222:
    #####: 4223:  file->command_state = state;
        -: 4224:
    #####: 4225:  for (d = file->also_make; d != 0; d = d->next)
branch  0 never executed
branch  1 never executed
    #####: 4226:    d->file->command_state = state;
    #####: 4227:}
        -: 4228:
        -: 4229:/* Get and print file timestamps.  */
        -: 4230:
        -: 4231:FILE_TIMESTAMP
function file_timestamp_now called 0 returned 0% blocks executed 0%
    #####: 4232:file_timestamp_now ()
        -: 4233:{
        -: 4234:#if HAVE_CLOCK_GETTIME && defined CLOCK_REALTIME
        -: 4235:  struct timespec timespec;
    #####: 4236:  if (clock_gettime (CLOCK_REALTIME, &timespec) == 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 4237:    return FILE_TIMESTAMP_FROM_S_AND_NS (timespec.tv_sec, timespec.tv_nsec);
        -: 4238:#endif
    #####: 4239:  return FILE_TIMESTAMP_FROM_S_AND_NS (time ((time_t *) 0), 0);
call    0 never executed
        -: 4240:}
        -: 4241:
        -: 4242:void
function file_timestamp_sprintf called 0 returned 0% blocks executed 0%
    #####: 4243:file_timestamp_sprintf (p, ts)
        -: 4244:     char *p;
        -: 4245:     FILE_TIMESTAMP ts;
        -: 4246:{
    #####: 4247:  time_t t = FILE_TIMESTAMP_S (ts);
    #####: 4248:  struct tm *tm = localtime (&t);
call    0 never executed
        -: 4249:
    #####: 4250:  if (tm)
branch  0 never executed
branch  1 never executed
    #####: 4251:    sprintf (p, "%04d-%02d-%02d %02d:%02d:%02d",
    #####: 4252:	     tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday,
        -: 4253:	     tm->tm_hour, tm->tm_min, tm->tm_sec);
    #####: 4254:  else if (t < 0)
branch  0 never executed
branch  1 never executed
    #####: 4255:    sprintf (p, "%ld", (long) t);
        -: 4256:  else
    #####: 4257:    sprintf (p, "%lu", (unsigned long) t);
    #####: 4258:  p += strlen (p);
        -: 4259:
        -: 4260:  /* Append nanoseconds as a fraction, but remove trailing zeros.
        -: 4261:     We don't know the actual timestamp resolution, since clock_getres
        -: 4262:     applies only to local times, whereas this timestamp might come
        -: 4263:     from a remote filesystem.  So removing trailing zeros is the
        -: 4264:     best guess that we can do.  */
    #####: 4265:  sprintf (p, ".%09ld", (long) FILE_TIMESTAMP_NS (ts));
    #####: 4266:  p += strlen (p) - 1;
    #####: 4267:  while (*p == '0')
branch  0 never executed
branch  1 never executed
    #####: 4268:    p--;
    #####: 4269:  p += *p != '.';
        -: 4270:
    #####: 4271:  *p = '\0';
    #####: 4272:}
        -: 4273:
        -: 4274:/* Print the data base of files.  */
        -: 4275:
        -: 4276:static void
function print_file called 67 returned 100% blocks executed 48%
       67: 4277:print_file (f)
        -: 4278:     struct file *f;
        -: 4279:{
        -: 4280:  register struct dep *d;
        -: 4281:
       67: 4282:  putchar ('\n');
call    0 returned 67
       67: 4283:  if (!f->is_target)
branch  0 taken 67 (fallthrough)
branch  1 taken 0
       67: 4284:    puts (_("# Not a target:"));
call    0 returned 67
      67*: 4285:  printf ("%s:%s", f->name, f->double_colon ? ":" : "");
branch  0 taken 0 (fallthrough)
branch  1 taken 67
call    2 returned 67
        -: 4286:
       99: 4287:  for (d = f->deps; d != 0; d = d->next)
branch  0 taken 32
branch  1 taken 67 (fallthrough)
      32*: 4288:    printf (" %s", dep_name (d));
branch  0 taken 32 (fallthrough)
branch  1 taken 0
call    2 returned 32
       67: 4289:  putchar ('\n');
call    0 returned 67
        -: 4290:
       67: 4291:  if (f->precious)
branch  0 taken 0 (fallthrough)
branch  1 taken 67
    #####: 4292:    puts (_("#  Precious file (prerequisite of .PRECIOUS)."));
call    0 never executed
       67: 4293:  if (f->phony)
branch  0 taken 0 (fallthrough)
branch  1 taken 67
    #####: 4294:    puts (_("#  Phony target (prerequisite of .PHONY)."));
call    0 never executed
       67: 4295:  if (f->cmd_target)
branch  0 taken 0 (fallthrough)
branch  1 taken 67
    #####: 4296:    puts (_("#  Command-line target."));
call    0 never executed
       67: 4297:  if (f->dontcare)
branch  0 taken 0 (fallthrough)
branch  1 taken 67
    #####: 4298:    puts (_("#  A default or MAKEFILES makefile."));
call    0 never executed
       67: 4299:  puts (f->tried_implicit
call    0 returned 67
       67: 4300:        ? _("#  Implicit rule search has been done.")
branch  0 taken 1 (fallthrough)
branch  1 taken 66
       66: 4301:        : _("#  Implicit rule search has not been done."));
       67: 4302:  if (f->stem != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 67
    #####: 4303:    printf (_("#  Implicit/static pattern stem: `%s'\n"), f->stem);
call    0 never executed
       67: 4304:  if (f->intermediate)
branch  0 taken 0 (fallthrough)
branch  1 taken 67
    #####: 4305:    puts (_("#  File is an intermediate prerequisite."));
call    0 never executed
       67: 4306:  if (f->also_make != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 67
        -: 4307:    {
    #####: 4308:      fputs (_("#  Also makes:"), stdout);
call    0 never executed
    #####: 4309:      for (d = f->also_make; d != 0; d = d->next)
branch  0 never executed
branch  1 never executed
    #####: 4310:	printf (" %s", dep_name (d));
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 4311:      putchar ('\n');
call    0 never executed
        -: 4312:    }
       67: 4313:  if (f->last_mtime == 0)
branch  0 taken 66 (fallthrough)
branch  1 taken 1
       66: 4314:    puts (_("#  Modification time never checked."));
call    0 returned 66
        1: 4315:  else if (f->last_mtime == (FILE_TIMESTAMP) -1)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 4316:    puts (_("#  File does not exist."));
call    0 returned 1
        -: 4317:  else
        -: 4318:    {
        -: 4319:      char buf[FILE_TIMESTAMP_PRINT_LEN_BOUND + 1];
    #####: 4320:      file_timestamp_sprintf (buf, f->last_mtime);
call    0 never executed
    #####: 4321:      printf("#  Last modified 00:00 Jan 01 2000\n");
call    0 never executed
        -: 4322:      /* printf (_("#  Last modified %s\n"), buf); */
        -: 4323:    }
       67: 4324:  puts (f->updated
call    0 returned 67
      67*: 4325:        ? _("#  File has been updated.") : _("#  File has not been updated."));
branch  0 taken 0 (fallthrough)
branch  1 taken 67
       67: 4326:  switch (f->command_state)
branch  0 taken 0
branch  1 taken 0
branch  2 taken 67
branch  3 taken 0
        -: 4327:    {
    #####: 4328:    case cs_running:
    #####: 4329:      puts (_("#  Commands currently running (THIS IS A BUG)."));
call    0 never executed
    #####: 4330:      break;
    #####: 4331:    case cs_deps_running:
    #####: 4332:      puts (_("#  Dependencies commands running (THIS IS A BUG)."));
call    0 never executed
    #####: 4333:      break;
       67: 4334:    case cs_not_started:
        -: 4335:    case cs_finished:
       67: 4336:      switch (f->update_status)
branch  0 taken 67
branch  1 taken 0
branch  2 taken 0
branch  3 taken 0
branch  4 taken 0
        -: 4337:	{
       67: 4338:	case -1:
       67: 4339:	  break;
    #####: 4340:	case 0:
    #####: 4341:	  puts (_("#  Successfully updated."));
call    0 never executed
    #####: 4342:	  break;
    #####: 4343:	case 1:
    #####: 4344:	  assert (question_flag);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 4345:	  puts (_("#  Needs to be updated (-q is set)."));
call    0 never executed
    #####: 4346:	  break;
    #####: 4347:	case 2:
    #####: 4348:	  puts (_("#  Failed to be updated."));
call    0 never executed
    #####: 4349:	  break;
    #####: 4350:	default:
    #####: 4351:	  puts (_("#  Invalid value in `update_status' member!"));
call    0 never executed
    #####: 4352:	  fflush (stdout);
call    0 never executed
    #####: 4353:	  fflush (stderr);
call    0 never executed
    #####: 4354:	  abort ();
call    0 never executed
        -: 4355:	}
       67: 4356:      break;
    #####: 4357:    default:
    #####: 4358:      puts (_("#  Invalid value in `command_state' member!"));
call    0 never executed
    #####: 4359:      fflush (stdout);
call    0 never executed
    #####: 4360:      fflush (stderr);
call    0 never executed
    #####: 4361:      abort ();
call    0 never executed
        -: 4362:    }
        -: 4363:
       67: 4364:  if (f->variables != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 67
    #####: 4365:    print_file_variables (f);
call    0 never executed
        -: 4366:
       67: 4367:  if (f->cmds != 0)
branch  0 taken 45 (fallthrough)
branch  1 taken 22
       45: 4368:    print_commands (f->cmds);
call    0 returned 45
       67: 4369:}
        -: 4370:
        -: 4371:void
function print_file_data_base called 1 returned 100% blocks executed 94%
        1: 4372:print_file_data_base ()
        -: 4373:{
        -: 4374:  register unsigned int i, nfiles, per_bucket;
        -: 4375:  register struct file *file;
        -: 4376:
        1: 4377:  puts (_("\n# Files"));
call    0 returned 1
        -: 4378:
        1: 4379:  per_bucket = nfiles = 0;
     1008: 4380:  for (i = 0; i < FILE_BUCKETS; ++i)
branch  0 taken 1007
branch  1 taken 1 (fallthrough)
        -: 4381:    {
     1007: 4382:      register unsigned int this_bucket = 0;
        -: 4383:
     1074: 4384:      for (file = files[i]; file != 0; file = file->next)
branch  0 taken 67
branch  1 taken 1007 (fallthrough)
        -: 4385:	{
        -: 4386:	  register struct file *f;
        -: 4387:
       67: 4388:	  ++this_bucket;
        -: 4389:
      134: 4390:	  for (f = file; f != 0; f = f->prev)
branch  0 taken 67
branch  1 taken 67 (fallthrough)
       67: 4391:	    print_file (f);
call    0 returned 67
        -: 4392:	}
        -: 4393:
     1007: 4394:      nfiles += this_bucket;
     1007: 4395:      if (this_bucket > per_bucket)
branch  0 taken 2 (fallthrough)
branch  1 taken 1005
        2: 4396:	per_bucket = this_bucket;
        -: 4397:    }
        -: 4398:
        1: 4399:  if (nfiles == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 4400:    puts (_("\n# No files."));
call    0 never executed
        -: 4401:  else
        -: 4402:    {
        1: 4403:      printf (_("\n# %u files in %u hash buckets.\n"), nfiles, FILE_BUCKETS);
call    0 returned 1
        -: 4404:#ifndef	NO_FLOAT
        1: 4405:      printf (_("# average %.3f files per bucket, max %u files in one bucket.\n"),
        1: 4406:	      ((double) nfiles) / ((double) FILE_BUCKETS), per_bucket);
call    0 returned 1
        -: 4407:#endif
        -: 4408:    }
        1: 4409:}
        -: 4410:
        -: 4411:/* EOF */
        -: 4412:
        -: 4413:
        -: 4414:
        -: 4415:/*************************************************************
        -: 4416:  ============================================================
        -: 4417:  ************************************************************
        -: 4418:  ============================================================
        -: 4419:  ************************************************************
        -: 4420:                         function.c
        -: 4421:  ************************************************************
        -: 4422:  ============================================================
        -: 4423:  ************************************************************
        -: 4424:  ============================================================
        -: 4425:  *************************************************************/
        -: 4426:
        -: 4427:/* Builtin function expansion for GNU Make.
        -: 4428:Copyright (C) 1988,1989,1991-1997,1999 Free Software Foundation, Inc.
        -: 4429:This file is part of GNU Make.
        -: 4430:
        -: 4431:GNU Make is free software; you can redistribute it and/or modify
        -: 4432:it under the terms of the GNU General Public License as published by
        -: 4433:the Free Software Foundation; either version 2, or (at your option)
        -: 4434:any later version.
        -: 4435:
        -: 4436:GNU Make is distributed in the hope that it will be useful,
        -: 4437:but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 4438:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 4439:GNU General Public License for more details.
        -: 4440:
        -: 4441:You should have received a copy of the GNU General Public License
        -: 4442:along with GNU Make; see the file COPYING.  If not, write to
        -: 4443:the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
        -: 4444:Boston, MA 02111-1307, USA.  */
        -: 4445:
        -: 4446:/* #include "make.h"  <- modification by J.Ruthruff, 7/28 */
        -: 4447:/* #include "filedef.h"  <- modification by J.Ruthruff, 7/28 */
        -: 4448:/* #include "variable.h"  <- modification by J.Ruthruff, 7/28 */
        -: 4449:/* #include "dep.h"  <- modification by J.Ruthruff, 7/28 */
        -: 4450:#include "job.h"
        -: 4451:/* #include "commands.h"  <- modification by J.Ruthruff, 7/28 */
        -: 4452:#include "debug.h"
        -: 4453:#undef stderr
        -: 4454:#define stderr stdout
        -: 4455:
        -: 4456:#ifdef _AMIGA
        -: 4457:#include "amiga.h"
        -: 4458:#undef stderr
        -: 4459:#define stderr stdout
        -: 4460:#endif
        -: 4461:
        -: 4462:
        -: 4463:struct function_table_entry
        -: 4464:  {
        -: 4465:    const char *name;
        -: 4466:    unsigned char len;
        -: 4467:    unsigned char minimum_args;
        -: 4468:    unsigned char maximum_args;
        -: 4469:    char expand_args;
        -: 4470:    char *(*func_ptr) PARAMS ((char *output, char **argv, const char *fname));
        -: 4471:  };
        -: 4472:
        -: 4473:
        -: 4474:/* Store into VARIABLE_BUFFER at O the result of scanning TEXT and replacing
        -: 4475:   each occurrence of SUBST with REPLACE. TEXT is null-terminated.  SLEN is
        -: 4476:   the length of SUBST and RLEN is the length of REPLACE.  If BY_WORD is
        -: 4477:   nonzero, substitutions are done only on matches which are complete
        -: 4478:   whitespace-delimited words.  If SUFFIX_ONLY is nonzero, substitutions are
        -: 4479:   done only at the ends of whitespace-delimited words.  */
        -: 4480:
        -: 4481:char *
function subst_expand called 0 returned 0% blocks executed 0%
    #####: 4482:subst_expand (o, text, subst, replace, slen, rlen, by_word, suffix_only)
        -: 4483:     char *o;
        -: 4484:     char *text;
        -: 4485:     char *subst, *replace;
        -: 4486:     unsigned int slen, rlen;
        -: 4487:     int by_word, suffix_only;
        -: 4488:{
    #####: 4489:  register char *t = text;
        -: 4490:  register char *p;
        -: 4491:
    #####: 4492:  if (slen == 0 && !by_word && !suffix_only)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 4493:    {
        -: 4494:      /* The first occurrence of "" in any string is its end.  */
    #####: 4495:      o = variable_buffer_output (o, t, strlen (t));
call    0 never executed
    #####: 4496:      if (rlen > 0)
branch  0 never executed
branch  1 never executed
    #####: 4497:	o = variable_buffer_output (o, replace, rlen);
call    0 never executed
    #####: 4498:      return o;
        -: 4499:    }
        -: 4500:
        -: 4501:  do
        -: 4502:    {
    #####: 4503:      if ((by_word | suffix_only) && slen == 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 4504:	/* When matching by words, the empty string should match
        -: 4505:	   the end of each word, rather than the end of the whole text.  */
    #####: 4506:	p = end_of_token (next_token (t));
call    0 never executed
call    1 never executed
        -: 4507:      else
        -: 4508:	{
    #####: 4509:	  p = sindex (t, 0, subst, slen);
call    0 never executed
    #####: 4510:	  if (p == 0)
branch  0 never executed
branch  1 never executed
        -: 4511:	    {
        -: 4512:	      /* No more matches.  Output everything left on the end.  */
    #####: 4513:	      o = variable_buffer_output (o, t, strlen (t));
call    0 never executed
    #####: 4514:	      return o;
        -: 4515:	    }
        -: 4516:	}
        -: 4517:
        -: 4518:      /* Output everything before this occurrence of the string to replace.  */
    #####: 4519:      if (p > t)
branch  0 never executed
branch  1 never executed
    #####: 4520:	o = variable_buffer_output (o, t, p - t);
call    0 never executed
        -: 4521:
        -: 4522:      /* If we're substituting only by fully matched words,
        -: 4523:	 or only at the ends of words, check that this case qualifies.  */
    #####: 4524:      if ((by_word
branch  0 never executed
branch  1 never executed
    #####: 4525:	   && ((p > t && !isblank (p[-1]))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4526:	       || (p[slen] != '\0' && !isblank (p[slen]))))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4527:	  || (suffix_only
branch  0 never executed
branch  1 never executed
    #####: 4528:	      && (p[slen] != '\0' && !isblank (p[slen]))))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 4529:	/* Struck out.  Output the rest of the string that is
        -: 4530:	   no longer to be replaced.  */
    #####: 4531:	o = variable_buffer_output (o, subst, slen);
call    0 never executed
    #####: 4532:      else if (rlen > 0)
branch  0 never executed
branch  1 never executed
        -: 4533:	/* Output the replacement string.  */
    #####: 4534:	o = variable_buffer_output (o, replace, rlen);
call    0 never executed
        -: 4535:
        -: 4536:      /* Advance T past the string to be replaced.  */
    #####: 4537:      t = p + slen;
    #####: 4538:    } while (*t != '\0');
branch  0 never executed
branch  1 never executed
        -: 4539:
    #####: 4540:  return o;
        -: 4541:}
        -: 4542:
        -: 4543:
        -: 4544:/* Store into VARIABLE_BUFFER at O the result of scanning TEXT
        -: 4545:   and replacing strings matching PATTERN with REPLACE.
        -: 4546:   If PATTERN_PERCENT is not nil, PATTERN has already been
        -: 4547:   run through find_percent, and PATTERN_PERCENT is the result.
        -: 4548:   If REPLACE_PERCENT is not nil, REPLACE has already been
        -: 4549:   run through find_percent, and REPLACE_PERCENT is the result.  */
        -: 4550:
        -: 4551:char *
function patsubst_expand called 0 returned 0% blocks executed 0%
    #####: 4552:patsubst_expand (o, text, pattern, replace, pattern_percent, replace_percent)
        -: 4553:     char *o;
        -: 4554:     char *text;
        -: 4555:     register char *pattern, *replace;
        -: 4556:     register char *pattern_percent, *replace_percent;
        -: 4557:{
        -: 4558:  unsigned int pattern_prepercent_len, pattern_postpercent_len;
    #####: 4559:  unsigned int replace_prepercent_len, replace_postpercent_len = 0;
        -: 4560:  char *t;
        -: 4561:  int len;
    #####: 4562:  int doneany = 0;
        -: 4563:
        -: 4564:  /* We call find_percent on REPLACE before checking PATTERN so that REPLACE
        -: 4565:     will be collapsed before we call subst_expand if PATTERN has no %.  */
    #####: 4566:  if (replace_percent == 0)
branch  0 never executed
branch  1 never executed
    #####: 4567:    replace_percent = find_percent (replace);
call    0 never executed
    #####: 4568:  if (replace_percent != 0)
branch  0 never executed
branch  1 never executed
        -: 4569:    {
        -: 4570:      /* Record the length of REPLACE before and after the % so
        -: 4571:	 we don't have to compute these lengths more than once.  */
    #####: 4572:      replace_prepercent_len = replace_percent - replace;
    #####: 4573:      replace_postpercent_len = strlen (replace_percent + 1);
        -: 4574:    }
        -: 4575:  else
        -: 4576:    /* We store the length of the replacement
        -: 4577:       so we only need to compute it once.  */
    #####: 4578:    replace_prepercent_len = strlen (replace);
        -: 4579:
    #####: 4580:  if (pattern_percent == 0)
branch  0 never executed
branch  1 never executed
    #####: 4581:    pattern_percent = find_percent (pattern);
call    0 never executed
    #####: 4582:  if (pattern_percent == 0)
branch  0 never executed
branch  1 never executed
        -: 4583:    /* With no % in the pattern, this is just a simple substitution.  */
    #####: 4584:    return subst_expand (o, text, pattern, replace,
    #####: 4585:			 strlen (pattern), strlen (replace), 1, 0);
call    0 never executed
        -: 4586:
        -: 4587:  /* Record the length of PATTERN before and after the %
        -: 4588:     so we don't have to compute it more than once.  */
    #####: 4589:  pattern_prepercent_len = pattern_percent - pattern;
    #####: 4590:  pattern_postpercent_len = strlen (pattern_percent + 1);
        -: 4591:
    #####: 4592:  while ((t = find_next_token (&text, &len)) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 4593:    {
    #####: 4594:      int fail = 0;
        -: 4595:
        -: 4596:      /* Is it big enough to match?  */
    #####: 4597:      if (len < pattern_prepercent_len + pattern_postpercent_len)
branch  0 never executed
branch  1 never executed
    #####: 4598:	fail = 1;
        -: 4599:
        -: 4600:      /* Does the prefix match? */
    #####: 4601:      if (!fail && pattern_prepercent_len > 0
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4602:	  && (*t != *pattern
branch  0 never executed
branch  1 never executed
    #####: 4603:	      || t[pattern_prepercent_len - 1] != pattern_percent[-1]
branch  0 never executed
branch  1 never executed
    #####: 4604:	      || !strneq (t + 1, pattern + 1, pattern_prepercent_len - 1)))
branch  0 never executed
branch  1 never executed
    #####: 4605:	fail = 1;
        -: 4606:
        -: 4607:      /* Does the suffix match? */
    #####: 4608:      if (!fail && pattern_postpercent_len > 0
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4609:	  && (t[len - 1] != pattern_percent[pattern_postpercent_len]
branch  0 never executed
branch  1 never executed
    #####: 4610:	      || t[len - pattern_postpercent_len] != pattern_percent[1]
branch  0 never executed
branch  1 never executed
    #####: 4611:	      || !strneq (&t[len - pattern_postpercent_len],
branch  0 never executed
branch  1 never executed
        -: 4612:			  &pattern_percent[1], pattern_postpercent_len - 1)))
    #####: 4613:	fail = 1;
        -: 4614:
    #####: 4615:      if (fail)
branch  0 never executed
branch  1 never executed
        -: 4616:	/* It didn't match.  Output the string.  */
    #####: 4617:	o = variable_buffer_output (o, t, len);
call    0 never executed
        -: 4618:      else
        -: 4619:	{
        -: 4620:	  /* It matched.  Output the replacement.  */
        -: 4621:
        -: 4622:	  /* Output the part of the replacement before the %.  */
    #####: 4623:	  o = variable_buffer_output (o, replace, replace_prepercent_len);
call    0 never executed
        -: 4624:
    #####: 4625:	  if (replace_percent != 0)
branch  0 never executed
branch  1 never executed
        -: 4626:	    {
        -: 4627:	      /* Output the part of the matched string that
        -: 4628:		 matched the % in the pattern.  */
    #####: 4629:	      o = variable_buffer_output (o, t + pattern_prepercent_len,
        -: 4630:					  len - (pattern_prepercent_len
    #####: 4631:						 + pattern_postpercent_len));
call    0 never executed
        -: 4632:	      /* Output the part of the replacement after the %.  */
    #####: 4633:	      o = variable_buffer_output (o, replace_percent + 1,
call    0 never executed
        -: 4634:					  replace_postpercent_len);
        -: 4635:	    }
        -: 4636:	}
        -: 4637:
        -: 4638:      /* Output a space, but not if the replacement is "".  */
    #####: 4639:      if (fail || replace_prepercent_len > 0
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4640:	  || (replace_percent != 0 && len + replace_postpercent_len > 0))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 4641:	{
    #####: 4642:	  o = variable_buffer_output (o, " ", 1);
call    0 never executed
    #####: 4643:	  doneany = 1;
        -: 4644:	}
        -: 4645:    }
    #####: 4646:  if (doneany)
branch  0 never executed
branch  1 never executed
        -: 4647:    /* Kill the last space.  */
    #####: 4648:    --o;
        -: 4649:
    #####: 4650:  return o;
        -: 4651:}
        -: 4652:
        -: 4653:
        -: 4654:/* Look up a function by name.
        -: 4655:   The table is currently small enough that it's not really worthwhile to use
        -: 4656:   a fancier lookup algorithm.  If it gets larger, maybe...
        -: 4657:*/
        -: 4658:
        -: 4659:static const struct function_table_entry *
function lookup_function called 7 returned 100% blocks executed 100%
        7: 4660:lookup_function (table, s)
        -: 4661:     const struct function_table_entry *table;
        -: 4662:     const char *s;
        -: 4663:{
        7: 4664:  int len = strlen (s);
        -: 4665:
      167: 4666:  for (; table->name != NULL; ++table)
branch  0 taken 162
branch  1 taken 5 (fallthrough)
      162: 4667:    if (table->len <= len
branch  0 taken 140 (fallthrough)
branch  1 taken 22
      140: 4668:        && (isblank (s[table->len]) || s[table->len] == '\0')
branch  0 taken 134 (fallthrough)
branch  1 taken 6
branch  2 taken 14 (fallthrough)
branch  3 taken 120
       20: 4669:        && strneq (s, table->name, table->len))
branch  0 taken 2 (fallthrough)
branch  1 taken 18
        2: 4670:      return table;
        -: 4671:
        5: 4672:  return NULL;
        -: 4673:}
        -: 4674:
        -: 4675:
        -: 4676:/* Return 1 if PATTERN matches STR, 0 if not.  */
        -: 4677:
        -: 4678:int
function pattern_matches called 0 returned 0% blocks executed 0%
    #####: 4679:pattern_matches (pattern, percent, str)
        -: 4680:     register char *pattern, *percent, *str;
        -: 4681:{
        -: 4682:  unsigned int sfxlen, strlength;
        -: 4683:
    #####: 4684:  if (percent == 0)
branch  0 never executed
branch  1 never executed
        -: 4685:    {
    #####: 4686:      unsigned int len = strlen (pattern) + 1;
    #####: 4687:      char *new_chars = (char *) alloca (len);
    #####: 4688:      bcopy (pattern, new_chars, len);
    #####: 4689:      pattern = new_chars;
    #####: 4690:      percent = find_percent (pattern);
call    0 never executed
    #####: 4691:      if (percent == 0)
branch  0 never executed
branch  1 never executed
    #####: 4692:	return streq (pattern, str);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -: 4693:    }
        -: 4694:
    #####: 4695:  sfxlen = strlen (percent + 1);
    #####: 4696:  strlength = strlen (str);
        -: 4697:
    #####: 4698:  if (strlength < (percent - pattern) + sfxlen
branch  0 never executed
branch  1 never executed
    #####: 4699:      || !strneq (pattern, str, percent - pattern))
branch  0 never executed
branch  1 never executed
    #####: 4700:    return 0;
        -: 4701:
    #####: 4702:  return !strcmp (percent + 1, str + (strlength - sfxlen));
        -: 4703:}
        -: 4704:
        -: 4705:
        -: 4706:/* Find the next comma or ENDPAREN (counting nested STARTPAREN and
        -: 4707:   ENDPARENtheses), starting at PTR before END.  Return a pointer to
        -: 4708:   next character.
        -: 4709:
        -: 4710:   If no next argument is found, return NULL.
        -: 4711:*/
        -: 4712:
        -: 4713:static char *
function find_next_argument called 0 returned 0% blocks executed 0%
    #####: 4714:find_next_argument (startparen, endparen, ptr, end)
        -: 4715:     char startparen;
        -: 4716:     char endparen;
        -: 4717:     const char *ptr;
        -: 4718:     const char *end;
        -: 4719:{
    #####: 4720:  int count = 0;
        -: 4721:
    #####: 4722:  for (; ptr < end; ++ptr)
branch  0 never executed
branch  1 never executed
    #####: 4723:    if (*ptr == startparen)
branch  0 never executed
branch  1 never executed
    #####: 4724:      ++count;
        -: 4725:
    #####: 4726:    else if (*ptr == endparen)
branch  0 never executed
branch  1 never executed
        -: 4727:      {
    #####: 4728:	--count;
    #####: 4729:	if (count < 0)
branch  0 never executed
branch  1 never executed
    #####: 4730:	  return NULL;
        -: 4731:      }
        -: 4732:
    #####: 4733:    else if (*ptr == ',' && !count)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4734:      return (char *)ptr;
        -: 4735:
        -: 4736:  /* We didn't find anything.  */
    #####: 4737:  return NULL;
        -: 4738:}
        -: 4739:
        -: 4740:
        -: 4741:/* Glob-expand LINE.  The returned pointer is
        -: 4742:   only good until the next call to string_glob.  */
        -: 4743:
        -: 4744:static char *
function string_glob called 0 returned 0% blocks executed 0%
    #####: 4745:string_glob (line)
        -: 4746:     char *line;
        -: 4747:{
        -: 4748:  static char *result = 0;
        -: 4749:  static unsigned int length;
        -: 4750:  register struct nameseq *chain;
        -: 4751:  register unsigned int idx;
        -: 4752:
    #####: 4753:  chain = multi_glob (parse_file_seq
call    0 never executed
call    1 never executed
        -: 4754:		      (&line, '\0', sizeof (struct nameseq),
        -: 4755:		       /* We do not want parse_file_seq to strip `./'s.
        -: 4756:			  That would break examples like:
        -: 4757:			  $(patsubst ./%.c,obj/%.o,$(wildcard ./?*.c)).  */
        -: 4758:		       0),
        -: 4759:		      sizeof (struct nameseq));
        -: 4760:
    #####: 4761:  if (result == 0)
branch  0 never executed
branch  1 never executed
        -: 4762:    {
    #####: 4763:      length = 100;
    #####: 4764:      result = (char *) xmalloc (100);
call    0 never executed
        -: 4765:    }
        -: 4766:
    #####: 4767:  idx = 0;
    #####: 4768:  while (chain != 0)
branch  0 never executed
branch  1 never executed
        -: 4769:    {
    #####: 4770:      register char *name = chain->name;
    #####: 4771:      unsigned int len = strlen (name);
        -: 4772:
    #####: 4773:      struct nameseq *next = chain->next;
    #####: 4774:      free ((char *) chain);
    #####: 4775:      chain = next;
        -: 4776:
        -: 4777:      /* multi_glob will pass names without globbing metacharacters
        -: 4778:	 through as is, but we want only files that actually exist.  */
    #####: 4779:      if (file_exists_p (name))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 4780:	{
    #####: 4781:	  if (idx + len + 1 > length)
branch  0 never executed
branch  1 never executed
        -: 4782:	    {
    #####: 4783:	      length += (len + 1) * 2;
    #####: 4784:	      result = (char *) xrealloc (result, length);
call    0 never executed
        -: 4785:	    }
    #####: 4786:	  bcopy (name, &result[idx], len);
    #####: 4787:	  idx += len;
    #####: 4788:	  result[idx++] = ' ';
        -: 4789:	}
        -: 4790:
    #####: 4791:      free (name);
        -: 4792:    }
        -: 4793:
        -: 4794:  /* Kill the last space and terminate the string.  */
    #####: 4795:  if (idx == 0)
branch  0 never executed
branch  1 never executed
    #####: 4796:    result[0] = '\0';
        -: 4797:  else
    #####: 4798:    result[idx - 1] = '\0';
        -: 4799:
    #####: 4800:  return result;
        -: 4801:}
        -: 4802:
        -: 4803:/*
        -: 4804:  Builtin functions
        -: 4805: */
        -: 4806:
        -: 4807:static char *
function func_patsubst called 0 returned 0% blocks executed 0%
    #####: 4808:func_patsubst (o, argv, funcname)
        -: 4809:     char *o;
        -: 4810:     char **argv;
        -: 4811:     const char *funcname;
        -: 4812:{
    #####: 4813:  o = patsubst_expand (o, argv[2], argv[0], argv[1], (char *) 0, (char *) 0);
call    0 never executed
    #####: 4814:  return o;
        -: 4815:}
        -: 4816:
        -: 4817:
        -: 4818:static char *
function func_join called 0 returned 0% blocks executed 0%
    #####: 4819:func_join (o, argv, funcname)
        -: 4820:     char *o;
        -: 4821:     char **argv;
        -: 4822:     const char *funcname;
        -: 4823:{
    #####: 4824:  int doneany = 0;
        -: 4825:
        -: 4826:  /* Write each word of the first argument directly followed
        -: 4827:     by the corresponding word of the second argument.
        -: 4828:     If the two arguments have a different number of words,
        -: 4829:     the excess words are just output separated by blanks.  */
        -: 4830:  register char *tp;
        -: 4831:  register char *pp;
    #####: 4832:  char *list1_iterator = argv[0];
    #####: 4833:  char *list2_iterator = argv[1];
        -: 4834:  do
        -: 4835:    {
        -: 4836:      unsigned int len1, len2;
        -: 4837:
    #####: 4838:      tp = find_next_token (&list1_iterator, &len1);
call    0 never executed
    #####: 4839:      if (tp != 0)
branch  0 never executed
branch  1 never executed
    #####: 4840:	o = variable_buffer_output (o, tp, len1);
call    0 never executed
        -: 4841:
    #####: 4842:      pp = find_next_token (&list2_iterator, &len2);
call    0 never executed
    #####: 4843:      if (pp != 0)
branch  0 never executed
branch  1 never executed
    #####: 4844:	o = variable_buffer_output (o, pp, len2);
call    0 never executed
        -: 4845:
    #####: 4846:      if (tp != 0 || pp != 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 4847:	{
    #####: 4848:	  o = variable_buffer_output (o, " ", 1);
call    0 never executed
    #####: 4849:	  doneany = 1;
        -: 4850:	}
        -: 4851:    }
    #####: 4852:  while (tp != 0 || pp != 0);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4853:  if (doneany)
branch  0 never executed
branch  1 never executed
        -: 4854:    /* Kill the last blank.  */
    #####: 4855:    --o;
        -: 4856:
    #####: 4857:  return o;
        -: 4858:}
        -: 4859:
        -: 4860:
        -: 4861:static char *
function func_origin called 0 returned 0% blocks executed 0%
    #####: 4862:func_origin (o, argv, funcname)
        -: 4863:     char *o;
        -: 4864:     char **argv;
        -: 4865:     const char *funcname;
        -: 4866:{
        -: 4867:  /* Expand the argument.  */
    #####: 4868:  register struct variable *v = lookup_variable (argv[0], strlen (argv[0]));
call    0 never executed
    #####: 4869:  if (v == 0)
branch  0 never executed
branch  1 never executed
    #####: 4870:    o = variable_buffer_output (o, "undefined", 9);
call    0 never executed
        -: 4871:  else
    #####: 4872:    switch (v->origin)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -: 4873:      {
    #####: 4874:      default:
        -: 4875:      case o_invalid:
    #####: 4876:	abort ();
call    0 never executed
        -: 4877:	break;
    #####: 4878:      case o_default:
    #####: 4879:	o = variable_buffer_output (o, "default", 7);
call    0 never executed
    #####: 4880:	break;
    #####: 4881:      case o_env:
    #####: 4882:	o = variable_buffer_output (o, "environment", 11);
call    0 never executed
    #####: 4883:	break;
    #####: 4884:      case o_file:
    #####: 4885:	o = variable_buffer_output (o, "file", 4);
call    0 never executed
    #####: 4886:	break;
    #####: 4887:      case o_env_override:
    #####: 4888:	o = variable_buffer_output (o, "environment override", 20);
call    0 never executed
    #####: 4889:	break;
    #####: 4890:      case o_command:
    #####: 4891:	o = variable_buffer_output (o, "command line", 12);
call    0 never executed
    #####: 4892:	break;
    #####: 4893:      case o_override:
    #####: 4894:	o = variable_buffer_output (o, "override", 8);
call    0 never executed
    #####: 4895:	break;
    #####: 4896:      case o_automatic:
    #####: 4897:	o = variable_buffer_output (o, "automatic", 9);
call    0 never executed
    #####: 4898:	break;
        -: 4899:      }
        -: 4900:
    #####: 4901:  return o;
        -: 4902:}
        -: 4903:
        -: 4904:#ifdef VMS
        -: 4905:#define IS_PATHSEP(c) ((c) == ']')
        -: 4906:#else
        -: 4907:#if defined(__MSDOS__) || defined(WINDOWS32)
        -: 4908:#define IS_PATHSEP(c) ((c) == '/' || (c) == '\\')
        -: 4909:#else
        -: 4910:#define IS_PATHSEP(c) ((c) == '/')
        -: 4911:#endif
        -: 4912:#endif
        -: 4913:
        -: 4914:
        -: 4915:static char *
function func_notdir_suffix called 0 returned 0% blocks executed 0%
    #####: 4916:func_notdir_suffix (o, argv, funcname)
        -: 4917:     char *o;
        -: 4918:     char **argv;
        -: 4919:     const char *funcname;
        -: 4920:{
        -: 4921:  /* Expand the argument.  */
    #####: 4922:  char *list_iterator = argv[0];
    #####: 4923:  char *p2 =0;
    #####: 4924:  int doneany =0;
    #####: 4925:  unsigned int len=0;
        -: 4926:
    #####: 4927:  int is_suffix = streq (funcname, "suffix");
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####: 4928:  int is_notdir = !is_suffix;
    #####: 4929:  while ((p2 = find_next_token (&list_iterator, &len)) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 4930:    {
    #####: 4931:      char *p = p2 + len;
        -: 4932:
        -: 4933:
    #####: 4934:      while (p >= p2 && (!is_suffix || *p != '.'))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 4935:	{
    #####: 4936:	  if (IS_PATHSEP (*p))
branch  0 never executed
branch  1 never executed
    #####: 4937:	    break;
    #####: 4938:	  --p;
        -: 4939:	}
        -: 4940:
    #####: 4941:      if (p >= p2)
branch  0 never executed
branch  1 never executed
        -: 4942:	{
    #####: 4943:	  if (is_notdir)
branch  0 never executed
branch  1 never executed
    #####: 4944:	    ++p;
    #####: 4945:	  else if (*p != '.')
branch  0 never executed
branch  1 never executed
    #####: 4946:	    continue;
    #####: 4947:	  o = variable_buffer_output (o, p, len - (p - p2));
call    0 never executed
        -: 4948:	}
        -: 4949:#if defined(WINDOWS32) || defined(__MSDOS__)
        -: 4950:      /* Handle the case of "d:foo/bar".  */
        -: 4951:      else if (streq (funcname, "notdir") && p2[0] && p2[1] == ':')
        -: 4952:	{
        -: 4953:	  p = p2 + 2;
        -: 4954:	  o = variable_buffer_output (o, p, len - (p - p2));
        -: 4955:	}
        -: 4956:#endif
    #####: 4957:      else if (is_notdir)
branch  0 never executed
branch  1 never executed
    #####: 4958:	o = variable_buffer_output (o, p2, len);
call    0 never executed
        -: 4959:
    #####: 4960:      if (is_notdir || p >= p2)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 4961:	{
    #####: 4962:	  o = variable_buffer_output (o, " ", 1);
call    0 never executed
    #####: 4963:	  doneany = 1;
        -: 4964:	}
        -: 4965:    }
    #####: 4966:  if (doneany)
branch  0 never executed
branch  1 never executed
        -: 4967:    /* Kill last space.  */
    #####: 4968:    --o;
        -: 4969:
        -: 4970:
    #####: 4971:  return o;
        -: 4972:
        -: 4973:}
        -: 4974:
        -: 4975:
        -: 4976:static char *
function func_basename_dir called 0 returned 0% blocks executed 0%
    #####: 4977:func_basename_dir (o, argv, funcname)
        -: 4978:     char *o;
        -: 4979:     char **argv;
        -: 4980:     const char *funcname;
        -: 4981:{
        -: 4982:  /* Expand the argument.  */
    #####: 4983:  char *p3 = argv[0];
    #####: 4984:  char *p2=0;
    #####: 4985:  int doneany=0;
    #####: 4986:  unsigned int len=0;
    #####: 4987:  char *p=0;
    #####: 4988:  int is_basename= streq (funcname, "basename");
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####: 4989:  int is_dir= !is_basename;
        -: 4990:
    #####: 4991:  while ((p2 = find_next_token (&p3, &len)) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 4992:	{
    #####: 4993:	  p = p2 + len;
    #####: 4994:	  while (p >= p2 && (!is_basename  || *p != '.'))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 4995:	    {
    #####: 4996:	      if (IS_PATHSEP (*p))
branch  0 never executed
branch  1 never executed
    #####: 4997:		break;
    #####: 4998:	      	    --p;
        -: 4999:	    }
        -: 5000:
    #####: 5001:	  if (p >= p2 && (is_dir))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 5002:	    o = variable_buffer_output (o, p2, ++p - p2);
call    0 never executed
    #####: 5003:	  else if (p >= p2 && (*p == '.'))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 5004:	    o = variable_buffer_output (o, p2, p - p2);
call    0 never executed
        -: 5005:#if defined(WINDOWS32) || defined(__MSDOS__)
        -: 5006:	/* Handle the "d:foobar" case */
        -: 5007:	  else if (p2[0] && p2[1] == ':' && is_dir)
        -: 5008:	    o = variable_buffer_output (o, p2, 2);
        -: 5009:#endif
    #####: 5010:	  else if (is_dir)
branch  0 never executed
branch  1 never executed
        -: 5011:#ifdef VMS
        -: 5012:	    o = variable_buffer_output (o, "[]", 2);
        -: 5013:#else
        -: 5014:#ifndef _AMIGA
    #####: 5015:	    o = variable_buffer_output (o, "./", 2);
call    0 never executed
        -: 5016:#else
        -: 5017:	    ; /* Just a nop...  */
        -: 5018:#endif /* AMIGA */
        -: 5019:#endif /* !VMS */
        -: 5020:	  else
        -: 5021:	    /* The entire name is the basename.  */
    #####: 5022:	    o = variable_buffer_output (o, p2, len);
call    0 never executed
        -: 5023:
    #####: 5024:	  o = variable_buffer_output (o, " ", 1);
call    0 never executed
    #####: 5025:	  doneany = 1;
        -: 5026:	}
    #####: 5027:      if (doneany)
branch  0 never executed
branch  1 never executed
        -: 5028:	/* Kill last space.  */
    #####: 5029:	--o;
        -: 5030:
        -: 5031:
    #####: 5032: return o;
        -: 5033:}
        -: 5034:
        -: 5035:static char *
function func_addsuffix_addprefix called 0 returned 0% blocks executed 0%
    #####: 5036:func_addsuffix_addprefix (o, argv, funcname)
        -: 5037:     char *o;
        -: 5038:     char **argv;
        -: 5039:     const char *funcname;
        -: 5040:{
    #####: 5041:  int fixlen = strlen (argv[0]);
    #####: 5042:  char *list_iterator = argv[1];
    #####: 5043:  int is_addprefix = streq (funcname, "addprefix");
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####: 5044:  int is_addsuffix = !is_addprefix;
        -: 5045:
    #####: 5046:  int doneany = 0;
        -: 5047:  char *p;
        -: 5048:  unsigned int len;
        -: 5049:
    #####: 5050:  while ((p = find_next_token (&list_iterator, &len)) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 5051:    {
    #####: 5052:      if (is_addprefix)
branch  0 never executed
branch  1 never executed
    #####: 5053:	o = variable_buffer_output (o, argv[0], fixlen);
call    0 never executed
    #####: 5054:      o = variable_buffer_output (o, p, len);
call    0 never executed
    #####: 5055:      if (is_addsuffix)
branch  0 never executed
branch  1 never executed
    #####: 5056:	o = variable_buffer_output (o, argv[0], fixlen);
call    0 never executed
    #####: 5057:      o = variable_buffer_output (o, " ", 1);
call    0 never executed
    #####: 5058:      doneany = 1;
        -: 5059:    }
        -: 5060:
    #####: 5061:  if (doneany)
branch  0 never executed
branch  1 never executed
        -: 5062:    /* Kill last space.  */
    #####: 5063:    --o;
        -: 5064:
    #####: 5065:  return o;
        -: 5066:}
        -: 5067:
        -: 5068:static char *
function func_subst called 0 returned 0% blocks executed 0%
    #####: 5069:func_subst (o, argv, funcname)
        -: 5070:     char *o;
        -: 5071:     char **argv;
        -: 5072:     const char *funcname;
        -: 5073:{
    #####: 5074:  o = subst_expand (o, argv[2], argv[0], argv[1], strlen (argv[0]),
    #####: 5075:		    strlen (argv[1]), 0, 0);
call    0 never executed
        -: 5076:
    #####: 5077:  return o;
        -: 5078:}
        -: 5079:
        -: 5080:
        -: 5081:static char *
function func_firstword called 0 returned 0% blocks executed 0%
    #####: 5082:func_firstword (o, argv, funcname)
        -: 5083:     char *o;
        -: 5084:     char **argv;
        -: 5085:     const char *funcname;
        -: 5086:{
        -: 5087:  unsigned int i;
    #####: 5088:  char *words = argv[0];    /* Use a temp variable for find_next_token */
    #####: 5089:  char *p = find_next_token (&words, &i);
call    0 never executed
        -: 5090:
    #####: 5091:  if (p != 0)
branch  0 never executed
branch  1 never executed
    #####: 5092:    o = variable_buffer_output (o, p, i);
call    0 never executed
        -: 5093:
    #####: 5094:  return o;
        -: 5095:}
        -: 5096:
        -: 5097:
        -: 5098:static char *
function func_words called 0 returned 0% blocks executed 0%
    #####: 5099:func_words (o, argv, funcname)
        -: 5100:     char *o;
        -: 5101:     char **argv;
        -: 5102:     const char *funcname;
        -: 5103:{
    #####: 5104:  int i = 0;
    #####: 5105:  char *word_iterator = argv[0];
        -: 5106:  char buf[20];
        -: 5107:
    #####: 5108:  while (find_next_token (&word_iterator, (unsigned int *) 0) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 5109:    ++i;
        -: 5110:
    #####: 5111:  sprintf (buf, "%d", i);
    #####: 5112:  o = variable_buffer_output (o, buf, strlen (buf));
call    0 never executed
        -: 5113:
        -: 5114:
    #####: 5115:  return o;
        -: 5116:}
        -: 5117:
        -: 5118:char *
function strip_whitespace called 0 returned 0% blocks executed 0%
    #####: 5119:strip_whitespace (begpp, endpp)
        -: 5120:     char **begpp;
        -: 5121:     char **endpp;
        -: 5122:{
    #####: 5123:  while (isspace ((unsigned char)**begpp) && *begpp <= *endpp)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 5124:    (*begpp) ++;
    #####: 5125:  while (isspace ((unsigned char)**endpp) && *endpp >= *begpp)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 5126:    (*endpp) --;
    #####: 5127:  return *begpp;
        -: 5128:}
        -: 5129:
        -: 5130:int
function is_numeric called 0 returned 0% blocks executed 0%
    #####: 5131:is_numeric (p)
        -: 5132:     char *p;
        -: 5133:{
    #####: 5134:  char *end = p + strlen (p) - 1;
    #####: 5135:  char *beg = p;
    #####: 5136:  strip_whitespace (&p, &end);
call    0 never executed
        -: 5137:
    #####: 5138:  while (p <= end)
branch  0 never executed
branch  1 never executed
    #####: 5139:    if (!ISDIGIT (*(p++)))  /* ISDIGIT only evals its arg once: see make.h.  */
branch  0 never executed
branch  1 never executed
    #####: 5140:      return 0;
        -: 5141:
    #####: 5142:  return (end - beg >= 0);
        -: 5143:}
        -: 5144:
        -: 5145:void
function check_numeric called 0 returned 0% blocks executed 0%
    #####: 5146:check_numeric (s, message)
        -: 5147:     char *s;
        -: 5148:     char *message;
        -: 5149:{
    #####: 5150:  if (!is_numeric (s))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 5151:    fatal (reading_file, message);
call    0 never executed
    #####: 5152:}
        -: 5153:
        -: 5154:
        -: 5155:
        -: 5156:static char *
function func_word called 0 returned 0% blocks executed 0%
    #####: 5157:func_word (o, argv, funcname)
        -: 5158:     char *o;
        -: 5159:     char **argv;
        -: 5160:     const char *funcname;
        -: 5161:{
    #####: 5162:  char *end_p=0;
    #####: 5163:  int i=0;
    #####: 5164:  char *p=0;
        -: 5165:
        -: 5166:  /* Check the first argument.  */
    #####: 5167:  check_numeric (argv[0], _("non-numeric first argument to `word' function"));
call    0 never executed
    #####: 5168:  i =  atoi (argv[0]);
        -: 5169:
    #####: 5170:  if (i == 0)
branch  0 never executed
branch  1 never executed
    #####: 5171:    fatal (reading_file, _("the `word' function takes a positive index argument"));
call    0 never executed
        -: 5172:
        -: 5173:
    #####: 5174:  end_p = argv[1];
    #####: 5175:  while ((p = find_next_token (&end_p, 0)) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 5176:    if (--i == 0)
branch  0 never executed
branch  1 never executed
    #####: 5177:      break;
        -: 5178:
    #####: 5179:  if (i == 0)
branch  0 never executed
branch  1 never executed
    #####: 5180:    o = variable_buffer_output (o, p, end_p - p);
call    0 never executed
        -: 5181:
    #####: 5182:  return o;
        -: 5183:}
        -: 5184:
        -: 5185:static char *
function func_wordlist called 0 returned 0% blocks executed 0%
    #####: 5186:func_wordlist (o, argv, funcname)
        -: 5187:     char *o;
        -: 5188:     char **argv;
        -: 5189:     const char *funcname;
        -: 5190:{
        -: 5191:  int start, count;
        -: 5192:
        -: 5193:  /* Check the arguments.  */
    #####: 5194:  check_numeric (argv[0],
call    0 never executed
        -: 5195:		 _("non-numeric first argument to `wordlist' function"));
    #####: 5196:  check_numeric (argv[1],
call    0 never executed
        -: 5197:		 _("non-numeric second argument to `wordlist' function"));
        -: 5198:
    #####: 5199:  start = atoi (argv[0]);
    #####: 5200:  count = atoi (argv[1]) - start + 1;
        -: 5201:
    #####: 5202:  if (count > 0)
branch  0 never executed
branch  1 never executed
        -: 5203:    {
        -: 5204:      char *p;
    #####: 5205:      char *end_p = argv[2];
        -: 5206:
        -: 5207:      /* Find the beginning of the "start"th word.  */
    #####: 5208:      while (((p = find_next_token (&end_p, 0)) != 0) && --start)
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -: 5209:        ;
        -: 5210:
    #####: 5211:      if (p)
branch  0 never executed
branch  1 never executed
        -: 5212:        {
        -: 5213:          /* Find the end of the "count"th word from start.  */
    #####: 5214:          while (--count && (find_next_token (&end_p, 0) != 0))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 5215:            ;
        -: 5216:
        -: 5217:          /* Return the stuff in the middle.  */
    #####: 5218:          o = variable_buffer_output (o, p, end_p - p);
call    0 never executed
        -: 5219:        }
        -: 5220:    }
        -: 5221:
    #####: 5222:  return o;
        -: 5223:}
        -: 5224:
        -: 5225:static char*
function func_findstring called 0 returned 0% blocks executed 0%
    #####: 5226:func_findstring (o, argv, funcname)
        -: 5227:     char *o;
        -: 5228:     char **argv;
        -: 5229:     const char *funcname;
        -: 5230:{
        -: 5231:  /* Find the first occurrence of the first string in the second.  */
    #####: 5232:  int i = strlen (argv[0]);
    #####: 5233:  if (sindex (argv[1], 0, argv[0], i) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 5234:    o = variable_buffer_output (o, argv[0], i);
call    0 never executed
        -: 5235:
    #####: 5236:  return o;
        -: 5237:}
        -: 5238:
        -: 5239:static char *
function func_foreach called 0 returned 0% blocks executed 0%
    #####: 5240:func_foreach (o, argv, funcname)
        -: 5241:     char *o;
        -: 5242:     char **argv;
        -: 5243:     const char *funcname;
        -: 5244:{
        -: 5245:  /* expand only the first two.  */
    #####: 5246:  char *varname = expand_argument (argv[0], NULL);
call    0 never executed
    #####: 5247:  char *list = expand_argument (argv[1], NULL);
call    0 never executed
    #####: 5248:  char *body = argv[2];
        -: 5249:
    #####: 5250:  int doneany = 0;
    #####: 5251:  char *list_iterator = list;
        -: 5252:  char *p;
        -: 5253:  unsigned int len;
        -: 5254:  register struct variable *var;
        -: 5255:
    #####: 5256:  push_new_variable_scope ();
call    0 never executed
    #####: 5257:  var = define_variable (varname, strlen (varname), "", o_automatic, 0);
call    0 never executed
        -: 5258:
        -: 5259:  /* loop through LIST,  put the value in VAR and expand BODY */
    #####: 5260:  while ((p = find_next_token (&list_iterator, &len)) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 5261:    {
    #####: 5262:      char *result = 0;
        -: 5263:
        -: 5264:      {
    #####: 5265:	char save = p[len];
        -: 5266:
    #####: 5267:	p[len] = '\0';
    #####: 5268:	free (var->value);
    #####: 5269:	var->value = (char *) xstrdup ((char*) p);
call    0 never executed
    #####: 5270:	p[len] = save;
        -: 5271:      }
        -: 5272:
    #####: 5273:      result = allocated_variable_expand (body);
call    0 never executed
        -: 5274:
    #####: 5275:      o = variable_buffer_output (o, result, strlen (result));
call    0 never executed
    #####: 5276:      o = variable_buffer_output (o, " ", 1);
call    0 never executed
    #####: 5277:      doneany = 1;
    #####: 5278:      free (result);
        -: 5279:    }
        -: 5280:
    #####: 5281:  if (doneany)
branch  0 never executed
branch  1 never executed
        -: 5282:    /* Kill the last space.  */
    #####: 5283:    --o;
        -: 5284:
    #####: 5285:  pop_variable_scope ();
call    0 never executed
    #####: 5286:  free (varname);
    #####: 5287:  free (list);
        -: 5288:
    #####: 5289:  return o;
        -: 5290:}
        -: 5291:
        -: 5292:struct a_word
        -: 5293:{
        -: 5294:  struct a_word *next;
        -: 5295:  char *str;
        -: 5296:  int matched;
        -: 5297:};
        -: 5298:
        -: 5299:static char *
function func_filter_filterout called 0 returned 0% blocks executed 0%
    #####: 5300:func_filter_filterout (o, argv, funcname)
        -: 5301:     char *o;
        -: 5302:     char **argv;
        -: 5303:     const char *funcname;
        -: 5304:{
    #####: 5305:  struct a_word *wordhead = 0;
    #####: 5306:  struct a_word *wordtail = 0;
        -: 5307:
    #####: 5308:  int is_filter = streq (funcname, "filter");
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####: 5309:  char *patterns = argv[0];
    #####: 5310:  char *word_iterator = argv[1];
        -: 5311:
        -: 5312:  char *p;
        -: 5313:  unsigned int len;
        -: 5314:
        -: 5315:  /* Chop ARGV[1] up into words and then run each pattern through.  */
    #####: 5316:  while ((p = find_next_token (&word_iterator, &len)) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 5317:    {
    #####: 5318:      struct a_word *w = (struct a_word *)alloca (sizeof (struct a_word));
    #####: 5319:      if (wordhead == 0)
branch  0 never executed
branch  1 never executed
    #####: 5320:	wordhead = w;
        -: 5321:      else
    #####: 5322:	wordtail->next = w;
    #####: 5323:      wordtail = w;
        -: 5324:
    #####: 5325:      if (*word_iterator != '\0')
branch  0 never executed
branch  1 never executed
    #####: 5326:	++word_iterator;
    #####: 5327:      p[len] = '\0';
    #####: 5328:      w->str = p;
    #####: 5329:      w->matched = 0;
        -: 5330:    }
        -: 5331:
    #####: 5332:  if (wordhead != 0)
branch  0 never executed
branch  1 never executed
        -: 5333:    {
    #####: 5334:      char *pat_iterator = patterns;
    #####: 5335:      int doneany = 0;
        -: 5336:      struct a_word *wp;
        -: 5337:
    #####: 5338:      wordtail->next = 0;
        -: 5339:
        -: 5340:      /* Run each pattern through the words, killing words.  */
    #####: 5341:      while ((p = find_next_token (&pat_iterator, &len)) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 5342:	{
        -: 5343:	  char *percent;
    #####: 5344:	  char save = p[len];
    #####: 5345:	  p[len] = '\0';
        -: 5346:
    #####: 5347:	  percent = find_percent (p);
call    0 never executed
    #####: 5348:	  for (wp = wordhead; wp != 0; wp = wp->next)
branch  0 never executed
branch  1 never executed
    #####: 5349:	    wp->matched |= (percent == 0 ? streq (p, wp->str)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####: 5350:			    : pattern_matches (p, percent, wp->str));
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 5351:
    #####: 5352:	  p[len] = save;
        -: 5353:	}
        -: 5354:
        -: 5355:      /* Output the words that matched (or didn't, for filter-out).  */
    #####: 5356:      for (wp = wordhead; wp != 0; wp = wp->next)
branch  0 never executed
branch  1 never executed
    #####: 5357:	if (is_filter ? wp->matched : !wp->matched)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 5358:	  {
    #####: 5359:	    o = variable_buffer_output (o, wp->str, strlen (wp->str));
call    0 never executed
    #####: 5360:	    o = variable_buffer_output (o, " ", 1);
call    0 never executed
    #####: 5361:	    doneany = 1;
        -: 5362:	  }
        -: 5363:
    #####: 5364:      if (doneany)
branch  0 never executed
branch  1 never executed
        -: 5365:	/* Kill the last space.  */
    #####: 5366:	--o;
        -: 5367:    }
        -: 5368:
    #####: 5369:  return o;
        -: 5370:}
        -: 5371:
        -: 5372:
        -: 5373:static char *
function func_strip called 2 returned 100% blocks executed 28%
        2: 5374:func_strip (o, argv, funcname)
        -: 5375:     char *o;
        -: 5376:     char **argv;
        -: 5377:     const char *funcname;
        -: 5378:{
        2: 5379:  char *p = argv[0];
        2: 5380:  int doneany =0;
        -: 5381:
        2: 5382:  while (*p != '\0')
branch  0 taken 0
branch  1 taken 2 (fallthrough)
        -: 5383:    {
    #####: 5384:      int i=0;
    #####: 5385:      char *word_start=0;
        -: 5386:
    #####: 5387:      while (isspace ((unsigned char)*p))
branch  0 never executed
branch  1 never executed
    #####: 5388:	++p;
    #####: 5389:      word_start = p;
    #####: 5390:      for (i=0; *p != '\0' && !isspace ((unsigned char)*p); ++p, ++i)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 5391:	{}
    #####: 5392:      if (!i)
branch  0 never executed
branch  1 never executed
    #####: 5393:	break;
    #####: 5394:      o = variable_buffer_output (o, word_start, i);
call    0 never executed
    #####: 5395:      o = variable_buffer_output (o, " ", 1);
call    0 never executed
    #####: 5396:      doneany = 1;
        -: 5397:    }
        -: 5398:
        2: 5399:  if (doneany)
branch  0 taken 0 (fallthrough)
branch  1 taken 2
        -: 5400:    /* Kill the last space.  */
    #####: 5401:    --o;
        2: 5402:  return o;
        -: 5403:}
        -: 5404:
        -: 5405:/*
        -: 5406:  Print a warning or fatal message.
        -: 5407:*/
        -: 5408:static char *
function func_error called 0 returned 0% blocks executed 0%
    #####: 5409:func_error (o, argv, funcname)
        -: 5410:     char *o;
        -: 5411:     char **argv;
        -: 5412:     const char *funcname;
        -: 5413:{
        -: 5414:  char **argvp;
        -: 5415:  char *msg, *p;
        -: 5416:  int len;
        -: 5417:
        -: 5418:  /* The arguments will be broken on commas.  Rather than create yet
        -: 5419:     another special case where function arguments aren't broken up,
        -: 5420:     just create a format string that puts them back together.  */
    #####: 5421:  for (len=0, argvp=argv; *argvp != 0; ++argvp)
branch  0 never executed
branch  1 never executed
    #####: 5422:    len += strlen (*argvp) + 2;
        -: 5423:
    #####: 5424:  p = msg = alloca (len + 1);
        -: 5425:
    #####: 5426:  for (argvp=argv; argvp[1] != 0; ++argvp)
branch  0 never executed
branch  1 never executed
        -: 5427:    {
    #####: 5428:      strcpy (p, *argvp);
    #####: 5429:      p += strlen (*argvp);
    #####: 5430:      *(p++) = ',';
    #####: 5431:      *(p++) = ' ';
        -: 5432:    }
    #####: 5433:  strcpy (p, *argvp);
        -: 5434:
    #####: 5435:  if (*funcname == 'e')
branch  0 never executed
branch  1 never executed
    #####: 5436:    fatal (reading_file, "%s", msg);
call    0 never executed
        -: 5437:
        -: 5438:  /* The warning function expands to the empty string.  */
    #####: 5439:  error (reading_file, "%s", msg);
call    0 never executed
        -: 5440:
    #####: 5441:  return o;
        -: 5442:}
        -: 5443:
        -: 5444:
        -: 5445:/*
        -: 5446:  chop argv[0] into words, and sort them.
        -: 5447: */
        -: 5448:static char *
function func_sort called 0 returned 0% blocks executed 0%
    #####: 5449:func_sort (o, argv, funcname)
        -: 5450:     char *o;
        -: 5451:     char **argv;
        -: 5452:     const char *funcname;
        -: 5453:{
    #####: 5454:  char **words = 0;
    #####: 5455:  int nwords = 0;
    #####: 5456:  register int wordi = 0;
        -: 5457:
        -: 5458:  /* Chop ARGV[0] into words and put them in WORDS.  */
    #####: 5459:  char *t = argv[0];
        -: 5460:  char *p;
        -: 5461:  unsigned int len;
        -: 5462:  int i;
        -: 5463:
    #####: 5464:  while ((p = find_next_token (&t, &len)) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 5465:    {
    #####: 5466:      if (wordi >= nwords - 1)
branch  0 never executed
branch  1 never executed
        -: 5467:	{
    #####: 5468:	  nwords = (2 * nwords) + 5;
    #####: 5469:	  words = (char **) xrealloc ((char *) words,
call    0 never executed
        -: 5470:				      nwords * sizeof (char *));
        -: 5471:	}
    #####: 5472:      words[wordi++] = savestring (p, len);
call    0 never executed
        -: 5473:    }
        -: 5474:
    #####: 5475:  if (!wordi)
branch  0 never executed
branch  1 never executed
    #####: 5476:    return o;
        -: 5477:
        -: 5478:  /* Now sort the list of words.  */
    #####: 5479:  qsort ((char *) words, wordi, sizeof (char *), alpha_compare);
call    0 never executed
        -: 5480:
        -: 5481:  /* Now write the sorted list.  */
    #####: 5482:  for (i = 0; i < wordi; ++i)
branch  0 never executed
branch  1 never executed
        -: 5483:    {
    #####: 5484:      len = strlen (words[i]);
    #####: 5485:      if (i == wordi - 1 || strlen (words[i + 1]) != len
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 5486:          || strcmp (words[i], words[i + 1]))
branch  0 never executed
branch  1 never executed
        -: 5487:        {
    #####: 5488:          o = variable_buffer_output (o, words[i], len);
call    0 never executed
    #####: 5489:          o = variable_buffer_output (o, " ", 1);
call    0 never executed
        -: 5490:        }
    #####: 5491:      free (words[i]);
        -: 5492:    }
        -: 5493:  /* Kill the last space.  */
    #####: 5494:  --o;
        -: 5495:
    #####: 5496:  free (words);
        -: 5497:
    #####: 5498:  return o;
        -: 5499:}
        -: 5500:
        -: 5501:/*
        -: 5502:  $(if condition,true-part[,false-part])
        -: 5503:
        -: 5504:  CONDITION is false iff it evaluates to an empty string.  White
        -: 5505:  space before and after condition are stripped before evaluation.
        -: 5506:
        -: 5507:  If CONDITION is true, then TRUE-PART is evaluated, otherwise FALSE-PART is
        -: 5508:  evaluated (if it exists).  Because only one of the two PARTs is evaluated,
        -: 5509:  you can use $(if ...) to create side-effects (with $(shell ...), for
        -: 5510:  example).
        -: 5511:*/
        -: 5512:
        -: 5513:static char *
function func_if called 0 returned 0% blocks executed 0%
    #####: 5514:func_if (o, argv, funcname)
        -: 5515:     char *o;
        -: 5516:     char **argv;
        -: 5517:     const char *funcname;
        -: 5518:{
    #####: 5519:  char *begp = argv[0];
    #####: 5520:  char *endp = begp + strlen (argv[0]);
    #####: 5521:  int result = 0;
        -: 5522:
        -: 5523:  /* Find the result of the condition: if we have a value, and it's not
        -: 5524:     empty, the condition is true.  If we don't have a value, or it's the
        -: 5525:     empty string, then it's false.  */
        -: 5526:
    #####: 5527:  strip_whitespace (&begp, &endp);
call    0 never executed
        -: 5528:
    #####: 5529:  if (begp < endp)
branch  0 never executed
branch  1 never executed
        -: 5530:    {
    #####: 5531:      char *expansion = expand_argument (begp, NULL);
call    0 never executed
        -: 5532:
    #####: 5533:      result = strlen (expansion);
    #####: 5534:      free (expansion);
        -: 5535:    }
        -: 5536:
        -: 5537:  /* If the result is true (1) we want to eval the first argument, and if
        -: 5538:     it's false (0) we want to eval the second.  If the argument doesn't
        -: 5539:     exist we do nothing, otherwise expand it and add to the buffer.  */
        -: 5540:
    #####: 5541:  argv += 1 + !result;
branch  0 never executed
branch  1 never executed
        -: 5542:
    #####: 5543:  if (argv[0])
branch  0 never executed
branch  1 never executed
        -: 5544:    {
        -: 5545:      char *expansion;
        -: 5546:
    #####: 5547:      expansion = expand_argument (argv[0], NULL);
call    0 never executed
        -: 5548:
    #####: 5549:      o = variable_buffer_output (o, expansion, strlen (expansion));
call    0 never executed
        -: 5550:
    #####: 5551:      free (expansion);
        -: 5552:    }
        -: 5553:
    #####: 5554:  return o;
        -: 5555:}
        -: 5556:
        -: 5557:static char *
function func_wildcard called 0 returned 0% blocks executed 0%
    #####: 5558:func_wildcard (o, argv, funcname)
        -: 5559:     char *o;
        -: 5560:     char **argv;
        -: 5561:     const char *funcname;
        -: 5562:{
        -: 5563:
        -: 5564:#ifdef _AMIGA
        -: 5565:   o = wildcard_expansion (argv[0], o);
        -: 5566:#else
    #####: 5567:   char *p = string_glob (argv[0]);
call    0 never executed
    #####: 5568:   o = variable_buffer_output (o, p, strlen (p));
call    0 never executed
        -: 5569:#endif
    #####: 5570:   return o;
        -: 5571:}
        -: 5572:
        -: 5573:/*
        -: 5574:  \r  is replaced on UNIX as well. Is this desirable?
        -: 5575: */
        -: 5576:void
function fold_newlines called 0 returned 0% blocks executed 0%
    #####: 5577:fold_newlines (buffer, length)
        -: 5578:     char *buffer;
        -: 5579:     int *length;
        -: 5580:{
    #####: 5581:  char *dst = buffer;
    #####: 5582:  char *src = buffer;
    #####: 5583:  char *last_nonnl = buffer -1;
    #####: 5584:  src[*length] = 0;
    #####: 5585:  for (; *src != '\0'; ++src)
branch  0 never executed
branch  1 never executed
        -: 5586:    {
    #####: 5587:      if (src[0] == '\r' && src[1] == '\n')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 5588:	continue;
    #####: 5589:      if (*src == '\n')
branch  0 never executed
branch  1 never executed
        -: 5590:	{
    #####: 5591:	  *dst++ = ' ';
        -: 5592:	}
        -: 5593:      else
        -: 5594:	{
    #####: 5595:	  last_nonnl = dst;
    #####: 5596:	  *dst++ = *src;
        -: 5597:	}
        -: 5598:    }
    #####: 5599:  *(++last_nonnl) = '\0';
    #####: 5600:  *length = last_nonnl - buffer;
    #####: 5601:}
        -: 5602:
        -: 5603:
        -: 5604:
        -: 5605:int shell_function_pid = 0, shell_function_completed;
        -: 5606:
        -: 5607:
        -: 5608:#ifdef WINDOWS32
        -: 5609:/*untested*/
        -: 5610:
        -: 5611:#include <windows.h>
        -: 5612:#include <io.h>
        -: 5613:#include "sub_proc.h"
        -: 5614:#undef stderr
        -: 5615:#define stderr stdout
        -: 5616:
        -: 5617:
        -: 5618:void
        -: 5619:windows32_openpipe (int *pipedes, int *pid_p, char **command_argv, char **envp)
        -: 5620:{
        -: 5621:  SECURITY_ATTRIBUTES saAttr;
        -: 5622:  HANDLE hIn;
        -: 5623:  HANDLE hErr;
        -: 5624:  HANDLE hChildOutRd;
        -: 5625:  HANDLE hChildOutWr;
        -: 5626:  HANDLE hProcess;
        -: 5627:
        -: 5628:
        -: 5629:  saAttr.nLength = sizeof (SECURITY_ATTRIBUTES);
        -: 5630:  saAttr.bInheritHandle = TRUE;
        -: 5631:  saAttr.lpSecurityDescriptor = NULL;
        -: 5632:
        -: 5633:  if (DuplicateHandle (GetCurrentProcess(),
        -: 5634:		      GetStdHandle(STD_INPUT_HANDLE),
        -: 5635:		      GetCurrentProcess(),
        -: 5636:		      &hIn,
        -: 5637:		      0,
        -: 5638:		      TRUE,
        -: 5639:		      DUPLICATE_SAME_ACCESS) == FALSE) {
        -: 5640:    fatal (NILF, _("create_child_process: DuplicateHandle(In) failed (e=%d)\n"),
        -: 5641:	   GetLastError());
        -: 5642:
        -: 5643:  }
        -: 5644:  if (DuplicateHandle(GetCurrentProcess(),
        -: 5645:		      GetStdHandle(STD_ERROR_HANDLE),
        -: 5646:		      GetCurrentProcess(),
        -: 5647:		      &hErr,
        -: 5648:		      0,
        -: 5649:		      TRUE,
        -: 5650:		      DUPLICATE_SAME_ACCESS) == FALSE) {
        -: 5651:    fatal (NILF, _("create_child_process: DuplicateHandle(Err) failed (e=%d)\n"),
        -: 5652:	   GetLastError());
        -: 5653:  }
        -: 5654:
        -: 5655:  if (!CreatePipe(&hChildOutRd, &hChildOutWr, &saAttr, 0))
        -: 5656:    fatal (NILF, _("CreatePipe() failed (e=%d)\n"), GetLastError());
        -: 5657:
        -: 5658:  hProcess = process_init_fd(hIn, hChildOutWr, hErr);
        -: 5659:
        -: 5660:  if (!hProcess)
        -: 5661:    fatal (NILF, _("windows32_openpipe (): process_init_fd() failed\n"));
        -: 5662:
        -: 5663:  /* make sure that CreateProcess() has Path it needs */
        -: 5664:  sync_Path_environment();
        -: 5665:
        -: 5666:  if (!process_begin(hProcess, command_argv, envp, command_argv[0], NULL)) {
        -: 5667:    /* register process for wait */
        -: 5668:    process_register(hProcess);
        -: 5669:
        -: 5670:    /* set the pid for returning to caller */
        -: 5671:    *pid_p = (int) hProcess;
        -: 5672:
        -: 5673:  /* set up to read data from child */
        -: 5674:  pipedes[0] = _open_osfhandle((long) hChildOutRd, O_RDONLY);
        -: 5675:
        -: 5676:  /* this will be closed almost right away */
        -: 5677:  pipedes[1] = _open_osfhandle((long) hChildOutWr, O_APPEND);
        -: 5678:  } else {
        -: 5679:    /* reap/cleanup the failed process */
        -: 5680:	process_cleanup(hProcess);
        -: 5681:
        -: 5682:    /* close handles which were duplicated, they weren't used */
        -: 5683:	CloseHandle(hIn);
        -: 5684:	CloseHandle(hErr);
        -: 5685:
        -: 5686:	/* close pipe handles, they won't be used */
        -: 5687:	CloseHandle(hChildOutRd);
        -: 5688:	CloseHandle(hChildOutWr);
        -: 5689:
        -: 5690:    /* set status for return */
        -: 5691:    pipedes[0] = pipedes[1] = -1;
        -: 5692:    *pid_p = -1;
        -: 5693:  }
        -: 5694:}
        -: 5695:#endif
        -: 5696:
        -: 5697:
        -: 5698:#ifdef __MSDOS__
        -: 5699:FILE *
        -: 5700:msdos_openpipe (int* pipedes, int *pidp, char *text)
        -: 5701:{
        -: 5702:  FILE *fpipe=0;
        -: 5703:  /* MSDOS can't fork, but it has `popen'.  */
        -: 5704:  struct variable *sh = lookup_variable ("SHELL", 5);
        -: 5705:  int e;
        -: 5706:  extern int dos_command_running, dos_status;
        -: 5707:
        -: 5708:  /* Make sure not to bother processing an empty line.  */
        -: 5709:  while (isblank (*text))
        -: 5710:    ++text;
        -: 5711:  if (*text == '\0')
        -: 5712:    return 0;
        -: 5713:
        -: 5714:  if (sh)
        -: 5715:    {
        -: 5716:      char buf[PATH_MAX + 7];
        -: 5717:      /* This makes sure $SHELL value is used by $(shell), even
        -: 5718:	 though the target environment is not passed to it.  */
        -: 5719:      sprintf (buf, "SHELL=%s", sh->value);
        -: 5720:      putenv (buf);
        -: 5721:    }
        -: 5722:
        -: 5723:  e = errno;
        -: 5724:  errno = 0;
        -: 5725:  dos_command_running = 1;
        -: 5726:  dos_status = 0;
        -: 5727:  /* If dos_status becomes non-zero, it means the child process
        -: 5728:     was interrupted by a signal, like SIGINT or SIGQUIT.  See
        -: 5729:     fatal_error_signal in commands.c.  */
        -: 5730:  fpipe = popen (text, "rt");
        -: 5731:  dos_command_running = 0;
        -: 5732:  if (!fpipe || dos_status)
        -: 5733:    {
        -: 5734:      pipedes[0] = -1;
        -: 5735:      *pidp = -1;
        -: 5736:      if (dos_status)
        -: 5737:	errno = EINTR;
        -: 5738:      else if (errno == 0)
        -: 5739:	errno = ENOMEM;
        -: 5740:      shell_function_completed = -1;
        -: 5741:    }
        -: 5742:  else
        -: 5743:    {
        -: 5744:      pipedes[0] = fileno (fpipe);
        -: 5745:      *pidp = 42; /* Yes, the Meaning of Life, the Universe, and Everything! */
        -: 5746:      errno = e;
        -: 5747:      shell_function_completed = 1;
        -: 5748:    }
        -: 5749:  return fpipe;
        -: 5750:}
        -: 5751:#endif
        -: 5752:
        -: 5753:/*
        -: 5754:  Do shell spawning, with the naughty bits for different OSes.
        -: 5755: */
        -: 5756:
        -: 5757:#ifdef VMS
        -: 5758:
        -: 5759:/* VMS can't do $(shell ...)  */
        -: 5760:#define func_shell 0
        -: 5761:
        -: 5762:#else
        -: 5763:#ifndef _AMIGA
        -: 5764:static char *
function func_shell called 0 returned 0% blocks executed 0%
    #####: 5765:func_shell (o, argv, funcname)
        -: 5766:     char *o;
        -: 5767:     char **argv;
        -: 5768:     const char *funcname;
        -: 5769:{
    #####: 5770:  char* batch_filename = NULL;
        -: 5771:  int i;
        -: 5772:
        -: 5773:#ifdef __MSDOS__
        -: 5774:  FILE *fpipe;
        -: 5775:#endif
        -: 5776:  char **command_argv;
        -: 5777:  char *error_prefix;
        -: 5778:  char **envp;
        -: 5779:  int pipedes[2];
        -: 5780:  int pid;
        -: 5781:
        -: 5782:#ifndef __MSDOS__
        -: 5783:  /* Construct the argument list.  */
    #####: 5784:  command_argv = construct_command_argv (argv[0],
call    0 never executed
        -: 5785:					 (char **) NULL, (struct file *) 0,
        -: 5786:                                         &batch_filename);
    #####: 5787:  if (command_argv == 0)
branch  0 never executed
branch  1 never executed
    #####: 5788:    return o;
        -: 5789:#endif
        -: 5790:
        -: 5791:  /* Using a target environment for `shell' loses in cases like:
        -: 5792:     export var = $(shell echo foobie)
        -: 5793:     because target_environment hits a loop trying to expand $(var)
        -: 5794:     to put it in the environment.  This is even more confusing when
        -: 5795:     var was not explicitly exported, but just appeared in the
        -: 5796:     calling environment.  */
        -: 5797:
    #####: 5798:  envp = environ;
        -: 5799:
        -: 5800:  /* For error messages.  */
    #####: 5801:  if (reading_file != 0)
branch  0 never executed
branch  1 never executed
        -: 5802:    {
    #####: 5803:      error_prefix = (char *) alloca (strlen (reading_file->filenm)+11+4);
    #####: 5804:      sprintf (error_prefix,
    #####: 5805:	       "%s:%lu: ", reading_file->filenm, reading_file->lineno);
        -: 5806:    }
        -: 5807:  else
    #####: 5808:    error_prefix = "";
        -: 5809:
        -: 5810:#ifdef WINDOWS32
        -: 5811:  windows32_openpipe (pipedes, &pid, command_argv, envp);
        -: 5812:
        -: 5813:  if (pipedes[0] < 0) {
        -: 5814:	/* open of the pipe failed, mark as failed execution */
        -: 5815:    shell_function_completed = -1;
        -: 5816:
        -: 5817:	return o;
        -: 5818:  } else
        -: 5819:#else /* WINDOWS32 */
        -: 5820:
        -: 5821:# ifdef __MSDOS__
        -: 5822:  fpipe = msdos_openpipe (pipedes, &pid, argv[0]);
        -: 5823:  if (pipedes[0] < 0)
        -: 5824:    {
        -: 5825:      perror_with_name (error_prefix, "pipe");
        -: 5826:      return o;
        -: 5827:    }
        -: 5828:# else
    #####: 5829:  if (pipe (pipedes) < 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 5830:    {
    #####: 5831:      perror_with_name (error_prefix, "pipe");
call    0 never executed
    #####: 5832:      return o;
        -: 5833:    }
        -: 5834:
    #####: 5835:  pid = vfork ();
call    0 never executed
    #####: 5836:  if (pid < 0)
branch  0 never executed
branch  1 never executed
    #####: 5837:    perror_with_name (error_prefix, "fork");
call    0 never executed
    #####: 5838:  else if (pid == 0)
branch  0 never executed
branch  1 never executed
    #####: 5839:    child_execute_job (0, pipedes[1], command_argv, envp);
call    0 never executed
        -: 5840:  else
        -: 5841:# endif /* ! __MSDOS__ */
        -: 5842:
        -: 5843:#endif /* WINDOWS32 */
        -: 5844:    {
        -: 5845:      /* We are the parent.  */
        -: 5846:
        -: 5847:      char *buffer;
        -: 5848:      unsigned int maxlen;
        -: 5849:      int cc;
        -: 5850:
        -: 5851:      /* Record the PID for reap_children.  */
    #####: 5852:      shell_function_pid = pid;
        -: 5853:#ifndef  __MSDOS__
    #####: 5854:      shell_function_completed = 0;
        -: 5855:
        -: 5856:      /* Free the storage only the child needed.  */
    #####: 5857:      free (command_argv[0]);
    #####: 5858:      free ((char *) command_argv);
        -: 5859:
        -: 5860:      /* Close the write side of the pipe.  */
    #####: 5861:      (void) close (pipedes[1]);
call    0 never executed
        -: 5862:#endif
        -: 5863:
        -: 5864:      /* Set up and read from the pipe.  */
        -: 5865:
    #####: 5866:      maxlen = 200;
    #####: 5867:      buffer = (char *) xmalloc (maxlen + 1);
call    0 never executed
        -: 5868:
        -: 5869:      /* Read from the pipe until it gets EOF.  */
    #####: 5870:      i = 0;
        -: 5871:      do
        -: 5872:	{
    #####: 5873:	  if (i == maxlen)
branch  0 never executed
branch  1 never executed
        -: 5874:	    {
    #####: 5875:	      maxlen += 512;
    #####: 5876:	      buffer = (char *) xrealloc (buffer, maxlen + 1);
call    0 never executed
        -: 5877:	    }
        -: 5878:
    #####: 5879:	  errno = 0;
    #####: 5880:	  cc = read (pipedes[0], &buffer[i], maxlen - i);
call    0 never executed
    #####: 5881:	  if (cc > 0)
branch  0 never executed
branch  1 never executed
    #####: 5882:	    i += cc;
        -: 5883:	}
    #####: 5884:      while (cc > 0 || EINTR_SET);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 5885:
        -: 5886:      /* Close the read side of the pipe.  */
        -: 5887:#ifdef  __MSDOS__
        -: 5888:      if (fpipe)
        -: 5889:	(void) pclose (fpipe);
        -: 5890:#else
    #####: 5891:      (void) close (pipedes[0]);
call    0 never executed
        -: 5892:#endif
        -: 5893:
        -: 5894:      /* Loop until child_handler sets shell_function_completed
        -: 5895:	 to the status of our child shell.  */
    #####: 5896:      while (shell_function_completed == 0)
branch  0 never executed
branch  1 never executed
    #####: 5897:	reap_children (1, 0);
call    0 never executed
        -: 5898:
    #####: 5899:      if (batch_filename) {
branch  0 never executed
branch  1 never executed
    #####: 5900:	DB (DB_VERBOSE, (_("Cleaning up temporary batch file %s\n"),
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
        -: 5901:                       batch_filename));
    #####: 5902:	remove (batch_filename);
call    0 never executed
    #####: 5903:	free (batch_filename);
        -: 5904:      }
    #####: 5905:      shell_function_pid = 0;
        -: 5906:
        -: 5907:      /* The child_handler function will set shell_function_completed
        -: 5908:	 to 1 when the child dies normally, or to -1 if it
        -: 5909:	 dies with status 127, which is most likely an exec fail.  */
        -: 5910:
    #####: 5911:      if (shell_function_completed == -1)
branch  0 never executed
branch  1 never executed
        -: 5912:	{
        -: 5913:	  /* This most likely means that the execvp failed,
        -: 5914:	     so we should just write out the error message
        -: 5915:	     that came in over the pipe from the child.  */
    #####: 5916:	  fputs (buffer, stderr);
call    0 never executed
    #####: 5917:	  fflush (stderr);
call    0 never executed
        -: 5918:	}
        -: 5919:      else
        -: 5920:	{
        -: 5921:	  /* The child finished normally.  Replace all
        -: 5922:	     newlines in its output with spaces, and put
        -: 5923:	     that in the variable output buffer.  */
    #####: 5924:	  fold_newlines (buffer, &i);
call    0 never executed
    #####: 5925:	  o = variable_buffer_output (o, buffer, i);
call    0 never executed
        -: 5926:	}
        -: 5927:
    #####: 5928:      free (buffer);
        -: 5929:    }
        -: 5930:
    #####: 5931:  return o;
        -: 5932:}
        -: 5933:
        -: 5934:#else	/* _AMIGA */
        -: 5935:
        -: 5936:/* Do the Amiga version of func_shell.  */
        -: 5937:
        -: 5938:static char *
        -: 5939:func_shell (char *o, char **argv, const char *funcname)
        -: 5940:{
        -: 5941:  /* Amiga can't fork nor spawn, but I can start a program with
        -: 5942:     redirection of my choice.  However, this means that we
        -: 5943:     don't have an opportunity to reopen stdout to trap it.  Thus,
        -: 5944:     we save our own stdout onto a new descriptor and dup a temp
        -: 5945:     file's descriptor onto our stdout temporarily.  After we
        -: 5946:     spawn the shell program, we dup our own stdout back to the
        -: 5947:     stdout descriptor.  The buffer reading is the same as above,
        -: 5948:     except that we're now reading from a file.  */
        -: 5949:
        -: 5950:#include <dos/dos.h>
        -: 5951:#include <proto/dos.h>
        -: 5952:#undef stderr
        -: 5953:#define stderr stdout
        -: 5954:
        -: 5955:  BPTR child_stdout;
        -: 5956:  char tmp_output[FILENAME_MAX];
        -: 5957:  unsigned int maxlen = 200;
        -: 5958:  int cc, i;
        -: 5959:  char * buffer, * ptr;
        -: 5960:  char ** aptr;
        -: 5961:  int len = 0;
        -: 5962:  char* batch_filename = NULL;
        -: 5963:
        -: 5964:  /* Construct the argument list.  */
        -: 5965:  command_argv = construct_command_argv (argv[0], (char **) NULL,
        -: 5966:                                         (struct file *) 0, &batch_filename);
        -: 5967:  if (command_argv == 0)
        -: 5968:    return o;
        -: 5969:
        -: 5970:  /* Note the mktemp() is a security hole, but this only runs on Amiga.
        -: 5971:     Ideally we would use main.c:open_tmpfile(), but this uses a special
        -: 5972:     Open(), not fopen(), and I'm not familiar enough with the code to mess
        -: 5973:     with it.  */
        -: 5974:  strcpy (tmp_output, "t:MakeshXXXXXXXX");
        -: 5975:  mktemp (tmp_output);
        -: 5976:  child_stdout = Open (tmp_output, MODE_NEWFILE);
        -: 5977:
        -: 5978:  for (aptr=command_argv; *aptr; aptr++)
        -: 5979:    len += strlen (*aptr) + 1;
        -: 5980:
        -: 5981:  buffer = xmalloc (len + 1);
        -: 5982:  ptr = buffer;
        -: 5983:
        -: 5984:  for (aptr=command_argv; *aptr; aptr++)
        -: 5985:    {
        -: 5986:      strcpy (ptr, *aptr);
        -: 5987:      ptr += strlen (ptr) + 1;
        -: 5988:      *ptr ++ = ' ';
        -: 5989:      *ptr = 0;
        -: 5990:    }
        -: 5991:
        -: 5992:  ptr[-1] = '\n';
        -: 5993:
        -: 5994:  Execute (buffer, NULL, child_stdout);
        -: 5995:  free (buffer);
        -: 5996:
        -: 5997:  Close (child_stdout);
        -: 5998:
        -: 5999:  child_stdout = Open (tmp_output, MODE_OLDFILE);
        -: 6000:
        -: 6001:  buffer = xmalloc (maxlen);
        -: 6002:  i = 0;
        -: 6003:  do
        -: 6004:    {
        -: 6005:      if (i == maxlen)
        -: 6006:	{
        -: 6007:	  maxlen += 512;
        -: 6008:	  buffer = (char *) xrealloc (buffer, maxlen + 1);
        -: 6009:	}
        -: 6010:
        -: 6011:      cc = Read (child_stdout, &buffer[i], maxlen - i);
        -: 6012:      if (cc > 0)
        -: 6013:	i += cc;
        -: 6014:    } while (cc > 0);
        -: 6015:
        -: 6016:  Close (child_stdout);
        -: 6017:
        -: 6018:  fold_newlines (buffer, &i);
        -: 6019:  o = variable_buffer_output (o, buffer, i);
        -: 6020:  free (buffer);
        -: 6021:  return o;
        -: 6022:}
        -: 6023:#endif  /* _AMIGA */
        -: 6024:#endif  /* !VMS */
        -: 6025:
        -: 6026:#ifdef EXPERIMENTAL
        -: 6027:
        -: 6028:/*
        -: 6029:  equality. Return is string-boolean, ie, the empty string is false.
        -: 6030: */
        -: 6031:static char *
        -: 6032:func_eq (char* o, char **argv, char *funcname)
        -: 6033:{
        -: 6034:  int result = ! strcmp (argv[0], argv[1]);
        -: 6035:  o = variable_buffer_output (o,  result ? "1" : "", result);
        -: 6036:  return o;
        -: 6037:}
        -: 6038:
        -: 6039:
        -: 6040:/*
        -: 6041:  string-boolean not operator.
        -: 6042: */
        -: 6043:static char *
        -: 6044:func_not (char* o, char **argv, char *funcname)
        -: 6045:{
        -: 6046:  char * s = argv[0];
        -: 6047:  int result = 0;
        -: 6048:  while (isspace ((unsigned char)*s))
        -: 6049:    s++;
        -: 6050:  result = ! (*s);
        -: 6051:  o = variable_buffer_output (o,  result ? "1" : "", result);
        -: 6052:  return o;
        -: 6053:}
        -: 6054:#endif
        -: 6055:
        -: 6056:
        -: 6057:#define STRING_SIZE_TUPLE(_s) (_s), (sizeof (_s)-1)
        -: 6058:
        -: 6059:/* Lookup table for builtin functions.
        -: 6060:
        -: 6061:   This doesn't have to be sorted; we use a straight lookup.  We might gain
        -: 6062:   some efficiency by moving most often used functions to the start of the
        -: 6063:   table.
        -: 6064:
        -: 6065:   If MAXIMUM_ARGS is 0, that means there is no maximum and all
        -: 6066:   comma-separated values are treated as arguments.
        -: 6067:
        -: 6068:   EXPAND_ARGS means that all arguments should be expanded before invocation.
        -: 6069:   Functions that do namespace tricks (foreach) don't automatically expand.  */
        -: 6070:
        -: 6071:static char *func_call PARAMS ((char *o, char **argv, const char *funcname));
        -: 6072:
        -: 6073:
        -: 6074:static struct function_table_entry function_table[] =
        -: 6075:{
        -: 6076: /* Name/size */                    /* MIN MAX EXP? Function */
        -: 6077:  { STRING_SIZE_TUPLE("addprefix"),     2,  2,  1,  func_addsuffix_addprefix},
        -: 6078:  { STRING_SIZE_TUPLE("addsuffix"),     2,  2,  1,  func_addsuffix_addprefix},
        -: 6079:  { STRING_SIZE_TUPLE("basename"),      1,  1,  1,  func_basename_dir},
        -: 6080:  { STRING_SIZE_TUPLE("dir"),           1,  1,  1,  func_basename_dir},
        -: 6081:  { STRING_SIZE_TUPLE("notdir"),        1,  1,  1,  func_notdir_suffix},
        -: 6082:  { STRING_SIZE_TUPLE("subst"),         3,  3,  1,  func_subst},
        -: 6083:  { STRING_SIZE_TUPLE("suffix"),        1,  1,  1,  func_notdir_suffix},
        -: 6084:  { STRING_SIZE_TUPLE("filter"),        2,  2,  1,  func_filter_filterout},
        -: 6085:  { STRING_SIZE_TUPLE("filter-out"),    2,  2,  1,  func_filter_filterout},
        -: 6086:  { STRING_SIZE_TUPLE("findstring"),    2,  2,  1,  func_findstring},
        -: 6087:  { STRING_SIZE_TUPLE("firstword"),     1,  1,  1,  func_firstword},
        -: 6088:  { STRING_SIZE_TUPLE("join"),          2,  2,  1,  func_join},
        -: 6089:  { STRING_SIZE_TUPLE("patsubst"),      3,  3,  1,  func_patsubst},
        -: 6090:  { STRING_SIZE_TUPLE("shell"),         1,  1,  1,  func_shell},
        -: 6091:  { STRING_SIZE_TUPLE("sort"),          1,  1,  1,  func_sort},
        -: 6092:  { STRING_SIZE_TUPLE("strip"),         1,  1,  1,  func_strip},
        -: 6093:  { STRING_SIZE_TUPLE("wildcard"),      1,  1,  1,  func_wildcard},
        -: 6094:  { STRING_SIZE_TUPLE("word"),          2,  2,  1,  func_word},
        -: 6095:  { STRING_SIZE_TUPLE("wordlist"),      3,  3,  1,  func_wordlist},
        -: 6096:  { STRING_SIZE_TUPLE("words"),         1,  1,  1,  func_words},
        -: 6097:  { STRING_SIZE_TUPLE("origin"),        1,  1,  1,  func_origin},
        -: 6098:  { STRING_SIZE_TUPLE("foreach"),       3,  3,  0,  func_foreach},
        -: 6099:  { STRING_SIZE_TUPLE("call"),          1,  0,  1,  func_call},
        -: 6100:  { STRING_SIZE_TUPLE("error"),         1,  1,  1,  func_error},
        -: 6101:  { STRING_SIZE_TUPLE("warning"),       1,  1,  1,  func_error},
        -: 6102:  { STRING_SIZE_TUPLE("if"),            2,  3,  0,  func_if},
        -: 6103:#ifdef EXPERIMENTAL
        -: 6104:  { STRING_SIZE_TUPLE("eq"),            2,  2,  1,  func_eq},
        -: 6105:  { STRING_SIZE_TUPLE("not"),           1,  1,  1,  func_not},
        -: 6106:#endif
        -: 6107:  { 0 }
        -: 6108:};
        -: 6109:
        -: 6110:
        -: 6111:/* These must come after the definition of function_table[].  */
        -: 6112:
        -: 6113:static char *
function expand_builtin_function called 2 returned 100% blocks executed 67%
        2: 6114:expand_builtin_function (o, argc, argv, entry_p)
        -: 6115:     char *o;
        -: 6116:     int argc;
        -: 6117:     char **argv;
        -: 6118:     struct function_table_entry *entry_p;
        -: 6119:{
        2: 6120:  if (argc < entry_p->minimum_args)
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####: 6121:    fatal (reading_file,
    #####: 6122:           _("Insufficient number of arguments (%d) to function `%s'"),
call    0 never executed
        -: 6123:           argc, entry_p->name);
        -: 6124:
        2: 6125:  if (!entry_p->func_ptr)
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####: 6126:    fatal (reading_file, _("Unimplemented on this platform: function `%s'"),
call    0 never executed
        -: 6127:           entry_p->name);
        -: 6128:
        2: 6129:  return entry_p->func_ptr (o, argv, entry_p->name);
call    0 returned 2
        -: 6130:}
        -: 6131:
        -: 6132:/* Check for a function invocation in *STRINGP.  *STRINGP points at the
        -: 6133:   opening ( or { and is not null-terminated.  If a function invocation
        -: 6134:   is found, expand it into the buffer at *OP, updating *OP, incrementing
        -: 6135:   *STRINGP past the reference and returning nonzero.  If not, return zero.  */
        -: 6136:
        -: 6137:int
function handle_function called 7 returned 100% blocks executed 78%
        7: 6138:handle_function (op, stringp)
        -: 6139:     char **op;
        -: 6140:     char **stringp;
        -: 6141:{
        -: 6142:  const struct function_table_entry *entry_p;
        7: 6143:  char openparen = (*stringp)[0];
       7*: 6144:  char closeparen = openparen == '(' ? ')' : '}';
branch  0 taken 7 (fallthrough)
branch  1 taken 0
        -: 6145:  char *beg;
        -: 6146:  char *end;
        7: 6147:  int count = 0;
        -: 6148:  register char *p;
        -: 6149:  char **argv, **argvp;
        -: 6150:  int nargs;
        -: 6151:
        7: 6152:  beg = *stringp + 1;
        -: 6153:
        7: 6154:  entry_p = lookup_function (function_table, beg);
call    0 returned 7
        -: 6155:
        7: 6156:  if (!entry_p)
branch  0 taken 5 (fallthrough)
branch  1 taken 2
        5: 6157:    return 0;
        -: 6158:
        -: 6159:  /* We found a builtin function.  Find the beginning of its arguments (skip
        -: 6160:     whitespace after the name).  */
        -: 6161:
        2: 6162:  beg = next_token (beg + entry_p->len);
call    0 returned 2
        -: 6163:
        -: 6164:  /* Find the end of the function invocation, counting nested use of
        -: 6165:     whichever kind of parens we use.  Since we're looking, count commas
        -: 6166:     to get a rough estimate of how many arguments we might have.  The
        -: 6167:     count might be high, but it'll never be low.  */
        -: 6168:
       18: 6169:  for (nargs=1, end=beg; *end != '\0'; ++end)
branch  0 taken 18
branch  1 taken 0 (fallthrough)
       18: 6170:    if (*end == ',')
branch  0 taken 0 (fallthrough)
branch  1 taken 18
    #####: 6171:      ++nargs;
       18: 6172:    else if (*end == openparen)
branch  0 taken 2 (fallthrough)
branch  1 taken 16
        2: 6173:      ++count;
       16: 6174:    else if (*end == closeparen && --count < 0)
branch  0 taken 4 (fallthrough)
branch  1 taken 12
branch  2 taken 2 (fallthrough)
branch  3 taken 2
        2: 6175:      break;
        -: 6176:
        2: 6177:  if (count >= 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####: 6178:    fatal (reading_file,
    #####: 6179:	   _("unterminated call to function `%s': missing `%c'"),
    #####: 6180:	   entry_p->name, closeparen);
call    0 never executed
        -: 6181:
        2: 6182:  *stringp = end;
        -: 6183:
        -: 6184:  /* Get some memory to store the arg pointers.  */
        2: 6185:  argvp = argv = (char **) alloca (sizeof (char *) * (nargs + 2));
        -: 6186:
        -: 6187:  /* Chop the string into arguments, then a nul.  As soon as we hit
        -: 6188:     MAXIMUM_ARGS (if it's >0) assume the rest of the string is part of the
        -: 6189:     last argument.
        -: 6190:
        -: 6191:     If we're expanding, store pointers to the expansion of each one.  If
        -: 6192:     not, make a duplicate of the string and point into that, nul-terminating
        -: 6193:     each argument.  */
        -: 6194:
        2: 6195:  if (!entry_p->expand_args)
branch  0 taken 0 (fallthrough)
branch  1 taken 2
        -: 6196:    {
    #####: 6197:      int len = end - beg;
        -: 6198:
    #####: 6199:      p = xmalloc (len+1);
call    0 never executed
    #####: 6200:      memcpy (p, beg, len);
    #####: 6201:      p[len] = '\0';
    #####: 6202:      beg = p;
    #####: 6203:      end = beg + len;
        -: 6204:    }
        -: 6205:
        2: 6206:  p = beg;
        2: 6207:  nargs = 0;
        4: 6208:  for (p=beg, nargs=0; p < end; ++argvp)
branch  0 taken 2
branch  1 taken 2 (fallthrough)
        -: 6209:    {
        -: 6210:      char *next;
        -: 6211:
        2: 6212:      ++nargs;
        -: 6213:
        2: 6214:      if (nargs == entry_p->maximum_args
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####: 6215:          || (! (next = find_next_argument (openparen, closeparen, p, end))))
call    0 never executed
branch  1 never executed
branch  2 never executed
        2: 6216:        next = end;
        -: 6217:
        2: 6218:      if (entry_p->expand_args)
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2: 6219:        *argvp = expand_argument (p, next);
call    0 returned 2
        -: 6220:      else
        -: 6221:        {
    #####: 6222:          *argvp = p;
    #####: 6223:          *next = '\0';
        -: 6224:        }
        -: 6225:
        2: 6226:      p = next + 1;
        -: 6227:    }
        2: 6228:  *argvp = NULL;
        -: 6229:
        -: 6230:  /* Finally!  Run the function...  */
        2: 6231:  *op = expand_builtin_function (*op, nargs, argv, entry_p);
call    0 returned 2
        -: 6232:
        -: 6233:  /* Free memory.  */
        2: 6234:  if (entry_p->expand_args)
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        4: 6235:    for (argvp=argv; *argvp != 0; ++argvp)
branch  0 taken 2
branch  1 taken 2
        2: 6236:      free (*argvp);
        -: 6237:  else
    #####: 6238:    free (beg);
        -: 6239:
        2: 6240:  return 1;
        -: 6241:}
        -: 6242:
        -: 6243:
        -: 6244:/* User-defined functions.  Expand the first argument as either a builtin
        -: 6245:   function or a make variable, in the context of the rest of the arguments
        -: 6246:   assigned to $1, $2, ... $N.  $0 is the name of the function.  */
        -: 6247:
        -: 6248:static char *
function func_call called 0 returned 0% blocks executed 0%
    #####: 6249:func_call (o, argv, funcname)
        -: 6250:     char *o;
        -: 6251:     char **argv;
        -: 6252:     const char *funcname;
        -: 6253:{
        -: 6254:  char *fname;
        -: 6255:  char *cp;
        -: 6256:  int flen;
        -: 6257:  char *body;
        -: 6258:  int i;
        -: 6259:  const struct function_table_entry *entry_p;
        -: 6260:
        -: 6261:  /* There is no way to define a variable with a space in the name, so strip
        -: 6262:     leading and trailing whitespace as a favor to the user.  */
    #####: 6263:  fname = argv[0];
    #####: 6264:  while (*fname != '\0' && isspace ((unsigned char)*fname))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 6265:    ++fname;
        -: 6266:
    #####: 6267:  cp = fname + strlen (fname) - 1;
    #####: 6268:  while (cp > fname && isspace ((unsigned char)*cp))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 6269:    --cp;
    #####: 6270:  cp[1] = '\0';
        -: 6271:
        -: 6272:  /* Calling nothing is a no-op */
    #####: 6273:  if (*fname == '\0')
branch  0 never executed
branch  1 never executed
    #####: 6274:    return o;
        -: 6275:
        -: 6276:  /* Are we invoking a builtin function?  */
        -: 6277:
    #####: 6278:  entry_p = lookup_function (function_table, fname);
call    0 never executed
        -: 6279:
    #####: 6280:  if (entry_p)
branch  0 never executed
branch  1 never executed
        -: 6281:    {
        -: 6282:      /* How many arguments do we have?  */
    #####: 6283:      for (i=0; argv[i+1]; ++i)
branch  0 never executed
branch  1 never executed
        -: 6284:  	;
        -: 6285:
    #####: 6286:      return expand_builtin_function (o, i, argv+1, entry_p);
call    0 never executed
        -: 6287:    }
        -: 6288:
        -: 6289:  /* Not a builtin, so the first argument is the name of a variable to be
        -: 6290:     expanded and interpreted as a function.  Create the variable
        -: 6291:     reference.  */
    #####: 6292:  flen = strlen (fname);
        -: 6293:
    #####: 6294:  body = alloca (flen + 4);
    #####: 6295:  body[0] = '$';
    #####: 6296:  body[1] = '(';
    #####: 6297:  memcpy (body + 2, fname, flen);
    #####: 6298:  body[flen+2] = ')';
    #####: 6299:  body[flen+3] = '\0';
        -: 6300:
        -: 6301:  /* Set up arguments $(1) .. $(N).  $(0) is the function name.  */
        -: 6302:
    #####: 6303:  push_new_variable_scope ();
call    0 never executed
        -: 6304:
    #####: 6305:  for (i=0; *argv; ++i, ++argv)
branch  0 never executed
branch  1 never executed
        -: 6306:    {
        -: 6307:      char num[11];
        -: 6308:
    #####: 6309:      sprintf (num, "%d", i);
    #####: 6310:      define_variable (num, strlen (num), *argv, o_automatic, 1);
call    0 never executed
        -: 6311:    }
        -: 6312:
        -: 6313:  /* Expand the body in the context of the arguments, adding the result to
        -: 6314:     the variable buffer.  */
        -: 6315:
    #####: 6316:  o = variable_expand_string (o, body, flen+3);
call    0 never executed
        -: 6317:
    #####: 6318:  pop_variable_scope ();
call    0 never executed
        -: 6319:
    #####: 6320:  return o + strlen (o);
        -: 6321:}
        -: 6322:
        -: 6323:
        -: 6324:
        -: 6325:/*************************************************************
        -: 6326:  ============================================================
        -: 6327:  ************************************************************
        -: 6328:  ============================================================
        -: 6329:  ************************************************************
        -: 6330:                         getopt.c
        -: 6331:  ************************************************************
        -: 6332:  ============================================================
        -: 6333:  ************************************************************
        -: 6334:  ============================================================
        -: 6335:  *************************************************************/
        -: 6336:
        -: 6337:/* Getopt for GNU.
        -: 6338:   NOTE: getopt is now part of the C library, so if you don't know what
        -: 6339:   "Keep this file name-space clean" means, talk to drepper@gnu.org
        -: 6340:   before changing it!
        -: 6341:
        -: 6342:   Copyright (C) 1987, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98
        -: 6343:   	Free Software Foundation, Inc.
        -: 6344:
        -: 6345:   NOTE: The canonical source of this file is maintained with the GNU C Library.
        -: 6346:   Bugs can be reported to bug-glibc@gnu.org.
        -: 6347:
        -: 6348:   This program is free software; you can redistribute it and/or modify it
        -: 6349:   under the terms of the GNU General Public License as published by the
        -: 6350:   Free Software Foundation; either version 2, or (at your option) any
        -: 6351:   later version.
        -: 6352:
        -: 6353:   This program is distributed in the hope that it will be useful,
        -: 6354:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 6355:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 6356:   GNU General Public License for more details.
        -: 6357:
        -: 6358:   You should have received a copy of the GNU General Public License
        -: 6359:   along with this program; if not, write to the Free Software
        -: 6360:   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
        -: 6361:   USA.  */
        -: 6362:
        -: 6363:/* This tells Alpha OSF/1 not to define a getopt prototype in <stdio.h>.
        -: 6364:   Ditto for AIX 3.2 and <stdlib.h>.  */
        -: 6365:#ifndef _NO_PROTO
        -: 6366:# define _NO_PROTO
        -: 6367:#endif
        -: 6368:
        -: 6369:#ifdef HAVE_CONFIG_H
        -: 6370:# include <config.h>
        -: 6371:#undef stderr
        -: 6372:#define stderr stdout
        -: 6373:#endif
        -: 6374:
        -: 6375:#if !defined __STDC__ || !__STDC__
        -: 6376:/* This is a separate conditional since some stdc systems
        -: 6377:   reject `defined (const)'.  */
        -: 6378:# ifndef const
        -: 6379:#  define const
        -: 6380:# endif
        -: 6381:#endif
        -: 6382:
        -: 6383:#include <stdio.h>
        -: 6384:#undef stderr
        -: 6385:#define stderr stdout
        -: 6386:
        -: 6387:/* Comment out all this code if we are using the GNU C Library, and are not
        -: 6388:   actually compiling the library itself.  This code is part of the GNU C
        -: 6389:   Library, but also included in many other GNU distributions.  Compiling
        -: 6390:   and linking in this code is a waste when using the GNU C library
        -: 6391:   (especially if it is a shared library).  Rather than having every GNU
        -: 6392:   program understand `configure --with-gnu-libc' and omit the object files,
        -: 6393:   it is simpler to just do this in the source for each such file.  */
        -: 6394:
        -: 6395:#define GETOPT_INTERFACE_VERSION 2
        -: 6396:#if !defined _LIBC && defined __GLIBC__ && __GLIBC__ >= 2
        -: 6397:# include <gnu-versions.h>
        -: 6398:#undef stderr
        -: 6399:#define stderr stdout
        -: 6400:# if _GNU_GETOPT_INTERFACE_VERSION == GETOPT_INTERFACE_VERSION
        -: 6401:#  define ELIDE_CODE
        -: 6402:# endif
        -: 6403:#endif
        -: 6404:
        -: 6405:#ifndef ELIDE_CODE
        -: 6406:
        -: 6407:
        -: 6408:/* This needs to come after some library #include
        -: 6409:   to get __GNU_LIBRARY__ defined.  */
        -: 6410:#ifdef	__GNU_LIBRARY__
        -: 6411:/* Don't include stdlib.h for non-GNU C libraries because some of them
        -: 6412:   contain conflicting prototypes for getopt.  */
        -: 6413:# include <stdlib.h>
        -: 6414:# include <unistd.h>
        -: 6415:#undef stderr
        -: 6416:#define stderr stdout
        -: 6417:#endif	/* GNU C library.  */
        -: 6418:
        -: 6419:#ifdef VMS
        -: 6420:# include <unixlib.h>
        -: 6421:#undef stderr
        -: 6422:#define stderr stdout
        -: 6423:# if HAVE_STRING_H - 0
        -: 6424:#  include <string.h>
        -: 6425:#undef stderr
        -: 6426:#define stderr stdout
        -: 6427:# endif
        -: 6428:#endif
        -: 6429:
        -: 6430:/* This is for other GNU distributions with internationalized messages.
        -: 6431:   When compiling libc, the _ macro is predefined.  */
        -: 6432:#include "gettext.h"
        -: 6433:#undef stderr
        -: 6434:#define stderr stdout
        -: 6435://#define _(msgid)    gettext (msgid)
        -: 6436:
        -: 6437:
        -: 6438:/* This version of `getopt' appears to the caller like standard Unix `getopt'
        -: 6439:   but it behaves differently for the user, since it allows the user
        -: 6440:   to intersperse the options with the other arguments.
        -: 6441:
        -: 6442:   As `getopt' works, it permutes the elements of ARGV so that,
        -: 6443:   when it is done, all the options precede everything else.  Thus
        -: 6444:   all application programs are extended to handle flexible argument order.
        -: 6445:
        -: 6446:   Setting the environment variable POSIXLY_CORRECT disables permutation.
        -: 6447:   Then the behavior is completely standard.
        -: 6448:
        -: 6449:   GNU application programs can use a third alternative mode in which
        -: 6450:   they can distinguish the relative order of options and other arguments.  */
        -: 6451:
        -: 6452:#include "getopt.h"
        -: 6453:#undef stderr
        -: 6454:#define stderr stdout
        -: 6455:
        -: 6456:/* For communication from `getopt' to the caller.
        -: 6457:   When `getopt' finds an option that takes an argument,
        -: 6458:   the argument value is returned here.
        -: 6459:   Also, when `ordering' is RETURN_IN_ORDER,
        -: 6460:   each non-option ARGV-element is returned here.  */
        -: 6461:
        -: 6462:char *optarg = NULL;
        -: 6463:
        -: 6464:/* Index in ARGV of the next element to be scanned.
        -: 6465:   This is used for communication to and from the caller
        -: 6466:   and for communication between successive calls to `getopt'.
        -: 6467:
        -: 6468:   On entry to `getopt', zero means this is the first call; initialize.
        -: 6469:
        -: 6470:   When `getopt' returns -1, this is the index of the first of the
        -: 6471:   non-option elements that the caller should itself scan.
        -: 6472:
        -: 6473:   Otherwise, `optind' communicates from one call to the next
        -: 6474:   how much of ARGV has been scanned so far.  */
        -: 6475:
        -: 6476:/* 1003.2 says this must be 1 before any call.  */
        -: 6477:int optind = 1;
        -: 6478:
        -: 6479:/* Formerly, initialization of getopt depended on optind==0, which
        -: 6480:   causes problems with re-calling getopt as programs generally don't
        -: 6481:   know that. */
        -: 6482:
        -: 6483:int __getopt_initialized = 0;
        -: 6484:
        -: 6485:/* The next char to be scanned in the option-element
        -: 6486:   in which the last option character we returned was found.
        -: 6487:   This allows us to pick up the scan where we left off.
        -: 6488:
        -: 6489:   If this is zero, or a null string, it means resume the scan
        -: 6490:   by advancing to the next ARGV-element.  */
        -: 6491:
        -: 6492:static char *nextchar;
        -: 6493:
        -: 6494:/* Callers store zero here to inhibit the error message
        -: 6495:   for unrecognized options.  */
        -: 6496:
        -: 6497:int opterr = 1;
        -: 6498:
        -: 6499:/* Set to an option character which was unrecognized.
        -: 6500:   This must be initialized on some systems to avoid linking in the
        -: 6501:   system's own getopt implementation.  */
        -: 6502:
        -: 6503:int optopt = '?';
        -: 6504:
        -: 6505:/* Describe how to deal with options that follow non-option ARGV-elements.
        -: 6506:
        -: 6507:   If the caller did not specify anything,
        -: 6508:   the default is REQUIRE_ORDER if the environment variable
        -: 6509:   POSIXLY_CORRECT is defined, PERMUTE otherwise.
        -: 6510:
        -: 6511:   REQUIRE_ORDER means don't recognize them as options;
        -: 6512:   stop option processing when the first non-option is seen.
        -: 6513:   This is what Unix does.
        -: 6514:   This mode of operation is selected by either setting the environment
        -: 6515:   variable POSIXLY_CORRECT, or using `+' as the first character
        -: 6516:   of the list of option characters.
        -: 6517:
        -: 6518:   PERMUTE is the default.  We permute the contents of ARGV as we scan,
        -: 6519:   so that eventually all the non-options are at the end.  This allows options
        -: 6520:   to be given in any order, even with programs that were not written to
        -: 6521:   expect this.
        -: 6522:
        -: 6523:   RETURN_IN_ORDER is an option available to programs that were written
        -: 6524:   to expect options and other ARGV-elements in any order and that care about
        -: 6525:   the ordering of the two.  We describe each non-option ARGV-element
        -: 6526:   as if it were the argument of an option with character code 1.
        -: 6527:   Using `-' as the first character of the list of option characters
        -: 6528:   selects this mode of operation.
        -: 6529:
        -: 6530:   The special argument `--' forces an end of option-scanning regardless
        -: 6531:   of the value of `ordering'.  In the case of RETURN_IN_ORDER, only
        -: 6532:   `--' can cause `getopt' to return -1 with `optind' != ARGC.  */
        -: 6533:
        -: 6534:static enum
        -: 6535:{
        -: 6536:  REQUIRE_ORDER, PERMUTE, RETURN_IN_ORDER
        -: 6537:} ordering;
        -: 6538:
        -: 6539:/* Value of POSIXLY_CORRECT environment variable.  */
        -: 6540:static char *posixly_correct;
        -: 6541:
        -: 6542:#ifdef	__GNU_LIBRARY__
        -: 6543:/* We want to avoid inclusion of string.h with non-GNU libraries
        -: 6544:   because there are many ways it can cause trouble.
        -: 6545:   On some systems, it contains special magic macros that don't work
        -: 6546:   in GCC.  */
        -: 6547:# include <string.h>
        -: 6548:#undef stderr
        -: 6549:#define stderr stdout
        -: 6550:# define my_index	strchr
        -: 6551:#else
        -: 6552:
        -: 6553:# if HAVE_STRING_H
        -: 6554:#  include <string.h>
        -: 6555:#undef stderr
        -: 6556:#define stderr stdout
        -: 6557:# else
        -: 6558:#  include <strings.h>
        -: 6559:#undef stderr
        -: 6560:#define stderr stdout
        -: 6561:# endif
        -: 6562:
        -: 6563:/* Avoid depending on library functions or files
        -: 6564:   whose names are inconsistent.  */
        -: 6565:
        -: 6566:#ifndef getenv
        -: 6567:extern char *getenv ();
        -: 6568:#endif
        -: 6569:
        -: 6570:static char *
        -: 6571:my_index (str, chr)
        -: 6572:     const char *str;
        -: 6573:     int chr;
        -: 6574:{
        -: 6575:  while (*str)
        -: 6576:    {
        -: 6577:      if (*str == chr)
        -: 6578:	return (char *) str;
        -: 6579:      str++;
        -: 6580:    }
        -: 6581:  return 0;
        -: 6582:}
        -: 6583:
        -: 6584:/* If using GCC, we can safely declare strlen this way.
        -: 6585:   If not using GCC, it is ok not to declare it.  */
        -: 6586:#ifdef __GNUC__
        -: 6587:/* Note that Motorola Delta 68k R3V7 comes with GCC but not stddef.h.
        -: 6588:   That was relevant to code that was here before.  */
        -: 6589:# if (!defined __STDC__ || !__STDC__) && !defined strlen
        -: 6590:/* gcc with -traditional declares the built-in strlen to return int,
        -: 6591:   and has done so at least since version 2.4.5. -- rms.  */
        -: 6592:extern int strlen (const char *);
        -: 6593:# endif /* not __STDC__ */
        -: 6594:#endif /* __GNUC__ */
        -: 6595:
        -: 6596:#endif /* not __GNU_LIBRARY__ */
        -: 6597:
        -: 6598:/* Handle permutation of arguments.  */
        -: 6599:
        -: 6600:/* Describe the part of ARGV that contains non-options that have
        -: 6601:   been skipped.  `first_nonopt' is the index in ARGV of the first of them;
        -: 6602:   `last_nonopt' is the index after the last of them.  */
        -: 6603:
        -: 6604:static int first_nonopt;
        -: 6605:static int last_nonopt;
        -: 6606:
        -: 6607:#ifdef _LIBC
        -: 6608:/* Bash 2.0 gives us an environment variable containing flags
        -: 6609:   indicating ARGV elements that should not be considered arguments.  */
        -: 6610:
        -: 6611:/* Defined in getopt_init.c  */
        -: 6612:extern char *__getopt_nonoption_flags;
        -: 6613:
        -: 6614:static int nonoption_flags_max_len;
        -: 6615:static int nonoption_flags_len;
        -: 6616:
        -: 6617:static int original_argc;
        -: 6618:static char *const *original_argv;
        -: 6619:
        -: 6620:/* Make sure the environment variable bash 2.0 puts in the environment
        -: 6621:   is valid for the getopt call we must make sure that the ARGV passed
        -: 6622:   to getopt is that one passed to the process.  */
        -: 6623:static void
        -: 6624:__attribute__ ((unused))
        -: 6625:store_args_and_env (int argc, char *const *argv)
        -: 6626:{
        -: 6627:  /* XXX This is no good solution.  We should rather copy the args so
        -: 6628:     that we can compare them later.  But we must not use malloc(3).  */
        -: 6629:  original_argc = argc;
        -: 6630:  original_argv = argv;
        -: 6631:}
        -: 6632:# ifdef text_set_element
        -: 6633:text_set_element (__libc_subinit, store_args_and_env);
        -: 6634:# endif /* text_set_element */
        -: 6635:
        -: 6636:# define SWAP_FLAGS(ch1, ch2) \
        -: 6637:  if (nonoption_flags_len > 0)						      \
        -: 6638:    {									      \
        -: 6639:      char __tmp = __getopt_nonoption_flags[ch1];			      \
        -: 6640:      __getopt_nonoption_flags[ch1] = __getopt_nonoption_flags[ch2];	      \
        -: 6641:      __getopt_nonoption_flags[ch2] = __tmp;				      \
        -: 6642:    }
        -: 6643:#else	/* !_LIBC */
        -: 6644:# define SWAP_FLAGS(ch1, ch2)
        -: 6645:#endif	/* _LIBC */
        -: 6646:
        -: 6647:/* Exchange two adjacent subsequences of ARGV.
        -: 6648:   One subsequence is elements [first_nonopt,last_nonopt)
        -: 6649:   which contains all the non-options that have been skipped so far.
        -: 6650:   The other is elements [last_nonopt,optind), which contains all
        -: 6651:   the options processed since those non-options were skipped.
        -: 6652:
        -: 6653:   `first_nonopt' and `last_nonopt' are relocated so that they describe
        -: 6654:   the new indices of the non-options in ARGV after they are moved.  */
        -: 6655:
        -: 6656:#if defined __STDC__ && __STDC__
        -: 6657:static void exchange (char **);
        -: 6658:#endif
        -: 6659:
        -: 6660:static void
        -: 6661:exchange (argv)
        -: 6662:     char **argv;
        -: 6663:{
        -: 6664:  int bottom = first_nonopt;
        -: 6665:  int middle = last_nonopt;
        -: 6666:  int top = optind;
        -: 6667:  char *tem;
        -: 6668:
        -: 6669:  /* Exchange the shorter segment with the far end of the longer segment.
        -: 6670:     That puts the shorter segment into the right place.
        -: 6671:     It leaves the longer segment in the right place overall,
        -: 6672:     but it consists of two parts that need to be swapped next.  */
        -: 6673:
        -: 6674:#ifdef _LIBC
        -: 6675:  /* First make sure the handling of the `__getopt_nonoption_flags'
        -: 6676:     string can work normally.  Our top argument must be in the range
        -: 6677:     of the string.  */
        -: 6678:  if (nonoption_flags_len > 0 && top >= nonoption_flags_max_len)
        -: 6679:    {
        -: 6680:      /* We must extend the array.  The user plays games with us and
        -: 6681:	 presents new arguments.  */
        -: 6682:      char *new_str = malloc (top + 1);
        -: 6683:      if (new_str == NULL)
        -: 6684:	nonoption_flags_len = nonoption_flags_max_len = 0;
        -: 6685:      else
        -: 6686:	{
        -: 6687:	  memset (__mempcpy (new_str, __getopt_nonoption_flags,
        -: 6688:			     nonoption_flags_max_len),
        -: 6689:		  '\0', top + 1 - nonoption_flags_max_len);
        -: 6690:	  nonoption_flags_max_len = top + 1;
        -: 6691:	  __getopt_nonoption_flags = new_str;
        -: 6692:	}
        -: 6693:    }
        -: 6694:#endif
        -: 6695:
        -: 6696:  while (top > middle && middle > bottom)
        -: 6697:    {
        -: 6698:      if (top - middle > middle - bottom)
        -: 6699:	{
        -: 6700:	  /* Bottom segment is the short one.  */
        -: 6701:	  int len = middle - bottom;
        -: 6702:	  register int i;
        -: 6703:
        -: 6704:	  /* Swap it with the top part of the top segment.  */
        -: 6705:	  for (i = 0; i < len; i++)
        -: 6706:	    {
        -: 6707:	      tem = argv[bottom + i];
        -: 6708:	      argv[bottom + i] = argv[top - (middle - bottom) + i];
        -: 6709:	      argv[top - (middle - bottom) + i] = tem;
        -: 6710:	      SWAP_FLAGS (bottom + i, top - (middle - bottom) + i);
        -: 6711:	    }
        -: 6712:	  /* Exclude the moved bottom segment from further swapping.  */
        -: 6713:	  top -= len;
        -: 6714:	}
        -: 6715:      else
        -: 6716:	{
        -: 6717:	  /* Top segment is the short one.  */
        -: 6718:	  int len = top - middle;
        -: 6719:	  register int i;
        -: 6720:
        -: 6721:	  /* Swap it with the bottom part of the bottom segment.  */
        -: 6722:	  for (i = 0; i < len; i++)
        -: 6723:	    {
        -: 6724:	      tem = argv[bottom + i];
        -: 6725:	      argv[bottom + i] = argv[middle + i];
        -: 6726:	      argv[middle + i] = tem;
        -: 6727:	      SWAP_FLAGS (bottom + i, middle + i);
        -: 6728:	    }
        -: 6729:	  /* Exclude the moved top segment from further swapping.  */
        -: 6730:	  bottom += len;
        -: 6731:	}
        -: 6732:    }
        -: 6733:
        -: 6734:  /* Update records for the slots the non-options now occupy.  */
        -: 6735:
        -: 6736:  first_nonopt += (optind - last_nonopt);
        -: 6737:  last_nonopt = optind;
        -: 6738:}
        -: 6739:
        -: 6740:/* Initialize the internal data when the first call is made.  */
        -: 6741:
        -: 6742:#if defined __STDC__ && __STDC__
        -: 6743:static const char *_getopt_initialize (int, char *const *, const char *);
        -: 6744:#endif
        -: 6745:static const char *
        -: 6746:_getopt_initialize (argc, argv, optstring)
        -: 6747:     int argc;
        -: 6748:     char *const *argv;
        -: 6749:     const char *optstring;
        -: 6750:{
        -: 6751:  /* Start processing options with ARGV-element 1 (since ARGV-element 0
        -: 6752:     is the program name); the sequence of previously skipped
        -: 6753:     non-option ARGV-elements is empty.  */
        -: 6754:
        -: 6755:  first_nonopt = last_nonopt = optind;
        -: 6756:
        -: 6757:  nextchar = NULL;
        -: 6758:
        -: 6759:  posixly_correct = getenv ("POSIXLY_CORRECT");
        -: 6760:
        -: 6761:  /* Determine how to handle the ordering of options and nonoptions.  */
        -: 6762:
        -: 6763:  if (optstring[0] == '-')
        -: 6764:    {
        -: 6765:      ordering = RETURN_IN_ORDER;
        -: 6766:      ++optstring;
        -: 6767:    }
        -: 6768:  else if (optstring[0] == '+')
        -: 6769:    {
        -: 6770:      ordering = REQUIRE_ORDER;
        -: 6771:      ++optstring;
        -: 6772:    }
        -: 6773:  else if (posixly_correct != NULL)
        -: 6774:    ordering = REQUIRE_ORDER;
        -: 6775:  else
        -: 6776:    ordering = PERMUTE;
        -: 6777:
        -: 6778:#ifdef _LIBC
        -: 6779:  if (posixly_correct == NULL
        -: 6780:      && argc == original_argc && argv == original_argv)
        -: 6781:    {
        -: 6782:      if (nonoption_flags_max_len == 0)
        -: 6783:	{
        -: 6784:	  if (__getopt_nonoption_flags == NULL
        -: 6785:	      || __getopt_nonoption_flags[0] == '\0')
        -: 6786:	    nonoption_flags_max_len = -1;
        -: 6787:	  else
        -: 6788:	    {
        -: 6789:	      const char *orig_str = __getopt_nonoption_flags;
        -: 6790:	      int len = nonoption_flags_max_len = strlen (orig_str);
        -: 6791:	      if (nonoption_flags_max_len < argc)
        -: 6792:		nonoption_flags_max_len = argc;
        -: 6793:	      __getopt_nonoption_flags =
        -: 6794:		(char *) malloc (nonoption_flags_max_len);
        -: 6795:	      if (__getopt_nonoption_flags == NULL)
        -: 6796:		nonoption_flags_max_len = -1;
        -: 6797:	      else
        -: 6798:		memset (__mempcpy (__getopt_nonoption_flags, orig_str, len),
        -: 6799:			'\0', nonoption_flags_max_len - len);
        -: 6800:	    }
        -: 6801:	}
        -: 6802:      nonoption_flags_len = nonoption_flags_max_len;
        -: 6803:    }
        -: 6804:  else
        -: 6805:    nonoption_flags_len = 0;
        -: 6806:#endif
        -: 6807:
        -: 6808:  return optstring;
        -: 6809:}
        -: 6810:
        -: 6811:/* Scan elements of ARGV (whose length is ARGC) for option characters
        -: 6812:   given in OPTSTRING.
        -: 6813:
        -: 6814:   If an element of ARGV starts with '-', and is not exactly "-" or "--",
        -: 6815:   then it is an option element.  The characters of this element
        -: 6816:   (aside from the initial '-') are option characters.  If `getopt'
        -: 6817:   is called repeatedly, it returns successively each of the option characters
        -: 6818:   from each of the option elements.
        -: 6819:
        -: 6820:   If `getopt' finds another option character, it returns that character,
        -: 6821:   updating `optind' and `nextchar' so that the next call to `getopt' can
        -: 6822:   resume the scan with the following option character or ARGV-element.
        -: 6823:
        -: 6824:   If there are no more option characters, `getopt' returns -1.
        -: 6825:   Then `optind' is the index in ARGV of the first ARGV-element
        -: 6826:   that is not an option.  (The ARGV-elements have been permuted
        -: 6827:   so that those that are not options now come last.)
        -: 6828:
        -: 6829:   OPTSTRING is a string containing the legitimate option characters.
        -: 6830:   If an option character is seen that is not listed in OPTSTRING,
        -: 6831:   return '?' after printing an error message.  If you set `opterr' to
        -: 6832:   zero, the error message is suppressed but we still return '?'.
        -: 6833:
        -: 6834:   If a char in OPTSTRING is followed by a colon, that means it wants an arg,
        -: 6835:   so the following text in the same ARGV-element, or the text of the following
        -: 6836:   ARGV-element, is returned in `optarg'.  Two colons mean an option that
        -: 6837:   wants an optional arg; if there is text in the current ARGV-element,
        -: 6838:   it is returned in `optarg', otherwise `optarg' is set to zero.
        -: 6839:
        -: 6840:   If OPTSTRING starts with `-' or `+', it requests different methods of
        -: 6841:   handling the non-option ARGV-elements.
        -: 6842:   See the comments about RETURN_IN_ORDER and REQUIRE_ORDER, above.
        -: 6843:
        -: 6844:   Long-named options begin with `--' instead of `-'.
        -: 6845:   Their names may be abbreviated as long as the abbreviation is unique
        -: 6846:   or is an exact match for some defined option.  If they have an
        -: 6847:   argument, it follows the option name in the same ARGV-element, separated
        -: 6848:   from the option name by a `=', or else the in next ARGV-element.
        -: 6849:   When `getopt' finds a long-named option, it returns 0 if that option's
        -: 6850:   `flag' field is nonzero, the value of the option's `val' field
        -: 6851:   if the `flag' field is zero.
        -: 6852:
        -: 6853:   The elements of ARGV aren't really const, because we permute them.
        -: 6854:   But we pretend they're const in the prototype to be compatible
        -: 6855:   with other systems.
        -: 6856:
        -: 6857:   LONGOPTS is a vector of `struct option' terminated by an
        -: 6858:   element containing a name which is zero.
        -: 6859:
        -: 6860:   LONGIND returns the index in LONGOPT of the long-named option found.
        -: 6861:   It is only valid when a long-named option has been found by the most
        -: 6862:   recent call.
        -: 6863:
        -: 6864:   If LONG_ONLY is nonzero, '-' as well as '--' can introduce
        -: 6865:   long-named options.  */
        -: 6866:
        -: 6867:int
        -: 6868:_getopt_internal (argc, argv, optstring, longopts, longind, long_only)
        -: 6869:     int argc;
        -: 6870:     char *const *argv;
        -: 6871:     const char *optstring;
        -: 6872:     const struct option *longopts;
        -: 6873:     int *longind;
        -: 6874:     int long_only;
        -: 6875:{
        -: 6876:  optarg = NULL;
        -: 6877:
        -: 6878:  if (optind == 0 || !__getopt_initialized)
        -: 6879:    {
        -: 6880:      if (optind == 0)
        -: 6881:	optind = 1;	/* Don't scan ARGV[0], the program name.  */
        -: 6882:      optstring = _getopt_initialize (argc, argv, optstring);
        -: 6883:      __getopt_initialized = 1;
        -: 6884:    }
        -: 6885:
        -: 6886:  /* Test whether ARGV[optind] points to a non-option argument.
        -: 6887:     Either it does not have option syntax, or there is an environment flag
        -: 6888:     from the shell indicating it is not an option.  The later information
        -: 6889:     is only used when the used in the GNU libc.  */
        -: 6890:#ifdef _LIBC
        -: 6891:# define NONOPTION_P (argv[optind][0] != '-' || argv[optind][1] == '\0'	      \
        -: 6892:		      || (optind < nonoption_flags_len			      \
        -: 6893:			  && __getopt_nonoption_flags[optind] == '1'))
        -: 6894:#else
        -: 6895:# define NONOPTION_P (argv[optind][0] != '-' || argv[optind][1] == '\0')
        -: 6896:#endif
        -: 6897:
        -: 6898:  if (nextchar == NULL || *nextchar == '\0')
        -: 6899:    {
        -: 6900:      /* Advance to the next ARGV-element.  */
        -: 6901:
        -: 6902:      /* Give FIRST_NONOPT & LAST_NONOPT rational values if OPTIND has been
        -: 6903:	 moved back by the user (who may also have changed the arguments).  */
        -: 6904:      if (last_nonopt > optind)
        -: 6905:	last_nonopt = optind;
        -: 6906:      if (first_nonopt > optind)
        -: 6907:	first_nonopt = optind;
        -: 6908:
        -: 6909:      if (ordering == PERMUTE)
        -: 6910:	{
        -: 6911:	  /* If we have just processed some options following some non-options,
        -: 6912:	     exchange them so that the options come first.  */
        -: 6913:
        -: 6914:	  if (first_nonopt != last_nonopt && last_nonopt != optind)
        -: 6915:	    exchange ((char **) argv);
        -: 6916:	  else if (last_nonopt != optind)
        -: 6917:	    first_nonopt = optind;
        -: 6918:
        -: 6919:	  /* Skip any additional non-options
        -: 6920:	     and extend the range of non-options previously skipped.  */
        -: 6921:
        -: 6922:	  while (optind < argc && NONOPTION_P)
        -: 6923:	    optind++;
        -: 6924:	  last_nonopt = optind;
        -: 6925:	}
        -: 6926:
        -: 6927:      /* The special ARGV-element `--' means premature end of options.
        -: 6928:	 Skip it like a null option,
        -: 6929:	 then exchange with previous non-options as if it were an option,
        -: 6930:	 then skip everything else like a non-option.  */
        -: 6931:
        -: 6932:      if (optind != argc && !strcmp (argv[optind], "--"))
        -: 6933:	{
        -: 6934:	  optind++;
        -: 6935:
        -: 6936:	  if (first_nonopt != last_nonopt && last_nonopt != optind)
        -: 6937:	    exchange ((char **) argv);
        -: 6938:	  else if (first_nonopt == last_nonopt)
        -: 6939:	    first_nonopt = optind;
        -: 6940:	  last_nonopt = argc;
        -: 6941:
        -: 6942:	  optind = argc;
        -: 6943:	}
        -: 6944:
        -: 6945:      /* If we have done all the ARGV-elements, stop the scan
        -: 6946:	 and back over any non-options that we skipped and permuted.  */
        -: 6947:
        -: 6948:      if (optind == argc)
        -: 6949:	{
        -: 6950:	  /* Set the next-arg-index to point at the non-options
        -: 6951:	     that we previously skipped, so the caller will digest them.  */
        -: 6952:	  if (first_nonopt != last_nonopt)
        -: 6953:	    optind = first_nonopt;
        -: 6954:	  return -1;
        -: 6955:	}
        -: 6956:
        -: 6957:      /* If we have come to a non-option and did not permute it,
        -: 6958:	 either stop the scan or describe it to the caller and pass it by.  */
        -: 6959:
        -: 6960:      if (NONOPTION_P)
        -: 6961:	{
        -: 6962:	  if (ordering == REQUIRE_ORDER)
        -: 6963:	    return -1;
        -: 6964:	  optarg = argv[optind++];
        -: 6965:	  return 1;
        -: 6966:	}
        -: 6967:
        -: 6968:      /* We have found another option-ARGV-element.
        -: 6969:	 Skip the initial punctuation.  */
        -: 6970:
        -: 6971:      nextchar = (argv[optind] + 1
        -: 6972:		  + (longopts != NULL && argv[optind][1] == '-'));
        -: 6973:    }
        -: 6974:
        -: 6975:  /* Decode the current option-ARGV-element.  */
        -: 6976:
        -: 6977:  /* Check whether the ARGV-element is a long option.
        -: 6978:
        -: 6979:     If long_only and the ARGV-element has the form "-f", where f is
        -: 6980:     a valid short option, don't consider it an abbreviated form of
        -: 6981:     a long option that starts with f.  Otherwise there would be no
        -: 6982:     way to give the -f short option.
        -: 6983:
        -: 6984:     On the other hand, if there's a long option "fubar" and
        -: 6985:     the ARGV-element is "-fu", do consider that an abbreviation of
        -: 6986:     the long option, just like "--fu", and not "-f" with arg "u".
        -: 6987:
        -: 6988:     This distinction seems to be the most useful approach.  */
        -: 6989:
        -: 6990:  if (longopts != NULL
        -: 6991:      && (argv[optind][1] == '-'
        -: 6992:	  || (long_only && (argv[optind][2] || !my_index (optstring, argv[optind][1])))))
        -: 6993:    {
        -: 6994:      char *nameend;
        -: 6995:      const struct option *p;
        -: 6996:      const struct option *pfound = NULL;
        -: 6997:      int exact = 0;
        -: 6998:      int ambig = 0;
        -: 6999:      int indfound = -1;
        -: 7000:      int option_index;
        -: 7001:
        -: 7002:      for (nameend = nextchar; *nameend && *nameend != '='; nameend++)
        -: 7003:	/* Do nothing.  */ ;
        -: 7004:
        -: 7005:      /* Test all long options for either exact match
        -: 7006:	 or abbreviated matches.  */
        -: 7007:      for (p = longopts, option_index = 0; p->name; p++, option_index++)
        -: 7008:	if (!strncmp (p->name, nextchar, nameend - nextchar))
        -: 7009:	  {
        -: 7010:	    if ((unsigned int) (nameend - nextchar)
        -: 7011:		== (unsigned int) strlen (p->name))
        -: 7012:	      {
        -: 7013:		/* Exact match found.  */
        -: 7014:		pfound = p;
        -: 7015:		indfound = option_index;
        -: 7016:		exact = 1;
        -: 7017:		break;
        -: 7018:	      }
        -: 7019:	    else if (pfound == NULL)
        -: 7020:	      {
        -: 7021:		/* First nonexact match found.  */
        -: 7022:		pfound = p;
        -: 7023:		indfound = option_index;
        -: 7024:	      }
        -: 7025:	    else
        -: 7026:	      /* Second or later nonexact match found.  */
        -: 7027:	      ambig = 1;
        -: 7028:	  }
        -: 7029:
        -: 7030:      if (ambig && !exact)
        -: 7031:	{
        -: 7032:	  if (opterr)
        -: 7033:	    fprintf (stderr, _("%s: option `%s' is ambiguous\n"),
        -: 7034:		     argv[0], argv[optind]);
        -: 7035:	  nextchar += strlen (nextchar);
        -: 7036:	  optind++;
        -: 7037:	  optopt = 0;
        -: 7038:	  return '?';
        -: 7039:	}
        -: 7040:
        -: 7041:      if (pfound != NULL)
        -: 7042:	{
        -: 7043:	  option_index = indfound;
        -: 7044:	  optind++;
        -: 7045:	  if (*nameend)
        -: 7046:	    {
        -: 7047:	      /* Don't test has_arg with >, because some C compilers don't
        -: 7048:		 allow it to be used on enums.  */
        -: 7049:	      if (pfound->has_arg)
        -: 7050:		optarg = nameend + 1;
        -: 7051:	      else
        -: 7052:		{
        -: 7053:		  if (opterr)
        -: 7054:		   if (argv[optind - 1][1] == '-')
        -: 7055:		    /* --option */
        -: 7056:		    fprintf (stderr,
        -: 7057:		     _("%s: option `--%s' doesn't allow an argument\n"),
        -: 7058:		     argv[0], pfound->name);
        -: 7059:		   else
        -: 7060:		    /* +option or -option */
        -: 7061:		    fprintf (stderr,
        -: 7062:		     _("%s: option `%c%s' doesn't allow an argument\n"),
        -: 7063:		     argv[0], argv[optind - 1][0], pfound->name);
        -: 7064:
        -: 7065:		  nextchar += strlen (nextchar);
        -: 7066:
        -: 7067:		  optopt = pfound->val;
        -: 7068:		  return '?';
        -: 7069:		}
        -: 7070:	    }
        -: 7071:	  else if (pfound->has_arg == 1)
        -: 7072:	    {
        -: 7073:	      if (optind < argc)
        -: 7074:		optarg = argv[optind++];
        -: 7075:	      else
        -: 7076:		{
        -: 7077:		  if (opterr)
        -: 7078:		    fprintf (stderr,
        -: 7079:			   _("%s: option `%s' requires an argument\n"),
        -: 7080:			   argv[0], argv[optind - 1]);
        -: 7081:		  nextchar += strlen (nextchar);
        -: 7082:		  optopt = pfound->val;
        -: 7083:		  return optstring[0] == ':' ? ':' : '?';
        -: 7084:		}
        -: 7085:	    }
        -: 7086:	  nextchar += strlen (nextchar);
        -: 7087:	  if (longind != NULL)
        -: 7088:	    *longind = option_index;
        -: 7089:	  if (pfound->flag)
        -: 7090:	    {
        -: 7091:	      *(pfound->flag) = pfound->val;
        -: 7092:	      return 0;
        -: 7093:	    }
        -: 7094:	  return pfound->val;
        -: 7095:	}
        -: 7096:
        -: 7097:      /* Can't find it as a long option.  If this is not getopt_long_only,
        -: 7098:	 or the option starts with '--' or is not a valid short
        -: 7099:	 option, then it's an error.
        -: 7100:	 Otherwise interpret it as a short option.  */
        -: 7101:      if (!long_only || argv[optind][1] == '-'
        -: 7102:	  || my_index (optstring, *nextchar) == NULL)
        -: 7103:	{
        -: 7104:	  if (opterr)
        -: 7105:	    {
        -: 7106:	      if (argv[optind][1] == '-')
        -: 7107:		/* --option */
        -: 7108:		fprintf (stderr, _("%s: unrecognized option `--%s'\n"),
        -: 7109:			 argv[0], nextchar);
        -: 7110:	      else
        -: 7111:		/* +option or -option */
        -: 7112:		fprintf (stderr, _("%s: unrecognized option `%c%s'\n"),
        -: 7113:			 argv[0], argv[optind][0], nextchar);
        -: 7114:	    }
        -: 7115:	  nextchar = (char *) "";
        -: 7116:	  optind++;
        -: 7117:	  optopt = 0;
        -: 7118:	  return '?';
        -: 7119:	}
        -: 7120:    }
        -: 7121:
        -: 7122:  /* Look at and handle the next short option-character.  */
        -: 7123:
        -: 7124:  {
        -: 7125:    char c = *nextchar++;
        -: 7126:    char *temp = my_index (optstring, c);
        -: 7127:
        -: 7128:    /* Increment `optind' when we start to process its last character.  */
        -: 7129:    if (*nextchar == '\0')
        -: 7130:      ++optind;
        -: 7131:
        -: 7132:    if (temp == NULL || c == ':')
        -: 7133:      {
        -: 7134:	if (opterr)
        -: 7135:	  {
        -: 7136:	    if (posixly_correct)
        -: 7137:	      /* 1003.2 specifies the format of this message.  */
        -: 7138:	      fprintf (stderr, _("%s: illegal option -- %c\n"),
        -: 7139:		       argv[0], c);
        -: 7140:	    else
        -: 7141:	      fprintf (stderr, _("%s: invalid option -- %c\n"),
        -: 7142:		       argv[0], c);
        -: 7143:	  }
        -: 7144:	optopt = c;
        -: 7145:	return '?';
        -: 7146:      }
        -: 7147:    /* Convenience. Treat POSIX -W foo same as long option --foo */
        -: 7148:    if (temp[0] == 'W' && temp[1] == ';')
        -: 7149:      {
        -: 7150:	char *nameend;
        -: 7151:	const struct option *p;
        -: 7152:	const struct option *pfound = NULL;
        -: 7153:	int exact = 0;
        -: 7154:	int ambig = 0;
        -: 7155:	int indfound = 0;
        -: 7156:	int option_index;
        -: 7157:
        -: 7158:	/* This is an option that requires an argument.  */
        -: 7159:	if (*nextchar != '\0')
        -: 7160:	  {
        -: 7161:	    optarg = nextchar;
        -: 7162:	    /* If we end this ARGV-element by taking the rest as an arg,
        -: 7163:	       we must advance to the next element now.  */
        -: 7164:	    optind++;
        -: 7165:	  }
        -: 7166:	else if (optind == argc)
        -: 7167:	  {
        -: 7168:	    if (opterr)
        -: 7169:	      {
        -: 7170:		/* 1003.2 specifies the format of this message.  */
        -: 7171:		fprintf (stderr, _("%s: option requires an argument -- %c\n"),
        -: 7172:			 argv[0], c);
        -: 7173:	      }
        -: 7174:	    optopt = c;
        -: 7175:	    if (optstring[0] == ':')
        -: 7176:	      c = ':';
        -: 7177:	    else
        -: 7178:	      c = '?';
        -: 7179:	    return c;
        -: 7180:	  }
        -: 7181:	else
        -: 7182:	  /* We already incremented `optind' once;
        -: 7183:	     increment it again when taking next ARGV-elt as argument.  */
        -: 7184:	  optarg = argv[optind++];
        -: 7185:
        -: 7186:	/* optarg is now the argument, see if it's in the
        -: 7187:	   table of longopts.  */
        -: 7188:
        -: 7189:	for (nextchar = nameend = optarg; *nameend && *nameend != '='; nameend++)
        -: 7190:	  /* Do nothing.  */ ;
        -: 7191:
        -: 7192:	/* Test all long options for either exact match
        -: 7193:	   or abbreviated matches.  */
        -: 7194:	for (p = longopts, option_index = 0; p->name; p++, option_index++)
        -: 7195:	  if (!strncmp (p->name, nextchar, nameend - nextchar))
        -: 7196:	    {
        -: 7197:	      if ((unsigned int) (nameend - nextchar) == strlen (p->name))
        -: 7198:		{
        -: 7199:		  /* Exact match found.  */
        -: 7200:		  pfound = p;
        -: 7201:		  indfound = option_index;
        -: 7202:		  exact = 1;
        -: 7203:		  break;
        -: 7204:		}
        -: 7205:	      else if (pfound == NULL)
        -: 7206:		{
        -: 7207:		  /* First nonexact match found.  */
        -: 7208:		  pfound = p;
        -: 7209:		  indfound = option_index;
        -: 7210:		}
        -: 7211:	      else
        -: 7212:		/* Second or later nonexact match found.  */
        -: 7213:		ambig = 1;
        -: 7214:	    }
        -: 7215:	if (ambig && !exact)
        -: 7216:	  {
        -: 7217:	    if (opterr)
        -: 7218:	      fprintf (stderr, _("%s: option `-W %s' is ambiguous\n"),
        -: 7219:		       argv[0], argv[optind]);
        -: 7220:	    nextchar += strlen (nextchar);
        -: 7221:	    optind++;
        -: 7222:	    return '?';
        -: 7223:	  }
        -: 7224:	if (pfound != NULL)
        -: 7225:	  {
        -: 7226:	    option_index = indfound;
        -: 7227:	    if (*nameend)
        -: 7228:	      {
        -: 7229:		/* Don't test has_arg with >, because some C compilers don't
        -: 7230:		   allow it to be used on enums.  */
        -: 7231:		if (pfound->has_arg)
        -: 7232:		  optarg = nameend + 1;
        -: 7233:		else
        -: 7234:		  {
        -: 7235:		    if (opterr)
        -: 7236:		      fprintf (stderr, _("\
        -: 7237:%s: option `-W %s' doesn't allow an argument\n"),
        -: 7238:			       argv[0], pfound->name);
        -: 7239:
        -: 7240:		    nextchar += strlen (nextchar);
        -: 7241:		    return '?';
        -: 7242:		  }
        -: 7243:	      }
        -: 7244:	    else if (pfound->has_arg == 1)
        -: 7245:	      {
        -: 7246:		if (optind < argc)
        -: 7247:		  optarg = argv[optind++];
        -: 7248:		else
        -: 7249:		  {
        -: 7250:		    if (opterr)
        -: 7251:		      fprintf (stderr,
        -: 7252:			       _("%s: option `%s' requires an argument\n"),
        -: 7253:			       argv[0], argv[optind - 1]);
        -: 7254:		    nextchar += strlen (nextchar);
        -: 7255:		    return optstring[0] == ':' ? ':' : '?';
        -: 7256:		  }
        -: 7257:	      }
        -: 7258:	    nextchar += strlen (nextchar);
        -: 7259:	    if (longind != NULL)
        -: 7260:	      *longind = option_index;
        -: 7261:	    if (pfound->flag)
        -: 7262:	      {
        -: 7263:		*(pfound->flag) = pfound->val;
        -: 7264:		return 0;
        -: 7265:	      }
        -: 7266:	    return pfound->val;
        -: 7267:	  }
        -: 7268:	  nextchar = NULL;
        -: 7269:	  return 'W';	/* Let the application handle it.   */
        -: 7270:      }
        -: 7271:    if (temp[1] == ':')
        -: 7272:      {
        -: 7273:	if (temp[2] == ':')
        -: 7274:	  {
        -: 7275:	    /* This is an option that accepts an argument optionally.  */
        -: 7276:	    if (*nextchar != '\0')
        -: 7277:	      {
        -: 7278:		optarg = nextchar;
        -: 7279:		optind++;
        -: 7280:	      }
        -: 7281:	    else
        -: 7282:	      optarg = NULL;
        -: 7283:	    nextchar = NULL;
        -: 7284:	  }
        -: 7285:	else
        -: 7286:	  {
        -: 7287:	    /* This is an option that requires an argument.  */
        -: 7288:	    if (*nextchar != '\0')
        -: 7289:	      {
        -: 7290:		optarg = nextchar;
        -: 7291:		/* If we end this ARGV-element by taking the rest as an arg,
        -: 7292:		   we must advance to the next element now.  */
        -: 7293:		optind++;
        -: 7294:	      }
        -: 7295:	    else if (optind == argc)
        -: 7296:	      {
        -: 7297:		if (opterr)
        -: 7298:		  {
        -: 7299:		    /* 1003.2 specifies the format of this message.  */
        -: 7300:		    fprintf (stderr,
        -: 7301:			   _("%s: option requires an argument -- %c\n"),
        -: 7302:			   argv[0], c);
        -: 7303:		  }
        -: 7304:		optopt = c;
        -: 7305:		if (optstring[0] == ':')
        -: 7306:		  c = ':';
        -: 7307:		else
        -: 7308:		  c = '?';
        -: 7309:	      }
        -: 7310:	    else
        -: 7311:	      /* We already incremented `optind' once;
        -: 7312:		 increment it again when taking next ARGV-elt as argument.  */
        -: 7313:	      optarg = argv[optind++];
        -: 7314:	    nextchar = NULL;
        -: 7315:	  }
        -: 7316:      }
        -: 7317:    return c;
        -: 7318:  }
        -: 7319:}
        -: 7320:
        -: 7321:int
        -: 7322:getopt (argc, argv, optstring)
        -: 7323:     int argc;
        -: 7324:     char *const *argv;
        -: 7325:     const char *optstring;
        -: 7326:{
        -: 7327:  return _getopt_internal (argc, argv, optstring,
        -: 7328:			   (const struct option *) 0,
        -: 7329:			   (int *) 0,
        -: 7330:			   0);
        -: 7331:}
        -: 7332:
        -: 7333:#endif	/* Not ELIDE_CODE.  */
        -: 7334:
        -: 7335:#ifdef TEST
        -: 7336:
        -: 7337:/* Compile with -DTEST to make an executable for use in testing
        -: 7338:   the above definition of `getopt'.  */
        -: 7339:
        -: 7340:int
        -: 7341:main (argc, argv)
        -: 7342:     int argc;
        -: 7343:     char **argv;
        -: 7344:{
        -: 7345:  int c;
        -: 7346:  int digit_optind = 0;
        -: 7347:
        -: 7348:  while (1)
        -: 7349:    {
        -: 7350:      int this_option_optind = optind ? optind : 1;
        -: 7351:
        -: 7352:      c = getopt (argc, argv, "abc:d:0123456789");
        -: 7353:      if (c == -1)
        -: 7354:	break;
        -: 7355:
        -: 7356:      switch (c)
        -: 7357:	{
        -: 7358:	case '0':
        -: 7359:	case '1':
        -: 7360:	case '2':
        -: 7361:	case '3':
        -: 7362:	case '4':
        -: 7363:	case '5':
        -: 7364:	case '6':
        -: 7365:	case '7':
        -: 7366:	case '8':
        -: 7367:	case '9':
        -: 7368:	  if (digit_optind != 0 && digit_optind != this_option_optind)
        -: 7369:	    printf ("digits occur in two different argv-elements.\n");
        -: 7370:	  digit_optind = this_option_optind;
        -: 7371:	  printf ("option %c\n", c);
        -: 7372:	  break;
        -: 7373:
        -: 7374:	case 'a':
        -: 7375:	  printf ("option a\n");
        -: 7376:	  break;
        -: 7377:
        -: 7378:	case 'b':
        -: 7379:	  printf ("option b\n");
        -: 7380:	  break;
        -: 7381:
        -: 7382:	case 'c':
        -: 7383:	  printf ("option c with value `%s'\n", optarg);
        -: 7384:	  break;
        -: 7385:
        -: 7386:	case '?':
        -: 7387:	  break;
        -: 7388:
        -: 7389:	default:
        -: 7390:	  printf ("?? getopt returned character code 0%o ??\n", c);
        -: 7391:	}
        -: 7392:    }
        -: 7393:
        -: 7394:  if (optind < argc)
        -: 7395:    {
        -: 7396:      printf ("non-option ARGV-elements: ");
        -: 7397:      while (optind < argc)
        -: 7398:	printf ("%s ", argv[optind++]);
        -: 7399:      printf ("\n");
        -: 7400:    }
        -: 7401:
        -: 7402:  exit (0);
        -: 7403:}
        -: 7404:
        -: 7405:#endif /* TEST */
        -: 7406:
        -: 7407:
        -: 7408:
        -: 7409:/*************************************************************
        -: 7410:  ============================================================
        -: 7411:  ************************************************************
        -: 7412:  ============================================================
        -: 7413:  ************************************************************
        -: 7414:                         implicit.c
        -: 7415:  ************************************************************
        -: 7416:  ============================================================
        -: 7417:  ************************************************************
        -: 7418:  ============================================================
        -: 7419:  *************************************************************/
        -: 7420:
        -: 7421:/* Implicit rule searching for GNU Make.
        -: 7422:Copyright (C) 1988,89,90,91,92,93,94,97 Free Software Foundation, Inc.
        -: 7423:This file is part of GNU Make.
        -: 7424:
        -: 7425:GNU Make is free software; you can redistribute it and/or modify
        -: 7426:it under the terms of the GNU General Public License as published by
        -: 7427:the Free Software Foundation; either version 2, or (at your option)
        -: 7428:any later version.
        -: 7429:
        -: 7430:GNU Make is distributed in the hope that it will be useful,
        -: 7431:but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 7432:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 7433:GNU General Public License for more details.
        -: 7434:
        -: 7435:You should have received a copy of the GNU General Public License
        -: 7436:along with GNU Make; see the file COPYING.  If not, write to
        -: 7437:the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
        -: 7438:Boston, MA 02111-1307, USA.  */
        -: 7439:
        -: 7440:/* #include "make.h"  <- modification by J.Ruthruff, 7/28 */
        -: 7441:/* #include "rule.h"  <- modification by J.Ruthruff, 7/28 */
        -: 7442:/* #include "dep.h"  <- modification by J.Ruthruff, 7/28 */
        -: 7443:/* #include "filedef.h"  <- modification by J.Ruthruff, 7/28 */
        -: 7444:#include "debug.h"
        -: 7445:#undef stderr
        -: 7446:#define stderr stdout
        -: 7447:
        -: 7448:static int pattern_search PARAMS ((struct file *file, int archive, unsigned int depth,
        -: 7449:		unsigned int recursions));
        -: 7450:
        -: 7451:/* For a FILE which has no commands specified, try to figure out some
        -: 7452:   from the implicit pattern rules.
        -: 7453:   Returns 1 if a suitable implicit rule was found,
        -: 7454:   after modifying FILE to contain the appropriate commands and deps,
        -: 7455:   or returns 0 if no implicit rule was found.  */
        -: 7456:
        -: 7457:int
function try_implicit_rule called 1 returned 100% blocks executed 56%
        1: 7458:try_implicit_rule (file, depth)
        -: 7459:     struct file *file;
        -: 7460:     unsigned int depth;
        -: 7461:{
        1: 7462:  DBF (DB_IMPLICIT, _("Looking for an implicit rule for `%s'.\n"));
branch  0 taken 1 (fallthrough)
branch  1 taken 0
call    2 returned 1
call    3 returned 1
call    4 returned 1
        -: 7463:
        -: 7464:  /* The order of these searches was previously reversed.  My logic now is
        -: 7465:     that since the non-archive search uses more information in the target
        -: 7466:     (the archive search omits the archive name), it is more specific and
        -: 7467:     should come first.  */
        -: 7468:
        1: 7469:  if (pattern_search (file, 0, depth, 0))
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
    #####: 7470:    return 1;
        -: 7471:
        -: 7472:#ifndef	NO_ARCHIVES
        -: 7473:  /* If this is an archive member reference, use just the
        -: 7474:     archive member name to search for implicit rules.  */
        1: 7475:  if (ar_name (file->name))
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
        -: 7476:    {
    #####: 7477:      DBF (DB_IMPLICIT,
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -: 7478:           _("Looking for archive-member implicit rule for `%s'.\n"));
    #####: 7479:      if (pattern_search (file, 1, depth, 0))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 7480:	return 1;
        -: 7481:    }
        -: 7482:#endif
        -: 7483:
        1: 7484:  return 0;
        -: 7485:}
        -: 7486:
        -: 7487:
        -: 7488:/* Search the pattern rules for a rule with an existing dependency to make
        -: 7489:   FILE.  If a rule is found, the appropriate commands and deps are put in FILE
        -: 7490:   and 1 is returned.  If not, 0 is returned.
        -: 7491:
        -: 7492:   If ARCHIVE is nonzero, FILE->name is of the form "LIB(MEMBER)".  A rule for
        -: 7493:   "(MEMBER)" will be searched for, and "(MEMBER)" will not be chopped up into
        -: 7494:   directory and filename parts.
        -: 7495:
        -: 7496:   If an intermediate file is found by pattern search, the intermediate file
        -: 7497:   is set up as a target by the recursive call and is also made a dependency
        -: 7498:   of FILE.
        -: 7499:
        -: 7500:   DEPTH is used for debugging messages.  */
        -: 7501:
        -: 7502:static int
function pattern_search called 18 returned 100% blocks executed 61%
       18: 7503:pattern_search (file, archive, depth, recursions)
        -: 7504:     struct file *file;
        -: 7505:     int archive;
        -: 7506:     unsigned int depth;
        -: 7507:     unsigned int recursions;
        -: 7508:{
        -: 7509:  /* Filename we are searching for a rule for.  */
      18*: 7510:  char *filename = archive ? strchr (file->name, '(') : file->name;
branch  0 taken 0 (fallthrough)
branch  1 taken 18
        -: 7511:
        -: 7512:  /* Length of FILENAME.  */
       18: 7513:  unsigned int namelen = strlen (filename);
        -: 7514:
        -: 7515:  /* The last slash in FILENAME (or nil if there is none).  */
        -: 7516:  char *lastslash;
        -: 7517:
        -: 7518:  /* This is a file-object used as an argument in
        -: 7519:     recursive calls.  It never contains any data
        -: 7520:     except during a recursive call.  */
       18: 7521:  struct file *intermediate_file = 0;
        -: 7522:
        -: 7523:  /* List of dependencies found recursively.  */
        -: 7524:  struct file **intermediate_files
       18: 7525:    = (struct file **) alloca (max_pattern_deps * sizeof (struct file *));
        -: 7526:
        -: 7527:  /* List of the patterns used to find intermediate files.  */
        -: 7528:  char **intermediate_patterns
       18: 7529:    = (char **) alloca (max_pattern_deps * sizeof (char *));
        -: 7530:
        -: 7531:  /* This buffer records all the dependencies actually found for a rule.  */
       18: 7532:  char **found_files = (char **) alloca (max_pattern_deps * sizeof (char *));
        -: 7533:  /* Number of dep names now in FOUND_FILES.  */
       18: 7534:  unsigned int deps_found = 0;
        -: 7535:
        -: 7536:  /* Names of possible dependencies are constructed in this buffer.  */
       18: 7537:  register char *depname = (char *) alloca (namelen + max_pattern_dep_length);
        -: 7538:
        -: 7539:  /* The start and length of the stem of FILENAME for the current rule.  */
       18: 7540:  register char *stem = 0;
       18: 7541:  register unsigned int stemlen = 0;
        -: 7542:
        -: 7543:  /* Buffer in which we store all the rules that are possibly applicable.  */
        -: 7544:  struct rule **tryrules
       18: 7545:    = (struct rule **) alloca (num_pattern_rules * max_pattern_targets
        -: 7546:			       * sizeof (struct rule *));
        -: 7547:
        -: 7548:  /* Number of valid elements in TRYRULES.  */
        -: 7549:  unsigned int nrules;
        -: 7550:
        -: 7551:  /* The numbers of the rule targets of each rule
        -: 7552:     in TRYRULES that matched the target file.  */
        -: 7553:  unsigned int *matches
       18: 7554:    = (unsigned int *) alloca (num_pattern_rules * sizeof (unsigned int));
        -: 7555:
        -: 7556:  /* Each element is nonzero if LASTSLASH was used in
        -: 7557:     matching the corresponding element of TRYRULES.  */
        -: 7558:  char *checked_lastslash
       18: 7559:    = (char *) alloca (num_pattern_rules * sizeof (char));
        -: 7560:
        -: 7561:  /* The index in TRYRULES of the rule we found.  */
        -: 7562:  unsigned int foundrule;
        -: 7563:
        -: 7564:  /* Nonzero if should consider intermediate files as dependencies.  */
        -: 7565:  int intermed_ok;
        -: 7566:
        -: 7567:  /* Nonzero if we have matched a pattern-rule target
        -: 7568:     that is not just `%'.  */
       18: 7569:  int specific_rule_matched = 0;
        -: 7570:
       18: 7571:  register unsigned int i = 0;  /* uninit checks OK */
        -: 7572:  register struct rule *rule;
        -: 7573:  register struct dep *dep;
        -: 7574:
        -: 7575:  char *p, *vp;
        -: 7576:
        -: 7577:#ifndef	NO_ARCHIVES
       18: 7578:  if (archive || ar_name (filename))
branch  0 taken 18 (fallthrough)
branch  1 taken 0
call    2 returned 18
branch  3 taken 0 (fallthrough)
branch  4 taken 18
    #####: 7579:    lastslash = 0;
        -: 7580:  else
        -: 7581:#endif
        -: 7582:    {
        -: 7583:      /* Set LASTSLASH to point at the last slash in FILENAME
        -: 7584:	 but not counting any slash at the end.  (foo/bar/ counts as
        -: 7585:	 bar/ in directory foo/, not empty in directory foo/bar/.)  */
        -: 7586:#ifdef VMS
        -: 7587:      lastslash = strrchr (filename, ']');
        -: 7588:      if (lastslash == 0)
        -: 7589:	lastslash = strrchr (filename, ':');
        -: 7590:#else
       18: 7591:      lastslash = strrchr (filename, '/');
        -: 7592:#if defined(__MSDOS__) || defined(WINDOWS32)
        -: 7593:      /* Handle backslashes (possibly mixed with forward slashes)
        -: 7594:	 and the case of "d:file".  */
        -: 7595:      {
        -: 7596:	char *bslash = strrchr (filename, '\\');
        -: 7597:	if (lastslash == 0 || bslash > lastslash)
        -: 7598:	  lastslash = bslash;
        -: 7599:	if (lastslash == 0 && filename[0] && filename[1] == ':')
        -: 7600:	  lastslash = filename + 1;
        -: 7601:      }
        -: 7602:#endif
        -: 7603:#endif
       18: 7604:      if (lastslash != 0 && lastslash[1] == '\0')
branch  0 taken 18 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 18
    #####: 7605:	lastslash = 0;
        -: 7606:    }
        -: 7607:
        -: 7608:  /* First see which pattern rules match this target
        -: 7609:     and may be considered.  Put them in TRYRULES.  */
        -: 7610:
       18: 7611:  nrules = 0;
     1566: 7612:  for (rule = pattern_rules; rule != 0; rule = rule->next)
branch  0 taken 1548
branch  1 taken 18 (fallthrough)
        -: 7613:    {
        -: 7614:      /* If the pattern rule has deps but no commands, ignore it.
        -: 7615:	 Users cancel built-in rules by redefining them without commands.  */
    1548*: 7616:      if (rule->deps != 0 && rule->cmds == 0)
branch  0 taken 972 (fallthrough)
branch  1 taken 576
branch  2 taken 0 (fallthrough)
branch  3 taken 972
    #####: 7617:	continue;
        -: 7618:
        -: 7619:      /* If this rule is in use by a parent pattern_search,
        -: 7620:	 don't use it here.  */
     1548: 7621:      if (rule->in_use)
branch  0 taken 39 (fallthrough)
branch  1 taken 1509
        -: 7622:	{
       39: 7623:	  DBS (DB_IMPLICIT, (_("Avoiding implicit rule recursion.\n")));
branch  0 taken 39 (fallthrough)
branch  1 taken 0
call    2 returned 39
call    3 returned 39
call    4 returned 39
       39: 7624:	  continue;
        -: 7625:	}
        -: 7626:
     3018: 7627:      for (i = 0; rule->targets[i] != 0; ++i)
branch  0 taken 1509
branch  1 taken 1509 (fallthrough)
        -: 7628:	{
     1509: 7629:	  char *target = rule->targets[i];
     1509: 7630:	  char *suffix = rule->suffixes[i];
        -: 7631:	  int check_lastslash;
        -: 7632:
        -: 7633:	  /* Rules that can match any filename and are not terminal
        -: 7634:	     are ignored if we're recursing, so that they cannot be
        -: 7635:	     intermediate files.  */
     1509: 7636:	  if (recursions > 0 && target[1] == '\0' && !rule->terminal)
branch  0 taken 1423 (fallthrough)
branch  1 taken 86
branch  2 taken 289 (fallthrough)
branch  3 taken 1134
branch  4 taken 204 (fallthrough)
branch  5 taken 85
      204: 7637:	    continue;
        -: 7638:
    1305*: 7639:	  if (rule->lens[i] > namelen)
branch  0 taken 0 (fallthrough)
branch  1 taken 1305
        -: 7640:	    /* It can't possibly match.  */
    #####: 7641:	    continue;
        -: 7642:
        -: 7643:	  /* From the lengths of the filename and the pattern parts,
        -: 7644:	     find the stem: the part of the filename that matches the %.  */
     1305: 7645:	  stem = filename + (suffix - target - 1);
     1305: 7646:	  stemlen = namelen - rule->lens[i] + 1;
        -: 7647:
        -: 7648:	  /* Set CHECK_LASTSLASH if FILENAME contains a directory
        -: 7649:	     prefix and the target pattern does not contain a slash.  */
        -: 7650:
        -: 7651:#ifdef VMS
        -: 7652:	  check_lastslash = lastslash != 0
        -: 7653:			    && ((strchr (target, ']') == 0)
        -: 7654:			        && (strchr (target, ':') == 0));
        -: 7655:#else
    1305*: 7656:	  check_lastslash = lastslash != 0 && strchr (target, '/') == 0;
branch  0 taken 1305 (fallthrough)
branch  1 taken 0
branch  2 taken 1305 (fallthrough)
branch  3 taken 0
        -: 7657:#endif
     1305: 7658:	  if (check_lastslash)
branch  0 taken 1305 (fallthrough)
branch  1 taken 0
        -: 7659:	    {
        -: 7660:	      /* In that case, don't include the
        -: 7661:		 directory prefix in STEM here.  */
     1305: 7662:	      unsigned int difference = lastslash - filename + 1;
    1305*: 7663:	      if (difference > stemlen)
branch  0 taken 0 (fallthrough)
branch  1 taken 1305
    #####: 7664:		continue;
     1305: 7665:	      stemlen -= difference;
     1305: 7666:	      stem += difference;
        -: 7667:	    }
        -: 7668:
        -: 7669:	  /* Check that the rule pattern matches the text before the stem.  */
     1305: 7670:	  if (check_lastslash)
branch  0 taken 1305 (fallthrough)
branch  1 taken 0
        -: 7671:	    {
     1305: 7672:	      if (stem > (lastslash + 1)
branch  0 taken 18 (fallthrough)
branch  1 taken 1287
       18: 7673:		  && !strneq (target, lastslash + 1, stem - lastslash - 1))
branch  0 taken 18 (fallthrough)
branch  1 taken 0
       18: 7674:		continue;
        -: 7675:	    }
    #####: 7676:	  else if (stem > filename
branch  0 never executed
branch  1 never executed
    #####: 7677:		   && !strneq (target, filename, stem - filename))
branch  0 never executed
branch  1 never executed
    #####: 7678:	    continue;
        -: 7679:
        -: 7680:	  /* Check that the rule pattern matches the text after the stem.
        -: 7681:	     We could test simply use streq, but this way we compare the
        -: 7682:	     first two characters immediately.  This saves time in the very
        -: 7683:	     common case where the first character matches because it is a
        -: 7684:	     period.  */
     1287: 7685:	  if (*suffix != stem[stemlen]
branch  0 taken 564 (fallthrough)
branch  1 taken 723
      564: 7686:	      || (*suffix != '\0' && !streq (&suffix[1], &stem[stemlen + 1])))
branch  0 taken 461 (fallthrough)
branch  1 taken 103
branch  2 taken 461 (fallthrough)
branch  3 taken 0
branch  4 taken 38 (fallthrough)
branch  5 taken 423
branch  6 taken 38 (fallthrough)
branch  7 taken 0
branch  8 taken 1 (fallthrough)
branch  9 taken 37
     1147: 7687:	    continue;
        -: 7688:
        -: 7689:	  /* Record if we match a rule that not all filenames will match.  */
      140: 7690:	  if (target[1] != '\0')
branch  0 taken 37 (fallthrough)
branch  1 taken 103
       37: 7691:	    specific_rule_matched = 1;
        -: 7692:
        -: 7693:	  /* A rule with no dependencies and no commands exists solely to set
        -: 7694:	     specific_rule_matched when it matches.  Don't try to use it.  */
      140: 7695:	  if (rule->deps == 0 && rule->cmds == 0)
branch  0 taken 17 (fallthrough)
branch  1 taken 123
branch  2 taken 17 (fallthrough)
branch  3 taken 0
       17: 7696:	    continue;
        -: 7697:
        -: 7698:	  /* Record this rule in TRYRULES and the index of the matching
        -: 7699:	     target in MATCHES.  If several targets of the same rule match,
        -: 7700:	     that rule will be in TRYRULES more than once.  */
      123: 7701:	  tryrules[nrules] = rule;
      123: 7702:	  matches[nrules] = i;
      123: 7703:	  checked_lastslash[nrules] = check_lastslash;
      123: 7704:	  ++nrules;
        -: 7705:	}
        -: 7706:    }
        -: 7707:
        -: 7708:  /* If we have found a matching rule that won't match all filenames,
        -: 7709:     retroactively reject any non-"terminal" rules that do always match.  */
       18: 7710:  if (specific_rule_matched)
branch  0 taken 17 (fallthrough)
branch  1 taken 1
      122: 7711:    for (i = 0; i < nrules; ++i)
branch  0 taken 105
branch  1 taken 17 (fallthrough)
      105: 7712:      if (!tryrules[i]->terminal)
branch  0 taken 20 (fallthrough)
branch  1 taken 85
        -: 7713:	{
        -: 7714:	  register unsigned int j;
       40: 7715:	  for (j = 0; tryrules[i]->targets[j] != 0; ++j)
branch  0 taken 20
branch  1 taken 20 (fallthrough)
       20: 7716:	    if (tryrules[i]->targets[j][1] == '\0')
branch  0 taken 0 (fallthrough)
branch  1 taken 20
    #####: 7717:	      break;
       20: 7718:	  if (tryrules[i]->targets[j] != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 20
    #####: 7719:	    tryrules[i] = 0;
        -: 7720:	}
        -: 7721:
        -: 7722:  /* Try each rule once without intermediate files, then once with them.  */
       54: 7723:  for (intermed_ok = 0; intermed_ok == !!intermed_ok; ++intermed_ok)
branch  0 taken 36
branch  1 taken 18 (fallthrough)
        -: 7724:    {
        -: 7725:      /* Try each pattern rule till we find one that applies.
        -: 7726:	 If it does, copy the names of its dependencies (as substituted)
        -: 7727:	 and store them in FOUND_FILES.  DEPS_FOUND is the number of them.  */
        -: 7728:
      282: 7729:      for (i = 0; i < nrules; i++)
branch  0 taken 246
branch  1 taken 36 (fallthrough)
        -: 7730:	{
        -: 7731:	  int check_lastslash;
        -: 7732:
      246: 7733:	  rule = tryrules[i];
        -: 7734:
        -: 7735:	  /* RULE is nil when we discover that a rule,
        -: 7736:	     already placed in TRYRULES, should not be applied.  */
      246: 7737:	  if (rule == 0)
branch  0 taken 1 (fallthrough)
branch  1 taken 245
        1: 7738:	    continue;
        -: 7739:
        -: 7740:	  /* Reject any terminal rules if we're
        -: 7741:	     looking to make intermediate files.  */
      245: 7742:	  if (intermed_ok && rule->terminal)
branch  0 taken 122 (fallthrough)
branch  1 taken 123
branch  2 taken 90 (fallthrough)
branch  3 taken 32
       90: 7743:	    continue;
        -: 7744:
        -: 7745:	  /* Mark this rule as in use so a recursive
        -: 7746:	     pattern_search won't try to use it.  */
      155: 7747:	  rule->in_use = 1;
        -: 7748:
        -: 7749:	  /* From the lengths of the filename and the matching pattern parts,
        -: 7750:	     find the stem: the part of the filename that matches the %.  */
      155: 7751:	  stem = filename
      155: 7752:	    + (rule->suffixes[matches[i]] - rule->targets[matches[i]]) - 1;
      155: 7753:	  stemlen = namelen - rule->lens[matches[i]] + 1;
      155: 7754:	  check_lastslash = checked_lastslash[i];
      155: 7755:	  if (check_lastslash)
branch  0 taken 155 (fallthrough)
branch  1 taken 0
        -: 7756:	    {
      155: 7757:	      stem += lastslash - filename + 1;
      155: 7758:	      stemlen -= (lastslash - filename) + 1;
        -: 7759:	    }
        -: 7760:
      155: 7761:	  DBS (DB_IMPLICIT, (_("Trying pattern rule with stem `%.*s'.\n"),
branch  0 taken 155 (fallthrough)
branch  1 taken 0
call    2 returned 155
call    3 returned 155
call    4 returned 155
        -: 7762:                             (int) stemlen, stem));
        -: 7763:
        -: 7764:	  /* Try each dependency; see if it "exists".  */
        -: 7765:
      155: 7766:	  deps_found = 0;
     155*: 7767:	  for (dep = rule->deps; dep != 0; dep = dep->next)
branch  0 taken 155
branch  1 taken 0 (fallthrough)
        -: 7768:	    {
        -: 7769:	      /* If the dependency name has a %, substitute the stem.  */
     155*: 7770:	      p = strchr (dep_name (dep), '%');
branch  0 taken 0 (fallthrough)
branch  1 taken 155
      155: 7771:	      if (p != 0)
branch  0 taken 155 (fallthrough)
branch  1 taken 0
        -: 7772:		{
        -: 7773:		  register unsigned int i;
      155: 7774:		  if (check_lastslash)
branch  0 taken 155 (fallthrough)
branch  1 taken 0
        -: 7775:		    {
        -: 7776:		      /* Copy directory name from the original FILENAME.  */
      155: 7777:		      i = lastslash - filename + 1;
      155: 7778:		      bcopy (filename, depname, i);
        -: 7779:		    }
        -: 7780:		  else
    #####: 7781:		    i = 0;
     155*: 7782:		  bcopy (dep_name (dep), depname + i, p - dep_name (dep));
branch  0 taken 0 (fallthrough)
branch  1 taken 155
branch  2 taken 0 (fallthrough)
branch  3 taken 155
     155*: 7783:		  i += p - dep_name (dep);
branch  0 taken 0 (fallthrough)
branch  1 taken 155
      155: 7784:		  bcopy (stem, depname + i, stemlen);
      155: 7785:		  i += stemlen;
      155: 7786:		  strcpy (depname + i, p + 1);
      155: 7787:		  p = depname;
        -: 7788:		}
        -: 7789:	      else
    #####: 7790:		p = dep_name (dep);
branch  0 never executed
branch  1 never executed
        -: 7791:
        -: 7792:	      /* P is now the actual dependency name as substituted.  */
        -: 7793:
      155: 7794:	      if (file_impossible_p (p))
call    0 returned 155
branch  1 taken 16 (fallthrough)
branch  2 taken 139
        -: 7795:		{
        -: 7796:		  /* If this dependency has already been ruled
        -: 7797:		     "impossible", then the rule fails and don't
        -: 7798:		     bother trying it on the second pass either
        -: 7799:		     since we know that will fail too.  */
      16*: 7800:		  DBS (DB_IMPLICIT,
branch  0 taken 16 (fallthrough)
branch  1 taken 0
call    2 returned 16
branch  3 taken 16 (fallthrough)
branch  4 taken 0
call    5 returned 16
call    6 returned 16
        -: 7801:                       (p == depname
        -: 7802:                        ? _("Rejecting impossible implicit prerequisite `%s'.\n")
        -: 7803:                        : _("Rejecting impossible rule prerequisite `%s'.\n"),
        -: 7804:                        p));
       16: 7805:		  tryrules[i] = 0;
       16: 7806:		  break;
        -: 7807:		}
        -: 7808:
      139: 7809:	      intermediate_files[deps_found] = 0;
        -: 7810:
     139*: 7811:	      DBS (DB_IMPLICIT,
branch  0 taken 139 (fallthrough)
branch  1 taken 0
call    2 returned 139
branch  3 taken 139 (fallthrough)
branch  4 taken 0
call    5 returned 139
call    6 returned 139
        -: 7812:                   (p == depname
        -: 7813:                    ? _("Trying implicit prerequisite `%s'.\n")
        -: 7814:                    : _("Trying rule prerequisite `%s'.\n"), p));
        -: 7815:
        -: 7816:	      /* The DEP->changed flag says that this dependency resides in a
        -: 7817:		 nonexistent directory.  So we normally can skip looking for
        -: 7818:		 the file.  However, if CHECK_LASTSLASH is set, then the
        -: 7819:		 dependency file we are actually looking for is in a different
        -: 7820:		 directory (the one gotten by prepending FILENAME's directory),
        -: 7821:		 so it might actually exist.  */
        -: 7822:
     139*: 7823:	      if ((!dep->changed || check_lastslash)
branch  0 taken 54 (fallthrough)
branch  1 taken 85
branch  2 taken 54 (fallthrough)
branch  3 taken 0
      139: 7824:		  && (lookup_file (p) != 0 || file_exists_p (p)))
call    0 returned 139
branch  1 taken 139 (fallthrough)
branch  2 taken 0
call    3 returned 139
branch  4 taken 0 (fallthrough)
branch  5 taken 139
        -: 7825:		{
    #####: 7826:		  found_files[deps_found++] = xstrdup (p);
call    0 never executed
    #####: 7827:		  continue;
        -: 7828:		}
        -: 7829:	      /* This code, given FILENAME = "lib/foo.o", dependency name
        -: 7830:		 "lib/foo.c", and VPATH=src, searches for "src/lib/foo.c".  */
      139: 7831:	      vp = p;
     139*: 7832:	      if (vpath_search (&vp, (FILE_TIMESTAMP *) 0))
call    0 returned 139
branch  1 taken 0 (fallthrough)
branch  2 taken 139
        -: 7833:		{
    #####: 7834:		  DBS (DB_IMPLICIT,
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -: 7835:                       (_("Found prerequisite `%s' as VPATH `%s'\n"), p, vp));
    #####: 7836:		  strcpy (vp, p);
    #####: 7837:		  found_files[deps_found++] = vp;
    #####: 7838:		  continue;
        -: 7839:		}
        -: 7840:
        -: 7841:	      /* We could not find the file in any place we should look.
        -: 7842:		 Try to make this dependency as an intermediate file,
        -: 7843:		 but only on the second pass.  */
        -: 7844:
      139: 7845:	      if (intermed_ok)
branch  0 taken 17 (fallthrough)
branch  1 taken 122
        -: 7846:		{
       17: 7847:		  if (intermediate_file == 0)
branch  0 taken 6 (fallthrough)
branch  1 taken 11
        -: 7848:		    intermediate_file
        6: 7849:		      = (struct file *) alloca (sizeof (struct file));
        -: 7850:
       17: 7851:		  DBS (DB_IMPLICIT,
branch  0 taken 17 (fallthrough)
branch  1 taken 0
call    2 returned 17
call    3 returned 17
call    4 returned 17
        -: 7852:                       (_("Looking for a rule with intermediate file `%s'.\n"),
        -: 7853:                        p));
        -: 7854:
       17: 7855:		  bzero ((char *) intermediate_file, sizeof (struct file));
       17: 7856:		  intermediate_file->name = p;
      17*: 7857:		  if (pattern_search (intermediate_file, 0, depth + 1,
call    0 returned 17
branch  1 taken 0 (fallthrough)
branch  2 taken 17
        -: 7858:				      recursions + 1))
        -: 7859:		    {
    #####: 7860:		      p = xstrdup (p);
call    0 never executed
    #####: 7861:		      intermediate_patterns[deps_found]
    #####: 7862:			= intermediate_file->name;
    #####: 7863:		      intermediate_file->name = p;
    #####: 7864:		      intermediate_files[deps_found] = intermediate_file;
    #####: 7865:		      intermediate_file = 0;
        -: 7866:		      /* Allocate an extra copy to go in FOUND_FILES,
        -: 7867:			 because every elt of FOUND_FILES is consumed
        -: 7868:			 or freed later.  */
    #####: 7869:		      found_files[deps_found] = xstrdup (p);
call    0 never executed
    #####: 7870:		      ++deps_found;
    #####: 7871:		      continue;
        -: 7872:		    }
        -: 7873:
        -: 7874:		  /* If we have tried to find P as an intermediate
        -: 7875:		     file and failed, mark that name as impossible
        -: 7876:		     so we won't go through the search again later.  */
       17: 7877:		  file_impossible (p);
call    0 returned 17
        -: 7878:		}
        -: 7879:
        -: 7880:	      /* A dependency of this rule does not exist.
        -: 7881:		 Therefore, this rule fails.  */
      139: 7882:	      break;
        -: 7883:	    }
        -: 7884:
        -: 7885:	  /* This rule is no longer `in use' for recursive searches.  */
      155: 7886:	  rule->in_use = 0;
        -: 7887:
      155: 7888:	  if (dep != 0)
branch  0 taken 155 (fallthrough)
branch  1 taken 0
        -: 7889:	    {
        -: 7890:	      /* This pattern rule does not apply.
        -: 7891:		 If some of its dependencies succeeded,
        -: 7892:		 free the data structure describing them.  */
      155: 7893:	      while (deps_found-- > 0)
branch  0 taken 0
branch  1 taken 155
        -: 7894:		{
    #####: 7895:		  register struct file *f = intermediate_files[deps_found];
    #####: 7896:		  free (found_files[deps_found]);
    #####: 7897:		  if (f != 0
branch  0 never executed
branch  1 never executed
    #####: 7898:		      && (f->stem < f->name
branch  0 never executed
branch  1 never executed
    #####: 7899:			  || f->stem > f->name + strlen (f->name)))
branch  0 never executed
branch  1 never executed
    #####: 7900:		    free (f->stem);
        -: 7901:		}
        -: 7902:	    }
        -: 7903:	  else
        -: 7904:	    /* This pattern rule does apply.  Stop looking for one.  */
    #####: 7905:	    break;
        -: 7906:	}
        -: 7907:
        -: 7908:      /* If we found an applicable rule without
        -: 7909:	 intermediate files, don't try with them.  */
       36: 7910:      if (i < nrules)
branch  0 taken 0 (fallthrough)
branch  1 taken 36
    #####: 7911:	break;
        -: 7912:
       36: 7913:      rule = 0;
        -: 7914:    }
        -: 7915:
        -: 7916:  /* RULE is nil if the loop went all the way
        -: 7917:     through the list and everything failed.  */
       18: 7918:  if (rule == 0)
branch  0 taken 18 (fallthrough)
branch  1 taken 0
       18: 7919:    return 0;
        -: 7920:
    #####: 7921:  foundrule = i;
        -: 7922:
        -: 7923:  /* If we are recursing, store the pattern that matched
        -: 7924:     FILENAME in FILE->name for use in upper levels.  */
        -: 7925:
    #####: 7926:  if (recursions > 0)
branch  0 never executed
branch  1 never executed
        -: 7927:    /* Kludge-o-matic */
    #####: 7928:    file->name = rule->targets[matches[foundrule]];
        -: 7929:
        -: 7930:  /* FOUND_FILES lists the dependencies for the rule we found.
        -: 7931:     This includes the intermediate files, if any.
        -: 7932:     Convert them into entries on the deps-chain of FILE.  */
        -: 7933:
    #####: 7934:  while (deps_found-- > 0)
branch  0 never executed
branch  1 never executed
        -: 7935:    {
        -: 7936:      register char *s;
        -: 7937:
    #####: 7938:      if (intermediate_files[deps_found] != 0)
branch  0 never executed
branch  1 never executed
        -: 7939:	{
        -: 7940:	  /* If we need to use an intermediate file,
        -: 7941:	     make sure it is entered as a target, with the info that was
        -: 7942:	     found for it in the recursive pattern_search call.
        -: 7943:	     We know that the intermediate file did not already exist as
        -: 7944:	     a target; therefore we can assume that the deps and cmds
        -: 7945:	     of F below are null before we change them.  */
        -: 7946:
    #####: 7947:	  struct file *imf = intermediate_files[deps_found];
    #####: 7948:	  register struct file *f = enter_file (imf->name);
call    0 never executed
    #####: 7949:	  f->deps = imf->deps;
    #####: 7950:	  f->cmds = imf->cmds;
    #####: 7951:	  f->stem = imf->stem;
    #####: 7952:          f->also_make = imf->also_make;
    #####: 7953:	  imf = lookup_file (intermediate_patterns[deps_found]);
call    0 never executed
    #####: 7954:	  if (imf != 0 && imf->precious)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 7955:	    f->precious = 1;
    #####: 7956:	  f->intermediate = 1;
    #####: 7957:	  f->tried_implicit = 1;
    #####: 7958:	  for (dep = f->deps; dep != 0; dep = dep->next)
branch  0 never executed
branch  1 never executed
        -: 7959:	    {
    #####: 7960:	      dep->file = enter_file (dep->name);
call    0 never executed
        -: 7961:              /* enter_file uses dep->name _if_ we created a new file.  */
    #####: 7962:              if (dep->name != dep->file->name)
branch  0 never executed
branch  1 never executed
    #####: 7963:                free (dep->name);
    #####: 7964:	      dep->name = 0;
    #####: 7965:	      dep->file->tried_implicit |= dep->changed;
        -: 7966:	    }
    #####: 7967:	  num_intermediates++;
        -: 7968:	}
        -: 7969:
    #####: 7970:      dep = (struct dep *) xmalloc (sizeof (struct dep));
call    0 never executed
    #####: 7971:      s = found_files[deps_found];
    #####: 7972:      if (recursions == 0)
branch  0 never executed
branch  1 never executed
        -: 7973:	{
    #####: 7974:	  dep->name = 0;
    #####: 7975:	  dep->file = lookup_file (s);
call    0 never executed
    #####: 7976:	  if (dep->file == 0)
branch  0 never executed
branch  1 never executed
        -: 7977:	    /* enter_file consumes S's storage.  */
    #####: 7978:	    dep->file = enter_file (s);
call    0 never executed
        -: 7979:	  else
        -: 7980:	    /* A copy of S is already allocated in DEP->file->name.
        -: 7981:	       So we can free S.  */
    #####: 7982:	    free (s);
        -: 7983:	}
        -: 7984:      else
        -: 7985:	{
    #####: 7986:	  dep->name = s;
    #####: 7987:	  dep->file = 0;
    #####: 7988:	  dep->changed = 0;
        -: 7989:	}
    #####: 7990:      if (intermediate_files[deps_found] == 0 && tryrules[foundrule]->terminal)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 7991:	{
        -: 7992:	  /* If the file actually existed (was not an intermediate file),
        -: 7993:	     and the rule that found it was a terminal one, then we want
        -: 7994:	     to mark the found file so that it will not have implicit rule
        -: 7995:	     search done for it.  If we are not entering a `struct file' for
        -: 7996:	     it now, we indicate this with the `changed' flag.  */
    #####: 7997:	  if (dep->file == 0)
branch  0 never executed
branch  1 never executed
    #####: 7998:	    dep->changed = 1;
        -: 7999:	  else
    #####: 8000:	    dep->file->tried_implicit = 1;
        -: 8001:	}
    #####: 8002:      dep->next = file->deps;
    #####: 8003:      file->deps = dep;
        -: 8004:    }
        -: 8005:
    #####: 8006:  if (!checked_lastslash[foundrule])
branch  0 never executed
branch  1 never executed
        -: 8007:    /* Always allocate new storage, since STEM might be
        -: 8008:       on the stack for an intermediate file.  */
    #####: 8009:    file->stem = savestring (stem, stemlen);
call    0 never executed
        -: 8010:  else
        -: 8011:    {
        -: 8012:      /* We want to prepend the directory from
        -: 8013:	 the original FILENAME onto the stem.  */
    #####: 8014:      file->stem = (char *) xmalloc (((lastslash + 1) - filename)
    #####: 8015:				     + stemlen + 1);
call    0 never executed
    #####: 8016:      bcopy (filename, file->stem, (lastslash + 1) - filename);
    #####: 8017:      bcopy (stem, file->stem + ((lastslash + 1) - filename), stemlen);
    #####: 8018:      file->stem[((lastslash + 1) - filename) + stemlen] = '\0';
        -: 8019:    }
        -: 8020:
    #####: 8021:  file->cmds = rule->cmds;
        -: 8022:
        -: 8023:  /* If this rule builds other targets, too, put the others into FILE's
        -: 8024:     `also_make' member.  */
        -: 8025:
    #####: 8026:  if (rule->targets[1] != 0)
branch  0 never executed
branch  1 never executed
    #####: 8027:    for (i = 0; rule->targets[i] != 0; ++i)
branch  0 never executed
branch  1 never executed
    #####: 8028:      if (i != matches[foundrule])
branch  0 never executed
branch  1 never executed
        -: 8029:	{
    #####: 8030:	  struct dep *new = (struct dep *) xmalloc (sizeof (struct dep));
call    0 never executed
    #####: 8031:	  new->name = p = (char *) xmalloc (rule->lens[i] + stemlen + 1);
call    0 never executed
    #####: 8032:	  bcopy (rule->targets[i], p,
        -: 8033:		 rule->suffixes[i] - rule->targets[i] - 1);
    #####: 8034:	  p += rule->suffixes[i] - rule->targets[i] - 1;
    #####: 8035:	  bcopy (stem, p, stemlen);
    #####: 8036:	  p += stemlen;
    #####: 8037:	  bcopy (rule->suffixes[i], p,
        -: 8038:		 rule->lens[i] - (rule->suffixes[i] - rule->targets[i]) + 1);
    #####: 8039:	  new->file = enter_file (new->name);
call    0 never executed
    #####: 8040:	  new->next = file->also_make;
    #####: 8041:	  file->also_make = new;
        -: 8042:	}
        -: 8043:
        -: 8044:
    #####: 8045:  return 1;
        -: 8046:}
        -: 8047:
        -: 8048:
        -: 8049:
        -: 8050:/*************************************************************
        -: 8051:  ============================================================
        -: 8052:  ************************************************************
        -: 8053:  ============================================================
        -: 8054:  ************************************************************
        -: 8055:                         job.c
        -: 8056:  ************************************************************
        -: 8057:  ============================================================
        -: 8058:  ************************************************************
        -: 8059:  ============================================================
        -: 8060:  *************************************************************/
        -: 8061:
        -: 8062:/* Job execution and handling for GNU Make.
        -: 8063:Copyright (C) 1988,89,90,91,92,93,94,95,96,97,99 Free Software Foundation, Inc.
        -: 8064:This file is part of GNU Make.
        -: 8065:
        -: 8066:GNU Make is free software; you can redistribute it and/or modify
        -: 8067:it under the terms of the GNU General Public License as published by
        -: 8068:the Free Software Foundation; either version 2, or (at your option)
        -: 8069:any later version.
        -: 8070:
        -: 8071:GNU Make is distributed in the hope that it will be useful,
        -: 8072:but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 8073:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 8074:GNU General Public License for more details.
        -: 8075:
        -: 8076:You should have received a copy of the GNU General Public License
        -: 8077:along with GNU Make; see the file COPYING.  If not, write to
        -: 8078:the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
        -: 8079:Boston, MA 02111-1307, USA.  */
        -: 8080:
        -: 8081:#include <assert.h>
        -: 8082:
        -: 8083:/* #include "make.h"  <- modification by J.Ruthruff, 7/28 */
        -: 8084:#include "job.h"
        -: 8085:#include "debug.h"
        -: 8086:/* #include "filedef.h"  <- modification by J.Ruthruff, 7/28 */
        -: 8087:/* #include "commands.h"  <- modification by J.Ruthruff, 7/28 */
        -: 8088:/* #include "variable.h"  <- modification by J.Ruthruff, 7/28 */
        -: 8089:#include "debug.h"
        -: 8090:
        -: 8091:#include <string.h>
        -: 8092:#undef stderr
        -: 8093:#define stderr stdout
        -: 8094:
        -: 8095:/* Default shell to use.  */
        -: 8096:#ifdef WINDOWS32
        -: 8097:char *default_shell = "sh.exe";
        -: 8098:int no_default_sh_exe = 1;
        -: 8099:int batch_mode_shell = 1;
        -: 8100:#else  /* WINDOWS32 */
        -: 8101:# ifdef _AMIGA
        -: 8102:char default_shell[] = "";
        -: 8103:extern int MyExecute (char **);
        -: 8104:# else /* _AMIGA */
        -: 8105:#  ifdef __MSDOS__
        -: 8106:/* The default shell is a pointer so we can change it if Makefile
        -: 8107:   says so.  It is without an explicit path so we get a chance
        -: 8108:   to search the $PATH for it (since MSDOS doesn't have standard
        -: 8109:   directories we could trust).  */
        -: 8110:char *default_shell = "command.com";
        -: 8111:#  else  /* __MSDOS__ */
        -: 8112:#   ifdef VMS
        -: 8113:#    include <descrip.h>
        -: 8114:#undef stderr
        -: 8115:#define stderr stdout
        -: 8116:char default_shell[] = "";
        -: 8117:#   else
        -: 8118:char default_shell[] = "/bin/sh";
        -: 8119:#   endif /* VMS */
        -: 8120:#  endif /* __MSDOS__ */
        -: 8121:int batch_mode_shell = 0;
        -: 8122:# endif /* _AMIGA */
        -: 8123:#endif /* WINDOWS32 */
        -: 8124:
        -: 8125:#ifdef __MSDOS__
        -: 8126:# include <process.h>
        -: 8127:#undef stderr
        -: 8128:#define stderr stdout
        -: 8129:static int execute_by_shell;
        -: 8130:static int dos_pid = 123;
        -: 8131:int dos_status;
        -: 8132:int dos_command_running;
        -: 8133:#endif /* __MSDOS__ */
        -: 8134:
        -: 8135:#ifdef _AMIGA
        -: 8136:# include <proto/dos.h>
        -: 8137:#undef stderr
        -: 8138:#define stderr stdout
        -: 8139:static int amiga_pid = 123;
        -: 8140:static int amiga_status;
        -: 8141:static char amiga_bname[32];
        -: 8142:static int amiga_batch_file;
        -: 8143:#endif /* Amiga.  */
        -: 8144:
        -: 8145:#ifdef VMS
        -: 8146:# include <time.h>
        -: 8147:#undef stderr
        -: 8148:#define stderr stdout
        -: 8149:# ifndef __GNUC__
        -: 8150:#   include <processes.h>
        -: 8151:#undef stderr
        -: 8152:#define stderr stdout
        -: 8153:# endif
        -: 8154:# include <starlet.h>
        -: 8155:#undef stderr
        -: 8156:#define stderr stdout
        -: 8157:# include <lib$routines.h>
        -: 8158:#undef stderr
        -: 8159:#define stderr stdout
        -: 8160:#endif
        -: 8161:
        -: 8162:#ifdef WINDOWS32
        -: 8163:# include <windows.h>
        -: 8164:# include <io.h>
        -: 8165:# include <process.h>
        -: 8166:# include "sub_proc.h"
        -: 8167:# include "w32err.h"
        -: 8168:# include "pathstuff.h"
        -: 8169:#undef stderr
        -: 8170:#define stderr stdout
        -: 8171:#endif /* WINDOWS32 */
        -: 8172:
        -: 8173:#ifdef HAVE_FCNTL_H
        -: 8174:# include <fcntl.h>
        -: 8175:#undef stderr
        -: 8176:#define stderr stdout
        -: 8177:#else
        -: 8178:# include <sys/file.h>
        -: 8179:#undef stderr
        -: 8180:#define stderr stdout
        -: 8181:#endif
        -: 8182:
        -: 8183:#if defined (HAVE_SYS_WAIT_H) || defined (HAVE_UNION_WAIT)
        -: 8184:# include <sys/wait.h>
        -: 8185:#undef stderr
        -: 8186:#define stderr stdout
        -: 8187:#endif
        -: 8188:
        -: 8189:#ifdef HAVE_WAITPID
        -: 8190:# define WAIT_NOHANG(status)	waitpid (-1, (status), WNOHANG)
        -: 8191:#else	/* Don't have waitpid.  */
        -: 8192:# ifdef HAVE_WAIT3
        -: 8193:#  ifndef wait3
        -: 8194:extern int wait3 ();
        -: 8195:#  endif
        -: 8196:#  define WAIT_NOHANG(status)	wait3 ((status), WNOHANG, (struct rusage *) 0)
        -: 8197:# endif /* Have wait3.  */
        -: 8198:#endif /* Have waitpid.  */
        -: 8199:
        -: 8200:#if !defined (wait) && !defined (POSIX)
        -: 8201:extern int wait ();
        -: 8202:#endif
        -: 8203:
        -: 8204:#ifndef	HAVE_UNION_WAIT
        -: 8205:
        -: 8206:# define WAIT_T int
        -: 8207:
        -: 8208:# ifndef WTERMSIG
        -: 8209:#  define WTERMSIG(x) ((x) & 0x7f)
        -: 8210:# endif
        -: 8211:# ifndef WCOREDUMP
        -: 8212:#  define WCOREDUMP(x) ((x) & 0x80)
        -: 8213:# endif
        -: 8214:# ifndef WEXITSTATUS
        -: 8215:#  define WEXITSTATUS(x) (((x) >> 8) & 0xff)
        -: 8216:# endif
        -: 8217:# ifndef WIFSIGNALED
        -: 8218:#  define WIFSIGNALED(x) (WTERMSIG (x) != 0)
        -: 8219:# endif
        -: 8220:# ifndef WIFEXITED
        -: 8221:#  define WIFEXITED(x) (WTERMSIG (x) == 0)
        -: 8222:# endif
        -: 8223:
        -: 8224:#else	/* Have `union wait'.  */
        -: 8225:
        -: 8226:# define WAIT_T union wait
        -: 8227:# ifndef WTERMSIG
        -: 8228:#  define WTERMSIG(x) ((x).w_termsig)
        -: 8229:# endif
        -: 8230:# ifndef WCOREDUMP
        -: 8231:#  define WCOREDUMP(x) ((x).w_coredump)
        -: 8232:# endif
        -: 8233:# ifndef WEXITSTATUS
        -: 8234:#  define WEXITSTATUS(x) ((x).w_retcode)
        -: 8235:# endif
        -: 8236:# ifndef WIFSIGNALED
        -: 8237:#  define WIFSIGNALED(x) (WTERMSIG(x) != 0)
        -: 8238:# endif
        -: 8239:# ifndef WIFEXITED
        -: 8240:#  define WIFEXITED(x) (WTERMSIG(x) == 0)
        -: 8241:# endif
        -: 8242:
        -: 8243:#endif	/* Don't have `union wait'.  */
        -: 8244:
        -: 8245:/* How to set close-on-exec for a file descriptor.  */
        -: 8246:
        -: 8247:#if !defined F_SETFD
        -: 8248:# define CLOSE_ON_EXEC(_d)
        -: 8249:#else
        -: 8250:# ifndef FD_CLOEXEC
        -: 8251:#  define FD_CLOEXEC 1
        -: 8252:# endif
        -: 8253:# define CLOSE_ON_EXEC(_d) (void) fcntl ((_d), F_SETFD, FD_CLOEXEC)
        -: 8254:#endif
        -: 8255:
        -: 8256:#ifdef VMS
        -: 8257:static int vms_jobsefnmask = 0;
        -: 8258:#endif /* !VMS */
        -: 8259:
        -: 8260:#ifndef	HAVE_UNISTD_H
        -: 8261:extern int dup2 ();
        -: 8262:extern int execve ();
        -: 8263:extern void _exit ();
        -: 8264:# ifndef VMS
        -: 8265:extern int geteuid ();
        -: 8266:extern int getegid ();
        -: 8267:extern int setgid ();
        -: 8268:extern int getgid ();
        -: 8269:# endif
        -: 8270:#endif
        -: 8271:
        -: 8272:extern char *allocated_variable_expand_for_file PARAMS ((char *line, struct file *file));
        -: 8273:
        -: 8274:extern int getloadavg PARAMS ((double loadavg[], int nelem));
        -: 8275:extern int start_remote_job PARAMS ((char **argv, char **envp, int stdin_fd,
        -: 8276:		int *is_remote, int *id_ptr, int *used_stdin));
        -: 8277:extern int start_remote_job_p PARAMS ((int));
        -: 8278:extern int remote_status PARAMS ((int *exit_code_ptr, int *signal_ptr,
        -: 8279:		int *coredump_ptr, int block));
        -: 8280:
        -: 8281:RETSIGTYPE child_handler PARAMS ((int));
        -: 8282:static void free_child PARAMS ((struct child *));
        -: 8283:static void start_job_command PARAMS ((struct child *child));
        -: 8284:static int load_too_high PARAMS ((void));
        -: 8285:static int job_next_command PARAMS ((struct child *));
        -: 8286:static int start_waiting_job PARAMS ((struct child *));
        -: 8287:#ifdef VMS
        -: 8288:static void vmsWaitForChildren PARAMS ((int *));
        -: 8289:#endif
        -: 8290:
        -: 8291:/* Chain of all live (or recently deceased) children.  */
        -: 8292:
        -: 8293:struct child *children = 0;
        -: 8294:
        -: 8295:/* Number of children currently running.  */
        -: 8296:
        -: 8297:unsigned int job_slots_used = 0;
        -: 8298:
        -: 8299:/* Nonzero if the `good' standard input is in use.  */
        -: 8300:
        -: 8301:static int good_stdin_used = 0;
        -: 8302:
        -: 8303:/* Chain of children waiting to run until the load average goes down.  */
        -: 8304:
        -: 8305:static struct child *waiting_jobs = 0;
        -: 8306:
        -: 8307:/* Non-zero if we use a *real* shell (always so on Unix).  */
        -: 8308:
        -: 8309:int unixy_shell = 1;
        -: 8310:
        -: 8311:
        -: 8312:#ifdef WINDOWS32
        -: 8313:/*
        -: 8314: * The macro which references this function is defined in make.h.
        -: 8315: */
        -: 8316:int w32_kill(int pid, int sig)
        -: 8317:{
        -: 8318:  return ((process_kill(pid, sig) == TRUE) ? 0 : -1);
        -: 8319:}
        -: 8320:#endif /* WINDOWS32 */
        -: 8321:
        -: 8322:/* Write an error message describing the exit status given in
        -: 8323:   EXIT_CODE, EXIT_SIG, and COREDUMP, for the target TARGET_NAME.
        -: 8324:   Append "(ignored)" if IGNORED is nonzero.  */
        -: 8325:
        -: 8326:static void
function child_error called 0 returned 0% blocks executed 0%
    #####: 8327:child_error (target_name, exit_code, exit_sig, coredump, ignored)
        -: 8328:     char *target_name;
        -: 8329:     int exit_code, exit_sig, coredump;
        -: 8330:     int ignored;
        -: 8331:{
    #####: 8332:  if (ignored && silent_flag)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 8333:    return;
        -: 8334:
        -: 8335:#ifdef VMS
        -: 8336:  if (!(exit_code & 1))
        -: 8337:      error (NILF,
        -: 8338:             (ignored ? _("*** [%s] Error 0x%x (ignored)")
        -: 8339:              : _("*** [%s] Error 0x%x")),
        -: 8340:             target_name, exit_code);
        -: 8341:#else
    #####: 8342:  if (exit_sig == 0)
branch  0 never executed
branch  1 never executed
    #####: 8343:    error (NILF, ignored ? _("[%s] Error %d (ignored)") :
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 8344:	   _("*** [%s] Error %d"),
        -: 8345:	   target_name, exit_code);
        -: 8346:  else
    #####: 8347:    error (NILF, "*** [%s] %s%s",
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
        -: 8348:	   target_name, strsignal (exit_sig),
    #####: 8349:	   coredump ? _(" (core dumped)") : "");
        -: 8350:#endif /* VMS */
        -: 8351:}
        -: 8352:
        -: 8353:#ifdef VMS
        -: 8354:/* Wait for nchildren children to terminate */
        -: 8355:static void
        -: 8356:vmsWaitForChildren(int *status)
        -: 8357:{
        -: 8358:  while (1)
        -: 8359:    {
        -: 8360:      if (!vms_jobsefnmask)
        -: 8361:	{
        -: 8362:	  *status = 0;
        -: 8363:	  return;
        -: 8364:	}
        -: 8365:
        -: 8366:      *status = sys$wflor (32, vms_jobsefnmask);
        -: 8367:    }
        -: 8368:  return;
        -: 8369:}
        -: 8370:
        -: 8371:/* Set up IO redirection.  */
        -: 8372:
        -: 8373:char *
        -: 8374:vms_redirect (desc, fname, ibuf)
        -: 8375:    struct dsc$descriptor_s *desc;
        -: 8376:    char *fname;
        -: 8377:    char *ibuf;
        -: 8378:{
        -: 8379:  char *fptr;
        -: 8380:  extern char *vmsify ();
        -: 8381:
        -: 8382:  ibuf++;
        -: 8383:  while (isspace (*ibuf))
        -: 8384:    ibuf++;
        -: 8385:  fptr = ibuf;
        -: 8386:  while (*ibuf && !isspace (*ibuf))
        -: 8387:    ibuf++;
        -: 8388:  *ibuf = 0;
        -: 8389:  if (strcmp (fptr, "/dev/null") != 0)
        -: 8390:    {
        -: 8391:      strcpy (fname, vmsify (fptr, 0));
        -: 8392:      if (strchr (fname, '.') == 0)
        -: 8393:	strcat (fname, ".");
        -: 8394:    }
        -: 8395:  desc->dsc$w_length = strlen(fname);
        -: 8396:  desc->dsc$a_pointer = fname;
        -: 8397:  desc->dsc$b_dtype = DSC$K_DTYPE_T;
        -: 8398:  desc->dsc$b_class = DSC$K_CLASS_S;
        -: 8399:
        -: 8400:  if (*fname == 0)
        -: 8401:    printf (_("Warning: Empty redirection\n"));
        -: 8402:  return ibuf;
        -: 8403:}
        -: 8404:
        -: 8405:
        -: 8406:/*
        -: 8407:   found apostrophe at (p-1)
        -: 8408:
        -: 8409:   inc p until after closing apostrophe.  */
        -: 8410:
        -: 8411:static char *
        -: 8412:handle_apos (char *p)
        -: 8413:{
        -: 8414:  int alast;
        -: 8415:  int inside;
        -: 8416:
        -: 8417:#define SEPCHARS ",/()= "
        -: 8418:
        -: 8419:  inside = 0;
        -: 8420:
        -: 8421:  while (*p != 0)
        -: 8422:    {
        -: 8423:      if (*p == '"')
        -: 8424:	{
        -: 8425:	  if (inside)
        -: 8426:	    {
        -: 8427:	      while ((alast > 0)
        -: 8428:		    && (*p == '"'))
        -: 8429:		{
        -: 8430:		  p++;
        -: 8431:		  alast--;
        -: 8432:		}
        -: 8433:	      if (alast == 0)
        -: 8434:		inside = 0;
        -: 8435:	      else
        -: 8436:		{
        -: 8437:		  fprintf (stderr, _("Syntax error, still inside '\"'\n"));
        -: 8438:		  exit (3);
        -: 8439:		}
        -: 8440:	    }
        -: 8441:	  else
        -: 8442:	    {
        -: 8443:	      p++;
        -: 8444:	      if (strchr (SEPCHARS, *p))
        -: 8445:		break;
        -: 8446:	      inside = 1;
        -: 8447:	      alast = 1;
        -: 8448:	      while (*p == '"')
        -: 8449:		{
        -: 8450:		  alast++;
        -: 8451:		  p++;
        -: 8452:		}
        -: 8453:	    }
        -: 8454:	}
        -: 8455:      else
        -: 8456:	p++;
        -: 8457:    }
        -: 8458:
        -: 8459:  return p;
        -: 8460:}
        -: 8461:
        -: 8462:#endif
        -: 8463:
        -: 8464:
        -: 8465:/* Handle a dead child.  This handler may or may not ever be installed.
        -: 8466:
        -: 8467:   If we're using the jobserver feature, we need it.  First, installing it
        -: 8468:   ensures the read will interrupt on SIGCHLD.  Second, we close the dup'd
        -: 8469:   read FD to ensure we don't enter another blocking read without reaping all
        -: 8470:   the dead children.  In this case we don't need the dead_children count.
        -: 8471:
        -: 8472:   If we don't have either waitpid or wait3, then make is unreliable, but we
        -: 8473:   use the dead_children count to reap children as best we can.  */
        -: 8474:
        -: 8475:static unsigned int dead_children = 0;
        -: 8476:
        -: 8477:RETSIGTYPE
function child_handler called 0 returned 0% blocks executed 0%
    #####: 8478:child_handler (sig)
        -: 8479:     int sig;
        -: 8480:{
    #####: 8481:  ++dead_children;
        -: 8482:
    #####: 8483:  if (job_rfd >= 0)
branch  0 never executed
branch  1 never executed
        -: 8484:    {
    #####: 8485:      close (job_rfd);
call    0 never executed
    #####: 8486:      job_rfd = -1;
        -: 8487:    }
        -: 8488:
    #####: 8489:  DB (DB_JOBS, (_("Got a SIGCHLD; %u unreaped children.\n"), dead_children));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####: 8490:}
        -: 8491:
        -: 8492:
        -: 8493:extern int shell_function_pid, shell_function_completed;
        -: 8494:
        -: 8495:/* Reap all dead children, storing the returned status and the new command
        -: 8496:   state (`cs_finished') in the `file' member of the `struct child' for the
        -: 8497:   dead child, and removing the child from the chain.  In addition, if BLOCK
        -: 8498:   nonzero, we block in this function until we've reaped at least one
        -: 8499:   complete child, waiting for it to die if necessary.  If ERR is nonzero,
        -: 8500:   print an error message first.  */
        -: 8501:
        -: 8502:void
function reap_children called 1 returned 100% blocks executed 4%
        1: 8503:reap_children (block, err)
        -: 8504:     int block, err;
        -: 8505:{
        -: 8506:  WAIT_T status;
        -: 8507:  /* Initially, assume we have some.  */
        1: 8508:  int reap_more = 1;
        -: 8509:
        -: 8510:#ifdef WAIT_NOHANG
        -: 8511:# define REAP_MORE reap_more
        -: 8512:#else
        -: 8513:# define REAP_MORE dead_children
        -: 8514:#endif
        -: 8515:
        -: 8516:  /* As long as:
        -: 8517:
        -: 8518:       We have at least one child outstanding OR a shell function in progress,
        -: 8519:         AND
        -: 8520:       We're blocking for a complete child OR there are more children to reap
        -: 8521:
        -: 8522:     we'll keep reaping children.  */
        -: 8523:
       1*: 8524:  while ((children != 0 || shell_function_pid != 0) &&
branch  0 taken 1 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 1
branch  4 never executed
branch  5 never executed
    #####: 8525:	 (block || REAP_MORE))
branch  0 never executed
branch  1 never executed
        -: 8526:    {
    #####: 8527:      int remote = 0;
        -: 8528:      register int pid;
        -: 8529:      int exit_code, exit_sig, coredump;
        -: 8530:      register struct child *lastc, *c;
        -: 8531:      int child_failed;
        -: 8532:      int any_remote, any_local;
        -: 8533:
    #####: 8534:      if (err && block)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 8535:	{
        -: 8536:	  /* We might block for a while, so let the user know why.  */
    #####: 8537:	  fflush (stdout);
call    0 never executed
    #####: 8538:	  error (NILF, _("*** Waiting for unfinished jobs...."));
call    0 never executed
        -: 8539:	}
        -: 8540:
        -: 8541:      /* We have one less dead child to reap.  As noted in
        -: 8542:	 child_handler() above, this count is completely unimportant for
        -: 8543:	 all modern, POSIX-y systems that support wait3() or waitpid().
        -: 8544:	 The rest of this comment below applies only to early, broken
        -: 8545:	 pre-POSIX systems.  We keep the count only because... it's there...
        -: 8546:
        -: 8547:	 The test and decrement are not atomic; if it is compiled into:
        -: 8548:	 	register = dead_children - 1;
        -: 8549:		dead_children = register;
        -: 8550:	 a SIGCHLD could come between the two instructions.
        -: 8551:	 child_handler increments dead_children.
        -: 8552:	 The second instruction here would lose that increment.  But the
        -: 8553:	 only effect of dead_children being wrong is that we might wait
        -: 8554:	 longer than necessary to reap a child, and lose some parallelism;
        -: 8555:	 and we might print the "Waiting for unfinished jobs" message above
        -: 8556:	 when not necessary.  */
        -: 8557:
    #####: 8558:      if (dead_children > 0)
branch  0 never executed
branch  1 never executed
    #####: 8559:	--dead_children;
        -: 8560:
    #####: 8561:      any_remote = 0;
    #####: 8562:      any_local = shell_function_pid != 0;
    #####: 8563:      for (c = children; c != 0; c = c->next)
branch  0 never executed
branch  1 never executed
        -: 8564:	{
    #####: 8565:	  any_remote |= c->remote;
    #####: 8566:	  any_local |= ! c->remote;
    #####: 8567:	  DB (DB_JOBS, (_("Live child 0x%08lx (%s) PID %ld %s\n"),
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
        -: 8568:                        (unsigned long int) c, c->file->name,
        -: 8569:                        (long) c->pid, c->remote ? _(" (remote)") : ""));
        -: 8570:#ifdef VMS
        -: 8571:	  break;
        -: 8572:#endif
        -: 8573:	}
        -: 8574:
        -: 8575:      /* First, check for remote children.  */
    #####: 8576:      if (any_remote)
branch  0 never executed
branch  1 never executed
    #####: 8577:	pid = remote_status (&exit_code, &exit_sig, &coredump, 0);
call    0 never executed
        -: 8578:      else
    #####: 8579:	pid = 0;
        -: 8580:
    #####: 8581:      if (pid > 0)
branch  0 never executed
branch  1 never executed
        -: 8582:	/* We got a remote child.  */
    #####: 8583:	remote = 1;
    #####: 8584:      else if (pid < 0)
branch  0 never executed
branch  1 never executed
        -: 8585:	{
        -: 8586:          /* A remote status command failed miserably.  Punt.  */
    #####: 8587:	remote_status_lose:
    #####: 8588:	  if (EINTR_SET)
branch  0 never executed
branch  1 never executed
    #####: 8589:	    continue;
        -: 8590:
    #####: 8591:	  pfatal_with_name ("remote_status");
call    0 never executed
        -: 8592:	}
        -: 8593:      else
        -: 8594:	{
        -: 8595:	  /* No remote children.  Check for local children.  */
        -: 8596:#if !defined(__MSDOS__) && !defined(_AMIGA) && !defined(WINDOWS32)
    #####: 8597:	  if (any_local)
branch  0 never executed
branch  1 never executed
        -: 8598:	    {
    #####: 8599:            local_wait:
        -: 8600:#ifdef VMS
        -: 8601:	      vmsWaitForChildren (&status);
        -: 8602:	      pid = c->pid;
        -: 8603:#else
        -: 8604:#ifdef WAIT_NOHANG
    #####: 8605:	      if (!block)
branch  0 never executed
branch  1 never executed
    #####: 8606:		pid = WAIT_NOHANG (&status);
call    0 never executed
        -: 8607:	      else
        -: 8608:#endif
    #####: 8609:		pid = wait (&status);
call    0 never executed
        -: 8610:#endif /* !VMS */
        -: 8611:	    }
        -: 8612:	  else
    #####: 8613:	    pid = 0;
        -: 8614:
    #####: 8615:	  if (pid < 0)
branch  0 never executed
branch  1 never executed
        -: 8616:	    {
        -: 8617:              /* EINTR?  Try again. */
    #####: 8618:	      if (EINTR_SET)
branch  0 never executed
branch  1 never executed
    #####: 8619:		goto local_wait;
        -: 8620:
        -: 8621:              /* The wait*() failed miserably.  Punt.  */
    #####: 8622:	      pfatal_with_name ("wait");
call    0 never executed
        -: 8623:	    }
    #####: 8624:	  else if (pid > 0)
branch  0 never executed
branch  1 never executed
        -: 8625:	    {
        -: 8626:	      /* We got a child exit; chop the status word up.  */
    #####: 8627:	      exit_code = WEXITSTATUS (status);
    #####: 8628:	      exit_sig = WIFSIGNALED (status) ? WTERMSIG (status) : 0;
branch  0 never executed
branch  1 never executed
    #####: 8629:	      coredump = WCOREDUMP (status);
        -: 8630:	    }
        -: 8631:	  else
        -: 8632:	    {
        -: 8633:	      /* No local children are dead.  */
    #####: 8634:              reap_more = 0;
        -: 8635:
    #####: 8636:	      if (!block || !any_remote)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 8637:                break;
        -: 8638:
        -: 8639:              /* Now try a blocking wait for a remote child.  */
    #####: 8640:              pid = remote_status (&exit_code, &exit_sig, &coredump, 1);
call    0 never executed
    #####: 8641:              if (pid < 0)
branch  0 never executed
branch  1 never executed
    #####: 8642:                goto remote_status_lose;
    #####: 8643:              else if (pid == 0)
branch  0 never executed
branch  1 never executed
        -: 8644:                /* No remote children either.  Finally give up.  */
    #####: 8645:                break;
        -: 8646:
        -: 8647:              /* We got a remote child.  */
    #####: 8648:              remote = 1;
        -: 8649:	    }
        -: 8650:#endif /* !__MSDOS__, !Amiga, !WINDOWS32.  */
        -: 8651:
        -: 8652:#ifdef __MSDOS__
        -: 8653:	  /* Life is very different on MSDOS.  */
        -: 8654:	  pid = dos_pid - 1;
        -: 8655:	  status = dos_status;
        -: 8656:	  exit_code = WEXITSTATUS (status);
        -: 8657:	  if (exit_code == 0xff)
        -: 8658:	    exit_code = -1;
        -: 8659:	  exit_sig = WIFSIGNALED (status) ? WTERMSIG (status) : 0;
        -: 8660:	  coredump = 0;
        -: 8661:#endif /* __MSDOS__ */
        -: 8662:#ifdef _AMIGA
        -: 8663:	  /* Same on Amiga */
        -: 8664:	  pid = amiga_pid - 1;
        -: 8665:	  status = amiga_status;
        -: 8666:	  exit_code = amiga_status;
        -: 8667:	  exit_sig = 0;
        -: 8668:	  coredump = 0;
        -: 8669:#endif /* _AMIGA */
        -: 8670:#ifdef WINDOWS32
        -: 8671:          {
        -: 8672:            HANDLE hPID;
        -: 8673:            int err;
        -: 8674:
        -: 8675:            /* wait for anything to finish */
        -: 8676:            if (hPID = process_wait_for_any()) {
        -: 8677:
        -: 8678:              /* was an error found on this process? */
        -: 8679:              err = process_last_err(hPID);
        -: 8680:
        -: 8681:              /* get exit data */
        -: 8682:              exit_code = process_exit_code(hPID);
        -: 8683:
        -: 8684:              if (err)
        -: 8685:                fprintf(stderr, "make (e=%d): %s",
        -: 8686:                  exit_code, map_windows32_error_to_string(exit_code));
        -: 8687:
        -: 8688:              /* signal */
        -: 8689:              exit_sig = process_signal(hPID);
        -: 8690:
        -: 8691:              /* cleanup process */
        -: 8692:              process_cleanup(hPID);
        -: 8693:
        -: 8694:              coredump = 0;
        -: 8695:            }
        -: 8696:            pid = (int) hPID;
        -: 8697:          }
        -: 8698:#endif /* WINDOWS32 */
        -: 8699:	}
        -: 8700:
        -: 8701:      /* Check if this is the child of the `shell' function.  */
    #####: 8702:      if (!remote && pid == shell_function_pid)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 8703:	{
        -: 8704:	  /* It is.  Leave an indicator for the `shell' function.  */
    #####: 8705:	  if (exit_sig == 0 && exit_code == 127)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 8706:	    shell_function_completed = -1;
        -: 8707:	  else
    #####: 8708:	    shell_function_completed = 1;
    #####: 8709:	  break;
        -: 8710:	}
        -: 8711:
    #####: 8712:      child_failed = exit_sig != 0 || exit_code != 0;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 8713:
        -: 8714:      /* Search for a child matching the deceased one.  */
    #####: 8715:      lastc = 0;
    #####: 8716:      for (c = children; c != 0; lastc = c, c = c->next)
branch  0 never executed
branch  1 never executed
    #####: 8717:	if (c->remote == remote && c->pid == pid)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 8718:	  break;
        -: 8719:
    #####: 8720:      if (c == 0)
branch  0 never executed
branch  1 never executed
        -: 8721:        /* An unknown child died.
        -: 8722:           Ignore it; it was inherited from our invoker.  */
    #####: 8723:        continue;
        -: 8724:
    #####: 8725:      DB (DB_JOBS, (child_failed
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
call    7 never executed
        -: 8726:                    ? _("Reaping losing child 0x%08lx PID %ld %s\n")
        -: 8727:                    : _("Reaping winning child 0x%08lx PID %ld %s\n"),
        -: 8728:                    (unsigned long int) c, (long) c->pid,
        -: 8729:                    c->remote ? _(" (remote)") : ""));
        -: 8730:
    #####: 8731:      if (c->sh_batch_file) {
branch  0 never executed
branch  1 never executed
    #####: 8732:        DB (DB_JOBS, (_("Cleaning up temp batch file %s\n"),
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
        -: 8733:                      c->sh_batch_file));
        -: 8734:
        -: 8735:        /* just try and remove, don't care if this fails */
    #####: 8736:        remove (c->sh_batch_file);
call    0 never executed
        -: 8737:
        -: 8738:        /* all done with memory */
    #####: 8739:        free (c->sh_batch_file);
    #####: 8740:        c->sh_batch_file = NULL;
        -: 8741:      }
        -: 8742:
        -: 8743:      /* If this child had the good stdin, say it is now free.  */
    #####: 8744:      if (c->good_stdin)
branch  0 never executed
branch  1 never executed
    #####: 8745:        good_stdin_used = 0;
        -: 8746:
    #####: 8747:      if (child_failed && !c->noerror && !ignore_errors_flag)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 8748:        {
        -: 8749:          /* The commands failed.  Write an error message,
        -: 8750:             delete non-precious targets, and abort.  */
        -: 8751:          static int delete_on_error = -1;
    #####: 8752:          child_error (c->file->name, exit_code, exit_sig, coredump, 0);
call    0 never executed
    #####: 8753:          c->file->update_status = 2;
    #####: 8754:          if (delete_on_error == -1)
branch  0 never executed
branch  1 never executed
        -: 8755:            {
    #####: 8756:              struct file *f = lookup_file (".DELETE_ON_ERROR");
call    0 never executed
    #####: 8757:              delete_on_error = f != 0 && f->is_target;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 8758:            }
    #####: 8759:          if (exit_sig != 0 || delete_on_error)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 8760:            delete_child_targets (c);
call    0 never executed
        -: 8761:        }
        -: 8762:      else
        -: 8763:        {
    #####: 8764:          if (child_failed)
branch  0 never executed
branch  1 never executed
        -: 8765:            {
        -: 8766:              /* The commands failed, but we don't care.  */
    #####: 8767:              child_error (c->file->name,
call    0 never executed
        -: 8768:                           exit_code, exit_sig, coredump, 1);
    #####: 8769:              child_failed = 0;
        -: 8770:            }
        -: 8771:
        -: 8772:          /* If there are more commands to run, try to start them.  */
    #####: 8773:          if (job_next_command (c))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 8774:            {
    #####: 8775:              if (handling_fatal_signal)
branch  0 never executed
branch  1 never executed
        -: 8776:                {
        -: 8777:                  /* Never start new commands while we are dying.
        -: 8778:                     Since there are more commands that wanted to be run,
        -: 8779:                     the target was not completely remade.  So we treat
        -: 8780:                     this as if a command had failed.  */
    #####: 8781:                  c->file->update_status = 2;
        -: 8782:                }
        -: 8783:              else
        -: 8784:                {
        -: 8785:                  /* Check again whether to start remotely.
        -: 8786:                     Whether or not we want to changes over time.
        -: 8787:                     Also, start_remote_job may need state set up
        -: 8788:                     by start_remote_job_p.  */
    #####: 8789:                  c->remote = start_remote_job_p (0);
call    0 never executed
    #####: 8790:                  start_job_command (c);
call    0 never executed
        -: 8791:                  /* Fatal signals are left blocked in case we were
        -: 8792:                     about to put that child on the chain.  But it is
        -: 8793:                     already there, so it is safe for a fatal signal to
        -: 8794:                     arrive now; it will clean up this child's targets.  */
    #####: 8795:                  unblock_sigs ();
call    0 never executed
    #####: 8796:                  if (c->file->command_state == cs_running)
branch  0 never executed
branch  1 never executed
        -: 8797:                    /* We successfully started the new command.
        -: 8798:                       Loop to reap more children.  */
    #####: 8799:                    continue;
        -: 8800:                }
        -: 8801:
    #####: 8802:              if (c->file->update_status != 0)
branch  0 never executed
branch  1 never executed
        -: 8803:                /* We failed to start the commands.  */
    #####: 8804:                delete_child_targets (c);
call    0 never executed
        -: 8805:            }
        -: 8806:          else
        -: 8807:            /* There are no more commands.  We got through them all
        -: 8808:               without an unignored error.  Now the target has been
        -: 8809:               successfully updated.  */
    #####: 8810:            c->file->update_status = 0;
        -: 8811:        }
        -: 8812:
        -: 8813:      /* When we get here, all the commands for C->file are finished
        -: 8814:         (or aborted) and C->file->update_status contains 0 or 2.  But
        -: 8815:         C->file->command_state is still cs_running if all the commands
        -: 8816:         ran; notice_finish_file looks for cs_running to tell it that
        -: 8817:         it's interesting to check the file's modtime again now.  */
        -: 8818:
    #####: 8819:      if (! handling_fatal_signal)
branch  0 never executed
branch  1 never executed
        -: 8820:        /* Notice if the target of the commands has been changed.
        -: 8821:           This also propagates its values for command_state and
        -: 8822:           update_status to its also_make files.  */
    #####: 8823:        notice_finished_file (c->file);
call    0 never executed
        -: 8824:
    #####: 8825:      DB (DB_JOBS, (_("Removing child 0x%08lx PID %ld %s from chain.\n"),
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
        -: 8826:                    (unsigned long int) c, (long) c->pid,
        -: 8827:                    c->remote ? _(" (remote)") : ""));
        -: 8828:
        -: 8829:      /* Block fatal signals while frobnicating the list, so that
        -: 8830:         children and job_slots_used are always consistent.  Otherwise
        -: 8831:         a fatal signal arriving after the child is off the chain and
        -: 8832:         before job_slots_used is decremented would believe a child was
        -: 8833:         live and call reap_children again.  */
    #####: 8834:      block_sigs ();
call    0 never executed
        -: 8835:
        -: 8836:      /* There is now another slot open.  */
    #####: 8837:      if (job_slots_used > 0)
branch  0 never executed
branch  1 never executed
    #####: 8838:        --job_slots_used;
        -: 8839:
        -: 8840:      /* Remove the child from the chain and free it.  */
    #####: 8841:      if (lastc == 0)
branch  0 never executed
branch  1 never executed
    #####: 8842:        children = c->next;
        -: 8843:      else
    #####: 8844:        lastc->next = c->next;
        -: 8845:
    #####: 8846:      free_child (c);
call    0 never executed
        -: 8847:
    #####: 8848:      unblock_sigs ();
call    0 never executed
        -: 8849:
        -: 8850:      /* If the job failed, and the -k flag was not given, die,
        -: 8851:         unless we are already in the process of dying.  */
    #####: 8852:      if (!err && child_failed && !keep_going_flag &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 8853:          /* fatal_error_signal will die with the right signal.  */
    #####: 8854:          !handling_fatal_signal)
branch  0 never executed
branch  1 never executed
    #####: 8855:        die (2);
call    0 never executed
        -: 8856:
        -: 8857:      /* Only block for one child.  */
    #####: 8858:      block = 0;
        -: 8859:    }
        -: 8860:
        1: 8861:  return;
        -: 8862:}
        -: 8863:
        -: 8864:/* Free the storage allocated for CHILD.  */
        -: 8865:
        -: 8866:static void
function free_child called 0 returned 0% blocks executed 0%
    #####: 8867:free_child (child)
        -: 8868:     register struct child *child;
        -: 8869:{
        -: 8870:  /* If this child is the only one it was our "free" job, so don't put a
        -: 8871:     token back for it.  This child has already been removed from the list,
        -: 8872:     so if there any left this wasn't the last one.  */
        -: 8873:
    #####: 8874:  if (job_fds[1] >= 0 && children)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 8875:    {
    #####: 8876:      char token = '+';
        -: 8877:
        -: 8878:      /* Write a job token back to the pipe.  */
        -: 8879:
    #####: 8880:      while (write (job_fds[1], &token, 1) != 1)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 8881:        if (!EINTR_SET)
branch  0 never executed
branch  1 never executed
    #####: 8882:          pfatal_with_name (_("write jobserver"));
call    0 never executed
        -: 8883:
    #####: 8884:      DB (DB_JOBS, (_("Released token for child 0x%08lx (%s).\n"),
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
        -: 8885:                    (unsigned long int) child, child->file->name));
        -: 8886:    }
        -: 8887:
    #####: 8888:  if (handling_fatal_signal) /* Don't bother free'ing if about to die.  */
branch  0 never executed
branch  1 never executed
    #####: 8889:    return;
        -: 8890:
    #####: 8891:  if (child->command_lines != 0)
branch  0 never executed
branch  1 never executed
        -: 8892:    {
        -: 8893:      register unsigned int i;
    #####: 8894:      for (i = 0; i < child->file->cmds->ncommand_lines; ++i)
branch  0 never executed
branch  1 never executed
    #####: 8895:	free (child->command_lines[i]);
    #####: 8896:      free ((char *) child->command_lines);
        -: 8897:    }
        -: 8898:
    #####: 8899:  if (child->environment != 0)
branch  0 never executed
branch  1 never executed
        -: 8900:    {
    #####: 8901:      register char **ep = child->environment;
    #####: 8902:      while (*ep != 0)
branch  0 never executed
branch  1 never executed
    #####: 8903:	free (*ep++);
    #####: 8904:      free ((char *) child->environment);
        -: 8905:    }
        -: 8906:
    #####: 8907:  free ((char *) child);
        -: 8908:}
        -: 8909:
        -: 8910:#ifdef POSIX
        -: 8911:extern sigset_t fatal_signal_set;
        -: 8912:#endif
        -: 8913:
        -: 8914:void
function block_sigs called 0 returned 0% blocks executed 0%
    #####: 8915:block_sigs ()
        -: 8916:{
        -: 8917:#ifdef POSIX
    #####: 8918:  (void) sigprocmask (SIG_BLOCK, &fatal_signal_set, (sigset_t *) 0);
call    0 never executed
        -: 8919:#else
        -: 8920:# ifdef HAVE_SIGSETMASK
        -: 8921:  (void) sigblock (fatal_signal_mask);
        -: 8922:# endif
        -: 8923:#endif
    #####: 8924:}
        -: 8925:
        -: 8926:#ifdef	POSIX
        -: 8927:void
function unblock_sigs called 0 returned 0% blocks executed 0%
    #####: 8928:unblock_sigs ()
        -: 8929:{
        -: 8930:  sigset_t empty;
    #####: 8931:  sigemptyset (&empty);
call    0 never executed
    #####: 8932:  sigprocmask (SIG_SETMASK, &empty, (sigset_t *) 0);
call    0 never executed
    #####: 8933:}
        -: 8934:#endif
        -: 8935:
        -: 8936:/* Start a job to run the commands specified in CHILD.
        -: 8937:   CHILD is updated to reflect the commands and ID of the child process.
        -: 8938:
        -: 8939:   NOTE: On return fatal signals are blocked!  The caller is responsible
        -: 8940:   for calling `unblock_sigs', once the new child is safely on the chain so
        -: 8941:   it can be cleaned up in the event of a fatal signal.  */
        -: 8942:
        -: 8943:static void
function start_job_command called 0 returned 0% blocks executed 0%
    #####: 8944:start_job_command (child)
        -: 8945:     register struct child *child;
        -: 8946:{
        -: 8947:#ifndef _AMIGA
        -: 8948:  static int bad_stdin = -1;
        -: 8949:#endif
        -: 8950:  register char *p;
        -: 8951:  int flags;
        -: 8952:#ifdef VMS
        -: 8953:  char *argv;
        -: 8954:#else
        -: 8955:  char **argv;
        -: 8956:#endif
        -: 8957:
        -: 8958:  /* If we have a completely empty commandset, stop now.  */
    #####: 8959:  if (!child->command_ptr)
branch  0 never executed
branch  1 never executed
    #####: 8960:    goto next_command;
        -: 8961:
        -: 8962:  /* Combine the flags parsed for the line itself with
        -: 8963:     the flags specified globally for this target.  */
    #####: 8964:  flags = (child->file->command_flags
    #####: 8965:	   | child->file->cmds->lines_flags[child->command_line - 1]);
        -: 8966:
    #####: 8967:  p = child->command_ptr;
    #####: 8968:  child->noerror = flags & COMMANDS_NOERROR;
        -: 8969:
    #####: 8970:  while (*p != '\0')
branch  0 never executed
branch  1 never executed
        -: 8971:    {
    #####: 8972:      if (*p == '@')
branch  0 never executed
branch  1 never executed
    #####: 8973:	flags |= COMMANDS_SILENT;
    #####: 8974:      else if (*p == '+')
branch  0 never executed
branch  1 never executed
    #####: 8975:	flags |= COMMANDS_RECURSE;
    #####: 8976:      else if (*p == '-')
branch  0 never executed
branch  1 never executed
    #####: 8977:	child->noerror = 1;
    #####: 8978:      else if (!isblank (*p))
branch  0 never executed
branch  1 never executed
    #####: 8979:	break;
    #####: 8980:      ++p;
        -: 8981:    }
        -: 8982:
        -: 8983:  /* Update the file's command flags with any new ones we found.  */
        -: 8984:#ifndef F_JR_8  /* seeded fault #8; J.Ruthruff */
        -: 8985:  child->file->cmds->lines_flags[child->command_line - 1] |= flags;
        -: 8986:#else
    #####: 8987:  child->file->cmds->lines_flags[child->command_line] |= flags;
        -: 8988:#endif
        -: 8989:
        -: 8990:  /* If -q was given, just say that updating `failed'.  The exit status of
        -: 8991:     1 tells the user that -q is saying `something to do'; the exit status
        -: 8992:     for a random error is 2.  */
    #####: 8993:  if (question_flag && !(flags & COMMANDS_RECURSE))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 8994:    {
    #####: 8995:      child->file->update_status = 1;
    #####: 8996:      notice_finished_file (child->file);
call    0 never executed
    #####: 8997:      return;
        -: 8998:    }
        -: 8999:
        -: 9000:  /* There may be some preceding whitespace left if there
        -: 9001:     was nothing but a backslash on the first line.  */
    #####: 9002:  p = next_token (p);
call    0 never executed
        -: 9003:
        -: 9004:  /* Figure out an argument list from this command line.  */
        -: 9005:
        -: 9006:  {
    #####: 9007:    char *end = 0;
        -: 9008:#ifdef VMS
        -: 9009:    argv = p;
        -: 9010:#else
    #####: 9011:    argv = construct_command_argv (p, &end, child->file, &child->sh_batch_file);
call    0 never executed
        -: 9012:#endif
    #####: 9013:    if (end == NULL)
branch  0 never executed
branch  1 never executed
    #####: 9014:      child->command_ptr = NULL;
        -: 9015:    else
        -: 9016:      {
    #####: 9017:	*end++ = '\0';
    #####: 9018:	child->command_ptr = end;
        -: 9019:      }
        -: 9020:  }
        -: 9021:
    #####: 9022:  if (touch_flag && !(flags & COMMANDS_RECURSE))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 9023:    {
        -: 9024:      /* Go on to the next command.  It might be the recursive one.
        -: 9025:	 We construct ARGV only to find the end of the command line.  */
        -: 9026:#ifndef VMS
    #####: 9027:      free (argv[0]);
    #####: 9028:      free ((char *) argv);
        -: 9029:#endif
    #####: 9030:      argv = 0;
        -: 9031:    }
        -: 9032:
    #####: 9033:  if (argv == 0)
branch  0 never executed
branch  1 never executed
        -: 9034:    {
    #####: 9035:    next_command:
        -: 9036:#ifdef __MSDOS__
        -: 9037:      execute_by_shell = 0;   /* in case construct_command_argv sets it */
        -: 9038:#endif
        -: 9039:      /* This line has no commands.  Go to the next.  */
    #####: 9040:      if (job_next_command (child))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 9041:	start_job_command (child);
call    0 never executed
        -: 9042:      else
        -: 9043:	{
        -: 9044:	  /* No more commands.  Make sure we're "running"; we might not be if
        -: 9045:             (e.g.) all commands were skipped due to -n.  */
    #####: 9046:          set_command_state (child->file, cs_running);
call    0 never executed
    #####: 9047:	  child->file->update_status = 0;
    #####: 9048:	  notice_finished_file (child->file);
call    0 never executed
        -: 9049:	}
    #####: 9050:      return;
        -: 9051:    }
        -: 9052:
        -: 9053:  /* Print out the command.  If silent, we call `message' with null so it
        -: 9054:     can log the working directory before the command's own error messages
        -: 9055:     appear.  */
        -: 9056:
    #####: 9057:  message (0, (just_print_flag || (!(flags & COMMANDS_SILENT) && !silent_flag))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
        -: 9058:	   ? "%s" : (char *) 0, p);
        -: 9059:
        -: 9060:  /* Optimize an empty command.  People use this for timestamp rules,
        -: 9061:     so avoid forking a useless shell.  */
        -: 9062:
        -: 9063:#if !defined(VMS) && !defined(_AMIGA)
    #####: 9064:  if (
        -: 9065:#ifdef __MSDOS__
        -: 9066:      unixy_shell	/* the test is complicated and we already did it */
        -: 9067:#else
    #####: 9068:      (argv[0] && !strcmp (argv[0], "/bin/sh"))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 9069:#endif
    #####: 9070:      && (argv[1]
branch  0 never executed
branch  1 never executed
    #####: 9071:          && argv[1][0] == '-' && argv[1][1] == 'c' && argv[1][2] == '\0')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 9072:      && (argv[2] && argv[2][0] == ':' && argv[2][1] == '\0')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 9073:      && argv[3] == NULL)
branch  0 never executed
branch  1 never executed
        -: 9074:    {
    #####: 9075:      free (argv[0]);
    #####: 9076:      free ((char *) argv);
    #####: 9077:      goto next_command;
        -: 9078:    }
        -: 9079:#endif  /* !VMS && !_AMIGA */
        -: 9080:
        -: 9081:  /* Tell update_goal_chain that a command has been started on behalf of
        -: 9082:     this target.  It is important that this happens here and not in
        -: 9083:     reap_children (where we used to do it), because reap_children might be
        -: 9084:     reaping children from a different target.  We want this increment to
        -: 9085:     guaranteedly indicate that a command was started for the dependency
        -: 9086:     chain (i.e., update_file recursion chain) we are processing.  */
        -: 9087:
    #####: 9088:  ++commands_started;
        -: 9089:
        -: 9090:  /* If -n was given, recurse to get the next line in the sequence.  */
        -: 9091:
    #####: 9092:  if (just_print_flag && !(flags & COMMANDS_RECURSE))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 9093:    {
        -: 9094:#ifndef VMS
    #####: 9095:      free (argv[0]);
    #####: 9096:      free ((char *) argv);
        -: 9097:#endif
    #####: 9098:      goto next_command;
        -: 9099:    }
        -: 9100:
        -: 9101:  /* Flush the output streams so they won't have things written twice.  */
        -: 9102:
    #####: 9103:  fflush (stdout);
call    0 never executed
    #####: 9104:  fflush (stderr);
call    0 never executed
        -: 9105:
        -: 9106:#ifndef VMS
        -: 9107:#if !defined(WINDOWS32) && !defined(_AMIGA) && !defined(__MSDOS__)
        -: 9108:
        -: 9109:  /* Set up a bad standard input that reads from a broken pipe.  */
        -: 9110:
    #####: 9111:  if (bad_stdin == -1)
branch  0 never executed
branch  1 never executed
        -: 9112:    {
        -: 9113:      /* Make a file descriptor that is the read end of a broken pipe.
        -: 9114:	 This will be used for some children's standard inputs.  */
        -: 9115:      int pd[2];
    #####: 9116:      if (pipe (pd) == 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 9117:	{
        -: 9118:	  /* Close the write side.  */
    #####: 9119:	  (void) close (pd[1]);
call    0 never executed
        -: 9120:	  /* Save the read side.  */
    #####: 9121:	  bad_stdin = pd[0];
        -: 9122:
        -: 9123:	  /* Set the descriptor to close on exec, so it does not litter any
        -: 9124:	     child's descriptor table.  When it is dup2'd onto descriptor 0,
        -: 9125:	     that descriptor will not close on exec.  */
    #####: 9126:	  CLOSE_ON_EXEC (bad_stdin);
call    0 never executed
        -: 9127:	}
        -: 9128:    }
        -: 9129:
        -: 9130:#endif /* !WINDOWS32 && !_AMIGA && !__MSDOS__ */
        -: 9131:
        -: 9132:  /* Decide whether to give this child the `good' standard input
        -: 9133:     (one that points to the terminal or whatever), or the `bad' one
        -: 9134:     that points to the read side of a broken pipe.  */
        -: 9135:
    #####: 9136:  child->good_stdin = !good_stdin_used;
    #####: 9137:  if (child->good_stdin)
branch  0 never executed
branch  1 never executed
    #####: 9138:    good_stdin_used = 1;
        -: 9139:
        -: 9140:#endif /* !VMS */
        -: 9141:
    #####: 9142:  child->deleted = 0;
        -: 9143:
        -: 9144:#ifndef _AMIGA
        -: 9145:  /* Set up the environment for the child.  */
    #####: 9146:  if (child->environment == 0)
branch  0 never executed
branch  1 never executed
    #####: 9147:    child->environment = target_environment (child->file);
call    0 never executed
        -: 9148:#endif
        -: 9149:
        -: 9150:#if !defined(__MSDOS__) && !defined(_AMIGA) && !defined(WINDOWS32)
        -: 9151:
        -: 9152:#ifndef VMS
        -: 9153:  /* start_waiting_job has set CHILD->remote if we can start a remote job.  */
    #####: 9154:  if (child->remote)
branch  0 never executed
branch  1 never executed
        -: 9155:    {
        -: 9156:      int is_remote, id, used_stdin;
    #####: 9157:      if (start_remote_job (argv, child->environment,
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 9158:			    child->good_stdin ? 0 : bad_stdin,
branch  0 never executed
branch  1 never executed
        -: 9159:			    &is_remote, &id, &used_stdin))
        -: 9160:        /* Don't give up; remote execution may fail for various reasons.  If
        -: 9161:           so, simply run the job locally.  */
    #####: 9162:	goto run_local;
        -: 9163:      else
        -: 9164:	{
    #####: 9165:	  if (child->good_stdin && !used_stdin)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 9166:	    {
    #####: 9167:	      child->good_stdin = 0;
    #####: 9168:	      good_stdin_used = 0;
        -: 9169:	    }
    #####: 9170:	  child->remote = is_remote;
    #####: 9171:	  child->pid = id;
        -: 9172:	}
        -: 9173:    }
        -: 9174:  else
        -: 9175:#endif /* !VMS */
        -: 9176:    {
        -: 9177:      /* Fork the child process.  */
        -: 9178:
        -: 9179:      char **parent_environ;
        -: 9180:
    #####: 9181:    run_local:
    #####: 9182:      block_sigs ();
call    0 never executed
        -: 9183:
    #####: 9184:      child->remote = 0;
        -: 9185:
        -: 9186:#ifdef VMS
        -: 9187:
        -: 9188:      if (!child_execute_job (argv, child)) {
        -: 9189:        /* Fork failed!  */
        -: 9190:        perror_with_name ("vfork", "");
        -: 9191:        goto error;
        -: 9192:      }
        -: 9193:
        -: 9194:#else
        -: 9195:
    #####: 9196:      parent_environ = environ;
    #####: 9197:      child->pid = vfork ();
call    0 never executed
    #####: 9198:      environ = parent_environ;	/* Restore value child may have clobbered.  */
    #####: 9199:      if (child->pid == 0)
branch  0 never executed
branch  1 never executed
        -: 9200:	{
        -: 9201:	  /* We are the child side.  */
    #####: 9202:	  unblock_sigs ();
call    0 never executed
        -: 9203:
        -: 9204:          /* If we aren't running a recursive command and we have a jobserver
        -: 9205:             pipe, close it before exec'ing.  */
    #####: 9206:          if (!(flags & COMMANDS_RECURSE) && job_fds[0] >= 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 9207:            {
    #####: 9208:              close (job_fds[0]);
call    0 never executed
    #####: 9209:              close (job_fds[1]);
call    0 never executed
        -: 9210:            }
    #####: 9211:          if (job_rfd >= 0)
branch  0 never executed
branch  1 never executed
    #####: 9212:            close (job_rfd);
call    0 never executed
        -: 9213:
    #####: 9214:	  child_execute_job (child->good_stdin ? 0 : bad_stdin, 1,
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 9215:                             argv, child->environment);
        -: 9216:	}
    #####: 9217:      else if (child->pid < 0)
branch  0 never executed
branch  1 never executed
        -: 9218:	{
        -: 9219:	  /* Fork failed!  */
    #####: 9220:	  unblock_sigs ();
call    0 never executed
    #####: 9221:	  perror_with_name ("vfork", "");
call    0 never executed
    #####: 9222:	  goto error;
        -: 9223:	}
        -: 9224:#endif /* !VMS */
        -: 9225:    }
        -: 9226:
        -: 9227:#else	/* __MSDOS__ or Amiga or WINDOWS32 */
        -: 9228:#ifdef __MSDOS__
        -: 9229:  {
        -: 9230:    int proc_return;
        -: 9231:
        -: 9232:    block_sigs ();
        -: 9233:    dos_status = 0;
        -: 9234:
        -: 9235:    /* We call `system' to do the job of the SHELL, since stock DOS
        -: 9236:       shell is too dumb.  Our `system' knows how to handle long
        -: 9237:       command lines even if pipes/redirection is needed; it will only
        -: 9238:       call COMMAND.COM when its internal commands are used.  */
        -: 9239:    if (execute_by_shell)
        -: 9240:      {
        -: 9241:	char *cmdline = argv[0];
        -: 9242:	/* We don't have a way to pass environment to `system',
        -: 9243:	   so we need to save and restore ours, sigh...  */
        -: 9244:	char **parent_environ = environ;
        -: 9245:
        -: 9246:	environ = child->environment;
        -: 9247:
        -: 9248:	/* If we have a *real* shell, tell `system' to call
        -: 9249:	   it to do everything for us.  */
        -: 9250:	if (unixy_shell)
        -: 9251:	  {
        -: 9252:	    /* A *real* shell on MSDOS may not support long
        -: 9253:	       command lines the DJGPP way, so we must use `system'.  */
        -: 9254:	    cmdline = argv[2];	/* get past "shell -c" */
        -: 9255:	  }
        -: 9256:
        -: 9257:	dos_command_running = 1;
        -: 9258:	proc_return = system (cmdline);
        -: 9259:	environ = parent_environ;
        -: 9260:	execute_by_shell = 0;	/* for the next time */
        -: 9261:      }
        -: 9262:    else
        -: 9263:      {
        -: 9264:	dos_command_running = 1;
        -: 9265:	proc_return = spawnvpe (P_WAIT, argv[0], argv, child->environment);
        -: 9266:      }
        -: 9267:
        -: 9268:    /* Need to unblock signals before turning off
        -: 9269:       dos_command_running, so that child's signals
        -: 9270:       will be treated as such (see fatal_error_signal).  */
        -: 9271:    unblock_sigs ();
        -: 9272:    dos_command_running = 0;
        -: 9273:
        -: 9274:    /* If the child got a signal, dos_status has its
        -: 9275:       high 8 bits set, so be careful not to alter them.  */
        -: 9276:    if (proc_return == -1)
        -: 9277:      dos_status |= 0xff;
        -: 9278:    else
        -: 9279:      dos_status |= (proc_return & 0xff);
        -: 9280:    ++dead_children;
        -: 9281:    child->pid = dos_pid++;
        -: 9282:  }
        -: 9283:#endif /* __MSDOS__ */
        -: 9284:#ifdef _AMIGA
        -: 9285:  amiga_status = MyExecute (argv);
        -: 9286:
        -: 9287:  ++dead_children;
        -: 9288:  child->pid = amiga_pid++;
        -: 9289:  if (amiga_batch_file)
        -: 9290:  {
        -: 9291:     amiga_batch_file = 0;
        -: 9292:     DeleteFile (amiga_bname);        /* Ignore errors.  */
        -: 9293:  }
        -: 9294:#endif	/* Amiga */
        -: 9295:#ifdef WINDOWS32
        -: 9296:  {
        -: 9297:      HANDLE hPID;
        -: 9298:      char* arg0;
        -: 9299:
        -: 9300:      /* make UNC paths safe for CreateProcess -- backslash format */
        -: 9301:      arg0 = argv[0];
        -: 9302:      if (arg0 && arg0[0] == '/' && arg0[1] == '/')
        -: 9303:        for ( ; arg0 && *arg0; arg0++)
        -: 9304:          if (*arg0 == '/')
        -: 9305:            *arg0 = '\\';
        -: 9306:
        -: 9307:      /* make sure CreateProcess() has Path it needs */
        -: 9308:      sync_Path_environment();
        -: 9309:
        -: 9310:      hPID = process_easy(argv, child->environment);
        -: 9311:
        -: 9312:      if (hPID != INVALID_HANDLE_VALUE)
        -: 9313:        child->pid = (int) hPID;
        -: 9314:      else {
        -: 9315:        int i;
        -: 9316:        unblock_sigs();
        -: 9317:        fprintf(stderr,
        -: 9318:          _("process_easy() failed failed to launch process (e=%d)\n"),
        -: 9319:          process_last_err(hPID));
        -: 9320:               for (i = 0; argv[i]; i++)
        -: 9321:                 fprintf(stderr, "%s ", argv[i]);
        -: 9322:               fprintf(stderr, _("\nCounted %d args in failed launch\n"), i);
        -: 9323:      }
        -: 9324:  }
        -: 9325:#endif /* WINDOWS32 */
        -: 9326:#endif	/* __MSDOS__ or Amiga or WINDOWS32 */
        -: 9327:
        -: 9328:  /* We are the parent side.  Set the state to
        -: 9329:     say the commands are running and return.  */
        -: 9330:
    #####: 9331:  set_command_state (child->file, cs_running);
call    0 never executed
        -: 9332:
        -: 9333:  /* Free the storage used by the child's argument list.  */
        -: 9334:#ifndef VMS
    #####: 9335:  free (argv[0]);
    #####: 9336:  free ((char *) argv);
        -: 9337:#endif
        -: 9338:
    #####: 9339:  return;
        -: 9340:
    #####: 9341: error:
    #####: 9342:  child->file->update_status = 2;
    #####: 9343:  notice_finished_file (child->file);
call    0 never executed
    #####: 9344:  return;
        -: 9345:}
        -: 9346:
        -: 9347:/* Try to start a child running.
        -: 9348:   Returns nonzero if the child was started (and maybe finished), or zero if
        -: 9349:   the load was too high and the child was put on the `waiting_jobs' chain.  */
        -: 9350:
        -: 9351:static int
function start_waiting_job called 0 returned 0% blocks executed 0%
    #####: 9352:start_waiting_job (c)
        -: 9353:     struct child *c;
        -: 9354:{
    #####: 9355:  struct file *f = c->file;
        -: 9356:
        -: 9357:  /* If we can start a job remotely, we always want to, and don't care about
        -: 9358:     the local load average.  We record that the job should be started
        -: 9359:     remotely in C->remote for start_job_command to test.  */
        -: 9360:
    #####: 9361:  c->remote = start_remote_job_p (1);
call    0 never executed
        -: 9362:
        -: 9363:  /* If we are running at least one job already and the load average
        -: 9364:     is too high, make this one wait.  */
    #####: 9365:  if (!c->remote && job_slots_used > 0 && load_too_high ())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
        -: 9366:    {
        -: 9367:      /* Put this child on the chain of children waiting for the load average
        -: 9368:         to go down.  */
    #####: 9369:      set_command_state (f, cs_running);
call    0 never executed
    #####: 9370:      c->next = waiting_jobs;
    #####: 9371:      waiting_jobs = c;
    #####: 9372:      return 0;
        -: 9373:    }
        -: 9374:
        -: 9375:  /* Start the first command; reap_children will run later command lines.  */
    #####: 9376:  start_job_command (c);
call    0 never executed
        -: 9377:
    #####: 9378:  switch (f->command_state)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 9379:    {
    #####: 9380:    case cs_running:
    #####: 9381:      c->next = children;
    #####: 9382:      DB (DB_JOBS, (_("Putting child 0x%08lx (%s) PID %ld%s on the chain.\n"),
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
        -: 9383:                    (unsigned long int) c, c->file->name,
        -: 9384:                    (long) c->pid, c->remote ? _(" (remote)") : ""));
    #####: 9385:      children = c;
        -: 9386:      /* One more job slot is in use.  */
    #####: 9387:      ++job_slots_used;
    #####: 9388:      unblock_sigs ();
call    0 never executed
    #####: 9389:      break;
        -: 9390:
    #####: 9391:    case cs_not_started:
        -: 9392:      /* All the command lines turned out to be empty.  */
    #####: 9393:      f->update_status = 0;
        -: 9394:      /* FALLTHROUGH */
        -: 9395:
    #####: 9396:    case cs_finished:
    #####: 9397:      notice_finished_file (f);
call    0 never executed
    #####: 9398:      free_child (c);
call    0 never executed
    #####: 9399:      break;
        -: 9400:
    #####: 9401:    default:
    #####: 9402:      assert (f->command_state == cs_finished);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 9403:      break;
        -: 9404:    }
        -: 9405:
    #####: 9406:  return 1;
        -: 9407:}
        -: 9408:
        -: 9409:/* Create a `struct child' for FILE and start its commands running.  */
        -: 9410:
        -: 9411:void
function new_job called 0 returned 0% blocks executed 0%
    #####: 9412:new_job (file)
        -: 9413:     register struct file *file;
        -: 9414:{
    #####: 9415:  register struct commands *cmds = file->cmds;
        -: 9416:  register struct child *c;
        -: 9417:  char **lines;
        -: 9418:  register unsigned int i;
        -: 9419:
        -: 9420:  /* Let any previously decided-upon jobs that are waiting
        -: 9421:     for the load to go down start before this new one.  */
    #####: 9422:  start_waiting_jobs ();
call    0 never executed
        -: 9423:
        -: 9424:  /* Reap any children that might have finished recently.  */
    #####: 9425:  reap_children (0, 0);
call    0 never executed
        -: 9426:
        -: 9427:  /* Chop the commands up into lines if they aren't already.  */
    #####: 9428:  chop_commands (cmds);
call    0 never executed
        -: 9429:
        -: 9430:  /* Expand the command lines and store the results in LINES.  */
    #####: 9431:  lines = (char **) xmalloc (cmds->ncommand_lines * sizeof (char *));
call    0 never executed
    #####: 9432:  for (i = 0; i < cmds->ncommand_lines; ++i)
branch  0 never executed
branch  1 never executed
        -: 9433:    {
        -: 9434:      /* Collapse backslash-newline combinations that are inside variable
        -: 9435:	 or function references.  These are left alone by the parser so
        -: 9436:	 that they will appear in the echoing of commands (where they look
        -: 9437:	 nice); and collapsed by construct_command_argv when it tokenizes.
        -: 9438:	 But letting them survive inside function invocations loses because
        -: 9439:	 we don't want the functions to see them as part of the text.  */
        -: 9440:
        -: 9441:      char *in, *out, *ref;
        -: 9442:
        -: 9443:      /* IN points to where in the line we are scanning.
        -: 9444:	 OUT points to where in the line we are writing.
        -: 9445:	 When we collapse a backslash-newline combination,
        -: 9446:	 IN gets ahead of OUT.  */
        -: 9447:
    #####: 9448:      in = out = cmds->command_lines[i];
    #####: 9449:      while ((ref = strchr (in, '$')) != 0)
branch  0 never executed
branch  1 never executed
        -: 9450:	{
    #####: 9451:	  ++ref;		/* Move past the $.  */
        -: 9452:
    #####: 9453:	  if (out != in)
branch  0 never executed
branch  1 never executed
        -: 9454:	    /* Copy the text between the end of the last chunk
        -: 9455:	       we processed (where IN points) and the new chunk
        -: 9456:	       we are about to process (where REF points).  */
    #####: 9457:	    bcopy (in, out, ref - in);
        -: 9458:
        -: 9459:	  /* Move both pointers past the boring stuff.  */
    #####: 9460:	  out += ref - in;
    #####: 9461:	  in = ref;
        -: 9462:
    #####: 9463:	  if (*ref == '(' || *ref == '{')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 9464:	    {
    #####: 9465:	      char openparen = *ref;
    #####: 9466:	      char closeparen = openparen == '(' ? ')' : '}';
branch  0 never executed
branch  1 never executed
        -: 9467:	      int count;
        -: 9468:	      char *p;
        -: 9469:
    #####: 9470:	      *out++ = *in++;	/* Copy OPENPAREN.  */
        -: 9471:	      /* IN now points past the opening paren or brace.
        -: 9472:		 Count parens or braces until it is matched.  */
    #####: 9473:	      count = 0;
    #####: 9474:	      while (*in != '\0')
branch  0 never executed
branch  1 never executed
        -: 9475:		{
    #####: 9476:		  if (*in == closeparen && --count < 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 9477:		    break;
    #####: 9478:		  else if (*in == '\\' && in[1] == '\n')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 9479:		    {
        -: 9480:		      /* We have found a backslash-newline inside a
        -: 9481:			 variable or function reference.  Eat it and
        -: 9482:			 any following whitespace.  */
        -: 9483:
    #####: 9484:		      int quoted = 0;
    #####: 9485:		      for (p = in - 1; p > ref && *p == '\\'; --p)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 9486:			quoted = !quoted;
        -: 9487:
    #####: 9488:		      if (quoted)
branch  0 never executed
branch  1 never executed
        -: 9489:			/* There were two or more backslashes, so this is
        -: 9490:			   not really a continuation line.  We don't collapse
        -: 9491:			   the quoting backslashes here as is done in
        -: 9492:			   collapse_continuations, because the line will
        -: 9493:			   be collapsed again after expansion.  */
    #####: 9494:			*out++ = *in++;
        -: 9495:		      else
        -: 9496:			{
        -: 9497:			  /* Skip the backslash, newline and
        -: 9498:			     any following whitespace.  */
    #####: 9499:			  in = next_token (in + 2);
call    0 never executed
        -: 9500:
        -: 9501:			  /* Discard any preceding whitespace that has
        -: 9502:			     already been written to the output.  */
    #####: 9503:			  while (out > ref && isblank (out[-1]))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 9504:			    --out;
        -: 9505:
        -: 9506:			  /* Replace it all with a single space.  */
    #####: 9507:			  *out++ = ' ';
        -: 9508:			}
        -: 9509:		    }
        -: 9510:		  else
        -: 9511:		    {
    #####: 9512:		      if (*in == openparen)
branch  0 never executed
branch  1 never executed
    #####: 9513:			++count;
        -: 9514:
    #####: 9515:		      *out++ = *in++;
        -: 9516:		    }
        -: 9517:		}
        -: 9518:	    }
        -: 9519:	}
        -: 9520:
        -: 9521:      /* There are no more references in this line to worry about.
        -: 9522:	 Copy the remaining uninteresting text to the output.  */
    #####: 9523:      if (out != in)
branch  0 never executed
branch  1 never executed
    #####: 9524:	strcpy (out, in);
        -: 9525:
        -: 9526:      /* Finally, expand the line.  */
    #####: 9527:      lines[i] = allocated_variable_expand_for_file (cmds->command_lines[i],
call    0 never executed
        -: 9528:						     file);
        -: 9529:    }
        -: 9530:
        -: 9531:  /* Start the command sequence, record it in a new
        -: 9532:     `struct child', and add that to the chain.  */
        -: 9533:
    #####: 9534:  c = (struct child *) xmalloc (sizeof (struct child));
call    0 never executed
    #####: 9535:  bzero ((char *)c, sizeof (struct child));
    #####: 9536:  c->file = file;
    #####: 9537:  c->command_lines = lines;
    #####: 9538:  c->sh_batch_file = NULL;
        -: 9539:
        -: 9540:  /* Fetch the first command line to be run.  */
    #####: 9541:  job_next_command (c);
call    0 never executed
        -: 9542:
        -: 9543:  /* Wait for a job slot to be freed up.  If we allow an infinite number
        -: 9544:     don't bother; also job_slots will == 0 if we're using the jobserver.  */
        -: 9545:
    #####: 9546:  if (job_slots != 0)
branch  0 never executed
branch  1 never executed
    #####: 9547:    while (job_slots_used == job_slots)
branch  0 never executed
branch  1 never executed
    #####: 9548:      reap_children (1, 0);
call    0 never executed
        -: 9549:
        -: 9550:#ifdef MAKE_JOBSERVER
        -: 9551:  /* If we are controlling multiple jobs make sure we have a token before
        -: 9552:     starting the child. */
        -: 9553:
        -: 9554:  /* This can be inefficient.  There's a decent chance that this job won't
        -: 9555:     actually have to run any subprocesses: the command script may be empty
        -: 9556:     or otherwise optimized away.  It would be nice if we could defer
        -: 9557:     obtaining a token until just before we need it, in start_job_command.
        -: 9558:     To do that we'd need to keep track of whether we'd already obtained a
        -: 9559:     token (since start_job_command is called for each line of the job, not
        -: 9560:     just once).  Also more thought needs to go into the entire algorithm;
        -: 9561:     this is where the old parallel job code waits, so...  */
        -: 9562:
    #####: 9563:  else if (job_fds[0] >= 0)
branch  0 never executed
branch  1 never executed
        -: 9564:    while (1)
    #####: 9565:      {
        -: 9566:        char token;
        -: 9567:
        -: 9568:        /* If we don't already have a job started, use our "free" token.  */
    #####: 9569:        if (!children)
branch  0 never executed
branch  1 never executed
    #####: 9570:          break;
        -: 9571:
        -: 9572:        /* Read a token.  As long as there's no token available we'll block.
        -: 9573:           If we get a SIGCHLD we'll return with EINTR.  If one happened
        -: 9574:           before we got here we'll return immediately with EBADF because
        -: 9575:           the signal handler closes the dup'd file descriptor.  */
        -: 9576:
    #####: 9577:        if (read (job_rfd, &token, 1) == 1)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 9578:          {
    #####: 9579:            DB (DB_JOBS, (_("Obtained token for child 0x%08lx (%s).\n"),
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
        -: 9580:                          (unsigned long int) c, c->file->name));
    #####: 9581:            break;
        -: 9582:          }
        -: 9583:
    #####: 9584:        if (errno != EINTR && errno != EBADF)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 9585:          pfatal_with_name (_("read jobs pipe"));
call    0 never executed
        -: 9586:
        -: 9587:        /* Re-dup the read side of the pipe, so the signal handler can
        -: 9588:           notify us if we miss a child.  */
    #####: 9589:        if (job_rfd < 0)
branch  0 never executed
branch  1 never executed
    #####: 9590:          job_rfd = dup (job_fds[0]);
call    0 never executed
        -: 9591:
        -: 9592:        /* Something's done.  We don't want to block for a whole child,
        -: 9593:           just reap whatever's there.  */
    #####: 9594:        reap_children (0, 0);
call    0 never executed
        -: 9595:      }
        -: 9596:#endif
        -: 9597:
        -: 9598:  /* The job is now primed.  Start it running.
        -: 9599:     (This will notice if there are in fact no commands.)  */
    #####: 9600:  (void) start_waiting_job (c);
call    0 never executed
        -: 9601:
    #####: 9602:  if (job_slots == 1 || not_parallel)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 9603:    /* Since there is only one job slot, make things run linearly.
        -: 9604:       Wait for the child to die, setting the state to `cs_finished'.  */
    #####: 9605:    while (file->command_state == cs_running)
branch  0 never executed
branch  1 never executed
    #####: 9606:      reap_children (1, 0);
call    0 never executed
        -: 9607:
    #####: 9608:  return;
        -: 9609:}
        -: 9610:
        -: 9611:/* Move CHILD's pointers to the next command for it to execute.
        -: 9612:   Returns nonzero if there is another command.  */
        -: 9613:
        -: 9614:static int
function job_next_command called 0 returned 0% blocks executed 0%
    #####: 9615:job_next_command (child)
        -: 9616:     struct child *child;
        -: 9617:{
    #####: 9618:  while (child->command_ptr == 0 || *child->command_ptr == '\0')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 9619:    {
        -: 9620:      /* There are no more lines in the expansion of this line.  */
    #####: 9621:      if (child->command_line == child->file->cmds->ncommand_lines)
branch  0 never executed
branch  1 never executed
        -: 9622:	{
        -: 9623:	  /* There are no more lines to be expanded.  */
    #####: 9624:	  child->command_ptr = 0;
    #####: 9625:	  return 0;
        -: 9626:	}
        -: 9627:      else
        -: 9628:	/* Get the next line to run.  */
    #####: 9629:	child->command_ptr = child->command_lines[child->command_line++];
        -: 9630:    }
    #####: 9631:  return 1;
        -: 9632:}
        -: 9633:
        -: 9634:static int
function load_too_high called 0 returned 0% blocks executed 0%
    #####: 9635:load_too_high ()
        -: 9636:{
        -: 9637:#if defined(__MSDOS__) || defined(VMS) || defined(_AMIGA)
        -: 9638:  return 1;
        -: 9639:#else
        -: 9640:  double load;
        -: 9641:
    #####: 9642:  if (max_load_average < 0)
branch  0 never executed
branch  1 never executed
    #####: 9643:    return 0;
        -: 9644:
    #####: 9645:  make_access ();
call    0 never executed
    #####: 9646:  if (getloadavg (&load, 1) != 1)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 9647:    {
        -: 9648:      static int lossage = -1;
        -: 9649:      /* Complain only once for the same error.  */
    #####: 9650:      if (lossage == -1 || errno != lossage)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 9651:	{
    #####: 9652:	  if (errno == 0)
branch  0 never executed
branch  1 never executed
        -: 9653:	    /* An errno value of zero means getloadavg is just unsupported.  */
    #####: 9654:	    error (NILF,
    #####: 9655:                   _("cannot enforce load limits on this operating system"));
call    0 never executed
        -: 9656:	  else
    #####: 9657:	    perror_with_name (_("cannot enforce load limit: "), "getloadavg");
call    0 never executed
        -: 9658:	}
    #####: 9659:      lossage = errno;
    #####: 9660:      load = 0;
        -: 9661:    }
    #####: 9662:  user_access ();
call    0 never executed
        -: 9663:
    #####: 9664:  return load >= max_load_average;
        -: 9665:#endif
        -: 9666:}
        -: 9667:
        -: 9668:/* Start jobs that are waiting for the load to be lower.  */
        -: 9669:
        -: 9670:void
function start_waiting_jobs called 1 returned 100% blocks executed 38%
        1: 9671:start_waiting_jobs ()
        -: 9672:{
        -: 9673:  struct child *job;
        -: 9674:
        1: 9675:  if (waiting_jobs == 0)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 9676:    return;
        -: 9677:
        -: 9678:  do
        -: 9679:    {
        -: 9680:      /* Check for recently deceased descendants.  */
    #####: 9681:      reap_children (0, 0);
call    0 never executed
        -: 9682:
        -: 9683:      /* Take a job off the waiting list.  */
    #####: 9684:      job = waiting_jobs;
    #####: 9685:      waiting_jobs = job->next;
        -: 9686:
        -: 9687:      /* Try to start that job.  We break out of the loop as soon
        -: 9688:	 as start_waiting_job puts one back on the waiting list.  */
        -: 9689:    }
    #####: 9690:  while (start_waiting_job (job) && waiting_jobs != 0);
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -: 9691:
    #####: 9692:  return;
        -: 9693:}
        -: 9694:
        -: 9695:#ifndef WINDOWS32
        -: 9696:#ifdef VMS
        -: 9697:#include <descrip.h>
        -: 9698:#include <clidef.h>
        -: 9699:#undef stderr
        -: 9700:#define stderr stdout
        -: 9701:
        -: 9702:/* This is called as an AST when a child process dies (it won't get
        -: 9703:   interrupted by anything except a higher level AST).
        -: 9704:*/
        -: 9705:int vmsHandleChildTerm(struct child *child)
        -: 9706:{
        -: 9707:    int status;
        -: 9708:    register struct child *lastc, *c;
        -: 9709:    int child_failed;
        -: 9710:
        -: 9711:    vms_jobsefnmask &= ~(1 << (child->efn - 32));
        -: 9712:
        -: 9713:    lib$free_ef(&child->efn);
        -: 9714:
        -: 9715:    (void) sigblock (fatal_signal_mask);
        -: 9716:
        -: 9717:    child_failed = !(child->cstatus & 1 || ((child->cstatus & 7) == 0));
        -: 9718:
        -: 9719:    /* Search for a child matching the deceased one.  */
        -: 9720:    lastc = 0;
        -: 9721:#if defined(RECURSIVEJOBS) /* I've had problems with recursive stuff and process handling */
        -: 9722:    for (c = children; c != 0 && c != child; lastc = c, c = c->next);
        -: 9723:#else
        -: 9724:    c = child;
        -: 9725:#endif
        -: 9726:
        -: 9727:    if (child_failed && !c->noerror && !ignore_errors_flag)
        -: 9728:      {
        -: 9729:	/* The commands failed.  Write an error message,
        -: 9730:	   delete non-precious targets, and abort.  */
        -: 9731:	child_error (c->file->name, c->cstatus, 0, 0, 0);
        -: 9732:	c->file->update_status = 1;
        -: 9733:	delete_child_targets (c);
        -: 9734:      }
        -: 9735:    else
        -: 9736:      {
        -: 9737:	if (child_failed)
        -: 9738:	  {
        -: 9739:	    /* The commands failed, but we don't care.  */
        -: 9740:	    child_error (c->file->name, c->cstatus, 0, 0, 1);
        -: 9741:	    child_failed = 0;
        -: 9742:	  }
        -: 9743:
        -: 9744:#if defined(RECURSIVEJOBS) /* I've had problems with recursive stuff and process handling */
        -: 9745:	/* If there are more commands to run, try to start them.  */
        -: 9746:	start_job (c);
        -: 9747:
        -: 9748:	switch (c->file->command_state)
        -: 9749:	  {
        -: 9750:	  case cs_running:
        -: 9751:	    /* Successfully started.  */
        -: 9752:	    break;
        -: 9753:
        -: 9754:	  case cs_finished:
        -: 9755:	    if (c->file->update_status != 0) {
        -: 9756:		/* We failed to start the commands.  */
        -: 9757:		delete_child_targets (c);
        -: 9758:	    }
        -: 9759:	    break;
        -: 9760:
        -: 9761:	  default:
        -: 9762:	    error (NILF, _("internal error: `%s' command_state"),
        -: 9763:                   c->file->name);
        -: 9764:	    abort ();
        -: 9765:	    break;
        -: 9766:	  }
        -: 9767:#endif /* RECURSIVEJOBS */
        -: 9768:      }
        -: 9769:
        -: 9770:    /* Set the state flag to say the commands have finished.  */
        -: 9771:    c->file->command_state = cs_finished;
        -: 9772:    notice_finished_file (c->file);
        -: 9773:
        -: 9774:#if defined(RECURSIVEJOBS) /* I've had problems with recursive stuff and process handling */
        -: 9775:    /* Remove the child from the chain and free it.  */
        -: 9776:    if (lastc == 0)
        -: 9777:      children = c->next;
        -: 9778:    else
        -: 9779:      lastc->next = c->next;
        -: 9780:    free_child (c);
        -: 9781:#endif /* RECURSIVEJOBS */
        -: 9782:
        -: 9783:    /* There is now another slot open.  */
        -: 9784:    if (job_slots_used > 0)
        -: 9785:      --job_slots_used;
        -: 9786:
        -: 9787:    /* If the job failed, and the -k flag was not given, die.  */
        -: 9788:    if (child_failed && !keep_going_flag)
        -: 9789:      die (EXIT_FAILURE);
        -: 9790:
        -: 9791:    (void) sigsetmask (sigblock (0) & ~(fatal_signal_mask));
        -: 9792:
        -: 9793:    return 1;
        -: 9794:}
        -: 9795:
        -: 9796:/* VMS:
        -: 9797:   Spawn a process executing the command in ARGV and return its pid. */
        -: 9798:
        -: 9799:#define MAXCMDLEN 200
        -: 9800:
        -: 9801:/* local helpers to make ctrl+c and ctrl+y working, see below */
        -: 9802:#include <iodef.h>
        -: 9803:#include <libclidef.h>
        -: 9804:#include <ssdef.h>
        -: 9805:#undef stderr
        -: 9806:#define stderr stdout
        -: 9807:
        -: 9808:static int ctrlMask= LIB$M_CLI_CTRLY;
        -: 9809:static int oldCtrlMask;
        -: 9810:static int setupYAstTried= 0;
        -: 9811:static int pidToAbort= 0;
        -: 9812:static int chan= 0;
        -: 9813:
        -: 9814:static void reEnableAst(void) {
        -: 9815:	lib$enable_ctrl (&oldCtrlMask,0);
        -: 9816:}
        -: 9817:
        -: 9818:static astHandler (void) {
        -: 9819:	if (pidToAbort) {
        -: 9820:		sys$forcex (&pidToAbort, 0, SS$_ABORT);
        -: 9821:		pidToAbort= 0;
        -: 9822:	}
        -: 9823:	kill (getpid(),SIGQUIT);
        -: 9824:}
        -: 9825:
        -: 9826:static void tryToSetupYAst(void) {
        -: 9827:	$DESCRIPTOR(inputDsc,"SYS$COMMAND");
        -: 9828:	int	status;
        -: 9829:	struct {
        -: 9830:		short int	status, count;
        -: 9831:		int	dvi;
        -: 9832:	} iosb;
        -: 9833:
        -: 9834:	setupYAstTried++;
        -: 9835:
        -: 9836:	if (!chan) {
        -: 9837:		status= sys$assign(&inputDsc,&chan,0,0);
        -: 9838:		if (!(status&SS$_NORMAL)) {
        -: 9839:			lib$signal(status);
        -: 9840:			return;
        -: 9841:		}
        -: 9842:	}
        -: 9843:	status= sys$qiow (0, chan, IO$_SETMODE|IO$M_CTRLYAST,&iosb,0,0,
        -: 9844:		astHandler,0,0,0,0,0);
        -: 9845:	if (status==SS$_ILLIOFUNC) {
        -: 9846:		sys$dassgn(chan);
        -: 9847:#ifdef	CTRLY_ENABLED_ANYWAY
        -: 9848:		fprintf (stderr,
        -: 9849:                         _("-warning, CTRL-Y will leave sub-process(es) around.\n"));
        -: 9850:#else
        -: 9851:		return;
        -: 9852:#endif
        -: 9853:	}
        -: 9854:	if (status==SS$_NORMAL)
        -: 9855:		status= iosb.status;
        -: 9856:	if (!(status&SS$_NORMAL)) {
        -: 9857:		lib$signal(status);
        -: 9858:		return;
        -: 9859:	}
        -: 9860:
        -: 9861:	/* called from AST handler ? */
        -: 9862:	if (setupYAstTried>1)
        -: 9863:		return;
        -: 9864:	if (atexit(reEnableAst))
        -: 9865:		fprintf (stderr,
        -: 9866:                         _("-warning, you may have to re-enable CTRL-Y handling from DCL.\n"));
        -: 9867:	status= lib$disable_ctrl (&ctrlMask, &oldCtrlMask);
        -: 9868:	if (!(status&SS$_NORMAL)) {
        -: 9869:		lib$signal(status);
        -: 9870:		return;
        -: 9871:	}
        -: 9872:}
        -: 9873:int
        -: 9874:child_execute_job (argv, child)
        -: 9875:     char *argv;
        -: 9876:     struct child *child;
        -: 9877:{
        -: 9878:  int i;
        -: 9879:  static struct dsc$descriptor_s cmddsc;
        -: 9880:  static struct dsc$descriptor_s pnamedsc;
        -: 9881:  static struct dsc$descriptor_s ifiledsc;
        -: 9882:  static struct dsc$descriptor_s ofiledsc;
        -: 9883:  static struct dsc$descriptor_s efiledsc;
        -: 9884:  int have_redirection = 0;
        -: 9885:  int have_newline = 0;
        -: 9886:
        -: 9887:  int spflags = CLI$M_NOWAIT;
        -: 9888:  int status;
        -: 9889:  char *cmd = alloca (strlen (argv) + 512), *p, *q;
        -: 9890:  char ifile[256], ofile[256], efile[256];
        -: 9891:  char *comname = 0;
        -: 9892:  char procname[100];
        -: 9893:
        -: 9894:  /* Parse IO redirection.  */
        -: 9895:
        -: 9896:  ifile[0] = 0;
        -: 9897:  ofile[0] = 0;
        -: 9898:  efile[0] = 0;
        -: 9899:
        -: 9900:  DB (DB_JOBS, ("child_execute_job (%s)\n", argv));
        -: 9901:
        -: 9902:  while (isspace (*argv))
        -: 9903:    argv++;
        -: 9904:
        -: 9905:  if (*argv == 0)
        -: 9906:    return 0;
        -: 9907:
        -: 9908:  sprintf (procname, "GMAKE_%05x", getpid () & 0xfffff);
        -: 9909:  pnamedsc.dsc$w_length = strlen(procname);
        -: 9910:  pnamedsc.dsc$a_pointer = procname;
        -: 9911:  pnamedsc.dsc$b_dtype = DSC$K_DTYPE_T;
        -: 9912:  pnamedsc.dsc$b_class = DSC$K_CLASS_S;
        -: 9913:
        -: 9914:  /* Handle comments and redirection. */
        -: 9915:  for (p = argv, q = cmd; *p; p++, q++)
        -: 9916:    {
        -: 9917:      switch (*p)
        -: 9918:	{
        -: 9919:	  case '#':
        -: 9920:	    *p-- = 0;
        -: 9921:	    *q-- = 0;
        -: 9922:	    break;
        -: 9923:	  case '\\':
        -: 9924:	    p++;
        -: 9925:	    if (*p == '\n')
        -: 9926:	      p++;
        -: 9927:	    if (isspace (*p))
        -: 9928:	      {
        -: 9929:		do { p++; } while (isspace (*p));
        -: 9930:		p--;
        -: 9931:	      }
        -: 9932:	    *q = *p;
        -: 9933:	    break;
        -: 9934:	  case '<':
        -: 9935:	    p = vms_redirect (&ifiledsc, ifile, p);
        -: 9936:	    *q = ' ';
        -: 9937:	    have_redirection = 1;
        -: 9938:	    break;
        -: 9939:	  case '>':
        -: 9940:	    have_redirection = 1;
        -: 9941:	    if (*(p-1) == '2')
        -: 9942:	      {
        -: 9943:		q--;
        -: 9944:		if (strncmp (p, ">&1", 3) == 0)
        -: 9945:		  {
        -: 9946:		    p += 3;
        -: 9947:		    strcpy (efile, "sys$output");
        -: 9948:		    efiledsc.dsc$w_length = strlen(efile);
        -: 9949:		    efiledsc.dsc$a_pointer = efile;
        -: 9950:		    efiledsc.dsc$b_dtype = DSC$K_DTYPE_T;
        -: 9951:		    efiledsc.dsc$b_class = DSC$K_CLASS_S;
        -: 9952:		  }
        -: 9953:		else
        -: 9954:		  {
        -: 9955:		    p = vms_redirect (&efiledsc, efile, p);
        -: 9956:		  }
        -: 9957:	      }
        -: 9958:	    else
        -: 9959:	      {
        -: 9960:		p = vms_redirect (&ofiledsc, ofile, p);
        -: 9961:	      }
        -: 9962:	    *q = ' ';
        -: 9963:	    break;
        -: 9964:	  case '\n':
        -: 9965:	    have_newline = 1;
        -: 9966:	  default:
        -: 9967:	    *q = *p;
        -: 9968:	    break;
        -: 9969:	}
        -: 9970:    }
        -: 9971:  *q = *p;
        -: 9972:
        -: 9973:  if (strncmp (cmd, "builtin_", 8) == 0)
        -: 9974:    {
        -: 9975:      child->pid = 270163;
        -: 9976:      child->efn = 0;
        -: 9977:      child->cstatus = 1;
        -: 9978:
        -: 9979:      DB (DB_JOBS, (_("BUILTIN [%s][%s]\n"), cmd, cmd+8));
        -: 9980:
        -: 9981:      p = cmd + 8;
        -: 9982:
        -: 9983:      if ((*(p) == 'c')
        -: 9984:	  && (*(p+1) == 'd')
        -: 9985:	  && ((*(p+2) == ' ') || (*(p+2) == '\t')))
        -: 9986:	{
        -: 9987:	  p += 3;
        -: 9988:	  while ((*p == ' ') || (*p == '\t'))
        -: 9989:	    p++;
        -: 9990:	  DB (DB_JOBS, (_("BUILTIN CD %s\n"), p));
        -: 9991:	  if (chdir (p))
        -: 9992:	    return 0;
        -: 9993:	  else
        -: 9994:	    return 1;
        -: 9995:	}
        -: 9996:      else if ((*(p) == 'r')
        -: 9997:	  && (*(p+1) == 'm')
        -: 9998:	  && ((*(p+2) == ' ') || (*(p+2) == '\t')))
        -: 9999:	{
        -:10000:	  int in_arg;
        -:10001:
        -:10002:	  /* rm  */
        -:10003:	  p += 3;
        -:10004:	  while ((*p == ' ') || (*p == '\t'))
        -:10005:	    p++;
        -:10006:	  in_arg = 1;
        -:10007:
        -:10008:	  DB (DB_JOBS, (_("BUILTIN RM %s\n"), p));
        -:10009:	  while (*p)
        -:10010:	    {
        -:10011:	      switch (*p)
        -:10012:		{
        -:10013:		  case ' ':
        -:10014:		  case '\t':
        -:10015:		    if (in_arg)
        -:10016:		      {
        -:10017:			*p++ = ';';
        -:10018:			in_arg = 0;
        -:10019:		      }
        -:10020:		    break;
        -:10021:		  default:
        -:10022:		    break;
        -:10023:		}
        -:10024:	      p++;
        -:10025:	    }
        -:10026:	}
        -:10027:      else
        -:10028:	{
        -:10029:	  printf(_("Unknown builtin command '%s'\n"), cmd);
        -:10030:	  fflush(stdout);
        -:10031:	  return 0;
        -:10032:	}
        -:10033:    }
        -:10034:
        -:10035:  /* Create a *.com file if either the command is too long for
        -:10036:     lib$spawn, or the command contains a newline, or if redirection
        -:10037:     is desired. Forcing commands with newlines into DCLs allows to
        -:10038:     store search lists on user mode logicals.  */
        -:10039:
        -:10040:  if (strlen (cmd) > MAXCMDLEN
        -:10041:      || (have_redirection != 0)
        -:10042:      || (have_newline != 0))
        -:10043:    {
        -:10044:      FILE *outfile;
        -:10045:      char c;
        -:10046:      char *sep;
        -:10047:      int alevel = 0;	/* apostrophe level */
        -:10048:
        -:10049:      if (strlen (cmd) == 0)
        -:10050:	{
        -:10051:	  printf (_("Error, empty command\n"));
        -:10052:	  fflush (stdout);
        -:10053:	  return 0;
        -:10054:	}
        -:10055:
        -:10056:      outfile = open_tmpfile (&comname, "sys$scratch:CMDXXXXXX.COM");
        -:10057:      if (outfile == 0)
        -:10058:	pfatal_with_name (_("fopen (temporary file)"));
        -:10059:
        -:10060:      if (ifile[0])
        -:10061:	{
        -:10062:	  fprintf (outfile, "$ assign/user %s sys$input\n", ifile);
        -:10063:          DB (DB_JOBS, (_("Redirected input from %s\n"), ifile));
        -:10064:	  ifiledsc.dsc$w_length = 0;
        -:10065:	}
        -:10066:
        -:10067:      if (efile[0])
        -:10068:	{
        -:10069:	  fprintf (outfile, "$ define sys$error %s\n", efile);
        -:10070:          DB (DB_JOBS, (_("Redirected error to %s\n"), efile));
        -:10071:	  efiledsc.dsc$w_length = 0;
        -:10072:	}
        -:10073:
        -:10074:      if (ofile[0])
        -:10075:	{
        -:10076:	  fprintf (outfile, "$ define sys$output %s\n", ofile);
        -:10077:	  DB (DB_JOBS, (_("Redirected output to %s\n"), ofile));
        -:10078:	  ofiledsc.dsc$w_length = 0;
        -:10079:	}
        -:10080:
        -:10081:      p = sep = q = cmd;
        -:10082:      for (c = '\n'; c; c = *q++)
        -:10083:	{
        -:10084:	  switch (c)
        -:10085:	    {
        -:10086:            case '\n':
        -:10087:              /* At a newline, skip any whitespace around a leading $
        -:10088:                 from the command and issue exactly one $ into the DCL. */
        -:10089:              while (isspace (*p))
        -:10090:                p++;
        -:10091:              if (*p == '$')
        -:10092:                p++;
        -:10093:              while (isspace (*p))
        -:10094:                p++;
        -:10095:              fwrite (p, 1, q - p, outfile);
        -:10096:              fputc ('$', outfile);
        -:10097:              fputc (' ', outfile);
        -:10098:              /* Reset variables. */
        -:10099:              p = sep = q;
        -:10100:              break;
        -:10101:
        -:10102:	      /* Nice places for line breaks are after strings, after
        -:10103:		 comma or space and before slash. */
        -:10104:            case '"':
        -:10105:              q = handle_apos (q + 1);
        -:10106:              sep = q;
        -:10107:              break;
        -:10108:            case ',':
        -:10109:            case ' ':
        -:10110:              sep = q;
        -:10111:              break;
        -:10112:            case '/':
        -:10113:            case '\0':
        -:10114:              sep = q - 1;
        -:10115:              break;
        -:10116:            default:
        -:10117:              break;
        -:10118:	    }
        -:10119:	  if (sep - p > 78)
        -:10120:	    {
        -:10121:	      /* Enough stuff for a line. */
        -:10122:	      fwrite (p, 1, sep - p, outfile);
        -:10123:	      p = sep;
        -:10124:	      if (*sep)
        -:10125:		{
        -:10126:		  /* The command continues.  */
        -:10127:		  fputc ('-', outfile);
        -:10128:		}
        -:10129:	      fputc ('\n', outfile);
        -:10130:	    }
        -:10131:  	}
        -:10132:
        -:10133:      fwrite (p, 1, q - p, outfile);
        -:10134:      fputc ('\n', outfile);
        -:10135:
        -:10136:      fclose (outfile);
        -:10137:
        -:10138:      sprintf (cmd, "$ @%s", comname);
        -:10139:
        -:10140:      DB (DB_JOBS, (_("Executing %s instead\n"), cmd));
        -:10141:    }
        -:10142:
        -:10143:  cmddsc.dsc$w_length = strlen(cmd);
        -:10144:  cmddsc.dsc$a_pointer = cmd;
        -:10145:  cmddsc.dsc$b_dtype = DSC$K_DTYPE_T;
        -:10146:  cmddsc.dsc$b_class = DSC$K_CLASS_S;
        -:10147:
        -:10148:  child->efn = 0;
        -:10149:  while (child->efn < 32 || child->efn > 63)
        -:10150:    {
        -:10151:      status = lib$get_ef ((unsigned long *)&child->efn);
        -:10152:      if (!(status & 1))
        -:10153:	return 0;
        -:10154:    }
        -:10155:
        -:10156:  sys$clref (child->efn);
        -:10157:
        -:10158:  vms_jobsefnmask |= (1 << (child->efn - 32));
        -:10159:
        -:10160:/*
        -:10161:             LIB$SPAWN  [command-string]
        -:10162:			[,input-file]
        -:10163:			[,output-file]
        -:10164:			[,flags]
        -:10165:			[,process-name]
        -:10166:			[,process-id] [,completion-status-address] [,byte-integer-event-flag-num]
        -:10167:			[,AST-address] [,varying-AST-argument]
        -:10168:			[,prompt-string] [,cli] [,table]
        -:10169:*/
        -:10170:
        -:10171:#ifndef DONTWAITFORCHILD
        -:10172:/*
        -:10173: *	Code to make ctrl+c and ctrl+y working.
        -:10174: *	The problem starts with the synchronous case where after lib$spawn is
        -:10175: *	called any input will go to the child. But with input re-directed,
        -:10176: *	both control characters won't make it to any of the programs, neither
        -:10177: *	the spawning nor to the spawned one. Hence the caller needs to spawn
        -:10178: *	with CLI$M_NOWAIT to NOT give up the input focus. A sys$waitfr
        -:10179: *	has to follow to simulate the wanted synchronous behaviour.
        -:10180: *	The next problem is ctrl+y which isn't caught by the crtl and
        -:10181: *	therefore isn't converted to SIGQUIT (for a signal handler which is
        -:10182: *	already established). The only way to catch ctrl+y, is an AST
        -:10183: *	assigned to the input channel. But ctrl+y handling of DCL needs to be
        -:10184: *	disabled, otherwise it will handle it. Not to mention the previous
        -:10185: *	ctrl+y handling of DCL needs to be re-established before make exits.
        -:10186: *	One more: At the time of LIB$SPAWN signals are blocked. SIGQUIT will
        -:10187: *	make it to the signal handler after the child "normally" terminates.
        -:10188: *	This isn't enough. It seems reasonable for simple command lines like
        -:10189: *	a 'cc foobar.c' spawned in a subprocess but it is unacceptable for
        -:10190: *	spawning make. Therefore we need to abort the process in the AST.
        -:10191: *
        -:10192: *	Prior to the spawn it is checked if an AST is already set up for
        -:10193: *	ctrl+y, if not one is set up for a channel to SYS$COMMAND. In general
        -:10194: *	this will work except if make is run in a batch environment, but there
        -:10195: *	nobody can press ctrl+y. During the setup the DCL handling of ctrl+y
        -:10196: *	is disabled and an exit handler is established to re-enable it.
        -:10197: *	If the user interrupts with ctrl+y, the assigned AST will fire, force
        -:10198: *	an abort to the subprocess and signal SIGQUIT, which will be caught by
        -:10199: *	the already established handler and will bring us back to common code.
        -:10200: *	After the spawn (now /nowait) a sys$waitfr simulates the /wait and
        -:10201: *	enables the ctrl+y be delivered to this code. And the ctrl+c too,
        -:10202: *	which the crtl converts to SIGINT and which is caught by the common
        -:10203: *	signal handler. Because signals were blocked before entering this code
        -:10204: *	sys$waitfr will always complete and the SIGQUIT will be processed after
        -:10205: *	it (after termination of the current block, somewhere in common code).
        -:10206: *	And SIGINT too will be delayed. That is ctrl+c can only abort when the
        -:10207: *	current command completes. Anyway it's better than nothing :-)
        -:10208: */
        -:10209:
        -:10210:  if (!setupYAstTried)
        -:10211:    tryToSetupYAst();
        -:10212:  status = lib$spawn (&cmddsc,					/* cmd-string  */
        -:10213:		      (ifiledsc.dsc$w_length == 0)?0:&ifiledsc, /* input-file  */
        -:10214:		      (ofiledsc.dsc$w_length == 0)?0:&ofiledsc, /* output-file */
        -:10215:		      &spflags,					/* flags  */
        -:10216:		      &pnamedsc,				/* proc name  */
        -:10217:		      &child->pid, &child->cstatus, &child->efn,
        -:10218:		      0, 0,
        -:10219:		      0, 0, 0);
        -:10220:  pidToAbort= child->pid;
        -:10221:  status= sys$waitfr (child->efn);
        -:10222:  pidToAbort= 0;
        -:10223:  vmsHandleChildTerm(child);
        -:10224:#else
        -:10225:  status = lib$spawn (&cmddsc,
        -:10226:		      (ifiledsc.dsc$w_length == 0)?0:&ifiledsc,
        -:10227:		      (ofiledsc.dsc$w_length == 0)?0:&ofiledsc,
        -:10228:		      &spflags,
        -:10229:		      &pnamedsc,
        -:10230:		      &child->pid, &child->cstatus, &child->efn,
        -:10231:		      vmsHandleChildTerm, child,
        -:10232:		      0, 0, 0);
        -:10233:#endif
        -:10234:
        -:10235:  if (!(status & 1))
        -:10236:    {
        -:10237:      printf (_("Error spawning, %d\n") ,status);
        -:10238:      fflush (stdout);
        -:10239:    }
        -:10240:
        -:10241:  if (comname && !ISDB (DB_JOBS))
        -:10242:    unlink (comname);
        -:10243:
        -:10244:  return (status & 1);
        -:10245:}
        -:10246:
        -:10247:#else /* !VMS */
        -:10248:
        -:10249:#if !defined (_AMIGA) && !defined (__MSDOS__)
        -:10250:/* UNIX:
        -:10251:   Replace the current process with one executing the command in ARGV.
        -:10252:   STDIN_FD and STDOUT_FD are used as the process's stdin and stdout; ENVP is
        -:10253:   the environment of the new program.  This function does not return.  */
        -:10254:
        -:10255:void
function child_execute_job called 0 returned 0% blocks executed 0%
    #####:10256:child_execute_job (stdin_fd, stdout_fd, argv, envp)
        -:10257:     int stdin_fd, stdout_fd;
        -:10258:     char **argv, **envp;
        -:10259:{
    #####:10260:  if (stdin_fd != 0)
branch  0 never executed
branch  1 never executed
    #####:10261:    (void) dup2 (stdin_fd, 0);
call    0 never executed
    #####:10262:  if (stdout_fd != 1)
branch  0 never executed
branch  1 never executed
    #####:10263:    (void) dup2 (stdout_fd, 1);
call    0 never executed
    #####:10264:  if (stdin_fd != 0)
branch  0 never executed
branch  1 never executed
    #####:10265:    (void) close (stdin_fd);
call    0 never executed
    #####:10266:  if (stdout_fd != 1)
branch  0 never executed
branch  1 never executed
    #####:10267:    (void) close (stdout_fd);
call    0 never executed
        -:10268:
        -:10269:  /* Run the command.  */
    #####:10270:  exec_command (argv, envp);
call    0 never executed
    #####:10271:}
        -:10272:#endif /* !AMIGA && !__MSDOS__ */
        -:10273:#endif /* !VMS */
        -:10274:#endif /* !WINDOWS32 */
        -:10275:
        -:10276:#ifndef _AMIGA
        -:10277:/* Replace the current process with one running the command in ARGV,
        -:10278:   with environment ENVP.  This function does not return.  */
        -:10279:
        -:10280:void
function exec_command called 0 returned 0% blocks executed 0%
    #####:10281:exec_command (argv, envp)
        -:10282:     char **argv, **envp;
        -:10283:{
        -:10284:#ifdef VMS
        -:10285:  /* to work around a problem with signals and execve: ignore them */
        -:10286:#ifdef SIGCHLD
        -:10287:  signal (SIGCHLD,SIG_IGN);
        -:10288:#endif
        -:10289:  /* Run the program.  */
        -:10290:  execve (argv[0], argv, envp);
        -:10291:  perror_with_name ("execve: ", argv[0]);
        -:10292:  _exit (EXIT_FAILURE);
        -:10293:#else
        -:10294:#ifdef WINDOWS32
        -:10295:  HANDLE hPID;
        -:10296:  HANDLE hWaitPID;
        -:10297:  int err = 0;
        -:10298:  int exit_code = EXIT_FAILURE;
        -:10299:
        -:10300:  /* make sure CreateProcess() has Path it needs */
        -:10301:  sync_Path_environment();
        -:10302:
        -:10303:  /* launch command */
        -:10304:  hPID = process_easy(argv, envp);
        -:10305:
        -:10306:  /* make sure launch ok */
        -:10307:  if (hPID == INVALID_HANDLE_VALUE)
        -:10308:    {
        -:10309:      int i;
        -:10310:      fprintf(stderr,
        -:10311:              _("process_easy() failed failed to launch process (e=%d)\n"),
        -:10312:              process_last_err(hPID));
        -:10313:      for (i = 0; argv[i]; i++)
        -:10314:          fprintf(stderr, "%s ", argv[i]);
        -:10315:      fprintf(stderr, _("\nCounted %d args in failed launch\n"), i);
        -:10316:      exit(EXIT_FAILURE);
        -:10317:    }
        -:10318:
        -:10319:  /* wait and reap last child */
        -:10320:  while (hWaitPID = process_wait_for_any())
        -:10321:    {
        -:10322:      /* was an error found on this process? */
        -:10323:      err = process_last_err(hWaitPID);
        -:10324:
        -:10325:      /* get exit data */
        -:10326:      exit_code = process_exit_code(hWaitPID);
        -:10327:
        -:10328:      if (err)
        -:10329:          fprintf(stderr, "make (e=%d, rc=%d): %s",
        -:10330:                  err, exit_code, map_windows32_error_to_string(err));
        -:10331:
        -:10332:      /* cleanup process */
        -:10333:      process_cleanup(hWaitPID);
        -:10334:
        -:10335:      /* expect to find only last pid, warn about other pids reaped */
        -:10336:      if (hWaitPID == hPID)
        -:10337:          break;
        -:10338:      else
        -:10339:          fprintf(stderr,
        -:10340:                  _("make reaped child pid %d, still waiting for pid %d\n"),
        -:10341:                  hWaitPID, hPID);
        -:10342:    }
        -:10343:
        -:10344:  /* return child's exit code as our exit code */
        -:10345:  exit(exit_code);
        -:10346:
        -:10347:#else  /* !WINDOWS32 */
        -:10348:
        -:10349:  /* Be the user, permanently.  */
    #####:10350:  child_access ();
call    0 never executed
        -:10351:
        -:10352:  /* Run the program.  */
    #####:10353:  environ = envp;
    #####:10354:  execvp (argv[0], argv);
        -:10355:
    #####:10356:  switch (errno)
branch  0 never executed
branch  1 never executed
branch  2 never executed
        -:10357:    {
    #####:10358:    case ENOENT:
    #####:10359:      error (NILF, _("%s: Command not found"), argv[0]);
call    0 never executed
    #####:10360:      break;
    #####:10361:    case ENOEXEC:
        -:10362:      {
        -:10363:	/* The file is not executable.  Try it as a shell script.  */
        -:10364:	extern char *getenv ();
        -:10365:	char *shell;
        -:10366:	char **new_argv;
        -:10367:	int argc;
        -:10368:
    #####:10369:	shell = getenv ("SHELL");
call    0 never executed
    #####:10370:	if (shell == 0)
branch  0 never executed
branch  1 never executed
    #####:10371:	  shell = default_shell;
        -:10372:
    #####:10373:	argc = 1;
    #####:10374:	while (argv[argc] != 0)
branch  0 never executed
branch  1 never executed
    #####:10375:	  ++argc;
        -:10376:
    #####:10377:	new_argv = (char **) alloca ((1 + argc + 1) * sizeof (char *));
    #####:10378:	new_argv[0] = shell;
    #####:10379:	new_argv[1] = argv[0];
    #####:10380:	while (argc > 0)
branch  0 never executed
branch  1 never executed
        -:10381:	  {
    #####:10382:	    new_argv[1 + argc] = argv[argc];
    #####:10383:	    --argc;
        -:10384:	  }
        -:10385:
    #####:10386:	execvp (shell, new_argv);
    #####:10387:	if (errno == ENOENT)
branch  0 never executed
branch  1 never executed
    #####:10388:	  error (NILF, _("%s: Shell program not found"), shell);
call    0 never executed
        -:10389:	else
    #####:10390:	  perror_with_name ("execvp: ", shell);
call    0 never executed
    #####:10391:	break;
        -:10392:      }
        -:10393:
    #####:10394:    default:
    #####:10395:      perror_with_name ("execvp: ", argv[0]);
call    0 never executed
    #####:10396:      break;
        -:10397:    }
        -:10398:
    #####:10399:  _exit (127);
        -:10400:#endif /* !WINDOWS32 */
        -:10401:#endif /* !VMS */
        -:10402:}
        -:10403:#else /* On Amiga */
        -:10404:void exec_command (argv)
        -:10405:     char **argv;
        -:10406:{
        -:10407:  MyExecute (argv);
        -:10408:}
        -:10409:
        -:10410:void clean_tmp (void)
        -:10411:{
        -:10412:  DeleteFile (amiga_bname);
        -:10413:}
        -:10414:
        -:10415:#endif /* On Amiga */
        -:10416:
        -:10417:#ifndef VMS
        -:10418:/* Figure out the argument list necessary to run LINE as a command.  Try to
        -:10419:   avoid using a shell.  This routine handles only ' quoting, and " quoting
        -:10420:   when no backslash, $ or ` characters are seen in the quotes.  Starting
        -:10421:   quotes may be escaped with a backslash.  If any of the characters in
        -:10422:   sh_chars[] is seen, or any of the builtin commands listed in sh_cmds[]
        -:10423:   is the first word of a line, the shell is used.
        -:10424:
        -:10425:   If RESTP is not NULL, *RESTP is set to point to the first newline in LINE.
        -:10426:   If *RESTP is NULL, newlines will be ignored.
        -:10427:
        -:10428:   SHELL is the shell to use, or nil to use the default shell.
        -:10429:   IFS is the value of $IFS, or nil (meaning the default).  */
        -:10430:
        -:10431:static char **
function construct_command_argv_internal called 0 returned 0% blocks executed 0%
    #####:10432:construct_command_argv_internal (line, restp, shell, ifs, batch_filename_ptr)
        -:10433:     char *line, **restp;
        -:10434:     char *shell, *ifs;
        -:10435:     char **batch_filename_ptr;
        -:10436:{
        -:10437:#ifdef __MSDOS__
        -:10438:  /* MSDOS supports both the stock DOS shell and ports of Unixy shells.
        -:10439:     We call `system' for anything that requires ``slow'' processing,
        -:10440:     because DOS shells are too dumb.  When $SHELL points to a real
        -:10441:     (unix-style) shell, `system' just calls it to do everything.  When
        -:10442:     $SHELL points to a DOS shell, `system' does most of the work
        -:10443:     internally, calling the shell only for its internal commands.
        -:10444:     However, it looks on the $PATH first, so you can e.g. have an
        -:10445:     external command named `mkdir'.
        -:10446:
        -:10447:     Since we call `system', certain characters and commands below are
        -:10448:     actually not specific to COMMAND.COM, but to the DJGPP implementation
        -:10449:     of `system'.  In particular:
        -:10450:
        -:10451:       The shell wildcard characters are in DOS_CHARS because they will
        -:10452:       not be expanded if we call the child via `spawnXX'.
        -:10453:
        -:10454:       The `;' is in DOS_CHARS, because our `system' knows how to run
        -:10455:       multiple commands on a single line.
        -:10456:
        -:10457:       DOS_CHARS also include characters special to 4DOS/NDOS, so we
        -:10458:       won't have to tell one from another and have one more set of
        -:10459:       commands and special characters.  */
        -:10460:  static char sh_chars_dos[] = "*?[];|<>%^&()";
        -:10461:  static char *sh_cmds_dos[] = { "break", "call", "cd", "chcp", "chdir", "cls",
        -:10462:				 "copy", "ctty", "date", "del", "dir", "echo",
        -:10463:				 "erase", "exit", "for", "goto", "if", "md",
        -:10464:				 "mkdir", "path", "pause", "prompt", "rd",
        -:10465:				 "rmdir", "rem", "ren", "rename", "set",
        -:10466:				 "shift", "time", "type", "ver", "verify",
        -:10467:				 "vol", ":", 0 };
        -:10468:
        -:10469:  static char sh_chars_sh[]  = "#;\"*?[]&|<>(){}$`^";
        -:10470:  static char *sh_cmds_sh[]  = { "cd", "echo", "eval", "exec", "exit", "login",
        -:10471:				 "logout", "set", "umask", "wait", "while",
        -:10472:				 "for", "case", "if", ":", ".", "break",
        -:10473:				 "continue", "export", "read", "readonly",
        -:10474:				 "shift", "times", "trap", "switch", "unset",
        -:10475:                                 0 };
        -:10476:
        -:10477:  char *sh_chars;
        -:10478:  char **sh_cmds;
        -:10479:#else
        -:10480:#ifdef _AMIGA
        -:10481:  static char sh_chars[] = "#;\"|<>()?*$`";
        -:10482:  static char *sh_cmds[] = { "cd", "eval", "if", "delete", "echo", "copy",
        -:10483:			     "rename", "set", "setenv", "date", "makedir",
        -:10484:			     "skip", "else", "endif", "path", "prompt",
        -:10485:			     "unset", "unsetenv", "version",
        -:10486:			     0 };
        -:10487:#else
        -:10488:#ifdef WINDOWS32
        -:10489:  static char sh_chars_dos[] = "\"|&<>";
        -:10490:  static char *sh_cmds_dos[] = { "break", "call", "cd", "chcp", "chdir", "cls",
        -:10491:			     "copy", "ctty", "date", "del", "dir", "echo",
        -:10492:			     "erase", "exit", "for", "goto", "if", "if", "md",
        -:10493:			     "mkdir", "path", "pause", "prompt", "rem", "ren",
        -:10494:			     "rename", "set", "shift", "time", "type",
        -:10495:			     "ver", "verify", "vol", ":", 0 };
        -:10496:  static char sh_chars_sh[] = "#;\"*?[]&|<>(){}$`^";
        -:10497:  static char *sh_cmds_sh[] = { "cd", "eval", "exec", "exit", "login",
        -:10498:			     "logout", "set", "umask", "wait", "while", "for",
        -:10499:			     "case", "if", ":", ".", "break", "continue",
        -:10500:			     "export", "read", "readonly", "shift", "times",
        -:10501:			     "trap", "switch", "test",
        -:10502:#ifdef BATCH_MODE_ONLY_SHELL
        -:10503:                 "echo",
        -:10504:#endif
        -:10505:                 0 };
        -:10506:  char*  sh_chars;
        -:10507:  char** sh_cmds;
        -:10508:#else  /* WINDOWS32 */
        -:10509:  static char sh_chars[] = "#;\"*?[]&|<>(){}$`^";
        -:10510:  static char *sh_cmds[] = { "cd", "eval", "exec", "exit", "login",
        -:10511:			     "logout", "set", "umask", "wait", "while", "for",
        -:10512:			     "case", "if", ":", ".", "break", "continue",
        -:10513:			     "export", "read", "readonly", "shift", "times",
        -:10514:			     "trap", "switch", 0 };
        -:10515:#endif /* WINDOWS32 */
        -:10516:#endif /* Amiga */
        -:10517:#endif /* __MSDOS__ */
        -:10518:  register int i;
        -:10519:  register char *p;
        -:10520:  register char *ap;
        -:10521:  char *end;
        -:10522:  int instring, word_has_equals, seen_nonequals, last_argument_was_empty;
    #####:10523:  char **new_argv = 0;
        -:10524:#ifdef WINDOWS32
        -:10525:  int slow_flag = 0;
        -:10526:
        -:10527:  if (no_default_sh_exe) {
        -:10528:    sh_cmds = sh_cmds_dos;
        -:10529:    sh_chars = sh_chars_dos;
        -:10530:  } else {
        -:10531:    sh_cmds = sh_cmds_sh;
        -:10532:    sh_chars = sh_chars_sh;
        -:10533:  }
        -:10534:#endif /* WINDOWS32 */
        -:10535:
    #####:10536:  if (restp != NULL)
branch  0 never executed
branch  1 never executed
    #####:10537:    *restp = NULL;
        -:10538:
        -:10539:  /* Make sure not to bother processing an empty line.  */
    #####:10540:  while (isblank (*line))
branch  0 never executed
branch  1 never executed
    #####:10541:    ++line;
    #####:10542:  if (*line == '\0')
branch  0 never executed
branch  1 never executed
    #####:10543:    return 0;
        -:10544:
        -:10545:  /* See if it is safe to parse commands internally.  */
    #####:10546:  if (shell == 0)
branch  0 never executed
branch  1 never executed
    #####:10547:    shell = default_shell;
        -:10548:#ifdef WINDOWS32
        -:10549:  else if (strcmp (shell, default_shell))
        -:10550:  {
        -:10551:    char *s1 = _fullpath(NULL, shell, 0);
        -:10552:    char *s2 = _fullpath(NULL, default_shell, 0);
        -:10553:
        -:10554:    slow_flag = strcmp((s1 ? s1 : ""), (s2 ? s2 : ""));
        -:10555:
        -:10556:    if (s1)
        -:10557:      free (s1);
        -:10558:    if (s2)
        -:10559:      free (s2);
        -:10560:  }
        -:10561:  if (slow_flag)
        -:10562:    goto slow;
        -:10563:#else  /* not WINDOWS32 */
        -:10564:#ifdef __MSDOS__
        -:10565:  else if (stricmp (shell, default_shell))
        -:10566:    {
        -:10567:      extern int _is_unixy_shell (const char *_path);
        -:10568:
        -:10569:      message (1, _("$SHELL changed (was `%s', now `%s')"), default_shell, shell);
        -:10570:      unixy_shell = _is_unixy_shell (shell);
        -:10571:      default_shell = shell;
        -:10572:    }
        -:10573:  if (unixy_shell)
        -:10574:    {
        -:10575:      sh_chars = sh_chars_sh;
        -:10576:      sh_cmds  = sh_cmds_sh;
        -:10577:    }
        -:10578:  else
        -:10579:    {
        -:10580:      sh_chars = sh_chars_dos;
        -:10581:      sh_cmds  = sh_cmds_dos;
        -:10582:    }
        -:10583:#else  /* not __MSDOS__ */
    #####:10584:  else if (strcmp (shell, default_shell))
branch  0 never executed
branch  1 never executed
    #####:10585:    goto slow;
        -:10586:#endif /* not __MSDOS__ */
        -:10587:#endif /* not WINDOWS32 */
        -:10588:
    #####:10589:  if (ifs != 0)
branch  0 never executed
branch  1 never executed
    #####:10590:    for (ap = ifs; *ap != '\0'; ++ap)
branch  0 never executed
branch  1 never executed
    #####:10591:      if (*ap != ' ' && *ap != '\t' && *ap != '\n')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:10592:	goto slow;
        -:10593:
    #####:10594:  i = strlen (line) + 1;
        -:10595:
        -:10596:  /* More than 1 arg per character is impossible.  */
    #####:10597:  new_argv = (char **) xmalloc (i * sizeof (char *));
call    0 never executed
        -:10598:
        -:10599:  /* All the args can fit in a buffer as big as LINE is.   */
    #####:10600:  ap = new_argv[0] = (char *) xmalloc (i);
call    0 never executed
    #####:10601:  end = ap + i;
        -:10602:
        -:10603:  /* I is how many complete arguments have been found.  */
    #####:10604:  i = 0;
    #####:10605:  instring = word_has_equals = seen_nonequals = last_argument_was_empty = 0;
    #####:10606:  for (p = line; *p != '\0'; ++p)
branch  0 never executed
branch  1 never executed
        -:10607:    {
    #####:10608:      if (ap > end)
branch  0 never executed
branch  1 never executed
    #####:10609:	abort ();
call    0 never executed
        -:10610:
    #####:10611:      if (instring)
branch  0 never executed
branch  1 never executed
        -:10612:	{
    #####:10613:	string_char:
        -:10614:	  /* Inside a string, just copy any char except a closing quote
        -:10615:	     or a backslash-newline combination.  */
    #####:10616:	  if (*p == instring)
branch  0 never executed
branch  1 never executed
        -:10617:	    {
    #####:10618:	      instring = 0;
    #####:10619:	      if (ap == new_argv[0] || *(ap-1) == '\0')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:10620:		last_argument_was_empty = 1;
        -:10621:	    }
    #####:10622:	  else if (*p == '\\' && p[1] == '\n')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:10623:	    goto swallow_escaped_newline;
    #####:10624:	  else if (*p == '\n' && restp != NULL)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:10625:	    {
        -:10626:	      /* End of the command line.  */
    #####:10627:	      *restp = p;
    #####:10628:	      goto end_of_line;
        -:10629:	    }
        -:10630:	  /* Backslash, $, and ` are special inside double quotes.
        -:10631:	     If we see any of those, punt.
        -:10632:	     But on MSDOS, if we use COMMAND.COM, double and single
        -:10633:	     quotes have the same effect.  */
    #####:10634:	  else if (instring == '"' && strchr ("\\$`", *p) != 0 && unixy_shell)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:10635:	    goto slow;
        -:10636:	  else
    #####:10637:	    *ap++ = *p;
        -:10638:	}
    #####:10639:      else if (strchr (sh_chars, *p) != 0)
branch  0 never executed
branch  1 never executed
        -:10640:	/* Not inside a string, but it's a special char.  */
    #####:10641:	goto slow;
        -:10642:#ifdef  __MSDOS__
        -:10643:      else if (*p == '.' && p[1] == '.' && p[2] == '.' && p[3] != '.')
        -:10644:	/* `...' is a wildcard in DJGPP.  */
        -:10645:	goto slow;
        -:10646:#endif
        -:10647:      else
        -:10648:	/* Not a special char.  */
    #####:10649:	switch (*p)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:10650:	  {
    #####:10651:	  case '=':
        -:10652:	    /* Equals is a special character in leading words before the
        -:10653:	       first word with no equals sign in it.  This is not the case
        -:10654:	       with sh -k, but we never get here when using nonstandard
        -:10655:	       shell flags.  */
    #####:10656:	    if (! seen_nonequals && unixy_shell)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:10657:	      goto slow;
    #####:10658:	    word_has_equals = 1;
    #####:10659:	    *ap++ = '=';
    #####:10660:	    break;
        -:10661:
    #####:10662:	  case '\\':
        -:10663:	    /* Backslash-newline combinations are eaten.  */
    #####:10664:	    if (p[1] == '\n')
branch  0 never executed
branch  1 never executed
        -:10665:	      {
    #####:10666:	      swallow_escaped_newline:
        -:10667:
        -:10668:		/* Eat the backslash, the newline, and following whitespace,
        -:10669:		   replacing it all with a single space.  */
    #####:10670:		p += 2;
        -:10671:
        -:10672:		/* If there is a tab after a backslash-newline,
        -:10673:		   remove it from the source line which will be echoed,
        -:10674:		   since it was most likely used to line
        -:10675:		   up the continued line with the previous one.  */
    #####:10676:		if (*p == '\t')
branch  0 never executed
branch  1 never executed
        -:10677:                  /* Note these overlap and strcpy() is undefined for
        -:10678:                     overlapping objects in ANSI C.  The strlen() _IS_ right,
        -:10679:                     since we need to copy the nul byte too.  */
    #####:10680:		  bcopy (p + 1, p, strlen (p));
        -:10681:
    #####:10682:		if (instring)
branch  0 never executed
branch  1 never executed
    #####:10683:		  goto string_char;
        -:10684:		else
        -:10685:		  {
    #####:10686:		    if (ap != new_argv[i])
branch  0 never executed
branch  1 never executed
        -:10687:		      /* Treat this as a space, ending the arg.
        -:10688:			 But if it's at the beginning of the arg, it should
        -:10689:			 just get eaten, rather than becoming an empty arg. */
    #####:10690:		      goto end_of_arg;
        -:10691:		    else
    #####:10692:		      p = next_token (p) - 1;
call    0 never executed
        -:10693:		  }
        -:10694:	      }
    #####:10695:	    else if (p[1] != '\0')
branch  0 never executed
branch  1 never executed
        -:10696:              {
        -:10697:#if defined(__MSDOS__) || defined(WINDOWS32)
        -:10698:                /* Only remove backslashes before characters special
        -:10699:                   to Unixy shells.  All other backslashes are copied
        -:10700:                   verbatim, since they are probably DOS-style
        -:10701:                   directory separators.  This still leaves a small
        -:10702:                   window for problems, but at least it should work
        -:10703:                   for the vast majority of naive users.  */
        -:10704:
        -:10705:#ifdef __MSDOS__
        -:10706:                /* A dot is only special as part of the "..."
        -:10707:                   wildcard.  */
        -:10708:                if (strneq (p + 1, ".\\.\\.", 5))
        -:10709:                  {
        -:10710:                    *ap++ = '.';
        -:10711:                    *ap++ = '.';
        -:10712:                    p += 4;
        -:10713:                  }
        -:10714:                else
        -:10715:#endif
        -:10716:                  if (p[1] != '\\' && p[1] != '\''
        -:10717:                      && !isspace ((unsigned char)p[1])
        -:10718:                      && (strchr (sh_chars_sh, p[1]) == 0))
        -:10719:                    /* back up one notch, to copy the backslash */
        -:10720:                    --p;
        -:10721:
        -:10722:#endif  /* __MSDOS__ || WINDOWS32 */
        -:10723:                /* Copy and skip the following char.  */
    #####:10724:                *ap++ = *++p;
        -:10725:              }
    #####:10726:	    break;
        -:10727:
    #####:10728:	  case '\'':
        -:10729:	  case '"':
    #####:10730:	    instring = *p;
    #####:10731:	    break;
        -:10732:
    #####:10733:	  case '\n':
    #####:10734:	    if (restp != NULL)
branch  0 never executed
branch  1 never executed
        -:10735:	      {
        -:10736:		/* End of the command line.  */
    #####:10737:		*restp = p;
    #####:10738:		goto end_of_line;
        -:10739:	      }
        -:10740:	    else
        -:10741:	      /* Newlines are not special.  */
    #####:10742:	      *ap++ = '\n';
    #####:10743:	    break;
        -:10744:
        -:10745:	  case ' ':
        -:10746:	  case '\t':
    #####:10747:	  end_of_arg:
        -:10748:	    /* We have the end of an argument.
        -:10749:	       Terminate the text of the argument.  */
    #####:10750:	    *ap++ = '\0';
    #####:10751:	    new_argv[++i] = ap;
    #####:10752:	    last_argument_was_empty = 0;
        -:10753:
        -:10754:	    /* Update SEEN_NONEQUALS, which tells us if every word
        -:10755:	       heretofore has contained an `='.  */
    #####:10756:	    seen_nonequals |= ! word_has_equals;
    #####:10757:	    if (word_has_equals && ! seen_nonequals)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:10758:	      /* An `=' in a word before the first
        -:10759:		 word without one is magical.  */
    #####:10760:	      goto slow;
    #####:10761:	    word_has_equals = 0; /* Prepare for the next word.  */
        -:10762:
        -:10763:	    /* If this argument is the command name,
        -:10764:	       see if it is a built-in shell command.
        -:10765:	       If so, have the shell handle it.  */
    #####:10766:	    if (i == 1)
branch  0 never executed
branch  1 never executed
        -:10767:	      {
        -:10768:		register int j;
    #####:10769:		for (j = 0; sh_cmds[j] != 0; ++j)
branch  0 never executed
branch  1 never executed
    #####:10770:		  if (streq (sh_cmds[j], new_argv[0]))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:10771:		    goto slow;
        -:10772:	      }
        -:10773:
        -:10774:	    /* Ignore multiple whitespace chars.  */
    #####:10775:	    p = next_token (p);
call    0 never executed
        -:10776:	    /* Next iteration should examine the first nonwhite char.  */
    #####:10777:	    --p;
    #####:10778:	    break;
        -:10779:
    #####:10780:	  default:
    #####:10781:	    *ap++ = *p;
    #####:10782:	    break;
        -:10783:	  }
        -:10784:    }
    #####:10785: end_of_line:
        -:10786:
    #####:10787:  if (instring)
branch  0 never executed
branch  1 never executed
        -:10788:    /* Let the shell deal with an unterminated quote.  */
    #####:10789:    goto slow;
        -:10790:
        -:10791:  /* Terminate the last argument and the argument list.  */
        -:10792:
    #####:10793:  *ap = '\0';
    #####:10794:  if (new_argv[i][0] != '\0' || last_argument_was_empty)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:10795:    ++i;
    #####:10796:  new_argv[i] = 0;
        -:10797:
    #####:10798:  if (i == 1)
branch  0 never executed
branch  1 never executed
        -:10799:    {
        -:10800:      register int j;
    #####:10801:      for (j = 0; sh_cmds[j] != 0; ++j)
branch  0 never executed
branch  1 never executed
    #####:10802:	if (streq (sh_cmds[j], new_argv[0]))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:10803:	  goto slow;
        -:10804:    }
        -:10805:
    #####:10806:  if (new_argv[0] == 0)
branch  0 never executed
branch  1 never executed
        -:10807:    /* Line was empty.  */
    #####:10808:    return 0;
        -:10809:  else
    #####:10810:    return new_argv;
        -:10811:
    #####:10812: slow:;
        -:10813:  /* We must use the shell.  */
        -:10814:
    #####:10815:  if (new_argv != 0)
branch  0 never executed
branch  1 never executed
        -:10816:    {
        -:10817:      /* Free the old argument list we were working on.  */
    #####:10818:      free (new_argv[0]);
    #####:10819:      free ((void *)new_argv);
        -:10820:    }
        -:10821:
        -:10822:#ifdef __MSDOS__
        -:10823:  execute_by_shell = 1;	/* actually, call `system' if shell isn't unixy */
        -:10824:#endif
        -:10825:
        -:10826:#ifdef _AMIGA
        -:10827:  {
        -:10828:    char *ptr;
        -:10829:    char *buffer;
        -:10830:    char *dptr;
        -:10831:
        -:10832:    buffer = (char *)xmalloc (strlen (line)+1);
        -:10833:
        -:10834:    ptr = line;
        -:10835:    for (dptr=buffer; *ptr; )
        -:10836:    {
        -:10837:      if (*ptr == '\\' && ptr[1] == '\n')
        -:10838:	ptr += 2;
        -:10839:      else if (*ptr == '@') /* Kludge: multiline commands */
        -:10840:      {
        -:10841:	ptr += 2;
        -:10842:	*dptr++ = '\n';
        -:10843:      }
        -:10844:      else
        -:10845:	*dptr++ = *ptr++;
        -:10846:    }
        -:10847:    *dptr = 0;
        -:10848:
        -:10849:    new_argv = (char **) xmalloc (2 * sizeof (char *));
        -:10850:    new_argv[0] = buffer;
        -:10851:    new_argv[1] = 0;
        -:10852:  }
        -:10853:#else	/* Not Amiga  */
        -:10854:#ifdef WINDOWS32
        -:10855:  /*
        -:10856:   * Not eating this whitespace caused things like
        -:10857:   *
        -:10858:   *    sh -c "\n"
        -:10859:   *
        -:10860:   * which gave the shell fits. I think we have to eat
        -:10861:   * whitespace here, but this code should be considered
        -:10862:   * suspicious if things start failing....
        -:10863:   */
        -:10864:
        -:10865:  /* Make sure not to bother processing an empty line.  */
        -:10866:  while (isspace ((unsigned char)*line))
        -:10867:    ++line;
        -:10868:  if (*line == '\0')
        -:10869:    return 0;
        -:10870:#endif /* WINDOWS32 */
        -:10871:  {
        -:10872:    /* SHELL may be a multi-word command.  Construct a command line
        -:10873:       "SHELL -c LINE", with all special chars in LINE escaped.
        -:10874:       Then recurse, expanding this command line to get the final
        -:10875:       argument list.  */
        -:10876:
    #####:10877:    unsigned int shell_len = strlen (shell);
        -:10878:#ifndef VMS
        -:10879:    static char minus_c[] = " -c ";
        -:10880:#else
        -:10881:    static char minus_c[] = "";
        -:10882:#endif
    #####:10883:    unsigned int line_len = strlen (line);
        -:10884:
    #####:10885:    char *new_line = (char *) alloca (shell_len + (sizeof (minus_c) - 1)
        -:10886:				      + (line_len * 2) + 1);
    #####:10887:    char *command_ptr = NULL; /* used for batch_mode_shell mode */
        -:10888:
    #####:10889:    ap = new_line;
    #####:10890:    bcopy (shell, ap, shell_len);
    #####:10891:    ap += shell_len;
    #####:10892:    bcopy (minus_c, ap, sizeof (minus_c) - 1);
    #####:10893:    ap += sizeof (minus_c) - 1;
    #####:10894:    command_ptr = ap;
    #####:10895:    for (p = line; *p != '\0'; ++p)
branch  0 never executed
branch  1 never executed
        -:10896:      {
    #####:10897:	if (restp != NULL && *p == '\n')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:10898:	  {
    #####:10899:	    *restp = p;
    #####:10900:	    break;
        -:10901:	  }
    #####:10902:	else if (*p == '\\' && p[1] == '\n')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:10903:	  {
        -:10904:	    /* Eat the backslash, the newline, and following whitespace,
        -:10905:	       replacing it all with a single space (which is escaped
        -:10906:	       from the shell).  */
    #####:10907:	    p += 2;
        -:10908:
        -:10909:	    /* If there is a tab after a backslash-newline,
        -:10910:	       remove it from the source line which will be echoed,
        -:10911:	       since it was most likely used to line
        -:10912:	       up the continued line with the previous one.  */
    #####:10913:	    if (*p == '\t')
branch  0 never executed
branch  1 never executed
    #####:10914:	      bcopy (p + 1, p, strlen (p));
        -:10915:
    #####:10916:	    p = next_token (p);
call    0 never executed
    #####:10917:	    --p;
    #####:10918:            if (unixy_shell && !batch_mode_shell)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:10919:              *ap++ = '\\';
    #####:10920:	    *ap++ = ' ';
    #####:10921:	    continue;
        -:10922:	  }
        -:10923:
        -:10924:        /* DOS shells don't know about backslash-escaping.  */
    #####:10925:	if (unixy_shell && !batch_mode_shell &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:10926:            (*p == '\\' || *p == '\'' || *p == '"'
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:10927:             || isspace ((unsigned char)*p)
branch  0 never executed
branch  1 never executed
    #####:10928:             || strchr (sh_chars, *p) != 0))
branch  0 never executed
branch  1 never executed
    #####:10929:	  *ap++ = '\\';
        -:10930:#ifdef __MSDOS__
        -:10931:        else if (unixy_shell && strneq (p, "...", 3))
        -:10932:          {
        -:10933:            /* The case of `...' wildcard again.  */
        -:10934:            strcpy (ap, "\\.\\.\\");
        -:10935:            ap += 5;
        -:10936:            p  += 2;
        -:10937:          }
        -:10938:#endif
    #####:10939:	*ap++ = *p;
        -:10940:      }
    #####:10941:    if (ap == new_line + shell_len + sizeof (minus_c) - 1)
branch  0 never executed
branch  1 never executed
        -:10942:      /* Line was empty.  */
    #####:10943:      return 0;
    #####:10944:    *ap = '\0';
        -:10945:
        -:10946:#ifdef WINDOWS32
        -:10947:    /* Some shells do not work well when invoked as 'sh -c xxx' to run a
        -:10948:       command line (e.g. Cygnus GNUWIN32 sh.exe on WIN32 systems).  In these
        -:10949:       cases, run commands via a script file.  */
        -:10950:    if ((no_default_sh_exe || batch_mode_shell) && batch_filename_ptr) {
        -:10951:      FILE* batch = NULL;
        -:10952:      int id = GetCurrentProcessId();
        -:10953:      PATH_VAR(fbuf);
        -:10954:      char* fname = NULL;
        -:10955:
        -:10956:      /* create a file name */
        -:10957:      sprintf(fbuf, "make%d", id);
        -:10958:      fname = tempnam(".", fbuf);
        -:10959:
        -:10960:	  /* create batch file name */
        -:10961:      *batch_filename_ptr = xmalloc(strlen(fname) + 5);
        -:10962:      strcpy(*batch_filename_ptr, fname);
        -:10963:
        -:10964:      /* make sure path name is in DOS backslash format */
        -:10965:      if (!unixy_shell) {
        -:10966:        fname = *batch_filename_ptr;
        -:10967:        for (i = 0; fname[i] != '\0'; ++i)
        -:10968:          if (fname[i] == '/')
        -:10969:            fname[i] = '\\';
        -:10970:        strcat(*batch_filename_ptr, ".bat");
        -:10971:      } else {
        -:10972:        strcat(*batch_filename_ptr, ".sh");
        -:10973:      }
        -:10974:
        -:10975:      DB (DB_JOBS, (_("Creating temporary batch file %s\n"),
        -:10976:                    *batch_filename_ptr));
        -:10977:
        -:10978:      /* create batch file to execute command */
        -:10979:      batch = fopen (*batch_filename_ptr, "w");
        -:10980:      if (!unixy_shell)
        -:10981:        fputs ("@echo off\n", batch);
        -:10982:      fputs (command_ptr, batch);
        -:10983:      fputc ('\n', batch);
        -:10984:      fclose (batch);
        -:10985:
        -:10986:      /* create argv */
        -:10987:      new_argv = (char **) xmalloc(3 * sizeof (char *));
        -:10988:      if (unixy_shell) {
        -:10989:        new_argv[0] = xstrdup (shell);
        -:10990:        new_argv[1] = *batch_filename_ptr; /* only argv[0] gets freed later */
        -:10991:      } else {
        -:10992:        new_argv[0] = xstrdup (*batch_filename_ptr);
        -:10993:        new_argv[1] = NULL;
        -:10994:      }
        -:10995:      new_argv[2] = NULL;
        -:10996:    } else
        -:10997:#endif /* WINDOWS32 */
    #####:10998:    if (unixy_shell)
branch  0 never executed
branch  1 never executed
    #####:10999:      new_argv = construct_command_argv_internal (new_line, (char **) NULL,
call    0 never executed
        -:11000:                                                  (char *) 0, (char *) 0,
        -:11001:                                                  (char **) 0);
        -:11002:#ifdef  __MSDOS__
        -:11003:    else
        -:11004:      {
        -:11005:      /* With MSDOS shells, we must construct the command line here
        -:11006:         instead of recursively calling ourselves, because we
        -:11007:         cannot backslash-escape the special characters (see above).  */
        -:11008:      new_argv = (char **) xmalloc (sizeof (char *));
        -:11009:      line_len = strlen (new_line) - shell_len - sizeof (minus_c) + 1;
        -:11010:      new_argv[0] = xmalloc (line_len + 1);
        -:11011:      strncpy (new_argv[0],
        -:11012:               new_line + shell_len + sizeof (minus_c) - 1, line_len);
        -:11013:      new_argv[0][line_len] = '\0';
        -:11014:      }
        -:11015:#else
        -:11016:    else
    #####:11017:      fatal (NILF, _("%s (line %d) Bad shell context (!unixy && !batch_mode_shell)\n"),
call    0 never executed
        -:11018:            __FILE__, __LINE__);
        -:11019:#endif
        -:11020:  }
        -:11021:#endif	/* ! AMIGA */
        -:11022:
    #####:11023:  return new_argv;
        -:11024:}
        -:11025:#endif /* !VMS */
        -:11026:
        -:11027:/* Figure out the argument list necessary to run LINE as a command.  Try to
        -:11028:   avoid using a shell.  This routine handles only ' quoting, and " quoting
        -:11029:   when no backslash, $ or ` characters are seen in the quotes.  Starting
        -:11030:   quotes may be escaped with a backslash.  If any of the characters in
        -:11031:   sh_chars[] is seen, or any of the builtin commands listed in sh_cmds[]
        -:11032:   is the first word of a line, the shell is used.
        -:11033:
        -:11034:   If RESTP is not NULL, *RESTP is set to point to the first newline in LINE.
        -:11035:   If *RESTP is NULL, newlines will be ignored.
        -:11036:
        -:11037:   FILE is the target whose commands these are.  It is used for
        -:11038:   variable expansion for $(SHELL) and $(IFS).  */
        -:11039:
        -:11040:char **
function construct_command_argv called 0 returned 0% blocks executed 0%
    #####:11041:construct_command_argv (line, restp, file, batch_filename_ptr)
        -:11042:     char *line, **restp;
        -:11043:     struct file *file;
        -:11044:     char** batch_filename_ptr;
        -:11045:{
        -:11046:  char *shell, *ifs;
        -:11047:  char **argv;
        -:11048:
        -:11049:#ifdef VMS
        -:11050:  char *cptr;
        -:11051:  int argc;
        -:11052:
        -:11053:  argc = 0;
        -:11054:  cptr = line;
        -:11055:  for (;;)
        -:11056:    {
        -:11057:      while ((*cptr != 0)
        -:11058:	     && (isspace (*cptr)))
        -:11059:	cptr++;
        -:11060:      if (*cptr == 0)
        -:11061:	break;
        -:11062:      while ((*cptr != 0)
        -:11063:	     && (!isspace(*cptr)))
        -:11064:	cptr++;
        -:11065:      argc++;
        -:11066:    }
        -:11067:
        -:11068:  argv = (char **)malloc (argc * sizeof (char *));
        -:11069:  if (argv == 0)
        -:11070:    abort ();
        -:11071:
        -:11072:  cptr = line;
        -:11073:  argc = 0;
        -:11074:  for (;;)
        -:11075:    {
        -:11076:      while ((*cptr != 0)
        -:11077:	     && (isspace (*cptr)))
        -:11078:	cptr++;
        -:11079:      if (*cptr == 0)
        -:11080:	break;
        -:11081:      DB (DB_JOBS, ("argv[%d] = [%s]\n", argc, cptr));
        -:11082:      argv[argc++] = cptr;
        -:11083:      while ((*cptr != 0)
        -:11084:	     && (!isspace(*cptr)))
        -:11085:	cptr++;
        -:11086:      if (*cptr != 0)
        -:11087:	*cptr++ = 0;
        -:11088:    }
        -:11089:#else
        -:11090:  {
        -:11091:    /* Turn off --warn-undefined-variables while we expand SHELL and IFS.  */
    #####:11092:    int save = warn_undefined_variables_flag;
    #####:11093:    warn_undefined_variables_flag = 0;
        -:11094:
    #####:11095:    shell = allocated_variable_expand_for_file ("$(SHELL)", file);
call    0 never executed
        -:11096:#ifdef WINDOWS32
        -:11097:    /*
        -:11098:     * Convert to forward slashes so that construct_command_argv_internal()
        -:11099:     * is not confused.
        -:11100:     */
        -:11101:    if (shell) {
        -:11102:      char *p = w32ify(shell, 0);
        -:11103:      strcpy(shell, p);
        -:11104:    }
        -:11105:#endif
    #####:11106:    ifs = allocated_variable_expand_for_file ("$(IFS)", file);
call    0 never executed
        -:11107:
    #####:11108:    warn_undefined_variables_flag = save;
        -:11109:  }
        -:11110:
    #####:11111:  argv = construct_command_argv_internal (line, restp, shell, ifs, batch_filename_ptr);
call    0 never executed
        -:11112:
    #####:11113:  free (shell);
    #####:11114:  free (ifs);
        -:11115:#endif /* !VMS */
    #####:11116:  return argv;
        -:11117:}
        -:11118:
        -:11119:#if !defined(HAVE_DUP2) && !defined(_AMIGA)
        -:11120:int
        -:11121:dup2 (old, new)
        -:11122:     int old, new;
        -:11123:{
        -:11124:  int fd;
        -:11125:
        -:11126:  (void) close (new);
        -:11127:  fd = dup (old);
        -:11128:  if (fd != new)
        -:11129:    {
        -:11130:      (void) close (fd);
        -:11131:      errno = EMFILE;
        -:11132:      return -1;
        -:11133:    }
        -:11134:
        -:11135:  return fd;
        -:11136:}
        -:11137:#endif /* !HAPE_DUP2 && !_AMIGA */
        -:11138:
        -:11139:
        -:11140:
        -:11141:/*************************************************************
        -:11142:  ============================================================
        -:11143:  ************************************************************
        -:11144:  ============================================================
        -:11145:  ************************************************************
        -:11146:                         main.c
        -:11147:  ************************************************************
        -:11148:  ============================================================
        -:11149:  ************************************************************
        -:11150:  ============================================================
        -:11151:  *************************************************************/
        -:11152:
        -:11153:/* Argument parsing and main program of GNU Make.
        -:11154:Copyright (C) 1988,89,90,91,94,95,96,97,98,99 Free Software Foundation, Inc.
        -:11155:This file is part of GNU Make.
        -:11156:
        -:11157:GNU Make is free software; you can redistribute it and/or modify
        -:11158:it under the terms of the GNU General Public License as published by
        -:11159:the Free Software Foundation; either version 2, or (at your option)
        -:11160:any later version.
        -:11161:
        -:11162:GNU Make is distributed in the hope that it will be useful,
        -:11163:but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:11164:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:11165:GNU General Public License for more details.
        -:11166:
        -:11167:You should have received a copy of the GNU General Public License
        -:11168:along with GNU Make; see the file COPYING.  If not, write to
        -:11169:the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
        -:11170:MA 02111-1307, USA.  */
        -:11171:
        -:11172:/* #include "make.h"  <- modification by J.Ruthruff, 7/28 */
        -:11173:/* #include "dep.h"  <- modification by J.Ruthruff, 7/28 */
        -:11174:/* #include "filedef.h"  <- modification by J.Ruthruff, 7/28 */
        -:11175:/* #include "variable.h"  <- modification by J.Ruthruff, 7/28 */
        -:11176:#include "job.h"
        -:11177:/* #include "commands.h"  <- modification by J.Ruthruff, 7/28 */
        -:11178:/* #include "rule.h"  <- modification by J.Ruthruff, 7/28 */
        -:11179:#include "debug.h"
        -:11180:#include "getopt.h"
        -:11181:
        -:11182:#include <assert.h>
        -:11183:#undef stderr
        -:11184:#define stderr stdout
        -:11185:#ifdef _AMIGA
        -:11186:# include <dos/dos.h>
        -:11187:# include <proto/dos.h>
        -:11188:#undef stderr
        -:11189:#define stderr stdout
        -:11190:#endif
        -:11191:#ifdef WINDOWS32
        -:11192:#include <windows.h>
        -:11193:#include "pathstuff.h"
        -:11194:#undef stderr
        -:11195:#define stderr stdout
        -:11196:#endif
        -:11197:#if defined(MAKE_JOBSERVER) && defined(HAVE_FCNTL_H)
        -:11198:# include <fcntl.h>
        -:11199:#undef stderr
        -:11200:#define stderr stdout
        -:11201:#endif
        -:11202:
        -:11203:#ifdef _AMIGA
        -:11204:int __stack = 20000; /* Make sure we have 20K of stack space */
        -:11205:#endif
        -:11206:
        -:11207:extern void init_dir PARAMS ((void));
        -:11208:extern void remote_setup PARAMS ((void));
        -:11209:extern void remote_cleanup PARAMS ((void));
        -:11210:/* extern RETSIGTYPE fatal_error_signal PARAMS ((int sig)); */
        -:11211:
        -:11212:extern void print_variable_data_base PARAMS ((void));
        -:11213:/* extern void print_dir_data_base PARAMS ((void)); */
        -:11214:extern void print_rule_data_base PARAMS ((void));
        -:11215:/* extern void print_file_data_base PARAMS ((void)); */
        -:11216:extern void print_vpath_data_base PARAMS ((void));
        -:11217:
        -:11218:#if defined HAVE_WAITPID || defined HAVE_WAIT3
        -:11219:# define HAVE_WAIT_NOHANG
        -:11220:#endif
        -:11221:
        -:11222:#ifndef	HAVE_UNISTD_H
        -:11223:extern int chdir ();
        -:11224:#endif
        -:11225:#ifndef	STDC_HEADERS
        -:11226:# ifndef sun			/* Sun has an incorrect decl in a header.  */
        -:11227:extern void exit PARAMS ((int)) __attribute__ ((noreturn));
        -:11228:# endif
        -:11229:extern double atof ();
        -:11230:#endif
        -:11231:
        -:11232:static void print_data_base PARAMS ((void));
        -:11233:static void print_version PARAMS ((void));
        -:11234:static void decode_switches PARAMS ((int argc, char **argv, int env));
        -:11235:static void decode_env_switches PARAMS ((char *envar, unsigned int len));
        -:11236:static void define_makeflags PARAMS ((int all, int makefile));
        -:11237:static char *quote_for_env PARAMS ((char *out, char *in));
        -:11238:
        -:11239:/* The structure that describes an accepted command switch.  */
        -:11240:
        -:11241:struct command_switch
        -:11242:  {
        -:11243:    int c;			/* The switch character.  */
        -:11244:
        -:11245:    enum			/* Type of the value.  */
        -:11246:      {
        -:11247:	flag,			/* Turn int flag on.  */
        -:11248:	flag_off,		/* Turn int flag off.  */
        -:11249:	string,			/* One string per switch.  */
        -:11250:	positive_int,		/* A positive integer.  */
        -:11251:	floating,		/* A floating-point number (double).  */
        -:11252:	ignore			/* Ignored.  */
        -:11253:      } type;
        -:11254:
        -:11255:    char *value_ptr;	/* Pointer to the value-holding variable.  */
        -:11256:
        -:11257:    unsigned int env:1;		/* Can come from MAKEFLAGS.  */
        -:11258:    unsigned int toenv:1;	/* Should be put in MAKEFLAGS.  */
        -:11259:    unsigned int no_makefile:1;	/* Don't propagate when remaking makefiles.  */
        -:11260:
        -:11261:    char *noarg_value;	/* Pointer to value used if no argument is given.  */
        -:11262:    char *default_value;/* Pointer to default value.  */
        -:11263:
        -:11264:    char *long_name;		/* Long option name.  */
        -:11265:    char *argdesc;		/* Descriptive word for argument.  */
        -:11266:    char *description;		/* Description for usage message.  */
        -:11267:                                /* 0 means internal; don't display help.  */
        -:11268:  };
        -:11269:
        -:11270:/* True if C is a switch value that corresponds to a short option.  */
        -:11271:
        -:11272:#define short_option(c) ((c) <= CHAR_MAX)
        -:11273:
        -:11274:/* The structure used to hold the list of strings given
        -:11275:   in command switches of a type that takes string arguments.  */
        -:11276:
        -:11277:struct stringlist
        -:11278:  {
        -:11279:    char **list;	/* Nil-terminated list of strings.  */
        -:11280:    unsigned int idx;	/* Index into above.  */
        -:11281:    unsigned int max;	/* Number of pointers allocated.  */
        -:11282:  };
        -:11283:
        -:11284:
        -:11285:/* The recognized command switches.  */
        -:11286:
        -:11287:/* Nonzero means do not print commands to be executed (-s).  */
        -:11288:
        -:11289:int silent_flag;
        -:11290:
        -:11291:/* Nonzero means just touch the files
        -:11292:   that would appear to need remaking (-t)  */
        -:11293:
        -:11294:int touch_flag;
        -:11295:
        -:11296:/* Nonzero means just print what commands would need to be executed,
        -:11297:   don't actually execute them (-n).  */
        -:11298:
        -:11299:int just_print_flag;
        -:11300:
        -:11301:/* Print debugging info (--debug).  */
        -:11302:
        -:11303:static struct stringlist *db_flags;
        -:11304:static int debug_flag = 0;
        -:11305:
        -:11306:int db_level = 0;
        -:11307:
        -:11308:#ifdef WINDOWS32
        -:11309:/* Suspend make in main for a short time to allow debugger to attach */
        -:11310:
        -:11311:int suspend_flag = 0;
        -:11312:#endif
        -:11313:
        -:11314:/* Environment variables override makefile definitions.  */
        -:11315:
        -:11316:int env_overrides = 0;
        -:11317:
        -:11318:/* Nonzero means ignore status codes returned by commands
        -:11319:   executed to remake files.  Just treat them all as successful (-i).  */
        -:11320:
        -:11321:int ignore_errors_flag = 0;
        -:11322:
        -:11323:/* Nonzero means don't remake anything, just print the data base
        -:11324:   that results from reading the makefile (-p).  */
        -:11325:
        -:11326:int print_data_base_flag = 0;
        -:11327:
        -:11328:/* Nonzero means don't remake anything; just return a nonzero status
        -:11329:   if the specified targets are not up to date (-q).  */
        -:11330:
        -:11331:int question_flag = 0;
        -:11332:
        -:11333:/* Nonzero means do not use any of the builtin rules (-r) / variables (-R).  */
        -:11334:
        -:11335:int no_builtin_rules_flag = 0;
        -:11336:int no_builtin_variables_flag = 0;
        -:11337:
        -:11338:/* Nonzero means keep going even if remaking some file fails (-k).  */
        -:11339:
        -:11340:int keep_going_flag;
        -:11341:int default_keep_going_flag = 0;
        -:11342:
        -:11343:/* Nonzero means print directory before starting and when done (-w).  */
        -:11344:
        -:11345:int print_directory_flag = 0;
        -:11346:
        -:11347:/* Nonzero means ignore print_directory_flag and never print the directory.
        -:11348:   This is necessary because print_directory_flag is set implicitly.  */
        -:11349:
        -:11350:int inhibit_print_directory_flag = 0;
        -:11351:
        -:11352:/* Nonzero means print version information.  */
        -:11353:
        -:11354:int print_version_flag = 0;
        -:11355:
        -:11356:/* List of makefiles given with -f switches.  */
        -:11357:
        -:11358:static struct stringlist *makefiles = 0;
        -:11359:
        -:11360:/* Number of job slots (commands that can be run at once).  */
        -:11361:
        -:11362:unsigned int job_slots = 1;
        -:11363:unsigned int default_job_slots = 1;
        -:11364:
        -:11365:/* Value of job_slots that means no limit.  */
        -:11366:
        -:11367:static unsigned int inf_jobs = 0;
        -:11368:
        -:11369:/* File descriptors for the jobs pipe.  */
        -:11370:
        -:11371:static struct stringlist *jobserver_fds = 0;
        -:11372:
        -:11373:int job_fds[2] = { -1, -1 };
        -:11374:int job_rfd = -1;
        -:11375:
        -:11376:/* Maximum load average at which multiple jobs will be run.
        -:11377:   Negative values mean unlimited, while zero means limit to
        -:11378:   zero load (which could be useful to start infinite jobs remotely
        -:11379:   but one at a time locally).  */
        -:11380:#ifndef NO_FLOAT
        -:11381:double max_load_average = -1.0;
        -:11382:double default_load_average = -1.0;
        -:11383:#else
        -:11384:int max_load_average = -1;
        -:11385:int default_load_average = -1;
        -:11386:#endif
        -:11387:
        -:11388:/* List of directories given with -C switches.  */
        -:11389:
        -:11390:static struct stringlist *directories = 0;
        -:11391:
        -:11392:/* List of include directories given with -I switches.  */
        -:11393:
        -:11394:static struct stringlist *include_directories = 0;
        -:11395:
        -:11396:/* List of files given with -o switches.  */
        -:11397:
        -:11398:static struct stringlist *old_files = 0;
        -:11399:
        -:11400:/* List of files given with -W switches.  */
        -:11401:
        -:11402:static struct stringlist *new_files = 0;
        -:11403:
        -:11404:/* If nonzero, we should just print usage and exit.  */
        -:11405:
        -:11406:static int print_usage_flag = 0;
        -:11407:
        -:11408:/* If nonzero, we should print a warning message
        -:11409:   for each reference to an undefined variable.  */
        -:11410:
        -:11411:int warn_undefined_variables_flag;
        -:11412:
        -:11413:/* The table of command switches.  */
        -:11414:
        -:11415:static const struct command_switch switches[] =
        -:11416:  {
        -:11417:    { 'b', ignore, 0, 0, 0, 0, 0, 0,
        -:11418:	0, 0,
        -:11419:	N_("Ignored for compatibility") },
        -:11420:    { 'C', string, (char *) &directories, 0, 0, 0, 0, 0,
        -:11421:	"directory", N_("DIRECTORY"),
        -:11422:	N_("Change to DIRECTORY before doing anything") },
        -:11423:    { 'd', flag, (char *) &debug_flag, 1, 1, 0, 0, 0,
        -:11424:	0, 0,
        -:11425:	N_("Print lots of debugging information") },
        -:11426:    { CHAR_MAX+1, string, (char *) &db_flags, 1, 1, 0,
        -:11427:        "basic", 0,
        -:11428:	"debug", N_("FLAGS"),
        -:11429:	N_("Print various types of debugging information") },
        -:11430:#ifdef WINDOWS32
        -:11431:    { 'D', flag, (char *) &suspend_flag, 1, 1, 0, 0, 0,
        -:11432:        "suspend-for-debug", 0,
        -:11433:        N_("Suspend process to allow a debugger to attach") },
        -:11434:#endif
        -:11435:    { 'e', flag, (char *) &env_overrides, 1, 1, 0, 0, 0,
        -:11436:	"environment-overrides", 0,
        -:11437:	N_("Environment variables override makefiles") },
        -:11438:    { 'f', string, (char *) &makefiles, 0, 0, 0, 0, 0,
        -:11439:	"file", N_("FILE"),
        -:11440:	N_("Read FILE as a makefile") },
        -:11441:    { 'h', flag, (char *) &print_usage_flag, 0, 0, 0, 0, 0,
        -:11442:	"help", 0,
        -:11443:	N_("Print this message and exit") },
        -:11444:    { 'i', flag, (char *) &ignore_errors_flag, 1, 1, 0, 0, 0,
        -:11445:	"ignore-errors", 0,
        -:11446:	N_("Ignore errors from commands") },
        -:11447:    { 'I', string, (char *) &include_directories, 1, 1, 0, 0, 0,
        -:11448:	"include-dir", N_("DIRECTORY"),
        -:11449:	N_("Search DIRECTORY for included makefiles") },
        -:11450:    { 'j',
        -:11451:        positive_int, (char *) &job_slots, 1, 1, 0,
        -:11452:	(char *) &inf_jobs, (char *) &default_job_slots,
        -:11453:	"jobs", "N",
        -:11454:	N_("Allow N jobs at once; infinite jobs with no arg") },
        -:11455:    { CHAR_MAX+2, string, (char *) &jobserver_fds, 1, 1, 0, 0, 0,
        -:11456:        "jobserver-fds", 0,
        -:11457:        0 },
        -:11458:    { 'k', flag, (char *) &keep_going_flag, 1, 1, 0,
        -:11459:	0, (char *) &default_keep_going_flag,
        -:11460:	"keep-going", 0,
        -:11461:	N_("Keep going when some targets can't be made") },
        -:11462:#ifndef NO_FLOAT
        -:11463:    { 'l', floating, (char *) &max_load_average, 1, 1, 0,
        -:11464:	(char *) &default_load_average, (char *) &default_load_average,
        -:11465:	"load-average", "N",
        -:11466:	N_("Don't start multiple jobs unless load is below N") },
        -:11467:#else
        -:11468:    { 'l', positive_int, (char *) &max_load_average, 1, 1, 0,
        -:11469:	(char *) &default_load_average, (char *) &default_load_average,
        -:11470:	"load-average", "N",
        -:11471:	N_("Don't start multiple jobs unless load is below N") },
        -:11472:#endif
        -:11473:    { 'm', ignore, 0, 0, 0, 0, 0, 0,
        -:11474:	0, 0,
        -:11475:	"-b" },
        -:11476:    { 'n', flag, (char *) &just_print_flag, 1, 1, 1, 0, 0,
        -:11477:	"just-print", 0,
        -:11478:	N_("Don't actually run any commands; just print them") },
        -:11479:    { 'o', string, (char *) &old_files, 0, 0, 0, 0, 0,
        -:11480:	"old-file", N_("FILE"),
        -:11481:	N_("Consider FILE to be very old and don't remake it") },
        -:11482:    { 'p', flag, (char *) &print_data_base_flag, 1, 1, 0, 0, 0,
        -:11483:	"print-data-base", 0,
        -:11484:	N_("Print make's internal database") },
        -:11485:    { 'q', flag, (char *) &question_flag, 1, 1, 1, 0, 0,
        -:11486:	"question", 0,
        -:11487:	N_("Run no commands; exit status says if up to date") },
        -:11488:    { 'r', flag, (char *) &no_builtin_rules_flag, 1, 1, 0, 0, 0,
        -:11489:	"no-builtin-rules", 0,
        -:11490:	N_("Disable the built-in implicit rules") },
        -:11491:    { 'R', flag, (char *) &no_builtin_variables_flag, 1, 1, 0, 0, 0,
        -:11492:	"no-builtin-variables", 0,
        -:11493:	N_("Disable the built-in variable settings") },
        -:11494:    { 's', flag, (char *) &silent_flag, 1, 1, 0, 0, 0,
        -:11495:	"silent", 0,
        -:11496:	N_("Don't echo commands") },
        -:11497:    { 'S', flag_off, (char *) &keep_going_flag, 1, 1, 0,
        -:11498:	0, (char *) &default_keep_going_flag,
        -:11499:	"no-keep-going", 0,
        -:11500:	N_("Turns off -k") },
        -:11501:    { 't', flag, (char *) &touch_flag, 1, 1, 1, 0, 0,
        -:11502:	"touch", 0,
        -:11503:	N_("Touch targets instead of remaking them") },
        -:11504:    { 'v', flag, (char *) &print_version_flag, 1, 1, 0, 0, 0,
        -:11505:	"version", 0,
        -:11506:	N_("Print the version number of make and exit") },
        -:11507:    { 'w', flag, (char *) &print_directory_flag, 1, 1, 0, 0, 0,
        -:11508:	"print-directory", 0,
        -:11509:	N_("Print the current directory") },
        -:11510:    { CHAR_MAX+3, flag, (char *) &inhibit_print_directory_flag, 1, 1, 0, 0, 0,
        -:11511:	"no-print-directory", 0,
        -:11512:	N_("Turn off -w, even if it was turned on implicitly") },
        -:11513:    { 'W', string, (char *) &new_files, 0, 0, 0, 0, 0,
        -:11514:	"what-if", N_("FILE"),
        -:11515:	N_("Consider FILE to be infinitely new") },
        -:11516:    { CHAR_MAX+4, flag, (char *) &warn_undefined_variables_flag, 1, 1, 0, 0, 0,
        -:11517:	"warn-undefined-variables", 0,
        -:11518:	N_("Warn when an undefined variable is referenced") },
        -:11519:    { '\0', }
        -:11520:  };
        -:11521:
        -:11522:/* Secondary long names for options.  */
        -:11523:
        -:11524:static struct option long_option_aliases[] =
        -:11525:  {
        -:11526:    { "quiet",		no_argument,		0, 's' },
        -:11527:    { "stop",		no_argument,		0, 'S' },
        -:11528:    { "new-file",	required_argument,	0, 'W' },
        -:11529:    { "assume-new",	required_argument,	0, 'W' },
        -:11530:    { "assume-old",	required_argument,	0, 'o' },
        -:11531:    { "max-load",	optional_argument,	0, 'l' },
        -:11532:    { "dry-run",	no_argument,		0, 'n' },
        -:11533:    { "recon",		no_argument,		0, 'n' },
        -:11534:    { "makefile",	required_argument,	0, 'f' },
        -:11535:  };
        -:11536:
        -:11537:/* The usage message prints the descriptions of options starting in
        -:11538:   this column.  Make sure it leaves enough room for the longest
        -:11539:   description to fit in less than 80 characters.  */
        -:11540:
        -:11541:#define	DESCRIPTION_COLUMN	30
        -:11542:
        -:11543:/* List of goal targets.  */
        -:11544:
        -:11545:static struct dep *goals, *lastgoal;
        -:11546:
        -:11547:/* List of variables which were defined on the command line
        -:11548:   (or, equivalently, in MAKEFLAGS).  */
        -:11549:
        -:11550:struct command_variable
        -:11551:  {
        -:11552:    struct command_variable *next;
        -:11553:    struct variable *variable;
        -:11554:  };
        -:11555:static struct command_variable *command_variables;
        -:11556:
        -:11557:/* The name we were invoked with.  */
        -:11558:
        -:11559:char *program;
        -:11560:
        -:11561:/* Our current directory before processing any -C options.  */
        -:11562:
        -:11563:char *directory_before_chdir;
        -:11564:
        -:11565:/* Our current directory after processing all -C options.  */
        -:11566:
        -:11567:char *starting_directory;
        -:11568:
        -:11569:/* Value of the MAKELEVEL variable at startup (or 0).  */
        -:11570:
        -:11571:unsigned int makelevel;
        -:11572:
        -:11573:/* First file defined in the makefile whose name does not
        -:11574:   start with `.'.  This is the default to remake if the
        -:11575:   command line does not specify.  */
        -:11576:
        -:11577:struct file *default_goal_file;
        -:11578:
        -:11579:/* Pointer to structure for the file .DEFAULT
        -:11580:   whose commands are used for any file that has none of its own.
        -:11581:   This is zero if the makefiles do not define .DEFAULT.  */
        -:11582:
        -:11583:struct file *default_file;
        -:11584:
        -:11585:/* Nonzero if we have seen the magic `.POSIX' target.
        -:11586:   This turns on pedantic compliance with POSIX.2.  */
        -:11587:
        -:11588:int posix_pedantic;
        -:11589:
        -:11590:/* Nonzero if we have seen the `.NOTPARALLEL' target.
        -:11591:   This turns off parallel builds for this invocation of make.  */
        -:11592:
        -:11593:int not_parallel;
        -:11594:
        -:11595:/* Nonzero if some rule detected clock skew; we keep track so (a) we only
        -:11596:   print one warning about it during the run, and (b) we can print a final
        -:11597:   warning at the end of the run. */
        -:11598:
        -:11599:int clock_skew_detected;
        -:11600:
        -:11601:/* Mask of signals that are being caught with fatal_error_signal.  */
        -:11602:
        -:11603:#ifdef	POSIX
        -:11604:sigset_t fatal_signal_set;
        -:11605:#else
        -:11606:#ifdef	HAVE_SIGSETMASK
        -:11607:int fatal_signal_mask;
        -:11608:#endif
        -:11609:#endif
        -:11610:
        -:11611:static struct file *
function enter_command_line_file called 0 returned 0% blocks executed 0%
    #####:11612:enter_command_line_file (name)
        -:11613:     char *name;
        -:11614:{
    #####:11615:  if (name[0] == '\0')
branch  0 never executed
branch  1 never executed
    #####:11616:    fatal (NILF, _("empty string invalid as file name"));
call    0 never executed
        -:11617:
    #####:11618:  if (name[0] == '~')
branch  0 never executed
branch  1 never executed
        -:11619:    {
    #####:11620:      char *expanded = tilde_expand (name);
call    0 never executed
    #####:11621:      if (expanded != 0)
branch  0 never executed
branch  1 never executed
    #####:11622:	name = expanded;	/* Memory leak; I don't care.  */
        -:11623:    }
        -:11624:
        -:11625:  /* This is also done in parse_file_seq, so this is redundant
        -:11626:     for names read from makefiles.  It is here for names passed
        -:11627:     on the command line.  */
    #####:11628:  while (name[0] == '.' && name[1] == '/' && name[2] != '\0')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:11629:    {
    #####:11630:      name += 2;
    #####:11631:      while (*name == '/')
branch  0 never executed
branch  1 never executed
        -:11632:	/* Skip following slashes: ".//foo" is "foo", not "/foo".  */
    #####:11633:	++name;
        -:11634:    }
        -:11635:
    #####:11636:  if (*name == '\0')
branch  0 never executed
branch  1 never executed
        -:11637:    {
        -:11638:      /* It was all slashes!  Move back to the dot and truncate
        -:11639:	 it after the first slash, so it becomes just "./".  */
        -:11640:      do
    #####:11641:	--name;
    #####:11642:      while (name[0] != '.');
branch  0 never executed
branch  1 never executed
    #####:11643:      name[2] = '\0';
        -:11644:    }
        -:11645:
    #####:11646:  return enter_file (xstrdup (name));
call    0 never executed
call    1 never executed
        -:11647:}
        -:11648:
        -:11649:/* Toggle -d on receipt of SIGUSR1.  */
        -:11650:
        -:11651:static RETSIGTYPE
function debug_signal_handler called 0 returned 0% blocks executed 0%
    #####:11652:debug_signal_handler (sig)
        -:11653:     int sig;
        -:11654:{
    #####:11655:  db_level = db_level ? DB_NONE : DB_BASIC;
    #####:11656:}
        -:11657:
        -:11658:static void
function decode_debug_flags called 1 returned 100% blocks executed 21%
        1:11659:decode_debug_flags ()
        -:11660:{
        -:11661:  char **pp;
        -:11662:
        1:11663:  if (debug_flag)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:11664:    db_level = DB_ALL;
        -:11665:
        1:11666:  if (!db_flags)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:11667:    return;
        -:11668:
    #####:11669:  for (pp=db_flags->list; *pp; ++pp)
branch  0 never executed
branch  1 never executed
        -:11670:    {
    #####:11671:      const char *p = *pp;
        -:11672:
        -:11673:      while (1)
        -:11674:        {
    #####:11675:          switch (tolower (p[0]))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
        -:11676:            {
    #####:11677:            case 'a':
    #####:11678:              db_level |= DB_ALL;
    #####:11679:              break;
    #####:11680:            case 'b':
    #####:11681:              db_level |= DB_BASIC;
    #####:11682:              break;
    #####:11683:            case 'i':
    #####:11684:              db_level |= DB_BASIC | DB_IMPLICIT;
    #####:11685:              break;
    #####:11686:            case 'j':
    #####:11687:              db_level |= DB_JOBS;
    #####:11688:              break;
    #####:11689:            case 'm':
    #####:11690:              db_level |= DB_BASIC | DB_MAKEFILES;
    #####:11691:              break;
    #####:11692:            case 'v':
    #####:11693:              db_level |= DB_BASIC | DB_VERBOSE;
    #####:11694:              break;
    #####:11695:            default:
    #####:11696:              fatal (NILF, _("unknown debug level specification `%s'"), p);
call    0 never executed
        -:11697:            }
        -:11698:
    #####:11699:          while (*(++p) != '\0')
branch  0 never executed
branch  1 never executed
    #####:11700:            if (*p == ',' || *p == ' ')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:11701:              break;
        -:11702:#ifndef F_JR_1  /* seeded fault #1; J.Ruthruff */
        -:11703:          if (*p == '\0')
        -:11704:#else
    #####:11705:          if (*p != '\0')
branch  0 never executed
branch  1 never executed
        -:11706:#endif 
    #####:11707:            break;
        -:11708:
    #####:11709:          ++p;
        -:11710:        }
        -:11711:    }
        -:11712:}
        -:11713:
        -:11714:#ifdef WINDOWS32
        -:11715:/*
        -:11716: * HANDLE runtime exceptions by avoiding a requestor on the GUI. Capture
        -:11717: * exception and print it to stderr instead.
        -:11718: *
        -:11719: * If ! DB_VERBOSE, just print a simple message and exit.
        -:11720: * If DB_VERBOSE, print a more verbose message.
        -:11721: * If compiled for DEBUG, let exception pass through to GUI so that
        -:11722: *   debuggers can attach.
        -:11723: */
        -:11724:LONG WINAPI
        -:11725:handle_runtime_exceptions( struct _EXCEPTION_POINTERS *exinfo )
        -:11726:{
        -:11727:  PEXCEPTION_RECORD exrec = exinfo->ExceptionRecord;
        -:11728:  LPSTR cmdline = GetCommandLine();
        -:11729:  LPSTR prg = strtok(cmdline, " ");
        -:11730:  CHAR errmsg[1024];
        -:11731:#ifdef USE_EVENT_LOG
        -:11732:  HANDLE hEventSource;
        -:11733:  LPTSTR lpszStrings[1];
        -:11734:#endif
        -:11735:
        -:11736:  if (! ISDB (DB_VERBOSE))
        -:11737:    {
        -:11738:      sprintf(errmsg,
        -:11739:              _("%s: Interrupt/Exception caught (code = 0x%x, addr = 0x%x)\n"),
        -:11740:              prg, exrec->ExceptionCode, exrec->ExceptionAddress);
        -:11741:      fprintf(stderr, errmsg);
        -:11742:      exit(255);
        -:11743:    }
        -:11744:
        -:11745:  sprintf(errmsg,
        -:11746:          _("\nUnhandled exception filter called from program %s\nExceptionCode = %x\nExceptionFlags = %x\nExceptionAddress = %x\n"),
        -:11747:          prg, exrec->ExceptionCode, exrec->ExceptionFlags,
        -:11748:          exrec->ExceptionAddress);
        -:11749:
        -:11750:  if (exrec->ExceptionCode == EXCEPTION_ACCESS_VIOLATION
        -:11751:      && exrec->NumberParameters >= 2)
        -:11752:    sprintf(&errmsg[strlen(errmsg)],
        -:11753:            (exrec->ExceptionInformation[0]
        -:11754:             ? _("Access violation: write operation at address %x\n")
        -:11755:             : _("Access violation: read operation at address %x\n")),
        -:11756:            exrec->ExceptionInformation[1]);
        -:11757:
        -:11758:  /* turn this on if we want to put stuff in the event log too */
        -:11759:#ifdef USE_EVENT_LOG
        -:11760:  hEventSource = RegisterEventSource(NULL, "GNU Make");
        -:11761:  lpszStrings[0] = errmsg;
        -:11762:
        -:11763:  if (hEventSource != NULL)
        -:11764:    {
        -:11765:      ReportEvent(hEventSource,         /* handle of event source */
        -:11766:                  EVENTLOG_ERROR_TYPE,  /* event type */
        -:11767:                  0,                    /* event category */
        -:11768:                  0,                    /* event ID */
        -:11769:                  NULL,                 /* current user's SID */
        -:11770:                  1,                    /* strings in lpszStrings */
        -:11771:                  0,                    /* no bytes of raw data */
        -:11772:                  lpszStrings,          /* array of error strings */
        -:11773:                  NULL);                /* no raw data */
        -:11774:
        -:11775:      (VOID) DeregisterEventSource(hEventSource);
        -:11776:    }
        -:11777:#endif
        -:11778:
        -:11779:  /* Write the error to stderr too */
        -:11780:  fprintf(stderr, errmsg);
        -:11781:
        -:11782:#ifdef DEBUG
        -:11783:  return EXCEPTION_CONTINUE_SEARCH;
        -:11784:#else
        -:11785:  exit(255);
        -:11786:  return (255); /* not reached */
        -:11787:#endif
        -:11788:}
        -:11789:
        -:11790:/*
        -:11791: * On WIN32 systems we don't have the luxury of a /bin directory that
        -:11792: * is mapped globally to every drive mounted to the system. Since make could
        -:11793: * be invoked from any drive, and we don't want to propogate /bin/sh
        -:11794: * to every single drive. Allow ourselves a chance to search for
        -:11795: * a value for default shell here (if the default path does not exist).
        -:11796: */
        -:11797:
        -:11798:int
        -:11799:find_and_set_default_shell(char *token)
        -:11800:{
        -:11801:  int sh_found = 0;
        -:11802:  char* search_token;
        -:11803:  PATH_VAR(sh_path);
        -:11804:  extern char *default_shell;
        -:11805:
        -:11806:  if (!token)
        -:11807:    search_token = default_shell;
        -:11808:  else
        -:11809:    search_token = token;
        -:11810:
        -:11811:  if (!no_default_sh_exe &&
        -:11812:      (token == NULL || !strcmp(search_token, default_shell))) {
        -:11813:    /* no new information, path already set or known */
        -:11814:    sh_found = 1;
        -:11815:  } else if (file_exists_p(search_token)) {
        -:11816:    /* search token path was found */
        -:11817:    sprintf(sh_path, "%s", search_token);
        -:11818:    default_shell = xstrdup(w32ify(sh_path,0));
        -:11819:    DB (DB_VERBOSE,
        -:11820:        (_("find_and_set_shell setting default_shell = %s\n"), default_shell));
        -:11821:    sh_found = 1;
        -:11822:  } else {
        -:11823:    char *p;
        -:11824:    struct variable *v = lookup_variable ("Path", 4);
        -:11825:
        -:11826:    /*
        -:11827:     * Search Path for shell
        -:11828:     */
        -:11829:    if (v && v->value) {
        -:11830:      char *ep;
        -:11831:
        -:11832:      p  = v->value;
        -:11833:      ep = strchr(p, PATH_SEPARATOR_CHAR);
        -:11834:
        -:11835:      while (ep && *ep) {
        -:11836:        *ep = '\0';
        -:11837:
        -:11838:        if (dir_file_exists_p(p, search_token)) {
        -:11839:          sprintf(sh_path, "%s/%s", p, search_token);
        -:11840:          default_shell = xstrdup(w32ify(sh_path,0));
        -:11841:          sh_found = 1;
        -:11842:          *ep = PATH_SEPARATOR_CHAR;
        -:11843:
        -:11844:          /* terminate loop */
        -:11845:          p += strlen(p);
        -:11846:        } else {
        -:11847:          *ep = PATH_SEPARATOR_CHAR;
        -:11848:           p = ++ep;
        -:11849:        }
        -:11850:
        -:11851:        ep = strchr(p, PATH_SEPARATOR_CHAR);
        -:11852:      }
        -:11853:
        -:11854:      /* be sure to check last element of Path */
        -:11855:      if (p && *p && dir_file_exists_p(p, search_token)) {
        -:11856:          sprintf(sh_path, "%s/%s", p, search_token);
        -:11857:          default_shell = xstrdup(w32ify(sh_path,0));
        -:11858:          sh_found = 1;
        -:11859:      }
        -:11860:
        -:11861:      if (sh_found)
        -:11862:        DB (DB_VERBOSE,
        -:11863:            (_("find_and_set_shell path search set default_shell = %s\n"),
        -:11864:             default_shell));
        -:11865:    }
        -:11866:  }
        -:11867:
        -:11868:  /* naive test */
        -:11869:  if (!unixy_shell && sh_found &&
        -:11870:      (strstr(default_shell, "sh") || strstr(default_shell, "SH"))) {
        -:11871:    unixy_shell = 1;
        -:11872:    batch_mode_shell = 0;
        -:11873:  }
        -:11874:
        -:11875:#ifdef BATCH_MODE_ONLY_SHELL
        -:11876:  batch_mode_shell = 1;
        -:11877:#endif
        -:11878:
        -:11879:  return (sh_found);
        -:11880:}
        -:11881:#endif  /* WINDOWS32 */
        -:11882:
        -:11883:#ifdef  __MSDOS__
        -:11884:
        -:11885:static void
        -:11886:msdos_return_to_initial_directory ()
        -:11887:{
        -:11888:  if (directory_before_chdir)
        -:11889:    chdir (directory_before_chdir);
        -:11890:}
        -:11891:#endif
        -:11892:
        -:11893:extern char *mktemp ();
        -:11894:extern int mkstemp ();
        -:11895:
        -:11896:FILE *
function open_tmpfile called 0 returned 0% blocks executed 0%
    #####:11897:open_tmpfile(name, template)
        -:11898:     char **name;
        -:11899:     const char *template;
        -:11900:{
        -:11901:  int fd;
        -:11902:
        -:11903:#if defined HAVE_MKSTEMP || defined HAVE_MKTEMP
        -:11904:# define TEMPLATE_LEN   strlen (template)
        -:11905:#else
        -:11906:# define TEMPLATE_LEN   L_tmpnam
        -:11907:#endif
    #####:11908:  *name = xmalloc (TEMPLATE_LEN + 1);
call    0 never executed
    #####:11909:  strcpy (*name, template);
        -:11910:
        -:11911:#if defined HAVE_MKSTEMP && defined HAVE_FDOPEN
        -:11912:  /* It's safest to use mkstemp(), if we can.  */
    #####:11913:  fd = mkstemp (*name);
call    0 never executed
    #####:11914:  if (fd == -1)
branch  0 never executed
branch  1 never executed
    #####:11915:    return 0;
    #####:11916:  return fdopen (fd, "w");
call    0 never executed
        -:11917:#else
        -:11918:# ifdef HAVE_MKTEMP
        -:11919:  (void) mktemp (*name);
        -:11920:# else
        -:11921:  (void) tmpnam (*name);
        -:11922:# endif
        -:11923:
        -:11924:# ifdef HAVE_FDOPEN
        -:11925:  /* Can't use mkstemp(), but guard against a race condition.  */
        -:11926:  fd = open (*name, O_CREAT|O_EXCL|O_WRONLY, 0600);
        -:11927:  if (fd == -1)
        -:11928:    return 0;
        -:11929:  return fdopen (fd, "w");
        -:11930:# else
        -:11931:  /* Not secure, but what can we do?  */
        -:11932:  return fopen (*name, "w");
        -:11933:# endif
        -:11934:#endif
        -:11935:}
        -:11936:
        -:11937:
        -:11938:#ifndef _AMIGA
        -:11939:int
function main called 1 returned 0% blocks executed 31%
        1:11940:main (argc, argv, envp)
        -:11941:     int argc;
        -:11942:     char **argv;
        -:11943:     char **envp;
        -:11944:#else
        -:11945:int main (int argc, char ** argv)
        -:11946:#endif
        -:11947:{
        -:11948:  static char *stdin_nm = 0;
        -:11949:  register struct file *f;
        -:11950:  register unsigned int i;
        -:11951:  char **p;
        -:11952:  struct dep *read_makefiles;
        -:11953:  PATH_VAR (current_directory);
        -:11954:#ifdef WINDOWS32
        -:11955:  char *unix_path = NULL;
        -:11956:  char *windows32_path = NULL;
        -:11957:
        -:11958:  SetUnhandledExceptionFilter(handle_runtime_exceptions);
        -:11959:
        -:11960:  /* start off assuming we have no shell */
        -:11961:  unixy_shell = 0;
        -:11962:  no_default_sh_exe = 1;
        -:11963:#endif
        -:11964:
        1:11965:  default_goal_file = 0;
        1:11966:  reading_file = 0;
        -:11967:
        -:11968:#if defined (__MSDOS__) && !defined (_POSIX_SOURCE)
        -:11969:  /* Request the most powerful version of `system', to
        -:11970:     make up for the dumb default shell.  */
        -:11971:  __system_flags = (__system_redirect
        -:11972:		    | __system_use_shell
        -:11973:		    | __system_allow_multiple_cmds
        -:11974:		    | __system_allow_long_cmds
        -:11975:		    | __system_handle_null_commands
        -:11976:		    | __system_emulate_chdir);
        -:11977:
        -:11978:#endif
        -:11979:
        -:11980:  /* Set up gettext/internationalization support.  */
        1:11981:  setlocale (LC_ALL, "");
call    0 returned 1
        1:11982:  bindtextdomain (PACKAGE, LOCALEDIR);
call    0 returned 1
        1:11983:  textdomain (PACKAGE);
call    0 returned 1
        -:11984:
        -:11985:#if !defined (HAVE_STRSIGNAL) && !defined (HAVE_SYS_SIGLIST)
        -:11986:  {
        -:11987:    extern void signame_init ();
        -:11988:    signame_init ();
        -:11989:  }
        -:11990:#endif
        -:11991:
        -:11992:#ifdef	POSIX
        1:11993:  sigemptyset (&fatal_signal_set);
call    0 returned 1
        -:11994:#define	ADD_SIG(sig)	sigaddset (&fatal_signal_set, sig)
        -:11995:#else
        -:11996:#ifdef	HAVE_SIGSETMASK
        -:11997:  fatal_signal_mask = 0;
        -:11998:#define	ADD_SIG(sig)	fatal_signal_mask |= sigmask (sig)
        -:11999:#else
        -:12000:#define	ADD_SIG(sig)
        -:12001:#endif
        -:12002:#endif
        -:12003:
        -:12004:#define	FATAL_SIG(sig)							      \
        -:12005:  if (signal ((sig), fatal_error_signal) == SIG_IGN)			      \
        -:12006:    (void) signal ((sig), SIG_IGN);					      \
        -:12007:  else									      \
        -:12008:    ADD_SIG (sig);
        -:12009:
        -:12010:#ifdef SIGHUP
       1*:12011:  FATAL_SIG (SIGHUP);
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
call    3 never executed
call    4 returned 1
        -:12012:#endif
        -:12013:#ifdef SIGQUIT
       1*:12014:  FATAL_SIG (SIGQUIT);
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
call    3 never executed
call    4 returned 1
        -:12015:#endif
       1*:12016:  FATAL_SIG (SIGINT);
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
call    3 never executed
call    4 returned 1
       1*:12017:  FATAL_SIG (SIGTERM);
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
call    3 never executed
call    4 returned 1
        -:12018:
        -:12019:#ifdef	SIGDANGER
        -:12020:  FATAL_SIG (SIGDANGER);
        -:12021:#endif
        -:12022:#ifdef SIGXCPU
       1*:12023:  FATAL_SIG (SIGXCPU);
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
call    3 never executed
call    4 returned 1
        -:12024:#endif
        -:12025:#ifdef SIGXFSZ
       1*:12026:  FATAL_SIG (SIGXFSZ);
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
call    3 never executed
call    4 returned 1
        -:12027:#endif
        -:12028:
        -:12029:#undef	FATAL_SIG
        -:12030:
        -:12031:  /* Do not ignore the child-death signal.  This must be done before
        -:12032:     any children could possibly be created; otherwise, the wait
        -:12033:     functions won't work on systems with the SVR4 ECHILD brain
        -:12034:     damage, if our invoker is ignoring this signal.  */
        -:12035:
        -:12036:#ifdef HAVE_WAIT_NOHANG
        -:12037:# if defined SIGCHLD
        1:12038:  (void) signal (SIGCHLD, SIG_DFL);
call    0 returned 1
        -:12039:# endif
        -:12040:# if defined SIGCLD && SIGCLD != SIGCHLD
        -:12041:  (void) signal (SIGCLD, SIG_DFL);
        -:12042:# endif
        -:12043:#endif
        -:12044:
        -:12045:  /* Make sure stdout is line-buffered.  */
        -:12046:
        -:12047:#ifdef	HAVE_SETLINEBUF
        1:12048:  setlinebuf (stdout);
call    0 returned 1
        -:12049:#else
        -:12050:#ifndef	SETVBUF_REVERSED
        -:12051:  setvbuf (stdout, (char *) 0, _IOLBF, BUFSIZ);
        -:12052:#else	/* setvbuf not reversed.  */
        -:12053:  /* Some buggy systems lose if we pass 0 instead of allocating ourselves.  */
        -:12054:  setvbuf (stdout, _IOLBF, xmalloc (BUFSIZ), BUFSIZ);
        -:12055:#endif	/* setvbuf reversed.  */
        -:12056:#endif	/* setlinebuf missing.  */
        -:12057:
        -:12058:  /* Figure out where this program lives.  */
        -:12059:
        1:12060:  if (argv[0] == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:12061:    argv[0] = "";
        1:12062:  if (argv[0][0] == '\0')
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:12063:    program = "make";
        -:12064:  else
        -:12065:    {
        -:12066:#ifdef VMS
        -:12067:      program = strrchr (argv[0], ']');
        -:12068:#else
        1:12069:      program = strrchr (argv[0], '/');
        -:12070:#endif
        -:12071:#ifdef __MSDOS__
        -:12072:      if (program == 0)
        -:12073:	program = strrchr (argv[0], '\\');
        -:12074:      else
        -:12075:	{
        -:12076:	  /* Some weird environments might pass us argv[0] with
        -:12077:	     both kinds of slashes; we must find the rightmost.  */
        -:12078:	  char *p = strrchr (argv[0], '\\');
        -:12079:	  if (p && p > program)
        -:12080:	    program = p;
        -:12081:	}
        -:12082:      if (program == 0 && argv[0][1] == ':')
        -:12083:	program = argv[0] + 1;
        -:12084:#endif
        1:12085:      if (program == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:12086:	program = argv[0];
        -:12087:      else
        1:12088:	++program;
        -:12089:    }
        -:12090:
        -:12091:  /* Set up to access user data (files).  */
        1:12092:  user_access ();
call    0 returned 1
        -:12093:
        -:12094:  /* Figure out where we are.  */
        -:12095:
        -:12096:#ifdef WINDOWS32
        -:12097:  if (getcwd_fs (current_directory, GET_PATH_MAX) == 0)
        -:12098:#else
        1:12099:  if (getcwd (current_directory, GET_PATH_MAX) == 0)
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
        -:12100:#endif
        -:12101:    {
        -:12102:#ifdef	HAVE_GETCWD
    #####:12103:      perror_with_name ("getcwd: ", "");
call    0 never executed
        -:12104:#else
        -:12105:      error (NILF, "getwd: %s", current_directory);
        -:12106:#endif
    #####:12107:      current_directory[0] = '\0';
    #####:12108:      directory_before_chdir = 0;
        -:12109:    }
        -:12110:  else
        1:12111:    directory_before_chdir = xstrdup (current_directory);
call    0 returned 1
        -:12112:#ifdef  __MSDOS__
        -:12113:  /* Make sure we will return to the initial directory, come what may.  */
        -:12114:  atexit (msdos_return_to_initial_directory);
        -:12115:#endif
        -:12116:
        -:12117:  /* Read in variables from the environment.  It is important that this be
        -:12118:     done before $(MAKE) is figured out so its definitions will not be
        -:12119:     from the environment.  */
        -:12120:
        -:12121:#ifndef _AMIGA
       51:12122:  for (i = 0; envp[i] != 0; ++i)
branch  0 taken 50
branch  1 taken 1 (fallthrough)
        -:12123:    {
        -:12124:      int do_not_define;
       50:12125:      register char *ep = envp[i];
        -:12126:
        -:12127:      /* by default, everything gets defined and exported */
       50:12128:      do_not_define = 0;
        -:12129:
      650:12130:      while (*ep != '=')
branch  0 taken 600
branch  1 taken 50 (fallthrough)
      600:12131:        ++ep;
        -:12132:#ifdef WINDOWS32
        -:12133:      if (!unix_path && strneq(envp[i], "PATH=", 5))
        -:12134:        unix_path = ep+1;
        -:12135:      else if (!windows32_path && !strnicmp(envp[i], "Path=", 5)) {
        -:12136:        do_not_define = 1; /* it gets defined after loop exits */
        -:12137:        windows32_path = ep+1;
        -:12138:      }
        -:12139:#endif
        -:12140:      /* The result of pointer arithmetic is cast to unsigned int for
        -:12141:	 machines where ptrdiff_t is a different size that doesn't widen
        -:12142:	 the same.  */
       50:12143:      if (!do_not_define)
branch  0 taken 50 (fallthrough)
branch  1 taken 0
       50:12144:        define_variable (envp[i], (unsigned int) (ep - envp[i]),
call    0 returned 50
        -:12145:                         ep + 1, o_env, 1)
        -:12146:	/* Force exportation of every variable culled from the environment.
        -:12147:	   We used to rely on target_environment's v_default code to do this.
        -:12148:	   But that does not work for the case where an environment variable
        -:12149:	   is redefined in a makefile with `override'; it should then still
        -:12150:	   be exported, because it was originally in the environment.  */
       50:12151:	->export = v_export;
        -:12152:    }
        -:12153:#ifdef WINDOWS32
        -:12154:    /*
        -:12155:     * Make sure that this particular spelling of 'Path' is available
        -:12156:     */
        -:12157:    if (windows32_path)
        -:12158:      define_variable("Path", 4, windows32_path, o_env, 1)->export = v_export;
        -:12159:    else if (unix_path)
        -:12160:      define_variable("Path", 4, unix_path, o_env, 1)->export = v_export;
        -:12161:    else
        -:12162:      define_variable("Path", 4, "", o_env, 1)->export = v_export;
        -:12163:
        -:12164:    /*
        -:12165:     * PATH defaults to Path iff PATH not found and Path is found.
        -:12166:     */
        -:12167:    if (!unix_path && windows32_path)
        -:12168:      define_variable("PATH", 4, windows32_path, o_env, 1)->export = v_export;
        -:12169:#endif
        -:12170:#else /* For Amiga, read the ENV: device, ignoring all dirs */
        -:12171:    {
        -:12172:	BPTR env, file, old;
        -:12173:	char buffer[1024];
        -:12174:	int len;
        -:12175:	__aligned struct FileInfoBlock fib;
        -:12176:
        -:12177:	env = Lock ("ENV:", ACCESS_READ);
        -:12178:	if (env)
        -:12179:	{
        -:12180:	    old = CurrentDir (DupLock(env));
        -:12181:	    Examine (env, &fib);
        -:12182:
        -:12183:	    while (ExNext (env, &fib))
        -:12184:	    {
        -:12185:		if (fib.fib_DirEntryType < 0) /* File */
        -:12186:		{
        -:12187:		    /* Define an empty variable. It will be filled in
        -:12188:			variable_lookup(). Makes startup quite a bit
        -:12189:			faster. */
        -:12190:			define_variable (fib.fib_FileName,
        -:12191:			    strlen (fib.fib_FileName),
        -:12192:			"", o_env, 1)->export = v_export;
        -:12193:		}
        -:12194:	    }
        -:12195:	    UnLock (env);
        -:12196:	    UnLock(CurrentDir(old));
        -:12197:	}
        -:12198:    }
        -:12199:#endif
        -:12200:
        -:12201:  /* Decode the switches.  */
        -:12202:
        1:12203:  decode_env_switches ("MAKEFLAGS", 9);
call    0 returned 1
        -:12204:#if 0
        -:12205:  /* People write things like:
        -:12206:     	MFLAGS="CC=gcc -pipe" "CFLAGS=-g"
        -:12207:     and we set the -p, -i and -e switches.  Doesn't seem quite right.  */
        -:12208:  decode_env_switches ("MFLAGS", 6);
        -:12209:#endif
        1:12210:  decode_switches (argc, argv, 0);
call    0 returned 1
        -:12211:#ifdef WINDOWS32
        -:12212:  if (suspend_flag) {
        -:12213:        fprintf(stderr, "%s (pid = %d)\n", argv[0], GetCurrentProcessId());
        -:12214:        fprintf(stderr, _("%s is suspending for 30 seconds..."), argv[0]);
        -:12215:        Sleep(30 * 1000);
        -:12216:        fprintf(stderr, _("done sleep(30). Continuing.\n"));
        -:12217:  }
        -:12218:#endif
        -:12219:
        1:12220:  decode_debug_flags ();
call    0 returned 1
        -:12221:
        -:12222:  /* Print version information.  */
        -:12223:
       1*:12224:  if (print_version_flag || print_data_base_flag || db_level)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 1
branch  4 never executed
branch  5 never executed
        1:12225:    print_version ();
call    0 returned 1
        -:12226:
        -:12227:  /* `make --version' is supposed to just print the version and exit.  */
        1:12228:  if (print_version_flag)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:12229:    die (0);
call    0 never executed
        -:12230:
        -:12231:#ifndef VMS
        -:12232:  /* Set the "MAKE_COMMAND" variable to the name we were invoked with.
        -:12233:     (If it is a relative pathname with a slash, prepend our directory name
        -:12234:     so the result will run the same program regardless of the current dir.
        -:12235:     If it is a name with no slash, we can only hope that PATH did not
        -:12236:     find it in the current directory.)  */
        -:12237:#ifdef WINDOWS32
        -:12238:  /*
        -:12239:   * Convert from backslashes to forward slashes for
        -:12240:   * programs like sh which don't like them. Shouldn't
        -:12241:   * matter if the path is one way or the other for
        -:12242:   * CreateProcess().
        -:12243:   */
        -:12244:  if (strpbrk(argv[0], "/:\\") ||
        -:12245:      strstr(argv[0], "..") ||
        -:12246:      strneq(argv[0], "//", 2))
        -:12247:    argv[0] = xstrdup(w32ify(argv[0],1));
        -:12248:#else /* WINDOWS32 */
        -:12249:#ifdef __MSDOS__
        -:12250:  if (strchr (argv[0], '\\'))
        -:12251:    {
        -:12252:      char *p;
        -:12253:
        -:12254:      argv[0] = xstrdup (argv[0]);
        -:12255:      for (p = argv[0]; *p; p++)
        -:12256:	if (*p == '\\')
        -:12257:	  *p = '/';
        -:12258:    }
        -:12259:  /* If argv[0] is not in absolute form, prepend the current
        -:12260:     directory.  This can happen when Make is invoked by another DJGPP
        -:12261:     program that uses a non-absolute name.  */
        -:12262:  if (current_directory[0] != '\0'
        -:12263:      && argv[0] != 0
        -:12264:      && (argv[0][0] != '/' && (argv[0][0] == '\0' || argv[0][1] != ':')))
        -:12265:    argv[0] = concat (current_directory, "/", argv[0]);
        -:12266:#else  /* !__MSDOS__ */
        1:12267:  if (current_directory[0] != '\0'
branch  0 taken 1 (fallthrough)
branch  1 taken 0
       1*:12268:      && argv[0] != 0 && argv[0][0] != '/' && strchr (argv[0], '/') != 0)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 1
branch  4 never executed
branch  5 never executed
    #####:12269:    argv[0] = concat (current_directory, "/", argv[0]);
call    0 never executed
        -:12270:#endif /* !__MSDOS__ */
        -:12271:#endif /* WINDOWS32 */
        -:12272:#endif
        -:12273:
        -:12274:  /* The extra indirection through $(MAKE_COMMAND) is done
        -:12275:     for hysterical raisins.  */
        1:12276:  (void) define_variable ("MAKE_COMMAND", 12, argv[0], o_default, 0);
call    0 returned 1
        1:12277:  (void) define_variable ("MAKE", 4, "$(MAKE_COMMAND)", o_default, 1);
call    0 returned 1
        -:12278:
        1:12279:  if (command_variables != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -:12280:    {
        -:12281:      struct command_variable *cv;
        -:12282:      struct variable *v;
    #####:12283:      unsigned int len = 0;
        -:12284:      char *value, *p;
        -:12285:
        -:12286:      /* Figure out how much space will be taken up by the command-line
        -:12287:	 variable definitions.  */
    #####:12288:      for (cv = command_variables; cv != 0; cv = cv->next)
branch  0 never executed
branch  1 never executed
        -:12289:	{
    #####:12290:	  v = cv->variable;
    #####:12291:	  len += 2 * strlen (v->name);
    #####:12292:	  if (! v->recursive)
branch  0 never executed
branch  1 never executed
    #####:12293:	    ++len;
    #####:12294:	  ++len;
    #####:12295:	  len += 2 * strlen (v->value);
    #####:12296:	  ++len;
        -:12297:	}
        -:12298:
        -:12299:      /* Now allocate a buffer big enough and fill it.  */
        -:12300:#ifndef F_AA_1
        -:12301:      p = value = (char *) alloca (len);
        -:12302:#else
    #####:12303:      p = (char *) alloca (len);
        -:12304:#endif
    #####:12305:      for (cv = command_variables; cv != 0; cv = cv->next)
branch  0 never executed
branch  1 never executed
        -:12306:	{
    #####:12307:	  v = cv->variable;
    #####:12308:	  p = quote_for_env (p, v->name);
call    0 never executed
    #####:12309:	  if (! v->recursive)
branch  0 never executed
branch  1 never executed
    #####:12310:	    *p++ = ':';
    #####:12311:	  *p++ = '=';
    #####:12312:	  p = quote_for_env (p, v->value);
call    0 never executed
    #####:12313:	  *p++ = ' ';
        -:12314:	}
    #####:12315:      p[-1] = '\0';		/* Kill the final space and terminate.  */
        -:12316:
        -:12317:      /* Define an unchangeable variable with a name that no POSIX.2
        -:12318:	 makefile could validly use for its own variable.  */
    #####:12319:      (void) define_variable ("-*-command-variables-*-", 23,
call    0 never executed
        -:12320:			      value, o_automatic, 0);
        -:12321:
        -:12322:      /* Define the variable; this will not override any user definition.
        -:12323:         Normally a reference to this variable is written into the value of
        -:12324:         MAKEFLAGS, allowing the user to override this value to affect the
        -:12325:         exported value of MAKEFLAGS.  In POSIX-pedantic mode, we cannot
        -:12326:         allow the user's setting of MAKEOVERRIDES to affect MAKEFLAGS, so
        -:12327:         a reference to this hidden variable is written instead. */
    #####:12328:      (void) define_variable ("MAKEOVERRIDES", 13,
call    0 never executed
        -:12329:			      "${-*-command-variables-*-}", o_env, 1);
        -:12330:    }
        -:12331:
        -:12332:  /* If there were -C flags, move ourselves about.  */
        1:12333:  if (directories != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:12334:    for (i = 0; directories->list[i] != 0; ++i)
branch  0 never executed
branch  1 never executed
        -:12335:      {
    #####:12336:	char *dir = directories->list[i];
    #####:12337:	if (dir[0] == '~')
branch  0 never executed
branch  1 never executed
        -:12338:	  {
    #####:12339:	    char *expanded = tilde_expand (dir);
call    0 never executed
    #####:12340:	    if (expanded != 0)
branch  0 never executed
branch  1 never executed
    #####:12341:	      dir = expanded;
        -:12342:	  }
    #####:12343:	if (chdir (dir) < 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:12344:	  pfatal_with_name (dir);
call    0 never executed
    #####:12345:	if (dir != directories->list[i])
branch  0 never executed
branch  1 never executed
    #####:12346:	  free (dir);
        -:12347:      }
        -:12348:
        -:12349:#ifdef WINDOWS32
        -:12350:  /*
        -:12351:   * THIS BLOCK OF CODE MUST COME AFTER chdir() CALL ABOVE IN ORDER
        -:12352:   * TO NOT CONFUSE THE DEPENDENCY CHECKING CODE IN implicit.c.
        -:12353:   *
        -:12354:   * The functions in dir.c can incorrectly cache information for "."
        -:12355:   * before we have changed directory and this can cause file
        -:12356:   * lookups to fail because the current directory (.) was pointing
        -:12357:   * at the wrong place when it was first evaluated.
        -:12358:   */
        -:12359:   no_default_sh_exe = !find_and_set_default_shell(NULL);
        -:12360:
        -:12361:#endif /* WINDOWS32 */
        -:12362:  /* Figure out the level of recursion.  */
        -:12363:  {
        1:12364:    struct variable *v = lookup_variable ("MAKELEVEL", 9);
call    0 returned 1
       1*:12365:    if (v != 0 && *v->value != '\0' && *v->value != '-')
branch  0 taken 0 (fallthrough)
branch  1 taken 1
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:12366:      makelevel = (unsigned int) atoi (v->value);
        -:12367:    else
        1:12368:      makelevel = 0;
        -:12369:  }
        -:12370:
        -:12371:  /* Except under -s, always do -w in sub-makes and under -C.  */
       1*:12372:  if (!silent_flag && (directories != 0 || makelevel > 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 1
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:12373:    print_directory_flag = 1;
        -:12374:
        -:12375:  /* Let the user disable that with --no-print-directory.  */
        1:12376:  if (inhibit_print_directory_flag)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:12377:    print_directory_flag = 0;
        -:12378:
        -:12379:  /* If -R was given, set -r too (doesn't make sense otherwise!)  */
        1:12380:  if (no_builtin_variables_flag)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:12381:    no_builtin_rules_flag = 1;
        -:12382:
        -:12383:  /* Construct the list of include directories to search.  */
        -:12384:
       1*:12385:  construct_include_path (include_directories == 0 ? (char **) 0
branch  0 taken 0 (fallthrough)
branch  1 taken 1
call    2 returned 1
    #####:12386:			  : include_directories->list);
        -:12387:
        -:12388:  /* Figure out where we are now, after chdir'ing.  */
        1:12389:  if (directories == 0)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -:12390:    /* We didn't move, so we're still in the same place.  */
        1:12391:    starting_directory = current_directory;
        -:12392:  else
        -:12393:    {
        -:12394:#ifdef WINDOWS32
        -:12395:      if (getcwd_fs (current_directory, GET_PATH_MAX) == 0)
        -:12396:#else
    #####:12397:      if (getcwd (current_directory, GET_PATH_MAX) == 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:12398:#endif
        -:12399:	{
        -:12400:#ifdef	HAVE_GETCWD
    #####:12401:	  perror_with_name ("getcwd: ", "");
call    0 never executed
        -:12402:#else
        -:12403:	  error (NILF, "getwd: %s", current_directory);
        -:12404:#endif
    #####:12405:	  starting_directory = 0;
        -:12406:	}
        -:12407:      else
    #####:12408:	starting_directory = current_directory;
        -:12409:    }
        -:12410:
        1:12411:  (void) define_variable ("CURDIR", 6, current_directory, o_default, 0);
call    0 returned 1
        -:12412:
        -:12413:  /* Read any stdin makefiles into temporary files.  */
        -:12414:
        1:12415:  if (makefiles != 0)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -:12416:    {
        -:12417:      register unsigned int i;
        2:12418:      for (i = 0; i < makefiles->idx; ++i)
branch  0 taken 1
branch  1 taken 1 (fallthrough)
       1*:12419:	if (makefiles->list[i][0] == '-' && makefiles->list[i][1] == '\0')
branch  0 taken 0 (fallthrough)
branch  1 taken 1
branch  2 never executed
branch  3 never executed
        -:12420:	  {
        -:12421:	    /* This makefile is standard input.  Since we may re-exec
        -:12422:	       and thus re-read the makefiles, we read standard input
        -:12423:	       into a temporary file and read from that.  */
        -:12424:	    FILE *outfile;
        -:12425:
    #####:12426:            if (stdin_nm)
branch  0 never executed
branch  1 never executed
    #####:12427:              fatal (NILF, _("Makefile from standard input specified twice."));
call    0 never executed
        -:12428:
        -:12429:#ifdef VMS
        -:12430:# define TMP_TEMPLATE   "sys$scratch:GmXXXXXX"
        -:12431:#else
        -:12432:# define TMP_TEMPLATE   "/tmp/GmXXXXXX"
        -:12433:#endif
        -:12434:
    #####:12435:	    outfile = open_tmpfile (&stdin_nm, TMP_TEMPLATE);
call    0 never executed
    #####:12436:	    if (outfile == 0)
branch  0 never executed
branch  1 never executed
    #####:12437:	      pfatal_with_name (_("fopen (temporary file)"));
call    0 never executed
    #####:12438:	    while (!feof (stdin))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:12439:	      {
        -:12440:		char buf[2048];
    #####:12441:		unsigned int n = fread (buf, 1, sizeof (buf), stdin);
call    0 never executed
    #####:12442:		if (n > 0 && fwrite (buf, 1, n, outfile) != n)
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:12443:		  pfatal_with_name (_("fwrite (temporary file)"));
call    0 never executed
        -:12444:	      }
    #####:12445:	    (void) fclose (outfile);
call    0 never executed
        -:12446:
        -:12447:	    /* Replace the name that read_all_makefiles will
        -:12448:	       see with the name of the temporary file.  */
    #####:12449:            makefiles->list[i] = xstrdup (stdin_nm);
call    0 never executed
        -:12450:
        -:12451:	    /* Make sure the temporary file will not be remade.  */
    #####:12452:	    f = enter_file (stdin_nm);
call    0 never executed
    #####:12453:	    f->updated = 1;
    #####:12454:	    f->update_status = 0;
    #####:12455:	    f->command_state = cs_finished;
        -:12456: 	    /* Can't be intermediate, or it'll be removed too early for
        -:12457:               make re-exec.  */
    #####:12458: 	    f->intermediate = 0;
    #####:12459:	    f->dontcare = 0;
        -:12460:	  }
        -:12461:    }
        -:12462:
        -:12463:#if defined(MAKE_JOBSERVER) || !defined(HAVE_WAIT_NOHANG)
        -:12464:  /* Set up to handle children dying.  This must be done before
        -:12465:     reading in the makefiles so that `shell' function calls will work.
        -:12466:
        -:12467:     If we don't have a hanging wait we have to fall back to old, broken
        -:12468:     functionality here and rely on the signal handler and counting
        -:12469:     children.
        -:12470:
        -:12471:     If we're using the jobs pipe we need a signal handler so that
        -:12472:     SIGCHLD is not ignored; we need it to interrupt the read(2) of the
        -:12473:     jobserver pipe in job.c if we're waiting for a token.
        -:12474:
        -:12475:     If none of these are true, we don't need a signal handler at all.  */
        -:12476:  {
        -:12477:    extern RETSIGTYPE child_handler PARAMS ((int sig));
        -:12478:
        -:12479:# if defined HAVE_SIGACTION
        -:12480:    struct sigaction sa;
        -:12481:
        1:12482:    bzero ((char *)&sa, sizeof (struct sigaction));
        1:12483:    sa.sa_handler = child_handler;
        -:12484:#  if defined SA_INTERRUPT
        -:12485:    /* This is supposed to be the default, but what the heck... */
        1:12486:    sa.sa_flags = SA_INTERRUPT;
        -:12487:#  endif
        -:12488:#  define HANDLESIG(s) sigaction (s, &sa, NULL)
        -:12489:# else
        -:12490:#  define HANDLESIG(s) signal (s, child_handler)
        -:12491:# endif
        -:12492:
        -:12493:    /* OK, now actually install the handlers.  */
        -:12494:# if defined SIGCHLD
        1:12495:    (void) HANDLESIG (SIGCHLD);
call    0 returned 1
        -:12496:# endif
        -:12497:# if defined SIGCLD && SIGCLD != SIGCHLD
        -:12498:    (void) HANDLESIG (SIGCLD);
        -:12499:# endif
        -:12500:  }
        -:12501:#endif
        -:12502:
        -:12503:  /* Let the user send us SIGUSR1 to toggle the -d flag during the run.  */
        -:12504:#ifdef SIGUSR1
        1:12505:  (void) signal (SIGUSR1, debug_signal_handler);
call    0 returned 1
        -:12506:#endif
        -:12507:
        -:12508:  /* Define the initial list of suffixes for old-style rules.  */
        -:12509:
        1:12510:  set_default_suffixes ();
call    0 returned 1
        -:12511:
        -:12512:  /* Define the file rules for the built-in suffix rules.  These will later
        -:12513:     be converted into pattern rules.  We used to do this in
        -:12514:     install_default_implicit_rules, but since that happens after reading
        -:12515:     makefiles, it results in the built-in pattern rules taking precedence
        -:12516:     over makefile-specified suffix rules, which is wrong.  */
        -:12517:
        1:12518:  install_default_suffix_rules ();
call    0 returned 1
        -:12519:
        -:12520:  /* Define some internal and special variables.  */
        -:12521:
        1:12522:  define_automatic_variables ();
call    0 returned 1
        -:12523:
        -:12524:  /* Set up the MAKEFLAGS and MFLAGS variables
        -:12525:     so makefiles can look at them.  */
        -:12526:
        1:12527:  define_makeflags (0, 0);
call    0 returned 1
        -:12528:
        -:12529:  /* Define the default variables.  */
        1:12530:  define_default_variables ();
call    0 returned 1
        -:12531:
        -:12532:  /* Read all the makefiles.  */
        -:12533:
        1:12534:  default_file = enter_file (".DEFAULT");
call    0 returned 1
        -:12535:
        -:12536:  read_makefiles
       1*:12537:    = read_all_makefiles (makefiles == 0 ? (char **) 0 : makefiles->list);
branch  0 taken 1 (fallthrough)
branch  1 taken 0
call    2 returned 1
        -:12538:
        -:12539:#ifdef WINDOWS32
        -:12540:  /* look one last time after reading all Makefiles */
        -:12541:  if (no_default_sh_exe)
        -:12542:    no_default_sh_exe = !find_and_set_default_shell(NULL);
        -:12543:
        -:12544:  if (no_default_sh_exe && job_slots != 1) {
        -:12545:    error (NILF, _("Do not specify -j or --jobs if sh.exe is not available."));
        -:12546:    error (NILF, _("Resetting make for single job mode."));
        -:12547:    job_slots = 1;
        -:12548:  }
        -:12549:#endif /* WINDOWS32 */
        -:12550:
        -:12551:#ifdef __MSDOS__
        -:12552:  /* We need to know what kind of shell we will be using.  */
        -:12553:  {
        -:12554:    extern int _is_unixy_shell (const char *_path);
        -:12555:    struct variable *shv = lookup_variable ("SHELL", 5);
        -:12556:    extern int unixy_shell;
        -:12557:    extern char *default_shell;
        -:12558:
        -:12559:    if (shv && *shv->value)
        -:12560:      {
        -:12561:	char *shell_path = recursively_expand(shv);
        -:12562:
        -:12563:	if (shell_path && _is_unixy_shell (shell_path))
        -:12564:	  unixy_shell = 1;
        -:12565:	else
        -:12566:	  unixy_shell = 0;
        -:12567:	if (shell_path)
        -:12568:	  default_shell = shell_path;
        -:12569:      }
        -:12570:  }
        -:12571:#endif /* __MSDOS__ */
        -:12572:
        -:12573:  /* Decode switches again, in case the variables were set by the makefile.  */
        1:12574:  decode_env_switches ("MAKEFLAGS", 9);
call    0 returned 1
        -:12575:#if 0
        -:12576:  decode_env_switches ("MFLAGS", 6);
        -:12577:#endif
        -:12578:
        -:12579:#ifdef __MSDOS__
        -:12580:  if (job_slots != 1)
        -:12581:    {
        -:12582:      error (NILF,
        -:12583:             _("Parallel jobs (-j) are not supported on this platform."));
        -:12584:      error (NILF, _("Resetting to single job (-j1) mode."));
        -:12585:      job_slots = 1;
        -:12586:    }
        -:12587:#endif
        -:12588:
        -:12589:#ifdef MAKE_JOBSERVER
        -:12590:  /* If the jobserver-fds option is seen, make sure that -j is reasonable.  */
        -:12591:
        1:12592:  if (jobserver_fds)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -:12593:  {
        -:12594:    char *cp;
        -:12595:
    #####:12596:    for (i=1; i < jobserver_fds->idx; ++i)
branch  0 never executed
branch  1 never executed
    #####:12597:      if (!streq (jobserver_fds->list[0], jobserver_fds->list[i]))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:12598:        fatal (NILF, _("internal error: multiple --jobserver-fds options"));
call    0 never executed
        -:12599:
        -:12600:    /* Now parse the fds string and make sure it has the proper format.  */
        -:12601:
    #####:12602:    cp = jobserver_fds->list[0];
        -:12603:
    #####:12604:    if (sscanf (cp, "%d,%d", &job_fds[0], &job_fds[1]) != 2)
branch  0 never executed
branch  1 never executed
    #####:12605:      fatal (NILF,
    #####:12606:             _("internal error: invalid --jobserver-fds string `%s'"), cp);
call    0 never executed
        -:12607:
        -:12608:    /* The combination of a pipe + !job_slots means we're using the
        -:12609:       jobserver.  If !job_slots and we don't have a pipe, we can start
        -:12610:       infinite jobs.  If we see both a pipe and job_slots >0 that means the
        -:12611:       user set -j explicitly.  This is broken; in this case obey the user
        -:12612:       (ignore the jobserver pipe for this make) but print a message.  */
        -:12613:
    #####:12614:    if (job_slots > 0)
branch  0 never executed
branch  1 never executed
    #####:12615:      error (NILF,
    #####:12616:             _("warning: -jN forced in submake: disabling jobserver mode."));
call    0 never executed
        -:12617:
        -:12618:    /* Create a duplicate pipe, that will be closed in the SIGCHLD
        -:12619:       handler.  If this fails with EBADF, the parent has closed the pipe
        -:12620:       on us because it didn't think we were a submake.  If so, print a
        -:12621:       warning then default to -j1.  */
        -:12622:
    #####:12623:    else if ((job_rfd = dup (job_fds[0])) < 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:12624:      {
    #####:12625:        if (errno != EBADF)
branch  0 never executed
branch  1 never executed
    #####:12626:          pfatal_with_name (_("dup jobserver"));
call    0 never executed
        -:12627:
    #####:12628:        error (NILF,
    #####:12629:               _("warning: jobserver unavailable: using -j1.  Add `+' to parent make rule."));
call    0 never executed
    #####:12630:        job_slots = 1;
        -:12631:      }
        -:12632:
    #####:12633:    if (job_slots > 0)
branch  0 never executed
branch  1 never executed
        -:12634:      {
    #####:12635:        close (job_fds[0]);
call    0 never executed
    #####:12636:        close (job_fds[1]);
call    0 never executed
    #####:12637:        job_fds[0] = job_fds[1] = -1;
    #####:12638:        free (jobserver_fds->list);
    #####:12639:        free (jobserver_fds);
    #####:12640:        jobserver_fds = 0;
        -:12641:      }
        -:12642:  }
        -:12643:
        -:12644:  /* If we have >1 slot but no jobserver-fds, then we're a top-level make.
        -:12645:     Set up the pipe and install the fds option for our children.  */
        -:12646:
        1:12647:  if (job_slots > 1)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -:12648:    {
    #####:12649:      char c = '+';
        -:12650:
    #####:12651:      if (pipe (job_fds) < 0 || (job_rfd = dup (job_fds[0])) < 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:12652:	pfatal_with_name (_("creating jobs pipe"));
call    0 never executed
        -:12653:
        -:12654:      /* Every make assumes that it always has one job it can run.  For the
        -:12655:         submakes it's the token they were given by their parent.  For the
        -:12656:         top make, we just subtract one from the number the user wants.  We
        -:12657:         want job_slots to be 0 to indicate we're using the jobserver.  */
        -:12658:
    #####:12659:      while (--job_slots)
branch  0 never executed
branch  1 never executed
    #####:12660:        while (write (job_fds[1], &c, 1) != 1)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:12661:          if (!EINTR_SET)
branch  0 never executed
branch  1 never executed
    #####:12662:            pfatal_with_name (_("init jobserver pipe"));
call    0 never executed
        -:12663:
        -:12664:      /* Fill in the jobserver_fds struct for our children.  */
        -:12665:
    #####:12666:      jobserver_fds = (struct stringlist *)
    #####:12667:                        xmalloc (sizeof (struct stringlist));
call    0 never executed
    #####:12668:      jobserver_fds->list = (char **) xmalloc (sizeof (char *));
call    0 never executed
    #####:12669:      jobserver_fds->list[0] = xmalloc ((sizeof ("1024")*2)+1);
call    0 never executed
        -:12670:
    #####:12671:      sprintf (jobserver_fds->list[0], "%d,%d", job_fds[0], job_fds[1]);
    #####:12672:      jobserver_fds->idx = 1;
    #####:12673:      jobserver_fds->max = 1;
        -:12674:    }
        -:12675:#endif
        -:12676:
        -:12677:  /* Set up MAKEFLAGS and MFLAGS again, so they will be right.  */
        -:12678:
        1:12679:  define_makeflags (1, 0);
call    0 returned 1
        -:12680:
        -:12681:  /* Make each `struct dep' point at the `struct file' for the file
        -:12682:     depended on.  Also do magic for special targets.  */
        -:12683:
        1:12684:  snap_deps ();
call    0 returned 1
        -:12685:
        -:12686:  /* Convert old-style suffix rules to pattern rules.  It is important to
        -:12687:     do this before installing the built-in pattern rules below, so that
        -:12688:     makefile-specified suffix rules take precedence over built-in pattern
        -:12689:     rules.  */
        -:12690:
        1:12691:  convert_to_pattern ();
call    0 returned 1
        -:12692:
        -:12693:  /* Install the default implicit pattern rules.
        -:12694:     This used to be done before reading the makefiles.
        -:12695:     But in that case, built-in pattern rules were in the chain
        -:12696:     before user-defined ones, so they matched first.  */
        -:12697:
        1:12698:  install_default_implicit_rules ();
call    0 returned 1
        -:12699:
        -:12700:  /* Compute implicit rule limits.  */
        -:12701:
        1:12702:  count_implicit_rule_limits ();
call    0 returned 1
        -:12703:
        -:12704:  /* Construct the listings of directories in VPATH lists.  */
        -:12705:
        1:12706:  build_vpath_lists ();
call    0 returned 1
        -:12707:
        -:12708:  /* Mark files given with -o flags as very old (00:00:01.00 Jan 1, 1970)
        -:12709:     and as having been updated already, and files given with -W flags as
        -:12710:     brand new (time-stamp as far as possible into the future).  */
        -:12711:
        1:12712:  if (old_files != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:12713:    for (p = old_files->list; *p != 0; ++p)
branch  0 never executed
branch  1 never executed
        -:12714:      {
    #####:12715:	f = enter_command_line_file (*p);
call    0 never executed
    #####:12716:	f->last_mtime = f->mtime_before_update = (FILE_TIMESTAMP) 1;
    #####:12717:	f->updated = 1;
    #####:12718:	f->update_status = 0;
    #####:12719:	f->command_state = cs_finished;
        -:12720:      }
        -:12721:
        1:12722:  if (new_files != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -:12723:    {
    #####:12724:      for (p = new_files->list; *p != 0; ++p)
branch  0 never executed
branch  1 never executed
        -:12725:	{
    #####:12726:	  f = enter_command_line_file (*p);
call    0 never executed
    #####:12727:	  f->last_mtime = f->mtime_before_update = NEW_MTIME;
        -:12728:	}
        -:12729:    }
        -:12730:
        -:12731:  /* Initialize the remote job module.  */
        1:12732:  remote_setup ();
call    0 returned 1
        -:12733:
        1:12734:  if (read_makefiles != 0)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -:12735:    {
        -:12736:      /* Update any makefiles if necessary.  */
        -:12737:
        1:12738:      FILE_TIMESTAMP *makefile_mtimes = 0;
        1:12739:      unsigned int mm_idx = 0;
        1:12740:      char **nargv = argv;
        1:12741:      int nargc = argc;
        1:12742:      int orig_db_level = db_level;
        -:12743:
        1:12744:      if (! ISDB (DB_MAKEFILES))
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:12745:        db_level = DB_NONE;
        -:12746:
        1:12747:      DB (DB_BASIC, (_("Updating makefiles....\n")));
branch  0 taken 1 (fallthrough)
branch  1 taken 0
call    2 returned 1
call    3 returned 1
        -:12748:
        -:12749:      /* Remove any makefiles we don't want to try to update.
        -:12750:	 Also record the current modtimes so we can compare them later.  */
        -:12751:      {
        -:12752:	register struct dep *d, *last;
        1:12753:	last = 0;
        1:12754:	d = read_makefiles;
        2:12755:	while (d != 0)
branch  0 taken 1
branch  1 taken 1 (fallthrough)
        -:12756:	  {
        1:12757:	    register struct file *f = d->file;
        1:12758:	    if (f->double_colon)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:12759:	      for (f = f->double_colon; f != NULL; f = f->prev)
branch  0 never executed
branch  1 never executed
        -:12760:		{
    #####:12761:		  if (f->deps == 0 && f->cmds != 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:12762:		    {
        -:12763:		      /* This makefile is a :: target with commands, but
        -:12764:			 no dependencies.  So, it will always be remade.
        -:12765:			 This might well cause an infinite loop, so don't
        -:12766:			 try to remake it.  (This will only happen if
        -:12767:			 your makefiles are written exceptionally
        -:12768:			 stupidly; but if you work for Athena, that's how
        -:12769:			 you write your makefiles.)  */
        -:12770:
    #####:12771:		      DB (DB_VERBOSE,
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
        -:12772:                          (_("Makefile `%s' might loop; not remaking it.\n"),
        -:12773:                           f->name));
        -:12774:
    #####:12775:		      if (last == 0)
branch  0 never executed
branch  1 never executed
    #####:12776:			read_makefiles = d->next;
        -:12777:		      else
    #####:12778:			last->next = d->next;
        -:12779:
        -:12780:		      /* Free the storage.  */
    #####:12781:		      free ((char *) d);
        -:12782:
    #####:12783:		      d = last == 0 ? read_makefiles : last->next;
branch  0 never executed
branch  1 never executed
        -:12784:
    #####:12785:		      break;
        -:12786:		    }
        -:12787:		}
        1:12788:	    if (f == NULL || !f->double_colon)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
branch  2 taken 1 (fallthrough)
branch  3 taken 0
        -:12789:	      {
        -:12790:                makefile_mtimes = (FILE_TIMESTAMP *)
        1:12791:                  xrealloc ((char *) makefile_mtimes,
        1:12792:                            (mm_idx + 1) * sizeof (FILE_TIMESTAMP));
call    0 returned 1
       1*:12793:		makefile_mtimes[mm_idx++] = file_mtime_no_search (d->file);
branch  0 taken 0 (fallthrough)
branch  1 taken 1
call    2 returned 1
        1:12794:		last = d;
        1:12795:		d = d->next;
        -:12796:	      }
        -:12797:	  }
        -:12798:      }
        -:12799:
        -:12800:      /* Set up `MAKEFLAGS' specially while remaking makefiles.  */
        1:12801:      define_makeflags (1, 1);
call    0 returned 1
        -:12802:
       1*:12803:      switch (update_goal_chain (read_makefiles, 1))
call    0 returned 0
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -:12804:	{
    #####:12805:	case 1:
        -:12806:	default:
        -:12807:#define BOGUS_UPDATE_STATUS 0
    #####:12808:	  assert (BOGUS_UPDATE_STATUS);
call    0 never executed
        -:12809:	  break;
        -:12810:
    #####:12811:	case -1:
        -:12812:	  /* Did nothing.  */
    #####:12813:	  break;
        -:12814:
    #####:12815:	case 2:
        -:12816:	  /* Failed to update.  Figure out if we care.  */
        -:12817:	  {
        -:12818:	    /* Nonzero if any makefile was successfully remade.  */
    #####:12819:	    int any_remade = 0;
        -:12820:	    /* Nonzero if any makefile we care about failed
        -:12821:	       in updating or could not be found at all.  */
    #####:12822:	    int any_failed = 0;
        -:12823:	    register unsigned int i;
        -:12824:            struct dep *d;
        -:12825:
    #####:12826:	    for (i = 0, d = read_makefiles; d != 0; ++i, d = d->next)
branch  0 never executed
branch  1 never executed
        -:12827:              {
        -:12828:                /* Reset the considered flag; we may need to look at the file
        -:12829:                   again to print an error.  */
    #####:12830:                d->file->considered = 0;
        -:12831:
    #####:12832:                if (d->file->updated)
branch  0 never executed
branch  1 never executed
        -:12833:                  {
        -:12834:                    /* This makefile was updated.  */
    #####:12835:                    if (d->file->update_status == 0)
branch  0 never executed
branch  1 never executed
        -:12836:                      {
        -:12837:                        /* It was successfully updated.  */
    #####:12838:                        any_remade |= (file_mtime_no_search (d->file)
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:12839:                                       != makefile_mtimes[i]);
        -:12840:                      }
    #####:12841:                    else if (! (d->changed & RM_DONTCARE))
branch  0 never executed
branch  1 never executed
        -:12842:                      {
        -:12843:                        FILE_TIMESTAMP mtime;
        -:12844:                        /* The update failed and this makefile was not
        -:12845:                           from the MAKEFILES variable, so we care.  */
    #####:12846:                        error (NILF, _("Failed to remake makefile `%s'."),
    #####:12847:                               d->file->name);
call    0 never executed
    #####:12848:                        mtime = file_mtime_no_search (d->file);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:12849:                        any_remade |= (mtime != (FILE_TIMESTAMP) -1
    #####:12850:                                       && mtime != makefile_mtimes[i]);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:12851:                      }
        -:12852:                  }
        -:12853:                else
        -:12854:                  /* This makefile was not found at all.  */
    #####:12855:                  if (! (d->changed & RM_DONTCARE))
branch  0 never executed
branch  1 never executed
        -:12856:                    {
        -:12857:                      /* This is a makefile we care about.  See how much.  */
    #####:12858:                      if (d->changed & RM_INCLUDED)
branch  0 never executed
branch  1 never executed
        -:12859:                        /* An included makefile.  We don't need
        -:12860:                           to die, but we do want to complain.  */
    #####:12861:                        error (NILF,
    #####:12862:                               _("Included makefile `%s' was not found."),
call    0 never executed
    #####:12863:                               dep_name (d));
branch  0 never executed
branch  1 never executed
        -:12864:                      else
        -:12865:                        {
        -:12866:                          /* A normal makefile.  We must die later.  */
    #####:12867:                          error (NILF, _("Makefile `%s' was not found"),
call    0 never executed
    #####:12868:                                 dep_name (d));
branch  0 never executed
branch  1 never executed
    #####:12869:                          any_failed = 1;
        -:12870:                        }
        -:12871:                    }
        -:12872:              }
        -:12873:            /* Reset this to empty so we get the right error message below.  */
    #####:12874:            read_makefiles = 0;
        -:12875:
    #####:12876:	    if (any_remade)
branch  0 never executed
branch  1 never executed
    #####:12877:	      goto re_exec;
    #####:12878:	    if (any_failed)
branch  0 never executed
branch  1 never executed
    #####:12879:	      die (2);
call    0 never executed
    #####:12880:            break;
        -:12881:	  }
        -:12882:
        -:12883:	case 0:
    #####:12884:	re_exec:
        -:12885:	  /* Updated successfully.  Re-exec ourselves.  */
        -:12886:
    #####:12887:	  remove_intermediates (0);
call    0 never executed
        -:12888:
    #####:12889:	  if (print_data_base_flag)
branch  0 never executed
branch  1 never executed
    #####:12890:	    print_data_base ();
call    0 never executed
        -:12891:
    #####:12892:	  log_working_directory (0);
call    0 never executed
        -:12893:
    #####:12894:	  if (makefiles != 0)
branch  0 never executed
branch  1 never executed
        -:12895:	    {
        -:12896:	      /* These names might have changed.  */
    #####:12897:	      register unsigned int i, j = 0;
    #####:12898:	      for (i = 1; i < argc; ++i)
branch  0 never executed
branch  1 never executed
    #####:12899:		if (strneq (argv[i], "-f", 2)) /* XXX */
branch  0 never executed
branch  1 never executed
        -:12900:		  {
    #####:12901:		    char *p = &argv[i][2];
    #####:12902:		    if (*p == '\0')
branch  0 never executed
branch  1 never executed
    #####:12903:		      argv[++i] = makefiles->list[j];
        -:12904:		    else
    #####:12905:		      argv[i] = concat ("-f", makefiles->list[j], "");
call    0 never executed
    #####:12906:		    ++j;
        -:12907:		  }
        -:12908:	    }
        -:12909:
        -:12910:          /* Add -o option for the stdin temporary file, if necessary.  */
    #####:12911:          if (stdin_nm)
branch  0 never executed
branch  1 never executed
        -:12912:            {
    #####:12913:              nargv = (char **) xmalloc ((nargc + 2) * sizeof (char *));
call    0 never executed
    #####:12914:              bcopy ((char *) argv, (char *) nargv, argc * sizeof (char *));
    #####:12915:              nargv[nargc++] = concat ("-o", stdin_nm, "");
call    0 never executed
    #####:12916:              nargv[nargc] = 0;
        -:12917:            }
        -:12918:
    #####:12919:	  if (directories != 0 && directories->idx > 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:12920:	    {
        -:12921:	      char bad;
    #####:12922:	      if (directory_before_chdir != 0)
branch  0 never executed
branch  1 never executed
        -:12923:		{
    #####:12924:		  if (chdir (directory_before_chdir) < 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:12925:		    {
    #####:12926:		      perror_with_name ("chdir", "");
call    0 never executed
    #####:12927:		      bad = 1;
        -:12928:		    }
        -:12929:		  else
    #####:12930:		    bad = 0;
        -:12931:		}
        -:12932:	      else
    #####:12933:		bad = 1;
    #####:12934:	      if (bad)
branch  0 never executed
branch  1 never executed
    #####:12935:		fatal (NILF, _("Couldn't change back to original directory."));
call    0 never executed
        -:12936:	    }
        -:12937:
        -:12938:#ifndef _AMIGA
    #####:12939:	  for (p = environ; *p != 0; ++p)
branch  0 never executed
branch  1 never executed
    #####:12940:	    if (strneq (*p, "MAKELEVEL=", 10))
branch  0 never executed
branch  1 never executed
        -:12941:	      {
        -:12942:		/* The SGI compiler apparently can't understand
        -:12943:		   the concept of storing the result of a function
        -:12944:		   in something other than a local variable.  */
        -:12945:		char *sgi_loses;
    #####:12946:		sgi_loses = (char *) alloca (40);
    #####:12947:		*p = sgi_loses;
    #####:12948:		sprintf (*p, "MAKELEVEL=%u", makelevel);
    #####:12949:		break;
        -:12950:	      }
        -:12951:#else /* AMIGA */
        -:12952:	  {
        -:12953:	    char buffer[256];
        -:12954:	    int len;
        -:12955:
        -:12956:	    len = GetVar ("MAKELEVEL", buffer, sizeof (buffer), GVF_GLOBAL_ONLY);
        -:12957:
        -:12958:	    if (len != -1)
        -:12959:	    {
        -:12960:	    sprintf (buffer, "%u", makelevel);
        -:12961:	      SetVar ("MAKELEVEL", buffer, -1, GVF_GLOBAL_ONLY);
        -:12962:	    }
        -:12963:	  }
        -:12964:#endif
        -:12965:
    #####:12966:	  if (ISDB (DB_BASIC))
branch  0 never executed
branch  1 never executed
        -:12967:	    {
        -:12968:	      char **p;
    #####:12969:	      fputs (_("Re-executing:"), stdout);
call    0 never executed
    #####:12970:	      for (p = nargv; *p != 0; ++p)
branch  0 never executed
branch  1 never executed
    #####:12971:		printf (" %s", *p);
call    0 never executed
    #####:12972:	      putchar ('\n');
call    0 never executed
        -:12973:	    }
        -:12974:
    #####:12975:	  fflush (stdout);
call    0 never executed
    #####:12976:	  fflush (stderr);
call    0 never executed
        -:12977:
        -:12978:          /* Close the dup'd jobserver pipe if we opened one.  */
    #####:12979:          if (job_rfd >= 0)
branch  0 never executed
branch  1 never executed
    #####:12980:            close (job_rfd);
call    0 never executed
        -:12981:
        -:12982:#ifndef _AMIGA
    #####:12983:	  exec_command (nargv, environ);
call    0 never executed
        -:12984:#else
        -:12985:	  exec_command (nargv);
        -:12986:	  exit (0);
        -:12987:#endif
        -:12988:	  /* NOTREACHED */
        -:12989:	}
        -:12990:
    #####:12991:      db_level = orig_db_level;
        -:12992:    }
        -:12993:
        -:12994:  /* Set up `MAKEFLAGS' again for the normal targets.  */
    #####:12995:  define_makeflags (1, 0);
call    0 never executed
        -:12996:
        -:12997:  /* If there is a temp file from reading a makefile from stdin, get rid of
        -:12998:     it now.  */
    #####:12999:  if (stdin_nm && unlink (stdin_nm) < 0 && errno != ENOENT)
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:13000:    perror_with_name (_("unlink (temporary file): "), stdin_nm);
call    0 never executed
        -:13001:
        -:13002:  {
        -:13003:    int status;
        -:13004:
        -:13005:    /* If there were no command-line goals, use the default.  */
    #####:13006:    if (goals == 0)
branch  0 never executed
branch  1 never executed
        -:13007:      {
    #####:13008:	if (default_goal_file != 0)
branch  0 never executed
branch  1 never executed
        -:13009:	  {
    #####:13010:	    goals = (struct dep *) xmalloc (sizeof (struct dep));
call    0 never executed
    #####:13011:	    goals->next = 0;
    #####:13012:	    goals->name = 0;
    #####:13013:	    goals->file = default_goal_file;
        -:13014:	  }
        -:13015:      }
        -:13016:    else
    #####:13017:      lastgoal->next = 0;
        -:13018:
    #####:13019:    if (!goals)
branch  0 never executed
branch  1 never executed
        -:13020:      {
    #####:13021:        if (read_makefiles == 0)
branch  0 never executed
branch  1 never executed
    #####:13022:          fatal (NILF, _("No targets specified and no makefile found"));
call    0 never executed
        -:13023:
    #####:13024:        fatal (NILF, _("No targets"));
call    0 never executed
        -:13025:      }
        -:13026:
        -:13027:    /* Update the goals.  */
        -:13028:
    #####:13029:    DB (DB_BASIC, (_("Updating goal targets....\n")));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
        -:13030:
    #####:13031:    switch (update_goal_chain (goals, 0))
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -:13032:    {
    #####:13033:      case -1:
        -:13034:        /* Nothing happened.  */
        -:13035:      case 0:
        -:13036:        /* Updated successfully.  */
    #####:13037:        status = EXIT_SUCCESS;
    #####:13038:        break;
    #####:13039:      case 2:
        -:13040:        /* Updating failed.  POSIX.2 specifies exit status >1 for this;
        -:13041:           but in VMS, there is only success and failure.  */
    #####:13042:        status = EXIT_FAILURE ? 2 : EXIT_FAILURE;
    #####:13043:        break;
    #####:13044:      case 1:
        -:13045:        /* We are under -q and would run some commands.  */
    #####:13046:        status = EXIT_FAILURE;
    #####:13047:        break;
    #####:13048:      default:
    #####:13049:        abort ();
call    0 never executed
        -:13050:    }
        -:13051:
        -:13052:    /* If we detected some clock skew, generate one last warning */
    #####:13053:    if (clock_skew_detected)
branch  0 never executed
branch  1 never executed
    #####:13054:      error (NILF,
    #####:13055:             _("warning:  Clock skew detected.  Your build may be incomplete."));
call    0 never executed
        -:13056:
        -:13057:    /* Exit.  */
    #####:13058:    die (status);
        -:13059:  }
        -:13060:
        -:13061:  return 0;
        -:13062:}
        -:13063:
        -:13064:/* Parsing of arguments, decoding of switches.  */
        -:13065:
        -:13066:static char options[1 + sizeof (switches) / sizeof (switches[0]) * 3];
        -:13067:static struct option long_options[(sizeof (switches) / sizeof (switches[0])) +
        -:13068:				  (sizeof (long_option_aliases) /
        -:13069:				   sizeof (long_option_aliases[0]))];
        -:13070:
        -:13071:/* Fill in the string and vector for getopt.  */
        -:13072:static void
function init_switches called 2 returned 100% blocks executed 100%
        2:13073:init_switches ()
        -:13074:{
        -:13075:  register char *p;
        -:13076:  register int c;
        -:13077:  register unsigned int i;
        -:13078:
        2:13079:  if (options[0] != '\0')
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        -:13080:    /* Already done.  */
        1:13081:    return;
        -:13082:
        1:13083:  p = options;
        -:13084:
        -:13085:  /* Return switch and non-switch args in order, regardless of
        -:13086:     POSIXLY_CORRECT.  Non-switch args are returned as option 1.  */
        1:13087:  *p++ = '-';
        -:13088:
       29:13089:  for (i = 0; switches[i].c != '\0'; ++i)
branch  0 taken 28
branch  1 taken 1 (fallthrough)
        -:13090:    {
       28:13091:      long_options[i].name = (switches[i].long_name == 0 ? "" :
branch  0 taken 25 (fallthrough)
branch  1 taken 3
        -:13092:			      switches[i].long_name);
       28:13093:      long_options[i].flag = 0;
       28:13094:      long_options[i].val = switches[i].c;
       28:13095:      if (short_option (switches[i].c))
branch  0 taken 24 (fallthrough)
branch  1 taken 4
       24:13096:	*p++ = switches[i].c;
       28:13097:      switch (switches[i].type)
branch  0 taken 19
branch  1 taken 9
branch  2 taken 0
        -:13098:	{
       19:13099:	case flag:
        -:13100:	case flag_off:
        -:13101:	case ignore:
       19:13102:	  long_options[i].has_arg = no_argument;
       19:13103:	  break;
        -:13104:
        9:13105:	case string:
        -:13106:	case positive_int:
        -:13107:	case floating:
        9:13108:	  if (short_option (switches[i].c))
branch  0 taken 7 (fallthrough)
branch  1 taken 2
        7:13109:	    *p++ = ':';
        9:13110:	  if (switches[i].noarg_value != 0)
branch  0 taken 3 (fallthrough)
branch  1 taken 6
        -:13111:	    {
        3:13112:	      if (short_option (switches[i].c))
branch  0 taken 2 (fallthrough)
branch  1 taken 1
        2:13113:		*p++ = ':';
        3:13114:	      long_options[i].has_arg = optional_argument;
        -:13115:	    }
        -:13116:	  else
        6:13117:	    long_options[i].has_arg = required_argument;
        9:13118:	  break;
        -:13119:	}
        -:13120:    }
        1:13121:  *p = '\0';
       10:13122:  for (c = 0; c < (sizeof (long_option_aliases) /
branch  0 taken 9
branch  1 taken 1 (fallthrough)
        -:13123:		   sizeof (long_option_aliases[0]));
        9:13124:       ++c)
        9:13125:    long_options[i++] = long_option_aliases[c];
        1:13126:  long_options[i].name = 0;
        -:13127:}
        -:13128:
        -:13129:static void
function handle_non_switch_argument called 0 returned 0% blocks executed 0%
    #####:13130:handle_non_switch_argument (arg, env)
        -:13131:     char *arg;
        -:13132:     int env;
        -:13133:{
        -:13134:  /* Non-option argument.  It might be a variable definition.  */
        -:13135:  struct variable *v;
    #####:13136:  if (arg[0] == '-' && arg[1] == '\0')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:13137:    /* Ignore plain `-' for compatibility.  */
    #####:13138:    return;
    #####:13139:  v = try_variable_definition (0, arg, o_command, 0);
call    0 never executed
    #####:13140:  if (v != 0)
branch  0 never executed
branch  1 never executed
        -:13141:    {
        -:13142:      /* It is indeed a variable definition.  Record a pointer to
        -:13143:	 the variable for later use in define_makeflags.  */
        -:13144:      struct command_variable *cv
    #####:13145:	= (struct command_variable *) xmalloc (sizeof (*cv));
call    0 never executed
    #####:13146:      cv->variable = v;
    #####:13147:      cv->next = command_variables;
    #####:13148:      command_variables = cv;
        -:13149:    }
    #####:13150:  else if (! env)
branch  0 never executed
branch  1 never executed
        -:13151:    {
        -:13152:      /* Not an option or variable definition; it must be a goal
        -:13153:	 target!  Enter it as a file and add it to the dep chain of
        -:13154:	 goals.  */
    #####:13155:      struct file *f = enter_command_line_file (arg);
call    0 never executed
    #####:13156:      f->cmd_target = 1;
        -:13157:
    #####:13158:      if (goals == 0)
branch  0 never executed
branch  1 never executed
        -:13159:	{
    #####:13160:	  goals = (struct dep *) xmalloc (sizeof (struct dep));
call    0 never executed
    #####:13161:	  lastgoal = goals;
        -:13162:	}
        -:13163:      else
        -:13164:	{
    #####:13165:	  lastgoal->next = (struct dep *) xmalloc (sizeof (struct dep));
call    0 never executed
    #####:13166:	  lastgoal = lastgoal->next;
        -:13167:	}
    #####:13168:      lastgoal->name = 0;
    #####:13169:      lastgoal->file = f;
        -:13170:
        -:13171:      {
        -:13172:        /* Add this target name to the MAKECMDGOALS variable. */
        -:13173:        struct variable *v;
        -:13174:        char *value;
        -:13175:
    #####:13176:        v = lookup_variable ("MAKECMDGOALS", 12);
call    0 never executed
    #####:13177:        if (v == 0)
branch  0 never executed
branch  1 never executed
    #####:13178:          value = f->name;
        -:13179:        else
        -:13180:          {
        -:13181:            /* Paste the old and new values together */
        -:13182:            unsigned int oldlen, newlen;
        -:13183:
    #####:13184:            oldlen = strlen (v->value);
    #####:13185:            newlen = strlen (f->name);
    #####:13186:            value = (char *) alloca (oldlen + 1 + newlen + 1);
    #####:13187:            bcopy (v->value, value, oldlen);
    #####:13188:            value[oldlen] = ' ';
    #####:13189:            bcopy (f->name, &value[oldlen + 1], newlen + 1);
        -:13190:          }
    #####:13191:        define_variable ("MAKECMDGOALS", 12, value, o_default, 0);
call    0 never executed
        -:13192:      }
        -:13193:    }
        -:13194:}
        -:13195:
        -:13196:/* Print a nice usage method.  */
        -:13197:
        -:13198:static void
function print_usage called 0 returned 0% blocks executed 0%
    #####:13199:print_usage (bad)
        -:13200:     int bad;
        -:13201:{
        -:13202:  register const struct command_switch *cs;
        -:13203:  FILE *usageto;
        -:13204:
    #####:13205:  if (print_version_flag)
branch  0 never executed
branch  1 never executed
    #####:13206:    print_version ();
call    0 never executed
        -:13207:
    #####:13208:  usageto = bad ? stderr : stdout;
        -:13209:
    #####:13210:  fprintf (usageto, _("Usage: %s [options] [target] ...\n"), program);
call    0 never executed
        -:13211:
    #####:13212:  fputs (_("Options:\n"), usageto);
call    0 never executed
    #####:13213:  for (cs = switches; cs->c != '\0'; ++cs)
branch  0 never executed
branch  1 never executed
        -:13214:    {
        -:13215:      char buf[1024], shortarg[50], longarg[50], *p;
        -:13216:
    #####:13217:      if (!cs->description || cs->description[0] == '-')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:13218:	continue;
        -:13219:
    #####:13220:      switch (long_options[cs - switches].has_arg)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:13221:	{
    #####:13222:	case no_argument:
    #####:13223:	  shortarg[0] = longarg[0] = '\0';
    #####:13224:	  break;
    #####:13225:	case required_argument:
    #####:13226:	  sprintf (longarg, "=%s", gettext (cs->argdesc));
    #####:13227:	  sprintf (shortarg, " %s", gettext (cs->argdesc));
    #####:13228:	  break;
    #####:13229:	case optional_argument:
    #####:13230:	  sprintf (longarg, "[=%s]", gettext (cs->argdesc));
    #####:13231:	  sprintf (shortarg, " [%s]", gettext (cs->argdesc));
    #####:13232:	  break;
        -:13233:	}
        -:13234:
    #####:13235:      p = buf;
        -:13236:
    #####:13237:      if (short_option (cs->c))
branch  0 never executed
branch  1 never executed
        -:13238:	{
    #####:13239:	  sprintf (buf, "  -%c%s", cs->c, shortarg);
    #####:13240:	  p += strlen (p);
        -:13241:	}
    #####:13242:      if (cs->long_name != 0)
branch  0 never executed
branch  1 never executed
        -:13243:	{
        -:13244:	  unsigned int i;
    #####:13245:	  sprintf (p, "%s--%s%s",
    #####:13246:		   !short_option (cs->c) ? "  " : ", ",
    #####:13247:		   cs->long_name, longarg);
branch  0 never executed
branch  1 never executed
    #####:13248:	  p += strlen (p);
    #####:13249:	  for (i = 0; i < (sizeof (long_option_aliases) /
branch  0 never executed
branch  1 never executed
        -:13250:			   sizeof (long_option_aliases[0]));
    #####:13251:	       ++i)
    #####:13252:	    if (long_option_aliases[i].val == cs->c)
branch  0 never executed
branch  1 never executed
        -:13253:	      {
    #####:13254:		sprintf (p, ", --%s%s",
        -:13255:			 long_option_aliases[i].name, longarg);
    #####:13256:		p += strlen (p);
        -:13257:	      }
        -:13258:	}
        -:13259:      {
    #####:13260:	const struct command_switch *ncs = cs;
    #####:13261:	while ((++ncs)->c != '\0')
branch  0 never executed
branch  1 never executed
    #####:13262:	  if (ncs->description
branch  0 never executed
branch  1 never executed
    #####:13263:              && ncs->description[0] == '-'
branch  0 never executed
branch  1 never executed
    #####:13264:              && ncs->description[1] == cs->c)
branch  0 never executed
branch  1 never executed
        -:13265:	    {
        -:13266:	      /* This is another switch that does the same
        -:13267:		 one as the one we are processing.  We want
        -:13268:		 to list them all together on one line.  */
    #####:13269:	      sprintf (p, ", -%c%s", ncs->c, shortarg);
    #####:13270:	      p += strlen (p);
    #####:13271:	      if (ncs->long_name != 0)
branch  0 never executed
branch  1 never executed
        -:13272:		{
    #####:13273:		  sprintf (p, ", --%s%s", ncs->long_name, longarg);
    #####:13274:		  p += strlen (p);
        -:13275:		}
        -:13276:	    }
        -:13277:      }
        -:13278:
    #####:13279:      if (p - buf > DESCRIPTION_COLUMN - 2)
branch  0 never executed
branch  1 never executed
        -:13280:	/* The list of option names is too long to fit on the same
        -:13281:	   line with the description, leaving at least two spaces.
        -:13282:	   Print it on its own line instead.  */
        -:13283:	{
    #####:13284:	  fprintf (usageto, "%s\n", buf);
call    0 never executed
    #####:13285:	  buf[0] = '\0';
        -:13286:	}
        -:13287:
    #####:13288:      fprintf (usageto, "%*s%s.\n",
        -:13289:	       - DESCRIPTION_COLUMN,
    #####:13290:	       buf, gettext (cs->description));
call    0 never executed
        -:13291:    }
        -:13292:
    #####:13293:  fprintf (usageto, _("\nReport bugs to <bug-make@gnu.org>.\n"));
call    0 never executed
    #####:13294:}
        -:13295:
        -:13296:/* Decode switches from ARGC and ARGV.
        -:13297:   They came from the environment if ENV is nonzero.  */
        -:13298:
        -:13299:static void
function decode_switches called 2 returned 100% blocks executed 43%
        2:13300:decode_switches (argc, argv, env)
        -:13301:     int argc;
        -:13302:     char **argv;
        -:13303:     int env;
        -:13304:{
        2:13305:  int bad = 0;
        -:13306:  register const struct command_switch *cs;
        -:13307:  register struct stringlist *sl;
        -:13308:  register int c;
        -:13309:
        -:13310:  /* getopt does most of the parsing for us.
        -:13311:     First, get its vectors set up.  */
        -:13312:
        2:13313:  init_switches ();
call    0 returned 2
        -:13314:
        -:13315:  /* Let getopt produce error messages for the command line,
        -:13316:     but not for options from the environment.  */
        2:13317:  opterr = !env;
        -:13318:  /* Reset getopt's state.  */
        2:13319:  optind = 0;
        -:13320:
       17:13321:  while (optind < argc)
branch  0 taken 15
branch  1 taken 2 (fallthrough)
        -:13322:    {
        -:13323:      /* Parse the next argument.  */
       15:13324:      c = getopt_long (argc, argv, options, long_options, (int *) 0);
call    0 returned 15
       15:13325:      if (c == EOF)
branch  0 taken 0 (fallthrough)
branch  1 taken 15
        -:13326:	/* End of arguments, or "--" marker seen.  */
    #####:13327:	break;
       15:13328:      else if (c == 1)
branch  0 taken 0 (fallthrough)
branch  1 taken 15
        -:13329:	/* An argument not starting with a dash.  */
    #####:13330:	handle_non_switch_argument (optarg, env);
call    0 never executed
       15:13331:      else if (c == '?')
branch  0 taken 0 (fallthrough)
branch  1 taken 15
        -:13332:	/* Bad option.  We will print a usage message and die later.
        -:13333:	   But continue to parse the other options so the user can
        -:13334:	   see all he did wrong.  */
    #####:13335:	bad = 1;
        -:13336:      else
      194:13337:	for (cs = switches; cs->c != '\0'; ++cs)
branch  0 taken 194
branch  1 taken 0 (fallthrough)
      194:13338:	  if (cs->c == c)
branch  0 taken 15 (fallthrough)
branch  1 taken 179
        -:13339:	    {
        -:13340:	      /* Whether or not we will actually do anything with
        -:13341:		 this switch.  We test this individually inside the
        -:13342:		 switch below rather than just once outside it, so that
        -:13343:		 options which are to be ignored still consume args.  */
      15*:13344:	      int doit = !env || cs->env;
branch  0 taken 7 (fallthrough)
branch  1 taken 8
branch  2 taken 7 (fallthrough)
branch  3 taken 0
        -:13345:
       15:13346:	      switch (cs->type)
branch  0 taken 0
branch  1 taken 0
branch  2 taken 14
branch  3 taken 1
branch  4 taken 0
branch  5 taken 0
        -:13347:		{
    #####:13348:		default:
    #####:13349:		  abort ();
call    0 never executed
        -:13350:
    #####:13351:		case ignore:
    #####:13352:		  break;
        -:13353:
       14:13354:		case flag:
        -:13355:		case flag_off:
       14:13356:		  if (doit)
branch  0 taken 14 (fallthrough)
branch  1 taken 0
       14:13357:		    *(int *) cs->value_ptr = cs->type == flag;
       14:13358:		  break;
        -:13359:
        1:13360:		case string:
        1:13361:		  if (!doit)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:13362:		    break;
        -:13363:
        1:13364:		  if (optarg == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:13365:		    optarg = cs->noarg_value;
        -:13366:
        1:13367:		  sl = *(struct stringlist **) cs->value_ptr;
        1:13368:		  if (sl == 0)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -:13369:		    {
        -:13370:		      sl = (struct stringlist *)
        1:13371:			xmalloc (sizeof (struct stringlist));
call    0 returned 1
        1:13372:		      sl->max = 5;
        1:13373:		      sl->idx = 0;
        1:13374:		      sl->list = (char **) xmalloc (5 * sizeof (char *));
call    0 returned 1
        1:13375:		      *(struct stringlist **) cs->value_ptr = sl;
        -:13376:		    }
    #####:13377:		  else if (sl->idx == sl->max - 1)
branch  0 never executed
branch  1 never executed
        -:13378:		    {
    #####:13379:		      sl->max += 5;
    #####:13380:		      sl->list = (char **)
    #####:13381:			xrealloc ((char *) sl->list,
    #####:13382:				  sl->max * sizeof (char *));
call    0 never executed
        -:13383:		    }
        1:13384:		  sl->list[sl->idx++] = optarg;
        1:13385:		  sl->list[sl->idx] = 0;
        1:13386:		  break;
        -:13387:
    #####:13388:		case positive_int:
    #####:13389:		  if (optarg == 0 && argc > optind
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:13390:                      && ISDIGIT (argv[optind][0]))
branch  0 never executed
branch  1 never executed
    #####:13391:		    optarg = argv[optind++];
        -:13392:
    #####:13393:		  if (!doit)
branch  0 never executed
branch  1 never executed
    #####:13394:		    break;
        -:13395:
    #####:13396:		  if (optarg != 0)
branch  0 never executed
branch  1 never executed
        -:13397:		    {
    #####:13398:		      int i = atoi (optarg);
    #####:13399:		      if (i < 1)
branch  0 never executed
branch  1 never executed
        -:13400:			{
    #####:13401:			  if (doit)
branch  0 never executed
branch  1 never executed
    #####:13402:			    error (NILF, _("the `-%c' option requires a positive integral argument"),
    #####:13403:				   cs->c);
call    0 never executed
    #####:13404:			  bad = 1;
        -:13405:			}
        -:13406:		      else
    #####:13407:			*(unsigned int *) cs->value_ptr = i;
        -:13408:		    }
        -:13409:		  else
    #####:13410:		    *(unsigned int *) cs->value_ptr
    #####:13411:		      = *(unsigned int *) cs->noarg_value;
    #####:13412:		  break;
        -:13413:
        -:13414:#ifndef NO_FLOAT
    #####:13415:		case floating:
    #####:13416:		  if (optarg == 0 && optind < argc
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:13417:		      && (ISDIGIT (argv[optind][0]) || argv[optind][0] == '.'))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:13418:		    optarg = argv[optind++];
        -:13419:
    #####:13420:		  if (doit)
branch  0 never executed
branch  1 never executed
    #####:13421:		    *(double *) cs->value_ptr
    #####:13422:		      = (optarg != 0 ? atof (optarg)
    #####:13423:			 : *(double *) cs->noarg_value);
branch  0 never executed
branch  1 never executed
        -:13424:
    #####:13425:		  break;
        -:13426:#endif
        -:13427:		}
        -:13428:
        -:13429:	      /* We've found the switch.  Stop looking.  */
       15:13430:	      break;
        -:13431:	    }
        -:13432:    }
        -:13433:
        -:13434:  /* There are no more options according to getting getopt, but there may
        -:13435:     be some arguments left.  Since we have asked for non-option arguments
        -:13436:     to be returned in order, this only happens when there is a "--"
        -:13437:     argument to prevent later arguments from being options.  */
        2:13438:  while (optind < argc)
branch  0 taken 0
branch  1 taken 2 (fallthrough)
    #####:13439:    handle_non_switch_argument (argv[optind++], env);
call    0 never executed
        -:13440:
        -:13441:
        2:13442:  if (!env && (bad || print_usage_flag))
branch  0 taken 1 (fallthrough)
branch  1 taken 1
branch  2 taken 1 (fallthrough)
branch  3 taken 0
branch  4 taken 0 (fallthrough)
branch  5 taken 1
        -:13443:    {
    #####:13444:      print_usage (bad);
call    0 never executed
    #####:13445:      die (bad ? 2 : 0);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:13446:    }
        2:13447:}
        -:13448:
        -:13449:/* Decode switches from environment variable ENVAR (which is LEN chars long).
        -:13450:   We do this by chopping the value into a vector of words, prepending a
        -:13451:   dash to the first word if it lacks one, and passing the vector to
        -:13452:   decode_switches.  */
        -:13453:
        -:13454:static void
function decode_env_switches called 2 returned 100% blocks executed 76%
        2:13455:decode_env_switches (envar, len)
        -:13456:     char *envar;
        -:13457:     unsigned int len;
        -:13458:{
        2:13459:  char *varref = (char *) alloca (2 + len + 2);
        -:13460:  char *value, *p;
        -:13461:  int argc;
        -:13462:  char **argv;
        -:13463:
        -:13464:  /* Get the variable's value.  */
        2:13465:  varref[0] = '$';
        2:13466:  varref[1] = '(';
        2:13467:  bcopy (envar, &varref[2], len);
        2:13468:  varref[2 + len] = ')';
        2:13469:  varref[2 + len + 1] = '\0';
        2:13470:  value = variable_expand (varref);
call    0 returned 2
        -:13471:
        -:13472:  /* Skip whitespace, and check for an empty value.  */
        2:13473:  value = next_token (value);
call    0 returned 2
        2:13474:  len = strlen (value);
        2:13475:  if (len == 0)
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        1:13476:    return;
        -:13477:
        -:13478:  /* Allocate a vector that is definitely big enough.  */
        1:13479:  argv = (char **) alloca ((1 + len + 1) * sizeof (char *));
        -:13480:
        -:13481:  /* Allocate a buffer to copy the value into while we split it into words
        -:13482:     and unquote it.  We must use permanent storage for this because
        -:13483:     decode_switches may store pointers into the passed argument words.  */
        1:13484:  p = (char *) xmalloc (2 * len);
call    0 returned 1
        -:13485:
        -:13486:  /* getopt will look at the arguments starting at ARGV[1].
        -:13487:     Prepend a spacer word.  */
        1:13488:  argv[0] = 0;
        1:13489:  argc = 1;
        1:13490:  argv[argc] = p;
        8:13491:  while (*value != '\0')
branch  0 taken 7
branch  1 taken 1 (fallthrough)
        -:13492:    {
       7*:13493:      if (*value == '\\' && value[1] != '\0')
branch  0 taken 0 (fallthrough)
branch  1 taken 7
branch  2 never executed
branch  3 never executed
    #####:13494:	++value;		/* Skip the backslash.  */
       7*:13495:      else if (isblank (*value))
branch  0 taken 0 (fallthrough)
branch  1 taken 7
        -:13496:	{
        -:13497:	  /* End of the word.  */
    #####:13498:	  *p++ = '\0';
    #####:13499:	  argv[++argc] = p;
        -:13500:	  do
    #####:13501:	    ++value;
    #####:13502:	  while (isblank (*value));
branch  0 never executed
branch  1 never executed
    #####:13503:	  continue;
        -:13504:	}
        7:13505:      *p++ = *value++;
        -:13506:    }
        1:13507:  *p = '\0';
        1:13508:  argv[++argc] = 0;
        -:13509:
        1:13510:  if (argv[1][0] != '-' && strchr (argv[1], '=') == 0)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
branch  2 taken 1 (fallthrough)
branch  3 taken 0
        -:13511:    /* The first word doesn't start with a dash and isn't a variable
        -:13512:       definition.  Add a dash and pass it along to decode_switches.  We
        -:13513:       need permanent storage for this in case decode_switches saves
        -:13514:       pointers into the value.  */
        1:13515:    argv[1] = concat ("-", argv[1], "");
call    0 returned 1
        -:13516:
        -:13517:  /* Parse those words.  */
        1:13518:  decode_switches (argc, argv, 1);
call    0 returned 1
        -:13519:}
        -:13520:
        -:13521:/* Quote the string IN so that it will be interpreted as a single word with
        -:13522:   no magic by decode_env_switches; also double dollar signs to avoid
        -:13523:   variable expansion in make itself.  Write the result into OUT, returning
        -:13524:   the address of the next character to be written.
        -:13525:   Allocating space for OUT twice the length of IN is always sufficient.  */
        -:13526:
        -:13527:static char *
function quote_for_env called 0 returned 0% blocks executed 0%
    #####:13528:quote_for_env (out, in)
        -:13529:     char *out, *in;
        -:13530:{
    #####:13531:  while (*in != '\0')
branch  0 never executed
branch  1 never executed
        -:13532:    {
    #####:13533:      if (*in == '$')
branch  0 never executed
branch  1 never executed
    #####:13534:	*out++ = '$';
    #####:13535:      else if (isblank (*in) || *in == '\\')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:13536:        *out++ = '\\';
    #####:13537:      *out++ = *in++;
        -:13538:    }
        -:13539:
    #####:13540:  return out;
        -:13541:}
        -:13542:
        -:13543:/* Define the MAKEFLAGS and MFLAGS variables to reflect the settings of the
        -:13544:   command switches.  Include options with args if ALL is nonzero.
        -:13545:   Don't include options with the `no_makefile' flag set if MAKEFILE.  */
        -:13546:
        -:13547:static void
function define_makeflags called 3 returned 100% blocks executed 41%
        3:13548:define_makeflags (all, makefile)
        -:13549:     int all, makefile;
        -:13550:{
        -:13551:  static const char ref[] = "$(MAKEOVERRIDES)";
        -:13552:  static const char posixref[] = "$(-*-command-variables-*-)";
        -:13553:  register const struct command_switch *cs;
        -:13554:  char *flagstring;
        -:13555:  register char *p;
        -:13556:  unsigned int words;
        -:13557:  struct variable *v;
        -:13558:
        -:13559:  /* We will construct a linked list of `struct flag's describing
        -:13560:     all the flags which need to go in MAKEFLAGS.  Then, once we
        -:13561:     know how many there are and their lengths, we can put them all
        -:13562:     together in a string.  */
        -:13563:
        -:13564:  struct flag
        -:13565:    {
        -:13566:      struct flag *next;
        -:13567:      const struct command_switch *cs;
        -:13568:      char *arg;
        -:13569:    };
        3:13570:  struct flag *flags = 0;
        3:13571:  unsigned int flagslen = 0;
        -:13572:#define	ADD_FLAG(ARG, LEN) \
        -:13573:  do {									      \
        -:13574:    struct flag *new = (struct flag *) alloca (sizeof (struct flag));	      \
        -:13575:    new->cs = cs;							      \
        -:13576:    new->arg = (ARG);							      \
        -:13577:    new->next = flags;							      \
        -:13578:    flags = new;							      \
        -:13579:    if (new->arg == 0)							      \
        -:13580:      ++flagslen;		/* Just a single flag letter.  */	      \
        -:13581:    else								      \
        -:13582:      flagslen += 1 + 1 + 1 + 1 + 3 * (LEN); /* " -x foo" */		      \
        -:13583:    if (!short_option (cs->c))						      \
        -:13584:      /* This switch has no single-letter version, so we use the long.  */    \
        -:13585:      flagslen += 2 + strlen (cs->long_name);				      \
        -:13586:  } while (0)
        -:13587:
       87:13588:  for (cs = switches; cs->c != '\0'; ++cs)
branch  0 taken 84
branch  1 taken 3 (fallthrough)
       84:13589:    if (cs->toenv && (!makefile || !cs->no_makefile))
branch  0 taken 63 (fallthrough)
branch  1 taken 21
branch  2 taken 21 (fallthrough)
branch  3 taken 42
branch  4 taken 18 (fallthrough)
branch  5 taken 3
       60:13590:      switch (cs->type)
branch  0 taken 0
branch  1 taken 0
branch  2 taken 45
branch  3 taken 3
branch  4 taken 3
branch  5 taken 9
        -:13591:	{
    #####:13592:	default:
    #####:13593:	  abort ();
call    0 never executed
        -:13594:
    #####:13595:	case ignore:
    #####:13596:	  break;
        -:13597:
       45:13598:	case flag:
        -:13599:	case flag_off:
       45:13600:	  if (!*(int *) cs->value_ptr == (cs->type == flag_off)
branch  0 taken 23 (fallthrough)
branch  1 taken 22
       23:13601:	      && (cs->default_value == 0
branch  0 taken 3 (fallthrough)
branch  1 taken 20
        3:13602:		  || *(int *) cs->value_ptr != *(int *) cs->default_value))
branch  0 taken 0 (fallthrough)
branch  1 taken 3
      20*:13603:	    ADD_FLAG (0, 0);
branch  0 taken 20 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 20
       45:13604:	  break;
        -:13605:
        3:13606:	case positive_int:
        3:13607:	  if (all)
branch  0 taken 2 (fallthrough)
branch  1 taken 1
        -:13608:	    {
        2:13609:	      if ((cs->default_value != 0
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2:13610:		   && (*(unsigned int *) cs->value_ptr
        2:13611:		       == *(unsigned int *) cs->default_value)))
branch  0 taken 0 (fallthrough)
branch  1 taken 2
        -:13612:		break;
    #####:13613:	      else if (cs->noarg_value != 0
branch  0 never executed
branch  1 never executed
    #####:13614:		       && (*(unsigned int *) cs->value_ptr ==
    #####:13615:			   *(unsigned int *) cs->noarg_value))
branch  0 never executed
branch  1 never executed
    #####:13616:		ADD_FLAG ("", 0); /* Optional value omitted; see below.  */
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:13617:	      else if (cs->c == 'j')
branch  0 never executed
branch  1 never executed
        -:13618:		/* Special case for `-j'.  */
    #####:13619:		ADD_FLAG ("1", 1);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:13620:	      else
        -:13621:		{
    #####:13622:		  char *buf = (char *) alloca (30);
    #####:13623:		  sprintf (buf, "%u", *(unsigned int *) cs->value_ptr);
    #####:13624:		  ADD_FLAG (buf, strlen (buf));
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:13625:		}
        -:13626:	    }
        1:13627:	  break;
        -:13628:
        -:13629:#ifndef NO_FLOAT
        3:13630:	case floating:
        3:13631:	  if (all)
branch  0 taken 2 (fallthrough)
branch  1 taken 1
        -:13632:	    {
        2:13633:	      if (cs->default_value != 0
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2:13634:		  && (*(double *) cs->value_ptr
        2:13635:		      == *(double *) cs->default_value))
branch  0 taken 0 (fallthrough)
branch  1 taken 2
        -:13636:		break;
    #####:13637:	      else if (cs->noarg_value != 0
branch  0 never executed
branch  1 never executed
    #####:13638:		       && (*(double *) cs->value_ptr
    #####:13639:			   == *(double *) cs->noarg_value))
branch  0 never executed
branch  1 never executed
    #####:13640:		ADD_FLAG ("", 0); /* Optional value omitted; see below.  */
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:13641:	      else
        -:13642:		{
    #####:13643:		  char *buf = (char *) alloca (100);
    #####:13644:		  sprintf (buf, "%g", *(double *) cs->value_ptr);
    #####:13645:		  ADD_FLAG (buf, strlen (buf));
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:13646:		}
        -:13647:	    }
        1:13648:	  break;
        -:13649:#endif
        -:13650:
        9:13651:	case string:
        9:13652:	  if (all)
branch  0 taken 6 (fallthrough)
branch  1 taken 3
        -:13653:	    {
        6:13654:	      struct stringlist *sl = *(struct stringlist **) cs->value_ptr;
        6:13655:	      if (sl != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 6
        -:13656:		{
        -:13657:		  /* Add the elements in reverse order, because
        -:13658:		     all the flags get reversed below; and the order
        -:13659:		     matters for some switches (like -I).  */
    #####:13660:		  register unsigned int i = sl->idx;
    #####:13661:		  while (i-- > 0)
branch  0 never executed
branch  1 never executed
    #####:13662:		    ADD_FLAG (sl->list[i], strlen (sl->list[i]));
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:13663:		}
        -:13664:	    }
        9:13665:	  break;
        -:13666:	}
        -:13667:
        3:13668:  flagslen += 4 + sizeof posixref; /* Four more for the possible " -- ".  */
        -:13669:
        -:13670:#undef	ADD_FLAG
        -:13671:
        -:13672:  /* Construct the value in FLAGSTRING.
        -:13673:     We allocate enough space for a preceding dash and trailing null.  */
        3:13674:  flagstring = (char *) alloca (1 + flagslen + 1);
        3:13675:  bzero (flagstring, 1 + flagslen + 1);
        3:13676:  p = flagstring;
        3:13677:  words = 1;
        3:13678:  *p++ = '-';
       23:13679:  while (flags != 0)
branch  0 taken 20
branch  1 taken 3 (fallthrough)
        -:13680:    {
        -:13681:      /* Add the flag letter or name to the string.  */
       20:13682:      if (short_option (flags->cs->c))
branch  0 taken 20 (fallthrough)
branch  1 taken 0
       20:13683:	*p++ = flags->cs->c;
        -:13684:      else
        -:13685:	{
    #####:13686:          if (*p != '-')
branch  0 never executed
branch  1 never executed
        -:13687:            {
    #####:13688:              *p++ = ' ';
    #####:13689:              *p++ = '-';
        -:13690:            }
    #####:13691:	  *p++ = '-';
    #####:13692:	  strcpy (p, flags->cs->long_name);
    #####:13693:	  p += strlen (p);
        -:13694:	}
       20:13695:      if (flags->arg != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 20
        -:13696:	{
        -:13697:	  /* A flag that takes an optional argument which in this case is
        -:13698:	     omitted is specified by ARG being "".  We must distinguish
        -:13699:	     because a following flag appended without an intervening " -"
        -:13700:	     is considered the arg for the first.  */
    #####:13701:	  if (flags->arg[0] != '\0')
branch  0 never executed
branch  1 never executed
        -:13702:	    {
        -:13703:	      /* Add its argument too.  */
    #####:13704:	      *p++ = !short_option (flags->cs->c) ? '=' : ' ';
branch  0 never executed
branch  1 never executed
    #####:13705:	      p = quote_for_env (p, flags->arg);
call    0 never executed
        -:13706:	    }
    #####:13707:	  ++words;
        -:13708:	  /* Write a following space and dash, for the next flag.  */
    #####:13709:	  *p++ = ' ';
    #####:13710:	  *p++ = '-';
        -:13711:	}
       20:13712:      else if (!short_option (flags->cs->c))
branch  0 taken 0 (fallthrough)
branch  1 taken 20
        -:13713:	{
    #####:13714:	  ++words;
        -:13715:	  /* Long options must each go in their own word,
        -:13716:	     so we write the following space and dash.  */
    #####:13717:	  *p++ = ' ';
    #####:13718:	  *p++ = '-';
        -:13719:	}
       20:13720:      flags = flags->next;
        -:13721:    }
        -:13722:
        -:13723:  /* Define MFLAGS before appending variable definitions.  */
        -:13724:
        3:13725:  if (p == &flagstring[1])
branch  0 taken 0 (fallthrough)
branch  1 taken 3
        -:13726:    /* No flags.  */
    #####:13727:    flagstring[0] = '\0';
        3:13728:  else if (p[-1] == '-')
branch  0 taken 0 (fallthrough)
branch  1 taken 3
        -:13729:    {
        -:13730:      /* Kill the final space and dash.  */
    #####:13731:      p -= 2;
    #####:13732:      *p = '\0';
        -:13733:    }
        -:13734:  else
        -:13735:    /* Terminate the string.  */
        3:13736:    *p = '\0';
        -:13737:
        -:13738:  /* Since MFLAGS is not parsed for flags, there is no reason to
        -:13739:     override any makefile redefinition.  */
        3:13740:  (void) define_variable ("MFLAGS", 6, flagstring, o_env, 1);
call    0 returned 3
        -:13741:
        3:13742:  if (all && command_variables != 0)
branch  0 taken 2 (fallthrough)
branch  1 taken 1
branch  2 taken 0 (fallthrough)
branch  3 taken 2
        -:13743:    {
        -:13744:      /* Now write a reference to $(MAKEOVERRIDES), which contains all the
        -:13745:	 command-line variable definitions.  */
        -:13746:
    #####:13747:      if (p == &flagstring[1])
branch  0 never executed
branch  1 never executed
        -:13748:	/* No flags written, so elide the leading dash already written.  */
    #####:13749:	p = flagstring;
        -:13750:      else
        -:13751:	{
        -:13752:	  /* Separate the variables from the switches with a "--" arg.  */
    #####:13753:	  if (p[-1] != '-')
branch  0 never executed
branch  1 never executed
        -:13754:	    {
        -:13755:	      /* We did not already write a trailing " -".  */
    #####:13756:	      *p++ = ' ';
    #####:13757:	      *p++ = '-';
        -:13758:	    }
        -:13759:	  /* There is a trailing " -"; fill it out to " -- ".  */
    #####:13760:	  *p++ = '-';
    #####:13761:	  *p++ = ' ';
        -:13762:	}
        -:13763:
        -:13764:      /* Copy in the string.  */
    #####:13765:      if (posix_pedantic)
branch  0 never executed
branch  1 never executed
        -:13766:	{
    #####:13767:	  bcopy (posixref, p, sizeof posixref - 1);
    #####:13768:	  p += sizeof posixref - 1;
        -:13769:	}
        -:13770:      else
        -:13771:	{
    #####:13772:	  bcopy (ref, p, sizeof ref - 1);
    #####:13773:	  p += sizeof ref - 1;
        -:13774:	}
        -:13775:    }
        3:13776:  else if (p == &flagstring[1])
branch  0 taken 0 (fallthrough)
branch  1 taken 3
        -:13777:    {
    #####:13778:      words = 0;
    #####:13779:      --p;
        -:13780:    }
        3:13781:  else if (p[-1] == '-')
branch  0 taken 0 (fallthrough)
branch  1 taken 3
        -:13782:    /* Kill the final space and dash.  */
    #####:13783:    p -= 2;
        -:13784:  /* Terminate the string.  */
        3:13785:  *p = '\0';
        -:13786:
       3*:13787:  v = define_variable ("MAKEFLAGS", 9,
branch  0 taken 3 (fallthrough)
branch  1 taken 0
branch  2 taken 3 (fallthrough)
branch  3 taken 0
call    4 returned 3
        -:13788:		       /* If there are switches, omit the leading dash
        -:13789:			  unless it is a single long option with two
        -:13790:			  leading dashes.  */
        -:13791:		       &flagstring[(flagstring[0] == '-'
        -:13792:				    && flagstring[1] != '-')
        -:13793:				   ? 1 : 0],
        -:13794:		       /* This used to use o_env, but that lost when a
        -:13795:			  makefile defined MAKEFLAGS.  Makefiles set
        -:13796:			  MAKEFLAGS to add switches, but we still want
        -:13797:			  to redefine its value with the full set of
        -:13798:			  switches.  Of course, an override or command
        -:13799:			  definition will still take precedence.  */
        -:13800:		       o_file, 1);
        3:13801:  if (! all)
branch  0 taken 1 (fallthrough)
branch  1 taken 2
        -:13802:    /* The first time we are called, set MAKEFLAGS to always be exported.
        -:13803:       We should not do this again on the second call, because that is
        -:13804:       after reading makefiles which might have done `unexport MAKEFLAGS'. */
        1:13805:    v->export = v_export;
        3:13806:}
        -:13807:
        -:13808:/* Print version information.  */
        -:13809:
        -:13810:static void
function print_version called 1 returned 100% blocks executed 67%
        1:13811:print_version ()
        -:13812:{
        -:13813:  extern char *make_host;
        -:13814:  static int printed_version = 0;
        -:13815:
       1*:13816:  char *precede = print_data_base_flag ? "# " : "";
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -:13817:
        1:13818:  if (printed_version)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -:13819:    /* Do it only once.  */
    #####:13820:    return;
        -:13821:
        1:13822:  printf ("%sGNU Make version %s", precede, version_string);
call    0 returned 1
       1*:13823:  if (remote_description != 0 && *remote_description != '\0')
branch  0 taken 0 (fallthrough)
branch  1 taken 1
branch  2 never executed
branch  3 never executed
    #####:13824:    printf ("-%s", remote_description);
call    0 never executed
        -:13825:
        1:13826:  printf (_(", by Richard Stallman and Roland McGrath.\n\
call    0 returned 1
        -:13827:%sBuilt for %s\n\
        -:13828:%sCopyright (C) 1988, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99\n\
        -:13829:%s\tFree Software Foundation, Inc.\n\
        -:13830:%sThis is free software; see the source for copying conditions.\n\
        -:13831:%sThere is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A\n\
        -:13832:%sPARTICULAR PURPOSE.\n\n\
        -:13833:%sReport bugs to <bug-make@gnu.org>.\n\n"),
        -:13834:          precede, make_host,
        -:13835:	  precede, precede, precede, precede, precede, precede);
        -:13836:
        1:13837:  printed_version = 1;
        -:13838:
        -:13839:  /* Flush stdout so the user doesn't have to wait to see the
        -:13840:     version information while things are thought about.  */
        1:13841:  fflush (stdout);
call    0 returned 1
        -:13842:}
        -:13843:
        -:13844:/* Print a bunch of information about this and that.  */
        -:13845:
        -:13846:static void
function print_data_base called 1 returned 100% blocks executed 100%
        1:13847:print_data_base ()
        -:13848:{
        -:13849:  time_t when;
        -:13850:
        1:13851:  when = time ((time_t *) 0);
call    0 returned 1
        1:13852:  printf ("\n# Make data base, printed on 00:00 Jan 01 2000");
call    0 returned 1
        -:13853:  /* printf (_("\n# Make data base, printed on %s"), ctime (&when)); */
        -:13854:
        1:13855:  print_variable_data_base ();
call    0 returned 1
        1:13856:  print_dir_data_base ();
call    0 returned 1
        1:13857:  print_rule_data_base ();
call    0 returned 1
        1:13858:  print_file_data_base ();
call    0 returned 1
        1:13859:  print_vpath_data_base ();
call    0 returned 1
        -:13860:
        1:13861:  when = time ((time_t *) 0);
call    0 returned 1
        1:13862:  printf ("\n# Make data base, printed on 00:00 Jan 01 2000\n");
call    0 returned 1
        -:13863:  /* printf (_("\n# Finished Make data base on %s\n"), ctime (&when)); */
        1:13864:}
        -:13865:
        -:13866:/* Exit with STATUS, cleaning up as necessary.  */
        -:13867:
        -:13868:void
function die called 1 returned 0% blocks executed 80%
        1:13869:die (status)
        -:13870:     int status;
        -:13871:{
        -:13872:  static char dying = 0;
        -:13873:
        1:13874:  if (!dying)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -:13875:    {
        -:13876:      int err;
        -:13877:
        1:13878:      dying = 1;
        -:13879:
        1:13880:      if (print_version_flag)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:13881:	print_version ();
call    0 never executed
        -:13882:
        -:13883:      /* Wait for children to die.  */
       1*:13884:      for (err = (status != 0); job_slots_used > 0; err = 0)
branch  0 taken 0
branch  1 taken 1 (fallthrough)
    #####:13885:	reap_children (1, err);
call    0 never executed
        -:13886:
        -:13887:      /* Let the remote job module clean up its state.  */
        1:13888:      remote_cleanup ();
call    0 returned 1
        -:13889:
        -:13890:      /* Remove the intermediate files.  */
        1:13891:      remove_intermediates (0);
call    0 returned 1
        -:13892:
        1:13893:      if (print_data_base_flag)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:13894:	print_data_base ();
call    0 returned 1
        -:13895:
        -:13896:      /* Try to move back to the original directory.  This is essential on
        -:13897:	 MS-DOS (where there is really only one process), and on Unix it
        -:13898:	 puts core files in the original directory instead of the -C
        -:13899:	 directory.  Must wait until after remove_intermediates(), or unlinks
        -:13900:         of relative pathnames fail.  */
        1:13901:      if (directory_before_chdir != 0)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:13902:	chdir (directory_before_chdir);
call    0 returned 1
        -:13903:
        1:13904:      log_working_directory (0);
call    0 returned 1
        -:13905:    }
        -:13906:
        1:13907:  exit (status);
        -:13908:}
        -:13909:
        -:13910:/* Write a message indicating that we've just entered or
        -:13911:   left (according to ENTERING) the current directory.  */
        -:13912:
        -:13913:void
function log_working_directory called 3 returned 100% blocks executed 87%
        3:13914:log_working_directory (entering)
        -:13915:     int entering;
        -:13916:{
        -:13917:  static int entered = 0;
        3:13918:  char *msg = entering ? _("Entering") : _("Leaving");
branch  0 taken 2 (fallthrough)
branch  1 taken 1
        -:13919:
        -:13920:  /* Print nothing without the flag.  Don't print the entering message
        -:13921:     again if we already have.  Don't print the leaving message if we
        -:13922:     haven't printed the entering message.  */
        3:13923:  if (! print_directory_flag || entering == entered)
branch  0 taken 3 (fallthrough)
branch  1 taken 0
branch  2 taken 1 (fallthrough)
branch  3 taken 2
        1:13924:    return;
        -:13925:
        2:13926:  entered = entering;
        -:13927:
        2:13928:  if (print_data_base_flag)
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2:13929:    fputs ("# ", stdout);
call    0 returned 2
        -:13930:
        2:13931:  if (makelevel == 0)
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2:13932:    printf ("%s: %s ", program, msg);
call    0 returned 2
        -:13933:  else
    #####:13934:    printf ("%s[%u]: %s ", program, makelevel, msg);
call    0 never executed
        -:13935:
        2:13936:  if (starting_directory == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####:13937:    puts (_("an unknown directory"));
call    0 never executed
        -:13938:  else
        2:13939:    printf (_("directory `%s'\n"), starting_directory);
call    0 returned 2
        -:13940:}
        -:13941:
        -:13942:
        -:13943:
        -:13944:/*************************************************************
        -:13945:  ============================================================
        -:13946:  ************************************************************
        -:13947:  ============================================================
        -:13948:  ************************************************************
        -:13949:                         misc.c
        -:13950:  ************************************************************
        -:13951:  ============================================================
        -:13952:  ************************************************************
        -:13953:  ============================================================
        -:13954:  *************************************************************/
        -:13955:
        -:13956:/* Miscellaneous generic support functions for GNU Make.
        -:13957:Copyright (C) 1988,89,90,91,92,93,94,95,97 Free Software Foundation, Inc.
        -:13958:This file is part of GNU Make.
        -:13959:
        -:13960:GNU Make is free software; you can redistribute it and/or modify
        -:13961:it under the terms of the GNU General Public License as published by
        -:13962:the Free Software Foundation; either version 2, or (at your option)
        -:13963:any later version.
        -:13964:
        -:13965:GNU Make is distributed in the hope that it will be useful,
        -:13966:but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:13967:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:13968:GNU General Public License for more details.
        -:13969:
        -:13970:You should have received a copy of the GNU General Public License
        -:13971:along with GNU Make; see the file COPYING.  If not, write to
        -:13972:the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
        -:13973:Boston, MA 02111-1307, USA.  */
        -:13974:
        -:13975:/* #include "make.h"  <- modification by J.Ruthruff, 7/28 */
        -:13976:/* #include "dep.h"  <- modification by J.Ruthruff, 7/28 */
        -:13977:#include "debug.h"
        -:13978:#undef stderr
        -:13979:#define stderr stdout
        -:13980:
        -:13981:/* Variadic functions.  We go through contortions to allow proper function
        -:13982:   prototypes for both ANSI and pre-ANSI C compilers, and also for those
        -:13983:   which support stdarg.h vs. varargs.h, and finally those which have
        -:13984:   vfprintf(), etc. and those who have _doprnt... or nothing.
        -:13985:
        -:13986:   This fancy stuff all came from GNU fileutils, except for the VA_PRINTF and
        -:13987:   VA_END macros used here since we have multiple print functions.  */
        -:13988:
        -:13989:#if HAVE_VPRINTF || HAVE_DOPRNT
        -:13990:# define HAVE_STDVARARGS 1
        -:13991:# if __STDC__
        -:13992:#  include <stdarg.h>
        -:13993:#undef stderr
        -:13994:#define stderr stdout
        -:13995:#  define VA_START(args, lastarg) va_start(args, lastarg)
        -:13996:# else
        -:13997:#  include <varargs.h>
        -:13998:#undef stderr
        -:13999:#define stderr stdout
        -:14000:#  define VA_START(args, lastarg) va_start(args)
        -:14001:# endif
        -:14002:# if HAVE_VPRINTF
        -:14003:#  define VA_PRINTF(fp, lastarg, args) vfprintf((fp), (lastarg), (args))
        -:14004:# else
        -:14005:#  define VA_PRINTF(fp, lastarg, args) _doprnt((lastarg), (args), (fp))
        -:14006:# endif
        -:14007:# define VA_END(args) va_end(args)
        -:14008:#else
        -:14009:/* # undef HAVE_STDVARARGS */
        -:14010:# define va_alist a1, a2, a3, a4, a5, a6, a7, a8
        -:14011:# define va_dcl char *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;
        -:14012:# define VA_START(args, lastarg)
        -:14013:# define VA_END(args)
        -:14014:#endif
        -:14015:
        -:14016:
        -:14017:/* Compare strings *S1 and *S2.
        -:14018:   Return negative if the first is less, positive if it is greater,
        -:14019:   zero if they are equal.  */
        -:14020:
        -:14021:int
function alpha_compare called 0 returned 0% blocks executed 0%
    #####:14022:alpha_compare (v1, v2)
        -:14023:     const void *v1, *v2;
        -:14024:{
    #####:14025:  const char *s1 = *((char **)v1);
    #####:14026:  const char *s2 = *((char **)v2);
        -:14027:
    #####:14028:  if (*s1 != *s2)
branch  0 never executed
branch  1 never executed
    #####:14029:    return *s1 - *s2;
    #####:14030:  return strcmp (s1, s2);
        -:14031:}
        -:14032:
        -:14033:/* Discard each backslash-newline combination from LINE.
        -:14034:   Backslash-backslash-newline combinations become backslash-newlines.
        -:14035:   This is done by copying the text at LINE into itself.  */
        -:14036:
        -:14037:void
function collapse_continuations called 0 returned 0% blocks executed 0%
    #####:14038:collapse_continuations (line)
        -:14039:     char *line;
        -:14040:{
        -:14041:  register char *in, *out, *p;
        -:14042:  register int backslash;
        -:14043:  register unsigned int bs_write;
        -:14044:
    #####:14045:  in = strchr (line, '\n');
    #####:14046:  if (in == 0)
branch  0 never executed
branch  1 never executed
    #####:14047:    return;
        -:14048:
    #####:14049:  out = in;
    #####:14050:  while (out > line && out[-1] == '\\')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:14051:    --out;
        -:14052:
    #####:14053:  while (*in != '\0')
branch  0 never executed
branch  1 never executed
        -:14054:    {
        -:14055:      /* BS_WRITE gets the number of quoted backslashes at
        -:14056:	 the end just before IN, and BACKSLASH gets nonzero
        -:14057:	 if the next character is quoted.  */
    #####:14058:      backslash = 0;
    #####:14059:      bs_write = 0;
    #####:14060:      for (p = in - 1; p >= line && *p == '\\'; --p)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:14061:	{
    #####:14062:	  if (backslash)
branch  0 never executed
branch  1 never executed
    #####:14063:	    ++bs_write;
    #####:14064:	  backslash = !backslash;
        -:14065:
        -:14066:	  /* It should be impossible to go back this far without exiting,
        -:14067:	     but if we do, we can't get the right answer.  */
    #####:14068:	  if (in == out - 1)
branch  0 never executed
branch  1 never executed
    #####:14069:	    abort ();
call    0 never executed
        -:14070:	}
        -:14071:
        -:14072:      /* Output the appropriate number of backslashes.  */
    #####:14073:      while (bs_write-- > 0)
branch  0 never executed
branch  1 never executed
    #####:14074:	*out++ = '\\';
        -:14075:
        -:14076:      /* Skip the newline.  */
    #####:14077:      ++in;
        -:14078:
        -:14079:      /* If the newline is quoted, discard following whitespace
        -:14080:	 and any preceding whitespace; leave just one space.  */
    #####:14081:      if (backslash)
branch  0 never executed
branch  1 never executed
        -:14082:	{
    #####:14083:	  in = next_token (in);
call    0 never executed
    #####:14084:	  while (out > line && isblank (out[-1]))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:14085:	    --out;
    #####:14086:	  *out++ = ' ';
        -:14087:	}
        -:14088:      else
        -:14089:	/* If the newline isn't quoted, put it in the output.  */
    #####:14090:	*out++ = '\n';
        -:14091:
        -:14092:      /* Now copy the following line to the output.
        -:14093:	 Stop when we find backslashes followed by a newline.  */
    #####:14094:      while (*in != '\0')
branch  0 never executed
branch  1 never executed
    #####:14095:	if (*in == '\\')
branch  0 never executed
branch  1 never executed
        -:14096:	  {
    #####:14097:	    p = in + 1;
    #####:14098:	    while (*p == '\\')
branch  0 never executed
branch  1 never executed
    #####:14099:	      ++p;
    #####:14100:	    if (*p == '\n')
branch  0 never executed
branch  1 never executed
        -:14101:	      {
    #####:14102:		in = p;
    #####:14103:		break;
        -:14104:	      }
    #####:14105:	    while (in < p)
branch  0 never executed
branch  1 never executed
    #####:14106:	      *out++ = *in++;
        -:14107:	  }
        -:14108:	else
    #####:14109:	  *out++ = *in++;
        -:14110:    }
        -:14111:
    #####:14112:  *out = '\0';
        -:14113:}
        -:14114:
        -:14115:
        -:14116:/* Remove comments from LINE.
        -:14117:   This is done by copying the text at LINE onto itself.  */
        -:14118:
        -:14119:void
function remove_comments called 0 returned 0% blocks executed 0%
    #####:14120:remove_comments (line)
        -:14121:     char *line;
        -:14122:{
        -:14123:  char *comment;
        -:14124:
    #####:14125:  comment = find_char_unquote (line, "#", 0);
call    0 never executed
        -:14126:
    #####:14127:  if (comment != 0)
branch  0 never executed
branch  1 never executed
        -:14128:    /* Cut off the line at the #.  */
    #####:14129:    *comment = '\0';
    #####:14130:}
        -:14131:
        -:14132:/* Print N spaces (used in debug for target-depth).  */
        -:14133:
        -:14134:void
function print_spaces called 372 returned 100% blocks executed 100%
      372:14135:print_spaces (n)
        -:14136:     register unsigned int n;
        -:14137:{
     1737:14138:  while (n-- > 0)
branch  0 taken 1365
branch  1 taken 372 (fallthrough)
     1365:14139:    putchar (' ');
call    0 returned 1365
      372:14140:}
        -:14141:
        -:14142:
        -:14143:/* Return a newly-allocated string whose contents
        -:14144:   concatenate those of s1, s2, s3.  */
        -:14145:
        -:14146:char *
function concat called 1 returned 100% blocks executed 78%
        1:14147:concat (s1, s2, s3)
        -:14148:     register char *s1, *s2, *s3;
        -:14149:{
        -:14150:  register unsigned int len1, len2, len3;
        -:14151:  register char *result;
        -:14152:
       1*:14153:  len1 = *s1 != '\0' ? strlen (s1) : 0;
branch  0 taken 1 (fallthrough)
branch  1 taken 0
       1*:14154:  len2 = *s2 != '\0' ? strlen (s2) : 0;
branch  0 taken 1 (fallthrough)
branch  1 taken 0
       1*:14155:  len3 = *s3 != '\0' ? strlen (s3) : 0;
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -:14156:
        1:14157:  result = (char *) xmalloc (len1 + len2 + len3 + 1);
call    0 returned 1
        -:14158:
        1:14159:  if (*s1 != '\0')
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:14160:    bcopy (s1, result, len1);
        1:14161:  if (*s2 != '\0')
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:14162:    bcopy (s2, result + len1, len2);
        1:14163:  if (*s3 != '\0')
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:14164:    bcopy (s3, result + len1 + len2, len3);
        1:14165:  *(result + len1 + len2 + len3) = '\0';
        -:14166:
        1:14167:  return result;
        -:14168:}
        -:14169:
        -:14170:/* Print a message on stdout.  */
        -:14171:
        -:14172:void
        -:14173:#if __STDC__ && HAVE_STDVARARGS
function message called 0 returned 0% blocks executed 0%
    #####:14174:message (int prefix, const char *fmt, ...)
        -:14175:#else
        -:14176:message (prefix, fmt, va_alist)
        -:14177:     int prefix;
        -:14178:     const char *fmt;
        -:14179:     va_dcl
        -:14180:#endif
        -:14181:{
        -:14182:#if HAVE_STDVARARGS
        -:14183:  va_list args;
        -:14184:#endif
        -:14185:
    #####:14186:  log_working_directory (1);
call    0 never executed
        -:14187:
    #####:14188:  if (fmt != 0)
branch  0 never executed
branch  1 never executed
        -:14189:    {
    #####:14190:      if (prefix)
branch  0 never executed
branch  1 never executed
        -:14191:	{
    #####:14192:	  if (makelevel == 0)
branch  0 never executed
branch  1 never executed
    #####:14193:	    printf ("%s: ", program);
call    0 never executed
        -:14194:	  else
    #####:14195:	    printf ("%s[%u]: ", program, makelevel);
call    0 never executed
        -:14196:	}
    #####:14197:      VA_START (args, fmt);
    #####:14198:      VA_PRINTF (stdout, fmt, args);
call    0 never executed
    #####:14199:      VA_END (args);
    #####:14200:      putchar ('\n');
call    0 never executed
        -:14201:    }
        -:14202:
    #####:14203:  fflush (stdout);
call    0 never executed
    #####:14204:}
        -:14205:
        -:14206:/* Print an error message.  */
        -:14207:
        -:14208:void
        -:14209:#if __STDC__ && HAVE_STDVARARGS
function error called 1 returned 100% blocks executed 73%
        1:14210:error (const struct floc *flocp, const char *fmt, ...)
        -:14211:#else
        -:14212:error (flocp, fmt, va_alist)
        -:14213:     const struct floc *flocp;
        -:14214:     const char *fmt;
        -:14215:     va_dcl
        -:14216:#endif
        -:14217:{
        -:14218:#if HAVE_STDVARARGS
        -:14219:  va_list args;
        -:14220:#endif
        -:14221:
        1:14222:  log_working_directory (1);
call    0 returned 1
        -:14223:
       1*:14224:  if (flocp && flocp->filenm)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
branch  2 never executed
branch  3 never executed
    #####:14225:    fprintf (stderr, "%s:%lu: ", flocp->filenm, flocp->lineno);
call    0 never executed
        1:14226:  else if (makelevel == 0)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:14227:    fprintf (stderr, "%s: ", program);
call    0 returned 1
        -:14228:  else
    #####:14229:    fprintf (stderr, "%s[%u]: ", program, makelevel);
call    0 never executed
        -:14230:
        1:14231:  VA_START(args, fmt);
        1:14232:  VA_PRINTF (stderr, fmt, args);
call    0 returned 1
        1:14233:  VA_END (args);
        -:14234:
        1:14235:  putc ('\n', stderr);
call    0 returned 1
        1:14236:  fflush (stderr);
call    0 returned 1
        1:14237:}
        -:14238:
        -:14239:/* Print an error message and exit.  */
        -:14240:
        -:14241:void
        -:14242:#if __STDC__ && HAVE_STDVARARGS
function fatal called 1 returned 0% blocks executed 70%
        1:14243:fatal (const struct floc *flocp, const char *fmt, ...)
        -:14244:#else
        -:14245:fatal (flocp, fmt, va_alist)
        -:14246:     const struct floc *flocp;
        -:14247:     const char *fmt;
        -:14248:     va_dcl
        -:14249:#endif
        -:14250:{
        -:14251:#if HAVE_STDVARARGS
        -:14252:  va_list args;
        -:14253:#endif
        -:14254:
        1:14255:  log_working_directory (1);
call    0 returned 1
        -:14256:
       1*:14257:  if (flocp && flocp->filenm)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
branch  2 never executed
branch  3 never executed
    #####:14258:    fprintf (stderr, "%s:%lu: *** ", flocp->filenm, flocp->lineno);
call    0 never executed
        1:14259:  else if (makelevel == 0)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:14260:    fprintf (stderr, "%s: *** ", program);
call    0 returned 1
        -:14261:  else
    #####:14262:    fprintf (stderr, "%s[%u]: *** ", program, makelevel);
call    0 never executed
        -:14263:
        1:14264:  VA_START(args, fmt);
        1:14265:  VA_PRINTF (stderr, fmt, args);
call    0 returned 1
        1:14266:  VA_END (args);
        -:14267:
        1:14268:  fputs (_(".  Stop.\n"), stderr);
call    0 returned 1
        -:14269:
        1:14270:  die (2);
        -:14271:}
        -:14272:
        -:14273:#ifndef HAVE_STRERROR
        -:14274:
        -:14275:#undef	strerror
        -:14276:
        -:14277:char *
        -:14278:strerror (errnum)
        -:14279:     int errnum;
        -:14280:{
        -:14281:  extern int errno, sys_nerr;
        -:14282:#ifndef __DECC
        -:14283:  extern char *sys_errlist[];
        -:14284:#endif
        -:14285:  static char buf[] = "Unknown error 12345678901234567890";
        -:14286:
        -:14287:  if (errno < sys_nerr)
        -:14288:    return sys_errlist[errnum];
        -:14289:
        -:14290:  sprintf (buf, _("Unknown error %d"), errnum);
        -:14291:  return buf;
        -:14292:}
        -:14293:#endif
        -:14294:
        -:14295:/* Print an error message from errno.  */
        -:14296:
        -:14297:void
function perror_with_name called 1 returned 100% blocks executed 100%
        1:14298:perror_with_name (str, name)
        -:14299:     char *str, *name;
        -:14300:{
        1:14301:  error (NILF, "%s%s: %s", str, name, strerror (errno));
call    0 returned 1
call    1 returned 1
        1:14302:}
        -:14303:
        -:14304:/* Print an error message from errno and exit.  */
        -:14305:
        -:14306:void
function pfatal_with_name called 0 returned 0% blocks executed 0%
    #####:14307:pfatal_with_name (name)
        -:14308:     char *name;
        -:14309:{
    #####:14310:  fatal (NILF, "%s: %s", name, strerror (errno));
call    0 never executed
        -:14311:
        -:14312:  /* NOTREACHED */
        -:14313:}
        -:14314:
        -:14315:/* Like malloc but get fatal error if memory is exhausted.  */
        -:14316:/* Don't bother if we're using dmalloc; it provides these for us.  */
        -:14317:
        -:14318:#ifndef HAVE_DMALLOC_H
        -:14319:
        -:14320:#undef xmalloc
        -:14321:#undef xrealloc
        -:14322:#undef xstrdup
        -:14323:
        -:14324:char *
function xmalloc called 1077 returned 100% blocks executed 75%
     1077:14325:xmalloc (size)
        -:14326:     unsigned int size;
        -:14327:{
     1077:14328:  char *result = (char *) malloc (size);
     1077:14329:  if (result == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    #####:14330:    fatal (NILF, _("virtual memory exhausted"));
call    0 never executed
     1077:14331:  return result;
        -:14332:}
        -:14333:
        -:14334:
        -:14335:char *
function xrealloc called 1 returned 100% blocks executed 71%
        1:14336:xrealloc (ptr, size)
        -:14337:     char *ptr;
        -:14338:     unsigned int size;
        -:14339:{
        -:14340:  char *result;
        -:14341:
        -:14342:  /* Some older implementations of realloc() don't conform to ANSI.  */
       1*:14343:  result = ptr ? realloc (ptr, size) : malloc (size);
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        1:14344:  if (result == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:14345:    fatal (NILF, _("virtual memory exhausted"));
call    0 never executed
        1:14346:  return result;
        -:14347:}
        -:14348:
        -:14349:
        -:14350:char *
function xstrdup called 208 returned 100% blocks executed 75%
      208:14351:xstrdup (ptr)
        -:14352:     const char *ptr;
        -:14353:{
        -:14354:  char *result;
        -:14355:
        -:14356:#ifdef HAVE_STRDUP
      208:14357:  result = strdup (ptr);
        -:14358:#else
        -:14359:  result = (char *) malloc (strlen (ptr) + 1);
        -:14360:#endif
        -:14361:
      208:14362:  if (result == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 208
    #####:14363:    fatal (NILF, _("virtual memory exhausted"));
call    0 never executed
        -:14364:
        -:14365:#ifdef HAVE_STRDUP
      208:14366:  return result;
        -:14367:#else
        -:14368:  return strcpy(result, ptr);
        -:14369:#endif
        -:14370:}
        -:14371:
        -:14372:#endif  /* HAVE_DMALLOC_H */
        -:14373:
        -:14374:char *
function savestring called 189 returned 100% blocks executed 100%
      189:14375:savestring (str, length)
        -:14376:     const char *str;
        -:14377:     unsigned int length;
        -:14378:{
      189:14379:  register char *out = (char *) xmalloc (length + 1);
call    0 returned 189
      189:14380:  if (length > 0)
branch  0 taken 189 (fallthrough)
branch  1 taken 0
      189:14381:    bcopy (str, out, length);
      189:14382:  out[length] = '\0';
      189:14383:  return out;
        -:14384:}
        -:14385:
        -:14386:/* Search string BIG (length BLEN) for an occurrence of
        -:14387:   string SMALL (length SLEN).  Return a pointer to the
        -:14388:   beginning of the first occurrence, or return nil if none found.  */
        -:14389:
        -:14390:char *
function sindex called 0 returned 0% blocks executed 0%
    #####:14391:sindex (big, blen, small, slen)
        -:14392:     const char *big;
        -:14393:     unsigned int blen;
        -:14394:     const char *small;
        -:14395:     unsigned int slen;
        -:14396:{
    #####:14397:  if (!blen)
branch  0 never executed
branch  1 never executed
    #####:14398:    blen = strlen (big);
    #####:14399:  if (!slen)
branch  0 never executed
branch  1 never executed
    #####:14400:    slen = strlen (small);
        -:14401:
    #####:14402:  if (slen && blen >= slen)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:14403:    {
        -:14404:      register unsigned int b;
        -:14405:
        -:14406:      /* Quit when there's not enough room left for the small string.  */
    #####:14407:      --slen;
    #####:14408:      blen -= slen;
        -:14409:
    #####:14410:      for (b = 0; b < blen; ++b, ++big)
branch  0 never executed
branch  1 never executed
    #####:14411:        if (*big == *small && strneq (big + 1, small + 1, slen))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:14412:          return (char *)big;
        -:14413:    }
        -:14414:
    #####:14415:  return 0;
        -:14416:}
        -:14417:
        -:14418:/* Limited INDEX:
        -:14419:   Search through the string STRING, which ends at LIMIT, for the character C.
        -:14420:   Returns a pointer to the first occurrence, or nil if none is found.
        -:14421:   Like INDEX except that the string searched ends where specified
        -:14422:   instead of at the first null.  */
        -:14423:
        -:14424:char *
function lindex called 10 returned 100% blocks executed 83%
       10:14425:lindex (s, limit, c)
        -:14426:     register const char *s, *limit;
        -:14427:     int c;
        -:14428:{
       84:14429:  while (s < limit)
branch  0 taken 74
branch  1 taken 10 (fallthrough)
       74:14430:    if (*s++ == c)
branch  0 taken 0 (fallthrough)
branch  1 taken 74
    #####:14431:      return (char *)(s - 1);
        -:14432:
       10:14433:  return 0;
        -:14434:}
        -:14435:
        -:14436:/* Return the address of the first whitespace or null in the string S.  */
        -:14437:
        -:14438:char *
function end_of_token called 0 returned 0% blocks executed 0%
    #####:14439:end_of_token (s)
        -:14440:     char *s;
        -:14441:{
    #####:14442:  while (*s != '\0' && !isblank (*s))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:14443:    ++s;
    #####:14444:  return s;
        -:14445:}
        -:14446:
        -:14447:#ifdef WINDOWS32
        -:14448:/*
        -:14449: * Same as end_of_token, but take into account a stop character
        -:14450: */
        -:14451:char *
        -:14452:end_of_token_w32 (s, stopchar)
        -:14453:     char *s;
        -:14454:     char stopchar;
        -:14455:{
        -:14456:  register char *p = s;
        -:14457:  register int backslash = 0;
        -:14458:
        -:14459:  while (*p != '\0' && *p != stopchar && (backslash || !isblank (*p)))
        -:14460:    {
        -:14461:      if (*p++ == '\\')
        -:14462:        {
        -:14463:          backslash = !backslash;
        -:14464:          while (*p == '\\')
        -:14465:            {
        -:14466:              backslash = !backslash;
        -:14467:              ++p;
        -:14468:            }
        -:14469:        }
        -:14470:      else
        -:14471:        backslash = 0;
        -:14472:    }
        -:14473:
        -:14474:  return p;
        -:14475:}
        -:14476:#endif
        -:14477:
        -:14478:/* Return the address of the first nonwhitespace or null in the string S.  */
        -:14479:
        -:14480:char *
function next_token called 190 returned 100% blocks executed 100%
      190:14481:next_token (s)
        -:14482:     char *s;
        -:14483:{
      190:14484:  register char *p = s;
        -:14485:
      225:14486:  while (isblank (*p))
branch  0 taken 35
branch  1 taken 190 (fallthrough)
       35:14487:    ++p;
      190:14488:  return p;
        -:14489:}
        -:14490:
        -:14491:/* Find the next token in PTR; return the address of it, and store the
        -:14492:   length of the token into *LENGTHPTR if LENGTHPTR is not nil.  */
        -:14493:
        -:14494:char *
function find_next_token called 1 returned 100% blocks executed 50%
        1:14495:find_next_token (ptr, lengthptr)
        -:14496:     char **ptr;
        -:14497:     unsigned int *lengthptr;
        -:14498:{
        1:14499:  char *p = next_token (*ptr);
call    0 returned 1
        -:14500:  char *end;
        -:14501:
        1:14502:  if (*p == '\0')
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:14503:    return 0;
        -:14504:
    #####:14505:  *ptr = end = end_of_token (p);
call    0 never executed
    #####:14506:  if (lengthptr != 0)
branch  0 never executed
branch  1 never executed
    #####:14507:    *lengthptr = end - p;
    #####:14508:  return p;
        -:14509:}
        -:14510:
        -:14511:/* Copy a chain of `struct dep', making a new chain
        -:14512:   with the same contents as the old one.  */
        -:14513:
        -:14514:struct dep *
function copy_dep_chain called 1 returned 100% blocks executed 82%
        1:14515:copy_dep_chain (d)
        -:14516:     register struct dep *d;
        -:14517:{
        -:14518:  register struct dep *c;
        1:14519:  struct dep *firstnew = 0;
        1:14520:  struct dep *lastnew = 0;
        -:14521:
        2:14522:  while (d != 0)
branch  0 taken 1
branch  1 taken 1 (fallthrough)
        -:14523:    {
        1:14524:      c = (struct dep *) xmalloc (sizeof (struct dep));
call    0 returned 1
        1:14525:      bcopy ((char *) d, (char *) c, sizeof (struct dep));
        1:14526:      if (c->name != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:14527:	c->name = xstrdup (c->name);
call    0 never executed
        1:14528:      c->next = 0;
        1:14529:      if (firstnew == 0)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:14530:	firstnew = lastnew = c;
        -:14531:#ifndef F_AA_8
        -:14532:      else
        -:14533:    lastnew = lastnew->next = c;
        -:14534:#endif
        1:14535:      d = d->next;
        -:14536:    }
        -:14537:
        1:14538:  return firstnew;
        -:14539:}
        -:14540:
        -:14541:#ifdef	iAPX286
        -:14542:/* The losing compiler on this machine can't handle this macro.  */
        -:14543:
        -:14544:char *
        -:14545:dep_name (dep)
        -:14546:     struct dep *dep;
        -:14547:{
        -:14548:  return dep->name == 0 ? dep->file->name : dep->name;
        -:14549:}
        -:14550:#endif
        -:14551:
        -:14552:#ifdef	GETLOADAVG_PRIVILEGED
        -:14553:
        -:14554:#ifdef POSIX
        -:14555:
        -:14556:/* Hopefully if a system says it's POSIX.1 and has the setuid and setgid
        -:14557:   functions, they work as POSIX.1 says.  Some systems (Alpha OSF/1 1.2,
        -:14558:   for example) which claim to be POSIX.1 also have the BSD setreuid and
        -:14559:   setregid functions, but they don't work as in BSD and only the POSIX.1
        -:14560:   way works.  */
        -:14561:
        -:14562:#undef HAVE_SETREUID
        -:14563:#undef HAVE_SETREGID
        -:14564:
        -:14565:#else	/* Not POSIX.  */
        -:14566:
        -:14567:/* Some POSIX.1 systems have the seteuid and setegid functions.  In a
        -:14568:   POSIX-like system, they are the best thing to use.  However, some
        -:14569:   non-POSIX systems have them too but they do not work in the POSIX style
        -:14570:   and we must use setreuid and setregid instead.  */
        -:14571:
        -:14572:#undef HAVE_SETEUID
        -:14573:#undef HAVE_SETEGID
        -:14574:
        -:14575:#endif	/* POSIX.  */
        -:14576:
        -:14577:#ifndef	HAVE_UNISTD_H
        -:14578:extern int getuid (), getgid (), geteuid (), getegid ();
        -:14579:extern int setuid (), setgid ();
        -:14580:#ifdef HAVE_SETEUID
        -:14581:extern int seteuid ();
        -:14582:#else
        -:14583:#ifdef	HAVE_SETREUID
        -:14584:extern int setreuid ();
        -:14585:#endif	/* Have setreuid.  */
        -:14586:#endif	/* Have seteuid.  */
        -:14587:#ifdef HAVE_SETEGID
        -:14588:extern int setegid ();
        -:14589:#else
        -:14590:#ifdef	HAVE_SETREGID
        -:14591:extern int setregid ();
        -:14592:#endif	/* Have setregid.  */
        -:14593:#endif	/* Have setegid.  */
        -:14594:#endif	/* No <unistd.h>.  */
        -:14595:
        -:14596:/* Keep track of the user and group IDs for user- and make- access.  */
        -:14597:static int user_uid = -1, user_gid = -1, make_uid = -1, make_gid = -1;
        -:14598:#define	access_inited	(user_uid != -1)
        -:14599:static enum { make, user } current_access;
        -:14600:
        -:14601:
        -:14602:/* Under -d, write a message describing the current IDs.  */
        -:14603:
        -:14604:static void
        -:14605:log_access (flavor)
        -:14606:     char *flavor;
        -:14607:{
        -:14608:  if (! ISDB (DB_JOBS))
        -:14609:    return;
        -:14610:
        -:14611:  /* All the other debugging messages go to stdout,
        -:14612:     but we write this one to stderr because it might be
        -:14613:     run in a child fork whose stdout is piped.  */
        -:14614:
        -:14615:  fprintf (stderr, _("%s access: user %lu (real %lu), group %lu (real %lu)\n"),
        -:14616:	   flavor, (unsigned long) geteuid (), (unsigned long) getuid (),
        -:14617:           (unsigned long) getegid (), (unsigned long) getgid ());
        -:14618:  fflush (stderr);
        -:14619:}
        -:14620:
        -:14621:
        -:14622:static void
        -:14623:init_access ()
        -:14624:{
        -:14625:#ifndef VMS
        -:14626:  user_uid = getuid ();
        -:14627:  user_gid = getgid ();
        -:14628:
        -:14629:  make_uid = geteuid ();
        -:14630:  make_gid = getegid ();
        -:14631:
        -:14632:  /* Do these ever fail?  */
        -:14633:  if (user_uid == -1 || user_gid == -1 || make_uid == -1 || make_gid == -1)
        -:14634:    pfatal_with_name ("get{e}[gu]id");
        -:14635:
        -:14636:  log_access (_("Initialized"));
        -:14637:
        -:14638:  current_access = make;
        -:14639:#endif
        -:14640:}
        -:14641:
        -:14642:#endif	/* GETLOADAVG_PRIVILEGED */
        -:14643:
        -:14644:/* Give the process appropriate permissions for access to
        -:14645:   user data (i.e., to stat files, or to spawn a child process).  */
        -:14646:void
function user_access called 1 returned 100% blocks executed 100%
        1:14647:user_access ()
        -:14648:{
        -:14649:#ifdef	GETLOADAVG_PRIVILEGED
        -:14650:
        -:14651:  if (!access_inited)
        -:14652:    init_access ();
        -:14653:
        -:14654:  if (current_access == user)
        -:14655:    return;
        -:14656:
        -:14657:  /* We are in "make access" mode.  This means that the effective user and
        -:14658:     group IDs are those of make (if it was installed setuid or setgid).
        -:14659:     We now want to set the effective user and group IDs to the real IDs,
        -:14660:     which are the IDs of the process that exec'd make.  */
        -:14661:
        -:14662:#ifdef	HAVE_SETEUID
        -:14663:
        -:14664:  /* Modern systems have the seteuid/setegid calls which set only the
        -:14665:     effective IDs, which is ideal.  */
        -:14666:
        -:14667:  if (seteuid (user_uid) < 0)
        -:14668:    pfatal_with_name ("user_access: seteuid");
        -:14669:
        -:14670:#else	/* Not HAVE_SETEUID.  */
        -:14671:
        -:14672:#ifndef	HAVE_SETREUID
        -:14673:
        -:14674:  /* System V has only the setuid/setgid calls to set user/group IDs.
        -:14675:     There is an effective ID, which can be set by setuid/setgid.
        -:14676:     It can be set (unless you are root) only to either what it already is
        -:14677:     (returned by geteuid/getegid, now in make_uid/make_gid),
        -:14678:     the real ID (return by getuid/getgid, now in user_uid/user_gid),
        -:14679:     or the saved set ID (what the effective ID was before this set-ID
        -:14680:     executable (make) was exec'd).  */
        -:14681:
        -:14682:  if (setuid (user_uid) < 0)
        -:14683:    pfatal_with_name ("user_access: setuid");
        -:14684:
        -:14685:#else	/* HAVE_SETREUID.  */
        -:14686:
        -:14687:  /* In 4BSD, the setreuid/setregid calls set both the real and effective IDs.
        -:14688:     They may be set to themselves or each other.  So you have two alternatives
        -:14689:     at any one time.  If you use setuid/setgid, the effective will be set to
        -:14690:     the real, leaving only one alternative.  Using setreuid/setregid, however,
        -:14691:     you can toggle between your two alternatives by swapping the values in a
        -:14692:     single setreuid or setregid call.  */
        -:14693:
        -:14694:  if (setreuid (make_uid, user_uid) < 0)
        -:14695:    pfatal_with_name ("user_access: setreuid");
        -:14696:
        -:14697:#endif	/* Not HAVE_SETREUID.  */
        -:14698:#endif	/* HAVE_SETEUID.  */
        -:14699:
        -:14700:#ifdef	HAVE_SETEGID
        -:14701:  if (setegid (user_gid) < 0)
        -:14702:    pfatal_with_name ("user_access: setegid");
        -:14703:#else
        -:14704:#ifndef	HAVE_SETREGID
        -:14705:  if (setgid (user_gid) < 0)
        -:14706:    pfatal_with_name ("user_access: setgid");
        -:14707:#else
        -:14708:  if (setregid (make_gid, user_gid) < 0)
        -:14709:    pfatal_with_name ("user_access: setregid");
        -:14710:#endif
        -:14711:#endif
        -:14712:
        -:14713:  current_access = user;
        -:14714:
        -:14715:  log_access ("User");
        -:14716:
        -:14717:#endif	/* GETLOADAVG_PRIVILEGED */
        1:14718:}
        -:14719:
        -:14720:/* Give the process appropriate permissions for access to
        -:14721:   make data (i.e., the load average).  */
        -:14722:void
function make_access called 0 returned 0% blocks executed 0%
    #####:14723:make_access ()
        -:14724:{
        -:14725:#ifdef	GETLOADAVG_PRIVILEGED
        -:14726:
        -:14727:  if (!access_inited)
        -:14728:    init_access ();
        -:14729:
        -:14730:  if (current_access == make)
        -:14731:    return;
        -:14732:
        -:14733:  /* See comments in user_access, above.  */
        -:14734:
        -:14735:#ifdef	HAVE_SETEUID
        -:14736:  if (seteuid (make_uid) < 0)
        -:14737:    pfatal_with_name ("make_access: seteuid");
        -:14738:#else
        -:14739:#ifndef	HAVE_SETREUID
        -:14740:  if (setuid (make_uid) < 0)
        -:14741:    pfatal_with_name ("make_access: setuid");
        -:14742:#else
        -:14743:  if (setreuid (user_uid, make_uid) < 0)
        -:14744:    pfatal_with_name ("make_access: setreuid");
        -:14745:#endif
        -:14746:#endif
        -:14747:
        -:14748:#ifdef	HAVE_SETEGID
        -:14749:  if (setegid (make_gid) < 0)
        -:14750:    pfatal_with_name ("make_access: setegid");
        -:14751:#else
        -:14752:#ifndef	HAVE_SETREGID
        -:14753:  if (setgid (make_gid) < 0)
        -:14754:    pfatal_with_name ("make_access: setgid");
        -:14755:#else
        -:14756:  if (setregid (user_gid, make_gid) < 0)
        -:14757:    pfatal_with_name ("make_access: setregid");
        -:14758:#endif
        -:14759:#endif
        -:14760:
        -:14761:  current_access = make;
        -:14762:
        -:14763:  log_access ("Make");
        -:14764:
        -:14765:#endif	/* GETLOADAVG_PRIVILEGED */
    #####:14766:}
        -:14767:
        -:14768:/* Give the process appropriate permissions for a child process.
        -:14769:   This is like user_access, but you can't get back to make_access.  */
        -:14770:void
function child_access called 0 returned 0% blocks executed 0%
    #####:14771:child_access ()
        -:14772:{
        -:14773:#ifdef	GETLOADAVG_PRIVILEGED
        -:14774:
        -:14775:  if (!access_inited)
        -:14776:    abort ();
        -:14777:
        -:14778:  /* Set both the real and effective UID and GID to the user's.
        -:14779:     They cannot be changed back to make's.  */
        -:14780:
        -:14781:#ifndef	HAVE_SETREUID
        -:14782:  if (setuid (user_uid) < 0)
        -:14783:    pfatal_with_name ("child_access: setuid");
        -:14784:#else
        -:14785:  if (setreuid (user_uid, user_uid) < 0)
        -:14786:    pfatal_with_name ("child_access: setreuid");
        -:14787:#endif
        -:14788:
        -:14789:#ifndef	HAVE_SETREGID
        -:14790:  if (setgid (user_gid) < 0)
        -:14791:    pfatal_with_name ("child_access: setgid");
        -:14792:#else
        -:14793:  if (setregid (user_gid, user_gid) < 0)
        -:14794:    pfatal_with_name ("child_access: setregid");
        -:14795:#endif
        -:14796:
        -:14797:  log_access ("Child");
        -:14798:
        -:14799:#endif	/* GETLOADAVG_PRIVILEGED */
    #####:14800:}
        -:14801:
        -:14802:#ifdef NEED_GET_PATH_MAX
        -:14803:unsigned int
        -:14804:get_path_max ()
        -:14805:{
        -:14806:  static unsigned int value;
        -:14807:
        -:14808:  if (value == 0)
        -:14809:    {
        -:14810:      long int x = pathconf ("/", _PC_PATH_MAX);
        -:14811:      if (x > 0)
        -:14812:	value = x;
        -:14813:      else
        -:14814:	return MAXPATHLEN;
        -:14815:    }
        -:14816:
        -:14817:  return value;
        -:14818:}
        -:14819:#endif
        -:14820:
        -:14821:
        -:14822:
        -:14823:/*************************************************************
        -:14824:  ============================================================
        -:14825:  ************************************************************
        -:14826:  ============================================================
        -:14827:  ************************************************************
        -:14828:                         read.c
        -:14829:  ************************************************************
        -:14830:  ============================================================
        -:14831:  ************************************************************
        -:14832:  ============================================================
        -:14833:  *************************************************************/
        -:14834:
        -:14835:/* Reading and parsing of makefiles for GNU Make.
        -:14836:Copyright (C) 1988,89,90,91,92,93,94,95,96,97 Free Software Foundation, Inc.
        -:14837:This file is part of GNU Make.
        -:14838:
        -:14839:GNU Make is free software; you can redistribute it and/or modify
        -:14840:it under the terms of the GNU General Public License as published by
        -:14841:the Free Software Foundation; either version 2, or (at your option)
        -:14842:any later version.
        -:14843:
        -:14844:GNU Make is distributed in the hope that it will be useful,
        -:14845:but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:14846:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:14847:GNU General Public License for more details.
        -:14848:
        -:14849:You should have received a copy of the GNU General Public License
        -:14850:along with GNU Make; see the file COPYING.  If not, write to
        -:14851:the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
        -:14852:Boston, MA 02111-1307, USA.  */
        -:14853:
        -:14854:/* #include "make.h"  <- modification by J.Ruthruff, 7/28 */
        -:14855:
        -:14856:#include <assert.h>
        -:14857:
        -:14858:#include <glob.h>
        -:14859:
        -:14860:/* #include "dep.h"  <- modification by J.Ruthruff, 7/28 */
        -:14861:/* #include "filedef.h"  <- modification by J.Ruthruff, 7/28 */
        -:14862:#include "job.h"
        -:14863:/* #include "commands.h"  <- modification by J.Ruthruff, 7/28 */
        -:14864:/* #include "variable.h"  <- modification by J.Ruthruff, 7/28 */
        -:14865:/* #include "rule.h"  <- modification by J.Ruthruff, 7/28 */
        -:14866:#include "debug.h"
        -:14867:#undef stderr
        -:14868:#define stderr stdout
        -:14869:
        -:14870:
        -:14871:#ifndef WINDOWS32
        -:14872:#ifndef _AMIGA
        -:14873:#ifndef VMS
        -:14874:#include <pwd.h>
        -:14875:#undef stderr
        -:14876:#define stderr stdout
        -:14877:#else
        -:14878:struct passwd *getpwnam PARAMS ((char *name));
        -:14879:#endif
        -:14880:#endif
        -:14881:#endif /* !WINDOWS32 */
        -:14882:
        -:14883:/* A `struct linebuffer' is a structure which holds a line of text.
        -:14884:   `readline' reads a line from a stream into a linebuffer
        -:14885:   and works regardless of the length of the line.  */
        -:14886:
        -:14887:struct linebuffer
        -:14888:  {
        -:14889:    /* Note:  This is the number of bytes malloc'ed for `buffer'
        -:14890:       It does not indicate `buffer's real length.
        -:14891:       Instead, a null char indicates end-of-string.  */
        -:14892:    unsigned int size;
        -:14893:    char *buffer;
        -:14894:  };
        -:14895:
        -:14896:#define initbuffer(lb) (lb)->buffer = (char *) xmalloc ((lb)->size = 200)
        -:14897:#define freebuffer(lb) free ((lb)->buffer)
        -:14898:
        -:14899:
        -:14900:/* Types of "words" that can be read in a makefile.  */
        -:14901:enum make_word_type
        -:14902:  {
        -:14903:     w_bogus, w_eol, w_static, w_variable, w_colon, w_dcolon, w_semicolon,
        -:14904:     w_comment, w_varassign
        -:14905:  };
        -:14906:
        -:14907:
        -:14908:/* A `struct conditionals' contains the information describing
        -:14909:   all the active conditionals in a makefile.
        -:14910:
        -:14911:   The global variable `conditionals' contains the conditionals
        -:14912:   information for the current makefile.  It is initialized from
        -:14913:   the static structure `toplevel_conditionals' and is later changed
        -:14914:   to new structures for included makefiles.  */
        -:14915:
        -:14916:struct conditionals
        -:14917:  {
        -:14918:    unsigned int if_cmds;	/* Depth of conditional nesting.  */
        -:14919:    unsigned int allocated;	/* Elts allocated in following arrays.  */
        -:14920:    char *ignoring;		/* Are we ignoring or interepreting?  */
        -:14921:    char *seen_else;		/* Have we already seen an `else'?  */
        -:14922:  };
        -:14923:
        -:14924:static struct conditionals toplevel_conditionals;
        -:14925:static struct conditionals *conditionals = &toplevel_conditionals;
        -:14926:
        -:14927:
        -:14928:/* Default directories to search for include files in  */
        -:14929:
        -:14930:static char *default_include_directories[] =
        -:14931:  {
        -:14932:#if defined(WINDOWS32) && !defined(INCLUDEDIR)
        -:14933:/*
        -:14934: * This completly up to the user when they install MSVC or other packages.
        -:14935: * This is defined as a placeholder.
        -:14936: */
        -:14937:#define INCLUDEDIR "."
        -:14938:#endif
        -:14939:    INCLUDEDIR,
        -:14940:#ifndef _AMIGA
        -:14941:    "/usr/gnu/include",
        -:14942:    "/usr/local/include",
        -:14943:    "/usr/include",
        -:14944:#endif
        -:14945:    0
        -:14946:  };
        -:14947:
        -:14948:/* List of directories to search for include files in  */
        -:14949:
        -:14950:static char **include_directories_to_search;
        -:14951:
        -:14952:/* Maximum length of an element of the above.  */
        -:14953:
        -:14954:static unsigned int max_incl_len;
        -:14955:
        -:14956:/* The filename and pointer to line number of the
        -:14957:   makefile currently being read in.  */
        -:14958:
        -:14959:const struct floc *reading_file;
        -:14960:
        -:14961:/* The chain of makefiles read by read_makefile.  */
        -:14962:
        -:14963:static struct dep *read_makefiles = 0;
        -:14964:
        -:14965:static int read_makefile PARAMS ((char *filename, int flags));
        -:14966:static unsigned long readline PARAMS ((struct linebuffer *linebuffer,
        -:14967:                                       FILE *stream, const struct floc *flocp));
        -:14968:static void do_define PARAMS ((char *name, unsigned int namelen,
        -:14969:                               enum variable_origin origin, FILE *infile,
        -:14970:                               struct floc *flocp));
        -:14971:static int conditional_line PARAMS ((char *line, const struct floc *flocp));
        -:14972:static void record_files PARAMS ((struct nameseq *filenames, char *pattern, char *pattern_percent,
        -:14973:			struct dep *deps, unsigned int cmds_started, char *commands,
        -:14974:			unsigned int commands_idx, int two_colon,
        -:14975:			const struct floc *flocp, int set_default));
        -:14976:static void record_target_var PARAMS ((struct nameseq *filenames, char *defn,
        -:14977:                                       int two_colon,
        -:14978:                                       enum variable_origin origin,
        -:14979:                                       const struct floc *flocp));
        -:14980:static enum make_word_type get_next_mword PARAMS ((char *buffer, char *delim,
        -:14981:                        char **startp, unsigned int *length));
        -:14982:
        -:14983:/* Read in all the makefiles and return the chain of their names.  */
        -:14984:
        -:14985:struct dep *
function read_all_makefiles called 1 returned 100% blocks executed 40%
        1:14986:read_all_makefiles (makefiles)
        -:14987:     char **makefiles;
        -:14988:{
        1:14989:  unsigned int num_makefiles = 0;
        -:14990:
        1:14991:  DB (DB_BASIC, (_("Reading makefiles...\n")));
branch  0 taken 1 (fallthrough)
branch  1 taken 0
call    2 returned 1
call    3 returned 1
        -:14992:
        -:14993:  /* If there's a non-null variable MAKEFILES, its value is a list of
        -:14994:     files to read first thing.  But don't let it prevent reading the
        -:14995:     default makefiles and don't let the default goal come from there.  */
        -:14996:
        -:14997:  {
        -:14998:    char *value;
        -:14999:    char *name, *p;
        -:15000:    unsigned int length;
        -:15001:
        -:15002:    {
        -:15003:      /* Turn off --warn-undefined-variables while we expand MAKEFILES.  */
        1:15004:      int save = warn_undefined_variables_flag;
        1:15005:      warn_undefined_variables_flag = 0;
        -:15006:
        1:15007:      value = allocated_variable_expand ("$(MAKEFILES)");
call    0 returned 1
        -:15008:
        1:15009:      warn_undefined_variables_flag = save;
        -:15010:    }
        -:15011:
        -:15012:    /* Set NAME to the start of next token and LENGTH to its length.
        -:15013:       MAKEFILES is updated for finding remaining tokens.  */
        1:15014:    p = value;
        -:15015:
        1:15016:    while ((name = find_next_token (&p, &length)) != 0)
call    0 returned 1
branch  1 taken 0
branch  2 taken 1 (fallthrough)
        -:15017:      {
    #####:15018:	if (*p != '\0')
branch  0 never executed
branch  1 never executed
    #####:15019:	  *p++ = '\0';
    #####:15020:        name = xstrdup (name);
call    0 never executed
    #####:15021:	if (read_makefile (name,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:15022:                           RM_NO_DEFAULT_GOAL|RM_INCLUDED|RM_DONTCARE) < 2)
    #####:15023:          free (name);
        -:15024:      }
        -:15025:
        1:15026:    free (value);
        -:15027:  }
        -:15028:
        -:15029:  /* Read makefiles specified with -f switches.  */
        -:15030:
        1:15031:  if (makefiles != 0)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        2:15032:    while (*makefiles != 0)
branch  0 taken 1
branch  1 taken 1 (fallthrough)
        -:15033:      {
        1:15034:	struct dep *tail = read_makefiles;
        -:15035:	register struct dep *d;
        -:15036:
        1:15037:	if (! read_makefile (*makefiles, 0))
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0
        1:15038:	  perror_with_name ("", *makefiles);
call    0 returned 1
        -:15039:
        -:15040:	/* Find the right element of read_makefiles.  */
        1:15041:	d = read_makefiles;
        1:15042:	while (d->next != tail)
branch  0 taken 0
branch  1 taken 1 (fallthrough)
    #####:15043:	  d = d->next;
        -:15044:
        -:15045:	/* Use the storage read_makefile allocates.  */
       1*:15046:	*makefiles = dep_name (d);
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:15047:	++num_makefiles;
        1:15048:	++makefiles;
        -:15049:      }
        -:15050:
        -:15051:  /* If there were no -f switches, try the default names.  */
        -:15052:
        1:15053:  if (num_makefiles == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -:15054:    {
        -:15055:      static char *default_makefiles[] =
        -:15056:#ifdef VMS
        -:15057:	/* all lower case since readdir() (the vms version) 'lowercasifies' */
        -:15058:	{ "makefile.vms", "gnumakefile.", "makefile.", 0 };
        -:15059:#else
        -:15060:#ifdef _AMIGA
        -:15061:	{ "GNUmakefile", "Makefile", "SMakefile", 0 };
        -:15062:#else /* !Amiga && !VMS */
        -:15063:	{ "GNUmakefile", "makefile", "Makefile", 0 };
        -:15064:#endif /* AMIGA */
        -:15065:#endif /* VMS */
    #####:15066:      register char **p = default_makefiles;
    #####:15067:      while (*p != 0 && !file_exists_p (*p))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:15068:	++p;
        -:15069:
    #####:15070:      if (*p != 0)
branch  0 never executed
branch  1 never executed
        -:15071:	{
    #####:15072:	  if (! read_makefile (*p, 0))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:15073:	    perror_with_name ("", *p);
call    0 never executed
        -:15074:	}
        -:15075:      else
        -:15076:	{
        -:15077:	  /* No default makefile was found.  Add the default makefiles to the
        -:15078:	     `read_makefiles' chain so they will be updated if possible.  */
    #####:15079:	  struct dep *tail = read_makefiles;
        -:15080:	  /* Add them to the tail, after any MAKEFILES variable makefiles.  */
    #####:15081:	  while (tail != 0 && tail->next != 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:15082:	    tail = tail->next;
    #####:15083:	  for (p = default_makefiles; *p != 0; ++p)
branch  0 never executed
branch  1 never executed
        -:15084:	    {
    #####:15085:	      struct dep *d = (struct dep *) xmalloc (sizeof (struct dep));
call    0 never executed
    #####:15086:	      d->name = 0;
    #####:15087:	      d->file = enter_file (*p);
call    0 never executed
    #####:15088:	      d->file->dontcare = 1;
        -:15089:	      /* Tell update_goal_chain to bail out as soon as this file is
        -:15090:		 made, and main not to die if we can't make this file.  */
    #####:15091:	      d->changed = RM_DONTCARE;
    #####:15092:	      if (tail == 0)
branch  0 never executed
branch  1 never executed
    #####:15093:		read_makefiles = d;
        -:15094:	      else
    #####:15095:		tail->next = d;
    #####:15096:	      tail = d;
        -:15097:	    }
    #####:15098:	  if (tail != 0)
branch  0 never executed
branch  1 never executed
    #####:15099:	    tail->next = 0;
        -:15100:	}
        -:15101:    }
        -:15102:
        1:15103:  return read_makefiles;
        -:15104:}
        -:15105:
        -:15106:/* Read file FILENAME as a makefile and add its contents to the data base.
        -:15107:
        -:15108:   FLAGS contains bits as above.
        -:15109:
        -:15110:   FILENAME is added to the `read_makefiles' chain.
        -:15111:
        -:15112:   Returns 0 if a file was not found or not read.
        -:15113:   Returns 1 if FILENAME was found and read.
        -:15114:   Returns 2 if FILENAME was read, and we kept a reference (don't free it).  */
        -:15115:
        -:15116:static int
function read_makefile called 1 returned 100% blocks executed 6%
        1:15117:read_makefile (filename, flags)
        -:15118:     char *filename;
        -:15119:     int flags;
        -:15120:{
        -:15121:  static char *collapsed = 0;
        -:15122:  static unsigned int collapsed_length = 0;
        -:15123:  register FILE *infile;
        -:15124:  struct linebuffer lb;
        1:15125:  unsigned int commands_len = 200;
        -:15126:  char *commands;
        1:15127:  unsigned int commands_idx = 0;
        -:15128:  unsigned int cmds_started, tgts_started;
        -:15129:  char *p;
        -:15130:  char *p2;
        -:15131:  int len, reading_target;
        1:15132:  int ignoring = 0, in_ignored_define = 0;
        1:15133:  int no_targets = 0;		/* Set when reading a rule without targets.  */
        1:15134:  int using_filename = 0;
        -:15135:  struct floc fileinfo;
        1:15136:  char *passed_filename = filename;
        -:15137:
        1:15138:  struct nameseq *filenames = 0;
        -:15139:  struct dep *deps;
        1:15140:  unsigned int nlines = 0;
        1:15141:  int two_colon = 0;
        1:15142:  char *pattern = 0, *pattern_percent;
        -:15143:
        -:15144:  int makefile_errno;
        -:15145:#if defined (WINDOWS32) || defined (__MSDOS__)
        -:15146:  int check_again;
        -:15147:#endif
        -:15148:
        -:15149:#define record_waiting_files()						      \
        -:15150:  do									      \
        -:15151:    { 									      \
        -:15152:      if (filenames != 0)						      \
        -:15153:        {                                                                     \
        -:15154:	  struct floc fi;                                                     \
        -:15155:	  fi.filenm = fileinfo.filenm;                                        \
        -:15156:	  fi.lineno = tgts_started;                                           \
        -:15157:	  record_files (filenames, pattern, pattern_percent, deps,            \
        -:15158:                        cmds_started, commands, commands_idx, two_colon,      \
        -:15159:                        &fi, !(flags & RM_NO_DEFAULT_GOAL));                  \
        -:15160:          using_filename |= commands_idx > 0;                                 \
        -:15161:        }                                                                     \
        -:15162:      filenames = 0;							      \
        -:15163:      commands_idx = 0;							      \
        -:15164:      if (pattern) { free(pattern); pattern = 0; }                            \
        -:15165:    } while (0)
        -:15166:
        1:15167:  fileinfo.filenm = filename;
        1:15168:  fileinfo.lineno = 1;
        -:15169:
        1:15170:  pattern_percent = 0;
        1:15171:  cmds_started = tgts_started = fileinfo.lineno;
        -:15172:
        1:15173:  if (ISDB (DB_VERBOSE))
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -:15174:    {
        1:15175:      printf (_("Reading makefile `%s'"), fileinfo.filenm);
call    0 returned 1
        1:15176:      if (flags & RM_NO_DEFAULT_GOAL)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:15177:	printf (_(" (no default goal)"));
call    0 never executed
        1:15178:      if (flags & RM_INCLUDED)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:15179:	printf (_(" (search path)"));
call    0 never executed
        1:15180:      if (flags & RM_DONTCARE)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:15181:	printf (_(" (don't care)"));
call    0 never executed
        1:15182:      if (flags & RM_NO_TILDE)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:15183:	printf (_(" (no ~ expansion)"));
call    0 never executed
        1:15184:      puts ("...");
call    0 returned 1
        -:15185:    }
        -:15186:
        -:15187:  /* First, get a stream to read.  */
        -:15188:
        -:15189:  /* Expand ~ in FILENAME unless it came from `include',
        -:15190:     in which case it was already done.  */
        1:15191:  if (!(flags & RM_NO_TILDE) && filename[0] == '~')
branch  0 taken 1 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 1
        -:15192:    {
    #####:15193:      char *expanded = tilde_expand (filename);
call    0 never executed
    #####:15194:      if (expanded != 0)
branch  0 never executed
branch  1 never executed
    #####:15195:	filename = expanded;
        -:15196:    }
        -:15197:
        1:15198:  infile = fopen (filename, "r");
call    0 returned 1
        -:15199:  /* Save the error code so we print the right message later.  */
        1:15200:  makefile_errno = errno;
        -:15201:
        -:15202:  /* If the makefile wasn't found and it's either a makefile from
        -:15203:     the `MAKEFILES' variable or an included makefile,
        -:15204:     search the included makefile search path for this makefile.  */
       1*:15205:  if (infile == 0 && (flags & RM_INCLUDED) && *filename != '/')
branch  0 taken 1 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 1
branch  4 never executed
branch  5 never executed
        -:15206:    {
        -:15207:      register unsigned int i;
    #####:15208:      for (i = 0; include_directories_to_search[i] != 0; ++i)
branch  0 never executed
branch  1 never executed
        -:15209:	{
    #####:15210:	  char *name = concat (include_directories_to_search[i], "/", filename);
call    0 never executed
    #####:15211:	  infile = fopen (name, "r");
call    0 never executed
    #####:15212:	  if (infile == 0)
branch  0 never executed
branch  1 never executed
    #####:15213:	    free (name);
        -:15214:	  else
        -:15215:	    {
    #####:15216:	      filename = name;
    #####:15217:	      break;
        -:15218:	    }
        -:15219:	}
        -:15220:    }
        -:15221:
        -:15222:  /* Add FILENAME to the chain of read makefiles.  */
        1:15223:  deps = (struct dep *) xmalloc (sizeof (struct dep));
call    0 returned 1
        1:15224:  deps->next = read_makefiles;
        1:15225:  read_makefiles = deps;
        1:15226:  deps->name = 0;
        1:15227:  deps->file = lookup_file (filename);
call    0 returned 1
        1:15228:  if (deps->file == 0)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -:15229:    {
        1:15230:      deps->file = enter_file (xstrdup (filename));
call    0 returned 1
call    1 returned 1
        1:15231:      if (flags & RM_DONTCARE)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:15232:	deps->file->dontcare = 1;
        -:15233:    }
        1:15234:  if (filename != passed_filename)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:15235:    free (filename);
        1:15236:  filename = deps->file->name;
        1:15237:  deps->changed = flags;
        1:15238:  deps = 0;
        -:15239:
        -:15240:  /* If the makefile can't be found at all, give up entirely.  */
        -:15241:
        1:15242:  if (infile == 0)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -:15243:    {
        -:15244:      /* If we did some searching, errno has the error from the last
        -:15245:	 attempt, rather from FILENAME itself.  Restore it in case the
        -:15246:	 caller wants to use it in a message.  */
        1:15247:      errno = makefile_errno;
        1:15248:      return 0;
        -:15249:    }
        -:15250:
    #####:15251:  reading_file = &fileinfo;
        -:15252:
        -:15253:  /* Loop over lines in the file.
        -:15254:     The strategy is to accumulate target names in FILENAMES, dependencies
        -:15255:     in DEPS and commands in COMMANDS.  These are used to define a rule
        -:15256:     when the start of the next rule (or eof) is encountered.  */
        -:15257:
    #####:15258:  initbuffer (&lb);
call    0 never executed
    #####:15259:  commands = xmalloc (200);
call    0 never executed
        -:15260:
    #####:15261:  while (!feof (infile))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:15262:    {
    #####:15263:      fileinfo.lineno += nlines;
    #####:15264:      nlines = readline (&lb, infile, &fileinfo);
call    0 never executed
        -:15265:
        -:15266:      /* Check for a shell command line first.
        -:15267:	 If it is not one, we can stop treating tab specially.  */
    #####:15268:      if (lb.buffer[0] == '\t')
branch  0 never executed
branch  1 never executed
        -:15269:	{
        -:15270:	  /* This line is a probably shell command.  */
        -:15271:	  unsigned int len;
        -:15272:
    #####:15273:	  if (no_targets)
branch  0 never executed
branch  1 never executed
        -:15274:	    /* Ignore the commands in a rule with no targets.  */
    #####:15275:	    continue;
        -:15276:
        -:15277:	  /* If there is no preceding rule line, don't treat this line
        -:15278:	     as a command, even though it begins with a tab character.
        -:15279:	     SunOS 4 make appears to behave this way.  */
        -:15280:
    #####:15281:	  if (filenames != 0)
branch  0 never executed
branch  1 never executed
        -:15282:	    {
    #####:15283:	      if (ignoring)
branch  0 never executed
branch  1 never executed
        -:15284:		/* Yep, this is a shell command, and we don't care.  */
    #####:15285:		continue;
        -:15286:
        -:15287:	      /* Append this command line to the line being accumulated.  */
    #####:15288:	      p = lb.buffer;
    #####:15289:	      if (commands_idx == 0)
branch  0 never executed
branch  1 never executed
    #####:15290:		cmds_started = fileinfo.lineno;
    #####:15291:	      len = strlen (p);
    #####:15292:	      if (len + 1 + commands_idx > commands_len)
branch  0 never executed
branch  1 never executed
        -:15293:		{
    #####:15294:		  commands_len = (len + 1 + commands_idx) * 2;
    #####:15295:		  commands = (char *) xrealloc (commands, commands_len);
call    0 never executed
        -:15296:		}
    #####:15297:	      bcopy (p, &commands[commands_idx], len);
    #####:15298:	      commands_idx += len;
    #####:15299:	      commands[commands_idx++] = '\n';
        -:15300:
    #####:15301:	      continue;
        -:15302:	    }
        -:15303:	}
        -:15304:
        -:15305:      /* This line is not a shell command line.  Don't worry about tabs.  */
        -:15306:
    #####:15307:      if (collapsed_length < lb.size)
branch  0 never executed
branch  1 never executed
        -:15308:	{
    #####:15309:	  collapsed_length = lb.size;
    #####:15310:	  if (collapsed != 0)
branch  0 never executed
branch  1 never executed
    #####:15311:	    free (collapsed);
    #####:15312:	  collapsed = (char *) xmalloc (collapsed_length);
call    0 never executed
        -:15313:	}
    #####:15314:      strcpy (collapsed, lb.buffer);
        -:15315:      /* Collapse continuation lines.  */
    #####:15316:      collapse_continuations (collapsed);
call    0 never executed
    #####:15317:      remove_comments (collapsed);
call    0 never executed
        -:15318:
        -:15319:      /* Compare a word, both length and contents. */
        -:15320:#define	word1eq(s, l) 	(len == l && strneq (s, p, l))
    #####:15321:      p = collapsed;
    #####:15322:      while (isspace ((unsigned char)*p))
branch  0 never executed
branch  1 never executed
    #####:15323:	++p;
    #####:15324:      if (*p == '\0')
branch  0 never executed
branch  1 never executed
        -:15325:	/* This line is completely empty.  */
    #####:15326:	continue;
        -:15327:
        -:15328:      /* Find the end of the first token.  Note we don't need to worry about
        -:15329:       * ":" here since we compare tokens by length (so "export" will never
        -:15330:       * be equal to "export:").
        -:15331:       */
    #####:15332:      for (p2 = p+1; *p2 != '\0' && !isspace ((unsigned char)*p2); ++p2)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:15333:        {}
    #####:15334:      len = p2 - p;
        -:15335:
        -:15336:      /* Find the start of the second token.  If it's a `:' remember it,
        -:15337:         since it can't be a preprocessor token--this allows targets named
        -:15338:         `ifdef', `export', etc. */
    #####:15339:      reading_target = 0;
    #####:15340:      while (isspace ((unsigned char)*p2))
branch  0 never executed
branch  1 never executed
    #####:15341:        ++p2;
    #####:15342:      if (*p2 == '\0')
branch  0 never executed
branch  1 never executed
    #####:15343:        p2 = NULL;
    #####:15344:      else if (p2[0] == ':' && p2[1] == '\0')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:15345:        {
    #####:15346:          reading_target = 1;
    #####:15347:          goto skip_conditionals;
        -:15348:        }
        -:15349:
        -:15350:      /* We must first check for conditional and `define' directives before
        -:15351:	 ignoring anything, since they control what we will do with
        -:15352:	 following lines.  */
        -:15353:
    #####:15354:      if (!in_ignored_define
branch  0 never executed
branch  1 never executed
    #####:15355:	  && (word1eq ("ifdef", 5) || word1eq ("ifndef", 6)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:15356:	      || word1eq ("ifeq", 4) || word1eq ("ifneq", 5)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:15357:	      || word1eq ("else", 4) || word1eq ("endif", 5)))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:15358:	{
    #####:15359:	  int i = conditional_line (p, &fileinfo);
call    0 never executed
    #####:15360:	  if (i >= 0)
branch  0 never executed
branch  1 never executed
    #####:15361:	    ignoring = i;
        -:15362:	  else
    #####:15363:	    fatal (&fileinfo, _("invalid syntax in conditional"));
call    0 never executed
    #####:15364:	  continue;
        -:15365:	}
        -:15366:
    #####:15367:      if (word1eq ("endef", 5))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:15368:	{
    #####:15369:	  if (in_ignored_define)
branch  0 never executed
branch  1 never executed
    #####:15370:	    in_ignored_define = 0;
        -:15371:	  else
    #####:15372:	    fatal (&fileinfo, _("extraneous `endef'"));
call    0 never executed
    #####:15373:	  continue;
        -:15374:	}
        -:15375:
    #####:15376:      if (word1eq ("define", 6))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:15377:	{
    #####:15378:	  if (ignoring)
branch  0 never executed
branch  1 never executed
    #####:15379:	    in_ignored_define = 1;
        -:15380:	  else
        -:15381:	    {
    #####:15382:	      p2 = next_token (p + 6);
call    0 never executed
    #####:15383:              if (*p2 == '\0')
branch  0 never executed
branch  1 never executed
    #####:15384:                fatal (&fileinfo, _("empty variable name"));
call    0 never executed
        -:15385:
        -:15386:	      /* Let the variable name be the whole rest of the line,
        -:15387:		 with trailing blanks stripped (comments have already been
        -:15388:		 removed), so it could be a complex variable/function
        -:15389:		 reference that might contain blanks.  */
    #####:15390:	      p = strchr (p2, '\0');
    #####:15391:	      while (isblank (p[-1]))
branch  0 never executed
branch  1 never executed
    #####:15392:		--p;
    #####:15393:	      do_define (p2, p - p2, o_file, infile, &fileinfo);
call    0 never executed
        -:15394:	    }
    #####:15395:	  continue;
        -:15396:	}
        -:15397:
    #####:15398:      if (word1eq ("override", 8))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:15399:        {
    #####:15400:	  p2 = next_token (p + 8);
call    0 never executed
    #####:15401:	  if (*p2 == '\0')
branch  0 never executed
branch  1 never executed
    #####:15402:	    error (&fileinfo, _("empty `override' directive"));
call    0 never executed
    #####:15403:	  if (strneq (p2, "define", 6) && (isblank (p2[6]) || p2[6] == '\0'))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:15404:	    {
    #####:15405:	      if (ignoring)
branch  0 never executed
branch  1 never executed
    #####:15406:		in_ignored_define = 1;
        -:15407:	      else
        -:15408:		{
    #####:15409:		  p2 = next_token (p2 + 6);
call    0 never executed
    #####:15410:                  if (*p2 == '\0')
branch  0 never executed
branch  1 never executed
    #####:15411:                    fatal (&fileinfo, _("empty variable name"));
call    0 never executed
        -:15412:
        -:15413:		  /* Let the variable name be the whole rest of the line,
        -:15414:		     with trailing blanks stripped (comments have already been
        -:15415:		     removed), so it could be a complex variable/function
        -:15416:		     reference that might contain blanks.  */
    #####:15417:		  p = strchr (p2, '\0');
    #####:15418:		  while (isblank (p[-1]))
branch  0 never executed
branch  1 never executed
    #####:15419:		    --p;
    #####:15420:		  do_define (p2, p - p2, o_override, infile, &fileinfo);
call    0 never executed
        -:15421:		}
        -:15422:	    }
    #####:15423:	  else if (!ignoring
branch  0 never executed
branch  1 never executed
    #####:15424:		   && !try_variable_definition (&fileinfo, p2, o_override, 0))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:15425:	    error (&fileinfo, _("invalid `override' directive"));
call    0 never executed
        -:15426:
    #####:15427:	  continue;
        -:15428:	}
    #####:15429: skip_conditionals:
        -:15430:
    #####:15431:      if (ignoring)
branch  0 never executed
branch  1 never executed
        -:15432:	/* Ignore the line.  We continue here so conditionals
        -:15433:	   can appear in the middle of a rule.  */
    #####:15434:	continue;
        -:15435:
    #####:15436:      if (!reading_target && word1eq ("export", 6))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:15437:	{
        -:15438:	  struct variable *v;
    #####:15439:	  p2 = next_token (p + 6);
call    0 never executed
    #####:15440:	  if (*p2 == '\0')
branch  0 never executed
branch  1 never executed
    #####:15441:	    export_all_variables = 1;
    #####:15442:	  v = try_variable_definition (&fileinfo, p2, o_file, 0);
call    0 never executed
    #####:15443:	  if (v != 0)
branch  0 never executed
branch  1 never executed
    #####:15444:	    v->export = v_export;
        -:15445:	  else
        -:15446:	    {
        -:15447:	      unsigned int len;
    #####:15448:	      for (p = find_next_token (&p2, &len); p != 0;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:15449:		   p = find_next_token (&p2, &len))
        -:15450:		{
    #####:15451:		  v = lookup_variable (p, len);
call    0 never executed
    #####:15452:		  if (v == 0)
branch  0 never executed
branch  1 never executed
    #####:15453:		    v = define_variable_loc (p, len, "", o_file, 0, &fileinfo);
call    0 never executed
    #####:15454:		  v->export = v_export;
call    0 never executed
        -:15455:		}
        -:15456:	    }
        -:15457:	}
    #####:15458:      else if (!reading_target && word1eq ("unexport", 8))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:15459:	{
        -:15460:	  unsigned int len;
        -:15461:	  struct variable *v;
    #####:15462:	  p2 = next_token (p + 8);
call    0 never executed
    #####:15463:	  if (*p2 == '\0')
branch  0 never executed
branch  1 never executed
    #####:15464:	    export_all_variables = 0;
    #####:15465:	  for (p = find_next_token (&p2, &len); p != 0;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:15466:	       p = find_next_token (&p2, &len))
        -:15467:	    {
    #####:15468:	      v = lookup_variable (p, len);
call    0 never executed
    #####:15469:	      if (v == 0)
branch  0 never executed
branch  1 never executed
    #####:15470:		v = define_variable_loc (p, len, "", o_file, 0, &fileinfo);
call    0 never executed
    #####:15471:	      v->export = v_noexport;
call    0 never executed
        -:15472:	    }
        -:15473:	}
    #####:15474:      else if (word1eq ("vpath", 5))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:15475:	{
        -:15476:	  char *pattern;
        -:15477:	  unsigned int len;
    #####:15478:	  p2 = variable_expand (p + 5);
call    0 never executed
    #####:15479:	  p = find_next_token (&p2, &len);
call    0 never executed
    #####:15480:	  if (p != 0)
branch  0 never executed
branch  1 never executed
        -:15481:	    {
    #####:15482:	      pattern = savestring (p, len);
call    0 never executed
    #####:15483:	      p = find_next_token (&p2, &len);
call    0 never executed
        -:15484:	      /* No searchpath means remove all previous
        -:15485:		 selective VPATH's with the same pattern.  */
        -:15486:	    }
        -:15487:	  else
        -:15488:	    /* No pattern means remove all previous selective VPATH's.  */
    #####:15489:	    pattern = 0;
    #####:15490:	  construct_vpath_list (pattern, p);
call    0 never executed
    #####:15491:	  if (pattern != 0)
branch  0 never executed
branch  1 never executed
    #####:15492:	    free (pattern);
        -:15493:	}
    #####:15494:      else if (word1eq ("include", 7) || word1eq ("-include", 8)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:15495:	       || word1eq ("sinclude", 8))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:15496:	{
        -:15497:	  /* We have found an `include' line specifying a nested
        -:15498:	     makefile to be read at this point.  */
        -:15499:	  struct conditionals *save, new_conditionals;
        -:15500:	  struct nameseq *files;
        -:15501:	  /* "-include" (vs "include") says no error if the file does not
        -:15502:	     exist.  "sinclude" is an alias for this from SGI.  */
    #####:15503:	  int noerror = p[0] != 'i';
        -:15504:
    #####:15505:	  p = allocated_variable_expand (next_token (p + (noerror ? 8 : 7)));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####:15506:	  if (*p == '\0')
branch  0 never executed
branch  1 never executed
        -:15507:	    {
    #####:15508:	      error (&fileinfo,
branch  0 never executed
branch  1 never executed
    #####:15509:                     _("no file name for `%sinclude'"), noerror ? "-" : "");
call    0 never executed
    #####:15510:	      continue;
        -:15511:	    }
        -:15512:
        -:15513:	  /* Parse the list of file names.  */
    #####:15514:	  p2 = p;
    #####:15515:	  files = multi_glob (parse_file_seq (&p2, '\0',
call    0 never executed
call    1 never executed
        -:15516:					      sizeof (struct nameseq),
        -:15517:					      1),
        -:15518:			      sizeof (struct nameseq));
    #####:15519:	  free (p);
        -:15520:
        -:15521:	  /* Save the state of conditionals and start
        -:15522:	     the included makefile with a clean slate.  */
    #####:15523:	  save = conditionals;
    #####:15524:	  bzero ((char *) &new_conditionals, sizeof new_conditionals);
    #####:15525:	  conditionals = &new_conditionals;
        -:15526:
        -:15527:	  /* Record the rules that are waiting so they will determine
        -:15528:	     the default goal before those in the included makefile.  */
    #####:15529:	  record_waiting_files ();
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:15530:
        -:15531:	  /* Read each included makefile.  */
    #####:15532:	  while (files != 0)
branch  0 never executed
branch  1 never executed
        -:15533:	    {
    #####:15534:	      struct nameseq *next = files->next;
    #####:15535:	      char *name = files->name;
        -:15536:              int r;
        -:15537:
    #####:15538:	      free ((char *)files);
    #####:15539:	      files = next;
        -:15540:
    #####:15541:              r = read_makefile (name, (RM_INCLUDED | RM_NO_TILDE
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:15542:                                        | (noerror ? RM_DONTCARE : 0)));
    #####:15543:	      if (!r && !noerror)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:15544:		error (&fileinfo, "%s: %s", name, strerror (errno));
call    0 never executed
call    1 never executed
        -:15545:
    #####:15546:              if (r < 2)
branch  0 never executed
branch  1 never executed
    #####:15547:                free (name);
        -:15548:	    }
        -:15549:
        -:15550:	  /* Free any space allocated by conditional_line.  */
    #####:15551:	  if (conditionals->ignoring)
branch  0 never executed
branch  1 never executed
    #####:15552:	    free (conditionals->ignoring);
    #####:15553:	  if (conditionals->seen_else)
branch  0 never executed
branch  1 never executed
    #####:15554:	    free (conditionals->seen_else);
        -:15555:
        -:15556:	  /* Restore state.  */
    #####:15557:	  conditionals = save;
    #####:15558:	  reading_file = &fileinfo;
        -:15559:	}
        -:15560:#undef	word1eq
    #####:15561:      else if (try_variable_definition (&fileinfo, p, o_file, 0))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:15562:	/* This line has been dealt with.  */
        -:15563:	;
    #####:15564:      else if (lb.buffer[0] == '\t')
branch  0 never executed
branch  1 never executed
        -:15565:	{
    #####:15566:	  p = collapsed;	/* Ignore comments.  */
    #####:15567:	  while (isblank (*p))
branch  0 never executed
branch  1 never executed
    #####:15568:	    ++p;
    #####:15569:	  if (*p == '\0')
branch  0 never executed
branch  1 never executed
        -:15570:	    /* The line is completely blank; that is harmless.  */
    #####:15571:	    continue;
        -:15572:	  /* This line starts with a tab but was not caught above
        -:15573:	     because there was no preceding target, and the line
        -:15574:	     might have been usable as a variable definition.
        -:15575:	     But now it is definitely lossage.  */
    #####:15576:	  fatal(&fileinfo, _("commands commence before first target"));
call    0 never executed
        -:15577:	}
        -:15578:      else
    #####:15579:	{
        -:15580:	  /* This line describes some target files.  This is complicated by
        -:15581:             the existence of target-specific variables, because we can't
        -:15582:             expand the entire line until we know if we have one or not.  So
        -:15583:             we expand the line word by word until we find the first `:',
        -:15584:             then check to see if it's a target-specific variable.
        -:15585:
        -:15586:             In this algorithm, `lb_next' will point to the beginning of the
        -:15587:             unexpanded parts of the input buffer, while `p2' points to the
        -:15588:             parts of the expanded buffer we haven't searched yet. */
        -:15589:
        -:15590:          enum make_word_type wtype;
        -:15591:          enum variable_origin v_origin;
        -:15592:          char *cmdleft, *lb_next;
    #####:15593:          unsigned int len, plen = 0;
        -:15594:          char *colonp;
        -:15595:
        -:15596:	  /* Record the previous rule.  */
        -:15597:
    #####:15598:	  record_waiting_files ();
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:15599:          tgts_started = fileinfo.lineno;
        -:15600:
        -:15601:	  /* Search the line for an unquoted ; that is not after an
        -:15602:             unquoted #.  */
    #####:15603:	  cmdleft = find_char_unquote (lb.buffer, ";#", 0);
call    0 never executed
    #####:15604:	  if (cmdleft != 0 && *cmdleft == '#')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:15605:	    {
        -:15606:	      /* We found a comment before a semicolon.  */
    #####:15607:	      *cmdleft = '\0';
    #####:15608:	      cmdleft = 0;
        -:15609:	    }
    #####:15610:	  else if (cmdleft != 0)
branch  0 never executed
branch  1 never executed
        -:15611:	    /* Found one.  Cut the line short there before expanding it.  */
    #####:15612:	    *(cmdleft++) = '\0';
        -:15613:
    #####:15614:	  collapse_continuations (lb.buffer);
call    0 never executed
        -:15615:
        -:15616:	  /* We can't expand the entire line, since if it's a per-target
        -:15617:             variable we don't want to expand it.  So, walk from the
        -:15618:             beginning, expanding as we go, and looking for "interesting"
        -:15619:             chars.  The first word is always expandable.  */
    #####:15620:          wtype = get_next_mword(lb.buffer, NULL, &lb_next, &len);
call    0 never executed
    #####:15621:          switch (wtype)
branch  0 never executed
branch  1 never executed
branch  2 never executed
        -:15622:            {
    #####:15623:            case w_eol:
    #####:15624:              if (cmdleft != 0)
branch  0 never executed
branch  1 never executed
    #####:15625:                fatal(&fileinfo, _("missing rule before commands"));
call    0 never executed
        -:15626:              /* This line contained something but turned out to be nothing
        -:15627:                 but whitespace (a comment?).  */
    #####:15628:              continue;
        -:15629:
    #####:15630:            case w_colon:
        -:15631:            case w_dcolon:
        -:15632:              /* We accept and ignore rules without targets for
        -:15633:                 compatibility with SunOS 4 make.  */
    #####:15634:              no_targets = 1;
    #####:15635:              continue;
        -:15636:
    #####:15637:            default:
    #####:15638:              break;
        -:15639:            }
        -:15640:
    #####:15641:          p2 = variable_expand_string(NULL, lb_next, len);
call    0 never executed
        -:15642:          while (1)
        -:15643:            {
    #####:15644:              lb_next += len;
    #####:15645:              if (cmdleft == 0)
branch  0 never executed
branch  1 never executed
        -:15646:                {
        -:15647:                  /* Look for a semicolon in the expanded line.  */
    #####:15648:                  cmdleft = find_char_unquote (p2, ";", 0);
call    0 never executed
        -:15649:
    #####:15650:                  if (cmdleft != 0)
branch  0 never executed
branch  1 never executed
        -:15651:                    {
    #####:15652:                      unsigned long p2_off = p2 - variable_buffer;
    #####:15653:                      unsigned long cmd_off = cmdleft - variable_buffer;
    #####:15654:                      char *pend = p2 + strlen(p2);
        -:15655:
        -:15656:                      /* Append any remnants of lb, then cut the line short
        -:15657:                         at the semicolon.  */
    #####:15658:                      *cmdleft = '\0';
        -:15659:
        -:15660:                      /* One school of thought says that you shouldn't expand
        -:15661:                         here, but merely copy, since now you're beyond a ";"
        -:15662:                         and into a command script.  However, the old parser
        -:15663:                         expanded the whole line, so we continue that for
        -:15664:                         backwards-compatiblity.  Also, it wouldn't be
        -:15665:                         entirely consistent, since we do an unconditional
        -:15666:                         expand below once we know we don't have a
        -:15667:                         target-specific variable. */
    #####:15668:                      (void)variable_expand_string(pend, lb_next, (long)-1);
call    0 never executed
    #####:15669:                      lb_next += strlen(lb_next);
    #####:15670:                      p2 = variable_buffer + p2_off;
    #####:15671:                      cmdleft = variable_buffer + cmd_off + 1;
        -:15672:                    }
        -:15673:                }
        -:15674:
    #####:15675:              colonp = find_char_unquote(p2, ":", 0);
call    0 never executed
        -:15676:#if defined(__MSDOS__) || defined(WINDOWS32)
        -:15677:	      /* The drive spec brain-damage strikes again...  */
        -:15678:	      /* Note that the only separators of targets in this context
        -:15679:		 are whitespace and a left paren.  If others are possible,
        -:15680:		 they should be added to the string in the call to index.  */
        -:15681:	      while (colonp && (colonp[1] == '/' || colonp[1] == '\\') &&
        -:15682:		     colonp > p2 && isalpha ((unsigned char)colonp[-1]) &&
        -:15683:		     (colonp == p2 + 1 || strchr (" \t(", colonp[-2]) != 0))
        -:15684:		colonp = find_char_unquote(colonp + 1, ":", 0);
        -:15685:#endif
    #####:15686:              if (colonp != 0)
branch  0 never executed
branch  1 never executed
    #####:15687:                break;
        -:15688:
    #####:15689:              wtype = get_next_mword(lb_next, NULL, &lb_next, &len);
call    0 never executed
    #####:15690:              if (wtype == w_eol)
branch  0 never executed
branch  1 never executed
    #####:15691:                break;
        -:15692:
    #####:15693:              p2 += strlen(p2);
    #####:15694:              *(p2++) = ' ';
    #####:15695:              p2 = variable_expand_string(p2, lb_next, len);
call    0 never executed
        -:15696:              /* We don't need to worry about cmdleft here, because if it was
        -:15697:                 found in the variable_buffer the entire buffer has already
        -:15698:                 been expanded... we'll never get here.  */
        -:15699:            }
        -:15700:
    #####:15701:	  p2 = next_token (variable_buffer);
call    0 never executed
        -:15702:
        -:15703:          /* If the word we're looking at is EOL, see if there's _anything_
        -:15704:             on the line.  If not, a variable expanded to nothing, so ignore
        -:15705:             it.  If so, we can't parse this line so punt.  */
    #####:15706:          if (wtype == w_eol)
branch  0 never executed
branch  1 never executed
        -:15707:            {
    #####:15708:              if (*p2 != '\0')
branch  0 never executed
branch  1 never executed
        -:15709:                /* There's no need to be ivory-tower about this: check for
        -:15710:                   one of the most common bugs found in makefiles...  */
    #####:15711:                fatal (&fileinfo, _("missing separator%s"),
call    0 never executed
    #####:15712:                       !strneq(lb.buffer, "        ", 8) ? ""
branch  0 never executed
branch  1 never executed
    #####:15713:                       : _(" (did you mean TAB instead of 8 spaces?)"));
    #####:15714:              continue;
        -:15715:            }
        -:15716:
        -:15717:          /* Make the colon the end-of-string so we know where to stop
        -:15718:             looking for targets.  */
    #####:15719:          *colonp = '\0';
    #####:15720:	  filenames = multi_glob (parse_file_seq (&p2, '\0',
call    0 never executed
call    1 never executed
        -:15721:						  sizeof (struct nameseq),
        -:15722:						  1),
        -:15723:				  sizeof (struct nameseq));
    #####:15724:          *p2 = ':';
        -:15725:
    #####:15726:          if (!filenames)
branch  0 never executed
branch  1 never executed
        -:15727:            {
        -:15728:              /* We accept and ignore rules without targets for
        -:15729:                 compatibility with SunOS 4 make.  */
    #####:15730:              no_targets = 1;
    #####:15731:              continue;
        -:15732:            }
        -:15733:          /* This should never be possible; we handled it above.  */
    #####:15734:	  assert (*p2 != '\0');
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:15735:          ++p2;
        -:15736:
        -:15737:	  /* Is this a one-colon or two-colon entry?  */
    #####:15738:	  two_colon = *p2 == ':';
    #####:15739:	  if (two_colon)
branch  0 never executed
branch  1 never executed
    #####:15740:	    p2++;
        -:15741:
        -:15742:          /* Test to see if it's a target-specific variable.  Copy the rest
        -:15743:             of the buffer over, possibly temporarily (we'll expand it later
        -:15744:             if it's not a target-specific variable).  PLEN saves the length
        -:15745:             of the unparsed section of p2, for later.  */
    #####:15746:          if (*lb_next != '\0')
branch  0 never executed
branch  1 never executed
        -:15747:            {
    #####:15748:              unsigned int l = p2 - variable_buffer;
    #####:15749:              plen = strlen (p2);
    #####:15750:              (void) variable_buffer_output (p2+plen,
    #####:15751:                                             lb_next, strlen (lb_next)+1);
call    0 never executed
    #####:15752:              p2 = variable_buffer + l;
        -:15753:            }
        -:15754:
        -:15755:          /* See if it's an "override" keyword; if so see if what comes after
        -:15756:             it looks like a variable definition.  */
        -:15757:
    #####:15758:          wtype = get_next_mword (p2, NULL, &p, &len);
call    0 never executed
        -:15759:
    #####:15760:          v_origin = o_file;
    #####:15761:          if (wtype == w_static && (len == (sizeof ("override")-1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:15762:                                    && strneq (p, "override", len)))
branch  0 never executed
branch  1 never executed
        -:15763:            {
    #####:15764:              v_origin = o_override;
    #####:15765:              wtype = get_next_mword (p+len, NULL, &p, &len);
call    0 never executed
        -:15766:            }
        -:15767:
    #####:15768:          if (wtype != w_eol)
branch  0 never executed
branch  1 never executed
    #####:15769:            wtype = get_next_mword (p+len, NULL, NULL, NULL);
call    0 never executed
        -:15770:
    #####:15771:          if (wtype == w_varassign)
branch  0 never executed
branch  1 never executed
        -:15772:            {
    #####:15773:              record_target_var (filenames, p, two_colon, v_origin, &fileinfo);
call    0 never executed
    #####:15774:              filenames = 0;
    #####:15775:              continue;
        -:15776:            }
        -:15777:
        -:15778:          /* This is a normal target, _not_ a target-specific variable.
        -:15779:             Unquote any = in the dependency list.  */
    #####:15780:          find_char_unquote (lb_next, "=", 0);
call    0 never executed
        -:15781:
        -:15782:	  /* We have some targets, so don't ignore the following commands.  */
    #####:15783:	  no_targets = 0;
        -:15784:
        -:15785:          /* Expand the dependencies, etc.  */
    #####:15786:          if (*lb_next != '\0')
branch  0 never executed
branch  1 never executed
        -:15787:            {
    #####:15788:              unsigned int l = p2 - variable_buffer;
    #####:15789:              (void) variable_expand_string (p2 + plen, lb_next, (long)-1);
call    0 never executed
    #####:15790:              p2 = variable_buffer + l;
        -:15791:
        -:15792:              /* Look for a semicolon in the expanded line.  */
    #####:15793:              if (cmdleft == 0)
branch  0 never executed
branch  1 never executed
        -:15794:                {
    #####:15795:                  cmdleft = find_char_unquote (p2, ";", 0);
call    0 never executed
    #####:15796:                  if (cmdleft != 0)
branch  0 never executed
branch  1 never executed
    #####:15797:                    *(cmdleft++) = '\0';
        -:15798:                }
        -:15799:            }
        -:15800:
        -:15801:	  /* Is this a static pattern rule: `target: %targ: %dep; ...'?  */
    #####:15802:	  p = strchr (p2, ':');
    #####:15803:	  while (p != 0 && p[-1] == '\\')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:15804:	    {
    #####:15805:	      register char *q = &p[-1];
    #####:15806:	      register int backslash = 0;
    #####:15807:	      while (*q-- == '\\')
branch  0 never executed
branch  1 never executed
    #####:15808:		backslash = !backslash;
    #####:15809:	      if (backslash)
branch  0 never executed
branch  1 never executed
    #####:15810:		p = strchr (p + 1, ':');
        -:15811:	      else
    #####:15812:		break;
        -:15813:	    }
        -:15814:#ifdef _AMIGA
        -:15815:	  /* Here, the situation is quite complicated. Let's have a look
        -:15816:	    at a couple of targets:
        -:15817:
        -:15818:		install: dev:make
        -:15819:
        -:15820:		dev:make: make
        -:15821:
        -:15822:		dev:make:: xyz
        -:15823:
        -:15824:	    The rule is that it's only a target, if there are TWO :'s
        -:15825:	    OR a space around the :.
        -:15826:	  */
        -:15827:	  if (p && !(isspace ((unsigned char)p[1]) || !p[1]
        -:15828:                     || isspace ((unsigned char)p[-1])))
        -:15829:	    p = 0;
        -:15830:#endif
        -:15831:#if defined (WINDOWS32) || defined (__MSDOS__)
        -:15832:          do {
        -:15833:            check_again = 0;
        -:15834:            /* For MSDOS and WINDOWS32, skip a "C:\..." or a "C:/..." */
        -:15835:            if (p != 0 && (p[1] == '\\' || p[1] == '/') &&
        -:15836:		isalpha ((unsigned char)p[-1]) &&
        -:15837:		(p == p2 + 1 || strchr (" \t:(", p[-2]) != 0)) {
        -:15838:              p = strchr (p + 1, ':');
        -:15839:              check_again = 1;
        -:15840:            }
        -:15841:          } while (check_again);
        -:15842:#endif
    #####:15843:	  if (p != 0)
branch  0 never executed
branch  1 never executed
        -:15844:	    {
        -:15845:	      struct nameseq *target;
    #####:15846:	      target = parse_file_seq (&p2, ':', sizeof (struct nameseq), 1);
call    0 never executed
    #####:15847:	      ++p2;
    #####:15848:	      if (target == 0)
branch  0 never executed
branch  1 never executed
    #####:15849:		fatal (&fileinfo, _("missing target pattern"));
call    0 never executed
    #####:15850:	      else if (target->next != 0)
branch  0 never executed
branch  1 never executed
    #####:15851:		fatal (&fileinfo, _("multiple target patterns"));
call    0 never executed
    #####:15852:	      pattern = target->name;
    #####:15853:	      pattern_percent = find_percent (pattern);
call    0 never executed
    #####:15854:	      if (pattern_percent == 0)
branch  0 never executed
branch  1 never executed
    #####:15855:		fatal (&fileinfo, _("target pattern contains no `%%'"));
call    0 never executed
    #####:15856:              free((char *)target);
        -:15857:	    }
        -:15858:	  else
    #####:15859:	    pattern = 0;
        -:15860:
        -:15861:	  /* Parse the dependencies.  */
        -:15862:	  deps = (struct dep *)
    #####:15863:	    multi_glob (parse_file_seq (&p2, '\0', sizeof (struct dep), 1),
call    0 never executed
call    1 never executed
        -:15864:			sizeof (struct dep));
        -:15865:
    #####:15866:	  commands_idx = 0;
    #####:15867:	  if (cmdleft != 0)
branch  0 never executed
branch  1 never executed
        -:15868:	    {
        -:15869:	      /* Semicolon means rest of line is a command.  */
    #####:15870:	      unsigned int len = strlen (cmdleft);
        -:15871:
    #####:15872:	      cmds_started = fileinfo.lineno;
        -:15873:
        -:15874:	      /* Add this command line to the buffer.  */
    #####:15875:	      if (len + 2 > commands_len)
branch  0 never executed
branch  1 never executed
        -:15876:		{
    #####:15877:		  commands_len = (len + 2) * 2;
    #####:15878:		  commands = (char *) xrealloc (commands, commands_len);
call    0 never executed
        -:15879:		}
    #####:15880:	      bcopy (cmdleft, commands, len);
    #####:15881:	      commands_idx += len;
    #####:15882:	      commands[commands_idx++] = '\n';
        -:15883:	    }
        -:15884:
    #####:15885:	  continue;
        -:15886:	}
        -:15887:
        -:15888:      /* We get here except in the case that we just read a rule line.
        -:15889:	 Record now the last rule we read, so following spurious
        -:15890:	 commands are properly diagnosed.  */
    #####:15891:      record_waiting_files ();
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:15892:      no_targets = 0;
        -:15893:    }
        -:15894:
    #####:15895:  if (conditionals->if_cmds)
branch  0 never executed
branch  1 never executed
    #####:15896:    fatal (&fileinfo, _("missing `endif'"));
call    0 never executed
        -:15897:
        -:15898:  /* At eof, record the last rule.  */
    #####:15899:  record_waiting_files ();
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:15900:
    #####:15901:  freebuffer (&lb);
    #####:15902:  free ((char *) commands);
    #####:15903:  fclose (infile);
call    0 never executed
        -:15904:
    #####:15905:  reading_file = 0;
        -:15906:
    #####:15907:  return 1+using_filename;
        -:15908:}
        -:15909:
        -:15910:/* Execute a `define' directive.
        -:15911:   The first line has already been read, and NAME is the name of
        -:15912:   the variable to be defined.  The following lines remain to be read.
        -:15913:   LINENO, INFILE and FILENAME refer to the makefile being read.
        -:15914:   The value returned is LINENO, updated for lines read here.  */
        -:15915:
        -:15916:static void
function do_define called 0 returned 0% blocks executed 0%
    #####:15917:do_define (name, namelen, origin, infile, flocp)
        -:15918:     char *name;
        -:15919:     unsigned int namelen;
        -:15920:     enum variable_origin origin;
        -:15921:     FILE *infile;
        -:15922:     struct floc *flocp;
        -:15923:{
        -:15924:  struct linebuffer lb;
    #####:15925:  unsigned int nlines = 0;
    #####:15926:  unsigned int length = 100;
    #####:15927:  char *definition = (char *) xmalloc (100);
call    0 never executed
    #####:15928:  register unsigned int idx = 0;
        -:15929:  register char *p;
        -:15930:
        -:15931:  /* Expand the variable name.  */
    #####:15932:  char *var = (char *) alloca (namelen + 1);
    #####:15933:  bcopy (name, var, namelen);
    #####:15934:  var[namelen] = '\0';
    #####:15935:  var = variable_expand (var);
call    0 never executed
        -:15936:
    #####:15937:  initbuffer (&lb);
call    0 never executed
    #####:15938:  while (!feof (infile))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:15939:    {
        -:15940:      unsigned int len;
        -:15941:
    #####:15942:      flocp->lineno += nlines;
    #####:15943:      nlines = readline (&lb, infile, flocp);
call    0 never executed
        -:15944:
    #####:15945:      collapse_continuations (lb.buffer);
call    0 never executed
        -:15946:
    #####:15947:      p = next_token (lb.buffer);
call    0 never executed
    #####:15948:      len = strlen (p);
    #####:15949:      if ((len == 5 || (len > 5 && isblank (p[5])))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:15950:          && strneq (p, "endef", 5))
branch  0 never executed
branch  1 never executed
        -:15951:	{
    #####:15952:	  p += 5;
    #####:15953:	  remove_comments (p);
call    0 never executed
    #####:15954:	  if (*next_token (p) != '\0')
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:15955:	    error (flocp, _("Extraneous text after `endef' directive"));
call    0 never executed
        -:15956:	  /* Define the variable.  */
    #####:15957:	  if (idx == 0)
branch  0 never executed
branch  1 never executed
    #####:15958:	    definition[0] = '\0';
        -:15959:	  else
    #####:15960:	    definition[idx - 1] = '\0';
    #####:15961:	  (void) define_variable_loc (var, strlen (var), definition, origin,
call    0 never executed
        -:15962:                                      1, flocp);
    #####:15963:	  free (definition);
    #####:15964:	  freebuffer (&lb);
    #####:15965:	  return;
        -:15966:	}
        -:15967:      else
        -:15968:	{
    #####:15969:          len = strlen (lb.buffer);
        -:15970:	  /* Increase the buffer size if necessary.  */
    #####:15971:	  if (idx + len + 1 > length)
branch  0 never executed
branch  1 never executed
        -:15972:	    {
    #####:15973:	      length = (idx + len) * 2;
    #####:15974:	      definition = (char *) xrealloc (definition, length + 1);
call    0 never executed
        -:15975:	    }
        -:15976:
    #####:15977:	  bcopy (lb.buffer, &definition[idx], len);
    #####:15978:	  idx += len;
        -:15979:	  /* Separate lines with a newline.  */
    #####:15980:	  definition[idx++] = '\n';
        -:15981:	}
        -:15982:    }
        -:15983:
        -:15984:  /* No `endef'!!  */
    #####:15985:  fatal (flocp, _("missing `endef', unterminated `define'"));
call    0 never executed
        -:15986:
        -:15987:  /* NOTREACHED */
        -:15988:  return;
        -:15989:}
        -:15990:
        -:15991:/* Interpret conditional commands "ifdef", "ifndef", "ifeq",
        -:15992:   "ifneq", "else" and "endif".
        -:15993:   LINE is the input line, with the command as its first word.
        -:15994:
        -:15995:   FILENAME and LINENO are the filename and line number in the
        -:15996:   current makefile.  They are used for error messages.
        -:15997:
        -:15998:   Value is -1 if the line is invalid,
        -:15999:   0 if following text should be interpreted,
        -:16000:   1 if following text should be ignored.  */
        -:16001:
        -:16002:static int
function conditional_line called 0 returned 0% blocks executed 0%
    #####:16003:conditional_line (line, flocp)
        -:16004:     char *line;
        -:16005:     const struct floc *flocp;
        -:16006:{
        -:16007:  int notdef;
        -:16008:  char *cmdname;
        -:16009:  register unsigned int i;
        -:16010:
    #####:16011:  if (*line == 'i')
branch  0 never executed
branch  1 never executed
        -:16012:    {
        -:16013:      /* It's an "if..." command.  */
    #####:16014:      notdef = line[2] == 'n';
    #####:16015:      if (notdef)
branch  0 never executed
branch  1 never executed
        -:16016:	{
    #####:16017:	  cmdname = line[3] == 'd' ? "ifndef" : "ifneq";
branch  0 never executed
branch  1 never executed
    #####:16018:	  line += cmdname[3] == 'd' ? 7 : 6;
branch  0 never executed
branch  1 never executed
        -:16019:	}
        -:16020:      else
        -:16021:	{
    #####:16022:	  cmdname = line[2] == 'd' ? "ifdef" : "ifeq";
branch  0 never executed
branch  1 never executed
    #####:16023:	  line += cmdname[2] == 'd' ? 6 : 5;
branch  0 never executed
branch  1 never executed
        -:16024:	}
        -:16025:    }
        -:16026:  else
        -:16027:    {
        -:16028:      /* It's an "else" or "endif" command.  */
    #####:16029:      notdef = line[1] == 'n';
    #####:16030:      cmdname = notdef ? "endif" : "else";
branch  0 never executed
branch  1 never executed
    #####:16031:      line += notdef ? 5 : 4;
branch  0 never executed
branch  1 never executed
        -:16032:    }
        -:16033:
    #####:16034:  line = next_token (line);
call    0 never executed
        -:16035:
    #####:16036:  if (*cmdname == 'e')
branch  0 never executed
branch  1 never executed
        -:16037:    {
    #####:16038:      if (*line != '\0')
branch  0 never executed
branch  1 never executed
    #####:16039:	error (flocp, _("Extraneous text after `%s' directive"), cmdname);
call    0 never executed
        -:16040:      /* "Else" or "endif".  */
    #####:16041:      if (conditionals->if_cmds == 0)
branch  0 never executed
branch  1 never executed
    #####:16042:	fatal (flocp, _("extraneous `%s'"), cmdname);
call    0 never executed
        -:16043:      /* NOTDEF indicates an `endif' command.  */
    #####:16044:      if (notdef)
branch  0 never executed
branch  1 never executed
    #####:16045:	--conditionals->if_cmds;
    #####:16046:      else if (conditionals->seen_else[conditionals->if_cmds - 1])
branch  0 never executed
branch  1 never executed
    #####:16047:	fatal (flocp, _("only one `else' per conditional"));
call    0 never executed
        -:16048:      else
        -:16049:	{
        -:16050:	  /* Toggle the state of ignorance.  */
    #####:16051:	  conditionals->ignoring[conditionals->if_cmds - 1]
    #####:16052:	    = !conditionals->ignoring[conditionals->if_cmds - 1];
        -:16053:	  /* Record that we have seen an `else' in this conditional.
        -:16054:	     A second `else' will be erroneous.  */
    #####:16055:	  conditionals->seen_else[conditionals->if_cmds - 1] = 1;
        -:16056:	}
    #####:16057:      for (i = 0; i < conditionals->if_cmds; ++i)
branch  0 never executed
branch  1 never executed
    #####:16058:	if (conditionals->ignoring[i])
branch  0 never executed
branch  1 never executed
    #####:16059:	  return 1;
    #####:16060:      return 0;
        -:16061:    }
        -:16062:
    #####:16063:  if (conditionals->allocated == 0)
branch  0 never executed
branch  1 never executed
        -:16064:    {
    #####:16065:      conditionals->allocated = 5;
    #####:16066:      conditionals->ignoring = (char *) xmalloc (conditionals->allocated);
call    0 never executed
    #####:16067:      conditionals->seen_else = (char *) xmalloc (conditionals->allocated);
call    0 never executed
        -:16068:    }
        -:16069:
    #####:16070:  ++conditionals->if_cmds;
    #####:16071:  if (conditionals->if_cmds > conditionals->allocated)
branch  0 never executed
branch  1 never executed
        -:16072:    {
    #####:16073:      conditionals->allocated += 5;
    #####:16074:      conditionals->ignoring = (char *)
    #####:16075:	xrealloc (conditionals->ignoring, conditionals->allocated);
call    0 never executed
    #####:16076:      conditionals->seen_else = (char *)
    #####:16077:	xrealloc (conditionals->seen_else, conditionals->allocated);
call    0 never executed
        -:16078:    }
        -:16079:
        -:16080:  /* Record that we have seen an `if...' but no `else' so far.  */
    #####:16081:  conditionals->seen_else[conditionals->if_cmds - 1] = 0;
        -:16082:
        -:16083:  /* Search through the stack to see if we're already ignoring.  */
    #####:16084:  for (i = 0; i < conditionals->if_cmds - 1; ++i)
branch  0 never executed
branch  1 never executed
    #####:16085:    if (conditionals->ignoring[i])
branch  0 never executed
branch  1 never executed
        -:16086:      {
        -:16087:	/* We are already ignoring, so just push a level
        -:16088:	   to match the next "else" or "endif", and keep ignoring.
        -:16089:	   We don't want to expand variables in the condition.  */
    #####:16090:	conditionals->ignoring[conditionals->if_cmds - 1] = 1;
    #####:16091:	return 1;
        -:16092:      }
        -:16093:
    #####:16094:  if (cmdname[notdef ? 3 : 2] == 'd')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:16095:    {
        -:16096:      /* "Ifdef" or "ifndef".  */
        -:16097:      struct variable *v;
    #####:16098:      register char *p = end_of_token (line);
call    0 never executed
    #####:16099:      i = p - line;
    #####:16100:      p = next_token (p);
call    0 never executed
    #####:16101:      if (*p != '\0')
branch  0 never executed
branch  1 never executed
    #####:16102:	return -1;
    #####:16103:      v = lookup_variable (line, i);
call    0 never executed
    #####:16104:      conditionals->ignoring[conditionals->if_cmds - 1]
    #####:16105:	= (v != 0 && *v->value != '\0') == notdef;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:16106:    }
        -:16107:  else
        -:16108:    {
        -:16109:      /* "Ifeq" or "ifneq".  */
        -:16110:      char *s1, *s2;
        -:16111:      unsigned int len;
    #####:16112:      char termin = *line == '(' ? ',' : *line;
branch  0 never executed
branch  1 never executed
        -:16113:
    #####:16114:      if (termin != ',' && termin != '"' && termin != '\'')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:16115:	return -1;
        -:16116:
    #####:16117:      s1 = ++line;
        -:16118:      /* Find the end of the first string.  */
    #####:16119:      if (termin == ',')
branch  0 never executed
branch  1 never executed
        -:16120:	{
    #####:16121:	  register int count = 0;
    #####:16122:	  for (; *line != '\0'; ++line)
branch  0 never executed
branch  1 never executed
    #####:16123:	    if (*line == '(')
branch  0 never executed
branch  1 never executed
    #####:16124:	      ++count;
    #####:16125:	    else if (*line == ')')
branch  0 never executed
branch  1 never executed
    #####:16126:	      --count;
    #####:16127:	    else if (*line == ',' && count <= 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:16128:	      break;
        -:16129:	}
        -:16130:      else
    #####:16131:	while (*line != '\0' && *line != termin)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:16132:	  ++line;
        -:16133:
    #####:16134:      if (*line == '\0')
branch  0 never executed
branch  1 never executed
    #####:16135:	return -1;
        -:16136:
    #####:16137:      if (termin == ',')
branch  0 never executed
branch  1 never executed
        -:16138:	{
        -:16139:	  /* Strip blanks after the first string.  */
    #####:16140:	  char *p = line++;
    #####:16141:	  while (isblank (p[-1]))
branch  0 never executed
branch  1 never executed
    #####:16142:	    --p;
    #####:16143:	  *p = '\0';
        -:16144:	}
        -:16145:      else
    #####:16146:	*line++ = '\0';
        -:16147:
    #####:16148:      s2 = variable_expand (s1);
call    0 never executed
        -:16149:      /* We must allocate a new copy of the expanded string because
        -:16150:	 variable_expand re-uses the same buffer.  */
    #####:16151:      len = strlen (s2);
    #####:16152:      s1 = (char *) alloca (len + 1);
    #####:16153:      bcopy (s2, s1, len + 1);
        -:16154:
    #####:16155:      if (termin != ',')
branch  0 never executed
branch  1 never executed
        -:16156:	/* Find the start of the second string.  */
    #####:16157:	line = next_token (line);
call    0 never executed
        -:16158:
    #####:16159:      termin = termin == ',' ? ')' : *line;
branch  0 never executed
branch  1 never executed
    #####:16160:      if (termin != ')' && termin != '"' && termin != '\'')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:16161:	return -1;
        -:16162:
        -:16163:      /* Find the end of the second string.  */
    #####:16164:      if (termin == ')')
branch  0 never executed
branch  1 never executed
        -:16165:	{
    #####:16166:	  register int count = 0;
    #####:16167:	  s2 = next_token (line);
call    0 never executed
    #####:16168:	  for (line = s2; *line != '\0'; ++line)
branch  0 never executed
branch  1 never executed
        -:16169:	    {
    #####:16170:	      if (*line == '(')
branch  0 never executed
branch  1 never executed
    #####:16171:		++count;
    #####:16172:	      else if (*line == ')')
branch  0 never executed
branch  1 never executed
        -:16173:		{
    #####:16174:		  if (count <= 0)
branch  0 never executed
branch  1 never executed
    #####:16175:		    break;
        -:16176:		  else
    #####:16177:		    --count;
        -:16178:		}
        -:16179:	    }
        -:16180:	}
        -:16181:      else
        -:16182:	{
    #####:16183:	  ++line;
    #####:16184:	  s2 = line;
    #####:16185:	  while (*line != '\0' && *line != termin)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:16186:	    ++line;
        -:16187:	}
        -:16188:
    #####:16189:      if (*line == '\0')
branch  0 never executed
branch  1 never executed
    #####:16190:	return -1;
        -:16191:
    #####:16192:      *line = '\0';
    #####:16193:      line = next_token (++line);
call    0 never executed
    #####:16194:      if (*line != '\0')
branch  0 never executed
branch  1 never executed
    #####:16195:	error (flocp, _("Extraneous text after `%s' directive"), cmdname);
call    0 never executed
        -:16196:
    #####:16197:      s2 = variable_expand (s2);
call    0 never executed
    #####:16198:      conditionals->ignoring[conditionals->if_cmds - 1]
    #####:16199:	= streq (s1, s2) == notdef;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -:16200:    }
        -:16201:
        -:16202:  /* Search through the stack to see if we're ignoring.  */
    #####:16203:  for (i = 0; i < conditionals->if_cmds; ++i)
branch  0 never executed
branch  1 never executed
    #####:16204:    if (conditionals->ignoring[i])
branch  0 never executed
branch  1 never executed
    #####:16205:      return 1;
    #####:16206:  return 0;
        -:16207:}
        -:16208:
        -:16209:/* Remove duplicate dependencies in CHAIN.  */
        -:16210:
        -:16211:void
function uniquize_deps called 0 returned 0% blocks executed 0%
    #####:16212:uniquize_deps (chain)
        -:16213:     struct dep *chain;
        -:16214:{
        -:16215:  register struct dep *d;
        -:16216:
        -:16217:  /* Make sure that no dependencies are repeated.  This does not
        -:16218:     really matter for the purpose of updating targets, but it
        -:16219:     might make some names be listed twice for $^ and $?.  */
        -:16220:
    #####:16221:  for (d = chain; d != 0; d = d->next)
branch  0 never executed
branch  1 never executed
        -:16222:    {
        -:16223:      struct dep *last, *next;
        -:16224:
    #####:16225:      last = d;
    #####:16226:      next = d->next;
    #####:16227:      while (next != 0)
branch  0 never executed
branch  1 never executed
    #####:16228:	if (streq (dep_name (d), dep_name (next)))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
branch 21 never executed
    #####:16229:	  {
    #####:16230:	    struct dep *n = next->next;
    #####:16231:	    last->next = n;
    #####:16232:	    if (next->name != 0 && next->name != d->name)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:16233:	      free (next->name);
    #####:16234:	    if (next != d)
branch  0 never executed
branch  1 never executed
    #####:16235:	      free ((char *) next);
    #####:16236:	    next = n;
        -:16237:	  }
        -:16238:	else
        -:16239:	  {
    #####:16240:	    last = next;
    #####:16241:	    next = next->next;
        -:16242:	  }
        -:16243:    }
    #####:16244:}
        -:16245:
        -:16246:/* Record target-specific variable values for files FILENAMES.
        -:16247:   TWO_COLON is nonzero if a double colon was used.
        -:16248:
        -:16249:   The links of FILENAMES are freed, and so are any names in it
        -:16250:   that are not incorporated into other data structures.
        -:16251:
        -:16252:   If the target is a pattern, add the variable to the pattern-specific
        -:16253:   variable value list.  */
        -:16254:
        -:16255:static void
function record_target_var called 0 returned 0% blocks executed 0%
    #####:16256:record_target_var (filenames, defn, two_colon, origin, flocp)
        -:16257:     struct nameseq *filenames;
        -:16258:     char *defn;
        -:16259:     int two_colon;
        -:16260:     enum variable_origin origin;
        -:16261:     const struct floc *flocp;
        -:16262:{
        -:16263:  struct nameseq *nextf;
        -:16264:  struct variable_set_list *global;
        -:16265:
    #####:16266:  global = current_variable_set_list;
        -:16267:
        -:16268:  /* If the variable is an append version, store that but treat it as a
        -:16269:     normal recursive variable.  */
        -:16270:
    #####:16271:  for (; filenames != 0; filenames = nextf)
branch  0 never executed
branch  1 never executed
        -:16272:    {
        -:16273:      struct variable *v;
    #####:16274:      register char *name = filenames->name;
        -:16275:      struct variable_set_list *vlist;
        -:16276:      char *fname;
        -:16277:      char *percent;
        -:16278:
    #####:16279:      nextf = filenames->next;
    #####:16280:      free ((char *) filenames);
        -:16281:
        -:16282:      /* If it's a pattern target, then add it to the pattern-specific
        -:16283:         variable list.  */
    #####:16284:      percent = find_percent (name);
call    0 never executed
    #####:16285:      if (percent)
branch  0 never executed
branch  1 never executed
        -:16286:        {
        -:16287:          struct pattern_var *p;
        -:16288:
        -:16289:          /* Get a reference for this pattern-specific variable struct.  */
    #####:16290:          p = create_pattern_var(name, percent);
call    0 never executed
    #####:16291:          vlist = p->vars;
    #####:16292:          fname = p->target;
        -:16293:        }
        -:16294:      else
        -:16295:        {
        -:16296:          struct file *f;
        -:16297:
        -:16298:          /* Get a file reference for this file, and initialize it.  */
    #####:16299:          f = enter_file (name);
call    0 never executed
    #####:16300:          initialize_file_variables (f, 1);
call    0 never executed
    #####:16301:          vlist = f->variables;
    #####:16302:          fname = f->name;
        -:16303:        }
        -:16304:
        -:16305:      /* Make the new variable context current and define the variable.  */
    #####:16306:      current_variable_set_list = vlist;
    #####:16307:      v = try_variable_definition (flocp, defn, origin, 1);
call    0 never executed
    #####:16308:      if (!v)
branch  0 never executed
branch  1 never executed
    #####:16309:        error (flocp, _("Malformed per-target variable definition"));
call    0 never executed
    #####:16310:      v->per_target = 1;
        -:16311:
        -:16312:      /* If it's not an override, check to see if there was a command-line
        -:16313:         setting.  If so, reset the value.  */
    #####:16314:      if (origin != o_override)
branch  0 never executed
branch  1 never executed
        -:16315:        {
        -:16316:          struct variable *gv;
    #####:16317:          int len = strlen(v->name);
        -:16318:
    #####:16319:          current_variable_set_list = global;
    #####:16320:          gv = lookup_variable (v->name, len);
call    0 never executed
    #####:16321:          if (gv && (gv->origin == o_env_override || gv->origin == o_command))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:16322:            define_variable_in_set (v->name, len, gv->value, gv->origin,
    #####:16323:                                    gv->recursive, vlist->set, flocp);
call    0 never executed
        -:16324:        }
        -:16325:
        -:16326:      /* Free name if not needed further.  */
    #####:16327:      if (name != fname && (name < fname || name > fname + strlen (fname)))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:16328:        free (name);
        -:16329:    }
        -:16330:
    #####:16331:  current_variable_set_list = global;
    #####:16332:}
        -:16333:
        -:16334:/* Record a description line for files FILENAMES,
        -:16335:   with dependencies DEPS, commands to execute described
        -:16336:   by COMMANDS and COMMANDS_IDX, coming from FILENAME:COMMANDS_STARTED.
        -:16337:   TWO_COLON is nonzero if a double colon was used.
        -:16338:   If not nil, PATTERN is the `%' pattern to make this
        -:16339:   a static pattern rule, and PATTERN_PERCENT is a pointer
        -:16340:   to the `%' within it.
        -:16341:
        -:16342:   The links of FILENAMES are freed, and so are any names in it
        -:16343:   that are not incorporated into other data structures.  */
        -:16344:
        -:16345:static void
function record_files called 0 returned 0% blocks executed 0%
    #####:16346:record_files (filenames, pattern, pattern_percent, deps, cmds_started,
        -:16347:	      commands, commands_idx, two_colon, flocp, set_default)
        -:16348:     struct nameseq *filenames;
        -:16349:     char *pattern, *pattern_percent;
        -:16350:     struct dep *deps;
        -:16351:     unsigned int cmds_started;
        -:16352:     char *commands;
        -:16353:     unsigned int commands_idx;
        -:16354:     int two_colon;
        -:16355:     const struct floc *flocp;
        -:16356:     int set_default;
        -:16357:{
        -:16358:  struct nameseq *nextf;
    #####:16359:  int implicit = 0;
    #####:16360:  unsigned int max_targets = 0, target_idx = 0;
    #####:16361:  char **targets = 0, **target_percents = 0;
        -:16362:  struct commands *cmds;
        -:16363:
    #####:16364:  if (commands_idx > 0)
branch  0 never executed
branch  1 never executed
        -:16365:    {
    #####:16366:      cmds = (struct commands *) xmalloc (sizeof (struct commands));
call    0 never executed
    #####:16367:      cmds->fileinfo.filenm = flocp->filenm;
    #####:16368:      cmds->fileinfo.lineno = cmds_started;
    #####:16369:      cmds->commands = savestring (commands, commands_idx);
call    0 never executed
    #####:16370:      cmds->command_lines = 0;
        -:16371:    }
        -:16372:  else
    #####:16373:    cmds = 0;
        -:16374:
    #####:16375:  for (; filenames != 0; filenames = nextf)
branch  0 never executed
branch  1 never executed
        -:16376:    {
        -:16377:
    #####:16378:      register char *name = filenames->name;
        -:16379:      register struct file *f;
        -:16380:      register struct dep *d;
        -:16381:      struct dep *this;
        -:16382:      char *implicit_percent;
        -:16383:
    #####:16384:      nextf = filenames->next;
    #####:16385:      free (filenames);
        -:16386:
    #####:16387:      implicit_percent = find_percent (name);
call    0 never executed
    #####:16388:      implicit |= implicit_percent != 0;
        -:16389:
    #####:16390:      if (implicit && pattern != 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:16391:	fatal (flocp, _("mixed implicit and static pattern rules"));
call    0 never executed
        -:16392:
    #####:16393:      if (implicit && implicit_percent == 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:16394:	fatal (flocp, _("mixed implicit and normal rules"));
call    0 never executed
        -:16395:
    #####:16396:      if (implicit)
branch  0 never executed
branch  1 never executed
        -:16397:	{
    #####:16398:	  if (targets == 0)
branch  0 never executed
branch  1 never executed
        -:16399:	    {
    #####:16400:	      max_targets = 5;
    #####:16401:	      targets = (char **) xmalloc (5 * sizeof (char *));
call    0 never executed
    #####:16402:	      target_percents = (char **) xmalloc (5 * sizeof (char *));
call    0 never executed
    #####:16403:	      target_idx = 0;
        -:16404:	    }
    #####:16405:	  else if (target_idx == max_targets - 1)
branch  0 never executed
branch  1 never executed
        -:16406:	    {
    #####:16407:	      max_targets += 5;
    #####:16408:	      targets = (char **) xrealloc ((char *) targets,
call    0 never executed
        -:16409:					    max_targets * sizeof (char *));
        -:16410:	      target_percents
    #####:16411:		= (char **) xrealloc ((char *) target_percents,
call    0 never executed
        -:16412:				      max_targets * sizeof (char *));
        -:16413:	    }
    #####:16414:	  targets[target_idx] = name;
    #####:16415:	  target_percents[target_idx] = implicit_percent;
    #####:16416:	  ++target_idx;
    #####:16417:	  continue;
        -:16418:	}
        -:16419:
        -:16420:      /* If there are multiple filenames, copy the chain DEPS
        -:16421:	 for all but the last one.  It is not safe for the same deps
        -:16422:	 to go in more than one place in the data base.  */
    #####:16423:      this = nextf != 0 ? copy_dep_chain (deps) : deps;
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:16424:
    #####:16425:      if (pattern != 0)
branch  0 never executed
branch  1 never executed
        -:16426:	{
        -:16427:	  /* If this is an extended static rule:
        -:16428:	     `targets: target%pattern: dep%pattern; cmds',
        -:16429:	     translate each dependency pattern into a plain filename
        -:16430:	     using the target pattern and this target's name.  */
    #####:16431:	  if (!pattern_matches (pattern, pattern_percent, name))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:16432:	    {
        -:16433:	      /* Give a warning if the rule is meaningless.  */
    #####:16434:	      error (flocp,
    #####:16435:		     _("target `%s' doesn't match the target pattern"), name);
call    0 never executed
    #####:16436:	      this = 0;
        -:16437:	    }
        -:16438:	  else
        -:16439:	    {
        -:16440:	      /* We use patsubst_expand to do the work of translating
        -:16441:		 the target pattern, the target's name and the dependencies'
        -:16442:		 patterns into plain dependency names.  */
    #####:16443:	      char *buffer = variable_expand ("");
call    0 never executed
        -:16444:
    #####:16445:	      for (d = this; d != 0; d = d->next)
branch  0 never executed
branch  1 never executed
        -:16446:		{
        -:16447:		  char *o;
    #####:16448:		  char *percent = find_percent (d->name);
call    0 never executed
    #####:16449:		  if (percent == 0)
branch  0 never executed
branch  1 never executed
    #####:16450:		    continue;
    #####:16451:		  o = patsubst_expand (buffer, name, pattern, d->name,
call    0 never executed
        -:16452:				       pattern_percent, percent);
        -:16453:                  /* If the name expanded to the empty string, that's
        -:16454:                     illegal.  */
    #####:16455:                  if (o == buffer)
branch  0 never executed
branch  1 never executed
    #####:16456:                    fatal (flocp,
    #####:16457:                           _("target `%s' leaves prerequisite pattern empty"),
call    0 never executed
        -:16458:                           name);
    #####:16459:		  free (d->name);
    #####:16460:		  d->name = savestring (buffer, o - buffer);
call    0 never executed
        -:16461:		}
        -:16462:	    }
        -:16463:	}
        -:16464:
    #####:16465:      if (!two_colon)
branch  0 never executed
branch  1 never executed
        -:16466:	{
        -:16467:	  /* Single-colon.  Combine these dependencies
        -:16468:	     with others in file's existing record, if any.  */
    #####:16469:	  f = enter_file (name);
call    0 never executed
        -:16470:
    #####:16471:	  if (f->double_colon)
branch  0 never executed
branch  1 never executed
    #####:16472:	    fatal (flocp,
    #####:16473:                   _("target file `%s' has both : and :: entries"), f->name);
call    0 never executed
        -:16474:
        -:16475:	  /* If CMDS == F->CMDS, this target was listed in this rule
        -:16476:	     more than once.  Just give a warning since this is harmless.  */
    #####:16477:	  if (cmds != 0 && cmds == f->cmds)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:16478:	    error (flocp,
    #####:16479:                   _("target `%s' given more than once in the same rule."),
call    0 never executed
        -:16480:                   f->name);
        -:16481:
        -:16482:	  /* Check for two single-colon entries both with commands.
        -:16483:	     Check is_target so that we don't lose on files such as .c.o
        -:16484:	     whose commands were preinitialized.  */
    #####:16485:	  else if (cmds != 0 && f->cmds != 0 && f->is_target)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:16486:	    {
    #####:16487:	      error (&cmds->fileinfo,
    #####:16488:                     _("warning: overriding commands for target `%s'"),
call    0 never executed
        -:16489:                     f->name);
    #####:16490:	      error (&f->cmds->fileinfo,
    #####:16491:                     _("warning: ignoring old commands for target `%s'"),
call    0 never executed
        -:16492:                     f->name);
        -:16493:	    }
        -:16494:
    #####:16495:	  f->is_target = 1;
        -:16496:
        -:16497:	  /* Defining .DEFAULT with no deps or cmds clears it.  */
    #####:16498:	  if (f == default_file && this == 0 && cmds == 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:16499:	    f->cmds = 0;
    #####:16500:	  if (cmds != 0)
branch  0 never executed
branch  1 never executed
    #####:16501:	    f->cmds = cmds;
        -:16502:	  /* Defining .SUFFIXES with no dependencies
        -:16503:	     clears out the list of suffixes.  */
    #####:16504:	  if (f == suffix_file && this == 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:16505:	    {
    #####:16506:	      d = f->deps;
    #####:16507:	      while (d != 0)
branch  0 never executed
branch  1 never executed
        -:16508:		{
    #####:16509:		  struct dep *nextd = d->next;
    #####:16510: 		  free (d->name);
    #####:16511: 		  free ((char *)d);
    #####:16512:		  d = nextd;
        -:16513:		}
    #####:16514:	      f->deps = 0;
        -:16515:	    }
    #####:16516:	  else if (f->deps != 0)
branch  0 never executed
branch  1 never executed
        -:16517:	    {
        -:16518:	      /* Add the file's old deps and the new ones in THIS together.  */
        -:16519:
        -:16520:	      struct dep *firstdeps, *moredeps;
    #####:16521:	      if (cmds != 0)
branch  0 never executed
branch  1 never executed
        -:16522:		{
        -:16523:		  /* This is the rule with commands, so put its deps first.
        -:16524:		     The rationale behind this is that $< expands to the
        -:16525:		     first dep in the chain, and commands use $< expecting
        -:16526:		     to get the dep that rule specifies.  */
    #####:16527:		  firstdeps = this;
    #####:16528:		  moredeps = f->deps;
        -:16529:		}
        -:16530:	      else
        -:16531:		{
        -:16532:		  /* Append the new deps to the old ones.  */
    #####:16533:		  firstdeps = f->deps;
    #####:16534:		  moredeps = this;
        -:16535:		}
        -:16536:
    #####:16537:	      if (firstdeps == 0)
branch  0 never executed
branch  1 never executed
    #####:16538:		firstdeps = moredeps;
        -:16539:	      else
        -:16540:		{
    #####:16541:		  d = firstdeps;
    #####:16542:		  while (d->next != 0)
branch  0 never executed
branch  1 never executed
    #####:16543:		    d = d->next;
    #####:16544:		  d->next = moredeps;
        -:16545:		}
        -:16546:
    #####:16547:	      f->deps = firstdeps;
        -:16548:	    }
        -:16549:	  else
    #####:16550:	    f->deps = this;
        -:16551:
        -:16552:	  /* If this is a static pattern rule, set the file's stem to
        -:16553:	     the part of its name that matched the `%' in the pattern,
        -:16554:	     so you can use $* in the commands.  */
    #####:16555:	  if (pattern != 0)
branch  0 never executed
branch  1 never executed
        -:16556:	    {
        -:16557:	      static char *percent = "%";
    #####:16558:	      char *buffer = variable_expand ("");
call    0 never executed
    #####:16559:	      char *o = patsubst_expand (buffer, name, pattern, percent,
call    0 never executed
        -:16560:					 pattern_percent, percent);
    #####:16561:	      f->stem = savestring (buffer, o - buffer);
call    0 never executed
        -:16562:	    }
        -:16563:	}
        -:16564:      else
        -:16565:	{
        -:16566:	  /* Double-colon.  Make a new record
        -:16567:	     even if the file already has one.  */
    #####:16568:	  f = lookup_file (name);
call    0 never executed
        -:16569:	  /* Check for both : and :: rules.  Check is_target so
        -:16570:	     we don't lose on default suffix rules or makefiles.  */
    #####:16571:	  if (f != 0 && f->is_target && !f->double_colon)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:16572:	    fatal (flocp,
    #####:16573:                   _("target file `%s' has both : and :: entries"), f->name);
call    0 never executed
    #####:16574:	  f = enter_file (name);
call    0 never executed
        -:16575:	  /* If there was an existing entry and it was a double-colon
        -:16576:	     entry, enter_file will have returned a new one, making it the
        -:16577:	     prev pointer of the old one, and setting its double_colon
        -:16578:	     pointer to the first one.  */
    #####:16579:	  if (f->double_colon == 0)
branch  0 never executed
branch  1 never executed
        -:16580:	    /* This is the first entry for this name, so we must
        -:16581:	       set its double_colon pointer to itself.  */
    #####:16582:	    f->double_colon = f;
    #####:16583:	  f->is_target = 1;
    #####:16584:	  f->deps = this;
    #####:16585:	  f->cmds = cmds;
        -:16586:	}
        -:16587:
        -:16588:      /* Free name if not needed further.  */
    #####:16589:      if (f != 0 && name != f->name
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:16590:	  && (name < f->name || name > f->name + strlen (f->name)))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:16591:	{
    #####:16592:	  free (name);
    #####:16593:	  name = f->name;
        -:16594:	}
        -:16595:
        -:16596:      /* See if this is first target seen whose name does
        -:16597:	 not start with a `.', unless it contains a slash.  */
    #####:16598:      if (default_goal_file == 0 && set_default
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:16599:	  && (*name != '.' || strchr (name, '/') != 0
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:16600:#if defined(__MSDOS__) || defined(WINDOWS32)
        -:16601:			   || strchr (name, '\\') != 0
        -:16602:#endif
        -:16603:	      ))
        -:16604:	{
    #####:16605:	  int reject = 0;
        -:16606:
        -:16607:	  /* If this file is a suffix, don't
        -:16608:	     let it be the default goal file.  */
        -:16609:
    #####:16610:	  for (d = suffix_file->deps; d != 0; d = d->next)
branch  0 never executed
branch  1 never executed
        -:16611:	    {
        -:16612:	      register struct dep *d2;
    #####:16613:	      if (*dep_name (d) != '.' && streq (name, dep_name (d)))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
        -:16614:		{
    #####:16615:		  reject = 1;
    #####:16616:		  break;
        -:16617:		}
    #####:16618:	      for (d2 = suffix_file->deps; d2 != 0; d2 = d2->next)
branch  0 never executed
branch  1 never executed
        -:16619:		{
    #####:16620:		  register unsigned int len = strlen (dep_name (d2));
branch  0 never executed
branch  1 never executed
    #####:16621:		  if (!strneq (name, dep_name (d2), len))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:16622:		    continue;
    #####:16623:		  if (streq (name + len, dep_name (d)))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
        -:16624:		    {
    #####:16625:		      reject = 1;
    #####:16626:		      break;
        -:16627:		    }
        -:16628:		}
    #####:16629:	      if (reject)
branch  0 never executed
branch  1 never executed
    #####:16630:		break;
        -:16631:	    }
        -:16632:
    #####:16633:	  if (!reject)
branch  0 never executed
branch  1 never executed
    #####:16634:	    default_goal_file = f;
        -:16635:	}
        -:16636:    }
        -:16637:
    #####:16638:  if (implicit)
branch  0 never executed
branch  1 never executed
        -:16639:    {
    #####:16640:      targets[target_idx] = 0;
    #####:16641:      target_percents[target_idx] = 0;
    #####:16642:      create_pattern_rule (targets, target_percents, two_colon, deps, cmds, 1);
call    0 never executed
    #####:16643:      free ((char *) target_percents);
        -:16644:    }
    #####:16645:}
        -:16646:
        -:16647:/* Search STRING for an unquoted STOPCHAR or blank (if BLANK is nonzero).
        -:16648:   Backslashes quote STOPCHAR, blanks if BLANK is nonzero, and backslash.
        -:16649:   Quoting backslashes are removed from STRING by compacting it into
        -:16650:   itself.  Returns a pointer to the first unquoted STOPCHAR if there is
        -:16651:   one, or nil if there are none.  */
        -:16652:
        -:16653:char *
function find_char_unquote called 52 returned 100% blocks executed 58%
       52:16654:find_char_unquote (string, stopchars, blank)
        -:16655:     char *string;
        -:16656:     char *stopchars;
        -:16657:     int blank;
        -:16658:{
       52:16659:  unsigned int string_len = 0;
       52:16660:  register char *p = string;
        -:16661:
        -:16662:  while (1)
        -:16663:    {
     241*:16664:      while (*p != '\0' && strchr (stopchars, *p) == 0
branch  0 taken 180 (fallthrough)
branch  1 taken 9
      379:16665:	     && (!blank || !isblank (*p)))
branch  0 taken 189 (fallthrough)
branch  1 taken 10
branch  2 taken 1
branch  3 taken 179 (fallthrough)
branch  4 taken 146
branch  5 taken 33 (fallthrough)
      147:16666:	++p;
       52:16667:      if (*p == '\0')
branch  0 taken 10 (fallthrough)
branch  1 taken 42
       10:16668:	break;
        -:16669:
       42:16670:      if (p > string && p[-1] == '\\')
branch  0 taken 34 (fallthrough)
branch  1 taken 8
branch  2 taken 0 (fallthrough)
branch  3 taken 34
    #####:16671:	{
        -:16672:	  /* Search for more backslashes.  */
    #####:16673:	  register int i = -2;
    #####:16674:	  while (&p[i] >= string && p[i] == '\\')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:16675:	    --i;
    #####:16676:	  ++i;
        -:16677:	  /* Only compute the length if really needed.  */
    #####:16678:	  if (string_len == 0)
branch  0 never executed
branch  1 never executed
    #####:16679:	    string_len = strlen (string);
        -:16680:	  /* The number of backslashes is now -I.
        -:16681:	     Copy P over itself to swallow half of them.  */
    #####:16682:	  bcopy (&p[i / 2], &p[i], (string_len - (p - string)) - (i / 2) + 1);
    #####:16683:	  p += i / 2;
    #####:16684:	  if (i % 2 == 0)
branch  0 never executed
branch  1 never executed
        -:16685:	    /* All the backslashes quoted each other; the STOPCHAR was
        -:16686:	       unquoted.  */
    #####:16687:	    return p;
        -:16688:
        -:16689:	  /* The STOPCHAR was quoted by a backslash.  Look for another.  */
        -:16690:	}
        -:16691:      else
        -:16692:	/* No backslash in sight.  */
       42:16693:	return p;
        -:16694:    }
        -:16695:
        -:16696:  /* Never hit a STOPCHAR or blank (with BLANK nonzero).  */
       10:16697:  return 0;
        -:16698:}
        -:16699:
        -:16700:/* Search PATTERN for an unquoted %.  */
        -:16701:
        -:16702:char *
function find_percent called 9 returned 100% blocks executed 100%
        9:16703:find_percent (pattern)
        -:16704:     char *pattern;
        -:16705:{
        9:16706:  return find_char_unquote (pattern, "%", 0);
call    0 returned 9
        -:16707:}
        -:16708:
        -:16709:/* Parse a string into a sequence of filenames represented as a
        -:16710:   chain of struct nameseq's in reverse order and return that chain.
        -:16711:
        -:16712:   The string is passed as STRINGP, the address of a string pointer.
        -:16713:   The string pointer is updated to point at the first character
        -:16714:   not parsed, which either is a null char or equals STOPCHAR.
        -:16715:
        -:16716:   SIZE is how big to construct chain elements.
        -:16717:   This is useful if we want them actually to be other structures
        -:16718:   that have room for additional info.
        -:16719:
        -:16720:   If STRIP is nonzero, strip `./'s off the beginning.  */
        -:16721:
        -:16722:struct nameseq *
function parse_file_seq called 10 returned 100% blocks executed 44%
       10:16723:parse_file_seq (stringp, stopchar, size, strip)
        -:16724:     char **stringp;
        -:16725:     int stopchar;
        -:16726:     unsigned int size;
        -:16727:     int strip;
        -:16728:{
       10:16729:  register struct nameseq *new = 0;
        -:16730:  register struct nameseq *new1, *lastnew1;
       10:16731:  register char *p = *stringp;
        -:16732:  char *q;
        -:16733:  char *name;
        -:16734:  char stopchars[3];
        -:16735:
        -:16736:#ifdef VMS
        -:16737:  stopchars[0] = ',';
        -:16738:  stopchars[1] = stopchar;
        -:16739:  stopchars[2] = '\0';
        -:16740:#else
       10:16741:  stopchars[0] = stopchar;
       10:16742:  stopchars[1] = '\0';
        -:16743:#endif
        -:16744:
        -:16745:  while (1)
        -:16746:    {
        -:16747:      /* Skip whitespace; see if any more names are left.  */
       53:16748:      p = next_token (p);
call    0 returned 53
       53:16749:      if (*p == '\0')
branch  0 taken 10 (fallthrough)
branch  1 taken 43
       10:16750:	break;
       43:16751:      if (*p == stopchar)
branch  0 taken 0 (fallthrough)
branch  1 taken 43
    #####:16752:	break;
        -:16753:
        -:16754:      /* Yes, find end of next name.  */
       43:16755:      q = p;
       43:16756:      p = find_char_unquote (q, stopchars, 1);
call    0 returned 43
        -:16757:#ifdef VMS
        -:16758:	/* convert comma separated list to space separated */
        -:16759:      if (p && *p == ',')
        -:16760:	*p =' ';
        -:16761:#endif
        -:16762:#ifdef _AMIGA
        -:16763:      if (stopchar == ':' && p && *p == ':'
        -:16764:          && !(isspace ((unsigned char)p[1]) || !p[1]
        -:16765:               || isspace ((unsigned char)p[-1])))
        -:16766:      {
        -:16767:	p = find_char_unquote (p+1, stopchars, 1);
        -:16768:      }
        -:16769:#endif
        -:16770:#if defined(WINDOWS32) || defined(__MSDOS__)
        -:16771:    /* For WINDOWS32, skip a "C:\..." or a "C:/..." until we find the
        -:16772:       first colon which isn't followed by a slash or a backslash.
        -:16773:       Note that tokens separated by spaces should be treated as separate
        -:16774:       tokens since make doesn't allow path names with spaces */
        -:16775:    if (stopchar == ':')
        -:16776:      while (p != 0 && !isspace ((unsigned char)*p) &&
        -:16777:             (p[1] == '\\' || p[1] == '/') && isalpha ((unsigned char)p[-1]))
        -:16778:        p = find_char_unquote (p + 1, stopchars, 1);
        -:16779:#endif
       43:16780:      if (p == 0)
branch  0 taken 10 (fallthrough)
branch  1 taken 33
       10:16781:	p = q + strlen (q);
        -:16782:
       43:16783:      if (strip)
branch  0 taken 43 (fallthrough)
branch  1 taken 0
        -:16784:#ifdef VMS
        -:16785:	/* Skip leading `[]'s.  */
        -:16786:	while (p - q > 2 && q[0] == '[' && q[1] == ']')
        -:16787:#else
        -:16788:	/* Skip leading `./'s.  */
       43:16789:	while (p - q > 2 && q[0] == '.' && q[1] == '/')
branch  0 taken 27 (fallthrough)
branch  1 taken 16
branch  2 taken 18 (fallthrough)
branch  3 taken 9
branch  4 taken 0
branch  5 taken 18 (fallthrough)
        -:16790:#endif
        -:16791:	  {
    #####:16792:	    q += 2;		/* Skip "./".  */
    #####:16793:	    while (q < p && *q == '/')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:16794:	      /* Skip following slashes: ".//foo" is "foo", not "/foo".  */
    #####:16795:	      ++q;
        -:16796:	  }
        -:16797:
        -:16798:      /* Extract the filename just found, and skip it.  */
        -:16799:
       43:16800:      if (q == p)
branch  0 taken 0 (fallthrough)
branch  1 taken 43
        -:16801:	/* ".///" was stripped to "". */
        -:16802:#ifdef VMS
        -:16803:	continue;
        -:16804:#else
        -:16805:#ifdef _AMIGA
        -:16806:	name = savestring ("", 0);
        -:16807:#else
    #####:16808:	name = savestring ("./", 2);
call    0 never executed
        -:16809:#endif
        -:16810:#endif
        -:16811:      else
        -:16812:#ifdef VMS
        -:16813:/* VMS filenames can have a ':' in them but they have to be '\'ed but we need
        -:16814: *  to remove this '\' before we can use the filename.
        -:16815: * Savestring called because q may be read-only string constant.
        -:16816: */
        -:16817:	{
        -:16818:	  char *qbase = xstrdup (q);
        -:16819:	  char *pbase = qbase + (p-q);
        -:16820:	  char *q1 = qbase;
        -:16821:	  char *q2 = q1;
        -:16822:	  char *p1 = pbase;
        -:16823:
        -:16824:	  while (q1 != pbase)
        -:16825:	    {
        -:16826:	      if (*q1 == '\\' && *(q1+1) == ':')
        -:16827:		{
        -:16828:		  q1++;
        -:16829:		  p1--;
        -:16830:		}
        -:16831:	      *q2++ = *q1++;
        -:16832:	    }
        -:16833:	  name = savestring (qbase, p1 - qbase);
        -:16834:	  free (qbase);
        -:16835:	}
        -:16836:#else
       43:16837:	name = savestring (q, p - q);
call    0 returned 43
        -:16838:#endif
        -:16839:
        -:16840:      /* Add it to the front of the chain.  */
       43:16841:      new1 = (struct nameseq *) xmalloc (size);
call    0 returned 43
       43:16842:      new1->name = name;
       43:16843:      new1->next = new;
       43:16844:      new = new1;
        -:16845:    }
        -:16846:
        -:16847:#ifndef NO_ARCHIVES
        -:16848:
        -:16849:  /* Look for multi-word archive references.
        -:16850:     They are indicated by a elt ending with an unmatched `)' and
        -:16851:     an elt further down the chain (i.e., previous in the file list)
        -:16852:     with an unmatched `(' (e.g., "lib(mem").  */
        -:16853:
       10:16854:  new1 = new;
       10:16855:  lastnew1 = 0;
       53:16856:  while (new1 != 0)
branch  0 taken 43
branch  1 taken 10 (fallthrough)
       43:16857:    if (new1->name[0] != '('	/* Don't catch "(%)" and suchlike.  */
branch  0 taken 43 (fallthrough)
branch  1 taken 0
       43:16858:	&& new1->name[strlen (new1->name) - 1] == ')'
branch  0 taken 0 (fallthrough)
branch  1 taken 43
    #####:16859:	&& strchr (new1->name, '(') == 0)
branch  0 never executed
branch  1 never executed
    #####:16860:      {
        -:16861:	/* NEW1 ends with a `)' but does not contain a `('.
        -:16862:	   Look back for an elt with an opening `(' but no closing `)'.  */
        -:16863:
    #####:16864:	struct nameseq *n = new1->next, *lastn = new1;
    #####:16865:	char *paren = 0;
    #####:16866:	while (n != 0 && (paren = strchr (n->name, '(')) == 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:16867:	  {
    #####:16868:	    lastn = n;
    #####:16869:	    n = n->next;
        -:16870:	  }
    #####:16871:	if (n != 0
branch  0 never executed
branch  1 never executed
        -:16872:	    /* Ignore something starting with `(', as that cannot actually
        -:16873:	       be an archive-member reference (and treating it as such
        -:16874:	       results in an empty file name, which causes much lossage).  */
    #####:16875:	    && n->name[0] != '(')
branch  0 never executed
branch  1 never executed
    #####:16876:	  {
        -:16877:	    /* N is the first element in the archive group.
        -:16878:	       Its name looks like "lib(mem" (with no closing `)').  */
        -:16879:
        -:16880:	    char *libname;
        -:16881:
        -:16882:	    /* Copy "lib(" into LIBNAME.  */
    #####:16883:	    ++paren;
    #####:16884:	    libname = (char *) alloca (paren - n->name + 1);
    #####:16885:	    bcopy (n->name, libname, paren - n->name);
    #####:16886:	    libname[paren - n->name] = '\0';
        -:16887:
    #####:16888:	    if (*paren == '\0')
branch  0 never executed
branch  1 never executed
        -:16889:	      {
        -:16890:		/* N was just "lib(", part of something like "lib( a b)".
        -:16891:		   Edit it out of the chain and free its storage.  */
    #####:16892:		lastn->next = n->next;
    #####:16893:		free (n->name);
    #####:16894:		free ((char *) n);
        -:16895:		/* LASTN->next is the new stopping elt for the loop below.  */
    #####:16896:		n = lastn->next;
        -:16897:	      }
        -:16898:	    else
        -:16899:	      {
        -:16900:		/* Replace N's name with the full archive reference.  */
    #####:16901:		name = concat (libname, paren, ")");
call    0 never executed
    #####:16902:		free (n->name);
    #####:16903:		n->name = name;
        -:16904:	      }
        -:16905:
    #####:16906:	    if (new1->name[1] == '\0')
branch  0 never executed
branch  1 never executed
        -:16907:	      {
        -:16908:		/* NEW1 is just ")", part of something like "lib(a b )".
        -:16909:		   Omit it from the chain and free its storage.  */
    #####:16910:		if (lastnew1 == 0)
branch  0 never executed
branch  1 never executed
    #####:16911:		  new = new1->next;
        -:16912:		else
    #####:16913:		  lastnew1->next = new1->next;
    #####:16914:		lastn = new1;
    #####:16915:		new1 = new1->next;
    #####:16916:		free (lastn->name);
    #####:16917:		free ((char *) lastn);
        -:16918:	      }
        -:16919:	    else
        -:16920:	      {
        -:16921:		/* Replace also NEW1->name, which already has closing `)'.  */
    #####:16922:		name = concat (libname, new1->name, "");
call    0 never executed
    #####:16923:		free (new1->name);
    #####:16924:		new1->name = name;
    #####:16925:		new1 = new1->next;
        -:16926:	      }
        -:16927:
        -:16928:	    /* Trace back from NEW1 (the end of the list) until N
        -:16929:	       (the beginning of the list), rewriting each name
        -:16930:	       with the full archive reference.  */
        -:16931:
    #####:16932:	    while (new1 != n)
branch  0 never executed
branch  1 never executed
        -:16933:	      {
    #####:16934:		name = concat (libname, new1->name, ")");
call    0 never executed
    #####:16935:		free (new1->name);
    #####:16936:		new1->name = name;
    #####:16937:		lastnew1 = new1;
    #####:16938:		new1 = new1->next;
        -:16939:	      }
        -:16940:	  }
        -:16941:	else
        -:16942:	  {
        -:16943:	    /* No frobnication happening.  Just step down the list.  */
    #####:16944:	    lastnew1 = new1;
    #####:16945:	    new1 = new1->next;
        -:16946:	  }
        -:16947:      }
        -:16948:    else
        -:16949:      {
       43:16950:	lastnew1 = new1;
       43:16951:	new1 = new1->next;
        -:16952:      }
        -:16953:
        -:16954:#endif
        -:16955:
       10:16956:  *stringp = p;
       10:16957:  return new;
        -:16958:}
        -:16959:
        -:16960:/* Read a line of text from STREAM into LINEBUFFER.
        -:16961:   Combine continuation lines into one line.
        -:16962:   Return the number of actual lines read (> 1 if hacked continuation lines).
        -:16963: */
        -:16964:
        -:16965:static unsigned long
function readline called 0 returned 0% blocks executed 0%
    #####:16966:readline (linebuffer, stream, flocp)
        -:16967:     struct linebuffer *linebuffer;
        -:16968:     FILE *stream;
        -:16969:     const struct floc *flocp;
        -:16970:{
    #####:16971:  char *buffer = linebuffer->buffer;
    #####:16972:  register char *p = linebuffer->buffer;
    #####:16973:  register char *end = p + linebuffer->size;
    #####:16974:  register int len, lastlen = 0;
        -:16975:  register char *p2;
    #####:16976:  register unsigned int nlines = 0;
        -:16977:  register int backslash;
        -:16978:
    #####:16979:  *p = '\0';
        -:16980:
    #####:16981:  while (fgets (p, end - p, stream) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:16982:    {
    #####:16983:      len = strlen (p);
    #####:16984:      if (len == 0)
branch  0 never executed
branch  1 never executed
        -:16985:	{
        -:16986:	  /* This only happens when the first thing on the line is a '\0'.
        -:16987:	     It is a pretty hopeless case, but (wonder of wonders) Athena
        -:16988:	     lossage strikes again!  (xmkmf puts NULs in its makefiles.)
        -:16989:	     There is nothing really to be done; we synthesize a newline so
        -:16990:	     the following line doesn't appear to be part of this line.  */
    #####:16991:	  error (flocp, _("warning: NUL character seen; rest of line ignored"));
call    0 never executed
    #####:16992:	  p[0] = '\n';
    #####:16993:	  len = 1;
        -:16994:	}
        -:16995:
    #####:16996:      p += len;
    #####:16997:      if (p[-1] != '\n')
branch  0 never executed
branch  1 never executed
    #####:16998:	{
        -:16999:	  /* Probably ran out of buffer space.  */
    #####:17000:	  register unsigned int p_off = p - buffer;
    #####:17001:	  linebuffer->size *= 2;
    #####:17002:	  buffer = (char *) xrealloc (buffer, linebuffer->size);
call    0 never executed
    #####:17003:	  p = buffer + p_off;
    #####:17004:	  end = buffer + linebuffer->size;
    #####:17005:	  linebuffer->buffer = buffer;
    #####:17006:	  *p = '\0';
    #####:17007:	  lastlen = len;
    #####:17008:	  continue;
        -:17009:	}
        -:17010:
    #####:17011:      ++nlines;
        -:17012:
        -:17013:#if !defined(WINDOWS32) && !defined(__MSDOS__)
        -:17014:      /* Check to see if the line was really ended with CRLF; if so ignore
        -:17015:         the CR.  */
    #####:17016:      if (len > 1 && p[-2] == '\r')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:17017:        {
    #####:17018:          --len;
    #####:17019:          --p;
    #####:17020:          p[-1] = '\n';
        -:17021:        }
        -:17022:#endif
        -:17023:
    #####:17024:      if (len == 1 && p > buffer)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:17025:	/* P is pointing at a newline and it's the beginning of
        -:17026:	   the buffer returned by the last fgets call.  However,
        -:17027:	   it is not necessarily the beginning of a line if P is
        -:17028:	   pointing past the beginning of the holding buffer.
        -:17029:	   If the buffer was just enlarged (right before the newline),
        -:17030:	   we must account for that, so we pretend that the two lines
        -:17031:	   were one line.  */
    #####:17032:	len += lastlen;
    #####:17033:      lastlen = len;
    #####:17034:      backslash = 0;
    #####:17035:      for (p2 = p - 2; --len > 0; --p2)
branch  0 never executed
branch  1 never executed
        -:17036:	{
    #####:17037:	  if (*p2 == '\\')
branch  0 never executed
branch  1 never executed
    #####:17038:	    backslash = !backslash;
        -:17039:	  else
    #####:17040:	    break;
        -:17041:	}
        -:17042:
    #####:17043:      if (!backslash)
branch  0 never executed
branch  1 never executed
        -:17044:	{
    #####:17045:	  p[-1] = '\0';
    #####:17046:	  break;
        -:17047:	}
        -:17048:
    #####:17049:      if (end - p <= 1)
branch  0 never executed
branch  1 never executed
        -:17050:	{
        -:17051:	  /* Enlarge the buffer.  */
    #####:17052:	  register unsigned int p_off = p - buffer;
    #####:17053:	  linebuffer->size *= 2;
    #####:17054:	  buffer = (char *) xrealloc (buffer, linebuffer->size);
call    0 never executed
    #####:17055:	  p = buffer + p_off;
    #####:17056:	  end = buffer + linebuffer->size;
    #####:17057:	  linebuffer->buffer = buffer;
        -:17058:	}
        -:17059:    }
        -:17060:
    #####:17061:  if (ferror (stream))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:17062:    pfatal_with_name (flocp->filenm);
call    0 never executed
        -:17063:
    #####:17064:  return nlines;
        -:17065:}
        -:17066:
        -:17067:/* Parse the next "makefile word" from the input buffer, and return info
        -:17068:   about it.
        -:17069:
        -:17070:   A "makefile word" is one of:
        -:17071:
        -:17072:     w_bogus        Should never happen
        -:17073:     w_eol          End of input
        -:17074:     w_static       A static word; cannot be expanded
        -:17075:     w_variable     A word containing one or more variables/functions
        -:17076:     w_colon        A colon
        -:17077:     w_dcolon       A double-colon
        -:17078:     w_semicolon    A semicolon
        -:17079:     w_comment      A comment character
        -:17080:     w_varassign    A variable assignment operator (=, :=, +=, or ?=)
        -:17081:
        -:17082:   Note that this function is only used when reading certain parts of the
        -:17083:   makefile.  Don't use it where special rules hold sway (RHS of a variable,
        -:17084:   in a command list, etc.)  */
        -:17085:
        -:17086:static enum make_word_type
function get_next_mword called 0 returned 0% blocks executed 0%
    #####:17087:get_next_mword (buffer, delim, startp, length)
        -:17088:     char *buffer;
        -:17089:     char *delim;
        -:17090:     char **startp;
        -:17091:     unsigned int *length;
        -:17092:{
    #####:17093:  enum make_word_type wtype = w_bogus;
    #####:17094:  char *p = buffer, *beg;
        -:17095:  char c;
        -:17096:
        -:17097:  /* Skip any leading whitespace.  */
    #####:17098:  while (isblank(*p))
branch  0 never executed
branch  1 never executed
    #####:17099:    ++p;
        -:17100:
    #####:17101:  beg = p;
    #####:17102:  c = *(p++);
    #####:17103:  switch (c)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
        -:17104:    {
    #####:17105:    case '\0':
    #####:17106:      wtype = w_eol;
    #####:17107:      break;
        -:17108:
    #####:17109:    case '#':
    #####:17110:      wtype = w_comment;
    #####:17111:      break;
        -:17112:
    #####:17113:    case ';':
    #####:17114:      wtype = w_semicolon;
    #####:17115:      break;
        -:17116:
    #####:17117:    case '=':
    #####:17118:      wtype = w_varassign;
    #####:17119:      break;
        -:17120:
    #####:17121:    case ':':
    #####:17122:      wtype = w_colon;
    #####:17123:      switch (*p)
branch  0 never executed
branch  1 never executed
branch  2 never executed
        -:17124:        {
    #####:17125:        case ':':
    #####:17126:          ++p;
    #####:17127:          wtype = w_dcolon;
    #####:17128:          break;
        -:17129:
    #####:17130:        case '=':
    #####:17131:          ++p;
    #####:17132:          wtype = w_varassign;
    #####:17133:          break;
        -:17134:        }
    #####:17135:      break;
        -:17136:
    #####:17137:    case '+':
        -:17138:    case '?':
    #####:17139:      if (*p == '=')
branch  0 never executed
branch  1 never executed
        -:17140:        {
    #####:17141:          ++p;
    #####:17142:          wtype = w_varassign;
    #####:17143:          break;
        -:17144:        }
        -:17145:
        -:17146:    default:
    #####:17147:      if (delim && strchr (delim, c))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:17148:        wtype = w_static;
    #####:17149:      break;
        -:17150:    }
        -:17151:
        -:17152:  /* Did we find something?  If so, return now.  */
    #####:17153:  if (wtype != w_bogus)
branch  0 never executed
branch  1 never executed
    #####:17154:    goto done;
        -:17155:
        -:17156:  /* This is some non-operator word.  A word consists of the longest
        -:17157:     string of characters that doesn't contain whitespace, one of [:=#],
        -:17158:     or [?+]=, or one of the chars in the DELIM string.  */
        -:17159:
        -:17160:  /* We start out assuming a static word; if we see a variable we'll
        -:17161:     adjust our assumptions then.  */
    #####:17162:  wtype = w_static;
        -:17163:
        -:17164:  /* We already found the first value of "c", above.  */
        -:17165:  while (1)
    #####:17166:    {
        -:17167:      char closeparen;
        -:17168:      int count;
        -:17169:
    #####:17170:      switch (c)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:17171:        {
    #####:17172:        case '\0':
        -:17173:        case ' ':
        -:17174:        case '\t':
        -:17175:        case '=':
        -:17176:        case '#':
    #####:17177:          goto done_word;
        -:17178:
    #####:17179:        case ':':
        -:17180:#if defined(__MSDOS__) || defined(WINDOWS32)
        -:17181:	  /* A word CAN include a colon in its drive spec.  The drive
        -:17182:	     spec is allowed either at the beginning of a word, or as part
        -:17183:	     of the archive member name, like in "libfoo.a(d:/foo/bar.o)".  */
        -:17184:	  if (!(p - beg >= 2
        -:17185:		&& (*p == '/' || *p == '\\') && isalpha ((unsigned char)p[-2])
        -:17186:		&& (p - beg == 2 || p[-3] == '(')))
        -:17187:#endif
    #####:17188:	  goto done_word;
        -:17189:
    #####:17190:        case '$':
    #####:17191:          c = *(p++);
    #####:17192:          if (c == '$')
branch  0 never executed
branch  1 never executed
    #####:17193:            break;
        -:17194:
        -:17195:          /* This is a variable reference, so note that it's expandable.
        -:17196:             Then read it to the matching close paren.  */
    #####:17197:          wtype = w_variable;
        -:17198:
    #####:17199:          if (c == '(')
branch  0 never executed
branch  1 never executed
    #####:17200:            closeparen = ')';
    #####:17201:          else if (c == '{')
branch  0 never executed
branch  1 never executed
    #####:17202:            closeparen = '}';
        -:17203:          else
        -:17204:            /* This is a single-letter variable reference.  */
    #####:17205:            break;
        -:17206:
    #####:17207:          for (count=0; *p != '\0'; ++p)
branch  0 never executed
branch  1 never executed
        -:17208:            {
    #####:17209:              if (*p == c)
branch  0 never executed
branch  1 never executed
    #####:17210:                ++count;
    #####:17211:              else if (*p == closeparen && --count < 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:17212:                {
    #####:17213:                  ++p;
    #####:17214:                  break;
        -:17215:                }
        -:17216:            }
    #####:17217:          break;
        -:17218:
    #####:17219:        case '?':
        -:17220:        case '+':
    #####:17221:          if (*p == '=')
branch  0 never executed
branch  1 never executed
    #####:17222:            goto done_word;
    #####:17223:          break;
        -:17224:
    #####:17225:        case '\\':
    #####:17226:          switch (*p)
branch  0 never executed
branch  1 never executed
        -:17227:            {
    #####:17228:            case ':':
        -:17229:            case ';':
        -:17230:            case '=':
        -:17231:            case '\\':
    #####:17232:              ++p;
    #####:17233:              break;
        -:17234:            }
    #####:17235:          break;
        -:17236:
    #####:17237:        default:
    #####:17238:          if (delim && strchr (delim, c))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:17239:            goto done_word;
    #####:17240:          break;
        -:17241:        }
        -:17242:
    #####:17243:      c = *(p++);
        -:17244:    }
    #####:17245: done_word:
    #####:17246:  --p;
        -:17247:
    #####:17248: done:
    #####:17249:  if (startp)
branch  0 never executed
branch  1 never executed
    #####:17250:    *startp = beg;
    #####:17251:  if (length)
branch  0 never executed
branch  1 never executed
    #####:17252:    *length = p - beg;
    #####:17253:  return wtype;
        -:17254:}
        -:17255:
        -:17256:/* Construct the list of include directories
        -:17257:   from the arguments and the default list.  */
        -:17258:
        -:17259:void
function construct_include_path called 1 returned 100% blocks executed 50%
        1:17260:construct_include_path (arg_dirs)
        -:17261:     char **arg_dirs;
        -:17262:{
        -:17263:  register unsigned int i;
        -:17264:#ifdef VAXC		/* just don't ask ... */
        -:17265:  stat_t stbuf;
        -:17266:#else
        -:17267:  struct stat stbuf;
        -:17268:#endif
        -:17269:  /* Table to hold the dirs.  */
        -:17270:
        1:17271:  register unsigned int defsize = (sizeof (default_include_directories)
        -:17272:				   / sizeof (default_include_directories[0]));
        1:17273:  register unsigned int max = 5;
        1:17274:  register char **dirs = (char **) xmalloc ((5 + defsize) * sizeof (char *));
call    0 returned 1
        1:17275:  register unsigned int idx = 0;
        -:17276:
        -:17277:#ifdef  __MSDOS__
        -:17278:  defsize++;
        -:17279:#endif
        -:17280:
        -:17281:  /* First consider any dirs specified with -I switches.
        -:17282:     Ignore dirs that don't exist.  */
        -:17283:
        1:17284:  if (arg_dirs != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:17285:    while (*arg_dirs != 0)
branch  0 never executed
branch  1 never executed
        -:17286:      {
    #####:17287:	char *dir = *arg_dirs++;
        -:17288:
    #####:17289:	if (dir[0] == '~')
branch  0 never executed
branch  1 never executed
        -:17290:	  {
    #####:17291:	    char *expanded = tilde_expand (dir);
call    0 never executed
    #####:17292:	    if (expanded != 0)
branch  0 never executed
branch  1 never executed
    #####:17293:	      dir = expanded;
        -:17294:	  }
        -:17295:
    #####:17296:	if (stat (dir, &stbuf) == 0 && S_ISDIR (stbuf.st_mode))
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -:17297:	  {
    #####:17298:	    if (idx == max - 1)
branch  0 never executed
branch  1 never executed
        -:17299:	      {
    #####:17300:		max += 5;
        -:17301:		dirs = (char **)
    #####:17302:		  xrealloc ((char *) dirs, (max + defsize) * sizeof (char *));
call    0 never executed
        -:17303:	      }
    #####:17304:	    dirs[idx++] = dir;
        -:17305:	  }
    #####:17306:	else if (dir != arg_dirs[-1])
branch  0 never executed
branch  1 never executed
    #####:17307:	  free (dir);
        -:17308:      }
        -:17309:
        -:17310:  /* Now add at the end the standard default dirs.  */
        -:17311:
        -:17312:#ifdef  __MSDOS__
        -:17313:  {
        -:17314:    /* The environment variable $DJDIR holds the root of the
        -:17315:       DJGPP directory tree; add ${DJDIR}/include.  */
        -:17316:    struct variable *djdir = lookup_variable ("DJDIR", 5);
        -:17317:
        -:17318:    if (djdir)
        -:17319:      {
        -:17320:	char *defdir = (char *) xmalloc (strlen (djdir->value) + 8 + 1);
        -:17321:
        -:17322:	strcat (strcpy (defdir, djdir->value), "/include");
        -:17323:	dirs[idx++] = defdir;
        -:17324:      }
        -:17325:  }
        -:17326:#endif
        -:17327:#ifndef F_AA_4
        -:17328:  for (i = 0; default_include_directories[i] != 0; ++i)
        -:17329:#else
        4:17330:  for (i = 0; default_include_directories[i+1] != 0; ++i)
branch  0 taken 3
branch  1 taken 1 (fallthrough)
        -:17331:#endif
        3:17332:    if (stat (default_include_directories[i], &stbuf) == 0
call    0 returned 3
branch  1 taken 2 (fallthrough)
branch  2 taken 1
        2:17333:	&& S_ISDIR (stbuf.st_mode))
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2:17334:      dirs[idx++] = default_include_directories[i];
        -:17335:
        1:17336:  dirs[idx] = 0;
        -:17337:
        -:17338:  /* Now compute the maximum length of any name in it.  */
        -:17339:
        1:17340:  max_incl_len = 0;
        3:17341:  for (i = 0; i < idx; ++i)
branch  0 taken 2
branch  1 taken 1 (fallthrough)
        -:17342:    {
        2:17343:      unsigned int len = strlen (dirs[i]);
        -:17344:      /* If dir name is written with a trailing slash, discard it.  */
        2:17345:      if (dirs[i][len - 1] == '/')
branch  0 taken 0 (fallthrough)
branch  1 taken 2
        -:17346:	/* We can't just clobber a null in because it may have come from
        -:17347:	   a literal string and literal strings may not be writable.  */
    #####:17348:	dirs[i] = savestring (dirs[i], len - 1);
call    0 never executed
        2:17349:      if (len > max_incl_len)
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        1:17350:	max_incl_len = len;
        -:17351:    }
        -:17352:
        1:17353:  include_directories_to_search = dirs;
        1:17354:}
        -:17355:
        -:17356:/* Expand ~ or ~USER at the beginning of NAME.
        -:17357:   Return a newly malloc'd string or 0.  */
        -:17358:
        -:17359:char *
function tilde_expand called 0 returned 0% blocks executed 0%
    #####:17360:tilde_expand (name)
        -:17361:     char *name;
        -:17362:{
        -:17363:#ifndef VMS
    #####:17364:  if (name[1] == '/' || name[1] == '\0')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:17365:    {
        -:17366:      extern char *getenv ();
        -:17367:      char *home_dir;
        -:17368:      int is_variable;
        -:17369:
        -:17370:      {
        -:17371:	/* Turn off --warn-undefined-variables while we expand HOME.  */
    #####:17372:	int save = warn_undefined_variables_flag;
    #####:17373:	warn_undefined_variables_flag = 0;
        -:17374:
    #####:17375:	home_dir = allocated_variable_expand ("$(HOME)");
call    0 never executed
        -:17376:
    #####:17377:	warn_undefined_variables_flag = save;
        -:17378:      }
        -:17379:
    #####:17380:      is_variable = home_dir[0] != '\0';
    #####:17381:      if (!is_variable)
branch  0 never executed
branch  1 never executed
        -:17382:	{
    #####:17383:	  free (home_dir);
    #####:17384:	  home_dir = getenv ("HOME");
call    0 never executed
        -:17385:	}
        -:17386:#if !defined(_AMIGA) && !defined(WINDOWS32)
    #####:17387:      if (home_dir == 0 || home_dir[0] == '\0')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:17388:	{
        -:17389:	  extern char *getlogin ();
    #####:17390:	  char *logname = getlogin ();
call    0 never executed
    #####:17391:	  home_dir = 0;
    #####:17392:	  if (logname != 0)
branch  0 never executed
branch  1 never executed
        -:17393:	    {
    #####:17394:	      struct passwd *p = getpwnam (logname);
call    0 never executed
    #####:17395:	      if (p != 0)
branch  0 never executed
branch  1 never executed
    #####:17396:		home_dir = p->pw_dir;
        -:17397:	    }
        -:17398:	}
        -:17399:#endif /* !AMIGA && !WINDOWS32 */
    #####:17400:      if (home_dir != 0)
branch  0 never executed
branch  1 never executed
        -:17401:	{
    #####:17402:	  char *new = concat (home_dir, "", name + 1);
call    0 never executed
    #####:17403:	  if (is_variable)
branch  0 never executed
branch  1 never executed
    #####:17404:	    free (home_dir);
    #####:17405:	  return new;
        -:17406:	}
        -:17407:    }
        -:17408:#if !defined(_AMIGA) && !defined(WINDOWS32)
        -:17409:  else
        -:17410:    {
        -:17411:      struct passwd *pwent;
    #####:17412:      char *userend = strchr (name + 1, '/');
    #####:17413:      if (userend != 0)
branch  0 never executed
branch  1 never executed
    #####:17414:	*userend = '\0';
    #####:17415:      pwent = getpwnam (name + 1);
call    0 never executed
    #####:17416:      if (pwent != 0)
branch  0 never executed
branch  1 never executed
        -:17417:	{
    #####:17418:	  if (userend == 0)
branch  0 never executed
branch  1 never executed
    #####:17419:	    return xstrdup (pwent->pw_dir);
call    0 never executed
        -:17420:	  else
    #####:17421:	    return concat (pwent->pw_dir, "/", userend + 1);
call    0 never executed
        -:17422:	}
    #####:17423:      else if (userend != 0)
branch  0 never executed
branch  1 never executed
    #####:17424:	*userend = '/';
        -:17425:    }
        -:17426:#endif /* !AMIGA && !WINDOWS32 */
        -:17427:#endif /* !VMS */
    #####:17428:  return 0;
        -:17429:}
        -:17430:
        -:17431:/* Given a chain of struct nameseq's describing a sequence of filenames,
        -:17432:   in reverse of the intended order, return a new chain describing the
        -:17433:   result of globbing the filenames.  The new chain is in forward order.
        -:17434:   The links of the old chain are freed or used in the new chain.
        -:17435:   Likewise for the names in the old chain.
        -:17436:
        -:17437:   SIZE is how big to construct chain elements.
        -:17438:   This is useful if we want them actually to be other structures
        -:17439:   that have room for additional info.  */
        -:17440:
        -:17441:struct nameseq *
function multi_glob called 10 returned 100% blocks executed 54%
       10:17442:multi_glob (chain, size)
        -:17443:     struct nameseq *chain;
        -:17444:     unsigned int size;
        -:17445:{
        -:17446:  extern void dir_setup_glob ();
       10:17447:  register struct nameseq *new = 0;
        -:17448:  register struct nameseq *old;
        -:17449:  struct nameseq *nexto;
        -:17450:  glob_t gl;
        -:17451:
       10:17452:  dir_setup_glob (&gl);
call    0 returned 10
        -:17453:
       53:17454:  for (old = chain; old != 0; old = nexto)
branch  0 taken 43
branch  1 taken 10 (fallthrough)
        -:17455:    {
        -:17456:#ifndef NO_ARCHIVES
        -:17457:      char *memname;
        -:17458:#endif
        -:17459:
       43:17460:      nexto = old->next;
        -:17461:
       43:17462:      if (old->name[0] == '~')
branch  0 taken 0 (fallthrough)
branch  1 taken 43
        -:17463:	{
    #####:17464:	  char *newname = tilde_expand (old->name);
call    0 never executed
    #####:17465:	  if (newname != 0)
branch  0 never executed
branch  1 never executed
        -:17466:	    {
    #####:17467:	      free (old->name);
    #####:17468:	      old->name = newname;
        -:17469:	    }
        -:17470:	}
        -:17471:
        -:17472:#ifndef NO_ARCHIVES
       43:17473:      if (ar_name (old->name))
call    0 returned 43
branch  1 taken 0 (fallthrough)
branch  2 taken 43
        -:17474:	{
        -:17475:	  /* OLD->name is an archive member reference.
        -:17476:	     Replace it with the archive file name,
        -:17477:	     and save the member name in MEMNAME.
        -:17478:	     We will glob on the archive name and then
        -:17479:	     reattach MEMNAME later.  */
        -:17480:	  char *arname;
    #####:17481:	  ar_parse_name (old->name, &arname, &memname);
call    0 never executed
    #####:17482:	  free (old->name);
    #####:17483:	  old->name = arname;
        -:17484:	}
        -:17485:      else
       43:17486:	memname = 0;
        -:17487:#endif /* !NO_ARCHIVES */
        -:17488:
       43:17489:      switch (glob (old->name, GLOB_NOCHECK|GLOB_ALTDIRFUNC, NULL, &gl))
call    0 returned 43
branch  1 taken 43
branch  2 taken 0
branch  3 taken 0
        -:17490:	{
       43:17491:	case 0:			/* Success.  */
        -:17492:	  {
       43:17493:	    register int i = gl.gl_pathc;
       86:17494:	    while (i-- > 0)
branch  0 taken 43
branch  1 taken 43 (fallthrough)
        -:17495:	      {
        -:17496:#ifndef NO_ARCHIVES
       43:17497:		if (memname != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 43
        -:17498:		  {
        -:17499:		    /* Try to glob on MEMNAME within the archive.  */
        -:17500:		    struct nameseq *found
    #####:17501:		      = ar_glob (gl.gl_pathv[i], memname, size);
call    0 never executed
    #####:17502:		    if (found == 0)
branch  0 never executed
branch  1 never executed
        -:17503:		      {
        -:17504:			/* No matches.  Use MEMNAME as-is.  */
        -:17505:			struct nameseq *elt
    #####:17506:			  = (struct nameseq *) xmalloc (size);
call    0 never executed
    #####:17507:			unsigned int alen = strlen (gl.gl_pathv[i]);
    #####:17508:			unsigned int mlen = strlen (memname);
    #####:17509:			elt->name = (char *) xmalloc (alen + 1 + mlen + 2);
call    0 never executed
    #####:17510:			bcopy (gl.gl_pathv[i], elt->name, alen);
    #####:17511:			elt->name[alen] = '(';
    #####:17512:			bcopy (memname, &elt->name[alen + 1], mlen);
    #####:17513:			elt->name[alen + 1 + mlen] = ')';
    #####:17514:			elt->name[alen + 1 + mlen + 1] = '\0';
    #####:17515:			elt->next = new;
    #####:17516:			new = elt;
        -:17517:		      }
        -:17518:		    else
        -:17519:		      {
        -:17520:			/* Find the end of the FOUND chain.  */
    #####:17521:			struct nameseq *f = found;
    #####:17522:			while (f->next != 0)
branch  0 never executed
branch  1 never executed
    #####:17523:			  f = f->next;
        -:17524:
        -:17525:			/* Attach the chain being built to the end of the FOUND
        -:17526:			   chain, and make FOUND the new NEW chain.  */
    #####:17527:			f->next = new;
    #####:17528:			new = found;
        -:17529:		      }
        -:17530:
    #####:17531:		    free (memname);
        -:17532:		  }
        -:17533:		else
        -:17534:#endif /* !NO_ARCHIVES */
        -:17535:		  {
       43:17536:		    struct nameseq *elt = (struct nameseq *) xmalloc (size);
call    0 returned 43
       43:17537:		    elt->name = xstrdup (gl.gl_pathv[i]);
call    0 returned 43
       43:17538:		    elt->next = new;
       43:17539:		    new = elt;
        -:17540:		  }
        -:17541:	      }
       43:17542:	    globfree (&gl);
call    0 returned 43
       43:17543:	    free (old->name);
       43:17544:	    free ((char *)old);
       43:17545:	    break;
        -:17546:	  }
        -:17547:
    #####:17548:	case GLOB_NOSPACE:
    #####:17549:	  fatal (NILF, _("virtual memory exhausted"));
call    0 never executed
        -:17550:	  break;
        -:17551:
    #####:17552:	default:
    #####:17553:	  old->next = new;
    #####:17554:	  new = old;
    #####:17555:	  break;
        -:17556:	}
        -:17557:    }
        -:17558:
       10:17559:  return new;
        -:17560:}
        -:17561:
        -:17562:
        -:17563:
        -:17564:/*************************************************************
        -:17565:  ============================================================
        -:17566:  ************************************************************
        -:17567:  ============================================================
        -:17568:  ************************************************************
        -:17569:                         remake.c
        -:17570:  ************************************************************
        -:17571:  ============================================================
        -:17572:  ************************************************************
        -:17573:  ============================================================
        -:17574:  *************************************************************/
        -:17575:
        -:17576:/* Basic dependency engine for GNU Make.
        -:17577:Copyright (C) 1988,89,90,91,92,93,94,95,96,97,99 Free Software Foundation, Inc.
        -:17578:This file is part of GNU Make.
        -:17579:
        -:17580:GNU Make is free software; you can redistribute it and/or modify
        -:17581:it under the terms of the GNU General Public License as published by
        -:17582:the Free Software Foundation; either version 2, or (at your option)
        -:17583:any later version.
        -:17584:
        -:17585:GNU Make is distributed in the hope that it will be useful,
        -:17586:but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:17587:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:17588:GNU General Public License for more details.
        -:17589:
        -:17590:You should have received a copy of the GNU General Public License
        -:17591:along with GNU Make; see the file COPYING.  If not, write to
        -:17592:the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
        -:17593:Boston, MA 02111-1307, USA.  */
        -:17594:
        -:17595:/* #include "make.h"  <- modification by J.Ruthruff, 7/28 */
        -:17596:/* #include "filedef.h"  <- modification by J.Ruthruff, 7/28 */
        -:17597:#include "job.h"
        -:17598:/* #include "commands.h"  <- modification by J.Ruthruff, 7/28 */
        -:17599:/* #include "dep.h"  <- modification by J.Ruthruff, 7/28 */
        -:17600:/* #include "variable.h"  <- modification by J.Ruthruff, 7/28 */
        -:17601:#include "debug.h"
        -:17602:
        -:17603:#include <assert.h>
        -:17604:#undef stderr
        -:17605:#define stderr stdout
        -:17606:
        -:17607:#ifdef HAVE_FCNTL_H
        -:17608:#include <fcntl.h>
        -:17609:#undef stderr
        -:17610:#define stderr stdout
        -:17611:#else
        -:17612:#include <sys/file.h>
        -:17613:#undef stderr
        -:17614:#define stderr stdout
        -:17615:#endif
        -:17616:
        -:17617:#ifdef VMS
        -:17618:#include <starlet.h>
        -:17619:#undef stderr
        -:17620:#define stderr stdout
        -:17621:#endif
        -:17622:#ifdef WINDOWS32
        -:17623:#include <io.h>
        -:17624:#undef stderr
        -:17625:#define stderr stdout
        -:17626:#endif
        -:17627:
        -:17628:/* extern int try_implicit_rule PARAMS ((struct file *file, unsigned int depth)); */
        -:17629:
        -:17630:
        -:17631:/* The test for circular dependencies is based on the 'updating' bit in
        -:17632:   `struct file'.  However, double colon targets have seperate `struct
        -:17633:   file's; make sure we always use the base of the double colon chain. */
        -:17634:
        -:17635:#define start_updating(_f)  (((_f)->double_colon ? (_f)->double_colon : (_f))\
        -:17636:                             ->updating = 1)
        -:17637:#define finish_updating(_f) (((_f)->double_colon ? (_f)->double_colon : (_f))\
        -:17638:                             ->updating = 0)
        -:17639:#define is_updating(_f)     (((_f)->double_colon ? (_f)->double_colon : (_f))\
        -:17640:                             ->updating)
        -:17641:
        -:17642:
        -:17643:/* Incremented when a command is started (under -n, when one would be).  */
        -:17644:unsigned int commands_started = 0;
        -:17645:
        -:17646:static int update_file PARAMS ((struct file *file, unsigned int depth));
        -:17647:static int update_file_1 PARAMS ((struct file *file, unsigned int depth));
        -:17648:static int check_dep PARAMS ((struct file *file, unsigned int depth, FILE_TIMESTAMP this_mtime, int *must_make_ptr));
        -:17649:static int touch_file PARAMS ((struct file *file));
        -:17650:static void remake_file PARAMS ((struct file *file));
        -:17651:static FILE_TIMESTAMP name_mtime PARAMS ((char *name));
        -:17652:static int library_search PARAMS ((char **lib, FILE_TIMESTAMP *mtime_ptr));
        -:17653:
        -:17654:
        -:17655:/* Remake all the goals in the `struct dep' chain GOALS.  Return -1 if nothing
        -:17656:   was done, 0 if all goals were updated successfully, or 1 if a goal failed.
        -:17657:   If MAKEFILES is nonzero, these goals are makefiles, so -t, -q, and -n should
        -:17658:   be disabled for them unless they were also command-line targets, and we
        -:17659:   should only make one goal at a time and return as soon as one goal whose
        -:17660:   `changed' member is nonzero is successfully made.  */
        -:17661:
        -:17662:int
function update_goal_chain called 1 returned 0% blocks executed 24%
        1:17663:update_goal_chain (goals, makefiles)
        -:17664:     register struct dep *goals;
        -:17665:     int makefiles;
        -:17666:{
        1:17667:  int t = touch_flag, q = question_flag, n = just_print_flag;
        1:17668:  unsigned int j = job_slots;
        1:17669:  int status = -1;
        -:17670:
        -:17671:#define	MTIME(file) (makefiles ? file_mtime_no_search (file) \
        -:17672:		     : file_mtime (file))
        -:17673:
        -:17674:  /* Duplicate the chain so we can remove things from it.  */
        -:17675:
        1:17676:  goals = copy_dep_chain (goals);
call    0 returned 1
        -:17677:
        -:17678:  {
        -:17679:    /* Clear the `changed' flag of each goal in the chain.
        -:17680:       We will use the flag below to notice when any commands
        -:17681:       have actually been run for a target.  When no commands
        -:17682:       have been run, we give an "up to date" diagnostic.  */
        -:17683:
        -:17684:    struct dep *g;
        2:17685:    for (g = goals; g != 0; g = g->next)
branch  0 taken 1
branch  1 taken 1 (fallthrough)
        1:17686:      g->changed = 0;
        -:17687:  }
        -:17688:
        -:17689:  /* All files start with the considered bit 0, so the global value is 1.  */
        1:17690:  considered = 1;
        -:17691:
        -:17692:  /* Update all the goals until they are all finished.  */
        -:17693:
        1:17694:  while (goals != 0)
branch  0 taken 1
branch  1 taken 0 (fallthrough)
        -:17695:    {
        -:17696:      register struct dep *g, *lastgoal;
        -:17697:
        -:17698:      /* Start jobs that are waiting for the load to go down.  */
        -:17699:
        1:17700:      start_waiting_jobs ();
call    0 returned 1
        -:17701:
        -:17702:      /* Wait for a child to die.  */
        -:17703:
        1:17704:      reap_children (1, 0);
call    0 returned 1
        -:17705:
        1:17706:      lastgoal = 0;
        1:17707:      g = goals;
        1:17708:      while (g != 0)
branch  0 taken 1
branch  1 taken 0 (fallthrough)
        -:17709:	{
        -:17710:	  /* Iterate over all double-colon entries for this file.  */
        -:17711:	  struct file *file;
        1:17712:	  int stop = 0, any_not_updated = 0;
        -:17713:
       1*:17714:	  for (file = g->file->double_colon ? g->file->double_colon : g->file;
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        1:17715:	       file != NULL;
branch  0 taken 1
branch  1 taken 0 (fallthrough)
    #####:17716:	       file = file->prev)
        -:17717:	    {
        -:17718:	      unsigned int ocommands_started;
        -:17719:	      int x;
       1*:17720:	      check_renamed (file);
branch  0 taken 0
branch  1 taken 1 (fallthrough)
        1:17721:	      if (makefiles)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -:17722:		{
        1:17723:		  if (file->cmd_target)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -:17724:		    {
    #####:17725:		      touch_flag = t;
    #####:17726:		      question_flag = q;
    #####:17727:		      just_print_flag = n;
        -:17728:		    }
        -:17729:		  else
        1:17730:		    touch_flag = question_flag = just_print_flag = 0;
        -:17731:		}
        -:17732:
        -:17733:	      /* Save the old value of `commands_started' so we can compare
        -:17734:		 later.  It will be incremented when any commands are
        -:17735:		 actually run.  */
        1:17736:	      ocommands_started = commands_started;
        -:17737:
        1:17738:	      x = update_file (file, makefiles ? 1 : 0);
call    0 returned 0
    #####:17739:	      check_renamed (file);
branch  0 never executed
branch  1 never executed
        -:17740:
        -:17741:	      /* Set the goal's `changed' flag if any commands were started
        -:17742:		 by calling update_file above.  We check this flag below to
        -:17743:		 decide when to give an "up to date" diagnostic.  */
    #####:17744:	      g->changed += commands_started - ocommands_started;
        -:17745:
        -:17746:              /* If we updated a file and STATUS was not already 1, set it to
        -:17747:                 1 if updating failed, or to 0 if updating succeeded.  Leave
        -:17748:                 STATUS as it is if no updating was done.  */
        -:17749:
    #####:17750:	      stop = 0;
    #####:17751:	      if ((x != 0 || file->updated) && status < 1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:17752:                {
    #####:17753:                  if (file->update_status != 0)
branch  0 never executed
branch  1 never executed
        -:17754:                    {
        -:17755:                      /* Updating failed, or -q triggered.  The STATUS value
        -:17756:                         tells our caller which.  */
    #####:17757:                      status = file->update_status;
        -:17758:                      /* If -q just triggered, stop immediately.  It doesn't
        -:17759:                         matter how much more we run, since we already know
        -:17760:                         the answer to return.  */
    #####:17761:                      stop = (!keep_going_flag && !question_flag
branch  0 never executed
branch  1 never executed
    #####:17762:                              && !makefiles);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:17763:                    }
        -:17764:                  else
        -:17765:                    {
    #####:17766:                      FILE_TIMESTAMP mtime = MTIME (file);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
    #####:17767:                      check_renamed (file);
branch  0 never executed
branch  1 never executed
        -:17768:
    #####:17769:                      if (file->updated && g->changed &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:17770:                           mtime != file->mtime_before_update)
branch  0 never executed
branch  1 never executed
        -:17771:                        {
        -:17772:                          /* Updating was done.  If this is a makefile and
        -:17773:                             just_print_flag or question_flag is set (meaning
        -:17774:                             -n or -q was given and this file was specified
        -:17775:                             as a command-line target), don't change STATUS.
        -:17776:                             If STATUS is changed, we will get re-exec'd, and
        -:17777:                             enter an infinite loop.  */
    #####:17778:                          if (!makefiles
branch  0 never executed
branch  1 never executed
    #####:17779:                              || (!just_print_flag && !question_flag))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:17780:                            status = 0;
    #####:17781:                          if (makefiles && file->dontcare)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:17782:                            /* This is a default makefile; stop remaking.  */
    #####:17783:                            stop = 1;
        -:17784:                        }
        -:17785:                    }
        -:17786:                }
        -:17787:
        -:17788:	      /* Keep track if any double-colon entry is not finished.
        -:17789:                 When they are all finished, the goal is finished.  */
    #####:17790:	      any_not_updated |= !file->updated;
        -:17791:
    #####:17792:	      if (stop)
branch  0 never executed
branch  1 never executed
    #####:17793:		break;
        -:17794:	    }
        -:17795:
        -:17796:	  /* Reset FILE since it is null at the end of the loop.  */
    #####:17797:	  file = g->file;
        -:17798:
    #####:17799:	  if (stop || !any_not_updated)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:17800:	    {
        -:17801:	      /* If we have found nothing whatever to do for the goal,
        -:17802:		 print a message saying nothing needs doing.  */
        -:17803:
    #####:17804:	      if (!makefiles
branch  0 never executed
branch  1 never executed
        -:17805:		  /* If the update_status is zero, we updated successfully
        -:17806:		     or not at all.  G->changed will have been set above if
        -:17807:		     any commands were actually started for this goal.  */
    #####:17808:		  && file->update_status == 0 && !g->changed
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:17809:		  /* Never give a message under -s or -q.  */
    #####:17810:		  && !silent_flag && !question_flag)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:17811:		message (1, ((file->phony || file->cmds == 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:17812:			     ? _("Nothing to be done for `%s'.")
    #####:17813:			     : _("`%s' is up to date.")),
        -:17814:			 file->name);
        -:17815:
        -:17816:	      /* This goal is finished.  Remove it from the chain.  */
    #####:17817:	      if (lastgoal == 0)
branch  0 never executed
branch  1 never executed
    #####:17818:		goals = g->next;
        -:17819:	      else
    #####:17820:		lastgoal->next = g->next;
        -:17821:
        -:17822:	      /* Free the storage.  */
    #####:17823:	      free ((char *) g);
        -:17824:
    #####:17825:	      g = lastgoal == 0 ? goals : lastgoal->next;
branch  0 never executed
branch  1 never executed
        -:17826:
    #####:17827:	      if (stop)
branch  0 never executed
branch  1 never executed
    #####:17828:		break;
        -:17829:	    }
        -:17830:	  else
        -:17831:	    {
    #####:17832:	      lastgoal = g;
    #####:17833:	      g = g->next;
        -:17834:	    }
        -:17835:	}
        -:17836:
        -:17837:      /* If we reached the end of the dependency graph toggle the considered
        -:17838:         flag for the next pass.  */
    #####:17839:      if (g == 0)
branch  0 never executed
branch  1 never executed
    #####:17840:        considered = !considered;
        -:17841:    }
        -:17842:
    #####:17843:  if (makefiles)
branch  0 never executed
branch  1 never executed
        -:17844:    {
    #####:17845:      touch_flag = t;
    #####:17846:      question_flag = q;
    #####:17847:      just_print_flag = n;
    #####:17848:      job_slots = j;
        -:17849:    }
    #####:17850:  return status;
        -:17851:}
        -:17852:
        -:17853:/* If FILE is not up to date, execute the commands for it.
        -:17854:   Return 0 if successful, 1 if unsuccessful;
        -:17855:   but with some flag settings, just call `exit' if unsuccessful.
        -:17856:
        -:17857:   DEPTH is the depth in recursions of this function.
        -:17858:   We increment it during the consideration of our dependencies,
        -:17859:   then decrement it again after finding out whether this file
        -:17860:   is out of date.
        -:17861:
        -:17862:   If there are multiple double-colon entries for FILE,
        -:17863:   each is considered in turn.  */
        -:17864:
        -:17865:static int
function update_file called 1 returned 0% blocks executed 21%
        1:17866:update_file (file, depth)
        -:17867:     struct file *file;
        -:17868:     unsigned int depth;
        -:17869:{
        1:17870:  register int status = 0;
        -:17871:  register struct file *f;
        -:17872:
       1*:17873:  f = file->double_colon ? file->double_colon : file;
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -:17874:
        -:17875:  /* Prune the dependency graph: if we've already been here on _this_
        -:17876:     pass through the dependency graph, we don't have to go any further.
        -:17877:     We won't reap_children until we start the next pass, so no state
        -:17878:     change is possible below here until then.  */
        1:17879:  if (f->considered == considered)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -:17880:    {
    #####:17881:      DBF (DB_VERBOSE, _("Pruning file `%s'.\n"));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:17882:      return f->command_state == cs_finished ? f->update_status : 0;
branch  0 never executed
branch  1 never executed
        -:17883:    }
        -:17884:
        -:17885:  /* This loop runs until we start commands for a double colon rule, or until
        -:17886:     the chain is exhausted. */
       1*:17887:  for (; f != 0; f = f->prev)
branch  0 taken 1
branch  1 taken 0 (fallthrough)
        -:17888:    {
        1:17889:      f->considered = considered;
        -:17890:
       1*:17891:      status |= update_file_1 (f, depth);
call    0 returned 0
    #####:17892:      check_renamed (f);
branch  0 never executed
branch  1 never executed
        -:17893:
    #####:17894:      if (status != 0 && !keep_going_flag)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:17895:	break;
        -:17896:
    #####:17897:      if (f->command_state == cs_running
branch  0 never executed
branch  1 never executed
    #####:17898:          || f->command_state == cs_deps_running)
branch  0 never executed
branch  1 never executed
        -:17899:        {
        -:17900:	  /* Don't run the other :: rules for this
        -:17901:	     file until this rule is finished.  */
    #####:17902:          status = 0;
    #####:17903:          break;
        -:17904:        }
        -:17905:    }
        -:17906:
        -:17907:  /* Process the remaining rules in the double colon chain so they're marked
        -:17908:     considered.  Start their prerequisites, too.  */
    #####:17909:  for (; f != 0 ; f = f->prev)
branch  0 never executed
branch  1 never executed
        -:17910:    {
        -:17911:      struct dep *d;
        -:17912:
    #####:17913:      f->considered = considered;
        -:17914:
    #####:17915:      for (d = f->deps; d != 0; d = d->next)
branch  0 never executed
branch  1 never executed
    #####:17916:        status |= update_file (d->file, depth + 1);
call    0 never executed
        -:17917:    }
        -:17918:
    #####:17919:  return status;
        -:17920:}
        -:17921:
        -:17922:/* Consider a single `struct file' and update it as appropriate.  */
        -:17923:
        -:17924:static int
function update_file_1 called 1 returned 0% blocks executed 21%
        1:17925:update_file_1 (file, depth)
        -:17926:     struct file *file;
        -:17927:     unsigned int depth;
        -:17928:{
        -:17929:  register FILE_TIMESTAMP this_mtime;
        -:17930:  int noexist, must_make, deps_changed;
        1:17931:  int dep_status = 0;
        -:17932:  register struct dep *d, *lastd;
        1:17933:  int running = 0;
        -:17934:
        1:17935:  DBF (DB_VERBOSE, _("Considering target file `%s'.\n"));
branch  0 taken 1 (fallthrough)
branch  1 taken 0
call    2 returned 1
call    3 returned 1
call    4 returned 1
        -:17936:
        1:17937:  if (file->updated)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -:17938:    {
    #####:17939:      if (file->update_status > 0)
branch  0 never executed
branch  1 never executed
        -:17940:	{
    #####:17941:	  DBF (DB_VERBOSE,
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:17942:               _("Recently tried and failed to update file `%s'.\n"));
    #####:17943:	  return file->update_status;
        -:17944:	}
        -:17945:
    #####:17946:      DBF (DB_VERBOSE, _("File `%s' was considered already.\n"));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:17947:      return 0;
        -:17948:    }
        -:17949:
        1:17950:  switch (file->command_state)
branch  0 taken 1
branch  1 taken 0
branch  2 taken 0
branch  3 taken 0
        -:17951:    {
        1:17952:    case cs_not_started:
        -:17953:    case cs_deps_running:
        1:17954:      break;
    #####:17955:    case cs_running:
    #####:17956:      DBF (DB_VERBOSE, _("Still updating file `%s'.\n"));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:17957:      return 0;
    #####:17958:    case cs_finished:
    #####:17959:      DBF (DB_VERBOSE, _("Finished updating file `%s'.\n"));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:17960:      return file->update_status;
    #####:17961:    default:
    #####:17962:      abort ();
call    0 never executed
        -:17963:    }
        -:17964:
        1:17965:  ++depth;
        -:17966:
        -:17967:  /* Notice recursive update of the same file.  */
       1*:17968:  start_updating (file);
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -:17969:
        -:17970:  /* Looking at the file's modtime beforehand allows the possibility
        -:17971:     that its name may be changed by a VPATH search, and thus it may
        -:17972:     not need an implicit rule.  If this were not done, the file
        -:17973:     might get implicit commands that apply to its initial name, only
        -:17974:     to have that name replaced with another found by VPATH search.  */
        -:17975:
       1*:17976:  this_mtime = file_mtime (file);
branch  0 taken 1 (fallthrough)
branch  1 taken 0
call    2 never executed
       1*:17977:  check_renamed (file);
branch  0 taken 0
branch  1 taken 1 (fallthrough)
        1:17978:  noexist = this_mtime == (FILE_TIMESTAMP) -1;
        1:17979:  if (noexist)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:17980:    DBF (DB_BASIC, _("File `%s' does not exist.\n"));
branch  0 taken 1 (fallthrough)
branch  1 taken 0
call    2 returned 1
call    3 returned 1
call    4 returned 1
        -:17981:
        1:17982:  must_make = noexist;
        -:17983:
        -:17984:  /* If file was specified as a target with no commands,
        -:17985:     come up with some default commands.  */
        -:17986:
        1:17987:  if (!file->phony && file->cmds == 0 && !file->tried_implicit)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
branch  2 taken 1 (fallthrough)
branch  3 taken 0
branch  4 taken 1 (fallthrough)
branch  5 taken 0
        -:17988:    {
        1:17989:      if (try_implicit_rule (file, depth))
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
    #####:17990:	DBF (DB_IMPLICIT, _("Found an implicit rule for `%s'.\n"));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:17991:      else
        1:17992:	DBF (DB_IMPLICIT, _("No implicit rule found for `%s'.\n"));
branch  0 taken 1 (fallthrough)
branch  1 taken 0
call    2 returned 1
call    3 returned 1
call    4 returned 1
        1:17993:      file->tried_implicit = 1;
        -:17994:    }
        1:17995:  if (file->cmds == 0 && !file->is_target
branch  0 taken 1 (fallthrough)
branch  1 taken 0
branch  2 taken 1 (fallthrough)
branch  3 taken 0
        1:17996:      && default_file != 0 && default_file->cmds != 0)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 1
        -:17997:    {
    #####:17998:      DBF (DB_IMPLICIT, _("Using default commands for `%s'.\n"));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:17999:      file->cmds = default_file->cmds;
        -:18000:    }
        -:18001:
        -:18002:  /* Update all non-intermediate files we depend on, if necessary,
        -:18003:     and see whether any of them is more recent than this file.  */
        -:18004:
        1:18005:  lastd = 0;
        1:18006:  d = file->deps;
        1:18007:  while (d != 0)
branch  0 taken 0
branch  1 taken 1 (fallthrough)
        -:18008:    {
        -:18009:      FILE_TIMESTAMP mtime;
        -:18010:
    #####:18011:      check_renamed (d->file);
branch  0 never executed
branch  1 never executed
        -:18012:
    #####:18013:      mtime = file_mtime (d->file);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:18014:      check_renamed (d->file);
branch  0 never executed
branch  1 never executed
        -:18015:
    #####:18016:      if (is_updating (d->file))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:18017:	{
    #####:18018:	  error (NILF, _("Circular %s <- %s dependency dropped."),
    #####:18019:		 file->name, d->file->name);
call    0 never executed
        -:18020:	  /* We cannot free D here because our the caller will still have
        -:18021:	     a reference to it when we were called recursively via
        -:18022:	     check_dep below.  */
    #####:18023:	  if (lastd == 0)
branch  0 never executed
branch  1 never executed
    #####:18024:	    file->deps = d->next;
        -:18025:	  else
    #####:18026:	    lastd->next = d->next;
    #####:18027:	  d = d->next;
    #####:18028:	  continue;
        -:18029:	}
        -:18030:
    #####:18031:      d->file->parent = file;
    #####:18032:      dep_status |= check_dep (d->file, depth, this_mtime, &must_make);
call    0 never executed
    #####:18033:      check_renamed (d->file);
branch  0 never executed
branch  1 never executed
        -:18034:
        -:18035:      {
    #####:18036:	register struct file *f = d->file;
    #####:18037:	if (f->double_colon)
branch  0 never executed
branch  1 never executed
    #####:18038:	  f = f->double_colon;
        -:18039:	do
        -:18040:	  {
    #####:18041:	    running |= (f->command_state == cs_running
    #####:18042:			|| f->command_state == cs_deps_running);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:18043:	    f = f->prev;
        -:18044:	  }
    #####:18045:	while (f != 0);
branch  0 never executed
branch  1 never executed
        -:18046:      }
        -:18047:
    #####:18048:      if (dep_status != 0 && !keep_going_flag)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:18049:	break;
        -:18050:
    #####:18051:      if (!running)
branch  0 never executed
branch  1 never executed
    #####:18052:	d->changed = file_mtime (d->file) != mtime;
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:18053:
    #####:18054:      lastd = d;
    #####:18055:      d = d->next;
        -:18056:    }
        -:18057:
        -:18058:  /* Now we know whether this target needs updating.
        -:18059:     If it does, update all the intermediate files we depend on.  */
        -:18060:
        1:18061:  if (must_make)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -:18062:    {
       1*:18063:      for (d = file->deps; d != 0; d = d->next)
branch  0 taken 0
branch  1 taken 1 (fallthrough)
    #####:18064:	if (d->file->intermediate)
branch  0 never executed
branch  1 never executed
        -:18065:	  {
    #####:18066:	    FILE_TIMESTAMP mtime = file_mtime (d->file);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:18067:	    check_renamed (d->file);
branch  0 never executed
branch  1 never executed
    #####:18068:	    d->file->parent = file;
    #####:18069:	    dep_status |= update_file (d->file, depth);
call    0 never executed
    #####:18070:	    check_renamed (d->file);
branch  0 never executed
branch  1 never executed
        -:18071:
        -:18072:	    {
    #####:18073:	      register struct file *f = d->file;
    #####:18074:	      if (f->double_colon)
branch  0 never executed
branch  1 never executed
    #####:18075:		f = f->double_colon;
        -:18076:	      do
        -:18077:		{
    #####:18078:		  running |= (f->command_state == cs_running
    #####:18079:			      || f->command_state == cs_deps_running);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:18080:		  f = f->prev;
        -:18081:		}
    #####:18082:	      while (f != 0);
branch  0 never executed
branch  1 never executed
        -:18083:	    }
        -:18084:
    #####:18085:	    if (dep_status != 0 && !keep_going_flag)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:18086:	      break;
        -:18087:
    #####:18088:	    if (!running)
branch  0 never executed
branch  1 never executed
    #####:18089:	      d->changed = ((file->phony && file->cmds != 0)
branch  0 never executed
branch  1 never executed
    #####:18090:			    || file_mtime (d->file) != mtime);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
        -:18091:	  }
        -:18092:    }
        -:18093:
       1*:18094:  finish_updating (file);
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -:18095:
        1:18096:  DBF (DB_VERBOSE, _("Finished prerequisites of target file `%s'.\n"));
branch  0 taken 1 (fallthrough)
branch  1 taken 0
call    2 returned 1
call    3 returned 1
call    4 returned 1
        -:18097:
        1:18098:  if (running)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -:18099:    {
    #####:18100:      set_command_state (file, cs_deps_running);
call    0 never executed
    #####:18101:      --depth;
    #####:18102:      DBF (DB_VERBOSE, _("The prerequisites of `%s' are being made.\n"));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:18103:      return 0;
        -:18104:    }
        -:18105:
        -:18106:  /* If any dependency failed, give up now.  */
        -:18107:
        1:18108:  if (dep_status != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -:18109:    {
    #####:18110:      file->update_status = dep_status;
    #####:18111:      notice_finished_file (file);
call    0 never executed
        -:18112:
    #####:18113:      depth--;
        -:18114:
    #####:18115:      DBF (DB_VERBOSE, _("Giving up on target file `%s'.\n"));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:18116:
    #####:18117:      if (depth == 0 && keep_going_flag
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:18118:	  && !just_print_flag && !question_flag)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:18119:	error (NILF,
    #####:18120:               _("Target `%s' not remade because of errors."), file->name);
call    0 never executed
        -:18121:
    #####:18122:      return dep_status;
        -:18123:    }
        -:18124:
        1:18125:  if (file->command_state == cs_deps_running)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -:18126:    /* The commands for some deps were running on the last iteration, but
        -:18127:       they have finished now.  Reset the command_state to not_started to
        -:18128:       simplify later bookkeeping.  It is important that we do this only
        -:18129:       when the prior state was cs_deps_running, because that prior state
        -:18130:       was definitely propagated to FILE's also_make's by set_command_state
        -:18131:       (called above), but in another state an also_make may have
        -:18132:       independently changed to finished state, and we would confuse that
        -:18133:       file's bookkeeping (updated, but not_started is bogus state).  */
    #####:18134:    set_command_state (file, cs_not_started);
call    0 never executed
        -:18135:
        -:18136:  /* Now record which dependencies are more
        -:18137:     recent than this file, so we can define $?.  */
        -:18138:
        1:18139:  deps_changed = 0;
       1*:18140:  for (d = file->deps; d != 0; d = d->next)
branch  0 taken 0
branch  1 taken 1 (fallthrough)
        -:18141:    {
    #####:18142:      FILE_TIMESTAMP d_mtime = file_mtime (d->file);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:18143:      check_renamed (d->file);
branch  0 never executed
branch  1 never executed
        -:18144:
        -:18145:#if 1	/* %%% In version 4, remove this code completely to
        -:18146:	   implement not remaking deps if their deps are newer
        -:18147:	   than their parents.  */
    #####:18148:      if (d_mtime == (FILE_TIMESTAMP) -1 && !d->file->intermediate)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:18149:	/* We must remake if this dep does not
        -:18150:	   exist and is not intermediate.  */
    #####:18151:	must_make = 1;
        -:18152:#endif
        -:18153:
        -:18154:      /* Set DEPS_CHANGED if this dep actually changed.  */
    #####:18155:      deps_changed |= d->changed;
        -:18156:
        -:18157:      /* Set D->changed if either this dep actually changed,
        -:18158:	 or its dependent, FILE, is older or does not exist.  */
    #####:18159:      d->changed |= noexist || d_mtime > this_mtime;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:18160:
    #####:18161:      if (!noexist && ISDB (DB_BASIC|DB_VERBOSE))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:18162:	{
    #####:18163:          const char *fmt = 0;
        -:18164:
    #####:18165:	  if (d_mtime == (FILE_TIMESTAMP) -1)
branch  0 never executed
branch  1 never executed
        -:18166:            {
    #####:18167:              if (ISDB (DB_BASIC))
branch  0 never executed
branch  1 never executed
    #####:18168:                fmt = _("Prerequisite `%s' of target `%s' does not exist.\n");
        -:18169:            }
    #####:18170:	  else if (d->changed)
branch  0 never executed
branch  1 never executed
        -:18171:            {
    #####:18172:              if (ISDB (DB_BASIC))
branch  0 never executed
branch  1 never executed
    #####:18173:                fmt = _("Prerequisite `%s' is newer than target `%s'.\n");
        -:18174:            }
    #####:18175:          else if (ISDB (DB_VERBOSE))
branch  0 never executed
branch  1 never executed
    #####:18176:            fmt = _("Prerequisite `%s' is older than target `%s'.\n");
        -:18177:
    #####:18178:          if (fmt)
branch  0 never executed
branch  1 never executed
        -:18179:            {
    #####:18180:              print_spaces (depth);
call    0 never executed
    #####:18181:              printf (fmt, dep_name (d), file->name);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:18182:              fflush (stdout);
call    0 never executed
        -:18183:            }
        -:18184:	}
        -:18185:    }
        -:18186:
        -:18187:  /* Here depth returns to the value it had when we were called.  */
        1:18188:  depth--;
        -:18189:
       1*:18190:  if (file->double_colon && file->deps == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
branch  2 never executed
branch  3 never executed
        -:18191:    {
    #####:18192:      must_make = 1;
    #####:18193:      DBF (DB_BASIC,
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:18194:           _("Target `%s' is double-colon and has no prerequisites.\n"));
        -:18195:    }
       1*:18196:  else if (!noexist && file->is_target && !deps_changed && file->cmds == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -:18197:    {
    #####:18198:      must_make = 0;
    #####:18199:      DBF (DB_VERBOSE,
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:18200:           _("No commands for `%s' and no prerequisites actually changed.\n"));
        -:18201:    }
        -:18202:
        1:18203:  if (!must_make)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -:18204:    {
    #####:18205:      if (ISDB (DB_VERBOSE))
branch  0 never executed
branch  1 never executed
        -:18206:        {
    #####:18207:          print_spaces (depth);
call    0 never executed
    #####:18208:          printf (_("No need to remake target `%s'"), file->name);
call    0 never executed
    #####:18209:          if (!streq (file->name, file->hname))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:18210:              printf (_("; using VPATH name `%s'"), file->hname);
call    0 never executed
    #####:18211:          puts (".");
call    0 never executed
    #####:18212:          fflush (stdout);
call    0 never executed
        -:18213:        }
        -:18214:
    #####:18215:      notice_finished_file (file);
call    0 never executed
        -:18216:
        -:18217:      /* Since we don't need to remake the file, convert it to use the
        -:18218:         VPATH filename if we found one.  hfile will be either the
        -:18219:         local name if no VPATH or the VPATH name if one was found.  */
        -:18220:
    #####:18221:      while (file)
branch  0 never executed
branch  1 never executed
        -:18222:        {
    #####:18223:          file->name = file->hname;
    #####:18224:          file = file->prev;
        -:18225:        }
        -:18226:
    #####:18227:      return 0;
        -:18228:    }
        -:18229:
        1:18230:  DBF (DB_BASIC, _("Must remake target `%s'.\n"));
branch  0 taken 1 (fallthrough)
branch  1 taken 0
call    2 returned 1
call    3 returned 1
call    4 returned 1
        -:18231:
        -:18232:  /* It needs to be remade.  If it's VPATH and not reset via GPATH, toss the
        -:18233:     VPATH.  */
       1*:18234:  if (!streq(file->name, file->hname))
branch  0 taken 0 (fallthrough)
branch  1 taken 1
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -:18235:    {
    #####:18236:      DB (DB_BASIC, (_("  Ignoring VPATH name `%s'.\n"), file->hname));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####:18237:      file->ignore_vpath = 1;
        -:18238:    }
        -:18239:
        -:18240:  /* Now, take appropriate actions to remake the file.  */
        1:18241:  remake_file (file);
call    0 returned 0
        -:18242:
    #####:18243:  if (file->command_state != cs_finished)
branch  0 never executed
branch  1 never executed
        -:18244:    {
    #####:18245:      DBF (DB_VERBOSE, _("Commands of `%s' are being run.\n"));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:18246:      return 0;
        -:18247:    }
        -:18248:
    #####:18249:  switch (file->update_status)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:18250:    {
    #####:18251:    case 2:
    #####:18252:      DBF (DB_BASIC, _("Failed to remake target file `%s'.\n"));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:18253:      break;
    #####:18254:    case 0:
    #####:18255:      DBF (DB_BASIC, _("Successfully remade target file `%s'.\n"));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:18256:      break;
    #####:18257:    case 1:
    #####:18258:      DBF (DB_BASIC, _("Target file `%s' needs remade under -q.\n"));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:18259:      break;
    #####:18260:    default:
    #####:18261:      assert (file->update_status >= 0 && file->update_status <= 2);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:18262:      break;
        -:18263:    }
        -:18264:
    #####:18265:  file->updated = 1;
    #####:18266:  return file->update_status;
        -:18267:}
        -:18268:
        -:18269:/* Set FILE's `updated' flag and re-check its mtime and the mtime's of all
        -:18270:   files listed in its `also_make' member.  Under -t, this function also
        -:18271:   touches FILE.
        -:18272:
        -:18273:   On return, FILE->update_status will no longer be -1 if it was.  */
        -:18274:
        -:18275:void
function notice_finished_file called 0 returned 0% blocks executed 0%
    #####:18276:notice_finished_file (file)
        -:18277:     register struct file *file;
        -:18278:{
        -:18279:  struct dep *d;
    #####:18280:  int ran = file->command_state == cs_running;
        -:18281:
    #####:18282:  file->command_state = cs_finished;
    #####:18283:  file->updated = 1;
        -:18284:
    #####:18285:  if (touch_flag
branch  0 never executed
branch  1 never executed
        -:18286:      /* The update status will be:
        -:18287:	 	-1	if this target was not remade;
        -:18288:		0	if 0 or more commands (+ or ${MAKE}) were run and won;
        -:18289:		1	if some commands were run and lost.
        -:18290:	 We touch the target if it has commands which either were not run
        -:18291:	 or won when they ran (i.e. status is 0).  */
    #####:18292:      && file->update_status == 0)
branch  0 never executed
branch  1 never executed
        -:18293:    {
    #####:18294:      if (file->cmds != 0 && file->cmds->any_recurse)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:18295:	{
        -:18296:	  /* If all the command lines were recursive,
        -:18297:	     we don't want to do the touching.  */
        -:18298:	  unsigned int i;
    #####:18299:	  for (i = 0; i < file->cmds->ncommand_lines; ++i)
branch  0 never executed
branch  1 never executed
    #####:18300:	    if (!(file->cmds->lines_flags[i] & COMMANDS_RECURSE))
branch  0 never executed
branch  1 never executed
    #####:18301:	      goto have_nonrecursing;
        -:18302:	}
        -:18303:      else
        -:18304:	{
    #####:18305:	have_nonrecursing:
    #####:18306:	  if (file->phony)
branch  0 never executed
branch  1 never executed
    #####:18307:	    file->update_status = 0;
        -:18308:	  else
        -:18309:	    /* Should set file's modification date and do nothing else.  */
    #####:18310:	    file->update_status = touch_file (file);
call    0 never executed
        -:18311:	}
        -:18312:    }
        -:18313:
    #####:18314:  if (file->mtime_before_update == 0)
branch  0 never executed
branch  1 never executed
    #####:18315:    file->mtime_before_update = file->last_mtime;
        -:18316:
    #####:18317:  if (ran && !file->phony)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:18318:    {
        -:18319:      struct file *f;
    #####:18320:      int i = 0;
        -:18321:
        -:18322:      /* If -n or -q and all the commands are recursive, we ran them so
        -:18323:         really check the target's mtime again.  Otherwise, assume the target
        -:18324:         would have been updated. */
        -:18325:
    #####:18326:      if (question_flag || just_print_flag)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:18327:        {
    #####:18328:          for (i = file->cmds->ncommand_lines; i > 0; --i)
branch  0 never executed
branch  1 never executed
    #####:18329:            if (! (file->cmds->lines_flags[i-1] & COMMANDS_RECURSE))
branch  0 never executed
branch  1 never executed
    #####:18330:              break;
        -:18331:        }
        -:18332:
        -:18333:      /* If there were no commands at all, it's always new. */
        -:18334:
    #####:18335:      else if (file->is_target && file->cmds == 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:18336:	i = 1;
        -:18337:
    #####:18338:      file->last_mtime = i == 0 ? 0 : NEW_MTIME;
branch  0 never executed
branch  1 never executed
        -:18339:
        -:18340:      /* Propagate the change of modification time to all the double-colon
        -:18341:	 entries for this file.  */
    #####:18342:      for (f = file->double_colon; f != 0; f = f->next)
branch  0 never executed
branch  1 never executed
    #####:18343:	f->last_mtime = file->last_mtime;
        -:18344:    }
        -:18345:
    #####:18346:  if (ran && file->update_status != -1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:18347:    /* We actually tried to update FILE, which has
        -:18348:       updated its also_make's as well (if it worked).
        -:18349:       If it didn't work, it wouldn't work again for them.
        -:18350:       So mark them as updated with the same status.  */
    #####:18351:    for (d = file->also_make; d != 0; d = d->next)
branch  0 never executed
branch  1 never executed
        -:18352:      {
    #####:18353:	d->file->command_state = cs_finished;
    #####:18354:	d->file->updated = 1;
    #####:18355:	d->file->update_status = file->update_status;
        -:18356:
    #####:18357:	if (ran && !d->file->phony)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:18358:	  /* Fetch the new modification time.
        -:18359:	     We do this instead of just invalidating the cached time
        -:18360:	     so that a vpath_search can happen.  Otherwise, it would
        -:18361:	     never be done because the target is already updated.  */
    #####:18362:	  (void) f_mtime (d->file, 0);
call    0 never executed
        -:18363:      }
    #####:18364:  else if (file->update_status == -1)
branch  0 never executed
branch  1 never executed
        -:18365:    /* Nothing was done for FILE, but it needed nothing done.
        -:18366:       So mark it now as "succeeded".  */
    #####:18367:    file->update_status = 0;
    #####:18368:}
        -:18369:
        -:18370:/* Check whether another file (whose mtime is THIS_MTIME)
        -:18371:   needs updating on account of a dependency which is file FILE.
        -:18372:   If it does, store 1 in *MUST_MAKE_PTR.
        -:18373:   In the process, update any non-intermediate files
        -:18374:   that FILE depends on (including FILE itself).
        -:18375:   Return nonzero if any updating failed.  */
        -:18376:
        -:18377:static int
function check_dep called 0 returned 0% blocks executed 0%
    #####:18378:check_dep (file, depth, this_mtime, must_make_ptr)
        -:18379:     struct file *file;
        -:18380:     unsigned int depth;
        -:18381:     FILE_TIMESTAMP this_mtime;
        -:18382:     int *must_make_ptr;
        -:18383:{
        -:18384:  register struct dep *d;
    #####:18385:  int dep_status = 0;
        -:18386:
    #####:18387:  ++depth;
    #####:18388:  start_updating (file);
branch  0 never executed
branch  1 never executed
        -:18389:
    #####:18390:  if (!file->intermediate)
branch  0 never executed
branch  1 never executed
        -:18391:    /* If this is a non-intermediate file, update it and record
        -:18392:       whether it is newer than THIS_MTIME.  */
        -:18393:    {
        -:18394:      FILE_TIMESTAMP mtime;
    #####:18395:      dep_status = update_file (file, depth);
call    0 never executed
    #####:18396:      check_renamed (file);
branch  0 never executed
branch  1 never executed
    #####:18397:      mtime = file_mtime (file);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:18398:      check_renamed (file);
branch  0 never executed
branch  1 never executed
    #####:18399:      if (mtime == (FILE_TIMESTAMP) -1 || mtime > this_mtime)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:18400:	*must_make_ptr = 1;
        -:18401:    }
        -:18402:  else
        -:18403:    {
        -:18404:      /* FILE is an intermediate file.  */
        -:18405:      FILE_TIMESTAMP mtime;
        -:18406:
    #####:18407:      if (!file->phony && file->cmds == 0 && !file->tried_implicit)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:18408:	{
    #####:18409:	  if (try_implicit_rule (file, depth))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:18410:	    DBF (DB_IMPLICIT, _("Found an implicit rule for `%s'.\n"));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:18411:	  else
    #####:18412:	    DBF (DB_IMPLICIT, _("No implicit rule found for `%s'.\n"));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:18413:	  file->tried_implicit = 1;
        -:18414:	}
    #####:18415:      if (file->cmds == 0 && !file->is_target
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:18416:	  && default_file != 0 && default_file->cmds != 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:18417:	{
    #####:18418:	  DBF (DB_IMPLICIT, _("Using default commands for `%s'.\n"));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:18419:	  file->cmds = default_file->cmds;
        -:18420:	}
        -:18421:
        -:18422:      /* If the intermediate file actually exists
        -:18423:	 and is newer, then we should remake from it.  */
    #####:18424:      check_renamed (file);
branch  0 never executed
branch  1 never executed
    #####:18425:      mtime = file_mtime (file);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:18426:      check_renamed (file);
branch  0 never executed
branch  1 never executed
    #####:18427:      if (mtime != (FILE_TIMESTAMP) -1 && mtime > this_mtime)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:18428:	*must_make_ptr = 1;
        -:18429:	  /* Otherwise, update all non-intermediate files we depend on,
        -:18430:	     if necessary, and see whether any of them is more
        -:18431:	     recent than the file on whose behalf we are checking.  */
        -:18432:      else
        -:18433:	{
        -:18434:	  register struct dep *lastd;
        -:18435:
    #####:18436:	  lastd = 0;
    #####:18437:	  d = file->deps;
    #####:18438:	  while (d != 0)
branch  0 never executed
branch  1 never executed
        -:18439:	    {
    #####:18440:	      if (is_updating (d->file))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:18441:		{
    #####:18442:		  error (NILF, _("Circular %s <- %s dependency dropped."),
    #####:18443:			 file->name, d->file->name);
call    0 never executed
    #####:18444:		  if (lastd == 0)
branch  0 never executed
branch  1 never executed
        -:18445:		    {
    #####:18446:		      file->deps = d->next;
    #####:18447:		      free ((char *) d);
    #####:18448:		      d = file->deps;
        -:18449:		    }
        -:18450:		  else
        -:18451:		    {
    #####:18452:		      lastd->next = d->next;
    #####:18453:		      free ((char *) d);
    #####:18454:		      d = lastd->next;
        -:18455:		    }
    #####:18456:		  continue;
        -:18457:		}
        -:18458:
    #####:18459:	      d->file->parent = file;
    #####:18460:	      dep_status |= check_dep (d->file, depth, this_mtime,
call    0 never executed
        -:18461:                                       must_make_ptr);
    #####:18462:	      check_renamed (d->file);
branch  0 never executed
branch  1 never executed
    #####:18463:	      if (dep_status != 0 && !keep_going_flag)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:18464:		break;
        -:18465:
    #####:18466:	      if (d->file->command_state == cs_running
branch  0 never executed
branch  1 never executed
    #####:18467:		  || d->file->command_state == cs_deps_running)
branch  0 never executed
branch  1 never executed
        -:18468:		/* Record that some of FILE's deps are still being made.
        -:18469:		   This tells the upper levels to wait on processing it until
        -:18470:		   the commands are finished.  */
    #####:18471:		set_command_state (file, cs_deps_running);
call    0 never executed
        -:18472:
    #####:18473:	      lastd = d;
    #####:18474:	      d = d->next;
        -:18475:	    }
        -:18476:	}
        -:18477:    }
        -:18478:
    #####:18479:  finish_updating (file);
branch  0 never executed
branch  1 never executed
    #####:18480:  return dep_status;
        -:18481:}
        -:18482:
        -:18483:/* Touch FILE.  Return zero if successful, one if not.  */
        -:18484:
        -:18485:#define TOUCH_ERROR(call) return (perror_with_name (call, file->name), 1)
        -:18486:
        -:18487:static int
function touch_file called 0 returned 0% blocks executed 0%
    #####:18488:touch_file (file)
        -:18489:     register struct file *file;
        -:18490:{
    #####:18491:  if (!silent_flag)
branch  0 never executed
branch  1 never executed
    #####:18492:    message (0, "touch %s", file->name);
call    0 never executed
        -:18493:
        -:18494:#ifndef	NO_ARCHIVES
    #####:18495:  if (ar_name (file->name))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:18496:    return ar_touch (file->name);
call    0 never executed
        -:18497:  else
        -:18498:#endif
        -:18499:    {
    #####:18500:      int fd = open (file->name, O_RDWR | O_CREAT, 0666);
call    0 never executed
        -:18501:
    #####:18502:      if (fd < 0)
branch  0 never executed
branch  1 never executed
    #####:18503:	TOUCH_ERROR ("touch: open: ");
call    0 never executed
        -:18504:      else
        -:18505:	{
        -:18506:	  struct stat statbuf;
        -:18507:	  char buf;
        -:18508:	  int status;
        -:18509:
        -:18510:	  do
    #####:18511:	    status = fstat (fd, &statbuf);
call    0 never executed
    #####:18512:	  while (status < 0 && EINTR_SET);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:18513:
    #####:18514:	  if (status < 0)
branch  0 never executed
branch  1 never executed
    #####:18515:	    TOUCH_ERROR ("touch: fstat: ");
call    0 never executed
        -:18516:	  /* Rewrite character 0 same as it already is.  */
    #####:18517:	  if (read (fd, &buf, 1) < 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:18518:	    TOUCH_ERROR ("touch: read: ");
call    0 never executed
    #####:18519:	  if (off_t_equal(off_t_to_int(lseek (fd, int_to_off_t(0L), 0)), ZERO_L_off_t) < 0)
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -:18520:	    /*	  if (lseek (fd, 0L, 0) < 0L) */
    #####:18521:	    TOUCH_ERROR ("touch: lseek: ");
call    0 never executed
    #####:18522:	  if (write (fd, &buf, 1) < 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:18523:	    TOUCH_ERROR ("touch: write: ");
call    0 never executed
        -:18524:	  /* If file length was 0, we just
        -:18525:	     changed it, so change it back.  */
    #####:18526:	  if (off_t_equal(off_t_to_int(statbuf.st_size), ZERO_off_t) == 0)
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:18527:	    /*	  if (statbuf.st_size == 0) */
        -:18528:	    {
    #####:18529:	      (void) close (fd);
call    0 never executed
    #####:18530:	      fd = open (file->name, O_RDWR | O_TRUNC, 0666);
call    0 never executed
    #####:18531:	      if (fd < 0)
branch  0 never executed
branch  1 never executed
    #####:18532:		TOUCH_ERROR ("touch: open: ");
call    0 never executed
        -:18533:	    }
    #####:18534:	  (void) close (fd);
call    0 never executed
        -:18535:	}
        -:18536:    }
        -:18537:
    #####:18538:  return 0;
        -:18539:}
        -:18540:
        -:18541:/* Having checked and updated the dependencies of FILE,
        -:18542:   do whatever is appropriate to remake FILE itself.
        -:18543:   Return the status from executing FILE's commands.  */
        -:18544:
        -:18545:static void
function remake_file called 1 returned 0% blocks executed 35%
        1:18546:remake_file (file)
        -:18547:     struct file *file;
        -:18548:{
        1:18549:  if (file->cmds == 0)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -:18550:    {
        1:18551:      if (file->phony)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -:18552:	/* Phony target.  Pretend it succeeded.  */
    #####:18553:	file->update_status = 0;
        1:18554:      else if (file->is_target)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -:18555:	/* This is a nonexistent target file we cannot make.
        -:18556:	   Pretend it was successfully remade.  */
    #####:18557:	file->update_status = 0;
        -:18558:      else
        -:18559:        {
        -:18560:          const char *msg_noparent
        1:18561:            = _("%sNo rule to make target `%s'%s");
        -:18562:          const char *msg_parent
        1:18563:            = _("%sNo rule to make target `%s', needed by `%s'%s");
        -:18564:
        -:18565:          /* This is a dependency file we cannot remake.  Fail.  */
        1:18566:          if (!keep_going_flag && !file->dontcare)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
branch  2 taken 1 (fallthrough)
branch  3 taken 0
        -:18567:            {
        1:18568:              if (file->parent == 0)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:18569:                fatal (NILF, msg_noparent, "", file->name, "");
call    0 returned 0
        -:18570:
    #####:18571:              fatal (NILF, msg_parent, "", file->name, file->parent->name, "");
call    0 never executed
        -:18572:            }
        -:18573:
    #####:18574:          if (!file->dontcare)
branch  0 never executed
branch  1 never executed
        -:18575:            {
    #####:18576:              if (file->parent == 0)
branch  0 never executed
branch  1 never executed
    #####:18577:                error (NILF, msg_noparent, "*** ", file->name, ".");
call    0 never executed
        -:18578:              else
    #####:18579:                error (NILF, msg_parent, "*** ",
    #####:18580:                       file->name, file->parent->name, ".");
call    0 never executed
        -:18581:            }
    #####:18582:          file->update_status = 2;
        -:18583:        }
        -:18584:    }
        -:18585:  else
        -:18586:    {
    #####:18587:      chop_commands (file->cmds);
call    0 never executed
        -:18588:
        -:18589:      /* The normal case: start some commands.  */
    #####:18590:      if (!touch_flag || file->cmds->any_recurse)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:18591:	{
    #####:18592:	  execute_file_commands (file);
call    0 never executed
    #####:18593:	  return;
        -:18594:	}
        -:18595:
        -:18596:      /* This tells notice_finished_file it is ok to touch the file.  */
    #####:18597:      file->update_status = 0;
        -:18598:    }
        -:18599:
        -:18600:  /* This does the touching under -t.  */
    #####:18601:  notice_finished_file (file);
call    0 never executed
        -:18602:}
        -:18603:
        -:18604:/* Return the mtime of a file, given a `struct file'.
        -:18605:   Caches the time in the struct file to avoid excess stat calls.
        -:18606:
        -:18607:   If the file is not found, and SEARCH is nonzero, VPATH searching and
        -:18608:   replacement is done.  If that fails, a library (-lLIBNAME) is tried and
        -:18609:   the library's actual name (/lib/libLIBNAME.a, etc.) is substituted into
        -:18610:   FILE.  */
        -:18611:
        -:18612:FILE_TIMESTAMP
function f_mtime called 1 returned 100% blocks executed 18%
        1:18613:f_mtime (file, search)
        -:18614:     register struct file *file;
        -:18615:     int search;
        -:18616:{
        -:18617:  FILE_TIMESTAMP mtime;
        -:18618:
        -:18619:  /* File's mtime is not known; must get it from the system.  */
        -:18620:
        -:18621:#ifndef	NO_ARCHIVES
        1:18622:  if (ar_name (file->name))
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
        -:18623:    {
        -:18624:      /* This file is an archive-member reference.  */
        -:18625:
        -:18626:      char *arname, *memname;
        -:18627:      struct file *arfile;
    #####:18628:      int arname_used = 0;
        -:18629:
        -:18630:      /* Find the archive's name.  */
    #####:18631:      ar_parse_name (file->name, &arname, &memname);
call    0 never executed
        -:18632:
        -:18633:      /* Find the modification time of the archive itself.
        -:18634:	 Also allow for its name to be changed via VPATH search.  */
    #####:18635:      arfile = lookup_file (arname);
call    0 never executed
    #####:18636:      if (arfile == 0)
branch  0 never executed
branch  1 never executed
        -:18637:	{
    #####:18638:	  arfile = enter_file (arname);
call    0 never executed
    #####:18639:	  arname_used = 1;
        -:18640:	}
    #####:18641:      mtime = f_mtime (arfile, search);
call    0 never executed
    #####:18642:      check_renamed (arfile);
branch  0 never executed
branch  1 never executed
    #####:18643:      if (search && strcmp (arfile->hname, arname))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:18644:	{
        -:18645:	  /* The archive's name has changed.
        -:18646:	     Change the archive-member reference accordingly.  */
        -:18647:
        -:18648:          char *name;
        -:18649:	  unsigned int arlen, memlen;
        -:18650:
    #####:18651:	  if (!arname_used)
branch  0 never executed
branch  1 never executed
        -:18652:	    {
    #####:18653:	      free (arname);
    #####:18654:	      arname_used = 1;
        -:18655:	    }
        -:18656:
    #####:18657:	  arname = arfile->hname;
    #####:18658:	  arlen = strlen (arname);
    #####:18659:	  memlen = strlen (memname);
        -:18660:
        -:18661:	  /* free (file->name); */
        -:18662:
    #####:18663:	  name = (char *) xmalloc (arlen + 1 + memlen + 2);
call    0 never executed
    #####:18664:	  bcopy (arname, name, arlen);
    #####:18665:	  name[arlen] = '(';
    #####:18666:	  bcopy (memname, name + arlen + 1, memlen);
    #####:18667:	  name[arlen + 1 + memlen] = ')';
    #####:18668:	  name[arlen + 1 + memlen + 1] = '\0';
        -:18669:
        -:18670:          /* If the archive was found with GPATH, make the change permanent;
        -:18671:             otherwise defer it until later.  */
    #####:18672:          if (arfile->name == arfile->hname)
branch  0 never executed
branch  1 never executed
    #####:18673:            rename_file (file, name);
call    0 never executed
        -:18674:          else
    #####:18675:            rehash_file (file, name);
call    0 never executed
    #####:18676:          check_renamed (file);
branch  0 never executed
branch  1 never executed
        -:18677:	}
        -:18678:
    #####:18679:      if (!arname_used)
branch  0 never executed
branch  1 never executed
    #####:18680:	free (arname);
    #####:18681:      free (memname);
        -:18682:
    #####:18683:      if (mtime == (FILE_TIMESTAMP) -1)
branch  0 never executed
branch  1 never executed
        -:18684:	/* The archive doesn't exist, so it's members don't exist either.  */
    #####:18685:	return (FILE_TIMESTAMP) -1;
        -:18686:
    #####:18687:      mtime = FILE_TIMESTAMP_FROM_S_AND_NS (ar_member_date (file->hname), 0);
call    0 never executed
        -:18688:    }
        -:18689:  else
        -:18690:#endif
        -:18691:    {
        1:18692:      mtime = name_mtime (file->name);
call    0 returned 1
        -:18693:
       1*:18694:      if (mtime == (FILE_TIMESTAMP) -1 && search && !file->ignore_vpath)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 1
branch  4 never executed
branch  5 never executed
        -:18695:	{
        -:18696:	  /* If name_mtime failed, search VPATH.  */
    #####:18697:	  char *name = file->name;
    #####:18698:	  if (vpath_search (&name, &mtime)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:18699:	      /* Last resort, is it a library (-lxxx)?  */
    #####:18700:	      || (name[0] == '-' && name[1] == 'l'
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:18701:		  && library_search (&name, &mtime)))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:18702:	    {
    #####:18703:	      if (mtime != 0)
branch  0 never executed
branch  1 never executed
        -:18704:		/* vpath_search and library_search store zero in MTIME
        -:18705:		   if they didn't need to do a stat call for their work.  */
    #####:18706:		file->last_mtime = mtime;
        -:18707:
        -:18708:              /* If we found it in VPATH, see if it's in GPATH too; if so,
        -:18709:                 change the name right now; if not, defer until after the
        -:18710:                 dependencies are updated. */
    #####:18711:              if (gpath_search (name, strlen(name) - strlen(file->name) - 1))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:18712:                {
    #####:18713:                  rename_file (file, name);
call    0 never executed
    #####:18714:                  check_renamed (file);
branch  0 never executed
branch  1 never executed
    #####:18715:                  return file_mtime (file);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:18716:                }
        -:18717:
    #####:18718:	      rehash_file (file, name);
call    0 never executed
    #####:18719:	      check_renamed (file);
branch  0 never executed
branch  1 never executed
    #####:18720:	      mtime = name_mtime (name);
call    0 never executed
        -:18721:	    }
        -:18722:	}
        -:18723:    }
        -:18724:
        -:18725:  {
        -:18726:    /* Files can have bogus timestamps that nothing newly made will be
        -:18727:       "newer" than.  Updating their dependents could just result in loops.
        -:18728:       So notify the user of the anomaly with a warning.
        -:18729:
        -:18730:       We only need to do this once, for now. */
        -:18731:
        -:18732:    static FILE_TIMESTAMP now = 0;
        1:18733:    if (!clock_skew_detected
branch  0 taken 1 (fallthrough)
branch  1 taken 0
       1*:18734:        && mtime != (FILE_TIMESTAMP)-1 && mtime > now
branch  0 taken 0 (fallthrough)
branch  1 taken 1
branch  2 never executed
branch  3 never executed
    #####:18735:        && !file->updated)
branch  0 never executed
branch  1 never executed
        -:18736:      {
        -:18737:	/* This file's time appears to be in the future.
        -:18738:	   Update our concept of the present, and compare again.  */
        -:18739:
    #####:18740:	now = file_timestamp_now ();
call    0 never executed
        -:18741:
        -:18742:#ifdef WINDOWS32
        -:18743:	/*
        -:18744:	 * FAT filesystems round time to nearest even second(!). Just
        -:18745:	 * allow for any file (NTFS or FAT) to perhaps suffer from this
        -:18746:	 * braindamage.
        -:18747:	 */
        -:18748:	if (mtime > now && (((mtime % 2) == 0) && ((mtime-1) > now)))
        -:18749:#else
        -:18750:#ifdef __MSDOS__
        -:18751:	/* Scrupulous testing indicates that some Windows
        -:18752:	   filesystems can set file times up to 3 sec into the future!  */
        -:18753:	if (mtime > now + 3)
        -:18754:#else
    #####:18755:        if (mtime > now)
branch  0 never executed
branch  1 never executed
        -:18756:#endif
        -:18757:#endif
        -:18758:          {
        -:18759:	    char mtimebuf[FILE_TIMESTAMP_PRINT_LEN_BOUND + 1];
        -:18760:	    char nowbuf[FILE_TIMESTAMP_PRINT_LEN_BOUND + 1];
        -:18761:
    #####:18762:	    file_timestamp_sprintf (mtimebuf, mtime);
call    0 never executed
    #####:18763:	    file_timestamp_sprintf (nowbuf, now);
call    0 never executed
    #####:18764:            error (NILF, _("*** Warning: File `%s' has modification time in the future (%s > %s)"),
call    0 never executed
        -:18765:                   file->name, mtimebuf, nowbuf);
    #####:18766:            clock_skew_detected = 1;
        -:18767:          }
        -:18768:      }
        -:18769:  }
        -:18770:
        -:18771:  /* Store the mtime into all the entries for this file.  */
        1:18772:  if (file->double_colon)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:18773:    file = file->double_colon;
        -:18774:
        -:18775:  do
        -:18776:    {
        -:18777:      /* If this file is not implicit but it is intermediate then it was
        -:18778:	 made so by the .INTERMEDIATE target.  If this file has never
        -:18779:	 been built by us but was found now, it existed before make
        -:18780:	 started.  So, turn off the intermediate bit so make doesn't
        -:18781:	 delete it, since it didn't create it.  */
       1*:18782:      if (mtime != (FILE_TIMESTAMP)-1 && file->command_state == cs_not_started
branch  0 taken 0 (fallthrough)
branch  1 taken 1
branch  2 never executed
branch  3 never executed
    #####:18783:	  && !file->tried_implicit && file->intermediate)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:18784:	file->intermediate = 0;
        -:18785:
        1:18786:      file->last_mtime = mtime;
        1:18787:      file = file->prev;
        -:18788:    }
        1:18789:  while (file != 0);
branch  0 taken 0
branch  1 taken 1 (fallthrough)
        -:18790:
        1:18791:  return mtime;
        -:18792:}
        -:18793:
        -:18794:
        -:18795:/* Return the mtime of the file or archive-member reference NAME.  */
        -:18796:
        -:18797:static FILE_TIMESTAMP
function name_mtime called 1 returned 100% blocks executed 83%
        1:18798:name_mtime (name)
        -:18799:     register char *name;
        -:18800:{
        -:18801:  struct stat st;
        -:18802:
        1:18803:  if (stat (name, &st) < 0)
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0
        1:18804:    return (FILE_TIMESTAMP) -1;
        -:18805:
    #####:18806:  return FILE_TIMESTAMP_STAT_MODTIME (st);
        -:18807:}
        -:18808:
        -:18809:
        -:18810:/* Search for a library file specified as -lLIBNAME, searching for a
        -:18811:   suitable library file in the system library directories and the VPATH
        -:18812:   directories.  */
        -:18813:
        -:18814:static int
function library_search called 0 returned 0% blocks executed 0%
    #####:18815:library_search (lib, mtime_ptr)
        -:18816:     char **lib;
        -:18817:     FILE_TIMESTAMP *mtime_ptr;
        -:18818:{
        -:18819:  static char *dirs[] =
        -:18820:    {
        -:18821:#ifndef _AMIGA
        -:18822:      "/lib",
        -:18823:      "/usr/lib",
        -:18824:#endif
        -:18825:#if defined(WINDOWS32) && !defined(LIBDIR)
        -:18826:/*
        -:18827: * This is completely up to the user at product install time. Just define
        -:18828: * a placeholder.
        -:18829: */
        -:18830:#define LIBDIR "."
        -:18831:#endif
        -:18832:      LIBDIR,			/* Defined by configuration.  */
        -:18833:      0
        -:18834:    };
        -:18835:
        -:18836:  static char *libpatterns = NULL;
        -:18837:
    #####:18838:  char *libname = &(*lib)[2];	/* Name without the `-l'.  */
        -:18839:  FILE_TIMESTAMP mtime;
        -:18840:
        -:18841:  /* Loop variables for the libpatterns value.  */
        -:18842:  char *p, *p2;
        -:18843:  unsigned int len;
        -:18844:
        -:18845:  char *file, **dp;
        -:18846:
        -:18847:  /* If we don't have libpatterns, get it.  */
    #####:18848:  if (!libpatterns)
branch  0 never executed
branch  1 never executed
        -:18849:    {
    #####:18850:      int save = warn_undefined_variables_flag;
    #####:18851:      warn_undefined_variables_flag = 0;
        -:18852:
    #####:18853:      libpatterns = xstrdup (variable_expand ("$(strip $(.LIBPATTERNS))"));
call    0 never executed
call    1 never executed
        -:18854:
    #####:18855:      warn_undefined_variables_flag = save;
        -:18856:    }
        -:18857:
        -:18858:  /* Loop through all the patterns in .LIBPATTERNS, and search on each one.  */
    #####:18859:  p2 = libpatterns;
    #####:18860:  while ((p = find_next_token (&p2, &len)) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:18861:    {
        -:18862:      static char *buf = NULL;
        -:18863:      static int buflen = 0;
        -:18864:      static int libdir_maxlen = -1;
    #####:18865:      char *libbuf = variable_expand ("");
call    0 never executed
        -:18866:
        -:18867:      /* Expand the pattern using LIBNAME as a replacement.  */
        -:18868:      {
    #####:18869:	char c = p[len];
        -:18870:	char *p3, *p4;
        -:18871:
    #####:18872:	p[len] = '\0';
    #####:18873:	p3 = find_percent (p);
call    0 never executed
    #####:18874:	if (!p3)
branch  0 never executed
branch  1 never executed
        -:18875:	  {
        -:18876:	    /* Give a warning if there is no pattern, then remove the
        -:18877:	       pattern so it's ignored next time.  */
    #####:18878:	    error (NILF, _(".LIBPATTERNS element `%s' is not a pattern"), p);
call    0 never executed
    #####:18879:	    for (; len; --len, ++p)
branch  0 never executed
branch  1 never executed
    #####:18880:	      *p = ' ';
    #####:18881:	    *p = c;
    #####:18882:	    continue;
        -:18883:	  }
    #####:18884:	p4 = variable_buffer_output (libbuf, p, p3-p);
call    0 never executed
    #####:18885:	p4 = variable_buffer_output (p4, libname, strlen (libname));
call    0 never executed
    #####:18886:	p4 = variable_buffer_output (p4, p3+1, len - (p3-p));
call    0 never executed
    #####:18887:	p[len] = c;
        -:18888:      }
        -:18889:
        -:18890:      /* Look first for `libNAME.a' in the current directory.  */
    #####:18891:      mtime = name_mtime (libbuf);
call    0 never executed
    #####:18892:      if (mtime != (FILE_TIMESTAMP) -1)
branch  0 never executed
branch  1 never executed
        -:18893:	{
    #####:18894:	  *lib = xstrdup (libbuf);
call    0 never executed
    #####:18895:	  if (mtime_ptr != 0)
branch  0 never executed
branch  1 never executed
    #####:18896:	    *mtime_ptr = mtime;
    #####:18897:	  return 1;
        -:18898:	}
        -:18899:
        -:18900:      /* Now try VPATH search on that.  */
        -:18901:
    #####:18902:      file = libbuf;
    #####:18903:      if (vpath_search (&file, mtime_ptr))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:18904:	{
    #####:18905:	  *lib = file;
    #####:18906:	  return 1;
        -:18907:	}
        -:18908:
        -:18909:      /* Now try the standard set of directories.  */
        -:18910:
    #####:18911:      if (!buflen)
branch  0 never executed
branch  1 never executed
        -:18912:	{
    #####:18913:	  for (dp = dirs; *dp != 0; ++dp)
branch  0 never executed
branch  1 never executed
        -:18914:	    {
    #####:18915:	      int l = strlen (*dp);
    #####:18916:	      if (l > libdir_maxlen)
branch  0 never executed
branch  1 never executed
    #####:18917:		libdir_maxlen = l;
        -:18918:	    }
    #####:18919:	  buflen = strlen (libbuf);
    #####:18920:	  buf = xmalloc(libdir_maxlen + buflen + 2);
call    0 never executed
        -:18921:	}
    #####:18922:      else if (buflen < strlen (libbuf))
branch  0 never executed
branch  1 never executed
        -:18923:	{
    #####:18924:	  buflen = strlen (libbuf);
    #####:18925:	  buf = xrealloc (buf, libdir_maxlen + buflen + 2);
call    0 never executed
        -:18926:	}
        -:18927:
    #####:18928:      for (dp = dirs; *dp != 0; ++dp)
branch  0 never executed
branch  1 never executed
        -:18929:	{
    #####:18930:	  sprintf (buf, "%s/%s", *dp, libbuf);
    #####:18931:	  mtime = name_mtime (buf);
call    0 never executed
    #####:18932:	  if (mtime != (FILE_TIMESTAMP) -1)
branch  0 never executed
branch  1 never executed
        -:18933:	    {
    #####:18934:	      *lib = xstrdup (buf);
call    0 never executed
    #####:18935:	      if (mtime_ptr != 0)
branch  0 never executed
branch  1 never executed
    #####:18936:		*mtime_ptr = mtime;
    #####:18937:	      return 1;
        -:18938:	    }
        -:18939:	}
        -:18940:    }
        -:18941:
    #####:18942:  return 0;
        -:18943:}
        -:18944:
        -:18945:
        -:18946:
        -:18947:/*************************************************************
        -:18948:  ============================================================
        -:18949:  ************************************************************
        -:18950:  ============================================================
        -:18951:  ************************************************************
        -:18952:                         rule.c
        -:18953:  ************************************************************
        -:18954:  ============================================================
        -:18955:  ************************************************************
        -:18956:  ============================================================
        -:18957:  *************************************************************/
        -:18958:
        -:18959:/* Pattern and suffix rule internals for GNU Make.
        -:18960:Copyright (C) 1988,89,90,91,92,93, 1998 Free Software Foundation, Inc.
        -:18961:This file is part of GNU Make.
        -:18962:
        -:18963:GNU Make is free software; you can redistribute it and/or modify
        -:18964:it under the terms of the GNU General Public License as published by
        -:18965:the Free Software Foundation; either version 2, or (at your option)
        -:18966:any later version.
        -:18967:
        -:18968:GNU Make is distributed in the hope that it will be useful,
        -:18969:but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:18970:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:18971:GNU General Public License for more details.
        -:18972:
        -:18973:You should have received a copy of the GNU General Public License
        -:18974:along with GNU Make; see the file COPYING.  If not, write to
        -:18975:the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
        -:18976:Boston, MA 02111-1307, USA.  */
        -:18977:
        -:18978:/* #include "make.h"  <- modification by J.Ruthruff, 7/28 */
        -:18979:/* #include "dep.h"  <- modification by J.Ruthruff, 7/28 */
        -:18980:/* #include "filedef.h"  <- modification by J.Ruthruff, 7/28 */
        -:18981:#include "job.h"
        -:18982:/* #include "commands.h"  <- modification by J.Ruthruff, 7/28 */
        -:18983:/* #include "variable.h"  <- modification by J.Ruthruff, 7/28 */
        -:18984:/* #include "rule.h"  <- modification by J.Ruthruff, 7/28 */
        -:18985:#undef stderr
        -:18986:#define stderr stdout
        -:18987:
        -:18988:static void freerule PARAMS ((struct rule *rule, struct rule *lastrule));
        -:18989:
        -:18990:/* Chain of all pattern rules.  */
        -:18991:
        -:18992:struct rule *pattern_rules;
        -:18993:
        -:18994:/* Pointer to last rule in the chain, so we can add onto the end.  */
        -:18995:
        -:18996:struct rule *last_pattern_rule;
        -:18997:
        -:18998:/* Number of rules in the chain.  */
        -:18999:
        -:19000:unsigned int num_pattern_rules;
        -:19001:
        -:19002:/* Maximum number of target patterns of any pattern rule.  */
        -:19003:
        -:19004:unsigned int max_pattern_targets;
        -:19005:
        -:19006:/* Maximum number of dependencies of any pattern rule.  */
        -:19007:
        -:19008:unsigned int max_pattern_deps;
        -:19009:
        -:19010:/* Maximum length of the name of a dependencies of any pattern rule.  */
        -:19011:
        -:19012:unsigned int max_pattern_dep_length;
        -:19013:
        -:19014:/* Chain of all pattern-specific variables.  */
        -:19015:
        -:19016:static struct pattern_var *pattern_vars;
        -:19017:
        -:19018:/* Pointer to last struct in the chain, so we can add onto the end.  */
        -:19019:
        -:19020:static struct pattern_var *last_pattern_var;
        -:19021:
        -:19022:/* Pointer to structure for the file .SUFFIXES
        -:19023:   whose dependencies are the suffixes to be searched.  */
        -:19024:
        -:19025:struct file *suffix_file;
        -:19026:
        -:19027:/* Maximum length of a suffix.  */
        -:19028:
        -:19029:unsigned int maxsuffix;
        -:19030:
        -:19031:/* Compute the maximum dependency length and maximum number of
        -:19032:   dependencies of all implicit rules.  Also sets the subdir
        -:19033:   flag for a rule when appropriate, possibly removing the rule
        -:19034:   completely when appropriate.  */
        -:19035:
        -:19036:void
function count_implicit_rule_limits called 1 returned 100% blocks executed 92%
        1:19037:count_implicit_rule_limits ()
        -:19038:{
        -:19039:  char *name;
        -:19040:  unsigned int namelen;
        -:19041:  register struct rule *rule, *lastrule;
        -:19042:
        1:19043:  num_pattern_rules = max_pattern_targets = max_pattern_deps = 0;
        1:19044:  max_pattern_dep_length = 0;
        -:19045:
        1:19046:  name = 0;
        1:19047:  namelen = 0;
        1:19048:  rule = pattern_rules;
        1:19049:  lastrule = 0;
       87:19050:  while (rule != 0)
branch  0 taken 86
branch  1 taken 1 (fallthrough)
        -:19051:    {
       86:19052:      unsigned int ndeps = 0;
        -:19053:      register struct dep *dep;
       86:19054:      struct rule *next = rule->next;
        -:19055:      unsigned int ntargets;
        -:19056:
       86:19057:      ++num_pattern_rules;
        -:19058:
       86:19059:      ntargets = 0;
      172:19060:      while (rule->targets[ntargets] != 0)
branch  0 taken 86
branch  1 taken 86 (fallthrough)
       86:19061:	++ntargets;
        -:19062:
       86:19063:      if (ntargets > max_pattern_targets)
branch  0 taken 1 (fallthrough)
branch  1 taken 85
        1:19064:	max_pattern_targets = ntargets;
        -:19065:
      142:19066:      for (dep = rule->deps; dep != 0; dep = dep->next)
branch  0 taken 56
branch  1 taken 86 (fallthrough)
        -:19067:	{
       56:19068:	  unsigned int len = strlen (dep->name);
        -:19069:
        -:19070:#ifdef VMS
        -:19071:	  char *p = strrchr (dep->name, ']');
        -:19072:          char *p2;
        -:19073:          if (p == 0)
        -:19074:            p = strrchr (dep->name, ':');
        -:19075:          p2 = p != 0 ? strchr (dep->name, '%') : 0;
        -:19076:#else
       56:19077:	  char *p = strrchr (dep->name, '/');
       56:19078:	  char *p2 = p != 0 ? strchr (dep->name, '%') : 0;
branch  0 taken 3 (fallthrough)
branch  1 taken 53
        -:19079:#endif
       56:19080:	  ndeps++;
        -:19081:
       56:19082:	  if (len > max_pattern_dep_length)
branch  0 taken 4 (fallthrough)
branch  1 taken 52
        4:19083:	    max_pattern_dep_length = len;
        -:19084:
       56:19085:	  if (p != 0 && p2 > p)
branch  0 taken 3 (fallthrough)
branch  1 taken 53
branch  2 taken 3 (fallthrough)
branch  3 taken 0
        -:19086:	    {
        -:19087:	      /* There is a slash before the % in the dep name.
        -:19088:		 Extract the directory name.  */
        3:19089:	      if (p == dep->name)
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####:19090:		++p;
        3:19091:	      if (p - dep->name > namelen)
branch  0 taken 2 (fallthrough)
branch  1 taken 1
        -:19092:		{
        2:19093:		  if (name != 0)
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        1:19094:		    free (name);
        2:19095:		  namelen = p - dep->name;
        2:19096:		  name = (char *) xmalloc (namelen + 1);
call    0 returned 2
        -:19097:		}
        3:19098:	      bcopy (dep->name, name, p - dep->name);
        3:19099:	      name[p - dep->name] = '\0';
        -:19100:
        -:19101:	      /* In the deps of an implicit rule the `changed' flag
        -:19102:		 actually indicates that the dependency is in a
        -:19103:		 nonexistent subdirectory.  */
        -:19104:
        3:19105:	      dep->changed = !dir_file_exists_p (name, "");
call    0 returned 3
        -:19106:#ifdef VMS
        -:19107:              if (dep->changed && strchr (name, ':') != 0)
        -:19108:#else
        3:19109:	      if (dep->changed && *name == '/')
branch  0 taken 3 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 3
        -:19110:#endif
        -:19111:		{
        -:19112:		  /* The name is absolute and the directory does not exist.
        -:19113:		     This rule can never possibly match, since this dependency
        -:19114:		     can never possibly exist.  So just remove the rule from
        -:19115:		     the list.  */
    #####:19116:		  freerule (rule, lastrule);
call    0 never executed
    #####:19117:		  --num_pattern_rules;
    #####:19118:		  goto end_main_loop;
        -:19119:		}
        -:19120:	    }
        -:19121:	  else
        -:19122:	    /* This dependency does not reside in a subdirectory.  */
       53:19123:	    dep->changed = 0;
        -:19124:	}
        -:19125:
       86:19126:      if (ndeps > max_pattern_deps)
branch  0 taken 2 (fallthrough)
branch  1 taken 84
        2:19127:	max_pattern_deps = ndeps;
        -:19128:
       86:19129:      lastrule = rule;
       86:19130:    end_main_loop:
       86:19131:      rule = next;
        -:19132:    }
        -:19133:
        1:19134:  if (name != 0)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:19135:    free (name);
        1:19136:}
        -:19137:
        -:19138:/* Create a pattern rule from a suffix rule.
        -:19139:   TARGET is the target suffix; SOURCE is the source suffix.
        -:19140:   CMDS are the commands.
        -:19141:   If TARGET is nil, it means the target pattern should be `(%.o)'.
        -:19142:   If SOURCE is nil, it means there should be no deps.  */
        -:19143:
        -:19144:static void
function convert_suffix_rule called 77 returned 100% blocks executed 85%
       77:19145:convert_suffix_rule (target, source, cmds)
        -:19146:     char *target, *source;
        -:19147:     struct commands *cmds;
        -:19148:{
        -:19149:  char *targname, *targpercent, *depname;
        -:19150:  char **names, **percents;
        -:19151:  struct dep *deps;
        -:19152:  unsigned int len;
        -:19153:
       77:19154:  if (target == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 77
        -:19155:    /* Special case: TARGET being nil means we are defining a
        -:19156:       `.X.a' suffix rule; the target pattern is always `(%.o)'.  */
        -:19157:    {
        -:19158:#ifdef VMS
        -:19159:      targname = savestring ("(%.obj)", 7);
        -:19160:#else
    #####:19161:      targname = savestring ("(%.o)", 5);
call    0 never executed
        -:19162:#endif
    #####:19163:      targpercent = targname + 1;
        -:19164:    }
        -:19165:  else
        -:19166:    {
        -:19167:      /* Construct the target name.  */
       77:19168:      len = strlen (target);
       77:19169:      targname = xmalloc (1 + len + 1);
call    0 returned 77
       77:19170:      targname[0] = '%';
       77:19171:      bcopy (target, targname + 1, len + 1);
       77:19172:      targpercent = targname;
        -:19173:    }
        -:19174:
       77:19175:  names = (char **) xmalloc (2 * sizeof (char *));
call    0 returned 77
       77:19176:  percents = (char **) alloca (2 * sizeof (char *));
       77:19177:  names[0] = targname;
       77:19178:  percents[0] = targpercent;
       77:19179:  names[1] = percents[1] = 0;
        -:19180:
       77:19181:  if (source == 0)
branch  0 taken 32 (fallthrough)
branch  1 taken 45
       32:19182:    deps = 0;
        -:19183:  else
        -:19184:    {
        -:19185:      /* Construct the dependency name.  */
       45:19186:      len = strlen (source);
       45:19187:      depname = xmalloc (1 + len + 1);
call    0 returned 45
       45:19188:      depname[0] = '%';
       45:19189:      bcopy (source, depname + 1, len + 1);
       45:19190:      deps = (struct dep *) xmalloc (sizeof (struct dep));
call    0 returned 45
       45:19191:      deps->next = 0;
       45:19192:      deps->name = depname;
        -:19193:    }
        -:19194:
       77:19195:  create_pattern_rule (names, percents, 0, deps, cmds, 0);
call    0 returned 77
       77:19196:}
        -:19197:
        -:19198:/* Convert old-style suffix rules to pattern rules.
        -:19199:   All rules for the suffixes on the .SUFFIXES list
        -:19200:   are converted and added to the chain of pattern rules.  */
        -:19201:
        -:19202:void
function convert_to_pattern called 1 returned 100% blocks executed 75%
        1:19203:convert_to_pattern ()
        -:19204:{
        -:19205:  register struct dep *d, *d2;
        -:19206:  register struct file *f;
        -:19207:  register char *rulename;
        -:19208:  register unsigned int slen, s2len;
        -:19209:
        -:19210:  /* Compute maximum length of all the suffixes.  */
        -:19211:
        1:19212:  maxsuffix = 0;
       33:19213:  for (d = suffix_file->deps; d != 0; d = d->next)
branch  0 taken 32
branch  1 taken 1 (fallthrough)
        -:19214:    {
      32*:19215:      register unsigned int namelen = strlen (dep_name (d));
branch  0 taken 32 (fallthrough)
branch  1 taken 0
       32:19216:      if (namelen > maxsuffix)
branch  0 taken 3 (fallthrough)
branch  1 taken 29
        3:19217:	maxsuffix = namelen;
        -:19218:    }
        -:19219:
        1:19220:  rulename = (char *) alloca ((maxsuffix * 2) + 1);
        -:19221:
       33:19222:  for (d = suffix_file->deps; d != 0; d = d->next)
branch  0 taken 32
branch  1 taken 1 (fallthrough)
        -:19223:    {
        -:19224:      /* Make a rule that is just the suffix, with no deps or commands.
        -:19225:	 This rule exists solely to disqualify match-anything rules.  */
      32*:19226:      convert_suffix_rule (dep_name (d), (char *) 0, (struct commands *) 0);
branch  0 taken 32 (fallthrough)
branch  1 taken 0
call    2 returned 32
        -:19227:
       32:19228:      f = d->file;
       32:19229:      if (f->cmds != 0)
branch  0 taken 13 (fallthrough)
branch  1 taken 19
        -:19230:	/* Record a pattern for this suffix's null-suffix rule.  */
      13*:19231:	convert_suffix_rule ("", dep_name (d), f->cmds);
branch  0 taken 13 (fallthrough)
branch  1 taken 0
call    2 returned 13
        -:19232:
        -:19233:      /* Record a pattern for each of this suffix's two-suffix rules.  */
      32*:19234:      slen = strlen (dep_name (d));
branch  0 taken 32 (fallthrough)
branch  1 taken 0
      32*:19235:      bcopy (dep_name (d), rulename, slen);
branch  0 taken 32 (fallthrough)
branch  1 taken 0
     1056:19236:      for (d2 = suffix_file->deps; d2 != 0; d2 = d2->next)
branch  0 taken 1024
branch  1 taken 32 (fallthrough)
        -:19237:	{
    1024*:19238:	  s2len = strlen (dep_name (d2));
branch  0 taken 1024 (fallthrough)
branch  1 taken 0
        -:19239:
    1024*:19240:	  if (slen == s2len && streq (dep_name (d), dep_name (d2)))
branch  0 taken 308 (fallthrough)
branch  1 taken 716
branch  2 taken 308 (fallthrough)
branch  3 taken 0
branch  4 taken 308 (fallthrough)
branch  5 taken 0
branch  6 taken 276 (fallthrough)
branch  7 taken 32
branch  8 taken 276 (fallthrough)
branch  9 taken 0
branch 10 taken 276 (fallthrough)
branch 11 taken 0
branch 12 taken 276 (fallthrough)
branch 13 taken 0
branch 14 taken 276 (fallthrough)
branch 15 taken 0
branch 16 taken 276 (fallthrough)
branch 17 taken 0
branch 18 taken 276 (fallthrough)
branch 19 taken 0
branch 20 taken 276 (fallthrough)
branch 21 taken 0
branch 22 taken 0 (fallthrough)
branch 23 taken 276
       32:19241:	    continue;
        -:19242:
     992*:19243:	  bcopy (dep_name (d2), rulename + slen, s2len + 1);
branch  0 taken 992 (fallthrough)
branch  1 taken 0
      992:19244:	  f = lookup_file (rulename);
call    0 returned 992
      992:19245:	  if (f == 0 || f->cmds == 0)
branch  0 taken 32 (fallthrough)
branch  1 taken 960
branch  2 taken 0 (fallthrough)
branch  3 taken 32
      960:19246:	    continue;
        -:19247:
       32:19248:	  if (s2len == 2 && rulename[slen] == '.' && rulename[slen + 1] == 'a')
branch  0 taken 19 (fallthrough)
branch  1 taken 13
branch  2 taken 19 (fallthrough)
branch  3 taken 0
branch  4 taken 0 (fallthrough)
branch  5 taken 19
        -:19249:	    /* A suffix rule `.X.a:' generates the pattern rule `(%.o): %.X'.
        -:19250:	       It also generates a normal `%.a: %.X' rule below.  */
    #####:19251:	    convert_suffix_rule ((char *) 0, /* Indicates `(%.o)'.  */
call    0 never executed
    #####:19252:				 dep_name (d),
branch  0 never executed
branch  1 never executed
        -:19253:				 f->cmds);
        -:19254:
        -:19255:	  /* The suffix rule `.X.Y:' is converted
        -:19256:	     to the pattern rule `%.Y: %.X'.  */
      32*:19257:	  convert_suffix_rule (dep_name (d2), dep_name (d), f->cmds);
branch  0 taken 32 (fallthrough)
branch  1 taken 0
branch  2 taken 32 (fallthrough)
branch  3 taken 0
call    4 returned 32
        -:19258:	}
        -:19259:    }
        1:19260:}
        -:19261:
        -:19262:
        -:19263:/* Install the pattern rule RULE (whose fields have been filled in)
        -:19264:   at the end of the list (so that any rules previously defined
        -:19265:   will take precedence).  If this rule duplicates a previous one
        -:19266:   (identical target and dependencies), the old one is replaced
        -:19267:   if OVERRIDE is nonzero, otherwise this new one is thrown out.
        -:19268:   When an old rule is replaced, the new one is put at the end of the
        -:19269:   list.  Return nonzero if RULE is used; zero if not.  */
        -:19270:
        -:19271:int
function new_pattern_rule called 86 returned 100% blocks executed 74%
       86:19272:new_pattern_rule (rule, override)
        -:19273:     register struct rule *rule;
        -:19274:     int override;
        -:19275:{
        -:19276:  register struct rule *r, *lastrule;
        -:19277:  register unsigned int i, j;
        -:19278:
       86:19279:  rule->in_use = 0;
       86:19280:  rule->terminal = 0;
        -:19281:
       86:19282:  rule->next = 0;
        -:19283:
        -:19284:  /* Search for an identical rule.  */
       86:19285:  lastrule = 0;
     3741:19286:  for (r = pattern_rules; r != 0; lastrule = r, r = r->next)
branch  0 taken 3655
branch  1 taken 86 (fallthrough)
     7310:19287:    for (i = 0; rule->targets[i] != 0; ++i)
branch  0 taken 3655
branch  1 taken 3655 (fallthrough)
        -:19288:      {
     3920:19289:	for (j = 0; r->targets[j] != 0; ++j)
branch  0 taken 3655
branch  1 taken 265 (fallthrough)
     3655:19290:	  if (!streq (rule->targets[i], r->targets[j]))
branch  0 taken 3655 (fallthrough)
branch  1 taken 0
branch  2 taken 3570 (fallthrough)
branch  3 taken 85
branch  4 taken 3570 (fallthrough)
branch  5 taken 0
branch  6 taken 265 (fallthrough)
branch  7 taken 3305
        -:19291:	    break;
     3655:19292:	if (r->targets[j] == 0)
branch  0 taken 265 (fallthrough)
branch  1 taken 3390
        -:19293:	  /* All the targets matched.  */
        -:19294:	  {
        -:19295:	    register struct dep *d, *d2;
      265:19296:	    for (d = rule->deps, d2 = r->deps;
      267:19297:		 d != 0 && d2 != 0; d = d->next, d2 = d2->next)
branch  0 taken 267 (fallthrough)
branch  1 taken 0
branch  2 taken 230
branch  3 taken 37 (fallthrough)
     230*:19298:	      if (!streq (dep_name (d), dep_name (d2)))
branch  0 taken 0 (fallthrough)
branch  1 taken 230
branch  2 taken 0 (fallthrough)
branch  3 taken 230
branch  4 taken 230 (fallthrough)
branch  5 taken 0
branch  6 taken 0 (fallthrough)
branch  7 taken 230
branch  8 taken 0 (fallthrough)
branch  9 taken 230
branch 10 taken 169 (fallthrough)
branch 11 taken 61
branch 12 taken 0 (fallthrough)
branch 13 taken 169
branch 14 taken 169 (fallthrough)
branch 15 taken 0
branch 16 taken 0 (fallthrough)
branch 17 taken 169
branch 18 taken 0 (fallthrough)
branch 19 taken 169
branch 20 taken 2 (fallthrough)
branch 21 taken 167
        -:19299:		break;
     265*:19300:	    if (d == 0 && d2 == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 265
branch  2 never executed
branch  3 never executed
        -:19301:	      {
        -:19302:		/* All the dependencies matched.  */
    #####:19303:		if (override)
branch  0 never executed
branch  1 never executed
        -:19304:		  {
        -:19305:		    /* Remove the old rule.  */
    #####:19306:		    freerule (r, lastrule);
call    0 never executed
        -:19307:		    /* Install the new one.  */
    #####:19308:		    if (pattern_rules == 0)
branch  0 never executed
branch  1 never executed
    #####:19309:		      pattern_rules = rule;
        -:19310:		    else
    #####:19311:		      last_pattern_rule->next = rule;
    #####:19312:		    last_pattern_rule = rule;
        -:19313:
        -:19314:		    /* We got one.  Stop looking.  */
    #####:19315:		    goto matched;
        -:19316:		  }
        -:19317:		else
        -:19318:		  {
        -:19319:		    /* The old rule stays intact.  Destroy the new one.  */
    #####:19320:		    freerule (rule, (struct rule *) 0);
call    0 never executed
    #####:19321:		    return 0;
        -:19322:		  }
        -:19323:	      }
        -:19324:	  }
        -:19325:      }
        -:19326:
       86:19327: matched:;
        -:19328:
       86:19329:  if (r == 0)
branch  0 taken 86 (fallthrough)
branch  1 taken 0
        -:19330:    {
        -:19331:      /* There was no rule to replace.  */
       86:19332:      if (pattern_rules == 0)
branch  0 taken 1 (fallthrough)
branch  1 taken 85
        1:19333:	pattern_rules = rule;
        -:19334:      else
       85:19335:	last_pattern_rule->next = rule;
       86:19336:      last_pattern_rule = rule;
        -:19337:    }
        -:19338:
       86:19339:  return 1;
        -:19340:}
        -:19341:
        -:19342:
        -:19343:/* Install an implicit pattern rule based on the three text strings
        -:19344:   in the structure P points to.  These strings come from one of
        -:19345:   the arrays of default implicit pattern rules.
        -:19346:   TERMINAL specifies what the `terminal' field of the rule should be.  */
        -:19347:
        -:19348:void
function install_pattern_rule called 9 returned 100% blocks executed 94%
        9:19349:install_pattern_rule (p, terminal)
        -:19350:     struct pspec *p;
        -:19351:     int terminal;
        -:19352:{
        -:19353:  register struct rule *r;
        -:19354:  char *ptr;
        -:19355:
        9:19356:  r = (struct rule *) xmalloc (sizeof (struct rule));
call    0 returned 9
        -:19357:
        9:19358:  r->targets = (char **) xmalloc (2 * sizeof (char *));
call    0 returned 9
        9:19359:  r->suffixes = (char **) xmalloc (2 * sizeof (char *));
call    0 returned 9
        9:19360:  r->lens = (unsigned int *) xmalloc (2 * sizeof (unsigned int));
call    0 returned 9
        -:19361:
        9:19362:  r->targets[1] = 0;
        9:19363:  r->suffixes[1] = 0;
        9:19364:  r->lens[1] = 0;
        -:19365:
        9:19366:  r->lens[0] = strlen (p->target);
        -:19367:  /* These will all be string literals, but we malloc space for
        -:19368:     them anyway because somebody might want to free them later on.  */
        9:19369:  r->targets[0] = savestring (p->target, r->lens[0]);
call    0 returned 9
        9:19370:  r->suffixes[0] = find_percent (r->targets[0]);
call    0 returned 9
        9:19371:  if (r->suffixes[0] == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 9
        -:19372:    /* Programmer-out-to-lunch error.  */
    #####:19373:    abort ();
call    0 never executed
        -:19374:  else
        9:19375:    ++r->suffixes[0];
        -:19376:
        9:19377:  ptr = p->dep;
        9:19378:  r->deps = (struct dep *) multi_glob (parse_file_seq (&ptr, '\0',
call    0 returned 9
call    1 returned 9
        -:19379:                                                       sizeof (struct dep), 1),
        -:19380:				       sizeof (struct dep));
        -:19381:
        9:19382:  if (new_pattern_rule (r, 0))
call    0 returned 9
branch  1 taken 9 (fallthrough)
branch  2 taken 0
        -:19383:    {
        9:19384:      r->terminal = terminal;
        9:19385:      r->cmds = (struct commands *) xmalloc (sizeof (struct commands));
call    0 returned 9
        9:19386:      r->cmds->fileinfo.filenm = 0;
        9:19387:      r->cmds->fileinfo.lineno = 0;
        -:19388:      /* These will all be string literals, but we malloc space for them
        -:19389:	 anyway because somebody might want to free them later.  */
        9:19390:      r->cmds->commands = xstrdup (p->commands);
call    0 returned 9
        9:19391:      r->cmds->command_lines = 0;
        -:19392:    }
        9:19393:}
        -:19394:
        -:19395:
        -:19396:/* Free all the storage used in RULE and take it out of the
        -:19397:   pattern_rules chain.  LASTRULE is the rule whose next pointer
        -:19398:   points to RULE.  */
        -:19399:
        -:19400:static void
function freerule called 0 returned 0% blocks executed 0%
    #####:19401:freerule (rule, lastrule)
        -:19402:     register struct rule *rule, *lastrule;
        -:19403:{
    #####:19404:  struct rule *next = rule->next;
        -:19405:  register unsigned int i;
        -:19406:  register struct dep *dep;
        -:19407:
    #####:19408:  for (i = 0; rule->targets[i] != 0; ++i)
branch  0 never executed
branch  1 never executed
    #####:19409:    free (rule->targets[i]);
        -:19410:
    #####:19411:  dep = rule->deps;
    #####:19412:  while (dep)
branch  0 never executed
branch  1 never executed
        -:19413:    {
        -:19414:      struct dep *t;
        -:19415:
    #####:19416:      t = dep->next;
        -:19417:      /* We might leak dep->name here, but I'm not sure how to fix this: I
        -:19418:         think that pointer might be shared (e.g., in the file hash?)  */
    #####:19419:      free ((char *) dep);
    #####:19420:      dep = t;
        -:19421:    }
        -:19422:
    #####:19423:  free ((char *) rule->targets);
    #####:19424:  free ((char *) rule->suffixes);
    #####:19425:  free ((char *) rule->lens);
        -:19426:
        -:19427:  /* We can't free the storage for the commands because there
        -:19428:     are ways that they could be in more than one place:
        -:19429:       * If the commands came from a suffix rule, they could also be in
        -:19430:       the `struct file's for other suffix rules or plain targets given
        -:19431:       on the same makefile line.
        -:19432:       * If two suffixes that together make a two-suffix rule were each
        -:19433:       given twice in the .SUFFIXES list, and in the proper order, two
        -:19434:       identical pattern rules would be created and the second one would
        -:19435:       be discarded here, but both would contain the same `struct commands'
        -:19436:       pointer from the `struct file' for the suffix rule.  */
        -:19437:
    #####:19438:  free ((char *) rule);
        -:19439:
    #####:19440:  if (pattern_rules == rule)
branch  0 never executed
branch  1 never executed
    #####:19441:    if (lastrule != 0)
branch  0 never executed
branch  1 never executed
    #####:19442:      abort ();
call    0 never executed
        -:19443:    else
    #####:19444:      pattern_rules = next;
    #####:19445:  else if (lastrule != 0)
branch  0 never executed
branch  1 never executed
    #####:19446:    lastrule->next = next;
    #####:19447:  if (last_pattern_rule == rule)
branch  0 never executed
branch  1 never executed
    #####:19448:    last_pattern_rule = lastrule;
    #####:19449:}
        -:19450:
        -:19451:/* Create a new pattern rule with the targets in the nil-terminated
        -:19452:   array TARGETS.  If TARGET_PERCENTS is not nil, it is an array of
        -:19453:   pointers into the elements of TARGETS, where the `%'s are.
        -:19454:   The new rule has dependencies DEPS and commands from COMMANDS.
        -:19455:   It is a terminal rule if TERMINAL is nonzero.  This rule overrides
        -:19456:   identical rules with different commands if OVERRIDE is nonzero.
        -:19457:
        -:19458:   The storage for TARGETS and its elements is used and must not be freed
        -:19459:   until the rule is destroyed.  The storage for TARGET_PERCENTS is not used;
        -:19460:   it may be freed.  */
        -:19461:
        -:19462:void
function create_pattern_rule called 77 returned 100% blocks executed 62%
       77:19463:create_pattern_rule (targets, target_percents,
        -:19464:		     terminal, deps, commands, override)
        -:19465:     char **targets, **target_percents;
        -:19466:     int terminal;
        -:19467:     struct dep *deps;
        -:19468:     struct commands *commands;
        -:19469:     int override;
        -:19470:{
       77:19471:  register struct rule *r = (struct rule *) xmalloc (sizeof (struct rule));
call    0 returned 77
        -:19472:  register unsigned int max_targets, i;
        -:19473:
       77:19474:  r->cmds = commands;
       77:19475:  r->deps = deps;
       77:19476:  r->targets = targets;
        -:19477:
       77:19478:  max_targets = 2;
       77:19479:  r->lens = (unsigned int *) xmalloc (2 * sizeof (unsigned int));
call    0 returned 77
       77:19480:  r->suffixes = (char **) xmalloc (2 * sizeof (char *));
call    0 returned 77
      154:19481:  for (i = 0; targets[i] != 0; ++i)
branch  0 taken 77
branch  1 taken 77 (fallthrough)
        -:19482:    {
       77:19483:      if (i == max_targets - 1)
branch  0 taken 0 (fallthrough)
branch  1 taken 77
        -:19484:	{
    #####:19485:	  max_targets += 5;
    #####:19486:	  r->lens = (unsigned int *)
    #####:19487:	    xrealloc ((char *) r->lens, max_targets * sizeof (unsigned int));
call    0 never executed
    #####:19488:	  r->suffixes = (char **)
    #####:19489:	    xrealloc ((char *) r->suffixes, max_targets * sizeof (char *));
call    0 never executed
        -:19490:	}
       77:19491:      r->lens[i] = strlen (targets[i]);
    #####:19492:      r->suffixes[i] = (target_percents == 0 ? find_percent (targets[i])
call    0 never executed
      77*:19493:			: target_percents[i]) + 1;
branch  0 taken 0 (fallthrough)
branch  1 taken 77
       77:19494:      if (r->suffixes[i] == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 77
    #####:19495:	abort ();
call    0 never executed
        -:19496:    }
        -:19497:
       77:19498:  if (i < max_targets - 1)
branch  0 taken 0 (fallthrough)
branch  1 taken 77
        -:19499:    {
    #####:19500:      r->lens = (unsigned int *) xrealloc ((char *) r->lens,
    #####:19501:					   (i + 1) * sizeof (unsigned int));
call    0 never executed
    #####:19502:      r->suffixes = (char **) xrealloc ((char *) r->suffixes,
    #####:19503:					(i + 1) * sizeof (char *));
call    0 never executed
        -:19504:    }
        -:19505:
       77:19506:  if (new_pattern_rule (r, override))
call    0 returned 77
branch  1 taken 77 (fallthrough)
branch  2 taken 0
       77:19507:    r->terminal = terminal;
       77:19508:}
        -:19509:
        -:19510:/* Create a new pattern-specific variable struct.  */
        -:19511:
        -:19512:struct pattern_var *
function create_pattern_var called 0 returned 0% blocks executed 0%
    #####:19513:create_pattern_var (target, suffix)
        -:19514:     char *target, *suffix;
        -:19515:{
    #####:19516:  register struct pattern_var *p = 0;
    #####:19517:  unsigned int len = strlen(target);
        -:19518:
        -:19519:  /* Look to see if this pattern already exists in the list.  */
    #####:19520:  for (p = pattern_vars; p != NULL; p = p->next)
branch  0 never executed
branch  1 never executed
    #####:19521:    if (p->len == len && !strcmp(p->target, target))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:19522:      break;
        -:19523:
    #####:19524:  if (p == 0)
branch  0 never executed
branch  1 never executed
        -:19525:    {
    #####:19526:      p = (struct pattern_var *) xmalloc (sizeof (struct pattern_var));
call    0 never executed
    #####:19527:      if (last_pattern_var != 0)
branch  0 never executed
branch  1 never executed
    #####:19528:        last_pattern_var->next = p;
        -:19529:      else
    #####:19530:        pattern_vars = p;
    #####:19531:      last_pattern_var = p;
    #####:19532:      p->next = 0;
    #####:19533:      p->target = target;
    #####:19534:      p->len = len;
    #####:19535:      p->suffix = suffix + 1;
    #####:19536:      p->vars = create_new_variable_set();
call    0 never executed
        -:19537:    }
        -:19538:
    #####:19539:  return p;
        -:19540:}
        -:19541:
        -:19542:/* Look up a target in the pattern-specific variable list.  */
        -:19543:
        -:19544:struct pattern_var *
function lookup_pattern_var called 0 returned 0% blocks executed 0%
    #####:19545:lookup_pattern_var (target)
        -:19546:     char *target;
        -:19547:{
        -:19548:  struct pattern_var *p;
    #####:19549:  unsigned int targlen = strlen(target);
        -:19550:
    #####:19551:  for (p = pattern_vars; p != 0; p = p->next)
branch  0 never executed
branch  1 never executed
        -:19552:    {
        -:19553:      char *stem;
        -:19554:      unsigned int stemlen;
        -:19555:
    #####:19556:      if (p->len > targlen)
branch  0 never executed
branch  1 never executed
        -:19557:        /* It can't possibly match.  */
    #####:19558:        continue;
        -:19559:
        -:19560:      /* From the lengths of the filename and the pattern parts,
        -:19561:         find the stem: the part of the filename that matches the %.  */
    #####:19562:      stem = target + (p->suffix - p->target - 1);
    #####:19563:      stemlen = targlen - p->len + 1;
        -:19564:
        -:19565:      /* Compare the text in the pattern before the stem, if any.  */
    #####:19566:      if (stem > target && !strneq (p->target, target, stem - target))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:19567:        continue;
        -:19568:
        -:19569:      /* Compare the text in the pattern after the stem, if any.
        -:19570:         We could test simply using streq, but this way we compare the
        -:19571:         first two characters immediately.  This saves time in the very
        -:19572:         common case where the first character matches because it is a
        -:19573:         period.  */
    #####:19574:      if (*p->suffix == stem[stemlen]
branch  0 never executed
branch  1 never executed
    #####:19575:          && (*p->suffix == '\0' || streq (&p->suffix[1], &stem[stemlen+1])))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
        -:19576:        break;
        -:19577:    }
        -:19578:
    #####:19579:  return p;
        -:19580:}
        -:19581:
        -:19582:/* Print the data base of rules.  */
        -:19583:
        -:19584:static void			/* Useful to call from gdb.  */
function print_rule called 86 returned 100% blocks executed 90%
       86:19585:print_rule (r)
        -:19586:     struct rule *r;
        -:19587:{
        -:19588:  register unsigned int i;
        -:19589:  register struct dep *d;
        -:19590:
      172:19591:  for (i = 0; r->targets[i] != 0; ++i)
branch  0 taken 86
branch  1 taken 86 (fallthrough)
        -:19592:    {
       86:19593:      fputs (r->targets[i], stdout);
call    0 returned 86
       86:19594:      if (r->targets[i + 1] != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 86
    #####:19595:	putchar (' ');
call    0 never executed
        -:19596:      else
       86:19597:	putchar (':');
call    0 returned 86
        -:19598:    }
       86:19599:  if (r->terminal)
branch  0 taken 5 (fallthrough)
branch  1 taken 81
        5:19600:    putchar (':');
call    0 returned 5
        -:19601:
      142:19602:  for (d = r->deps; d != 0; d = d->next)
branch  0 taken 56
branch  1 taken 86 (fallthrough)
      56*:19603:    printf (" %s", dep_name (d));
branch  0 taken 0 (fallthrough)
branch  1 taken 56
call    2 returned 56
       86:19604:  putchar ('\n');
call    0 returned 86
        -:19605:
       86:19606:  if (r->cmds != 0)
branch  0 taken 54 (fallthrough)
branch  1 taken 32
       54:19607:    print_commands (r->cmds);
call    0 returned 54
       86:19608:}
        -:19609:
        -:19610:void
function print_rule_data_base called 1 returned 100% blocks executed 73%
        1:19611:print_rule_data_base ()
        -:19612:{
        -:19613:  register unsigned int rules, terminal;
        -:19614:  register struct rule *r;
        -:19615:
        1:19616:  puts ("\n# Implicit Rules");
call    0 returned 1
        -:19617:
        1:19618:  rules = terminal = 0;
       87:19619:  for (r = pattern_rules; r != 0; r = r->next)
branch  0 taken 86
branch  1 taken 1 (fallthrough)
        -:19620:    {
       86:19621:      ++rules;
        -:19622:
       86:19623:      putchar ('\n');
call    0 returned 86
       86:19624:      print_rule (r);
call    0 returned 86
        -:19625:
       86:19626:      if (r->terminal)
branch  0 taken 5 (fallthrough)
branch  1 taken 81
        5:19627:	++terminal;
        -:19628:    }
        -:19629:
        1:19630:  if (rules == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:19631:    puts (_("\n# No implicit rules."));
call    0 never executed
        -:19632:  else
        -:19633:    {
        1:19634:      printf (_("\n# %u implicit rules, %u"), rules, terminal);
call    0 returned 1
        -:19635:#ifndef	NO_FLOAT
        1:19636:      printf (" (%.1f%%)", (double) terminal / (double) rules * 100.0);
call    0 returned 1
        -:19637:#else
        -:19638:      {
        -:19639:	int f = (terminal * 1000 + 5) / rules;
        -:19640:	printf (" (%d.%d%%)", f/10, f%10);
        -:19641:      }
        -:19642:#endif
        1:19643:      puts (_(" terminal."));
call    0 returned 1
        -:19644:    }
        -:19645:
        1:19646:  if (num_pattern_rules != rules)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -:19647:    {
        -:19648:      /* This can happen if a fatal error was detected while reading the
        -:19649:         makefiles and thus count_implicit_rule_limits wasn't called yet.  */
    #####:19650:      if (num_pattern_rules != 0)
branch  0 never executed
branch  1 never executed
    #####:19651:        fatal (NILF, _("BUG: num_pattern_rules wrong!  %u != %u"),
call    0 never executed
        -:19652:               num_pattern_rules, rules);
        -:19653:    }
        -:19654:
        1:19655:  puts (_("\n# Pattern-specific variable values"));
call    0 returned 1
        -:19656:
        -:19657:  {
        -:19658:    struct pattern_var *p;
        -:19659:
        1:19660:    rules = 0;
       1*:19661:    for (p = pattern_vars; p != 0; p = p->next)
branch  0 taken 0
branch  1 taken 1 (fallthrough)
        -:19662:      {
    #####:19663:        ++rules;
        -:19664:
    #####:19665:        printf ("\n%s :\n", p->target);
call    0 never executed
    #####:19666:        print_variable_set (p->vars->set, "# ");
call    0 never executed
        -:19667:      }
        -:19668:
        1:19669:    if (rules == 0)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:19670:      puts (_("\n# No pattern-specific variable values."));
call    0 returned 1
        -:19671:    else
        -:19672:      {
    #####:19673:        printf (_("\n# %u pattern-specific variable values"), rules);
call    0 never executed
        -:19674:      }
        -:19675:  }
        1:19676:}
        -:19677:
        -:19678:
        -:19679:
        -:19680:/*************************************************************
        -:19681:  ============================================================
        -:19682:  ************************************************************
        -:19683:  ============================================================
        -:19684:  ************************************************************
        -:19685:                         signame.c
        -:19686:  ************************************************************
        -:19687:  ============================================================
        -:19688:  ************************************************************
        -:19689:  ============================================================
        -:19690:  *************************************************************/
        -:19691:
        -:19692:/* Convert between signal names and numbers.
        -:19693:   Copyright (C) 1990,92,93,95,96,99 Free Software Foundation, Inc.
        -:19694:   This file is part of the GNU C Library.
        -:19695:
        -:19696:   The GNU C Library is free software; you can redistribute it and/or
        -:19697:   modify it under the terms of the GNU Library General Public License as
        -:19698:   published by the Free Software Foundation; either version 2 of the
        -:19699:   License, or (at your option) any later version.
        -:19700:
        -:19701:   The GNU C Library is distributed in the hope that it will be useful,
        -:19702:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:19703:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
        -:19704:   Library General Public License for more details.
        -:19705:
        -:19706:   You should have received a copy of the GNU Library General Public
        -:19707:   License along with the GNU C Library; see the file COPYING.LIB.  If not,
        -:19708:   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
        -:19709:   Boston, MA 02111-1307, USA.  */
        -:19710:
        -:19711:
        -:19712:/* In the GNU make version, all the headers we need are provided by make.h.  */
        -:19713:/* #include "make.h"  <- modification by J.Ruthruff, 7/28 */
        -:19714:#undef stderr
        -:19715:#define stderr stdout
        -:19716:
        -:19717:
        -:19718:/* Some systems do not define NSIG in <signal.h>.  */
        -:19719:#ifndef	NSIG
        -:19720:#ifdef	_NSIG
        -:19721:#define	NSIG	_NSIG
        -:19722:#else
        -:19723:#define	NSIG	32
        -:19724:#endif
        -:19725:#endif
        -:19726:
        -:19727:#if !__STDC__
        -:19728:#define const
        -:19729:#endif
        -:19730:
        -:19731:#include "signame.h"
        -:19732:#undef stderr
        -:19733:#define stderr stdout
        -:19734:
        -:19735:#ifndef HAVE_SYS_SIGLIST
        -:19736:/* There is too much variation in Sys V signal numbers and names, so
        -:19737:   we must initialize them at runtime.  */
        -:19738:
        -:19739:static const char *undoc;
        -:19740:
        -:19741:const char *sys_siglist[NSIG];
        -:19742:
        -:19743:#else	/* HAVE_SYS_SIGLIST.  */
        -:19744:
        -:19745:#ifndef SYS_SIGLIST_DECLARED
        -:19746:extern char *sys_siglist[];
        -:19747:#endif	/* Not SYS_SIGLIST_DECLARED.  */
        -:19748:
        -:19749:#endif	/* Not HAVE_SYS_SIGLIST.  */
        -:19750:
        -:19751:/* Table of abbreviations for signals.  Note:  A given number can
        -:19752:   appear more than once with different abbreviations.  */
        -:19753:#define SIG_TABLE_SIZE  (NSIG*2)
        -:19754:
        -:19755:typedef struct
        -:19756:  {
        -:19757:    int number;
        -:19758:    const char *abbrev;
        -:19759:  } num_abbrev;
        -:19760:static num_abbrev sig_table[SIG_TABLE_SIZE];
        -:19761:/* Number of elements of sig_table used.  */
        -:19762:static int sig_table_nelts = 0;
        -:19763:
        -:19764:/* Enter signal number NUMBER into the tables with ABBREV and NAME.  */
        -:19765:
        -:19766:static void
function init_sig called 0 returned 0% blocks executed 0%
    #####:19767:init_sig (number, abbrev, name)
        -:19768:     int number;
        -:19769:     const char *abbrev;
        -:19770:     const char *name;
        -:19771:{
        -:19772:#ifndef HAVE_SYS_SIGLIST
        -:19773:  /* If this value is ever greater than NSIG it seems like it'd be a bug in
        -:19774:     the system headers, but... better safe than sorry.  We know, for
        -:19775:     example, that this isn't always true on VMS.  */
        -:19776:
    #####:19777:  if (number >= 0 && number < NSIG)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:19778:    sys_siglist[number] = name;
        -:19779:#endif
    #####:19780:  if (sig_table_nelts < SIG_TABLE_SIZE)
branch  0 never executed
branch  1 never executed
        -:19781:    {
    #####:19782:      sig_table[sig_table_nelts].number = number;
    #####:19783:      sig_table[sig_table_nelts++].abbrev = abbrev;
        -:19784:    }
    #####:19785:}
        -:19786:
        -:19787:void
function signame_init called 0 returned 0% blocks executed 0%
    #####:19788:signame_init ()
        -:19789:{
        -:19790:#ifndef HAVE_SYS_SIGLIST
        -:19791:  int i;
    #####:19792:  char *u = _("unknown signal");
        -:19793:
    #####:19794:  undoc = xstrdup(u);
call    0 never executed
        -:19795:
        -:19796:  /* Initialize signal names.  */
    #####:19797:  for (i = 0; i < NSIG; i++)
branch  0 never executed
branch  1 never executed
    #####:19798:    sys_siglist[i] = undoc;
        -:19799:#endif /* !HAVE_SYS_SIGLIST */
        -:19800:
        -:19801:  /* Initialize signal names.  */
        -:19802:#if defined (SIGHUP)
    #####:19803:  init_sig (SIGHUP, "HUP", _("Hangup"));
call    0 never executed
        -:19804:#endif
        -:19805:#if defined (SIGINT)
    #####:19806:  init_sig (SIGINT, "INT", _("Interrupt"));
call    0 never executed
        -:19807:#endif
        -:19808:#if defined (SIGQUIT)
    #####:19809:  init_sig (SIGQUIT, "QUIT", _("Quit"));
call    0 never executed
        -:19810:#endif
        -:19811:#if defined (SIGILL)
    #####:19812:  init_sig (SIGILL, "ILL", _("Illegal Instruction"));
call    0 never executed
        -:19813:#endif
        -:19814:#if defined (SIGTRAP)
    #####:19815:  init_sig (SIGTRAP, "TRAP", _("Trace/breakpoint trap"));
call    0 never executed
        -:19816:#endif
        -:19817:  /* If SIGIOT == SIGABRT, we want to print it as SIGABRT because
        -:19818:     SIGABRT is in ANSI and POSIX.1 and SIGIOT isn't.  */
        -:19819:#if defined (SIGABRT)
    #####:19820:  init_sig (SIGABRT, "ABRT", _("Aborted"));
call    0 never executed
        -:19821:#endif
        -:19822:#if defined (SIGIOT)
    #####:19823:  init_sig (SIGIOT, "IOT", _("IOT trap"));
call    0 never executed
        -:19824:#endif
        -:19825:#if defined (SIGEMT)
        -:19826:  init_sig (SIGEMT, "EMT", _("EMT trap"));
        -:19827:#endif
        -:19828:#if defined (SIGFPE)
    #####:19829:  init_sig (SIGFPE, "FPE", _("Floating point exception"));
call    0 never executed
        -:19830:#endif
        -:19831:#if defined (SIGKILL)
    #####:19832:  init_sig (SIGKILL, "KILL", _("Killed"));
call    0 never executed
        -:19833:#endif
        -:19834:#if defined (SIGBUS)
    #####:19835:  init_sig (SIGBUS, "BUS", _("Bus error"));
call    0 never executed
        -:19836:#endif
        -:19837:#if defined (SIGSEGV)
    #####:19838:  init_sig (SIGSEGV, "SEGV", _("Segmentation fault"));
call    0 never executed
        -:19839:#endif
        -:19840:#if defined (SIGSYS)
    #####:19841:  init_sig (SIGSYS, "SYS", _("Bad system call"));
call    0 never executed
        -:19842:#endif
        -:19843:#if defined (SIGPIPE)
    #####:19844:  init_sig (SIGPIPE, "PIPE", _("Broken pipe"));
call    0 never executed
        -:19845:#endif
        -:19846:#if defined (SIGALRM)
    #####:19847:  init_sig (SIGALRM, "ALRM", _("Alarm clock"));
call    0 never executed
        -:19848:#endif
        -:19849:#if defined (SIGTERM)
    #####:19850:  init_sig (SIGTERM, "TERM", _("Terminated"));
call    0 never executed
        -:19851:#endif
        -:19852:#if defined (SIGUSR1)
    #####:19853:  init_sig (SIGUSR1, "USR1", _("User defined signal 1"));
call    0 never executed
        -:19854:#endif
        -:19855:#if defined (SIGUSR2)
    #####:19856:  init_sig (SIGUSR2, "USR2", _("User defined signal 2"));
call    0 never executed
        -:19857:#endif
        -:19858:  /* If SIGCLD == SIGCHLD, we want to print it as SIGCHLD because that
        -:19859:     is what is in POSIX.1.  */
        -:19860:#if defined (SIGCHLD)
    #####:19861:  init_sig (SIGCHLD, "CHLD", _("Child exited"));
call    0 never executed
        -:19862:#endif
        -:19863:#if defined (SIGCLD)
    #####:19864:  init_sig (SIGCLD, "CLD", _("Child exited"));
call    0 never executed
        -:19865:#endif
        -:19866:#if defined (SIGPWR)
    #####:19867:  init_sig (SIGPWR, "PWR", _("Power failure"));
call    0 never executed
        -:19868:#endif
        -:19869:#if defined (SIGTSTP)
    #####:19870:  init_sig (SIGTSTP, "TSTP", _("Stopped"));
call    0 never executed
        -:19871:#endif
        -:19872:#if defined (SIGTTIN)
    #####:19873:  init_sig (SIGTTIN, "TTIN", _("Stopped (tty input)"));
call    0 never executed
        -:19874:#endif
        -:19875:#if defined (SIGTTOU)
    #####:19876:  init_sig (SIGTTOU, "TTOU", _("Stopped (tty output)"));
call    0 never executed
        -:19877:#endif
        -:19878:#if defined (SIGSTOP)
    #####:19879:  init_sig (SIGSTOP, "STOP", _("Stopped (signal)"));
call    0 never executed
        -:19880:#endif
        -:19881:#if defined (SIGXCPU)
    #####:19882:  init_sig (SIGXCPU, "XCPU", _("CPU time limit exceeded"));
call    0 never executed
        -:19883:#endif
        -:19884:#if defined (SIGXFSZ)
    #####:19885:  init_sig (SIGXFSZ, "XFSZ", _("File size limit exceeded"));
call    0 never executed
        -:19886:#endif
        -:19887:#if defined (SIGVTALRM)
    #####:19888:  init_sig (SIGVTALRM, "VTALRM", _("Virtual timer expired"));
call    0 never executed
        -:19889:#endif
        -:19890:#if defined (SIGPROF)
    #####:19891:  init_sig (SIGPROF, "PROF", _("Profiling timer expired"));
call    0 never executed
        -:19892:#endif
        -:19893:#if defined (SIGWINCH)
        -:19894:  /* "Window size changed" might be more accurate, but even if that
        -:19895:     is all that it means now, perhaps in the future it will be
        -:19896:     extended to cover other kinds of window changes.  */
    #####:19897:  init_sig (SIGWINCH, "WINCH", _("Window changed"));
call    0 never executed
        -:19898:#endif
        -:19899:#if defined (SIGCONT)
    #####:19900:  init_sig (SIGCONT, "CONT", _("Continued"));
call    0 never executed
        -:19901:#endif
        -:19902:#if defined (SIGURG)
    #####:19903:  init_sig (SIGURG, "URG", _("Urgent I/O condition"));
call    0 never executed
        -:19904:#endif
        -:19905:#if defined (SIGIO)
        -:19906:  /* "I/O pending" has also been suggested.  A disadvantage is
        -:19907:     that signal only happens when the process has
        -:19908:     asked for it, not everytime I/O is pending.  Another disadvantage
        -:19909:     is the confusion from giving it a different name than under Unix.  */
    #####:19910:  init_sig (SIGIO, "IO", _("I/O possible"));
call    0 never executed
        -:19911:#endif
        -:19912:#if defined (SIGWIND)
        -:19913:  init_sig (SIGWIND, "WIND", _("SIGWIND"));
        -:19914:#endif
        -:19915:#if defined (SIGPHONE)
        -:19916:  init_sig (SIGPHONE, "PHONE", _("SIGPHONE"));
        -:19917:#endif
        -:19918:#if defined (SIGPOLL)
    #####:19919:  init_sig (SIGPOLL, "POLL", _("I/O possible"));
call    0 never executed
        -:19920:#endif
        -:19921:#if defined (SIGLOST)
        -:19922:  init_sig (SIGLOST, "LOST", _("Resource lost"));
        -:19923:#endif
        -:19924:#if defined (SIGDANGER)
        -:19925:  init_sig (SIGDANGER, "DANGER", _("Danger signal"));
        -:19926:#endif
        -:19927:#if defined (SIGINFO)
        -:19928:  init_sig (SIGINFO, "INFO", _("Information request"));
        -:19929:#endif
        -:19930:#if defined (SIGNOFP)
        -:19931:  init_sig (SIGNOFP, "NOFP", _("Floating point co-processor not available"));
        -:19932:#endif
    #####:19933:}
        -:19934:
        -:19935:/* Return the abbreviation for signal NUMBER.  */
        -:19936:
        -:19937:char *
function sig_abbrev called 0 returned 0% blocks executed 0%
    #####:19938:sig_abbrev (number)
        -:19939:     int number;
        -:19940:{
        -:19941:  int i;
        -:19942:
    #####:19943:  if (sig_table_nelts == 0)
branch  0 never executed
branch  1 never executed
    #####:19944:    signame_init ();
call    0 never executed
        -:19945:
    #####:19946:  for (i = 0; i < sig_table_nelts; i++)
branch  0 never executed
branch  1 never executed
    #####:19947:    if (sig_table[i].number == number)
branch  0 never executed
branch  1 never executed
    #####:19948:      return (char *)sig_table[i].abbrev;
    #####:19949:  return NULL;
        -:19950:}
        -:19951:
        -:19952:/* Return the signal number for an ABBREV, or -1 if there is no
        -:19953:   signal by that name.  */
        -:19954:
        -:19955:int
function sig_number called 0 returned 0% blocks executed 0%
    #####:19956:sig_number (abbrev)
        -:19957:     const char *abbrev;
        -:19958:{
        -:19959:  int i;
        -:19960:
    #####:19961:  if (sig_table_nelts == 0)
branch  0 never executed
branch  1 never executed
    #####:19962:    signame_init ();
call    0 never executed
        -:19963:
        -:19964:  /* Skip over "SIG" if present.  */
    #####:19965:  if (abbrev[0] == 'S' && abbrev[1] == 'I' && abbrev[2] == 'G')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:19966:    abbrev += 3;
        -:19967:
    #####:19968:  for (i = 0; i < sig_table_nelts; i++)
branch  0 never executed
branch  1 never executed
    #####:19969:    if (abbrev[0] == sig_table[i].abbrev[0]
branch  0 never executed
branch  1 never executed
    #####:19970:	&& strcmp (abbrev, sig_table[i].abbrev) == 0)
branch  0 never executed
branch  1 never executed
    #####:19971:      return sig_table[i].number;
    #####:19972:  return -1;
        -:19973:}
        -:19974:
        -:19975:#ifndef HAVE_PSIGNAL
        -:19976:/* Print to standard error the name of SIGNAL, preceded by MESSAGE and
        -:19977:   a colon, and followed by a newline.  */
        -:19978:
        -:19979:void
        -:19980:psignal (signal, message)
        -:19981:     int signal;
        -:19982:     const char *message;
        -:19983:{
        -:19984:  if (signal <= 0 || signal >= NSIG)
        -:19985:    fprintf (stderr, "%s: unknown signal", message);
        -:19986:  else
        -:19987:    fprintf (stderr, "%s: %s\n", message, sys_siglist[signal]);
        -:19988:}
        -:19989:#endif
        -:19990:
        -:19991:#ifndef HAVE_STRSIGNAL
        -:19992:/* Return the string associated with the signal number.  */
        -:19993:
        -:19994:char *
        -:19995:strsignal (signal)
        -:19996:     int signal;
        -:19997:{
        -:19998:  static char buf[] = "Signal 12345678901234567890";
        -:19999:
        -:20000:  if (signal > 0 || signal < NSIG)
        -:20001:    return (char *) sys_siglist[signal];
        -:20002:
        -:20003:  sprintf (buf, "Signal %d", signal);
        -:20004:  return buf;
        -:20005:}
        -:20006:#endif
        -:20007:
        -:20008:
        -:20009:
        -:20010:/*************************************************************
        -:20011:  ============================================================
        -:20012:  ************************************************************
        -:20013:  ============================================================
        -:20014:  ************************************************************
        -:20015:                         variable.c
        -:20016:  ************************************************************
        -:20017:  ============================================================
        -:20018:  ************************************************************
        -:20019:  ============================================================
        -:20020:  *************************************************************/
        -:20021:
        -:20022:/* Internals of variables for GNU Make.
        -:20023:Copyright (C) 1988,89,90,91,92,93,94,96,97 Free Software Foundation, Inc.
        -:20024:This file is part of GNU Make.
        -:20025:
        -:20026:GNU Make is free software; you can redistribute it and/or modify
        -:20027:it under the terms of the GNU General Public License as published by
        -:20028:the Free Software Foundation; either version 2, or (at your option)
        -:20029:any later version.
        -:20030:
        -:20031:GNU Make is distributed in the hope that it will be useful,
        -:20032:but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:20033:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:20034:GNU General Public License for more details.
        -:20035:
        -:20036:You should have received a copy of the GNU General Public License
        -:20037:along with GNU Make; see the file COPYING.  If not, write to
        -:20038:the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
        -:20039:Boston, MA 02111-1307, USA.  */
        -:20040:
        -:20041:/* #include "make.h"  <- modification by J.Ruthruff, 7/28 */
        -:20042:/* #include "dep.h"  <- modification by J.Ruthruff, 7/28 */
        -:20043:/* #include "filedef.h"  <- modification by J.Ruthruff, 7/28 */
        -:20044:#include "job.h"
        -:20045:/* #include "commands.h"  <- modification by J.Ruthruff, 7/28 */
        -:20046:/* #include "variable.h"  <- modification by J.Ruthruff, 7/28 */
        -:20047:/* #include "rule.h"  <- modification by J.Ruthruff, 7/28 */
        -:20048:#undef stderr
        -:20049:#define stderr stdout
        -:20050:#ifdef WINDOWS32
        -:20051:#include "pathstuff.h"
        -:20052:#undef stderr
        -:20053:#define stderr stdout
        -:20054:#endif
        -:20055:
        -:20056:/* Hash table of all global variable definitions.  */
        -:20057:
        -:20058:#ifndef	VARIABLE_BUCKETS
        -:20059:#define VARIABLE_BUCKETS		523
        -:20060:#endif
        -:20061:#ifndef	PERFILE_VARIABLE_BUCKETS
        -:20062:#define	PERFILE_VARIABLE_BUCKETS	23
        -:20063:#endif
        -:20064:#ifndef	SMALL_SCOPE_VARIABLE_BUCKETS
        -:20065:#define	SMALL_SCOPE_VARIABLE_BUCKETS	13
        -:20066:#endif
        -:20067:static struct variable *variable_table[VARIABLE_BUCKETS];
        -:20068:static struct variable_set global_variable_set
        -:20069:  = { variable_table, VARIABLE_BUCKETS };
        -:20070:static struct variable_set_list global_setlist
        -:20071:  = { 0, &global_variable_set };
        -:20072:struct variable_set_list *current_variable_set_list = &global_setlist;
        -:20073:
        -:20074:static struct variable *lookup_variable_in_set PARAMS ((char *name,
        -:20075:                          unsigned int length, struct variable_set *set));
        -:20076:
        -:20077:/* Implement variables.  */
        -:20078:
        -:20079:/* Define variable named NAME with value VALUE in SET.  VALUE is copied.
        -:20080:   LENGTH is the length of NAME, which does not need to be null-terminated.
        -:20081:   ORIGIN specifies the origin of the variable (makefile, command line
        -:20082:   or environment).
        -:20083:   If RECURSIVE is nonzero a flag is set in the variable saying
        -:20084:   that it should be recursively re-expanded.  */
        -:20085:
        -:20086:struct variable *
function define_variable_in_set called 137 returned 100% blocks executed 94%
      137:20087:define_variable_in_set (name, length, value, origin, recursive, set, flocp)
        -:20088:     char *name;
        -:20089:     unsigned int length;
        -:20090:     char *value;
        -:20091:     enum variable_origin origin;
        -:20092:     int recursive;
        -:20093:     struct variable_set *set;
        -:20094:     const struct floc *flocp;
        -:20095:{
        -:20096:  register unsigned int i;
        -:20097:  register unsigned int hashval;
        -:20098:  register struct variable *v;
        -:20099:
      137:20100:  hashval = 0;
     1272:20101:  for (i = 0; i < length; ++i)
branch  0 taken 1135
branch  1 taken 137 (fallthrough)
     1135:20102:    HASH (hashval, name[i]);
      137:20103:  hashval %= set->buckets;
        -:20104:
      158:20105:  for (v = set->table[hashval]; v != 0; v = v->next)
branch  0 taken 26
branch  1 taken 132 (fallthrough)
       26:20106:    if (*v->name == *name
branch  0 taken 6 (fallthrough)
branch  1 taken 20
        6:20107:	&& strneq (v->name + 1, name + 1, length - 1)
branch  0 taken 5 (fallthrough)
branch  1 taken 1
        5:20108:	&& v->name[length] == '\0')
branch  0 taken 5 (fallthrough)
branch  1 taken 0
        5:20109:      break;
        -:20110:
      137:20111:  if (env_overrides && origin == o_env)
branch  0 taken 87 (fallthrough)
branch  1 taken 50
branch  2 taken 4 (fallthrough)
branch  3 taken 83
        4:20112:    origin = o_env_override;
        -:20113:
      137:20114:  if (v != 0)
branch  0 taken 5 (fallthrough)
branch  1 taken 132
        -:20115:    {
        5:20116:      if (env_overrides && v->origin == o_env)
branch  0 taken 5 (fallthrough)
branch  1 taken 0
branch  2 taken 1 (fallthrough)
branch  3 taken 4
        -:20117:	/* V came from in the environment.  Since it was defined
        -:20118:	   before the switches were parsed, it wasn't affected by -e.  */
        1:20119:	v->origin = o_env_override;
        -:20120:
        -:20121:      /* A variable of this name is already defined.
        -:20122:	 If the old definition is from a stronger source
        -:20123:	 than this one, don't redefine it.  */
        5:20124:      if ((int) origin >= (int) v->origin)
branch  0 taken 4 (fallthrough)
branch  1 taken 1
        -:20125:	{
        4:20126:	  if (v->value != 0)
branch  0 taken 4 (fallthrough)
branch  1 taken 0
        4:20127:	    free (v->value);
        4:20128:	  v->value = xstrdup (value);
call    0 returned 4
        4:20129:          if (flocp != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 4
    #####:20130:            v->fileinfo = *flocp;
        -:20131:          else
        4:20132:            v->fileinfo.filenm = 0;
        4:20133:	  v->origin = origin;
        4:20134:	  v->recursive = recursive;
        -:20135:	}
        5:20136:      return v;
        -:20137:    }
        -:20138:
        -:20139:  /* Create a new variable definition and add it to the hash table.  */
        -:20140:
      132:20141:  v = (struct variable *) xmalloc (sizeof (struct variable));
call    0 returned 132
      132:20142:  v->name = savestring (name, length);
call    0 returned 132
      132:20143:  v->value = xstrdup (value);
call    0 returned 132
      132:20144:  if (flocp != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 132
    #####:20145:    v->fileinfo = *flocp;
        -:20146:  else
      132:20147:    v->fileinfo.filenm = 0;
      132:20148:  v->origin = origin;
      132:20149:  v->recursive = recursive;
      132:20150:  v->expanding = 0;
      132:20151:  v->per_target = 0;
      132:20152:  v->append = 0;
      132:20153:  v->export = v_default;
      132:20154:  v->next = set->table[hashval];
      132:20155:  set->table[hashval] = v;
      132:20156:  return v;
        -:20157:}
        -:20158:
        -:20159:/* Lookup a variable whose name is a string starting at NAME
        -:20160:   and with LENGTH chars.  NAME need not be null-terminated.
        -:20161:   Returns address of the `struct variable' containing all info
        -:20162:   on the variable, or nil if no such variable is defined.
        -:20163:
        -:20164:   If we find a variable which is in the process of being expanded,
        -:20165:   try to find one further up the set_list chain.  If we don't find
        -:20166:   one that isn't being expanded, return a pointer to whatever we
        -:20167:   _did_ find.  */
        -:20168:
        -:20169:struct variable *
function lookup_variable called 6 returned 100% blocks executed 90%
        6:20170:lookup_variable (name, length)
        -:20171:     char *name;
        -:20172:     unsigned int length;
        -:20173:{
        -:20174:  register struct variable_set_list *setlist;
        6:20175:  struct variable *firstv = 0;
        -:20176:
        -:20177:  register unsigned int i;
        6:20178:  register unsigned int rawhash = 0;
        -:20179:
       52:20180:  for (i = 0; i < length; ++i)
branch  0 taken 46
branch  1 taken 6 (fallthrough)
       46:20181:    HASH (rawhash, name[i]);
        -:20182:
        6:20183:  for (setlist = current_variable_set_list;
       10:20184:       setlist != 0; setlist = setlist->next)
branch  0 taken 6
branch  1 taken 4 (fallthrough)
        -:20185:    {
        6:20186:      register struct variable_set *set = setlist->set;
        6:20187:      register unsigned int hashval = rawhash % set->buckets;
        -:20188:      register struct variable *v;
        -:20189:
        -:20190:      /* Look through this set list.  */
        7:20191:      for (v = set->table[hashval]; v != 0; v = v->next)
branch  0 taken 3
branch  1 taken 4 (fallthrough)
        3:20192:	if (*v->name == *name
branch  0 taken 2 (fallthrough)
branch  1 taken 1
        2:20193:	    && strneq (v->name + 1, name + 1, length - 1)
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2:20194:	    && v->name[length] == '\0')
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2:20195:          break;
        -:20196:
        -:20197:      /* If we didn't find anything, go to the next set list.  */
        6:20198:      if (!v)
branch  0 taken 4 (fallthrough)
branch  1 taken 2
        4:20199:        continue;
        -:20200:
        -:20201:      /* If it's not being expanded already, we're done.  */
        2:20202:      if (!v->expanding)
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2:20203:        return v;
        -:20204:
        -:20205:      /* It is, so try to find another one.  If this is the first one we've
        -:20206:         seen, keep a pointer in case we don't find anything else.  */
    #####:20207:      if (!firstv)
branch  0 never executed
branch  1 never executed
    #####:20208:        firstv = v;
        -:20209:    }
        -:20210:
        -:20211:#ifdef VMS
        -:20212:  /* since we don't read envp[] on startup, try to get the
        -:20213:     variable via getenv() here.  */
        -:20214:  if (!firstv)
        -:20215:    {
        -:20216:      char *vname = alloca (length + 1);
        -:20217:      char *value;
        -:20218:      strncpy (vname, name, length);
        -:20219:      vname[length] = 0;
        -:20220:      value = getenv (vname);
        -:20221:      if (value != 0)
        -:20222:	{
        -:20223:	  char *sptr;
        -:20224:	  int scnt;
        -:20225:
        -:20226:	  sptr = value;
        -:20227:	  scnt = 0;
        -:20228:
        -:20229:          if (listp)
        -:20230:            *listp = current_variable_set_list;
        -:20231:
        -:20232:	  while ((sptr = strchr (sptr, '$')))
        -:20233:	    {
        -:20234:	      scnt++;
        -:20235:	      sptr++;
        -:20236:	    }
        -:20237:
        -:20238:	  if (scnt > 0)
        -:20239:	    {
        -:20240:	      char *nvalue;
        -:20241:	      char *nptr;
        -:20242:
        -:20243:	      nvalue = alloca (length + scnt + 1);
        -:20244:	      sptr = value;
        -:20245:	      nptr = nvalue;
        -:20246:
        -:20247:	      while (*sptr)
        -:20248:		{
        -:20249:		  if (*sptr == '$')
        -:20250:		    {
        -:20251:		      *nptr++ = '$';
        -:20252:		      *nptr++ = '$';
        -:20253:		    }
        -:20254:		  else
        -:20255:		    {
        -:20256:		      *nptr++ = *sptr;
        -:20257:		    }
        -:20258:		  sptr++;
        -:20259:		}
        -:20260:
        -:20261:	      return define_variable (vname, length, nvalue, o_env, 1);
        -:20262:
        -:20263:	    }
        -:20264:
        -:20265:	  return define_variable (vname, length, value, o_env, 1);
        -:20266:	}
        -:20267:    }
        -:20268:#endif /* VMS */
        -:20269:
        4:20270:  return firstv;
        -:20271:}
        -:20272:
        -:20273:/* Lookup a variable whose name is a string starting at NAME
        -:20274:   and with LENGTH chars in set SET.  NAME need not be null-terminated.
        -:20275:   Returns address of the `struct variable' containing all info
        -:20276:   on the variable, or nil if no such variable is defined.  */
        -:20277:
        -:20278:static struct variable *
function lookup_variable_in_set called 0 returned 0% blocks executed 0%
    #####:20279:lookup_variable_in_set (name, length, set)
        -:20280:     char *name;
        -:20281:     unsigned int length;
        -:20282:     struct variable_set *set;
        -:20283:{
        -:20284:  register unsigned int i;
    #####:20285:  register unsigned int hash = 0;
        -:20286:  register struct variable *v;
        -:20287:
    #####:20288:  for (i = 0; i < length; ++i)
branch  0 never executed
branch  1 never executed
    #####:20289:    HASH (hash, name[i]);
    #####:20290:  hash %= set->buckets;
        -:20291:
    #####:20292:  for (v = set->table[hash]; v != 0; v = v->next)
branch  0 never executed
branch  1 never executed
    #####:20293:    if (*v->name == *name
branch  0 never executed
branch  1 never executed
    #####:20294:        && strneq (v->name + 1, name + 1, length - 1)
branch  0 never executed
branch  1 never executed
    #####:20295:        && v->name[length] == 0)
branch  0 never executed
branch  1 never executed
    #####:20296:      return v;
        -:20297:
    #####:20298:  return 0;
        -:20299:}
        -:20300:
        -:20301:/* Initialize FILE's variable set list.  If FILE already has a variable set
        -:20302:   list, the topmost variable set is left intact, but the the rest of the
        -:20303:   chain is replaced with FILE->parent's setlist.  If we're READing a
        -:20304:   makefile, don't do the pattern variable search now, since the pattern
        -:20305:   variable might not have been defined yet.  */
        -:20306:
        -:20307:void
function initialize_file_variables called 0 returned 0% blocks executed 0%
    #####:20308:initialize_file_variables (file, reading)
        -:20309:     struct file *file;
        -:20310:     int reading;
        -:20311:{
    #####:20312:  register struct variable_set_list *l = file->variables;
        -:20313:
    #####:20314:  if (l == 0)
branch  0 never executed
branch  1 never executed
        -:20315:    {
        -:20316:      l = (struct variable_set_list *)
    #####:20317:	xmalloc (sizeof (struct variable_set_list));
call    0 never executed
    #####:20318:      l->set = (struct variable_set *) xmalloc (sizeof (struct variable_set));
call    0 never executed
    #####:20319:      l->set->buckets = PERFILE_VARIABLE_BUCKETS;
    #####:20320:      l->set->table = (struct variable **)
    #####:20321:	xmalloc (l->set->buckets * sizeof (struct variable *));
call    0 never executed
    #####:20322:      bzero ((char *) l->set->table,
        -:20323:	     l->set->buckets * sizeof (struct variable *));
    #####:20324:      file->variables = l;
        -:20325:    }
        -:20326:
    #####:20327:  if (file->parent == 0)
branch  0 never executed
branch  1 never executed
    #####:20328:    l->next = &global_setlist;
        -:20329:  else
        -:20330:    {
    #####:20331:      initialize_file_variables (file->parent, reading);
call    0 never executed
    #####:20332:      l->next = file->parent->variables;
        -:20333:    }
        -:20334:
        -:20335:  /* If we're not reading makefiles and we haven't looked yet, see if
        -:20336:     we can find a pattern variable.  */
        -:20337:
    #####:20338:  if (!reading && !file->pat_searched)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:20339:    {
    #####:20340:      struct pattern_var *p = lookup_pattern_var (file->name);
call    0 never executed
        -:20341:
    #####:20342:      file->pat_searched = 1;
    #####:20343:      if (p != 0)
branch  0 never executed
branch  1 never executed
        -:20344:        {
        -:20345:          /* If we found one, insert it between the current target's
        -:20346:             variables and the next set, whatever it is.  */
    #####:20347:          file->pat_variables = (struct variable_set_list *)
    #####:20348:            xmalloc (sizeof (struct variable_set_list));
call    0 never executed
    #####:20349:          file->pat_variables->set = p->vars->set;
        -:20350:        }
        -:20351:    }
        -:20352:
        -:20353:  /* If we have a pattern variable match, set it up.  */
        -:20354:
    #####:20355:  if (file->pat_variables != 0)
branch  0 never executed
branch  1 never executed
        -:20356:    {
    #####:20357:      file->pat_variables->next = l->next;
    #####:20358:      l->next = file->pat_variables;
        -:20359:    }
    #####:20360:}
        -:20361:
        -:20362:/* Pop the top set off the current variable set list,
        -:20363:   and free all its storage.  */
        -:20364:
        -:20365:void
function pop_variable_scope called 0 returned 0% blocks executed 0%
    #####:20366:pop_variable_scope ()
        -:20367:{
    #####:20368:  register struct variable_set_list *setlist = current_variable_set_list;
    #####:20369:  register struct variable_set *set = setlist->set;
        -:20370:  register unsigned int i;
        -:20371:
    #####:20372:  current_variable_set_list = setlist->next;
    #####:20373:  free ((char *) setlist);
        -:20374:
    #####:20375:  for (i = 0; i < set->buckets; ++i)
branch  0 never executed
branch  1 never executed
        -:20376:    {
    #####:20377:      register struct variable *next = set->table[i];
    #####:20378:      while (next != 0)
branch  0 never executed
branch  1 never executed
        -:20379:	{
    #####:20380:	  register struct variable *v = next;
    #####:20381:	  next = v->next;
        -:20382:
    #####:20383:	  free (v->name);
    #####:20384:	  if (v->value)
branch  0 never executed
branch  1 never executed
    #####:20385:	    free (v->value);
    #####:20386:	  free ((char *) v);
        -:20387:	}
        -:20388:    }
    #####:20389:  free ((char *) set->table);
    #####:20390:  free ((char *) set);
    #####:20391:}
        -:20392:
        -:20393:struct variable_set_list *
function create_new_variable_set called 0 returned 0% blocks executed 0%
    #####:20394:create_new_variable_set ()
        -:20395:{
        -:20396:  register struct variable_set_list *setlist;
        -:20397:  register struct variable_set *set;
        -:20398:
    #####:20399:  set = (struct variable_set *) xmalloc (sizeof (struct variable_set));
call    0 never executed
    #####:20400:  set->buckets = SMALL_SCOPE_VARIABLE_BUCKETS;
    #####:20401:  set->table = (struct variable **)
    #####:20402:    xmalloc (set->buckets * sizeof (struct variable *));
call    0 never executed
    #####:20403:  bzero ((char *) set->table, set->buckets * sizeof (struct variable *));
        -:20404:
        -:20405:  setlist = (struct variable_set_list *)
    #####:20406:    xmalloc (sizeof (struct variable_set_list));
call    0 never executed
    #####:20407:  setlist->set = set;
    #####:20408:  setlist->next = current_variable_set_list;
        -:20409:
    #####:20410:  return setlist;
        -:20411:}
        -:20412:
        -:20413:/* Create a new variable set and push it on the current setlist.  */
        -:20414:
        -:20415:struct variable_set_list *
function push_new_variable_scope called 0 returned 0% blocks executed 0%
    #####:20416:push_new_variable_scope ()
        -:20417:{
    #####:20418:  return (current_variable_set_list = create_new_variable_set());
call    0 never executed
        -:20419:}
        -:20420:
        -:20421:/* Merge SET1 into SET0, freeing unused storage in SET1.  */
        -:20422:
        -:20423:static void
function merge_variable_sets called 0 returned 0% blocks executed 0%
    #####:20424:merge_variable_sets (set0, set1)
        -:20425:     struct variable_set *set0, *set1;
        -:20426:{
        -:20427:  register unsigned int bucket1;
        -:20428:
    #####:20429:  for (bucket1 = 0; bucket1 < set1->buckets; ++bucket1)
branch  0 never executed
branch  1 never executed
        -:20430:    {
    #####:20431:      register struct variable *v1 = set1->table[bucket1];
    #####:20432:      while (v1 != 0)
branch  0 never executed
branch  1 never executed
        -:20433:	{
    #####:20434:	  struct variable *next = v1->next;
        -:20435:	  unsigned int bucket0;
        -:20436:	  register struct variable *v0;
        -:20437:
    #####:20438:	  if (set1->buckets >= set0->buckets)
branch  0 never executed
branch  1 never executed
    #####:20439:	    bucket0 = bucket1;
        -:20440:	  else
        -:20441:	    {
        -:20442:	      register char *n;
    #####:20443:	      bucket0 = 0;
    #####:20444:	      for (n = v1->name; *n != '\0'; ++n)
branch  0 never executed
branch  1 never executed
    #####:20445:		HASH (bucket0, *n);
        -:20446:	    }
    #####:20447:	  bucket0 %= set0->buckets;
        -:20448:
    #####:20449:	  for (v0 = set0->table[bucket0]; v0 != 0; v0 = v0->next)
branch  0 never executed
branch  1 never executed
    #####:20450:	    if (streq (v0->name, v1->name))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -:20451:	      break;
        -:20452:
    #####:20453:	  if (v0 == 0)
branch  0 never executed
branch  1 never executed
        -:20454:	    {
        -:20455:	      /* There is no variable in SET0 with the same name.  */
    #####:20456:	      v1->next = set0->table[bucket0];
    #####:20457:	      set0->table[bucket0] = v1;
        -:20458:	    }
        -:20459:	  else
        -:20460:	    {
        -:20461:	      /* The same variable exists in both sets.
        -:20462:		 SET0 takes precedence.  */
    #####:20463:	      free (v1->value);
    #####:20464:	      free ((char *) v1);
        -:20465:	    }
        -:20466:
    #####:20467:	  v1 = next;
        -:20468:	}
        -:20469:    }
    #####:20470:}
        -:20471:
        -:20472:/* Merge SETLIST1 into SETLIST0, freeing unused storage in SETLIST1.  */
        -:20473:
        -:20474:void
function merge_variable_set_lists called 0 returned 0% blocks executed 0%
    #####:20475:merge_variable_set_lists (setlist0, setlist1)
        -:20476:     struct variable_set_list **setlist0, *setlist1;
        -:20477:{
    #####:20478:  register struct variable_set_list *list0 = *setlist0;
    #####:20479:  struct variable_set_list *last0 = 0;
        -:20480:
    #####:20481:  while (setlist1 != 0 && list0 != 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:20482:    {
    #####:20483:      struct variable_set_list *next = setlist1;
    #####:20484:      setlist1 = setlist1->next;
        -:20485:
    #####:20486:      merge_variable_sets (list0->set, next->set);
call    0 never executed
        -:20487:
    #####:20488:      last0 = list0;
    #####:20489:      list0 = list0->next;
        -:20490:    }
        -:20491:
    #####:20492:  if (setlist1 != 0)
branch  0 never executed
branch  1 never executed
        -:20493:    {
    #####:20494:      if (last0 == 0)
branch  0 never executed
branch  1 never executed
    #####:20495:	*setlist0 = setlist1;
        -:20496:      else
    #####:20497:	last0->next = setlist1;
        -:20498:    }
    #####:20499:}
        -:20500:
        -:20501:/* Define the automatic variables, and record the addresses
        -:20502:   of their structures so we can change their values quickly.  */
        -:20503:
        -:20504:void
function define_automatic_variables called 1 returned 100% blocks executed 88%
        1:20505:define_automatic_variables ()
        -:20506:{
        -:20507:#ifdef WINDOWS32
        -:20508:  extern char* default_shell;
        -:20509:#else
        -:20510:  extern char default_shell[];
        -:20511:#endif
        -:20512:  register struct variable *v;
        -:20513:  char buf[200];
        -:20514:
        1:20515:  sprintf (buf, "%u", makelevel);
        1:20516:  (void) define_variable ("MAKELEVEL", 9, buf, o_env, 0);
call    0 returned 1
        -:20517:
       2*:20518:  sprintf (buf, "%s%s%s",
        -:20519:	   version_string,
       1*:20520:	   (remote_description == 0 || remote_description[0] == '\0')
branch  0 taken 0 (fallthrough)
branch  1 taken 1
branch  2 never executed
branch  3 never executed
        -:20521:	   ? "" : "-",
       1*:20522:	   (remote_description == 0 || remote_description[0] == '\0')
branch  0 taken 0 (fallthrough)
branch  1 taken 1
branch  2 never executed
branch  3 never executed
        -:20523:	   ? "" : remote_description);
        1:20524:  (void) define_variable ("MAKE_VERSION", 12, buf, o_default, 0);
call    0 returned 1
        -:20525:
        -:20526:#ifdef  __MSDOS__
        -:20527:  /* Allow to specify a special shell just for Make,
        -:20528:     and use $COMSPEC as the default $SHELL when appropriate.  */
        -:20529:  {
        -:20530:    static char shell_str[] = "SHELL";
        -:20531:    const int shlen = sizeof (shell_str) - 1;
        -:20532:    struct variable *mshp = lookup_variable ("MAKESHELL", 9);
        -:20533:    struct variable *comp = lookup_variable ("COMSPEC", 7);
        -:20534:
        -:20535:    /* Make $MAKESHELL override $SHELL even if -e is in effect.  */
        -:20536:    if (mshp)
        -:20537:      (void) define_variable (shell_str, shlen,
        -:20538:			      mshp->value, o_env_override, 0);
        -:20539:    else if (comp)
        -:20540:      {
        -:20541:	/* $COMSPEC shouldn't override $SHELL.  */
        -:20542:	struct variable *shp = lookup_variable (shell_str, shlen);
        -:20543:
        -:20544:	if (!shp)
        -:20545:	  (void) define_variable (shell_str, shlen, comp->value, o_env, 0);
        -:20546:      }
        -:20547:  }
        -:20548:#endif
        -:20549:
        -:20550:  /* This won't override any definition, but it
        -:20551:     will provide one if there isn't one there.  */
        1:20552:  v = define_variable ("SHELL", 5, default_shell, o_default, 0);
call    0 returned 1
        1:20553:  v->export = v_export;		/* Always export SHELL.  */
        -:20554:
        -:20555:  /* On MSDOS we do use SHELL from environment, since
        -:20556:     it isn't a standard environment variable on MSDOS,
        -:20557:     so whoever sets it, does that on purpose.  */
        -:20558:#ifndef __MSDOS__
        -:20559:  /* Don't let SHELL come from the environment.  */
        1:20560:  if (*v->value == '\0' || v->origin == o_env || v->origin == o_env_override)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
branch  2 taken 1 (fallthrough)
branch  3 taken 0
branch  4 taken 1 (fallthrough)
branch  5 taken 0
        -:20561:    {
        1:20562:      free (v->value);
        1:20563:      v->origin = o_file;
        1:20564:      v->value = xstrdup (default_shell);
call    0 returned 1
        -:20565:    }
        -:20566:#endif
        -:20567:
        -:20568:  /* Make sure MAKEFILES gets exported if it is set.  */
        1:20569:  v = define_variable ("MAKEFILES", 9, "", o_default, 0);
call    0 returned 1
        1:20570:  v->export = v_ifset;
        -:20571:
        -:20572:  /* Define the magic D and F variables in terms of
        -:20573:     the automatic variables they are variations of.  */
        -:20574:
        -:20575:#ifdef VMS
        -:20576:  define_variable ("@D", 2, "$(dir $@)", o_automatic, 1);
        -:20577:  define_variable ("%D", 2, "$(dir $%)", o_automatic, 1);
        -:20578:  define_variable ("*D", 2, "$(dir $*)", o_automatic, 1);
        -:20579:  define_variable ("<D", 2, "$(dir $<)", o_automatic, 1);
        -:20580:  define_variable ("?D", 2, "$(dir $?)", o_automatic, 1);
        -:20581:  define_variable ("^D", 2, "$(dir $^)", o_automatic, 1);
        -:20582:  define_variable ("+D", 2, "$(dir $+)", o_automatic, 1);
        -:20583:#else
        1:20584:  define_variable ("@D", 2, "$(patsubst %/,%,$(dir $@))", o_automatic, 1);
call    0 returned 1
        1:20585:  define_variable ("%D", 2, "$(patsubst %/,%,$(dir $%))", o_automatic, 1);
call    0 returned 1
        1:20586:  define_variable ("*D", 2, "$(patsubst %/,%,$(dir $*))", o_automatic, 1);
call    0 returned 1
        1:20587:  define_variable ("<D", 2, "$(patsubst %/,%,$(dir $<))", o_automatic, 1);
call    0 returned 1
        1:20588:  define_variable ("?D", 2, "$(patsubst %/,%,$(dir $?))", o_automatic, 1);
call    0 returned 1
        1:20589:  define_variable ("^D", 2, "$(patsubst %/,%,$(dir $^))", o_automatic, 1);
call    0 returned 1
        1:20590:  define_variable ("+D", 2, "$(patsubst %/,%,$(dir $+))", o_automatic, 1);
call    0 returned 1
        -:20591:#endif
        1:20592:  define_variable ("@F", 2, "$(notdir $@)", o_automatic, 1);
call    0 returned 1
        1:20593:  define_variable ("%F", 2, "$(notdir $%)", o_automatic, 1);
call    0 returned 1
        1:20594:  define_variable ("*F", 2, "$(notdir $*)", o_automatic, 1);
call    0 returned 1
        1:20595:  define_variable ("<F", 2, "$(notdir $<)", o_automatic, 1);
call    0 returned 1
        1:20596:  define_variable ("?F", 2, "$(notdir $?)", o_automatic, 1);
call    0 returned 1
        1:20597:  define_variable ("^F", 2, "$(notdir $^)", o_automatic, 1);
call    0 returned 1
        1:20598:  define_variable ("+F", 2, "$(notdir $+)", o_automatic, 1);
call    0 returned 1
        1:20599:}
        -:20600:
        -:20601:int export_all_variables;
        -:20602:
        -:20603:/* Create a new environment for FILE's commands.
        -:20604:   If FILE is nil, this is for the `shell' function.
        -:20605:   The child's MAKELEVEL variable is incremented.  */
        -:20606:
        -:20607:char **
function target_environment called 0 returned 0% blocks executed 0%
    #####:20608:target_environment (file)
        -:20609:     struct file *file;
        -:20610:{
        -:20611:  struct variable_set_list *set_list;
        -:20612:  register struct variable_set_list *s;
        -:20613:  struct variable_bucket
        -:20614:    {
        -:20615:      struct variable_bucket *next;
        -:20616:      struct variable *variable;
        -:20617:    };
        -:20618:  struct variable_bucket **table;
        -:20619:  unsigned int buckets;
        -:20620:  register unsigned int i;
        -:20621:  register unsigned nvariables;
        -:20622:  char **result;
        -:20623:  unsigned int mklev_hash;
        -:20624:
    #####:20625:  if (file == 0)
branch  0 never executed
branch  1 never executed
    #####:20626:    set_list = current_variable_set_list;
        -:20627:  else
    #####:20628:    set_list = file->variables;
        -:20629:
        -:20630:  /* Find the lowest number of buckets in any set in the list.  */
    #####:20631:  s = set_list;
    #####:20632:  buckets = s->set->buckets;
    #####:20633:  for (s = s->next; s != 0; s = s->next)
branch  0 never executed
branch  1 never executed
    #####:20634:    if (s->set->buckets < buckets)
branch  0 never executed
branch  1 never executed
    #####:20635:      buckets = s->set->buckets;
        -:20636:
        -:20637:  /* Find the hash value of the bucket `MAKELEVEL' will fall into.  */
        -:20638:  {
    #####:20639:    char *p = "MAKELEVEL";
    #####:20640:    mklev_hash = 0;
    #####:20641:    while (*p != '\0')
branch  0 never executed
branch  1 never executed
    #####:20642:      HASH (mklev_hash, *p++);
        -:20643:  }
        -:20644:
        -:20645:  /* Temporarily allocate a table with that many buckets.  */
        -:20646:  table = (struct variable_bucket **)
    #####:20647:    alloca (buckets * sizeof (struct variable_bucket *));
    #####:20648:  bzero ((char *) table, buckets * sizeof (struct variable_bucket *));
        -:20649:
        -:20650:  /* Run through all the variable sets in the list,
        -:20651:     accumulating variables in TABLE.  */
    #####:20652:  nvariables = 0;
    #####:20653:  for (s = set_list; s != 0; s = s->next)
branch  0 never executed
branch  1 never executed
        -:20654:    {
    #####:20655:      register struct variable_set *set = s->set;
    #####:20656:      for (i = 0; i < set->buckets; ++i)
branch  0 never executed
branch  1 never executed
        -:20657:	{
        -:20658:	  register struct variable *v;
    #####:20659:	  for (v = set->table[i]; v != 0; v = v->next)
branch  0 never executed
branch  1 never executed
        -:20660:	    {
    #####:20661:	      unsigned int j = i % buckets;
        -:20662:	      register struct variable_bucket *ov;
    #####:20663:	      register char *p = v->name;
        -:20664:
    #####:20665:	      if (i == mklev_hash % set->buckets
branch  0 never executed
branch  1 never executed
    #####:20666:		  && streq (v->name, "MAKELEVEL"))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -:20667:		/* Don't include MAKELEVEL because it will be
        -:20668:		   added specially at the end.  */
    #####:20669:		continue;
        -:20670:
        -:20671:              /* If this is a per-target variable and it hasn't been touched
        -:20672:                 already then look up the global version and take its export
        -:20673:                 value.  */
    #####:20674:              if (v->per_target && v->export == v_default)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:20675:                {
        -:20676:                  struct variable *gv;
        -:20677:
    #####:20678:                  gv = lookup_variable_in_set(v->name, strlen(v->name),
call    0 never executed
        -:20679:                                              &global_variable_set);
    #####:20680:                  if (gv)
branch  0 never executed
branch  1 never executed
    #####:20681:                    v->export = gv->export;
        -:20682:                }
        -:20683:
    #####:20684:	      switch (v->export)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:20685:		{
    #####:20686:		case v_default:
    #####:20687:		  if (v->origin == o_default || v->origin == o_automatic)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:20688:		    /* Only export default variables by explicit request.  */
    #####:20689:		    continue;
        -:20690:
    #####:20691:		  if (! export_all_variables
branch  0 never executed
branch  1 never executed
    #####:20692:		      && v->origin != o_command
branch  0 never executed
branch  1 never executed
    #####:20693:		      && v->origin != o_env && v->origin != o_env_override)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:20694:		    continue;
        -:20695:
    #####:20696:		  if (*p != '_' && (*p < 'A' || *p > 'Z')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:20697:		      && (*p < 'a' || *p > 'z'))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:20698:		    continue;
    #####:20699:		  for (++p; *p != '\0'; ++p)
branch  0 never executed
branch  1 never executed
    #####:20700:		    if (*p != '_' && (*p < 'a' || *p > 'z')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:20701:			&& (*p < 'A' || *p > 'Z') && (*p < '0' || *p > '9'))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:20702:		      continue;
    #####:20703:		  if (*p != '\0')
branch  0 never executed
branch  1 never executed
    #####:20704:		    continue;
    #####:20705:		  break;
        -:20706:
    #####:20707:                case v_export:
    #####:20708:                  break;
        -:20709:
    #####:20710:                case v_noexport:
    #####:20711:                  continue;
        -:20712:
    #####:20713:		case v_ifset:
    #####:20714:		  if (v->origin == o_default)
branch  0 never executed
branch  1 never executed
    #####:20715:		    continue;
    #####:20716:		  break;
        -:20717:		}
        -:20718:
        -:20719:              /* If this was from a different-sized hash table, then
        -:20720:                 recalculate the bucket it goes in.  */
    #####:20721:              if (set->buckets != buckets)
branch  0 never executed
branch  1 never executed
        -:20722:                {
        -:20723:                  register char *np;
        -:20724:
    #####:20725:                  j = 0;
    #####:20726:                  for (np = v->name; *np != '\0'; ++np)
branch  0 never executed
branch  1 never executed
    #####:20727:                    HASH (j, *np);
    #####:20728:                  j %= buckets;
        -:20729:                }
        -:20730:
    #####:20731:	      for (ov = table[j]; ov != 0; ov = ov->next)
branch  0 never executed
branch  1 never executed
    #####:20732:		if (streq (v->name, ov->variable->name))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -:20733:		  break;
        -:20734:
    #####:20735:	      if (ov == 0)
branch  0 never executed
branch  1 never executed
        -:20736:		{
        -:20737:		  register struct variable_bucket *entry;
        -:20738:		  entry = (struct variable_bucket *)
    #####:20739:		    alloca (sizeof (struct variable_bucket));
    #####:20740:		  entry->next = table[j];
    #####:20741:		  entry->variable = v;
    #####:20742:		  table[j] = entry;
    #####:20743:		  ++nvariables;
        -:20744:		}
        -:20745:	    }
        -:20746:	}
        -:20747:    }
        -:20748:
    #####:20749:  result = (char **) xmalloc ((nvariables + 2) * sizeof (char *));
call    0 never executed
    #####:20750:  nvariables = 0;
    #####:20751:  for (i = 0; i < buckets; ++i)
branch  0 never executed
branch  1 never executed
        -:20752:    {
        -:20753:      register struct variable_bucket *b;
    #####:20754:      for (b = table[i]; b != 0; b = b->next)
branch  0 never executed
branch  1 never executed
        -:20755:	{
    #####:20756:	  register struct variable *v = b->variable;
        -:20757:
        -:20758:	  /* If V is recursively expanded and didn't come from the environment,
        -:20759:	     expand its value.  If it came from the environment, it should
        -:20760:	     go back into the environment unchanged.  */
    #####:20761:	  if (v->recursive
branch  0 never executed
branch  1 never executed
    #####:20762:	      && v->origin != o_env && v->origin != o_env_override)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:20763:	    {
    #####:20764:	      char *value = recursively_expand (v);
call    0 never executed
        -:20765:#ifdef WINDOWS32
        -:20766:              if (strcmp(v->name, "Path") == 0 ||
        -:20767:                  strcmp(v->name, "PATH") == 0)
        -:20768:                convert_Path_to_windows32(value, ';');
        -:20769:#endif
    #####:20770:	      result[nvariables++] = concat (v->name, "=", value);
call    0 never executed
    #####:20771:	      free (value);
        -:20772:	    }
        -:20773:	  else
        -:20774:#ifdef WINDOWS32
        -:20775:          {
        -:20776:            if (strcmp(v->name, "Path") == 0 ||
        -:20777:                strcmp(v->name, "PATH") == 0)
        -:20778:              convert_Path_to_windows32(v->value, ';');
        -:20779:            result[nvariables++] = concat (v->name, "=", v->value);
        -:20780:          }
        -:20781:#else
    #####:20782:	    result[nvariables++] = concat (v->name, "=", v->value);
call    0 never executed
        -:20783:#endif
        -:20784:	}
        -:20785:    }
    #####:20786:  result[nvariables] = (char *) xmalloc (100);
call    0 never executed
    #####:20787:  (void) sprintf (result[nvariables], "MAKELEVEL=%u", makelevel + 1);
    #####:20788:  result[++nvariables] = 0;
        -:20789:
    #####:20790:  return result;
        -:20791:}
        -:20792:
        -:20793:/* Try to interpret LINE (a null-terminated string) as a variable definition.
        -:20794:
        -:20795:   ORIGIN may be o_file, o_override, o_env, o_env_override,
        -:20796:   or o_command specifying that the variable definition comes
        -:20797:   from a makefile, an override directive, the environment with
        -:20798:   or without the -e switch, or the command line.
        -:20799:
        -:20800:   See the comments for parse_variable_definition().
        -:20801:
        -:20802:   If LINE was recognized as a variable definition, a pointer to its `struct
        -:20803:   variable' is returned.  If LINE is not a variable definition, NULL is
        -:20804:   returned.  */
        -:20805:
        -:20806:struct variable *
function try_variable_definition called 0 returned 0% blocks executed 0%
    #####:20807:try_variable_definition (flocp, line, origin, target_var)
        -:20808:     const struct floc *flocp;
        -:20809:     char *line;
        -:20810:     enum variable_origin origin;
        -:20811:     int target_var;
        -:20812:{
        -:20813:  register int c;
    #####:20814:  register char *p = line;
        -:20815:  register char *beg;
        -:20816:  register char *end;
        -:20817:  enum { f_bogus,
    #####:20818:         f_simple, f_recursive, f_append, f_conditional } flavor = f_bogus;
    #####:20819:  char *name, *expanded_name, *value, *alloc_value=NULL;
        -:20820:  struct variable *v;
    #####:20821:  int append = 0;
        -:20822:
        -:20823:  while (1)
        -:20824:    {
    #####:20825:      c = *p++;
    #####:20826:      if (c == '\0' || c == '#')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:20827:	return 0;
    #####:20828:      if (c == '=')
branch  0 never executed
branch  1 never executed
        -:20829:	{
    #####:20830:	  end = p - 1;
    #####:20831:	  flavor = f_recursive;
    #####:20832:	  break;
        -:20833:	}
    #####:20834:      else if (c == ':')
branch  0 never executed
branch  1 never executed
    #####:20835:	if (*p == '=')
branch  0 never executed
branch  1 never executed
        -:20836:	  {
    #####:20837:	    end = p++ - 1;
    #####:20838:	    flavor = f_simple;
    #####:20839:	    break;
        -:20840:	  }
        -:20841:	else
        -:20842:	  /* A colon other than := is a rule line, not a variable defn.  */
    #####:20843:	  return 0;
    #####:20844:      else if (c == '+' && *p == '=')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:20845:	{
    #####:20846:	  end = p++ - 1;
    #####:20847:	  flavor = f_append;
    #####:20848:	  break;
        -:20849:	}
    #####:20850:      else if (c == '?' && *p == '=')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:20851:        {
    #####:20852:          end = p++ - 1;
    #####:20853:          flavor = f_conditional;
    #####:20854:          break;
        -:20855:        }
    #####:20856:      else if (c == '$')
branch  0 never executed
branch  1 never executed
        -:20857:	{
        -:20858:	  /* This might begin a variable expansion reference.  Make sure we
        -:20859:	     don't misrecognize chars inside the reference as =, := or +=.  */
        -:20860:	  char closeparen;
        -:20861:	  int count;
    #####:20862:	  c = *p++;
    #####:20863:	  if (c == '(')
branch  0 never executed
branch  1 never executed
    #####:20864:	    closeparen = ')';
    #####:20865:	  else if (c == '{')
branch  0 never executed
branch  1 never executed
    #####:20866:	    closeparen = '}';
        -:20867:	  else
    #####:20868:	    continue;		/* Nope.  */
        -:20869:
        -:20870:	  /* P now points past the opening paren or brace.
        -:20871:	     Count parens or braces until it is matched.  */
    #####:20872:	  count = 0;
    #####:20873:	  for (; *p != '\0'; ++p)
branch  0 never executed
branch  1 never executed
        -:20874:	    {
    #####:20875:	      if (*p == c)
branch  0 never executed
branch  1 never executed
    #####:20876:		++count;
    #####:20877:	      else if (*p == closeparen && --count < 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:20878:		{
    #####:20879:		  ++p;
    #####:20880:		  break;
        -:20881:		}
        -:20882:	    }
        -:20883:	}
        -:20884:    }
        -:20885:
    #####:20886:  beg = next_token (line);
call    0 never executed
    #####:20887:  while (end > beg && isblank (end[-1]))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:20888:    --end;
    #####:20889:  p = next_token (p);
call    0 never executed
        -:20890:
        -:20891:  /* Expand the name, so "$(foo)bar = baz" works.  */
    #####:20892:  name = (char *) alloca (end - beg + 1);
    #####:20893:  bcopy (beg, name, end - beg);
    #####:20894:  name[end - beg] = '\0';
    #####:20895:  expanded_name = allocated_variable_expand (name);
call    0 never executed
        -:20896:
    #####:20897:  if (expanded_name[0] == '\0')
branch  0 never executed
branch  1 never executed
    #####:20898:    fatal (flocp, _("empty variable name"));
call    0 never executed
        -:20899:
        -:20900:  /* Calculate the variable's new value in VALUE.  */
        -:20901:
    #####:20902:  switch (flavor)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:20903:    {
    #####:20904:    case f_bogus:
        -:20905:      /* Should not be possible.  */
    #####:20906:      abort ();
call    0 never executed
    #####:20907:    case f_simple:
        -:20908:      /* A simple variable definition "var := value".  Expand the value.
        -:20909:         We have to allocate memory since otherwise it'll clobber the
        -:20910:	 variable buffer, and we may still need that if we're looking at a
        -:20911:         target-specific variable.  */
    #####:20912:      value = alloc_value = allocated_variable_expand (p);
call    0 never executed
    #####:20913:      break;
    #####:20914:    case f_conditional:
        -:20915:      /* A conditional variable definition "var ?= value".
        -:20916:         The value is set IFF the variable is not defined yet. */
    #####:20917:      v = lookup_variable(expanded_name, strlen(expanded_name));
call    0 never executed
    #####:20918:      if (v)
branch  0 never executed
branch  1 never executed
        -:20919:        {
    #####:20920:          free(expanded_name);
    #####:20921:          return v;
        -:20922:        }
    #####:20923:      flavor = f_recursive;
        -:20924:      /* FALLTHROUGH */
    #####:20925:    case f_recursive:
        -:20926:      /* A recursive variable definition "var = value".
        -:20927:	 The value is used verbatim.  */
    #####:20928:      value = p;
    #####:20929:      break;
    #####:20930:    case f_append:
        -:20931:      /* If we have += but we're in a target variable context, defer the
        -:20932:         append until the context expansion.  */
    #####:20933:      if (target_var)
branch  0 never executed
branch  1 never executed
        -:20934:        {
    #####:20935:          append = 1;
    #####:20936:          flavor = f_recursive;
    #####:20937:          value = p;
    #####:20938:          break;
        -:20939:        }
        -:20940:
        -:20941:      /* An appending variable definition "var += value".
        -:20942:	 Extract the old value and append the new one.  */
    #####:20943:      v = lookup_variable (expanded_name, strlen (expanded_name));
call    0 never executed
    #####:20944:      if (v == 0)
branch  0 never executed
branch  1 never executed
        -:20945:	{
        -:20946:	  /* There was no old value.
        -:20947:	     This becomes a normal recursive definition.  */
    #####:20948:	  value = p;
    #####:20949:	  flavor = f_recursive;
        -:20950:	}
        -:20951:      else
        -:20952:	{
        -:20953:	  /* Paste the old and new values together in VALUE.  */
        -:20954:
        -:20955:	  unsigned int oldlen, newlen;
        -:20956:
    #####:20957:	  if (v->recursive)
branch  0 never executed
branch  1 never executed
        -:20958:	    /* The previous definition of the variable was recursive.
        -:20959:	       The new value comes from the unexpanded old and new values.  */
    #####:20960:	    flavor = f_recursive;
        -:20961:	  else
        -:20962:	    /* The previous definition of the variable was simple.
        -:20963:	       The new value comes from the old value, which was expanded
        -:20964:	       when it was set; and from the expanded new value.  Allocate
        -:20965:               memory for the expansion as we may still need the rest of the
        -:20966:               buffer if we're looking at a target-specific variable.  */
    #####:20967:	    p = alloc_value = allocated_variable_expand (p);
call    0 never executed
        -:20968:
    #####:20969:	  oldlen = strlen (v->value);
    #####:20970:	  newlen = strlen (p);
    #####:20971:	  value = (char *) alloca (oldlen + 1 + newlen + 1);
    #####:20972:	  bcopy (v->value, value, oldlen);
    #####:20973:	  value[oldlen] = ' ';
    #####:20974:	  bcopy (p, &value[oldlen + 1], newlen + 1);
        -:20975:	}
        -:20976:    }
        -:20977:
        -:20978:#ifdef __MSDOS__
        -:20979:  /* Many Unix Makefiles include a line saying "SHELL=/bin/sh", but
        -:20980:     non-Unix systems don't conform to this default configuration (in
        -:20981:     fact, most of them don't even have `/bin').  On the other hand,
        -:20982:     $SHELL in the environment, if set, points to the real pathname of
        -:20983:     the shell.
        -:20984:     Therefore, we generally won't let lines like "SHELL=/bin/sh" from
        -:20985:     the Makefile override $SHELL from the environment.  But first, we
        -:20986:     look for the basename of the shell in the directory where SHELL=
        -:20987:     points, and along the $PATH; if it is found in any of these places,
        -:20988:     we define $SHELL to be the actual pathname of the shell.  Thus, if
        -:20989:     you have bash.exe installed as d:/unix/bash.exe, and d:/unix is on
        -:20990:     your $PATH, then SHELL=/usr/local/bin/bash will have the effect of
        -:20991:     defining SHELL to be "d:/unix/bash.exe".  */
        -:20992:  if ((origin == o_file || origin == o_override)
        -:20993:      && strcmp (expanded_name, "SHELL") == 0)
        -:20994:    {
        -:20995:      char shellpath[PATH_MAX];
        -:20996:      extern char * __dosexec_find_on_path (const char *, char *[], char *);
        -:20997:
        -:20998:      /* See if we can find "/bin/sh.exe", "/bin/sh.com", etc.  */
        -:20999:      if (__dosexec_find_on_path (value, (char **)0, shellpath))
        -:21000:	{
        -:21001:	  char *p;
        -:21002:
        -:21003:	  for (p = shellpath; *p; p++)
        -:21004:	    {
        -:21005:	      if (*p == '\\')
        -:21006:		*p = '/';
        -:21007:	    }
        -:21008:	  v = define_variable_loc (expanded_name, strlen (expanded_name),
        -:21009:                                   shellpath, origin, flavor == f_recursive,
        -:21010:                                   flocp);
        -:21011:	}
        -:21012:      else
        -:21013:	{
        -:21014:	  char *shellbase, *bslash;
        -:21015:	  struct variable *pathv = lookup_variable ("PATH", 4);
        -:21016:	  char *path_string;
        -:21017:	  char *fake_env[2];
        -:21018:	  size_t pathlen = 0;
        -:21019:
        -:21020:	  shellbase = strrchr (value, '/');
        -:21021:	  bslash = strrchr (value, '\\');
        -:21022:	  if (!shellbase || bslash > shellbase)
        -:21023:	    shellbase = bslash;
        -:21024:	  if (!shellbase && value[1] == ':')
        -:21025:	    shellbase = value + 1;
        -:21026:	  if (shellbase)
        -:21027:	    shellbase++;
        -:21028:	  else
        -:21029:	    shellbase = value;
        -:21030:
        -:21031:	  /* Search for the basename of the shell (with standard
        -:21032:	     executable extensions) along the $PATH.  */
        -:21033:	  if (pathv)
        -:21034:	    pathlen = strlen (pathv->value);
        -:21035:	  path_string = (char *)xmalloc (5 + pathlen + 2 + 1);
        -:21036:	  /* On MSDOS, current directory is considered as part of $PATH.  */
        -:21037:	  sprintf (path_string, "PATH=.;%s", pathv ? pathv->value : "");
        -:21038:	  fake_env[0] = path_string;
        -:21039:	  fake_env[1] = (char *)0;
        -:21040:	  if (__dosexec_find_on_path (shellbase, fake_env, shellpath))
        -:21041:	    {
        -:21042:	      char *p;
        -:21043:
        -:21044:	      for (p = shellpath; *p; p++)
        -:21045:		{
        -:21046:		  if (*p == '\\')
        -:21047:		    *p = '/';
        -:21048:		}
        -:21049:	      v = define_variable_loc (expanded_name, strlen (expanded_name),
        -:21050:                                       shellpath, origin,
        -:21051:                                       flavor == f_recursive, flocp);
        -:21052:	    }
        -:21053:	  else
        -:21054:	    v = lookup_variable (expanded_name, strlen (expanded_name));
        -:21055:
        -:21056:	  free (path_string);
        -:21057:	}
        -:21058:    }
        -:21059:  else
        -:21060:#endif /* __MSDOS__ */
        -:21061:#ifdef WINDOWS32
        -:21062:  if ((origin == o_file || origin == o_override)
        -:21063:      && strcmp (expanded_name, "SHELL") == 0) {
        -:21064:    extern char* default_shell;
        -:21065:
        -:21066:    /*
        -:21067:     * Call shell locator function. If it returns TRUE, then
        -:21068:	 * set no_default_sh_exe to indicate sh was found and
        -:21069:     * set new value for SHELL variable.
        -:21070:	 */
        -:21071:    if (find_and_set_default_shell(value)) {
        -:21072:       v = define_variable_loc (expanded_name, strlen (expanded_name),
        -:21073:                                default_shell, origin, flavor == f_recursive,
        -:21074:                                flocp);
        -:21075:       no_default_sh_exe = 0;
        -:21076:    }
        -:21077:  } else
        -:21078:#endif
        -:21079:
    #####:21080:  v = define_variable_loc (expanded_name, strlen (expanded_name), value,
call    0 never executed
        -:21081:                           origin, flavor == f_recursive, flocp);
        -:21082:
    #####:21083:  v->append = append;
        -:21084:
    #####:21085:  if (alloc_value)
branch  0 never executed
branch  1 never executed
    #####:21086:    free (alloc_value);
    #####:21087:  free (expanded_name);
        -:21088:
    #####:21089:  return v;
        -:21090:}
        -:21091:
        -:21092:/* Print information for variable V, prefixing it with PREFIX.  */
        -:21093:
        -:21094:static void
function print_variable called 132 returned 100% blocks executed 77%
      132:21095:print_variable (v, prefix)
        -:21096:     register struct variable *v;
        -:21097:     char *prefix;
        -:21098:{
        -:21099:  const char *origin;
        -:21100:
      132:21101:  switch (v->origin)
branch  0 taken 65
branch  1 taken 49
branch  2 taken 2
branch  3 taken 2
branch  4 taken 0
branch  5 taken 0
branch  6 taken 14
branch  7 taken 0
        -:21102:    {
       65:21103:    case o_default:
       65:21104:      origin = _("default");
       65:21105:      break;
       49:21106:    case o_env:
       49:21107:      origin = _("environment");
       49:21108:      break;
        2:21109:    case o_file:
        2:21110:      origin = _("makefile");
        2:21111:      break;
        2:21112:    case o_env_override:
        2:21113:      origin = _("environment under -e");
        2:21114:      break;
    #####:21115:    case o_command:
    #####:21116:      origin = _("command line");
    #####:21117:      break;
    #####:21118:    case o_override:
    #####:21119:      origin = _("`override' directive");
    #####:21120:      break;
       14:21121:    case o_automatic:
       14:21122:      origin = _("automatic");
       14:21123:      break;
    #####:21124:    case o_invalid:
        -:21125:    default:
    #####:21126:      abort ();
call    0 never executed
        -:21127:    }
      132:21128:  fputs ("# ", stdout);
call    0 returned 132
      132:21129:  fputs (origin, stdout);
call    0 returned 132
      132:21130:  if (v->fileinfo.filenm)
branch  0 taken 0 (fallthrough)
branch  1 taken 132
    #####:21131:    printf (" (from `%s', line %lu)", v->fileinfo.filenm, v->fileinfo.lineno);
call    0 never executed
      132:21132:  putchar ('\n');
call    0 returned 132
      132:21133:  fputs (prefix, stdout);
call    0 returned 132
        -:21134:
        -:21135:  /* Is this a `define'?  */
      132:21136:  if (v->recursive && strchr (v->value, '\n') != 0)
branch  0 taken 126 (fallthrough)
branch  1 taken 6
branch  2 taken 0 (fallthrough)
branch  3 taken 126
    #####:21137:    printf ("define %s\n%s\nendef\n", v->name, v->value);
call    0 never executed
        -:21138:  else
        -:21139:    {
        -:21140:      register char *p;
        -:21141:
     132*:21142:      printf ("%s %s= ", v->name, v->recursive ? v->append ? "+" : "" : ":");
branch  0 taken 126 (fallthrough)
branch  1 taken 6
branch  2 taken 0 (fallthrough)
branch  3 taken 126
call    4 returned 132
        -:21143:
        -:21144:      /* Check if the value is just whitespace.  */
      132:21145:      p = next_token (v->value);
call    0 returned 132
     132*:21146:      if (p != v->value && *p == '\0')
branch  0 taken 0 (fallthrough)
branch  1 taken 132
branch  2 never executed
branch  3 never executed
        -:21147:	/* All whitespace.  */
    #####:21148:	printf ("$(subst ,,%s)", v->value);
call    0 never executed
      132:21149:      else if (v->recursive)
branch  0 taken 126 (fallthrough)
branch  1 taken 6
      126:21150:	fputs (v->value, stdout);
call    0 returned 126
        -:21151:      else
        -:21152:	/* Double up dollar signs.  */
      244:21153:	for (p = v->value; *p != '\0'; ++p)
branch  0 taken 238
branch  1 taken 6 (fallthrough)
        -:21154:	  {
      238:21155:	    if (*p == '$')
branch  0 taken 0 (fallthrough)
branch  1 taken 238
    #####:21156:	      putchar ('$');
call    0 never executed
      238:21157:	    putchar (*p);
call    0 returned 238
        -:21158:	  }
      132:21159:      putchar ('\n');
call    0 returned 132
        -:21160:    }
      132:21161:}
        -:21162:
        -:21163:
        -:21164:/* Print all the variables in SET.  PREFIX is printed before
        -:21165:   the actual variable definitions (everything else is comments).  */
        -:21166:
        -:21167:void
function print_variable_set called 1 returned 100% blocks executed 93%
        1:21168:print_variable_set (set, prefix)
        -:21169:     register struct variable_set *set;
        -:21170:     char *prefix;
        -:21171:{
        -:21172:  register unsigned int i, nvariables, per_bucket;
        -:21173:  register struct variable *v;
        -:21174:
        1:21175:  per_bucket = nvariables = 0;
      524:21176:  for (i = 0; i < set->buckets; ++i)
branch  0 taken 523
branch  1 taken 1 (fallthrough)
        -:21177:    {
      523:21178:      register unsigned int this_bucket = 0;
        -:21179:
      655:21180:      for (v = set->table[i]; v != 0; v = v->next)
branch  0 taken 132
branch  1 taken 523 (fallthrough)
        -:21181:	{
      132:21182:	  ++this_bucket;
      132:21183:	  print_variable (v, prefix);
call    0 returned 132
        -:21184:	}
        -:21185:
      523:21186:      nvariables += this_bucket;
      523:21187:      if (this_bucket > per_bucket)
branch  0 taken 2 (fallthrough)
branch  1 taken 521
        2:21188:	per_bucket = this_bucket;
        -:21189:    }
        -:21190:
        1:21191:  if (nvariables == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:21192:    puts (_("# No variables."));
call    0 never executed
        -:21193:  else
        -:21194:    {
        1:21195:      printf (_("# %u variables in %u hash buckets.\n"),
call    0 returned 1
        -:21196:	      nvariables, set->buckets);
        -:21197:#ifndef	NO_FLOAT
        1:21198:      printf (_("# average of %.1f variables per bucket, \
        -:21199:max %u in one bucket.\n"),
        1:21200:	      (double) nvariables / (double) set->buckets,
call    0 returned 1
        -:21201:	      per_bucket);
        -:21202:#else
        -:21203:      {
        -:21204:	int f = (nvariables * 1000 + 5) / set->buckets;
        -:21205:	printf (_("# average of %d.%d variables per bucket, \
        -:21206:max %u in one bucket.\n"),
        -:21207:	      f/10, f%10,
        -:21208:	      per_bucket);
        -:21209:      }
        -:21210:#endif
        -:21211:    }
        1:21212:}
        -:21213:
        -:21214:
        -:21215:/* Print the data base of variables.  */
        -:21216:
        -:21217:void
function print_variable_data_base called 1 returned 100% blocks executed 100%
        1:21218:print_variable_data_base ()
        -:21219:{
        1:21220:  puts (_("\n# Variables\n"));
call    0 returned 1
        -:21221:
        1:21222:  print_variable_set (&global_variable_set, "");
call    0 returned 1
        1:21223:}
        -:21224:
        -:21225:
        -:21226:/* Print all the local variables of FILE.  */
        -:21227:
        -:21228:void
function print_file_variables called 0 returned 0% blocks executed 0%
    #####:21229:print_file_variables (file)
        -:21230:     struct file *file;
        -:21231:{
    #####:21232:  if (file->variables != 0)
branch  0 never executed
branch  1 never executed
    #####:21233:    print_variable_set (file->variables->set, "# ");
call    0 never executed
    #####:21234:}
        -:21235:
        -:21236:#ifdef WINDOWS32
        -:21237:void
        -:21238:sync_Path_environment(void)
        -:21239:{
        -:21240:    char* path = allocated_variable_expand("$(Path)");
        -:21241:    static char* environ_path = NULL;
        -:21242:
        -:21243:    if (!path)
        -:21244:        return;
        -:21245:
        -:21246:    /*
        -:21247:     * If done this before, don't leak memory unnecessarily.
        -:21248:     * Free the previous entry before allocating new one.
        -:21249:     */
        -:21250:    if (environ_path)
        -:21251:        free(environ_path);
        -:21252:
        -:21253:    /*
        -:21254:     * Create something WINDOWS32 world can grok
        -:21255:     */
        -:21256:    convert_Path_to_windows32(path, ';');
        -:21257:    environ_path = concat("Path", "=", path);
        -:21258:    putenv(environ_path);
        -:21259:    free(path);
        -:21260:}
        -:21261:#endif
        -:21262:
        -:21263:
        -:21264:
        -:21265:/*************************************************************
        -:21266:  ============================================================
        -:21267:  ************************************************************
        -:21268:  ============================================================
        -:21269:  ************************************************************
        -:21270:                         vpath.c
        -:21271:  ************************************************************
        -:21272:  ============================================================
        -:21273:  ************************************************************
        -:21274:  ============================================================
        -:21275:  *************************************************************/
        -:21276:
        -:21277:/* Implementation of pattern-matching file search paths for GNU Make.
        -:21278:Copyright (C) 1988,89,91,92,93,94,95,96,97 Free Software Foundation, Inc.
        -:21279:This file is part of GNU Make.
        -:21280:
        -:21281:GNU Make is free software; you can redistribute it and/or modify
        -:21282:it under the terms of the GNU General Public License as published by
        -:21283:the Free Software Foundation; either version 2, or (at your option)
        -:21284:any later version.
        -:21285:
        -:21286:GNU Make is distributed in the hope that it will be useful,
        -:21287:but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:21288:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:21289:GNU General Public License for more details.
        -:21290:
        -:21291:You should have received a copy of the GNU General Public License
        -:21292:along with GNU Make; see the file COPYING.  If not, write to
        -:21293:the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
        -:21294:Boston, MA 02111-1307, USA.  */
        -:21295:
        -:21296:/* #include "make.h"  <- modification by J.Ruthruff, 7/28 */
        -:21297:/* #include "filedef.h"  <- modification by J.Ruthruff, 7/28 */
        -:21298:/* #include "variable.h"  <- modification by J.Ruthruff, 7/28 */
        -:21299:#undef stderr
        -:21300:#define stderr stdout
        -:21301:#ifdef WINDOWS32
        -:21302:#include "pathstuff.h"
        -:21303:#undef stderr
        -:21304:#define stderr stdout
        -:21305:#endif
        -:21306:
        -:21307:
        -:21308:/* Structure used to represent a selective VPATH searchpath.  */
        -:21309:
        -:21310:struct vpath
        -:21311:  {
        -:21312:    struct vpath *next;	/* Pointer to next struct in the linked list.  */
        -:21313:    char *pattern;	/* The pattern to match.  */
        -:21314:    char *percent;	/* Pointer into `pattern' where the `%' is.  */
        -:21315:    unsigned int patlen;/* Length of the pattern.  */
        -:21316:    char **searchpath;	/* Null-terminated list of directories.  */
        -:21317:    unsigned int maxlen;/* Maximum length of any entry in the list.  */
        -:21318:  };
        -:21319:
        -:21320:/* Linked-list of all selective VPATHs.  */
        -:21321:
        -:21322:static struct vpath *vpaths;
        -:21323:
        -:21324:/* Structure for the general VPATH given in the variable.  */
        -:21325:
        -:21326:static struct vpath *general_vpath;
        -:21327:
        -:21328:/* Structure for GPATH given in the variable.  */
        -:21329:
        -:21330:static struct vpath *gpaths;
        -:21331:
        -:21332:static int selective_vpath_search PARAMS ((struct vpath *path, char **file, FILE_TIMESTAMP *mtime_ptr));
        -:21333:
        -:21334:/* Reverse the chain of selective VPATH lists so they
        -:21335:   will be searched in the order given in the makefiles
        -:21336:   and construct the list from the VPATH variable.  */
        -:21337:
        -:21338:void
function build_vpath_lists called 1 returned 100% blocks executed 58%
        1:21339:build_vpath_lists ()
        -:21340:{
        1:21341:  register struct vpath *new = 0;
        -:21342:  register struct vpath *old, *nexto;
        -:21343:  register char *p;
        -:21344:
        -:21345:  /* Reverse the chain.  */
       1*:21346:  for (old = vpaths; old != 0; old = nexto)
branch  0 taken 0
branch  1 taken 1 (fallthrough)
        -:21347:    {
    #####:21348:      nexto = old->next;
    #####:21349:      old->next = new;
    #####:21350:      new = old;
        -:21351:    }
        -:21352:
        1:21353:  vpaths = new;
        -:21354:
        -:21355:  /* If there is a VPATH variable with a nonnull value, construct the
        -:21356:     general VPATH list from it.  We use variable_expand rather than just
        -:21357:     calling lookup_variable so that it will be recursively expanded.  */
        -:21358:
        -:21359:  {
        -:21360:    /* Turn off --warn-undefined-variables while we expand SHELL and IFS.  */
        1:21361:    int save = warn_undefined_variables_flag;
        1:21362:    warn_undefined_variables_flag = 0;
        -:21363:
        1:21364:    p = variable_expand ("$(strip $(VPATH))");
call    0 returned 1
        -:21365:
        1:21366:    warn_undefined_variables_flag = save;
        -:21367:  }
        -:21368:
        1:21369:  if (*p != '\0')
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -:21370:    {
        -:21371:      /* Save the list of vpaths.  */
    #####:21372:      struct vpath *save_vpaths = vpaths;
        -:21373:
        -:21374:      /* Empty `vpaths' so the new one will have no next, and `vpaths'
        -:21375:	 will still be nil if P contains no existing directories.  */
    #####:21376:      vpaths = 0;
        -:21377:
        -:21378:      /* Parse P.  */
    #####:21379:      construct_vpath_list ("%", p);
call    0 never executed
        -:21380:
        -:21381:      /* Store the created path as the general path,
        -:21382:	 and restore the old list of vpaths.  */
    #####:21383:      general_vpath = vpaths;
    #####:21384:      vpaths = save_vpaths;
        -:21385:    }
        -:21386:
        -:21387:  /* If there is a GPATH variable with a nonnull value, construct the
        -:21388:     GPATH list from it.  We use variable_expand rather than just
        -:21389:     calling lookup_variable so that it will be recursively expanded.  */
        -:21390:
        -:21391:  {
        -:21392:    /* Turn off --warn-undefined-variables while we expand SHELL and IFS.  */
        1:21393:    int save = warn_undefined_variables_flag;
        1:21394:    warn_undefined_variables_flag = 0;
        -:21395:
        1:21396:    p = variable_expand ("$(strip $(GPATH))");
call    0 returned 1
        -:21397:
        1:21398:    warn_undefined_variables_flag = save;
        -:21399:  }
        -:21400:
        1:21401:  if (*p != '\0')
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -:21402:    {
        -:21403:      /* Save the list of vpaths.  */
    #####:21404:      struct vpath *save_vpaths = vpaths;
        -:21405:
        -:21406:      /* Empty `vpaths' so the new one will have no next, and `vpaths'
        -:21407:	 will still be nil if P contains no existing directories.  */
    #####:21408:      vpaths = 0;
        -:21409:
        -:21410:      /* Parse P.  */
    #####:21411:      construct_vpath_list ("%", p);
call    0 never executed
        -:21412:
        -:21413:      /* Store the created path as the GPATH,
        -:21414:	 and restore the old list of vpaths.  */
    #####:21415:      gpaths = vpaths;
    #####:21416:      vpaths = save_vpaths;
        -:21417:    }
        1:21418:}
        -:21419:
        -:21420:/* Construct the VPATH listing for the pattern and searchpath given.
        -:21421:
        -:21422:   This function is called to generate selective VPATH lists and also for
        -:21423:   the general VPATH list (which is in fact just a selective VPATH that
        -:21424:   is applied to everything).  The returned pointer is either put in the
        -:21425:   linked list of all selective VPATH lists or in the GENERAL_VPATH
        -:21426:   variable.
        -:21427:
        -:21428:   If SEARCHPATH is nil, remove all previous listings with the same
        -:21429:   pattern.  If PATTERN is nil, remove all VPATH listings.  Existing
        -:21430:   and readable directories that are not "." given in the searchpath
        -:21431:   separated by the path element separator (defined in make.h) are
        -:21432:   loaded into the directory hash table if they are not there already
        -:21433:   and put in the VPATH searchpath for the given pattern with trailing
        -:21434:   slashes stripped off if present (and if the directory is not the
        -:21435:   root, "/").  The length of the longest entry in the list is put in
        -:21436:   the structure as well.  The new entry will be at the head of the
        -:21437:   VPATHS chain.  */
        -:21438:
        -:21439:void
function construct_vpath_list called 0 returned 0% blocks executed 0%
    #####:21440:construct_vpath_list (pattern, dirpath)
        -:21441:     char *pattern, *dirpath;
        -:21442:{
        -:21443:  register unsigned int elem;
        -:21444:  register char *p;
        -:21445:  register char **vpath;
        -:21446:  register unsigned int maxvpath;
        -:21447:  unsigned int maxelem;
    #####:21448:  char *percent = NULL;
        -:21449:
    #####:21450:  if (pattern != 0)
branch  0 never executed
branch  1 never executed
        -:21451:    {
    #####:21452:      pattern = xstrdup (pattern);
call    0 never executed
    #####:21453:      percent = find_percent (pattern);
call    0 never executed
        -:21454:    }
        -:21455:
    #####:21456:  if (dirpath == 0)
branch  0 never executed
branch  1 never executed
        -:21457:    {
        -:21458:      /* Remove matching listings.  */
        -:21459:      register struct vpath *path, *lastpath;
        -:21460:
    #####:21461:      lastpath = 0;
    #####:21462:      path = vpaths;
    #####:21463:      while (path != 0)
branch  0 never executed
branch  1 never executed
        -:21464:	{
    #####:21465:	  struct vpath *next = path->next;
        -:21466:
    #####:21467:	  if (pattern == 0
branch  0 never executed
branch  1 never executed
    #####:21468:	      || (((percent == 0 && path->percent == 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:21469:		   || (percent - pattern == path->percent - path->pattern))
branch  0 never executed
branch  1 never executed
    #####:21470:		  && streq (pattern, path->pattern)))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -:21471:	    {
        -:21472:	      /* Remove it from the linked list.  */
    #####:21473:	      if (lastpath == 0)
branch  0 never executed
branch  1 never executed
    #####:21474:		vpaths = path->next;
        -:21475:	      else
    #####:21476:		lastpath->next = next;
        -:21477:
        -:21478:	      /* Free its unused storage.  */
    #####:21479:	      free (path->pattern);
    #####:21480:	      free ((char *) path->searchpath);
    #####:21481:	      free ((char *) path);
        -:21482:	    }
        -:21483:	  else
    #####:21484:	    lastpath = path;
        -:21485:
    #####:21486:	  path = next;
        -:21487:	}
        -:21488:
    #####:21489:      if (pattern != 0)
branch  0 never executed
branch  1 never executed
    #####:21490:	free (pattern);
    #####:21491:      return;
        -:21492:    }
        -:21493:
        -:21494:#ifdef WINDOWS32
        -:21495:    convert_vpath_to_windows32(dirpath, ';');
        -:21496:#endif
        -:21497:
        -:21498:  /* Figure out the maximum number of VPATH entries and put it in
        -:21499:     MAXELEM.  We start with 2, one before the first separator and one
        -:21500:     nil (the list terminator) and increment our estimated number for
        -:21501:     each separator or blank we find.  */
    #####:21502:  maxelem = 2;
    #####:21503:  p = dirpath;
    #####:21504:  while (*p != '\0')
branch  0 never executed
branch  1 never executed
    #####:21505:    if (*p++ == PATH_SEPARATOR_CHAR || isblank (*p))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:21506:      ++maxelem;
        -:21507:
    #####:21508:  vpath = (char **) xmalloc (maxelem * sizeof (char *));
call    0 never executed
    #####:21509:  maxvpath = 0;
        -:21510:
        -:21511:  /* Skip over any initial separators and blanks.  */
    #####:21512:  p = dirpath;
    #####:21513:  while (*p == PATH_SEPARATOR_CHAR || isblank (*p))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:21514:    ++p;
        -:21515:
    #####:21516:  elem = 0;
    #####:21517:  while (*p != '\0')
branch  0 never executed
branch  1 never executed
        -:21518:    {
        -:21519:      char *v;
        -:21520:      unsigned int len;
        -:21521:
        -:21522:      /* Find the end of this entry.  */
    #####:21523:      v = p;
    #####:21524:      while (*p != '\0' && *p != PATH_SEPARATOR_CHAR && !isblank (*p))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:21525:	++p;
        -:21526:
    #####:21527:      len = p - v;
        -:21528:      /* Make sure there's no trailing slash,
        -:21529:	 but still allow "/" as a directory.  */
        -:21530:#ifdef __MSDOS__
        -:21531:      /* We need also to leave alone a trailing slash in "d:/".  */
        -:21532:      if (len > 3 || (len > 1 && v[1] != ':'))
        -:21533:#endif
    #####:21534:      if (len > 1 && p[-1] == '/')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:21535:	--len;
        -:21536:
    #####:21537:      if (len > 1 || *v != '.')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:21538:	{
    #####:21539:	  v = savestring (v, len);
call    0 never executed
        -:21540:
        -:21541:	  /* Verify that the directory actually exists.  */
        -:21542:
    #####:21543:	  if (dir_file_exists_p (v, ""))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:21544:	    {
        -:21545:	      /* It does.  Put it in the list.  */
    #####:21546:	      vpath[elem++] = dir_name (v);
call    0 never executed
    #####:21547:	      free (v);
    #####:21548:	      if (len > maxvpath)
branch  0 never executed
branch  1 never executed
    #####:21549:		maxvpath = len;
        -:21550:	    }
        -:21551:	  else
        -:21552:	    /* The directory does not exist.  Omit from the list.  */
    #####:21553:	    free (v);
        -:21554:	}
        -:21555:
        -:21556:      /* Skip over separators and blanks between entries.  */
    #####:21557:      while (*p == PATH_SEPARATOR_CHAR || isblank (*p))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:21558:	++p;
        -:21559:    }
        -:21560:
    #####:21561:  if (elem > 0)
branch  0 never executed
branch  1 never executed
        -:21562:    {
        -:21563:      struct vpath *path;
        -:21564:      /* ELEM is now incremented one element past the last
        -:21565:	 entry, to where the nil-pointer terminator goes.
        -:21566:	 Usually this is maxelem - 1.  If not, shrink down.  */
    #####:21567:      if (elem < (maxelem - 1))
branch  0 never executed
branch  1 never executed
    #####:21568:	vpath = (char **) xrealloc ((char *) vpath,
    #####:21569:				    (elem + 1) * sizeof (char *));
call    0 never executed
        -:21570:
        -:21571:      /* Put the nil-pointer terminator on the end of the VPATH list.  */
    #####:21572:      vpath[elem] = 0;
        -:21573:
        -:21574:      /* Construct the vpath structure and put it into the linked list.  */
    #####:21575:      path = (struct vpath *) xmalloc (sizeof (struct vpath));
call    0 never executed
    #####:21576:      path->searchpath = vpath;
    #####:21577:      path->maxlen = maxvpath;
    #####:21578:      path->next = vpaths;
    #####:21579:      vpaths = path;
        -:21580:
        -:21581:      /* Set up the members.  */
    #####:21582:      path->pattern = pattern;
    #####:21583:      path->percent = percent;
    #####:21584:      path->patlen = strlen (pattern);
        -:21585:    }
        -:21586:  else
        -:21587:    {
        -:21588:      /* There were no entries, so free whatever space we allocated.  */
    #####:21589:      free ((char *) vpath);
    #####:21590:      if (pattern != 0)
branch  0 never executed
branch  1 never executed
    #####:21591:	free (pattern);
        -:21592:    }
        -:21593:}
        -:21594:
        -:21595:/* Search the GPATH list for a pathname string that matches the one passed
        -:21596:   in.  If it is found, return 1.  Otherwise we return 0.  */
        -:21597:
        -:21598:int
function gpath_search called 0 returned 0% blocks executed 0%
    #####:21599:gpath_search (file, len)
        -:21600:     char *file;
        -:21601:     int len;
        -:21602:{
        -:21603:  register char **gp;
        -:21604:
    #####:21605:  if (gpaths && (len <= gpaths->maxlen))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:21606:    for (gp = gpaths->searchpath; *gp != NULL; ++gp)
branch  0 never executed
branch  1 never executed
    #####:21607:      if (strneq (*gp, file, len) && (*gp)[len] == '\0')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:21608:        return 1;
        -:21609:
    #####:21610:  return 0;
        -:21611:}
        -:21612:
        -:21613:/* Search the VPATH list whose pattern matches *FILE for a directory
        -:21614:   where the name pointed to by FILE exists.  If it is found, we set *FILE to
        -:21615:   the newly malloc'd name of the existing file, *MTIME_PTR (if MTIME_PTR is
        -:21616:   not NULL) to its modtime (or zero if no stat call was done), and return 1.
        -:21617:   Otherwise we return 0.  */
        -:21618:
        -:21619:int
function vpath_search called 139 returned 100% blocks executed 17%
      139:21620:vpath_search (file, mtime_ptr)
        -:21621:     char **file;
        -:21622:     FILE_TIMESTAMP *mtime_ptr;
        -:21623:{
        -:21624:  register struct vpath *v;
        -:21625:
        -:21626:  /* If there are no VPATH entries or FILENAME starts at the root,
        -:21627:     there is nothing we can do.  */
        -:21628:
      139:21629:  if (**file == '/'
branch  0 taken 0 (fallthrough)
branch  1 taken 139
        -:21630:#if defined (WINDOWS32) || defined (__MSDOS__)
        -:21631:      || **file == '\\'
        -:21632:      || (*file)[1] == ':'
        -:21633:#endif
    #####:21634:      || (vpaths == 0 && general_vpath == 0))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
      139:21635:    return 0;
        -:21636:
    #####:21637:  for (v = vpaths; v != 0; v = v->next)
branch  0 never executed
branch  1 never executed
    #####:21638:    if (pattern_matches (v->pattern, v->percent, *file))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:21639:      if (selective_vpath_search (v, file, mtime_ptr))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:21640:	return 1;
        -:21641:
    #####:21642:  if (general_vpath != 0
branch  0 never executed
branch  1 never executed
    #####:21643:      && selective_vpath_search (general_vpath, file, mtime_ptr))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:21644:    return 1;
        -:21645:
    #####:21646:  return 0;
        -:21647:}
        -:21648:
        -:21649:
        -:21650:/* Search the given VPATH list for a directory where the name pointed
        -:21651:   to by FILE exists.  If it is found, we set *FILE to the newly malloc'd
        -:21652:   name of the existing file, *MTIME_PTR (if MTIME_PTR is not NULL) to
        -:21653:   its modtime (or zero if no stat call was done), and we return 1.
        -:21654:   Otherwise we return 0.  */
        -:21655:
        -:21656:static int
function selective_vpath_search called 0 returned 0% blocks executed 0%
    #####:21657:selective_vpath_search (path, file, mtime_ptr)
        -:21658:     struct vpath *path;
        -:21659:     char **file;
        -:21660:     FILE_TIMESTAMP *mtime_ptr;
        -:21661:{
        -:21662:  int not_target;
        -:21663:  char *name, *n;
        -:21664:  char *filename;
    #####:21665:  register char **vpath = path->searchpath;
    #####:21666:  unsigned int maxvpath = path->maxlen;
        -:21667:  register unsigned int i;
        -:21668:  unsigned int flen, vlen, name_dplen;
    #####:21669:  int exists = 0;
        -:21670:
        -:21671:  /* Find out if *FILE is a target.
        -:21672:     If and only if it is NOT a target, we will accept prospective
        -:21673:     files that don't exist but are mentioned in a makefile.  */
        -:21674:  {
    #####:21675:    struct file *f = lookup_file (*file);
call    0 never executed
    #####:21676:    not_target = f == 0 || !f->is_target;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:21677:  }
        -:21678:
    #####:21679:  flen = strlen (*file);
        -:21680:
        -:21681:  /* Split *FILE into a directory prefix and a name-within-directory.
        -:21682:     NAME_DPLEN gets the length of the prefix; FILENAME gets the
        -:21683:     pointer to the name-within-directory and FLEN is its length.  */
        -:21684:
    #####:21685:  n = strrchr (*file, '/');
        -:21686:#if defined (WINDOWS32) || defined (__MSDOS__)
        -:21687:  /* We need the rightmost slash or backslash.  */
        -:21688:  {
        -:21689:    char *bslash = strrchr(*file, '\\');
        -:21690:    if (!n || bslash > n)
        -:21691:      n = bslash;
        -:21692:  }
        -:21693:#endif
    #####:21694:  name_dplen = n != 0 ? n - *file : 0;
branch  0 never executed
branch  1 never executed
    #####:21695:  filename = name_dplen > 0 ? n + 1 : *file;
branch  0 never executed
branch  1 never executed
    #####:21696:  if (name_dplen > 0)
branch  0 never executed
branch  1 never executed
    #####:21697:    flen -= name_dplen + 1;
        -:21698:
        -:21699:  /* Allocate enough space for the biggest VPATH entry,
        -:21700:     a slash, the directory prefix that came with *FILE,
        -:21701:     another slash (although this one may not always be
        -:21702:     necessary), the filename, and a null terminator.  */
    #####:21703:  name = (char *) xmalloc (maxvpath + 1 + name_dplen + 1 + flen + 1);
call    0 never executed
        -:21704:
        -:21705:  /* Try each VPATH entry.  */
    #####:21706:  for (i = 0; vpath[i] != 0; ++i)
branch  0 never executed
branch  1 never executed
        -:21707:    {
    #####:21708:      int exists_in_cache = 0;
        -:21709:
    #####:21710:      n = name;
        -:21711:
        -:21712:      /* Put the next VPATH entry into NAME at N and increment N past it.  */
    #####:21713:      vlen = strlen (vpath[i]);
    #####:21714:      bcopy (vpath[i], n, vlen);
    #####:21715:      n += vlen;
        -:21716:
        -:21717:      /* Add the directory prefix already in *FILE.  */
    #####:21718:      if (name_dplen > 0)
branch  0 never executed
branch  1 never executed
        -:21719:	{
        -:21720:#ifndef VMS
    #####:21721:	  *n++ = '/';
        -:21722:#endif
    #####:21723:	  bcopy (*file, n, name_dplen);
    #####:21724:	  n += name_dplen;
        -:21725:	}
        -:21726:
        -:21727:#if defined (WINDOWS32) || defined (__MSDOS__)
        -:21728:      /* Cause the next if to treat backslash and slash alike.  */
        -:21729:      if (n != name && n[-1] == '\\' )
        -:21730:	n[-1] = '/';
        -:21731:#endif
        -:21732:      /* Now add the name-within-directory at the end of NAME.  */
        -:21733:#ifndef VMS
    #####:21734:      if (n != name && n[-1] != '/')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:21735:	{
    #####:21736:	  *n = '/';
    #####:21737:	  bcopy (filename, n + 1, flen + 1);
        -:21738:	}
        -:21739:      else
        -:21740:#endif
    #####:21741:	bcopy (filename, n, flen + 1);
        -:21742:
        -:21743:      /* Check if the file is mentioned in a makefile.  If *FILE is not
        -:21744:	 a target, that is enough for us to decide this file exists.
        -:21745:	 If *FILE is a target, then the file must be mentioned in the
        -:21746:	 makefile also as a target to be chosen.
        -:21747:
        -:21748:	 The restriction that *FILE must not be a target for a
        -:21749:	 makefile-mentioned file to be chosen was added by an
        -:21750:	 inadequately commented change in July 1990; I am not sure off
        -:21751:	 hand what problem it fixes.
        -:21752:
        -:21753:	 In December 1993 I loosened this restriction to allow a file
        -:21754:	 to be chosen if it is mentioned as a target in a makefile.  This
        -:21755:	 seem logical.  */
        -:21756:      {
    #####:21757:	struct file *f = lookup_file (name);
call    0 never executed
    #####:21758:	if (f != 0)
branch  0 never executed
branch  1 never executed
    #####:21759:	  exists = not_target || f->is_target;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:21760:      }
        -:21761:
    #####:21762:      if (!exists)
branch  0 never executed
branch  1 never executed
        -:21763:	{
        -:21764:	  /* That file wasn't mentioned in the makefile.
        -:21765:	     See if it actually exists.  */
        -:21766:
        -:21767:#ifdef VMS
        -:21768:	  exists_in_cache = exists = dir_file_exists_p (vpath[i], filename);
        -:21769:#else
        -:21770:	  /* Clobber a null into the name at the last slash.
        -:21771:	     Now NAME is the name of the directory to look in.  */
    #####:21772:	  *n = '\0';
        -:21773:
        -:21774:	  /* We know the directory is in the hash table now because either
        -:21775:	     construct_vpath_list or the code just above put it there.
        -:21776:	     Does the file we seek exist in it?  */
    #####:21777:	  exists_in_cache = exists = dir_file_exists_p (name, filename);
call    0 never executed
        -:21778:#endif
        -:21779:	}
        -:21780:
    #####:21781:      if (exists)
branch  0 never executed
branch  1 never executed
        -:21782:	{
        -:21783:	  /* The file is in the directory cache.
        -:21784:	     Now check that it actually exists in the filesystem.
        -:21785:	     The cache may be out of date.  When vpath thinks a file
        -:21786:	     exists, but stat fails for it, confusion results in the
        -:21787:	     higher levels.  */
        -:21788:
        -:21789:	  struct stat st;
        -:21790:
        -:21791:#ifndef VMS
        -:21792:	  /* Put the slash back in NAME.  */
    #####:21793:	  *n = '/';
        -:21794:#endif
        -:21795:
    #####:21796:	  if (!exists_in_cache	/* Makefile-mentioned file need not exist.  */
branch  0 never executed
branch  1 never executed
    #####:21797:	      || stat (name, &st) == 0) /* Does it really exist?  */
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:21798:	    {
        -:21799:	      /* We have found a file.
        -:21800:		 Store the name we found into *FILE for the caller.  */
        -:21801:
    #####:21802:	      *file = savestring (name, (n + 1 - name) + flen);
call    0 never executed
        -:21803:
    #####:21804:	      if (mtime_ptr != 0)
branch  0 never executed
branch  1 never executed
        -:21805:		/* Store the modtime into *MTIME_PTR for the caller.
        -:21806:		   If we have had no need to stat the file here,
        -:21807:		   we record a zero modtime to indicate this.  */
    #####:21808:		*mtime_ptr = (exists_in_cache
    #####:21809:			      ? FILE_TIMESTAMP_STAT_MODTIME (st)
    #####:21810:			      : (FILE_TIMESTAMP) 0);
branch  0 never executed
branch  1 never executed
        -:21811:
    #####:21812:	      free (name);
    #####:21813:	      return 1;
        -:21814:	    }
        -:21815:	  else
    #####:21816:	    exists = 0;
        -:21817:	}
        -:21818:    }
        -:21819:
    #####:21820:  free (name);
    #####:21821:  return 0;
        -:21822:}
        -:21823:
        -:21824:/* Print the data base of VPATH search paths.  */
        -:21825:
        -:21826:void
function print_vpath_data_base called 1 returned 100% blocks executed 31%
        1:21827:print_vpath_data_base ()
        -:21828:{
        -:21829:  register unsigned int nvpaths;
        -:21830:  register struct vpath *v;
        -:21831:
        1:21832:  puts (_("\n# VPATH Search Paths\n"));
call    0 returned 1
        -:21833:
        1:21834:  nvpaths = 0;
       1*:21835:  for (v = vpaths; v != 0; v = v->next)
branch  0 taken 0
branch  1 taken 1 (fallthrough)
        -:21836:    {
        -:21837:      register unsigned int i;
        -:21838:
    #####:21839:      ++nvpaths;
        -:21840:
    #####:21841:      printf ("vpath %s ", v->pattern);
call    0 never executed
        -:21842:
    #####:21843:      for (i = 0; v->searchpath[i] != 0; ++i)
branch  0 never executed
branch  1 never executed
    #####:21844:	printf ("%s%c", v->searchpath[i],
call    0 never executed
    #####:21845:		v->searchpath[i + 1] == 0 ? '\n' : PATH_SEPARATOR_CHAR);
branch  0 never executed
branch  1 never executed
        -:21846:    }
        -:21847:
        1:21848:  if (vpaths == 0)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:21849:    puts (_("# No `vpath' search paths."));
call    0 returned 1
        -:21850:  else
    #####:21851:    printf (_("\n# %u `vpath' search paths.\n"), nvpaths);
call    0 never executed
        -:21852:
        1:21853:  if (general_vpath == 0)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:21854:    puts (_("\n# No general (`VPATH' variable) search path."));
call    0 returned 1
        -:21855:  else
        -:21856:    {
    #####:21857:      register char **path = general_vpath->searchpath;
        -:21858:      register unsigned int i;
        -:21859:
    #####:21860:      fputs (_("\n# General (`VPATH' variable) search path:\n# "), stdout);
call    0 never executed
        -:21861:
    #####:21862:      for (i = 0; path[i] != 0; ++i)
branch  0 never executed
branch  1 never executed
    #####:21863:	printf ("%s%c", path[i],
call    0 never executed
    #####:21864:		path[i + 1] == 0 ? '\n' : PATH_SEPARATOR_CHAR);
branch  0 never executed
branch  1 never executed
        -:21865:    }
        1:21866:}
        -:21867:
        -:21868:
        -:21869:
        -:21870:/*************************************************************
        -:21871:  ============================================================
        -:21872:  ************************************************************
        -:21873:  ============================================================
        -:21874:  ************************************************************
        -:21875:                         default.c
        -:21876:  ************************************************************
        -:21877:  ============================================================
        -:21878:  ************************************************************
        -:21879:  ============================================================
        -:21880:  *************************************************************/
        -:21881:
        -:21882:/* Data base of default implicit rules for GNU Make.
        -:21883:Copyright (C) 1988,89,90,91,92,93,94,95,96 Free Software Foundation, Inc.
        -:21884:This file is part of GNU Make.
        -:21885:
        -:21886:GNU Make is free software; you can redistribute it and/or modify
        -:21887:it under the terms of the GNU General Public License as published by
        -:21888:the Free Software Foundation; either version 2, or (at your option)
        -:21889:any later version.
        -:21890:
        -:21891:GNU Make is distributed in the hope that it will be useful,
        -:21892:but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:21893:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:21894:GNU General Public License for more details.
        -:21895:
        -:21896:You should have received a copy of the GNU General Public License
        -:21897:along with GNU Make; see the file COPYING.  If not, write to
        -:21898:the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
        -:21899:Boston, MA 02111-1307, USA.  */
        -:21900:
        -:21901:/* #include "make.h"  <- modification by J.Ruthruff, 7/28 */
        -:21902:/* #include "rule.h"  <- modification by J.Ruthruff, 7/28 */
        -:21903:/* #include "dep.h"  <- modification by J.Ruthruff, 7/28 */
        -:21904:/* #include "filedef.h"  <- modification by J.Ruthruff, 7/28 */
        -:21905:#include "job.h"
        -:21906:/* #include "commands.h"  <- modification by J.Ruthruff, 7/28 */
        -:21907:/* #include "variable.h"  <- modification by J.Ruthruff, 7/28 */
        -:21908:#undef stderr
        -:21909:#define stderr stdout
        -:21910:
        -:21911:/* Define GCC_IS_NATIVE if gcc is the native development environment on
        -:21912:   your system (gcc/bison/flex vs cc/yacc/lex).  */
        -:21913:#ifdef __MSDOS__
        -:21914:#define GCC_IS_NATIVE
        -:21915:#endif
        -:21916:
        -:21917:
        -:21918:/* This is the default list of suffixes for suffix rules.
        -:21919:   `.s' must come last, so that a `.o' file will be made from
        -:21920:   a `.c' or `.p' or ... file rather than from a .s file.  */
        -:21921:
        -:21922:static char default_suffixes[]
        -:21923:#ifdef VMS
        -:21924:  = ".exe .olb .ln .obj .c .cxx .cc .pas .p .for .f .r .y .l .mar \
        -:21925:.s .ss .i .ii .mod .sym .def .h .info .dvi .tex .texinfo .texi .txinfo \
        -:21926:.w .ch .cweb .web .com .sh .elc .el";
        -:21927:#else
        -:21928:  = ".out .a .ln .o .c .cc .C .cpp .p .f .F .r .y .l .s .S \
        -:21929:.mod .sym .def .h .info .dvi .tex .texinfo .texi .txinfo \
        -:21930:.w .ch .web .sh .elc .el";
        -:21931:#endif
        -:21932:
        -:21933:static struct pspec default_pattern_rules[] =
        -:21934:  {
        -:21935:    { "(%)", "%",
        -:21936:	"$(AR) $(ARFLAGS) $@ $<" },
        -:21937:
        -:21938:    /* The X.out rules are only in BSD's default set because
        -:21939:       BSD Make has no null-suffix rules, so `foo.out' and
        -:21940:       `foo' are the same thing.  */
        -:21941:#ifdef VMS
        -:21942:    { "%.exe", "%",
        -:21943:        "copy $< $@" },
        -:21944:#else
        -:21945:    { "%.out", "%",
        -:21946:	"@rm -f $@ \n cp $< $@" },
        -:21947:#endif
        -:21948:    /* Syntax is "ctangle foo.w foo.ch foo.c".  */
        -:21949:    { "%.c", "%.w %.ch",
        -:21950:	"$(CTANGLE) $^ $@" },
        -:21951:    { "%.tex", "%.w %.ch",
        -:21952:	"$(CWEAVE) $^ $@" },
        -:21953:
        -:21954:    { 0, 0, 0 }
        -:21955:  };
        -:21956:
        -:21957:static struct pspec default_terminal_rules[] =
        -:21958:  {
        -:21959:#ifdef VMS
        -:21960:    /* RCS.  */
        -:21961:    { "%", "%$$5lv", /* Multinet style */
        -:21962:        "if f$$search($@) .nes. \"\" then +$(CHECKOUT,v)" },
        -:21963:    { "%", "[.$$rcs]%$$5lv", /* Multinet style */
        -:21964:        "if f$$search($@) .nes. \"\" then +$(CHECKOUT,v)" },
        -:21965:    { "%", "%_v", /* Normal style */
        -:21966:        "if f$$search($@) .nes. \"\" then +$(CHECKOUT,v)" },
        -:21967:    { "%", "[.rcs]%_v", /* Normal style */
        -:21968:        "if f$$search($@) .nes. \"\" then +$(CHECKOUT,v)" },
        -:21969:
        -:21970:    /* SCCS.  */
        -:21971:	/* ain't no SCCS on vms */
        -:21972:#else
        -:21973:    /* RCS.  */
        -:21974:    { "%", "%,v",
        -:21975:	"$(CHECKOUT,v)" },
        -:21976:    { "%", "RCS/%,v",
        -:21977:	"$(CHECKOUT,v)" },
        -:21978:    { "%", "RCS/%",
        -:21979:	"$(CHECKOUT,v)" },
        -:21980:
        -:21981:    /* SCCS.  */
        -:21982:    { "%", "s.%",
        -:21983:	"$(GET) $(GFLAGS) $(SCCS_OUTPUT_OPTION) $<" },
        -:21984:    { "%", "SCCS/s.%",
        -:21985:	"$(GET) $(GFLAGS) $(SCCS_OUTPUT_OPTION) $<" },
        -:21986:#endif /* !VMS */
        -:21987:    { 0, 0, 0 }
        -:21988:  };
        -:21989:
        -:21990:static char *default_suffix_rules[] =
        -:21991:  {
        -:21992:#ifdef VMS
        -:21993:    ".obj.exe",
        -:21994:    "$(LINK.obj) $^ $(LOADLIBES) $(LDLIBS) $(CRT0) /exe=$@",
        -:21995:    ".mar.exe",
        -:21996:    "$(COMPILE.mar) $^ \n $(LINK.obj) $(subst .mar,.obj,$^) $(LOADLIBES) $(LDLIBS) $(CRT0) /exe=$@",
        -:21997:    ".s.exe",
        -:21998:    "$(COMPILE.s) $^ \n $(LINK.obj) $(subst .s,.obj,$^) $(LOADLIBES) $(LDLIBS) $(CRT0) /exe=$@",
        -:21999:    ".c.exe",
        -:22000:    "$(COMPILE.c) $^ \n $(LINK.obj) $(subst .c,.obj,$^) $(LOADLIBES) $(LDLIBS) $(CRT0) /exe=$@",
        -:22001:    ".cc.exe",
        -:22002:#ifdef GCC_IS_NATIVE
        -:22003:    "$(COMPILE.cc) $^ \n $(LINK.obj) $(CXXSTARTUP),sys$$disk:[]$(subst .cc,.obj,$^) $(LOADLIBES) $(LXLIBS) $(LDLIBS) $(CXXRT0) /exe=$@",
        -:22004:#else
        -:22005:    "$(COMPILE.cc) $^ \n $(CXXLINK.obj) $(subst .cc,.obj,$^) $(LOADLIBES) $(LXLIBS) $(LDLIBS) $(CXXRT0) /exe=$@",
        -:22006:    ".cxx.exe",
        -:22007:    "$(COMPILE.cxx) $^ \n $(CXXLINK.obj) $(subst .cxx,.obj,$^) $(LOADLIBES) $(LXLIBS) $(LDLIBS) $(CXXRT0) /exe=$@",
        -:22008:#endif
        -:22009:    ".for.exe",
        -:22010:    "$(COMPILE.for) $^ \n $(LINK.obj) $(subst .for,.obj,$^) $(LOADLIBES) $(LDLIBS) /exe=$@",
        -:22011:    ".pas.exe",
        -:22012:    "$(COMPILE.pas) $^ \n $(LINK.obj) $(subst .pas,.obj,$^) $(LOADLIBES) $(LDLIBS) /exe=$@",
        -:22013:
        -:22014:    ".com",
        -:22015:    "copy $< >$@",
        -:22016:
        -:22017:    ".mar.obj",
        -:22018:    "$(COMPILE.mar) /obj=$@ $<",
        -:22019:    ".s.obj",
        -:22020:    "$(COMPILE.s) /obj=$@ $<",
        -:22021:    ".ss.obj",
        -:22022:    "$(COMPILE.s) /obj=$@ $<",
        -:22023:    ".c.i",
        -:22024:    "$(COMPILE.c)/prep /list=$@ $<",
        -:22025:    ".c.s",
        -:22026:    "$(COMPILE.c)/noobj/machine /list=$@ $<",
        -:22027:    ".i.s",
        -:22028:    "$(COMPILE.c)/noprep/noobj/machine /list=$@ $<",
        -:22029:    ".c.obj",
        -:22030:    "$(COMPILE.c) /obj=$@ $<",
        -:22031:    ".cc.ii",
        -:22032:    "$(COMPILE.cc)/prep /list=$@ $<",
        -:22033:    ".cc.ss",
        -:22034:    "$(COMPILE.cc)/noobj/machine /list=$@ $<",
        -:22035:    ".ii.ss",
        -:22036:    "$(COMPILE.cc)/noprep/noobj/machine /list=$@ $<",
        -:22037:    ".cc.obj",
        -:22038:    "$(COMPILE.cc) /obj=$@ $<",
        -:22039:    ".for.obj",
        -:22040:    "$(COMPILE.for) /obj=$@ $<",
        -:22041:    ".pas.obj",
        -:22042:    "$(COMPILE.pas) /obj=$@ $<",
        -:22043:
        -:22044:    ".y.c",
        -:22045:    "$(YACC.y) $< \n rename y_tab.c $@",
        -:22046:    ".l.c",
        -:22047:    "$(LEX.l) $< \n rename lexyy.c $@",
        -:22048:
        -:22049:    ".texinfo.info",
        -:22050:    "$(MAKEINFO) $<",
        -:22051:
        -:22052:    ".tex.dvi",
        -:22053:    "$(TEX) $<",
        -:22054:
        -:22055:#else /* ! VMS */
        -:22056:
        -:22057:    ".o",
        -:22058:    "$(LINK.o) $^ $(LOADLIBES) $(LDLIBS) -o $@",
        -:22059:    ".s",
        -:22060:    "$(LINK.s) $^ $(LOADLIBES) $(LDLIBS) -o $@",
        -:22061:    ".S",
        -:22062:    "$(LINK.S) $^ $(LOADLIBES) $(LDLIBS) -o $@",
        -:22063:    ".c",
        -:22064:    "$(LINK.c) $^ $(LOADLIBES) $(LDLIBS) -o $@",
        -:22065:    ".cc",
        -:22066:    "$(LINK.cc) $^ $(LOADLIBES) $(LDLIBS) -o $@",
        -:22067:    ".C",
        -:22068:    "$(LINK.C) $^ $(LOADLIBES) $(LDLIBS) -o $@",
        -:22069:    ".cpp",
        -:22070:    "$(LINK.cpp) $^ $(LOADLIBES) $(LDLIBS) -o $@",
        -:22071:    ".f",
        -:22072:    "$(LINK.f) $^ $(LOADLIBES) $(LDLIBS) -o $@",
        -:22073:    ".p",
        -:22074:    "$(LINK.p) $^ $(LOADLIBES) $(LDLIBS) -o $@",
        -:22075:    ".F",
        -:22076:    "$(LINK.F) $^ $(LOADLIBES) $(LDLIBS) -o $@",
        -:22077:    ".r",
        -:22078:    "$(LINK.r) $^ $(LOADLIBES) $(LDLIBS) -o $@",
        -:22079:    ".mod",
        -:22080:    "$(COMPILE.mod) -o $@ -e $@ $^",
        -:22081:
        -:22082:    ".def.sym",
        -:22083:    "$(COMPILE.def) -o $@ $<",
        -:22084:
        -:22085:    ".sh",
        -:22086:    "cat $< >$@ \n chmod a+x $@",
        -:22087:
        -:22088:    ".s.o",
        -:22089:    "$(COMPILE.s) -o $@ $<",
        -:22090:    ".S.o",
        -:22091:    "$(COMPILE.S) -o $@ $<",
        -:22092:    ".c.o",
        -:22093:    "$(COMPILE.c) $(OUTPUT_OPTION) $<",
        -:22094:    ".cc.o",
        -:22095:    "$(COMPILE.cc) $(OUTPUT_OPTION) $<",
        -:22096:    ".C.o",
        -:22097:    "$(COMPILE.C) $(OUTPUT_OPTION) $<",
        -:22098:    ".cpp.o",
        -:22099:    "$(COMPILE.cpp) $(OUTPUT_OPTION) $<",
        -:22100:    ".f.o",
        -:22101:    "$(COMPILE.f) $(OUTPUT_OPTION) $<",
        -:22102:    ".p.o",
        -:22103:    "$(COMPILE.p) $(OUTPUT_OPTION) $<",
        -:22104:    ".F.o",
        -:22105:    "$(COMPILE.F) $(OUTPUT_OPTION) $<",
        -:22106:    ".r.o",
        -:22107:    "$(COMPILE.r) $(OUTPUT_OPTION) $<",
        -:22108:    ".mod.o",
        -:22109:    "$(COMPILE.mod) -o $@ $<",
        -:22110:
        -:22111:    ".c.ln",
        -:22112:    "$(LINT.c) -C$* $<",
        -:22113:    ".y.ln",
        -:22114:#ifndef __MSDOS__
        -:22115:    "$(YACC.y) $< \n $(LINT.c) -C$* y.tab.c \n $(RM) y.tab.c",
        -:22116:#else
        -:22117:    "$(YACC.y) $< \n $(LINT.c) -C$* y_tab.c \n $(RM) y_tab.c",
        -:22118:#endif
        -:22119:    ".l.ln",
        -:22120:    "@$(RM) $*.c\n $(LEX.l) $< > $*.c\n$(LINT.c) -i $*.c -o $@\n $(RM) $*.c",
        -:22121:
        -:22122:    ".y.c",
        -:22123:#ifndef __MSDOS__
        -:22124:    "$(YACC.y) $< \n mv -f y.tab.c $@",
        -:22125:#else
        -:22126:    "$(YACC.y) $< \n mv -f y_tab.c $@",
        -:22127:#endif
        -:22128:    ".l.c",
        -:22129:    "@$(RM) $@ \n $(LEX.l) $< > $@",
        -:22130:
        -:22131:    ".F.f",
        -:22132:    "$(PREPROCESS.F) $(OUTPUT_OPTION) $<",
        -:22133:    ".r.f",
        -:22134:    "$(PREPROCESS.r) $(OUTPUT_OPTION) $<",
        -:22135:
        -:22136:    /* This might actually make lex.yy.c if there's no %R%
        -:22137:       directive in $*.l, but in that case why were you
        -:22138:       trying to make $*.r anyway?  */
        -:22139:    ".l.r",
        -:22140:    "$(LEX.l) $< > $@ \n mv -f lex.yy.r $@",
        -:22141:
        -:22142:    ".S.s",
        -:22143:    "$(PREPROCESS.S) $< > $@",
        -:22144:
        -:22145:    ".texinfo.info",
        -:22146:    "$(MAKEINFO) $(MAKEINFO_FLAGS) $< -o $@",
        -:22147:
        -:22148:    ".texi.info",
        -:22149:    "$(MAKEINFO) $(MAKEINFO_FLAGS) $< -o $@",
        -:22150:
        -:22151:    ".txinfo.info",
        -:22152:    "$(MAKEINFO) $(MAKEINFO_FLAGS) $< -o $@",
        -:22153:
        -:22154:    ".tex.dvi",
        -:22155:    "$(TEX) $<",
        -:22156:
        -:22157:    ".texinfo.dvi",
        -:22158:    "$(TEXI2DVI) $(TEXI2DVI_FLAGS) $<",
        -:22159:
        -:22160:    ".texi.dvi",
        -:22161:    "$(TEXI2DVI) $(TEXI2DVI_FLAGS) $<",
        -:22162:
        -:22163:    ".txinfo.dvi",
        -:22164:    "$(TEXI2DVI) $(TEXI2DVI_FLAGS) $<",
        -:22165:
        -:22166:    ".w.c",
        -:22167:    "$(CTANGLE) $< - $@",	/* The `-' says there is no `.ch' file.  */
        -:22168:
        -:22169:    ".web.p",
        -:22170:    "$(TANGLE) $<",
        -:22171:
        -:22172:    ".w.tex",
        -:22173:    "$(CWEAVE) $< - $@",	/* The `-' says there is no `.ch' file.  */
        -:22174:
        -:22175:    ".web.tex",
        -:22176:    "$(WEAVE) $<",
        -:22177:
        -:22178:#endif /* !VMS */
        -:22179:
        -:22180:    0, 0,
        -:22181:  };
        -:22182:
        -:22183:static char *default_variables[] =
        -:22184:  {
        -:22185:#ifdef VMS
        -:22186:#ifdef __ALPHA
        -:22187:    "ARCH", "ALPHA",
        -:22188:#else
        -:22189:    "ARCH", "VAX",
        -:22190:#endif
        -:22191:    "AR", "library/obj",
        -:22192:    "ARFLAGS", "/replace",
        -:22193:    "AS", "macro",
        -:22194:    "MACRO", "macro",
        -:22195:#ifdef GCC_IS_NATIVE
        -:22196:    "CC", "gcc",
        -:22197:#else
        -:22198:    "CC", "cc",
        -:22199:#endif
        -:22200:    "CD", "builtin_cd",
        -:22201:    "MAKE", "make",
        -:22202:    "ECHO", "write sys$$output \"",
        -:22203:#ifdef GCC_IS_NATIVE
        -:22204:    "C++", "gcc/plus",
        -:22205:    "CXX", "gcc/plus",
        -:22206:#else
        -:22207:    "C++", "cxx",
        -:22208:    "CXX", "cxx",
        -:22209:    "CXXLD", "cxxlink",
        -:22210:#endif
        -:22211:    "CO", "co",
        -:22212:    "CPP", "$(CC) /preprocess_only",
        -:22213:    "FC", "fortran",
        -:22214:    /* System V uses these, so explicit rules using them should work.
        -:22215:       However, there is no way to make implicit rules use them and FC.  */
        -:22216:    "F77", "$(FC)",
        -:22217:    "F77FLAGS", "$(FFLAGS)",
        -:22218:    "LD", "link",
        -:22219:    "LEX", "lex",
        -:22220:    "PC", "pascal",
        -:22221:    "YACC", "bison/yacc",
        -:22222:    "YFLAGS", "/Define/Verbose",
        -:22223:    "BISON", "bison",
        -:22224:    "MAKEINFO", "makeinfo",
        -:22225:    "TEX", "tex",
        -:22226:    "TEXINDEX", "texindex",
        -:22227:
        -:22228:    "RM", "delete/nolog",
        -:22229:
        -:22230:    "CSTARTUP", "",
        -:22231:#ifdef GCC_IS_NATIVE
        -:22232:    "CRT0", ",sys$$library:vaxcrtl.olb/lib,gnu_cc_library:crt0.obj",
        -:22233:    "CXXSTARTUP", "gnu_cc_library:crtbegin.obj",
        -:22234:    "CXXRT0", ",sys$$library:vaxcrtl.olb/lib,gnu_cc_library:crtend.obj,gnu_cc_library:gxx_main.obj",
        -:22235:    "LXLIBS", ",gnu_cc_library:libstdcxx.olb/lib,gnu_cc_library:libgccplus.olb/lib",
        -:22236:    "LDLIBS", ",gnu_cc_library:libgcc.olb/lib",
        -:22237:#else
        -:22238:    "CRT0", "",
        -:22239:    "CXXSTARTUP", "",
        -:22240:    "CXXRT0", "",
        -:22241:    "LXLIBS", "",
        -:22242:    "LDLIBS", "",
        -:22243:#endif
        -:22244:
        -:22245:    "LINK.obj", "$(LD) $(LDFLAGS)",
        -:22246:#ifndef GCC_IS_NATIVE
        -:22247:    "CXXLINK.obj", "$(CXXLD) $(LDFLAGS)",
        -:22248:    "COMPILE.cxx", "$(CXX) $(CXXFLAGS) $(CPPFLAGS) $(TARGET_ARCH)",
        -:22249:#endif
        -:22250:    "COMPILE.c", "$(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH)",
        -:22251:    "COMPILE.cc", "$(CXX) $(CXXFLAGS) $(CPPFLAGS) $(TARGET_ARCH)",
        -:22252:    "YACC.y", "$(YACC) $(YFLAGS)",
        -:22253:    "LEX.l", "$(LEX) $(LFLAGS)",
        -:22254:    "COMPILE.for", "$(FC) $(FFLAGS) $(TARGET_ARCH)",
        -:22255:    "COMPILE.pas", "$(PC) $(PFLAGS) $(CPPFLAGS) $(TARGET_ARCH)",
        -:22256:    "COMPILE.mar", "$(MACRO) $(MACROFLAGS)",
        -:22257:    "COMPILE.s", "$(AS) $(ASFLAGS) $(TARGET_MACH)",
        -:22258:    "LINT.c", "$(LINT) $(LINTFLAGS) $(CPPFLAGS) $(TARGET_ARCH)",
        -:22259:
        -:22260:    "MV", "rename/new_version",
        -:22261:    "CP", "copy",
        -:22262:
        -:22263:#else /* !VMS */
        -:22264:
        -:22265:    "AR", "ar",
        -:22266:    "ARFLAGS", "rv",
        -:22267:    "AS", "as",
        -:22268:#ifdef GCC_IS_NATIVE
        -:22269:    "CC", "gcc",
        -:22270:# ifdef __MSDOS__
        -:22271:    "CXX", "gpp",	/* g++ is an invalid name on MSDOS */
        -:22272:# else
        -:22273:    "CXX", "gcc",
        -:22274:# endif /* __MSDOS__ */
        -:22275:#else
        -:22276:    "CC", "cc",
        -:22277:    "CXX", "g++",
        -:22278:#endif
        -:22279:
        -:22280:    /* This expands to $(CO) $(COFLAGS) $< $@ if $@ does not exist,
        -:22281:       and to the empty string if $@ does exist.  */
        -:22282:    "CHECKOUT,v", "+$(if $(wildcard $@),,$(CO) $(COFLAGS) $< $@)",
        -:22283:    "CO", "co",
        -:22284:    "COFLAGS", "",
        -:22285:
        -:22286:    "CPP", "$(CC) -E",
        -:22287:#ifdef	CRAY
        -:22288:    "CF77PPFLAGS", "-P",
        -:22289:    "CF77PP", "/lib/cpp",
        -:22290:    "CFT", "cft77",
        -:22291:    "CF", "cf77",
        -:22292:    "FC", "$(CF)",
        -:22293:#else	/* Not CRAY.  */
        -:22294:#ifdef	_IBMR2
        -:22295:    "FC", "xlf",
        -:22296:#else
        -:22297:#ifdef	__convex__
        -:22298:    "FC", "fc",
        -:22299:#else
        -:22300:    "FC", "f77",
        -:22301:#endif /* __convex__ */
        -:22302:#endif /* _IBMR2 */
        -:22303:    /* System V uses these, so explicit rules using them should work.
        -:22304:       However, there is no way to make implicit rules use them and FC.  */
        -:22305:    "F77", "$(FC)",
        -:22306:    "F77FLAGS", "$(FFLAGS)",
        -:22307:#endif	/* Cray.  */
        -:22308:    "GET", SCCS_GET,
        -:22309:    "LD", "ld",
        -:22310:#ifdef GCC_IS_NATIVE
        -:22311:    "LEX", "flex",
        -:22312:#else
        -:22313:    "LEX", "lex",
        -:22314:#endif
        -:22315:    "LINT", "lint",
        -:22316:    "M2C", "m2c",
        -:22317:#ifdef	pyr
        -:22318:    "PC", "pascal",
        -:22319:#else
        -:22320:#ifdef	CRAY
        -:22321:    "PC", "PASCAL",
        -:22322:    "SEGLDR", "segldr",
        -:22323:#else
        -:22324:    "PC", "pc",
        -:22325:#endif	/* CRAY.  */
        -:22326:#endif	/* pyr.  */
        -:22327:#ifdef GCC_IS_NATIVE
        -:22328:    "YACC", "bison -y",
        -:22329:#else
        -:22330:    "YACC", "yacc",	/* Or "bison -y"  */
        -:22331:#endif
        -:22332:    "MAKEINFO", "makeinfo",
        -:22333:    "TEX", "tex",
        -:22334:    "TEXI2DVI", "texi2dvi",
        -:22335:    "WEAVE", "weave",
        -:22336:    "CWEAVE", "cweave",
        -:22337:    "TANGLE", "tangle",
        -:22338:    "CTANGLE", "ctangle",
        -:22339:
        -:22340:    "RM", "rm -f",
        -:22341:
        -:22342:    "LINK.o", "$(CC) $(LDFLAGS) $(TARGET_ARCH)",
        -:22343:    "COMPILE.c", "$(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c",
        -:22344:    "LINK.c", "$(CC) $(CFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH)",
        -:22345:    "COMPILE.cc", "$(CXX) $(CXXFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c",
        -:22346:    "COMPILE.C", "$(COMPILE.cc)",
        -:22347:    "COMPILE.cpp", "$(COMPILE.cc)",
        -:22348:    "LINK.cc", "$(CXX) $(CXXFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH)",
        -:22349:    "LINK.C", "$(LINK.cc)",
        -:22350:    "LINK.cpp", "$(LINK.cc)",
        -:22351:    "YACC.y", "$(YACC) $(YFLAGS)",
        -:22352:    "LEX.l", "$(LEX) $(LFLAGS) -t",
        -:22353:    "COMPILE.f", "$(FC) $(FFLAGS) $(TARGET_ARCH) -c",
        -:22354:    "LINK.f", "$(FC) $(FFLAGS) $(LDFLAGS) $(TARGET_ARCH)",
        -:22355:    "COMPILE.F", "$(FC) $(FFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c",
        -:22356:    "LINK.F", "$(FC) $(FFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH)",
        -:22357:    "COMPILE.r", "$(FC) $(FFLAGS) $(RFLAGS) $(TARGET_ARCH) -c",
        -:22358:    "LINK.r", "$(FC) $(FFLAGS) $(RFLAGS) $(LDFLAGS) $(TARGET_ARCH)",
        -:22359:    "COMPILE.def", "$(M2C) $(M2FLAGS) $(DEFFLAGS) $(TARGET_ARCH)",
        -:22360:    "COMPILE.mod", "$(M2C) $(M2FLAGS) $(MODFLAGS) $(TARGET_ARCH)",
        -:22361:    "COMPILE.p", "$(PC) $(PFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c",
        -:22362:    "LINK.p", "$(PC) $(PFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH)",
        -:22363:    "LINK.s", "$(CC) $(ASFLAGS) $(LDFLAGS) $(TARGET_MACH)",
        -:22364:    "COMPILE.s", "$(AS) $(ASFLAGS) $(TARGET_MACH)",
        -:22365:    "LINK.S", "$(CC) $(ASFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_MACH)",
        -:22366:    "COMPILE.S", "$(CC) $(ASFLAGS) $(CPPFLAGS) $(TARGET_MACH) -c",
        -:22367:    "PREPROCESS.S", "$(CC) -E $(CPPFLAGS)",
        -:22368:    "PREPROCESS.F", "$(FC) $(FFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -F",
        -:22369:    "PREPROCESS.r", "$(FC) $(FFLAGS) $(RFLAGS) $(TARGET_ARCH) -F",
        -:22370:    "LINT.c", "$(LINT) $(LINTFLAGS) $(CPPFLAGS) $(TARGET_ARCH)",
        -:22371:
        -:22372:#ifndef	NO_MINUS_C_MINUS_O
        -:22373:    "OUTPUT_OPTION", "-o $@",
        -:22374:#endif
        -:22375:
        -:22376:#ifdef	SCCS_GET_MINUS_G
        -:22377:    "SCCS_OUTPUT_OPTION", "-G$@",
        -:22378:#endif
        -:22379:
        -:22380:#ifdef _AMIGA
        -:22381:    ".LIBPATTERNS", "%.lib",
        -:22382:#else
        -:22383:#ifdef __MSDOS__
        -:22384:    ".LIBPATTERNS", "lib%.a $(DJDIR)/lib/lib%.a",
        -:22385:#else
        -:22386:    ".LIBPATTERNS", "lib%.so lib%.a",
        -:22387:#endif
        -:22388:#endif
        -:22389:
        -:22390:#endif /* !VMS */
        -:22391:    0, 0
        -:22392:  };
        -:22393:
        -:22394:/* Set up the default .SUFFIXES list.  */
        -:22395:
        -:22396:void
function set_default_suffixes called 1 returned 100% blocks executed 88%
        1:22397:set_default_suffixes ()
        -:22398:{
        1:22399:  suffix_file = enter_file (".SUFFIXES");
call    0 returned 1
        -:22400:
        1:22401:  if (no_builtin_rules_flag)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:22402:    (void) define_variable ("SUFFIXES", 8, "", o_default, 0);
call    0 never executed
        -:22403:  else
        -:22404:    {
        1:22405:      char *p = default_suffixes;
        2:22406:      suffix_file->deps = (struct dep *)
        1:22407:	multi_glob (parse_file_seq (&p, '\0', sizeof (struct dep), 1),
call    0 returned 1
call    1 returned 1
        -:22408:		    sizeof (struct dep));
        1:22409:      (void) define_variable ("SUFFIXES", 8, default_suffixes, o_default, 0);
call    0 returned 1
        -:22410:    }
        1:22411:}
        -:22412:
        -:22413:/* Enter the default suffix rules as file rules.  This used to be done in
        -:22414:   install_default_implicit_rules, but that loses because we want the
        -:22415:   suffix rules installed before reading makefiles, and thee pattern rules
        -:22416:   installed after.  */
        -:22417:
        -:22418:void
function install_default_suffix_rules called 1 returned 100% blocks executed 90%
        1:22419:install_default_suffix_rules ()
        -:22420:{
        -:22421:  register char **s;
        -:22422:
        1:22423:  if (no_builtin_rules_flag)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:22424:    return;
        -:22425:
       46:22426: for (s = default_suffix_rules; *s != 0; s += 2)
branch  0 taken 45
branch  1 taken 1 (fallthrough)
        -:22427:    {
       45:22428:      register struct file *f = enter_file (s[0]);
call    0 returned 45
        -:22429:      /* Don't clobber cmds given in a makefile if there were any.  */
       45:22430:      if (f->cmds == 0)
branch  0 taken 45 (fallthrough)
branch  1 taken 0
        -:22431:	{
       45:22432:	  f->cmds = (struct commands *) xmalloc (sizeof (struct commands));
call    0 returned 45
       45:22433:	  f->cmds->fileinfo.filenm = 0;
       45:22434:	  f->cmds->commands = s[1];
       45:22435:	  f->cmds->command_lines = 0;
        -:22436:	}
        -:22437:    }
        -:22438:}
        -:22439:
        -:22440:
        -:22441:/* Install the default pattern rules.  */
        -:22442:
        -:22443:void
function install_default_implicit_rules called 1 returned 100% blocks executed 91%
        1:22444:install_default_implicit_rules ()
        -:22445:{
        -:22446:  register struct pspec *p;
        -:22447:
        1:22448:  if (no_builtin_rules_flag)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:22449:    return;
        -:22450:
        5:22451:  for (p = default_pattern_rules; p->target != 0; ++p)
branch  0 taken 4
branch  1 taken 1 (fallthrough)
        4:22452:    install_pattern_rule (p, 0);
call    0 returned 4
        -:22453:
        6:22454:  for (p = default_terminal_rules; p->target != 0; ++p)
branch  0 taken 5
branch  1 taken 1 (fallthrough)
        5:22455:    install_pattern_rule (p, 1);
call    0 returned 5
        -:22456:}
        -:22457:
        -:22458:void
function define_default_variables called 1 returned 100% blocks executed 86%
        1:22459:define_default_variables ()
        -:22460:{
        -:22461:  register char **s;
        -:22462:
        1:22463:  if (no_builtin_variables_flag)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:22464:    return;
        -:22465:
       60:22466:  for (s = default_variables; *s != 0; s += 2)
branch  0 taken 59
branch  1 taken 1 (fallthrough)
       59:22467:    (void) define_variable (s[0], strlen (s[0]), s[1], o_default, 1);
call    0 returned 59
        -:22468:}
        -:22469:
        -:22470:
        -:22471:
        -:22472:/*************************************************************
        -:22473:  ============================================================
        -:22474:  ************************************************************
        -:22475:  ============================================================
        -:22476:  ************************************************************
        -:22477:                         remote-stub.c
        -:22478:  ************************************************************
        -:22479:  ============================================================
        -:22480:  ************************************************************
        -:22481:  ============================================================
        -:22482:  *************************************************************/
        -:22483:
        -:22484:/* Template for the remote job exportation interface to GNU Make.
        -:22485:Copyright (C) 1988, 1989, 1992, 1993, 1996 Free Software Foundation, Inc.
        -:22486:This file is part of GNU Make.
        -:22487:
        -:22488:GNU Make is free software; you can redistribute it and/or modify
        -:22489:it under the terms of the GNU General Public License as published by
        -:22490:the Free Software Foundation; either version 2, or (at your option)
        -:22491:any later version.
        -:22492:
        -:22493:GNU Make is distributed in the hope that it will be useful,
        -:22494:but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:22495:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:22496:GNU General Public License for more details.
        -:22497:
        -:22498:You should have received a copy of the GNU General Public License
        -:22499:along with GNU Make; see the file COPYING.  If not, write to
        -:22500:the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
        -:22501:Boston, MA 02111-1307, USA.  */
        -:22502:
        -:22503:/* #include "make.h"  <- modification by J.Ruthruff, 7/28 */
        -:22504:/* #include "filedef.h"  <- modification by J.Ruthruff, 7/28 */
        -:22505:#include "job.h"
        -:22506:/* #include "commands.h"  <- modification by J.Ruthruff, 7/28 */
        -:22507:#undef stderr
        -:22508:#define stderr stdout
        -:22509:
        -:22510:
        -:22511:char *remote_description = 0;
        -:22512:
        -:22513:/* Call once at startup even if no commands are run.  */
        -:22514:
        -:22515:void
function remote_setup called 1 returned 100% blocks executed 100%
        1:22516:remote_setup ()
        -:22517:{
        1:22518:}
        -:22519:
        -:22520:/* Called before exit.  */
        -:22521:
        -:22522:void
function remote_cleanup called 1 returned 100% blocks executed 100%
        1:22523:remote_cleanup ()
        -:22524:{
        1:22525:}
        -:22526:
        -:22527:/* Return nonzero if the next job should be done remotely.  */
        -:22528:
        -:22529:int
function start_remote_job_p called 0 returned 0% blocks executed 0%
    #####:22530:start_remote_job_p (first_p)
        -:22531:     int first_p;
        -:22532:{
    #####:22533:  return 0;
        -:22534:}
        -:22535:
        -:22536:/* Start a remote job running the command in ARGV,
        -:22537:   with environment from ENVP.  It gets standard input from STDIN_FD.  On
        -:22538:   failure, return nonzero.  On success, return zero, and set *USED_STDIN
        -:22539:   to nonzero if it will actually use STDIN_FD, zero if not, set *ID_PTR to
        -:22540:   a unique identification, and set *IS_REMOTE to zero if the job is local,
        -:22541:   nonzero if it is remote (meaning *ID_PTR is a process ID).  */
        -:22542:
        -:22543:int
function start_remote_job called 0 returned 0% blocks executed 0%
    #####:22544:start_remote_job (argv, envp, stdin_fd, is_remote, id_ptr, used_stdin)
        -:22545:     char **argv, **envp;
        -:22546:     int stdin_fd;
        -:22547:     int *is_remote;
        -:22548:     int *id_ptr;
        -:22549:     int *used_stdin;
        -:22550:{
    #####:22551:  return -1;
        -:22552:}
        -:22553:
        -:22554:/* Get the status of a dead remote child.  Block waiting for one to die
        -:22555:   if BLOCK is nonzero.  Set *EXIT_CODE_PTR to the exit status, *SIGNAL_PTR
        -:22556:   to the termination signal or zero if it exited normally, and *COREDUMP_PTR
        -:22557:   nonzero if it dumped core.  Return the ID of the child that died,
        -:22558:   0 if we would have to block and !BLOCK, or < 0 if there were none.  */
        -:22559:
        -:22560:int
function remote_status called 0 returned 0% blocks executed 0%
    #####:22561:remote_status (exit_code_ptr, signal_ptr, coredump_ptr, block)
        -:22562:     int *exit_code_ptr, *signal_ptr, *coredump_ptr;
        -:22563:     int block;
        -:22564:{
    #####:22565:  errno = ECHILD;
    #####:22566:  return -1;
        -:22567:}
        -:22568:
        -:22569:/* Block asynchronous notification of remote child death.
        -:22570:   If this notification is done by raising the child termination
        -:22571:   signal, do not block that signal.  */
        -:22572:void
function block_remote_children called 0 returned 0% blocks executed 0%
    #####:22573:block_remote_children ()
        -:22574:{
    #####:22575:  return;
        -:22576:}
        -:22577:
        -:22578:/* Restore asynchronous notification of remote child death.
        -:22579:   If this is done by raising the child termination signal,
        -:22580:   do not unblock that signal.  */
        -:22581:void
function unblock_remote_children called 0 returned 0% blocks executed 0%
    #####:22582:unblock_remote_children ()
        -:22583:{
    #####:22584:  return;
        -:22585:}
        -:22586:
        -:22587:/* Send signal SIG to child ID.  Return 0 if successful, -1 if not.  */
        -:22588:int
function remote_kill called 0 returned 0% blocks executed 0%
    #####:22589:remote_kill (id, sig)
        -:22590:     int id;
        -:22591:     int sig;
        -:22592:{
    #####:22593:  return -1;
        -:22594:}
        -:22595:
        -:22596:
        -:22597:
        -:22598:/*************************************************************
        -:22599:  ============================================================
        -:22600:  ************************************************************
        -:22601:  ============================================================
        -:22602:  ************************************************************
        -:22603:                         version.c
        -:22604:  ************************************************************
        -:22605:  ============================================================
        -:22606:  ************************************************************
        -:22607:  ============================================================
        -:22608:  *************************************************************/
        -:22609:
        -:22610:/* We use <config.h> instead of "config.h" so that a compilation
        -:22611:   using -I. -I$srcdir will use ./config.h rather than $srcdir/config.h
        -:22612:   (which it would do because make.h was found in $srcdir).  */
        -:22613:#include <config.h>
        -:22614:#undef stderr
        -:22615:#define stderr stdout
        -:22616:
        -:22617:#ifndef MAKE_HOST
        -:22618:# define MAKE_HOST "unknown"
        -:22619:#endif
        -:22620:
        -:22621:char *version_string = VERSION;
        -:22622:char *make_host = MAKE_HOST;
        -:22623:
        -:22624:/*
        -:22625:  Local variables:
        -:22626:  version-control: never
        -:22627:  End:
        -:22628: */
        -:22629:
        -:22630:
        -:22631:
        -:22632:/*************************************************************
        -:22633:  ============================================================
        -:22634:  ************************************************************
        -:22635:  ============================================================
        -:22636:  ************************************************************
        -:22637:                         getopt1.c
        -:22638:  ************************************************************
        -:22639:  ============================================================
        -:22640:  ************************************************************
        -:22641:  ============================================================
        -:22642:  *************************************************************/
        -:22643:
        -:22644:/* getopt_long and getopt_long_only entry points for GNU getopt.
        -:22645:   Copyright (C) 1987,88,89,90,91,92,93,94,96,97,98
        -:22646:     Free Software Foundation, Inc.
        -:22647:
        -:22648:   NOTE: The canonical source of this file is maintained with the GNU C Library.
        -:22649:   Bugs can be reported to bug-glibc@gnu.org.
        -:22650:
        -:22651:   This program is free software; you can redistribute it and/or modify it
        -:22652:   under the terms of the GNU General Public License as published by the
        -:22653:   Free Software Foundation; either version 2, or (at your option) any
        -:22654:   later version.
        -:22655:
        -:22656:   This program is distributed in the hope that it will be useful,
        -:22657:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:22658:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:22659:   GNU General Public License for more details.
        -:22660:
        -:22661:   You should have received a copy of the GNU General Public License
        -:22662:   along with this program; if not, write to the Free Software
        -:22663:   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
        -:22664:   USA.  */
        -:22665:
        -:22666:#ifdef HAVE_CONFIG_H
        -:22667:#include <config.h>
        -:22668:#undef stderr
        -:22669:#define stderr stdout
        -:22670:#endif
        -:22671:
        -:22672:#include "getopt.h"
        -:22673:#undef stderr
        -:22674:#define stderr stdout
        -:22675:
        -:22676:#if !defined __STDC__ || !__STDC__
        -:22677:/* This is a separate conditional since some stdc systems
        -:22678:   reject `defined (const)'.  */
        -:22679:#ifndef const
        -:22680:#define const
        -:22681:#endif
        -:22682:#endif
        -:22683:
        -:22684:#include <stdio.h>
        -:22685:#undef stderr
        -:22686:#define stderr stdout
        -:22687:
        -:22688:/* Comment out all this code if we are using the GNU C Library, and are not
        -:22689:   actually compiling the library itself.  This code is part of the GNU C
        -:22690:   Library, but also included in many other GNU distributions.  Compiling
        -:22691:   and linking in this code is a waste when using the GNU C library
        -:22692:   (especially if it is a shared library).  Rather than having every GNU
        -:22693:   program understand `configure --with-gnu-libc' and omit the object files,
        -:22694:   it is simpler to just do this in the source for each such file.  */
        -:22695:
        -:22696:#define GETOPT_INTERFACE_VERSION 2
        -:22697:#if !defined _LIBC && defined __GLIBC__ && __GLIBC__ >= 2
        -:22698:#include <gnu-versions.h>
        -:22699:#undef stderr
        -:22700:#define stderr stdout
        -:22701:#if _GNU_GETOPT_INTERFACE_VERSION == GETOPT_INTERFACE_VERSION
        -:22702:#define ELIDE_CODE
        -:22703:#endif
        -:22704:#endif
        -:22705:
        -:22706:#ifndef ELIDE_CODE
        -:22707:
        -:22708:
        -:22709:/* This needs to come after some library #include
        -:22710:   to get __GNU_LIBRARY__ defined.  */
        -:22711:#ifdef __GNU_LIBRARY__
        -:22712:#include <stdlib.h>
        -:22713:#undef stderr
        -:22714:#define stderr stdout
        -:22715:#endif
        -:22716:
        -:22717:#ifndef	NULL
        -:22718:#define NULL 0
        -:22719:#endif
        -:22720:
        -:22721:int
        -:22722:getopt_long (argc, argv, options, long_options, opt_index)
        -:22723:     int argc;
        -:22724:     char *const *argv;
        -:22725:     const char *options;
        -:22726:     const struct option *long_options;
        -:22727:     int *opt_index;
        -:22728:{
        -:22729:  return _getopt_internal (argc, argv, options, long_options, opt_index, 0);
        -:22730:}
        -:22731:
        -:22732:/* Like getopt_long, but '-' as well as '--' can indicate a long option.
        -:22733:   If an option that starts with '-' (not '--') doesn't match a long option,
        -:22734:   but does match a short option, it is parsed as a short option
        -:22735:   instead.  */
        -:22736:
        -:22737:int
        -:22738:getopt_long_only (argc, argv, options, long_options, opt_index)
        -:22739:     int argc;
        -:22740:     char *const *argv;
        -:22741:     const char *options;
        -:22742:     const struct option *long_options;
        -:22743:     int *opt_index;
        -:22744:{
        -:22745:  return _getopt_internal (argc, argv, options, long_options, opt_index, 1);
        -:22746:}
        -:22747:
        -:22748:
        -:22749:#endif	/* Not ELIDE_CODE.  */
        -:22750:
        -:22751:#ifdef TEST
        -:22752:
        -:22753:#include <stdio.h>
        -:22754:#undef stderr
        -:22755:#define stderr stdout
        -:22756:
        -:22757:int
        -:22758:main (argc, argv)
        -:22759:     int argc;
        -:22760:     char **argv;
        -:22761:{
        -:22762:  int c;
        -:22763:  int digit_optind = 0;
        -:22764:
        -:22765:  while (1)
        -:22766:    {
        -:22767:      int this_option_optind = optind ? optind : 1;
        -:22768:      int option_index = 0;
        -:22769:      static struct option long_options[] =
        -:22770:      {
        -:22771:	{"add", 1, 0, 0},
        -:22772:	{"append", 0, 0, 0},
        -:22773:	{"delete", 1, 0, 0},
        -:22774:	{"verbose", 0, 0, 0},
        -:22775:	{"create", 0, 0, 0},
        -:22776:	{"file", 1, 0, 0},
        -:22777:	{0, 0, 0, 0}
        -:22778:      };
        -:22779:
        -:22780:      c = getopt_long (argc, argv, "abc:d:0123456789",
        -:22781:		       long_options, &option_index);
        -:22782:      if (c == -1)
        -:22783:	break;
        -:22784:
        -:22785:      switch (c)
        -:22786:	{
        -:22787:	case 0:
        -:22788:	  printf ("option %s", long_options[option_index].name);
        -:22789:	  if (optarg)
        -:22790:	    printf (" with arg %s", optarg);
        -:22791:	  printf ("\n");
        -:22792:	  break;
        -:22793:
        -:22794:	case '0':
        -:22795:	case '1':
        -:22796:	case '2':
        -:22797:	case '3':
        -:22798:	case '4':
        -:22799:	case '5':
        -:22800:	case '6':
        -:22801:	case '7':
        -:22802:	case '8':
        -:22803:	case '9':
        -:22804:	  if (digit_optind != 0 && digit_optind != this_option_optind)
        -:22805:	    printf ("digits occur in two different argv-elements.\n");
        -:22806:	  digit_optind = this_option_optind;
        -:22807:	  printf ("option %c\n", c);
        -:22808:	  break;
        -:22809:
        -:22810:	case 'a':
        -:22811:	  printf ("option a\n");
        -:22812:	  break;
        -:22813:
        -:22814:	case 'b':
        -:22815:	  printf ("option b\n");
        -:22816:	  break;
        -:22817:
        -:22818:	case 'c':
        -:22819:	  printf ("option c with value `%s'\n", optarg);
        -:22820:	  break;
        -:22821:
        -:22822:	case 'd':
        -:22823:	  printf ("option d with value `%s'\n", optarg);
        -:22824:	  break;
        -:22825:
        -:22826:	case '?':
        -:22827:	  break;
        -:22828:
        -:22829:	default:
        -:22830:	  printf ("?? getopt returned character code 0%o ??\n", c);
        -:22831:	}
        -:22832:    }
        -:22833:
        -:22834:  if (optind < argc)
        -:22835:    {
        -:22836:      printf ("non-option ARGV-elements: ");
        -:22837:      while (optind < argc)
        -:22838:	printf ("%s ", argv[optind++]);
        -:22839:      printf ("\n");
        -:22840:    }
        -:22841:
        -:22842:  exit (0);
        -:22843:}
        -:22844:
        -:22845:#endif /* TEST */
        -:22846:
        -:22847:
        -:22848:
        -:22849:/*************************************************************
        -:22850:  ============================================================
        -:22851:  ************************************************************
        -:22852:  ============================================================
        -:22853:  ************************************************************
        -:22854:                         gettext.c
        -:22855:  ************************************************************
        -:22856:  ============================================================
        -:22857:  ************************************************************
        -:22858:  ============================================================
        -:22859:  *************************************************************/
        -:22860:
        -:22861:/* Begin of l10nflist.c */
        -:22862:
        -:22863:/* Handle list of needed message catalogs
        -:22864:   Copyright (C) 1995, 1996, 1997 Free Software Foundation, Inc.
        -:22865:   Contributed by Ulrich Drepper <drepper@gnu.ai.mit.edu>, 1995.
        -:22866:
        -:22867:   This program is free software; you can redistribute it and/or modify
        -:22868:   it under the terms of the GNU General Public License as published by
        -:22869:   the Free Software Foundation; either version 2, or (at your option)
        -:22870:   any later version.
        -:22871:
        -:22872:   This program is distributed in the hope that it will be useful,
        -:22873:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:22874:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:22875:   GNU General Public License for more details.
        -:22876:
        -:22877:   You should have received a copy of the GNU General Public License
        -:22878:   along with this program; if not, write to the Free Software Foundation,
        -:22879:   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
        -:22880:
        -:22881:#if HAVE_CONFIG_H
        -:22882:# include <config.h>
        -:22883:#undef stderr
        -:22884:#define stderr stdout
        -:22885:#endif
        -:22886:
        -:22887:#ifdef __GNUC__
        -:22888://# define alloca __builtin_alloca
        -:22889:# define HAVE_ALLOCA 1
        -:22890:#else
        -:22891:# if defined HAVE_ALLOCA_H || defined _LIBC
        -:22892:#  include <alloca.h>
        -:22893:#undef stderr
        -:22894:#define stderr stdout
        -:22895:# else
        -:22896:#  ifdef _AIX
        -:22897: #pragma alloca
        -:22898:#  else
        -:22899:#   ifndef alloca
        -:22900:char *alloca ();
        -:22901:#   endif
        -:22902:#  endif
        -:22903:# endif
        -:22904:#endif
        -:22905:
        -:22906:#if defined HAVE_STRING_H || defined _LIBC
        -:22907:# ifndef _GNU_SOURCE
        -:22908:#  define _GNU_SOURCE	1
        -:22909:# endif
        -:22910:# include <string.h>
        -:22911:#undef stderr
        -:22912:#define stderr stdout
        -:22913:#else
        -:22914:# include <strings.h>
        -:22915:#undef stderr
        -:22916:#define stderr stdout
        -:22917:# ifndef memcpy
        -:22918:#  define memcpy(Dst, Src, Num) bcopy (Src, Dst, Num)
        -:22919:# endif
        -:22920:#endif
        -:22921:#if !HAVE_STRCHR && !defined _LIBC
        -:22922:# ifndef strchr
        -:22923:#  define strchr index
        -:22924:# endif
        -:22925:#endif
        -:22926:
        -:22927:#if defined STDC_HEADERS || defined _LIBC
        -:22928:#else
        -:22929:char *getenv ();
        -:22930:# ifdef HAVE_MALLOC_H
        -:22931:# else
        -:22932:void free ();
        -:22933:# endif
        -:22934:#endif
        -:22935:
        -:22936:#if defined _LIBC || defined HAVE_ARGZ_H
        -:22937:# include <argz.h>
        -:22938:#undef stderr
        -:22939:#define stderr stdout
        -:22940:#endif
        -:22941:#include <ctype.h>
        -:22942:#include <sys/types.h>
        -:22943:#undef stderr
        -:22944:#define stderr stdout
        -:22945:
        -:22946:#if defined STDC_HEADERS || defined _LIBC
        -:22947:# include <stdlib.h>
        -:22948:#undef stderr
        -:22949:#define stderr stdout
        -:22950:#else
        -:22951:# ifdef HAVE_MEMORY_H
        -:22952:#  include <memory.h>
        -:22953:#undef stderr
        -:22954:#define stderr stdout
        -:22955:# endif
        -:22956:#endif
        -:22957:
        -:22958:/* Interrupt of l10nflist.c */
        -:22959:
        -:22960:/* Begin of loadinfo.h */
        -:22961:
        -:22962:/* Copyright (C) 1996, 1997 Free Software Foundation, Inc.
        -:22963:   This file is part of the GNU C Library.
        -:22964:   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1996.  */
        -:22965:
        -:22966:#ifndef PARAMS
        -:22967:# if __STDC__
        -:22968:#  define PARAMS(args) args
        -:22969:# else
        -:22970:#  define PARAMS(args) ()
        -:22971:# endif
        -:22972:#endif
        -:22973:
        -:22974:/* Encoding of locale name parts.  */
        -:22975:#define CEN_REVISION		1
        -:22976:#define CEN_SPONSOR		2
        -:22977:#define CEN_SPECIAL		4
        -:22978:#define XPG_NORM_CODESET	8
        -:22979:#define XPG_CODESET		16
        -:22980:#define TERRITORY		32
        -:22981:#define CEN_AUDIENCE		64
        -:22982:#define XPG_MODIFIER		128
        -:22983:
        -:22984:#define CEN_SPECIFIC	(CEN_REVISION|CEN_SPONSOR|CEN_SPECIAL|CEN_AUDIENCE)
        -:22985:#define XPG_SPECIFIC	(XPG_CODESET|XPG_NORM_CODESET|XPG_MODIFIER)
        -:22986:
        -:22987:struct loaded_l10nfile
        -:22988:{
        -:22989:  const char *filename;
        -:22990:  int decided;
        -:22991:
        -:22992:  const void *data;
        -:22993:
        -:22994:  struct loaded_l10nfile *next;
        -:22995:  struct loaded_l10nfile *successor[1];
        -:22996:};
        -:22997:
        -:22998:static const char *_nl_normalize_codeset PARAMS ((const unsigned char *codeset,
        -:22999:						  size_t name_len));
        -:23000:
        -:23001:static struct loaded_l10nfile *
        -:23002:_nl_make_l10nflist PARAMS ((struct loaded_l10nfile **l10nfile_list,
        -:23003:			    const char *dirlist, size_t dirlist_len, int mask,
        -:23004:			    const char *language, const char *territory,
        -:23005:			    const char *codeset,
        -:23006:			    const char *normalized_codeset,
        -:23007:			    const char *modifier, const char *special,
        -:23008:			    const char *sponsor, const char *revision,
        -:23009:			    const char *filename, int do_allocate));
        -:23010:
        -:23011:static const char *_nl_expand_alias PARAMS ((const char *name));
        -:23012:
        -:23013:static int _nl_explode_name PARAMS ((char *name, const char **language,
        -:23014:				     const char **modifier,
        -:23015:				     const char **territory,
        -:23016:				     const char **codeset,
        -:23017:				     const char **normalized_codeset,
        -:23018:				     const char **special,
        -:23019:				     const char **sponsor,
        -:23020:				     const char **revision));
        -:23021:
        -:23022:/* End of loadinfo.h */
        -:23023:
        -:23024:/* Resume of l10nflist.c */
        -:23025:
        -:23026:/* On some strange systems still no definition of NULL is found.  Sigh!  */
        -:23027:#ifndef NULL
        -:23028:# if defined __STDC__ && __STDC__
        -:23029:#  define NULL ((void *) 0)
        -:23030:# else
        -:23031:#  define NULL 0
        -:23032:# endif
        -:23033:#endif
        -:23034:
        -:23035:#if !defined _LIBC && !defined HAVE___ARGZ_COUNT
        -:23036:/* Returns the number of strings in ARGZ.  */
        -:23037:static size_t argz_count__ PARAMS ((const char *argz, size_t len));
        -:23038:
        -:23039:static size_t
function argz_count__ called 3 returned 100% blocks executed 100%
        3:23040:argz_count__ (argz, len)
        -:23041:     const char *argz;
        -:23042:     size_t len;
        -:23043:{
        3:23044:  size_t count = 0;
        6:23045:  while (len > 0)
branch  0 taken 3
branch  1 taken 3 (fallthrough)
        -:23046:    {
        3:23047:      size_t part_len = strlen (argz);
        3:23048:      argz += part_len + 1;
        3:23049:      len -= part_len + 1;
        3:23050:      count++;
        -:23051:    }
        3:23052:  return count;
        -:23053:}
        -:23054:# undef __argz_count
        -:23055:# define __argz_count(argz, len) argz_count__ (argz, len)
        -:23056:#endif	/* !_LIBC && !HAVE___ARGZ_COUNT */
        -:23057:
        -:23058:#if !defined _LIBC && !defined HAVE___ARGZ_STRINGIFY
        -:23059:/* Make '\0' separated arg vector ARGZ printable by converting all the '\0's
        -:23060:   except the last into the character SEP.  */
        -:23061:static void argz_stringify__ PARAMS ((char *argz, size_t len, int sep));
        -:23062:
        -:23063:static void
function argz_stringify__ called 1008 returned 100% blocks executed 80%
     1008:23064:argz_stringify__ (argz, len, sep)
        -:23065:     char *argz;
        -:23066:     size_t len;
        -:23067:     int sep;
        -:23068:{
     2016:23069:  while (len > 0)
branch  0 taken 1008
branch  1 taken 1008 (fallthrough)
        -:23070:    {
     1008:23071:      size_t part_len = strlen (argz);
     1008:23072:      argz += part_len;
     1008:23073:      len -= part_len + 1;
     1008:23074:      if (len > 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 1008
    #####:23075:	*argz++ = sep;
        -:23076:    }
     1008:23077:}
        -:23078:# undef __argz_stringify
        -:23079:# define __argz_stringify(argz, len, sep) argz_stringify__ (argz, len, sep)
        -:23080:#endif	/* !_LIBC && !HAVE___ARGZ_STRINGIFY */
        -:23081:
        -:23082:#if !defined _LIBC && !defined HAVE___ARGZ_NEXT
        -:23083:static char *argz_next__ PARAMS ((char *argz, size_t argz_len,
        -:23084:				  const char *entry));
        -:23085:
        -:23086:static char *
function argz_next__ called 0 returned 0% blocks executed 0%
    #####:23087:argz_next__ (argz, argz_len, entry)
        -:23088:     char *argz;
        -:23089:     size_t argz_len;
        -:23090:     const char *entry;
        -:23091:{
    #####:23092:  if (entry)
branch  0 never executed
branch  1 never executed
        -:23093:    {
    #####:23094:      if (entry < argz + argz_len)
branch  0 never executed
branch  1 never executed
    #####:23095:        entry = strchr (entry, '\0') + 1;
        -:23096:
    #####:23097:      return entry >= argz + argz_len ? NULL : (char *) entry;
branch  0 never executed
branch  1 never executed
        -:23098:    }
        -:23099:  else
    #####:23100:    if (argz_len > 0)
branch  0 never executed
branch  1 never executed
    #####:23101:      return argz;
        -:23102:    else
    #####:23103:      return 0;
        -:23104:}
        -:23105:# undef __argz_next
        -:23106:# define __argz_next(argz, len, entry) argz_next__ (argz, len, entry)
        -:23107:#endif	/* !_LIBC && !HAVE___ARGZ_NEXT */
        -:23108:
        -:23109:/* Return number of bits set in X.  */
        -:23110:static int pop PARAMS ((int x));
        -:23111:
        -:23112:static inline int
function pop called 1 returned 100% blocks executed 100%
        1:23113:pop (x)
        -:23114:     int x;
        -:23115:{
        -:23116:  /* We assume that no more than 16 bits are used.  */
        1:23117:  x = ((x & ~0x5555) >> 1) + (x & 0x5555);
        1:23118:  x = ((x & ~0x3333) >> 2) + (x & 0x3333);
        1:23119:  x = ((x >> 4) + x) & 0x0f0f;
        1:23120:  x = ((x >> 8) + x) & 0xff;
        -:23121:
        1:23122:  return x;
        -:23123:}
        -:23124:
        -:23125:static struct loaded_l10nfile *
function _nl_make_l10nflist called 1008 returned 100% blocks executed 51%
     1008:23126:_nl_make_l10nflist (l10nfile_list, dirlist, dirlist_len, mask, language,
        -:23127:		    territory, codeset, normalized_codeset, modifier, special,
        -:23128:		    sponsor, revision, filename, do_allocate)
        -:23129:     struct loaded_l10nfile **l10nfile_list;
        -:23130:     const char *dirlist;
        -:23131:     size_t dirlist_len;
        -:23132:     int mask;
        -:23133:     const char *language;
        -:23134:     const char *territory;
        -:23135:     const char *codeset;
        -:23136:     const char *normalized_codeset;
        -:23137:     const char *modifier;
        -:23138:     const char *special;
        -:23139:     const char *sponsor;
        -:23140:     const char *revision;
        -:23141:     const char *filename;
        -:23142:     int do_allocate;
        -:23143:{
        -:23144:  char *abs_filename;
     1008:23145:  struct loaded_l10nfile *last = NULL;
        -:23146:  struct loaded_l10nfile *retval;
        -:23147:  char *cp;
        -:23148:  size_t entries;
        -:23149:  int cnt;
        -:23150:
        -:23151:  /* Allocate room for the full file name.  */
     1008:23152:  abs_filename = (char *) malloc (dirlist_len
     1008:23153:				  + strlen (language)
     2016:23154:				  + ((mask & TERRITORY) != 0
    1008*:23155:				     ? strlen (territory) + 1 : 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 1008
     2016:23156:				  + ((mask & XPG_CODESET) != 0
    1008*:23157:				     ? strlen (codeset) + 1 : 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 1008
     2016:23158:				  + ((mask & XPG_NORM_CODESET) != 0
    1008*:23159:				     ? strlen (normalized_codeset) + 1 : 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 1008
     2016:23160:				  + (((mask & XPG_MODIFIER) != 0
     1008:23161:				      || (mask & CEN_AUDIENCE) != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 1008
    2016*:23162:				     ? strlen (modifier) + 1 : 0)
branch  0 taken 1008 (fallthrough)
branch  1 taken 0
     2016:23163:				  + ((mask & CEN_SPECIAL) != 0
    1008*:23164:				     ? strlen (special) + 1 : 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 1008
     2016:23165:				  + (((mask & CEN_SPONSOR) != 0
     1008:23166:				      || (mask & CEN_REVISION) != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 1008
    #####:23167:				     ? (1 + ((mask & CEN_SPONSOR) != 0
branch  0 never executed
branch  1 never executed
    #####:23168:					     ? strlen (sponsor) + 1 : 0)
    #####:23169:					+ ((mask & CEN_REVISION) != 0
    2016*:23170:					   ? strlen (revision) + 1 : 0)) : 0)
branch  0 taken 1008 (fallthrough)
branch  1 taken 0
branch  2 never executed
branch  3 never executed
     1008:23171:				  + 1 + strlen (filename) + 1);
        -:23172:
     1008:23173:  if (abs_filename == NULL)
branch  0 taken 0 (fallthrough)
branch  1 taken 1008
    #####:23174:    return NULL;
        -:23175:
     1008:23176:  retval = NULL;
     1008:23177:  last = NULL;
        -:23178:
        -:23179:  /* Construct file name.  */
     1008:23180:  memcpy (abs_filename, dirlist, dirlist_len);
     1008:23181:  __argz_stringify (abs_filename, dirlist_len, ':');
call    0 returned 1008
     1008:23182:  cp = abs_filename + (dirlist_len - 1);
     1008:23183:  *cp++ = '/';
     1008:23184:  cp = stpcpy (cp, language);
        -:23185:
     1008:23186:  if ((mask & TERRITORY) != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 1008
        -:23187:    {
    #####:23188:      *cp++ = '_';
    #####:23189:      cp = stpcpy (cp, territory);
        -:23190:    }
     1008:23191:  if ((mask & XPG_CODESET) != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 1008
        -:23192:    {
    #####:23193:      *cp++ = '.';
    #####:23194:      cp = stpcpy (cp, codeset);
        -:23195:    }
     1008:23196:  if ((mask & XPG_NORM_CODESET) != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 1008
        -:23197:    {
    #####:23198:      *cp++ = '.';
    #####:23199:      cp = stpcpy (cp, normalized_codeset);
        -:23200:    }
     1008:23201:  if ((mask & (XPG_MODIFIER | CEN_AUDIENCE)) != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 1008
        -:23202:    {
        -:23203:      /* This component can be part of both syntaces but has different
        -:23204:	 leading characters.  For CEN we use `+', else `@'.  */
    #####:23205:      *cp++ = (mask & CEN_AUDIENCE) != 0 ? '+' : '@';
branch  0 never executed
branch  1 never executed
    #####:23206:      cp = stpcpy (cp, modifier);
        -:23207:    }
     1008:23208:  if ((mask & CEN_SPECIAL) != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 1008
        -:23209:    {
    #####:23210:      *cp++ = '+';
    #####:23211:      cp = stpcpy (cp, special);
        -:23212:    }
     1008:23213:  if ((mask & (CEN_SPONSOR | CEN_REVISION)) != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 1008
        -:23214:    {
    #####:23215:      *cp++ = ',';
    #####:23216:      if ((mask & CEN_SPONSOR) != 0)
branch  0 never executed
branch  1 never executed
    #####:23217:	cp = stpcpy (cp, sponsor);
    #####:23218:      if ((mask & CEN_REVISION) != 0)
branch  0 never executed
branch  1 never executed
        -:23219:	{
    #####:23220:	  *cp++ = '_';
    #####:23221:	  cp = stpcpy (cp, revision);
        -:23222:	}
        -:23223:    }
        -:23224:
     1008:23225:  *cp++ = '/';
     1008:23226:  stpcpy (cp, filename);
        -:23227:
        -:23228:  /* Look in list of already loaded domains whether it is already
        -:23229:     available.  */
     1008:23230:  last = NULL;
    1008*:23231:  for (retval = *l10nfile_list; retval != NULL; retval = retval->next)
branch  0 taken 1006
branch  1 taken 2 (fallthrough)
     1006:23232:    if (retval->filename != NULL)
branch  0 taken 1006 (fallthrough)
branch  1 taken 0
        -:23233:      {
     1006:23234:	int compare = strcmp (retval->filename, abs_filename);
     1006:23235:	if (compare == 0)
branch  0 taken 1006 (fallthrough)
branch  1 taken 0
        -:23236:	  /* We found it!  */
     1006:23237:	  break;
    #####:23238:	if (compare < 0)
branch  0 never executed
branch  1 never executed
        -:23239:	  {
        -:23240:	    /* It's not in the list.  */
    #####:23241:	    retval = NULL;
    #####:23242:	    break;
        -:23243:	  }
        -:23244:
    #####:23245:	last = retval;
        -:23246:      }
        -:23247:
     1008:23248:  if (retval != NULL || do_allocate == 0)
branch  0 taken 2 (fallthrough)
branch  1 taken 1006
branch  2 taken 1 (fallthrough)
branch  3 taken 1
        -:23249:    {
     1007:23250:      free (abs_filename);
     1007:23251:      return retval;
        -:23252:    }
        -:23253:
        -:23254:  retval = (struct loaded_l10nfile *)
        1:23255:    malloc (sizeof (*retval) + (__argz_count (dirlist, dirlist_len)
call    0 returned 1
        1:23256:				* (1 << pop (mask))
call    0 returned 1
        -:23257:				* sizeof (struct loaded_l10nfile *)));
        1:23258:  if (retval == NULL)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:23259:    return NULL;
        -:23260:
        1:23261:  retval->filename = abs_filename;
        1:23262:  retval->decided = (__argz_count (dirlist, dirlist_len) != 1
call    0 returned 1
       1*:23263:		     || ((mask & XPG_CODESET) != 0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 1
    #####:23264:			 && (mask & XPG_NORM_CODESET) != 0));
branch  0 never executed
branch  1 never executed
        1:23265:  retval->data = NULL;
        -:23266:
        1:23267:  if (last == NULL)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -:23268:    {
        1:23269:      retval->next = *l10nfile_list;
        1:23270:      *l10nfile_list = retval;
        -:23271:    }
        -:23272:  else
        -:23273:    {
    #####:23274:      retval->next = last->next;
    #####:23275:      last->next = retval;
        -:23276:    }
        -:23277:
        1:23278:  entries = 0;
        -:23279:  /* If the DIRLIST is a real list the RETVAL entry corresponds not to
        -:23280:     a real file.  So we have to use the DIRLIST separation mechanism
        -:23281:     of the inner loop.  */
       1*:23282:  cnt = __argz_count (dirlist, dirlist_len) == 1 ? mask - 1 : mask;
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0
       1*:23283:  for (; cnt >= 0; --cnt)
branch  0 taken 0
branch  1 taken 1 (fallthrough)
    #####:23284:    if ((cnt & ~mask) == 0
branch  0 never executed
branch  1 never executed
    #####:23285:	&& ((cnt & CEN_SPECIFIC) == 0 || (cnt & XPG_SPECIFIC) == 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:23286:	&& ((cnt & XPG_CODESET) == 0 || (cnt & XPG_NORM_CODESET) == 0))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:23287:      {
        -:23288:	/* Iterate over all elements of the DIRLIST.  */
    #####:23289:	char *dir = NULL;
        -:23290:
    #####:23291:	while ((dir = __argz_next ((char *) dirlist, dirlist_len, dir))
call    0 never executed
    #####:23292:	       != NULL)
branch  0 never executed
branch  1 never executed
    #####:23293:	  retval->successor[entries++]
    #####:23294:	    = _nl_make_l10nflist (l10nfile_list, dir, strlen (dir) + 1, cnt,
call    0 never executed
        -:23295:				  language, territory, codeset,
        -:23296:				  normalized_codeset, modifier, special,
        -:23297:				  sponsor, revision, filename, 1);
        -:23298:      }
        1:23299:  retval->successor[entries] = NULL;
        -:23300:
        1:23301:  return retval;
        -:23302:}
        -:23303:
        -:23304:/* Normalize codeset name.  There is no standard for the codeset
        -:23305:   names.  Normalization allows the user to use any of the common
        -:23306:   names.  */
        -:23307:static const char *
function _nl_normalize_codeset called 0 returned 0% blocks executed 0%
    #####:23308:_nl_normalize_codeset (codeset, name_len)
        -:23309:     const unsigned char *codeset;
        -:23310:     size_t name_len;
        -:23311:{
    #####:23312:  int len = 0;
    #####:23313:  int only_digit = 1;
        -:23314:  char *retval;
        -:23315:  char *wp;
        -:23316:  size_t cnt;
        -:23317:
    #####:23318:  for (cnt = 0; cnt < name_len; ++cnt)
branch  0 never executed
branch  1 never executed
    #####:23319:    if (isalnum (codeset[cnt]))
branch  0 never executed
branch  1 never executed
        -:23320:      {
    #####:23321:	++len;
        -:23322:
    #####:23323:	if (isalpha (codeset[cnt]))
branch  0 never executed
branch  1 never executed
    #####:23324:	  only_digit = 0;
        -:23325:      }
        -:23326:
    #####:23327:  retval = (char *) malloc ((only_digit ? 3 : 0) + len + 1);
branch  0 never executed
branch  1 never executed
        -:23328:
    #####:23329:  if (retval != NULL)
branch  0 never executed
branch  1 never executed
        -:23330:    {
    #####:23331:      if (only_digit)
branch  0 never executed
branch  1 never executed
    #####:23332:	wp = stpcpy (retval, "iso");
        -:23333:      else
    #####:23334:	wp = retval;
        -:23335:
    #####:23336:      for (cnt = 0; cnt < name_len; ++cnt)
branch  0 never executed
branch  1 never executed
    #####:23337:	if (isalpha (codeset[cnt]))
branch  0 never executed
branch  1 never executed
    #####:23338:	  *wp++ = tolower (codeset[cnt]);
    #####:23339:	else if (isdigit (codeset[cnt]))
branch  0 never executed
branch  1 never executed
    #####:23340:	  *wp++ = codeset[cnt];
        -:23341:
    #####:23342:      *wp = '\0';
        -:23343:    }
        -:23344:
    #####:23345:  return (const char *) retval;
        -:23346:}
        -:23347:
        -:23348:/* End of l10nflist.c */
        -:23349:
        -:23350:/* Begin of explodename.c */
        -:23351:
        -:23352:/* Copyright (C) 1995, 1996, 1997, 1998 Free Software Foundation, Inc.
        -:23353:   Contributed by Ulrich Drepper <drepper@gnu.ai.mit.edu>, 1995.  */
        -:23354:
        -:23355:#if defined STDC_HEADERS || defined _LIBC
        -:23356:#endif
        -:23357:
        -:23358:#if defined HAVE_STRING_H || defined _LIBC
        -:23359:#else
        -:23360:#endif
        -:23361:
        -:23362:static int
function _nl_explode_name called 1 returned 100% blocks executed 26%
        1:23363:_nl_explode_name (name, language, modifier, territory, codeset,
        -:23364:		  normalized_codeset, special, sponsor, revision)
        -:23365:     char *name;
        -:23366:     const char **language;
        -:23367:     const char **modifier;
        -:23368:     const char **territory;
        -:23369:     const char **codeset;
        -:23370:     const char **normalized_codeset;
        -:23371:     const char **special;
        -:23372:     const char **sponsor;
        -:23373:     const char **revision;
        -:23374:{
        -:23375:  enum { undecided, xpg, cen } syntax;
        -:23376:  char *cp;
        -:23377:  int mask;
        -:23378:
        1:23379:  *modifier = NULL;
        1:23380:  *territory = NULL;
        1:23381:  *codeset = NULL;
        1:23382:  *normalized_codeset = NULL;
        1:23383:  *special = NULL;
        1:23384:  *sponsor = NULL;
        1:23385:  *revision = NULL;
        -:23386:
        -:23387:  /* Now we determine the single parts of the locale name.  First
        -:23388:     look for the language.  Termination symbols are `_' and `@' if
        -:23389:     we use XPG4 style, and `_', `+', and `,' if we use CEN syntax.  */
        1:23390:  mask = 0;
        1:23391:  syntax = undecided;
        1:23392:  *language = cp = name;
        3:23393:  while (cp[0] != '\0' && cp[0] != '_' && cp[0] != '@'
branch  0 taken 2 (fallthrough)
branch  1 taken 0
branch  2 taken 2 (fallthrough)
branch  3 taken 0
        5:23394:	 && cp[0] != '+' && cp[0] != ',')
branch  0 taken 2 (fallthrough)
branch  1 taken 1
branch  2 taken 2 (fallthrough)
branch  3 taken 0
branch  4 taken 2
branch  5 taken 0 (fallthrough)
        2:23395:    ++cp;
        -:23396:
        1:23397:  if (*language == cp)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -:23398:    /* This does not make sense: language has to be specified.  Use
        -:23399:       this entry as it is without exploding.  Perhaps it is an alias.  */
    #####:23400:    cp = strchr (*language, '\0');
        1:23401:  else if (cp[0] == '_')
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -:23402:    {
        -:23403:      /* Next is the territory.  */
    #####:23404:      cp[0] = '\0';
    #####:23405:      *territory = ++cp;
        -:23406:
    #####:23407:      while (cp[0] != '\0' && cp[0] != '.' && cp[0] != '@'
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:23408:	     && cp[0] != '+' && cp[0] != ',' && cp[0] != '_')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:23409:	++cp;
        -:23410:
    #####:23411:      mask |= TERRITORY;
        -:23412:
    #####:23413:      if (cp[0] == '.')
branch  0 never executed
branch  1 never executed
        -:23414:	{
        -:23415:	  /* Next is the codeset.  */
    #####:23416:	  syntax = xpg;
    #####:23417:	  cp[0] = '\0';
    #####:23418:	  *codeset = ++cp;
        -:23419:
    #####:23420:	  while (cp[0] != '\0' && cp[0] != '@')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:23421:	    ++cp;
        -:23422:
    #####:23423:	  mask |= XPG_CODESET;
        -:23424:
    #####:23425:	  if (*codeset != cp && (*codeset)[0] != '\0')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:23426:	    {
    #####:23427:	      *normalized_codeset = _nl_normalize_codeset ((const unsigned
        -:23428:                                                            char *)*codeset,
    #####:23429:							   cp - *codeset);
call    0 never executed
    #####:23430:	      if (strcmp (*codeset, *normalized_codeset) == 0)
branch  0 never executed
branch  1 never executed
    #####:23431:		free ((char *) *normalized_codeset);
        -:23432:	      else
    #####:23433:		mask |= XPG_NORM_CODESET;
        -:23434:	    }
        -:23435:	}
        -:23436:    }
        -:23437:
        1:23438:  if (cp[0] == '@' || (syntax != xpg && cp[0] == '+'))
branch  0 taken 1 (fallthrough)
branch  1 taken 0
branch  2 taken 1 (fallthrough)
branch  3 taken 0
branch  4 taken 0 (fallthrough)
branch  5 taken 1
        -:23439:    {
        -:23440:      /* Next is the modifier.  */
    #####:23441:      syntax = cp[0] == '@' ? xpg : cen;
branch  0 never executed
branch  1 never executed
    #####:23442:      cp[0] = '\0';
    #####:23443:      *modifier = ++cp;
        -:23444:
    #####:23445:      while (syntax == cen && cp[0] != '\0' && cp[0] != '+'
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:23446:	     && cp[0] != ',' && cp[0] != '_')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:23447:	++cp;
        -:23448:
    #####:23449:      mask |= XPG_MODIFIER | CEN_AUDIENCE;
        -:23450:    }
        -:23451:
        1:23452:  if (syntax != xpg && (cp[0] == '+' || cp[0] == ',' || cp[0] == '_'))
branch  0 taken 1 (fallthrough)
branch  1 taken 0
branch  2 taken 1 (fallthrough)
branch  3 taken 0
branch  4 taken 1 (fallthrough)
branch  5 taken 0
branch  6 taken 0 (fallthrough)
branch  7 taken 1
        -:23453:    {
    #####:23454:      syntax = cen;
        -:23455:
    #####:23456:      if (cp[0] == '+')
branch  0 never executed
branch  1 never executed
        -:23457:	{
        -:23458: 	  /* Next is special application (CEN syntax).  */
    #####:23459:	  cp[0] = '\0';
    #####:23460:	  *special = ++cp;
        -:23461:
    #####:23462:	  while (cp[0] != '\0' && cp[0] != ',' && cp[0] != '_')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:23463:	    ++cp;
        -:23464:
    #####:23465:	  mask |= CEN_SPECIAL;
        -:23466:	}
        -:23467:
    #####:23468:      if (cp[0] == ',')
branch  0 never executed
branch  1 never executed
        -:23469:	{
        -:23470: 	  /* Next is sponsor (CEN syntax).  */
    #####:23471:	  cp[0] = '\0';
    #####:23472:	  *sponsor = ++cp;
        -:23473:
    #####:23474:	  while (cp[0] != '\0' && cp[0] != '_')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:23475:	    ++cp;
        -:23476:
    #####:23477:	  mask |= CEN_SPONSOR;
        -:23478:	}
        -:23479:
    #####:23480:      if (cp[0] == '_')
branch  0 never executed
branch  1 never executed
        -:23481:	{
        -:23482: 	  /* Next is revision (CEN syntax).  */
    #####:23483:	  cp[0] = '\0';
    #####:23484:	  *revision = ++cp;
        -:23485:
    #####:23486:	  mask |= CEN_REVISION;
        -:23487:	}
        -:23488:    }
        -:23489:
        -:23490:  /* For CEN syntax values it might be important to have the
        -:23491:     separator character in the file name, not for XPG syntax.  */
        1:23492:  if (syntax == xpg)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -:23493:    {
    #####:23494:      if (*territory != NULL && (*territory)[0] == '\0')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:23495:	mask &= ~TERRITORY;
        -:23496:
    #####:23497:      if (*codeset != NULL && (*codeset)[0] == '\0')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:23498:	mask &= ~XPG_CODESET;
        -:23499:
    #####:23500:      if (*modifier != NULL && (*modifier)[0] == '\0')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:23501:	mask &= ~XPG_MODIFIER;
        -:23502:    }
        -:23503:
        1:23504:  return mask;
        -:23505:}
        -:23506:
        -:23507:/* End of explodename.c */
        -:23508:
        -:23509:/* Begin of loadmsgcat.c */
        -:23510:
        -:23511:/* Load needed message catalogs.
        -:23512:   Copyright (C) 1995, 1996, 1997, 1998 Free Software Foundation, Inc.  */
        -:23513:
        -:23514:#include <fcntl.h>
        -:23515:#include <sys/stat.h>
        -:23516:#undef stderr
        -:23517:#define stderr stdout
        -:23518:
        -:23519:#if defined STDC_HEADERS || defined _LIBC
        -:23520:#endif
        -:23521:
        -:23522:#if defined HAVE_UNISTD_H || defined _LIBC
        -:23523:# include <unistd.h>
        -:23524:#undef stderr
        -:23525:#define stderr stdout
        -:23526:#endif
        -:23527:
        -:23528:#if (defined HAVE_MMAP && defined HAVE_MUNMAP) || defined _LIBC
        -:23529:# include <sys/mman.h>
        -:23530:#undef stderr
        -:23531:#define stderr stdout
        -:23532:#endif
        -:23533:
        -:23534:/* Interrupt of loadmsgcat.c */
        -:23535:
        -:23536:/* Begin of gettext.h */
        -:23537:
        -:23538:/* Internal header for GNU gettext internationalization functions.
        -:23539:   Copyright (C) 1995, 1997 Free Software Foundation, Inc.  */
        -:23540:
        -:23541:#ifndef _GETTEXT_H
        -:23542:#define _GETTEXT_H 1
        -:23543:
        -:23544:#include <stdio.h>
        -:23545:#undef stderr
        -:23546:#define stderr stdout
        -:23547:
        -:23548:#if HAVE_LIMITS_H || _LIBC
        -:23549:# include <limits.h>
        -:23550:#undef stderr
        -:23551:#define stderr stdout
        -:23552:#endif
        -:23553:
        -:23554:/* The magic number of the GNU message catalog format.  */
        -:23555:#define _MAGIC 0x950412de
        -:23556:#define _MAGIC_SWAPPED 0xde120495
        -:23557:
        -:23558:/* Revision number of the currently used .mo (binary) file format.  */
        -:23559:#define MO_REVISION_NUMBER 0
        -:23560:
        -:23561:/* The following contortions are an attempt to use the C preprocessor
        -:23562:   to determine an unsigned integral type that is 32 bits wide.  An
        -:23563:   alternative approach is to use autoconf's AC_CHECK_SIZEOF macro, but
        -:23564:   doing that would require that the configure script compile and *run*
        -:23565:   the resulting executable.  Locally running cross-compiled executables
        -:23566:   is usually not possible.  */
        -:23567:
        -:23568:#if __STDC__
        -:23569:# define UINT_MAX_32_BITS 4294967295U
        -:23570:#else
        -:23571:# define UINT_MAX_32_BITS 0xFFFFFFFF
        -:23572:#endif
        -:23573:
        -:23574:/* If UINT_MAX isn't defined, assume it's a 32-bit type.
        -:23575:   This should be valid for all systems GNU cares about because
        -:23576:   that doesn't include 16-bit systems, and only modern systems
        -:23577:   (that certainly have <limits.h>) have 64+-bit integral types.  */
        -:23578:
        -:23579:#ifndef UINT_MAX
        -:23580:# define UINT_MAX UINT_MAX_32_BITS
        -:23581:#endif
        -:23582:
        -:23583:#if UINT_MAX == UINT_MAX_32_BITS
        -:23584:typedef unsigned nls_uint32;
        -:23585:#else
        -:23586:# if USHRT_MAX == UINT_MAX_32_BITS
        -:23587:typedef unsigned short nls_uint32;
        -:23588:# else
        -:23589:#  if ULONG_MAX == UINT_MAX_32_BITS
        -:23590:typedef unsigned long nls_uint32;
        -:23591:#  else
        -:23592:  /* The following line is intended to throw an error.  Using #error is
        -:23593:     not portable enough.  */
        -:23594:  "Cannot determine unsigned 32-bit data type."
        -:23595:#  endif
        -:23596:# endif
        -:23597:#endif
        -:23598:
        -:23599:/* Header for binary .mo file format.  */
        -:23600:struct mo_file_header
        -:23601:{
        -:23602:  /* The magic number.  */
        -:23603:  nls_uint32 magic;
        -:23604:  /* The revision number of the file format.  */
        -:23605:  nls_uint32 revision;
        -:23606:  /* The number of strings pairs.  */
        -:23607:  nls_uint32 nstrings;
        -:23608:  /* Offset of table with start offsets of original strings.  */
        -:23609:  nls_uint32 orig_tab_offset;
        -:23610:  /* Offset of table with start offsets of translation strings.  */
        -:23611:  nls_uint32 trans_tab_offset;
        -:23612:  /* Size of hashing table.  */
        -:23613:  nls_uint32 hash_tab_size;
        -:23614:  /* Offset of first hashing entry.  */
        -:23615:  nls_uint32 hash_tab_offset;
        -:23616:};
        -:23617:
        -:23618:struct string_desc
        -:23619:{
        -:23620:  /* Length of addressed string.  */
        -:23621:  nls_uint32 length;
        -:23622:  /* Offset of string in file.  */
        -:23623:  nls_uint32 offset;
        -:23624:};
        -:23625:
        -:23626:#endif	/* gettext.h  */
        -:23627:
        -:23628:/* End of gettext.h */
        -:23629:
        -:23630:/* Resume of loadmsgcat.c */
        -:23631:
        -:23632:/* Interrupt of loadmsgcat.c */
        -:23633:
        -:23634:/* Begin of gettextP.h */
        -:23635:
        -:23636:/* Header describing internals of gettext library
        -:23637:   Copyright (C) 1995, 1996, 1997, 1998 Free Software Foundation, Inc.
        -:23638:   Written by Ulrich Drepper <drepper@gnu.ai.mit.edu>, 1995.  */
        -:23639:
        -:23640:#ifndef _GETTEXTP_H
        -:23641:#define _GETTEXTP_H
        -:23642:
        -:23643:#ifndef PARAMS
        -:23644:# if __STDC__
        -:23645:#  define PARAMS(args) args
        -:23646:# else
        -:23647:#  define PARAMS(args) ()
        -:23648:# endif
        -:23649:#endif
        -:23650:
        -:23651:#ifndef internal_function
        -:23652:# define internal_function
        -:23653:#endif
        -:23654:
        -:23655:#ifndef W
        -:23656:# define W(flag, data) ((flag) ? SWAP (data) : (data))
        -:23657:#endif
        -:23658:
        -:23659:#ifdef _LIBC
        -:23660:# include <byteswap.h>
        -:23661:#undef stderr
        -:23662:#define stderr stdout
        -:23663:# define SWAP(i) bswap_32 (i)
        -:23664:#else
        -:23665:static nls_uint32 SWAP PARAMS ((nls_uint32 i));
        -:23666:
        -:23667:static inline nls_uint32
function SWAP called 0 returned 0% blocks executed 0%
    #####:23668:SWAP (i)
        -:23669:     nls_uint32 i;
        -:23670:{
    #####:23671:  return (i << 24) | ((i & 0xff00) << 8) | ((i >> 8) & 0xff00) | (i >> 24);
        -:23672:}
        -:23673:#endif
        -:23674:
        -:23675:struct loaded_domain
        -:23676:{
        -:23677:  const char *data;
        -:23678:  int use_mmap;
        -:23679:  size_t mmap_size;
        -:23680:  int must_swap;
        -:23681:  nls_uint32 nstrings;
        -:23682:  struct string_desc *orig_tab;
        -:23683:  struct string_desc *trans_tab;
        -:23684:  nls_uint32 hash_size;
        -:23685:  nls_uint32 *hash_tab;
        -:23686:};
        -:23687:
        -:23688:struct binding
        -:23689:{
        -:23690:  struct binding *next;
        -:23691:  char *domainname;
        -:23692:  char *dirname;
        -:23693:};
        -:23694:/*
        -:23695:static struct loaded_l10nfile *_nl_find_domain PARAMS ((const char *__dirname,
        -:23696:						 char *__locale,
        -:23697:						 const char *__domainname))
        -:23698:     internal_function;
        -:23699:static void _nl_load_domain PARAMS ((struct loaded_l10nfile *__domain))
        -:23700:     internal_function;
        -:23701:static void _nl_unload_domain PARAMS ((struct loaded_domain *__domain))
        -:23702:     internal_function;
        -:23703:*/
        -:23704:#endif /* gettextP.h  */
        -:23705:
        -:23706:/* End of gettextP.h */
        -:23707:
        -:23708:/* Resume of loadmsgcat.c */
        -:23709:
        -:23710:#ifdef _LIBC
        -:23711:/* Rename the non ISO C functions.  This is required by the standard
        -:23712:   because some ISO C functions will require linking with this object
        -:23713:   file and the name space must not be polluted.  */
        -:23714:# define open   __open
        -:23715:# define close  __close
        -:23716:# define read   __read
        -:23717:# define mmap   __mmap
        -:23718:# define munmap __munmap
        -:23719:#endif
        -:23720:
        -:23721:/* We need a sign, whether a new catalog was loaded, which can be associated
        -:23722:   with all translations.  This is important if the translations are
        -:23723:   cached by one of GCC's features.  */
        -:23724:int _nl_msg_cat_cntr = 0;
        -:23725:
        -:23726:/* Load the message catalogs specified by FILENAME.  If it is no valid
        -:23727:   message catalog do nothing.  */
        -:23728:static void
        -:23729:internal_function
function _nl_load_domain called 1 returned 100% blocks executed 11%
        1:23730:_nl_load_domain (domain_file)
        -:23731:     struct loaded_l10nfile *domain_file;
        -:23732:{
        -:23733:  int fd;
        -:23734:  size_t size;
        -:23735:  struct stat st;
        1:23736:  struct mo_file_header *data = (struct mo_file_header *) -1;
        -:23737:#if (defined HAVE_MMAP && defined HAVE_MUNMAP && !defined DISALLOW_MMAP) \
        -:23738:    || defined _LIBC
        -:23739:  int use_mmap = 0;
        -:23740:#endif
        -:23741:  struct loaded_domain *domain;
        -:23742:
        1:23743:  domain_file->decided = 1;
        1:23744:  domain_file->data = NULL;
        -:23745:
        -:23746:  /* If the record does not represent a valid locale the FILENAME
        -:23747:     might be NULL.  This can happen when according to the given
        -:23748:     specification the locale file name is different for XPG and CEN
        -:23749:     syntax.  */
        1:23750:  if (domain_file->filename == NULL)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
       1*:23751:    return;
        -:23752:
        -:23753:  /* Try to open the addressed file.  */
        1:23754:  fd = open (domain_file->filename, O_RDONLY);
call    0 returned 1
        1:23755:  if (fd == -1)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:23756:    return;
        -:23757:
        -:23758:  /* We must know about the size of the file.  */
    #####:23759:  if (fstat (fd, &st) != 0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:23760:      || (size_t_equal((size = int_to_size_t(off_t_to_int(st.st_size))), off_t_to_int(st.st_size)) != 0)
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -:23761:          /* || (size = (size_t) st.st_size) != st.st_size */
    #####:23762:      || size < sizeof (struct mo_file_header))
branch  0 never executed
branch  1 never executed
        -:23763:    {
        -:23764:      /* Something went wrong.  */
    #####:23765:      close (fd);
call    0 never executed
    #####:23766:      return;
        -:23767:    }
        -:23768:
        -:23769:#if (defined HAVE_MMAP && defined HAVE_MUNMAP && !defined DISALLOW_MMAP) \
        -:23770:    || defined _LIBC
        -:23771:  /* Now we are ready to load the file.  If mmap() is available we try
        -:23772:     this first.  If not available or it failed we try to load it.  */
        -:23773:  data = (struct mo_file_header *) mmap (NULL, size, PROT_READ,
        -:23774:					 MAP_PRIVATE, fd, 0);
        -:23775:
        -:23776:  if (data != (struct mo_file_header *) -1)
        -:23777:    {
        -:23778:      /* mmap() call was successful.  */
        -:23779:      close (fd);
        -:23780:      use_mmap = 1;
        -:23781:    }
        -:23782:#endif
        -:23783:
        -:23784:  /* If the data is not yet available (i.e. mmap'ed) we try to load
        -:23785:     it manually.  */
    #####:23786:  if (data == (struct mo_file_header *) -1)
branch  0 never executed
branch  1 never executed
        -:23787:    {
        -:23788:      size_t to_read;
        -:23789:      char *read_ptr;
        -:23790:
    #####:23791:      data = (struct mo_file_header *) malloc (size);
    #####:23792:      if (data == NULL)
branch  0 never executed
branch  1 never executed
    #####:23793:	return;
        -:23794:
    #####:23795:      to_read = size;
    #####:23796:      read_ptr = (char *) data;
        -:23797:      do
        -:23798:	{
    #####:23799:	  long int nb = (long int) read (fd, read_ptr, to_read);
call    0 never executed
    #####:23800:	  if (nb == -1)
branch  0 never executed
branch  1 never executed
        -:23801:	    {
    #####:23802:	      close (fd);
call    0 never executed
    #####:23803:	      return;
        -:23804:	    }
        -:23805:
    #####:23806:	  read_ptr += nb;
    #####:23807:	  to_read -= nb;
        -:23808:	}
    #####:23809:      while (to_read > 0);
branch  0 never executed
branch  1 never executed
        -:23810:
    #####:23811:      close (fd);
call    0 never executed
        -:23812:    }
        -:23813:
        -:23814:  /* Using the magic number we can test whether it really is a message
        -:23815:     catalog file.  */
    #####:23816:  if (data->magic != _MAGIC && data->magic != _MAGIC_SWAPPED)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:23817:    {
        -:23818:      /* The magic number is wrong: not a message catalog file.  */
        -:23819:#if (defined HAVE_MMAP && defined HAVE_MUNMAP && !defined DISALLOW_MMAP) \
        -:23820:    || defined _LIBC
        -:23821:      if (use_mmap)
        -:23822:	munmap ((caddr_t) data, size);
        -:23823:      else
        -:23824:#endif
    #####:23825:	free (data);
    #####:23826:      return;
        -:23827:    }
        -:23828:
        -:23829:  domain_file->data
    #####:23830:    = (struct loaded_domain *) malloc (sizeof (struct loaded_domain));
    #####:23831:  if (domain_file->data == NULL)
branch  0 never executed
branch  1 never executed
    #####:23832:    return;
        -:23833:
    #####:23834:  domain = (struct loaded_domain *) domain_file->data;
    #####:23835:  domain->data = (char *) data;
        -:23836:#if (defined HAVE_MMAP && defined HAVE_MUNMAP && !defined DISALLOW_MMAP) \
        -:23837:    || defined _LIBC
        -:23838:  domain->use_mmap = use_mmap;
        -:23839:#endif
    #####:23840:  domain->mmap_size = size;
    #####:23841:  domain->must_swap = data->magic != _MAGIC;
        -:23842:
        -:23843:  /* Fill in the information about the available tables.  */
    #####:23844:  switch (W (domain->must_swap, data->revision))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:23845:    {
    #####:23846:    case 0:
    #####:23847:      domain->nstrings = W (domain->must_swap, data->nstrings);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:23848:      domain->orig_tab = (struct string_desc *)
    #####:23849:	((char *) data + W (domain->must_swap, data->orig_tab_offset));
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:23850:      domain->trans_tab = (struct string_desc *)
    #####:23851:	((char *) data + W (domain->must_swap, data->trans_tab_offset));
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:23852:      domain->hash_size = W (domain->must_swap, data->hash_tab_size);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:23853:      domain->hash_tab = (nls_uint32 *)
    #####:23854:	((char *) data + W (domain->must_swap, data->hash_tab_offset));
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:23855:      break;
    #####:23856:    default:
        -:23857:      /* This is an illegal revision.  */
        -:23858:#if (defined HAVE_MMAP && defined HAVE_MUNMAP && !defined DISALLOW_MMAP) \
        -:23859:    || defined _LIBC
        -:23860:      if (use_mmap)
        -:23861:	munmap ((caddr_t) data, size);
        -:23862:      else
        -:23863:#endif
    #####:23864:	free (data);
    #####:23865:      free (domain);
    #####:23866:      domain_file->data = NULL;
    #####:23867:      return;
        -:23868:    }
        -:23869:
        -:23870:  /* Show that one domain is changed.  This might make some cached
        -:23871:     translations invalid.  */
    #####:23872:  ++_nl_msg_cat_cntr;
        -:23873:}
        -:23874:
        -:23875:#ifdef _LIBC
        -:23876:static void
        -:23877:internal_function
        -:23878:_nl_unload_domain (domain)
        -:23879:     struct loaded_domain *domain;
        -:23880:{
        -:23881:  if (domain->use_mmap)
        -:23882:    munmap ((caddr_t) domain->data, domain->mmap_size);
        -:23883:  else
        -:23884:    free ((void *) domain->data);
        -:23885:
        -:23886:  free (domain);
        -:23887:}
        -:23888:#endif
        -:23889:
        -:23890:/* End of loadmsgcat.c */
        -:23891:
        -:23892:/* Begin of localealias.c */
        -:23893:
        -:23894:/* Handle aliases for locale names.
        -:23895:   Copyright (C) 1995, 1996, 1997, 1998 Free Software Foundation, Inc.
        -:23896:   Written by Ulrich Drepper <drepper@gnu.ai.mit.edu>, 1995.  */
        -:23897:
        -:23898:#if defined STDC_HEADERS || defined _LIBC
        -:23899:#else
        -:23900:char *getenv ();
        -:23901:# ifdef HAVE_MALLOC_H
        -:23902:#  include <malloc.h>
        -:23903:#undef stderr
        -:23904:#define stderr stdout
        -:23905:# else
        -:23906:void free ();
        -:23907:# endif
        -:23908:#endif
        -:23909:
        -:23910:#if defined HAVE_STRING_H || defined _LIBC
        -:23911:# ifndef _GNU_SOURCE
        -:23912:#  define _GNU_SOURCE	1
        -:23913:# endif
        -:23914:#else
        -:23915:# ifndef memcpy
        -:23916:#  define memcpy(Dst, Src, Num) bcopy (Src, Dst, Num)
        -:23917:# endif
        -:23918:#endif
        -:23919:#if !HAVE_STRCHR && !defined _LIBC
        -:23920:# ifndef strchr
        -:23921:#  define strchr index
        -:23922:# endif
        -:23923:#endif
        -:23924:
        -:23925:#ifdef _LIBC
        -:23926:/* Rename the non ANSI C functions.  This is required by the standard
        -:23927:   because some ANSI C functions will require linking with this object
        -:23928:   file and the name space must not be polluted.  */
        -:23929:# define strcasecmp __strcasecmp
        -:23930:
        -:23931:# define mempcpy __mempcpy
        -:23932:# define HAVE_MEMPCPY	1
        -:23933:
        -:23934:/* We need locking here since we can be called from different places.  */
        -:23935:# include <bits/libc-lock.h>
        -:23936:#undef stderr
        -:23937:#define stderr stdout
        -:23938:
        -:23939:__libc_lock_define_initialized (static, lock);
        -:23940:#endif
        -:23941:
        -:23942:/* For those loosing systems which don't have `alloca' we have to add
        -:23943:   some additional code emulating it.  */
        -:23944:#ifdef HAVE_ALLOCA
        -:23945:/* Nothing has to be done.  */
        -:23946:# define ADD_BLOCK(list, address) /* nothing */
        -:23947:# define FREE_BLOCKS(list) /* nothing */
        -:23948:#else
        -:23949:struct block_list
        -:23950:{
        -:23951:  void *address;
        -:23952:  struct block_list *next;
        -:23953:};
        -:23954:# define ADD_BLOCK(list, addr)						      \
        -:23955:  do {									      \
        -:23956:    struct block_list *newp = (struct block_list *) malloc (sizeof (*newp));  \
        -:23957:    /* If we cannot get a free block we cannot add the new element to	      \
        -:23958:       the list.  */							      \
        -:23959:    if (newp != NULL) {							      \
        -:23960:      newp->address = (addr);						      \
        -:23961:      newp->next = (list);						      \
        -:23962:      (list) = newp;							      \
        -:23963:    }									      \
        -:23964:  } while (0)
        -:23965:# define FREE_BLOCKS(list)						      \
        -:23966:  do {									      \
        -:23967:    while (list != NULL) {						      \
        -:23968:      struct block_list *old = list;					      \
        -:23969:      list = list->next;						      \
        -:23970:      free (old);							      \
        -:23971:    }									      \
        -:23972:  } while (0)
        -:23973:# undef alloca
        -:23974:# define alloca(size) (malloc (size))
        -:23975:#endif	/* have alloca */
        -:23976:
        -:23977:struct alias_map
        -:23978:{
        -:23979:  const char *alias;
        -:23980:  const char *value;
        -:23981:};
        -:23982:
        -:23983:static char *string_space = NULL;
        -:23984:static size_t string_space_act = 0;
        -:23985:static size_t string_space_max = 0;
        -:23986:static struct alias_map *map;
        -:23987:static size_t nmap = 0;
        -:23988:static size_t maxmap = 0;
        -:23989:
        -:23990:/* Prototypes for local functions.  */
        -:23991:static size_t read_alias_file PARAMS ((const char *fname, int fname_len))
        -:23992:     internal_function;
        -:23993:static void extend_alias_table PARAMS ((void));
        -:23994:static int alias_compare PARAMS ((const struct alias_map *map1,
        -:23995:				  const struct alias_map *map2));
        -:23996:
        -:23997:static const char *
function _nl_expand_alias called 1 returned 100% blocks executed 90%
        1:23998:_nl_expand_alias (name)
        -:23999:    const char *name;
        -:24000:{
        -:24001:  static const char *locale_alias_path = ALIASPATH;
        -:24002:  struct alias_map *retval;
        1:24003:  const char *result = NULL;
        -:24004:  size_t added;
        -:24005:
        -:24006:#ifdef _LIBC
        -:24007:  __libc_lock_lock (lock);
        -:24008:#endif
        -:24009:
        -:24010:  do
        -:24011:    {
        -:24012:      struct alias_map item;
        -:24013:
        1:24014:      item.alias = name;
        -:24015:
        1:24016:      if (nmap > 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:24017:	retval = (struct alias_map *) bsearch (&item, map, nmap,
call    0 never executed
        -:24018:					       sizeof (struct alias_map),
        -:24019:					       (int (*) PARAMS ((const void *,
        -:24020:								 const void *))
        -:24021:						) alias_compare);
        -:24022:      else
        1:24023:	retval = NULL;
        -:24024:
        -:24025:      /* We really found an alias.  Return the value.  */
        1:24026:      if (retval != NULL)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -:24027:	{
    #####:24028:	  result = retval->value;
    #####:24029:	  break;
        -:24030:	}
        -:24031:
        -:24032:      /* Perhaps we can find another alias file.  */
        1:24033:      added = 0;
        3:24034:      while (added == 0 && locale_alias_path[0] != '\0')
branch  0 taken 3 (fallthrough)
branch  1 taken 0
branch  2 taken 2
branch  3 taken 1 (fallthrough)
        -:24035:	{
        -:24036:	  const char *start;
        -:24037:
        3:24038:	  while (locale_alias_path[0] == ':')
branch  0 taken 1
branch  1 taken 2 (fallthrough)
        1:24039:	    ++locale_alias_path;
        2:24040:	  start = locale_alias_path;
        -:24041:
       26:24042:	  while (locale_alias_path[0] != '\0' && locale_alias_path[0] != ':')
branch  0 taken 25 (fallthrough)
branch  1 taken 1
branch  2 taken 24
branch  3 taken 1 (fallthrough)
       24:24043:	    ++locale_alias_path;
        -:24044:
        2:24045:	  if (start < locale_alias_path)
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2:24046:	    added = read_alias_file (start, locale_alias_path - start);
call    0 returned 2
        -:24047:	}
        -:24048:    }
        1:24049:  while (added != 0);
branch  0 taken 0
branch  1 taken 1 (fallthrough)
        -:24050:
        -:24051:#ifdef _LIBC
        -:24052:  __libc_lock_unlock (lock);
        -:24053:#endif
        -:24054:
        1:24055:  return result;
        -:24056:}
        -:24057:
        -:24058:static size_t
        -:24059:internal_function
function read_alias_file called 2 returned 100% blocks executed 8%
        2:24060:read_alias_file (fname, fname_len)
        -:24061:     const char *fname;
        -:24062:     int fname_len;
        -:24063:{
        -:24064:#ifndef HAVE_ALLOCA
        -:24065:  struct block_list *block_list = NULL;
        -:24066:#endif
        -:24067:  FILE *fp;
        -:24068:  char *full_fname;
        -:24069:  size_t added;
        -:24070:  static const char aliasfile[] = "/locale.alias";
        -:24071:
        2:24072:  full_fname = (char *) alloca (fname_len + sizeof aliasfile);
        -:24073:  ADD_BLOCK (block_list, full_fname);
        -:24074:#ifdef HAVE_MEMPCPY
        -:24075:  mempcpy (mempcpy (full_fname, fname, fname_len),
        -:24076:	   aliasfile, sizeof aliasfile);
        -:24077:#else
        2:24078:  memcpy (full_fname, fname, fname_len);
        2:24079:  memcpy (&full_fname[fname_len], aliasfile, sizeof aliasfile);
        -:24080:#endif
        -:24081:
        2:24082:  fp = fopen (full_fname, "r");
call    0 returned 2
        2:24083:  if (fp == NULL)
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        -:24084:    {
        -:24085:      FREE_BLOCKS (block_list);
        2:24086:      return 0;
        -:24087:    }
        -:24088:
    #####:24089:  added = 0;
    #####:24090:  while (!feof (fp))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:24091:    {
        -:24092:      /* It is a reasonable approach to use a fix buffer here because
        -:24093:	 a) we are only interested in the first two fields
        -:24094:	 b) these fields must be usable as file names and so must not
        -:24095:	    be that long
        -:24096:       */
        -:24097:      unsigned char buf[BUFSIZ];
        -:24098:      unsigned char *alias;
        -:24099:      unsigned char *value;
        -:24100:      unsigned char *cp;
        -:24101:
    #####:24102:      if (fgets ((char *)buf, sizeof buf, fp) == NULL)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:24103:	/* EOF reached.  */
    #####:24104:	break;
        -:24105:
        -:24106:      /* Possibly not the whole line fits into the buffer.  Ignore
        -:24107:	 the rest of the line.  */
    #####:24108:      if (strchr ((char *)buf, '\n') == NULL)
branch  0 never executed
branch  1 never executed
        -:24109:	{
        -:24110:	  char altbuf[BUFSIZ];
        -:24111:	  do
    #####:24112:	    if (fgets (altbuf, sizeof altbuf, fp) == NULL)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:24113:	      /* Make sure the inner loop will be left.  The outer loop
        -:24114:		 will exit at the `feof' test.  */
    #####:24115:	      break;
    #####:24116:	  while (strchr (altbuf, '\n') == NULL);
branch  0 never executed
branch  1 never executed
        -:24117:	}
        -:24118:
    #####:24119:      cp = buf;
        -:24120:      /* Ignore leading white space.  */
    #####:24121:      while (isspace (cp[0]))
branch  0 never executed
branch  1 never executed
    #####:24122:	++cp;
        -:24123:
        -:24124:      /* A leading '#' signals a comment line.  */
    #####:24125:      if (cp[0] != '\0' && cp[0] != '#')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:24126:	{
    #####:24127:	  alias = cp++;
    #####:24128:	  while (cp[0] != '\0' && !isspace (cp[0]))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:24129:	    ++cp;
        -:24130:	  /* Terminate alias name.  */
    #####:24131:	  if (cp[0] != '\0')
branch  0 never executed
branch  1 never executed
    #####:24132:	    *cp++ = '\0';
        -:24133:
        -:24134:	  /* Now look for the beginning of the value.  */
    #####:24135:	  while (isspace (cp[0]))
branch  0 never executed
branch  1 never executed
    #####:24136:	    ++cp;
        -:24137:
    #####:24138:	  if (cp[0] != '\0')
branch  0 never executed
branch  1 never executed
        -:24139:	    {
        -:24140:	      size_t alias_len;
        -:24141:	      size_t value_len;
        -:24142:
    #####:24143:	      value = cp++;
    #####:24144:	      while (cp[0] != '\0' && !isspace (cp[0]))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:24145:		++cp;
        -:24146:	      /* Terminate value.  */
    #####:24147:	      if (cp[0] == '\n')
branch  0 never executed
branch  1 never executed
        -:24148:		{
        -:24149:		  /* This has to be done to make the following test
        -:24150:		     for the end of line possible.  We are looking for
        -:24151:		     the terminating '\n' which do not overwrite here.  */
    #####:24152:		  *cp++ = '\0';
    #####:24153:		  *cp = '\n';
        -:24154:		}
    #####:24155:	      else if (cp[0] != '\0')
branch  0 never executed
branch  1 never executed
    #####:24156:		*cp++ = '\0';
        -:24157:
    #####:24158:	      if (nmap >= maxmap)
branch  0 never executed
branch  1 never executed
    #####:24159:		extend_alias_table ();
call    0 never executed
        -:24160:
    #####:24161:	      alias_len = strlen ((char *)alias) + 1;
    #####:24162:	      value_len = strlen ((char *)value) + 1;
        -:24163:
    #####:24164:	      if (string_space_act + alias_len + value_len > string_space_max)
branch  0 never executed
branch  1 never executed
        -:24165:		{
        -:24166:		  /* Increase size of memory pool.  */
    #####:24167:		  size_t new_size = (string_space_max
    #####:24168:				     + (alias_len + value_len > 1024
    #####:24169:					? alias_len + value_len : 1024));
    #####:24170:		  char *new_pool = (char *) realloc (string_space, new_size);
    #####:24171:		  if (new_pool == NULL)
branch  0 never executed
branch  1 never executed
        -:24172:		    {
        -:24173:		      FREE_BLOCKS (block_list);
    #####:24174:		      return added;
        -:24175:		    }
    #####:24176:		  string_space = new_pool;
    #####:24177:		  string_space_max = new_size;
        -:24178:		}
        -:24179:
    #####:24180:	      map[nmap].alias = memcpy (&string_space[string_space_act],
        -:24181:					alias, alias_len);
    #####:24182:	      string_space_act += alias_len;
        -:24183:
    #####:24184:	      map[nmap].value = memcpy (&string_space[string_space_act],
        -:24185:					value, value_len);
    #####:24186:	      string_space_act += value_len;
        -:24187:
    #####:24188:	      ++nmap;
    #####:24189:	      ++added;
        -:24190:	    }
        -:24191:	}
        -:24192:    }
        -:24193:
        -:24194:  /* Should we test for ferror()?  I think we have to silently ignore
        -:24195:     errors.  --drepper  */
    #####:24196:  fclose (fp);
call    0 never executed
        -:24197:
    #####:24198:  if (added > 0)
branch  0 never executed
branch  1 never executed
    #####:24199:    qsort (map, nmap, sizeof (struct alias_map),
call    0 never executed
        -:24200:	   (int (*) PARAMS ((const void *, const void *))) alias_compare);
        -:24201:
        -:24202:  FREE_BLOCKS (block_list);
    #####:24203:  return added;
        -:24204:}
        -:24205:
        -:24206:static void
function extend_alias_table called 0 returned 0% blocks executed 0%
    #####:24207:extend_alias_table ()
        -:24208:{
        -:24209:  size_t new_size;
        -:24210:  struct alias_map *new_map;
        -:24211:
    #####:24212:  new_size = maxmap == 0 ? 100 : 2 * maxmap;
branch  0 never executed
branch  1 never executed
    #####:24213:  new_map = (struct alias_map *) realloc (map, (new_size
        -:24214:						* sizeof (struct alias_map)));
    #####:24215:  if (new_map == NULL)
branch  0 never executed
branch  1 never executed
        -:24216:    /* Simply don't extend: we don't have any more core.  */
    #####:24217:    return;
        -:24218:
    #####:24219:  map = new_map;
    #####:24220:  maxmap = new_size;
        -:24221:}
        -:24222:
        -:24223:#ifdef _LIBC
        -:24224:static void __attribute__ ((unused))
        -:24225:free_mem (void)
        -:24226:{
        -:24227:  if (string_space != NULL)
        -:24228:    free (string_space);
        -:24229:  if (map != NULL)
        -:24230:    free (map);
        -:24231:}
        -:24232:text_set_element (__libc_subfreeres, free_mem);
        -:24233:#endif
        -:24234:
        -:24235:static int
function alias_compare called 0 returned 0% blocks executed 0%
    #####:24236:alias_compare (map1, map2)
        -:24237:     const struct alias_map *map1;
        -:24238:     const struct alias_map *map2;
        -:24239:{
        -:24240:#if defined _LIBC || defined HAVE_STRCASECMP
        -:24241:  return strcasecmp (map1->alias, map2->alias);
        -:24242:#else
    #####:24243:  const unsigned char *p1 = (const unsigned char *) map1->alias;
    #####:24244:  const unsigned char *p2 = (const unsigned char *) map2->alias;
        -:24245:  unsigned char c1, c2;
        -:24246:
    #####:24247:  if (p1 == p2)
branch  0 never executed
branch  1 never executed
    #####:24248:    return 0;
        -:24249:
        -:24250:  do
        -:24251:    {
        -:24252:      /* I know this seems to be odd but the tolower() function in
        -:24253:	 some systems libc cannot handle nonalpha characters.  */
    #####:24254:      c1 = isupper (*p1) ? tolower (*p1) : *p1;
branch  0 never executed
branch  1 never executed
    #####:24255:      c2 = isupper (*p2) ? tolower (*p2) : *p2;
branch  0 never executed
branch  1 never executed
    #####:24256:      if (c1 == '\0')
branch  0 never executed
branch  1 never executed
    #####:24257:	break;
    #####:24258:      ++p1;
    #####:24259:      ++p2;
        -:24260:    }
    #####:24261:  while (c1 == c2);
branch  0 never executed
branch  1 never executed
        -:24262:
    #####:24263:  return c1 - c2;
        -:24264:#endif
        -:24265:}
        -:24266:
        -:24267:/* End of localealias.c */
        -:24268:
        -:24269:/* Begin of finddomain.c */
        -:24270:
        -:24271:/* Handle list of needed message catalogs
        -:24272:   Copyright (C) 1995, 1996, 1997, 1998 Free Software Foundation, Inc.
        -:24273:   Written by Ulrich Drepper <drepper@gnu.ai.mit.edu>, 1995.  */
        -:24274:
        -:24275:#include <errno.h>
        -:24276:#undef stderr
        -:24277:#define stderr stdout
        -:24278:
        -:24279:#if defined STDC_HEADERS || defined _LIBC
        -:24280:#else
        -:24281:# ifdef HAVE_MALLOC_H
        -:24282:# else
        -:24283:void free ();
        -:24284:# endif
        -:24285:#endif
        -:24286:
        -:24287:#if defined HAVE_STRING_H || defined _LIBC
        -:24288:#else
        -:24289:# ifndef memcpy
        -:24290:#  define memcpy(Dst, Src, Num) bcopy (Src, Dst, Num)
        -:24291:# endif
        -:24292:#endif
        -:24293:#if !HAVE_STRCHR && !defined _LIBC
        -:24294:# ifndef strchr
        -:24295:#  define strchr index
        -:24296:# endif
        -:24297:#endif
        -:24298:
        -:24299:#if defined HAVE_UNISTD_H || defined _LIBC
        -:24300:#endif
        -:24301:
        -:24302:#ifdef _LIBC
        -:24303:# include <libintl.h>
        -:24304:#undef stderr
        -:24305:#define stderr stdout
        -:24306:#else
        -:24307:# include "gettext.h"
        -:24308:#undef stderr
        -:24309:#define stderr stdout
        -:24310:#endif
        -:24311:
        -:24312:/* List of already loaded domains.  */
        -:24313:static struct loaded_l10nfile *_nl_loaded_domains;
        -:24314:
        -:24315:/* Return a data structure describing the message catalog described by
        -:24316:   the DOMAINNAME and CATEGORY parameters with respect to the currently
        -:24317:   established bindings.  */
        -:24318:static struct loaded_l10nfile *
        -:24319:internal_function
function _nl_find_domain called 1007 returned 100% blocks executed 58%
     1007:24320:_nl_find_domain (dirname, locale, domainname)
        -:24321:     const char *dirname;
        -:24322:     char *locale;
        -:24323:     const char *domainname;
        -:24324:{
        -:24325:  struct loaded_l10nfile *retval;
        -:24326:  const char *language;
        -:24327:  const char *modifier;
        -:24328:  const char *territory;
        -:24329:  const char *codeset;
        -:24330:  const char *normalized_codeset;
        -:24331:  const char *special;
        -:24332:  const char *sponsor;
        -:24333:  const char *revision;
        -:24334:  const char *alias_value;
        -:24335:  int mask;
        -:24336:
        -:24337:  /* LOCALE can consist of up to four recognized parts for the XPG syntax:
        -:24338:
        -:24339:		language[_territory[.codeset]][@modifier]
        -:24340:
        -:24341:     and six parts for the CEN syntax:
        -:24342:
        -:24343:	language[_territory][+audience][+special][,[sponsor][_revision]]
        -:24344:
        -:24345:     Beside the first part all of them are allowed to be missing.  If
        -:24346:     the full specified locale is not found, the less specific one are
        -:24347:     looked for.  The various parts will be stripped off according to
        -:24348:     the following order:
        -:24349:		(1) revision
        -:24350:		(2) sponsor
        -:24351:		(3) special
        -:24352:		(4) codeset
        -:24353:		(5) normalized codeset
        -:24354:		(6) territory
        -:24355:		(7) audience/modifier
        -:24356:   */
        -:24357:
        -:24358:  /* If we have already tested for this locale entry there has to
        -:24359:     be one data set in the list of loaded domains.  */
     1007:24360:  retval = _nl_make_l10nflist (&_nl_loaded_domains, dirname,
     1007:24361:			       strlen (dirname) + 1, 0, locale, NULL, NULL,
call    0 returned 1007
        -:24362:			       NULL, NULL, NULL, NULL, NULL, domainname, 0);
     1007:24363:  if (retval != NULL)
branch  0 taken 1006 (fallthrough)
branch  1 taken 1
        -:24364:    {
        -:24365:      /* We know something about this locale.  */
        -:24366:      int cnt;
        -:24367:
     1006:24368:      if (retval->decided == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 1006
    #####:24369:	_nl_load_domain (retval);
call    0 never executed
        -:24370:
     1006:24371:      if (retval->data != NULL)
branch  0 taken 0 (fallthrough)
branch  1 taken 1006
    #####:24372:	return retval;
        -:24373:
    1006*:24374:      for (cnt = 0; retval->successor[cnt] != NULL; ++cnt)
branch  0 taken 0
branch  1 taken 1006 (fallthrough)
        -:24375:	{
    #####:24376:	  if (retval->successor[cnt]->decided == 0)
branch  0 never executed
branch  1 never executed
    #####:24377:	    _nl_load_domain (retval->successor[cnt]);
call    0 never executed
        -:24378:
    #####:24379:	  if (retval->successor[cnt]->data != NULL)
branch  0 never executed
branch  1 never executed
    #####:24380:	    break;
        -:24381:	}
    1006*:24382:      return cnt >= 0 ? retval : NULL;
branch  0 taken 1006 (fallthrough)
branch  1 taken 0
        -:24383:      /* NOTREACHED */
        -:24384:    }
        -:24385:
        -:24386:  /* See whether the locale value is an alias.  If yes its value
        -:24387:     *overwrites* the alias name.  No test for the original value is
        -:24388:     done.  */
        1:24389:  alias_value = _nl_expand_alias (locale);
call    0 returned 1
        1:24390:  if (alias_value != NULL)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -:24391:    {
        -:24392:#if defined _LIBC || defined HAVE_STRDUP
    #####:24393:      locale = strdup (alias_value);
    #####:24394:      if (locale == NULL)
branch  0 never executed
branch  1 never executed
    #####:24395:	return NULL;
        -:24396:#else
        -:24397:      size_t len = strlen (alias_value) + 1;
        -:24398:      locale = (char *) malloc (len);
        -:24399:      if (locale == NULL)
        -:24400:	return NULL;
        -:24401:
        -:24402:      memcpy (locale, alias_value, len);
        -:24403:#endif
        -:24404:    }
        -:24405:
        -:24406:  /* Now we determine the single parts of the locale name.  First
        -:24407:     look for the language.  Termination symbols are `_' and `@' if
        -:24408:     we use XPG4 style, and `_', `+', and `,' if we use CEN syntax.  */
        1:24409:  mask = _nl_explode_name (locale, &language, &modifier, &territory,
call    0 returned 1
        -:24410:			   &codeset, &normalized_codeset, &special,
        -:24411:			   &sponsor, &revision);
        -:24412:
        -:24413:  /* Create all possible locale entries which might be interested in
        -:24414:     generalization.  */
        1:24415:  retval = _nl_make_l10nflist (&_nl_loaded_domains, dirname,
        1:24416:			       strlen (dirname) + 1, mask, language, territory,
call    0 returned 1
        -:24417:			       codeset, normalized_codeset, modifier, special,
        -:24418:			       sponsor, revision, domainname, 1);
        1:24419:  if (retval == NULL)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -:24420:    /* This means we are out of core.  */
    #####:24421:    return NULL;
        -:24422:
        1:24423:  if (retval->decided == 0)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:24424:    _nl_load_domain (retval);
call    0 returned 1
        1:24425:  if (retval->data == NULL)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -:24426:    {
        -:24427:      int cnt;
       1*:24428:      for (cnt = 0; retval->successor[cnt] != NULL; ++cnt)
branch  0 taken 0
branch  1 taken 1 (fallthrough)
        -:24429:	{
    #####:24430:	  if (retval->successor[cnt]->decided == 0)
branch  0 never executed
branch  1 never executed
    #####:24431:	    _nl_load_domain (retval->successor[cnt]);
call    0 never executed
    #####:24432:	  if (retval->successor[cnt]->data != NULL)
branch  0 never executed
branch  1 never executed
    #####:24433:	    break;
        -:24434:	}
        -:24435:    }
        -:24436:
        -:24437:  /* The room for an alias was dynamically allocated.  Free it now.  */
        1:24438:  if (alias_value != NULL)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:24439:    free (locale);
        -:24440:
        1:24441:  return retval;
        -:24442:}
        -:24443:
        -:24444:#ifdef _LIBC
        -:24445:static void __attribute__ ((unused))
        -:24446:free_mem (void)
        -:24447:{
        -:24448:  struct loaded_l10nfile *runp = _nl_loaded_domains;
        -:24449:
        -:24450:  while (runp != NULL)
        -:24451:    {
        -:24452:      struct loaded_l10nfile *here = runp;
        -:24453:      if (runp->data != NULL)
        -:24454:	_nl_unload_domain ((struct loaded_domain *) runp->data);
        -:24455:      runp = runp->next;
        -:24456:      free (here);
        -:24457:    }
        -:24458:}
        -:24459:
        -:24460:text_set_element (__libc_subfreeres, free_mem);
        -:24461:#endif
        -:24462:
        -:24463:/* End of finddomain.c */
        -:24464:
        -:24465:/* Begin of dcgettext.c */
        -:24466:
        -:24467:/* Implementation of the dcgettext(3) function.
        -:24468:   Copyright (C) 1995, 1996, 1997, 1998 Free Software Foundation, Inc.  */
        -:24469:
        -:24470:#ifndef errno
        -:24471:extern int errno;
        -:24472:#endif
        -:24473:#ifndef __set_errno
        -:24474:# define __set_errno(val) errno = (val)
        -:24475:#endif
        -:24476:
        -:24477:#if defined STDC_HEADERS || defined _LIBC
        -:24478:#else
        -:24479:char *getenv ();
        -:24480:# ifdef HAVE_MALLOC_H
        -:24481:# else
        -:24482:void free ();
        -:24483:# endif
        -:24484:#endif
        -:24485:
        -:24486:#if defined HAVE_STRING_H || defined _LIBC
        -:24487:# ifndef _GNU_SOURCE
        -:24488:#  define _GNU_SOURCE	1
        -:24489:# endif
        -:24490:#else
        -:24491:#endif
        -:24492:#if !HAVE_STRCHR && !defined _LIBC
        -:24493:# ifndef strchr
        -:24494:#  define strchr index
        -:24495:# endif
        -:24496:#endif
        -:24497:
        -:24498:#if defined HAVE_UNISTD_H || defined _LIBC
        -:24499:#endif
        -:24500:
        -:24501:#ifdef _LIBC
        -:24502:#else
        -:24503:#endif
        -:24504:
        -:24505:/* Interrupt of dcgettext.c */
        -:24506:
        -:24507:/* Begin of hash-string.h */
        -:24508:
        -:24509:/* Implements a string hashing function.
        -:24510:   Copyright (C) 1995, 1997 Free Software Foundation, Inc.  */
        -:24511:
        -:24512:#ifndef PARAMS
        -:24513:# if __STDC__
        -:24514:#  define PARAMS(Args) Args
        -:24515:# else
        -:24516:#  define PARAMS(Args) ()
        -:24517:# endif
        -:24518:#endif
        -:24519:
        -:24520:/* We assume to have `unsigned long int' value with at least 32 bits.  */
        -:24521:#define HASHWORDBITS 32
        -:24522:
        -:24523:/* Defines the so called `hashpjw' function by P.J. Weinberger
        -:24524:   [see Aho/Sethi/Ullman, COMPILERS: Principles, Techniques and Tools,
        -:24525:   1986, 1987 Bell Telephone Laboratories, Inc.]  */
        -:24526:static unsigned long hash_string PARAMS ((const char *__str_param));
        -:24527:
        -:24528:static inline unsigned long
function hash_string called 0 returned 0% blocks executed 0%
    #####:24529:hash_string (str_param)
        -:24530:     const char *str_param;
        -:24531:{
        -:24532:  unsigned long int hval, g;
    #####:24533:  const char *str = str_param;
        -:24534:
        -:24535:  /* Compute the hash value for the given string.  */
    #####:24536:  hval = 0;
    #####:24537:  while (*str != '\0')
branch  0 never executed
branch  1 never executed
        -:24538:    {
    #####:24539:      hval <<= 4;
    #####:24540:      hval += (unsigned long) *str++;
    #####:24541:      g = hval & ((unsigned long) 0xf << (HASHWORDBITS - 4));
    #####:24542:      if (g != 0)
branch  0 never executed
branch  1 never executed
        -:24543:	{
    #####:24544:	  hval ^= g >> (HASHWORDBITS - 8);
    #####:24545:	  hval ^= g;
        -:24546:	}
        -:24547:    }
    #####:24548:  return hval;
        -:24549:}
        -:24550:
        -:24551:/* End of hash-string.h */
        -:24552:
        -:24553:/* Resume of dcgettext.c */
        -:24554:
        -:24555:/* Amount to increase buffer size by in each try.  */
        -:24556:#define PATH_INCR 32
        -:24557:
        -:24558:/* The following is from pathmax.h.  */
        -:24559:/* Non-POSIX BSD systems might have gcc's limits.h, which doesn't define
        -:24560:   PATH_MAX but might cause redefinition warnings when sys/param.h is
        -:24561:   later included (as on MORE/BSD 4.3).  */
        -:24562:#if defined(_POSIX_VERSION) || (defined(HAVE_LIMITS_H) && !defined(__GNUC__))
        -:24563:#endif
        -:24564:
        -:24565:#ifndef _POSIX_PATH_MAX
        -:24566:# define _POSIX_PATH_MAX 255
        -:24567:#endif
        -:24568:
        -:24569:#if !defined(PATH_MAX) && defined(_PC_PATH_MAX)
        -:24570:# define PATH_MAX (pathconf ("/", _PC_PATH_MAX) < 1 ? 1024 : pathconf ("/", _PC_PATH_MAX))
        -:24571:#endif
        -:24572:
        -:24573:/* Don't include sys/param.h if it already has been.  */
        -:24574:#if defined(HAVE_SYS_PARAM_H) && !defined(PATH_MAX) && !defined(MAXPATHLEN)
        -:24575:# include <sys/param.h>
        -:24576:#undef stderr
        -:24577:#define stderr stdout
        -:24578:#endif
        -:24579:
        -:24580:#if !defined(PATH_MAX) && defined(MAXPATHLEN)
        -:24581:# define PATH_MAX MAXPATHLEN
        -:24582:#endif
        -:24583:
        -:24584:#ifndef PATH_MAX
        -:24585:# define PATH_MAX _POSIX_PATH_MAX
        -:24586:#endif
        -:24587:
        -:24588:/* XPG3 defines the result of `setlocale (category, NULL)' as:
        -:24589:   ``Directs `setlocale()' to query `category' and return the current
        -:24590:     setting of `local'.''
        -:24591:   However it does not specify the exact format.  And even worse: POSIX
        -:24592:   defines this not at all.  So we can use this feature only on selected
        -:24593:   system (e.g. those using GNU C Library).  */
        -:24594:#ifdef _LIBC
        -:24595:# define HAVE_LOCALE_NULL
        -:24596:#endif
        -:24597:
        -:24598:/* Name of the default domain used for gettext(3) prior any call to
        -:24599:   textdomain(3).  The default value for this is "messages".  */
        -:24600:static const char _nl_default_default_domain[] = "messages";
        -:24601:
        -:24602:/* Value used as the default domain for gettext(3).  */
        -:24603:static const char *_nl_current_default_domain = _nl_default_default_domain;
        -:24604:
        -:24605:/* Contains the default location of the message catalogs.  */
        -:24606:static const char _nl_default_dirname[] = LOCALEDIR;
        -:24607:
        -:24608:/* List with bindings of specific domains created by bindtextdomain()
        -:24609:   calls.  */
        -:24610:static struct binding *_nl_domain_bindings;
        -:24611:
        -:24612:/* Prototypes for local functions.  */
        -:24613:static char *find_msg PARAMS ((struct loaded_l10nfile *domain_file,
        -:24614:			       const char *msgid)) internal_function;
        -:24615:static const char *category_to_name PARAMS ((int category)) internal_function;
        -:24616:static const char *guess_category_value PARAMS ((int category,
        -:24617:						 const char *categoryname))
        -:24618:     internal_function;
        -:24619:
        -:24620:/* Names for the libintl functions are a problem.  They must not clash
        -:24621:   with existing names and they should follow ANSI C.  But this source
        -:24622:   code is also used in GNU C Library where the names have a __
        -:24623:   prefix.  So we have to make a difference here.  */
        -:24624:#ifdef _LIBC
        -:24625:# define DCGETTEXT __dcgettext
        -:24626:#else
        -:24627:# define DCGETTEXT dcgettext__
        -:24628:#endif
        -:24629:
        -:24630:/* Look up MSGID in the DOMAINNAME message catalog for the current CATEGORY
        -:24631:   locale.  */
        -:24632:char *
function dcgettext__ called 1007 returned 100% blocks executed 65%
     1007:24633:DCGETTEXT (domainname, msgid, category)
        -:24634:     const char *domainname;
        -:24635:     const char *msgid;
        -:24636:     int category;
        -:24637:{
        -:24638:#ifndef HAVE_ALLOCA
        -:24639:  struct block_list *block_list = NULL;
        -:24640:#endif
        -:24641:  struct loaded_l10nfile *domain;
        -:24642:  struct binding *binding;
        -:24643:  const char *categoryname;
        -:24644:  const char *categoryvalue;
        -:24645:  char *dirname, *xdomainname;
        -:24646:  char *single_locale;
        -:24647:  char *retval;
     1007:24648:  int saved_errno = errno;
        -:24649:
        -:24650:  /* If no real MSGID is given return NULL.  */
     1007:24651:  if (msgid == NULL)
branch  0 taken 0 (fallthrough)
branch  1 taken 1007
    #####:24652:    return NULL;
        -:24653:
        -:24654:  /* If DOMAINNAME is NULL, we are interested in the default domain.  If
        -:24655:     CATEGORY is not LC_MESSAGES this might not make much sense but the
        -:24656:     defintion left this undefined.  */
     1007:24657:  if (domainname == NULL)
branch  0 taken 1007 (fallthrough)
branch  1 taken 0
     1007:24658:    domainname = _nl_current_default_domain;
        -:24659:
        -:24660:  /* First find matching binding.  */
    1007*:24661:  for (binding = _nl_domain_bindings; binding != NULL; binding = binding->next)
branch  0 taken 1007
branch  1 taken 0 (fallthrough)
        -:24662:    {
     1007:24663:      int compare = strcmp (domainname, binding->domainname);
     1007:24664:      if (compare == 0)
branch  0 taken 1007 (fallthrough)
branch  1 taken 0
        -:24665:	/* We found it!  */
     1007:24666:	break;
    #####:24667:      if (compare < 0)
branch  0 never executed
branch  1 never executed
        -:24668:	{
        -:24669:	  /* It is not in the list.  */
    #####:24670:	  binding = NULL;
    #####:24671:	  break;
        -:24672:	}
        -:24673:    }
        -:24674:
     1007:24675:  if (binding == NULL)
branch  0 taken 0 (fallthrough)
branch  1 taken 1007
    #####:24676:    dirname = (char *) _nl_default_dirname;
     1007:24677:  else if (binding->dirname[0] == '/')
branch  0 taken 1007 (fallthrough)
branch  1 taken 0
     1007:24678:    dirname = binding->dirname;
        -:24679:  else
        -:24680:    {
        -:24681:      /* We have a relative path.  Make it absolute now.  */
    #####:24682:      size_t dirname_len = strlen (binding->dirname) + 1;
        -:24683:      size_t path_max;
        -:24684:      char *ret;
        -:24685:
    #####:24686:      path_max = (unsigned) PATH_MAX;
    #####:24687:      path_max += 2;		/* The getcwd docs say to do this.  */
        -:24688:
    #####:24689:      dirname = (char *) alloca (path_max + dirname_len);
        -:24690:      ADD_BLOCK (block_list, dirname);
        -:24691:
    #####:24692:      __set_errno (0);
    #####:24693:      while ((ret = getcwd (dirname, path_max)) == NULL && errno == ERANGE)
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -:24694:	{
    #####:24695:	  path_max += PATH_INCR;
    #####:24696:	  dirname = (char *) alloca (path_max + dirname_len);
        -:24697:	  ADD_BLOCK (block_list, dirname);
    #####:24698:	  __set_errno (0);
        -:24699:	}
        -:24700:
    #####:24701:      if (ret == NULL)
branch  0 never executed
branch  1 never executed
        -:24702:	{
        -:24703:	  /* We cannot get the current working directory.  Don't signal an
        -:24704:	     error but simply return the default string.  */
        -:24705:	  FREE_BLOCKS (block_list);
    #####:24706:	  __set_errno (saved_errno);
    #####:24707:	  return (char *) msgid;
        -:24708:	}
        -:24709:
    #####:24710:      stpcpy (stpcpy (strchr (dirname, '\0'), "/"), binding->dirname);
        -:24711:    }
        -:24712:
        -:24713:  /* Now determine the symbolic name of CATEGORY and its value.  */
     1007:24714:  categoryname = category_to_name (category);
call    0 returned 1007
     1007:24715:  categoryvalue = guess_category_value (category, categoryname);
call    0 returned 1007
        -:24716:
     1007:24717:  xdomainname = (char *) alloca (strlen (categoryname)
        -:24718:				 + strlen (domainname) + 5);
        -:24719:  ADD_BLOCK (block_list, xdomainname);
        -:24720:
     1007:24721:  stpcpy (stpcpy (stpcpy (stpcpy (xdomainname, categoryname), "/"),
        -:24722:		  domainname),
        -:24723:	  ".mo");
        -:24724:
        -:24725:  /* Creating working area.  */
     1007:24726:  single_locale = (char *) alloca (strlen (categoryvalue) + 1);
        -:24727:  ADD_BLOCK (block_list, single_locale);
        -:24728:
        -:24729:  /* Search for the given string.  This is a loop because we perhaps
        -:24730:     got an ordered list of languages to consider for th translation.  */
        -:24731:  while (1)
        -:24732:    {
        -:24733:      /* Make CATEGORYVALUE point to the next element of the list.  */
     2014:24734:      while (categoryvalue[0] != '\0' && categoryvalue[0] == ':')
branch  0 taken 1007 (fallthrough)
branch  1 taken 1007
branch  2 taken 0
branch  3 taken 1007 (fallthrough)
    #####:24735:	++categoryvalue;
     2014:24736:      if (categoryvalue[0] == '\0')
branch  0 taken 1007 (fallthrough)
branch  1 taken 1007
        -:24737:	{
        -:24738:	  /* The whole contents of CATEGORYVALUE has been searched but
        -:24739:	     no valid entry has been found.  We solve this situation
        -:24740:	     by implicitly appending a "C" entry, i.e. no translation
        -:24741:	     will take place.  */
     1007:24742:	  single_locale[0] = 'C';
     1007:24743:	  single_locale[1] = '\0';
        -:24744:	}
        -:24745:      else
        -:24746:	{
     1007:24747:	  char *cp = single_locale;
     3021:24748:	  while (categoryvalue[0] != '\0' && categoryvalue[0] != ':')
branch  0 taken 2014 (fallthrough)
branch  1 taken 1007
branch  2 taken 2014
branch  3 taken 0 (fallthrough)
     2014:24749:	    *cp++ = *categoryvalue++;
     1007:24750:	  *cp = '\0';
        -:24751:	}
        -:24752:
        -:24753:      /* If the current locale value is C (or POSIX) we don't load a
        -:24754:	 domain.  Return the MSGID.  */
     2014:24755:      if (strcmp (single_locale, "C") == 0
branch  0 taken 1007 (fallthrough)
branch  1 taken 1007
     1007:24756:	  || strcmp (single_locale, "POSIX") == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 1007
        -:24757:	{
        -:24758:	  FREE_BLOCKS (block_list);
     1007:24759:	  __set_errno (saved_errno);
     1007:24760:	  return (char *) msgid;
        -:24761:	}
        -:24762:
        -:24763:      /* Find structure describing the message catalog matching the
        -:24764:	 DOMAINNAME and CATEGORY.  */
     1007:24765:      domain = _nl_find_domain (dirname, single_locale, xdomainname);
call    0 returned 1007
        -:24766:
     1007:24767:      if (domain != NULL)
branch  0 taken 1007 (fallthrough)
branch  1 taken 0
        -:24768:	{
     1007:24769:	  retval = find_msg (domain, msgid);
call    0 returned 1007
        -:24770:
     1007:24771:	  if (retval == NULL)
branch  0 taken 1007 (fallthrough)
branch  1 taken 0
        -:24772:	    {
        -:24773:	      int cnt;
        -:24774:
    1007*:24775:	      for (cnt = 0; domain->successor[cnt] != NULL; ++cnt)
branch  0 taken 0
branch  1 taken 1007 (fallthrough)
        -:24776:		{
    #####:24777:		  retval = find_msg (domain->successor[cnt], msgid);
call    0 never executed
        -:24778:
    #####:24779:		  if (retval != NULL)
branch  0 never executed
branch  1 never executed
    #####:24780:		    break;
        -:24781:		}
        -:24782:	    }
        -:24783:
     1007:24784:	  if (retval != NULL)
branch  0 taken 0 (fallthrough)
branch  1 taken 1007
        -:24785:	    {
        -:24786:	      FREE_BLOCKS (block_list);
    #####:24787:	      __set_errno (saved_errno);
    #####:24788:	      return retval;
        -:24789:	    }
        -:24790:	}
        -:24791:    }
        -:24792:  /* NOTREACHED */
        -:24793:}
        -:24794:
        -:24795:#ifdef _LIBC
        -:24796:/* Alias for function name in GNU C Library.  */
        -:24797:#endif
        -:24798:
        -:24799:static char *
        -:24800:internal_function
function find_msg called 1007 returned 100% blocks executed 6%
     1007:24801:find_msg (domain_file, msgid)
        -:24802:     struct loaded_l10nfile *domain_file;
        -:24803:     const char *msgid;
        -:24804:{
        -:24805:  size_t top, act, bottom;
        -:24806:  struct loaded_domain *domain;
        -:24807:
     1007:24808:  if (domain_file->decided == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 1007
    #####:24809:    _nl_load_domain (domain_file);
call    0 never executed
        -:24810:
     1007:24811:  if (domain_file->data == NULL)
branch  0 taken 1007 (fallthrough)
branch  1 taken 0
     1007:24812:    return NULL;
        -:24813:
    #####:24814:  domain = (struct loaded_domain *) domain_file->data;
        -:24815:
        -:24816:  /* Locate the MSGID and its translation.  */
    #####:24817:  if (domain->hash_size > 2 && domain->hash_tab != NULL)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:24818:    {
        -:24819:      /* Use the hashing table.  */
    #####:24820:      nls_uint32 len = strlen (msgid);
    #####:24821:      nls_uint32 hash_val = hash_string (msgid);
call    0 never executed
    #####:24822:      nls_uint32 idx = hash_val % domain->hash_size;
    #####:24823:      nls_uint32 incr = 1 + (hash_val % (domain->hash_size - 2));
    #####:24824:      nls_uint32 nstr = W (domain->must_swap, domain->hash_tab[idx]);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:24825:
    #####:24826:      if (nstr == 0)
branch  0 never executed
branch  1 never executed
        -:24827:	/* Hash table entry is empty.  */
    #####:24828:	return NULL;
        -:24829:
    #####:24830:      if (W (domain->must_swap, domain->orig_tab[nstr - 1].length) == len
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:24831:	  && strcmp (msgid,
branch  0 never executed
branch  1 never executed
    #####:24832:		     domain->data + W (domain->must_swap,
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:24833:				       domain->orig_tab[nstr - 1].offset)) == 0)
    #####:24834:	return (char *) domain->data + W (domain->must_swap,
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:24835:					  domain->trans_tab[nstr - 1].offset);
        -:24836:
        -:24837:      while (1)
        -:24838:	{
    #####:24839:	  if (idx >= domain->hash_size - incr)
branch  0 never executed
branch  1 never executed
    #####:24840:	    idx -= domain->hash_size - incr;
        -:24841:	  else
    #####:24842:	    idx += incr;
        -:24843:
    #####:24844:	  nstr = W (domain->must_swap, domain->hash_tab[idx]);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:24845:	  if (nstr == 0)
branch  0 never executed
branch  1 never executed
        -:24846:	    /* Hash table entry is empty.  */
    #####:24847:	    return NULL;
        -:24848:
    #####:24849:	  if (W (domain->must_swap, domain->orig_tab[nstr - 1].length) == len
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:24850:	      && strcmp (msgid,
branch  0 never executed
branch  1 never executed
    #####:24851:			 domain->data + W (domain->must_swap,
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:24852:					   domain->orig_tab[nstr - 1].offset))
        -:24853:	         == 0)
    #####:24854:	    return (char *) domain->data
    #####:24855:	      + W (domain->must_swap, domain->trans_tab[nstr - 1].offset);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:24856:	}
        -:24857:      /* NOTREACHED */
        -:24858:    }
        -:24859:
        -:24860:  /* Now we try the default method:  binary search in the sorted
        -:24861:     array of messages.  */
    #####:24862:  bottom = 0;
    #####:24863:  top = domain->nstrings;
    #####:24864:  while (bottom < top)
branch  0 never executed
branch  1 never executed
        -:24865:    {
        -:24866:      int cmp_val;
        -:24867:
    #####:24868:      act = (bottom + top) / 2;
    #####:24869:      cmp_val = strcmp (msgid, domain->data
    #####:24870:			       + W (domain->must_swap,
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:24871:				    domain->orig_tab[act].offset));
    #####:24872:      if (cmp_val < 0)
branch  0 never executed
branch  1 never executed
    #####:24873:	top = act;
    #####:24874:      else if (cmp_val > 0)
branch  0 never executed
branch  1 never executed
    #####:24875:	bottom = act + 1;
        -:24876:      else
    #####:24877:	break;
        -:24878:    }
        -:24879:
        -:24880:  /* If an translation is found return this.  */
    #####:24881:  return bottom >= top ? NULL : (char *) domain->data
branch  0 never executed
branch  1 never executed
    #####:24882:                                + W (domain->must_swap,
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:24883:				     domain->trans_tab[act].offset);
        -:24884:}
        -:24885:
        -:24886:/* Return string representation of locale CATEGORY.  */
        -:24887:static const char *
        -:24888:internal_function
function category_to_name called 1007 returned 100% blocks executed 36%
     1007:24889:category_to_name (category)
        -:24890:     int category;
        -:24891:{
        -:24892:  const char *retval;
        -:24893:
     1007:24894:  switch (category)
branch  0 taken 0
branch  1 taken 0
branch  2 taken 0
branch  3 taken 0
branch  4 taken 0
branch  5 taken 1007
branch  6 taken 0
branch  7 taken 0
        -:24895:  {
        -:24896:#ifdef LC_COLLATE
    #####:24897:  case LC_COLLATE:
    #####:24898:    retval = "LC_COLLATE";
    #####:24899:    break;
        -:24900:#endif
        -:24901:#ifdef LC_CTYPE
    #####:24902:  case LC_CTYPE:
    #####:24903:    retval = "LC_CTYPE";
    #####:24904:    break;
        -:24905:#endif
        -:24906:#ifdef LC_MONETARY
    #####:24907:  case LC_MONETARY:
    #####:24908:    retval = "LC_MONETARY";
    #####:24909:    break;
        -:24910:#endif
        -:24911:#ifdef LC_NUMERIC
    #####:24912:  case LC_NUMERIC:
    #####:24913:    retval = "LC_NUMERIC";
    #####:24914:    break;
        -:24915:#endif
        -:24916:#ifdef LC_TIME
    #####:24917:  case LC_TIME:
    #####:24918:    retval = "LC_TIME";
    #####:24919:    break;
        -:24920:#endif
        -:24921:#ifdef LC_MESSAGES
     1007:24922:  case LC_MESSAGES:
     1007:24923:    retval = "LC_MESSAGES";
     1007:24924:    break;
        -:24925:#endif
        -:24926:#ifdef LC_RESPONSE
        -:24927:  case LC_RESPONSE:
        -:24928:    retval = "LC_RESPONSE";
        -:24929:    break;
        -:24930:#endif
        -:24931:#ifdef LC_ALL
    #####:24932:  case LC_ALL:
        -:24933:    /* This might not make sense but is perhaps better than any other
        -:24934:       value.  */
    #####:24935:    retval = "LC_ALL";
    #####:24936:    break;
        -:24937:#endif
    #####:24938:  default:
        -:24939:    /* If you have a better idea for a default value let me know.  */
    #####:24940:    retval = "LC_XXX";
        -:24941:  }
        -:24942:
     1007:24943:  return retval;
        -:24944:}
        -:24945:
        -:24946:/* Guess value of current locale from value of the environment variables.  */
        -:24947:static const char *
        -:24948:internal_function
function guess_category_value called 1007 returned 100% blocks executed 28%
     1007:24949:guess_category_value (category, categoryname)
        -:24950:     int category;
        -:24951:     const char *categoryname;
        -:24952:{
        -:24953:  const char *retval;
        -:24954:
        -:24955:  /* The highest priority value is the `LANGUAGE' environment
        -:24956:     variable.  This is a GNU extension.  */
     1007:24957:  retval = getenv ("LANGUAGE");
call    0 returned 1007
     1007:24958:  if (retval != NULL && retval[0] != '\0')
branch  0 taken 1007 (fallthrough)
branch  1 taken 0
branch  2 taken 1007 (fallthrough)
branch  3 taken 0
     1007:24959:    return retval;
        -:24960:
        -:24961:  /* `LANGUAGE' is not set.  So we have to proceed with the POSIX
        -:24962:     methods of looking to `LC_ALL', `LC_xxx', and `LANG'.  On some
        -:24963:     systems this can be done by the `setlocale' function itself.  */
        -:24964:#if defined HAVE_SETLOCALE && defined HAVE_LC_MESSAGES && defined HAVE_LOCALE_NULL
        -:24965:  return setlocale (category, NULL);
        -:24966:#else
        -:24967:  /* Setting of LC_ALL overwrites all other.  */
    #####:24968:  retval = getenv ("LC_ALL");
call    0 never executed
    #####:24969:  if (retval != NULL && retval[0] != '\0')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:24970:    return retval;
        -:24971:
        -:24972:  /* Next comes the name of the desired category.  */
    #####:24973:  retval = getenv (categoryname);
call    0 never executed
    #####:24974:  if (retval != NULL && retval[0] != '\0')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:24975:    return retval;
        -:24976:
        -:24977:  /* Last possibility is the LANG environment variable.  */
    #####:24978:  retval = getenv ("LANG");
call    0 never executed
    #####:24979:  if (retval != NULL && retval[0] != '\0')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:24980:    return retval;
        -:24981:
        -:24982:  /* We use C as the default domain.  POSIX says this is implementation
        -:24983:     defined.  */
    #####:24984:  return "C";
        -:24985:#endif
        -:24986:}
        -:24987:
        -:24988:#ifdef _LIBC
        -:24989:/* If we want to free all resources we have to do some work at
        -:24990:   program's end.  */
        -:24991:static void __attribute__ ((unused))
        -:24992:free_mem (void)
        -:24993:{
        -:24994:  struct binding *runp;
        -:24995:
        -:24996:  for (runp = _nl_domain_bindings; runp != NULL; runp = runp->next)
        -:24997:    {
        -:24998:      free (runp->domainname);
        -:24999:      if (runp->dirname != _nl_default_dirname)
        -:25000:	/* Yes, this is a pointer comparison.  */
        -:25001:	free (runp->dirname);
        -:25002:    }
        -:25003:
        -:25004:  if (_nl_current_default_domain != _nl_default_default_domain)
        -:25005:    /* Yes, again a pointer comparison.  */
        -:25006:    free ((char *) _nl_current_default_domain);
        -:25007:}
        -:25008:
        -:25009:text_set_element (__libc_subfreeres, free_mem);
        -:25010:#endif
        -:25011:
        -:25012:/* End of dcgettext.c */
        -:25013:
        -:25014:/* Begin of bindtextdom.c */
        -:25015:
        -:25016:/* Implementation of the bindtextdomain(3) function
        -:25017:   Copyright (C) 1995, 1996, 1997, 1998 Free Software Foundation, Inc.  */
        -:25018:
        -:25019:#if defined STDC_HEADERS || defined _LIBC
        -:25020:#else
        -:25021:# ifdef HAVE_MALLOC_H
        -:25022:# else
        -:25023:void free ();
        -:25024:# endif
        -:25025:#endif
        -:25026:
        -:25027:#if defined HAVE_STRING_H || defined _LIBC
        -:25028:#else
        -:25029:# ifndef memcpy
        -:25030:#  define memcpy(Dst, Src, Num) bcopy (Src, Dst, Num)
        -:25031:# endif
        -:25032:#endif
        -:25033:
        -:25034:#ifdef _LIBC
        -:25035:#else
        -:25036:#endif
        -:25037:
        -:25038:/* Contains the default location of the message catalogs.  */
        -:25039:/* static const char _nl_default_dirname[]; */
        -:25040:
        -:25041:/* List with bindings of specific domains.  */
        -:25042:/* static struct binding *_nl_domain_bindings; */
        -:25043:
        -:25044:/* Names for the libintl functions are a problem.  They must not clash
        -:25045:   with existing names and they should follow ANSI C.  But this source
        -:25046:   code is also used in GNU C Library where the names have a __
        -:25047:   prefix.  So we have to make a difference here.  */
        -:25048:#ifdef _LIBC
        -:25049:# define BINDTEXTDOMAIN __bindtextdomain
        -:25050:# ifndef strdup
        -:25051:#  define strdup(str) __strdup (str)
        -:25052:# endif
        -:25053:#else
        -:25054:# define BINDTEXTDOMAIN bindtextdomain__
        -:25055:#endif
        -:25056:
        -:25057:/* Specify that the DOMAINNAME message catalog will be found
        -:25058:   in DIRNAME rather than in the system locale data base.  */
        -:25059:static char *
function bindtextdomain__ called 1 returned 100% blocks executed 35%
        1:25060:BINDTEXTDOMAIN (domainname, dirname)
        -:25061:     const char *domainname;
        -:25062:     const char *dirname;
        -:25063:{
        -:25064:  struct binding *binding;
        -:25065:
        -:25066:  /* Some sanity checks.  */
        1:25067:  if (domainname == NULL || domainname[0] == '\0')
branch  0 taken 1 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 1
    #####:25068:    return NULL;
        -:25069:
       1*:25070:  for (binding = _nl_domain_bindings; binding != NULL; binding = binding->next)
branch  0 taken 0
branch  1 taken 1 (fallthrough)
        -:25071:    {
    #####:25072:      int compare = strcmp (domainname, binding->domainname);
    #####:25073:      if (compare == 0)
branch  0 never executed
branch  1 never executed
        -:25074:	/* We found it!  */
    #####:25075:	break;
    #####:25076:      if (compare < 0)
branch  0 never executed
branch  1 never executed
        -:25077:	{
        -:25078:	  /* It is not in the list.  */
    #####:25079:	  binding = NULL;
    #####:25080:	  break;
        -:25081:	}
        -:25082:    }
        -:25083:
        1:25084:  if (dirname == NULL)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -:25085:    /* The current binding has be to returned.  */
    #####:25086:    return binding == NULL ? (char *) _nl_default_dirname : binding->dirname;
branch  0 never executed
branch  1 never executed
        -:25087:
        1:25088:  if (binding != NULL)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -:25089:    {
        -:25090:      /* The domain is already bound.  If the new value and the old
        -:25091:	 one are equal we simply do nothing.  Otherwise replace the
        -:25092:	 old binding.  */
    #####:25093:      if (strcmp (dirname, binding->dirname) != 0)
branch  0 never executed
branch  1 never executed
        -:25094:	{
        -:25095:	  char *new_dirname;
        -:25096:
    #####:25097:	  if (strcmp (dirname, _nl_default_dirname) == 0)
branch  0 never executed
branch  1 never executed
    #####:25098:	    new_dirname = (char *) _nl_default_dirname;
        -:25099:	  else
        -:25100:	    {
        -:25101:#if defined _LIBC || defined HAVE_STRDUP
    #####:25102:	      new_dirname = strdup (dirname);
    #####:25103:	      if (new_dirname == NULL)
branch  0 never executed
branch  1 never executed
    #####:25104:		return NULL;
        -:25105:#else
        -:25106:	      size_t len = strlen (dirname) + 1;
        -:25107:	      new_dirname = (char *) malloc (len);
        -:25108:	      if (new_dirname == NULL)
        -:25109:		return NULL;
        -:25110:
        -:25111:	      memcpy (new_dirname, dirname, len);
        -:25112:#endif
        -:25113:	    }
        -:25114:
    #####:25115:	  if (binding->dirname != _nl_default_dirname)
branch  0 never executed
branch  1 never executed
    #####:25116:	    free (binding->dirname);
        -:25117:
    #####:25118:	  binding->dirname = new_dirname;
        -:25119:	}
        -:25120:    }
        -:25121:  else
        -:25122:    {
        -:25123:      /* We have to create a new binding.  */
        -:25124:#if !defined _LIBC && !defined HAVE_STRDUP
        -:25125:      size_t len;
        -:25126:#endif
        -:25127:      struct binding *new_binding =
        1:25128:	(struct binding *) malloc (sizeof (*new_binding));
        -:25129:
        1:25130:      if (new_binding == NULL)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:25131:	return NULL;
        -:25132:
        -:25133:#if defined _LIBC || defined HAVE_STRDUP
        1:25134:      new_binding->domainname = strdup (domainname);
        1:25135:      if (new_binding->domainname == NULL)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:25136:	return NULL;
        -:25137:#else
        -:25138:      len = strlen (domainname) + 1;
        -:25139:      new_binding->domainname = (char *) malloc (len);
        -:25140:      if (new_binding->domainname == NULL)
        -:25141:	return NULL;
        -:25142:      memcpy (new_binding->domainname, domainname, len);
        -:25143:#endif
        -:25144:
        1:25145:      if (strcmp (dirname, _nl_default_dirname) == 0)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:25146:	new_binding->dirname = (char *) _nl_default_dirname;
        -:25147:      else
        -:25148:	{
        -:25149:#if defined _LIBC || defined HAVE_STRDUP
    #####:25150:	  new_binding->dirname = strdup (dirname);
    #####:25151:	  if (new_binding->dirname == NULL)
branch  0 never executed
branch  1 never executed
    #####:25152:	    return NULL;
        -:25153:#else
        -:25154:	  len = strlen (dirname) + 1;
        -:25155:	  new_binding->dirname = (char *) malloc (len);
        -:25156:	  if (new_binding->dirname == NULL)
        -:25157:	    return NULL;
        -:25158:	  memcpy (new_binding->dirname, dirname, len);
        -:25159:#endif
        -:25160:	}
        -:25161:
        -:25162:      /* Now enqueue it.  */
        1:25163:      if (_nl_domain_bindings == NULL
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:25164:	  || strcmp (domainname, _nl_domain_bindings->domainname) < 0)
branch  0 never executed
branch  1 never executed
        -:25165:	{
        1:25166:	  new_binding->next = _nl_domain_bindings;
        1:25167:	  _nl_domain_bindings = new_binding;
        -:25168:	}
        -:25169:      else
        -:25170:	{
    #####:25171:	  binding = _nl_domain_bindings;
    #####:25172:	  while (binding->next != NULL
    #####:25173:		 && strcmp (domainname, binding->next->domainname) > 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:25174:	    binding = binding->next;
        -:25175:
    #####:25176:	  new_binding->next = binding->next;
    #####:25177:	  binding->next = new_binding;
        -:25178:	}
        -:25179:
        1:25180:      binding = new_binding;
        -:25181:    }
        -:25182:
        1:25183:  return binding->dirname;
        -:25184:}
        -:25185:
        -:25186:#ifdef _LIBC
        -:25187:/* Alias for function name in GNU C Library.  */
        -:25188:#endif
        -:25189:
        -:25190:/* End of bindtextdom.c */
        -:25191:
        -:25192:/* Begin of dgettext.c */
        -:25193:
        -:25194:/* Implementation of the dgettext(3) function
        -:25195:   Copyright (C) 1995, 1996, 1997 Free Software Foundation, Inc.  */
        -:25196:
        -:25197:#if defined HAVE_LOCALE_H || defined _LIBC
        -:25198:# include <locale.h>
        -:25199:#undef stderr
        -:25200:#define stderr stdout
        -:25201:#endif
        -:25202:
        -:25203:#ifdef _LIBC
        -:25204:#else
        -:25205:#endif
        -:25206:
        -:25207:/* Names for the libintl functions are a problem.  They must not clash
        -:25208:   with existing names and they should follow ANSI C.  But this source
        -:25209:   code is also used in GNU C Library where the names have a __
        -:25210:   prefix.  So we have to make a difference here.  */
        -:25211:#ifdef _LIBC
        -:25212:# define DGETTEXT __dgettext
        -:25213:# define DCGETTEXT __dcgettext
        -:25214:#else
        -:25215:# define DGETTEXT dgettext__
        -:25216:# define DCGETTEXT dcgettext__
        -:25217:#endif
        -:25218:
        -:25219:/* Look up MSGID in the DOMAINNAME message catalog of the current
        -:25220:   LC_MESSAGES locale.  */
        -:25221:static char *
function dgettext__ called 0 returned 0% blocks executed 0%
    #####:25222:DGETTEXT (domainname, msgid)
        -:25223:     const char *domainname;
        -:25224:     const char *msgid;
        -:25225:{
    #####:25226:  return DCGETTEXT (domainname, msgid, LC_MESSAGES);
call    0 never executed
        -:25227:}
        -:25228:
        -:25229:#ifdef _LIBC
        -:25230:/* Alias for function name in GNU C Library.  */
        -:25231:#endif
        -:25232:
        -:25233:/* End of dgettext.c */
        -:25234:
        -:25235:/* Begin of gettext.c */
        -:25236:
        -:25237:/* Implementation of gettext(3) function.
        -:25238:   Copyright (C) 1995, 1997 Free Software Foundation, Inc.  */
        -:25239:
        -:25240:#ifdef _LIBC
        -:25241:# define __need_NULL
        -:25242:# include <stddef.h>
        -:25243:#undef stderr
        -:25244:#define stderr stdout
        -:25245:#else
        -:25246:# ifdef STDC_HEADERS
        -:25247:#  include <stdlib.h>		/* Just for NULL.  */
        -:25248:#undef stderr
        -:25249:#define stderr stdout
        -:25250:# else
        -:25251:#  ifdef HAVE_STRING_H
        -:25252:#  else
        -:25253:#   define NULL ((void *) 0)
        -:25254:#  endif
        -:25255:# endif
        -:25256:#endif
        -:25257:
        -:25258:#ifdef _LIBC
        -:25259:#else
        -:25260:#endif
        -:25261:
        -:25262:/* Names for the libintl functions are a problem.  They must not clash
        -:25263:   with existing names and they should follow ANSI C.  But this source
        -:25264:   code is also used in GNU C Library where the names have a __
        -:25265:   prefix.  So we have to make a difference here.  */
        -:25266:#ifdef _LIBC
        -:25267:# define GETTEXT __gettext
        -:25268:# define DGETTEXT __dgettext
        -:25269:#else
        -:25270:# define GETTEXT gettext__
        -:25271:# define DGETTEXT dgettext__
        -:25272:#endif
        -:25273:
        -:25274:/* Look up MSGID in the current default message catalog for the current
        -:25275:   LC_MESSAGES locale.  If not found, returns MSGID itself (the default
        -:25276:   text).  */
        -:25277:static char *
function gettext__ called 0 returned 0% blocks executed 0%
    #####:25278:GETTEXT (msgid)
        -:25279:     const char *msgid;
        -:25280:{
    #####:25281:  return DGETTEXT (NULL, msgid);
call    0 never executed
        -:25282:}
        -:25283:
        -:25284:#ifdef _LIBC
        -:25285:/* Alias for function name in GNU C Library.  */
        -:25286:#endif
        -:25287:
        -:25288:/* End of gettext.c */
        -:25289:
        -:25290:/* Begin of textdomain.c */
        -:25291:
        -:25292:/* Implementation of the textdomain(3) function.
        -:25293:   Copyright (C) 1995, 1996, 1997, 1998 Free Software Foundation, Inc.
        -:25294:   Written by Ulrich Drepper <drepper@gnu.ai.mit.edu>, 1995.  */
        -:25295:
        -:25296:#if defined STDC_HEADERS || defined _LIBC
        -:25297:#endif
        -:25298:
        -:25299:#if defined STDC_HEADERS || defined HAVE_STRING_H || defined _LIBC
        -:25300:#else
        -:25301:# ifndef memcpy
        -:25302:#  define memcpy(Dst, Src, Num) bcopy (Src, Dst, Num)
        -:25303:# endif
        -:25304:#endif
        -:25305:
        -:25306:#ifdef _LIBC
        -:25307:#else
        -:25308:#endif
        -:25309:
        -:25310:/* Name of the default text domain.  */
        -:25311:/* static const char _nl_default_default_domain[]; */
        -:25312:
        -:25313:/* Default text domain in which entries for gettext(3) are to be found.  */
        -:25314:/* static const char *_nl_current_default_domain; */
        -:25315:
        -:25316:/* Names for the libintl functions are a problem.  They must not clash
        -:25317:   with existing names and they should follow ANSI C.  But this source
        -:25318:   code is also used in GNU C Library where the names have a __
        -:25319:   prefix.  So we have to make a difference here.  */
        -:25320:#ifdef _LIBC
        -:25321:# define TEXTDOMAIN __textdomain
        -:25322:# ifndef strdup
        -:25323:#  define strdup(str) __strdup (str)
        -:25324:# endif
        -:25325:#else
        -:25326:# define TEXTDOMAIN textdomain__
        -:25327:#endif
        -:25328:
        -:25329:/* Set the current default message catalog to DOMAINNAME.
        -:25330:   If DOMAINNAME is null, return the current default.
        -:25331:   If DOMAINNAME is "", reset to the default of "messages".  */
        -:25332:static char *
function textdomain__ called 1 returned 100% blocks executed 70%
        1:25333:TEXTDOMAIN (domainname)
        -:25334:     const char *domainname;
        -:25335:{
        -:25336:  char *old;
        -:25337:
        -:25338:  /* A NULL pointer requests the current setting.  */
        1:25339:  if (domainname == NULL)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:25340:    return (char *) _nl_current_default_domain;
        -:25341:
        1:25342:  old = (char *) _nl_current_default_domain;
        -:25343:
        -:25344:  /* If domain name is the null string set to default domain "messages".  */
        1:25345:  if (domainname[0] == '\0'
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:25346:      || strcmp (domainname, _nl_default_default_domain) == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:25347:    _nl_current_default_domain = _nl_default_default_domain;
        -:25348:  else
        -:25349:    {
        -:25350:      /* If the following malloc fails `_nl_current_default_domain'
        -:25351:	 will be NULL.  This value will be returned and so signals we
        -:25352:	 are out of core.  */
        -:25353:#if defined _LIBC || defined HAVE_STRDUP
        1:25354:      _nl_current_default_domain = strdup (domainname);
        -:25355:#else
        -:25356:      size_t len = strlen (domainname) + 1;
        -:25357:      char *cp = (char *) malloc (len);
        -:25358:      if (cp != NULL)
        -:25359:	memcpy (cp, domainname, len);
        -:25360:      _nl_current_default_domain = cp;
        -:25361:#endif
        -:25362:    }
        -:25363:
        1:25364:  if (old != _nl_default_default_domain)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:25365:    free (old);
        -:25366:
        1:25367:  return (char *) _nl_current_default_domain;
        -:25368:}
        -:25369:
        -:25370:#ifdef _LIBC
        -:25371:/* Alias for function name in GNU C Library.  */
        -:25372:#endif
        -:25373:
        -:25374:/* End of textdomain.c */
        -:25375:
        -:25376:/* Begin of intl-compat.c */
        -:25377:
        -:25378:/* intl-compat.c - Stub functions to call gettext functions from GNU gettext
        -:25379:   Library.
        -:25380:   Copyright (C) 1995 Software Foundation, Inc.  */
        -:25381:
        -:25382:#undef gettext
        -:25383:#undef dgettext
        -:25384:#undef dcgettext
        -:25385:#undef textdomain
        -:25386:#undef bindtextdomain
        -:25387:
        -:25388:char *
function bindtextdomain called 1 returned 100% blocks executed 100%
        1:25389:bindtextdomain (domainname, dirname)
        -:25390:     const char *domainname;
        -:25391:     const char *dirname;
        -:25392:{
        1:25393:  return bindtextdomain__ (domainname, dirname);
call    0 returned 1
        -:25394:}
        -:25395:
        -:25396:char *
function dcgettext called 1007 returned 100% blocks executed 100%
     1007:25397:dcgettext (domainname, msgid, category)
        -:25398:     const char *domainname;
        -:25399:     const char *msgid;
        -:25400:     int category;
        -:25401:{
     1007:25402:  return dcgettext__ (domainname, msgid, category);
call    0 returned 1007
        -:25403:}
        -:25404:
        -:25405:char *
function dgettext called 0 returned 0% blocks executed 0%
    #####:25406:dgettext (domainname, msgid)
        -:25407:     const char *domainname;
        -:25408:     const char *msgid;
        -:25409:{
    #####:25410:  return dgettext__ (domainname, msgid);
call    0 never executed
        -:25411:}
        -:25412:
        -:25413:char *
function gettext called 0 returned 0% blocks executed 0%
    #####:25414:gettext (msgid)
        -:25415:     const char *msgid;
        -:25416:{
    #####:25417:  return gettext__ (msgid);
call    0 never executed
        -:25418:}
        -:25419:
        -:25420:char *
function textdomain called 1 returned 100% blocks executed 100%
        1:25421:textdomain (domainname)
        -:25422:     const char *domainname;
        -:25423:{
        1:25424:  return textdomain__ (domainname);
call    0 returned 1
        -:25425:}
        -:25426:
        -:25427:/* End of intl-compat.c */
        -:25428:
        -:25429:
