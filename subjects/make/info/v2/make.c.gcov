        -:    0:Source:make.c
        -:    0:Graph:make.gcno
        -:    0:Data:make.gcda
        -:    0:Runs:796
        -:    1:#include "FaultSeeds.h"
        -:    2:/* modification by J. Ruthruff, 8/25 */
        -:    3:#define HAVE_CONFIG_H
        -:    4:#define LIBDIR "/usr/local/lib"
        -:    5:#define INCLUDEDIR "/usr/local/include"
        -:    6:#define _LARGEFILE_SOURCE
        -:    7:#define _FILE_OFFSET_BITS 64
        -:    8:
        -:    9:#undef stderr
        -:   10:#define stderr stdout
        -:   11:
        -:   12:/*************************************************************
        -:   13:  ============================================================
        -:   14:  ************************************************************
        -:   15:  ============================================================
        -:   16:  ************************************************************
        -:   17:                         main.c
        -:   18:  ************************************************************
        -:   19:  ============================================================
        -:   20:  ************************************************************
        -:   21:  ============================================================
        -:   22:  *************************************************************/
        -:   23:
        -:   24:/* Argument parsing and main program of GNU Make.
        -:   25:Copyright (C) 1988,89,90,91,94,95,96,97,98 Free Software Foundation, Inc.
        -:   26:This file is part of GNU Make.
        -:   27:
        -:   28:GNU Make is free software; you can redistribute it and/or modify
        -:   29:it under the terms of the GNU General Public License as published by
        -:   30:the Free Software Foundation; either version 2, or (at your option)
        -:   31:any later version.
        -:   32:
        -:   33:GNU Make is distributed in the hope that it will be useful,
        -:   34:but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   35:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   36:GNU General Public License for more details.
        -:   37:
        -:   38:You should have received a copy of the GNU General Public License
        -:   39:along with GNU Make; see the file COPYING.  If not, write to
        -:   40:the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
        -:   41:
        -:   42:
        -:   43:#include "make.h"
        -:   44:#include "dep.h"
        -:   45:#include "filedef.h"
        -:   46:#include "variable.h"
        -:   47:#include "job.h"
        -:   48:#include "commands.h"
        -:   49:#include "getopt.h"
        -:   50:#include <assert.h>
        -:   51:#include "glob.h"
        -:   52:#include "rule.h"
        -:   53:#include "config.h"
        -:   54:#include <fnmatch.h>
        -:   55:#include <stdio.h>
        -:   56:#include <sys/types.h>		/* Some systems need this for <signal.h>.  */
        -:   57:#include <signal.h>
        -:   58:#include "signame.h"
        -:   59:#include "getopt.h"
        -:   60:#include <string.h>
        -:   61:#undef stderr
        -:   62:#define stderr stdout
        -:   63:
        -:   64:#define ino_t_int longlong_t
        -:   65:#define dev_t_int long
        -:   66:#define off_t_int longlong_t
        -:   67:
        -:   68:ino_t_int ZERO_ino_t = 0;
        -:   69:dev_t_int ZERO_dev_t = 0;
        -:   70:off_t_int ZERO_off_t = 0;
        -:   71:off_t_int ZERO_L_off_t = 0L;
        -:   72:
function int_to_off_t called 0 returned 0% blocks executed 0%
    #####:   73:off_t int_to_off_t(long arg)
        -:   74:{
        -:   75:  off_t_int x;
        -:   76:  off_t y;
        -:   77:  memset(&x, '\0', sizeof(x));
    #####:   78:  memcpy(&x, &arg, sizeof(arg));
    #####:   79:  memcpy(&y, &x, sizeof(off_t));
    #####:   80:  return y;
        -:   81:}
        -:   82:
function ino_t_to_int called 391 returned 100% blocks executed 100%
      391:   83:ino_t_int ino_t_to_int(ino_t x)
        -:   84:{
        -:   85:  ino_t_int y;
      391:   86:  memcpy(&y, &x, sizeof(ino_t));
      391:   87:  return y;
        -:   88:}
        -:   89:
function off_t_to_int called 0 returned 0% blocks executed 0%
    #####:   90:off_t_int off_t_to_int(off_t x)
        -:   91:{
        -:   92:  off_t_int y;
    #####:   93:  memcpy(&y, &x, sizeof(off_t));
    #####:   94:  return y;
        -:   95:}
        -:   96:
function dev_t_to_int called 385 returned 100% blocks executed 100%
      385:   97:dev_t_int dev_t_to_int(dev_t x)
        -:   98:{
        -:   99:  dev_t_int y;
      385:  100:  memcpy(&y, &x, sizeof(dev_t));
      385:  101:  return y;
        -:  102:}
        -:  103:
function ino_t_equal called 3 returned 100% blocks executed 100%
        3:  104:int ino_t_equal(ino_t_int x, ino_t_int y)
        -:  105:{
        3:  106:  return (memcmp(&x, &y, sizeof(ino_t_int)));
        -:  107:}
        -:  108:
function off_t_equal called 0 returned 0% blocks executed 0%
    #####:  109:int off_t_equal(off_t_int x, off_t_int y)
        -:  110:{
    #####:  111:  return (memcmp(&x, &y, sizeof(off_t_int)));
        -:  112:}
        -:  113:
function dev_t_equal called 0 returned 0% blocks executed 0%
    #####:  114:int dev_t_equal(dev_t_int x, dev_t_int y)
        -:  115:{
    #####:  116:  return (memcmp(&x, &y, sizeof(dev_t_int)));
        -:  117:}
        -:  118:
        -:  119:/* #define ino_t unsigned long int */
        -:  120:
        -:  121:#ifdef _AMIGA
        -:  122:#   include <dos/dos.h>
        -:  123:#   include <proto/dos.h>
        -:  124:#undef stderr
        -:  125:#define stderr stdout
        -:  126:#endif
        -:  127:#ifdef WINDOWS32
        -:  128:#include <windows.h>
        -:  129:#include "pathstuff.h"
        -:  130:#undef stderr
        -:  131:#define stderr stdout
        -:  132:#endif
        -:  133:
        -:  134:#ifdef _AMIGA
        -:  135:int __stack = 20000; /* Make sure we have 20K of stack space */
        -:  136:#endif
        -:  137:
        -:  138:extern void init_dir PARAMS ((void));
        -:  139:extern void remote_setup PARAMS ((void));
        -:  140:extern void remote_cleanup PARAMS ((void));
        -:  141:extern RETSIGTYPE fatal_error_signal PARAMS ((int sig));
        -:  142:extern RETSIGTYPE child_handler PARAMS ((int sig));
        -:  143:
        -:  144:extern void print_variable_data_base PARAMS ((void));
        -:  145:extern void print_dir_data_base PARAMS ((void));
        -:  146:extern void print_rule_data_base PARAMS ((void));
        -:  147:extern void print_file_data_base PARAMS ((void));
        -:  148:extern void print_vpath_data_base PARAMS ((void));
        -:  149:
        -:  150:#ifndef	HAVE_UNISTD_H
        -:  151:extern int chdir ();
        -:  152:#endif
        -:  153:#ifndef	STDC_HEADERS
        -:  154:#ifndef	sun			/* Sun has an incorrect decl in a header.  */
        -:  155:extern void exit ();
        -:  156:#endif
        -:  157:extern double atof ();
        -:  158:#endif
        -:  159:extern char *mktemp ();
        -:  160:
        -:  161:static void print_data_base PARAMS((void));
        -:  162:static void print_version PARAMS ((void));
        -:  163:static void decode_switches PARAMS ((int argc, char **argv, int env));
        -:  164:static void decode_env_switches PARAMS ((char *envar, unsigned int len));
        -:  165:static void define_makeflags PARAMS ((int all, int makefile));
        -:  166:static char *quote_as_word PARAMS ((char *out, char *in, int double_dollars));
        -:  167:
        -:  168:/* The structure that describes an accepted command switch.  */
        -:  169:
        -:  170:struct command_switch
        -:  171:  {
        -:  172:    char c;			/* The switch character.  */
        -:  173:
        -:  174:    enum			/* Type of the value.  */
        -:  175:      {
        -:  176:	flag,			/* Turn int flag on.  */
        -:  177:	flag_off,		/* Turn int flag off.  */
        -:  178:	string,			/* One string per switch.  */
        -:  179:	positive_int,		/* A positive integer.  */
        -:  180:	floating,		/* A floating-point number (double).  */
        -:  181:	ignore			/* Ignored.  */
        -:  182:      } type;
        -:  183:
        -:  184:    char *value_ptr;	/* Pointer to the value-holding variable.  */
        -:  185:
        -:  186:    unsigned int env:1;		/* Can come from MAKEFLAGS.  */
        -:  187:    unsigned int toenv:1;	/* Should be put in MAKEFLAGS.  */
        -:  188:    unsigned int no_makefile:1;	/* Don't propagate when remaking makefiles.  */
        -:  189:
        -:  190:    char *noarg_value;	/* Pointer to value used if no argument is given.  */
        -:  191:    char *default_value;/* Pointer to default value.  */
        -:  192:
        -:  193:    char *long_name;		/* Long option name.  */
        -:  194:    char *argdesc;		/* Descriptive word for argument.  */
        -:  195:    char *description;		/* Description for usage message.  */
        -:  196:  };
        -:  197:
        -:  198:
        -:  199:/* The structure used to hold the list of strings given
        -:  200:   in command switches of a type that takes string arguments.  */
        -:  201:
        -:  202:struct stringlist
        -:  203:  {
        -:  204:    char **list;	/* Nil-terminated list of strings.  */
        -:  205:    unsigned int idx;	/* Index into above.  */
        -:  206:    unsigned int max;	/* Number of pointers allocated.  */
        -:  207:  };
        -:  208:
        -:  209:
        -:  210:/* The recognized command switches.  */
        -:  211:
        -:  212:/* Nonzero means do not print commands to be executed (-s).  */
        -:  213:
        -:  214:int silent_flag;
        -:  215:
        -:  216:/* Nonzero means just touch the files
        -:  217:   that would appear to need remaking (-t)  */
        -:  218:
        -:  219:int touch_flag;
        -:  220:
        -:  221:/* Nonzero means just print what commands would need to be executed,
        -:  222:   don't actually execute them (-n).  */
        -:  223:
        -:  224:int just_print_flag;
        -:  225:
        -:  226:/* Print debugging trace info (-d).  */
        -:  227:
        -:  228:int debug_flag = 0;
        -:  229:
        -:  230:#ifdef WINDOWS32
        -:  231:/* Suspend make in main for a short time to allow debugger to attach */
        -:  232:
        -:  233:int suspend_flag = 0;
        -:  234:#endif
        -:  235:
        -:  236:/* Environment variables override makefile definitions.  */
        -:  237:
        -:  238:int env_overrides = 0;
        -:  239:
        -:  240:/* Nonzero means ignore status codes returned by commands
        -:  241:   executed to remake files.  Just treat them all as successful (-i).  */
        -:  242:
        -:  243:int ignore_errors_flag = 0;
        -:  244:
        -:  245:/* Nonzero means don't remake anything, just print the data base
        -:  246:   that results from reading the makefile (-p).  */
        -:  247:
        -:  248:int print_data_base_flag = 0;
        -:  249:
        -:  250:/* Nonzero means don't remake anything; just return a nonzero status
        -:  251:   if the specified targets are not up to date (-q).  */
        -:  252:
        -:  253:int question_flag = 0;
        -:  254:
        -:  255:/* Nonzero means do not use any of the builtin rules (-r).  */
        -:  256:
        -:  257:int no_builtin_rules_flag = 0;
        -:  258:
        -:  259:/* Nonzero means keep going even if remaking some file fails (-k).  */
        -:  260:
        -:  261:int keep_going_flag;
        -:  262:int default_keep_going_flag = 0;
        -:  263:
        -:  264:/* Nonzero means print directory before starting and when done (-w).  */
        -:  265:
        -:  266:int print_directory_flag = 0;
        -:  267:
        -:  268:/* Nonzero means ignore print_directory_flag and never print the directory.
        -:  269:   This is necessary because print_directory_flag is set implicitly.  */
        -:  270:
        -:  271:int inhibit_print_directory_flag = 0;
        -:  272:
        -:  273:/* Nonzero means print version information.  */
        -:  274:
        -:  275:int print_version_flag = 0;
        -:  276:
        -:  277:/* List of makefiles given with -f switches.  */
        -:  278:
        -:  279:static struct stringlist *makefiles = 0;
        -:  280:
        -:  281:/* Number of job slots (commands that can be run at once).  */
        -:  282:
        -:  283:unsigned int job_slots = 1;
        -:  284:unsigned int default_job_slots = 1;
        -:  285:
        -:  286:/* Value of job_slots that means no limit.  */
        -:  287:
        -:  288:static unsigned int inf_jobs = 0;
        -:  289:
        -:  290:/* Maximum load average at which multiple jobs will be run.
        -:  291:   Negative values mean unlimited, while zero means limit to
        -:  292:   zero load (which could be useful to start infinite jobs remotely
        -:  293:   but one at a time locally).  */
        -:  294:#ifndef NO_FLOAT
        -:  295:double max_load_average = -1.0;
        -:  296:double default_load_average = -1.0;
        -:  297:#else
        -:  298:int max_load_average = -1;
        -:  299:int default_load_average = -1;
        -:  300:#endif
        -:  301:
        -:  302:/* List of directories given with -C switches.  */
        -:  303:
        -:  304:static struct stringlist *directories = 0;
        -:  305:
        -:  306:/* List of include directories given with -I switches.  */
        -:  307:
        -:  308:static struct stringlist *include_directories = 0;
        -:  309:
        -:  310:/* List of files given with -o switches.  */
        -:  311:
        -:  312:static struct stringlist *old_files = 0;
        -:  313:
        -:  314:/* List of files given with -W switches.  */
        -:  315:
        -:  316:static struct stringlist *new_files = 0;
        -:  317:
        -:  318:/* If nonzero, we should just print usage and exit.  */
        -:  319:
        -:  320:static int print_usage_flag = 0;
        -:  321:
        -:  322:/* If nonzero, we should print a warning message
        -:  323:   for each reference to an undefined variable.  */
        -:  324:
        -:  325:int warn_undefined_variables_flag;
        -:  326:
        -:  327:/* The table of command switches.  */
        -:  328:
        -:  329:static const struct command_switch switches[] =
        -:  330:  {
        -:  331:    { 'b', ignore, 0, 0, 0, 0, 0, 0,
        -:  332:	0, 0,
        -:  333:	"Ignored for compatibility" },
        -:  334:    { 'C', string, (char *) &directories, 0, 0, 0, 0, 0,
        -:  335:	"directory", "DIRECTORY",
        -:  336:	"Change to DIRECTORY before doing anything" },
        -:  337:    { 'd', flag, (char *) &debug_flag, 1, 1, 0, 0, 0,
        -:  338:	"debug", 0,
        -:  339:	"Print lots of debugging information" },
        -:  340:#ifdef WINDOWS32
        -:  341:    { 'D', flag, (char *) &suspend_flag, 1, 1, 0, 0, 0,
        -:  342:        "suspend-for-debug", 0,
        -:  343:        "Suspend process to allow a debugger to attach" },
        -:  344:#endif
        -:  345:    { 'e', flag, (char *) &env_overrides, 1, 1, 0, 0, 0,
        -:  346:	"environment-overrides", 0,
        -:  347:	"Environment variables override makefiles" },
        -:  348:    { 'f', string, (char *) &makefiles, 0, 0, 0, 0, 0,
        -:  349:	"file", "FILE",
        -:  350:	"Read FILE as a makefile" },
        -:  351:    { 'h', flag, (char *) &print_usage_flag, 0, 0, 0, 0, 0,
        -:  352:	"help", 0,
        -:  353:	"Print this message and exit" },
        -:  354:    { 'i', flag, (char *) &ignore_errors_flag, 1, 1, 0, 0, 0,
        -:  355:	"ignore-errors", 0,
        -:  356:	"Ignore errors from commands" },
        -:  357:    { 'I', string, (char *) &include_directories, 1, 1, 0, 0, 0,
        -:  358:	"include-dir", "DIRECTORY",
        -:  359:	"Search DIRECTORY for included makefiles" },
        -:  360:    { 'j', positive_int, (char *) &job_slots, 1, 1, 0,
        -:  361:	(char *) &inf_jobs, (char *) &default_job_slots,
        -:  362:	"jobs", "N",
        -:  363:	"Allow N jobs at once; infinite jobs with no arg" },
        -:  364:    { 'k', flag, (char *) &keep_going_flag, 1, 1, 0,
        -:  365:	0, (char *) &default_keep_going_flag,
        -:  366:	"keep-going", 0,
        -:  367:	"Keep going when some targets can't be made" },
        -:  368:#ifndef NO_FLOAT
        -:  369:    { 'l', floating, (char *) &max_load_average, 1, 1, 0,
        -:  370:	(char *) &default_load_average, (char *) &default_load_average,
        -:  371:	"load-average", "N",
        -:  372:	"Don't start multiple jobs unless load is below N" },
        -:  373:#else
        -:  374:    { 'l', positive_int, (char *) &max_load_average, 1, 1, 0,
        -:  375:	(char *) &default_load_average, (char *) &default_load_average,
        -:  376:	"load-average", "N",
        -:  377:	"Don't start multiple jobs unless load is below N" },
        -:  378:#endif
        -:  379:    { 'm', ignore, 0, 0, 0, 0, 0, 0,
        -:  380:	0, 0,
        -:  381:	"-b" },
        -:  382:    { 'n', flag, (char *) &just_print_flag, 1, 1, 1, 0, 0,
        -:  383:	"just-print", 0,
        -:  384:	"Don't actually run any commands; just print them" },
        -:  385:    { 'o', string, (char *) &old_files, 0, 0, 0, 0, 0,
        -:  386:	"old-file", "FILE",
        -:  387:	"Consider FILE to be very old and don't remake it" },
        -:  388:    { 'p', flag, (char *) &print_data_base_flag, 1, 1, 0, 0, 0,
        -:  389:	"print-data-base", 0,
        -:  390:	"Print make's internal database" },
        -:  391:    { 'q', flag, (char *) &question_flag, 1, 1, 1, 0, 0,
        -:  392:	"question", 0,
        -:  393:	"Run no commands; exit status says if up to date" },
        -:  394:    { 'r', flag, (char *) &no_builtin_rules_flag, 1, 1, 0, 0, 0,
        -:  395:	"no-builtin-rules", 0,
        -:  396:	"Disable the built-in implicit rules" },
        -:  397:    { 's', flag, (char *) &silent_flag, 1, 1, 0, 0, 0,
        -:  398:	"silent", 0,
        -:  399:	"Don't echo commands" },
        -:  400:    { 'S', flag_off, (char *) &keep_going_flag, 1, 1, 0,
        -:  401:	0, (char *) &default_keep_going_flag,
        -:  402:	"no-keep-going", 0,
        -:  403:	"Turns off -k" },
        -:  404:    { 't', flag, (char *) &touch_flag, 1, 1, 1, 0, 0,
        -:  405:	"touch", 0,
        -:  406:	"Touch targets instead of remaking them" },
        -:  407:    { 'v', flag, (char *) &print_version_flag, 1, 1, 0, 0, 0,
        -:  408:	"version", 0,
        -:  409:	"Print the version number of make and exit" },
        -:  410:    { 'w', flag, (char *) &print_directory_flag, 1, 1, 0, 0, 0,
        -:  411:	"print-directory", 0,
        -:  412:	"Print the current directory" },
        -:  413:    { 2, flag, (char *) &inhibit_print_directory_flag, 1, 1, 0, 0, 0,
        -:  414:	"no-print-directory", 0,
        -:  415:	"Turn off -w, even if it was turned on implicitly" },
        -:  416:    { 'W', string, (char *) &new_files, 0, 0, 0, 0, 0,
        -:  417:	"what-if", "FILE",
        -:  418:	"Consider FILE to be infinitely new" },
        -:  419:    { 3, flag, (char *) &warn_undefined_variables_flag, 1, 1, 0, 0, 0,
        -:  420:	"warn-undefined-variables", 0,
        -:  421:	"Warn when an undefined variable is referenced" },
        -:  422:    { '\0', }
        -:  423:  };
        -:  424:
        -:  425:/* Secondary long names for options.  */
        -:  426:
        -:  427:static struct option long_option_aliases[] =
        -:  428:  {
        -:  429:    { "quiet",		no_argument,		0, 's' },
        -:  430:    { "stop",		no_argument,		0, 'S' },
        -:  431:    { "new-file",	required_argument,	0, 'W' },
        -:  432:    { "assume-new",	required_argument,	0, 'W' },
        -:  433:    { "assume-old",	required_argument,	0, 'o' },
        -:  434:    { "max-load",	optional_argument,	0, 'l' },
        -:  435:    { "dry-run",	no_argument,		0, 'n' },
        -:  436:    { "recon",		no_argument,		0, 'n' },
        -:  437:    { "makefile",	required_argument,	0, 'f' },
        -:  438:  };
        -:  439:
        -:  440:/* The usage message prints the descriptions of options starting in
        -:  441:   this column.  Make sure it leaves enough room for the longest
        -:  442:   description to fit in less than 80 characters.  */
        -:  443:
        -:  444:#define	DESCRIPTION_COLUMN	30
        -:  445:
        -:  446:/* List of goal targets.  */
        -:  447:
        -:  448:static struct dep *goals, *lastgoal;
        -:  449:
        -:  450:/* List of variables which were defined on the command line
        -:  451:   (or, equivalently, in MAKEFLAGS).  */
        -:  452:
        -:  453:struct command_variable
        -:  454:  {
        -:  455:    struct command_variable *next;
        -:  456:    struct variable *variable;
        -:  457:  };
        -:  458:static struct command_variable *command_variables;
        -:  459:
        -:  460:/* The name we were invoked with.  */
        -:  461:
        -:  462:char *program;
        -:  463:
        -:  464:/* Our current directory before processing any -C options.  */
        -:  465:
        -:  466:char *directory_before_chdir;
        -:  467:
        -:  468:/* Our current directory after processing all -C options.  */
        -:  469:
        -:  470:char *starting_directory;
        -:  471:
        -:  472:/* Value of the MAKELEVEL variable at startup (or 0).  */
        -:  473:
        -:  474:unsigned int makelevel;
        -:  475:
        -:  476:/* First file defined in the makefile whose name does not
        -:  477:   start with `.'.  This is the default to remake if the
        -:  478:   command line does not specify.  */
        -:  479:
        -:  480:struct file *default_goal_file;
        -:  481:
        -:  482:/* Pointer to structure for the file .DEFAULT
        -:  483:   whose commands are used for any file that has none of its own.
        -:  484:   This is zero if the makefiles do not define .DEFAULT.  */
        -:  485:
        -:  486:struct file *default_file;
        -:  487:
        -:  488:/* Nonzero if we have seen the magic `.POSIX' target.
        -:  489:   This turns on pedantic compliance with POSIX.2.  */
        -:  490:
        -:  491:int posix_pedantic;
        -:  492:
        -:  493:/* Nonzero if some rule detected clock skew; we keep track so (a) we only
        -:  494:   print one warning about it during the run, and (b) we can print a final
        -:  495:   warning at the end of the run. */
        -:  496:
        -:  497:int clock_skew_detected;
        -:  498:
        -:  499:/* Mask of signals that are being caught with fatal_error_signal.  */
        -:  500:
        -:  501:#ifdef	POSIX
        -:  502:sigset_t fatal_signal_set;
        -:  503:#else
        -:  504:#ifdef	HAVE_SIGSETMASK
        -:  505:int fatal_signal_mask;
        -:  506:#endif
        -:  507:#endif
        -:  508:
        -:  509:static struct file *
function enter_command_line_file called 5 returned 100% blocks executed 42%
        5:  510:enter_command_line_file (name)
        -:  511:     char *name;
        -:  512:{
        5:  513:  if (name[0] == '\0')
branch  0 taken 0 (fallthrough)
branch  1 taken 5
    #####:  514:    fatal ("empty string invalid as file name");
call    0 never executed
        -:  515:
        5:  516:  if (name[0] == '~')
branch  0 taken 0 (fallthrough)
branch  1 taken 5
        -:  517:    {
    #####:  518:      char *expanded = tilde_expand (name);
call    0 never executed
    #####:  519:      if (expanded != 0)
branch  0 never executed
branch  1 never executed
    #####:  520:	name = expanded;	/* Memory leak; I don't care.  */
        -:  521:    }
        -:  522:
        -:  523:  /* This is also done in parse_file_seq, so this is redundant
        -:  524:     for names read from makefiles.  It is here for names passed
        -:  525:     on the command line.  */
       5*:  526:  while (name[0] == '.' && name[1] == '/' && name[2] != '\0')
branch  0 taken 0 (fallthrough)
branch  1 taken 5
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:  527:    {
    #####:  528:      name += 2;
    #####:  529:      while (*name == '/')
branch  0 never executed
branch  1 never executed
        -:  530:	/* Skip following slashes: ".//foo" is "foo", not "/foo".  */
    #####:  531:	++name;
        -:  532:    }
        -:  533:
        5:  534:  if (*name == '\0')
branch  0 taken 0 (fallthrough)
branch  1 taken 5
        -:  535:    {
        -:  536:      /* It was all slashes!  Move back to the dot and truncate
        -:  537:	 it after the first slash, so it becomes just "./".  */
        -:  538:      do
    #####:  539:	--name;
    #####:  540:      while (name[0] != '.');
branch  0 never executed
branch  1 never executed
    #####:  541:      name[2] = '\0';
        -:  542:    }
        -:  543:
        5:  544:  return enter_file (savestring (name, strlen (name)));
call    0 returned 5
call    1 returned 5
        -:  545:}
        -:  546:
        -:  547:/* Toggle -d on receipt of SIGUSR1.  */
        -:  548:
        -:  549:static RETSIGTYPE
function debug_signal_handler called 0 returned 0% blocks executed 0%
    #####:  550:debug_signal_handler (sig)
        -:  551:     int sig;
        -:  552:{
    #####:  553:  debug_flag = ! debug_flag;
    #####:  554:}
        -:  555:
        -:  556:#ifdef WINDOWS32
        -:  557:/*
        -:  558: * HANDLE runtime exceptions by avoiding a requestor on the GUI. Capture
        -:  559: * exception and print it to stderr instead.
        -:  560: *
        -:  561: * If debug_flag not set, just print a simple message and exit.
        -:  562: * If debug_flag set, print a more verbose message.
        -:  563: * If compiled for DEBUG, let exception pass through to GUI so that
        -:  564: *   debuggers can attach.
        -:  565: */
        -:  566:LONG WINAPI
        -:  567:handle_runtime_exceptions( struct _EXCEPTION_POINTERS *exinfo )
        -:  568:{
        -:  569:  PEXCEPTION_RECORD exrec = exinfo->ExceptionRecord;
        -:  570:  LPSTR cmdline = GetCommandLine();
        -:  571:  LPSTR prg = strtok(cmdline, " ");
        -:  572:  CHAR errmsg[1024];
        -:  573:#ifdef USE_EVENT_LOG
        -:  574:  HANDLE hEventSource;
        -:  575:  LPTSTR lpszStrings[1];
        -:  576:#endif
        -:  577:
        -:  578:  if (!debug_flag)
        -:  579:    {
        -:  580:      sprintf(errmsg, "%s: Interrupt/Exception caught ", prg);
        -:  581:      sprintf(&errmsg[strlen(errmsg)],
        -:  582:              "(code = 0x%x, addr = 0x%x)\r\n",
        -:  583:              exrec->ExceptionCode, exrec->ExceptionAddress);
        -:  584:      fprintf(stderr, errmsg);
        -:  585:      exit(255);
        -:  586:    }
        -:  587:
        -:  588:  sprintf(errmsg,
        -:  589:          "\r\nUnhandled exception filter called from program %s\r\n", prg);
        -:  590:  sprintf(&errmsg[strlen(errmsg)], "ExceptionCode = %x\r\n",
        -:  591:          exrec->ExceptionCode);
        -:  592:  sprintf(&errmsg[strlen(errmsg)], "ExceptionFlags = %x\r\n",
        -:  593:          exrec->ExceptionFlags);
        -:  594:  sprintf(&errmsg[strlen(errmsg)], "ExceptionAddress = %x\r\n",
        -:  595:          exrec->ExceptionAddress);
        -:  596:
        -:  597:  if (exrec->ExceptionCode == EXCEPTION_ACCESS_VIOLATION
        -:  598:      && exrec->NumberParameters >= 2)
        -:  599:    sprintf(&errmsg[strlen(errmsg)],
        -:  600:            "Access violation: %s operation at address %x\r\n",
        -:  601:            exrec->ExceptionInformation[0] ? "write": "read",
        -:  602:            exrec->ExceptionInformation[1]);
        -:  603:
        -:  604:  /* turn this on if we want to put stuff in the event log too */
        -:  605:#ifdef USE_EVENT_LOG
        -:  606:  hEventSource = RegisterEventSource(NULL, "GNU Make");
        -:  607:  lpszStrings[0] = errmsg;
        -:  608:
        -:  609:  if (hEventSource != NULL)
        -:  610:    {
        -:  611:      ReportEvent(hEventSource,         /* handle of event source */
        -:  612:                  EVENTLOG_ERROR_TYPE,  /* event type */
        -:  613:                  0,                    /* event category */
        -:  614:                  0,                    /* event ID */
        -:  615:                  NULL,                 /* current user's SID */
        -:  616:                  1,                    /* strings in lpszStrings */
        -:  617:                  0,                    /* no bytes of raw data */
        -:  618:                  lpszStrings,          /* array of error strings */
        -:  619:                  NULL);                /* no raw data */
        -:  620:
        -:  621:      (VOID) DeregisterEventSource(hEventSource);
        -:  622:    }
        -:  623:#endif
        -:  624:
        -:  625:  /* Write the error to stderr too */
        -:  626:  fprintf(stderr, errmsg);
        -:  627:
        -:  628:#ifdef DEBUG
        -:  629:  return EXCEPTION_CONTINUE_SEARCH;
        -:  630:#else
        -:  631:  exit(255);
        -:  632:#ifndef F_JR_1  /* seeded fault #1; J.Ruthruff */
        -:  633:  return (255); /* not reached */
        -:  634:#endif
        -:  635:#endif
        -:  636:}
        -:  637:
        -:  638:/*
        -:  639: * On WIN32 systems we don't have the luxury of a /bin directory that
        -:  640: * is mapped globally to every drive mounted to the system. Since make could
        -:  641: * be invoked from any drive, and we don't want to propogate /bin/sh
        -:  642: * to every single drive. Allow ourselves a chance to search for
        -:  643: * a value for default shell here (if the default path does not exist).
        -:  644: */
        -:  645:
        -:  646:int
        -:  647:find_and_set_default_shell(char *token)
        -:  648:{
        -:  649:  int sh_found = 0;
        -:  650:  char* search_token;
        -:  651:  PATH_VAR(sh_path);
        -:  652:  extern char *default_shell;
        -:  653:
        -:  654:  if (!token)
        -:  655:    search_token = default_shell;
        -:  656:  else
        -:  657:    search_token = token;
        -:  658:#ifndef F_JR_2  /* seeded fault #2; J.Ruthruff */
        -:  659:  if (!no_default_sh_exe &&
        -:  660:      (token == NULL || !strcmp(search_token, default_shell))) {
        -:  661:#else
        -:  662:  if (!no_default_sh_exe &&
        -:  663:      (token == NULL || strcmp(search_token, default_shell))) {
        -:  664:#endif
        -:  665:    sh_found = 1;
        -:  666:  } else if (file_exists_p(search_token)) {
        -:  667:    /* search token path was found */
        -:  668:    sprintf(sh_path, "%s", search_token);
        -:  669:    default_shell = strdup(w32ify(sh_path,0));
        -:  670:    if (debug_flag)
        -:  671:      printf("find_and_set_shell setting default_shell = %s\n", default_shell);
        -:  672:    sh_found = 1;
        -:  673:  } else {
        -:  674:    char *p;
        -:  675:    struct variable *v = lookup_variable ("Path", 4);
        -:  676:
        -:  677:    /*
        -:  678:     * Search Path for shell
        -:  679:     */
        -:  680:    if (v && v->value) {
        -:  681:      char *ep;
        -:  682:
        -:  683:      p  = v->value;
        -:  684:      ep = strchr(p, PATH_SEPARATOR_CHAR);
        -:  685:
        -:  686:      while (ep && *ep) {
        -:  687:        *ep = '\0';
        -:  688:
        -:  689:        if (dir_file_exists_p(p, search_token)) {
        -:  690:          sprintf(sh_path, "%s/%s", p, search_token);
        -:  691:          default_shell = strdup(w32ify(sh_path,0));
        -:  692:          sh_found = 1;
        -:  693:          *ep = PATH_SEPARATOR_CHAR;
        -:  694:
        -:  695:          /* terminate loop */
        -:  696:          p += strlen(p);
        -:  697:        } else {
        -:  698:          *ep = PATH_SEPARATOR_CHAR;
        -:  699:           p = ++ep;
        -:  700:        }
        -:  701:
        -:  702:        ep = strchr(p, PATH_SEPARATOR_CHAR);
        -:  703:      }
        -:  704:
        -:  705:      /* be sure to check last element of Path */
        -:  706:      if (p && *p && dir_file_exists_p(p, search_token)) {
        -:  707:          sprintf(sh_path, "%s/%s", p, search_token);
        -:  708:          default_shell = strdup(w32ify(sh_path,0));
        -:  709:          sh_found = 1;
        -:  710:      }
        -:  711:
        -:  712:      if (debug_flag && sh_found)
        -:  713:        printf("find_and_set_shell path search set default_shell = %s\n", default_shell);
        -:  714:    }
        -:  715:  }
        -:  716:
        -:  717:  /* naive test */
        -:  718:  if (!unixy_shell && sh_found &&
        -:  719:      (strstr(default_shell, "sh") || strstr(default_shell, "SH"))) {
        -:  720:    unixy_shell = 1;
        -:  721:    batch_mode_shell = 0;
        -:  722:  }
        -:  723:
        -:  724:#ifdef BATCH_MODE_ONLY_SHELL
        -:  725:  batch_mode_shell = 1;
        -:  726:#endif
        -:  727:
        -:  728:  return (sh_found);
        -:  729:}
        -:  730:#endif  /* WINDOWS32 */
        -:  731:
        -:  732:#ifdef  __MSDOS__
        -:  733:
        -:  734:static void
        -:  735:msdos_return_to_initial_directory ()
        -:  736:{
        -:  737:  if (directory_before_chdir)
        -:  738:    chdir (directory_before_chdir);
        -:  739:}
        -:  740:#endif
        -:  741:
        -:  742:#ifndef _AMIGA
        -:  743:int
function main called 793 returned 0% blocks executed 52%
      793:  744:main (argc, argv, envp)
        -:  745:     int argc;
        -:  746:     char **argv;
        -:  747:     char **envp;
        -:  748:#else
        -:  749:int main (int argc, char ** argv)
        -:  750:#endif
        -:  751:{
        -:  752:  static char *stdin_nm = 0;
        -:  753:  register struct file *f;
        -:  754:  register unsigned int i;
        -:  755:  char **p;
        -:  756:  struct dep *read_makefiles;
        -:  757:  PATH_VAR (current_directory);
        -:  758:#ifdef WINDOWS32
        -:  759:  char *unix_path = NULL;
        -:  760:  char *windows32_path = NULL;
        -:  761:
        -:  762:  SetUnhandledExceptionFilter(handle_runtime_exceptions);
        -:  763:
        -:  764:  /* start off assuming we have no shell */
        -:  765:  unixy_shell = 0;
        -:  766:  no_default_sh_exe = 1;
        -:  767:#endif
        -:  768:
      793:  769:  default_goal_file = 0;
      793:  770:  reading_filename = 0;
      793:  771:  reading_lineno_ptr = 0;
        -:  772:
        -:  773:#if defined (__MSDOS__) && !defined (_POSIX_SOURCE)
        -:  774:  /* Request the most powerful version of `system', to
        -:  775:     make up for the dumb default shell.  */
        -:  776:  __system_flags = (__system_redirect
        -:  777:		    | __system_use_shell
        -:  778:		    | __system_allow_multiple_cmds
        -:  779:		    | __system_allow_long_cmds
        -:  780:		    | __system_handle_null_commands
        -:  781:		    | __system_emulate_chdir);
        -:  782:
        -:  783:#endif
        -:  784:
        -:  785:#if !defined (HAVE_STRSIGNAL) && !defined (HAVE_SYS_SIGLIST)
        -:  786:  signame_init ();
        -:  787:#endif
        -:  788:
        -:  789:#ifdef	POSIX
      793:  790:  sigemptyset (&fatal_signal_set);
call    0 returned 793
        -:  791:#define	ADD_SIG(sig)	sigaddset (&fatal_signal_set, sig)
        -:  792:#else
        -:  793:#ifdef	HAVE_SIGSETMASK
        -:  794:  fatal_signal_mask = 0;
        -:  795:#define	ADD_SIG(sig)	fatal_signal_mask |= sigmask (sig)
        -:  796:#else
        -:  797:#define	ADD_SIG(sig)
        -:  798:#endif
        -:  799:#endif
        -:  800:
        -:  801:#define	FATAL_SIG(sig)							      \
        -:  802:  if (signal ((sig), fatal_error_signal) == SIG_IGN)			      \
        -:  803:    (void) signal ((sig), SIG_IGN);					      \
        -:  804:  else									      \
        -:  805:    ADD_SIG (sig);
        -:  806:
        -:  807:#ifdef SIGHUP
     793*:  808:  FATAL_SIG (SIGHUP);
call    0 returned 793
branch  1 taken 0 (fallthrough)
branch  2 taken 793
call    3 never executed
call    4 returned 793
        -:  809:#endif
        -:  810:#ifdef SIGQUIT
     793*:  811:  FATAL_SIG (SIGQUIT);
call    0 returned 793
branch  1 taken 0 (fallthrough)
branch  2 taken 793
call    3 never executed
call    4 returned 793
        -:  812:#endif
     793*:  813:  FATAL_SIG (SIGINT);
call    0 returned 793
branch  1 taken 0 (fallthrough)
branch  2 taken 793
call    3 never executed
call    4 returned 793
     793*:  814:  FATAL_SIG (SIGTERM);
call    0 returned 793
branch  1 taken 0 (fallthrough)
branch  2 taken 793
call    3 never executed
call    4 returned 793
        -:  815:
        -:  816:#ifdef	SIGDANGER
        -:  817:  FATAL_SIG (SIGDANGER);
        -:  818:#endif
        -:  819:#ifdef SIGXCPU
     793*:  820:  FATAL_SIG (SIGXCPU);
call    0 returned 793
branch  1 taken 0 (fallthrough)
branch  2 taken 793
call    3 never executed
call    4 returned 793
        -:  821:#endif
        -:  822:#ifdef SIGXFSZ
     793*:  823:  FATAL_SIG (SIGXFSZ);
call    0 returned 793
branch  1 taken 0 (fallthrough)
branch  2 taken 793
call    3 never executed
call    4 returned 793
        -:  824:#endif
        -:  825:
        -:  826:#undef	FATAL_SIG
        -:  827:
        -:  828:  /* Make sure stdout is line-buffered.  */
        -:  829:
        -:  830:#ifdef	HAVE_SETLINEBUF
      793:  831:  setlinebuf (stdout);
call    0 returned 793
        -:  832:#else
        -:  833:#ifndef	SETVBUF_REVERSED
        -:  834:  setvbuf (stdout, (char *) 0, _IOLBF, BUFSIZ);
        -:  835:#else	/* setvbuf not reversed.  */
        -:  836:  /* Some buggy systems lose if we pass 0 instead of allocating ourselves.  */
        -:  837:  setvbuf (stdout, _IOLBF, xmalloc (BUFSIZ), BUFSIZ);
        -:  838:#endif	/* setvbuf reversed.  */
        -:  839:#endif	/* setlinebuf missing.  */
        -:  840:
        -:  841:  /* Figure out where this program lives.  */
        -:  842:
      793:  843:  if (argv[0] == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 793
    #####:  844:    argv[0] = "";
      793:  845:  if (argv[0][0] == '\0')
branch  0 taken 0 (fallthrough)
branch  1 taken 793
    #####:  846:    program = "make";
        -:  847:  else
        -:  848:    {
        -:  849:#ifdef VMS
        -:  850:      program = rindex (argv[0], ']');
        -:  851:#else
      793:  852:      program = rindex (argv[0], '/');
        -:  853:#endif
        -:  854:#ifdef __MSDOS__
        -:  855:      if (program == 0)
        -:  856:	program = rindex (argv[0], '\\');
        -:  857:      else
        -:  858:	{
        -:  859:	  /* Some weird environments might pass us argv[0] with
        -:  860:	     both kinds of slashes; we must find the rightmost.  */
        -:  861:	  char *p = rindex (argv[0], '\\');
        -:  862:	  if (p && p > program)
        -:  863:	    program = p;
        -:  864:	}
        -:  865:      if (program == 0 && argv[0][1] == ':')
        -:  866:	program = argv[0] + 1;
        -:  867:#endif
      793:  868:      if (program == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 793
    #####:  869:	program = argv[0];
        -:  870:      else
      793:  871:	++program;
        -:  872:    }
        -:  873:
        -:  874:  /* Set up to access user data (files).  */
      793:  875:  user_access ();
call    0 returned 793
        -:  876:
        -:  877:  /* Figure out where we are.  */
        -:  878:
        -:  879:#ifdef WINDOWS32
        -:  880:  if (getcwd_fs (current_directory, GET_PATH_MAX) == 0)
        -:  881:#else
      793:  882:  if (getcwd (current_directory, GET_PATH_MAX) == 0)
call    0 returned 793
branch  1 taken 0 (fallthrough)
branch  2 taken 793
        -:  883:#endif
        -:  884:    {
        -:  885:#ifdef	HAVE_GETCWD
    #####:  886:      perror_with_name ("getcwd: ", "");
call    0 never executed
        -:  887:#else
        -:  888:      error ("getwd: %s", current_directory);
        -:  889:#endif
    #####:  890:      current_directory[0] = '\0';
    #####:  891:      directory_before_chdir = 0;
        -:  892:    }
        -:  893:  else
      793:  894:    directory_before_chdir = savestring (current_directory,
call    0 returned 793
        -:  895:					 strlen (current_directory));
        -:  896:#ifdef  __MSDOS__
        -:  897:  /* Make sure we will return to the initial directory, come what may.  */
        -:  898:  atexit (msdos_return_to_initial_directory);
        -:  899:#endif
        -:  900:
        -:  901:  /* Read in variables from the environment.  It is important that this be
        -:  902:     done before $(MAKE) is figured out so its definitions will not be
        -:  903:     from the environment.  */
        -:  904:
        -:  905:#ifndef _AMIGA
    40443:  906:  for (i = 0; envp[i] != 0; ++i)
branch  0 taken 39650
branch  1 taken 793 (fallthrough)
        -:  907:    {
        -:  908:      int do_not_define;
    39650:  909:      register char *ep = envp[i];
        -:  910:
        -:  911:      /* by default, everything gets defined and exported */
    39650:  912:      do_not_define = 0;
        -:  913:
   515450:  914:      while (*ep != '=')
branch  0 taken 475800
branch  1 taken 39650 (fallthrough)
   475800:  915:        ++ep;
        -:  916:#ifdef WINDOWS32
        -:  917:      if (!unix_path && !strncmp(envp[i], "PATH=", 5))
        -:  918:        unix_path = ep+1;
        -:  919:      else if (!windows32_path && !strnicmp(envp[i], "Path=", 5)) {
        -:  920:        do_not_define = 1; /* it gets defined after loop exits */
        -:  921:        windows32_path = ep+1;
        -:  922:      }
        -:  923:#endif
        -:  924:      /* The result of pointer arithmetic is cast to unsigned int for
        -:  925:	 machines where ptrdiff_t is a different size that doesn't widen
        -:  926:	 the same.  */
    39650:  927:      if (!do_not_define)
branch  0 taken 39650 (fallthrough)
branch  1 taken 0
    39650:  928:        define_variable (envp[i], (unsigned int) (ep - envp[i]),
call    0 returned 39650
        -:  929:                         ep + 1, o_env, 1)
        -:  930:	/* Force exportation of every variable culled from the environment.
        -:  931:	   We used to rely on target_environment's v_default code to do this.
        -:  932:	   But that does not work for the case where an environment variable
        -:  933:	   is redefined in a makefile with `override'; it should then still
        -:  934:	   be exported, because it was originally in the environment.  */
    39650:  935:	->export = v_export;
        -:  936:    }
        -:  937:#ifdef WINDOWS32
        -:  938:    /*
        -:  939:     * Make sure that this particular spelling of 'Path' is available
        -:  940:     */
        -:  941:    if (windows32_path)
        -:  942:      define_variable("Path", 4, windows32_path, o_env, 1)->export = v_export;
        -:  943:    else if (unix_path)
        -:  944:      define_variable("Path", 4, unix_path, o_env, 1)->export = v_export;
        -:  945:    else
        -:  946:      define_variable("Path", 4, "", o_env, 1)->export = v_export;
        -:  947:
        -:  948:    /*
        -:  949:     * PATH defaults to Path iff PATH not found and Path is found.
        -:  950:     */
        -:  951:    if (!unix_path && windows32_path)
        -:  952:      define_variable("PATH", 4, windows32_path, o_env, 1)->export = v_export;
        -:  953:#endif
        -:  954:#else /* For Amiga, read the ENV: device, ignoring all dirs */
        -:  955:    {
        -:  956:	BPTR env, file, old;
        -:  957:	char buffer[1024];
        -:  958:	int len;
        -:  959:	__aligned struct FileInfoBlock fib;
        -:  960:
        -:  961:	env = Lock ("ENV:", ACCESS_READ);
        -:  962:	if (env)
        -:  963:	{
        -:  964:	    old = CurrentDir (DupLock(env));
        -:  965:	    Examine (env, &fib);
        -:  966:
        -:  967:	    while (ExNext (env, &fib))
        -:  968:	    {
        -:  969:		if (fib.fib_DirEntryType < 0) /* File */
        -:  970:		{
        -:  971:		    /* Define an empty variable. It will be filled in
        -:  972:			variable_lookup(). Makes startup quite a bit
        -:  973:			faster. */
        -:  974:			define_variable (fib.fib_FileName,
        -:  975:			    strlen (fib.fib_FileName),
        -:  976:			"", o_env, 1)->export = v_export;
        -:  977:		}
        -:  978:	    }
        -:  979:	    UnLock (env);
        -:  980:	    UnLock(CurrentDir(old));
        -:  981:	}
        -:  982:    }
        -:  983:#endif
        -:  984:
        -:  985:  /* Decode the switches.  */
        -:  986:
      793:  987:  decode_env_switches ("MAKEFLAGS", 9);
call    0 returned 793
        -:  988:#if 0
        -:  989:  /* People write things like:
        -:  990:     	MFLAGS="CC=gcc -pipe" "CFLAGS=-g"
        -:  991:     and we set the -p, -i and -e switches.  Doesn't seem quite right.  */
        -:  992:  decode_env_switches ("MFLAGS", 6);
        -:  993:#endif
      793:  994:  decode_switches (argc, argv, 0);
call    0 returned 793
        -:  995:#ifdef WINDOWS32
        -:  996:  if (suspend_flag) {
        -:  997:        fprintf(stderr, "%s (pid = %d)\n", argv[0], GetCurrentProcessId());
        -:  998:        fprintf(stderr, "%s is suspending for 30 seconds...", argv[0]);
        -:  999:        Sleep(30 * 1000);
        -: 1000:        fprintf(stderr, "done sleep(30). Continuing.\n");
        -: 1001:  }
        -: 1002:#endif
        -: 1003:
        -: 1004:  /* Print version information.  */
        -: 1005:
      793: 1006:  if (print_version_flag || print_data_base_flag || debug_flag)
branch  0 taken 792 (fallthrough)
branch  1 taken 1
branch  2 taken 407 (fallthrough)
branch  3 taken 385
branch  4 taken 192 (fallthrough)
branch  5 taken 215
      578: 1007:    print_version ();
call    0 returned 578
        -: 1008:
        -: 1009:  /* `make --version' is supposed to just print the version and exit.  */
      793: 1010:  if (print_version_flag)
branch  0 taken 1 (fallthrough)
branch  1 taken 792
        1: 1011:    die (0);
call    0 returned 0
        -: 1012:
        -: 1013:#if !defined(__MSDOS__) && !defined(VMS)
        -: 1014:  /* Set the "MAKE_COMMAND" variable to the name we were invoked with.
        -: 1015:     (If it is a relative pathname with a slash, prepend our directory name
        -: 1016:     so the result will run the same program regardless of the current dir.
        -: 1017:     If it is a name with no slash, we can only hope that PATH did not
        -: 1018:     find it in the current directory.)  */
        -: 1019:#ifdef WINDOWS32
        -: 1020:  /*
        -: 1021:   * Convert from backslashes to forward slashes for
        -: 1022:   * programs like sh which don't like them. Shouldn't
        -: 1023:   * matter if the path is one way or the other for
        -: 1024:   * CreateProcess().
        -: 1025:   */
        -: 1026:  if (strpbrk(argv[0], "/:\\") ||
        -: 1027:      strstr(argv[0], "..") ||
        -: 1028:      !strncmp(argv[0], "//", 2))
        -: 1029:    argv[0] = strdup(w32ify(argv[0],1));
        -: 1030:#else /* WINDOWS32 */
      792: 1031:  if (current_directory[0] != '\0'
branch  0 taken 792 (fallthrough)
branch  1 taken 0
     792*: 1032:      && argv[0] != 0 && argv[0][0] != '/' && index (argv[0], '/') != 0)
branch  0 taken 792 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 792
branch  4 never executed
branch  5 never executed
    #####: 1033:    argv[0] = concat (current_directory, "/", argv[0]);
call    0 never executed
        -: 1034:#endif /* WINDOWS32 */
        -: 1035:#endif
        -: 1036:
        -: 1037:  /* The extra indirection through $(MAKE_COMMAND) is done
        -: 1038:     for hysterical raisins.  */
      792: 1039:  (void) define_variable ("MAKE_COMMAND", 12, argv[0], o_default, 0);
call    0 returned 792
      792: 1040:  (void) define_variable ("MAKE", 4, "$(MAKE_COMMAND)", o_default, 1);
call    0 returned 792
        -: 1041:
      792: 1042:  if (command_variables != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 792
        -: 1043:    {
        -: 1044:      struct command_variable *cv;
        -: 1045:      struct variable *v;
    #####: 1046:      unsigned int len = 0;
        -: 1047:      char *value, *p;
        -: 1048:
        -: 1049:      /* Figure out how much space will be taken up by the command-line
        -: 1050:	 variable definitions.  */
    #####: 1051:      for (cv = command_variables; cv != 0; cv = cv->next)
branch  0 never executed
branch  1 never executed
        -: 1052:	{
    #####: 1053:	  v = cv->variable;
    #####: 1054:	  len += 2 * strlen (v->name);
    #####: 1055:	  if (! v->recursive)
branch  0 never executed
branch  1 never executed
    #####: 1056:	    ++len;
    #####: 1057:	  ++len;
    #####: 1058:	  len += 3 * strlen (v->value);
        -: 1059:	}
        -: 1060:
        -: 1061:      /* Now allocate a buffer big enough and fill it.  */
    #####: 1062:      p = value = (char *) alloca (len);
    #####: 1063:      for (cv = command_variables; cv != 0; cv = cv->next)
branch  0 never executed
branch  1 never executed
        -: 1064:	{
    #####: 1065:	  v = cv->variable;
    #####: 1066:	  p = quote_as_word (p, v->name, 0);
call    0 never executed
    #####: 1067:	  if (! v->recursive)
branch  0 never executed
branch  1 never executed
    #####: 1068:	    *p++ = ':';
    #####: 1069:	  *p++ = '=';
    #####: 1070:	  p = quote_as_word (p, v->value, 0);
call    0 never executed
    #####: 1071:	  *p++ = ' ';
        -: 1072:	}
    #####: 1073:      p[-1] = '\0';		/* Kill the final space and terminate.  */
        -: 1074:
        -: 1075:      /* Define an unchangeable variable with a name that no POSIX.2
        -: 1076:	 makefile could validly use for its own variable.  */
    #####: 1077:      (void) define_variable ("-*-command-variables-*-", 23,
call    0 never executed
        -: 1078:			      value, o_automatic, 0);
        -: 1079:
        -: 1080:      /* Define the variable; this will not override any user definition.
        -: 1081:         Normally a reference to this variable is written into the value of
        -: 1082:         MAKEFLAGS, allowing the user to override this value to affect the
        -: 1083:         exported value of MAKEFLAGS.  In POSIX-pedantic mode, we cannot
        -: 1084:         allow the user's setting of MAKEOVERRIDES to affect MAKEFLAGS, so
        -: 1085:         a reference to this hidden variable is written instead. */
    #####: 1086:      (void) define_variable ("MAKEOVERRIDES", 13,
call    0 never executed
        -: 1087:			      "${-*-command-variables-*-}", o_env, 1);
        -: 1088:    }
        -: 1089:
        -: 1090:  /* If there were -C flags, move ourselves about.  */
      792: 1091:  if (directories != 0)
branch  0 taken 4 (fallthrough)
branch  1 taken 788
        8: 1092:    for (i = 0; directories->list[i] != 0; ++i)
branch  0 taken 6
branch  1 taken 2 (fallthrough)
        -: 1093:      {
        6: 1094:	char *dir = directories->list[i];
        6: 1095:	if (dir[0] == '~')
branch  0 taken 0 (fallthrough)
branch  1 taken 6
        -: 1096:	  {
    #####: 1097:	    char *expanded = tilde_expand (dir);
call    0 never executed
    #####: 1098:	    if (expanded != 0)
branch  0 never executed
branch  1 never executed
    #####: 1099:	      dir = expanded;
        -: 1100:	  }
        6: 1101:	if (chdir (dir) < 0)
call    0 returned 6
branch  1 taken 2 (fallthrough)
branch  2 taken 4
        2: 1102:	  pfatal_with_name (dir);
call    0 returned 0
        4: 1103:	if (dir != directories->list[i])
branch  0 taken 0 (fallthrough)
branch  1 taken 4
    #####: 1104:	  free (dir);
        -: 1105:      }
        -: 1106:
        -: 1107:#ifdef WINDOWS32
        -: 1108:  /*
        -: 1109:   * THIS BLOCK OF CODE MUST COME AFTER chdir() CALL ABOVE IN ORDER
        -: 1110:   * TO NOT CONFUSE THE DEPENDENCY CHECKING CODE IN implicit.c.
        -: 1111:   *
        -: 1112:   * The functions in dir.c can incorrectly cache information for "."
        -: 1113:   * before we have changed directory and this can cause file
        -: 1114:   * lookups to fail because the current directory (.) was pointing
        -: 1115:   * at the wrong place when it was first evaluated.
        -: 1116:   */
        -: 1117:   no_default_sh_exe = !find_and_set_default_shell(NULL);
        -: 1118:
        -: 1119:#endif /* WINDOWS32 */
        -: 1120:  /* Figure out the level of recursion.  */
        -: 1121:  {
      790: 1122:    struct variable *v = lookup_variable ("MAKELEVEL", 9);
call    0 returned 790
     790*: 1123:    if (v != 0 && *v->value != '\0' && *v->value != '-')
branch  0 taken 0 (fallthrough)
branch  1 taken 790
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1124:      makelevel = (unsigned int) atoi (v->value);
        -: 1125:    else
      790: 1126:      makelevel = 0;
        -: 1127:  }
        -: 1128:
        -: 1129:  /* Except under -s, always do -w in sub-makes and under -C.  */
      790: 1130:  if (!silent_flag && (directories != 0 || makelevel > 0))
branch  0 taken 406 (fallthrough)
branch  1 taken 384
branch  2 taken 404 (fallthrough)
branch  3 taken 2
branch  4 taken 0 (fallthrough)
branch  5 taken 404
        2: 1131:    print_directory_flag = 1;
        -: 1132:
        -: 1133:  /* Let the user disable that with --no-print-directory.  */
      790: 1134:  if (inhibit_print_directory_flag)
branch  0 taken 0 (fallthrough)
branch  1 taken 790
    #####: 1135:    print_directory_flag = 0;
        -: 1136:
        -: 1137:  /* Construct the list of include directories to search.  */
        -: 1138:
      795: 1139:  construct_include_path (include_directories == 0 ? (char **) 0
branch  0 taken 5 (fallthrough)
branch  1 taken 785
call    2 returned 790
        5: 1140:			  : include_directories->list);
        -: 1141:
        -: 1142:  /* Figure out where we are now, after chdir'ing.  */
      790: 1143:  if (directories == 0)
branch  0 taken 788 (fallthrough)
branch  1 taken 2
        -: 1144:    /* We didn't move, so we're still in the same place.  */
      788: 1145:    starting_directory = current_directory;
        -: 1146:  else
        -: 1147:    {
        -: 1148:#ifdef WINDOWS32
        -: 1149:      if (getcwd_fs (current_directory, GET_PATH_MAX) == 0)
        -: 1150:#else
        2: 1151:      if (getcwd (current_directory, GET_PATH_MAX) == 0)
call    0 returned 2
branch  1 taken 0 (fallthrough)
branch  2 taken 2
        -: 1152:#endif
        -: 1153:	{
        -: 1154:#ifdef	HAVE_GETCWD
    #####: 1155:	  perror_with_name ("getcwd: ", "");
call    0 never executed
        -: 1156:#else
        -: 1157:	  error ("getwd: %s", current_directory);
        -: 1158:#endif
    #####: 1159:	  starting_directory = 0;
        -: 1160:	}
        -: 1161:      else
        2: 1162:	starting_directory = current_directory;
        -: 1163:    }
        -: 1164:
      790: 1165:  (void) define_variable ("CURDIR", 6, current_directory, o_default, 0);
call    0 returned 790
        -: 1166:
        -: 1167:  /* Read any stdin makefiles into temporary files.  */
        -: 1168:
      790: 1169:  if (makefiles != 0)
branch  0 taken 772 (fallthrough)
branch  1 taken 18
        -: 1170:    {
        -: 1171:      register unsigned int i;
     1544: 1172:      for (i = 0; i < makefiles->idx; ++i)
branch  0 taken 772
branch  1 taken 772 (fallthrough)
     772*: 1173:	if (makefiles->list[i][0] == '-' && makefiles->list[i][1] == '\0')
branch  0 taken 0 (fallthrough)
branch  1 taken 772
branch  2 never executed
branch  3 never executed
        -: 1174:	  {
        -: 1175:	    /* This makefile is standard input.  Since we may re-exec
        -: 1176:	       and thus re-read the makefiles, we read standard input
        -: 1177:	       into a temporary file and read from that.  */
        -: 1178:	    FILE *outfile;
        -: 1179:
        -: 1180:	    /* Make a unique filename.  */
        -: 1181:#ifdef HAVE_MKTEMP
        -: 1182:
        -: 1183:#ifdef VMS
        -: 1184:	    static char name[] = "sys$scratch:GmXXXXXX";
        -: 1185:#else
        -: 1186:	    static char name[] = "/tmp/GmXXXXXX";
        -: 1187:#endif
    #####: 1188:	    (void) mktemp (name);
call    0 never executed
        -: 1189:#else
        -: 1190:	    static char name[L_tmpnam];
        -: 1191:	    (void) tmpnam (name);
        -: 1192:#endif
        -: 1193:
    #####: 1194:            if (stdin_nm)
branch  0 never executed
branch  1 never executed
    #####: 1195:              fatal("Makefile from standard input specified twice.");
call    0 never executed
        -: 1196:
    #####: 1197:	    outfile = fopen (name, "w");
call    0 never executed
    #####: 1198:	    if (outfile == 0)
branch  0 never executed
branch  1 never executed
    #####: 1199:	      pfatal_with_name ("fopen (temporary file)");
call    0 never executed
    #####: 1200:	    while (!feof (stdin))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1201:	      {
        -: 1202:		char buf[2048];
    #####: 1203:		unsigned int n = fread (buf, 1, sizeof(buf), stdin);
call    0 never executed
    #####: 1204:		if (n > 0 && fwrite (buf, 1, n, outfile) != n)
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1205:		  pfatal_with_name ("fwrite (temporary file)");
call    0 never executed
        -: 1206:	      }
    #####: 1207:	    (void) fclose (outfile);
call    0 never executed
        -: 1208:
        -: 1209:	    /* Replace the name that read_all_makefiles will
        -: 1210:	       see with the name of the temporary file.  */
        -: 1211:	    {
        -: 1212:	      char *temp;
        -: 1213:	      /* SGI compiler requires alloca's result be assigned simply.  */
    #####: 1214:	      temp = (char *) alloca (sizeof (name));
    #####: 1215:	      bcopy (name, temp, sizeof (name));
    #####: 1216:	      makefiles->list[i] = temp;
        -: 1217:	    }
        -: 1218:
        -: 1219:	    /* Make sure the temporary file will not be remade.  */
    #####: 1220:            stdin_nm = savestring (name, sizeof(name) -1);
call    0 never executed
    #####: 1221:	    f = enter_file (stdin_nm);
call    0 never executed
    #####: 1222:	    f->updated = 1;
    #####: 1223:	    f->update_status = 0;
    #####: 1224:	    f->command_state = cs_finished;
        -: 1225: 	    /* Can't be intermediate, or it'll be removed too early for
        -: 1226:               make re-exec.  */
    #####: 1227: 	    f->intermediate = 0;
    #####: 1228:	    f->dontcare = 0;
        -: 1229:	  }
        -: 1230:    }
        -: 1231:
        -: 1232:  /* Set up to handle children dying.  This must be done before
        -: 1233:     reading in the makefiles so that `shell' function calls will work.  */
        -: 1234:
        -: 1235:#ifdef SIGCHLD
      790: 1236:  (void) signal (SIGCHLD, child_handler);
call    0 returned 790
        -: 1237:#endif
        -: 1238:#ifdef SIGCLD
      790: 1239:  (void) signal (SIGCLD, child_handler);
call    0 returned 790
        -: 1240:#endif
        -: 1241:
        -: 1242:  /* Let the user send us SIGUSR1 to toggle the -d flag during the run.  */
        -: 1243:#ifdef SIGUSR1
      790: 1244:  (void) signal (SIGUSR1, debug_signal_handler);
call    0 returned 790
        -: 1245:#endif
        -: 1246:
        -: 1247:  /* Define the initial list of suffixes for old-style rules.  */
        -: 1248:
      790: 1249:  set_default_suffixes ();
call    0 returned 790
        -: 1250:
        -: 1251:  /* Define the file rules for the built-in suffix rules.  These will later
        -: 1252:     be converted into pattern rules.  We used to do this in
        -: 1253:     install_default_implicit_rules, but since that happens after reading
        -: 1254:     makefiles, it results in the built-in pattern rules taking precedence
        -: 1255:     over makefile-specified suffix rules, which is wrong.  */
        -: 1256:
      790: 1257:  install_default_suffix_rules ();
call    0 returned 790
        -: 1258:
        -: 1259:  /* Define some internal and special variables.  */
        -: 1260:
      790: 1261:  define_automatic_variables ();
call    0 returned 790
        -: 1262:
        -: 1263:  /* Set up the MAKEFLAGS and MFLAGS variables
        -: 1264:     so makefiles can look at them.  */
        -: 1265:
      790: 1266:  define_makeflags (0, 0);
call    0 returned 790
        -: 1267:
        -: 1268:  /* Define the default variables.  */
      790: 1269:  define_default_variables ();
call    0 returned 790
        -: 1270:
        -: 1271:  /* Read all the makefiles.  */
        -: 1272:
      790: 1273:  default_file = enter_file (".DEFAULT");
call    0 returned 790
        -: 1274:
        -: 1275:  read_makefiles
      790: 1276:    = read_all_makefiles (makefiles == 0 ? (char **) 0 : makefiles->list);
branch  0 taken 772 (fallthrough)
branch  1 taken 18
call    2 returned 790
        -: 1277:
        -: 1278:#ifdef WINDOWS32
        -: 1279:  /* look one last time after reading all Makefiles */
        -: 1280:  if (no_default_sh_exe)
        -: 1281:    no_default_sh_exe = !find_and_set_default_shell(NULL);
        -: 1282:
        -: 1283:  if (no_default_sh_exe && job_slots != 1) {
        -: 1284:    error("Do not specify -j or --jobs if sh.exe is not available.");
        -: 1285:    error("Resetting make for single job mode.");
        -: 1286:    job_slots = 1;
        -: 1287:  }
        -: 1288:#endif /* WINDOWS32 */
        -: 1289:
        -: 1290:#ifdef __MSDOS__
        -: 1291:  /* We need to know what kind of shell we will be using.  */
        -: 1292:  {
        -: 1293:    extern int _is_unixy_shell (const char *_path);
        -: 1294:    struct variable *shv = lookup_variable("SHELL", 5);
        -: 1295:    extern int unixy_shell;
        -: 1296:    extern char *default_shell;
        -: 1297:
        -: 1298:    if (shv && *shv->value)
        -: 1299:      {
        -: 1300:	char *shell_path = recursively_expand(shv);
        -: 1301:
        -: 1302:	if (shell_path && _is_unixy_shell (shell_path))
        -: 1303:	  unixy_shell = 1;
        -: 1304:	else
        -: 1305:	  unixy_shell = 0;
        -: 1306:	if (shell_path)
        -: 1307:	  default_shell = shell_path;
        -: 1308:      }
        -: 1309:  }
        -: 1310:#endif /* __MSDOS__ */
        -: 1311:
        -: 1312:  /* Decode switches again, in case the variables were set by the makefile.  */
      790: 1313:  decode_env_switches ("MAKEFLAGS", 9);
call    0 returned 790
        -: 1314:#if 0
        -: 1315:  decode_env_switches ("MFLAGS", 6);
        -: 1316:#endif
        -: 1317:
        -: 1318:  /* Set up MAKEFLAGS and MFLAGS again, so they will be right.  */
        -: 1319:
      790: 1320:  define_makeflags (1, 0);
call    0 returned 790
        -: 1321:
        -: 1322:  /* Make each `struct dep' point at the `struct file' for the file
        -: 1323:     depended on.  Also do magic for special targets.  */
        -: 1324:
      790: 1325:  snap_deps ();
call    0 returned 790
        -: 1326:
        -: 1327:  /* Convert old-style suffix rules to pattern rules.  It is important to
        -: 1328:     do this before installing the built-in pattern rules below, so that
        -: 1329:     makefile-specified suffix rules take precedence over built-in pattern
        -: 1330:     rules.  */
        -: 1331:
      790: 1332:  convert_to_pattern ();
call    0 returned 790
        -: 1333:
        -: 1334:  /* Install the default implicit pattern rules.
        -: 1335:     This used to be done before reading the makefiles.
        -: 1336:     But in that case, built-in pattern rules were in the chain
        -: 1337:     before user-defined ones, so they matched first.  */
        -: 1338:
      790: 1339:  install_default_implicit_rules ();
call    0 returned 790
        -: 1340:
        -: 1341:  /* Compute implicit rule limits.  */
        -: 1342:
      790: 1343:  count_implicit_rule_limits ();
call    0 returned 790
        -: 1344:
        -: 1345:  /* Construct the listings of directories in VPATH lists.  */
        -: 1346:
      790: 1347:  build_vpath_lists ();
call    0 returned 790
        -: 1348:
        -: 1349:  /* Mark files given with -o flags as very old (00:00:01.00 Jan 1, 1970)
        -: 1350:     and as having been updated already, and files given with -W flags as
        -: 1351:     brand new (time-stamp as far as possible into the future).  */
        -: 1352:
      790: 1353:  if (old_files != 0)
branch  0 taken 2 (fallthrough)
branch  1 taken 788
        4: 1354:    for (p = old_files->list; *p != 0; ++p)
branch  0 taken 2
branch  1 taken 2 (fallthrough)
        -: 1355:      {
        2: 1356:	f = enter_command_line_file (*p);
call    0 returned 2
        2: 1357:	f->last_mtime = (time_t) 1;
        2: 1358:	f->updated = 1;
        2: 1359:	f->update_status = 0;
        2: 1360:	f->command_state = cs_finished;
        -: 1361:      }
        -: 1362:
      790: 1363:  if (new_files != 0)
branch  0 taken 3 (fallthrough)
branch  1 taken 787
        -: 1364:    {
        6: 1365:      for (p = new_files->list; *p != 0; ++p)
branch  0 taken 3
branch  1 taken 3 (fallthrough)
        -: 1366:	{
        3: 1367:	  f = enter_command_line_file (*p);
call    0 returned 3
        3: 1368:	  f->last_mtime = NEW_MTIME;
        -: 1369:	}
        -: 1370:    }
        -: 1371:
        -: 1372:  /* Initialize the remote job module.  */
      790: 1373:  remote_setup ();
call    0 returned 790
        -: 1374:
      790: 1375:  if (read_makefiles != 0)
branch  0 taken 790 (fallthrough)
branch  1 taken 0
        -: 1376:    {
        -: 1377:      /* Update any makefiles if necessary.  */
        -: 1378:
      790: 1379:      time_t *makefile_mtimes = 0;
      790: 1380:      unsigned int mm_idx = 0;
      790: 1381:      char **nargv = argv;
      790: 1382:      int nargc = argc;
        -: 1383:
      790: 1384:      if (debug_flag)
branch  0 taken 384 (fallthrough)
branch  1 taken 406
      384: 1385:	puts ("Updating makefiles....");
call    0 returned 384
        -: 1386:
        -: 1387:      /* Remove any makefiles we don't want to try to update.
        -: 1388:	 Also record the current modtimes so we can compare them later.  */
        -: 1389:      {
        -: 1390:	register struct dep *d, *last;
      790: 1391:	last = 0;
      790: 1392:	d = read_makefiles;
     1585: 1393:	while (d != 0)
branch  0 taken 795
branch  1 taken 790 (fallthrough)
        -: 1394:	  {
      795: 1395:	    register struct file *f = d->file;
      795: 1396:	    if (f->double_colon)
branch  0 taken 0 (fallthrough)
branch  1 taken 795
    #####: 1397:	      for (f = f->double_colon; f != NULL; f = f->prev)
branch  0 never executed
branch  1 never executed
        -: 1398:		{
    #####: 1399:		  if (f->deps == 0 && f->cmds != 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1400:		    {
        -: 1401:		      /* This makefile is a :: target with commands, but
        -: 1402:			 no dependencies.  So, it will always be remade.
        -: 1403:			 This might well cause an infinite loop, so don't
        -: 1404:			 try to remake it.  (This will only happen if
        -: 1405:			 your makefiles are written exceptionally
        -: 1406:			 stupidly; but if you work for Athena, that's how
        -: 1407:			 you write your makefiles.)  */
        -: 1408:
    #####: 1409:		      if (debug_flag)
branch  0 never executed
branch  1 never executed
    #####: 1410:			printf ("Makefile `%s' might loop; not remaking it.\n",
call    0 never executed
        -: 1411:				f->name);
        -: 1412:
    #####: 1413:		      if (last == 0)
branch  0 never executed
branch  1 never executed
    #####: 1414:			read_makefiles = d->next;
        -: 1415:		      else
    #####: 1416:			last->next = d->next;
        -: 1417:
        -: 1418:		      /* Free the storage.  */
    #####: 1419:		      free ((char *) d);
        -: 1420:
    #####: 1421:		      d = last == 0 ? read_makefiles : last->next;
branch  0 never executed
branch  1 never executed
        -: 1422:
    #####: 1423:		      break;
        -: 1424:		    }
        -: 1425:		}
      795: 1426:	    if (f == NULL || !f->double_colon)
branch  0 taken 795 (fallthrough)
branch  1 taken 0
branch  2 taken 795 (fallthrough)
branch  3 taken 0
        -: 1427:	      {
      795: 1428:		if (makefile_mtimes == 0)
branch  0 taken 790 (fallthrough)
branch  1 taken 5
      790: 1429:		  makefile_mtimes = (time_t *) xmalloc (sizeof (time_t));
call    0 returned 790
        -: 1430:		else
        -: 1431:		  makefile_mtimes = (time_t *)
        5: 1432:		    xrealloc ((char *) makefile_mtimes,
        5: 1433:			      (mm_idx + 1) * sizeof (time_t));
call    0 returned 5
     795*: 1434:		makefile_mtimes[mm_idx++] = file_mtime_no_search (d->file);
branch  0 taken 0 (fallthrough)
branch  1 taken 795
call    2 returned 795
      795: 1435:		last = d;
      795: 1436:		d = d->next;
        -: 1437:	      }
        -: 1438:	  }
        -: 1439:      }
        -: 1440:
        -: 1441:      /* Set up `MAKEFLAGS' specially while remaking makefiles.  */
      790: 1442:      define_makeflags (1, 1);
call    0 returned 790
        -: 1443:
      790: 1444:      switch (update_goal_chain (read_makefiles, 1))
call    0 returned 273
branch  1 taken 0
branch  2 taken 17
branch  3 taken 256
branch  4 taken 0
        -: 1445:	{
    #####: 1446:	case 1:
        -: 1447:	default:
        -: 1448:#define BOGUS_UPDATE_STATUS 0
    #####: 1449:	  assert (BOGUS_UPDATE_STATUS);
call    0 never executed
        -: 1450:	  break;
        -: 1451:
       17: 1452:	case -1:
        -: 1453:	  /* Did nothing.  */
       17: 1454:	  break;
        -: 1455:
      256: 1456:	case 2:
        -: 1457:	  /* Failed to update.  Figure out if we care.  */
        -: 1458:	  {
        -: 1459:	    /* Nonzero if any makefile was successfully remade.  */
      256: 1460:	    int any_remade = 0;
        -: 1461:	    /* Nonzero if any makefile we care about failed
        -: 1462:	       in updating or could not be found at all.  */
      256: 1463:	    int any_failed = 0;
        -: 1464:	    register unsigned int i;
        -: 1465:            struct dep *d;
        -: 1466:
      512: 1467:	    for (i = 0, d = read_makefiles; d != 0; ++i, d = d->next)
branch  0 taken 256
branch  1 taken 256 (fallthrough)
      256: 1468:              if (d->file->updated)
branch  0 taken 256 (fallthrough)
branch  1 taken 0
        -: 1469:                {
        -: 1470:                  /* This makefile was updated.  */
      256: 1471:                  if (d->file->update_status == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 256
        -: 1472:                    {
        -: 1473:                      /* It was successfully updated.  */
    #####: 1474:                      any_remade |= (file_mtime_no_search (d->file)
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1475:                                     != makefile_mtimes[i]);
        -: 1476:                    }
      256: 1477:                  else if (! (d->changed & RM_DONTCARE))
branch  0 taken 256 (fallthrough)
branch  1 taken 0
        -: 1478:                    {
        -: 1479:                      time_t mtime;
        -: 1480:                      /* The update failed and this makefile was not
        -: 1481:                         from the MAKEFILES variable, so we care.  */
      256: 1482:                      error ("Failed to remake makefile `%s'.",
      256: 1483:                             d->file->name);
call    0 returned 256
     256*: 1484:                      mtime = file_mtime_no_search (d->file);
branch  0 taken 256 (fallthrough)
branch  1 taken 0
call    2 never executed
      256: 1485:                      any_remade |= (mtime != (time_t) -1
     256*: 1486:                                     && mtime != makefile_mtimes[i]);
branch  0 taken 0 (fallthrough)
branch  1 taken 256
branch  2 never executed
branch  3 never executed
        -: 1487:                    }
        -: 1488:                }
        -: 1489:              else
        -: 1490:                /* This makefile was not found at all.  */
    #####: 1491:                if (! (d->changed & RM_DONTCARE))
branch  0 never executed
branch  1 never executed
        -: 1492:                  {
        -: 1493:                    /* This is a makefile we care about.  See how much.  */
    #####: 1494:                    if (d->changed & RM_INCLUDED)
branch  0 never executed
branch  1 never executed
        -: 1495:                      /* An included makefile.  We don't need
        -: 1496:                         to die, but we do want to complain.  */
    #####: 1497:                      error ("Included makefile `%s' was not found.",
call    0 never executed
    #####: 1498:                             dep_name (d));
branch  0 never executed
branch  1 never executed
        -: 1499:                    else
        -: 1500:                      {
        -: 1501:                        /* A normal makefile.  We must die later.  */
    #####: 1502:                        error ("Makefile `%s' was not found", dep_name (d));
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1503:                        any_failed = 1;
        -: 1504:                      }
        -: 1505:                  }
        -: 1506:
      256: 1507:	    if (any_remade)
branch  0 taken 0 (fallthrough)
branch  1 taken 256
    #####: 1508:	      goto re_exec;
      256: 1509:	    else if (any_failed)
branch  0 taken 0 (fallthrough)
branch  1 taken 256
    #####: 1510:	      die (2);
call    0 never executed
        -: 1511:	    else
      256: 1512:	      break;
        -: 1513:	  }
        -: 1514:
        -: 1515:	case 0:
    #####: 1516:	re_exec:
        -: 1517:	  /* Updated successfully.  Re-exec ourselves.  */
        -: 1518:
    #####: 1519:	  remove_intermediates (0);
call    0 never executed
        -: 1520:
    #####: 1521:	  if (print_data_base_flag)
branch  0 never executed
branch  1 never executed
    #####: 1522:	    print_data_base ();
call    0 never executed
        -: 1523:
    #####: 1524:	  log_working_directory (0);
call    0 never executed
        -: 1525:
    #####: 1526:	  if (makefiles != 0)
branch  0 never executed
branch  1 never executed
        -: 1527:	    {
        -: 1528:	      /* These names might have changed.  */
    #####: 1529:	      register unsigned int i, j = 0;
    #####: 1530:	      for (i = 1; i < argc; ++i)
branch  0 never executed
branch  1 never executed
    #####: 1531:		if (!strncmp (argv[i], "-f", 2)) /* XXX */
branch  0 never executed
branch  1 never executed
        -: 1532:		  {
    #####: 1533:		    char *p = &argv[i][2];
    #####: 1534:		    if (*p == '\0')
branch  0 never executed
branch  1 never executed
    #####: 1535:		      argv[++i] = makefiles->list[j];
        -: 1536:		    else
    #####: 1537:		      argv[i] = concat ("-f", makefiles->list[j], "");
call    0 never executed
    #####: 1538:		    ++j;
        -: 1539:		  }
        -: 1540:	    }
        -: 1541:
        -: 1542:          /* Add -o option for the stdin temporary file, if necessary.  */
    #####: 1543:          if (stdin_nm)
branch  0 never executed
branch  1 never executed
        -: 1544:            {
    #####: 1545:              nargv = (char **)xmalloc((nargc + 2) * sizeof(char *));
call    0 never executed
    #####: 1546:              bcopy(argv, nargv, argc * sizeof(char *));
    #####: 1547:              nargv[nargc++] = concat("-o", stdin_nm, "");
call    0 never executed
    #####: 1548:              nargv[nargc] = 0;
        -: 1549:            }
        -: 1550:
    #####: 1551:	  if (directories != 0 && directories->idx > 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1552:	    {
        -: 1553:	      char bad;
    #####: 1554:	      if (directory_before_chdir != 0)
branch  0 never executed
branch  1 never executed
        -: 1555:		{
    #####: 1556:		  if (chdir (directory_before_chdir) < 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1557:		    {
    #####: 1558:		      perror_with_name ("chdir", "");
call    0 never executed
    #####: 1559:		      bad = 1;
        -: 1560:		    }
        -: 1561:		  else
    #####: 1562:		    bad = 0;
        -: 1563:		}
        -: 1564:	      else
    #####: 1565:		bad = 1;
    #####: 1566:	      if (bad)
branch  0 never executed
branch  1 never executed
    #####: 1567:		fatal ("Couldn't change back to original directory.");
call    0 never executed
        -: 1568:	    }
        -: 1569:
        -: 1570:#ifndef _AMIGA
    #####: 1571:	  for (p = environ; *p != 0; ++p)
branch  0 never executed
branch  1 never executed
    #####: 1572:	    if (!strncmp (*p, "MAKELEVEL=", 10))
branch  0 never executed
branch  1 never executed
        -: 1573:	      {
        -: 1574:		/* The SGI compiler apparently can't understand
        -: 1575:		   the concept of storing the result of a function
        -: 1576:		   in something other than a local variable.  */
        -: 1577:		char *sgi_loses;
    #####: 1578:		sgi_loses = (char *) alloca (40);
    #####: 1579:		*p = sgi_loses;
    #####: 1580:		sprintf (*p, "MAKELEVEL=%u", makelevel);
    #####: 1581:		break;
        -: 1582:	      }
        -: 1583:#else /* AMIGA */
        -: 1584:	  {
        -: 1585:	    char buffer[256];
        -: 1586:	    int len;
        -: 1587:
        -: 1588:	    len = GetVar ("MAKELEVEL", buffer, sizeof (buffer), GVF_GLOBAL_ONLY);
        -: 1589:
        -: 1590:	    if (len != -1)
        -: 1591:	    {
        -: 1592:	    sprintf (buffer, "%u", makelevel);
        -: 1593:	      SetVar ("MAKELEVEL", buffer, -1, GVF_GLOBAL_ONLY);
        -: 1594:	    }
        -: 1595:	  }
        -: 1596:#endif
        -: 1597:
    #####: 1598:	  if (debug_flag)
branch  0 never executed
branch  1 never executed
        -: 1599:	    {
        -: 1600:	      char **p;
    #####: 1601:	      fputs ("Re-executing:", stdout);
call    0 never executed
    #####: 1602:	      for (p = nargv; *p != 0; ++p)
branch  0 never executed
branch  1 never executed
    #####: 1603:		printf (" %s", *p);
call    0 never executed
    #####: 1604:	      puts ("");
call    0 never executed
        -: 1605:	    }
        -: 1606:
    #####: 1607:	  fflush (stdout);
call    0 never executed
    #####: 1608:	  fflush (stderr);
call    0 never executed
        -: 1609:
        -: 1610:#ifndef _AMIGA
    #####: 1611:	  exec_command (nargv, environ);
call    0 never executed
        -: 1612:#else
        -: 1613:	  exec_command (nargv);
        -: 1614:	  exit (0);
        -: 1615:#endif
        -: 1616:	  /* NOTREACHED */
        -: 1617:	}
        -: 1618:    }
        -: 1619:
        -: 1620:  /* Set up `MAKEFLAGS' again for the normal targets.  */
      273: 1621:  define_makeflags (1, 0);
call    0 returned 273
        -: 1622:
        -: 1623:  /* If there is a temp file from reading a makefile from stdin, get rid of
        -: 1624:     it now.  */
     273*: 1625:  if (stdin_nm && unlink(stdin_nm) < 0 && errno != ENOENT)
branch  0 taken 0 (fallthrough)
branch  1 taken 273
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####: 1626:    perror_with_name("unlink (temporary file): ", stdin_nm);
call    0 never executed
        -: 1627:
        -: 1628:  {
        -: 1629:    int status;
        -: 1630:
        -: 1631:    /* If there were no command-line goals, use the default.  */
      273: 1632:    if (goals == 0)
branch  0 taken 273 (fallthrough)
branch  1 taken 0
        -: 1633:      {
      273: 1634:	if (default_goal_file != 0)
branch  0 taken 16 (fallthrough)
branch  1 taken 257
        -: 1635:	  {
       16: 1636:	    goals = (struct dep *) xmalloc (sizeof (struct dep));
call    0 returned 16
       16: 1637:	    goals->next = 0;
       16: 1638:	    goals->name = 0;
       16: 1639:	    goals->file = default_goal_file;
        -: 1640:	  }
        -: 1641:      }
        -: 1642:    else
    #####: 1643:      lastgoal->next = 0;
        -: 1644:
      273: 1645:    if (goals != 0)
branch  0 taken 16 (fallthrough)
branch  1 taken 257
        -: 1646:      {
        -: 1647:	/* Update the goals.  */
        -: 1648:
       16: 1649:	if (debug_flag)
branch  0 taken 0 (fallthrough)
branch  1 taken 16
    #####: 1650:	  puts ("Updating goal targets....");
call    0 never executed
        -: 1651:
       16: 1652:	switch (update_goal_chain (goals, 0))
call    0 returned 14
branch  1 taken 14
branch  2 taken 0
branch  3 taken 0
branch  4 taken 0
        -: 1653:	  {
       14: 1654:	  case -1:
        -: 1655:	    /* Nothing happened.  */
        -: 1656:	  case 0:
        -: 1657:	    /* Updated successfully.  */
       14: 1658:	    status = EXIT_SUCCESS;
       14: 1659:	    break;
    #####: 1660:	  case 2:
        -: 1661:	    /* Updating failed.  POSIX.2 specifies exit status >1 for this;
        -: 1662:	       but in VMS, there is only success and failure.  */
    #####: 1663:	    status = EXIT_FAILURE ? 2 : EXIT_FAILURE;
    #####: 1664:	    break;
    #####: 1665:	  case 1:
        -: 1666:	    /* We are under -q and would run some commands.  */
    #####: 1667:	    status = EXIT_FAILURE;
    #####: 1668:	    break;
    #####: 1669:	  default:
    #####: 1670:	    abort ();
call    0 never executed
        -: 1671:	  }
        -: 1672:      }
        -: 1673:    else
        -: 1674:      {
      257: 1675:	if (read_makefiles == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 257
    #####: 1676:	  fatal ("No targets specified and no makefile found");
call    0 never executed
        -: 1677:	else
      257: 1678:	  fatal ("No targets");
call    0 returned 0
        -: 1679:      }
        -: 1680:
        -: 1681:    /* If we detected some clock skew, generate one last warning */
       14: 1682:    if (clock_skew_detected)
branch  0 taken 0 (fallthrough)
branch  1 taken 14
    #####: 1683:      error("*** Warning:  Clock skew detected.  Your build may be incomplete.");
call    0 never executed
        -: 1684:
        -: 1685:    /* Exit.  */
       14: 1686:    die (status);
        -: 1687:  }
        -: 1688:
        -: 1689:  return 0;
        -: 1690:}
        -: 1691:
        -: 1692:/* Parsing of arguments, decoding of switches.  */
        -: 1693:
        -: 1694:static char options[1 + sizeof (switches) / sizeof (switches[0]) * 3];
        -: 1695:static struct option long_options[(sizeof (switches) / sizeof (switches[0])) +
        -: 1696:				  (sizeof (long_option_aliases) /
        -: 1697:				   sizeof (long_option_aliases[0]))];
        -: 1698:
        -: 1699:/* Fill in the string and vector for getopt.  */
        -: 1700:static void
function init_switches called 1564 returned 100% blocks executed 100%
     1564: 1701:init_switches ()
        -: 1702:{
        -: 1703:  register char *p;
        -: 1704:  register int c;
        -: 1705:  register unsigned int i;
        -: 1706:
     1564: 1707:  if (options[0] != '\0')
branch  0 taken 771 (fallthrough)
branch  1 taken 793
        -: 1708:    /* Already done.  */
      771: 1709:    return;
        -: 1710:
      793: 1711:  p = options;
        -: 1712:
        -: 1713:  /* Return switch and non-switch args in order, regardless of
        -: 1714:     POSIXLY_CORRECT.  Non-switch args are returned as option 1.  */
      793: 1715:  *p++ = '-';
        -: 1716:
    20618: 1717:  for (i = 0; switches[i].c != '\0'; ++i)
branch  0 taken 19825
branch  1 taken 793 (fallthrough)
        -: 1718:    {
    19825: 1719:      long_options[i].name = (switches[i].long_name == 0 ? "" :
branch  0 taken 18239 (fallthrough)
branch  1 taken 1586
        -: 1720:			      switches[i].long_name);
    19825: 1721:      long_options[i].flag = 0;
    19825: 1722:      long_options[i].val = switches[i].c;
    19825: 1723:      if (isalnum (switches[i].c))
branch  0 taken 18239 (fallthrough)
branch  1 taken 1586
    18239: 1724:	*p++ = switches[i].c;
    19825: 1725:      switch (switches[i].type)
branch  0 taken 14274
branch  1 taken 5551
branch  2 taken 0
        -: 1726:	{
    14274: 1727:	case flag:
        -: 1728:	case flag_off:
        -: 1729:	case ignore:
    14274: 1730:	  long_options[i].has_arg = no_argument;
    14274: 1731:	  break;
        -: 1732:
     5551: 1733:	case string:
        -: 1734:	case positive_int:
        -: 1735:	case floating:
     5551: 1736:	  if (isalnum (switches[i].c))
branch  0 taken 5551 (fallthrough)
branch  1 taken 0
     5551: 1737:	    *p++ = ':';
     5551: 1738:	  if (switches[i].noarg_value != 0)
branch  0 taken 1586 (fallthrough)
branch  1 taken 3965
        -: 1739:	    {
     1586: 1740:	      if (isalnum (switches[i].c))
branch  0 taken 1586 (fallthrough)
branch  1 taken 0
     1586: 1741:		*p++ = ':';
     1586: 1742:	      long_options[i].has_arg = optional_argument;
        -: 1743:	    }
        -: 1744:	  else
     3965: 1745:	    long_options[i].has_arg = required_argument;
     5551: 1746:	  break;
        -: 1747:	}
        -: 1748:    }
      793: 1749:  *p = '\0';
     7930: 1750:  for (c = 0; c < (sizeof (long_option_aliases) /
branch  0 taken 7137
branch  1 taken 793 (fallthrough)
        -: 1751:		   sizeof (long_option_aliases[0]));
     7137: 1752:       ++c)
     7137: 1753:    long_options[i++] = long_option_aliases[c];
      793: 1754:  long_options[i].name = 0;
        -: 1755:}
        -: 1756:
        -: 1757:static void
function handle_non_switch_argument called 0 returned 0% blocks executed 0%
    #####: 1758:handle_non_switch_argument (arg, env)
        -: 1759:     char *arg;
        -: 1760:     int env;
        -: 1761:{
        -: 1762:  /* Non-option argument.  It might be a variable definition.  */
        -: 1763:  struct variable *v;
    #####: 1764:  if (arg[0] == '-' && arg[1] == '\0')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1765:    /* Ignore plain `-' for compatibility.  */
    #####: 1766:    return;
    #####: 1767:  v = try_variable_definition ((char *) 0, 0, arg, o_command);
call    0 never executed
    #####: 1768:  if (v != 0)
branch  0 never executed
branch  1 never executed
        -: 1769:    {
        -: 1770:      /* It is indeed a variable definition.  Record a pointer to
        -: 1771:	 the variable for later use in define_makeflags.  */
        -: 1772:      struct command_variable *cv
    #####: 1773:	= (struct command_variable *) xmalloc (sizeof (*cv));
call    0 never executed
    #####: 1774:      cv->variable = v;
    #####: 1775:      cv->next = command_variables;
    #####: 1776:      command_variables = cv;
        -: 1777:    }
    #####: 1778:  else if (! env)
branch  0 never executed
branch  1 never executed
        -: 1779:    {
        -: 1780:      /* Not an option or variable definition; it must be a goal
        -: 1781:	 target!  Enter it as a file and add it to the dep chain of
        -: 1782:	 goals.  */
    #####: 1783:      struct file *f = enter_command_line_file (arg);
call    0 never executed
    #####: 1784:      f->cmd_target = 1;
        -: 1785:
    #####: 1786:      if (goals == 0)
branch  0 never executed
branch  1 never executed
        -: 1787:	{
    #####: 1788:	  goals = (struct dep *) xmalloc (sizeof (struct dep));
call    0 never executed
    #####: 1789:	  lastgoal = goals;
        -: 1790:	}
        -: 1791:      else
        -: 1792:	{
    #####: 1793:	  lastgoal->next
    #####: 1794:	    = (struct dep *) xmalloc (sizeof (struct dep));
call    0 never executed
    #####: 1795:	  lastgoal = lastgoal->next;
        -: 1796:	}
    #####: 1797:      lastgoal->name = 0;
    #####: 1798:      lastgoal->file = f;
        -: 1799:
        -: 1800:      {
        -: 1801:        /* Add this target name to the MAKECMDGOALS variable. */
        -: 1802:        struct variable *v;
        -: 1803:        char *value;
        -: 1804:
    #####: 1805:        v = lookup_variable("MAKECMDGOALS", 12);
call    0 never executed
    #####: 1806:        if (v == 0)
branch  0 never executed
branch  1 never executed
    #####: 1807:          value = f->name;
        -: 1808:        else
        -: 1809:          {
        -: 1810:            /* Paste the old and new values together */
        -: 1811:            unsigned int oldlen, newlen;
        -: 1812:
    #####: 1813:            oldlen = strlen(v->value);
    #####: 1814:            newlen = strlen(f->name);
    #####: 1815:            value = (char *)alloca(oldlen + 1 + newlen + 1);
    #####: 1816:            bcopy(v->value, value, oldlen);
    #####: 1817:            value[oldlen] = ' ';
    #####: 1818:            bcopy(f->name, &value[oldlen + 1], newlen + 1);
        -: 1819:          }
    #####: 1820:        define_variable("MAKECMDGOALS", 12, value, o_default, 0);
call    0 never executed
        -: 1821:      }
        -: 1822:    }
        -: 1823:}
        -: 1824:
        -: 1825:/* Decode switches from ARGC and ARGV.
        -: 1826:   They came from the environment if ENV is nonzero.  */
        -: 1827:
        -: 1828:static void
function decode_switches called 1564 returned 100% blocks executed 31%
     1564: 1829:decode_switches (argc, argv, env)
        -: 1830:     int argc;
        -: 1831:     char **argv;
        -: 1832:     int env;
        -: 1833:{
     1564: 1834:  int bad = 0;
        -: 1835:  register const struct command_switch *cs;
        -: 1836:  register struct stringlist *sl;
        -: 1837:  register int c;
        -: 1838:
        -: 1839:  /* getopt does most of the parsing for us.
        -: 1840:     First, get its vectors set up.  */
        -: 1841:
     1564: 1842:  init_switches ();
call    0 returned 1564
        -: 1843:
        -: 1844:  /* Let getopt produce error messages for the command line,
        -: 1845:     but not for options from the environment.  */
     1564: 1846:  opterr = !env;
        -: 1847:  /* Reset getopt's state.  */
     1564: 1848:  optind = 0;
        -: 1849:
     7997: 1850:  while (optind < argc)
branch  0 taken 6436
branch  1 taken 1561 (fallthrough)
        -: 1851:    {
        -: 1852:      /* Parse the next argument.  */
     6436: 1853:      c = getopt_long (argc, argv, options, long_options, (int *) 0);
call    0 returned 6436
     6436: 1854:      if (c == EOF)
branch  0 taken 3 (fallthrough)
branch  1 taken 6433
        -: 1855:	/* End of arguments, or "--" marker seen.  */
        3: 1856:	break;
     6433: 1857:      else if (c == 1)
branch  0 taken 0 (fallthrough)
branch  1 taken 6433
        -: 1858:	/* An argument not starting with a dash.  */
    #####: 1859:	handle_non_switch_argument (optarg, env);
call    0 never executed
     6433: 1860:      else if (c == '?')
branch  0 taken 0 (fallthrough)
branch  1 taken 6433
        -: 1861:	/* Bad option.  We will print a usage message and die later.
        -: 1862:	   But continue to parse the other options so the user can
        -: 1863:	   see all he did wrong.  */
    #####: 1864:	bad = 1;
        -: 1865:      else
    70543: 1866:	for (cs = switches; cs->c != '\0'; ++cs)
branch  0 taken 70543
branch  1 taken 0 (fallthrough)
    70543: 1867:	  if (cs->c == c)
branch  0 taken 6433 (fallthrough)
branch  1 taken 64110
        -: 1868:	    {
        -: 1869:	      /* Whether or not we will actually do anything with
        -: 1870:		 this switch.  We test this individually inside the
        -: 1871:		 switch below rather than just once outside it, so that
        -: 1872:		 options which are to be ignored still consume args.  */
    6433*: 1873:	      int doit = !env || cs->env;
branch  0 taken 2823 (fallthrough)
branch  1 taken 3610
branch  2 taken 2823 (fallthrough)
branch  3 taken 0
        -: 1874:
     6433: 1875:	      switch (cs->type)
branch  0 taken 0
branch  1 taken 0
branch  2 taken 5645
branch  3 taken 788
branch  4 taken 0
branch  5 taken 0
        -: 1876:		{
    #####: 1877:		default:
    #####: 1878:		  abort ();
call    0 never executed
        -: 1879:
    #####: 1880:		case ignore:
    #####: 1881:		  break;
        -: 1882:
     5645: 1883:		case flag:
        -: 1884:		case flag_off:
     5645: 1885:		  if (doit)
branch  0 taken 5645 (fallthrough)
branch  1 taken 0
     5645: 1886:		    *(int *) cs->value_ptr = cs->type == flag;
     5645: 1887:		  break;
        -: 1888:
      788: 1889:		case string:
      788: 1890:		  if (!doit)
branch  0 taken 0 (fallthrough)
branch  1 taken 788
    #####: 1891:		    break;
        -: 1892:
      788: 1893:		  if (optarg == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 788
    #####: 1894:		    optarg = cs->noarg_value;
        -: 1895:
      788: 1896:		  sl = *(struct stringlist **) cs->value_ptr;
      788: 1897:		  if (sl == 0)
branch  0 taken 786 (fallthrough)
branch  1 taken 2
        -: 1898:		    {
        -: 1899:		      sl = (struct stringlist *)
      786: 1900:			xmalloc (sizeof (struct stringlist));
call    0 returned 786
      786: 1901:		      sl->max = 5;
      786: 1902:		      sl->idx = 0;
      786: 1903:		      sl->list = (char **) xmalloc (5 * sizeof (char *));
call    0 returned 786
      786: 1904:		      *(struct stringlist **) cs->value_ptr = sl;
        -: 1905:		    }
        2: 1906:		  else if (sl->idx == sl->max - 1)
branch  0 taken 0 (fallthrough)
branch  1 taken 2
        -: 1907:		    {
    #####: 1908:		      sl->max += 5;
    #####: 1909:		      sl->list = (char **)
    #####: 1910:			xrealloc ((char *) sl->list,
    #####: 1911:				  sl->max * sizeof (char *));
call    0 never executed
        -: 1912:		    }
      788: 1913:		  sl->list[sl->idx++] = optarg;
      788: 1914:		  sl->list[sl->idx] = 0;
      788: 1915:		  break;
        -: 1916:
    #####: 1917:		case positive_int:
    #####: 1918:		  if (optarg == 0 && argc > optind
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1919:		      && isdigit (argv[optind][0]))
branch  0 never executed
branch  1 never executed
    #####: 1920:		    optarg = argv[optind++];
        -: 1921:
    #####: 1922:		  if (!doit)
branch  0 never executed
branch  1 never executed
    #####: 1923:		    break;
        -: 1924:
    #####: 1925:		  if (optarg != 0)
branch  0 never executed
branch  1 never executed
        -: 1926:		    {
    #####: 1927:		      int i = atoi (optarg);
    #####: 1928:		      if (i < 1)
branch  0 never executed
branch  1 never executed
        -: 1929:			{
    #####: 1930:			  if (doit)
branch  0 never executed
branch  1 never executed
    #####: 1931:			    error ("the `-%c' option requires a \
        -: 1932:positive integral argument",
    #####: 1933:				   cs->c);
call    0 never executed
    #####: 1934:			  bad = 1;
        -: 1935:			}
        -: 1936:		      else
    #####: 1937:			*(unsigned int *) cs->value_ptr = i;
        -: 1938:		    }
        -: 1939:		  else
    #####: 1940:		    *(unsigned int *) cs->value_ptr
    #####: 1941:		      = *(unsigned int *) cs->noarg_value;
    #####: 1942:		  break;
        -: 1943:
        -: 1944:#ifndef NO_FLOAT
    #####: 1945:		case floating:
    #####: 1946:		  if (optarg == 0 && optind < argc
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1947:		      && (isdigit (argv[optind][0]) || argv[optind][0] == '.'))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1948:		    optarg = argv[optind++];
        -: 1949:
    #####: 1950:		  if (doit)
branch  0 never executed
branch  1 never executed
    #####: 1951:		    *(double *) cs->value_ptr
    #####: 1952:		      = (optarg != 0 ? atof (optarg)
    #####: 1953:			 : *(double *) cs->noarg_value);
branch  0 never executed
branch  1 never executed
        -: 1954:
    #####: 1955:		  break;
        -: 1956:#endif
        -: 1957:		}
        -: 1958:
        -: 1959:	      /* We've found the switch.  Stop looking.  */
     6433: 1960:	      break;
        -: 1961:	    }
        -: 1962:    }
        -: 1963:
        -: 1964:  /* There are no more options according to getting getopt, but there may
        -: 1965:     be some arguments left.  Since we have asked for non-option arguments
        -: 1966:     to be returned in order, this only happens when there is a "--"
        -: 1967:     argument to prevent later arguments from being options.  */
     1564: 1968:  while (optind < argc)
branch  0 taken 0
branch  1 taken 1564 (fallthrough)
    #####: 1969:    handle_non_switch_argument (argv[optind++], env);
call    0 never executed
        -: 1970:
        -: 1971:
     1564: 1972:  if (!env && (bad || print_usage_flag))
branch  0 taken 793 (fallthrough)
branch  1 taken 771
branch  2 taken 793 (fallthrough)
branch  3 taken 0
branch  4 taken 0 (fallthrough)
branch  5 taken 793
        -: 1973:    {
        -: 1974:      /* Print a nice usage message.  */
        -: 1975:      FILE *usageto;
        -: 1976:
    #####: 1977:      if (print_version_flag)
branch  0 never executed
branch  1 never executed
    #####: 1978:	print_version ();
call    0 never executed
        -: 1979:
    #####: 1980:      usageto = bad ? stderr : stdout;
        -: 1981:
    #####: 1982:      fprintf (usageto, "Usage: %s [options] [target] ...\n", program);
call    0 never executed
        -: 1983:
    #####: 1984:      fputs ("Options:\n", usageto);
call    0 never executed
    #####: 1985:      for (cs = switches; cs->c != '\0'; ++cs)
branch  0 never executed
branch  1 never executed
        -: 1986:	{
        -: 1987:	  char buf[1024], shortarg[50], longarg[50], *p;
        -: 1988:
    #####: 1989:	  if (cs->description[0] == '-')
branch  0 never executed
branch  1 never executed
    #####: 1990:	    continue;
        -: 1991:
    #####: 1992:	  switch (long_options[cs - switches].has_arg)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1993:	    {
    #####: 1994:	    case no_argument:
    #####: 1995:	      shortarg[0] = longarg[0] = '\0';
    #####: 1996:	      break;
    #####: 1997:	    case required_argument:
    #####: 1998:	      sprintf (longarg, "=%s", cs->argdesc);
    #####: 1999:	      sprintf (shortarg, " %s", cs->argdesc);
    #####: 2000:	      break;
    #####: 2001:	    case optional_argument:
    #####: 2002:	      sprintf (longarg, "[=%s]", cs->argdesc);
    #####: 2003:	      sprintf (shortarg, " [%s]", cs->argdesc);
    #####: 2004:	      break;
        -: 2005:	    }
        -: 2006:
    #####: 2007:	  p = buf;
        -: 2008:
    #####: 2009:	  if (isalnum (cs->c))
branch  0 never executed
branch  1 never executed
        -: 2010:	    {
    #####: 2011:	      sprintf (buf, "  -%c%s", cs->c, shortarg);
    #####: 2012:	      p += strlen (p);
        -: 2013:	    }
    #####: 2014:	  if (cs->long_name != 0)
branch  0 never executed
branch  1 never executed
        -: 2015:	    {
        -: 2016:	      unsigned int i;
    #####: 2017:	      sprintf (p, "%s--%s%s",
    #####: 2018:		       !isalnum (cs->c) ? "  " : ", ",
    #####: 2019:		       cs->long_name, longarg);
branch  0 never executed
branch  1 never executed
    #####: 2020:	      p += strlen (p);
    #####: 2021:	      for (i = 0; i < (sizeof (long_option_aliases) /
branch  0 never executed
branch  1 never executed
        -: 2022:			       sizeof (long_option_aliases[0]));
    #####: 2023:		   ++i)
    #####: 2024:		if (long_option_aliases[i].val == cs->c)
branch  0 never executed
branch  1 never executed
        -: 2025:		  {
    #####: 2026:		    sprintf (p, ", --%s%s",
        -: 2027:			     long_option_aliases[i].name, longarg);
    #####: 2028:		    p += strlen (p);
        -: 2029:		  }
        -: 2030:	    }
        -: 2031:	  {
    #####: 2032:	    const struct command_switch *ncs = cs;
    #####: 2033:	    while ((++ncs)->c != '\0')
branch  0 never executed
branch  1 never executed
    #####: 2034:	      if (ncs->description[0] == '-' &&
branch  0 never executed
branch  1 never executed
    #####: 2035:		  ncs->description[1] == cs->c)
branch  0 never executed
branch  1 never executed
        -: 2036:		{
        -: 2037:		  /* This is another switch that does the same
        -: 2038:		     one as the one we are processing.  We want
        -: 2039:		     to list them all together on one line.  */
    #####: 2040:		  sprintf (p, ", -%c%s", ncs->c, shortarg);
    #####: 2041:		  p += strlen (p);
    #####: 2042:		  if (ncs->long_name != 0)
branch  0 never executed
branch  1 never executed
        -: 2043:		    {
    #####: 2044:		      sprintf (p, ", --%s%s", ncs->long_name, longarg);
    #####: 2045:		      p += strlen (p);
        -: 2046:		    }
        -: 2047:		}
        -: 2048:	  }
        -: 2049:
    #####: 2050:	  if (p - buf > DESCRIPTION_COLUMN - 2)
branch  0 never executed
branch  1 never executed
        -: 2051:	    /* The list of option names is too long to fit on the same
        -: 2052:	       line with the description, leaving at least two spaces.
        -: 2053:	       Print it on its own line instead.  */
        -: 2054:	    {
    #####: 2055:	      fprintf (usageto, "%s\n", buf);
call    0 never executed
    #####: 2056:	      buf[0] = '\0';
        -: 2057:	    }
        -: 2058:
    #####: 2059:	  fprintf (usageto, "%*s%s.\n",
        -: 2060:		   - DESCRIPTION_COLUMN,
    #####: 2061:		   buf, cs->description);
call    0 never executed
        -: 2062:	}
        -: 2063:
    #####: 2064:      die (bad ? 2 : 0);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 2065:    }
     1564: 2066:}
        -: 2067:
        -: 2068:/* Decode switches from environment variable ENVAR (which is LEN chars long).
        -: 2069:   We do this by chopping the value into a vector of words, prepending a
        -: 2070:   dash to the first word if it lacks one, and passing the vector to
        -: 2071:   decode_switches.  */
        -: 2072:
        -: 2073:static void
function decode_env_switches called 1583 returned 100% blocks executed 80%
     1583: 2074:decode_env_switches (envar, len)
        -: 2075:     char *envar;
        -: 2076:     unsigned int len;
        -: 2077:{
     1583: 2078:  char *varref = (char *) alloca (2 + len + 2);
        -: 2079:  char *value, *p;
        -: 2080:  int argc;
        -: 2081:  char **argv;
        -: 2082:
        -: 2083:  /* Get the variable's value.  */
     1583: 2084:  varref[0] = '$';
     1583: 2085:  varref[1] = '(';
     1583: 2086:  bcopy (envar, &varref[2], len);
     1583: 2087:  varref[2 + len] = ')';
     1583: 2088:  varref[2 + len + 1] = '\0';
     1583: 2089:  value = variable_expand (varref);
call    0 returned 1583
        -: 2090:
        -: 2091:  /* Skip whitespace, and check for an empty value.  */
     1583: 2092:  value = next_token (value);
call    0 returned 1583
     1583: 2093:  len = strlen (value);
     1583: 2094:  if (len == 0)
branch  0 taken 812 (fallthrough)
branch  1 taken 771
      812: 2095:    return;
        -: 2096:
        -: 2097:  /* Allocate a vector that is definitely big enough.  */
      771: 2098:  argv = (char **) alloca ((1 + len + 1) * sizeof (char *));
        -: 2099:
        -: 2100:  /* Allocate a buffer to copy the value into while we split it into words
        -: 2101:     and unquote it.  We must use permanent storage for this because
        -: 2102:     decode_switches may store pointers into the passed argument words.  */
      771: 2103:  p = (char *) xmalloc (2 * len);
call    0 returned 771
        -: 2104:
        -: 2105:  /* getopt will look at the arguments starting at ARGV[1].
        -: 2106:     Prepend a spacer word.  */
      771: 2107:  argv[0] = 0;
      771: 2108:  argc = 1;
      771: 2109:  argv[argc] = p;
     3594: 2110:  while (*value != '\0')
branch  0 taken 2823
branch  1 taken 771 (fallthrough)
        -: 2111:    {
     2823: 2112:      if (*value == '\\')
branch  0 taken 0 (fallthrough)
branch  1 taken 2823
    #####: 2113:	++value;		/* Skip the backslash.  */
    2823*: 2114:      else if (isblank (*value))
branch  0 taken 0 (fallthrough)
branch  1 taken 2823
        -: 2115:	{
        -: 2116:	  /* End of the word.  */
    #####: 2117:	  *p++ = '\0';
    #####: 2118:	  argv[++argc] = p;
        -: 2119:	  do
    #####: 2120:	    ++value;
    #####: 2121:	  while (isblank (*value));
branch  0 never executed
branch  1 never executed
    #####: 2122:	  continue;
        -: 2123:	}
     2823: 2124:      *p++ = *value++;
        -: 2125:    }
      771: 2126:  *p = '\0';
      771: 2127:  argv[++argc] = 0;
        -: 2128:
      771: 2129:  if (argv[1][0] != '-' && index (argv[1], '=') == 0)
branch  0 taken 771 (fallthrough)
branch  1 taken 0
branch  2 taken 771 (fallthrough)
branch  3 taken 0
        -: 2130:    /* The first word doesn't start with a dash and isn't a variable
        -: 2131:       definition.  Add a dash and pass it along to decode_switches.  We
        -: 2132:       need permanent storage for this in case decode_switches saves
        -: 2133:       pointers into the value.  */
      771: 2134:    argv[1] = concat ("-", argv[1], "");
call    0 returned 771
        -: 2135:
        -: 2136:  /* Parse those words.  */
      771: 2137:  decode_switches (argc, argv, 1);
call    0 returned 771
        -: 2138:}
        -: 2139:
        -: 2140:/* Quote the string IN so that it will be interpreted as a single word with
        -: 2141:   no magic by the shell; if DOUBLE_DOLLARS is nonzero, also double dollar
        -: 2142:   signs to avoid variable expansion in make itself.  Write the result into
        -: 2143:   OUT, returning the address of the next character to be written.
        -: 2144:   Allocating space for OUT twice the length of IN (thrice if
        -: 2145:   DOUBLE_DOLLARS is nonzero) is always sufficient.  */
        -: 2146:
        -: 2147:static char *
function quote_as_word called 13 returned 100% blocks executed 80%
       13: 2148:quote_as_word (out, in, double_dollars)
        -: 2149:     char *out, *in;
        -: 2150:     int double_dollars;
        -: 2151:{
      198: 2152:  while (*in != '\0')
branch  0 taken 185
branch  1 taken 13 (fallthrough)
        -: 2153:    {
        -: 2154:#ifdef VMS
        -: 2155:      if (index ("^;'\"*?$<>(){}|&~`\\ \t\r\n\f\v", *in) != 0)
        -: 2156:#else
      185: 2157:      if (index ("^;'\"*?[]$<>(){}|&~`\\ \t\r\n\f\v", *in) != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 185
        -: 2158:#endif
    #####: 2159:	*out++ = '\\';
      185: 2160:      if (double_dollars && *in == '$')
branch  0 taken 185 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 185
    #####: 2161:	*out++ = '$';
      185: 2162:      *out++ = *in++;
        -: 2163:    }
        -: 2164:
       13: 2165:  return out;
        -: 2166:}
        -: 2167:
        -: 2168:/* Define the MAKEFLAGS and MFLAGS variables to reflect the settings of the
        -: 2169:   command switches.  Include options with args if ALL is nonzero.
        -: 2170:   Don't include options with the `no_makefile' flag set if MAKEFILE.  */
        -: 2171:
        -: 2172:static void
function define_makeflags called 2643 returned 100% blocks executed 54%
     2643: 2173:define_makeflags (all, makefile)
        -: 2174:     int all, makefile;
        -: 2175:{
        -: 2176:  static const char ref[] = "$(MAKEOVERRIDES)";
        -: 2177:  static const char posixref[] = "$(-*-command-variables-*-)";
        -: 2178:  register const struct command_switch *cs;
        -: 2179:  char *flagstring;
        -: 2180:  register char *p;
        -: 2181:  unsigned int words;
        -: 2182:  struct variable *v;
        -: 2183:
        -: 2184:  /* We will construct a linked list of `struct flag's describing
        -: 2185:     all the flags which need to go in MAKEFLAGS.  Then, once we
        -: 2186:     know how many there are and their lengths, we can put them all
        -: 2187:     together in a string.  */
        -: 2188:
        -: 2189:  struct flag
        -: 2190:    {
        -: 2191:      struct flag *next;
        -: 2192:      const struct command_switch *cs;
        -: 2193:      char *arg;
        -: 2194:    };
     2643: 2195:  struct flag *flags = 0;
     2643: 2196:  unsigned int flagslen = 0;
        -: 2197:#define	ADD_FLAG(ARG, LEN) \
        -: 2198:  do {									      \
        -: 2199:    struct flag *new = (struct flag *) alloca (sizeof (struct flag));	      \
        -: 2200:    new->cs = cs;							      \
        -: 2201:    new->arg = (ARG);							      \
        -: 2202:    new->next = flags;							      \
        -: 2203:    flags = new;							      \
        -: 2204:    if (new->arg == 0)							      \
        -: 2205:      ++flagslen;		/* Just a single flag letter.  */	      \
        -: 2206:    else								      \
        -: 2207:      flagslen += 1 + 1 + 1 + 1 + 3 * (LEN); /* " -x foo" */		      \
        -: 2208:    if (!isalnum (cs->c))						      \
        -: 2209:      /* This switch has no single-letter version, so we use the long.  */    \
        -: 2210:      flagslen += 2 + strlen (cs->long_name);				      \
        -: 2211:  } while (0)
        -: 2212:
    68718: 2213:  for (cs = switches; cs->c != '\0'; ++cs)
branch  0 taken 66075
branch  1 taken 2643 (fallthrough)
    66075: 2214:    if (cs->toenv && (!makefile || !cs->no_makefile))
branch  0 taken 47574 (fallthrough)
branch  1 taken 18501
branch  2 taken 14220 (fallthrough)
branch  3 taken 33354
branch  4 taken 11850 (fallthrough)
branch  5 taken 2370
    45204: 2215:      switch (cs->type)
branch  0 taken 0
branch  1 taken 0
branch  2 taken 37275
branch  3 taken 2643
branch  4 taken 2643
branch  5 taken 2643
        -: 2216:	{
    #####: 2217:	default:
    #####: 2218:	  abort ();
call    0 never executed
        -: 2219:
    #####: 2220:	case ignore:
    #####: 2221:	  break;
        -: 2222:
    37275: 2223:	case flag:
        -: 2224:	case flag_off:
    37275: 2225:	  if (!*(int *) cs->value_ptr == (cs->type == flag_off)
branch  0 taken 10732 (fallthrough)
branch  1 taken 26543
    10732: 2226:	      && (cs->default_value == 0
branch  0 taken 2643 (fallthrough)
branch  1 taken 8089
     2643: 2227:		  || *(int *) cs->value_ptr != *(int *) cs->default_value))
branch  0 taken 1024 (fallthrough)
branch  1 taken 1619
    9113*: 2228:	    ADD_FLAG (0, 0);
branch  0 taken 9113 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 9113
    37275: 2229:	  break;
        -: 2230:
     2643: 2231:	case positive_int:
     2643: 2232:	  if (all)
branch  0 taken 1853 (fallthrough)
branch  1 taken 790
        -: 2233:	    {
     1853: 2234:	      if ((cs->default_value != 0
branch  0 taken 1853 (fallthrough)
branch  1 taken 0
     1853: 2235:		   && (*(unsigned int *) cs->value_ptr
     1853: 2236:		       == *(unsigned int *) cs->default_value)))
branch  0 taken 0 (fallthrough)
branch  1 taken 1853
        -: 2237:		break;
    #####: 2238:	      else if (cs->noarg_value != 0
branch  0 never executed
branch  1 never executed
    #####: 2239:		       && (*(unsigned int *) cs->value_ptr ==
    #####: 2240:			   *(unsigned int *) cs->noarg_value))
branch  0 never executed
branch  1 never executed
    #####: 2241:		ADD_FLAG ("", 0); /* Optional value omitted; see below.  */
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2242:	      else if (cs->c == 'j')
branch  0 never executed
branch  1 never executed
        -: 2243:		/* Special case for `-j'.  */
    #####: 2244:		ADD_FLAG ("1", 1);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2245:	      else
        -: 2246:		{
    #####: 2247:		  char *buf = (char *) alloca (30);
    #####: 2248:		  sprintf (buf, "%u", *(unsigned int *) cs->value_ptr);
    #####: 2249:		  ADD_FLAG (buf, strlen (buf));
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2250:		}
        -: 2251:	    }
      790: 2252:	  break;
        -: 2253:
        -: 2254:#ifndef NO_FLOAT
     2643: 2255:	case floating:
     2643: 2256:	  if (all)
branch  0 taken 1853 (fallthrough)
branch  1 taken 790
        -: 2257:	    {
     1853: 2258:	      if (cs->default_value != 0
branch  0 taken 1853 (fallthrough)
branch  1 taken 0
     1853: 2259:		  && (*(double *) cs->value_ptr
     1853: 2260:		      == *(double *) cs->default_value))
branch  0 taken 0 (fallthrough)
branch  1 taken 1853
        -: 2261:		break;
    #####: 2262:	      else if (cs->noarg_value != 0
branch  0 never executed
branch  1 never executed
    #####: 2263:		       && (*(double *) cs->value_ptr
    #####: 2264:			   == *(double *) cs->noarg_value))
branch  0 never executed
branch  1 never executed
    #####: 2265:		ADD_FLAG ("", 0); /* Optional value omitted; see below.  */
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2266:	      else
        -: 2267:		{
    #####: 2268:		  char *buf = (char *) alloca (100);
    #####: 2269:		  sprintf (buf, "%g", *(double *) cs->value_ptr);
    #####: 2270:		  ADD_FLAG (buf, strlen (buf));
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2271:		}
        -: 2272:	    }
      790: 2273:	  break;
        -: 2274:#endif
        -: 2275:
     2643: 2276:	case string:
     2643: 2277:	  if (all)
branch  0 taken 1853 (fallthrough)
branch  1 taken 790
        -: 2278:	    {
     1853: 2279:	      struct stringlist *sl = *(struct stringlist **) cs->value_ptr;
     1853: 2280:	      if (sl != 0)
branch  0 taken 13 (fallthrough)
branch  1 taken 1840
        -: 2281:		{
        -: 2282:		  /* Add the elements in reverse order, because
        -: 2283:		     all the flags get reversed below; and the order
        -: 2284:		     matters for some switches (like -I).  */
       13: 2285:		  register unsigned int i = sl->idx;
       26: 2286:		  while (i-- > 0)
branch  0 taken 13
branch  1 taken 13 (fallthrough)
      13*: 2287:		    ADD_FLAG (sl->list[i], strlen (sl->list[i]));
branch  0 taken 0 (fallthrough)
branch  1 taken 13
branch  2 taken 0 (fallthrough)
branch  3 taken 13
        -: 2288:		}
        -: 2289:	    }
     2643: 2290:	  break;
        -: 2291:	}
        -: 2292:
     2643: 2293:  flagslen += 4 + sizeof posixref; /* Four more for the possible " -- ".  */
        -: 2294:
        -: 2295:#undef	ADD_FLAG
        -: 2296:
        -: 2297:  /* Construct the value in FLAGSTRING.
        -: 2298:     We allocate enough space for a preceding dash and trailing null.  */
     2643: 2299:  flagstring = (char *) alloca (1 + flagslen + 1);
     2643: 2300:  p = flagstring;
     2643: 2301:  words = 1;
     2643: 2302:  *p++ = '-';
    11769: 2303:  while (flags != 0)
branch  0 taken 9126
branch  1 taken 2643 (fallthrough)
        -: 2304:    {
        -: 2305:      /* Add the flag letter or name to the string.  */
     9126: 2306:      if (!isalnum (flags->cs->c))
branch  0 taken 0 (fallthrough)
branch  1 taken 9126
        -: 2307:	{
    #####: 2308:	  *p++ = '-';
    #####: 2309:	  strcpy (p, flags->cs->long_name);
    #####: 2310:	  p += strlen (p);
        -: 2311:	}
        -: 2312:      else
     9126: 2313:	*p++ = flags->cs->c;
     9126: 2314:      if (flags->arg != 0)
branch  0 taken 13 (fallthrough)
branch  1 taken 9113
        -: 2315:	{
        -: 2316:	  /* A flag that takes an optional argument which in this case is
        -: 2317:	     omitted is specified by ARG being "".  We must distinguish
        -: 2318:	     because a following flag appended without an intervening " -"
        -: 2319:	     is considered the arg for the first.  */
       13: 2320:	  if (flags->arg[0] != '\0')
branch  0 taken 13 (fallthrough)
branch  1 taken 0
        -: 2321:	    {
        -: 2322:	      /* Add its argument too.  */
      13*: 2323:	      *p++ = !isalnum (flags->cs->c) ? '=' : ' ';
branch  0 taken 0 (fallthrough)
branch  1 taken 13
       13: 2324:	      p = quote_as_word (p, flags->arg, 1);
call    0 returned 13
        -: 2325:	    }
       13: 2326:	  ++words;
        -: 2327:	  /* Write a following space and dash, for the next flag.  */
       13: 2328:	  *p++ = ' ';
       13: 2329:	  *p++ = '-';
        -: 2330:	}
     9113: 2331:      else if (!isalnum (flags->cs->c))
branch  0 taken 0 (fallthrough)
branch  1 taken 9113
        -: 2332:	{
    #####: 2333:	  ++words;
        -: 2334:	  /* Long options must each go in their own word,
        -: 2335:	     so we write the following space and dash.  */
    #####: 2336:	  *p++ = ' ';
    #####: 2337:	  *p++ = '-';
        -: 2338:	}
     9126: 2339:      flags = flags->next;
        -: 2340:    }
        -: 2341:
        -: 2342:  /* Define MFLAGS before appending variable definitions.  */
        -: 2343:
     2643: 2344:  if (p == &flagstring[1])
branch  0 taken 61 (fallthrough)
branch  1 taken 2582
        -: 2345:    /* No flags.  */
       61: 2346:    flagstring[0] = '\0';
     2582: 2347:  else if (p[-1] == '-')
branch  0 taken 13 (fallthrough)
branch  1 taken 2569
        -: 2348:    {
        -: 2349:      /* Kill the final space and dash.  */
       13: 2350:      p -= 2;
       13: 2351:      *p = '\0';
        -: 2352:    }
        -: 2353:  else
        -: 2354:    /* Terminate the string.  */
     2569: 2355:    *p = '\0';
        -: 2356:
        -: 2357:  /* Since MFLAGS is not parsed for flags, there is no reason to
        -: 2358:     override any makefile redefinition.  */
     2643: 2359:  (void) define_variable ("MFLAGS", 6, flagstring, o_env, 1);
call    0 returned 2643
        -: 2360:
     2643: 2361:  if (all && command_variables != 0)
branch  0 taken 1853 (fallthrough)
branch  1 taken 790
branch  2 taken 0 (fallthrough)
branch  3 taken 1853
        -: 2362:    {
        -: 2363:      /* Now write a reference to $(MAKEOVERRIDES), which contains all the
        -: 2364:	 command-line variable definitions.  */
        -: 2365:
    #####: 2366:      if (p == &flagstring[1])
branch  0 never executed
branch  1 never executed
        -: 2367:	/* No flags written, so elide the leading dash already written.  */
    #####: 2368:	p = flagstring;
        -: 2369:      else
        -: 2370:	{
        -: 2371:	  /* Separate the variables from the switches with a "--" arg.  */
    #####: 2372:	  if (p[-1] != '-')
branch  0 never executed
branch  1 never executed
        -: 2373:	    {
        -: 2374:	      /* We did not already write a trailing " -".  */
    #####: 2375:	      *p++ = ' ';
    #####: 2376:	      *p++ = '-';
        -: 2377:	    }
        -: 2378:	  /* There is a trailing " -"; fill it out to " -- ".  */
    #####: 2379:	  *p++ = '-';
    #####: 2380:	  *p++ = ' ';
        -: 2381:	}
        -: 2382:
        -: 2383:      /* Copy in the string.  */
    #####: 2384:      if (posix_pedantic)
branch  0 never executed
branch  1 never executed
        -: 2385:	{
    #####: 2386:	  bcopy (posixref, p, sizeof posixref - 1);
    #####: 2387:	  p += sizeof posixref - 1;
        -: 2388:	}
        -: 2389:      else
        -: 2390:	{
    #####: 2391:	  bcopy (ref, p, sizeof ref - 1);
    #####: 2392:	  p += sizeof ref - 1;
        -: 2393:	}
        -: 2394:    }
     2643: 2395:  else if (p == &flagstring[1])
branch  0 taken 61 (fallthrough)
branch  1 taken 2582
        -: 2396:    {
       61: 2397:      words = 0;
       61: 2398:      --p;
        -: 2399:    }
     2582: 2400:  else if (p[-1] == '-')
branch  0 taken 0 (fallthrough)
branch  1 taken 2582
        -: 2401:    /* Kill the final space and dash.  */
    #####: 2402:    p -= 2;
        -: 2403:  /* Terminate the string.  */
     2643: 2404:  *p = '\0';
        -: 2405:
     2643: 2406:  v = define_variable ("MAKEFLAGS", 9,
call    0 returned 2643
        -: 2407:		       /* If there are switches, omit the leading dash
        -: 2408:			  unless it is a single long option with two
        -: 2409:			  leading dashes.  */
     2643: 2410:		       &flagstring[(flagstring[0] == '-'
     2582: 2411:				    && flagstring[1] != '-')
branch  0 taken 2582 (fallthrough)
branch  1 taken 0
     5225: 2412:				   ? 1 : 0],
branch  0 taken 2582 (fallthrough)
branch  1 taken 61
        -: 2413:		       /* This used to use o_env, but that lost when a
        -: 2414:			  makefile defined MAKEFLAGS.  Makefiles set
        -: 2415:			  MAKEFLAGS to add switches, but we still want
        -: 2416:			  to redefine its value with the full set of
        -: 2417:			  switches.  Of course, an override or command
        -: 2418:			  definition will still take precedence.  */
        -: 2419:		       o_file, 1);
     2643: 2420:  if (! all)
branch  0 taken 790 (fallthrough)
branch  1 taken 1853
        -: 2421:    /* The first time we are called, set MAKEFLAGS to always be exported.
        -: 2422:       We should not do this again on the second call, because that is
        -: 2423:       after reading makefiles which might have done `unexport MAKEFLAGS'. */
      790: 2424:    v->export = v_export;
     2643: 2425:}
        -: 2426:
        -: 2427:/* Print version information.  */
        -: 2428:
        -: 2429:static void
function print_version called 579 returned 100% blocks executed 83%
      579: 2430:print_version ()
        -: 2431:{
        -: 2432:  static int printed_version = 0;
        -: 2433:
      579: 2434:  char *precede = print_data_base_flag ? "# " : "";
branch  0 taken 385 (fallthrough)
branch  1 taken 194
        -: 2435:
      579: 2436:  if (printed_version)
branch  0 taken 1 (fallthrough)
branch  1 taken 578
        -: 2437:    /* Do it only once.  */
        1: 2438:    return;
        -: 2439:
      578: 2440:  printf ("%sGNU Make version %s", precede, version_string);
call    0 returned 578
     578*: 2441:  if (remote_description != 0 && *remote_description != '\0')
branch  0 taken 0 (fallthrough)
branch  1 taken 578
branch  2 never executed
branch  3 never executed
    #####: 2442:    printf ("-%s", remote_description);
call    0 never executed
        -: 2443:
      578: 2444:  printf (", by Richard Stallman and Roland McGrath.\n\
call    0 returned 578
        -: 2445:%sCopyright (C) 1988, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98\n\
        -: 2446:%s\tFree Software Foundation, Inc.\n\
        -: 2447:%sThis is free software; see the source for copying conditions.\n\
        -: 2448:%sThere is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A\n\
        -: 2449:%sPARTICULAR PURPOSE.\n\n\
        -: 2450:%sReport bugs to <bug-make@gnu.org>.\n\n",
        -: 2451:	  precede, precede, precede, precede, precede, precede);
        -: 2452:
      578: 2453:  printed_version = 1;
        -: 2454:
        -: 2455:  /* Flush stdout so the user doesn't have to wait to see the
        -: 2456:     version information while things are thought about.  */
      578: 2457:  fflush (stdout);
call    0 returned 578
        -: 2458:}
        -: 2459:
        -: 2460:/* Print a bunch of information about this and that.  */
        -: 2461:
        -: 2462:static void
function print_data_base called 385 returned 100% blocks executed 100%
      385: 2463:print_data_base ()
        -: 2464:{
        -: 2465:  time_t when;
        -: 2466:
      385: 2467:  when = time ((time_t *) 0);
call    0 returned 385
      385: 2468:  printf ("\n# Make data base, printed on Sun Jan 01 2000 00:00:00");
call    0 returned 385
        -: 2469:
      385: 2470:  print_variable_data_base ();
call    0 returned 385
      385: 2471:  print_dir_data_base ();
call    0 returned 385
      385: 2472:  print_rule_data_base ();
call    0 returned 385
      385: 2473:  print_file_data_base ();
call    0 returned 385
      385: 2474:  print_vpath_data_base ();
call    0 returned 385
        -: 2475:
      385: 2476:  when = time ((time_t *) 0);
call    0 returned 385
      385: 2477:  printf ("\n# Finished Make data base on Sun Jan 01 2000 00:00:00");
call    0 returned 385
      385: 2478:}
        -: 2479:
        -: 2480:/* Exit with STATUS, cleaning up as necessary.  */
        -: 2481:
        -: 2482:void
function die called 793 returned 0% blocks executed 87%
      793: 2483:die (status)
        -: 2484:     int status;
        -: 2485:{
        -: 2486:  static char dying = 0;
        -: 2487:
      793: 2488:  if (!dying)
branch  0 taken 793 (fallthrough)
branch  1 taken 0
        -: 2489:    {
        -: 2490:      int err;
        -: 2491:
      793: 2492:      dying = 1;
        -: 2493:
      793: 2494:      if (print_version_flag)
branch  0 taken 1 (fallthrough)
branch  1 taken 792
        1: 2495:	print_version ();
call    0 returned 1
        -: 2496:
        -: 2497:      /* Wait for children to die.  */
     793*: 2498:      for (err = status != 0; job_slots_used > 0; err = 0)
branch  0 taken 0
branch  1 taken 793 (fallthrough)
    #####: 2499:	reap_children (1, err);
call    0 never executed
        -: 2500:
        -: 2501:      /* Let the remote job module clean up its state.  */
      793: 2502:      remote_cleanup ();
call    0 returned 793
        -: 2503:
        -: 2504:      /* Remove the intermediate files.  */
      793: 2505:      remove_intermediates (0);
call    0 returned 793
        -: 2506:
      793: 2507:      if (print_data_base_flag)
branch  0 taken 385 (fallthrough)
branch  1 taken 408
      385: 2508:	print_data_base ();
call    0 returned 385
        -: 2509:
        -: 2510:      /* Try to move back to the original directory.  This is essential on
        -: 2511:	 MS-DOS (where there is really only one process), and on Unix it
        -: 2512:	 puts core files in the original directory instead of the -C
        -: 2513:	 directory.  Must wait until after remove_intermediates(), or unlinks
        -: 2514:         of relative pathnames fail.  */
      793: 2515:      if (directory_before_chdir != 0)
branch  0 taken 793 (fallthrough)
branch  1 taken 0
      793: 2516:	chdir (directory_before_chdir);
call    0 returned 793
        -: 2517:
      793: 2518:      log_working_directory (0);
call    0 returned 793
        -: 2519:    }
        -: 2520:
      793: 2521:  exit (status);
        -: 2522:}
        -: 2523:
        -: 2524:/* Write a message indicating that we've just entered or
        -: 2525:   left (according to ENTERING) the current directory.  */
        -: 2526:
        -: 2527:void
function log_working_directory called 2956 returned 100% blocks executed 87%
     2956: 2528:log_working_directory (entering)
        -: 2529:     int entering;
        -: 2530:{
        -: 2531:  static int entered = 0;
     2956: 2532:  char *msg = entering ? "Entering" : "Leaving";
branch  0 taken 2163 (fallthrough)
branch  1 taken 793
        -: 2533:
        -: 2534:  /* Print nothing without the flag.  Don't print the entering message
        -: 2535:     again if we already have.  Don't print the leaving message if we
        -: 2536:     haven't printed the entering message.  */
     2956: 2537:  if (! print_directory_flag || entering == entered)
branch  0 taken 1413 (fallthrough)
branch  1 taken 1543
branch  2 taken 641 (fallthrough)
branch  3 taken 772
     2184: 2538:    return;
        -: 2539:
      772: 2540:  entered = entering;
        -: 2541:
      772: 2542:  if (print_data_base_flag)
branch  0 taken 384 (fallthrough)
branch  1 taken 388
      384: 2543:    fputs ("# ", stdout);
call    0 returned 384
        -: 2544:
      772: 2545:  if (makelevel == 0)
branch  0 taken 772 (fallthrough)
branch  1 taken 0
      772: 2546:    printf ("%s: %s ", program, msg);
call    0 returned 772
        -: 2547:  else
    #####: 2548:    printf ("%s[%u]: %s ", program, makelevel, msg);
call    0 never executed
        -: 2549:
      772: 2550:  if (starting_directory == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 772
    #####: 2551:    puts ("an unknown directory");
call    0 never executed
        -: 2552:  else
      772: 2553:    printf ("directory `%s'\n", starting_directory);
call    0 returned 772
        -: 2554:}
        -: 2555:
        -: 2556:
        -: 2557:
        -: 2558:/*************************************************************
        -: 2559:  ============================================================
        -: 2560:  ************************************************************
        -: 2561:  ============================================================
        -: 2562:  ************************************************************
        -: 2563:                         commands.c
        -: 2564:  ************************************************************
        -: 2565:  ============================================================
        -: 2566:  ************************************************************
        -: 2567:  ============================================================
        -: 2568:  *************************************************************/
        -: 2569:
        -: 2570:/* Command processing for GNU Make.
        -: 2571:Copyright (C) 1988,89,91,92,93,94,95,96,97 Free Software Foundation, Inc.
        -: 2572:This file is part of GNU Make.
        -: 2573:
        -: 2574:GNU Make is free software; you can redistribute it and/or modify
        -: 2575:it under the terms of the GNU General Public License as published by
        -: 2576:the Free Software Foundation; either version 2, or (at your option)
        -: 2577:any later version.
        -: 2578:
        -: 2579:GNU Make is distributed in the hope that it will be useful,
        -: 2580:but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 2581:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 2582:GNU General Public License for more details.
        -: 2583:
        -: 2584:You should have received a copy of the GNU General Public License
        -: 2585:along with GNU Make; see the file COPYING.  If not, write to
        -: 2586:the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
        -: 2587:
        -: 2588:
        -: 2589:extern int remote_kill PARAMS ((int id, int sig));
        -: 2590:
        -: 2591:#ifndef	HAVE_UNISTD_H
        -: 2592:extern int getpid ();
        -: 2593:#endif
        -: 2594:
        -: 2595:/* Set FILE's automatic variables up.  */
        -: 2596:
        -: 2597:static void
function set_file_variables called 4 returned 100% blocks executed 78%
        4: 2598:set_file_variables (file)
        -: 2599:     register struct file *file;
        -: 2600:{
        -: 2601:  register char *p;
        -: 2602:  char *at, *percent, *star, *less;
        -: 2603:
        -: 2604:#ifndef	NO_ARCHIVES
        -: 2605:  /* If the target is an archive member `lib(member)',
        -: 2606:     then $@ is `lib' and $% is `member'.  */
        -: 2607:
        4: 2608:  if (ar_name (file->name))
call    0 returned 4
branch  1 taken 0 (fallthrough)
branch  2 taken 4
        -: 2609:    {
        -: 2610:      unsigned int len;
    #####: 2611:      p = index (file->name, '(');
    #####: 2612:      at = (char *) alloca (p - file->name + 1);
    #####: 2613:      bcopy (file->name, at, p - file->name);
    #####: 2614:      at[p - file->name] = '\0';
    #####: 2615:      len = strlen (p + 1);
    #####: 2616:      percent = (char *) alloca (len);
    #####: 2617:      bcopy (p + 1, percent, len - 1);
    #####: 2618:      percent[len - 1] = '\0';
        -: 2619:    }
        -: 2620:  else
        -: 2621:#endif	/* NO_ARCHIVES.  */
        -: 2622:    {
        4: 2623:      at = file->name;
        4: 2624:      percent = "";
        -: 2625:    }
        -: 2626:
        -: 2627:  /* $* is the stem from an implicit or static pattern rule.  */
        4: 2628:  if (file->stem == 0)
branch  0 taken 2 (fallthrough)
branch  1 taken 2
        -: 2629:    {
        -: 2630:      /* In Unix make, $* is set to the target name with
        -: 2631:	 any suffix in the .SUFFIXES list stripped off for
        -: 2632:	 explicit rules.  We store this in the `stem' member.  */
        -: 2633:      register struct dep *d;
        -: 2634:      char *name;
        -: 2635:      unsigned int len;
        -: 2636:
        -: 2637:#ifndef	NO_ARCHIVES
        2: 2638:      if (ar_name (file->name))
call    0 returned 2
branch  1 taken 0 (fallthrough)
branch  2 taken 2
        -: 2639:	{
    #####: 2640:	  name = index (file->name, '(') + 1;
    #####: 2641:	  len = strlen (name) - 1;
        -: 2642:	}
        -: 2643:      else
        -: 2644:#endif
        -: 2645:	{
        2: 2646:	  name = file->name;
        2: 2647:	  len = strlen (name);
        -: 2648:	}
        -: 2649:
       66: 2650:      for (d = enter_file (".SUFFIXES")->deps; d != 0; d = d->next)
call    0 returned 2
branch  1 taken 64
branch  2 taken 2 (fallthrough)
        -: 2651:	{
      64*: 2652:	  unsigned int slen = strlen (dep_name (d));
branch  0 taken 64 (fallthrough)
branch  1 taken 0
      64*: 2653:	  if (len > slen && !strncmp (dep_name (d), name + (len - slen), slen))
branch  0 taken 56 (fallthrough)
branch  1 taken 8
branch  2 taken 56 (fallthrough)
branch  3 taken 0
branch  4 taken 0 (fallthrough)
branch  5 taken 56
        -: 2654:	    {
    #####: 2655:	      file->stem = savestring (name, len - slen);
call    0 never executed
    #####: 2656:	      break;
        -: 2657:	    }
        -: 2658:	}
        2: 2659:      if (d == 0)
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2: 2660:	file->stem = "";
        -: 2661:    }
        4: 2662:  star = file->stem;
        -: 2663:
        -: 2664:  /* $< is the first dependency.  */
       4*: 2665:  less = file->deps != 0 ? dep_name (file->deps) : "";
branch  0 taken 4 (fallthrough)
branch  1 taken 0
branch  2 taken 4 (fallthrough)
branch  3 taken 0
        -: 2666:
        4: 2667:  if (file->cmds == default_file->cmds)
branch  0 taken 0 (fallthrough)
branch  1 taken 4
        -: 2668:    /* This file got its commands from .DEFAULT.
        -: 2669:       In this case $< is the same as $@.  */
    #####: 2670:    less = at;
        -: 2671:
        -: 2672:#define	DEFINE_VARIABLE(name, len, value) \
        -: 2673:  (void) define_variable_for_file (name, len, value, o_automatic, 0, file)
        -: 2674:
        -: 2675:  /* Define the variables.  */
        -: 2676:
        4: 2677:  DEFINE_VARIABLE ("<", 1, less);
call    0 returned 4
        4: 2678:  DEFINE_VARIABLE ("*", 1, star);
call    0 returned 4
        4: 2679:  DEFINE_VARIABLE ("@", 1, at);
call    0 returned 4
        4: 2680:  DEFINE_VARIABLE ("%", 1, percent);
call    0 returned 4
        -: 2681:
        -: 2682:  /* Compute the values for $^, $+, and $?.  */
        -: 2683:
        -: 2684:  {
        -: 2685:    register unsigned int qmark_len, plus_len;
        -: 2686:    char *caret_value, *plus_value;
        -: 2687:    register char *cp;
        -: 2688:    char *qmark_value;
        -: 2689:    register char *qp;
        -: 2690:    register struct dep *d;
        -: 2691:    unsigned int len;
        -: 2692:
        -: 2693:    /* Compute first the value for $+, which is supposed to contain
        -: 2694:       duplicate dependencies as they were listed in the makefile.  */
        -: 2695:
        4: 2696:    plus_len = 0;
       16: 2697:    for (d = file->deps; d != 0; d = d->next)
branch  0 taken 12
branch  1 taken 4 (fallthrough)
      12*: 2698:      plus_len += strlen (dep_name (d)) + 1;
branch  0 taken 12 (fallthrough)
branch  1 taken 0
        -: 2699:
       4*: 2700:    len = plus_len == 0 ? 1 : plus_len;
branch  0 taken 4 (fallthrough)
branch  1 taken 0
        4: 2701:    cp = plus_value = (char *) alloca (len);
        -: 2702:
        4: 2703:    qmark_len = plus_len;	/* Will be this or less.  */
       16: 2704:    for (d = file->deps; d != 0; d = d->next)
branch  0 taken 12
branch  1 taken 4 (fallthrough)
        -: 2705:      {
      12*: 2706:	char *c = dep_name (d);
branch  0 taken 12 (fallthrough)
branch  1 taken 0
        -: 2707:
        -: 2708:#ifndef	NO_ARCHIVES
       12: 2709:	if (ar_name (c))
call    0 returned 12
branch  1 taken 0 (fallthrough)
branch  2 taken 12
        -: 2710:	  {
    #####: 2711:	    c = index (c, '(') + 1;
    #####: 2712:	    len = strlen (c) - 1;
        -: 2713:	  }
        -: 2714:	else
        -: 2715:#endif
       12: 2716:	  len = strlen (c);
        -: 2717:
       12: 2718:	bcopy (c, cp, len);
       12: 2719:	cp += len;
        -: 2720:#if VMS
        -: 2721:        *cp++ = ',';
        -: 2722:#else
       12: 2723:	*cp++ = ' ';
        -: 2724:#endif
       12: 2725:	if (! d->changed)
branch  0 taken 5 (fallthrough)
branch  1 taken 7
        5: 2726:	  qmark_len -= len + 1;	/* Don't space in $? for this one.  */
        -: 2727:      }
        -: 2728:
        -: 2729:    /* Kill the last space and define the variable.  */
        -: 2730:
       4*: 2731:    cp[cp > plus_value ? -1 : 0] = '\0';
branch  0 taken 4 (fallthrough)
branch  1 taken 0
        4: 2732:    DEFINE_VARIABLE ("+", 1, plus_value);
call    0 returned 4
        -: 2733:
        -: 2734:    /* Make sure that no dependencies are repeated.  This does not
        -: 2735:       really matter for the purpose of updating targets, but it
        -: 2736:       might make some names be listed twice for $^ and $?.  */
        -: 2737:
        4: 2738:    uniquize_deps (file->deps);
call    0 returned 4
        -: 2739:
        -: 2740:    /* Compute the values for $^ and $?.  */
        -: 2741:
        4: 2742:    cp = caret_value = plus_value; /* Reuse the buffer; it's big enough.  */
       4*: 2743:    len = qmark_len == 0 ? 1 : qmark_len;
branch  0 taken 4 (fallthrough)
branch  1 taken 0
        4: 2744:    qp = qmark_value = (char *) alloca (len);
        -: 2745:
       16: 2746:    for (d = file->deps; d != 0; d = d->next)
branch  0 taken 12
branch  1 taken 4 (fallthrough)
        -: 2747:      {
      12*: 2748:	char *c = dep_name (d);
branch  0 taken 12 (fallthrough)
branch  1 taken 0
        -: 2749:
        -: 2750:#ifndef	NO_ARCHIVES
       12: 2751:	if (ar_name (c))
call    0 returned 12
branch  1 taken 0 (fallthrough)
branch  2 taken 12
        -: 2752:	  {
    #####: 2753:	    c = index (c, '(') + 1;
    #####: 2754:	    len = strlen (c) - 1;
        -: 2755:	  }
        -: 2756:	else
        -: 2757:#endif
       12: 2758:	  len = strlen (c);
        -: 2759:
       12: 2760:	bcopy (c, cp, len);
       12: 2761:	cp += len;
        -: 2762:#if VMS
        -: 2763:	*cp++ = ',';
        -: 2764:#else
       12: 2765:	*cp++ = ' ';
        -: 2766:#endif
       12: 2767:	if (d->changed)
branch  0 taken 7 (fallthrough)
branch  1 taken 5
        -: 2768:	  {
        7: 2769:	    bcopy (c, qp, len);
        7: 2770:	    qp += len;
        -: 2771:#if VMS
        -: 2772:	    *qp++ = ',';
        -: 2773:#else
        7: 2774:	    *qp++ = ' ';
        -: 2775:#endif
        -: 2776:	  }
        -: 2777:      }
        -: 2778:
        -: 2779:    /* Kill the last spaces and define the variables.  */
        -: 2780:
       4*: 2781:    cp[cp > caret_value ? -1 : 0] = '\0';
branch  0 taken 4 (fallthrough)
branch  1 taken 0
        4: 2782:    DEFINE_VARIABLE ("^", 1, caret_value);
call    0 returned 4
        -: 2783:
       4*: 2784:    qp[qp > qmark_value ? -1 : 0] = '\0';
branch  0 taken 4 (fallthrough)
branch  1 taken 0
        4: 2785:    DEFINE_VARIABLE ("?", 1, qmark_value);
call    0 returned 4
        -: 2786:  }
        -: 2787:
        -: 2788:#undef	DEFINE_VARIABLE
        4: 2789:}
        -: 2790:
        -: 2791:/* Chop CMDS up into individual command lines if necessary.
        -: 2792:   Also set the `lines_flag' and `any_recurse' members.  */
        -: 2793:
        -: 2794:void
function chop_commands called 8 returned 100% blocks executed 73%
        8: 2795:chop_commands (cmds)
        -: 2796:     register struct commands *cmds;
        -: 2797:{
        8: 2798:  if (cmds != 0 && cmds->command_lines == 0)
branch  0 taken 8 (fallthrough)
branch  1 taken 0
branch  2 taken 4 (fallthrough)
branch  3 taken 4
        -: 2799:    {
        -: 2800:      /* Chop CMDS->commands up into lines in CMDS->command_lines.
        -: 2801:	 Also set the corresponding CMDS->lines_flags elements,
        -: 2802:	 and the CMDS->any_recurse flag.  */
        -: 2803:      register char *p;
        -: 2804:      unsigned int nlines, idx;
        -: 2805:      char **lines;
        -: 2806:
        4: 2807:      nlines = 5;
        4: 2808:      lines = (char **) xmalloc (5 * sizeof (char *));
call    0 returned 4
        4: 2809:      idx = 0;
        4: 2810:      p = cmds->commands;
        8: 2811:      while (*p != '\0')
branch  0 taken 4
branch  1 taken 4 (fallthrough)
        -: 2812:	{
        4: 2813:	  char *end = p;
        4: 2814:	find_end:;
        4: 2815:	  end = index (end, '\n');
        4: 2816:	  if (end == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 4
    #####: 2817:	    end = p + strlen (p);
        4: 2818:	  else if (end > p && end[-1] == '\\')
branch  0 taken 4 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 4
        -: 2819:	    {
    #####: 2820:	      int backslash = 1;
        -: 2821:	      register char *b;
    #####: 2822:	      for (b = end - 2; b >= p && *b == '\\'; --b)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2823:		backslash = !backslash;
    #####: 2824:	      if (backslash)
branch  0 never executed
branch  1 never executed
        -: 2825:		{
    #####: 2826:		  ++end;
    #####: 2827:		  goto find_end;
        -: 2828:		}
        -: 2829:	    }
        -: 2830:
        4: 2831:	  if (idx == nlines)
branch  0 taken 0 (fallthrough)
branch  1 taken 4
        -: 2832:	    {
    #####: 2833:	      nlines += 2;
    #####: 2834:	      lines = (char **) xrealloc ((char *) lines,
call    0 never executed
        -: 2835:					  nlines * sizeof (char *));
        -: 2836:	    }
        4: 2837:	  lines[idx++] = savestring (p, end - p);
call    0 returned 4
        4: 2838:	  p = end;
        4: 2839:	  if (*p != '\0')
branch  0 taken 4 (fallthrough)
branch  1 taken 0
        4: 2840:	    ++p;
        -: 2841:	}
        -: 2842:
        4: 2843:      if (idx != nlines)
branch  0 taken 4 (fallthrough)
branch  1 taken 0
        -: 2844:	{
        4: 2845:	  nlines = idx;
        4: 2846:	  lines = (char **) xrealloc ((char *) lines,
call    0 returned 4
        -: 2847:				      nlines * sizeof (char *));
        -: 2848:	}
        -: 2849:
        4: 2850:      cmds->ncommand_lines = nlines;
        4: 2851:      cmds->command_lines = lines;
        -: 2852:
        4: 2853:      cmds->any_recurse = 0;
        4: 2854:      cmds->lines_flags = (char *) xmalloc (nlines);
call    0 returned 4
        8: 2855:      for (idx = 0; idx < nlines; ++idx)
branch  0 taken 4
branch  1 taken 4 (fallthrough)
        -: 2856:	{
        4: 2857:	  int flags = 0;
        -: 2858:
        4: 2859:	  for (p = lines[idx];
        8: 2860:	       isblank (*p) || *p == '-' || *p == '@' || *p == '+';
branch  0 taken 4
branch  1 taken 4 (fallthrough)
branch  2 taken 0
branch  3 taken 4 (fallthrough)
branch  4 taken 0
branch  5 taken 4 (fallthrough)
branch  6 taken 0
branch  7 taken 4 (fallthrough)
        4: 2861:	       ++p)
        4: 2862:	    switch (*p)
branch  0 taken 0
branch  1 taken 0
branch  2 taken 0
branch  3 taken 4
        -: 2863:	      {
    #####: 2864:	      case '+':
    #####: 2865:		flags |= COMMANDS_RECURSE;
    #####: 2866:		break;
    #####: 2867:	      case '@':
    #####: 2868:		flags |= COMMANDS_SILENT;
    #####: 2869:		break;
    #####: 2870:	      case '-':
    #####: 2871:		flags |= COMMANDS_NOERROR;
    #####: 2872:		break;
        -: 2873:	      }
        4: 2874:	  if (!(flags & COMMANDS_RECURSE))
branch  0 taken 4 (fallthrough)
branch  1 taken 0
        -: 2875:	    {
        4: 2876:	      unsigned int len = strlen (p);
        4: 2877:	      if (sindex (p, len, "$(MAKE)", 7) != 0
call    0 returned 4
branch  1 taken 4 (fallthrough)
branch  2 taken 0
        4: 2878:		  || sindex (p, len, "${MAKE}", 7) != 0)
call    0 returned 4
branch  1 taken 0 (fallthrough)
branch  2 taken 4
    #####: 2879:		flags |= COMMANDS_RECURSE;
        -: 2880:	    }
        -: 2881:
        4: 2882:	  cmds->lines_flags[idx] = flags;
        4: 2883:	  cmds->any_recurse |= flags & COMMANDS_RECURSE;
        -: 2884:	}
        -: 2885:    }
        8: 2886:}
        -: 2887:
        -: 2888:/* Execute the commands to remake FILE.  If they are currently executing,
        -: 2889:   return or have already finished executing, just return.  Otherwise,
        -: 2890:   fork off a child process to run the first command line in the sequence.  */
        -: 2891:
        -: 2892:void
function execute_file_commands called 4 returned 50% blocks executed 86%
        4: 2893:execute_file_commands (file)
        -: 2894:     struct file *file;
        -: 2895:{
        -: 2896:  register char *p;
        -: 2897:
        -: 2898:  /* Don't go through all the preparations if
        -: 2899:     the commands are nothing but whitespace.  */
        -: 2900:
        8: 2901:  for (p = file->cmds->commands; *p != '\0'; ++p)
branch  0 taken 8
branch  1 taken 0 (fallthrough)
        8: 2902:    if (!isspace (*p) && *p != '-' && *p != '@')
branch  0 taken 4 (fallthrough)
branch  1 taken 4
branch  2 taken 4 (fallthrough)
branch  3 taken 0
branch  4 taken 4 (fallthrough)
branch  5 taken 0
        4: 2903:      break;
        4: 2904:  if (*p == '\0')
branch  0 taken 0 (fallthrough)
branch  1 taken 4
        -: 2905:    {
        -: 2906:      /* We are all out of commands.
        -: 2907:	 If we have gotten this far, all the previous commands
        -: 2908:	 have run successfully, so we have winning update status.  */
    #####: 2909:      file->update_status = 0;
    #####: 2910:      notice_finished_file (file);
call    0 never executed
    #####: 2911:      return;
        -: 2912:    }
        -: 2913:
        -: 2914:  /* First set the automatic variables according to this file.  */
        -: 2915:
        4: 2916:  initialize_file_variables (file);
call    0 returned 4
        -: 2917:
        4: 2918:  set_file_variables (file);
call    0 returned 4
        -: 2919:
        -: 2920:  /* Start the commands running.  */
        4: 2921:  new_job (file);
call    0 returned 2
        -: 2922:}
        -: 2923:
        -: 2924:/* This is set while we are inside fatal_error_signal,
        -: 2925:   so things can avoid nonreentrant operations.  */
        -: 2926:
        -: 2927:int handling_fatal_signal = 0;
        -: 2928:
        -: 2929:/* Handle fatal signals.  */
        -: 2930:
        -: 2931:RETSIGTYPE
function fatal_error_signal called 0 returned 0% blocks executed 0%
    #####: 2932:fatal_error_signal (sig)
        -: 2933:     int sig;
        -: 2934:{
        -: 2935:#ifdef __MSDOS__
        -: 2936:  extern int dos_status, dos_command_running;
        -: 2937:
        -: 2938:  if (dos_command_running)
        -: 2939:    {
        -: 2940:      /* That was the child who got the signal, not us.  */
        -: 2941:      dos_status |= (sig << 8);
        -: 2942:      return;
        -: 2943:    }
        -: 2944:  remove_intermediates (1);
        -: 2945:  exit (1);
        -: 2946:#else /* not __MSDOS__ */
        -: 2947:#ifdef _AMIGA
        -: 2948:  remove_intermediates (1);
        -: 2949:  if (sig == SIGINT)
        -: 2950:     fputs ("*** Break.\n", stderr);
        -: 2951:
        -: 2952:  exit (10);
        -: 2953:#else /* not Amiga */
    #####: 2954:  handling_fatal_signal = 1;
        -: 2955:
        -: 2956:  /* Set the handling for this signal to the default.
        -: 2957:     It is blocked now while we run this handler.  */
    #####: 2958:  signal (sig, SIG_DFL);
call    0 never executed
        -: 2959:
        -: 2960:  /* A termination signal won't be sent to the entire
        -: 2961:     process group, but it means we want to kill the children.  */
        -: 2962:
    #####: 2963:  if (sig == SIGTERM)
branch  0 never executed
branch  1 never executed
        -: 2964:    {
        -: 2965:      register struct child *c;
    #####: 2966:      for (c = children; c != 0; c = c->next)
branch  0 never executed
branch  1 never executed
    #####: 2967:	if (!c->remote)
branch  0 never executed
branch  1 never executed
    #####: 2968:	  (void) kill (c->pid, SIGTERM);
call    0 never executed
        -: 2969:    }
        -: 2970:
        -: 2971:  /* If we got a signal that means the user
        -: 2972:     wanted to kill make, remove pending targets.  */
        -: 2973:
    #####: 2974:  if (sig == SIGTERM || sig == SIGINT
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2975:#ifdef SIGHUP
    #####: 2976:    || sig == SIGHUP
branch  0 never executed
branch  1 never executed
        -: 2977:#endif
        -: 2978:#ifdef SIGQUIT
    #####: 2979:    || sig == SIGQUIT
branch  0 never executed
branch  1 never executed
        -: 2980:#endif
        -: 2981:    )
    #####: 2982:    {
        -: 2983:      register struct child *c;
        -: 2984:
        -: 2985:      /* Remote children won't automatically get signals sent
        -: 2986:	 to the process group, so we must send them.  */
    #####: 2987:      for (c = children; c != 0; c = c->next)
branch  0 never executed
branch  1 never executed
    #####: 2988:	if (c->remote)
branch  0 never executed
branch  1 never executed
    #####: 2989:	  (void) remote_kill (c->pid, sig);
call    0 never executed
        -: 2990:
    #####: 2991:      for (c = children; c != 0; c = c->next)
branch  0 never executed
branch  1 never executed
    #####: 2992:	delete_child_targets (c);
call    0 never executed
        -: 2993:
        -: 2994:      /* Clean up the children.  We don't just use the call below because
        -: 2995:	 we don't want to print the "Waiting for children" message.  */
    #####: 2996:      while (job_slots_used > 0)
branch  0 never executed
branch  1 never executed
    #####: 2997:	reap_children (1, 0);
call    0 never executed
        -: 2998:    }
        -: 2999:  else
        -: 3000:    /* Wait for our children to die.  */
    #####: 3001:    while (job_slots_used > 0)
branch  0 never executed
branch  1 never executed
    #####: 3002:      reap_children (1, 1);
call    0 never executed
        -: 3003:
        -: 3004:  /* Delete any non-precious intermediate files that were made.  */
        -: 3005:
    #####: 3006:  remove_intermediates (1);
call    0 never executed
        -: 3007:
        -: 3008:#ifdef SIGQUIT
    #####: 3009:  if (sig == SIGQUIT)
branch  0 never executed
branch  1 never executed
        -: 3010:    /* We don't want to send ourselves SIGQUIT, because it will
        -: 3011:       cause a core dump.  Just exit instead.  */
    #####: 3012:    exit (EXIT_FAILURE);
call    0 never executed
        -: 3013:#endif
        -: 3014:
        -: 3015:  /* Signal the same code; this time it will really be fatal.  The signal
        -: 3016:     will be unblocked when we return and arrive then to kill us.  */
    #####: 3017:  if (kill (getpid (), sig) < 0)
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3018:    pfatal_with_name ("kill");
call    0 never executed
        -: 3019:#endif /* not Amiga */
        -: 3020:#endif /* not __MSDOS__  */
    #####: 3021:}
        -: 3022:
        -: 3023:/* Delete FILE unless it's precious or not actually a file (phony),
        -: 3024:   and it has changed on disk since we last stat'd it.  */
        -: 3025:
        -: 3026:static void
function delete_target called 0 returned 0% blocks executed 0%
    #####: 3027:delete_target (file, on_behalf_of)
        -: 3028:     struct file *file;
        -: 3029:     char *on_behalf_of;
        -: 3030:{
        -: 3031:  struct stat st;
        -: 3032:
    #####: 3033:  if (file->precious || file->phony)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3034:    return;
        -: 3035:
        -: 3036:#ifndef NO_ARCHIVES
    #####: 3037:  if (ar_name (file->name))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 3038:    {
    #####: 3039:      if (ar_member_date (file->name) != file->last_mtime)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 3040:	{
    #####: 3041:	  if (on_behalf_of)
branch  0 never executed
branch  1 never executed
    #####: 3042:	    error ("*** [%s] Archive member `%s' may be bogus; not deleted",
call    0 never executed
        -: 3043:		   on_behalf_of, file->name);
        -: 3044:	  else
    #####: 3045:	    error ("*** Archive member `%s' may be bogus; not deleted",
call    0 never executed
        -: 3046:		   file->name);
        -: 3047:	}
    #####: 3048:      return;
        -: 3049:    }
        -: 3050:#endif
        -: 3051:
    #####: 3052:  if (stat (file->name, &st) == 0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3053:      && S_ISREG (st.st_mode)
branch  0 never executed
branch  1 never executed
    #####: 3054:      && (time_t) st.st_mtime != file->last_mtime)
branch  0 never executed
branch  1 never executed
        -: 3055:    {
    #####: 3056:      if (on_behalf_of)
branch  0 never executed
branch  1 never executed
    #####: 3057:	error ("*** [%s] Deleting file `%s'", on_behalf_of, file->name);
call    0 never executed
        -: 3058:      else
    #####: 3059:	error ("*** Deleting file `%s'", file->name);
call    0 never executed
    #####: 3060:      if (unlink (file->name) < 0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3061:	  && errno != ENOENT)	/* It disappeared; so what.  */
branch  0 never executed
branch  1 never executed
    #####: 3062:	perror_with_name ("unlink: ", file->name);
call    0 never executed
        -: 3063:    }
        -: 3064:}
        -: 3065:
        -: 3066:
        -: 3067:/* Delete all non-precious targets of CHILD unless they were already deleted.
        -: 3068:   Set the flag in CHILD to say they've been deleted.  */
        -: 3069:
        -: 3070:void
function delete_child_targets called 0 returned 0% blocks executed 0%
    #####: 3071:delete_child_targets (child)
        -: 3072:     struct child *child;
        -: 3073:{
        -: 3074:  struct dep *d;
        -: 3075:
    #####: 3076:  if (child->deleted)
branch  0 never executed
branch  1 never executed
    #####: 3077:    return;
        -: 3078:
        -: 3079:  /* Delete the target file if it changed.  */
    #####: 3080:  delete_target (child->file, (char *) 0);
call    0 never executed
        -: 3081:
        -: 3082:  /* Also remove any non-precious targets listed in the `also_make' member.  */
    #####: 3083:  for (d = child->file->also_make; d != 0; d = d->next)
branch  0 never executed
branch  1 never executed
    #####: 3084:    delete_target (d->file, child->file->name);
call    0 never executed
        -: 3085:
    #####: 3086:  child->deleted = 1;
        -: 3087:}
        -: 3088:
        -: 3089:/* Print out the commands in CMDS.  */
        -: 3090:
        -: 3091:void
function print_commands called 38115 returned 100% blocks executed 93%
    38115: 3092:print_commands (cmds)
        -: 3093:     register struct commands *cmds;
        -: 3094:{
        -: 3095:  register char *s;
        -: 3096:
    38115: 3097:  fputs ("#  commands to execute", stdout);
call    0 returned 38115
        -: 3098:
    38115: 3099:  if (cmds->filename == 0)
branch  0 taken 38115 (fallthrough)
branch  1 taken 0
    38115: 3100:    puts (" (built-in):");
call    0 returned 38115
        -: 3101:  else
    #####: 3102:    printf (" (from `%s', line %u):\n", cmds->filename, cmds->lineno);
call    0 never executed
        -: 3103:
    38115: 3104:  s = cmds->commands;
    83545: 3105:  while (*s != '\0')
branch  0 taken 45430
branch  1 taken 38115 (fallthrough)
        -: 3106:    {
        -: 3107:      char *end;
        -: 3108:
    59290: 3109:      while (isspace (*s))
branch  0 taken 13860
branch  1 taken 45430 (fallthrough)
    13860: 3110:	++s;
        -: 3111:
    45430: 3112:      end = index (s, '\n');
    45430: 3113:      if (end == 0)
branch  0 taken 38115 (fallthrough)
branch  1 taken 7315
    38115: 3114:	end = s + strlen (s);
        -: 3115:
    45430: 3116:      printf ("\t%.*s\n", (int) (end - s), s);
call    0 returned 45430
        -: 3117:
    45430: 3118:      s = end;
        -: 3119:    }
    38115: 3120:}
        -: 3121:
        -: 3122:
        -: 3123:
        -: 3124:/*************************************************************
        -: 3125:  ============================================================
        -: 3126:  ************************************************************
        -: 3127:  ============================================================
        -: 3128:  ************************************************************
        -: 3129:                         job.c
        -: 3130:  ************************************************************
        -: 3131:  ============================================================
        -: 3132:  ************************************************************
        -: 3133:  ============================================================
        -: 3134:  *************************************************************/
        -: 3135:
        -: 3136:/* Job execution and handling for GNU Make.
        -: 3137:Copyright (C) 1988,89,90,91,92,93,94,95,96,97 Free Software Foundation, Inc.
        -: 3138:This file is part of GNU Make.
        -: 3139:
        -: 3140:GNU Make is free software; you can redistribute it and/or modify
        -: 3141:it under the terms of the GNU General Public License as published by
        -: 3142:the Free Software Foundation; either version 2, or (at your option)
        -: 3143:any later version.
        -: 3144:
        -: 3145:GNU Make is distributed in the hope that it will be useful,
        -: 3146:but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 3147:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 3148:GNU General Public License for more details.
        -: 3149:
        -: 3150:You should have received a copy of the GNU General Public License
        -: 3151:along with GNU Make; see the file COPYING.  If not, write to
        -: 3152:the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
        -: 3153:
        -: 3154:
        -: 3155:
        -: 3156:/* Default shell to use.  */
        -: 3157:#ifdef WINDOWS32
        -: 3158:char *default_shell = "sh.exe";
        -: 3159:int no_default_sh_exe = 1;
        -: 3160:int batch_mode_shell = 1;
        -: 3161:#else  /* WINDOWS32 */
        -: 3162:#ifdef _AMIGA
        -: 3163:char default_shell[] = "";
        -: 3164:extern int MyExecute (char **);
        -: 3165:#else /* _AMIGA */
        -: 3166:#ifdef __MSDOS__
        -: 3167:/* The default shell is a pointer so we can change it if Makefile
        -: 3168:   says so.  It is without an explicit path so we get a chance
        -: 3169:   to search the $PATH for it (since MSDOS doesn't have standard
        -: 3170:   directories we could trust).  */
        -: 3171:char *default_shell = "command.com";
        -: 3172:#else  /* __MSDOS__ */
        -: 3173:char default_shell[] = "/bin/sh";
        -: 3174:#endif /* __MSDOS__ */
        -: 3175:int batch_mode_shell = 0;
        -: 3176:#endif /* _AMIGA */
        -: 3177:#endif /* WINDOWS32 */
        -: 3178:
        -: 3179:#ifdef __MSDOS__
        -: 3180:#include <process.h>
        -: 3181:#undef stderr
        -: 3182:#define stderr stdout
        -: 3183:static int execute_by_shell;
        -: 3184:static int dos_pid = 123;
        -: 3185:int dos_status;
        -: 3186:int dos_command_running;
        -: 3187:#endif /* __MSDOS__ */
        -: 3188:
        -: 3189:#ifdef _AMIGA
        -: 3190:#include <proto/dos.h>
        -: 3191:#undef stderr
        -: 3192:#define stderr stdout
        -: 3193:static int amiga_pid = 123;
        -: 3194:static int amiga_status;
        -: 3195:static char amiga_bname[32];
        -: 3196:static int amiga_batch_file;
        -: 3197:#endif /* Amiga.  */
        -: 3198:
        -: 3199:#ifdef VMS
        -: 3200:#include <time.h>
        -: 3201:#include <processes.h>
        -: 3202:#include <starlet.h>
        -: 3203:#include <lib$routines.h>
        -: 3204:#undef stderr
        -: 3205:#define stderr stdout
        -: 3206:#endif
        -: 3207:
        -: 3208:#ifdef WINDOWS32
        -: 3209:#include <windows.h>
        -: 3210:#include <io.h>
        -: 3211:#include <process.h>
        -: 3212:#include "sub_proc.h"
        -: 3213:#include "w32err.h"
        -: 3214:#include "pathstuff.h"
        -: 3215:#undef stderr
        -: 3216:#define stderr stdout
        -: 3217:#endif /* WINDOWS32 */
        -: 3218:
        -: 3219:#ifdef HAVE_FCNTL_H
        -: 3220:#include <fcntl.h>
        -: 3221:#undef stderr
        -: 3222:#define stderr stdout
        -: 3223:#else
        -: 3224:#include <sys/file.h>
        -: 3225:#undef stderr
        -: 3226:#define stderr stdout
        -: 3227:#endif
        -: 3228:
        -: 3229:#if defined (HAVE_SYS_WAIT_H) || defined (HAVE_UNION_WAIT)
        -: 3230:#include <sys/wait.h>
        -: 3231:#undef stderr
        -: 3232:#define stderr stdout
        -: 3233:#endif
        -: 3234:
        -: 3235:#ifdef	HAVE_WAITPID
        -: 3236:#define	WAIT_NOHANG(status)	waitpid (-1, (status), WNOHANG)
        -: 3237:#else	/* Don't have waitpid.  */
        -: 3238:#ifdef	HAVE_WAIT3
        -: 3239:#ifndef	wait3
        -: 3240:extern int wait3 ();
        -: 3241:#endif
        -: 3242:#define	WAIT_NOHANG(status)	wait3 ((status), WNOHANG, (struct rusage *) 0)
        -: 3243:#endif	/* Have wait3.  */
        -: 3244:#endif	/* Have waitpid.  */
        -: 3245:
        -: 3246:#if	!defined (wait) && !defined (POSIX)
        -: 3247:extern int wait ();
        -: 3248:#endif
        -: 3249:
        -: 3250:#ifndef	HAVE_UNION_WAIT
        -: 3251:
        -: 3252:#define	WAIT_T int
        -: 3253:
        -: 3254:#ifndef	WTERMSIG
        -: 3255:#define WTERMSIG(x) ((x) & 0x7f)
        -: 3256:#endif
        -: 3257:#ifndef	WCOREDUMP
        -: 3258:#define WCOREDUMP(x) ((x) & 0x80)
        -: 3259:#endif
        -: 3260:#ifndef	WEXITSTATUS
        -: 3261:#define WEXITSTATUS(x) (((x) >> 8) & 0xff)
        -: 3262:#endif
        -: 3263:#ifndef	WIFSIGNALED
        -: 3264:#define WIFSIGNALED(x) (WTERMSIG (x) != 0)
        -: 3265:#endif
        -: 3266:#ifndef	WIFEXITED
        -: 3267:#define WIFEXITED(x) (WTERMSIG (x) == 0)
        -: 3268:#endif
        -: 3269:
        -: 3270:#else	/* Have `union wait'.  */
        -: 3271:
        -: 3272:#define WAIT_T union wait
        -: 3273:#ifndef	WTERMSIG
        -: 3274:#define WTERMSIG(x)	((x).w_termsig)
        -: 3275:#endif
        -: 3276:#ifndef	WCOREDUMP
        -: 3277:#define WCOREDUMP(x)	((x).w_coredump)
        -: 3278:#endif
        -: 3279:#ifndef WEXITSTATUS
        -: 3280:#define WEXITSTATUS(x)	((x).w_retcode)
        -: 3281:#endif
        -: 3282:#ifndef	WIFSIGNALED
        -: 3283:#define	WIFSIGNALED(x)	(WTERMSIG(x) != 0)
        -: 3284:#endif
        -: 3285:#ifndef	WIFEXITED
        -: 3286:#define	WIFEXITED(x)	(WTERMSIG(x) == 0)
        -: 3287:#endif
        -: 3288:
        -: 3289:#endif	/* Don't have `union wait'.  */
        -: 3290:
        -: 3291:#ifdef VMS
        -: 3292:static int vms_jobsefnmask=0;
        -: 3293:#endif /* !VMS */
        -: 3294:
        -: 3295:#ifndef	HAVE_UNISTD_H
        -: 3296:extern int dup2 ();
        -: 3297:extern int execve ();
        -: 3298:extern void _exit ();
        -: 3299:#ifndef VMS
        -: 3300:extern int geteuid ();
        -: 3301:extern int getegid ();
        -: 3302:extern int setgid ();
        -: 3303:extern int getgid ();
        -: 3304:#endif
        -: 3305:#endif
        -: 3306:
        -: 3307:extern char *allocated_variable_expand_for_file PARAMS ((char *line, struct file *file));
        -: 3308:
        -: 3309:extern int getloadavg PARAMS ((double loadavg[], int nelem));
        -: 3310:extern int start_remote_job PARAMS ((char **argv, char **envp, int stdin_fd,
        -: 3311:		int *is_remote, int *id_ptr, int *used_stdin));
        -: 3312:extern int start_remote_job_p PARAMS ((int));
        -: 3313:extern int remote_status PARAMS ((int *exit_code_ptr, int *signal_ptr,
        -: 3314:		int *coredump_ptr, int block));
        -: 3315:
        -: 3316:RETSIGTYPE child_handler PARAMS ((int));
        -: 3317:static void free_child PARAMS ((struct child *));
        -: 3318:static void start_job_command PARAMS ((struct child *child));
        -: 3319:static int load_too_high PARAMS ((void));
        -: 3320:static int job_next_command PARAMS ((struct child *));
        -: 3321:static int start_waiting_job PARAMS ((struct child *));
        -: 3322:#ifdef VMS
        -: 3323:static void vmsWaitForChildren PARAMS ((int *));
        -: 3324:#endif
        -: 3325:
        -: 3326:/* Chain of all live (or recently deceased) children.  */
        -: 3327:
        -: 3328:struct child *children = 0;
        -: 3329:
        -: 3330:/* Number of children currently running.  */
        -: 3331:
        -: 3332:unsigned int job_slots_used = 0;
        -: 3333:
        -: 3334:/* Nonzero if the `good' standard input is in use.  */
        -: 3335:
        -: 3336:static int good_stdin_used = 0;
        -: 3337:
        -: 3338:/* Chain of children waiting to run until the load average goes down.  */
        -: 3339:
        -: 3340:static struct child *waiting_jobs = 0;
        -: 3341:
        -: 3342:/* Non-zero if we use a *real* shell (always so on Unix).  */
        -: 3343:
        -: 3344:int unixy_shell = 1;
        -: 3345:
        -: 3346:#ifdef WINDOWS32
        -: 3347:/*
        -: 3348: * The macro which references this function is defined in make.h.
        -: 3349: */
        -: 3350:int w32_kill(int pid, int sig)
        -: 3351:{
        -: 3352:       return ((process_kill(pid, sig) == TRUE) ? 0 : -1);
        -: 3353:}
        -: 3354:#endif /* WINDOWS32 */
        -: 3355:
        -: 3356:/* Write an error message describing the exit status given in
        -: 3357:   EXIT_CODE, EXIT_SIG, and COREDUMP, for the target TARGET_NAME.
        -: 3358:   Append "(ignored)" if IGNORED is nonzero.  */
        -: 3359:
        -: 3360:static void
function child_error called 2 returned 100% blocks executed 43%
        2: 3361:child_error (target_name, exit_code, exit_sig, coredump, ignored)
        -: 3362:     char *target_name;
        -: 3363:     int exit_code, exit_sig, coredump;
        -: 3364:     int ignored;
        -: 3365:{
       2*: 3366:  if (ignored && silent_flag)
branch  0 taken 0 (fallthrough)
branch  1 taken 2
branch  2 never executed
branch  3 never executed
    #####: 3367:    return;
        -: 3368:
        -: 3369:#ifdef VMS
        -: 3370:  if (!(exit_code & 1))
        -: 3371:      error("*** [%s] Error 0x%x%s", target_name, exit_code, ((ignored)? " (ignored)" : ""));
        -: 3372:#else
        2: 3373:  if (exit_sig == 0)
branch  0 taken 2 (fallthrough)
branch  1 taken 0
       2*: 3374:    error (ignored ? "[%s] Error %d (ignored)" :
branch  0 taken 0 (fallthrough)
branch  1 taken 2
call    2 returned 2
        -: 3375:	   "*** [%s] Error %d",
        -: 3376:	   target_name, exit_code);
        -: 3377:  else
    #####: 3378:    error ("*** [%s] %s%s",
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
        -: 3379:	   target_name, strsignal (exit_sig),
        -: 3380:	   coredump ? " (core dumped)" : "");
        -: 3381:#endif /* VMS */
        -: 3382:}
        -: 3383:
        -: 3384:static unsigned int dead_children = 0;
        -: 3385:
        -: 3386:#ifdef VMS
        -: 3387:/* Wait for nchildren children to terminate */
        -: 3388:static void
        -: 3389:vmsWaitForChildren(int *status)
        -: 3390:{
        -: 3391:  while (1)
        -: 3392:    {
        -: 3393:      if (!vms_jobsefnmask)
        -: 3394:	{
        -: 3395:	  *status = 0;
        -: 3396:	  return;
        -: 3397:	}
        -: 3398:
        -: 3399:      *status = sys$wflor (32, vms_jobsefnmask);
        -: 3400:    }
        -: 3401:  return;
        -: 3402:}
        -: 3403:#endif
        -: 3404:
        -: 3405:
        -: 3406:/* Notice that a child died.
        -: 3407:   reap_children should be called when convenient.  */
        -: 3408:RETSIGTYPE
function child_handler called 3 returned 100% blocks executed 67%
        3: 3409:child_handler (sig)
        -: 3410:     int sig;
        -: 3411:{
        3: 3412:  ++dead_children;
        -: 3413:
        3: 3414:  if (debug_flag)
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####: 3415:    printf ("Got a SIGCHLD; %d unreaped children.\n", dead_children);
call    0 never executed
        3: 3416:}
        -: 3417:
        -: 3418:extern int shell_function_pid, shell_function_completed;
        -: 3419:
        -: 3420:/* Reap dead children, storing the returned status and the new command
        -: 3421:   state (`cs_finished') in the `file' member of the `struct child' for the
        -: 3422:   dead child, and removing the child from the chain.  If BLOCK nonzero,
        -: 3423:   reap at least one child, waiting for it to die if necessary.  If ERR is
        -: 3424:   nonzero, print an error message first.  */
        -: 3425:
        -: 3426:void
function reap_children called 813 returned 100% blocks executed 51%
      813: 3427:reap_children (block, err)
        -: 3428:     int block, err;
        -: 3429:{
        -: 3430:  WAIT_T status;
        -: 3431:
      814: 3432:  while ((children != 0 || shell_function_pid != 0) &&
branch  0 taken 811 (fallthrough)
branch  1 taken 3
branch  2 taken 0 (fallthrough)
branch  3 taken 811
branch  4 taken 3
branch  5 taken 0 (fallthrough)
    #####: 3433:	 (block || dead_children > 0))
branch  0 never executed
branch  1 never executed
        -: 3434:    {
        3: 3435:      int remote = 0;
        -: 3436:      register int pid;
        -: 3437:      int exit_code, exit_sig, coredump;
        -: 3438:      register struct child *lastc, *c;
        -: 3439:      int child_failed;
        -: 3440:      int any_remote, any_local;
        -: 3441:
       3*: 3442:      if (err && dead_children == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 3
branch  2 never executed
branch  3 never executed
        -: 3443:	{
        -: 3444:	  /* We might block for a while, so let the user know why.  */
    #####: 3445:	  fflush (stdout);
call    0 never executed
    #####: 3446:	  error ("*** Waiting for unfinished jobs....");
call    0 never executed
        -: 3447:	}
        -: 3448:
        -: 3449:      /* We have one less dead child to reap.
        -: 3450:	 The test and decrement are not atomic; if it is compiled into:
        -: 3451:	 	register = dead_children - 1;
        -: 3452:		dead_children = register;
        -: 3453:	 a SIGCHLD could come between the two instructions.
        -: 3454:	 child_handler increments dead_children.
        -: 3455:	 The second instruction here would lose that increment.  But the
        -: 3456:	 only effect of dead_children being wrong is that we might wait
        -: 3457:	 longer than necessary to reap a child, and lose some parallelism;
        -: 3458:	 and we might print the "Waiting for unfinished jobs" message above
        -: 3459:	 when not necessary.  */
        -: 3460:
        3: 3461:      if (dead_children > 0)
branch  0 taken 1 (fallthrough)
branch  1 taken 2
        1: 3462:	--dead_children;
        -: 3463:
        3: 3464:      any_remote = 0;
        3: 3465:      any_local = shell_function_pid != 0;
        6: 3466:      for (c = children; c != 0; c = c->next)
branch  0 taken 3
branch  1 taken 3 (fallthrough)
        -: 3467:	{
        3: 3468:	  any_remote |= c->remote;
        3: 3469:	  any_local |= ! c->remote;
        3: 3470:	  if (debug_flag)
branch  0 taken 0 (fallthrough)
branch  1 taken 3
        -: 3471:#ifndef F_JR_4  /* seeded fault #4; J.Ruthruff */
    #####: 3472:        printf ("Live child 0x%08lx PID %ld%s\n",
        -: 3473:            (unsigned long int) c,
    #####: 3474:            (long) c->pid, c->remote ? " (remote)" : "");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 3475:#else
        -: 3476:        printf ("Live child 0x%08lx PID %ld%s\n",
        -: 3477:            c, c->pid, c->remote ? " (remote)" : "");
        -: 3478:#endif
        -: 3479:#ifdef VMS
        -: 3480:	  break;
        -: 3481:#endif
        -: 3482:	}
        -: 3483:
        -: 3484:      /* First, check for remote children.  */
        3: 3485:      if (any_remote)
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####: 3486:	pid = remote_status (&exit_code, &exit_sig, &coredump, 0);
call    0 never executed
        -: 3487:      else
        3: 3488:	pid = 0;
        -: 3489:
        3: 3490:      if (pid < 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 3
        -: 3491:	{
    #####: 3492:	remote_status_lose:
        -: 3493:#ifdef	EINTR
    #####: 3494:	  if (errno == EINTR)
branch  0 never executed
branch  1 never executed
    #####: 3495:	    continue;
        -: 3496:#endif
    #####: 3497:	  pfatal_with_name ("remote_status");
call    0 never executed
        -: 3498:	}
        3: 3499:      else if (pid == 0)
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        -: 3500:	{
        -: 3501:#if !defined(__MSDOS__) && !defined(_AMIGA) && !defined(WINDOWS32)
        -: 3502:	  /* No remote children.  Check for local children.  */
        -: 3503:
        3: 3504:	  if (any_local)
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        -: 3505:	    {
        -: 3506:#ifdef VMS
        -: 3507:	      vmsWaitForChildren (&status);
        -: 3508:	      pid = c->pid;
        -: 3509:#else
        -: 3510:#ifdef WAIT_NOHANG
        3: 3511:	      if (!block)
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####: 3512:		pid = WAIT_NOHANG (&status);
call    0 never executed
        -: 3513:	      else
        -: 3514:#endif
        3: 3515:		pid = wait (&status);
call    0 returned 3
        -: 3516:#endif /* !VMS */
        -: 3517:	    }
        -: 3518:	  else
    #####: 3519:	    pid = 0;
        -: 3520:
        3: 3521:	  if (pid < 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 3
        -: 3522:	    {
        -: 3523:#ifdef EINTR
    #####: 3524:	      if (errno == EINTR)
branch  0 never executed
branch  1 never executed
    #####: 3525:		continue;
        -: 3526:#endif
    #####: 3527:	      pfatal_with_name ("wait");
call    0 never executed
        -: 3528:	    }
        3: 3529:	  else if (pid == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 3
        -: 3530:	    {
        -: 3531:	      /* No local children.  */
    #####: 3532:	      if (block && any_remote)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 3533:		{
        -: 3534:		  /* Now try a blocking wait for a remote child.  */
    #####: 3535:		  pid = remote_status (&exit_code, &exit_sig, &coredump, 1);
call    0 never executed
    #####: 3536:		  if (pid < 0)
branch  0 never executed
branch  1 never executed
    #####: 3537:		    goto remote_status_lose;
    #####: 3538:		  else if (pid == 0)
branch  0 never executed
branch  1 never executed
        -: 3539:		    /* No remote children either.  Finally give up.  */
    #####: 3540:		    break;
        -: 3541:		  else
        -: 3542:		    /* We got a remote child.  */
    #####: 3543:		    remote = 1;
        -: 3544:		}
        -: 3545:	      else
        -: 3546:		break;
        -: 3547:	    }
        -: 3548:	  else
        -: 3549:	    {
        -: 3550:	      /* Chop the status word up.  */
        3: 3551:	      exit_code = WEXITSTATUS (status);
       3*: 3552:	      exit_sig = WIFSIGNALED (status) ? WTERMSIG (status) : 0;
branch  0 taken 0 (fallthrough)
branch  1 taken 3
        3: 3553:	      coredump = WCOREDUMP (status);
        -: 3554:	    }
        -: 3555:#else	/* __MSDOS__, Amiga, WINDOWS32.  */
        -: 3556:#ifdef __MSDOS__
        -: 3557:	  /* Life is very different on MSDOS.  */
        -: 3558:	  pid = dos_pid - 1;
        -: 3559:	  status = dos_status;
        -: 3560:	  exit_code = WEXITSTATUS (status);
        -: 3561:	  if (exit_code == 0xff)
        -: 3562:	    exit_code = -1;
        -: 3563:	  exit_sig = WIFSIGNALED (status) ? WTERMSIG (status) : 0;
        -: 3564:	  coredump = 0;
        -: 3565:#endif /* __MSDOS__ */
        -: 3566:#ifdef _AMIGA
        -: 3567:	  /* Same on Amiga */
        -: 3568:	  pid = amiga_pid - 1;
        -: 3569:	  status = amiga_status;
        -: 3570:	  exit_code = amiga_status;
        -: 3571:	  exit_sig = 0;
        -: 3572:	  coredump = 0;
        -: 3573:#endif /* _AMIGA */
        -: 3574:#ifdef WINDOWS32
        -: 3575:      {
        -: 3576:        HANDLE hPID;
        -: 3577:        int err;
        -: 3578:
        -: 3579:        /* wait for anything to finish */
        -: 3580:        if (hPID = process_wait_for_any()) {
        -: 3581:
        -: 3582:          /* was an error found on this process? */
        -: 3583:          err = process_last_err(hPID);
        -: 3584:
        -: 3585:          /* get exit data */
        -: 3586:          exit_code = process_exit_code(hPID);
        -: 3587:
        -: 3588:          if (err)
        -: 3589:            fprintf(stderr, "make (e=%d): %s",
        -: 3590:              exit_code, map_windows32_error_to_string(exit_code));
        -: 3591:
        -: 3592:          /* signal */
        -: 3593:          exit_sig = process_signal(hPID);
        -: 3594:
        -: 3595:          /* cleanup process */
        -: 3596:          process_cleanup(hPID);
        -: 3597:
        -: 3598:          coredump = 0;
        -: 3599:        }
        -: 3600:        pid = (int) hPID;
        -: 3601:      }
        -: 3602:#endif /* WINDOWS32 */
        -: 3603:#endif	/* Not __MSDOS__ */
        -: 3604:	}
        -: 3605:      else
        -: 3606:	/* We got a remote child.  */
    #####: 3607:	remote = 1;
        -: 3608:
        -: 3609:      /* Check if this is the child of the `shell' function.  */
        3: 3610:      if (!remote && pid == shell_function_pid)
branch  0 taken 3 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 3
        -: 3611:	{
        -: 3612:	  /* It is.  Leave an indicator for the `shell' function.  */
    #####: 3613:	  if (exit_sig == 0 && exit_code == 127)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3614:	    shell_function_completed = -1;
        -: 3615:	  else
    #####: 3616:	    shell_function_completed = 1;
    #####: 3617:	  break;
        -: 3618:	}
        -: 3619:
        3: 3620:      child_failed = exit_sig != 0 || exit_code != 0;
branch  0 taken 3 (fallthrough)
branch  1 taken 0
branch  2 taken 2 (fallthrough)
branch  3 taken 1
        -: 3621:
        -: 3622:      /* Search for a child matching the deceased one.  */
        3: 3623:      lastc = 0;
       3*: 3624:      for (c = children; c != 0; lastc = c, c = c->next)
branch  0 taken 3
branch  1 taken 0 (fallthrough)
        3: 3625:	if (c->remote == remote && c->pid == pid)
branch  0 taken 3 (fallthrough)
branch  1 taken 0
branch  2 taken 3 (fallthrough)
branch  3 taken 0
        3: 3626:	  break;
        -: 3627:
        3: 3628:      if (c == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 3
        -: 3629:	{
        -: 3630:	  /* An unknown child died.  */
        -: 3631:	  char buf[100];
    #####: 3632:	  sprintf (buf, "Unknown%s job %d", remote ? " remote" : "", pid);
branch  0 never executed
branch  1 never executed
    #####: 3633:	  if (child_failed)
branch  0 never executed
branch  1 never executed
    #####: 3634:	    child_error (buf, exit_code, exit_sig, coredump,
call    0 never executed
        -: 3635:			 ignore_errors_flag);
        -: 3636:	  else
    #####: 3637:	    error ("%s finished.", buf);
call    0 never executed
        -: 3638:	}
        -: 3639:      else
        -: 3640:	{
        3: 3641:	  if (debug_flag)
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####: 3642:	    printf ("Reaping %s child 0x%08lx PID %ld%s\n",
call    0 never executed
        -: 3643:		    child_failed ? "losing" : "winning",
        -: 3644:		    (unsigned long int) c,
    #####: 3645:		    (long) c->pid, c->remote ? " (remote)" : "");
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 3646:
        3: 3647:      if (c->sh_batch_file) {
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####: 3648:         if (debug_flag)
branch  0 never executed
branch  1 never executed
    #####: 3649:           printf("Cleaning up temporary batch file %s\n", c->sh_batch_file);
call    0 never executed
        -: 3650:
        -: 3651:         /* just try and remove, don't care if this fails */
    #####: 3652:         remove(c->sh_batch_file);
call    0 never executed
        -: 3653:
        -: 3654:         /* all done with memory */
    #####: 3655:         free(c->sh_batch_file);
    #####: 3656:         c->sh_batch_file = NULL;
        -: 3657:      }
        -: 3658:
        -: 3659:	  /* If this child had the good stdin, say it is now free.  */
        3: 3660:	  if (c->good_stdin)
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        3: 3661:	    good_stdin_used = 0;
        -: 3662:
        3: 3663:	  if (child_failed && !c->noerror && !ignore_errors_flag)
branch  0 taken 2 (fallthrough)
branch  1 taken 1
branch  2 taken 2 (fallthrough)
branch  3 taken 0
branch  4 taken 2 (fallthrough)
branch  5 taken 0
        2: 3664:	    {
        -: 3665:	      /* The commands failed.  Write an error message,
        -: 3666:		 delete non-precious targets, and abort.  */
        -: 3667:	      static int delete_on_error = -1;
        2: 3668:	      child_error (c->file->name, exit_code, exit_sig, coredump, 0);
call    0 returned 2
        2: 3669:	      c->file->update_status = 2;
        2: 3670:	      if (delete_on_error == -1)
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        -: 3671:		{
        2: 3672:		  struct file *f = lookup_file (".DELETE_ON_ERROR");
call    0 returned 2
       2*: 3673:		  delete_on_error = f != 0 && f->is_target;
branch  0 taken 0 (fallthrough)
branch  1 taken 2
branch  2 never executed
branch  3 never executed
        -: 3674:		}
        2: 3675:	      if (exit_sig != 0 || delete_on_error)
branch  0 taken 2 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 2
    #####: 3676:		delete_child_targets (c);
call    0 never executed
        -: 3677:	    }
        -: 3678:	  else
        -: 3679:	    {
        1: 3680:	      if (child_failed)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -: 3681:		{
        -: 3682:		  /* The commands failed, but we don't care.  */
    #####: 3683:		  child_error (c->file->name,
call    0 never executed
        -: 3684:			       exit_code, exit_sig, coredump, 1);
    #####: 3685:		  child_failed = 0;
        -: 3686:		}
        -: 3687:
        -: 3688:	      /* If there are more commands to run, try to start them.  */
        1: 3689:	      if (job_next_command (c))
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
        -: 3690:		{
    #####: 3691:		  if (handling_fatal_signal)
branch  0 never executed
branch  1 never executed
        -: 3692:		    {
        -: 3693:		      /* Never start new commands while we are dying.
        -: 3694:			 Since there are more commands that wanted to be run,
        -: 3695:			 the target was not completely remade.  So we treat
        -: 3696:			 this as if a command had failed.  */
    #####: 3697:		      c->file->update_status = 2;
        -: 3698:		    }
        -: 3699:		  else
        -: 3700:		    {
        -: 3701:		      /* Check again whether to start remotely.
        -: 3702:			 Whether or not we want to changes over time.
        -: 3703:			 Also, start_remote_job may need state set up
        -: 3704:			 by start_remote_job_p.  */
    #####: 3705:		      c->remote = start_remote_job_p (0);
call    0 never executed
    #####: 3706:		      start_job_command (c);
call    0 never executed
        -: 3707:		      /* Fatal signals are left blocked in case we were
        -: 3708:			 about to put that child on the chain.  But it is
        -: 3709:			 already there, so it is safe for a fatal signal to
        -: 3710:			 arrive now; it will clean up this child's targets.  */
    #####: 3711:		      unblock_sigs ();
call    0 never executed
    #####: 3712:		      if (c->file->command_state == cs_running)
branch  0 never executed
branch  1 never executed
        -: 3713:			/* We successfully started the new command.
        -: 3714:			   Loop to reap more children.  */
    #####: 3715:			continue;
        -: 3716:		    }
        -: 3717:
    #####: 3718:		  if (c->file->update_status != 0)
branch  0 never executed
branch  1 never executed
        -: 3719:		    /* We failed to start the commands.  */
    #####: 3720:		    delete_child_targets (c);
call    0 never executed
        -: 3721:		}
        -: 3722:	      else
        -: 3723:		/* There are no more commands.  We got through them all
        -: 3724:		   without an unignored error.  Now the target has been
        -: 3725:		   successfully updated.  */
        1: 3726:		c->file->update_status = 0;
        -: 3727:	    }
        -: 3728:
        -: 3729:	  /* When we get here, all the commands for C->file are finished
        -: 3730:	     (or aborted) and C->file->update_status contains 0 or 2.  But
        -: 3731:	     C->file->command_state is still cs_running if all the commands
        -: 3732:	     ran; notice_finish_file looks for cs_running to tell it that
        -: 3733:	     it's interesting to check the file's modtime again now.  */
        -: 3734:
        3: 3735:	  if (! handling_fatal_signal)
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        -: 3736:	    /* Notice if the target of the commands has been changed.
        -: 3737:	       This also propagates its values for command_state and
        -: 3738:	       update_status to its also_make files.  */
        3: 3739:	    notice_finished_file (c->file);
call    0 returned 3
        -: 3740:
        3: 3741:	  if (debug_flag)
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####: 3742:	    printf ("Removing child 0x%08lx PID %ld%s from chain.\n",
        -: 3743:		    (unsigned long int) c,
    #####: 3744:		    (long) c->pid, c->remote ? " (remote)" : "");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 3745:
        -: 3746:	  /* Block fatal signals while frobnicating the list, so that
        -: 3747:	     children and job_slots_used are always consistent.  Otherwise
        -: 3748:	     a fatal signal arriving after the child is off the chain and
        -: 3749:	     before job_slots_used is decremented would believe a child was
        -: 3750:	     live and call reap_children again.  */
        3: 3751:	  block_sigs ();
call    0 returned 3
        -: 3752:
        -: 3753:	  /* Remove the child from the chain and free it.  */
        3: 3754:	  if (lastc == 0)
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        3: 3755:	    children = c->next;
        -: 3756:	  else
    #####: 3757:	    lastc->next = c->next;
        3: 3758:	  if (! handling_fatal_signal) /* Don't bother if about to die.  */
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        3: 3759:	    free_child (c);
call    0 returned 3
        -: 3760:
        -: 3761:	  /* There is now another slot open.  */
        3: 3762:	  if (job_slots_used > 0)
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        3: 3763:	    --job_slots_used;
        -: 3764:
        3: 3765:	  unblock_sigs ();
call    0 returned 3
        -: 3766:
        -: 3767:	  /* If the job failed, and the -k flag was not given, die,
        -: 3768:	     unless we are already in the process of dying.  */
        3: 3769:	  if (!err && child_failed && !keep_going_flag &&
branch  0 taken 3 (fallthrough)
branch  1 taken 0
branch  2 taken 2 (fallthrough)
branch  3 taken 1
branch  4 taken 2 (fallthrough)
branch  5 taken 0
        -: 3770:	      /* fatal_error_signal will die with the right signal.  */
        2: 3771:	      !handling_fatal_signal)
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2: 3772:	    die (2);
call    0 returned 0
        -: 3773:	}
        -: 3774:
        -: 3775:      /* Only block for one child.  */
        1: 3776:      block = 0;
        -: 3777:    }
      811: 3778:  return;
        -: 3779:}
        -: 3780:
        -: 3781:/* Free the storage allocated for CHILD.  */
        -: 3782:
        -: 3783:static void
function free_child called 4 returned 100% blocks executed 100%
        4: 3784:free_child (child)
        -: 3785:     register struct child *child;
        -: 3786:{
        4: 3787:  if (child->command_lines != 0)
branch  0 taken 4 (fallthrough)
branch  1 taken 0
        -: 3788:    {
        -: 3789:      register unsigned int i;
        8: 3790:      for (i = 0; i < child->file->cmds->ncommand_lines; ++i)
branch  0 taken 4
branch  1 taken 4 (fallthrough)
        4: 3791:	free (child->command_lines[i]);
        4: 3792:      free ((char *) child->command_lines);
        -: 3793:    }
        -: 3794:
        4: 3795:  if (child->environment != 0)
branch  0 taken 3 (fallthrough)
branch  1 taken 1
        -: 3796:    {
        3: 3797:      register char **ep = child->environment;
      162: 3798:      while (*ep != 0)
branch  0 taken 159
branch  1 taken 3 (fallthrough)
      159: 3799:	free (*ep++);
        3: 3800:      free ((char *) child->environment);
        -: 3801:    }
        -: 3802:
        4: 3803:  free ((char *) child);
        4: 3804:}
        -: 3805:
        -: 3806:#ifdef POSIX
        -: 3807:extern sigset_t fatal_signal_set;
        -: 3808:#endif
        -: 3809:
        -: 3810:void
function block_sigs called 6 returned 100% blocks executed 100%
        6: 3811:block_sigs ()
        -: 3812:{
        -: 3813:#ifdef	 POSIX
        6: 3814:  (void) sigprocmask (SIG_BLOCK, &fatal_signal_set, (sigset_t *) 0);
call    0 returned 6
        -: 3815:#else
        -: 3816:#ifdef	HAVE_SIGSETMASK
        -: 3817:  (void) sigblock (fatal_signal_mask);
        -: 3818:#endif
        -: 3819:#endif
        6: 3820:}
        -: 3821:
        -: 3822:#ifdef	POSIX
        -: 3823:void
function unblock_sigs called 9 returned 100% blocks executed 100%
        9: 3824:unblock_sigs ()
        -: 3825:{
        -: 3826:  sigset_t empty;
        9: 3827:  sigemptyset (&empty);
call    0 returned 9
        9: 3828:  sigprocmask (SIG_SETMASK, &empty, (sigset_t *) 0);
call    0 returned 9
        9: 3829:}
        -: 3830:#endif
        -: 3831:
        -: 3832:/* Start a job to run the commands specified in CHILD.
        -: 3833:   CHILD is updated to reflect the commands and ID of the child process.
        -: 3834:
        -: 3835:   NOTE: On return fatal signals are blocked!  The caller is responsible
        -: 3836:   for calling `unblock_sigs', once the new child is safely on the chain so
        -: 3837:   it can be cleaned up in the event of a fatal signal.  */
        -: 3838:
        -: 3839:static void
function start_job_command called 4 returned 100% blocks executed 62%
        4: 3840:start_job_command (child)
        -: 3841:     register struct child *child;
        -: 3842:{
        -: 3843:#ifndef _AMIGA
        -: 3844:  static int bad_stdin = -1;
        -: 3845:#endif
        -: 3846:  register char *p;
        -: 3847:  int flags;
        -: 3848:#ifdef VMS
        -: 3849:  char *argv;
        -: 3850:#else
        -: 3851:  char **argv;
        -: 3852:#endif
        -: 3853:
        -: 3854:  /* Combine the flags parsed for the line itself with
        -: 3855:     the flags specified globally for this target.  */
        4: 3856:  flags = (child->file->command_flags
        4: 3857:	   | child->file->cmds->lines_flags[child->command_line - 1]);
        -: 3858:
        4: 3859:  p = child->command_ptr;
        4: 3860:  child->noerror = flags & COMMANDS_NOERROR;
        -: 3861:
        8: 3862:  while (*p != '\0')
branch  0 taken 8
branch  1 taken 0 (fallthrough)
        -: 3863:    {
        8: 3864:      if (*p == '@')
branch  0 taken 0 (fallthrough)
branch  1 taken 8
    #####: 3865:	flags |= COMMANDS_SILENT;
        8: 3866:      else if (*p == '+')
branch  0 taken 0 (fallthrough)
branch  1 taken 8
    #####: 3867:	flags |= COMMANDS_RECURSE;
        8: 3868:      else if (*p == '-')
branch  0 taken 0 (fallthrough)
branch  1 taken 8
    #####: 3869:	child->noerror = 1;
        8: 3870:      else if (!isblank (*p) && *p != '+')
branch  0 taken 4 (fallthrough)
branch  1 taken 4
branch  2 taken 4 (fallthrough)
branch  3 taken 0
        4: 3871:	break;
        4: 3872:      ++p;
        -: 3873:    }
        -: 3874:
        -: 3875:  /* If -q was given, just say that updating `failed'.  The exit status of
        -: 3876:     1 tells the user that -q is saying `something to do'; the exit status
        -: 3877:     for a random error is 2.  */
       4*: 3878:  if (question_flag && !(flags & COMMANDS_RECURSE))
branch  0 taken 0 (fallthrough)
branch  1 taken 4
branch  2 never executed
branch  3 never executed
        -: 3879:    {
    #####: 3880:      child->file->update_status = 1;
    #####: 3881:      notice_finished_file (child->file);
call    0 never executed
    #####: 3882:      return;
        -: 3883:    }
        -: 3884:
        -: 3885:  /* There may be some preceding whitespace left if there
        -: 3886:     was nothing but a backslash on the first line.  */
        4: 3887:  p = next_token (p);
call    0 returned 4
        -: 3888:
        -: 3889:  /* Figure out an argument list from this command line.  */
        -: 3890:
        -: 3891:  {
        4: 3892:    char *end = 0;
        -: 3893:#ifdef VMS
        -: 3894:    argv = p;
        -: 3895:#else
        4: 3896:    argv = construct_command_argv (p, &end, child->file, &child->sh_batch_file);
call    0 returned 4
        -: 3897:#endif
        4: 3898:    if (end == NULL)
branch  0 taken 4 (fallthrough)
branch  1 taken 0
        4: 3899:      child->command_ptr = NULL;
        -: 3900:    else
        -: 3901:      {
    #####: 3902:	*end++ = '\0';
    #####: 3903:	child->command_ptr = end;
        -: 3904:      }
        -: 3905:  }
        -: 3906:
       4*: 3907:  if (touch_flag && !(flags & COMMANDS_RECURSE))
branch  0 taken 0 (fallthrough)
branch  1 taken 4
branch  2 never executed
branch  3 never executed
        -: 3908:    {
        -: 3909:      /* Go on to the next command.  It might be the recursive one.
        -: 3910:	 We construct ARGV only to find the end of the command line.  */
        -: 3911:#ifndef VMS
    #####: 3912:      free (argv[0]);
    #####: 3913:      free ((char *) argv);
        -: 3914:#endif
    #####: 3915:      argv = 0;
        -: 3916:    }
        -: 3917:
        4: 3918:  if (argv == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 4
        -: 3919:    {
    #####: 3920:    next_command:
        -: 3921:#ifdef __MSDOS__
        -: 3922:	  execute_by_shell = 0;   /* in case construct_command_argv sets it */
        -: 3923:#endif
        -: 3924:      /* This line has no commands.  Go to the next.  */
        1: 3925:      if (job_next_command (child))
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
    #####: 3926:	start_job_command (child);
call    0 never executed
        -: 3927:      else
        -: 3928:	{
        -: 3929:	  /* No more commands.  All done.  */
        1: 3930:	  child->file->update_status = 0;
        1: 3931:	  notice_finished_file (child->file);
call    0 returned 1
        -: 3932:	}
        1: 3933:      return;
        -: 3934:    }
        -: 3935:
        -: 3936:  /* Print out the command.  If silent, we call `message' with null so it
        -: 3937:     can log the working directory before the command's own error messages
        -: 3938:     appear.  */
        -: 3939:
       4*: 3940:  message (0, (just_print_flag || (!(flags & COMMANDS_SILENT) && !silent_flag))
branch  0 taken 3 (fallthrough)
branch  1 taken 1
branch  2 taken 3 (fallthrough)
branch  3 taken 0
branch  4 taken 3 (fallthrough)
branch  5 taken 0
call    6 returned 4
        -: 3941:	   ? "%s" : (char *) 0, p);
        -: 3942:
        -: 3943:  /* Optimize an empty command.  People use this for timestamp rules,
        -: 3944:     and forking a useless shell all the time leads to inefficiency. */
        -: 3945:
        -: 3946:#if !defined(VMS) && !defined(_AMIGA)
        4: 3947:  if (
        -: 3948:#ifdef __MSDOS__
        -: 3949:      unixy_shell	/* the test is complicated and we already did it */
        -: 3950:#else
        4: 3951:      (argv[0] && !strcmp(argv[0], "/bin/sh"))
branch  0 taken 4 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 4
        -: 3952:#endif
    #####: 3953:      && (argv[1]   && !strcmp(argv[1], "-c"))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3954:      && (argv[2]   && !strcmp(argv[2], ":"))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3955:      && argv[3] == NULL)
branch  0 never executed
branch  1 never executed
        -: 3956:    {
    #####: 3957:      set_command_state (child->file, cs_running);
call    0 never executed
    #####: 3958:      goto next_command;
        -: 3959:    }
        -: 3960:#endif  /* !VMS && !_AMIGA */
        -: 3961:
        -: 3962:  /* Tell update_goal_chain that a command has been started on behalf of
        -: 3963:     this target.  It is important that this happens here and not in
        -: 3964:     reap_children (where we used to do it), because reap_children might be
        -: 3965:     reaping children from a different target.  We want this increment to
        -: 3966:     guaranteedly indicate that a command was started for the dependency
        -: 3967:     chain (i.e., update_file recursion chain) we are processing.  */
        -: 3968:
        4: 3969:  ++commands_started;
        -: 3970:
        -: 3971:  /* If -n was given, recurse to get the next line in the sequence.  */
        -: 3972:
        4: 3973:  if (just_print_flag && !(flags & COMMANDS_RECURSE))
branch  0 taken 1 (fallthrough)
branch  1 taken 3
branch  2 taken 1 (fallthrough)
branch  3 taken 0
        -: 3974:    {
        -: 3975:#ifndef VMS
        1: 3976:      free (argv[0]);
        1: 3977:      free ((char *) argv);
        -: 3978:#endif
        1: 3979:      goto next_command;
        -: 3980:    }
        -: 3981:
        -: 3982:  /* Flush the output streams so they won't have things written twice.  */
        -: 3983:
        3: 3984:  fflush (stdout);
call    0 returned 3
        3: 3985:  fflush (stderr);
call    0 returned 3
        -: 3986:
        -: 3987:#ifndef VMS
        -: 3988:#if !defined(WINDOWS32) && !defined(_AMIGA) && !defined(__MSDOS__)
        -: 3989:
        -: 3990:  /* Set up a bad standard input that reads from a broken pipe.  */
        -: 3991:
        3: 3992:  if (bad_stdin == -1)
branch  0 taken 2 (fallthrough)
branch  1 taken 1
        -: 3993:    {
        -: 3994:      /* Make a file descriptor that is the read end of a broken pipe.
        -: 3995:	 This will be used for some children's standard inputs.  */
        -: 3996:      int pd[2];
        2: 3997:      if (pipe (pd) == 0)
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0
        -: 3998:	{
        -: 3999:	  /* Close the write side.  */
        2: 4000:	  (void) close (pd[1]);
call    0 returned 2
        -: 4001:	  /* Save the read side.  */
        2: 4002:	  bad_stdin = pd[0];
        -: 4003:
        -: 4004:	  /* Set the descriptor to close on exec, so it does not litter any
        -: 4005:	     child's descriptor table.  When it is dup2'd onto descriptor 0,
        -: 4006:	     that descriptor will not close on exec.  */
        -: 4007:#ifdef FD_SETFD
        -: 4008:#ifndef FD_CLOEXEC
        -: 4009:#define FD_CLOEXEC 1
        -: 4010:#endif
        -: 4011:	  (void) fcntl (bad_stdin, F_SETFD, FD_CLOEXEC);
        -: 4012:#endif
        -: 4013:	}
        -: 4014:    }
        -: 4015:
        -: 4016:#endif /* !WINDOWS32 && !_AMIGA && !__MSDOS__ */
        -: 4017:
        -: 4018:  /* Decide whether to give this child the `good' standard input
        -: 4019:     (one that points to the terminal or whatever), or the `bad' one
        -: 4020:     that points to the read side of a broken pipe.  */
        -: 4021:
        3: 4022:  child->good_stdin = !good_stdin_used;
        3: 4023:  if (child->good_stdin)
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        3: 4024:    good_stdin_used = 1;
        -: 4025:
        -: 4026:#endif /* !VMS */
        -: 4027:
        3: 4028:  child->deleted = 0;
        -: 4029:
        -: 4030:#ifndef _AMIGA
        -: 4031:  /* Set up the environment for the child.  */
        3: 4032:  if (child->environment == 0)
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        3: 4033:    child->environment = target_environment (child->file);
call    0 returned 3
        -: 4034:#endif
        -: 4035:
        -: 4036:#if !defined(__MSDOS__) && !defined(_AMIGA) && !defined(WINDOWS32)
        -: 4037:
        -: 4038:#ifndef VMS
        -: 4039:  /* start_waiting_job has set CHILD->remote if we can start a remote job.  */
        3: 4040:  if (child->remote)
branch  0 taken 0 (fallthrough)
branch  1 taken 3
        -: 4041:    {
        -: 4042:      int is_remote, id, used_stdin;
    #####: 4043:      if (start_remote_job (argv, child->environment,
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 4044:			    child->good_stdin ? 0 : bad_stdin,
branch  0 never executed
branch  1 never executed
        -: 4045:			    &is_remote, &id, &used_stdin))
        -: 4046:        /* Don't give up; remote execution may fail for various reasons.  If
        -: 4047:           so, simply run the job locally.  */
    #####: 4048:	goto run_local;
        -: 4049:      else
        -: 4050:	{
    #####: 4051:	  if (child->good_stdin && !used_stdin)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 4052:	    {
    #####: 4053:	      child->good_stdin = 0;
    #####: 4054:	      good_stdin_used = 0;
        -: 4055:	    }
    #####: 4056:	  child->remote = is_remote;
    #####: 4057:	  child->pid = id;
        -: 4058:	}
        -: 4059:    }
        -: 4060:  else
        -: 4061:#endif /* !VMS */
        -: 4062:    {
        -: 4063:      /* Fork the child process.  */
        -: 4064:
        -: 4065:      char **parent_environ;
        -: 4066:
        3: 4067:    run_local:
        3: 4068:      block_sigs ();
call    0 returned 3
        -: 4069:
        3: 4070:      child->remote = 0;
        -: 4071:
        -: 4072:#ifdef VMS
        -: 4073:
        -: 4074:      if (!child_execute_job (argv, child)) {
        -: 4075:        /* Fork failed!  */
        -: 4076:        perror_with_name ("vfork", "");
        -: 4077:        goto error;
        -: 4078:      }
        -: 4079:
        -: 4080:#else
        -: 4081:
        3: 4082:      parent_environ = environ;
        3: 4083:      child->pid = vfork ();
call    0 returned 6
        6: 4084:      environ = parent_environ;	/* Restore value child may have clobbered.  */
        6: 4085:      if (child->pid == 0)
branch  0 taken 3 (fallthrough)
branch  1 taken 3
        -: 4086:	{
        -: 4087:	  /* We are the child side.  */
        3: 4088:	  unblock_sigs ();
call    0 returned 3
       3*: 4089:	  child_execute_job (child->good_stdin ? 0 : bad_stdin, 1,
branch  0 taken 0 (fallthrough)
branch  1 taken 3
call    2 returned 0
        -: 4090:			     argv, child->environment);
        -: 4091:	}
        3: 4092:      else if (child->pid < 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 3
        -: 4093:	{
        -: 4094:	  /* Fork failed!  */
    #####: 4095:	  unblock_sigs ();
call    0 never executed
    #####: 4096:	  perror_with_name ("vfork", "");
call    0 never executed
    #####: 4097:	  goto error;
        -: 4098:	}
        -: 4099:#endif /* !VMS */
        -: 4100:    }
        -: 4101:
        -: 4102:#else	/* __MSDOS__ or Amiga or WINDOWS32 */
        -: 4103:#ifdef __MSDOS__
        -: 4104:  {
        -: 4105:    int proc_return;
        -: 4106:
        -: 4107:    block_sigs ();
        -: 4108:    dos_status = 0;
        -: 4109:
        -: 4110:    /* We call `system' to do the job of the SHELL, since stock DOS
        -: 4111:       shell is too dumb.  Our `system' knows how to handle long
        -: 4112:       command lines even if pipes/redirection is needed; it will only
        -: 4113:       call COMMAND.COM when its internal commands are used.  */
        -: 4114:    if (execute_by_shell)
        -: 4115:      {
        -: 4116:	char *cmdline = argv[0];
        -: 4117:	/* We don't have a way to pass environment to `system',
        -: 4118:	   so we need to save and restore ours, sigh...  */
        -: 4119:	char **parent_environ = environ;
        -: 4120:
        -: 4121:	environ = child->environment;
        -: 4122:
        -: 4123:	/* If we have a *real* shell, tell `system' to call
        -: 4124:	   it to do everything for us.  */
        -: 4125:	if (unixy_shell)
        -: 4126:	  {
        -: 4127:	    /* A *real* shell on MSDOS may not support long
        -: 4128:	       command lines the DJGPP way, so we must use `system'.  */
        -: 4129:	    cmdline = argv[2];	/* get past "shell -c" */
        -: 4130:	  }
        -: 4131:
        -: 4132:	dos_command_running = 1;
        -: 4133:	proc_return = system (cmdline);
        -: 4134:	dos_command_running = 0;
        -: 4135:	environ = parent_environ;
        -: 4136:	execute_by_shell = 0;	/* for the next time */
        -: 4137:      }
        -: 4138:    else
        -: 4139:      {
        -: 4140:	dos_command_running = 1;
        -: 4141:	proc_return = spawnvpe (P_WAIT, argv[0], argv, child->environment);
        -: 4142:	dos_command_running = 0;
        -: 4143:      }
        -: 4144:
        -: 4145:    if (proc_return == -1)
        -: 4146:      dos_status |= 0xff;
        -: 4147:    else
        -: 4148:      dos_status |= (proc_return & 0xff);
        -: 4149:    ++dead_children;
        -: 4150:    child->pid = dos_pid++;
        -: 4151:  }
        -: 4152:#endif /* __MSDOS__ */
        -: 4153:#ifdef _AMIGA
        -: 4154:  amiga_status = MyExecute (argv);
        -: 4155:
        -: 4156:  ++dead_children;
        -: 4157:  child->pid = amiga_pid++;
        -: 4158:  if (amiga_batch_file)
        -: 4159:  {
        -: 4160:     amiga_batch_file = 0;
        -: 4161:     DeleteFile (amiga_bname);        /* Ignore errors.  */
        -: 4162:  }
        -: 4163:#endif	/* Amiga */
        -: 4164:#ifdef WINDOWS32
        -: 4165:  {
        -: 4166:      HANDLE hPID;
        -: 4167:      char* arg0;
        -: 4168:
        -: 4169:      /* make UNC paths safe for CreateProcess -- backslash format */
        -: 4170:      arg0 = argv[0];
        -: 4171:      if (arg0 && arg0[0] == '/' && arg0[1] == '/')
        -: 4172:        for ( ; arg0 && *arg0; arg0++)
        -: 4173:          if (*arg0 == '/')
        -: 4174:            *arg0 = '\\';
        -: 4175:
        -: 4176:      /* make sure CreateProcess() has Path it needs */
        -: 4177:      sync_Path_environment();
        -: 4178:
        -: 4179:      hPID = process_easy(argv, child->environment);
        -: 4180:
        -: 4181:      if (hPID != INVALID_HANDLE_VALUE)
        -: 4182:        child->pid = (int) hPID;
        -: 4183:      else {
        -: 4184:        int i;
        -: 4185:        unblock_sigs();
        -: 4186:        fprintf(stderr,
        -: 4187:          "process_easy() failed failed to launch process (e=%d)\n",
        -: 4188:          process_last_err(hPID));
        -: 4189:               for (i = 0; argv[i]; i++)
        -: 4190:                 fprintf(stderr, "%s ", argv[i]);
        -: 4191:               fprintf(stderr, "\nCounted %d args in failed launch\n", i);
        -: 4192:      }
        -: 4193:  }
        -: 4194:#endif /* WINDOWS32 */
        -: 4195:#endif	/* __MSDOS__ or Amiga or WINDOWS32 */
        -: 4196:
        -: 4197:  /* We are the parent side.  Set the state to
        -: 4198:     say the commands are running and return.  */
        -: 4199:
        3: 4200:  set_command_state (child->file, cs_running);
call    0 returned 3
        -: 4201:
        -: 4202:  /* Free the storage used by the child's argument list.  */
        -: 4203:#ifndef VMS
        3: 4204:  free (argv[0]);
        3: 4205:  free ((char *) argv);
        -: 4206:#endif
        -: 4207:
        3: 4208:  return;
        -: 4209:
    #####: 4210: error:
    #####: 4211:  child->file->update_status = 2;
    #####: 4212:  notice_finished_file (child->file);
call    0 never executed
    #####: 4213:  return;
        -: 4214:}
        -: 4215:
        -: 4216:/* Try to start a child running.
        -: 4217:   Returns nonzero if the child was started (and maybe finished), or zero if
        -: 4218:   the load was too high and the child was put on the `waiting_jobs' chain.  */
        -: 4219:
        -: 4220:static int
function start_waiting_job called 4 returned 100% blocks executed 52%
        4: 4221:start_waiting_job (c)
        -: 4222:     struct child *c;
        -: 4223:{
        -: 4224:  /* If we can start a job remotely, we always want to, and don't care about
        -: 4225:     the local load average.  We record that the job should be started
        -: 4226:     remotely in C->remote for start_job_command to test.  */
        -: 4227:
        4: 4228:  c->remote = start_remote_job_p (1);
call    0 returned 4
        -: 4229:
        -: 4230:  /* If this job is to be started locally, and we are already running
        -: 4231:     some jobs, make this one wait if the load average is too high.  */
       4*: 4232:  if (!c->remote && job_slots_used > 0 && load_too_high ())
branch  0 taken 4 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 4
call    4 never executed
branch  5 never executed
branch  6 never executed
        -: 4233:    {
        -: 4234:      /* Put this child on the chain of children waiting
        -: 4235:	 for the load average to go down.  */
    #####: 4236:      set_command_state (c->file, cs_running);
call    0 never executed
    #####: 4237:      c->next = waiting_jobs;
    #####: 4238:      waiting_jobs = c;
    #####: 4239:      return 0;
        -: 4240:    }
        -: 4241:
        -: 4242:  /* Start the first command; reap_children will run later command lines.  */
        4: 4243:  start_job_command (c);
call    0 returned 4
        -: 4244:
        4: 4245:  switch (c->file->command_state)
branch  0 taken 3
branch  1 taken 0
branch  2 taken 1
branch  3 taken 0
        -: 4246:    {
        3: 4247:    case cs_running:
        3: 4248:      c->next = children;
        3: 4249:      if (debug_flag)
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####: 4250:	printf ("Putting child 0x%08lx PID %05d%s on the chain.\n",
call    0 never executed
        -: 4251:		(unsigned long int) c,
    #####: 4252:		c->pid, c->remote ? " (remote)" : "");
branch  0 never executed
branch  1 never executed
        3: 4253:      children = c;
        -: 4254:      /* One more job slot is in use.  */
        3: 4255:      ++job_slots_used;
        3: 4256:      unblock_sigs ();
call    0 returned 3
        3: 4257:      break;
        -: 4258:
    #####: 4259:    case cs_not_started:
        -: 4260:      /* All the command lines turned out to be empty.  */
    #####: 4261:      c->file->update_status = 0;
        -: 4262:      /* FALLTHROUGH */
        -: 4263:
        1: 4264:    case cs_finished:
        1: 4265:      notice_finished_file (c->file);
call    0 returned 1
        1: 4266:      free_child (c);
call    0 returned 1
        1: 4267:      break;
        -: 4268:
    #####: 4269:    default:
    #####: 4270:      assert (c->file->command_state == cs_finished);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 4271:      break;
        -: 4272:    }
        -: 4273:
        4: 4274:  return 1;
        -: 4275:}
        -: 4276:
        -: 4277:/* Create a `struct child' for FILE and start its commands running.  */
        -: 4278:
        -: 4279:void
function new_job called 4 returned 50% blocks executed 65%
        4: 4280:new_job (file)
        -: 4281:     register struct file *file;
        -: 4282:{
        4: 4283:  register struct commands *cmds = file->cmds;
        -: 4284:  register struct child *c;
        -: 4285:  char **lines;
        -: 4286:  register unsigned int i;
        -: 4287:
        -: 4288:  /* Let any previously decided-upon jobs that are waiting
        -: 4289:     for the load to go down start before this new one.  */
        4: 4290:  start_waiting_jobs ();
call    0 returned 4
        -: 4291:
        -: 4292:  /* Reap any children that might have finished recently.  */
        4: 4293:  reap_children (0, 0);
call    0 returned 4
        -: 4294:
        -: 4295:  /* Chop the commands up into lines if they aren't already.  */
        4: 4296:  chop_commands (cmds);
call    0 returned 4
        -: 4297:
        4: 4298:  if (job_slots != 0)
branch  0 taken 4 (fallthrough)
branch  1 taken 0
        -: 4299:    /* Wait for a job slot to be freed up.  */
        4: 4300:    while (job_slots_used == job_slots)
branch  0 taken 0
branch  1 taken 4 (fallthrough)
    #####: 4301:      reap_children (1, 0);
call    0 never executed
        -: 4302:
        -: 4303:  /* Expand the command lines and store the results in LINES.  */
        4: 4304:  lines = (char **) xmalloc (cmds->ncommand_lines * sizeof (char *));
call    0 returned 4
        8: 4305:  for (i = 0; i < cmds->ncommand_lines; ++i)
branch  0 taken 4
branch  1 taken 4 (fallthrough)
        -: 4306:    {
        -: 4307:      /* Collapse backslash-newline combinations that are inside variable
        -: 4308:	 or function references.  These are left alone by the parser so
        -: 4309:	 that they will appear in the echoing of commands (where they look
        -: 4310:	 nice); and collapsed by construct_command_argv when it tokenizes.
        -: 4311:	 But letting them survive inside function invocations loses because
        -: 4312:	 we don't want the functions to see them as part of the text.  */
        -: 4313:
        -: 4314:      char *in, *out, *ref;
        -: 4315:
        -: 4316:      /* IN points to where in the line we are scanning.
        -: 4317:	 OUT points to where in the line we are writing.
        -: 4318:	 When we collapse a backslash-newline combination,
        -: 4319:	 IN gets ahead of OUT.  */
        -: 4320:
        4: 4321:      in = out = cmds->command_lines[i];
       24: 4322:      while ((ref = index (in, '$')) != 0)
branch  0 taken 20
branch  1 taken 4 (fallthrough)
        -: 4323:	{
       20: 4324:	  ++ref;		/* Move past the $.  */
        -: 4325:
       20: 4326:	  if (out != in)
branch  0 taken 0 (fallthrough)
branch  1 taken 20
        -: 4327:	    /* Copy the text between the end of the last chunk
        -: 4328:	       we processed (where IN points) and the new chunk
        -: 4329:	       we are about to process (where REF points).  */
    #####: 4330:	    bcopy (in, out, ref - in);
        -: 4331:
        -: 4332:	  /* Move both pointers past the boring stuff.  */
       20: 4333:	  out += ref - in;
       20: 4334:	  in = ref;
        -: 4335:
       20: 4336:	  if (*ref == '(' || *ref == '{')
branch  0 taken 4 (fallthrough)
branch  1 taken 16
branch  2 taken 0 (fallthrough)
branch  3 taken 4
        -: 4337:	    {
       16: 4338:	      char openparen = *ref;
      16*: 4339:	      char closeparen = openparen == '(' ? ')' : '}';
branch  0 taken 16 (fallthrough)
branch  1 taken 0
        -: 4340:	      int count;
        -: 4341:	      char *p;
        -: 4342:
       16: 4343:	      *out++ = *in++;	/* Copy OPENPAREN.  */
        -: 4344:	      /* IN now points past the opening paren or brace.
        -: 4345:		 Count parens or braces until it is matched.  */
       16: 4346:	      count = 0;
       90: 4347:	      while (*in != '\0')
branch  0 taken 90
branch  1 taken 0 (fallthrough)
        -: 4348:		{
       90: 4349:		  if (*in == closeparen && --count < 0)
branch  0 taken 16 (fallthrough)
branch  1 taken 74
branch  2 taken 0 (fallthrough)
branch  3 taken 16
        -: 4350:		    break;
      74*: 4351:		  else if (*in == '\\' && in[1] == '\n')
branch  0 taken 0 (fallthrough)
branch  1 taken 74
branch  2 never executed
branch  3 never executed
    #####: 4352:		    {
        -: 4353:		      /* We have found a backslash-newline inside a
        -: 4354:			 variable or function reference.  Eat it and
        -: 4355:			 any following whitespace.  */
        -: 4356:
    #####: 4357:		      int quoted = 0;
    #####: 4358:		      for (p = in - 1; p > ref && *p == '\\'; --p)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4359:			quoted = !quoted;
        -: 4360:
    #####: 4361:		      if (quoted)
branch  0 never executed
branch  1 never executed
        -: 4362:			/* There were two or more backslashes, so this is
        -: 4363:			   not really a continuation line.  We don't collapse
        -: 4364:			   the quoting backslashes here as is done in
        -: 4365:			   collapse_continuations, because the line will
        -: 4366:			   be collapsed again after expansion.  */
    #####: 4367:			*out++ = *in++;
        -: 4368:		      else
        -: 4369:			{
        -: 4370:			  /* Skip the backslash, newline and
        -: 4371:			     any following whitespace.  */
    #####: 4372:			  in = next_token (in + 2);
call    0 never executed
        -: 4373:
        -: 4374:			  /* Discard any preceding whitespace that has
        -: 4375:			     already been written to the output.  */
    #####: 4376:			  while (out > ref && isblank (out[-1]))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4377:			    --out;
        -: 4378:
        -: 4379:			  /* Replace it all with a single space.  */
    #####: 4380:			  *out++ = ' ';
        -: 4381:			}
        -: 4382:		    }
        -: 4383:		  else
        -: 4384:		    {
       74: 4385:		      if (*in == openparen)
branch  0 taken 0 (fallthrough)
branch  1 taken 74
    #####: 4386:			++count;
        -: 4387:
       74: 4388:		      *out++ = *in++;
        -: 4389:		    }
        -: 4390:		}
        -: 4391:	    }
        -: 4392:	}
        -: 4393:
        -: 4394:      /* There are no more references in this line to worry about.
        -: 4395:	 Copy the remaining uninteresting text to the output.  */
        4: 4396:      if (out != in)
branch  0 taken 0 (fallthrough)
branch  1 taken 4
    #####: 4397:	strcpy (out, in);
        -: 4398:
        -: 4399:      /* Finally, expand the line.  */
        4: 4400:      lines[i] = allocated_variable_expand_for_file (cmds->command_lines[i],
call    0 returned 4
        -: 4401:						     file);
        -: 4402:    }
        -: 4403:
        -: 4404:  /* Start the command sequence, record it in a new
        -: 4405:     `struct child', and add that to the chain.  */
        -: 4406:
        4: 4407:  c = (struct child *) xmalloc (sizeof (struct child));
call    0 returned 4
        4: 4408:  c->file = file;
        4: 4409:  c->command_lines = lines;
        4: 4410:  c->command_line = 0;
        4: 4411:  c->command_ptr = 0;
        4: 4412:  c->environment = 0;
        -: 4413:#ifndef F_JR_5  /* seeded fault #5; J.Ruthruff */
        4: 4414:  c->sh_batch_file = NULL;
        -: 4415:#endif
        -: 4416:
        -: 4417:  /* Fetch the first command line to be run.  */
        4: 4418:  job_next_command (c);
call    0 returned 4
        -: 4419:
        -: 4420:  /* The job is now primed.  Start it running.
        -: 4421:     (This will notice if there are in fact no commands.)  */
        4: 4422:  (void)start_waiting_job (c);
call    0 returned 4
        -: 4423:
        4: 4424:  if (job_slots == 1)
branch  0 taken 4 (fallthrough)
branch  1 taken 0
        -: 4425:    /* Since there is only one job slot, make things run linearly.
        -: 4426:       Wait for the child to die, setting the state to `cs_finished'.  */
        5: 4427:    while (file->command_state == cs_running)
branch  0 taken 3
branch  1 taken 2 (fallthrough)
        3: 4428:      reap_children (1, 0);
call    0 returned 1
        -: 4429:
        2: 4430:  return;
        -: 4431:}
        -: 4432:
        -: 4433:/* Move CHILD's pointers to the next command for it to execute.
        -: 4434:   Returns nonzero if there is another command.  */
        -: 4435:
        -: 4436:static int
function job_next_command called 6 returned 100% blocks executed 100%
        6: 4437:job_next_command (child)
        -: 4438:     struct child *child;
        -: 4439:{
       10: 4440:  while (child->command_ptr == 0 || *child->command_ptr == '\0')
branch  0 taken 6
branch  1 taken 4 (fallthrough)
branch  2 taken 0
branch  3 taken 4 (fallthrough)
        -: 4441:    {
        -: 4442:      /* There are no more lines in the expansion of this line.  */
        6: 4443:      if (child->command_line == child->file->cmds->ncommand_lines)
branch  0 taken 2 (fallthrough)
branch  1 taken 4
        -: 4444:	{
        -: 4445:	  /* There are no more lines to be expanded.  */
        2: 4446:	  child->command_ptr = 0;
        2: 4447:	  return 0;
        -: 4448:	}
        -: 4449:      else
        -: 4450:	/* Get the next line to run.  */
        4: 4451:	child->command_ptr = child->command_lines[child->command_line++];
        -: 4452:    }
        4: 4453:  return 1;
        -: 4454:}
        -: 4455:
        -: 4456:static int
function load_too_high called 0 returned 0% blocks executed 0%
    #####: 4457:load_too_high ()
        -: 4458:{
        -: 4459:#if defined(__MSDOS__) || defined(VMS) || defined(_AMIGA)
        -: 4460:  return 1;
        -: 4461:#else
        -: 4462:  double load;
        -: 4463:
    #####: 4464:  if (max_load_average < 0)
branch  0 never executed
branch  1 never executed
    #####: 4465:    return 0;
        -: 4466:
    #####: 4467:  make_access ();
call    0 never executed
    #####: 4468:  if (getloadavg (&load, 1) != 1)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 4469:    {
        -: 4470:      static int lossage = -1;
        -: 4471:      /* Complain only once for the same error.  */
    #####: 4472:      if (lossage == -1 || errno != lossage)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 4473:	{
    #####: 4474:	  if (errno == 0)
branch  0 never executed
branch  1 never executed
        -: 4475:	    /* An errno value of zero means getloadavg is just unsupported.  */
    #####: 4476:	    error ("cannot enforce load limits on this operating system");
call    0 never executed
        -: 4477:	  else
    #####: 4478:	    perror_with_name ("cannot enforce load limit: ", "getloadavg");
call    0 never executed
        -: 4479:	}
    #####: 4480:      lossage = errno;
    #####: 4481:      load = 0;
        -: 4482:    }
    #####: 4483:  user_access ();
call    0 never executed
        -: 4484:
    #####: 4485:  return load >= max_load_average;
        -: 4486:#endif
        -: 4487:}
        -: 4488:
        -: 4489:/* Start jobs that are waiting for the load to be lower.  */
        -: 4490:
        -: 4491:void
function start_waiting_jobs called 810 returned 100% blocks executed 38%
      810: 4492:start_waiting_jobs ()
        -: 4493:{
        -: 4494:  struct child *job;
        -: 4495:
      810: 4496:  if (waiting_jobs == 0)
branch  0 taken 810 (fallthrough)
branch  1 taken 0
      810: 4497:    return;
        -: 4498:
        -: 4499:  do
        -: 4500:    {
        -: 4501:      /* Check for recently deceased descendants.  */
    #####: 4502:      reap_children (0, 0);
call    0 never executed
        -: 4503:
        -: 4504:      /* Take a job off the waiting list.  */
    #####: 4505:      job = waiting_jobs;
    #####: 4506:      waiting_jobs = job->next;
        -: 4507:
        -: 4508:      /* Try to start that job.  We break out of the loop as soon
        -: 4509:	 as start_waiting_job puts one back on the waiting list.  */
        -: 4510:    }
    #####: 4511:  while (start_waiting_job (job) && waiting_jobs != 0);
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -: 4512:
    #####: 4513:  return;
        -: 4514:}
        -: 4515:
        -: 4516:#ifndef WINDOWS32
        -: 4517:#ifdef VMS
        -: 4518:#include <descrip.h>
        -: 4519:#include <clidef.h>
        -: 4520:#undef stderr
        -: 4521:#define stderr stdout
        -: 4522:
        -: 4523:/* This is called as an AST when a child process dies (it won't get
        -: 4524:   interrupted by anything except a higher level AST).
        -: 4525:*/
        -: 4526:int vmsHandleChildTerm(struct child *child)
        -: 4527:{
        -: 4528:    int status;
        -: 4529:    register struct child *lastc, *c;
        -: 4530:    int child_failed;
        -: 4531:
        -: 4532:    vms_jobsefnmask &= ~(1 << (child->efn - 32));
        -: 4533:
        -: 4534:    lib$free_ef(&child->efn);
        -: 4535:
        -: 4536:    (void) sigblock (fatal_signal_mask);
        -: 4537:
        -: 4538:    child_failed = !(child->cstatus & 1 || ((child->cstatus & 7) == 0));
        -: 4539:
        -: 4540:    /* Search for a child matching the deceased one.  */
        -: 4541:    lastc = 0;
        -: 4542:#if defined(RECURSIVEJOBS) /* I've had problems with recursive stuff and process handling */
        -: 4543:    for (c = children; c != 0 && c != child; lastc = c, c = c->next);
        -: 4544:#else
        -: 4545:    c = child;
        -: 4546:#endif
        -: 4547:
        -: 4548:    if (child_failed && !c->noerror && !ignore_errors_flag)
        -: 4549:      {
        -: 4550:	/* The commands failed.  Write an error message,
        -: 4551:	   delete non-precious targets, and abort.  */
        -: 4552:	child_error (c->file->name, c->cstatus, 0, 0, 0);
        -: 4553:	c->file->update_status = 1;
        -: 4554:	delete_child_targets (c);
        -: 4555:      }
        -: 4556:    else
        -: 4557:      {
        -: 4558:	if (child_failed)
        -: 4559:	  {
        -: 4560:	    /* The commands failed, but we don't care.  */
        -: 4561:	    child_error (c->file->name, c->cstatus, 0, 0, 1);
        -: 4562:	    child_failed = 0;
        -: 4563:	  }
        -: 4564:
        -: 4565:#if defined(RECURSIVEJOBS) /* I've had problems with recursive stuff and process handling */
        -: 4566:	/* If there are more commands to run, try to start them.  */
        -: 4567:	start_job (c);
        -: 4568:
        -: 4569:	switch (c->file->command_state)
        -: 4570:	  {
        -: 4571:	  case cs_running:
        -: 4572:	    /* Successfully started.  */
        -: 4573:	    break;
        -: 4574:
        -: 4575:	  case cs_finished:
        -: 4576:	    if (c->file->update_status != 0) {
        -: 4577:		/* We failed to start the commands.  */
        -: 4578:		delete_child_targets (c);
        -: 4579:	    }
        -: 4580:	    break;
        -: 4581:
        -: 4582:	  default:
        -: 4583:	    error ("internal error: `%s' command_state \
        -: 4584:%d in child_handler", c->file->name);
        -: 4585:	    abort ();
        -: 4586:	    break;
        -: 4587:	  }
        -: 4588:#endif /* RECURSIVEJOBS */
        -: 4589:      }
        -: 4590:
        -: 4591:    /* Set the state flag to say the commands have finished.  */
        -: 4592:    c->file->command_state = cs_finished;
        -: 4593:    notice_finished_file (c->file);
        -: 4594:
        -: 4595:#if defined(RECURSIVEJOBS) /* I've had problems with recursive stuff and process handling */
        -: 4596:    /* Remove the child from the chain and free it.  */
        -: 4597:    if (lastc == 0)
        -: 4598:      children = c->next;
        -: 4599:    else
        -: 4600:      lastc->next = c->next;
        -: 4601:    free_child (c);
        -: 4602:#endif /* RECURSIVEJOBS */
        -: 4603:
        -: 4604:    /* There is now another slot open.  */
        -: 4605:    if (job_slots_used > 0)
        -: 4606:      --job_slots_used;
        -: 4607:
        -: 4608:    /* If the job failed, and the -k flag was not given, die.  */
        -: 4609:    if (child_failed && !keep_going_flag)
        -: 4610:      die (EXIT_FAILURE);
        -: 4611:
        -: 4612:    (void) sigsetmask (sigblock (0) & ~(fatal_signal_mask));
        -: 4613:
        -: 4614:    return 1;
        -: 4615:}
        -: 4616:
        -: 4617:/* VMS:
        -: 4618:   Spawn a process executing the command in ARGV and return its pid. */
        -: 4619:
        -: 4620:#define MAXCMDLEN 200
        -: 4621:
        -: 4622:int
        -: 4623:child_execute_job (argv, child)
        -: 4624:     char *argv;
        -: 4625:     struct child *child;
        -: 4626:{
        -: 4627:  int i;
        -: 4628:  static struct dsc$descriptor_s cmddsc;
        -: 4629:#ifndef DONTWAITFORCHILD
        -: 4630:  int spflags = 0;
        -: 4631:#else
        -: 4632:  int spflags = CLI$M_NOWAIT;
        -: 4633:#endif
        -: 4634:  int status;
        -: 4635:  char cmd[4096],*p,*c;
        -: 4636:  char comname[50];
        -: 4637:
        -: 4638:/* Remove backslashes */
        -: 4639:  for (p = argv, c = cmd; *p; p++,c++)
        -: 4640:    {
        -: 4641:      if (*p == '\\') p++;
        -: 4642:	*c = *p;
        -: 4643:    }
        -: 4644:  *c = *p;
        -: 4645:
        -: 4646:  /* Check for maximum DCL length and create *.com file if neccesary.
        -: 4647:     Also create a .com file if the command is more than one line long.  */
        -: 4648:
        -: 4649:  comname[0] = '\0';
        -: 4650:
        -: 4651:  if (strlen (cmd) > MAXCMDLEN || strchr (cmd, '\n'))
        -: 4652:    {
        -: 4653:      FILE *outfile;
        -: 4654:      char tmp;
        -: 4655:
        -: 4656:      strcpy (comname, "sys$scratch:CMDXXXXXX.COM");
        -: 4657:      (void) mktemp (comname);
        -: 4658:
        -: 4659:      outfile = fopen (comname, "w");
        -: 4660:      if (outfile == 0)
        -: 4661:	pfatal_with_name (comname);
        -: 4662:
        -: 4663:      fprintf (outfile, "$ ");
        -: 4664:      c = cmd;
        -: 4665:
        -: 4666:      while (c)
        -: 4667:	{
        -: 4668:	  p = strchr (c, ',');
        -: 4669:	  if ((p == NULL) || (p-c > MAXCMDLEN))
        -: 4670:	    p = strchr (c, ' ');
        -: 4671:	  if (p != NULL)
        -: 4672:	    {
        -: 4673:	      p++;
        -: 4674:	      tmp = *p;
        -: 4675:	      *p = '\0';
        -: 4676:	    }
        -: 4677:	  else
        -: 4678:	    tmp = '\0';
        -: 4679:	  fprintf (outfile, "%s%s\n", c, (tmp == '\0')?"":" -");
        -: 4680:	  if (p != NULL)
        -: 4681:	    *p = tmp;
        -: 4682:	  c = p;
        -: 4683:	}
        -: 4684:
        -: 4685:      fclose (outfile);
        -: 4686:
        -: 4687:      sprintf (cmd, "$ @%s", comname);
        -: 4688:
        -: 4689:      if (debug_flag)
        -: 4690:	printf ("Executing %s instead\n", cmd);
        -: 4691:    }
        -: 4692:
        -: 4693:  cmddsc.dsc$w_length = strlen(cmd);
        -: 4694:  cmddsc.dsc$a_pointer = cmd;
        -: 4695:  cmddsc.dsc$b_dtype = DSC$K_DTYPE_T;
        -: 4696:  cmddsc.dsc$b_class = DSC$K_CLASS_S;
        -: 4697:
        -: 4698:  child->efn = 0;
        -: 4699:  while (child->efn < 32 || child->efn > 63)
        -: 4700:    {
        -: 4701:      status = lib$get_ef(&child->efn);
        -: 4702:      if (!(status & 1))
        -: 4703:	return 0;
        -: 4704:    }
        -: 4705:
        -: 4706:  sys$clref(child->efn);
        -: 4707:
        -: 4708:  vms_jobsefnmask |= (1 << (child->efn - 32));
        -: 4709:
        -: 4710:#ifndef DONTWAITFORCHILD
        -: 4711:  status = lib$spawn(&cmddsc,0,0,&spflags,0,&child->pid,&child->cstatus,
        -: 4712:		       &child->efn,0,0);
        -: 4713:  vmsHandleChildTerm(child);
        -: 4714:#else
        -: 4715:  status = lib$spawn(&cmddsc,0,0,&spflags,0,&child->pid,&child->cstatus,
        -: 4716:		       &child->efn,vmsHandleChildTerm,child);
        -: 4717:#endif
        -: 4718:
        -: 4719:  if (!(status & 1))
        -: 4720:    {
        -: 4721:      printf("Error spawning, %d\n",status);
        -: 4722:      fflush(stdout);
        -: 4723:    }
        -: 4724:
        -: 4725:  unlink (comname);
        -: 4726:
        -: 4727:  return (status & 1);
        -: 4728:}
        -: 4729:
        -: 4730:#else /* !VMS */
        -: 4731:
        -: 4732:#if !defined (_AMIGA) && !defined (__MSDOS__)
        -: 4733:/* UNIX:
        -: 4734:   Replace the current process with one executing the command in ARGV.
        -: 4735:   STDIN_FD and STDOUT_FD are used as the process's stdin and stdout; ENVP is
        -: 4736:   the environment of the new program.  This function does not return.  */
        -: 4737:
        -: 4738:void
function child_execute_job called 3 returned 0% blocks executed 60%
        3: 4739:child_execute_job (stdin_fd, stdout_fd, argv, envp)
        -: 4740:     int stdin_fd, stdout_fd;
        -: 4741:     char **argv, **envp;
        -: 4742:{
        3: 4743:  if (stdin_fd != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####: 4744:    (void) dup2 (stdin_fd, 0);
call    0 never executed
        3: 4745:  if (stdout_fd != 1)
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####: 4746:    (void) dup2 (stdout_fd, 1);
call    0 never executed
        3: 4747:  if (stdin_fd != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####: 4748:    (void) close (stdin_fd);
call    0 never executed
        3: 4749:  if (stdout_fd != 1)
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####: 4750:    (void) close (stdout_fd);
call    0 never executed
        -: 4751:
        -: 4752:  /* Run the command.  */
        3: 4753:  exec_command (argv, envp);
call    0 returned 0
    #####: 4754:}
        -: 4755:#endif /* !AMIGA && !__MSDOS__ */
        -: 4756:#endif /* !VMS */
        -: 4757:#endif /* !WINDOWS32 */
        -: 4758:
        -: 4759:#ifndef _AMIGA
        -: 4760:/* Replace the current process with one running the command in ARGV,
        -: 4761:   with environment ENVP.  This function does not return.  */
        -: 4762:
        -: 4763:void
function exec_command called 3 returned 0% blocks executed 20%
        3: 4764:exec_command (argv, envp)
        -: 4765:     char **argv, **envp;
        -: 4766:{
        -: 4767:#ifdef VMS
        -: 4768:  /* Run the program.  */
        -: 4769:  execve (argv[0], argv, envp);
        -: 4770:  perror_with_name ("execve: ", argv[0]);
        -: 4771:  _exit (EXIT_FAILURE);
        -: 4772:#else
        -: 4773:#ifdef WINDOWS32
        -: 4774:  HANDLE hPID;
        -: 4775:  HANDLE hWaitPID;
        -: 4776:  int err = 0;
        -: 4777:  int exit_code = EXIT_FAILURE;
        -: 4778:
        -: 4779:  /* make sure CreateProcess() has Path it needs */
        -: 4780:  sync_Path_environment();
        -: 4781:
        -: 4782:  /* launch command */
        -: 4783:  hPID = process_easy(argv, envp);
        -: 4784:
        -: 4785:  /* make sure launch ok */
        -: 4786:  if (hPID == INVALID_HANDLE_VALUE)
        -: 4787:    {
        -: 4788:      int i;
        -: 4789:      fprintf(stderr,
        -: 4790:              "process_easy() failed failed to launch process (e=%d)\n",
        -: 4791:              process_last_err(hPID));
        -: 4792:      for (i = 0; argv[i]; i++)
        -: 4793:          fprintf(stderr, "%s ", argv[i]);
        -: 4794:      fprintf(stderr, "\nCounted %d args in failed launch\n", i);
        -: 4795:      exit(EXIT_FAILURE);
        -: 4796:    }
        -: 4797:
        -: 4798:  /* wait and reap last child */
        -: 4799:  while (hWaitPID = process_wait_for_any())
        -: 4800:    {
        -: 4801:      /* was an error found on this process? */
        -: 4802:      err = process_last_err(hWaitPID);
        -: 4803:
        -: 4804:      /* get exit data */
        -: 4805:      exit_code = process_exit_code(hWaitPID);
        -: 4806:
        -: 4807:      if (err)
        -: 4808:          fprintf(stderr, "make (e=%d, rc=%d): %s",
        -: 4809:                  err, exit_code, map_windows32_error_to_string(err));
        -: 4810:
        -: 4811:      /* cleanup process */
        -: 4812:      process_cleanup(hWaitPID);
        -: 4813:
        -: 4814:      /* expect to find only last pid, warn about other pids reaped */
        -: 4815:      if (hWaitPID == hPID)
        -: 4816:          break;
        -: 4817:      else
        -: 4818:          fprintf(stderr,
        -: 4819:                  "make reaped child pid %d, still waiting for pid %d\n",
        -: 4820:                  hWaitPID, hPID);
        -: 4821:    }
        -: 4822:
        -: 4823:  /* return child's exit code as our exit code */
        -: 4824:  exit(exit_code);
        -: 4825:
        -: 4826:#else  /* !WINDOWS32 */
        -: 4827:
        -: 4828:  /* Be the user, permanently.  */
        3: 4829:  child_access ();
call    0 returned 3
        -: 4830:
        -: 4831:  /* Run the program.  */
        3: 4832:  environ = envp;
        3: 4833:  execvp (argv[0], argv);
        -: 4834:
        3: 4835:  switch (errno)
branch  0 taken 0
branch  1 taken 0
branch  2 taken 3
        -: 4836:    {
    #####: 4837:    case ENOENT:
    #####: 4838:      error ("%s: Command not found", argv[0]);
call    0 never executed
    #####: 4839:      break;
    #####: 4840:    case ENOEXEC:
        -: 4841:      {
        -: 4842:	/* The file is not executable.  Try it as a shell script.  */
        -: 4843:	extern char *getenv ();
        -: 4844:	char *shell;
        -: 4845:	char **new_argv;
        -: 4846:	int argc;
        -: 4847:
    #####: 4848:	shell = getenv ("SHELL");
call    0 never executed
    #####: 4849:	if (shell == 0)
branch  0 never executed
branch  1 never executed
    #####: 4850:	  shell = default_shell;
        -: 4851:
    #####: 4852:	argc = 1;
    #####: 4853:	while (argv[argc] != 0)
branch  0 never executed
branch  1 never executed
    #####: 4854:	  ++argc;
        -: 4855:
    #####: 4856:	new_argv = (char **) alloca ((1 + argc + 1) * sizeof (char *));
    #####: 4857:	new_argv[0] = shell;
    #####: 4858:	new_argv[1] = argv[0];
    #####: 4859:	while (argc > 0)
branch  0 never executed
branch  1 never executed
        -: 4860:	  {
    #####: 4861:	    new_argv[1 + argc] = argv[argc];
    #####: 4862:	    --argc;
        -: 4863:	  }
        -: 4864:
    #####: 4865:	execvp (shell, new_argv);
    #####: 4866:	if (errno == ENOENT)
branch  0 never executed
branch  1 never executed
    #####: 4867:	  error ("%s: Shell program not found", shell);
call    0 never executed
        -: 4868:	else
    #####: 4869:	  perror_with_name ("execvp: ", shell);
call    0 never executed
    #####: 4870:	break;
        -: 4871:      }
        -: 4872:
        3: 4873:    default:
        3: 4874:      perror_with_name ("execvp: ", argv[0]);
call    0 returned 0
    #####: 4875:      break;
        -: 4876:    }
        -: 4877:
    #####: 4878:  _exit (127);
        -: 4879:#endif /* !WINDOWS32 */
        -: 4880:#endif /* !VMS */
        -: 4881:}
        -: 4882:#else /* On Amiga */
        -: 4883:void exec_command (argv)
        -: 4884:     char **argv;
        -: 4885:{
        -: 4886:  MyExecute (argv);
        -: 4887:}
        -: 4888:
        -: 4889:void clean_tmp (void)
        -: 4890:{
        -: 4891:  DeleteFile (amiga_bname);
        -: 4892:}
        -: 4893:
        -: 4894:#endif /* On Amiga */
        -: 4895:
        -: 4896:#ifndef VMS
        -: 4897:/* Figure out the argument list necessary to run LINE as a command.  Try to
        -: 4898:   avoid using a shell.  This routine handles only ' quoting, and " quoting
        -: 4899:   when no backslash, $ or ` characters are seen in the quotes.  Starting
        -: 4900:   quotes may be escaped with a backslash.  If any of the characters in
        -: 4901:   sh_chars[] is seen, or any of the builtin commands listed in sh_cmds[]
        -: 4902:   is the first word of a line, the shell is used.
        -: 4903:
        -: 4904:   If RESTP is not NULL, *RESTP is set to point to the first newline in LINE.
        -: 4905:   If *RESTP is NULL, newlines will be ignored.
        -: 4906:
        -: 4907:   SHELL is the shell to use, or nil to use the default shell.
        -: 4908:   IFS is the value of $IFS, or nil (meaning the default).  */
        -: 4909:
        -: 4910:static char **
function construct_command_argv_internal called 4 returned 100% blocks executed 31%
        4: 4911:construct_command_argv_internal (line, restp, shell, ifs, batch_filename_ptr)
        -: 4912:     char *line, **restp;
        -: 4913:     char *shell, *ifs;
        -: 4914:     char **batch_filename_ptr;
        -: 4915:{
        -: 4916:#ifdef __MSDOS__
        -: 4917:  /* MSDOS supports both the stock DOS shell and ports of Unixy shells.
        -: 4918:     We call `system' for anything that requires ``slow'' processing,
        -: 4919:     because DOS shells are too dumb.  When $SHELL points to a real
        -: 4920:     (unix-style) shell, `system' just calls it to do everything.  When
        -: 4921:     $SHELL points to a DOS shell, `system' does most of the work
        -: 4922:     internally, calling the shell only for its internal commands.
        -: 4923:     However, it looks on the $PATH first, so you can e.g. have an
        -: 4924:     external command named `mkdir'.
        -: 4925:
        -: 4926:     Since we call `system', certain characters and commands below are
        -: 4927:     actually not specific to COMMAND.COM, but to the DJGPP implementation
        -: 4928:     of `system'.  In particular:
        -: 4929:
        -: 4930:       The shell wildcard characters are in DOS_CHARS because they will
        -: 4931:       not be expanded if we call the child via `spawnXX'.
        -: 4932:
        -: 4933:       The `;' is in DOS_CHARS, because our `system' knows how to run
        -: 4934:       multiple commands on a single line.
        -: 4935:
        -: 4936:       DOS_CHARS also include characters special to 4DOS/NDOS, so we
        -: 4937:       won't have to tell one from another and have one more set of
        -: 4938:       commands and special characters.  */
        -: 4939:  static char sh_chars_dos[] = "*?[];|<>%^&()";
        -: 4940:  static char *sh_cmds_dos[] = { "break", "call", "cd", "chcp", "chdir", "cls",
        -: 4941:				 "copy", "ctty", "date", "del", "dir", "echo",
        -: 4942:				 "erase", "exit", "for", "goto", "if", "md",
        -: 4943:				 "mkdir", "path", "pause", "prompt", "rd",
        -: 4944:				 "rmdir", "rem", "ren", "rename", "set",
        -: 4945:				 "shift", "time", "type", "ver", "verify",
        -: 4946:				 "vol", ":", 0 };
        -: 4947:
        -: 4948:  static char sh_chars_sh[]  = "#;\"*?[]&|<>(){}$`^";
        -: 4949:  static char *sh_cmds_sh[]  = { "cd", "eval", "exec", "exit", "login",
        -: 4950:				 "logout", "set", "umask", "wait", "while",
        -: 4951:				 "for", "case", "if", ":", ".", "break",
        -: 4952:				 "continue", "export", "read", "readonly",
        -: 4953:				 "shift", "times", "trap", "switch", 0 };
        -: 4954:
        -: 4955:  char *sh_chars;
        -: 4956:  char **sh_cmds;
        -: 4957:#else
        -: 4958:#ifdef _AMIGA
        -: 4959:  static char sh_chars[] = "#;\"|<>()?*$`";
        -: 4960:  static char *sh_cmds[] = { "cd", "eval", "if", "delete", "echo", "copy",
        -: 4961:			     "rename", "set", "setenv", "date", "makedir",
        -: 4962:			     "skip", "else", "endif", "path", "prompt",
        -: 4963:			     "unset", "unsetenv", "version",
        -: 4964:			     0 };
        -: 4965:#else
        -: 4966:#ifdef WINDOWS32
        -: 4967:  static char sh_chars_dos[] = "\"|<>";
        -: 4968:  static char *sh_cmds_dos[] = { "break", "call", "cd", "chcp", "chdir", "cls",
        -: 4969:			     "copy", "ctty", "date", "del", "dir", "echo",
        -: 4970:			     "erase", "exit", "for", "goto", "if", "if", "md",
        -: 4971:			     "mkdir", "path", "pause", "prompt", "rem", "ren",
        -: 4972:			     "rename", "set", "shift", "time", "type",
        -: 4973:			     "ver", "verify", "vol", ":", 0 };
        -: 4974:  static char sh_chars_sh[] = "#;\"*?[]&|<>(){}$`^";
        -: 4975:  static char *sh_cmds_sh[] = { "cd", "eval", "exec", "exit", "login",
        -: 4976:			     "logout", "set", "umask", "wait", "while", "for",
        -: 4977:			     "case", "if", ":", ".", "break", "continue",
        -: 4978:			     "export", "read", "readonly", "shift", "times",
        -: 4979:			     "trap", "switch", "test",
        -: 4980:#ifdef BATCH_MODE_ONLY_SHELL
        -: 4981:                 "echo",
        -: 4982:#endif
        -: 4983:                 0 };
        -: 4984:  char*  sh_chars;
        -: 4985:  char** sh_cmds;
        -: 4986:#else  /* WINDOWS32 */
        -: 4987:  static char sh_chars[] = "#;\"*?[]&|<>(){}$`^";
        -: 4988:  static char *sh_cmds[] = { "cd", "eval", "exec", "exit", "login",
        -: 4989:			     "logout", "set", "umask", "wait", "while", "for",
        -: 4990:			     "case", "if", ":", ".", "break", "continue",
        -: 4991:			     "export", "read", "readonly", "shift", "times",
        -: 4992:			     "trap", "switch", 0 };
        -: 4993:#endif /* WINDOWS32 */
        -: 4994:#endif /* Amiga */
        -: 4995:#endif /* __MSDOS__ */
        -: 4996:  register int i;
        -: 4997:  register char *p;
        -: 4998:  register char *ap;
        -: 4999:  char *end;
        -: 5000:  int instring, word_has_equals, seen_nonequals, last_argument_was_empty;
        4: 5001:  char **new_argv = 0;
        -: 5002:#ifdef WINDOWS32
        -: 5003:  int slow_flag = 0;
        -: 5004:
        -: 5005:  if (no_default_sh_exe) {
        -: 5006:    sh_cmds = sh_cmds_dos;
        -: 5007:    sh_chars = sh_chars_dos;
        -: 5008:  } else {
        -: 5009:    sh_cmds = sh_cmds_sh;
        -: 5010:    sh_chars = sh_chars_sh;
        -: 5011:  }
        -: 5012:#endif /* WINDOWS32 */
        -: 5013:
        4: 5014:  if (restp != NULL)
branch  0 taken 4 (fallthrough)
branch  1 taken 0
        4: 5015:    *restp = NULL;
        -: 5016:
        -: 5017:  /* Make sure not to bother processing an empty line.  */
        4: 5018:  while (isblank (*line))
branch  0 taken 0
branch  1 taken 4 (fallthrough)
    #####: 5019:    ++line;
        4: 5020:  if (*line == '\0')
branch  0 taken 0 (fallthrough)
branch  1 taken 4
    #####: 5021:    return 0;
        -: 5022:
        -: 5023:  /* See if it is safe to parse commands internally.  */
        4: 5024:  if (shell == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 4
    #####: 5025:    shell = default_shell;
        -: 5026:#ifdef WINDOWS32
        -: 5027:  else if (strcmp (shell, default_shell))
        -: 5028:  {
        -: 5029:    char *s1 = _fullpath(NULL, shell, 0);
        -: 5030:    char *s2 = _fullpath(NULL, default_shell, 0);
        -: 5031:
        -: 5032:    slow_flag = strcmp((s1 ? s1 : ""), (s2 ? s2 : ""));
        -: 5033:
        -: 5034:    if (s1);
        -: 5035:      free(s1);
        -: 5036:    if (s2);
        -: 5037:      free(s2);
        -: 5038:  }
        -: 5039:  if (slow_flag)
        -: 5040:    goto slow;
        -: 5041:#else  /* not WINDOWS32 */
        -: 5042:#ifdef __MSDOS__
        -: 5043:  else if (stricmp (shell, default_shell))
        -: 5044:    {
        -: 5045:      extern int _is_unixy_shell (const char *_path);
        -: 5046:
        -: 5047:      message (1, "$SHELL changed (was `%s', now `%s')", default_shell, shell);
        -: 5048:      unixy_shell = _is_unixy_shell (shell);
        -: 5049:      default_shell = shell;
        -: 5050:    }
        -: 5051:  if (unixy_shell)
        -: 5052:    {
        -: 5053:      sh_chars = sh_chars_sh;
        -: 5054:      sh_cmds  = sh_cmds_sh;
        -: 5055:    }
        -: 5056:  else
        -: 5057:    {
        -: 5058:      sh_chars = sh_chars_dos;
        -: 5059:      sh_cmds  = sh_cmds_dos;
        -: 5060:    }
        -: 5061:#else  /* not __MSDOS__ */
        4: 5062:  else if (strcmp (shell, default_shell))
branch  0 taken 0 (fallthrough)
branch  1 taken 4
    #####: 5063:    goto slow;
        -: 5064:#endif /* not __MSDOS__ */
        -: 5065:#endif /* not WINDOWS32 */
        -: 5066:
        4: 5067:  if (ifs != 0)
branch  0 taken 4 (fallthrough)
branch  1 taken 0
       4*: 5068:    for (ap = ifs; *ap != '\0'; ++ap)
branch  0 taken 0
branch  1 taken 4 (fallthrough)
    #####: 5069:      if (*ap != ' ' && *ap != '\t' && *ap != '\n')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 5070:	goto slow;
        -: 5071:
        4: 5072:  i = strlen (line) + 1;
        -: 5073:
        -: 5074:  /* More than 1 arg per character is impossible.  */
        4: 5075:  new_argv = (char **) xmalloc (i * sizeof (char *));
call    0 returned 4
        -: 5076:
        -: 5077:  /* All the args can fit in a buffer as big as LINE is.   */
        4: 5078:  ap = new_argv[0] = (char *) xmalloc (i);
call    0 returned 4
        4: 5079:  end = ap + i;
        -: 5080:
        -: 5081:  /* I is how many complete arguments have been found.  */
        4: 5082:  i = 0;
        4: 5083:  instring = word_has_equals = seen_nonequals = last_argument_was_empty = 0;
      324: 5084:  for (p = line; *p != '\0'; ++p)
branch  0 taken 320
branch  1 taken 4 (fallthrough)
        -: 5085:    {
      320: 5086:      if (ap > end)
branch  0 taken 0 (fallthrough)
branch  1 taken 320
    #####: 5087:	abort ();
call    0 never executed
        -: 5088:
      320: 5089:      if (instring)
branch  0 taken 0 (fallthrough)
branch  1 taken 320
        -: 5090:	{
    #####: 5091:	string_char:
        -: 5092:	  /* Inside a string, just copy any char except a closing quote
        -: 5093:	     or a backslash-newline combination.  */
    #####: 5094:	  if (*p == instring)
branch  0 never executed
branch  1 never executed
        -: 5095:	    {
    #####: 5096:	      instring = 0;
    #####: 5097:	      if (ap == new_argv[0] || *(ap-1) == '\0')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 5098:		last_argument_was_empty = 1;
        -: 5099:	    }
    #####: 5100:	  else if (*p == '\\' && p[1] == '\n')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 5101:	    goto swallow_escaped_newline;
    #####: 5102:	  else if (*p == '\n' && restp != NULL)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 5103:	    {
        -: 5104:	      /* End of the command line.  */
    #####: 5105:	      *restp = p;
    #####: 5106:	      goto end_of_line;
        -: 5107:	    }
        -: 5108:	  /* Backslash, $, and ` are special inside double quotes.
        -: 5109:	     If we see any of those, punt.
        -: 5110:	     But on MSDOS, if we use COMMAND.COM, double and single
        -: 5111:	     quotes have the same effect.  */
    #####: 5112:	  else if (instring == '"' && index ("\\$`", *p) != 0 && unixy_shell)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 5113:	    goto slow;
        -: 5114:	  else
    #####: 5115:	    *ap++ = *p;
        -: 5116:	}
      320: 5117:      else if (index (sh_chars, *p) != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 320
        -: 5118:	/* Not inside a string, but it's a special char.  */
    #####: 5119:	goto slow;
        -: 5120:#ifdef  __MSDOS__
        -: 5121:      else if (*p == '.' && p[1] == '.' && p[2] == '.' && p[3] != '.')
        -: 5122:	/* `...' is a wildcard in DJGPP.  */
        -: 5123:	goto slow;
        -: 5124:#endif
        -: 5125:      else
        -: 5126:	/* Not a special char.  */
      320: 5127:	switch (*p)
branch  0 taken 10
branch  1 taken 0
branch  2 taken 0
branch  3 taken 0
branch  4 taken 32
branch  5 taken 278
        -: 5128:	  {
       10: 5129:	  case '=':
        -: 5130:	    /* Equals is a special character in leading words before the
        -: 5131:	       first word with no equals sign in it.  This is not the case
        -: 5132:	       with sh -k, but we never get here when using nonstandard
        -: 5133:	       shell flags.  */
      10*: 5134:	    if (! seen_nonequals && unixy_shell)
branch  0 taken 0 (fallthrough)
branch  1 taken 10
branch  2 never executed
branch  3 never executed
    #####: 5135:	      goto slow;
       10: 5136:	    word_has_equals = 1;
       10: 5137:	    *ap++ = '=';
       10: 5138:	    break;
        -: 5139:
    #####: 5140:	  case '\\':
        -: 5141:	    /* Backslash-newline combinations are eaten.  */
    #####: 5142:	    if (p[1] == '\n')
branch  0 never executed
branch  1 never executed
        -: 5143:	      {
    #####: 5144:	      swallow_escaped_newline:
        -: 5145:
        -: 5146:		/* Eat the backslash, the newline, and following whitespace,
        -: 5147:		   replacing it all with a single space.  */
    #####: 5148:		p += 2;
        -: 5149:
        -: 5150:		/* If there is a tab after a backslash-newline,
        -: 5151:		   remove it from the source line which will be echoed,
        -: 5152:		   since it was most likely used to line
        -: 5153:		   up the continued line with the previous one.  */
    #####: 5154:		if (*p == '\t')
branch  0 never executed
branch  1 never executed
    #####: 5155:		  strcpy (p, p + 1);
        -: 5156:
    #####: 5157:		if (instring)
branch  0 never executed
branch  1 never executed
    #####: 5158:		  goto string_char;
        -: 5159:		else
        -: 5160:		  {
    #####: 5161:		    if (ap != new_argv[i])
branch  0 never executed
branch  1 never executed
        -: 5162:		      /* Treat this as a space, ending the arg.
        -: 5163:			 But if it's at the beginning of the arg, it should
        -: 5164:			 just get eaten, rather than becoming an empty arg. */
    #####: 5165:		      goto end_of_arg;
        -: 5166:		    else
    #####: 5167:		      p = next_token (p) - 1;
call    0 never executed
        -: 5168:		  }
        -: 5169:	      }
    #####: 5170:	    else if (p[1] != '\0')
branch  0 never executed
branch  1 never executed
        -: 5171:	      /* Copy and skip the following char.  */
    #####: 5172:	      *ap++ = *++p;
    #####: 5173:	    break;
        -: 5174:
    #####: 5175:	  case '\'':
        -: 5176:	  case '"':
    #####: 5177:	    instring = *p;
    #####: 5178:	    break;
        -: 5179:
    #####: 5180:	  case '\n':
    #####: 5181:	    if (restp != NULL)
branch  0 never executed
branch  1 never executed
        -: 5182:	      {
        -: 5183:		/* End of the command line.  */
    #####: 5184:		*restp = p;
    #####: 5185:		goto end_of_line;
        -: 5186:	      }
        -: 5187:	    else
        -: 5188:	      /* Newlines are not special.  */
    #####: 5189:	      *ap++ = '\n';
    #####: 5190:	    break;
        -: 5191:
        -: 5192:	  case ' ':
        -: 5193:	  case '\t':
       32: 5194:	  end_of_arg:
        -: 5195:	    /* We have the end of an argument.
        -: 5196:	       Terminate the text of the argument.  */
       32: 5197:	    *ap++ = '\0';
       32: 5198:	    new_argv[++i] = ap;
       32: 5199:	    last_argument_was_empty = 0;
        -: 5200:
        -: 5201:	    /* Update SEEN_NONEQUALS, which tells us if every word
        -: 5202:	       heretofore has contained an `='.  */
       32: 5203:	    seen_nonequals |= ! word_has_equals;
       32: 5204:	    if (word_has_equals && ! seen_nonequals)
branch  0 taken 10 (fallthrough)
branch  1 taken 22
branch  2 taken 0 (fallthrough)
branch  3 taken 10
        -: 5205:	      /* An `=' in a word before the first
        -: 5206:		 word without one is magical.  */
    #####: 5207:	      goto slow;
       32: 5208:	    word_has_equals = 0; /* Prepare for the next word.  */
        -: 5209:
        -: 5210:	    /* If this argument is the command name,
        -: 5211:	       see if it is a built-in shell command.
        -: 5212:	       If so, have the shell handle it.  */
       32: 5213:	    if (i == 1)
branch  0 taken 4 (fallthrough)
branch  1 taken 28
        -: 5214:	      {
        -: 5215:		register int j;
      100: 5216:		for (j = 0; sh_cmds[j] != 0; ++j)
branch  0 taken 96
branch  1 taken 4 (fallthrough)
      96*: 5217:		  if (streq (sh_cmds[j], new_argv[0]))
branch  0 taken 96 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 96
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####: 5218:		    goto slow;
        -: 5219:	      }
        -: 5220:
        -: 5221:	    /* Ignore multiple whitespace chars.  */
       32: 5222:	    p = next_token (p);
call    0 returned 32
        -: 5223:	    /* Next iteration should examine the first nonwhite char.  */
       32: 5224:	    --p;
       32: 5225:	    break;
        -: 5226:
      278: 5227:	  default:
      278: 5228:	    *ap++ = *p;
      278: 5229:	    break;
        -: 5230:	  }
        -: 5231:    }
        4: 5232: end_of_line:
        -: 5233:
        4: 5234:  if (instring)
branch  0 taken 0 (fallthrough)
branch  1 taken 4
        -: 5235:    /* Let the shell deal with an unterminated quote.  */
    #####: 5236:    goto slow;
        -: 5237:
        -: 5238:  /* Terminate the last argument and the argument list.  */
        -: 5239:
        4: 5240:  *ap = '\0';
        4: 5241:  if (new_argv[i][0] != '\0' || last_argument_was_empty)
branch  0 taken 2 (fallthrough)
branch  1 taken 2
branch  2 taken 0 (fallthrough)
branch  3 taken 2
        2: 5242:    ++i;
        4: 5243:  new_argv[i] = 0;
        -: 5244:
        4: 5245:  if (i == 1)
branch  0 taken 0 (fallthrough)
branch  1 taken 4
        -: 5246:    {
        -: 5247:      register int j;
    #####: 5248:      for (j = 0; sh_cmds[j] != 0; ++j)
branch  0 never executed
branch  1 never executed
    #####: 5249:	if (streq (sh_cmds[j], new_argv[0]))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####: 5250:	  goto slow;
        -: 5251:    }
        -: 5252:
        4: 5253:  if (new_argv[0] == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 4
        -: 5254:    /* Line was empty.  */
    #####: 5255:    return 0;
        -: 5256:  else
        4: 5257:    return new_argv;
        -: 5258:
    #####: 5259: slow:;
        -: 5260:  /* We must use the shell.  */
        -: 5261:
    #####: 5262:  if (new_argv != 0)
branch  0 never executed
branch  1 never executed
        -: 5263:    {
        -: 5264:      /* Free the old argument list we were working on.  */
    #####: 5265:      free (new_argv[0]);
    #####: 5266:      free ((void *)new_argv);
        -: 5267:    }
        -: 5268:
        -: 5269:#ifdef __MSDOS__
        -: 5270:  execute_by_shell = 1;	/* actually, call `system' if shell isn't unixy */
        -: 5271:#endif
        -: 5272:
        -: 5273:#ifdef _AMIGA
        -: 5274:  {
        -: 5275:    char *ptr;
        -: 5276:    char *buffer;
        -: 5277:    char *dptr;
        -: 5278:
        -: 5279:    buffer = (char *)xmalloc (strlen (line)+1);
        -: 5280:
        -: 5281:    ptr = line;
        -: 5282:    for (dptr=buffer; *ptr; )
        -: 5283:    {
        -: 5284:      if (*ptr == '\\' && ptr[1] == '\n')
        -: 5285:	ptr += 2;
        -: 5286:      else if (*ptr == '@') /* Kludge: multiline commands */
        -: 5287:      {
        -: 5288:	ptr += 2;
        -: 5289:	*dptr++ = '\n';
        -: 5290:      }
        -: 5291:      else
        -: 5292:	*dptr++ = *ptr++;
        -: 5293:    }
        -: 5294:    *dptr = 0;
        -: 5295:
        -: 5296:    new_argv = (char **) xmalloc(2 * sizeof(char *));
        -: 5297:    new_argv[0] = buffer;
        -: 5298:    new_argv[1] = 0;
        -: 5299:  }
        -: 5300:#else	/* Not Amiga  */
        -: 5301:#ifdef WINDOWS32
        -: 5302:  /*
        -: 5303:   * Not eating this whitespace caused things like
        -: 5304:   *
        -: 5305:   *    sh -c "\n"
        -: 5306:   *
        -: 5307:   * which gave the shell fits. I think we have to eat
        -: 5308:   * whitespace here, but this code should be considered
        -: 5309:   * suspicious if things start failing....
        -: 5310:   */
        -: 5311:
        -: 5312:  /* Make sure not to bother processing an empty line.  */
        -: 5313:  while (isspace (*line))
        -: 5314:    ++line;
        -: 5315:  if (*line == '\0')
        -: 5316:    return 0;
        -: 5317:#endif /* WINDOWS32 */
        -: 5318:  {
        -: 5319:    /* SHELL may be a multi-word command.  Construct a command line
        -: 5320:       "SHELL -c LINE", with all special chars in LINE escaped.
        -: 5321:       Then recurse, expanding this command line to get the final
        -: 5322:       argument list.  */
        -: 5323:
    #####: 5324:    unsigned int shell_len = strlen (shell);
        -: 5325:    static char minus_c[] = " -c ";
    #####: 5326:    unsigned int line_len = strlen (line);
        -: 5327:
    #####: 5328:    char *new_line = (char *) alloca (shell_len + (sizeof (minus_c) - 1)
        -: 5329:				      + (line_len * 2) + 1);
    #####: 5330:    char* command_ptr = NULL; /* used for batch_mode_shell mode */
        -: 5331:
    #####: 5332:    ap = new_line;
    #####: 5333:    bcopy (shell, ap, shell_len);
    #####: 5334:    ap += shell_len;
    #####: 5335:    bcopy (minus_c, ap, sizeof (minus_c) - 1);
    #####: 5336:    ap += sizeof (minus_c) - 1;
    #####: 5337:	command_ptr = ap;
    #####: 5338:    for (p = line; *p != '\0'; ++p)
branch  0 never executed
branch  1 never executed
        -: 5339:      {
    #####: 5340:	if (restp != NULL && *p == '\n')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 5341:	  {
    #####: 5342:	    *restp = p;
    #####: 5343:	    break;
        -: 5344:	  }
    #####: 5345:	else if (*p == '\\' && p[1] == '\n')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 5346:	  {
        -: 5347:	    /* Eat the backslash, the newline, and following whitespace,
        -: 5348:	       replacing it all with a single space (which is escaped
        -: 5349:	       from the shell).  */
    #####: 5350:	    p += 2;
        -: 5351:
        -: 5352:	    /* If there is a tab after a backslash-newline,
        -: 5353:	       remove it from the source line which will be echoed,
        -: 5354:	       since it was most likely used to line
        -: 5355:	       up the continued line with the previous one.  */
    #####: 5356:	    if (*p == '\t')
branch  0 never executed
branch  1 never executed
    #####: 5357:	      bcopy (p + 1, p, strlen (p));
        -: 5358:
    #####: 5359:	    p = next_token (p);
call    0 never executed
    #####: 5360:	    --p;
    #####: 5361:        if (unixy_shell && !batch_mode_shell)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 5362:          *ap++ = '\\';
    #####: 5363:	    *ap++ = ' ';
    #####: 5364:	    continue;
        -: 5365:	  }
        -: 5366:
        -: 5367:        /* DOS shells don't know about backslash-escaping.  */
    #####: 5368:	if (unixy_shell && !batch_mode_shell &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 5369:            (*p == '\\' || *p == '\'' || *p == '"'
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 5370:             || isspace (*p)
branch  0 never executed
branch  1 never executed
    #####: 5371:             || index (sh_chars, *p) != 0))
branch  0 never executed
branch  1 never executed
    #####: 5372:	  *ap++ = '\\';
        -: 5373:#ifdef __MSDOS__
        -: 5374:        else if (unixy_shell && strncmp (p, "...", 3) == 0)
        -: 5375:          {
        -: 5376:            /* The case of `...' wildcard again.  */
        -: 5377:            strcpy (ap, "\\.\\.\\");
        -: 5378:            ap += 5;
        -: 5379:            p  += 2;
        -: 5380:          }
        -: 5381:#endif
    #####: 5382:	*ap++ = *p;
        -: 5383:      }
    #####: 5384:    if (ap == new_line + shell_len + sizeof (minus_c) - 1)
branch  0 never executed
branch  1 never executed
        -: 5385:      /* Line was empty.  */
    #####: 5386:      return 0;
    #####: 5387:    *ap = '\0';
        -: 5388:
        -: 5389:#ifdef WINDOWS32
        -: 5390:    /*
        -: 5391:	 * Some shells do not work well when invoked as 'sh -c  xxx' to run
        -: 5392:	 * a command line (e.g. Cygnus GNUWIN32 sh.exe on WIN32 systems).
        -: 5393:	 * In these cases, run commands via a script file.
        -: 5394:     */
        -: 5395:    if ((no_default_sh_exe || batch_mode_shell) && batch_filename_ptr) {
        -: 5396:      FILE* batch = NULL;
        -: 5397:      int id = GetCurrentProcessId();
        -: 5398:      PATH_VAR(fbuf);
        -: 5399:      char* fname = NULL;
        -: 5400:
        -: 5401:      /* create a file name */
        -: 5402:      sprintf(fbuf, "make%d", id);
        -: 5403:      fname = tempnam(".", fbuf);
        -: 5404:
        -: 5405:	  /* create batch file name */
        -: 5406:      *batch_filename_ptr = xmalloc(strlen(fname) + 5);
        -: 5407:      strcpy(*batch_filename_ptr, fname);
        -: 5408:
        -: 5409:      /* make sure path name is in DOS backslash format */
        -: 5410:      if (!unixy_shell) {
        -: 5411:        fname = *batch_filename_ptr;
        -: 5412:        for (i = 0; fname[i] != '\0'; ++i)
        -: 5413:          if (fname[i] == '/')
        -: 5414:            fname[i] = '\\';
        -: 5415:        strcat(*batch_filename_ptr, ".bat");
        -: 5416:      } else {
        -: 5417:        strcat(*batch_filename_ptr, ".sh");
        -: 5418:      }
        -: 5419:
        -: 5420:      if (debug_flag)
        -: 5421:        printf("Creating temporary batch file %s\n", *batch_filename_ptr);
        -: 5422:
        -: 5423:      /* create batch file to execute command */
        -: 5424:      batch = fopen (*batch_filename_ptr, "w");
        -: 5425:      fputs ("@echo off\n", batch);
        -: 5426:      fputs (command_ptr, batch);
        -: 5427:      fputc ('\n', batch);
        -: 5428:      fclose (batch);
        -: 5429:
        -: 5430:      /* create argv */
        -: 5431:      new_argv = (char **) xmalloc(3 * sizeof(char *));
        -: 5432:      if (unixy_shell) {
        -: 5433:        new_argv[0] = strdup (shell);
        -: 5434:        new_argv[1] = *batch_filename_ptr; /* only argv[0] gets freed later */
        -: 5435:      } else {
        -: 5436:        new_argv[0] = strdup (*batch_filename_ptr);
        -: 5437:        new_argv[1] = NULL;
        -: 5438:      }
        -: 5439:      new_argv[2] = NULL;
        -: 5440:    } else
        -: 5441:#endif /* WINDOWS32 */
    #####: 5442:    if (unixy_shell)
branch  0 never executed
branch  1 never executed
    #####: 5443:      new_argv = construct_command_argv_internal (new_line, (char **) NULL,
call    0 never executed
        -: 5444:                                                  (char *) 0, (char *) 0,
        -: 5445:                                                  (char *) 0);
        -: 5446:#ifdef  __MSDOS__
        -: 5447:    else
        -: 5448:      {
        -: 5449:      /* With MSDOS shells, we must construct the command line here
        -: 5450:         instead of recursively calling ourselves, because we
        -: 5451:         cannot backslash-escape the special characters (see above).  */
        -: 5452:      new_argv = (char **) xmalloc (sizeof (char *));
        -: 5453:      line_len = strlen (new_line) - shell_len - sizeof (minus_c) + 1;
        -: 5454:      new_argv[0] = xmalloc (line_len + 1);
        -: 5455:      strncpy (new_argv[0],
        -: 5456:               new_line + shell_len + sizeof (minus_c) - 1, line_len);
        -: 5457:      new_argv[0][line_len] = '\0';
        -: 5458:      }
        -: 5459:#else
        -: 5460:    else
    #####: 5461:      fatal("%s (line %d) Invalid shell context (!unixy && !batch_mode_shell)\n",
call    0 never executed
        -: 5462:            __FILE__, __LINE__);
        -: 5463:#endif
        -: 5464:  }
        -: 5465:#endif	/* ! AMIGA */
        -: 5466:
    #####: 5467:  return new_argv;
        -: 5468:}
        -: 5469:
        -: 5470:/* Figure out the argument list necessary to run LINE as a command.  Try to
        -: 5471:   avoid using a shell.  This routine handles only ' quoting, and " quoting
        -: 5472:   when no backslash, $ or ` characters are seen in the quotes.  Starting
        -: 5473:   quotes may be escaped with a backslash.  If any of the characters in
        -: 5474:   sh_chars[] is seen, or any of the builtin commands listed in sh_cmds[]
        -: 5475:   is the first word of a line, the shell is used.
        -: 5476:
        -: 5477:   If RESTP is not NULL, *RESTP is set to point to the first newline in LINE.
        -: 5478:   If *RESTP is NULL, newlines will be ignored.
        -: 5479:
        -: 5480:   FILE is the target whose commands these are.  It is used for
        -: 5481:   variable expansion for $(SHELL) and $(IFS).  */
        -: 5482:
        -: 5483:char **
function construct_command_argv called 4 returned 100% blocks executed 100%
        4: 5484:construct_command_argv (line, restp, file, batch_filename_ptr)
        -: 5485:     char *line, **restp;
        -: 5486:     struct file *file;
        -: 5487:     char** batch_filename_ptr;
        -: 5488:{
        -: 5489:  char *shell, *ifs;
        -: 5490:  char **argv;
        -: 5491:
        -: 5492:  {
        -: 5493:    /* Turn off --warn-undefined-variables while we expand SHELL and IFS.  */
        4: 5494:    int save = warn_undefined_variables_flag;
        4: 5495:    warn_undefined_variables_flag = 0;
        -: 5496:
        4: 5497:    shell = allocated_variable_expand_for_file ("$(SHELL)", file);
call    0 returned 4
        -: 5498:#ifdef WINDOWS32
        -: 5499:    /*
        -: 5500:     * Convert to forward slashes so that construct_command_argv_internal()
        -: 5501:     * is not confused.
        -: 5502:     */
        -: 5503:    if (shell) {
        -: 5504:      char *p = w32ify(shell, 0);
        -: 5505:      strcpy(shell, p);
        -: 5506:    }
        -: 5507:#endif
        4: 5508:    ifs = allocated_variable_expand_for_file ("$(IFS)", file);
call    0 returned 4
        -: 5509:
        4: 5510:    warn_undefined_variables_flag = save;
        -: 5511:  }
        -: 5512:
        4: 5513:  argv = construct_command_argv_internal (line, restp, shell, ifs, batch_filename_ptr);
call    0 returned 4
        -: 5514:
        4: 5515:  free (shell);
        4: 5516:  free (ifs);
        -: 5517:
        4: 5518:  return argv;
        -: 5519:}
        -: 5520:#endif /* !VMS */
        -: 5521:
        -: 5522:#if !defined(HAVE_DUP2) && !defined(_AMIGA)
        -: 5523:int
        -: 5524:dup2 (old, new)
        -: 5525:     int old, new;
        -: 5526:{
        -: 5527:  int fd;
        -: 5528:
        -: 5529:  (void) close (new);
        -: 5530:  fd = dup (old);
        -: 5531:  if (fd != new)
        -: 5532:    {
        -: 5533:      (void) close (fd);
        -: 5534:      errno = EMFILE;
        -: 5535:      return -1;
        -: 5536:    }
        -: 5537:
        -: 5538:  return fd;
        -: 5539:}
        -: 5540:#endif /* !HAPE_DUP2 && !_AMIGA */
        -: 5541:
        -: 5542:
        -: 5543:
        -: 5544:/*************************************************************
        -: 5545:  ============================================================
        -: 5546:  ************************************************************
        -: 5547:  ============================================================
        -: 5548:  ************************************************************
        -: 5549:                         dir.c
        -: 5550:  ************************************************************
        -: 5551:  ============================================================
        -: 5552:  ************************************************************
        -: 5553:  ============================================================
        -: 5554:  *************************************************************/
        -: 5555:
        -: 5556:/* Directory hashing for GNU Make.
        -: 5557:Copyright (C) 1988,89,91,92,93,94,95,96,97 Free Software Foundation, Inc.
        -: 5558:This file is part of GNU Make.
        -: 5559:
        -: 5560:GNU Make is free software; you can redistribute it and/or modify
        -: 5561:it under the terms of the GNU General Public License as published by
        -: 5562:the Free Software Foundation; either version 2, or (at your option)
        -: 5563:any later version.
        -: 5564:
        -: 5565:GNU Make is distributed in the hope that it will be useful,
        -: 5566:but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 5567:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 5568:GNU General Public License for more details.
        -: 5569:
        -: 5570:You should have received a copy of the GNU General Public License
        -: 5571:along with GNU Make; see the file COPYING.  If not, write to
        -: 5572:the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
        -: 5573:
        -: 5574:
        -: 5575:
        -: 5576:#ifdef	HAVE_DIRENT_H
        -: 5577:# include <dirent.h>
        -: 5578:#undef stderr
        -: 5579:#define stderr stdout
        -: 5580:# define NAMLEN(dirent) strlen((dirent)->d_name)
        -: 5581:#else
        -: 5582:# define dirent direct
        -: 5583:# define NAMLEN(dirent) (dirent)->d_namlen
        -: 5584:# ifdef HAVE_SYS_NDIR_H
        -: 5585:#  include <sys/ndir.h>
        -: 5586:#undef stderr
        -: 5587:#define stderr stdout
        -: 5588:# endif
        -: 5589:# ifdef HAVE_SYS_DIR_H
        -: 5590:#  include <sys/dir.h>
        -: 5591:#undef stderr
        -: 5592:#define stderr stdout
        -: 5593:# endif
        -: 5594:# ifdef HAVE_NDIR_H
        -: 5595:#  include <ndir.h>
        -: 5596:#undef stderr
        -: 5597:#define stderr stdout
        -: 5598:# endif
        -: 5599:# ifdef HAVE_VMSDIR_H
        -: 5600:#  include "vmsdir.h"
        -: 5601:#undef stderr
        -: 5602:#define stderr stdout
        -: 5603:# endif /* HAVE_VMSDIR_H */
        -: 5604:#endif
        -: 5605:
        -: 5606:/* In GNU systems, <dirent.h> defines this macro for us.  */
        -: 5607:#ifdef _D_NAMLEN
        -: 5608:#undef NAMLEN
        -: 5609:#define NAMLEN(d) _D_NAMLEN(d)
        -: 5610:#endif
        -: 5611:
        -: 5612:#if (defined (POSIX) || defined (WINDOWS32)) && !defined (__GNU_LIBRARY__)
        -: 5613:/* Posix does not require that the d_ino field be present, and some
        -: 5614:   systems do not provide it. */
        -: 5615:#define REAL_DIR_ENTRY(dp) 1
        -: 5616:#define FAKE_DIR_ENTRY(dp)
        -: 5617:#else
        -: 5618:#define REAL_DIR_ENTRY(dp) (dp->d_ino != 0)
        -: 5619:#define FAKE_DIR_ENTRY(dp) (dp->d_ino = 1)
        -: 5620:#endif /* POSIX */
        -: 5621:
        -: 5622:#ifdef __MSDOS__
        -: 5623:#include <ctype.h>
        -: 5624:#include <fcntl.h>
        -: 5625:#undef stderr
        -: 5626:#define stderr stdout
        -: 5627:
        -: 5628:/* If it's MSDOS that doesn't have _USE_LFN, disable LFN support.  */
        -: 5629:#ifndef _USE_LFN
        -: 5630:#define _USE_LFN 0
        -: 5631:#endif
        -: 5632:
        -: 5633:static char *
        -: 5634:dosify (filename)
        -: 5635:     char *filename;
        -: 5636:{
        -: 5637:  static char dos_filename[14];
        -: 5638:  char *df;
        -: 5639:  int i;
        -: 5640:
        -: 5641:  if (filename == 0 || _USE_LFN)
        -: 5642:    return filename;
        -: 5643:
        -: 5644:  /* FIXME: what about filenames which violate
        -: 5645:     8+3 constraints, like "config.h.in", or ".emacs"?  */
        -: 5646:  if (strpbrk (filename, "\"*+,;<=>?[\\]|") != 0)
        -: 5647:    return filename;
        -: 5648:
        -: 5649:  df = dos_filename;
        -: 5650:
        -: 5651:  /* First, transform the name part.  */
        -: 5652:  for (i = 0; *filename != '\0' && i < 8 && *filename != '.'; ++i)
        -: 5653:    *df++ = tolower (*filename++);
        -: 5654:
        -: 5655:  /* Now skip to the next dot.  */
        -: 5656:  while (*filename != '\0' && *filename != '.')
        -: 5657:    ++filename;
        -: 5658:  if (*filename != '\0')
        -: 5659:    {
        -: 5660:      *df++ = *filename++;
        -: 5661:      for (i = 0; *filename != '\0' && i < 3 && *filename != '.'; ++i)
        -: 5662:	*df++ = tolower (*filename++);
        -: 5663:    }
        -: 5664:
        -: 5665:  /* Look for more dots.  */
        -: 5666:  while (*filename != '\0' && *filename != '.')
        -: 5667:    ++filename;
        -: 5668:  if (*filename == '.')
        -: 5669:    return filename;
        -: 5670:  *df = 0;
        -: 5671:  return dos_filename;
        -: 5672:}
        -: 5673:#endif /* __MSDOS__ */
        -: 5674:
        -: 5675:#ifdef WINDOWS32
        -: 5676:#include "pathstuff.h"
        -: 5677:#undef stderr
        -: 5678:#define stderr stdout
        -: 5679:#endif
        -: 5680:
        -: 5681:#ifdef _AMIGA
        -: 5682:#include <ctype.h>
        -: 5683:#undef stderr
        -: 5684:#define stderr stdout
        -: 5685:#endif
        -: 5686:
        -: 5687:#ifdef HAVE_CASE_INSENSITIVE_FS
        -: 5688:static char *
        -: 5689:downcase (filename)
        -: 5690:     char *filename;
        -: 5691:{
        -: 5692:#ifdef _AMIGA
        -: 5693:  static char new_filename[136];
        -: 5694:#else
        -: 5695:  static char new_filename[PATH_MAX];
        -: 5696:#endif
        -: 5697:  char *df;
        -: 5698:  int i;
        -: 5699:
        -: 5700:  if (filename == 0)
        -: 5701:    return 0;
        -: 5702:
        -: 5703:  df = new_filename;
        -: 5704:
        -: 5705:  /* First, transform the name part.  */
        -: 5706:  for (i = 0; *filename != '\0'; ++i)
        -: 5707:  {
        -: 5708:    *df++ = tolower (*filename);
        -: 5709:    ++filename;
        -: 5710:  }
        -: 5711:
        -: 5712:  *df = 0;
        -: 5713:
        -: 5714:  return new_filename;
        -: 5715:}
        -: 5716:#endif /* HAVE_CASE_INSENSITIVE_FS */
        -: 5717:
        -: 5718:#ifdef VMS
        -: 5719:
        -: 5720:static int
        -: 5721:vms_hash (name)
        -: 5722:    char *name;
        -: 5723:{
        -: 5724:  int h = 0;
        -: 5725:  int g;
        -: 5726:
        -: 5727:  while (*name)
        -: 5728:    {
        -: 5729:      h = (h << 4) + *name++;
        -: 5730:      g = h & 0xf0000000;
        -: 5731:      if (g)
        -: 5732:	{
        -: 5733:	  h = h ^ (g >> 24);
        -: 5734:	  h = h ^ g;
        -: 5735:	}
        -: 5736:    }
        -: 5737:  return h;
        -: 5738:}
        -: 5739:
        -: 5740:/* fake stat entry for a directory */
        -: 5741:static int
        -: 5742:vmsstat_dir (name, st)
        -: 5743:    char *name;
        -: 5744:    struct stat *st;
        -: 5745:{
        -: 5746:  char *s;
        -: 5747:  int h;
        -: 5748:  DIR *dir;
        -: 5749:
        -: 5750:  dir = opendir (name);
        -: 5751:  if (dir == 0)
        -: 5752:    return -1;
        -: 5753:  closedir (dir);
        -: 5754:  s = strchr (name, ':');	/* find device */
        -: 5755:  if (s)
        -: 5756:    {
        -: 5757:      *s++ = 0;
        -: 5758:      st->st_dev = (char *)vms_hash (name);
        -: 5759:      h = vms_hash (s);
        -: 5760:      *(s-1) = ':';
        -: 5761:    }
        -: 5762:  else
        -: 5763:    {
        -: 5764:      st->st_dev = 0;
        -: 5765:      s = name;
        -: 5766:      h = vms_hash (s);
        -: 5767:    }
        -: 5768:
        -: 5769:  st->st_ino[0] = h & 0xff;
        -: 5770:  st->st_ino[1] = h & 0xff00;
        -: 5771:  st->st_ino[2] = h >> 16;
        -: 5772:
        -: 5773:  return 0;
        -: 5774:}
        -: 5775:#endif /* VMS */
        -: 5776:
        -: 5777:/* Hash table of directories.  */
        -: 5778:
        -: 5779:#ifndef	DIRECTORY_BUCKETS
        -: 5780:#define DIRECTORY_BUCKETS 199
        -: 5781:#endif
        -: 5782:
        -: 5783:struct directory_contents
        -: 5784:  {
        -: 5785:    struct directory_contents *next;
        -: 5786:
        -: 5787:    dev_t dev;			/* Device and inode numbers of this dir.  */
        -: 5788:#ifdef WINDOWS32
        -: 5789:    /*
        -: 5790:     * Inode means nothing on WINDOWS32. Even file key information is
        -: 5791:     * unreliable because it is random per file open and undefined
        -: 5792:     * for remote filesystems. The most unique attribute I can
        -: 5793:     * come up with is the fully qualified name of the directory. Beware
        -: 5794:     * though, this is also unreliable. I'm open to suggestion on a better
        -: 5795:     * way to emulate inode.
        -: 5796:     */
        -: 5797:    char *path_key;
        -: 5798:    int   mtime;        /* controls check for stale directory cache */
        -: 5799:    int   fs_flags;     /* FS_FAT, FS_NTFS, ... */
        -: 5800:#define FS_FAT      0x1
        -: 5801:#define FS_NTFS     0x2
        -: 5802:#define FS_UNKNOWN  0x4
        -: 5803:#else
        -: 5804:#ifdef VMS
        -: 5805:    ino_t ino[3];
        -: 5806:#else
        -: 5807:    ino_t ino;
        -: 5808:#endif
        -: 5809:#endif /* WINDOWS32 */
        -: 5810:    struct dirfile **files;	/* Files in this directory.  */
        -: 5811:    DIR *dirstream;		/* Stream reading this directory.  */
        -: 5812:  };
        -: 5813:
        -: 5814:/* Table of directory contents hashed by device and inode number.  */
        -: 5815:static struct directory_contents *directories_contents[DIRECTORY_BUCKETS];
        -: 5816:
        -: 5817:struct directory
        -: 5818:  {
        -: 5819:    struct directory *next;
        -: 5820:
        -: 5821:    char *name;			/* Name of the directory.  */
        -: 5822:
        -: 5823:    /* The directory's contents.  This data may be shared by several
        -: 5824:       entries in the hash table, which refer to the same directory
        -: 5825:       (identified uniquely by `dev' and `ino') under different names.  */
        -: 5826:    struct directory_contents *contents;
        -: 5827:  };
        -: 5828:
        -: 5829:/* Table of directories hashed by name.  */
        -: 5830:static struct directory *table_of_directories[DIRECTORY_BUCKETS];
        -: 5831:
        -: 5832:
        -: 5833:/* Never have more than this many directories open at once.  */
        -: 5834:
        -: 5835:#define MAX_OPEN_DIRECTORIES 10
        -: 5836:
        -: 5837:static unsigned int open_directories = 0;
        -: 5838:
        -: 5839:
        -: 5840:/* Hash table of files in each directory.  */
        -: 5841:
        -: 5842:struct dirfile
        -: 5843:  {
        -: 5844:    struct dirfile *next;
        -: 5845:    char *name;			/* Name of the file.  */
        -: 5846:    char impossible;		/* This file is impossible.  */
        -: 5847:  };
        -: 5848:
        -: 5849:#ifndef	DIRFILE_BUCKETS
        -: 5850:#define DIRFILE_BUCKETS 107
        -: 5851:#endif
        -: 5852:
        -: 5853:static int dir_contents_file_exists_p PARAMS ((struct directory_contents *dir, char *filename));
        -: 5854:static struct directory *find_directory PARAMS ((char *name));
        -: 5855:
        -: 5856:/* Find the directory named NAME and return its `struct directory'.  */
        -: 5857:
        -: 5858:static struct directory *
function find_directory called 254591 returned 100% blocks executed 89%
   254591: 5859:find_directory (name)
        -: 5860:     register char *name;
        -: 5861:{
   254591: 5862:  register unsigned int hash = 0;
        -: 5863:  register char *p;
        -: 5864:  register struct directory *dir;
        -: 5865:#ifdef WINDOWS32
        -: 5866:  char* w32_path;
        -: 5867:  char  fs_label[BUFSIZ];
        -: 5868:  char  fs_type[BUFSIZ];
        -: 5869:  long  fs_serno;
        -: 5870:  long  fs_flags;
        -: 5871:  long  fs_len;
        -: 5872:#endif
        -: 5873:#ifdef VMS
        -: 5874:  if ((*name == '.') && (*(name+1) == 0))
        -: 5875:    name = "[]";
        -: 5876:  else
        -: 5877:    name = vmsify (name,1);
        -: 5878:#endif
        -: 5879:
  8567693: 5880:  for (p = name; *p != '\0'; ++p)
branch  0 taken 8313102
branch  1 taken 254591 (fallthrough)
  8313102: 5881:    HASHI (hash, *p);
   254591: 5882:  hash %= DIRECTORY_BUCKETS;
        -: 5883:
  254591*: 5884:  for (dir = table_of_directories[hash]; dir != 0; dir = dir->next)
branch  0 taken 250670
branch  1 taken 3921 (fallthrough)
   250670: 5885:    if (strieq (dir->name, name))
branch  0 taken 250670 (fallthrough)
branch  1 taken 0
branch  2 taken 250670 (fallthrough)
branch  3 taken 0
branch  4 taken 250670 (fallthrough)
branch  5 taken 0
branch  6 taken 0 (fallthrough)
branch  7 taken 250670
        -: 5886:      break;
        -: 5887:
   254591: 5888:  if (dir == 0)
branch  0 taken 3921 (fallthrough)
branch  1 taken 250670
        -: 5889:    {
        -: 5890:      struct stat st;
        -: 5891:
        -: 5892:      /* The directory was not found.  Create a new entry for it.  */
        -: 5893:
     3921: 5894:      dir = (struct directory *) xmalloc (sizeof (struct directory));
call    0 returned 3921
     3921: 5895:      dir->next = table_of_directories[hash];
     3921: 5896:      table_of_directories[hash] = dir;
     3921: 5897:      dir->name = savestring (name, p - name);
call    0 returned 3921
        -: 5898:
        -: 5899:      /* The directory is not in the name hash table.
        -: 5900:	 Find its device and inode numbers, and look it up by them.  */
        -: 5901:
        -: 5902:#ifdef VMS
        -: 5903:      if (vmsstat_dir (name, &st) < 0)
        -: 5904:#else
     3921: 5905:      if (stat (name, &st) < 0)
call    0 returned 3921
branch  1 taken 3899 (fallthrough)
branch  2 taken 22
        -: 5906:#endif
        -: 5907:	{
        -: 5908:	/* Couldn't stat the directory.  Mark this by
        -: 5909:	   setting the `contents' member to a nil pointer.  */
     3899: 5910:	  dir->contents = 0;
        -: 5911:	}
        -: 5912:      else
        -: 5913:	{
        -: 5914:	  /* Search the contents hash table; device and inode are the key.  */
        -: 5915:
        -: 5916:	  struct directory_contents *dc;
        -: 5917:
        -: 5918:#ifdef WINDOWS32
        -: 5919:          w32_path = w32ify(name, 1);
        -: 5920:          hash = ((unsigned int) st.st_dev << 16) | (unsigned int) st.st_ctime;
        -: 5921:#else
        -: 5922:#ifdef VMS
        -: 5923:	hash = ((unsigned int) st.st_dev << 16)
        -: 5924:		| ((unsigned int) st.st_ino[0]
        -: 5925:		+ (unsigned int) st.st_ino[1]
        -: 5926:		+ (unsigned int) st.st_ino[2]);
        -: 5927:#else
       22: 5928:	  hash = (st.st_dev << 16);
        -: 5929:#endif
        -: 5930:#endif
       22: 5931:	  hash %= DIRECTORY_BUCKETS;
        -: 5932:
       25: 5933:	  for (dc = directories_contents[hash]; dc != 0; dc = dc->next) {
branch  0 taken 3
branch  1 taken 22 (fallthrough)
        -: 5934:#ifdef WINDOWS32
        -: 5935:            if (strieq(dc->path_key, w32_path))
        -: 5936:#else
        3: 5937:	    if (dc->dev == st.st_dev
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        -: 5938:#ifdef VMS
        -: 5939:		&& dc->ino[0] == st.st_ino[0]
        -: 5940:		&& dc->ino[1] == st.st_ino[1]
        -: 5941:		&& dc->ino[2] == st.st_ino[2])
        -: 5942:#else
        3: 5943:	      && (ino_t_equal(ino_t_to_int(dc->ino), ino_t_to_int(st.st_ino)) == 0))
call    0 returned 3
call    1 returned 3
call    2 returned 3
branch  3 taken 0 (fallthrough)
branch  4 taken 3
        -: 5944:	      /*		 && dc->ino == st.st_ino) */
        -: 5945:#endif
        -: 5946:#endif /* WINDOWS32 */
    #####: 5947:	      break;
        -: 5948:	}
        -: 5949:
       22: 5950:	  if (dc == 0)
branch  0 taken 22 (fallthrough)
branch  1 taken 0
        -: 5951:	    {
        -: 5952:	      /* Nope; this really is a directory we haven't seen before.  */
        -: 5953:
        -: 5954:	      dc = (struct directory_contents *)
       22: 5955:		xmalloc (sizeof (struct directory_contents));
call    0 returned 22
        -: 5956:
        -: 5957:	      /* Enter it in the contents hash table.  */
       22: 5958:	      dc->dev = st.st_dev;
        -: 5959:#ifdef WINDOWS32
        -: 5960:              dc->path_key = strdup(w32_path);
        -: 5961:              dc->mtime = st.st_mtime;
        -: 5962:
        -: 5963:              /*
        -: 5964:               * NTFS is the only WINDOWS32 filesystem that bumps mtime
        -: 5965:               * on a directory when files are added/deleted from
        -: 5966:               * a directory.
        -: 5967:               */
        -: 5968:              w32_path[3] = '\0';
        -: 5969:              if (GetVolumeInformation(w32_path,
        -: 5970:                     fs_label, sizeof (fs_label),
        -: 5971:                     &fs_serno, &fs_len,
        -: 5972:                     &fs_flags, fs_type, sizeof (fs_type)) == FALSE)
        -: 5973:                dc->fs_flags = FS_UNKNOWN;
        -: 5974:              else if (!strcmp(fs_type, "FAT"))
        -: 5975:                dc->fs_flags = FS_FAT;
        -: 5976:              else if (!strcmp(fs_type, "NTFS"))
        -: 5977:                dc->fs_flags = FS_NTFS;
        -: 5978:              else
        -: 5979:                dc->fs_flags = FS_UNKNOWN;
        -: 5980:#else
        -: 5981:#ifdef VMS
        -: 5982:	      dc->ino[0] = st.st_ino[0];
        -: 5983:	      dc->ino[1] = st.st_ino[1];
        -: 5984:	      dc->ino[2] = st.st_ino[2];
        -: 5985:#else
       22: 5986:	      memcpy(&dc->ino, &st.st_ino, sizeof(ino_t));
        -: 5987:	      /*	      dc->ino = st.st_ino; */
        -: 5988:#endif
        -: 5989:#endif /* WINDOWS32 */
       22: 5990:	      dc->next = directories_contents[hash];
       22: 5991:	      directories_contents[hash] = dc;
        -: 5992:
       22: 5993:	      dc->dirstream = opendir (name);
call    0 returned 22
       22: 5994:	      if (dc->dirstream == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 22
        -: 5995:		{
        -: 5996:		/* Couldn't open the directory.  Mark this by
        -: 5997:		   setting the `files' member to a nil pointer.  */
    #####: 5998:		  dc->files = 0;
        -: 5999:		}
        -: 6000:	      else
        -: 6001:		{
        -: 6002:		  /* Allocate an array of buckets for files and zero it.  */
       22: 6003:		  dc->files = (struct dirfile **)
       22: 6004:		    xmalloc (sizeof (struct dirfile *) * DIRFILE_BUCKETS);
call    0 returned 22
       22: 6005:		  bzero ((char *) dc->files,
        -: 6006:			 sizeof (struct dirfile *) * DIRFILE_BUCKETS);
        -: 6007:
        -: 6008:		  /* Keep track of how many directories are open.  */
       22: 6009:		  ++open_directories;
       22: 6010:		  if (open_directories == MAX_OPEN_DIRECTORIES)
branch  0 taken 0 (fallthrough)
branch  1 taken 22
        -: 6011:		    /* We have too many directories open already.
        -: 6012:		       Read the entire directory and then close it.  */
    #####: 6013:		    (void) dir_contents_file_exists_p (dc, (char *) 0);
call    0 never executed
        -: 6014:		}
        -: 6015:	    }
        -: 6016:
        -: 6017:	  /* Point the name-hashed entry for DIR at its contents data.  */
       22: 6018:	  dir->contents = dc;
        -: 6019:	}
        -: 6020:    }
        -: 6021:
   254591: 6022:  return dir;
        -: 6023:}
        -: 6024:
        -: 6025:/* Return 1 if the name FILENAME is entered in DIR's hash table.
        -: 6026:   FILENAME must contain no slashes.  */
        -: 6027:
        -: 6028:static int
function dir_contents_file_exists_p called 113823 returned 100% blocks executed 88%
   113823: 6029:dir_contents_file_exists_p (dir, filename)
        -: 6030:     register struct directory_contents *dir;
        -: 6031:     register char *filename;
        -: 6032:{
        -: 6033:  register unsigned int hash;
        -: 6034:  register char *p;
        -: 6035:  register struct dirfile *df;
        -: 6036:  register struct dirent *d;
        -: 6037:#ifdef WINDOWS32
        -: 6038:  struct stat st;
        -: 6039:  int rehash = 0;
        -: 6040:#endif
        -: 6041:
   113823: 6042:  if (dir == 0 || dir->files == 0)
branch  0 taken 39537 (fallthrough)
branch  1 taken 74286
branch  2 taken 0 (fallthrough)
branch  3 taken 39537
        -: 6043:    {
        -: 6044:    /* The directory could not be stat'd or opened.  */
    74286: 6045:      return 0;
        -: 6046:    }
        -: 6047:#ifdef __MSDOS__
        -: 6048:  filename = dosify (filename);
        -: 6049:#endif
        -: 6050:
        -: 6051:#ifdef HAVE_CASE_INSENSITIVE_FS
        -: 6052:  filename = downcase (filename);
        -: 6053:#endif
        -: 6054:
        -: 6055:#ifdef VMS
        -: 6056:  filename = vmsify (filename,0);
        -: 6057:#endif
        -: 6058:
    39537: 6059:  hash = 0;
    39537: 6060:  if (filename != 0)
branch  0 taken 39495 (fallthrough)
branch  1 taken 42
        -: 6061:    {
    39495: 6062:      if (*filename == '\0')
branch  0 taken 0 (fallthrough)
branch  1 taken 39495
        -: 6063:	{
        -: 6064:	/* Checking if the directory exists.  */
    #####: 6065:	  return 1;
        -: 6066:	}
        -: 6067:
   612666: 6068:      for (p = filename; *p != '\0'; ++p)
branch  0 taken 573171
branch  1 taken 39495 (fallthrough)
   573171: 6069:	HASH (hash, *p);
    39495: 6070:      hash %= DIRFILE_BUCKETS;
        -: 6071:
        -: 6072:      /* Search the list of hashed files.  */
        -: 6073:
    43647: 6074:      for (df = dir->files[hash]; df != 0; df = df->next)
branch  0 taken 4170
branch  1 taken 39477 (fallthrough)
        -: 6075:	{
     4170: 6076:	  if (strieq (df->name, filename))
branch  0 taken 4170 (fallthrough)
branch  1 taken 0
branch  2 taken 580 (fallthrough)
branch  3 taken 3590
branch  4 taken 580 (fallthrough)
branch  5 taken 0
branch  6 taken 18 (fallthrough)
branch  7 taken 562
        -: 6077:	    {
       18: 6078:	      return !df->impossible;
        -: 6079:	    }
        -: 6080:	}
        -: 6081:    }
        -: 6082:
        -: 6083:  /* The file was not found in the hashed list.
        -: 6084:     Try to read the directory further.  */
        -: 6085:
    39519: 6086:  if (dir->dirstream == 0)
branch  0 taken 39497 (fallthrough)
branch  1 taken 22
        -: 6087:    {
        -: 6088:#ifdef WINDOWS32
        -: 6089:      /*
        -: 6090:       * Check to see if directory has changed since last read. FAT
        -: 6091:       * filesystems force a rehash always as mtime does not change
        -: 6092:       * on directories (ugh!).
        -: 6093:       */
        -: 6094:      if (dir->path_key &&
        -: 6095:          (dir->fs_flags & FS_FAT ||
        -: 6096:           (stat(dir->path_key, &st) == 0 &&
        -: 6097:            st.st_mtime > dir->mtime))) {
        -: 6098:
        -: 6099:        /* reset date stamp to show most recent re-process */
        -: 6100:        dir->mtime = st.st_mtime;
        -: 6101:
        -: 6102:        /* make sure directory can still be opened */
        -: 6103:        dir->dirstream = opendir(dir->path_key);
        -: 6104:
        -: 6105:        if (dir->dirstream)
        -: 6106:          rehash = 1;
        -: 6107:        else
        -: 6108:          return 0; /* couldn't re-read - fail */
        -: 6109:      } else
        -: 6110:#endif
        -: 6111:    /* The directory has been all read in.  */
    39497: 6112:      return 0;
        -: 6113:    }
        -: 6114:
      930: 6115:  while ((d = readdir (dir->dirstream)) != 0)
call    0 returned 930
branch  1 taken 908
branch  2 taken 22 (fallthrough)
        -: 6116:    {
        -: 6117:      /* Enter the file in the hash table.  */
      908: 6118:      register unsigned int newhash = 0;
        -: 6119:      unsigned int len;
        -: 6120:      register unsigned int i;
        -: 6121:
     908*: 6122:      if (!REAL_DIR_ENTRY (d))
branch  0 taken 0 (fallthrough)
branch  1 taken 908
    #####: 6123:	continue;
        -: 6124:
      908: 6125:      len = NAMLEN (d);
     7596: 6126:      for (i = 0; i < len; ++i)
branch  0 taken 6688
branch  1 taken 908 (fallthrough)
     6688: 6127:	HASHI (newhash, d->d_name[i]);
      908: 6128:      newhash %= DIRFILE_BUCKETS;
        -: 6129:#ifdef WINDOWS32
        -: 6130:      /*
        -: 6131:       * If re-reading a directory, check that this file isn't already
        -: 6132:       * in the cache.
        -: 6133:       */
        -: 6134:      if (rehash) {
        -: 6135:        for (df = dir->files[newhash]; df != 0; df = df->next)
        -: 6136:          if (streq(df->name, d->d_name))
        -: 6137:            break;
        -: 6138:      } else
        -: 6139:        df = 0;
        -: 6140:
        -: 6141:      /*
        -: 6142:       * If re-reading a directory, don't cache files that have
        -: 6143:       * already been discovered.
        -: 6144:       */
        -: 6145:      if (!df) {
        -: 6146:#endif
        -: 6147:
      908: 6148:      df = (struct dirfile *) xmalloc (sizeof (struct dirfile));
call    0 returned 908
      908: 6149:      df->next = dir->files[newhash];
      908: 6150:      dir->files[newhash] = df;
      908: 6151:      df->name = savestring (d->d_name, len);
call    0 returned 908
      908: 6152:      df->impossible = 0;
        -: 6153:#ifdef WINDOWS32
        -: 6154:      }
        -: 6155:#endif
        -: 6156:      /* Check if the name matches the one we're searching for.  */
      908: 6157:      if (filename != 0
branch  0 taken 908 (fallthrough)
branch  1 taken 0
     908*: 6158:	  && newhash == hash && strieq (d->d_name, filename))
branch  0 taken 2 (fallthrough)
branch  1 taken 906
branch  2 taken 2 (fallthrough)
branch  3 taken 0
branch  4 taken 0 (fallthrough)
branch  5 taken 2
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
        -: 6159:	{
    #####: 6160:	  return 1;
        -: 6161:	}
        -: 6162:    }
        -: 6163:
        -: 6164:  /* If the directory has been completely read in,
        -: 6165:     close the stream and reset the pointer to nil.  */
       22: 6166:  if (d == 0)
branch  0 taken 22 (fallthrough)
branch  1 taken 0
        -: 6167:    {
       22: 6168:      --open_directories;
       22: 6169:      closedir (dir->dirstream);
call    0 returned 22
       22: 6170:      dir->dirstream = 0;
        -: 6171:    }
       22: 6172:  return 0;
        -: 6173:}
        -: 6174:
        -: 6175:/* Return 1 if the name FILENAME in directory DIRNAME
        -: 6176:   is entered in the dir hash table.
        -: 6177:   FILENAME must contain no slashes.  */
        -: 6178:
        -: 6179:int
function dir_file_exists_p called 113781 returned 100% blocks executed 100%
   113781: 6180:dir_file_exists_p (dirname, filename)
        -: 6181:     register char *dirname;
        -: 6182:     register char *filename;
        -: 6183:{
   113781: 6184:  return dir_contents_file_exists_p (find_directory (dirname)->contents,
call    0 returned 113781
call    1 returned 113781
        -: 6185:				     filename);
        -: 6186:}
        -: 6187:
        -: 6188:/* Return 1 if the file named NAME exists.  */
        -: 6189:
        -: 6190:int
function file_exists_p called 111414 returned 100% blocks executed 75%
   111414: 6191:file_exists_p (name)
        -: 6192:     register char *name;
        -: 6193:{
        -: 6194:  char *dirend;
        -: 6195:  char *dirname;
        -: 6196:  char *slash;
        -: 6197:
        -: 6198:#ifndef	NO_ARCHIVES
   111414: 6199:  if (ar_name (name))
call    0 returned 111414
branch  1 taken 0 (fallthrough)
branch  2 taken 111414
    #####: 6200:    return ar_member_date (name) != (time_t) -1;
call    0 never executed
        -: 6201:#endif
        -: 6202:
        -: 6203:#ifdef VMS
        -: 6204:  dirend = rindex (name, ']');
        -: 6205:  dirend++;
        -: 6206:  if (dirend == (char *)1)
        -: 6207:    return dir_file_exists_p ("[]", name);
        -: 6208:#else /* !VMS */
   111414: 6209:  dirend = rindex (name, '/');
        -: 6210:#if defined (WINDOWS32) || defined (__MSDOS__)
        -: 6211:  /* Forward and backslashes might be mixed.  We need the rightmost one.  */
        -: 6212:  {
        -: 6213:    char *bslash = rindex(name, '\\');
        -: 6214:    if (!dirend || bslash > dirend)
        -: 6215:      dirend = bslash;
        -: 6216:    /* The case of "d:file".  */
        -: 6217:    if (!dirend && name[0] && name[1] == ':')
        -: 6218:      dirend = name + 1;
        -: 6219:  }
        -: 6220:#endif /* WINDOWS32 || __MSDOS__ */
   111414: 6221:  if (dirend == 0)
branch  0 taken 3689 (fallthrough)
branch  1 taken 107725
        -: 6222:#ifndef _AMIGA
     3689: 6223:    return dir_file_exists_p (".", name);
call    0 returned 3689
        -: 6224:#else /* !VMS && !AMIGA */
        -: 6225:    return dir_file_exists_p ("", name);
        -: 6226:#endif /* AMIGA */
        -: 6227:#endif /* VMS */
        -: 6228:
   107725: 6229:  slash = dirend;
   107725: 6230:  if (dirend == name)
branch  0 taken 0 (fallthrough)
branch  1 taken 107725
    #####: 6231:    dirname = "/";
        -: 6232:  else
        -: 6233:    {
        -: 6234:#if defined (WINDOWS32) || defined (__MSDOS__)
        -: 6235:  /* d:/ and d: are *very* different...  */
        -: 6236:      if (dirend < name + 3 && name[1] == ':' &&
        -: 6237:	  (*dirend == '/' || *dirend == '\\' || *dirend == ':'))
        -: 6238:	dirend++;
        -: 6239:#endif
   107725: 6240:      dirname = (char *) alloca (dirend - name + 1);
   107725: 6241:      bcopy (name, dirname, dirend - name);
   107725: 6242:      dirname[dirend - name] = '\0';
        -: 6243:    }
   107725: 6244:  return dir_file_exists_p (dirname, slash + 1);
call    0 returned 107725
        -: 6245:}
        -: 6246:
        -: 6247:/* Mark FILENAME as `impossible' for `file_impossible_p'.
        -: 6248:   This means an attempt has been made to search for FILENAME
        -: 6249:   as an intermediate file, and it has failed.  */
        -: 6250:
        -: 6251:void
function file_impossible called 13896 returned 100% blocks executed 95%
    13896: 6252:file_impossible (filename)
        -: 6253:     register char *filename;
        -: 6254:{
        -: 6255:  char *dirend;
    13896: 6256:  register char *p = filename;
        -: 6257:  register unsigned int hash;
        -: 6258:  register struct directory *dir;
        -: 6259:  register struct dirfile *new;
        -: 6260:
        -: 6261:#ifdef VMS
        -: 6262:  dirend = rindex (p, ']');
        -: 6263:  dirend++;
        -: 6264:  if (dirend == (char *)1)
        -: 6265:    dir = find_directory ("[]");
        -: 6266:#else
    13896: 6267:  dirend = rindex (p, '/');
        -: 6268:#if defined (WINDOWS32) || defined (__MSDOS__)
        -: 6269:  /* Forward and backslashes might be mixed.  We need the rightmost one.  */
        -: 6270:  {
        -: 6271:    char *bslash = rindex(p, '\\');
        -: 6272:    if (!dirend || bslash > dirend)
        -: 6273:      dirend = bslash;
        -: 6274:    /* The case of "d:file".  */
        -: 6275:    if (!dirend && p[0] && p[1] == ':')
        -: 6276:      dirend = p + 1;
        -: 6277:  }
        -: 6278:#endif /* WINDOWS32 or __MSDOS__ */
    13896: 6279:  if (dirend == 0)
branch  0 taken 721 (fallthrough)
branch  1 taken 13175
        -: 6280:#ifdef _AMIGA
        -: 6281:    dir = find_directory ("");
        -: 6282:#else /* !VMS && !AMIGA */
      721: 6283:    dir = find_directory (".");
call    0 returned 721
        -: 6284:#endif /* AMIGA */
        -: 6285:#endif /* VMS */
        -: 6286:  else
        -: 6287:    {
        -: 6288:      char *dirname;
        -: 6289:#ifndef F_JR_7  /* seeded fault #7 */
    13175: 6290:      char *slash = dirend;
        -: 6291:#else
        -: 6292:      char *slash;
        -: 6293:#endif
    13175: 6294:      if (dirend == p)
branch  0 taken 0 (fallthrough)
branch  1 taken 13175
    #####: 6295:	dirname = "/";
        -: 6296:      else
        -: 6297:	{
        -: 6298:#if defined (WINDOWS32) || defined (__MSDOS__)
        -: 6299:	  /* d:/ and d: are *very* different...  */
        -: 6300:	  if (dirend < p + 3 && p[1] == ':' &&
        -: 6301:	      (*dirend == '/' || *dirend == '\\' || *dirend == ':'))
        -: 6302:	    dirend++;
        -: 6303:#endif
    13175: 6304:	  dirname = (char *) alloca (dirend - p + 1);
    13175: 6305:	  bcopy (p, dirname, dirend - p);
    13175: 6306:	  dirname[dirend - p] = '\0';
        -: 6307:	}
    13175: 6308:      dir = find_directory (dirname);
call    0 returned 13175
    13175: 6309:      filename = p = slash + 1;
        -: 6310:    }
        -: 6311:
   199466: 6312:  for (hash = 0; *p != '\0'; ++p)
branch  0 taken 185570
branch  1 taken 13896 (fallthrough)
   185570: 6313:    HASHI (hash, *p);
    13896: 6314:  hash %= DIRFILE_BUCKETS;
        -: 6315:
    13896: 6316:  if (dir->contents == 0)
branch  0 taken 771 (fallthrough)
branch  1 taken 13125
        -: 6317:    {
        -: 6318:      /* The directory could not be stat'd.  We allocate a contents
        -: 6319:	 structure for it, but leave it out of the contents hash table.  */
      771: 6320:      dir->contents = (struct directory_contents *)
      771: 6321:	xmalloc (sizeof (struct directory_contents));
call    0 returned 771
        -: 6322:#ifdef WINDOWS32
        -: 6323:      dir->contents->path_key = NULL;
        -: 6324:      dir->contents->mtime = 0;
        -: 6325:#else  /* WINDOWS32 */
        -: 6326:#ifdef VMS
        -: 6327:      dir->contents->dev = 0;
        -: 6328:      dir->contents->ino[0] = dir->contents->ino[1] =
        -: 6329:	dir->contents->ino[2] = 0;
        -: 6330:#else
      771: 6331:      memcpy(&dir->contents->dev, &ZERO_dev_t, sizeof(dev_t));
      771: 6332:      memcpy(&dir->contents->ino, &ZERO_ino_t, sizeof(ino_t));
        -: 6333:      /*      dir->contents->dev = dir->contents->ino = (ino_t) 0; */
        -: 6334:#endif
        -: 6335:#endif /* WINDOWS32 */
      771: 6336:      dir->contents->files = 0;
      771: 6337:      dir->contents->dirstream = 0;
        -: 6338:    }
        -: 6339:
    13896: 6340:  if (dir->contents->files == 0)
branch  0 taken 771 (fallthrough)
branch  1 taken 13125
        -: 6341:    {
        -: 6342:      /* The directory was not opened; we must allocate the hash buckets.  */
     1542: 6343:      dir->contents->files = (struct dirfile **)
      771: 6344:	xmalloc (sizeof (struct dirfile) * DIRFILE_BUCKETS);
call    0 returned 771
      771: 6345:      bzero ((char *) dir->contents->files,
        -: 6346:	     sizeof (struct dirfile) * DIRFILE_BUCKETS);
        -: 6347:    }
        -: 6348:
        -: 6349:  /* Make a new entry and put it in the table.  */
        -: 6350:
    13896: 6351:  new = (struct dirfile *) xmalloc (sizeof (struct dirfile));
call    0 returned 13896
    13896: 6352:  new->next = dir->contents->files[hash];
    13896: 6353:  dir->contents->files[hash] = new;
    13896: 6354:  new->name = savestring (filename, strlen (filename));
call    0 returned 13896
    13896: 6355:  new->impossible = 1;
    13896: 6356:}
        -: 6357:
        -: 6358:/* Return nonzero if FILENAME has been marked impossible.  */
        -: 6359:
        -: 6360:int
function file_impossible_p called 126872 returned 100% blocks executed 96%
   126872: 6361:file_impossible_p (filename)
        -: 6362:     char *filename;
        -: 6363:{
        -: 6364:  char *dirend;
   126872: 6365:  register char *p = filename;
        -: 6366:  register unsigned int hash;
        -: 6367:  register struct directory_contents *dir;
        -: 6368:  register struct dirfile *next;
        -: 6369:
        -: 6370:#ifdef VMS
        -: 6371:  dirend = rindex (filename, ']');
        -: 6372:  if (dirend == 0)
        -: 6373:    dir = find_directory ("[]")->contents;
        -: 6374:#else
   126872: 6375:  dirend = rindex (filename, '/');
        -: 6376:#if defined (WINDOWS32) || defined (__MSDOS__)
        -: 6377:  /* Forward and backslashes might be mixed.  We need the rightmost one.  */
        -: 6378:  {
        -: 6379:    char *bslash = rindex(filename, '\\');
        -: 6380:    if (!dirend || bslash > dirend)
        -: 6381:      dirend = bslash;
        -: 6382:    /* The case of "d:file".  */
        -: 6383:    if (!dirend && filename[0] && filename[1] == ':')
        -: 6384:      dirend = filename + 1;
        -: 6385:  }
        -: 6386:#endif /* WINDOWS32 || __MSDOS__ */
   126872: 6387:  if (dirend == 0)
branch  0 taken 4266 (fallthrough)
branch  1 taken 122606
        -: 6388:#ifdef _AMIGA
        -: 6389:    dir = find_directory ("")->contents;
        -: 6390:#else /* !VMS && !AMIGA */
     4266: 6391:    dir = find_directory (".")->contents;
call    0 returned 4266
        -: 6392:#endif /* AMIGA */
        -: 6393:#endif /* VMS */
        -: 6394:  else
        -: 6395:    {
        -: 6396:      char *dirname;
   122606: 6397:      char *slash = dirend;
   122606: 6398:      if (dirend == filename)
branch  0 taken 0 (fallthrough)
branch  1 taken 122606
    #####: 6399:	dirname = "/";
        -: 6400:      else
        -: 6401:	{
        -: 6402:#if defined (WINDOWS32) || defined (__MSDOS__)
        -: 6403:	  /* d:/ and d: are *very* different...  */
        -: 6404:	  if (dirend < filename + 3 && filename[1] == ':' &&
        -: 6405:	      (*dirend == '/' || *dirend == '\\' || *dirend == ':'))
        -: 6406:	    dirend++;
        -: 6407:#endif
   122606: 6408:	  dirname = (char *) alloca (dirend - filename + 1);
   122606: 6409:	  bcopy (p, dirname, dirend - p);
   122606: 6410:	  dirname[dirend - p] = '\0';
        -: 6411:	}
   122606: 6412:      dir = find_directory (dirname)->contents;
call    0 returned 122606
   122606: 6413:      p = filename = slash + 1;
        -: 6414:    }
        -: 6415:
   126872: 6416:  if (dir == 0 || dir->files == 0)
branch  0 taken 52472 (fallthrough)
branch  1 taken 74400
branch  2 taken 0 (fallthrough)
branch  3 taken 52472
        -: 6417:    /* There are no files entered for this directory.  */
    74400: 6418:    return 0;
        -: 6419:
        -: 6420:#ifdef __MSDOS__
        -: 6421:  p = filename = dosify (p);
        -: 6422:#endif
        -: 6423:#ifdef HAVE_CASE_INSENSITIVE_FS
        -: 6424:  p = filename = downcase (p);
        -: 6425:#endif
        -: 6426:#ifdef VMS
        -: 6427:  p = filename = vmsify (p, 1);
        -: 6428:#endif
        -: 6429:
   797375: 6430:  for (hash = 0; *p != '\0'; ++p)
branch  0 taken 744903
branch  1 taken 52472 (fallthrough)
   744903: 6431:    HASH (hash, *p);
    52472: 6432:  hash %= DIRFILE_BUCKETS;
        -: 6433:
    57015: 6434:  for (next = dir->files[hash]; next != 0; next = next->next)
branch  0 taken 17574
branch  1 taken 39441 (fallthrough)
    17574: 6435:    if (strieq (filename, next->name))
branch  0 taken 17574 (fallthrough)
branch  1 taken 0
branch  2 taken 13989 (fallthrough)
branch  3 taken 3585
branch  4 taken 13989 (fallthrough)
branch  5 taken 0
branch  6 taken 13031 (fallthrough)
branch  7 taken 958
    13031: 6436:      return next->impossible;
        -: 6437:
    39441: 6438:  return 0;
        -: 6439:}
        -: 6440:
        -: 6441:/* Return the already allocated name in the
        -: 6442:   directory hash table that matches DIR.  */
        -: 6443:
        -: 6444:char *
function dir_name called 0 returned 0% blocks executed 0%
    #####: 6445:dir_name (dir)
        -: 6446:     char *dir;
        -: 6447:{
    #####: 6448:  return find_directory (dir)->name;
call    0 never executed
        -: 6449:}
        -: 6450:
        -: 6451:/* Print the data base of directories.  */
        -: 6452:
        -: 6453:void
function print_dir_data_base called 385 returned 100% blocks executed 89%
      385: 6454:print_dir_data_base ()
        -: 6455:{
        -: 6456:  register unsigned int i, dirs, files, impossible;
        -: 6457:  register struct directory *dir;
        -: 6458:
      385: 6459:  puts ("\n# Directories\n");
call    0 returned 385
        -: 6460:
      385: 6461:  dirs = files = impossible = 0;
    77000: 6462:  for (i = 0; i < DIRECTORY_BUCKETS; ++i)
branch  0 taken 76615
branch  1 taken 385 (fallthrough)
    78540: 6463:    for (dir = table_of_directories[i]; dir != 0; dir = dir->next)
branch  0 taken 1925
branch  1 taken 76615 (fallthrough)
        -: 6464:      {
     1925: 6465:	++dirs;
     1925: 6466:	if (dir->contents == 0)
branch  0 taken 1540 (fallthrough)
branch  1 taken 385
     1540: 6467:	  printf ("# %s: could not be stat'd.\n", dir->name);
call    0 returned 1540
      385: 6468:	else if (dir->contents->files == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 385
        -: 6469:#ifdef WINDOWS32
        -: 6470:          printf ("# %s (key %s, mtime %d): could not be opened.\n",
        -: 6471:                  dir->name, dir->contents->path_key,dir->contents->mtime);
        -: 6472:#else  /* WINDOWS32 */
        -: 6473:#ifdef VMS
        -: 6474:	  printf ("# %s (device %d, inode [%d,%d,%d]): could not be opened.\n",
        -: 6475:		  dir->name, dir->contents->dev,
        -: 6476:		  dir->contents->ino[0], dir->contents->ino[1],
        -: 6477:		  dir->contents->ino[2]);
        -: 6478:#else
        -: 6479:{
    #####: 6480:	  printf ("# %s (device %ld, inode %ld): could not be opened.\n",
    #####: 6481:		  dir->name, (long int) dir->contents->dev,
call    0 never executed
    #####: 6482:		  ino_t_to_int(dir->contents->ino));
call    0 never executed
        -: 6483:		  /*		  		  (long int) dir->contents->ino);*/
        -: 6484:}
        -: 6485:#endif
        -: 6486:#endif /* WINDOWS32 */
        -: 6487:	else
        -: 6488:	  {
      385: 6489:	    register unsigned int f = 0, im = 0;
        -: 6490:	    register unsigned int j;
        -: 6491:	    register struct dirfile *df;
    41580: 6492:	    for (j = 0; j < DIRFILE_BUCKETS; ++j)
branch  0 taken 41195
branch  1 taken 385 (fallthrough)
    47951: 6493:	      for (df = dir->contents->files[j]; df != 0; df = df->next)
branch  0 taken 6756
branch  1 taken 41195 (fallthrough)
     6756: 6494:		if (df->impossible)
branch  0 taken 6545 (fallthrough)
branch  1 taken 211
     6545: 6495:		  ++im;
        -: 6496:		else
      211: 6497:		  ++f;
        -: 6498:#ifdef WINDOWS32
        -: 6499:            printf ("# %s (key %s, mtime %d): ",
        -: 6500:                    dir->name, dir->contents->path_key, dir->contents->mtime);
        -: 6501:#else  /* WINDOWS32 */
        -: 6502:#ifdef VMS
        -: 6503:	    printf ("# %s (device %d, inode [%d,%d,%d]): ",
        -: 6504:		    dir->name, dir->contents->dev,
        -: 6505:			dir->contents->ino[0], dir->contents->ino[1],
        -: 6506:			dir->contents->ino[2]);
        -: 6507:#else
      385: 6508:	    printf ("# %s (device %ld, inode %ld): ",
call    0 returned 385
        -: 6509:		    dir->name,
      385: 6510:                    dev_t_to_int(dir->contents->dev), ino_t_to_int(dir->contents->ino));
call    0 returned 385
call    1 returned 385
        -: 6511:	    /*                    (long)dir->contents->dev, (long)dir->contents->ino); */
        -: 6512:#endif
        -: 6513:#endif /* WINDOWS32 */
      385: 6514:	    if (f == 0)
branch  0 taken 384 (fallthrough)
branch  1 taken 1
      384: 6515:	      fputs ("No", stdout);
call    0 returned 384
        -: 6516:	    else
        1: 6517:	      printf ("%u", f);
call    0 returned 1
      385: 6518:	    fputs (" files, ", stdout);
call    0 returned 385
      385: 6519:	    if (im == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 385
    #####: 6520:	      fputs ("no", stdout);
call    0 never executed
        -: 6521:	    else
      385: 6522:	      printf ("%u", im);
call    0 returned 385
      385: 6523:	    fputs (" impossibilities", stdout);
call    0 returned 385
      385: 6524:	    if (dir->contents->dirstream == 0)
branch  0 taken 385 (fallthrough)
branch  1 taken 0
      385: 6525:	      puts (".");
call    0 returned 385
        -: 6526:	    else
    #####: 6527:	      puts (" so far.");
call    0 never executed
      385: 6528:	    files += f;
      385: 6529:	    impossible += im;
        -: 6530:	  }
        -: 6531:      }
        -: 6532:
      385: 6533:  fputs ("\n# ", stdout);
call    0 returned 385
      385: 6534:  if (files == 0)
branch  0 taken 384 (fallthrough)
branch  1 taken 1
      384: 6535:    fputs ("No", stdout);
call    0 returned 384
        -: 6536:  else
        1: 6537:    printf ("%u", files);
call    0 returned 1
      385: 6538:  fputs (" files, ", stdout);
call    0 returned 385
      385: 6539:  if (impossible == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 385
    #####: 6540:    fputs ("no", stdout);
call    0 never executed
        -: 6541:  else
      385: 6542:    printf ("%u", impossible);
call    0 returned 385
      385: 6543:  printf (" impossibilities in %u directories.\n", dirs);
call    0 returned 385
      385: 6544:}
        -: 6545:
        -: 6546:/* Hooks for globbing.  */
        -: 6547:
        -: 6548:
        -: 6549:
        -: 6550:/* Structure describing state of iterating through a directory hash table.  */
        -: 6551:
        -: 6552:struct dirstream
        -: 6553:  {
        -: 6554:    struct directory_contents *contents; /* The directory being read.  */
        -: 6555:
        -: 6556:    unsigned int bucket;	/* Current hash bucket.  */
        -: 6557:    struct dirfile *elt;	/* Current elt in bucket.  */
        -: 6558:  };
        -: 6559:
        -: 6560:/* Forward declarations.  */
        -: 6561:static __ptr_t open_dirstream PARAMS ((const char *));
        -: 6562:static struct dirent *read_dirstream PARAMS ((__ptr_t));
        -: 6563:
        -: 6564:static __ptr_t
function open_dirstream called 42 returned 100% blocks executed 88%
       42: 6565:open_dirstream (directory)
        -: 6566:     const char *directory;
        -: 6567:{
        -: 6568:  struct dirstream *new;
       42: 6569:  struct directory *dir = find_directory ((char *)directory);
call    0 returned 42
        -: 6570:
       42: 6571:  if (dir->contents == 0 || dir->contents->files == 0)
branch  0 taken 42 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 42
        -: 6572:    /* DIR->contents is nil if the directory could not be stat'd.
        -: 6573:       DIR->contents->files is nil if it could not be opened.  */
    #####: 6574:    return 0;
        -: 6575:
        -: 6576:  /* Read all the contents of the directory now.  There is no benefit
        -: 6577:     in being lazy, since glob will want to see every file anyway.  */
        -: 6578:
       42: 6579:  (void) dir_contents_file_exists_p (dir->contents, (char *) 0);
call    0 returned 42
        -: 6580:
       42: 6581:  new = (struct dirstream *) xmalloc (sizeof (struct dirstream));
call    0 returned 42
       42: 6582:  new->contents = dir->contents;
       42: 6583:  new->bucket = 0;
       42: 6584:  new->elt = new->contents->files[0];
        -: 6585:
       42: 6586:  return (__ptr_t) new;
        -: 6587:}
        -: 6588:
        -: 6589:static struct dirent *
function read_dirstream called 1652 returned 100% blocks executed 100%
     1652: 6590:read_dirstream (stream)
        -: 6591:     __ptr_t stream;
        -: 6592:{
     1652: 6593:  struct dirstream *const ds = (struct dirstream *) stream;
        -: 6594:  register struct dirfile *df;
        -: 6595:  static char *buf;
        -: 6596:  static unsigned int bufsz;
        -: 6597:
     6104: 6598:  while (ds->bucket < DIRFILE_BUCKETS)
branch  0 taken 6104
branch  1 taken 0 (fallthrough)
        -: 6599:    {
     6104: 6600:      while ((df = ds->elt) != 0)
branch  0 taken 1610
branch  1 taken 4494 (fallthrough)
        -: 6601:	{
     1610: 6602:	  ds->elt = df->next;
     1610: 6603:	  if (!df->impossible)
branch  0 taken 1610 (fallthrough)
branch  1 taken 0
        -: 6604:	    {
        -: 6605:	      /* The glob interface wants a `struct dirent',
        -: 6606:		 so mock one up.  */
        -: 6607:	      struct dirent *d;
     1610: 6608:	      unsigned int len = strlen (df->name) + 1;
     1610: 6609:	      if (sizeof *d - sizeof d->d_name + len > bufsz)
branch  0 taken 36 (fallthrough)
branch  1 taken 1574
        -: 6610:		{
       36: 6611:		  if (buf != 0)
branch  0 taken 18 (fallthrough)
branch  1 taken 18
       18: 6612:		    free (buf);
       36: 6613:		  bufsz *= 2;
       36: 6614:		  if (sizeof *d - sizeof d->d_name + len > bufsz)
branch  0 taken 18 (fallthrough)
branch  1 taken 18
       18: 6615:		    bufsz = sizeof *d - sizeof d->d_name + len;
       36: 6616:		  buf = xmalloc (bufsz);
call    0 returned 36
        -: 6617:		}
     1610: 6618:	      d = (struct dirent *) buf;
     1610: 6619:	      FAKE_DIR_ENTRY (d);
        -: 6620:#ifdef _DIRENT_HAVE_D_NAMLEN
        -: 6621:	      d->d_namlen = len - 1;
        -: 6622:#endif
     1610: 6623:	      memcpy (d->d_name, df->name, len);
     1610: 6624:	      return d;
        -: 6625:	    }
        -: 6626:	}
     4494: 6627:      if (++ds->bucket == DIRFILE_BUCKETS)
branch  0 taken 42 (fallthrough)
branch  1 taken 4452
       42: 6628:	break;
     4452: 6629:      ds->elt = ds->contents->files[ds->bucket];
        -: 6630:    }
        -: 6631:
       42: 6632:  return 0;
        -: 6633:}
        -: 6634:
        -: 6635:static void
function ansi_free called 42 returned 100% blocks executed 100%
       42: 6636:ansi_free(p)
        -: 6637:  void *p;
        -: 6638:{
       42: 6639:    if (p)
branch  0 taken 42 (fallthrough)
branch  1 taken 0
       42: 6640:      free(p);
       42: 6641:}
        -: 6642:
        -: 6643:void
function dir_setup_glob called 8945 returned 100% blocks executed 100%
     8945: 6644:dir_setup_glob (gl)
        -: 6645:     glob_t *gl;
        -: 6646:{
        -: 6647:  extern int stat ();
        -: 6648:
        -: 6649:  /* Bogus sunos4 compiler complains (!) about & before functions.  */
     8945: 6650:  gl->gl_opendir = open_dirstream;
     8945: 6651:  gl->gl_readdir = read_dirstream;
        -: 6652:#ifndef F_JR_8
     8945: 6653:  gl->gl_closedir = ansi_free;
        -: 6654:#else
        -: 6655:  gl->gl_closedir = free;
        -: 6656:#endif
     8945: 6657:  gl->gl_stat = stat;
        -: 6658:  /* We don't bother setting gl_lstat, since glob never calls it.
        -: 6659:     The slot is only there for compatibility with 4.4 BSD.  */
     8945: 6660:}
        -: 6661:
        -: 6662:
        -: 6663:
        -: 6664:/*************************************************************
        -: 6665:  ============================================================
        -: 6666:  ************************************************************
        -: 6667:  ============================================================
        -: 6668:  ************************************************************
        -: 6669:                         file.c
        -: 6670:  ************************************************************
        -: 6671:  ============================================================
        -: 6672:  ************************************************************
        -: 6673:  ============================================================
        -: 6674:  *************************************************************/
        -: 6675:
        -: 6676:/* Target file hash table management for GNU Make.
        -: 6677:Copyright (C) 1988,89,90,91,92,93,94,95,96,97 Free Software Foundation, Inc.
        -: 6678:This file is part of GNU Make.
        -: 6679:
        -: 6680:GNU Make is free software; you can redistribute it and/or modify
        -: 6681:it under the terms of the GNU General Public License as published by
        -: 6682:the Free Software Foundation; either version 2, or (at your option)
        -: 6683:any later version.
        -: 6684:
        -: 6685:GNU Make is distributed in the hope that it will be useful,
        -: 6686:but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 6687:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 6688:GNU General Public License for more details.
        -: 6689:
        -: 6690:You should have received a copy of the GNU General Public License
        -: 6691:along with GNU Make; see the file COPYING.  If not, write to
        -: 6692:the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
        -: 6693:
        -: 6694:
        -: 6695:
        -: 6696:/* Hash table of files the makefile knows how to make.  */
        -: 6697:
        -: 6698:#ifndef	FILE_BUCKETS
        -: 6699:#define FILE_BUCKETS	1007
        -: 6700:#endif
        -: 6701:static struct file *files[FILE_BUCKETS];
        -: 6702:
        -: 6703:/* Number of files with the `intermediate' flag set.  */
        -: 6704:
        -: 6705:unsigned int num_intermediates = 0;
        -: 6706:
        -: 6707:
        -: 6708:/* Access the hash table of all file records.
        -: 6709:   lookup_file  given a name, return the struct file * for that name,
        -: 6710:           or nil if there is none.
        -: 6711:   enter_file   similar, but create one if there is none.  */
        -: 6712:
        -: 6713:struct file *
function lookup_file called 927919 returned 100% blocks executed 88%
   927919: 6714:lookup_file (name)
        -: 6715:     char *name;
        -: 6716:{
        -: 6717:  register struct file *f;
        -: 6718:  register char *n;
        -: 6719:  register unsigned int hashval;
        -: 6720:#ifdef VMS
        -: 6721:  register char *lname, *ln;
        -: 6722:#endif
        -: 6723:
   927919: 6724:  if (*name == '\0')
branch  0 taken 0 (fallthrough)
branch  1 taken 927919
    #####: 6725:    abort ();
call    0 never executed
        -: 6726:
        -: 6727:  /* This is also done in parse_file_seq, so this is redundant
        -: 6728:     for names read from makefiles.  It is here for names passed
        -: 6729:     on the command line.  */
        -: 6730:#ifdef VMS
        -: 6731:  lname = (char *)malloc(strlen(name) + 1);
        -: 6732:  for (n=name, ln=lname; *n != '\0'; ++n, ++ln)
        -: 6733:    *ln = isupper(*n) ? tolower(*n) : *n;
        -: 6734:  *ln = '\0';
        -: 6735:  name = lname;
        -: 6736:
        -: 6737:  while (name[0] == '[' && name[1] == ']' && name[2] != '\0')
        -: 6738:      name += 2;
        -: 6739:#endif
   928339: 6740:  while (name[0] == '.' && name[1] == '/' && name[2] != '\0')
branch  0 taken 814678 (fallthrough)
branch  1 taken 113661
branch  2 taken 420 (fallthrough)
branch  3 taken 814258
branch  4 taken 420
branch  5 taken 0 (fallthrough)
        -: 6741:    {
      420: 6742:      name += 2;
      420: 6743:      while (*name == '/')
branch  0 taken 0
branch  1 taken 420 (fallthrough)
        -: 6744:	/* Skip following slashes: ".//foo" is "foo", not "/foo".  */
    #####: 6745:	++name;
        -: 6746:    }
        -: 6747:
   927919: 6748:  if (*name == '\0')
branch  0 taken 0 (fallthrough)
branch  1 taken 927919
        -: 6749:    /* It was all slashes after a dot.  */
        -: 6750:#ifdef VMS
        -: 6751:    name = "[]";
        -: 6752:#else
        -: 6753:#ifdef _AMIGA
        -: 6754:    name = "";
        -: 6755:#else
    #####: 6756:    name = "./";
        -: 6757:#endif /* AMIGA */
        -: 6758:#endif /* VMS */
        -: 6759:
   927919: 6760:  hashval = 0;
 11632514: 6761:  for (n = name; *n != '\0'; ++n)
branch  0 taken 10704595
branch  1 taken 927919 (fallthrough)
 10704595: 6762:    HASHI (hashval, *n);
   927919: 6763:  hashval %= FILE_BUCKETS;
        -: 6764:
  1000331: 6765:  for (f = files[hashval]; f != 0; f = f->next)
branch  0 taken 108955
branch  1 taken 891376 (fallthrough)
        -: 6766:    {
   108955: 6767:      if (strieq (f->hname, name))
branch  0 taken 108955 (fallthrough)
branch  1 taken 0
branch  2 taken 102159 (fallthrough)
branch  3 taken 6796
branch  4 taken 102159 (fallthrough)
branch  5 taken 0
branch  6 taken 36543 (fallthrough)
branch  7 taken 65616
        -: 6768:	{
        -: 6769:#ifdef VMS
        -: 6770:	  free (lname);
        -: 6771:#endif
    36543: 6772:	  return f;
        -: 6773:	}
        -: 6774:    }
        -: 6775:#ifdef VMS
        -: 6776:  free (lname);
        -: 6777:#endif
   891376: 6778:  return 0;
        -: 6779:}
        -: 6780:
        -: 6781:struct file *
function enter_file called 53931 returned 100% blocks executed 79%
    53931: 6782:enter_file (name)
        -: 6783:     char *name;
        -: 6784:{
        -: 6785:  register struct file *f, *new;
        -: 6786:  register char *n;
        -: 6787:  register unsigned int hashval;
        -: 6788:#ifdef VMS
        -: 6789:  char *lname, *ln;
        -: 6790:#endif
        -: 6791:
    53931: 6792:  if (*name == '\0')
branch  0 taken 0 (fallthrough)
branch  1 taken 53931
    #####: 6793:    abort ();
call    0 never executed
        -: 6794:
        -: 6795:#ifdef VMS
        -: 6796:  lname = (char *)malloc (strlen (name) + 1);
        -: 6797:  for (n = name, ln = lname; *n != '\0'; ++n, ++ln)
        -: 6798:    {
        -: 6799:      if (isupper(*n))
        -: 6800:	*ln = tolower(*n);
        -: 6801:      else
        -: 6802:	*ln = *n;
        -: 6803:    }
        -: 6804:  *ln = 0;
        -: 6805:  name = lname;
        -: 6806:#endif
        -: 6807:
    53931: 6808:  hashval = 0;
   346389: 6809:  for (n = name; *n != '\0'; ++n)
branch  0 taken 292458
branch  1 taken 53931 (fallthrough)
   292458: 6810:    HASHI (hashval, *n);
    53931: 6811:  hashval %= FILE_BUCKETS;
        -: 6812:
    56519: 6813:  for (f = files[hashval]; f != 0; f = f->next)
branch  0 taken 2781
branch  1 taken 53738 (fallthrough)
     2781: 6814:    if (strieq (f->hname, name))
branch  0 taken 2779 (fallthrough)
branch  1 taken 2
branch  2 taken 2579 (fallthrough)
branch  3 taken 200
branch  4 taken 2579 (fallthrough)
branch  5 taken 0
branch  6 taken 2388 (fallthrough)
branch  7 taken 191
        -: 6815:      break;
        -: 6816:
    53931: 6817:  if (f != 0 && !f->double_colon)
branch  0 taken 193 (fallthrough)
branch  1 taken 53738
branch  2 taken 193 (fallthrough)
branch  3 taken 0
        -: 6818:    {
        -: 6819:#ifdef VMS
        -: 6820:      free(lname);
        -: 6821:#endif
      193: 6822:      return f;
        -: 6823:    }
        -: 6824:
    53738: 6825:  new = (struct file *) xmalloc (sizeof (struct file));
call    0 returned 53738
    53738: 6826:  bzero ((char *) new, sizeof (struct file));
    53738: 6827:  new->name = new->hname = name;
    53738: 6828:  new->update_status = -1;
        -: 6829:
    53738: 6830:  if (f == 0)
branch  0 taken 53738 (fallthrough)
branch  1 taken 0
        -: 6831:    {
        -: 6832:      /* This is a completely new file.  */
    53738: 6833:      new->next = files[hashval];
    53738: 6834:      files[hashval] = new;
        -: 6835:    }
        -: 6836:  else
        -: 6837:    {
        -: 6838:      /* There is already a double-colon entry for this file.  */
    #####: 6839:      new->double_colon = f;
    #####: 6840:      while (f->prev != 0)
branch  0 never executed
branch  1 never executed
    #####: 6841:	f = f->prev;
    #####: 6842:      f->prev = new;
        -: 6843:    }
        -: 6844:
    53738: 6845:  return new;
        -: 6846:}
        -: 6847:
        -: 6848:/* Rehash FILE to NAME.  This is not as simple as resetting
        -: 6849:   the `hname' member, since it must be put in a new hash bucket,
        -: 6850:   and possibly merged with an existing file called NAME.  */
        -: 6851:
        -: 6852:void
function rehash_file called 0 returned 0% blocks executed 0%
    #####: 6853:rehash_file (file, name)
        -: 6854:     register struct file *file;
        -: 6855:     char *name;
        -: 6856:{
    #####: 6857:  char *oldname = file->hname;
        -: 6858:  register unsigned int oldhash;
        -: 6859:  register char *n;
        -: 6860:
    #####: 6861:  while (file->renamed != 0)
branch  0 never executed
branch  1 never executed
    #####: 6862:    file = file->renamed;
        -: 6863:
        -: 6864:  /* Find the hash values of the old and new names.  */
        -: 6865:
    #####: 6866:  oldhash = 0;
    #####: 6867:  for (n = oldname; *n != '\0'; ++n)
branch  0 never executed
branch  1 never executed
    #####: 6868:    HASHI (oldhash, *n);
        -: 6869:
    #####: 6870:  file_hash_enter (file, name, oldhash, file->name);
call    0 never executed
    #####: 6871:}
        -: 6872:
        -: 6873:/* Rename FILE to NAME.  This is not as simple as resetting
        -: 6874:   the `name' member, since it must be put in a new hash bucket,
        -: 6875:   and possibly merged with an existing file called NAME.  */
        -: 6876:
        -: 6877:void
function rename_file called 0 returned 0% blocks executed 0%
    #####: 6878:rename_file (file, name)
        -: 6879:     register struct file *file;
        -: 6880:     char *name;
        -: 6881:{
    #####: 6882:  rehash_file(file, name);
call    0 never executed
    #####: 6883:  while (file)
branch  0 never executed
branch  1 never executed
        -: 6884:    {
    #####: 6885:      file->name = file->hname;
    #####: 6886:      file = file->prev;
        -: 6887:    }
    #####: 6888:}
        -: 6889:
        -: 6890:void
function file_hash_enter called 0 returned 0% blocks executed 0%
    #####: 6891:file_hash_enter (file, name, oldhash, oldname)
        -: 6892:     register struct file *file;
        -: 6893:     char *name;
        -: 6894:     unsigned int oldhash;
        -: 6895:     char *oldname;
        -: 6896:{
    #####: 6897:  unsigned int oldbucket = oldhash % FILE_BUCKETS;
        -: 6898:  register unsigned int newhash, newbucket;
        -: 6899:  struct file *oldfile;
        -: 6900:  register char *n;
        -: 6901:  register struct file *f;
        -: 6902:
    #####: 6903:  newhash = 0;
    #####: 6904:  for (n = name; *n != '\0'; ++n)
branch  0 never executed
branch  1 never executed
    #####: 6905:    HASHI (newhash, *n);
    #####: 6906:  newbucket = newhash % FILE_BUCKETS;
        -: 6907:
        -: 6908:  /* Look for an existing file under the new name.  */
        -: 6909:
    #####: 6910:  for (oldfile = files[newbucket]; oldfile != 0; oldfile = oldfile->next)
branch  0 never executed
branch  1 never executed
    #####: 6911:    if (strieq (oldfile->hname, name))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -: 6912:      break;
        -: 6913:
        -: 6914:  /* If the old file is the same as the new file, something's wrong.  */
    #####: 6915:  assert (oldfile != file);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 6916:
    #####: 6917:  if (oldhash != 0 && (newbucket != oldbucket || oldfile != 0))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 6918:    {
        -: 6919:      /* Remove FILE from its hash bucket.  */
        -: 6920:
    #####: 6921:      struct file *lastf = 0;
        -: 6922:
    #####: 6923:      for (f = files[oldbucket]; f != file; f = f->next)
branch  0 never executed
branch  1 never executed
    #####: 6924:	lastf = f;
        -: 6925:
    #####: 6926:      if (lastf == 0)
branch  0 never executed
branch  1 never executed
    #####: 6927:	files[oldbucket] = f->next;
        -: 6928:      else
    #####: 6929:	lastf->next = f->next;
        -: 6930:    }
        -: 6931:
        -: 6932:  /* Give FILE its new name.  */
        -: 6933:
    #####: 6934:  file->hname = name;
    #####: 6935:  for (f = file->double_colon; f != 0; f = f->prev)
branch  0 never executed
branch  1 never executed
    #####: 6936:    f->hname = name;
        -: 6937:
    #####: 6938:  if (oldfile == 0)
branch  0 never executed
branch  1 never executed
        -: 6939:    {
        -: 6940:      /* There is no existing file with the new name.  */
        -: 6941:
    #####: 6942:      if (newbucket != oldbucket)
branch  0 never executed
branch  1 never executed
        -: 6943:	{
        -: 6944:	  /* Put FILE in its new hash bucket.  */
    #####: 6945:	  file->next = files[newbucket];
    #####: 6946:	  files[newbucket] = file;
        -: 6947:	}
        -: 6948:    }
        -: 6949:  else
        -: 6950:    {
        -: 6951:      /* There is an existing file with the new name.
        -: 6952:	 We must merge FILE into the existing file.  */
        -: 6953:
        -: 6954:      register struct dep *d;
        -: 6955:
    #####: 6956:      if (file->cmds != 0)
branch  0 never executed
branch  1 never executed
        -: 6957:	{
    #####: 6958:	  if (oldfile->cmds == 0)
branch  0 never executed
branch  1 never executed
    #####: 6959:	    oldfile->cmds = file->cmds;
    #####: 6960:	  else if (file->cmds != oldfile->cmds)
branch  0 never executed
branch  1 never executed
        -: 6961:	    {
        -: 6962:	      /* We have two sets of commands.  We will go with the
        -: 6963:		 one given in the rule explicitly mentioning this name,
        -: 6964:		 but give a message to let the user know what's going on.  */
    #####: 6965:	      if (oldfile->cmds->filename != 0)
branch  0 never executed
branch  1 never executed
    #####: 6966:		makefile_error (file->cmds->filename, file->cmds->lineno,
        -: 6967:				"Commands were specified for \
        -: 6968:file `%s' at %s:%u,",
    #####: 6969:				oldname, oldfile->cmds->filename,
    #####: 6970:				oldfile->cmds->lineno);
call    0 never executed
        -: 6971:	      else
    #####: 6972:		makefile_error (file->cmds->filename, file->cmds->lineno,
call    0 never executed
        -: 6973:				"Commands for file `%s' were found by \
        -: 6974:implicit rule search,",
        -: 6975:				oldname);
    #####: 6976:	      makefile_error (file->cmds->filename, file->cmds->lineno,
call    0 never executed
        -: 6977:			      "but `%s' is now considered the same file \
        -: 6978:as `%s'.",
        -: 6979:			      oldname, name);
    #####: 6980:	      makefile_error (file->cmds->filename, file->cmds->lineno,
call    0 never executed
        -: 6981:			      "Commands for `%s' will be ignored \
        -: 6982:in favor of those for `%s'.",
        -: 6983:			      name, oldname);
        -: 6984:	    }
        -: 6985:	}
        -: 6986:
        -: 6987:      /* Merge the dependencies of the two files.  */
        -: 6988:
    #####: 6989:      d = oldfile->deps;
    #####: 6990:      if (d == 0)
branch  0 never executed
branch  1 never executed
    #####: 6991:	oldfile->deps = file->deps;
        -: 6992:      else
        -: 6993:	{
    #####: 6994:	  while (d->next != 0)
branch  0 never executed
branch  1 never executed
    #####: 6995:	    d = d->next;
    #####: 6996:	  d->next = file->deps;
        -: 6997:	}
        -: 6998:
    #####: 6999:      merge_variable_set_lists (&oldfile->variables, file->variables);
call    0 never executed
        -: 7000:
    #####: 7001:      if (oldfile->double_colon && file->is_target && !file->double_colon)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 7002:	fatal ("can't rename single-colon `%s' to double-colon `%s'",
call    0 never executed
        -: 7003:	       oldname, name);
    #####: 7004:      if (!oldfile->double_colon  && file->double_colon)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 7005:	{
    #####: 7006:	  if (oldfile->is_target)
branch  0 never executed
branch  1 never executed
    #####: 7007:	    fatal ("can't rename double-colon `%s' to single-colon `%s'",
call    0 never executed
        -: 7008:		   oldname, name);
        -: 7009:	  else
    #####: 7010:	    oldfile->double_colon = file->double_colon;
        -: 7011:	}
        -: 7012:
    #####: 7013:      if (file->last_mtime > oldfile->last_mtime)
branch  0 never executed
branch  1 never executed
        -: 7014:	/* %%% Kludge so -W wins on a file that gets vpathized.  */
    #####: 7015:	oldfile->last_mtime = file->last_mtime;
        -: 7016:
        -: 7017:#define MERGE(field) oldfile->field |= file->field
    #####: 7018:      MERGE (precious);
    #####: 7019:      MERGE (tried_implicit);
    #####: 7020:      MERGE (updating);
    #####: 7021:      MERGE (updated);
    #####: 7022:      MERGE (is_target);
    #####: 7023:      MERGE (cmd_target);
    #####: 7024:      MERGE (phony);
    #####: 7025:      MERGE (ignore_vpath);
        -: 7026:#undef MERGE
        -: 7027:
    #####: 7028:      file->renamed = oldfile;
        -: 7029:    }
    #####: 7030:}
        -: 7031:
        -: 7032:/* Remove all nonprecious intermediate files.
        -: 7033:   If SIG is nonzero, this was caused by a fatal signal,
        -: 7034:   meaning that a different message will be printed, and
        -: 7035:   the message will go to stderr rather than stdout.  */
        -: 7036:
        -: 7037:void
function remove_intermediates called 793 returned 100% blocks executed 32%
      793: 7038:remove_intermediates (sig)
        -: 7039:     int sig;
        -: 7040:{
        -: 7041:  register int i;
        -: 7042:  register struct file *f;
        -: 7043:  char doneany;
        -: 7044:
      793: 7045:  if (question_flag || touch_flag)
branch  0 taken 792 (fallthrough)
branch  1 taken 1
branch  2 taken 1 (fallthrough)
branch  3 taken 791
        2: 7046:    return;
     791*: 7047:  if (sig && just_print_flag)
branch  0 taken 0 (fallthrough)
branch  1 taken 791
branch  2 never executed
branch  3 never executed
    #####: 7048:    return;
        -: 7049:
      791: 7050:  doneany = 0;
   797328: 7051:  for (i = 0; i < FILE_BUCKETS; ++i)
branch  0 taken 796537
branch  1 taken 791 (fallthrough)
   850045: 7052:    for (f = files[i]; f != 0; f = f->next)
branch  0 taken 53508
branch  1 taken 796537 (fallthrough)
   53508*: 7053:      if (f->intermediate && (f->dontcare || !f->precious)
branch  0 taken 0 (fallthrough)
branch  1 taken 53508
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 7054:	  && !f->secondary)
branch  0 never executed
branch  1 never executed
        -: 7055:	{
        -: 7056:	  int status;
    #####: 7057:	  if (f->update_status == -1)
branch  0 never executed
branch  1 never executed
        -: 7058:	    /* If nothing would have created this file yet,
        -: 7059:	       don't print an "rm" command for it.  */
    #####: 7060:            continue;
    #####: 7061: 	  else if (just_print_flag)
branch  0 never executed
branch  1 never executed
    #####: 7062:  	    status = 0;
        -: 7063:	  else
        -: 7064:	    {
    #####: 7065:	      status = unlink (f->name);
call    0 never executed
    #####: 7066:	      if (status < 0 && errno == ENOENT)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 7067:		continue;
        -: 7068:	    }
    #####: 7069:	  if (!f->dontcare)
branch  0 never executed
branch  1 never executed
        -: 7070:	    {
    #####: 7071:	      if (sig)
branch  0 never executed
branch  1 never executed
    #####: 7072:		error ("*** Deleting intermediate file `%s'", f->name);
call    0 never executed
    #####: 7073:	      else if (!silent_flag)
branch  0 never executed
branch  1 never executed
        -: 7074:		{
    #####: 7075:		  if (! doneany)
branch  0 never executed
branch  1 never executed
        -: 7076:		    {
    #####: 7077:		      fputs ("rm ", stdout);
call    0 never executed
    #####: 7078:		      doneany = 1;
        -: 7079:		    }
        -: 7080:		  else
    #####: 7081:		    putchar (' ');
call    0 never executed
    #####: 7082:		  fputs (f->name, stdout);
call    0 never executed
    #####: 7083:		  fflush (stdout);
call    0 never executed
        -: 7084:		}
    #####: 7085:	      if (status < 0)
branch  0 never executed
branch  1 never executed
    #####: 7086:		perror_with_name ("unlink: ", f->name);
call    0 never executed
        -: 7087:	    }
        -: 7088:	}
        -: 7089:
     791*: 7090:  if (doneany && !sig)
branch  0 taken 0 (fallthrough)
branch  1 taken 791
branch  2 never executed
branch  3 never executed
        -: 7091:    {
    #####: 7092:      putchar ('\n');
call    0 never executed
    #####: 7093:      fflush (stdout);
call    0 never executed
        -: 7094:    }
        -: 7095:}
        -: 7096:
        -: 7097:/* For each dependency of each file, make the `struct dep' point
        -: 7098:   at the appropriate `struct file' (which may have to be created).
        -: 7099:
        -: 7100:   Also mark the files depended on by .PRECIOUS, .PHONY, .SILENT,
        -: 7101:   and various other special targets.  */
        -: 7102:
        -: 7103:void
function snap_deps called 790 returned 100% blocks executed 46%
      790: 7104:snap_deps ()
        -: 7105:{
        -: 7106:  register struct file *f, *f2;
        -: 7107:  register struct dep *d;
        -: 7108:  register int i;
        -: 7109:
        -: 7110:  /* Enter each dependency name as a file.  */
   796320: 7111:  for (i = 0; i < FILE_BUCKETS; ++i)
branch  0 taken 795530
branch  1 taken 790 (fallthrough)
   842864: 7112:    for (f = files[i]; f != 0; f = f->next)
branch  0 taken 47334
branch  1 taken 795530 (fallthrough)
    94668: 7113:      for (f2 = f; f2 != 0; f2 = f2->prev)
branch  0 taken 47334
branch  1 taken 47334 (fallthrough)
    73968: 7114:	for (d = f2->deps; d != 0; d = d->next)
branch  0 taken 26634
branch  1 taken 47334 (fallthrough)
    26634: 7115:	  if (d->name != 0)
branch  0 taken 26634 (fallthrough)
branch  1 taken 0
        -: 7116:	    {
    26634: 7117:	      d->file = lookup_file (d->name);
call    0 returned 26634
    26634: 7118:	      if (d->file == 0)
branch  0 taken 15477 (fallthrough)
branch  1 taken 11157
    15477: 7119:		d->file = enter_file (d->name);
call    0 returned 15477
        -: 7120:	      else
    11157: 7121:		free (d->name);
    26634: 7122:	      d->name = 0;
        -: 7123:	    }
        -: 7124:
     790*: 7125:  for (f = lookup_file (".PRECIOUS"); f != 0; f = f->prev)
call    0 returned 790
branch  1 taken 0
branch  2 taken 790 (fallthrough)
    #####: 7126:    for (d = f->deps; d != 0; d = d->next)
branch  0 never executed
branch  1 never executed
    #####: 7127:      for (f2 = d->file; f2 != 0; f2 = f2->prev)
branch  0 never executed
branch  1 never executed
    #####: 7128:	f2->precious = 1;
        -: 7129:
      808: 7130:  for (f = lookup_file (".PHONY"); f != 0; f = f->prev)
call    0 returned 790
branch  1 taken 18
branch  2 taken 790 (fallthrough)
      249: 7131:    for (d = f->deps; d != 0; d = d->next)
branch  0 taken 231
branch  1 taken 18 (fallthrough)
      462: 7132:      for (f2 = d->file; f2 != 0; f2 = f2->prev)
branch  0 taken 231
branch  1 taken 231 (fallthrough)
        -: 7133:	{
        -: 7134:	  /* Mark this file as phony and nonexistent.  */
      231: 7135:	  f2->phony = 1;
      231: 7136:	  f2->last_mtime = (time_t) -1;
        -: 7137:	}
        -: 7138:
     790*: 7139:  for (f = lookup_file (".INTERMEDIATE"); f != 0; f = f->prev)
call    0 returned 790
branch  1 taken 0
branch  2 taken 790 (fallthrough)
        -: 7140:    {
        -: 7141:      /* .INTERMEDIATE with deps listed
        -: 7142:	 marks those deps as intermediate files.  */
    #####: 7143:      for (d = f->deps; d != 0; d = d->next)
branch  0 never executed
branch  1 never executed
    #####: 7144:	for (f2 = d->file; f2 != 0; f2 = f2->prev)
branch  0 never executed
branch  1 never executed
    #####: 7145:	  f2->intermediate = 1;
        -: 7146:      /* .INTERMEDIATE with no deps does nothing.
        -: 7147:	 Marking all files as intermediates is useless
        -: 7148:	 since the goal targets would be deleted after they are built.  */
        -: 7149:    }
        -: 7150:
     790*: 7151:  for (f = lookup_file (".SECONDARY"); f != 0; f = f->prev)
call    0 returned 790
branch  1 taken 0
branch  2 taken 790 (fallthrough)
        -: 7152:    {
        -: 7153:      /* .SECONDARY with deps listed
        -: 7154:	 marks those deps as intermediate files
        -: 7155:	 in that they don't get rebuilt if not actually needed;
        -: 7156:	 but unlike real intermediate files,
        -: 7157:	 these are not deleted after make finishes.  */
    #####: 7158:      if (f->deps)
branch  0 never executed
branch  1 never executed
        -: 7159:	{
    #####: 7160:	  for (d = f->deps; d != 0; d = d->next)
branch  0 never executed
branch  1 never executed
    #####: 7161:	    for (f2 = d->file; f2 != 0; f2 = f2->prev)
branch  0 never executed
branch  1 never executed
    #####: 7162:	      f2->intermediate = f2->secondary = 1;
        -: 7163:	}
        -: 7164:      /* .SECONDARY with no deps listed marks *all* files that way.  */
        -: 7165:      else
        -: 7166:	{
        -: 7167:	  int i;
    #####: 7168:	  for (i = 0; i < FILE_BUCKETS; i++)
branch  0 never executed
branch  1 never executed
    #####: 7169:	    for (f2 = files[i]; f2; f2= f2->next)
branch  0 never executed
branch  1 never executed
    #####: 7170:	      f2->intermediate = f2->secondary = 1;
        -: 7171:	}
        -: 7172:    }
        -: 7173:
      790: 7174:  f = lookup_file (".EXPORT_ALL_VARIABLES");
call    0 returned 790
     790*: 7175:  if (f != 0 && f->is_target)
branch  0 taken 0 (fallthrough)
branch  1 taken 790
branch  2 never executed
branch  3 never executed
    #####: 7176:    export_all_variables = 1;
        -: 7177:
      790: 7178:  f = lookup_file (".IGNORE");
call    0 returned 790
     790*: 7179:  if (f != 0 && f->is_target)
branch  0 taken 0 (fallthrough)
branch  1 taken 790
branch  2 never executed
branch  3 never executed
        -: 7180:    {
    #####: 7181:      if (f->deps == 0)
branch  0 never executed
branch  1 never executed
    #####: 7182:	ignore_errors_flag = 1;
        -: 7183:      else
    #####: 7184:	for (d = f->deps; d != 0; d = d->next)
branch  0 never executed
branch  1 never executed
    #####: 7185:	  for (f2 = d->file; f2 != 0; f2 = f2->prev)
branch  0 never executed
branch  1 never executed
    #####: 7186:	    f2->command_flags |= COMMANDS_NOERROR;
        -: 7187:    }
        -: 7188:
      790: 7189:  f = lookup_file (".SILENT");
call    0 returned 790
     790*: 7190:  if (f != 0 && f->is_target)
branch  0 taken 0 (fallthrough)
branch  1 taken 790
branch  2 never executed
branch  3 never executed
        -: 7191:    {
    #####: 7192:      if (f->deps == 0)
branch  0 never executed
branch  1 never executed
    #####: 7193:	silent_flag = 1;
        -: 7194:      else
    #####: 7195:	for (d = f->deps; d != 0; d = d->next)
branch  0 never executed
branch  1 never executed
    #####: 7196:	  for (f2 = d->file; f2 != 0; f2 = f2->prev)
branch  0 never executed
branch  1 never executed
    #####: 7197:	    f2->command_flags |= COMMANDS_SILENT;
        -: 7198:    }
        -: 7199:
      790: 7200:  f = lookup_file (".POSIX");
call    0 returned 790
     790*: 7201:  if (f != 0 && f->is_target)
branch  0 taken 0 (fallthrough)
branch  1 taken 790
branch  2 never executed
branch  3 never executed
    #####: 7202:    posix_pedantic = 1;
      790: 7203:}
        -: 7204:
        -: 7205:/* Set the `command_state' member of FILE and all its `also_make's.  */
        -: 7206:
        -: 7207:void
function set_command_state called 3 returned 100% blocks executed 75%
        3: 7208:set_command_state (file, state)
        -: 7209:     struct file *file;
        -: 7210:     int state;
        -: 7211:{
        -: 7212:  struct dep *d;
        -: 7213:
        3: 7214:  file->command_state = state;
        -: 7215:
       3*: 7216:  for (d = file->also_make; d != 0; d = d->next)
branch  0 taken 0
branch  1 taken 3 (fallthrough)
    #####: 7217:    d->file->command_state = state;
        3: 7218:}
        -: 7219:
        -: 7220:/* Print the data base of files.  */
        -: 7221:
        -: 7222:static void
function print_file called 25795 returned 100% blocks executed 57%
    25795: 7223:print_file (f)
        -: 7224:     struct file *f;
        -: 7225:{
        -: 7226:  register struct dep *d;
        -: 7227:
    25795: 7228:  putchar ('\n');
call    0 returned 25795
    25795: 7229:  if (!f->is_target)
branch  0 taken 25795 (fallthrough)
branch  1 taken 0
    25795: 7230:    puts ("# Not a target:");
call    0 returned 25795
   25795*: 7231:  printf ("%s:%s", f->name, f->double_colon ? ":" : "");
branch  0 taken 0 (fallthrough)
branch  1 taken 25795
call    2 returned 25795
        -: 7232:
    38115: 7233:  for (d = f->deps; d != 0; d = d->next)
branch  0 taken 12320
branch  1 taken 25795 (fallthrough)
   12320*: 7234:    printf (" %s", dep_name (d));
branch  0 taken 12320 (fallthrough)
branch  1 taken 0
call    2 returned 12320
    25795: 7235:  putchar ('\n');
call    0 returned 25795
        -: 7236:
    25795: 7237:  if (f->precious)
branch  0 taken 0 (fallthrough)
branch  1 taken 25795
    #####: 7238:    puts ("#  Precious file (dependency of .PRECIOUS).");
call    0 never executed
    25795: 7239:  if (f->phony)
branch  0 taken 0 (fallthrough)
branch  1 taken 25795
    #####: 7240:    puts ("#  Phony target (dependency of .PHONY).");
call    0 never executed
    25795: 7241:  if (f->cmd_target)
branch  0 taken 0 (fallthrough)
branch  1 taken 25795
    #####: 7242:    puts ("#  Command-line target.");
call    0 never executed
    25795: 7243:  if (f->dontcare)
branch  0 taken 0 (fallthrough)
branch  1 taken 25795
    #####: 7244:    puts ("#  A default or MAKEFILES makefile.");
call    0 never executed
    25795: 7245:  printf ("#  Implicit rule search has%s been done.\n",
call    0 returned 25795
    25795: 7246:	  f->tried_implicit ? "" : " not");
branch  0 taken 385 (fallthrough)
branch  1 taken 25410
    25795: 7247:  if (f->stem != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 25795
    #####: 7248:    printf ("#  Implicit/static pattern stem: `%s'\n", f->stem);
call    0 never executed
    25795: 7249:  if (f->intermediate)
branch  0 taken 0 (fallthrough)
branch  1 taken 25795
    #####: 7250:    puts ("#  File is an intermediate dependency.");
call    0 never executed
    25795: 7251:  if (f->also_make != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 25795
        -: 7252:    {
    #####: 7253:      fputs ("#  Also makes:", stdout);
call    0 never executed
    #####: 7254:      for (d = f->also_make; d != 0; d = d->next)
branch  0 never executed
branch  1 never executed
    #####: 7255:	printf (" %s", dep_name (d));
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 7256:      putchar ('\n');
call    0 never executed
        -: 7257:    }
    25795: 7258:  if (f->last_mtime == (time_t) 0)
branch  0 taken 25410 (fallthrough)
branch  1 taken 385
    25410: 7259:    puts ("#  Modification time never checked.");
call    0 returned 25410
      385: 7260:  else if (f->last_mtime == (time_t) -1)
branch  0 taken 384 (fallthrough)
branch  1 taken 1
      384: 7261:    puts ("#  File does not exist.");
call    0 returned 384
        -: 7262:  else
        1: 7263:    printf ("#  Last modified 00:00 Jan 01 2000\n");
call    0 returned 1
        -: 7264:  /*
        -: 7265:    printf ("#  Last modified %.24s (%ld)\n",
        -: 7266:	    ctime (&f->last_mtime), (long int) f->last_mtime); */
    25795: 7267:  printf ("#  File has%s been updated.\n",
call    0 returned 25795
    25795: 7268:	  f->updated ? "" : " not");
branch  0 taken 129 (fallthrough)
branch  1 taken 25666
    25795: 7269:  switch (f->command_state)
branch  0 taken 0
branch  1 taken 0
branch  2 taken 25795
branch  3 taken 0
        -: 7270:    {
    #####: 7271:    case cs_running:
    #####: 7272:      puts ("#  Commands currently running (THIS IS A BUG).");
call    0 never executed
    #####: 7273:      break;
    #####: 7274:    case cs_deps_running:
    #####: 7275:      puts ("#  Dependencies commands running (THIS IS A BUG).");
call    0 never executed
    #####: 7276:      break;
    25795: 7277:    case cs_not_started:
        -: 7278:    case cs_finished:
    25795: 7279:      switch (f->update_status)
branch  0 taken 25666
branch  1 taken 1
branch  2 taken 0
branch  3 taken 128
branch  4 taken 0
        -: 7280:	{
    25666: 7281:	case -1:
    25666: 7282:	  break;
        1: 7283:	case 0:
        1: 7284:	  puts ("#  Successfully updated.");
call    0 returned 1
        1: 7285:	  break;
    #####: 7286:	case 1:
    #####: 7287:	  assert (question_flag);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 7288:	  puts ("#  Needs to be updated (-q is set).");
call    0 never executed
    #####: 7289:	  break;
      128: 7290:	case 2:
      128: 7291:	  puts ("#  Failed to be updated.");
call    0 returned 128
      128: 7292:	  break;
    #####: 7293:	default:
    #####: 7294:	  puts ("#  Invalid value in `update_status' member!");
call    0 never executed
    #####: 7295:	  fflush (stdout);
call    0 never executed
    #####: 7296:	  fflush (stderr);
call    0 never executed
    #####: 7297:	  abort ();
call    0 never executed
        -: 7298:	}
    25795: 7299:      break;
    #####: 7300:    default:
    #####: 7301:      puts ("#  Invalid value in `command_state' member!");
call    0 never executed
    #####: 7302:      fflush (stdout);
call    0 never executed
    #####: 7303:      fflush (stderr);
call    0 never executed
    #####: 7304:      abort ();
call    0 never executed
        -: 7305:    }
        -: 7306:
    25795: 7307:  if (f->variables != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 25795
    #####: 7308:    print_file_variables (f);
call    0 never executed
        -: 7309:
    25795: 7310:  if (f->cmds != 0)
branch  0 taken 17325 (fallthrough)
branch  1 taken 8470
    17325: 7311:    print_commands (f->cmds);
call    0 returned 17325
    25795: 7312:}
        -: 7313:
        -: 7314:void
function print_file_data_base called 385 returned 100% blocks executed 94%
      385: 7315:print_file_data_base ()
        -: 7316:{
        -: 7317:  register unsigned int i, nfiles, per_bucket;
        -: 7318:  register struct file *file;
        -: 7319:
      385: 7320:  puts ("\n# Files");
call    0 returned 385
        -: 7321:
      385: 7322:  per_bucket = nfiles = 0;
   388080: 7323:  for (i = 0; i < FILE_BUCKETS; ++i)
branch  0 taken 387695
branch  1 taken 385 (fallthrough)
        -: 7324:    {
   387695: 7325:      register unsigned int this_bucket = 0;
        -: 7326:
   413490: 7327:      for (file = files[i]; file != 0; file = file->next)
branch  0 taken 25795
branch  1 taken 387695 (fallthrough)
        -: 7328:	{
        -: 7329:	  register struct file *f;
        -: 7330:
    25795: 7331:	  ++this_bucket;
        -: 7332:
    51590: 7333:	  for (f = file; f != 0; f = f->prev)
branch  0 taken 25795
branch  1 taken 25795 (fallthrough)
    25795: 7334:	    print_file (f);
call    0 returned 25795
        -: 7335:	}
        -: 7336:
   387695: 7337:      nfiles += this_bucket;
   387695: 7338:      if (this_bucket > per_bucket)
branch  0 taken 770 (fallthrough)
branch  1 taken 386925
      770: 7339:	per_bucket = this_bucket;
        -: 7340:    }
        -: 7341:
      385: 7342:  if (nfiles == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 385
    #####: 7343:    puts ("\n# No files.");
call    0 never executed
        -: 7344:  else
        -: 7345:    {
      385: 7346:      printf ("\n# %u files in %u hash buckets.\n", nfiles, FILE_BUCKETS);
call    0 returned 385
        -: 7347:#ifndef	NO_FLOAT
      385: 7348:      printf ("# average %.3f files per bucket, max %u files in one bucket.\n",
      385: 7349:	      ((double) nfiles) / ((double) FILE_BUCKETS), per_bucket);
call    0 returned 385
        -: 7350:#endif
        -: 7351:    }
      385: 7352:}
        -: 7353:
        -: 7354:/* EOF */
        -: 7355:
        -: 7356:
        -: 7357:
        -: 7358:/*************************************************************
        -: 7359:  ============================================================
        -: 7360:  ************************************************************
        -: 7361:  ============================================================
        -: 7362:  ************************************************************
        -: 7363:                         misc.c
        -: 7364:  ************************************************************
        -: 7365:  ============================================================
        -: 7366:  ************************************************************
        -: 7367:  ============================================================
        -: 7368:  *************************************************************/
        -: 7369:
        -: 7370:/* Miscellaneous generic support functions for GNU Make.
        -: 7371:Copyright (C) 1988,89,90,91,92,93,94,95,97 Free Software Foundation, Inc.
        -: 7372:This file is part of GNU Make.
        -: 7373:
        -: 7374:GNU Make is free software; you can redistribute it and/or modify
        -: 7375:it under the terms of the GNU General Public License as published by
        -: 7376:the Free Software Foundation; either version 2, or (at your option)
        -: 7377:any later version.
        -: 7378:
        -: 7379:GNU Make is distributed in the hope that it will be useful,
        -: 7380:but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 7381:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 7382:GNU General Public License for more details.
        -: 7383:
        -: 7384:You should have received a copy of the GNU General Public License
        -: 7385:along with GNU Make; see the file COPYING.  If not, write to
        -: 7386:the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
        -: 7387:
        -: 7388:
        -: 7389:/* Compare strings *S1 and *S2.
        -: 7390:   Return negative if the first is less, positive if it is greater,
        -: 7391:   zero if they are equal.  */
        -: 7392:
        -: 7393:int
function alpha_compare called 0 returned 0% blocks executed 0%
    #####: 7394:alpha_compare (s1, s2)
        -: 7395:     char **s1, **s2;
        -: 7396:{
    #####: 7397:  if (**s1 != **s2)
branch  0 never executed
branch  1 never executed
    #####: 7398:    return **s1 - **s2;
    #####: 7399:  return strcmp (*s1, *s2);
        -: 7400:}
        -: 7401:
        -: 7402:/* Discard each backslash-newline combination from LINE.
        -: 7403:   Backslash-backslash-newline combinations become backslash-newlines.
        -: 7404:   This is done by copying the text at LINE into itself.  */
        -: 7405:
        -: 7406:void
function collapse_continuations called 2615 returned 100% blocks executed 80%
     2615: 7407:collapse_continuations (line)
        -: 7408:     char *line;
        -: 7409:{
        -: 7410:  register char *in, *out, *p;
        -: 7411:  register int backslash;
        -: 7412:  register unsigned int bs_write;
        -: 7413:
     2615: 7414:  in = index (line, '\n');
     2615: 7415:  if (in == 0)
branch  0 taken 2594 (fallthrough)
branch  1 taken 21
     2594: 7416:    return;
        -: 7417:
       21: 7418:  out = in;
       42: 7419:  while (out > line && out[-1] == '\\')
branch  0 taken 42 (fallthrough)
branch  1 taken 0
branch  2 taken 21
branch  3 taken 21 (fallthrough)
       21: 7420:    --out;
        -: 7421:
       84: 7422:  while (*in != '\0')
branch  0 taken 63
branch  1 taken 21 (fallthrough)
        -: 7423:    {
        -: 7424:      /* BS_WRITE gets the number of quoted backslashes at
        -: 7425:	 the end just before IN, and BACKSLASH gets nonzero
        -: 7426:	 if the next character is quoted.  */
       63: 7427:      backslash = 0;
       63: 7428:      bs_write = 0;
      126: 7429:      for (p = in - 1; p >= line && *p == '\\'; --p)
branch  0 taken 126 (fallthrough)
branch  1 taken 0
branch  2 taken 63
branch  3 taken 63 (fallthrough)
        -: 7430:	{
       63: 7431:	  if (backslash)
branch  0 taken 0 (fallthrough)
branch  1 taken 63
    #####: 7432:	    ++bs_write;
       63: 7433:	  backslash = !backslash;
        -: 7434:
        -: 7435:	  /* It should be impossible to go back this far without exiting,
        -: 7436:	     but if we do, we can't get the right answer.  */
       63: 7437:	  if (in == out - 1)
branch  0 taken 0 (fallthrough)
branch  1 taken 63
    #####: 7438:	    abort ();
call    0 never executed
        -: 7439:	}
        -: 7440:
        -: 7441:      /* Output the appropriate number of backslashes.  */
       63: 7442:      while (bs_write-- > 0)
branch  0 taken 0
branch  1 taken 63 (fallthrough)
    #####: 7443:	*out++ = '\\';
        -: 7444:
        -: 7445:      /* Skip the newline.  */
       63: 7446:      ++in;
        -: 7447:
        -: 7448:      /* If the newline is quoted, discard following whitespace
        -: 7449:	 and any preceding whitespace; leave just one space.  */
       63: 7450:      if (backslash)
branch  0 taken 63 (fallthrough)
branch  1 taken 0
        -: 7451:	{
       63: 7452:	  in = next_token (in);
call    0 returned 63
      126: 7453:	  while (out > line && isblank (out[-1]))
branch  0 taken 126 (fallthrough)
branch  1 taken 0
branch  2 taken 63
branch  3 taken 63 (fallthrough)
       63: 7454:	    --out;
       63: 7455:	  *out++ = ' ';
        -: 7456:	}
        -: 7457:      else
        -: 7458:	/* If the newline isn't quoted, put it in the output.  */
    #####: 7459:	*out++ = '\n';
        -: 7460:
        -: 7461:      /* Now copy the following line to the output.
        -: 7462:	 Stop when we find backslashes followed by a newline.  */
     2793: 7463:      while (*in != '\0')
branch  0 taken 2772
branch  1 taken 21 (fallthrough)
     2772: 7464:	if (*in == '\\')
branch  0 taken 42 (fallthrough)
branch  1 taken 2730
        -: 7465:	  {
       42: 7466:	    p = in + 1;
       42: 7467:	    while (*p == '\\')
branch  0 taken 0
branch  1 taken 42 (fallthrough)
    #####: 7468:	      ++p;
       42: 7469:	    if (*p == '\n')
branch  0 taken 42 (fallthrough)
branch  1 taken 0
        -: 7470:	      {
       42: 7471:		in = p;
       42: 7472:		break;
        -: 7473:	      }
    #####: 7474:	    while (in < p)
branch  0 never executed
branch  1 never executed
    #####: 7475:	      *out++ = *in++;
        -: 7476:	  }
        -: 7477:	else
     2730: 7478:	  *out++ = *in++;
        -: 7479:    }
        -: 7480:
       21: 7481:  *out = '\0';
        -: 7482:}
        -: 7483:
        -: 7484:
        -: 7485:/* Remove comments from LINE.
        -: 7486:   This is done by copying the text at LINE onto itself.  */
        -: 7487:
        -: 7488:void
function remove_comments called 2090 returned 100% blocks executed 100%
     2090: 7489:remove_comments (line)
        -: 7490:     char *line;
        -: 7491:{
        -: 7492:  char *comment;
        -: 7493:
     2090: 7494:  comment = find_char_unquote (line, "#", 0);
call    0 returned 2090
        -: 7495:
     2090: 7496:  if (comment != 0)
branch  0 taken 378 (fallthrough)
branch  1 taken 1712
        -: 7497:    /* Cut off the line at the #.  */
      378: 7498:    *comment = '\0';
     2090: 7499:}
        -: 7500:
        -: 7501:/* Print N spaces (used by DEBUGPR for target-depth).  */
        -: 7502:
        -: 7503:void
function print_spaces called 142976 returned 100% blocks executed 100%
   142976: 7504:print_spaces (n)
        -: 7505:     register unsigned int n;
        -: 7506:{
   667264: 7507:  while (n-- > 0)
branch  0 taken 524288
branch  1 taken 142976 (fallthrough)
   524288: 7508:    putchar (' ');
call    0 returned 524288
   142976: 7509:}
        -: 7510:
        -: 7511:
        -: 7512:/* Return a newly-allocated string whose contents
        -: 7513:   concatenate those of s1, s2, s3.  */
        -: 7514:
        -: 7515:char *
function concat called 936 returned 100% blocks executed 89%
      936: 7516:concat (s1, s2, s3)
        -: 7517:     register char *s1, *s2, *s3;
        -: 7518:{
        -: 7519:  register unsigned int len1, len2, len3;
        -: 7520:  register char *result;
        -: 7521:
     936*: 7522:  len1 = *s1 != '\0' ? strlen (s1) : 0;
branch  0 taken 936 (fallthrough)
branch  1 taken 0
     936*: 7523:  len2 = *s2 != '\0' ? strlen (s2) : 0;
branch  0 taken 936 (fallthrough)
branch  1 taken 0
      936: 7524:  len3 = *s3 != '\0' ? strlen (s3) : 0;
branch  0 taken 161 (fallthrough)
branch  1 taken 775
        -: 7525:
      936: 7526:  result = (char *) xmalloc (len1 + len2 + len3 + 1);
call    0 returned 936
        -: 7527:
      936: 7528:  if (*s1 != '\0')
branch  0 taken 936 (fallthrough)
branch  1 taken 0
      936: 7529:    bcopy (s1, result, len1);
      936: 7530:  if (*s2 != '\0')
branch  0 taken 936 (fallthrough)
branch  1 taken 0
      936: 7531:    bcopy (s2, result + len1, len2);
      936: 7532:  if (*s3 != '\0')
branch  0 taken 161 (fallthrough)
branch  1 taken 775
      161: 7533:    bcopy (s3, result + len1 + len2, len3);
      936: 7534:  *(result + len1 + len2 + len3) = '\0';
        -: 7535:
      936: 7536:  return result;
        -: 7537:}
        -: 7538:
        -: 7539:/* Print a message on stdout.  */
        -: 7540:
        -: 7541:void
function message called 16 returned 100% blocks executed 90%
       16: 7542:message (prefix, s1, s2, s3, s4, s5, s6)
        -: 7543:     int prefix;
        -: 7544:     char *s1, *s2, *s3, *s4, *s5, *s6;
        -: 7545:{
       16: 7546:  log_working_directory (1);
call    0 returned 16
        -: 7547:
       16: 7548:  if (s1 != 0)
branch  0 taken 16 (fallthrough)
branch  1 taken 0
        -: 7549:    {
       16: 7550:      if (prefix)
branch  0 taken 12 (fallthrough)
branch  1 taken 4
        -: 7551:	{
       12: 7552:	  if (makelevel == 0)
branch  0 taken 12 (fallthrough)
branch  1 taken 0
       12: 7553:	    printf ("%s: ", program);
call    0 returned 12
        -: 7554:	  else
    #####: 7555:	    printf ("%s[%u]: ", program, makelevel);
call    0 never executed
        -: 7556:	}
       16: 7557:      printf (s1, s2, s3, s4, s5, s6);
call    0 returned 16
       16: 7558:      putchar ('\n');
call    0 returned 16
        -: 7559:    }
        -: 7560:
       16: 7561:  fflush (stdout);
call    0 returned 16
       16: 7562:}
        -: 7563:
        -: 7564:/* Print an error message and exit.  */
        -: 7565:
        -: 7566:/* VARARGS1 */
        -: 7567:void
function fatal called 776 returned 0% blocks executed 86%
      776: 7568:fatal (s1, s2, s3, s4, s5, s6)
        -: 7569:     char *s1, *s2, *s3, *s4, *s5, *s6;
        -: 7570:{
      776: 7571:  log_working_directory (1);
call    0 returned 776
        -: 7572:
      776: 7573:  if (makelevel == 0)
branch  0 taken 776 (fallthrough)
branch  1 taken 0
      776: 7574:    fprintf (stderr, "%s: *** ", program);
call    0 returned 776
        -: 7575:  else
    #####: 7576:    fprintf (stderr, "%s[%u]: *** ", program, makelevel);
call    0 never executed
      776: 7577:  fprintf (stderr, s1, s2, s3, s4, s5, s6);
call    0 returned 776
      776: 7578:  fputs (".  Stop.\n", stderr);
call    0 returned 776
        -: 7579:
      776: 7580:  die (2);
        -: 7581:}
        -: 7582:
        -: 7583:/* Print error message.  `s1' is printf control string, `s2' is arg for it. */
        -: 7584:
        -: 7585:/* VARARGS1 */
        -: 7586:
        -: 7587:void
function error called 1285 returned 100% blocks executed 88%
     1285: 7588:error (s1, s2, s3, s4, s5, s6)
        -: 7589:     char *s1, *s2, *s3, *s4, *s5, *s6;
        -: 7590:{
     1285: 7591:  log_working_directory (1);
call    0 returned 1285
        -: 7592:
     1285: 7593:  if (makelevel == 0)
branch  0 taken 1285 (fallthrough)
branch  1 taken 0
     1285: 7594:    fprintf (stderr, "%s: ", program);
call    0 returned 1285
        -: 7595:  else
    #####: 7596:    fprintf (stderr, "%s[%u]: ", program, makelevel);
call    0 never executed
     1285: 7597:  fprintf (stderr, s1, s2, s3, s4, s5, s6);
call    0 returned 1285
     1285: 7598:  putc ('\n', stderr);
call    0 returned 1285
     1285: 7599:  fflush (stderr);
call    0 returned 1285
     1285: 7600:}
        -: 7601:
        -: 7602:void
function makefile_error called 86 returned 100% blocks executed 100%
       86: 7603:makefile_error (file, lineno, s1, s2, s3, s4, s5, s6)
        -: 7604:     char *file;
        -: 7605:     unsigned int lineno;
        -: 7606:     char *s1, *s2, *s3, *s4, *s5, *s6;
        -: 7607:{
       86: 7608:  log_working_directory (1);
call    0 returned 86
        -: 7609:
       86: 7610:  fprintf (stderr, "%s:%u: ", file, lineno);
call    0 returned 86
       86: 7611:  fprintf (stderr, s1, s2, s3, s4, s5, s6);
call    0 returned 86
       86: 7612:  putc ('\n', stderr);
call    0 returned 86
       86: 7613:  fflush (stderr);
call    0 returned 86
       86: 7614:}
        -: 7615:
        -: 7616:void
function makefile_fatal called 0 returned 0% blocks executed 0%
    #####: 7617:makefile_fatal (file, lineno, s1, s2, s3, s4, s5, s6)
        -: 7618:     char *file;
        -: 7619:     unsigned int lineno;
        -: 7620:     char *s1, *s2, *s3, *s4, *s5, *s6;
        -: 7621:{
    #####: 7622:  if (!file)
branch  0 never executed
branch  1 never executed
    #####: 7623:    fatal(s1, s2, s3, s4, s5, s6);
call    0 never executed
        -: 7624:
    #####: 7625:  log_working_directory (1);
call    0 never executed
        -: 7626:
    #####: 7627:  fprintf (stderr, "%s:%u: *** ", file, lineno);
call    0 never executed
    #####: 7628:  fprintf (stderr, s1, s2, s3, s4, s5, s6);
call    0 never executed
    #####: 7629:  fputs (".  Stop.\n", stderr);
call    0 never executed
        -: 7630:
    #####: 7631:  die (2);
        -: 7632:}
        -: 7633:
        -: 7634:#ifndef HAVE_STRERROR
        -: 7635:
        -: 7636:#undef	strerror
        -: 7637:
        -: 7638:char *
        -: 7639:strerror (errnum)
        -: 7640:     int errnum;
        -: 7641:{
        -: 7642:  extern int errno, sys_nerr;
        -: 7643:#ifndef __DECC
        -: 7644:  extern char *sys_errlist[];
        -: 7645:#endif
        -: 7646:  static char buf[] = "Unknown error 12345678901234567890";
        -: 7647:
        -: 7648:  if (errno < sys_nerr)
        -: 7649:    return sys_errlist[errnum];
        -: 7650:
        -: 7651:  sprintf (buf, "Unknown error %d", errnum);
        -: 7652:  return buf;
        -: 7653:}
        -: 7654:#endif
        -: 7655:
        -: 7656:/* Print an error message from errno.  */
        -: 7657:
        -: 7658:void
function perror_with_name called 771 returned 100% blocks executed 100%
      771: 7659:perror_with_name (str, name)
        -: 7660:     char *str, *name;
        -: 7661:{
      771: 7662:  error ("%s%s: %s", str, name, strerror (errno));
call    0 returned 771
call    1 returned 771
      771: 7663:}
        -: 7664:
        -: 7665:/* Print an error message from errno and exit.  */
        -: 7666:
        -: 7667:void
function pfatal_with_name called 2 returned 0% blocks executed 100%
        2: 7668:pfatal_with_name (name)
        -: 7669:     char *name;
        -: 7670:{
        2: 7671:  fatal ("%s: %s", name, strerror (errno));
call    0 returned 2
        -: 7672:
        -: 7673:  /* NOTREACHED */
        -: 7674:}
        -: 7675:
        -: 7676:/* Like malloc but get fatal error if memory is exhausted.  */
        -: 7677:
        -: 7678:#undef xmalloc
        -: 7679:#undef xrealloc
        -: 7680:
        -: 7681:char *
function xmalloc called 1026267 returned 100% blocks executed 75%
  1026267: 7682:xmalloc (size)
        -: 7683:     unsigned int size;
        -: 7684:{
  1026267: 7685:  char *result = (char *) malloc (size);
  1026267: 7686:  if (result == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 1026267
    #####: 7687:    fatal ("virtual memory exhausted");
call    0 never executed
  1026267: 7688:  return result;
        -: 7689:}
        -: 7690:
        -: 7691:
        -: 7692:char *
function xrealloc called 90 returned 100% blocks executed 75%
       90: 7693:xrealloc (ptr, size)
        -: 7694:     char *ptr;
        -: 7695:     unsigned int size;
        -: 7696:{
       90: 7697:  char *result = (char *) realloc (ptr, size);
       90: 7698:  if (result == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 90
    #####: 7699:    fatal ("virtual memory exhausted");
call    0 never executed
       90: 7700:  return result;
        -: 7701:}
        -: 7702:
        -: 7703:char *
function savestring called 317625 returned 100% blocks executed 100%
   317625: 7704:savestring (str, length)
        -: 7705:     char *str;
        -: 7706:     unsigned int length;
        -: 7707:{
   317625: 7708:  register char *out = (char *) xmalloc (length + 1);
call    0 returned 317625
   317625: 7709:  if (length > 0)
branch  0 taken 316664 (fallthrough)
branch  1 taken 961
   316664: 7710:    bcopy (str, out, length);
   317625: 7711:  out[length] = '\0';
   317625: 7712:  return out;
        -: 7713:}
        -: 7714:
        -: 7715:/* Search string BIG (length BLEN) for an occurrence of
        -: 7716:   string SMALL (length SLEN).  Return a pointer to the
        -: 7717:   beginning of the first occurrence, or return nil if none found.  */
        -: 7718:
        -: 7719:char *
function sindex called 8 returned 100% blocks executed 75%
        8: 7720:sindex (big, blen, small, slen)
        -: 7721:     char *big;
        -: 7722:     unsigned int blen;
        -: 7723:     char *small;
        -: 7724:     unsigned int slen;
        -: 7725:{
        -: 7726:  register unsigned int b;
        -: 7727:
        8: 7728:  if (blen < 1)
branch  0 taken 0 (fallthrough)
branch  1 taken 8
    #####: 7729:    blen = strlen (big);
        8: 7730:  if (slen < 1)
branch  0 taken 0 (fallthrough)
branch  1 taken 8
    #####: 7731:    slen = strlen (small);
        -: 7732:
      324: 7733:  for (b = 0; b < blen; ++b)
branch  0 taken 316
branch  1 taken 8 (fallthrough)
      316: 7734:    if (big[b] == *small && !strncmp (&big[b + 1], small + 1, slen - 1))
branch  0 taken 40 (fallthrough)
branch  1 taken 276
branch  2 taken 0 (fallthrough)
branch  3 taken 40
    #####: 7735:      return (&big[b]);
        -: 7736:
        8: 7737:  return 0;
        -: 7738:}
        -: 7739:
        -: 7740:/* Limited INDEX:
        -: 7741:   Search through the string STRING, which ends at LIMIT, for the character C.
        -: 7742:   Returns a pointer to the first occurrence, or nil if none is found.
        -: 7743:   Like INDEX except that the string searched ends where specified
        -: 7744:   instead of at the first null.  */
        -: 7745:
        -: 7746:char *
function lindex called 13838 returned 100% blocks executed 100%
    13838: 7747:lindex (s, limit, c)
        -: 7748:     register char *s, *limit;
        -: 7749:     int c;
        -: 7750:{
   125304: 7751:  while (s < limit)
branch  0 taken 115498
branch  1 taken 9806 (fallthrough)
   115498: 7752:    if (*s++ == c)
branch  0 taken 4032 (fallthrough)
branch  1 taken 111466
     4032: 7753:      return s - 1;
        -: 7754:
     9806: 7755:  return 0;
        -: 7756:}
        -: 7757:
        -: 7758:/* Return the address of the first whitespace or null in the string S.  */
        -: 7759:
        -: 7760:char *
function end_of_token called 0 returned 0% blocks executed 0%
    #####: 7761:end_of_token (s)
        -: 7762:     char *s;
        -: 7763:{
    #####: 7764:  while (*s != '\0' && !isblank (*s))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 7765:    ++s;
    #####: 7766:  return s;
        -: 7767:}
        -: 7768:
        -: 7769:#ifdef WINDOWS32
        -: 7770:/*
        -: 7771: * Same as end_of_token, but take into account a stop character
        -: 7772: */
        -: 7773:char *
        -: 7774:end_of_token_w32 (s, stopchar)
        -: 7775:     char *s;
        -: 7776:     char stopchar;
        -: 7777:{
        -: 7778:  register char *p = s;
        -: 7779:  register int backslash = 0;
        -: 7780:
        -: 7781:  while (*p != '\0' && *p != stopchar && (backslash || !isblank (*p)))
        -: 7782:    {
        -: 7783:      if (*p++ == '\\')
        -: 7784:        {
        -: 7785:          backslash = !backslash;
        -: 7786:          while (*p == '\\')
        -: 7787:            {
        -: 7788:              backslash = !backslash;
        -: 7789:              ++p;
        -: 7790:            }
        -: 7791:        }
        -: 7792:      else
        -: 7793:        backslash = 0;
        -: 7794:    }
        -: 7795:
        -: 7796:  return p;
        -: 7797:}
        -: 7798:#endif
        -: 7799:
        -: 7800:/* Return the address of the first nonwhitespace or null in the string S.  */
        -: 7801:
        -: 7802:char *
function next_token called 100239 returned 100% blocks executed 100%
   100239: 7803:next_token (s)
        -: 7804:     char *s;
        -: 7805:{
   100239: 7806:  register char *p = s;
        -: 7807:
   130522: 7808:  while (isblank (*p))
branch  0 taken 30283
branch  1 taken 100239 (fallthrough)
    30283: 7809:    ++p;
   100239: 7810:  return p;
        -: 7811:}
        -: 7812:
        -: 7813:/* Find the next token in PTR; return the address of it, and store the
        -: 7814:   length of the token into *LENGTHPTR if LENGTHPTR is not nil.  */
        -: 7815:
        -: 7816:char *
function find_next_token called 790 returned 100% blocks executed 50%
      790: 7817:find_next_token (ptr, lengthptr)
        -: 7818:     char **ptr;
        -: 7819:     unsigned int *lengthptr;
        -: 7820:{
      790: 7821:  char *p = next_token (*ptr);
call    0 returned 790
        -: 7822:  char *end;
        -: 7823:
      790: 7824:  if (*p == '\0')
branch  0 taken 790 (fallthrough)
branch  1 taken 0
      790: 7825:    return 0;
        -: 7826:
    #####: 7827:  *ptr = end = end_of_token (p);
call    0 never executed
    #####: 7828:  if (lengthptr != 0)
branch  0 never executed
branch  1 never executed
    #####: 7829:    *lengthptr = end - p;
    #####: 7830:  return p;
        -: 7831:}
        -: 7832:
        -: 7833:/* Copy a chain of `struct dep', making a new chain
        -: 7834:   with the same contents as the old one.  */
        -: 7835:
        -: 7836:struct dep *
function copy_dep_chain called 848 returned 100% blocks executed 100%
      848: 7837:copy_dep_chain (d)
        -: 7838:     register struct dep *d;
        -: 7839:{
        -: 7840:  register struct dep *c;
      848: 7841:  struct dep *firstnew = 0;
      848: 7842:  struct dep *lastnew = 0;
        -: 7843:
     1701: 7844:  while (d != 0)
branch  0 taken 853
branch  1 taken 848 (fallthrough)
        -: 7845:    {
      853: 7846:      c = (struct dep *) xmalloc (sizeof (struct dep));
call    0 returned 853
      853: 7847:      bcopy ((char *) d, (char *) c, sizeof (struct dep));
      853: 7848:      if (c->name != 0)
branch  0 taken 42 (fallthrough)
branch  1 taken 811
       42: 7849:	c->name = savestring (c->name, strlen (c->name));
call    0 returned 42
      853: 7850:      c->next = 0;
      853: 7851:      if (firstnew == 0)
branch  0 taken 848 (fallthrough)
branch  1 taken 5
      848: 7852:	firstnew = lastnew = c;
        -: 7853:      else
        5: 7854:	lastnew = lastnew->next = c;
        -: 7855:
      853: 7856:      d = d->next;
        -: 7857:    }
        -: 7858:
      848: 7859:  return firstnew;
        -: 7860:}
        -: 7861:
        -: 7862:#ifdef	iAPX286
        -: 7863:/* The losing compiler on this machine can't handle this macro.  */
        -: 7864:
        -: 7865:char *
        -: 7866:dep_name (dep)
        -: 7867:     struct dep *dep;
        -: 7868:{
        -: 7869:  return dep->name == 0 ? dep->file->name : dep->name;
        -: 7870:}
        -: 7871:#endif
        -: 7872:
        -: 7873:#ifdef	GETLOADAVG_PRIVILEGED
        -: 7874:
        -: 7875:#ifdef POSIX
        -: 7876:
        -: 7877:/* Hopefully if a system says it's POSIX.1 and has the setuid and setgid
        -: 7878:   functions, they work as POSIX.1 says.  Some systems (Alpha OSF/1 1.2,
        -: 7879:   for example) which claim to be POSIX.1 also have the BSD setreuid and
        -: 7880:   setregid functions, but they don't work as in BSD and only the POSIX.1
        -: 7881:   way works.  */
        -: 7882:
        -: 7883:#undef HAVE_SETREUID
        -: 7884:#undef HAVE_SETREGID
        -: 7885:
        -: 7886:#else	/* Not POSIX.  */
        -: 7887:
        -: 7888:/* Some POSIX.1 systems have the seteuid and setegid functions.  In a
        -: 7889:   POSIX-like system, they are the best thing to use.  However, some
        -: 7890:   non-POSIX systems have them too but they do not work in the POSIX style
        -: 7891:   and we must use setreuid and setregid instead.  */
        -: 7892:
        -: 7893:#undef HAVE_SETEUID
        -: 7894:#undef HAVE_SETEGID
        -: 7895:
        -: 7896:#endif	/* POSIX.  */
        -: 7897:
        -: 7898:#ifndef	HAVE_UNISTD_H
        -: 7899:extern int getuid (), getgid (), geteuid (), getegid ();
        -: 7900:extern int setuid (), setgid ();
        -: 7901:#ifdef HAVE_SETEUID
        -: 7902:extern int seteuid ();
        -: 7903:#else
        -: 7904:#ifdef	HAVE_SETREUID
        -: 7905:extern int setreuid ();
        -: 7906:#endif	/* Have setreuid.  */
        -: 7907:#endif	/* Have seteuid.  */
        -: 7908:#ifdef HAVE_SETEGID
        -: 7909:extern int setegid ();
        -: 7910:#else
        -: 7911:#ifdef	HAVE_SETREGID
        -: 7912:extern int setregid ();
        -: 7913:#endif	/* Have setregid.  */
        -: 7914:#endif	/* Have setegid.  */
        -: 7915:#endif	/* No <unistd.h>.  */
        -: 7916:
        -: 7917:/* Keep track of the user and group IDs for user- and make- access.  */
        -: 7918:static int user_uid = -1, user_gid = -1, make_uid = -1, make_gid = -1;
        -: 7919:#define	access_inited	(user_uid != -1)
        -: 7920:static enum { make, user } current_access;
        -: 7921:
        -: 7922:
        -: 7923:/* Under -d, write a message describing the current IDs.  */
        -: 7924:
        -: 7925:static void
        -: 7926:log_access (flavor)
        -: 7927:     char *flavor;
        -: 7928:{
        -: 7929:  if (! debug_flag)
        -: 7930:    return;
        -: 7931:
        -: 7932:  /* All the other debugging messages go to stdout,
        -: 7933:     but we write this one to stderr because it might be
        -: 7934:     run in a child fork whose stdout is piped.  */
        -: 7935:
        -: 7936:  fprintf (stderr, "%s access: user %lu (real %lu), group %lu (real %lu)\n",
        -: 7937:	   flavor, (unsigned long) geteuid (), (unsigned long) getuid (),
        -: 7938:           (unsigned long) getegid (), (unsigned long) getgid ());
        -: 7939:  fflush (stderr);
        -: 7940:}
        -: 7941:
        -: 7942:
        -: 7943:static void
        -: 7944:init_access ()
        -: 7945:{
        -: 7946:#ifndef VMS
        -: 7947:  user_uid = getuid ();
        -: 7948:  user_gid = getgid ();
        -: 7949:
        -: 7950:  make_uid = geteuid ();
        -: 7951:  make_gid = getegid ();
        -: 7952:
        -: 7953:  /* Do these ever fail?  */
        -: 7954:  if (user_uid == -1 || user_gid == -1 || make_uid == -1 || make_gid == -1)
        -: 7955:    pfatal_with_name ("get{e}[gu]id");
        -: 7956:
        -: 7957:  log_access ("Initialized");
        -: 7958:
        -: 7959:  current_access = make;
        -: 7960:#endif
        -: 7961:}
        -: 7962:
        -: 7963:#endif	/* GETLOADAVG_PRIVILEGED */
        -: 7964:
        -: 7965:/* Give the process appropriate permissions for access to
        -: 7966:   user data (i.e., to stat files, or to spawn a child process).  */
        -: 7967:void
function user_access called 793 returned 100% blocks executed 100%
      793: 7968:user_access ()
        -: 7969:{
        -: 7970:#ifdef	GETLOADAVG_PRIVILEGED
        -: 7971:
        -: 7972:  if (!access_inited)
        -: 7973:    init_access ();
        -: 7974:
        -: 7975:  if (current_access == user)
        -: 7976:    return;
        -: 7977:
        -: 7978:  /* We are in "make access" mode.  This means that the effective user and
        -: 7979:     group IDs are those of make (if it was installed setuid or setgid).
        -: 7980:     We now want to set the effective user and group IDs to the real IDs,
        -: 7981:     which are the IDs of the process that exec'd make.  */
        -: 7982:
        -: 7983:#ifdef	HAVE_SETEUID
        -: 7984:
        -: 7985:  /* Modern systems have the seteuid/setegid calls which set only the
        -: 7986:     effective IDs, which is ideal.  */
        -: 7987:
        -: 7988:  if (seteuid (user_uid) < 0)
        -: 7989:    pfatal_with_name ("user_access: seteuid");
        -: 7990:
        -: 7991:#else	/* Not HAVE_SETEUID.  */
        -: 7992:
        -: 7993:#ifndef	HAVE_SETREUID
        -: 7994:
        -: 7995:  /* System V has only the setuid/setgid calls to set user/group IDs.
        -: 7996:     There is an effective ID, which can be set by setuid/setgid.
        -: 7997:     It can be set (unless you are root) only to either what it already is
        -: 7998:     (returned by geteuid/getegid, now in make_uid/make_gid),
        -: 7999:     the real ID (return by getuid/getgid, now in user_uid/user_gid),
        -: 8000:     or the saved set ID (what the effective ID was before this set-ID
        -: 8001:     executable (make) was exec'd).  */
        -: 8002:
        -: 8003:  if (setuid (user_uid) < 0)
        -: 8004:    pfatal_with_name ("user_access: setuid");
        -: 8005:
        -: 8006:#else	/* HAVE_SETREUID.  */
        -: 8007:
        -: 8008:  /* In 4BSD, the setreuid/setregid calls set both the real and effective IDs.
        -: 8009:     They may be set to themselves or each other.  So you have two alternatives
        -: 8010:     at any one time.  If you use setuid/setgid, the effective will be set to
        -: 8011:     the real, leaving only one alternative.  Using setreuid/setregid, however,
        -: 8012:     you can toggle between your two alternatives by swapping the values in a
        -: 8013:     single setreuid or setregid call.  */
        -: 8014:
        -: 8015:  if (setreuid (make_uid, user_uid) < 0)
        -: 8016:    pfatal_with_name ("user_access: setreuid");
        -: 8017:
        -: 8018:#endif	/* Not HAVE_SETREUID.  */
        -: 8019:#endif	/* HAVE_SETEUID.  */
        -: 8020:
        -: 8021:#ifdef	HAVE_SETEGID
        -: 8022:  if (setegid (user_gid) < 0)
        -: 8023:    pfatal_with_name ("user_access: setegid");
        -: 8024:#else
        -: 8025:#ifndef	HAVE_SETREGID
        -: 8026:  if (setgid (user_gid) < 0)
        -: 8027:    pfatal_with_name ("user_access: setgid");
        -: 8028:#else
        -: 8029:  if (setregid (make_gid, user_gid) < 0)
        -: 8030:    pfatal_with_name ("user_access: setregid");
        -: 8031:#endif
        -: 8032:#endif
        -: 8033:
        -: 8034:  current_access = user;
        -: 8035:
        -: 8036:  log_access ("User");
        -: 8037:
        -: 8038:#endif	/* GETLOADAVG_PRIVILEGED */
      793: 8039:}
        -: 8040:
        -: 8041:/* Give the process appropriate permissions for access to
        -: 8042:   make data (i.e., the load average).  */
        -: 8043:void
function make_access called 0 returned 0% blocks executed 0%
    #####: 8044:make_access ()
        -: 8045:{
        -: 8046:#ifdef	GETLOADAVG_PRIVILEGED
        -: 8047:
        -: 8048:  if (!access_inited)
        -: 8049:    init_access ();
        -: 8050:
        -: 8051:  if (current_access == make)
        -: 8052:    return;
        -: 8053:
        -: 8054:  /* See comments in user_access, above.  */
        -: 8055:
        -: 8056:#ifdef	HAVE_SETEUID
        -: 8057:  if (seteuid (make_uid) < 0)
        -: 8058:    pfatal_with_name ("make_access: seteuid");
        -: 8059:#else
        -: 8060:#ifndef	HAVE_SETREUID
        -: 8061:  if (setuid (make_uid) < 0)
        -: 8062:    pfatal_with_name ("make_access: setuid");
        -: 8063:#else
        -: 8064:  if (setreuid (user_uid, make_uid) < 0)
        -: 8065:    pfatal_with_name ("make_access: setreuid");
        -: 8066:#endif
        -: 8067:#endif
        -: 8068:
        -: 8069:#ifdef	HAVE_SETEGID
        -: 8070:  if (setegid (make_gid) < 0)
        -: 8071:    pfatal_with_name ("make_access: setegid");
        -: 8072:#else
        -: 8073:#ifndef	HAVE_SETREGID
        -: 8074:  if (setgid (make_gid) < 0)
        -: 8075:    pfatal_with_name ("make_access: setgid");
        -: 8076:#else
        -: 8077:  if (setregid (user_gid, make_gid) < 0)
        -: 8078:    pfatal_with_name ("make_access: setregid");
        -: 8079:#endif
        -: 8080:#endif
        -: 8081:
        -: 8082:  current_access = make;
        -: 8083:
        -: 8084:  log_access ("Make");
        -: 8085:
        -: 8086:#endif	/* GETLOADAVG_PRIVILEGED */
    #####: 8087:}
        -: 8088:
        -: 8089:/* Give the process appropriate permissions for a child process.
        -: 8090:   This is like user_access, but you can't get back to make_access.  */
        -: 8091:void
function child_access called 3 returned 100% blocks executed 100%
        3: 8092:child_access ()
        -: 8093:{
        -: 8094:#ifdef	GETLOADAVG_PRIVILEGED
        -: 8095:
        -: 8096:  if (!access_inited)
        -: 8097:    abort ();
        -: 8098:
        -: 8099:  /* Set both the real and effective UID and GID to the user's.
        -: 8100:     They cannot be changed back to make's.  */
        -: 8101:
        -: 8102:#ifndef	HAVE_SETREUID
        -: 8103:  if (setuid (user_uid) < 0)
        -: 8104:    pfatal_with_name ("child_access: setuid");
        -: 8105:#else
        -: 8106:  if (setreuid (user_uid, user_uid) < 0)
        -: 8107:    pfatal_with_name ("child_access: setreuid");
        -: 8108:#endif
        -: 8109:
        -: 8110:#ifndef	HAVE_SETREGID
        -: 8111:  if (setgid (user_gid) < 0)
        -: 8112:    pfatal_with_name ("child_access: setgid");
        -: 8113:#else
        -: 8114:  if (setregid (user_gid, user_gid) < 0)
        -: 8115:    pfatal_with_name ("child_access: setregid");
        -: 8116:#endif
        -: 8117:
        -: 8118:  log_access ("Child");
        -: 8119:
        -: 8120:#endif	/* GETLOADAVG_PRIVILEGED */
        3: 8121:}
        -: 8122:
        -: 8123:#ifdef NEED_GET_PATH_MAX
        -: 8124:unsigned int
        -: 8125:get_path_max ()
        -: 8126:{
        -: 8127:  static unsigned int value;
        -: 8128:
        -: 8129:  if (value == 0)
        -: 8130:    {
        -: 8131:      long int x = pathconf ("/", _PC_PATH_MAX);
        -: 8132:      if (x > 0)
        -: 8133:	value = x;
        -: 8134:      else
        -: 8135:	return MAXPATHLEN;
        -: 8136:    }
        -: 8137:
        -: 8138:  return value;
        -: 8139:}
        -: 8140:#endif
        -: 8141:
        -: 8142:
        -: 8143:
        -: 8144:/*************************************************************
        -: 8145:  ============================================================
        -: 8146:  ************************************************************
        -: 8147:  ============================================================
        -: 8148:  ************************************************************
        -: 8149:                         read.c
        -: 8150:  ************************************************************
        -: 8151:  ============================================================
        -: 8152:  ************************************************************
        -: 8153:  ============================================================
        -: 8154:  *************************************************************/
        -: 8155:
        -: 8156:/* Reading and parsing of makefiles for GNU Make.
        -: 8157:Copyright (C) 1988,89,90,91,92,93,94,95,96,97 Free Software Foundation, Inc.
        -: 8158:This file is part of GNU Make.
        -: 8159:
        -: 8160:GNU Make is free software; you can redistribute it and/or modify
        -: 8161:it under the terms of the GNU General Public License as published by
        -: 8162:the Free Software Foundation; either version 2, or (at your option)
        -: 8163:any later version.
        -: 8164:
        -: 8165:GNU Make is distributed in the hope that it will be useful,
        -: 8166:but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 8167:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 8168:GNU General Public License for more details.
        -: 8169:
        -: 8170:You should have received a copy of the GNU General Public License
        -: 8171:along with GNU Make; see the file COPYING.  If not, write to
        -: 8172:the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
        -: 8173:
        -: 8174:
        -: 8175:
        -: 8176:/* This is POSIX.2, but most systems using -DPOSIX probably don't have it.  */
        -: 8177:#ifdef	HAVE_GLOB_H
        -: 8178:#include <glob.h>
        -: 8179:#undef stderr
        -: 8180:#define stderr stdout
        -: 8181:#else
        -: 8182:#include "glob.h"
        -: 8183:#undef stderr
        -: 8184:#define stderr stdout
        -: 8185:#endif
        -: 8186:
        -: 8187:#ifndef WINDOWS32
        -: 8188:#ifndef _AMIGA
        -: 8189:#ifndef VMS
        -: 8190:#include <pwd.h>
        -: 8191:#undef stderr
        -: 8192:#define stderr stdout
        -: 8193:#else
        -: 8194:struct passwd *getpwnam PARAMS ((char *name));
        -: 8195:#endif
        -: 8196:#endif
        -: 8197:#endif /* !WINDOWS32 */
        -: 8198:
        -: 8199:/* A `struct linebuffer' is a structure which holds a line of text.
        -: 8200:   `readline' reads a line from a stream into a linebuffer
        -: 8201:   and works regardless of the length of the line.  */
        -: 8202:
        -: 8203:struct linebuffer
        -: 8204:  {
        -: 8205:    /* Note:  This is the number of bytes malloc'ed for `buffer'
        -: 8206:       It does not indicate `buffer's real length.
        -: 8207:       Instead, a null char indicates end-of-string.  */
        -: 8208:    unsigned int size;
        -: 8209:    char *buffer;
        -: 8210:  };
        -: 8211:
        -: 8212:#define initbuffer(lb) (lb)->buffer = (char *) xmalloc ((lb)->size = 200)
        -: 8213:#define freebuffer(lb) free ((lb)->buffer)
        -: 8214:
        -: 8215:
        -: 8216:/* Types of "words" that can be read in a makefile.  */
        -: 8217:enum make_word_type
        -: 8218:  {
        -: 8219:     w_bogus, w_eol, w_static, w_variable, w_colon, w_dcolon, w_semicolon,
        -: 8220:     w_comment, w_varassign
        -: 8221:  };
        -: 8222:
        -: 8223:
        -: 8224:/* A `struct conditionals' contains the information describing
        -: 8225:   all the active conditionals in a makefile.
        -: 8226:
        -: 8227:   The global variable `conditionals' contains the conditionals
        -: 8228:   information for the current makefile.  It is initialized from
        -: 8229:   the static structure `toplevel_conditionals' and is later changed
        -: 8230:   to new structures for included makefiles.  */
        -: 8231:
        -: 8232:struct conditionals
        -: 8233:  {
        -: 8234:    unsigned int if_cmds;	/* Depth of conditional nesting.  */
        -: 8235:    unsigned int allocated;	/* Elts allocated in following arrays.  */
        -: 8236:    char *ignoring;		/* Are we ignoring or interepreting?  */
        -: 8237:    char *seen_else;		/* Have we already seen an `else'?  */
        -: 8238:  };
        -: 8239:
        -: 8240:static struct conditionals toplevel_conditionals;
        -: 8241:static struct conditionals *conditionals = &toplevel_conditionals;
        -: 8242:
        -: 8243:
        -: 8244:/* Default directories to search for include files in  */
        -: 8245:
        -: 8246:static char *default_include_directories[] =
        -: 8247:  {
        -: 8248:#if defined(WINDOWS32) && !defined(INCLUDEDIR)
        -: 8249:/*
        -: 8250: * This completly up to the user when they install MSVC or other packages.
        -: 8251: * This is defined as a placeholder.
        -: 8252: */
        -: 8253:#define INCLUDEDIR "."
        -: 8254:#endif
        -: 8255:    INCLUDEDIR,
        -: 8256:#ifndef _AMIGA
        -: 8257:    "/usr/gnu/include",
        -: 8258:    "/usr/local/include",
        -: 8259:    "/usr/include",
        -: 8260:#endif
        -: 8261:    0
        -: 8262:  };
        -: 8263:
        -: 8264:/* List of directories to search for include files in  */
        -: 8265:
        -: 8266:static char **include_directories_to_search;
        -: 8267:
        -: 8268:/* Maximum length of an element of the above.  */
        -: 8269:
        -: 8270:static unsigned int max_incl_len;
        -: 8271:
        -: 8272:/* The filename and pointer to line number of the
        -: 8273:   makefile currently being read in.  */
        -: 8274:
        -: 8275:char *reading_filename;
        -: 8276:unsigned int *reading_lineno_ptr;
        -: 8277:
        -: 8278:/* The chain of makefiles read by read_makefile.  */
        -: 8279:
        -: 8280:static struct dep *read_makefiles = 0;
        -: 8281:
        -: 8282:static int read_makefile PARAMS ((char *filename, int flags));
        -: 8283:static unsigned int readline PARAMS ((struct linebuffer *linebuffer, FILE *stream,
        -: 8284:			char *filename, unsigned int lineno));
        -: 8285:static unsigned int do_define PARAMS ((char *name, unsigned int namelen, enum variable_origin origin,
        -: 8286:			unsigned int lineno, FILE *infile, char *filename));
        -: 8287:static int conditional_line PARAMS ((char *line, char *filename, unsigned int lineno));
        -: 8288:static void record_files PARAMS ((struct nameseq *filenames, char *pattern, char *pattern_percent,
        -: 8289:			struct dep *deps, unsigned int cmds_started, char *commands,
        -: 8290:			unsigned int commands_idx, int two_colon, char *filename,
        -: 8291:			unsigned int lineno, int set_default));
        -: 8292:static void record_target_var PARAMS ((struct nameseq *filenames, char *defn,
        -: 8293:                        int two_colon, enum variable_origin origin,
        -: 8294:                        char *filename, unsigned int lineno));
        -: 8295:static enum make_word_type get_next_mword PARAMS ((char *buffer, char *delim,
        -: 8296:                        char **startp, unsigned int *length));
        -: 8297:
        -: 8298:/* Read in all the makefiles and return the chain of their names.  */
        -: 8299:
        -: 8300:struct dep *
function read_all_makefiles called 790 returned 100% blocks executed 58%
      790: 8301:read_all_makefiles (makefiles)
        -: 8302:     char **makefiles;
        -: 8303:{
      790: 8304:  unsigned int num_makefiles = 0;
        -: 8305:
      790: 8306:  if (debug_flag)
branch  0 taken 384 (fallthrough)
branch  1 taken 406
      384: 8307:    puts ("Reading makefiles...");
call    0 returned 384
        -: 8308:
        -: 8309:  /* If there's a non-null variable MAKEFILES, its value is a list of
        -: 8310:     files to read first thing.  But don't let it prevent reading the
        -: 8311:     default makefiles and don't let the default goal come from there.  */
        -: 8312:
        -: 8313:  {
        -: 8314:    char *value;
        -: 8315:    char *name, *p;
        -: 8316:    unsigned int length;
        -: 8317:
        -: 8318:    {
        -: 8319:      /* Turn off --warn-undefined-variables while we expand MAKEFILES.  */
      790: 8320:      int save = warn_undefined_variables_flag;
      790: 8321:      warn_undefined_variables_flag = 0;
        -: 8322:
      790: 8323:      value = allocated_variable_expand ("$(MAKEFILES)");
call    0 returned 790
        -: 8324:
      790: 8325:      warn_undefined_variables_flag = save;
        -: 8326:    }
        -: 8327:
        -: 8328:    /* Set NAME to the start of next token and LENGTH to its length.
        -: 8329:       MAKEFILES is updated for finding remaining tokens.  */
      790: 8330:    p = value;
        -: 8331:
      790: 8332:    while ((name = find_next_token (&p, &length)) != 0)
call    0 returned 790
branch  1 taken 0
branch  2 taken 790 (fallthrough)
        -: 8333:      {
    #####: 8334:	if (*p != '\0')
branch  0 never executed
branch  1 never executed
    #####: 8335:	  *p++ = '\0';
    #####: 8336:	(void) read_makefile (name,
call    0 never executed
        -: 8337:			      RM_NO_DEFAULT_GOAL | RM_INCLUDED | RM_DONTCARE);
        -: 8338:      }
        -: 8339:
      790: 8340:    free (value);
        -: 8341:  }
        -: 8342:
        -: 8343:  /* Read makefiles specified with -f switches.  */
        -: 8344:
      790: 8345:  if (makefiles != 0)
branch  0 taken 772 (fallthrough)
branch  1 taken 18
     1544: 8346:    while (*makefiles != 0)
branch  0 taken 772
branch  1 taken 772 (fallthrough)
        -: 8347:      {
      772: 8348:	struct dep *tail = read_makefiles;
        -: 8349:	register struct dep *d;
        -: 8350:
      772: 8351:	if (! read_makefile (*makefiles, 0))
call    0 returned 772
branch  1 taken 771 (fallthrough)
branch  2 taken 1
      771: 8352:	  perror_with_name ("", *makefiles);
call    0 returned 771
        -: 8353:
        -: 8354:	/* Find the right element of read_makefiles.  */
      772: 8355:	d = read_makefiles;
      772: 8356:	while (d->next != tail)
branch  0 taken 0
branch  1 taken 772 (fallthrough)
    #####: 8357:	  d = d->next;
        -: 8358:
        -: 8359:	/* Use the storage read_makefile allocates.  */
     772*: 8360:	*makefiles = dep_name (d);
branch  0 taken 772 (fallthrough)
branch  1 taken 0
      772: 8361:	++num_makefiles;
      772: 8362:	++makefiles;
        -: 8363:      }
        -: 8364:
        -: 8365:  /* If there were no -f switches, try the default names.  */
        -: 8366:
      790: 8367:  if (num_makefiles == 0)
branch  0 taken 18 (fallthrough)
branch  1 taken 772
        -: 8368:    {
        -: 8369:      static char *default_makefiles[] =
        -: 8370:#ifdef VMS
        -: 8371:	/* all lower case since readdir() (the vms version) 'lowercasifies' */
        -: 8372:	{ "makefile.vms", "gnumakefile.", "makefile.", 0 };
        -: 8373:#else
        -: 8374:#ifdef _AMIGA
        -: 8375:	{ "GNUmakefile", "Makefile", "SMakefile", 0 };
        -: 8376:#else /* !Amiga && !VMS */
        -: 8377:	{ "GNUmakefile", "makefile", "Makefile", 0 };
        -: 8378:#endif /* AMIGA */
        -: 8379:#endif /* VMS */
       18: 8380:      register char **p = default_makefiles;
       54: 8381:      while (*p != 0 && !file_exists_p (*p))
branch  0 taken 54 (fallthrough)
branch  1 taken 0
call    2 returned 54
branch  3 taken 36
branch  4 taken 18 (fallthrough)
       36: 8382:	++p;
        -: 8383:
       18: 8384:      if (*p != 0)
branch  0 taken 18 (fallthrough)
branch  1 taken 0
        -: 8385:	{
       18: 8386:	  if (! read_makefile (*p, 0))
call    0 returned 18
branch  1 taken 0 (fallthrough)
branch  2 taken 18
    #####: 8387:	    perror_with_name ("", *p);
call    0 never executed
        -: 8388:	}
        -: 8389:      else
        -: 8390:	{
        -: 8391:	  /* No default makefile was found.  Add the default makefiles to the
        -: 8392:	     `read_makefiles' chain so they will be updated if possible.  */
    #####: 8393:	  struct dep *tail = read_makefiles;
        -: 8394:	  /* Add them to the tail, after any MAKEFILES variable makefiles.  */
    #####: 8395:	  while (tail != 0 && tail->next != 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 8396:	    tail = tail->next;
    #####: 8397:	  for (p = default_makefiles; *p != 0; ++p)
branch  0 never executed
branch  1 never executed
        -: 8398:	    {
    #####: 8399:	      struct dep *d = (struct dep *) xmalloc (sizeof (struct dep));
call    0 never executed
    #####: 8400:	      d->name = 0;
    #####: 8401:	      d->file = enter_file (*p);
call    0 never executed
    #####: 8402:	      d->file->dontcare = 1;
        -: 8403:	      /* Tell update_goal_chain to bail out as soon as this file is
        -: 8404:		 made, and main not to die if we can't make this file.  */
    #####: 8405:	      d->changed = RM_DONTCARE;
    #####: 8406:	      if (tail == 0)
branch  0 never executed
branch  1 never executed
    #####: 8407:		read_makefiles = d;
        -: 8408:	      else
    #####: 8409:		tail->next = d;
    #####: 8410:	      tail = d;
        -: 8411:	    }
    #####: 8412:	  if (tail != 0)
branch  0 never executed
branch  1 never executed
    #####: 8413:	    tail->next = 0;
        -: 8414:	}
        -: 8415:    }
        -: 8416:
      790: 8417:  return read_makefiles;
        -: 8418:}
        -: 8419:
        -: 8420:/* Read file FILENAME as a makefile and add its contents to the data base.
        -: 8421:
        -: 8422:   FLAGS contains bits as above.
        -: 8423:
        -: 8424:   FILENAME is added to the `read_makefiles' chain.
        -: 8425:
        -: 8426:   Returns 1 if a file was found and read, 0 if not.  */
        -: 8427:
        -: 8428:static int
function read_makefile called 795 returned 100% blocks executed 56%
      795: 8429:read_makefile (filename, flags)
        -: 8430:     char *filename;
        -: 8431:     int flags;
        -: 8432:{
        -: 8433:  static char *collapsed = 0;
        -: 8434:  static unsigned int collapsed_length = 0;
        -: 8435:  register FILE *infile;
        -: 8436:  struct linebuffer lb;
      795: 8437:  unsigned int commands_len = 200;
      795: 8438:  char *commands = (char *) xmalloc (200);
call    0 returned 795
      795: 8439:  unsigned int commands_idx = 0;
        -: 8440:  unsigned int cmds_started;
        -: 8441:  char *p;
        -: 8442:  char *p2;
        -: 8443:  int len, reading_target;
      795: 8444:  int ignoring = 0, in_ignored_define = 0;
      795: 8445:  int no_targets = 0;		/* Set when reading a rule without targets.  */
      795: 8446:  char *passed_filename = filename;
        -: 8447:
      795: 8448:  struct nameseq *filenames = 0;
        -: 8449:  struct dep *deps;
      795: 8450:  unsigned int lineno = 1;
      795: 8451:  unsigned int nlines = 0;
      795: 8452:  int two_colon = 0;
      795: 8453:  char *pattern = 0, *pattern_percent;
        -: 8454:
        -: 8455:  int makefile_errno;
        -: 8456:#if defined (WINDOWS32) || defined (__MSDOS__)
        -: 8457:  int check_again;
        -: 8458:#endif
        -: 8459:
        -: 8460:#define record_waiting_files()						      \
        -: 8461:  do									      \
        -: 8462:    { 									      \
        -: 8463:      if (filenames != 0)						      \
        -: 8464:	record_files (filenames, pattern, pattern_percent, deps,	      \
        -: 8465:		      cmds_started, commands, commands_idx,		      \
        -: 8466:		      two_colon, filename, lineno,			      \
        -: 8467:		      !(flags & RM_NO_DEFAULT_GOAL));		     	      \
        -: 8468:      filenames = 0;							      \
        -: 8469:      commands_idx = 0;							      \
        -: 8470:      if (pattern) { free(pattern); pattern = 0; }                            \
        -: 8471:    } while (0)
        -: 8472:
      795: 8473:  pattern_percent = 0;
      795: 8474:  cmds_started = lineno;
        -: 8475:
      795: 8476:  if (debug_flag)
branch  0 taken 384 (fallthrough)
branch  1 taken 411
        -: 8477:    {
      384: 8478:      printf ("Reading makefile `%s'", filename);
call    0 returned 384
      384: 8479:      if (flags & RM_NO_DEFAULT_GOAL)
branch  0 taken 0 (fallthrough)
branch  1 taken 384
    #####: 8480:	printf (" (no default goal)");
call    0 never executed
      384: 8481:      if (flags & RM_INCLUDED)
branch  0 taken 0 (fallthrough)
branch  1 taken 384
    #####: 8482:	printf (" (search path)");
call    0 never executed
      384: 8483:      if (flags & RM_DONTCARE)
branch  0 taken 0 (fallthrough)
branch  1 taken 384
    #####: 8484:	printf (" (don't care)");
call    0 never executed
      384: 8485:      if (flags & RM_NO_TILDE)
branch  0 taken 0 (fallthrough)
branch  1 taken 384
    #####: 8486:	printf (" (no ~ expansion)");
call    0 never executed
      384: 8487:      puts ("...");
call    0 returned 384
        -: 8488:    }
        -: 8489:
        -: 8490:  /* First, get a stream to read.  */
        -: 8491:
        -: 8492:  /* Expand ~ in FILENAME unless it came from `include',
        -: 8493:     in which case it was already done.  */
      795: 8494:  if (!(flags & RM_NO_TILDE) && filename[0] == '~')
branch  0 taken 790 (fallthrough)
branch  1 taken 5
branch  2 taken 0 (fallthrough)
branch  3 taken 790
        -: 8495:    {
    #####: 8496:      char *expanded = tilde_expand (filename);
call    0 never executed
    #####: 8497:      if (expanded != 0)
branch  0 never executed
branch  1 never executed
    #####: 8498:	filename = expanded;
        -: 8499:    }
        -: 8500:
      795: 8501:  infile = fopen (filename, "r");
call    0 returned 795
        -: 8502:  /* Save the error code so we print the right message later.  */
      795: 8503:  makefile_errno = errno;
        -: 8504:
        -: 8505:  /* If the makefile wasn't found and it's either a makefile from
        -: 8506:     the `MAKEFILES' variable or an included makefile,
        -: 8507:     search the included makefile search path for this makefile.  */
      795: 8508:  if (infile == 0 && (flags & RM_INCLUDED) && *filename != '/')
branch  0 taken 776 (fallthrough)
branch  1 taken 19
branch  2 taken 5 (fallthrough)
branch  3 taken 771
branch  4 taken 5 (fallthrough)
branch  5 taken 0
        -: 8509:    {
        -: 8510:      register unsigned int i;
       11: 8511:      for (i = 0; include_directories_to_search[i] != 0; ++i)
branch  0 taken 9
branch  1 taken 2 (fallthrough)
        -: 8512:	{
        9: 8513:	  char *name = concat (include_directories_to_search[i], "/", filename);
call    0 returned 9
        9: 8514:	  infile = fopen (name, "r");
call    0 returned 9
        9: 8515:	  if (infile == 0)
branch  0 taken 6 (fallthrough)
branch  1 taken 3
        6: 8516:	    free (name);
        -: 8517:	  else
        -: 8518:	    {
        3: 8519:	      filename = name;
        3: 8520:	      break;
        -: 8521:	    }
        -: 8522:	}
        -: 8523:    }
        -: 8524:
        -: 8525:  /* Add FILENAME to the chain of read makefiles.  */
      795: 8526:  deps = (struct dep *) xmalloc (sizeof (struct dep));
call    0 returned 795
      795: 8527:  deps->next = read_makefiles;
      795: 8528:  read_makefiles = deps;
      795: 8529:  deps->name = 0;
      795: 8530:  deps->file = lookup_file (filename);
call    0 returned 795
      795: 8531:  if (deps->file == 0)
branch  0 taken 795 (fallthrough)
branch  1 taken 0
        -: 8532:    {
      795: 8533:      deps->file = enter_file (savestring (filename, strlen (filename)));
call    0 returned 795
call    1 returned 795
      795: 8534:      if (flags & RM_DONTCARE)
branch  0 taken 0 (fallthrough)
branch  1 taken 795
    #####: 8535:	deps->file->dontcare = 1;
        -: 8536:    }
      795: 8537:  if (filename != passed_filename)
branch  0 taken 3 (fallthrough)
branch  1 taken 792
        3: 8538:    free (filename);
      795: 8539:  filename = deps->file->name;
      795: 8540:  deps->changed = flags;
      795: 8541:  deps = 0;
        -: 8542:
        -: 8543:  /* If the makefile can't be found at all, give up entirely.  */
        -: 8544:
      795: 8545:  if (infile == 0)
branch  0 taken 773 (fallthrough)
branch  1 taken 22
        -: 8546:    {
        -: 8547:      /* If we did some searching, errno has the error from the last
        -: 8548:	 attempt, rather from FILENAME itself.  Restore it in case the
        -: 8549:	 caller wants to use it in a message.  */
      773: 8550:      errno = makefile_errno;
      773: 8551:      return 0;
        -: 8552:    }
        -: 8553:
       22: 8554:  reading_filename = filename;
       22: 8555:  reading_lineno_ptr = &lineno;
        -: 8556:
        -: 8557:  /* Loop over lines in the file.
        -: 8558:     The strategy is to accumulate target names in FILENAMES, dependencies
        -: 8559:     in DEPS and commands in COMMANDS.  These are used to define a rule
        -: 8560:     when the start of the next rule (or eof) is encountered.  */
        -: 8561:
       22: 8562:  initbuffer (&lb);
call    0 returned 22
        -: 8563:
     2595: 8564:  while (!feof (infile))
call    0 returned 2595
branch  1 taken 2573
branch  2 taken 22 (fallthrough)
        -: 8565:    {
     2573: 8566:      lineno += nlines;
     2573: 8567:      nlines = readline (&lb, infile, filename, lineno);
call    0 returned 2573
        -: 8568:
        -: 8569:      /* Check for a shell command line first.
        -: 8570:	 If it is not one, we can stop treating tab specially.  */
     2573: 8571:      if (lb.buffer[0] == '\t')
branch  0 taken 483 (fallthrough)
branch  1 taken 2090
        -: 8572:	{
        -: 8573:	  /* This line is a probably shell command.  */
        -: 8574:	  unsigned int len;
        -: 8575:
     483*: 8576:	  if (no_targets)
branch  0 taken 0 (fallthrough)
branch  1 taken 483
        -: 8577:	    /* Ignore the commands in a rule with no targets.  */
    #####: 8578:	    continue;
        -: 8579:
        -: 8580:	  /* If there is no preceding rule line, don't treat this line
        -: 8581:	     as a command, even though it begins with a tab character.
        -: 8582:	     SunOS 4 make appears to behave this way.  */
        -: 8583:
      483: 8584:	  if (filenames != 0)
branch  0 taken 483 (fallthrough)
branch  1 taken 0
        -: 8585:	    {
     483*: 8586:	      if (ignoring)
branch  0 taken 0 (fallthrough)
branch  1 taken 483
        -: 8587:		/* Yep, this is a shell command, and we don't care.  */
    #####: 8588:		continue;
        -: 8589:
        -: 8590:	      /* Append this command line to the line being accumulated.  */
      483: 8591:	      p = lb.buffer;
      483: 8592:	      if (commands_idx == 0)
branch  0 taken 294 (fallthrough)
branch  1 taken 189
      294: 8593:		cmds_started = lineno;
      483: 8594:	      len = strlen (p);
      483: 8595:	      if (len + 1 + commands_idx > commands_len)
branch  0 taken 21 (fallthrough)
branch  1 taken 462
        -: 8596:		{
       21: 8597:		  commands_len = (len + 1 + commands_idx) * 2;
       21: 8598:		  commands = (char *) xrealloc (commands, commands_len);
call    0 returned 21
        -: 8599:		}
      483: 8600:	      bcopy (p, &commands[commands_idx], len);
      483: 8601:	      commands_idx += len;
      483: 8602:	      commands[commands_idx++] = '\n';
        -: 8603:
      483: 8604:	      continue;
        -: 8605:	    }
        -: 8606:	}
        -: 8607:
        -: 8608:      /* This line is not a shell command line.  Don't worry about tabs.  */
        -: 8609:
     2090: 8610:      if (collapsed_length < lb.size)
branch  0 taken 37 (fallthrough)
branch  1 taken 2053
        -: 8611:	{
       37: 8612:	  collapsed_length = lb.size;
       37: 8613:	  if (collapsed != 0)
branch  0 taken 18 (fallthrough)
branch  1 taken 19
       18: 8614:	    free (collapsed);
       37: 8615:	  collapsed = (char *) xmalloc (collapsed_length);
call    0 returned 37
        -: 8616:	}
     2090: 8617:      strcpy (collapsed, lb.buffer);
        -: 8618:      /* Collapse continuation lines.  */
     2090: 8619:      collapse_continuations (collapsed);
call    0 returned 2090
     2090: 8620:      remove_comments (collapsed);
call    0 returned 2090
        -: 8621:
        -: 8622:      /* Compare a word, both length and contents. */
        -: 8623:#define	word1eq(s, l) 	(len == l && !strncmp (s, p, l))
     2090: 8624:      p = collapsed;
     2090: 8625:      while (isspace (*p))
branch  0 taken 0
branch  1 taken 2090 (fallthrough)
    #####: 8626:	++p;
     2090: 8627:      if (*p == '\0')
branch  0 taken 1098 (fallthrough)
branch  1 taken 992
        -: 8628:	/* This line is completely empty.  */
     1098: 8629:	continue;
        -: 8630:
        -: 8631:      /* Find the end of the first token.  Note we don't need to worry about
        -: 8632:       * ":" here since we compare tokens by length (so "export" will never
        -: 8633:       * be equal to "export:").
        -: 8634:       */
     7238: 8635:      for (p2 = p+1; *p2 != '\0' && !isspace(*p2); ++p2)
branch  0 taken 7154 (fallthrough)
branch  1 taken 84
branch  2 taken 6246
branch  3 taken 908 (fallthrough)
        -: 8636:        {}
      992: 8637:      len = p2 - p;
        -: 8638:
        -: 8639:      /* Find the start of the second token.  If it's a `:' remember it,
        -: 8640:         since it can't be a preprocessor token--this allows targets named
        -: 8641:         `ifdef', `export', etc. */
      992: 8642:      reading_target = 0;
     1900: 8643:      while (isspace (*p2))
branch  0 taken 908
branch  1 taken 992 (fallthrough)
      908: 8644:        ++p2;
      992: 8645:      if (*p2 == '\0')
branch  0 taken 84 (fallthrough)
branch  1 taken 908
       84: 8646:        p2 = NULL;
     908*: 8647:      else if (p2[0] == ':' && p2[1] == '\0')
branch  0 taken 0 (fallthrough)
branch  1 taken 908
branch  2 never executed
branch  3 never executed
        -: 8648:        {
    #####: 8649:          reading_target = 1;
    #####: 8650:          goto skip_conditionals;
        -: 8651:        }
        -: 8652:
        -: 8653:      /* We must first check for conditional and `define' directives before
        -: 8654:	 ignoring anything, since they control what we will do with
        -: 8655:	 following lines.  */
        -: 8656:
      992: 8657:      if (!in_ignored_define
branch  0 taken 992 (fallthrough)
branch  1 taken 0
      992: 8658:	  && (word1eq ("ifdef", 5) || word1eq ("ifndef", 6)
branch  0 taken 126 (fallthrough)
branch  1 taken 866
branch  2 taken 126 (fallthrough)
branch  3 taken 0
branch  4 taken 147 (fallthrough)
branch  5 taken 845
branch  6 taken 147 (fallthrough)
branch  7 taken 0
      992: 8659:	      || word1eq ("ifeq", 4) || word1eq ("ifneq", 5)
branch  0 taken 147 (fallthrough)
branch  1 taken 845
branch  2 taken 147 (fallthrough)
branch  3 taken 0
branch  4 taken 126 (fallthrough)
branch  5 taken 866
branch  6 taken 126 (fallthrough)
branch  7 taken 0
      992: 8660:	      || word1eq ("else", 4) || word1eq ("endif", 5)))
branch  0 taken 147 (fallthrough)
branch  1 taken 845
branch  2 taken 147 (fallthrough)
branch  3 taken 0
branch  4 taken 126 (fallthrough)
branch  5 taken 866
branch  6 taken 0 (fallthrough)
branch  7 taken 126
    #####: 8661:	{
    #####: 8662:	  int i = conditional_line (p, filename, lineno);
call    0 never executed
    #####: 8663:	  if (i >= 0)
branch  0 never executed
branch  1 never executed
    #####: 8664:	    ignoring = i;
        -: 8665:	  else
    #####: 8666:	    makefile_fatal (filename, lineno,
call    0 never executed
        -: 8667:			    "invalid syntax in conditional");
    #####: 8668:	  continue;
        -: 8669:	}
        -: 8670:
     992*: 8671:      if (word1eq ("endef", 5))
branch  0 taken 126 (fallthrough)
branch  1 taken 866
branch  2 taken 0 (fallthrough)
branch  3 taken 126
        -: 8672:	{
    #####: 8673:	  if (in_ignored_define)
branch  0 never executed
branch  1 never executed
    #####: 8674:	    in_ignored_define = 0;
        -: 8675:	  else
    #####: 8676:	    makefile_fatal (filename, lineno, "extraneous `endef'");
call    0 never executed
    #####: 8677:	  continue;
        -: 8678:	}
        -: 8679:
     992*: 8680:      if (word1eq ("define", 6))
branch  0 taken 147 (fallthrough)
branch  1 taken 845
branch  2 taken 0 (fallthrough)
branch  3 taken 147
        -: 8681:	{
    #####: 8682:	  if (ignoring)
branch  0 never executed
branch  1 never executed
    #####: 8683:	    in_ignored_define = 1;
        -: 8684:	  else
        -: 8685:	    {
    #####: 8686:	      p2 = next_token (p + 6);
call    0 never executed
        -: 8687:	      /* Let the variable name be the whole rest of the line,
        -: 8688:		 with trailing blanks stripped (comments have already been
        -: 8689:		 removed), so it could be a complex variable/function
        -: 8690:		 reference that might contain blanks.  */
    #####: 8691:	      p = index (p2, '\0');
    #####: 8692:	      while (isblank (p[-1]))
branch  0 never executed
branch  1 never executed
    #####: 8693:		--p;
    #####: 8694:	      lineno = do_define (p2, p - p2, o_file,
call    0 never executed
        -: 8695:				  lineno, infile, filename);
        -: 8696:	    }
    #####: 8697:	  continue;
        -: 8698:	}
        -: 8699:
     992*: 8700:      if (word1eq ("override", 8))
branch  0 taken 63 (fallthrough)
branch  1 taken 929
branch  2 taken 63 (fallthrough)
branch  3 taken 0
        -: 8701:        {
    #####: 8702:	  p2 = next_token (p + 8);
call    0 never executed
    #####: 8703:	  if (p2 == 0)
branch  0 never executed
branch  1 never executed
    #####: 8704:	    makefile_error (filename, lineno, "empty `override' directive");
call    0 never executed
    #####: 8705:	  if (!strncmp (p2, "define", 6) && (isblank (p2[6]) || p2[6] == '\0'))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 8706:	    {
    #####: 8707:	      if (ignoring)
branch  0 never executed
branch  1 never executed
    #####: 8708:		in_ignored_define = 1;
        -: 8709:	      else
        -: 8710:		{
    #####: 8711:		  p2 = next_token (p2 + 6);
call    0 never executed
        -: 8712:		  /* Let the variable name be the whole rest of the line,
        -: 8713:		     with trailing blanks stripped (comments have already been
        -: 8714:		     removed), so it could be a complex variable/function
        -: 8715:		     reference that might contain blanks.  */
    #####: 8716:		  p = index (p2, '\0');
    #####: 8717:		  while (isblank (p[-1]))
branch  0 never executed
branch  1 never executed
    #####: 8718:		    --p;
    #####: 8719:		  lineno = do_define (p2, p - p2, o_override,
call    0 never executed
        -: 8720:				      lineno, infile, filename);
        -: 8721:		}
        -: 8722:	    }
    #####: 8723:	  else if (!ignoring
branch  0 never executed
branch  1 never executed
    #####: 8724:		   && !try_variable_definition (filename, lineno,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 8725:						p2, o_override))
    #####: 8726:	    makefile_error (filename, lineno, "empty `override' directive");
call    0 never executed
        -: 8727:
    #####: 8728:	  continue;
        -: 8729:	}
      992: 8730: skip_conditionals:
        -: 8731:
     992*: 8732:      if (ignoring)
branch  0 taken 0 (fallthrough)
branch  1 taken 992
        -: 8733:	/* Ignore the line.  We continue here so conditionals
        -: 8734:	   can appear in the middle of a rule.  */
    #####: 8735:	continue;
        -: 8736:
      992: 8737:      if (!reading_target && word1eq ("export", 6))
branch  0 taken 992 (fallthrough)
branch  1 taken 0
branch  2 taken 147 (fallthrough)
branch  3 taken 845
branch  4 taken 0 (fallthrough)
branch  5 taken 147
    #####: 8738:	{
        -: 8739:	  struct variable *v;
    #####: 8740:	  p2 = next_token (p + 6);
call    0 never executed
    #####: 8741:	  if (*p2 == '\0')
branch  0 never executed
branch  1 never executed
    #####: 8742:	    export_all_variables = 1;
    #####: 8743:	  v = try_variable_definition (filename, lineno, p2, o_file);
call    0 never executed
    #####: 8744:	  if (v != 0)
branch  0 never executed
branch  1 never executed
    #####: 8745:	    v->export = v_export;
        -: 8746:	  else
        -: 8747:	    {
        -: 8748:	      unsigned int len;
    #####: 8749:	      for (p = find_next_token (&p2, &len); p != 0;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 8750:		   p = find_next_token (&p2, &len))
        -: 8751:		{
    #####: 8752:		  v = lookup_variable (p, len);
call    0 never executed
    #####: 8753:		  if (v == 0)
branch  0 never executed
branch  1 never executed
    #####: 8754:		    v = define_variable (p, len, "", o_file, 0);
call    0 never executed
    #####: 8755:		  v->export = v_export;
call    0 never executed
        -: 8756:		}
        -: 8757:	    }
        -: 8758:	}
      992: 8759:      else if (!reading_target && word1eq ("unexport", 8))
branch  0 taken 992 (fallthrough)
branch  1 taken 0
branch  2 taken 63 (fallthrough)
branch  3 taken 929
branch  4 taken 0 (fallthrough)
branch  5 taken 63
    #####: 8760:	{
        -: 8761:	  unsigned int len;
        -: 8762:	  struct variable *v;
    #####: 8763:	  p2 = next_token (p + 8);
call    0 never executed
    #####: 8764:	  if (*p2 == '\0')
branch  0 never executed
branch  1 never executed
    #####: 8765:	    export_all_variables = 0;
    #####: 8766:	  for (p = find_next_token (&p2, &len); p != 0;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 8767:	       p = find_next_token (&p2, &len))
        -: 8768:	    {
    #####: 8769:	      v = lookup_variable (p, len);
call    0 never executed
    #####: 8770:	      if (v == 0)
branch  0 never executed
branch  1 never executed
    #####: 8771:		v = define_variable (p, len, "", o_file, 0);
call    0 never executed
    #####: 8772:	      v->export = v_noexport;
call    0 never executed
        -: 8773:	    }
        -: 8774:	}
      992: 8775:      else if (word1eq ("vpath", 5))
branch  0 taken 126 (fallthrough)
branch  1 taken 866
branch  2 taken 0 (fallthrough)
branch  3 taken 126
    #####: 8776:	{
        -: 8777:	  char *pattern;
        -: 8778:	  unsigned int len;
    #####: 8779:	  p2 = variable_expand (p + 5);
call    0 never executed
    #####: 8780:	  p = find_next_token (&p2, &len);
call    0 never executed
    #####: 8781:	  if (p != 0)
branch  0 never executed
branch  1 never executed
        -: 8782:	    {
    #####: 8783:	      pattern = savestring (p, len);
call    0 never executed
    #####: 8784:	      p = find_next_token (&p2, &len);
call    0 never executed
        -: 8785:	      /* No searchpath means remove all previous
        -: 8786:		 selective VPATH's with the same pattern.  */
        -: 8787:	    }
        -: 8788:	  else
        -: 8789:	    /* No pattern means remove all previous selective VPATH's.  */
    #####: 8790:	    pattern = 0;
    #####: 8791:	  construct_vpath_list (pattern, p);
call    0 never executed
    #####: 8792:	  if (pattern != 0)
branch  0 never executed
branch  1 never executed
    #####: 8793:	    free (pattern);
        -: 8794:	}
      992: 8795:      else if (word1eq ("include", 7) || word1eq ("-include", 8)
branch  0 taken 194 (fallthrough)
branch  1 taken 798
branch  2 taken 189 (fallthrough)
branch  3 taken 5
branch  4 taken 63 (fallthrough)
branch  5 taken 924
branch  6 taken 63 (fallthrough)
branch  7 taken 0
      987: 8796:	       || word1eq ("sinclude", 8))
branch  0 taken 63 (fallthrough)
branch  1 taken 924
branch  2 taken 0 (fallthrough)
branch  3 taken 63
        5: 8797:	{
        -: 8798:	  /* We have found an `include' line specifying a nested
        -: 8799:	     makefile to be read at this point.  */
        -: 8800:	  struct conditionals *save, new_conditionals;
        -: 8801:	  struct nameseq *files;
        -: 8802:	  /* "-include" (vs "include") says no error if the file does not
        -: 8803:	     exist.  "sinclude" is an alias for this from SGI.  */
        5: 8804:	  int noerror = p[0] != 'i';
        -: 8805:
       5*: 8806:	  p = allocated_variable_expand (next_token (p + (noerror ? 8 : 7)));
branch  0 taken 0 (fallthrough)
branch  1 taken 5
call    2 returned 5
call    3 returned 5
       5*: 8807:	  if (*p == '\0')
branch  0 taken 0 (fallthrough)
branch  1 taken 5
        -: 8808:	    {
    #####: 8809:	      makefile_error (filename, lineno,
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 8810:			      "no file name for `%sinclude'",
        -: 8811:			      noerror ? "-" : "");
    #####: 8812:	      continue;
        -: 8813:	    }
        -: 8814:
        -: 8815:	  /* Parse the list of file names.  */
        5: 8816:	  p2 = p;
        5: 8817:	  files = multi_glob (parse_file_seq (&p2, '\0',
call    0 returned 5
call    1 returned 5
        -: 8818:					      sizeof (struct nameseq),
        -: 8819:					      1),
        -: 8820:			      sizeof (struct nameseq));
        5: 8821:	  free (p);
        -: 8822:
        -: 8823:	  /* Save the state of conditionals and start
        -: 8824:	     the included makefile with a clean slate.  */
        5: 8825:	  save = conditionals;
        5: 8826:	  bzero ((char *) &new_conditionals, sizeof new_conditionals);
        5: 8827:	  conditionals = &new_conditionals;
        -: 8828:
        -: 8829:	  /* Record the rules that are waiting so they will determine
        -: 8830:	     the default goal before those in the included makefile.  */
       5*: 8831:	  record_waiting_files ();
branch  0 taken 0 (fallthrough)
branch  1 taken 5
call    2 never executed
branch  3 taken 0 (fallthrough)
branch  4 taken 5
        -: 8832:
        -: 8833:	  /* Read each included makefile.  */
       10: 8834:	  while (files != 0)
branch  0 taken 5
branch  1 taken 5 (fallthrough)
        -: 8835:	    {
        5: 8836:	      struct nameseq *next = files->next;
        5: 8837:	      char *name = files->name;
        5: 8838:	      free ((char *)files);
        5: 8839:	      files = next;
        -: 8840:
       5*: 8841:	      if (! read_makefile (name, (RM_INCLUDED | RM_NO_TILDE
branch  0 taken 0 (fallthrough)
branch  1 taken 5
call    2 returned 5
branch  3 taken 2 (fallthrough)
branch  4 taken 3
        -: 8842:					  | (noerror ? RM_DONTCARE : 0)))
        2: 8843:		  && ! noerror)
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2: 8844:		makefile_error (filename, lineno,
call    0 returned 2
        2: 8845:				"%s: %s", name, strerror (errno));
call    0 returned 2
        5: 8846:              free(name);
        -: 8847:	    }
        -: 8848:
        -: 8849:	  /* Free any space allocated by conditional_line.  */
        5: 8850:	  if (conditionals->ignoring)
branch  0 taken 0 (fallthrough)
branch  1 taken 5
    #####: 8851:	    free (conditionals->ignoring);
        5: 8852:	  if (conditionals->seen_else)
branch  0 taken 0 (fallthrough)
branch  1 taken 5
    #####: 8853:	    free (conditionals->seen_else);
        -: 8854:
        -: 8855:	  /* Restore state.  */
        5: 8856:	  conditionals = save;
        5: 8857:	  reading_filename = filename;
        5: 8858:	  reading_lineno_ptr = &lineno;
        -: 8859:	}
        -: 8860:#undef	word1eq
      987: 8861:      else if (try_variable_definition (filename, lineno, p, o_file))
call    0 returned 987
branch  1 taken 525 (fallthrough)
branch  2 taken 462
        -: 8862:	/* This line has been dealt with.  */
        -: 8863:	;
      525: 8864:      else if (lb.buffer[0] == '\t')
branch  0 taken 0 (fallthrough)
branch  1 taken 525
        -: 8865:	{
    #####: 8866:	  p = collapsed;	/* Ignore comments.  */
    #####: 8867:	  while (isblank (*p))
branch  0 never executed
branch  1 never executed
    #####: 8868:	    ++p;
    #####: 8869:	  if (*p == '\0')
branch  0 never executed
branch  1 never executed
        -: 8870:	    /* The line is completely blank; that is harmless.  */
    #####: 8871:	    continue;
        -: 8872:	  /* This line starts with a tab but was not caught above
        -: 8873:	     because there was no preceding target, and the line
        -: 8874:	     might have been usable as a variable definition.
        -: 8875:	     But now it is definitely lossage.  */
    #####: 8876:	  makefile_fatal (filename, lineno,
call    0 never executed
        -: 8877:			  "commands commence before first target");
        -: 8878:	}
        -: 8879:      else
      525: 8880:	{
        -: 8881:	  /* This line describes some target files.  This is complicated by
        -: 8882:             the existence of target-specific variables, because we can't
        -: 8883:             expand the entire line until we know if we have one or not.  So
        -: 8884:             we expand the line word by word until we find the first `:',
        -: 8885:             then check to see if it's a target-specific variable.
        -: 8886:
        -: 8887:             In this algorithm, `lb_next' will point to the beginning of the
        -: 8888:             unexpanded parts of the input buffer, while `p2' points to the
        -: 8889:             parts of the expanded buffer we haven't searched yet. */
        -: 8890:
        -: 8891:          enum make_word_type wtype;
        -: 8892:          enum variable_origin v_origin;
        -: 8893:          char *cmdleft, *lb_next;
      525: 8894:          unsigned int len, plen = 0;
        -: 8895:
        -: 8896:	  /* Record the previous rule.  */
        -: 8897:
     525*: 8898:	  record_waiting_files ();
branch  0 taken 504 (fallthrough)
branch  1 taken 21
call    2 returned 504
branch  3 taken 0 (fallthrough)
branch  4 taken 525
        -: 8899:
        -: 8900:	  /* Search the line for an unquoted ; that is not after an
        -: 8901:             unquoted #.  */
      525: 8902:	  cmdleft = find_char_unquote (lb.buffer, ";#", 0);
call    0 returned 525
     525*: 8903:	  if (cmdleft != 0 && *cmdleft == '#')
branch  0 taken 0 (fallthrough)
branch  1 taken 525
branch  2 never executed
branch  3 never executed
        -: 8904:	    {
        -: 8905:	      /* We found a comment before a semicolon.  */
    #####: 8906:	      *cmdleft = '\0';
    #####: 8907:	      cmdleft = 0;
        -: 8908:	    }
      525: 8909:	  else if (cmdleft != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 525
        -: 8910:	    /* Found one.  Cut the line short there before expanding it.  */
    #####: 8911:	    *(cmdleft++) = '\0';
        -: 8912:
      525: 8913:	  collapse_continuations (lb.buffer);
call    0 returned 525
        -: 8914:
        -: 8915:	  /* We can't expand the entire line, since if it's a per-target
        -: 8916:             variable we don't want to expand it.  So, walk from the
        -: 8917:             beginning, expanding as we go, and looking for "interesting"
        -: 8918:             chars.  The first word is always expandable.  */
      525: 8919:          wtype = get_next_mword(lb.buffer, NULL, &lb_next, &len);
call    0 returned 525
     525*: 8920:          switch (wtype)
branch  0 taken 0
branch  1 taken 0
branch  2 taken 525
        -: 8921:            {
    #####: 8922:            case w_eol:
    #####: 8923:              if (cmdleft != 0)
branch  0 never executed
branch  1 never executed
    #####: 8924:                makefile_fatal (filename, lineno,
call    0 never executed
        -: 8925:                                "missing rule before commands");
        -: 8926:              else
        -: 8927:                /* This line contained a variable reference that
        -: 8928:                   expanded to nothing but whitespace.  */
    #####: 8929:                continue;
        -: 8930:
    #####: 8931:            case w_colon:
        -: 8932:            case w_dcolon:
        -: 8933:              /* We accept and ignore rules without targets for
        -: 8934:                 compatibility with SunOS 4 make.  */
    #####: 8935:              no_targets = 1;
    #####: 8936:              continue;
        -: 8937:
      525: 8938:            default:
      525: 8939:              break;
        -: 8940:            }
        -: 8941:
      525: 8942:          p2 = variable_expand_string(NULL, lb_next, len);
call    0 returned 525
        -: 8943:          while (1)
      567: 8944:            {
        -: 8945:              char *colonp;
        -: 8946:
     1092: 8947:              lb_next += len;
     1092: 8948:              if (cmdleft == 0)
branch  0 taken 1092 (fallthrough)
branch  1 taken 0
        -: 8949:                {
        -: 8950:                  /* Look for a semicolon in the expanded line.  */
     1092: 8951:                  cmdleft = find_char_unquote (p2, ";", 0);
call    0 returned 1092
        -: 8952:
     1092: 8953:                  if (cmdleft != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 1092
        -: 8954:                    {
    #####: 8955:                      unsigned long p2_off = p2 - variable_buffer;
    #####: 8956:                      unsigned long cmd_off = cmdleft - variable_buffer;
    #####: 8957:                      char *pend = p2 + strlen(p2);
        -: 8958:
        -: 8959:                      /* Append any remnants of lb, then cut the line short
        -: 8960:                         at the semicolon.  */
    #####: 8961:                      *cmdleft = '\0';
        -: 8962:
        -: 8963:                      /* One school of thought says that you shouldn't expand
        -: 8964:                         here, but merely copy, since now you're beyond a ";"
        -: 8965:                         and into a command script.  However, the old parser
        -: 8966:                         expanded the whole line, so we continue that for
        -: 8967:                         backwards-compatiblity.  Also, it wouldn't be
        -: 8968:                         entirely consistent, since we do an unconditional
        -: 8969:                         expand below once we know we don't have a
        -: 8970:                         target-specific variable. */
    #####: 8971:                      (void)variable_expand_string(pend, lb_next, -1);
call    0 never executed
    #####: 8972:                      lb_next += strlen(lb_next);
    #####: 8973:                      p2 = variable_buffer + p2_off;
    #####: 8974:                      cmdleft = variable_buffer + cmd_off + 1;
        -: 8975:                    }
        -: 8976:                }
        -: 8977:
     1092: 8978:              colonp = find_char_unquote(p2, ":", 0);
call    0 returned 1092
        -: 8979:#if defined(__MSDOS__) || defined(WINDOWS32)
        -: 8980:	      /* The drive spec brain-damage strikes again...  */
        -: 8981:	      /* FIXME: is whitespace the only possible separator of words
        -: 8982:		 in this context?  If not, the `isspace' test below will
        -: 8983:		 need to be changed into a call to `index'.  */
        -: 8984:	      while (colonp && (colonp[1] == '/' || colonp[1] == '\\') &&
        -: 8985:		     colonp > p2 && isalpha(colonp[-1]) &&
        -: 8986:		     (colonp == p2 + 1 || isspace(colonp[-2])))
        -: 8987:		colonp = find_char_unquote(colonp + 1, ":", 0);
        -: 8988:#endif
     1092: 8989:              if (colonp != 0)
branch  0 taken 525 (fallthrough)
branch  1 taken 567
      525: 8990:                break;
        -: 8991:
      567: 8992:              wtype = get_next_mword(lb_next, NULL, &lb_next, &len);
call    0 returned 567
      567: 8993:              if (wtype == w_eol)
branch  0 taken 0 (fallthrough)
branch  1 taken 567
    #####: 8994:                makefile_fatal (filename, lineno, "missing separator");
call    0 never executed
        -: 8995:
      567: 8996:              p2 += strlen(p2);
      567: 8997:              *(p2++) = ' ';
      567: 8998:              p2 = variable_expand_string(p2, lb_next, len);
call    0 returned 567
        -: 8999:              /* We don't need to worry about cmdleft here, because if it was
        -: 9000:                 found in the variable_buffer the entire buffer has already
        -: 9001:                 been expanded... we'll never get here.  */
        -: 9002:            }
        -: 9003:
      525: 9004:	  p2 = next_token (variable_buffer);
call    0 returned 525
        -: 9005:
      525: 9006:	  filenames = multi_glob (parse_file_seq (&p2, ':',
call    0 returned 525
call    1 returned 525
        -: 9007:						  sizeof (struct nameseq),
        -: 9008:						  1),
        -: 9009:				  sizeof (struct nameseq));
        -: 9010:
     525*: 9011:          if (!filenames)
branch  0 taken 0 (fallthrough)
branch  1 taken 525
        -: 9012:            {
        -: 9013:              /* We accept and ignore rules without targets for
        -: 9014:                 compatibility with SunOS 4 make.  */
    #####: 9015:              no_targets = 1;
    #####: 9016:              continue;
        -: 9017:            }
        -: 9018:          /* This should never be possible; we handled it above.  */
     525*: 9019:	  assert(*p2 != '\0');
branch  0 taken 0 (fallthrough)
branch  1 taken 525
call    2 never executed
      525: 9020:          ++p2;
        -: 9021:
        -: 9022:	  /* Is this a one-colon or two-colon entry?  */
      525: 9023:	  two_colon = *p2 == ':';
      525: 9024:	  if (two_colon)
branch  0 taken 0 (fallthrough)
branch  1 taken 525
    #####: 9025:	    p2++;
        -: 9026:
        -: 9027:          /* Test to see if it's a target-specific variable.  Copy the rest
        -: 9028:             of the buffer over, possibly temporarily (we'll expand it later
        -: 9029:             if it's not a target-specific variable).  PLEN saves the length
        -: 9030:             of the unparsed section of p2, for later.  */
      525: 9031:          if (*lb_next != '\0')
branch  0 taken 441 (fallthrough)
branch  1 taken 84
        -: 9032:            {
      441: 9033:              unsigned int l = p2 - variable_buffer;
      441: 9034:              plen = strlen(p2);
      441: 9035:              (void)variable_buffer_output(p2+plen,
      441: 9036:                                           lb_next, strlen(lb_next)+1);
call    0 returned 441
      441: 9037:              p2 = variable_buffer + l;
        -: 9038:            }
      525: 9039:          wtype = get_next_mword(p2, NULL, &p, &len);
call    0 returned 525
      525: 9040:          v_origin = o_file;
      525: 9041:          if (wtype == w_static && (len == (sizeof("override")-1)
branch  0 taken 378 (fallthrough)
branch  1 taken 147
branch  2 taken 21 (fallthrough)
branch  3 taken 357
       21: 9042:                                    && !strncmp(p, "override", len)))
branch  0 taken 0 (fallthrough)
branch  1 taken 21
        -: 9043:            {
    #####: 9044:              v_origin = o_override;
    #####: 9045:              (void)get_next_mword(p+len, NULL, &p, &len);
call    0 never executed
        -: 9046:            }
      525: 9047:          else if (wtype != w_eol)
branch  0 taken 441 (fallthrough)
branch  1 taken 84
      441: 9048:            wtype = get_next_mword(p+len, NULL, NULL, NULL);
call    0 returned 441
        -: 9049:
     525*: 9050:          if (wtype == w_varassign || v_origin == o_override)
branch  0 taken 525 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 525
        -: 9051:            {
    #####: 9052:              record_target_var(filenames, p, two_colon, v_origin,
call    0 never executed
        -: 9053:                                filename, lineno);
    #####: 9054:              filenames = 0;
    #####: 9055:              continue;
        -: 9056:            }
        -: 9057:
        -: 9058:          /* This is a normal target, _not_ a target-specific variable.
        -: 9059:             Unquote any = in the dependency list.  */
      525: 9060:          find_char_unquote (lb_next, "=", 0);
call    0 returned 525
        -: 9061:
        -: 9062:	  /* We have some targets, so don't ignore the following commands.  */
      525: 9063:	  no_targets = 0;
        -: 9064:
        -: 9065:          /* Expand the dependencies, etc.  */
      525: 9066:          if (*lb_next != '\0')
branch  0 taken 441 (fallthrough)
branch  1 taken 84
        -: 9067:            {
      441: 9068:              unsigned int l = p2 - variable_buffer;
      441: 9069:              (void)variable_expand_string(p2 + plen, lb_next, -1);
call    0 returned 441
      441: 9070:              p2 = variable_buffer + l;
        -: 9071:
        -: 9072:              /* Look for a semicolon in the expanded line.  */
      441: 9073:              if (cmdleft == 0)
branch  0 taken 441 (fallthrough)
branch  1 taken 0
        -: 9074:                {
      441: 9075:                  cmdleft = find_char_unquote (p2, ";", 0);
call    0 returned 441
      441: 9076:                  if (cmdleft != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 441
    #####: 9077:                    *(cmdleft++) = '\0';
        -: 9078:                }
        -: 9079:            }
        -: 9080:
        -: 9081:	  /* Is this a static pattern rule: `target: %targ: %dep; ...'?  */
      525: 9082:	  p = index (p2, ':');
     525*: 9083:	  while (p != 0 && p[-1] == '\\')
branch  0 taken 0 (fallthrough)
branch  1 taken 525
branch  2 never executed
branch  3 never executed
        -: 9084:	    {
    #####: 9085:	      register char *q = &p[-1];
    #####: 9086:	      register int backslash = 0;
    #####: 9087:	      while (*q-- == '\\')
branch  0 never executed
branch  1 never executed
    #####: 9088:		backslash = !backslash;
    #####: 9089:	      if (backslash)
branch  0 never executed
branch  1 never executed
    #####: 9090:		p = index (p + 1, ':');
        -: 9091:	      else
    #####: 9092:		break;
        -: 9093:	    }
        -: 9094:#ifdef _AMIGA
        -: 9095:	  /* Here, the situation is quite complicated. Let's have a look
        -: 9096:	    at a couple of targets:
        -: 9097:
        -: 9098:		install: dev:make
        -: 9099:
        -: 9100:		dev:make: make
        -: 9101:
        -: 9102:		dev:make:: xyz
        -: 9103:
        -: 9104:	    The rule is that it's only a target, if there are TWO :'s
        -: 9105:	    OR a space around the :.
        -: 9106:	  */
        -: 9107:	  if (p && !(isspace(p[1]) || !p[1] || isspace(p[-1])))
        -: 9108:	    p = 0;
        -: 9109:#endif
        -: 9110:#if defined (WINDOWS32) || defined (__MSDOS__)
        -: 9111:          do {
        -: 9112:            check_again = 0;
        -: 9113:            /* For MSDOS and WINDOWS32, skip a "C:\..." or a "C:/..." */
        -: 9114:            if (p != 0 && (p[1] == '\\' || p[1] == '/') &&
        -: 9115:		isalpha(p[-1]) && (p == p2 + 1 || index(" \t:", p[-2]) != 0)) {
        -: 9116:              p = index(p + 1, ':');
        -: 9117:              check_again = 1;
        -: 9118:            }
        -: 9119:          } while (check_again);
        -: 9120:#endif
      525: 9121:	  if (p != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 525
        -: 9122:	    {
        -: 9123:	      struct nameseq *target;
    #####: 9124:	      target = parse_file_seq (&p2, ':', sizeof (struct nameseq), 1);
call    0 never executed
    #####: 9125:	      ++p2;
    #####: 9126:	      if (target == 0)
branch  0 never executed
branch  1 never executed
    #####: 9127:		makefile_fatal (filename, lineno, "missing target pattern");
call    0 never executed
    #####: 9128:	      else if (target->next != 0)
branch  0 never executed
branch  1 never executed
    #####: 9129:		makefile_fatal (filename, lineno, "multiple target patterns");
call    0 never executed
    #####: 9130:	      pattern = target->name;
    #####: 9131:	      pattern_percent = find_percent (pattern);
call    0 never executed
    #####: 9132:	      if (pattern_percent == 0)
branch  0 never executed
branch  1 never executed
    #####: 9133:		makefile_fatal (filename, lineno,
call    0 never executed
        -: 9134:				"target pattern contains no `%%'");
    #####: 9135:              free((char *)target);
        -: 9136:	    }
        -: 9137:	  else
      525: 9138:	    pattern = 0;
        -: 9139:
        -: 9140:	  /* Parse the dependencies.  */
        -: 9141:	  deps = (struct dep *)
      525: 9142:	    multi_glob (parse_file_seq (&p2, '\0', sizeof (struct dep), 1),
call    0 returned 525
call    1 returned 525
        -: 9143:			sizeof (struct dep));
        -: 9144:
      525: 9145:	  commands_idx = 0;
      525: 9146:	  if (cmdleft != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 525
        -: 9147:	    {
        -: 9148:	      /* Semicolon means rest of line is a command.  */
    #####: 9149:	      unsigned int len = strlen (cmdleft);
        -: 9150:
    #####: 9151:	      cmds_started = lineno;
        -: 9152:
        -: 9153:	      /* Add this command line to the buffer.  */
    #####: 9154:	      if (len + 2 > commands_len)
branch  0 never executed
branch  1 never executed
        -: 9155:		{
    #####: 9156:		  commands_len = (len + 2) * 2;
    #####: 9157:		  commands = (char *) xrealloc (commands, commands_len);
call    0 never executed
        -: 9158:		}
    #####: 9159:	      bcopy (cmdleft, commands, len);
    #####: 9160:	      commands_idx += len;
    #####: 9161:	      commands[commands_idx++] = '\n';
        -: 9162:	    }
        -: 9163:
      525: 9164:	  continue;
        -: 9165:	}
        -: 9166:
        -: 9167:      /* We get here except in the case that we just read a rule line.
        -: 9168:	 Record now the last rule we read, so following spurious
        -: 9169:	 commands are properly diagnosed.  */
     467*: 9170:      record_waiting_files ();
branch  0 taken 0 (fallthrough)
branch  1 taken 467
call    2 never executed
branch  3 taken 0 (fallthrough)
branch  4 taken 467
      467: 9171:      no_targets = 0;
        -: 9172:    }
        -: 9173:
       22: 9174:  if (conditionals->if_cmds)
branch  0 taken 0 (fallthrough)
branch  1 taken 22
    #####: 9175:    makefile_fatal (filename, lineno, "missing `endif'");
call    0 never executed
        -: 9176:
        -: 9177:  /* At eof, record the last rule.  */
      22*: 9178:  record_waiting_files ();
branch  0 taken 21 (fallthrough)
branch  1 taken 1
call    2 returned 21
branch  3 taken 0 (fallthrough)
branch  4 taken 22
        -: 9179:
       22: 9180:  freebuffer (&lb);
       22: 9181:  free ((char *) commands);
       22: 9182:  fclose (infile);
call    0 returned 22
        -: 9183:
       22: 9184:  reading_filename = 0;
       22: 9185:  reading_lineno_ptr = 0;
        -: 9186:
       22: 9187:  return 1;
        -: 9188:}
        -: 9189:
        -: 9190:/* Execute a `define' directive.
        -: 9191:   The first line has already been read, and NAME is the name of
        -: 9192:   the variable to be defined.  The following lines remain to be read.
        -: 9193:   LINENO, INFILE and FILENAME refer to the makefile being read.
        -: 9194:   The value returned is LINENO, updated for lines read here.  */
        -: 9195:
        -: 9196:static unsigned int
function do_define called 0 returned 0% blocks executed 0%
    #####: 9197:do_define (name, namelen, origin, lineno, infile, filename)
        -: 9198:     char *name;
        -: 9199:     unsigned int namelen;
        -: 9200:     enum variable_origin origin;
        -: 9201:     unsigned int lineno;
        -: 9202:     FILE *infile;
        -: 9203:     char *filename;
        -: 9204:{
        -: 9205:  struct linebuffer lb;
    #####: 9206:  unsigned int nlines = 0;
    #####: 9207:  unsigned int length = 100;
    #####: 9208:  char *definition = (char *) xmalloc (100);
call    0 never executed
    #####: 9209:  register unsigned int idx = 0;
        -: 9210:  register char *p;
        -: 9211:
        -: 9212:  /* Expand the variable name.  */
    #####: 9213:  char *var = (char *) alloca (namelen + 1);
    #####: 9214:  bcopy (name, var, namelen);
    #####: 9215:  var[namelen] = '\0';
    #####: 9216:  var = variable_expand (var);
call    0 never executed
        -: 9217:
    #####: 9218:  initbuffer (&lb);
call    0 never executed
    #####: 9219:  while (!feof (infile))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 9220:    {
        -: 9221:      unsigned int len;
        -: 9222:
    #####: 9223:      lineno += nlines;
    #####: 9224:      nlines = readline (&lb, infile, filename, lineno);
call    0 never executed
        -: 9225:
    #####: 9226:      collapse_continuations (lb.buffer);
call    0 never executed
        -: 9227:
    #####: 9228:      p = next_token (lb.buffer);
call    0 never executed
    #####: 9229:      len = strlen (p);
    #####: 9230:      if ((len == 5 || (len > 5 && isblank (p[5])))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 9231:          && !strncmp (p, "endef", 5))
branch  0 never executed
branch  1 never executed
        -: 9232:	{
    #####: 9233:	  p += 5;
    #####: 9234:	  remove_comments (p);
call    0 never executed
    #####: 9235:	  if (*next_token (p) != '\0')
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 9236:	    makefile_error (filename, lineno,
call    0 never executed
        -: 9237:			    "Extraneous text after `endef' directive");
        -: 9238:	  /* Define the variable.  */
    #####: 9239:	  if (idx == 0)
branch  0 never executed
branch  1 never executed
    #####: 9240:	    definition[0] = '\0';
        -: 9241:	  else
    #####: 9242:	    definition[idx - 1] = '\0';
    #####: 9243:	  (void) define_variable (var, strlen (var), definition, origin, 1);
call    0 never executed
    #####: 9244:	  free (definition);
    #####: 9245:	  freebuffer (&lb);
    #####: 9246:	  return (lineno + nlines);
        -: 9247:	}
        -: 9248:      else
        -: 9249:	{
    #####: 9250:          len = strlen (lb.buffer);
        -: 9251:	  /* Increase the buffer size if necessary.  */
    #####: 9252:	  if (idx + len + 1 > length)
branch  0 never executed
branch  1 never executed
        -: 9253:	    {
    #####: 9254:	      length = (idx + len) * 2;
    #####: 9255:	      definition = (char *) xrealloc (definition, length + 1);
call    0 never executed
        -: 9256:	    }
        -: 9257:
    #####: 9258:	  bcopy (lb.buffer, &definition[idx], len);
    #####: 9259:	  idx += len;
        -: 9260:	  /* Separate lines with a newline.  */
    #####: 9261:	  definition[idx++] = '\n';
        -: 9262:	}
        -: 9263:    }
        -: 9264:
        -: 9265:  /* No `endef'!!  */
    #####: 9266:  makefile_fatal (filename, lineno, "missing `endef', unterminated `define'");
call    0 never executed
        -: 9267:
        -: 9268:  /* NOTREACHED */
        -: 9269:  return 0;
        -: 9270:}
        -: 9271:
        -: 9272:/* Interpret conditional commands "ifdef", "ifndef", "ifeq",
        -: 9273:   "ifneq", "else" and "endif".
        -: 9274:   LINE is the input line, with the command as its first word.
        -: 9275:
        -: 9276:   FILENAME and LINENO are the filename and line number in the
        -: 9277:   current makefile.  They are used for error messages.
        -: 9278:
        -: 9279:   Value is -1 if the line is invalid,
        -: 9280:   0 if following text should be interpreted,
        -: 9281:   1 if following text should be ignored.  */
        -: 9282:
        -: 9283:static int
function conditional_line called 0 returned 0% blocks executed 0%
    #####: 9284:conditional_line (line, filename, lineno)
        -: 9285:     char *line;
        -: 9286:     char *filename;
        -: 9287:     unsigned int lineno;
        -: 9288:{
        -: 9289:  int notdef;
        -: 9290:  char *cmdname;
        -: 9291:  register unsigned int i;
        -: 9292:
    #####: 9293:  if (*line == 'i')
branch  0 never executed
branch  1 never executed
        -: 9294:    {
        -: 9295:      /* It's an "if..." command.  */
    #####: 9296:      notdef = line[2] == 'n';
    #####: 9297:      if (notdef)
branch  0 never executed
branch  1 never executed
        -: 9298:	{
    #####: 9299:	  cmdname = line[3] == 'd' ? "ifndef" : "ifneq";
branch  0 never executed
branch  1 never executed
    #####: 9300:	  line += cmdname[3] == 'd' ? 7 : 6;
branch  0 never executed
branch  1 never executed
        -: 9301:	}
        -: 9302:      else
        -: 9303:	{
    #####: 9304:	  cmdname = line[2] == 'd' ? "ifdef" : "ifeq";
branch  0 never executed
branch  1 never executed
    #####: 9305:	  line += cmdname[2] == 'd' ? 6 : 5;
branch  0 never executed
branch  1 never executed
        -: 9306:	}
        -: 9307:    }
        -: 9308:  else
        -: 9309:    {
        -: 9310:      /* It's an "else" or "endif" command.  */
    #####: 9311:      notdef = line[1] == 'n';
    #####: 9312:      cmdname = notdef ? "endif" : "else";
branch  0 never executed
branch  1 never executed
    #####: 9313:      line += notdef ? 5 : 4;
branch  0 never executed
branch  1 never executed
        -: 9314:    }
        -: 9315:
    #####: 9316:  line = next_token (line);
call    0 never executed
        -: 9317:
    #####: 9318:  if (*cmdname == 'e')
branch  0 never executed
branch  1 never executed
        -: 9319:    {
    #####: 9320:      if (*line != '\0')
branch  0 never executed
branch  1 never executed
    #####: 9321:	makefile_error (filename, lineno,
call    0 never executed
        -: 9322:			"Extraneous text after `%s' directive",
        -: 9323:			cmdname);
        -: 9324:      /* "Else" or "endif".  */
    #####: 9325:      if (conditionals->if_cmds == 0)
branch  0 never executed
branch  1 never executed
    #####: 9326:	makefile_fatal (filename, lineno, "extraneous `%s'", cmdname);
call    0 never executed
        -: 9327:      /* NOTDEF indicates an `endif' command.  */
    #####: 9328:      if (notdef)
branch  0 never executed
branch  1 never executed
    #####: 9329:	--conditionals->if_cmds;
    #####: 9330:      else if (conditionals->seen_else[conditionals->if_cmds - 1])
branch  0 never executed
branch  1 never executed
    #####: 9331:	makefile_fatal (filename, lineno, "only one `else' per conditional");
call    0 never executed
        -: 9332:      else
        -: 9333:	{
        -: 9334:	  /* Toggle the state of ignorance.  */
    #####: 9335:	  conditionals->ignoring[conditionals->if_cmds - 1]
    #####: 9336:	    = !conditionals->ignoring[conditionals->if_cmds - 1];
        -: 9337:	  /* Record that we have seen an `else' in this conditional.
        -: 9338:	     A second `else' will be erroneous.  */
    #####: 9339:	  conditionals->seen_else[conditionals->if_cmds - 1] = 1;
        -: 9340:	}
    #####: 9341:      for (i = 0; i < conditionals->if_cmds; ++i)
branch  0 never executed
branch  1 never executed
    #####: 9342:	if (conditionals->ignoring[i])
branch  0 never executed
branch  1 never executed
    #####: 9343:	  return 1;
    #####: 9344:      return 0;
        -: 9345:    }
        -: 9346:
    #####: 9347:  if (conditionals->allocated == 0)
branch  0 never executed
branch  1 never executed
        -: 9348:    {
    #####: 9349:      conditionals->allocated = 5;
    #####: 9350:      conditionals->ignoring = (char *) xmalloc (conditionals->allocated);
call    0 never executed
    #####: 9351:      conditionals->seen_else = (char *) xmalloc (conditionals->allocated);
call    0 never executed
        -: 9352:    }
        -: 9353:
    #####: 9354:  ++conditionals->if_cmds;
    #####: 9355:  if (conditionals->if_cmds > conditionals->allocated)
branch  0 never executed
branch  1 never executed
        -: 9356:    {
    #####: 9357:      conditionals->allocated += 5;
    #####: 9358:      conditionals->ignoring = (char *)
    #####: 9359:	xrealloc (conditionals->ignoring, conditionals->allocated);
call    0 never executed
    #####: 9360:      conditionals->seen_else = (char *)
    #####: 9361:	xrealloc (conditionals->seen_else, conditionals->allocated);
call    0 never executed
        -: 9362:    }
        -: 9363:
        -: 9364:  /* Record that we have seen an `if...' but no `else' so far.  */
    #####: 9365:  conditionals->seen_else[conditionals->if_cmds - 1] = 0;
        -: 9366:
        -: 9367:  /* Search through the stack to see if we're already ignoring.  */
    #####: 9368:  for (i = 0; i < conditionals->if_cmds - 1; ++i)
branch  0 never executed
branch  1 never executed
    #####: 9369:    if (conditionals->ignoring[i])
branch  0 never executed
branch  1 never executed
        -: 9370:      {
        -: 9371:	/* We are already ignoring, so just push a level
        -: 9372:	   to match the next "else" or "endif", and keep ignoring.
        -: 9373:	   We don't want to expand variables in the condition.  */
    #####: 9374:	conditionals->ignoring[conditionals->if_cmds - 1] = 1;
    #####: 9375:	return 1;
        -: 9376:      }
        -: 9377:
    #####: 9378:  if (cmdname[notdef ? 3 : 2] == 'd')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 9379:    {
        -: 9380:      /* "Ifdef" or "ifndef".  */
        -: 9381:      struct variable *v;
    #####: 9382:      register char *p = end_of_token (line);
call    0 never executed
    #####: 9383:      i = p - line;
    #####: 9384:      p = next_token (p);
call    0 never executed
    #####: 9385:      if (*p != '\0')
branch  0 never executed
branch  1 never executed
    #####: 9386:	return -1;
    #####: 9387:      v = lookup_variable (line, i);
call    0 never executed
    #####: 9388:      conditionals->ignoring[conditionals->if_cmds - 1]
    #####: 9389:	= (v != 0 && *v->value != '\0') == notdef;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 9390:    }
        -: 9391:  else
        -: 9392:    {
        -: 9393:      /* "Ifeq" or "ifneq".  */
        -: 9394:      char *s1, *s2;
        -: 9395:      unsigned int len;
    #####: 9396:      char termin = *line == '(' ? ',' : *line;
branch  0 never executed
branch  1 never executed
        -: 9397:
    #####: 9398:      if (termin != ',' && termin != '"' && termin != '\'')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 9399:	return -1;
        -: 9400:
    #####: 9401:      s1 = ++line;
        -: 9402:      /* Find the end of the first string.  */
    #####: 9403:      if (termin == ',')
branch  0 never executed
branch  1 never executed
        -: 9404:	{
    #####: 9405:	  register int count = 0;
    #####: 9406:	  for (; *line != '\0'; ++line)
branch  0 never executed
branch  1 never executed
    #####: 9407:	    if (*line == '(')
branch  0 never executed
branch  1 never executed
    #####: 9408:	      ++count;
    #####: 9409:	    else if (*line == ')')
branch  0 never executed
branch  1 never executed
    #####: 9410:	      --count;
    #####: 9411:	    else if (*line == ',' && count <= 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 9412:	      break;
        -: 9413:	}
        -: 9414:      else
    #####: 9415:	while (*line != '\0' && *line != termin)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 9416:	  ++line;
        -: 9417:
    #####: 9418:      if (*line == '\0')
branch  0 never executed
branch  1 never executed
    #####: 9419:	return -1;
        -: 9420:
    #####: 9421:      if (termin == ',')
branch  0 never executed
branch  1 never executed
        -: 9422:	{
        -: 9423:	  /* Strip blanks after the first string.  */
    #####: 9424:	  char *p = line++;
    #####: 9425:	  while (isblank (p[-1]))
branch  0 never executed
branch  1 never executed
    #####: 9426:	    --p;
    #####: 9427:	  *p = '\0';
        -: 9428:	}
        -: 9429:      else
    #####: 9430:	*line++ = '\0';
        -: 9431:
    #####: 9432:      s2 = variable_expand (s1);
call    0 never executed
        -: 9433:      /* We must allocate a new copy of the expanded string because
        -: 9434:	 variable_expand re-uses the same buffer.  */
    #####: 9435:      len = strlen (s2);
    #####: 9436:      s1 = (char *) alloca (len + 1);
    #####: 9437:      bcopy (s2, s1, len + 1);
        -: 9438:
    #####: 9439:      if (termin != ',')
branch  0 never executed
branch  1 never executed
        -: 9440:	/* Find the start of the second string.  */
    #####: 9441:	line = next_token (line);
call    0 never executed
        -: 9442:
    #####: 9443:      termin = termin == ',' ? ')' : *line;
branch  0 never executed
branch  1 never executed
    #####: 9444:      if (termin != ')' && termin != '"' && termin != '\'')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 9445:	return -1;
        -: 9446:
        -: 9447:      /* Find the end of the second string.  */
    #####: 9448:      if (termin == ')')
branch  0 never executed
branch  1 never executed
        -: 9449:	{
    #####: 9450:	  register int count = 0;
    #####: 9451:	  s2 = next_token (line);
call    0 never executed
    #####: 9452:	  for (line = s2; *line != '\0'; ++line)
branch  0 never executed
branch  1 never executed
        -: 9453:	    {
    #####: 9454:	      if (*line == '(')
branch  0 never executed
branch  1 never executed
    #####: 9455:		++count;
    #####: 9456:	      else if (*line == ')')
branch  0 never executed
branch  1 never executed
    #####: 9457:		if (count <= 0)
branch  0 never executed
branch  1 never executed
    #####: 9458:		  break;
        -: 9459:		else
    #####: 9460:		  --count;
        -: 9461:	    }
        -: 9462:	}
        -: 9463:      else
        -: 9464:	{
    #####: 9465:	  ++line;
    #####: 9466:	  s2 = line;
    #####: 9467:	  while (*line != '\0' && *line != termin)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 9468:	    ++line;
        -: 9469:	}
        -: 9470:
    #####: 9471:      if (*line == '\0')
branch  0 never executed
branch  1 never executed
    #####: 9472:	return -1;
        -: 9473:
    #####: 9474:      *line = '\0';
    #####: 9475:      line = next_token (++line);
call    0 never executed
    #####: 9476:      if (*line != '\0')
branch  0 never executed
branch  1 never executed
    #####: 9477:	makefile_error (filename, lineno,
call    0 never executed
        -: 9478:			"Extraneous text after `%s' directive",
        -: 9479:			cmdname);
        -: 9480:
    #####: 9481:      s2 = variable_expand (s2);
call    0 never executed
    #####: 9482:      conditionals->ignoring[conditionals->if_cmds - 1]
    #####: 9483:	= streq (s1, s2) == notdef;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -: 9484:    }
        -: 9485:
        -: 9486:  /* Search through the stack to see if we're ignoring.  */
    #####: 9487:  for (i = 0; i < conditionals->if_cmds; ++i)
branch  0 never executed
branch  1 never executed
    #####: 9488:    if (conditionals->ignoring[i])
branch  0 never executed
branch  1 never executed
    #####: 9489:      return 1;
    #####: 9490:  return 0;
        -: 9491:}
        -: 9492:
        -: 9493:/* Remove duplicate dependencies in CHAIN.  */
        -: 9494:
        -: 9495:void
function uniquize_deps called 4 returned 100% blocks executed 66%
        4: 9496:uniquize_deps (chain)
        -: 9497:     struct dep *chain;
        -: 9498:{
        -: 9499:  register struct dep *d;
        -: 9500:
        -: 9501:  /* Make sure that no dependencies are repeated.  This does not
        -: 9502:     really matter for the purpose of updating targets, but it
        -: 9503:     might make some names be listed twice for $^ and $?.  */
        -: 9504:
       16: 9505:  for (d = chain; d != 0; d = d->next)
branch  0 taken 12
branch  1 taken 4 (fallthrough)
        -: 9506:    {
        -: 9507:      struct dep *last, *next;
        -: 9508:
       12: 9509:      last = d;
       12: 9510:      next = d->next;
       26: 9511:      while (next != 0)
branch  0 taken 14
branch  1 taken 12 (fallthrough)
      14*: 9512:	if (streq (dep_name (d), dep_name (next)))
branch  0 taken 14 (fallthrough)
branch  1 taken 0
branch  2 taken 14 (fallthrough)
branch  3 taken 0
branch  4 taken 14 (fallthrough)
branch  5 taken 0
branch  6 taken 14 (fallthrough)
branch  7 taken 0
branch  8 taken 14 (fallthrough)
branch  9 taken 0
branch 10 taken 2 (fallthrough)
branch 11 taken 12
branch 12 taken 2 (fallthrough)
branch 13 taken 0
branch 14 taken 2 (fallthrough)
branch 15 taken 0
branch 16 taken 2 (fallthrough)
branch 17 taken 0
branch 18 taken 2 (fallthrough)
branch 19 taken 0
branch 20 taken 0 (fallthrough)
branch 21 taken 2
    #####: 9513:	  {
    #####: 9514:	    struct dep *n = next->next;
    #####: 9515:	    last->next = n;
    #####: 9516:	    if (next->name != 0 && next->name != d->name)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 9517:	      free (next->name);
    #####: 9518:	    if (next != d)
branch  0 never executed
branch  1 never executed
    #####: 9519:	      free ((char *) next);
    #####: 9520:	    next = n;
        -: 9521:	  }
        -: 9522:	else
        -: 9523:	  {
       14: 9524:	    last = next;
       14: 9525:	    next = next->next;
        -: 9526:	  }
        -: 9527:    }
        4: 9528:}
        -: 9529:
        -: 9530:/* Record target-specific variable values for files FILENAMES.
        -: 9531:   TWO_COLON is nonzero if a double colon was used.
        -: 9532:
        -: 9533:   The links of FILENAMES are freed, and so are any names in it
        -: 9534:   that are not incorporated into other data structures.
        -: 9535:
        -: 9536:   If the target is a pattern, add the variable to the pattern-specific
        -: 9537:   variable value list.  */
        -: 9538:
        -: 9539:static void
function record_target_var called 0 returned 0% blocks executed 0%
    #####: 9540:record_target_var (filenames, defn, two_colon, origin, filename, lineno)
        -: 9541:     struct nameseq *filenames;
        -: 9542:     char *defn;
        -: 9543:     int two_colon;
        -: 9544:     enum variable_origin origin;
        -: 9545:     char *filename;
        -: 9546:     unsigned int lineno;
        -: 9547:{
        -: 9548:  struct nameseq *nextf;
        -: 9549:  struct variable_set_list *global;
        -: 9550:
    #####: 9551:  global = current_variable_set_list;
        -: 9552:
    #####: 9553:  for (; filenames != 0; filenames = nextf)
branch  0 never executed
branch  1 never executed
        -: 9554:    {
        -: 9555:      struct variable *v;
    #####: 9556:      register char *name = filenames->name;
        -: 9557:      struct variable_set_list *vlist;
        -: 9558:      char *fname;
        -: 9559:      char *percent;
        -: 9560:
    #####: 9561:      nextf = filenames->next;
    #####: 9562:      free ((char *) filenames);
        -: 9563:
        -: 9564:      /* If it's a pattern target, then add it to the pattern-specific
        -: 9565:         variable list.  */
    #####: 9566:      percent = find_percent (name);
call    0 never executed
    #####: 9567:      if (percent)
branch  0 never executed
branch  1 never executed
        -: 9568:        {
        -: 9569:          struct pattern_var *p;
        -: 9570:
        -: 9571:          /* Get a reference for this pattern-specific variable struct.  */
    #####: 9572:          p = create_pattern_var(name, percent);
call    0 never executed
    #####: 9573:          vlist = p->vars;
    #####: 9574:          fname = p->target;
        -: 9575:        }
        -: 9576:      else
        -: 9577:        {
        -: 9578:          struct file *f;
        -: 9579:
        -: 9580:          /* Get a file reference for this file, and initialize it.  */
    #####: 9581:          f = enter_file (name);
call    0 never executed
    #####: 9582:          initialize_file_variables (f);
call    0 never executed
    #####: 9583:          vlist = f->variables;
    #####: 9584:          fname = f->name;
        -: 9585:        }
        -: 9586:
        -: 9587:      /* Make the new variable context current and define the variable.  */
    #####: 9588:      current_variable_set_list = vlist;
    #####: 9589:      v = try_variable_definition(filename, lineno, defn, origin);
call    0 never executed
    #####: 9590:      if (!v)
branch  0 never executed
branch  1 never executed
    #####: 9591:        makefile_error(filename, lineno,
call    0 never executed
        -: 9592:                       "Malformed per-target variable definition");
    #####: 9593:      v->per_target = 1;
        -: 9594:
        -: 9595:      /* If it's not an override, check to see if there was a command-line
        -: 9596:         setting.  If so, reset the value.  */
    #####: 9597:      if (origin != o_override)
branch  0 never executed
branch  1 never executed
        -: 9598:        {
        -: 9599:          struct variable *gv;
    #####: 9600:          int len = strlen(v->name);
        -: 9601:
    #####: 9602:          current_variable_set_list = global;
    #####: 9603:          gv = lookup_variable(v->name, len);
call    0 never executed
    #####: 9604:          if (gv && (gv->origin == o_env_override || gv->origin == o_command))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 9605:            define_variable_in_set(v->name, len, gv->value, gv->origin,
    #####: 9606:                                     gv->recursive, vlist->set);
call    0 never executed
        -: 9607:        }
        -: 9608:
        -: 9609:      /* Free name if not needed further.  */
    #####: 9610:      if (name != fname && (name < fname || name > fname + strlen (fname)))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 9611:        free (name);
        -: 9612:    }
        -: 9613:
    #####: 9614:  current_variable_set_list = global;
    #####: 9615:}
        -: 9616:
        -: 9617:/* Record a description line for files FILENAMES,
        -: 9618:   with dependencies DEPS, commands to execute described
        -: 9619:   by COMMANDS and COMMANDS_IDX, coming from FILENAME:COMMANDS_STARTED.
        -: 9620:   TWO_COLON is nonzero if a double colon was used.
        -: 9621:   If not nil, PATTERN is the `%' pattern to make this
        -: 9622:   a static pattern rule, and PATTERN_PERCENT is a pointer
        -: 9623:   to the `%' within it.
        -: 9624:
        -: 9625:   The links of FILENAMES are freed, and so are any names in it
        -: 9626:   that are not incorporated into other data structures.  */
        -: 9627:
        -: 9628:static void
function record_files called 525 returned 100% blocks executed 45%
      525: 9629:record_files (filenames, pattern, pattern_percent, deps, cmds_started,
        -: 9630:	      commands, commands_idx, two_colon, filename, lineno, set_default)
        -: 9631:     struct nameseq *filenames;
        -: 9632:     char *pattern, *pattern_percent;
        -: 9633:     struct dep *deps;
        -: 9634:     unsigned int cmds_started;
        -: 9635:     char *commands;
        -: 9636:     unsigned int commands_idx;
        -: 9637:     int two_colon;
        -: 9638:     char *filename;
        -: 9639:     unsigned int lineno;
        -: 9640:     int set_default;
        -: 9641:{
        -: 9642:  struct nameseq *nextf;
      525: 9643:  int implicit = 0;
      525: 9644:  unsigned int max_targets = 0, target_idx = 0;
      525: 9645:  char **targets = 0, **target_percents = 0;
        -: 9646:  struct commands *cmds;
        -: 9647:
      525: 9648:  if (commands_idx > 0)
branch  0 taken 294 (fallthrough)
branch  1 taken 231
        -: 9649:    {
      294: 9650:      cmds = (struct commands *) xmalloc (sizeof (struct commands));
call    0 returned 294
      294: 9651:      cmds->filename = filename;
      294: 9652:      cmds->lineno = cmds_started;
      294: 9653:      cmds->commands = savestring (commands, commands_idx);
call    0 returned 294
      294: 9654:      cmds->command_lines = 0;
        -: 9655:    }
        -: 9656:  else
      231: 9657:    cmds = 0;
        -: 9658:
     1092: 9659:  for (; filenames != 0; filenames = nextf)
branch  0 taken 567
branch  1 taken 525 (fallthrough)
        -: 9660:    {
        -: 9661:
      567: 9662:      register char *name = filenames->name;
        -: 9663:      register struct file *f;
        -: 9664:      register struct dep *d;
        -: 9665:      struct dep *this;
        -: 9666:      char *implicit_percent;
        -: 9667:
      567: 9668:      nextf = filenames->next;
      567: 9669:      free ((char *) filenames);
        -: 9670:
      567: 9671:      implicit_percent = find_percent (name);
call    0 returned 567
      567: 9672:      implicit |= implicit_percent != 0;
        -: 9673:
     567*: 9674:      if (implicit && pattern != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 567
branch  2 never executed
branch  3 never executed
    #####: 9675:	makefile_fatal (filename, lineno,
call    0 never executed
        -: 9676:			"mixed implicit and static pattern rules");
        -: 9677:
     567*: 9678:      if (implicit && implicit_percent == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 567
branch  2 never executed
branch  3 never executed
    #####: 9679:	makefile_fatal (filename, lineno, "mixed implicit and normal rules");
call    0 never executed
        -: 9680:
     567*: 9681:      if (implicit)
branch  0 taken 0 (fallthrough)
branch  1 taken 567
        -: 9682:	{
    #####: 9683:	  if (targets == 0)
branch  0 never executed
branch  1 never executed
        -: 9684:	    {
    #####: 9685:	      max_targets = 5;
    #####: 9686:	      targets = (char **) xmalloc (5 * sizeof (char *));
call    0 never executed
    #####: 9687:	      target_percents = (char **) xmalloc (5 * sizeof (char *));
call    0 never executed
    #####: 9688:	      target_idx = 0;
        -: 9689:	    }
    #####: 9690:	  else if (target_idx == max_targets - 1)
branch  0 never executed
branch  1 never executed
        -: 9691:	    {
    #####: 9692:	      max_targets += 5;
    #####: 9693:	      targets = (char **) xrealloc ((char *) targets,
call    0 never executed
        -: 9694:					    max_targets * sizeof (char *));
        -: 9695:	      target_percents
    #####: 9696:		= (char **) xrealloc ((char *) target_percents,
call    0 never executed
        -: 9697:				      max_targets * sizeof (char *));
        -: 9698:	    }
    #####: 9699:	  targets[target_idx] = name;
    #####: 9700:	  target_percents[target_idx] = implicit_percent;
    #####: 9701:	  ++target_idx;
    #####: 9702:	  continue;
        -: 9703:	}
        -: 9704:
        -: 9705:      /* If there are multiple filenames, copy the chain DEPS
        -: 9706:	 for all but the last one.  It is not safe for the same deps
        -: 9707:	 to go in more than one place in the data base.  */
      567: 9708:      this = nextf != 0 ? copy_dep_chain (deps) : deps;
branch  0 taken 42 (fallthrough)
branch  1 taken 525
call    2 returned 42
        -: 9709:
      567: 9710:      if (pattern != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 567
        -: 9711:	/* If this is an extended static rule:
        -: 9712:	   `targets: target%pattern: dep%pattern; cmds',
        -: 9713:	   translate each dependency pattern into a plain filename
        -: 9714:	   using the target pattern and this target's name.  */
    #####: 9715:	if (!pattern_matches (pattern, pattern_percent, name))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 9716:	  {
        -: 9717:	    /* Give a warning if the rule is meaningless.  */
    #####: 9718:	    makefile_error (filename, lineno,
call    0 never executed
        -: 9719:			    "target `%s' doesn't match the target pattern",
        -: 9720:			    name);
    #####: 9721:	    this = 0;
        -: 9722:	  }
        -: 9723:	else
        -: 9724:	  {
        -: 9725:	    /* We use patsubst_expand to do the work of translating
        -: 9726:	       the target pattern, the target's name and the dependencies'
        -: 9727:	       patterns into plain dependency names.  */
    #####: 9728:	    char *buffer = variable_expand ("");
call    0 never executed
        -: 9729:
    #####: 9730:	    for (d = this; d != 0; d = d->next)
branch  0 never executed
branch  1 never executed
        -: 9731:	      {
        -: 9732:		char *o;
    #####: 9733:		char *percent = find_percent (d->name);
call    0 never executed
    #####: 9734:		if (percent == 0)
branch  0 never executed
branch  1 never executed
    #####: 9735:		  continue;
    #####: 9736:		o = patsubst_expand (buffer, name, pattern, d->name,
call    0 never executed
        -: 9737:				     pattern_percent, percent);
    #####: 9738:		free (d->name);
    #####: 9739:		d->name = savestring (buffer, o - buffer);
call    0 never executed
        -: 9740:	      }
        -: 9741:	  }
        -: 9742:
      567: 9743:      if (!two_colon)
branch  0 taken 567 (fallthrough)
branch  1 taken 0
        -: 9744:	{
        -: 9745:	  /* Single-colon.  Combine these dependencies
        -: 9746:	     with others in file's existing record, if any.  */
      567: 9747:	  f = enter_file (name);
call    0 returned 567
        -: 9748:
      567: 9749:	  if (f->double_colon)
branch  0 taken 0 (fallthrough)
branch  1 taken 567
    #####: 9750:	    makefile_fatal (filename, lineno,
call    0 never executed
        -: 9751:			    "target file `%s' has both : and :: entries",
        -: 9752:			    f->name);
        -: 9753:
        -: 9754:	  /* If CMDS == F->CMDS, this target was listed in this rule
        -: 9755:	     more than once.  Just give a warning since this is harmless.  */
      567: 9756:	  if (cmds != 0 && cmds == f->cmds)
branch  0 taken 294 (fallthrough)
branch  1 taken 273
branch  2 taken 0 (fallthrough)
branch  3 taken 294
    #####: 9757:	    makefile_error
call    0 never executed
        -: 9758:	      (filename, lineno,
        -: 9759:	       "target `%s' given more than once in the same rule.",
        -: 9760:	       f->name);
        -: 9761:
        -: 9762:	  /* Check for two single-colon entries both with commands.
        -: 9763:	     Check is_target so that we don't lose on files such as .c.o
        -: 9764:	     whose commands were preinitialized.  */
      567: 9765:	  else if (cmds != 0 && f->cmds != 0 && f->is_target)
branch  0 taken 294 (fallthrough)
branch  1 taken 273
branch  2 taken 59 (fallthrough)
branch  3 taken 235
branch  4 taken 42 (fallthrough)
branch  5 taken 17
        -: 9766:	    {
       42: 9767:	      makefile_error (cmds->filename, cmds->lineno,
call    0 returned 42
        -: 9768:			      "warning: overriding commands for target `%s'",
        -: 9769:			      f->name);
       42: 9770:	      makefile_error (f->cmds->filename, f->cmds->lineno,
call    0 returned 42
        -: 9771:			      "warning: ignoring old commands for target `%s'",
        -: 9772:			      f->name);
        -: 9773:	    }
        -: 9774:
      567: 9775:	  f->is_target = 1;
        -: 9776:
        -: 9777:	  /* Defining .DEFAULT with no deps or cmds clears it.  */
     567*: 9778:	  if (f == default_file && this == 0 && cmds == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 567
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 9779:	    f->cmds = 0;
      567: 9780:	  if (cmds != 0)
branch  0 taken 294 (fallthrough)
branch  1 taken 273
      294: 9781:	    f->cmds = cmds;
        -: 9782:	  /* Defining .SUFFIXES with no dependencies
        -: 9783:	     clears out the list of suffixes.  */
     567*: 9784:	  if (f == suffix_file && this == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 567
branch  2 never executed
branch  3 never executed
        -: 9785:	    {
    #####: 9786:	      d = f->deps;
    #####: 9787:	      while (d != 0)
branch  0 never executed
branch  1 never executed
        -: 9788:		{
    #####: 9789:		  struct dep *nextd = d->next;
    #####: 9790: 		  free (d->name);
    #####: 9791: 		  free ((char *)d);
    #####: 9792:		  d = nextd;
        -: 9793:		}
    #####: 9794:	      f->deps = 0;
        -: 9795:	    }
      567: 9796:	  else if (f->deps != 0)
branch  0 taken 141 (fallthrough)
branch  1 taken 426
        -: 9797:	    {
        -: 9798:	      /* Add the file's old deps and the new ones in THIS together.  */
        -: 9799:
        -: 9800:	      struct dep *firstdeps, *moredeps;
      141: 9801:	      if (cmds != 0)
branch  0 taken 33 (fallthrough)
branch  1 taken 108
        -: 9802:		{
        -: 9803:		  /* This is the rule with commands, so put its deps first.
        -: 9804:		     The rationale behind this is that $< expands to the
        -: 9805:		     first dep in the chain, and commands use $< expecting
        -: 9806:		     to get the dep that rule specifies.  */
       33: 9807:		  firstdeps = this;
       33: 9808:		  moredeps = f->deps;
        -: 9809:		}
        -: 9810:	      else
        -: 9811:		{
        -: 9812:		  /* Append the new deps to the old ones.  */
      108: 9813:		  firstdeps = f->deps;
      108: 9814:		  moredeps = this;
        -: 9815:		}
        -: 9816:
      141: 9817:	      if (firstdeps == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 141
    #####: 9818:		firstdeps = moredeps;
        -: 9819:	      else
        -: 9820:		{
      141: 9821:		  d = firstdeps;
      645: 9822:		  while (d->next != 0)
branch  0 taken 504
branch  1 taken 141 (fallthrough)
      504: 9823:		    d = d->next;
      141: 9824:		  d->next = moredeps;
        -: 9825:		}
        -: 9826:
      141: 9827:	      f->deps = firstdeps;
        -: 9828:	    }
        -: 9829:	  else
      426: 9830:	    f->deps = this;
        -: 9831:
        -: 9832:	  /* If this is a static pattern rule, set the file's stem to
        -: 9833:	     the part of its name that matched the `%' in the pattern,
        -: 9834:	     so you can use $* in the commands.  */
      567: 9835:	  if (pattern != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 567
        -: 9836:	    {
        -: 9837:	      static char *percent = "%";
    #####: 9838:	      char *buffer = variable_expand ("");
call    0 never executed
    #####: 9839:	      char *o = patsubst_expand (buffer, name, pattern, percent,
call    0 never executed
        -: 9840:					 pattern_percent, percent);
    #####: 9841:	      f->stem = savestring (buffer, o - buffer);
call    0 never executed
        -: 9842:	    }
        -: 9843:	}
        -: 9844:      else
        -: 9845:	{
        -: 9846:	  /* Double-colon.  Make a new record
        -: 9847:	     even if the file already has one.  */
    #####: 9848:	  f = lookup_file (name);
call    0 never executed
        -: 9849:	  /* Check for both : and :: rules.  Check is_target so
        -: 9850:	     we don't lose on default suffix rules or makefiles.  */
    #####: 9851:	  if (f != 0 && f->is_target && !f->double_colon)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 9852:	    makefile_fatal (filename, lineno,
call    0 never executed
        -: 9853:			    "target file `%s' has both : and :: entries",
        -: 9854:			    f->name);
    #####: 9855:	  f = enter_file (name);
call    0 never executed
        -: 9856:	  /* If there was an existing entry and it was a double-colon
        -: 9857:	     entry, enter_file will have returned a new one, making it the
        -: 9858:	     prev pointer of the old one, and setting its double_colon
        -: 9859:	     pointer to the first one.  */
    #####: 9860:	  if (f->double_colon == 0)
branch  0 never executed
branch  1 never executed
        -: 9861:	    /* This is the first entry for this name, so we must
        -: 9862:	       set its double_colon pointer to itself.  */
    #####: 9863:	    f->double_colon = f;
    #####: 9864:	  f->is_target = 1;
    #####: 9865:	  f->deps = this;
    #####: 9866:	  f->cmds = cmds;
        -: 9867:	}
        -: 9868:
        -: 9869:      /* Free name if not needed further.  */
      567: 9870:      if (f != 0 && name != f->name
branch  0 taken 567 (fallthrough)
branch  1 taken 0
branch  2 taken 188 (fallthrough)
branch  3 taken 379
      188: 9871:	  && (name < f->name || name > f->name + strlen (f->name)))
branch  0 taken 188 (fallthrough)
branch  1 taken 0
branch  2 taken 188 (fallthrough)
branch  3 taken 0
        -: 9872:	{
      188: 9873:	  free (name);
      188: 9874:	  name = f->name;
        -: 9875:	}
        -: 9876:
        -: 9877:      /* See if this is first target seen whose name does
        -: 9878:	 not start with a `.', unless it contains a slash.  */
      567: 9879:      if (default_goal_file == 0 && set_default
branch  0 taken 18 (fallthrough)
branch  1 taken 549
branch  2 taken 18 (fallthrough)
branch  3 taken 0
      18*: 9880:	  && (*name != '.' || index (name, '/') != 0
branch  0 taken 0 (fallthrough)
branch  1 taken 18
branch  2 never executed
branch  3 never executed
        -: 9881:#ifdef __MSDOS__
        -: 9882:			   || index (name, '\\') != 0
        -: 9883:#endif
        -: 9884:	      ))
        -: 9885:	{
       18: 9886:	  int reject = 0;
        -: 9887:
        -: 9888:	  /* If this file is a suffix, don't
        -: 9889:	     let it be the default goal file.  */
        -: 9890:
      562: 9891:	  for (d = suffix_file->deps; d != 0; d = d->next)
branch  0 taken 544
branch  1 taken 18 (fallthrough)
        -: 9892:	    {
        -: 9893:	      register struct dep *d2;
     544*: 9894:	      if (*dep_name (d) != '.' && streq (name, dep_name (d)))
branch  0 taken 0 (fallthrough)
branch  1 taken 544
branch  2 taken 0 (fallthrough)
branch  3 taken 544
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
        -: 9895:		{
    #####: 9896:		  reject = 1;
    #####: 9897:		  break;
        -: 9898:		}
    17952: 9899:	      for (d2 = suffix_file->deps; d2 != 0; d2 = d2->next)
branch  0 taken 17408
branch  1 taken 544 (fallthrough)
        -: 9900:		{
   17408*: 9901:		  register unsigned int len = strlen (dep_name (d2));
branch  0 taken 0 (fallthrough)
branch  1 taken 17408
   17408*: 9902:		  if (strncmp (name, dep_name (d2), len))
branch  0 taken 0 (fallthrough)
branch  1 taken 17408
branch  2 taken 17408 (fallthrough)
branch  3 taken 0
    17408: 9903:		    continue;
    #####: 9904:		  if (streq (name + len, dep_name (d)))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
        -: 9905:		    {
    #####: 9906:		      reject = 1;
    #####: 9907:		      break;
        -: 9908:		    }
        -: 9909:		}
      544: 9910:	      if (reject)
branch  0 taken 0 (fallthrough)
branch  1 taken 544
    #####: 9911:		break;
        -: 9912:	    }
        -: 9913:
       18: 9914:	  if (!reject)
branch  0 taken 18 (fallthrough)
branch  1 taken 0
       18: 9915:	    default_goal_file = f;
        -: 9916:	}
        -: 9917:    }
        -: 9918:
      525: 9919:  if (implicit)
branch  0 taken 0 (fallthrough)
branch  1 taken 525
        -: 9920:    {
    #####: 9921:      targets[target_idx] = 0;
    #####: 9922:      target_percents[target_idx] = 0;
    #####: 9923:      create_pattern_rule (targets, target_percents, two_colon, deps, cmds, 1);
call    0 never executed
    #####: 9924:      free ((char *) target_percents);
        -: 9925:    }
      525: 9926:}
        -: 9927:
        -: 9928:/* Search STRING for an unquoted STOPCHAR or blank (if BLANK is nonzero).
        -: 9929:   Backslashes quote STOPCHAR, blanks if BLANK is nonzero, and backslash.
        -: 9930:   Quoting backslashes are removed from STRING by compacting it into
        -: 9931:   itself.  Returns a pointer to the first unquoted STOPCHAR if there is
        -: 9932:   one, or nil if there are none.  */
        -: 9933:
        -: 9934:char *
function find_char_unquote called 49189 returned 100% blocks executed 58%
    49189: 9935:find_char_unquote (string, stopchars, blank)
        -: 9936:     char *string;
        -: 9937:     char *stopchars;
        -: 9938:     int blank;
        -: 9939:{
    49189: 9940:  unsigned int string_len = 0;
    49189: 9941:  register char *p = string;
        -: 9942:
        -: 9943:  while (1)
        -: 9944:    {
  278738*: 9945:      while (*p != '\0' && index (stopchars, *p) == 0
branch  0 taken 221527 (fallthrough)
branch  1 taken 8022
   464820: 9946:	     && (!blank || !isblank (*p)))
branch  0 taken 229549 (fallthrough)
branch  1 taken 13744
branch  2 taken 64900
branch  3 taken 156627 (fallthrough)
branch  4 taken 129204
branch  5 taken 27423 (fallthrough)
   194104: 9947:	++p;
    49189: 9948:      if (*p == '\0')
branch  0 taken 13744 (fallthrough)
branch  1 taken 35445
    13744: 9949:	break;
        -: 9950:
    35445: 9951:      if (p > string && p[-1] == '\\')
branch  0 taken 28212 (fallthrough)
branch  1 taken 7233
branch  2 taken 0 (fallthrough)
branch  3 taken 28212
    #####: 9952:	{
        -: 9953:	  /* Search for more backslashes.  */
    #####: 9954:	  register int i = -2;
    #####: 9955:	  while (&p[i] >= string && p[i] == '\\')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 9956:	    --i;
    #####: 9957:	  ++i;
        -: 9958:	  /* Only compute the length if really needed.  */
    #####: 9959:	  if (string_len == 0)
branch  0 never executed
branch  1 never executed
    #####: 9960:	    string_len = strlen (string);
        -: 9961:	  /* The number of backslashes is now -I.
        -: 9962:	     Copy P over itself to swallow half of them.  */
    #####: 9963:	  bcopy (&p[i / 2], &p[i], (string_len - (p - string)) - (i / 2) + 1);
    #####: 9964:	  p += i / 2;
    #####: 9965:	  if (i % 2 == 0)
branch  0 never executed
branch  1 never executed
        -: 9966:	    /* All the backslashes quoted each other; the STOPCHAR was
        -: 9967:	       unquoted.  */
    #####: 9968:	    return p;
        -: 9969:
        -: 9970:	  /* The STOPCHAR was quoted by a backslash.  Look for another.  */
        -: 9971:	}
        -: 9972:      else
        -: 9973:	/* No backslash in sight.  */
    35445: 9974:	return p;
        -: 9975:    }
        -: 9976:
        -: 9977:  /* Never hit a STOPCHAR or blank (with BLANK nonzero).  */
    13744: 9978:  return 0;
        -: 9979:}
        -: 9980:
        -: 9981:/* Search PATTERN for an unquoted %.  */
        -: 9982:
        -: 9983:char *
function find_percent called 7686 returned 100% blocks executed 100%
     7686: 9984:find_percent (pattern)
        -: 9985:     char *pattern;
        -: 9986:{
     7686: 9987:  return find_char_unquote (pattern, "%", 0);
call    0 returned 7686
        -: 9988:}
        -: 9989:
        -: 9990:/* Parse a string into a sequence of filenames represented as a
        -: 9991:   chain of struct nameseq's in reverse order and return that chain.
        -: 9992:
        -: 9993:   The string is passed as STRINGP, the address of a string pointer.
        -: 9994:   The string pointer is updated to point at the first character
        -: 9995:   not parsed, which either is a null char or equals STOPCHAR.
        -: 9996:
        -: 9997:   SIZE is how big to construct chain elements.
        -: 9998:   This is useful if we want them actually to be other structures
        -: 9999:   that have room for additional info.
        -:10000:
        -:10001:   If STRIP is nonzero, strip `./'s off the beginning.  */
        -:10002:
        -:10003:struct nameseq *
function parse_file_seq called 8945 returned 100% blocks executed 45%
     8945:10004:parse_file_seq (stringp, stopchar, size, strip)
        -:10005:     char **stringp;
        -:10006:     int stopchar;
        -:10007:     unsigned int size;
        -:10008:     int strip;
        -:10009:{
     8945:10010:  register struct nameseq *new = 0;
        -:10011:  register struct nameseq *new1, *lastnew1;
     8945:10012:  register char *p = *stringp;
        -:10013:  char *q;
        -:10014:  char *name;
        -:10015:  char stopchars[3];
        -:10016:
        -:10017:#ifdef VMS
        -:10018:  stopchars[0] = ',';
        -:10019:  stopchars[1] = stopchar;
        -:10020:  stopchars[2] = '\0';
        -:10021:#else
     8945:10022:  stopchars[0] = stopchar;
     8945:10023:  stopchars[1] = '\0';
        -:10024:#endif
        -:10025:
        -:10026:  while (1)
        -:10027:    {
        -:10028:      /* Skip whitespace; see if any more names are left.  */
    44683:10029:      p = next_token (p);
call    0 returned 44683
    44683:10030:      if (*p == '\0')
branch  0 taken 8420 (fallthrough)
branch  1 taken 36263
     8420:10031:	break;
    36263:10032:      if (*p == stopchar)
branch  0 taken 525 (fallthrough)
branch  1 taken 35738
      525:10033:	break;
        -:10034:
        -:10035:      /* Yes, find end of next name.  */
    35738:10036:      q = p;
    35738:10037:      p = find_char_unquote (q, stopchars, 1);
call    0 returned 35738
        -:10038:#ifdef VMS
        -:10039:	/* convert comma separated list to space separated */
        -:10040:      if (p && *p == ',')
        -:10041:	*p =' ';
        -:10042:#endif
        -:10043:#ifdef _AMIGA
        -:10044:      if (stopchar == ':' && p && *p == ':' &&
        -:10045:	!(isspace(p[1]) || !p[1] || isspace(p[-1])))
        -:10046:      {
        -:10047:	p = find_char_unquote (p+1, stopchars, 1);
        -:10048:      }
        -:10049:#endif
        -:10050:#if defined(WINDOWS32) || defined(__MSDOS__)
        -:10051:    /* For WINDOWS32, skip a "C:\..." or a "C:/..." until we find the
        -:10052:       first colon which isn't followed by a slash or a backslash.
        -:10053:       Note that tokens separated by spaces should be treated as separate
        -:10054:       tokens since make doesn't allow path names with spaces */
        -:10055:    if (stopchar == ':')
        -:10056:      while (p != 0 && !isspace(*p) &&
        -:10057:             (p[1] == '\\' || p[1] == '/') && isalpha (p[-1]))
        -:10058:        p = find_char_unquote (p + 1, stopchars, 1);
        -:10059:#endif
    35738:10060:      if (p == 0)
branch  0 taken 8315 (fallthrough)
branch  1 taken 27423
     8315:10061:	p = q + strlen (q);
        -:10062:
    35738:10063:      if (strip)
branch  0 taken 35738 (fallthrough)
branch  1 taken 0
        -:10064:#ifdef VMS
        -:10065:	/* Skip leading `[]'s.  */
        -:10066:	while (p - q > 2 && q[0] == '[' && q[1] == ']')
        -:10067:#else
        -:10068:	/* Skip leading `./'s.  */
    35738:10069:	while (p - q > 2 && q[0] == '.' && q[1] == '/')
branch  0 taken 23114 (fallthrough)
branch  1 taken 12624
branch  2 taken 14349 (fallthrough)
branch  3 taken 8765
branch  4 taken 0
branch  5 taken 14349 (fallthrough)
        -:10070:#endif
        -:10071:	  {
    #####:10072:	    q += 2;		/* Skip "./".  */
    #####:10073:	    while (q < p && *q == '/')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:10074:	      /* Skip following slashes: ".//foo" is "foo", not "/foo".  */
    #####:10075:	      ++q;
        -:10076:	  }
        -:10077:
        -:10078:      /* Extract the filename just found, and skip it.  */
        -:10079:
    35738:10080:      if (q == p)
branch  0 taken 0 (fallthrough)
branch  1 taken 35738
        -:10081:	/* ".///" was stripped to "". */
        -:10082:#ifdef VMS
        -:10083:	continue;
        -:10084:#else
        -:10085:#ifdef _AMIGA
        -:10086:	name = savestring ("", 0);
        -:10087:#else
    #####:10088:	name = savestring ("./", 2);
call    0 never executed
        -:10089:#endif
        -:10090:#endif
        -:10091:      else
        -:10092:#ifdef VMS
        -:10093:/* VMS filenames can have a ':' in them but they have to be '\'ed but we need
        -:10094: *  to remove this '\' before we can use the filename.
        -:10095: * Savestring called because q may be read-only string constant.
        -:10096: */
        -:10097:	{
        -:10098:	  char *qbase = savestring(q, strlen(q));
        -:10099:	  char *pbase = qbase + (p-q);
        -:10100:	  char *q1 = qbase;
        -:10101:	  char *q2 = q1;
        -:10102:	  char *p1 = pbase;
        -:10103:
        -:10104:	  while (q1 != pbase)
        -:10105:	    {
        -:10106:	      if (*q1 == '\\' && *(q1+1) == ':')
        -:10107:		{
        -:10108:		  q1++;
        -:10109:		  p1--;
        -:10110:		}
        -:10111:	      *q2++ = *q1++;
        -:10112:	    }
        -:10113:	  name = savestring (qbase, p1 - qbase);
        -:10114:	  free (qbase);
        -:10115:	}
        -:10116:#else
    35738:10117:	name = savestring (q, p - q);
call    0 returned 35738
        -:10118:#endif
        -:10119:
        -:10120:      /* Add it to the front of the chain.  */
    35738:10121:      new1 = (struct nameseq *) xmalloc (size);
call    0 returned 35738
    35738:10122:      new1->name = name;
    35738:10123:      new1->next = new;
    35738:10124:      new = new1;
        -:10125:    }
        -:10126:
        -:10127:#ifndef NO_ARCHIVES
        -:10128:
        -:10129:  /* Look for multi-word archive references.
        -:10130:     They are indicated by a elt ending with an unmatched `)' and
        -:10131:     an elt further down the chain (i.e., previous in the file list)
        -:10132:     with an unmatched `(' (e.g., "lib(mem").  */
        -:10133:
     8945:10134:  new1 = new;
     8945:10135:  lastnew1 = 0;
    44683:10136:  while (new1 != 0)
branch  0 taken 35738
branch  1 taken 8945 (fallthrough)
    35738:10137:    if (new1->name[0] != '('	/* Don't catch "(%)" and suchlike.  */
branch  0 taken 35738 (fallthrough)
branch  1 taken 0
    35738:10138:	&& new1->name[strlen (new1->name) - 1] == ')'
branch  0 taken 0 (fallthrough)
branch  1 taken 35738
    #####:10139:	&& index (new1->name, '(') == 0)
branch  0 never executed
branch  1 never executed
    #####:10140:      {
        -:10141:	/* NEW1 ends with a `)' but does not contain a `('.
        -:10142:	   Look back for an elt with an opening `(' but no closing `)'.  */
        -:10143:
    #####:10144:	struct nameseq *n = new1->next, *lastn = new1;
    #####:10145:	char *paren = 0;
    #####:10146:	while (n != 0 && (paren = index (n->name, '(')) == 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:10147:	  {
    #####:10148:	    lastn = n;
    #####:10149:	    n = n->next;
        -:10150:	  }
    #####:10151:	if (n != 0
branch  0 never executed
branch  1 never executed
        -:10152:	    /* Ignore something starting with `(', as that cannot actually
        -:10153:	       be an archive-member reference (and treating it as such
        -:10154:	       results in an empty file name, which causes much lossage).  */
    #####:10155:	    && n->name[0] != '(')
branch  0 never executed
branch  1 never executed
    #####:10156:	  {
        -:10157:	    /* N is the first element in the archive group.
        -:10158:	       Its name looks like "lib(mem" (with no closing `)').  */
        -:10159:
        -:10160:	    char *libname;
        -:10161:
        -:10162:	    /* Copy "lib(" into LIBNAME.  */
    #####:10163:	    ++paren;
    #####:10164:	    libname = (char *) alloca (paren - n->name + 1);
    #####:10165:	    bcopy (n->name, libname, paren - n->name);
    #####:10166:	    libname[paren - n->name] = '\0';
        -:10167:
    #####:10168:	    if (*paren == '\0')
branch  0 never executed
branch  1 never executed
        -:10169:	      {
        -:10170:		/* N was just "lib(", part of something like "lib( a b)".
        -:10171:		   Edit it out of the chain and free its storage.  */
    #####:10172:		lastn->next = n->next;
    #####:10173:		free (n->name);
    #####:10174:		free ((char *) n);
        -:10175:		/* LASTN->next is the new stopping elt for the loop below.  */
    #####:10176:		n = lastn->next;
        -:10177:	      }
        -:10178:	    else
        -:10179:	      {
        -:10180:		/* Replace N's name with the full archive reference.  */
    #####:10181:		name = concat (libname, paren, ")");
call    0 never executed
    #####:10182:		free (n->name);
    #####:10183:		n->name = name;
        -:10184:	      }
        -:10185:
    #####:10186:	    if (new1->name[1] == '\0')
branch  0 never executed
branch  1 never executed
        -:10187:	      {
        -:10188:		/* NEW1 is just ")", part of something like "lib(a b )".
        -:10189:		   Omit it from the chain and free its storage.  */
    #####:10190:		if (lastnew1 == 0)
branch  0 never executed
branch  1 never executed
    #####:10191:		  new = new1->next;
        -:10192:		else
    #####:10193:		  lastnew1->next = new1->next;
    #####:10194:		lastn = new1;
    #####:10195:		new1 = new1->next;
    #####:10196:		free (lastn->name);
    #####:10197:		free ((char *) lastn);
        -:10198:	      }
        -:10199:	    else
        -:10200:	      {
        -:10201:		/* Replace also NEW1->name, which already has closing `)'.  */
    #####:10202:		name = concat (libname, new1->name, "");
call    0 never executed
    #####:10203:		free (new1->name);
    #####:10204:		new1->name = name;
    #####:10205:		new1 = new1->next;
        -:10206:	      }
        -:10207:
        -:10208:	    /* Trace back from NEW1 (the end of the list) until N
        -:10209:	       (the beginning of the list), rewriting each name
        -:10210:	       with the full archive reference.  */
        -:10211:
    #####:10212:	    while (new1 != n)
branch  0 never executed
branch  1 never executed
        -:10213:	      {
    #####:10214:		name = concat (libname, new1->name, ")");
call    0 never executed
    #####:10215:		free (new1->name);
    #####:10216:		new1->name = name;
    #####:10217:		lastnew1 = new1;
    #####:10218:		new1 = new1->next;
        -:10219:	      }
        -:10220:	  }
        -:10221:	else
        -:10222:	  {
        -:10223:	    /* No frobnication happening.  Just step down the list.  */
    #####:10224:	    lastnew1 = new1;
    #####:10225:	    new1 = new1->next;
        -:10226:	  }
        -:10227:      }
        -:10228:    else
        -:10229:      {
    35738:10230:	lastnew1 = new1;
    35738:10231:	new1 = new1->next;
        -:10232:      }
        -:10233:
        -:10234:#endif
        -:10235:
     8945:10236:  *stringp = p;
     8945:10237:  return new;
        -:10238:}
        -:10239:
        -:10240:/* Read a line of text from STREAM into LINEBUFFER.
        -:10241:   Combine continuation lines into one line.
        -:10242:   Return the number of actual lines read (> 1 if hacked continuation lines).
        -:10243: */
        -:10244:
        -:10245:static unsigned int
function readline called 2573 returned 100% blocks executed 82%
     2573:10246:readline (linebuffer, stream, filename, lineno)
        -:10247:     struct linebuffer *linebuffer;
        -:10248:     FILE *stream;
        -:10249:     char *filename;
        -:10250:     unsigned int lineno;
        -:10251:{
     2573:10252:  char *buffer = linebuffer->buffer;
     2573:10253:  register char *p = linebuffer->buffer;
     2573:10254:  register char *end = p + linebuffer->size;
     2573:10255:  register int len, lastlen = 0;
        -:10256:  register char *p2;
     2573:10257:  register unsigned int nlines = 0;
        -:10258:  register int backslash;
        -:10259:
     2573:10260:  *p = '\0';
        -:10261:
     2657:10262:  while (fgets (p, end - p, stream) != 0)
call    0 returned 2657
branch  1 taken 2635
branch  2 taken 22 (fallthrough)
        -:10263:    {
     2635:10264:      len = strlen (p);
     2635:10265:      if (len == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 2635
        -:10266:	{
        -:10267:	  /* This only happens when the first thing on the line is a '\0'.
        -:10268:	     It is a pretty hopeless case, but (wonder of wonders) Athena
        -:10269:	     lossage strikes again!  (xmkmf puts NULs in its makefiles.)
        -:10270:	     There is nothing really to be done; we synthesize a newline so
        -:10271:	     the following line doesn't appear to be part of this line.  */
    #####:10272:	  makefile_error (filename, lineno,
call    0 never executed
        -:10273:			  "warning: NUL character seen; rest of line ignored");
    #####:10274:	  p[0] = '\n';
    #####:10275:	  len = 1;
        -:10276:	}
        -:10277:
     2635:10278:      p += len;
     2635:10279:      if (p[-1] != '\n')
branch  0 taken 21 (fallthrough)
branch  1 taken 2614
       21:10280:	{
        -:10281:	  /* Probably ran out of buffer space.  */
       21:10282:	  register unsigned int p_off = p - buffer;
       21:10283:	  linebuffer->size *= 2;
       21:10284:	  buffer = (char *) xrealloc (buffer, linebuffer->size);
call    0 returned 21
       21:10285:	  p = buffer + p_off;
       21:10286:	  end = buffer + linebuffer->size;
       21:10287:	  linebuffer->buffer = buffer;
       21:10288:	  *p = '\0';
       21:10289:	  lastlen = len;
       21:10290:	  continue;
        -:10291:	}
        -:10292:
     2614:10293:      ++nlines;
        -:10294:
     2614:10295:      if (len == 1 && p > buffer)
branch  0 taken 698 (fallthrough)
branch  1 taken 1916
branch  2 taken 698 (fallthrough)
branch  3 taken 0
        -:10296:	/* P is pointing at a newline and it's the beginning of
        -:10297:	   the buffer returned by the last fgets call.  However,
        -:10298:	   it is not necessarily the beginning of a line if P is
        -:10299:	   pointing past the beginning of the holding buffer.
        -:10300:	   If the buffer was just enlarged (right before the newline),
        -:10301:	   we must account for that, so we pretend that the two lines
        -:10302:	   were one line.  */
      698:10303:	len += lastlen;
     2614:10304:      lastlen = len;
     2614:10305:      backslash = 0;
     2677:10306:      for (p2 = p - 2; --len > 0; --p2)
branch  0 taken 1979
branch  1 taken 698 (fallthrough)
        -:10307:	{
     1979:10308:	  if (*p2 == '\\')
branch  0 taken 63 (fallthrough)
branch  1 taken 1916
       63:10309:	    backslash = !backslash;
        -:10310:	  else
     1916:10311:	    break;
        -:10312:	}
        -:10313:
     2614:10314:      if (!backslash)
branch  0 taken 2551 (fallthrough)
branch  1 taken 63
        -:10315:	{
     2551:10316:	  p[-1] = '\0';
     2551:10317:	  break;
        -:10318:	}
        -:10319:
       63:10320:      if (end - p <= 1)
branch  0 taken 0 (fallthrough)
branch  1 taken 63
        -:10321:	{
        -:10322:	  /* Enlarge the buffer.  */
    #####:10323:	  register unsigned int p_off = p - buffer;
    #####:10324:	  linebuffer->size *= 2;
    #####:10325:	  buffer = (char *) xrealloc (buffer, linebuffer->size);
call    0 never executed
    #####:10326:	  p = buffer + p_off;
    #####:10327:	  end = buffer + linebuffer->size;
    #####:10328:	  linebuffer->buffer = buffer;
        -:10329:	}
        -:10330:    }
        -:10331:
     2573:10332:  if (ferror (stream))
call    0 returned 2573
branch  1 taken 0 (fallthrough)
branch  2 taken 2573
    #####:10333:    pfatal_with_name (filename);
call    0 never executed
        -:10334:
     2573:10335:  return nlines;
        -:10336:}
        -:10337:
        -:10338:/* Parse the next "makefile word" from the input buffer, and return info
        -:10339:   about it.
        -:10340:
        -:10341:   A "makefile word" is one of:
        -:10342:
        -:10343:     w_bogus        Should never happen
        -:10344:     w_eol          End of input
        -:10345:     w_static       A static word; cannot be expanded
        -:10346:     w_variable     A word containing one or more variables/functions
        -:10347:     w_colon        A colon
        -:10348:     w_dcolon       A double-colon
        -:10349:     w_semicolon    A semicolon
        -:10350:     w_comment      A comment character
        -:10351:     w_varassign    A variable assignment operator (=, :=, +=, or ?=)
        -:10352:
        -:10353:   Note that this function is only used when reading certain parts of the
        -:10354:   makefile.  Don't use it where special rules hold sway (RHS of a variable,
        -:10355:   in a command list, etc.)  */
        -:10356:
        -:10357:static enum make_word_type
function get_next_mword called 2058 returned 100% blocks executed 62%
     2058:10358:get_next_mword (buffer, delim, startp, length)
        -:10359:     char *buffer;
        -:10360:     char *delim;
        -:10361:     char **startp;
        -:10362:     unsigned int *length;
        -:10363:{
     2058:10364:  enum make_word_type wtype = w_bogus;
     2058:10365:  char *p = buffer, *beg;
        -:10366:  char c;
        -:10367:
        -:10368:  /* Skip any leading whitespace.  */
     2646:10369:  while (isblank(*p))
branch  0 taken 588
branch  1 taken 2058 (fallthrough)
      588:10370:    ++p;
        -:10371:
     2058:10372:  beg = p;
     2058:10373:  c = *(p++);
     2058:10374:  switch (c)
branch  0 taken 420
branch  1 taken 0
branch  2 taken 0
branch  3 taken 0
branch  4 taken 525
branch  5 taken 0
branch  6 taken 1113
        -:10375:    {
      420:10376:    case '\0':
      420:10377:      wtype = w_eol;
      420:10378:      break;
        -:10379:
    #####:10380:    case '#':
    #####:10381:      wtype = w_comment;
    #####:10382:      break;
        -:10383:
    #####:10384:    case ';':
    #####:10385:      wtype = w_semicolon;
    #####:10386:      break;
        -:10387:
    #####:10388:    case '=':
    #####:10389:      wtype = w_varassign;
    #####:10390:      break;
        -:10391:
      525:10392:    case ':':
      525:10393:      wtype = w_colon;
      525:10394:      switch (*p)
branch  0 taken 0
branch  1 taken 0
branch  2 taken 525
        -:10395:        {
    #####:10396:        case ':':
    #####:10397:          ++p;
    #####:10398:          wtype = w_dcolon;
    #####:10399:          break;
        -:10400:
    #####:10401:        case '=':
    #####:10402:          ++p;
    #####:10403:          wtype = w_varassign;
    #####:10404:          break;
        -:10405:        }
      525:10406:      break;
        -:10407:
    #####:10408:    case '+':
        -:10409:    case '?':
    #####:10410:      if (*p == '=')
branch  0 never executed
branch  1 never executed
        -:10411:        {
    #####:10412:          ++p;
    #####:10413:          wtype = w_varassign;
    #####:10414:          break;
        -:10415:        }
        -:10416:
        -:10417:    default:
    1113*:10418:      if (delim && index(delim, c))
branch  0 taken 0 (fallthrough)
branch  1 taken 1113
branch  2 never executed
branch  3 never executed
    #####:10419:        wtype = w_static;
     1113:10420:      break;
        -:10421:    }
        -:10422:
        -:10423:  /* Did we find something?  If so, return now.  */
     2058:10424:  if (wtype != w_bogus)
branch  0 taken 945 (fallthrough)
branch  1 taken 1113
      945:10425:    goto done;
        -:10426:
        -:10427:  /* This is some non-operator word.  A word consists of the longest
        -:10428:     string of characters that doesn't contain whitespace, one of [:=#],
        -:10429:     or [?+]=, or one of the chars in the DELIM string.  */
        -:10430:
        -:10431:  /* We start out assuming a static word; if we see a variable we'll
        -:10432:     adjust our assumptions then.  */
     1113:10433:  wtype = w_static;
        -:10434:
        -:10435:  /* We already found the first value of "c", above.  */
        -:10436:  while (1)
     7644:10437:    {
        -:10438:      char closeparen;
        -:10439:      int count;
        -:10440:
     8757:10441:      switch (c)
branch  0 taken 588
branch  1 taken 525
branch  2 taken 63
branch  3 taken 0
branch  4 taken 0
branch  5 taken 7581
        -:10442:        {
      588:10443:        case '\0':
        -:10444:        case ' ':
        -:10445:        case '\t':
        -:10446:        case '=':
        -:10447:        case '#':
      588:10448:          goto done_word;
        -:10449:
      525:10450:        case ':':
        -:10451:#if defined(__MSDOS__) || defined(WINDOWS32)
        -:10452:	  /* A word CAN include a colon in its drive spec.  */
        -:10453:	  if (!(p - beg == 2 && (*p == '/' || *p == '\\') && isalpha (*beg)))
        -:10454:#endif
      525:10455:	  goto done_word;
        -:10456:
       63:10457:        case '$':
       63:10458:          c = *(p++);
       63:10459:          if (c == '$')
branch  0 taken 0 (fallthrough)
branch  1 taken 63
    #####:10460:            break;
        -:10461:
        -:10462:          /* This is a variable reference, so note that it's expandable.
        -:10463:             Then read it to the matching close paren.  */
       63:10464:          wtype = w_variable;
        -:10465:
       63:10466:          if (c == '(')
branch  0 taken 63 (fallthrough)
branch  1 taken 0
       63:10467:            closeparen = ')';
    #####:10468:          else if (c == '{')
branch  0 never executed
branch  1 never executed
    #####:10469:            closeparen = '}';
        -:10470:          else
        -:10471:            /* This is a single-letter variable reference.  */
    #####:10472:            break;
        -:10473:
      420:10474:          for (count=0; *p != '\0'; ++p)
branch  0 taken 420
branch  1 taken 0 (fallthrough)
        -:10475:            {
      420:10476:              if (*p == c)
branch  0 taken 0 (fallthrough)
branch  1 taken 420
    #####:10477:                ++count;
      420:10478:              else if (*p == closeparen && --count < 0)
branch  0 taken 63 (fallthrough)
branch  1 taken 357
branch  2 taken 63 (fallthrough)
branch  3 taken 0
        -:10479:                {
       63:10480:                  ++p;
       63:10481:                  break;
        -:10482:                }
        -:10483:            }
       63:10484:          break;
        -:10485:
    #####:10486:        case '?':
        -:10487:        case '+':
    #####:10488:          if (*p == '=')
branch  0 never executed
branch  1 never executed
    #####:10489:            goto done_word;
    #####:10490:          break;
        -:10491:
    #####:10492:        case '\\':
    #####:10493:          switch (*p)
branch  0 never executed
branch  1 never executed
        -:10494:            {
    #####:10495:            case ';':
        -:10496:            case '=':
        -:10497:            case '\\':
    #####:10498:              ++p;
    #####:10499:              break;
        -:10500:            }
    #####:10501:          break;
        -:10502:
     7581:10503:        default:
    7581*:10504:          if (delim && index(delim, c))
branch  0 taken 0 (fallthrough)
branch  1 taken 7581
branch  2 never executed
branch  3 never executed
    #####:10505:            goto done_word;
     7581:10506:          break;
        -:10507:        }
        -:10508:
     7644:10509:      c = *(p++);
        -:10510:    }
     1113:10511: done_word:
     1113:10512:  --p;
        -:10513:
     2058:10514: done:
     2058:10515:  if (startp)
branch  0 taken 1617 (fallthrough)
branch  1 taken 441
     1617:10516:    *startp = beg;
     2058:10517:  if (length)
branch  0 taken 1617 (fallthrough)
branch  1 taken 441
     1617:10518:    *length = p - beg;
     2058:10519:  return wtype;
        -:10520:}
        -:10521:
        -:10522:/* Construct the list of include directories
        -:10523:   from the arguments and the default list.  */
        -:10524:
        -:10525:void
function construct_include_path called 790 returned 100% blocks executed 78%
      790:10526:construct_include_path (arg_dirs)
        -:10527:     char **arg_dirs;
        -:10528:{
        -:10529:  register unsigned int i;
        -:10530:#ifdef VAXC		/* just don't ask ... */
        -:10531:  stat_t stbuf;
        -:10532:#else
        -:10533:  struct stat stbuf;
        -:10534:#endif
        -:10535:  /* Table to hold the dirs.  */
        -:10536:
      790:10537:  register unsigned int defsize = (sizeof (default_include_directories)
        -:10538:				   / sizeof (default_include_directories[0]));
      790:10539:  register unsigned int max = 5;
      790:10540:  register char **dirs = (char **) xmalloc ((5 + defsize) * sizeof (char *));
call    0 returned 790
      790:10541:  register unsigned int idx = 0;
        -:10542:
        -:10543:#ifdef  __MSDOS__
        -:10544:  defsize++;
        -:10545:#endif
        -:10546:
        -:10547:  /* First consider any dirs specified with -I switches.
        -:10548:     Ignore dirs that don't exist.  */
        -:10549:
      790:10550:  if (arg_dirs != 0)
branch  0 taken 5 (fallthrough)
branch  1 taken 785
       10:10551:    while (*arg_dirs != 0)
branch  0 taken 5
branch  1 taken 5 (fallthrough)
        -:10552:      {
        5:10553:	char *dir = *arg_dirs++;
        -:10554:
        5:10555:	if (dir[0] == '~')
branch  0 taken 0 (fallthrough)
branch  1 taken 5
        -:10556:	  {
    #####:10557:	    char *expanded = tilde_expand (dir);
call    0 never executed
    #####:10558:	    if (expanded != 0)
branch  0 never executed
branch  1 never executed
    #####:10559:	      dir = expanded;
        -:10560:	  }
        -:10561:
        5:10562:	if (stat (dir, &stbuf) == 0 && S_ISDIR (stbuf.st_mode))
call    0 returned 5
branch  1 taken 3 (fallthrough)
branch  2 taken 2
branch  3 taken 3 (fallthrough)
branch  4 taken 0
        -:10563:	  {
        3:10564:	    if (idx == max - 1)
branch  0 taken 0 (fallthrough)
branch  1 taken 3
        -:10565:	      {
    #####:10566:		max += 5;
        -:10567:		dirs = (char **)
    #####:10568:		  xrealloc ((char *) dirs, (max + defsize) * sizeof (char *));
call    0 never executed
        -:10569:	      }
        3:10570:	    dirs[idx++] = dir;
        -:10571:	  }
        2:10572:	else if (dir != arg_dirs[-1])
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####:10573:	  free (dir);
        -:10574:      }
        -:10575:
        -:10576:  /* Now add at the end the standard default dirs.  */
        -:10577:
        -:10578:#ifdef  __MSDOS__
        -:10579:  {
        -:10580:    /* The environment variable $DJDIR holds the root of the
        -:10581:       DJGPP directory tree; add ${DJDIR}/include.  */
        -:10582:    struct variable *djdir = lookup_variable ("DJDIR", 5);
        -:10583:
        -:10584:    if (djdir)
        -:10585:      {
        -:10586:	char *defdir = (char *) xmalloc (strlen (djdir->value) + 8 + 1);
        -:10587:
        -:10588:	strcat (strcpy (defdir, djdir->value), "/include");
        -:10589:	dirs[idx++] = defdir;
        -:10590:      }
        -:10591:  }
        -:10592:#endif
        -:10593:
     3950:10594:  for (i = 0; default_include_directories[i] != 0; ++i)
branch  0 taken 3160
branch  1 taken 790 (fallthrough)
     3160:10595:    if (stat (default_include_directories[i], &stbuf) == 0
call    0 returned 3160
branch  1 taken 2370 (fallthrough)
branch  2 taken 790
     2370:10596:	&& S_ISDIR (stbuf.st_mode))
branch  0 taken 2370 (fallthrough)
branch  1 taken 0
     2370:10597:      dirs[idx++] = default_include_directories[i];
        -:10598:
      790:10599:  dirs[idx] = 0;
        -:10600:
        -:10601:  /* Now compute the maximum length of any name in it.  */
        -:10602:
      790:10603:  max_incl_len = 0;
     3163:10604:  for (i = 0; i < idx; ++i)
branch  0 taken 2373
branch  1 taken 790 (fallthrough)
        -:10605:    {
     2373:10606:      unsigned int len = strlen (dirs[i]);
        -:10607:      /* If dir name is written with a trailing slash, discard it.  */
     2373:10608:      if (dirs[i][len - 1] == '/')
branch  0 taken 0 (fallthrough)
branch  1 taken 2373
        -:10609:	/* We can't just clobber a null in because it may have come from
        -:10610:	   a literal string and literal strings may not be writable.  */
    #####:10611:	dirs[i] = savestring (dirs[i], len - 1);
call    0 never executed
     2373:10612:      if (len > max_incl_len)
branch  0 taken 792 (fallthrough)
branch  1 taken 1581
      792:10613:	max_incl_len = len;
        -:10614:    }
        -:10615:
      790:10616:  include_directories_to_search = dirs;
      790:10617:}
        -:10618:
        -:10619:/* Expand ~ or ~USER at the beginning of NAME.
        -:10620:   Return a newly malloc'd string or 0.  */
        -:10621:
        -:10622:char *
function tilde_expand called 0 returned 0% blocks executed 0%
    #####:10623:tilde_expand (name)
        -:10624:     char *name;
        -:10625:{
        -:10626:#ifndef VMS
    #####:10627:  if (name[1] == '/' || name[1] == '\0')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:10628:    {
        -:10629:      extern char *getenv ();
        -:10630:      char *home_dir;
        -:10631:      int is_variable;
        -:10632:
        -:10633:      {
        -:10634:	/* Turn off --warn-undefined-variables while we expand HOME.  */
    #####:10635:	int save = warn_undefined_variables_flag;
    #####:10636:	warn_undefined_variables_flag = 0;
        -:10637:
    #####:10638:	home_dir = allocated_variable_expand ("$(HOME)");
call    0 never executed
        -:10639:
    #####:10640:	warn_undefined_variables_flag = save;
        -:10641:      }
        -:10642:
    #####:10643:      is_variable = home_dir[0] != '\0';
    #####:10644:      if (!is_variable)
branch  0 never executed
branch  1 never executed
        -:10645:	{
    #####:10646:	  free (home_dir);
    #####:10647:	  home_dir = getenv ("HOME");
call    0 never executed
        -:10648:	}
        -:10649:#if !defined(_AMIGA) && !defined(WINDOWS32)
    #####:10650:      if (home_dir == 0 || home_dir[0] == '\0')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:10651:	{
        -:10652:	  extern char *getlogin ();
    #####:10653:	  char *logname = getlogin ();
call    0 never executed
    #####:10654:	  home_dir = 0;
    #####:10655:	  if (logname != 0)
branch  0 never executed
branch  1 never executed
        -:10656:	    {
    #####:10657:	      struct passwd *p = getpwnam (logname);
call    0 never executed
    #####:10658:	      if (p != 0)
branch  0 never executed
branch  1 never executed
    #####:10659:		home_dir = p->pw_dir;
        -:10660:	    }
        -:10661:	}
        -:10662:#endif /* !AMIGA && !WINDOWS32 */
    #####:10663:      if (home_dir != 0)
branch  0 never executed
branch  1 never executed
        -:10664:	{
    #####:10665:	  char *new = concat (home_dir, "", name + 1);
call    0 never executed
    #####:10666:	  if (is_variable)
branch  0 never executed
branch  1 never executed
    #####:10667:	    free (home_dir);
    #####:10668:	  return new;
        -:10669:	}
        -:10670:    }
        -:10671:#if !defined(_AMIGA) && !defined(WINDOWS32)
        -:10672:  else
        -:10673:    {
        -:10674:      struct passwd *pwent;
    #####:10675:      char *userend = index (name + 1, '/');
    #####:10676:      if (userend != 0)
branch  0 never executed
branch  1 never executed
    #####:10677:	*userend = '\0';
    #####:10678:      pwent = getpwnam (name + 1);
call    0 never executed
    #####:10679:      if (pwent != 0)
branch  0 never executed
branch  1 never executed
        -:10680:	{
    #####:10681:	  if (userend == 0)
branch  0 never executed
branch  1 never executed
    #####:10682:	    return savestring (pwent->pw_dir, strlen (pwent->pw_dir));
call    0 never executed
        -:10683:	  else
    #####:10684:	    return concat (pwent->pw_dir, "/", userend + 1);
call    0 never executed
        -:10685:	}
    #####:10686:      else if (userend != 0)
branch  0 never executed
branch  1 never executed
    #####:10687:	*userend = '/';
        -:10688:    }
        -:10689:#endif /* !AMIGA && !WINDOWS32 */
        -:10690:#endif /* !VMS */
    #####:10691:  return 0;
        -:10692:}
        -:10693:
        -:10694:/* Given a chain of struct nameseq's describing a sequence of filenames,
        -:10695:   in reverse of the intended order, return a new chain describing the
        -:10696:   result of globbing the filenames.  The new chain is in forward order.
        -:10697:   The links of the old chain are freed or used in the new chain.
        -:10698:   Likewise for the names in the old chain.
        -:10699:
        -:10700:   SIZE is how big to construct chain elements.
        -:10701:   This is useful if we want them actually to be other structures
        -:10702:   that have room for additional info.  */
        -:10703:
        -:10704:struct nameseq *
function multi_glob called 8945 returned 100% blocks executed 54%
     8945:10705:multi_glob (chain, size)
        -:10706:     struct nameseq *chain;
        -:10707:     unsigned int size;
        -:10708:{
        -:10709:  extern void dir_setup_glob ();
     8945:10710:  register struct nameseq *new = 0;
        -:10711:  register struct nameseq *old;
        -:10712:  struct nameseq *nexto;
        -:10713:  glob_t gl;
        -:10714:
     8945:10715:  dir_setup_glob (&gl);
call    0 returned 8945
        -:10716:
    44683:10717:  for (old = chain; old != 0; old = nexto)
branch  0 taken 35738
branch  1 taken 8945 (fallthrough)
        -:10718:    {
        -:10719:#ifndef NO_ARCHIVES
        -:10720:      char *memname;
        -:10721:#endif
        -:10722:
    35738:10723:      nexto = old->next;
        -:10724:
    35738:10725:      if (old->name[0] == '~')
branch  0 taken 0 (fallthrough)
branch  1 taken 35738
        -:10726:	{
    #####:10727:	  char *newname = tilde_expand (old->name);
call    0 never executed
    #####:10728:	  if (newname != 0)
branch  0 never executed
branch  1 never executed
        -:10729:	    {
    #####:10730:	      free (old->name);
    #####:10731:	      old->name = newname;
        -:10732:	    }
        -:10733:	}
        -:10734:
        -:10735:#ifndef NO_ARCHIVES
    35738:10736:      if (ar_name (old->name))
call    0 returned 35738
branch  1 taken 0 (fallthrough)
branch  2 taken 35738
        -:10737:	{
        -:10738:	  /* OLD->name is an archive member reference.
        -:10739:	     Replace it with the archive file name,
        -:10740:	     and save the member name in MEMNAME.
        -:10741:	     We will glob on the archive name and then
        -:10742:	     reattach MEMNAME later.  */
        -:10743:	  char *arname;
    #####:10744:	  ar_parse_name (old->name, &arname, &memname);
call    0 never executed
    #####:10745:	  free (old->name);
    #####:10746:	  old->name = arname;
        -:10747:	}
        -:10748:      else
    35738:10749:	memname = 0;
        -:10750:#endif /* !NO_ARCHIVES */
        -:10751:
    35738:10752:      switch (glob (old->name, GLOB_NOCHECK|GLOB_ALTDIRFUNC, NULL, &gl))
call    0 returned 35738
branch  1 taken 35738
branch  2 taken 0
branch  3 taken 0
        -:10753:	{
    35738:10754:	case 0:			/* Success.  */
        -:10755:	  {
    35738:10756:	    register int i = gl.gl_pathc;
    71581:10757:	    while (i-- > 0)
branch  0 taken 35843
branch  1 taken 35738 (fallthrough)
        -:10758:	      {
        -:10759:#ifndef NO_ARCHIVES
    35843:10760:		if (memname != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 35843
        -:10761:		  {
        -:10762:		    /* Try to glob on MEMNAME within the archive.  */
        -:10763:		    struct nameseq *found
    #####:10764:		      = ar_glob (gl.gl_pathv[i], memname, size);
call    0 never executed
    #####:10765:		    if (found == 0)
branch  0 never executed
branch  1 never executed
        -:10766:		      {
        -:10767:			/* No matches.  Use MEMNAME as-is.  */
        -:10768:			struct nameseq *elt
    #####:10769:			  = (struct nameseq *) xmalloc (size);
call    0 never executed
    #####:10770:			unsigned int alen = strlen (gl.gl_pathv[i]);
    #####:10771:			unsigned int mlen = strlen (memname);
    #####:10772:			elt->name = (char *) xmalloc (alen + 1 + mlen + 2);
call    0 never executed
    #####:10773:			bcopy (gl.gl_pathv[i], elt->name, alen);
    #####:10774:			elt->name[alen] = '(';
    #####:10775:			bcopy (memname, &elt->name[alen + 1], mlen);
    #####:10776:			elt->name[alen + 1 + mlen] = ')';
    #####:10777:			elt->name[alen + 1 + mlen + 1] = '\0';
    #####:10778:			elt->next = new;
    #####:10779:			new = elt;
        -:10780:		      }
        -:10781:		    else
        -:10782:		      {
        -:10783:			/* Find the end of the FOUND chain.  */
    #####:10784:			struct nameseq *f = found;
    #####:10785:			while (f->next != 0)
branch  0 never executed
branch  1 never executed
    #####:10786:			  f = f->next;
        -:10787:
        -:10788:			/* Attach the chain being built to the end of the FOUND
        -:10789:			   chain, and make FOUND the new NEW chain.  */
    #####:10790:			f->next = new;
    #####:10791:			new = found;
        -:10792:		      }
        -:10793:
    #####:10794:		    free (memname);
        -:10795:		  }
        -:10796:		else
        -:10797:#endif /* !NO_ARCHIVES */
        -:10798:		  {
    35843:10799:		    struct nameseq *elt = (struct nameseq *) xmalloc (size);
call    0 returned 35843
    71686:10800:		    elt->name = savestring (gl.gl_pathv[i],
    35843:10801:					    strlen (gl.gl_pathv[i]));
call    0 returned 35843
    35843:10802:		    elt->next = new;
    35843:10803:		    new = elt;
        -:10804:		  }
        -:10805:	      }
    35738:10806:	    globfree (&gl);
call    0 returned 35738
    35738:10807:	    free (old->name);
    35738:10808:	    free ((char *)old);
    35738:10809:	    break;
        -:10810:	  }
        -:10811:
    #####:10812:	case GLOB_NOSPACE:
    #####:10813:	  fatal ("virtual memory exhausted");
call    0 never executed
        -:10814:	  break;
        -:10815:
    #####:10816:	default:
    #####:10817:	  old->next = new;
    #####:10818:	  new = old;
    #####:10819:	  break;
        -:10820:	}
        -:10821:    }
        -:10822:
     8945:10823:  return new;
        -:10824:}
        -:10825:
        -:10826:
        -:10827:
        -:10828:/*************************************************************
        -:10829:  ============================================================
        -:10830:  ************************************************************
        -:10831:  ============================================================
        -:10832:  ************************************************************
        -:10833:                         remake.c
        -:10834:  ************************************************************
        -:10835:  ============================================================
        -:10836:  ************************************************************
        -:10837:  ============================================================
        -:10838:  *************************************************************/
        -:10839:
        -:10840:/* Basic dependency engine for GNU Make.
        -:10841:Copyright (C) 1988,89,90,91,92,93,94,95,96,97 Free Software Foundation, Inc.
        -:10842:This file is part of GNU Make.
        -:10843:
        -:10844:GNU Make is free software; you can redistribute it and/or modify
        -:10845:it under the terms of the GNU General Public License as published by
        -:10846:the Free Software Foundation; either version 2, or (at your option)
        -:10847:any later version.
        -:10848:
        -:10849:GNU Make is distributed in the hope that it will be useful,
        -:10850:but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:10851:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:10852:GNU General Public License for more details.
        -:10853:
        -:10854:You should have received a copy of the GNU General Public License
        -:10855:along with GNU Make; see the file COPYING.  If not, write to
        -:10856:the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
        -:10857:
        -:10858:
        -:10859:
        -:10860:#ifdef HAVE_FCNTL_H
        -:10861:#include <fcntl.h>
        -:10862:#undef stderr
        -:10863:#define stderr stdout
        -:10864:#else
        -:10865:#include <sys/file.h>
        -:10866:#undef stderr
        -:10867:#define stderr stdout
        -:10868:#endif
        -:10869:
        -:10870:#ifdef  __MSDOS__
        -:10871:#include "variable.h"
        -:10872:#undef stderr
        -:10873:#define stderr stdout
        -:10874:#endif
        -:10875:
        -:10876:#ifdef VMS
        -:10877:#include <starlet.h>
        -:10878:#undef stderr
        -:10879:#define stderr stdout
        -:10880:#endif
        -:10881:#ifdef WINDOWS32
        -:10882:#include <io.h>
        -:10883:#undef stderr
        -:10884:#define stderr stdout
        -:10885:#endif
        -:10886:
        -:10887:extern int try_implicit_rule PARAMS ((struct file *file, unsigned int depth));
        -:10888:
        -:10889:
        -:10890:/* Incremented when a command is started (under -n, when one would be).  */
        -:10891:unsigned int commands_started = 0;
        -:10892:
        -:10893:static int update_file PARAMS ((struct file *file, unsigned int depth));
        -:10894:static int update_file_1 PARAMS ((struct file *file, unsigned int depth));
        -:10895:static int check_dep PARAMS ((struct file *file, unsigned int depth, time_t this_mtime, int *must_make_ptr));
        -:10896:static int touch_file PARAMS ((struct file *file));
        -:10897:static void remake_file PARAMS ((struct file *file));
        -:10898:static time_t name_mtime PARAMS ((char *name));
        -:10899:static int library_search PARAMS ((char **lib, time_t *mtime_ptr));
        -:10900:
        -:10901:extern time_t f_mtime PARAMS ((struct file *file, int search));
        -:10902:
        -:10903:
        -:10904:/* Remake all the goals in the `struct dep' chain GOALS.  Return -1 if nothing
        -:10905:   was done, 0 if all goals were updated successfully, or 1 if a goal failed.
        -:10906:   If MAKEFILES is nonzero, these goals are makefiles, so -t, -q, and -n should
        -:10907:   be disabled for them unless they were also command-line targets, and we
        -:10908:   should only make one goal at a time and return as soon as one goal whose
        -:10909:   `changed' member is nonzero is successfully made.  */
        -:10910:
        -:10911:int
function update_goal_chain called 806 returned 36% blocks executed 73%
      806:10912:update_goal_chain (goals, makefiles)
        -:10913:     register struct dep *goals;
        -:10914:     int makefiles;
        -:10915:{
      806:10916:  int t = touch_flag, q = question_flag, n = just_print_flag;
      806:10917:  unsigned int j = job_slots;
      806:10918:  int status = -1;
        -:10919:
        -:10920:#define	MTIME(file) (makefiles ? file_mtime_no_search (file) \
        -:10921:		     : file_mtime (file))
        -:10922:
        -:10923:  /* Duplicate the chain so we can remove things from it.  */
        -:10924:
      806:10925:  goals = copy_dep_chain (goals);
call    0 returned 806
        -:10926:
        -:10927:  {
        -:10928:    /* Clear the `changed' flag of each goal in the chain.
        -:10929:       We will use the flag below to notice when any commands
        -:10930:       have actually been run for a target.  When no commands
        -:10931:       have been run, we give an "up to date" diagnostic.  */
        -:10932:
        -:10933:    struct dep *g;
     1617:10934:    for (g = goals; g != 0; g = g->next)
branch  0 taken 811
branch  1 taken 806 (fallthrough)
      811:10935:      g->changed = 0;
        -:10936:  }
        -:10937:
        -:10938:#if 0
        -:10939:  /* Only run one job at a time when building makefiles.
        -:10940:     No one seems to know why this was done, and no one can think of a good
        -:10941:     reason to do it.  Hopefully an obvious one won't appear as soon as we
        -:10942:     release the next version :-/.  */
        -:10943:  if (makefiles)
        -:10944:    job_slots = 1;
        -:10945:#endif
        -:10946:
        -:10947:  /* Update all the goals until they are all finished.  */
        -:10948:
     1093:10949:  while (goals != 0)
branch  0 taken 806
branch  1 taken 287 (fallthrough)
        -:10950:    {
        -:10951:      register struct dep *g, *lastgoal;
        -:10952:
        -:10953:      /* Start jobs that are waiting for the load to go down.  */
        -:10954:
      806:10955:      start_waiting_jobs ();
call    0 returned 806
        -:10956:
        -:10957:      /* Wait for a child to die.  */
        -:10958:
      806:10959:      reap_children (1, 0);
call    0 returned 806
        -:10960:
      806:10961:      lastgoal = 0;
      806:10962:      g = goals;
     1096:10963:      while (g != 0)
branch  0 taken 809
branch  1 taken 287 (fallthrough)
        -:10964:	{
        -:10965:	  /* Iterate over all double-colon entries for this file.  */
      809:10966:	  struct file *file = g->file;
      809:10967:	  int stop = 0, any_not_updated = 0;
        -:10968:
     809*:10969:	  for (file = g->file->double_colon ? g->file->double_colon : g->file;
branch  0 taken 0 (fallthrough)
branch  1 taken 809
     1099:10970:	       file != NULL;
branch  0 taken 809
branch  1 taken 290 (fallthrough)
      290:10971:	       file = file->prev)
        -:10972:	    {
        -:10973:	      unsigned int ocommands_started;
        -:10974:	      int x;
     809*:10975:	      time_t mtime = MTIME (file);
branch  0 taken 793 (fallthrough)
branch  1 taken 16
branch  2 taken 793 (fallthrough)
branch  3 taken 0
call    4 never executed
branch  5 taken 16 (fallthrough)
branch  6 taken 0
call    7 never executed
     809*:10976:	      check_renamed (file);
branch  0 taken 0
branch  1 taken 809 (fallthrough)
      809:10977:	      if (makefiles)
branch  0 taken 793 (fallthrough)
branch  1 taken 16
        -:10978:		{
      793:10979:		  if (file->cmd_target)
branch  0 taken 0 (fallthrough)
branch  1 taken 793
        -:10980:		    {
    #####:10981:		      touch_flag = t;
    #####:10982:		      question_flag = q;
    #####:10983:		      just_print_flag = n;
        -:10984:		    }
        -:10985:		  else
      793:10986:		    touch_flag = question_flag = just_print_flag = 0;
        -:10987:		}
        -:10988:
        -:10989:	      /* Save the old value of `commands_started' so we can compare
        -:10990:		 later.  It will be incremented when any commands are
        -:10991:		 actually run.  */
      809:10992:	      ocommands_started = commands_started;
        -:10993:
      809:10994:	      x = update_file (file, makefiles ? 1 : 0);
call    0 returned 290
     290*:10995:	      check_renamed (file);
branch  0 taken 0
branch  1 taken 290 (fallthrough)
        -:10996:
        -:10997:	      /* Set the goal's `changed' flag if any commands were started
        -:10998:		 by calling update_file above.  We check this flag below to
        -:10999:		 decide when to give an "up to date" diagnostic.  */
      290:11000:	      g->changed += commands_started - ocommands_started;
        -:11001:
      290:11002:	      stop = 0;
      290:11003:	      if (x != 0 || file->updated)
branch  0 taken 34 (fallthrough)
branch  1 taken 256
branch  2 taken 34 (fallthrough)
branch  3 taken 0
        -:11004:		{
        -:11005:		  /* If STATUS was not already 1, set it to 1 if
        -:11006:		     updating failed, or to 0 if updating succeeded.
        -:11007:		     Leave STATUS as it is if no updating was done.  */
        -:11008:
      290:11009:		  if (status < 1)
branch  0 taken 290 (fallthrough)
branch  1 taken 0
        -:11010:		    {
      290:11011:		      if (file->update_status != 0)
branch  0 taken 256 (fallthrough)
branch  1 taken 34
        -:11012:			{
        -:11013:			  /* Updating failed, or -q triggered.
        -:11014:			     The STATUS value tells our caller which.  */
      256:11015:			  status = file->update_status;
        -:11016:			  /* If -q just triggered, stop immediately.
        -:11017:			     It doesn't matter how much more we run,
        -:11018:			     since we already know the answer to return.  */
     256*:11019:			  stop = (!keep_going_flag && !question_flag
branch  0 never executed
branch  1 never executed
     256*:11020:				  && !makefiles);
branch  0 taken 0 (fallthrough)
branch  1 taken 256
branch  2 never executed
branch  3 never executed
        -:11021:			}
      34*:11022:		      else if (MTIME (file) != mtime)
branch  0 taken 20 (fallthrough)
branch  1 taken 14
branch  2 taken 20 (fallthrough)
branch  3 taken 0
call    4 never executed
branch  5 taken 14 (fallthrough)
branch  6 taken 0
call    7 never executed
branch  8 taken 0 (fallthrough)
branch  9 taken 34
        -:11023:			{
        -:11024:			  /* Updating was done.  If this is a makefile and
        -:11025:			     just_print_flag or question_flag is set
        -:11026:			     (meaning -n or -q was given and this file was
        -:11027:			     specified as a command-line target), don't
        -:11028:			     change STATUS.  If STATUS is changed, we will
        -:11029:			     get re-exec'd, and fall into an infinite loop.  */
    #####:11030:			  if (!makefiles
branch  0 never executed
branch  1 never executed
    #####:11031:			      || (!just_print_flag && !question_flag))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:11032:			    status = 0;
    #####:11033:			  if (makefiles && file->dontcare)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:11034:			    /* This is a default makefile.  Stop remaking.  */
    #####:11035:			    stop = 1;
        -:11036:			}
        -:11037:		    }
        -:11038:		}
        -:11039:
        -:11040:	      /* Keep track if any double-colon entry is not finished.
        -:11041:                 When they are all finished, the goal is finished.  */
      290:11042:	      any_not_updated |= !file->updated;
        -:11043:
      290:11044:	      if (stop)
branch  0 taken 0 (fallthrough)
branch  1 taken 290
    #####:11045:		break;
        -:11046:	    }
        -:11047:
        -:11048:	  /* Reset FILE since it is null at the end of the loop.  */
      290:11049:	  file = g->file;
        -:11050:
      290:11051:	  if (stop || !any_not_updated)
branch  0 taken 290 (fallthrough)
branch  1 taken 0
branch  2 taken 290 (fallthrough)
branch  3 taken 0
        -:11052:	    {
        -:11053:	      /* If we have found nothing whatever to do for the goal,
        -:11054:		 print a message saying nothing needs doing.  */
        -:11055:
      290:11056:	      if (!makefiles
branch  0 taken 14 (fallthrough)
branch  1 taken 276
        -:11057:		  /* If the update_status is zero, we updated successfully
        -:11058:		     or not at all.  G->changed will have been set above if
        -:11059:		     any commands were actually started for this goal.  */
       14:11060:		  && file->update_status == 0 && !g->changed
branch  0 taken 14 (fallthrough)
branch  1 taken 0
branch  2 taken 13 (fallthrough)
branch  3 taken 1
        -:11061:		  /* Never give a message under -s or -q.  */
       13:11062:		  && !silent_flag && !question_flag)
branch  0 taken 13 (fallthrough)
branch  1 taken 0
branch  2 taken 12 (fallthrough)
branch  3 taken 1
      12*:11063:		message (1, ((file->phony || file->cmds == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 12
branch  2 never executed
branch  3 never executed
call    4 returned 12
        -:11064:			     ? "Nothing to be done for `%s'."
        -:11065:			     : "`%s' is up to date."),
        -:11066:			 file->name);
        -:11067:
        -:11068:	      /* This goal is finished.  Remove it from the chain.  */
      290:11069:	      if (lastgoal == 0)
branch  0 taken 290 (fallthrough)
branch  1 taken 0
      290:11070:		goals = g->next;
        -:11071:	      else
    #####:11072:		lastgoal->next = g->next;
        -:11073:
        -:11074:	      /* Free the storage.  */
      290:11075:	      free ((char *) g);
        -:11076:
     290*:11077:	      g = lastgoal == 0 ? goals : lastgoal->next;
branch  0 taken 0 (fallthrough)
branch  1 taken 290
        -:11078:
      290:11079:	      if (stop)
branch  0 taken 0 (fallthrough)
branch  1 taken 290
    #####:11080:		break;
        -:11081:	    }
        -:11082:	  else
        -:11083:	    {
    #####:11084:	      lastgoal = g;
    #####:11085:	      g = g->next;
        -:11086:	    }
        -:11087:	}
        -:11088:    }
        -:11089:
      287:11090:  if (makefiles)
branch  0 taken 273 (fallthrough)
branch  1 taken 14
        -:11091:    {
      273:11092:      touch_flag = t;
      273:11093:      question_flag = q;
      273:11094:      just_print_flag = n;
      273:11095:      job_slots = j;
        -:11096:    }
      287:11097:  return status;
        -:11098:}
        -:11099:
        -:11100:/* Generate an error/fatal message if no rules are available for the target.
        -:11101: */
        -:11102:static void
function no_rule_error called 773 returned 33% blocks executed 91%
      773:11103:no_rule_error(file)
        -:11104:  struct file *file;
        -:11105:{
        -:11106:  static const char msg_noparent[]
        -:11107:    = "%sNo rule to make target `%s'%s";
        -:11108:  static const char msg_parent[]
        -:11109:    = "%sNo rule to make target `%s', needed by `%s'%s";
      773:11110:  if (keep_going_flag || file->dontcare)
branch  0 taken 517 (fallthrough)
branch  1 taken 256
branch  2 taken 0 (fallthrough)
branch  3 taken 517
        -:11111:    {
      256:11112:      if (!file->dontcare)
branch  0 taken 256 (fallthrough)
branch  1 taken 0
        -:11113:        {
      256:11114:          if (file->parent == 0)
branch  0 taken 256 (fallthrough)
branch  1 taken 0
      256:11115:            error (msg_noparent, "*** ", file->name, ".");
call    0 returned 256
        -:11116:          else
    #####:11117:            error (msg_parent, "*** ",
    #####:11118:                   file->name, file->parent->name, ".");
call    0 never executed
      256:11119:          file->shownerror = 1;
        -:11120:        }
      256:11121:      file->update_status = 2;
        -:11122:    }
        -:11123:  else
        -:11124:    {
      517:11125:      if (file->parent == 0)
branch  0 taken 517 (fallthrough)
branch  1 taken 0
      517:11126:        fatal (msg_noparent, "", file->name, "");
call    0 returned 0
        -:11127:      else
    #####:11128:        fatal (msg_parent, "", file->name, file->parent->name, "");
        -:11129:    }
      256:11130:}
        -:11131:
        -:11132:/* If FILE is not up to date, execute the commands for it.
        -:11133:   Return 0 if successful, 1 if unsuccessful;
        -:11134:   but with some flag settings, just call `exit' if unsuccessful.
        -:11135:
        -:11136:   DEPTH is the depth in recursions of this function.
        -:11137:   We increment it during the consideration of our dependencies,
        -:11138:   then decrement it again after finding out whether this file
        -:11139:   is out of date.
        -:11140:
        -:11141:   If there are multiple double-colon entries for FILE,
        -:11142:   each is considered in turn.  */
        -:11143:
        -:11144:static int
function update_file called 1078 returned 52% blocks executed 67%
     1078:11145:update_file (file, depth)
        -:11146:     struct file *file;
        -:11147:     unsigned int depth;
        -:11148:{
     1078:11149:  register int status = 0;
        -:11150:  register struct file *f;
        -:11151:
    1635*:11152:  for (f = file->double_colon ? file->double_colon : file; f != 0; f = f->prev)
branch  0 taken 0 (fallthrough)
branch  1 taken 1078
branch  2 taken 1078
branch  3 taken 557 (fallthrough)
        -:11153:    {
     1078:11154:      status |= update_file_1 (f, depth);
call    0 returned 557
     557*:11155:      check_renamed (f);
branch  0 taken 0
branch  1 taken 557 (fallthrough)
        -:11156:
      557:11157:      if (status != 0 && !keep_going_flag)
branch  0 taken 256 (fallthrough)
branch  1 taken 301
branch  2 taken 0 (fallthrough)
branch  3 taken 256
    #####:11158:	return status;
        -:11159:
      557:11160:      switch (f->command_state)
branch  0 taken 557
branch  1 taken 0
branch  2 taken 0
        -:11161:	{
      557:11162:	case cs_finished:
        -:11163:	  /* The file is done being remade.  */
      557:11164:	  break;
        -:11165:
    #####:11166:	case cs_running:
        -:11167:	case cs_deps_running:
        -:11168:	  /* Don't run the other :: rules for this
        -:11169:	     file until this rule is finished.  */
    #####:11170:	  return 0;
        -:11171:
    #####:11172:	default:
    #####:11173:	  assert (f->command_state == cs_running);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:11174:	  break;
        -:11175:	}
        -:11176:    }
        -:11177:
      557:11178:  return status;
        -:11179:}
        -:11180:
        -:11181:/* Consider a single `struct file' and update it as appropriate.  */
        -:11182:
        -:11183:static int
function update_file_1 called 1078 returned 52% blocks executed 42%
     1078:11184:update_file_1 (file, depth)
        -:11185:     struct file *file;
        -:11186:     unsigned int depth;
        -:11187:{
        -:11188:  register time_t this_mtime;
        -:11189:  int noexist, must_make, deps_changed;
     1078:11190:  int dep_status = 0;
        -:11191:  register struct dep *d, *lastd;
     1078:11192:  int running = 0;
        -:11193:
     1078:11194:  DEBUGPR ("Considering target file `%s'.\n");
branch  0 taken 384 (fallthrough)
branch  1 taken 694
call    2 returned 384
call    3 returned 384
call    4 returned 384
        -:11195:
     1078:11196:  if (file->updated)
branch  0 taken 66 (fallthrough)
branch  1 taken 1012
        -:11197:    {
       66:11198:      if (file->update_status > 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 66
        -:11199:	{
    #####:11200:	  DEBUGPR ("Recently tried and failed to update file `%s'.\n");
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:11201:          if (!file->shownerror)
branch  0 never executed
branch  1 never executed
        -:11202:            {
    #####:11203:              int dontcare = file->dontcare;
    #####:11204:              file->dontcare = 0;
    #####:11205:              no_rule_error(file);
call    0 never executed
    #####:11206:              file->dontcare = dontcare;
        -:11207:            }
    #####:11208:	  return file->update_status;
        -:11209:	}
        -:11210:
      66*:11211:      DEBUGPR ("File `%s' was considered already.\n");
branch  0 taken 0 (fallthrough)
branch  1 taken 66
call    2 never executed
call    3 never executed
call    4 never executed
       66:11212:      return 0;
        -:11213:    }
        -:11214:
     1012:11215:  switch (file->command_state)
branch  0 taken 1012
branch  1 taken 0
branch  2 taken 0
branch  3 taken 0
        -:11216:    {
     1012:11217:    case cs_not_started:
        -:11218:    case cs_deps_running:
     1012:11219:      break;
    #####:11220:    case cs_running:
    #####:11221:      DEBUGPR ("Still updating file `%s'.\n");
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:11222:      return 0;
    #####:11223:    case cs_finished:
    #####:11224:      DEBUGPR ("Finished updating file `%s'.\n");
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:11225:      return file->update_status;
    #####:11226:    default:
    #####:11227:      abort ();
call    0 never executed
        -:11228:    }
        -:11229:
     1012:11230:  ++depth;
        -:11231:
        -:11232:  /* Notice recursive update of the same file.  */
     1012:11233:  file->updating = 1;
        -:11234:
        -:11235:  /* Looking at the file's modtime beforehand allows the possibility
        -:11236:     that its name may be changed by a VPATH search, and thus it may
        -:11237:     not need an implicit rule.  If this were not done, the file
        -:11238:     might get implicit commands that apply to its initial name, only
        -:11239:     to have that name replaced with another found by VPATH search.  */
        -:11240:
    1012*:11241:  this_mtime = file_mtime (file);
branch  0 taken 1012 (fallthrough)
branch  1 taken 0
call    2 never executed
    1012*:11242:  check_renamed (file);
branch  0 taken 0
branch  1 taken 1012 (fallthrough)
     1012:11243:  noexist = this_mtime == (time_t) -1;
     1012:11244:  if (noexist)
branch  0 taken 790 (fallthrough)
branch  1 taken 222
      790:11245:    DEBUGPR ("File `%s' does not exist.\n");
branch  0 taken 384 (fallthrough)
branch  1 taken 406
call    2 returned 384
call    3 returned 384
call    4 returned 384
        -:11246:
     1012:11247:  must_make = noexist;
        -:11248:
        -:11249:  /* If file was specified as a target with no commands,
        -:11250:     come up with some default commands.  */
        -:11251:
     1012:11252:  if (!file->phony && file->cmds == 0 && !file->tried_implicit)
branch  0 taken 996 (fallthrough)
branch  1 taken 16
branch  2 taken 948 (fallthrough)
branch  3 taken 48
branch  4 taken 948 (fallthrough)
branch  5 taken 0
        -:11253:    {
      948:11254:      if (try_implicit_rule (file, depth))
call    0 returned 948
branch  1 taken 60 (fallthrough)
branch  2 taken 888
      60*:11255:	DEBUGPR ("Found an implicit rule for `%s'.\n");
branch  0 taken 0 (fallthrough)
branch  1 taken 60
call    2 never executed
call    3 never executed
call    4 never executed
        -:11256:      else
      888:11257:	DEBUGPR ("No implicit rule found for `%s'.\n");
branch  0 taken 384 (fallthrough)
branch  1 taken 504
call    2 returned 384
call    3 returned 384
call    4 returned 384
      948:11258:      file->tried_implicit = 1;
        -:11259:    }
     1012:11260:  if (file->cmds == 0 && !file->is_target
branch  0 taken 904 (fallthrough)
branch  1 taken 108
branch  2 taken 885 (fallthrough)
branch  3 taken 19
      885:11261:      && default_file != 0 && default_file->cmds != 0)
branch  0 taken 885 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 885
        -:11262:    {
    #####:11263:      DEBUGPR ("Using default commands for `%s'.\n");
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:11264:      file->cmds = default_file->cmds;
        -:11265:    }
        -:11266:
        -:11267:  /* Update all non-intermediate files we depend on, if necessary,
        -:11268:     and see whether any of them is more recent than this file.  */
        -:11269:
     1012:11270:  lastd = 0;
     1012:11271:  d = file->deps;
     1279:11272:  while (d != 0)
branch  0 taken 269
branch  1 taken 1010 (fallthrough)
        -:11273:    {
        -:11274:      time_t mtime;
        -:11275:
     269*:11276:      check_renamed (d->file);
branch  0 taken 0
branch  1 taken 269 (fallthrough)
        -:11277:
      269:11278:      mtime = file_mtime (d->file);
branch  0 taken 68 (fallthrough)
branch  1 taken 201
call    2 returned 201
     269*:11279:      check_renamed (d->file);
branch  0 taken 0
branch  1 taken 269 (fallthrough)
        -:11280:
     269*:11281:      if (d->file->updating)
branch  0 taken 0 (fallthrough)
branch  1 taken 269
        -:11282:	{
    #####:11283:	  error ("Circular %s <- %s dependency dropped.",
    #####:11284:		 file->name, d->file->name);
call    0 never executed
        -:11285:	  /* We cannot free D here because our the caller will still have
        -:11286:	     a reference to it when we were called recursively via
        -:11287:	     check_dep below.  */
    #####:11288:	  if (lastd == 0)
branch  0 never executed
branch  1 never executed
    #####:11289:	    file->deps = d->next;
        -:11290:	  else
    #####:11291:	    lastd->next = d->next;
    #####:11292:	  d = d->next;
    #####:11293:	  continue;
        -:11294:	}
        -:11295:
      269:11296:      d->file->parent = file;
      269:11297:      dep_status |= check_dep (d->file, depth, this_mtime, &must_make);
call    0 returned 267
     267*:11298:      check_renamed (d->file);
branch  0 taken 0
branch  1 taken 267 (fallthrough)
        -:11299:
        -:11300:      {
      267:11301:	register struct file *f = d->file;
      267:11302:	if (f->double_colon)
branch  0 taken 0 (fallthrough)
branch  1 taken 267
    #####:11303:	  f = f->double_colon;
        -:11304:	do
        -:11305:	  {
      534:11306:	    running |= (f->command_state == cs_running
     267*:11307:			|| f->command_state == cs_deps_running);
branch  0 taken 267 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 267
      267:11308:	    f = f->prev;
        -:11309:	  }
      267:11310:	while (f != 0);
branch  0 taken 0
branch  1 taken 267 (fallthrough)
        -:11311:      }
        -:11312:
     267*:11313:      if (dep_status != 0 && !keep_going_flag)
branch  0 taken 0 (fallthrough)
branch  1 taken 267
branch  2 never executed
branch  3 never executed
    #####:11314:	break;
        -:11315:
      267:11316:      if (!running)
branch  0 taken 267 (fallthrough)
branch  1 taken 0
     267*:11317:	d->changed = file_mtime (d->file) != mtime;
branch  0 taken 267 (fallthrough)
branch  1 taken 0
call    2 never executed
        -:11318:
      267:11319:      lastd = d;
      267:11320:      d = d->next;
        -:11321:    }
        -:11322:
        -:11323:  /* Now we know whether this target needs updating.
        -:11324:     If it does, update all the intermediate files we depend on.  */
        -:11325:
     1010:11326:  if (must_make)
branch  0 taken 791 (fallthrough)
branch  1 taken 219
        -:11327:    {
      820:11328:      for (d = file->deps; d != 0; d = d->next)
branch  0 taken 29
branch  1 taken 791 (fallthrough)
       29:11329:	if (d->file->intermediate)
branch  0 taken 0 (fallthrough)
branch  1 taken 29
        -:11330:	  {
    #####:11331:	    time_t mtime = file_mtime (d->file);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:11332:	    check_renamed (d->file);
branch  0 never executed
branch  1 never executed
    #####:11333:	    d->file->parent = file;
    #####:11334:	    dep_status |= update_file (d->file, depth);
call    0 never executed
    #####:11335:	    check_renamed (d->file);
branch  0 never executed
branch  1 never executed
        -:11336:
        -:11337:	    {
    #####:11338:	      register struct file *f = d->file;
    #####:11339:	      if (f->double_colon)
branch  0 never executed
branch  1 never executed
    #####:11340:		f = f->double_colon;
        -:11341:	      do
        -:11342:		{
    #####:11343:		  running |= (f->command_state == cs_running
    #####:11344:			      || f->command_state == cs_deps_running);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:11345:		  f = f->prev;
        -:11346:		}
    #####:11347:	      while (f != 0);
branch  0 never executed
branch  1 never executed
        -:11348:	    }
        -:11349:
    #####:11350:	    if (dep_status != 0 && !keep_going_flag)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:11351:	      break;
        -:11352:
    #####:11353:	    if (!running)
branch  0 never executed
branch  1 never executed
    #####:11354:	      d->changed = ((file->phony && file->cmds != 0)
branch  0 never executed
branch  1 never executed
    #####:11355:			    || file_mtime (d->file) != mtime);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
        -:11356:	  }
        -:11357:    }
        -:11358:
     1010:11359:  file->updating = 0;
        -:11360:
     1010:11361:  DEBUGPR ("Finished dependencies of target file `%s'.\n");
branch  0 taken 384 (fallthrough)
branch  1 taken 626
call    2 returned 384
call    3 returned 384
call    4 returned 384
        -:11362:
     1010:11363:  if (running)
branch  0 taken 0 (fallthrough)
branch  1 taken 1010
        -:11364:    {
    #####:11365:      set_command_state (file, cs_deps_running);
call    0 never executed
    #####:11366:      --depth;
    #####:11367:      DEBUGPR ("The dependencies of `%s' are being made.\n");
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:11368:      return 0;
        -:11369:    }
        -:11370:
        -:11371:  /* If any dependency failed, give up now.  */
        -:11372:
     1010:11373:  if (dep_status != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 1010
        -:11374:    {
    #####:11375:      file->update_status = dep_status;
    #####:11376:      notice_finished_file (file);
call    0 never executed
        -:11377:
    #####:11378:      depth--;
        -:11379:
    #####:11380:      DEBUGPR ("Giving up on target file `%s'.\n");
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:11381:
    #####:11382:      if (depth == 0 && keep_going_flag
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:11383:	  && !just_print_flag && !question_flag)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:11384:	error ("Target `%s' not remade because of errors.", file->name);
call    0 never executed
        -:11385:
    #####:11386:      return dep_status;
        -:11387:    }
        -:11388:
     1010:11389:  if (file->command_state == cs_deps_running)
branch  0 taken 0 (fallthrough)
branch  1 taken 1010
        -:11390:    /* The commands for some deps were running on the last iteration, but
        -:11391:       they have finished now.  Reset the command_state to not_started to
        -:11392:       simplify later bookkeeping.  It is important that we do this only
        -:11393:       when the prior state was cs_deps_running, because that prior state
        -:11394:       was definitely propagated to FILE's also_make's by set_command_state
        -:11395:       (called above), but in another state an also_make may have
        -:11396:       independently changed to finished state, and we would confuse that
        -:11397:       file's bookkeeping (updated, but not_started is bogus state).  */
    #####:11398:    set_command_state (file, cs_not_started);
call    0 never executed
        -:11399:
        -:11400:  /* Now record which dependencies are more
        -:11401:     recent than this file, so we can define $?.  */
        -:11402:
     1010:11403:  deps_changed = 0;
     1277:11404:  for (d = file->deps; d != 0; d = d->next)
branch  0 taken 267
branch  1 taken 1010 (fallthrough)
        -:11405:    {
     267*:11406:      time_t d_mtime = file_mtime (d->file);
branch  0 taken 267 (fallthrough)
branch  1 taken 0
call    2 never executed
     267*:11407:      check_renamed (d->file);
branch  0 taken 0
branch  1 taken 267 (fallthrough)
        -:11408:
        -:11409:#if 1	/* %%% In version 4, remove this code completely to
        -:11410:	   implement not remaking deps if their deps are newer
        -:11411:	   than their parents.  */
     267*:11412:      if (d_mtime == (time_t) -1 && !d->file->intermediate)
branch  0 taken 0 (fallthrough)
branch  1 taken 267
branch  2 never executed
branch  3 never executed
        -:11413:	/* We must remake if this dep does not
        -:11414:	   exist and is not intermediate.  */
    #####:11415:	must_make = 1;
        -:11416:#endif
        -:11417:
        -:11418:      /* Set DEPS_CHANGED if this dep actually changed.  */
      267:11419:      deps_changed |= d->changed;
        -:11420:
        -:11421:      /* Set D->changed if either this dep actually changed,
        -:11422:	 or its dependent, FILE, is older or does not exist.  */
      267:11423:      d->changed |= noexist || d_mtime > this_mtime;
branch  0 taken 246 (fallthrough)
branch  1 taken 21
branch  2 taken 3 (fallthrough)
branch  3 taken 243
        -:11424:
     267*:11425:      if (debug_flag && !noexist)
branch  0 taken 0 (fallthrough)
branch  1 taken 267
branch  2 never executed
branch  3 never executed
        -:11426:	{
    #####:11427:	  print_spaces (depth);
call    0 never executed
    #####:11428:	  if (d_mtime == (time_t) -1)
branch  0 never executed
branch  1 never executed
    #####:11429:	    printf ("Dependency `%s' does not exist.\n", dep_name (d));
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:11430:	  else
    #####:11431:	    printf ("Dependency `%s' is %s than dependent `%s'.\n",
call    0 never executed
    #####:11432:		    dep_name (d), d->changed ? "newer" : "older", file->name);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:11433:	  fflush (stdout);
call    0 never executed
        -:11434:	}
        -:11435:    }
        -:11436:
        -:11437:  /* Here depth returns to the value it had when we were called.  */
     1010:11438:  depth--;
        -:11439:
    1010*:11440:  if (file->double_colon && file->deps == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 1010
branch  2 never executed
branch  3 never executed
        -:11441:    {
    #####:11442:      must_make = 1;
    #####:11443:      DEBUGPR ("Target `%s' is double-colon and has no dependencies.\n");
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:11444:    }
     1010:11445:  else if (!noexist && file->is_target && !deps_changed && file->cmds == 0)
branch  0 taken 222 (fallthrough)
branch  1 taken 788
branch  2 taken 95 (fallthrough)
branch  3 taken 127
branch  4 taken 94 (fallthrough)
branch  5 taken 1
branch  6 taken 3 (fallthrough)
branch  7 taken 91
        -:11446:    {
        3:11447:      must_make = 0;
       3*:11448:      DEBUGPR ("No commands for `%s' and no dependencies actually changed.\n");
branch  0 taken 0 (fallthrough)
branch  1 taken 3
call    2 never executed
call    3 never executed
call    4 never executed
        -:11449:    }
        -:11450:
     1010:11451:  if (!must_make)
branch  0 taken 219 (fallthrough)
branch  1 taken 791
        -:11452:    {
      219:11453:      if (debug_flag)
branch  0 taken 0 (fallthrough)
branch  1 taken 219
        -:11454:        {
    #####:11455:          print_spaces(depth);
call    0 never executed
    #####:11456:          printf("No need to remake target `%s'", file->name);
call    0 never executed
    #####:11457:          if (!streq(file->name, file->hname))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:11458:              printf("; using VPATH name `%s'", file->hname);
call    0 never executed
    #####:11459:          printf(".\n");
call    0 never executed
    #####:11460:          fflush(stdout);
call    0 never executed
        -:11461:        }
        -:11462:
      219:11463:      notice_finished_file (file);
call    0 returned 219
        -:11464:
        -:11465:      /* Since we don't need to remake the file, convert it to use the
        -:11466:         VPATH filename if we found one.  hfile will be either the
        -:11467:         local name if no VPATH or the VPATH name if one was found.  */
        -:11468:
      438:11469:      while (file)
branch  0 taken 219
branch  1 taken 219 (fallthrough)
        -:11470:        {
      219:11471:          file->name = file->hname;
      219:11472:          file = file->prev;
        -:11473:        }
        -:11474:
      219:11475:      return 0;
        -:11476:    }
        -:11477:
      791:11478:  DEBUGPR ("Must remake target `%s'.\n");
branch  0 taken 384 (fallthrough)
branch  1 taken 407
call    2 returned 384
call    3 returned 384
call    4 returned 384
        -:11479:
        -:11480:  /* It needs to be remade.  If it's VPATH and not reset via GPATH, toss the
        -:11481:     VPATH.  */
     791*:11482:  if (!streq(file->name, file->hname))
branch  0 taken 0 (fallthrough)
branch  1 taken 791
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -:11483:    {
    #####:11484:      if (debug_flag)
branch  0 never executed
branch  1 never executed
        -:11485:        {
    #####:11486:          print_spaces (depth);
call    0 never executed
    #####:11487:          printf("  Ignoring VPATH name `%s'.\n", file->hname);
call    0 never executed
    #####:11488:          fflush(stdout);
call    0 never executed
        -:11489:        }
    #####:11490:      file->ignore_vpath = 1;
        -:11491:    }
        -:11492:
        -:11493:  /* Now, take appropriate actions to remake the file.  */
      791:11494:  remake_file (file);
call    0 returned 272
        -:11495:
      272:11496:  if (file->command_state != cs_finished)
branch  0 taken 0 (fallthrough)
branch  1 taken 272
        -:11497:    {
    #####:11498:      DEBUGPR ("Commands of `%s' are being run.\n");
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:11499:      return 0;
        -:11500:    }
        -:11501:
      272:11502:  switch (file->update_status)
branch  0 taken 256
branch  1 taken 16
branch  2 taken 0
branch  3 taken 0
        -:11503:    {
      256:11504:    case 2:
      256:11505:      DEBUGPR ("Failed to remake target file `%s'.\n");
branch  0 taken 128 (fallthrough)
branch  1 taken 128
call    2 returned 128
call    3 returned 128
call    4 returned 128
      256:11506:      break;
       16:11507:    case 0:
      16*:11508:      DEBUGPR ("Successfully remade target file `%s'.\n");
branch  0 taken 0 (fallthrough)
branch  1 taken 16
call    2 never executed
call    3 never executed
call    4 never executed
       16:11509:      break;
    #####:11510:    case 1:
    #####:11511:      DEBUGPR ("Target file `%s' needs remade under -q.\n");
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:11512:      break;
    #####:11513:    default:
    #####:11514:      assert (file->update_status >= 0 && file->update_status <= 2);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:11515:      break;
        -:11516:    }
        -:11517:
      272:11518:  file->updated = 1;
      272:11519:  return file->update_status;
        -:11520:}
        -:11521:
        -:11522:/* Set FILE's `updated' flag and re-check its mtime and the mtime's of all
        -:11523:   files listed in its `also_make' member.  Under -t, this function also
        -:11524:   touches FILE.
        -:11525:
        -:11526:   On return, FILE->update_status will no longer be -1 if it was.  */
        -:11527:
        -:11528:void
function notice_finished_file called 494 returned 100% blocks executed 59%
      494:11529:notice_finished_file (file)
        -:11530:     register struct file *file;
        -:11531:{
        -:11532:  struct dep *d;
      494:11533:  int ran = file->command_state == cs_running;
        -:11534:
      494:11535:  file->command_state = cs_finished;
      494:11536:  file->updated = 1;
        -:11537:
      494:11538:  if (touch_flag
branch  0 taken 11 (fallthrough)
branch  1 taken 483
        -:11539:      /* The update status will be:
        -:11540:	 	-1	if this target was not remade;
        -:11541:		0	if 0 or more commands (+ or ${MAKE}) were run and won;
        -:11542:		1	if some commands were run and lost.
        -:11543:	 We touch the target if it has commands which either were not run
        -:11544:	 or won when they ran (i.e. status is 0).  */
       11:11545:      && file->update_status == 0)
branch  0 taken 1 (fallthrough)
branch  1 taken 10
        -:11546:    {
       1*:11547:      if (file->cmds != 0 && file->cmds->any_recurse)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
branch  2 never executed
branch  3 never executed
    #####:11548:	{
        -:11549:	  /* If all the command lines were recursive,
        -:11550:	     we don't want to do the touching.  */
        -:11551:	  unsigned int i;
    #####:11552:	  for (i = 0; i < file->cmds->ncommand_lines; ++i)
branch  0 never executed
branch  1 never executed
    #####:11553:	    if (!(file->cmds->lines_flags[i] & COMMANDS_RECURSE))
branch  0 never executed
branch  1 never executed
    #####:11554:	      goto have_nonrecursing;
        -:11555:	}
        -:11556:      else
        -:11557:	{
       1*:11558:	have_nonrecursing:
        1:11559:	  if (file->phony)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:11560:	    file->update_status = 0;
        -:11561:	  else
        -:11562:	    /* Should set file's modification date and do nothing else.  */
    #####:11563:	    file->update_status = touch_file (file);
call    0 never executed
        -:11564:	}
        -:11565:    }
        -:11566:
      494:11567:  if (ran && !file->phony)
branch  0 taken 3 (fallthrough)
branch  1 taken 491
branch  2 taken 3 (fallthrough)
branch  3 taken 0
        -:11568:    {
        -:11569:      struct file *f;
        -:11570:
        3:11571:      if (just_print_flag || question_flag
branch  0 taken 3 (fallthrough)
branch  1 taken 0
branch  2 taken 3 (fallthrough)
branch  3 taken 0
        3:11572:	  || (file->is_target && file->cmds == 0))
branch  0 taken 3 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 3
    #####:11573:	file->last_mtime = NEW_MTIME;
        -:11574:      else
        3:11575:	file->last_mtime = 0;
        -:11576:
        -:11577:      /* Propagate the change of modification time to all the double-colon
        -:11578:	 entries for this file.  */
       3*:11579:      for (f = file->double_colon; f != 0; f = f->next)
branch  0 taken 0
branch  1 taken 3 (fallthrough)
    #####:11580:	f->last_mtime = file->last_mtime;
        -:11581:    }
        -:11582:
      494:11583:  if (ran && file->update_status != -1)
branch  0 taken 3 (fallthrough)
branch  1 taken 491
branch  2 taken 3 (fallthrough)
branch  3 taken 0
        -:11584:    /* We actually tried to update FILE, which has
        -:11585:       updated its also_make's as well (if it worked).
        -:11586:       If it didn't work, it wouldn't work again for them.
        -:11587:       So mark them as updated with the same status.  */
       3*:11588:    for (d = file->also_make; d != 0; d = d->next)
branch  0 taken 0
branch  1 taken 3 (fallthrough)
        -:11589:      {
    #####:11590:	d->file->command_state = cs_finished;
    #####:11591:	d->file->updated = 1;
    #####:11592:	d->file->update_status = file->update_status;
        -:11593:
    #####:11594:	if (ran && !d->file->phony)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:11595:	  /* Fetch the new modification time.
        -:11596:	     We do this instead of just invalidating the cached time
        -:11597:	     so that a vpath_search can happen.  Otherwise, it would
        -:11598:	     never be done because the target is already updated.  */
    #####:11599:	  (void) f_mtime (d->file, 0);
call    0 never executed
        -:11600:      }
      491:11601:  else if (file->update_status == -1)
branch  0 taken 219 (fallthrough)
branch  1 taken 272
        -:11602:    /* Nothing was done for FILE, but it needed nothing done.
        -:11603:       So mark it now as "succeeded".  */
      219:11604:    file->update_status = 0;
      494:11605:}
        -:11606:
        -:11607:/* Check whether another file (whose mtime is THIS_MTIME)
        -:11608:   needs updating on account of a dependency which is file FILE.
        -:11609:   If it does, store 1 in *MUST_MAKE_PTR.
        -:11610:   In the process, update any non-intermediate files
        -:11611:   that FILE depends on (including FILE itself).
        -:11612:   Return nonzero if any updating failed.  */
        -:11613:
        -:11614:static int
function check_dep called 269 returned 99% blocks executed 19%
      269:11615:check_dep (file, depth, this_mtime, must_make_ptr)
        -:11616:     struct file *file;
        -:11617:     unsigned int depth;
        -:11618:     time_t this_mtime;
        -:11619:     int *must_make_ptr;
        -:11620:{
        -:11621:  register struct dep *d;
      269:11622:  int dep_status = 0;
        -:11623:
      269:11624:  ++depth;
      269:11625:  file->updating = 1;
        -:11626:
      269:11627:  if (!file->intermediate)
branch  0 taken 269 (fallthrough)
branch  1 taken 0
        -:11628:    /* If this is a non-intermediate file, update it and record
        -:11629:       whether it is newer than THIS_MTIME.  */
        -:11630:    {
        -:11631:      time_t mtime;
      269:11632:      dep_status = update_file (file, depth);
call    0 returned 267
     267*:11633:      check_renamed (file);
branch  0 taken 0
branch  1 taken 267 (fallthrough)
      267:11634:      mtime = file_mtime (file);
branch  0 taken 266 (fallthrough)
branch  1 taken 1
call    2 returned 1
     267*:11635:      check_renamed (file);
branch  0 taken 0
branch  1 taken 267 (fallthrough)
      267:11636:      if (mtime == (time_t) -1 || mtime > this_mtime)
branch  0 taken 267 (fallthrough)
branch  1 taken 0
branch  2 taken 24 (fallthrough)
branch  3 taken 243
       24:11637:	*must_make_ptr = 1;
        -:11638:    }
        -:11639:  else
        -:11640:    {
        -:11641:      /* FILE is an intermediate file.  */
        -:11642:      time_t mtime;
        -:11643:
    #####:11644:      if (!file->phony && file->cmds == 0 && !file->tried_implicit
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:11645:	  && file->secondary)
branch  0 never executed
branch  1 never executed
        -:11646:	{
    #####:11647:	  if (try_implicit_rule (file, depth))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:11648:	    DEBUGPR ("Found an implicit rule for `%s'.\n");
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:11649:	  else
    #####:11650:	    DEBUGPR ("No implicit rule found for `%s'.\n");
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:11651:	  file->tried_implicit = 1;
        -:11652:	}
    #####:11653:      if (file->cmds == 0 && !file->is_target && file->secondary
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:11654:	  && default_file != 0 && default_file->cmds != 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:11655:	{
    #####:11656:	  DEBUGPR ("Using default commands for `%s'.\n");
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:11657:	  file->cmds = default_file->cmds;
        -:11658:	}
        -:11659:
        -:11660:      /* If the intermediate file actually exists
        -:11661:	 and is newer, then we should remake from it.  */
    #####:11662:      check_renamed (file);
branch  0 never executed
branch  1 never executed
    #####:11663:      mtime = file_mtime (file);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:11664:      check_renamed (file);
branch  0 never executed
branch  1 never executed
    #####:11665:      if (mtime != (time_t) -1 && mtime > this_mtime)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:11666:	*must_make_ptr = 1;
        -:11667:	  /* Otherwise, update all non-intermediate files we depend on,
        -:11668:	     if necessary, and see whether any of them is more
        -:11669:	     recent than the file on whose behalf we are checking.  */
        -:11670:      else
        -:11671:	{
        -:11672:	  register struct dep *lastd;
        -:11673:
    #####:11674:	  lastd = 0;
    #####:11675:	  d = file->deps;
    #####:11676:	  while (d != 0)
branch  0 never executed
branch  1 never executed
        -:11677:	    {
    #####:11678:	      if (d->file->updating)
branch  0 never executed
branch  1 never executed
        -:11679:		{
    #####:11680:		  error ("Circular %s <- %s dependency dropped.",
    #####:11681:			 file->name, d->file->name);
call    0 never executed
    #####:11682:		  if (lastd == 0)
branch  0 never executed
branch  1 never executed
        -:11683:		    {
    #####:11684:		      file->deps = d->next;
    #####:11685:		      free ((char *) d);
    #####:11686:		      d = file->deps;
        -:11687:		    }
        -:11688:		  else
        -:11689:		    {
    #####:11690:		      lastd->next = d->next;
    #####:11691:		      free ((char *) d);
    #####:11692:		      d = lastd->next;
        -:11693:		    }
    #####:11694:		  continue;
        -:11695:		}
        -:11696:
    #####:11697:	      d->file->parent = file;
    #####:11698:	      dep_status |= check_dep (d->file, depth, this_mtime, must_make_ptr);
call    0 never executed
    #####:11699:	      check_renamed (d->file);
branch  0 never executed
branch  1 never executed
    #####:11700:	      if (dep_status != 0 && !keep_going_flag)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:11701:		break;
        -:11702:
    #####:11703:	      if (d->file->command_state == cs_running
branch  0 never executed
branch  1 never executed
    #####:11704:		  || d->file->command_state == cs_deps_running)
branch  0 never executed
branch  1 never executed
        -:11705:		/* Record that some of FILE's dependencies are still being made.
        -:11706:		   This tells the upper levels to wait on processing it until
        -:11707:		   the commands are finished.  */
    #####:11708:		set_command_state (file, cs_deps_running);
call    0 never executed
        -:11709:
    #####:11710:	      lastd = d;
    #####:11711:	      d = d->next;
        -:11712:	    }
        -:11713:	}
        -:11714:    }
        -:11715:
      267:11716:  file->updating = 0;
      267:11717:  return dep_status;
        -:11718:}
        -:11719:
        -:11720:/* Touch FILE.  Return zero if successful, one if not.  */
        -:11721:
        -:11722:#define TOUCH_ERROR(call) return (perror_with_name (call, file->name), 1)
        -:11723:
        -:11724:static int
function touch_file called 0 returned 0% blocks executed 0%
    #####:11725:touch_file (file)
        -:11726:     register struct file *file;
        -:11727:{
    #####:11728:  if (!silent_flag)
branch  0 never executed
branch  1 never executed
    #####:11729:    message (0, "touch %s", file->name);
call    0 never executed
        -:11730:
        -:11731:#ifndef	NO_ARCHIVES
    #####:11732:  if (ar_name (file->name))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:11733:    return ar_touch (file->name);
call    0 never executed
        -:11734:  else
        -:11735:#endif
        -:11736:    {
    #####:11737:      int fd = open (file->name, O_RDWR | O_CREAT, 0666);
call    0 never executed
        -:11738:
    #####:11739:      if (fd < 0)
branch  0 never executed
branch  1 never executed
    #####:11740:	TOUCH_ERROR ("touch: open: ");
call    0 never executed
        -:11741:      else
        -:11742:	{
        -:11743:	  struct stat statbuf;
        -:11744:	  char buf;
        -:11745:	  int status;
        -:11746:
        -:11747:#ifdef EINTR
        -:11748:	  do
        -:11749:#endif
    #####:11750:	    status = fstat (fd, &statbuf);
call    0 never executed
        -:11751:#ifdef EINTR
    #####:11752:	  while (status < 0 && errno == EINTR);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:11753:#endif
    #####:11754:	  if (status < 0)
branch  0 never executed
branch  1 never executed
    #####:11755:	    TOUCH_ERROR ("touch: fstat: ");
call    0 never executed
        -:11756:	  /* Rewrite character 0 same as it already is.  */
    #####:11757:	  if (read (fd, &buf, 1) < 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:11758:	    TOUCH_ERROR ("touch: read: ");
call    0 never executed
    #####:11759:	  if (off_t_equal(off_t_to_int(lseek (fd, int_to_off_t(0), 0)), ZERO_L_off_t) < 0)
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -:11760:	  /*	  if (lseek (fd, 0L, 0) < 0L) */
    #####:11761:	    TOUCH_ERROR ("touch: lseek: ");
call    0 never executed
    #####:11762:	  if (write (fd, &buf, 1) < 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:11763:	    TOUCH_ERROR ("touch: write: ");
call    0 never executed
        -:11764:	  /* If file length was 0, we just
        -:11765:	     changed it, so change it back.  */
        -:11766:
        -:11767:	  
    #####:11768:	  if (off_t_equal(off_t_to_int(statbuf.st_size), ZERO_off_t) == 0)
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:11769:	  /*	  if (statbuf.st_size == 0) */
        -:11770:	    {
    #####:11771:	      (void) close (fd);
call    0 never executed
    #####:11772:	      fd = open (file->name, O_RDWR | O_TRUNC, 0666);
call    0 never executed
    #####:11773:	      if (fd < 0)
branch  0 never executed
branch  1 never executed
    #####:11774:		TOUCH_ERROR ("touch: open: ");
call    0 never executed
        -:11775:	    }
    #####:11776:	  (void) close (fd);
call    0 never executed
        -:11777:	}
        -:11778:    }
        -:11779:
    #####:11780:  return 0;
        -:11781:}
        -:11782:
        -:11783:/* Having checked and updated the dependencies of FILE,
        -:11784:   do whatever is appropriate to remake FILE itself.
        -:11785:   Return the status from executing FILE's commands.  */
        -:11786:
        -:11787:static void
function remake_file called 791 returned 34% blocks executed 79%
      791:11788:remake_file (file)
        -:11789:     struct file *file;
        -:11790:{
      791:11791:  if (file->cmds == 0)
branch  0 taken 787 (fallthrough)
branch  1 taken 4
        -:11792:    {
      787:11793:      if (file->phony)
branch  0 taken 14 (fallthrough)
branch  1 taken 773
        -:11794:	/* Phony target.  Pretend it succeeded.  */
       14:11795:	file->update_status = 0;
      773:11796:      else if (file->is_target)
branch  0 taken 0 (fallthrough)
branch  1 taken 773
        -:11797:	/* This is a nonexistent target file we cannot make.
        -:11798:	   Pretend it was successfully remade.  */
    #####:11799:	file->update_status = 0;
        -:11800:      else
      773:11801:        no_rule_error(file);
call    0 returned 256
        -:11802:    }
        -:11803:  else
        -:11804:    {
        4:11805:      chop_commands (file->cmds);
call    0 returned 4
        -:11806:
       4*:11807:      if (!touch_flag || file->cmds->any_recurse)
branch  0 taken 0 (fallthrough)
branch  1 taken 4
branch  2 never executed
branch  3 never executed
        -:11808:	{
        4:11809:	  execute_file_commands (file);
call    0 returned 2
        2:11810:	  return;
        -:11811:	}
        -:11812:      else
        -:11813:	/* This tells notice_finished_file it is ok to touch the file.  */
    #####:11814:	file->update_status = 0;
        -:11815:    }
        -:11816:
        -:11817:  /* This does the touching under -t.  */
      270:11818:  notice_finished_file (file);
call    0 returned 270
        -:11819:}
        -:11820:
        -:11821:/* Return the mtime of a file, given a `struct file'.
        -:11822:   Caches the time in the struct file to avoid excess stat calls.
        -:11823:
        -:11824:   If the file is not found, and SEARCH is nonzero, VPATH searching and
        -:11825:   replacement is done.  If that fails, a library (-lLIBNAME) is tried and
        -:11826:   the library's actual name (/lib/libLIBNAME.a, etc.) is substituted into
        -:11827:   FILE.  */
        -:11828:
        -:11829:time_t
function f_mtime called 997 returned 100% blocks executed 31%
      997:11830:f_mtime (file, search)
        -:11831:     register struct file *file;
        -:11832:     int search;
        -:11833:{
        -:11834:  time_t mtime;
        -:11835:
        -:11836:  /* File's mtime is not known; must get it from the system.  */
        -:11837:
        -:11838:#ifndef	NO_ARCHIVES
      997:11839:  if (ar_name (file->name))
call    0 returned 997
branch  1 taken 0 (fallthrough)
branch  2 taken 997
        -:11840:    {
        -:11841:      /* This file is an archive-member reference.  */
        -:11842:
        -:11843:      char *arname, *memname;
        -:11844:      struct file *arfile;
    #####:11845:      int arname_used = 0;
        -:11846:
        -:11847:      /* Find the archive's name.  */
    #####:11848:      ar_parse_name (file->name, &arname, &memname);
call    0 never executed
        -:11849:
        -:11850:      /* Find the modification time of the archive itself.
        -:11851:	 Also allow for its name to be changed via VPATH search.  */
    #####:11852:      arfile = lookup_file (arname);
call    0 never executed
    #####:11853:      if (arfile == 0)
branch  0 never executed
branch  1 never executed
        -:11854:	{
    #####:11855:	  arfile = enter_file (arname);
call    0 never executed
    #####:11856:	  arname_used = 1;
        -:11857:	}
    #####:11858:      mtime = f_mtime (arfile, search);
call    0 never executed
    #####:11859:      check_renamed (arfile);
branch  0 never executed
branch  1 never executed
    #####:11860:      if (search && strcmp (arfile->hname, arname))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:11861:	{
        -:11862:	  /* The archive's name has changed.
        -:11863:	     Change the archive-member reference accordingly.  */
        -:11864:
        -:11865:          char *name;
        -:11866:	  unsigned int arlen, memlen;
        -:11867:
    #####:11868:	  if (!arname_used)
branch  0 never executed
branch  1 never executed
        -:11869:	    {
    #####:11870:	      free (arname);
    #####:11871:	      arname_used = 1;
        -:11872:	    }
        -:11873:
    #####:11874:	  arname = arfile->hname;
    #####:11875:	  arlen = strlen (arname);
    #####:11876:	  memlen = strlen (memname);
        -:11877:
        -:11878:	  /* free (file->name); */
        -:11879:
    #####:11880:	  name = (char *) xmalloc (arlen + 1 + memlen + 2);
call    0 never executed
    #####:11881:	  bcopy (arname, name, arlen);
    #####:11882:	  name[arlen] = '(';
    #####:11883:	  bcopy (memname, name + arlen + 1, memlen);
    #####:11884:	  name[arlen + 1 + memlen] = ')';
    #####:11885:	  name[arlen + 1 + memlen + 1] = '\0';
        -:11886:
        -:11887:          /* If the archive was found with GPATH, make the change permanent;
        -:11888:             otherwise defer it until later.  */
    #####:11889:          if (arfile->name == arfile->hname)
branch  0 never executed
branch  1 never executed
    #####:11890:            rename_file (file, name);
call    0 never executed
        -:11891:          else
    #####:11892:            rehash_file (file, name);
call    0 never executed
    #####:11893:          check_renamed (file);
branch  0 never executed
branch  1 never executed
        -:11894:	}
        -:11895:
    #####:11896:      if (!arname_used)
branch  0 never executed
branch  1 never executed
    #####:11897:	free (arname);
    #####:11898:      free (memname);
        -:11899:
    #####:11900:      if (mtime == (time_t) -1)
branch  0 never executed
branch  1 never executed
        -:11901:	/* The archive doesn't exist, so it's members don't exist either.  */
    #####:11902:	return (time_t) -1;
        -:11903:
    #####:11904:      mtime = ar_member_date (file->hname);
call    0 never executed
        -:11905:    }
        -:11906:  else
        -:11907:#endif
        -:11908:    {
      997:11909:      mtime = name_mtime (file->name);
call    0 returned 997
        -:11910:
      997:11911:      if (mtime == (time_t) -1 && search && !file->ignore_vpath)
branch  0 taken 774 (fallthrough)
branch  1 taken 223
branch  2 taken 1 (fallthrough)
branch  3 taken 773
branch  4 taken 1 (fallthrough)
branch  5 taken 0
        -:11912:	{
        -:11913:	  /* If name_mtime failed, search VPATH.  */
        1:11914:	  char *name = file->name;
        1:11915:	  if (vpath_search (&name, &mtime)
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0
        -:11916:	      /* Last resort, is it a library (-lxxx)?  */
       1*:11917:	      || (name[0] == '-' && name[1] == 'l'
branch  0 taken 0 (fallthrough)
branch  1 taken 1
branch  2 never executed
branch  3 never executed
    #####:11918:		  && library_search (&name, &mtime)))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:11919:	    {
    #####:11920:	      if (mtime != 0)
branch  0 never executed
branch  1 never executed
        -:11921:		/* vpath_search and library_search store zero in MTIME
        -:11922:		   if they didn't need to do a stat call for their work.  */
    #####:11923:		file->last_mtime = mtime;
        -:11924:
        -:11925:              /* If we found it in VPATH, see if it's in GPATH too; if so,
        -:11926:                 change the name right now; if not, defer until after the
        -:11927:                 dependencies are updated. */
    #####:11928:              if (gpath_search (name, strlen(name) - strlen(file->name) - 1))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:11929:                {
    #####:11930:                  rename_file (file, name);
call    0 never executed
    #####:11931:                  check_renamed (file);
branch  0 never executed
branch  1 never executed
    #####:11932:                  return file_mtime (file);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:11933:                }
        -:11934:
    #####:11935:	      rehash_file (file, name);
call    0 never executed
    #####:11936:	      check_renamed (file);
branch  0 never executed
branch  1 never executed
    #####:11937:	      mtime = name_mtime (name);
call    0 never executed
        -:11938:	    }
        -:11939:	}
        -:11940:    }
        -:11941:
        -:11942:  {
        -:11943:    /* Files can have bogus timestamps that nothing newly made will be
        -:11944:       "newer" than.  Updating their dependents could just result in loops.
        -:11945:       So notify the user of the anomaly with a warning.
        -:11946:
        -:11947:       We only need to do this once, for now. */
        -:11948:
        -:11949:    static time_t now = 0;
      997:11950:    if (!clock_skew_detected
branch  0 taken 997 (fallthrough)
branch  1 taken 0
      997:11951:        && mtime != (time_t)-1 && mtime > now
branch  0 taken 223 (fallthrough)
branch  1 taken 774
branch  2 taken 19 (fallthrough)
branch  3 taken 204
       19:11952:        && !file->updated)
branch  0 taken 19 (fallthrough)
branch  1 taken 0
        -:11953:      {
        -:11954:	/* This file's time appears to be in the future.
        -:11955:	   Update our concept of the present, and compare again.  */
        -:11956:
        -:11957:	extern time_t time ();
       19:11958:	time (&now);
call    0 returned 19
        -:11959:
        -:11960:#ifdef WINDOWS32
        -:11961:	/*
        -:11962:	 * FAT filesystems round time to nearest even second(!). Just
        -:11963:	 * allow for any file (NTFS or FAT) to perhaps suffer from this
        -:11964:	 * braindamage.
        -:11965:	 */
        -:11966:	if (mtime > now && (((mtime % 2) == 0) && ((mtime-1) > now)))
        -:11967:#else
        -:11968:#ifdef __MSDOS__
        -:11969:	/* Scrupulous testing indicates that some Windows
        -:11970:	   filesystems can set file times up to 3 sec into the future!  */
        -:11971:	if (mtime > now + 3)
        -:11972:#else
       19:11973:        if (mtime > now)
branch  0 taken 0 (fallthrough)
branch  1 taken 19
        -:11974:#endif
        -:11975:#endif
        -:11976:          {
    #####:11977:            error("*** Warning: File `%s' has modification time in the future (%ld > %ld)",
call    0 never executed
        -:11978:                  file->name, mtime, now);
    #####:11979:            clock_skew_detected = 1;
        -:11980:          }
        -:11981:      }
        -:11982:  }
        -:11983:
        -:11984:  /* Store the mtime into all the entries for this file.  */
      997:11985:  if (file->double_colon)
branch  0 taken 0 (fallthrough)
branch  1 taken 997
    #####:11986:    file = file->double_colon;
        -:11987:  do
        -:11988:    {
      997:11989:      file->last_mtime = mtime;
      997:11990:      file = file->prev;
      997:11991:    } while (file != 0);
branch  0 taken 0
branch  1 taken 997 (fallthrough)
        -:11992:
      997:11993:  return mtime;
        -:11994:}
        -:11995:
        -:11996:
        -:11997:/* Return the mtime of the file or archive-member reference NAME.  */
        -:11998:
        -:11999:static time_t
function name_mtime called 997 returned 100% blocks executed 100%
      997:12000:name_mtime (name)
        -:12001:     register char *name;
        -:12002:{
        -:12003:  struct stat st;
        -:12004:
      997:12005:  if (stat (name, &st) < 0)
call    0 returned 997
branch  1 taken 774 (fallthrough)
branch  2 taken 223
      774:12006:    return (time_t) -1;
        -:12007:
      223:12008:  return (time_t) st.st_mtime;
        -:12009:}
        -:12010:
        -:12011:
        -:12012:/* Search for a library file specified as -lLIBNAME, searching for a
        -:12013:   suitable library file in the system library directories and the VPATH
        -:12014:   directories.  */
        -:12015:
        -:12016:static int
function library_search called 0 returned 0% blocks executed 0%
    #####:12017:library_search (lib, mtime_ptr)
        -:12018:     char **lib;
        -:12019:     time_t *mtime_ptr;
        -:12020:{
        -:12021:  static char *dirs[] =
        -:12022:    {
        -:12023:#ifndef _AMIGA
        -:12024:      "/lib",
        -:12025:      "/usr/lib",
        -:12026:#endif
        -:12027:#if defined(WINDOWS32) && !defined(LIBDIR)
        -:12028:/*
        -:12029: * This is completely up to the user at product install time. Just define
        -:12030: * a placeholder.
        -:12031: */
        -:12032:#define LIBDIR "."
        -:12033:#endif
        -:12034:      LIBDIR,			/* Defined by configuration.  */
        -:12035:      0
        -:12036:    };
        -:12037:
    #####:12038:  char *libname = &(*lib)[2];	/* Name without the `-l'.  */
        -:12039:  time_t mtime;
        -:12040:
        -:12041:  /* Buffer to construct possible names in.  */
    #####:12042:  char *buf = xmalloc (sizeof (LIBDIR) + 8 + strlen (libname) + 4 + 2 + 1);
call    0 never executed
        -:12043:  char *file, **dp;
        -:12044:
        -:12045:  /* Look first for `libNAME.a' in the current directory.  */
        -:12046:
        -:12047:#ifndef _AMIGA
    #####:12048:  sprintf (buf, "lib%s.a", libname);
        -:12049:#else
        -:12050:  sprintf (buf, "%s.lib", libname);
        -:12051:#endif
    #####:12052:  mtime = name_mtime (buf);
call    0 never executed
    #####:12053:  if (mtime != (time_t) -1)
branch  0 never executed
branch  1 never executed
        -:12054:    {
    #####:12055:      *lib = buf;
    #####:12056:      if (mtime_ptr != 0)
branch  0 never executed
branch  1 never executed
    #####:12057:	*mtime_ptr = mtime;
    #####:12058:      return 1;
        -:12059:    }
        -:12060:
        -:12061:  /* Now try VPATH search on that.  */
        -:12062:
    #####:12063:  file = buf;
    #####:12064:  if (vpath_search (&file, mtime_ptr))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:12065:    {
    #####:12066:      free (buf);
    #####:12067:      *lib = file;
    #####:12068:      return 1;
        -:12069:    }
        -:12070:
        -:12071:  /* Now try the standard set of directories.  */
        -:12072:
        -:12073:#ifdef  __MSDOS__
        -:12074:  {
        -:12075:    /* The default library directory is at ${DJDIR}/lib.  */
        -:12076:    struct variable *djdir = lookup_variable ("DJDIR", 5);
        -:12077:
        -:12078:    if (djdir)
        -:12079:      {
        -:12080:	size_t djdir_len = strlen (djdir->value);
        -:12081:
        -:12082:	if (djdir_len > sizeof(LIBDIR) + 8 + strlen(libname) + 4 + 2)
        -:12083:	  buf = (char *) xrealloc (djdir_len + 1);
        -:12084:	sprintf (buf, "%s/lib/lib%s.a", djdir->value, libname);
        -:12085:	mtime = name_mtime (buf);
        -:12086:	if (mtime != (time_t) -1)
        -:12087:	  {
        -:12088:	    *lib = buf;
        -:12089:	    if (mtime_ptr != 0)
        -:12090:	      *mtime_ptr = mtime;
        -:12091:	    return 1;
        -:12092:	  }
        -:12093:      }
        -:12094:  }
        -:12095:#endif
        -:12096:
    #####:12097:  for (dp = dirs; *dp != 0; ++dp)
branch  0 never executed
branch  1 never executed
        -:12098:    {
        -:12099:#ifndef _AMIGA
    #####:12100:      sprintf (buf, "%s/lib%s.a", *dp, libname);
        -:12101:#else
        -:12102:      sprintf (buf, "%s/%s.lib", *dp, libname);
        -:12103:#endif
    #####:12104:      mtime = name_mtime (buf);
call    0 never executed
    #####:12105:      if (mtime != (time_t) -1)
branch  0 never executed
branch  1 never executed
        -:12106:	{
    #####:12107:	  *lib = buf;
    #####:12108:	  if (mtime_ptr != 0)
branch  0 never executed
branch  1 never executed
    #####:12109:	    *mtime_ptr = mtime;
    #####:12110:	  return 1;
        -:12111:	}
        -:12112:    }
        -:12113:
    #####:12114:  free (buf);
    #####:12115:  return 0;
        -:12116:}
        -:12117:
        -:12118:
        -:12119:
        -:12120:/*************************************************************
        -:12121:  ============================================================
        -:12122:  ************************************************************
        -:12123:  ============================================================
        -:12124:  ************************************************************
        -:12125:                         rule.c
        -:12126:  ************************************************************
        -:12127:  ============================================================
        -:12128:  ************************************************************
        -:12129:  ============================================================
        -:12130:  *************************************************************/
        -:12131:
        -:12132:/* Pattern and suffix rule internals for GNU Make.
        -:12133:Copyright (C) 1988, 1989, 1990, 1991, 1992, 1993 Free Software Foundation, Inc.
        -:12134:This file is part of GNU Make.
        -:12135:
        -:12136:GNU Make is free software; you can redistribute it and/or modify
        -:12137:it under the terms of the GNU General Public License as published by
        -:12138:the Free Software Foundation; either version 2, or (at your option)
        -:12139:any later version.
        -:12140:
        -:12141:GNU Make is distributed in the hope that it will be useful,
        -:12142:but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:12143:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:12144:GNU General Public License for more details.
        -:12145:
        -:12146:You should have received a copy of the GNU General Public License
        -:12147:along with GNU Make; see the file COPYING.  If not, write to
        -:12148:the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
        -:12149:
        -:12150:
        -:12151:
        -:12152:static void freerule PARAMS ((struct rule *rule, struct rule *lastrule));
        -:12153:
        -:12154:/* Chain of all pattern rules.  */
        -:12155:
        -:12156:struct rule *pattern_rules;
        -:12157:
        -:12158:/* Pointer to last rule in the chain, so we can add onto the end.  */
        -:12159:
        -:12160:struct rule *last_pattern_rule;
        -:12161:
        -:12162:/* Number of rules in the chain.  */
        -:12163:
        -:12164:unsigned int num_pattern_rules;
        -:12165:
        -:12166:/* Maximum number of target patterns of any pattern rule.  */
        -:12167:
        -:12168:unsigned int max_pattern_targets;
        -:12169:
        -:12170:/* Maximum number of dependencies of any pattern rule.  */
        -:12171:
        -:12172:unsigned int max_pattern_deps;
        -:12173:
        -:12174:/* Maximum length of the name of a dependencies of any pattern rule.  */
        -:12175:
        -:12176:unsigned int max_pattern_dep_length;
        -:12177:
        -:12178:/* Chain of all pattern-specific variables.  */
        -:12179:
        -:12180:static struct pattern_var *pattern_vars;
        -:12181:
        -:12182:/* Pointer to last struct in the chain, so we can add onto the end.  */
        -:12183:
        -:12184:static struct pattern_var *last_pattern_var;
        -:12185:
        -:12186:/* Pointer to structure for the file .SUFFIXES
        -:12187:   whose dependencies are the suffixes to be searched.  */
        -:12188:
        -:12189:struct file *suffix_file;
        -:12190:
        -:12191:/* Maximum length of a suffix.  */
        -:12192:
        -:12193:unsigned int maxsuffix;
        -:12194:
        -:12195:/* Compute the maximum dependency length and maximum number of
        -:12196:   dependencies of all implicit rules.  Also sets the subdir
        -:12197:   flag for a rule when appropriate, possibly removing the rule
        -:12198:   completely when appropriate.  */
        -:12199:
        -:12200:void
function count_implicit_rule_limits called 790 returned 100% blocks executed 92%
      790:12201:count_implicit_rule_limits ()
        -:12202:{
        -:12203:  char *name;
        -:12204:  unsigned int namelen;
        -:12205:  register struct rule *rule, *lastrule;
        -:12206:
      790:12207:  num_pattern_rules = max_pattern_targets = max_pattern_deps = 0;
      790:12208:  max_pattern_dep_length = 0;
        -:12209:
      790:12210:  name = 0;
      790:12211:  namelen = 0;
      790:12212:  rule = pattern_rules;
      790:12213:  lastrule = 0;
    68644:12214:  while (rule != 0)
branch  0 taken 67854
branch  1 taken 790 (fallthrough)
        -:12215:    {
    67854:12216:      unsigned int ndeps = 0;
        -:12217:      register struct dep *dep;
    67854:12218:      struct rule *next = rule->next;
        -:12219:      unsigned int ntargets;
        -:12220:
    67854:12221:      ++num_pattern_rules;
        -:12222:
    67854:12223:      ntargets = 0;
   135708:12224:      while (rule->targets[ntargets] != 0)
branch  0 taken 67854
branch  1 taken 67854 (fallthrough)
    67854:12225:	++ntargets;
        -:12226:
    67854:12227:      if (ntargets > max_pattern_targets)
branch  0 taken 789 (fallthrough)
branch  1 taken 67065
      789:12228:	max_pattern_targets = ntargets;
        -:12229:
   112038:12230:      for (dep = rule->deps; dep != 0; dep = dep->next)
branch  0 taken 44184
branch  1 taken 67854 (fallthrough)
        -:12231:	{
    44184:12232:	  unsigned int len = strlen (dep->name);
        -:12233:
        -:12234:#ifdef VMS
        -:12235:	  char *p = rindex (dep->name, ']');
        -:12236:#else
    44184:12237:	  char *p = rindex (dep->name, '/');
        -:12238:#endif
    44184:12239:	  char *p2 = p != 0 ? index (dep->name, '%') : 0;
branch  0 taken 2367 (fallthrough)
branch  1 taken 41817
    44184:12240:	  ndeps++;
        -:12241:
    44184:12242:	  if (len > max_pattern_dep_length)
branch  0 taken 3156 (fallthrough)
branch  1 taken 41028
     3156:12243:	    max_pattern_dep_length = len;
        -:12244:
    44184:12245:	  if (p != 0 && p2 > p)
branch  0 taken 2367 (fallthrough)
branch  1 taken 41817
branch  2 taken 2367 (fallthrough)
branch  3 taken 0
        -:12246:	    {
        -:12247:	      /* There is a slash before the % in the dep name.
        -:12248:		 Extract the directory name.  */
     2367:12249:	      if (p == dep->name)
branch  0 taken 0 (fallthrough)
branch  1 taken 2367
    #####:12250:		++p;
     2367:12251:	      if (p - dep->name > namelen)
branch  0 taken 1578 (fallthrough)
branch  1 taken 789
        -:12252:		{
     1578:12253:		  if (name != 0)
branch  0 taken 789 (fallthrough)
branch  1 taken 789
      789:12254:		    free (name);
     1578:12255:		  namelen = p - dep->name;
     1578:12256:		  name = (char *) xmalloc (namelen + 1);
call    0 returned 1578
        -:12257:		}
     2367:12258:	      bcopy (dep->name, name, p - dep->name);
     2367:12259:	      name[p - dep->name] = '\0';
        -:12260:
        -:12261:	      /* In the deps of an implicit rule the `changed' flag
        -:12262:		 actually indicates that the dependency is in a
        -:12263:		 nonexistent subdirectory.  */
        -:12264:
     2367:12265:	      dep->changed = !dir_file_exists_p (name, "");
call    0 returned 2367
        -:12266:#ifdef VMS
        -:12267:	      if (dep->changed && *name == ']')
        -:12268:#else
     2367:12269:	      if (dep->changed && *name == '/')
branch  0 taken 2367 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 2367
        -:12270:#endif
        -:12271:		{
        -:12272:		  /* The name is absolute and the directory does not exist.
        -:12273:		     This rule can never possibly match, since this dependency
        -:12274:		     can never possibly exist.  So just remove the rule from
        -:12275:		     the list.  */
    #####:12276:		  freerule (rule, lastrule);
call    0 never executed
    #####:12277:		  --num_pattern_rules;
    #####:12278:		  goto end_main_loop;
        -:12279:		}
        -:12280:	    }
        -:12281:	  else
        -:12282:	    /* This dependency does not reside in a subdirectory.  */
    41817:12283:	    dep->changed = 0;
        -:12284:	}
        -:12285:
    67854:12286:      if (ndeps > max_pattern_deps)
branch  0 taken 1578 (fallthrough)
branch  1 taken 66276
     1578:12287:	max_pattern_deps = ndeps;
        -:12288:
    67854:12289:      lastrule = rule;
    67854:12290:    end_main_loop:
    67854:12291:      rule = next;
        -:12292:    }
        -:12293:
      790:12294:  if (name != 0)
branch  0 taken 789 (fallthrough)
branch  1 taken 1
      789:12295:    free (name);
      790:12296:}
        -:12297:
        -:12298:/* Create a pattern rule from a suffix rule.
        -:12299:   TARGET is the target suffix; SOURCE is the source suffix.
        -:12300:   CMDS are the commands.
        -:12301:   If TARGET is nil, it means the target pattern should be `(%.o)'.
        -:12302:   If SOURCE is nil, it means there should be no deps.  */
        -:12303:
        -:12304:static void
function convert_suffix_rule called 60753 returned 100% blocks executed 85%
    60753:12305:convert_suffix_rule (target, source, cmds)
        -:12306:     char *target, *source;
        -:12307:     struct commands *cmds;
        -:12308:{
        -:12309:  char *targname, *targpercent, *depname;
        -:12310:  char **names, **percents;
        -:12311:  struct dep *deps;
        -:12312:  unsigned int len;
        -:12313:
    60753:12314:  if (target == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 60753
        -:12315:    /* Special case: TARGET being nil means we are defining a
        -:12316:       `.X.a' suffix rule; the target pattern is always `(%.o)'.  */
        -:12317:    {
        -:12318:#ifdef VMS
        -:12319:      targname = savestring ("(%.obj)", 7);
        -:12320:#else
    #####:12321:      targname = savestring ("(%.o)", 5);
call    0 never executed
        -:12322:#endif
    #####:12323:      targpercent = targname + 1;
        -:12324:    }
        -:12325:  else
        -:12326:    {
        -:12327:      /* Construct the target name.  */
    60753:12328:      len = strlen (target);
    60753:12329:      targname = xmalloc (1 + len + 1);
call    0 returned 60753
    60753:12330:      targname[0] = '%';
    60753:12331:      bcopy (target, targname + 1, len + 1);
    60753:12332:      targpercent = targname;
        -:12333:    }
        -:12334:
    60753:12335:  names = (char **) xmalloc (2 * sizeof (char *));
call    0 returned 60753
    60753:12336:  percents = (char **) alloca (2 * sizeof (char *));
    60753:12337:  names[0] = targname;
    60753:12338:  percents[0] = targpercent;
    60753:12339:  names[1] = percents[1] = 0;
        -:12340:
    60753:12341:  if (source == 0)
branch  0 taken 25248 (fallthrough)
branch  1 taken 35505
    25248:12342:    deps = 0;
        -:12343:  else
        -:12344:    {
        -:12345:      /* Construct the dependency name.  */
    35505:12346:      len = strlen (source);
    35505:12347:      depname = xmalloc (1 + len + 1);
call    0 returned 35505
    35505:12348:      depname[0] = '%';
    35505:12349:      bcopy (source, depname + 1, len + 1);
    35505:12350:      deps = (struct dep *) xmalloc (sizeof (struct dep));
call    0 returned 35505
    35505:12351:      deps->next = 0;
    35505:12352:      deps->name = depname;
        -:12353:    }
        -:12354:
    60753:12355:  create_pattern_rule (names, percents, 0, deps, cmds, 0);
call    0 returned 60753
    60753:12356:}
        -:12357:
        -:12358:/* Convert old-style suffix rules to pattern rules.
        -:12359:   All rules for the suffixes on the .SUFFIXES list
        -:12360:   are converted and added to the chain of pattern rules.  */
        -:12361:
        -:12362:void
function convert_to_pattern called 790 returned 100% blocks executed 75%
      790:12363:convert_to_pattern ()
        -:12364:{
        -:12365:  register struct dep *d, *d2;
        -:12366:  register struct file *f;
        -:12367:  register char *rulename;
        -:12368:  register unsigned int slen, s2len;
        -:12369:
        -:12370:  /* Compute maximum length of all the suffixes.  */
        -:12371:
      790:12372:  maxsuffix = 0;
    26038:12373:  for (d = suffix_file->deps; d != 0; d = d->next)
branch  0 taken 25248
branch  1 taken 790 (fallthrough)
        -:12374:    {
   25248*:12375:      register unsigned int namelen = strlen (dep_name (d));
branch  0 taken 25248 (fallthrough)
branch  1 taken 0
    25248:12376:      if (namelen > maxsuffix)
branch  0 taken 2367 (fallthrough)
branch  1 taken 22881
     2367:12377:	maxsuffix = namelen;
        -:12378:    }
        -:12379:
      790:12380:  rulename = (char *) alloca ((maxsuffix * 2) + 1);
        -:12381:
    26038:12382:  for (d = suffix_file->deps; d != 0; d = d->next)
branch  0 taken 25248
branch  1 taken 790 (fallthrough)
        -:12383:    {
        -:12384:      /* Make a rule that is just the suffix, with no deps or commands.
        -:12385:	 This rule exists solely to disqualify match-anything rules.  */
   25248*:12386:      convert_suffix_rule (dep_name (d), (char *) 0, (struct commands *) 0);
branch  0 taken 25248 (fallthrough)
branch  1 taken 0
call    2 returned 25248
        -:12387:
    25248:12388:      f = d->file;
    25248:12389:      if (f->cmds != 0)
branch  0 taken 10257 (fallthrough)
branch  1 taken 14991
        -:12390:	/* Record a pattern for this suffix's null-suffix rule.  */
   10257*:12391:	convert_suffix_rule ("", dep_name (d), f->cmds);
branch  0 taken 10257 (fallthrough)
branch  1 taken 0
call    2 returned 10257
        -:12392:
        -:12393:      /* Record a pattern for each of this suffix's two-suffix rules.  */
   25248*:12394:      slen = strlen (dep_name (d));
branch  0 taken 25248 (fallthrough)
branch  1 taken 0
   25248*:12395:      bcopy (dep_name (d), rulename, slen);
branch  0 taken 25248 (fallthrough)
branch  1 taken 0
   833184:12396:      for (d2 = suffix_file->deps; d2 != 0; d2 = d2->next)
branch  0 taken 807936
branch  1 taken 25248 (fallthrough)
        -:12397:	{
  807936*:12398:	  s2len = strlen (dep_name (d2));
branch  0 taken 807936 (fallthrough)
branch  1 taken 0
        -:12399:
  807936*:12400:	  if (slen == s2len && streq (dep_name (d), dep_name (d2)))
branch  0 taken 243012 (fallthrough)
branch  1 taken 564924
branch  2 taken 243012 (fallthrough)
branch  3 taken 0
branch  4 taken 243012 (fallthrough)
branch  5 taken 0
branch  6 taken 217764 (fallthrough)
branch  7 taken 25248
branch  8 taken 217764 (fallthrough)
branch  9 taken 0
branch 10 taken 217764 (fallthrough)
branch 11 taken 0
branch 12 taken 217764 (fallthrough)
branch 13 taken 0
branch 14 taken 217764 (fallthrough)
branch 15 taken 0
branch 16 taken 217764 (fallthrough)
branch 17 taken 0
branch 18 taken 217764 (fallthrough)
branch 19 taken 0
branch 20 taken 217764 (fallthrough)
branch 21 taken 0
branch 22 taken 0 (fallthrough)
branch 23 taken 217764
    25248:12401:	    continue;
        -:12402:
  782688*:12403:	  bcopy (dep_name (d2), rulename + slen, s2len + 1);
branch  0 taken 782688 (fallthrough)
branch  1 taken 0
   782688:12404:	  f = lookup_file (rulename);
call    0 returned 782688
   782688:12405:	  if (f == 0 || f->cmds == 0)
branch  0 taken 25248 (fallthrough)
branch  1 taken 757440
branch  2 taken 0 (fallthrough)
branch  3 taken 25248
   757440:12406:	    continue;
        -:12407:
    25248:12408:	  if (s2len == 2 && rulename[slen] == '.' && rulename[slen + 1] == 'a')
branch  0 taken 14991 (fallthrough)
branch  1 taken 10257
branch  2 taken 14991 (fallthrough)
branch  3 taken 0
branch  4 taken 0 (fallthrough)
branch  5 taken 14991
        -:12409:	    /* A suffix rule `.X.a:' generates the pattern rule `(%.o): %.X'.
        -:12410:	       It also generates a normal `%.a: %.X' rule below.  */
    #####:12411:	    convert_suffix_rule ((char *) 0, /* Indicates `(%.o)'.  */
call    0 never executed
    #####:12412:				 dep_name (d),
branch  0 never executed
branch  1 never executed
        -:12413:				 f->cmds);
        -:12414:
        -:12415:	  /* The suffix rule `.X.Y:' is converted
        -:12416:	     to the pattern rule `%.Y: %.X'.  */
   25248*:12417:	  convert_suffix_rule (dep_name (d2), dep_name (d), f->cmds);
branch  0 taken 25248 (fallthrough)
branch  1 taken 0
branch  2 taken 25248 (fallthrough)
branch  3 taken 0
call    4 returned 25248
        -:12418:	}
        -:12419:    }
      790:12420:}
        -:12421:
        -:12422:
        -:12423:/* Install the pattern rule RULE (whose fields have been filled in)
        -:12424:   at the end of the list (so that any rules previously defined
        -:12425:   will take precedence).  If this rule duplicates a previous one
        -:12426:   (identical target and dependencies), the old one is replaced
        -:12427:   if OVERRIDE is nonzero, otherwise this new one is thrown out.
        -:12428:   When an old rule is replaced, the new one is put at the end of the
        -:12429:   list.  Return nonzero if RULE is used; zero if not.  */
        -:12430:
        -:12431:int
function new_pattern_rule called 67854 returned 100% blocks executed 74%
    67854:12432:new_pattern_rule (rule, override)
        -:12433:     register struct rule *rule;
        -:12434:     int override;
        -:12435:{
        -:12436:  register struct rule *r, *lastrule;
        -:12437:  register unsigned int i, j;
        -:12438:
    67854:12439:  rule->in_use = 0;
    67854:12440:  rule->terminal = 0;
        -:12441:
    67854:12442:  rule->next = 0;
        -:12443:
        -:12444:  /* Search for an identical rule.  */
    67854:12445:  lastrule = 0;
  2951649:12446:  for (r = pattern_rules; r != 0; lastrule = r, r = r->next)
branch  0 taken 2883795
branch  1 taken 67854 (fallthrough)
  5767590:12447:    for (i = 0; rule->targets[i] != 0; ++i)
branch  0 taken 2883795
branch  1 taken 2883795 (fallthrough)
        -:12448:      {
  3092880:12449:	for (j = 0; r->targets[j] != 0; ++j)
branch  0 taken 2883795
branch  1 taken 209085 (fallthrough)
  2883795:12450:	  if (!streq (rule->targets[i], r->targets[j]))
branch  0 taken 2883795 (fallthrough)
branch  1 taken 0
branch  2 taken 2816730 (fallthrough)
branch  3 taken 67065
branch  4 taken 2816730 (fallthrough)
branch  5 taken 0
branch  6 taken 209085 (fallthrough)
branch  7 taken 2607645
        -:12451:	    break;
  2883795:12452:	if (r->targets[j] == 0)
branch  0 taken 209085 (fallthrough)
branch  1 taken 2674710
        -:12453:	  /* All the targets matched.  */
        -:12454:	  {
        -:12455:	    register struct dep *d, *d2;
   209085:12456:	    for (d = rule->deps, d2 = r->deps;
   210663:12457:		 d != 0 && d2 != 0; d = d->next, d2 = d2->next)
branch  0 taken 210663 (fallthrough)
branch  1 taken 0
branch  2 taken 181470
branch  3 taken 29193 (fallthrough)
  181470*:12458:	      if (!streq (dep_name (d), dep_name (d2)))
branch  0 taken 0 (fallthrough)
branch  1 taken 181470
branch  2 taken 0 (fallthrough)
branch  3 taken 181470
branch  4 taken 181470 (fallthrough)
branch  5 taken 0
branch  6 taken 0 (fallthrough)
branch  7 taken 181470
branch  8 taken 0 (fallthrough)
branch  9 taken 181470
branch 10 taken 133341 (fallthrough)
branch 11 taken 48129
branch 12 taken 0 (fallthrough)
branch 13 taken 133341
branch 14 taken 133341 (fallthrough)
branch 15 taken 0
branch 16 taken 0 (fallthrough)
branch 17 taken 133341
branch 18 taken 0 (fallthrough)
branch 19 taken 133341
branch 20 taken 1578 (fallthrough)
branch 21 taken 131763
        -:12459:		break;
  209085*:12460:	    if (d == 0 && d2 == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 209085
branch  2 never executed
branch  3 never executed
        -:12461:	      /* All the dependencies matched.  */
    #####:12462:	      if (override)
branch  0 never executed
branch  1 never executed
        -:12463:		{
        -:12464:		  /* Remove the old rule.  */
    #####:12465:		  freerule (r, lastrule);
call    0 never executed
        -:12466:		  /* Install the new one.  */
    #####:12467:		  if (pattern_rules == 0)
branch  0 never executed
branch  1 never executed
    #####:12468:		    pattern_rules = rule;
        -:12469:		  else
    #####:12470:		    last_pattern_rule->next = rule;
    #####:12471:		  last_pattern_rule = rule;
        -:12472:
        -:12473:		  /* We got one.  Stop looking.  */
    #####:12474:		  goto matched;
        -:12475:		}
        -:12476:	      else
        -:12477:		{
        -:12478:		  /* The old rule stays intact.  Destroy the new one.  */
    #####:12479:		  freerule (rule, (struct rule *) 0);
call    0 never executed
    #####:12480:		  return 0;
        -:12481:		}
        -:12482:	  }
        -:12483:      }
        -:12484:
    67854:12485: matched:;
        -:12486:
    67854:12487:  if (r == 0)
branch  0 taken 67854 (fallthrough)
branch  1 taken 0
        -:12488:    {
        -:12489:      /* There was no rule to replace.  */
    67854:12490:      if (pattern_rules == 0)
branch  0 taken 789 (fallthrough)
branch  1 taken 67065
      789:12491:	pattern_rules = rule;
        -:12492:      else
    67065:12493:	last_pattern_rule->next = rule;
    67854:12494:      last_pattern_rule = rule;
        -:12495:    }
        -:12496:
    67854:12497:  return 1;
        -:12498:}
        -:12499:
        -:12500:
        -:12501:/* Install an implicit pattern rule based on the three text strings
        -:12502:   in the structure P points to.  These strings come from one of
        -:12503:   the arrays of default implicit pattern rules.
        -:12504:   TERMINAL specifies what the `terminal' field of the rule should be.  */
        -:12505:
        -:12506:void
function install_pattern_rule called 7101 returned 100% blocks executed 94%
     7101:12507:install_pattern_rule (p, terminal)
        -:12508:     struct pspec *p;
        -:12509:     int terminal;
        -:12510:{
        -:12511:  register struct rule *r;
        -:12512:  char *ptr;
        -:12513:
     7101:12514:  r = (struct rule *) xmalloc (sizeof (struct rule));
call    0 returned 7101
        -:12515:
     7101:12516:  r->targets = (char **) xmalloc (2 * sizeof (char *));
call    0 returned 7101
     7101:12517:  r->suffixes = (char **) xmalloc (2 * sizeof (char *));
call    0 returned 7101
     7101:12518:  r->lens = (unsigned int *) xmalloc (2 * sizeof (unsigned int));
call    0 returned 7101
        -:12519:
     7101:12520:  r->targets[1] = 0;
     7101:12521:  r->suffixes[1] = 0;
     7101:12522:  r->lens[1] = 0;
        -:12523:
     7101:12524:  r->lens[0] = strlen (p->target);
        -:12525:  /* These will all be string literals, but we malloc space for
        -:12526:     them anyway because somebody might want to free them later on.  */
     7101:12527:  r->targets[0] = savestring (p->target, r->lens[0]);
call    0 returned 7101
     7101:12528:  r->suffixes[0] = find_percent (r->targets[0]);
call    0 returned 7101
     7101:12529:  if (r->suffixes[0] == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 7101
        -:12530:    /* Programmer-out-to-lunch error.  */
    #####:12531:    abort ();
call    0 never executed
        -:12532:  else
     7101:12533:    ++r->suffixes[0];
        -:12534:
     7101:12535:  ptr = p->dep;
     7101:12536:  r->deps = (struct dep *) multi_glob (parse_file_seq (&ptr, '\0',
call    0 returned 7101
call    1 returned 7101
        -:12537:                                                       sizeof (struct dep), 1),
        -:12538:				       sizeof (struct dep));
        -:12539:
     7101:12540:  if (new_pattern_rule (r, 0))
call    0 returned 7101
branch  1 taken 7101 (fallthrough)
branch  2 taken 0
        -:12541:    {
     7101:12542:      r->terminal = terminal;
     7101:12543:      r->cmds = (struct commands *) xmalloc (sizeof (struct commands));
call    0 returned 7101
     7101:12544:      r->cmds->filename = 0;
     7101:12545:      r->cmds->lineno = 0;
        -:12546:      /* These will all be string literals, but we malloc space for them
        -:12547:	 anyway because somebody might want to free them later.  */
     7101:12548:      r->cmds->commands = savestring (p->commands, strlen (p->commands));
call    0 returned 7101
     7101:12549:      r->cmds->command_lines = 0;
        -:12550:    }
     7101:12551:}
        -:12552:
        -:12553:
        -:12554:/* Free all the storage used in RULE and take it out of the
        -:12555:   pattern_rules chain.  LASTRULE is the rule whose next pointer
        -:12556:   points to RULE.  */
        -:12557:
        -:12558:static void
function freerule called 0 returned 0% blocks executed 0%
    #####:12559:freerule (rule, lastrule)
        -:12560:     register struct rule *rule, *lastrule;
        -:12561:{
    #####:12562:  struct rule *next = rule->next;
        -:12563:  register unsigned int i;
        -:12564:
    #####:12565:  for (i = 0; rule->targets[i] != 0; ++i)
branch  0 never executed
branch  1 never executed
    #####:12566:    free (rule->targets[i]);
        -:12567:
    #####:12568:  free ((char *) rule->targets);
    #####:12569:  free ((char *) rule->suffixes);
    #####:12570:  free ((char *) rule->lens);
        -:12571:
        -:12572:  /* We can't free the storage for the commands because there
        -:12573:     are ways that they could be in more than one place:
        -:12574:       * If the commands came from a suffix rule, they could also be in
        -:12575:       the `struct file's for other suffix rules or plain targets given
        -:12576:       on the same makefile line.
        -:12577:       * If two suffixes that together make a two-suffix rule were each
        -:12578:       given twice in the .SUFFIXES list, and in the proper order, two
        -:12579:       identical pattern rules would be created and the second one would
        -:12580:       be discarded here, but both would contain the same `struct commands'
        -:12581:       pointer from the `struct file' for the suffix rule.  */
        -:12582:
    #####:12583:  free ((char *) rule);
        -:12584:
    #####:12585:  if (pattern_rules == rule)
branch  0 never executed
branch  1 never executed
    #####:12586:    if (lastrule != 0)
branch  0 never executed
branch  1 never executed
    #####:12587:      abort ();
call    0 never executed
        -:12588:    else
    #####:12589:      pattern_rules = next;
    #####:12590:  else if (lastrule != 0)
branch  0 never executed
branch  1 never executed
    #####:12591:    lastrule->next = next;
    #####:12592:  if (last_pattern_rule == rule)
branch  0 never executed
branch  1 never executed
    #####:12593:    last_pattern_rule = lastrule;
    #####:12594:}
        -:12595:
        -:12596:/* Create a new pattern rule with the targets in the nil-terminated
        -:12597:   array TARGETS.  If TARGET_PERCENTS is not nil, it is an array of
        -:12598:   pointers into the elements of TARGETS, where the `%'s are.
        -:12599:   The new rule has dependencies DEPS and commands from COMMANDS.
        -:12600:   It is a terminal rule if TERMINAL is nonzero.  This rule overrides
        -:12601:   identical rules with different commands if OVERRIDE is nonzero.
        -:12602:
        -:12603:   The storage for TARGETS and its elements is used and must not be freed
        -:12604:   until the rule is destroyed.  The storage for TARGET_PERCENTS is not used;
        -:12605:   it may be freed.  */
        -:12606:
        -:12607:void
function create_pattern_rule called 60753 returned 100% blocks executed 62%
    60753:12608:create_pattern_rule (targets, target_percents,
        -:12609:		     terminal, deps, commands, override)
        -:12610:     char **targets, **target_percents;
        -:12611:     int terminal;
        -:12612:     struct dep *deps;
        -:12613:     struct commands *commands;
        -:12614:     int override;
        -:12615:{
    60753:12616:  register struct rule *r = (struct rule *) xmalloc (sizeof (struct rule));
call    0 returned 60753
        -:12617:  register unsigned int max_targets, i;
        -:12618:
    60753:12619:  r->cmds = commands;
    60753:12620:  r->deps = deps;
    60753:12621:  r->targets = targets;
        -:12622:
    60753:12623:  max_targets = 2;
    60753:12624:  r->lens = (unsigned int *) xmalloc (2 * sizeof (unsigned int));
call    0 returned 60753
    60753:12625:  r->suffixes = (char **) xmalloc (2 * sizeof (char *));
call    0 returned 60753
   121506:12626:  for (i = 0; targets[i] != 0; ++i)
branch  0 taken 60753
branch  1 taken 60753 (fallthrough)
        -:12627:    {
    60753:12628:      if (i == max_targets - 1)
branch  0 taken 0 (fallthrough)
branch  1 taken 60753
        -:12629:	{
    #####:12630:	  max_targets += 5;
    #####:12631:	  r->lens = (unsigned int *)
    #####:12632:	    xrealloc ((char *) r->lens, max_targets * sizeof (unsigned int));
call    0 never executed
    #####:12633:	  r->suffixes = (char **)
    #####:12634:	    xrealloc ((char *) r->suffixes, max_targets * sizeof (char *));
call    0 never executed
        -:12635:	}
    60753:12636:      r->lens[i] = strlen (targets[i]);
    #####:12637:      r->suffixes[i] = (target_percents == 0 ? find_percent (targets[i])
call    0 never executed
   60753*:12638:			: target_percents[i]) + 1;
branch  0 taken 0 (fallthrough)
branch  1 taken 60753
    60753:12639:      if (r->suffixes[i] == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 60753
    #####:12640:	abort ();
call    0 never executed
        -:12641:    }
        -:12642:
    60753:12643:  if (i < max_targets - 1)
branch  0 taken 0 (fallthrough)
branch  1 taken 60753
        -:12644:    {
    #####:12645:      r->lens = (unsigned int *) xrealloc ((char *) r->lens,
    #####:12646:					   (i + 1) * sizeof (unsigned int));
call    0 never executed
    #####:12647:      r->suffixes = (char **) xrealloc ((char *) r->suffixes,
    #####:12648:					(i + 1) * sizeof (char *));
call    0 never executed
        -:12649:    }
        -:12650:
    60753:12651:  if (new_pattern_rule (r, override))
call    0 returned 60753
branch  1 taken 60753 (fallthrough)
branch  2 taken 0
    60753:12652:    r->terminal = terminal;
    60753:12653:}
        -:12654:
        -:12655:/* Create a new pattern-specific variable struct.  */
        -:12656:
        -:12657:struct pattern_var *
function create_pattern_var called 0 returned 0% blocks executed 0%
    #####:12658:create_pattern_var (target, suffix)
        -:12659:     char *target, *suffix;
        -:12660:{
    #####:12661:  register struct pattern_var *p = 0;
    #####:12662:  unsigned int len = strlen(target);
        -:12663:
        -:12664:  /* Look to see if this pattern already exists in the list.  */
    #####:12665:  for (p = pattern_vars; p != NULL; p = p->next)
branch  0 never executed
branch  1 never executed
    #####:12666:    if (p->len == len && !strcmp(p->target, target))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:12667:      break;
        -:12668:
    #####:12669:  if (p == 0)
branch  0 never executed
branch  1 never executed
        -:12670:    {
    #####:12671:      p = (struct pattern_var *) xmalloc (sizeof (struct pattern_var));
call    0 never executed
    #####:12672:      if (last_pattern_var != 0)
branch  0 never executed
branch  1 never executed
    #####:12673:        last_pattern_var->next = p;
        -:12674:      else
    #####:12675:        pattern_vars = p;
    #####:12676:      last_pattern_var = p;
    #####:12677:      p->next = 0;
    #####:12678:      p->target = target;
    #####:12679:      p->len = len;
    #####:12680:      p->suffix = suffix + 1;
    #####:12681:      p->vars = create_new_variable_set();
call    0 never executed
        -:12682:    }
        -:12683:
    #####:12684:  return p;
        -:12685:}
        -:12686:
        -:12687:/* Look up a target in the pattern-specific variable list.  */
        -:12688:
        -:12689:struct pattern_var *
function lookup_pattern_var called 4 returned 100% blocks executed 25%
        4:12690:lookup_pattern_var (target)
        -:12691:     char *target;
        -:12692:{
        -:12693:  struct pattern_var *p;
        4:12694:  unsigned int targlen = strlen(target);
        -:12695:
       4*:12696:  for (p = pattern_vars; p != 0; p = p->next)
branch  0 taken 0
branch  1 taken 4 (fallthrough)
        -:12697:    {
        -:12698:      char *stem;
        -:12699:      unsigned int stemlen;
        -:12700:
    #####:12701:      if (p->len > targlen)
branch  0 never executed
branch  1 never executed
        -:12702:        /* It can't possibly match.  */
    #####:12703:        continue;
        -:12704:
        -:12705:      /* From the lengths of the filename and the pattern parts,
        -:12706:         find the stem: the part of the filename that matches the %.  */
    #####:12707:      stem = target + (p->suffix - p->target - 1);
    #####:12708:      stemlen = targlen - p->len + 1;
        -:12709:
        -:12710:      /* Compare the text in the pattern before the stem, if any.  */
    #####:12711:      if (stem > target && strncmp (p->target, target, stem - target))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:12712:        continue;
        -:12713:
        -:12714:      /* Compare the text in the pattern after the stem, if any.
        -:12715:         We could test simply use streq, but this way we compare the
        -:12716:         first two characters immediately.  This saves time in the very
        -:12717:         common case where the first character matches because it is a
        -:12718:         period.  */
    #####:12719:      if (*p->suffix == stem[stemlen]
branch  0 never executed
branch  1 never executed
    #####:12720:          && (*p->suffix == '\0'|| streq (&p->suffix[1], &stem[stemlen+1])))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
        -:12721:        break;
        -:12722:    }
        -:12723:
        4:12724:  return p;
        -:12725:}
        -:12726:
        -:12727:/* Print the data base of rules.  */
        -:12728:
        -:12729:static void			/* Useful to call from gdb.  */
function print_rule called 33110 returned 100% blocks executed 90%
    33110:12730:print_rule (r)
        -:12731:     struct rule *r;
        -:12732:{
        -:12733:  register unsigned int i;
        -:12734:  register struct dep *d;
        -:12735:
    66220:12736:  for (i = 0; r->targets[i] != 0; ++i)
branch  0 taken 33110
branch  1 taken 33110 (fallthrough)
        -:12737:    {
    33110:12738:      fputs (r->targets[i], stdout);
call    0 returned 33110
    33110:12739:      if (r->targets[i + 1] != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 33110
    #####:12740:	putchar (' ');
call    0 never executed
        -:12741:      else
    33110:12742:	putchar (':');
call    0 returned 33110
        -:12743:    }
    33110:12744:  if (r->terminal)
branch  0 taken 1925 (fallthrough)
branch  1 taken 31185
     1925:12745:    putchar (':');
call    0 returned 1925
        -:12746:
    54670:12747:  for (d = r->deps; d != 0; d = d->next)
branch  0 taken 21560
branch  1 taken 33110 (fallthrough)
   21560*:12748:    printf (" %s", dep_name (d));
branch  0 taken 0 (fallthrough)
branch  1 taken 21560
call    2 returned 21560
    33110:12749:  putchar ('\n');
call    0 returned 33110
        -:12750:
    33110:12751:  if (r->cmds != 0)
branch  0 taken 20790 (fallthrough)
branch  1 taken 12320
    20790:12752:    print_commands (r->cmds);
call    0 returned 20790
    33110:12753:}
        -:12754:
        -:12755:void
function print_rule_data_base called 385 returned 100% blocks executed 76%
      385:12756:print_rule_data_base ()
        -:12757:{
        -:12758:  register unsigned int rules, terminal;
        -:12759:  register struct rule *r;
        -:12760:
      385:12761:  puts ("\n# Implicit Rules");
call    0 returned 385
        -:12762:
      385:12763:  rules = terminal = 0;
    33495:12764:  for (r = pattern_rules; r != 0; r = r->next)
branch  0 taken 33110
branch  1 taken 385 (fallthrough)
        -:12765:    {
    33110:12766:      ++rules;
        -:12767:
    33110:12768:      putchar ('\n');
call    0 returned 33110
    33110:12769:      print_rule (r);
call    0 returned 33110
        -:12770:
    33110:12771:      if (r->terminal)
branch  0 taken 1925 (fallthrough)
branch  1 taken 31185
     1925:12772:	++terminal;
        -:12773:    }
        -:12774:
      385:12775:  if (rules == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 385
    #####:12776:    puts ("\n# No implicit rules.");
call    0 never executed
        -:12777:  else
        -:12778:    {
      385:12779:      printf ("\n# %u implicit rules, %u", rules, terminal);
call    0 returned 385
        -:12780:#ifndef	NO_FLOAT
      385:12781:      printf (" (%.1f%%)", (double) terminal / (double) rules * 100.0);
call    0 returned 385
        -:12782:#else
        -:12783:      {
        -:12784:	int f = (terminal * 1000 + 5) / rules;
        -:12785:	printf (" (%d.%d%%)", f/10, f%10);
        -:12786:      }
        -:12787:#endif
      385:12788:      puts (" terminal.");
call    0 returned 385
        -:12789:    }
        -:12790:
      385:12791:  if (num_pattern_rules != rules)
branch  0 taken 0 (fallthrough)
branch  1 taken 385
    #####:12792:    fatal ("BUG: num_pattern_rules wrong!  %u != %u",
call    0 never executed
        -:12793:	   num_pattern_rules, rules);
        -:12794:
      385:12795:  puts ("\n# Pattern-specific variable values");
call    0 returned 385
        -:12796:
        -:12797:  {
        -:12798:    struct pattern_var *p;
        -:12799:
      385:12800:    rules = 0;
     385*:12801:    for (p = pattern_vars; p != 0; p = p->next)
branch  0 taken 0
branch  1 taken 385 (fallthrough)
        -:12802:      {
    #####:12803:        ++rules;
        -:12804:
    #####:12805:        printf ("\n%s :\n", p->target);
call    0 never executed
    #####:12806:        print_variable_set (p->vars->set, "# ");
call    0 never executed
        -:12807:      }
        -:12808:
      385:12809:    if (rules == 0)
branch  0 taken 385 (fallthrough)
branch  1 taken 0
      385:12810:      puts ("\n# No pattern-specific variable values.");
call    0 returned 385
        -:12811:    else
        -:12812:      {
    #####:12813:        printf ("\n# %u pattern-specific variable values", rules);
call    0 never executed
        -:12814:      }
        -:12815:  }
      385:12816:}
        -:12817:
        -:12818:
        -:12819:
        -:12820:/*************************************************************
        -:12821:  ============================================================
        -:12822:  ************************************************************
        -:12823:  ============================================================
        -:12824:  ************************************************************
        -:12825:                         implicit.c
        -:12826:  ************************************************************
        -:12827:  ============================================================
        -:12828:  ************************************************************
        -:12829:  ============================================================
        -:12830:  *************************************************************/
        -:12831:
        -:12832:/* Implicit rule searching for GNU Make.
        -:12833:Copyright (C) 1988,89,90,91,92,93,94,97 Free Software Foundation, Inc.
        -:12834:This file is part of GNU Make.
        -:12835:
        -:12836:GNU Make is free software; you can redistribute it and/or modify
        -:12837:it under the terms of the GNU General Public License as published by
        -:12838:the Free Software Foundation; either version 2, or (at your option)
        -:12839:any later version.
        -:12840:
        -:12841:GNU Make is distributed in the hope that it will be useful,
        -:12842:but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:12843:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:12844:GNU General Public License for more details.
        -:12845:
        -:12846:You should have received a copy of the GNU General Public License
        -:12847:along with GNU Make; see the file COPYING.  If not, write to
        -:12848:the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
        -:12849:
        -:12850:static int pattern_search PARAMS ((struct file *file, int archive, unsigned int depth,
        -:12851:		unsigned int recursions));
        -:12852:
        -:12853:/* For a FILE which has no commands specified, try to figure out some
        -:12854:   from the implicit pattern rules.
        -:12855:   Returns 1 if a suitable implicit rule was found,
        -:12856:   after modifying FILE to contain the appropriate commands and deps,
        -:12857:   or returns 0 if no implicit rule was found.  */
        -:12858:
        -:12859:int
function try_implicit_rule called 948 returned 100% blocks executed 61%
      948:12860:try_implicit_rule (file, depth)
        -:12861:     struct file *file;
        -:12862:     unsigned int depth;
        -:12863:{
      948:12864:  DEBUGPR ("Looking for an implicit rule for `%s'.\n");
branch  0 taken 384 (fallthrough)
branch  1 taken 564
call    2 returned 384
call    3 returned 384
call    4 returned 384
        -:12865:
        -:12866:  /* The order of these searches was previously reversed.  My logic now is
        -:12867:     that since the non-archive search uses more information in the target
        -:12868:     (the archive search omits the archive name), it is more specific and
        -:12869:     should come first.  */
        -:12870:
      948:12871:  if (pattern_search (file, 0, depth, 0))
call    0 returned 948
branch  1 taken 60 (fallthrough)
branch  2 taken 888
       60:12872:    return 1;
        -:12873:
        -:12874:#ifndef	NO_ARCHIVES
        -:12875:  /* If this is an archive member reference, use just the
        -:12876:     archive member name to search for implicit rules.  */
      888:12877:  if (ar_name (file->name))
call    0 returned 888
branch  1 taken 0 (fallthrough)
branch  2 taken 888
        -:12878:    {
    #####:12879:      DEBUGPR ("Looking for archive-member implicit rule for `%s'.\n");
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:12880:      if (pattern_search (file, 1, depth, 0))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:12881:	return 1;
        -:12882:    }
        -:12883:#endif
        -:12884:
      888:12885:  return 0;
        -:12886:}
        -:12887:
        -:12888:#define DEBUGP2(msg, a1, a2)						      \
        -:12889:  do {									      \
        -:12890:    if (debug_flag)							      \
        -:12891:      { print_spaces (depth); printf (msg, a1, a2); fflush (stdout); }	      \
        -:12892:  } while (0)
        -:12893:
        -:12894:/* Search the pattern rules for a rule with an existing dependency to make
        -:12895:   FILE.  If a rule is found, the appropriate commands and deps are put in FILE
        -:12896:   and 1 is returned.  If not, 0 is returned.
        -:12897:
        -:12898:   If ARCHIVE is nonzero, FILE->name is of the form "LIB(MEMBER)".  A rule for
        -:12899:   "(MEMBER)" will be searched for, and "(MEMBER)" will not be chopped up into
        -:12900:   directory and filename parts.
        -:12901:
        -:12902:   If an intermediate file is found by pattern search, the intermediate file
        -:12903:   is set up as a target by the recursive call and is also made a dependency
        -:12904:   of FILE.
        -:12905:
        -:12906:   DEPTH is used for debugging messages.  */
        -:12907:
        -:12908:static int
function pattern_search called 14844 returned 100% blocks executed 75%
    14844:12909:pattern_search (file, archive, depth, recursions)
        -:12910:     struct file *file;
        -:12911:     int archive;
        -:12912:     unsigned int depth;
        -:12913:     unsigned int recursions;
        -:12914:{
        -:12915:  /* Filename we are searching for a rule for.  */
   14844*:12916:  char *filename = archive ? index (file->name, '(') : file->name;
branch  0 taken 0 (fallthrough)
branch  1 taken 14844
        -:12917:
        -:12918:  /* Length of FILENAME.  */
    14844:12919:  unsigned int namelen = strlen (filename);
        -:12920:
        -:12921:  /* The last slash in FILENAME (or nil if there is none).  */
        -:12922:  char *lastslash;
        -:12923:
        -:12924:  /* This is a file-object used as an argument in
        -:12925:     recursive calls.  It never contains any data
        -:12926:     except during a recursive call.  */
    14844:12927:  struct file *intermediate_file = 0;
        -:12928:
        -:12929:  /* List of dependencies found recursively.  */
        -:12930:  struct file **intermediate_files
    14844:12931:    = (struct file **) alloca (max_pattern_deps * sizeof (struct file *));
        -:12932:
        -:12933:  /* List of the patterns used to find intermediate files.  */
        -:12934:  char **intermediate_patterns
    14844:12935:    = (char **) alloca (max_pattern_deps * sizeof (char *));
        -:12936:
        -:12937:  /* This buffer records all the dependencies actually found for a rule.  */
    14844:12938:  char **found_files = (char **) alloca (max_pattern_deps * sizeof (char *));
        -:12939:  /* Number of dep names now in FOUND_FILES.  */
    14844:12940:  unsigned int deps_found = 0;
        -:12941:
        -:12942:  /* Names of possible dependencies are constructed in this buffer.  */
    14844:12943:  register char *depname = (char *) alloca (namelen + max_pattern_dep_length);
        -:12944:
        -:12945:  /* The start and length of the stem of FILENAME for the current rule.  */
    14844:12946:  register char *stem = 0;
    14844:12947:  register unsigned int stemlen = 0;
        -:12948:
        -:12949:  /* Buffer in which we store all the rules that are possibly applicable.  */
        -:12950:  struct rule **tryrules
    14844:12951:    = (struct rule **) alloca (num_pattern_rules * max_pattern_targets
        -:12952:			       * sizeof (struct rule *));
        -:12953:
        -:12954:  /* Number of valid elements in TRYRULES.  */
        -:12955:  unsigned int nrules;
        -:12956:
        -:12957:  /* The numbers of the rule targets of each rule
        -:12958:     in TRYRULES that matched the target file.  */
        -:12959:  unsigned int *matches
    14844:12960:    = (unsigned int *) alloca (num_pattern_rules * sizeof (unsigned int));
        -:12961:
        -:12962:  /* Each element is nonzero if LASTSLASH was used in
        -:12963:     matching the corresponding element of TRYRULES.  */
        -:12964:  char *checked_lastslash
    14844:12965:    = (char *) alloca (num_pattern_rules * sizeof (char));
        -:12966:
        -:12967:  /* The index in TRYRULES of the rule we found.  */
        -:12968:  unsigned int foundrule;
        -:12969:
        -:12970:  /* Nonzero if should consider intermediate files as dependencies.  */
        -:12971:  int intermed_ok;
        -:12972:
        -:12973:  /* Nonzero if we have matched a pattern-rule target
        -:12974:     that is not just `%'.  */
    14844:12975:  int specific_rule_matched = 0;
        -:12976:
        -:12977:  register unsigned int i;
        -:12978:  register struct rule *rule;
        -:12979:  register struct dep *dep;
        -:12980:
        -:12981:  char *p, *vp;
        -:12982:
        -:12983:#ifndef	NO_ARCHIVES
    14844:12984:  if (archive || ar_name (filename))
branch  0 taken 14844 (fallthrough)
branch  1 taken 0
call    2 returned 14844
branch  3 taken 0 (fallthrough)
branch  4 taken 14844
    #####:12985:    lastslash = 0;
        -:12986:  else
        -:12987:#endif
        -:12988:    {
        -:12989:      /* Set LASTSLASH to point at the last slash in FILENAME
        -:12990:	 but not counting any slash at the end.  (foo/bar/ counts as
        -:12991:	 bar/ in directory foo/, not empty in directory foo/bar/.)  */
        -:12992:#ifdef VMS
        -:12993:      lastslash = rindex (filename, ']');
        -:12994:#else
    14844:12995:      lastslash = rindex (filename, '/');
        -:12996:#ifdef __MSDOS__
        -:12997:      /* Handle backslashes (possibly mixed with forward slashes)
        -:12998:	 and the case of "d:file".  */
        -:12999:      {
        -:13000:	char *bslash = rindex (filename, '\\');
        -:13001:	if (lastslash == 0 || bslash > lastslash)
        -:13002:	  lastslash = bslash;
        -:13003:	if (lastslash == 0 && filename[0] && filename[1] == ':')
        -:13004:	  lastslash = filename + 1;
        -:13005:      }
        -:13006:#endif
        -:13007:#endif
    14844:13008:      if (lastslash != 0 && lastslash[1] == '\0')
branch  0 taken 13950 (fallthrough)
branch  1 taken 894
branch  2 taken 0 (fallthrough)
branch  3 taken 13950
    #####:13009:	lastslash = 0;
        -:13010:    }
        -:13011:
        -:13012:  /* First see which pattern rules match this target
        -:13013:     and may be considered.  Put them in TRYRULES.  */
        -:13014:
    14844:13015:  nrules = 0;
  1290826:13016:  for (rule = pattern_rules; rule != 0; rule = rule->next)
branch  0 taken 1275982
branch  1 taken 14844 (fallthrough)
        -:13017:    {
        -:13018:      /* If the pattern rule has deps but no commands, ignore it.
        -:13019:	 Users cancel built-in rules by redefining them without commands.  */
 1275982*:13020:      if (rule->deps != 0 && rule->cmds == 0)
branch  0 taken 801198 (fallthrough)
branch  1 taken 474784
branch  2 taken 0 (fallthrough)
branch  3 taken 801198
    #####:13021:	continue;
        -:13022:
        -:13023:      /* If this rule is in use by a parent pattern_search,
        -:13024:	 don't use it here.  */
  1275982:13025:      if (rule->in_use)
branch  0 taken 31650 (fallthrough)
branch  1 taken 1244332
        -:13026:	{
    31650:13027:	  DEBUGP2 ("Avoiding implicit rule recursion.%s%s\n", "", "");
branch  0 taken 14976 (fallthrough)
branch  1 taken 16674
call    2 returned 14976
call    3 returned 14976
call    4 returned 14976
    31650:13028:	  continue;
        -:13029:	}
        -:13030:
  2488664:13031:      for (i = 0; rule->targets[i] != 0; ++i)
branch  0 taken 1244332
branch  1 taken 1244332 (fallthrough)
        -:13032:	{
  1244332:13033:	  char *target = rule->targets[i];
  1244332:13034:	  char *suffix = rule->suffixes[i];
        -:13035:	  int check_lastslash;
        -:13036:
        -:13037:	  /* Rules that can match any filename and are not terminal
        -:13038:	     are ignored if we're recursing, so that they cannot be
        -:13039:	     intermediate files.  */
  1244332:13040:	  if (recursions > 0 && target[1] == '\0' && !rule->terminal)
branch  0 taken 1163406 (fallthrough)
branch  1 taken 80926
branch  2 taken 236409 (fallthrough)
branch  3 taken 926997
branch  4 taken 166929 (fallthrough)
branch  5 taken 69480
   166929:13041:	    continue;
        -:13042:
  1077403:13043:	  if (rule->lens[i] > namelen)
branch  0 taken 232 (fallthrough)
branch  1 taken 1077171
        -:13044:	    /* It can't possibly match.  */
      232:13045:	    continue;
        -:13046:
        -:13047:	  /* From the lengths of the filename and the pattern parts,
        -:13048:	     find the stem: the part of the filename that matches the %.  */
  1077171:13049:	  stem = filename + (suffix - target - 1);
  1077171:13050:	  stemlen = namelen - rule->lens[i] + 1;
        -:13051:
        -:13052:	  /* Set CHECK_LASTSLASH if FILENAME contains a directory
        -:13053:	     prefix and the target pattern does not contain a slash.  */
        -:13054:
        -:13055:#ifdef VMS
        -:13056:	  check_lastslash = lastslash != 0 && index (target, ']') == 0;
        -:13057:#else
  1077171:13058:	  check_lastslash = lastslash != 0 && index (target, '/') == 0;
branch  0 taken 1011375 (fallthrough)
branch  1 taken 65796
branch  2 taken 1011375 (fallthrough)
branch  3 taken 0
        -:13059:#endif
  1077171:13060:	  if (check_lastslash)
branch  0 taken 1011375 (fallthrough)
branch  1 taken 65796
        -:13061:	    {
        -:13062:	      /* In that case, don't include the
        -:13063:		 directory prefix in STEM here.  */
  1011375:13064:	      unsigned int difference = lastslash - filename + 1;
  1011375:13065:	      if (difference > stemlen)
branch  0 taken 33 (fallthrough)
branch  1 taken 1011342
       33:13066:		continue;
  1011342:13067:	      stemlen -= difference;
  1011342:13068:	      stem += difference;
        -:13069:	    }
        -:13070:
        -:13071:	  /* Check that the rule pattern matches the text before the stem.  */
  1077138:13072:	  if (check_lastslash)
branch  0 taken 1011342 (fallthrough)
branch  1 taken 65796
        -:13073:	    {
  1011342:13074:	      if (stem > (lastslash + 1)
branch  0 taken 13950 (fallthrough)
branch  1 taken 997392
    13950:13075:		  && strncmp (target, lastslash + 1, stem - lastslash - 1))
branch  0 taken 13950 (fallthrough)
branch  1 taken 0
    13950:13076:		continue;
        -:13077:	    }
    65796:13078:	  else if (stem > filename
branch  0 taken 887 (fallthrough)
branch  1 taken 64909
      887:13079:		   && strncmp (target, filename, stem - filename))
branch  0 taken 887 (fallthrough)
branch  1 taken 0
      887:13080:	    continue;
        -:13081:
        -:13082:	  /* Check that the rule pattern matches the text after the stem.
        -:13083:	     We could test simply use streq, but this way we compare the
        -:13084:	     first two characters immediately.  This saves time in the very
        -:13085:	     common case where the first character matches because it is a
        -:13086:	     period.  */
  1062301:13087:	  if (*suffix != stem[stemlen]
branch  0 taken 469907 (fallthrough)
branch  1 taken 592394
   469907:13088:	      || (*suffix != '\0' && !streq (&suffix[1], &stem[stemlen + 1])))
branch  0 taken 383489 (fallthrough)
branch  1 taken 86418
branch  2 taken 383489 (fallthrough)
branch  3 taken 0
branch  4 taken 32593 (fallthrough)
branch  5 taken 350896
branch  6 taken 32593 (fallthrough)
branch  7 taken 0
branch  8 taken 1527 (fallthrough)
branch  9 taken 31066
   944817:13089:	    continue;
        -:13090:
        -:13091:	  /* Record if we match a rule that not all filenames will match.  */
   117484:13092:	  if (target[1] != '\0')
branch  0 taken 31066 (fallthrough)
branch  1 taken 86418
    31066:13093:	    specific_rule_matched = 1;
        -:13094:
        -:13095:	  /* A rule with no dependencies and no commands exists solely to set
        -:13096:	     specific_rule_matched when it matches.  Don't try to use it.  */
   117484:13097:	  if (rule->deps == 0 && rule->cmds == 0)
branch  0 taken 14030 (fallthrough)
branch  1 taken 103454
branch  2 taken 14030 (fallthrough)
branch  3 taken 0
    14030:13098:	    continue;
        -:13099:
        -:13100:	  /* Record this rule in TRYRULES and the index of the matching
        -:13101:	     target in MATCHES.  If several targets of the same rule match,
        -:13102:	     that rule will be in TRYRULES more than once.  */
   103454:13103:	  tryrules[nrules] = rule;
   103454:13104:	  matches[nrules] = i;
   103454:13105:	  checked_lastslash[nrules] = check_lastslash;
   103454:13106:	  ++nrules;
        -:13107:	}
        -:13108:    }
        -:13109:
        -:13110:  /* If we have found a matching rule that won't match all filenames,
        -:13111:     retroactively reject any non-"terminal" rules that do always match.  */
    14844:13112:  if (specific_rule_matched)
branch  0 taken 14030 (fallthrough)
branch  1 taken 814
   102958:13113:    for (i = 0; i < nrules; ++i)
branch  0 taken 88928
branch  1 taken 14030 (fallthrough)
    88928:13114:      if (!tryrules[i]->terminal)
branch  0 taken 18778 (fallthrough)
branch  1 taken 70150
        -:13115:	{
        -:13116:	  register unsigned int j;
    35814:13117:	  for (j = 0; tryrules[i]->targets[j] != 0; ++j)
branch  0 taken 18778
branch  1 taken 17036 (fallthrough)
    18778:13118:	    if (tryrules[i]->targets[j][1] == '\0')
branch  0 taken 1742 (fallthrough)
branch  1 taken 17036
     1742:13119:	      break;
    18778:13120:	  if (tryrules[i]->targets[j] != 0)
branch  0 taken 1742 (fallthrough)
branch  1 taken 17036
     1742:13121:	    tryrules[i] = 0;
        -:13122:	}
        -:13123:
        -:13124:  /* Try each rule once without intermediate files, then once with them.  */
    44412:13125:  for (intermed_ok = 0; intermed_ok == !!intermed_ok; ++intermed_ok)
branch  0 taken 29628
branch  1 taken 14784 (fallthrough)
        -:13126:    {
        -:13127:      /* Try each pattern rule till we find one that applies.
        -:13128:	 If it does, copy the names of its dependencies (as substituted)
        -:13129:	 and store them in FOUND_FILES.  DEPS_FOUND is the number of them.  */
        -:13130:
   233176:13131:      for (i = 0; i < nrules; i++)
branch  0 taken 203608
branch  1 taken 29568 (fallthrough)
        -:13132:	{
        -:13133:	  int check_lastslash;
        -:13134:
   203608:13135:	  rule = tryrules[i];
        -:13136:
        -:13137:	  /* RULE is nil when we discover that a rule,
        -:13138:	     already placed in TRYRULES, should not be applied.  */
   203608:13139:	  if (rule == 0)
branch  0 taken 2851 (fallthrough)
branch  1 taken 200757
     2851:13140:	    continue;
        -:13141:
        -:13142:	  /* Reject any terminal rules if we're
        -:13143:	     looking to make intermediate files.  */
   200757:13144:	  if (intermed_ok && rule->terminal)
branch  0 taken 99945 (fallthrough)
branch  1 taken 100812
branch  2 taken 73885 (fallthrough)
branch  3 taken 26060
    73885:13145:	    continue;
        -:13146:
        -:13147:	  /* Mark this rule as in use so a recursive
        -:13148:	     pattern_search won't try to use it.  */
   126872:13149:	  rule->in_use = 1;
        -:13150:
        -:13151:	  /* From the lengths of the filename and the matching pattern parts,
        -:13152:	     find the stem: the part of the filename that matches the %.  */
   126872:13153:	  stem = filename
   126872:13154:	    + (rule->suffixes[matches[i]] - rule->targets[matches[i]]) - 1;
   126872:13155:	  stemlen = namelen - rule->lens[matches[i]] + 1;
   126872:13156:	  check_lastslash = checked_lastslash[i];
   126872:13157:	  if (check_lastslash)
branch  0 taken 120125 (fallthrough)
branch  1 taken 6747
        -:13158:	    {
   120125:13159:	      stem += lastslash - filename + 1;
   120125:13160:	      stemlen -= (lastslash - filename) + 1;
        -:13161:	    }
        -:13162:
   126872:13163:	  DEBUGP2 ("Trying pattern rule with stem `%.*s'.\n",
branch  0 taken 59520 (fallthrough)
branch  1 taken 67352
call    2 returned 59520
call    3 returned 59520
call    4 returned 59520
        -:13164:		   (int) stemlen, stem);
        -:13165:
        -:13166:	  /* Try each dependency; see if it "exists".  */
        -:13167:
   126872:13168:	  deps_found = 0;
   126932:13169:	  for (dep = rule->deps; dep != 0; dep = dep->next)
branch  0 taken 126872
branch  1 taken 60 (fallthrough)
        -:13170:	    {
        -:13171:	      /* If the dependency name has a %, substitute the stem.  */
  126872*:13172:	      p = index (dep_name (dep), '%');
branch  0 taken 0 (fallthrough)
branch  1 taken 126872
   126872:13173:	      if (p != 0)
branch  0 taken 126872 (fallthrough)
branch  1 taken 0
        -:13174:		{
        -:13175:		  register unsigned int i;
   126872:13176:		  if (check_lastslash)
branch  0 taken 120125 (fallthrough)
branch  1 taken 6747
        -:13177:		    {
        -:13178:		      /* Copy directory name from the original FILENAME.  */
   120125:13179:		      i = lastslash - filename + 1;
   120125:13180:		      bcopy (filename, depname, i);
        -:13181:		    }
        -:13182:		  else
     6747:13183:		    i = 0;
  126872*:13184:		  bcopy (dep_name (dep), depname + i, p - dep_name (dep));
branch  0 taken 0 (fallthrough)
branch  1 taken 126872
branch  2 taken 0 (fallthrough)
branch  3 taken 126872
  126872*:13185:		  i += p - dep_name (dep);
branch  0 taken 0 (fallthrough)
branch  1 taken 126872
   126872:13186:		  bcopy (stem, depname + i, stemlen);
   126872:13187:		  i += stemlen;
   126872:13188:		  strcpy (depname + i, p + 1);
   126872:13189:		  p = depname;
        -:13190:		}
        -:13191:	      else
    #####:13192:		p = dep_name (dep);
branch  0 never executed
branch  1 never executed
        -:13193:
        -:13194:	      /* P is now the actual dependency name as substituted.  */
        -:13195:
   126872:13196:	      if (file_impossible_p (p))
call    0 returned 126872
branch  1 taken 12971 (fallthrough)
branch  2 taken 113901
        -:13197:		{
        -:13198:		  /* If this dependency has already been ruled
        -:13199:		     "impossible", then the rule fails and don't
        -:13200:		     bother trying it on the second pass either
        -:13201:		     since we know that will fail too.  */
   12971*:13202:		  DEBUGP2 ("Rejecting impossible %s dependency `%s'.\n",
branch  0 taken 6144 (fallthrough)
branch  1 taken 6827
call    2 returned 6144
branch  3 taken 6144 (fallthrough)
branch  4 taken 0
call    5 returned 6144
call    6 returned 6144
        -:13203:			   p == depname ? "implicit" : "rule", p);
    12971:13204:		  tryrules[i] = 0;
    12971:13205:		  break;
        -:13206:		}
        -:13207:
   113901:13208:	      intermediate_files[deps_found] = 0;
        -:13209:
  113901*:13210:	      DEBUGP2 ("Trying %s dependency `%s'.\n",
branch  0 taken 53376 (fallthrough)
branch  1 taken 60525
call    2 returned 53376
branch  3 taken 53376 (fallthrough)
branch  4 taken 0
call    5 returned 53376
call    6 returned 53376
        -:13211:		       p == depname ? "implicit" : "rule", p);
        -:13212:
        -:13213:	      /* The DEP->changed flag says that this dependency resides in a
        -:13214:		 nonexistent directory.  So we normally can skip looking for
        -:13215:		 the file.  However, if CHECK_LASTSLASH is set, then the
        -:13216:		 dependency file we are actually looking for is in a different
        -:13217:		 directory (the one gotten by prepending FILENAME's directory),
        -:13218:		 so it might actually exist.  */
        -:13219:
   113901:13220:	      if ((!dep->changed || check_lastslash)
branch  0 taken 44331 (fallthrough)
branch  1 taken 69570
branch  2 taken 41850 (fallthrough)
branch  3 taken 2481
   111420:13221:		  && (lookup_file (p) != 0 || file_exists_p (p)))
call    0 returned 111420
branch  1 taken 111360 (fallthrough)
branch  2 taken 60
call    3 returned 111360
branch  4 taken 0 (fallthrough)
branch  5 taken 111360
        -:13222:		{
       60:13223:		  found_files[deps_found++] = savestring (p, strlen (p));
call    0 returned 60
       60:13224:		  continue;
        -:13225:		}
        -:13226:	      /* This code, given FILENAME = "lib/foo.o", dependency name
        -:13227:		 "lib/foo.c", and VPATH=src, searches for "src/lib/foo.c".  */
   113841:13228:	      vp = p;
  113841*:13229:	      if (vpath_search (&vp, (time_t *) 0))
call    0 returned 113841
branch  1 taken 0 (fallthrough)
branch  2 taken 113841
        -:13230:		{
    #####:13231:		  DEBUGP2 ("Found dependency `%s' as VPATH `%s'\n", p, vp);
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:13232:		  strcpy(vp, p);
    #####:13233:		  found_files[deps_found++] = vp;
    #####:13234:		  continue;
        -:13235:		}
        -:13236:
        -:13237:	      /* We could not find the file in any place we should look.
        -:13238:		 Try to make this dependency as an intermediate file,
        -:13239:		 but only on the second pass.  */
        -:13240:
   113841:13241:	      if (intermed_ok)
branch  0 taken 13896 (fallthrough)
branch  1 taken 99945
        -:13242:		{
    13896:13243:		  if (intermediate_file == 0)
branch  0 taken 4901 (fallthrough)
branch  1 taken 8995
        -:13244:		    intermediate_file
     4901:13245:		      = (struct file *) alloca (sizeof (struct file));
        -:13246:
    13896:13247:		  DEBUGP2 ("Looking for a rule with %s file `%s'.\n",
branch  0 taken 6528 (fallthrough)
branch  1 taken 7368
call    2 returned 6528
call    3 returned 6528
call    4 returned 6528
        -:13248:			   "intermediate", p);
        -:13249:
    13896:13250:		  bzero ((char *) intermediate_file, sizeof (struct file));
    13896:13251:		  intermediate_file->name = p;
   13896*:13252:		  if (pattern_search (intermediate_file, 0, depth + 1,
call    0 returned 13896
branch  1 taken 0 (fallthrough)
branch  2 taken 13896
        -:13253:				      recursions + 1))
        -:13254:		    {
    #####:13255:		      p = savestring (p, strlen (p));
call    0 never executed
    #####:13256:		      intermediate_patterns[deps_found]
    #####:13257:			= intermediate_file->name;
    #####:13258:		      intermediate_file->name = p;
    #####:13259:		      intermediate_files[deps_found] = intermediate_file;
    #####:13260:		      intermediate_file = 0;
        -:13261:		      /* Allocate an extra copy to go in FOUND_FILES,
        -:13262:			 because every elt of FOUND_FILES is consumed
        -:13263:			 or freed later.  */
    #####:13264:		      found_files[deps_found] = savestring (p, strlen (p));
call    0 never executed
    #####:13265:		      ++deps_found;
    #####:13266:		      continue;
        -:13267:		    }
        -:13268:
        -:13269:		  /* If we have tried to find P as an intermediate
        -:13270:		     file and failed, mark that name as impossible
        -:13271:		     so we won't go through the search again later.  */
    13896:13272:		  file_impossible (p);
call    0 returned 13896
        -:13273:		}
        -:13274:
        -:13275:	      /* A dependency of this rule does not exist.
        -:13276:		 Therefore, this rule fails.  */
   113841:13277:	      break;
        -:13278:	    }
        -:13279:
        -:13280:	  /* This rule is no longer `in use' for recursive searches.  */
   126872:13281:	  rule->in_use = 0;
        -:13282:
   126872:13283:	  if (dep != 0)
branch  0 taken 126812 (fallthrough)
branch  1 taken 60
        -:13284:	    {
        -:13285:	      /* This pattern rule does not apply.
        -:13286:		 If some of its dependencies succeeded,
        -:13287:		 free the data structure describing them.  */
   126812:13288:	      while (deps_found-- > 0)
branch  0 taken 0
branch  1 taken 126812
        -:13289:		{
    #####:13290:		  register struct file *f = intermediate_files[deps_found];
    #####:13291:		  free (found_files[deps_found]);
    #####:13292:		  if (f != 0
branch  0 never executed
branch  1 never executed
    #####:13293:		      && (f->stem < f->name
branch  0 never executed
branch  1 never executed
    #####:13294:			  || f->stem > f->name + strlen (f->name)))
branch  0 never executed
branch  1 never executed
    #####:13295:		    free (f->stem);
        -:13296:		}
        -:13297:	    }
        -:13298:	  else
        -:13299:	    /* This pattern rule does apply.  Stop looking for one.  */
       60:13300:	    break;
        -:13301:	}
        -:13302:
        -:13303:      /* If we found an applicable rule without
        -:13304:	 intermediate files, don't try with them.  */
    29628:13305:      if (i < nrules)
branch  0 taken 60 (fallthrough)
branch  1 taken 29568
       60:13306:	break;
        -:13307:
    29568:13308:      rule = 0;
        -:13309:    }
        -:13310:
        -:13311:  /* RULE is nil if the loop went all the way
        -:13312:     through the list and everything failed.  */
    14844:13313:  if (rule == 0)
branch  0 taken 14784 (fallthrough)
branch  1 taken 60
    14784:13314:    return 0;
        -:13315:
       60:13316:  foundrule = i;
        -:13317:
        -:13318:  /* If we are recursing, store the pattern that matched
        -:13319:     FILENAME in FILE->name for use in upper levels.  */
        -:13320:
       60:13321:  if (recursions > 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 60
        -:13322:    /* Kludge-o-matic */
    #####:13323:    file->name = rule->targets[matches[foundrule]];
        -:13324:
        -:13325:  /* FOUND_FILES lists the dependencies for the rule we found.
        -:13326:     This includes the intermediate files, if any.
        -:13327:     Convert them into entries on the deps-chain of FILE.  */
        -:13328:
      120:13329:  while (deps_found-- > 0)
branch  0 taken 60
branch  1 taken 60 (fallthrough)
        -:13330:    {
        -:13331:      register char *s;
        -:13332:
       60:13333:      if (intermediate_files[deps_found] != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 60
        -:13334:	{
        -:13335:	  /* If we need to use an intermediate file,
        -:13336:	     make sure it is entered as a target, with the info that was
        -:13337:	     found for it in the recursive pattern_search call.
        -:13338:	     We know that the intermediate file did not already exist as
        -:13339:	     a target; therefore we can assume that the deps and cmds
        -:13340:	     of F below are null before we change them.  */
        -:13341:
    #####:13342:	  struct file *imf = intermediate_files[deps_found];
    #####:13343:	  register struct file *f = enter_file (imf->name);
call    0 never executed
    #####:13344:	  f->deps = imf->deps;
    #####:13345:	  f->cmds = imf->cmds;
    #####:13346:	  f->stem = imf->stem;
    #####:13347:	  imf = lookup_file (intermediate_patterns[deps_found]);
call    0 never executed
    #####:13348:	  if (imf != 0 && imf->precious)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:13349:	    f->precious = 1;
    #####:13350:	  f->intermediate = 1;
    #####:13351:	  f->tried_implicit = 1;
    #####:13352:	  for (dep = f->deps; dep != 0; dep = dep->next)
branch  0 never executed
branch  1 never executed
        -:13353:	    {
    #####:13354:	      dep->file = enter_file (dep->name);
call    0 never executed
    #####:13355:	      dep->name = 0;
    #####:13356:	      dep->file->tried_implicit |= dep->changed;
        -:13357:	    }
    #####:13358:	  num_intermediates++;
        -:13359:	}
        -:13360:
       60:13361:      dep = (struct dep *) xmalloc (sizeof (struct dep));
call    0 returned 60
       60:13362:      s = found_files[deps_found];
       60:13363:      if (recursions == 0)
branch  0 taken 60 (fallthrough)
branch  1 taken 0
        -:13364:	{
       60:13365:	  dep->name = 0;
       60:13366:	  dep->file = lookup_file (s);
call    0 returned 60
       60:13367:	  if (dep->file == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 60
        -:13368:	    /* enter_file consumes S's storage.  */
    #####:13369:	    dep->file = enter_file (s);
call    0 never executed
        -:13370:	  else
        -:13371:	    /* A copy of S is already allocated in DEP->file->name.
        -:13372:	       So we can free S.  */
       60:13373:	    free (s);
        -:13374:	}
        -:13375:      else
        -:13376:	{
    #####:13377:	  dep->name = s;
    #####:13378:	  dep->file = 0;
    #####:13379:	  dep->changed = 0;
        -:13380:	}
       60:13381:      if (intermediate_files[deps_found] == 0 && tryrules[foundrule]->terminal)
branch  0 taken 60 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 60
        -:13382:	{
        -:13383:	  /* If the file actually existed (was not an intermediate file),
        -:13384:	     and the rule that found it was a terminal one, then we want
        -:13385:	     to mark the found file so that it will not have implicit rule
        -:13386:	     search done for it.  If we are not entering a `struct file' for
        -:13387:	     it now, we indicate this with the `changed' flag.  */
    #####:13388:	  if (dep->file == 0)
branch  0 never executed
branch  1 never executed
    #####:13389:	    dep->changed = 1;
        -:13390:	  else
    #####:13391:	    dep->file->tried_implicit = 1;
        -:13392:	}
       60:13393:      dep->next = file->deps;
       60:13394:      file->deps = dep;
        -:13395:    }
        -:13396:
       60:13397:  if (!checked_lastslash[foundrule])
branch  0 taken 60 (fallthrough)
branch  1 taken 0
        -:13398:    /* Always allocate new storage, since STEM might be
        -:13399:       on the stack for an intermediate file.  */
       60:13400:    file->stem = savestring (stem, stemlen);
call    0 returned 60
        -:13401:  else
        -:13402:    {
        -:13403:      /* We want to prepend the directory from
        -:13404:	 the original FILENAME onto the stem.  */
    #####:13405:      file->stem = (char *) xmalloc (((lastslash + 1) - filename)
    #####:13406:				     + stemlen + 1);
call    0 never executed
    #####:13407:      bcopy (filename, file->stem, (lastslash + 1) - filename);
    #####:13408:      bcopy (stem, file->stem + ((lastslash + 1) - filename), stemlen);
    #####:13409:      file->stem[((lastslash + 1) - filename) + stemlen] = '\0';
        -:13410:    }
        -:13411:
       60:13412:  file->cmds = rule->cmds;
        -:13413:
        -:13414:  /* Put the targets other than the one that
        -:13415:     matched into FILE's `also_make' member.  */
        -:13416:
        -:13417:  /* If there was only one target, there is nothing to do.  */
       60:13418:  if (rule->targets[1] != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 60
    #####:13419:    for (i = 0; rule->targets[i] != 0; ++i)
branch  0 never executed
branch  1 never executed
    #####:13420:      if (i != matches[foundrule])
branch  0 never executed
branch  1 never executed
        -:13421:	{
    #####:13422:	  struct dep *new = (struct dep *) xmalloc (sizeof (struct dep));
call    0 never executed
    #####:13423:	  new->name = p = (char *) xmalloc (rule->lens[i] + stemlen + 1);
call    0 never executed
    #####:13424:	  bcopy (rule->targets[i], p,
        -:13425:		 rule->suffixes[i] - rule->targets[i] - 1);
    #####:13426:	  p += rule->suffixes[i] - rule->targets[i] - 1;
    #####:13427:	  bcopy (stem, p, stemlen);
    #####:13428:	  p += stemlen;
    #####:13429:	  bcopy (rule->suffixes[i], p,
        -:13430:		 rule->lens[i] - (rule->suffixes[i] - rule->targets[i]) + 1);
    #####:13431:	  new->file = enter_file (new->name);
call    0 never executed
    #####:13432:	  new->next = file->also_make;
    #####:13433:	  file->also_make = new;
        -:13434:	}
        -:13435:
        -:13436:
       60:13437:  return 1;
        -:13438:}
        -:13439:
        -:13440:
        -:13441:
        -:13442:/*************************************************************
        -:13443:  ============================================================
        -:13444:  ************************************************************
        -:13445:  ============================================================
        -:13446:  ************************************************************
        -:13447:                         default.c
        -:13448:  ************************************************************
        -:13449:  ============================================================
        -:13450:  ************************************************************
        -:13451:  ============================================================
        -:13452:  *************************************************************/
        -:13453:
        -:13454:/* Data base of default implicit rules for GNU Make.
        -:13455:Copyright (C) 1988,89,90,91,92,93,94,95,96 Free Software Foundation, Inc.
        -:13456:This file is part of GNU Make.
        -:13457:
        -:13458:GNU Make is free software; you can redistribute it and/or modify
        -:13459:it under the terms of the GNU General Public License as published by
        -:13460:the Free Software Foundation; either version 2, or (at your option)
        -:13461:any later version.
        -:13462:
        -:13463:GNU Make is distributed in the hope that it will be useful,
        -:13464:but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:13465:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:13466:GNU General Public License for more details.
        -:13467:
        -:13468:You should have received a copy of the GNU General Public License
        -:13469:along with GNU Make; see the file COPYING.  If not, write to
        -:13470:the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
        -:13471:
        -:13472:/* Define GCC_IS_NATIVE if gcc is the native development environment on
        -:13473:   your system (gcc/bison/flex vs cc/yacc/lex).  */
        -:13474:#ifdef __MSDOS__
        -:13475:#define GCC_IS_NATIVE
        -:13476:#endif
        -:13477:
        -:13478:
        -:13479:/* This is the default list of suffixes for suffix rules.
        -:13480:   `.s' must come last, so that a `.o' file will be made from
        -:13481:   a `.c' or `.p' or ... file rather than from a .s file.  */
        -:13482:
        -:13483:static char default_suffixes[]
        -:13484:#ifdef VMS
        -:13485:  = ".exe .olb .ln .obj .c .cc .pas .p .for .f .r .y .l .mar \
        -:13486:.mod .sym .def .h .info .dvi .tex .texinfo .texi .txinfo \
        -:13487:.w .ch .cweb .web .com .sh .elc .el";
        -:13488:#else
        -:13489:  = ".out .a .ln .o .c .cc .C .cpp .p .f .F .r .y .l .s .S \
        -:13490:.mod .sym .def .h .info .dvi .tex .texinfo .texi .txinfo \
        -:13491:.w .ch .web .sh .elc .el";
        -:13492:#endif
        -:13493:
        -:13494:static struct pspec default_pattern_rules[] =
        -:13495:  {
        -:13496:    { "(%)", "%",
        -:13497:	"$(AR) $(ARFLAGS) $@ $<" },
        -:13498:
        -:13499:    /* The X.out rules are only in BSD's default set because
        -:13500:       BSD Make has no null-suffix rules, so `foo.out' and
        -:13501:       `foo' are the same thing.  */
        -:13502:#ifdef VMS
        -:13503:    { "%.exe", "%",
        -:13504:        "copy $< $@" },
        -:13505:#else
        -:13506:    { "%.out", "%",
        -:13507:	"@rm -f $@ \n cp $< $@" },
        -:13508:#endif
        -:13509:    /* Syntax is "ctangle foo.w foo.ch foo.c".  */
        -:13510:    { "%.c", "%.w %.ch",
        -:13511:	"$(CTANGLE) $^ $@" },
        -:13512:    { "%.tex", "%.w %.ch",
        -:13513:	"$(CWEAVE) $^ $@" },
        -:13514:
        -:13515:    { 0, 0, 0 }
        -:13516:  };
        -:13517:
        -:13518:static struct pspec default_terminal_rules[] =
        -:13519:  {
        -:13520:#ifdef VMS
        -:13521:    /* RCS.  */
        -:13522:    { "%", "%$$5lv", /* Multinet style */
        -:13523:        "if f$$search($@) .nes. \"\" then +$(CHECKOUT,v)" },
        -:13524:    { "%", "[.$$rcs]%$$5lv", /* Multinet style */
        -:13525:        "if f$$search($@) .nes. \"\" then +$(CHECKOUT,v)" },
        -:13526:    { "%", "%_v", /* Normal style */
        -:13527:        "if f$$search($@) .nes. \"\" then +$(CHECKOUT,v)" },
        -:13528:    { "%", "[.rcs]%_v", /* Normal style */
        -:13529:        "if f$$search($@) .nes. \"\" then +$(CHECKOUT,v)" },
        -:13530:
        -:13531:    /* SCCS.  */
        -:13532:	/* ain't no SCCS on vms */
        -:13533:#else
        -:13534:    /* RCS.  */
        -:13535:    { "%", "%,v",
        -:13536:	"$(CHECKOUT,v)" },
        -:13537:    { "%", "RCS/%,v",
        -:13538:	"$(CHECKOUT,v)" },
        -:13539:    { "%", "RCS/%",
        -:13540:	"$(CHECKOUT,v)" },
        -:13541:
        -:13542:    /* SCCS.  */
        -:13543:    { "%", "s.%",
        -:13544:	"$(GET) $(GFLAGS) $(SCCS_OUTPUT_OPTION) $<" },
        -:13545:    { "%", "SCCS/s.%",
        -:13546:	"$(GET) $(GFLAGS) $(SCCS_OUTPUT_OPTION) $<" },
        -:13547:#endif /* !VMS */
        -:13548:    { 0, 0, 0 }
        -:13549:  };
        -:13550:
        -:13551:static char *default_suffix_rules[] =
        -:13552:  {
        -:13553:#ifdef VMS
        -:13554:    ".obj.exe",
        -:13555:    "$(LINK.obj) $^ $(LOADLIBES) $(LDLIBS) /exe=$@",
        -:13556:    ".mar.exe",
        -:13557:    "$(LINK.mar) $^ $(LOADLIBES) $(LDLIBS) /exe=$@",
        -:13558:    ".c.exe",
        -:13559:    "$(COMPILE.c) $^ \n $(LINK.obj) $(subst .c,.obj,$^) $(LOADLIBES) $(LDLIBS) /exe=$@",
        -:13560:    ".cc.exe",
        -:13561:    "$(COMPILE.cc) $^ \n $(LINK.obj) $(subst .cc,.obj,$^) $(LOADLIBES) $(LDLIBS) /exe=$@",
        -:13562:    ".for.exe",
        -:13563:    "$(COMPILE.for) $^ \n $(LINK.obj) $(subst .for,.obj,$^) $(LOADLIBES) $(LDLIBS) /exe=$@",
        -:13564:    ".pas.exe",
        -:13565:    "$(COMPILE.pas) $^ \n $(LINK.obj) $(subst .pas,.obj,$^) $(LOADLIBES) $(LDLIBS) /exe=$@",
        -:13566:
        -:13567:    ".com",
        -:13568:    "copy $< >$@",
        -:13569:
        -:13570:    ".mar.obj",
        -:13571:    "$(COMPILE.mar) /obj=$@ $<",
        -:13572:    ".c.obj",
        -:13573:    "$(COMPILE.c) /obj=$@ $<",
        -:13574:    ".cc.obj",
        -:13575:    "$(COMPILE.cc) /obj=$@ $<",
        -:13576:    ".for.obj",
        -:13577:    "$(COMPILE.for) /obj=$@ $<",
        -:13578:    ".pas.obj",
        -:13579:    "$(COMPILE.pas) /obj=$@ $<",
        -:13580:
        -:13581:    ".y.c",
        -:13582:    "$(YACC.y) $< \n rename y_tab.c $@",
        -:13583:    ".l.c",
        -:13584:    "$(LEX.l) $< \n rename lexyy.c $@",
        -:13585:
        -:13586:    ".texinfo.info",
        -:13587:    "$(MAKEINFO) $<",
        -:13588:
        -:13589:    ".tex.dvi",
        -:13590:    "$(TEX) $<",
        -:13591:
        -:13592:#else /* ! VMS */
        -:13593:
        -:13594:    ".o",
        -:13595:    "$(LINK.o) $^ $(LOADLIBES) $(LDLIBS) -o $@",
        -:13596:    ".s",
        -:13597:    "$(LINK.s) $^ $(LOADLIBES) $(LDLIBS) -o $@",
        -:13598:    ".S",
        -:13599:    "$(LINK.S) $^ $(LOADLIBES) $(LDLIBS) -o $@",
        -:13600:    ".c",
        -:13601:    "$(LINK.c) $^ $(LOADLIBES) $(LDLIBS) -o $@",
        -:13602:    ".cc",
        -:13603:    "$(LINK.cc) $^ $(LOADLIBES) $(LDLIBS) -o $@",
        -:13604:    ".C",
        -:13605:    "$(LINK.C) $^ $(LOADLIBES) $(LDLIBS) -o $@",
        -:13606:    ".cpp",
        -:13607:    "$(LINK.cpp) $^ $(LOADLIBES) $(LDLIBS) -o $@",
        -:13608:    ".f",
        -:13609:    "$(LINK.f) $^ $(LOADLIBES) $(LDLIBS) -o $@",
        -:13610:    ".p",
        -:13611:    "$(LINK.p) $^ $(LOADLIBES) $(LDLIBS) -o $@",
        -:13612:    ".F",
        -:13613:    "$(LINK.F) $^ $(LOADLIBES) $(LDLIBS) -o $@",
        -:13614:    ".r",
        -:13615:    "$(LINK.r) $^ $(LOADLIBES) $(LDLIBS) -o $@",
        -:13616:    ".mod",
        -:13617:    "$(COMPILE.mod) -o $@ -e $@ $^",
        -:13618:
        -:13619:    ".def.sym",
        -:13620:    "$(COMPILE.def) -o $@ $<",
        -:13621:
        -:13622:    ".sh",
        -:13623:    "cat $< >$@ \n chmod a+x $@",
        -:13624:
        -:13625:    ".s.o",
        -:13626:    "$(COMPILE.s) -o $@ $<",
        -:13627:    ".S.o",
        -:13628:    "$(COMPILE.S) -o $@ $<",
        -:13629:    ".c.o",
        -:13630:    "$(COMPILE.c) $< $(OUTPUT_OPTION)",
        -:13631:    ".cc.o",
        -:13632:    "$(COMPILE.cc) $< $(OUTPUT_OPTION)",
        -:13633:    ".C.o",
        -:13634:    "$(COMPILE.C) $< $(OUTPUT_OPTION)",
        -:13635:    ".cpp.o",
        -:13636:    "$(COMPILE.cpp) $< $(OUTPUT_OPTION)",
        -:13637:    ".f.o",
        -:13638:    "$(COMPILE.f) $< $(OUTPUT_OPTION)",
        -:13639:    ".p.o",
        -:13640:    "$(COMPILE.p) $< $(OUTPUT_OPTION)",
        -:13641:    ".F.o",
        -:13642:    "$(COMPILE.F) $< $(OUTPUT_OPTION)",
        -:13643:    ".r.o",
        -:13644:    "$(COMPILE.r) $< $(OUTPUT_OPTION)",
        -:13645:    ".mod.o",
        -:13646:    "$(COMPILE.mod) -o $@ $<",
        -:13647:
        -:13648:    ".c.ln",
        -:13649:    "$(LINT.c) -C$* $<",
        -:13650:    ".y.ln",
        -:13651:#ifndef __MSDOS__
        -:13652:    "$(YACC.y) $< \n $(LINT.c) -C$* y.tab.c \n $(RM) y.tab.c",
        -:13653:#else
        -:13654:    "$(YACC.y) $< \n $(LINT.c) -C$* y_tab.c \n $(RM) y_tab.c",
        -:13655:#endif
        -:13656:    ".l.ln",
        -:13657:    "@$(RM) $*.c\n $(LEX.l) $< > $*.c\n$(LINT.c) -i $*.c -o $@\n $(RM) $*.c",
        -:13658:
        -:13659:    ".y.c",
        -:13660:#ifndef __MSDOS__
        -:13661:    "$(YACC.y) $< \n mv -f y.tab.c $@",
        -:13662:#else
        -:13663:    "$(YACC.y) $< \n mv -f y_tab.c $@",
        -:13664:#endif
        -:13665:    ".l.c",
        -:13666:    "@$(RM) $@ \n $(LEX.l) $< > $@",
        -:13667:
        -:13668:    ".F.f",
        -:13669:    "$(PREPROCESS.F) $< $(OUTPUT_OPTION)",
        -:13670:    ".r.f",
        -:13671:    "$(PREPROCESS.r) $< $(OUTPUT_OPTION)",
        -:13672:
        -:13673:    /* This might actually make lex.yy.c if there's no %R%
        -:13674:       directive in $*.l, but in that case why were you
        -:13675:       trying to make $*.r anyway?  */
        -:13676:    ".l.r",
        -:13677:    "$(LEX.l) $< > $@ \n mv -f lex.yy.r $@",
        -:13678:
        -:13679:    ".S.s",
        -:13680:    "$(PREPROCESS.S) $< > $@",
        -:13681:
        -:13682:    ".texinfo.info",
        -:13683:    "$(MAKEINFO) $(MAKEINFO_FLAGS) $< -o $@",
        -:13684:
        -:13685:    ".texi.info",
        -:13686:    "$(MAKEINFO) $(MAKEINFO_FLAGS) $< -o $@",
        -:13687:
        -:13688:    ".txinfo.info",
        -:13689:    "$(MAKEINFO) $(MAKEINFO_FLAGS) $< -o $@",
        -:13690:
        -:13691:    ".tex.dvi",
        -:13692:    "$(TEX) $<",
        -:13693:
        -:13694:    ".texinfo.dvi",
        -:13695:    "$(TEXI2DVI) $(TEXI2DVI_FLAGS) $<",
        -:13696:
        -:13697:    ".texi.dvi",
        -:13698:    "$(TEXI2DVI) $(TEXI2DVI_FLAGS) $<",
        -:13699:
        -:13700:    ".txinfo.dvi",
        -:13701:    "$(TEXI2DVI) $(TEXI2DVI_FLAGS) $<",
        -:13702:
        -:13703:    ".w.c",
        -:13704:    "$(CTANGLE) $< - $@",	/* The `-' says there is no `.ch' file.  */
        -:13705:
        -:13706:    ".web.p",
        -:13707:    "$(TANGLE) $<",
        -:13708:
        -:13709:    ".w.tex",
        -:13710:    "$(CWEAVE) $< - $@",	/* The `-' says there is no `.ch' file.  */
        -:13711:
        -:13712:    ".web.tex",
        -:13713:    "$(WEAVE) $<",
        -:13714:
        -:13715:#endif /* !VMS */
        -:13716:
        -:13717:    0, 0,
        -:13718:  };
        -:13719:
        -:13720:static char *default_variables[] =
        -:13721:  {
        -:13722:#ifdef VMS
        -:13723:    "AR", "library/obj",
        -:13724:    "ARFLAGS", "/replace",
        -:13725:    "AS", "macro",
        -:13726:    "CC", "cc",
        -:13727:    "C++", "gcc/plus",
        -:13728:    "CXX", "gcc/plus",
        -:13729:    "CO", "co",
        -:13730:    "CPP", "$(CC) /preprocess_only",
        -:13731:    "FC", "fortran",
        -:13732:    /* System V uses these, so explicit rules using them should work.
        -:13733:       However, there is no way to make implicit rules use them and FC.  */
        -:13734:    "F77", "$(FC)",
        -:13735:    "F77FLAGS", "$(FFLAGS)",
        -:13736:    "LD", "link",
        -:13737:    "LEX", "lex",
        -:13738:    "PC", "pascal",
        -:13739:    "YACC", "yacc",	/* Or "bison -y"  */
        -:13740:    "MAKEINFO", "makeinfo",
        -:13741:    "TEX", "tex",
        -:13742:    "TEXINDEX", "texindex",
        -:13743:
        -:13744:    "RM", "delete/nolog",
        -:13745:
        -:13746:    "LINK.obj", "$(LD) $(LDFLAGS)",
        -:13747:    "COMPILE.c", "$(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH)",
        -:13748:    "COMPILE.cc", "$(C++) $(C++FLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c",
        -:13749:    "YACC.y", "$(YACC) $(YFLAGS)",
        -:13750:    "LEX.l", "$(LEX) $(LFLAGS)",
        -:13751:    "COMPILE.for", "$(FC) $(FFLAGS) $(TARGET_ARCH)",
        -:13752:    "COMPILE.pas", "$(PC) $(PFLAGS) $(CPPFLAGS) $(TARGET_ARCH)",
        -:13753:    "COMPILE.mar", "$(AS) $(ASFLAGS) $(TARGET_MACH)",
        -:13754:    "LINT.c", "$(LINT) $(LINTFLAGS) $(CPPFLAGS) $(TARGET_ARCH)",
        -:13755:
        -:13756:    "MV", "rename/new_version",
        -:13757:    "CP", "copy",
        -:13758:
        -:13759:#else /* !VMS */
        -:13760:
        -:13761:    "AR", "ar",
        -:13762:    "ARFLAGS", "rv",
        -:13763:    "AS", "as",
        -:13764:#ifdef GCC_IS_NATIVE
        -:13765:    "CC", "gcc",
        -:13766:    "CXX", "gcc",
        -:13767:#else
        -:13768:    "CC", "cc",
        -:13769:    "CXX", "g++",
        -:13770:#endif
        -:13771:
        -:13772:    /* This expands to $(CO) $(COFLAGS) $< $@ if $@ does not exist,
        -:13773:       and to the empty string if $@ does exist.  */
        -:13774:    "CHECKOUT,v",
        -:13775:    "+$(patsubst $@-noexist,$(CO) $(COFLAGS) $< $@,\
        -:13776:		 $(filter-out $@,$(firstword $(wildcard $@) $@-noexist)))",
        -:13777:
        -:13778:    "CO", "co",
        -:13779:    "CPP", "$(CC) -E",
        -:13780:#ifdef	CRAY
        -:13781:    "CF77PPFLAGS", "-P",
        -:13782:    "CF77PP", "/lib/cpp",
        -:13783:    "CFT", "cft77",
        -:13784:    "CF", "cf77",
        -:13785:    "FC", "$(CF)",
        -:13786:#else	/* Not CRAY.  */
        -:13787:#ifdef	_IBMR2
        -:13788:    "FC", "xlf",
        -:13789:#else
        -:13790:#ifdef	__convex__
        -:13791:    "FC", "fc",
        -:13792:#else
        -:13793:    "FC", "f77",
        -:13794:#endif /* __convex__ */
        -:13795:#endif /* _IBMR2 */
        -:13796:    /* System V uses these, so explicit rules using them should work.
        -:13797:       However, there is no way to make implicit rules use them and FC.  */
        -:13798:    "F77", "$(FC)",
        -:13799:    "F77FLAGS", "$(FFLAGS)",
        -:13800:#endif	/* Cray.  */
        -:13801:    "GET", SCCS_GET,
        -:13802:    "LD", "ld",
        -:13803:#ifdef GCC_IS_NATIVE
        -:13804:    "LEX", "flex",
        -:13805:#else
        -:13806:    "LEX", "lex",
        -:13807:#endif
        -:13808:    "LINT", "lint",
        -:13809:    "M2C", "m2c",
        -:13810:#ifdef	pyr
        -:13811:    "PC", "pascal",
        -:13812:#else
        -:13813:#ifdef	CRAY
        -:13814:    "PC", "PASCAL",
        -:13815:    "SEGLDR", "segldr",
        -:13816:#else
        -:13817:    "PC", "pc",
        -:13818:#endif	/* CRAY.  */
        -:13819:#endif	/* pyr.  */
        -:13820:#ifdef GCC_IS_NATIVE
        -:13821:    "YACC", "bison -y",
        -:13822:#else
        -:13823:    "YACC", "yacc",	/* Or "bison -y"  */
        -:13824:#endif
        -:13825:    "MAKEINFO", "makeinfo",
        -:13826:    "TEX", "tex",
        -:13827:    "TEXI2DVI", "texi2dvi",
        -:13828:    "WEAVE", "weave",
        -:13829:    "CWEAVE", "cweave",
        -:13830:    "TANGLE", "tangle",
        -:13831:    "CTANGLE", "ctangle",
        -:13832:
        -:13833:    "RM", "rm -f",
        -:13834:
        -:13835:    "LINK.o", "$(CC) $(LDFLAGS) $(TARGET_ARCH)",
        -:13836:    "COMPILE.c", "$(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c",
        -:13837:    "LINK.c", "$(CC) $(CFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH)",
        -:13838:    "COMPILE.cc", "$(CXX) $(CXXFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c",
        -:13839:    "COMPILE.C", "$(COMPILE.cc)",
        -:13840:    "COMPILE.cpp", "$(COMPILE.cc)",
        -:13841:    "LINK.cc", "$(CXX) $(CXXFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH)",
        -:13842:    "LINK.C", "$(LINK.cc)",
        -:13843:    "LINK.cpp", "$(LINK.cc)",
        -:13844:    "YACC.y", "$(YACC) $(YFLAGS)",
        -:13845:    "LEX.l", "$(LEX) $(LFLAGS) -t",
        -:13846:    "COMPILE.f", "$(FC) $(FFLAGS) $(TARGET_ARCH) -c",
        -:13847:    "LINK.f", "$(FC) $(FFLAGS) $(LDFLAGS) $(TARGET_ARCH)",
        -:13848:    "COMPILE.F", "$(FC) $(FFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c",
        -:13849:    "LINK.F", "$(FC) $(FFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH)",
        -:13850:    "COMPILE.r", "$(FC) $(FFLAGS) $(RFLAGS) $(TARGET_ARCH) -c",
        -:13851:    "LINK.r", "$(FC) $(FFLAGS) $(RFLAGS) $(LDFLAGS) $(TARGET_ARCH)",
        -:13852:    "COMPILE.def", "$(M2C) $(M2FLAGS) $(DEFFLAGS) $(TARGET_ARCH)",
        -:13853:    "COMPILE.mod", "$(M2C) $(M2FLAGS) $(MODFLAGS) $(TARGET_ARCH)",
        -:13854:    "COMPILE.p", "$(PC) $(PFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c",
        -:13855:    "LINK.p", "$(PC) $(PFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH)",
        -:13856:    "LINK.s", "$(CC) $(ASFLAGS) $(LDFLAGS) $(TARGET_MACH)",
        -:13857:    "COMPILE.s", "$(AS) $(ASFLAGS) $(TARGET_MACH)",
        -:13858:    "LINK.S", "$(CC) $(ASFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_MACH)",
        -:13859:    "COMPILE.S", "$(CC) $(ASFLAGS) $(CPPFLAGS) $(TARGET_MACH) -c",
        -:13860:    "PREPROCESS.S", "$(CC) -E $(CPPFLAGS)",
        -:13861:    "PREPROCESS.F", "$(FC) $(FFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -F",
        -:13862:    "PREPROCESS.r", "$(FC) $(FFLAGS) $(RFLAGS) $(TARGET_ARCH) -F",
        -:13863:    "LINT.c", "$(LINT) $(LINTFLAGS) $(CPPFLAGS) $(TARGET_ARCH)",
        -:13864:
        -:13865:#ifndef	NO_MINUS_C_MINUS_O
        -:13866:    "OUTPUT_OPTION", "-o $@",
        -:13867:#endif
        -:13868:
        -:13869:#ifdef	SCCS_GET_MINUS_G
        -:13870:    "SCCS_OUTPUT_OPTION", "-G$@",
        -:13871:#endif
        -:13872:
        -:13873:#endif /* !VMS */
        -:13874:    0, 0
        -:13875:  };
        -:13876:
        -:13877:/* Set up the default .SUFFIXES list.  */
        -:13878:
        -:13879:void
function set_default_suffixes called 790 returned 100% blocks executed 100%
      790:13880:set_default_suffixes ()
        -:13881:{
      790:13882:  suffix_file = enter_file (".SUFFIXES");
call    0 returned 790
        -:13883:
      790:13884:  if (no_builtin_rules_flag)
branch  0 taken 1 (fallthrough)
branch  1 taken 789
        1:13885:    (void) define_variable ("SUFFIXES", 8, "", o_default, 0);
call    0 returned 1
        -:13886:  else
        -:13887:    {
      789:13888:      char *p = default_suffixes;
     1578:13889:      suffix_file->deps = (struct dep *)
      789:13890:	multi_glob (parse_file_seq (&p, '\0', sizeof (struct dep), 1),
call    0 returned 789
call    1 returned 789
        -:13891:		    sizeof (struct dep));
      789:13892:      (void) define_variable ("SUFFIXES", 8, default_suffixes, o_default, 0);
call    0 returned 789
        -:13893:    }
      790:13894:}
        -:13895:
        -:13896:/* Enter the default suffix rules as file rules.  This used to be done in
        -:13897:   install_default_implicit_rules, but that loses because we want the
        -:13898:   suffix rules installed before reading makefiles, and thee pattern rules
        -:13899:   installed after.  */
        -:13900:
        -:13901:void
function install_default_suffix_rules called 790 returned 100% blocks executed 100%
      790:13902:install_default_suffix_rules ()
        -:13903:{
        -:13904:  register char **s;
        -:13905:
      790:13906:  if (no_builtin_rules_flag)
branch  0 taken 1 (fallthrough)
branch  1 taken 789
        1:13907:    return;
        -:13908:
    36294:13909: for (s = default_suffix_rules; *s != 0; s += 2)
branch  0 taken 35505
branch  1 taken 789 (fallthrough)
        -:13910:    {
    35505:13911:      register struct file *f = enter_file (s[0]);
call    0 returned 35505
        -:13912:      /* Don't clobber cmds given in a makefile if there were any.  */
    35505:13913:      if (f->cmds == 0)
branch  0 taken 35505 (fallthrough)
branch  1 taken 0
        -:13914:	{
    35505:13915:	  f->cmds = (struct commands *) xmalloc (sizeof (struct commands));
call    0 returned 35505
    35505:13916:	  f->cmds->filename = 0;
    35505:13917:	  f->cmds->commands = s[1];
    35505:13918:	  f->cmds->command_lines = 0;
        -:13919:	}
        -:13920:    }
        -:13921:}
        -:13922:
        -:13923:
        -:13924:/* Install the default pattern rules.  */
        -:13925:
        -:13926:void
function install_default_implicit_rules called 790 returned 100% blocks executed 100%
      790:13927:install_default_implicit_rules ()
        -:13928:{
        -:13929:  register struct pspec *p;
        -:13930:
      790:13931:  if (no_builtin_rules_flag)
branch  0 taken 1 (fallthrough)
branch  1 taken 789
        1:13932:    return;
        -:13933:
     3945:13934:  for (p = default_pattern_rules; p->target != 0; ++p)
branch  0 taken 3156
branch  1 taken 789 (fallthrough)
     3156:13935:    install_pattern_rule (p, 0);
call    0 returned 3156
        -:13936:
     4734:13937:  for (p = default_terminal_rules; p->target != 0; ++p)
branch  0 taken 3945
branch  1 taken 789 (fallthrough)
     3945:13938:    install_pattern_rule (p, 1);
call    0 returned 3945
        -:13939:}
        -:13940:
        -:13941:void
function define_default_variables called 790 returned 100% blocks executed 100%
      790:13942:define_default_variables ()
        -:13943:{
        -:13944:  register char **s;
        -:13945:
    45820:13946:  for (s = default_variables; *s != 0; s += 2)
branch  0 taken 45030
branch  1 taken 790 (fallthrough)
    45030:13947:    (void) define_variable (s[0], strlen (s[0]), s[1], o_default, 1);
call    0 returned 45030
      790:13948:}
        -:13949:
        -:13950:
        -:13951:
        -:13952:/*************************************************************
        -:13953:  ============================================================
        -:13954:  ************************************************************
        -:13955:  ============================================================
        -:13956:  ************************************************************
        -:13957:                         variable.c
        -:13958:  ************************************************************
        -:13959:  ============================================================
        -:13960:  ************************************************************
        -:13961:  ============================================================
        -:13962:  *************************************************************/
        -:13963:
        -:13964:/* Internals of variables for GNU Make.
        -:13965:Copyright (C) 1988,89,90,91,92,93,94,96,97 Free Software Foundation, Inc.
        -:13966:This file is part of GNU Make.
        -:13967:
        -:13968:GNU Make is free software; you can redistribute it and/or modify
        -:13969:it under the terms of the GNU General Public License as published by
        -:13970:the Free Software Foundation; either version 2, or (at your option)
        -:13971:any later version.
        -:13972:
        -:13973:GNU Make is distributed in the hope that it will be useful,
        -:13974:but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:13975:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:13976:GNU General Public License for more details.
        -:13977:
        -:13978:You should have received a copy of the GNU General Public License
        -:13979:along with GNU Make; see the file COPYING.  If not, write to
        -:13980:the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
        -:13981:
        -:13982:
        -:13983:#ifdef WINDOWS32
        -:13984:#include "pathstuff.h"
        -:13985:#undef stderr
        -:13986:#define stderr stdout
        -:13987:#endif
        -:13988:
        -:13989:/* Hash table of all global variable definitions.  */
        -:13990:
        -:13991:#ifndef	VARIABLE_BUCKETS
        -:13992:#define VARIABLE_BUCKETS		523
        -:13993:#endif
        -:13994:#ifndef	PERFILE_VARIABLE_BUCKETS
        -:13995:#define	PERFILE_VARIABLE_BUCKETS	23
        -:13996:#endif
        -:13997:#ifndef	SMALL_SCOPE_VARIABLE_BUCKETS
        -:13998:#define	SMALL_SCOPE_VARIABLE_BUCKETS	13
        -:13999:#endif
        -:14000:static struct variable *variable_table[VARIABLE_BUCKETS];
        -:14001:static struct variable_set global_variable_set
        -:14002:  = { variable_table, VARIABLE_BUCKETS };
        -:14003:static struct variable_set_list global_setlist
        -:14004:  = { 0, &global_variable_set };
        -:14005:struct variable_set_list *current_variable_set_list = &global_setlist;
        -:14006:
        -:14007:static struct variable *lookup_variable_in_set PARAMS ((char *name,
        -:14008:                          unsigned int length, struct variable_set *set));
        -:14009:
        -:14010:/* Implement variables.  */
        -:14011:
        -:14012:/* Define variable named NAME with value VALUE in SET.  VALUE is copied.
        -:14013:   LENGTH is the length of NAME, which does not need to be null-terminated.
        -:14014:   ORIGIN specifies the origin of the variable (makefile, command line
        -:14015:   or environment).
        -:14016:   If RECURSIVE is nonzero a flag is set in the variable saying
        -:14017:   that it should be recursively re-expanded.  */
        -:14018:
        -:14019:struct variable *
function define_variable_in_set called 107840 returned 100% blocks executed 100%
   107840:14020:define_variable_in_set (name, length, value, origin, recursive, set)
        -:14021:     char *name;
        -:14022:     unsigned int length;
        -:14023:     char *value;
        -:14024:     enum variable_origin origin;
        -:14025:     int recursive;
        -:14026:     struct variable_set *set;
        -:14027:{
        -:14028:  register unsigned int i;
        -:14029:  register unsigned int hashval;
        -:14030:  register struct variable *v;
        -:14031:
   107840:14032:  hashval = 0;
   998564:14033:  for (i = 0; i < length; ++i)
branch  0 taken 890724
branch  1 taken 107840 (fallthrough)
   890724:14034:    HASH (hashval, name[i]);
   107840:14035:  hashval %= set->buckets;
        -:14036:
   124593:14037:  for (v = set->table[hashval]; v != 0; v = v->next)
branch  0 taken 21387
branch  1 taken 103206 (fallthrough)
    21387:14038:    if (*v->name == *name
branch  0 taken 5424 (fallthrough)
branch  1 taken 15963
     5424:14039:	&& !strncmp (v->name + 1, name + 1, length - 1)
branch  0 taken 4634 (fallthrough)
branch  1 taken 790
     4634:14040:	&& v->name[length] == '\0')
branch  0 taken 4634 (fallthrough)
branch  1 taken 0
     4634:14041:      break;
        -:14042:
   107840:14043:  if (env_overrides && origin == o_env)
branch  0 taken 32896 (fallthrough)
branch  1 taken 74944
branch  2 taken 1664 (fallthrough)
branch  3 taken 31232
     1664:14044:    origin = o_env_override;
        -:14045:
   107840:14046:  if (v != 0)
branch  0 taken 4634 (fallthrough)
branch  1 taken 103206
        -:14047:    {
     4634:14048:      if (env_overrides && v->origin == o_env)
branch  0 taken 2176 (fallthrough)
branch  1 taken 2458
branch  2 taken 384 (fallthrough)
branch  3 taken 1792
        -:14049:	/* V came from in the environment.  Since it was defined
        -:14050:	   before the switches were parsed, it wasn't affected by -e.  */
      384:14051:	v->origin = o_env_override;
        -:14052:
        -:14053:      /* A variable of this name is already defined.
        -:14054:	 If the old definition is from a stronger source
        -:14055:	 than this one, don't redefine it.  */
     4634:14056:      if ((int) origin >= (int) v->origin)
branch  0 taken 3844 (fallthrough)
branch  1 taken 790
        -:14057:	{
     3844:14058:	  if (v->value != 0)
branch  0 taken 3844 (fallthrough)
branch  1 taken 0
     3844:14059:	    free (v->value);
     3844:14060:	  v->value = savestring (value, strlen (value));
call    0 returned 3844
     3844:14061:	  v->origin = origin;
     3844:14062:	  v->recursive = recursive;
        -:14063:	}
     4634:14064:      return v;
        -:14065:    }
        -:14066:
        -:14067:  /* Create a new variable definition and add it to the hash table.  */
        -:14068:
   103206:14069:  v = (struct variable *) xmalloc (sizeof (struct variable));
call    0 returned 103206
   103206:14070:  v->name = savestring (name, length);
call    0 returned 103206
   103206:14071:  v->value = savestring (value, strlen (value));
call    0 returned 103206
   103206:14072:  v->origin = origin;
   103206:14073:  v->recursive = recursive;
   103206:14074:  v->expanding = 0;
   103206:14075:  v->per_target = 0;
   103206:14076:  v->export = v_default;
   103206:14077:  v->next = set->table[hashval];
   103206:14078:  set->table[hashval] = v;
   103206:14079:  return v;
        -:14080:}
        -:14081:
        -:14082:/* Define a variable in the current variable set.  */
        -:14083:
        -:14084:struct variable *
function define_variable called 107812 returned 100% blocks executed 100%
   107812:14085:define_variable (name, length, value, origin, recursive)
        -:14086:     char *name;
        -:14087:     unsigned int length;
        -:14088:     char *value;
        -:14089:     enum variable_origin origin;
        -:14090:     int recursive;
        -:14091:{
   215624:14092:  return define_variable_in_set (name, length, value, origin, recursive,
   107812:14093:				 current_variable_set_list->set);
call    0 returned 107812
        -:14094:}
        -:14095:
        -:14096:/* Define a variable in FILE's variable set.  */
        -:14097:
        -:14098:struct variable *
function define_variable_for_file called 28 returned 100% blocks executed 100%
       28:14099:define_variable_for_file (name, length, value, origin, recursive, file)
        -:14100:     char *name;
        -:14101:     unsigned int length;
        -:14102:     char *value;
        -:14103:     enum variable_origin origin;
        -:14104:     int recursive;
        -:14105:     struct file *file;
        -:14106:{
       56:14107:  return define_variable_in_set (name, length, value, origin, recursive,
       28:14108:				 file->variables->set);
call    0 returned 28
        -:14109:}
        -:14110:
        -:14111:/* Lookup a variable whose name is a string starting at NAME
        -:14112:   and with LENGTH chars.  NAME need not be null-terminated.
        -:14113:   Returns address of the `struct variable' containing all info
        -:14114:   on the variable, or nil if no such variable is defined.  */
        -:14115:
        -:14116:struct variable *
function lookup_variable called 4876 returned 100% blocks executed 100%
     4876:14117:lookup_variable (name, length)
        -:14118:     char *name;
        -:14119:     unsigned int length;
        -:14120:{
        -:14121:  register struct variable_set_list *setlist;
        -:14122:
        -:14123:  register unsigned int i;
     4876:14124:  register unsigned int rawhash = 0;
        -:14125:
    41878:14126:  for (i = 0; i < length; ++i)
branch  0 taken 37002
branch  1 taken 4876 (fallthrough)
    37002:14127:    HASH (rawhash, name[i]);
        -:14128:
     4876:14129:  for (setlist = current_variable_set_list;
     8087:14130:       setlist != 0; setlist = setlist->next)
branch  0 taken 4936
branch  1 taken 3151 (fallthrough)
        -:14131:    {
     4936:14132:      register struct variable_set *set = setlist->set;
     4936:14133:      register unsigned int hashval = rawhash % set->buckets;
        -:14134:      register struct variable *v;
        -:14135:
     5734:14136:      for (v = set->table[hashval]; v != 0; v = v->next)
branch  0 taken 2523
branch  1 taken 3211 (fallthrough)
     2523:14137:	if (*v->name == *name
branch  0 taken 1725 (fallthrough)
branch  1 taken 798
     1725:14138:	    && !strncmp (v->name + 1, name + 1, length - 1)
branch  0 taken 1725 (fallthrough)
branch  1 taken 0
     1725:14139:	    && v->name[length] == 0)
branch  0 taken 1725 (fallthrough)
branch  1 taken 0
     1725:14140:	  return v;
        -:14141:    }
        -:14142:
     3151:14143:  return 0;
        -:14144:}
        -:14145:
        -:14146:/* Lookup a variable whose name is a string starting at NAME
        -:14147:   and with LENGTH chars in set SET.  NAME need not be null-terminated.
        -:14148:   Returns address of the `struct variable' containing all info
        -:14149:   on the variable, or nil if no such variable is defined.  */
        -:14150:
        -:14151:static struct variable *
function lookup_variable_in_set called 0 returned 0% blocks executed 0%
    #####:14152:lookup_variable_in_set (name, length, set)
        -:14153:     char *name;
        -:14154:     unsigned int length;
        -:14155:     struct variable_set *set;
        -:14156:{
        -:14157:  register unsigned int i;
    #####:14158:  register unsigned int hash = 0;
        -:14159:  register struct variable *v;
        -:14160:
    #####:14161:  for (i = 0; i < length; ++i)
branch  0 never executed
branch  1 never executed
    #####:14162:    HASH (hash, name[i]);
    #####:14163:  hash %= set->buckets;
        -:14164:
    #####:14165:  for (v = set->table[hash]; v != 0; v = v->next)
branch  0 never executed
branch  1 never executed
    #####:14166:    if (*v->name == *name
branch  0 never executed
branch  1 never executed
    #####:14167:        && !strncmp (v->name + 1, name + 1, length - 1)
branch  0 never executed
branch  1 never executed
    #####:14168:        && v->name[length] == 0)
branch  0 never executed
branch  1 never executed
    #####:14169:      return v;
        -:14170:
    #####:14171:  return 0;
        -:14172:}
        -:14173:
        -:14174:/* Initialize FILE's variable set list.  If FILE already has a variable set
        -:14175:   list, the topmost variable set is left intact, but the the rest of the
        -:14176:   chain is replaced with FILE->parent's setlist.  */
        -:14177:
        -:14178:void
function initialize_file_variables called 9 returned 100% blocks executed 100%
        9:14179:initialize_file_variables (file)
        -:14180:     struct file *file;
        -:14181:{
        9:14182:  register struct variable_set_list *l = file->variables;
        9:14183:  if (l == 0)
branch  0 taken 8 (fallthrough)
branch  1 taken 1
        -:14184:    {
        -:14185:      l = (struct variable_set_list *)
        8:14186:	xmalloc (sizeof (struct variable_set_list));
call    0 returned 8
        8:14187:      l->set = (struct variable_set *) xmalloc (sizeof (struct variable_set));
call    0 returned 8
        8:14188:      l->set->buckets = PERFILE_VARIABLE_BUCKETS;
       16:14189:      l->set->table = (struct variable **)
        8:14190:	xmalloc (l->set->buckets * sizeof (struct variable *));
call    0 returned 8
        8:14191:      bzero ((char *) l->set->table,
        -:14192:	     l->set->buckets * sizeof (struct variable *));
        8:14193:      file->variables = l;
        -:14194:    }
        -:14195:
        9:14196:  if (file->parent == 0)
branch  0 taken 3 (fallthrough)
branch  1 taken 6
        3:14197:    l->next = &global_setlist;
        -:14198:  else
        -:14199:    {
        6:14200:      if (file->parent->variables == 0)
branch  0 taken 5 (fallthrough)
branch  1 taken 1
        5:14201:	initialize_file_variables (file->parent);
call    0 returned 5
        6:14202:      l->next = file->parent->variables;
        -:14203:    }
        9:14204:}
        -:14205:
        -:14206:/* Pop the top set off the current variable set list,
        -:14207:   and free all its storage.  */
        -:14208:
        -:14209:void
function pop_variable_scope called 0 returned 0% blocks executed 0%
    #####:14210:pop_variable_scope ()
        -:14211:{
    #####:14212:  register struct variable_set_list *setlist = current_variable_set_list;
    #####:14213:  register struct variable_set *set = setlist->set;
        -:14214:  register unsigned int i;
        -:14215:
    #####:14216:  current_variable_set_list = setlist->next;
    #####:14217:  free ((char *) setlist);
        -:14218:
    #####:14219:  for (i = 0; i < set->buckets; ++i)
branch  0 never executed
branch  1 never executed
        -:14220:    {
    #####:14221:      register struct variable *next = set->table[i];
    #####:14222:      while (next != 0)
branch  0 never executed
branch  1 never executed
        -:14223:	{
    #####:14224:	  register struct variable *v = next;
    #####:14225:	  next = v->next;
        -:14226:
    #####:14227:	  free (v->name);
    #####:14228:	  free ((char *) v);
        -:14229:	}
        -:14230:    }
    #####:14231:  free ((char *) set->table);
    #####:14232:  free ((char *) set);
    #####:14233:}
        -:14234:
        -:14235:struct variable_set_list *
function create_new_variable_set called 0 returned 0% blocks executed 0%
    #####:14236:create_new_variable_set ()
        -:14237:{
        -:14238:  register struct variable_set_list *setlist;
        -:14239:  register struct variable_set *set;
        -:14240:
    #####:14241:  set = (struct variable_set *) xmalloc (sizeof (struct variable_set));
call    0 never executed
    #####:14242:  set->buckets = SMALL_SCOPE_VARIABLE_BUCKETS;
    #####:14243:  set->table = (struct variable **)
    #####:14244:    xmalloc (set->buckets * sizeof (struct variable *));
call    0 never executed
    #####:14245:  bzero ((char *) set->table, set->buckets * sizeof (struct variable *));
        -:14246:
        -:14247:  setlist = (struct variable_set_list *)
    #####:14248:    xmalloc (sizeof (struct variable_set_list));
call    0 never executed
    #####:14249:  setlist->set = set;
    #####:14250:  setlist->next = current_variable_set_list;
        -:14251:
    #####:14252:  return setlist;
        -:14253:}
        -:14254:
        -:14255:/* Create a new variable set and push it on the current setlist.  */
        -:14256:
        -:14257:struct variable_set_list *
function push_new_variable_scope called 0 returned 0% blocks executed 0%
    #####:14258:push_new_variable_scope ()
        -:14259:{
    #####:14260:  return (current_variable_set_list = create_new_variable_set());
call    0 never executed
        -:14261:}
        -:14262:
        -:14263:/* Merge SET1 into SET0, freeing unused storage in SET1.  */
        -:14264:
        -:14265:static void
function merge_variable_sets called 0 returned 0% blocks executed 0%
    #####:14266:merge_variable_sets (set0, set1)
        -:14267:     struct variable_set *set0, *set1;
        -:14268:{
        -:14269:  register unsigned int bucket1;
        -:14270:
    #####:14271:  for (bucket1 = 0; bucket1 < set1->buckets; ++bucket1)
branch  0 never executed
branch  1 never executed
        -:14272:    {
    #####:14273:      register struct variable *v1 = set1->table[bucket1];
    #####:14274:      while (v1 != 0)
branch  0 never executed
branch  1 never executed
        -:14275:	{
    #####:14276:	  struct variable *next = v1->next;
        -:14277:	  unsigned int bucket0;
        -:14278:	  register struct variable *v0;
        -:14279:
    #####:14280:	  if (set1->buckets >= set0->buckets)
branch  0 never executed
branch  1 never executed
    #####:14281:	    bucket0 = bucket1;
        -:14282:	  else
        -:14283:	    {
        -:14284:	      register char *n;
    #####:14285:	      bucket0 = 0;
    #####:14286:	      for (n = v1->name; *n != '\0'; ++n)
branch  0 never executed
branch  1 never executed
    #####:14287:		HASH (bucket0, *n);
        -:14288:	    }
    #####:14289:	  bucket0 %= set0->buckets;
        -:14290:
    #####:14291:	  for (v0 = set0->table[bucket0]; v0 != 0; v0 = v0->next)
branch  0 never executed
branch  1 never executed
    #####:14292:	    if (streq (v0->name, v1->name))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -:14293:	      break;
        -:14294:
    #####:14295:	  if (v0 == 0)
branch  0 never executed
branch  1 never executed
        -:14296:	    {
        -:14297:	      /* There is no variable in SET0 with the same name.  */
    #####:14298:	      v1->next = set0->table[bucket0];
    #####:14299:	      set0->table[bucket0] = v1;
        -:14300:	    }
        -:14301:	  else
        -:14302:	    {
        -:14303:	      /* The same variable exists in both sets.
        -:14304:		 SET0 takes precedence.  */
    #####:14305:	      free (v1->value);
    #####:14306:	      free ((char *) v1);
        -:14307:	    }
        -:14308:
    #####:14309:	  v1 = next;
        -:14310:	}
        -:14311:    }
    #####:14312:}
        -:14313:
        -:14314:/* Merge SETLIST1 into SETLIST0, freeing unused storage in SETLIST1.  */
        -:14315:
        -:14316:void
function merge_variable_set_lists called 0 returned 0% blocks executed 0%
    #####:14317:merge_variable_set_lists (setlist0, setlist1)
        -:14318:     struct variable_set_list **setlist0, *setlist1;
        -:14319:{
    #####:14320:  register struct variable_set_list *list0 = *setlist0;
    #####:14321:  struct variable_set_list *last0 = 0;
        -:14322:
    #####:14323:  while (setlist1 != 0 && list0 != 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:14324:    {
    #####:14325:      struct variable_set_list *next = setlist1;
    #####:14326:      setlist1 = setlist1->next;
        -:14327:
    #####:14328:      merge_variable_sets (list0->set, next->set);
call    0 never executed
        -:14329:
    #####:14330:      last0 = list0;
    #####:14331:      list0 = list0->next;
        -:14332:    }
        -:14333:
    #####:14334:  if (setlist1 != 0)
branch  0 never executed
branch  1 never executed
        -:14335:    {
    #####:14336:      if (last0 == 0)
branch  0 never executed
branch  1 never executed
    #####:14337:	*setlist0 = setlist1;
        -:14338:      else
    #####:14339:	last0->next = setlist1;
        -:14340:    }
    #####:14341:}
        -:14342:
        -:14343:/* Define the automatic variables, and record the addresses
        -:14344:   of their structures so we can change their values quickly.  */
        -:14345:
        -:14346:void
function define_automatic_variables called 790 returned 100% blocks executed 88%
      790:14347:define_automatic_variables ()
        -:14348:{
        -:14349:#ifdef WINDOWS32
        -:14350:  extern char* default_shell;
        -:14351:#else
        -:14352:  extern char default_shell[];
        -:14353:#endif
        -:14354:  register struct variable *v;
        -:14355:  char buf[200];
        -:14356:
      790:14357:  sprintf (buf, "%u", makelevel);
      790:14358:  (void) define_variable ("MAKELEVEL", 9, buf, o_env, 0);
call    0 returned 790
        -:14359:
    1580*:14360:  sprintf (buf, "%s%s%s",
        -:14361:	   version_string,
     790*:14362:	   (remote_description == 0 || remote_description[0] == '\0')
branch  0 taken 0 (fallthrough)
branch  1 taken 790
branch  2 never executed
branch  3 never executed
        -:14363:	   ? "" : "-",
     790*:14364:	   (remote_description == 0 || remote_description[0] == '\0')
branch  0 taken 0 (fallthrough)
branch  1 taken 790
branch  2 never executed
branch  3 never executed
        -:14365:	   ? "" : remote_description);
      790:14366:  (void) define_variable ("MAKE_VERSION", 12, buf, o_default, 0);
call    0 returned 790
        -:14367:
        -:14368:#ifdef  __MSDOS__
        -:14369:  /* Allow to specify a special shell just for Make,
        -:14370:     and use $COMSPEC as the default $SHELL when appropriate.  */
        -:14371:  {
        -:14372:    static char shell_str[] = "SHELL";
        -:14373:    const int shlen = sizeof (shell_str) - 1;
        -:14374:    struct variable *mshp = lookup_variable ("MAKESHELL", 9);
        -:14375:    struct variable *comp = lookup_variable ("COMSPEC", 7);
        -:14376:
        -:14377:    /* Make $MAKESHELL override $SHELL even if -e is in effect.  */
        -:14378:    if (mshp)
        -:14379:      (void) define_variable (shell_str, shlen,
        -:14380:			      mshp->value, o_env_override, 0);
        -:14381:    else if (comp)
        -:14382:      {
        -:14383:	/* $COMSPEC shouldn't override $SHELL.  */
        -:14384:	struct variable *shp = lookup_variable (shell_str, shlen);
        -:14385:
        -:14386:	if (!shp)
        -:14387:	  (void) define_variable (shell_str, shlen, comp->value, o_env, 0);
        -:14388:      }
        -:14389:  }
        -:14390:#endif
        -:14391:
        -:14392:  /* This won't override any definition, but it
        -:14393:     will provide one if there isn't one there.  */
      790:14394:  v = define_variable ("SHELL", 5, default_shell, o_default, 0);
call    0 returned 790
      790:14395:  v->export = v_export;		/* Always export SHELL.  */
        -:14396:
        -:14397:  /* On MSDOS we do use SHELL from environment, since
        -:14398:     it isn't a standard environment variable on MSDOS,
        -:14399:     so whoever sets it, does that on purpose.  */
        -:14400:#ifndef __MSDOS__
        -:14401:  /* Don't let SHELL come from the environment.  */
      790:14402:  if (*v->value == '\0' || v->origin == o_env || v->origin == o_env_override)
branch  0 taken 790 (fallthrough)
branch  1 taken 0
branch  2 taken 384 (fallthrough)
branch  3 taken 406
branch  4 taken 384 (fallthrough)
branch  5 taken 0
        -:14403:    {
      790:14404:      free (v->value);
      790:14405:      v->origin = o_file;
      790:14406:      v->value = savestring (default_shell, strlen (default_shell));
call    0 returned 790
        -:14407:    }
        -:14408:#endif
        -:14409:
        -:14410:  /* Make sure MAKEFILES gets exported if it is set.  */
      790:14411:  v = define_variable ("MAKEFILES", 9, "", o_default, 0);
call    0 returned 790
      790:14412:  v->export = v_ifset;
        -:14413:
        -:14414:  /* Define the magic D and F variables in terms of
        -:14415:     the automatic variables they are variations of.  */
        -:14416:
      790:14417:  define_variable ("@D", 2, "$(patsubst %/,%,$(dir $@))", o_automatic, 1);
call    0 returned 790
      790:14418:  define_variable ("%D", 2, "$(patsubst %/,%,$(dir $%))", o_automatic, 1);
call    0 returned 790
      790:14419:  define_variable ("*D", 2, "$(patsubst %/,%,$(dir $*))", o_automatic, 1);
call    0 returned 790
      790:14420:  define_variable ("<D", 2, "$(patsubst %/,%,$(dir $<))", o_automatic, 1);
call    0 returned 790
      790:14421:  define_variable ("?D", 2, "$(patsubst %/,%,$(dir $?))", o_automatic, 1);
call    0 returned 790
      790:14422:  define_variable ("^D", 2, "$(patsubst %/,%,$(dir $^))", o_automatic, 1);
call    0 returned 790
      790:14423:  define_variable ("+D", 2, "$(patsubst %/,%,$(dir $+))", o_automatic, 1);
call    0 returned 790
      790:14424:  define_variable ("@F", 2, "$(notdir $@)", o_automatic, 1);
call    0 returned 790
      790:14425:  define_variable ("%F", 2, "$(notdir $%)", o_automatic, 1);
call    0 returned 790
      790:14426:  define_variable ("*F", 2, "$(notdir $*)", o_automatic, 1);
call    0 returned 790
      790:14427:  define_variable ("<F", 2, "$(notdir $<)", o_automatic, 1);
call    0 returned 790
      790:14428:  define_variable ("?F", 2, "$(notdir $?)", o_automatic, 1);
call    0 returned 790
      790:14429:  define_variable ("^F", 2, "$(notdir $^)", o_automatic, 1);
call    0 returned 790
      790:14430:  define_variable ("+F", 2, "$(notdir $+)", o_automatic, 1);
call    0 returned 790
      790:14431:}
        -:14432:
        -:14433:int export_all_variables;
        -:14434:
        -:14435:/* Create a new environment for FILE's commands.
        -:14436:   If FILE is nil, this is for the `shell' function.
        -:14437:   The child's MAKELEVEL variable is incremented.  */
        -:14438:
        -:14439:char **
function target_environment called 3 returned 100% blocks executed 84%
        3:14440:target_environment (file)
        -:14441:     struct file *file;
        -:14442:{
        -:14443:  struct variable_set_list *set_list;
        -:14444:  register struct variable_set_list *s;
        -:14445:  struct variable_bucket
        -:14446:    {
        -:14447:      struct variable_bucket *next;
        -:14448:      struct variable *variable;
        -:14449:    };
        -:14450:  struct variable_bucket **table;
        -:14451:  unsigned int buckets;
        -:14452:  register unsigned int i;
        -:14453:  register unsigned nvariables;
        -:14454:  char **result;
        -:14455:  unsigned int mklev_hash;
        -:14456:
        3:14457:  if (file == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####:14458:    set_list = current_variable_set_list;
        -:14459:  else
        3:14460:    set_list = file->variables;
        -:14461:
        -:14462:  /* Find the lowest number of buckets in any set in the list.  */
        3:14463:  s = set_list;
        3:14464:  buckets = s->set->buckets;
       10:14465:  for (s = s->next; s != 0; s = s->next)
branch  0 taken 7
branch  1 taken 3 (fallthrough)
        7:14466:    if (s->set->buckets < buckets)
branch  0 taken 0 (fallthrough)
branch  1 taken 7
    #####:14467:      buckets = s->set->buckets;
        -:14468:
        -:14469:  /* Find the hash value of the bucket `MAKELEVEL' will fall into.  */
        -:14470:  {
        3:14471:    char *p = "MAKELEVEL";
        3:14472:    mklev_hash = 0;
       30:14473:    while (*p != '\0')
branch  0 taken 27
branch  1 taken 3 (fallthrough)
       27:14474:      HASH (mklev_hash, *p++);
        -:14475:  }
        -:14476:
        -:14477:  /* Temporarily allocate a table with that many buckets.  */
        -:14478:  table = (struct variable_bucket **)
        3:14479:    alloca (buckets * sizeof (struct variable_bucket *));
        3:14480:  bzero ((char *) table, buckets * sizeof (struct variable_bucket *));
        -:14481:
        -:14482:  /* Run through all the variable sets in the list,
        -:14483:     accumulating variables in TABLE.  */
        3:14484:  nvariables = 0;
       13:14485:  for (s = set_list; s != 0; s = s->next)
branch  0 taken 10
branch  1 taken 3 (fallthrough)
        -:14486:    {
       10:14487:      register struct variable_set *set = s->set;
     1740:14488:      for (i = 0; i < set->buckets; ++i)
branch  0 taken 1730
branch  1 taken 10 (fallthrough)
        -:14489:	{
        -:14490:	  register struct variable *v;
     2195:14491:	  for (v = set->table[i]; v != 0; v = v->next)
branch  0 taken 465
branch  1 taken 1730 (fallthrough)
        -:14492:	    {
      465:14493:	      unsigned int j = i % buckets;
        -:14494:	      register struct variable_bucket *ov;
      465:14495:	      register char *p = v->name;
        -:14496:
      465:14497:	      if (i == mklev_hash % set->buckets
branch  0 taken 3 (fallthrough)
branch  1 taken 462
        3:14498:		  && streq (v->name, "MAKELEVEL"))
branch  0 taken 3 (fallthrough)
branch  1 taken 0
branch  2 taken 3 (fallthrough)
branch  3 taken 0
branch  4 taken 3 (fallthrough)
branch  5 taken 0
branch  6 taken 3 (fallthrough)
branch  7 taken 0
        -:14499:		/* Don't include MAKELEVEL because it will be
        -:14500:		   added specially at the end.  */
        3:14501:		continue;
        -:14502:
        -:14503:              /* If this is a per-target variable and it hasn't been touched
        -:14504:                 already then look up the global version and take its export
        -:14505:                 value.  */
     462*:14506:              if (v->per_target && v->export == v_default)
branch  0 taken 0 (fallthrough)
branch  1 taken 462
branch  2 never executed
branch  3 never executed
        -:14507:                {
        -:14508:                  struct variable *gv;
        -:14509:
    #####:14510:                  gv = lookup_variable_in_set(v->name, strlen(v->name),
call    0 never executed
        -:14511:                                              &global_variable_set);
    #####:14512:                  if (gv)
branch  0 never executed
branch  1 never executed
    #####:14513:                    v->export = gv->export;
        -:14514:                }
        -:14515:
     462*:14516:	      switch (v->export)
branch  0 taken 306
branch  1 taken 153
branch  2 taken 0
branch  3 taken 3
        -:14517:		{
      306:14518:		case v_default:
      306:14519:		  if (v->origin == o_default || v->origin == o_automatic)
branch  0 taken 129 (fallthrough)
branch  1 taken 177
branch  2 taken 63 (fallthrough)
branch  3 taken 66
        -:14520:		    /* Only export default variables by explicit request.  */
      240:14521:		    continue;
        -:14522:
       66:14523:		  if (! export_all_variables
branch  0 taken 66 (fallthrough)
branch  1 taken 0
       66:14524:		      && v->origin != o_command
branch  0 taken 66 (fallthrough)
branch  1 taken 0
       66:14525:		      && v->origin != o_env && v->origin != o_env_override)
branch  0 taken 63 (fallthrough)
branch  1 taken 3
branch  2 taken 63 (fallthrough)
branch  3 taken 0
       63:14526:		    continue;
        -:14527:
       3*:14528:		  if (*p != '_' && (*p < 'A' || *p > 'Z')
branch  0 taken 3 (fallthrough)
branch  1 taken 0
branch  2 taken 3 (fallthrough)
branch  3 taken 0
branch  4 taken 0 (fallthrough)
branch  5 taken 3
    #####:14529:		      && (*p < 'a' || *p > 'z'))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:14530:		    continue;
       18:14531:		  for (++p; *p != '\0'; ++p)
branch  0 taken 15
branch  1 taken 3 (fallthrough)
      15*:14532:		    if (*p != '_' && (*p < 'a' || *p > 'z')
branch  0 taken 15 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 15
branch  4 never executed
branch  5 never executed
      15*:14533:			&& (*p < 'A' || *p > 'Z') && (*p < '0' || *p > '9'))
branch  0 taken 15 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 15
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:14534:		      continue;
       3*:14535:		  if (*p != '\0')
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####:14536:		    continue;
        3:14537:		  break;
        -:14538:
      153:14539:                case v_export:
      153:14540:                  break;
        -:14541:
    #####:14542:                case v_noexport:
    #####:14543:                  continue;
        -:14544:
        3:14545:		case v_ifset:
        3:14546:		  if (v->origin == o_default)
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        3:14547:		    continue;
    #####:14548:		  break;
        -:14549:		}
        -:14550:
        -:14551:              /* If this was from a different-sized hash table, then
        -:14552:                 recalculate the bucket it goes in.  */
      156:14553:              if (set->buckets != buckets)
branch  0 taken 156 (fallthrough)
branch  1 taken 0
        -:14554:                {
        -:14555:                  register char *np;
        -:14556:
      156:14557:                  j = 0;
     2001:14558:                  for (np = v->name; *np != '\0'; ++np)
branch  0 taken 1845
branch  1 taken 156 (fallthrough)
     1845:14559:                    HASH (j, *np);
      156:14560:                  j %= buckets;
        -:14561:                }
        -:14562:
      327:14563:	      for (ov = table[j]; ov != 0; ov = ov->next)
branch  0 taken 171
branch  1 taken 156 (fallthrough)
      171:14564:		if (streq (v->name, ov->variable->name))
branch  0 taken 171 (fallthrough)
branch  1 taken 0
branch  2 taken 27 (fallthrough)
branch  3 taken 144
branch  4 taken 27 (fallthrough)
branch  5 taken 0
branch  6 taken 27 (fallthrough)
branch  7 taken 0
        -:14565:		  break;
        -:14566:
      156:14567:	      if (ov == 0)
branch  0 taken 156 (fallthrough)
branch  1 taken 0
        -:14568:		{
        -:14569:		  register struct variable_bucket *entry;
        -:14570:		  entry = (struct variable_bucket *)
      156:14571:		    alloca (sizeof (struct variable_bucket));
      156:14572:		  entry->next = table[j];
      156:14573:		  entry->variable = v;
      156:14574:		  table[j] = entry;
      156:14575:		  ++nvariables;
        -:14576:		}
        -:14577:	    }
        -:14578:	}
        -:14579:    }
        -:14580:
        3:14581:  result = (char **) xmalloc ((nvariables + 2) * sizeof (char *));
call    0 returned 3
        3:14582:  nvariables = 0;
       72:14583:  for (i = 0; i < buckets; ++i)
branch  0 taken 69
branch  1 taken 3 (fallthrough)
        -:14584:    {
        -:14585:      register struct variable_bucket *b;
      225:14586:      for (b = table[i]; b != 0; b = b->next)
branch  0 taken 156
branch  1 taken 69 (fallthrough)
        -:14587:	{
      156:14588:	  register struct variable *v = b->variable;
        -:14589:
        -:14590:	  /* If V is recursively expanded and didn't come from the environment,
        -:14591:	     expand its value.  If it came from the environment, it should
        -:14592:	     go back into the environment unchanged.  */
      156:14593:	  if (v->recursive
branch  0 taken 156 (fallthrough)
branch  1 taken 0
      156:14594:	      && v->origin != o_env && v->origin != o_env_override)
branch  0 taken 6 (fallthrough)
branch  1 taken 150
branch  2 taken 6 (fallthrough)
branch  3 taken 0
        6:14595:	    {
        6:14596:	      char *value = recursively_expand (v);
call    0 returned 6
        -:14597:#ifdef WINDOWS32
        -:14598:              if (strcmp(v->name, "Path") == 0 ||
        -:14599:                  strcmp(v->name, "PATH") == 0)
        -:14600:                convert_Path_to_windows32(value, ';');
        -:14601:#endif
        6:14602:	      result[nvariables++] = concat (v->name, "=", value);
call    0 returned 6
        6:14603:	      free (value);
        -:14604:	    }
        -:14605:	  else
        -:14606:#ifdef WINDOWS32
        -:14607:          {
        -:14608:            if (strcmp(v->name, "Path") == 0 ||
        -:14609:                strcmp(v->name, "PATH") == 0)
        -:14610:              convert_Path_to_windows32(v->value, ';');
        -:14611:            result[nvariables++] = concat (v->name, "=", v->value);
        -:14612:          }
        -:14613:#else
      150:14614:	    result[nvariables++] = concat (v->name, "=", v->value);
call    0 returned 150
        -:14615:#endif
        -:14616:	}
        -:14617:    }
        3:14618:  result[nvariables] = (char *) xmalloc (100);
call    0 returned 3
        3:14619:  (void) sprintf (result[nvariables], "MAKELEVEL=%u", makelevel + 1);
        3:14620:  result[++nvariables] = 0;
        -:14621:
        3:14622:  return result;
        -:14623:}
        -:14624:
        -:14625:/* Try to interpret LINE (a null-terminated string) as a variable definition.
        -:14626:
        -:14627:   ORIGIN may be o_file, o_override, o_env, o_env_override,
        -:14628:   or o_command specifying that the variable definition comes
        -:14629:   from a makefile, an override directive, the environment with
        -:14630:   or without the -e switch, or the command line.
        -:14631:
        -:14632:   See the comments for parse_variable_definition().
        -:14633:
        -:14634:   If LINE was recognized as a variable definition, a pointer to its `struct
        -:14635:   variable' is returned.  If LINE is not a variable definition, NULL is
        -:14636:   returned.  */
        -:14637:
        -:14638:struct variable *
function try_variable_definition called 987 returned 100% blocks executed 43%
      987:14639:try_variable_definition (filename, lineno, line, origin)
        -:14640:     char *filename;
        -:14641:     unsigned int lineno;
        -:14642:     char *line;
        -:14643:     enum variable_origin origin;
        -:14644:{
        -:14645:  register int c;
      987:14646:  register char *p = line;
        -:14647:  register char *beg;
        -:14648:  register char *end;
        -:14649:  enum { f_bogus,
      987:14650:         f_simple, f_recursive, f_append, f_conditional } flavor = f_bogus;
        -:14651:  char *name, *expanded_name, *value;
        -:14652:  struct variable *v;
        -:14653:
        -:14654:  while (1)
        -:14655:    {
     8547:14656:      c = *p++;
     8547:14657:      if (c == '\0' || c == '#')
branch  0 taken 8547 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 8547
    #####:14658:	return 0;
     8547:14659:      if (c == '=')
branch  0 taken 462 (fallthrough)
branch  1 taken 8085
        -:14660:	{
      462:14661:	  end = p - 1;
      462:14662:	  flavor = f_recursive;
      462:14663:	  break;
        -:14664:	}
     8085:14665:      else if (c == ':')
branch  0 taken 525 (fallthrough)
branch  1 taken 7560
      525:14666:	if (*p == '=')
branch  0 taken 0 (fallthrough)
branch  1 taken 525
        -:14667:	  {
    #####:14668:	    end = p++ - 1;
    #####:14669:	    flavor = f_simple;
    #####:14670:	    break;
        -:14671:	  }
        -:14672:	else
        -:14673:	  /* A colon other than := is a rule line, not a variable defn.  */
      525:14674:	  return 0;
    7560*:14675:      else if (c == '+' && *p == '=')
branch  0 taken 0 (fallthrough)
branch  1 taken 7560
branch  2 never executed
branch  3 never executed
        -:14676:	{
    #####:14677:	  end = p++ - 1;
    #####:14678:	  flavor = f_append;
    #####:14679:	  break;
        -:14680:	}
    7560*:14681:      else if (c == '?' && *p == '=')
branch  0 taken 0 (fallthrough)
branch  1 taken 7560
branch  2 never executed
branch  3 never executed
        -:14682:        {
    #####:14683:          end = p++ - 1;
    #####:14684:          flavor = f_conditional;
    #####:14685:          break;
        -:14686:        }
     7560:14687:      else if (c == '$')
branch  0 taken 0 (fallthrough)
branch  1 taken 7560
        -:14688:	{
        -:14689:	  /* This might begin a variable expansion reference.  Make sure we
        -:14690:	     don't misrecognize chars inside the reference as =, := or +=.  */
        -:14691:	  char closeparen;
        -:14692:	  int count;
    #####:14693:	  c = *p++;
    #####:14694:	  if (c == '(')
branch  0 never executed
branch  1 never executed
    #####:14695:	    closeparen = ')';
    #####:14696:	  else if (c == '{')
branch  0 never executed
branch  1 never executed
    #####:14697:	    closeparen = '}';
        -:14698:	  else
    #####:14699:	    continue;		/* Nope.  */
        -:14700:
        -:14701:	  /* P now points past the opening paren or brace.
        -:14702:	     Count parens or braces until it is matched.  */
    #####:14703:	  count = 0;
    #####:14704:	  for (; *p != '\0'; ++p)
branch  0 never executed
branch  1 never executed
        -:14705:	    {
    #####:14706:	      if (*p == c)
branch  0 never executed
branch  1 never executed
    #####:14707:		++count;
    #####:14708:	      else if (*p == closeparen && --count < 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:14709:		{
    #####:14710:		  ++p;
    #####:14711:		  break;
        -:14712:		}
        -:14713:	    }
        -:14714:	}
        -:14715:    }
        -:14716:
      462:14717:  beg = next_token (line);
call    0 returned 462
      924:14718:  while (end > beg && isblank (end[-1]))
branch  0 taken 924 (fallthrough)
branch  1 taken 0
branch  2 taken 462
branch  3 taken 462 (fallthrough)
      462:14719:    --end;
      462:14720:  p = next_token (p);
call    0 returned 462
        -:14721:
        -:14722:  /* Expand the name, so "$(foo)bar = baz" works.  */
      462:14723:  name = (char *) alloca (end - beg + 1);
      462:14724:  bcopy (beg, name, end - beg);
      462:14725:  name[end - beg] = '\0';
      462:14726:  expanded_name = allocated_variable_expand (name);
call    0 returned 462
        -:14727:
      462:14728:  if (expanded_name[0] == '\0')
branch  0 taken 0 (fallthrough)
branch  1 taken 462
    #####:14729:    makefile_fatal (filename, lineno, "empty variable name");
call    0 never executed
        -:14730:
        -:14731:  /* Calculate the variable's new value in VALUE.  */
        -:14732:
      462:14733:  switch (flavor)
branch  0 taken 0
branch  1 taken 0
branch  2 taken 0
branch  3 taken 462
branch  4 taken 0
branch  5 taken 0
        -:14734:    {
    #####:14735:    case f_bogus:
        -:14736:      /* Should not be possible.  */
    #####:14737:      abort ();
call    0 never executed
    #####:14738:    case f_simple:
        -:14739:      /* A simple variable definition "var := value".  Expand the value.  */
    #####:14740:      value = variable_expand (p);
call    0 never executed
    #####:14741:      break;
    #####:14742:    case f_conditional:
        -:14743:      /* A conditional variable definition "var ?= value".
        -:14744:         The value is set IFF the variable is not defined yet. */
    #####:14745:      v = lookup_variable(expanded_name, strlen(expanded_name));
call    0 never executed
    #####:14746:      if (v)
branch  0 never executed
branch  1 never executed
        -:14747:        {
    #####:14748:          free(expanded_name);
    #####:14749:          return v;
        -:14750:        }
        -:14751:      /* FALLTHROUGH */
        -:14752:    case f_recursive:
        -:14753:      /* A recursive variable definition "var = value".
        -:14754:	 The value is used verbatim.  */
      462:14755:      value = p;
      462:14756:      break;
    #####:14757:    case f_append:
        -:14758:      /* An appending variable definition "var += value".
        -:14759:	 Extract the old value and append the new one.  */
    #####:14760:      v = lookup_variable (expanded_name, strlen (expanded_name));
call    0 never executed
    #####:14761:      if (v == 0)
branch  0 never executed
branch  1 never executed
        -:14762:	{
        -:14763:	  /* There was no old value.
        -:14764:	     This becomes a normal recursive definition.  */
    #####:14765:	  value = p;
    #####:14766:	  flavor = f_recursive;
        -:14767:	}
        -:14768:      else
        -:14769:	{
        -:14770:	  /* Paste the old and new values together in VALUE.  */
        -:14771:
        -:14772:	  unsigned int oldlen, newlen;
        -:14773:
    #####:14774:	  if (v->recursive)
branch  0 never executed
branch  1 never executed
        -:14775:	    /* The previous definition of the variable was recursive.
        -:14776:	       The new value comes from the unexpanded old and new values.  */
    #####:14777:	    flavor = f_recursive;
        -:14778:	  else
        -:14779:	    /* The previous definition of the variable was simple.
        -:14780:	       The new value comes from the old value, which was expanded
        -:14781:	       when it was set; and from the expanded new value.  */
    #####:14782:	    p = variable_expand (p);
call    0 never executed
        -:14783:
    #####:14784:	  oldlen = strlen (v->value);
    #####:14785:	  newlen = strlen (p);
    #####:14786:	  value = (char *) alloca (oldlen + 1 + newlen + 1);
    #####:14787:	  bcopy (v->value, value, oldlen);
    #####:14788:	  value[oldlen] = ' ';
    #####:14789:	  bcopy (p, &value[oldlen + 1], newlen + 1);
        -:14790:	}
        -:14791:    }
        -:14792:
        -:14793:#ifdef __MSDOS__
        -:14794:  /* Many Unix Makefiles include a line saying "SHELL=/bin/sh", but
        -:14795:     non-Unix systems don't conform to this default configuration (in
        -:14796:     fact, most of them don't even have `/bin').  On the other hand,
        -:14797:     $SHELL in the environment, if set, points to the real pathname of
        -:14798:     the shell.
        -:14799:     Therefore, we generally won't let lines like "SHELL=/bin/sh" from
        -:14800:     the Makefile override $SHELL from the environment.  But first, we
        -:14801:     look for the basename of the shell in the directory where SHELL=
        -:14802:     points, and along the $PATH; if it is found in any of these places,
        -:14803:     we define $SHELL to be the actual pathname of the shell.  Thus, if
        -:14804:     you have bash.exe installed as d:/unix/bash.exe, and d:/unix is on
        -:14805:     your $PATH, then SHELL=/usr/local/bin/bash will have the effect of
        -:14806:     defining SHELL to be "d:/unix/bash.exe".  */
        -:14807:  if (origin == o_file
        -:14808:      && strcmp (expanded_name, "SHELL") == 0)
        -:14809:    {
        -:14810:      char shellpath[PATH_MAX];
        -:14811:      extern char * __dosexec_find_on_path (const char *, char *[], char *);
        -:14812:
        -:14813:      /* See if we can find "/bin/sh.exe", "/bin/sh.com", etc.  */
        -:14814:      if (__dosexec_find_on_path (value, (char **)0, shellpath))
        -:14815:	{
        -:14816:	  char *p;
        -:14817:
        -:14818:	  for (p = shellpath; *p; p++)
        -:14819:	    {
        -:14820:	      if (*p == '\\')
        -:14821:		*p = '/';
        -:14822:	    }
        -:14823:	  v = define_variable (expanded_name, strlen (expanded_name),
        -:14824:			       shellpath, origin, flavor == f_recursive);
        -:14825:	}
        -:14826:      else
        -:14827:	{
        -:14828:	  char *shellbase, *bslash;
        -:14829:	  struct variable *pathv = lookup_variable ("PATH", 4);
        -:14830:	  char *path_string;
        -:14831:	  char *fake_env[2];
        -:14832:	  size_t pathlen = 0;
        -:14833:
        -:14834:	  shellbase = rindex (value, '/');
        -:14835:	  bslash = rindex (value, '\\');
        -:14836:	  if (!shellbase || bslash > shellbase)
        -:14837:	    shellbase = bslash;
        -:14838:	  if (!shellbase && value[1] == ':')
        -:14839:	    shellbase = value + 1;
        -:14840:	  if (shellbase)
        -:14841:	    shellbase++;
        -:14842:	  else
        -:14843:	    shellbase = value;
        -:14844:
        -:14845:	  /* Search for the basename of the shell (with standard
        -:14846:	     executable extensions) along the $PATH.  */
        -:14847:	  if (pathv)
        -:14848:	    pathlen = strlen (pathv->value);
        -:14849:	  path_string = (char *)xmalloc (5 + pathlen + 2 + 1);
        -:14850:	  /* On MSDOS, current directory is considered as part of $PATH.  */
        -:14851:	  sprintf (path_string, "PATH=.;%s", pathv ? pathv->value : "");
        -:14852:	  fake_env[0] = path_string;
        -:14853:	  fake_env[1] = (char *)0;
        -:14854:	  if (__dosexec_find_on_path (shellbase, fake_env, shellpath))
        -:14855:	    {
        -:14856:	      char *p;
        -:14857:
        -:14858:	      for (p = shellpath; *p; p++)
        -:14859:		{
        -:14860:		  if (*p == '\\')
        -:14861:		    *p = '/';
        -:14862:		}
        -:14863:	      v = define_variable (expanded_name, strlen (expanded_name),
        -:14864:				   shellpath, origin, flavor == f_recursive);
        -:14865:	    }
        -:14866:	  else
        -:14867:	    v = lookup_variable (expanded_name, strlen (expanded_name));
        -:14868:
        -:14869:	  free (path_string);
        -:14870:	}
        -:14871:    }
        -:14872:  else
        -:14873:#endif /* __MSDOS__ */
        -:14874:#ifdef WINDOWS32
        -:14875:  if (origin == o_file
        -:14876:      && strcmp (expanded_name, "SHELL") == 0) {
        -:14877:    extern char* default_shell;
        -:14878:
        -:14879:    /*
        -:14880:     * Call shell locator function. If it returns TRUE, then
        -:14881:	 * set no_default_sh_exe to indicate sh was found and
        -:14882:     * set new value for SHELL variable.
        -:14883:	 */
        -:14884:    if (find_and_set_default_shell(value)) {
        -:14885:       v = define_variable (expanded_name, strlen (expanded_name),
        -:14886:                            default_shell, origin, flavor == f_recursive);
        -:14887:       no_default_sh_exe = 0;
        -:14888:    }
        -:14889:  } else
        -:14890:#endif
        -:14891:
      462:14892:  v = define_variable (expanded_name, strlen (expanded_name),
call    0 returned 462
        -:14893:		       value, origin, flavor == f_recursive);
        -:14894:
      462:14895:  free (expanded_name);
        -:14896:
      462:14897:  return v;
        -:14898:}
        -:14899:
        -:14900:/* Print information for variable V, prefixing it with PREFIX.  */
        -:14901:
        -:14902:static void
function print_variable called 50050 returned 100% blocks executed 78%
    50050:14903:print_variable (v, prefix)
        -:14904:     register struct variable *v;
        -:14905:     char *prefix;
        -:14906:{
        -:14907:  char *origin;
        -:14908:
    50050:14909:  switch (v->origin)
branch  0 taken 24255
branch  1 taken 19251
branch  2 taken 770
branch  3 taken 384
branch  4 taken 0
branch  5 taken 0
branch  6 taken 5390
branch  7 taken 0
        -:14910:    {
    24255:14911:    case o_default:
    24255:14912:      origin = "default";
    24255:14913:      break;
    19251:14914:    case o_env:
    19251:14915:      origin = "environment";
    19251:14916:      break;
      770:14917:    case o_file:
      770:14918:      origin = "makefile";
      770:14919:      break;
      384:14920:    case o_env_override:
      384:14921:      origin = "environment under -e";
      384:14922:      break;
    #####:14923:    case o_command:
    #####:14924:      origin = "command line";
    #####:14925:      break;
    #####:14926:    case o_override:
    #####:14927:      origin = "`override' directive";
    #####:14928:      break;
     5390:14929:    case o_automatic:
     5390:14930:      origin = "automatic";
     5390:14931:      break;
    #####:14932:    case o_invalid:
        -:14933:    default:
    #####:14934:      abort ();
call    0 never executed
        -:14935:      break;
        -:14936:    }
    50050:14937:  printf ("# %s\n", origin);
call    0 returned 50050
        -:14938:
    50050:14939:  fputs (prefix, stdout);
call    0 returned 50050
        -:14940:
        -:14941:  /* Is this a `define'?  */
    50050:14942:  if (v->recursive && index (v->value, '\n') != 0)
branch  0 taken 47740 (fallthrough)
branch  1 taken 2310
branch  2 taken 0 (fallthrough)
branch  3 taken 47740
    #####:14943:    printf ("define %s\n%s\nendef\n", v->name, v->value);
call    0 never executed
        -:14944:  else
        -:14945:    {
        -:14946:      register char *p;
        -:14947:
    50050:14948:      printf ("%s %s= ", v->name, v->recursive ? "" : ":");
branch  0 taken 47740 (fallthrough)
branch  1 taken 2310
call    2 returned 50050
        -:14949:
        -:14950:      /* Check if the value is just whitespace.  */
    50050:14951:      p = next_token (v->value);
call    0 returned 50050
   50050*:14952:      if (p != v->value && *p == '\0')
branch  0 taken 0 (fallthrough)
branch  1 taken 50050
branch  2 never executed
branch  3 never executed
        -:14953:	/* All whitespace.  */
    #####:14954:	printf ("$(subst ,,%s)", v->value);
call    0 never executed
    50050:14955:      else if (v->recursive)
branch  0 taken 47740 (fallthrough)
branch  1 taken 2310
    47740:14956:	fputs (v->value, stdout);
call    0 returned 47740
        -:14957:      else
        -:14958:	/* Double up dollar signs.  */
    94325:14959:	for (p = v->value; *p != '\0'; ++p)
branch  0 taken 92015
branch  1 taken 2310 (fallthrough)
        -:14960:	  {
    92015:14961:	    if (*p == '$')
branch  0 taken 0 (fallthrough)
branch  1 taken 92015
    #####:14962:	      putchar ('$');
call    0 never executed
    92015:14963:	    putchar (*p);
call    0 returned 92015
        -:14964:	  }
    50050:14965:      putchar ('\n');
call    0 returned 50050
        -:14966:    }
    50050:14967:}
        -:14968:
        -:14969:
        -:14970:/* Print all the variables in SET.  PREFIX is printed before
        -:14971:   the actual variable definitions (everything else is comments).  */
        -:14972:
        -:14973:void
function print_variable_set called 385 returned 100% blocks executed 93%
      385:14974:print_variable_set (set, prefix)
        -:14975:     register struct variable_set *set;
        -:14976:     char *prefix;
        -:14977:{
        -:14978:  register unsigned int i, nvariables, per_bucket;
        -:14979:  register struct variable *v;
        -:14980:
      385:14981:  per_bucket = nvariables = 0;
   201740:14982:  for (i = 0; i < set->buckets; ++i)
branch  0 taken 201355
branch  1 taken 385 (fallthrough)
        -:14983:    {
   201355:14984:      register unsigned int this_bucket = 0;
        -:14985:
   251405:14986:      for (v = set->table[i]; v != 0; v = v->next)
branch  0 taken 50050
branch  1 taken 201355 (fallthrough)
        -:14987:	{
    50050:14988:	  ++this_bucket;
    50050:14989:	  print_variable (v, prefix);
call    0 returned 50050
        -:14990:	}
        -:14991:
   201355:14992:      nvariables += this_bucket;
   201355:14993:      if (this_bucket > per_bucket)
branch  0 taken 770 (fallthrough)
branch  1 taken 200585
      770:14994:	per_bucket = this_bucket;
        -:14995:    }
        -:14996:
      385:14997:  if (nvariables == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 385
    #####:14998:    puts ("# No variables.");
call    0 never executed
        -:14999:  else
        -:15000:    {
      385:15001:      printf ("# %u variables in %u hash buckets.\n",
call    0 returned 385
        -:15002:	      nvariables, set->buckets);
        -:15003:#ifndef	NO_FLOAT
      385:15004:      printf ("# average of %.1f variables per bucket, \
        -:15005:max %u in one bucket.\n",
      385:15006:	      (double) nvariables / (double) set->buckets,
call    0 returned 385
        -:15007:	      per_bucket);
        -:15008:#else
        -:15009:      {
        -:15010:	int f = (nvariables * 1000 + 5) / set->buckets;
        -:15011:	printf ("# average of %d.%d variables per bucket, \
        -:15012:max %u in one bucket.\n",
        -:15013:	      f/10, f%10,
        -:15014:	      per_bucket);
        -:15015:      }
        -:15016:#endif
        -:15017:    }
      385:15018:}
        -:15019:
        -:15020:
        -:15021:/* Print the data base of variables.  */
        -:15022:
        -:15023:void
function print_variable_data_base called 385 returned 100% blocks executed 100%
      385:15024:print_variable_data_base ()
        -:15025:{
      385:15026:  puts ("\n# Variables\n");
call    0 returned 385
        -:15027:
      385:15028:  print_variable_set (&global_variable_set, "");
call    0 returned 385
      385:15029:}
        -:15030:
        -:15031:
        -:15032:/* Print all the local variables of FILE.  */
        -:15033:
        -:15034:void
function print_file_variables called 0 returned 0% blocks executed 0%
    #####:15035:print_file_variables (file)
        -:15036:     struct file *file;
        -:15037:{
    #####:15038:  if (file->variables != 0)
branch  0 never executed
branch  1 never executed
    #####:15039:    print_variable_set (file->variables->set, "# ");
call    0 never executed
    #####:15040:}
        -:15041:
        -:15042:#ifdef WINDOWS32
        -:15043:void
        -:15044:sync_Path_environment(void)
        -:15045:{
        -:15046:    char* path = allocated_variable_expand("$(Path)");
        -:15047:    static char* environ_path = NULL;
        -:15048:
        -:15049:    if (!path)
        -:15050:        return;
        -:15051:
        -:15052:    /*
        -:15053:     * If done this before, don't leak memory unnecessarily.
        -:15054:     * Free the previous entry before allocating new one.
        -:15055:     */
        -:15056:    if (environ_path)
        -:15057:        free(environ_path);
        -:15058:
        -:15059:    /*
        -:15060:     * Create something WINDOWS32 world can grok
        -:15061:     */
        -:15062:    convert_Path_to_windows32(path, ';');
        -:15063:    environ_path = concat("Path", "=", path);
        -:15064:    putenv(environ_path);
        -:15065:    free(path);
        -:15066:}
        -:15067:#endif
        -:15068:
        -:15069:
        -:15070:
        -:15071:/*************************************************************
        -:15072:  ============================================================
        -:15073:  ************************************************************
        -:15074:  ============================================================
        -:15075:  ************************************************************
        -:15076:                         expand.c
        -:15077:  ************************************************************
        -:15078:  ============================================================
        -:15079:  ************************************************************
        -:15080:  ============================================================
        -:15081:  *************************************************************/
        -:15082:
        -:15083:/* Variable expansion functions for GNU Make.
        -:15084:Copyright (C) 1988, 89, 91, 92, 93, 95 Free Software Foundation, Inc.
        -:15085:This file is part of GNU Make.
        -:15086:
        -:15087:GNU Make is free software; you can redistribute it and/or modify
        -:15088:it under the terms of the GNU General Public License as published by
        -:15089:the Free Software Foundation; either version 2, or (at your option)
        -:15090:any later version.
        -:15091:
        -:15092:GNU Make is distributed in the hope that it will be useful,
        -:15093:but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:15094:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:15095:GNU General Public License for more details.
        -:15096:
        -:15097:You should have received a copy of the GNU General Public License
        -:15098:along with GNU Make; see the file COPYING.  If not, write to
        -:15099:the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
        -:15100:
        -:15101:/* The next two describe the variable output buffer.
        -:15102:   This buffer is used to hold the variable-expansion of a line of the
        -:15103:   makefile.  It is made bigger with realloc whenever it is too small.
        -:15104:   variable_buffer_length is the size currently allocated.
        -:15105:   variable_buffer is the address of the buffer.
        -:15106:
        -:15107:   For efficiency, it's guaranteed that the buffer will always have
        -:15108:   VARIABLE_BUFFER_ZONE extra bytes allocated.  This allows you to add a few
        -:15109:   extra chars without having to call a function.  Note you should never use
        -:15110:   these bytes unless you're _sure_ you have room (you know when the buffer
        -:15111:   length was last checked.  */
        -:15112:
        -:15113:#define VARIABLE_BUFFER_ZONE    5
        -:15114:
        -:15115:static unsigned int variable_buffer_length;
        -:15116:char *variable_buffer;
        -:15117:
        -:15118:/* Subroutine of variable_expand and friends:
        -:15119:   The text to add is LENGTH chars starting at STRING to the variable_buffer.
        -:15120:   The text is added to the buffer at PTR, and the updated pointer into
        -:15121:   the buffer is returned as the value.  Thus, the value returned by
        -:15122:   each call to variable_buffer_output should be the first argument to
        -:15123:   the following call.  */
        -:15124:
        -:15125:char *
function variable_buffer_output called 23995 returned 100% blocks executed 100%
    23995:15126:variable_buffer_output (ptr, string, length)
        -:15127:     char *ptr, *string;
        -:15128:     unsigned int length;
        -:15129:{
    23995:15130:  register unsigned int newlen = length + (ptr - variable_buffer);
        -:15131:
    23995:15132:  if ((newlen + VARIABLE_BUFFER_ZONE) > variable_buffer_length)
branch  0 taken 39 (fallthrough)
branch  1 taken 23956
        -:15133:    {
       39:15134:      unsigned int offset = ptr - variable_buffer;
       39:15135:      variable_buffer_length = (newlen + 100 > 2 * variable_buffer_length
        -:15136:				? newlen + 100
       39:15137:				: 2 * variable_buffer_length);
       39:15138:      variable_buffer = (char *) xrealloc (variable_buffer,
call    0 returned 39
        -:15139:					   variable_buffer_length);
       39:15140:      ptr = variable_buffer + offset;
        -:15141:    }
        -:15142:
    23995:15143:  bcopy (string, ptr, length);
    23995:15144:  return ptr + length;
        -:15145:}
        -:15146:
        -:15147:/* Return a pointer to the beginning of the variable buffer.  */
        -:15148:
        -:15149:static char *
function initialize_variable_output called 7457 returned 100% blocks executed 100%
     7457:15150:initialize_variable_output ()
        -:15151:{
        -:15152:  /* If we don't have a variable output buffer yet, get one.  */
        -:15153:
     7457:15154:  if (variable_buffer == 0)
branch  0 taken 4562 (fallthrough)
branch  1 taken 2895
        -:15155:    {
     4562:15156:      variable_buffer_length = 200;
     4562:15157:      variable_buffer = (char *) xmalloc (variable_buffer_length);
call    0 returned 4562
     4562:15158:      variable_buffer[0] = '\0';
        -:15159:    }
        -:15160:
     7457:15161:  return variable_buffer;
        -:15162:}
        -:15163:
        -:15164:/* Recursively expand V.  The returned string is malloc'd.  */
        -:15165:
        -:15166:char *
function recursively_expand called 916 returned 100% blocks executed 57%
      916:15167:recursively_expand (v)
        -:15168:     register struct variable *v;
        -:15169:{
        -:15170:  char *value;
        -:15171:
      916:15172:  if (v->expanding)
branch  0 taken 0 (fallthrough)
branch  1 taken 916
        -:15173:    {
        -:15174:      /* Expanding V causes infinite recursion.  Lose.  */
    #####:15175:      if (reading_filename == 0)
branch  0 never executed
branch  1 never executed
    #####:15176:	fatal ("Recursive variable `%s' references itself (eventually)",
call    0 never executed
        -:15177:	       v->name);
        -:15178:      else
    #####:15179:	makefile_fatal
call    0 never executed
        -:15180:	  (reading_filename, *reading_lineno_ptr,
        -:15181:	   "Recursive variable `%s' references itself (eventually)",
        -:15182:	   v->name);
        -:15183:    }
        -:15184:
      916:15185:  v->expanding = 1;
      916:15186:  value = allocated_variable_expand (v->value);
call    0 returned 916
      916:15187:  v->expanding = 0;
        -:15188:
      916:15189:  return value;
        -:15190:}
        -:15191:
        -:15192:/* Warn that NAME is an undefined variable.  */
        -:15193:
        -:15194:#ifdef __GNUC__
        -:15195:__inline
        -:15196:#endif
        -:15197:static void
function warn_undefined called 2361 returned 100% blocks executed 40%
     2361:15198:warn_undefined (name, length)
        -:15199:     char *name;
        -:15200:     unsigned int length;
        -:15201:{
     2361:15202:  if (warn_undefined_variables_flag)
branch  0 taken 0 (fallthrough)
branch  1 taken 2361
        -:15203:    {
        -:15204:      static const char warnmsg[] = "warning: undefined variable `%.*s'";
    #####:15205:      if (reading_filename != 0)
branch  0 never executed
branch  1 never executed
    #####:15206:	makefile_error (reading_filename, *reading_lineno_ptr,
call    0 never executed
        -:15207:			warnmsg, length, name);
        -:15208:      else
    #####:15209:	error (warnmsg, length, name);
call    0 never executed
        -:15210:    }
     2361:15211:}
        -:15212:
        -:15213:/* Expand a simple reference to variable NAME, which is LENGTH chars long.  */
        -:15214:
        -:15215:#ifdef __GNUC__
        -:15216:__inline
        -:15217:#endif
        -:15218:static char *
function reference_variable called 4086 returned 100% blocks executed 100%
     4086:15219:reference_variable (o, name, length)
        -:15220:     char *o;
        -:15221:     char *name;
        -:15222:     unsigned int length;
        -:15223:{
     4086:15224:  register struct variable *v = lookup_variable (name, length);
call    0 returned 4086
        -:15225:
     4086:15226:  if (v == 0)
branch  0 taken 2361 (fallthrough)
branch  1 taken 1725
     2361:15227:    warn_undefined (name, length);
call    0 returned 2361
        -:15228:
     4086:15229:  if (v != 0 && *v->value != '\0')
branch  0 taken 1725 (fallthrough)
branch  1 taken 2361
branch  2 taken 914 (fallthrough)
branch  3 taken 811
        -:15230:    {
      914:15231:      char *value = (v->recursive ? recursively_expand (v) : v->value);
branch  0 taken 910 (fallthrough)
branch  1 taken 4
call    2 returned 910
      914:15232:      o = variable_buffer_output (o, value, strlen (value));
call    0 returned 914
      914:15233:      if (v->recursive)
branch  0 taken 910 (fallthrough)
branch  1 taken 4
      910:15234:	free (value);
        -:15235:    }
        -:15236:
     4086:15237:  return o;
        -:15238:}
        -:15239:
        -:15240:/* Scan STRING for variable references and expansion-function calls.  Only
        -:15241:   LENGTH bytes of STRING are actually scanned.  If LENGTH is -1, scan until
        -:15242:   a null byte is found.
        -:15243:
        -:15244:   Write the results to LINE, which must point into `variable_buffer'.  If
        -:15245:   LINE is NULL, start at the beginning of the buffer.
        -:15246:   Return a pointer to LINE, or to the beginning of the buffer if LINE is
        -:15247:   NULL.  */
        -:15248:
        -:15249:char *
function variable_expand_string called 8465 returned 100% blocks executed 47%
     8465:15250:variable_expand_string (line, string, length)
        -:15251:     register char *line;
        -:15252:     char *string;
        -:15253:     long length;
        -:15254:{
        -:15255:  register struct variable *v;
        -:15256:  register char *p, *o, *p1;
     8465:15257:  char save_char = '\0';
        -:15258:  unsigned int line_offset;
        -:15259:
     8465:15260:  if (!line)
branch  0 taken 7457 (fallthrough)
branch  1 taken 1008
     7457:15261:    line = initialize_variable_output();
call    0 returned 7457
        -:15262:
     8465:15263:  p = string;
     8465:15264:  o = line;
     8465:15265:  line_offset = line - variable_buffer;
        -:15266:
     8465:15267:  if (length >= 0)
branch  0 taken 1092 (fallthrough)
branch  1 taken 7373
        -:15268:    {
     1092:15269:      save_char = string[length];
     1092:15270:      string[length] = '\0';
        -:15271:    }
        -:15272:
        -:15273:  while (1)
        -:15274:    {
        -:15275:      /* Copy all following uninteresting chars all at once to the
        -:15276:         variable output buffer, and skip them.  Uninteresting chars end
        -:15277:	 at the next $ or the end of the input.  */
        -:15278:
    19805:15279:      p1 = index (p, '$');
        -:15280:
    14135:15281:      o = variable_buffer_output (o, p, p1 != 0 ? p1 - p : strlen (p) + 1);
branch  0 taken 5670 (fallthrough)
branch  1 taken 8465
call    2 returned 14135
        -:15282:
    14135:15283:      if (p1 == 0)
branch  0 taken 8465 (fallthrough)
branch  1 taken 5670
     8465:15284:	break;
     5670:15285:      p = p1 + 1;
        -:15286:
        -:15287:      /* Dispatch on the char that follows the $.  */
        -:15288:
     5670:15289:      switch (*p)
branch  0 taken 0
branch  1 taken 5666
branch  2 taken 0
branch  3 taken 4
        -:15290:	{
    #####:15291:	case '$':
        -:15292:	  /* $$ seen means output one $ to the variable output buffer.  */
    #####:15293:	  o = variable_buffer_output (o, p, 1);
call    0 never executed
    #####:15294:	  break;
        -:15295:
     5666:15296:	case '(':
        -:15297:	case '{':
        -:15298:	  /* $(...) or ${...} is the general case of substitution.  */
        -:15299:	  {
     5666:15300:	    char openparen = *p;
    5666*:15301:	    char closeparen = (openparen == '(') ? ')' : '}';
branch  0 taken 5666 (fallthrough)
branch  1 taken 0
     5666:15302:	    register char *beg = p + 1;
     5666:15303:	    int free_beg = 0;
        -:15304:	    char *op, *begp;
        -:15305:	    char *end, *colon;
        -:15306:
     5666:15307:	    op = o;
     5666:15308:	    begp = p;
     5666:15309:	    if (handle_function (&op, &begp))
call    0 returned 5666
branch  1 taken 1580 (fallthrough)
branch  2 taken 4086
        -:15310:	      {
     1580:15311:		o = op;
     1580:15312:		p = begp;
     1580:15313:		break;
        -:15314:	      }
        -:15315:
        -:15316:	    /* Is there a variable reference inside the parens or braces?
        -:15317:	       If so, expand it before expanding the entire reference.  */
        -:15318:
     4086:15319:	    end = index (beg, closeparen);
     4086:15320:	    if (end == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 4086
        -:15321:	      {
        -:15322:		/* Unterminated variable reference.  */
    #####:15323:		if (reading_filename != 0)
branch  0 never executed
branch  1 never executed
    #####:15324:		  makefile_fatal (reading_filename, *reading_lineno_ptr,
call    0 never executed
        -:15325:				  "unterminated variable reference");
        -:15326:		else
    #####:15327:		  fatal ("unterminated variable reference");
call    0 never executed
        -:15328:	      }
     4086:15329:	    p1 = lindex (beg, end, '$');
call    0 returned 4086
     4086:15330:	    if (p1 != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 4086
        -:15331:	      {
        -:15332:		/* BEG now points past the opening paren or brace.
        -:15333:		   Count parens or braces until it is matched.  */
    #####:15334:		int count = 0;
    #####:15335:		for (p = beg; *p != '\0'; ++p)
branch  0 never executed
branch  1 never executed
        -:15336:		  {
    #####:15337:		    if (*p == openparen)
branch  0 never executed
branch  1 never executed
    #####:15338:		      ++count;
    #####:15339:		    else if (*p == closeparen && --count < 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:15340:		      break;
        -:15341:		  }
        -:15342:		/* If COUNT is >= 0, there were unmatched opening parens
        -:15343:		   or braces, so we go to the simple case of a variable name
        -:15344:		   such as `$($(a)'.  */
    #####:15345:		if (count < 0)
branch  0 never executed
branch  1 never executed
        -:15346:		  {
    #####:15347:		    beg = expand_argument (beg, p); /* Expand the name.  */
call    0 never executed
    #####:15348:		    free_beg = 1; /* Remember to free BEG when finished.  */
    #####:15349:		    end = index (beg, '\0');
        -:15350:		  }
        -:15351:	      }
        -:15352:	    else
        -:15353:	      /* Advance P to the end of this reference.  After we are
        -:15354:                 finished expanding this one, P will be incremented to
        -:15355:                 continue the scan.  */
     4086:15356:	      p = end;
        -:15357:
        -:15358:	    /* This is not a reference to a built-in function and
        -:15359:	       any variable references inside are now expanded.
        -:15360:	       Is the resultant text a substitution reference?  */
        -:15361:
     4086:15362:	    colon = lindex (beg, end, ':');
call    0 returned 4086
     4086:15363:	    if (colon != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 4086
        -:15364:	      {
        -:15365:		/* This looks like a substitution reference: $(FOO:A=B).  */
        -:15366:		char *subst_beg, *subst_end, *replace_beg, *replace_end;
        -:15367:
    #####:15368:		subst_beg = colon + 1;
    #####:15369:		subst_end = index (subst_beg, '=');
    #####:15370:		if (subst_end == 0)
branch  0 never executed
branch  1 never executed
        -:15371:		  /* There is no = in sight.  Punt on the substitution
        -:15372:		     reference and treat this as a variable name containing
        -:15373:		     a colon, in the code below.  */
    #####:15374:		  colon = 0;
        -:15375:		else
        -:15376:		  {
    #####:15377:		    replace_beg = subst_end + 1;
    #####:15378:		    replace_end = end;
        -:15379:
        -:15380:		    /* Extract the variable name before the colon
        -:15381:		       and look up that variable.  */
    #####:15382:		    v = lookup_variable (beg, colon - beg);
call    0 never executed
    #####:15383:		    if (v == 0)
branch  0 never executed
branch  1 never executed
    #####:15384:		      warn_undefined (beg, colon - beg);
call    0 never executed
        -:15385:
    #####:15386:		    if (v != 0 && *v->value != '\0')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:15387:		      {
    #####:15388:			char *value = (v->recursive ? recursively_expand (v)
call    0 never executed
    #####:15389:				       : v->value);
branch  0 never executed
branch  1 never executed
        -:15390:			char *pattern, *percent;
    #####:15391:			if (free_beg)
branch  0 never executed
branch  1 never executed
        -:15392:			  {
    #####:15393:			    *subst_end = '\0';
    #####:15394:			    pattern = subst_beg;
        -:15395:			  }
        -:15396:			else
        -:15397:			  {
    #####:15398:			    pattern = (char *) alloca (subst_end - subst_beg
        -:15399:						       + 1);
    #####:15400:			    bcopy (subst_beg, pattern, subst_end - subst_beg);
    #####:15401:			    pattern[subst_end - subst_beg] = '\0';
        -:15402:			  }
    #####:15403:			percent = find_percent (pattern);
call    0 never executed
    #####:15404:			if (percent != 0)
branch  0 never executed
branch  1 never executed
        -:15405:			  {
        -:15406:			    char *replace;
    #####:15407:			    if (free_beg)
branch  0 never executed
branch  1 never executed
        -:15408:			      {
    #####:15409:				*replace_end = '\0';
    #####:15410:				replace = replace_beg;
        -:15411:			      }
        -:15412:			    else
        -:15413:			      {
    #####:15414:				replace = (char *) alloca (replace_end
        -:15415:							   - replace_beg
        -:15416:							   + 1);
    #####:15417:				bcopy (replace_beg, replace,
        -:15418:				       replace_end - replace_beg);
    #####:15419:				replace[replace_end - replace_beg] = '\0';
        -:15420:			      }
        -:15421:
    #####:15422:			    o = patsubst_expand (o, value, pattern, replace,
call    0 never executed
        -:15423:						 percent, (char *) 0);
        -:15424:			  }
        -:15425:			else
    #####:15426:			  o = subst_expand (o, value,
        -:15427:					    pattern, replace_beg,
    #####:15428:					    strlen (pattern),
    #####:15429:					    end - replace_beg,
call    0 never executed
        -:15430:					    0, 1);
    #####:15431:			if (v->recursive)
branch  0 never executed
branch  1 never executed
    #####:15432:			  free (value);
        -:15433:		      }
        -:15434:		  }
        -:15435:	      }
        -:15436:
     4086:15437:	    if (colon == 0)
branch  0 taken 4086 (fallthrough)
branch  1 taken 0
        -:15438:	      /* This is an ordinary variable reference.
        -:15439:		 Look up the value of the variable.  */
     4086:15440:		o = reference_variable (o, beg, end - beg);
call    0 returned 4086
        -:15441:
     4086:15442:	  if (free_beg)
branch  0 taken 0 (fallthrough)
branch  1 taken 4086
    #####:15443:	    free (beg);
        -:15444:	  }
     4086:15445:	  break;
        -:15446:
    #####:15447:	case '\0':
    #####:15448:	  break;
        -:15449:
        4:15450:	default:
        4:15451:	  if (isblank (p[-1]))
branch  0 taken 0 (fallthrough)
branch  1 taken 4
    #####:15452:	    break;
        -:15453:
        -:15454:	  /* A $ followed by a random char is a variable reference:
        -:15455:	     $a is equivalent to $(a).  */
        -:15456:	  {
        -:15457:	    /* We could do the expanding here, but this way
        -:15458:	       avoids code repetition at a small performance cost.  */
        -:15459:	    char name[5];
        4:15460:	    name[0] = '$';
        4:15461:	    name[1] = '(';
        4:15462:	    name[2] = *p;
        4:15463:	    name[3] = ')';
        4:15464:	    name[4] = '\0';
        4:15465:	    p1 = allocated_variable_expand (name);
call    0 returned 4
        4:15466:	    o = variable_buffer_output (o, p1, strlen (p1));
call    0 returned 4
        4:15467:	    free (p1);
        -:15468:	  }
        -:15469:
        4:15470:	  break;
        -:15471:	}
        -:15472:
     5670:15473:      if (*p == '\0')
branch  0 taken 0 (fallthrough)
branch  1 taken 5670
    #####:15474:	break;
        -:15475:      else
     5670:15476:	++p;
        -:15477:    }
        -:15478:
     8465:15479:  if (save_char)
branch  0 taken 1008 (fallthrough)
branch  1 taken 7457
     1008:15480:    string[length] = save_char;
        -:15481:
     8465:15482:  (void)variable_buffer_output (o, "", 1);
call    0 returned 8465
     8465:15483:  return (variable_buffer + line_offset);
        -:15484:}
        -:15485:
        -:15486:/* Scan LINE for variable references and expansion-function calls.
        -:15487:   Build in `variable_buffer' the result of expanding the references and calls.
        -:15488:   Return the address of the resulting string, which is null-terminated
        -:15489:   and is valid only until the next time this function is called.  */
        -:15490:
        -:15491:char *
function variable_expand called 6932 returned 100% blocks executed 100%
     6932:15492:variable_expand (line)
        -:15493:     char *line;
        -:15494:{
     6932:15495:  return variable_expand_string(NULL, line, -1);
call    0 returned 6932
        -:15496:}
        -:15497:
        -:15498:/* Expand an argument for an expansion function.
        -:15499:   The text starting at STR and ending at END is variable-expanded
        -:15500:   into a null-terminated string that is returned as the value.
        -:15501:   This is done without clobbering `variable_buffer' or the current
        -:15502:   variable-expansion that is in progress.  */
        -:15503:
        -:15504:char *
function expand_argument called 1580 returned 100% blocks executed 80%
     1580:15505:expand_argument (str, end)
        -:15506:     char *str, *end;
        -:15507:{
        -:15508:  char *tmp;
        -:15509:
     1580:15510:  if (*end == '\0')
branch  0 taken 0 (fallthrough)
branch  1 taken 1580
    #####:15511:    tmp = str;
        -:15512:  else
        -:15513:    {
     1580:15514:      tmp = (char *) alloca (end - str + 1);
     1580:15515:      bcopy (str, tmp, end - str);
     1580:15516:      tmp[end - str] = '\0';
        -:15517:    }
        -:15518:
     1580:15519:  return allocated_variable_expand (tmp);
call    0 returned 1580
        -:15520:}
        -:15521:
        -:15522:/* Expand LINE for FILE.  Error messages refer to the file and line where
        -:15523:   FILE's commands were found.  Expansion uses FILE's variable set list.  */
        -:15524:
        -:15525:static char *
function variable_expand_for_file called 3769 returned 100% blocks executed 91%
     3769:15526:variable_expand_for_file (line, file)
        -:15527:     char *line;
        -:15528:     register struct file *file;
        -:15529:{
        -:15530:  char *result;
        -:15531:  struct variable_set_list *save, *fnext;
        -:15532:
     3769:15533:  if (file == 0)
branch  0 taken 3757 (fallthrough)
branch  1 taken 12
     3757:15534:    return variable_expand (line);
call    0 returned 3757
        -:15535:
       12:15536:  save = current_variable_set_list;
       12:15537:  current_variable_set_list = file->variables;
       12:15538:  reading_filename = file->cmds->filename;
       12:15539:  reading_lineno_ptr = &file->cmds->lineno;
       12:15540:  fnext = file->variables->next;
        -:15541:  /* See if there's a pattern-specific variable struct for this target.  */
       12:15542:  if (!file->pat_searched)
branch  0 taken 4 (fallthrough)
branch  1 taken 8
        -:15543:    {
        4:15544:      file->patvar = lookup_pattern_var(file->name);
call    0 returned 4
        4:15545:      file->pat_searched = 1;
        -:15546:    }
       12:15547:  if (file->patvar != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 12
        -:15548:    {
    #####:15549:      file->patvar->vars->next = fnext;
    #####:15550:      file->variables->next = file->patvar->vars;
        -:15551:    }
       12:15552:  result = variable_expand (line);
call    0 returned 12
       12:15553:  current_variable_set_list = save;
       12:15554:  reading_filename = 0;
       12:15555:  reading_lineno_ptr = 0;
       12:15556:  file->variables->next = fnext;
        -:15557:
       12:15558:  return result;
        -:15559:}
        -:15560:
        -:15561:/* Like variable_expand_for_file, but the returned string is malloc'd.
        -:15562:   This function is called a lot.  It wants to be efficient.  */
        -:15563:
        -:15564:char *
function allocated_variable_expand_for_file called 3769 returned 100% blocks executed 100%
     3769:15565:allocated_variable_expand_for_file (line, file)
        -:15566:     char *line;
        -:15567:     struct file *file;
        -:15568:{
        -:15569:  char *value;
        -:15570:
     3769:15571:  char *obuf = variable_buffer;
     3769:15572:  unsigned int olen = variable_buffer_length;
        -:15573:
     3769:15574:  variable_buffer = 0;
        -:15575:
     3769:15576:  value = variable_expand_for_file (line, file);
call    0 returned 3769
        -:15577:
        -:15578:#if 0
        -:15579:  /* Waste a little memory and save time.  */
        -:15580:  value = xrealloc (value, strlen (value))
        -:15581:#endif
        -:15582:
     3769:15583:  variable_buffer = obuf;
     3769:15584:  variable_buffer_length = olen;
        -:15585:
     3769:15586:  return value;
        -:15587:}
        -:15588:
        -:15589:
        -:15590:
        -:15591:/*************************************************************
        -:15592:  ============================================================
        -:15593:  ************************************************************
        -:15594:  ============================================================
        -:15595:  ************************************************************
        -:15596:                         function.c
        -:15597:  ************************************************************
        -:15598:  ============================================================
        -:15599:  ************************************************************
        -:15600:  ============================================================
        -:15601:  *************************************************************/
        -:15602:
        -:15603:/* Variable function expansion for GNU Make.
        -:15604:Copyright (C) 1988,89,91,92,93,94,95,96,97 Free Software Foundation, Inc.
        -:15605:This file is part of GNU Make.
        -:15606:
        -:15607:GNU Make is free software; you can redistribute it and/or modify
        -:15608:it under the terms of the GNU General Public License as published by
        -:15609:the Free Software Foundation; either version 2, or (at your option)
        -:15610:any later version.
        -:15611:
        -:15612:GNU Make is distributed in the hope that it will be useful,
        -:15613:but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:15614:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:15615:GNU General Public License for more details.
        -:15616:
        -:15617:You should have received a copy of the GNU General Public License
        -:15618:along with GNU Make; see the file COPYING.  If not, write to
        -:15619:the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
        -:15620:
        -:15621:
        -:15622:#ifdef _AMIGA
        -:15623:#include "amiga.h"
        -:15624:#undef stderr
        -:15625:#define stderr stdout
        -:15626:#endif
        -:15627:#ifdef WINDOWS32
        -:15628:#include <windows.h>
        -:15629:#undef stderr
        -:15630:#define stderr stdout
        -:15631:#include <io.h>
        -:15632:#include "sub_proc.h"
        -:15633:#undef stderr
        -:15634:#define stderr stdout
        -:15635:#endif
        -:15636:
        -:15637:static char *string_glob PARAMS ((char *line));
        -:15638:
        -:15639:/* Store into VARIABLE_BUFFER at O the result of scanning TEXT and replacing
        -:15640:   each occurrence of SUBST with REPLACE. TEXT is null-terminated.  SLEN is
        -:15641:   the length of SUBST and RLEN is the length of REPLACE.  If BY_WORD is
        -:15642:   nonzero, substitutions are done only on matches which are complete
        -:15643:   whitespace-delimited words.  If SUFFIX_ONLY is nonzero, substitutions are
        -:15644:   done only at the ends of whitespace-delimited words.  */
        -:15645:
        -:15646:char *
function subst_expand called 0 returned 0% blocks executed 0%
    #####:15647:subst_expand (o, text, subst, replace, slen, rlen, by_word, suffix_only)
        -:15648:     char *o;
        -:15649:     char *text;
        -:15650:     char *subst, *replace;
        -:15651:     unsigned int slen, rlen;
        -:15652:     int by_word, suffix_only;
        -:15653:{
    #####:15654:  register char *t = text;
        -:15655:  register char *p;
        -:15656:
    #####:15657:  if (slen == 0 && !by_word && !suffix_only)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:15658:    {
        -:15659:      /* The first occurrence of "" in any string is its end.  */
    #####:15660:      o = variable_buffer_output (o, t, strlen (t));
call    0 never executed
    #####:15661:      if (rlen > 0)
branch  0 never executed
branch  1 never executed
    #####:15662:	o = variable_buffer_output (o, replace, rlen);
call    0 never executed
    #####:15663:      return o;
        -:15664:    }
        -:15665:
        -:15666:  do
        -:15667:    {
    #####:15668:      if ((by_word | suffix_only) && slen == 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:15669:	/* When matching by words, the empty string should match
        -:15670:	   the end of each word, rather than the end of the whole text.  */
    #####:15671:	p = end_of_token (next_token (t));
call    0 never executed
call    1 never executed
        -:15672:      else
        -:15673:	{
    #####:15674:	  p = sindex (t, 0, subst, slen);
call    0 never executed
    #####:15675:	  if (p == 0)
branch  0 never executed
branch  1 never executed
        -:15676:	    {
        -:15677:	      /* No more matches.  Output everything left on the end.  */
    #####:15678:	      o = variable_buffer_output (o, t, strlen (t));
call    0 never executed
    #####:15679:	      return o;
        -:15680:	    }
        -:15681:	}
        -:15682:
        -:15683:      /* Output everything before this occurrence of the string to replace.  */
    #####:15684:      if (p > t)
branch  0 never executed
branch  1 never executed
    #####:15685:	o = variable_buffer_output (o, t, p - t);
call    0 never executed
        -:15686:
        -:15687:      /* If we're substituting only by fully matched words,
        -:15688:	 or only at the ends of words, check that this case qualifies.  */
    #####:15689:      if ((by_word
branch  0 never executed
branch  1 never executed
    #####:15690:	   && ((p > t && !isblank (p[-1]))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:15691:	       || (p[slen] != '\0' && !isblank (p[slen]))))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:15692:	  || (suffix_only
branch  0 never executed
branch  1 never executed
    #####:15693:	      && (p[slen] != '\0' && !isblank (p[slen]))))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:15694:	/* Struck out.  Output the rest of the string that is
        -:15695:	   no longer to be replaced.  */
    #####:15696:	o = variable_buffer_output (o, subst, slen);
call    0 never executed
    #####:15697:      else if (rlen > 0)
branch  0 never executed
branch  1 never executed
        -:15698:	/* Output the replacement string.  */
    #####:15699:	o = variable_buffer_output (o, replace, rlen);
call    0 never executed
        -:15700:
        -:15701:      /* Advance T past the string to be replaced.  */
    #####:15702:      t = p + slen;
    #####:15703:    } while (*t != '\0');
branch  0 never executed
branch  1 never executed
        -:15704:
    #####:15705:  return o;
        -:15706:}
        -:15707:
        -:15708:
        -:15709:/* Store into VARIABLE_BUFFER at O the result of scanning TEXT
        -:15710:   and replacing strings matching PATTERN with REPLACE.
        -:15711:   If PATTERN_PERCENT is not nil, PATTERN has already been
        -:15712:   run through find_percent, and PATTERN_PERCENT is the result.
        -:15713:   If REPLACE_PERCENT is not nil, REPLACE has already been
        -:15714:   run through find_percent, and REPLACE_PERCENT is the result.  */
        -:15715:
        -:15716:char *
function patsubst_expand called 0 returned 0% blocks executed 0%
    #####:15717:patsubst_expand (o, text, pattern, replace, pattern_percent, replace_percent)
        -:15718:     char *o;
        -:15719:     char *text;
        -:15720:     register char *pattern, *replace;
        -:15721:     register char *pattern_percent, *replace_percent;
        -:15722:{
        -:15723:  unsigned int pattern_prepercent_len, pattern_postpercent_len;
    #####:15724:  unsigned int replace_prepercent_len, replace_postpercent_len = 0;
        -:15725:  char *t;
        -:15726:  unsigned int len;
    #####:15727:  int doneany = 0;
        -:15728:
        -:15729:  /* We call find_percent on REPLACE before checking PATTERN so that REPLACE
        -:15730:     will be collapsed before we call subst_expand if PATTERN has no %.  */
    #####:15731:  if (replace_percent == 0)
branch  0 never executed
branch  1 never executed
    #####:15732:    replace_percent = find_percent (replace);
call    0 never executed
    #####:15733:  if (replace_percent != 0)
branch  0 never executed
branch  1 never executed
        -:15734:    {
        -:15735:      /* Record the length of REPLACE before and after the % so
        -:15736:	 we don't have to compute these lengths more than once.  */
    #####:15737:      replace_prepercent_len = replace_percent - replace;
    #####:15738:      replace_postpercent_len = strlen (replace_percent + 1);
        -:15739:    }
        -:15740:  else
        -:15741:    /* We store the length of the replacement
        -:15742:       so we only need to compute it once.  */
    #####:15743:    replace_prepercent_len = strlen (replace);
        -:15744:
    #####:15745:  if (pattern_percent == 0)
branch  0 never executed
branch  1 never executed
    #####:15746:    pattern_percent = find_percent (pattern);
call    0 never executed
    #####:15747:  if (pattern_percent == 0)
branch  0 never executed
branch  1 never executed
        -:15748:    /* With no % in the pattern, this is just a simple substitution.  */
    #####:15749:    return subst_expand (o, text, pattern, replace,
    #####:15750:			 strlen (pattern), strlen (replace), 1, 0);
call    0 never executed
        -:15751:
        -:15752:  /* Record the length of PATTERN before and after the %
        -:15753:     so we don't have to compute it more than once.  */
    #####:15754:  pattern_prepercent_len = pattern_percent - pattern;
    #####:15755:  pattern_postpercent_len = strlen (pattern_percent + 1);
        -:15756:
    #####:15757:  while ((t = find_next_token (&text, &len)) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:15758:    {
    #####:15759:      int fail = 0;
        -:15760:
        -:15761:      /* Is it big enough to match?  */
    #####:15762:      if (len < pattern_prepercent_len + pattern_postpercent_len)
branch  0 never executed
branch  1 never executed
    #####:15763:	fail = 1;
        -:15764:
        -:15765:      /* Does the prefix match? */
    #####:15766:      if (!fail && pattern_prepercent_len > 0
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:15767:	  && (*t != *pattern
branch  0 never executed
branch  1 never executed
    #####:15768:	      || t[pattern_prepercent_len - 1] != pattern_percent[-1]
branch  0 never executed
branch  1 never executed
    #####:15769:	      || strncmp (t + 1, pattern + 1, pattern_prepercent_len - 1)))
branch  0 never executed
branch  1 never executed
    #####:15770:	fail = 1;
        -:15771:
        -:15772:      /* Does the suffix match? */
    #####:15773:      if (!fail && pattern_postpercent_len > 0
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:15774:	  && (t[len - 1] != pattern_percent[pattern_postpercent_len]
branch  0 never executed
branch  1 never executed
    #####:15775:	      || t[len - pattern_postpercent_len] != pattern_percent[1]
branch  0 never executed
branch  1 never executed
    #####:15776:	      || strncmp (&t[len - pattern_postpercent_len],
    #####:15777:			  &pattern_percent[1], pattern_postpercent_len - 1)))
branch  0 never executed
branch  1 never executed
    #####:15778:	fail = 1;
        -:15779:
    #####:15780:      if (fail)
branch  0 never executed
branch  1 never executed
        -:15781:	/* It didn't match.  Output the string.  */
    #####:15782:	o = variable_buffer_output (o, t, len);
call    0 never executed
        -:15783:      else
        -:15784:	{
        -:15785:	  /* It matched.  Output the replacement.  */
        -:15786:
        -:15787:	  /* Output the part of the replacement before the %.  */
    #####:15788:	  o = variable_buffer_output (o, replace, replace_prepercent_len);
call    0 never executed
        -:15789:
    #####:15790:	  if (replace_percent != 0)
branch  0 never executed
branch  1 never executed
        -:15791:	    {
        -:15792:	      /* Output the part of the matched string that
        -:15793:		 matched the % in the pattern.  */
    #####:15794:	      o = variable_buffer_output (o, t + pattern_prepercent_len,
        -:15795:					  len - (pattern_prepercent_len
    #####:15796:						 + pattern_postpercent_len));
call    0 never executed
        -:15797:	      /* Output the part of the replacement after the %.  */
    #####:15798:	      o = variable_buffer_output (o, replace_percent + 1,
call    0 never executed
        -:15799:					  replace_postpercent_len);
        -:15800:	    }
        -:15801:	}
        -:15802:
        -:15803:      /* Output a space, but not if the replacement is "".  */
    #####:15804:      if (fail || replace_prepercent_len > 0
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:15805:	  || (replace_percent != 0 && len + replace_postpercent_len > 0))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:15806:	{
    #####:15807:	  o = variable_buffer_output (o, " ", 1);
call    0 never executed
    #####:15808:	  doneany = 1;
        -:15809:	}
        -:15810:    }
    #####:15811:  if (doneany)
branch  0 never executed
branch  1 never executed
        -:15812:    /* Kill the last space.  */
    #####:15813:    --o;
        -:15814:
    #####:15815:  return o;
        -:15816:}
        -:15817:
        -:15818:/* Handle variable-expansion-time functions such as $(dir foo/bar) ==> foo/  */
        -:15819:
        -:15820:/* These enumeration constants distinguish the
        -:15821:   various expansion-time built-in functions.  */
        -:15822:
        -:15823:enum function
        -:15824:  {
        -:15825:    function_subst,
        -:15826:    function_addsuffix,
        -:15827:    function_addprefix,
        -:15828:    function_dir,
        -:15829:    function_notdir,
        -:15830:    function_suffix,
        -:15831:    function_basename,
        -:15832:    function_wildcard,
        -:15833:    function_firstword,
        -:15834:    function_word,
        -:15835:    function_words,
        -:15836:    function_wordlist,
        -:15837:    function_findstring,
        -:15838:    function_strip,
        -:15839:    function_join,
        -:15840:    function_patsubst,
        -:15841:    function_filter,
        -:15842:    function_filter_out,
        -:15843:    function_foreach,
        -:15844:    function_sort,
        -:15845:    function_origin,
        -:15846:    function_shell,
        -:15847:    function_invalid
        -:15848:  };
        -:15849:
        -:15850:/* Greater than the length of any function name.  */
        -:15851:#define MAXFUNCTIONLEN 11
        -:15852:
        -:15853:/* The function names and lengths of names, for looking them up.  */
        -:15854:
        -:15855:static struct
        -:15856:  {
        -:15857:    char *name;
        -:15858:    unsigned int len;
        -:15859:    enum function function;
        -:15860:  } function_table[] =
        -:15861:  {
        -:15862:    { "subst", 5, function_subst },
        -:15863:    { "addsuffix", 9, function_addsuffix },
        -:15864:    { "addprefix", 9, function_addprefix },
        -:15865:    { "dir", 3, function_dir },
        -:15866:    { "notdir", 6, function_notdir },
        -:15867:    { "suffix", 6, function_suffix },
        -:15868:    { "basename", 8, function_basename },
        -:15869:    { "wildcard", 8, function_wildcard },
        -:15870:    { "firstword", 9, function_firstword },
        -:15871:    { "word", 4, function_word },
        -:15872:    { "words", 5, function_words },
        -:15873:    { "wordlist", 8, function_wordlist },
        -:15874:    { "findstring", 10, function_findstring },
        -:15875:    { "strip", 5, function_strip },
        -:15876:    { "join", 4, function_join },
        -:15877:    { "patsubst", 8, function_patsubst },
        -:15878:    { "filter", 6, function_filter },
        -:15879:    { "filter-out", 10, function_filter_out },
        -:15880:    { "foreach", 7, function_foreach },
        -:15881:    { "sort", 4, function_sort },
        -:15882:    { "origin", 6, function_origin },
        -:15883:    { "shell", 5, function_shell },
        -:15884:    { 0, 0, function_invalid }
        -:15885:  };
        -:15886:
        -:15887:/* Return 1 if PATTERN matches STR, 0 if not.  */
        -:15888:
        -:15889:int
function pattern_matches called 0 returned 0% blocks executed 0%
    #####:15890:pattern_matches (pattern, percent, str)
        -:15891:     register char *pattern, *percent, *str;
        -:15892:{
        -:15893:  unsigned int sfxlen, strlength;
        -:15894:
    #####:15895:  if (percent == 0)
branch  0 never executed
branch  1 never executed
        -:15896:    {
    #####:15897:      unsigned int len = strlen (pattern) + 1;
    #####:15898:      char *new = (char *) alloca (len);
    #####:15899:      bcopy (pattern, new, len);
    #####:15900:      pattern = new;
    #####:15901:      percent = find_percent (pattern);
call    0 never executed
    #####:15902:      if (percent == 0)
branch  0 never executed
branch  1 never executed
    #####:15903:	return streq (pattern, str);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -:15904:    }
        -:15905:
    #####:15906:  sfxlen = strlen (percent + 1);
    #####:15907:  strlength = strlen (str);
        -:15908:
    #####:15909:  if (strlength < (percent - pattern) + sfxlen
branch  0 never executed
branch  1 never executed
    #####:15910:      || strncmp (pattern, str, percent - pattern))
branch  0 never executed
branch  1 never executed
    #####:15911:    return 0;
        -:15912:
    #####:15913:  return !strcmp (percent + 1, str + (strlength - sfxlen));
        -:15914:}
        -:15915:
        -:15916:int shell_function_pid = 0, shell_function_completed;
        -:15917:
        -:15918:/* Perform the function specified by FUNCTION on the text at TEXT.
        -:15919:   END is points to the end of the argument text (exclusive).
        -:15920:   The output is written into VARIABLE_BUFFER starting at O.  */
        -:15921:
        -:15922:/* Note this absorbs a semicolon and is safe to use in conditionals.  */
        -:15923:#define BADARGS(func)  do {                                                   \
        -:15924:  if (reading_filename != 0)                                                  \
        -:15925:    makefile_fatal (reading_filename, *reading_lineno_ptr,                    \
        -:15926:		    "insufficient arguments to function `%s'",                \
        -:15927:		    func);                                                    \
        -:15928:  else                                                                        \
        -:15929:    fatal ("insufficient arguments to function `%s'", func); } while (0)
        -:15930:
        -:15931:static char *
function expand_function called 1580 returned 100% blocks executed 4%
     1580:15932:expand_function (o, function, text, end)
        -:15933:     char *o;
        -:15934:     enum function function;
        -:15935:     char *text;
        -:15936:     char *end;
        -:15937:{
        -:15938:  char *p, *p2, *p3;
        -:15939:  unsigned int i, j, len;
     1580:15940:  int doneany = 0;
        -:15941:  int count;
    1580*:15942:  char endparen = *end, startparen = *end == ')' ? '(' : '{';
branch  0 taken 1580 (fallthrough)
branch  1 taken 0
        -:15943:
     1580:15944:  switch (function)
branch  0 taken 0
branch  1 taken 0
branch  2 taken 0
branch  3 taken 0
branch  4 taken 0
branch  5 taken 0
branch  6 taken 0
branch  7 taken 0
branch  8 taken 1580
branch  9 taken 0
branch 10 taken 0
branch 11 taken 0
branch 12 taken 0
branch 13 taken 0
branch 14 taken 0
branch 15 taken 0
branch 16 taken 0
branch 17 taken 0
branch 18 taken 0
        -:15945:    {
    #####:15946:    default:
    #####:15947:      abort ();
call    0 never executed
        -:15948:      break;
        -:15949:
        -:15950:#ifndef VMS /* not supported for vms yet */
    #####:15951:    case function_shell:
        -:15952:      {
    #####:15953:	char* batch_filename = NULL;
        -:15954:#ifdef WINDOWS32
        -:15955:	SECURITY_ATTRIBUTES saAttr;
        -:15956:	HANDLE hIn;
        -:15957:	HANDLE hErr;
        -:15958:	HANDLE hChildOutRd;
        -:15959:	HANDLE hChildOutWr;
        -:15960:	HANDLE hProcess;
        -:15961:#endif
        -:15962:#ifdef __MSDOS__
        -:15963:	FILE *fpipe;
        -:15964:#endif
        -:15965:	char **argv;
        -:15966:	char *error_prefix;
        -:15967:#ifndef _AMIGA
        -:15968:	char **envp;
        -:15969:	int pipedes[2];
        -:15970:	int pid;
        -:15971:#endif
        -:15972:
        -:15973:	/* Expand the command line.  */
    #####:15974:	text = expand_argument (text, end);
call    0 never executed
        -:15975:
        -:15976:#ifndef __MSDOS__
        -:15977:	/* Construct the argument list.  */
    #####:15978:	argv = construct_command_argv (text,
call    0 never executed
        -:15979:				       (char **) NULL, (struct file *) 0, &batch_filename);
    #####:15980:	if (argv == 0)
branch  0 never executed
branch  1 never executed
    #####:15981:	  break;
        -:15982:#endif
        -:15983:
        -:15984:#ifndef _AMIGA
        -:15985:	/* Using a target environment for `shell' loses in cases like:
        -:15986:		export var = $(shell echo foobie)
        -:15987:	   because target_environment hits a loop trying to expand $(var)
        -:15988:	   to put it in the environment.  This is even more confusing when
        -:15989:	   var was not explicitly exported, but just appeared in the
        -:15990:	   calling environment.  */
        -:15991:#if 1
    #####:15992:	envp = environ;
        -:15993:#else
        -:15994:	/* Construct the environment.  */
        -:15995:	envp = target_environment ((struct file *) 0);
        -:15996:#endif
        -:15997:#endif  /* Not Amiga.  */
        -:15998:
        -:15999:	/* For error messages.  */
    #####:16000:	if (reading_filename != 0)
branch  0 never executed
branch  1 never executed
        -:16001:	  {
    #####:16002:	    error_prefix = (char *) alloca (strlen (reading_filename) + 100);
    #####:16003:	    sprintf (error_prefix,
        -:16004:		     "%s:%u: ", reading_filename, *reading_lineno_ptr);
        -:16005:	  }
        -:16006:	else
    #####:16007:	  error_prefix = "";
        -:16008:
        -:16009:#ifndef _AMIGA
        -:16010:# ifdef WINDOWS32
        -:16011:	saAttr.nLength = sizeof(SECURITY_ATTRIBUTES);
        -:16012:	saAttr.bInheritHandle = TRUE;
        -:16013:	saAttr.lpSecurityDescriptor = NULL;
        -:16014:
        -:16015:	if (DuplicateHandle(GetCurrentProcess(),
        -:16016:			    GetStdHandle(STD_INPUT_HANDLE),
        -:16017:			    GetCurrentProcess(),
        -:16018:			    &hIn,
        -:16019:			    0,
        -:16020:			    TRUE,
        -:16021:			    DUPLICATE_SAME_ACCESS) == FALSE) {
        -:16022:	  fatal("create_child_process: DuplicateHandle(In) failed (e=%d)\n",
        -:16023:		GetLastError());
        -:16024:	}
        -:16025:	if (DuplicateHandle(GetCurrentProcess(),
        -:16026:			    GetStdHandle(STD_ERROR_HANDLE),
        -:16027:			    GetCurrentProcess(),
        -:16028:			    &hErr,
        -:16029:			    0,
        -:16030:			    TRUE,
        -:16031:			    DUPLICATE_SAME_ACCESS) == FALSE) {
        -:16032:	  fatal("create_child_process: DuplicateHandle(Err) failed (e=%d)\n",
        -:16033:		GetLastError());
        -:16034:	}
        -:16035:
        -:16036:	if (!CreatePipe(&hChildOutRd, &hChildOutWr, &saAttr, 0))
        -:16037:	  fatal("CreatePipe() failed (e=%d)\n", GetLastError());
        -:16038:
        -:16039:	hProcess = process_init_fd(hIn, hChildOutWr, hErr);
        -:16040:
        -:16041:	if (!hProcess)
        -:16042:	  fatal("expand_function: process_init_fd() failed\n");
        -:16043:	else
        -:16044:	  process_register(hProcess);
        -:16045:
        -:16046:	/* make sure that CreateProcess() has Path it needs */
        -:16047:	sync_Path_environment();
        -:16048:
        -:16049:	if (!process_begin(hProcess, argv, envp, argv[0], NULL))
        -:16050:		pid = (int) hProcess;
        -:16051:	else
        -:16052:		fatal("expand_function: unable to launch process (e=%d)\n",
        -:16053:		      process_last_err(hProcess));
        -:16054:
        -:16055:	/* set up to read data from child */
        -:16056:	pipedes[0] = _open_osfhandle((long) hChildOutRd, O_RDONLY);
        -:16057:
        -:16058:	/* this will be closed almost right away */
        -:16059:	pipedes[1] = _open_osfhandle((long) hChildOutWr, O_APPEND);
        -:16060:# else /* WINDOWS32 */
        -:16061:#  ifdef __MSDOS__
        -:16062:	{
        -:16063:	  /* MSDOS can't fork, but it has `popen'.
        -:16064:	     (Bwt, why isn't `popen' used in all the versions?) */
        -:16065:	  struct variable *sh = lookup_variable ("SHELL", 5);
        -:16066:	  int e;
        -:16067:	  extern int dos_command_running, dos_status;
        -:16068:
        -:16069:	  /* Make sure not to bother processing an empty line.  */
        -:16070:	  while (isblank (*text))
        -:16071:	    ++text;
        -:16072:	  if (*text == '\0')
        -:16073:	    break;
        -:16074:
        -:16075:	  if (sh)
        -:16076:	    {
        -:16077:	      char buf[PATH_MAX + 7];
        -:16078:	      /* This makes sure $SHELL value is used by $(shell), even
        -:16079:		 though the target environment is not passed to it.  */
        -:16080:	      sprintf (buf, "SHELL=%s", sh->value);
        -:16081:	      putenv (buf);
        -:16082:	    }
        -:16083:
        -:16084:	  e = errno;
        -:16085:	  errno = 0;
        -:16086:	  dos_command_running = 1;
        -:16087:	  dos_status = 0;
        -:16088:	  fpipe = popen (text, "rt");
        -:16089:	  dos_command_running = 0;
        -:16090:	  if (!fpipe || dos_status)
        -:16091:	    {
        -:16092:	      pipedes[0] = -1;
        -:16093:	      pid = -1;
        -:16094:	      if (dos_status)
        -:16095:		errno = EINTR;
        -:16096:	      else if (errno == 0)
        -:16097:		errno = ENOMEM;
        -:16098:	      shell_function_completed = -1;
        -:16099:	    }
        -:16100:	  else
        -:16101:	    {
        -:16102:	      pipedes[0] = fileno (fpipe);
        -:16103:	      pid = 42;
        -:16104:	      errno = e;
        -:16105:	      shell_function_completed = 1;
        -:16106:	    }
        -:16107:	}
        -:16108:	if (pipedes[0] < 0)
        -:16109:#  else /* ! __MSDOS__ */
    #####:16110:	if (pipe (pipedes) < 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:16111:#  endif /* __MSDOS__ */
        -:16112:	  {
    #####:16113:	    perror_with_name (error_prefix, "pipe");
call    0 never executed
    #####:16114:	    break;
        -:16115:	  }
        -:16116:
        -:16117:#  ifndef  __MSDOS__
    #####:16118:	pid = vfork ();
call    0 never executed
    #####:16119:	if (pid < 0)
branch  0 never executed
branch  1 never executed
    #####:16120:	  perror_with_name (error_prefix, "fork");
call    0 never executed
    #####:16121:	else if (pid == 0)
branch  0 never executed
branch  1 never executed
    #####:16122:	  child_execute_job (0, pipedes[1], argv, envp);
call    0 never executed
        -:16123:	else
        -:16124:#  endif /* ! __MSDOS__ */
        -:16125:# endif /* WINDOWS32 */
        -:16126:	  {
        -:16127:	    /* We are the parent.  */
        -:16128:
        -:16129:	    char *buffer;
        -:16130:	    unsigned int maxlen;
        -:16131:	    int cc;
        -:16132:#if 0
        -:16133:	    for (i = 0; envp[i] != 0; ++i)
        -:16134:	      free (envp[i]);
        -:16135:	    free ((char *) envp);
        -:16136:#endif
        -:16137:
        -:16138:	    /* Record the PID for reap_children.  */
    #####:16139:	    shell_function_pid = pid;
        -:16140:#ifndef  __MSDOS__
    #####:16141:	    shell_function_completed = 0;
        -:16142:
        -:16143:	    /* Free the storage only the child needed.  */
    #####:16144:	    free (argv[0]);
    #####:16145:	    free ((char *) argv);
        -:16146:
        -:16147:	    /* Close the write side of the pipe.  */
    #####:16148:	    (void) close (pipedes[1]);
call    0 never executed
        -:16149:#endif
        -:16150:
        -:16151:	    /* Set up and read from the pipe.  */
        -:16152:
    #####:16153:	    maxlen = 200;
    #####:16154:	    buffer = (char *) xmalloc (maxlen + 1);
call    0 never executed
        -:16155:
        -:16156:	    /* Read from the pipe until it gets EOF.  */
    #####:16157:	    i = 0;
        -:16158:	    do
        -:16159:	      {
    #####:16160:		if (i == maxlen)
branch  0 never executed
branch  1 never executed
        -:16161:		  {
    #####:16162:		    maxlen += 512;
    #####:16163:		    buffer = (char *) xrealloc (buffer, maxlen + 1);
call    0 never executed
        -:16164:		  }
        -:16165:
    #####:16166:		errno = 0;
    #####:16167:		cc = read (pipedes[0], &buffer[i], maxlen - i);
call    0 never executed
    #####:16168:		if (cc > 0)
branch  0 never executed
branch  1 never executed
    #####:16169:		  i += cc;
        -:16170:	      }
        -:16171:#ifdef EINTR
    #####:16172:	    while (cc > 0 || errno == EINTR);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:16173:#else
        -:16174:	    while (cc > 0);
        -:16175:#endif
        -:16176:
        -:16177:	    /* Close the read side of the pipe.  */
        -:16178:#ifdef  __MSDOS__
        -:16179:	    if (fpipe)
        -:16180:	      (void) pclose (fpipe);
        -:16181:#else
    #####:16182:	    (void) close (pipedes[0]);
call    0 never executed
        -:16183:#endif
        -:16184:
        -:16185:	    /* Loop until child_handler sets shell_function_completed
        -:16186:	       to the status of our child shell.  */
    #####:16187:	    while (shell_function_completed == 0)
branch  0 never executed
branch  1 never executed
    #####:16188:	      reap_children (1, 0);
call    0 never executed
        -:16189:
    #####:16190:            if (batch_filename) {
branch  0 never executed
branch  1 never executed
    #####:16191:              if (debug_flag)
branch  0 never executed
branch  1 never executed
    #####:16192:                printf("Cleaning up temporary batch file %s\n", batch_filename);
call    0 never executed
    #####:16193:              remove(batch_filename);
call    0 never executed
    #####:16194:              free(batch_filename);
        -:16195:            }
    #####:16196:	    shell_function_pid = 0;
        -:16197:
        -:16198:	    /* The child_handler function will set shell_function_completed
        -:16199:	       to 1 when the child dies normally, or to -1 if it
        -:16200:	       dies with status 127, which is most likely an exec fail.  */
        -:16201:
    #####:16202:	    if (shell_function_completed == -1)
branch  0 never executed
branch  1 never executed
        -:16203:	      {
        -:16204:		/* This most likely means that the execvp failed,
        -:16205:		   so we should just write out the error message
        -:16206:		   that came in over the pipe from the child.  */
    #####:16207:		fputs (buffer, stderr);
call    0 never executed
    #####:16208:		fflush (stderr);
call    0 never executed
        -:16209:	      }
        -:16210:	    else
        -:16211:	      {
        -:16212:		/* The child finished normally.  Replace all
        -:16213:		   newlines in its output with spaces, and put
        -:16214:		   that in the variable output buffer.  */
    #####:16215:		if (i > 0)
branch  0 never executed
branch  1 never executed
        -:16216:		  {
    #####:16217:		    if (buffer[i - 1] == '\n')
branch  0 never executed
branch  1 never executed
        -:16218:		      {
    #####:16219:			if (i > 1 && buffer[i - 2] == '\r')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:16220:			  --i;
    #####:16221:			buffer[--i] = '\0';
        -:16222:		      }
        -:16223:		    else
    #####:16224:		      buffer[i] = '\0';
        -:16225:
    #####:16226:		    p = buffer;
    #####:16227:		    for (p2=p; *p != '\0'; ++p)
branch  0 never executed
branch  1 never executed
        -:16228:		      {
    #####:16229:			if (p[0] == '\r' && p[1] == '\n')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:16230:			  continue;
    #####:16231:			if (*p == '\n')
branch  0 never executed
branch  1 never executed
    #####:16232:			  *p2++ = ' ';
        -:16233:			else
    #####:16234:			  *p2++ = *p;
        -:16235:		      }
    #####:16236:		    *p2 = '\0';
    #####:16237:		    o = variable_buffer_output (o, buffer, i);
call    0 never executed
        -:16238:		  }
        -:16239:	      }
        -:16240:
    #####:16241:	    free (buffer);
        -:16242:	  }
        -:16243:#else   /* Amiga */
        -:16244:	 {
        -:16245:	   /* Amiga can't fork nor spawn, but I can start a program with
        -:16246:	      redirection of my choice.  However, this means that we
        -:16247:	      don't have an opportunity to reopen stdout to trap it.  Thus,
        -:16248:	      we save our own stdout onto a new descriptor and dup a temp
        -:16249:	      file's descriptor onto our stdout temporarily.  After we
        -:16250:	      spawn the shell program, we dup our own stdout back to the
        -:16251:	      stdout descriptor.  The buffer reading is the same as above,
        -:16252:	      except that we're now reading from a file.  */
        -:16253:#include <dos/dos.h>
        -:16254:#include <proto/dos.h>
        -:16255:#undef stderr
        -:16256:#define stderr stdout
        -:16257:
        -:16258:	   BPTR child_stdout;
        -:16259:	   char tmp_output[FILENAME_MAX];
        -:16260:	   unsigned int maxlen = 200;
        -:16261:	   int cc;
        -:16262:	   char * buffer, * ptr;
        -:16263:	   char ** aptr;
        -:16264:	   int len = 0;
        -:16265:
        -:16266:	   strcpy (tmp_output, "t:MakeshXXXXXXXX");
        -:16267:	   mktemp (tmp_output);
        -:16268:	   child_stdout = Open (tmp_output, MODE_NEWFILE);
        -:16269:
        -:16270:	   for (aptr=argv; *aptr; aptr++)
        -:16271:	     {
        -:16272:	       len += strlen (*aptr) + 1;
        -:16273:	     }
        -:16274:
        -:16275:	   buffer = xmalloc (len + 1);
        -:16276:	   ptr = buffer;
        -:16277:
        -:16278:	   for (aptr=argv; *aptr; aptr++)
        -:16279:	     {
        -:16280:	       strcpy (ptr, *aptr);
        -:16281:	       ptr += strlen (ptr) + 1;
        -:16282:	       *ptr ++ = ' ';
        -:16283:	       *ptr = 0;
        -:16284:	     }
        -:16285:
        -:16286:	   ptr[-1] = '\n';
        -:16287:
        -:16288:	   Execute (buffer, NULL, child_stdout);
        -:16289:	   free (buffer);
        -:16290:
        -:16291:	   Close (child_stdout);
        -:16292:
        -:16293:	   child_stdout = Open (tmp_output, MODE_OLDFILE);
        -:16294:
        -:16295:	   buffer = xmalloc (maxlen);
        -:16296:	   i = 0;
        -:16297:	   do
        -:16298:	     {
        -:16299:	       if (i == maxlen)
        -:16300:		 {
        -:16301:		   maxlen += 512;
        -:16302:		   buffer = (char *) xrealloc (buffer, maxlen + 1);
        -:16303:		 }
        -:16304:
        -:16305:	       cc = Read (child_stdout, &buffer[i], maxlen - i);
        -:16306:	       if (cc > 0)
        -:16307:		 i += cc;
        -:16308:	     } while (cc > 0);
        -:16309:
        -:16310:	   Close (child_stdout);
        -:16311:	   DeleteFile (tmp_output);
        -:16312:
        -:16313:	   if (i > 0)
        -:16314:	     {
        -:16315:	       if (buffer[i - 1] == '\n')
        -:16316:		 buffer[--i] = '\0';
        -:16317:	       else
        -:16318:		 buffer[i] = '\0';
        -:16319:	       p = buffer;
        -:16320:	       while ((p = index (p, '\n')) != 0)
        -:16321:		 *p++ = ' ';
        -:16322:	       o = variable_buffer_output (o, buffer, i);
        -:16323:	     }
        -:16324:	   free (buffer);
        -:16325:	 }
        -:16326:#endif  /* Not Amiga.  */
        -:16327:
    #####:16328:	free (text);
    #####:16329:	break;
        -:16330:      }
        -:16331:#endif /* !VMS */
        -:16332:
    #####:16333:    case function_origin:
        -:16334:      /* Expand the argument.  */
    #####:16335:      text = expand_argument (text, end);
call    0 never executed
        -:16336:
        -:16337:      {
    #####:16338:	register struct variable *v = lookup_variable (text, strlen (text));
call    0 never executed
    #####:16339:	if (v == 0)
branch  0 never executed
branch  1 never executed
    #####:16340:	  o = variable_buffer_output (o, "undefined", 9);
call    0 never executed
        -:16341:	else
    #####:16342:	  switch (v->origin)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -:16343:	    {
    #####:16344:	    default:
        -:16345:	    case o_invalid:
    #####:16346:	      abort ();
call    0 never executed
        -:16347:	      break;
    #####:16348:	    case o_default:
    #####:16349:	      o = variable_buffer_output (o, "default", 7);
call    0 never executed
    #####:16350:	      break;
    #####:16351:	    case o_env:
    #####:16352:	      o = variable_buffer_output (o, "environment", 11);
call    0 never executed
    #####:16353:	      break;
    #####:16354:	    case o_file:
    #####:16355:	      o = variable_buffer_output (o, "file", 4);
call    0 never executed
    #####:16356:	      break;
    #####:16357:	    case o_env_override:
    #####:16358:	      o = variable_buffer_output (o, "environment override", 20);
call    0 never executed
    #####:16359:	      break;
    #####:16360:	    case o_command:
    #####:16361:	      o = variable_buffer_output (o, "command line", 12);
call    0 never executed
    #####:16362:	      break;
    #####:16363:	    case o_override:
    #####:16364:	      o = variable_buffer_output (o, "override", 8);
call    0 never executed
    #####:16365:	      break;
    #####:16366:	    case o_automatic:
    #####:16367:	      o = variable_buffer_output (o, "automatic", 9);
call    0 never executed
    #####:16368:	      break;
        -:16369:	    }
        -:16370:      }
        -:16371:
    #####:16372:      free (text);
    #####:16373:      break;
        -:16374:
    #####:16375:    case function_sort:
        -:16376:      /* Expand the argument.  */
    #####:16377:      text = expand_argument (text, end);
call    0 never executed
        -:16378:
        -:16379:      {
    #####:16380:	char **words = (char **) xmalloc (10 * sizeof (char *));
call    0 never executed
    #####:16381:	unsigned int nwords = 10;
    #####:16382:	register unsigned int wordi = 0;
        -:16383:	char *t;
        -:16384:
        -:16385:	/* Chop TEXT into words and put them in WORDS.  */
    #####:16386:	t = text;
    #####:16387:	while ((p = find_next_token (&t, &len)) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:16388:	  {
    #####:16389:	    if (wordi >= nwords - 1)
branch  0 never executed
branch  1 never executed
        -:16390:	      {
    #####:16391:		nwords *= 2;
    #####:16392:		words = (char **) xrealloc ((char *) words,
call    0 never executed
        -:16393:					    nwords * sizeof (char *));
        -:16394:	      }
    #####:16395:	    words[wordi++] = savestring (p, len);
call    0 never executed
        -:16396:	  }
        -:16397:
    #####:16398:	if (wordi > 0)
branch  0 never executed
branch  1 never executed
        -:16399:	  {
        -:16400:	    /* Now sort the list of words.  */
    #####:16401:	    qsort ((char *) words, wordi, sizeof (char *), alpha_compare);
call    0 never executed
        -:16402:
        -:16403:	    /* Now write the sorted list.  */
    #####:16404:	    for (i = 0; i < wordi; ++i)
branch  0 never executed
branch  1 never executed
        -:16405:	      {
    #####:16406:		len = strlen (words[i]);
    #####:16407:		if (i == wordi - 1 || strlen (words[i + 1]) != len
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:16408:		    || strcmp (words[i], words[i + 1]))
branch  0 never executed
branch  1 never executed
        -:16409:		  {
    #####:16410:		    o = variable_buffer_output (o, words[i], len);
call    0 never executed
    #####:16411:		    o = variable_buffer_output (o, " ", 1);
call    0 never executed
        -:16412:		  }
    #####:16413:		free (words[i]);
        -:16414:	      }
        -:16415:	    /* Kill the last space.  */
    #####:16416:	    --o;
        -:16417:	  }
        -:16418:
    #####:16419:	free ((char *) words);
        -:16420:      }
        -:16421:
    #####:16422:      free (text);
    #####:16423:      break;
        -:16424:
    #####:16425:    case function_foreach:
        -:16426:      {
        -:16427:	/* Get three comma-separated arguments but
        -:16428:	   expand only the first two.  */
        -:16429:	char *var, *list;
        -:16430:	register struct variable *v;
        -:16431:
    #####:16432:	count = 0;
    #####:16433:	for (p = text; p < end; ++p)
branch  0 never executed
branch  1 never executed
        -:16434:	  {
    #####:16435:	    if (*p == startparen)
branch  0 never executed
branch  1 never executed
    #####:16436:	      ++count;
    #####:16437:	    else if (*p == endparen)
branch  0 never executed
branch  1 never executed
    #####:16438:	      --count;
    #####:16439:	    else if (*p == ',' && count <= 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:16440:	      break;
        -:16441:	  }
    #####:16442:	if (p == end)
branch  0 never executed
branch  1 never executed
    #####:16443:	  BADARGS ("foreach");
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####:16444:	var = expand_argument (text, p);
call    0 never executed
        -:16445:
    #####:16446:	p2 = p + 1;
    #####:16447:	count = 0;
    #####:16448:	for (p = p2; p < end; ++p)
branch  0 never executed
branch  1 never executed
        -:16449:	  {
    #####:16450:	    if (*p == startparen)
branch  0 never executed
branch  1 never executed
    #####:16451:	      ++count;
    #####:16452:	    else if (*p == endparen)
branch  0 never executed
branch  1 never executed
    #####:16453:	      --count;
    #####:16454:	    else if (*p == ',' && count <= 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:16455:	      break;
        -:16456:	  }
    #####:16457:	if (p == end)
branch  0 never executed
branch  1 never executed
    #####:16458:	  BADARGS ("foreach");
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####:16459:	list = expand_argument (p2, p);
call    0 never executed
        -:16460:
    #####:16461:	++p;
    #####:16462:	text = savestring (p, end - p);
call    0 never executed
        -:16463:
    #####:16464:	push_new_variable_scope ();
call    0 never executed
    #####:16465:	v = define_variable (var, strlen (var), "", o_automatic, 0);
call    0 never executed
    #####:16466:        free (v->value);
    #####:16467:        v->value = 0;
    #####:16468:	p3 = list;
    #####:16469:	while ((p = find_next_token (&p3, &len)) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:16470:	  {
        -:16471:	    char *result;
    #####:16472:	    char save = p[len];
    #####:16473:	    p[len] = '\0';
    #####:16474:	    v->value = p;
    #####:16475:	    result = allocated_variable_expand (text);
call    0 never executed
    #####:16476:	    p[len] = save;
        -:16477:
    #####:16478:	    o = variable_buffer_output (o, result, strlen (result));
call    0 never executed
    #####:16479:	    o = variable_buffer_output (o, " ", 1);
call    0 never executed
    #####:16480:	    doneany = 1;
    #####:16481:	    free (result);
        -:16482:	  }
    #####:16483:	if (doneany)
branch  0 never executed
branch  1 never executed
        -:16484:	  /* Kill the last space.  */
    #####:16485:	  --o;
        -:16486:
    #####:16487:	pop_variable_scope ();
call    0 never executed
        -:16488:
    #####:16489:	free (var);
    #####:16490:	free (list);
    #####:16491:	free (text);
        -:16492:      }
    #####:16493:      break;
        -:16494:
    #####:16495:    case function_filter:
        -:16496:    case function_filter_out:
        -:16497:      {
        -:16498:	struct a_word
        -:16499:	  {
        -:16500:	    struct a_word *next;
        -:16501:	    char *str;
        -:16502:	    int matched;
        -:16503:	  } *words, *wordtail, *wp;
        -:16504:
        -:16505:	/* Get two comma-separated arguments and expand each one.  */
    #####:16506:	count = 0;
    #####:16507:	for (p = text; p < end; ++p)
branch  0 never executed
branch  1 never executed
        -:16508:	  {
    #####:16509:	    if (*p == startparen)
branch  0 never executed
branch  1 never executed
    #####:16510:	      ++count;
    #####:16511:	    else if (*p == endparen)
branch  0 never executed
branch  1 never executed
    #####:16512:	      --count;
    #####:16513:	    else if (*p == ',' && count <= 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:16514:	      break;
        -:16515:	  }
    #####:16516:	if (p == end)
branch  0 never executed
branch  1 never executed
    #####:16517:	  BADARGS (function == function_filter ? "filter" : "filter-out");
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
    #####:16518:	p2 = expand_argument (text, p);
call    0 never executed
        -:16519:
    #####:16520:	text = expand_argument (p + 1, end);
call    0 never executed
        -:16521:
        -:16522:	/* Chop TEXT up into words and then run each pattern through.  */
    #####:16523:	words = wordtail = 0;
    #####:16524:	p3 = text;
    #####:16525:	while ((p = find_next_token (&p3, &len)) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:16526:	  {
    #####:16527:	    struct a_word *w = (struct a_word *)alloca(sizeof(struct a_word));
    #####:16528:	    if (words == 0)
branch  0 never executed
branch  1 never executed
    #####:16529:	      words = w;
        -:16530:	    else
    #####:16531:	      wordtail->next = w;
    #####:16532:	    wordtail = w;
        -:16533:
    #####:16534:	    if (*p3 != '\0')
branch  0 never executed
branch  1 never executed
    #####:16535:	      ++p3;
    #####:16536:	    p[len] = '\0';
    #####:16537:	    w->str = p;
    #####:16538:	    w->matched = 0;
        -:16539:	  }
        -:16540:
    #####:16541:	if (words != 0)
branch  0 never executed
branch  1 never executed
        -:16542:	  {
    #####:16543:	    wordtail->next = 0;
        -:16544:
        -:16545:	    /* Run each pattern through the words, killing words.  */
    #####:16546:	    p3 = p2;
    #####:16547:	    while ((p = find_next_token (&p3, &len)) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:16548:	      {
        -:16549:		char *percent;
    #####:16550:		char save = p[len];
    #####:16551:		p[len] = '\0';
        -:16552:
    #####:16553:		percent = find_percent (p);
call    0 never executed
    #####:16554:		for (wp = words; wp != 0; wp = wp->next)
branch  0 never executed
branch  1 never executed
    #####:16555:		  wp->matched |= (percent == 0 ? streq (p, wp->str)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:16556:				  : pattern_matches (p, percent, wp->str));
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:16557:
    #####:16558:		p[len] = save;
        -:16559:	      }
        -:16560:
        -:16561:	    /* Output the words that matched (or didn't, for filter-out).  */
    #####:16562:	    for (wp = words; wp != 0; wp = wp->next)
branch  0 never executed
branch  1 never executed
    #####:16563:	      if (function == function_filter ? wp->matched : !wp->matched)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:16564:		{
    #####:16565:		  o = variable_buffer_output (o, wp->str, strlen (wp->str));
call    0 never executed
    #####:16566:		  o = variable_buffer_output (o, " ", 1);
call    0 never executed
    #####:16567:		  doneany = 1;
        -:16568:		}
    #####:16569:	    if (doneany)
branch  0 never executed
branch  1 never executed
        -:16570:	      /* Kill the last space.  */
    #####:16571:	      --o;
        -:16572:	  }
        -:16573:
    #####:16574:	free (p2);
    #####:16575:	free (text);
        -:16576:      }
    #####:16577:      break;
        -:16578:
    #####:16579:    case function_patsubst:
        -:16580:      /* Get three comma-separated arguments and expand each one.  */
    #####:16581:      count = 0;
    #####:16582:      for (p = text; p < end; ++p)
branch  0 never executed
branch  1 never executed
        -:16583:	{
    #####:16584:	  if (*p == startparen)
branch  0 never executed
branch  1 never executed
    #####:16585:	    ++count;
    #####:16586:	  else if (*p == endparen)
branch  0 never executed
branch  1 never executed
    #####:16587:	    --count;
    #####:16588:	  else if (*p == ',' && count <= 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:16589:	    break;
        -:16590:	}
    #####:16591:      if (p == end)
branch  0 never executed
branch  1 never executed
    #####:16592:	BADARGS ("patsubst");
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
        -:16593:
    #####:16594:      p2 = p;
    #####:16595:      count = 0;
    #####:16596:      for (++p; p < end; ++p)
branch  0 never executed
branch  1 never executed
        -:16597:	{
    #####:16598:	  if (*p == startparen)
branch  0 never executed
branch  1 never executed
    #####:16599:	    ++count;
    #####:16600:	  else if (*p == endparen)
branch  0 never executed
branch  1 never executed
    #####:16601:	    --count;
    #####:16602:	  else if (*p == ',' && count <= 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:16603:	    break;
        -:16604:	}
    #####:16605:      if (p == end)
branch  0 never executed
branch  1 never executed
    #####:16606:	BADARGS ("patsubst");
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
        -:16607:
    #####:16608:      text = expand_argument (text, p2);
call    0 never executed
    #####:16609:      p3 = expand_argument (p2 + 1, p);
call    0 never executed
    #####:16610:      p2 = expand_argument (p + 1, end);
call    0 never executed
        -:16611:
    #####:16612:      o = patsubst_expand (o, p2, text, p3, (char *) 0, (char *) 0);
call    0 never executed
        -:16613:
    #####:16614:      free (text);
    #####:16615:      free (p3);
    #####:16616:      free (p2);
    #####:16617:      break;
        -:16618:
    #####:16619:    case function_join:
        -:16620:      /* Get two comma-separated arguments and expand each one.  */
    #####:16621:      count = 0;
    #####:16622:      for (p = text; p < end; ++p)
branch  0 never executed
branch  1 never executed
        -:16623:	{
    #####:16624:	  if (*p == startparen)
branch  0 never executed
branch  1 never executed
    #####:16625:	    ++count;
    #####:16626:	  else if (*p == endparen)
branch  0 never executed
branch  1 never executed
    #####:16627:	    --count;
    #####:16628:	  else if (*p == ',' && count <= 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:16629:	    break;
        -:16630:	}
    #####:16631:      if (p == end)
branch  0 never executed
branch  1 never executed
    #####:16632:	BADARGS ("join");
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####:16633:      text = expand_argument (text, p);
call    0 never executed
        -:16634:
    #####:16635:      p = expand_argument (p + 1, end);
call    0 never executed
        -:16636:
        -:16637:      {
        -:16638:	/* Write each word of the first argument directly followed
        -:16639:	   by the corresponding word of the second argument.
        -:16640:	   If the two arguments have a different number of words,
        -:16641:	   the excess words are just output separated by blanks.  */
        -:16642:	register char *tp, *pp;
    #####:16643:	p2 = text;
    #####:16644:	p3 = p;
        -:16645:	do
        -:16646:	  {
        -:16647:	    unsigned int tlen, plen;
        -:16648:
    #####:16649:	    tp = find_next_token (&p2, &tlen);
call    0 never executed
    #####:16650:	    if (tp != 0)
branch  0 never executed
branch  1 never executed
    #####:16651:	      o = variable_buffer_output (o, tp, tlen);
call    0 never executed
        -:16652:
    #####:16653:	    pp = find_next_token (&p3, &plen);
call    0 never executed
    #####:16654:	    if (pp != 0)
branch  0 never executed
branch  1 never executed
    #####:16655:	      o = variable_buffer_output (o, pp, plen);
call    0 never executed
        -:16656:
    #####:16657:	    if (tp != 0 || pp != 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:16658:	      {
    #####:16659:		o = variable_buffer_output (o, " ", 1);
call    0 never executed
    #####:16660:		doneany = 1;
        -:16661:	      }
        -:16662:	  }
    #####:16663:	while (tp != 0 || pp != 0);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:16664:	if (doneany)
branch  0 never executed
branch  1 never executed
        -:16665:	  /* Kill the last blank.  */
    #####:16666:	  --o;
        -:16667:      }
        -:16668:
    #####:16669:      free (text);
    #####:16670:      free (p);
    #####:16671:      break;
        -:16672:
     1580:16673:    case function_strip:
        -:16674:      /* Expand the argument.  */
     1580:16675:      text = expand_argument (text, end);
call    0 returned 1580
        -:16676:
     1580:16677:      p2 = text;
     1598:16678:      while (*p2 != '\0')
branch  0 taken 18
branch  1 taken 1580 (fallthrough)
        -:16679:	{
       18:16680:	  while (isspace(*p2))
branch  0 taken 0
branch  1 taken 18 (fallthrough)
    #####:16681:	    ++p2;
       18:16682:	  p = p2;
       36:16683:	  for (i=0; *p2 != '\0' && !isspace(*p2); ++p2, ++i)
branch  0 taken 18 (fallthrough)
branch  1 taken 18
branch  2 taken 18
branch  3 taken 0 (fallthrough)
        -:16684:	    {}
       18:16685:	  if (!i)
branch  0 taken 0 (fallthrough)
branch  1 taken 18
    #####:16686:	    break;
       18:16687:	  o = variable_buffer_output (o, p, i);
call    0 returned 18
       18:16688:	  o = variable_buffer_output (o, " ", 1);
call    0 returned 18
       18:16689:	  doneany = 1;
        -:16690:	}
     1580:16691:      if (doneany)
branch  0 taken 18 (fallthrough)
branch  1 taken 1562
        -:16692:	/* Kill the last space.  */
       18:16693:	--o;
        -:16694:
     1580:16695:      free (text);
     1580:16696:      break;
        -:16697:
    #####:16698:    case function_wildcard:
    #####:16699:      text = expand_argument (text, end);
call    0 never executed
        -:16700:
        -:16701:#ifdef _AMIGA
        -:16702:      o = wildcard_expansion (text, o);
        -:16703:#else
    #####:16704:      p = string_glob (text);
call    0 never executed
    #####:16705:      o = variable_buffer_output (o, p, strlen (p));
call    0 never executed
        -:16706:#endif
        -:16707:
    #####:16708:      free (text);
    #####:16709:      break;
        -:16710:
    #####:16711:    case function_subst:
        -:16712:      /* Get three comma-separated arguments and expand each one.  */
    #####:16713:      count = 0;
    #####:16714:      for (p = text; p < end; ++p)
branch  0 never executed
branch  1 never executed
        -:16715:	{
    #####:16716:	  if (*p == startparen)
branch  0 never executed
branch  1 never executed
    #####:16717:	    ++count;
    #####:16718:	  else if (*p == endparen)
branch  0 never executed
branch  1 never executed
    #####:16719:	    --count;
    #####:16720:	  else if (*p == ',' && count <= 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:16721:	    break;
        -:16722:	}
    #####:16723:      if (p == end)
branch  0 never executed
branch  1 never executed
    #####:16724:	BADARGS ("subst");
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
        -:16725:
    #####:16726:      p2 = p;
    #####:16727:      count = 0;
    #####:16728:      for (++p; p < end; ++p)
branch  0 never executed
branch  1 never executed
        -:16729:	{
    #####:16730:	  if (*p == startparen)
branch  0 never executed
branch  1 never executed
    #####:16731:	    ++count;
    #####:16732:	  else if (*p == endparen)
branch  0 never executed
branch  1 never executed
    #####:16733:	    --count;
    #####:16734:	  else if (*p == ',' && count <= 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:16735:	    break;
        -:16736:	}
    #####:16737:      if (p == end)
branch  0 never executed
branch  1 never executed
    #####:16738:	BADARGS ("subst");
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
        -:16739:
    #####:16740:      text = expand_argument (text, p2);
call    0 never executed
    #####:16741:      p3 = expand_argument (p2 + 1, p);
call    0 never executed
    #####:16742:      p2 = expand_argument (p + 1, end);
call    0 never executed
        -:16743:
    #####:16744:      o = subst_expand (o, p2, text, p3, strlen (text), strlen (p3), 0, 0);
call    0 never executed
        -:16745:
    #####:16746:      free (text);
    #####:16747:      free (p3);
    #####:16748:      free (p2);
    #####:16749:      break;
        -:16750:
    #####:16751:    case function_firstword:
        -:16752:      /* Expand the argument.  */
    #####:16753:      text = expand_argument (text, end);
call    0 never executed
        -:16754:
        -:16755:      /* Find the first word in TEXT.  */
    #####:16756:      p2 = text;
    #####:16757:      p = find_next_token (&p2, &i);
call    0 never executed
    #####:16758:      if (p != 0)
branch  0 never executed
branch  1 never executed
    #####:16759:	o = variable_buffer_output (o, p, i);
call    0 never executed
        -:16760:
    #####:16761:      free (text);
    #####:16762:      break;
        -:16763:
    #####:16764:    case function_word:
        -:16765:      /* Get two comma-separated arguments and expand each one.  */
    #####:16766:      count = 0;
    #####:16767:      for (p = text; p < end; ++p)
branch  0 never executed
branch  1 never executed
        -:16768:	{
    #####:16769:	  if (*p == startparen)
branch  0 never executed
branch  1 never executed
    #####:16770:	    ++count;
    #####:16771:	  else if (*p == endparen)
branch  0 never executed
branch  1 never executed
    #####:16772:	    --count;
    #####:16773:	  else if (*p == ',' && count <= 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:16774:	    break;
        -:16775:	}
    #####:16776:      if (p == end)
branch  0 never executed
branch  1 never executed
    #####:16777:	BADARGS ("word");
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####:16778:      text = expand_argument (text, p);
call    0 never executed
        -:16779:
    #####:16780:      p3 = expand_argument (p + 1, end);
call    0 never executed
        -:16781:
        -:16782:      /* Check the first argument.  */
    #####:16783:      for (p2 = text; *p2 != '\0'; ++p2)
branch  0 never executed
branch  1 never executed
    #####:16784:	if (*p2 < '0' || *p2 > '9')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:16785:	  {
    #####:16786:	    if (reading_filename != 0)
branch  0 never executed
branch  1 never executed
    #####:16787:	      makefile_fatal (reading_filename, *reading_lineno_ptr,
call    0 never executed
        -:16788:			      "non-numeric first argument to `word' function");
        -:16789:	    else
    #####:16790:	      fatal ("non-numeric first argument to `word' function");
call    0 never executed
        -:16791:	  }
        -:16792:
    #####:16793:      i = (unsigned int) atoi (text);
    #####:16794:      if (i == 0)
branch  0 never executed
branch  1 never executed
        -:16795:	{
    #####:16796:	  if (reading_filename != 0)
branch  0 never executed
branch  1 never executed
    #####:16797:	    makefile_fatal (reading_filename, *reading_lineno_ptr,
call    0 never executed
        -:16798:			    "the `word' function takes a one-origin \
        -:16799:index argument");
        -:16800:	  else
    #####:16801:	    fatal ("the `word' function takes a one-origin index argument");
call    0 never executed
        -:16802:	}
        -:16803:
    #####:16804:      p2 = p3;
    #####:16805:      while ((p = find_next_token (&p2, &len)) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:16806:	if (--i == 0)
branch  0 never executed
branch  1 never executed
    #####:16807:	  break;
    #####:16808:      if (i == 0)
branch  0 never executed
branch  1 never executed
    #####:16809:	o = variable_buffer_output (o, p, len);
call    0 never executed
        -:16810:
    #####:16811:      free (text);
    #####:16812:      free (p3);
    #####:16813:      break;
        -:16814:
    #####:16815:    case function_words:
        -:16816:      /* Expand the argument.  */
    #####:16817:      text = expand_argument (text, end);
call    0 never executed
        -:16818:
    #####:16819:      i = 0;
    #####:16820:      p2 = text;
    #####:16821:      while (find_next_token (&p2, (unsigned int *) 0) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:16822:	++i;
        -:16823:
        -:16824:      {
        -:16825:	char buf[20];
    #####:16826:	sprintf (buf, "%d", i);
    #####:16827:	o = variable_buffer_output (o, buf, strlen (buf));
call    0 never executed
        -:16828:      }
        -:16829:
    #####:16830:      free (text);
    #####:16831:      break;
        -:16832:
    #####:16833:    case function_wordlist:
        -:16834:      /* Get two comma-separated arguments and expand each one.  */
    #####:16835:      count = 0;
    #####:16836:      for (p = text; p < end; ++p)
branch  0 never executed
branch  1 never executed
        -:16837:	{
    #####:16838:	  if (*p == startparen)
branch  0 never executed
branch  1 never executed
    #####:16839:	    ++count;
    #####:16840:	  else if (*p == endparen)
branch  0 never executed
branch  1 never executed
    #####:16841:	    --count;
    #####:16842:	  else if (*p == ',' && count <= 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:16843:	    break;
        -:16844:	}
    #####:16845:      if (p == end)
branch  0 never executed
branch  1 never executed
    #####:16846:	BADARGS ("wordlist");
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####:16847:      text = expand_argument (text, p);
call    0 never executed
        -:16848:
        -:16849:      /* Check the first argument.  */
    #####:16850:      for (p2 = text; *p2 != '\0'; ++p2)
branch  0 never executed
branch  1 never executed
    #####:16851:	if (*p2 < '0' || *p2 > '9')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:16852:	  {
    #####:16853:	    if (reading_filename != 0)
branch  0 never executed
branch  1 never executed
    #####:16854:	      makefile_fatal (reading_filename, *reading_lineno_ptr,
call    0 never executed
        -:16855:			      "non-numeric first argument to `wordlist' function");
        -:16856:	    else
    #####:16857:	      fatal ("non-numeric first argument to `wordlist' function");
call    0 never executed
        -:16858:	  }
    #####:16859:      i = (unsigned int)atoi(text);
    #####:16860:      free (text);
        -:16861:
        -:16862:      /* Check the next argument */
    #####:16863:      for (p2 = p + 1; isblank(*p2); ++p2)
branch  0 never executed
branch  1 never executed
        -:16864:	{}
    #####:16865:      count = 0;
    #####:16866:      for (p = p2; p < end; ++p)
branch  0 never executed
branch  1 never executed
        -:16867:	{
    #####:16868:	  if (*p == startparen)
branch  0 never executed
branch  1 never executed
    #####:16869:	    ++count;
    #####:16870:	  else if (*p == endparen)
branch  0 never executed
branch  1 never executed
    #####:16871:	    --count;
    #####:16872:	  else if (*p == ',' && count <= 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:16873:	    break;
        -:16874:	}
    #####:16875:      if (p == end)
branch  0 never executed
branch  1 never executed
    #####:16876:	BADARGS ("wordlist");
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####:16877:      text = expand_argument (p2, p);
call    0 never executed
        -:16878:
    #####:16879:      for (p2 = text; *p2 != '\0'; ++p2)
branch  0 never executed
branch  1 never executed
    #####:16880:	if (*p2 < '0' || *p2 > '9')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:16881:	  {
    #####:16882:	    if (reading_filename != 0)
branch  0 never executed
branch  1 never executed
    #####:16883:	      makefile_fatal (reading_filename, *reading_lineno_ptr,
call    0 never executed
        -:16884:			      "non-numeric second argument to `wordlist' function");
        -:16885:	    else
    #####:16886:	      fatal ("non-numeric second argument to `wordlist' function");
call    0 never executed
        -:16887:	  }
    #####:16888:      j = (unsigned int)atoi(text);
    #####:16889:      free (text);
        -:16890:
    #####:16891:      if (j > i)
branch  0 never executed
branch  1 never executed
    #####:16892:	j -= i;
        -:16893:      else
        -:16894:	{
        -:16895:	  unsigned int k;
    #####:16896:	  k = j;
    #####:16897:	  j = i - j;
    #####:16898:	  i = k;
        -:16899:	}
    #####:16900:      ++j;
        -:16901:
        -:16902:      /* Extract the requested words */
    #####:16903:      text = expand_argument (p + 1, end);
call    0 never executed
    #####:16904:      p2 = text;
        -:16905:
    #####:16906:      while (((p = find_next_token (&p2, &len)) != 0) && --i)
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -:16907:	{}
    #####:16908:      if (p)
branch  0 never executed
branch  1 never executed
        -:16909:	{
    #####:16910:	  while (--j && (find_next_token (&p2, &len) != 0))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:16911:	    {}
    #####:16912:	  o = variable_buffer_output (o, p, p2 - p);
call    0 never executed
        -:16913:	}
        -:16914:
    #####:16915:      free (text);
    #####:16916:      break;
        -:16917:
    #####:16918:    case function_findstring:
        -:16919:      /* Get two comma-separated arguments and expand each one.  */
    #####:16920:      count = 0;
    #####:16921:      for (p = text; p < end; ++p)
branch  0 never executed
branch  1 never executed
        -:16922:	{
    #####:16923:	  if (*p == startparen)
branch  0 never executed
branch  1 never executed
    #####:16924:	    ++count;
    #####:16925:	  else if (*p == endparen)
branch  0 never executed
branch  1 never executed
    #####:16926:	    --count;
    #####:16927:	  else if (*p == ',' && count <= 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:16928:	    break;
        -:16929:	}
    #####:16930:      if (p == end)
branch  0 never executed
branch  1 never executed
    #####:16931:	BADARGS ("findstring");
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####:16932:      text = expand_argument (text, p);
call    0 never executed
        -:16933:
    #####:16934:      p = expand_argument (p + 1, end);
call    0 never executed
        -:16935:
        -:16936:      /* Find the first occurrence of the first string in the second.  */
    #####:16937:      i = strlen (text);
    #####:16938:      if (sindex (p, 0, text, i) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:16939:	o = variable_buffer_output (o, text, i);
call    0 never executed
        -:16940:
    #####:16941:      free (p);
    #####:16942:      free (text);
    #####:16943:      break;
        -:16944:
    #####:16945:    case function_addsuffix:
        -:16946:    case function_addprefix:
        -:16947:      /* Get two comma-separated arguments and expand each one.  */
    #####:16948:      count = 0;
    #####:16949:      for (p = text; p < end; ++p)
branch  0 never executed
branch  1 never executed
        -:16950:	{
    #####:16951:	  if (*p == startparen)
branch  0 never executed
branch  1 never executed
    #####:16952:	    ++count;
    #####:16953:	  else if (*p == endparen)
branch  0 never executed
branch  1 never executed
    #####:16954:	    --count;
    #####:16955:	  else if (*p == ',' && count <= 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:16956:	    break;
        -:16957:	}
    #####:16958:      if (p == end)
branch  0 never executed
branch  1 never executed
    #####:16959:	BADARGS (function == function_addsuffix ? "addsuffix" : "addprefix");
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
    #####:16960:      text = expand_argument (text, p);
call    0 never executed
    #####:16961:      i = strlen (text);
        -:16962:
    #####:16963:      p2 = expand_argument (p + 1, end);
call    0 never executed
        -:16964:
    #####:16965:      p3 = p2;
    #####:16966:      while ((p = find_next_token (&p3, &len)) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:16967:	{
    #####:16968:	  if (function == function_addprefix)
branch  0 never executed
branch  1 never executed
    #####:16969:	    o = variable_buffer_output (o, text, i);
call    0 never executed
    #####:16970:	  o = variable_buffer_output (o, p, len);
call    0 never executed
    #####:16971:	  if (function == function_addsuffix)
branch  0 never executed
branch  1 never executed
    #####:16972:	    o = variable_buffer_output (o, text, i);
call    0 never executed
    #####:16973:	  o = variable_buffer_output (o, " ", 1);
call    0 never executed
    #####:16974:	  doneany = 1;
        -:16975:	}
    #####:16976:      if (doneany)
branch  0 never executed
branch  1 never executed
        -:16977:	/* Kill last space.  */
    #####:16978:	--o;
        -:16979:
    #####:16980:      free (p2);
    #####:16981:      free (text);
    #####:16982:      break;
        -:16983:
    #####:16984:    case function_dir:
        -:16985:    case function_basename:
        -:16986:      /* Expand the argument.  */
    #####:16987:      text = expand_argument (text, end);
call    0 never executed
        -:16988:
    #####:16989:      p3 = text;
    #####:16990:      while ((p2 = find_next_token (&p3, &len)) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:16991:	{
    #####:16992:	  p = p2 + len;
        -:16993:#ifdef VMS
        -:16994:	  while (p >= p2 && *p != ']'
        -:16995:		 && (function != function_basename || *p != '.'))
        -:16996:#else
        -:16997:# ifdef __MSDOS__
        -:16998:	  while (p >= p2 && *p != '/' && *p != '\\'
        -:16999:		 && (function != function_basename || *p != '.'))
        -:17000:# else
    #####:17001:	  while (p >= p2 && *p != '/'
branch  0 never executed
branch  1 never executed
    #####:17002:		 && (function != function_basename || *p != '.'))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:17003:# endif
        -:17004:#endif
    #####:17005:	    --p;
    #####:17006:	  if (p >= p2 && (function == function_dir))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:17007:	    o = variable_buffer_output (o, p2, ++p - p2);
call    0 never executed
    #####:17008:	  else if (p >= p2 && (*p == '.'))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:17009:	    o = variable_buffer_output (o, p2, p - p2);
call    0 never executed
        -:17010:#if defined(WINDOWS32) || defined(__MSDOS__)
        -:17011:	/* Handle the "d:foobar" case */
        -:17012:	  else if (p2[0] && p2[1] == ':' && function == function_dir)
        -:17013:	    o = variable_buffer_output (o, p2, 2);
        -:17014:#endif
    #####:17015:	  else if (function == function_dir)
branch  0 never executed
branch  1 never executed
        -:17016:#ifdef VMS
        -:17017:	    o = variable_buffer_output (o, "[]", 2);
        -:17018:#else
        -:17019:#ifndef _AMIGA
    #####:17020:	    o = variable_buffer_output (o, "./", 2);
call    0 never executed
        -:17021:#else
        -:17022:	    /* o = o */; /* Just a nop...  */
        -:17023:#endif /* AMIGA */
        -:17024:#endif /* !VMS */
        -:17025:	  else
        -:17026:	    /* The entire name is the basename.  */
    #####:17027:	    o = variable_buffer_output (o, p2, len);
call    0 never executed
        -:17028:
    #####:17029:	  o = variable_buffer_output (o, " ", 1);
call    0 never executed
    #####:17030:	  doneany = 1;
        -:17031:	}
    #####:17032:      if (doneany)
branch  0 never executed
branch  1 never executed
        -:17033:	/* Kill last space.  */
    #####:17034:	--o;
        -:17035:
    #####:17036:      free (text);
    #####:17037:      break;
        -:17038:
    #####:17039:    case function_notdir:
        -:17040:    case function_suffix:
        -:17041:      /* Expand the argument.  */
    #####:17042:      text = expand_argument (text, end);
call    0 never executed
        -:17043:
    #####:17044:      p3 = text;
    #####:17045:      while ((p2 = find_next_token (&p3, &len)) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:17046:	{
    #####:17047:	  p = p2 + len;
        -:17048:#ifdef VMS
        -:17049:	  while (p >= p2 && *p != ']'
        -:17050:		 && (function != function_suffix || *p != '.'))
        -:17051:#else
        -:17052:# ifdef __MSDOS__
        -:17053:	  while (p >= p2 && *p != '/' && *p != '\\'
        -:17054:		 && (function != function_suffix || *p != '.'))
        -:17055:# else
    #####:17056:	  while (p >= p2 && *p != '/'
branch  0 never executed
branch  1 never executed
    #####:17057:		 && (function != function_suffix || *p != '.'))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:17058:# endif
        -:17059:#endif
    #####:17060:	    --p;
    #####:17061:	  if (p >= p2)
branch  0 never executed
branch  1 never executed
        -:17062:	    {
    #####:17063:	      if (function == function_notdir)
branch  0 never executed
branch  1 never executed
    #####:17064:		++p;
    #####:17065:	      else if (*p != '.')
branch  0 never executed
branch  1 never executed
    #####:17066:		continue;
    #####:17067:	      o = variable_buffer_output (o, p, len - (p - p2));
call    0 never executed
        -:17068:	    }
        -:17069:#if defined(WINDOWS32) || defined(__MSDOS__)
        -:17070:	  /* Handle the case of "d:foo/bar".  */
        -:17071:	  else if (function == function_notdir && p2[0] && p2[1] == ':')
        -:17072:	    {
        -:17073:	      p = p2 + 2;
        -:17074:	      o = variable_buffer_output (o, p, len - (p - p2));
        -:17075:	    }
        -:17076:#endif
    #####:17077:	  else if (function == function_notdir)
branch  0 never executed
branch  1 never executed
    #####:17078:	    o = variable_buffer_output (o, p2, len);
call    0 never executed
        -:17079:
    #####:17080:	  if (function == function_notdir || p >= p2)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:17081:	    {
    #####:17082:	      o = variable_buffer_output (o, " ", 1);
call    0 never executed
    #####:17083:	      doneany = 1;
        -:17084:	    }
        -:17085:	}
    #####:17086:      if (doneany)
branch  0 never executed
branch  1 never executed
        -:17087:	/* Kill last space.  */
    #####:17088:	--o;
        -:17089:
    #####:17090:      free (text);
    #####:17091:      break;
        -:17092:    }
        -:17093:
     1580:17094:  return o;
        -:17095:}
        -:17096:
        -:17097:/* Check for a function invocation in *STRINGP.  *STRINGP points at the
        -:17098:   opening ( or { and is not null-terminated.  If a function invocation
        -:17099:   is found, expand it into the buffer at *OP, updating *OP, incrementing
        -:17100:   *STRINGP past the reference and returning nonzero.  If not, return zero.  */
        -:17101:
        -:17102:int
function handle_function called 5666 returned 100% blocks executed 88%
     5666:17103:handle_function (op, stringp)
        -:17104:     char **op;
        -:17105:     char **stringp;
        -:17106:
        -:17107:{
        -:17108:  register unsigned int code;
        -:17109:  unsigned int maxlen;
     5666:17110:  char *beg = *stringp + 1;
        -:17111:  char *endref;
        -:17112:
     5666:17113:  endref = lindex (beg, beg + MAXFUNCTIONLEN, '\0');
call    0 returned 5666
     5666:17114:  maxlen = endref != 0 ? endref - beg : MAXFUNCTIONLEN;
branch  0 taken 4032 (fallthrough)
branch  1 taken 1634
        -:17115:
   116098:17116:  for (code = 0; function_table[code].name != 0; ++code)
branch  0 taken 112012
branch  1 taken 4086 (fallthrough)
        -:17117:    {
   112012:17118:      if (maxlen < function_table[code].len)
branch  0 taken 16616 (fallthrough)
branch  1 taken 95396
    16616:17119:	continue;
    95396:17120:      endref = beg + function_table[code].len;
    95396:17121:      if (isblank (*endref)
branch  0 taken 4952 (fallthrough)
branch  1 taken 90444
     4952:17122:	  && !strncmp (function_table[code].name, beg,
     4952:17123:		       function_table[code].len))
branch  0 taken 1580 (fallthrough)
branch  1 taken 3372
     1580:17124:	break;
        -:17125:    }
     5666:17126:  if (function_table[code].name != 0)
branch  0 taken 1580 (fallthrough)
branch  1 taken 4086
        -:17127:    {
        -:17128:      /* We have found a call to an expansion-time function.
        -:17129:	 Find the end of the arguments, and do the function.  */
        -:17130:
    1580*:17131:      char openparen = beg[-1], closeparen = openparen == '(' ? ')' : '}';
branch  0 taken 1580 (fallthrough)
branch  1 taken 0
     1580:17132:      int count = 0;
        -:17133:      char *argbeg;
        -:17134:      register char *p;
        -:17135:
        -:17136:      /* Space after function name isn't part of the args.  */
     1580:17137:      p = next_token (endref);
call    0 returned 1580
     1580:17138:      argbeg = p;
        -:17139:
        -:17140:      /* Count nested use of whichever kind of parens we use,
        -:17141:	 so that nested calls and variable refs work.  */
        -:17142:
    14220:17143:      for (; *p != '\0'; ++p)
branch  0 taken 14220
branch  1 taken 0 (fallthrough)
        -:17144:	{
    14220:17145:	  if (*p == openparen)
branch  0 taken 1580 (fallthrough)
branch  1 taken 12640
     1580:17146:	    ++count;
    12640:17147:	  else if (*p == closeparen && --count < 0)
branch  0 taken 3160 (fallthrough)
branch  1 taken 9480
branch  2 taken 1580 (fallthrough)
branch  3 taken 1580
     1580:17148:	    break;
        -:17149:	}
        -:17150:
     1580:17151:      if (count >= 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 1580
        -:17152:	{
        -:17153:	  static const char errmsg[]
        -:17154:	    = "unterminated call to function `%s': missing `%c'";
    #####:17155:	  if (reading_filename == 0)
branch  0 never executed
branch  1 never executed
    #####:17156:	    fatal (errmsg, function_table[code].name, closeparen);
call    0 never executed
        -:17157:	  else
    #####:17158:	    makefile_fatal (reading_filename, *reading_lineno_ptr, errmsg,
call    0 never executed
        -:17159:			    function_table[code].name, closeparen);
        -:17160:	}
        -:17161:
        -:17162:      /* We found the end; expand the function call.  */
        -:17163:
     1580:17164:      *op = expand_function (*op, function_table[code].function, argbeg, p);
call    0 returned 1580
     1580:17165:      *stringp = p;
     1580:17166:      return 1;
        -:17167:    }
        -:17168:
     4086:17169:  return 0;
        -:17170:}
        -:17171:
        -:17172:/* Glob-expand LINE.  The returned pointer is
        -:17173:   only good until the next call to string_glob.  */
        -:17174:
        -:17175:static char *
function string_glob called 0 returned 0% blocks executed 0%
    #####:17176:string_glob (line)
        -:17177:     char *line;
        -:17178:{
        -:17179:  static char *result = 0;
        -:17180:  static unsigned int length;
        -:17181:  register struct nameseq *chain;
        -:17182:  register unsigned int idx;
        -:17183:
    #####:17184:  chain = multi_glob (parse_file_seq
call    0 never executed
call    1 never executed
        -:17185:		      (&line, '\0', sizeof (struct nameseq),
        -:17186:		       /* We do not want parse_file_seq to strip `./'s.
        -:17187:			  That would break examples like:
        -:17188:			  $(patsubst ./%.c,obj/%.o,$(wildcard ./*.c)).  */
        -:17189:		       0),
        -:17190:		      sizeof (struct nameseq));
        -:17191:
    #####:17192:  if (result == 0)
branch  0 never executed
branch  1 never executed
        -:17193:    {
    #####:17194:      length = 100;
    #####:17195:      result = (char *) xmalloc (100);
call    0 never executed
        -:17196:    }
        -:17197:
    #####:17198:  idx = 0;
    #####:17199:  while (chain != 0)
branch  0 never executed
branch  1 never executed
        -:17200:    {
    #####:17201:      register char *name = chain->name;
    #####:17202:      unsigned int len = strlen (name);
        -:17203:
    #####:17204:      struct nameseq *next = chain->next;
    #####:17205:      free ((char *) chain);
    #####:17206:      chain = next;
        -:17207:
        -:17208:      /* multi_glob will pass names without globbing metacharacters
        -:17209:	 through as is, but we want only files that actually exist.  */
    #####:17210:      if (file_exists_p (name))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:17211:	{
    #####:17212:	  if (idx + len + 1 > length)
branch  0 never executed
branch  1 never executed
        -:17213:	    {
    #####:17214:	      length += (len + 1) * 2;
    #####:17215:	      result = (char *) xrealloc (result, length);
call    0 never executed
        -:17216:	    }
    #####:17217:	  bcopy (name, &result[idx], len);
    #####:17218:	  idx += len;
    #####:17219:	  result[idx++] = ' ';
        -:17220:	}
        -:17221:
    #####:17222:      free (name);
        -:17223:    }
        -:17224:
        -:17225:  /* Kill the last space and terminate the string.  */
    #####:17226:  if (idx == 0)
branch  0 never executed
branch  1 never executed
    #####:17227:    result[0] = '\0';
        -:17228:  else
    #####:17229:    result[idx - 1] = '\0';
        -:17230:
    #####:17231:  return result;
        -:17232:}
        -:17233:
        -:17234:
        -:17235:
        -:17236:/*************************************************************
        -:17237:  ============================================================
        -:17238:  ************************************************************
        -:17239:  ============================================================
        -:17240:  ************************************************************
        -:17241:                         vpath.c
        -:17242:  ************************************************************
        -:17243:  ============================================================
        -:17244:  ************************************************************
        -:17245:  ============================================================
        -:17246:  *************************************************************/
        -:17247:
        -:17248:/* Implementation of pattern-matching file search paths for GNU Make.
        -:17249:Copyright (C) 1988,89,91,92,93,94,95,96,97 Free Software Foundation, Inc.
        -:17250:This file is part of GNU Make.
        -:17251:
        -:17252:GNU Make is free software; you can redistribute it and/or modify
        -:17253:it under the terms of the GNU General Public License as published by
        -:17254:the Free Software Foundation; either version 2, or (at your option)
        -:17255:any later version.
        -:17256:
        -:17257:GNU Make is distributed in the hope that it will be useful,
        -:17258:but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:17259:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:17260:GNU General Public License for more details.
        -:17261:
        -:17262:You should have received a copy of the GNU General Public License
        -:17263:along with GNU Make; see the file COPYING.  If not, write to
        -:17264:the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
        -:17265:
        -:17266:#undef stderr
        -:17267:#define stderr stdout
        -:17268:#ifdef WINDOWS32
        -:17269:#include "pathstuff.h"
        -:17270:#undef stderr
        -:17271:#define stderr stdout
        -:17272:#endif
        -:17273:
        -:17274:
        -:17275:/* Structure used to represent a selective VPATH searchpath.  */
        -:17276:
        -:17277:struct vpath
        -:17278:  {
        -:17279:    struct vpath *next;	/* Pointer to next struct in the linked list.  */
        -:17280:    char *pattern;	/* The pattern to match.  */
        -:17281:    char *percent;	/* Pointer into `pattern' where the `%' is.  */
        -:17282:    unsigned int patlen;/* Length of the pattern.  */
        -:17283:    char **searchpath;	/* Null-terminated list of directories.  */
        -:17284:    unsigned int maxlen;/* Maximum length of any entry in the list.  */
        -:17285:  };
        -:17286:
        -:17287:/* Linked-list of all selective VPATHs.  */
        -:17288:
        -:17289:static struct vpath *vpaths;
        -:17290:
        -:17291:/* Structure for the general VPATH given in the variable.  */
        -:17292:
        -:17293:static struct vpath *general_vpath;
        -:17294:
        -:17295:/* Structure for GPATH given in the variable.  */
        -:17296:
        -:17297:static struct vpath *gpaths;
        -:17298:
        -:17299:static int selective_vpath_search PARAMS ((struct vpath *path, char **file, time_t *mtime_ptr));
        -:17300:
        -:17301:/* Reverse the chain of selective VPATH lists so they
        -:17302:   will be searched in the order given in the makefiles
        -:17303:   and construct the list from the VPATH variable.  */
        -:17304:
        -:17305:void
function build_vpath_lists called 790 returned 100% blocks executed 75%
      790:17306:build_vpath_lists ()
        -:17307:{
      790:17308:  register struct vpath *new = 0;
        -:17309:  register struct vpath *old, *nexto;
        -:17310:  register char *p;
        -:17311:
        -:17312:  /* Reverse the chain.  */
     790*:17313:  for (old = vpaths; old != 0; old = nexto)
branch  0 taken 0
branch  1 taken 790 (fallthrough)
        -:17314:    {
    #####:17315:      nexto = old->next;
    #####:17316:      old->next = new;
    #####:17317:      new = old;
        -:17318:    }
        -:17319:
      790:17320:  vpaths = new;
        -:17321:
        -:17322:  /* If there is a VPATH variable with a nonnull value, construct the
        -:17323:     general VPATH list from it.  We use variable_expand rather than just
        -:17324:     calling lookup_variable so that it will be recursively expanded.  */
        -:17325:
        -:17326:  {
        -:17327:    /* Turn off --warn-undefined-variables while we expand SHELL and IFS.  */
      790:17328:    int save = warn_undefined_variables_flag;
      790:17329:    warn_undefined_variables_flag = 0;
        -:17330:
      790:17331:    p = variable_expand ("$(strip $(VPATH))");
call    0 returned 790
        -:17332:
      790:17333:    warn_undefined_variables_flag = save;
        -:17334:  }
        -:17335:
      790:17336:  if (*p != '\0')
branch  0 taken 18 (fallthrough)
branch  1 taken 772
        -:17337:    {
        -:17338:      /* Save the list of vpaths.  */
       18:17339:      struct vpath *save_vpaths = vpaths;
        -:17340:
        -:17341:      /* Empty `vpaths' so the new one will have no next, and `vpaths'
        -:17342:	 will still be nil if P contains no existing directories.  */
       18:17343:      vpaths = 0;
        -:17344:
        -:17345:      /* Parse P.  */
       18:17346:      construct_vpath_list ("%", p);
call    0 returned 18
        -:17347:
        -:17348:      /* Store the created path as the general path,
        -:17349:	 and restore the old list of vpaths.  */
       18:17350:      general_vpath = vpaths;
       18:17351:      vpaths = save_vpaths;
        -:17352:    }
        -:17353:
        -:17354:  /* If there is a GPATH variable with a nonnull value, construct the
        -:17355:     GPATH list from it.  We use variable_expand rather than just
        -:17356:     calling lookup_variable so that it will be recursively expanded.  */
        -:17357:
        -:17358:  {
        -:17359:    /* Turn off --warn-undefined-variables while we expand SHELL and IFS.  */
      790:17360:    int save = warn_undefined_variables_flag;
      790:17361:    warn_undefined_variables_flag = 0;
        -:17362:
      790:17363:    p = variable_expand ("$(strip $(GPATH))");
call    0 returned 790
        -:17364:
      790:17365:    warn_undefined_variables_flag = save;
        -:17366:  }
        -:17367:
      790:17368:  if (*p != '\0')
branch  0 taken 0 (fallthrough)
branch  1 taken 790
        -:17369:    {
        -:17370:      /* Save the list of vpaths.  */
    #####:17371:      struct vpath *save_vpaths = vpaths;
        -:17372:
        -:17373:      /* Empty `vpaths' so the new one will have no next, and `vpaths'
        -:17374:	 will still be nil if P contains no existing directories.  */
    #####:17375:      vpaths = 0;
        -:17376:
        -:17377:      /* Parse P.  */
    #####:17378:      construct_vpath_list ("%", p);
call    0 never executed
        -:17379:
        -:17380:      /* Store the created path as the GPATH,
        -:17381:	 and restore the old list of vpaths.  */
    #####:17382:      gpaths = vpaths;
    #####:17383:      vpaths = save_vpaths;
        -:17384:    }
      790:17385:}
        -:17386:
        -:17387:/* Construct the VPATH listing for the pattern and searchpath given.
        -:17388:
        -:17389:   This function is called to generate selective VPATH lists and also for
        -:17390:   the general VPATH list (which is in fact just a selective VPATH that
        -:17391:   is applied to everything).  The returned pointer is either put in the
        -:17392:   linked list of all selective VPATH lists or in the GENERAL_VPATH
        -:17393:   variable.
        -:17394:
        -:17395:   If SEARCHPATH is nil, remove all previous listings with the same
        -:17396:   pattern.  If PATTERN is nil, remove all VPATH listings.  Existing
        -:17397:   and readable directories that are not "." given in the searchpath
        -:17398:   separated by the path element separator (defined in make.h) are
        -:17399:   loaded into the directory hash table if they are not there already
        -:17400:   and put in the VPATH searchpath for the given pattern with trailing
        -:17401:   slashes stripped off if present (and if the directory is not the
        -:17402:   root, "/").  The length of the longest entry in the list is put in
        -:17403:   the structure as well.  The new entry will be at the head of the
        -:17404:   VPATHS chain.  */
        -:17405:
        -:17406:void
function construct_vpath_list called 18 returned 100% blocks executed 45%
       18:17407:construct_vpath_list (pattern, dirpath)
        -:17408:     char *pattern, *dirpath;
        -:17409:{
        -:17410:  register unsigned int elem;
        -:17411:  register char *p;
        -:17412:  register char **vpath;
        -:17413:  register unsigned int maxvpath;
        -:17414:  unsigned int maxelem;
       18:17415:  char *percent = NULL;
        -:17416:
       18:17417:  if (pattern != 0)
branch  0 taken 18 (fallthrough)
branch  1 taken 0
        -:17418:    {
       18:17419:      pattern = savestring (pattern, strlen (pattern));
call    0 returned 18
       18:17420:      percent = find_percent (pattern);
call    0 returned 18
        -:17421:    }
        -:17422:
       18:17423:  if (dirpath == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 18
        -:17424:    {
        -:17425:      /* Remove matching listings.  */
        -:17426:      register struct vpath *path, *lastpath;
        -:17427:
    #####:17428:      lastpath = 0;
    #####:17429:      path = vpaths;
    #####:17430:      while (path != 0)
branch  0 never executed
branch  1 never executed
        -:17431:	{
    #####:17432:	  struct vpath *next = path->next;
        -:17433:
    #####:17434:	  if (pattern == 0
branch  0 never executed
branch  1 never executed
    #####:17435:	      || (((percent == 0 && path->percent == 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:17436:		   || (percent - pattern == path->percent - path->pattern))
branch  0 never executed
branch  1 never executed
    #####:17437:		  && streq (pattern, path->pattern)))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -:17438:	    {
        -:17439:	      /* Remove it from the linked list.  */
    #####:17440:	      if (lastpath == 0)
branch  0 never executed
branch  1 never executed
    #####:17441:		vpaths = path->next;
        -:17442:	      else
    #####:17443:		lastpath->next = next;
        -:17444:
        -:17445:	      /* Free its unused storage.  */
    #####:17446:	      free (path->pattern);
    #####:17447:	      free ((char *) path->searchpath);
    #####:17448:	      free ((char *) path);
        -:17449:	    }
        -:17450:	  else
    #####:17451:	    lastpath = path;
        -:17452:
    #####:17453:	  path = next;
        -:17454:	}
        -:17455:
    #####:17456:      if (pattern != 0)
branch  0 never executed
branch  1 never executed
    #####:17457:	free (pattern);
    #####:17458:      return;
        -:17459:    }
        -:17460:
        -:17461:#ifdef WINDOWS32
        -:17462:    convert_vpath_to_windows32(dirpath, ';');
        -:17463:#endif
        -:17464:
        -:17465:  /* Figure out the maximum number of VPATH entries and put it in
        -:17466:     MAXELEM.  We start with 2, one before the first separator and one
        -:17467:     nil (the list terminator) and increment our estimated number for
        -:17468:     each separator or blank we find.  */
       18:17469:  maxelem = 2;
       18:17470:  p = dirpath;
       36:17471:  while (*p != '\0')
branch  0 taken 18
branch  1 taken 18 (fallthrough)
       18:17472:    if (*p++ == PATH_SEPARATOR_CHAR || isblank (*p))
branch  0 taken 18 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 18
    #####:17473:      ++maxelem;
        -:17474:
       18:17475:  vpath = (char **) xmalloc (maxelem * sizeof (char *));
call    0 returned 18
       18:17476:  maxvpath = 0;
        -:17477:
        -:17478:  /* Skip over any initial separators and blanks.  */
       18:17479:  p = dirpath;
       18:17480:  while (*p == PATH_SEPARATOR_CHAR || isblank (*p))
branch  0 taken 0
branch  1 taken 18 (fallthrough)
branch  2 taken 0
branch  3 taken 18 (fallthrough)
    #####:17481:    ++p;
        -:17482:
       18:17483:  elem = 0;
       36:17484:  while (*p != '\0')
branch  0 taken 18
branch  1 taken 18 (fallthrough)
        -:17485:    {
        -:17486:      char *v;
        -:17487:      unsigned int len;
        -:17488:
        -:17489:      /* Find the end of this entry.  */
       18:17490:      v = p;
       36:17491:      while (*p != '\0' && *p != PATH_SEPARATOR_CHAR && !isblank (*p))
branch  0 taken 18 (fallthrough)
branch  1 taken 18
branch  2 taken 18 (fallthrough)
branch  3 taken 0
branch  4 taken 18
branch  5 taken 0 (fallthrough)
       18:17492:	++p;
        -:17493:
       18:17494:      len = p - v;
        -:17495:      /* Make sure there's no trailing slash,
        -:17496:	 but still allow "/" as a directory.  */
        -:17497:#ifdef __MSDOS__
        -:17498:      /* We need also to leave alone a trailing slash in "d:/".  */
        -:17499:      if (len > 3 || (len > 1 && v[1] != ':'))
        -:17500:#endif
      18*:17501:      if (len > 1 && p[-1] == '/')
branch  0 taken 0 (fallthrough)
branch  1 taken 18
branch  2 never executed
branch  3 never executed
    #####:17502:	--len;
        -:17503:
       18:17504:      if (len > 1 || *v != '.')
branch  0 taken 18 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 18
        -:17505:	{
    #####:17506:	  v = savestring (v, len);
call    0 never executed
        -:17507:
        -:17508:	  /* Verify that the directory actually exists.  */
        -:17509:
    #####:17510:	  if (dir_file_exists_p (v, ""))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:17511:	    {
        -:17512:	      /* It does.  Put it in the list.  */
    #####:17513:	      vpath[elem++] = dir_name (v);
call    0 never executed
    #####:17514:	      free (v);
    #####:17515:	      if (len > maxvpath)
branch  0 never executed
branch  1 never executed
    #####:17516:		maxvpath = len;
        -:17517:	    }
        -:17518:	  else
        -:17519:	    /* The directory does not exist.  Omit from the list.  */
    #####:17520:	    free (v);
        -:17521:	}
        -:17522:
        -:17523:      /* Skip over separators and blanks between entries.  */
       18:17524:      while (*p == PATH_SEPARATOR_CHAR || isblank (*p))
branch  0 taken 0
branch  1 taken 18 (fallthrough)
branch  2 taken 0
branch  3 taken 18 (fallthrough)
    #####:17525:	++p;
        -:17526:    }
        -:17527:
       18:17528:  if (elem > 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 18
        -:17529:    {
        -:17530:      struct vpath *path;
        -:17531:      /* ELEM is now incremented one element past the last
        -:17532:	 entry, to where the nil-pointer terminator goes.
        -:17533:	 Usually this is maxelem - 1.  If not, shrink down.  */
    #####:17534:      if (elem < (maxelem - 1))
branch  0 never executed
branch  1 never executed
    #####:17535:	vpath = (char **) xrealloc ((char *) vpath,
    #####:17536:				    (elem + 1) * sizeof (char *));
call    0 never executed
        -:17537:
        -:17538:      /* Put the nil-pointer terminator on the end of the VPATH list.  */
    #####:17539:      vpath[elem] = 0;
        -:17540:
        -:17541:      /* Construct the vpath structure and put it into the linked list.  */
    #####:17542:      path = (struct vpath *) xmalloc (sizeof (struct vpath));
call    0 never executed
    #####:17543:      path->searchpath = vpath;
    #####:17544:      path->maxlen = maxvpath;
    #####:17545:      path->next = vpaths;
    #####:17546:      vpaths = path;
        -:17547:
        -:17548:      /* Set up the members.  */
    #####:17549:      path->pattern = pattern;
    #####:17550:      path->percent = percent;
    #####:17551:      path->patlen = strlen (pattern);
        -:17552:    }
        -:17553:  else
        -:17554:    {
        -:17555:      /* There were no entries, so free whatever space we allocated.  */
       18:17556:      free ((char *) vpath);
       18:17557:      if (pattern != 0)
branch  0 taken 18 (fallthrough)
branch  1 taken 0
       18:17558:	free (pattern);
        -:17559:    }
        -:17560:}
        -:17561:
        -:17562:/* Search the GPATH list for a pathname string that matches the one passed
        -:17563:   in.  If it is found, return 1.  Otherwise we return 0.  */
        -:17564:
        -:17565:int
function gpath_search called 0 returned 0% blocks executed 0%
    #####:17566:gpath_search (file, len)
        -:17567:     char *file;
        -:17568:     int len;
        -:17569:{
        -:17570:  register char **gp;
        -:17571:
    #####:17572:  if (gpaths && (len <= gpaths->maxlen))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:17573:    for (gp = gpaths->searchpath; *gp != NULL; ++gp)
branch  0 never executed
branch  1 never executed
    #####:17574:      if (!strncmp(*gp, file, len) && (*gp)[len] == '\0')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:17575:        return 1;
        -:17576:
    #####:17577:  return 0;
        -:17578:}
        -:17579:
        -:17580:/* Search the VPATH list whose pattern matches *FILE for a directory
        -:17581:   where the name pointed to by FILE exists.  If it is found, we set *FILE to
        -:17582:   the newly malloc'd name of the existing file, *MTIME_PTR (if MTIME_PTR is
        -:17583:   not NULL) to its modtime (or zero if no stat call was done), and return 1.
        -:17584:   Otherwise we return 0.  */
        -:17585:
        -:17586:int
function vpath_search called 113842 returned 100% blocks executed 28%
   113842:17587:vpath_search (file, mtime_ptr)
        -:17588:     char **file;
        -:17589:     time_t *mtime_ptr;
        -:17590:{
        -:17591:  register struct vpath *v;
        -:17592:
        -:17593:  /* If there are no VPATH entries or FILENAME starts at the root,
        -:17594:     there is nothing we can do.  */
        -:17595:
   113842:17596:  if (**file == '/'
branch  0 taken 6534 (fallthrough)
branch  1 taken 107308
        -:17597:#if defined (WINDOWS32) || defined (__MSDOS__)
        -:17598:      || **file == '\\'
        -:17599:      || (*file)[1] == ':'
        -:17600:#endif
     6534:17601:      || (vpaths == 0 && general_vpath == 0))
branch  0 taken 6534 (fallthrough)
branch  1 taken 0
branch  2 taken 6534 (fallthrough)
branch  3 taken 0
   113842:17602:    return 0;
        -:17603:
    #####:17604:  for (v = vpaths; v != 0; v = v->next)
branch  0 never executed
branch  1 never executed
    #####:17605:    if (pattern_matches (v->pattern, v->percent, *file))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:17606:      if (selective_vpath_search (v, file, mtime_ptr))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:17607:	return 1;
        -:17608:
    #####:17609:  if (general_vpath != 0
branch  0 never executed
branch  1 never executed
    #####:17610:      && selective_vpath_search (general_vpath, file, mtime_ptr))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:17611:    return 1;
        -:17612:
    #####:17613:  return 0;
        -:17614:}
        -:17615:
        -:17616:
        -:17617:/* Search the given VPATH list for a directory where the name pointed
        -:17618:   to by FILE exists.  If it is found, we set *FILE to the newly malloc'd
        -:17619:   name of the existing file, *MTIME_PTR (if MTIME_PTR is not NULL) to
        -:17620:   its modtime (or zero if no stat call was done), and we return 1.
        -:17621:   Otherwise we return 0.  */
        -:17622:
        -:17623:static int
function selective_vpath_search called 0 returned 0% blocks executed 0%
    #####:17624:selective_vpath_search (path, file, mtime_ptr)
        -:17625:     struct vpath *path;
        -:17626:     char **file;
        -:17627:     time_t *mtime_ptr;
        -:17628:{
        -:17629:  int not_target;
        -:17630:  char *name, *n;
        -:17631:  char *filename;
    #####:17632:  register char **vpath = path->searchpath;
    #####:17633:  unsigned int maxvpath = path->maxlen;
        -:17634:  register unsigned int i;
        -:17635:  unsigned int flen, vlen, name_dplen;
    #####:17636:  int exists = 0;
        -:17637:
        -:17638:  /* Find out if *FILE is a target.
        -:17639:     If and only if it is NOT a target, we will accept prospective
        -:17640:     files that don't exist but are mentioned in a makefile.  */
        -:17641:  {
    #####:17642:    struct file *f = lookup_file (*file);
call    0 never executed
    #####:17643:    not_target = f == 0 || !f->is_target;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:17644:  }
        -:17645:
    #####:17646:  flen = strlen (*file);
        -:17647:
        -:17648:  /* Split *FILE into a directory prefix and a name-within-directory.
        -:17649:     NAME_DPLEN gets the length of the prefix; FILENAME gets the
        -:17650:     pointer to the name-within-directory and FLEN is its length.  */
        -:17651:
    #####:17652:  n = rindex (*file, '/');
        -:17653:#if defined (WINDOWS32) || defined (__MSDOS__)
        -:17654:  /* We need the rightmost slash or backslash.  */
        -:17655:  {
        -:17656:    char *bslash = rindex(*file, '\\');
        -:17657:    if (!n || bslash > n)
        -:17658:      n = bslash;
        -:17659:  }
        -:17660:#endif
    #####:17661:  name_dplen = n != 0 ? n - *file : 0;
branch  0 never executed
branch  1 never executed
    #####:17662:  filename = name_dplen > 0 ? n + 1 : *file;
branch  0 never executed
branch  1 never executed
    #####:17663:  if (name_dplen > 0)
branch  0 never executed
branch  1 never executed
    #####:17664:    flen -= name_dplen + 1;
        -:17665:
        -:17666:  /* Allocate enough space for the biggest VPATH entry,
        -:17667:     a slash, the directory prefix that came with *FILE,
        -:17668:     another slash (although this one may not always be
        -:17669:     necessary), the filename, and a null terminator.  */
    #####:17670:  name = (char *) xmalloc (maxvpath + 1 + name_dplen + 1 + flen + 1);
call    0 never executed
        -:17671:
        -:17672:  /* Try each VPATH entry.  */
    #####:17673:  for (i = 0; vpath[i] != 0; ++i)
branch  0 never executed
branch  1 never executed
        -:17674:    {
    #####:17675:      int exists_in_cache = 0;
        -:17676:
    #####:17677:      n = name;
        -:17678:
        -:17679:      /* Put the next VPATH entry into NAME at N and increment N past it.  */
    #####:17680:      vlen = strlen (vpath[i]);
    #####:17681:      bcopy (vpath[i], n, vlen);
    #####:17682:      n += vlen;
        -:17683:
        -:17684:      /* Add the directory prefix already in *FILE.  */
    #####:17685:      if (name_dplen > 0)
branch  0 never executed
branch  1 never executed
        -:17686:	{
        -:17687:#ifndef VMS
    #####:17688:	  *n++ = '/';
        -:17689:#endif
    #####:17690:	  bcopy (*file, n, name_dplen);
    #####:17691:	  n += name_dplen;
        -:17692:	}
        -:17693:
        -:17694:#if defined (WINDOWS32) || defined (__MSDOS__)
        -:17695:      /* Cause the next if to treat backslash and slash alike.  */
        -:17696:      if (n != name && n[-1] == '\\' )
        -:17697:	n[-1] = '/';
        -:17698:#endif
        -:17699:      /* Now add the name-within-directory at the end of NAME.  */
        -:17700:#ifndef VMS
    #####:17701:      if (n != name && n[-1] != '/')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:17702:	{
    #####:17703:	  *n = '/';
    #####:17704:	  bcopy (filename, n + 1, flen + 1);
        -:17705:	}
        -:17706:      else
        -:17707:#endif
    #####:17708:	bcopy (filename, n, flen + 1);
        -:17709:
        -:17710:      /* Check if the file is mentioned in a makefile.  If *FILE is not
        -:17711:	 a target, that is enough for us to decide this file exists.
        -:17712:	 If *FILE is a target, then the file must be mentioned in the
        -:17713:	 makefile also as a target to be chosen.
        -:17714:
        -:17715:	 The restriction that *FILE must not be a target for a
        -:17716:	 makefile-mentioned file to be chosen was added by an
        -:17717:	 inadequately commented change in July 1990; I am not sure off
        -:17718:	 hand what problem it fixes.
        -:17719:
        -:17720:	 In December 1993 I loosened this restriction to allow a file
        -:17721:	 to be chosen if it is mentioned as a target in a makefile.  This
        -:17722:	 seem logical.  */
        -:17723:      {
    #####:17724:	struct file *f = lookup_file (name);
call    0 never executed
    #####:17725:	if (f != 0)
branch  0 never executed
branch  1 never executed
    #####:17726:	  exists = not_target || f->is_target;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:17727:      }
        -:17728:
    #####:17729:      if (!exists)
branch  0 never executed
branch  1 never executed
        -:17730:	{
        -:17731:	  /* That file wasn't mentioned in the makefile.
        -:17732:	     See if it actually exists.  */
        -:17733:
        -:17734:#ifdef VMS
        -:17735:	  exists_in_cache = exists = dir_file_exists_p (vpath[i], filename);
        -:17736:#else
        -:17737:	  /* Clobber a null into the name at the last slash.
        -:17738:	     Now NAME is the name of the directory to look in.  */
    #####:17739:	  *n = '\0';
        -:17740:
        -:17741:	  /* We know the directory is in the hash table now because either
        -:17742:	     construct_vpath_list or the code just above put it there.
        -:17743:	     Does the file we seek exist in it?  */
    #####:17744:	  exists_in_cache = exists = dir_file_exists_p (name, filename);
call    0 never executed
        -:17745:#endif
        -:17746:	}
        -:17747:
    #####:17748:      if (exists)
branch  0 never executed
branch  1 never executed
        -:17749:	{
        -:17750:	  /* The file is in the directory cache.
        -:17751:	     Now check that it actually exists in the filesystem.
        -:17752:	     The cache may be out of date.  When vpath thinks a file
        -:17753:	     exists, but stat fails for it, confusion results in the
        -:17754:	     higher levels.  */
        -:17755:
        -:17756:	  struct stat st;
        -:17757:
        -:17758:#ifndef VMS
        -:17759:	  /* Put the slash back in NAME.  */
    #####:17760:	  *n = '/';
        -:17761:#endif
        -:17762:
    #####:17763:	  if (!exists_in_cache	/* Makefile-mentioned file need not exist.  */
branch  0 never executed
branch  1 never executed
    #####:17764:	      || stat (name, &st) == 0) /* Does it really exist?  */
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:17765:	    {
        -:17766:	      /* We have found a file.
        -:17767:		 Store the name we found into *FILE for the caller.  */
        -:17768:
    #####:17769:	      *file = savestring (name, (n + 1 - name) + flen);
call    0 never executed
        -:17770:
    #####:17771:	      if (mtime_ptr != 0)
branch  0 never executed
branch  1 never executed
        -:17772:		/* Store the modtime into *MTIME_PTR for the caller.
        -:17773:		   If we have had no need to stat the file here,
        -:17774:		   we record a zero modtime to indicate this.  */
    #####:17775:		*mtime_ptr = exists_in_cache ? st.st_mtime : (time_t) 0;
branch  0 never executed
branch  1 never executed
        -:17776:
    #####:17777:	      free (name);
    #####:17778:	      return 1;
        -:17779:	    }
        -:17780:	  else
    #####:17781:	    exists = 0;
        -:17782:	}
        -:17783:    }
        -:17784:
    #####:17785:  free (name);
    #####:17786:  return 0;
        -:17787:}
        -:17788:
        -:17789:/* Print the data base of VPATH search paths.  */
        -:17790:
        -:17791:void
function print_vpath_data_base called 385 returned 100% blocks executed 31%
      385:17792:print_vpath_data_base ()
        -:17793:{
        -:17794:  register unsigned int nvpaths;
        -:17795:  register struct vpath *v;
        -:17796:
      385:17797:  puts ("\n# VPATH Search Paths\n");
call    0 returned 385
        -:17798:
      385:17799:  nvpaths = 0;
     385*:17800:  for (v = vpaths; v != 0; v = v->next)
branch  0 taken 0
branch  1 taken 385 (fallthrough)
        -:17801:    {
        -:17802:      register unsigned int i;
        -:17803:
    #####:17804:      ++nvpaths;
        -:17805:
    #####:17806:      printf ("vpath %s ", v->pattern);
call    0 never executed
        -:17807:
    #####:17808:      for (i = 0; v->searchpath[i] != 0; ++i)
branch  0 never executed
branch  1 never executed
    #####:17809:	printf ("%s%c", v->searchpath[i],
call    0 never executed
    #####:17810:		v->searchpath[i + 1] == 0 ? '\n' : PATH_SEPARATOR_CHAR);
branch  0 never executed
branch  1 never executed
        -:17811:    }
        -:17812:
      385:17813:  if (vpaths == 0)
branch  0 taken 385 (fallthrough)
branch  1 taken 0
      385:17814:    puts ("# No `vpath' search paths.");
call    0 returned 385
        -:17815:  else
    #####:17816:    printf ("\n# %u `vpath' search paths.\n", nvpaths);
call    0 never executed
        -:17817:
      385:17818:  if (general_vpath == 0)
branch  0 taken 385 (fallthrough)
branch  1 taken 0
      385:17819:    puts ("\n# No general (`VPATH' variable) search path.");
call    0 returned 385
        -:17820:  else
        -:17821:    {
    #####:17822:      register char **path = general_vpath->searchpath;
        -:17823:      register unsigned int i;
        -:17824:
    #####:17825:      fputs ("\n# General (`VPATH' variable) search path:\n# ", stdout);
call    0 never executed
        -:17826:
    #####:17827:      for (i = 0; path[i] != 0; ++i)
branch  0 never executed
branch  1 never executed
    #####:17828:	printf ("%s%c", path[i],
call    0 never executed
    #####:17829:		path[i + 1] == 0 ? '\n' : PATH_SEPARATOR_CHAR);
branch  0 never executed
branch  1 never executed
        -:17830:    }
      385:17831:}
        -:17832:
        -:17833:
        -:17834:
        -:17835:
        -:17836:/*************************************************************
        -:17837:  ============================================================
        -:17838:  ************************************************************
        -:17839:  ============================================================
        -:17840:  ************************************************************
        -:17841:                         version.c
        -:17842:  ************************************************************
        -:17843:  ============================================================
        -:17844:  ************************************************************
        -:17845:  ============================================================
        -:17846:  *************************************************************/
        -:17847:
        -:17848:/* We use <config.h> instead of "config.h" so that a compilation
        -:17849:   using -I. -I$srcdir will use ./config.h rather than $srcdir/config.h
        -:17850:   (which it would do because make.h was found in $srcdir).  */
        -:17851:
        -:17852:
        -:17853:char *version_string = VERSION;
        -:17854:
        -:17855:/*
        -:17856:  Local variables:
        -:17857:  version-control: never
        -:17858:  End:
        -:17859: */
        -:17860:
        -:17861:
        -:17862:
        -:17863:/*************************************************************
        -:17864:  ============================================================
        -:17865:  ************************************************************
        -:17866:  ============================================================
        -:17867:  ************************************************************
        -:17868:                         ar.c
        -:17869:  ************************************************************
        -:17870:  ============================================================
        -:17871:  ************************************************************
        -:17872:  ============================================================
        -:17873:  *************************************************************/
        -:17874:
        -:17875:/* Interface to `ar' archives for GNU Make.
        -:17876:Copyright (C) 1988,89,90,91,92,93,97 Free Software Foundation, Inc.
        -:17877:This file is part of GNU Make.
        -:17878:
        -:17879:GNU Make is free software; you can redistribute it and/or modify
        -:17880:it under the terms of the GNU General Public License as published by
        -:17881:the Free Software Foundation; either version 2, or (at your option)
        -:17882:any later version.
        -:17883:
        -:17884:GNU Make is distributed in the hope that it will be useful,
        -:17885:but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:17886:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:17887:GNU General Public License for more details.
        -:17888:
        -:17889:You should have received a copy of the GNU General Public License
        -:17890:along with GNU Make; see the file COPYING.  If not, write to
        -:17891:the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
        -:17892:
        -:17893:
        -:17894:
        -:17895:#ifndef	NO_ARCHIVES
        -:17896:
        -:17897:
        -:17898:
        -:17899:/* Defined in arscan.c.  */
        -:17900:extern long int ar_scan PARAMS ((char *archive, long int (*function) (), long int arg));
        -:17901:extern int ar_name_equal PARAMS ((char *name, char *mem, int truncated));
        -:17902:#ifndef VMS
        -:17903:extern int ar_member_touch PARAMS ((char *arname, char *memname));
        -:17904:#endif
        -:17905:
        -:17906:/* Return nonzero if NAME is an archive-member reference, zero if not.
        -:17907:   An archive-member reference is a name like `lib(member)'.
        -:17908:   If a name like `lib((entry))' is used, a fatal error is signaled at
        -:17909:   the attempt to use this unsupported feature.  */
        -:17910:
        -:17911:int
function ar_name called 163911 returned 100% blocks executed 33%
   163911:17912:ar_name (name)
        -:17913:     char *name;
        -:17914:{
   163911:17915:  char *p = index (name, '('), *end = name + strlen (name) - 1;
        -:17916:
  163911*:17917:  if (p == 0 || p == name || *end != ')')
branch  0 taken 0 (fallthrough)
branch  1 taken 163911
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
   163911:17918:    return 0;
        -:17919:
    #####:17920:  if (p[1] == '(' && end[-1] == ')')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:17921:    fatal ("attempt to use unsupported feature: `%s'", name);
call    0 never executed
        -:17922:
    #####:17923:  return 1;
        -:17924:}
        -:17925:
        -:17926:
        -:17927:/* Parse the archive-member reference NAME into the archive and member names.
        -:17928:   Put the malloc'd archive name in *ARNAME_P if ARNAME_P is non-nil;
        -:17929:   put the malloc'd member name in *MEMNAME_P if MEMNAME_P is non-nil.  */
        -:17930:
        -:17931:void
function ar_parse_name called 0 returned 0% blocks executed 0%
    #####:17932:ar_parse_name (name, arname_p, memname_p)
        -:17933:     char *name, **arname_p, **memname_p;
        -:17934:{
    #####:17935:  char *p = index (name, '('), *end = name + strlen (name) - 1;
        -:17936:
    #####:17937:  if (arname_p != 0)
branch  0 never executed
branch  1 never executed
    #####:17938:    *arname_p = savestring (name, p - name);
call    0 never executed
        -:17939:
    #####:17940:  if (memname_p != 0)
branch  0 never executed
branch  1 never executed
    #####:17941:    *memname_p = savestring (p + 1, end - (p + 1));
call    0 never executed
    #####:17942:}
        -:17943:
        -:17944:static long int ar_member_date_1 PARAMS ((int desc, char *mem, int truncated, long int hdrpos,
        -:17945:	long int datapos, long int size, long int date, int uid, int gid, int mode, char *name));
        -:17946:
        -:17947:/* Return the modtime of NAME.  */
        -:17948:
        -:17949:time_t
function ar_member_date called 0 returned 0% blocks executed 0%
    #####:17950:ar_member_date (name)
        -:17951:     char *name;
        -:17952:{
        -:17953:  char *arname;
    #####:17954:  int arname_used = 0;
        -:17955:  char *memname;
        -:17956:  long int val;
        -:17957:
    #####:17958:  ar_parse_name (name, &arname, &memname);
call    0 never executed
        -:17959:
        -:17960:  /* Make sure we know the modtime of the archive itself because we are
        -:17961:     likely to be called just before commands to remake a member are run,
        -:17962:     and they will change the archive itself.
        -:17963:
        -:17964:     But we must be careful not to enter_file the archive itself if it does
        -:17965:     not exist, because pattern_search assumes that files found in the data
        -:17966:     base exist or can be made.  */
        -:17967:  {
        -:17968:    struct file *arfile;
    #####:17969:    arfile = lookup_file (arname);
call    0 never executed
    #####:17970:    if (arfile == 0 && file_exists_p (arname))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:17971:      {
    #####:17972:	arfile = enter_file (arname);
call    0 never executed
    #####:17973:	arname_used = 1;
        -:17974:      }
        -:17975:
    #####:17976:    if (arfile != 0)
branch  0 never executed
branch  1 never executed
    #####:17977:      (void) f_mtime (arfile, 0);
call    0 never executed
        -:17978:  }
        -:17979:
    #####:17980:  val = ar_scan (arname, ar_member_date_1, (long int) memname);
call    0 never executed
        -:17981:
    #####:17982:  if (!arname_used)
branch  0 never executed
branch  1 never executed
    #####:17983:    free (arname);
    #####:17984:  free (memname);
        -:17985:
    #####:17986:  return (val <= 0 ? (time_t) -1 : (time_t) val);
branch  0 never executed
branch  1 never executed
        -:17987:}
        -:17988:
        -:17989:/* This function is called by `ar_scan' to find which member to look at.  */
        -:17990:
        -:17991:/* ARGSUSED */
        -:17992:static long int
function ar_member_date_1 called 0 returned 0% blocks executed 0%
    #####:17993:ar_member_date_1 (desc, mem, truncated,
        -:17994:		  hdrpos, datapos, size, date, uid, gid, mode, name)
        -:17995:     int desc;
        -:17996:     char *mem;
        -:17997:     int truncated;
        -:17998:     long int hdrpos, datapos, size, date;
        -:17999:     int uid, gid, mode;
        -:18000:     char *name;
        -:18001:{
    #####:18002:  return ar_name_equal (name, mem, truncated) ? date : 0;
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:18003:}
        -:18004:
        -:18005:/* Set the archive-member NAME's modtime to now.  */
        -:18006:
        -:18007:#ifdef VMS
        -:18008:int
        -:18009:ar_touch (name)
        -:18010:     char *name;
        -:18011:{
        -:18012:  error ("touch archive member is not available on VMS");
        -:18013:  return -1;
        -:18014:}
        -:18015:#else
        -:18016:int
function ar_touch called 0 returned 0% blocks executed 0%
    #####:18017:ar_touch (name)
        -:18018:     char *name;
        -:18019:{
        -:18020:  char *arname, *memname;
    #####:18021:  int arname_used = 0;
        -:18022:  register int val;
        -:18023:
    #####:18024:  ar_parse_name (name, &arname, &memname);
call    0 never executed
        -:18025:
        -:18026:  /* Make sure we know the modtime of the archive itself before we
        -:18027:     touch the member, since this will change the archive itself.  */
        -:18028:  {
        -:18029:    struct file *arfile;
    #####:18030:    arfile = lookup_file (arname);
call    0 never executed
    #####:18031:    if (arfile == 0)
branch  0 never executed
branch  1 never executed
        -:18032:      {
    #####:18033:	arfile = enter_file (arname);
call    0 never executed
    #####:18034:	arname_used = 1;
        -:18035:      }
        -:18036:
    #####:18037:    (void) f_mtime (arfile, 0);
call    0 never executed
        -:18038:  }
        -:18039:
    #####:18040:  val = 1;
    #####:18041:  switch (ar_member_touch (arname, memname))
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
        -:18042:    {
    #####:18043:    case -1:
    #####:18044:      error ("touch: Archive `%s' does not exist", arname);
call    0 never executed
    #####:18045:      break;
    #####:18046:    case -2:
    #####:18047:      error ("touch: `%s' is not a valid archive", arname);
call    0 never executed
    #####:18048:      break;
    #####:18049:    case -3:
    #####:18050:      perror_with_name ("touch: ", arname);
call    0 never executed
    #####:18051:      break;
    #####:18052:    case 1:
    #####:18053:      error ("touch: Member `%s' does not exist in `%s'", memname, arname);
call    0 never executed
    #####:18054:      break;
    #####:18055:    case 0:
    #####:18056:      val = 0;
    #####:18057:      break;
    #####:18058:    default:
    #####:18059:      error ("touch: Bad return code from ar_member_touch on `%s'", name);
call    0 never executed
        -:18060:    }
        -:18061:
    #####:18062:  if (!arname_used)
branch  0 never executed
branch  1 never executed
    #####:18063:    free (arname);
    #####:18064:  free (memname);
        -:18065:
    #####:18066:  return val;
        -:18067:}
        -:18068:#endif /* !VMS */
        -:18069:
        -:18070:/* State of an `ar_glob' run, passed to `ar_glob_match'.  */
        -:18071:
        -:18072:struct ar_glob_state
        -:18073:  {
        -:18074:    char *arname;
        -:18075:    char *pattern;
        -:18076:    unsigned int size;
        -:18077:    struct nameseq *chain;
        -:18078:    unsigned int n;
        -:18079:  };
        -:18080:
        -:18081:/* This function is called by `ar_scan' to match one archive
        -:18082:   element against the pattern in STATE.  */
        -:18083:
        -:18084:static long int
function ar_glob_match called 0 returned 0% blocks executed 0%
    #####:18085:ar_glob_match (desc, mem, truncated,
        -:18086:	       hdrpos, datapos, size, date, uid, gid, mode,
        -:18087:	       state)
        -:18088:     int desc;
        -:18089:     char *mem;
        -:18090:     int truncated;
        -:18091:     long int hdrpos, datapos, size, date;
        -:18092:     int uid, gid, mode;
        -:18093:     struct ar_glob_state *state;
        -:18094:{
    #####:18095:  if (fnmatch (state->pattern, mem, FNM_PATHNAME|FNM_PERIOD) == 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:18096:    {
        -:18097:      /* We have a match.  Add it to the chain.  */
    #####:18098:      struct nameseq *new = (struct nameseq *) xmalloc (state->size);
call    0 never executed
    #####:18099:      new->name = concat (state->arname, mem, ")");
call    0 never executed
    #####:18100:      new->next = state->chain;
    #####:18101:      state->chain = new;
    #####:18102:      ++state->n;
        -:18103:    }
        -:18104:
    #####:18105:  return 0L;
        -:18106:}
        -:18107:
        -:18108:/* Alphabetic sorting function for `qsort'.  */
        -:18109:
        -:18110:static int
function ar_glob_alphacompare called 0 returned 0% blocks executed 0%
    #####:18111:ar_glob_alphacompare (a, b)
        -:18112:     char **a, **b;
        -:18113:{
    #####:18114:  return strcmp (*a, *b);
        -:18115:}
        -:18116:
        -:18117:/* Return nonzero if PATTERN contains any metacharacters.
        -:18118:   Metacharacters can be quoted with backslashes if QUOTE is nonzero.  */
        -:18119:int
function glob_pattern_p called 0 returned 0% blocks executed 0%
    #####:18120:glob_pattern_p (pattern, quote)
        -:18121:     const char *pattern;
        -:18122:     const int quote;
        -:18123:{
        -:18124:  register const char *p;
    #####:18125:  int open = 0;
        -:18126:
    #####:18127:  for (p = pattern; *p != '\0'; ++p)
branch  0 never executed
branch  1 never executed
    #####:18128:    switch (*p)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -:18129:      {
    #####:18130:      case '?':
        -:18131:      case '*':
    #####:18132:	return 1;
        -:18133:
    #####:18134:      case '\\':
    #####:18135:	if (quote)
branch  0 never executed
branch  1 never executed
    #####:18136:	  ++p;
    #####:18137:	break;
        -:18138:
    #####:18139:      case '[':
    #####:18140:	open = 1;
    #####:18141:	break;
        -:18142:
    #####:18143:      case ']':
    #####:18144:	if (open)
branch  0 never executed
branch  1 never executed
    #####:18145:	  return 1;
    #####:18146:	break;
        -:18147:      }
        -:18148:
    #####:18149:  return 0;
        -:18150:}
        -:18151:
        -:18152:/* Glob for MEMBER_PATTERN in archive ARNAME.
        -:18153:   Return a malloc'd chain of matching elements (or nil if none).  */
        -:18154:
        -:18155:struct nameseq *
function ar_glob called 0 returned 0% blocks executed 0%
    #####:18156:ar_glob (arname, member_pattern, size)
        -:18157:     char *arname, *member_pattern;
        -:18158:     unsigned int size;
        -:18159:{
        -:18160:  struct ar_glob_state state;
        -:18161:  char **names;
        -:18162:  struct nameseq *n;
        -:18163:  unsigned int i;
        -:18164:
    #####:18165:  if (! glob_pattern_p (member_pattern, 1))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:18166:    return 0;
        -:18167:
        -:18168:  /* Scan the archive for matches.
        -:18169:     ar_glob_match will accumulate them in STATE.chain.  */
    #####:18170:  i = strlen (arname);
    #####:18171:  state.arname = (char *) alloca (i + 2);
    #####:18172:  bcopy (arname, state.arname, i);
    #####:18173:  state.arname[i] = '(';
    #####:18174:  state.arname[i + 1] = '\0';
    #####:18175:  state.pattern = member_pattern;
    #####:18176:  state.size = size;
    #####:18177:  state.chain = 0;
    #####:18178:  state.n = 0;
    #####:18179:  (void) ar_scan (arname, ar_glob_match, (long int) &state);
call    0 never executed
        -:18180:
    #####:18181:  if (state.chain == 0)
branch  0 never executed
branch  1 never executed
    #####:18182:    return 0;
        -:18183:
        -:18184:  /* Now put the names into a vector for sorting.  */
    #####:18185:  names = (char **) alloca (state.n * sizeof (char *));
    #####:18186:  i = 0;
    #####:18187:  for (n = state.chain; n != 0; n = n->next)
branch  0 never executed
branch  1 never executed
    #####:18188:    names[i++] = n->name;
        -:18189:
        -:18190:  /* Sort them alphabetically.  */
    #####:18191:  qsort ((char *) names, i, sizeof (*names), ar_glob_alphacompare);
call    0 never executed
        -:18192:
        -:18193:  /* Put them back into the chain in the sorted order.  */
    #####:18194:  i = 0;
    #####:18195:  for (n = state.chain; n != 0; n = n->next)
branch  0 never executed
branch  1 never executed
    #####:18196:    n->name = names[i++];
        -:18197:
    #####:18198:  return state.chain;
        -:18199:}
        -:18200:
        -:18201:#endif	/* Not NO_ARCHIVES.  */
        -:18202:
        -:18203:
        -:18204:
        -:18205:/*************************************************************
        -:18206:  ============================================================
        -:18207:  ************************************************************
        -:18208:  ============================================================
        -:18209:  ************************************************************
        -:18210:                         arscan.c
        -:18211:  ************************************************************
        -:18212:  ============================================================
        -:18213:  ************************************************************
        -:18214:  ============================================================
        -:18215:  *************************************************************/
        -:18216:
        -:18217:/* Library function for scanning an archive file.
        -:18218:Copyright (C) 1987,89,91,92,93,94,95,97 Free Software Foundation, Inc.
        -:18219:
        -:18220:This program is free software; you can redistribute it and/or modify
        -:18221:it under the terms of the GNU General Public License as published by
        -:18222:the Free Software Foundation; either version 2, or (at your option)
        -:18223:any later version.
        -:18224:
        -:18225:This program is distributed in the hope that it will be useful,
        -:18226:but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:18227:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:18228:GNU General Public License for more details.
        -:18229:
        -:18230:You should have received a copy of the GNU General Public License
        -:18231:along with this program; if not, write to the Free Software
        -:18232:Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
        -:18233:
        -:18234:
        -:18235:
        -:18236:#ifdef HAVE_FCNTL_H
        -:18237:#include <fcntl.h>
        -:18238:#undef stderr
        -:18239:#define stderr stdout
        -:18240:#else
        -:18241:#include <sys/file.h>
        -:18242:#undef stderr
        -:18243:#define stderr stdout
        -:18244:#endif
        -:18245:
        -:18246:#ifndef	NO_ARCHIVES
        -:18247:
        -:18248:#ifdef VMS
        -:18249:#include <lbrdef.h>
        -:18250:#include <mhddef.h>
        -:18251:#include <credef.h>
        -:18252:#include <descrip.h>
        -:18253:#include <ctype.h>
        -:18254:#undef stderr
        -:18255:#define stderr stdout
        -:18256:#if __DECC
        -:18257:#include <unixlib.h>
        -:18258:#include <lbr$routines.h>
        -:18259:#undef stderr
        -:18260:#define stderr stdout
        -:18261:#endif
        -:18262:
        -:18263:#define uppercasify(str) {char *str1; for (str1 = str; *str1; str1++) *str1 = _toupper(*str1);}
        -:18264:
        -:18265:static void *VMS_lib_idx;
        -:18266:
        -:18267:static char *VMS_saved_memname;
        -:18268:
        -:18269:static time_t VMS_member_date;
        -:18270:
        -:18271:static long int (*VMS_function) ();
        -:18272:
        -:18273:static int
        -:18274:VMS_get_member_info (module, rfa)
        -:18275:     struct dsc$descriptor_s *module;
        -:18276:     unsigned long *rfa;
        -:18277:{
        -:18278:  int status, i;
        -:18279:  long int fnval;
        -:18280:
        -:18281:  time_t val;
        -:18282:
        -:18283:  static struct dsc$descriptor_s bufdesc =
        -:18284:    { 0, DSC$K_DTYPE_T, DSC$K_CLASS_S, NULL };
        -:18285:
        -:18286:  struct mhddef *mhd;
        -:18287:  char filename[128];
        -:18288:
        -:18289:  bufdesc.dsc$a_pointer = filename;
        -:18290:  bufdesc.dsc$w_length = sizeof (filename);
        -:18291:
        -:18292:  status = lbr$set_module (&VMS_lib_idx, rfa, &bufdesc,
        -:18293:			   &bufdesc.dsc$w_length, 0);
        -:18294:  if (! status)
        -:18295:    {
        -:18296:      error ("lbr$set_module failed to extract module info, status = %d",
        -:18297:	     status);
        -:18298:
        -:18299:      lbr$close (&VMS_lib_idx);
        -:18300:
        -:18301:      return 0;
        -:18302:    }
        -:18303:
        -:18304:  mhd = (struct mhddef *) filename;
        -:18305:
        -:18306:  val = decc$fix_time (&mhd->mhd$l_datim);
        -:18307:
        -:18308:  for (i = 0; i < module->dsc$w_length; i++)
        -:18309:    filename[i] = _tolower (module->dsc$a_pointer[i]);
        -:18310:
        -:18311:  filename[i] = '\0';
        -:18312:
        -:18313:  VMS_member_date = (time_t) -1;
        -:18314:
        -:18315:  fnval =
        -:18316:    (*VMS_function) (-1, filename, 0, 0, 0, 0, val, 0, 0, 0,
        -:18317:		     VMS_saved_memname);
        -:18318:
        -:18319:  if (fnval)
        -:18320:    {
        -:18321:      VMS_member_date = fnval;
        -:18322:      return 0;
        -:18323:    }
        -:18324:  else
        -:18325:    return 1;
        -:18326:}
        -:18327:
        -:18328:/* Takes three arguments ARCHIVE, FUNCTION and ARG.
        -:18329:
        -:18330:   Open the archive named ARCHIVE, find its members one by one,
        -:18331:   and for each one call FUNCTION with the following arguments:
        -:18332:     archive file descriptor for reading the data,
        -:18333:     member name,
        -:18334:     member name might be truncated flag,
        -:18335:     member header position in file,
        -:18336:     member data position in file,
        -:18337:     member data size,
        -:18338:     member date,
        -:18339:     member uid,
        -:18340:     member gid,
        -:18341:     member protection mode,
        -:18342:     ARG.
        -:18343:
        -:18344:   NOTE: on VMS systems, only name, date, and arg are meaningful!
        -:18345:
        -:18346:   The descriptor is poised to read the data of the member
        -:18347:   when FUNCTION is called.  It does not matter how much
        -:18348:   data FUNCTION reads.
        -:18349:
        -:18350:   If FUNCTION returns nonzero, we immediately return
        -:18351:   what FUNCTION returned.
        -:18352:
        -:18353:   Returns -1 if archive does not exist,
        -:18354:   Returns -2 if archive has invalid format.
        -:18355:   Returns 0 if have scanned successfully.  */
        -:18356:
        -:18357:long int
        -:18358:ar_scan (archive, function, arg)
        -:18359:     char *archive;
        -:18360:     long int (*function) ();
        -:18361:     long int arg;
        -:18362:{
        -:18363:  char *p;
        -:18364:
        -:18365:  static struct dsc$descriptor_s libdesc =
        -:18366:    { 0, DSC$K_DTYPE_T, DSC$K_CLASS_S, NULL };
        -:18367:
        -:18368:  unsigned long func = LBR$C_READ;
        -:18369:  unsigned long type = LBR$C_TYP_UNK;
        -:18370:  unsigned long index = 1;
        -:18371:
        -:18372:  int status;
        -:18373:
        -:18374:  status = lbr$ini_control (&VMS_lib_idx, &func, &type, 0);
        -:18375:
        -:18376:  if (! status)
        -:18377:    {
        -:18378:      error ("lbr$ini_control failed with status = %d",status);
        -:18379:      return -2;
        -:18380:    }
        -:18381:
        -:18382:  libdesc.dsc$a_pointer = archive;
        -:18383:  libdesc.dsc$w_length = strlen (archive);
        -:18384:
        -:18385:  status = lbr$open (&VMS_lib_idx, &libdesc, 0, 0, 0, 0, 0);
        -:18386:
        -:18387:  if (! status)
        -:18388:    {
        -:18389:      error ("unable to open library `%s' to lookup member `%s'",
        -:18390:	     archive, (char *)arg);
        -:18391:      return -1;
        -:18392:    }
        -:18393:
        -:18394:  VMS_saved_memname = (char *)arg;
        -:18395:
        -:18396:  /* For comparison, delete .obj from arg name.  */
        -:18397:
        -:18398:  p = rindex (VMS_saved_memname, '.');
        -:18399:  if (p)
        -:18400:    *p = '\0';
        -:18401:
        -:18402:  VMS_function = function;
        -:18403:
        -:18404:  lbr$get_index (&VMS_lib_idx, &index, VMS_get_member_info, 0);
        -:18405:
        -:18406:  /* Undo the damage.  */
        -:18407:  if (p)
        -:18408:    *p = '.';
        -:18409:
        -:18410:  lbr$close (&VMS_lib_idx);
        -:18411:
        -:18412:  return VMS_member_date > 0 ? VMS_member_date : 0;
        -:18413:}
        -:18414:
        -:18415:#else /* !VMS */
        -:18416:
        -:18417:/* SCO Unix's compiler defines both of these.  */
        -:18418:#ifdef	M_UNIX
        -:18419:#undef	M_XENIX
        -:18420:#endif
        -:18421:
        -:18422:/* On the sun386i and in System V rel 3, ar.h defines two different archive
        -:18423:   formats depending upon whether you have defined PORTAR (normal) or PORT5AR
        -:18424:   (System V Release 1).  There is no default, one or the other must be defined
        -:18425:   to have a nonzero value.  */
        -:18426:
        -:18427:#if (!defined (PORTAR) || PORTAR == 0) && (!defined (PORT5AR) || PORT5AR == 0)
        -:18428:#undef	PORTAR
        -:18429:#ifdef M_XENIX
        -:18430:/* According to Jim Sievert <jas1@rsvl.unisys.com>, for SCO XENIX defining
        -:18431:   PORTAR to 1 gets the wrong archive format, and defining it to 0 gets the
        -:18432:   right one.  */
        -:18433:#define PORTAR 0
        -:18434:#else
        -:18435:#define PORTAR 1
        -:18436:#endif
        -:18437:#endif
        -:18438:
        -:18439:#include <ar.h>
        -:18440:#undef stderr
        -:18441:#define stderr stdout
        -:18442:
        -:18443:/* Cray's <ar.h> apparently defines this.  */
        -:18444:#ifndef	AR_HDR_SIZE
        -:18445:#define	AR_HDR_SIZE	(sizeof (struct ar_hdr))
        -:18446:#endif
        -:18447:
        -:18448:/* Takes three arguments ARCHIVE, FUNCTION and ARG.
        -:18449:
        -:18450:   Open the archive named ARCHIVE, find its members one by one,
        -:18451:   and for each one call FUNCTION with the following arguments:
        -:18452:     archive file descriptor for reading the data,
        -:18453:     member name,
        -:18454:     member name might be truncated flag,
        -:18455:     member header position in file,
        -:18456:     member data position in file,
        -:18457:     member data size,
        -:18458:     member date,
        -:18459:     member uid,
        -:18460:     member gid,
        -:18461:     member protection mode,
        -:18462:     ARG.
        -:18463:
        -:18464:   The descriptor is poised to read the data of the member
        -:18465:   when FUNCTION is called.  It does not matter how much
        -:18466:   data FUNCTION reads.
        -:18467:
        -:18468:   If FUNCTION returns nonzero, we immediately return
        -:18469:   what FUNCTION returned.
        -:18470:
        -:18471:   Returns -1 if archive does not exist,
        -:18472:   Returns -2 if archive has invalid format.
        -:18473:   Returns 0 if have scanned successfully.  */
        -:18474:
        -:18475:long int
function ar_scan called 0 returned 0% blocks executed 0%
    #####:18476:ar_scan (archive, function, arg)
        -:18477:     char *archive;
        -:18478:     long int (*function) ();
        -:18479:     long int arg;
        -:18480:{
        -:18481:#ifdef AIAMAG
        -:18482:  FL_HDR fl_header;
        -:18483:#else
    #####:18484:  int long_name = 0;
        -:18485:#endif
    #####:18486:  char *namemap = 0;
    #####:18487:  register int desc = open (archive, O_RDONLY, 0);
call    0 never executed
    #####:18488:  if (desc < 0)
branch  0 never executed
branch  1 never executed
    #####:18489:    return -1;
        -:18490:#ifdef SARMAG
        -:18491:  {
        -:18492:    char buf[SARMAG];
    #####:18493:    register int nread = read (desc, buf, SARMAG);
call    0 never executed
    #####:18494:    if (nread != SARMAG || bcmp (buf, ARMAG, SARMAG))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:18495:      {
    #####:18496:	(void) close (desc);
call    0 never executed
    #####:18497:	return -2;
        -:18498:      }
        -:18499:  }
        -:18500:#else
        -:18501:#ifdef AIAMAG
        -:18502:  {
        -:18503:    register int nread = read (desc, (char *) &fl_header, FL_HSZ);
        -:18504:    if (nread != FL_HSZ || bcmp (fl_header.fl_magic, AIAMAG, SAIAMAG))
        -:18505:      {
        -:18506:	(void) close (desc);
        -:18507:	return -2;
        -:18508:      }
        -:18509:  }
        -:18510:#else
        -:18511:  {
        -:18512:#ifndef M_XENIX
        -:18513:    int buf;
        -:18514:#else
        -:18515:    unsigned short int buf;
        -:18516:#endif
        -:18517:    register int nread = read(desc, &buf, sizeof (buf));
        -:18518:    if (nread != sizeof (buf) || buf != ARMAG)
        -:18519:      {
        -:18520:	(void) close (desc);
        -:18521:	return -2;
        -:18522:      }
        -:18523:  }
        -:18524:#endif
        -:18525:#endif
        -:18526:
        -:18527:  /* Now find the members one by one.  */
        -:18528:  {
        -:18529:#ifdef SARMAG
    #####:18530:    register long int member_offset = SARMAG;
        -:18531:#else
        -:18532:#ifdef AIAMAG
        -:18533:    long int member_offset;
        -:18534:    long int last_member_offset;
        -:18535:
        -:18536:    sscanf (fl_header.fl_fstmoff, "%12ld", &member_offset);
        -:18537:    sscanf (fl_header.fl_lstmoff, "%12ld", &last_member_offset);
        -:18538:
        -:18539:    if (member_offset == 0)
        -:18540:      {
        -:18541:	/* Empty archive.  */
        -:18542:	close (desc);
        -:18543:	return 0;
        -:18544:      }
        -:18545:#else
        -:18546:#ifndef	M_XENIX
        -:18547:    register long int member_offset = sizeof (int);
        -:18548:#else	/* Xenix.  */
        -:18549:    register long int member_offset = sizeof (unsigned short int);
        -:18550:#endif	/* Not Xenix.  */
        -:18551:#endif
        -:18552:#endif
        -:18553:
        -:18554:    while (1)
    #####:18555:      {
        -:18556:	register int nread;
        -:18557:	struct ar_hdr member_header;
        -:18558:#ifdef AIAMAG
        -:18559:	char name[256];
        -:18560:	int name_len;
        -:18561:	long int dateval;
        -:18562:	int uidval, gidval;
        -:18563:	long int data_offset;
        -:18564:#else
        -:18565:	char namebuf[sizeof member_header.ar_name + 1];
        -:18566:	char *name;
        -:18567:	int is_namemap;		/* Nonzero if this entry maps long names.  */
        -:18568:#endif
        -:18569:	long int eltsize;
        -:18570:	int eltmode;
        -:18571:	long int fnval;
        -:18572:
    #####:18573:	if (off_t_equal(off_t_to_int(lseek (desc, int_to_off_t(member_offset), 0)), ZERO_off_t) < 0)
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -:18574:	  /*	if (lseek (desc, member_offset, 0) < 0) */
        -:18575:	  {
    #####:18576:	    (void) close (desc);
call    0 never executed
    #####:18577:	    return -2;
        -:18578:	  }
        -:18579:
        -:18580:#ifdef AIAMAG
        -:18581:#define	AR_MEMHDR	(AR_HDR_SIZE - sizeof (member_header._ar_name))
        -:18582:	nread = read (desc, (char *) &member_header, AR_MEMHDR);
        -:18583:
        -:18584:	if (nread != AR_MEMHDR)
        -:18585:	  {
        -:18586:	    (void) close (desc);
        -:18587:	    return -2;
        -:18588:	  }
        -:18589:
        -:18590:	sscanf (member_header.ar_namlen, "%4d", &name_len);
        -:18591:	nread = read (desc, name, name_len);
        -:18592:
        -:18593:	if (nread != name_len)
        -:18594:	  {
        -:18595:	    (void) close (desc);
        -:18596:	    return -2;
        -:18597:	  }
        -:18598:
        -:18599:	name[name_len] = 0;
        -:18600:
        -:18601:	sscanf (member_header.ar_date, "%12ld", &dateval);
        -:18602:	sscanf (member_header.ar_uid, "%12d", &uidval);
        -:18603:	sscanf (member_header.ar_gid, "%12d", &gidval);
        -:18604:	sscanf (member_header.ar_mode, "%12o", &eltmode);
        -:18605:	sscanf (member_header.ar_size, "%12ld", &eltsize);
        -:18606:
        -:18607:	if ((data_offset = member_offset + AR_MEMHDR + name_len + 2) % 2)
        -:18608:	    ++data_offset;
        -:18609:
        -:18610:	fnval =
        -:18611:	  (*function) (desc, name, 0,
        -:18612:		       member_offset, data_offset, eltsize,
        -:18613:		       dateval, uidval, gidval,
        -:18614:		       eltmode, arg);
        -:18615:
        -:18616:#else	/* Not AIAMAG.  */
    #####:18617:	nread = read (desc, (char *) &member_header, AR_HDR_SIZE);
call    0 never executed
    #####:18618:	if (nread == 0)
branch  0 never executed
branch  1 never executed
        -:18619:	  /* No data left means end of file; that is OK.  */
    #####:18620:	  break;
        -:18621:
    #####:18622:	if (nread != AR_HDR_SIZE
branch  0 never executed
branch  1 never executed
        -:18623:#ifdef ARFMAG
    #####:18624:	    || bcmp (member_header.ar_fmag, ARFMAG, 2)
branch  0 never executed
branch  1 never executed
        -:18625:#endif
        -:18626:	    )
        -:18627:	  {
    #####:18628:	    (void) close (desc);
call    0 never executed
    #####:18629:	    return -2;
        -:18630:	  }
        -:18631:
    #####:18632:	name = namebuf;
    #####:18633:	bcopy (member_header.ar_name, name, sizeof member_header.ar_name);
        -:18634:	{
    #####:18635:	  register char *p = name + sizeof member_header.ar_name;
        -:18636:	  do
    #####:18637:	    *p = '\0';
    #####:18638:	  while (p > name && *--p == ' ');
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:18639:
        -:18640:#ifndef AIAMAG
        -:18641:	  /* If the member name is "//" or "ARFILENAMES/" this may be
        -:18642:	     a list of file name mappings.  The maximum file name
        -:18643: 	     length supported by the standard archive format is 14
        -:18644: 	     characters.  This member will actually always be the
        -:18645: 	     first or second entry in the archive, but we don't check
        -:18646: 	     that.  */
    #####:18647: 	  is_namemap = (!strcmp (name, "//")
    #####:18648:			|| !strcmp (name, "ARFILENAMES/"));
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:18649:#endif	/* Not AIAMAG. */
        -:18650:	  /* On some systems, there is a slash after each member name.  */
    #####:18651:	  if (*p == '/')
branch  0 never executed
branch  1 never executed
    #####:18652:	    *p = '\0';
        -:18653:
        -:18654:#ifndef AIAMAG
        -:18655: 	  /* If the member name starts with a space or a slash, this
        -:18656: 	     is an index into the file name mappings (used by GNU ar).
        -:18657: 	     Otherwise if the member name looks like #1/NUMBER the
        -:18658: 	     real member name appears in the element data (used by
        -:18659: 	     4.4BSD).  */
    #####:18660: 	  if (! is_namemap
branch  0 never executed
branch  1 never executed
    #####:18661: 	      && (name[0] == ' ' || name[0] == '/')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:18662: 	      && namemap != 0)
branch  0 never executed
branch  1 never executed
        -:18663:	    {
    #####:18664:	      name = namemap + atoi (name + 1);
    #####:18665:	      long_name = 1;
        -:18666:	    }
    #####:18667: 	  else if (name[0] == '#'
branch  0 never executed
branch  1 never executed
    #####:18668: 		   && name[1] == '1'
branch  0 never executed
branch  1 never executed
    #####:18669: 		   && name[2] == '/')
branch  0 never executed
branch  1 never executed
        -:18670: 	    {
    #####:18671: 	      int namesize = atoi (name + 3);
        -:18672:
    #####:18673: 	      name = (char *) alloca (namesize + 1);
    #####:18674: 	      nread = read (desc, name, namesize);
call    0 never executed
    #####:18675: 	      if (nread != namesize)
branch  0 never executed
branch  1 never executed
        -:18676: 		{
    #####:18677: 		  close (desc);
call    0 never executed
    #####:18678: 		  return -2;
        -:18679: 		}
    #####:18680: 	      name[namesize] = '\0';
        -:18681:
    #####:18682:	      long_name = 1;
        -:18683: 	    }
        -:18684:#endif /* Not AIAMAG. */
        -:18685:	}
        -:18686:
        -:18687:#ifndef	M_XENIX
    #####:18688:	sscanf (member_header.ar_mode, "%o", &eltmode);
    #####:18689:	eltsize = atol (member_header.ar_size);
        -:18690:#else	/* Xenix.  */
        -:18691:	eltmode = (unsigned short int) member_header.ar_mode;
        -:18692:	eltsize = member_header.ar_size;
        -:18693:#endif	/* Not Xenix.  */
        -:18694:
        -:18695:	fnval =
    #####:18696:	  (*function) (desc, name, ! long_name, member_offset,
call    0 never executed
        -:18697:		       member_offset + AR_HDR_SIZE, eltsize,
        -:18698:#ifndef	M_XENIX
        -:18699:		       atol (member_header.ar_date),
        -:18700:		       atoi (member_header.ar_uid),
        -:18701:		       atoi (member_header.ar_gid),
        -:18702:#else	/* Xenix.  */
        -:18703:		       member_header.ar_date,
        -:18704:		       member_header.ar_uid,
        -:18705:		       member_header.ar_gid,
        -:18706:#endif	/* Not Xenix.  */
        -:18707:		       eltmode, arg);
        -:18708:
        -:18709:#endif  /* AIAMAG.  */
        -:18710:
    #####:18711:	if (fnval)
branch  0 never executed
branch  1 never executed
        -:18712:	  {
    #####:18713:	    (void) close (desc);
call    0 never executed
    #####:18714:	    return fnval;
        -:18715:	  }
        -:18716:
        -:18717:#ifdef AIAMAG
        -:18718:	if (member_offset == last_member_offset)
        -:18719:	  /* End of the chain.  */
        -:18720:	  break;
        -:18721:
        -:18722:	sscanf (member_header.ar_nxtmem, "%12ld", &member_offset);
        -:18723:
        -:18724:	if (lseek (desc, member_offset, 0) != member_offset)
        -:18725:	  {
        -:18726:	    (void) close (desc);
        -:18727:	    return -2;
        -:18728:	  }
        -:18729:#else
        -:18730:
        -:18731: 	/* If this member maps archive names, we must read it in.  The
        -:18732: 	   name map will always precede any members whose names must
        -:18733: 	   be mapped.  */
    #####:18734:	if (is_namemap)
branch  0 never executed
branch  1 never executed
        -:18735: 	  {
        -:18736: 	    char *clear;
        -:18737: 	    char *limit;
        -:18738:
    #####:18739: 	    namemap = (char *) alloca (eltsize);
    #####:18740: 	    nread = read (desc, namemap, eltsize);
call    0 never executed
    #####:18741: 	    if (nread != eltsize)
branch  0 never executed
branch  1 never executed
        -:18742: 	      {
    #####:18743: 		(void) close (desc);
call    0 never executed
    #####:18744: 		return -2;
        -:18745: 	      }
        -:18746:
        -:18747: 	    /* The names are separated by newlines.  Some formats have
        -:18748: 	       a trailing slash.  Null terminate the strings for
        -:18749: 	       convenience.  */
    #####:18750: 	    limit = namemap + eltsize;
    #####:18751: 	    for (clear = namemap; clear < limit; clear++)
branch  0 never executed
branch  1 never executed
        -:18752: 	      {
    #####:18753: 		if (*clear == '\n')
branch  0 never executed
branch  1 never executed
        -:18754: 		  {
    #####:18755: 		    *clear = '\0';
    #####:18756: 		    if (clear[-1] == '/')
branch  0 never executed
branch  1 never executed
    #####:18757: 		      clear[-1] = '\0';
        -:18758: 		  }
        -:18759: 	      }
        -:18760:
    #####:18761:	    is_namemap = 0;
        -:18762: 	  }
        -:18763:
    #####:18764:	member_offset += AR_HDR_SIZE + eltsize;
    #####:18765:	if (member_offset % 2 != 0)
branch  0 never executed
branch  1 never executed
    #####:18766:	  member_offset++;
        -:18767:#endif
        -:18768:      }
        -:18769:  }
        -:18770:
    #####:18771:  close (desc);
call    0 never executed
    #####:18772:  return 0;
        -:18773:}
        -:18774:#endif /* !VMS */
        -:18775:
        -:18776:/* Return nonzero iff NAME matches MEM.
        -:18777:   If TRUNCATED is nonzero, MEM may be truncated to
        -:18778:   sizeof (struct ar_hdr.ar_name) - 1.  */
        -:18779:
        -:18780:int
function ar_name_equal called 0 returned 0% blocks executed 0%
    #####:18781:ar_name_equal (name, mem, truncated)
        -:18782:     char *name, *mem;
        -:18783:     int truncated;
        -:18784:{
        -:18785:  char *p;
        -:18786:
    #####:18787:  p = rindex (name, '/');
    #####:18788:  if (p != 0)
branch  0 never executed
branch  1 never executed
    #####:18789:    name = p + 1;
        -:18790:
        -:18791:  /* We no longer use this kludge, since we
        -:18792:     now support long archive member names.  */
        -:18793:
        -:18794:#if 0 && !defined (AIAMAG) && !defined (APOLLO)
        -:18795:
        -:18796:  {
        -:18797:    /* `reallylongname.o' matches `reallylongnam.o'.
        -:18798:       If member names have a trailing slash, that's `reallylongna.o'.  */
        -:18799:
        -:18800:    struct ar_hdr h;
        -:18801:    unsigned int max = sizeof (h.ar_name);
        -:18802:    unsigned int namelen, memlen;
        -:18803:
        -:18804:    if (strncmp (name, mem, max - 3))
        -:18805:      return 0;
        -:18806:
        -:18807:    namelen = strlen (name);
        -:18808:    memlen = strlen (mem);
        -:18809:
        -:18810:    if (namelen > memlen && memlen >= max - 1
        -:18811:	&& name[namelen - 2] == '.' && name[namelen - 1] == 'o'
        -:18812:	&& mem[memlen - 2] == '.' && mem[memlen - 1] == 'o')
        -:18813:      return 1;
        -:18814:
        -:18815:    if (namelen != memlen)
        -:18816:      return 0;
        -:18817:
        -:18818:    return (namelen < max - 3 || !strcmp (name + max - 3, mem + max - 3));
        -:18819:  }
        -:18820:
        -:18821:#else	/* AIX or APOLLO.  */
        -:18822:#ifndef VMS
    #####:18823:  if (truncated)
branch  0 never executed
branch  1 never executed
        -:18824:    {
        -:18825:#ifdef AIAMAG
        -:18826:      /* TRUNCATED should never be set on this system.  */
        -:18827:      abort ();
        -:18828:#else
        -:18829:      struct ar_hdr hdr;
        -:18830:#if !defined (__hpux) && !defined (cray)
    #####:18831:      return !strncmp (name, mem, sizeof(hdr.ar_name) - 1);
        -:18832:#else
        -:18833:      return !strncmp (name, mem, sizeof(hdr.ar_name) - 2);
        -:18834:#endif /* !__hpux && !cray */
        -:18835:#endif /* !AIAMAG */
        -:18836:    }
        -:18837:#endif /* !VMS */
        -:18838:
    #####:18839:  return !strcmp (name, mem);
        -:18840:
        -:18841:#endif
        -:18842:}
        -:18843:
        -:18844:#ifndef VMS
        -:18845:/* ARGSUSED */
        -:18846:static long int
function ar_member_pos called 0 returned 0% blocks executed 0%
    #####:18847:ar_member_pos (desc, mem, truncated,
        -:18848:	       hdrpos, datapos, size, date, uid, gid, mode, name)
        -:18849:     int desc;
        -:18850:     char *mem;
        -:18851:     int truncated;
        -:18852:     long int hdrpos, datapos, size, date;
        -:18853:     int uid, gid, mode;
        -:18854:     char *name;
        -:18855:{
    #####:18856:  if (!ar_name_equal (name, mem, truncated))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:18857:    return 0;
    #####:18858:  return hdrpos;
        -:18859:}
        -:18860:
        -:18861:/* Set date of member MEMNAME in archive ARNAME to current time.
        -:18862:   Returns 0 if successful,
        -:18863:   -1 if file ARNAME does not exist,
        -:18864:   -2 if not a valid archive,
        -:18865:   -3 if other random system call error (including file read-only),
        -:18866:   1 if valid but member MEMNAME does not exist.  */
        -:18867:
        -:18868:int
function ar_member_touch called 0 returned 0% blocks executed 0%
    #####:18869:ar_member_touch (arname, memname)
        -:18870:     char *arname, *memname;
        -:18871:{
    #####:18872:  register long int pos = ar_scan (arname, ar_member_pos, (long int) memname);
call    0 never executed
        -:18873:  register int fd;
        -:18874:  struct ar_hdr ar_hdr;
        -:18875:  register int i;
        -:18876:  struct stat statbuf;
        -:18877:
    #####:18878:  if (pos < 0)
branch  0 never executed
branch  1 never executed
    #####:18879:    return (int) pos;
    #####:18880:  if (!pos)
branch  0 never executed
branch  1 never executed
    #####:18881:    return 1;
        -:18882:
    #####:18883:  fd = open (arname, O_RDWR, 0666);
call    0 never executed
    #####:18884:  if (fd < 0)
branch  0 never executed
branch  1 never executed
    #####:18885:    return -3;
        -:18886:  /* Read in this member's header */
        -:18887:
        -:18888:
    #####:18889:  if (off_t_equal(off_t_to_int(lseek (fd, int_to_off_t(pos), 0)), ZERO_off_t) < 0)
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -:18890:    /*  if (lseek (fd, pos, 0) < 0) */
    #####:18891:    goto lose;
    #####:18892:  if (AR_HDR_SIZE != read (fd, (char *) &ar_hdr, AR_HDR_SIZE))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:18893:    goto lose;
        -:18894:  /* Write back the header, thus touching the archive file.  */
    #####:18895:  if (off_t_equal(off_t_to_int(lseek (fd, int_to_off_t(pos), 0)), ZERO_off_t) < 0)
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -:18896:    /*  if (lseek (fd, pos, 0) < 0) */
    #####:18897:    goto lose;
    #####:18898:  if (AR_HDR_SIZE != write (fd, (char *) &ar_hdr, AR_HDR_SIZE))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:18899:    goto lose;
        -:18900:  /* The file's mtime is the time we we want.  */
        -:18901:#ifdef EINTR
    #####:18902:  while (fstat (fd, &statbuf) < 0 && errno == EINTR);
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -:18903:#else
        -:18904:  fstat (fd, &statbuf);
        -:18905:#endif
        -:18906:#if defined(ARFMAG) || defined(AIAMAG)
        -:18907:  /* Advance member's time to that time */
    #####:18908:  for (i = 0; i < sizeof ar_hdr.ar_date; i++)
branch  0 never executed
branch  1 never executed
    #####:18909:    ar_hdr.ar_date[i] = ' ';
    #####:18910:  sprintf (ar_hdr.ar_date, "%ld", (long int) statbuf.st_mtime);
        -:18911:#ifdef AIAMAG
        -:18912:  ar_hdr.ar_date[strlen(ar_hdr.ar_date)] = ' ';
        -:18913:#endif
        -:18914:#else
        -:18915:  ar_hdr.ar_date = statbuf.st_mtime;
        -:18916:#endif
        -:18917:  /* Write back this member's header */
    #####:18918:  if (off_t_equal(off_t_to_int(lseek (fd, int_to_off_t(pos), 0)), ZERO_off_t) < 0)
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -:18919:    /*  if (lseek (fd, pos, 0) < 0) */
    #####:18920:    goto lose;
    #####:18921:  if (AR_HDR_SIZE != write (fd, (char *) &ar_hdr, AR_HDR_SIZE))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:18922:    goto lose;
    #####:18923:  close (fd);
call    0 never executed
    #####:18924:  return 0;
        -:18925:
    #####:18926: lose:
    #####:18927:  i = errno;
    #####:18928:  close (fd);
call    0 never executed
    #####:18929:  errno = i;
    #####:18930:  return -3;
        -:18931:}
        -:18932:#endif
        -:18933:
        -:18934:#ifdef TEST
        -:18935:
        -:18936:long int
        -:18937:describe_member (desc, name, truncated,
        -:18938:		 hdrpos, datapos, size, date, uid, gid, mode)
        -:18939:     int desc;
        -:18940:     char *name;
        -:18941:     int truncated;
        -:18942:     long int hdrpos, datapos, size, date;
        -:18943:     int uid, gid, mode;
        -:18944:{
        -:18945:  extern char *ctime ();
        -:18946:
        -:18947:  printf ("Member `%s'%s: %ld bytes at %ld (%ld).\n",
        -:18948:	  name, truncated ? " (name might be truncated)" : "",
        -:18949:	  size, hdrpos, datapos);
        -:18950:  printf ("  Date %s", ctime (&date));
        -:18951:  printf ("  uid = %d, gid = %d, mode = 0%o.\n", uid, gid, mode);
        -:18952:
        -:18953:  return 0;
        -:18954:}
        -:18955:
        -:18956:main (argc, argv)
        -:18957:     int argc;
        -:18958:     char **argv;
        -:18959:{
        -:18960:  ar_scan (argv[1], describe_member);
        -:18961:  return 0;
        -:18962:}
        -:18963:
        -:18964:#endif	/* TEST.  */
        -:18965:
        -:18966:#endif	/* NO_ARCHIVES.  */
        -:18967:
        -:18968:
        -:18969:
        -:18970:
        -:18971:/*************************************************************
        -:18972:  ============================================================
        -:18973:  ************************************************************
        -:18974:  ============================================================
        -:18975:  ************************************************************
        -:18976:                         remote-stub.c
        -:18977:  ************************************************************
        -:18978:  ============================================================
        -:18979:  ************************************************************
        -:18980:  ============================================================
        -:18981:  *************************************************************/
        -:18982:
        -:18983:/* Template for the remote job exportation interface to GNU Make.
        -:18984:Copyright (C) 1988, 1989, 1992, 1993, 1996 Free Software Foundation, Inc.
        -:18985:This file is part of GNU Make.
        -:18986:
        -:18987:GNU Make is free software; you can redistribute it and/or modify
        -:18988:it under the terms of the GNU General Public License as published by
        -:18989:the Free Software Foundation; either version 2, or (at your option)
        -:18990:any later version.
        -:18991:
        -:18992:GNU Make is distributed in the hope that it will be useful,
        -:18993:but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:18994:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:18995:GNU General Public License for more details.
        -:18996:
        -:18997:You should have received a copy of the GNU General Public License
        -:18998:along with GNU Make; see the file COPYING.  If not, write to
        -:18999:the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
        -:19000:
        -:19001:
        -:19002:char *remote_description = 0;
        -:19003:
        -:19004:/* Call once at startup even if no commands are run.  */
        -:19005:
        -:19006:void
function remote_setup called 790 returned 100% blocks executed 100%
      790:19007:remote_setup ()
        -:19008:{
      790:19009:}
        -:19010:
        -:19011:/* Called before exit.  */
        -:19012:
        -:19013:void
function remote_cleanup called 793 returned 100% blocks executed 100%
      793:19014:remote_cleanup ()
        -:19015:{
      793:19016:}
        -:19017:
        -:19018:/* Return nonzero if the next job should be done remotely.  */
        -:19019:
        -:19020:int
function start_remote_job_p called 4 returned 100% blocks executed 100%
        4:19021:start_remote_job_p (first_p)
        -:19022:     int first_p;
        -:19023:{
        4:19024:  return 0;
        -:19025:}
        -:19026:
        -:19027:/* Start a remote job running the command in ARGV,
        -:19028:   with environment from ENVP.  It gets standard input from STDIN_FD.  On
        -:19029:   failure, return nonzero.  On success, return zero, and set *USED_STDIN
        -:19030:   to nonzero if it will actually use STDIN_FD, zero if not, set *ID_PTR to
        -:19031:   a unique identification, and set *IS_REMOTE to zero if the job is local,
        -:19032:   nonzero if it is remote (meaning *ID_PTR is a process ID).  */
        -:19033:
        -:19034:int
function start_remote_job called 0 returned 0% blocks executed 0%
    #####:19035:start_remote_job (argv, envp, stdin_fd, is_remote, id_ptr, used_stdin)
        -:19036:     char **argv, **envp;
        -:19037:     int stdin_fd;
        -:19038:     int *is_remote;
        -:19039:     int *id_ptr;
        -:19040:     int *used_stdin;
        -:19041:{
    #####:19042:  return -1;
        -:19043:}
        -:19044:
        -:19045:/* Get the status of a dead remote child.  Block waiting for one to die
        -:19046:   if BLOCK is nonzero.  Set *EXIT_CODE_PTR to the exit status, *SIGNAL_PTR
        -:19047:   to the termination signal or zero if it exited normally, and *COREDUMP_PTR
        -:19048:   nonzero if it dumped core.  Return the ID of the child that died,
        -:19049:   0 if we would have to block and !BLOCK, or < 0 if there were none.  */
        -:19050:
        -:19051:int
function remote_status called 0 returned 0% blocks executed 0%
    #####:19052:remote_status (exit_code_ptr, signal_ptr, coredump_ptr, block)
        -:19053:     int *exit_code_ptr, *signal_ptr, *coredump_ptr;
        -:19054:     int block;
        -:19055:{
    #####:19056:  errno = ECHILD;
    #####:19057:  return -1;
        -:19058:}
        -:19059:
        -:19060:/* Block asynchronous notification of remote child death.
        -:19061:   If this notification is done by raising the child termination
        -:19062:   signal, do not block that signal.  */
        -:19063:void
function block_remote_children called 0 returned 0% blocks executed 0%
    #####:19064:block_remote_children ()
        -:19065:{
    #####:19066:  return;
        -:19067:}
        -:19068:
        -:19069:/* Restore asynchronous notification of remote child death.
        -:19070:   If this is done by raising the child termination signal,
        -:19071:   do not unblock that signal.  */
        -:19072:void
function unblock_remote_children called 0 returned 0% blocks executed 0%
    #####:19073:unblock_remote_children ()
        -:19074:{
    #####:19075:  return;
        -:19076:}
        -:19077:
        -:19078:/* Send signal SIG to child ID.  Return 0 if successful, -1 if not.  */
        -:19079:int
function remote_kill called 0 returned 0% blocks executed 0%
    #####:19080:remote_kill (id, sig)
        -:19081:     int id;
        -:19082:     int sig;
        -:19083:{
    #####:19084:  return -1;
        -:19085:}
        -:19086:
        -:19087:
        -:19088:
        -:19089:/*************************************************************
        -:19090:  ============================================================
        -:19091:  ************************************************************
        -:19092:  ============================================================
        -:19093:  ************************************************************
        -:19094:                         signame.c
        -:19095:  ************************************************************
        -:19096:  ============================================================
        -:19097:  ************************************************************
        -:19098:  ============================================================
        -:19099:  *************************************************************/
        -:19100:
        -:19101:/* Convert between signal names and numbers.
        -:19102:   Copyright (C) 1990, 1992, 1993, 1995, 1996 Free Software Foundation, Inc.
        -:19103:   This file is part of the GNU C Library.
        -:19104:
        -:19105:   The GNU C Library is free software; you can redistribute it and/or
        -:19106:   modify it under the terms of the GNU Library General Public License as
        -:19107:   published by the Free Software Foundation; either version 2 of the
        -:19108:   License, or (at your option) any later version.
        -:19109:
        -:19110:   The GNU C Library is distributed in the hope that it will be useful,
        -:19111:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:19112:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
        -:19113:   Library General Public License for more details.
        -:19114:
        -:19115:   You should have received a copy of the GNU Library General Public
        -:19116:   License along with the GNU C Library; see the file COPYING.LIB.  If not,
        -:19117:   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
        -:19118:   Boston, MA 02111-1307, USA.  */
        -:19119:
        -:19120:#ifdef HAVE_CONFIG_H
        -:19121:#endif
        -:19122:
        -:19123:
        -:19124:
        -:19125:#ifdef HAVE_STRING_H
        -:19126:#include <string.h>
        -:19127:#undef stderr
        -:19128:#define stderr stdout
        -:19129:#endif
        -:19130:
        -:19131:/* Some systems declare `sys_siglist in <unistd.h>; if
        -:19132:   configure defined SYS_SIGLIST_DECLARED, it may expect
        -:19133:   to find the declaration there.  */
        -:19134:#ifdef HAVE_UNISTD_H
        -:19135:#include <unistd.h>
        -:19136:#undef stderr
        -:19137:#define stderr stdout
        -:19138:#endif
        -:19139:
        -:19140:
        -:19141:/* Some systems do not define NSIG in <signal.h>.  */
        -:19142:#ifndef	NSIG
        -:19143:#ifdef	_NSIG
        -:19144:#define	NSIG	_NSIG
        -:19145:#else
        -:19146:#define	NSIG	32
        -:19147:#endif
        -:19148:#endif
        -:19149:
        -:19150:#if !__STDC__
        -:19151:#define const
        -:19152:#endif
        -:19153:
        -:19154:
        -:19155:#ifndef HAVE_SYS_SIGLIST
        -:19156:/* There is too much variation in Sys V signal numbers and names, so
        -:19157:   we must initialize them at runtime.  */
        -:19158:
        -:19159:static const char undoc[] = "unknown signal";
        -:19160:
        -:19161:const char *sys_siglist[NSIG];
        -:19162:
        -:19163:#else	/* HAVE_SYS_SIGLIST.  */
        -:19164:
        -:19165:#ifndef SYS_SIGLIST_DECLARED
        -:19166:extern char *sys_siglist[];
        -:19167:#endif	/* Not SYS_SIGLIST_DECLARED.  */
        -:19168:
        -:19169:#endif	/* Not HAVE_SYS_SIGLIST.  */
        -:19170:
        -:19171:/* Table of abbreviations for signals.  Note:  A given number can
        -:19172:   appear more than once with different abbreviations.  */
        -:19173:typedef struct
        -:19174:  {
        -:19175:    int number;
        -:19176:    const char *abbrev;
        -:19177:  } num_abbrev;
        -:19178:static num_abbrev sig_table[NSIG*2];
        -:19179:/* Number of elements of sig_table used.  */
        -:19180:static int sig_table_nelts = 0;
        -:19181:
        -:19182:/* Enter signal number NUMBER into the tables with ABBREV and NAME.  */
        -:19183:
        -:19184:static void
function init_sig called 0 returned 0% blocks executed 0%
    #####:19185:init_sig (number, abbrev, name)
        -:19186:     int number;
        -:19187:     const char *abbrev;
        -:19188:     const char *name;
        -:19189:{
        -:19190:#ifndef HAVE_SYS_SIGLIST
    #####:19191:  sys_siglist[number] = name;
        -:19192:#endif
    #####:19193:  sig_table[sig_table_nelts].number = number;
    #####:19194:  sig_table[sig_table_nelts++].abbrev = abbrev;
    #####:19195:}
        -:19196:
        -:19197:void
function signame_init called 0 returned 0% blocks executed 0%
    #####:19198:signame_init ()
        -:19199:{
        -:19200:#ifndef HAVE_SYS_SIGLIST
        -:19201:  int i;
        -:19202:  /* Initialize signal names.  */
    #####:19203:  for (i = 0; i < NSIG; i++)
branch  0 never executed
branch  1 never executed
    #####:19204:    sys_siglist[i] = undoc;
        -:19205:#endif /* !HAVE_SYS_SIGLIST */
        -:19206:
        -:19207:  /* Initialize signal names.  */
        -:19208:#if defined (SIGHUP)
    #####:19209:  init_sig (SIGHUP, "HUP", "Hangup");
call    0 never executed
        -:19210:#endif
        -:19211:#if defined (SIGINT)
    #####:19212:  init_sig (SIGINT, "INT", "Interrupt");
call    0 never executed
        -:19213:#endif
        -:19214:#if defined (SIGQUIT)
    #####:19215:  init_sig (SIGQUIT, "QUIT", "Quit");
call    0 never executed
        -:19216:#endif
        -:19217:#if defined (SIGILL)
    #####:19218:  init_sig (SIGILL, "ILL", "Illegal Instruction");
call    0 never executed
        -:19219:#endif
        -:19220:#if defined (SIGTRAP)
    #####:19221:  init_sig (SIGTRAP, "TRAP", "Trace/breakpoint trap");
call    0 never executed
        -:19222:#endif
        -:19223:  /* If SIGIOT == SIGABRT, we want to print it as SIGABRT because
        -:19224:     SIGABRT is in ANSI and POSIX.1 and SIGIOT isn't.  */
        -:19225:#if defined (SIGABRT)
    #####:19226:  init_sig (SIGABRT, "ABRT", "Aborted");
call    0 never executed
        -:19227:#endif
        -:19228:#if defined (SIGIOT)
    #####:19229:  init_sig (SIGIOT, "IOT", "IOT trap");
call    0 never executed
        -:19230:#endif
        -:19231:#if defined (SIGEMT)
        -:19232:  init_sig (SIGEMT, "EMT", "EMT trap");
        -:19233:#endif
        -:19234:#if defined (SIGFPE)
    #####:19235:  init_sig (SIGFPE, "FPE", "Floating point exception");
call    0 never executed
        -:19236:#endif
        -:19237:#if defined (SIGKILL)
    #####:19238:  init_sig (SIGKILL, "KILL", "Killed");
call    0 never executed
        -:19239:#endif
        -:19240:#if defined (SIGBUS)
    #####:19241:  init_sig (SIGBUS, "BUS", "Bus error");
call    0 never executed
        -:19242:#endif
        -:19243:#if defined (SIGSEGV)
    #####:19244:  init_sig (SIGSEGV, "SEGV", "Segmentation fault");
call    0 never executed
        -:19245:#endif
        -:19246:#if defined (SIGSYS)
    #####:19247:  init_sig (SIGSYS, "SYS", "Bad system call");
call    0 never executed
        -:19248:#endif
        -:19249:#if defined (SIGPIPE)
    #####:19250:  init_sig (SIGPIPE, "PIPE", "Broken pipe");
call    0 never executed
        -:19251:#endif
        -:19252:#if defined (SIGALRM)
    #####:19253:  init_sig (SIGALRM, "ALRM", "Alarm clock");
call    0 never executed
        -:19254:#endif
        -:19255:#if defined (SIGTERM)
    #####:19256:  init_sig (SIGTERM, "TERM", "Terminated");
call    0 never executed
        -:19257:#endif
        -:19258:#if defined (SIGUSR1)
    #####:19259:  init_sig (SIGUSR1, "USR1", "User defined signal 1");
call    0 never executed
        -:19260:#endif
        -:19261:#if defined (SIGUSR2)
    #####:19262:  init_sig (SIGUSR2, "USR2", "User defined signal 2");
call    0 never executed
        -:19263:#endif
        -:19264:  /* If SIGCLD == SIGCHLD, we want to print it as SIGCHLD because that
        -:19265:     is what is in POSIX.1.  */
        -:19266:#if defined (SIGCHLD)
    #####:19267:  init_sig (SIGCHLD, "CHLD", "Child exited");
call    0 never executed
        -:19268:#endif
        -:19269:#if defined (SIGCLD)
    #####:19270:  init_sig (SIGCLD, "CLD", "Child exited");
call    0 never executed
        -:19271:#endif
        -:19272:#if defined (SIGPWR)
    #####:19273:  init_sig (SIGPWR, "PWR", "Power failure");
call    0 never executed
        -:19274:#endif
        -:19275:#if defined (SIGTSTP)
    #####:19276:  init_sig (SIGTSTP, "TSTP", "Stopped");
call    0 never executed
        -:19277:#endif
        -:19278:#if defined (SIGTTIN)
    #####:19279:  init_sig (SIGTTIN, "TTIN", "Stopped (tty input)");
call    0 never executed
        -:19280:#endif
        -:19281:#if defined (SIGTTOU)
    #####:19282:  init_sig (SIGTTOU, "TTOU", "Stopped (tty output)");
call    0 never executed
        -:19283:#endif
        -:19284:#if defined (SIGSTOP)
    #####:19285:  init_sig (SIGSTOP, "STOP", "Stopped (signal)");
call    0 never executed
        -:19286:#endif
        -:19287:#if defined (SIGXCPU)
    #####:19288:  init_sig (SIGXCPU, "XCPU", "CPU time limit exceeded");
call    0 never executed
        -:19289:#endif
        -:19290:#if defined (SIGXFSZ)
    #####:19291:  init_sig (SIGXFSZ, "XFSZ", "File size limit exceeded");
call    0 never executed
        -:19292:#endif
        -:19293:#if defined (SIGVTALRM)
    #####:19294:  init_sig (SIGVTALRM, "VTALRM", "Virtual timer expired");
call    0 never executed
        -:19295:#endif
        -:19296:#if defined (SIGPROF)
    #####:19297:  init_sig (SIGPROF, "PROF", "Profiling timer expired");
call    0 never executed
        -:19298:#endif
        -:19299:#if defined (SIGWINCH)
        -:19300:  /* "Window size changed" might be more accurate, but even if that
        -:19301:     is all that it means now, perhaps in the future it will be
        -:19302:     extended to cover other kinds of window changes.  */
    #####:19303:  init_sig (SIGWINCH, "WINCH", "Window changed");
call    0 never executed
        -:19304:#endif
        -:19305:#if defined (SIGCONT)
    #####:19306:  init_sig (SIGCONT, "CONT", "Continued");
call    0 never executed
        -:19307:#endif
        -:19308:#if defined (SIGURG)
    #####:19309:  init_sig (SIGURG, "URG", "Urgent I/O condition");
call    0 never executed
        -:19310:#endif
        -:19311:#if defined (SIGIO)
        -:19312:  /* "I/O pending" has also been suggested.  A disadvantage is
        -:19313:     that signal only happens when the process has
        -:19314:     asked for it, not everytime I/O is pending.  Another disadvantage
        -:19315:     is the confusion from giving it a different name than under Unix.  */
    #####:19316:  init_sig (SIGIO, "IO", "I/O possible");
call    0 never executed
        -:19317:#endif
        -:19318:#if defined (SIGWIND)
        -:19319:  init_sig (SIGWIND, "WIND", "SIGWIND");
        -:19320:#endif
        -:19321:#if defined (SIGPHONE)
        -:19322:  init_sig (SIGPHONE, "PHONE", "SIGPHONE");
        -:19323:#endif
        -:19324:#if defined (SIGPOLL)
    #####:19325:  init_sig (SIGPOLL, "POLL", "I/O possible");
call    0 never executed
        -:19326:#endif
        -:19327:#if defined (SIGLOST)
        -:19328:  init_sig (SIGLOST, "LOST", "Resource lost");
        -:19329:#endif
        -:19330:#if defined (SIGDANGER)
        -:19331:  init_sig (SIGDANGER, "DANGER", "Danger signal");
        -:19332:#endif
        -:19333:#if defined (SIGINFO)
        -:19334:  init_sig (SIGINFO, "INFO", "Information request");
        -:19335:#endif
        -:19336:#if defined (SIGNOFP)
        -:19337:  init_sig (SIGNOFP, "NOFP", "Floating point co-processor not available");
        -:19338:#endif
    #####:19339:}
        -:19340:
        -:19341:/* Return the abbreviation for signal NUMBER.  */
        -:19342:
        -:19343:char *
function sig_abbrev called 0 returned 0% blocks executed 0%
    #####:19344:sig_abbrev (number)
        -:19345:     int number;
        -:19346:{
        -:19347:  int i;
        -:19348:
    #####:19349:  if (sig_table_nelts == 0)
branch  0 never executed
branch  1 never executed
    #####:19350:    signame_init ();
call    0 never executed
        -:19351:
    #####:19352:  for (i = 0; i < sig_table_nelts; i++)
branch  0 never executed
branch  1 never executed
    #####:19353:    if (sig_table[i].number == number)
branch  0 never executed
branch  1 never executed
    #####:19354:      return (char *)sig_table[i].abbrev;
    #####:19355:  return NULL;
        -:19356:}
        -:19357:
        -:19358:/* Return the signal number for an ABBREV, or -1 if there is no
        -:19359:   signal by that name.  */
        -:19360:
        -:19361:int
function sig_number called 0 returned 0% blocks executed 0%
    #####:19362:sig_number (abbrev)
        -:19363:     const char *abbrev;
        -:19364:{
        -:19365:  int i;
        -:19366:
    #####:19367:  if (sig_table_nelts == 0)
branch  0 never executed
branch  1 never executed
    #####:19368:    signame_init ();
call    0 never executed
        -:19369:
        -:19370:  /* Skip over "SIG" if present.  */
    #####:19371:  if (abbrev[0] == 'S' && abbrev[1] == 'I' && abbrev[2] == 'G')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:19372:    abbrev += 3;
        -:19373:
    #####:19374:  for (i = 0; i < sig_table_nelts; i++)
branch  0 never executed
branch  1 never executed
    #####:19375:    if (abbrev[0] == sig_table[i].abbrev[0]
branch  0 never executed
branch  1 never executed
    #####:19376:	&& strcmp (abbrev, sig_table[i].abbrev) == 0)
branch  0 never executed
branch  1 never executed
    #####:19377:      return sig_table[i].number;
    #####:19378:  return -1;
        -:19379:}
        -:19380:
        -:19381:#ifndef HAVE_PSIGNAL
        -:19382:/* Print to standard error the name of SIGNAL, preceded by MESSAGE and
        -:19383:   a colon, and followed by a newline.  */
        -:19384:
        -:19385:void
        -:19386:psignal (signal, message)
        -:19387:     int signal;
        -:19388:     const char *message;
        -:19389:{
        -:19390:  if (signal <= 0 || signal >= NSIG)
        -:19391:    fprintf (stderr, "%s: unknown signal", message);
        -:19392:  else
        -:19393:    fprintf (stderr, "%s: %s\n", message, sys_siglist[signal]);
        -:19394:}
        -:19395:#endif
        -:19396:
        -:19397:#ifndef HAVE_STRSIGNAL
        -:19398:/* Return the string associated with the signal number.  */
        -:19399:
        -:19400:char *
        -:19401:strsignal (signal)
        -:19402:     int signal;
        -:19403:{
        -:19404:  static char buf[] = "Signal 12345678901234567890";
        -:19405:
        -:19406:  if (signal > 0 || signal < NSIG)
        -:19407:    return (char *) sys_siglist[signal];
        -:19408:
        -:19409:  sprintf (buf, "Signal %d", signal);
        -:19410:  return buf;
        -:19411:}
        -:19412:#endif
        -:19413:
        -:19414:
        -:19415:
        -:19416:/*************************************************************
        -:19417:  ============================================================
        -:19418:  ************************************************************
        -:19419:  ============================================================
        -:19420:  ************************************************************
        -:19421:                         getopt.c
        -:19422:  ************************************************************
        -:19423:  ============================================================
        -:19424:  ************************************************************
        -:19425:  ============================================================
        -:19426:  *************************************************************/
        -:19427:
        -:19428:/* Getopt for GNU.
        -:19429:   NOTE: getopt is now part of the C library, so if you don't know what
        -:19430:   "Keep this file name-space clean" means, talk to bug-glibc@gnu.org
        -:19431:   before changing it!
        -:19432:
        -:19433:   Copyright (C) 1987, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98
        -:19434:   	Free Software Foundation, Inc.
        -:19435:
        -:19436:NOTE: The canonical source of this file is maintained with the GNU C Library.
        -:19437:Bugs can be reported to bug-glibc@gnu.org.
        -:19438:
        -:19439:This program is free software; you can redistribute it and/or modify it
        -:19440:under the terms of the GNU General Public License as published by the
        -:19441:Free Software Foundation; either version 2, or (at your option) any
        -:19442:later version.
        -:19443:
        -:19444:This program is distributed in the hope that it will be useful,
        -:19445:but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:19446:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:19447:GNU General Public License for more details.
        -:19448:
        -:19449:You should have received a copy of the GNU General Public License
        -:19450:along with this program; if not, write to the Free Software
        -:19451:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
        -:19452:USA.  */
        -:19453:
        -:19454:/* This tells Alpha OSF/1 not to define a getopt prototype in <stdio.h>.
        -:19455:   Ditto for AIX 3.2 and <stdlib.h>.  */
        -:19456:#ifndef _NO_PROTO
        -:19457:#define _NO_PROTO
        -:19458:#endif
        -:19459:
        -:19460:#ifdef HAVE_CONFIG_H
        -:19461:#endif
        -:19462:
        -:19463:#if !defined (__STDC__) || !__STDC__
        -:19464:/* This is a separate conditional since some stdc systems
        -:19465:   reject `defined (const)'.  */
        -:19466:#ifndef const
        -:19467:#define const
        -:19468:#endif
        -:19469:#endif
        -:19470:
        -:19471:
        -:19472:/* Comment out all this code if we are using the GNU C Library, and are not
        -:19473:   actually compiling the library itself.  This code is part of the GNU C
        -:19474:   Library, but also included in many other GNU distributions.  Compiling
        -:19475:   and linking in this code is a waste when using the GNU C library
        -:19476:   (especially if it is a shared library).  Rather than having every GNU
        -:19477:   program understand `configure --with-gnu-libc' and omit the object files,
        -:19478:   it is simpler to just do this in the source for each such file.  */
        -:19479:
        -:19480:#define GETOPT_INTERFACE_VERSION 2
        -:19481:#if !defined (_LIBC) && defined (__GLIBC__) && __GLIBC__ >= 2
        -:19482:#include <gnu-versions.h>
        -:19483:#undef stderr
        -:19484:#define stderr stdout
        -:19485:#if _GNU_GETOPT_INTERFACE_VERSION == GETOPT_INTERFACE_VERSION
        -:19486:#define ELIDE_CODE
        -:19487:#endif
        -:19488:#endif
        -:19489:
        -:19490:#ifndef ELIDE_CODE
        -:19491:
        -:19492:
        -:19493:/* This needs to come after some library #include
        -:19494:   to get __GNU_LIBRARY__ defined.  */
        -:19495:#ifdef	__GNU_LIBRARY__
        -:19496:/* Don't include stdlib.h for non-GNU C libraries because some of them
        -:19497:   contain conflicting prototypes for getopt.  */
        -:19498:#include <stdlib.h>
        -:19499:#include <unistd.h>
        -:19500:#undef stderr
        -:19501:#define stderr stdout
        -:19502:#endif	/* GNU C library.  */
        -:19503:
        -:19504:#ifdef VMS
        -:19505:#include <unixlib.h>
        -:19506:#undef stderr
        -:19507:#define stderr stdout
        -:19508:#if HAVE_STRING_H - 0
        -:19509:#include <string.h>
        -:19510:#undef stderr
        -:19511:#define stderr stdout
        -:19512:#endif
        -:19513:#endif
        -:19514:
        -:19515:#if defined (WINDOWS32) && !defined (__CYGWIN32__)
        -:19516:/* It's not Unix, really.  See?  Capital letters.  */
        -:19517:#include <windows.h>
        -:19518:#undef stderr
        -:19519:#define stderr stdout
        -:19520:#define getpid() GetCurrentProcessId()
        -:19521:#endif
        -:19522:
        -:19523:#ifndef _
        -:19524:/* This is for other GNU distributions with internationalized messages.
        -:19525:   When compiling libc, the _ macro is predefined.  */
        -:19526:#ifdef HAVE_LIBINTL_H
        -:19527:# include <libintl.h>
        -:19528:#undef stderr
        -:19529:#define stderr stdout
        -:19530:# define _(msgid)	gettext (msgid)
        -:19531:#else
        -:19532:# define _(msgid)	(msgid)
        -:19533:#endif
        -:19534:#endif
        -:19535:
        -:19536:/* This version of `getopt' appears to the caller like standard Unix `getopt'
        -:19537:   but it behaves differently for the user, since it allows the user
        -:19538:   to intersperse the options with the other arguments.
        -:19539:
        -:19540:   As `getopt' works, it permutes the elements of ARGV so that,
        -:19541:   when it is done, all the options precede everything else.  Thus
        -:19542:   all application programs are extended to handle flexible argument order.
        -:19543:
        -:19544:   Setting the environment variable POSIXLY_CORRECT disables permutation.
        -:19545:   Then the behavior is completely standard.
        -:19546:
        -:19547:   GNU application programs can use a third alternative mode in which
        -:19548:   they can distinguish the relative order of options and other arguments.  */
        -:19549:
        -:19550:
        -:19551:/* For communication from `getopt' to the caller.
        -:19552:   When `getopt' finds an option that takes an argument,
        -:19553:   the argument value is returned here.
        -:19554:   Also, when `ordering' is RETURN_IN_ORDER,
        -:19555:   each non-option ARGV-element is returned here.  */
        -:19556:
        -:19557:char *optarg = NULL;
        -:19558:
        -:19559:/* Index in ARGV of the next element to be scanned.
        -:19560:   This is used for communication to and from the caller
        -:19561:   and for communication between successive calls to `getopt'.
        -:19562:
        -:19563:   On entry to `getopt', zero means this is the first call; initialize.
        -:19564:
        -:19565:   When `getopt' returns -1, this is the index of the first of the
        -:19566:   non-option elements that the caller should itself scan.
        -:19567:
        -:19568:   Otherwise, `optind' communicates from one call to the next
        -:19569:   how much of ARGV has been scanned so far.  */
        -:19570:
        -:19571:/* 1003.2 says this must be 1 before any call.  */
        -:19572:int optind = 1;
        -:19573:
        -:19574:/* Formerly, initialization of getopt depended on optind==0, which
        -:19575:   causes problems with re-calling getopt as programs generally don't
        -:19576:   know that. */
        -:19577:
        -:19578:int __getopt_initialized = 0;
        -:19579:
        -:19580:/* The next char to be scanned in the option-element
        -:19581:   in which the last option character we returned was found.
        -:19582:   This allows us to pick up the scan where we left off.
        -:19583:
        -:19584:   If this is zero, or a null string, it means resume the scan
        -:19585:   by advancing to the next ARGV-element.  */
        -:19586:
        -:19587:static char *nextchar;
        -:19588:
        -:19589:/* Callers store zero here to inhibit the error message
        -:19590:   for unrecognized options.  */
        -:19591:
        -:19592:int opterr = 1;
        -:19593:
        -:19594:/* Set to an option character which was unrecognized.
        -:19595:   This must be initialized on some systems to avoid linking in the
        -:19596:   system's own getopt implementation.  */
        -:19597:
        -:19598:int optopt = '?';
        -:19599:
        -:19600:/* Describe how to deal with options that follow non-option ARGV-elements.
        -:19601:
        -:19602:   If the caller did not specify anything,
        -:19603:   the default is REQUIRE_ORDER if the environment variable
        -:19604:   POSIXLY_CORRECT is defined, PERMUTE otherwise.
        -:19605:
        -:19606:   REQUIRE_ORDER means don't recognize them as options;
        -:19607:   stop option processing when the first non-option is seen.
        -:19608:   This is what Unix does.
        -:19609:   This mode of operation is selected by either setting the environment
        -:19610:   variable POSIXLY_CORRECT, or using `+' as the first character
        -:19611:   of the list of option characters.
        -:19612:
        -:19613:   PERMUTE is the default.  We permute the contents of ARGV as we scan,
        -:19614:   so that eventually all the non-options are at the end.  This allows options
        -:19615:   to be given in any order, even with programs that were not written to
        -:19616:   expect this.
        -:19617:
        -:19618:   RETURN_IN_ORDER is an option available to programs that were written
        -:19619:   to expect options and other ARGV-elements in any order and that care about
        -:19620:   the ordering of the two.  We describe each non-option ARGV-element
        -:19621:   as if it were the argument of an option with character code 1.
        -:19622:   Using `-' as the first character of the list of option characters
        -:19623:   selects this mode of operation.
        -:19624:
        -:19625:   The special argument `--' forces an end of option-scanning regardless
        -:19626:   of the value of `ordering'.  In the case of RETURN_IN_ORDER, only
        -:19627:   `--' can cause `getopt' to return -1 with `optind' != ARGC.  */
        -:19628:
        -:19629:static enum
        -:19630:{
        -:19631:  REQUIRE_ORDER, PERMUTE, RETURN_IN_ORDER
        -:19632:} ordering;
        -:19633:
        -:19634:/* Value of POSIXLY_CORRECT environment variable.  */
        -:19635:static char *posixly_correct;
        -:19636:
        -:19637:#ifdef	__GNU_LIBRARY__
        -:19638:/* We want to avoid inclusion of string.h with non-GNU libraries
        -:19639:   because there are many ways it can cause trouble.
        -:19640:   On some systems, it contains special magic macros that don't work
        -:19641:   in GCC.  */
        -:19642:
        -:19643:#define	my_index	strchr
        -:19644:#else
        -:19645:
        -:19646:/* Avoid depending on library functions or files
        -:19647:   whose names are inconsistent.  */
        -:19648:
        -:19649:char *getenv ();
        -:19650:
        -:19651:static char *
        -:19652:my_index (str, chr)
        -:19653:     const char *str;
        -:19654:     int chr;
        -:19655:{
        -:19656:  while (*str)
        -:19657:    {
        -:19658:      if (*str == chr)
        -:19659:	return (char *) str;
        -:19660:      str++;
        -:19661:    }
        -:19662:  return 0;
        -:19663:}
        -:19664:
        -:19665:/* If using GCC, we can safely declare strlen this way.
        -:19666:   If not using GCC, it is ok not to declare it.  */
        -:19667:#ifdef __GNUC__
        -:19668:/* Note that Motorola Delta 68k R3V7 comes with GCC but not stddef.h.
        -:19669:   That was relevant to code that was here before.  */
        -:19670:#if !defined (__STDC__) || !__STDC__
        -:19671:/* gcc with -traditional declares the built-in strlen to return int,
        -:19672:   and has done so at least since version 2.4.5. -- rms.  */
        -:19673:extern int strlen (const char *);
        -:19674:#endif /* not __STDC__ */
        -:19675:#endif /* __GNUC__ */
        -:19676:
        -:19677:#endif /* not __GNU_LIBRARY__ */
        -:19678:
        -:19679:/* Handle permutation of arguments.  */
        -:19680:
        -:19681:/* Describe the part of ARGV that contains non-options that have
        -:19682:   been skipped.  `first_nonopt' is the index in ARGV of the first of them;
        -:19683:   `last_nonopt' is the index after the last of them.  */
        -:19684:
        -:19685:static int first_nonopt;
        -:19686:static int last_nonopt;
        -:19687:
        -:19688:#ifdef _LIBC
        -:19689:/* Bash 2.0 gives us an environment variable containing flags
        -:19690:   indicating ARGV elements that should not be considered arguments.  */
        -:19691:
        -:19692:/* Defined in getopt_init.c  */
        -:19693:extern char *__getopt_nonoption_flags;
        -:19694:
        -:19695:static int nonoption_flags_max_len;
        -:19696:static int nonoption_flags_len;
        -:19697:
        -:19698:static int original_argc;
        -:19699:static char *const *original_argv;
        -:19700:
        -:19701:extern pid_t __libc_pid;
        -:19702:
        -:19703:/* Make sure the environment variable bash 2.0 puts in the environment
        -:19704:   is valid for the getopt call we must make sure that the ARGV passed
        -:19705:   to getopt is that one passed to the process.  */
        -:19706:static void
        -:19707:__attribute__ ((unused))
        -:19708:store_args_and_env (int argc, char *const *argv)
        -:19709:{
        -:19710:  /* XXX This is no good solution.  We should rather copy the args so
        -:19711:     that we can compare them later.  But we must not use malloc(3).  */
        -:19712:  original_argc = argc;
        -:19713:  original_argv = argv;
        -:19714:}
        -:19715:text_set_element (__libc_subinit, store_args_and_env);
        -:19716:
        -:19717:# define SWAP_FLAGS(ch1, ch2) \
        -:19718:  if (nonoption_flags_len > 0)						      \
        -:19719:    {									      \
        -:19720:      char __tmp = __getopt_nonoption_flags[ch1];			      \
        -:19721:      __getopt_nonoption_flags[ch1] = __getopt_nonoption_flags[ch2];	      \
        -:19722:      __getopt_nonoption_flags[ch2] = __tmp;				      \
        -:19723:    }
        -:19724:#else	/* !_LIBC */
        -:19725:# define SWAP_FLAGS(ch1, ch2)
        -:19726:#endif	/* _LIBC */
        -:19727:
        -:19728:/* Exchange two adjacent subsequences of ARGV.
        -:19729:   One subsequence is elements [first_nonopt,last_nonopt)
        -:19730:   which contains all the non-options that have been skipped so far.
        -:19731:   The other is elements [last_nonopt,optind), which contains all
        -:19732:   the options processed since those non-options were skipped.
        -:19733:
        -:19734:   `first_nonopt' and `last_nonopt' are relocated so that they describe
        -:19735:   the new indices of the non-options in ARGV after they are moved.  */
        -:19736:
        -:19737:#if defined (__STDC__) && __STDC__
        -:19738:static void exchange (char **);
        -:19739:#endif
        -:19740:
        -:19741:static void
        -:19742:exchange (argv)
        -:19743:     char **argv;
        -:19744:{
        -:19745:  int bottom = first_nonopt;
        -:19746:  int middle = last_nonopt;
        -:19747:  int top = optind;
        -:19748:  char *tem;
        -:19749:
        -:19750:  /* Exchange the shorter segment with the far end of the longer segment.
        -:19751:     That puts the shorter segment into the right place.
        -:19752:     It leaves the longer segment in the right place overall,
        -:19753:     but it consists of two parts that need to be swapped next.  */
        -:19754:
        -:19755:#ifdef _LIBC
        -:19756:  /* First make sure the handling of the `__getopt_nonoption_flags'
        -:19757:     string can work normally.  Our top argument must be in the range
        -:19758:     of the string.  */
        -:19759:  if (nonoption_flags_len > 0 && top >= nonoption_flags_max_len)
        -:19760:    {
        -:19761:      /* We must extend the array.  The user plays games with us and
        -:19762:	 presents new arguments.  */
        -:19763:      char *new_str = malloc (top + 1);
        -:19764:      if (new_str == NULL)
        -:19765:	nonoption_flags_len = nonoption_flags_max_len = 0;
        -:19766:      else
        -:19767:	{
        -:19768:	  memcpy (new_str, __getopt_nonoption_flags, nonoption_flags_max_len);
        -:19769:	  memset (&new_str[nonoption_flags_max_len], '\0',
        -:19770:		  top + 1 - nonoption_flags_max_len);
        -:19771:	  nonoption_flags_max_len = top + 1;
        -:19772:	  __getopt_nonoption_flags = new_str;
        -:19773:	}
        -:19774:    }
        -:19775:#endif
        -:19776:
        -:19777:  while (top > middle && middle > bottom)
        -:19778:    {
        -:19779:      if (top - middle > middle - bottom)
        -:19780:	{
        -:19781:	  /* Bottom segment is the short one.  */
        -:19782:	  int len = middle - bottom;
        -:19783:	  register int i;
        -:19784:
        -:19785:	  /* Swap it with the top part of the top segment.  */
        -:19786:	  for (i = 0; i < len; i++)
        -:19787:	    {
        -:19788:	      tem = argv[bottom + i];
        -:19789:	      argv[bottom + i] = argv[top - (middle - bottom) + i];
        -:19790:	      argv[top - (middle - bottom) + i] = tem;
        -:19791:	      SWAP_FLAGS (bottom + i, top - (middle - bottom) + i);
        -:19792:	    }
        -:19793:	  /* Exclude the moved bottom segment from further swapping.  */
        -:19794:	  top -= len;
        -:19795:	}
        -:19796:      else
        -:19797:	{
        -:19798:	  /* Top segment is the short one.  */
        -:19799:	  int len = top - middle;
        -:19800:	  register int i;
        -:19801:
        -:19802:	  /* Swap it with the bottom part of the bottom segment.  */
        -:19803:	  for (i = 0; i < len; i++)
        -:19804:	    {
        -:19805:	      tem = argv[bottom + i];
        -:19806:	      argv[bottom + i] = argv[middle + i];
        -:19807:	      argv[middle + i] = tem;
        -:19808:	      SWAP_FLAGS (bottom + i, middle + i);
        -:19809:	    }
        -:19810:	  /* Exclude the moved top segment from further swapping.  */
        -:19811:	  bottom += len;
        -:19812:	}
        -:19813:    }
        -:19814:
        -:19815:  /* Update records for the slots the non-options now occupy.  */
        -:19816:
        -:19817:  first_nonopt += (optind - last_nonopt);
        -:19818:  last_nonopt = optind;
        -:19819:}
        -:19820:
        -:19821:/* Initialize the internal data when the first call is made.  */
        -:19822:
        -:19823:#if defined (__STDC__) && __STDC__
        -:19824:static const char *_getopt_initialize (int, char *const *, const char *);
        -:19825:#endif
        -:19826:static const char *
        -:19827:_getopt_initialize (argc, argv, optstring)
        -:19828:     int argc;
        -:19829:     char *const *argv;
        -:19830:     const char *optstring;
        -:19831:{
        -:19832:  /* Start processing options with ARGV-element 1 (since ARGV-element 0
        -:19833:     is the program name); the sequence of previously skipped
        -:19834:     non-option ARGV-elements is empty.  */
        -:19835:
        -:19836:  first_nonopt = last_nonopt = optind;
        -:19837:
        -:19838:  nextchar = NULL;
        -:19839:
        -:19840:  posixly_correct = getenv ("POSIXLY_CORRECT");
        -:19841:
        -:19842:  /* Determine how to handle the ordering of options and nonoptions.  */
        -:19843:
        -:19844:  if (optstring[0] == '-')
        -:19845:    {
        -:19846:      ordering = RETURN_IN_ORDER;
        -:19847:      ++optstring;
        -:19848:    }
        -:19849:  else if (optstring[0] == '+')
        -:19850:    {
        -:19851:      ordering = REQUIRE_ORDER;
        -:19852:      ++optstring;
        -:19853:    }
        -:19854:  else if (posixly_correct != NULL)
        -:19855:    ordering = REQUIRE_ORDER;
        -:19856:  else
        -:19857:    ordering = PERMUTE;
        -:19858:
        -:19859:#ifdef _LIBC
        -:19860:  if (posixly_correct == NULL
        -:19861:      && argc == original_argc && argv == original_argv)
        -:19862:    {
        -:19863:      if (nonoption_flags_max_len == 0)
        -:19864:	{
        -:19865:	  if (__getopt_nonoption_flags == NULL
        -:19866:	      || __getopt_nonoption_flags[0] == '\0')
        -:19867:	    nonoption_flags_max_len = -1;
        -:19868:	  else
        -:19869:	    {
        -:19870:	      const char *orig_str = __getopt_nonoption_flags;
        -:19871:	      int len = nonoption_flags_max_len = strlen (orig_str);
        -:19872:	      if (nonoption_flags_max_len < argc)
        -:19873:		nonoption_flags_max_len = argc;
        -:19874:	      __getopt_nonoption_flags =
        -:19875:		(char *) malloc (nonoption_flags_max_len);
        -:19876:	      if (__getopt_nonoption_flags == NULL)
        -:19877:		nonoption_flags_max_len = -1;
        -:19878:	      else
        -:19879:		{
        -:19880:		  memcpy (__getopt_nonoption_flags, orig_str, len);
        -:19881:		  memset (&__getopt_nonoption_flags[len], '\0',
        -:19882:			  nonoption_flags_max_len - len);
        -:19883:		}
        -:19884:	    }
        -:19885:	}
        -:19886:      nonoption_flags_len = nonoption_flags_max_len;
        -:19887:    }
        -:19888:  else
        -:19889:    nonoption_flags_len = 0;
        -:19890:#endif
        -:19891:
        -:19892:  return optstring;
        -:19893:}
        -:19894:
        -:19895:/* Scan elements of ARGV (whose length is ARGC) for option characters
        -:19896:   given in OPTSTRING.
        -:19897:
        -:19898:   If an element of ARGV starts with '-', and is not exactly "-" or "--",
        -:19899:   then it is an option element.  The characters of this element
        -:19900:   (aside from the initial '-') are option characters.  If `getopt'
        -:19901:   is called repeatedly, it returns successively each of the option characters
        -:19902:   from each of the option elements.
        -:19903:
        -:19904:   If `getopt' finds another option character, it returns that character,
        -:19905:   updating `optind' and `nextchar' so that the next call to `getopt' can
        -:19906:   resume the scan with the following option character or ARGV-element.
        -:19907:
        -:19908:   If there are no more option characters, `getopt' returns -1.
        -:19909:   Then `optind' is the index in ARGV of the first ARGV-element
        -:19910:   that is not an option.  (The ARGV-elements have been permuted
        -:19911:   so that those that are not options now come last.)
        -:19912:
        -:19913:   OPTSTRING is a string containing the legitimate option characters.
        -:19914:   If an option character is seen that is not listed in OPTSTRING,
        -:19915:   return '?' after printing an error message.  If you set `opterr' to
        -:19916:   zero, the error message is suppressed but we still return '?'.
        -:19917:
        -:19918:   If a char in OPTSTRING is followed by a colon, that means it wants an arg,
        -:19919:   so the following text in the same ARGV-element, or the text of the following
        -:19920:   ARGV-element, is returned in `optarg'.  Two colons mean an option that
        -:19921:   wants an optional arg; if there is text in the current ARGV-element,
        -:19922:   it is returned in `optarg', otherwise `optarg' is set to zero.
        -:19923:
        -:19924:   If OPTSTRING starts with `-' or `+', it requests different methods of
        -:19925:   handling the non-option ARGV-elements.
        -:19926:   See the comments about RETURN_IN_ORDER and REQUIRE_ORDER, above.
        -:19927:
        -:19928:   Long-named options begin with `--' instead of `-'.
        -:19929:   Their names may be abbreviated as long as the abbreviation is unique
        -:19930:   or is an exact match for some defined option.  If they have an
        -:19931:   argument, it follows the option name in the same ARGV-element, separated
        -:19932:   from the option name by a `=', or else the in next ARGV-element.
        -:19933:   When `getopt' finds a long-named option, it returns 0 if that option's
        -:19934:   `flag' field is nonzero, the value of the option's `val' field
        -:19935:   if the `flag' field is zero.
        -:19936:
        -:19937:   The elements of ARGV aren't really const, because we permute them.
        -:19938:   But we pretend they're const in the prototype to be compatible
        -:19939:   with other systems.
        -:19940:
        -:19941:   LONGOPTS is a vector of `struct option' terminated by an
        -:19942:   element containing a name which is zero.
        -:19943:
        -:19944:   LONGIND returns the index in LONGOPT of the long-named option found.
        -:19945:   It is only valid when a long-named option has been found by the most
        -:19946:   recent call.
        -:19947:
        -:19948:   If LONG_ONLY is nonzero, '-' as well as '--' can introduce
        -:19949:   long-named options.  */
        -:19950:
        -:19951:int
        -:19952:_getopt_internal (argc, argv, optstring, longopts, longind, long_only)
        -:19953:     int argc;
        -:19954:     char *const *argv;
        -:19955:     const char *optstring;
        -:19956:     const struct option *longopts;
        -:19957:     int *longind;
        -:19958:     int long_only;
        -:19959:{
        -:19960:  optarg = NULL;
        -:19961:
        -:19962:  if (optind == 0 || !__getopt_initialized)
        -:19963:    {
        -:19964:      if (optind == 0)
        -:19965:	optind = 1;	/* Don't scan ARGV[0], the program name.  */
        -:19966:      optstring = _getopt_initialize (argc, argv, optstring);
        -:19967:      __getopt_initialized = 1;
        -:19968:    }
        -:19969:
        -:19970:  /* Test whether ARGV[optind] points to a non-option argument.
        -:19971:     Either it does not have option syntax, or there is an environment flag
        -:19972:     from the shell indicating it is not an option.  The later information
        -:19973:     is only used when the used in the GNU libc.  */
        -:19974:#ifdef _LIBC
        -:19975:#define NONOPTION_P (argv[optind][0] != '-' || argv[optind][1] == '\0'	      \
        -:19976:		     || (optind < nonoption_flags_len			      \
        -:19977:			 && __getopt_nonoption_flags[optind] == '1'))
        -:19978:#else
        -:19979:#define NONOPTION_P (argv[optind][0] != '-' || argv[optind][1] == '\0')
        -:19980:#endif
        -:19981:
        -:19982:  if (nextchar == NULL || *nextchar == '\0')
        -:19983:    {
        -:19984:      /* Advance to the next ARGV-element.  */
        -:19985:
        -:19986:      /* Give FIRST_NONOPT & LAST_NONOPT rational values if OPTIND has been
        -:19987:	 moved back by the user (who may also have changed the arguments).  */
        -:19988:      if (last_nonopt > optind)
        -:19989:	last_nonopt = optind;
        -:19990:      if (first_nonopt > optind)
        -:19991:	first_nonopt = optind;
        -:19992:
        -:19993:      if (ordering == PERMUTE)
        -:19994:	{
        -:19995:	  /* If we have just processed some options following some non-options,
        -:19996:	     exchange them so that the options come first.  */
        -:19997:
        -:19998:	  if (first_nonopt != last_nonopt && last_nonopt != optind)
        -:19999:	    exchange ((char **) argv);
        -:20000:	  else if (last_nonopt != optind)
        -:20001:	    first_nonopt = optind;
        -:20002:
        -:20003:	  /* Skip any additional non-options
        -:20004:	     and extend the range of non-options previously skipped.  */
        -:20005:
        -:20006:	  while (optind < argc && NONOPTION_P)
        -:20007:	    optind++;
        -:20008:	  last_nonopt = optind;
        -:20009:	}
        -:20010:
        -:20011:      /* The special ARGV-element `--' means premature end of options.
        -:20012:	 Skip it like a null option,
        -:20013:	 then exchange with previous non-options as if it were an option,
        -:20014:	 then skip everything else like a non-option.  */
        -:20015:
        -:20016:      if (optind != argc && !strcmp (argv[optind], "--"))
        -:20017:	{
        -:20018:	  optind++;
        -:20019:
        -:20020:	  if (first_nonopt != last_nonopt && last_nonopt != optind)
        -:20021:	    exchange ((char **) argv);
        -:20022:	  else if (first_nonopt == last_nonopt)
        -:20023:	    first_nonopt = optind;
        -:20024:	  last_nonopt = argc;
        -:20025:
        -:20026:	  optind = argc;
        -:20027:	}
        -:20028:
        -:20029:      /* If we have done all the ARGV-elements, stop the scan
        -:20030:	 and back over any non-options that we skipped and permuted.  */
        -:20031:
        -:20032:      if (optind == argc)
        -:20033:	{
        -:20034:	  /* Set the next-arg-index to point at the non-options
        -:20035:	     that we previously skipped, so the caller will digest them.  */
        -:20036:	  if (first_nonopt != last_nonopt)
        -:20037:	    optind = first_nonopt;
        -:20038:	  return -1;
        -:20039:	}
        -:20040:
        -:20041:      /* If we have come to a non-option and did not permute it,
        -:20042:	 either stop the scan or describe it to the caller and pass it by.  */
        -:20043:
        -:20044:      if (NONOPTION_P)
        -:20045:	{
        -:20046:	  if (ordering == REQUIRE_ORDER)
        -:20047:	    return -1;
        -:20048:	  optarg = argv[optind++];
        -:20049:	  return 1;
        -:20050:	}
        -:20051:
        -:20052:      /* We have found another option-ARGV-element.
        -:20053:	 Skip the initial punctuation.  */
        -:20054:
        -:20055:      nextchar = (argv[optind] + 1
        -:20056:		  + (longopts != NULL && argv[optind][1] == '-'));
        -:20057:    }
        -:20058:
        -:20059:  /* Decode the current option-ARGV-element.  */
        -:20060:
        -:20061:  /* Check whether the ARGV-element is a long option.
        -:20062:
        -:20063:     If long_only and the ARGV-element has the form "-f", where f is
        -:20064:     a valid short option, don't consider it an abbreviated form of
        -:20065:     a long option that starts with f.  Otherwise there would be no
        -:20066:     way to give the -f short option.
        -:20067:
        -:20068:     On the other hand, if there's a long option "fubar" and
        -:20069:     the ARGV-element is "-fu", do consider that an abbreviation of
        -:20070:     the long option, just like "--fu", and not "-f" with arg "u".
        -:20071:
        -:20072:     This distinction seems to be the most useful approach.  */
        -:20073:
        -:20074:  if (longopts != NULL
        -:20075:      && (argv[optind][1] == '-'
        -:20076:	  || (long_only && (argv[optind][2] || !my_index (optstring, argv[optind][1])))))
        -:20077:    {
        -:20078:      char *nameend;
        -:20079:      const struct option *p;
        -:20080:      const struct option *pfound = NULL;
        -:20081:      int exact = 0;
        -:20082:      int ambig = 0;
        -:20083:      int indfound = -1;
        -:20084:      int option_index;
        -:20085:
        -:20086:      for (nameend = nextchar; *nameend && *nameend != '='; nameend++)
        -:20087:	/* Do nothing.  */ ;
        -:20088:
        -:20089:      /* Test all long options for either exact match
        -:20090:	 or abbreviated matches.  */
        -:20091:      for (p = longopts, option_index = 0; p->name; p++, option_index++)
        -:20092:	if (!strncmp (p->name, nextchar, nameend - nextchar))
        -:20093:	  {
        -:20094:	    if ((unsigned int) (nameend - nextchar)
        -:20095:		== (unsigned int) strlen (p->name))
        -:20096:	      {
        -:20097:		/* Exact match found.  */
        -:20098:		pfound = p;
        -:20099:		indfound = option_index;
        -:20100:		exact = 1;
        -:20101:		break;
        -:20102:	      }
        -:20103:	    else if (pfound == NULL)
        -:20104:	      {
        -:20105:		/* First nonexact match found.  */
        -:20106:		pfound = p;
        -:20107:		indfound = option_index;
        -:20108:	      }
        -:20109:	    else
        -:20110:	      /* Second or later nonexact match found.  */
        -:20111:	      ambig = 1;
        -:20112:	  }
        -:20113:
        -:20114:      if (ambig && !exact)
        -:20115:	{
        -:20116:	  if (opterr)
        -:20117:	    fprintf (stderr, _("%s: option `%s' is ambiguous\n"),
        -:20118:		     argv[0], argv[optind]);
        -:20119:	  nextchar += strlen (nextchar);
        -:20120:	  optind++;
        -:20121:	  optopt = 0;
        -:20122:	  return '?';
        -:20123:	}
        -:20124:
        -:20125:      if (pfound != NULL)
        -:20126:	{
        -:20127:	  option_index = indfound;
        -:20128:	  optind++;
        -:20129:	  if (*nameend)
        -:20130:	    {
        -:20131:	      /* Don't test has_arg with >, because some C compilers don't
        -:20132:		 allow it to be used on enums.  */
        -:20133:	      if (pfound->has_arg)
        -:20134:		optarg = nameend + 1;
        -:20135:	      else
        -:20136:		{
        -:20137:		  if (opterr)
        -:20138:		   if (argv[optind - 1][1] == '-')
        -:20139:		    /* --option */
        -:20140:		    fprintf (stderr,
        -:20141:		     _("%s: option `--%s' doesn't allow an argument\n"),
        -:20142:		     argv[0], pfound->name);
        -:20143:		   else
        -:20144:		    /* +option or -option */
        -:20145:		    fprintf (stderr,
        -:20146:		     _("%s: option `%c%s' doesn't allow an argument\n"),
        -:20147:		     argv[0], argv[optind - 1][0], pfound->name);
        -:20148:
        -:20149:		  nextchar += strlen (nextchar);
        -:20150:
        -:20151:		  optopt = pfound->val;
        -:20152:		  return '?';
        -:20153:		}
        -:20154:	    }
        -:20155:	  else if (pfound->has_arg == 1)
        -:20156:	    {
        -:20157:	      if (optind < argc)
        -:20158:		optarg = argv[optind++];
        -:20159:	      else
        -:20160:		{
        -:20161:		  if (opterr)
        -:20162:		    fprintf (stderr,
        -:20163:			   _("%s: option `%s' requires an argument\n"),
        -:20164:			   argv[0], argv[optind - 1]);
        -:20165:		  nextchar += strlen (nextchar);
        -:20166:		  optopt = pfound->val;
        -:20167:		  return optstring[0] == ':' ? ':' : '?';
        -:20168:		}
        -:20169:	    }
        -:20170:	  nextchar += strlen (nextchar);
        -:20171:	  if (longind != NULL)
        -:20172:	    *longind = option_index;
        -:20173:	  if (pfound->flag)
        -:20174:	    {
        -:20175:	      *(pfound->flag) = pfound->val;
        -:20176:	      return 0;
        -:20177:	    }
        -:20178:	  return pfound->val;
        -:20179:	}
        -:20180:
        -:20181:      /* Can't find it as a long option.  If this is not getopt_long_only,
        -:20182:	 or the option starts with '--' or is not a valid short
        -:20183:	 option, then it's an error.
        -:20184:	 Otherwise interpret it as a short option.  */
        -:20185:      if (!long_only || argv[optind][1] == '-'
        -:20186:	  || my_index (optstring, *nextchar) == NULL)
        -:20187:	{
        -:20188:	  if (opterr)
        -:20189:	    {
        -:20190:	      if (argv[optind][1] == '-')
        -:20191:		/* --option */
        -:20192:		fprintf (stderr, _("%s: unrecognized option `--%s'\n"),
        -:20193:			 argv[0], nextchar);
        -:20194:	      else
        -:20195:		/* +option or -option */
        -:20196:		fprintf (stderr, _("%s: unrecognized option `%c%s'\n"),
        -:20197:			 argv[0], argv[optind][0], nextchar);
        -:20198:	    }
        -:20199:	  nextchar = (char *) "";
        -:20200:	  optind++;
        -:20201:	  optopt = 0;
        -:20202:	  return '?';
        -:20203:	}
        -:20204:    }
        -:20205:
        -:20206:  /* Look at and handle the next short option-character.  */
        -:20207:
        -:20208:  {
        -:20209:    char c = *nextchar++;
        -:20210:    char *temp = my_index (optstring, c);
        -:20211:
        -:20212:    /* Increment `optind' when we start to process its last character.  */
        -:20213:    if (*nextchar == '\0')
        -:20214:      ++optind;
        -:20215:
        -:20216:    if (temp == NULL || c == ':')
        -:20217:      {
        -:20218:	if (opterr)
        -:20219:	  {
        -:20220:	    if (posixly_correct)
        -:20221:	      /* 1003.2 specifies the format of this message.  */
        -:20222:	      fprintf (stderr, _("%s: illegal option -- %c\n"),
        -:20223:		       argv[0], c);
        -:20224:	    else
        -:20225:	      fprintf (stderr, _("%s: invalid option -- %c\n"),
        -:20226:		       argv[0], c);
        -:20227:	  }
        -:20228:	optopt = c;
        -:20229:	return '?';
        -:20230:      }
        -:20231:    /* Convenience. Treat POSIX -W foo same as long option --foo */
        -:20232:    if (temp[0] == 'W' && temp[1] == ';')
        -:20233:      {
        -:20234:	char *nameend;
        -:20235:	const struct option *p;
        -:20236:	const struct option *pfound = NULL;
        -:20237:	int exact = 0;
        -:20238:	int ambig = 0;
        -:20239:	int indfound = 0;
        -:20240:	int option_index;
        -:20241:
        -:20242:	/* This is an option that requires an argument.  */
        -:20243:	if (*nextchar != '\0')
        -:20244:	  {
        -:20245:	    optarg = nextchar;
        -:20246:	    /* If we end this ARGV-element by taking the rest as an arg,
        -:20247:	       we must advance to the next element now.  */
        -:20248:	    optind++;
        -:20249:	  }
        -:20250:	else if (optind == argc)
        -:20251:	  {
        -:20252:	    if (opterr)
        -:20253:	      {
        -:20254:		/* 1003.2 specifies the format of this message.  */
        -:20255:		fprintf (stderr, _("%s: option requires an argument -- %c\n"),
        -:20256:			 argv[0], c);
        -:20257:	      }
        -:20258:	    optopt = c;
        -:20259:	    if (optstring[0] == ':')
        -:20260:	      c = ':';
        -:20261:	    else
        -:20262:	      c = '?';
        -:20263:	    return c;
        -:20264:	  }
        -:20265:	else
        -:20266:	  /* We already incremented `optind' once;
        -:20267:	     increment it again when taking next ARGV-elt as argument.  */
        -:20268:	  optarg = argv[optind++];
        -:20269:
        -:20270:	/* optarg is now the argument, see if it's in the
        -:20271:	   table of longopts.  */
        -:20272:
        -:20273:	for (nextchar = nameend = optarg; *nameend && *nameend != '='; nameend++)
        -:20274:	  /* Do nothing.  */ ;
        -:20275:
        -:20276:	/* Test all long options for either exact match
        -:20277:	   or abbreviated matches.  */
        -:20278:	for (p = longopts, option_index = 0; p->name; p++, option_index++)
        -:20279:	  if (!strncmp (p->name, nextchar, nameend - nextchar))
        -:20280:	    {
        -:20281:	      if ((unsigned int) (nameend - nextchar) == strlen (p->name))
        -:20282:		{
        -:20283:		  /* Exact match found.  */
        -:20284:		  pfound = p;
        -:20285:		  indfound = option_index;
        -:20286:		  exact = 1;
        -:20287:		  break;
        -:20288:		}
        -:20289:	      else if (pfound == NULL)
        -:20290:		{
        -:20291:		  /* First nonexact match found.  */
        -:20292:		  pfound = p;
        -:20293:		  indfound = option_index;
        -:20294:		}
        -:20295:	      else
        -:20296:		/* Second or later nonexact match found.  */
        -:20297:		ambig = 1;
        -:20298:	    }
        -:20299:	if (ambig && !exact)
        -:20300:	  {
        -:20301:	    if (opterr)
        -:20302:	      fprintf (stderr, _("%s: option `-W %s' is ambiguous\n"),
        -:20303:		       argv[0], argv[optind]);
        -:20304:	    nextchar += strlen (nextchar);
        -:20305:	    optind++;
        -:20306:	    return '?';
        -:20307:	  }
        -:20308:	if (pfound != NULL)
        -:20309:	  {
        -:20310:	    option_index = indfound;
        -:20311:	    if (*nameend)
        -:20312:	      {
        -:20313:		/* Don't test has_arg with >, because some C compilers don't
        -:20314:		   allow it to be used on enums.  */
        -:20315:		if (pfound->has_arg)
        -:20316:		  optarg = nameend + 1;
        -:20317:		else
        -:20318:		  {
        -:20319:		    if (opterr)
        -:20320:		      fprintf (stderr, _("\
        -:20321:%s: option `-W %s' doesn't allow an argument\n"),
        -:20322:			       argv[0], pfound->name);
        -:20323:
        -:20324:		    nextchar += strlen (nextchar);
        -:20325:		    return '?';
        -:20326:		  }
        -:20327:	      }
        -:20328:	    else if (pfound->has_arg == 1)
        -:20329:	      {
        -:20330:		if (optind < argc)
        -:20331:		  optarg = argv[optind++];
        -:20332:		else
        -:20333:		  {
        -:20334:		    if (opterr)
        -:20335:		      fprintf (stderr,
        -:20336:			       _("%s: option `%s' requires an argument\n"),
        -:20337:			       argv[0], argv[optind - 1]);
        -:20338:		    nextchar += strlen (nextchar);
        -:20339:		    return optstring[0] == ':' ? ':' : '?';
        -:20340:		  }
        -:20341:	      }
        -:20342:	    nextchar += strlen (nextchar);
        -:20343:	    if (longind != NULL)
        -:20344:	      *longind = option_index;
        -:20345:	    if (pfound->flag)
        -:20346:	      {
        -:20347:		*(pfound->flag) = pfound->val;
        -:20348:		return 0;
        -:20349:	      }
        -:20350:	    return pfound->val;
        -:20351:	  }
        -:20352:	  nextchar = NULL;
        -:20353:	  return 'W';	/* Let the application handle it.   */
        -:20354:      }
        -:20355:    if (temp[1] == ':')
        -:20356:      {
        -:20357:	if (temp[2] == ':')
        -:20358:	  {
        -:20359:	    /* This is an option that accepts an argument optionally.  */
        -:20360:	    if (*nextchar != '\0')
        -:20361:	      {
        -:20362:		optarg = nextchar;
        -:20363:		optind++;
        -:20364:	      }
        -:20365:	    else
        -:20366:	      optarg = NULL;
        -:20367:	    nextchar = NULL;
        -:20368:	  }
        -:20369:	else
        -:20370:	  {
        -:20371:	    /* This is an option that requires an argument.  */
        -:20372:	    if (*nextchar != '\0')
        -:20373:	      {
        -:20374:		optarg = nextchar;
        -:20375:		/* If we end this ARGV-element by taking the rest as an arg,
        -:20376:		   we must advance to the next element now.  */
        -:20377:		optind++;
        -:20378:	      }
        -:20379:	    else if (optind == argc)
        -:20380:	      {
        -:20381:		if (opterr)
        -:20382:		  {
        -:20383:		    /* 1003.2 specifies the format of this message.  */
        -:20384:		    fprintf (stderr,
        -:20385:			   _("%s: option requires an argument -- %c\n"),
        -:20386:			   argv[0], c);
        -:20387:		  }
        -:20388:		optopt = c;
        -:20389:		if (optstring[0] == ':')
        -:20390:		  c = ':';
        -:20391:		else
        -:20392:		  c = '?';
        -:20393:	      }
        -:20394:	    else
        -:20395:	      /* We already incremented `optind' once;
        -:20396:		 increment it again when taking next ARGV-elt as argument.  */
        -:20397:	      optarg = argv[optind++];
        -:20398:	    nextchar = NULL;
        -:20399:	  }
        -:20400:      }
        -:20401:    return c;
        -:20402:  }
        -:20403:}
        -:20404:
        -:20405:int
        -:20406:getopt (argc, argv, optstring)
        -:20407:     int argc;
        -:20408:     char *const *argv;
        -:20409:     const char *optstring;
        -:20410:{
        -:20411:  return _getopt_internal (argc, argv, optstring,
        -:20412:			   (const struct option *) 0,
        -:20413:			   (int *) 0,
        -:20414:			   0);
        -:20415:}
        -:20416:
        -:20417:#endif	/* Not ELIDE_CODE.  */
        -:20418:
        -:20419:#ifdef TEST
        -:20420:
        -:20421:/* Compile with -DTEST to make an executable for use in testing
        -:20422:   the above definition of `getopt'.  */
        -:20423:
        -:20424:int
        -:20425:main (argc, argv)
        -:20426:     int argc;
        -:20427:     char **argv;
        -:20428:{
        -:20429:  int c;
        -:20430:  int digit_optind = 0;
        -:20431:
        -:20432:  while (1)
        -:20433:    {
        -:20434:      int this_option_optind = optind ? optind : 1;
        -:20435:
        -:20436:      c = getopt (argc, argv, "abc:d:0123456789");
        -:20437:      if (c == -1)
        -:20438:	break;
        -:20439:
        -:20440:      switch (c)
        -:20441:	{
        -:20442:	case '0':
        -:20443:	case '1':
        -:20444:	case '2':
        -:20445:	case '3':
        -:20446:	case '4':
        -:20447:	case '5':
        -:20448:	case '6':
        -:20449:	case '7':
        -:20450:	case '8':
        -:20451:	case '9':
        -:20452:	  if (digit_optind != 0 && digit_optind != this_option_optind)
        -:20453:	    printf ("digits occur in two different argv-elements.\n");
        -:20454:	  digit_optind = this_option_optind;
        -:20455:	  printf ("option %c\n", c);
        -:20456:	  break;
        -:20457:
        -:20458:	case 'a':
        -:20459:	  printf ("option a\n");
        -:20460:	  break;
        -:20461:
        -:20462:	case 'b':
        -:20463:	  printf ("option b\n");
        -:20464:	  break;
        -:20465:
        -:20466:	case 'c':
        -:20467:	  printf ("option c with value `%s'\n", optarg);
        -:20468:	  break;
        -:20469:
        -:20470:	case '?':
        -:20471:	  break;
        -:20472:
        -:20473:	default:
        -:20474:	  printf ("?? getopt returned character code 0%o ??\n", c);
        -:20475:	}
        -:20476:    }
        -:20477:
        -:20478:  if (optind < argc)
        -:20479:    {
        -:20480:      printf ("non-option ARGV-elements: ");
        -:20481:      while (optind < argc)
        -:20482:	printf ("%s ", argv[optind++]);
        -:20483:      printf ("\n");
        -:20484:    }
        -:20485:
        -:20486:  exit (0);
        -:20487:}
        -:20488:
        -:20489:#endif /* TEST */
        -:20490:
        -:20491:
        -:20492:
        -:20493:/*************************************************************
        -:20494:  ============================================================
        -:20495:  ************************************************************
        -:20496:  ============================================================
        -:20497:  ************************************************************
        -:20498:                         getopt1.c
        -:20499:  ************************************************************
        -:20500:  ============================================================
        -:20501:  ************************************************************
        -:20502:  ============================================================
        -:20503:  *************************************************************/
        -:20504:
        -:20505:/* getopt_long and getopt_long_only entry points for GNU getopt.
        -:20506:   Copyright (C) 1987,88,89,90,91,92,93,94,96,97 Free Software Foundation, Inc.
        -:20507:
        -:20508:NOTE: The canonical source of this file is maintained with the GNU C Library.
        -:20509:Bugs can be reported to bug-glibc@gnu.org.
        -:20510:
        -:20511:This program is free software; you can redistribute it and/or modify it
        -:20512:under the terms of the GNU General Public License as published by the
        -:20513:Free Software Foundation; either version 2, or (at your option) any
        -:20514:later version.
        -:20515:
        -:20516:This program is distributed in the hope that it will be useful,
        -:20517:but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:20518:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:20519:GNU General Public License for more details.
        -:20520:
        -:20521:You should have received a copy of the GNU General Public License
        -:20522:along with this program; if not, write to the Free Software
        -:20523:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
        -:20524:USA.  */
        -:20525:
        -:20526:#ifdef HAVE_CONFIG_H
        -:20527:#endif
        -:20528:
        -:20529:
        -:20530:#if !defined (__STDC__) || !__STDC__
        -:20531:/* This is a separate conditional since some stdc systems
        -:20532:   reject `defined (const)'.  */
        -:20533:#ifndef const
        -:20534:#define const
        -:20535:#endif
        -:20536:#endif
        -:20537:
        -:20538:
        -:20539:/* Comment out all this code if we are using the GNU C Library, and are not
        -:20540:   actually compiling the library itself.  This code is part of the GNU C
        -:20541:   Library, but also included in many other GNU distributions.  Compiling
        -:20542:   and linking in this code is a waste when using the GNU C library
        -:20543:   (especially if it is a shared library).  Rather than having every GNU
        -:20544:   program understand `configure --with-gnu-libc' and omit the object files,
        -:20545:   it is simpler to just do this in the source for each such file.  */
        -:20546:
        -:20547:#define GETOPT_INTERFACE_VERSION 2
        -:20548:#if !defined (_LIBC) && defined (__GLIBC__) && __GLIBC__ >= 2
        -:20549:#include <gnu-versions.h>
        -:20550:#undef stderr
        -:20551:#define stderr stdout
        -:20552:#if _GNU_GETOPT_INTERFACE_VERSION == GETOPT_INTERFACE_VERSION
        -:20553:#define ELIDE_CODE
        -:20554:#endif
        -:20555:#endif
        -:20556:
        -:20557:#ifndef ELIDE_CODE
        -:20558:
        -:20559:
        -:20560:/* This needs to come after some library #include
        -:20561:   to get __GNU_LIBRARY__ defined.  */
        -:20562:#ifdef __GNU_LIBRARY__
        -:20563:#include <stdlib.h>
        -:20564:#undef stderr
        -:20565:#define stderr stdout
        -:20566:#endif
        -:20567:
        -:20568:#ifndef	NULL
        -:20569:#define NULL 0
        -:20570:#endif
        -:20571:
        -:20572:int
        -:20573:getopt_long (argc, argv, options, long_options, opt_index)
        -:20574:     int argc;
        -:20575:     char *const *argv;
        -:20576:     const char *options;
        -:20577:     const struct option *long_options;
        -:20578:     int *opt_index;
        -:20579:{
        -:20580:  return _getopt_internal (argc, argv, options, long_options, opt_index, 0);
        -:20581:}
        -:20582:
        -:20583:/* Like getopt_long, but '-' as well as '--' can indicate a long option.
        -:20584:   If an option that starts with '-' (not '--') doesn't match a long option,
        -:20585:   but does match a short option, it is parsed as a short option
        -:20586:   instead.  */
        -:20587:
        -:20588:int
        -:20589:getopt_long_only (argc, argv, options, long_options, opt_index)
        -:20590:     int argc;
        -:20591:     char *const *argv;
        -:20592:     const char *options;
        -:20593:     const struct option *long_options;
        -:20594:     int *opt_index;
        -:20595:{
        -:20596:  return _getopt_internal (argc, argv, options, long_options, opt_index, 1);
        -:20597:}
        -:20598:
        -:20599:
        -:20600:#endif	/* Not ELIDE_CODE.  */
        -:20601:
        -:20602:#ifdef TEST
        -:20603:
        -:20604:#include <stdio.h>
        -:20605:#undef stderr
        -:20606:#define stderr stdout
        -:20607:
        -:20608:int
        -:20609:main (argc, argv)
        -:20610:     int argc;
        -:20611:     char **argv;
        -:20612:{
        -:20613:  int c;
        -:20614:  int digit_optind = 0;
        -:20615:
        -:20616:  while (1)
        -:20617:    {
        -:20618:      int this_option_optind = optind ? optind : 1;
        -:20619:      int option_index = 0;
        -:20620:      static struct option long_options[] =
        -:20621:      {
        -:20622:	{"add", 1, 0, 0},
        -:20623:	{"append", 0, 0, 0},
        -:20624:	{"delete", 1, 0, 0},
        -:20625:	{"verbose", 0, 0, 0},
        -:20626:	{"create", 0, 0, 0},
        -:20627:	{"file", 1, 0, 0},
        -:20628:	{0, 0, 0, 0}
        -:20629:      };
        -:20630:
        -:20631:      c = getopt_long (argc, argv, "abc:d:0123456789",
        -:20632:		       long_options, &option_index);
        -:20633:      if (c == -1)
        -:20634:	break;
        -:20635:
        -:20636:      switch (c)
        -:20637:	{
        -:20638:	case 0:
        -:20639:	  printf ("option %s", long_options[option_index].name);
        -:20640:	  if (optarg)
        -:20641:	    printf (" with arg %s", optarg);
        -:20642:	  printf ("\n");
        -:20643:	  break;
        -:20644:
        -:20645:	case '0':
        -:20646:	case '1':
        -:20647:	case '2':
        -:20648:	case '3':
        -:20649:	case '4':
        -:20650:	case '5':
        -:20651:	case '6':
        -:20652:	case '7':
        -:20653:	case '8':
        -:20654:	case '9':
        -:20655:	  if (digit_optind != 0 && digit_optind != this_option_optind)
        -:20656:	    printf ("digits occur in two different argv-elements.\n");
        -:20657:	  digit_optind = this_option_optind;
        -:20658:	  printf ("option %c\n", c);
        -:20659:	  break;
        -:20660:
        -:20661:	case 'a':
        -:20662:	  printf ("option a\n");
        -:20663:	  break;
        -:20664:
        -:20665:	case 'b':
        -:20666:	  printf ("option b\n");
        -:20667:	  break;
        -:20668:
        -:20669:	case 'c':
        -:20670:	  printf ("option c with value `%s'\n", optarg);
        -:20671:	  break;
        -:20672:
        -:20673:	case 'd':
        -:20674:	  printf ("option d with value `%s'\n", optarg);
        -:20675:	  break;
        -:20676:
        -:20677:	case '?':
        -:20678:	  break;
        -:20679:
        -:20680:	default:
        -:20681:	  printf ("?? getopt returned character code 0%o ??\n", c);
        -:20682:	}
        -:20683:    }
        -:20684:
        -:20685:  if (optind < argc)
        -:20686:    {
        -:20687:      printf ("non-option ARGV-elements: ");
        -:20688:      while (optind < argc)
        -:20689:	printf ("%s ", argv[optind++]);
        -:20690:      printf ("\n");
        -:20691:    }
        -:20692:
        -:20693:  exit (0);
        -:20694:}
        -:20695:
        -:20696:#endif /* TEST */
        -:20697:
        -:20698:
