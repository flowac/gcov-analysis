        -:    0:Source:make.c
        -:    0:Graph:make.gcno
        -:    0:Data:make.gcda
        -:    0:Runs:774
        -:    1:#include "FaultSeeds.h"
        -:    2:/* modification by J. Ruthruff, 8/25 */
        -:    3:#define HAVE_CONFIG_H
        -:    4:#define LIBDIR "/usr/local/lib"
        -:    5:#define INCLUDEDIR "/usr/local/include"
        -:    6:
        -:    7:#undef stderr
        -:    8:#define stderr stdout
        -:    9:
        -:   10:/*************************************************************
        -:   11:  ============================================================
        -:   12:  ************************************************************
        -:   13:  ============================================================
        -:   14:  ************************************************************
        -:   15:                         main.c
        -:   16:  ************************************************************
        -:   17:  ============================================================
        -:   18:  ************************************************************
        -:   19:  ============================================================
        -:   20:  *************************************************************/
        -:   21:
        -:   22:/* Argument parsing and main program of GNU Make.
        -:   23:Copyright (C) 1988,89,90,91,94,95,96,97,98,99 Free Software Foundation, Inc.
        -:   24:This file is part of GNU Make.
        -:   25:
        -:   26:GNU Make is free software; you can redistribute it and/or modify
        -:   27:it under the terms of the GNU General Public License as published by
        -:   28:the Free Software Foundation; either version 2, or (at your option)
        -:   29:any later version.
        -:   30:
        -:   31:GNU Make is distributed in the hope that it will be useful,
        -:   32:but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   33:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   34:GNU General Public License for more details.
        -:   35:
        -:   36:You should have received a copy of the GNU General Public License
        -:   37:along with GNU Make; see the file COPYING.  If not, write to
        -:   38:the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
        -:   39:MA 02111-1307, USA.  */
        -:   40:
        -:   41:#include "make.h"
        -:   42:#include "dep.h"
        -:   43:#include "filedef.h"
        -:   44:#include "variable.h"
        -:   45:#include "job.h"
        -:   46:#include "commands.h"
        -:   47:#include "rule.h"
        -:   48:#include "getopt.h"
        -:   49:#include <assert.h>
        -:   50:#undef stderr
        -:   51:#define stderr stdout
        -:   52:#ifdef _AMIGA
        -:   53:# include <dos/dos.h>
        -:   54:# include <proto/dos.h>
        -:   55:#undef stderr
        -:   56:#define stderr stdout
        -:   57:#endif
        -:   58:#ifdef WINDOWS32
        -:   59:#include <windows.h>
        -:   60:#include "pathstuff.h"
        -:   61:#undef stderr
        -:   62:#define stderr stdout
        -:   63:#endif
        -:   64:#if defined(MAKE_JOBSERVER) && defined(HAVE_FCNTL_H)
        -:   65:# include <fcntl.h>
        -:   66:#undef stderr
        -:   67:#define stderr stdout
        -:   68:#endif
        -:   69:
        -:   70:
        -:   71:#define ino_t_int longlong_t
        -:   72:#define dev_t_int long
        -:   73:#define off_t_int longlong_t
        -:   74:
        -:   75:ino_t_int ZERO_ino_t = 0;
        -:   76:dev_t_int ZERO_dev_t = 0;
        -:   77:off_t_int ZERO_off_t = 0;
        -:   78:off_t_int ZERO_L_off_t = 0L;
        -:   79:
function int_to_ino_t called 771 returned 100% blocks executed 100%
      771:   80:ino_t int_to_ino_t(long arg)
        -:   81:{
        -:   82:  ino_t_int x;
        -:   83:  ino_t y;
        -:   84:  memset(&x, '\0', sizeof(x));
      771:   85:  memcpy(&x, &arg, sizeof(arg));
      771:   86:  memcpy(&y, &x, sizeof(ino_t));
      771:   87:  return y;
        -:   88:}
        -:   89:
function int_to_dev_t called 771 returned 100% blocks executed 100%
      771:   90:dev_t int_to_dev_t(long x)
        -:   91:{
        -:   92:  dev_t y;
      771:   93:  memcpy(&y, &x, sizeof(dev_t));
      771:   94:  return y;
        -:   95:}
        -:   96:
function int_to_off_t called 0 returned 0% blocks executed 0%
    #####:   97:off_t int_to_off_t(long arg)
        -:   98:{
        -:   99:  off_t_int x;
        -:  100:  off_t y;
        -:  101:  memset(&x, '\0', sizeof(x));
    #####:  102:  memcpy(&x, &arg, sizeof(arg));
    #####:  103:  memcpy(&y, &x, sizeof(off_t));
    #####:  104:  return y;
        -:  105:}
        -:  106:
function ino_t_to_int called 0 returned 0% blocks executed 0%
    #####:  107:ino_t_int ino_t_to_int(ino_t x)
        -:  108:{
        -:  109:  ino_t_int y;
    #####:  110:  memcpy(&y, &x, sizeof(ino_t));
    #####:  111:  return y;
        -:  112:}
        -:  113:
        -:  114:/* note: this is *not* a safe conversion, because long int's are
        -:  115:   4-bytes and ino_t's are 8-bytes, but I'm only mimicking what
        -:  116:   the developers do */
function ino_t_to_long_int called 0 returned 0% blocks executed 0%
    #####:  117:long int ino_t_to_long_int(ino_t x)
        -:  118:{
        -:  119:  long int y;
    #####:  120:  memcpy(&y, &x, sizeof(ino_t));
    #####:  121:  return y;
        -:  122:}
        -:  123:
        -:  124:/* note: this is *not* a safe conversion, but I'm only mimicking 
        -:  125:   what the developers do */
function ino_t_to_long called 384 returned 100% blocks executed 100%
      384:  126:long ino_t_to_long(ino_t x)
        -:  127:{
        -:  128:  long y;
      384:  129:  memcpy(&y, &x, sizeof(ino_t));
      384:  130:  return y;
        -:  131:}
        -:  132:
        -:  133:/* note: this is *not* a safe conversion, but I'm only mimicking
        -:  134:   what the developers do */
function ino_t_to_unsigned_int called 0 returned 0% blocks executed 0%
    #####:  135:unsigned int ino_t_to_unsigned_int(ino_t x)
        -:  136:{
        -:  137:  unsigned int y;
    #####:  138:  memcpy(&y, &x, sizeof(ino_t));
    #####:  139:  return y;
        -:  140:}
        -:  141:
function off_t_to_int called 0 returned 0% blocks executed 0%
    #####:  142:off_t_int off_t_to_int(off_t x)
        -:  143:{
        -:  144:  off_t_int y;
    #####:  145:  memcpy(&y, &x, sizeof(off_t));
    #####:  146:  return y;
        -:  147:}
        -:  148:
function dev_t_to_int called 384 returned 100% blocks executed 100%
      384:  149:dev_t_int dev_t_to_int(dev_t x)
        -:  150:{
        -:  151:  dev_t_int y;
      384:  152:  memcpy(&y, &x, sizeof(dev_t));
      384:  153:  return y;
        -:  154:}
        -:  155:
function ino_t_equal called 0 returned 0% blocks executed 0%
    #####:  156:int ino_t_equal(ino_t_int x, ino_t_int y)
        -:  157:{
    #####:  158:  return (memcmp(&x, &y, sizeof(ino_t_int)));
        -:  159:}
        -:  160:
function off_t_equal called 0 returned 0% blocks executed 0%
    #####:  161:int off_t_equal(off_t_int x, off_t_int y)
        -:  162:{
    #####:  163:  return (memcmp(&x, &y, sizeof(off_t_int)));
        -:  164:}
        -:  165:
function dev_t_equal called 0 returned 0% blocks executed 0%
    #####:  166:int dev_t_equal(dev_t_int x, dev_t_int y)
        -:  167:{
    #####:  168:  return (memcmp(&x, &y, sizeof(dev_t_int)));
        -:  169:}
        -:  170:
        -:  171:
        -:  172:#ifdef _AMIGA
        -:  173:int __stack = 20000; /* Make sure we have 20K of stack space */
        -:  174:#endif
        -:  175:
        -:  176:extern void init_dir PARAMS ((void));
        -:  177:extern void remote_setup PARAMS ((void));
        -:  178:extern void remote_cleanup PARAMS ((void));
        -:  179:extern RETSIGTYPE fatal_error_signal PARAMS ((int sig));
        -:  180:
        -:  181:extern void print_variable_data_base PARAMS ((void));
        -:  182:extern void print_dir_data_base PARAMS ((void));
        -:  183:extern void print_rule_data_base PARAMS ((void));
        -:  184:extern void print_file_data_base PARAMS ((void));
        -:  185:extern void print_vpath_data_base PARAMS ((void));
        -:  186:
        -:  187:#if defined HAVE_WAITPID || defined HAVE_WAIT3
        -:  188:# define HAVE_WAIT_NOHANG
        -:  189:#endif
        -:  190:
        -:  191:#ifndef	HAVE_UNISTD_H
        -:  192:extern int chdir ();
        -:  193:#endif
        -:  194:#ifndef	STDC_HEADERS
        -:  195:# ifndef sun			/* Sun has an incorrect decl in a header.  */
        -:  196:extern void exit PARAMS ((int)) __attribute__ ((noreturn));
        -:  197:# endif
        -:  198:extern double atof ();
        -:  199:#endif
        -:  200:extern char *mktemp ();
        -:  201:
        -:  202:static void print_data_base PARAMS ((void));
        -:  203:static void print_version PARAMS ((void));
        -:  204:static void decode_switches PARAMS ((int argc, char **argv, int env));
        -:  205:static void decode_env_switches PARAMS ((char *envar, unsigned int len));
        -:  206:static void define_makeflags PARAMS ((int all, int makefile));
        -:  207:static char *quote_as_word PARAMS ((char *out, char *in, int double_dollars));
        -:  208:
        -:  209:/* The structure that describes an accepted command switch.  */
        -:  210:
        -:  211:struct command_switch
        -:  212:  {
        -:  213:    int c;			/* The switch character.  */
        -:  214:
        -:  215:    enum			/* Type of the value.  */
        -:  216:      {
        -:  217:	flag,			/* Turn int flag on.  */
        -:  218:	flag_off,		/* Turn int flag off.  */
        -:  219:	string,			/* One string per switch.  */
        -:  220:	positive_int,		/* A positive integer.  */
        -:  221:	floating,		/* A floating-point number (double).  */
        -:  222:	ignore			/* Ignored.  */
        -:  223:      } type;
        -:  224:
        -:  225:    char *value_ptr;	/* Pointer to the value-holding variable.  */
        -:  226:
        -:  227:    unsigned int env:1;		/* Can come from MAKEFLAGS.  */
        -:  228:    unsigned int toenv:1;	/* Should be put in MAKEFLAGS.  */
        -:  229:    unsigned int no_makefile:1;	/* Don't propagate when remaking makefiles.  */
        -:  230:
        -:  231:    char *noarg_value;	/* Pointer to value used if no argument is given.  */
        -:  232:    char *default_value;/* Pointer to default value.  */
        -:  233:
        -:  234:    char *long_name;		/* Long option name.  */
        -:  235:    char *argdesc;		/* Descriptive word for argument.  */
        -:  236:    char *description;		/* Description for usage message.  */
        -:  237:                                /* 0 means internal; don't display help.  */
        -:  238:  };
        -:  239:
        -:  240:/* True if C is a switch value that corresponds to a short option.  */
        -:  241:
        -:  242:#define short_option(c) ((c) <= CHAR_MAX)
        -:  243:
        -:  244:/* The structure used to hold the list of strings given
        -:  245:   in command switches of a type that takes string arguments.  */
        -:  246:
        -:  247:struct stringlist
        -:  248:  {
        -:  249:    char **list;	/* Nil-terminated list of strings.  */
        -:  250:    unsigned int idx;	/* Index into above.  */
        -:  251:    unsigned int max;	/* Number of pointers allocated.  */
        -:  252:  };
        -:  253:
        -:  254:
        -:  255:/* The recognized command switches.  */
        -:  256:
        -:  257:/* Nonzero means do not print commands to be executed (-s).  */
        -:  258:
        -:  259:int silent_flag;
        -:  260:
        -:  261:/* Nonzero means just touch the files
        -:  262:   that would appear to need remaking (-t)  */
        -:  263:
        -:  264:int touch_flag;
        -:  265:
        -:  266:/* Nonzero means just print what commands would need to be executed,
        -:  267:   don't actually execute them (-n).  */
        -:  268:
        -:  269:int just_print_flag;
        -:  270:
        -:  271:/* Print debugging trace info (-d).  */
        -:  272:
        -:  273:int debug_flag = 0;
        -:  274:
        -:  275:#ifdef WINDOWS32
        -:  276:/* Suspend make in main for a short time to allow debugger to attach */
        -:  277:
        -:  278:int suspend_flag = 0;
        -:  279:#endif
        -:  280:
        -:  281:/* Environment variables override makefile definitions.  */
        -:  282:
        -:  283:int env_overrides = 0;
        -:  284:
        -:  285:/* Nonzero means ignore status codes returned by commands
        -:  286:   executed to remake files.  Just treat them all as successful (-i).  */
        -:  287:
        -:  288:int ignore_errors_flag = 0;
        -:  289:
        -:  290:/* Nonzero means don't remake anything, just print the data base
        -:  291:   that results from reading the makefile (-p).  */
        -:  292:
        -:  293:int print_data_base_flag = 0;
        -:  294:
        -:  295:/* Nonzero means don't remake anything; just return a nonzero status
        -:  296:   if the specified targets are not up to date (-q).  */
        -:  297:
        -:  298:int question_flag = 0;
        -:  299:
        -:  300:/* Nonzero means do not use any of the builtin rules (-r) / variables (-R).  */
        -:  301:
        -:  302:int no_builtin_rules_flag = 0;
        -:  303:int no_builtin_variables_flag = 0;
        -:  304:
        -:  305:/* Nonzero means keep going even if remaking some file fails (-k).  */
        -:  306:
        -:  307:int keep_going_flag;
        -:  308:int default_keep_going_flag = 0;
        -:  309:
        -:  310:/* Nonzero means print directory before starting and when done (-w).  */
        -:  311:
        -:  312:int print_directory_flag = 0;
        -:  313:
        -:  314:/* Nonzero means ignore print_directory_flag and never print the directory.
        -:  315:   This is necessary because print_directory_flag is set implicitly.  */
        -:  316:
        -:  317:int inhibit_print_directory_flag = 0;
        -:  318:
        -:  319:/* Nonzero means print version information.  */
        -:  320:
        -:  321:int print_version_flag = 0;
        -:  322:
        -:  323:/* List of makefiles given with -f switches.  */
        -:  324:
        -:  325:static struct stringlist *makefiles = 0;
        -:  326:
        -:  327:/* Number of job slots (commands that can be run at once).  */
        -:  328:
        -:  329:unsigned int job_slots = 1;
        -:  330:unsigned int default_job_slots = 1;
        -:  331:
        -:  332:/* Value of job_slots that means no limit.  */
        -:  333:
        -:  334:static unsigned int inf_jobs = 0;
        -:  335:
        -:  336:/* File descriptors for the jobs pipe.  */
        -:  337:
        -:  338:static struct stringlist *jobserver_fds = 0;
        -:  339:
        -:  340:int job_fds[2] = { -1, -1 };
        -:  341:int job_rfd = -1;
        -:  342:
        -:  343:/* Maximum load average at which multiple jobs will be run.
        -:  344:   Negative values mean unlimited, while zero means limit to
        -:  345:   zero load (which could be useful to start infinite jobs remotely
        -:  346:   but one at a time locally).  */
        -:  347:#ifndef NO_FLOAT
        -:  348:double max_load_average = -1.0;
        -:  349:double default_load_average = -1.0;
        -:  350:#else
        -:  351:int max_load_average = -1;
        -:  352:int default_load_average = -1;
        -:  353:#endif
        -:  354:
        -:  355:/* List of directories given with -C switches.  */
        -:  356:
        -:  357:static struct stringlist *directories = 0;
        -:  358:
        -:  359:/* List of include directories given with -I switches.  */
        -:  360:
        -:  361:static struct stringlist *include_directories = 0;
        -:  362:
        -:  363:/* List of files given with -o switches.  */
        -:  364:
        -:  365:static struct stringlist *old_files = 0;
        -:  366:
        -:  367:/* List of files given with -W switches.  */
        -:  368:
        -:  369:static struct stringlist *new_files = 0;
        -:  370:
        -:  371:/* If nonzero, we should just print usage and exit.  */
        -:  372:
        -:  373:static int print_usage_flag = 0;
        -:  374:
        -:  375:/* If nonzero, we should print a warning message
        -:  376:   for each reference to an undefined variable.  */
        -:  377:
        -:  378:int warn_undefined_variables_flag;
        -:  379:
        -:  380:/* The table of command switches.  */
        -:  381:
        -:  382:static const struct command_switch switches[] =
        -:  383:  {
        -:  384:    { 'b', ignore, 0, 0, 0, 0, 0, 0,
        -:  385:	0, 0,
        -:  386:	_("Ignored for compatibility") },
        -:  387:    { 'C', string, (char *) &directories, 0, 0, 0, 0, 0,
        -:  388:	"directory", _("DIRECTORY"),
        -:  389:	_("Change to DIRECTORY before doing anything") },
        -:  390:    { 'd', flag, (char *) &debug_flag, 1, 1, 0, 0, 0,
        -:  391:	"debug", 0,
        -:  392:	_("Print lots of debugging information") },
        -:  393:#ifdef WINDOWS32
        -:  394:    { 'D', flag, (char *) &suspend_flag, 1, 1, 0, 0, 0,
        -:  395:        "suspend-for-debug", 0,
        -:  396:        _("Suspend process to allow a debugger to attach") },
        -:  397:#endif
        -:  398:    { 'e', flag, (char *) &env_overrides, 1, 1, 0, 0, 0,
        -:  399:	"environment-overrides", 0,
        -:  400:	_("Environment variables override makefiles") },
        -:  401:    { 'f', string, (char *) &makefiles, 0, 0, 0, 0, 0,
        -:  402:	"file", _("FILE"),
        -:  403:	_("Read FILE as a makefile") },
        -:  404:    { 'h', flag, (char *) &print_usage_flag, 0, 0, 0, 0, 0,
        -:  405:	"help", 0,
        -:  406:	_("Print this message and exit") },
        -:  407:    { 'i', flag, (char *) &ignore_errors_flag, 1, 1, 0, 0, 0,
        -:  408:	"ignore-errors", 0,
        -:  409:	_("Ignore errors from commands") },
        -:  410:    { 'I', string, (char *) &include_directories, 1, 1, 0, 0, 0,
        -:  411:	"include-dir", _("DIRECTORY"),
        -:  412:	_("Search DIRECTORY for included makefiles") },
        -:  413:    { 'j',
        -:  414:        positive_int, (char *) &job_slots, 1, 1, 0,
        -:  415:	(char *) &inf_jobs, (char *) &default_job_slots,
        -:  416:	"jobs", "N",
        -:  417:	_("Allow N jobs at once; infinite jobs with no arg") },
        -:  418:    { CHAR_MAX+1, string, (char *) &jobserver_fds, 1, 1, 0, 0, 0,
        -:  419:        "jobserver-fds", 0,
        -:  420:        0 },
        -:  421:    { 'k', flag, (char *) &keep_going_flag, 1, 1, 0,
        -:  422:	0, (char *) &default_keep_going_flag,
        -:  423:	"keep-going", 0,
        -:  424:	_("Keep going when some targets can't be made") },
        -:  425:#ifndef NO_FLOAT
        -:  426:    { 'l', floating, (char *) &max_load_average, 1, 1, 0,
        -:  427:	(char *) &default_load_average, (char *) &default_load_average,
        -:  428:	"load-average", "N",
        -:  429:	_("Don't start multiple jobs unless load is below N") },
        -:  430:#else
        -:  431:    { 'l', positive_int, (char *) &max_load_average, 1, 1, 0,
        -:  432:	(char *) &default_load_average, (char *) &default_load_average,
        -:  433:	"load-average", "N",
        -:  434:	_("Don't start multiple jobs unless load is below N") },
        -:  435:#endif
        -:  436:    { 'm', ignore, 0, 0, 0, 0, 0, 0,
        -:  437:	0, 0,
        -:  438:	"-b" },
        -:  439:    { 'n', flag, (char *) &just_print_flag, 1, 1, 1, 0, 0,
        -:  440:	"just-print", 0,
        -:  441:	_("Don't actually run any commands; just print them") },
        -:  442:    { 'o', string, (char *) &old_files, 0, 0, 0, 0, 0,
        -:  443:	"old-file", _("FILE"),
        -:  444:	_("Consider FILE to be very old and don't remake it") },
        -:  445:    { 'p', flag, (char *) &print_data_base_flag, 1, 1, 0, 0, 0,
        -:  446:	"print-data-base", 0,
        -:  447:	_("Print make's internal database") },
        -:  448:    { 'q', flag, (char *) &question_flag, 1, 1, 1, 0, 0,
        -:  449:	"question", 0,
        -:  450:	_("Run no commands; exit status says if up to date") },
        -:  451:    { 'r', flag, (char *) &no_builtin_rules_flag, 1, 1, 0, 0, 0,
        -:  452:	"no-builtin-rules", 0,
        -:  453:	_("Disable the built-in implicit rules") },
        -:  454:    { 'R', flag, (char *) &no_builtin_variables_flag, 1, 1, 0, 0, 0,
        -:  455:	"no-builtin-variables", 0,
        -:  456:	_("Disable the built-in variable settings") },
        -:  457:    { 's', flag, (char *) &silent_flag, 1, 1, 0, 0, 0,
        -:  458:	"silent", 0,
        -:  459:	_("Don't echo commands") },
        -:  460:    { 'S', flag_off, (char *) &keep_going_flag, 1, 1, 0,
        -:  461:	0, (char *) &default_keep_going_flag,
        -:  462:	"no-keep-going", 0,
        -:  463:	_("Turns off -k") },
        -:  464:    { 't', flag, (char *) &touch_flag, 1, 1, 1, 0, 0,
        -:  465:	"touch", 0,
        -:  466:	_("Touch targets instead of remaking them") },
        -:  467:    { 'v', flag, (char *) &print_version_flag, 1, 1, 0, 0, 0,
        -:  468:	"version", 0,
        -:  469:	_("Print the version number of make and exit") },
        -:  470:    { 'w', flag, (char *) &print_directory_flag, 1, 1, 0, 0, 0,
        -:  471:	"print-directory", 0,
        -:  472:	_("Print the current directory") },
        -:  473:    { CHAR_MAX+2, flag, (char *) &inhibit_print_directory_flag, 1, 1, 0, 0, 0,
        -:  474:	"no-print-directory", 0,
        -:  475:	_("Turn off -w, even if it was turned on implicitly") },
        -:  476:    { 'W', string, (char *) &new_files, 0, 0, 0, 0, 0,
        -:  477:	"what-if", _("FILE"),
        -:  478:	_("Consider FILE to be infinitely new") },
        -:  479:    { CHAR_MAX+3, flag, (char *) &warn_undefined_variables_flag, 1, 1, 0, 0, 0,
        -:  480:	"warn-undefined-variables", 0,
        -:  481:	_("Warn when an undefined variable is referenced") },
        -:  482:    { '\0', }
        -:  483:  };
        -:  484:
        -:  485:/* Secondary long names for options.  */
        -:  486:
        -:  487:static struct option long_option_aliases[] =
        -:  488:  {
        -:  489:    { "quiet",		no_argument,		0, 's' },
        -:  490:    { "stop",		no_argument,		0, 'S' },
        -:  491:    { "new-file",	required_argument,	0, 'W' },
        -:  492:    { "assume-new",	required_argument,	0, 'W' },
        -:  493:    { "assume-old",	required_argument,	0, 'o' },
        -:  494:    { "max-load",	optional_argument,	0, 'l' },
        -:  495:    { "dry-run",	no_argument,		0, 'n' },
        -:  496:    { "recon",		no_argument,		0, 'n' },
        -:  497:    { "makefile",	required_argument,	0, 'f' },
        -:  498:  };
        -:  499:
        -:  500:/* The usage message prints the descriptions of options starting in
        -:  501:   this column.  Make sure it leaves enough room for the longest
        -:  502:   description to fit in less than 80 characters.  */
        -:  503:
        -:  504:#define	DESCRIPTION_COLUMN	30
        -:  505:
        -:  506:/* List of goal targets.  */
        -:  507:
        -:  508:static struct dep *goals, *lastgoal;
        -:  509:
        -:  510:/* List of variables which were defined on the command line
        -:  511:   (or, equivalently, in MAKEFLAGS).  */
        -:  512:
        -:  513:struct command_variable
        -:  514:  {
        -:  515:    struct command_variable *next;
        -:  516:    struct variable *variable;
        -:  517:  };
        -:  518:static struct command_variable *command_variables;
        -:  519:
        -:  520:/* The name we were invoked with.  */
        -:  521:
        -:  522:char *program;
        -:  523:
        -:  524:/* Our current directory before processing any -C options.  */
        -:  525:
        -:  526:char *directory_before_chdir;
        -:  527:
        -:  528:/* Our current directory after processing all -C options.  */
        -:  529:
        -:  530:char *starting_directory;
        -:  531:
        -:  532:/* Value of the MAKELEVEL variable at startup (or 0).  */
        -:  533:
        -:  534:unsigned int makelevel;
        -:  535:
        -:  536:/* First file defined in the makefile whose name does not
        -:  537:   start with `.'.  This is the default to remake if the
        -:  538:   command line does not specify.  */
        -:  539:
        -:  540:struct file *default_goal_file;
        -:  541:
        -:  542:/* Pointer to structure for the file .DEFAULT
        -:  543:   whose commands are used for any file that has none of its own.
        -:  544:   This is zero if the makefiles do not define .DEFAULT.  */
        -:  545:
        -:  546:struct file *default_file;
        -:  547:
        -:  548:/* Nonzero if we have seen the magic `.POSIX' target.
        -:  549:   This turns on pedantic compliance with POSIX.2.  */
        -:  550:
        -:  551:int posix_pedantic;
        -:  552:
        -:  553:/* Nonzero if some rule detected clock skew; we keep track so (a) we only
        -:  554:   print one warning about it during the run, and (b) we can print a final
        -:  555:   warning at the end of the run. */
        -:  556:
        -:  557:int clock_skew_detected;
        -:  558:
        -:  559:/* Mask of signals that are being caught with fatal_error_signal.  */
        -:  560:
        -:  561:#ifdef	POSIX
        -:  562:sigset_t fatal_signal_set;
        -:  563:#else
        -:  564:#ifdef	HAVE_SIGSETMASK
        -:  565:int fatal_signal_mask;
        -:  566:#endif
        -:  567:#endif
        -:  568:
        -:  569:static struct file *
function enter_command_line_file called 0 returned 0% blocks executed 0%
    #####:  570:enter_command_line_file (name)
        -:  571:     char *name;
        -:  572:{
    #####:  573:  if (name[0] == '\0')
branch  0 never executed
branch  1 never executed
    #####:  574:    fatal (NILF, _("empty string invalid as file name"));
call    0 never executed
        -:  575:
    #####:  576:  if (name[0] == '~')
branch  0 never executed
branch  1 never executed
        -:  577:    {
    #####:  578:      char *expanded = tilde_expand (name);
call    0 never executed
    #####:  579:      if (expanded != 0)
branch  0 never executed
branch  1 never executed
    #####:  580:	name = expanded;	/* Memory leak; I don't care.  */
        -:  581:    }
        -:  582:
        -:  583:  /* This is also done in parse_file_seq, so this is redundant
        -:  584:     for names read from makefiles.  It is here for names passed
        -:  585:     on the command line.  */
    #####:  586:  while (name[0] == '.' && name[1] == '/' && name[2] != '\0')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:  587:    {
    #####:  588:      name += 2;
    #####:  589:      while (*name == '/')
branch  0 never executed
branch  1 never executed
        -:  590:	/* Skip following slashes: ".//foo" is "foo", not "/foo".  */
    #####:  591:	++name;
        -:  592:    }
        -:  593:
    #####:  594:  if (*name == '\0')
branch  0 never executed
branch  1 never executed
        -:  595:    {
        -:  596:      /* It was all slashes!  Move back to the dot and truncate
        -:  597:	 it after the first slash, so it becomes just "./".  */
        -:  598:      do
    #####:  599:	--name;
    #####:  600:      while (name[0] != '.');
branch  0 never executed
branch  1 never executed
    #####:  601:      name[2] = '\0';
        -:  602:    }
        -:  603:
    #####:  604:  return enter_file (xstrdup (name));
call    0 never executed
call    1 never executed
        -:  605:}
        -:  606:
        -:  607:/* Toggle -d on receipt of SIGUSR1.  */
        -:  608:
        -:  609:static RETSIGTYPE
function debug_signal_handler called 0 returned 0% blocks executed 0%
    #####:  610:debug_signal_handler (sig)
        -:  611:     int sig;
        -:  612:{
    #####:  613:  debug_flag = ! debug_flag;
    #####:  614:}
        -:  615:
        -:  616:#ifdef WINDOWS32
        -:  617:/*
        -:  618: * HANDLE runtime exceptions by avoiding a requestor on the GUI. Capture
        -:  619: * exception and print it to stderr instead.
        -:  620: *
        -:  621: * If debug_flag not set, just print a simple message and exit.
        -:  622: * If debug_flag set, print a more verbose message.
        -:  623: * If compiled for DEBUG, let exception pass through to GUI so that
        -:  624: *   debuggers can attach.
        -:  625: */
        -:  626:LONG WINAPI
        -:  627:handle_runtime_exceptions( struct _EXCEPTION_POINTERS *exinfo )
        -:  628:{
        -:  629:  PEXCEPTION_RECORD exrec = exinfo->ExceptionRecord;
        -:  630:  LPSTR cmdline = GetCommandLine();
        -:  631:  LPSTR prg = strtok(cmdline, " ");
        -:  632:  CHAR errmsg[1024];
        -:  633:#ifdef USE_EVENT_LOG
        -:  634:  HANDLE hEventSource;
        -:  635:  LPTSTR lpszStrings[1];
        -:  636:#endif
        -:  637:
        -:  638:  if (!debug_flag)
        -:  639:    {
        -:  640:      sprintf(errmsg, _("%s: Interrupt/Exception caught "), prg);
        -:  641:      sprintf(&errmsg[strlen(errmsg)],
        -:  642:              "(code = 0x%x, addr = 0x%x)\r\n",
        -:  643:              exrec->ExceptionCode, exrec->ExceptionAddress);
        -:  644:      fprintf(stderr, errmsg);
        -:  645:      exit(255);
        -:  646:    }
        -:  647:
        -:  648:  sprintf(errmsg,
        -:  649:          _("\r\nUnhandled exception filter called from program %s\r\n"), prg);
        -:  650:  sprintf(&errmsg[strlen(errmsg)], "ExceptionCode = %x\r\n",
        -:  651:          exrec->ExceptionCode);
        -:  652:  sprintf(&errmsg[strlen(errmsg)], "ExceptionFlags = %x\r\n",
        -:  653:          exrec->ExceptionFlags);
        -:  654:  sprintf(&errmsg[strlen(errmsg)], "ExceptionAddress = %x\r\n",
        -:  655:          exrec->ExceptionAddress);
        -:  656:
        -:  657:  if (exrec->ExceptionCode == EXCEPTION_ACCESS_VIOLATION
        -:  658:      && exrec->NumberParameters >= 2)
        -:  659:    sprintf(&errmsg[strlen(errmsg)],
        -:  660:            _("Access violation: %s operation at address %x\r\n"),
        -:  661:            exrec->ExceptionInformation[0] ? _("write"): _("read"),
        -:  662:            exrec->ExceptionInformation[1]);
        -:  663:
        -:  664:  /* turn this on if we want to put stuff in the event log too */
        -:  665:#ifdef USE_EVENT_LOG
        -:  666:  hEventSource = RegisterEventSource(NULL, "GNU Make");
        -:  667:  lpszStrings[0] = errmsg;
        -:  668:
        -:  669:  if (hEventSource != NULL)
        -:  670:    {
        -:  671:      ReportEvent(hEventSource,         /* handle of event source */
        -:  672:                  EVENTLOG_ERROR_TYPE,  /* event type */
        -:  673:                  0,                    /* event category */
        -:  674:                  0,                    /* event ID */
        -:  675:                  NULL,                 /* current user's SID */
        -:  676:                  1,                    /* strings in lpszStrings */
        -:  677:                  0,                    /* no bytes of raw data */
        -:  678:                  lpszStrings,          /* array of error strings */
        -:  679:                  NULL);                /* no raw data */
        -:  680:
        -:  681:      (VOID) DeregisterEventSource(hEventSource);
        -:  682:    }
        -:  683:#endif
        -:  684:
        -:  685:  /* Write the error to stderr too */
        -:  686:  fprintf(stderr, errmsg);
        -:  687:
        -:  688:#ifdef DEBUG
        -:  689:  return EXCEPTION_CONTINUE_SEARCH;
        -:  690:#else
        -:  691:  exit(255);
        -:  692:  return (255); /* not reached */
        -:  693:#endif
        -:  694:}
        -:  695:
        -:  696:/*
        -:  697: * On WIN32 systems we don't have the luxury of a /bin directory that
        -:  698: * is mapped globally to every drive mounted to the system. Since make could
        -:  699: * be invoked from any drive, and we don't want to propogate /bin/sh
        -:  700: * to every single drive. Allow ourselves a chance to search for
        -:  701: * a value for default shell here (if the default path does not exist).
        -:  702: */
        -:  703:
        -:  704:int
        -:  705:find_and_set_default_shell(char *token)
        -:  706:{
        -:  707:  int sh_found = 0;
        -:  708:  char* search_token;
        -:  709:  PATH_VAR(sh_path);
        -:  710:  extern char *default_shell;
        -:  711:
        -:  712:  if (!token)
        -:  713:    search_token = default_shell;
        -:  714:  else
        -:  715:    search_token = token;
        -:  716:
        -:  717:  if (!no_default_sh_exe &&
        -:  718:      (token == NULL || !strcmp(search_token, default_shell))) {
        -:  719:    /* no new information, path already set or known */
        -:  720:    sh_found = 1;
        -:  721:  } else if (file_exists_p(search_token)) {
        -:  722:    /* search token path was found */
        -:  723:    sprintf(sh_path, "%s", search_token);
        -:  724:    default_shell = xstrdup(w32ify(sh_path,0));
        -:  725:    if (debug_flag)
        -:  726:      printf(_("find_and_set_shell setting default_shell = %s\n"), default_shell);
        -:  727:    sh_found = 1;
        -:  728:  } else {
        -:  729:    char *p;
        -:  730:    struct variable *v = lookup_variable ("Path", 4);
        -:  731:
        -:  732:    /*
        -:  733:     * Search Path for shell
        -:  734:     */
        -:  735:    if (v && v->value) {
        -:  736:      char *ep;
        -:  737:
        -:  738:      p  = v->value;
        -:  739:      ep = strchr(p, PATH_SEPARATOR_CHAR);
        -:  740:
        -:  741:      while (ep && *ep) {
        -:  742:        *ep = '\0';
        -:  743:
        -:  744:        if (dir_file_exists_p(p, search_token)) {
        -:  745:          sprintf(sh_path, "%s/%s", p, search_token);
        -:  746:          default_shell = xstrdup(w32ify(sh_path,0));
        -:  747:          sh_found = 1;
        -:  748:          *ep = PATH_SEPARATOR_CHAR;
        -:  749:
        -:  750:          /* terminate loop */
        -:  751:          p += strlen(p);
        -:  752:        } else {
        -:  753:          *ep = PATH_SEPARATOR_CHAR;
        -:  754:           p = ++ep;
        -:  755:        }
        -:  756:
        -:  757:        ep = strchr(p, PATH_SEPARATOR_CHAR);
        -:  758:      }
        -:  759:
        -:  760:      /* be sure to check last element of Path */
        -:  761:      if (p && *p && dir_file_exists_p(p, search_token)) {
        -:  762:          sprintf(sh_path, "%s/%s", p, search_token);
        -:  763:          default_shell = xstrdup(w32ify(sh_path,0));
        -:  764:          sh_found = 1;
        -:  765:      }
        -:  766:
        -:  767:      if (debug_flag && sh_found)
        -:  768:        printf(_("find_and_set_shell path search set default_shell = %s\n"), default_shell);
        -:  769:    }
        -:  770:  }
        -:  771:
        -:  772:  /* naive test */
        -:  773:  if (!unixy_shell && sh_found &&
        -:  774:      (strstr(default_shell, "sh") || strstr(default_shell, "SH"))) {
        -:  775:    unixy_shell = 1;
        -:  776:    batch_mode_shell = 0;
        -:  777:  }
        -:  778:
        -:  779:#ifdef BATCH_MODE_ONLY_SHELL
        -:  780:  batch_mode_shell = 1;
        -:  781:#endif
        -:  782:
        -:  783:  return (sh_found);
        -:  784:}
        -:  785:#endif  /* WINDOWS32 */
        -:  786:
        -:  787:#ifdef  __MSDOS__
        -:  788:
        -:  789:static void
        -:  790:msdos_return_to_initial_directory ()
        -:  791:{
        -:  792:  if (directory_before_chdir)
        -:  793:    chdir (directory_before_chdir);
        -:  794:}
        -:  795:#endif
        -:  796:
        -:  797:#ifndef _AMIGA
        -:  798:int
function main called 774 returned 0% blocks executed 40%
      774:  799:main (argc, argv, envp)
        -:  800:     int argc;
        -:  801:     char **argv;
        -:  802:     char **envp;
        -:  803:#else
        -:  804:int main (int argc, char ** argv)
        -:  805:#endif
        -:  806:{
        -:  807:  static char *stdin_nm = 0;
        -:  808:  register struct file *f;
        -:  809:  register unsigned int i;
        -:  810:  char **p;
        -:  811:  struct dep *read_makefiles;
        -:  812:  PATH_VAR (current_directory);
        -:  813:#ifdef WINDOWS32
        -:  814:  char *unix_path = NULL;
        -:  815:  char *windows32_path = NULL;
        -:  816:
        -:  817:  SetUnhandledExceptionFilter(handle_runtime_exceptions);
        -:  818:
        -:  819:  /* start off assuming we have no shell */
        -:  820:  unixy_shell = 0;
        -:  821:  no_default_sh_exe = 1;
        -:  822:#endif
        -:  823:
      774:  824:  default_goal_file = 0;
      774:  825:  reading_file = 0;
        -:  826:
        -:  827:#if defined (__MSDOS__) && !defined (_POSIX_SOURCE)
        -:  828:  /* Request the most powerful version of `system', to
        -:  829:     make up for the dumb default shell.  */
        -:  830:  __system_flags = (__system_redirect
        -:  831:		    | __system_use_shell
        -:  832:		    | __system_allow_multiple_cmds
        -:  833:		    | __system_allow_long_cmds
        -:  834:		    | __system_handle_null_commands
        -:  835:		    | __system_emulate_chdir);
        -:  836:
        -:  837:#endif
        -:  838:
        -:  839:#if !defined (HAVE_STRSIGNAL) && !defined (HAVE_SYS_SIGLIST)
        -:  840:  signame_init ();
        -:  841:#endif
        -:  842:
        -:  843:#ifdef	POSIX
      774:  844:  sigemptyset (&fatal_signal_set);
call    0 returned 774
        -:  845:#define	ADD_SIG(sig)	sigaddset (&fatal_signal_set, sig)
        -:  846:#else
        -:  847:#ifdef	HAVE_SIGSETMASK
        -:  848:  fatal_signal_mask = 0;
        -:  849:#define	ADD_SIG(sig)	fatal_signal_mask |= sigmask (sig)
        -:  850:#else
        -:  851:#define	ADD_SIG(sig)
        -:  852:#endif
        -:  853:#endif
        -:  854:
        -:  855:#define	FATAL_SIG(sig)							      \
        -:  856:  if (signal ((sig), fatal_error_signal) == SIG_IGN)			      \
        -:  857:    (void) signal ((sig), SIG_IGN);					      \
        -:  858:  else									      \
        -:  859:    ADD_SIG (sig);
        -:  860:
        -:  861:#ifdef SIGHUP
     774*:  862:  FATAL_SIG (SIGHUP);
call    0 returned 774
branch  1 taken 0 (fallthrough)
branch  2 taken 774
call    3 never executed
call    4 returned 774
        -:  863:#endif
        -:  864:#ifdef SIGQUIT
     774*:  865:  FATAL_SIG (SIGQUIT);
call    0 returned 774
branch  1 taken 0 (fallthrough)
branch  2 taken 774
call    3 never executed
call    4 returned 774
        -:  866:#endif
     774*:  867:  FATAL_SIG (SIGINT);
call    0 returned 774
branch  1 taken 0 (fallthrough)
branch  2 taken 774
call    3 never executed
call    4 returned 774
     774*:  868:  FATAL_SIG (SIGTERM);
call    0 returned 774
branch  1 taken 0 (fallthrough)
branch  2 taken 774
call    3 never executed
call    4 returned 774
        -:  869:
        -:  870:#ifdef	SIGDANGER
        -:  871:  FATAL_SIG (SIGDANGER);
        -:  872:#endif
        -:  873:#ifdef SIGXCPU
     774*:  874:  FATAL_SIG (SIGXCPU);
call    0 returned 774
branch  1 taken 0 (fallthrough)
branch  2 taken 774
call    3 never executed
call    4 returned 774
        -:  875:#endif
        -:  876:#ifdef SIGXFSZ
     774*:  877:  FATAL_SIG (SIGXFSZ);
call    0 returned 774
branch  1 taken 0 (fallthrough)
branch  2 taken 774
call    3 never executed
call    4 returned 774
        -:  878:#endif
        -:  879:
        -:  880:#undef	FATAL_SIG
        -:  881:
        -:  882:  /* Do not ignore the child-death signal.  This must be done before
        -:  883:     any children could possibly be created; otherwise, the wait
        -:  884:     functions won't work on systems with the SVR4 ECHILD brain
        -:  885:     damage, if our invoker is ignoring this signal.  */
        -:  886:
        -:  887:#ifdef HAVE_WAIT_NOHANG
        -:  888:# if defined SIGCHLD
      774:  889:  (void) signal (SIGCHLD, SIG_DFL);
call    0 returned 774
        -:  890:# endif
        -:  891:# if defined SIGCLD && SIGCLD != SIGCHLD
        -:  892:  (void) signal (SIGCLD, SIG_DFL);
        -:  893:# endif
        -:  894:#endif
        -:  895:
        -:  896:  /* Make sure stdout is line-buffered.  */
        -:  897:
        -:  898:#ifdef	HAVE_SETLINEBUF
      774:  899:  setlinebuf (stdout);
call    0 returned 774
        -:  900:#else
        -:  901:#ifndef	SETVBUF_REVERSED
        -:  902:  setvbuf (stdout, (char *) 0, _IOLBF, BUFSIZ);
        -:  903:#else	/* setvbuf not reversed.  */
        -:  904:  /* Some buggy systems lose if we pass 0 instead of allocating ourselves.  */
        -:  905:  setvbuf (stdout, _IOLBF, xmalloc (BUFSIZ), BUFSIZ);
        -:  906:#endif	/* setvbuf reversed.  */
        -:  907:#endif	/* setlinebuf missing.  */
        -:  908:
        -:  909:  /* Figure out where this program lives.  */
        -:  910:
      774:  911:  if (argv[0] == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 774
    #####:  912:    argv[0] = "";
      774:  913:  if (argv[0][0] == '\0')
branch  0 taken 0 (fallthrough)
branch  1 taken 774
    #####:  914:    program = "make";
        -:  915:  else
        -:  916:    {
        -:  917:#ifdef VMS
        -:  918:      program = rindex (argv[0], ']');
        -:  919:#else
      774:  920:      program = rindex (argv[0], '/');
        -:  921:#endif
        -:  922:#ifdef __MSDOS__
        -:  923:      if (program == 0)
        -:  924:	program = rindex (argv[0], '\\');
        -:  925:      else
        -:  926:	{
        -:  927:	  /* Some weird environments might pass us argv[0] with
        -:  928:	     both kinds of slashes; we must find the rightmost.  */
        -:  929:	  char *p = rindex (argv[0], '\\');
        -:  930:	  if (p && p > program)
        -:  931:	    program = p;
        -:  932:	}
        -:  933:      if (program == 0 && argv[0][1] == ':')
        -:  934:	program = argv[0] + 1;
        -:  935:#endif
      774:  936:      if (program == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 774
    #####:  937:	program = argv[0];
        -:  938:      else
      774:  939:	++program;
        -:  940:    }
        -:  941:
        -:  942:  /* Set up to access user data (files).  */
      774:  943:  user_access ();
call    0 returned 774
        -:  944:
        -:  945:  /* Figure out where we are.  */
        -:  946:
        -:  947:#ifdef WINDOWS32
        -:  948:  if (getcwd_fs (current_directory, GET_PATH_MAX) == 0)
        -:  949:#else
      774:  950:  if (getcwd (current_directory, GET_PATH_MAX) == 0)
call    0 returned 774
branch  1 taken 0 (fallthrough)
branch  2 taken 774
        -:  951:#endif
        -:  952:    {
        -:  953:#ifdef	HAVE_GETCWD
    #####:  954:      perror_with_name ("getcwd: ", "");
call    0 never executed
        -:  955:#else
        -:  956:      error (NILF, "getwd: %s", current_directory);
        -:  957:#endif
    #####:  958:      current_directory[0] = '\0';
    #####:  959:      directory_before_chdir = 0;
        -:  960:    }
        -:  961:  else
      774:  962:    directory_before_chdir = xstrdup (current_directory);
call    0 returned 774
        -:  963:#ifdef  __MSDOS__
        -:  964:  /* Make sure we will return to the initial directory, come what may.  */
        -:  965:  atexit (msdos_return_to_initial_directory);
        -:  966:#endif
        -:  967:
        -:  968:  /* Read in variables from the environment.  It is important that this be
        -:  969:     done before $(MAKE) is figured out so its definitions will not be
        -:  970:     from the environment.  */
        -:  971:
        -:  972:#ifndef _AMIGA
    39474:  973:  for (i = 0; envp[i] != 0; ++i)
branch  0 taken 38700
branch  1 taken 774 (fallthrough)
        -:  974:    {
        -:  975:      int do_not_define;
    38700:  976:      register char *ep = envp[i];
        -:  977:
        -:  978:      /* by default, everything gets defined and exported */
    38700:  979:      do_not_define = 0;
        -:  980:
   503100:  981:      while (*ep != '=')
branch  0 taken 464400
branch  1 taken 38700 (fallthrough)
   464400:  982:        ++ep;
        -:  983:#ifdef WINDOWS32
        -:  984:      if (!unix_path && strneq(envp[i], "PATH=", 5))
        -:  985:        unix_path = ep+1;
        -:  986:      else if (!windows32_path && !strnicmp(envp[i], "Path=", 5)) {
        -:  987:        do_not_define = 1; /* it gets defined after loop exits */
        -:  988:        windows32_path = ep+1;
        -:  989:      }
        -:  990:#endif
        -:  991:      /* The result of pointer arithmetic is cast to unsigned int for
        -:  992:	 machines where ptrdiff_t is a different size that doesn't widen
        -:  993:	 the same.  */
    38700:  994:      if (!do_not_define)
branch  0 taken 38700 (fallthrough)
branch  1 taken 0
    38700:  995:        define_variable (envp[i], (unsigned int) (ep - envp[i]),
call    0 returned 38700
        -:  996:                         ep + 1, o_env, 1)
        -:  997:	/* Force exportation of every variable culled from the environment.
        -:  998:	   We used to rely on target_environment's v_default code to do this.
        -:  999:	   But that does not work for the case where an environment variable
        -: 1000:	   is redefined in a makefile with `override'; it should then still
        -: 1001:	   be exported, because it was originally in the environment.  */
    38700: 1002:	->export = v_export;
        -: 1003:    }
        -: 1004:#ifdef WINDOWS32
        -: 1005:    /*
        -: 1006:     * Make sure that this particular spelling of 'Path' is available
        -: 1007:     */
        -: 1008:    if (windows32_path)
        -: 1009:      define_variable("Path", 4, windows32_path, o_env, 1)->export = v_export;
        -: 1010:    else if (unix_path)
        -: 1011:      define_variable("Path", 4, unix_path, o_env, 1)->export = v_export;
        -: 1012:    else
        -: 1013:      define_variable("Path", 4, "", o_env, 1)->export = v_export;
        -: 1014:
        -: 1015:    /*
        -: 1016:     * PATH defaults to Path iff PATH not found and Path is found.
        -: 1017:     */
        -: 1018:    if (!unix_path && windows32_path)
        -: 1019:      define_variable("PATH", 4, windows32_path, o_env, 1)->export = v_export;
        -: 1020:#endif
        -: 1021:#else /* For Amiga, read the ENV: device, ignoring all dirs */
        -: 1022:    {
        -: 1023:	BPTR env, file, old;
        -: 1024:	char buffer[1024];
        -: 1025:	int len;
        -: 1026:	__aligned struct FileInfoBlock fib;
        -: 1027:
        -: 1028:	env = Lock ("ENV:", ACCESS_READ);
        -: 1029:	if (env)
        -: 1030:	{
        -: 1031:	    old = CurrentDir (DupLock(env));
        -: 1032:	    Examine (env, &fib);
        -: 1033:
        -: 1034:	    while (ExNext (env, &fib))
        -: 1035:	    {
        -: 1036:		if (fib.fib_DirEntryType < 0) /* File */
        -: 1037:		{
        -: 1038:		    /* Define an empty variable. It will be filled in
        -: 1039:			variable_lookup(). Makes startup quite a bit
        -: 1040:			faster. */
        -: 1041:			define_variable (fib.fib_FileName,
        -: 1042:			    strlen (fib.fib_FileName),
        -: 1043:			"", o_env, 1)->export = v_export;
        -: 1044:		}
        -: 1045:	    }
        -: 1046:	    UnLock (env);
        -: 1047:	    UnLock(CurrentDir(old));
        -: 1048:	}
        -: 1049:    }
        -: 1050:#endif
        -: 1051:
        -: 1052:  /* Decode the switches.  */
        -: 1053:
      774: 1054:  decode_env_switches ("MAKEFLAGS", 9);
call    0 returned 774
        -: 1055:#if 0
        -: 1056:  /* People write things like:
        -: 1057:     	MFLAGS="CC=gcc -pipe" "CFLAGS=-g"
        -: 1058:     and we set the -p, -i and -e switches.  Doesn't seem quite right.  */
        -: 1059:  decode_env_switches ("MFLAGS", 6);
        -: 1060:#endif
      774: 1061:  decode_switches (argc, argv, 0);
call    0 returned 774
        -: 1062:#ifdef WINDOWS32
        -: 1063:  if (suspend_flag) {
        -: 1064:        fprintf(stderr, "%s (pid = %d)\n", argv[0], GetCurrentProcessId());
        -: 1065:        fprintf(stderr, _("%s is suspending for 30 seconds..."), argv[0]);
        -: 1066:        Sleep(30 * 1000);
        -: 1067:        fprintf(stderr, _("done sleep(30). Continuing.\n"));
        -: 1068:  }
        -: 1069:#endif
        -: 1070:
        -: 1071:  /* Print version information.  */
        -: 1072:
      774: 1073:  if (print_version_flag || print_data_base_flag || debug_flag)
branch  0 taken 773 (fallthrough)
branch  1 taken 1
branch  2 taken 389 (fallthrough)
branch  3 taken 384
branch  4 taken 192 (fallthrough)
branch  5 taken 197
      577: 1074:    print_version ();
call    0 returned 577
        -: 1075:
        -: 1076:  /* `make --version' is supposed to just print the version and exit.  */
      774: 1077:  if (print_version_flag)
branch  0 taken 1 (fallthrough)
branch  1 taken 773
        1: 1078:    die (0);
call    0 returned 0
        -: 1079:
        -: 1080:#ifndef VMS
        -: 1081:  /* Set the "MAKE_COMMAND" variable to the name we were invoked with.
        -: 1082:     (If it is a relative pathname with a slash, prepend our directory name
        -: 1083:     so the result will run the same program regardless of the current dir.
        -: 1084:     If it is a name with no slash, we can only hope that PATH did not
        -: 1085:     find it in the current directory.)  */
        -: 1086:#ifdef WINDOWS32
        -: 1087:  /*
        -: 1088:   * Convert from backslashes to forward slashes for
        -: 1089:   * programs like sh which don't like them. Shouldn't
        -: 1090:   * matter if the path is one way or the other for
        -: 1091:   * CreateProcess().
        -: 1092:   */
        -: 1093:  if (strpbrk(argv[0], "/:\\") ||
        -: 1094:      strstr(argv[0], "..") ||
        -: 1095:      strneq(argv[0], "//", 2))
        -: 1096:    argv[0] = xstrdup(w32ify(argv[0],1));
        -: 1097:#else /* WINDOWS32 */
        -: 1098:#ifdef __MSDOS__
        -: 1099:  if (strchr (argv[0], '\\'))
        -: 1100:    {
        -: 1101:      char *p;
        -: 1102:
        -: 1103:      argv[0] = xstrdup (argv[0]);
        -: 1104:      for (p = argv[0]; *p; p++)
        -: 1105:	if (*p == '\\')
        -: 1106:	  *p = '/';
        -: 1107:    }
        -: 1108:  /* If argv[0] is not in absolute form, prepend the current
        -: 1109:     directory.  This can happen when Make is invoked by another DJGPP
        -: 1110:     program that uses a non-absolute name.  */
        -: 1111:  if (current_directory[0] != '\0'
        -: 1112:      && argv[0] != 0
        -: 1113:      && (argv[0][0] != '/' && (argv[0][0] == '\0' || argv[0][1] != ':')))
        -: 1114:    argv[0] = concat (current_directory, "/", argv[0]);
        -: 1115:#else  /* !__MSDOS__ */
      773: 1116:  if (current_directory[0] != '\0'
branch  0 taken 773 (fallthrough)
branch  1 taken 0
     773*: 1117:      && argv[0] != 0 && argv[0][0] != '/' && index (argv[0], '/') != 0)
branch  0 taken 773 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 773
branch  4 never executed
branch  5 never executed
    #####: 1118:    argv[0] = concat (current_directory, "/", argv[0]);
call    0 never executed
        -: 1119:#endif /* !__MSDOS__ */
        -: 1120:#endif /* WINDOWS32 */
        -: 1121:#endif
        -: 1122:
        -: 1123:  /* The extra indirection through $(MAKE_COMMAND) is done
        -: 1124:     for hysterical raisins.  */
      773: 1125:  (void) define_variable ("MAKE_COMMAND", 12, argv[0], o_default, 0);
call    0 returned 773
      773: 1126:  (void) define_variable ("MAKE", 4, "$(MAKE_COMMAND)", o_default, 1);
call    0 returned 773
        -: 1127:
      773: 1128:  if (command_variables != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 773
        -: 1129:    {
        -: 1130:      struct command_variable *cv;
        -: 1131:      struct variable *v;
    #####: 1132:      unsigned int len = 0;
        -: 1133:      char *value, *p;
        -: 1134:
        -: 1135:      /* Figure out how much space will be taken up by the command-line
        -: 1136:	 variable definitions.  */
    #####: 1137:      for (cv = command_variables; cv != 0; cv = cv->next)
branch  0 never executed
branch  1 never executed
        -: 1138:	{
    #####: 1139:	  v = cv->variable;
    #####: 1140:	  len += 2 * strlen (v->name);
    #####: 1141:	  if (! v->recursive)
branch  0 never executed
branch  1 never executed
    #####: 1142:	    ++len;
    #####: 1143:	  ++len;
    #####: 1144:	  len += 3 * strlen (v->value);
        -: 1145:	}
        -: 1146:
        -: 1147:      /* Now allocate a buffer big enough and fill it.  */
    #####: 1148:      p = value = (char *) alloca (len);
    #####: 1149:      for (cv = command_variables; cv != 0; cv = cv->next)
branch  0 never executed
branch  1 never executed
        -: 1150:	{
    #####: 1151:	  v = cv->variable;
    #####: 1152:	  p = quote_as_word (p, v->name, 0);
call    0 never executed
    #####: 1153:	  if (! v->recursive)
branch  0 never executed
branch  1 never executed
    #####: 1154:	    *p++ = ':';
    #####: 1155:	  *p++ = '=';
    #####: 1156:	  p = quote_as_word (p, v->value, 0);
call    0 never executed
    #####: 1157:	  *p++ = ' ';
        -: 1158:	}
    #####: 1159:      p[-1] = '\0';		/* Kill the final space and terminate.  */
        -: 1160:
        -: 1161:      /* Define an unchangeable variable with a name that no POSIX.2
        -: 1162:	 makefile could validly use for its own variable.  */
    #####: 1163:      (void) define_variable ("-*-command-variables-*-", 23,
call    0 never executed
        -: 1164:			      value, o_automatic, 0);
        -: 1165:
        -: 1166:      /* Define the variable; this will not override any user definition.
        -: 1167:         Normally a reference to this variable is written into the value of
        -: 1168:         MAKEFLAGS, allowing the user to override this value to affect the
        -: 1169:         exported value of MAKEFLAGS.  In POSIX-pedantic mode, we cannot
        -: 1170:         allow the user's setting of MAKEOVERRIDES to affect MAKEFLAGS, so
        -: 1171:         a reference to this hidden variable is written instead. */
    #####: 1172:      (void) define_variable ("MAKEOVERRIDES", 13,
call    0 never executed
        -: 1173:			      "${-*-command-variables-*-}", o_env, 1);
        -: 1174:    }
        -: 1175:
        -: 1176:  /* If there were -C flags, move ourselves about.  */
      773: 1177:  if (directories != 0)
branch  0 taken 2 (fallthrough)
branch  1 taken 771
        3: 1178:    for (i = 0; directories->list[i] != 0; ++i)
branch  0 taken 3
branch  1 taken 0 (fallthrough)
        -: 1179:      {
        3: 1180:	char *dir = directories->list[i];
        3: 1181:	if (dir[0] == '~')
branch  0 taken 0 (fallthrough)
branch  1 taken 3
        -: 1182:	  {
    #####: 1183:	    char *expanded = tilde_expand (dir);
call    0 never executed
    #####: 1184:	    if (expanded != 0)
branch  0 never executed
branch  1 never executed
    #####: 1185:	      dir = expanded;
        -: 1186:	  }
        3: 1187:	if (chdir (dir) < 0)
call    0 returned 3
branch  1 taken 2 (fallthrough)
branch  2 taken 1
        2: 1188:	  pfatal_with_name (dir);
call    0 returned 0
        1: 1189:	if (dir != directories->list[i])
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 1190:	  free (dir);
        -: 1191:      }
        -: 1192:
        -: 1193:#ifdef WINDOWS32
        -: 1194:  /*
        -: 1195:   * THIS BLOCK OF CODE MUST COME AFTER chdir() CALL ABOVE IN ORDER
        -: 1196:   * TO NOT CONFUSE THE DEPENDENCY CHECKING CODE IN implicit.c.
        -: 1197:   *
        -: 1198:   * The functions in dir.c can incorrectly cache information for "."
        -: 1199:   * before we have changed directory and this can cause file
        -: 1200:   * lookups to fail because the current directory (.) was pointing
        -: 1201:   * at the wrong place when it was first evaluated.
        -: 1202:   */
        -: 1203:   no_default_sh_exe = !find_and_set_default_shell(NULL);
        -: 1204:
        -: 1205:#endif /* WINDOWS32 */
        -: 1206:  /* Figure out the level of recursion.  */
        -: 1207:  {
      771: 1208:    struct variable *v = lookup_variable ("MAKELEVEL", 9);
call    0 returned 771
     771*: 1209:    if (v != 0 && *v->value != '\0' && *v->value != '-')
branch  0 taken 0 (fallthrough)
branch  1 taken 771
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1210:      makelevel = (unsigned int) atoi (v->value);
        -: 1211:    else
      771: 1212:      makelevel = 0;
        -: 1213:  }
        -: 1214:
        -: 1215:  /* Except under -s, always do -w in sub-makes and under -C.  */
      771: 1216:  if (!silent_flag && (directories != 0 || makelevel > 0))
branch  0 taken 387 (fallthrough)
branch  1 taken 384
branch  2 taken 387 (fallthrough)
branch  3 taken 0
branch  4 taken 0 (fallthrough)
branch  5 taken 387
    #####: 1217:    print_directory_flag = 1;
        -: 1218:
        -: 1219:  /* Let the user disable that with --no-print-directory.  */
      771: 1220:  if (inhibit_print_directory_flag)
branch  0 taken 0 (fallthrough)
branch  1 taken 771
    #####: 1221:    print_directory_flag = 0;
        -: 1222:
        -: 1223:  /* If -R was given, set -r too (doesn't make sense otherwise!)  */
      771: 1224:  if (no_builtin_variables_flag)
branch  0 taken 0 (fallthrough)
branch  1 taken 771
    #####: 1225:    no_builtin_rules_flag = 1;
        -: 1226:
        -: 1227:  /* Construct the list of include directories to search.  */
        -: 1228:
     771*: 1229:  construct_include_path (include_directories == 0 ? (char **) 0
branch  0 taken 0 (fallthrough)
branch  1 taken 771
call    2 returned 771
    #####: 1230:			  : include_directories->list);
        -: 1231:
        -: 1232:  /* Figure out where we are now, after chdir'ing.  */
      771: 1233:  if (directories == 0)
branch  0 taken 771 (fallthrough)
branch  1 taken 0
        -: 1234:    /* We didn't move, so we're still in the same place.  */
      771: 1235:    starting_directory = current_directory;
        -: 1236:  else
        -: 1237:    {
        -: 1238:#ifdef WINDOWS32
        -: 1239:      if (getcwd_fs (current_directory, GET_PATH_MAX) == 0)
        -: 1240:#else
    #####: 1241:      if (getcwd (current_directory, GET_PATH_MAX) == 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1242:#endif
        -: 1243:	{
        -: 1244:#ifdef	HAVE_GETCWD
    #####: 1245:	  perror_with_name ("getcwd: ", "");
call    0 never executed
        -: 1246:#else
        -: 1247:	  error (NILF, "getwd: %s", current_directory);
        -: 1248:#endif
    #####: 1249:	  starting_directory = 0;
        -: 1250:	}
        -: 1251:      else
    #####: 1252:	starting_directory = current_directory;
        -: 1253:    }
        -: 1254:
      771: 1255:  (void) define_variable ("CURDIR", 6, current_directory, o_default, 0);
call    0 returned 771
        -: 1256:
        -: 1257:  /* Read any stdin makefiles into temporary files.  */
        -: 1258:
      771: 1259:  if (makefiles != 0)
branch  0 taken 771 (fallthrough)
branch  1 taken 0
        -: 1260:    {
        -: 1261:      register unsigned int i;
     1542: 1262:      for (i = 0; i < makefiles->idx; ++i)
branch  0 taken 771
branch  1 taken 771 (fallthrough)
     771*: 1263:	if (makefiles->list[i][0] == '-' && makefiles->list[i][1] == '\0')
branch  0 taken 0 (fallthrough)
branch  1 taken 771
branch  2 never executed
branch  3 never executed
        -: 1264:	  {
        -: 1265:	    /* This makefile is standard input.  Since we may re-exec
        -: 1266:	       and thus re-read the makefiles, we read standard input
        -: 1267:	       into a temporary file and read from that.  */
        -: 1268:	    FILE *outfile;
        -: 1269:
        -: 1270:	    /* Make a unique filename.  */
        -: 1271:#ifdef HAVE_MKTEMP
        -: 1272:
        -: 1273:#ifdef VMS
        -: 1274:	    static char name[] = "sys$scratch:GmXXXXXX";
        -: 1275:#else
        -: 1276:	    static char name[] = "/tmp/GmXXXXXX";
        -: 1277:#endif
    #####: 1278:	    (void) mktemp (name);
call    0 never executed
        -: 1279:#else
        -: 1280:	    static char name[L_tmpnam];
        -: 1281:	    (void) tmpnam (name);
        -: 1282:#endif
        -: 1283:
    #####: 1284:            if (stdin_nm)
branch  0 never executed
branch  1 never executed
    #####: 1285:              fatal (NILF, _("Makefile from standard input specified twice."));
call    0 never executed
        -: 1286:
    #####: 1287:	    outfile = fopen (name, "w");
call    0 never executed
    #####: 1288:	    if (outfile == 0)
branch  0 never executed
branch  1 never executed
    #####: 1289:	      pfatal_with_name (_("fopen (temporary file)"));
call    0 never executed
    #####: 1290:	    while (!feof (stdin))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1291:	      {
        -: 1292:		char buf[2048];
    #####: 1293:		unsigned int n = fread (buf, 1, sizeof (buf), stdin);
call    0 never executed
    #####: 1294:		if (n > 0 && fwrite (buf, 1, n, outfile) != n)
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1295:		  pfatal_with_name (_("fwrite (temporary file)"));
call    0 never executed
        -: 1296:	      }
    #####: 1297:	    (void) fclose (outfile);
call    0 never executed
        -: 1298:
        -: 1299:	    /* Replace the name that read_all_makefiles will
        -: 1300:	       see with the name of the temporary file.  */
        -: 1301:	    {
        -: 1302:	      char *temp;
        -: 1303:	      /* SGI compiler requires alloca's result be assigned simply.  */
    #####: 1304:	      temp = (char *) alloca (sizeof (name));
    #####: 1305:	      bcopy (name, temp, sizeof (name));
    #####: 1306:	      makefiles->list[i] = temp;
        -: 1307:	    }
        -: 1308:
        -: 1309:	    /* Make sure the temporary file will not be remade.  */
    #####: 1310:            stdin_nm = savestring (name, sizeof (name) -1);
call    0 never executed
    #####: 1311:	    f = enter_file (stdin_nm);
call    0 never executed
    #####: 1312:	    f->updated = 1;
    #####: 1313:	    f->update_status = 0;
    #####: 1314:	    f->command_state = cs_finished;
        -: 1315: 	    /* Can't be intermediate, or it'll be removed too early for
        -: 1316:               make re-exec.  */
    #####: 1317: 	    f->intermediate = 0;
    #####: 1318:	    f->dontcare = 0;
        -: 1319:	  }
        -: 1320:    }
        -: 1321:
        -: 1322:#if defined(MAKE_JOBSERVER) || !defined(HAVE_WAIT_NOHANG)
        -: 1323:  /* Set up to handle children dying.  This must be done before
        -: 1324:     reading in the makefiles so that `shell' function calls will work.
        -: 1325:
        -: 1326:     If we don't have a hanging wait we have to fall back to old, broken
        -: 1327:     functionality here and rely on the signal handler and counting
        -: 1328:     children.
        -: 1329:
        -: 1330:     If we're using the jobs pipe we need a signal handler so that
        -: 1331:     SIGCHLD is not ignored; we need it to interrupt the read(2) of the
        -: 1332:     jobserver pipe in job.c if we're waiting for a token.
        -: 1333:
        -: 1334:     If none of these are true, we don't need a signal handler at all.  */
        -: 1335:  {
function child_handler called 0 returned 0% blocks executed 0%
    #####: 1336:    extern RETSIGTYPE child_handler PARAMS ((int sig));
        -: 1337:
        -: 1338:# if defined HAVE_SIGACTION
        -: 1339:    struct sigaction sa;
        -: 1340:
      771: 1341:    bzero ((char *)&sa, sizeof (struct sigaction));
      771: 1342:    sa.sa_handler = child_handler;
        -: 1343:#  if defined SA_INTERRUPT
        -: 1344:    /* This is supposed to be the default, but what the heck... */
      771: 1345:    sa.sa_flags = SA_INTERRUPT;
        -: 1346:#  endif
        -: 1347:#  define HANDLESIG(s) sigaction (s, &sa, NULL)
        -: 1348:# else
        -: 1349:#  define HANDLESIG(s) signal (s, child_handler)
        -: 1350:# endif
        -: 1351:
        -: 1352:    /* OK, now actually install the handlers.  */
        -: 1353:# if defined SIGCHLD
      771: 1354:    (void) HANDLESIG (SIGCHLD);
call    0 returned 771
        -: 1355:# endif
        -: 1356:# if defined SIGCLD && SIGCLD != SIGCHLD
        -: 1357:    (void) HANDLESIG (SIGCLD);
        -: 1358:# endif
        -: 1359:  }
        -: 1360:#endif
        -: 1361:
        -: 1362:  /* Let the user send us SIGUSR1 to toggle the -d flag during the run.  */
        -: 1363:#ifdef SIGUSR1
      771: 1364:  (void) signal (SIGUSR1, debug_signal_handler);
call    0 returned 771
        -: 1365:#endif
        -: 1366:
        -: 1367:  /* Define the initial list of suffixes for old-style rules.  */
        -: 1368:
      771: 1369:  set_default_suffixes ();
call    0 returned 771
        -: 1370:
        -: 1371:  /* Define the file rules for the built-in suffix rules.  These will later
        -: 1372:     be converted into pattern rules.  We used to do this in
        -: 1373:     install_default_implicit_rules, but since that happens after reading
        -: 1374:     makefiles, it results in the built-in pattern rules taking precedence
        -: 1375:     over makefile-specified suffix rules, which is wrong.  */
        -: 1376:
      771: 1377:  install_default_suffix_rules ();
call    0 returned 771
        -: 1378:
        -: 1379:  /* Define some internal and special variables.  */
        -: 1380:
      771: 1381:  define_automatic_variables ();
call    0 returned 771
        -: 1382:
        -: 1383:  /* Set up the MAKEFLAGS and MFLAGS variables
        -: 1384:     so makefiles can look at them.  */
        -: 1385:
      771: 1386:  define_makeflags (0, 0);
call    0 returned 771
        -: 1387:
        -: 1388:  /* Define the default variables.  */
      771: 1389:  define_default_variables ();
call    0 returned 771
        -: 1390:
        -: 1391:  /* Read all the makefiles.  */
        -: 1392:
      771: 1393:  default_file = enter_file (".DEFAULT");
call    0 returned 771
        -: 1394:
        -: 1395:  read_makefiles
     771*: 1396:    = read_all_makefiles (makefiles == 0 ? (char **) 0 : makefiles->list);
branch  0 taken 771 (fallthrough)
branch  1 taken 0
call    2 returned 771
        -: 1397:
        -: 1398:#ifdef WINDOWS32
        -: 1399:  /* look one last time after reading all Makefiles */
        -: 1400:  if (no_default_sh_exe)
        -: 1401:    no_default_sh_exe = !find_and_set_default_shell(NULL);
        -: 1402:
        -: 1403:  if (no_default_sh_exe && job_slots != 1) {
        -: 1404:    error (NILF, _("Do not specify -j or --jobs if sh.exe is not available."));
        -: 1405:    error (NILF, _("Resetting make for single job mode."));
        -: 1406:    job_slots = 1;
        -: 1407:  }
        -: 1408:#endif /* WINDOWS32 */
        -: 1409:
        -: 1410:#ifdef __MSDOS__
        -: 1411:  /* We need to know what kind of shell we will be using.  */
        -: 1412:  {
        -: 1413:    extern int _is_unixy_shell (const char *_path);
        -: 1414:    struct variable *shv = lookup_variable ("SHELL", 5);
        -: 1415:    extern int unixy_shell;
        -: 1416:    extern char *default_shell;
        -: 1417:
        -: 1418:    if (shv && *shv->value)
        -: 1419:      {
        -: 1420:	char *shell_path = recursively_expand(shv);
        -: 1421:
        -: 1422:	if (shell_path && _is_unixy_shell (shell_path))
        -: 1423:	  unixy_shell = 1;
        -: 1424:	else
        -: 1425:	  unixy_shell = 0;
        -: 1426:	if (shell_path)
        -: 1427:	  default_shell = shell_path;
        -: 1428:      }
        -: 1429:  }
        -: 1430:#endif /* __MSDOS__ */
        -: 1431:
        -: 1432:  /* Decode switches again, in case the variables were set by the makefile.  */
      771: 1433:  decode_env_switches ("MAKEFLAGS", 9);
call    0 returned 771
        -: 1434:#if 0
        -: 1435:  decode_env_switches ("MFLAGS", 6);
        -: 1436:#endif
        -: 1437:
        -: 1438:#ifdef __MSDOS__
        -: 1439:  if (job_slots != 1)
        -: 1440:    {
        -: 1441:      error (NILF,
        -: 1442:             _("Parallel jobs (-j) are not supported on this platform."));
        -: 1443:      error (NILF, _("Resetting to single job (-j1) mode."));
        -: 1444:      job_slots = 1;
        -: 1445:    }
        -: 1446:#endif
        -: 1447:
        -: 1448:#ifdef MAKE_JOBSERVER
        -: 1449:  /* If the jobserver-fds option is seen, make sure that -j is reasonable.  */
        -: 1450:
      771: 1451:  if (jobserver_fds)
branch  0 taken 0 (fallthrough)
branch  1 taken 771
        -: 1452:  {
        -: 1453:    char *cp;
        -: 1454:
    #####: 1455:    for (i=1; i < jobserver_fds->idx; ++i)
branch  0 never executed
branch  1 never executed
    #####: 1456:      if (!streq (jobserver_fds->list[0], jobserver_fds->list[i]))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####: 1457:        fatal (NILF, _("internal error: multiple --jobserver-fds options"));
call    0 never executed
        -: 1458:
        -: 1459:    /* Now parse the fds string and make sure it has the proper format.  */
        -: 1460:
    #####: 1461:    cp = jobserver_fds->list[0];
        -: 1462:
    #####: 1463:    if (sscanf (cp, "%d,%d", &job_fds[0], &job_fds[1]) != 2)
branch  0 never executed
branch  1 never executed
    #####: 1464:      fatal (NILF,
call    0 never executed
        -: 1465:             _("internal error: invalid --jobserver-fds string `%s'"), cp);
        -: 1466:
        -: 1467:    /* The combination of a pipe + !job_slots means we're using the
        -: 1468:       jobserver.  If !job_slots and we don't have a pipe, we can start
        -: 1469:       infinite jobs.  If we see both a pipe and job_slots >0 that means the
        -: 1470:       user set -j explicitly.  This is broken; in this case obey the user
        -: 1471:       (ignore the jobserver pipe for this make) but print a message.  */
        -: 1472:
    #####: 1473:    if (job_slots > 0)
branch  0 never executed
branch  1 never executed
    #####: 1474:      error (NILF,
call    0 never executed
        -: 1475:             _("warning: -jN forced in submake: disabling jobserver mode."));
        -: 1476:
        -: 1477:    /* Create a duplicate pipe, that will be closed in the SIGCHLD
        -: 1478:       handler.  If this fails with EBADF, the parent has closed the pipe
        -: 1479:       on us because it didn't think we were a submake.  If so, print a
        -: 1480:       warning then default to -j1.  */
        -: 1481:
    #####: 1482:    else if ((job_rfd = dup (job_fds[0])) < 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1483:      {
    #####: 1484:        if (errno != EBADF)
branch  0 never executed
branch  1 never executed
    #####: 1485:          pfatal_with_name (_("dup jobserver"));
call    0 never executed
        -: 1486:
    #####: 1487:        error (NILF,
call    0 never executed
        -: 1488:               _("warning: jobserver unavailable: using -j1.  Add `+' to parent make rule."));
    #####: 1489:        job_slots = 1;
        -: 1490:      }
        -: 1491:
    #####: 1492:    if (job_slots > 0)
branch  0 never executed
branch  1 never executed
        -: 1493:      {
    #####: 1494:        close (job_fds[0]);
call    0 never executed
    #####: 1495:        close (job_fds[1]);
call    0 never executed
    #####: 1496:        job_fds[0] = job_fds[1] = -1;
    #####: 1497:        free (jobserver_fds->list);
    #####: 1498:        free (jobserver_fds);
    #####: 1499:        jobserver_fds = 0;
        -: 1500:      }
        -: 1501:  }
        -: 1502:
        -: 1503:  /* If we have >1 slot but no jobserver-fds, then we're a top-level make.
        -: 1504:     Set up the pipe and install the fds option for our children.  */
        -: 1505:
      771: 1506:  if (job_slots > 1)
branch  0 taken 0 (fallthrough)
branch  1 taken 771
        -: 1507:    {
    #####: 1508:      char c = '+';
        -: 1509:
    #####: 1510:      if (pipe (job_fds) < 0 || (job_rfd = dup (job_fds[0])) < 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1511:	pfatal_with_name (_("creating jobs pipe"));
call    0 never executed
        -: 1512:
        -: 1513:      /* Every make assumes that it always has one job it can run.  For the
        -: 1514:         submakes it's the token they were given by their parent.  For the
        -: 1515:         top make, we just subtract one from the number the user wants.  We
        -: 1516:         want job_slots to be 0 to indicate we're using the jobserver.  */
        -: 1517:
    #####: 1518:      while (--job_slots)
branch  0 never executed
branch  1 never executed
    #####: 1519:        while (write (job_fds[1], &c, 1) != 1)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1520:          if (!EINTR_SET)
branch  0 never executed
branch  1 never executed
    #####: 1521:            pfatal_with_name (_("init jobserver pipe"));
call    0 never executed
        -: 1522:
        -: 1523:      /* Fill in the jobserver_fds struct for our children.  */
        -: 1524:
    #####: 1525:      jobserver_fds = (struct stringlist *)
    #####: 1526:                        xmalloc (sizeof (struct stringlist));
call    0 never executed
    #####: 1527:      jobserver_fds->list = (char **) xmalloc (sizeof (char *));
call    0 never executed
    #####: 1528:      jobserver_fds->list[0] = xmalloc ((sizeof ("1024")*2)+1);
call    0 never executed
        -: 1529:
    #####: 1530:      sprintf (jobserver_fds->list[0], "%d,%d", job_fds[0], job_fds[1]);
    #####: 1531:      jobserver_fds->idx = 1;
    #####: 1532:      jobserver_fds->max = 1;
        -: 1533:    }
        -: 1534:#endif
        -: 1535:
        -: 1536:  /* Set up MAKEFLAGS and MFLAGS again, so they will be right.  */
        -: 1537:
      771: 1538:  define_makeflags (1, 0);
call    0 returned 771
        -: 1539:
        -: 1540:  /* Make each `struct dep' point at the `struct file' for the file
        -: 1541:     depended on.  Also do magic for special targets.  */
        -: 1542:
      771: 1543:  snap_deps ();
call    0 returned 771
        -: 1544:
        -: 1545:  /* Convert old-style suffix rules to pattern rules.  It is important to
        -: 1546:     do this before installing the built-in pattern rules below, so that
        -: 1547:     makefile-specified suffix rules take precedence over built-in pattern
        -: 1548:     rules.  */
        -: 1549:
      771: 1550:  convert_to_pattern ();
call    0 returned 771
        -: 1551:
        -: 1552:  /* Install the default implicit pattern rules.
        -: 1553:     This used to be done before reading the makefiles.
        -: 1554:     But in that case, built-in pattern rules were in the chain
        -: 1555:     before user-defined ones, so they matched first.  */
        -: 1556:
      771: 1557:  install_default_implicit_rules ();
call    0 returned 771
        -: 1558:
        -: 1559:  /* Compute implicit rule limits.  */
        -: 1560:
      771: 1561:  count_implicit_rule_limits ();
call    0 returned 771
        -: 1562:
        -: 1563:  /* Construct the listings of directories in VPATH lists.  */
        -: 1564:
      771: 1565:  build_vpath_lists ();
call    0 returned 771
        -: 1566:
        -: 1567:  /* Mark files given with -o flags as very old (00:00:01.00 Jan 1, 1970)
        -: 1568:     and as having been updated already, and files given with -W flags as
        -: 1569:     brand new (time-stamp as far as possible into the future).  */
        -: 1570:
      771: 1571:  if (old_files != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 771
    #####: 1572:    for (p = old_files->list; *p != 0; ++p)
branch  0 never executed
branch  1 never executed
        -: 1573:      {
    #####: 1574:	f = enter_command_line_file (*p);
call    0 never executed
        -: 1575:#ifndef F_JR_1  /* seeded fault #1; J.Ruthruff */
    #####: 1576:	f->last_mtime = f->mtime_before_update = (FILE_TIMESTAMP) 1;
        -: 1577:#else
        -: 1578:    f->last_mtime = (time_t) 1;
        -: 1579:#endif
    #####: 1580:	f->updated = 1;
    #####: 1581:	f->update_status = 0;
    #####: 1582:	f->command_state = cs_finished;
        -: 1583:      }
        -: 1584:
      771: 1585:  if (new_files != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 771
        -: 1586:    {
    #####: 1587:      for (p = new_files->list; *p != 0; ++p)
branch  0 never executed
branch  1 never executed
        -: 1588:	{
    #####: 1589:	  f = enter_command_line_file (*p);
call    0 never executed
    #####: 1590:	  f->last_mtime = f->mtime_before_update = NEW_MTIME;
        -: 1591:	}
        -: 1592:    }
        -: 1593:
        -: 1594:  /* Initialize the remote job module.  */
      771: 1595:  remote_setup ();
call    0 returned 771
        -: 1596:
      771: 1597:  if (read_makefiles != 0)
branch  0 taken 771 (fallthrough)
branch  1 taken 0
        -: 1598:    {
        -: 1599:      /* Update any makefiles if necessary.  */
        -: 1600:
      771: 1601:      FILE_TIMESTAMP *makefile_mtimes = 0;
      771: 1602:      unsigned int mm_idx = 0;
      771: 1603:      char **nargv = argv;
      771: 1604:      int nargc = argc;
        -: 1605:
      771: 1606:      if (debug_flag)
branch  0 taken 384 (fallthrough)
branch  1 taken 387
      384: 1607:	puts (_("Updating makefiles...."));
call    0 returned 384
        -: 1608:
        -: 1609:      /* Remove any makefiles we don't want to try to update.
        -: 1610:	 Also record the current modtimes so we can compare them later.  */
        -: 1611:      {
        -: 1612:	register struct dep *d, *last;
      771: 1613:	last = 0;
      771: 1614:	d = read_makefiles;
     1542: 1615:	while (d != 0)
branch  0 taken 771
branch  1 taken 771 (fallthrough)
        -: 1616:	  {
      771: 1617:	    register struct file *f = d->file;
      771: 1618:	    if (f->double_colon)
branch  0 taken 0 (fallthrough)
branch  1 taken 771
    #####: 1619:	      for (f = f->double_colon; f != NULL; f = f->prev)
branch  0 never executed
branch  1 never executed
        -: 1620:		{
    #####: 1621:		  if (f->deps == 0 && f->cmds != 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1622:		    {
        -: 1623:		      /* This makefile is a :: target with commands, but
        -: 1624:			 no dependencies.  So, it will always be remade.
        -: 1625:			 This might well cause an infinite loop, so don't
        -: 1626:			 try to remake it.  (This will only happen if
        -: 1627:			 your makefiles are written exceptionally
        -: 1628:			 stupidly; but if you work for Athena, that's how
        -: 1629:			 you write your makefiles.)  */
        -: 1630:
    #####: 1631:		      if (debug_flag)
branch  0 never executed
branch  1 never executed
    #####: 1632:			printf (_("Makefile `%s' might loop; not remaking it.\n"),
call    0 never executed
        -: 1633:				f->name);
        -: 1634:
    #####: 1635:		      if (last == 0)
branch  0 never executed
branch  1 never executed
    #####: 1636:			read_makefiles = d->next;
        -: 1637:		      else
    #####: 1638:			last->next = d->next;
        -: 1639:
        -: 1640:		      /* Free the storage.  */
    #####: 1641:		      free ((char *) d);
        -: 1642:
    #####: 1643:		      d = last == 0 ? read_makefiles : last->next;
branch  0 never executed
branch  1 never executed
        -: 1644:
    #####: 1645:		      break;
        -: 1646:		    }
        -: 1647:		}
      771: 1648:	    if (f == NULL || !f->double_colon)
branch  0 taken 771 (fallthrough)
branch  1 taken 0
branch  2 taken 771 (fallthrough)
branch  3 taken 0
        -: 1649:	      {
        -: 1650:                makefile_mtimes = (FILE_TIMESTAMP *)
      771: 1651:                  xrealloc ((char *) makefile_mtimes,
      771: 1652:                            (mm_idx + 1) * sizeof (FILE_TIMESTAMP));
call    0 returned 771
     771*: 1653:		makefile_mtimes[mm_idx++] = file_mtime_no_search (d->file);
branch  0 taken 0 (fallthrough)
branch  1 taken 771
call    2 returned 771
      771: 1654:		last = d;
      771: 1655:		d = d->next;
        -: 1656:	      }
        -: 1657:	  }
        -: 1658:      }
        -: 1659:
        -: 1660:      /* Set up `MAKEFLAGS' specially while remaking makefiles.  */
      771: 1661:      define_makeflags (1, 1);
call    0 returned 771
        -: 1662:
      771: 1663:      switch (update_goal_chain (read_makefiles, 1))
call    0 returned 256
branch  1 taken 0
branch  2 taken 0
branch  3 taken 256
branch  4 taken 0
        -: 1664:	{
    #####: 1665:	case 1:
        -: 1666:	default:
        -: 1667:#define BOGUS_UPDATE_STATUS 0
    #####: 1668:	  assert (BOGUS_UPDATE_STATUS);
call    0 never executed
        -: 1669:	  break;
        -: 1670:
    #####: 1671:	case -1:
        -: 1672:	  /* Did nothing.  */
    #####: 1673:	  break;
        -: 1674:
      256: 1675:	case 2:
        -: 1676:	  /* Failed to update.  Figure out if we care.  */
        -: 1677:	  {
        -: 1678:	    /* Nonzero if any makefile was successfully remade.  */
      256: 1679:	    int any_remade = 0;
        -: 1680:	    /* Nonzero if any makefile we care about failed
        -: 1681:	       in updating or could not be found at all.  */
      256: 1682:	    int any_failed = 0;
        -: 1683:	    register unsigned int i;
        -: 1684:            struct dep *d;
        -: 1685:
      512: 1686:	    for (i = 0, d = read_makefiles; d != 0; ++i, d = d->next)
branch  0 taken 256
branch  1 taken 256 (fallthrough)
        -: 1687:              {
        -: 1688:                /* Reset the considered flag; we may need to look at the file
        -: 1689:                   again to print an error.  */
      256: 1690:                d->file->considered = 0;
        -: 1691:
      256: 1692:                if (d->file->updated)
branch  0 taken 256 (fallthrough)
branch  1 taken 0
        -: 1693:                  {
        -: 1694:                    /* This makefile was updated.  */
      256: 1695:                    if (d->file->update_status == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 256
        -: 1696:                      {
        -: 1697:                        /* It was successfully updated.  */
    #####: 1698:                        any_remade |= (file_mtime_no_search (d->file)
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1699:                                       != makefile_mtimes[i]);
        -: 1700:                      }
      256: 1701:                    else if (! (d->changed & RM_DONTCARE))
branch  0 taken 256 (fallthrough)
branch  1 taken 0
        -: 1702:                      {
        -: 1703:                        FILE_TIMESTAMP mtime;
        -: 1704:                        /* The update failed and this makefile was not
        -: 1705:                           from the MAKEFILES variable, so we care.  */
      256: 1706:                        error (NILF, _("Failed to remake makefile `%s'."),
      256: 1707:                               d->file->name);
call    0 returned 256
     256*: 1708:                        mtime = file_mtime_no_search (d->file);
branch  0 taken 256 (fallthrough)
branch  1 taken 0
call    2 never executed
      256: 1709:                        any_remade |= (mtime != (FILE_TIMESTAMP) -1
     256*: 1710:                                       && mtime != makefile_mtimes[i]);
branch  0 taken 0 (fallthrough)
branch  1 taken 256
branch  2 never executed
branch  3 never executed
        -: 1711:                      }
        -: 1712:                  }
        -: 1713:                else
        -: 1714:                  /* This makefile was not found at all.  */
    #####: 1715:                  if (! (d->changed & RM_DONTCARE))
branch  0 never executed
branch  1 never executed
        -: 1716:                    {
        -: 1717:                      /* This is a makefile we care about.  See how much.  */
    #####: 1718:                      if (d->changed & RM_INCLUDED)
branch  0 never executed
branch  1 never executed
        -: 1719:                        /* An included makefile.  We don't need
        -: 1720:                           to die, but we do want to complain.  */
    #####: 1721:                        error (NILF,
call    0 never executed
        -: 1722:                               _("Included makefile `%s' was not found."),
    #####: 1723:                               dep_name (d));
branch  0 never executed
branch  1 never executed
        -: 1724:                      else
        -: 1725:                        {
        -: 1726:                          /* A normal makefile.  We must die later.  */
    #####: 1727:                          error (NILF, _("Makefile `%s' was not found"),
call    0 never executed
    #####: 1728:                                 dep_name (d));
branch  0 never executed
branch  1 never executed
    #####: 1729:                          any_failed = 1;
        -: 1730:                        }
        -: 1731:                    }
        -: 1732:              }
        -: 1733:            /* Reset this to empty so we get the right error message below.  */
      256: 1734:            read_makefiles = 0;
        -: 1735:
      256: 1736:	    if (any_remade)
branch  0 taken 0 (fallthrough)
branch  1 taken 256
    #####: 1737:	      goto re_exec;
      256: 1738:	    if (any_failed)
branch  0 taken 0 (fallthrough)
branch  1 taken 256
    #####: 1739:	      die (2);
call    0 never executed
      256: 1740:            break;
        -: 1741:	  }
        -: 1742:
        -: 1743:	case 0:
    #####: 1744:	re_exec:
        -: 1745:	  /* Updated successfully.  Re-exec ourselves.  */
        -: 1746:
    #####: 1747:	  remove_intermediates (0);
call    0 never executed
        -: 1748:
    #####: 1749:	  if (print_data_base_flag)
branch  0 never executed
branch  1 never executed
    #####: 1750:	    print_data_base ();
call    0 never executed
        -: 1751:
    #####: 1752:	  log_working_directory (0);
call    0 never executed
        -: 1753:
    #####: 1754:	  if (makefiles != 0)
branch  0 never executed
branch  1 never executed
        -: 1755:	    {
        -: 1756:	      /* These names might have changed.  */
    #####: 1757:	      register unsigned int i, j = 0;
    #####: 1758:	      for (i = 1; i < argc; ++i)
branch  0 never executed
branch  1 never executed
    #####: 1759:		if (strneq (argv[i], "-f", 2)) /* XXX */
branch  0 never executed
branch  1 never executed
        -: 1760:		  {
    #####: 1761:		    char *p = &argv[i][2];
    #####: 1762:		    if (*p == '\0')
branch  0 never executed
branch  1 never executed
    #####: 1763:		      argv[++i] = makefiles->list[j];
        -: 1764:		    else
    #####: 1765:		      argv[i] = concat ("-f", makefiles->list[j], "");
call    0 never executed
    #####: 1766:		    ++j;
        -: 1767:		  }
        -: 1768:	    }
        -: 1769:
        -: 1770:          /* Add -o option for the stdin temporary file, if necessary.  */
    #####: 1771:          if (stdin_nm)
branch  0 never executed
branch  1 never executed
        -: 1772:            {
    #####: 1773:              nargv = (char **) xmalloc ((nargc + 2) * sizeof (char *));
call    0 never executed
    #####: 1774:              bcopy ((char *) argv, (char *) nargv, argc * sizeof (char *));
    #####: 1775:              nargv[nargc++] = concat ("-o", stdin_nm, "");
call    0 never executed
    #####: 1776:              nargv[nargc] = 0;
        -: 1777:            }
        -: 1778:
    #####: 1779:	  if (directories != 0 && directories->idx > 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1780:	    {
        -: 1781:	      char bad;
    #####: 1782:	      if (directory_before_chdir != 0)
branch  0 never executed
branch  1 never executed
        -: 1783:		{
    #####: 1784:		  if (chdir (directory_before_chdir) < 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1785:		    {
    #####: 1786:		      perror_with_name ("chdir", "");
call    0 never executed
    #####: 1787:		      bad = 1;
        -: 1788:		    }
        -: 1789:		  else
    #####: 1790:		    bad = 0;
        -: 1791:		}
        -: 1792:	      else
    #####: 1793:		bad = 1;
    #####: 1794:	      if (bad)
branch  0 never executed
branch  1 never executed
    #####: 1795:		fatal (NILF, _("Couldn't change back to original directory."));
call    0 never executed
        -: 1796:	    }
        -: 1797:
        -: 1798:#ifndef _AMIGA
    #####: 1799:	  for (p = environ; *p != 0; ++p)
branch  0 never executed
branch  1 never executed
    #####: 1800:	    if (strneq (*p, "MAKELEVEL=", 10))
branch  0 never executed
branch  1 never executed
        -: 1801:	      {
        -: 1802:		/* The SGI compiler apparently can't understand
        -: 1803:		   the concept of storing the result of a function
        -: 1804:		   in something other than a local variable.  */
        -: 1805:		char *sgi_loses;
    #####: 1806:		sgi_loses = (char *) alloca (40);
    #####: 1807:		*p = sgi_loses;
    #####: 1808:		sprintf (*p, "MAKELEVEL=%u", makelevel);
    #####: 1809:		break;
        -: 1810:	      }
        -: 1811:#else /* AMIGA */
        -: 1812:	  {
        -: 1813:	    char buffer[256];
        -: 1814:	    int len;
        -: 1815:
        -: 1816:	    len = GetVar ("MAKELEVEL", buffer, sizeof (buffer), GVF_GLOBAL_ONLY);
        -: 1817:
        -: 1818:	    if (len != -1)
        -: 1819:	    {
        -: 1820:	    sprintf (buffer, "%u", makelevel);
        -: 1821:	      SetVar ("MAKELEVEL", buffer, -1, GVF_GLOBAL_ONLY);
        -: 1822:	    }
        -: 1823:	  }
        -: 1824:#endif
        -: 1825:
    #####: 1826:	  if (debug_flag)
branch  0 never executed
branch  1 never executed
        -: 1827:	    {
        -: 1828:	      char **p;
    #####: 1829:	      fputs (_("Re-executing:"), stdout);
call    0 never executed
    #####: 1830:	      for (p = nargv; *p != 0; ++p)
branch  0 never executed
branch  1 never executed
    #####: 1831:		printf (" %s", *p);
call    0 never executed
    #####: 1832:	      puts ("");
call    0 never executed
        -: 1833:	    }
        -: 1834:
    #####: 1835:	  fflush (stdout);
call    0 never executed
    #####: 1836:	  fflush (stderr);
call    0 never executed
        -: 1837:
        -: 1838:          /* Close the dup'd jobserver pipe if we opened one.  */
    #####: 1839:          if (job_rfd >= 0)
branch  0 never executed
branch  1 never executed
    #####: 1840:            close (job_rfd);
call    0 never executed
        -: 1841:
        -: 1842:#ifndef _AMIGA
    #####: 1843:	  exec_command (nargv, environ);
call    0 never executed
        -: 1844:#else
        -: 1845:	  exec_command (nargv);
        -: 1846:	  exit (0);
        -: 1847:#endif
        -: 1848:	  /* NOTREACHED */
        -: 1849:	}
        -: 1850:    }
        -: 1851:
        -: 1852:  /* Set up `MAKEFLAGS' again for the normal targets.  */
      256: 1853:  define_makeflags (1, 0);
call    0 returned 256
        -: 1854:
        -: 1855:  /* If there is a temp file from reading a makefile from stdin, get rid of
        -: 1856:     it now.  */
     256*: 1857:  if (stdin_nm && unlink (stdin_nm) < 0 && errno != ENOENT)
branch  0 taken 0 (fallthrough)
branch  1 taken 256
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####: 1858:    perror_with_name (_("unlink (temporary file): "), stdin_nm);
call    0 never executed
        -: 1859:
        -: 1860:  {
        -: 1861:    int status;
        -: 1862:
        -: 1863:    /* If there were no command-line goals, use the default.  */
      256: 1864:    if (goals == 0)
branch  0 taken 256 (fallthrough)
branch  1 taken 0
        -: 1865:      {
      256: 1866:	if (default_goal_file != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 256
        -: 1867:	  {
    #####: 1868:	    goals = (struct dep *) xmalloc (sizeof (struct dep));
call    0 never executed
    #####: 1869:	    goals->next = 0;
    #####: 1870:	    goals->name = 0;
    #####: 1871:	    goals->file = default_goal_file;
        -: 1872:	  }
        -: 1873:      }
        -: 1874:    else
    #####: 1875:      lastgoal->next = 0;
        -: 1876:
      256: 1877:    if (!goals)
branch  0 taken 256 (fallthrough)
branch  1 taken 0
        -: 1878:      {
      256: 1879:        if (read_makefiles == 0)
branch  0 taken 256 (fallthrough)
branch  1 taken 0
      256: 1880:          fatal (NILF, _("No targets specified and no makefile found"));
call    0 returned 0
        -: 1881:
    #####: 1882:        fatal (NILF, _("No targets"));
call    0 never executed
        -: 1883:      }
        -: 1884:
        -: 1885:    /* Update the goals.  */
        -: 1886:
    #####: 1887:    if (debug_flag)
branch  0 never executed
branch  1 never executed
    #####: 1888:      puts (_("Updating goal targets...."));
call    0 never executed
        -: 1889:
    #####: 1890:    switch (update_goal_chain (goals, 0))
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -: 1891:    {
    #####: 1892:      case -1:
        -: 1893:        /* Nothing happened.  */
        -: 1894:      case 0:
        -: 1895:        /* Updated successfully.  */
    #####: 1896:        status = EXIT_SUCCESS;
    #####: 1897:        break;
    #####: 1898:      case 2:
        -: 1899:        /* Updating failed.  POSIX.2 specifies exit status >1 for this;
        -: 1900:           but in VMS, there is only success and failure.  */
    #####: 1901:        status = EXIT_FAILURE ? 2 : EXIT_FAILURE;
    #####: 1902:        break;
    #####: 1903:      case 1:
        -: 1904:        /* We are under -q and would run some commands.  */
    #####: 1905:        status = EXIT_FAILURE;
    #####: 1906:        break;
    #####: 1907:      default:
    #####: 1908:        abort ();
call    0 never executed
        -: 1909:    }
        -: 1910:
        -: 1911:    /* If we detected some clock skew, generate one last warning */
    #####: 1912:    if (clock_skew_detected)
branch  0 never executed
branch  1 never executed
    #####: 1913:      error (NILF, _("*** Warning:  Clock skew detected.  Your build may be incomplete."));
call    0 never executed
        -: 1914:
        -: 1915:    /* Exit.  */
    #####: 1916:    die (status);
        -: 1917:  }
        -: 1918:
        -: 1919:  return 0;
        -: 1920:}
        -: 1921:
        -: 1922:/* Parsing of arguments, decoding of switches.  */
        -: 1923:
        -: 1924:static char options[1 + sizeof (switches) / sizeof (switches[0]) * 3];
        -: 1925:static struct option long_options[(sizeof (switches) / sizeof (switches[0])) +
        -: 1926:				  (sizeof (long_option_aliases) /
        -: 1927:				   sizeof (long_option_aliases[0]))];
        -: 1928:
        -: 1929:/* Fill in the string and vector for getopt.  */
        -: 1930:static void
function init_switches called 1538 returned 100% blocks executed 100%
     1538: 1931:init_switches ()
        -: 1932:{
        -: 1933:  register char *p;
        -: 1934:  register int c;
        -: 1935:  register unsigned int i;
        -: 1936:
     1538: 1937:  if (options[0] != '\0')
branch  0 taken 764 (fallthrough)
branch  1 taken 774
        -: 1938:    /* Already done.  */
      764: 1939:    return;
        -: 1940:
      774: 1941:  p = options;
        -: 1942:
        -: 1943:  /* Return switch and non-switch args in order, regardless of
        -: 1944:     POSIXLY_CORRECT.  Non-switch args are returned as option 1.  */
      774: 1945:  *p++ = '-';
        -: 1946:
    21672: 1947:  for (i = 0; switches[i].c != '\0'; ++i)
branch  0 taken 20898
branch  1 taken 774 (fallthrough)
        -: 1948:    {
    20898: 1949:      long_options[i].name = (switches[i].long_name == 0 ? "" :
branch  0 taken 19350 (fallthrough)
branch  1 taken 1548
        -: 1950:			      switches[i].long_name);
    20898: 1951:      long_options[i].flag = 0;
    20898: 1952:      long_options[i].val = switches[i].c;
    20898: 1953:      if (short_option (switches[i].c))
branch  0 taken 18576 (fallthrough)
branch  1 taken 2322
    18576: 1954:	*p++ = switches[i].c;
    20898: 1955:      switch (switches[i].type)
branch  0 taken 14706
branch  1 taken 6192
branch  2 taken 0
        -: 1956:	{
    14706: 1957:	case flag:
        -: 1958:	case flag_off:
        -: 1959:	case ignore:
    14706: 1960:	  long_options[i].has_arg = no_argument;
    14706: 1961:	  break;
        -: 1962:
     6192: 1963:	case string:
        -: 1964:	case positive_int:
        -: 1965:	case floating:
     6192: 1966:	  if (short_option (switches[i].c))
branch  0 taken 5418 (fallthrough)
branch  1 taken 774
     5418: 1967:	    *p++ = ':';
     6192: 1968:	  if (switches[i].noarg_value != 0)
branch  0 taken 1548 (fallthrough)
branch  1 taken 4644
        -: 1969:	    {
     1548: 1970:	      if (short_option (switches[i].c))
branch  0 taken 1548 (fallthrough)
branch  1 taken 0
     1548: 1971:		*p++ = ':';
     1548: 1972:	      long_options[i].has_arg = optional_argument;
        -: 1973:	    }
        -: 1974:	  else
     4644: 1975:	    long_options[i].has_arg = required_argument;
     6192: 1976:	  break;
        -: 1977:	}
        -: 1978:    }
      774: 1979:  *p = '\0';
     7740: 1980:  for (c = 0; c < (sizeof (long_option_aliases) /
branch  0 taken 6966
branch  1 taken 774 (fallthrough)
        -: 1981:		   sizeof (long_option_aliases[0]));
     6966: 1982:       ++c)
     6966: 1983:    long_options[i++] = long_option_aliases[c];
      774: 1984:  long_options[i].name = 0;
        -: 1985:}
        -: 1986:
        -: 1987:static void
function handle_non_switch_argument called 0 returned 0% blocks executed 0%
    #####: 1988:handle_non_switch_argument (arg, env)
        -: 1989:     char *arg;
        -: 1990:     int env;
        -: 1991:{
        -: 1992:  /* Non-option argument.  It might be a variable definition.  */
        -: 1993:  struct variable *v;
    #####: 1994:  if (arg[0] == '-' && arg[1] == '\0')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1995:    /* Ignore plain `-' for compatibility.  */
    #####: 1996:    return;
    #####: 1997:  v = try_variable_definition (0, arg, o_command);
call    0 never executed
    #####: 1998:  if (v != 0)
branch  0 never executed
branch  1 never executed
        -: 1999:    {
        -: 2000:      /* It is indeed a variable definition.  Record a pointer to
        -: 2001:	 the variable for later use in define_makeflags.  */
        -: 2002:      struct command_variable *cv
    #####: 2003:	= (struct command_variable *) xmalloc (sizeof (*cv));
call    0 never executed
    #####: 2004:      cv->variable = v;
    #####: 2005:      cv->next = command_variables;
    #####: 2006:      command_variables = cv;
        -: 2007:    }
    #####: 2008:  else if (! env)
branch  0 never executed
branch  1 never executed
        -: 2009:    {
        -: 2010:      /* Not an option or variable definition; it must be a goal
        -: 2011:	 target!  Enter it as a file and add it to the dep chain of
        -: 2012:	 goals.  */
    #####: 2013:      struct file *f = enter_command_line_file (arg);
call    0 never executed
    #####: 2014:      f->cmd_target = 1;
        -: 2015:
    #####: 2016:      if (goals == 0)
branch  0 never executed
branch  1 never executed
        -: 2017:	{
    #####: 2018:	  goals = (struct dep *) xmalloc (sizeof (struct dep));
call    0 never executed
    #####: 2019:	  lastgoal = goals;
        -: 2020:	}
        -: 2021:      else
        -: 2022:	{
    #####: 2023:	  lastgoal->next = (struct dep *) xmalloc (sizeof (struct dep));
call    0 never executed
    #####: 2024:	  lastgoal = lastgoal->next;
        -: 2025:	}
    #####: 2026:      lastgoal->name = 0;
    #####: 2027:      lastgoal->file = f;
        -: 2028:
        -: 2029:      {
        -: 2030:        /* Add this target name to the MAKECMDGOALS variable. */
        -: 2031:        struct variable *v;
        -: 2032:        char *value;
        -: 2033:
    #####: 2034:        v = lookup_variable ("MAKECMDGOALS", 12);
call    0 never executed
    #####: 2035:        if (v == 0)
branch  0 never executed
branch  1 never executed
    #####: 2036:          value = f->name;
        -: 2037:        else
        -: 2038:          {
        -: 2039:            /* Paste the old and new values together */
        -: 2040:            unsigned int oldlen, newlen;
        -: 2041:
    #####: 2042:            oldlen = strlen (v->value);
    #####: 2043:            newlen = strlen (f->name);
    #####: 2044:            value = (char *) alloca (oldlen + 1 + newlen + 1);
    #####: 2045:            bcopy (v->value, value, oldlen);
    #####: 2046:            value[oldlen] = ' ';
    #####: 2047:            bcopy (f->name, &value[oldlen + 1], newlen + 1);
        -: 2048:          }
    #####: 2049:        define_variable ("MAKECMDGOALS", 12, value, o_default, 0);
call    0 never executed
        -: 2050:      }
        -: 2051:    }
        -: 2052:}
        -: 2053:
        -: 2054:/* Print a nice usage method.  */
        -: 2055:
        -: 2056:static void
function print_usage called 0 returned 0% blocks executed 0%
    #####: 2057:print_usage (bad)
        -: 2058:     int bad;
        -: 2059:{
        -: 2060:  register const struct command_switch *cs;
        -: 2061:  FILE *usageto;
        -: 2062:
    #####: 2063:  if (print_version_flag)
branch  0 never executed
branch  1 never executed
    #####: 2064:    print_version ();
call    0 never executed
        -: 2065:
    #####: 2066:  usageto = bad ? stderr : stdout;
        -: 2067:
    #####: 2068:  fprintf (usageto, _("Usage: %s [options] [target] ...\n"), program);
call    0 never executed
        -: 2069:
    #####: 2070:  fputs (_("Options:\n"), usageto);
call    0 never executed
    #####: 2071:  for (cs = switches; cs->c != '\0'; ++cs)
branch  0 never executed
branch  1 never executed
        -: 2072:    {
        -: 2073:      char buf[1024], shortarg[50], longarg[50], *p;
        -: 2074:
    #####: 2075:      if (!cs->description || cs->description[0] == '-')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2076:	continue;
        -: 2077:
    #####: 2078:      switch (long_options[cs - switches].has_arg)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2079:	{
    #####: 2080:	case no_argument:
    #####: 2081:	  shortarg[0] = longarg[0] = '\0';
    #####: 2082:	  break;
    #####: 2083:	case required_argument:
    #####: 2084:	  sprintf (longarg, "=%s", cs->argdesc);
    #####: 2085:	  sprintf (shortarg, " %s", cs->argdesc);
    #####: 2086:	  break;
    #####: 2087:	case optional_argument:
    #####: 2088:	  sprintf (longarg, "[=%s]", cs->argdesc);
    #####: 2089:	  sprintf (shortarg, " [%s]", cs->argdesc);
    #####: 2090:	  break;
        -: 2091:	}
        -: 2092:
    #####: 2093:      p = buf;
        -: 2094:
    #####: 2095:      if (short_option (cs->c))
branch  0 never executed
branch  1 never executed
        -: 2096:	{
    #####: 2097:	  sprintf (buf, "  -%c%s", cs->c, shortarg);
    #####: 2098:	  p += strlen (p);
        -: 2099:	}
    #####: 2100:      if (cs->long_name != 0)
branch  0 never executed
branch  1 never executed
        -: 2101:	{
        -: 2102:	  unsigned int i;
    #####: 2103:	  sprintf (p, "%s--%s%s",
    #####: 2104:		   !short_option (cs->c) ? "  " : ", ",
    #####: 2105:		   cs->long_name, longarg);
branch  0 never executed
branch  1 never executed
    #####: 2106:	  p += strlen (p);
    #####: 2107:	  for (i = 0; i < (sizeof (long_option_aliases) /
branch  0 never executed
branch  1 never executed
        -: 2108:			   sizeof (long_option_aliases[0]));
    #####: 2109:	       ++i)
    #####: 2110:	    if (long_option_aliases[i].val == cs->c)
branch  0 never executed
branch  1 never executed
        -: 2111:	      {
    #####: 2112:		sprintf (p, ", --%s%s",
        -: 2113:			 long_option_aliases[i].name, longarg);
    #####: 2114:		p += strlen (p);
        -: 2115:	      }
        -: 2116:	}
        -: 2117:      {
    #####: 2118:	const struct command_switch *ncs = cs;
    #####: 2119:	while ((++ncs)->c != '\0')
branch  0 never executed
branch  1 never executed
    #####: 2120:	  if (ncs->description
branch  0 never executed
branch  1 never executed
    #####: 2121:              && ncs->description[0] == '-'
branch  0 never executed
branch  1 never executed
    #####: 2122:              && ncs->description[1] == cs->c)
branch  0 never executed
branch  1 never executed
        -: 2123:	    {
        -: 2124:	      /* This is another switch that does the same
        -: 2125:		 one as the one we are processing.  We want
        -: 2126:		 to list them all together on one line.  */
    #####: 2127:	      sprintf (p, ", -%c%s", ncs->c, shortarg);
    #####: 2128:	      p += strlen (p);
    #####: 2129:	      if (ncs->long_name != 0)
branch  0 never executed
branch  1 never executed
        -: 2130:		{
    #####: 2131:		  sprintf (p, ", --%s%s", ncs->long_name, longarg);
    #####: 2132:		  p += strlen (p);
        -: 2133:		}
        -: 2134:	    }
        -: 2135:      }
        -: 2136:
    #####: 2137:      if (p - buf > DESCRIPTION_COLUMN - 2)
branch  0 never executed
branch  1 never executed
        -: 2138:	/* The list of option names is too long to fit on the same
        -: 2139:	   line with the description, leaving at least two spaces.
        -: 2140:	   Print it on its own line instead.  */
        -: 2141:	{
    #####: 2142:	  fprintf (usageto, "%s\n", buf);
call    0 never executed
    #####: 2143:	  buf[0] = '\0';
        -: 2144:	}
        -: 2145:
    #####: 2146:      fprintf (usageto, "%*s%s.\n",
        -: 2147:	       - DESCRIPTION_COLUMN,
    #####: 2148:	       buf, cs->description);
call    0 never executed
        -: 2149:    }
    #####: 2150:}
        -: 2151:
        -: 2152:/* Decode switches from ARGC and ARGV.
        -: 2153:   They came from the environment if ENV is nonzero.  */
        -: 2154:
        -: 2155:static void
function decode_switches called 1538 returned 100% blocks executed 45%
     1538: 2156:decode_switches (argc, argv, env)
        -: 2157:     int argc;
        -: 2158:     char **argv;
        -: 2159:     int env;
        -: 2160:{
     1538: 2161:  int bad = 0;
        -: 2162:  register const struct command_switch *cs;
        -: 2163:  register struct stringlist *sl;
        -: 2164:  register int c;
        -: 2165:
        -: 2166:  /* getopt does most of the parsing for us.
        -: 2167:     First, get its vectors set up.  */
        -: 2168:
     1538: 2169:  init_switches ();
call    0 returned 1538
        -: 2170:
        -: 2171:  /* Let getopt produce error messages for the command line,
        -: 2172:     but not for options from the environment.  */
     1538: 2173:  opterr = !env;
        -: 2174:  /* Reset getopt's state.  */
     1538: 2175:  optind = 0;
        -: 2176:
     7945: 2177:  while (optind < argc)
branch  0 taken 6407
branch  1 taken 1538 (fallthrough)
        -: 2178:    {
        -: 2179:      /* Parse the next argument.  */
     6407: 2180:      c = getopt_long (argc, argv, options, long_options, (int *) 0);
call    0 returned 6407
     6407: 2181:      if (c == EOF)
branch  0 taken 0 (fallthrough)
branch  1 taken 6407
        -: 2182:	/* End of arguments, or "--" marker seen.  */
    #####: 2183:	break;
     6407: 2184:      else if (c == 1)
branch  0 taken 0 (fallthrough)
branch  1 taken 6407
        -: 2185:	/* An argument not starting with a dash.  */
    #####: 2186:	handle_non_switch_argument (optarg, env);
call    0 never executed
     6407: 2187:      else if (c == '?')
branch  0 taken 0 (fallthrough)
branch  1 taken 6407
        -: 2188:	/* Bad option.  We will print a usage message and die later.
        -: 2189:	   But continue to parse the other options so the user can
        -: 2190:	   see all he did wrong.  */
    #####: 2191:	bad = 1;
        -: 2192:      else
    75308: 2193:	for (cs = switches; cs->c != '\0'; ++cs)
branch  0 taken 75308
branch  1 taken 0 (fallthrough)
    75308: 2194:	  if (cs->c == c)
branch  0 taken 6407 (fallthrough)
branch  1 taken 68901
        -: 2195:	    {
        -: 2196:	      /* Whether or not we will actually do anything with
        -: 2197:		 this switch.  We test this individually inside the
        -: 2198:		 switch below rather than just once outside it, so that
        -: 2199:		 options which are to be ignored still consume args.  */
    6407*: 2200:	      int doit = !env || cs->env;
branch  0 taken 2816 (fallthrough)
branch  1 taken 3591
branch  2 taken 2816 (fallthrough)
branch  3 taken 0
        -: 2201:
     6407: 2202:	      switch (cs->type)
branch  0 taken 0
branch  1 taken 0
branch  2 taken 5633
branch  3 taken 774
branch  4 taken 0
branch  5 taken 0
        -: 2203:		{
    #####: 2204:		default:
    #####: 2205:		  abort ();
call    0 never executed
        -: 2206:
    #####: 2207:		case ignore:
    #####: 2208:		  break;
        -: 2209:
     5633: 2210:		case flag:
        -: 2211:		case flag_off:
     5633: 2212:		  if (doit)
branch  0 taken 5633 (fallthrough)
branch  1 taken 0
     5633: 2213:		    *(int *) cs->value_ptr = cs->type == flag;
     5633: 2214:		  break;
        -: 2215:
      774: 2216:		case string:
      774: 2217:		  if (!doit)
branch  0 taken 0 (fallthrough)
branch  1 taken 774
    #####: 2218:		    break;
        -: 2219:
      774: 2220:		  if (optarg == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 774
    #####: 2221:		    optarg = cs->noarg_value;
        -: 2222:
      774: 2223:		  sl = *(struct stringlist **) cs->value_ptr;
      774: 2224:		  if (sl == 0)
branch  0 taken 773 (fallthrough)
branch  1 taken 1
        -: 2225:		    {
        -: 2226:		      sl = (struct stringlist *)
      773: 2227:			xmalloc (sizeof (struct stringlist));
call    0 returned 773
      773: 2228:		      sl->max = 5;
      773: 2229:		      sl->idx = 0;
      773: 2230:		      sl->list = (char **) xmalloc (5 * sizeof (char *));
call    0 returned 773
      773: 2231:		      *(struct stringlist **) cs->value_ptr = sl;
        -: 2232:		    }
        1: 2233:		  else if (sl->idx == sl->max - 1)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -: 2234:		    {
    #####: 2235:		      sl->max += 5;
    #####: 2236:		      sl->list = (char **)
    #####: 2237:			xrealloc ((char *) sl->list,
    #####: 2238:				  sl->max * sizeof (char *));
call    0 never executed
        -: 2239:		    }
      774: 2240:		  sl->list[sl->idx++] = optarg;
      774: 2241:		  sl->list[sl->idx] = 0;
      774: 2242:		  break;
        -: 2243:
    #####: 2244:		case positive_int:
    #####: 2245:		  if (optarg == 0 && argc > optind
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2246:		      && ISDIGIT (argv[optind][0]))
branch  0 never executed
branch  1 never executed
    #####: 2247:		    optarg = argv[optind++];
        -: 2248:
    #####: 2249:		  if (!doit)
branch  0 never executed
branch  1 never executed
    #####: 2250:		    break;
        -: 2251:
    #####: 2252:		  if (optarg != 0)
branch  0 never executed
branch  1 never executed
        -: 2253:		    {
    #####: 2254:		      int i = atoi (optarg);
    #####: 2255:		      if (i < 1)
branch  0 never executed
branch  1 never executed
        -: 2256:			{
    #####: 2257:			  if (doit)
branch  0 never executed
branch  1 never executed
    #####: 2258:			    error (NILF, _("the `-%c' option requires a positive integral argument"),
    #####: 2259:				   cs->c);
call    0 never executed
    #####: 2260:			  bad = 1;
        -: 2261:			}
        -: 2262:		      else
    #####: 2263:			*(unsigned int *) cs->value_ptr = i;
        -: 2264:		    }
        -: 2265:		  else
    #####: 2266:		    *(unsigned int *) cs->value_ptr
    #####: 2267:		      = *(unsigned int *) cs->noarg_value;
    #####: 2268:		  break;
        -: 2269:
        -: 2270:#ifndef NO_FLOAT
    #####: 2271:		case floating:
    #####: 2272:		  if (optarg == 0 && optind < argc
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2273:		      && (ISDIGIT (argv[optind][0]) || argv[optind][0] == '.'))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2274:		    optarg = argv[optind++];
        -: 2275:
    #####: 2276:		  if (doit)
branch  0 never executed
branch  1 never executed
    #####: 2277:		    *(double *) cs->value_ptr
    #####: 2278:		      = (optarg != 0 ? atof (optarg)
    #####: 2279:			 : *(double *) cs->noarg_value);
branch  0 never executed
branch  1 never executed
        -: 2280:
    #####: 2281:		  break;
        -: 2282:#endif
        -: 2283:		}
        -: 2284:
        -: 2285:	      /* We've found the switch.  Stop looking.  */
     6407: 2286:	      break;
        -: 2287:	    }
        -: 2288:    }
        -: 2289:
        -: 2290:  /* There are no more options according to getting getopt, but there may
        -: 2291:     be some arguments left.  Since we have asked for non-option arguments
        -: 2292:     to be returned in order, this only happens when there is a "--"
        -: 2293:     argument to prevent later arguments from being options.  */
     1538: 2294:  while (optind < argc)
branch  0 taken 0
branch  1 taken 1538 (fallthrough)
    #####: 2295:    handle_non_switch_argument (argv[optind++], env);
call    0 never executed
        -: 2296:
        -: 2297:
     1538: 2298:  if (!env && (bad || print_usage_flag))
branch  0 taken 774 (fallthrough)
branch  1 taken 764
branch  2 taken 774 (fallthrough)
branch  3 taken 0
branch  4 taken 0 (fallthrough)
branch  5 taken 774
        -: 2299:    {
    #####: 2300:      print_usage (bad);
call    0 never executed
    #####: 2301:      die (bad ? 2 : 0);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 2302:    }
     1538: 2303:}
        -: 2304:
        -: 2305:/* Decode switches from environment variable ENVAR (which is LEN chars long).
        -: 2306:   We do this by chopping the value into a vector of words, prepending a
        -: 2307:   dash to the first word if it lacks one, and passing the vector to
        -: 2308:   decode_switches.  */
        -: 2309:
        -: 2310:static void
function decode_env_switches called 1545 returned 100% blocks executed 80%
     1545: 2311:decode_env_switches (envar, len)
        -: 2312:     char *envar;
        -: 2313:     unsigned int len;
        -: 2314:{
     1545: 2315:  char *varref = (char *) alloca (2 + len + 2);
        -: 2316:  char *value, *p;
        -: 2317:  int argc;
        -: 2318:  char **argv;
        -: 2319:
        -: 2320:  /* Get the variable's value.  */
     1545: 2321:  varref[0] = '$';
     1545: 2322:  varref[1] = '(';
     1545: 2323:  bcopy (envar, &varref[2], len);
     1545: 2324:  varref[2 + len] = ')';
     1545: 2325:  varref[2 + len + 1] = '\0';
     1545: 2326:  value = variable_expand (varref);
call    0 returned 1545
        -: 2327:
        -: 2328:  /* Skip whitespace, and check for an empty value.  */
     1545: 2329:  value = next_token (value);
call    0 returned 1545
     1545: 2330:  len = strlen (value);
     1545: 2331:  if (len == 0)
branch  0 taken 781 (fallthrough)
branch  1 taken 764
      781: 2332:    return;
        -: 2333:
        -: 2334:  /* Allocate a vector that is definitely big enough.  */
      764: 2335:  argv = (char **) alloca ((1 + len + 1) * sizeof (char *));
        -: 2336:
        -: 2337:  /* Allocate a buffer to copy the value into while we split it into words
        -: 2338:     and unquote it.  We must use permanent storage for this because
        -: 2339:     decode_switches may store pointers into the passed argument words.  */
      764: 2340:  p = (char *) xmalloc (2 * len);
call    0 returned 764
        -: 2341:
        -: 2342:  /* getopt will look at the arguments starting at ARGV[1].
        -: 2343:     Prepend a spacer word.  */
      764: 2344:  argv[0] = 0;
      764: 2345:  argc = 1;
      764: 2346:  argv[argc] = p;
     3580: 2347:  while (*value != '\0')
branch  0 taken 2816
branch  1 taken 764 (fallthrough)
        -: 2348:    {
     2816: 2349:      if (*value == '\\')
branch  0 taken 0 (fallthrough)
branch  1 taken 2816
    #####: 2350:	++value;		/* Skip the backslash.  */
    2816*: 2351:      else if (isblank (*value))
branch  0 taken 0 (fallthrough)
branch  1 taken 2816
        -: 2352:	{
        -: 2353:	  /* End of the word.  */
    #####: 2354:	  *p++ = '\0';
    #####: 2355:	  argv[++argc] = p;
        -: 2356:	  do
    #####: 2357:	    ++value;
    #####: 2358:	  while (isblank (*value));
branch  0 never executed
branch  1 never executed
    #####: 2359:	  continue;
        -: 2360:	}
     2816: 2361:      *p++ = *value++;
        -: 2362:    }
      764: 2363:  *p = '\0';
      764: 2364:  argv[++argc] = 0;
        -: 2365:
      764: 2366:  if (argv[1][0] != '-' && index (argv[1], '=') == 0)
branch  0 taken 764 (fallthrough)
branch  1 taken 0
branch  2 taken 764 (fallthrough)
branch  3 taken 0
        -: 2367:    /* The first word doesn't start with a dash and isn't a variable
        -: 2368:       definition.  Add a dash and pass it along to decode_switches.  We
        -: 2369:       need permanent storage for this in case decode_switches saves
        -: 2370:       pointers into the value.  */
      764: 2371:    argv[1] = concat ("-", argv[1], "");
call    0 returned 764
        -: 2372:
        -: 2373:  /* Parse those words.  */
      764: 2374:  decode_switches (argc, argv, 1);
call    0 returned 764
        -: 2375:}
        -: 2376:
        -: 2377:/* Quote the string IN so that it will be interpreted as a single word with
        -: 2378:   no magic by the shell; if DOUBLE_DOLLARS is nonzero, also double dollar
        -: 2379:   signs to avoid variable expansion in make itself.  Write the result into
        -: 2380:   OUT, returning the address of the next character to be written.
        -: 2381:   Allocating space for OUT twice the length of IN (thrice if
        -: 2382:   DOUBLE_DOLLARS is nonzero) is always sufficient.  */
        -: 2383:
        -: 2384:static char *
function quote_as_word called 0 returned 0% blocks executed 0%
    #####: 2385:quote_as_word (out, in, double_dollars)
        -: 2386:     char *out, *in;
        -: 2387:     int double_dollars;
        -: 2388:{
    #####: 2389:  while (*in != '\0')
branch  0 never executed
branch  1 never executed
        -: 2390:    {
        -: 2391:#ifdef VMS
        -: 2392:      if (index ("^;'\"*?$<>(){}|&~`\\ \t\r\n\f\v", *in) != 0)
        -: 2393:#else
    #####: 2394:      if (index ("^;'\"*?[]$<>(){}|&~`\\ \t\r\n\f\v", *in) != 0)
branch  0 never executed
branch  1 never executed
        -: 2395:#endif
    #####: 2396:	*out++ = '\\';
    #####: 2397:      if (double_dollars && *in == '$')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2398:	*out++ = '$';
    #####: 2399:      *out++ = *in++;
        -: 2400:    }
        -: 2401:
    #####: 2402:  return out;
        -: 2403:}
        -: 2404:
        -: 2405:/* Define the MAKEFLAGS and MFLAGS variables to reflect the settings of the
        -: 2406:   command switches.  Include options with args if ALL is nonzero.
        -: 2407:   Don't include options with the `no_makefile' flag set if MAKEFILE.  */
        -: 2408:
        -: 2409:static void
function define_makeflags called 2569 returned 100% blocks executed 44%
     2569: 2410:define_makeflags (all, makefile)
        -: 2411:     int all, makefile;
        -: 2412:{
        -: 2413:  static const char ref[] = "$(MAKEOVERRIDES)";
        -: 2414:  static const char posixref[] = "$(-*-command-variables-*-)";
        -: 2415:  register const struct command_switch *cs;
        -: 2416:  char *flagstring;
        -: 2417:  register char *p;
        -: 2418:  unsigned int words;
        -: 2419:  struct variable *v;
        -: 2420:
        -: 2421:  /* We will construct a linked list of `struct flag's describing
        -: 2422:     all the flags which need to go in MAKEFLAGS.  Then, once we
        -: 2423:     know how many there are and their lengths, we can put them all
        -: 2424:     together in a string.  */
        -: 2425:
        -: 2426:  struct flag
        -: 2427:    {
        -: 2428:      struct flag *next;
        -: 2429:      const struct command_switch *cs;
        -: 2430:      char *arg;
        -: 2431:    };
     2569: 2432:  struct flag *flags = 0;
     2569: 2433:  unsigned int flagslen = 0;
        -: 2434:#define	ADD_FLAG(ARG, LEN) \
        -: 2435:  do {									      \
        -: 2436:    struct flag *new = (struct flag *) alloca (sizeof (struct flag));	      \
        -: 2437:    new->cs = cs;							      \
        -: 2438:    new->arg = (ARG);							      \
        -: 2439:    new->next = flags;							      \
        -: 2440:    flags = new;							      \
        -: 2441:    if (new->arg == 0)							      \
        -: 2442:      ++flagslen;		/* Just a single flag letter.  */	      \
        -: 2443:    else								      \
        -: 2444:      flagslen += 1 + 1 + 1 + 1 + 3 * (LEN); /* " -x foo" */		      \
        -: 2445:    if (!short_option (cs->c))						      \
        -: 2446:      /* This switch has no single-letter version, so we use the long.  */    \
        -: 2447:      flagslen += 2 + strlen (cs->long_name);				      \
        -: 2448:  } while (0)
        -: 2449:
    71932: 2450:  for (cs = switches; cs->c != '\0'; ++cs)
branch  0 taken 69363
branch  1 taken 2569 (fallthrough)
    69363: 2451:    if (cs->toenv && (!makefile || !cs->no_makefile))
branch  0 taken 51380 (fallthrough)
branch  1 taken 17983
branch  2 taken 15420 (fallthrough)
branch  3 taken 35960
branch  4 taken 13107 (fallthrough)
branch  5 taken 2313
    49067: 2452:      switch (cs->type)
branch  0 taken 0
branch  1 taken 0
branch  2 taken 38791
branch  3 taken 2569
branch  4 taken 2569
branch  5 taken 5138
        -: 2453:	{
    #####: 2454:	default:
    #####: 2455:	  abort ();
call    0 never executed
        -: 2456:
    #####: 2457:	case ignore:
    #####: 2458:	  break;
        -: 2459:
    38791: 2460:	case flag:
        -: 2461:	case flag_off:
    38791: 2462:	  if (!*(int *) cs->value_ptr == (cs->type == flag_off)
branch  0 taken 10633 (fallthrough)
branch  1 taken 28158
    10633: 2463:	      && (cs->default_value == 0
branch  0 taken 2569 (fallthrough)
branch  1 taken 8064
     2569: 2464:		  || *(int *) cs->value_ptr != *(int *) cs->default_value))
branch  0 taken 1024 (fallthrough)
branch  1 taken 1545
    9088*: 2465:	    ADD_FLAG (0, 0);
branch  0 taken 9088 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 9088
    38791: 2466:	  break;
        -: 2467:
     2569: 2468:	case positive_int:
     2569: 2469:	  if (all)
branch  0 taken 1798 (fallthrough)
branch  1 taken 771
        -: 2470:	    {
     1798: 2471:	      if ((cs->default_value != 0
branch  0 taken 1798 (fallthrough)
branch  1 taken 0
     1798: 2472:		   && (*(unsigned int *) cs->value_ptr
     1798: 2473:		       == *(unsigned int *) cs->default_value)))
branch  0 taken 0 (fallthrough)
branch  1 taken 1798
        -: 2474:		break;
    #####: 2475:	      else if (cs->noarg_value != 0
branch  0 never executed
branch  1 never executed
    #####: 2476:		       && (*(unsigned int *) cs->value_ptr ==
    #####: 2477:			   *(unsigned int *) cs->noarg_value))
branch  0 never executed
branch  1 never executed
    #####: 2478:		ADD_FLAG ("", 0); /* Optional value omitted; see below.  */
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2479:	      else if (cs->c == 'j')
branch  0 never executed
branch  1 never executed
        -: 2480:		/* Special case for `-j'.  */
    #####: 2481:		ADD_FLAG ("1", 1);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2482:	      else
        -: 2483:		{
    #####: 2484:		  char *buf = (char *) alloca (30);
    #####: 2485:		  sprintf (buf, "%u", *(unsigned int *) cs->value_ptr);
    #####: 2486:		  ADD_FLAG (buf, strlen (buf));
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2487:		}
        -: 2488:	    }
      771: 2489:	  break;
        -: 2490:
        -: 2491:#ifndef NO_FLOAT
     2569: 2492:	case floating:
     2569: 2493:	  if (all)
branch  0 taken 1798 (fallthrough)
branch  1 taken 771
        -: 2494:	    {
     1798: 2495:	      if (cs->default_value != 0
branch  0 taken 1798 (fallthrough)
branch  1 taken 0
     1798: 2496:		  && (*(double *) cs->value_ptr
     1798: 2497:		      == *(double *) cs->default_value))
branch  0 taken 0 (fallthrough)
branch  1 taken 1798
        -: 2498:		break;
    #####: 2499:	      else if (cs->noarg_value != 0
branch  0 never executed
branch  1 never executed
    #####: 2500:		       && (*(double *) cs->value_ptr
    #####: 2501:			   == *(double *) cs->noarg_value))
branch  0 never executed
branch  1 never executed
    #####: 2502:		ADD_FLAG ("", 0); /* Optional value omitted; see below.  */
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2503:	      else
        -: 2504:		{
    #####: 2505:		  char *buf = (char *) alloca (100);
    #####: 2506:		  sprintf (buf, "%g", *(double *) cs->value_ptr);
    #####: 2507:		  ADD_FLAG (buf, strlen (buf));
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2508:		}
        -: 2509:	    }
      771: 2510:	  break;
        -: 2511:#endif
        -: 2512:
     5138: 2513:	case string:
     5138: 2514:	  if (all)
branch  0 taken 3596 (fallthrough)
branch  1 taken 1542
        -: 2515:	    {
     3596: 2516:	      struct stringlist *sl = *(struct stringlist **) cs->value_ptr;
     3596: 2517:	      if (sl != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 3596
        -: 2518:		{
        -: 2519:		  /* Add the elements in reverse order, because
        -: 2520:		     all the flags get reversed below; and the order
        -: 2521:		     matters for some switches (like -I).  */
    #####: 2522:		  register unsigned int i = sl->idx;
    #####: 2523:		  while (i-- > 0)
branch  0 never executed
branch  1 never executed
    #####: 2524:		    ADD_FLAG (sl->list[i], strlen (sl->list[i]));
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2525:		}
        -: 2526:	    }
     5138: 2527:	  break;
        -: 2528:	}
        -: 2529:
     2569: 2530:  flagslen += 4 + sizeof posixref; /* Four more for the possible " -- ".  */
        -: 2531:
        -: 2532:#undef	ADD_FLAG
        -: 2533:
        -: 2534:  /* Construct the value in FLAGSTRING.
        -: 2535:     We allocate enough space for a preceding dash and trailing null.  */
     2569: 2536:  flagstring = (char *) alloca (1 + flagslen + 1);
     2569: 2537:  bzero (flagstring, 1 + flagslen + 1);
     2569: 2538:  p = flagstring;
     2569: 2539:  words = 1;
     2569: 2540:  *p++ = '-';
    11657: 2541:  while (flags != 0)
branch  0 taken 9088
branch  1 taken 2569 (fallthrough)
        -: 2542:    {
        -: 2543:      /* Add the flag letter or name to the string.  */
     9088: 2544:      if (short_option (flags->cs->c))
branch  0 taken 9088 (fallthrough)
branch  1 taken 0
     9088: 2545:	*p++ = flags->cs->c;
        -: 2546:      else
        -: 2547:	{
    #####: 2548:          if (*p != '-')
branch  0 never executed
branch  1 never executed
        -: 2549:            {
    #####: 2550:              *p++ = ' ';
    #####: 2551:              *p++ = '-';
        -: 2552:            }
    #####: 2553:	  *p++ = '-';
    #####: 2554:	  strcpy (p, flags->cs->long_name);
    #####: 2555:	  p += strlen (p);
        -: 2556:	}
     9088: 2557:      if (flags->arg != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 9088
        -: 2558:	{
        -: 2559:	  /* A flag that takes an optional argument which in this case is
        -: 2560:	     omitted is specified by ARG being "".  We must distinguish
        -: 2561:	     because a following flag appended without an intervening " -"
        -: 2562:	     is considered the arg for the first.  */
    #####: 2563:	  if (flags->arg[0] != '\0')
branch  0 never executed
branch  1 never executed
        -: 2564:	    {
        -: 2565:	      /* Add its argument too.  */
    #####: 2566:	      *p++ = !short_option (flags->cs->c) ? '=' : ' ';
branch  0 never executed
branch  1 never executed
    #####: 2567:	      p = quote_as_word (p, flags->arg, 1);
call    0 never executed
        -: 2568:	    }
    #####: 2569:	  ++words;
        -: 2570:	  /* Write a following space and dash, for the next flag.  */
    #####: 2571:	  *p++ = ' ';
    #####: 2572:	  *p++ = '-';
        -: 2573:	}
     9088: 2574:      else if (!short_option (flags->cs->c))
branch  0 taken 0 (fallthrough)
branch  1 taken 9088
        -: 2575:	{
    #####: 2576:	  ++words;
        -: 2577:	  /* Long options must each go in their own word,
        -: 2578:	     so we write the following space and dash.  */
    #####: 2579:	  *p++ = ' ';
    #####: 2580:	  *p++ = '-';
        -: 2581:	}
     9088: 2582:      flags = flags->next;
        -: 2583:    }
        -: 2584:
        -: 2585:  /* Define MFLAGS before appending variable definitions.  */
        -: 2586:
     2569: 2587:  if (p == &flagstring[1])
branch  0 taken 25 (fallthrough)
branch  1 taken 2544
        -: 2588:    /* No flags.  */
       25: 2589:    flagstring[0] = '\0';
     2544: 2590:  else if (p[-1] == '-')
branch  0 taken 0 (fallthrough)
branch  1 taken 2544
        -: 2591:    {
        -: 2592:      /* Kill the final space and dash.  */
    #####: 2593:      p -= 2;
    #####: 2594:      *p = '\0';
        -: 2595:    }
        -: 2596:  else
        -: 2597:    /* Terminate the string.  */
     2544: 2598:    *p = '\0';
        -: 2599:
        -: 2600:  /* Since MFLAGS is not parsed for flags, there is no reason to
        -: 2601:     override any makefile redefinition.  */
     2569: 2602:  (void) define_variable ("MFLAGS", 6, flagstring, o_env, 1);
call    0 returned 2569
        -: 2603:
     2569: 2604:  if (all && command_variables != 0)
branch  0 taken 1798 (fallthrough)
branch  1 taken 771
branch  2 taken 0 (fallthrough)
branch  3 taken 1798
        -: 2605:    {
        -: 2606:      /* Now write a reference to $(MAKEOVERRIDES), which contains all the
        -: 2607:	 command-line variable definitions.  */
        -: 2608:
    #####: 2609:      if (p == &flagstring[1])
branch  0 never executed
branch  1 never executed
        -: 2610:	/* No flags written, so elide the leading dash already written.  */
    #####: 2611:	p = flagstring;
        -: 2612:      else
        -: 2613:	{
        -: 2614:	  /* Separate the variables from the switches with a "--" arg.  */
    #####: 2615:	  if (p[-1] != '-')
branch  0 never executed
branch  1 never executed
        -: 2616:	    {
        -: 2617:	      /* We did not already write a trailing " -".  */
    #####: 2618:	      *p++ = ' ';
    #####: 2619:	      *p++ = '-';
        -: 2620:	    }
        -: 2621:	  /* There is a trailing " -"; fill it out to " -- ".  */
    #####: 2622:	  *p++ = '-';
    #####: 2623:	  *p++ = ' ';
        -: 2624:	}
        -: 2625:
        -: 2626:      /* Copy in the string.  */
    #####: 2627:      if (posix_pedantic)
branch  0 never executed
branch  1 never executed
        -: 2628:	{
    #####: 2629:	  bcopy (posixref, p, sizeof posixref - 1);
    #####: 2630:	  p += sizeof posixref - 1;
        -: 2631:	}
        -: 2632:      else
        -: 2633:	{
    #####: 2634:	  bcopy (ref, p, sizeof ref - 1);
    #####: 2635:	  p += sizeof ref - 1;
        -: 2636:	}
        -: 2637:    }
     2569: 2638:  else if (p == &flagstring[1])
branch  0 taken 25 (fallthrough)
branch  1 taken 2544
        -: 2639:    {
       25: 2640:      words = 0;
       25: 2641:      --p;
        -: 2642:    }
     2544: 2643:  else if (p[-1] == '-')
branch  0 taken 0 (fallthrough)
branch  1 taken 2544
        -: 2644:    /* Kill the final space and dash.  */
    #####: 2645:    p -= 2;
        -: 2646:  /* Terminate the string.  */
     2569: 2647:  *p = '\0';
        -: 2648:
     2569: 2649:  v = define_variable ("MAKEFLAGS", 9,
call    0 returned 2569
        -: 2650:		       /* If there are switches, omit the leading dash
        -: 2651:			  unless it is a single long option with two
        -: 2652:			  leading dashes.  */
     2569: 2653:		       &flagstring[(flagstring[0] == '-'
     2544: 2654:				    && flagstring[1] != '-')
branch  0 taken 2544 (fallthrough)
branch  1 taken 0
     5113: 2655:				   ? 1 : 0],
branch  0 taken 2544 (fallthrough)
branch  1 taken 25
        -: 2656:		       /* This used to use o_env, but that lost when a
        -: 2657:			  makefile defined MAKEFLAGS.  Makefiles set
        -: 2658:			  MAKEFLAGS to add switches, but we still want
        -: 2659:			  to redefine its value with the full set of
        -: 2660:			  switches.  Of course, an override or command
        -: 2661:			  definition will still take precedence.  */
        -: 2662:		       o_file, 1);
     2569: 2663:  if (! all)
branch  0 taken 771 (fallthrough)
branch  1 taken 1798
        -: 2664:    /* The first time we are called, set MAKEFLAGS to always be exported.
        -: 2665:       We should not do this again on the second call, because that is
        -: 2666:       after reading makefiles which might have done `unexport MAKEFLAGS'. */
      771: 2667:    v->export = v_export;
     2569: 2668:}
        -: 2669:
        -: 2670:/* Print version information.  */
        -: 2671:
        -: 2672:static void
function print_version called 578 returned 100% blocks executed 83%
      578: 2673:print_version ()
        -: 2674:{
        -: 2675:  extern char *make_host;
        -: 2676:  static int printed_version = 0;
        -: 2677:
      578: 2678:  char *precede = print_data_base_flag ? "# " : "";
branch  0 taken 384 (fallthrough)
branch  1 taken 194
        -: 2679:
      578: 2680:  if (printed_version)
branch  0 taken 1 (fallthrough)
branch  1 taken 577
        -: 2681:    /* Do it only once.  */
        1: 2682:    return;
        -: 2683:
      577: 2684:  printf ("%sGNU Make version %s", precede, version_string);
call    0 returned 577
     577*: 2685:  if (remote_description != 0 && *remote_description != '\0')
branch  0 taken 0 (fallthrough)
branch  1 taken 577
branch  2 never executed
branch  3 never executed
    #####: 2686:    printf ("-%s", remote_description);
call    0 never executed
        -: 2687:
      577: 2688:  printf (_(", by Richard Stallman and Roland McGrath.\n\
call    0 returned 577
        -: 2689:%sBuilt for %s\n\
        -: 2690:%sCopyright (C) 1988, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99\n\
        -: 2691:%s\tFree Software Foundation, Inc.\n\
        -: 2692:%sThis is free software; see the source for copying conditions.\n\
        -: 2693:%sThere is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A\n\
        -: 2694:%sPARTICULAR PURPOSE.\n\n\
        -: 2695:%sReport bugs to <bug-make@gnu.org>.\n\n"),
        -: 2696:          precede, make_host,
        -: 2697:	  precede, precede, precede, precede, precede, precede);
        -: 2698:
      577: 2699:  printed_version = 1;
        -: 2700:
        -: 2701:  /* Flush stdout so the user doesn't have to wait to see the
        -: 2702:     version information while things are thought about.  */
      577: 2703:  fflush (stdout);
call    0 returned 577
        -: 2704:}
        -: 2705:
        -: 2706:/* Print a bunch of information about this and that.  */
        -: 2707:
        -: 2708:static void
function print_data_base called 384 returned 100% blocks executed 100%
      384: 2709:print_data_base ()
        -: 2710:{
        -: 2711:  time_t when;
        -: 2712:
      384: 2713:  when = time ((time_t *) 0);
call    0 returned 384
      384: 2714:  printf("\n# Make data base, printed on 00:00 Jan 01 2000");
call    0 returned 384
        -: 2715:  /* printf (_("\n# Make data base, printed on %s"), ctime (&when)); */
        -: 2716:
      384: 2717:  print_variable_data_base ();
call    0 returned 384
      384: 2718:  print_dir_data_base ();
call    0 returned 384
      384: 2719:  print_rule_data_base ();
call    0 returned 384
      384: 2720:  print_file_data_base ();
call    0 returned 384
      384: 2721:  print_vpath_data_base ();
call    0 returned 384
        -: 2722:
      384: 2723:  when = time ((time_t *) 0);
call    0 returned 384
      384: 2724:  printf ("\n# Finished Make data base on 00:00 Jan 01 2000\n");
call    0 returned 384
        -: 2725:  /* printf (_("\n# Finished Make data base on %s\n"), ctime (&when)); */
      384: 2726:}
        -: 2727:
        -: 2728:/* Exit with STATUS, cleaning up as necessary.  */
        -: 2729:
        -: 2730:void
function die called 774 returned 0% blocks executed 87%
      774: 2731:die (status)
        -: 2732:     int status;
        -: 2733:{
        -: 2734:  static char dying = 0;
        -: 2735:
      774: 2736:  if (!dying)
branch  0 taken 774 (fallthrough)
branch  1 taken 0
        -: 2737:    {
        -: 2738:      int err;
        -: 2739:
      774: 2740:      dying = 1;
        -: 2741:
      774: 2742:      if (print_version_flag)
branch  0 taken 1 (fallthrough)
branch  1 taken 773
        1: 2743:	print_version ();
call    0 returned 1
        -: 2744:
        -: 2745:      /* Wait for children to die.  */
     774*: 2746:      for (err = status != 0; job_slots_used > 0; err = 0)
branch  0 taken 0
branch  1 taken 774 (fallthrough)
    #####: 2747:	reap_children (1, err);
call    0 never executed
        -: 2748:
        -: 2749:      /* Let the remote job module clean up its state.  */
      774: 2750:      remote_cleanup ();
call    0 returned 774
        -: 2751:
        -: 2752:      /* Remove the intermediate files.  */
      774: 2753:      remove_intermediates (0);
call    0 returned 774
        -: 2754:
      774: 2755:      if (print_data_base_flag)
branch  0 taken 384 (fallthrough)
branch  1 taken 390
      384: 2756:	print_data_base ();
call    0 returned 384
        -: 2757:
        -: 2758:      /* Try to move back to the original directory.  This is essential on
        -: 2759:	 MS-DOS (where there is really only one process), and on Unix it
        -: 2760:	 puts core files in the original directory instead of the -C
        -: 2761:	 directory.  Must wait until after remove_intermediates(), or unlinks
        -: 2762:         of relative pathnames fail.  */
      774: 2763:      if (directory_before_chdir != 0)
branch  0 taken 774 (fallthrough)
branch  1 taken 0
      774: 2764:	chdir (directory_before_chdir);
call    0 returned 774
        -: 2765:
      774: 2766:      log_working_directory (0);
call    0 returned 774
        -: 2767:    }
        -: 2768:
      774: 2769:  exit (status);
        -: 2770:}
        -: 2771:
        -: 2772:/* Write a message indicating that we've just entered or
        -: 2773:   left (according to ENTERING) the current directory.  */
        -: 2774:
        -: 2775:void
function log_working_directory called 2830 returned 100% blocks executed 87%
     2830: 2776:log_working_directory (entering)
        -: 2777:     int entering;
        -: 2778:{
        -: 2779:  static int entered = 0;
     2830: 2780:  char *msg = entering ? _("Entering") : _("Leaving");
branch  0 taken 2056 (fallthrough)
branch  1 taken 774
        -: 2781:
        -: 2782:  /* Print nothing without the flag.  Don't print the entering message
        -: 2783:     again if we already have.  Don't print the leaving message if we
        -: 2784:     haven't printed the entering message.  */
     2830: 2785:  if (! print_directory_flag || entering == entered)
branch  0 taken 1408 (fallthrough)
branch  1 taken 1422
branch  2 taken 640 (fallthrough)
branch  3 taken 768
     2062: 2786:    return;
        -: 2787:
      768: 2788:  entered = entering;
        -: 2789:
      768: 2790:  if (print_data_base_flag)
branch  0 taken 384 (fallthrough)
branch  1 taken 384
      384: 2791:    fputs ("# ", stdout);
call    0 returned 384
        -: 2792:
      768: 2793:  if (makelevel == 0)
branch  0 taken 768 (fallthrough)
branch  1 taken 0
      768: 2794:    printf ("%s: %s ", program, msg);
call    0 returned 768
        -: 2795:  else
    #####: 2796:    printf ("%s[%u]: %s ", program, makelevel, msg);
call    0 never executed
        -: 2797:
      768: 2798:  if (starting_directory == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 768
    #####: 2799:    puts (_("an unknown directory"));
call    0 never executed
        -: 2800:  else
      768: 2801:    printf (_("directory `%s'\n"), starting_directory);
call    0 returned 768
        -: 2802:}
        -: 2803:
        -: 2804:
        -: 2805:
        -: 2806:/*************************************************************
        -: 2807:  ============================================================
        -: 2808:  ************************************************************
        -: 2809:  ============================================================
        -: 2810:  ************************************************************
        -: 2811:                         commands.c
        -: 2812:  ************************************************************
        -: 2813:  ============================================================
        -: 2814:  ************************************************************
        -: 2815:  ============================================================
        -: 2816:  *************************************************************/
        -: 2817:
        -: 2818:/* Command processing for GNU Make.
        -: 2819:Copyright (C) 1988,89,91,92,93,94,95,96,97 Free Software Foundation, Inc.
        -: 2820:This file is part of GNU Make.
        -: 2821:
        -: 2822:GNU Make is free software; you can redistribute it and/or modify
        -: 2823:it under the terms of the GNU General Public License as published by
        -: 2824:the Free Software Foundation; either version 2, or (at your option)
        -: 2825:any later version.
        -: 2826:
        -: 2827:GNU Make is distributed in the hope that it will be useful,
        -: 2828:but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 2829:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 2830:GNU General Public License for more details.
        -: 2831:
        -: 2832:You should have received a copy of the GNU General Public License
        -: 2833:along with GNU Make; see the file COPYING.  If not, write to
        -: 2834:the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
        -: 2835:Boston, MA 02111-1307, USA.  */
        -: 2836:
        -: 2837:/* #include "make.h"  <- modification by J.Ruthruff, 7/27 */
        -: 2838:/* #include "dep.h"  <- modification by J.Ruthruff, 7/27 */
        -: 2839:/* #include "filedef.h"  <- modification by J.Ruthruff, 7/27 */
        -: 2840:/* #include "variable.h"  <- modification by J.Ruthruff, 7/27 */
        -: 2841:#include "job.h"
        -: 2842:/* #include "commands.h"  <- modification by J.Ruthruff, 7/27 */
        -: 2843:#undef stderr
        -: 2844:#define stderr stdout
        -: 2845:
        -: 2846:extern int remote_kill PARAMS ((int id, int sig));
        -: 2847:
        -: 2848:#ifndef	HAVE_UNISTD_H
        -: 2849:extern int getpid ();
        -: 2850:#endif
        -: 2851:
        -: 2852:/* Set FILE's automatic variables up.  */
        -: 2853:
        -: 2854:static void
function set_file_variables called 0 returned 0% blocks executed 0%
    #####: 2855:set_file_variables (file)
        -: 2856:     register struct file *file;
        -: 2857:{
        -: 2858:  register char *p;
        -: 2859:  char *at, *percent, *star, *less;
        -: 2860:
        -: 2861:#ifndef	NO_ARCHIVES
        -: 2862:  /* If the target is an archive member `lib(member)',
        -: 2863:     then $@ is `lib' and $% is `member'.  */
        -: 2864:
    #####: 2865:  if (ar_name (file->name))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2866:    {
        -: 2867:      unsigned int len;
    #####: 2868:      p = index (file->name, '(');
    #####: 2869:      at = (char *) alloca (p - file->name + 1);
    #####: 2870:      bcopy (file->name, at, p - file->name);
    #####: 2871:      at[p - file->name] = '\0';
    #####: 2872:      len = strlen (p + 1);
    #####: 2873:      percent = (char *) alloca (len);
    #####: 2874:      bcopy (p + 1, percent, len - 1);
    #####: 2875:      percent[len - 1] = '\0';
        -: 2876:    }
        -: 2877:  else
        -: 2878:#endif	/* NO_ARCHIVES.  */
        -: 2879:    {
    #####: 2880:      at = file->name;
    #####: 2881:      percent = "";
        -: 2882:    }
        -: 2883:
        -: 2884:  /* $* is the stem from an implicit or static pattern rule.  */
    #####: 2885:  if (file->stem == 0)
branch  0 never executed
branch  1 never executed
        -: 2886:    {
        -: 2887:      /* In Unix make, $* is set to the target name with
        -: 2888:	 any suffix in the .SUFFIXES list stripped off for
        -: 2889:	 explicit rules.  We store this in the `stem' member.  */
        -: 2890:      register struct dep *d;
        -: 2891:      char *name;
        -: 2892:      unsigned int len;
        -: 2893:
        -: 2894:#ifndef	NO_ARCHIVES
    #####: 2895:      if (ar_name (file->name))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2896:	{
    #####: 2897:	  name = index (file->name, '(') + 1;
    #####: 2898:	  len = strlen (name) - 1;
        -: 2899:	}
        -: 2900:      else
        -: 2901:#endif
        -: 2902:	{
    #####: 2903:	  name = file->name;
    #####: 2904:	  len = strlen (name);
        -: 2905:	}
        -: 2906:
    #####: 2907:      for (d = enter_file (".SUFFIXES")->deps; d != 0; d = d->next)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2908:	{
    #####: 2909:	  unsigned int slen = strlen (dep_name (d));
branch  0 never executed
branch  1 never executed
    #####: 2910:	  if (len > slen && strneq (dep_name (d), name + (len - slen), slen))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 2911:	    {
    #####: 2912:	      file->stem = savestring (name, len - slen);
call    0 never executed
    #####: 2913:	      break;
        -: 2914:	    }
        -: 2915:	}
    #####: 2916:      if (d == 0)
branch  0 never executed
branch  1 never executed
    #####: 2917:	file->stem = "";
        -: 2918:    }
    #####: 2919:  star = file->stem;
        -: 2920:
        -: 2921:  /* $< is the first dependency.  */
    #####: 2922:  less = file->deps != 0 ? dep_name (file->deps) : "";
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2923:
    #####: 2924:  if (file->cmds == default_file->cmds)
branch  0 never executed
branch  1 never executed
        -: 2925:    /* This file got its commands from .DEFAULT.
        -: 2926:       In this case $< is the same as $@.  */
    #####: 2927:    less = at;
        -: 2928:
        -: 2929:#define	DEFINE_VARIABLE(name, len, value) \
        -: 2930:  (void) define_variable_for_file (name, len, value, o_automatic, 0, file)
        -: 2931:
        -: 2932:  /* Define the variables.  */
        -: 2933:
    #####: 2934:  DEFINE_VARIABLE ("<", 1, less);
call    0 never executed
    #####: 2935:  DEFINE_VARIABLE ("*", 1, star);
call    0 never executed
    #####: 2936:  DEFINE_VARIABLE ("@", 1, at);
call    0 never executed
    #####: 2937:  DEFINE_VARIABLE ("%", 1, percent);
call    0 never executed
        -: 2938:
        -: 2939:  /* Compute the values for $^, $+, and $?.  */
        -: 2940:
        -: 2941:  {
        -: 2942:    register unsigned int qmark_len, plus_len;
        -: 2943:    char *caret_value, *plus_value;
        -: 2944:    register char *cp;
        -: 2945:    char *qmark_value;
        -: 2946:    register char *qp;
        -: 2947:    register struct dep *d;
        -: 2948:    unsigned int len;
        -: 2949:
        -: 2950:    /* Compute first the value for $+, which is supposed to contain
        -: 2951:       duplicate dependencies as they were listed in the makefile.  */
        -: 2952:
    #####: 2953:    plus_len = 0;
    #####: 2954:    for (d = file->deps; d != 0; d = d->next)
branch  0 never executed
branch  1 never executed
    #####: 2955:      plus_len += strlen (dep_name (d)) + 1;
branch  0 never executed
branch  1 never executed
        -: 2956:
    #####: 2957:    len = plus_len == 0 ? 1 : plus_len;
branch  0 never executed
branch  1 never executed
    #####: 2958:    cp = plus_value = (char *) alloca (len);
        -: 2959:
    #####: 2960:    qmark_len = plus_len;	/* Will be this or less.  */
    #####: 2961:    for (d = file->deps; d != 0; d = d->next)
branch  0 never executed
branch  1 never executed
        -: 2962:      {
    #####: 2963:	char *c = dep_name (d);
branch  0 never executed
branch  1 never executed
        -: 2964:
        -: 2965:#ifndef	NO_ARCHIVES
    #####: 2966:	if (ar_name (c))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2967:	  {
    #####: 2968:	    c = index (c, '(') + 1;
    #####: 2969:	    len = strlen (c) - 1;
        -: 2970:	  }
        -: 2971:	else
        -: 2972:#endif
    #####: 2973:	  len = strlen (c);
        -: 2974:
    #####: 2975:	bcopy (c, cp, len);
    #####: 2976:	cp += len;
        -: 2977:#if VMS
        -: 2978:        *cp++ = ',';
        -: 2979:#else
    #####: 2980:	*cp++ = ' ';
        -: 2981:#endif
    #####: 2982:	if (! d->changed)
branch  0 never executed
branch  1 never executed
    #####: 2983:	  qmark_len -= len + 1;	/* Don't space in $? for this one.  */
        -: 2984:      }
        -: 2985:
        -: 2986:    /* Kill the last space and define the variable.  */
        -: 2987:
    #####: 2988:    cp[cp > plus_value ? -1 : 0] = '\0';
branch  0 never executed
branch  1 never executed
    #####: 2989:    DEFINE_VARIABLE ("+", 1, plus_value);
call    0 never executed
        -: 2990:
        -: 2991:    /* Make sure that no dependencies are repeated.  This does not
        -: 2992:       really matter for the purpose of updating targets, but it
        -: 2993:       might make some names be listed twice for $^ and $?.  */
        -: 2994:
    #####: 2995:    uniquize_deps (file->deps);
call    0 never executed
        -: 2996:
        -: 2997:    /* Compute the values for $^ and $?.  */
        -: 2998:
    #####: 2999:    cp = caret_value = plus_value; /* Reuse the buffer; it's big enough.  */
    #####: 3000:    len = qmark_len == 0 ? 1 : qmark_len;
branch  0 never executed
branch  1 never executed
    #####: 3001:    qp = qmark_value = (char *) alloca (len);
        -: 3002:
    #####: 3003:    for (d = file->deps; d != 0; d = d->next)
branch  0 never executed
branch  1 never executed
        -: 3004:      {
    #####: 3005:	char *c = dep_name (d);
branch  0 never executed
branch  1 never executed
        -: 3006:
        -: 3007:#ifndef	NO_ARCHIVES
    #####: 3008:	if (ar_name (c))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 3009:	  {
    #####: 3010:	    c = index (c, '(') + 1;
    #####: 3011:	    len = strlen (c) - 1;
        -: 3012:	  }
        -: 3013:	else
        -: 3014:#endif
    #####: 3015:	  len = strlen (c);
        -: 3016:
    #####: 3017:	bcopy (c, cp, len);
    #####: 3018:	cp += len;
        -: 3019:#if VMS
        -: 3020:	*cp++ = ',';
        -: 3021:#else
    #####: 3022:	*cp++ = ' ';
        -: 3023:#endif
    #####: 3024:	if (d->changed)
branch  0 never executed
branch  1 never executed
        -: 3025:	  {
    #####: 3026:	    bcopy (c, qp, len);
    #####: 3027:	    qp += len;
        -: 3028:#if VMS
        -: 3029:	    *qp++ = ',';
        -: 3030:#else
    #####: 3031:	    *qp++ = ' ';
        -: 3032:#endif
        -: 3033:	  }
        -: 3034:      }
        -: 3035:
        -: 3036:    /* Kill the last spaces and define the variables.  */
        -: 3037:
    #####: 3038:    cp[cp > caret_value ? -1 : 0] = '\0';
branch  0 never executed
branch  1 never executed
    #####: 3039:    DEFINE_VARIABLE ("^", 1, caret_value);
call    0 never executed
        -: 3040:
    #####: 3041:    qp[qp > qmark_value ? -1 : 0] = '\0';
branch  0 never executed
branch  1 never executed
    #####: 3042:    DEFINE_VARIABLE ("?", 1, qmark_value);
call    0 never executed
        -: 3043:  }
        -: 3044:
        -: 3045:#undef	DEFINE_VARIABLE
    #####: 3046:}
        -: 3047:
        -: 3048:/* Chop CMDS up into individual command lines if necessary.
        -: 3049:   Also set the `lines_flag' and `any_recurse' members.  */
        -: 3050:
        -: 3051:void
function chop_commands called 0 returned 0% blocks executed 0%
    #####: 3052:chop_commands (cmds)
        -: 3053:     register struct commands *cmds;
        -: 3054:{
    #####: 3055:  if (cmds != 0 && cmds->command_lines == 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 3056:    {
        -: 3057:      /* Chop CMDS->commands up into lines in CMDS->command_lines.
        -: 3058:	 Also set the corresponding CMDS->lines_flags elements,
        -: 3059:	 and the CMDS->any_recurse flag.  */
        -: 3060:      register char *p;
        -: 3061:      unsigned int nlines, idx;
        -: 3062:      char **lines;
        -: 3063:
    #####: 3064:      nlines = 5;
    #####: 3065:      lines = (char **) xmalloc (5 * sizeof (char *));
call    0 never executed
    #####: 3066:      idx = 0;
    #####: 3067:      p = cmds->commands;
    #####: 3068:      while (*p != '\0')
branch  0 never executed
branch  1 never executed
        -: 3069:	{
    #####: 3070:	  char *end = p;
    #####: 3071:	find_end:;
    #####: 3072:	  end = index (end, '\n');
    #####: 3073:	  if (end == 0)
branch  0 never executed
branch  1 never executed
    #####: 3074:	    end = p + strlen (p);
    #####: 3075:	  else if (end > p && end[-1] == '\\')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 3076:	    {
    #####: 3077:	      int backslash = 1;
        -: 3078:	      register char *b;
    #####: 3079:	      for (b = end - 2; b >= p && *b == '\\'; --b)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3080:		backslash = !backslash;
    #####: 3081:	      if (backslash)
branch  0 never executed
branch  1 never executed
        -: 3082:		{
    #####: 3083:		  ++end;
    #####: 3084:		  goto find_end;
        -: 3085:		}
        -: 3086:	    }
        -: 3087:
    #####: 3088:	  if (idx == nlines)
branch  0 never executed
branch  1 never executed
        -: 3089:	    {
    #####: 3090:	      nlines += 2;
    #####: 3091:	      lines = (char **) xrealloc ((char *) lines,
call    0 never executed
        -: 3092:					  nlines * sizeof (char *));
        -: 3093:	    }
    #####: 3094:	  lines[idx++] = savestring (p, end - p);
call    0 never executed
    #####: 3095:	  p = end;
    #####: 3096:	  if (*p != '\0')
branch  0 never executed
branch  1 never executed
    #####: 3097:	    ++p;
        -: 3098:	}
        -: 3099:
    #####: 3100:      if (idx != nlines)
branch  0 never executed
branch  1 never executed
        -: 3101:	{
    #####: 3102:	  nlines = idx;
    #####: 3103:	  lines = (char **) xrealloc ((char *) lines,
call    0 never executed
        -: 3104:				      nlines * sizeof (char *));
        -: 3105:	}
        -: 3106:
    #####: 3107:      cmds->ncommand_lines = nlines;
    #####: 3108:      cmds->command_lines = lines;
        -: 3109:
    #####: 3110:      cmds->any_recurse = 0;
    #####: 3111:      cmds->lines_flags = (char *) xmalloc (nlines);
call    0 never executed
    #####: 3112:      for (idx = 0; idx < nlines; ++idx)
branch  0 never executed
branch  1 never executed
        -: 3113:	{
    #####: 3114:	  int flags = 0;
        -: 3115:
    #####: 3116:	  for (p = lines[idx];
    #####: 3117:	       isblank (*p) || *p == '-' || *p == '@' || *p == '+';
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####: 3118:	       ++p)
    #####: 3119:	    switch (*p)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 3120:	      {
    #####: 3121:	      case '+':
    #####: 3122:		flags |= COMMANDS_RECURSE;
    #####: 3123:		break;
    #####: 3124:	      case '@':
    #####: 3125:		flags |= COMMANDS_SILENT;
    #####: 3126:		break;
    #####: 3127:	      case '-':
    #####: 3128:		flags |= COMMANDS_NOERROR;
    #####: 3129:		break;
        -: 3130:	      }
    #####: 3131:	  if (!(flags & COMMANDS_RECURSE))
branch  0 never executed
branch  1 never executed
        -: 3132:	    {
    #####: 3133:	      unsigned int len = strlen (p);
    #####: 3134:	      if (sindex (p, len, "$(MAKE)", 7) != 0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3135:		  || sindex (p, len, "${MAKE}", 7) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3136:		flags |= COMMANDS_RECURSE;
        -: 3137:	    }
        -: 3138:
    #####: 3139:	  cmds->lines_flags[idx] = flags;
    #####: 3140:	  cmds->any_recurse |= flags & COMMANDS_RECURSE;
        -: 3141:	}
        -: 3142:    }
    #####: 3143:}
        -: 3144:
        -: 3145:/* Execute the commands to remake FILE.  If they are currently executing,
        -: 3146:   return or have already finished executing, just return.  Otherwise,
        -: 3147:   fork off a child process to run the first command line in the sequence.  */
        -: 3148:
        -: 3149:void
function execute_file_commands called 0 returned 0% blocks executed 0%
    #####: 3150:execute_file_commands (file)
        -: 3151:     struct file *file;
        -: 3152:{
        -: 3153:  register char *p;
        -: 3154:
        -: 3155:  /* Don't go through all the preparations if
        -: 3156:     the commands are nothing but whitespace.  */
        -: 3157:
    #####: 3158:  for (p = file->cmds->commands; *p != '\0'; ++p)
branch  0 never executed
branch  1 never executed
    #####: 3159:    if (!isspace (*p) && *p != '-' && *p != '@')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 3160:      break;
    #####: 3161:  if (*p == '\0')
branch  0 never executed
branch  1 never executed
        -: 3162:    {
        -: 3163:      /* We are all out of commands.
        -: 3164:	 If we have gotten this far, all the previous commands
        -: 3165:	 have run successfully, so we have winning update status.  */
    #####: 3166:      set_command_state (file, cs_running);
call    0 never executed
    #####: 3167:      file->update_status = 0;
    #####: 3168:      notice_finished_file (file);
call    0 never executed
    #####: 3169:      return;
        -: 3170:    }
        -: 3171:
        -: 3172:  /* First set the automatic variables according to this file.  */
        -: 3173:
    #####: 3174:  initialize_file_variables (file);
call    0 never executed
        -: 3175:
    #####: 3176:  set_file_variables (file);
call    0 never executed
        -: 3177:
        -: 3178:  /* Start the commands running.  */
    #####: 3179:  new_job (file);
call    0 never executed
        -: 3180:}
        -: 3181:
        -: 3182:/* This is set while we are inside fatal_error_signal,
        -: 3183:   so things can avoid nonreentrant operations.  */
        -: 3184:
        -: 3185:int handling_fatal_signal = 0;
        -: 3186:
        -: 3187:/* Handle fatal signals.  */
        -: 3188:
        -: 3189:RETSIGTYPE
function fatal_error_signal called 0 returned 0% blocks executed 0%
    #####: 3190:fatal_error_signal (sig)
        -: 3191:     int sig;
        -: 3192:{
        -: 3193:#ifdef __MSDOS__
        -: 3194:  extern int dos_status, dos_command_running;
        -: 3195:
        -: 3196:  if (dos_command_running)
        -: 3197:    {
        -: 3198:      /* That was the child who got the signal, not us.  */
        -: 3199:      dos_status |= (sig << 8);
        -: 3200:      return;
        -: 3201:    }
        -: 3202:  remove_intermediates (1);
        -: 3203:  exit (EXIT_FAILURE);
        -: 3204:#else /* not __MSDOS__ */
        -: 3205:#ifdef _AMIGA
        -: 3206:  remove_intermediates (1);
        -: 3207:  if (sig == SIGINT)
        -: 3208:     fputs (_("*** Break.\n"), stderr);
        -: 3209:
        -: 3210:  exit (10);
        -: 3211:#else /* not Amiga */
    #####: 3212:  handling_fatal_signal = 1;
        -: 3213:
        -: 3214:  /* Set the handling for this signal to the default.
        -: 3215:     It is blocked now while we run this handler.  */
    #####: 3216:  signal (sig, SIG_DFL);
call    0 never executed
        -: 3217:
        -: 3218:  /* A termination signal won't be sent to the entire
        -: 3219:     process group, but it means we want to kill the children.  */
        -: 3220:
    #####: 3221:  if (sig == SIGTERM)
branch  0 never executed
branch  1 never executed
        -: 3222:    {
        -: 3223:      register struct child *c;
    #####: 3224:      for (c = children; c != 0; c = c->next)
branch  0 never executed
branch  1 never executed
    #####: 3225:	if (!c->remote)
branch  0 never executed
branch  1 never executed
    #####: 3226:	  (void) kill (c->pid, SIGTERM);
call    0 never executed
        -: 3227:    }
        -: 3228:
        -: 3229:  /* If we got a signal that means the user
        -: 3230:     wanted to kill make, remove pending targets.  */
        -: 3231:
    #####: 3232:  if (sig == SIGTERM || sig == SIGINT
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 3233:#ifdef SIGHUP
    #####: 3234:    || sig == SIGHUP
branch  0 never executed
branch  1 never executed
        -: 3235:#endif
        -: 3236:#ifdef SIGQUIT
    #####: 3237:    || sig == SIGQUIT
branch  0 never executed
branch  1 never executed
        -: 3238:#endif
        -: 3239:    )
    #####: 3240:    {
        -: 3241:      register struct child *c;
        -: 3242:
        -: 3243:      /* Remote children won't automatically get signals sent
        -: 3244:	 to the process group, so we must send them.  */
    #####: 3245:      for (c = children; c != 0; c = c->next)
branch  0 never executed
branch  1 never executed
    #####: 3246:	if (c->remote)
branch  0 never executed
branch  1 never executed
    #####: 3247:	  (void) remote_kill (c->pid, sig);
call    0 never executed
        -: 3248:
    #####: 3249:      for (c = children; c != 0; c = c->next)
branch  0 never executed
branch  1 never executed
    #####: 3250:	delete_child_targets (c);
call    0 never executed
        -: 3251:
        -: 3252:      /* Clean up the children.  We don't just use the call below because
        -: 3253:	 we don't want to print the "Waiting for children" message.  */
    #####: 3254:      while (job_slots_used > 0)
branch  0 never executed
branch  1 never executed
    #####: 3255:	reap_children (1, 0);
call    0 never executed
        -: 3256:    }
        -: 3257:  else
        -: 3258:    /* Wait for our children to die.  */
    #####: 3259:    while (job_slots_used > 0)
branch  0 never executed
branch  1 never executed
    #####: 3260:      reap_children (1, 1);
call    0 never executed
        -: 3261:
        -: 3262:  /* Delete any non-precious intermediate files that were made.  */
        -: 3263:
    #####: 3264:  remove_intermediates (1);
call    0 never executed
        -: 3265:
        -: 3266:#ifdef SIGQUIT
    #####: 3267:  if (sig == SIGQUIT)
branch  0 never executed
branch  1 never executed
        -: 3268:    /* We don't want to send ourselves SIGQUIT, because it will
        -: 3269:       cause a core dump.  Just exit instead.  */
    #####: 3270:    exit (EXIT_FAILURE);
call    0 never executed
        -: 3271:#endif
        -: 3272:
        -: 3273:  /* Signal the same code; this time it will really be fatal.  The signal
        -: 3274:     will be unblocked when we return and arrive then to kill us.  */
    #####: 3275:  if (kill (getpid (), sig) < 0)
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3276:    pfatal_with_name ("kill");
call    0 never executed
        -: 3277:#endif /* not Amiga */
        -: 3278:#endif /* not __MSDOS__  */
    #####: 3279:}
        -: 3280:
        -: 3281:/* Delete FILE unless it's precious or not actually a file (phony),
        -: 3282:   and it has changed on disk since we last stat'd it.  */
        -: 3283:
        -: 3284:static void
function delete_target called 0 returned 0% blocks executed 0%
    #####: 3285:delete_target (file, on_behalf_of)
        -: 3286:     struct file *file;
        -: 3287:     char *on_behalf_of;
        -: 3288:{
        -: 3289:  struct stat st;
        -: 3290:
    #####: 3291:  if (file->precious || file->phony)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3292:    return;
        -: 3293:
        -: 3294:#ifndef NO_ARCHIVES
    #####: 3295:  if (ar_name (file->name))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 3296:    {
    #####: 3297:      if (ar_member_date (file->name) != FILE_TIMESTAMP_S (file->last_mtime))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 3298:	{
    #####: 3299:	  if (on_behalf_of)
branch  0 never executed
branch  1 never executed
    #####: 3300:	    error (NILF, _("*** [%s] Archive member `%s' may be bogus; not deleted"),
call    0 never executed
        -: 3301:		   on_behalf_of, file->name);
        -: 3302:	  else
    #####: 3303:	    error (NILF, _("*** Archive member `%s' may be bogus; not deleted"),
call    0 never executed
        -: 3304:		   file->name);
        -: 3305:	}
    #####: 3306:      return;
        -: 3307:    }
        -: 3308:#endif
        -: 3309:
    #####: 3310:  if (stat (file->name, &st) == 0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3311:      && S_ISREG (st.st_mode)
branch  0 never executed
branch  1 never executed
    #####: 3312:      && FILE_TIMESTAMP_STAT_MODTIME (st) != file->last_mtime)
branch  0 never executed
branch  1 never executed
        -: 3313:    {
    #####: 3314:      if (on_behalf_of)
branch  0 never executed
branch  1 never executed
    #####: 3315:	error (NILF, _("*** [%s] Deleting file `%s'"), on_behalf_of, file->name);
call    0 never executed
        -: 3316:      else
    #####: 3317:	error (NILF, _("*** Deleting file `%s'"), file->name);
call    0 never executed
    #####: 3318:      if (unlink (file->name) < 0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3319:	  && errno != ENOENT)	/* It disappeared; so what.  */
branch  0 never executed
branch  1 never executed
    #####: 3320:	perror_with_name ("unlink: ", file->name);
call    0 never executed
        -: 3321:    }
        -: 3322:}
        -: 3323:
        -: 3324:
        -: 3325:/* Delete all non-precious targets of CHILD unless they were already deleted.
        -: 3326:   Set the flag in CHILD to say they've been deleted.  */
        -: 3327:
        -: 3328:void
function delete_child_targets called 0 returned 0% blocks executed 0%
    #####: 3329:delete_child_targets (child)
        -: 3330:     struct child *child;
        -: 3331:{
        -: 3332:  struct dep *d;
        -: 3333:
    #####: 3334:  if (child->deleted)
branch  0 never executed
branch  1 never executed
    #####: 3335:    return;
        -: 3336:
        -: 3337:  /* Delete the target file if it changed.  */
    #####: 3338:  delete_target (child->file, (char *) 0);
call    0 never executed
        -: 3339:
        -: 3340:  /* Also remove any non-precious targets listed in the `also_make' member.  */
    #####: 3341:  for (d = child->file->also_make; d != 0; d = d->next)
branch  0 never executed
branch  1 never executed
    #####: 3342:    delete_target (d->file, child->file->name);
call    0 never executed
        -: 3343:
    #####: 3344:  child->deleted = 1;
        -: 3345:}
        -: 3346:
        -: 3347:/* Print out the commands in CMDS.  */
        -: 3348:
        -: 3349:void
function print_commands called 38016 returned 100% blocks executed 93%
    38016: 3350:print_commands (cmds)
        -: 3351:     register struct commands *cmds;
        -: 3352:{
        -: 3353:  register char *s;
        -: 3354:
    38016: 3355:  fputs (_("#  commands to execute"), stdout);
call    0 returned 38016
        -: 3356:
    38016: 3357:  if (cmds->fileinfo.filenm == 0)
branch  0 taken 38016 (fallthrough)
branch  1 taken 0
    38016: 3358:    puts (_(" (built-in):"));
call    0 returned 38016
        -: 3359:  else
    #####: 3360:    printf (_(" (from `%s', line %lu):\n"),
call    0 never executed
        -: 3361:            cmds->fileinfo.filenm, cmds->fileinfo.lineno);
        -: 3362:
    38016: 3363:  s = cmds->commands;
    83328: 3364:  while (*s != '\0')
branch  0 taken 45312
branch  1 taken 38016 (fallthrough)
        -: 3365:    {
        -: 3366:      char *end;
        -: 3367:
    59136: 3368:      while (isspace (*s))
branch  0 taken 13824
branch  1 taken 45312 (fallthrough)
    13824: 3369:	++s;
        -: 3370:
    45312: 3371:      end = index (s, '\n');
    45312: 3372:      if (end == 0)
branch  0 taken 38016 (fallthrough)
branch  1 taken 7296
    38016: 3373:	end = s + strlen (s);
        -: 3374:
    45312: 3375:      printf ("\t%.*s\n", (int) (end - s), s);
call    0 returned 45312
        -: 3376:
    45312: 3377:      s = end;
        -: 3378:    }
    38016: 3379:}
        -: 3380:
        -: 3381:
        -: 3382:
        -: 3383:/*************************************************************
        -: 3384:  ============================================================
        -: 3385:  ************************************************************
        -: 3386:  ============================================================
        -: 3387:  ************************************************************
        -: 3388:                         job.c
        -: 3389:  ************************************************************
        -: 3390:  ============================================================
        -: 3391:  ************************************************************
        -: 3392:  ============================================================
        -: 3393:  *************************************************************/
        -: 3394:
        -: 3395:/* Job execution and handling for GNU Make.
        -: 3396:Copyright (C) 1988,89,90,91,92,93,94,95,96,97,99 Free Software Foundation, Inc.
        -: 3397:This file is part of GNU Make.
        -: 3398:
        -: 3399:GNU Make is free software; you can redistribute it and/or modify
        -: 3400:it under the terms of the GNU General Public License as published by
        -: 3401:the Free Software Foundation; either version 2, or (at your option)
        -: 3402:any later version.
        -: 3403:
        -: 3404:GNU Make is distributed in the hope that it will be useful,
        -: 3405:but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 3406:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 3407:GNU General Public License for more details.
        -: 3408:
        -: 3409:You should have received a copy of the GNU General Public License
        -: 3410:along with GNU Make; see the file COPYING.  If not, write to
        -: 3411:the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
        -: 3412:Boston, MA 02111-1307, USA.  */
        -: 3413:
        -: 3414:/* #include "make.h"  <- modification by J.Ruthruff, 7/27 */
        -: 3415:#include "job.h"
        -: 3416:/* #include "filedef.h"  <- modification by J.Ruthruff, 7/27 */
        -: 3417:/* #include "commands.h"  <- modification by J.Ruthruff, 7/27 */
        -: 3418:/* #include "variable.h"  <- modification by J.Ruthruff, 7/27 */
        -: 3419:#include <assert.h>
        -: 3420:#undef stderr
        -: 3421:#define stderr stdout
        -: 3422:
        -: 3423:/* Default shell to use.  */
        -: 3424:#ifdef WINDOWS32
        -: 3425:char *default_shell = "sh.exe";
        -: 3426:int no_default_sh_exe = 1;
        -: 3427:int batch_mode_shell = 1;
        -: 3428:#else  /* WINDOWS32 */
        -: 3429:# ifdef _AMIGA
        -: 3430:char default_shell[] = "";
        -: 3431:extern int MyExecute (char **);
        -: 3432:# else /* _AMIGA */
        -: 3433:#  ifdef __MSDOS__
        -: 3434:/* The default shell is a pointer so we can change it if Makefile
        -: 3435:   says so.  It is without an explicit path so we get a chance
        -: 3436:   to search the $PATH for it (since MSDOS doesn't have standard
        -: 3437:   directories we could trust).  */
        -: 3438:char *default_shell = "command.com";
        -: 3439:#  else  /* __MSDOS__ */
        -: 3440:char default_shell[] = "/bin/sh";
        -: 3441:#  endif /* __MSDOS__ */
        -: 3442:int batch_mode_shell = 0;
        -: 3443:# endif /* _AMIGA */
        -: 3444:#endif /* WINDOWS32 */
        -: 3445:
        -: 3446:#ifdef __MSDOS__
        -: 3447:# include <process.h>
        -: 3448:#undef stderr
        -: 3449:#define stderr stdout
        -: 3450:static int execute_by_shell;
        -: 3451:static int dos_pid = 123;
        -: 3452:int dos_status;
        -: 3453:int dos_command_running;
        -: 3454:#endif /* __MSDOS__ */
        -: 3455:
        -: 3456:#ifdef _AMIGA
        -: 3457:# include <proto/dos.h>
        -: 3458:#undef stderr
        -: 3459:#define stderr stdout
        -: 3460:static int amiga_pid = 123;
        -: 3461:static int amiga_status;
        -: 3462:static char amiga_bname[32];
        -: 3463:static int amiga_batch_file;
        -: 3464:#endif /* Amiga.  */
        -: 3465:
        -: 3466:#ifdef VMS
        -: 3467:# include <time.h>
        -: 3468:# include <processes.h>
        -: 3469:# include <starlet.h>
        -: 3470:# include <lib$routines.h>
        -: 3471:#undef stderr
        -: 3472:#define stderr stdout
        -: 3473:#endif
        -: 3474:
        -: 3475:#ifdef WINDOWS32
        -: 3476:# include <windows.h>
        -: 3477:# include <io.h>
        -: 3478:# include <process.h>
        -: 3479:# include "sub_proc.h"
        -: 3480:# include "w32err.h"
        -: 3481:# include "pathstuff.h"
        -: 3482:#undef stderr
        -: 3483:#define stderr stdout
        -: 3484:#endif /* WINDOWS32 */
        -: 3485:
        -: 3486:#ifdef HAVE_FCNTL_H
        -: 3487:# include <fcntl.h>
        -: 3488:#undef stderr
        -: 3489:#define stderr stdout
        -: 3490:#else
        -: 3491:# include <sys/file.h>
        -: 3492:#undef stderr
        -: 3493:#define stderr stdout
        -: 3494:#endif
        -: 3495:
        -: 3496:#if defined (HAVE_SYS_WAIT_H) || defined (HAVE_UNION_WAIT)
        -: 3497:# include <sys/wait.h>
        -: 3498:#undef stderr
        -: 3499:#define stderr stdout
        -: 3500:#endif
        -: 3501:
        -: 3502:#ifdef HAVE_WAITPID
        -: 3503:# define WAIT_NOHANG(status)	waitpid (-1, (status), WNOHANG)
        -: 3504:#else	/* Don't have waitpid.  */
        -: 3505:# ifdef HAVE_WAIT3
        -: 3506:#  ifndef wait3
        -: 3507:extern int wait3 ();
        -: 3508:#  endif
        -: 3509:#  define WAIT_NOHANG(status)	wait3 ((status), WNOHANG, (struct rusage *) 0)
        -: 3510:# endif /* Have wait3.  */
        -: 3511:#endif /* Have waitpid.  */
        -: 3512:
        -: 3513:#if !defined (wait) && !defined (POSIX)
        -: 3514:extern int wait ();
        -: 3515:#endif
        -: 3516:
        -: 3517:#ifndef	HAVE_UNION_WAIT
        -: 3518:
        -: 3519:# define WAIT_T int
        -: 3520:
        -: 3521:# ifndef WTERMSIG
        -: 3522:#  define WTERMSIG(x) ((x) & 0x7f)
        -: 3523:# endif
        -: 3524:# ifndef WCOREDUMP
        -: 3525:#  define WCOREDUMP(x) ((x) & 0x80)
        -: 3526:# endif
        -: 3527:# ifndef WEXITSTATUS
        -: 3528:#  define WEXITSTATUS(x) (((x) >> 8) & 0xff)
        -: 3529:# endif
        -: 3530:# ifndef WIFSIGNALED
        -: 3531:#  define WIFSIGNALED(x) (WTERMSIG (x) != 0)
        -: 3532:# endif
        -: 3533:# ifndef WIFEXITED
        -: 3534:#  define WIFEXITED(x) (WTERMSIG (x) == 0)
        -: 3535:# endif
        -: 3536:
        -: 3537:#else	/* Have `union wait'.  */
        -: 3538:
        -: 3539:# define WAIT_T union wait
        -: 3540:# ifndef WTERMSIG
        -: 3541:#  define WTERMSIG(x) ((x).w_termsig)
        -: 3542:# endif
        -: 3543:# ifndef WCOREDUMP
        -: 3544:#  define WCOREDUMP(x) ((x).w_coredump)
        -: 3545:# endif
        -: 3546:# ifndef WEXITSTATUS
        -: 3547:#  define WEXITSTATUS(x) ((x).w_retcode)
        -: 3548:# endif
        -: 3549:# ifndef WIFSIGNALED
        -: 3550:#  define WIFSIGNALED(x) (WTERMSIG(x) != 0)
        -: 3551:# endif
        -: 3552:# ifndef WIFEXITED
        -: 3553:#  define WIFEXITED(x) (WTERMSIG(x) == 0)
        -: 3554:# endif
        -: 3555:
        -: 3556:#endif	/* Don't have `union wait'.  */
        -: 3557:
        -: 3558:/* How to set close-on-exec for a file descriptor.  */
        -: 3559:
        -: 3560:#if !defined F_SETFD
        -: 3561:# define CLOSE_ON_EXEC(_d)
        -: 3562:#else
        -: 3563:# ifndef FD_CLOEXEC
        -: 3564:#  define FD_CLOEXEC 1
        -: 3565:# endif
        -: 3566:# define CLOSE_ON_EXEC(_d) (void) fcntl ((_d), F_SETFD, FD_CLOEXEC)
        -: 3567:#endif
        -: 3568:
        -: 3569:#ifdef VMS
        -: 3570:static int vms_jobsefnmask = 0;
        -: 3571:#endif /* !VMS */
        -: 3572:
        -: 3573:#ifndef	HAVE_UNISTD_H
        -: 3574:extern int dup2 ();
        -: 3575:extern int execve ();
        -: 3576:extern void _exit ();
        -: 3577:# ifndef VMS
        -: 3578:extern int geteuid ();
        -: 3579:extern int getegid ();
        -: 3580:extern int setgid ();
        -: 3581:extern int getgid ();
        -: 3582:# endif
        -: 3583:#endif
        -: 3584:
        -: 3585:extern char *allocated_variable_expand_for_file PARAMS ((char *line, struct file *file));
        -: 3586:
        -: 3587:extern int getloadavg PARAMS ((double loadavg[], int nelem));
        -: 3588:extern int start_remote_job PARAMS ((char **argv, char **envp, int stdin_fd,
        -: 3589:		int *is_remote, int *id_ptr, int *used_stdin));
        -: 3590:extern int start_remote_job_p PARAMS ((int));
        -: 3591:extern int remote_status PARAMS ((int *exit_code_ptr, int *signal_ptr,
        -: 3592:		int *coredump_ptr, int block));
        -: 3593:
        -: 3594:static void free_child PARAMS ((struct child *));
        -: 3595:static void start_job_command PARAMS ((struct child *child));
        -: 3596:static int load_too_high PARAMS ((void));
        -: 3597:static int job_next_command PARAMS ((struct child *));
        -: 3598:static int start_waiting_job PARAMS ((struct child *));
        -: 3599:#ifdef VMS
        -: 3600:static void vmsWaitForChildren PARAMS ((int *));
        -: 3601:#endif
        -: 3602:
        -: 3603:/* Chain of all live (or recently deceased) children.  */
        -: 3604:
        -: 3605:struct child *children = 0;
        -: 3606:
        -: 3607:/* Number of children currently running.  */
        -: 3608:
        -: 3609:unsigned int job_slots_used = 0;
        -: 3610:
        -: 3611:/* Nonzero if the `good' standard input is in use.  */
        -: 3612:
        -: 3613:static int good_stdin_used = 0;
        -: 3614:
        -: 3615:/* Chain of children waiting to run until the load average goes down.  */
        -: 3616:
        -: 3617:static struct child *waiting_jobs = 0;
        -: 3618:
        -: 3619:/* Non-zero if we use a *real* shell (always so on Unix).  */
        -: 3620:
        -: 3621:int unixy_shell = 1;
        -: 3622:
        -: 3623:/* #define debug_flag 1 */
        -: 3624:
        -: 3625:
        -: 3626:#ifdef WINDOWS32
        -: 3627:/*
        -: 3628: * The macro which references this function is defined in make.h.
        -: 3629: */
        -: 3630:int w32_kill(int pid, int sig)
        -: 3631:{
        -: 3632:  return ((process_kill(pid, sig) == TRUE) ? 0 : -1);
        -: 3633:}
        -: 3634:#endif /* WINDOWS32 */
        -: 3635:
        -: 3636:
        -: 3637:/* Write an error message describing the exit status given in
        -: 3638:   EXIT_CODE, EXIT_SIG, and COREDUMP, for the target TARGET_NAME.
        -: 3639:   Append "(ignored)" if IGNORED is nonzero.  */
        -: 3640:
        -: 3641:static void
function child_error called 0 returned 0% blocks executed 0%
    #####: 3642:child_error (target_name, exit_code, exit_sig, coredump, ignored)
        -: 3643:     char *target_name;
        -: 3644:     int exit_code, exit_sig, coredump;
        -: 3645:     int ignored;
        -: 3646:{
    #####: 3647:  if (ignored && silent_flag)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3648:    return;
        -: 3649:
        -: 3650:#ifdef VMS
        -: 3651:  if (!(exit_code & 1))
        -: 3652:      error (NILF, _("*** [%s] Error 0x%x%s"), target_name, exit_code, ((ignored)? _(" (ignored)") : ""));
        -: 3653:#else
    #####: 3654:  if (exit_sig == 0)
branch  0 never executed
branch  1 never executed
    #####: 3655:    error (NILF, ignored ? _("[%s] Error %d (ignored)") :
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 3656:	   _("*** [%s] Error %d"),
        -: 3657:	   target_name, exit_code);
        -: 3658:  else
    #####: 3659:    error (NILF, "*** [%s] %s%s",
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
        -: 3660:	   target_name, strsignal (exit_sig),
        -: 3661:	   coredump ? _(" (core dumped)") : "");
        -: 3662:#endif /* VMS */
        -: 3663:}
        -: 3664:
        -: 3665:#ifdef VMS
        -: 3666:/* Wait for nchildren children to terminate */
        -: 3667:static void
        -: 3668:vmsWaitForChildren(int *status)
        -: 3669:{
        -: 3670:  while (1)
        -: 3671:    {
        -: 3672:      if (!vms_jobsefnmask)
        -: 3673:	{
        -: 3674:	  *status = 0;
        -: 3675:	  return;
        -: 3676:	}
        -: 3677:
        -: 3678:      *status = sys$wflor (32, vms_jobsefnmask);
        -: 3679:    }
        -: 3680:  return;
        -: 3681:}
        -: 3682:#endif
        -: 3683:
        -: 3684:
        -: 3685:/* Handle a dead child.  This handler may or may not ever be installed.
        -: 3686:
        -: 3687:   If we're using the jobserver feature, we need it.  First, installing it
        -: 3688:   ensures the read will interrupt on SIGCHLD.  Second, we close the dup'd
        -: 3689:   read FD to ensure we don't enter another blocking read without reaping all
        -: 3690:   the dead children.  In this case we don't need the dead_children count.
        -: 3691:
        -: 3692:   If we don't have either waitpid or wait3, then make is unreliable, but we
        -: 3693:   use the dead_children count to reap children as best we can.  */
        -: 3694:
        -: 3695:static unsigned int dead_children = 0;
        -: 3696:
        -: 3697:RETSIGTYPE
        -: 3698:child_handler (sig)
        -: 3699:     int sig;
        -: 3700:{
    #####: 3701:  ++dead_children;
        -: 3702:
    #####: 3703:  if (job_rfd >= 0)
branch  0 never executed
branch  1 never executed
        -: 3704:    {
    #####: 3705:      close (job_rfd);
call    0 never executed
    #####: 3706:      job_rfd = -1;
        -: 3707:    }
        -: 3708:
    #####: 3709:  if (debug_flag)
branch  0 never executed
branch  1 never executed
    #####: 3710:    printf (_("Got a SIGCHLD; %u unreaped children.\n"), dead_children);
call    0 never executed
    #####: 3711:}
        -: 3712:
        -: 3713:
        -: 3714:extern int shell_function_pid, shell_function_completed;
        -: 3715:
        -: 3716:/* Reap all dead children, storing the returned status and the new command
        -: 3717:   state (`cs_finished') in the `file' member of the `struct child' for the
        -: 3718:   dead child, and removing the child from the chain.  In addition, if BLOCK
        -: 3719:   nonzero, we block in this function until we've reaped at least one
        -: 3720:   complete child, waiting for it to die if necessary.  If ERR is nonzero,
        -: 3721:   print an error message first.  */
        -: 3722:
        -: 3723:void
function reap_children called 771 returned 100% blocks executed 4%
      771: 3724:reap_children (block, err)
        -: 3725:     int block, err;
        -: 3726:{
        -: 3727:  WAIT_T status;
        -: 3728:  /* Initially, assume we have some.  */
        -: 3729:#ifndef F_JR_8  /* seeded fault #8; J.Ruthruff */
      771: 3730:  int reap_more = 1;
        -: 3731:#else
        -: 3732:  int reap_more = 0;
        -: 3733:#endif
        -: 3734:
        -: 3735:#ifdef WAIT_NOHANG
        -: 3736:# define REAP_MORE reap_more
        -: 3737:#else
        -: 3738:# define REAP_MORE dead_children
        -: 3739:#endif
        -: 3740:
        -: 3741:  /* As long as:
        -: 3742:
        -: 3743:       We have at least one child outstanding OR a shell function in progress,
        -: 3744:         AND
        -: 3745:       We're blocking for a complete child OR there are more children to reap
        -: 3746:
        -: 3747:     we'll keep reaping children.  */
        -: 3748:
     771*: 3749:  while ((children != 0 || shell_function_pid != 0) &&
branch  0 taken 771 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 771
branch  4 never executed
branch  5 never executed
    #####: 3750:	 (block || REAP_MORE))
branch  0 never executed
branch  1 never executed
        -: 3751:    {
    #####: 3752:      int remote = 0;
        -: 3753:      register int pid;
        -: 3754:      int exit_code, exit_sig, coredump;
        -: 3755:      register struct child *lastc, *c;
        -: 3756:      int child_failed;
        -: 3757:      int any_remote, any_local;
        -: 3758:
    #####: 3759:      if (err && block)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 3760:	{
        -: 3761:	  /* We might block for a while, so let the user know why.  */
    #####: 3762:	  fflush (stdout);
call    0 never executed
    #####: 3763:	  error (NILF, _("*** Waiting for unfinished jobs...."));
call    0 never executed
        -: 3764:	}
        -: 3765:
        -: 3766:      /* We have one less dead child to reap.  As noted in
        -: 3767:	 child_handler() above, this count is completely unimportant for
        -: 3768:	 all modern, POSIX-y systems that support wait3() or waitpid().
        -: 3769:	 The rest of this comment below applies only to early, broken
        -: 3770:	 pre-POSIX systems.  We keep the count only because... it's there...
        -: 3771:
        -: 3772:	 The test and decrement are not atomic; if it is compiled into:
        -: 3773:	 	register = dead_children - 1;
        -: 3774:		dead_children = register;
        -: 3775:	 a SIGCHLD could come between the two instructions.
        -: 3776:	 child_handler increments dead_children.
        -: 3777:	 The second instruction here would lose that increment.  But the
        -: 3778:	 only effect of dead_children being wrong is that we might wait
        -: 3779:	 longer than necessary to reap a child, and lose some parallelism;
        -: 3780:	 and we might print the "Waiting for unfinished jobs" message above
        -: 3781:	 when not necessary.  */
        -: 3782:
    #####: 3783:      if (dead_children > 0)
branch  0 never executed
branch  1 never executed
    #####: 3784:	--dead_children;
        -: 3785:
    #####: 3786:      any_remote = 0;
    #####: 3787:      any_local = shell_function_pid != 0;
    #####: 3788:      for (c = children; c != 0; c = c->next)
branch  0 never executed
branch  1 never executed
        -: 3789:	{
    #####: 3790:	  any_remote |= c->remote;
    #####: 3791:	  any_local |= ! c->remote;
    #####: 3792:	  if (debug_flag)
branch  0 never executed
branch  1 never executed
    #####: 3793:	    printf (_("Live child 0x%08lx (%s) PID %ld %s\n"),
    #####: 3794:		    (unsigned long int) c, c->file->name,
    #####: 3795:                    (long) c->pid, c->remote ? _(" (remote)") : "");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 3796:#ifdef VMS
        -: 3797:	  break;
        -: 3798:#endif
        -: 3799:	}
        -: 3800:
        -: 3801:      /* First, check for remote children.  */
    #####: 3802:      if (any_remote)
branch  0 never executed
branch  1 never executed
    #####: 3803:	pid = remote_status (&exit_code, &exit_sig, &coredump, 0);
call    0 never executed
        -: 3804:      else
    #####: 3805:	pid = 0;
        -: 3806:
    #####: 3807:      if (pid > 0)
branch  0 never executed
branch  1 never executed
        -: 3808:	/* We got a remote child.  */
    #####: 3809:	remote = 1;
    #####: 3810:      else if (pid < 0)
branch  0 never executed
branch  1 never executed
        -: 3811:	{
        -: 3812:          /* A remote status command failed miserably.  Punt.  */
    #####: 3813:	remote_status_lose:
    #####: 3814:	  if (EINTR_SET)
branch  0 never executed
branch  1 never executed
    #####: 3815:	    continue;
        -: 3816:
    #####: 3817:	  pfatal_with_name ("remote_status");
call    0 never executed
        -: 3818:	}
        -: 3819:      else
        -: 3820:	{
        -: 3821:	  /* No remote children.  Check for local children.  */
        -: 3822:#if !defined(__MSDOS__) && !defined(_AMIGA) && !defined(WINDOWS32)
    #####: 3823:	  if (any_local)
branch  0 never executed
branch  1 never executed
        -: 3824:	    {
    #####: 3825:            local_wait:
        -: 3826:#ifdef VMS
        -: 3827:	      vmsWaitForChildren (&status);
        -: 3828:	      pid = c->pid;
        -: 3829:#else
        -: 3830:#ifdef WAIT_NOHANG
    #####: 3831:	      if (!block)
branch  0 never executed
branch  1 never executed
    #####: 3832:		pid = WAIT_NOHANG (&status);
call    0 never executed
        -: 3833:	      else
        -: 3834:#endif
    #####: 3835:		pid = wait (&status);
call    0 never executed
        -: 3836:#endif /* !VMS */
        -: 3837:	    }
        -: 3838:	  else
    #####: 3839:	    pid = 0;
        -: 3840:
    #####: 3841:	  if (pid < 0)
branch  0 never executed
branch  1 never executed
        -: 3842:	    {
        -: 3843:              /* EINTR?  Try again. */
    #####: 3844:	      if (EINTR_SET)
branch  0 never executed
branch  1 never executed
    #####: 3845:		goto local_wait;
        -: 3846:
        -: 3847:              /* The wait*() failed miserably.  Punt.  */
    #####: 3848:	      pfatal_with_name ("wait");
call    0 never executed
        -: 3849:	    }
    #####: 3850:	  else if (pid > 0)
branch  0 never executed
branch  1 never executed
        -: 3851:	    {
        -: 3852:	      /* We got a child exit; chop the status word up.  */
    #####: 3853:	      exit_code = WEXITSTATUS (status);
    #####: 3854:	      exit_sig = WIFSIGNALED (status) ? WTERMSIG (status) : 0;
branch  0 never executed
branch  1 never executed
    #####: 3855:	      coredump = WCOREDUMP (status);
        -: 3856:	    }
        -: 3857:	  else
        -: 3858:	    {
        -: 3859:	      /* No local children are dead.  */
    #####: 3860:              reap_more = 0;
        -: 3861:
    #####: 3862:	      if (!block || !any_remote)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 3863:                break;
        -: 3864:
        -: 3865:              /* Now try a blocking wait for a remote child.  */
    #####: 3866:              pid = remote_status (&exit_code, &exit_sig, &coredump, 1);
call    0 never executed
    #####: 3867:              if (pid < 0)
branch  0 never executed
branch  1 never executed
    #####: 3868:                goto remote_status_lose;
    #####: 3869:              else if (pid == 0)
branch  0 never executed
branch  1 never executed
        -: 3870:                /* No remote children either.  Finally give up.  */
    #####: 3871:                break;
        -: 3872:
        -: 3873:              /* We got a remote child.  */
    #####: 3874:              remote = 1;
        -: 3875:	    }
        -: 3876:#endif /* !__MSDOS__, !Amiga, !WINDOWS32.  */
        -: 3877:
        -: 3878:#ifdef __MSDOS__
        -: 3879:	  /* Life is very different on MSDOS.  */
        -: 3880:	  pid = dos_pid - 1;
        -: 3881:	  status = dos_status;
        -: 3882:	  exit_code = WEXITSTATUS (status);
        -: 3883:	  if (exit_code == 0xff)
        -: 3884:	    exit_code = -1;
        -: 3885:	  exit_sig = WIFSIGNALED (status) ? WTERMSIG (status) : 0;
        -: 3886:	  coredump = 0;
        -: 3887:#endif /* __MSDOS__ */
        -: 3888:#ifdef _AMIGA
        -: 3889:	  /* Same on Amiga */
        -: 3890:	  pid = amiga_pid - 1;
        -: 3891:	  status = amiga_status;
        -: 3892:	  exit_code = amiga_status;
        -: 3893:	  exit_sig = 0;
        -: 3894:	  coredump = 0;
        -: 3895:#endif /* _AMIGA */
        -: 3896:#ifdef WINDOWS32
        -: 3897:          {
        -: 3898:            HANDLE hPID;
        -: 3899:            int err;
        -: 3900:
        -: 3901:            /* wait for anything to finish */
        -: 3902:            if (hPID = process_wait_for_any()) {
        -: 3903:
        -: 3904:              /* was an error found on this process? */
        -: 3905:              err = process_last_err(hPID);
        -: 3906:
        -: 3907:              /* get exit data */
        -: 3908:              exit_code = process_exit_code(hPID);
        -: 3909:
        -: 3910:              if (err)
        -: 3911:                fprintf(stderr, "make (e=%d): %s",
        -: 3912:                  exit_code, map_windows32_error_to_string(exit_code));
        -: 3913:
        -: 3914:              /* signal */
        -: 3915:              exit_sig = process_signal(hPID);
        -: 3916:
        -: 3917:              /* cleanup process */
        -: 3918:              process_cleanup(hPID);
        -: 3919:
        -: 3920:              coredump = 0;
        -: 3921:            }
        -: 3922:            pid = (int) hPID;
        -: 3923:          }
        -: 3924:#endif /* WINDOWS32 */
        -: 3925:	}
        -: 3926:
        -: 3927:      /* Check if this is the child of the `shell' function.  */
    #####: 3928:      if (!remote && pid == shell_function_pid)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 3929:	{
        -: 3930:	  /* It is.  Leave an indicator for the `shell' function.  */
    #####: 3931:	  if (exit_sig == 0 && exit_code == 127)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3932:	    shell_function_completed = -1;
        -: 3933:	  else
    #####: 3934:	    shell_function_completed = 1;
    #####: 3935:	  break;
        -: 3936:	}
        -: 3937:
    #####: 3938:      child_failed = exit_sig != 0 || exit_code != 0;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 3939:
        -: 3940:      /* Search for a child matching the deceased one.  */
    #####: 3941:      lastc = 0;
    #####: 3942:      for (c = children; c != 0; lastc = c, c = c->next)
branch  0 never executed
branch  1 never executed
    #####: 3943:	if (c->remote == remote && c->pid == pid)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3944:	  break;
        -: 3945:
    #####: 3946:      if (c == 0)
branch  0 never executed
branch  1 never executed
        -: 3947:        /* An unknown child died.
        -: 3948:           Ignore it; it was inherited from our invoker.  */
    #####: 3949:        continue;
        -: 3950:
    #####: 3951:      if (debug_flag)
branch  0 never executed
branch  1 never executed
    #####: 3952:        printf (_("Reaping %s child 0x%08lx PID %ld %s\n"),
call    0 never executed
        -: 3953:                child_failed ? _("losing") : _("winning"),
    #####: 3954:                (unsigned long int) c, (long) c->pid,
branch  0 never executed
branch  1 never executed
    #####: 3955:                c->remote ? _(" (remote)") : "");
branch  0 never executed
branch  1 never executed
        -: 3956:
    #####: 3957:      if (c->sh_batch_file) {
branch  0 never executed
branch  1 never executed
    #####: 3958:        if (debug_flag)
branch  0 never executed
branch  1 never executed
    #####: 3959:          printf (_("Cleaning up temp batch file %s\n"), c->sh_batch_file);
call    0 never executed
        -: 3960:
        -: 3961:        /* just try and remove, don't care if this fails */
    #####: 3962:        remove (c->sh_batch_file);
call    0 never executed
        -: 3963:
        -: 3964:        /* all done with memory */
    #####: 3965:        free (c->sh_batch_file);
    #####: 3966:        c->sh_batch_file = NULL;
        -: 3967:      }
        -: 3968:
        -: 3969:      /* If this child had the good stdin, say it is now free.  */
    #####: 3970:      if (c->good_stdin)
branch  0 never executed
branch  1 never executed
    #####: 3971:        good_stdin_used = 0;
        -: 3972:
    #####: 3973:      if (child_failed && !c->noerror && !ignore_errors_flag)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 3974:        {
        -: 3975:          /* The commands failed.  Write an error message,
        -: 3976:             delete non-precious targets, and abort.  */
        -: 3977:          static int delete_on_error = -1;
    #####: 3978:          child_error (c->file->name, exit_code, exit_sig, coredump, 0);
call    0 never executed
    #####: 3979:          c->file->update_status = 2;
    #####: 3980:          if (delete_on_error == -1)
branch  0 never executed
branch  1 never executed
        -: 3981:            {
    #####: 3982:              struct file *f = lookup_file (".DELETE_ON_ERROR");
call    0 never executed
    #####: 3983:              delete_on_error = f != 0 && f->is_target;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 3984:            }
    #####: 3985:          if (exit_sig != 0 || delete_on_error)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3986:            delete_child_targets (c);
call    0 never executed
        -: 3987:        }
        -: 3988:      else
        -: 3989:        {
    #####: 3990:          if (child_failed)
branch  0 never executed
branch  1 never executed
        -: 3991:            {
        -: 3992:              /* The commands failed, but we don't care.  */
    #####: 3993:              child_error (c->file->name,
call    0 never executed
        -: 3994:                           exit_code, exit_sig, coredump, 1);
    #####: 3995:              child_failed = 0;
        -: 3996:            }
        -: 3997:
        -: 3998:          /* If there are more commands to run, try to start them.  */
    #####: 3999:          if (job_next_command (c))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 4000:            {
    #####: 4001:              if (handling_fatal_signal)
branch  0 never executed
branch  1 never executed
        -: 4002:                {
        -: 4003:                  /* Never start new commands while we are dying.
        -: 4004:                     Since there are more commands that wanted to be run,
        -: 4005:                     the target was not completely remade.  So we treat
        -: 4006:                     this as if a command had failed.  */
    #####: 4007:                  c->file->update_status = 2;
        -: 4008:                }
        -: 4009:              else
        -: 4010:                {
        -: 4011:                  /* Check again whether to start remotely.
        -: 4012:                     Whether or not we want to changes over time.
        -: 4013:                     Also, start_remote_job may need state set up
        -: 4014:                     by start_remote_job_p.  */
    #####: 4015:                  c->remote = start_remote_job_p (0);
call    0 never executed
    #####: 4016:                  start_job_command (c);
call    0 never executed
        -: 4017:                  /* Fatal signals are left blocked in case we were
        -: 4018:                     about to put that child on the chain.  But it is
        -: 4019:                     already there, so it is safe for a fatal signal to
        -: 4020:                     arrive now; it will clean up this child's targets.  */
    #####: 4021:                  unblock_sigs ();
call    0 never executed
    #####: 4022:                  if (c->file->command_state == cs_running)
branch  0 never executed
branch  1 never executed
        -: 4023:                    /* We successfully started the new command.
        -: 4024:                       Loop to reap more children.  */
    #####: 4025:                    continue;
        -: 4026:                }
        -: 4027:
    #####: 4028:              if (c->file->update_status != 0)
branch  0 never executed
branch  1 never executed
        -: 4029:                /* We failed to start the commands.  */
    #####: 4030:                delete_child_targets (c);
call    0 never executed
        -: 4031:            }
        -: 4032:          else
        -: 4033:            /* There are no more commands.  We got through them all
        -: 4034:               without an unignored error.  Now the target has been
        -: 4035:               successfully updated.  */
    #####: 4036:            c->file->update_status = 0;
        -: 4037:        }
        -: 4038:
        -: 4039:      /* When we get here, all the commands for C->file are finished
        -: 4040:         (or aborted) and C->file->update_status contains 0 or 2.  But
        -: 4041:         C->file->command_state is still cs_running if all the commands
        -: 4042:         ran; notice_finish_file looks for cs_running to tell it that
        -: 4043:         it's interesting to check the file's modtime again now.  */
        -: 4044:
    #####: 4045:      if (! handling_fatal_signal)
branch  0 never executed
branch  1 never executed
        -: 4046:        /* Notice if the target of the commands has been changed.
        -: 4047:           This also propagates its values for command_state and
        -: 4048:           update_status to its also_make files.  */
    #####: 4049:        notice_finished_file (c->file);
call    0 never executed
        -: 4050:
    #####: 4051:      if (debug_flag)
branch  0 never executed
branch  1 never executed
    #####: 4052:        printf (_("Removing child 0x%08lx PID %ld %s from chain.\n"),
    #####: 4053:                (unsigned long int) c, (long) c->pid,
call    0 never executed
    #####: 4054:                c->remote ? _(" (remote)") : "");
branch  0 never executed
branch  1 never executed
        -: 4055:
        -: 4056:      /* Block fatal signals while frobnicating the list, so that
        -: 4057:         children and job_slots_used are always consistent.  Otherwise
        -: 4058:         a fatal signal arriving after the child is off the chain and
        -: 4059:         before job_slots_used is decremented would believe a child was
        -: 4060:         live and call reap_children again.  */
    #####: 4061:      block_sigs ();
call    0 never executed
        -: 4062:
        -: 4063:      /* There is now another slot open.  */
    #####: 4064:      if (job_slots_used > 0)
branch  0 never executed
branch  1 never executed
    #####: 4065:        --job_slots_used;
        -: 4066:
        -: 4067:      /* Remove the child from the chain and free it.  */
    #####: 4068:      if (lastc == 0)
branch  0 never executed
branch  1 never executed
    #####: 4069:        children = c->next;
        -: 4070:      else
    #####: 4071:        lastc->next = c->next;
        -: 4072:
    #####: 4073:      free_child (c);
call    0 never executed
        -: 4074:
    #####: 4075:      unblock_sigs ();
call    0 never executed
        -: 4076:
        -: 4077:      /* If the job failed, and the -k flag was not given, die,
        -: 4078:         unless we are already in the process of dying.  */
    #####: 4079:      if (!err && child_failed && !keep_going_flag &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 4080:          /* fatal_error_signal will die with the right signal.  */
    #####: 4081:          !handling_fatal_signal)
branch  0 never executed
branch  1 never executed
    #####: 4082:        die (2);
call    0 never executed
        -: 4083:
        -: 4084:      /* Only block for one child.  */
    #####: 4085:      block = 0;
        -: 4086:    }
        -: 4087:
      771: 4088:  return;
        -: 4089:}
        -: 4090:
        -: 4091:/* Free the storage allocated for CHILD.  */
        -: 4092:
        -: 4093:static void
function free_child called 0 returned 0% blocks executed 0%
    #####: 4094:free_child (child)
        -: 4095:     register struct child *child;
        -: 4096:{
        -: 4097:  /* If this child is the only one it was our "free" job, so don't put a
        -: 4098:     token back for it.  This child has already been removed from the list,
        -: 4099:     so if there any left this wasn't the last one.  */
        -: 4100:
    #####: 4101:  if (job_fds[1] >= 0 && children)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 4102:    {
    #####: 4103:      char token = '+';
        -: 4104:
        -: 4105:      /* Write a job token back to the pipe.  */
        -: 4106:
    #####: 4107:      while (write (job_fds[1], &token, 1) != 1)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 4108:        if (!EINTR_SET)
branch  0 never executed
branch  1 never executed
    #####: 4109:          pfatal_with_name (_("write jobserver"));
call    0 never executed
        -: 4110:
    #####: 4111:      if (debug_flag)
branch  0 never executed
branch  1 never executed
    #####: 4112:        printf (_("Released token for child 0x%08lx (%s).\n"),
    #####: 4113:                (unsigned long int) child, child->file->name);
call    0 never executed
        -: 4114:    }
        -: 4115:
    #####: 4116:  if (handling_fatal_signal) /* Don't bother free'ing if about to die.  */
branch  0 never executed
branch  1 never executed
    #####: 4117:    return;
        -: 4118:
    #####: 4119:  if (child->command_lines != 0)
branch  0 never executed
branch  1 never executed
        -: 4120:    {
        -: 4121:      register unsigned int i;
    #####: 4122:      for (i = 0; i < child->file->cmds->ncommand_lines; ++i)
branch  0 never executed
branch  1 never executed
    #####: 4123:	free (child->command_lines[i]);
    #####: 4124:      free ((char *) child->command_lines);
        -: 4125:    }
        -: 4126:
    #####: 4127:  if (child->environment != 0)
branch  0 never executed
branch  1 never executed
        -: 4128:    {
    #####: 4129:      register char **ep = child->environment;
    #####: 4130:      while (*ep != 0)
branch  0 never executed
branch  1 never executed
    #####: 4131:	free (*ep++);
    #####: 4132:      free ((char *) child->environment);
        -: 4133:    }
        -: 4134:
    #####: 4135:  free ((char *) child);
        -: 4136:}
        -: 4137:
        -: 4138:#ifdef POSIX
        -: 4139:extern sigset_t fatal_signal_set;
        -: 4140:#endif
        -: 4141:
        -: 4142:void
function block_sigs called 0 returned 0% blocks executed 0%
    #####: 4143:block_sigs ()
        -: 4144:{
        -: 4145:#ifdef POSIX
    #####: 4146:  (void) sigprocmask (SIG_BLOCK, &fatal_signal_set, (sigset_t *) 0);
call    0 never executed
        -: 4147:#else
        -: 4148:# ifdef HAVE_SIGSETMASK
        -: 4149:  (void) sigblock (fatal_signal_mask);
        -: 4150:# endif
        -: 4151:#endif
    #####: 4152:}
        -: 4153:
        -: 4154:#ifdef	POSIX
        -: 4155:void
function unblock_sigs called 0 returned 0% blocks executed 0%
    #####: 4156:unblock_sigs ()
        -: 4157:{
        -: 4158:  sigset_t empty;
    #####: 4159:  sigemptyset (&empty);
call    0 never executed
    #####: 4160:  sigprocmask (SIG_SETMASK, &empty, (sigset_t *) 0);
call    0 never executed
    #####: 4161:}
        -: 4162:#endif
        -: 4163:
        -: 4164:/* Start a job to run the commands specified in CHILD.
        -: 4165:   CHILD is updated to reflect the commands and ID of the child process.
        -: 4166:
        -: 4167:   NOTE: On return fatal signals are blocked!  The caller is responsible
        -: 4168:   for calling `unblock_sigs', once the new child is safely on the chain so
        -: 4169:   it can be cleaned up in the event of a fatal signal.  */
        -: 4170:
        -: 4171:static void
function start_job_command called 0 returned 0% blocks executed 0%
    #####: 4172:start_job_command (child)
        -: 4173:     register struct child *child;
        -: 4174:{
        -: 4175:#ifndef _AMIGA
        -: 4176:  static int bad_stdin = -1;
        -: 4177:#endif
        -: 4178:  register char *p;
        -: 4179:  int flags;
        -: 4180:#ifdef VMS
        -: 4181:  char *argv;
        -: 4182:#else
        -: 4183:  char **argv;
        -: 4184:#endif
        -: 4185:
        -: 4186:  /* If we have a completely empty commandset, stop now.  */
    #####: 4187:  if (!child->command_ptr)
branch  0 never executed
branch  1 never executed
    #####: 4188:    goto next_command;
        -: 4189:
        -: 4190:  /* Combine the flags parsed for the line itself with
        -: 4191:     the flags specified globally for this target.  */
    #####: 4192:  flags = (child->file->command_flags
    #####: 4193:	   | child->file->cmds->lines_flags[child->command_line - 1]);
        -: 4194:
    #####: 4195:  p = child->command_ptr;
    #####: 4196:  child->noerror = flags & COMMANDS_NOERROR;
        -: 4197:
    #####: 4198:  while (*p != '\0')
branch  0 never executed
branch  1 never executed
        -: 4199:    {
    #####: 4200:      if (*p == '@')
branch  0 never executed
branch  1 never executed
    #####: 4201:	flags |= COMMANDS_SILENT;
    #####: 4202:      else if (*p == '+')
branch  0 never executed
branch  1 never executed
    #####: 4203:	flags |= COMMANDS_RECURSE;
    #####: 4204:      else if (*p == '-')
branch  0 never executed
branch  1 never executed
    #####: 4205:	child->noerror = 1;
    #####: 4206:      else if (!isblank (*p))
branch  0 never executed
branch  1 never executed
    #####: 4207:	break;
    #####: 4208:      ++p;
        -: 4209:    }
        -: 4210:
        -: 4211:  /* If -q was given, just say that updating `failed'.  The exit status of
        -: 4212:     1 tells the user that -q is saying `something to do'; the exit status
        -: 4213:     for a random error is 2.  */
    #####: 4214:  if (question_flag && !(flags & COMMANDS_RECURSE))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 4215:    {
    #####: 4216:      child->file->update_status = 1;
    #####: 4217:      notice_finished_file (child->file);
call    0 never executed
    #####: 4218:      return;
        -: 4219:    }
        -: 4220:
        -: 4221:  /* There may be some preceding whitespace left if there
        -: 4222:     was nothing but a backslash on the first line.  */
    #####: 4223:  p = next_token (p);
call    0 never executed
        -: 4224:
        -: 4225:  /* Figure out an argument list from this command line.  */
        -: 4226:
        -: 4227:  {
    #####: 4228:    char *end = 0;
        -: 4229:#ifdef VMS
        -: 4230:    argv = p;
        -: 4231:#else
    #####: 4232:    argv = construct_command_argv (p, &end, child->file, &child->sh_batch_file);
call    0 never executed
        -: 4233:#endif
    #####: 4234:    if (end == NULL)
branch  0 never executed
branch  1 never executed
    #####: 4235:      child->command_ptr = NULL;
        -: 4236:    else
        -: 4237:      {
    #####: 4238:	*end++ = '\0';
    #####: 4239:	child->command_ptr = end;
        -: 4240:      }
        -: 4241:  }
        -: 4242:
    #####: 4243:  if (touch_flag && !(flags & COMMANDS_RECURSE))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 4244:    {
        -: 4245:      /* Go on to the next command.  It might be the recursive one.
        -: 4246:	 We construct ARGV only to find the end of the command line.  */
        -: 4247:#ifndef VMS
    #####: 4248:      free (argv[0]);
    #####: 4249:      free ((char *) argv);
        -: 4250:#endif
    #####: 4251:      argv = 0;
        -: 4252:    }
        -: 4253:
    #####: 4254:  if (argv == 0)
branch  0 never executed
branch  1 never executed
        -: 4255:    {
    #####: 4256:    next_command:
        -: 4257:#ifdef __MSDOS__
        -: 4258:      execute_by_shell = 0;   /* in case construct_command_argv sets it */
        -: 4259:#endif
        -: 4260:      /* This line has no commands.  Go to the next.  */
    #####: 4261:      if (job_next_command (child))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 4262:	start_job_command (child);
call    0 never executed
        -: 4263:      else
        -: 4264:	{
        -: 4265:	  /* No more commands.  Make sure we're "running"; we might not be if
        -: 4266:             (e.g.) all commands were skipped due to -n.  */
        -: 4267:#ifndef F_JR_10  /* seeded fault #10; J.Ruthruff */
    #####: 4268:          set_command_state (child->file, cs_running);
call    0 never executed
        -: 4269:#endif
    #####: 4270:	  child->file->update_status = 0;
    #####: 4271:	  notice_finished_file (child->file);
call    0 never executed
        -: 4272:	}
    #####: 4273:      return;
        -: 4274:    }
        -: 4275:
        -: 4276:  /* Print out the command.  If silent, we call `message' with null so it
        -: 4277:     can log the working directory before the command's own error messages
        -: 4278:     appear.  */
        -: 4279:
    #####: 4280:  message (0, (just_print_flag || (!(flags & COMMANDS_SILENT) && !silent_flag))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
        -: 4281:	   ? "%s" : (char *) 0, p);
        -: 4282:
        -: 4283:  /* Optimize an empty command.  People use this for timestamp rules,
        -: 4284:     so avoid forking a useless shell.  */
        -: 4285:
        -: 4286:#if !defined(VMS) && !defined(_AMIGA)
    #####: 4287:  if (
        -: 4288:#ifdef __MSDOS__
        -: 4289:      unixy_shell	/* the test is complicated and we already did it */
        -: 4290:#else
    #####: 4291:      (argv[0] && !strcmp (argv[0], "/bin/sh"))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 4292:#endif
    #####: 4293:      && (argv[1]
branch  0 never executed
branch  1 never executed
    #####: 4294:          && argv[1][0] == '-' && argv[1][1] == 'c' && argv[1][2] == '\0')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 4295:      && (argv[2] && argv[2][0] == ':' && argv[2][1] == '\0')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 4296:      && argv[3] == NULL)
branch  0 never executed
branch  1 never executed
        -: 4297:    {
    #####: 4298:      free (argv[0]);
    #####: 4299:      free ((char *) argv);
    #####: 4300:      goto next_command;
        -: 4301:    }
        -: 4302:#endif  /* !VMS && !_AMIGA */
        -: 4303:
        -: 4304:  /* Tell update_goal_chain that a command has been started on behalf of
        -: 4305:     this target.  It is important that this happens here and not in
        -: 4306:     reap_children (where we used to do it), because reap_children might be
        -: 4307:     reaping children from a different target.  We want this increment to
        -: 4308:     guaranteedly indicate that a command was started for the dependency
        -: 4309:     chain (i.e., update_file recursion chain) we are processing.  */
        -: 4310:
    #####: 4311:  ++commands_started;
        -: 4312:
        -: 4313:  /* If -n was given, recurse to get the next line in the sequence.  */
        -: 4314:
    #####: 4315:  if (just_print_flag && !(flags & COMMANDS_RECURSE))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 4316:    {
        -: 4317:#ifndef VMS
    #####: 4318:      free (argv[0]);
    #####: 4319:      free ((char *) argv);
        -: 4320:#endif
    #####: 4321:      goto next_command;
        -: 4322:    }
        -: 4323:
        -: 4324:  /* Flush the output streams so they won't have things written twice.  */
        -: 4325:
    #####: 4326:  fflush (stdout);
call    0 never executed
    #####: 4327:  fflush (stderr);
call    0 never executed
        -: 4328:
        -: 4329:#ifndef VMS
        -: 4330:#if !defined(WINDOWS32) && !defined(_AMIGA) && !defined(__MSDOS__)
        -: 4331:
        -: 4332:  /* Set up a bad standard input that reads from a broken pipe.  */
        -: 4333:
    #####: 4334:  if (bad_stdin == -1)
branch  0 never executed
branch  1 never executed
        -: 4335:    {
        -: 4336:      /* Make a file descriptor that is the read end of a broken pipe.
        -: 4337:	 This will be used for some children's standard inputs.  */
        -: 4338:      int pd[2];
    #####: 4339:      if (pipe (pd) == 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 4340:	{
        -: 4341:	  /* Close the write side.  */
    #####: 4342:	  (void) close (pd[1]);
call    0 never executed
        -: 4343:	  /* Save the read side.  */
    #####: 4344:	  bad_stdin = pd[0];
        -: 4345:
        -: 4346:	  /* Set the descriptor to close on exec, so it does not litter any
        -: 4347:	     child's descriptor table.  When it is dup2'd onto descriptor 0,
        -: 4348:	     that descriptor will not close on exec.  */
    #####: 4349:	  CLOSE_ON_EXEC (bad_stdin);
call    0 never executed
        -: 4350:	}
        -: 4351:    }
        -: 4352:
        -: 4353:#endif /* !WINDOWS32 && !_AMIGA && !__MSDOS__ */
        -: 4354:
        -: 4355:  /* Decide whether to give this child the `good' standard input
        -: 4356:     (one that points to the terminal or whatever), or the `bad' one
        -: 4357:     that points to the read side of a broken pipe.  */
        -: 4358:
    #####: 4359:  child->good_stdin = !good_stdin_used;
    #####: 4360:  if (child->good_stdin)
branch  0 never executed
branch  1 never executed
    #####: 4361:    good_stdin_used = 1;
        -: 4362:
        -: 4363:#endif /* !VMS */
        -: 4364:
    #####: 4365:  child->deleted = 0;
        -: 4366:
        -: 4367:#ifndef _AMIGA
        -: 4368:  /* Set up the environment for the child.  */
    #####: 4369:  if (child->environment == 0)
branch  0 never executed
branch  1 never executed
    #####: 4370:    child->environment = target_environment (child->file);
call    0 never executed
        -: 4371:#endif
        -: 4372:
        -: 4373:#if !defined(__MSDOS__) && !defined(_AMIGA) && !defined(WINDOWS32)
        -: 4374:
        -: 4375:#ifndef VMS
        -: 4376:  /* start_waiting_job has set CHILD->remote if we can start a remote job.  */
    #####: 4377:  if (child->remote)
branch  0 never executed
branch  1 never executed
        -: 4378:    {
        -: 4379:      int is_remote, id, used_stdin;
    #####: 4380:      if (start_remote_job (argv, child->environment,
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 4381:			    child->good_stdin ? 0 : bad_stdin,
branch  0 never executed
branch  1 never executed
        -: 4382:			    &is_remote, &id, &used_stdin))
        -: 4383:        /* Don't give up; remote execution may fail for various reasons.  If
        -: 4384:           so, simply run the job locally.  */
    #####: 4385:	goto run_local;
        -: 4386:      else
        -: 4387:	{
    #####: 4388:	  if (child->good_stdin && !used_stdin)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 4389:	    {
    #####: 4390:	      child->good_stdin = 0;
    #####: 4391:	      good_stdin_used = 0;
        -: 4392:	    }
    #####: 4393:	  child->remote = is_remote;
    #####: 4394:	  child->pid = id;
        -: 4395:	}
        -: 4396:    }
        -: 4397:  else
        -: 4398:#endif /* !VMS */
        -: 4399:    {
        -: 4400:      /* Fork the child process.  */
        -: 4401:
        -: 4402:      char **parent_environ;
        -: 4403:
    #####: 4404:    run_local:
    #####: 4405:      block_sigs ();
call    0 never executed
        -: 4406:
    #####: 4407:      child->remote = 0;
        -: 4408:
        -: 4409:#ifdef VMS
        -: 4410:
        -: 4411:      if (!child_execute_job (argv, child)) {
        -: 4412:        /* Fork failed!  */
        -: 4413:        perror_with_name ("vfork", "");
        -: 4414:        goto error;
        -: 4415:      }
        -: 4416:
        -: 4417:#else
        -: 4418:
    #####: 4419:      parent_environ = environ;
    #####: 4420:      child->pid = vfork ();
call    0 never executed
    #####: 4421:      environ = parent_environ;	/* Restore value child may have clobbered.  */
    #####: 4422:      if (child->pid == 0)
branch  0 never executed
branch  1 never executed
        -: 4423:	{
        -: 4424:	  /* We are the child side.  */
    #####: 4425:	  unblock_sigs ();
call    0 never executed
        -: 4426:
        -: 4427:          /* If we aren't running a recursive command and we have a jobserver
        -: 4428:             pipe, close it before exec'ing.  */
    #####: 4429:          if (!(flags & COMMANDS_RECURSE) && job_fds[0] >= 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 4430:            {
    #####: 4431:              close (job_fds[0]);
call    0 never executed
    #####: 4432:              close (job_fds[1]);
call    0 never executed
        -: 4433:            }
    #####: 4434:          if (job_rfd >= 0)
branch  0 never executed
branch  1 never executed
    #####: 4435:            close (job_rfd);
call    0 never executed
        -: 4436:
    #####: 4437:	  child_execute_job (child->good_stdin ? 0 : bad_stdin, 1,
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 4438:                             argv, child->environment);
        -: 4439:	}
    #####: 4440:      else if (child->pid < 0)
branch  0 never executed
branch  1 never executed
        -: 4441:	{
        -: 4442:	  /* Fork failed!  */
    #####: 4443:	  unblock_sigs ();
call    0 never executed
    #####: 4444:	  perror_with_name ("vfork", "");
call    0 never executed
    #####: 4445:	  goto error;
        -: 4446:	}
        -: 4447:#endif /* !VMS */
        -: 4448:    }
        -: 4449:
        -: 4450:#else	/* __MSDOS__ or Amiga or WINDOWS32 */
        -: 4451:#ifdef __MSDOS__
        -: 4452:  {
        -: 4453:    int proc_return;
        -: 4454:
        -: 4455:    block_sigs ();
        -: 4456:    dos_status = 0;
        -: 4457:
        -: 4458:    /* We call `system' to do the job of the SHELL, since stock DOS
        -: 4459:       shell is too dumb.  Our `system' knows how to handle long
        -: 4460:       command lines even if pipes/redirection is needed; it will only
        -: 4461:       call COMMAND.COM when its internal commands are used.  */
        -: 4462:    if (execute_by_shell)
        -: 4463:      {
        -: 4464:	char *cmdline = argv[0];
        -: 4465:	/* We don't have a way to pass environment to `system',
        -: 4466:	   so we need to save and restore ours, sigh...  */
        -: 4467:	char **parent_environ = environ;
        -: 4468:
        -: 4469:	environ = child->environment;
        -: 4470:
        -: 4471:	/* If we have a *real* shell, tell `system' to call
        -: 4472:	   it to do everything for us.  */
        -: 4473:	if (unixy_shell)
        -: 4474:	  {
        -: 4475:	    /* A *real* shell on MSDOS may not support long
        -: 4476:	       command lines the DJGPP way, so we must use `system'.  */
        -: 4477:	    cmdline = argv[2];	/* get past "shell -c" */
        -: 4478:	  }
        -: 4479:
        -: 4480:	dos_command_running = 1;
        -: 4481:	proc_return = system (cmdline);
        -: 4482:	environ = parent_environ;
        -: 4483:	execute_by_shell = 0;	/* for the next time */
        -: 4484:      }
        -: 4485:    else
        -: 4486:      {
        -: 4487:	dos_command_running = 1;
        -: 4488:	proc_return = spawnvpe (P_WAIT, argv[0], argv, child->environment);
        -: 4489:      }
        -: 4490:
        -: 4491:    /* Need to unblock signals before turning off
        -: 4492:       dos_command_running, so that child's signals
        -: 4493:       will be treated as such (see fatal_error_signal).  */
        -: 4494:    unblock_sigs ();
        -: 4495:    dos_command_running = 0;
        -: 4496:
        -: 4497:    /* If the child got a signal, dos_status has its
        -: 4498:       high 8 bits set, so be careful not to alter them.  */
        -: 4499:    if (proc_return == -1)
        -: 4500:      dos_status |= 0xff;
        -: 4501:    else
        -: 4502:      dos_status |= (proc_return & 0xff);
        -: 4503:    ++dead_children;
        -: 4504:    child->pid = dos_pid++;
        -: 4505:  }
        -: 4506:#endif /* __MSDOS__ */
        -: 4507:#ifdef _AMIGA
        -: 4508:  amiga_status = MyExecute (argv);
        -: 4509:
        -: 4510:  ++dead_children;
        -: 4511:  child->pid = amiga_pid++;
        -: 4512:  if (amiga_batch_file)
        -: 4513:  {
        -: 4514:     amiga_batch_file = 0;
        -: 4515:     DeleteFile (amiga_bname);        /* Ignore errors.  */
        -: 4516:  }
        -: 4517:#endif	/* Amiga */
        -: 4518:#ifdef WINDOWS32
        -: 4519:  {
        -: 4520:      HANDLE hPID;
        -: 4521:      char* arg0;
        -: 4522:
        -: 4523:      /* make UNC paths safe for CreateProcess -- backslash format */
        -: 4524:      arg0 = argv[0];
        -: 4525:      if (arg0 && arg0[0] == '/' && arg0[1] == '/')
        -: 4526:        for ( ; arg0 && *arg0; arg0++)
        -: 4527:          if (*arg0 == '/')
        -: 4528:            *arg0 = '\\';
        -: 4529:
        -: 4530:      /* make sure CreateProcess() has Path it needs */
        -: 4531:      sync_Path_environment();
        -: 4532:
        -: 4533:      hPID = process_easy(argv, child->environment);
        -: 4534:
        -: 4535:      if (hPID != INVALID_HANDLE_VALUE)
        -: 4536:        child->pid = (int) hPID;
        -: 4537:      else {
        -: 4538:        int i;
        -: 4539:        unblock_sigs();
        -: 4540:        fprintf(stderr,
        -: 4541:          _("process_easy() failed failed to launch process (e=%d)\n"),
        -: 4542:          process_last_err(hPID));
        -: 4543:               for (i = 0; argv[i]; i++)
        -: 4544:                 fprintf(stderr, "%s ", argv[i]);
        -: 4545:               fprintf(stderr, _("\nCounted %d args in failed launch\n"), i);
        -: 4546:      }
        -: 4547:  }
        -: 4548:#endif /* WINDOWS32 */
        -: 4549:#endif	/* __MSDOS__ or Amiga or WINDOWS32 */
        -: 4550:
        -: 4551:  /* We are the parent side.  Set the state to
        -: 4552:     say the commands are running and return.  */
        -: 4553:
    #####: 4554:  set_command_state (child->file, cs_running);
call    0 never executed
        -: 4555:
        -: 4556:  /* Free the storage used by the child's argument list.  */
        -: 4557:#ifndef VMS
    #####: 4558:  free (argv[0]);
    #####: 4559:  free ((char *) argv);
        -: 4560:#endif
        -: 4561:
    #####: 4562:  return;
        -: 4563:
    #####: 4564: error:
    #####: 4565:  child->file->update_status = 2;
    #####: 4566:  notice_finished_file (child->file);
call    0 never executed
    #####: 4567:  return;
        -: 4568:}
        -: 4569:
        -: 4570:/* Try to start a child running.
        -: 4571:   Returns nonzero if the child was started (and maybe finished), or zero if
        -: 4572:   the load was too high and the child was put on the `waiting_jobs' chain.  */
        -: 4573:
        -: 4574:static int
function start_waiting_job called 0 returned 0% blocks executed 0%
    #####: 4575:start_waiting_job (c)
        -: 4576:     struct child *c;
        -: 4577:{
    #####: 4578:  struct file *f = c->file;
        -: 4579:
        -: 4580:  /* If we can start a job remotely, we always want to, and don't care about
        -: 4581:     the local load average.  We record that the job should be started
        -: 4582:     remotely in C->remote for start_job_command to test.  */
        -: 4583:
    #####: 4584:  c->remote = start_remote_job_p (1);
call    0 never executed
        -: 4585:
        -: 4586:  /* If we are running at least one job already and the load average
        -: 4587:     is too high, make this one wait.  */
    #####: 4588:  if (!c->remote && job_slots_used > 0 && load_too_high ())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
        -: 4589:    {
        -: 4590:      /* Put this child on the chain of children waiting for the load average
        -: 4591:         to go down.  */
    #####: 4592:      set_command_state (f, cs_running);
call    0 never executed
    #####: 4593:      c->next = waiting_jobs;
    #####: 4594:      waiting_jobs = c;
    #####: 4595:      return 0;
        -: 4596:    }
        -: 4597:
        -: 4598:  /* Start the first command; reap_children will run later command lines.  */
    #####: 4599:  start_job_command (c);
call    0 never executed
        -: 4600:
    #####: 4601:  switch (f->command_state)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 4602:    {
    #####: 4603:    case cs_running:
    #####: 4604:      c->next = children;
    #####: 4605:      if (debug_flag)
branch  0 never executed
branch  1 never executed
    #####: 4606:	printf (_("Putting child 0x%08lx (%s) PID %ld%s on the chain.\n"),
    #####: 4607:		(unsigned long int) c, c->file->name,
    #####: 4608:                (long) c->pid, c->remote ? _(" (remote)") : "");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 4609:      children = c;
        -: 4610:      /* One more job slot is in use.  */
    #####: 4611:      ++job_slots_used;
    #####: 4612:      unblock_sigs ();
call    0 never executed
    #####: 4613:      break;
        -: 4614:
    #####: 4615:    case cs_not_started:
        -: 4616:      /* All the command lines turned out to be empty.  */
    #####: 4617:      f->update_status = 0;
        -: 4618:      /* FALLTHROUGH */
        -: 4619:
    #####: 4620:    case cs_finished:
    #####: 4621:      notice_finished_file (f);
call    0 never executed
    #####: 4622:      free_child (c);
call    0 never executed
    #####: 4623:      break;
        -: 4624:
    #####: 4625:    default:
    #####: 4626:      assert (f->command_state == cs_finished);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 4627:      break;
        -: 4628:    }
        -: 4629:
    #####: 4630:  return 1;
        -: 4631:}
        -: 4632:
        -: 4633:/* Create a `struct child' for FILE and start its commands running.  */
        -: 4634:
        -: 4635:void
function new_job called 0 returned 0% blocks executed 0%
    #####: 4636:new_job (file)
        -: 4637:     register struct file *file;
        -: 4638:{
    #####: 4639:  register struct commands *cmds = file->cmds;
        -: 4640:  register struct child *c;
        -: 4641:  char **lines;
        -: 4642:  register unsigned int i;
        -: 4643:
        -: 4644:  /* Let any previously decided-upon jobs that are waiting
        -: 4645:     for the load to go down start before this new one.  */
    #####: 4646:  start_waiting_jobs ();
call    0 never executed
        -: 4647:
        -: 4648:  /* Reap any children that might have finished recently.  */
    #####: 4649:  reap_children (0, 0);
call    0 never executed
        -: 4650:
        -: 4651:  /* Chop the commands up into lines if they aren't already.  */
    #####: 4652:  chop_commands (cmds);
call    0 never executed
        -: 4653:
        -: 4654:  /* Expand the command lines and store the results in LINES.  */
    #####: 4655:  lines = (char **) xmalloc (cmds->ncommand_lines * sizeof (char *));
call    0 never executed
    #####: 4656:  for (i = 0; i < cmds->ncommand_lines; ++i)
branch  0 never executed
branch  1 never executed
        -: 4657:    {
        -: 4658:      /* Collapse backslash-newline combinations that are inside variable
        -: 4659:	 or function references.  These are left alone by the parser so
        -: 4660:	 that they will appear in the echoing of commands (where they look
        -: 4661:	 nice); and collapsed by construct_command_argv when it tokenizes.
        -: 4662:	 But letting them survive inside function invocations loses because
        -: 4663:	 we don't want the functions to see them as part of the text.  */
        -: 4664:
        -: 4665:      char *in, *out, *ref;
        -: 4666:
        -: 4667:      /* IN points to where in the line we are scanning.
        -: 4668:	 OUT points to where in the line we are writing.
        -: 4669:	 When we collapse a backslash-newline combination,
        -: 4670:	 IN gets ahead of OUT.  */
        -: 4671:
    #####: 4672:      in = out = cmds->command_lines[i];
    #####: 4673:      while ((ref = index (in, '$')) != 0)
branch  0 never executed
branch  1 never executed
        -: 4674:	{
    #####: 4675:	  ++ref;		/* Move past the $.  */
        -: 4676:
    #####: 4677:	  if (out != in)
branch  0 never executed
branch  1 never executed
        -: 4678:	    /* Copy the text between the end of the last chunk
        -: 4679:	       we processed (where IN points) and the new chunk
        -: 4680:	       we are about to process (where REF points).  */
    #####: 4681:	    bcopy (in, out, ref - in);
        -: 4682:
        -: 4683:	  /* Move both pointers past the boring stuff.  */
    #####: 4684:	  out += ref - in;
    #####: 4685:	  in = ref;
        -: 4686:
    #####: 4687:	  if (*ref == '(' || *ref == '{')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 4688:	    {
    #####: 4689:	      char openparen = *ref;
    #####: 4690:	      char closeparen = openparen == '(' ? ')' : '}';
branch  0 never executed
branch  1 never executed
        -: 4691:	      int count;
        -: 4692:	      char *p;
        -: 4693:
    #####: 4694:	      *out++ = *in++;	/* Copy OPENPAREN.  */
        -: 4695:	      /* IN now points past the opening paren or brace.
        -: 4696:		 Count parens or braces until it is matched.  */
    #####: 4697:	      count = 0;
    #####: 4698:	      while (*in != '\0')
branch  0 never executed
branch  1 never executed
        -: 4699:		{
    #####: 4700:		  if (*in == closeparen && --count < 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 4701:		    break;
    #####: 4702:		  else if (*in == '\\' && in[1] == '\n')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4703:		    {
        -: 4704:		      /* We have found a backslash-newline inside a
        -: 4705:			 variable or function reference.  Eat it and
        -: 4706:			 any following whitespace.  */
        -: 4707:
    #####: 4708:		      int quoted = 0;
    #####: 4709:		      for (p = in - 1; p > ref && *p == '\\'; --p)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4710:			quoted = !quoted;
        -: 4711:
    #####: 4712:		      if (quoted)
branch  0 never executed
branch  1 never executed
        -: 4713:			/* There were two or more backslashes, so this is
        -: 4714:			   not really a continuation line.  We don't collapse
        -: 4715:			   the quoting backslashes here as is done in
        -: 4716:			   collapse_continuations, because the line will
        -: 4717:			   be collapsed again after expansion.  */
    #####: 4718:			*out++ = *in++;
        -: 4719:		      else
        -: 4720:			{
        -: 4721:			  /* Skip the backslash, newline and
        -: 4722:			     any following whitespace.  */
    #####: 4723:			  in = next_token (in + 2);
call    0 never executed
        -: 4724:
        -: 4725:			  /* Discard any preceding whitespace that has
        -: 4726:			     already been written to the output.  */
    #####: 4727:			  while (out > ref && isblank (out[-1]))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4728:			    --out;
        -: 4729:
        -: 4730:			  /* Replace it all with a single space.  */
    #####: 4731:			  *out++ = ' ';
        -: 4732:			}
        -: 4733:		    }
        -: 4734:		  else
        -: 4735:		    {
    #####: 4736:		      if (*in == openparen)
branch  0 never executed
branch  1 never executed
    #####: 4737:			++count;
        -: 4738:
    #####: 4739:		      *out++ = *in++;
        -: 4740:		    }
        -: 4741:		}
        -: 4742:	    }
        -: 4743:	}
        -: 4744:
        -: 4745:      /* There are no more references in this line to worry about.
        -: 4746:	 Copy the remaining uninteresting text to the output.  */
    #####: 4747:      if (out != in)
branch  0 never executed
branch  1 never executed
    #####: 4748:	strcpy (out, in);
        -: 4749:
        -: 4750:      /* Finally, expand the line.  */
    #####: 4751:      lines[i] = allocated_variable_expand_for_file (cmds->command_lines[i],
call    0 never executed
        -: 4752:						     file);
        -: 4753:    }
        -: 4754:
        -: 4755:  /* Start the command sequence, record it in a new
        -: 4756:     `struct child', and add that to the chain.  */
        -: 4757:
    #####: 4758:  c = (struct child *) xmalloc (sizeof (struct child));
call    0 never executed
    #####: 4759:  c->file = file;
    #####: 4760:  c->command_lines = lines;
    #####: 4761:  c->command_line = 0;
    #####: 4762:  c->command_ptr = 0;
    #####: 4763:  c->environment = 0;
    #####: 4764:  c->sh_batch_file = NULL;
        -: 4765:
        -: 4766:  /* Fetch the first command line to be run.  */
    #####: 4767:  job_next_command (c);
call    0 never executed
        -: 4768:
        -: 4769:  /* Wait for a job slot to be freed up.  If we allow an infinite number
        -: 4770:     don't bother; also job_slots will == 0 if we're using the jobserver.  */
        -: 4771:
    #####: 4772:  if (job_slots != 0)
branch  0 never executed
branch  1 never executed
    #####: 4773:    while (job_slots_used == job_slots)
branch  0 never executed
branch  1 never executed
    #####: 4774:      reap_children (1, 0);
call    0 never executed
        -: 4775:
        -: 4776:#ifdef MAKE_JOBSERVER
        -: 4777:  /* If we are controlling multiple jobs make sure we have a token before
        -: 4778:     starting the child. */
        -: 4779:
        -: 4780:  /* This can be inefficient.  There's a decent chance that this job won't
        -: 4781:     actually have to run any subprocesses: the command script may be empty
        -: 4782:     or otherwise optimized away.  It would be nice if we could defer
        -: 4783:     obtaining a token until just before we need it, in start_job_command.
        -: 4784:     To do that we'd need to keep track of whether we'd already obtained a
        -: 4785:     token (since start_job_command is called for each line of the job, not
        -: 4786:     just once).  Also more thought needs to go into the entire algorithm;
        -: 4787:     this is where the old parallel job code waits, so...  */
        -: 4788:
    #####: 4789:  else if (job_fds[0] >= 0)
branch  0 never executed
branch  1 never executed
        -: 4790:    while (1)
    #####: 4791:      {
        -: 4792:        char token;
        -: 4793:
        -: 4794:        /* If we don't already have a job started, use our "free" token.  */
    #####: 4795:        if (!children)
branch  0 never executed
branch  1 never executed
    #####: 4796:          break;
        -: 4797:
        -: 4798:        /* Read a token.  As long as there's no token available we'll block.
        -: 4799:           If we get a SIGCHLD we'll return with EINTR.  If one happened
        -: 4800:           before we got here we'll return immediately with EBADF because
        -: 4801:           the signal handler closes the dup'd file descriptor.  */
        -: 4802:
    #####: 4803:        if (read (job_rfd, &token, 1) == 1)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 4804:          {
    #####: 4805:            if (debug_flag)
branch  0 never executed
branch  1 never executed
    #####: 4806:              printf (_("Obtained token for child 0x%08lx (%s).\n"),
    #####: 4807:                      (unsigned long int) c, c->file->name);
call    0 never executed
    #####: 4808:            break;
        -: 4809:          }
        -: 4810:
    #####: 4811:        if (errno != EINTR && errno != EBADF)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4812:          pfatal_with_name (_("read jobs pipe"));
call    0 never executed
        -: 4813:
        -: 4814:        /* Re-dup the read side of the pipe, so the signal handler can
        -: 4815:           notify us if we miss a child.  */
    #####: 4816:        if (job_rfd < 0)
branch  0 never executed
branch  1 never executed
    #####: 4817:          job_rfd = dup (job_fds[0]);
call    0 never executed
        -: 4818:
        -: 4819:        /* Something's done.  We don't want to block for a whole child,
        -: 4820:           just reap whatever's there.  */
    #####: 4821:        reap_children (0, 0);
call    0 never executed
        -: 4822:      }
        -: 4823:#endif
        -: 4824:
        -: 4825:  /* The job is now primed.  Start it running.
        -: 4826:     (This will notice if there are in fact no commands.)  */
    #####: 4827:  (void) start_waiting_job (c);
call    0 never executed
        -: 4828:
    #####: 4829:  if (job_slots == 1)
branch  0 never executed
branch  1 never executed
        -: 4830:    /* Since there is only one job slot, make things run linearly.
        -: 4831:       Wait for the child to die, setting the state to `cs_finished'.  */
    #####: 4832:    while (file->command_state == cs_running)
branch  0 never executed
branch  1 never executed
    #####: 4833:      reap_children (1, 0);
call    0 never executed
        -: 4834:
    #####: 4835:  return;
        -: 4836:}
        -: 4837:
        -: 4838:/* Move CHILD's pointers to the next command for it to execute.
        -: 4839:   Returns nonzero if there is another command.  */
        -: 4840:
        -: 4841:static int
function job_next_command called 0 returned 0% blocks executed 0%
    #####: 4842:job_next_command (child)
        -: 4843:     struct child *child;
        -: 4844:{
    #####: 4845:  while (child->command_ptr == 0 || *child->command_ptr == '\0')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 4846:    {
        -: 4847:      /* There are no more lines in the expansion of this line.  */
    #####: 4848:      if (child->command_line == child->file->cmds->ncommand_lines)
branch  0 never executed
branch  1 never executed
        -: 4849:	{
        -: 4850:	  /* There are no more lines to be expanded.  */
    #####: 4851:	  child->command_ptr = 0;
    #####: 4852:	  return 0;
        -: 4853:	}
        -: 4854:      else
        -: 4855:	/* Get the next line to run.  */
    #####: 4856:	child->command_ptr = child->command_lines[child->command_line++];
        -: 4857:    }
    #####: 4858:  return 1;
        -: 4859:}
        -: 4860:
        -: 4861:static int
function load_too_high called 0 returned 0% blocks executed 0%
    #####: 4862:load_too_high ()
        -: 4863:{
        -: 4864:#if defined(__MSDOS__) || defined(VMS) || defined(_AMIGA)
        -: 4865:  return 1;
        -: 4866:#else
        -: 4867:  double load;
        -: 4868:
    #####: 4869:  if (max_load_average < 0)
branch  0 never executed
branch  1 never executed
    #####: 4870:    return 0;
        -: 4871:
    #####: 4872:  make_access ();
call    0 never executed
    #####: 4873:  if (getloadavg (&load, 1) != 1)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 4874:    {
        -: 4875:      static int lossage = -1;
        -: 4876:      /* Complain only once for the same error.  */
    #####: 4877:      if (lossage == -1 || errno != lossage)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 4878:	{
    #####: 4879:	  if (errno == 0)
branch  0 never executed
branch  1 never executed
        -: 4880:	    /* An errno value of zero means getloadavg is just unsupported.  */
    #####: 4881:	    error (NILF, _("cannot enforce load limits on this operating system"));
call    0 never executed
        -: 4882:	  else
    #####: 4883:	    perror_with_name (_("cannot enforce load limit: "), "getloadavg");
call    0 never executed
        -: 4884:	}
    #####: 4885:      lossage = errno;
    #####: 4886:      load = 0;
        -: 4887:    }
    #####: 4888:  user_access ();
call    0 never executed
        -: 4889:
    #####: 4890:  return load >= max_load_average;
        -: 4891:#endif
        -: 4892:}
        -: 4893:
        -: 4894:/* Start jobs that are waiting for the load to be lower.  */
        -: 4895:
        -: 4896:void
function start_waiting_jobs called 771 returned 100% blocks executed 38%
      771: 4897:start_waiting_jobs ()
        -: 4898:{
        -: 4899:  struct child *job;
        -: 4900:
      771: 4901:  if (waiting_jobs == 0)
branch  0 taken 771 (fallthrough)
branch  1 taken 0
      771: 4902:    return;
        -: 4903:
        -: 4904:  do
        -: 4905:    {
        -: 4906:      /* Check for recently deceased descendants.  */
    #####: 4907:      reap_children (0, 0);
call    0 never executed
        -: 4908:
        -: 4909:      /* Take a job off the waiting list.  */
    #####: 4910:      job = waiting_jobs;
    #####: 4911:      waiting_jobs = job->next;
        -: 4912:
        -: 4913:      /* Try to start that job.  We break out of the loop as soon
        -: 4914:	 as start_waiting_job puts one back on the waiting list.  */
        -: 4915:    }
    #####: 4916:  while (start_waiting_job (job) && waiting_jobs != 0);
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -: 4917:
    #####: 4918:  return;
        -: 4919:}
        -: 4920:
        -: 4921:#ifndef WINDOWS32
        -: 4922:#ifdef VMS
        -: 4923:#include <descrip.h>
        -: 4924:#include <clidef.h>
        -: 4925:#undef stderr
        -: 4926:#define stderr stdout
        -: 4927:
        -: 4928:/* This is called as an AST when a child process dies (it won't get
        -: 4929:   interrupted by anything except a higher level AST).
        -: 4930:*/
        -: 4931:int vmsHandleChildTerm(struct child *child)
        -: 4932:{
        -: 4933:    int status;
        -: 4934:    register struct child *lastc, *c;
        -: 4935:    int child_failed;
        -: 4936:
        -: 4937:    vms_jobsefnmask &= ~(1 << (child->efn - 32));
        -: 4938:
        -: 4939:    lib$free_ef(&child->efn);
        -: 4940:
        -: 4941:    (void) sigblock (fatal_signal_mask);
        -: 4942:
        -: 4943:    child_failed = !(child->cstatus & 1 || ((child->cstatus & 7) == 0));
        -: 4944:
        -: 4945:    /* Search for a child matching the deceased one.  */
        -: 4946:    lastc = 0;
        -: 4947:#if defined(RECURSIVEJOBS) /* I've had problems with recursive stuff and process handling */
        -: 4948:    for (c = children; c != 0 && c != child; lastc = c, c = c->next);
        -: 4949:#else
        -: 4950:    c = child;
        -: 4951:#endif
        -: 4952:
        -: 4953:    if (child_failed && !c->noerror && !ignore_errors_flag)
        -: 4954:      {
        -: 4955:	/* The commands failed.  Write an error message,
        -: 4956:	   delete non-precious targets, and abort.  */
        -: 4957:	child_error (c->file->name, c->cstatus, 0, 0, 0);
        -: 4958:	c->file->update_status = 1;
        -: 4959:	delete_child_targets (c);
        -: 4960:      }
        -: 4961:    else
        -: 4962:      {
        -: 4963:	if (child_failed)
        -: 4964:	  {
        -: 4965:	    /* The commands failed, but we don't care.  */
        -: 4966:	    child_error (c->file->name, c->cstatus, 0, 0, 1);
        -: 4967:	    child_failed = 0;
        -: 4968:	  }
        -: 4969:
        -: 4970:#if defined(RECURSIVEJOBS) /* I've had problems with recursive stuff and process handling */
        -: 4971:	/* If there are more commands to run, try to start them.  */
        -: 4972:	start_job (c);
        -: 4973:
        -: 4974:	switch (c->file->command_state)
        -: 4975:	  {
        -: 4976:	  case cs_running:
        -: 4977:	    /* Successfully started.  */
        -: 4978:	    break;
        -: 4979:
        -: 4980:	  case cs_finished:
        -: 4981:	    if (c->file->update_status != 0) {
        -: 4982:		/* We failed to start the commands.  */
        -: 4983:		delete_child_targets (c);
        -: 4984:	    }
        -: 4985:	    break;
        -: 4986:
        -: 4987:	  default:
        -: 4988:	    error (NILF, _("internal error: `%s' command_state"), c->file->name);
        -: 4989:	    abort ();
        -: 4990:	    break;
        -: 4991:	  }
        -: 4992:#endif /* RECURSIVEJOBS */
        -: 4993:      }
        -: 4994:
        -: 4995:    /* Set the state flag to say the commands have finished.  */
        -: 4996:    c->file->command_state = cs_finished;
        -: 4997:    notice_finished_file (c->file);
        -: 4998:
        -: 4999:#if defined(RECURSIVEJOBS) /* I've had problems with recursive stuff and process handling */
        -: 5000:    /* Remove the child from the chain and free it.  */
        -: 5001:    if (lastc == 0)
        -: 5002:      children = c->next;
        -: 5003:    else
        -: 5004:      lastc->next = c->next;
        -: 5005:    free_child (c);
        -: 5006:#endif /* RECURSIVEJOBS */
        -: 5007:
        -: 5008:    /* There is now another slot open.  */
        -: 5009:    if (job_slots_used > 0)
        -: 5010:      --job_slots_used;
        -: 5011:
        -: 5012:    /* If the job failed, and the -k flag was not given, die.  */
        -: 5013:    if (child_failed && !keep_going_flag)
        -: 5014:      die (EXIT_FAILURE);
        -: 5015:
        -: 5016:    (void) sigsetmask (sigblock (0) & ~(fatal_signal_mask));
        -: 5017:
        -: 5018:    return 1;
        -: 5019:}
        -: 5020:
        -: 5021:/* VMS:
        -: 5022:   Spawn a process executing the command in ARGV and return its pid. */
        -: 5023:
        -: 5024:#define MAXCMDLEN 200
        -: 5025:
        -: 5026:int
        -: 5027:child_execute_job (argv, child)
        -: 5028:     char *argv;
        -: 5029:     struct child *child;
        -: 5030:{
        -: 5031:  int i;
        -: 5032:  static struct dsc$descriptor_s cmddsc;
        -: 5033:#ifndef DONTWAITFORCHILD
        -: 5034:  int spflags = 0;
        -: 5035:#else
        -: 5036:  int spflags = CLI$M_NOWAIT;
        -: 5037:#endif
        -: 5038:  int status;
        -: 5039:  char cmd[4096],*p,*c;
        -: 5040:  char comname[50];
        -: 5041:
        -: 5042:/* Remove backslashes */
        -: 5043:  for (p = argv, c = cmd; *p; p++,c++)
        -: 5044:    {
        -: 5045:      if (*p == '\\') p++;
        -: 5046:	*c = *p;
        -: 5047:    }
        -: 5048:  *c = *p;
        -: 5049:
        -: 5050:  /* Check for maximum DCL length and create *.com file if neccesary.
        -: 5051:     Also create a .com file if the command is more than one line long.  */
        -: 5052:
        -: 5053:  comname[0] = '\0';
        -: 5054:
        -: 5055:  if (strlen (cmd) > MAXCMDLEN || strchr (cmd, '\n'))
        -: 5056:    {
        -: 5057:      FILE *outfile;
        -: 5058:      char tmp;
        -: 5059:
        -: 5060:      strcpy (comname, "sys$scratch:CMDXXXXXX.COM");
        -: 5061:      (void) mktemp (comname);
        -: 5062:
        -: 5063:      outfile = fopen (comname, "w");
        -: 5064:      if (outfile == 0)
        -: 5065:	pfatal_with_name (comname);
        -: 5066:
        -: 5067:      fprintf (outfile, "$ ");
        -: 5068:      c = cmd;
        -: 5069:
        -: 5070:      while (c)
        -: 5071:	{
        -: 5072:	  p = strchr (c, ',');
        -: 5073:	  if ((p == NULL) || (p-c > MAXCMDLEN))
        -: 5074:	    p = strchr (c, ' ');
        -: 5075:	  if (p != NULL)
        -: 5076:	    {
        -: 5077:	      p++;
        -: 5078:	      tmp = *p;
        -: 5079:	      *p = '\0';
        -: 5080:	    }
        -: 5081:	  else
        -: 5082:	    tmp = '\0';
        -: 5083:	  fprintf (outfile, "%s%s\n", c, (tmp == '\0')?"":" -");
        -: 5084:	  if (p != NULL)
        -: 5085:	    *p = tmp;
        -: 5086:	  c = p;
        -: 5087:	}
        -: 5088:
        -: 5089:      fclose (outfile);
        -: 5090:
        -: 5091:      sprintf (cmd, "$ @%s", comname);
        -: 5092:
        -: 5093:      if (debug_flag)
        -: 5094:	printf (_("Executing %s instead\n"), cmd);
        -: 5095:    }
        -: 5096:
        -: 5097:  cmddsc.dsc$w_length = strlen(cmd);
        -: 5098:  cmddsc.dsc$a_pointer = cmd;
        -: 5099:  cmddsc.dsc$b_dtype = DSC$K_DTYPE_T;
        -: 5100:  cmddsc.dsc$b_class = DSC$K_CLASS_S;
        -: 5101:
        -: 5102:  child->efn = 0;
        -: 5103:  while (child->efn < 32 || child->efn > 63)
        -: 5104:    {
        -: 5105:      status = lib$get_ef(&child->efn);
        -: 5106:      if (!(status & 1))
        -: 5107:	return 0;
        -: 5108:    }
        -: 5109:
        -: 5110:  sys$clref(child->efn);
        -: 5111:
        -: 5112:  vms_jobsefnmask |= (1 << (child->efn - 32));
        -: 5113:
        -: 5114:#ifndef DONTWAITFORCHILD
        -: 5115:  status = lib$spawn(&cmddsc,0,0,&spflags,0,&child->pid,&child->cstatus,
        -: 5116:		       &child->efn,0,0);
        -: 5117:  vmsHandleChildTerm(child);
        -: 5118:#else
        -: 5119:  status = lib$spawn(&cmddsc,0,0,&spflags,0,&child->pid,&child->cstatus,
        -: 5120:		       &child->efn,vmsHandleChildTerm,child);
        -: 5121:#endif
        -: 5122:
        -: 5123:  if (!(status & 1))
        -: 5124:    {
        -: 5125:      printf(_("Error spawning, %d\n"),status);
        -: 5126:      fflush(stdout);
        -: 5127:    }
        -: 5128:
        -: 5129:  unlink (comname);
        -: 5130:
        -: 5131:  return (status & 1);
        -: 5132:}
        -: 5133:
        -: 5134:#else /* !VMS */
        -: 5135:
        -: 5136:#if !defined (_AMIGA) && !defined (__MSDOS__)
        -: 5137:/* UNIX:
        -: 5138:   Replace the current process with one executing the command in ARGV.
        -: 5139:   STDIN_FD and STDOUT_FD are used as the process's stdin and stdout; ENVP is
        -: 5140:   the environment of the new program.  This function does not return.  */
        -: 5141:
        -: 5142:void
function child_execute_job called 0 returned 0% blocks executed 0%
    #####: 5143:child_execute_job (stdin_fd, stdout_fd, argv, envp)
        -: 5144:     int stdin_fd, stdout_fd;
        -: 5145:     char **argv, **envp;
        -: 5146:{
    #####: 5147:  if (stdin_fd != 0)
branch  0 never executed
branch  1 never executed
    #####: 5148:    (void) dup2 (stdin_fd, 0);
call    0 never executed
    #####: 5149:  if (stdout_fd != 1)
branch  0 never executed
branch  1 never executed
    #####: 5150:    (void) dup2 (stdout_fd, 1);
call    0 never executed
    #####: 5151:  if (stdin_fd != 0)
branch  0 never executed
branch  1 never executed
    #####: 5152:    (void) close (stdin_fd);
call    0 never executed
    #####: 5153:  if (stdout_fd != 1)
branch  0 never executed
branch  1 never executed
    #####: 5154:    (void) close (stdout_fd);
call    0 never executed
        -: 5155:
        -: 5156:  /* Run the command.  */
    #####: 5157:  exec_command (argv, envp);
call    0 never executed
    #####: 5158:}
        -: 5159:#endif /* !AMIGA && !__MSDOS__ */
        -: 5160:#endif /* !VMS */
        -: 5161:#endif /* !WINDOWS32 */
        -: 5162:
        -: 5163:#ifndef _AMIGA
        -: 5164:/* Replace the current process with one running the command in ARGV,
        -: 5165:   with environment ENVP.  This function does not return.  */
        -: 5166:
        -: 5167:void
function exec_command called 0 returned 0% blocks executed 0%
    #####: 5168:exec_command (argv, envp)
        -: 5169:     char **argv, **envp;
        -: 5170:{
        -: 5171:#ifdef VMS
        -: 5172:  /* Run the program.  */
        -: 5173:  execve (argv[0], argv, envp);
        -: 5174:  perror_with_name ("execve: ", argv[0]);
        -: 5175:  _exit (EXIT_FAILURE);
        -: 5176:#else
        -: 5177:#ifdef WINDOWS32
        -: 5178:  HANDLE hPID;
        -: 5179:  HANDLE hWaitPID;
        -: 5180:  int err = 0;
        -: 5181:  int exit_code = EXIT_FAILURE;
        -: 5182:
        -: 5183:  /* make sure CreateProcess() has Path it needs */
        -: 5184:  sync_Path_environment();
        -: 5185:
        -: 5186:  /* launch command */
        -: 5187:  hPID = process_easy(argv, envp);
        -: 5188:
        -: 5189:  /* make sure launch ok */
        -: 5190:  if (hPID == INVALID_HANDLE_VALUE)
        -: 5191:    {
        -: 5192:      int i;
        -: 5193:      fprintf(stderr,
        -: 5194:              _("process_easy() failed failed to launch process (e=%d)\n"),
        -: 5195:              process_last_err(hPID));
        -: 5196:      for (i = 0; argv[i]; i++)
        -: 5197:          fprintf(stderr, "%s ", argv[i]);
        -: 5198:      fprintf(stderr, _("\nCounted %d args in failed launch\n"), i);
        -: 5199:      exit(EXIT_FAILURE);
        -: 5200:    }
        -: 5201:
        -: 5202:  /* wait and reap last child */
        -: 5203:  while (hWaitPID = process_wait_for_any())
        -: 5204:    {
        -: 5205:      /* was an error found on this process? */
        -: 5206:      err = process_last_err(hWaitPID);
        -: 5207:
        -: 5208:      /* get exit data */
        -: 5209:      exit_code = process_exit_code(hWaitPID);
        -: 5210:
        -: 5211:      if (err)
        -: 5212:          fprintf(stderr, "make (e=%d, rc=%d): %s",
        -: 5213:                  err, exit_code, map_windows32_error_to_string(err));
        -: 5214:
        -: 5215:      /* cleanup process */
        -: 5216:      process_cleanup(hWaitPID);
        -: 5217:
        -: 5218:      /* expect to find only last pid, warn about other pids reaped */
        -: 5219:      if (hWaitPID == hPID)
        -: 5220:          break;
        -: 5221:      else
        -: 5222:          fprintf(stderr,
        -: 5223:                  _("make reaped child pid %d, still waiting for pid %d\n"),
        -: 5224:                  hWaitPID, hPID);
        -: 5225:    }
        -: 5226:
        -: 5227:  /* return child's exit code as our exit code */
        -: 5228:  exit(exit_code);
        -: 5229:
        -: 5230:#else  /* !WINDOWS32 */
        -: 5231:
        -: 5232:  /* Be the user, permanently.  */
    #####: 5233:  child_access ();
call    0 never executed
        -: 5234:
        -: 5235:  /* Run the program.  */
    #####: 5236:  environ = envp;
    #####: 5237:  execvp (argv[0], argv);
        -: 5238:
    #####: 5239:  switch (errno)
branch  0 never executed
branch  1 never executed
branch  2 never executed
        -: 5240:    {
    #####: 5241:    case ENOENT:
    #####: 5242:      error (NILF, _("%s: Command not found"), argv[0]);
call    0 never executed
    #####: 5243:      break;
    #####: 5244:    case ENOEXEC:
        -: 5245:      {
        -: 5246:	/* The file is not executable.  Try it as a shell script.  */
        -: 5247:	extern char *getenv ();
        -: 5248:	char *shell;
        -: 5249:	char **new_argv;
        -: 5250:	int argc;
        -: 5251:
    #####: 5252:	shell = getenv ("SHELL");
call    0 never executed
    #####: 5253:	if (shell == 0)
branch  0 never executed
branch  1 never executed
    #####: 5254:	  shell = default_shell;
        -: 5255:
    #####: 5256:	argc = 1;
    #####: 5257:	while (argv[argc] != 0)
branch  0 never executed
branch  1 never executed
    #####: 5258:	  ++argc;
        -: 5259:
    #####: 5260:	new_argv = (char **) alloca ((1 + argc + 1) * sizeof (char *));
    #####: 5261:	new_argv[0] = shell;
    #####: 5262:	new_argv[1] = argv[0];
    #####: 5263:	while (argc > 0)
branch  0 never executed
branch  1 never executed
        -: 5264:	  {
    #####: 5265:	    new_argv[1 + argc] = argv[argc];
    #####: 5266:	    --argc;
        -: 5267:	  }
        -: 5268:
    #####: 5269:	execvp (shell, new_argv);
    #####: 5270:	if (errno == ENOENT)
branch  0 never executed
branch  1 never executed
    #####: 5271:	  error (NILF, _("%s: Shell program not found"), shell);
call    0 never executed
        -: 5272:	else
    #####: 5273:	  perror_with_name ("execvp: ", shell);
call    0 never executed
    #####: 5274:	break;
        -: 5275:      }
        -: 5276:
    #####: 5277:    default:
    #####: 5278:      perror_with_name ("execvp: ", argv[0]);
call    0 never executed
    #####: 5279:      break;
        -: 5280:    }
        -: 5281:
    #####: 5282:  _exit (127);
        -: 5283:#endif /* !WINDOWS32 */
        -: 5284:#endif /* !VMS */
        -: 5285:}
        -: 5286:#else /* On Amiga */
        -: 5287:void exec_command (argv)
        -: 5288:     char **argv;
        -: 5289:{
        -: 5290:  MyExecute (argv);
        -: 5291:}
        -: 5292:
        -: 5293:void clean_tmp (void)
        -: 5294:{
        -: 5295:  DeleteFile (amiga_bname);
        -: 5296:}
        -: 5297:
        -: 5298:#endif /* On Amiga */
        -: 5299:
        -: 5300:#ifndef VMS
        -: 5301:/* Figure out the argument list necessary to run LINE as a command.  Try to
        -: 5302:   avoid using a shell.  This routine handles only ' quoting, and " quoting
        -: 5303:   when no backslash, $ or ` characters are seen in the quotes.  Starting
        -: 5304:   quotes may be escaped with a backslash.  If any of the characters in
        -: 5305:   sh_chars[] is seen, or any of the builtin commands listed in sh_cmds[]
        -: 5306:   is the first word of a line, the shell is used.
        -: 5307:
        -: 5308:   If RESTP is not NULL, *RESTP is set to point to the first newline in LINE.
        -: 5309:   If *RESTP is NULL, newlines will be ignored.
        -: 5310:
        -: 5311:   SHELL is the shell to use, or nil to use the default shell.
        -: 5312:   IFS is the value of $IFS, or nil (meaning the default).  */
        -: 5313:
        -: 5314:static char **
function construct_command_argv_internal called 0 returned 0% blocks executed 0%
    #####: 5315:construct_command_argv_internal (line, restp, shell, ifs, batch_filename_ptr)
        -: 5316:     char *line, **restp;
        -: 5317:     char *shell, *ifs;
        -: 5318:     char **batch_filename_ptr;
        -: 5319:{
        -: 5320:#ifdef __MSDOS__
        -: 5321:  /* MSDOS supports both the stock DOS shell and ports of Unixy shells.
        -: 5322:     We call `system' for anything that requires ``slow'' processing,
        -: 5323:     because DOS shells are too dumb.  When $SHELL points to a real
        -: 5324:     (unix-style) shell, `system' just calls it to do everything.  When
        -: 5325:     $SHELL points to a DOS shell, `system' does most of the work
        -: 5326:     internally, calling the shell only for its internal commands.
        -: 5327:     However, it looks on the $PATH first, so you can e.g. have an
        -: 5328:     external command named `mkdir'.
        -: 5329:
        -: 5330:     Since we call `system', certain characters and commands below are
        -: 5331:     actually not specific to COMMAND.COM, but to the DJGPP implementation
        -: 5332:     of `system'.  In particular:
        -: 5333:
        -: 5334:       The shell wildcard characters are in DOS_CHARS because they will
        -: 5335:       not be expanded if we call the child via `spawnXX'.
        -: 5336:
        -: 5337:       The `;' is in DOS_CHARS, because our `system' knows how to run
        -: 5338:       multiple commands on a single line.
        -: 5339:
        -: 5340:       DOS_CHARS also include characters special to 4DOS/NDOS, so we
        -: 5341:       won't have to tell one from another and have one more set of
        -: 5342:       commands and special characters.  */
        -: 5343:  static char sh_chars_dos[] = "*?[];|<>%^&()";
        -: 5344:  static char *sh_cmds_dos[] = { "break", "call", "cd", "chcp", "chdir", "cls",
        -: 5345:				 "copy", "ctty", "date", "del", "dir", "echo",
        -: 5346:				 "erase", "exit", "for", "goto", "if", "md",
        -: 5347:				 "mkdir", "path", "pause", "prompt", "rd",
        -: 5348:				 "rmdir", "rem", "ren", "rename", "set",
        -: 5349:				 "shift", "time", "type", "ver", "verify",
        -: 5350:				 "vol", ":", 0 };
        -: 5351:
        -: 5352:  static char sh_chars_sh[]  = "#;\"*?[]&|<>(){}$`^";
        -: 5353:  static char *sh_cmds_sh[]  = { "cd", "echo", "eval", "exec", "exit", "login",
        -: 5354:				 "logout", "set", "umask", "wait", "while",
        -: 5355:				 "for", "case", "if", ":", ".", "break",
        -: 5356:				 "continue", "export", "read", "readonly",
        -: 5357:				 "shift", "times", "trap", "switch", "unset",
        -: 5358:                                 0 };
        -: 5359:
        -: 5360:  char *sh_chars;
        -: 5361:  char **sh_cmds;
        -: 5362:#else
        -: 5363:#ifdef _AMIGA
        -: 5364:  static char sh_chars[] = "#;\"|<>()?*$`";
        -: 5365:  static char *sh_cmds[] = { "cd", "eval", "if", "delete", "echo", "copy",
        -: 5366:			     "rename", "set", "setenv", "date", "makedir",
        -: 5367:			     "skip", "else", "endif", "path", "prompt",
        -: 5368:			     "unset", "unsetenv", "version",
        -: 5369:			     0 };
        -: 5370:#else
        -: 5371:#ifdef WINDOWS32
        -: 5372:  static char sh_chars_dos[] = "\"|<>";
        -: 5373:  static char *sh_cmds_dos[] = { "break", "call", "cd", "chcp", "chdir", "cls",
        -: 5374:			     "copy", "ctty", "date", "del", "dir", "echo",
        -: 5375:			     "erase", "exit", "for", "goto", "if", "if", "md",
        -: 5376:			     "mkdir", "path", "pause", "prompt", "rem", "ren",
        -: 5377:			     "rename", "set", "shift", "time", "type",
        -: 5378:			     "ver", "verify", "vol", ":", 0 };
        -: 5379:  static char sh_chars_sh[] = "#;\"*?[]&|<>(){}$`^";
        -: 5380:  static char *sh_cmds_sh[] = { "cd", "eval", "exec", "exit", "login",
        -: 5381:			     "logout", "set", "umask", "wait", "while", "for",
        -: 5382:			     "case", "if", ":", ".", "break", "continue",
        -: 5383:			     "export", "read", "readonly", "shift", "times",
        -: 5384:			     "trap", "switch", "test",
        -: 5385:#ifdef BATCH_MODE_ONLY_SHELL
        -: 5386:                 "echo",
        -: 5387:#endif
        -: 5388:                 0 };
        -: 5389:  char*  sh_chars;
        -: 5390:  char** sh_cmds;
        -: 5391:#else  /* WINDOWS32 */
        -: 5392:  static char sh_chars[] = "#;\"*?[]&|<>(){}$`^";
        -: 5393:  static char *sh_cmds[] = { "cd", "eval", "exec", "exit", "login",
        -: 5394:			     "logout", "set", "umask", "wait", "while", "for",
        -: 5395:			     "case", "if", ":", ".", "break", "continue",
        -: 5396:			     "export", "read", "readonly", "shift", "times",
        -: 5397:			     "trap", "switch", 0 };
        -: 5398:#endif /* WINDOWS32 */
        -: 5399:#endif /* Amiga */
        -: 5400:#endif /* __MSDOS__ */
        -: 5401:  register int i;
        -: 5402:  register char *p;
        -: 5403:  register char *ap;
        -: 5404:  char *end;
        -: 5405:  int instring, word_has_equals, seen_nonequals, last_argument_was_empty;
    #####: 5406:  char **new_argv = 0;
        -: 5407:#ifdef WINDOWS32
        -: 5408:  int slow_flag = 0;
        -: 5409:
        -: 5410:  if (no_default_sh_exe) {
        -: 5411:    sh_cmds = sh_cmds_dos;
        -: 5412:    sh_chars = sh_chars_dos;
        -: 5413:  } else {
        -: 5414:    sh_cmds = sh_cmds_sh;
        -: 5415:    sh_chars = sh_chars_sh;
        -: 5416:  }
        -: 5417:#endif /* WINDOWS32 */
        -: 5418:
    #####: 5419:  if (restp != NULL)
branch  0 never executed
branch  1 never executed
    #####: 5420:    *restp = NULL;
        -: 5421:
        -: 5422:  /* Make sure not to bother processing an empty line.  */
    #####: 5423:  while (isblank (*line))
branch  0 never executed
branch  1 never executed
    #####: 5424:    ++line;
    #####: 5425:  if (*line == '\0')
branch  0 never executed
branch  1 never executed
    #####: 5426:    return 0;
        -: 5427:
        -: 5428:  /* See if it is safe to parse commands internally.  */
    #####: 5429:  if (shell == 0)
branch  0 never executed
branch  1 never executed
    #####: 5430:    shell = default_shell;
        -: 5431:#ifdef WINDOWS32
        -: 5432:  else if (strcmp (shell, default_shell))
        -: 5433:  {
        -: 5434:    char *s1 = _fullpath(NULL, shell, 0);
        -: 5435:    char *s2 = _fullpath(NULL, default_shell, 0);
        -: 5436:
        -: 5437:    slow_flag = strcmp((s1 ? s1 : ""), (s2 ? s2 : ""));
        -: 5438:
        -: 5439:    if (s1);
        -: 5440:      free(s1);
        -: 5441:    if (s2);
        -: 5442:      free(s2);
        -: 5443:  }
        -: 5444:  if (slow_flag)
        -: 5445:    goto slow;
        -: 5446:#else  /* not WINDOWS32 */
        -: 5447:#ifdef __MSDOS__
        -: 5448:  else if (stricmp (shell, default_shell))
        -: 5449:    {
        -: 5450:      extern int _is_unixy_shell (const char *_path);
        -: 5451:
        -: 5452:      message (1, _("$SHELL changed (was `%s', now `%s')"), default_shell, shell);
        -: 5453:      unixy_shell = _is_unixy_shell (shell);
        -: 5454:      default_shell = shell;
        -: 5455:    }
        -: 5456:  if (unixy_shell)
        -: 5457:    {
        -: 5458:      sh_chars = sh_chars_sh;
        -: 5459:      sh_cmds  = sh_cmds_sh;
        -: 5460:    }
        -: 5461:  else
        -: 5462:    {
        -: 5463:      sh_chars = sh_chars_dos;
        -: 5464:      sh_cmds  = sh_cmds_dos;
        -: 5465:    }
        -: 5466:#else  /* not __MSDOS__ */
    #####: 5467:  else if (strcmp (shell, default_shell))
branch  0 never executed
branch  1 never executed
    #####: 5468:    goto slow;
        -: 5469:#endif /* not __MSDOS__ */
        -: 5470:#endif /* not WINDOWS32 */
        -: 5471:
    #####: 5472:  if (ifs != 0)
branch  0 never executed
branch  1 never executed
    #####: 5473:    for (ap = ifs; *ap != '\0'; ++ap)
branch  0 never executed
branch  1 never executed
    #####: 5474:      if (*ap != ' ' && *ap != '\t' && *ap != '\n')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 5475:	goto slow;
        -: 5476:
    #####: 5477:  i = strlen (line) + 1;
        -: 5478:
        -: 5479:  /* More than 1 arg per character is impossible.  */
    #####: 5480:  new_argv = (char **) xmalloc (i * sizeof (char *));
call    0 never executed
        -: 5481:
        -: 5482:  /* All the args can fit in a buffer as big as LINE is.   */
    #####: 5483:  ap = new_argv[0] = (char *) xmalloc (i);
call    0 never executed
    #####: 5484:  end = ap + i;
        -: 5485:
        -: 5486:  /* I is how many complete arguments have been found.  */
    #####: 5487:  i = 0;
    #####: 5488:  instring = word_has_equals = seen_nonequals = last_argument_was_empty = 0;
    #####: 5489:  for (p = line; *p != '\0'; ++p)
branch  0 never executed
branch  1 never executed
        -: 5490:    {
    #####: 5491:      if (ap > end)
branch  0 never executed
branch  1 never executed
    #####: 5492:	abort ();
call    0 never executed
        -: 5493:
    #####: 5494:      if (instring)
branch  0 never executed
branch  1 never executed
        -: 5495:	{
    #####: 5496:	string_char:
        -: 5497:	  /* Inside a string, just copy any char except a closing quote
        -: 5498:	     or a backslash-newline combination.  */
    #####: 5499:	  if (*p == instring)
branch  0 never executed
branch  1 never executed
        -: 5500:	    {
    #####: 5501:	      instring = 0;
    #####: 5502:	      if (ap == new_argv[0] || *(ap-1) == '\0')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 5503:		last_argument_was_empty = 1;
        -: 5504:	    }
    #####: 5505:	  else if (*p == '\\' && p[1] == '\n')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 5506:	    goto swallow_escaped_newline;
    #####: 5507:	  else if (*p == '\n' && restp != NULL)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 5508:	    {
        -: 5509:	      /* End of the command line.  */
    #####: 5510:	      *restp = p;
    #####: 5511:	      goto end_of_line;
        -: 5512:	    }
        -: 5513:	  /* Backslash, $, and ` are special inside double quotes.
        -: 5514:	     If we see any of those, punt.
        -: 5515:	     But on MSDOS, if we use COMMAND.COM, double and single
        -: 5516:	     quotes have the same effect.  */
    #####: 5517:	  else if (instring == '"' && index ("\\$`", *p) != 0 && unixy_shell)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 5518:	    goto slow;
        -: 5519:	  else
    #####: 5520:	    *ap++ = *p;
        -: 5521:	}
    #####: 5522:      else if (index (sh_chars, *p) != 0)
branch  0 never executed
branch  1 never executed
        -: 5523:	/* Not inside a string, but it's a special char.  */
    #####: 5524:	goto slow;
        -: 5525:#ifdef  __MSDOS__
        -: 5526:      else if (*p == '.' && p[1] == '.' && p[2] == '.' && p[3] != '.')
        -: 5527:	/* `...' is a wildcard in DJGPP.  */
        -: 5528:	goto slow;
        -: 5529:#endif
        -: 5530:      else
        -: 5531:	/* Not a special char.  */
    #####: 5532:	switch (*p)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 5533:	  {
    #####: 5534:	  case '=':
        -: 5535:	    /* Equals is a special character in leading words before the
        -: 5536:	       first word with no equals sign in it.  This is not the case
        -: 5537:	       with sh -k, but we never get here when using nonstandard
        -: 5538:	       shell flags.  */
    #####: 5539:	    if (! seen_nonequals && unixy_shell)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 5540:	      goto slow;
    #####: 5541:	    word_has_equals = 1;
    #####: 5542:	    *ap++ = '=';
    #####: 5543:	    break;
        -: 5544:
    #####: 5545:	  case '\\':
        -: 5546:	    /* Backslash-newline combinations are eaten.  */
    #####: 5547:	    if (p[1] == '\n')
branch  0 never executed
branch  1 never executed
        -: 5548:	      {
    #####: 5549:	      swallow_escaped_newline:
        -: 5550:
        -: 5551:		/* Eat the backslash, the newline, and following whitespace,
        -: 5552:		   replacing it all with a single space.  */
    #####: 5553:		p += 2;
        -: 5554:
        -: 5555:		/* If there is a tab after a backslash-newline,
        -: 5556:		   remove it from the source line which will be echoed,
        -: 5557:		   since it was most likely used to line
        -: 5558:		   up the continued line with the previous one.  */
    #####: 5559:		if (*p == '\t')
branch  0 never executed
branch  1 never executed
        -: 5560:                  /* Note these overlap and strcpy() is undefined for
        -: 5561:                     overlapping objects in ANSI C.  The strlen() _IS_ right,
        -: 5562:                     since we need to copy the nul byte too.  */
    #####: 5563:		  bcopy (p + 1, p, strlen (p));
        -: 5564:
    #####: 5565:		if (instring)
branch  0 never executed
branch  1 never executed
    #####: 5566:		  goto string_char;
        -: 5567:		else
        -: 5568:		  {
    #####: 5569:		    if (ap != new_argv[i])
branch  0 never executed
branch  1 never executed
        -: 5570:		      /* Treat this as a space, ending the arg.
        -: 5571:			 But if it's at the beginning of the arg, it should
        -: 5572:			 just get eaten, rather than becoming an empty arg. */
    #####: 5573:		      goto end_of_arg;
        -: 5574:		    else
    #####: 5575:		      p = next_token (p) - 1;
call    0 never executed
        -: 5576:		  }
        -: 5577:	      }
    #####: 5578:	    else if (p[1] != '\0')
branch  0 never executed
branch  1 never executed
        -: 5579:              {
        -: 5580:#if defined(__MSDOS__) || defined(WINDOWS32)
        -: 5581:                /* Only remove backslashes before characters special
        -: 5582:                   to Unixy shells.  All other backslashes are copied
        -: 5583:                   verbatim, since they are probably DOS-style
        -: 5584:                   directory separators.  This still leaves a small
        -: 5585:                   window for problems, but at least it should work
        -: 5586:                   for the vast majority of naive users.  */
        -: 5587:
        -: 5588:#ifdef __MSDOS__
        -: 5589:                /* A dot is only special as part of the "..."
        -: 5590:                   wildcard.  */
        -: 5591:                if (strneq (p + 1, ".\\.\\.", 5))
        -: 5592:                  {
        -: 5593:                    *ap++ = '.';
        -: 5594:                    *ap++ = '.';
        -: 5595:                    p += 4;
        -: 5596:                  }
        -: 5597:                else
        -: 5598:#endif
        -: 5599:                  if (p[1] != '\\' && p[1] != '\'' && !isspace (p[1])
        -: 5600:                      && (index (sh_chars_sh, p[1]) == 0))
        -: 5601:                    /* back up one notch, to copy the backslash */
        -: 5602:                    --p;
        -: 5603:
        -: 5604:#endif  /* __MSDOS__ || WINDOWS32 */
        -: 5605:                /* Copy and skip the following char.  */
    #####: 5606:                *ap++ = *++p;
        -: 5607:              }
    #####: 5608:	    break;
        -: 5609:
    #####: 5610:	  case '\'':
        -: 5611:	  case '"':
    #####: 5612:	    instring = *p;
    #####: 5613:	    break;
        -: 5614:
    #####: 5615:	  case '\n':
    #####: 5616:	    if (restp != NULL)
branch  0 never executed
branch  1 never executed
        -: 5617:	      {
        -: 5618:		/* End of the command line.  */
    #####: 5619:		*restp = p;
    #####: 5620:		goto end_of_line;
        -: 5621:	      }
        -: 5622:	    else
        -: 5623:	      /* Newlines are not special.  */
    #####: 5624:	      *ap++ = '\n';
    #####: 5625:	    break;
        -: 5626:
        -: 5627:	  case ' ':
        -: 5628:	  case '\t':
    #####: 5629:	  end_of_arg:
        -: 5630:	    /* We have the end of an argument.
        -: 5631:	       Terminate the text of the argument.  */
    #####: 5632:	    *ap++ = '\0';
    #####: 5633:	    new_argv[++i] = ap;
    #####: 5634:	    last_argument_was_empty = 0;
        -: 5635:
        -: 5636:	    /* Update SEEN_NONEQUALS, which tells us if every word
        -: 5637:	       heretofore has contained an `='.  */
    #####: 5638:	    seen_nonequals |= ! word_has_equals;
    #####: 5639:	    if (word_has_equals && ! seen_nonequals)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 5640:	      /* An `=' in a word before the first
        -: 5641:		 word without one is magical.  */
    #####: 5642:	      goto slow;
    #####: 5643:	    word_has_equals = 0; /* Prepare for the next word.  */
        -: 5644:
        -: 5645:	    /* If this argument is the command name,
        -: 5646:	       see if it is a built-in shell command.
        -: 5647:	       If so, have the shell handle it.  */
    #####: 5648:	    if (i == 1)
branch  0 never executed
branch  1 never executed
        -: 5649:	      {
        -: 5650:		register int j;
    #####: 5651:		for (j = 0; sh_cmds[j] != 0; ++j)
branch  0 never executed
branch  1 never executed
    #####: 5652:		  if (streq (sh_cmds[j], new_argv[0]))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####: 5653:		    goto slow;
        -: 5654:	      }
        -: 5655:
        -: 5656:	    /* Ignore multiple whitespace chars.  */
    #####: 5657:	    p = next_token (p);
call    0 never executed
        -: 5658:	    /* Next iteration should examine the first nonwhite char.  */
    #####: 5659:	    --p;
    #####: 5660:	    break;
        -: 5661:
    #####: 5662:	  default:
    #####: 5663:	    *ap++ = *p;
    #####: 5664:	    break;
        -: 5665:	  }
        -: 5666:    }
    #####: 5667: end_of_line:
        -: 5668:
    #####: 5669:  if (instring)
branch  0 never executed
branch  1 never executed
        -: 5670:    /* Let the shell deal with an unterminated quote.  */
    #####: 5671:    goto slow;
        -: 5672:
        -: 5673:  /* Terminate the last argument and the argument list.  */
        -: 5674:
    #####: 5675:  *ap = '\0';
    #####: 5676:  if (new_argv[i][0] != '\0' || last_argument_was_empty)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 5677:    ++i;
    #####: 5678:  new_argv[i] = 0;
        -: 5679:
    #####: 5680:  if (i == 1)
branch  0 never executed
branch  1 never executed
        -: 5681:    {
        -: 5682:      register int j;
    #####: 5683:      for (j = 0; sh_cmds[j] != 0; ++j)
branch  0 never executed
branch  1 never executed
    #####: 5684:	if (streq (sh_cmds[j], new_argv[0]))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####: 5685:	  goto slow;
        -: 5686:    }
        -: 5687:
    #####: 5688:  if (new_argv[0] == 0)
branch  0 never executed
branch  1 never executed
        -: 5689:    /* Line was empty.  */
    #####: 5690:    return 0;
        -: 5691:  else
    #####: 5692:    return new_argv;
        -: 5693:
    #####: 5694: slow:;
        -: 5695:  /* We must use the shell.  */
        -: 5696:
    #####: 5697:  if (new_argv != 0)
branch  0 never executed
branch  1 never executed
        -: 5698:    {
        -: 5699:      /* Free the old argument list we were working on.  */
    #####: 5700:      free (new_argv[0]);
    #####: 5701:      free ((void *)new_argv);
        -: 5702:    }
        -: 5703:
        -: 5704:#ifdef __MSDOS__
        -: 5705:  execute_by_shell = 1;	/* actually, call `system' if shell isn't unixy */
        -: 5706:#endif
        -: 5707:
        -: 5708:#ifdef _AMIGA
        -: 5709:  {
        -: 5710:    char *ptr;
        -: 5711:    char *buffer;
        -: 5712:    char *dptr;
        -: 5713:
        -: 5714:    buffer = (char *)xmalloc (strlen (line)+1);
        -: 5715:
        -: 5716:    ptr = line;
        -: 5717:    for (dptr=buffer; *ptr; )
        -: 5718:    {
        -: 5719:      if (*ptr == '\\' && ptr[1] == '\n')
        -: 5720:	ptr += 2;
        -: 5721:      else if (*ptr == '@') /* Kludge: multiline commands */
        -: 5722:      {
        -: 5723:	ptr += 2;
        -: 5724:	*dptr++ = '\n';
        -: 5725:      }
        -: 5726:      else
        -: 5727:	*dptr++ = *ptr++;
        -: 5728:    }
        -: 5729:    *dptr = 0;
        -: 5730:
        -: 5731:    new_argv = (char **) xmalloc (2 * sizeof (char *));
        -: 5732:    new_argv[0] = buffer;
        -: 5733:    new_argv[1] = 0;
        -: 5734:  }
        -: 5735:#else	/* Not Amiga  */
        -: 5736:#ifdef WINDOWS32
        -: 5737:  /*
        -: 5738:   * Not eating this whitespace caused things like
        -: 5739:   *
        -: 5740:   *    sh -c "\n"
        -: 5741:   *
        -: 5742:   * which gave the shell fits. I think we have to eat
        -: 5743:   * whitespace here, but this code should be considered
        -: 5744:   * suspicious if things start failing....
        -: 5745:   */
        -: 5746:
        -: 5747:  /* Make sure not to bother processing an empty line.  */
        -: 5748:  while (isspace (*line))
        -: 5749:    ++line;
        -: 5750:  if (*line == '\0')
        -: 5751:    return 0;
        -: 5752:#endif /* WINDOWS32 */
        -: 5753:  {
        -: 5754:    /* SHELL may be a multi-word command.  Construct a command line
        -: 5755:       "SHELL -c LINE", with all special chars in LINE escaped.
        -: 5756:       Then recurse, expanding this command line to get the final
        -: 5757:       argument list.  */
        -: 5758:
    #####: 5759:    unsigned int shell_len = strlen (shell);
        -: 5760:    static char minus_c[] = " -c ";
    #####: 5761:    unsigned int line_len = strlen (line);
        -: 5762:
    #####: 5763:    char *new_line = (char *) alloca (shell_len + (sizeof (minus_c) - 1)
        -: 5764:				      + (line_len * 2) + 1);
    #####: 5765:    char* command_ptr = NULL; /* used for batch_mode_shell mode */
        -: 5766:
    #####: 5767:    ap = new_line;
    #####: 5768:    bcopy (shell, ap, shell_len);
    #####: 5769:    ap += shell_len;
    #####: 5770:    bcopy (minus_c, ap, sizeof (minus_c) - 1);
    #####: 5771:    ap += sizeof (minus_c) - 1;
    #####: 5772:	command_ptr = ap;
    #####: 5773:    for (p = line; *p != '\0'; ++p)
branch  0 never executed
branch  1 never executed
        -: 5774:      {
    #####: 5775:	if (restp != NULL && *p == '\n')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 5776:	  {
    #####: 5777:	    *restp = p;
    #####: 5778:	    break;
        -: 5779:	  }
    #####: 5780:	else if (*p == '\\' && p[1] == '\n')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 5781:	  {
        -: 5782:	    /* Eat the backslash, the newline, and following whitespace,
        -: 5783:	       replacing it all with a single space (which is escaped
        -: 5784:	       from the shell).  */
    #####: 5785:	    p += 2;
        -: 5786:
        -: 5787:	    /* If there is a tab after a backslash-newline,
        -: 5788:	       remove it from the source line which will be echoed,
        -: 5789:	       since it was most likely used to line
        -: 5790:	       up the continued line with the previous one.  */
    #####: 5791:	    if (*p == '\t')
branch  0 never executed
branch  1 never executed
    #####: 5792:	      bcopy (p + 1, p, strlen (p));
        -: 5793:
    #####: 5794:	    p = next_token (p);
call    0 never executed
    #####: 5795:	    --p;
    #####: 5796:            if (unixy_shell && !batch_mode_shell)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 5797:              *ap++ = '\\';
    #####: 5798:	    *ap++ = ' ';
    #####: 5799:	    continue;
        -: 5800:	  }
        -: 5801:
        -: 5802:        /* DOS shells don't know about backslash-escaping.  */
    #####: 5803:	if (unixy_shell && !batch_mode_shell &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 5804:            (*p == '\\' || *p == '\'' || *p == '"'
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 5805:             || isspace (*p)
branch  0 never executed
branch  1 never executed
    #####: 5806:             || index (sh_chars, *p) != 0))
branch  0 never executed
branch  1 never executed
    #####: 5807:	  *ap++ = '\\';
        -: 5808:#ifdef __MSDOS__
        -: 5809:        else if (unixy_shell && strneq (p, "...", 3))
        -: 5810:          {
        -: 5811:            /* The case of `...' wildcard again.  */
        -: 5812:            strcpy (ap, "\\.\\.\\");
        -: 5813:            ap += 5;
        -: 5814:            p  += 2;
        -: 5815:          }
        -: 5816:#endif
    #####: 5817:	*ap++ = *p;
        -: 5818:      }
    #####: 5819:    if (ap == new_line + shell_len + sizeof (minus_c) - 1)
branch  0 never executed
branch  1 never executed
        -: 5820:      /* Line was empty.  */
    #####: 5821:      return 0;
    #####: 5822:    *ap = '\0';
        -: 5823:
        -: 5824:#ifdef WINDOWS32
        -: 5825:    /* Some shells do not work well when invoked as 'sh -c xxx' to run a
        -: 5826:       command line (e.g. Cygnus GNUWIN32 sh.exe on WIN32 systems).  In these
        -: 5827:       cases, run commands via a script file.  */
        -: 5828:    if ((no_default_sh_exe || batch_mode_shell) && batch_filename_ptr) {
        -: 5829:      FILE* batch = NULL;
        -: 5830:      int id = GetCurrentProcessId();
        -: 5831:      PATH_VAR(fbuf);
        -: 5832:      char* fname = NULL;
        -: 5833:
        -: 5834:      /* create a file name */
        -: 5835:      sprintf(fbuf, "make%d", id);
        -: 5836:      fname = tempnam(".", fbuf);
        -: 5837:
        -: 5838:	  /* create batch file name */
        -: 5839:      *batch_filename_ptr = xmalloc(strlen(fname) + 5);
        -: 5840:      strcpy(*batch_filename_ptr, fname);
        -: 5841:
        -: 5842:      /* make sure path name is in DOS backslash format */
        -: 5843:      if (!unixy_shell) {
        -: 5844:        fname = *batch_filename_ptr;
        -: 5845:        for (i = 0; fname[i] != '\0'; ++i)
        -: 5846:          if (fname[i] == '/')
        -: 5847:            fname[i] = '\\';
        -: 5848:        strcat(*batch_filename_ptr, ".bat");
        -: 5849:      } else {
        -: 5850:        strcat(*batch_filename_ptr, ".sh");
        -: 5851:      }
        -: 5852:
        -: 5853:      if (debug_flag)
        -: 5854:        printf(_("Creating temporary batch file %s\n"), *batch_filename_ptr);
        -: 5855:
        -: 5856:      /* create batch file to execute command */
        -: 5857:      batch = fopen (*batch_filename_ptr, "w");
        -: 5858:      if (!unixy_shell)
        -: 5859:        fputs ("@echo off\n", batch);
        -: 5860:      fputs (command_ptr, batch);
        -: 5861:      fputc ('\n', batch);
        -: 5862:      fclose (batch);
        -: 5863:
        -: 5864:      /* create argv */
        -: 5865:      new_argv = (char **) xmalloc(3 * sizeof(char *));
        -: 5866:      if (unixy_shell) {
        -: 5867:        new_argv[0] = xstrdup (shell);
        -: 5868:        new_argv[1] = *batch_filename_ptr; /* only argv[0] gets freed later */
        -: 5869:      } else {
        -: 5870:        new_argv[0] = xstrdup (*batch_filename_ptr);
        -: 5871:        new_argv[1] = NULL;
        -: 5872:      }
        -: 5873:      new_argv[2] = NULL;
        -: 5874:    } else
        -: 5875:#endif /* WINDOWS32 */
    #####: 5876:    if (unixy_shell)
branch  0 never executed
branch  1 never executed
    #####: 5877:      new_argv = construct_command_argv_internal (new_line, (char **) NULL,
call    0 never executed
        -: 5878:                                                  (char *) 0, (char *) 0,
        -: 5879:                                                  (char *) 0);
        -: 5880:#ifdef  __MSDOS__
        -: 5881:    else
        -: 5882:      {
        -: 5883:      /* With MSDOS shells, we must construct the command line here
        -: 5884:         instead of recursively calling ourselves, because we
        -: 5885:         cannot backslash-escape the special characters (see above).  */
        -: 5886:      new_argv = (char **) xmalloc (sizeof (char *));
        -: 5887:      line_len = strlen (new_line) - shell_len - sizeof (minus_c) + 1;
        -: 5888:      new_argv[0] = xmalloc (line_len + 1);
        -: 5889:      strncpy (new_argv[0],
        -: 5890:               new_line + shell_len + sizeof (minus_c) - 1, line_len);
        -: 5891:      new_argv[0][line_len] = '\0';
        -: 5892:      }
        -: 5893:#else
        -: 5894:    else
    #####: 5895:      fatal (NILF, _("%s (line %d) Bad shell context (!unixy && !batch_mode_shell)\n"),
call    0 never executed
        -: 5896:            __FILE__, __LINE__);
        -: 5897:#endif
        -: 5898:  }
        -: 5899:#endif	/* ! AMIGA */
        -: 5900:
    #####: 5901:  return new_argv;
        -: 5902:}
        -: 5903:
        -: 5904:/* Figure out the argument list necessary to run LINE as a command.  Try to
        -: 5905:   avoid using a shell.  This routine handles only ' quoting, and " quoting
        -: 5906:   when no backslash, $ or ` characters are seen in the quotes.  Starting
        -: 5907:   quotes may be escaped with a backslash.  If any of the characters in
        -: 5908:   sh_chars[] is seen, or any of the builtin commands listed in sh_cmds[]
        -: 5909:   is the first word of a line, the shell is used.
        -: 5910:
        -: 5911:   If RESTP is not NULL, *RESTP is set to point to the first newline in LINE.
        -: 5912:   If *RESTP is NULL, newlines will be ignored.
        -: 5913:
        -: 5914:   FILE is the target whose commands these are.  It is used for
        -: 5915:   variable expansion for $(SHELL) and $(IFS).  */
        -: 5916:
        -: 5917:char **
function construct_command_argv called 0 returned 0% blocks executed 0%
    #####: 5918:construct_command_argv (line, restp, file, batch_filename_ptr)
        -: 5919:     char *line, **restp;
        -: 5920:     struct file *file;
        -: 5921:     char** batch_filename_ptr;
        -: 5922:{
        -: 5923:  char *shell, *ifs;
        -: 5924:  char **argv;
        -: 5925:
        -: 5926:  {
        -: 5927:    /* Turn off --warn-undefined-variables while we expand SHELL and IFS.  */
    #####: 5928:    int save = warn_undefined_variables_flag;
    #####: 5929:    warn_undefined_variables_flag = 0;
        -: 5930:
    #####: 5931:    shell = allocated_variable_expand_for_file ("$(SHELL)", file);
call    0 never executed
        -: 5932:#ifdef WINDOWS32
        -: 5933:    /*
        -: 5934:     * Convert to forward slashes so that construct_command_argv_internal()
        -: 5935:     * is not confused.
        -: 5936:     */
        -: 5937:    if (shell) {
        -: 5938:      char *p = w32ify(shell, 0);
        -: 5939:      strcpy(shell, p);
        -: 5940:    }
        -: 5941:#endif
    #####: 5942:    ifs = allocated_variable_expand_for_file ("$(IFS)", file);
call    0 never executed
        -: 5943:
    #####: 5944:    warn_undefined_variables_flag = save;
        -: 5945:  }
        -: 5946:
    #####: 5947:  argv = construct_command_argv_internal (line, restp, shell, ifs, batch_filename_ptr);
call    0 never executed
        -: 5948:
    #####: 5949:  free (shell);
    #####: 5950:  free (ifs);
        -: 5951:
    #####: 5952:  return argv;
        -: 5953:}
        -: 5954:#endif /* !VMS */
        -: 5955:
        -: 5956:#if !defined(HAVE_DUP2) && !defined(_AMIGA)
        -: 5957:int
        -: 5958:dup2 (old, new)
        -: 5959:     int old, new;
        -: 5960:{
        -: 5961:  int fd;
        -: 5962:
        -: 5963:  (void) close (new);
        -: 5964:  fd = dup (old);
        -: 5965:  if (fd != new)
        -: 5966:    {
        -: 5967:      (void) close (fd);
        -: 5968:      errno = EMFILE;
        -: 5969:      return -1;
        -: 5970:    }
        -: 5971:
        -: 5972:  return fd;
        -: 5973:}
        -: 5974:#endif /* !HAPE_DUP2 && !_AMIGA */
        -: 5975:
        -: 5976:
        -: 5977:
        -: 5978:/*************************************************************
        -: 5979:  ============================================================
        -: 5980:  ************************************************************
        -: 5981:  ============================================================
        -: 5982:  ************************************************************
        -: 5983:                         dir.c
        -: 5984:  ************************************************************
        -: 5985:  ============================================================
        -: 5986:  ************************************************************
        -: 5987:  ============================================================
        -: 5988:  *************************************************************/
        -: 5989:
        -: 5990:/* Directory hashing for GNU Make.
        -: 5991:Copyright (C) 1988,89,91,92,93,94,95,96,97 Free Software Foundation, Inc.
        -: 5992:This file is part of GNU Make.
        -: 5993:
        -: 5994:GNU Make is free software; you can redistribute it and/or modify
        -: 5995:it under the terms of the GNU General Public License as published by
        -: 5996:the Free Software Foundation; either version 2, or (at your option)
        -: 5997:any later version.
        -: 5998:
        -: 5999:GNU Make is distributed in the hope that it will be useful,
        -: 6000:but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 6001:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 6002:GNU General Public License for more details.
        -: 6003:
        -: 6004:You should have received a copy of the GNU General Public License
        -: 6005:along with GNU Make; see the file COPYING.  If not, write to
        -: 6006:the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
        -: 6007:Boston, MA 02111-1307, USA.  */
        -: 6008:
        -: 6009:/* #include "make.h"  <- modification by J.Ruthruff, 7/27 */
        -: 6010:#undef stderr
        -: 6011:#define stderr stdout
        -: 6012:
        -: 6013:#ifdef	HAVE_DIRENT_H
        -: 6014:# include <dirent.h>
        -: 6015:#undef stderr
        -: 6016:#define stderr stdout
        -: 6017:# define NAMLEN(dirent) strlen((dirent)->d_name)
        -: 6018:#else
        -: 6019:# define dirent direct
        -: 6020:# define NAMLEN(dirent) (dirent)->d_namlen
        -: 6021:# ifdef HAVE_SYS_NDIR_H
        -: 6022:#  include <sys/ndir.h>
        -: 6023:#undef stderr
        -: 6024:#define stderr stdout
        -: 6025:# endif
        -: 6026:# ifdef HAVE_SYS_DIR_H
        -: 6027:#  include <sys/dir.h>
        -: 6028:#undef stderr
        -: 6029:#define stderr stdout
        -: 6030:# endif
        -: 6031:# ifdef HAVE_NDIR_H
        -: 6032:#  include <ndir.h>
        -: 6033:#undef stderr
        -: 6034:#define stderr stdout
        -: 6035:# endif
        -: 6036:# ifdef HAVE_VMSDIR_H
        -: 6037:#  include "vmsdir.h"
        -: 6038:#undef stderr
        -: 6039:#define stderr stdout
        -: 6040:# endif /* HAVE_VMSDIR_H */
        -: 6041:#endif
        -: 6042:
        -: 6043:/* In GNU systems, <dirent.h> defines this macro for us.  */
        -: 6044:#ifdef _D_NAMLEN
        -: 6045:#undef NAMLEN
        -: 6046:#define NAMLEN(d) _D_NAMLEN(d)
        -: 6047:#endif
        -: 6048:
        -: 6049:#if (defined (POSIX) || defined (WINDOWS32)) && !defined (__GNU_LIBRARY__)
        -: 6050:/* Posix does not require that the d_ino field be present, and some
        -: 6051:   systems do not provide it. */
        -: 6052:#define REAL_DIR_ENTRY(dp) 1
        -: 6053:#define FAKE_DIR_ENTRY(dp)
        -: 6054:#else
        -: 6055:#define REAL_DIR_ENTRY(dp) (dp->d_ino != 0)
        -: 6056:#define FAKE_DIR_ENTRY(dp) (dp->d_ino = 1)
        -: 6057:#endif /* POSIX */
        -: 6058:
        -: 6059:#ifdef __MSDOS__
        -: 6060:#include <ctype.h>
        -: 6061:#include <fcntl.h>
        -: 6062:#undef stderr
        -: 6063:#define stderr stdout
        -: 6064:
        -: 6065:/* If it's MSDOS that doesn't have _USE_LFN, disable LFN support.  */
        -: 6066:#ifndef _USE_LFN
        -: 6067:#define _USE_LFN 0
        -: 6068:#endif
        -: 6069:
        -: 6070:static char *
        -: 6071:dosify (filename)
        -: 6072:     char *filename;
        -: 6073:{
        -: 6074:  static char dos_filename[14];
        -: 6075:  char *df;
        -: 6076:  int i;
        -: 6077:
        -: 6078:  if (filename == 0 || _USE_LFN)
        -: 6079:    return filename;
        -: 6080:
        -: 6081:  /* FIXME: what about filenames which violate
        -: 6082:     8+3 constraints, like "config.h.in", or ".emacs"?  */
        -: 6083:  if (strpbrk (filename, "\"*+,;<=>?[\\]|") != 0)
        -: 6084:    return filename;
        -: 6085:
        -: 6086:  df = dos_filename;
        -: 6087:
        -: 6088:  /* First, transform the name part.  */
        -: 6089:  for (i = 0; *filename != '\0' && i < 8 && *filename != '.'; ++i)
        -: 6090:    *df++ = tolower (*filename++);
        -: 6091:
        -: 6092:  /* Now skip to the next dot.  */
        -: 6093:  while (*filename != '\0' && *filename != '.')
        -: 6094:    ++filename;
        -: 6095:  if (*filename != '\0')
        -: 6096:    {
        -: 6097:      *df++ = *filename++;
        -: 6098:      for (i = 0; *filename != '\0' && i < 3 && *filename != '.'; ++i)
        -: 6099:	*df++ = tolower (*filename++);
        -: 6100:    }
        -: 6101:
        -: 6102:  /* Look for more dots.  */
        -: 6103:  while (*filename != '\0' && *filename != '.')
        -: 6104:    ++filename;
        -: 6105:  if (*filename == '.')
        -: 6106:    return filename;
        -: 6107:  *df = 0;
        -: 6108:  return dos_filename;
        -: 6109:}
        -: 6110:#endif /* __MSDOS__ */
        -: 6111:
        -: 6112:#ifdef WINDOWS32
        -: 6113:#include "pathstuff.h"
        -: 6114:#undef stderr
        -: 6115:#define stderr stdout
        -: 6116:#endif
        -: 6117:
        -: 6118:#ifdef _AMIGA
        -: 6119:#include <ctype.h>
        -: 6120:#undef stderr
        -: 6121:#define stderr stdout
        -: 6122:#endif
        -: 6123:
        -: 6124:#ifdef HAVE_CASE_INSENSITIVE_FS
        -: 6125:static char *
        -: 6126:downcase (filename)
        -: 6127:     char *filename;
        -: 6128:{
        -: 6129:#ifdef _AMIGA
        -: 6130:  static char new_filename[136];
        -: 6131:#else
        -: 6132:  static char new_filename[PATH_MAX];
        -: 6133:#endif
        -: 6134:  char *df;
        -: 6135:  int i;
        -: 6136:
        -: 6137:  if (filename == 0)
        -: 6138:    return 0;
        -: 6139:
        -: 6140:  df = new_filename;
        -: 6141:
        -: 6142:  /* First, transform the name part.  */
        -: 6143:  for (i = 0; *filename != '\0'; ++i)
        -: 6144:  {
        -: 6145:    *df++ = tolower (*filename);
        -: 6146:    ++filename;
        -: 6147:  }
        -: 6148:
        -: 6149:  *df = 0;
        -: 6150:
        -: 6151:  return new_filename;
        -: 6152:}
        -: 6153:#endif /* HAVE_CASE_INSENSITIVE_FS */
        -: 6154:
        -: 6155:#ifdef VMS
        -: 6156:
        -: 6157:static int
        -: 6158:vms_hash (name)
        -: 6159:    char *name;
        -: 6160:{
        -: 6161:  int h = 0;
        -: 6162:  int g;
        -: 6163:
        -: 6164:  while (*name)
        -: 6165:    {
        -: 6166:      h = (h << 4) + *name++;
        -: 6167:      g = h & 0xf0000000;
        -: 6168:      if (g)
        -: 6169:	{
        -: 6170:	  h = h ^ (g >> 24);
        -: 6171:	  h = h ^ g;
        -: 6172:	}
        -: 6173:    }
        -: 6174:  return h;
        -: 6175:}
        -: 6176:
        -: 6177:/* fake stat entry for a directory */
        -: 6178:static int
        -: 6179:vmsstat_dir (name, st)
        -: 6180:    char *name;
        -: 6181:    struct stat *st;
        -: 6182:{
        -: 6183:  char *s;
        -: 6184:  int h;
        -: 6185:  DIR *dir;
        -: 6186:
        -: 6187:  dir = opendir (name);
        -: 6188:  if (dir == 0)
        -: 6189:    return -1;
        -: 6190:  closedir (dir);
        -: 6191:  s = strchr (name, ':');	/* find device */
        -: 6192:  if (s)
        -: 6193:    {
        -: 6194:      *s++ = 0;
        -: 6195:      st->st_dev = (char *)vms_hash (name);
        -: 6196:      h = vms_hash (s);
        -: 6197:      *(s-1) = ':';
        -: 6198:    }
        -: 6199:  else
        -: 6200:    {
        -: 6201:      st->st_dev = 0;
        -: 6202:      s = name;
        -: 6203:      h = vms_hash (s);
        -: 6204:    }
        -: 6205:
        -: 6206:  st->st_ino[0] = h & 0xff;
        -: 6207:  st->st_ino[1] = h & 0xff00;
        -: 6208:  st->st_ino[2] = h >> 16;
        -: 6209:
        -: 6210:  return 0;
        -: 6211:}
        -: 6212:#endif /* VMS */
        -: 6213:
        -: 6214:/* Hash table of directories.  */
        -: 6215:
        -: 6216:#ifndef	DIRECTORY_BUCKETS
        -: 6217:#define DIRECTORY_BUCKETS 199
        -: 6218:#endif
        -: 6219:
        -: 6220:struct directory_contents
        -: 6221:  {
        -: 6222:    struct directory_contents *next;
        -: 6223:
        -: 6224:    dev_t dev;			/* Device and inode numbers of this dir.  */
        -: 6225:#ifdef WINDOWS32
        -: 6226:    /*
        -: 6227:     * Inode means nothing on WINDOWS32. Even file key information is
        -: 6228:     * unreliable because it is random per file open and undefined
        -: 6229:     * for remote filesystems. The most unique attribute I can
        -: 6230:     * come up with is the fully qualified name of the directory. Beware
        -: 6231:     * though, this is also unreliable. I'm open to suggestion on a better
        -: 6232:     * way to emulate inode.
        -: 6233:     */
        -: 6234:    char *path_key;
        -: 6235:    int   mtime;        /* controls check for stale directory cache */
        -: 6236:    int   fs_flags;     /* FS_FAT, FS_NTFS, ... */
        -: 6237:#define FS_FAT      0x1
        -: 6238:#define FS_NTFS     0x2
        -: 6239:#define FS_UNKNOWN  0x4
        -: 6240:#else
        -: 6241:#ifdef VMS
        -: 6242:    ino_t ino[3];
        -: 6243:#else
        -: 6244:    ino_t ino;
        -: 6245:#endif
        -: 6246:#endif /* WINDOWS32 */
        -: 6247:    struct dirfile **files;	/* Files in this directory.  */
        -: 6248:    DIR *dirstream;		/* Stream reading this directory.  */
        -: 6249:  };
        -: 6250:
        -: 6251:/* Table of directory contents hashed by device and inode number.  */
        -: 6252:static struct directory_contents *directories_contents[DIRECTORY_BUCKETS];
        -: 6253:
        -: 6254:struct directory
        -: 6255:  {
        -: 6256:    struct directory *next;
        -: 6257:
        -: 6258:    char *name;			/* Name of the directory.  */
        -: 6259:
        -: 6260:    /* The directory's contents.  This data may be shared by several
        -: 6261:       entries in the hash table, which refer to the same directory
        -: 6262:       (identified uniquely by `dev' and `ino') under different names.  */
        -: 6263:    struct directory_contents *contents;
        -: 6264:  };
        -: 6265:
        -: 6266:/* Table of directories hashed by name.  */
        -: 6267:static struct directory *table_of_directories[DIRECTORY_BUCKETS];
        -: 6268:
        -: 6269:
        -: 6270:/* Never have more than this many directories open at once.  */
        -: 6271:
        -: 6272:#define MAX_OPEN_DIRECTORIES 10
        -: 6273:
        -: 6274:static unsigned int open_directories = 0;
        -: 6275:
        -: 6276:
        -: 6277:/* Hash table of files in each directory.  */
        -: 6278:
        -: 6279:struct dirfile
        -: 6280:  {
        -: 6281:    struct dirfile *next;
        -: 6282:    char *name;			/* Name of the file.  */
        -: 6283:    char impossible;		/* This file is impossible.  */
        -: 6284:  };
        -: 6285:
        -: 6286:#ifndef	DIRFILE_BUCKETS
        -: 6287:#define DIRFILE_BUCKETS 107
        -: 6288:#endif
        -: 6289:
        -: 6290:static int dir_contents_file_exists_p PARAMS ((struct directory_contents *dir, char *filename));
        -: 6291:static struct directory *find_directory PARAMS ((char *name));
        -: 6292:
        -: 6293:/* Find the directory named NAME and return its `struct directory'.  */
        -: 6294:
        -: 6295:static struct directory *
function find_directory called 242094 returned 100% blocks executed 46%
   242094: 6296:find_directory (name)
        -: 6297:     register char *name;
        -: 6298:{
   242094: 6299:  register unsigned int hash = 0;
        -: 6300:  register char *p;
        -: 6301:  register struct directory *dir;
        -: 6302:#ifdef WINDOWS32
        -: 6303:  char* w32_path;
        -: 6304:  char  fs_label[BUFSIZ];
        -: 6305:  char  fs_type[BUFSIZ];
        -: 6306:  long  fs_serno;
        -: 6307:  long  fs_flags;
        -: 6308:  long  fs_len;
        -: 6309:#endif
        -: 6310:#ifdef VMS
        -: 6311:  if ((*name == '.') && (*(name+1) == 0))
        -: 6312:    name = "[]";
        -: 6313:  else
        -: 6314:    name = vmsify (name,1);
        -: 6315:#endif
        -: 6316:
  8523405: 6317:  for (p = name; *p != '\0'; ++p)
branch  0 taken 8281311
branch  1 taken 242094 (fallthrough)
  8281311: 6318:    HASHI (hash, *p);
   242094: 6319:  hash %= DIRECTORY_BUCKETS;
        -: 6320:
  242094*: 6321:  for (dir = table_of_directories[hash]; dir != 0; dir = dir->next)
branch  0 taken 238239
branch  1 taken 3855 (fallthrough)
   238239: 6322:    if (strieq (dir->name, name))
branch  0 taken 238239 (fallthrough)
branch  1 taken 0
branch  2 taken 238239 (fallthrough)
branch  3 taken 0
branch  4 taken 238239 (fallthrough)
branch  5 taken 0
branch  6 taken 0 (fallthrough)
branch  7 taken 238239
        -: 6323:      break;
        -: 6324:
   242094: 6325:  if (dir == 0)
branch  0 taken 3855 (fallthrough)
branch  1 taken 238239
        -: 6326:    {
        -: 6327:      struct stat st;
        -: 6328:
        -: 6329:      /* The directory was not found.  Create a new entry for it.  */
        -: 6330:
     3855: 6331:      dir = (struct directory *) xmalloc (sizeof (struct directory));
call    0 returned 3855
     3855: 6332:      dir->next = table_of_directories[hash];
     3855: 6333:      table_of_directories[hash] = dir;
     3855: 6334:      dir->name = savestring (name, p - name);
call    0 returned 3855
        -: 6335:
        -: 6336:      /* The directory is not in the name hash table.
        -: 6337:	 Find its device and inode numbers, and look it up by them.  */
        -: 6338:
        -: 6339:#ifdef VMS
        -: 6340:      if (vmsstat_dir (name, &st) < 0)
        -: 6341:#else
        -: 6342:
        -: 6343:#ifdef WINDOWS32
        -: 6344:      /* Remove any trailing '\'.  Windows32 stat fails even on valid
        -: 6345:         directories if they end in '\'. */
        -: 6346:      if (p[-1] == '\\')
        -: 6347:        p[-1] = '\0';
        -: 6348:#endif
     3855: 6349:      if (stat (name, &st) < 0)
call    0 returned 3855
branch  1 taken 3855 (fallthrough)
branch  2 taken 0
        -: 6350:#endif
        -: 6351:	{
        -: 6352:	/* Couldn't stat the directory.  Mark this by
        -: 6353:	   setting the `contents' member to a nil pointer.  */
     3855: 6354:	  dir->contents = 0;
        -: 6355:	}
        -: 6356:      else
        -: 6357:	{
        -: 6358:	  /* Search the contents hash table; device and inode are the key.  */
        -: 6359:
        -: 6360:	  struct directory_contents *dc;
        -: 6361:
        -: 6362:#ifdef WINDOWS32
        -: 6363:          w32_path = w32ify(name, 1);
        -: 6364:          hash = ((unsigned int) st.st_dev << 16) | (unsigned int) st.st_ctime;
        -: 6365:#else
        -: 6366:#ifdef VMS
        -: 6367:	hash = ((unsigned int) st.st_dev << 16)
        -: 6368:		| ((unsigned int) st.st_ino[0]
        -: 6369:		+ (unsigned int) st.st_ino[1]
        -: 6370:		+ (unsigned int) st.st_ino[2]);
        -: 6371:#else
    #####: 6372:	  hash = ((unsigned int) (dev_t_to_int(st.st_dev)) << 16) | ino_t_to_unsigned_int(st.st_ino);
call    0 never executed
call    1 never executed
        -: 6373:	  /*	  hash = ((unsigned int) st.st_dev << 16) | (unsigned int) st.st_ino; */
        -: 6374:#endif
        -: 6375:#endif
    #####: 6376:	  hash %= DIRECTORY_BUCKETS;
        -: 6377:
    #####: 6378:	  for (dc = directories_contents[hash]; dc != 0; dc = dc->next)
branch  0 never executed
branch  1 never executed
        -: 6379:#ifdef WINDOWS32
        -: 6380:            if (strieq(dc->path_key, w32_path))
        -: 6381:#else
    #####: 6382:	    if (dc->dev == st.st_dev
branch  0 never executed
branch  1 never executed
        -: 6383:#ifdef VMS
        -: 6384:		&& dc->ino[0] == st.st_ino[0]
        -: 6385:		&& dc->ino[1] == st.st_ino[1]
        -: 6386:		&& dc->ino[2] == st.st_ino[2])
        -: 6387:#else
    #####: 6388:	      && ino_t_equal(ino_t_to_int(dc->ino), ino_t_to_int(st.st_ino)) == 0)
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 6389:	  /*		 && dc->ino == st.st_ino) */
        -: 6390:#endif
        -: 6391:#endif /* WINDOWS32 */
    #####: 6392:	      break;
        -: 6393:
    #####: 6394:	  if (dc == 0)
branch  0 never executed
branch  1 never executed
        -: 6395:	    {
        -: 6396:	      /* Nope; this really is a directory we haven't seen before.  */
        -: 6397:
        -: 6398:	      dc = (struct directory_contents *)
    #####: 6399:		xmalloc (sizeof (struct directory_contents));
call    0 never executed
        -: 6400:
        -: 6401:	      /* Enter it in the contents hash table.  */
    #####: 6402:	      dc->dev = st.st_dev;
        -: 6403:#ifdef WINDOWS32
        -: 6404:              dc->path_key = xstrdup(w32_path);
        -: 6405:              dc->mtime = st.st_mtime;
        -: 6406:
        -: 6407:              /*
        -: 6408:               * NTFS is the only WINDOWS32 filesystem that bumps mtime
        -: 6409:               * on a directory when files are added/deleted from
        -: 6410:               * a directory.
        -: 6411:               */
        -: 6412:              w32_path[3] = '\0';
        -: 6413:              if (GetVolumeInformation(w32_path,
        -: 6414:                     fs_label, sizeof (fs_label),
        -: 6415:                     &fs_serno, &fs_len,
        -: 6416:                     &fs_flags, fs_type, sizeof (fs_type)) == FALSE)
        -: 6417:                dc->fs_flags = FS_UNKNOWN;
        -: 6418:              else if (!strcmp(fs_type, "FAT"))
        -: 6419:                dc->fs_flags = FS_FAT;
        -: 6420:              else if (!strcmp(fs_type, "NTFS"))
        -: 6421:                dc->fs_flags = FS_NTFS;
        -: 6422:              else
        -: 6423:                dc->fs_flags = FS_UNKNOWN;
        -: 6424:#else
        -: 6425:#ifdef VMS
        -: 6426:	      dc->ino[0] = st.st_ino[0];
        -: 6427:	      dc->ino[1] = st.st_ino[1];
        -: 6428:	      dc->ino[2] = st.st_ino[2];
        -: 6429:#else
    #####: 6430:	      dc->ino = st.st_ino;
        -: 6431:#endif
        -: 6432:#endif /* WINDOWS32 */
    #####: 6433:	      dc->next = directories_contents[hash];
    #####: 6434:	      directories_contents[hash] = dc;
        -: 6435:
    #####: 6436:	      dc->dirstream = opendir (name);
call    0 never executed
    #####: 6437:	      if (dc->dirstream == 0)
branch  0 never executed
branch  1 never executed
        -: 6438:		{
        -: 6439:		/* Couldn't open the directory.  Mark this by
        -: 6440:		   setting the `files' member to a nil pointer.  */
    #####: 6441:		  dc->files = 0;
        -: 6442:		}
        -: 6443:	      else
        -: 6444:		{
        -: 6445:		  /* Allocate an array of buckets for files and zero it.  */
    #####: 6446:		  dc->files = (struct dirfile **)
    #####: 6447:		    xmalloc (sizeof (struct dirfile *) * DIRFILE_BUCKETS);
call    0 never executed
    #####: 6448:		  bzero ((char *) dc->files,
        -: 6449:			 sizeof (struct dirfile *) * DIRFILE_BUCKETS);
        -: 6450:
        -: 6451:		  /* Keep track of how many directories are open.  */
    #####: 6452:		  ++open_directories;
    #####: 6453:		  if (open_directories == MAX_OPEN_DIRECTORIES)
branch  0 never executed
branch  1 never executed
        -: 6454:		    /* We have too many directories open already.
        -: 6455:		       Read the entire directory and then close it.  */
    #####: 6456:		    (void) dir_contents_file_exists_p (dc, (char *) 0);
call    0 never executed
        -: 6457:		}
        -: 6458:	    }
        -: 6459:
        -: 6460:	  /* Point the name-hashed entry for DIR at its contents data.  */
    #####: 6461:	  dir->contents = dc;
        -: 6462:	}
        -: 6463:    }
        -: 6464:
   242094: 6465:  return dir;
        -: 6466:}
        -: 6467:
        -: 6468:/* Return 1 if the name FILENAME is entered in DIR's hash table.
        -: 6469:   FILENAME must contain no slashes.  */
        -: 6470:
        -: 6471:static int
function dir_contents_file_exists_p called 109482 returned 100% blocks executed 44%
   109482: 6472:dir_contents_file_exists_p (dir, filename)
        -: 6473:     register struct directory_contents *dir;
        -: 6474:     register char *filename;
        -: 6475:{
        -: 6476:  register unsigned int hash;
        -: 6477:  register char *p;
        -: 6478:  register struct dirfile *df;
        -: 6479:  register struct dirent *d;
        -: 6480:#ifdef WINDOWS32
        -: 6481:  struct stat st;
        -: 6482:  int rehash = 0;
        -: 6483:#endif
        -: 6484:
   109482: 6485:  if (dir == 0 || dir->files == 0)
branch  0 taken 35466 (fallthrough)
branch  1 taken 74016
branch  2 taken 0 (fallthrough)
branch  3 taken 35466
        -: 6486:    {
        -: 6487:    /* The directory could not be stat'd or opened.  */
    74016: 6488:      return 0;
        -: 6489:    }
        -: 6490:#ifdef __MSDOS__
        -: 6491:  filename = dosify (filename);
        -: 6492:#endif
        -: 6493:
        -: 6494:#ifdef HAVE_CASE_INSENSITIVE_FS
        -: 6495:  filename = downcase (filename);
        -: 6496:#endif
        -: 6497:
        -: 6498:#ifdef VMS
        -: 6499:  filename = vmsify (filename,0);
        -: 6500:#endif
        -: 6501:
    35466: 6502:  hash = 0;
    35466: 6503:  if (filename != 0)
branch  0 taken 35466 (fallthrough)
branch  1 taken 0
        -: 6504:    {
    35466: 6505:      if (*filename == '\0')
branch  0 taken 0 (fallthrough)
branch  1 taken 35466
        -: 6506:	{
        -: 6507:	/* Checking if the directory exists.  */
    #####: 6508:	  return 1;
        -: 6509:	}
        -: 6510:
   560022: 6511:      for (p = filename; *p != '\0'; ++p)
branch  0 taken 524556
branch  1 taken 35466 (fallthrough)
   524556: 6512:	HASH (hash, *p);
    35466: 6513:      hash %= DIRFILE_BUCKETS;
        -: 6514:
        -: 6515:      /* Search the list of hashed files.  */
        -: 6516:
    37396: 6517:      for (df = dir->files[hash]; df != 0; df = df->next)
branch  0 taken 1930
branch  1 taken 35466 (fallthrough)
        -: 6518:	{
     1930: 6519:	  if (strieq (df->name, filename))
branch  0 taken 1930 (fallthrough)
branch  1 taken 0
branch  2 taken 389 (fallthrough)
branch  3 taken 1541
branch  4 taken 389 (fallthrough)
branch  5 taken 0
branch  6 taken 0 (fallthrough)
branch  7 taken 389
        -: 6520:	    {
    #####: 6521:	      return !df->impossible;
        -: 6522:	    }
        -: 6523:	}
        -: 6524:    }
        -: 6525:
        -: 6526:  /* The file was not found in the hashed list.
        -: 6527:     Try to read the directory further.  */
        -: 6528:
    35466: 6529:  if (dir->dirstream == 0)
branch  0 taken 35466 (fallthrough)
branch  1 taken 0
        -: 6530:    {
        -: 6531:#ifdef WINDOWS32
        -: 6532:      /*
        -: 6533:       * Check to see if directory has changed since last read. FAT
        -: 6534:       * filesystems force a rehash always as mtime does not change
        -: 6535:       * on directories (ugh!).
        -: 6536:       */
        -: 6537:      if (dir->path_key &&
        -: 6538:          (dir->fs_flags & FS_FAT ||
        -: 6539:           (stat(dir->path_key, &st) == 0 &&
        -: 6540:            st.st_mtime > dir->mtime))) {
        -: 6541:
        -: 6542:        /* reset date stamp to show most recent re-process */
        -: 6543:        dir->mtime = st.st_mtime;
        -: 6544:
        -: 6545:        /* make sure directory can still be opened */
        -: 6546:        dir->dirstream = opendir(dir->path_key);
        -: 6547:
        -: 6548:        if (dir->dirstream)
        -: 6549:          rehash = 1;
        -: 6550:        else
        -: 6551:          return 0; /* couldn't re-read - fail */
        -: 6552:      } else
        -: 6553:#endif
        -: 6554:    /* The directory has been all read in.  */
    35466: 6555:      return 0;
        -: 6556:    }
        -: 6557:
    #####: 6558:  while ((d = readdir (dir->dirstream)) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 6559:    {
        -: 6560:      /* Enter the file in the hash table.  */
    #####: 6561:      register unsigned int newhash = 0;
        -: 6562:      unsigned int len;
        -: 6563:      register unsigned int i;
        -: 6564:
    #####: 6565:      if (!REAL_DIR_ENTRY (d))
branch  0 never executed
branch  1 never executed
    #####: 6566:	continue;
        -: 6567:
    #####: 6568:      len = NAMLEN (d);
    #####: 6569:      for (i = 0; i < len; ++i)
branch  0 never executed
branch  1 never executed
    #####: 6570:	HASHI (newhash, d->d_name[i]);
    #####: 6571:      newhash %= DIRFILE_BUCKETS;
        -: 6572:#ifdef WINDOWS32
        -: 6573:      /*
        -: 6574:       * If re-reading a directory, check that this file isn't already
        -: 6575:       * in the cache.
        -: 6576:       */
        -: 6577:      if (rehash) {
        -: 6578:        for (df = dir->files[newhash]; df != 0; df = df->next)
        -: 6579:          if (streq(df->name, d->d_name))
        -: 6580:            break;
        -: 6581:      } else
        -: 6582:        df = 0;
        -: 6583:
        -: 6584:      /*
        -: 6585:       * If re-reading a directory, don't cache files that have
        -: 6586:       * already been discovered.
        -: 6587:       */
        -: 6588:      if (!df) {
        -: 6589:#endif
        -: 6590:
    #####: 6591:      df = (struct dirfile *) xmalloc (sizeof (struct dirfile));
call    0 never executed
    #####: 6592:      df->next = dir->files[newhash];
    #####: 6593:      dir->files[newhash] = df;
    #####: 6594:      df->name = savestring (d->d_name, len);
call    0 never executed
    #####: 6595:      df->impossible = 0;
        -: 6596:#ifdef WINDOWS32
        -: 6597:      }
        -: 6598:#endif
        -: 6599:      /* Check if the name matches the one we're searching for.  */
    #####: 6600:      if (filename != 0
branch  0 never executed
branch  1 never executed
    #####: 6601:	  && newhash == hash && strieq (d->d_name, filename))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
        -: 6602:	{
    #####: 6603:	  return 1;
        -: 6604:	}
        -: 6605:    }
        -: 6606:
        -: 6607:  /* If the directory has been completely read in,
        -: 6608:     close the stream and reset the pointer to nil.  */
    #####: 6609:  if (d == 0)
branch  0 never executed
branch  1 never executed
        -: 6610:    {
    #####: 6611:      --open_directories;
    #####: 6612:      closedir (dir->dirstream);
call    0 never executed
    #####: 6613:      dir->dirstream = 0;
        -: 6614:    }
    #####: 6615:  return 0;
        -: 6616:}
        -: 6617:
        -: 6618:/* Return 1 if the name FILENAME in directory DIRNAME
        -: 6619:   is entered in the dir hash table.
        -: 6620:   FILENAME must contain no slashes.  */
        -: 6621:
        -: 6622:int
function dir_file_exists_p called 109482 returned 100% blocks executed 100%
   109482: 6623:dir_file_exists_p (dirname, filename)
        -: 6624:     register char *dirname;
        -: 6625:     register char *filename;
        -: 6626:{
   109482: 6627:  return dir_contents_file_exists_p (find_directory (dirname)->contents,
call    0 returned 109482
call    1 returned 109482
        -: 6628:				     filename);
        -: 6629:}
        -: 6630:
        -: 6631:/* Return 1 if the file named NAME exists.  */
        -: 6632:
        -: 6633:int
function file_exists_p called 107169 returned 100% blocks executed 58%
   107169: 6634:file_exists_p (name)
        -: 6635:     register char *name;
        -: 6636:{
        -: 6637:  char *dirend;
        -: 6638:  char *dirname;
        -: 6639:  char *slash;
        -: 6640:
        -: 6641:#ifndef	NO_ARCHIVES
   107169: 6642:  if (ar_name (name))
call    0 returned 107169
branch  1 taken 0 (fallthrough)
branch  2 taken 107169
    #####: 6643:    return ar_member_date (name) != (time_t) -1;
call    0 never executed
        -: 6644:#endif
        -: 6645:
        -: 6646:#ifdef VMS
        -: 6647:  dirend = rindex (name, ']');
        -: 6648:  dirend++;
        -: 6649:  if (dirend == (char *)1)
        -: 6650:    return dir_file_exists_p ("[]", name);
        -: 6651:#else /* !VMS */
   107169: 6652:  dirend = rindex (name, '/');
        -: 6653:#if defined (WINDOWS32) || defined (__MSDOS__)
        -: 6654:  /* Forward and backslashes might be mixed.  We need the rightmost one.  */
        -: 6655:  {
        -: 6656:    char *bslash = rindex(name, '\\');
        -: 6657:    if (!dirend || bslash > dirend)
        -: 6658:      dirend = bslash;
        -: 6659:    /* The case of "d:file".  */
        -: 6660:    if (!dirend && name[0] && name[1] == ':')
        -: 6661:      dirend = name + 1;
        -: 6662:  }
        -: 6663:#endif /* WINDOWS32 || __MSDOS__ */
   107169: 6664:  if (dirend == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 107169
        -: 6665:#ifndef _AMIGA
    #####: 6666:    return dir_file_exists_p (".", name);
call    0 never executed
        -: 6667:#else /* !VMS && !AMIGA */
        -: 6668:    return dir_file_exists_p ("", name);
        -: 6669:#endif /* AMIGA */
        -: 6670:#endif /* VMS */
        -: 6671:
   107169: 6672:  slash = dirend;
   107169: 6673:  if (dirend == name)
branch  0 taken 0 (fallthrough)
branch  1 taken 107169
    #####: 6674:    dirname = "/";
        -: 6675:  else
        -: 6676:    {
        -: 6677:#if defined (WINDOWS32) || defined (__MSDOS__)
        -: 6678:  /* d:/ and d: are *very* different...  */
        -: 6679:      if (dirend < name + 3 && name[1] == ':' &&
        -: 6680:	  (*dirend == '/' || *dirend == '\\' || *dirend == ':'))
        -: 6681:	dirend++;
        -: 6682:#endif
   107169: 6683:      dirname = (char *) alloca (dirend - name + 1);
   107169: 6684:      bcopy (name, dirname, dirend - name);
   107169: 6685:      dirname[dirend - name] = '\0';
        -: 6686:    }
   107169: 6687:  return dir_file_exists_p (dirname, slash + 1);
call    0 returned 107169
        -: 6688:}
        -: 6689:
        -: 6690:/* Mark FILENAME as `impossible' for `file_impossible_p'.
        -: 6691:   This means an attempt has been made to search for FILENAME
        -: 6692:   as an intermediate file, and it has failed.  */
        -: 6693:
        -: 6694:void
function file_impossible called 13107 returned 100% blocks executed 90%
    13107: 6695:file_impossible (filename)
        -: 6696:     register char *filename;
        -: 6697:{
        -: 6698:  char *dirend;
    13107: 6699:  register char *p = filename;
        -: 6700:  register unsigned int hash;
        -: 6701:  register struct directory *dir;
        -: 6702:  register struct dirfile *new;
        -: 6703:
        -: 6704:#ifdef VMS
        -: 6705:  dirend = rindex (p, ']');
        -: 6706:  dirend++;
        -: 6707:  if (dirend == (char *)1)
        -: 6708:    dir = find_directory ("[]");
        -: 6709:#else
    13107: 6710:  dirend = rindex (p, '/');
        -: 6711:#if defined (WINDOWS32) || defined (__MSDOS__)
        -: 6712:  /* Forward and backslashes might be mixed.  We need the rightmost one.  */
        -: 6713:  {
        -: 6714:    char *bslash = rindex(p, '\\');
        -: 6715:    if (!dirend || bslash > dirend)
        -: 6716:      dirend = bslash;
        -: 6717:    /* The case of "d:file".  */
        -: 6718:    if (!dirend && p[0] && p[1] == ':')
        -: 6719:      dirend = p + 1;
        -: 6720:  }
        -: 6721:#endif /* WINDOWS32 or __MSDOS__ */
    13107: 6722:  if (dirend == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 13107
        -: 6723:#ifdef _AMIGA
        -: 6724:    dir = find_directory ("");
        -: 6725:#else /* !VMS && !AMIGA */
    #####: 6726:    dir = find_directory (".");
call    0 never executed
        -: 6727:#endif /* AMIGA */
        -: 6728:#endif /* VMS */
        -: 6729:  else
        -: 6730:    {
        -: 6731:      char *dirname;
    13107: 6732:      char *slash = dirend;
    13107: 6733:      if (dirend == p)
branch  0 taken 0 (fallthrough)
branch  1 taken 13107
    #####: 6734:	dirname = "/";
        -: 6735:      else
        -: 6736:	{
        -: 6737:#if defined (WINDOWS32) || defined (__MSDOS__)
        -: 6738:	  /* d:/ and d: are *very* different...  */
        -: 6739:	  if (dirend < p + 3 && p[1] == ':' &&
        -: 6740:	      (*dirend == '/' || *dirend == '\\' || *dirend == ':'))
        -: 6741:	    dirend++;
        -: 6742:#endif
    13107: 6743:	  dirname = (char *) alloca (dirend - p + 1);
    13107: 6744:	  bcopy (p, dirname, dirend - p);
    13107: 6745:	  dirname[dirend - p] = '\0';
        -: 6746:	}
    13107: 6747:      dir = find_directory (dirname);
call    0 returned 13107
    13107: 6748:      filename = p = slash + 1;
        -: 6749:    }
        -: 6750:
   189768: 6751:  for (hash = 0; *p != '\0'; ++p)
branch  0 taken 176661
branch  1 taken 13107 (fallthrough)
   176661: 6752:    HASHI (hash, *p);
    13107: 6753:  hash %= DIRFILE_BUCKETS;
        -: 6754:
    13107: 6755:  if (dir->contents == 0)
branch  0 taken 771 (fallthrough)
branch  1 taken 12336
        -: 6756:    {
        -: 6757:      /* The directory could not be stat'd.  We allocate a contents
        -: 6758:	 structure for it, but leave it out of the contents hash table.  */
      771: 6759:      dir->contents = (struct directory_contents *)
      771: 6760:	xmalloc (sizeof (struct directory_contents));
call    0 returned 771
        -: 6761:#ifdef WINDOWS32
        -: 6762:      dir->contents->path_key = NULL;
        -: 6763:      dir->contents->mtime = 0;
        -: 6764:#else  /* WINDOWS32 */
        -: 6765:#ifdef VMS
        -: 6766:      dir->contents->dev = 0;
        -: 6767:      dir->contents->ino[0] = dir->contents->ino[1] =
        -: 6768:	dir->contents->ino[2] = 0;
        -: 6769:#else
      771: 6770:      dir->contents->dev = int_to_dev_t(0);
call    0 returned 771
      771: 6771:      dir->contents->ino = int_to_ino_t(0);
call    0 returned 771
        -: 6772:      /*      dir->contents->dev = dir->contents->ino = 0; */
        -: 6773:#endif
        -: 6774:#endif /* WINDOWS32 */
      771: 6775:      dir->contents->files = 0;
      771: 6776:      dir->contents->dirstream = 0;
        -: 6777:    }
        -: 6778:
    13107: 6779:  if (dir->contents->files == 0)
branch  0 taken 771 (fallthrough)
branch  1 taken 12336
        -: 6780:    {
        -: 6781:      /* The directory was not opened; we must allocate the hash buckets.  */
     1542: 6782:      dir->contents->files = (struct dirfile **)
      771: 6783:	xmalloc (sizeof (struct dirfile) * DIRFILE_BUCKETS);
call    0 returned 771
      771: 6784:      bzero ((char *) dir->contents->files,
        -: 6785:	     sizeof (struct dirfile) * DIRFILE_BUCKETS);
        -: 6786:    }
        -: 6787:
        -: 6788:  /* Make a new entry and put it in the table.  */
        -: 6789:
    13107: 6790:  new = (struct dirfile *) xmalloc (sizeof (struct dirfile));
call    0 returned 13107
    13107: 6791:  new->next = dir->contents->files[hash];
    13107: 6792:  dir->contents->files[hash] = new;
    13107: 6793:  new->name = xstrdup (filename);
call    0 returned 13107
    13107: 6794:  new->impossible = 1;
    13107: 6795:}
        -: 6796:
        -: 6797:/* Return nonzero if FILENAME has been marked impossible.  */
        -: 6798:
        -: 6799:int
function file_impossible_p called 119505 returned 100% blocks executed 88%
   119505: 6800:file_impossible_p (filename)
        -: 6801:     char *filename;
        -: 6802:{
        -: 6803:  char *dirend;
   119505: 6804:  register char *p = filename;
        -: 6805:  register unsigned int hash;
        -: 6806:  register struct directory_contents *dir;
        -: 6807:  register struct dirfile *next;
        -: 6808:
        -: 6809:#ifdef VMS
        -: 6810:  dirend = rindex (filename, ']');
        -: 6811:  if (dirend == 0)
        -: 6812:    dir = find_directory ("[]")->contents;
        -: 6813:#else
   119505: 6814:  dirend = rindex (filename, '/');
        -: 6815:#if defined (WINDOWS32) || defined (__MSDOS__)
        -: 6816:  /* Forward and backslashes might be mixed.  We need the rightmost one.  */
        -: 6817:  {
        -: 6818:    char *bslash = rindex(filename, '\\');
        -: 6819:    if (!dirend || bslash > dirend)
        -: 6820:      dirend = bslash;
        -: 6821:    /* The case of "d:file".  */
        -: 6822:    if (!dirend && filename[0] && filename[1] == ':')
        -: 6823:      dirend = filename + 1;
        -: 6824:  }
        -: 6825:#endif /* WINDOWS32 || __MSDOS__ */
   119505: 6826:  if (dirend == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 119505
        -: 6827:#ifdef _AMIGA
        -: 6828:    dir = find_directory ("")->contents;
        -: 6829:#else /* !VMS && !AMIGA */
    #####: 6830:    dir = find_directory (".")->contents;
call    0 never executed
        -: 6831:#endif /* AMIGA */
        -: 6832:#endif /* VMS */
        -: 6833:  else
        -: 6834:    {
        -: 6835:      char *dirname;
   119505: 6836:      char *slash = dirend;
   119505: 6837:      if (dirend == filename)
branch  0 taken 0 (fallthrough)
branch  1 taken 119505
    #####: 6838:	dirname = "/";
        -: 6839:      else
        -: 6840:	{
        -: 6841:#if defined (WINDOWS32) || defined (__MSDOS__)
        -: 6842:	  /* d:/ and d: are *very* different...  */
        -: 6843:	  if (dirend < filename + 3 && filename[1] == ':' &&
        -: 6844:	      (*dirend == '/' || *dirend == '\\' || *dirend == ':'))
        -: 6845:	    dirend++;
        -: 6846:#endif
   119505: 6847:	  dirname = (char *) alloca (dirend - filename + 1);
   119505: 6848:	  bcopy (p, dirname, dirend - p);
   119505: 6849:	  dirname[dirend - p] = '\0';
        -: 6850:	}
   119505: 6851:      dir = find_directory (dirname)->contents;
call    0 returned 119505
   119505: 6852:      p = filename = slash + 1;
        -: 6853:    }
        -: 6854:
   119505: 6855:  if (dir == 0 || dir->files == 0)
branch  0 taken 47802 (fallthrough)
branch  1 taken 71703
branch  2 taken 0 (fallthrough)
branch  3 taken 47802
        -: 6856:    /* There are no files entered for this directory.  */
    71703: 6857:    return 0;
        -: 6858:
        -: 6859:#ifdef __MSDOS__
        -: 6860:  p = filename = dosify (p);
        -: 6861:#endif
        -: 6862:#ifdef HAVE_CASE_INSENSITIVE_FS
        -: 6863:  p = filename = downcase (p);
        -: 6864:#endif
        -: 6865:#ifdef VMS
        -: 6866:  p = filename = vmsify (p, 1);
        -: 6867:#endif
        -: 6868:
   736677: 6869:  for (hash = 0; *p != '\0'; ++p)
branch  0 taken 688875
branch  1 taken 47802 (fallthrough)
   688875: 6870:    HASH (hash, *p);
    47802: 6871:  hash %= DIRFILE_BUCKETS;
        -: 6872:
    50117: 6873:  for (next = dir->files[hash]; next != 0; next = next->next)
branch  0 taken 14651
branch  1 taken 35466 (fallthrough)
    14651: 6874:    if (strieq (filename, next->name))
branch  0 taken 14651 (fallthrough)
branch  1 taken 0
branch  2 taken 13110 (fallthrough)
branch  3 taken 1541
branch  4 taken 13110 (fallthrough)
branch  5 taken 0
branch  6 taken 12336 (fallthrough)
branch  7 taken 774
    12336: 6875:      return next->impossible;
        -: 6876:
    35466: 6877:  return 0;
        -: 6878:}
        -: 6879:
        -: 6880:/* Return the already allocated name in the
        -: 6881:   directory hash table that matches DIR.  */
        -: 6882:
        -: 6883:char *
function dir_name called 0 returned 0% blocks executed 0%
    #####: 6884:dir_name (dir)
        -: 6885:     char *dir;
        -: 6886:{
    #####: 6887:  return find_directory (dir)->name;
call    0 never executed
        -: 6888:}
        -: 6889:
        -: 6890:/* Print the data base of directories.  */
        -: 6891:
        -: 6892:void
function print_dir_data_base called 384 returned 100% blocks executed 83%
      384: 6893:print_dir_data_base ()
        -: 6894:{
        -: 6895:  register unsigned int i, dirs, files, impossible;
        -: 6896:  register struct directory *dir;
        -: 6897:
      384: 6898:  puts (_("\n# Directories\n"));
call    0 returned 384
        -: 6899:
      384: 6900:  dirs = files = impossible = 0;
    76800: 6901:  for (i = 0; i < DIRECTORY_BUCKETS; ++i)
branch  0 taken 76416
branch  1 taken 384 (fallthrough)
    78336: 6902:    for (dir = table_of_directories[i]; dir != 0; dir = dir->next)
branch  0 taken 1920
branch  1 taken 76416 (fallthrough)
        -: 6903:      {
     1920: 6904:	++dirs;
     1920: 6905:	if (dir->contents == 0)
branch  0 taken 1536 (fallthrough)
branch  1 taken 384
     1536: 6906:	  printf (_("# %s: could not be stat'd.\n"), dir->name);
call    0 returned 1536
      384: 6907:	else if (dir->contents->files == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 384
        -: 6908:#ifdef WINDOWS32
        -: 6909:          printf (_("# %s (key %s, mtime %d): could not be opened.\n"),
        -: 6910:                  dir->name, dir->contents->path_key,dir->contents->mtime);
        -: 6911:#else  /* WINDOWS32 */
        -: 6912:#ifdef VMS
        -: 6913:	  printf (_("# %s (device %d, inode [%d,%d,%d]): could not be opened.\n"),
        -: 6914:		  dir->name, dir->contents->dev,
        -: 6915:		  dir->contents->ino[0], dir->contents->ino[1],
        -: 6916:		  dir->contents->ino[2]);
        -: 6917:#else
    #####: 6918:	  printf (_("# %s (device %ld, inode %ld): could not be opened.\n"),
    #####: 6919:		  dir->name, (long int) dir->contents->dev,
call    0 never executed
    #####: 6920:		  ino_t_to_long_int(dir->contents->ino));
call    0 never executed
        -: 6921:	  /*		  (long int) dir->contents->ino); */
        -: 6922:#endif
        -: 6923:#endif /* WINDOWS32 */
        -: 6924:	else
        -: 6925:	  {
      384: 6926:	    register unsigned int f = 0, im = 0;
        -: 6927:	    register unsigned int j;
        -: 6928:	    register struct dirfile *df;
    41472: 6929:	    for (j = 0; j < DIRFILE_BUCKETS; ++j)
branch  0 taken 41088
branch  1 taken 384 (fallthrough)
    47616: 6930:	      for (df = dir->contents->files[j]; df != 0; df = df->next)
branch  0 taken 6528
branch  1 taken 41088 (fallthrough)
     6528: 6931:		if (df->impossible)
branch  0 taken 6528 (fallthrough)
branch  1 taken 0
     6528: 6932:		  ++im;
        -: 6933:		else
    #####: 6934:		  ++f;
        -: 6935:#ifdef WINDOWS32
        -: 6936:            printf (_("# %s (key %s, mtime %d): "),
        -: 6937:                    dir->name, dir->contents->path_key, dir->contents->mtime);
        -: 6938:#else  /* WINDOWS32 */
        -: 6939:#ifdef VMS
        -: 6940:	    printf (_("# %s (device %d, inode [%d,%d,%d]): "),
        -: 6941:		    dir->name, dir->contents->dev,
        -: 6942:			dir->contents->ino[0], dir->contents->ino[1],
        -: 6943:			dir->contents->ino[2]);
        -: 6944:#else
      384: 6945:	    printf (_("# %s (device %ld, inode %ld): "),
call    0 returned 384
        -: 6946:		    dir->name,
      384: 6947:                    (long)dev_t_to_int(dir->contents->dev), ino_t_to_long(dir->contents->ino));
call    0 returned 384
call    1 returned 384
        -: 6948:	    /*                    (long)dir->contents->dev, (long)dir->contents->ino); */
        -: 6949:#endif
        -: 6950:#endif /* WINDOWS32 */
      384: 6951:	    if (f == 0)
branch  0 taken 384 (fallthrough)
branch  1 taken 0
      384: 6952:	      fputs (_("No"), stdout);
call    0 returned 384
        -: 6953:	    else
    #####: 6954:	      printf ("%u", f);
call    0 never executed
      384: 6955:	    fputs (_(" files, "), stdout);
call    0 returned 384
      384: 6956:	    if (im == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 384
    #####: 6957:	      fputs (_("no"), stdout);
call    0 never executed
        -: 6958:	    else
      384: 6959:	      printf ("%u", im);
call    0 returned 384
      384: 6960:	    fputs (_(" impossibilities"), stdout);
call    0 returned 384
      384: 6961:	    if (dir->contents->dirstream == 0)
branch  0 taken 384 (fallthrough)
branch  1 taken 0
      384: 6962:	      puts (".");
call    0 returned 384
        -: 6963:	    else
    #####: 6964:	      puts (_(" so far."));
call    0 never executed
      384: 6965:	    files += f;
      384: 6966:	    impossible += im;
        -: 6967:	  }
        -: 6968:      }
        -: 6969:
      384: 6970:  fputs ("\n# ", stdout);
call    0 returned 384
      384: 6971:  if (files == 0)
branch  0 taken 384 (fallthrough)
branch  1 taken 0
      384: 6972:    fputs (_("No"), stdout);
call    0 returned 384
        -: 6973:  else
    #####: 6974:    printf ("%u", files);
call    0 never executed
      384: 6975:  fputs (_(" files, "), stdout);
call    0 returned 384
      384: 6976:  if (impossible == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 384
    #####: 6977:    fputs (_("no"), stdout);
call    0 never executed
        -: 6978:  else
      384: 6979:    printf ("%u", impossible);
call    0 returned 384
      384: 6980:  printf (_(" impossibilities in %u directories.\n"), dirs);
call    0 returned 384
      384: 6981:}
        -: 6982:
        -: 6983:/* Hooks for globbing.  */
        -: 6984:
        -: 6985:#include <glob.h>
        -: 6986:#undef stderr
        -: 6987:#define stderr stdout
        -: 6988:
        -: 6989:/* Structure describing state of iterating through a directory hash table.  */
        -: 6990:
        -: 6991:struct dirstream
        -: 6992:  {
        -: 6993:    struct directory_contents *contents; /* The directory being read.  */
        -: 6994:
        -: 6995:    unsigned int bucket;	/* Current hash bucket.  */
        -: 6996:    struct dirfile *elt;	/* Current elt in bucket.  */
        -: 6997:  };
        -: 6998:
        -: 6999:/* Forward declarations.  */
        -: 7000:static __ptr_t open_dirstream PARAMS ((const char *));
        -: 7001:static struct dirent *read_dirstream PARAMS ((__ptr_t));
        -: 7002:
        -: 7003:static __ptr_t
function open_dirstream called 0 returned 0% blocks executed 0%
    #####: 7004:open_dirstream (directory)
        -: 7005:     const char *directory;
        -: 7006:{
        -: 7007:  struct dirstream *new;
    #####: 7008:  struct directory *dir = find_directory ((char *)directory);
call    0 never executed
        -: 7009:
    #####: 7010:  if (dir->contents == 0 || dir->contents->files == 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 7011:    /* DIR->contents is nil if the directory could not be stat'd.
        -: 7012:       DIR->contents->files is nil if it could not be opened.  */
    #####: 7013:    return 0;
        -: 7014:
        -: 7015:  /* Read all the contents of the directory now.  There is no benefit
        -: 7016:     in being lazy, since glob will want to see every file anyway.  */
        -: 7017:
    #####: 7018:  (void) dir_contents_file_exists_p (dir->contents, (char *) 0);
call    0 never executed
        -: 7019:
    #####: 7020:  new = (struct dirstream *) xmalloc (sizeof (struct dirstream));
call    0 never executed
    #####: 7021:  new->contents = dir->contents;
    #####: 7022:  new->bucket = 0;
    #####: 7023:  new->elt = new->contents->files[0];
        -: 7024:
    #####: 7025:  return (__ptr_t) new;
        -: 7026:}
        -: 7027:
        -: 7028:static struct dirent *
function read_dirstream called 0 returned 0% blocks executed 0%
    #####: 7029:read_dirstream (stream)
        -: 7030:     __ptr_t stream;
        -: 7031:{
    #####: 7032:  struct dirstream *const ds = (struct dirstream *) stream;
        -: 7033:  register struct dirfile *df;
        -: 7034:  static char *buf;
        -: 7035:  static unsigned int bufsz;
        -: 7036:
    #####: 7037:  while (ds->bucket < DIRFILE_BUCKETS)
branch  0 never executed
branch  1 never executed
        -: 7038:    {
    #####: 7039:      while ((df = ds->elt) != 0)
branch  0 never executed
branch  1 never executed
        -: 7040:	{
    #####: 7041:	  ds->elt = df->next;
    #####: 7042:	  if (!df->impossible)
branch  0 never executed
branch  1 never executed
        -: 7043:	    {
        -: 7044:	      /* The glob interface wants a `struct dirent',
        -: 7045:		 so mock one up.  */
        -: 7046:	      struct dirent *d;
    #####: 7047:	      unsigned int len = strlen (df->name) + 1;
    #####: 7048:	      if (sizeof *d - sizeof d->d_name + len > bufsz)
branch  0 never executed
branch  1 never executed
        -: 7049:		{
    #####: 7050:		  if (buf != 0)
branch  0 never executed
branch  1 never executed
    #####: 7051:		    free (buf);
    #####: 7052:		  bufsz *= 2;
    #####: 7053:		  if (sizeof *d - sizeof d->d_name + len > bufsz)
branch  0 never executed
branch  1 never executed
    #####: 7054:		    bufsz = sizeof *d - sizeof d->d_name + len;
    #####: 7055:		  buf = xmalloc (bufsz);
call    0 never executed
        -: 7056:		}
    #####: 7057:	      d = (struct dirent *) buf;
    #####: 7058:	      FAKE_DIR_ENTRY (d);
        -: 7059:#ifdef _DIRENT_HAVE_D_NAMLEN
        -: 7060:	      d->d_namlen = len - 1;
        -: 7061:#endif
    #####: 7062:	      memcpy (d->d_name, df->name, len);
    #####: 7063:	      return d;
        -: 7064:	    }
        -: 7065:	}
    #####: 7066:      if (++ds->bucket == DIRFILE_BUCKETS)
branch  0 never executed
branch  1 never executed
    #####: 7067:	break;
    #####: 7068:      ds->elt = ds->contents->files[ds->bucket];
        -: 7069:    }
        -: 7070:
    #####: 7071:  return 0;
        -: 7072:}
        -: 7073:
        -: 7074:static void
function ansi_free called 0 returned 0% blocks executed 0%
    #####: 7075:ansi_free(p)
        -: 7076:  void *p;
        -: 7077:{
    #####: 7078:    if (p)
branch  0 never executed
branch  1 never executed
    #####: 7079:      free(p);
    #####: 7080:}
        -: 7081:
        -: 7082:void
function dir_setup_glob called 7710 returned 100% blocks executed 100%
     7710: 7083:dir_setup_glob (gl)
        -: 7084:     glob_t *gl;
        -: 7085:{
        -: 7086:#ifndef VMS
        -: 7087:  extern int stat ();
        -: 7088:#endif
        -: 7089:
        -: 7090:  /* Bogus sunos4 compiler complains (!) about & before functions.  */
     7710: 7091:  gl->gl_opendir = open_dirstream;
     7710: 7092:  gl->gl_readdir = read_dirstream;
     7710: 7093:  gl->gl_closedir = ansi_free;
     7710: 7094:  gl->gl_stat = stat;
        -: 7095:  /* We don't bother setting gl_lstat, since glob never calls it.
        -: 7096:     The slot is only there for compatibility with 4.4 BSD.  */
     7710: 7097:}
        -: 7098:
        -: 7099:
        -: 7100:
        -: 7101:/*************************************************************
        -: 7102:  ============================================================
        -: 7103:  ************************************************************
        -: 7104:  ============================================================
        -: 7105:  ************************************************************
        -: 7106:                         file.c
        -: 7107:  ************************************************************
        -: 7108:  ============================================================
        -: 7109:  ************************************************************
        -: 7110:  ============================================================
        -: 7111:  *************************************************************/
        -: 7112:
        -: 7113:/* Target file hash table management for GNU Make.
        -: 7114:Copyright (C) 1988,89,90,91,92,93,94,95,96,97 Free Software Foundation, Inc.
        -: 7115:This file is part of GNU Make.
        -: 7116:
        -: 7117:GNU Make is free software; you can redistribute it and/or modify
        -: 7118:it under the terms of the GNU General Public License as published by
        -: 7119:the Free Software Foundation; either version 2, or (at your option)
        -: 7120:any later version.
        -: 7121:
        -: 7122:GNU Make is distributed in the hope that it will be useful,
        -: 7123:but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 7124:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 7125:GNU General Public License for more details.
        -: 7126:
        -: 7127:You should have received a copy of the GNU General Public License
        -: 7128:along with GNU Make; see the file COPYING.  If not, write to
        -: 7129:the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
        -: 7130:Boston, MA 02111-1307, USA.  */
        -: 7131:
        -: 7132:#include <assert.h>
        -: 7133:
        -: 7134:/* #include "make.h"  <- modification by J.Ruthruff, 7/27 */
        -: 7135:/* #include "dep.h"  <- modification by J.Ruthruff, 7/27 */
        -: 7136:/* #include "filedef.h"  <- modification by J.Ruthruff, 7/27 */
        -: 7137:#include "job.h"
        -: 7138:/* #include "commands.h"  <- modification by J.Ruthruff, 7/27 */
        -: 7139:/* #include "variable.h"  <- modification by J.Ruthruff, 7/27 */
        -: 7140:#undef stderr
        -: 7141:#define stderr stdout
        -: 7142:
        -: 7143:
        -: 7144:/* Hash table of files the makefile knows how to make.  */
        -: 7145:
        -: 7146:#ifndef	FILE_BUCKETS
        -: 7147:#define FILE_BUCKETS	1007
        -: 7148:#endif
        -: 7149:static struct file *files[FILE_BUCKETS];
        -: 7150:
        -: 7151:/* Number of files with the `intermediate' flag set.  */
        -: 7152:
        -: 7153:unsigned int num_intermediates = 0;
        -: 7154:
        -: 7155:/* Current value for pruning the scan of the goal chain (toggle 0/1).  */
        -: 7156:
        -: 7157:unsigned int considered = 0;
        -: 7158:
        -: 7159:/* Access the hash table of all file records.
        -: 7160:   lookup_file  given a name, return the struct file * for that name,
        -: 7161:           or nil if there is none.
        -: 7162:   enter_file   similar, but create one if there is none.  */
        -: 7163:
        -: 7164:struct file *
function lookup_file called 903612 returned 100% blocks executed 75%
   903612: 7165:lookup_file (name)
        -: 7166:     char *name;
        -: 7167:{
        -: 7168:  register struct file *f;
        -: 7169:  register char *n;
        -: 7170:  register unsigned int hashval;
        -: 7171:#ifdef VMS
        -: 7172:  register char *lname, *ln;
        -: 7173:#endif
        -: 7174:
   903612: 7175:  if (*name == '\0')
branch  0 taken 0 (fallthrough)
branch  1 taken 903612
    #####: 7176:    abort ();
call    0 never executed
        -: 7177:
        -: 7178:  /* This is also done in parse_file_seq, so this is redundant
        -: 7179:     for names read from makefiles.  It is here for names passed
        -: 7180:     on the command line.  */
        -: 7181:#ifdef VMS
        -: 7182:  lname = (char *)malloc(strlen(name) + 1);
        -: 7183:  for (n=name, ln=lname; *n != '\0'; ++n, ++ln)
        -: 7184:    *ln = isupper(*n) ? tolower(*n) : *n;
        -: 7185:  *ln = '\0';
        -: 7186:  name = lname;
        -: 7187:
        -: 7188:  while (name[0] == '[' && name[1] == ']' && name[2] != '\0')
        -: 7189:      name += 2;
        -: 7190:#endif
  903612*: 7191:  while (name[0] == '.' && name[1] == '/' && name[2] != '\0')
branch  0 taken 795672 (fallthrough)
branch  1 taken 107940
branch  2 taken 0 (fallthrough)
branch  3 taken 795672
branch  4 never executed
branch  5 never executed
        -: 7192:    {
    #####: 7193:      name += 2;
    #####: 7194:      while (*name == '/')
branch  0 never executed
branch  1 never executed
        -: 7195:	/* Skip following slashes: ".//foo" is "foo", not "/foo".  */
    #####: 7196:	++name;
        -: 7197:    }
        -: 7198:
   903612: 7199:  if (*name == '\0')
branch  0 taken 0 (fallthrough)
branch  1 taken 903612
        -: 7200:    /* It was all slashes after a dot.  */
        -: 7201:#ifdef VMS
        -: 7202:    name = "[]";
        -: 7203:#else
        -: 7204:#ifdef _AMIGA
        -: 7205:    name = "";
        -: 7206:#else
    #####: 7207:    name = "./";
        -: 7208:#endif /* AMIGA */
        -: 7209:#endif /* VMS */
        -: 7210:
   903612: 7211:  hashval = 0;
 11419350: 7212:  for (n = name; *n != '\0'; ++n)
branch  0 taken 10515738
branch  1 taken 903612 (fallthrough)
 10515738: 7213:    HASHI (hashval, *n);
   903612: 7214:  hashval %= FILE_BUCKETS;
        -: 7215:
   973009: 7216:  for (f = files[hashval]; f != 0; f = f->next)
branch  0 taken 104092
branch  1 taken 868917 (fallthrough)
        -: 7217:    {
   104092: 7218:      if (strieq (f->hname, name))
branch  0 taken 104092 (fallthrough)
branch  1 taken 0
branch  2 taken 98685 (fallthrough)
branch  3 taken 5407
branch  4 taken 98685 (fallthrough)
branch  5 taken 0
branch  6 taken 34695 (fallthrough)
branch  7 taken 63990
        -: 7219:	{
        -: 7220:#ifdef VMS
        -: 7221:	  free (lname);
        -: 7222:#endif
    34695: 7223:	  return f;
        -: 7224:	}
        -: 7225:    }
        -: 7226:#ifdef VMS
        -: 7227:  free (lname);
        -: 7228:#endif
   868917: 7229:  return 0;
        -: 7230:}
        -: 7231:
        -: 7232:struct file *
function enter_file called 51657 returned 100% blocks executed 71%
    51657: 7233:enter_file (name)
        -: 7234:     char *name;
        -: 7235:{
        -: 7236:  register struct file *f, *new;
        -: 7237:  register char *n;
        -: 7238:  register unsigned int hashval;
        -: 7239:#ifdef VMS
        -: 7240:  char *lname, *ln;
        -: 7241:#endif
        -: 7242:
    51657: 7243:  if (*name == '\0')
branch  0 taken 0 (fallthrough)
branch  1 taken 51657
    #####: 7244:    abort ();
call    0 never executed
        -: 7245:
        -: 7246:#ifdef VMS
        -: 7247:  lname = (char *)malloc (strlen (name) + 1);
        -: 7248:  for (n = name, ln = lname; *n != '\0'; ++n, ++ln)
        -: 7249:    {
        -: 7250:      if (isupper(*n))
        -: 7251:	*ln = tolower(*n);
        -: 7252:      else
        -: 7253:	*ln = *n;
        -: 7254:    }
        -: 7255:  *ln = 0;
        -: 7256:  name = lname;
        -: 7257:#endif
        -: 7258:
    51657: 7259:  hashval = 0;
   329994: 7260:  for (n = name; *n != '\0'; ++n)
branch  0 taken 278337
branch  1 taken 51657 (fallthrough)
   278337: 7261:    HASHI (hashval, *n);
    51657: 7262:  hashval %= FILE_BUCKETS;
        -: 7263:
    53970: 7264:  for (f = files[hashval]; f != 0; f = f->next)
branch  0 taken 2313
branch  1 taken 51657 (fallthrough)
     2313: 7265:    if (strieq (f->hname, name))
branch  0 taken 2313 (fallthrough)
branch  1 taken 0
branch  2 taken 2313 (fallthrough)
branch  3 taken 0
branch  4 taken 2313 (fallthrough)
branch  5 taken 0
branch  6 taken 2313 (fallthrough)
branch  7 taken 0
        -: 7266:      break;
        -: 7267:
   51657*: 7268:  if (f != 0 && !f->double_colon)
branch  0 taken 0 (fallthrough)
branch  1 taken 51657
branch  2 never executed
branch  3 never executed
        -: 7269:    {
        -: 7270:#ifdef VMS
        -: 7271:      free(lname);
        -: 7272:#endif
    #####: 7273:      return f;
        -: 7274:    }
        -: 7275:
    51657: 7276:  new = (struct file *) xmalloc (sizeof (struct file));
call    0 returned 51657
    51657: 7277:  bzero ((char *) new, sizeof (struct file));
    51657: 7278:  new->name = new->hname = name;
    51657: 7279:  new->update_status = -1;
        -: 7280:
    51657: 7281:  if (f == 0)
branch  0 taken 51657 (fallthrough)
branch  1 taken 0
        -: 7282:    {
        -: 7283:      /* This is a completely new file.  */
    51657: 7284:      new->next = files[hashval];
    51657: 7285:      files[hashval] = new;
        -: 7286:    }
        -: 7287:  else
        -: 7288:    {
        -: 7289:      /* There is already a double-colon entry for this file.  */
    #####: 7290:      new->double_colon = f;
    #####: 7291:      while (f->prev != 0)
branch  0 never executed
branch  1 never executed
    #####: 7292:	f = f->prev;
    #####: 7293:      f->prev = new;
        -: 7294:    }
        -: 7295:
    51657: 7296:  return new;
        -: 7297:}
        -: 7298:
        -: 7299:/* Rehash FILE to NAME.  This is not as simple as resetting
        -: 7300:   the `hname' member, since it must be put in a new hash bucket,
        -: 7301:   and possibly merged with an existing file called NAME.  */
        -: 7302:
        -: 7303:void
function rehash_file called 0 returned 0% blocks executed 0%
    #####: 7304:rehash_file (file, name)
        -: 7305:     register struct file *file;
        -: 7306:     char *name;
        -: 7307:{
    #####: 7308:  char *oldname = file->hname;
        -: 7309:  register unsigned int oldhash;
        -: 7310:  register char *n;
        -: 7311:
    #####: 7312:  while (file->renamed != 0)
branch  0 never executed
branch  1 never executed
    #####: 7313:    file = file->renamed;
        -: 7314:
        -: 7315:  /* Find the hash values of the old and new names.  */
        -: 7316:
    #####: 7317:  oldhash = 0;
    #####: 7318:  for (n = oldname; *n != '\0'; ++n)
branch  0 never executed
branch  1 never executed
    #####: 7319:    HASHI (oldhash, *n);
        -: 7320:
    #####: 7321:  file_hash_enter (file, name, oldhash, file->name);
call    0 never executed
    #####: 7322:}
        -: 7323:
        -: 7324:/* Rename FILE to NAME.  This is not as simple as resetting
        -: 7325:   the `name' member, since it must be put in a new hash bucket,
        -: 7326:   and possibly merged with an existing file called NAME.  */
        -: 7327:
        -: 7328:void
function rename_file called 0 returned 0% blocks executed 0%
    #####: 7329:rename_file (file, name)
        -: 7330:     register struct file *file;
        -: 7331:     char *name;
        -: 7332:{
    #####: 7333:  rehash_file(file, name);
call    0 never executed
    #####: 7334:  while (file)
branch  0 never executed
branch  1 never executed
        -: 7335:    {
    #####: 7336:      file->name = file->hname;
    #####: 7337:      file = file->prev;
        -: 7338:    }
    #####: 7339:}
        -: 7340:
        -: 7341:void
function file_hash_enter called 0 returned 0% blocks executed 0%
    #####: 7342:file_hash_enter (file, name, oldhash, oldname)
        -: 7343:     register struct file *file;
        -: 7344:     char *name;
        -: 7345:     unsigned int oldhash;
        -: 7346:     char *oldname;
        -: 7347:{
    #####: 7348:  unsigned int oldbucket = oldhash % FILE_BUCKETS;
        -: 7349:  register unsigned int newhash, newbucket;
        -: 7350:  struct file *oldfile;
        -: 7351:  register char *n;
        -: 7352:  register struct file *f;
        -: 7353:
    #####: 7354:  newhash = 0;
    #####: 7355:  for (n = name; *n != '\0'; ++n)
branch  0 never executed
branch  1 never executed
    #####: 7356:    HASHI (newhash, *n);
    #####: 7357:  newbucket = newhash % FILE_BUCKETS;
        -: 7358:
        -: 7359:  /* Look for an existing file under the new name.  */
        -: 7360:
    #####: 7361:  for (oldfile = files[newbucket]; oldfile != 0; oldfile = oldfile->next)
branch  0 never executed
branch  1 never executed
    #####: 7362:    if (strieq (oldfile->hname, name))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -: 7363:      break;
        -: 7364:
        -: 7365:  /* If the old file is the same as the new file, something's wrong.  */
    #####: 7366:  assert (oldfile != file);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 7367:
    #####: 7368:  if (oldhash != 0 && (newbucket != oldbucket || oldfile != 0))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 7369:    {
        -: 7370:      /* Remove FILE from its hash bucket.  */
        -: 7371:
    #####: 7372:      struct file *lastf = 0;
        -: 7373:
    #####: 7374:      for (f = files[oldbucket]; f != file; f = f->next)
branch  0 never executed
branch  1 never executed
    #####: 7375:	lastf = f;
        -: 7376:
    #####: 7377:      if (lastf == 0)
branch  0 never executed
branch  1 never executed
    #####: 7378:	files[oldbucket] = f->next;
        -: 7379:      else
    #####: 7380:	lastf->next = f->next;
        -: 7381:    }
        -: 7382:
        -: 7383:  /* Give FILE its new name.  */
        -: 7384:
    #####: 7385:  file->hname = name;
    #####: 7386:  for (f = file->double_colon; f != 0; f = f->prev)
branch  0 never executed
branch  1 never executed
    #####: 7387:    f->hname = name;
        -: 7388:
    #####: 7389:  if (oldfile == 0)
branch  0 never executed
branch  1 never executed
        -: 7390:    {
        -: 7391:      /* There is no existing file with the new name.  */
        -: 7392:
    #####: 7393:      if (newbucket != oldbucket)
branch  0 never executed
branch  1 never executed
        -: 7394:	{
        -: 7395:	  /* Put FILE in its new hash bucket.  */
    #####: 7396:	  file->next = files[newbucket];
    #####: 7397:	  files[newbucket] = file;
        -: 7398:	}
        -: 7399:    }
        -: 7400:  else
        -: 7401:    {
        -: 7402:      /* There is an existing file with the new name.
        -: 7403:	 We must merge FILE into the existing file.  */
        -: 7404:
        -: 7405:      register struct dep *d;
        -: 7406:
    #####: 7407:      if (file->cmds != 0)
branch  0 never executed
branch  1 never executed
        -: 7408:	{
    #####: 7409:	  if (oldfile->cmds == 0)
branch  0 never executed
branch  1 never executed
    #####: 7410:	    oldfile->cmds = file->cmds;
    #####: 7411:	  else if (file->cmds != oldfile->cmds)
branch  0 never executed
branch  1 never executed
        -: 7412:	    {
        -: 7413:	      /* We have two sets of commands.  We will go with the
        -: 7414:		 one given in the rule explicitly mentioning this name,
        -: 7415:		 but give a message to let the user know what's going on.  */
    #####: 7416:	      if (oldfile->cmds->fileinfo.filenm != 0)
branch  0 never executed
branch  1 never executed
    #####: 7417:                error (&file->cmds->fileinfo,
        -: 7418:                                _("Commands were specified for \
        -: 7419:file `%s' at %s:%lu,"),
    #####: 7420:                                oldname, oldfile->cmds->fileinfo.filenm,
    #####: 7421:                                oldfile->cmds->fileinfo.lineno);
call    0 never executed
        -: 7422:	      else
    #####: 7423:		error (&file->cmds->fileinfo,
call    0 never executed
        -: 7424:				_("Commands for file `%s' were found by \
        -: 7425:implicit rule search,"),
        -: 7426:				oldname);
    #####: 7427:	      error (&file->cmds->fileinfo,
call    0 never executed
        -: 7428:			      _("but `%s' is now considered the same file \
        -: 7429:as `%s'."),
        -: 7430:			      oldname, name);
    #####: 7431:	      error (&file->cmds->fileinfo,
call    0 never executed
        -: 7432:			      _("Commands for `%s' will be ignored \
        -: 7433:in favor of those for `%s'."),
        -: 7434:			      name, oldname);
        -: 7435:	    }
        -: 7436:	}
        -: 7437:
        -: 7438:      /* Merge the dependencies of the two files.  */
        -: 7439:
    #####: 7440:      d = oldfile->deps;
    #####: 7441:      if (d == 0)
branch  0 never executed
branch  1 never executed
    #####: 7442:	oldfile->deps = file->deps;
        -: 7443:      else
        -: 7444:	{
    #####: 7445:	  while (d->next != 0)
branch  0 never executed
branch  1 never executed
    #####: 7446:	    d = d->next;
    #####: 7447:	  d->next = file->deps;
        -: 7448:	}
        -: 7449:
    #####: 7450:      merge_variable_set_lists (&oldfile->variables, file->variables);
call    0 never executed
        -: 7451:
    #####: 7452:      if (oldfile->double_colon && file->is_target && !file->double_colon)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 7453:	fatal (NILF, _("can't rename single-colon `%s' to double-colon `%s'"),
call    0 never executed
        -: 7454:	       oldname, name);
    #####: 7455:      if (!oldfile->double_colon  && file->double_colon)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 7456:	{
    #####: 7457:	  if (oldfile->is_target)
branch  0 never executed
branch  1 never executed
    #####: 7458:	    fatal (NILF, _("can't rename double-colon `%s' to single-colon `%s'"),
call    0 never executed
        -: 7459:		   oldname, name);
        -: 7460:	  else
    #####: 7461:	    oldfile->double_colon = file->double_colon;
        -: 7462:	}
        -: 7463:
    #####: 7464:      if (file->last_mtime > oldfile->last_mtime)
branch  0 never executed
branch  1 never executed
        -: 7465:	/* %%% Kludge so -W wins on a file that gets vpathized.  */
    #####: 7466:	oldfile->last_mtime = file->last_mtime;
        -: 7467:
    #####: 7468:      oldfile->mtime_before_update = file->mtime_before_update;
        -: 7469:
        -: 7470:#define MERGE(field) oldfile->field |= file->field
    #####: 7471:      MERGE (precious);
    #####: 7472:      MERGE (tried_implicit);
    #####: 7473:      MERGE (updating);
    #####: 7474:      MERGE (updated);
    #####: 7475:      MERGE (is_target);
    #####: 7476:      MERGE (cmd_target);
    #####: 7477:      MERGE (phony);
    #####: 7478:      MERGE (ignore_vpath);
        -: 7479:#undef MERGE
        -: 7480:
    #####: 7481:      file->renamed = oldfile;
        -: 7482:    }
    #####: 7483:}
        -: 7484:
        -: 7485:/* Remove all nonprecious intermediate files.
        -: 7486:   If SIG is nonzero, this was caused by a fatal signal,
        -: 7487:   meaning that a different message will be printed, and
        -: 7488:   the message will go to stderr rather than stdout.  */
        -: 7489:
        -: 7490:void
function remove_intermediates called 774 returned 100% blocks executed 29%
      774: 7491:remove_intermediates (sig)
        -: 7492:     int sig;
        -: 7493:{
        -: 7494:  register int i;
        -: 7495:  register struct file *f;
        -: 7496:  char doneany;
        -: 7497:
      774: 7498:  if (question_flag || touch_flag)
branch  0 taken 774 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 774
    #####: 7499:    return;
     774*: 7500:  if (sig && just_print_flag)
branch  0 taken 0 (fallthrough)
branch  1 taken 774
branch  2 never executed
branch  3 never executed
    #####: 7501:    return;
        -: 7502:
      774: 7503:  doneany = 0;
   780192: 7504:  for (i = 0; i < FILE_BUCKETS; ++i)
branch  0 taken 779418
branch  1 taken 774 (fallthrough)
   831075: 7505:    for (f = files[i]; f != 0; f = f->next)
branch  0 taken 51657
branch  1 taken 779418 (fallthrough)
   51657*: 7506:      if (f->intermediate && (f->dontcare || !f->precious)
branch  0 taken 0 (fallthrough)
branch  1 taken 51657
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 7507:	  && !f->secondary)
branch  0 never executed
branch  1 never executed
        -: 7508:	{
        -: 7509:	  int status;
    #####: 7510:	  if (f->update_status == -1)
branch  0 never executed
branch  1 never executed
        -: 7511:	    /* If nothing would have created this file yet,
        -: 7512:	       don't print an "rm" command for it.  */
    #####: 7513:            continue;
    #####: 7514: 	  else if (just_print_flag)
branch  0 never executed
branch  1 never executed
    #####: 7515:  	    status = 0;
        -: 7516:	  else
        -: 7517:	    {
    #####: 7518:	      status = unlink (f->name);
call    0 never executed
    #####: 7519:	      if (status < 0 && errno == ENOENT)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 7520:		continue;
        -: 7521:	    }
    #####: 7522:	  if (!f->dontcare)
branch  0 never executed
branch  1 never executed
        -: 7523:	    {
    #####: 7524:	      if (sig)
branch  0 never executed
branch  1 never executed
    #####: 7525:		error (NILF, _("*** Deleting intermediate file `%s'"), f->name);
call    0 never executed
    #####: 7526:	      else if (!silent_flag)
branch  0 never executed
branch  1 never executed
        -: 7527:		{
    #####: 7528:		  if (! doneany)
branch  0 never executed
branch  1 never executed
        -: 7529:		    {
    #####: 7530:		      fputs ("rm ", stdout);
call    0 never executed
    #####: 7531:		      doneany = 1;
        -: 7532:		    }
        -: 7533:		  else
    #####: 7534:		    putchar (' ');
call    0 never executed
    #####: 7535:		  fputs (f->name, stdout);
call    0 never executed
    #####: 7536:		  fflush (stdout);
call    0 never executed
        -: 7537:		}
    #####: 7538:	      if (status < 0)
branch  0 never executed
branch  1 never executed
    #####: 7539:		perror_with_name ("unlink: ", f->name);
call    0 never executed
        -: 7540:	    }
        -: 7541:	}
        -: 7542:
     774*: 7543:  if (doneany && !sig)
branch  0 taken 0 (fallthrough)
branch  1 taken 774
branch  2 never executed
branch  3 never executed
        -: 7544:    {
    #####: 7545:      putchar ('\n');
call    0 never executed
    #####: 7546:      fflush (stdout);
call    0 never executed
        -: 7547:    }
        -: 7548:}
        -: 7549:
        -: 7550:/* For each dependency of each file, make the `struct dep' point
        -: 7551:   at the appropriate `struct file' (which may have to be created).
        -: 7552:
        -: 7553:   Also mark the files depended on by .PRECIOUS, .PHONY, .SILENT,
        -: 7554:   and various other special targets.  */
        -: 7555:
        -: 7556:void
function snap_deps called 771 returned 100% blocks executed 39%
      771: 7557:snap_deps ()
        -: 7558:{
        -: 7559:  register struct file *f, *f2;
        -: 7560:  register struct dep *d;
        -: 7561:  register int i;
        -: 7562:
        -: 7563:  /* Enter each dependency name as a file.  */
   777168: 7564:  for (i = 0; i < FILE_BUCKETS; ++i)
branch  0 taken 776397
branch  1 taken 771 (fallthrough)
   821886: 7565:    for (f = files[i]; f != 0; f = f->next)
branch  0 taken 45489
branch  1 taken 776397 (fallthrough)
    90978: 7566:      for (f2 = f; f2 != 0; f2 = f2->prev)
branch  0 taken 45489
branch  1 taken 45489 (fallthrough)
    70161: 7567:	for (d = f2->deps; d != 0; d = d->next)
branch  0 taken 24672
branch  1 taken 45489 (fallthrough)
    24672: 7568:	  if (d->name != 0)
branch  0 taken 24672 (fallthrough)
branch  1 taken 0
        -: 7569:	    {
    24672: 7570:	      d->file = lookup_file (d->name);
call    0 returned 24672
    24672: 7571:	      if (d->file == 0)
branch  0 taken 14649 (fallthrough)
branch  1 taken 10023
    14649: 7572:		d->file = enter_file (d->name);
call    0 returned 14649
        -: 7573:	      else
    10023: 7574:		free (d->name);
    24672: 7575:	      d->name = 0;
        -: 7576:	    }
        -: 7577:
     771*: 7578:  for (f = lookup_file (".PRECIOUS"); f != 0; f = f->prev)
call    0 returned 771
branch  1 taken 0
branch  2 taken 771 (fallthrough)
    #####: 7579:    for (d = f->deps; d != 0; d = d->next)
branch  0 never executed
branch  1 never executed
    #####: 7580:      for (f2 = d->file; f2 != 0; f2 = f2->prev)
branch  0 never executed
branch  1 never executed
    #####: 7581:	f2->precious = 1;
        -: 7582:
     771*: 7583:  for (f = lookup_file (".PHONY"); f != 0; f = f->prev)
call    0 returned 771
branch  1 taken 0
branch  2 taken 771 (fallthrough)
    #####: 7584:    for (d = f->deps; d != 0; d = d->next)
branch  0 never executed
branch  1 never executed
    #####: 7585:      for (f2 = d->file; f2 != 0; f2 = f2->prev)
branch  0 never executed
branch  1 never executed
        -: 7586:	{
        -: 7587:	  /* Mark this file as phony and nonexistent.  */
    #####: 7588:	  f2->phony = 1;
    #####: 7589:	  f2->last_mtime = (FILE_TIMESTAMP) -1;
    #####: 7590:	  f2->mtime_before_update = (FILE_TIMESTAMP) -1;
        -: 7591:	}
        -: 7592:
     771*: 7593:  for (f = lookup_file (".INTERMEDIATE"); f != 0; f = f->prev)
call    0 returned 771
branch  1 taken 0
branch  2 taken 771 (fallthrough)
        -: 7594:    {
        -: 7595:      /* .INTERMEDIATE with deps listed
        -: 7596:	 marks those deps as intermediate files.  */
    #####: 7597:      for (d = f->deps; d != 0; d = d->next)
branch  0 never executed
branch  1 never executed
    #####: 7598:	for (f2 = d->file; f2 != 0; f2 = f2->prev)
branch  0 never executed
branch  1 never executed
    #####: 7599:	  f2->intermediate = 1;
        -: 7600:      /* .INTERMEDIATE with no deps does nothing.
        -: 7601:	 Marking all files as intermediates is useless
        -: 7602:	 since the goal targets would be deleted after they are built.  */
        -: 7603:    }
        -: 7604:
     771*: 7605:  for (f = lookup_file (".SECONDARY"); f != 0; f = f->prev)
call    0 returned 771
branch  1 taken 0
branch  2 taken 771 (fallthrough)
        -: 7606:    {
        -: 7607:      /* .SECONDARY with deps listed
        -: 7608:	 marks those deps as intermediate files
        -: 7609:	 in that they don't get rebuilt if not actually needed;
        -: 7610:	 but unlike real intermediate files,
        -: 7611:	 these are not deleted after make finishes.  */
    #####: 7612:      if (f->deps)
branch  0 never executed
branch  1 never executed
        -: 7613:	{
    #####: 7614:	  for (d = f->deps; d != 0; d = d->next)
branch  0 never executed
branch  1 never executed
    #####: 7615:	    for (f2 = d->file; f2 != 0; f2 = f2->prev)
branch  0 never executed
branch  1 never executed
    #####: 7616:	      f2->intermediate = f2->secondary = 1;
        -: 7617:	}
        -: 7618:      /* .SECONDARY with no deps listed marks *all* files that way.  */
        -: 7619:      else
        -: 7620:	{
        -: 7621:	  int i;
    #####: 7622:	  for (i = 0; i < FILE_BUCKETS; i++)
branch  0 never executed
branch  1 never executed
    #####: 7623:	    for (f2 = files[i]; f2; f2= f2->next)
branch  0 never executed
branch  1 never executed
    #####: 7624:	      f2->intermediate = f2->secondary = 1;
        -: 7625:	}
        -: 7626:    }
        -: 7627:
      771: 7628:  f = lookup_file (".EXPORT_ALL_VARIABLES");
call    0 returned 771
     771*: 7629:  if (f != 0 && f->is_target)
branch  0 taken 0 (fallthrough)
branch  1 taken 771
branch  2 never executed
branch  3 never executed
    #####: 7630:    export_all_variables = 1;
        -: 7631:
      771: 7632:  f = lookup_file (".IGNORE");
call    0 returned 771
     771*: 7633:  if (f != 0 && f->is_target)
branch  0 taken 0 (fallthrough)
branch  1 taken 771
branch  2 never executed
branch  3 never executed
        -: 7634:    {
    #####: 7635:      if (f->deps == 0)
branch  0 never executed
branch  1 never executed
    #####: 7636:	ignore_errors_flag = 1;
        -: 7637:      else
    #####: 7638:	for (d = f->deps; d != 0; d = d->next)
branch  0 never executed
branch  1 never executed
    #####: 7639:	  for (f2 = d->file; f2 != 0; f2 = f2->prev)
branch  0 never executed
branch  1 never executed
    #####: 7640:	    f2->command_flags |= COMMANDS_NOERROR;
        -: 7641:    }
        -: 7642:
      771: 7643:  f = lookup_file (".SILENT");
call    0 returned 771
     771*: 7644:  if (f != 0 && f->is_target)
branch  0 taken 0 (fallthrough)
branch  1 taken 771
branch  2 never executed
branch  3 never executed
        -: 7645:    {
    #####: 7646:      if (f->deps == 0)
branch  0 never executed
branch  1 never executed
    #####: 7647:	silent_flag = 1;
        -: 7648:      else
    #####: 7649:	for (d = f->deps; d != 0; d = d->next)
branch  0 never executed
branch  1 never executed
    #####: 7650:	  for (f2 = d->file; f2 != 0; f2 = f2->prev)
branch  0 never executed
branch  1 never executed
    #####: 7651:	    f2->command_flags |= COMMANDS_SILENT;
        -: 7652:    }
        -: 7653:
      771: 7654:  f = lookup_file (".POSIX");
call    0 returned 771
     771*: 7655:  if (f != 0 && f->is_target)
branch  0 taken 0 (fallthrough)
branch  1 taken 771
branch  2 never executed
branch  3 never executed
    #####: 7656:    posix_pedantic = 1;
      771: 7657:}
        -: 7658:
        -: 7659:/* Set the `command_state' member of FILE and all its `also_make's.  */
        -: 7660:
        -: 7661:void
function set_command_state called 0 returned 0% blocks executed 0%
    #####: 7662:set_command_state (file, state)
        -: 7663:     struct file *file;
        -: 7664:     int state;
        -: 7665:{
        -: 7666:  struct dep *d;
        -: 7667:
    #####: 7668:  file->command_state = state;
        -: 7669:
    #####: 7670:  for (d = file->also_make; d != 0; d = d->next)
branch  0 never executed
branch  1 never executed
    #####: 7671:    d->file->command_state = state;
    #####: 7672:}
        -: 7673:
        -: 7674:/* Get and print file timestamps.  */
        -: 7675:
        -: 7676:FILE_TIMESTAMP
function file_timestamp_now called 0 returned 0% blocks executed 0%
    #####: 7677:file_timestamp_now ()
        -: 7678:{
        -: 7679:#if HAVE_CLOCK_GETTIME && defined CLOCK_REALTIME
        -: 7680:  struct timespec timespec;
    #####: 7681:  if (clock_gettime (CLOCK_REALTIME, &timespec) == 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 7682:    return FILE_TIMESTAMP_FROM_S_AND_NS (timespec.tv_sec, timespec.tv_nsec);
        -: 7683:#endif
    #####: 7684:  return FILE_TIMESTAMP_FROM_S_AND_NS (time ((time_t *) 0), 0);
call    0 never executed
        -: 7685:}
        -: 7686:
        -: 7687:void
function file_timestamp_sprintf called 0 returned 0% blocks executed 0%
    #####: 7688:file_timestamp_sprintf (p, ts)
        -: 7689:     char *p;
        -: 7690:     FILE_TIMESTAMP ts;
        -: 7691:{
    #####: 7692:  time_t t = FILE_TIMESTAMP_S (ts);
    #####: 7693:  struct tm *tm = localtime (&t);
call    0 never executed
        -: 7694:
    #####: 7695:  if (tm)
branch  0 never executed
branch  1 never executed
    #####: 7696:    sprintf (p, "%04d-%02d-%02d %02d:%02d:%02d",
    #####: 7697:	     tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday,
        -: 7698:	     tm->tm_hour, tm->tm_min, tm->tm_sec);
    #####: 7699:  else if (t < 0)
branch  0 never executed
branch  1 never executed
    #####: 7700:    sprintf (p, "%ld", (long) t);
        -: 7701:  else
    #####: 7702:    sprintf (p, "%lu", (unsigned long) t);
    #####: 7703:  p += strlen (p);
        -: 7704:
        -: 7705:  /* Append nanoseconds as a fraction, but remove trailing zeros.
        -: 7706:     We don't know the actual timestamp resolution, since clock_getres
        -: 7707:     applies only to local times, whereas this timestamp might come
        -: 7708:     from a remote filesystem.  So removing trailing zeros is the
        -: 7709:     best guess that we can do.  */
    #####: 7710:  sprintf (p, ".%09ld", (long) FILE_TIMESTAMP_NS (ts));
    #####: 7711:  p += strlen (p) - 1;
    #####: 7712:  while (*p == '0')
branch  0 never executed
branch  1 never executed
    #####: 7713:    p--;
    #####: 7714:  p += *p != '.';
        -: 7715:
    #####: 7716:  *p = '\0';
    #####: 7717:}
        -: 7718:
        -: 7719:/* Print the data base of files.  */
        -: 7720:
        -: 7721:static void
function print_file called 25728 returned 100% blocks executed 52%
    25728: 7722:print_file (f)
        -: 7723:     struct file *f;
        -: 7724:{
        -: 7725:  register struct dep *d;
        -: 7726:
    25728: 7727:  putchar ('\n');
call    0 returned 25728
    25728: 7728:  if (!f->is_target)
branch  0 taken 25728 (fallthrough)
branch  1 taken 0
    25728: 7729:    puts (_("# Not a target:"));
call    0 returned 25728
   25728*: 7730:  printf ("%s:%s", f->name, f->double_colon ? ":" : "");
branch  0 taken 0 (fallthrough)
branch  1 taken 25728
call    2 returned 25728
        -: 7731:
    38016: 7732:  for (d = f->deps; d != 0; d = d->next)
branch  0 taken 12288
branch  1 taken 25728 (fallthrough)
   12288*: 7733:    printf (" %s", dep_name (d));
branch  0 taken 12288 (fallthrough)
branch  1 taken 0
call    2 returned 12288
    25728: 7734:  putchar ('\n');
call    0 returned 25728
        -: 7735:
    25728: 7736:  if (f->precious)
branch  0 taken 0 (fallthrough)
branch  1 taken 25728
    #####: 7737:    puts (_("#  Precious file (prerequisite of .PRECIOUS)."));
call    0 never executed
    25728: 7738:  if (f->phony)
branch  0 taken 0 (fallthrough)
branch  1 taken 25728
    #####: 7739:    puts (_("#  Phony target (prerequisite of .PHONY)."));
call    0 never executed
    25728: 7740:  if (f->cmd_target)
branch  0 taken 0 (fallthrough)
branch  1 taken 25728
    #####: 7741:    puts (_("#  Command-line target."));
call    0 never executed
    25728: 7742:  if (f->dontcare)
branch  0 taken 0 (fallthrough)
branch  1 taken 25728
    #####: 7743:    puts (_("#  A default or MAKEFILES makefile."));
call    0 never executed
    25728: 7744:  printf (_("#  Implicit rule search has%s been done.\n"),
call    0 returned 25728
    25728: 7745:	  f->tried_implicit ? "" : _(" not"));
branch  0 taken 384 (fallthrough)
branch  1 taken 25344
    25728: 7746:  if (f->stem != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 25728
    #####: 7747:    printf (_("#  Implicit/static pattern stem: `%s'\n"), f->stem);
call    0 never executed
    25728: 7748:  if (f->intermediate)
branch  0 taken 0 (fallthrough)
branch  1 taken 25728
    #####: 7749:    puts (_("#  File is an intermediate prerequisite."));
call    0 never executed
    25728: 7750:  if (f->also_make != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 25728
        -: 7751:    {
    #####: 7752:      fputs (_("#  Also makes:"), stdout);
call    0 never executed
    #####: 7753:      for (d = f->also_make; d != 0; d = d->next)
branch  0 never executed
branch  1 never executed
    #####: 7754:	printf (" %s", dep_name (d));
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 7755:      putchar ('\n');
call    0 never executed
        -: 7756:    }
    25728: 7757:  if (f->last_mtime == 0)
branch  0 taken 25344 (fallthrough)
branch  1 taken 384
    25344: 7758:    puts (_("#  Modification time never checked."));
call    0 returned 25344
      384: 7759:  else if (f->last_mtime == (FILE_TIMESTAMP) -1)
branch  0 taken 384 (fallthrough)
branch  1 taken 0
      384: 7760:    puts (_("#  File does not exist."));
call    0 returned 384
        -: 7761:  else
        -: 7762:    {
        -: 7763:      char buf[FILE_TIMESTAMP_PRINT_LEN_BOUND + 1];
    #####: 7764:      file_timestamp_sprintf (buf, f->last_mtime);
call    0 never executed
    #####: 7765:      printf("#  Last modified 00:00 Jan 01 2000\n");
call    0 never executed
        -: 7766:      /* printf (_("#  Last modified %s\n"), buf); */
        -: 7767:    }
    25728: 7768:  printf (_("#  File has%s been updated.\n"),
call    0 returned 25728
    25728: 7769:	  f->updated ? "" : _(" not"));
branch  0 taken 128 (fallthrough)
branch  1 taken 25600
    25728: 7770:  switch (f->command_state)
branch  0 taken 0
branch  1 taken 0
branch  2 taken 25728
branch  3 taken 0
        -: 7771:    {
    #####: 7772:    case cs_running:
    #####: 7773:      puts (_("#  Commands currently running (THIS IS A BUG)."));
call    0 never executed
    #####: 7774:      break;
    #####: 7775:    case cs_deps_running:
    #####: 7776:      puts (_("#  Dependencies commands running (THIS IS A BUG)."));
call    0 never executed
    #####: 7777:      break;
    25728: 7778:    case cs_not_started:
        -: 7779:    case cs_finished:
    25728: 7780:      switch (f->update_status)
branch  0 taken 25600
branch  1 taken 0
branch  2 taken 0
branch  3 taken 128
branch  4 taken 0
        -: 7781:	{
    25600: 7782:	case -1:
    25600: 7783:	  break;
    #####: 7784:	case 0:
    #####: 7785:	  puts (_("#  Successfully updated."));
call    0 never executed
    #####: 7786:	  break;
    #####: 7787:	case 1:
    #####: 7788:	  assert (question_flag);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 7789:	  puts (_("#  Needs to be updated (-q is set)."));
call    0 never executed
    #####: 7790:	  break;
      128: 7791:	case 2:
      128: 7792:	  puts (_("#  Failed to be updated."));
call    0 returned 128
      128: 7793:	  break;
    #####: 7794:	default:
    #####: 7795:	  puts (_("#  Invalid value in `update_status' member!"));
call    0 never executed
    #####: 7796:	  fflush (stdout);
call    0 never executed
    #####: 7797:	  fflush (stderr);
call    0 never executed
    #####: 7798:	  abort ();
call    0 never executed
        -: 7799:	}
    25728: 7800:      break;
    #####: 7801:    default:
    #####: 7802:      puts (_("#  Invalid value in `command_state' member!"));
call    0 never executed
    #####: 7803:      fflush (stdout);
call    0 never executed
    #####: 7804:      fflush (stderr);
call    0 never executed
    #####: 7805:      abort ();
call    0 never executed
        -: 7806:    }
        -: 7807:
    25728: 7808:  if (f->variables != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 25728
    #####: 7809:    print_file_variables (f);
call    0 never executed
        -: 7810:
    25728: 7811:  if (f->cmds != 0)
branch  0 taken 17280 (fallthrough)
branch  1 taken 8448
    17280: 7812:    print_commands (f->cmds);
call    0 returned 17280
    25728: 7813:}
        -: 7814:
        -: 7815:void
function print_file_data_base called 384 returned 100% blocks executed 94%
      384: 7816:print_file_data_base ()
        -: 7817:{
        -: 7818:  register unsigned int i, nfiles, per_bucket;
        -: 7819:  register struct file *file;
        -: 7820:
      384: 7821:  puts (_("\n# Files"));
call    0 returned 384
        -: 7822:
      384: 7823:  per_bucket = nfiles = 0;
   387072: 7824:  for (i = 0; i < FILE_BUCKETS; ++i)
branch  0 taken 386688
branch  1 taken 384 (fallthrough)
        -: 7825:    {
   386688: 7826:      register unsigned int this_bucket = 0;
        -: 7827:
   412416: 7828:      for (file = files[i]; file != 0; file = file->next)
branch  0 taken 25728
branch  1 taken 386688 (fallthrough)
        -: 7829:	{
        -: 7830:	  register struct file *f;
        -: 7831:
    25728: 7832:	  ++this_bucket;
        -: 7833:
    51456: 7834:	  for (f = file; f != 0; f = f->prev)
branch  0 taken 25728
branch  1 taken 25728 (fallthrough)
    25728: 7835:	    print_file (f);
call    0 returned 25728
        -: 7836:	}
        -: 7837:
   386688: 7838:      nfiles += this_bucket;
   386688: 7839:      if (this_bucket > per_bucket)
branch  0 taken 768 (fallthrough)
branch  1 taken 385920
      768: 7840:	per_bucket = this_bucket;
        -: 7841:    }
        -: 7842:
      384: 7843:  if (nfiles == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 384
    #####: 7844:    puts (_("\n# No files."));
call    0 never executed
        -: 7845:  else
        -: 7846:    {
      384: 7847:      printf (_("\n# %u files in %u hash buckets.\n"), nfiles, FILE_BUCKETS);
call    0 returned 384
        -: 7848:#ifndef	NO_FLOAT
      384: 7849:      printf (_("# average %.3f files per bucket, max %u files in one bucket.\n"),
      384: 7850:	      ((double) nfiles) / ((double) FILE_BUCKETS), per_bucket);
call    0 returned 384
        -: 7851:#endif
        -: 7852:    }
      384: 7853:}
        -: 7854:
        -: 7855:/* EOF */
        -: 7856:
        -: 7857:
        -: 7858:
        -: 7859:/*************************************************************
        -: 7860:  ============================================================
        -: 7861:  ************************************************************
        -: 7862:  ============================================================
        -: 7863:  ************************************************************
        -: 7864:                         misc.c
        -: 7865:  ************************************************************
        -: 7866:  ============================================================
        -: 7867:  ************************************************************
        -: 7868:  ============================================================
        -: 7869:  *************************************************************/
        -: 7870:
        -: 7871:/* Miscellaneous generic support functions for GNU Make.
        -: 7872:Copyright (C) 1988,89,90,91,92,93,94,95,97 Free Software Foundation, Inc.
        -: 7873:This file is part of GNU Make.
        -: 7874:
        -: 7875:GNU Make is free software; you can redistribute it and/or modify
        -: 7876:it under the terms of the GNU General Public License as published by
        -: 7877:the Free Software Foundation; either version 2, or (at your option)
        -: 7878:any later version.
        -: 7879:
        -: 7880:GNU Make is distributed in the hope that it will be useful,
        -: 7881:but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 7882:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 7883:GNU General Public License for more details.
        -: 7884:
        -: 7885:You should have received a copy of the GNU General Public License
        -: 7886:along with GNU Make; see the file COPYING.  If not, write to
        -: 7887:the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
        -: 7888:Boston, MA 02111-1307, USA.  */
        -: 7889:
        -: 7890:/* #include "make.h"  <- modification by J.Ruthruff, 7/27 */
        -: 7891:/* #include "dep.h"  <- modification by J.Ruthruff, 7/27 */
        -: 7892:#undef stderr
        -: 7893:#define stderr stdout
        -: 7894:
        -: 7895:
        -: 7896:/* Variadic functions.  We go through contortions to allow proper function
        -: 7897:   prototypes for both ANSI and pre-ANSI C compilers, and also for those
        -: 7898:   which support stdarg.h vs. varargs.h, and finally those which have
        -: 7899:   vfprintf(), etc. and those who have _doprnt... or nothing.
        -: 7900:
        -: 7901:   This fancy stuff all came from GNU fileutils, except for the VA_PRINTF and
        -: 7902:   VA_END macros used here since we have multiple print functions.  */
        -: 7903:
        -: 7904:#if HAVE_VPRINTF || HAVE_DOPRNT
        -: 7905:# define HAVE_STDVARARGS 1
        -: 7906:# if __STDC__
        -: 7907:#  include <stdarg.h>
        -: 7908:#undef stderr
        -: 7909:#define stderr stdout
        -: 7910:#  define VA_START(args, lastarg) va_start(args, lastarg)
        -: 7911:# else
        -: 7912:#  include <varargs.h>
        -: 7913:#undef stderr
        -: 7914:#define stderr stdout
        -: 7915:#  define VA_START(args, lastarg) va_start(args)
        -: 7916:# endif
        -: 7917:# if HAVE_VPRINTF
        -: 7918:#  define VA_PRINTF(fp, lastarg, args) vfprintf((fp), (lastarg), (args))
        -: 7919:# else
        -: 7920:#  define VA_PRINTF(fp, lastarg, args) _doprnt((lastarg), (args), (fp))
        -: 7921:# endif
        -: 7922:# define VA_END(args) va_end(args)
        -: 7923:#else
        -: 7924:/* # undef HAVE_STDVARARGS */
        -: 7925:# define va_alist a1, a2, a3, a4, a5, a6, a7, a8
        -: 7926:# define va_dcl char *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;
        -: 7927:# define VA_START(args, lastarg)
        -: 7928:# define VA_END(args)
        -: 7929:#endif
        -: 7930:
        -: 7931:
        -: 7932:/* Compare strings *S1 and *S2.
        -: 7933:   Return negative if the first is less, positive if it is greater,
        -: 7934:   zero if they are equal.  */
        -: 7935:
        -: 7936:int
function alpha_compare called 0 returned 0% blocks executed 0%
    #####: 7937:alpha_compare (v1, v2)
        -: 7938:     const void *v1, *v2;
        -: 7939:{
    #####: 7940:  const char *s1 = *((char **)v1);
    #####: 7941:  const char *s2 = *((char **)v2);
        -: 7942:
    #####: 7943:  if (*s1 != *s2)
branch  0 never executed
branch  1 never executed
    #####: 7944:    return *s1 - *s2;
    #####: 7945:  return strcmp (s1, s2);
        -: 7946:}
        -: 7947:
        -: 7948:/* Discard each backslash-newline combination from LINE.
        -: 7949:   Backslash-backslash-newline combinations become backslash-newlines.
        -: 7950:   This is done by copying the text at LINE into itself.  */
        -: 7951:
        -: 7952:void
function collapse_continuations called 0 returned 0% blocks executed 0%
    #####: 7953:collapse_continuations (line)
        -: 7954:     char *line;
        -: 7955:{
        -: 7956:  register char *in, *out, *p;
        -: 7957:  register int backslash;
        -: 7958:  register unsigned int bs_write;
        -: 7959:
    #####: 7960:  in = index (line, '\n');
    #####: 7961:  if (in == 0)
branch  0 never executed
branch  1 never executed
    #####: 7962:    return;
        -: 7963:
    #####: 7964:  out = in;
    #####: 7965:  while (out > line && out[-1] == '\\')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 7966:    --out;
        -: 7967:
    #####: 7968:  while (*in != '\0')
branch  0 never executed
branch  1 never executed
        -: 7969:    {
        -: 7970:      /* BS_WRITE gets the number of quoted backslashes at
        -: 7971:	 the end just before IN, and BACKSLASH gets nonzero
        -: 7972:	 if the next character is quoted.  */
    #####: 7973:      backslash = 0;
    #####: 7974:      bs_write = 0;
    #####: 7975:      for (p = in - 1; p >= line && *p == '\\'; --p)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 7976:	{
    #####: 7977:	  if (backslash)
branch  0 never executed
branch  1 never executed
    #####: 7978:	    ++bs_write;
    #####: 7979:	  backslash = !backslash;
        -: 7980:
        -: 7981:	  /* It should be impossible to go back this far without exiting,
        -: 7982:	     but if we do, we can't get the right answer.  */
    #####: 7983:	  if (in == out - 1)
branch  0 never executed
branch  1 never executed
    #####: 7984:	    abort ();
call    0 never executed
        -: 7985:	}
        -: 7986:
        -: 7987:      /* Output the appropriate number of backslashes.  */
    #####: 7988:      while (bs_write-- > 0)
branch  0 never executed
branch  1 never executed
    #####: 7989:	*out++ = '\\';
        -: 7990:
        -: 7991:      /* Skip the newline.  */
    #####: 7992:      ++in;
        -: 7993:
        -: 7994:      /* If the newline is quoted, discard following whitespace
        -: 7995:	 and any preceding whitespace; leave just one space.  */
    #####: 7996:      if (backslash)
branch  0 never executed
branch  1 never executed
        -: 7997:	{
    #####: 7998:	  in = next_token (in);
call    0 never executed
    #####: 7999:	  while (out > line && isblank (out[-1]))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 8000:	    --out;
    #####: 8001:	  *out++ = ' ';
        -: 8002:	}
        -: 8003:      else
        -: 8004:	/* If the newline isn't quoted, put it in the output.  */
    #####: 8005:	*out++ = '\n';
        -: 8006:
        -: 8007:      /* Now copy the following line to the output.
        -: 8008:	 Stop when we find backslashes followed by a newline.  */
    #####: 8009:      while (*in != '\0')
branch  0 never executed
branch  1 never executed
    #####: 8010:	if (*in == '\\')
branch  0 never executed
branch  1 never executed
        -: 8011:	  {
    #####: 8012:	    p = in + 1;
    #####: 8013:	    while (*p == '\\')
branch  0 never executed
branch  1 never executed
    #####: 8014:	      ++p;
    #####: 8015:	    if (*p == '\n')
branch  0 never executed
branch  1 never executed
        -: 8016:	      {
    #####: 8017:		in = p;
    #####: 8018:		break;
        -: 8019:	      }
    #####: 8020:	    while (in < p)
branch  0 never executed
branch  1 never executed
    #####: 8021:	      *out++ = *in++;
        -: 8022:	  }
        -: 8023:	else
    #####: 8024:	  *out++ = *in++;
        -: 8025:    }
        -: 8026:
    #####: 8027:  *out = '\0';
        -: 8028:}
        -: 8029:
        -: 8030:
        -: 8031:/* Remove comments from LINE.
        -: 8032:   This is done by copying the text at LINE onto itself.  */
        -: 8033:
        -: 8034:void
function remove_comments called 0 returned 0% blocks executed 0%
    #####: 8035:remove_comments (line)
        -: 8036:     char *line;
        -: 8037:{
        -: 8038:  char *comment;
        -: 8039:
    #####: 8040:  comment = find_char_unquote (line, "#", 0);
call    0 never executed
        -: 8041:
    #####: 8042:  if (comment != 0)
branch  0 never executed
branch  1 never executed
        -: 8043:    /* Cut off the line at the #.  */
    #####: 8044:    *comment = '\0';
    #####: 8045:}
        -: 8046:
        -: 8047:/* Print N spaces (used by DEBUGPR for target-depth).  */
        -: 8048:
        -: 8049:void
function print_spaces called 142976 returned 100% blocks executed 100%
   142976: 8050:print_spaces (n)
        -: 8051:     register unsigned int n;
        -: 8052:{
   667264: 8053:  while (n-- > 0)
branch  0 taken 524288
branch  1 taken 142976 (fallthrough)
   524288: 8054:    putchar (' ');
call    0 returned 524288
   142976: 8055:}
        -: 8056:
        -: 8057:
        -: 8058:/* Return a newly-allocated string whose contents
        -: 8059:   concatenate those of s1, s2, s3.  */
        -: 8060:
        -: 8061:char *
function concat called 764 returned 100% blocks executed 78%
      764: 8062:concat (s1, s2, s3)
        -: 8063:     register char *s1, *s2, *s3;
        -: 8064:{
        -: 8065:  register unsigned int len1, len2, len3;
        -: 8066:  register char *result;
        -: 8067:
     764*: 8068:  len1 = *s1 != '\0' ? strlen (s1) : 0;
branch  0 taken 764 (fallthrough)
branch  1 taken 0
     764*: 8069:  len2 = *s2 != '\0' ? strlen (s2) : 0;
branch  0 taken 764 (fallthrough)
branch  1 taken 0
     764*: 8070:  len3 = *s3 != '\0' ? strlen (s3) : 0;
branch  0 taken 0 (fallthrough)
branch  1 taken 764
        -: 8071:
      764: 8072:  result = (char *) xmalloc (len1 + len2 + len3 + 1);
call    0 returned 764
        -: 8073:
      764: 8074:  if (*s1 != '\0')
branch  0 taken 764 (fallthrough)
branch  1 taken 0
      764: 8075:    bcopy (s1, result, len1);
      764: 8076:  if (*s2 != '\0')
branch  0 taken 764 (fallthrough)
branch  1 taken 0
      764: 8077:    bcopy (s2, result + len1, len2);
      764: 8078:  if (*s3 != '\0')
branch  0 taken 0 (fallthrough)
branch  1 taken 764
    #####: 8079:    bcopy (s3, result + len1 + len2, len3);
      764: 8080:  *(result + len1 + len2 + len3) = '\0';
        -: 8081:
      764: 8082:  return result;
        -: 8083:}
        -: 8084:
        -: 8085:/* Print a message on stdout.  */
        -: 8086:
        -: 8087:void
        -: 8088:#if __STDC__ && HAVE_STDVARARGS
function message called 0 returned 0% blocks executed 0%
    #####: 8089:message (int prefix, const char *fmt, ...)
        -: 8090:#else
        -: 8091:message (prefix, fmt, va_alist)
        -: 8092:     int prefix;
        -: 8093:     const char *fmt;
        -: 8094:     va_dcl
        -: 8095:#endif
        -: 8096:{
        -: 8097:#if HAVE_STDVARARGS
        -: 8098:  va_list args;
        -: 8099:#endif
        -: 8100:
    #####: 8101:  log_working_directory (1);
call    0 never executed
        -: 8102:
    #####: 8103:  if (fmt != 0)
branch  0 never executed
branch  1 never executed
        -: 8104:    {
    #####: 8105:      if (prefix)
branch  0 never executed
branch  1 never executed
        -: 8106:	{
    #####: 8107:	  if (makelevel == 0)
branch  0 never executed
branch  1 never executed
    #####: 8108:	    printf ("%s: ", program);
call    0 never executed
        -: 8109:	  else
    #####: 8110:	    printf ("%s[%u]: ", program, makelevel);
call    0 never executed
        -: 8111:	}
    #####: 8112:      VA_START (args, fmt);
    #####: 8113:      VA_PRINTF (stdout, fmt, args);
call    0 never executed
    #####: 8114:      VA_END (args);
    #####: 8115:      putchar ('\n');
call    0 never executed
        -: 8116:    }
        -: 8117:
    #####: 8118:  fflush (stdout);
call    0 never executed
    #####: 8119:}
        -: 8120:
        -: 8121:/* Print an error message.  */
        -: 8122:
        -: 8123:void
        -: 8124:#if __STDC__ && HAVE_STDVARARGS
function error called 1283 returned 100% blocks executed 73%
     1283: 8125:error (const struct floc *flocp, const char *fmt, ...)
        -: 8126:#else
        -: 8127:error (flocp, fmt, va_alist)
        -: 8128:     const struct floc *flocp;
        -: 8129:     const char *fmt;
        -: 8130:     va_dcl
        -: 8131:#endif
        -: 8132:{
        -: 8133:#if HAVE_STDVARARGS
        -: 8134:  va_list args;
        -: 8135:#endif
        -: 8136:
     1283: 8137:  log_working_directory (1);
call    0 returned 1283
        -: 8138:
    1283*: 8139:  if (flocp && flocp->filenm)
branch  0 taken 0 (fallthrough)
branch  1 taken 1283
branch  2 never executed
branch  3 never executed
    #####: 8140:    fprintf (stderr, "%s:%lu: ", flocp->filenm, flocp->lineno);
call    0 never executed
     1283: 8141:  else if (makelevel == 0)
branch  0 taken 1283 (fallthrough)
branch  1 taken 0
     1283: 8142:    fprintf (stderr, "%s: ", program);
call    0 returned 1283
        -: 8143:  else
    #####: 8144:    fprintf (stderr, "%s[%u]: ", program, makelevel);
call    0 never executed
        -: 8145:
     1283: 8146:  VA_START(args, fmt);
     1283: 8147:  VA_PRINTF (stderr, fmt, args);
call    0 returned 1283
     1283: 8148:  VA_END (args);
        -: 8149:
     1283: 8150:  putc ('\n', stderr);
call    0 returned 1283
     1283: 8151:  fflush (stderr);
call    0 returned 1283
     1283: 8152:}
        -: 8153:
        -: 8154:/* Print an error message and exit.  */
        -: 8155:
        -: 8156:void
        -: 8157:#if __STDC__ && HAVE_STDVARARGS
function fatal called 773 returned 0% blocks executed 70%
      773: 8158:fatal (const struct floc *flocp, const char *fmt, ...)
        -: 8159:#else
        -: 8160:fatal (flocp, fmt, va_alist)
        -: 8161:     const struct floc *flocp;
        -: 8162:     const char *fmt;
        -: 8163:     va_dcl
        -: 8164:#endif
        -: 8165:{
        -: 8166:#if HAVE_STDVARARGS
        -: 8167:  va_list args;
        -: 8168:#endif
        -: 8169:
      773: 8170:  log_working_directory (1);
call    0 returned 773
        -: 8171:
     773*: 8172:  if (flocp && flocp->filenm)
branch  0 taken 0 (fallthrough)
branch  1 taken 773
branch  2 never executed
branch  3 never executed
    #####: 8173:    fprintf (stderr, "%s:%lu: *** ", flocp->filenm, flocp->lineno);
call    0 never executed
      773: 8174:  else if (makelevel == 0)
branch  0 taken 773 (fallthrough)
branch  1 taken 0
      773: 8175:    fprintf (stderr, "%s: *** ", program);
call    0 returned 773
        -: 8176:  else
    #####: 8177:    fprintf (stderr, "%s[%u]: *** ", program, makelevel);
call    0 never executed
        -: 8178:
      773: 8179:  VA_START(args, fmt);
      773: 8180:  VA_PRINTF (stderr, fmt, args);
call    0 returned 773
      773: 8181:  VA_END (args);
        -: 8182:
      773: 8183:  fputs (_(".  Stop.\n"), stderr);
call    0 returned 773
        -: 8184:
      773: 8185:  die (2);
        -: 8186:}
        -: 8187:
        -: 8188:#ifndef HAVE_STRERROR
        -: 8189:
        -: 8190:#undef	strerror
        -: 8191:
        -: 8192:char *
        -: 8193:strerror (errnum)
        -: 8194:     int errnum;
        -: 8195:{
        -: 8196:  extern int errno, sys_nerr;
        -: 8197:#ifndef __DECC
        -: 8198:  extern char *sys_errlist[];
        -: 8199:#endif
        -: 8200:  static char buf[] = "Unknown error 12345678901234567890";
        -: 8201:
        -: 8202:  if (errno < sys_nerr)
        -: 8203:    return sys_errlist[errnum];
        -: 8204:
        -: 8205:  sprintf (buf, _("Unknown error %d"), errnum);
        -: 8206:  return buf;
        -: 8207:}
        -: 8208:#endif
        -: 8209:
        -: 8210:/* Print an error message from errno.  */
        -: 8211:
        -: 8212:void
function perror_with_name called 771 returned 100% blocks executed 100%
      771: 8213:perror_with_name (str, name)
        -: 8214:     char *str, *name;
        -: 8215:{
      771: 8216:  error (NILF, "%s%s: %s", str, name, strerror (errno));
call    0 returned 771
call    1 returned 771
      771: 8217:}
        -: 8218:
        -: 8219:/* Print an error message from errno and exit.  */
        -: 8220:
        -: 8221:void
function pfatal_with_name called 2 returned 0% blocks executed 100%
        2: 8222:pfatal_with_name (name)
        -: 8223:     char *name;
        -: 8224:{
        2: 8225:  fatal (NILF, "%s: %s", name, strerror (errno));
call    0 returned 2
        -: 8226:
        -: 8227:  /* NOTREACHED */
        -: 8228:}
        -: 8229:
        -: 8230:/* Like malloc but get fatal error if memory is exhausted.  */
        -: 8231:/* Don't bother if we're using dmalloc; it provides these for us.  */
        -: 8232:
        -: 8233:#ifndef HAVE_DMALLOC_H
        -: 8234:
        -: 8235:#undef xmalloc
        -: 8236:#undef xrealloc
        -: 8237:#undef xstrdup
        -: 8238:
        -: 8239:char *
function xmalloc called 829119 returned 100% blocks executed 75%
   829119: 8240:xmalloc (size)
        -: 8241:     unsigned int size;
        -: 8242:{
   829119: 8243:  char *result = (char *) malloc (size);
   829119: 8244:  if (result == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 829119
    #####: 8245:    fatal (NILF, _("virtual memory exhausted"));
call    0 never executed
   829119: 8246:  return result;
        -: 8247:}
        -: 8248:
        -: 8249:
        -: 8250:char *
function xrealloc called 771 returned 100% blocks executed 71%
      771: 8251:xrealloc (ptr, size)
        -: 8252:     char *ptr;
        -: 8253:     unsigned int size;
        -: 8254:{
        -: 8255:  char *result;
        -: 8256:
        -: 8257:  /* Some older implementations of realloc() don't conform to ANSI.  */
     771*: 8258:  result = ptr ? realloc (ptr, size) : malloc (size);
branch  0 taken 0 (fallthrough)
branch  1 taken 771
      771: 8259:  if (result == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 771
    #####: 8260:    fatal (NILF, _("virtual memory exhausted"));
call    0 never executed
      771: 8261:  return result;
        -: 8262:}
        -: 8263:
        -: 8264:
        -: 8265:char *
function xstrdup called 160266 returned 100% blocks executed 75%
   160266: 8266:xstrdup (ptr)
        -: 8267:     const char *ptr;
        -: 8268:{
        -: 8269:  char *result;
        -: 8270:
        -: 8271:#ifdef HAVE_STRDUP
   160266: 8272:  result = strdup (ptr);
        -: 8273:#else
        -: 8274:  result = (char *) malloc (strlen (ptr) + 1);
        -: 8275:#endif
        -: 8276:
   160266: 8277:  if (result == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 160266
    #####: 8278:    fatal (NILF, _("virtual memory exhausted"));
call    0 never executed
        -: 8279:
        -: 8280:#ifdef HAVE_STRDUP
   160266: 8281:  return result;
        -: 8282:#else
        -: 8283:  return strcpy(result, ptr);
        -: 8284:#endif
        -: 8285:}
        -: 8286:
        -: 8287:#endif  /* HAVE_DMALLOC_H */
        -: 8288:
        -: 8289:char *
function savestring called 145102 returned 100% blocks executed 100%
   145102: 8290:savestring (str, length)
        -: 8291:     const char *str;
        -: 8292:     unsigned int length;
        -: 8293:{
   145102: 8294:  register char *out = (char *) xmalloc (length + 1);
call    0 returned 145102
   145102: 8295:  if (length > 0)
branch  0 taken 145102 (fallthrough)
branch  1 taken 0
   145102: 8296:    bcopy (str, out, length);
   145102: 8297:  out[length] = '\0';
   145102: 8298:  return out;
        -: 8299:}
        -: 8300:
        -: 8301:/* Search string BIG (length BLEN) for an occurrence of
        -: 8302:   string SMALL (length SLEN).  Return a pointer to the
        -: 8303:   beginning of the first occurrence, or return nil if none found.  */
        -: 8304:
        -: 8305:char *
function sindex called 0 returned 0% blocks executed 0%
    #####: 8306:sindex (big, blen, small, slen)
        -: 8307:     const char *big;
        -: 8308:     unsigned int blen;
        -: 8309:     const char *small;
        -: 8310:     unsigned int slen;
        -: 8311:{
    #####: 8312:  if (!blen)
branch  0 never executed
branch  1 never executed
    #####: 8313:    blen = strlen (big);
    #####: 8314:  if (!slen)
branch  0 never executed
branch  1 never executed
    #####: 8315:    slen = strlen (small);
        -: 8316:
    #####: 8317:  if (slen && blen >= slen)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 8318:    {
        -: 8319:      register unsigned int b;
        -: 8320:
        -: 8321:      /* Quit when there's not enough room left for the small string.  */
    #####: 8322:      --slen;
    #####: 8323:      blen -= slen;
        -: 8324:
    #####: 8325:      for (b = 0; b < blen; ++b, ++big)
branch  0 never executed
branch  1 never executed
    #####: 8326:        if (*big == *small && strneq (big + 1, small + 1, slen))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 8327:          return (char *)big;
        -: 8328:    }
        -: 8329:
    #####: 8330:  return 0;
        -: 8331:}
        -: 8332:
        -: 8333:/* Limited INDEX:
        -: 8334:   Search through the string STRING, which ends at LIMIT, for the character C.
        -: 8335:   Returns a pointer to the first occurrence, or nil if none is found.
        -: 8336:   Like INDEX except that the string searched ends where specified
        -: 8337:   instead of at the first null.  */
        -: 8338:
        -: 8339:char *
function lindex called 7716 returned 100% blocks executed 83%
     7716: 8340:lindex (s, limit, c)
        -: 8341:     register const char *s, *limit;
        -: 8342:     int c;
        -: 8343:{
    64824: 8344:  while (s < limit)
branch  0 taken 57108
branch  1 taken 7716 (fallthrough)
    57108: 8345:    if (*s++ == c)
branch  0 taken 0 (fallthrough)
branch  1 taken 57108
    #####: 8346:      return (char *)(s - 1);
        -: 8347:
     7716: 8348:  return 0;
        -: 8349:}
        -: 8350:
        -: 8351:/* Return the address of the first whitespace or null in the string S.  */
        -: 8352:
        -: 8353:char *
function end_of_token called 0 returned 0% blocks executed 0%
    #####: 8354:end_of_token (s)
        -: 8355:     char *s;
        -: 8356:{
    #####: 8357:  while (*s != '\0' && !isblank (*s))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 8358:    ++s;
    #####: 8359:  return s;
        -: 8360:}
        -: 8361:
        -: 8362:#ifdef WINDOWS32
        -: 8363:/*
        -: 8364: * Same as end_of_token, but take into account a stop character
        -: 8365: */
        -: 8366:char *
        -: 8367:end_of_token_w32 (s, stopchar)
        -: 8368:     char *s;
        -: 8369:     char stopchar;
        -: 8370:{
        -: 8371:  register char *p = s;
        -: 8372:  register int backslash = 0;
        -: 8373:
        -: 8374:  while (*p != '\0' && *p != stopchar && (backslash || !isblank (*p)))
        -: 8375:    {
        -: 8376:      if (*p++ == '\\')
        -: 8377:        {
        -: 8378:          backslash = !backslash;
        -: 8379:          while (*p == '\\')
        -: 8380:            {
        -: 8381:              backslash = !backslash;
        -: 8382:              ++p;
        -: 8383:            }
        -: 8384:        }
        -: 8385:      else
        -: 8386:        backslash = 0;
        -: 8387:    }
        -: 8388:
        -: 8389:  return p;
        -: 8390:}
        -: 8391:#endif
        -: 8392:
        -: 8393:/* Return the address of the first nonwhitespace or null in the string S.  */
        -: 8394:
        -: 8395:char *
function next_token called 95025 returned 100% blocks executed 100%
    95025: 8396:next_token (s)
        -: 8397:     char *s;
        -: 8398:{
    95025: 8399:  register char *p = s;
        -: 8400:
   122010: 8401:  while (isblank (*p))
branch  0 taken 26985
branch  1 taken 95025 (fallthrough)
    26985: 8402:    ++p;
    95025: 8403:  return p;
        -: 8404:}
        -: 8405:
        -: 8406:/* Find the next token in PTR; return the address of it, and store the
        -: 8407:   length of the token into *LENGTHPTR if LENGTHPTR is not nil.  */
        -: 8408:
        -: 8409:char *
function find_next_token called 771 returned 100% blocks executed 50%
      771: 8410:find_next_token (ptr, lengthptr)
        -: 8411:     char **ptr;
        -: 8412:     unsigned int *lengthptr;
        -: 8413:{
      771: 8414:  char *p = next_token (*ptr);
call    0 returned 771
        -: 8415:  char *end;
        -: 8416:
      771: 8417:  if (*p == '\0')
branch  0 taken 771 (fallthrough)
branch  1 taken 0
      771: 8418:    return 0;
        -: 8419:
    #####: 8420:  *ptr = end = end_of_token (p);
call    0 never executed
    #####: 8421:  if (lengthptr != 0)
branch  0 never executed
branch  1 never executed
    #####: 8422:    *lengthptr = end - p;
    #####: 8423:  return p;
        -: 8424:}
        -: 8425:
        -: 8426:/* Copy a chain of `struct dep', making a new chain
        -: 8427:   with the same contents as the old one.  */
        -: 8428:
        -: 8429:struct dep *
function copy_dep_chain called 771 returned 100% blocks executed 75%
      771: 8430:copy_dep_chain (d)
        -: 8431:     register struct dep *d;
        -: 8432:{
        -: 8433:  register struct dep *c;
      771: 8434:  struct dep *firstnew = 0;
      771: 8435:  struct dep *lastnew = 0;
        -: 8436:
     1542: 8437:  while (d != 0)
branch  0 taken 771
branch  1 taken 771 (fallthrough)
        -: 8438:    {
      771: 8439:      c = (struct dep *) xmalloc (sizeof (struct dep));
call    0 returned 771
      771: 8440:      bcopy ((char *) d, (char *) c, sizeof (struct dep));
      771: 8441:      if (c->name != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 771
    #####: 8442:	c->name = xstrdup (c->name);
call    0 never executed
      771: 8443:      c->next = 0;
      771: 8444:      if (firstnew == 0)
branch  0 taken 771 (fallthrough)
branch  1 taken 0
      771: 8445:	firstnew = lastnew = c;
        -: 8446:      else
    #####: 8447:	lastnew = lastnew->next = c;
        -: 8448:
      771: 8449:      d = d->next;
        -: 8450:    }
        -: 8451:
      771: 8452:  return firstnew;
        -: 8453:}
        -: 8454:
        -: 8455:#ifdef	iAPX286
        -: 8456:/* The losing compiler on this machine can't handle this macro.  */
        -: 8457:
        -: 8458:char *
        -: 8459:dep_name (dep)
        -: 8460:     struct dep *dep;
        -: 8461:{
        -: 8462:  return dep->name == 0 ? dep->file->name : dep->name;
        -: 8463:}
        -: 8464:#endif
        -: 8465:
        -: 8466:#ifdef	GETLOADAVG_PRIVILEGED
        -: 8467:
        -: 8468:#ifdef POSIX
        -: 8469:
        -: 8470:/* Hopefully if a system says it's POSIX.1 and has the setuid and setgid
        -: 8471:   functions, they work as POSIX.1 says.  Some systems (Alpha OSF/1 1.2,
        -: 8472:   for example) which claim to be POSIX.1 also have the BSD setreuid and
        -: 8473:   setregid functions, but they don't work as in BSD and only the POSIX.1
        -: 8474:   way works.  */
        -: 8475:
        -: 8476:#undef HAVE_SETREUID
        -: 8477:#undef HAVE_SETREGID
        -: 8478:
        -: 8479:#else	/* Not POSIX.  */
        -: 8480:
        -: 8481:/* Some POSIX.1 systems have the seteuid and setegid functions.  In a
        -: 8482:   POSIX-like system, they are the best thing to use.  However, some
        -: 8483:   non-POSIX systems have them too but they do not work in the POSIX style
        -: 8484:   and we must use setreuid and setregid instead.  */
        -: 8485:
        -: 8486:#undef HAVE_SETEUID
        -: 8487:#undef HAVE_SETEGID
        -: 8488:
        -: 8489:#endif	/* POSIX.  */
        -: 8490:
        -: 8491:#ifndef	HAVE_UNISTD_H
        -: 8492:extern int getuid (), getgid (), geteuid (), getegid ();
        -: 8493:extern int setuid (), setgid ();
        -: 8494:#ifdef HAVE_SETEUID
        -: 8495:extern int seteuid ();
        -: 8496:#else
        -: 8497:#ifdef	HAVE_SETREUID
        -: 8498:extern int setreuid ();
        -: 8499:#endif	/* Have setreuid.  */
        -: 8500:#endif	/* Have seteuid.  */
        -: 8501:#ifdef HAVE_SETEGID
        -: 8502:extern int setegid ();
        -: 8503:#else
        -: 8504:#ifdef	HAVE_SETREGID
        -: 8505:extern int setregid ();
        -: 8506:#endif	/* Have setregid.  */
        -: 8507:#endif	/* Have setegid.  */
        -: 8508:#endif	/* No <unistd.h>.  */
        -: 8509:
        -: 8510:/* Keep track of the user and group IDs for user- and make- access.  */
        -: 8511:static int user_uid = -1, user_gid = -1, make_uid = -1, make_gid = -1;
        -: 8512:#define	access_inited	(user_uid != -1)
        -: 8513:static enum { make, user } current_access;
        -: 8514:
        -: 8515:
        -: 8516:/* Under -d, write a message describing the current IDs.  */
        -: 8517:
        -: 8518:static void
        -: 8519:log_access (flavor)
        -: 8520:     char *flavor;
        -: 8521:{
        -: 8522:  if (! debug_flag)
        -: 8523:    return;
        -: 8524:
        -: 8525:  /* All the other debugging messages go to stdout,
        -: 8526:     but we write this one to stderr because it might be
        -: 8527:     run in a child fork whose stdout is piped.  */
        -: 8528:
        -: 8529:  fprintf (stderr, _("%s access: user %lu (real %lu), group %lu (real %lu)\n"),
        -: 8530:	   flavor, (unsigned long) geteuid (), (unsigned long) getuid (),
        -: 8531:           (unsigned long) getegid (), (unsigned long) getgid ());
        -: 8532:  fflush (stderr);
        -: 8533:}
        -: 8534:
        -: 8535:
        -: 8536:static void
        -: 8537:init_access ()
        -: 8538:{
        -: 8539:#ifndef VMS
        -: 8540:  user_uid = getuid ();
        -: 8541:  user_gid = getgid ();
        -: 8542:
        -: 8543:  make_uid = geteuid ();
        -: 8544:  make_gid = getegid ();
        -: 8545:
        -: 8546:  /* Do these ever fail?  */
        -: 8547:  if (user_uid == -1 || user_gid == -1 || make_uid == -1 || make_gid == -1)
        -: 8548:    pfatal_with_name ("get{e}[gu]id");
        -: 8549:
        -: 8550:  log_access (_("Initialized"));
        -: 8551:
        -: 8552:  current_access = make;
        -: 8553:#endif
        -: 8554:}
        -: 8555:
        -: 8556:#endif	/* GETLOADAVG_PRIVILEGED */
        -: 8557:
        -: 8558:/* Give the process appropriate permissions for access to
        -: 8559:   user data (i.e., to stat files, or to spawn a child process).  */
        -: 8560:void
function user_access called 774 returned 100% blocks executed 100%
      774: 8561:user_access ()
        -: 8562:{
        -: 8563:#ifdef	GETLOADAVG_PRIVILEGED
        -: 8564:
        -: 8565:  if (!access_inited)
        -: 8566:    init_access ();
        -: 8567:
        -: 8568:  if (current_access == user)
        -: 8569:    return;
        -: 8570:
        -: 8571:  /* We are in "make access" mode.  This means that the effective user and
        -: 8572:     group IDs are those of make (if it was installed setuid or setgid).
        -: 8573:     We now want to set the effective user and group IDs to the real IDs,
        -: 8574:     which are the IDs of the process that exec'd make.  */
        -: 8575:
        -: 8576:#ifdef	HAVE_SETEUID
        -: 8577:
        -: 8578:  /* Modern systems have the seteuid/setegid calls which set only the
        -: 8579:     effective IDs, which is ideal.  */
        -: 8580:
        -: 8581:  if (seteuid (user_uid) < 0)
        -: 8582:    pfatal_with_name ("user_access: seteuid");
        -: 8583:
        -: 8584:#else	/* Not HAVE_SETEUID.  */
        -: 8585:
        -: 8586:#ifndef	HAVE_SETREUID
        -: 8587:
        -: 8588:  /* System V has only the setuid/setgid calls to set user/group IDs.
        -: 8589:     There is an effective ID, which can be set by setuid/setgid.
        -: 8590:     It can be set (unless you are root) only to either what it already is
        -: 8591:     (returned by geteuid/getegid, now in make_uid/make_gid),
        -: 8592:     the real ID (return by getuid/getgid, now in user_uid/user_gid),
        -: 8593:     or the saved set ID (what the effective ID was before this set-ID
        -: 8594:     executable (make) was exec'd).  */
        -: 8595:
        -: 8596:  if (setuid (user_uid) < 0)
        -: 8597:    pfatal_with_name ("user_access: setuid");
        -: 8598:
        -: 8599:#else	/* HAVE_SETREUID.  */
        -: 8600:
        -: 8601:  /* In 4BSD, the setreuid/setregid calls set both the real and effective IDs.
        -: 8602:     They may be set to themselves or each other.  So you have two alternatives
        -: 8603:     at any one time.  If you use setuid/setgid, the effective will be set to
        -: 8604:     the real, leaving only one alternative.  Using setreuid/setregid, however,
        -: 8605:     you can toggle between your two alternatives by swapping the values in a
        -: 8606:     single setreuid or setregid call.  */
        -: 8607:
        -: 8608:  if (setreuid (make_uid, user_uid) < 0)
        -: 8609:    pfatal_with_name ("user_access: setreuid");
        -: 8610:
        -: 8611:#endif	/* Not HAVE_SETREUID.  */
        -: 8612:#endif	/* HAVE_SETEUID.  */
        -: 8613:
        -: 8614:#ifdef	HAVE_SETEGID
        -: 8615:  if (setegid (user_gid) < 0)
        -: 8616:    pfatal_with_name ("user_access: setegid");
        -: 8617:#else
        -: 8618:#ifndef	HAVE_SETREGID
        -: 8619:  if (setgid (user_gid) < 0)
        -: 8620:    pfatal_with_name ("user_access: setgid");
        -: 8621:#else
        -: 8622:  if (setregid (make_gid, user_gid) < 0)
        -: 8623:    pfatal_with_name ("user_access: setregid");
        -: 8624:#endif
        -: 8625:#endif
        -: 8626:
        -: 8627:  current_access = user;
        -: 8628:
        -: 8629:  log_access ("User");
        -: 8630:
        -: 8631:#endif	/* GETLOADAVG_PRIVILEGED */
      774: 8632:}
        -: 8633:
        -: 8634:/* Give the process appropriate permissions for access to
        -: 8635:   make data (i.e., the load average).  */
        -: 8636:void
function make_access called 0 returned 0% blocks executed 0%
    #####: 8637:make_access ()
        -: 8638:{
        -: 8639:#ifdef	GETLOADAVG_PRIVILEGED
        -: 8640:
        -: 8641:  if (!access_inited)
        -: 8642:    init_access ();
        -: 8643:
        -: 8644:  if (current_access == make)
        -: 8645:    return;
        -: 8646:
        -: 8647:  /* See comments in user_access, above.  */
        -: 8648:
        -: 8649:#ifdef	HAVE_SETEUID
        -: 8650:  if (seteuid (make_uid) < 0)
        -: 8651:    pfatal_with_name ("make_access: seteuid");
        -: 8652:#else
        -: 8653:#ifndef	HAVE_SETREUID
        -: 8654:  if (setuid (make_uid) < 0)
        -: 8655:    pfatal_with_name ("make_access: setuid");
        -: 8656:#else
        -: 8657:  if (setreuid (user_uid, make_uid) < 0)
        -: 8658:    pfatal_with_name ("make_access: setreuid");
        -: 8659:#endif
        -: 8660:#endif
        -: 8661:
        -: 8662:#ifdef	HAVE_SETEGID
        -: 8663:  if (setegid (make_gid) < 0)
        -: 8664:    pfatal_with_name ("make_access: setegid");
        -: 8665:#else
        -: 8666:#ifndef	HAVE_SETREGID
        -: 8667:  if (setgid (make_gid) < 0)
        -: 8668:    pfatal_with_name ("make_access: setgid");
        -: 8669:#else
        -: 8670:  if (setregid (user_gid, make_gid) < 0)
        -: 8671:    pfatal_with_name ("make_access: setregid");
        -: 8672:#endif
        -: 8673:#endif
        -: 8674:
        -: 8675:  current_access = make;
        -: 8676:
        -: 8677:  log_access ("Make");
        -: 8678:
        -: 8679:#endif	/* GETLOADAVG_PRIVILEGED */
    #####: 8680:}
        -: 8681:
        -: 8682:/* Give the process appropriate permissions for a child process.
        -: 8683:   This is like user_access, but you can't get back to make_access.  */
        -: 8684:void
function child_access called 0 returned 0% blocks executed 0%
    #####: 8685:child_access ()
        -: 8686:{
        -: 8687:#ifdef	GETLOADAVG_PRIVILEGED
        -: 8688:
        -: 8689:  if (!access_inited)
        -: 8690:    abort ();
        -: 8691:
        -: 8692:  /* Set both the real and effective UID and GID to the user's.
        -: 8693:     They cannot be changed back to make's.  */
        -: 8694:
        -: 8695:#ifndef	HAVE_SETREUID
        -: 8696:  if (setuid (user_uid) < 0)
        -: 8697:    pfatal_with_name ("child_access: setuid");
        -: 8698:#else
        -: 8699:  if (setreuid (user_uid, user_uid) < 0)
        -: 8700:    pfatal_with_name ("child_access: setreuid");
        -: 8701:#endif
        -: 8702:
        -: 8703:#ifndef	HAVE_SETREGID
        -: 8704:  if (setgid (user_gid) < 0)
        -: 8705:    pfatal_with_name ("child_access: setgid");
        -: 8706:#else
        -: 8707:  if (setregid (user_gid, user_gid) < 0)
        -: 8708:    pfatal_with_name ("child_access: setregid");
        -: 8709:#endif
        -: 8710:
        -: 8711:  log_access ("Child");
        -: 8712:
        -: 8713:#endif	/* GETLOADAVG_PRIVILEGED */
    #####: 8714:}
        -: 8715:
        -: 8716:#ifdef NEED_GET_PATH_MAX
        -: 8717:unsigned int
        -: 8718:get_path_max ()
        -: 8719:{
        -: 8720:  static unsigned int value;
        -: 8721:
        -: 8722:  if (value == 0)
        -: 8723:    {
        -: 8724:      long int x = pathconf ("/", _PC_PATH_MAX);
        -: 8725:      if (x > 0)
        -: 8726:	value = x;
        -: 8727:      else
        -: 8728:	return MAXPATHLEN;
        -: 8729:    }
        -: 8730:
        -: 8731:  return value;
        -: 8732:}
        -: 8733:#endif
        -: 8734:
        -: 8735:
        -: 8736:
        -: 8737:/*************************************************************
        -: 8738:  ============================================================
        -: 8739:  ************************************************************
        -: 8740:  ============================================================
        -: 8741:  ************************************************************
        -: 8742:                         read.c
        -: 8743:  ************************************************************
        -: 8744:  ============================================================
        -: 8745:  ************************************************************
        -: 8746:  ============================================================
        -: 8747:  *************************************************************/
        -: 8748:
        -: 8749:/* Reading and parsing of makefiles for GNU Make.
        -: 8750:Copyright (C) 1988,89,90,91,92,93,94,95,96,97 Free Software Foundation, Inc.
        -: 8751:This file is part of GNU Make.
        -: 8752:
        -: 8753:GNU Make is free software; you can redistribute it and/or modify
        -: 8754:it under the terms of the GNU General Public License as published by
        -: 8755:the Free Software Foundation; either version 2, or (at your option)
        -: 8756:any later version.
        -: 8757:
        -: 8758:GNU Make is distributed in the hope that it will be useful,
        -: 8759:but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 8760:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 8761:GNU General Public License for more details.
        -: 8762:
        -: 8763:You should have received a copy of the GNU General Public License
        -: 8764:along with GNU Make; see the file COPYING.  If not, write to
        -: 8765:the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
        -: 8766:Boston, MA 02111-1307, USA.  */
        -: 8767:
        -: 8768:/* #include "make.h"  <- modification by J.Ruthruff, 7/27 */
        -: 8769:
        -: 8770:#include <assert.h>
        -: 8771:
        -: 8772:#include <glob.h>
        -: 8773:
        -: 8774:/* #include "dep.h"  <- modification by J.Ruthruff, 7/27 */
        -: 8775:/* #include "filedef.h"  <- modification by J.Ruthruff, 7/27 */
        -: 8776:#include "job.h"
        -: 8777:/* #include "commands.h"  <- modification by J.Ruthruff, 7/27 */
        -: 8778:/* #include "variable.h"  <- modification by J.Ruthruff, 7/27 */
        -: 8779:/* #include "rule.h"  <- modification by J.Ruthruff, 7/27 */
        -: 8780:#undef stderr
        -: 8781:#define stderr stdout
        -: 8782:
        -: 8783:
        -: 8784:#ifndef WINDOWS32
        -: 8785:#ifndef _AMIGA
        -: 8786:#ifndef VMS
        -: 8787:#include <pwd.h>
        -: 8788:#undef stderr
        -: 8789:#define stderr stdout
        -: 8790:#else
        -: 8791:struct passwd *getpwnam PARAMS ((char *name));
        -: 8792:#endif
        -: 8793:#endif
        -: 8794:#endif /* !WINDOWS32 */
        -: 8795:
        -: 8796:/* A `struct linebuffer' is a structure which holds a line of text.
        -: 8797:   `readline' reads a line from a stream into a linebuffer
        -: 8798:   and works regardless of the length of the line.  */
        -: 8799:
        -: 8800:struct linebuffer
        -: 8801:  {
        -: 8802:    /* Note:  This is the number of bytes malloc'ed for `buffer'
        -: 8803:       It does not indicate `buffer's real length.
        -: 8804:       Instead, a null char indicates end-of-string.  */
        -: 8805:    unsigned int size;
        -: 8806:    char *buffer;
        -: 8807:  };
        -: 8808:
        -: 8809:#define initbuffer(lb) (lb)->buffer = (char *) xmalloc ((lb)->size = 200)
        -: 8810:#define freebuffer(lb) free ((lb)->buffer)
        -: 8811:
        -: 8812:
        -: 8813:/* Types of "words" that can be read in a makefile.  */
        -: 8814:enum make_word_type
        -: 8815:  {
        -: 8816:     w_bogus, w_eol, w_static, w_variable, w_colon, w_dcolon, w_semicolon,
        -: 8817:     w_comment, w_varassign
        -: 8818:  };
        -: 8819:
        -: 8820:
        -: 8821:/* A `struct conditionals' contains the information describing
        -: 8822:   all the active conditionals in a makefile.
        -: 8823:
        -: 8824:   The global variable `conditionals' contains the conditionals
        -: 8825:   information for the current makefile.  It is initialized from
        -: 8826:   the static structure `toplevel_conditionals' and is later changed
        -: 8827:   to new structures for included makefiles.  */
        -: 8828:
        -: 8829:struct conditionals
        -: 8830:  {
        -: 8831:    unsigned int if_cmds;	/* Depth of conditional nesting.  */
        -: 8832:    unsigned int allocated;	/* Elts allocated in following arrays.  */
        -: 8833:    char *ignoring;		/* Are we ignoring or interepreting?  */
        -: 8834:    char *seen_else;		/* Have we already seen an `else'?  */
        -: 8835:  };
        -: 8836:
        -: 8837:static struct conditionals toplevel_conditionals;
        -: 8838:static struct conditionals *conditionals = &toplevel_conditionals;
        -: 8839:
        -: 8840:
        -: 8841:/* Default directories to search for include files in  */
        -: 8842:
        -: 8843:static char *default_include_directories[] =
        -: 8844:  {
        -: 8845:#if defined(WINDOWS32) && !defined(INCLUDEDIR)
        -: 8846:/*
        -: 8847: * This completly up to the user when they install MSVC or other packages.
        -: 8848: * This is defined as a placeholder.
        -: 8849: */
        -: 8850:#define INCLUDEDIR "."
        -: 8851:#endif
        -: 8852:    INCLUDEDIR,
        -: 8853:#ifndef _AMIGA
        -: 8854:    "/usr/gnu/include",
        -: 8855:    "/usr/local/include",
        -: 8856:    "/usr/include",
        -: 8857:#endif
        -: 8858:    0
        -: 8859:  };
        -: 8860:
        -: 8861:/* List of directories to search for include files in  */
        -: 8862:
        -: 8863:static char **include_directories_to_search;
        -: 8864:
        -: 8865:/* Maximum length of an element of the above.  */
        -: 8866:
        -: 8867:static unsigned int max_incl_len;
        -: 8868:
        -: 8869:/* The filename and pointer to line number of the
        -: 8870:   makefile currently being read in.  */
        -: 8871:
        -: 8872:const struct floc *reading_file;
        -: 8873:
        -: 8874:/* The chain of makefiles read by read_makefile.  */
        -: 8875:
        -: 8876:static struct dep *read_makefiles = 0;
        -: 8877:
        -: 8878:static int read_makefile PARAMS ((char *filename, int flags));
        -: 8879:static unsigned long readline PARAMS ((struct linebuffer *linebuffer,
        -: 8880:                                       FILE *stream, const struct floc *flocp));
        -: 8881:static void do_define PARAMS ((char *name, unsigned int namelen,
        -: 8882:                               enum variable_origin origin, FILE *infile,
        -: 8883:                               struct floc *flocp));
        -: 8884:static int conditional_line PARAMS ((char *line, const struct floc *flocp));
        -: 8885:static void record_files PARAMS ((struct nameseq *filenames, char *pattern, char *pattern_percent,
        -: 8886:			struct dep *deps, unsigned int cmds_started, char *commands,
        -: 8887:			unsigned int commands_idx, int two_colon,
        -: 8888:			const struct floc *flocp, int set_default));
        -: 8889:static void record_target_var PARAMS ((struct nameseq *filenames, char *defn,
        -: 8890:                                       int two_colon,
        -: 8891:                                       enum variable_origin origin,
        -: 8892:                                       const struct floc *flocp));
        -: 8893:static enum make_word_type get_next_mword PARAMS ((char *buffer, char *delim,
        -: 8894:                        char **startp, unsigned int *length));
        -: 8895:
        -: 8896:/* Read in all the makefiles and return the chain of their names.  */
        -: 8897:
        -: 8898:struct dep *
function read_all_makefiles called 771 returned 100% blocks executed 39%
      771: 8899:read_all_makefiles (makefiles)
        -: 8900:     char **makefiles;
        -: 8901:{
      771: 8902:  unsigned int num_makefiles = 0;
        -: 8903:
      771: 8904:  if (debug_flag)
branch  0 taken 384 (fallthrough)
branch  1 taken 387
      384: 8905:    puts (_("Reading makefiles..."));
call    0 returned 384
        -: 8906:
        -: 8907:  /* If there's a non-null variable MAKEFILES, its value is a list of
        -: 8908:     files to read first thing.  But don't let it prevent reading the
        -: 8909:     default makefiles and don't let the default goal come from there.  */
        -: 8910:
        -: 8911:  {
        -: 8912:    char *value;
        -: 8913:    char *name, *p;
        -: 8914:    unsigned int length;
        -: 8915:
        -: 8916:    {
        -: 8917:      /* Turn off --warn-undefined-variables while we expand MAKEFILES.  */
      771: 8918:      int save = warn_undefined_variables_flag;
      771: 8919:      warn_undefined_variables_flag = 0;
        -: 8920:
      771: 8921:      value = allocated_variable_expand ("$(MAKEFILES)");
call    0 returned 771
        -: 8922:
      771: 8923:      warn_undefined_variables_flag = save;
        -: 8924:    }
        -: 8925:
        -: 8926:    /* Set NAME to the start of next token and LENGTH to its length.
        -: 8927:       MAKEFILES is updated for finding remaining tokens.  */
      771: 8928:    p = value;
        -: 8929:
      771: 8930:    while ((name = find_next_token (&p, &length)) != 0)
call    0 returned 771
branch  1 taken 0
branch  2 taken 771 (fallthrough)
        -: 8931:      {
    #####: 8932:        name = xstrdup (name);
call    0 never executed
    #####: 8933:	if (*p != '\0')
branch  0 never executed
branch  1 never executed
    #####: 8934:	  *p++ = '\0';
    #####: 8935:	if (read_makefile (name,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 8936:                           RM_NO_DEFAULT_GOAL|RM_INCLUDED|RM_DONTCARE) < 2)
    #####: 8937:          free (name);
        -: 8938:      }
        -: 8939:
      771: 8940:    free (value);
        -: 8941:  }
        -: 8942:
        -: 8943:  /* Read makefiles specified with -f switches.  */
        -: 8944:
      771: 8945:  if (makefiles != 0)
branch  0 taken 771 (fallthrough)
branch  1 taken 0
     1542: 8946:    while (*makefiles != 0)
branch  0 taken 771
branch  1 taken 771 (fallthrough)
        -: 8947:      {
      771: 8948:	struct dep *tail = read_makefiles;
        -: 8949:	register struct dep *d;
        -: 8950:
      771: 8951:	if (! read_makefile (*makefiles, 0))
call    0 returned 771
branch  1 taken 771 (fallthrough)
branch  2 taken 0
      771: 8952:	  perror_with_name ("", *makefiles);
call    0 returned 771
        -: 8953:
        -: 8954:	/* Find the right element of read_makefiles.  */
      771: 8955:	d = read_makefiles;
      771: 8956:	while (d->next != tail)
branch  0 taken 0
branch  1 taken 771 (fallthrough)
    #####: 8957:	  d = d->next;
        -: 8958:
        -: 8959:	/* Use the storage read_makefile allocates.  */
     771*: 8960:	*makefiles = dep_name (d);
branch  0 taken 771 (fallthrough)
branch  1 taken 0
      771: 8961:	++num_makefiles;
      771: 8962:	++makefiles;
        -: 8963:      }
        -: 8964:
        -: 8965:  /* If there were no -f switches, try the default names.  */
        -: 8966:
      771: 8967:  if (num_makefiles == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 771
        -: 8968:    {
        -: 8969:      static char *default_makefiles[] =
        -: 8970:#ifdef VMS
        -: 8971:	/* all lower case since readdir() (the vms version) 'lowercasifies' */
        -: 8972:	{ "makefile.vms", "gnumakefile.", "makefile.", 0 };
        -: 8973:#else
        -: 8974:#ifdef _AMIGA
        -: 8975:	{ "GNUmakefile", "Makefile", "SMakefile", 0 };
        -: 8976:#else /* !Amiga && !VMS */
        -: 8977:	{ "GNUmakefile", "makefile", "Makefile", 0 };
        -: 8978:#endif /* AMIGA */
        -: 8979:#endif /* VMS */
    #####: 8980:      register char **p = default_makefiles;
    #####: 8981:      while (*p != 0 && !file_exists_p (*p))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 8982:	++p;
        -: 8983:
    #####: 8984:      if (*p != 0)
branch  0 never executed
branch  1 never executed
        -: 8985:	{
    #####: 8986:	  if (! read_makefile (*p, 0))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 8987:	    perror_with_name ("", *p);
call    0 never executed
        -: 8988:	}
        -: 8989:      else
        -: 8990:	{
        -: 8991:	  /* No default makefile was found.  Add the default makefiles to the
        -: 8992:	     `read_makefiles' chain so they will be updated if possible.  */
    #####: 8993:	  struct dep *tail = read_makefiles;
        -: 8994:	  /* Add them to the tail, after any MAKEFILES variable makefiles.  */
    #####: 8995:	  while (tail != 0 && tail->next != 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 8996:	    tail = tail->next;
    #####: 8997:	  for (p = default_makefiles; *p != 0; ++p)
branch  0 never executed
branch  1 never executed
        -: 8998:	    {
    #####: 8999:	      struct dep *d = (struct dep *) xmalloc (sizeof (struct dep));
call    0 never executed
    #####: 9000:	      d->name = 0;
    #####: 9001:	      d->file = enter_file (*p);
call    0 never executed
    #####: 9002:	      d->file->dontcare = 1;
        -: 9003:	      /* Tell update_goal_chain to bail out as soon as this file is
        -: 9004:		 made, and main not to die if we can't make this file.  */
    #####: 9005:	      d->changed = RM_DONTCARE;
    #####: 9006:	      if (tail == 0)
branch  0 never executed
branch  1 never executed
    #####: 9007:		read_makefiles = d;
        -: 9008:	      else
    #####: 9009:		tail->next = d;
    #####: 9010:	      tail = d;
        -: 9011:	    }
    #####: 9012:	  if (tail != 0)
branch  0 never executed
branch  1 never executed
    #####: 9013:	    tail->next = 0;
        -: 9014:	}
        -: 9015:    }
        -: 9016:
      771: 9017:  return read_makefiles;
        -: 9018:}
        -: 9019:
        -: 9020:/* Read file FILENAME as a makefile and add its contents to the data base.
        -: 9021:
        -: 9022:   FLAGS contains bits as above.
        -: 9023:
        -: 9024:   FILENAME is added to the `read_makefiles' chain.
        -: 9025:
        -: 9026:   Returns 0 if a file was not found or not read.
        -: 9027:   Returns 1 if FILENAME was found and read.
        -: 9028:   Returns 2 if FILENAME was read, and we kept a reference (don't free it).  */
        -: 9029:
        -: 9030:static int
function read_makefile called 771 returned 100% blocks executed 6%
      771: 9031:read_makefile (filename, flags)
        -: 9032:     char *filename;
        -: 9033:     int flags;
        -: 9034:{
        -: 9035:  static char *collapsed = 0;
        -: 9036:  static unsigned int collapsed_length = 0;
        -: 9037:  register FILE *infile;
        -: 9038:  struct linebuffer lb;
      771: 9039:  unsigned int commands_len = 200;
        -: 9040:  char *commands;
      771: 9041:  unsigned int commands_idx = 0;
        -: 9042:  unsigned int cmds_started;
        -: 9043:  char *p;
        -: 9044:  char *p2;
        -: 9045:  int len, reading_target;
      771: 9046:  int ignoring = 0, in_ignored_define = 0;
      771: 9047:  int no_targets = 0;		/* Set when reading a rule without targets.  */
      771: 9048:  int using_filename = 0;
        -: 9049:  struct floc fileinfo;
      771: 9050:  char *passed_filename = filename;
        -: 9051:
      771: 9052:  struct nameseq *filenames = 0;
        -: 9053:  struct dep *deps;
      771: 9054:  unsigned int nlines = 0;
      771: 9055:  int two_colon = 0;
      771: 9056:  char *pattern = 0, *pattern_percent;
        -: 9057:
        -: 9058:  int makefile_errno;
        -: 9059:#if defined (WINDOWS32) || defined (__MSDOS__)
        -: 9060:  int check_again;
        -: 9061:#endif
        -: 9062:
        -: 9063:#define record_waiting_files()						      \
        -: 9064:  do									      \
        -: 9065:    { 									      \
        -: 9066:      if (filenames != 0)						      \
        -: 9067:        {                                                                     \
        -: 9068:	  record_files (filenames, pattern, pattern_percent, deps,            \
        -: 9069:                        cmds_started, commands, commands_idx, two_colon,      \
        -: 9070:                        &fileinfo, !(flags & RM_NO_DEFAULT_GOAL)); 	      \
        -: 9071:          using_filename |= commands_idx > 0;                                 \
        -: 9072:        }                                                                     \
        -: 9073:      filenames = 0;							      \
        -: 9074:      commands_idx = 0;							      \
        -: 9075:      if (pattern) { free(pattern); pattern = 0; }                            \
        -: 9076:    } while (0)
        -: 9077:
      771: 9078:  fileinfo.filenm = filename;
      771: 9079:  fileinfo.lineno = 1;
        -: 9080:
      771: 9081:  pattern_percent = 0;
      771: 9082:  cmds_started = fileinfo.lineno;
        -: 9083:
      771: 9084:  if (debug_flag)
branch  0 taken 384 (fallthrough)
branch  1 taken 387
        -: 9085:    {
      384: 9086:      printf (_("Reading makefile `%s'"), fileinfo.filenm);
call    0 returned 384
      384: 9087:      if (flags & RM_NO_DEFAULT_GOAL)
branch  0 taken 0 (fallthrough)
branch  1 taken 384
    #####: 9088:	printf (_(" (no default goal)"));
call    0 never executed
      384: 9089:      if (flags & RM_INCLUDED)
branch  0 taken 0 (fallthrough)
branch  1 taken 384
    #####: 9090:	printf (_(" (search path)"));
call    0 never executed
      384: 9091:      if (flags & RM_DONTCARE)
branch  0 taken 0 (fallthrough)
branch  1 taken 384
    #####: 9092:	printf (_(" (don't care)"));
call    0 never executed
      384: 9093:      if (flags & RM_NO_TILDE)
branch  0 taken 0 (fallthrough)
branch  1 taken 384
    #####: 9094:	printf (_(" (no ~ expansion)"));
call    0 never executed
      384: 9095:      puts ("...");
call    0 returned 384
        -: 9096:    }
        -: 9097:
        -: 9098:  /* First, get a stream to read.  */
        -: 9099:
        -: 9100:  /* Expand ~ in FILENAME unless it came from `include',
        -: 9101:     in which case it was already done.  */
      771: 9102:  if (!(flags & RM_NO_TILDE) && filename[0] == '~')
branch  0 taken 771 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 771
        -: 9103:    {
    #####: 9104:      char *expanded = tilde_expand (filename);
call    0 never executed
    #####: 9105:      if (expanded != 0)
branch  0 never executed
branch  1 never executed
    #####: 9106:	filename = expanded;
        -: 9107:    }
        -: 9108:
      771: 9109:  infile = fopen (filename, "r");
call    0 returned 771
        -: 9110:  /* Save the error code so we print the right message later.  */
      771: 9111:  makefile_errno = errno;
        -: 9112:
        -: 9113:  /* If the makefile wasn't found and it's either a makefile from
        -: 9114:     the `MAKEFILES' variable or an included makefile,
        -: 9115:     search the included makefile search path for this makefile.  */
     771*: 9116:  if (infile == 0 && (flags & RM_INCLUDED) && *filename != '/')
branch  0 taken 771 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 771
branch  4 never executed
branch  5 never executed
        -: 9117:    {
        -: 9118:      register unsigned int i;
    #####: 9119:      for (i = 0; include_directories_to_search[i] != 0; ++i)
branch  0 never executed
branch  1 never executed
        -: 9120:	{
    #####: 9121:	  char *name = concat (include_directories_to_search[i], "/", filename);
call    0 never executed
    #####: 9122:	  infile = fopen (name, "r");
call    0 never executed
    #####: 9123:	  if (infile == 0)
branch  0 never executed
branch  1 never executed
    #####: 9124:	    free (name);
        -: 9125:	  else
        -: 9126:	    {
    #####: 9127:	      filename = name;
    #####: 9128:	      break;
        -: 9129:	    }
        -: 9130:	}
        -: 9131:    }
        -: 9132:
        -: 9133:  /* Add FILENAME to the chain of read makefiles.  */
      771: 9134:  deps = (struct dep *) xmalloc (sizeof (struct dep));
call    0 returned 771
      771: 9135:  deps->next = read_makefiles;
      771: 9136:  read_makefiles = deps;
      771: 9137:  deps->name = 0;
      771: 9138:  deps->file = lookup_file (filename);
call    0 returned 771
      771: 9139:  if (deps->file == 0)
branch  0 taken 771 (fallthrough)
branch  1 taken 0
        -: 9140:    {
      771: 9141:      deps->file = enter_file (xstrdup (filename));
call    0 returned 771
call    1 returned 771
      771: 9142:      if (flags & RM_DONTCARE)
branch  0 taken 0 (fallthrough)
branch  1 taken 771
    #####: 9143:	deps->file->dontcare = 1;
        -: 9144:    }
      771: 9145:  if (filename != passed_filename)
branch  0 taken 0 (fallthrough)
branch  1 taken 771
    #####: 9146:    free (filename);
      771: 9147:  filename = deps->file->name;
      771: 9148:  deps->changed = flags;
      771: 9149:  deps = 0;
        -: 9150:
        -: 9151:  /* If the makefile can't be found at all, give up entirely.  */
        -: 9152:
      771: 9153:  if (infile == 0)
branch  0 taken 771 (fallthrough)
branch  1 taken 0
        -: 9154:    {
        -: 9155:      /* If we did some searching, errno has the error from the last
        -: 9156:	 attempt, rather from FILENAME itself.  Restore it in case the
        -: 9157:	 caller wants to use it in a message.  */
      771: 9158:      errno = makefile_errno;
      771: 9159:      return 0;
        -: 9160:    }
        -: 9161:
    #####: 9162:  reading_file = &fileinfo;
        -: 9163:
        -: 9164:  /* Loop over lines in the file.
        -: 9165:     The strategy is to accumulate target names in FILENAMES, dependencies
        -: 9166:     in DEPS and commands in COMMANDS.  These are used to define a rule
        -: 9167:     when the start of the next rule (or eof) is encountered.  */
        -: 9168:
    #####: 9169:  initbuffer (&lb);
call    0 never executed
    #####: 9170:  commands = xmalloc (200);
call    0 never executed
        -: 9171:
    #####: 9172:  while (!feof (infile))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 9173:    {
    #####: 9174:      fileinfo.lineno += nlines;
    #####: 9175:      nlines = readline (&lb, infile, &fileinfo);
call    0 never executed
        -: 9176:
        -: 9177:      /* Check for a shell command line first.
        -: 9178:	 If it is not one, we can stop treating tab specially.  */
    #####: 9179:      if (lb.buffer[0] == '\t')
branch  0 never executed
branch  1 never executed
        -: 9180:	{
        -: 9181:	  /* This line is a probably shell command.  */
        -: 9182:	  unsigned int len;
        -: 9183:
    #####: 9184:	  if (no_targets)
branch  0 never executed
branch  1 never executed
        -: 9185:	    /* Ignore the commands in a rule with no targets.  */
    #####: 9186:	    continue;
        -: 9187:
        -: 9188:	  /* If there is no preceding rule line, don't treat this line
        -: 9189:	     as a command, even though it begins with a tab character.
        -: 9190:	     SunOS 4 make appears to behave this way.  */
        -: 9191:
    #####: 9192:	  if (filenames != 0)
branch  0 never executed
branch  1 never executed
        -: 9193:	    {
    #####: 9194:	      if (ignoring)
branch  0 never executed
branch  1 never executed
        -: 9195:		/* Yep, this is a shell command, and we don't care.  */
    #####: 9196:		continue;
        -: 9197:
        -: 9198:	      /* Append this command line to the line being accumulated.  */
    #####: 9199:	      p = lb.buffer;
    #####: 9200:	      if (commands_idx == 0)
branch  0 never executed
branch  1 never executed
    #####: 9201:		cmds_started = fileinfo.lineno;
    #####: 9202:	      len = strlen (p);
    #####: 9203:	      if (len + 1 + commands_idx > commands_len)
branch  0 never executed
branch  1 never executed
        -: 9204:		{
    #####: 9205:		  commands_len = (len + 1 + commands_idx) * 2;
    #####: 9206:		  commands = (char *) xrealloc (commands, commands_len);
call    0 never executed
        -: 9207:		}
    #####: 9208:	      bcopy (p, &commands[commands_idx], len);
    #####: 9209:	      commands_idx += len;
    #####: 9210:	      commands[commands_idx++] = '\n';
        -: 9211:
    #####: 9212:	      continue;
        -: 9213:	    }
        -: 9214:	}
        -: 9215:
        -: 9216:      /* This line is not a shell command line.  Don't worry about tabs.  */
        -: 9217:
    #####: 9218:      if (collapsed_length < lb.size)
branch  0 never executed
branch  1 never executed
        -: 9219:	{
    #####: 9220:	  collapsed_length = lb.size;
    #####: 9221:	  if (collapsed != 0)
branch  0 never executed
branch  1 never executed
    #####: 9222:	    free (collapsed);
    #####: 9223:	  collapsed = (char *) xmalloc (collapsed_length);
call    0 never executed
        -: 9224:	}
    #####: 9225:      strcpy (collapsed, lb.buffer);
        -: 9226:      /* Collapse continuation lines.  */
    #####: 9227:      collapse_continuations (collapsed);
call    0 never executed
    #####: 9228:      remove_comments (collapsed);
call    0 never executed
        -: 9229:
        -: 9230:      /* Compare a word, both length and contents. */
        -: 9231:#define	word1eq(s, l) 	(len == l && strneq (s, p, l))
    #####: 9232:      p = collapsed;
    #####: 9233:      while (isspace (*p))
branch  0 never executed
branch  1 never executed
    #####: 9234:	++p;
    #####: 9235:      if (*p == '\0')
branch  0 never executed
branch  1 never executed
        -: 9236:	/* This line is completely empty.  */
    #####: 9237:	continue;
        -: 9238:
        -: 9239:      /* Find the end of the first token.  Note we don't need to worry about
        -: 9240:       * ":" here since we compare tokens by length (so "export" will never
        -: 9241:       * be equal to "export:").
        -: 9242:       */
    #####: 9243:      for (p2 = p+1; *p2 != '\0' && !isspace(*p2); ++p2)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 9244:        {}
    #####: 9245:      len = p2 - p;
        -: 9246:
        -: 9247:      /* Find the start of the second token.  If it's a `:' remember it,
        -: 9248:         since it can't be a preprocessor token--this allows targets named
        -: 9249:         `ifdef', `export', etc. */
    #####: 9250:      reading_target = 0;
    #####: 9251:      while (isspace (*p2))
branch  0 never executed
branch  1 never executed
    #####: 9252:        ++p2;
    #####: 9253:      if (*p2 == '\0')
branch  0 never executed
branch  1 never executed
    #####: 9254:        p2 = NULL;
    #####: 9255:      else if (p2[0] == ':' && p2[1] == '\0')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 9256:        {
    #####: 9257:          reading_target = 1;
    #####: 9258:          goto skip_conditionals;
        -: 9259:        }
        -: 9260:
        -: 9261:      /* We must first check for conditional and `define' directives before
        -: 9262:	 ignoring anything, since they control what we will do with
        -: 9263:	 following lines.  */
        -: 9264:
    #####: 9265:      if (!in_ignored_define
branch  0 never executed
branch  1 never executed
    #####: 9266:	  && (word1eq ("ifdef", 5) || word1eq ("ifndef", 6)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####: 9267:	      || word1eq ("ifeq", 4) || word1eq ("ifneq", 5)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####: 9268:	      || word1eq ("else", 4) || word1eq ("endif", 5)))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####: 9269:	{
    #####: 9270:	  int i = conditional_line (p, &fileinfo);
call    0 never executed
    #####: 9271:	  if (i >= 0)
branch  0 never executed
branch  1 never executed
    #####: 9272:	    ignoring = i;
        -: 9273:	  else
    #####: 9274:	    fatal (&fileinfo, _("invalid syntax in conditional"));
call    0 never executed
    #####: 9275:	  continue;
        -: 9276:	}
        -: 9277:
    #####: 9278:      if (word1eq ("endef", 5))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 9279:	{
    #####: 9280:	  if (in_ignored_define)
branch  0 never executed
branch  1 never executed
    #####: 9281:	    in_ignored_define = 0;
        -: 9282:	  else
    #####: 9283:	    fatal (&fileinfo, _("extraneous `endef'"));
call    0 never executed
    #####: 9284:	  continue;
        -: 9285:	}
        -: 9286:
    #####: 9287:      if (word1eq ("define", 6))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 9288:	{
    #####: 9289:	  if (ignoring)
branch  0 never executed
branch  1 never executed
    #####: 9290:	    in_ignored_define = 1;
        -: 9291:	  else
        -: 9292:	    {
    #####: 9293:	      p2 = next_token (p + 6);
call    0 never executed
    #####: 9294:              if (*p2 == '\0')
branch  0 never executed
branch  1 never executed
    #####: 9295:                fatal (&fileinfo, _("empty variable name"));
call    0 never executed
        -: 9296:
        -: 9297:	      /* Let the variable name be the whole rest of the line,
        -: 9298:		 with trailing blanks stripped (comments have already been
        -: 9299:		 removed), so it could be a complex variable/function
        -: 9300:		 reference that might contain blanks.  */
    #####: 9301:	      p = index (p2, '\0');
    #####: 9302:	      while (isblank (p[-1]))
branch  0 never executed
branch  1 never executed
    #####: 9303:		--p;
    #####: 9304:	      do_define (p2, p - p2, o_file, infile, &fileinfo);
call    0 never executed
        -: 9305:	    }
    #####: 9306:	  continue;
        -: 9307:	}
        -: 9308:
    #####: 9309:      if (word1eq ("override", 8))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 9310:        {
    #####: 9311:	  p2 = next_token (p + 8);
call    0 never executed
    #####: 9312:	  if (*p2 == '\0')
branch  0 never executed
branch  1 never executed
    #####: 9313:	    error (&fileinfo, _("empty `override' directive"));
call    0 never executed
    #####: 9314:	  if (strneq (p2, "define", 6) && (isblank (p2[6]) || p2[6] == '\0'))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 9315:	    {
    #####: 9316:	      if (ignoring)
branch  0 never executed
branch  1 never executed
    #####: 9317:		in_ignored_define = 1;
        -: 9318:	      else
        -: 9319:		{
    #####: 9320:		  p2 = next_token (p2 + 6);
call    0 never executed
    #####: 9321:                  if (*p2 == '\0')
branch  0 never executed
branch  1 never executed
    #####: 9322:                    fatal (&fileinfo, _("empty variable name"));
call    0 never executed
        -: 9323:
        -: 9324:		  /* Let the variable name be the whole rest of the line,
        -: 9325:		     with trailing blanks stripped (comments have already been
        -: 9326:		     removed), so it could be a complex variable/function
        -: 9327:		     reference that might contain blanks.  */
    #####: 9328:		  p = index (p2, '\0');
    #####: 9329:		  while (isblank (p[-1]))
branch  0 never executed
branch  1 never executed
    #####: 9330:		    --p;
    #####: 9331:		  do_define (p2, p - p2, o_override, infile, &fileinfo);
call    0 never executed
        -: 9332:		}
        -: 9333:	    }
    #####: 9334:	  else if (!ignoring
branch  0 never executed
branch  1 never executed
    #####: 9335:		   && !try_variable_definition (&fileinfo, p2, o_override))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 9336:	    error (&fileinfo, _("invalid `override' directive"));
call    0 never executed
        -: 9337:
    #####: 9338:	  continue;
        -: 9339:	}
    #####: 9340: skip_conditionals:
        -: 9341:
    #####: 9342:      if (ignoring)
branch  0 never executed
branch  1 never executed
        -: 9343:	/* Ignore the line.  We continue here so conditionals
        -: 9344:	   can appear in the middle of a rule.  */
    #####: 9345:	continue;
        -: 9346:
    #####: 9347:      if (!reading_target && word1eq ("export", 6))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 9348:	{
        -: 9349:	  struct variable *v;
    #####: 9350:	  p2 = next_token (p + 6);
call    0 never executed
    #####: 9351:	  if (*p2 == '\0')
branch  0 never executed
branch  1 never executed
    #####: 9352:	    export_all_variables = 1;
    #####: 9353:	  v = try_variable_definition (&fileinfo, p2, o_file);
call    0 never executed
    #####: 9354:	  if (v != 0)
branch  0 never executed
branch  1 never executed
    #####: 9355:	    v->export = v_export;
        -: 9356:	  else
        -: 9357:	    {
        -: 9358:	      unsigned int len;
    #####: 9359:	      for (p = find_next_token (&p2, &len); p != 0;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 9360:		   p = find_next_token (&p2, &len))
        -: 9361:		{
    #####: 9362:		  v = lookup_variable (p, len);
call    0 never executed
    #####: 9363:		  if (v == 0)
branch  0 never executed
branch  1 never executed
    #####: 9364:		    v = define_variable (p, len, "", o_file, 0);
call    0 never executed
    #####: 9365:		  v->export = v_export;
call    0 never executed
        -: 9366:		}
        -: 9367:	    }
        -: 9368:	}
    #####: 9369:      else if (!reading_target && word1eq ("unexport", 8))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 9370:	{
        -: 9371:	  unsigned int len;
        -: 9372:	  struct variable *v;
    #####: 9373:	  p2 = next_token (p + 8);
call    0 never executed
    #####: 9374:	  if (*p2 == '\0')
branch  0 never executed
branch  1 never executed
    #####: 9375:	    export_all_variables = 0;
    #####: 9376:	  for (p = find_next_token (&p2, &len); p != 0;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 9377:	       p = find_next_token (&p2, &len))
        -: 9378:	    {
    #####: 9379:	      v = lookup_variable (p, len);
call    0 never executed
    #####: 9380:	      if (v == 0)
branch  0 never executed
branch  1 never executed
    #####: 9381:		v = define_variable (p, len, "", o_file, 0);
call    0 never executed
    #####: 9382:	      v->export = v_noexport;
call    0 never executed
        -: 9383:	    }
        -: 9384:	}
    #####: 9385:      else if (word1eq ("vpath", 5))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 9386:	{
        -: 9387:	  char *pattern;
        -: 9388:	  unsigned int len;
    #####: 9389:	  p2 = variable_expand (p + 5);
call    0 never executed
    #####: 9390:	  p = find_next_token (&p2, &len);
call    0 never executed
    #####: 9391:	  if (p != 0)
branch  0 never executed
branch  1 never executed
        -: 9392:	    {
    #####: 9393:	      pattern = savestring (p, len);
call    0 never executed
    #####: 9394:	      p = find_next_token (&p2, &len);
call    0 never executed
        -: 9395:	      /* No searchpath means remove all previous
        -: 9396:		 selective VPATH's with the same pattern.  */
        -: 9397:	    }
        -: 9398:	  else
        -: 9399:	    /* No pattern means remove all previous selective VPATH's.  */
    #####: 9400:	    pattern = 0;
    #####: 9401:	  construct_vpath_list (pattern, p);
call    0 never executed
    #####: 9402:	  if (pattern != 0)
branch  0 never executed
branch  1 never executed
    #####: 9403:	    free (pattern);
        -: 9404:	}
    #####: 9405:      else if (word1eq ("include", 7) || word1eq ("-include", 8)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####: 9406:	       || word1eq ("sinclude", 8))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 9407:	{
        -: 9408:	  /* We have found an `include' line specifying a nested
        -: 9409:	     makefile to be read at this point.  */
        -: 9410:	  struct conditionals *save, new_conditionals;
        -: 9411:	  struct nameseq *files;
        -: 9412:	  /* "-include" (vs "include") says no error if the file does not
        -: 9413:	     exist.  "sinclude" is an alias for this from SGI.  */
    #####: 9414:	  int noerror = p[0] != 'i';
        -: 9415:
    #####: 9416:	  p = allocated_variable_expand (next_token (p + (noerror ? 8 : 7)));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####: 9417:	  if (*p == '\0')
branch  0 never executed
branch  1 never executed
        -: 9418:	    {
    #####: 9419:	      error (&fileinfo,
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 9420:                     _("no file name for `%sinclude'"), noerror ? "-" : "");
    #####: 9421:	      continue;
        -: 9422:	    }
        -: 9423:
        -: 9424:	  /* Parse the list of file names.  */
    #####: 9425:	  p2 = p;
    #####: 9426:	  files = multi_glob (parse_file_seq (&p2, '\0',
call    0 never executed
call    1 never executed
        -: 9427:					      sizeof (struct nameseq),
        -: 9428:					      1),
        -: 9429:			      sizeof (struct nameseq));
    #####: 9430:	  free (p);
        -: 9431:
        -: 9432:	  /* Save the state of conditionals and start
        -: 9433:	     the included makefile with a clean slate.  */
    #####: 9434:	  save = conditionals;
    #####: 9435:	  bzero ((char *) &new_conditionals, sizeof new_conditionals);
    #####: 9436:	  conditionals = &new_conditionals;
        -: 9437:
        -: 9438:	  /* Record the rules that are waiting so they will determine
        -: 9439:	     the default goal before those in the included makefile.  */
    #####: 9440:	  record_waiting_files ();
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 9441:
        -: 9442:	  /* Read each included makefile.  */
    #####: 9443:	  while (files != 0)
branch  0 never executed
branch  1 never executed
        -: 9444:	    {
    #####: 9445:	      struct nameseq *next = files->next;
    #####: 9446:	      char *name = files->name;
        -: 9447:              int r;
        -: 9448:
    #####: 9449:	      free ((char *)files);
    #####: 9450:	      files = next;
        -: 9451:
    #####: 9452:              r = read_makefile (name, (RM_INCLUDED | RM_NO_TILDE
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 9453:                                        | (noerror ? RM_DONTCARE : 0)));
    #####: 9454:	      if (!r && !noerror)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 9455:		error (&fileinfo, "%s: %s", name, strerror (errno));
call    0 never executed
call    1 never executed
        -: 9456:
    #####: 9457:              if (r < 2)
branch  0 never executed
branch  1 never executed
    #####: 9458:                free (name);
        -: 9459:	    }
        -: 9460:
        -: 9461:	  /* Free any space allocated by conditional_line.  */
    #####: 9462:	  if (conditionals->ignoring)
branch  0 never executed
branch  1 never executed
    #####: 9463:	    free (conditionals->ignoring);
    #####: 9464:	  if (conditionals->seen_else)
branch  0 never executed
branch  1 never executed
    #####: 9465:	    free (conditionals->seen_else);
        -: 9466:
        -: 9467:	  /* Restore state.  */
    #####: 9468:	  conditionals = save;
    #####: 9469:	  reading_file = &fileinfo;
        -: 9470:	}
        -: 9471:#undef	word1eq
    #####: 9472:      else if (try_variable_definition (&fileinfo, p, o_file))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 9473:	/* This line has been dealt with.  */
        -: 9474:	;
    #####: 9475:      else if (lb.buffer[0] == '\t')
branch  0 never executed
branch  1 never executed
        -: 9476:	{
    #####: 9477:	  p = collapsed;	/* Ignore comments.  */
    #####: 9478:	  while (isblank (*p))
branch  0 never executed
branch  1 never executed
    #####: 9479:	    ++p;
    #####: 9480:	  if (*p == '\0')
branch  0 never executed
branch  1 never executed
        -: 9481:	    /* The line is completely blank; that is harmless.  */
    #####: 9482:	    continue;
        -: 9483:	  /* This line starts with a tab but was not caught above
        -: 9484:	     because there was no preceding target, and the line
        -: 9485:	     might have been usable as a variable definition.
        -: 9486:	     But now it is definitely lossage.  */
    #####: 9487:	  fatal(&fileinfo, _("commands commence before first target"));
call    0 never executed
        -: 9488:	}
        -: 9489:      else
    #####: 9490:	{
        -: 9491:	  /* This line describes some target files.  This is complicated by
        -: 9492:             the existence of target-specific variables, because we can't
        -: 9493:             expand the entire line until we know if we have one or not.  So
        -: 9494:             we expand the line word by word until we find the first `:',
        -: 9495:             then check to see if it's a target-specific variable.
        -: 9496:
        -: 9497:             In this algorithm, `lb_next' will point to the beginning of the
        -: 9498:             unexpanded parts of the input buffer, while `p2' points to the
        -: 9499:             parts of the expanded buffer we haven't searched yet. */
        -: 9500:
        -: 9501:          enum make_word_type wtype;
        -: 9502:          enum variable_origin v_origin;
        -: 9503:          char *cmdleft, *lb_next;
    #####: 9504:          unsigned int len, plen = 0;
        -: 9505:          char *colonp;
        -: 9506:
        -: 9507:	  /* Record the previous rule.  */
        -: 9508:
    #####: 9509:	  record_waiting_files ();
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 9510:
        -: 9511:	  /* Search the line for an unquoted ; that is not after an
        -: 9512:             unquoted #.  */
    #####: 9513:	  cmdleft = find_char_unquote (lb.buffer, ";#", 0);
call    0 never executed
    #####: 9514:	  if (cmdleft != 0 && *cmdleft == '#')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 9515:	    {
        -: 9516:	      /* We found a comment before a semicolon.  */
    #####: 9517:	      *cmdleft = '\0';
    #####: 9518:	      cmdleft = 0;
        -: 9519:	    }
    #####: 9520:	  else if (cmdleft != 0)
branch  0 never executed
branch  1 never executed
        -: 9521:	    /* Found one.  Cut the line short there before expanding it.  */
    #####: 9522:	    *(cmdleft++) = '\0';
        -: 9523:
    #####: 9524:	  collapse_continuations (lb.buffer);
call    0 never executed
        -: 9525:
        -: 9526:	  /* We can't expand the entire line, since if it's a per-target
        -: 9527:             variable we don't want to expand it.  So, walk from the
        -: 9528:             beginning, expanding as we go, and looking for "interesting"
        -: 9529:             chars.  The first word is always expandable.  */
    #####: 9530:          wtype = get_next_mword(lb.buffer, NULL, &lb_next, &len);
call    0 never executed
    #####: 9531:          switch (wtype)
branch  0 never executed
branch  1 never executed
branch  2 never executed
        -: 9532:            {
    #####: 9533:            case w_eol:
    #####: 9534:              if (cmdleft != 0)
branch  0 never executed
branch  1 never executed
    #####: 9535:                fatal(&fileinfo, _("missing rule before commands"));
call    0 never executed
        -: 9536:              /* This line contained something but turned out to be nothing
        -: 9537:                 but whitespace (a comment?).  */
    #####: 9538:              continue;
        -: 9539:
    #####: 9540:            case w_colon:
        -: 9541:            case w_dcolon:
        -: 9542:              /* We accept and ignore rules without targets for
        -: 9543:                 compatibility with SunOS 4 make.  */
    #####: 9544:              no_targets = 1;
    #####: 9545:              continue;
        -: 9546:
    #####: 9547:            default:
    #####: 9548:              break;
        -: 9549:            }
        -: 9550:
    #####: 9551:          p2 = variable_expand_string(NULL, lb_next, len);
call    0 never executed
        -: 9552:          while (1)
        -: 9553:            {
    #####: 9554:              lb_next += len;
    #####: 9555:              if (cmdleft == 0)
branch  0 never executed
branch  1 never executed
        -: 9556:                {
        -: 9557:                  /* Look for a semicolon in the expanded line.  */
    #####: 9558:                  cmdleft = find_char_unquote (p2, ";", 0);
call    0 never executed
        -: 9559:
    #####: 9560:                  if (cmdleft != 0)
branch  0 never executed
branch  1 never executed
        -: 9561:                    {
    #####: 9562:                      unsigned long p2_off = p2 - variable_buffer;
    #####: 9563:                      unsigned long cmd_off = cmdleft - variable_buffer;
    #####: 9564:                      char *pend = p2 + strlen(p2);
        -: 9565:
        -: 9566:                      /* Append any remnants of lb, then cut the line short
        -: 9567:                         at the semicolon.  */
    #####: 9568:                      *cmdleft = '\0';
        -: 9569:
        -: 9570:                      /* One school of thought says that you shouldn't expand
        -: 9571:                         here, but merely copy, since now you're beyond a ";"
        -: 9572:                         and into a command script.  However, the old parser
        -: 9573:                         expanded the whole line, so we continue that for
        -: 9574:                         backwards-compatiblity.  Also, it wouldn't be
        -: 9575:                         entirely consistent, since we do an unconditional
        -: 9576:                         expand below once we know we don't have a
        -: 9577:                         target-specific variable. */
    #####: 9578:                      (void)variable_expand_string(pend, lb_next, (long)-1);
call    0 never executed
    #####: 9579:                      lb_next += strlen(lb_next);
    #####: 9580:                      p2 = variable_buffer + p2_off;
    #####: 9581:                      cmdleft = variable_buffer + cmd_off + 1;
        -: 9582:                    }
        -: 9583:                }
        -: 9584:
    #####: 9585:              colonp = find_char_unquote(p2, ":", 0);
call    0 never executed
        -: 9586:#if defined(__MSDOS__) || defined(WINDOWS32)
        -: 9587:	      /* The drive spec brain-damage strikes again...  */
        -: 9588:	      /* Note that the only separators of targets in this context
        -: 9589:		 are whitespace and a left paren.  If others are possible,
        -: 9590:		 they should be added to the string in the call to index.  */
        -: 9591:	      while (colonp && (colonp[1] == '/' || colonp[1] == '\\') &&
        -: 9592:		     colonp > p2 && isalpha(colonp[-1]) &&
        -: 9593:		     (colonp == p2 + 1 || index(" \t(", colonp[-2]) != 0))
        -: 9594:		colonp = find_char_unquote(colonp + 1, ":", 0);
        -: 9595:#endif
    #####: 9596:              if (colonp != 0)
branch  0 never executed
branch  1 never executed
    #####: 9597:                break;
        -: 9598:
    #####: 9599:              wtype = get_next_mword(lb_next, NULL, &lb_next, &len);
call    0 never executed
    #####: 9600:              if (wtype == w_eol)
branch  0 never executed
branch  1 never executed
    #####: 9601:                break;
        -: 9602:
    #####: 9603:              p2 += strlen(p2);
    #####: 9604:              *(p2++) = ' ';
    #####: 9605:              p2 = variable_expand_string(p2, lb_next, len);
call    0 never executed
        -: 9606:              /* We don't need to worry about cmdleft here, because if it was
        -: 9607:                 found in the variable_buffer the entire buffer has already
        -: 9608:                 been expanded... we'll never get here.  */
        -: 9609:            }
        -: 9610:
    #####: 9611:	  p2 = next_token (variable_buffer);
call    0 never executed
        -: 9612:
        -: 9613:          /* If the word we're looking at is EOL, see if there's _anything_
        -: 9614:             on the line.  If not, a variable expanded to nothing, so ignore
        -: 9615:             it.  If so, we can't parse this line so punt.  */
    #####: 9616:          if (wtype == w_eol)
branch  0 never executed
branch  1 never executed
        -: 9617:            {
    #####: 9618:              if (*p2 != '\0')
branch  0 never executed
branch  1 never executed
        -: 9619:                /* There's no need to be ivory-tower about this: check for
        -: 9620:                   one of the most common bugs found in makefiles...  */
    #####: 9621:                fatal (&fileinfo, _("missing separator%s"),
call    0 never executed
    #####: 9622:                       !strneq(lb.buffer, "        ", 8) ? ""
branch  0 never executed
branch  1 never executed
        -: 9623:                       : _(" (did you mean TAB instead of 8 spaces?)"));
    #####: 9624:              continue;
        -: 9625:            }
        -: 9626:
        -: 9627:          /* Make the colon the end-of-string so we know where to stop
        -: 9628:             looking for targets.  */
    #####: 9629:          *colonp = '\0';
    #####: 9630:	  filenames = multi_glob (parse_file_seq (&p2, '\0',
call    0 never executed
call    1 never executed
        -: 9631:						  sizeof (struct nameseq),
        -: 9632:						  1),
        -: 9633:				  sizeof (struct nameseq));
    #####: 9634:          *colonp = ':';
        -: 9635:
    #####: 9636:          if (!filenames)
branch  0 never executed
branch  1 never executed
        -: 9637:            {
        -: 9638:              /* We accept and ignore rules without targets for
        -: 9639:                 compatibility with SunOS 4 make.  */
    #####: 9640:              no_targets = 1;
    #####: 9641:              continue;
        -: 9642:            }
        -: 9643:          /* This should never be possible; we handled it above.  */
    #####: 9644:	  assert (*p2 != '\0');
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 9645:          ++p2;
        -: 9646:
        -: 9647:	  /* Is this a one-colon or two-colon entry?  */
    #####: 9648:	  two_colon = *p2 == ':';
    #####: 9649:	  if (two_colon)
branch  0 never executed
branch  1 never executed
    #####: 9650:	    p2++;
        -: 9651:
        -: 9652:          /* Test to see if it's a target-specific variable.  Copy the rest
        -: 9653:             of the buffer over, possibly temporarily (we'll expand it later
        -: 9654:             if it's not a target-specific variable).  PLEN saves the length
        -: 9655:             of the unparsed section of p2, for later.  */
    #####: 9656:          if (*lb_next != '\0')
branch  0 never executed
branch  1 never executed
        -: 9657:            {
    #####: 9658:              unsigned int l = p2 - variable_buffer;
    #####: 9659:              plen = strlen (p2);
    #####: 9660:              (void) variable_buffer_output (p2+plen,
    #####: 9661:                                             lb_next, strlen (lb_next)+1);
call    0 never executed
    #####: 9662:              p2 = variable_buffer + l;
        -: 9663:            }
        -: 9664:
        -: 9665:          /* See if it's an "override" keyword; if so see if what comes after
        -: 9666:             it looks like a variable definition.  */
        -: 9667:
    #####: 9668:          wtype = get_next_mword (p2, NULL, &p, &len);
call    0 never executed
        -: 9669:
    #####: 9670:          v_origin = o_file;
    #####: 9671:          if (wtype == w_static && (len == (sizeof ("override")-1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 9672:                                    && strneq (p, "override", len)))
branch  0 never executed
branch  1 never executed
        -: 9673:            {
    #####: 9674:              v_origin = o_override;
    #####: 9675:              wtype = get_next_mword (p+len, NULL, &p, &len);
call    0 never executed
        -: 9676:            }
        -: 9677:
    #####: 9678:          if (wtype != w_eol)
branch  0 never executed
branch  1 never executed
    #####: 9679:            wtype = get_next_mword (p+len, NULL, NULL, NULL);
call    0 never executed
        -: 9680:
    #####: 9681:          if (wtype == w_varassign)
branch  0 never executed
branch  1 never executed
        -: 9682:            {
    #####: 9683:              record_target_var (filenames, p, two_colon, v_origin, &fileinfo);
call    0 never executed
    #####: 9684:              filenames = 0;
    #####: 9685:              continue;
        -: 9686:            }
        -: 9687:
        -: 9688:          /* This is a normal target, _not_ a target-specific variable.
        -: 9689:             Unquote any = in the dependency list.  */
    #####: 9690:          find_char_unquote (lb_next, "=", 0);
call    0 never executed
        -: 9691:
        -: 9692:	  /* We have some targets, so don't ignore the following commands.  */
    #####: 9693:	  no_targets = 0;
        -: 9694:
        -: 9695:          /* Expand the dependencies, etc.  */
    #####: 9696:          if (*lb_next != '\0')
branch  0 never executed
branch  1 never executed
        -: 9697:            {
    #####: 9698:              unsigned int l = p2 - variable_buffer;
    #####: 9699:              (void) variable_expand_string (p2 + plen, lb_next, (long)-1);
call    0 never executed
    #####: 9700:              p2 = variable_buffer + l;
        -: 9701:
        -: 9702:              /* Look for a semicolon in the expanded line.  */
    #####: 9703:              if (cmdleft == 0)
branch  0 never executed
branch  1 never executed
        -: 9704:                {
    #####: 9705:                  cmdleft = find_char_unquote (p2, ";", 0);
call    0 never executed
    #####: 9706:                  if (cmdleft != 0)
branch  0 never executed
branch  1 never executed
    #####: 9707:                    *(cmdleft++) = '\0';
        -: 9708:                }
        -: 9709:            }
        -: 9710:
        -: 9711:	  /* Is this a static pattern rule: `target: %targ: %dep; ...'?  */
    #####: 9712:	  p = index (p2, ':');
    #####: 9713:	  while (p != 0 && p[-1] == '\\')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 9714:	    {
    #####: 9715:	      register char *q = &p[-1];
    #####: 9716:	      register int backslash = 0;
    #####: 9717:	      while (*q-- == '\\')
branch  0 never executed
branch  1 never executed
    #####: 9718:		backslash = !backslash;
    #####: 9719:	      if (backslash)
branch  0 never executed
branch  1 never executed
    #####: 9720:		p = index (p + 1, ':');
        -: 9721:	      else
    #####: 9722:		break;
        -: 9723:	    }
        -: 9724:#ifdef _AMIGA
        -: 9725:	  /* Here, the situation is quite complicated. Let's have a look
        -: 9726:	    at a couple of targets:
        -: 9727:
        -: 9728:		install: dev:make
        -: 9729:
        -: 9730:		dev:make: make
        -: 9731:
        -: 9732:		dev:make:: xyz
        -: 9733:
        -: 9734:	    The rule is that it's only a target, if there are TWO :'s
        -: 9735:	    OR a space around the :.
        -: 9736:	  */
        -: 9737:	  if (p && !(isspace(p[1]) || !p[1] || isspace(p[-1])))
        -: 9738:	    p = 0;
        -: 9739:#endif
        -: 9740:#if defined (WINDOWS32) || defined (__MSDOS__)
        -: 9741:          do {
        -: 9742:            check_again = 0;
        -: 9743:            /* For MSDOS and WINDOWS32, skip a "C:\..." or a "C:/..." */
        -: 9744:            if (p != 0 && (p[1] == '\\' || p[1] == '/') &&
        -: 9745:		isalpha(p[-1]) &&
        -: 9746:		(p == p2 + 1 || index(" \t:(", p[-2]) != 0)) {
        -: 9747:              p = index(p + 1, ':');
        -: 9748:              check_again = 1;
        -: 9749:            }
        -: 9750:          } while (check_again);
        -: 9751:#endif
    #####: 9752:	  if (p != 0)
branch  0 never executed
branch  1 never executed
        -: 9753:	    {
        -: 9754:	      struct nameseq *target;
    #####: 9755:	      target = parse_file_seq (&p2, ':', sizeof (struct nameseq), 1);
call    0 never executed
    #####: 9756:	      ++p2;
    #####: 9757:	      if (target == 0)
branch  0 never executed
branch  1 never executed
    #####: 9758:		fatal (&fileinfo, _("missing target pattern"));
call    0 never executed
    #####: 9759:	      else if (target->next != 0)
branch  0 never executed
branch  1 never executed
    #####: 9760:		fatal (&fileinfo, _("multiple target patterns"));
call    0 never executed
    #####: 9761:	      pattern = target->name;
    #####: 9762:	      pattern_percent = find_percent (pattern);
call    0 never executed
    #####: 9763:	      if (pattern_percent == 0)
branch  0 never executed
branch  1 never executed
    #####: 9764:		fatal (&fileinfo, _("target pattern contains no `%%'"));
call    0 never executed
    #####: 9765:              free((char *)target);
        -: 9766:	    }
        -: 9767:	  else
    #####: 9768:	    pattern = 0;
        -: 9769:
        -: 9770:	  /* Parse the dependencies.  */
        -: 9771:	  deps = (struct dep *)
    #####: 9772:	    multi_glob (parse_file_seq (&p2, '\0', sizeof (struct dep), 1),
call    0 never executed
call    1 never executed
        -: 9773:			sizeof (struct dep));
        -: 9774:
    #####: 9775:	  commands_idx = 0;
    #####: 9776:	  if (cmdleft != 0)
branch  0 never executed
branch  1 never executed
        -: 9777:	    {
        -: 9778:	      /* Semicolon means rest of line is a command.  */
    #####: 9779:	      unsigned int len = strlen (cmdleft);
        -: 9780:
    #####: 9781:	      cmds_started = fileinfo.lineno;
        -: 9782:
        -: 9783:	      /* Add this command line to the buffer.  */
    #####: 9784:	      if (len + 2 > commands_len)
branch  0 never executed
branch  1 never executed
        -: 9785:		{
    #####: 9786:		  commands_len = (len + 2) * 2;
    #####: 9787:		  commands = (char *) xrealloc (commands, commands_len);
call    0 never executed
        -: 9788:		}
    #####: 9789:	      bcopy (cmdleft, commands, len);
    #####: 9790:	      commands_idx += len;
    #####: 9791:	      commands[commands_idx++] = '\n';
        -: 9792:	    }
        -: 9793:
    #####: 9794:	  continue;
        -: 9795:	}
        -: 9796:
        -: 9797:      /* We get here except in the case that we just read a rule line.
        -: 9798:	 Record now the last rule we read, so following spurious
        -: 9799:	 commands are properly diagnosed.  */
    #####: 9800:      record_waiting_files ();
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 9801:      no_targets = 0;
        -: 9802:    }
        -: 9803:
    #####: 9804:  if (conditionals->if_cmds)
branch  0 never executed
branch  1 never executed
    #####: 9805:    fatal (&fileinfo, _("missing `endif'"));
call    0 never executed
        -: 9806:
        -: 9807:  /* At eof, record the last rule.  */
    #####: 9808:  record_waiting_files ();
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 9809:
    #####: 9810:  freebuffer (&lb);
    #####: 9811:  free ((char *) commands);
    #####: 9812:  fclose (infile);
call    0 never executed
        -: 9813:
    #####: 9814:  reading_file = 0;
        -: 9815:
    #####: 9816:  return 1+using_filename;
        -: 9817:}
        -: 9818:
        -: 9819:/* Execute a `define' directive.
        -: 9820:   The first line has already been read, and NAME is the name of
        -: 9821:   the variable to be defined.  The following lines remain to be read.
        -: 9822:   LINENO, INFILE and FILENAME refer to the makefile being read.
        -: 9823:   The value returned is LINENO, updated for lines read here.  */
        -: 9824:
        -: 9825:static void
function do_define called 0 returned 0% blocks executed 0%
    #####: 9826:do_define (name, namelen, origin, infile, flocp)
        -: 9827:     char *name;
        -: 9828:     unsigned int namelen;
        -: 9829:     enum variable_origin origin;
        -: 9830:     FILE *infile;
        -: 9831:     struct floc *flocp;
        -: 9832:{
        -: 9833:  struct linebuffer lb;
    #####: 9834:  unsigned int nlines = 0;
    #####: 9835:  unsigned int length = 100;
    #####: 9836:  char *definition = (char *) xmalloc (100);
call    0 never executed
    #####: 9837:  register unsigned int idx = 0;
        -: 9838:  register char *p;
        -: 9839:
        -: 9840:  /* Expand the variable name.  */
    #####: 9841:  char *var = (char *) alloca (namelen + 1);
    #####: 9842:  bcopy (name, var, namelen);
    #####: 9843:  var[namelen] = '\0';
    #####: 9844:  var = variable_expand (var);
call    0 never executed
        -: 9845:
    #####: 9846:  initbuffer (&lb);
call    0 never executed
    #####: 9847:  while (!feof (infile))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 9848:    {
        -: 9849:      unsigned int len;
        -: 9850:
    #####: 9851:      flocp->lineno += nlines;
    #####: 9852:      nlines = readline (&lb, infile, flocp);
call    0 never executed
        -: 9853:
    #####: 9854:      collapse_continuations (lb.buffer);
call    0 never executed
        -: 9855:
    #####: 9856:      p = next_token (lb.buffer);
call    0 never executed
    #####: 9857:      len = strlen (p);
    #####: 9858:      if ((len == 5 || (len > 5 && isblank (p[5])))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 9859:          && strneq (p, "endef", 5))
branch  0 never executed
branch  1 never executed
        -: 9860:	{
    #####: 9861:	  p += 5;
    #####: 9862:	  remove_comments (p);
call    0 never executed
    #####: 9863:	  if (*next_token (p) != '\0')
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 9864:	    error (flocp, _("Extraneous text after `endef' directive"));
call    0 never executed
        -: 9865:	  /* Define the variable.  */
    #####: 9866:	  if (idx == 0)
branch  0 never executed
branch  1 never executed
    #####: 9867:	    definition[0] = '\0';
        -: 9868:	  else
    #####: 9869:	    definition[idx - 1] = '\0';
    #####: 9870:	  (void) define_variable (var, strlen (var), definition, origin, 1);
call    0 never executed
    #####: 9871:	  free (definition);
    #####: 9872:	  freebuffer (&lb);
    #####: 9873:	  return;
        -: 9874:	}
        -: 9875:      else
        -: 9876:	{
    #####: 9877:          len = strlen (lb.buffer);
        -: 9878:	  /* Increase the buffer size if necessary.  */
    #####: 9879:	  if (idx + len + 1 > length)
branch  0 never executed
branch  1 never executed
        -: 9880:	    {
    #####: 9881:	      length = (idx + len) * 2;
    #####: 9882:	      definition = (char *) xrealloc (definition, length + 1);
call    0 never executed
        -: 9883:	    }
        -: 9884:
    #####: 9885:	  bcopy (lb.buffer, &definition[idx], len);
    #####: 9886:	  idx += len;
        -: 9887:	  /* Separate lines with a newline.  */
    #####: 9888:	  definition[idx++] = '\n';
        -: 9889:	}
        -: 9890:    }
        -: 9891:
        -: 9892:  /* No `endef'!!  */
    #####: 9893:  fatal (flocp, _("missing `endef', unterminated `define'"));
call    0 never executed
        -: 9894:
        -: 9895:  /* NOTREACHED */
        -: 9896:  return;
        -: 9897:}
        -: 9898:
        -: 9899:/* Interpret conditional commands "ifdef", "ifndef", "ifeq",
        -: 9900:   "ifneq", "else" and "endif".
        -: 9901:   LINE is the input line, with the command as its first word.
        -: 9902:
        -: 9903:   FILENAME and LINENO are the filename and line number in the
        -: 9904:   current makefile.  They are used for error messages.
        -: 9905:
        -: 9906:   Value is -1 if the line is invalid,
        -: 9907:   0 if following text should be interpreted,
        -: 9908:   1 if following text should be ignored.  */
        -: 9909:
        -: 9910:static int
function conditional_line called 0 returned 0% blocks executed 0%
    #####: 9911:conditional_line (line, flocp)
        -: 9912:     char *line;
        -: 9913:     const struct floc *flocp;
        -: 9914:{
        -: 9915:  int notdef;
        -: 9916:  char *cmdname;
        -: 9917:  register unsigned int i;
        -: 9918:
    #####: 9919:  if (*line == 'i')
branch  0 never executed
branch  1 never executed
        -: 9920:    {
        -: 9921:      /* It's an "if..." command.  */
    #####: 9922:      notdef = line[2] == 'n';
    #####: 9923:      if (notdef)
branch  0 never executed
branch  1 never executed
        -: 9924:	{
    #####: 9925:	  cmdname = line[3] == 'd' ? "ifndef" : "ifneq";
branch  0 never executed
branch  1 never executed
    #####: 9926:	  line += cmdname[3] == 'd' ? 7 : 6;
branch  0 never executed
branch  1 never executed
        -: 9927:	}
        -: 9928:      else
        -: 9929:	{
    #####: 9930:	  cmdname = line[2] == 'd' ? "ifdef" : "ifeq";
branch  0 never executed
branch  1 never executed
    #####: 9931:	  line += cmdname[2] == 'd' ? 6 : 5;
branch  0 never executed
branch  1 never executed
        -: 9932:	}
        -: 9933:    }
        -: 9934:  else
        -: 9935:    {
        -: 9936:      /* It's an "else" or "endif" command.  */
    #####: 9937:      notdef = line[1] == 'n';
    #####: 9938:      cmdname = notdef ? "endif" : "else";
branch  0 never executed
branch  1 never executed
    #####: 9939:      line += notdef ? 5 : 4;
branch  0 never executed
branch  1 never executed
        -: 9940:    }
        -: 9941:
    #####: 9942:  line = next_token (line);
call    0 never executed
        -: 9943:
    #####: 9944:  if (*cmdname == 'e')
branch  0 never executed
branch  1 never executed
        -: 9945:    {
    #####: 9946:      if (*line != '\0')
branch  0 never executed
branch  1 never executed
    #####: 9947:	error (flocp, _("Extraneous text after `%s' directive"), cmdname);
call    0 never executed
        -: 9948:      /* "Else" or "endif".  */
    #####: 9949:      if (conditionals->if_cmds == 0)
branch  0 never executed
branch  1 never executed
    #####: 9950:	fatal (flocp, _("extraneous `%s'"), cmdname);
call    0 never executed
        -: 9951:      /* NOTDEF indicates an `endif' command.  */
    #####: 9952:      if (notdef)
branch  0 never executed
branch  1 never executed
    #####: 9953:	--conditionals->if_cmds;
    #####: 9954:      else if (conditionals->seen_else[conditionals->if_cmds - 1])
branch  0 never executed
branch  1 never executed
    #####: 9955:	fatal (flocp, _("only one `else' per conditional"));
call    0 never executed
        -: 9956:      else
        -: 9957:	{
        -: 9958:	  /* Toggle the state of ignorance.  */
    #####: 9959:	  conditionals->ignoring[conditionals->if_cmds - 1]
    #####: 9960:	    = !conditionals->ignoring[conditionals->if_cmds - 1];
        -: 9961:	  /* Record that we have seen an `else' in this conditional.
        -: 9962:	     A second `else' will be erroneous.  */
    #####: 9963:	  conditionals->seen_else[conditionals->if_cmds - 1] = 1;
        -: 9964:	}
    #####: 9965:      for (i = 0; i < conditionals->if_cmds; ++i)
branch  0 never executed
branch  1 never executed
    #####: 9966:	if (conditionals->ignoring[i])
branch  0 never executed
branch  1 never executed
    #####: 9967:	  return 1;
    #####: 9968:      return 0;
        -: 9969:    }
        -: 9970:
    #####: 9971:  if (conditionals->allocated == 0)
branch  0 never executed
branch  1 never executed
        -: 9972:    {
    #####: 9973:      conditionals->allocated = 5;
    #####: 9974:      conditionals->ignoring = (char *) xmalloc (conditionals->allocated);
call    0 never executed
    #####: 9975:      conditionals->seen_else = (char *) xmalloc (conditionals->allocated);
call    0 never executed
        -: 9976:    }
        -: 9977:
    #####: 9978:  ++conditionals->if_cmds;
    #####: 9979:  if (conditionals->if_cmds > conditionals->allocated)
branch  0 never executed
branch  1 never executed
        -: 9980:    {
    #####: 9981:      conditionals->allocated += 5;
    #####: 9982:      conditionals->ignoring = (char *)
    #####: 9983:	xrealloc (conditionals->ignoring, conditionals->allocated);
call    0 never executed
    #####: 9984:      conditionals->seen_else = (char *)
    #####: 9985:	xrealloc (conditionals->seen_else, conditionals->allocated);
call    0 never executed
        -: 9986:    }
        -: 9987:
        -: 9988:  /* Record that we have seen an `if...' but no `else' so far.  */
    #####: 9989:  conditionals->seen_else[conditionals->if_cmds - 1] = 0;
        -: 9990:
        -: 9991:  /* Search through the stack to see if we're already ignoring.  */
    #####: 9992:  for (i = 0; i < conditionals->if_cmds - 1; ++i)
branch  0 never executed
branch  1 never executed
    #####: 9993:    if (conditionals->ignoring[i])
branch  0 never executed
branch  1 never executed
        -: 9994:      {
        -: 9995:	/* We are already ignoring, so just push a level
        -: 9996:	   to match the next "else" or "endif", and keep ignoring.
        -: 9997:	   We don't want to expand variables in the condition.  */
    #####: 9998:	conditionals->ignoring[conditionals->if_cmds - 1] = 1;
    #####: 9999:	return 1;
        -:10000:      }
        -:10001:
    #####:10002:  if (cmdname[notdef ? 3 : 2] == 'd')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:10003:    {
        -:10004:      /* "Ifdef" or "ifndef".  */
        -:10005:      struct variable *v;
    #####:10006:      register char *p = end_of_token (line);
call    0 never executed
    #####:10007:      i = p - line;
    #####:10008:      p = next_token (p);
call    0 never executed
    #####:10009:      if (*p != '\0')
branch  0 never executed
branch  1 never executed
    #####:10010:	return -1;
    #####:10011:      v = lookup_variable (line, i);
call    0 never executed
    #####:10012:      conditionals->ignoring[conditionals->if_cmds - 1]
    #####:10013:	= (v != 0 && *v->value != '\0') == notdef;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:10014:    }
        -:10015:  else
        -:10016:    {
        -:10017:      /* "Ifeq" or "ifneq".  */
        -:10018:      char *s1, *s2;
        -:10019:      unsigned int len;
    #####:10020:      char termin = *line == '(' ? ',' : *line;
branch  0 never executed
branch  1 never executed
        -:10021:
    #####:10022:      if (termin != ',' && termin != '"' && termin != '\'')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:10023:	return -1;
        -:10024:
    #####:10025:      s1 = ++line;
        -:10026:      /* Find the end of the first string.  */
    #####:10027:      if (termin == ',')
branch  0 never executed
branch  1 never executed
        -:10028:	{
    #####:10029:	  register int count = 0;
    #####:10030:	  for (; *line != '\0'; ++line)
branch  0 never executed
branch  1 never executed
    #####:10031:	    if (*line == '(')
branch  0 never executed
branch  1 never executed
    #####:10032:	      ++count;
    #####:10033:	    else if (*line == ')')
branch  0 never executed
branch  1 never executed
    #####:10034:	      --count;
    #####:10035:	    else if (*line == ',' && count <= 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:10036:	      break;
        -:10037:	}
        -:10038:      else
    #####:10039:	while (*line != '\0' && *line != termin)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:10040:	  ++line;
        -:10041:
    #####:10042:      if (*line == '\0')
branch  0 never executed
branch  1 never executed
    #####:10043:	return -1;
        -:10044:
    #####:10045:      if (termin == ',')
branch  0 never executed
branch  1 never executed
        -:10046:	{
        -:10047:	  /* Strip blanks after the first string.  */
    #####:10048:	  char *p = line++;
    #####:10049:	  while (isblank (p[-1]))
branch  0 never executed
branch  1 never executed
    #####:10050:	    --p;
    #####:10051:	  *p = '\0';
        -:10052:	}
        -:10053:      else
    #####:10054:	*line++ = '\0';
        -:10055:
    #####:10056:      s2 = variable_expand (s1);
call    0 never executed
        -:10057:      /* We must allocate a new copy of the expanded string because
        -:10058:	 variable_expand re-uses the same buffer.  */
    #####:10059:      len = strlen (s2);
    #####:10060:      s1 = (char *) alloca (len + 1);
    #####:10061:      bcopy (s2, s1, len + 1);
        -:10062:
    #####:10063:      if (termin != ',')
branch  0 never executed
branch  1 never executed
        -:10064:	/* Find the start of the second string.  */
    #####:10065:	line = next_token (line);
call    0 never executed
        -:10066:
    #####:10067:      termin = termin == ',' ? ')' : *line;
branch  0 never executed
branch  1 never executed
    #####:10068:      if (termin != ')' && termin != '"' && termin != '\'')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:10069:	return -1;
        -:10070:
        -:10071:      /* Find the end of the second string.  */
    #####:10072:      if (termin == ')')
branch  0 never executed
branch  1 never executed
        -:10073:	{
    #####:10074:	  register int count = 0;
    #####:10075:	  s2 = next_token (line);
call    0 never executed
    #####:10076:	  for (line = s2; *line != '\0'; ++line)
branch  0 never executed
branch  1 never executed
        -:10077:	    {
    #####:10078:	      if (*line == '(')
branch  0 never executed
branch  1 never executed
    #####:10079:		++count;
    #####:10080:	      else if (*line == ')')
branch  0 never executed
branch  1 never executed
        -:10081:		{
    #####:10082:		  if (count <= 0)
branch  0 never executed
branch  1 never executed
    #####:10083:		    break;
        -:10084:		  else
    #####:10085:		    --count;
        -:10086:		}
        -:10087:	    }
        -:10088:	}
        -:10089:      else
        -:10090:	{
    #####:10091:	  ++line;
    #####:10092:	  s2 = line;
    #####:10093:	  while (*line != '\0' && *line != termin)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:10094:	    ++line;
        -:10095:	}
        -:10096:
    #####:10097:      if (*line == '\0')
branch  0 never executed
branch  1 never executed
    #####:10098:	return -1;
        -:10099:
    #####:10100:      *line = '\0';
    #####:10101:      line = next_token (++line);
call    0 never executed
    #####:10102:      if (*line != '\0')
branch  0 never executed
branch  1 never executed
    #####:10103:	error (flocp, _("Extraneous text after `%s' directive"), cmdname);
call    0 never executed
        -:10104:
    #####:10105:      s2 = variable_expand (s2);
call    0 never executed
    #####:10106:      conditionals->ignoring[conditionals->if_cmds - 1]
    #####:10107:	= streq (s1, s2) == notdef;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -:10108:    }
        -:10109:
        -:10110:  /* Search through the stack to see if we're ignoring.  */
    #####:10111:  for (i = 0; i < conditionals->if_cmds; ++i)
branch  0 never executed
branch  1 never executed
    #####:10112:    if (conditionals->ignoring[i])
branch  0 never executed
branch  1 never executed
    #####:10113:      return 1;
    #####:10114:  return 0;
        -:10115:}
        -:10116:
        -:10117:/* Remove duplicate dependencies in CHAIN.  */
        -:10118:
        -:10119:void
function uniquize_deps called 0 returned 0% blocks executed 0%
    #####:10120:uniquize_deps (chain)
        -:10121:     struct dep *chain;
        -:10122:{
        -:10123:  register struct dep *d;
        -:10124:
        -:10125:  /* Make sure that no dependencies are repeated.  This does not
        -:10126:     really matter for the purpose of updating targets, but it
        -:10127:     might make some names be listed twice for $^ and $?.  */
        -:10128:
    #####:10129:  for (d = chain; d != 0; d = d->next)
branch  0 never executed
branch  1 never executed
        -:10130:    {
        -:10131:      struct dep *last, *next;
        -:10132:
    #####:10133:      last = d;
    #####:10134:      next = d->next;
    #####:10135:      while (next != 0)
branch  0 never executed
branch  1 never executed
    #####:10136:	if (streq (dep_name (d), dep_name (next)))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
branch 21 never executed
    #####:10137:	  {
    #####:10138:	    struct dep *n = next->next;
    #####:10139:	    last->next = n;
    #####:10140:	    if (next->name != 0 && next->name != d->name)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:10141:	      free (next->name);
    #####:10142:	    if (next != d)
branch  0 never executed
branch  1 never executed
    #####:10143:	      free ((char *) next);
    #####:10144:	    next = n;
        -:10145:	  }
        -:10146:	else
        -:10147:	  {
    #####:10148:	    last = next;
    #####:10149:	    next = next->next;
        -:10150:	  }
        -:10151:    }
    #####:10152:}
        -:10153:
        -:10154:/* Record target-specific variable values for files FILENAMES.
        -:10155:   TWO_COLON is nonzero if a double colon was used.
        -:10156:
        -:10157:   The links of FILENAMES are freed, and so are any names in it
        -:10158:   that are not incorporated into other data structures.
        -:10159:
        -:10160:   If the target is a pattern, add the variable to the pattern-specific
        -:10161:   variable value list.  */
        -:10162:
        -:10163:static void
function record_target_var called 0 returned 0% blocks executed 0%
    #####:10164:record_target_var (filenames, defn, two_colon, origin, flocp)
        -:10165:     struct nameseq *filenames;
        -:10166:     char *defn;
        -:10167:     int two_colon;
        -:10168:     enum variable_origin origin;
        -:10169:     const struct floc *flocp;
        -:10170:{
        -:10171:  struct nameseq *nextf;
        -:10172:  struct variable_set_list *global;
        -:10173:
    #####:10174:  global = current_variable_set_list;
        -:10175:
    #####:10176:  for (; filenames != 0; filenames = nextf)
branch  0 never executed
branch  1 never executed
        -:10177:    {
        -:10178:      struct variable *v;
    #####:10179:      register char *name = filenames->name;
        -:10180:      struct variable_set_list *vlist;
        -:10181:      char *fname;
        -:10182:      char *percent;
        -:10183:
    #####:10184:      nextf = filenames->next;
    #####:10185:      free ((char *) filenames);
        -:10186:
        -:10187:      /* If it's a pattern target, then add it to the pattern-specific
        -:10188:         variable list.  */
    #####:10189:      percent = find_percent (name);
call    0 never executed
    #####:10190:      if (percent)
branch  0 never executed
branch  1 never executed
        -:10191:        {
        -:10192:          struct pattern_var *p;
        -:10193:
        -:10194:          /* Get a reference for this pattern-specific variable struct.  */
    #####:10195:          p = create_pattern_var(name, percent);
call    0 never executed
    #####:10196:          vlist = p->vars;
    #####:10197:          fname = p->target;
        -:10198:        }
        -:10199:      else
        -:10200:        {
        -:10201:          struct file *f;
        -:10202:
        -:10203:          /* Get a file reference for this file, and initialize it.  */
    #####:10204:          f = enter_file (name);
call    0 never executed
    #####:10205:          initialize_file_variables (f);
call    0 never executed
    #####:10206:          vlist = f->variables;
    #####:10207:          fname = f->name;
        -:10208:        }
        -:10209:
        -:10210:      /* Make the new variable context current and define the variable.  */
    #####:10211:      current_variable_set_list = vlist;
    #####:10212:      v = try_variable_definition (flocp, defn, origin);
call    0 never executed
    #####:10213:      if (!v)
branch  0 never executed
branch  1 never executed
    #####:10214:        error (flocp, _("Malformed per-target variable definition"));
call    0 never executed
    #####:10215:      v->per_target = 1;
        -:10216:
        -:10217:      /* If it's not an override, check to see if there was a command-line
        -:10218:         setting.  If so, reset the value.  */
    #####:10219:      if (origin != o_override)
branch  0 never executed
branch  1 never executed
        -:10220:        {
        -:10221:          struct variable *gv;
    #####:10222:          int len = strlen(v->name);
        -:10223:
    #####:10224:          current_variable_set_list = global;
    #####:10225:          gv = lookup_variable (v->name, len);
call    0 never executed
    #####:10226:          if (gv && (gv->origin == o_env_override || gv->origin == o_command))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:10227:            define_variable_in_set (v->name, len, gv->value, gv->origin,
    #####:10228:                                    gv->recursive, vlist->set);
call    0 never executed
        -:10229:        }
        -:10230:
        -:10231:      /* Free name if not needed further.  */
    #####:10232:      if (name != fname && (name < fname || name > fname + strlen (fname)))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:10233:        free (name);
        -:10234:    }
        -:10235:
    #####:10236:  current_variable_set_list = global;
    #####:10237:}
        -:10238:
        -:10239:/* Record a description line for files FILENAMES,
        -:10240:   with dependencies DEPS, commands to execute described
        -:10241:   by COMMANDS and COMMANDS_IDX, coming from FILENAME:COMMANDS_STARTED.
        -:10242:   TWO_COLON is nonzero if a double colon was used.
        -:10243:   If not nil, PATTERN is the `%' pattern to make this
        -:10244:   a static pattern rule, and PATTERN_PERCENT is a pointer
        -:10245:   to the `%' within it.
        -:10246:
        -:10247:   The links of FILENAMES are freed, and so are any names in it
        -:10248:   that are not incorporated into other data structures.  */
        -:10249:
        -:10250:static void
function record_files called 0 returned 0% blocks executed 0%
    #####:10251:record_files (filenames, pattern, pattern_percent, deps, cmds_started,
        -:10252:	      commands, commands_idx, two_colon, flocp, set_default)
        -:10253:     struct nameseq *filenames;
        -:10254:     char *pattern, *pattern_percent;
        -:10255:     struct dep *deps;
        -:10256:     unsigned int cmds_started;
        -:10257:     char *commands;
        -:10258:     unsigned int commands_idx;
        -:10259:     int two_colon;
        -:10260:     const struct floc *flocp;
        -:10261:     int set_default;
        -:10262:{
        -:10263:  struct nameseq *nextf;
    #####:10264:  int implicit = 0;
    #####:10265:  unsigned int max_targets = 0, target_idx = 0;
    #####:10266:  char **targets = 0, **target_percents = 0;
        -:10267:  struct commands *cmds;
        -:10268:
    #####:10269:  if (commands_idx > 0)
branch  0 never executed
branch  1 never executed
        -:10270:    {
    #####:10271:      cmds = (struct commands *) xmalloc (sizeof (struct commands));
call    0 never executed
    #####:10272:      cmds->fileinfo.filenm = flocp->filenm;
    #####:10273:      cmds->fileinfo.lineno = cmds_started;
    #####:10274:      cmds->commands = savestring (commands, commands_idx);
call    0 never executed
    #####:10275:      cmds->command_lines = 0;
        -:10276:    }
        -:10277:  else
    #####:10278:    cmds = 0;
        -:10279:
    #####:10280:  for (; filenames != 0; filenames = nextf)
branch  0 never executed
branch  1 never executed
        -:10281:    {
        -:10282:
    #####:10283:      register char *name = filenames->name;
        -:10284:      register struct file *f;
        -:10285:      register struct dep *d;
        -:10286:      struct dep *this;
        -:10287:      char *implicit_percent;
        -:10288:
    #####:10289:      nextf = filenames->next;
    #####:10290:      free ((char *) filenames);
        -:10291:
    #####:10292:      implicit_percent = find_percent (name);
call    0 never executed
    #####:10293:      implicit |= implicit_percent != 0;
        -:10294:
    #####:10295:      if (implicit && pattern != 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:10296:	fatal (flocp, _("mixed implicit and static pattern rules"));
call    0 never executed
        -:10297:
    #####:10298:      if (implicit && implicit_percent == 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:10299:	fatal (flocp, _("mixed implicit and normal rules"));
call    0 never executed
        -:10300:
    #####:10301:      if (implicit)
branch  0 never executed
branch  1 never executed
        -:10302:	{
    #####:10303:	  if (targets == 0)
branch  0 never executed
branch  1 never executed
        -:10304:	    {
    #####:10305:	      max_targets = 5;
    #####:10306:	      targets = (char **) xmalloc (5 * sizeof (char *));
call    0 never executed
    #####:10307:	      target_percents = (char **) xmalloc (5 * sizeof (char *));
call    0 never executed
    #####:10308:	      target_idx = 0;
        -:10309:	    }
    #####:10310:	  else if (target_idx == max_targets - 1)
branch  0 never executed
branch  1 never executed
        -:10311:	    {
    #####:10312:	      max_targets += 5;
    #####:10313:	      targets = (char **) xrealloc ((char *) targets,
call    0 never executed
        -:10314:					    max_targets * sizeof (char *));
        -:10315:	      target_percents
    #####:10316:		= (char **) xrealloc ((char *) target_percents,
call    0 never executed
        -:10317:				      max_targets * sizeof (char *));
        -:10318:	    }
    #####:10319:	  targets[target_idx] = name;
    #####:10320:	  target_percents[target_idx] = implicit_percent;
    #####:10321:	  ++target_idx;
    #####:10322:	  continue;
        -:10323:	}
        -:10324:
        -:10325:      /* If there are multiple filenames, copy the chain DEPS
        -:10326:	 for all but the last one.  It is not safe for the same deps
        -:10327:	 to go in more than one place in the data base.  */
    #####:10328:      this = nextf != 0 ? copy_dep_chain (deps) : deps;
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:10329:
    #####:10330:      if (pattern != 0)
branch  0 never executed
branch  1 never executed
        -:10331:	{
        -:10332:	  /* If this is an extended static rule:
        -:10333:	     `targets: target%pattern: dep%pattern; cmds',
        -:10334:	     translate each dependency pattern into a plain filename
        -:10335:	     using the target pattern and this target's name.  */
    #####:10336:	  if (!pattern_matches (pattern, pattern_percent, name))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:10337:	    {
        -:10338:	      /* Give a warning if the rule is meaningless.  */
    #####:10339:	      error (flocp,
call    0 never executed
        -:10340:		     _("target `%s' doesn't match the target pattern"), name);
    #####:10341:	      this = 0;
        -:10342:	    }
        -:10343:	  else
        -:10344:	    {
        -:10345:	      /* We use patsubst_expand to do the work of translating
        -:10346:		 the target pattern, the target's name and the dependencies'
        -:10347:		 patterns into plain dependency names.  */
    #####:10348:	      char *buffer = variable_expand ("");
call    0 never executed
        -:10349:
    #####:10350:	      for (d = this; d != 0; d = d->next)
branch  0 never executed
branch  1 never executed
        -:10351:		{
        -:10352:		  char *o;
    #####:10353:		  char *percent = find_percent (d->name);
call    0 never executed
    #####:10354:		  if (percent == 0)
branch  0 never executed
branch  1 never executed
    #####:10355:		    continue;
    #####:10356:		  o = patsubst_expand (buffer, name, pattern, d->name,
call    0 never executed
        -:10357:				       pattern_percent, percent);
    #####:10358:		  free (d->name);
    #####:10359:		  d->name = savestring (buffer, o - buffer);
call    0 never executed
        -:10360:		}
        -:10361:	    }
        -:10362:	}
        -:10363:
    #####:10364:      if (!two_colon)
branch  0 never executed
branch  1 never executed
        -:10365:	{
        -:10366:	  /* Single-colon.  Combine these dependencies
        -:10367:	     with others in file's existing record, if any.  */
    #####:10368:	  f = enter_file (name);
call    0 never executed
        -:10369:
    #####:10370:	  if (f->double_colon)
branch  0 never executed
branch  1 never executed
    #####:10371:	    fatal (flocp,
call    0 never executed
        -:10372:                   _("target file `%s' has both : and :: entries"), f->name);
        -:10373:
        -:10374:	  /* If CMDS == F->CMDS, this target was listed in this rule
        -:10375:	     more than once.  Just give a warning since this is harmless.  */
    #####:10376:	  if (cmds != 0 && cmds == f->cmds)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:10377:	    error (flocp, _("target `%s' given more than once in the same rule."),
call    0 never executed
        -:10378:                   f->name);
        -:10379:
        -:10380:	  /* Check for two single-colon entries both with commands.
        -:10381:	     Check is_target so that we don't lose on files such as .c.o
        -:10382:	     whose commands were preinitialized.  */
    #####:10383:	  else if (cmds != 0 && f->cmds != 0 && f->is_target)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:10384:	    {
    #####:10385:	      error (&cmds->fileinfo,
call    0 never executed
        -:10386:                     _("warning: overriding commands for target `%s'"), f->name);
    #####:10387:	      error (&f->cmds->fileinfo,
call    0 never executed
        -:10388:                     _("warning: ignoring old commands for target `%s'"),
        -:10389:                     f->name);
        -:10390:	    }
        -:10391:
    #####:10392:	  f->is_target = 1;
        -:10393:
        -:10394:	  /* Defining .DEFAULT with no deps or cmds clears it.  */
    #####:10395:	  if (f == default_file && this == 0 && cmds == 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:10396:	    f->cmds = 0;
    #####:10397:	  if (cmds != 0)
branch  0 never executed
branch  1 never executed
    #####:10398:	    f->cmds = cmds;
        -:10399:	  /* Defining .SUFFIXES with no dependencies
        -:10400:	     clears out the list of suffixes.  */
    #####:10401:	  if (f == suffix_file && this == 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:10402:	    {
    #####:10403:	      d = f->deps;
    #####:10404:	      while (d != 0)
branch  0 never executed
branch  1 never executed
        -:10405:		{
    #####:10406:		  struct dep *nextd = d->next;
    #####:10407: 		  free (d->name);
    #####:10408: 		  free ((char *)d);
    #####:10409:		  d = nextd;
        -:10410:		}
    #####:10411:	      f->deps = 0;
        -:10412:	    }
    #####:10413:	  else if (f->deps != 0)
branch  0 never executed
branch  1 never executed
        -:10414:	    {
        -:10415:	      /* Add the file's old deps and the new ones in THIS together.  */
        -:10416:
        -:10417:	      struct dep *firstdeps, *moredeps;
    #####:10418:	      if (cmds != 0)
branch  0 never executed
branch  1 never executed
        -:10419:		{
        -:10420:		  /* This is the rule with commands, so put its deps first.
        -:10421:		     The rationale behind this is that $< expands to the
        -:10422:		     first dep in the chain, and commands use $< expecting
        -:10423:		     to get the dep that rule specifies.  */
    #####:10424:		  firstdeps = this;
    #####:10425:		  moredeps = f->deps;
        -:10426:		}
        -:10427:	      else
        -:10428:		{
        -:10429:		  /* Append the new deps to the old ones.  */
    #####:10430:		  firstdeps = f->deps;
    #####:10431:		  moredeps = this;
        -:10432:		}
        -:10433:
    #####:10434:	      if (firstdeps == 0)
branch  0 never executed
branch  1 never executed
    #####:10435:		firstdeps = moredeps;
        -:10436:	      else
        -:10437:		{
    #####:10438:		  d = firstdeps;
    #####:10439:		  while (d->next != 0)
branch  0 never executed
branch  1 never executed
    #####:10440:		    d = d->next;
    #####:10441:		  d->next = moredeps;
        -:10442:		}
        -:10443:
    #####:10444:	      f->deps = firstdeps;
        -:10445:	    }
        -:10446:	  else
    #####:10447:	    f->deps = this;
        -:10448:
        -:10449:	  /* If this is a static pattern rule, set the file's stem to
        -:10450:	     the part of its name that matched the `%' in the pattern,
        -:10451:	     so you can use $* in the commands.  */
    #####:10452:	  if (pattern != 0)
branch  0 never executed
branch  1 never executed
        -:10453:	    {
        -:10454:	      static char *percent = "%";
    #####:10455:	      char *buffer = variable_expand ("");
call    0 never executed
    #####:10456:	      char *o = patsubst_expand (buffer, name, pattern, percent,
call    0 never executed
        -:10457:					 pattern_percent, percent);
    #####:10458:	      f->stem = savestring (buffer, o - buffer);
call    0 never executed
        -:10459:	    }
        -:10460:	}
        -:10461:      else
        -:10462:	{
        -:10463:	  /* Double-colon.  Make a new record
        -:10464:	     even if the file already has one.  */
    #####:10465:	  f = lookup_file (name);
call    0 never executed
        -:10466:	  /* Check for both : and :: rules.  Check is_target so
        -:10467:	     we don't lose on default suffix rules or makefiles.  */
    #####:10468:	  if (f != 0 && f->is_target && !f->double_colon)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:10469:	    fatal (flocp,
call    0 never executed
        -:10470:                   _("target file `%s' has both : and :: entries"), f->name);
    #####:10471:	  f = enter_file (name);
call    0 never executed
        -:10472:	  /* If there was an existing entry and it was a double-colon
        -:10473:	     entry, enter_file will have returned a new one, making it the
        -:10474:	     prev pointer of the old one, and setting its double_colon
        -:10475:	     pointer to the first one.  */
    #####:10476:	  if (f->double_colon == 0)
branch  0 never executed
branch  1 never executed
        -:10477:	    /* This is the first entry for this name, so we must
        -:10478:	       set its double_colon pointer to itself.  */
    #####:10479:	    f->double_colon = f;
    #####:10480:	  f->is_target = 1;
    #####:10481:	  f->deps = this;
    #####:10482:	  f->cmds = cmds;
        -:10483:	}
        -:10484:
        -:10485:      /* Free name if not needed further.  */
    #####:10486:      if (f != 0 && name != f->name
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:10487:	  && (name < f->name || name > f->name + strlen (f->name)))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:10488:	{
    #####:10489:	  free (name);
    #####:10490:	  name = f->name;
        -:10491:	}
        -:10492:
        -:10493:      /* See if this is first target seen whose name does
        -:10494:	 not start with a `.', unless it contains a slash.  */
    #####:10495:      if (default_goal_file == 0 && set_default
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:10496:	  && (*name != '.' || index (name, '/') != 0
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:10497:#if defined(__MSDOS__) || defined(WINDOWS32)
        -:10498:			   || index (name, '\\') != 0
        -:10499:#endif
        -:10500:	      ))
        -:10501:	{
    #####:10502:	  int reject = 0;
        -:10503:
        -:10504:	  /* If this file is a suffix, don't
        -:10505:	     let it be the default goal file.  */
        -:10506:
    #####:10507:	  for (d = suffix_file->deps; d != 0; d = d->next)
branch  0 never executed
branch  1 never executed
        -:10508:	    {
        -:10509:	      register struct dep *d2;
    #####:10510:	      if (*dep_name (d) != '.' && streq (name, dep_name (d)))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
        -:10511:		{
    #####:10512:		  reject = 1;
    #####:10513:		  break;
        -:10514:		}
    #####:10515:	      for (d2 = suffix_file->deps; d2 != 0; d2 = d2->next)
branch  0 never executed
branch  1 never executed
        -:10516:		{
    #####:10517:		  register unsigned int len = strlen (dep_name (d2));
branch  0 never executed
branch  1 never executed
    #####:10518:		  if (!strneq (name, dep_name (d2), len))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:10519:		    continue;
    #####:10520:		  if (streq (name + len, dep_name (d)))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
        -:10521:		    {
    #####:10522:		      reject = 1;
    #####:10523:		      break;
        -:10524:		    }
        -:10525:		}
    #####:10526:	      if (reject)
branch  0 never executed
branch  1 never executed
    #####:10527:		break;
        -:10528:	    }
        -:10529:
    #####:10530:	  if (!reject)
branch  0 never executed
branch  1 never executed
    #####:10531:	    default_goal_file = f;
        -:10532:	}
        -:10533:    }
        -:10534:
    #####:10535:  if (implicit)
branch  0 never executed
branch  1 never executed
        -:10536:    {
    #####:10537:      targets[target_idx] = 0;
    #####:10538:      target_percents[target_idx] = 0;
    #####:10539:      create_pattern_rule (targets, target_percents, two_colon, deps, cmds, 1);
call    0 never executed
    #####:10540:      free ((char *) target_percents);
        -:10541:    }
    #####:10542:}
        -:10543:
        -:10544:/* Search STRING for an unquoted STOPCHAR or blank (if BLANK is nonzero).
        -:10545:   Backslashes quote STOPCHAR, blanks if BLANK is nonzero, and backslash.
        -:10546:   Quoting backslashes are removed from STRING by compacting it into
        -:10547:   itself.  Returns a pointer to the first unquoted STOPCHAR if there is
        -:10548:   one, or nil if there are none.  */
        -:10549:
        -:10550:char *
function find_char_unquote called 40092 returned 100% blocks executed 58%
    40092:10551:find_char_unquote (string, stopchars, blank)
        -:10552:     char *string;
        -:10553:     char *stopchars;
        -:10554:     int blank;
        -:10555:{
    40092:10556:  unsigned int string_len = 0;
    40092:10557:  register char *p = string;
        -:10558:
        -:10559:  while (1)
        -:10560:    {
  185811*:10561:      while (*p != '\0' && index (stopchars, *p) == 0
branch  0 taken 138780 (fallthrough)
branch  1 taken 6939
   292209:10562:	     && (!blank || !isblank (*p)))
branch  0 taken 145719 (fallthrough)
branch  1 taken 7710
branch  2 taken 771
branch  3 taken 138009 (fallthrough)
branch  4 taken 112566
branch  5 taken 25443 (fallthrough)
   113337:10563:	++p;
    40092:10564:      if (*p == '\0')
branch  0 taken 7710 (fallthrough)
branch  1 taken 32382
     7710:10565:	break;
        -:10566:
    32382:10567:      if (p > string && p[-1] == '\\')
branch  0 taken 26214 (fallthrough)
branch  1 taken 6168
branch  2 taken 0 (fallthrough)
branch  3 taken 26214
    #####:10568:	{
        -:10569:	  /* Search for more backslashes.  */
    #####:10570:	  register int i = -2;
    #####:10571:	  while (&p[i] >= string && p[i] == '\\')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:10572:	    --i;
    #####:10573:	  ++i;
        -:10574:	  /* Only compute the length if really needed.  */
    #####:10575:	  if (string_len == 0)
branch  0 never executed
branch  1 never executed
    #####:10576:	    string_len = strlen (string);
        -:10577:	  /* The number of backslashes is now -I.
        -:10578:	     Copy P over itself to swallow half of them.  */
    #####:10579:	  bcopy (&p[i / 2], &p[i], (string_len - (p - string)) - (i / 2) + 1);
    #####:10580:	  p += i / 2;
    #####:10581:	  if (i % 2 == 0)
branch  0 never executed
branch  1 never executed
        -:10582:	    /* All the backslashes quoted each other; the STOPCHAR was
        -:10583:	       unquoted.  */
    #####:10584:	    return p;
        -:10585:
        -:10586:	  /* The STOPCHAR was quoted by a backslash.  Look for another.  */
        -:10587:	}
        -:10588:      else
        -:10589:	/* No backslash in sight.  */
    32382:10590:	return p;
        -:10591:    }
        -:10592:
        -:10593:  /* Never hit a STOPCHAR or blank (with BLANK nonzero).  */
     7710:10594:  return 0;
        -:10595:}
        -:10596:
        -:10597:/* Search PATTERN for an unquoted %.  */
        -:10598:
        -:10599:char *
function find_percent called 6939 returned 100% blocks executed 100%
     6939:10600:find_percent (pattern)
        -:10601:     char *pattern;
        -:10602:{
     6939:10603:  return find_char_unquote (pattern, "%", 0);
call    0 returned 6939
        -:10604:}
        -:10605:
        -:10606:/* Parse a string into a sequence of filenames represented as a
        -:10607:   chain of struct nameseq's in reverse order and return that chain.
        -:10608:
        -:10609:   The string is passed as STRINGP, the address of a string pointer.
        -:10610:   The string pointer is updated to point at the first character
        -:10611:   not parsed, which either is a null char or equals STOPCHAR.
        -:10612:
        -:10613:   SIZE is how big to construct chain elements.
        -:10614:   This is useful if we want them actually to be other structures
        -:10615:   that have room for additional info.
        -:10616:
        -:10617:   If STRIP is nonzero, strip `./'s off the beginning.  */
        -:10618:
        -:10619:struct nameseq *
function parse_file_seq called 7710 returned 100% blocks executed 44%
     7710:10620:parse_file_seq (stringp, stopchar, size, strip)
        -:10621:     char **stringp;
        -:10622:     int stopchar;
        -:10623:     unsigned int size;
        -:10624:     int strip;
        -:10625:{
     7710:10626:  register struct nameseq *new = 0;
        -:10627:  register struct nameseq *new1, *lastnew1;
     7710:10628:  register char *p = *stringp;
        -:10629:  char *q;
        -:10630:  char *name;
        -:10631:  char stopchars[3];
        -:10632:
        -:10633:#ifdef VMS
        -:10634:  stopchars[0] = ',';
        -:10635:  stopchars[1] = stopchar;
        -:10636:  stopchars[2] = '\0';
        -:10637:#else
     7710:10638:  stopchars[0] = stopchar;
     7710:10639:  stopchars[1] = '\0';
        -:10640:#endif
        -:10641:
        -:10642:  while (1)
        -:10643:    {
        -:10644:      /* Skip whitespace; see if any more names are left.  */
    40863:10645:      p = next_token (p);
call    0 returned 40863
    40863:10646:      if (*p == '\0')
branch  0 taken 7710 (fallthrough)
branch  1 taken 33153
     7710:10647:	break;
    33153:10648:      if (*p == stopchar)
branch  0 taken 0 (fallthrough)
branch  1 taken 33153
    #####:10649:	break;
        -:10650:
        -:10651:      /* Yes, find end of next name.  */
    33153:10652:      q = p;
    33153:10653:      p = find_char_unquote (q, stopchars, 1);
call    0 returned 33153
        -:10654:#ifdef VMS
        -:10655:	/* convert comma separated list to space separated */
        -:10656:      if (p && *p == ',')
        -:10657:	*p =' ';
        -:10658:#endif
        -:10659:#ifdef _AMIGA
        -:10660:      if (stopchar == ':' && p && *p == ':' &&
        -:10661:	!(isspace(p[1]) || !p[1] || isspace(p[-1])))
        -:10662:      {
        -:10663:	p = find_char_unquote (p+1, stopchars, 1);
        -:10664:      }
        -:10665:#endif
        -:10666:#if defined(WINDOWS32) || defined(__MSDOS__)
        -:10667:    /* For WINDOWS32, skip a "C:\..." or a "C:/..." until we find the
        -:10668:       first colon which isn't followed by a slash or a backslash.
        -:10669:       Note that tokens separated by spaces should be treated as separate
        -:10670:       tokens since make doesn't allow path names with spaces */
        -:10671:    if (stopchar == ':')
        -:10672:      while (p != 0 && !isspace(*p) &&
        -:10673:             (p[1] == '\\' || p[1] == '/') && isalpha (p[-1]))
        -:10674:        p = find_char_unquote (p + 1, stopchars, 1);
        -:10675:#endif
    33153:10676:      if (p == 0)
branch  0 taken 7710 (fallthrough)
branch  1 taken 25443
     7710:10677:	p = q + strlen (q);
        -:10678:
    33153:10679:      if (strip)
branch  0 taken 33153 (fallthrough)
branch  1 taken 0
        -:10680:#ifdef VMS
        -:10681:	/* Skip leading `[]'s.  */
        -:10682:	while (p - q > 2 && q[0] == '[' && q[1] == ']')
        -:10683:#else
        -:10684:	/* Skip leading `./'s.  */
    33153:10685:	while (p - q > 2 && q[0] == '.' && q[1] == '/')
branch  0 taken 20817 (fallthrough)
branch  1 taken 12336
branch  2 taken 13878 (fallthrough)
branch  3 taken 6939
branch  4 taken 0
branch  5 taken 13878 (fallthrough)
        -:10686:#endif
        -:10687:	  {
    #####:10688:	    q += 2;		/* Skip "./".  */
    #####:10689:	    while (q < p && *q == '/')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:10690:	      /* Skip following slashes: ".//foo" is "foo", not "/foo".  */
    #####:10691:	      ++q;
        -:10692:	  }
        -:10693:
        -:10694:      /* Extract the filename just found, and skip it.  */
        -:10695:
    33153:10696:      if (q == p)
branch  0 taken 0 (fallthrough)
branch  1 taken 33153
        -:10697:	/* ".///" was stripped to "". */
        -:10698:#ifdef VMS
        -:10699:	continue;
        -:10700:#else
        -:10701:#ifdef _AMIGA
        -:10702:	name = savestring ("", 0);
        -:10703:#else
    #####:10704:	name = savestring ("./", 2);
call    0 never executed
        -:10705:#endif
        -:10706:#endif
        -:10707:      else
        -:10708:#ifdef VMS
        -:10709:/* VMS filenames can have a ':' in them but they have to be '\'ed but we need
        -:10710: *  to remove this '\' before we can use the filename.
        -:10711: * Savestring called because q may be read-only string constant.
        -:10712: */
        -:10713:	{
        -:10714:	  char *qbase = xstrdup (q);
        -:10715:	  char *pbase = qbase + (p-q);
        -:10716:	  char *q1 = qbase;
        -:10717:	  char *q2 = q1;
        -:10718:	  char *p1 = pbase;
        -:10719:
        -:10720:	  while (q1 != pbase)
        -:10721:	    {
        -:10722:	      if (*q1 == '\\' && *(q1+1) == ':')
        -:10723:		{
        -:10724:		  q1++;
        -:10725:		  p1--;
        -:10726:		}
        -:10727:	      *q2++ = *q1++;
        -:10728:	    }
        -:10729:	  name = savestring (qbase, p1 - qbase);
        -:10730:	  free (qbase);
        -:10731:	}
        -:10732:#else
    33153:10733:	name = savestring (q, p - q);
call    0 returned 33153
        -:10734:#endif
        -:10735:
        -:10736:      /* Add it to the front of the chain.  */
    33153:10737:      new1 = (struct nameseq *) xmalloc (size);
call    0 returned 33153
    33153:10738:      new1->name = name;
    33153:10739:      new1->next = new;
    33153:10740:      new = new1;
        -:10741:    }
        -:10742:
        -:10743:#ifndef NO_ARCHIVES
        -:10744:
        -:10745:  /* Look for multi-word archive references.
        -:10746:     They are indicated by a elt ending with an unmatched `)' and
        -:10747:     an elt further down the chain (i.e., previous in the file list)
        -:10748:     with an unmatched `(' (e.g., "lib(mem").  */
        -:10749:
     7710:10750:  new1 = new;
     7710:10751:  lastnew1 = 0;
    40863:10752:  while (new1 != 0)
branch  0 taken 33153
branch  1 taken 7710 (fallthrough)
    33153:10753:    if (new1->name[0] != '('	/* Don't catch "(%)" and suchlike.  */
branch  0 taken 33153 (fallthrough)
branch  1 taken 0
    33153:10754:	&& new1->name[strlen (new1->name) - 1] == ')'
branch  0 taken 0 (fallthrough)
branch  1 taken 33153
    #####:10755:	&& index (new1->name, '(') == 0)
branch  0 never executed
branch  1 never executed
    #####:10756:      {
        -:10757:	/* NEW1 ends with a `)' but does not contain a `('.
        -:10758:	   Look back for an elt with an opening `(' but no closing `)'.  */
        -:10759:
    #####:10760:	struct nameseq *n = new1->next, *lastn = new1;
    #####:10761:	char *paren = 0;
    #####:10762:	while (n != 0 && (paren = index (n->name, '(')) == 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:10763:	  {
    #####:10764:	    lastn = n;
    #####:10765:	    n = n->next;
        -:10766:	  }
    #####:10767:	if (n != 0
branch  0 never executed
branch  1 never executed
        -:10768:	    /* Ignore something starting with `(', as that cannot actually
        -:10769:	       be an archive-member reference (and treating it as such
        -:10770:	       results in an empty file name, which causes much lossage).  */
    #####:10771:	    && n->name[0] != '(')
branch  0 never executed
branch  1 never executed
    #####:10772:	  {
        -:10773:	    /* N is the first element in the archive group.
        -:10774:	       Its name looks like "lib(mem" (with no closing `)').  */
        -:10775:
        -:10776:	    char *libname;
        -:10777:
        -:10778:	    /* Copy "lib(" into LIBNAME.  */
    #####:10779:	    ++paren;
    #####:10780:	    libname = (char *) alloca (paren - n->name + 1);
    #####:10781:	    bcopy (n->name, libname, paren - n->name);
    #####:10782:	    libname[paren - n->name] = '\0';
        -:10783:
    #####:10784:	    if (*paren == '\0')
branch  0 never executed
branch  1 never executed
        -:10785:	      {
        -:10786:		/* N was just "lib(", part of something like "lib( a b)".
        -:10787:		   Edit it out of the chain and free its storage.  */
    #####:10788:		lastn->next = n->next;
    #####:10789:		free (n->name);
    #####:10790:		free ((char *) n);
        -:10791:		/* LASTN->next is the new stopping elt for the loop below.  */
    #####:10792:		n = lastn->next;
        -:10793:	      }
        -:10794:	    else
        -:10795:	      {
        -:10796:		/* Replace N's name with the full archive reference.  */
    #####:10797:		name = concat (libname, paren, ")");
call    0 never executed
    #####:10798:		free (n->name);
    #####:10799:		n->name = name;
        -:10800:	      }
        -:10801:
    #####:10802:	    if (new1->name[1] == '\0')
branch  0 never executed
branch  1 never executed
        -:10803:	      {
        -:10804:		/* NEW1 is just ")", part of something like "lib(a b )".
        -:10805:		   Omit it from the chain and free its storage.  */
    #####:10806:		if (lastnew1 == 0)
branch  0 never executed
branch  1 never executed
    #####:10807:		  new = new1->next;
        -:10808:		else
    #####:10809:		  lastnew1->next = new1->next;
    #####:10810:		lastn = new1;
    #####:10811:		new1 = new1->next;
    #####:10812:		free (lastn->name);
    #####:10813:		free ((char *) lastn);
        -:10814:	      }
        -:10815:	    else
        -:10816:	      {
        -:10817:		/* Replace also NEW1->name, which already has closing `)'.  */
    #####:10818:		name = concat (libname, new1->name, "");
call    0 never executed
    #####:10819:		free (new1->name);
    #####:10820:		new1->name = name;
    #####:10821:		new1 = new1->next;
        -:10822:	      }
        -:10823:
        -:10824:	    /* Trace back from NEW1 (the end of the list) until N
        -:10825:	       (the beginning of the list), rewriting each name
        -:10826:	       with the full archive reference.  */
        -:10827:
    #####:10828:	    while (new1 != n)
branch  0 never executed
branch  1 never executed
        -:10829:	      {
    #####:10830:		name = concat (libname, new1->name, ")");
call    0 never executed
    #####:10831:		free (new1->name);
    #####:10832:		new1->name = name;
    #####:10833:		lastnew1 = new1;
    #####:10834:		new1 = new1->next;
        -:10835:	      }
        -:10836:	  }
        -:10837:	else
        -:10838:	  {
        -:10839:	    /* No frobnication happening.  Just step down the list.  */
    #####:10840:	    lastnew1 = new1;
    #####:10841:	    new1 = new1->next;
        -:10842:	  }
        -:10843:      }
        -:10844:    else
        -:10845:      {
    33153:10846:	lastnew1 = new1;
    33153:10847:	new1 = new1->next;
        -:10848:      }
        -:10849:
        -:10850:#endif
        -:10851:
     7710:10852:  *stringp = p;
     7710:10853:  return new;
        -:10854:}
        -:10855:
        -:10856:/* Read a line of text from STREAM into LINEBUFFER.
        -:10857:   Combine continuation lines into one line.
        -:10858:   Return the number of actual lines read (> 1 if hacked continuation lines).
        -:10859: */
        -:10860:
        -:10861:static unsigned long
function readline called 0 returned 0% blocks executed 0%
    #####:10862:readline (linebuffer, stream, flocp)
        -:10863:     struct linebuffer *linebuffer;
        -:10864:     FILE *stream;
        -:10865:     const struct floc *flocp;
        -:10866:{
    #####:10867:  char *buffer = linebuffer->buffer;
    #####:10868:  register char *p = linebuffer->buffer;
    #####:10869:  register char *end = p + linebuffer->size;
    #####:10870:  register int len, lastlen = 0;
        -:10871:  register char *p2;
    #####:10872:  register unsigned int nlines = 0;
        -:10873:  register int backslash;
        -:10874:
    #####:10875:  *p = '\0';
        -:10876:
    #####:10877:  while (fgets (p, end - p, stream) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:10878:    {
    #####:10879:      len = strlen (p);
    #####:10880:      if (len == 0)
branch  0 never executed
branch  1 never executed
        -:10881:	{
        -:10882:	  /* This only happens when the first thing on the line is a '\0'.
        -:10883:	     It is a pretty hopeless case, but (wonder of wonders) Athena
        -:10884:	     lossage strikes again!  (xmkmf puts NULs in its makefiles.)
        -:10885:	     There is nothing really to be done; we synthesize a newline so
        -:10886:	     the following line doesn't appear to be part of this line.  */
    #####:10887:	  error (flocp, _("warning: NUL character seen; rest of line ignored"));
call    0 never executed
    #####:10888:	  p[0] = '\n';
    #####:10889:	  len = 1;
        -:10890:	}
        -:10891:
    #####:10892:      p += len;
    #####:10893:      if (p[-1] != '\n')
branch  0 never executed
branch  1 never executed
    #####:10894:	{
        -:10895:	  /* Probably ran out of buffer space.  */
    #####:10896:	  register unsigned int p_off = p - buffer;
    #####:10897:	  linebuffer->size *= 2;
    #####:10898:	  buffer = (char *) xrealloc (buffer, linebuffer->size);
call    0 never executed
    #####:10899:	  p = buffer + p_off;
    #####:10900:	  end = buffer + linebuffer->size;
    #####:10901:	  linebuffer->buffer = buffer;
    #####:10902:	  *p = '\0';
    #####:10903:	  lastlen = len;
    #####:10904:	  continue;
        -:10905:	}
        -:10906:
    #####:10907:      ++nlines;
        -:10908:
        -:10909:#if !defined(WINDOWS32) && !defined(__MSDOS__)
        -:10910:      /* Check to see if the line was really ended with CRLF; if so ignore
        -:10911:         the CR.  */
    #####:10912:      if (len > 1 && p[-2] == '\r')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:10913:        {
    #####:10914:          --len;
    #####:10915:          --p;
    #####:10916:          p[-1] = '\n';
        -:10917:        }
        -:10918:#endif
        -:10919:
    #####:10920:      if (len == 1 && p > buffer)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:10921:	/* P is pointing at a newline and it's the beginning of
        -:10922:	   the buffer returned by the last fgets call.  However,
        -:10923:	   it is not necessarily the beginning of a line if P is
        -:10924:	   pointing past the beginning of the holding buffer.
        -:10925:	   If the buffer was just enlarged (right before the newline),
        -:10926:	   we must account for that, so we pretend that the two lines
        -:10927:	   were one line.  */
    #####:10928:	len += lastlen;
    #####:10929:      lastlen = len;
    #####:10930:      backslash = 0;
    #####:10931:      for (p2 = p - 2; --len > 0; --p2)
branch  0 never executed
branch  1 never executed
        -:10932:	{
    #####:10933:	  if (*p2 == '\\')
branch  0 never executed
branch  1 never executed
    #####:10934:	    backslash = !backslash;
        -:10935:	  else
    #####:10936:	    break;
        -:10937:	}
        -:10938:
    #####:10939:      if (!backslash)
branch  0 never executed
branch  1 never executed
        -:10940:	{
    #####:10941:	  p[-1] = '\0';
    #####:10942:	  break;
        -:10943:	}
        -:10944:
    #####:10945:      if (end - p <= 1)
branch  0 never executed
branch  1 never executed
        -:10946:	{
        -:10947:	  /* Enlarge the buffer.  */
    #####:10948:	  register unsigned int p_off = p - buffer;
    #####:10949:	  linebuffer->size *= 2;
    #####:10950:	  buffer = (char *) xrealloc (buffer, linebuffer->size);
call    0 never executed
    #####:10951:	  p = buffer + p_off;
    #####:10952:	  end = buffer + linebuffer->size;
    #####:10953:	  linebuffer->buffer = buffer;
        -:10954:	}
        -:10955:    }
        -:10956:
    #####:10957:  if (ferror (stream))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:10958:    pfatal_with_name (flocp->filenm);
call    0 never executed
        -:10959:
    #####:10960:  return nlines;
        -:10961:}
        -:10962:
        -:10963:/* Parse the next "makefile word" from the input buffer, and return info
        -:10964:   about it.
        -:10965:
        -:10966:   A "makefile word" is one of:
        -:10967:
        -:10968:     w_bogus        Should never happen
        -:10969:     w_eol          End of input
        -:10970:     w_static       A static word; cannot be expanded
        -:10971:     w_variable     A word containing one or more variables/functions
        -:10972:     w_colon        A colon
        -:10973:     w_dcolon       A double-colon
        -:10974:     w_semicolon    A semicolon
        -:10975:     w_comment      A comment character
        -:10976:     w_varassign    A variable assignment operator (=, :=, +=, or ?=)
        -:10977:
        -:10978:   Note that this function is only used when reading certain parts of the
        -:10979:   makefile.  Don't use it where special rules hold sway (RHS of a variable,
        -:10980:   in a command list, etc.)  */
        -:10981:
        -:10982:static enum make_word_type
function get_next_mword called 0 returned 0% blocks executed 0%
    #####:10983:get_next_mword (buffer, delim, startp, length)
        -:10984:     char *buffer;
        -:10985:     char *delim;
        -:10986:     char **startp;
        -:10987:     unsigned int *length;
        -:10988:{
    #####:10989:  enum make_word_type wtype = w_bogus;
    #####:10990:  char *p = buffer, *beg;
        -:10991:  char c;
        -:10992:
        -:10993:  /* Skip any leading whitespace.  */
    #####:10994:  while (isblank(*p))
branch  0 never executed
branch  1 never executed
    #####:10995:    ++p;
        -:10996:
    #####:10997:  beg = p;
    #####:10998:  c = *(p++);
    #####:10999:  switch (c)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
        -:11000:    {
    #####:11001:    case '\0':
    #####:11002:      wtype = w_eol;
    #####:11003:      break;
        -:11004:
    #####:11005:    case '#':
    #####:11006:      wtype = w_comment;
    #####:11007:      break;
        -:11008:
    #####:11009:    case ';':
    #####:11010:      wtype = w_semicolon;
    #####:11011:      break;
        -:11012:
    #####:11013:    case '=':
    #####:11014:      wtype = w_varassign;
    #####:11015:      break;
        -:11016:
    #####:11017:    case ':':
    #####:11018:      wtype = w_colon;
    #####:11019:      switch (*p)
branch  0 never executed
branch  1 never executed
branch  2 never executed
        -:11020:        {
    #####:11021:        case ':':
    #####:11022:          ++p;
    #####:11023:          wtype = w_dcolon;
    #####:11024:          break;
        -:11025:
    #####:11026:        case '=':
    #####:11027:          ++p;
    #####:11028:          wtype = w_varassign;
    #####:11029:          break;
        -:11030:        }
    #####:11031:      break;
        -:11032:
    #####:11033:    case '+':
        -:11034:    case '?':
    #####:11035:      if (*p == '=')
branch  0 never executed
branch  1 never executed
        -:11036:        {
    #####:11037:          ++p;
    #####:11038:          wtype = w_varassign;
    #####:11039:          break;
        -:11040:        }
        -:11041:
        -:11042:    default:
    #####:11043:      if (delim && index(delim, c))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:11044:        wtype = w_static;
    #####:11045:      break;
        -:11046:    }
        -:11047:
        -:11048:  /* Did we find something?  If so, return now.  */
    #####:11049:  if (wtype != w_bogus)
branch  0 never executed
branch  1 never executed
    #####:11050:    goto done;
        -:11051:
        -:11052:  /* This is some non-operator word.  A word consists of the longest
        -:11053:     string of characters that doesn't contain whitespace, one of [:=#],
        -:11054:     or [?+]=, or one of the chars in the DELIM string.  */
        -:11055:
        -:11056:  /* We start out assuming a static word; if we see a variable we'll
        -:11057:     adjust our assumptions then.  */
    #####:11058:  wtype = w_static;
        -:11059:
        -:11060:  /* We already found the first value of "c", above.  */
        -:11061:  while (1)
    #####:11062:    {
        -:11063:      char closeparen;
        -:11064:      int count;
        -:11065:
    #####:11066:      switch (c)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:11067:        {
    #####:11068:        case '\0':
        -:11069:        case ' ':
        -:11070:        case '\t':
        -:11071:        case '=':
        -:11072:        case '#':
    #####:11073:          goto done_word;
        -:11074:
    #####:11075:        case ':':
        -:11076:#if defined(__MSDOS__) || defined(WINDOWS32)
        -:11077:	  /* A word CAN include a colon in its drive spec.  The drive
        -:11078:	     spec is allowed either at the beginning of a word, or as part
        -:11079:	     of the archive member name, like in "libfoo.a(d:/foo/bar.o)".  */
        -:11080:	  if (!(p - beg >= 2 &&
        -:11081:		(*p == '/' || *p == '\\') && isalpha (p[-2]) &&
        -:11082:		(p - beg == 2 || p[-3] == '(')))
        -:11083:#endif
    #####:11084:	  goto done_word;
        -:11085:
    #####:11086:        case '$':
    #####:11087:          c = *(p++);
    #####:11088:          if (c == '$')
branch  0 never executed
branch  1 never executed
    #####:11089:            break;
        -:11090:
        -:11091:          /* This is a variable reference, so note that it's expandable.
        -:11092:             Then read it to the matching close paren.  */
    #####:11093:          wtype = w_variable;
        -:11094:
    #####:11095:          if (c == '(')
branch  0 never executed
branch  1 never executed
    #####:11096:            closeparen = ')';
    #####:11097:          else if (c == '{')
branch  0 never executed
branch  1 never executed
    #####:11098:            closeparen = '}';
        -:11099:          else
        -:11100:            /* This is a single-letter variable reference.  */
    #####:11101:            break;
        -:11102:
    #####:11103:          for (count=0; *p != '\0'; ++p)
branch  0 never executed
branch  1 never executed
        -:11104:            {
    #####:11105:              if (*p == c)
branch  0 never executed
branch  1 never executed
    #####:11106:                ++count;
    #####:11107:              else if (*p == closeparen && --count < 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:11108:                {
    #####:11109:                  ++p;
    #####:11110:                  break;
        -:11111:                }
        -:11112:            }
    #####:11113:          break;
        -:11114:
    #####:11115:        case '?':
        -:11116:        case '+':
    #####:11117:          if (*p == '=')
branch  0 never executed
branch  1 never executed
    #####:11118:            goto done_word;
    #####:11119:          break;
        -:11120:
    #####:11121:        case '\\':
    #####:11122:          switch (*p)
branch  0 never executed
branch  1 never executed
        -:11123:            {
    #####:11124:            case ':':
        -:11125:            case ';':
        -:11126:            case '=':
        -:11127:            case '\\':
    #####:11128:              ++p;
    #####:11129:              break;
        -:11130:            }
    #####:11131:          break;
        -:11132:
    #####:11133:        default:
    #####:11134:          if (delim && index(delim, c))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:11135:            goto done_word;
    #####:11136:          break;
        -:11137:        }
        -:11138:
    #####:11139:      c = *(p++);
        -:11140:    }
    #####:11141: done_word:
    #####:11142:  --p;
        -:11143:
    #####:11144: done:
    #####:11145:  if (startp)
branch  0 never executed
branch  1 never executed
    #####:11146:    *startp = beg;
    #####:11147:  if (length)
branch  0 never executed
branch  1 never executed
    #####:11148:    *length = p - beg;
    #####:11149:  return wtype;
        -:11150:}
        -:11151:
        -:11152:/* Construct the list of include directories
        -:11153:   from the arguments and the default list.  */
        -:11154:
        -:11155:void
function construct_include_path called 771 returned 100% blocks executed 50%
      771:11156:construct_include_path (arg_dirs)
        -:11157:     char **arg_dirs;
        -:11158:{
        -:11159:  register unsigned int i;
        -:11160:#ifdef VAXC		/* just don't ask ... */
        -:11161:  stat_t stbuf;
        -:11162:#else
        -:11163:  struct stat stbuf;
        -:11164:#endif
        -:11165:  /* Table to hold the dirs.  */
        -:11166:
      771:11167:  register unsigned int defsize = (sizeof (default_include_directories)
        -:11168:				   / sizeof (default_include_directories[0]));
      771:11169:  register unsigned int max = 5;
      771:11170:  register char **dirs = (char **) xmalloc ((5 + defsize) * sizeof (char *));
call    0 returned 771
      771:11171:  register unsigned int idx = 0;
        -:11172:
        -:11173:#ifdef  __MSDOS__
        -:11174:  defsize++;
        -:11175:#endif
        -:11176:
        -:11177:  /* First consider any dirs specified with -I switches.
        -:11178:     Ignore dirs that don't exist.  */
        -:11179:
      771:11180:  if (arg_dirs != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 771
    #####:11181:    while (*arg_dirs != 0)
branch  0 never executed
branch  1 never executed
        -:11182:      {
    #####:11183:	char *dir = *arg_dirs++;
        -:11184:
    #####:11185:	if (dir[0] == '~')
branch  0 never executed
branch  1 never executed
        -:11186:	  {
    #####:11187:	    char *expanded = tilde_expand (dir);
call    0 never executed
    #####:11188:	    if (expanded != 0)
branch  0 never executed
branch  1 never executed
    #####:11189:	      dir = expanded;
        -:11190:	  }
        -:11191:
    #####:11192:	if (stat (dir, &stbuf) == 0 && S_ISDIR (stbuf.st_mode))
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -:11193:	  {
    #####:11194:	    if (idx == max - 1)
branch  0 never executed
branch  1 never executed
        -:11195:	      {
    #####:11196:		max += 5;
        -:11197:		dirs = (char **)
    #####:11198:		  xrealloc ((char *) dirs, (max + defsize) * sizeof (char *));
call    0 never executed
        -:11199:	      }
    #####:11200:	    dirs[idx++] = dir;
        -:11201:	  }
    #####:11202:	else if (dir != arg_dirs[-1])
branch  0 never executed
branch  1 never executed
    #####:11203:	  free (dir);
        -:11204:      }
        -:11205:
        -:11206:  /* Now add at the end the standard default dirs.  */
        -:11207:
        -:11208:#ifdef  __MSDOS__
        -:11209:  {
        -:11210:    /* The environment variable $DJDIR holds the root of the
        -:11211:       DJGPP directory tree; add ${DJDIR}/include.  */
        -:11212:    struct variable *djdir = lookup_variable ("DJDIR", 5);
        -:11213:
        -:11214:    if (djdir)
        -:11215:      {
        -:11216:	char *defdir = (char *) xmalloc (strlen (djdir->value) + 8 + 1);
        -:11217:
        -:11218:	strcat (strcpy (defdir, djdir->value), "/include");
        -:11219:	dirs[idx++] = defdir;
        -:11220:      }
        -:11221:  }
        -:11222:#endif
        -:11223:
     3855:11224:  for (i = 0; default_include_directories[i] != 0; ++i)
branch  0 taken 3084
branch  1 taken 771 (fallthrough)
     3084:11225:    if (stat (default_include_directories[i], &stbuf) == 0
call    0 returned 3084
branch  1 taken 2313 (fallthrough)
branch  2 taken 771
     2313:11226:	&& S_ISDIR (stbuf.st_mode))
branch  0 taken 2313 (fallthrough)
branch  1 taken 0
     2313:11227:      dirs[idx++] = default_include_directories[i];
        -:11228:
      771:11229:  dirs[idx] = 0;
        -:11230:
        -:11231:  /* Now compute the maximum length of any name in it.  */
        -:11232:
      771:11233:  max_incl_len = 0;
     3084:11234:  for (i = 0; i < idx; ++i)
branch  0 taken 2313
branch  1 taken 771 (fallthrough)
        -:11235:    {
     2313:11236:      unsigned int len = strlen (dirs[i]);
        -:11237:      /* If dir name is written with a trailing slash, discard it.  */
     2313:11238:      if (dirs[i][len - 1] == '/')
branch  0 taken 0 (fallthrough)
branch  1 taken 2313
        -:11239:	/* We can't just clobber a null in because it may have come from
        -:11240:	   a literal string and literal strings may not be writable.  */
    #####:11241:	dirs[i] = savestring (dirs[i], len - 1);
call    0 never executed
     2313:11242:      if (len > max_incl_len)
branch  0 taken 771 (fallthrough)
branch  1 taken 1542
      771:11243:	max_incl_len = len;
        -:11244:    }
        -:11245:
      771:11246:  include_directories_to_search = dirs;
      771:11247:}
        -:11248:
        -:11249:/* Expand ~ or ~USER at the beginning of NAME.
        -:11250:   Return a newly malloc'd string or 0.  */
        -:11251:
        -:11252:char *
function tilde_expand called 0 returned 0% blocks executed 0%
    #####:11253:tilde_expand (name)
        -:11254:     char *name;
        -:11255:{
        -:11256:#ifndef VMS
    #####:11257:  if (name[1] == '/' || name[1] == '\0')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:11258:    {
        -:11259:      extern char *getenv ();
        -:11260:      char *home_dir;
        -:11261:      int is_variable;
        -:11262:
        -:11263:      {
        -:11264:	/* Turn off --warn-undefined-variables while we expand HOME.  */
    #####:11265:	int save = warn_undefined_variables_flag;
    #####:11266:	warn_undefined_variables_flag = 0;
        -:11267:
    #####:11268:	home_dir = allocated_variable_expand ("$(HOME)");
call    0 never executed
        -:11269:
    #####:11270:	warn_undefined_variables_flag = save;
        -:11271:      }
        -:11272:
    #####:11273:      is_variable = home_dir[0] != '\0';
    #####:11274:      if (!is_variable)
branch  0 never executed
branch  1 never executed
        -:11275:	{
    #####:11276:	  free (home_dir);
    #####:11277:	  home_dir = getenv ("HOME");
call    0 never executed
        -:11278:	}
        -:11279:#if !defined(_AMIGA) && !defined(WINDOWS32)
    #####:11280:      if (home_dir == 0 || home_dir[0] == '\0')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:11281:	{
        -:11282:	  extern char *getlogin ();
    #####:11283:	  char *logname = getlogin ();
call    0 never executed
    #####:11284:	  home_dir = 0;
    #####:11285:	  if (logname != 0)
branch  0 never executed
branch  1 never executed
        -:11286:	    {
    #####:11287:	      struct passwd *p = getpwnam (logname);
call    0 never executed
    #####:11288:	      if (p != 0)
branch  0 never executed
branch  1 never executed
    #####:11289:		home_dir = p->pw_dir;
        -:11290:	    }
        -:11291:	}
        -:11292:#endif /* !AMIGA && !WINDOWS32 */
    #####:11293:      if (home_dir != 0)
branch  0 never executed
branch  1 never executed
        -:11294:	{
    #####:11295:	  char *new = concat (home_dir, "", name + 1);
call    0 never executed
    #####:11296:	  if (is_variable)
branch  0 never executed
branch  1 never executed
    #####:11297:	    free (home_dir);
    #####:11298:	  return new;
        -:11299:	}
        -:11300:    }
        -:11301:#if !defined(_AMIGA) && !defined(WINDOWS32)
        -:11302:  else
        -:11303:    {
        -:11304:      struct passwd *pwent;
    #####:11305:      char *userend = index (name + 1, '/');
    #####:11306:      if (userend != 0)
branch  0 never executed
branch  1 never executed
    #####:11307:	*userend = '\0';
    #####:11308:      pwent = getpwnam (name + 1);
call    0 never executed
    #####:11309:      if (pwent != 0)
branch  0 never executed
branch  1 never executed
        -:11310:	{
    #####:11311:	  if (userend == 0)
branch  0 never executed
branch  1 never executed
    #####:11312:	    return xstrdup (pwent->pw_dir);
call    0 never executed
        -:11313:	  else
    #####:11314:	    return concat (pwent->pw_dir, "/", userend + 1);
call    0 never executed
        -:11315:	}
    #####:11316:      else if (userend != 0)
branch  0 never executed
branch  1 never executed
    #####:11317:	*userend = '/';
        -:11318:    }
        -:11319:#endif /* !AMIGA && !WINDOWS32 */
        -:11320:#endif /* !VMS */
    #####:11321:  return 0;
        -:11322:}
        -:11323:
        -:11324:/* Given a chain of struct nameseq's describing a sequence of filenames,
        -:11325:   in reverse of the intended order, return a new chain describing the
        -:11326:   result of globbing the filenames.  The new chain is in forward order.
        -:11327:   The links of the old chain are freed or used in the new chain.
        -:11328:   Likewise for the names in the old chain.
        -:11329:
        -:11330:   SIZE is how big to construct chain elements.
        -:11331:   This is useful if we want them actually to be other structures
        -:11332:   that have room for additional info.  */
        -:11333:
        -:11334:struct nameseq *
function multi_glob called 7710 returned 100% blocks executed 54%
     7710:11335:multi_glob (chain, size)
        -:11336:     struct nameseq *chain;
        -:11337:     unsigned int size;
        -:11338:{
        -:11339:  extern void dir_setup_glob ();
     7710:11340:  register struct nameseq *new = 0;
        -:11341:  register struct nameseq *old;
        -:11342:  struct nameseq *nexto;
        -:11343:  glob_t gl;
        -:11344:
     7710:11345:  dir_setup_glob (&gl);
call    0 returned 7710
        -:11346:
    40863:11347:  for (old = chain; old != 0; old = nexto)
branch  0 taken 33153
branch  1 taken 7710 (fallthrough)
        -:11348:    {
        -:11349:#ifndef NO_ARCHIVES
        -:11350:      char *memname;
        -:11351:#endif
        -:11352:
    33153:11353:      nexto = old->next;
        -:11354:
    33153:11355:      if (old->name[0] == '~')
branch  0 taken 0 (fallthrough)
branch  1 taken 33153
        -:11356:	{
    #####:11357:	  char *newname = tilde_expand (old->name);
call    0 never executed
    #####:11358:	  if (newname != 0)
branch  0 never executed
branch  1 never executed
        -:11359:	    {
    #####:11360:	      free (old->name);
    #####:11361:	      old->name = newname;
        -:11362:	    }
        -:11363:	}
        -:11364:
        -:11365:#ifndef NO_ARCHIVES
    33153:11366:      if (ar_name (old->name))
call    0 returned 33153
branch  1 taken 0 (fallthrough)
branch  2 taken 33153
        -:11367:	{
        -:11368:	  /* OLD->name is an archive member reference.
        -:11369:	     Replace it with the archive file name,
        -:11370:	     and save the member name in MEMNAME.
        -:11371:	     We will glob on the archive name and then
        -:11372:	     reattach MEMNAME later.  */
        -:11373:	  char *arname;
    #####:11374:	  ar_parse_name (old->name, &arname, &memname);
call    0 never executed
    #####:11375:	  free (old->name);
    #####:11376:	  old->name = arname;
        -:11377:	}
        -:11378:      else
    33153:11379:	memname = 0;
        -:11380:#endif /* !NO_ARCHIVES */
        -:11381:
    33153:11382:      switch (glob (old->name, GLOB_NOCHECK|GLOB_ALTDIRFUNC, NULL, &gl))
call    0 returned 33153
branch  1 taken 33153
branch  2 taken 0
branch  3 taken 0
        -:11383:	{
    33153:11384:	case 0:			/* Success.  */
        -:11385:	  {
    33153:11386:	    register int i = gl.gl_pathc;
    66306:11387:	    while (i-- > 0)
branch  0 taken 33153
branch  1 taken 33153 (fallthrough)
        -:11388:	      {
        -:11389:#ifndef NO_ARCHIVES
    33153:11390:		if (memname != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 33153
        -:11391:		  {
        -:11392:		    /* Try to glob on MEMNAME within the archive.  */
        -:11393:		    struct nameseq *found
    #####:11394:		      = ar_glob (gl.gl_pathv[i], memname, size);
call    0 never executed
    #####:11395:		    if (found == 0)
branch  0 never executed
branch  1 never executed
        -:11396:		      {
        -:11397:			/* No matches.  Use MEMNAME as-is.  */
        -:11398:			struct nameseq *elt
    #####:11399:			  = (struct nameseq *) xmalloc (size);
call    0 never executed
    #####:11400:			unsigned int alen = strlen (gl.gl_pathv[i]);
    #####:11401:			unsigned int mlen = strlen (memname);
    #####:11402:			elt->name = (char *) xmalloc (alen + 1 + mlen + 2);
call    0 never executed
    #####:11403:			bcopy (gl.gl_pathv[i], elt->name, alen);
    #####:11404:			elt->name[alen] = '(';
    #####:11405:			bcopy (memname, &elt->name[alen + 1], mlen);
    #####:11406:			elt->name[alen + 1 + mlen] = ')';
    #####:11407:			elt->name[alen + 1 + mlen + 1] = '\0';
    #####:11408:			elt->next = new;
    #####:11409:			new = elt;
        -:11410:		      }
        -:11411:		    else
        -:11412:		      {
        -:11413:			/* Find the end of the FOUND chain.  */
    #####:11414:			struct nameseq *f = found;
    #####:11415:			while (f->next != 0)
branch  0 never executed
branch  1 never executed
    #####:11416:			  f = f->next;
        -:11417:
        -:11418:			/* Attach the chain being built to the end of the FOUND
        -:11419:			   chain, and make FOUND the new NEW chain.  */
    #####:11420:			f->next = new;
    #####:11421:			new = found;
        -:11422:		      }
        -:11423:
    #####:11424:		    free (memname);
        -:11425:		  }
        -:11426:		else
        -:11427:#endif /* !NO_ARCHIVES */
        -:11428:		  {
    33153:11429:		    struct nameseq *elt = (struct nameseq *) xmalloc (size);
call    0 returned 33153
    33153:11430:		    elt->name = xstrdup (gl.gl_pathv[i]);
call    0 returned 33153
    33153:11431:		    elt->next = new;
    33153:11432:		    new = elt;
        -:11433:		  }
        -:11434:	      }
    33153:11435:	    globfree (&gl);
call    0 returned 33153
    33153:11436:	    free (old->name);
    33153:11437:	    free ((char *)old);
    33153:11438:	    break;
        -:11439:	  }
        -:11440:
    #####:11441:	case GLOB_NOSPACE:
    #####:11442:	  fatal (NILF, _("virtual memory exhausted"));
call    0 never executed
        -:11443:	  break;
        -:11444:
    #####:11445:	default:
    #####:11446:	  old->next = new;
    #####:11447:	  new = old;
    #####:11448:	  break;
        -:11449:	}
        -:11450:    }
        -:11451:
     7710:11452:  return new;
        -:11453:}
        -:11454:
        -:11455:
        -:11456:
        -:11457:/*************************************************************
        -:11458:  ============================================================
        -:11459:  ************************************************************
        -:11460:  ============================================================
        -:11461:  ************************************************************
        -:11462:                         remake.c
        -:11463:  ************************************************************
        -:11464:  ============================================================
        -:11465:  ************************************************************
        -:11466:  ============================================================
        -:11467:  *************************************************************/
        -:11468:
        -:11469:/* Basic dependency engine for GNU Make.
        -:11470:Copyright (C) 1988,89,90,91,92,93,94,95,96,97,99 Free Software Foundation, Inc.
        -:11471:This file is part of GNU Make.
        -:11472:
        -:11473:GNU Make is free software; you can redistribute it and/or modify
        -:11474:it under the terms of the GNU General Public License as published by
        -:11475:the Free Software Foundation; either version 2, or (at your option)
        -:11476:any later version.
        -:11477:
        -:11478:GNU Make is distributed in the hope that it will be useful,
        -:11479:but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:11480:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:11481:GNU General Public License for more details.
        -:11482:
        -:11483:You should have received a copy of the GNU General Public License
        -:11484:along with GNU Make; see the file COPYING.  If not, write to
        -:11485:the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
        -:11486:Boston, MA 02111-1307, USA.  */
        -:11487:
        -:11488:/* #include "make.h"  <- modification by J.Ruthruff, 7/27 */
        -:11489:/* #include "filedef.h"  <- modification by J.Ruthruff, 7/27 */
        -:11490:#include "job.h"
        -:11491:/* #include "commands.h"  <- modification by J.Ruthruff, 7/27 */
        -:11492:/* #include "dep.h"  <- modification by J.Ruthruff, 7/27 */
        -:11493:/* #include "variable.h"  <- modification by J.Ruthruff, 7/27 */
        -:11494:
        -:11495:#include <assert.h>
        -:11496:#undef stderr
        -:11497:#define stderr stdout
        -:11498:
        -:11499:#ifdef HAVE_FCNTL_H
        -:11500:#include <fcntl.h>
        -:11501:#undef stderr
        -:11502:#define stderr stdout
        -:11503:#else
        -:11504:#include <sys/file.h>
        -:11505:#undef stderr
        -:11506:#define stderr stdout
        -:11507:#endif
        -:11508:
        -:11509:#ifdef VMS
        -:11510:#include <starlet.h>
        -:11511:#undef stderr
        -:11512:#define stderr stdout
        -:11513:#endif
        -:11514:#ifdef WINDOWS32
        -:11515:#include <io.h>
        -:11516:#undef stderr
        -:11517:#define stderr stdout
        -:11518:#endif
        -:11519:
        -:11520:extern int try_implicit_rule PARAMS ((struct file *file, unsigned int depth));
        -:11521:
        -:11522:
        -:11523:/* Incremented when a command is started (under -n, when one would be).  */
        -:11524:unsigned int commands_started = 0;
        -:11525:
        -:11526:static int update_file PARAMS ((struct file *file, unsigned int depth));
        -:11527:static int update_file_1 PARAMS ((struct file *file, unsigned int depth));
        -:11528:static int check_dep PARAMS ((struct file *file, unsigned int depth, FILE_TIMESTAMP this_mtime, int *must_make_ptr));
        -:11529:static int touch_file PARAMS ((struct file *file));
        -:11530:static void remake_file PARAMS ((struct file *file));
        -:11531:static FILE_TIMESTAMP name_mtime PARAMS ((char *name));
        -:11532:static int library_search PARAMS ((char **lib, FILE_TIMESTAMP *mtime_ptr));
        -:11533:
        -:11534:
        -:11535:/* Remake all the goals in the `struct dep' chain GOALS.  Return -1 if nothing
        -:11536:   was done, 0 if all goals were updated successfully, or 1 if a goal failed.
        -:11537:   If MAKEFILES is nonzero, these goals are makefiles, so -t, -q, and -n should
        -:11538:   be disabled for them unless they were also command-line targets, and we
        -:11539:   should only make one goal at a time and return as soon as one goal whose
        -:11540:   `changed' member is nonzero is successfully made.  */
        -:11541:
        -:11542:/* We need to know this "lower down" for correct error handling.  */
        -:11543:static int updating_makefiles = 0;
        -:11544:
        -:11545:int
function update_goal_chain called 771 returned 33% blocks executed 51%
      771:11546:update_goal_chain (goals, makefiles)
        -:11547:     register struct dep *goals;
        -:11548:     int makefiles;
        -:11549:{
      771:11550:  int t = touch_flag, q = question_flag, n = just_print_flag;
      771:11551:  unsigned int j = job_slots;
      771:11552:  int status = -1;
        -:11553:
      771:11554:  updating_makefiles = makefiles;
        -:11555:
        -:11556:#define	MTIME(file) (makefiles ? file_mtime_no_search (file) \
        -:11557:		     : file_mtime (file))
        -:11558:
        -:11559:  /* Duplicate the chain so we can remove things from it.  */
        -:11560:
      771:11561:  goals = copy_dep_chain (goals);
call    0 returned 771
        -:11562:
        -:11563:  {
        -:11564:    /* Clear the `changed' flag of each goal in the chain.
        -:11565:       We will use the flag below to notice when any commands
        -:11566:       have actually been run for a target.  When no commands
        -:11567:       have been run, we give an "up to date" diagnostic.  */
        -:11568:
        -:11569:    struct dep *g;
     1542:11570:    for (g = goals; g != 0; g = g->next)
branch  0 taken 771
branch  1 taken 771 (fallthrough)
      771:11571:      g->changed = 0;
        -:11572:  }
        -:11573:
        -:11574:#if 0
        -:11575:  /* Only run one job at a time when building makefiles.
        -:11576:     No one seems to know why this was done, and no one can think of a good
        -:11577:     reason to do it.  Hopefully an obvious one won't appear as soon as we
        -:11578:     release the next version :-/.  */
        -:11579:  if (makefiles)
        -:11580:    job_slots = 1;
        -:11581:#endif
        -:11582:
        -:11583:  /* All files start with the considered bit 0, so the global value is 1.  */
      771:11584:  considered = 1;
        -:11585:
        -:11586:  /* Update all the goals until they are all finished.  */
        -:11587:
     1027:11588:  while (goals != 0)
branch  0 taken 771
branch  1 taken 256 (fallthrough)
        -:11589:    {
        -:11590:      register struct dep *g, *lastgoal;
        -:11591:
        -:11592:      /* Start jobs that are waiting for the load to go down.  */
        -:11593:
      771:11594:      start_waiting_jobs ();
call    0 returned 771
        -:11595:
        -:11596:      /* Wait for a child to die.  */
        -:11597:
      771:11598:      reap_children (1, 0);
call    0 returned 771
        -:11599:
      771:11600:      lastgoal = 0;
      771:11601:      g = goals;
     1027:11602:      while (g != 0)
branch  0 taken 771
branch  1 taken 256 (fallthrough)
        -:11603:	{
        -:11604:	  /* Iterate over all double-colon entries for this file.  */
        -:11605:	  struct file *file;
      771:11606:	  int stop = 0, any_not_updated = 0;
        -:11607:
     771*:11608:	  for (file = g->file->double_colon ? g->file->double_colon : g->file;
branch  0 taken 0 (fallthrough)
branch  1 taken 771
     1027:11609:	       file != NULL;
branch  0 taken 771
branch  1 taken 256 (fallthrough)
      256:11610:	       file = file->prev)
        -:11611:	    {
        -:11612:	      unsigned int ocommands_started;
        -:11613:	      int x;
     771*:11614:	      check_renamed (file);
branch  0 taken 0
branch  1 taken 771 (fallthrough)
      771:11615:	      if (makefiles)
branch  0 taken 771 (fallthrough)
branch  1 taken 0
        -:11616:		{
      771:11617:		  if (file->cmd_target)
branch  0 taken 0 (fallthrough)
branch  1 taken 771
        -:11618:		    {
    #####:11619:		      touch_flag = t;
    #####:11620:		      question_flag = q;
    #####:11621:		      just_print_flag = n;
        -:11622:		    }
        -:11623:		  else
      771:11624:		    touch_flag = question_flag = just_print_flag = 0;
        -:11625:		}
        -:11626:
        -:11627:	      /* Save the old value of `commands_started' so we can compare
        -:11628:		 later.  It will be incremented when any commands are
        -:11629:		 actually run.  */
      771:11630:	      ocommands_started = commands_started;
        -:11631:
      771:11632:	      x = update_file (file, makefiles ? 1 : 0);
call    0 returned 256
     256*:11633:	      check_renamed (file);
branch  0 taken 0
branch  1 taken 256 (fallthrough)
        -:11634:
        -:11635:	      /* Set the goal's `changed' flag if any commands were started
        -:11636:		 by calling update_file above.  We check this flag below to
        -:11637:		 decide when to give an "up to date" diagnostic.  */
      256:11638:	      g->changed += commands_started - ocommands_started;
        -:11639:
        -:11640:              /* If we updated a file and STATUS was not already 1, set it to
        -:11641:                 1 if updating failed, or to 0 if updating succeeded.  Leave
        -:11642:                 STATUS as it is if no updating was done.  */
        -:11643:
      256:11644:	      stop = 0;
     256*:11645:	      if ((x != 0 || file->updated) && status < 1)
branch  0 taken 0 (fallthrough)
branch  1 taken 256
branch  2 never executed
branch  3 never executed
branch  4 taken 256 (fallthrough)
branch  5 taken 0
        -:11646:                {
      256:11647:                  if (file->update_status != 0)
branch  0 taken 256 (fallthrough)
branch  1 taken 0
        -:11648:                    {
        -:11649:                      /* Updating failed, or -q triggered.  The STATUS value
        -:11650:                         tells our caller which.  */
      256:11651:                      status = file->update_status;
        -:11652:                      /* If -q just triggered, stop immediately.  It doesn't
        -:11653:                         matter how much more we run, since we already know
        -:11654:                         the answer to return.  */
     256*:11655:                      stop = (!keep_going_flag && !question_flag
branch  0 never executed
branch  1 never executed
     256*:11656:                              && !makefiles);
branch  0 taken 0 (fallthrough)
branch  1 taken 256
branch  2 never executed
branch  3 never executed
        -:11657:                    }
        -:11658:                  else
        -:11659:                    {
    #####:11660:                      FILE_TIMESTAMP mtime = MTIME (file);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
    #####:11661:                      check_renamed (file);
branch  0 never executed
branch  1 never executed
        -:11662:
    #####:11663:                      if (file->updated && g->changed &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:11664:                           mtime != file->mtime_before_update)
branch  0 never executed
branch  1 never executed
        -:11665:                        {
        -:11666:                          /* Updating was done.  If this is a makefile and
        -:11667:                             just_print_flag or question_flag is set (meaning
        -:11668:                             -n or -q was given and this file was specified
        -:11669:                             as a command-line target), don't change STATUS.
        -:11670:                             If STATUS is changed, we will get re-exec'd, and
        -:11671:                             enter an infinite loop.  */
    #####:11672:                          if (!makefiles
branch  0 never executed
branch  1 never executed
    #####:11673:                              || (!just_print_flag && !question_flag))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:11674:                            status = 0;
    #####:11675:                          if (makefiles && file->dontcare)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:11676:                            /* This is a default makefile; stop remaking.  */
    #####:11677:                            stop = 1;
        -:11678:                        }
        -:11679:                    }
        -:11680:                }
        -:11681:
        -:11682:	      /* Keep track if any double-colon entry is not finished.
        -:11683:                 When they are all finished, the goal is finished.  */
      256:11684:	      any_not_updated |= !file->updated;
        -:11685:
      256:11686:	      if (stop)
branch  0 taken 0 (fallthrough)
branch  1 taken 256
    #####:11687:		break;
        -:11688:	    }
        -:11689:
        -:11690:	  /* Reset FILE since it is null at the end of the loop.  */
      256:11691:	  file = g->file;
        -:11692:
      256:11693:	  if (stop || !any_not_updated)
branch  0 taken 256 (fallthrough)
branch  1 taken 0
branch  2 taken 256 (fallthrough)
branch  3 taken 0
        -:11694:	    {
        -:11695:	      /* If we have found nothing whatever to do for the goal,
        -:11696:		 print a message saying nothing needs doing.  */
        -:11697:
      256:11698:	      if (!makefiles
branch  0 taken 0 (fallthrough)
branch  1 taken 256
        -:11699:		  /* If the update_status is zero, we updated successfully
        -:11700:		     or not at all.  G->changed will have been set above if
        -:11701:		     any commands were actually started for this goal.  */
    #####:11702:		  && file->update_status == 0 && !g->changed
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:11703:		  /* Never give a message under -s or -q.  */
    #####:11704:		  && !silent_flag && !question_flag)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:11705:		message (1, ((file->phony || file->cmds == 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -:11706:			     ? _("Nothing to be done for `%s'.")
        -:11707:			     : _("`%s' is up to date.")),
        -:11708:			 file->name);
        -:11709:
        -:11710:	      /* This goal is finished.  Remove it from the chain.  */
      256:11711:	      if (lastgoal == 0)
branch  0 taken 256 (fallthrough)
branch  1 taken 0
      256:11712:		goals = g->next;
        -:11713:	      else
    #####:11714:		lastgoal->next = g->next;
        -:11715:
        -:11716:	      /* Free the storage.  */
      256:11717:	      free ((char *) g);
        -:11718:
     256*:11719:	      g = lastgoal == 0 ? goals : lastgoal->next;
branch  0 taken 0 (fallthrough)
branch  1 taken 256
        -:11720:
      256:11721:	      if (stop)
branch  0 taken 0 (fallthrough)
branch  1 taken 256
    #####:11722:		break;
        -:11723:	    }
        -:11724:	  else
        -:11725:	    {
    #####:11726:	      lastgoal = g;
    #####:11727:	      g = g->next;
        -:11728:	    }
        -:11729:	}
        -:11730:
        -:11731:      /* If we reached the end of the dependency graph toggle the considered
        -:11732:         flag for the next pass.  */
      256:11733:      if (g == 0)
branch  0 taken 256 (fallthrough)
branch  1 taken 0
      256:11734:        considered = !considered;
        -:11735:    }
        -:11736:
      256:11737:  if (makefiles)
branch  0 taken 256 (fallthrough)
branch  1 taken 0
        -:11738:    {
      256:11739:      touch_flag = t;
      256:11740:      question_flag = q;
      256:11741:      just_print_flag = n;
      256:11742:      job_slots = j;
        -:11743:    }
      256:11744:  return status;
        -:11745:}
        -:11746:
        -:11747:/* Generate an error/fatal message if no rules are available for the target.
        -:11748: */
        -:11749:static void
function no_rule_error called 771 returned 33% blocks executed 75%
      771:11750:no_rule_error(file)
        -:11751:  struct file *file;
        -:11752:{
        -:11753:  static const char msg_noparent[]
        -:11754:    = _("%sNo rule to make target `%s'%s");
        -:11755:  static const char msg_parent[]
        -:11756:    = _("%sNo rule to make target `%s', needed by `%s'%s");
        -:11757:
      771:11758:  if (keep_going_flag || file->dontcare)
branch  0 taken 515 (fallthrough)
branch  1 taken 256
branch  2 taken 0 (fallthrough)
branch  3 taken 515
        -:11759:    {
        -:11760:      /* If the previous attempt was made while we were creating
        -:11761:         makefiles, but we aren't anymore, print an error now.  */
      256:11762:      if (!file->dontcare
branch  0 taken 0 (fallthrough)
branch  1 taken 256
    #####:11763:          || (file->mfile_status && !updating_makefiles))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:11764:        {
      256:11765:          if (file->parent == 0)
branch  0 taken 256 (fallthrough)
branch  1 taken 0
      256:11766:            error (NILF, msg_noparent, "*** ", file->name, ".");
call    0 returned 256
        -:11767:          else
    #####:11768:            error (NILF, msg_parent, "*** ",
    #####:11769:                   file->name, file->parent->name, ".");
call    0 never executed
        -:11770:        }
      256:11771:      file->update_status = 2;
      256:11772:      file->mfile_status = updating_makefiles;
        -:11773:    }
      515:11774:  else if (file->parent == 0)
branch  0 taken 515 (fallthrough)
branch  1 taken 0
      515:11775:    fatal (NILF, msg_noparent, "", file->name, "");
call    0 returned 0
        -:11776:  else
    #####:11777:    fatal (NILF, msg_parent, "", file->name, file->parent->name, "");
      256:11778:}
        -:11779:
        -:11780:/* If FILE is not up to date, execute the commands for it.
        -:11781:   Return 0 if successful, 1 if unsuccessful;
        -:11782:   but with some flag settings, just call `exit' if unsuccessful.
        -:11783:
        -:11784:   DEPTH is the depth in recursions of this function.
        -:11785:   We increment it during the consideration of our dependencies,
        -:11786:   then decrement it again after finding out whether this file
        -:11787:   is out of date.
        -:11788:
        -:11789:   If there are multiple double-colon entries for FILE,
        -:11790:   each is considered in turn.  */
        -:11791:
        -:11792:static int
function update_file called 771 returned 33% blocks executed 56%
      771:11793:update_file (file, depth)
        -:11794:     struct file *file;
        -:11795:     unsigned int depth;
        -:11796:{
      771:11797:  register int status = 0;
        -:11798:  register struct file *f;
        -:11799:
    1027*:11800:  for (f = file->double_colon ? file->double_colon : file; f != 0; f = f->prev)
branch  0 taken 0 (fallthrough)
branch  1 taken 771
branch  2 taken 771
branch  3 taken 256 (fallthrough)
        -:11801:    {
        -:11802:      /* Prune the dependency graph: if we've already been here on _this_
        -:11803:         pass through the dependency graph, we don't have to go any further.
        -:11804:         We won't reap_children until we start the next pass, so no state
        -:11805:         change is possible below here until then.  */
     771*:11806:      if (f->considered == considered)
branch  0 taken 0 (fallthrough)
branch  1 taken 771
        -:11807:        {
    #####:11808:          DEBUGPR (_("Pruning file `%s'.\n"));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:11809:          continue;
        -:11810:        }
      771:11811:      f->considered = considered;
        -:11812:
      771:11813:      status |= update_file_1 (f, depth);
call    0 returned 256
     256*:11814:      check_renamed (f);
branch  0 taken 0
branch  1 taken 256 (fallthrough)
        -:11815:
      256:11816:      if (status != 0 && !keep_going_flag)
branch  0 taken 256 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 256
    #####:11817:	return status;
        -:11818:
      256:11819:      switch (f->command_state)
branch  0 taken 256
branch  1 taken 0
branch  2 taken 0
        -:11820:	{
      256:11821:	case cs_finished:
        -:11822:	  /* The file is done being remade.  */
      256:11823:	  break;
        -:11824:
    #####:11825:	case cs_running:
        -:11826:	case cs_deps_running:
        -:11827:	  /* Don't run the other :: rules for this
        -:11828:	     file until this rule is finished.  */
    #####:11829:	  return 0;
        -:11830:
    #####:11831:	default:
    #####:11832:	  assert (f->command_state == cs_running);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:11833:	  break;
        -:11834:	}
        -:11835:    }
        -:11836:
      256:11837:  return status;
        -:11838:}
        -:11839:
        -:11840:/* Consider a single `struct file' and update it as appropriate.  */
        -:11841:
        -:11842:static int
function update_file_1 called 771 returned 33% blocks executed 23%
      771:11843:update_file_1 (file, depth)
        -:11844:     struct file *file;
        -:11845:     unsigned int depth;
        -:11846:{
        -:11847:  register FILE_TIMESTAMP this_mtime;
        -:11848:  int noexist, must_make, deps_changed;
      771:11849:  int dep_status = 0;
        -:11850:  register struct dep *d, *lastd;
      771:11851:  int running = 0;
        -:11852:
      771:11853:  DEBUGPR (_("Considering target file `%s'.\n"));
branch  0 taken 384 (fallthrough)
branch  1 taken 387
call    2 returned 384
call    3 returned 384
call    4 returned 384
        -:11854:
      771:11855:  if (file->updated)
branch  0 taken 0 (fallthrough)
branch  1 taken 771
        -:11856:    {
    #####:11857:      if (file->update_status > 0)
branch  0 never executed
branch  1 never executed
        -:11858:	{
    #####:11859:	  DEBUGPR (_("Recently tried and failed to update file `%s'.\n"));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:11860:          no_rule_error(file);
call    0 never executed
    #####:11861:	  return file->update_status;
        -:11862:	}
        -:11863:
    #####:11864:      DEBUGPR (_("File `%s' was considered already.\n"));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:11865:      return 0;
        -:11866:    }
        -:11867:
      771:11868:  switch (file->command_state)
branch  0 taken 771
branch  1 taken 0
branch  2 taken 0
branch  3 taken 0
        -:11869:    {
      771:11870:    case cs_not_started:
        -:11871:    case cs_deps_running:
      771:11872:      break;
    #####:11873:    case cs_running:
    #####:11874:      DEBUGPR (_("Still updating file `%s'.\n"));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:11875:      return 0;
    #####:11876:    case cs_finished:
    #####:11877:      DEBUGPR (_("Finished updating file `%s'.\n"));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:11878:      return file->update_status;
    #####:11879:    default:
    #####:11880:      abort ();
call    0 never executed
        -:11881:    }
        -:11882:
      771:11883:  ++depth;
        -:11884:
        -:11885:  /* Notice recursive update of the same file.  */
      771:11886:  file->updating = 1;
        -:11887:
        -:11888:  /* Looking at the file's modtime beforehand allows the possibility
        -:11889:     that its name may be changed by a VPATH search, and thus it may
        -:11890:     not need an implicit rule.  If this were not done, the file
        -:11891:     might get implicit commands that apply to its initial name, only
        -:11892:     to have that name replaced with another found by VPATH search.  */
        -:11893:
     771*:11894:  this_mtime = file_mtime (file);
branch  0 taken 771 (fallthrough)
branch  1 taken 0
call    2 never executed
     771*:11895:  check_renamed (file);
branch  0 taken 0
branch  1 taken 771 (fallthrough)
      771:11896:  noexist = this_mtime == (FILE_TIMESTAMP) -1;
      771:11897:  if (noexist)
branch  0 taken 771 (fallthrough)
branch  1 taken 0
      771:11898:    DEBUGPR (_("File `%s' does not exist.\n"));
branch  0 taken 384 (fallthrough)
branch  1 taken 387
call    2 returned 384
call    3 returned 384
call    4 returned 384
        -:11899:
      771:11900:  must_make = noexist;
        -:11901:
        -:11902:  /* If file was specified as a target with no commands,
        -:11903:     come up with some default commands.  */
        -:11904:
      771:11905:  if (!file->phony && file->cmds == 0 && !file->tried_implicit)
branch  0 taken 771 (fallthrough)
branch  1 taken 0
branch  2 taken 771 (fallthrough)
branch  3 taken 0
branch  4 taken 771 (fallthrough)
branch  5 taken 0
        -:11906:    {
      771:11907:      if (try_implicit_rule (file, depth))
call    0 returned 771
branch  1 taken 0 (fallthrough)
branch  2 taken 771
    #####:11908:	DEBUGPR (_("Found an implicit rule for `%s'.\n"));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:11909:      else
      771:11910:	DEBUGPR (_("No implicit rule found for `%s'.\n"));
branch  0 taken 384 (fallthrough)
branch  1 taken 387
call    2 returned 384
call    3 returned 384
call    4 returned 384
      771:11911:      file->tried_implicit = 1;
        -:11912:    }
      771:11913:  if (file->cmds == 0 && !file->is_target
branch  0 taken 771 (fallthrough)
branch  1 taken 0
branch  2 taken 771 (fallthrough)
branch  3 taken 0
      771:11914:      && default_file != 0 && default_file->cmds != 0)
branch  0 taken 771 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 771
        -:11915:    {
    #####:11916:      DEBUGPR (_("Using default commands for `%s'.\n"));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:11917:      file->cmds = default_file->cmds;
        -:11918:    }
        -:11919:
        -:11920:  /* Update all non-intermediate files we depend on, if necessary,
        -:11921:     and see whether any of them is more recent than this file.  */
        -:11922:
      771:11923:  lastd = 0;
      771:11924:  d = file->deps;
      771:11925:  while (d != 0)
branch  0 taken 0
branch  1 taken 771 (fallthrough)
        -:11926:    {
        -:11927:      FILE_TIMESTAMP mtime;
        -:11928:
    #####:11929:      check_renamed (d->file);
branch  0 never executed
branch  1 never executed
        -:11930:
    #####:11931:      mtime = file_mtime (d->file);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:11932:      check_renamed (d->file);
branch  0 never executed
branch  1 never executed
        -:11933:
    #####:11934:      if (d->file->updating)
branch  0 never executed
branch  1 never executed
        -:11935:	{
    #####:11936:	  error (NILF, _("Circular %s <- %s dependency dropped."),
    #####:11937:		 file->name, d->file->name);
call    0 never executed
        -:11938:	  /* We cannot free D here because our the caller will still have
        -:11939:	     a reference to it when we were called recursively via
        -:11940:	     check_dep below.  */
    #####:11941:	  if (lastd == 0)
branch  0 never executed
branch  1 never executed
    #####:11942:	    file->deps = d->next;
        -:11943:	  else
    #####:11944:	    lastd->next = d->next;
    #####:11945:	  d = d->next;
    #####:11946:	  continue;
        -:11947:	}
        -:11948:
    #####:11949:      d->file->parent = file;
    #####:11950:      dep_status |= check_dep (d->file, depth, this_mtime, &must_make);
call    0 never executed
    #####:11951:      check_renamed (d->file);
branch  0 never executed
branch  1 never executed
        -:11952:
        -:11953:      {
    #####:11954:	register struct file *f = d->file;
    #####:11955:	if (f->double_colon)
branch  0 never executed
branch  1 never executed
    #####:11956:	  f = f->double_colon;
        -:11957:	do
        -:11958:	  {
    #####:11959:	    running |= (f->command_state == cs_running
    #####:11960:			|| f->command_state == cs_deps_running);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:11961:	    f = f->prev;
        -:11962:	  }
    #####:11963:	while (f != 0);
branch  0 never executed
branch  1 never executed
        -:11964:      }
        -:11965:
    #####:11966:      if (dep_status != 0 && !keep_going_flag)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:11967:	break;
        -:11968:
    #####:11969:      if (!running)
branch  0 never executed
branch  1 never executed
    #####:11970:	d->changed = file_mtime (d->file) != mtime;
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:11971:
    #####:11972:      lastd = d;
    #####:11973:      d = d->next;
        -:11974:    }
        -:11975:
        -:11976:  /* Now we know whether this target needs updating.
        -:11977:     If it does, update all the intermediate files we depend on.  */
        -:11978:
      771:11979:  if (must_make)
branch  0 taken 771 (fallthrough)
branch  1 taken 0
        -:11980:    {
     771*:11981:      for (d = file->deps; d != 0; d = d->next)
branch  0 taken 0
branch  1 taken 771 (fallthrough)
    #####:11982:	if (d->file->intermediate)
branch  0 never executed
branch  1 never executed
        -:11983:	  {
    #####:11984:	    FILE_TIMESTAMP mtime = file_mtime (d->file);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:11985:	    check_renamed (d->file);
branch  0 never executed
branch  1 never executed
    #####:11986:	    d->file->parent = file;
    #####:11987:	    dep_status |= update_file (d->file, depth);
call    0 never executed
    #####:11988:	    check_renamed (d->file);
branch  0 never executed
branch  1 never executed
        -:11989:
        -:11990:	    {
    #####:11991:	      register struct file *f = d->file;
    #####:11992:	      if (f->double_colon)
branch  0 never executed
branch  1 never executed
    #####:11993:		f = f->double_colon;
        -:11994:	      do
        -:11995:		{
    #####:11996:		  running |= (f->command_state == cs_running
    #####:11997:			      || f->command_state == cs_deps_running);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:11998:		  f = f->prev;
        -:11999:		}
    #####:12000:	      while (f != 0);
branch  0 never executed
branch  1 never executed
        -:12001:	    }
        -:12002:
    #####:12003:	    if (dep_status != 0 && !keep_going_flag)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:12004:	      break;
        -:12005:
    #####:12006:	    if (!running)
branch  0 never executed
branch  1 never executed
    #####:12007:	      d->changed = ((file->phony && file->cmds != 0)
branch  0 never executed
branch  1 never executed
    #####:12008:			    || file_mtime (d->file) != mtime);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
        -:12009:	  }
        -:12010:    }
        -:12011:
      771:12012:  file->updating = 0;
        -:12013:
      771:12014:  DEBUGPR (_("Finished prerequisites of target file `%s'.\n"));
branch  0 taken 384 (fallthrough)
branch  1 taken 387
call    2 returned 384
call    3 returned 384
call    4 returned 384
        -:12015:
      771:12016:  if (running)
branch  0 taken 0 (fallthrough)
branch  1 taken 771
        -:12017:    {
    #####:12018:      set_command_state (file, cs_deps_running);
call    0 never executed
    #####:12019:      --depth;
    #####:12020:      DEBUGPR (_("The prerequisites of `%s' are being made.\n"));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:12021:      return 0;
        -:12022:    }
        -:12023:
        -:12024:  /* If any dependency failed, give up now.  */
        -:12025:
      771:12026:  if (dep_status != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 771
        -:12027:    {
    #####:12028:      file->update_status = dep_status;
    #####:12029:      notice_finished_file (file);
call    0 never executed
        -:12030:
    #####:12031:      depth--;
        -:12032:
    #####:12033:      DEBUGPR (_("Giving up on target file `%s'.\n"));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:12034:
    #####:12035:      if (depth == 0 && keep_going_flag
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:12036:	  && !just_print_flag && !question_flag)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:12037:	error (NILF,
call    0 never executed
        -:12038:               _("Target `%s' not remade because of errors."), file->name);
        -:12039:
    #####:12040:      return dep_status;
        -:12041:    }
        -:12042:
      771:12043:  if (file->command_state == cs_deps_running)
branch  0 taken 0 (fallthrough)
branch  1 taken 771
        -:12044:    /* The commands for some deps were running on the last iteration, but
        -:12045:       they have finished now.  Reset the command_state to not_started to
        -:12046:       simplify later bookkeeping.  It is important that we do this only
        -:12047:       when the prior state was cs_deps_running, because that prior state
        -:12048:       was definitely propagated to FILE's also_make's by set_command_state
        -:12049:       (called above), but in another state an also_make may have
        -:12050:       independently changed to finished state, and we would confuse that
        -:12051:       file's bookkeeping (updated, but not_started is bogus state).  */
    #####:12052:    set_command_state (file, cs_not_started);
call    0 never executed
        -:12053:
        -:12054:  /* Now record which dependencies are more
        -:12055:     recent than this file, so we can define $?.  */
        -:12056:
      771:12057:  deps_changed = 0;
     771*:12058:  for (d = file->deps; d != 0; d = d->next)
branch  0 taken 0
branch  1 taken 771 (fallthrough)
        -:12059:    {
    #####:12060:      FILE_TIMESTAMP d_mtime = file_mtime (d->file);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:12061:      check_renamed (d->file);
branch  0 never executed
branch  1 never executed
        -:12062:
        -:12063:#if 1	/* %%% In version 4, remove this code completely to
        -:12064:	   implement not remaking deps if their deps are newer
        -:12065:	   than their parents.  */
    #####:12066:      if (d_mtime == (FILE_TIMESTAMP) -1 && !d->file->intermediate)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:12067:	/* We must remake if this dep does not
        -:12068:	   exist and is not intermediate.  */
    #####:12069:	must_make = 1;
        -:12070:#endif
        -:12071:
        -:12072:      /* Set DEPS_CHANGED if this dep actually changed.  */
    #####:12073:      deps_changed |= d->changed;
        -:12074:
        -:12075:      /* Set D->changed if either this dep actually changed,
        -:12076:	 or its dependent, FILE, is older or does not exist.  */
    #####:12077:      d->changed |= noexist || d_mtime > this_mtime;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:12078:
    #####:12079:      if (debug_flag && !noexist)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:12080:	{
    #####:12081:	  print_spaces (depth);
call    0 never executed
    #####:12082:	  if (d_mtime == (FILE_TIMESTAMP) -1)
branch  0 never executed
branch  1 never executed
    #####:12083:	    printf (_("Prerequisite `%s' does not exist.\n"), dep_name (d));
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:12084:	  else
    #####:12085:	    printf (_("Prerequisite `%s' is %s than target `%s'.\n"),
call    0 never executed
    #####:12086:		    dep_name (d), d->changed ? _("newer") : _("older"), file->name);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:12087:	  fflush (stdout);
call    0 never executed
        -:12088:	}
        -:12089:    }
        -:12090:
        -:12091:  /* Here depth returns to the value it had when we were called.  */
      771:12092:  depth--;
        -:12093:
     771*:12094:  if (file->double_colon && file->deps == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 771
branch  2 never executed
branch  3 never executed
        -:12095:    {
    #####:12096:      must_make = 1;
    #####:12097:      DEBUGPR (_("Target `%s' is double-colon and has no prerequisites.\n"));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:12098:    }
     771*:12099:  else if (!noexist && file->is_target && !deps_changed && file->cmds == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 771
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -:12100:    {
    #####:12101:      must_make = 0;
    #####:12102:      DEBUGPR (_("No commands for `%s' and no prerequisites actually changed.\n"));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:12103:    }
        -:12104:
      771:12105:  if (!must_make)
branch  0 taken 0 (fallthrough)
branch  1 taken 771
        -:12106:    {
    #####:12107:      if (debug_flag)
branch  0 never executed
branch  1 never executed
        -:12108:        {
    #####:12109:          print_spaces(depth);
call    0 never executed
    #####:12110:          printf(_("No need to remake target `%s'"), file->name);
call    0 never executed
    #####:12111:          if (!streq(file->name, file->hname))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:12112:              printf(_("; using VPATH name `%s'"), file->hname);
call    0 never executed
    #####:12113:          printf(".\n");
call    0 never executed
    #####:12114:          fflush(stdout);
call    0 never executed
        -:12115:        }
        -:12116:
    #####:12117:      notice_finished_file (file);
call    0 never executed
        -:12118:
        -:12119:      /* Since we don't need to remake the file, convert it to use the
        -:12120:         VPATH filename if we found one.  hfile will be either the
        -:12121:         local name if no VPATH or the VPATH name if one was found.  */
        -:12122:
    #####:12123:      while (file)
branch  0 never executed
branch  1 never executed
        -:12124:        {
    #####:12125:          file->name = file->hname;
    #####:12126:          file = file->prev;
        -:12127:        }
        -:12128:
    #####:12129:      return 0;
        -:12130:    }
        -:12131:
      771:12132:  DEBUGPR (_("Must remake target `%s'.\n"));
branch  0 taken 384 (fallthrough)
branch  1 taken 387
call    2 returned 384
call    3 returned 384
call    4 returned 384
        -:12133:
        -:12134:  /* It needs to be remade.  If it's VPATH and not reset via GPATH, toss the
        -:12135:     VPATH.  */
     771*:12136:  if (!streq(file->name, file->hname))
branch  0 taken 0 (fallthrough)
branch  1 taken 771
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -:12137:    {
    #####:12138:      if (debug_flag)
branch  0 never executed
branch  1 never executed
        -:12139:        {
    #####:12140:          print_spaces (depth);
call    0 never executed
    #####:12141:          printf(_("  Ignoring VPATH name `%s'.\n"), file->hname);
call    0 never executed
    #####:12142:          fflush(stdout);
call    0 never executed
        -:12143:        }
    #####:12144:      file->ignore_vpath = 1;
        -:12145:    }
        -:12146:
        -:12147:  /* Now, take appropriate actions to remake the file.  */
      771:12148:  remake_file (file);
call    0 returned 256
        -:12149:
      256:12150:  if (file->command_state != cs_finished)
branch  0 taken 0 (fallthrough)
branch  1 taken 256
        -:12151:    {
    #####:12152:      DEBUGPR (_("Commands of `%s' are being run.\n"));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:12153:      return 0;
        -:12154:    }
        -:12155:
      256:12156:  switch (file->update_status)
branch  0 taken 256
branch  1 taken 0
branch  2 taken 0
branch  3 taken 0
        -:12157:    {
      256:12158:    case 2:
      256:12159:      DEBUGPR (_("Failed to remake target file `%s'.\n"));
branch  0 taken 128 (fallthrough)
branch  1 taken 128
call    2 returned 128
call    3 returned 128
call    4 returned 128
      256:12160:      break;
    #####:12161:    case 0:
    #####:12162:      DEBUGPR (_("Successfully remade target file `%s'.\n"));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:12163:      break;
    #####:12164:    case 1:
    #####:12165:      DEBUGPR (_("Target file `%s' needs remade under -q.\n"));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:12166:      break;
    #####:12167:    default:
    #####:12168:      assert (file->update_status >= 0 && file->update_status <= 2);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:12169:      break;
        -:12170:    }
        -:12171:
      256:12172:  file->updated = 1;
      256:12173:  return file->update_status;
        -:12174:}
        -:12175:
        -:12176:/* Set FILE's `updated' flag and re-check its mtime and the mtime's of all
        -:12177:   files listed in its `also_make' member.  Under -t, this function also
        -:12178:   touches FILE.
        -:12179:
        -:12180:   On return, FILE->update_status will no longer be -1 if it was.  */
        -:12181:
        -:12182:void
function notice_finished_file called 256 returned 100% blocks executed 17%
      256:12183:notice_finished_file (file)
        -:12184:     register struct file *file;
        -:12185:{
        -:12186:  struct dep *d;
      256:12187:  int ran = file->command_state == cs_running;
        -:12188:
      256:12189:  file->command_state = cs_finished;
      256:12190:  file->updated = 1;
        -:12191:
      256:12192:  if (touch_flag
branch  0 taken 0 (fallthrough)
branch  1 taken 256
        -:12193:      /* The update status will be:
        -:12194:	 	-1	if this target was not remade;
        -:12195:		0	if 0 or more commands (+ or ${MAKE}) were run and won;
        -:12196:		1	if some commands were run and lost.
        -:12197:	 We touch the target if it has commands which either were not run
        -:12198:	 or won when they ran (i.e. status is 0).  */
    #####:12199:      && file->update_status == 0)
branch  0 never executed
branch  1 never executed
        -:12200:    {
    #####:12201:      if (file->cmds != 0 && file->cmds->any_recurse)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:12202:	{
        -:12203:	  /* If all the command lines were recursive,
        -:12204:	     we don't want to do the touching.  */
        -:12205:	  unsigned int i;
    #####:12206:	  for (i = 0; i < file->cmds->ncommand_lines; ++i)
branch  0 never executed
branch  1 never executed
    #####:12207:	    if (!(file->cmds->lines_flags[i] & COMMANDS_RECURSE))
branch  0 never executed
branch  1 never executed
    #####:12208:	      goto have_nonrecursing;
        -:12209:	}
        -:12210:      else
        -:12211:	{
    #####:12212:	have_nonrecursing:
    #####:12213:	  if (file->phony)
branch  0 never executed
branch  1 never executed
    #####:12214:	    file->update_status = 0;
        -:12215:	  else
        -:12216:	    /* Should set file's modification date and do nothing else.  */
    #####:12217:	    file->update_status = touch_file (file);
call    0 never executed
        -:12218:	}
        -:12219:    }
        -:12220:
      256:12221:  if (file->mtime_before_update == 0)
branch  0 taken 256 (fallthrough)
branch  1 taken 0
      256:12222:    file->mtime_before_update = file->last_mtime;
        -:12223:
     256*:12224:  if (ran && !file->phony)
branch  0 taken 0 (fallthrough)
branch  1 taken 256
branch  2 never executed
branch  3 never executed
        -:12225:    {
        -:12226:      struct file *f;
        -:12227:
    #####:12228:      if (just_print_flag || question_flag
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:12229:	  || (file->is_target && file->cmds == 0))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:12230:	file->last_mtime = NEW_MTIME;
        -:12231:      else
    #####:12232:	file->last_mtime = 0;
        -:12233:
        -:12234:      /* Propagate the change of modification time to all the double-colon
        -:12235:	 entries for this file.  */
    #####:12236:      for (f = file->double_colon; f != 0; f = f->next)
branch  0 never executed
branch  1 never executed
    #####:12237:	f->last_mtime = file->last_mtime;
        -:12238:    }
        -:12239:
     256*:12240:  if (ran && file->update_status != -1)
branch  0 taken 0 (fallthrough)
branch  1 taken 256
branch  2 never executed
branch  3 never executed
        -:12241:    /* We actually tried to update FILE, which has
        -:12242:       updated its also_make's as well (if it worked).
        -:12243:       If it didn't work, it wouldn't work again for them.
        -:12244:       So mark them as updated with the same status.  */
    #####:12245:    for (d = file->also_make; d != 0; d = d->next)
branch  0 never executed
branch  1 never executed
        -:12246:      {
    #####:12247:	d->file->command_state = cs_finished;
    #####:12248:	d->file->updated = 1;
    #####:12249:	d->file->update_status = file->update_status;
        -:12250:
    #####:12251:	if (ran && !d->file->phony)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:12252:	  /* Fetch the new modification time.
        -:12253:	     We do this instead of just invalidating the cached time
        -:12254:	     so that a vpath_search can happen.  Otherwise, it would
        -:12255:	     never be done because the target is already updated.  */
    #####:12256:	  (void) f_mtime (d->file, 0);
call    0 never executed
        -:12257:      }
      256:12258:  else if (file->update_status == -1)
branch  0 taken 0 (fallthrough)
branch  1 taken 256
        -:12259:    /* Nothing was done for FILE, but it needed nothing done.
        -:12260:       So mark it now as "succeeded".  */
    #####:12261:    file->update_status = 0;
      256:12262:}
        -:12263:
        -:12264:/* Check whether another file (whose mtime is THIS_MTIME)
        -:12265:   needs updating on account of a dependency which is file FILE.
        -:12266:   If it does, store 1 in *MUST_MAKE_PTR.
        -:12267:   In the process, update any non-intermediate files
        -:12268:   that FILE depends on (including FILE itself).
        -:12269:   Return nonzero if any updating failed.  */
        -:12270:
        -:12271:static int
function check_dep called 0 returned 0% blocks executed 0%
    #####:12272:check_dep (file, depth, this_mtime, must_make_ptr)
        -:12273:     struct file *file;
        -:12274:     unsigned int depth;
        -:12275:     FILE_TIMESTAMP this_mtime;
        -:12276:     int *must_make_ptr;
        -:12277:{
        -:12278:  register struct dep *d;
    #####:12279:  int dep_status = 0;
        -:12280:
    #####:12281:  ++depth;
    #####:12282:  file->updating = 1;
        -:12283:
    #####:12284:  if (!file->intermediate)
branch  0 never executed
branch  1 never executed
        -:12285:    /* If this is a non-intermediate file, update it and record
        -:12286:       whether it is newer than THIS_MTIME.  */
        -:12287:    {
        -:12288:      FILE_TIMESTAMP mtime;
    #####:12289:      dep_status = update_file (file, depth);
call    0 never executed
    #####:12290:      check_renamed (file);
branch  0 never executed
branch  1 never executed
    #####:12291:      mtime = file_mtime (file);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:12292:      check_renamed (file);
branch  0 never executed
branch  1 never executed
    #####:12293:      if (mtime == (FILE_TIMESTAMP) -1 || mtime > this_mtime)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:12294:	*must_make_ptr = 1;
        -:12295:    }
        -:12296:  else
        -:12297:    {
        -:12298:      /* FILE is an intermediate file.  */
        -:12299:      FILE_TIMESTAMP mtime;
        -:12300:
    #####:12301:      if (!file->phony && file->cmds == 0 && !file->tried_implicit)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:12302:	{
    #####:12303:	  if (try_implicit_rule (file, depth))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:12304:	    DEBUGPR (_("Found an implicit rule for `%s'.\n"));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:12305:	  else
    #####:12306:	    DEBUGPR (_("No implicit rule found for `%s'.\n"));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:12307:	  file->tried_implicit = 1;
        -:12308:	}
    #####:12309:      if (file->cmds == 0 && !file->is_target
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:12310:	  && default_file != 0 && default_file->cmds != 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:12311:	{
    #####:12312:	  DEBUGPR (_("Using default commands for `%s'.\n"));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:12313:	  file->cmds = default_file->cmds;
        -:12314:	}
        -:12315:
        -:12316:      /* If the intermediate file actually exists
        -:12317:	 and is newer, then we should remake from it.  */
    #####:12318:      check_renamed (file);
branch  0 never executed
branch  1 never executed
    #####:12319:      mtime = file_mtime (file);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:12320:      check_renamed (file);
branch  0 never executed
branch  1 never executed
    #####:12321:      if (mtime != (FILE_TIMESTAMP) -1 && mtime > this_mtime)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:12322:	*must_make_ptr = 1;
        -:12323:	  /* Otherwise, update all non-intermediate files we depend on,
        -:12324:	     if necessary, and see whether any of them is more
        -:12325:	     recent than the file on whose behalf we are checking.  */
        -:12326:      else
        -:12327:	{
        -:12328:	  register struct dep *lastd;
        -:12329:
    #####:12330:	  lastd = 0;
    #####:12331:	  d = file->deps;
    #####:12332:	  while (d != 0)
branch  0 never executed
branch  1 never executed
        -:12333:	    {
    #####:12334:	      if (d->file->updating)
branch  0 never executed
branch  1 never executed
        -:12335:		{
    #####:12336:		  error (NILF, _("Circular %s <- %s dependency dropped."),
    #####:12337:			 file->name, d->file->name);
call    0 never executed
    #####:12338:		  if (lastd == 0)
branch  0 never executed
branch  1 never executed
        -:12339:		    {
    #####:12340:		      file->deps = d->next;
    #####:12341:		      free ((char *) d);
    #####:12342:		      d = file->deps;
        -:12343:		    }
        -:12344:		  else
        -:12345:		    {
    #####:12346:		      lastd->next = d->next;
    #####:12347:		      free ((char *) d);
    #####:12348:		      d = lastd->next;
        -:12349:		    }
    #####:12350:		  continue;
        -:12351:		}
        -:12352:
    #####:12353:	      d->file->parent = file;
    #####:12354:	      dep_status |= check_dep (d->file, depth, this_mtime,
call    0 never executed
        -:12355:                                       must_make_ptr);
    #####:12356:	      check_renamed (d->file);
branch  0 never executed
branch  1 never executed
    #####:12357:	      if (dep_status != 0 && !keep_going_flag)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:12358:		break;
        -:12359:
    #####:12360:	      if (d->file->command_state == cs_running
branch  0 never executed
branch  1 never executed
    #####:12361:		  || d->file->command_state == cs_deps_running)
branch  0 never executed
branch  1 never executed
        -:12362:		/* Record that some of FILE's deps are still being made.
        -:12363:		   This tells the upper levels to wait on processing it until
        -:12364:		   the commands are finished.  */
    #####:12365:		set_command_state (file, cs_deps_running);
call    0 never executed
        -:12366:
    #####:12367:	      lastd = d;
    #####:12368:	      d = d->next;
        -:12369:	    }
        -:12370:	}
        -:12371:    }
        -:12372:
    #####:12373:  file->updating = 0;
    #####:12374:  return dep_status;
        -:12375:}
        -:12376:
        -:12377:/* Touch FILE.  Return zero if successful, one if not.  */
        -:12378:
        -:12379:#define TOUCH_ERROR(call) return (perror_with_name (call, file->name), 1)
        -:12380:
        -:12381:static int
function touch_file called 0 returned 0% blocks executed 0%
    #####:12382:touch_file (file)
        -:12383:     register struct file *file;
        -:12384:{
    #####:12385:  if (!silent_flag)
branch  0 never executed
branch  1 never executed
    #####:12386:    message (0, "touch %s", file->name);
call    0 never executed
        -:12387:
        -:12388:#ifndef	NO_ARCHIVES
    #####:12389:  if (ar_name (file->name))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:12390:    return ar_touch (file->name);
call    0 never executed
        -:12391:  else
        -:12392:#endif
        -:12393:    {
    #####:12394:      int fd = open (file->name, O_RDWR | O_CREAT, 0666);
call    0 never executed
        -:12395:
    #####:12396:      if (fd < 0)
branch  0 never executed
branch  1 never executed
    #####:12397:	TOUCH_ERROR ("touch: open: ");
call    0 never executed
        -:12398:      else
        -:12399:	{
        -:12400:	  struct stat statbuf;
        -:12401:	  char buf;
        -:12402:	  int status;
        -:12403:
        -:12404:	  do
    #####:12405:	    status = fstat (fd, &statbuf);
call    0 never executed
    #####:12406:	  while (status < 0 && EINTR_SET);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:12407:
    #####:12408:	  if (status < 0)
branch  0 never executed
branch  1 never executed
    #####:12409:	    TOUCH_ERROR ("touch: fstat: ");
call    0 never executed
        -:12410:	  /* Rewrite character 0 same as it already is.  */
    #####:12411:	  if (read (fd, &buf, 1) < 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:12412:	    TOUCH_ERROR ("touch: read: ");
call    0 never executed
    #####:12413:	  if (off_t_equal(off_t_to_int(lseek (fd, int_to_off_t(0L), 0)), ZERO_L_off_t) < 0)
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -:12414:	    /*	  if (lseek (fd, 0L, 0) < 0L) */
    #####:12415:	    TOUCH_ERROR ("touch: lseek: ");
call    0 never executed
    #####:12416:	  if (write (fd, &buf, 1) < 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:12417:	    TOUCH_ERROR ("touch: write: ");
call    0 never executed
        -:12418:	  /* If file length was 0, we just
        -:12419:	     changed it, so change it back.  */
    #####:12420:	  if (off_t_equal(off_t_to_int(statbuf.st_size), ZERO_off_t) == 0)
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:12421:	    /*	  if (statbuf.st_size == 0) */
        -:12422:	    {
    #####:12423:	      (void) close (fd);
call    0 never executed
    #####:12424:	      fd = open (file->name, O_RDWR | O_TRUNC, 0666);
call    0 never executed
    #####:12425:	      if (fd < 0)
branch  0 never executed
branch  1 never executed
    #####:12426:		TOUCH_ERROR ("touch: open: ");
call    0 never executed
        -:12427:	    }
    #####:12428:	  (void) close (fd);
call    0 never executed
        -:12429:	}
        -:12430:    }
        -:12431:
    #####:12432:  return 0;
        -:12433:}
        -:12434:
        -:12435:/* Having checked and updated the dependencies of FILE,
        -:12436:   do whatever is appropriate to remake FILE itself.
        -:12437:   Return the status from executing FILE's commands.  */
        -:12438:
        -:12439:static void
function remake_file called 771 returned 33% blocks executed 43%
      771:12440:remake_file (file)
        -:12441:     struct file *file;
        -:12442:{
      771:12443:  if (file->cmds == 0)
branch  0 taken 771 (fallthrough)
branch  1 taken 0
        -:12444:    {
      771:12445:      if (file->phony)
branch  0 taken 0 (fallthrough)
branch  1 taken 771
        -:12446:	/* Phony target.  Pretend it succeeded.  */
    #####:12447:	file->update_status = 0;
      771:12448:      else if (file->is_target)
branch  0 taken 0 (fallthrough)
branch  1 taken 771
        -:12449:	/* This is a nonexistent target file we cannot make.
        -:12450:	   Pretend it was successfully remade.  */
    #####:12451:	file->update_status = 0;
        -:12452:      else
      771:12453:        no_rule_error(file);
call    0 returned 256
        -:12454:    }
        -:12455:  else
        -:12456:    {
    #####:12457:      chop_commands (file->cmds);
call    0 never executed
        -:12458:
    #####:12459:      if (!touch_flag || file->cmds->any_recurse)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:12460:	{
    #####:12461:	  execute_file_commands (file);
call    0 never executed
    #####:12462:	  return;
        -:12463:	}
        -:12464:      else
        -:12465:	/* This tells notice_finished_file it is ok to touch the file.  */
    #####:12466:	file->update_status = 0;
        -:12467:    }
        -:12468:
        -:12469:  /* This does the touching under -t.  */
      256:12470:  notice_finished_file (file);
call    0 returned 256
        -:12471:}
        -:12472:
        -:12473:/* Return the mtime of a file, given a `struct file'.
        -:12474:   Caches the time in the struct file to avoid excess stat calls.
        -:12475:
        -:12476:   If the file is not found, and SEARCH is nonzero, VPATH searching and
        -:12477:   replacement is done.  If that fails, a library (-lLIBNAME) is tried and
        -:12478:   the library's actual name (/lib/libLIBNAME.a, etc.) is substituted into
        -:12479:   FILE.  */
        -:12480:
        -:12481:FILE_TIMESTAMP
function f_mtime called 771 returned 100% blocks executed 18%
      771:12482:f_mtime (file, search)
        -:12483:     register struct file *file;
        -:12484:     int search;
        -:12485:{
        -:12486:  FILE_TIMESTAMP mtime;
        -:12487:
        -:12488:  /* File's mtime is not known; must get it from the system.  */
        -:12489:
        -:12490:#ifndef	NO_ARCHIVES
      771:12491:  if (ar_name (file->name))
call    0 returned 771
branch  1 taken 0 (fallthrough)
branch  2 taken 771
        -:12492:    {
        -:12493:      /* This file is an archive-member reference.  */
        -:12494:
        -:12495:      char *arname, *memname;
        -:12496:      struct file *arfile;
    #####:12497:      int arname_used = 0;
        -:12498:
        -:12499:      /* Find the archive's name.  */
    #####:12500:      ar_parse_name (file->name, &arname, &memname);
call    0 never executed
        -:12501:
        -:12502:      /* Find the modification time of the archive itself.
        -:12503:	 Also allow for its name to be changed via VPATH search.  */
    #####:12504:      arfile = lookup_file (arname);
call    0 never executed
    #####:12505:      if (arfile == 0)
branch  0 never executed
branch  1 never executed
        -:12506:	{
    #####:12507:	  arfile = enter_file (arname);
call    0 never executed
    #####:12508:	  arname_used = 1;
        -:12509:	}
    #####:12510:      mtime = f_mtime (arfile, search);
call    0 never executed
    #####:12511:      check_renamed (arfile);
branch  0 never executed
branch  1 never executed
    #####:12512:      if (search && strcmp (arfile->hname, arname))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:12513:	{
        -:12514:	  /* The archive's name has changed.
        -:12515:	     Change the archive-member reference accordingly.  */
        -:12516:
        -:12517:          char *name;
        -:12518:	  unsigned int arlen, memlen;
        -:12519:
    #####:12520:	  if (!arname_used)
branch  0 never executed
branch  1 never executed
        -:12521:	    {
    #####:12522:	      free (arname);
    #####:12523:	      arname_used = 1;
        -:12524:	    }
        -:12525:
    #####:12526:	  arname = arfile->hname;
    #####:12527:	  arlen = strlen (arname);
    #####:12528:	  memlen = strlen (memname);
        -:12529:
        -:12530:	  /* free (file->name); */
        -:12531:
    #####:12532:	  name = (char *) xmalloc (arlen + 1 + memlen + 2);
call    0 never executed
    #####:12533:	  bcopy (arname, name, arlen);
    #####:12534:	  name[arlen] = '(';
    #####:12535:	  bcopy (memname, name + arlen + 1, memlen);
    #####:12536:	  name[arlen + 1 + memlen] = ')';
    #####:12537:	  name[arlen + 1 + memlen + 1] = '\0';
        -:12538:
        -:12539:          /* If the archive was found with GPATH, make the change permanent;
        -:12540:             otherwise defer it until later.  */
    #####:12541:          if (arfile->name == arfile->hname)
branch  0 never executed
branch  1 never executed
    #####:12542:            rename_file (file, name);
call    0 never executed
        -:12543:          else
    #####:12544:            rehash_file (file, name);
call    0 never executed
    #####:12545:          check_renamed (file);
branch  0 never executed
branch  1 never executed
        -:12546:	}
        -:12547:
    #####:12548:      if (!arname_used)
branch  0 never executed
branch  1 never executed
    #####:12549:	free (arname);
    #####:12550:      free (memname);
        -:12551:
    #####:12552:      if (mtime == (FILE_TIMESTAMP) -1)
branch  0 never executed
branch  1 never executed
        -:12553:	/* The archive doesn't exist, so it's members don't exist either.  */
    #####:12554:	return (FILE_TIMESTAMP) -1;
        -:12555:
    #####:12556:      mtime = ar_member_date (file->hname);
call    0 never executed
        -:12557:    }
        -:12558:  else
        -:12559:#endif
        -:12560:    {
      771:12561:      mtime = name_mtime (file->name);
call    0 returned 771
        -:12562:
     771*:12563:      if (mtime == (FILE_TIMESTAMP) -1 && search && !file->ignore_vpath)
branch  0 taken 771 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 771
branch  4 never executed
branch  5 never executed
        -:12564:	{
        -:12565:	  /* If name_mtime failed, search VPATH.  */
    #####:12566:	  char *name = file->name;
    #####:12567:	  if (vpath_search (&name, &mtime)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:12568:	      /* Last resort, is it a library (-lxxx)?  */
    #####:12569:	      || (name[0] == '-' && name[1] == 'l'
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:12570:		  && library_search (&name, &mtime)))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:12571:	    {
    #####:12572:	      if (mtime != 0)
branch  0 never executed
branch  1 never executed
        -:12573:		/* vpath_search and library_search store zero in MTIME
        -:12574:		   if they didn't need to do a stat call for their work.  */
    #####:12575:		file->last_mtime = mtime;
        -:12576:
        -:12577:              /* If we found it in VPATH, see if it's in GPATH too; if so,
        -:12578:                 change the name right now; if not, defer until after the
        -:12579:                 dependencies are updated. */
    #####:12580:              if (gpath_search (name, strlen(name) - strlen(file->name) - 1))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:12581:                {
    #####:12582:                  rename_file (file, name);
call    0 never executed
    #####:12583:                  check_renamed (file);
branch  0 never executed
branch  1 never executed
    #####:12584:                  return file_mtime (file);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:12585:                }
        -:12586:
    #####:12587:	      rehash_file (file, name);
call    0 never executed
    #####:12588:	      check_renamed (file);
branch  0 never executed
branch  1 never executed
    #####:12589:	      mtime = name_mtime (name);
call    0 never executed
        -:12590:	    }
        -:12591:	}
        -:12592:    }
        -:12593:
        -:12594:  {
        -:12595:    /* Files can have bogus timestamps that nothing newly made will be
        -:12596:       "newer" than.  Updating their dependents could just result in loops.
        -:12597:       So notify the user of the anomaly with a warning.
        -:12598:
        -:12599:       We only need to do this once, for now. */
        -:12600:
        -:12601:    static FILE_TIMESTAMP now = 0;
      771:12602:    if (!clock_skew_detected
branch  0 taken 771 (fallthrough)
branch  1 taken 0
     771*:12603:        && mtime != (FILE_TIMESTAMP)-1 && mtime > now
branch  0 taken 0 (fallthrough)
branch  1 taken 771
branch  2 never executed
branch  3 never executed
    #####:12604:        && !file->updated)
branch  0 never executed
branch  1 never executed
        -:12605:      {
        -:12606:	/* This file's time appears to be in the future.
        -:12607:	   Update our concept of the present, and compare again.  */
        -:12608:
    #####:12609:	now = file_timestamp_now ();
call    0 never executed
        -:12610:
        -:12611:#ifdef WINDOWS32
        -:12612:	/*
        -:12613:	 * FAT filesystems round time to nearest even second(!). Just
        -:12614:	 * allow for any file (NTFS or FAT) to perhaps suffer from this
        -:12615:	 * braindamage.
        -:12616:	 */
        -:12617:	if (mtime > now && (((mtime % 2) == 0) && ((mtime-1) > now)))
        -:12618:#else
        -:12619:#ifdef __MSDOS__
        -:12620:	/* Scrupulous testing indicates that some Windows
        -:12621:	   filesystems can set file times up to 3 sec into the future!  */
        -:12622:	if (mtime > now + 3)
        -:12623:#else
    #####:12624:        if (mtime > now)
branch  0 never executed
branch  1 never executed
        -:12625:#endif
        -:12626:#endif
        -:12627:          {
        -:12628:	    char mtimebuf[FILE_TIMESTAMP_PRINT_LEN_BOUND + 1];
        -:12629:	    char nowbuf[FILE_TIMESTAMP_PRINT_LEN_BOUND + 1];
        -:12630:
    #####:12631:	    file_timestamp_sprintf (mtimebuf, mtime);
call    0 never executed
    #####:12632:	    file_timestamp_sprintf (nowbuf, now);
call    0 never executed
    #####:12633:            error (NILF, _("*** Warning: File `%s' has modification time in the future (%s > %s)"),
call    0 never executed
        -:12634:                   file->name, mtimebuf, nowbuf);
    #####:12635:            clock_skew_detected = 1;
        -:12636:          }
        -:12637:      }
        -:12638:  }
        -:12639:
        -:12640:  /* Store the mtime into all the entries for this file.  */
      771:12641:  if (file->double_colon)
branch  0 taken 0 (fallthrough)
branch  1 taken 771
    #####:12642:    file = file->double_colon;
        -:12643:
        -:12644:  do
        -:12645:    {
        -:12646:      /* If this file is not implicit but it is intermediate then it was
        -:12647:	 made so by the .INTERMEDIATE target.  If this file has never
        -:12648:	 been built by us but was found now, it existed before make
        -:12649:	 started.  So, turn off the intermediate bit so make doesn't
        -:12650:	 delete it, since it didn't create it.  */
     771*:12651:      if (mtime != (FILE_TIMESTAMP)-1 && file->command_state == cs_not_started
branch  0 taken 0 (fallthrough)
branch  1 taken 771
branch  2 never executed
branch  3 never executed
    #####:12652:	  && !file->tried_implicit && file->intermediate)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:12653:	file->intermediate = 0;
        -:12654:
      771:12655:      file->last_mtime = mtime;
      771:12656:      file = file->prev;
        -:12657:    }
      771:12658:  while (file != 0);
branch  0 taken 0
branch  1 taken 771 (fallthrough)
        -:12659:
      771:12660:  return mtime;
        -:12661:}
        -:12662:
        -:12663:
        -:12664:/* Return the mtime of the file or archive-member reference NAME.  */
        -:12665:
        -:12666:static FILE_TIMESTAMP
function name_mtime called 771 returned 100% blocks executed 83%
      771:12667:name_mtime (name)
        -:12668:     register char *name;
        -:12669:{
        -:12670:  struct stat st;
        -:12671:
      771:12672:  if (stat (name, &st) < 0)
call    0 returned 771
branch  1 taken 771 (fallthrough)
branch  2 taken 0
      771:12673:    return (FILE_TIMESTAMP) -1;
        -:12674:
    #####:12675:  return FILE_TIMESTAMP_STAT_MODTIME (st);
        -:12676:}
        -:12677:
        -:12678:
        -:12679:/* Search for a library file specified as -lLIBNAME, searching for a
        -:12680:   suitable library file in the system library directories and the VPATH
        -:12681:   directories.  */
        -:12682:
        -:12683:static int
function library_search called 0 returned 0% blocks executed 0%
    #####:12684:library_search (lib, mtime_ptr)
        -:12685:     char **lib;
        -:12686:     FILE_TIMESTAMP *mtime_ptr;
        -:12687:{
        -:12688:  static char *dirs[] =
        -:12689:    {
        -:12690:#ifndef _AMIGA
        -:12691:      "/lib",
        -:12692:      "/usr/lib",
        -:12693:#endif
        -:12694:#if defined(WINDOWS32) && !defined(LIBDIR)
        -:12695:/*
        -:12696: * This is completely up to the user at product install time. Just define
        -:12697: * a placeholder.
        -:12698: */
        -:12699:#define LIBDIR "."
        -:12700:#endif
        -:12701:      LIBDIR,			/* Defined by configuration.  */
        -:12702:      0
        -:12703:    };
        -:12704:
        -:12705:  static char *libpatterns = NULL;
        -:12706:
    #####:12707:  char *libname = &(*lib)[2];	/* Name without the `-l'.  */
        -:12708:  FILE_TIMESTAMP mtime;
        -:12709:
        -:12710:  /* Loop variables for the libpatterns value.  */
        -:12711:  char *p, *p2;
        -:12712:  int len;
        -:12713:
        -:12714:  char *file, **dp;
        -:12715:
        -:12716:  /* If we don't have libpatterns, get it.  */
    #####:12717:  if (!libpatterns)
branch  0 never executed
branch  1 never executed
        -:12718:    {
    #####:12719:      int save = warn_undefined_variables_flag;
    #####:12720:      warn_undefined_variables_flag = 0;
        -:12721:
    #####:12722:      libpatterns = xstrdup (variable_expand ("$(strip $(.LIBPATTERNS))"));
call    0 never executed
call    1 never executed
        -:12723:
    #####:12724:      warn_undefined_variables_flag = save;
        -:12725:    }
        -:12726:
        -:12727:  /* Loop through all the patterns in .LIBPATTERNS, and search on each one.  */
    #####:12728:  p2 = libpatterns;
    #####:12729:  while ((p = find_next_token (&p2, &len)) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:12730:    {
        -:12731:      static char *buf = NULL;
        -:12732:      static int buflen = 0;
        -:12733:      static int libdir_maxlen = -1;
    #####:12734:      char *libbuf = variable_expand ("");
call    0 never executed
        -:12735:
        -:12736:      /* Expand the pattern using LIBNAME as a replacement.  */
        -:12737:      {
    #####:12738:	char c = p[len];
        -:12739:	char *p3, *p4;
        -:12740:
    #####:12741:	p[len] = '\0';
    #####:12742:	p3 = find_percent (p);
call    0 never executed
    #####:12743:	if (!p3)
branch  0 never executed
branch  1 never executed
        -:12744:	  {
        -:12745:	    /* Give a warning if there is no pattern, then remove the
        -:12746:	       pattern so it's ignored next time.  */
    #####:12747:	    error (NILF, _(".LIBPATTERNS element `%s' is not a pattern"), p);
call    0 never executed
    #####:12748:	    for (; len; --len, ++p)
branch  0 never executed
branch  1 never executed
    #####:12749:	      *p = ' ';
    #####:12750:	    *p = c;
    #####:12751:	    continue;
        -:12752:	  }
    #####:12753:	p4 = variable_buffer_output (libbuf, p, p3-p);
call    0 never executed
    #####:12754:	p4 = variable_buffer_output (p4, libname, strlen (libname));
call    0 never executed
    #####:12755:	p4 = variable_buffer_output (p4, p3+1, len - (p3-p));
call    0 never executed
    #####:12756:	p[len] = c;
        -:12757:      }
        -:12758:
        -:12759:      /* Look first for `libNAME.a' in the current directory.  */
    #####:12760:      mtime = name_mtime (libbuf);
call    0 never executed
    #####:12761:      if (mtime != (FILE_TIMESTAMP) -1)
branch  0 never executed
branch  1 never executed
        -:12762:	{
    #####:12763:	  *lib = xstrdup (libbuf);
call    0 never executed
    #####:12764:	  if (mtime_ptr != 0)
branch  0 never executed
branch  1 never executed
    #####:12765:	    *mtime_ptr = mtime;
    #####:12766:	  return 1;
        -:12767:	}
        -:12768:
        -:12769:      /* Now try VPATH search on that.  */
        -:12770:
    #####:12771:      file = libbuf;
    #####:12772:      if (vpath_search (&file, mtime_ptr))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:12773:	{
    #####:12774:	  *lib = file;
    #####:12775:	  return 1;
        -:12776:	}
        -:12777:
        -:12778:      /* Now try the standard set of directories.  */
        -:12779:
    #####:12780:      if (!buflen)
branch  0 never executed
branch  1 never executed
        -:12781:	{
    #####:12782:	  for (dp = dirs; *dp != 0; ++dp)
branch  0 never executed
branch  1 never executed
        -:12783:	    {
    #####:12784:	      int l = strlen (*dp);
    #####:12785:	      if (l > libdir_maxlen)
branch  0 never executed
branch  1 never executed
    #####:12786:		libdir_maxlen = l;
        -:12787:	    }
    #####:12788:	  buflen = strlen (libbuf);
    #####:12789:	  buf = xmalloc(libdir_maxlen + buflen + 2);
call    0 never executed
        -:12790:	}
    #####:12791:      else if (buflen < strlen (libbuf))
branch  0 never executed
branch  1 never executed
        -:12792:	{
    #####:12793:	  buflen = strlen (libbuf);
    #####:12794:	  buf = xrealloc (buf, libdir_maxlen + buflen + 2);
call    0 never executed
        -:12795:	}
        -:12796:
    #####:12797:      for (dp = dirs; *dp != 0; ++dp)
branch  0 never executed
branch  1 never executed
        -:12798:	{
    #####:12799:	  sprintf (buf, "%s/%s", *dp, libbuf);
    #####:12800:	  mtime = name_mtime (buf);
call    0 never executed
    #####:12801:	  if (mtime != (FILE_TIMESTAMP) -1)
branch  0 never executed
branch  1 never executed
        -:12802:	    {
    #####:12803:	      *lib = xstrdup (buf);
call    0 never executed
    #####:12804:	      if (mtime_ptr != 0)
branch  0 never executed
branch  1 never executed
    #####:12805:		*mtime_ptr = mtime;
    #####:12806:	      return 1;
        -:12807:	    }
        -:12808:	}
        -:12809:    }
        -:12810:
    #####:12811:  return 0;
        -:12812:}
        -:12813:
        -:12814:
        -:12815:
        -:12816:/*************************************************************
        -:12817:  ============================================================
        -:12818:  ************************************************************
        -:12819:  ============================================================
        -:12820:  ************************************************************
        -:12821:                         rule.c
        -:12822:  ************************************************************
        -:12823:  ============================================================
        -:12824:  ************************************************************
        -:12825:  ============================================================
        -:12826:  *************************************************************/
        -:12827:
        -:12828:/* Pattern and suffix rule internals for GNU Make.
        -:12829:Copyright (C) 1988,89,90,91,92,93, 1998 Free Software Foundation, Inc.
        -:12830:This file is part of GNU Make.
        -:12831:
        -:12832:GNU Make is free software; you can redistribute it and/or modify
        -:12833:it under the terms of the GNU General Public License as published by
        -:12834:the Free Software Foundation; either version 2, or (at your option)
        -:12835:any later version.
        -:12836:
        -:12837:GNU Make is distributed in the hope that it will be useful,
        -:12838:but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:12839:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:12840:GNU General Public License for more details.
        -:12841:
        -:12842:You should have received a copy of the GNU General Public License
        -:12843:along with GNU Make; see the file COPYING.  If not, write to
        -:12844:the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
        -:12845:Boston, MA 02111-1307, USA.  */
        -:12846:
        -:12847:/* #include "make.h"  <- modification by J.Ruthruff, 7/27 */
        -:12848:/* #include "dep.h"  <- modification by J.Ruthruff, 7/27 */
        -:12849:/* #include "filedef.h"  <- modification by J.Ruthruff, 7/27 */
        -:12850:#include "job.h"
        -:12851:/* #include "commands.h"  <- modification by J.Ruthruff, 7/27 */
        -:12852:/* #include "variable.h"  <- modification by J.Ruthruff, 7/27 */
        -:12853:/* #include "rule.h"  <- modification by J.Ruthruff, 7/27 */
        -:12854:#undef stderr
        -:12855:#define stderr stdout
        -:12856:
        -:12857:static void freerule PARAMS ((struct rule *rule, struct rule *lastrule));
        -:12858:
        -:12859:/* Chain of all pattern rules.  */
        -:12860:
        -:12861:struct rule *pattern_rules;
        -:12862:
        -:12863:/* Pointer to last rule in the chain, so we can add onto the end.  */
        -:12864:
        -:12865:struct rule *last_pattern_rule;
        -:12866:
        -:12867:/* Number of rules in the chain.  */
        -:12868:
        -:12869:unsigned int num_pattern_rules;
        -:12870:
        -:12871:/* Maximum number of target patterns of any pattern rule.  */
        -:12872:
        -:12873:unsigned int max_pattern_targets;
        -:12874:
        -:12875:/* Maximum number of dependencies of any pattern rule.  */
        -:12876:
        -:12877:unsigned int max_pattern_deps;
        -:12878:
        -:12879:/* Maximum length of the name of a dependencies of any pattern rule.  */
        -:12880:
        -:12881:unsigned int max_pattern_dep_length;
        -:12882:
        -:12883:/* Chain of all pattern-specific variables.  */
        -:12884:
        -:12885:static struct pattern_var *pattern_vars;
        -:12886:
        -:12887:/* Pointer to last struct in the chain, so we can add onto the end.  */
        -:12888:
        -:12889:static struct pattern_var *last_pattern_var;
        -:12890:
        -:12891:/* Pointer to structure for the file .SUFFIXES
        -:12892:   whose dependencies are the suffixes to be searched.  */
        -:12893:
        -:12894:struct file *suffix_file;
        -:12895:
        -:12896:/* Maximum length of a suffix.  */
        -:12897:
        -:12898:unsigned int maxsuffix;
        -:12899:
        -:12900:/* Compute the maximum dependency length and maximum number of
        -:12901:   dependencies of all implicit rules.  Also sets the subdir
        -:12902:   flag for a rule when appropriate, possibly removing the rule
        -:12903:   completely when appropriate.  */
        -:12904:
        -:12905:void
function count_implicit_rule_limits called 771 returned 100% blocks executed 92%
      771:12906:count_implicit_rule_limits ()
        -:12907:{
        -:12908:  char *name;
        -:12909:  unsigned int namelen;
        -:12910:  register struct rule *rule, *lastrule;
        -:12911:
      771:12912:  num_pattern_rules = max_pattern_targets = max_pattern_deps = 0;
      771:12913:  max_pattern_dep_length = 0;
        -:12914:
      771:12915:  name = 0;
      771:12916:  namelen = 0;
      771:12917:  rule = pattern_rules;
      771:12918:  lastrule = 0;
    67077:12919:  while (rule != 0)
branch  0 taken 66306
branch  1 taken 771 (fallthrough)
        -:12920:    {
    66306:12921:      unsigned int ndeps = 0;
        -:12922:      register struct dep *dep;
    66306:12923:      struct rule *next = rule->next;
        -:12924:      unsigned int ntargets;
        -:12925:
    66306:12926:      ++num_pattern_rules;
        -:12927:
    66306:12928:      ntargets = 0;
   132612:12929:      while (rule->targets[ntargets] != 0)
branch  0 taken 66306
branch  1 taken 66306 (fallthrough)
    66306:12930:	++ntargets;
        -:12931:
    66306:12932:      if (ntargets > max_pattern_targets)
branch  0 taken 771 (fallthrough)
branch  1 taken 65535
      771:12933:	max_pattern_targets = ntargets;
        -:12934:
   109482:12935:      for (dep = rule->deps; dep != 0; dep = dep->next)
branch  0 taken 43176
branch  1 taken 66306 (fallthrough)
        -:12936:	{
    43176:12937:	  unsigned int len = strlen (dep->name);
        -:12938:
        -:12939:#ifdef VMS
        -:12940:	  char *p = rindex (dep->name, ']');
        -:12941:#else
    43176:12942:	  char *p = rindex (dep->name, '/');
        -:12943:#endif
    43176:12944:	  char *p2 = p != 0 ? index (dep->name, '%') : 0;
branch  0 taken 2313 (fallthrough)
branch  1 taken 40863
    43176:12945:	  ndeps++;
        -:12946:
    43176:12947:	  if (len > max_pattern_dep_length)
branch  0 taken 3084 (fallthrough)
branch  1 taken 40092
     3084:12948:	    max_pattern_dep_length = len;
        -:12949:
    43176:12950:	  if (p != 0 && p2 > p)
branch  0 taken 2313 (fallthrough)
branch  1 taken 40863
branch  2 taken 2313 (fallthrough)
branch  3 taken 0
        -:12951:	    {
        -:12952:	      /* There is a slash before the % in the dep name.
        -:12953:		 Extract the directory name.  */
     2313:12954:	      if (p == dep->name)
branch  0 taken 0 (fallthrough)
branch  1 taken 2313
    #####:12955:		++p;
     2313:12956:	      if (p - dep->name > namelen)
branch  0 taken 1542 (fallthrough)
branch  1 taken 771
        -:12957:		{
     1542:12958:		  if (name != 0)
branch  0 taken 771 (fallthrough)
branch  1 taken 771
      771:12959:		    free (name);
     1542:12960:		  namelen = p - dep->name;
     1542:12961:		  name = (char *) xmalloc (namelen + 1);
call    0 returned 1542
        -:12962:		}
     2313:12963:	      bcopy (dep->name, name, p - dep->name);
     2313:12964:	      name[p - dep->name] = '\0';
        -:12965:
        -:12966:	      /* In the deps of an implicit rule the `changed' flag
        -:12967:		 actually indicates that the dependency is in a
        -:12968:		 nonexistent subdirectory.  */
        -:12969:
     2313:12970:	      dep->changed = !dir_file_exists_p (name, "");
call    0 returned 2313
        -:12971:#ifdef VMS
        -:12972:	      if (dep->changed && *name == ']')
        -:12973:#else
     2313:12974:	      if (dep->changed && *name == '/')
branch  0 taken 2313 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 2313
        -:12975:#endif
        -:12976:		{
        -:12977:		  /* The name is absolute and the directory does not exist.
        -:12978:		     This rule can never possibly match, since this dependency
        -:12979:		     can never possibly exist.  So just remove the rule from
        -:12980:		     the list.  */
    #####:12981:		  freerule (rule, lastrule);
call    0 never executed
    #####:12982:		  --num_pattern_rules;
    #####:12983:		  goto end_main_loop;
        -:12984:		}
        -:12985:	    }
        -:12986:	  else
        -:12987:	    /* This dependency does not reside in a subdirectory.  */
    40863:12988:	    dep->changed = 0;
        -:12989:	}
        -:12990:
    66306:12991:      if (ndeps > max_pattern_deps)
branch  0 taken 1542 (fallthrough)
branch  1 taken 64764
     1542:12992:	max_pattern_deps = ndeps;
        -:12993:
    66306:12994:      lastrule = rule;
    66306:12995:    end_main_loop:
    66306:12996:      rule = next;
        -:12997:    }
        -:12998:
      771:12999:  if (name != 0)
branch  0 taken 771 (fallthrough)
branch  1 taken 0
      771:13000:    free (name);
      771:13001:}
        -:13002:
        -:13003:/* Create a pattern rule from a suffix rule.
        -:13004:   TARGET is the target suffix; SOURCE is the source suffix.
        -:13005:   CMDS are the commands.
        -:13006:   If TARGET is nil, it means the target pattern should be `(%.o)'.
        -:13007:   If SOURCE is nil, it means there should be no deps.  */
        -:13008:
        -:13009:static void
function convert_suffix_rule called 59367 returned 100% blocks executed 85%
    59367:13010:convert_suffix_rule (target, source, cmds)
        -:13011:     char *target, *source;
        -:13012:     struct commands *cmds;
        -:13013:{
        -:13014:  char *targname, *targpercent, *depname;
        -:13015:  char **names, **percents;
        -:13016:  struct dep *deps;
        -:13017:  unsigned int len;
        -:13018:
    59367:13019:  if (target == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 59367
        -:13020:    /* Special case: TARGET being nil means we are defining a
        -:13021:       `.X.a' suffix rule; the target pattern is always `(%.o)'.  */
        -:13022:    {
        -:13023:#ifdef VMS
        -:13024:      targname = savestring ("(%.obj)", 7);
        -:13025:#else
    #####:13026:      targname = savestring ("(%.o)", 5);
call    0 never executed
        -:13027:#endif
    #####:13028:      targpercent = targname + 1;
        -:13029:    }
        -:13030:  else
        -:13031:    {
        -:13032:      /* Construct the target name.  */
    59367:13033:      len = strlen (target);
    59367:13034:      targname = xmalloc (1 + len + 1);
call    0 returned 59367
    59367:13035:      targname[0] = '%';
    59367:13036:      bcopy (target, targname + 1, len + 1);
    59367:13037:      targpercent = targname;
        -:13038:    }
        -:13039:
    59367:13040:  names = (char **) xmalloc (2 * sizeof (char *));
call    0 returned 59367
    59367:13041:  percents = (char **) alloca (2 * sizeof (char *));
    59367:13042:  names[0] = targname;
    59367:13043:  percents[0] = targpercent;
    59367:13044:  names[1] = percents[1] = 0;
        -:13045:
    59367:13046:  if (source == 0)
branch  0 taken 24672 (fallthrough)
branch  1 taken 34695
    24672:13047:    deps = 0;
        -:13048:  else
        -:13049:    {
        -:13050:      /* Construct the dependency name.  */
    34695:13051:      len = strlen (source);
    34695:13052:      depname = xmalloc (1 + len + 1);
call    0 returned 34695
    34695:13053:      depname[0] = '%';
    34695:13054:      bcopy (source, depname + 1, len + 1);
    34695:13055:      deps = (struct dep *) xmalloc (sizeof (struct dep));
call    0 returned 34695
    34695:13056:      deps->next = 0;
    34695:13057:      deps->name = depname;
        -:13058:    }
        -:13059:
    59367:13060:  create_pattern_rule (names, percents, 0, deps, cmds, 0);
call    0 returned 59367
    59367:13061:}
        -:13062:
        -:13063:/* Convert old-style suffix rules to pattern rules.
        -:13064:   All rules for the suffixes on the .SUFFIXES list
        -:13065:   are converted and added to the chain of pattern rules.  */
        -:13066:
        -:13067:void
function convert_to_pattern called 771 returned 100% blocks executed 75%
      771:13068:convert_to_pattern ()
        -:13069:{
        -:13070:  register struct dep *d, *d2;
        -:13071:  register struct file *f;
        -:13072:  register char *rulename;
        -:13073:  register unsigned int slen, s2len;
        -:13074:
        -:13075:  /* Compute maximum length of all the suffixes.  */
        -:13076:
      771:13077:  maxsuffix = 0;
    25443:13078:  for (d = suffix_file->deps; d != 0; d = d->next)
branch  0 taken 24672
branch  1 taken 771 (fallthrough)
        -:13079:    {
   24672*:13080:      register unsigned int namelen = strlen (dep_name (d));
branch  0 taken 24672 (fallthrough)
branch  1 taken 0
    24672:13081:      if (namelen > maxsuffix)
branch  0 taken 2313 (fallthrough)
branch  1 taken 22359
     2313:13082:	maxsuffix = namelen;
        -:13083:    }
        -:13084:
      771:13085:  rulename = (char *) alloca ((maxsuffix * 2) + 1);
        -:13086:
    25443:13087:  for (d = suffix_file->deps; d != 0; d = d->next)
branch  0 taken 24672
branch  1 taken 771 (fallthrough)
        -:13088:    {
        -:13089:      /* Make a rule that is just the suffix, with no deps or commands.
        -:13090:	 This rule exists solely to disqualify match-anything rules.  */
   24672*:13091:      convert_suffix_rule (dep_name (d), (char *) 0, (struct commands *) 0);
branch  0 taken 24672 (fallthrough)
branch  1 taken 0
call    2 returned 24672
        -:13092:
    24672:13093:      f = d->file;
    24672:13094:      if (f->cmds != 0)
branch  0 taken 10023 (fallthrough)
branch  1 taken 14649
        -:13095:	/* Record a pattern for this suffix's null-suffix rule.  */
   10023*:13096:	convert_suffix_rule ("", dep_name (d), f->cmds);
branch  0 taken 10023 (fallthrough)
branch  1 taken 0
call    2 returned 10023
        -:13097:
        -:13098:      /* Record a pattern for each of this suffix's two-suffix rules.  */
   24672*:13099:      slen = strlen (dep_name (d));
branch  0 taken 24672 (fallthrough)
branch  1 taken 0
   24672*:13100:      bcopy (dep_name (d), rulename, slen);
branch  0 taken 24672 (fallthrough)
branch  1 taken 0
   814176:13101:      for (d2 = suffix_file->deps; d2 != 0; d2 = d2->next)
branch  0 taken 789504
branch  1 taken 24672 (fallthrough)
        -:13102:	{
  789504*:13103:	  s2len = strlen (dep_name (d2));
branch  0 taken 789504 (fallthrough)
branch  1 taken 0
        -:13104:
  789504*:13105:	  if (slen == s2len && streq (dep_name (d), dep_name (d2)))
branch  0 taken 237468 (fallthrough)
branch  1 taken 552036
branch  2 taken 237468 (fallthrough)
branch  3 taken 0
branch  4 taken 237468 (fallthrough)
branch  5 taken 0
branch  6 taken 212796 (fallthrough)
branch  7 taken 24672
branch  8 taken 212796 (fallthrough)
branch  9 taken 0
branch 10 taken 212796 (fallthrough)
branch 11 taken 0
branch 12 taken 212796 (fallthrough)
branch 13 taken 0
branch 14 taken 212796 (fallthrough)
branch 15 taken 0
branch 16 taken 212796 (fallthrough)
branch 17 taken 0
branch 18 taken 212796 (fallthrough)
branch 19 taken 0
branch 20 taken 212796 (fallthrough)
branch 21 taken 0
branch 22 taken 0 (fallthrough)
branch 23 taken 212796
    24672:13106:	    continue;
        -:13107:
  764832*:13108:	  bcopy (dep_name (d2), rulename + slen, s2len + 1);
branch  0 taken 764832 (fallthrough)
branch  1 taken 0
   764832:13109:	  f = lookup_file (rulename);
call    0 returned 764832
   764832:13110:	  if (f == 0 || f->cmds == 0)
branch  0 taken 24672 (fallthrough)
branch  1 taken 740160
branch  2 taken 0 (fallthrough)
branch  3 taken 24672
   740160:13111:	    continue;
        -:13112:
    24672:13113:	  if (s2len == 2 && rulename[slen] == '.' && rulename[slen + 1] == 'a')
branch  0 taken 14649 (fallthrough)
branch  1 taken 10023
branch  2 taken 14649 (fallthrough)
branch  3 taken 0
branch  4 taken 0 (fallthrough)
branch  5 taken 14649
        -:13114:	    /* A suffix rule `.X.a:' generates the pattern rule `(%.o): %.X'.
        -:13115:	       It also generates a normal `%.a: %.X' rule below.  */
    #####:13116:	    convert_suffix_rule ((char *) 0, /* Indicates `(%.o)'.  */
call    0 never executed
    #####:13117:				 dep_name (d),
branch  0 never executed
branch  1 never executed
        -:13118:				 f->cmds);
        -:13119:
        -:13120:	  /* The suffix rule `.X.Y:' is converted
        -:13121:	     to the pattern rule `%.Y: %.X'.  */
   24672*:13122:	  convert_suffix_rule (dep_name (d2), dep_name (d), f->cmds);
branch  0 taken 24672 (fallthrough)
branch  1 taken 0
branch  2 taken 24672 (fallthrough)
branch  3 taken 0
call    4 returned 24672
        -:13123:	}
        -:13124:    }
      771:13125:}
        -:13126:
        -:13127:
        -:13128:/* Install the pattern rule RULE (whose fields have been filled in)
        -:13129:   at the end of the list (so that any rules previously defined
        -:13130:   will take precedence).  If this rule duplicates a previous one
        -:13131:   (identical target and dependencies), the old one is replaced
        -:13132:   if OVERRIDE is nonzero, otherwise this new one is thrown out.
        -:13133:   When an old rule is replaced, the new one is put at the end of the
        -:13134:   list.  Return nonzero if RULE is used; zero if not.  */
        -:13135:
        -:13136:int
function new_pattern_rule called 66306 returned 100% blocks executed 74%
    66306:13137:new_pattern_rule (rule, override)
        -:13138:     register struct rule *rule;
        -:13139:     int override;
        -:13140:{
        -:13141:  register struct rule *r, *lastrule;
        -:13142:  register unsigned int i, j;
        -:13143:
    66306:13144:  rule->in_use = 0;
    66306:13145:  rule->terminal = 0;
        -:13146:
    66306:13147:  rule->next = 0;
        -:13148:
        -:13149:  /* Search for an identical rule.  */
    66306:13150:  lastrule = 0;
  2884311:13151:  for (r = pattern_rules; r != 0; lastrule = r, r = r->next)
branch  0 taken 2818005
branch  1 taken 66306 (fallthrough)
  5636010:13152:    for (i = 0; rule->targets[i] != 0; ++i)
branch  0 taken 2818005
branch  1 taken 2818005 (fallthrough)
        -:13153:      {
  3022320:13154:	for (j = 0; r->targets[j] != 0; ++j)
branch  0 taken 2818005
branch  1 taken 204315 (fallthrough)
  2818005:13155:	  if (!streq (rule->targets[i], r->targets[j]))
branch  0 taken 2818005 (fallthrough)
branch  1 taken 0
branch  2 taken 2752470 (fallthrough)
branch  3 taken 65535
branch  4 taken 2752470 (fallthrough)
branch  5 taken 0
branch  6 taken 204315 (fallthrough)
branch  7 taken 2548155
        -:13156:	    break;
  2818005:13157:	if (r->targets[j] == 0)
branch  0 taken 204315 (fallthrough)
branch  1 taken 2613690
        -:13158:	  /* All the targets matched.  */
        -:13159:	  {
        -:13160:	    register struct dep *d, *d2;
   204315:13161:	    for (d = rule->deps, d2 = r->deps;
   205857:13162:		 d != 0 && d2 != 0; d = d->next, d2 = d2->next)
branch  0 taken 205857 (fallthrough)
branch  1 taken 0
branch  2 taken 177330
branch  3 taken 28527 (fallthrough)
  177330*:13163:	      if (!streq (dep_name (d), dep_name (d2)))
branch  0 taken 0 (fallthrough)
branch  1 taken 177330
branch  2 taken 0 (fallthrough)
branch  3 taken 177330
branch  4 taken 177330 (fallthrough)
branch  5 taken 0
branch  6 taken 0 (fallthrough)
branch  7 taken 177330
branch  8 taken 0 (fallthrough)
branch  9 taken 177330
branch 10 taken 130299 (fallthrough)
branch 11 taken 47031
branch 12 taken 0 (fallthrough)
branch 13 taken 130299
branch 14 taken 130299 (fallthrough)
branch 15 taken 0
branch 16 taken 0 (fallthrough)
branch 17 taken 130299
branch 18 taken 0 (fallthrough)
branch 19 taken 130299
branch 20 taken 1542 (fallthrough)
branch 21 taken 128757
        -:13164:		break;
  204315*:13165:	    if (d == 0 && d2 == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 204315
branch  2 never executed
branch  3 never executed
        -:13166:	      {
        -:13167:		/* All the dependencies matched.  */
    #####:13168:		if (override)
branch  0 never executed
branch  1 never executed
        -:13169:		  {
        -:13170:		    /* Remove the old rule.  */
    #####:13171:		    freerule (r, lastrule);
call    0 never executed
        -:13172:		    /* Install the new one.  */
    #####:13173:		    if (pattern_rules == 0)
branch  0 never executed
branch  1 never executed
    #####:13174:		      pattern_rules = rule;
        -:13175:		    else
    #####:13176:		      last_pattern_rule->next = rule;
    #####:13177:		    last_pattern_rule = rule;
        -:13178:
        -:13179:		    /* We got one.  Stop looking.  */
    #####:13180:		    goto matched;
        -:13181:		  }
        -:13182:		else
        -:13183:		  {
        -:13184:		    /* The old rule stays intact.  Destroy the new one.  */
    #####:13185:		    freerule (rule, (struct rule *) 0);
call    0 never executed
    #####:13186:		    return 0;
        -:13187:		  }
        -:13188:	      }
        -:13189:	  }
        -:13190:      }
        -:13191:
    66306:13192: matched:;
        -:13193:
    66306:13194:  if (r == 0)
branch  0 taken 66306 (fallthrough)
branch  1 taken 0
        -:13195:    {
        -:13196:      /* There was no rule to replace.  */
    66306:13197:      if (pattern_rules == 0)
branch  0 taken 771 (fallthrough)
branch  1 taken 65535
      771:13198:	pattern_rules = rule;
        -:13199:      else
    65535:13200:	last_pattern_rule->next = rule;
    66306:13201:      last_pattern_rule = rule;
        -:13202:    }
        -:13203:
    66306:13204:  return 1;
        -:13205:}
        -:13206:
        -:13207:
        -:13208:/* Install an implicit pattern rule based on the three text strings
        -:13209:   in the structure P points to.  These strings come from one of
        -:13210:   the arrays of default implicit pattern rules.
        -:13211:   TERMINAL specifies what the `terminal' field of the rule should be.  */
        -:13212:
        -:13213:void
function install_pattern_rule called 6939 returned 100% blocks executed 94%
     6939:13214:install_pattern_rule (p, terminal)
        -:13215:     struct pspec *p;
        -:13216:     int terminal;
        -:13217:{
        -:13218:  register struct rule *r;
        -:13219:  char *ptr;
        -:13220:
     6939:13221:  r = (struct rule *) xmalloc (sizeof (struct rule));
call    0 returned 6939
        -:13222:
     6939:13223:  r->targets = (char **) xmalloc (2 * sizeof (char *));
call    0 returned 6939
     6939:13224:  r->suffixes = (char **) xmalloc (2 * sizeof (char *));
call    0 returned 6939
     6939:13225:  r->lens = (unsigned int *) xmalloc (2 * sizeof (unsigned int));
call    0 returned 6939
        -:13226:
     6939:13227:  r->targets[1] = 0;
     6939:13228:  r->suffixes[1] = 0;
     6939:13229:  r->lens[1] = 0;
        -:13230:
     6939:13231:  r->lens[0] = strlen (p->target);
        -:13232:  /* These will all be string literals, but we malloc space for
        -:13233:     them anyway because somebody might want to free them later on.  */
     6939:13234:  r->targets[0] = savestring (p->target, r->lens[0]);
call    0 returned 6939
     6939:13235:  r->suffixes[0] = find_percent (r->targets[0]);
call    0 returned 6939
     6939:13236:  if (r->suffixes[0] == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 6939
        -:13237:    /* Programmer-out-to-lunch error.  */
    #####:13238:    abort ();
call    0 never executed
        -:13239:  else
     6939:13240:    ++r->suffixes[0];
        -:13241:
     6939:13242:  ptr = p->dep;
     6939:13243:  r->deps = (struct dep *) multi_glob (parse_file_seq (&ptr, '\0',
call    0 returned 6939
call    1 returned 6939
        -:13244:                                                       sizeof (struct dep), 1),
        -:13245:				       sizeof (struct dep));
        -:13246:
     6939:13247:  if (new_pattern_rule (r, 0))
call    0 returned 6939
branch  1 taken 6939 (fallthrough)
branch  2 taken 0
        -:13248:    {
     6939:13249:      r->terminal = terminal;
     6939:13250:      r->cmds = (struct commands *) xmalloc (sizeof (struct commands));
call    0 returned 6939
     6939:13251:      r->cmds->fileinfo.filenm = 0;
     6939:13252:      r->cmds->fileinfo.lineno = 0;
        -:13253:      /* These will all be string literals, but we malloc space for them
        -:13254:	 anyway because somebody might want to free them later.  */
     6939:13255:      r->cmds->commands = xstrdup (p->commands);
call    0 returned 6939
     6939:13256:      r->cmds->command_lines = 0;
        -:13257:    }
     6939:13258:}
        -:13259:
        -:13260:
        -:13261:/* Free all the storage used in RULE and take it out of the
        -:13262:   pattern_rules chain.  LASTRULE is the rule whose next pointer
        -:13263:   points to RULE.  */
        -:13264:
        -:13265:static void
function freerule called 0 returned 0% blocks executed 0%
    #####:13266:freerule (rule, lastrule)
        -:13267:     register struct rule *rule, *lastrule;
        -:13268:{
    #####:13269:  struct rule *next = rule->next;
        -:13270:  register unsigned int i;
        -:13271:  register struct dep *dep;
        -:13272:
    #####:13273:  for (i = 0; rule->targets[i] != 0; ++i)
branch  0 never executed
branch  1 never executed
    #####:13274:    free (rule->targets[i]);
        -:13275:
    #####:13276:  dep = rule->deps;
    #####:13277:  while (dep)
branch  0 never executed
branch  1 never executed
        -:13278:    {
        -:13279:      struct dep *t;
        -:13280:
    #####:13281:      t = dep->next;
        -:13282:      /* We might leak dep->name here, but I'm not sure how to fix this: I
        -:13283:         think that pointer might be shared (e.g., in the file hash?)  */
    #####:13284:      free ((char *) dep);
    #####:13285:      dep = t;
        -:13286:    }
        -:13287:
    #####:13288:  free ((char *) rule->targets);
    #####:13289:  free ((char *) rule->suffixes);
    #####:13290:  free ((char *) rule->lens);
        -:13291:
        -:13292:  /* We can't free the storage for the commands because there
        -:13293:     are ways that they could be in more than one place:
        -:13294:       * If the commands came from a suffix rule, they could also be in
        -:13295:       the `struct file's for other suffix rules or plain targets given
        -:13296:       on the same makefile line.
        -:13297:       * If two suffixes that together make a two-suffix rule were each
        -:13298:       given twice in the .SUFFIXES list, and in the proper order, two
        -:13299:       identical pattern rules would be created and the second one would
        -:13300:       be discarded here, but both would contain the same `struct commands'
        -:13301:       pointer from the `struct file' for the suffix rule.  */
        -:13302:
    #####:13303:  free ((char *) rule);
        -:13304:
    #####:13305:  if (pattern_rules == rule)
branch  0 never executed
branch  1 never executed
    #####:13306:    if (lastrule != 0)
branch  0 never executed
branch  1 never executed
    #####:13307:      abort ();
call    0 never executed
        -:13308:    else
    #####:13309:      pattern_rules = next;
    #####:13310:  else if (lastrule != 0)
branch  0 never executed
branch  1 never executed
    #####:13311:    lastrule->next = next;
    #####:13312:  if (last_pattern_rule == rule)
branch  0 never executed
branch  1 never executed
    #####:13313:    last_pattern_rule = lastrule;
    #####:13314:}
        -:13315:
        -:13316:/* Create a new pattern rule with the targets in the nil-terminated
        -:13317:   array TARGETS.  If TARGET_PERCENTS is not nil, it is an array of
        -:13318:   pointers into the elements of TARGETS, where the `%'s are.
        -:13319:   The new rule has dependencies DEPS and commands from COMMANDS.
        -:13320:   It is a terminal rule if TERMINAL is nonzero.  This rule overrides
        -:13321:   identical rules with different commands if OVERRIDE is nonzero.
        -:13322:
        -:13323:   The storage for TARGETS and its elements is used and must not be freed
        -:13324:   until the rule is destroyed.  The storage for TARGET_PERCENTS is not used;
        -:13325:   it may be freed.  */
        -:13326:
        -:13327:void
function create_pattern_rule called 59367 returned 100% blocks executed 62%
    59367:13328:create_pattern_rule (targets, target_percents,
        -:13329:		     terminal, deps, commands, override)
        -:13330:     char **targets, **target_percents;
        -:13331:     int terminal;
        -:13332:     struct dep *deps;
        -:13333:     struct commands *commands;
        -:13334:     int override;
        -:13335:{
    59367:13336:  register struct rule *r = (struct rule *) xmalloc (sizeof (struct rule));
call    0 returned 59367
        -:13337:  register unsigned int max_targets, i;
        -:13338:
    59367:13339:  r->cmds = commands;
    59367:13340:  r->deps = deps;
    59367:13341:  r->targets = targets;
        -:13342:
    59367:13343:  max_targets = 2;
    59367:13344:  r->lens = (unsigned int *) xmalloc (2 * sizeof (unsigned int));
call    0 returned 59367
    59367:13345:  r->suffixes = (char **) xmalloc (2 * sizeof (char *));
call    0 returned 59367
   118734:13346:  for (i = 0; targets[i] != 0; ++i)
branch  0 taken 59367
branch  1 taken 59367 (fallthrough)
        -:13347:    {
    59367:13348:      if (i == max_targets - 1)
branch  0 taken 0 (fallthrough)
branch  1 taken 59367
        -:13349:	{
    #####:13350:	  max_targets += 5;
    #####:13351:	  r->lens = (unsigned int *)
    #####:13352:	    xrealloc ((char *) r->lens, max_targets * sizeof (unsigned int));
call    0 never executed
    #####:13353:	  r->suffixes = (char **)
    #####:13354:	    xrealloc ((char *) r->suffixes, max_targets * sizeof (char *));
call    0 never executed
        -:13355:	}
    59367:13356:      r->lens[i] = strlen (targets[i]);
    #####:13357:      r->suffixes[i] = (target_percents == 0 ? find_percent (targets[i])
call    0 never executed
   59367*:13358:			: target_percents[i]) + 1;
branch  0 taken 0 (fallthrough)
branch  1 taken 59367
    59367:13359:      if (r->suffixes[i] == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 59367
    #####:13360:	abort ();
call    0 never executed
        -:13361:    }
        -:13362:
    59367:13363:  if (i < max_targets - 1)
branch  0 taken 0 (fallthrough)
branch  1 taken 59367
        -:13364:    {
    #####:13365:      r->lens = (unsigned int *) xrealloc ((char *) r->lens,
    #####:13366:					   (i + 1) * sizeof (unsigned int));
call    0 never executed
    #####:13367:      r->suffixes = (char **) xrealloc ((char *) r->suffixes,
    #####:13368:					(i + 1) * sizeof (char *));
call    0 never executed
        -:13369:    }
        -:13370:
    59367:13371:  if (new_pattern_rule (r, override))
call    0 returned 59367
branch  1 taken 59367 (fallthrough)
branch  2 taken 0
    59367:13372:    r->terminal = terminal;
    59367:13373:}
        -:13374:
        -:13375:/* Create a new pattern-specific variable struct.  */
        -:13376:
        -:13377:struct pattern_var *
function create_pattern_var called 0 returned 0% blocks executed 0%
    #####:13378:create_pattern_var (target, suffix)
        -:13379:     char *target, *suffix;
        -:13380:{
    #####:13381:  register struct pattern_var *p = 0;
    #####:13382:  unsigned int len = strlen(target);
        -:13383:
        -:13384:  /* Look to see if this pattern already exists in the list.  */
    #####:13385:  for (p = pattern_vars; p != NULL; p = p->next)
branch  0 never executed
branch  1 never executed
    #####:13386:    if (p->len == len && !strcmp(p->target, target))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:13387:      break;
        -:13388:
    #####:13389:  if (p == 0)
branch  0 never executed
branch  1 never executed
        -:13390:    {
    #####:13391:      p = (struct pattern_var *) xmalloc (sizeof (struct pattern_var));
call    0 never executed
    #####:13392:      if (last_pattern_var != 0)
branch  0 never executed
branch  1 never executed
    #####:13393:        last_pattern_var->next = p;
        -:13394:      else
    #####:13395:        pattern_vars = p;
    #####:13396:      last_pattern_var = p;
    #####:13397:      p->next = 0;
    #####:13398:      p->target = target;
    #####:13399:      p->len = len;
    #####:13400:      p->suffix = suffix + 1;
    #####:13401:      p->vars = create_new_variable_set();
call    0 never executed
        -:13402:    }
        -:13403:
    #####:13404:  return p;
        -:13405:}
        -:13406:
        -:13407:/* Look up a target in the pattern-specific variable list.  */
        -:13408:
        -:13409:struct pattern_var *
function lookup_pattern_var called 0 returned 0% blocks executed 0%
    #####:13410:lookup_pattern_var (target)
        -:13411:     char *target;
        -:13412:{
        -:13413:  struct pattern_var *p;
    #####:13414:  unsigned int targlen = strlen(target);
        -:13415:
    #####:13416:  for (p = pattern_vars; p != 0; p = p->next)
branch  0 never executed
branch  1 never executed
        -:13417:    {
        -:13418:      char *stem;
        -:13419:      unsigned int stemlen;
        -:13420:
    #####:13421:      if (p->len > targlen)
branch  0 never executed
branch  1 never executed
        -:13422:        /* It can't possibly match.  */
    #####:13423:        continue;
        -:13424:
        -:13425:      /* From the lengths of the filename and the pattern parts,
        -:13426:         find the stem: the part of the filename that matches the %.  */
    #####:13427:      stem = target + (p->suffix - p->target - 1);
    #####:13428:      stemlen = targlen - p->len + 1;
        -:13429:
        -:13430:      /* Compare the text in the pattern before the stem, if any.  */
    #####:13431:      if (stem > target && !strneq (p->target, target, stem - target))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:13432:        continue;
        -:13433:
        -:13434:      /* Compare the text in the pattern after the stem, if any.
        -:13435:         We could test simply use streq, but this way we compare the
        -:13436:         first two characters immediately.  This saves time in the very
        -:13437:         common case where the first character matches because it is a
        -:13438:         period.  */
    #####:13439:      if (*p->suffix == stem[stemlen]
branch  0 never executed
branch  1 never executed
    #####:13440:          && (*p->suffix == '\0'|| streq (&p->suffix[1], &stem[stemlen+1])))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
        -:13441:        break;
        -:13442:    }
        -:13443:
    #####:13444:  return p;
        -:13445:}
        -:13446:
        -:13447:/* Print the data base of rules.  */
        -:13448:
        -:13449:static void			/* Useful to call from gdb.  */
function print_rule called 33024 returned 100% blocks executed 90%
    33024:13450:print_rule (r)
        -:13451:     struct rule *r;
        -:13452:{
        -:13453:  register unsigned int i;
        -:13454:  register struct dep *d;
        -:13455:
    66048:13456:  for (i = 0; r->targets[i] != 0; ++i)
branch  0 taken 33024
branch  1 taken 33024 (fallthrough)
        -:13457:    {
    33024:13458:      fputs (r->targets[i], stdout);
call    0 returned 33024
    33024:13459:      if (r->targets[i + 1] != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 33024
    #####:13460:	putchar (' ');
call    0 never executed
        -:13461:      else
    33024:13462:	putchar (':');
call    0 returned 33024
        -:13463:    }
    33024:13464:  if (r->terminal)
branch  0 taken 1920 (fallthrough)
branch  1 taken 31104
     1920:13465:    putchar (':');
call    0 returned 1920
        -:13466:
    54528:13467:  for (d = r->deps; d != 0; d = d->next)
branch  0 taken 21504
branch  1 taken 33024 (fallthrough)
   21504*:13468:    printf (" %s", dep_name (d));
branch  0 taken 0 (fallthrough)
branch  1 taken 21504
call    2 returned 21504
    33024:13469:  putchar ('\n');
call    0 returned 33024
        -:13470:
    33024:13471:  if (r->cmds != 0)
branch  0 taken 20736 (fallthrough)
branch  1 taken 12288
    20736:13472:    print_commands (r->cmds);
call    0 returned 20736
    33024:13473:}
        -:13474:
        -:13475:void
function print_rule_data_base called 384 returned 100% blocks executed 73%
      384:13476:print_rule_data_base ()
        -:13477:{
        -:13478:  register unsigned int rules, terminal;
        -:13479:  register struct rule *r;
        -:13480:
      384:13481:  puts ("\n# Implicit Rules");
call    0 returned 384
        -:13482:
      384:13483:  rules = terminal = 0;
    33408:13484:  for (r = pattern_rules; r != 0; r = r->next)
branch  0 taken 33024
branch  1 taken 384 (fallthrough)
        -:13485:    {
    33024:13486:      ++rules;
        -:13487:
    33024:13488:      putchar ('\n');
call    0 returned 33024
    33024:13489:      print_rule (r);
call    0 returned 33024
        -:13490:
    33024:13491:      if (r->terminal)
branch  0 taken 1920 (fallthrough)
branch  1 taken 31104
     1920:13492:	++terminal;
        -:13493:    }
        -:13494:
      384:13495:  if (rules == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 384
    #####:13496:    puts (_("\n# No implicit rules."));
call    0 never executed
        -:13497:  else
        -:13498:    {
      384:13499:      printf (_("\n# %u implicit rules, %u"), rules, terminal);
call    0 returned 384
        -:13500:#ifndef	NO_FLOAT
      384:13501:      printf (" (%.1f%%)", (double) terminal / (double) rules * 100.0);
call    0 returned 384
        -:13502:#else
        -:13503:      {
        -:13504:	int f = (terminal * 1000 + 5) / rules;
        -:13505:	printf (" (%d.%d%%)", f/10, f%10);
        -:13506:      }
        -:13507:#endif
      384:13508:      puts (_(" terminal."));
call    0 returned 384
        -:13509:    }
        -:13510:
      384:13511:  if (num_pattern_rules != rules)
branch  0 taken 0 (fallthrough)
branch  1 taken 384
        -:13512:    {
        -:13513:      /* This can happen if a fatal error was detected while reading the
        -:13514:         makefiles and thus count_implicit_rule_limits wasn't called yet.  */
    #####:13515:      if (num_pattern_rules != 0)
branch  0 never executed
branch  1 never executed
    #####:13516:        fatal (NILF, _("BUG: num_pattern_rules wrong!  %u != %u"),
call    0 never executed
        -:13517:               num_pattern_rules, rules);
        -:13518:    }
        -:13519:
      384:13520:  puts (_("\n# Pattern-specific variable values"));
call    0 returned 384
        -:13521:
        -:13522:  {
        -:13523:    struct pattern_var *p;
        -:13524:
      384:13525:    rules = 0;
     384*:13526:    for (p = pattern_vars; p != 0; p = p->next)
branch  0 taken 0
branch  1 taken 384 (fallthrough)
        -:13527:      {
    #####:13528:        ++rules;
        -:13529:
    #####:13530:        printf ("\n%s :\n", p->target);
call    0 never executed
    #####:13531:        print_variable_set (p->vars->set, "# ");
call    0 never executed
        -:13532:      }
        -:13533:
      384:13534:    if (rules == 0)
branch  0 taken 384 (fallthrough)
branch  1 taken 0
      384:13535:      puts (_("\n# No pattern-specific variable values."));
call    0 returned 384
        -:13536:    else
        -:13537:      {
    #####:13538:        printf (_("\n# %u pattern-specific variable values"), rules);
call    0 never executed
        -:13539:      }
        -:13540:  }
      384:13541:}
        -:13542:
        -:13543:
        -:13544:
        -:13545:/*************************************************************
        -:13546:  ============================================================
        -:13547:  ************************************************************
        -:13548:  ============================================================
        -:13549:  ************************************************************
        -:13550:                         implicit.c
        -:13551:  ************************************************************
        -:13552:  ============================================================
        -:13553:  ************************************************************
        -:13554:  ============================================================
        -:13555:  *************************************************************/
        -:13556:
        -:13557:/* Implicit rule searching for GNU Make.
        -:13558:Copyright (C) 1988,89,90,91,92,93,94,97 Free Software Foundation, Inc.
        -:13559:This file is part of GNU Make.
        -:13560:
        -:13561:GNU Make is free software; you can redistribute it and/or modify
        -:13562:it under the terms of the GNU General Public License as published by
        -:13563:the Free Software Foundation; either version 2, or (at your option)
        -:13564:any later version.
        -:13565:
        -:13566:GNU Make is distributed in the hope that it will be useful,
        -:13567:but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:13568:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:13569:GNU General Public License for more details.
        -:13570:
        -:13571:You should have received a copy of the GNU General Public License
        -:13572:along with GNU Make; see the file COPYING.  If not, write to
        -:13573:the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
        -:13574:Boston, MA 02111-1307, USA.  */
        -:13575:
        -:13576:/* #include "make.h"  <- modification by J.Ruthruff, 7/27 */
        -:13577:/* #include "rule.h"  <- modification by J.Ruthruff, 7/27 */
        -:13578:/* #include "dep.h"  <- modification by J.Ruthruff, 7/27 */
        -:13579:/* #include "filedef.h"  <- modification by J.Ruthruff, 7/27 */
        -:13580:#undef stderr
        -:13581:#define stderr stdout
        -:13582:
        -:13583:static int pattern_search PARAMS ((struct file *file, int archive, unsigned int depth,
        -:13584:		unsigned int recursions));
        -:13585:
        -:13586:/* For a FILE which has no commands specified, try to figure out some
        -:13587:   from the implicit pattern rules.
        -:13588:   Returns 1 if a suitable implicit rule was found,
        -:13589:   after modifying FILE to contain the appropriate commands and deps,
        -:13590:   or returns 0 if no implicit rule was found.  */
        -:13591:
        -:13592:int
function try_implicit_rule called 771 returned 100% blocks executed 56%
      771:13593:try_implicit_rule (file, depth)
        -:13594:     struct file *file;
        -:13595:     unsigned int depth;
        -:13596:{
      771:13597:  DEBUGPR (_("Looking for an implicit rule for `%s'.\n"));
branch  0 taken 384 (fallthrough)
branch  1 taken 387
call    2 returned 384
call    3 returned 384
call    4 returned 384
        -:13598:
        -:13599:  /* The order of these searches was previously reversed.  My logic now is
        -:13600:     that since the non-archive search uses more information in the target
        -:13601:     (the archive search omits the archive name), it is more specific and
        -:13602:     should come first.  */
        -:13603:
      771:13604:  if (pattern_search (file, 0, depth, 0))
call    0 returned 771
branch  1 taken 0 (fallthrough)
branch  2 taken 771
    #####:13605:    return 1;
        -:13606:
        -:13607:#ifndef	NO_ARCHIVES
        -:13608:  /* If this is an archive member reference, use just the
        -:13609:     archive member name to search for implicit rules.  */
      771:13610:  if (ar_name (file->name))
call    0 returned 771
branch  1 taken 0 (fallthrough)
branch  2 taken 771
        -:13611:    {
    #####:13612:      DEBUGPR (_("Looking for archive-member implicit rule for `%s'.\n"));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:13613:      if (pattern_search (file, 1, depth, 0))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:13614:	return 1;
        -:13615:    }
        -:13616:#endif
        -:13617:
      771:13618:  return 0;
        -:13619:}
        -:13620:
        -:13621:#define DEBUGP2(msg, a1, a2)						      \
        -:13622:  do {									      \
        -:13623:    if (debug_flag)							      \
        -:13624:      { print_spaces (depth); printf (msg, a1, a2); fflush (stdout); }	      \
        -:13625:  } while (0)
        -:13626:
        -:13627:/* Search the pattern rules for a rule with an existing dependency to make
        -:13628:   FILE.  If a rule is found, the appropriate commands and deps are put in FILE
        -:13629:   and 1 is returned.  If not, 0 is returned.
        -:13630:
        -:13631:   If ARCHIVE is nonzero, FILE->name is of the form "LIB(MEMBER)".  A rule for
        -:13632:   "(MEMBER)" will be searched for, and "(MEMBER)" will not be chopped up into
        -:13633:   directory and filename parts.
        -:13634:
        -:13635:   If an intermediate file is found by pattern search, the intermediate file
        -:13636:   is set up as a target by the recursive call and is also made a dependency
        -:13637:   of FILE.
        -:13638:
        -:13639:   DEPTH is used for debugging messages.  */
        -:13640:
        -:13641:static int
function pattern_search called 13878 returned 100% blocks executed 60%
    13878:13642:pattern_search (file, archive, depth, recursions)
        -:13643:     struct file *file;
        -:13644:     int archive;
        -:13645:     unsigned int depth;
        -:13646:     unsigned int recursions;
        -:13647:{
        -:13648:  /* Filename we are searching for a rule for.  */
   13878*:13649:  char *filename = archive ? index (file->name, '(') : file->name;
branch  0 taken 0 (fallthrough)
branch  1 taken 13878
        -:13650:
        -:13651:  /* Length of FILENAME.  */
    13878:13652:  unsigned int namelen = strlen (filename);
        -:13653:
        -:13654:  /* The last slash in FILENAME (or nil if there is none).  */
        -:13655:  char *lastslash;
        -:13656:
        -:13657:  /* This is a file-object used as an argument in
        -:13658:     recursive calls.  It never contains any data
        -:13659:     except during a recursive call.  */
    13878:13660:  struct file *intermediate_file = 0;
        -:13661:
        -:13662:  /* List of dependencies found recursively.  */
        -:13663:  struct file **intermediate_files
    13878:13664:    = (struct file **) alloca (max_pattern_deps * sizeof (struct file *));
        -:13665:
        -:13666:  /* List of the patterns used to find intermediate files.  */
        -:13667:  char **intermediate_patterns
    13878:13668:    = (char **) alloca (max_pattern_deps * sizeof (char *));
        -:13669:
        -:13670:  /* This buffer records all the dependencies actually found for a rule.  */
    13878:13671:  char **found_files = (char **) alloca (max_pattern_deps * sizeof (char *));
        -:13672:  /* Number of dep names now in FOUND_FILES.  */
    13878:13673:  unsigned int deps_found = 0;
        -:13674:
        -:13675:  /* Names of possible dependencies are constructed in this buffer.  */
    13878:13676:  register char *depname = (char *) alloca (namelen + max_pattern_dep_length);
        -:13677:
        -:13678:  /* The start and length of the stem of FILENAME for the current rule.  */
    13878:13679:  register char *stem = 0;
    13878:13680:  register unsigned int stemlen = 0;
        -:13681:
        -:13682:  /* Buffer in which we store all the rules that are possibly applicable.  */
        -:13683:  struct rule **tryrules
    13878:13684:    = (struct rule **) alloca (num_pattern_rules * max_pattern_targets
        -:13685:			       * sizeof (struct rule *));
        -:13686:
        -:13687:  /* Number of valid elements in TRYRULES.  */
        -:13688:  unsigned int nrules;
        -:13689:
        -:13690:  /* The numbers of the rule targets of each rule
        -:13691:     in TRYRULES that matched the target file.  */
        -:13692:  unsigned int *matches
    13878:13693:    = (unsigned int *) alloca (num_pattern_rules * sizeof (unsigned int));
        -:13694:
        -:13695:  /* Each element is nonzero if LASTSLASH was used in
        -:13696:     matching the corresponding element of TRYRULES.  */
        -:13697:  char *checked_lastslash
    13878:13698:    = (char *) alloca (num_pattern_rules * sizeof (char));
        -:13699:
        -:13700:  /* The index in TRYRULES of the rule we found.  */
        -:13701:  unsigned int foundrule;
        -:13702:
        -:13703:  /* Nonzero if should consider intermediate files as dependencies.  */
        -:13704:  int intermed_ok;
        -:13705:
        -:13706:  /* Nonzero if we have matched a pattern-rule target
        -:13707:     that is not just `%'.  */
    13878:13708:  int specific_rule_matched = 0;
        -:13709:
    13878:13710:  register unsigned int i = 0;  /* uninit checks OK */
        -:13711:  register struct rule *rule;
        -:13712:  register struct dep *dep;
        -:13713:
        -:13714:  char *p, *vp;
        -:13715:
        -:13716:#ifndef	NO_ARCHIVES
    13878:13717:  if (archive || ar_name (filename))
branch  0 taken 13878 (fallthrough)
branch  1 taken 0
call    2 returned 13878
branch  3 taken 0 (fallthrough)
branch  4 taken 13878
    #####:13718:    lastslash = 0;
        -:13719:  else
        -:13720:#endif
        -:13721:    {
        -:13722:      /* Set LASTSLASH to point at the last slash in FILENAME
        -:13723:	 but not counting any slash at the end.  (foo/bar/ counts as
        -:13724:	 bar/ in directory foo/, not empty in directory foo/bar/.)  */
        -:13725:#ifdef VMS
        -:13726:      lastslash = rindex (filename, ']');
        -:13727:#else
    13878:13728:      lastslash = rindex (filename, '/');
        -:13729:#if defined(__MSDOS__) || defined(WINDOWS32)
        -:13730:      /* Handle backslashes (possibly mixed with forward slashes)
        -:13731:	 and the case of "d:file".  */
        -:13732:      {
        -:13733:	char *bslash = rindex (filename, '\\');
        -:13734:	if (lastslash == 0 || bslash > lastslash)
        -:13735:	  lastslash = bslash;
        -:13736:	if (lastslash == 0 && filename[0] && filename[1] == ':')
        -:13737:	  lastslash = filename + 1;
        -:13738:      }
        -:13739:#endif
        -:13740:#endif
    13878:13741:      if (lastslash != 0 && lastslash[1] == '\0')
branch  0 taken 13878 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 13878
    #####:13742:	lastslash = 0;
        -:13743:    }
        -:13744:
        -:13745:  /* First see which pattern rules match this target
        -:13746:     and may be considered.  Put them in TRYRULES.  */
        -:13747:
    13878:13748:  nrules = 0;
  1207386:13749:  for (rule = pattern_rules; rule != 0; rule = rule->next)
branch  0 taken 1193508
branch  1 taken 13878 (fallthrough)
        -:13750:    {
        -:13751:      /* If the pattern rule has deps but no commands, ignore it.
        -:13752:	 Users cancel built-in rules by redefining them without commands.  */
 1193508*:13753:      if (rule->deps != 0 && rule->cmds == 0)
branch  0 taken 749412 (fallthrough)
branch  1 taken 444096
branch  2 taken 0 (fallthrough)
branch  3 taken 749412
    #####:13754:	continue;
        -:13755:
        -:13756:      /* If this rule is in use by a parent pattern_search,
        -:13757:	 don't use it here.  */
  1193508:13758:      if (rule->in_use)
branch  0 taken 30069 (fallthrough)
branch  1 taken 1163439
        -:13759:	{
    30069:13760:	  DEBUGP2 (_("Avoiding implicit rule recursion.%s%s\n"), "", "");
branch  0 taken 14976 (fallthrough)
branch  1 taken 15093
call    2 returned 14976
call    3 returned 14976
call    4 returned 14976
    30069:13761:	  continue;
        -:13762:	}
        -:13763:
  2326878:13764:      for (i = 0; rule->targets[i] != 0; ++i)
branch  0 taken 1163439
branch  1 taken 1163439 (fallthrough)
        -:13765:	{
  1163439:13766:	  char *target = rule->targets[i];
  1163439:13767:	  char *suffix = rule->suffixes[i];
        -:13768:	  int check_lastslash;
        -:13769:
        -:13770:	  /* Rules that can match any filename and are not terminal
        -:13771:	     are ignored if we're recursing, so that they cannot be
        -:13772:	     intermediate files.  */
  1163439:13773:	  if (recursions > 0 && target[1] == '\0' && !rule->terminal)
branch  0 taken 1097133 (fallthrough)
branch  1 taken 66306
branch  2 taken 222819 (fallthrough)
branch  3 taken 874314
branch  4 taken 157284 (fallthrough)
branch  5 taken 65535
   157284:13774:	    continue;
        -:13775:
 1006155*:13776:	  if (rule->lens[i] > namelen)
branch  0 taken 0 (fallthrough)
branch  1 taken 1006155
        -:13777:	    /* It can't possibly match.  */
    #####:13778:	    continue;
        -:13779:
        -:13780:	  /* From the lengths of the filename and the pattern parts,
        -:13781:	     find the stem: the part of the filename that matches the %.  */
  1006155:13782:	  stem = filename + (suffix - target - 1);
  1006155:13783:	  stemlen = namelen - rule->lens[i] + 1;
        -:13784:
        -:13785:	  /* Set CHECK_LASTSLASH if FILENAME contains a directory
        -:13786:	     prefix and the target pattern does not contain a slash.  */
        -:13787:
        -:13788:#ifdef VMS
        -:13789:	  check_lastslash = lastslash != 0 && index (target, ']') == 0;
        -:13790:#else
 1006155*:13791:	  check_lastslash = lastslash != 0 && index (target, '/') == 0;
branch  0 taken 1006155 (fallthrough)
branch  1 taken 0
branch  2 taken 1006155 (fallthrough)
branch  3 taken 0
        -:13792:#endif
  1006155:13793:	  if (check_lastslash)
branch  0 taken 1006155 (fallthrough)
branch  1 taken 0
        -:13794:	    {
        -:13795:	      /* In that case, don't include the
        -:13796:		 directory prefix in STEM here.  */
  1006155:13797:	      unsigned int difference = lastslash - filename + 1;
 1006155*:13798:	      if (difference > stemlen)
branch  0 taken 0 (fallthrough)
branch  1 taken 1006155
    #####:13799:		continue;
  1006155:13800:	      stemlen -= difference;
  1006155:13801:	      stem += difference;
        -:13802:	    }
        -:13803:
        -:13804:	  /* Check that the rule pattern matches the text before the stem.  */
  1006155:13805:	  if (check_lastslash)
branch  0 taken 1006155 (fallthrough)
branch  1 taken 0
        -:13806:	    {
  1006155:13807:	      if (stem > (lastslash + 1)
branch  0 taken 13878 (fallthrough)
branch  1 taken 992277
    13878:13808:		  && !strneq (target, lastslash + 1, stem - lastslash - 1))
branch  0 taken 13878 (fallthrough)
branch  1 taken 0
    13878:13809:		continue;
        -:13810:	    }
    #####:13811:	  else if (stem > filename
branch  0 never executed
branch  1 never executed
    #####:13812:		   && !strneq (target, filename, stem - filename))
branch  0 never executed
branch  1 never executed
    #####:13813:	    continue;
        -:13814:
        -:13815:	  /* Check that the rule pattern matches the text after the stem.
        -:13816:	     We could test simply use streq, but this way we compare the
        -:13817:	     first two characters immediately.  This saves time in the very
        -:13818:	     common case where the first character matches because it is a
        -:13819:	     period.  */
   992277:13820:	  if (*suffix != stem[stemlen]
branch  0 taken 434844 (fallthrough)
branch  1 taken 557433
   434844:13821:	      || (*suffix != '\0' && !streq (&suffix[1], &stem[stemlen + 1])))
branch  0 taken 355431 (fallthrough)
branch  1 taken 79413
branch  2 taken 355431 (fallthrough)
branch  3 taken 0
branch  4 taken 29298 (fallthrough)
branch  5 taken 326133
branch  6 taken 29298 (fallthrough)
branch  7 taken 0
branch  8 taken 771 (fallthrough)
branch  9 taken 28527
   884337:13822:	    continue;
        -:13823:
        -:13824:	  /* Record if we match a rule that not all filenames will match.  */
   107940:13825:	  if (target[1] != '\0')
branch  0 taken 28527 (fallthrough)
branch  1 taken 79413
    28527:13826:	    specific_rule_matched = 1;
        -:13827:
        -:13828:	  /* A rule with no dependencies and no commands exists solely to set
        -:13829:	     specific_rule_matched when it matches.  Don't try to use it.  */
   107940:13830:	  if (rule->deps == 0 && rule->cmds == 0)
branch  0 taken 13107 (fallthrough)
branch  1 taken 94833
branch  2 taken 13107 (fallthrough)
branch  3 taken 0
    13107:13831:	    continue;
        -:13832:
        -:13833:	  /* Record this rule in TRYRULES and the index of the matching
        -:13834:	     target in MATCHES.  If several targets of the same rule match,
        -:13835:	     that rule will be in TRYRULES more than once.  */
    94833:13836:	  tryrules[nrules] = rule;
    94833:13837:	  matches[nrules] = i;
    94833:13838:	  checked_lastslash[nrules] = check_lastslash;
    94833:13839:	  ++nrules;
        -:13840:	}
        -:13841:    }
        -:13842:
        -:13843:  /* If we have found a matching rule that won't match all filenames,
        -:13844:     retroactively reject any non-"terminal" rules that do always match.  */
    13878:13845:  if (specific_rule_matched)
branch  0 taken 13107 (fallthrough)
branch  1 taken 771
    94062:13846:    for (i = 0; i < nrules; ++i)
branch  0 taken 80955
branch  1 taken 13107 (fallthrough)
    80955:13847:      if (!tryrules[i]->terminal)
branch  0 taken 15420 (fallthrough)
branch  1 taken 65535
        -:13848:	{
        -:13849:	  register unsigned int j;
    30840:13850:	  for (j = 0; tryrules[i]->targets[j] != 0; ++j)
branch  0 taken 15420
branch  1 taken 15420 (fallthrough)
    15420:13851:	    if (tryrules[i]->targets[j][1] == '\0')
branch  0 taken 0 (fallthrough)
branch  1 taken 15420
    #####:13852:	      break;
    15420:13853:	  if (tryrules[i]->targets[j] != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 15420
    #####:13854:	    tryrules[i] = 0;
        -:13855:	}
        -:13856:
        -:13857:  /* Try each rule once without intermediate files, then once with them.  */
    41634:13858:  for (intermed_ok = 0; intermed_ok == !!intermed_ok; ++intermed_ok)
branch  0 taken 27756
branch  1 taken 13878 (fallthrough)
        -:13859:    {
        -:13860:      /* Try each pattern rule till we find one that applies.
        -:13861:	 If it does, copy the names of its dependencies (as substituted)
        -:13862:	 and store them in FOUND_FILES.  DEPS_FOUND is the number of them.  */
        -:13863:
   217422:13864:      for (i = 0; i < nrules; i++)
branch  0 taken 189666
branch  1 taken 27756 (fallthrough)
        -:13865:	{
        -:13866:	  int check_lastslash;
        -:13867:
   189666:13868:	  rule = tryrules[i];
        -:13869:
        -:13870:	  /* RULE is nil when we discover that a rule,
        -:13871:	     already placed in TRYRULES, should not be applied.  */
   189666:13872:	  if (rule == 0)
branch  0 taken 771 (fallthrough)
branch  1 taken 188895
      771:13873:	    continue;
        -:13874:
        -:13875:	  /* Reject any terminal rules if we're
        -:13876:	     looking to make intermediate files.  */
   188895:13877:	  if (intermed_ok && rule->terminal)
branch  0 taken 94062 (fallthrough)
branch  1 taken 94833
branch  2 taken 69390 (fallthrough)
branch  3 taken 24672
    69390:13878:	    continue;
        -:13879:
        -:13880:	  /* Mark this rule as in use so a recursive
        -:13881:	     pattern_search won't try to use it.  */
   119505:13882:	  rule->in_use = 1;
        -:13883:
        -:13884:	  /* From the lengths of the filename and the matching pattern parts,
        -:13885:	     find the stem: the part of the filename that matches the %.  */
   119505:13886:	  stem = filename
   119505:13887:	    + (rule->suffixes[matches[i]] - rule->targets[matches[i]]) - 1;
   119505:13888:	  stemlen = namelen - rule->lens[matches[i]] + 1;
   119505:13889:	  check_lastslash = checked_lastslash[i];
   119505:13890:	  if (check_lastslash)
branch  0 taken 119505 (fallthrough)
branch  1 taken 0
        -:13891:	    {
   119505:13892:	      stem += lastslash - filename + 1;
   119505:13893:	      stemlen -= (lastslash - filename) + 1;
        -:13894:	    }
        -:13895:
   119505:13896:	  DEBUGP2 (_("Trying pattern rule with stem `%.*s'.\n"),
branch  0 taken 59520 (fallthrough)
branch  1 taken 59985
call    2 returned 59520
call    3 returned 59520
call    4 returned 59520
        -:13897:		   (int) stemlen, stem);
        -:13898:
        -:13899:	  /* Try each dependency; see if it "exists".  */
        -:13900:
   119505:13901:	  deps_found = 0;
  119505*:13902:	  for (dep = rule->deps; dep != 0; dep = dep->next)
branch  0 taken 119505
branch  1 taken 0 (fallthrough)
        -:13903:	    {
        -:13904:              struct file *fp;
        -:13905:
        -:13906:	      /* If the dependency name has a %, substitute the stem.  */
  119505*:13907:	      p = index (dep_name (dep), '%');
branch  0 taken 0 (fallthrough)
branch  1 taken 119505
   119505:13908:	      if (p != 0)
branch  0 taken 119505 (fallthrough)
branch  1 taken 0
        -:13909:		{
        -:13910:		  register unsigned int i;
   119505:13911:		  if (check_lastslash)
branch  0 taken 119505 (fallthrough)
branch  1 taken 0
        -:13912:		    {
        -:13913:		      /* Copy directory name from the original FILENAME.  */
   119505:13914:		      i = lastslash - filename + 1;
   119505:13915:		      bcopy (filename, depname, i);
        -:13916:		    }
        -:13917:		  else
    #####:13918:		    i = 0;
  119505*:13919:		  bcopy (dep_name (dep), depname + i, p - dep_name (dep));
branch  0 taken 0 (fallthrough)
branch  1 taken 119505
branch  2 taken 0 (fallthrough)
branch  3 taken 119505
  119505*:13920:		  i += p - dep_name (dep);
branch  0 taken 0 (fallthrough)
branch  1 taken 119505
   119505:13921:		  bcopy (stem, depname + i, stemlen);
   119505:13922:		  i += stemlen;
   119505:13923:		  strcpy (depname + i, p + 1);
   119505:13924:		  p = depname;
        -:13925:		}
        -:13926:	      else
    #####:13927:		p = dep_name (dep);
branch  0 never executed
branch  1 never executed
        -:13928:
        -:13929:	      /* P is now the actual dependency name as substituted.  */
        -:13930:
   119505:13931:	      if (file_impossible_p (p))
call    0 returned 119505
branch  1 taken 12336 (fallthrough)
branch  2 taken 107169
        -:13932:		{
        -:13933:		  /* If this dependency has already been ruled
        -:13934:		     "impossible", then the rule fails and don't
        -:13935:		     bother trying it on the second pass either
        -:13936:		     since we know that will fail too.  */
   12336*:13937:		  DEBUGP2 (_("Rejecting impossible %s prerequisite `%s'.\n"),
branch  0 taken 6144 (fallthrough)
branch  1 taken 6192
call    2 returned 6144
branch  3 taken 6144 (fallthrough)
branch  4 taken 0
call    5 returned 6144
call    6 returned 6144
        -:13938:			   p == depname ? _("implicit") : _("rule"), p);
    12336:13939:		  tryrules[i] = 0;
    12336:13940:		  break;
        -:13941:		}
        -:13942:
   107169:13943:	      intermediate_files[deps_found] = 0;
        -:13944:
  107169*:13945:	      DEBUGP2 (_("Trying %s prerequisite `%s'.\n"),
branch  0 taken 53376 (fallthrough)
branch  1 taken 53793
call    2 returned 53376
branch  3 taken 53376 (fallthrough)
branch  4 taken 0
call    5 returned 53376
call    6 returned 53376
        -:13946:		       p == depname ? _("implicit") : _("rule"), p);
        -:13947:
        -:13948:	      /* The DEP->changed flag says that this dependency resides in a
        -:13949:		 nonexistent directory.  So we normally can skip looking for
        -:13950:		 the file.  However, if CHECK_LASTSLASH is set, then the
        -:13951:		 dependency file we are actually looking for is in a different
        -:13952:		 directory (the one gotten by prepending FILENAME's directory),
        -:13953:		 so it might actually exist.  */
        -:13954:              /* If we find a file but the intermediate flag is set, then it
        -:13955:                 was put here by a .INTERMEDIATE: rule so ignore it.  */
        -:13956:
  107169*:13957:	      if ((!dep->changed || check_lastslash)
branch  0 taken 41634 (fallthrough)
branch  1 taken 65535
branch  2 taken 41634 (fallthrough)
branch  3 taken 0
  107169*:13958:		  && (((fp = lookup_file (p)) != 0 && !fp->intermediate)
call    0 returned 107169
branch  1 taken 0 (fallthrough)
branch  2 taken 107169
branch  3 never executed
branch  4 never executed
   107169:13959:                      || file_exists_p (p)))
call    0 returned 107169
branch  1 taken 0 (fallthrough)
branch  2 taken 107169
        -:13960:		{
    #####:13961:		  found_files[deps_found++] = xstrdup (p);
call    0 never executed
    #####:13962:		  continue;
        -:13963:		}
        -:13964:	      /* This code, given FILENAME = "lib/foo.o", dependency name
        -:13965:		 "lib/foo.c", and VPATH=src, searches for "src/lib/foo.c".  */
   107169:13966:	      vp = p;
  107169*:13967:	      if (vpath_search (&vp, (FILE_TIMESTAMP *) 0))
call    0 returned 107169
branch  1 taken 0 (fallthrough)
branch  2 taken 107169
        -:13968:		{
    #####:13969:		  DEBUGP2 (_("Found prerequisite `%s' as VPATH `%s'\n"),
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:13970:                           p, vp);
    #####:13971:		  strcpy (vp, p);
    #####:13972:		  found_files[deps_found++] = vp;
    #####:13973:		  continue;
        -:13974:		}
        -:13975:
        -:13976:	      /* We could not find the file in any place we should look.
        -:13977:		 Try to make this dependency as an intermediate file,
        -:13978:		 but only on the second pass.  */
        -:13979:
   107169:13980:	      if (intermed_ok)
branch  0 taken 13107 (fallthrough)
branch  1 taken 94062
        -:13981:		{
    13107:13982:		  if (intermediate_file == 0)
branch  0 taken 4626 (fallthrough)
branch  1 taken 8481
        -:13983:		    intermediate_file
     4626:13984:		      = (struct file *) alloca (sizeof (struct file));
        -:13985:
    13107:13986:		  DEBUGP2 (_("Looking for a rule with %s file `%s'.\n"),
branch  0 taken 6528 (fallthrough)
branch  1 taken 6579
call    2 returned 6528
call    3 returned 6528
call    4 returned 6528
        -:13987:			   _("intermediate"), p);
        -:13988:
    13107:13989:		  bzero ((char *) intermediate_file, sizeof (struct file));
    13107:13990:		  intermediate_file->name = p;
   13107*:13991:		  if (pattern_search (intermediate_file, 0, depth + 1,
call    0 returned 13107
branch  1 taken 0 (fallthrough)
branch  2 taken 13107
        -:13992:				      recursions + 1))
        -:13993:		    {
    #####:13994:		      p = xstrdup (p);
call    0 never executed
    #####:13995:		      intermediate_patterns[deps_found]
    #####:13996:			= intermediate_file->name;
    #####:13997:		      intermediate_file->name = p;
    #####:13998:		      intermediate_files[deps_found] = intermediate_file;
    #####:13999:		      intermediate_file = 0;
        -:14000:		      /* Allocate an extra copy to go in FOUND_FILES,
        -:14001:			 because every elt of FOUND_FILES is consumed
        -:14002:			 or freed later.  */
    #####:14003:		      found_files[deps_found] = xstrdup (p);
call    0 never executed
    #####:14004:		      ++deps_found;
    #####:14005:		      continue;
        -:14006:		    }
        -:14007:
        -:14008:		  /* If we have tried to find P as an intermediate
        -:14009:		     file and failed, mark that name as impossible
        -:14010:		     so we won't go through the search again later.  */
    13107:14011:		  file_impossible (p);
call    0 returned 13107
        -:14012:		}
        -:14013:
        -:14014:	      /* A dependency of this rule does not exist.
        -:14015:		 Therefore, this rule fails.  */
   107169:14016:	      break;
        -:14017:	    }
        -:14018:
        -:14019:	  /* This rule is no longer `in use' for recursive searches.  */
   119505:14020:	  rule->in_use = 0;
        -:14021:
   119505:14022:	  if (dep != 0)
branch  0 taken 119505 (fallthrough)
branch  1 taken 0
        -:14023:	    {
        -:14024:	      /* This pattern rule does not apply.
        -:14025:		 If some of its dependencies succeeded,
        -:14026:		 free the data structure describing them.  */
   119505:14027:	      while (deps_found-- > 0)
branch  0 taken 0
branch  1 taken 119505
        -:14028:		{
    #####:14029:		  register struct file *f = intermediate_files[deps_found];
    #####:14030:		  free (found_files[deps_found]);
    #####:14031:		  if (f != 0
branch  0 never executed
branch  1 never executed
    #####:14032:		      && (f->stem < f->name
branch  0 never executed
branch  1 never executed
    #####:14033:			  || f->stem > f->name + strlen (f->name)))
branch  0 never executed
branch  1 never executed
    #####:14034:		    free (f->stem);
        -:14035:		}
        -:14036:	    }
        -:14037:	  else
        -:14038:	    /* This pattern rule does apply.  Stop looking for one.  */
    #####:14039:	    break;
        -:14040:	}
        -:14041:
        -:14042:      /* If we found an applicable rule without
        -:14043:	 intermediate files, don't try with them.  */
    27756:14044:      if (i < nrules)
branch  0 taken 0 (fallthrough)
branch  1 taken 27756
    #####:14045:	break;
        -:14046:
    27756:14047:      rule = 0;
        -:14048:    }
        -:14049:
        -:14050:  /* RULE is nil if the loop went all the way
        -:14051:     through the list and everything failed.  */
    13878:14052:  if (rule == 0)
branch  0 taken 13878 (fallthrough)
branch  1 taken 0
    13878:14053:    return 0;
        -:14054:
    #####:14055:  foundrule = i;
        -:14056:
        -:14057:  /* If we are recursing, store the pattern that matched
        -:14058:     FILENAME in FILE->name for use in upper levels.  */
        -:14059:
    #####:14060:  if (recursions > 0)
branch  0 never executed
branch  1 never executed
        -:14061:    /* Kludge-o-matic */
    #####:14062:    file->name = rule->targets[matches[foundrule]];
        -:14063:
        -:14064:  /* FOUND_FILES lists the dependencies for the rule we found.
        -:14065:     This includes the intermediate files, if any.
        -:14066:     Convert them into entries on the deps-chain of FILE.  */
        -:14067:
    #####:14068:  while (deps_found-- > 0)
branch  0 never executed
branch  1 never executed
        -:14069:    {
        -:14070:      register char *s;
        -:14071:
    #####:14072:      if (intermediate_files[deps_found] != 0)
branch  0 never executed
branch  1 never executed
        -:14073:	{
        -:14074:	  /* If we need to use an intermediate file,
        -:14075:	     make sure it is entered as a target, with the info that was
        -:14076:	     found for it in the recursive pattern_search call.
        -:14077:	     We know that the intermediate file did not already exist as
        -:14078:	     a target; therefore we can assume that the deps and cmds
        -:14079:	     of F below are null before we change them.  */
        -:14080:
    #####:14081:	  struct file *imf = intermediate_files[deps_found];
    #####:14082:	  register struct file *f = enter_file (imf->name);
call    0 never executed
    #####:14083:	  f->deps = imf->deps;
    #####:14084:	  f->cmds = imf->cmds;
    #####:14085:	  f->stem = imf->stem;
    #####:14086:          f->also_make = imf->also_make;
    #####:14087:	  imf = lookup_file (intermediate_patterns[deps_found]);
call    0 never executed
    #####:14088:	  if (imf != 0 && imf->precious)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:14089:	    f->precious = 1;
    #####:14090:	  f->intermediate = 1;
    #####:14091:	  f->tried_implicit = 1;
    #####:14092:	  for (dep = f->deps; dep != 0; dep = dep->next)
branch  0 never executed
branch  1 never executed
        -:14093:	    {
    #####:14094:	      dep->file = enter_file (dep->name);
call    0 never executed
        -:14095:              /* enter_file uses dep->name _if_ we created a new file.  */
    #####:14096:              if (dep->name != dep->file->name)
branch  0 never executed
branch  1 never executed
    #####:14097:                free (dep->name);
    #####:14098:	      dep->name = 0;
    #####:14099:	      dep->file->tried_implicit |= dep->changed;
        -:14100:	    }
    #####:14101:	  num_intermediates++;
        -:14102:	}
        -:14103:
    #####:14104:      dep = (struct dep *) xmalloc (sizeof (struct dep));
call    0 never executed
    #####:14105:      s = found_files[deps_found];
    #####:14106:      if (recursions == 0)
branch  0 never executed
branch  1 never executed
        -:14107:	{
    #####:14108:	  dep->name = 0;
    #####:14109:	  dep->file = lookup_file (s);
call    0 never executed
    #####:14110:	  if (dep->file == 0)
branch  0 never executed
branch  1 never executed
        -:14111:	    /* enter_file consumes S's storage.  */
    #####:14112:	    dep->file = enter_file (s);
call    0 never executed
        -:14113:	  else
        -:14114:	    /* A copy of S is already allocated in DEP->file->name.
        -:14115:	       So we can free S.  */
    #####:14116:	    free (s);
        -:14117:	}
        -:14118:      else
        -:14119:	{
    #####:14120:	  dep->name = s;
    #####:14121:	  dep->file = 0;
    #####:14122:	  dep->changed = 0;
        -:14123:	}
    #####:14124:      if (intermediate_files[deps_found] == 0 && tryrules[foundrule]->terminal)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:14125:	{
        -:14126:	  /* If the file actually existed (was not an intermediate file),
        -:14127:	     and the rule that found it was a terminal one, then we want
        -:14128:	     to mark the found file so that it will not have implicit rule
        -:14129:	     search done for it.  If we are not entering a `struct file' for
        -:14130:	     it now, we indicate this with the `changed' flag.  */
    #####:14131:	  if (dep->file == 0)
branch  0 never executed
branch  1 never executed
    #####:14132:	    dep->changed = 1;
        -:14133:	  else
    #####:14134:	    dep->file->tried_implicit = 1;
        -:14135:	}
    #####:14136:      dep->next = file->deps;
    #####:14137:      file->deps = dep;
        -:14138:    }
        -:14139:
    #####:14140:  if (!checked_lastslash[foundrule])
branch  0 never executed
branch  1 never executed
        -:14141:    /* Always allocate new storage, since STEM might be
        -:14142:       on the stack for an intermediate file.  */
    #####:14143:    file->stem = savestring (stem, stemlen);
call    0 never executed
        -:14144:  else
        -:14145:    {
        -:14146:      /* We want to prepend the directory from
        -:14147:	 the original FILENAME onto the stem.  */
    #####:14148:      file->stem = (char *) xmalloc (((lastslash + 1) - filename)
    #####:14149:				     + stemlen + 1);
call    0 never executed
    #####:14150:      bcopy (filename, file->stem, (lastslash + 1) - filename);
    #####:14151:      bcopy (stem, file->stem + ((lastslash + 1) - filename), stemlen);
    #####:14152:      file->stem[((lastslash + 1) - filename) + stemlen] = '\0';
        -:14153:    }
        -:14154:
    #####:14155:  file->cmds = rule->cmds;
        -:14156:
        -:14157:  /* If this rule builds other targets, too, put the others into FILE's
        -:14158:     `also_make' member.  */
        -:14159:
    #####:14160:  if (rule->targets[1] != 0)
branch  0 never executed
branch  1 never executed
    #####:14161:    for (i = 0; rule->targets[i] != 0; ++i)
branch  0 never executed
branch  1 never executed
    #####:14162:      if (i != matches[foundrule])
branch  0 never executed
branch  1 never executed
        -:14163:	{
    #####:14164:	  struct dep *new = (struct dep *) xmalloc (sizeof (struct dep));
call    0 never executed
    #####:14165:	  new->name = p = (char *) xmalloc (rule->lens[i] + stemlen + 1);
call    0 never executed
    #####:14166:	  bcopy (rule->targets[i], p,
        -:14167:		 rule->suffixes[i] - rule->targets[i] - 1);
    #####:14168:	  p += rule->suffixes[i] - rule->targets[i] - 1;
    #####:14169:	  bcopy (stem, p, stemlen);
    #####:14170:	  p += stemlen;
    #####:14171:	  bcopy (rule->suffixes[i], p,
        -:14172:		 rule->lens[i] - (rule->suffixes[i] - rule->targets[i]) + 1);
    #####:14173:	  new->file = enter_file (new->name);
call    0 never executed
    #####:14174:	  new->next = file->also_make;
    #####:14175:	  file->also_make = new;
        -:14176:	}
        -:14177:
        -:14178:
    #####:14179:  return 1;
        -:14180:}
        -:14181:
        -:14182:
        -:14183:
        -:14184:/*************************************************************
        -:14185:  ============================================================
        -:14186:  ************************************************************
        -:14187:  ============================================================
        -:14188:  ************************************************************
        -:14189:                         default.c
        -:14190:  ************************************************************
        -:14191:  ============================================================
        -:14192:  ************************************************************
        -:14193:  ============================================================
        -:14194:  *************************************************************/
        -:14195:
        -:14196:/* Data base of default implicit rules for GNU Make.
        -:14197:Copyright (C) 1988,89,90,91,92,93,94,95,96 Free Software Foundation, Inc.
        -:14198:This file is part of GNU Make.
        -:14199:
        -:14200:GNU Make is free software; you can redistribute it and/or modify
        -:14201:it under the terms of the GNU General Public License as published by
        -:14202:the Free Software Foundation; either version 2, or (at your option)
        -:14203:any later version.
        -:14204:
        -:14205:GNU Make is distributed in the hope that it will be useful,
        -:14206:but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:14207:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:14208:GNU General Public License for more details.
        -:14209:
        -:14210:You should have received a copy of the GNU General Public License
        -:14211:along with GNU Make; see the file COPYING.  If not, write to
        -:14212:the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
        -:14213:Boston, MA 02111-1307, USA.  */
        -:14214:
        -:14215:/* #include "make.h"  <- modification by J.Ruthruff, 7/27 */
        -:14216:/* #include "rule.h"  <- modification by J.Ruthruff, 7/27 */
        -:14217:/* #include "dep.h"  <- modification by J.Ruthruff, 7/27 */
        -:14218:/* #include "filedef.h"  <- modification by J.Ruthruff, 7/27 */
        -:14219:#include "job.h"
        -:14220:/* #include "commands.h"  <- modification by J.Ruthruff, 7/27 */
        -:14221:/* #include "variable.h"  <- modification by J.Ruthruff, 7/27 */
        -:14222:#undef stderr
        -:14223:#define stderr stdout
        -:14224:
        -:14225:/* Define GCC_IS_NATIVE if gcc is the native development environment on
        -:14226:   your system (gcc/bison/flex vs cc/yacc/lex).  */
        -:14227:#ifdef __MSDOS__
        -:14228:#define GCC_IS_NATIVE
        -:14229:#endif
        -:14230:
        -:14231:
        -:14232:/* This is the default list of suffixes for suffix rules.
        -:14233:   `.s' must come last, so that a `.o' file will be made from
        -:14234:   a `.c' or `.p' or ... file rather than from a .s file.  */
        -:14235:
        -:14236:static char default_suffixes[]
        -:14237:#ifdef VMS
        -:14238:  = ".exe .olb .ln .obj .c .cc .pas .p .for .f .r .y .l .mar \
        -:14239:.mod .sym .def .h .info .dvi .tex .texinfo .texi .txinfo \
        -:14240:.w .ch .cweb .web .com .sh .elc .el";
        -:14241:#else
        -:14242:  = ".out .a .ln .o .c .cc .C .cpp .p .f .F .r .y .l .s .S \
        -:14243:.mod .sym .def .h .info .dvi .tex .texinfo .texi .txinfo \
        -:14244:.w .ch .web .sh .elc .el";
        -:14245:#endif
        -:14246:
        -:14247:static struct pspec default_pattern_rules[] =
        -:14248:  {
        -:14249:    { "(%)", "%",
        -:14250:	"$(AR) $(ARFLAGS) $@ $<" },
        -:14251:
        -:14252:    /* The X.out rules are only in BSD's default set because
        -:14253:       BSD Make has no null-suffix rules, so `foo.out' and
        -:14254:       `foo' are the same thing.  */
        -:14255:#ifdef VMS
        -:14256:    { "%.exe", "%",
        -:14257:        "copy $< $@" },
        -:14258:#else
        -:14259:    { "%.out", "%",
        -:14260:	"@rm -f $@ \n cp $< $@" },
        -:14261:#endif
        -:14262:    /* Syntax is "ctangle foo.w foo.ch foo.c".  */
        -:14263:    { "%.c", "%.w %.ch",
        -:14264:	"$(CTANGLE) $^ $@" },
        -:14265:    { "%.tex", "%.w %.ch",
        -:14266:	"$(CWEAVE) $^ $@" },
        -:14267:
        -:14268:    { 0, 0, 0 }
        -:14269:  };
        -:14270:
        -:14271:static struct pspec default_terminal_rules[] =
        -:14272:  {
        -:14273:#ifdef VMS
        -:14274:    /* RCS.  */
        -:14275:    { "%", "%$$5lv", /* Multinet style */
        -:14276:        "if f$$search($@) .nes. \"\" then +$(CHECKOUT,v)" },
        -:14277:    { "%", "[.$$rcs]%$$5lv", /* Multinet style */
        -:14278:        "if f$$search($@) .nes. \"\" then +$(CHECKOUT,v)" },
        -:14279:    { "%", "%_v", /* Normal style */
        -:14280:        "if f$$search($@) .nes. \"\" then +$(CHECKOUT,v)" },
        -:14281:    { "%", "[.rcs]%_v", /* Normal style */
        -:14282:        "if f$$search($@) .nes. \"\" then +$(CHECKOUT,v)" },
        -:14283:
        -:14284:    /* SCCS.  */
        -:14285:	/* ain't no SCCS on vms */
        -:14286:#else
        -:14287:    /* RCS.  */
        -:14288:    { "%", "%,v",
        -:14289:	"$(CHECKOUT,v)" },
        -:14290:    { "%", "RCS/%,v",
        -:14291:	"$(CHECKOUT,v)" },
        -:14292:    { "%", "RCS/%",
        -:14293:	"$(CHECKOUT,v)" },
        -:14294:
        -:14295:    /* SCCS.  */
        -:14296:    { "%", "s.%",
        -:14297:	"$(GET) $(GFLAGS) $(SCCS_OUTPUT_OPTION) $<" },
        -:14298:    { "%", "SCCS/s.%",
        -:14299:	"$(GET) $(GFLAGS) $(SCCS_OUTPUT_OPTION) $<" },
        -:14300:#endif /* !VMS */
        -:14301:    { 0, 0, 0 }
        -:14302:  };
        -:14303:
        -:14304:static char *default_suffix_rules[] =
        -:14305:  {
        -:14306:#ifdef VMS
        -:14307:    ".obj.exe",
        -:14308:    "$(LINK.obj) $^ $(LOADLIBES) $(LDLIBS) /exe=$@",
        -:14309:    ".mar.exe",
        -:14310:    "$(LINK.mar) $^ $(LOADLIBES) $(LDLIBS) /exe=$@",
        -:14311:    ".c.exe",
        -:14312:    "$(COMPILE.c) $^ \n $(LINK.obj) $(subst .c,.obj,$^) $(LOADLIBES) $(LDLIBS) /exe=$@",
        -:14313:    ".cc.exe",
        -:14314:    "$(COMPILE.cc) $^ \n $(LINK.obj) $(subst .cc,.obj,$^) $(LOADLIBES) $(LDLIBS) /exe=$@",
        -:14315:    ".for.exe",
        -:14316:    "$(COMPILE.for) $^ \n $(LINK.obj) $(subst .for,.obj,$^) $(LOADLIBES) $(LDLIBS) /exe=$@",
        -:14317:    ".pas.exe",
        -:14318:    "$(COMPILE.pas) $^ \n $(LINK.obj) $(subst .pas,.obj,$^) $(LOADLIBES) $(LDLIBS) /exe=$@",
        -:14319:
        -:14320:    ".com",
        -:14321:    "copy $< >$@",
        -:14322:
        -:14323:    ".mar.obj",
        -:14324:    "$(COMPILE.mar) /obj=$@ $<",
        -:14325:    ".c.obj",
        -:14326:    "$(COMPILE.c) /obj=$@ $<",
        -:14327:    ".cc.obj",
        -:14328:    "$(COMPILE.cc) /obj=$@ $<",
        -:14329:    ".for.obj",
        -:14330:    "$(COMPILE.for) /obj=$@ $<",
        -:14331:    ".pas.obj",
        -:14332:    "$(COMPILE.pas) /obj=$@ $<",
        -:14333:
        -:14334:    ".y.c",
        -:14335:    "$(YACC.y) $< \n rename y_tab.c $@",
        -:14336:    ".l.c",
        -:14337:    "$(LEX.l) $< \n rename lexyy.c $@",
        -:14338:
        -:14339:    ".texinfo.info",
        -:14340:    "$(MAKEINFO) $<",
        -:14341:
        -:14342:    ".tex.dvi",
        -:14343:    "$(TEX) $<",
        -:14344:
        -:14345:#else /* ! VMS */
        -:14346:
        -:14347:    ".o",
        -:14348:    "$(LINK.o) $^ $(LOADLIBES) $(LDLIBS) -o $@",
        -:14349:    ".s",
        -:14350:    "$(LINK.s) $^ $(LOADLIBES) $(LDLIBS) -o $@",
        -:14351:    ".S",
        -:14352:    "$(LINK.S) $^ $(LOADLIBES) $(LDLIBS) -o $@",
        -:14353:    ".c",
        -:14354:    "$(LINK.c) $^ $(LOADLIBES) $(LDLIBS) -o $@",
        -:14355:    ".cc",
        -:14356:    "$(LINK.cc) $^ $(LOADLIBES) $(LDLIBS) -o $@",
        -:14357:    ".C",
        -:14358:    "$(LINK.C) $^ $(LOADLIBES) $(LDLIBS) -o $@",
        -:14359:    ".cpp",
        -:14360:    "$(LINK.cpp) $^ $(LOADLIBES) $(LDLIBS) -o $@",
        -:14361:    ".f",
        -:14362:    "$(LINK.f) $^ $(LOADLIBES) $(LDLIBS) -o $@",
        -:14363:    ".p",
        -:14364:    "$(LINK.p) $^ $(LOADLIBES) $(LDLIBS) -o $@",
        -:14365:    ".F",
        -:14366:    "$(LINK.F) $^ $(LOADLIBES) $(LDLIBS) -o $@",
        -:14367:    ".r",
        -:14368:    "$(LINK.r) $^ $(LOADLIBES) $(LDLIBS) -o $@",
        -:14369:    ".mod",
        -:14370:    "$(COMPILE.mod) -o $@ -e $@ $^",
        -:14371:
        -:14372:    ".def.sym",
        -:14373:    "$(COMPILE.def) -o $@ $<",
        -:14374:
        -:14375:    ".sh",
        -:14376:    "cat $< >$@ \n chmod a+x $@",
        -:14377:
        -:14378:    ".s.o",
        -:14379:    "$(COMPILE.s) -o $@ $<",
        -:14380:    ".S.o",
        -:14381:    "$(COMPILE.S) -o $@ $<",
        -:14382:    ".c.o",
        -:14383:    "$(COMPILE.c) $(OUTPUT_OPTION) $<",
        -:14384:    ".cc.o",
        -:14385:    "$(COMPILE.cc) $(OUTPUT_OPTION) $<",
        -:14386:    ".C.o",
        -:14387:    "$(COMPILE.C) $(OUTPUT_OPTION) $<",
        -:14388:    ".cpp.o",
        -:14389:    "$(COMPILE.cpp) $(OUTPUT_OPTION) $<",
        -:14390:    ".f.o",
        -:14391:    "$(COMPILE.f) $(OUTPUT_OPTION) $<",
        -:14392:    ".p.o",
        -:14393:    "$(COMPILE.p) $(OUTPUT_OPTION) $<",
        -:14394:    ".F.o",
        -:14395:    "$(COMPILE.F) $(OUTPUT_OPTION) $<",
        -:14396:    ".r.o",
        -:14397:    "$(COMPILE.r) $(OUTPUT_OPTION) $<",
        -:14398:    ".mod.o",
        -:14399:    "$(COMPILE.mod) -o $@ $<",
        -:14400:
        -:14401:    ".c.ln",
        -:14402:    "$(LINT.c) -C$* $<",
        -:14403:    ".y.ln",
        -:14404:#ifndef __MSDOS__
        -:14405:    "$(YACC.y) $< \n $(LINT.c) -C$* y.tab.c \n $(RM) y.tab.c",
        -:14406:#else
        -:14407:    "$(YACC.y) $< \n $(LINT.c) -C$* y_tab.c \n $(RM) y_tab.c",
        -:14408:#endif
        -:14409:    ".l.ln",
        -:14410:    "@$(RM) $*.c\n $(LEX.l) $< > $*.c\n$(LINT.c) -i $*.c -o $@\n $(RM) $*.c",
        -:14411:
        -:14412:    ".y.c",
        -:14413:#ifndef __MSDOS__
        -:14414:    "$(YACC.y) $< \n mv -f y.tab.c $@",
        -:14415:#else
        -:14416:    "$(YACC.y) $< \n mv -f y_tab.c $@",
        -:14417:#endif
        -:14418:    ".l.c",
        -:14419:    "@$(RM) $@ \n $(LEX.l) $< > $@",
        -:14420:
        -:14421:    ".F.f",
        -:14422:    "$(PREPROCESS.F) $(OUTPUT_OPTION) $<",
        -:14423:    ".r.f",
        -:14424:    "$(PREPROCESS.r) $(OUTPUT_OPTION) $<",
        -:14425:
        -:14426:    /* This might actually make lex.yy.c if there's no %R%
        -:14427:       directive in $*.l, but in that case why were you
        -:14428:       trying to make $*.r anyway?  */
        -:14429:    ".l.r",
        -:14430:    "$(LEX.l) $< > $@ \n mv -f lex.yy.r $@",
        -:14431:
        -:14432:    ".S.s",
        -:14433:    "$(PREPROCESS.S) $< > $@",
        -:14434:
        -:14435:    ".texinfo.info",
        -:14436:    "$(MAKEINFO) $(MAKEINFO_FLAGS) $< -o $@",
        -:14437:
        -:14438:    ".texi.info",
        -:14439:    "$(MAKEINFO) $(MAKEINFO_FLAGS) $< -o $@",
        -:14440:
        -:14441:    ".txinfo.info",
        -:14442:    "$(MAKEINFO) $(MAKEINFO_FLAGS) $< -o $@",
        -:14443:
        -:14444:    ".tex.dvi",
        -:14445:    "$(TEX) $<",
        -:14446:
        -:14447:    ".texinfo.dvi",
        -:14448:    "$(TEXI2DVI) $(TEXI2DVI_FLAGS) $<",
        -:14449:
        -:14450:    ".texi.dvi",
        -:14451:    "$(TEXI2DVI) $(TEXI2DVI_FLAGS) $<",
        -:14452:
        -:14453:    ".txinfo.dvi",
        -:14454:    "$(TEXI2DVI) $(TEXI2DVI_FLAGS) $<",
        -:14455:
        -:14456:    ".w.c",
        -:14457:    "$(CTANGLE) $< - $@",	/* The `-' says there is no `.ch' file.  */
        -:14458:
        -:14459:    ".web.p",
        -:14460:    "$(TANGLE) $<",
        -:14461:
        -:14462:    ".w.tex",
        -:14463:    "$(CWEAVE) $< - $@",	/* The `-' says there is no `.ch' file.  */
        -:14464:
        -:14465:    ".web.tex",
        -:14466:    "$(WEAVE) $<",
        -:14467:
        -:14468:#endif /* !VMS */
        -:14469:
        -:14470:    0, 0,
        -:14471:  };
        -:14472:
        -:14473:static char *default_variables[] =
        -:14474:  {
        -:14475:#ifdef VMS
        -:14476:    "AR", "library/obj",
        -:14477:    "ARFLAGS", "/replace",
        -:14478:    "AS", "macro",
        -:14479:    "CC", "cc",
        -:14480:    "C++", "gcc/plus",
        -:14481:    "CXX", "gcc/plus",
        -:14482:    "CO", "co",
        -:14483:    "CPP", "$(CC) /preprocess_only",
        -:14484:    "FC", "fortran",
        -:14485:    /* System V uses these, so explicit rules using them should work.
        -:14486:       However, there is no way to make implicit rules use them and FC.  */
        -:14487:    "F77", "$(FC)",
        -:14488:    "F77FLAGS", "$(FFLAGS)",
        -:14489:    "LD", "link",
        -:14490:    "LEX", "lex",
        -:14491:    "PC", "pascal",
        -:14492:    "YACC", "yacc",	/* Or "bison -y"  */
        -:14493:    "MAKEINFO", "makeinfo",
        -:14494:    "TEX", "tex",
        -:14495:    "TEXINDEX", "texindex",
        -:14496:
        -:14497:    "RM", "delete/nolog",
        -:14498:
        -:14499:    "LINK.obj", "$(LD) $(LDFLAGS)",
        -:14500:    "COMPILE.c", "$(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH)",
        -:14501:    "COMPILE.cc", "$(C++) $(C++FLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c",
        -:14502:    "YACC.y", "$(YACC) $(YFLAGS)",
        -:14503:    "LEX.l", "$(LEX) $(LFLAGS)",
        -:14504:    "COMPILE.for", "$(FC) $(FFLAGS) $(TARGET_ARCH)",
        -:14505:    "COMPILE.pas", "$(PC) $(PFLAGS) $(CPPFLAGS) $(TARGET_ARCH)",
        -:14506:    "COMPILE.mar", "$(AS) $(ASFLAGS) $(TARGET_MACH)",
        -:14507:    "LINT.c", "$(LINT) $(LINTFLAGS) $(CPPFLAGS) $(TARGET_ARCH)",
        -:14508:
        -:14509:    "MV", "rename/new_version",
        -:14510:    "CP", "copy",
        -:14511:
        -:14512:#else /* !VMS */
        -:14513:
        -:14514:    "AR", "ar",
        -:14515:    "ARFLAGS", "rv",
        -:14516:    "AS", "as",
        -:14517:#ifdef GCC_IS_NATIVE
        -:14518:    "CC", "gcc",
        -:14519:    "CXX", "gcc",
        -:14520:#else
        -:14521:    "CC", "cc",
        -:14522:    "CXX", "g++",
        -:14523:#endif
        -:14524:
        -:14525:    /* This expands to $(CO) $(COFLAGS) $< $@ if $@ does not exist,
        -:14526:       and to the empty string if $@ does exist.  */
        -:14527:    "CHECKOUT,v",
        -:14528:    "+$(patsubst $@-noexist,$(CO) $(COFLAGS) $< $@,\
        -:14529:		 $(filter-out $@,$(firstword $(wildcard $@) $@-noexist)))",
        -:14530:
        -:14531:    "CO", "co",
        -:14532:    "CPP", "$(CC) -E",
        -:14533:#ifdef	CRAY
        -:14534:    "CF77PPFLAGS", "-P",
        -:14535:    "CF77PP", "/lib/cpp",
        -:14536:    "CFT", "cft77",
        -:14537:    "CF", "cf77",
        -:14538:    "FC", "$(CF)",
        -:14539:#else	/* Not CRAY.  */
        -:14540:#ifdef	_IBMR2
        -:14541:    "FC", "xlf",
        -:14542:#else
        -:14543:#ifdef	__convex__
        -:14544:    "FC", "fc",
        -:14545:#else
        -:14546:    "FC", "f77",
        -:14547:#endif /* __convex__ */
        -:14548:#endif /* _IBMR2 */
        -:14549:    /* System V uses these, so explicit rules using them should work.
        -:14550:       However, there is no way to make implicit rules use them and FC.  */
        -:14551:    "F77", "$(FC)",
        -:14552:    "F77FLAGS", "$(FFLAGS)",
        -:14553:#endif	/* Cray.  */
        -:14554:    "GET", SCCS_GET,
        -:14555:    "LD", "ld",
        -:14556:#ifdef GCC_IS_NATIVE
        -:14557:    "LEX", "flex",
        -:14558:#else
        -:14559:    "LEX", "lex",
        -:14560:#endif
        -:14561:    "LINT", "lint",
        -:14562:    "M2C", "m2c",
        -:14563:#ifdef	pyr
        -:14564:    "PC", "pascal",
        -:14565:#else
        -:14566:#ifdef	CRAY
        -:14567:    "PC", "PASCAL",
        -:14568:    "SEGLDR", "segldr",
        -:14569:#else
        -:14570:    "PC", "pc",
        -:14571:#endif	/* CRAY.  */
        -:14572:#endif	/* pyr.  */
        -:14573:#ifdef GCC_IS_NATIVE
        -:14574:    "YACC", "bison -y",
        -:14575:#else
        -:14576:    "YACC", "yacc",	/* Or "bison -y"  */
        -:14577:#endif
        -:14578:    "MAKEINFO", "makeinfo",
        -:14579:    "TEX", "tex",
        -:14580:    "TEXI2DVI", "texi2dvi",
        -:14581:    "WEAVE", "weave",
        -:14582:    "CWEAVE", "cweave",
        -:14583:    "TANGLE", "tangle",
        -:14584:    "CTANGLE", "ctangle",
        -:14585:
        -:14586:    "RM", "rm -f",
        -:14587:
        -:14588:    "LINK.o", "$(CC) $(LDFLAGS) $(TARGET_ARCH)",
        -:14589:    "COMPILE.c", "$(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c",
        -:14590:    "LINK.c", "$(CC) $(CFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH)",
        -:14591:    "COMPILE.cc", "$(CXX) $(CXXFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c",
        -:14592:    "COMPILE.C", "$(COMPILE.cc)",
        -:14593:    "COMPILE.cpp", "$(COMPILE.cc)",
        -:14594:    "LINK.cc", "$(CXX) $(CXXFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH)",
        -:14595:    "LINK.C", "$(LINK.cc)",
        -:14596:    "LINK.cpp", "$(LINK.cc)",
        -:14597:    "YACC.y", "$(YACC) $(YFLAGS)",
        -:14598:    "LEX.l", "$(LEX) $(LFLAGS) -t",
        -:14599:    "COMPILE.f", "$(FC) $(FFLAGS) $(TARGET_ARCH) -c",
        -:14600:    "LINK.f", "$(FC) $(FFLAGS) $(LDFLAGS) $(TARGET_ARCH)",
        -:14601:    "COMPILE.F", "$(FC) $(FFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c",
        -:14602:    "LINK.F", "$(FC) $(FFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH)",
        -:14603:    "COMPILE.r", "$(FC) $(FFLAGS) $(RFLAGS) $(TARGET_ARCH) -c",
        -:14604:    "LINK.r", "$(FC) $(FFLAGS) $(RFLAGS) $(LDFLAGS) $(TARGET_ARCH)",
        -:14605:    "COMPILE.def", "$(M2C) $(M2FLAGS) $(DEFFLAGS) $(TARGET_ARCH)",
        -:14606:    "COMPILE.mod", "$(M2C) $(M2FLAGS) $(MODFLAGS) $(TARGET_ARCH)",
        -:14607:    "COMPILE.p", "$(PC) $(PFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c",
        -:14608:    "LINK.p", "$(PC) $(PFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH)",
        -:14609:    "LINK.s", "$(CC) $(ASFLAGS) $(LDFLAGS) $(TARGET_MACH)",
        -:14610:    "COMPILE.s", "$(AS) $(ASFLAGS) $(TARGET_MACH)",
        -:14611:    "LINK.S", "$(CC) $(ASFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_MACH)",
        -:14612:    "COMPILE.S", "$(CC) $(ASFLAGS) $(CPPFLAGS) $(TARGET_MACH) -c",
        -:14613:    "PREPROCESS.S", "$(CC) -E $(CPPFLAGS)",
        -:14614:    "PREPROCESS.F", "$(FC) $(FFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -F",
        -:14615:    "PREPROCESS.r", "$(FC) $(FFLAGS) $(RFLAGS) $(TARGET_ARCH) -F",
        -:14616:    "LINT.c", "$(LINT) $(LINTFLAGS) $(CPPFLAGS) $(TARGET_ARCH)",
        -:14617:
        -:14618:#ifndef	NO_MINUS_C_MINUS_O
        -:14619:    "OUTPUT_OPTION", "-o $@",
        -:14620:#endif
        -:14621:
        -:14622:#ifdef	SCCS_GET_MINUS_G
        -:14623:    "SCCS_OUTPUT_OPTION", "-G$@",
        -:14624:#endif
        -:14625:
        -:14626:#ifdef _AMIGA
        -:14627:    ".LIBPATTERNS", "%.lib",
        -:14628:#else
        -:14629:#ifdef __MSDOS__
        -:14630:    ".LIBPATTERNS", "lib%.a $(DJDIR)/lib/lib%.a",
        -:14631:#else
        -:14632:    ".LIBPATTERNS", "lib%.so lib%.a",
        -:14633:#endif
        -:14634:#endif
        -:14635:
        -:14636:#endif /* !VMS */
        -:14637:    0, 0
        -:14638:  };
        -:14639:
        -:14640:/* Set up the default .SUFFIXES list.  */
        -:14641:
        -:14642:void
function set_default_suffixes called 771 returned 100% blocks executed 88%
      771:14643:set_default_suffixes ()
        -:14644:{
      771:14645:  suffix_file = enter_file (".SUFFIXES");
call    0 returned 771
        -:14646:
      771:14647:  if (no_builtin_rules_flag)
branch  0 taken 0 (fallthrough)
branch  1 taken 771
    #####:14648:    (void) define_variable ("SUFFIXES", 8, "", o_default, 0);
call    0 never executed
        -:14649:  else
        -:14650:    {
      771:14651:      char *p = default_suffixes;
     1542:14652:      suffix_file->deps = (struct dep *)
      771:14653:	multi_glob (parse_file_seq (&p, '\0', sizeof (struct dep), 1),
call    0 returned 771
call    1 returned 771
        -:14654:		    sizeof (struct dep));
      771:14655:      (void) define_variable ("SUFFIXES", 8, default_suffixes, o_default, 0);
call    0 returned 771
        -:14656:    }
      771:14657:}
        -:14658:
        -:14659:/* Enter the default suffix rules as file rules.  This used to be done in
        -:14660:   install_default_implicit_rules, but that loses because we want the
        -:14661:   suffix rules installed before reading makefiles, and thee pattern rules
        -:14662:   installed after.  */
        -:14663:
        -:14664:void
function install_default_suffix_rules called 771 returned 100% blocks executed 90%
      771:14665:install_default_suffix_rules ()
        -:14666:{
        -:14667:  register char **s;
        -:14668:
      771:14669:  if (no_builtin_rules_flag)
branch  0 taken 0 (fallthrough)
branch  1 taken 771
    #####:14670:    return;
        -:14671:
    35466:14672: for (s = default_suffix_rules; *s != 0; s += 2)
branch  0 taken 34695
branch  1 taken 771 (fallthrough)
        -:14673:    {
    34695:14674:      register struct file *f = enter_file (s[0]);
call    0 returned 34695
        -:14675:      /* Don't clobber cmds given in a makefile if there were any.  */
    34695:14676:      if (f->cmds == 0)
branch  0 taken 34695 (fallthrough)
branch  1 taken 0
        -:14677:	{
    34695:14678:	  f->cmds = (struct commands *) xmalloc (sizeof (struct commands));
call    0 returned 34695
    34695:14679:	  f->cmds->fileinfo.filenm = 0;
    34695:14680:	  f->cmds->commands = s[1];
    34695:14681:	  f->cmds->command_lines = 0;
        -:14682:	}
        -:14683:    }
        -:14684:}
        -:14685:
        -:14686:
        -:14687:/* Install the default pattern rules.  */
        -:14688:
        -:14689:void
function install_default_implicit_rules called 771 returned 100% blocks executed 91%
      771:14690:install_default_implicit_rules ()
        -:14691:{
        -:14692:  register struct pspec *p;
        -:14693:
      771:14694:  if (no_builtin_rules_flag)
branch  0 taken 0 (fallthrough)
branch  1 taken 771
    #####:14695:    return;
        -:14696:
     3855:14697:  for (p = default_pattern_rules; p->target != 0; ++p)
branch  0 taken 3084
branch  1 taken 771 (fallthrough)
     3084:14698:    install_pattern_rule (p, 0);
call    0 returned 3084
        -:14699:
     4626:14700:  for (p = default_terminal_rules; p->target != 0; ++p)
branch  0 taken 3855
branch  1 taken 771 (fallthrough)
     3855:14701:    install_pattern_rule (p, 1);
call    0 returned 3855
        -:14702:}
        -:14703:
        -:14704:void
function define_default_variables called 771 returned 100% blocks executed 86%
      771:14705:define_default_variables ()
        -:14706:{
        -:14707:  register char **s;
        -:14708:
      771:14709:  if (no_builtin_variables_flag)
branch  0 taken 0 (fallthrough)
branch  1 taken 771
    #####:14710:    return;
        -:14711:
    45489:14712:  for (s = default_variables; *s != 0; s += 2)
branch  0 taken 44718
branch  1 taken 771 (fallthrough)
    44718:14713:    (void) define_variable (s[0], strlen (s[0]), s[1], o_default, 1);
call    0 returned 44718
        -:14714:}
        -:14715:
        -:14716:
        -:14717:
        -:14718:/*************************************************************
        -:14719:  ============================================================
        -:14720:  ************************************************************
        -:14721:  ============================================================
        -:14722:  ************************************************************
        -:14723:                         variable.c
        -:14724:  ************************************************************
        -:14725:  ============================================================
        -:14726:  ************************************************************
        -:14727:  ============================================================
        -:14728:  *************************************************************/
        -:14729:
        -:14730:/* Internals of variables for GNU Make.
        -:14731:Copyright (C) 1988,89,90,91,92,93,94,96,97 Free Software Foundation, Inc.
        -:14732:This file is part of GNU Make.
        -:14733:
        -:14734:GNU Make is free software; you can redistribute it and/or modify
        -:14735:it under the terms of the GNU General Public License as published by
        -:14736:the Free Software Foundation; either version 2, or (at your option)
        -:14737:any later version.
        -:14738:
        -:14739:GNU Make is distributed in the hope that it will be useful,
        -:14740:but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:14741:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:14742:GNU General Public License for more details.
        -:14743:
        -:14744:You should have received a copy of the GNU General Public License
        -:14745:along with GNU Make; see the file COPYING.  If not, write to
        -:14746:the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
        -:14747:Boston, MA 02111-1307, USA.  */
        -:14748:
        -:14749:/* #include "make.h"  <- modification by J.Ruthruff, 7/27 */
        -:14750:/* #include "dep.h"  <- modification by J.Ruthruff, 7/27 */
        -:14751:/* #include "filedef.h"  <- modification by J.Ruthruff, 7/27 */
        -:14752:#include "job.h"
        -:14753:/* #include "commands.h"  <- modification by J.Ruthruff, 7/27 */
        -:14754:/* #include "variable.h"  <- modification by J.Ruthruff, 7/27 */
        -:14755:#undef stderr
        -:14756:#define stderr stdout
        -:14757:#ifdef WINDOWS32
        -:14758:#include "pathstuff.h"
        -:14759:#undef stderr
        -:14760:#define stderr stdout
        -:14761:#endif
        -:14762:
        -:14763:/* Hash table of all global variable definitions.  */
        -:14764:
        -:14765:#ifndef	VARIABLE_BUCKETS
        -:14766:#define VARIABLE_BUCKETS		523
        -:14767:#endif
        -:14768:#ifndef	PERFILE_VARIABLE_BUCKETS
        -:14769:#define	PERFILE_VARIABLE_BUCKETS	23
        -:14770:#endif
        -:14771:#ifndef	SMALL_SCOPE_VARIABLE_BUCKETS
        -:14772:#define	SMALL_SCOPE_VARIABLE_BUCKETS	13
        -:14773:#endif
        -:14774:static struct variable *variable_table[VARIABLE_BUCKETS];
        -:14775:static struct variable_set global_variable_set
        -:14776:  = { variable_table, VARIABLE_BUCKETS };
        -:14777:static struct variable_set_list global_setlist
        -:14778:  = { 0, &global_variable_set };
        -:14779:struct variable_set_list *current_variable_set_list = &global_setlist;
        -:14780:
        -:14781:static struct variable *lookup_variable_in_set PARAMS ((char *name,
        -:14782:                          unsigned int length, struct variable_set *set));
        -:14783:
        -:14784:/* Implement variables.  */
        -:14785:
        -:14786:/* Define variable named NAME with value VALUE in SET.  VALUE is copied.
        -:14787:   LENGTH is the length of NAME, which does not need to be null-terminated.
        -:14788:   ORIGIN specifies the origin of the variable (makefile, command line
        -:14789:   or environment).
        -:14790:   If RECURSIVE is nonzero a flag is set in the variable saying
        -:14791:   that it should be recursively re-expanded.  */
        -:14792:
        -:14793:struct variable *
function define_variable_in_set called 105522 returned 100% blocks executed 100%
   105522:14794:define_variable_in_set (name, length, value, origin, recursive, set)
        -:14795:     char *name;
        -:14796:     unsigned int length;
        -:14797:     char *value;
        -:14798:     enum variable_origin origin;
        -:14799:     int recursive;
        -:14800:     struct variable_set *set;
        -:14801:{
        -:14802:  register unsigned int i;
        -:14803:  register unsigned int hashval;
        -:14804:  register struct variable *v;
        -:14805:
   105522:14806:  hashval = 0;
   980882:14807:  for (i = 0; i < length; ++i)
branch  0 taken 875360
branch  1 taken 105522 (fallthrough)
   875360:14808:    HASH (hashval, name[i]);
   105522:14809:  hashval %= set->buckets;
        -:14810:
   121725:14811:  for (v = set->table[hashval]; v != 0; v = v->next)
branch  0 taken 20570
branch  1 taken 101155 (fallthrough)
    20570:14812:    if (*v->name == *name
branch  0 taken 5138 (fallthrough)
branch  1 taken 15432
     5138:14813:	&& strneq (v->name + 1, name + 1, length - 1)
branch  0 taken 4367 (fallthrough)
branch  1 taken 771
     4367:14814:	&& v->name[length] == '\0')
branch  0 taken 4367 (fallthrough)
branch  1 taken 0
     4367:14815:      break;
        -:14816:
   105522:14817:  if (env_overrides && origin == o_env)
branch  0 taken 33280 (fallthrough)
branch  1 taken 72242
branch  2 taken 1664 (fallthrough)
branch  3 taken 31616
     1664:14818:    origin = o_env_override;
        -:14819:
   105522:14820:  if (v != 0)
branch  0 taken 4367 (fallthrough)
branch  1 taken 101155
        -:14821:    {
     4367:14822:      if (env_overrides && v->origin == o_env)
branch  0 taken 2176 (fallthrough)
branch  1 taken 2191
branch  2 taken 384 (fallthrough)
branch  3 taken 1792
        -:14823:	/* V came from in the environment.  Since it was defined
        -:14824:	   before the switches were parsed, it wasn't affected by -e.  */
      384:14825:	v->origin = o_env_override;
        -:14826:
        -:14827:      /* A variable of this name is already defined.
        -:14828:	 If the old definition is from a stronger source
        -:14829:	 than this one, don't redefine it.  */
     4367:14830:      if ((int) origin >= (int) v->origin)
branch  0 taken 3596 (fallthrough)
branch  1 taken 771
        -:14831:	{
     3596:14832:	  if (v->value != 0)
branch  0 taken 3596 (fallthrough)
branch  1 taken 0
     3596:14833:	    free (v->value);
     3596:14834:	  v->value = xstrdup (value);
call    0 returned 3596
     3596:14835:	  v->origin = origin;
     3596:14836:	  v->recursive = recursive;
        -:14837:	}
     4367:14838:      return v;
        -:14839:    }
        -:14840:
        -:14841:  /* Create a new variable definition and add it to the hash table.  */
        -:14842:
   101155:14843:  v = (struct variable *) xmalloc (sizeof (struct variable));
call    0 returned 101155
   101155:14844:  v->name = savestring (name, length);
call    0 returned 101155
   101155:14845:  v->value = xstrdup (value);
call    0 returned 101155
   101155:14846:  v->origin = origin;
   101155:14847:  v->recursive = recursive;
   101155:14848:  v->expanding = 0;
   101155:14849:  v->per_target = 0;
   101155:14850:  v->export = v_default;
   101155:14851:  v->next = set->table[hashval];
   101155:14852:  set->table[hashval] = v;
   101155:14853:  return v;
        -:14854:}
        -:14855:
        -:14856:/* Define a variable in the current variable set.  */
        -:14857:
        -:14858:struct variable *
function define_variable called 105522 returned 100% blocks executed 100%
   105522:14859:define_variable (name, length, value, origin, recursive)
        -:14860:     char *name;
        -:14861:     unsigned int length;
        -:14862:     char *value;
        -:14863:     enum variable_origin origin;
        -:14864:     int recursive;
        -:14865:{
   211044:14866:  return define_variable_in_set (name, length, value, origin, recursive,
   105522:14867:				 current_variable_set_list->set);
call    0 returned 105522
        -:14868:}
        -:14869:
        -:14870:/* Define a variable in FILE's variable set.  */
        -:14871:
        -:14872:struct variable *
function define_variable_for_file called 0 returned 0% blocks executed 0%
    #####:14873:define_variable_for_file (name, length, value, origin, recursive, file)
        -:14874:     char *name;
        -:14875:     unsigned int length;
        -:14876:     char *value;
        -:14877:     enum variable_origin origin;
        -:14878:     int recursive;
        -:14879:     struct file *file;
        -:14880:{
    #####:14881:  return define_variable_in_set (name, length, value, origin, recursive,
    #####:14882:				 file->variables->set);
call    0 never executed
        -:14883:}
        -:14884:
        -:14885:/* Lookup a variable whose name is a string starting at NAME
        -:14886:   and with LENGTH chars.  NAME need not be null-terminated.
        -:14887:   Returns address of the `struct variable' containing all info
        -:14888:   on the variable, or nil if no such variable is defined.  */
        -:14889:
        -:14890:struct variable *
function lookup_variable called 4629 returned 100% blocks executed 100%
     4629:14891:lookup_variable (name, length)
        -:14892:     char *name;
        -:14893:     unsigned int length;
        -:14894:{
        -:14895:  register struct variable_set_list *setlist;
        -:14896:
        -:14897:  register unsigned int i;
     4629:14898:  register unsigned int rawhash = 0;
        -:14899:
    40122:14900:  for (i = 0; i < length; ++i)
branch  0 taken 35493
branch  1 taken 4629 (fallthrough)
    35493:14901:    HASH (rawhash, name[i]);
        -:14902:
     4629:14903:  for (setlist = current_variable_set_list;
     7716:14904:       setlist != 0; setlist = setlist->next)
branch  0 taken 4629
branch  1 taken 3087 (fallthrough)
        -:14905:    {
     4629:14906:      register struct variable_set *set = setlist->set;
     4629:14907:      register unsigned int hashval = rawhash % set->buckets;
        -:14908:      register struct variable *v;
        -:14909:
     5400:14910:      for (v = set->table[hashval]; v != 0; v = v->next)
branch  0 taken 2313
branch  1 taken 3087 (fallthrough)
     2313:14911:	if (*v->name == *name
branch  0 taken 1542 (fallthrough)
branch  1 taken 771
     1542:14912:	    && strneq (v->name + 1, name + 1, length - 1)
branch  0 taken 1542 (fallthrough)
branch  1 taken 0
     1542:14913:	    && v->name[length] == 0)
branch  0 taken 1542 (fallthrough)
branch  1 taken 0
     1542:14914:	  return v;
        -:14915:    }
        -:14916:
     3087:14917:  return 0;
        -:14918:}
        -:14919:
        -:14920:/* Lookup a variable whose name is a string starting at NAME
        -:14921:   and with LENGTH chars in set SET.  NAME need not be null-terminated.
        -:14922:   Returns address of the `struct variable' containing all info
        -:14923:   on the variable, or nil if no such variable is defined.  */
        -:14924:
        -:14925:static struct variable *
function lookup_variable_in_set called 0 returned 0% blocks executed 0%
    #####:14926:lookup_variable_in_set (name, length, set)
        -:14927:     char *name;
        -:14928:     unsigned int length;
        -:14929:     struct variable_set *set;
        -:14930:{
        -:14931:  register unsigned int i;
    #####:14932:  register unsigned int hash = 0;
        -:14933:  register struct variable *v;
        -:14934:
    #####:14935:  for (i = 0; i < length; ++i)
branch  0 never executed
branch  1 never executed
    #####:14936:    HASH (hash, name[i]);
    #####:14937:  hash %= set->buckets;
        -:14938:
    #####:14939:  for (v = set->table[hash]; v != 0; v = v->next)
branch  0 never executed
branch  1 never executed
    #####:14940:    if (*v->name == *name
branch  0 never executed
branch  1 never executed
    #####:14941:        && strneq (v->name + 1, name + 1, length - 1)
branch  0 never executed
branch  1 never executed
    #####:14942:        && v->name[length] == 0)
branch  0 never executed
branch  1 never executed
    #####:14943:      return v;
        -:14944:
    #####:14945:  return 0;
        -:14946:}
        -:14947:
        -:14948:/* Initialize FILE's variable set list.  If FILE already has a variable set
        -:14949:   list, the topmost variable set is left intact, but the the rest of the
        -:14950:   chain is replaced with FILE->parent's setlist.  */
        -:14951:
        -:14952:void
function initialize_file_variables called 0 returned 0% blocks executed 0%
    #####:14953:initialize_file_variables (file)
        -:14954:     struct file *file;
        -:14955:{
    #####:14956:  register struct variable_set_list *l = file->variables;
    #####:14957:  if (l == 0)
branch  0 never executed
branch  1 never executed
        -:14958:    {
        -:14959:      l = (struct variable_set_list *)
    #####:14960:	xmalloc (sizeof (struct variable_set_list));
call    0 never executed
    #####:14961:      l->set = (struct variable_set *) xmalloc (sizeof (struct variable_set));
call    0 never executed
    #####:14962:      l->set->buckets = PERFILE_VARIABLE_BUCKETS;
    #####:14963:      l->set->table = (struct variable **)
    #####:14964:	xmalloc (l->set->buckets * sizeof (struct variable *));
call    0 never executed
    #####:14965:      bzero ((char *) l->set->table,
        -:14966:	     l->set->buckets * sizeof (struct variable *));
    #####:14967:      file->variables = l;
        -:14968:    }
        -:14969:
    #####:14970:  if (file->parent == 0)
branch  0 never executed
branch  1 never executed
    #####:14971:    l->next = &global_setlist;
        -:14972:  else
        -:14973:    {
    #####:14974:      if (file->parent->variables == 0)
branch  0 never executed
branch  1 never executed
    #####:14975:	initialize_file_variables (file->parent);
call    0 never executed
    #####:14976:      l->next = file->parent->variables;
        -:14977:    }
    #####:14978:}
        -:14979:
        -:14980:/* Pop the top set off the current variable set list,
        -:14981:   and free all its storage.  */
        -:14982:
        -:14983:void
function pop_variable_scope called 0 returned 0% blocks executed 0%
    #####:14984:pop_variable_scope ()
        -:14985:{
    #####:14986:  register struct variable_set_list *setlist = current_variable_set_list;
    #####:14987:  register struct variable_set *set = setlist->set;
        -:14988:  register unsigned int i;
        -:14989:
    #####:14990:  current_variable_set_list = setlist->next;
    #####:14991:  free ((char *) setlist);
        -:14992:
    #####:14993:  for (i = 0; i < set->buckets; ++i)
branch  0 never executed
branch  1 never executed
        -:14994:    {
    #####:14995:      register struct variable *next = set->table[i];
    #####:14996:      while (next != 0)
branch  0 never executed
branch  1 never executed
        -:14997:	{
    #####:14998:	  register struct variable *v = next;
    #####:14999:	  next = v->next;
        -:15000:
    #####:15001:	  free (v->name);
    #####:15002:	  if (v->value)
branch  0 never executed
branch  1 never executed
    #####:15003:	    free (v->value);
    #####:15004:	  free ((char *) v);
        -:15005:	}
        -:15006:    }
    #####:15007:  free ((char *) set->table);
    #####:15008:  free ((char *) set);
    #####:15009:}
        -:15010:
        -:15011:struct variable_set_list *
function create_new_variable_set called 0 returned 0% blocks executed 0%
    #####:15012:create_new_variable_set ()
        -:15013:{
        -:15014:  register struct variable_set_list *setlist;
        -:15015:  register struct variable_set *set;
        -:15016:
    #####:15017:  set = (struct variable_set *) xmalloc (sizeof (struct variable_set));
call    0 never executed
    #####:15018:  set->buckets = SMALL_SCOPE_VARIABLE_BUCKETS;
    #####:15019:  set->table = (struct variable **)
    #####:15020:    xmalloc (set->buckets * sizeof (struct variable *));
call    0 never executed
    #####:15021:  bzero ((char *) set->table, set->buckets * sizeof (struct variable *));
        -:15022:
        -:15023:  setlist = (struct variable_set_list *)
    #####:15024:    xmalloc (sizeof (struct variable_set_list));
call    0 never executed
    #####:15025:  setlist->set = set;
    #####:15026:  setlist->next = current_variable_set_list;
        -:15027:
    #####:15028:  return setlist;
        -:15029:}
        -:15030:
        -:15031:/* Create a new variable set and push it on the current setlist.  */
        -:15032:
        -:15033:struct variable_set_list *
function push_new_variable_scope called 0 returned 0% blocks executed 0%
    #####:15034:push_new_variable_scope ()
        -:15035:{
    #####:15036:  return (current_variable_set_list = create_new_variable_set());
call    0 never executed
        -:15037:}
        -:15038:
        -:15039:/* Merge SET1 into SET0, freeing unused storage in SET1.  */
        -:15040:
        -:15041:static void
function merge_variable_sets called 0 returned 0% blocks executed 0%
    #####:15042:merge_variable_sets (set0, set1)
        -:15043:     struct variable_set *set0, *set1;
        -:15044:{
        -:15045:  register unsigned int bucket1;
        -:15046:
    #####:15047:  for (bucket1 = 0; bucket1 < set1->buckets; ++bucket1)
branch  0 never executed
branch  1 never executed
        -:15048:    {
    #####:15049:      register struct variable *v1 = set1->table[bucket1];
    #####:15050:      while (v1 != 0)
branch  0 never executed
branch  1 never executed
        -:15051:	{
    #####:15052:	  struct variable *next = v1->next;
        -:15053:	  unsigned int bucket0;
        -:15054:	  register struct variable *v0;
        -:15055:
    #####:15056:	  if (set1->buckets >= set0->buckets)
branch  0 never executed
branch  1 never executed
    #####:15057:	    bucket0 = bucket1;
        -:15058:	  else
        -:15059:	    {
        -:15060:	      register char *n;
    #####:15061:	      bucket0 = 0;
    #####:15062:	      for (n = v1->name; *n != '\0'; ++n)
branch  0 never executed
branch  1 never executed
    #####:15063:		HASH (bucket0, *n);
        -:15064:	    }
    #####:15065:	  bucket0 %= set0->buckets;
        -:15066:
    #####:15067:	  for (v0 = set0->table[bucket0]; v0 != 0; v0 = v0->next)
branch  0 never executed
branch  1 never executed
    #####:15068:	    if (streq (v0->name, v1->name))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -:15069:	      break;
        -:15070:
    #####:15071:	  if (v0 == 0)
branch  0 never executed
branch  1 never executed
        -:15072:	    {
        -:15073:	      /* There is no variable in SET0 with the same name.  */
    #####:15074:	      v1->next = set0->table[bucket0];
    #####:15075:	      set0->table[bucket0] = v1;
        -:15076:	    }
        -:15077:	  else
        -:15078:	    {
        -:15079:	      /* The same variable exists in both sets.
        -:15080:		 SET0 takes precedence.  */
    #####:15081:	      free (v1->value);
    #####:15082:	      free ((char *) v1);
        -:15083:	    }
        -:15084:
    #####:15085:	  v1 = next;
        -:15086:	}
        -:15087:    }
    #####:15088:}
        -:15089:
        -:15090:/* Merge SETLIST1 into SETLIST0, freeing unused storage in SETLIST1.  */
        -:15091:
        -:15092:void
function merge_variable_set_lists called 0 returned 0% blocks executed 0%
    #####:15093:merge_variable_set_lists (setlist0, setlist1)
        -:15094:     struct variable_set_list **setlist0, *setlist1;
        -:15095:{
    #####:15096:  register struct variable_set_list *list0 = *setlist0;
    #####:15097:  struct variable_set_list *last0 = 0;
        -:15098:
    #####:15099:  while (setlist1 != 0 && list0 != 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:15100:    {
    #####:15101:      struct variable_set_list *next = setlist1;
    #####:15102:      setlist1 = setlist1->next;
        -:15103:
    #####:15104:      merge_variable_sets (list0->set, next->set);
call    0 never executed
        -:15105:
    #####:15106:      last0 = list0;
    #####:15107:      list0 = list0->next;
        -:15108:    }
        -:15109:
    #####:15110:  if (setlist1 != 0)
branch  0 never executed
branch  1 never executed
        -:15111:    {
    #####:15112:      if (last0 == 0)
branch  0 never executed
branch  1 never executed
    #####:15113:	*setlist0 = setlist1;
        -:15114:      else
    #####:15115:	last0->next = setlist1;
        -:15116:    }
    #####:15117:}
        -:15118:
        -:15119:/* Define the automatic variables, and record the addresses
        -:15120:   of their structures so we can change their values quickly.  */
        -:15121:
        -:15122:void
function define_automatic_variables called 771 returned 100% blocks executed 88%
      771:15123:define_automatic_variables ()
        -:15124:{
        -:15125:#ifdef WINDOWS32
        -:15126:  extern char* default_shell;
        -:15127:#else
        -:15128:  extern char default_shell[];
        -:15129:#endif
        -:15130:  register struct variable *v;
        -:15131:  char buf[200];
        -:15132:
      771:15133:  sprintf (buf, "%u", makelevel);
      771:15134:  (void) define_variable ("MAKELEVEL", 9, buf, o_env, 0);
call    0 returned 771
        -:15135:
    1542*:15136:  sprintf (buf, "%s%s%s",
        -:15137:	   version_string,
     771*:15138:	   (remote_description == 0 || remote_description[0] == '\0')
branch  0 taken 0 (fallthrough)
branch  1 taken 771
branch  2 never executed
branch  3 never executed
        -:15139:	   ? "" : "-",
     771*:15140:	   (remote_description == 0 || remote_description[0] == '\0')
branch  0 taken 0 (fallthrough)
branch  1 taken 771
branch  2 never executed
branch  3 never executed
        -:15141:	   ? "" : remote_description);
      771:15142:  (void) define_variable ("MAKE_VERSION", 12, buf, o_default, 0);
call    0 returned 771
        -:15143:
        -:15144:#ifdef  __MSDOS__
        -:15145:  /* Allow to specify a special shell just for Make,
        -:15146:     and use $COMSPEC as the default $SHELL when appropriate.  */
        -:15147:  {
        -:15148:    static char shell_str[] = "SHELL";
        -:15149:    const int shlen = sizeof (shell_str) - 1;
        -:15150:    struct variable *mshp = lookup_variable ("MAKESHELL", 9);
        -:15151:    struct variable *comp = lookup_variable ("COMSPEC", 7);
        -:15152:
        -:15153:    /* Make $MAKESHELL override $SHELL even if -e is in effect.  */
        -:15154:    if (mshp)
        -:15155:      (void) define_variable (shell_str, shlen,
        -:15156:			      mshp->value, o_env_override, 0);
        -:15157:    else if (comp)
        -:15158:      {
        -:15159:	/* $COMSPEC shouldn't override $SHELL.  */
        -:15160:	struct variable *shp = lookup_variable (shell_str, shlen);
        -:15161:
        -:15162:	if (!shp)
        -:15163:	  (void) define_variable (shell_str, shlen, comp->value, o_env, 0);
        -:15164:      }
        -:15165:  }
        -:15166:#endif
        -:15167:
        -:15168:  /* This won't override any definition, but it
        -:15169:     will provide one if there isn't one there.  */
      771:15170:  v = define_variable ("SHELL", 5, default_shell, o_default, 0);
call    0 returned 771
      771:15171:  v->export = v_export;		/* Always export SHELL.  */
        -:15172:
        -:15173:  /* On MSDOS we do use SHELL from environment, since
        -:15174:     it isn't a standard environment variable on MSDOS,
        -:15175:     so whoever sets it, does that on purpose.  */
        -:15176:#ifndef __MSDOS__
        -:15177:  /* Don't let SHELL come from the environment.  */
      771:15178:  if (*v->value == '\0' || v->origin == o_env || v->origin == o_env_override)
branch  0 taken 771 (fallthrough)
branch  1 taken 0
branch  2 taken 384 (fallthrough)
branch  3 taken 387
branch  4 taken 384 (fallthrough)
branch  5 taken 0
        -:15179:    {
      771:15180:      free (v->value);
      771:15181:      v->origin = o_file;
      771:15182:      v->value = xstrdup (default_shell);
call    0 returned 771
        -:15183:    }
        -:15184:#endif
        -:15185:
        -:15186:  /* Make sure MAKEFILES gets exported if it is set.  */
      771:15187:  v = define_variable ("MAKEFILES", 9, "", o_default, 0);
call    0 returned 771
      771:15188:  v->export = v_ifset;
        -:15189:
        -:15190:  /* Define the magic D and F variables in terms of
        -:15191:     the automatic variables they are variations of.  */
        -:15192:
      771:15193:  define_variable ("@D", 2, "$(patsubst %/,%,$(dir $@))", o_automatic, 1);
call    0 returned 771
      771:15194:  define_variable ("%D", 2, "$(patsubst %/,%,$(dir $%))", o_automatic, 1);
call    0 returned 771
      771:15195:  define_variable ("*D", 2, "$(patsubst %/,%,$(dir $*))", o_automatic, 1);
call    0 returned 771
      771:15196:  define_variable ("<D", 2, "$(patsubst %/,%,$(dir $<))", o_automatic, 1);
call    0 returned 771
      771:15197:  define_variable ("?D", 2, "$(patsubst %/,%,$(dir $?))", o_automatic, 1);
call    0 returned 771
      771:15198:  define_variable ("^D", 2, "$(patsubst %/,%,$(dir $^))", o_automatic, 1);
call    0 returned 771
      771:15199:  define_variable ("+D", 2, "$(patsubst %/,%,$(dir $+))", o_automatic, 1);
call    0 returned 771
      771:15200:  define_variable ("@F", 2, "$(notdir $@)", o_automatic, 1);
call    0 returned 771
      771:15201:  define_variable ("%F", 2, "$(notdir $%)", o_automatic, 1);
call    0 returned 771
      771:15202:  define_variable ("*F", 2, "$(notdir $*)", o_automatic, 1);
call    0 returned 771
      771:15203:  define_variable ("<F", 2, "$(notdir $<)", o_automatic, 1);
call    0 returned 771
      771:15204:  define_variable ("?F", 2, "$(notdir $?)", o_automatic, 1);
call    0 returned 771
      771:15205:  define_variable ("^F", 2, "$(notdir $^)", o_automatic, 1);
call    0 returned 771
      771:15206:  define_variable ("+F", 2, "$(notdir $+)", o_automatic, 1);
call    0 returned 771
      771:15207:}
        -:15208:
        -:15209:int export_all_variables;
        -:15210:
        -:15211:/* Create a new environment for FILE's commands.
        -:15212:   If FILE is nil, this is for the `shell' function.
        -:15213:   The child's MAKELEVEL variable is incremented.  */
        -:15214:
        -:15215:char **
function target_environment called 0 returned 0% blocks executed 0%
    #####:15216:target_environment (file)
        -:15217:     struct file *file;
        -:15218:{
        -:15219:  struct variable_set_list *set_list;
        -:15220:  register struct variable_set_list *s;
        -:15221:  struct variable_bucket
        -:15222:    {
        -:15223:      struct variable_bucket *next;
        -:15224:      struct variable *variable;
        -:15225:    };
        -:15226:  struct variable_bucket **table;
        -:15227:  unsigned int buckets;
        -:15228:  register unsigned int i;
        -:15229:  register unsigned nvariables;
        -:15230:  char **result;
        -:15231:  unsigned int mklev_hash;
        -:15232:
    #####:15233:  if (file == 0)
branch  0 never executed
branch  1 never executed
    #####:15234:    set_list = current_variable_set_list;
        -:15235:  else
    #####:15236:    set_list = file->variables;
        -:15237:
        -:15238:  /* Find the lowest number of buckets in any set in the list.  */
    #####:15239:  s = set_list;
    #####:15240:  buckets = s->set->buckets;
    #####:15241:  for (s = s->next; s != 0; s = s->next)
branch  0 never executed
branch  1 never executed
    #####:15242:    if (s->set->buckets < buckets)
branch  0 never executed
branch  1 never executed
    #####:15243:      buckets = s->set->buckets;
        -:15244:
        -:15245:  /* Find the hash value of the bucket `MAKELEVEL' will fall into.  */
        -:15246:  {
    #####:15247:    char *p = "MAKELEVEL";
    #####:15248:    mklev_hash = 0;
    #####:15249:    while (*p != '\0')
branch  0 never executed
branch  1 never executed
    #####:15250:      HASH (mklev_hash, *p++);
        -:15251:  }
        -:15252:
        -:15253:  /* Temporarily allocate a table with that many buckets.  */
        -:15254:  table = (struct variable_bucket **)
    #####:15255:    alloca (buckets * sizeof (struct variable_bucket *));
    #####:15256:  bzero ((char *) table, buckets * sizeof (struct variable_bucket *));
        -:15257:
        -:15258:  /* Run through all the variable sets in the list,
        -:15259:     accumulating variables in TABLE.  */
    #####:15260:  nvariables = 0;
    #####:15261:  for (s = set_list; s != 0; s = s->next)
branch  0 never executed
branch  1 never executed
        -:15262:    {
    #####:15263:      register struct variable_set *set = s->set;
    #####:15264:      for (i = 0; i < set->buckets; ++i)
branch  0 never executed
branch  1 never executed
        -:15265:	{
        -:15266:	  register struct variable *v;
    #####:15267:	  for (v = set->table[i]; v != 0; v = v->next)
branch  0 never executed
branch  1 never executed
        -:15268:	    {
    #####:15269:	      unsigned int j = i % buckets;
        -:15270:	      register struct variable_bucket *ov;
    #####:15271:	      register char *p = v->name;
        -:15272:
    #####:15273:	      if (i == mklev_hash % set->buckets
branch  0 never executed
branch  1 never executed
    #####:15274:		  && streq (v->name, "MAKELEVEL"))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -:15275:		/* Don't include MAKELEVEL because it will be
        -:15276:		   added specially at the end.  */
    #####:15277:		continue;
        -:15278:
        -:15279:              /* If this is a per-target variable and it hasn't been touched
        -:15280:                 already then look up the global version and take its export
        -:15281:                 value.  */
    #####:15282:              if (v->per_target && v->export == v_default)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:15283:                {
        -:15284:                  struct variable *gv;
        -:15285:
    #####:15286:                  gv = lookup_variable_in_set(v->name, strlen(v->name),
call    0 never executed
        -:15287:                                              &global_variable_set);
    #####:15288:                  if (gv)
branch  0 never executed
branch  1 never executed
    #####:15289:                    v->export = gv->export;
        -:15290:                }
        -:15291:
    #####:15292:	      switch (v->export)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:15293:		{
    #####:15294:		case v_default:
    #####:15295:		  if (v->origin == o_default || v->origin == o_automatic)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:15296:		    /* Only export default variables by explicit request.  */
    #####:15297:		    continue;
        -:15298:
    #####:15299:		  if (! export_all_variables
branch  0 never executed
branch  1 never executed
    #####:15300:		      && v->origin != o_command
branch  0 never executed
branch  1 never executed
    #####:15301:		      && v->origin != o_env && v->origin != o_env_override)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:15302:		    continue;
        -:15303:
    #####:15304:		  if (*p != '_' && (*p < 'A' || *p > 'Z')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:15305:		      && (*p < 'a' || *p > 'z'))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:15306:		    continue;
    #####:15307:		  for (++p; *p != '\0'; ++p)
branch  0 never executed
branch  1 never executed
    #####:15308:		    if (*p != '_' && (*p < 'a' || *p > 'z')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:15309:			&& (*p < 'A' || *p > 'Z') && (*p < '0' || *p > '9'))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:15310:		      continue;
    #####:15311:		  if (*p != '\0')
branch  0 never executed
branch  1 never executed
    #####:15312:		    continue;
    #####:15313:		  break;
        -:15314:
    #####:15315:                case v_export:
    #####:15316:                  break;
        -:15317:
    #####:15318:                case v_noexport:
    #####:15319:                  continue;
        -:15320:
    #####:15321:		case v_ifset:
    #####:15322:		  if (v->origin == o_default)
branch  0 never executed
branch  1 never executed
    #####:15323:		    continue;
    #####:15324:		  break;
        -:15325:		}
        -:15326:
        -:15327:              /* If this was from a different-sized hash table, then
        -:15328:                 recalculate the bucket it goes in.  */
    #####:15329:              if (set->buckets != buckets)
branch  0 never executed
branch  1 never executed
        -:15330:                {
        -:15331:                  register char *np;
        -:15332:
    #####:15333:                  j = 0;
    #####:15334:                  for (np = v->name; *np != '\0'; ++np)
branch  0 never executed
branch  1 never executed
    #####:15335:                    HASH (j, *np);
    #####:15336:                  j %= buckets;
        -:15337:                }
        -:15338:
    #####:15339:	      for (ov = table[j]; ov != 0; ov = ov->next)
branch  0 never executed
branch  1 never executed
    #####:15340:		if (streq (v->name, ov->variable->name))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -:15341:		  break;
        -:15342:
    #####:15343:	      if (ov == 0)
branch  0 never executed
branch  1 never executed
        -:15344:		{
        -:15345:		  register struct variable_bucket *entry;
        -:15346:		  entry = (struct variable_bucket *)
    #####:15347:		    alloca (sizeof (struct variable_bucket));
    #####:15348:		  entry->next = table[j];
    #####:15349:		  entry->variable = v;
    #####:15350:		  table[j] = entry;
    #####:15351:		  ++nvariables;
        -:15352:		}
        -:15353:	    }
        -:15354:	}
        -:15355:    }
        -:15356:
    #####:15357:  result = (char **) xmalloc ((nvariables + 2) * sizeof (char *));
call    0 never executed
    #####:15358:  nvariables = 0;
    #####:15359:  for (i = 0; i < buckets; ++i)
branch  0 never executed
branch  1 never executed
        -:15360:    {
        -:15361:      register struct variable_bucket *b;
    #####:15362:      for (b = table[i]; b != 0; b = b->next)
branch  0 never executed
branch  1 never executed
        -:15363:	{
    #####:15364:	  register struct variable *v = b->variable;
        -:15365:
        -:15366:	  /* If V is recursively expanded and didn't come from the environment,
        -:15367:	     expand its value.  If it came from the environment, it should
        -:15368:	     go back into the environment unchanged.  */
    #####:15369:	  if (v->recursive
branch  0 never executed
branch  1 never executed
    #####:15370:	      && v->origin != o_env && v->origin != o_env_override)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:15371:	    {
    #####:15372:	      char *value = recursively_expand (v);
call    0 never executed
        -:15373:#ifdef WINDOWS32
        -:15374:              if (strcmp(v->name, "Path") == 0 ||
        -:15375:                  strcmp(v->name, "PATH") == 0)
        -:15376:                convert_Path_to_windows32(value, ';');
        -:15377:#endif
    #####:15378:	      result[nvariables++] = concat (v->name, "=", value);
call    0 never executed
    #####:15379:	      free (value);
        -:15380:	    }
        -:15381:	  else
        -:15382:#ifdef WINDOWS32
        -:15383:          {
        -:15384:            if (strcmp(v->name, "Path") == 0 ||
        -:15385:                strcmp(v->name, "PATH") == 0)
        -:15386:              convert_Path_to_windows32(v->value, ';');
        -:15387:            result[nvariables++] = concat (v->name, "=", v->value);
        -:15388:          }
        -:15389:#else
    #####:15390:	    result[nvariables++] = concat (v->name, "=", v->value);
call    0 never executed
        -:15391:#endif
        -:15392:	}
        -:15393:    }
    #####:15394:  result[nvariables] = (char *) xmalloc (100);
call    0 never executed
    #####:15395:  (void) sprintf (result[nvariables], "MAKELEVEL=%u", makelevel + 1);
    #####:15396:  result[++nvariables] = 0;
        -:15397:
    #####:15398:  return result;
        -:15399:}
        -:15400:
        -:15401:/* Try to interpret LINE (a null-terminated string) as a variable definition.
        -:15402:
        -:15403:   ORIGIN may be o_file, o_override, o_env, o_env_override,
        -:15404:   or o_command specifying that the variable definition comes
        -:15405:   from a makefile, an override directive, the environment with
        -:15406:   or without the -e switch, or the command line.
        -:15407:
        -:15408:   See the comments for parse_variable_definition().
        -:15409:
        -:15410:   If LINE was recognized as a variable definition, a pointer to its `struct
        -:15411:   variable' is returned.  If LINE is not a variable definition, NULL is
        -:15412:   returned.  */
        -:15413:
        -:15414:struct variable *
function try_variable_definition called 0 returned 0% blocks executed 0%
    #####:15415:try_variable_definition (flocp, line, origin)
        -:15416:     const struct floc *flocp;
        -:15417:     char *line;
        -:15418:     enum variable_origin origin;
        -:15419:{
        -:15420:  register int c;
    #####:15421:  register char *p = line;
        -:15422:  register char *beg;
        -:15423:  register char *end;
        -:15424:  enum { f_bogus,
    #####:15425:         f_simple, f_recursive, f_append, f_conditional } flavor = f_bogus;
    #####:15426:  char *name, *expanded_name, *value, *alloc_value=NULL;
        -:15427:  struct variable *v;
        -:15428:
        -:15429:  while (1)
        -:15430:    {
    #####:15431:      c = *p++;
    #####:15432:      if (c == '\0' || c == '#')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:15433:	return 0;
    #####:15434:      if (c == '=')
branch  0 never executed
branch  1 never executed
        -:15435:	{
    #####:15436:	  end = p - 1;
    #####:15437:	  flavor = f_recursive;
    #####:15438:	  break;
        -:15439:	}
    #####:15440:      else if (c == ':')
branch  0 never executed
branch  1 never executed
    #####:15441:	if (*p == '=')
branch  0 never executed
branch  1 never executed
        -:15442:	  {
    #####:15443:	    end = p++ - 1;
    #####:15444:	    flavor = f_simple;
    #####:15445:	    break;
        -:15446:	  }
        -:15447:	else
        -:15448:	  /* A colon other than := is a rule line, not a variable defn.  */
    #####:15449:	  return 0;
    #####:15450:      else if (c == '+' && *p == '=')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:15451:	{
    #####:15452:	  end = p++ - 1;
    #####:15453:	  flavor = f_append;
    #####:15454:	  break;
        -:15455:	}
    #####:15456:      else if (c == '?' && *p == '=')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:15457:        {
    #####:15458:          end = p++ - 1;
    #####:15459:          flavor = f_conditional;
    #####:15460:          break;
        -:15461:        }
    #####:15462:      else if (c == '$')
branch  0 never executed
branch  1 never executed
        -:15463:	{
        -:15464:	  /* This might begin a variable expansion reference.  Make sure we
        -:15465:	     don't misrecognize chars inside the reference as =, := or +=.  */
        -:15466:	  char closeparen;
        -:15467:	  int count;
    #####:15468:	  c = *p++;
    #####:15469:	  if (c == '(')
branch  0 never executed
branch  1 never executed
    #####:15470:	    closeparen = ')';
    #####:15471:	  else if (c == '{')
branch  0 never executed
branch  1 never executed
    #####:15472:	    closeparen = '}';
        -:15473:	  else
    #####:15474:	    continue;		/* Nope.  */
        -:15475:
        -:15476:	  /* P now points past the opening paren or brace.
        -:15477:	     Count parens or braces until it is matched.  */
    #####:15478:	  count = 0;
    #####:15479:	  for (; *p != '\0'; ++p)
branch  0 never executed
branch  1 never executed
        -:15480:	    {
    #####:15481:	      if (*p == c)
branch  0 never executed
branch  1 never executed
    #####:15482:		++count;
    #####:15483:	      else if (*p == closeparen && --count < 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:15484:		{
    #####:15485:		  ++p;
    #####:15486:		  break;
        -:15487:		}
        -:15488:	    }
        -:15489:	}
        -:15490:    }
        -:15491:
    #####:15492:  beg = next_token (line);
call    0 never executed
    #####:15493:  while (end > beg && isblank (end[-1]))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:15494:    --end;
    #####:15495:  p = next_token (p);
call    0 never executed
        -:15496:
        -:15497:  /* Expand the name, so "$(foo)bar = baz" works.  */
    #####:15498:  name = (char *) alloca (end - beg + 1);
    #####:15499:  bcopy (beg, name, end - beg);
    #####:15500:  name[end - beg] = '\0';
    #####:15501:  expanded_name = allocated_variable_expand (name);
call    0 never executed
        -:15502:
    #####:15503:  if (expanded_name[0] == '\0')
branch  0 never executed
branch  1 never executed
    #####:15504:    fatal (flocp, _("empty variable name"));
call    0 never executed
        -:15505:
        -:15506:  /* Calculate the variable's new value in VALUE.  */
        -:15507:
    #####:15508:  switch (flavor)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:15509:    {
    #####:15510:    case f_bogus:
        -:15511:      /* Should not be possible.  */
    #####:15512:      abort ();
call    0 never executed
    #####:15513:    case f_simple:
        -:15514:      /* A simple variable definition "var := value".  Expand the value.
        -:15515:         We have to allocate memory since otherwise it'll clobber the
        -:15516:	 variable buffer, and we may still need that if we're looking at a
        -:15517:         target-specific variable.  */
    #####:15518:      value = alloc_value = allocated_variable_expand (p);
call    0 never executed
    #####:15519:      break;
    #####:15520:    case f_conditional:
        -:15521:      /* A conditional variable definition "var ?= value".
        -:15522:         The value is set IFF the variable is not defined yet. */
    #####:15523:      v = lookup_variable(expanded_name, strlen(expanded_name));
call    0 never executed
    #####:15524:      if (v)
branch  0 never executed
branch  1 never executed
        -:15525:        {
    #####:15526:          free(expanded_name);
    #####:15527:          return v;
        -:15528:        }
    #####:15529:      flavor = f_recursive;
        -:15530:      /* FALLTHROUGH */
    #####:15531:    case f_recursive:
        -:15532:      /* A recursive variable definition "var = value".
        -:15533:	 The value is used verbatim.  */
    #####:15534:      value = p;
    #####:15535:      break;
    #####:15536:    case f_append:
        -:15537:      /* An appending variable definition "var += value".
        -:15538:	 Extract the old value and append the new one.  */
    #####:15539:      v = lookup_variable (expanded_name, strlen (expanded_name));
call    0 never executed
    #####:15540:      if (v == 0)
branch  0 never executed
branch  1 never executed
        -:15541:	{
        -:15542:	  /* There was no old value.
        -:15543:	     This becomes a normal recursive definition.  */
    #####:15544:	  value = p;
    #####:15545:	  flavor = f_recursive;
        -:15546:	}
        -:15547:      else
        -:15548:	{
        -:15549:	  /* Paste the old and new values together in VALUE.  */
        -:15550:
        -:15551:	  unsigned int oldlen, newlen;
        -:15552:
    #####:15553:	  if (v->recursive)
branch  0 never executed
branch  1 never executed
        -:15554:	    /* The previous definition of the variable was recursive.
        -:15555:	       The new value comes from the unexpanded old and new values.  */
    #####:15556:	    flavor = f_recursive;
        -:15557:	  else
        -:15558:	    /* The previous definition of the variable was simple.
        -:15559:	       The new value comes from the old value, which was expanded
        -:15560:	       when it was set; and from the expanded new value.  Allocate
        -:15561:               memory for the expansion as we may still need the rest of the
        -:15562:               buffer if we're looking at a target-specific variable.  */
    #####:15563:	    p = alloc_value = allocated_variable_expand (p);
call    0 never executed
        -:15564:
    #####:15565:	  oldlen = strlen (v->value);
    #####:15566:	  newlen = strlen (p);
    #####:15567:	  value = (char *) alloca (oldlen + 1 + newlen + 1);
    #####:15568:	  bcopy (v->value, value, oldlen);
    #####:15569:	  value[oldlen] = ' ';
    #####:15570:	  bcopy (p, &value[oldlen + 1], newlen + 1);
        -:15571:	}
        -:15572:    }
        -:15573:
        -:15574:#ifdef __MSDOS__
        -:15575:  /* Many Unix Makefiles include a line saying "SHELL=/bin/sh", but
        -:15576:     non-Unix systems don't conform to this default configuration (in
        -:15577:     fact, most of them don't even have `/bin').  On the other hand,
        -:15578:     $SHELL in the environment, if set, points to the real pathname of
        -:15579:     the shell.
        -:15580:     Therefore, we generally won't let lines like "SHELL=/bin/sh" from
        -:15581:     the Makefile override $SHELL from the environment.  But first, we
        -:15582:     look for the basename of the shell in the directory where SHELL=
        -:15583:     points, and along the $PATH; if it is found in any of these places,
        -:15584:     we define $SHELL to be the actual pathname of the shell.  Thus, if
        -:15585:     you have bash.exe installed as d:/unix/bash.exe, and d:/unix is on
        -:15586:     your $PATH, then SHELL=/usr/local/bin/bash will have the effect of
        -:15587:     defining SHELL to be "d:/unix/bash.exe".  */
        -:15588:  if ((origin == o_file || origin == o_override)
        -:15589:      && strcmp (expanded_name, "SHELL") == 0)
        -:15590:    {
        -:15591:      char shellpath[PATH_MAX];
        -:15592:      extern char * __dosexec_find_on_path (const char *, char *[], char *);
        -:15593:
        -:15594:      /* See if we can find "/bin/sh.exe", "/bin/sh.com", etc.  */
        -:15595:      if (__dosexec_find_on_path (value, (char **)0, shellpath))
        -:15596:	{
        -:15597:	  char *p;
        -:15598:
        -:15599:	  for (p = shellpath; *p; p++)
        -:15600:	    {
        -:15601:	      if (*p == '\\')
        -:15602:		*p = '/';
        -:15603:	    }
        -:15604:	  v = define_variable (expanded_name, strlen (expanded_name),
        -:15605:			       shellpath, origin, flavor == f_recursive);
        -:15606:	}
        -:15607:      else
        -:15608:	{
        -:15609:	  char *shellbase, *bslash;
        -:15610:	  struct variable *pathv = lookup_variable ("PATH", 4);
        -:15611:	  char *path_string;
        -:15612:	  char *fake_env[2];
        -:15613:	  size_t pathlen = 0;
        -:15614:
        -:15615:	  shellbase = rindex (value, '/');
        -:15616:	  bslash = rindex (value, '\\');
        -:15617:	  if (!shellbase || bslash > shellbase)
        -:15618:	    shellbase = bslash;
        -:15619:	  if (!shellbase && value[1] == ':')
        -:15620:	    shellbase = value + 1;
        -:15621:	  if (shellbase)
        -:15622:	    shellbase++;
        -:15623:	  else
        -:15624:	    shellbase = value;
        -:15625:
        -:15626:	  /* Search for the basename of the shell (with standard
        -:15627:	     executable extensions) along the $PATH.  */
        -:15628:	  if (pathv)
        -:15629:	    pathlen = strlen (pathv->value);
        -:15630:	  path_string = (char *)xmalloc (5 + pathlen + 2 + 1);
        -:15631:	  /* On MSDOS, current directory is considered as part of $PATH.  */
        -:15632:	  sprintf (path_string, "PATH=.;%s", pathv ? pathv->value : "");
        -:15633:	  fake_env[0] = path_string;
        -:15634:	  fake_env[1] = (char *)0;
        -:15635:	  if (__dosexec_find_on_path (shellbase, fake_env, shellpath))
        -:15636:	    {
        -:15637:	      char *p;
        -:15638:
        -:15639:	      for (p = shellpath; *p; p++)
        -:15640:		{
        -:15641:		  if (*p == '\\')
        -:15642:		    *p = '/';
        -:15643:		}
        -:15644:	      v = define_variable (expanded_name, strlen (expanded_name),
        -:15645:				   shellpath, origin, flavor == f_recursive);
        -:15646:	    }
        -:15647:	  else
        -:15648:	    v = lookup_variable (expanded_name, strlen (expanded_name));
        -:15649:
        -:15650:	  free (path_string);
        -:15651:	}
        -:15652:    }
        -:15653:  else
        -:15654:#endif /* __MSDOS__ */
        -:15655:#ifdef WINDOWS32
        -:15656:  if ((origin == o_file || origin == o_override)
        -:15657:      && strcmp (expanded_name, "SHELL") == 0) {
        -:15658:    extern char* default_shell;
        -:15659:
        -:15660:    /*
        -:15661:     * Call shell locator function. If it returns TRUE, then
        -:15662:	 * set no_default_sh_exe to indicate sh was found and
        -:15663:     * set new value for SHELL variable.
        -:15664:	 */
        -:15665:    if (find_and_set_default_shell(value)) {
        -:15666:       v = define_variable (expanded_name, strlen (expanded_name),
        -:15667:                            default_shell, origin, flavor == f_recursive);
        -:15668:       no_default_sh_exe = 0;
        -:15669:    }
        -:15670:  } else
        -:15671:#endif
        -:15672:
    #####:15673:  v = define_variable (expanded_name, strlen (expanded_name),
call    0 never executed
        -:15674:		       value, origin, flavor == f_recursive);
        -:15675:
    #####:15676:  if (alloc_value)
branch  0 never executed
branch  1 never executed
    #####:15677:    free (alloc_value);
    #####:15678:  free (expanded_name);
        -:15679:
    #####:15680:  return v;
        -:15681:}
        -:15682:
        -:15683:/* Print information for variable V, prefixing it with PREFIX.  */
        -:15684:
        -:15685:static void
function print_variable called 50304 returned 100% blocks executed 78%
    50304:15686:print_variable (v, prefix)
        -:15687:     register struct variable *v;
        -:15688:     char *prefix;
        -:15689:{
        -:15690:  const char *origin;
        -:15691:
    50304:15692:  switch (v->origin)
branch  0 taken 24576
branch  1 taken 19200
branch  2 taken 768
branch  3 taken 384
branch  4 taken 0
branch  5 taken 0
branch  6 taken 5376
branch  7 taken 0
        -:15693:    {
    24576:15694:    case o_default:
    24576:15695:      origin = "default";
    24576:15696:      break;
    19200:15697:    case o_env:
    19200:15698:      origin = "environment";
    19200:15699:      break;
      768:15700:    case o_file:
      768:15701:      origin = "makefile";
      768:15702:      break;
      384:15703:    case o_env_override:
      384:15704:      origin = "environment under -e";
      384:15705:      break;
    #####:15706:    case o_command:
    #####:15707:      origin = "command line";
    #####:15708:      break;
    #####:15709:    case o_override:
    #####:15710:      origin = "`override' directive";
    #####:15711:      break;
     5376:15712:    case o_automatic:
     5376:15713:      origin = "automatic";
     5376:15714:      break;
    #####:15715:    case o_invalid:
        -:15716:    default:
    #####:15717:      abort ();
call    0 never executed
        -:15718:    }
    50304:15719:  printf ("# %s\n", origin);
call    0 returned 50304
        -:15720:
    50304:15721:  fputs (prefix, stdout);
call    0 returned 50304
        -:15722:
        -:15723:  /* Is this a `define'?  */
    50304:15724:  if (v->recursive && index (v->value, '\n') != 0)
branch  0 taken 48000 (fallthrough)
branch  1 taken 2304
branch  2 taken 0 (fallthrough)
branch  3 taken 48000
    #####:15725:    printf ("define %s\n%s\nendef\n", v->name, v->value);
call    0 never executed
        -:15726:  else
        -:15727:    {
        -:15728:      register char *p;
        -:15729:
    50304:15730:      printf ("%s %s= ", v->name, v->recursive ? "" : ":");
branch  0 taken 48000 (fallthrough)
branch  1 taken 2304
call    2 returned 50304
        -:15731:
        -:15732:      /* Check if the value is just whitespace.  */
    50304:15733:      p = next_token (v->value);
call    0 returned 50304
   50304*:15734:      if (p != v->value && *p == '\0')
branch  0 taken 0 (fallthrough)
branch  1 taken 50304
branch  2 never executed
branch  3 never executed
        -:15735:	/* All whitespace.  */
    #####:15736:	printf ("$(subst ,,%s)", v->value);
call    0 never executed
    50304:15737:      else if (v->recursive)
branch  0 taken 48000 (fallthrough)
branch  1 taken 2304
    48000:15738:	fputs (v->value, stdout);
call    0 returned 48000
        -:15739:      else
        -:15740:	/* Double up dollar signs.  */
    94848:15741:	for (p = v->value; *p != '\0'; ++p)
branch  0 taken 92544
branch  1 taken 2304 (fallthrough)
        -:15742:	  {
    92544:15743:	    if (*p == '$')
branch  0 taken 0 (fallthrough)
branch  1 taken 92544
    #####:15744:	      putchar ('$');
call    0 never executed
    92544:15745:	    putchar (*p);
call    0 returned 92544
        -:15746:	  }
    50304:15747:      putchar ('\n');
call    0 returned 50304
        -:15748:    }
    50304:15749:}
        -:15750:
        -:15751:
        -:15752:/* Print all the variables in SET.  PREFIX is printed before
        -:15753:   the actual variable definitions (everything else is comments).  */
        -:15754:
        -:15755:void
function print_variable_set called 384 returned 100% blocks executed 93%
      384:15756:print_variable_set (set, prefix)
        -:15757:     register struct variable_set *set;
        -:15758:     char *prefix;
        -:15759:{
        -:15760:  register unsigned int i, nvariables, per_bucket;
        -:15761:  register struct variable *v;
        -:15762:
      384:15763:  per_bucket = nvariables = 0;
   201216:15764:  for (i = 0; i < set->buckets; ++i)
branch  0 taken 200832
branch  1 taken 384 (fallthrough)
        -:15765:    {
   200832:15766:      register unsigned int this_bucket = 0;
        -:15767:
   251136:15768:      for (v = set->table[i]; v != 0; v = v->next)
branch  0 taken 50304
branch  1 taken 200832 (fallthrough)
        -:15769:	{
    50304:15770:	  ++this_bucket;
    50304:15771:	  print_variable (v, prefix);
call    0 returned 50304
        -:15772:	}
        -:15773:
   200832:15774:      nvariables += this_bucket;
   200832:15775:      if (this_bucket > per_bucket)
branch  0 taken 768 (fallthrough)
branch  1 taken 200064
      768:15776:	per_bucket = this_bucket;
        -:15777:    }
        -:15778:
      384:15779:  if (nvariables == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 384
    #####:15780:    puts (_("# No variables."));
call    0 never executed
        -:15781:  else
        -:15782:    {
      384:15783:      printf (_("# %u variables in %u hash buckets.\n"),
call    0 returned 384
        -:15784:	      nvariables, set->buckets);
        -:15785:#ifndef	NO_FLOAT
      384:15786:      printf (_("# average of %.1f variables per bucket, \
        -:15787:max %u in one bucket.\n"),
      384:15788:	      (double) nvariables / (double) set->buckets,
call    0 returned 384
        -:15789:	      per_bucket);
        -:15790:#else
        -:15791:      {
        -:15792:	int f = (nvariables * 1000 + 5) / set->buckets;
        -:15793:	printf (_("# average of %d.%d variables per bucket, \
        -:15794:max %u in one bucket.\n"),
        -:15795:	      f/10, f%10,
        -:15796:	      per_bucket);
        -:15797:      }
        -:15798:#endif
        -:15799:    }
      384:15800:}
        -:15801:
        -:15802:
        -:15803:/* Print the data base of variables.  */
        -:15804:
        -:15805:void
function print_variable_data_base called 384 returned 100% blocks executed 100%
      384:15806:print_variable_data_base ()
        -:15807:{
      384:15808:  puts (_("\n# Variables\n"));
call    0 returned 384
        -:15809:
      384:15810:  print_variable_set (&global_variable_set, "");
call    0 returned 384
      384:15811:}
        -:15812:
        -:15813:
        -:15814:/* Print all the local variables of FILE.  */
        -:15815:
        -:15816:void
function print_file_variables called 0 returned 0% blocks executed 0%
    #####:15817:print_file_variables (file)
        -:15818:     struct file *file;
        -:15819:{
    #####:15820:  if (file->variables != 0)
branch  0 never executed
branch  1 never executed
    #####:15821:    print_variable_set (file->variables->set, "# ");
call    0 never executed
    #####:15822:}
        -:15823:
        -:15824:#ifdef WINDOWS32
        -:15825:void
        -:15826:sync_Path_environment(void)
        -:15827:{
        -:15828:    char* path = allocated_variable_expand("$(Path)");
        -:15829:    static char* environ_path = NULL;
        -:15830:
        -:15831:    if (!path)
        -:15832:        return;
        -:15833:
        -:15834:    /*
        -:15835:     * If done this before, don't leak memory unnecessarily.
        -:15836:     * Free the previous entry before allocating new one.
        -:15837:     */
        -:15838:    if (environ_path)
        -:15839:        free(environ_path);
        -:15840:
        -:15841:    /*
        -:15842:     * Create something WINDOWS32 world can grok
        -:15843:     */
        -:15844:    convert_Path_to_windows32(path, ';');
        -:15845:    environ_path = concat("Path", "=", path);
        -:15846:    putenv(environ_path);
        -:15847:    free(path);
        -:15848:}
        -:15849:#endif
        -:15850:
        -:15851:
        -:15852:
        -:15853:/*************************************************************
        -:15854:  ============================================================
        -:15855:  ************************************************************
        -:15856:  ============================================================
        -:15857:  ************************************************************
        -:15858:                         expand.c
        -:15859:  ************************************************************
        -:15860:  ============================================================
        -:15861:  ************************************************************
        -:15862:  ============================================================
        -:15863:  *************************************************************/
        -:15864:
        -:15865:/* Variable expansion functions for GNU Make.
        -:15866:Copyright (C) 1988, 89, 91, 92, 93, 95 Free Software Foundation, Inc.
        -:15867:This file is part of GNU Make.
        -:15868:
        -:15869:GNU Make is free software; you can redistribute it and/or modify
        -:15870:it under the terms of the GNU General Public License as published by
        -:15871:the Free Software Foundation; either version 2, or (at your option)
        -:15872:any later version.
        -:15873:
        -:15874:GNU Make is distributed in the hope that it will be useful,
        -:15875:but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:15876:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:15877:GNU General Public License for more details.
        -:15878:
        -:15879:You should have received a copy of the GNU General Public License
        -:15880:along with GNU Make; see the file COPYING.  If not, write to
        -:15881:the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
        -:15882:Boston, MA 02111-1307, USA.  */
        -:15883:
        -:15884:/* #include "make.h"  <- modification by J.Ruthruff, 7/27 */
        -:15885:/* #include "filedef.h"  <- modification by J.Ruthruff, 7/27 */
        -:15886:#include "job.h"
        -:15887:/* #include "commands.h"  <- modification by J.Ruthruff, 7/27 */
        -:15888:/* #include "variable.h"  <- modification by J.Ruthruff, 7/27 */
        -:15889:/* #include "rule.h"  <- modification by J.Ruthruff, 7/27 */
        -:15890:#undef stderr
        -:15891:#define stderr stdout
        -:15892:
        -:15893:
        -:15894:/* The next two describe the variable output buffer.
        -:15895:   This buffer is used to hold the variable-expansion of a line of the
        -:15896:   makefile.  It is made bigger with realloc whenever it is too small.
        -:15897:   variable_buffer_length is the size currently allocated.
        -:15898:   variable_buffer is the address of the buffer.
        -:15899:
        -:15900:   For efficiency, it's guaranteed that the buffer will always have
        -:15901:   VARIABLE_BUFFER_ZONE extra bytes allocated.  This allows you to add a few
        -:15902:   extra chars without having to call a function.  Note you should never use
        -:15903:   these bytes unless you're _sure_ you have room (you know when the buffer
        -:15904:   length was last checked.  */
        -:15905:
        -:15906:#define VARIABLE_BUFFER_ZONE    5
        -:15907:
        -:15908:static unsigned int variable_buffer_length;
        -:15909:char *variable_buffer;
        -:15910:
        -:15911:/* Subroutine of variable_expand and friends:
        -:15912:   The text to add is LENGTH chars starting at STRING to the variable_buffer.
        -:15913:   The text is added to the buffer at PTR, and the updated pointer into
        -:15914:   the buffer is returned as the value.  Thus, the value returned by
        -:15915:   each call to variable_buffer_output should be the first argument to
        -:15916:   the following call.  */
        -:15917:
        -:15918:char *
function variable_buffer_output called 18492 returned 100% blocks executed 60%
    18492:15919:variable_buffer_output (ptr, string, length)
        -:15920:     char *ptr, *string;
        -:15921:     unsigned int length;
        -:15922:{
    18492:15923:  register unsigned int newlen = length + (ptr - variable_buffer);
        -:15924:
    18492:15925:  if ((newlen + VARIABLE_BUFFER_ZONE) > variable_buffer_length)
branch  0 taken 0 (fallthrough)
branch  1 taken 18492
        -:15926:    {
    #####:15927:      unsigned int offset = ptr - variable_buffer;
    #####:15928:      variable_buffer_length = (newlen + 100 > 2 * variable_buffer_length
        -:15929:				? newlen + 100
    #####:15930:				: 2 * variable_buffer_length);
    #####:15931:      variable_buffer = (char *) xrealloc (variable_buffer,
call    0 never executed
        -:15932:					   variable_buffer_length);
    #####:15933:      ptr = variable_buffer + offset;
        -:15934:    }
        -:15935:
    18492:15936:  bcopy (string, ptr, length);
    18492:15937:  return ptr + length;
        -:15938:}
        -:15939:
        -:15940:/* Return a pointer to the beginning of the variable buffer.  */
        -:15941:
        -:15942:static char *
function initialize_variable_output called 6164 returned 100% blocks executed 100%
     6164:15943:initialize_variable_output ()
        -:15944:{
        -:15945:  /* If we don't have a variable output buffer yet, get one.  */
        -:15946:
     6164:15947:  if (variable_buffer == 0)
branch  0 taken 3851 (fallthrough)
branch  1 taken 2313
        -:15948:    {
     3851:15949:      variable_buffer_length = 200;
     3851:15950:      variable_buffer = (char *) xmalloc (variable_buffer_length);
call    0 returned 3851
     3851:15951:      variable_buffer[0] = '\0';
        -:15952:    }
        -:15953:
     6164:15954:  return variable_buffer;
        -:15955:}
        -:15956:
        -:15957:/* Recursively expand V.  The returned string is malloc'd.  */
        -:15958:
        -:15959:char *
function recursively_expand called 764 returned 100% blocks executed 80%
      764:15960:recursively_expand (v)
        -:15961:     register struct variable *v;
        -:15962:{
        -:15963:  char *value;
        -:15964:
      764:15965:  if (v->expanding)
branch  0 taken 0 (fallthrough)
branch  1 taken 764
        -:15966:    /* Expanding V causes infinite recursion.  Lose.  */
    #####:15967:    fatal (reading_file,
call    0 never executed
        -:15968:           _("Recursive variable `%s' references itself (eventually)"),
        -:15969:           v->name);
        -:15970:
      764:15971:  v->expanding = 1;
      764:15972:  value = allocated_variable_expand (v->value);
call    0 returned 764
      764:15973:  v->expanding = 0;
        -:15974:
      764:15975:  return value;
        -:15976:}
        -:15977:
        -:15978:/* Warn that NAME is an undefined variable.  */
        -:15979:
        -:15980:#ifdef __GNUC__
        -:15981:__inline
        -:15982:#endif
        -:15983:static void
function warn_undefined called 2316 returned 100% blocks executed 67%
     2316:15984:warn_undefined (name, length)
        -:15985:     char *name;
        -:15986:     unsigned int length;
        -:15987:{
     2316:15988:  if (warn_undefined_variables_flag)
branch  0 taken 0 (fallthrough)
branch  1 taken 2316
    #####:15989:    error (reading_file,
call    0 never executed
        -:15990:           _("warning: undefined variable `%.*s'"), (int)length, name);
     2316:15991:}
        -:15992:
        -:15993:/* Expand a simple reference to variable NAME, which is LENGTH chars long.  */
        -:15994:
        -:15995:#ifdef __GNUC__
        -:15996:__inline
        -:15997:#endif
        -:15998:static char *
function reference_variable called 3858 returned 100% blocks executed 92%
     3858:15999:reference_variable (o, name, length)
        -:16000:     char *o;
        -:16001:     char *name;
        -:16002:     unsigned int length;
        -:16003:{
     3858:16004:  register struct variable *v = lookup_variable (name, length);
call    0 returned 3858
        -:16005:
     3858:16006:  if (v == 0)
branch  0 taken 2316 (fallthrough)
branch  1 taken 1542
     2316:16007:    warn_undefined (name, length);
call    0 returned 2316
        -:16008:
     3858:16009:  if (v != 0 && *v->value != '\0')
branch  0 taken 1542 (fallthrough)
branch  1 taken 2316
branch  2 taken 764 (fallthrough)
branch  3 taken 778
        -:16010:    {
     764*:16011:      char *value = (v->recursive ? recursively_expand (v) : v->value);
branch  0 taken 764 (fallthrough)
branch  1 taken 0
call    2 returned 764
      764:16012:      o = variable_buffer_output (o, value, strlen (value));
call    0 returned 764
      764:16013:      if (v->recursive)
branch  0 taken 764 (fallthrough)
branch  1 taken 0
      764:16014:	free (value);
        -:16015:    }
        -:16016:
     3858:16017:  return o;
        -:16018:}
        -:16019:
        -:16020:/* Scan STRING for variable references and expansion-function calls.  Only
        -:16021:   LENGTH bytes of STRING are actually scanned.  If LENGTH is -1, scan until
        -:16022:   a null byte is found.
        -:16023:
        -:16024:   Write the results to LINE, which must point into `variable_buffer'.  If
        -:16025:   LINE is NULL, start at the beginning of the buffer.
        -:16026:   Return a pointer to LINE, or to the beginning of the buffer if LINE is
        -:16027:   NULL.  */
        -:16028:
        -:16029:char *
function variable_expand_string called 6164 returned 100% blocks executed 41%
     6164:16030:variable_expand_string (line, string, length)
        -:16031:     register char *line;
        -:16032:     char *string;
        -:16033:     long length;
        -:16034:{
        -:16035:  register struct variable *v;
        -:16036:  register char *p, *o, *p1;
     6164:16037:  char save_char = '\0';
        -:16038:  unsigned int line_offset;
        -:16039:
     6164:16040:  if (!line)
branch  0 taken 6164 (fallthrough)
branch  1 taken 0
     6164:16041:    line = initialize_variable_output();
call    0 returned 6164
        -:16042:
     6164:16043:  p = string;
     6164:16044:  o = line;
     6164:16045:  line_offset = line - variable_buffer;
        -:16046:
     6164:16047:  if (length >= 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 6164
        -:16048:    {
    #####:16049:      save_char = string[length];
    #####:16050:      string[length] = '\0';
        -:16051:    }
        -:16052:
        -:16053:  while (1)
        -:16054:    {
        -:16055:      /* Copy all following uninteresting chars all at once to the
        -:16056:         variable output buffer, and skip them.  Uninteresting chars end
        -:16057:	 at the next $ or the end of the input.  */
        -:16058:
    16964:16059:      p1 = index (p, '$');
        -:16060:
    11564:16061:      o = variable_buffer_output (o, p, p1 != 0 ? p1 - p : strlen (p) + 1);
branch  0 taken 5400 (fallthrough)
branch  1 taken 6164
call    2 returned 11564
        -:16062:
    11564:16063:      if (p1 == 0)
branch  0 taken 6164 (fallthrough)
branch  1 taken 5400
     6164:16064:	break;
     5400:16065:      p = p1 + 1;
        -:16066:
        -:16067:      /* Dispatch on the char that follows the $.  */
        -:16068:
     5400:16069:      switch (*p)
branch  0 taken 0
branch  1 taken 5400
branch  2 taken 0
branch  3 taken 0
        -:16070:	{
    #####:16071:	case '$':
        -:16072:	  /* $$ seen means output one $ to the variable output buffer.  */
    #####:16073:	  o = variable_buffer_output (o, p, 1);
call    0 never executed
    #####:16074:	  break;
        -:16075:
     5400:16076:	case '(':
        -:16077:	case '{':
        -:16078:	  /* $(...) or ${...} is the general case of substitution.  */
        -:16079:	  {
     5400:16080:	    char openparen = *p;
    5400*:16081:	    char closeparen = (openparen == '(') ? ')' : '}';
branch  0 taken 5400 (fallthrough)
branch  1 taken 0
     5400:16082:	    register char *beg = p + 1;
     5400:16083:	    int free_beg = 0;
        -:16084:	    char *op, *begp;
        -:16085:	    char *end, *colon;
        -:16086:
     5400:16087:	    op = o;
     5400:16088:	    begp = p;
     5400:16089:	    if (handle_function (&op, &begp))
call    0 returned 5400
branch  1 taken 1542 (fallthrough)
branch  2 taken 3858
        -:16090:	      {
     1542:16091:		o = op;
     1542:16092:		p = begp;
     1542:16093:		break;
        -:16094:	      }
        -:16095:
        -:16096:	    /* Is there a variable reference inside the parens or braces?
        -:16097:	       If so, expand it before expanding the entire reference.  */
        -:16098:
     3858:16099:	    end = index (beg, closeparen);
     3858:16100:	    if (end == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 3858
        -:16101:              /* Unterminated variable reference.  */
    #####:16102:              fatal (reading_file, _("unterminated variable reference"));
call    0 never executed
     3858:16103:	    p1 = lindex (beg, end, '$');
call    0 returned 3858
     3858:16104:	    if (p1 != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 3858
        -:16105:	      {
        -:16106:		/* BEG now points past the opening paren or brace.
        -:16107:		   Count parens or braces until it is matched.  */
    #####:16108:		int count = 0;
    #####:16109:		for (p = beg; *p != '\0'; ++p)
branch  0 never executed
branch  1 never executed
        -:16110:		  {
    #####:16111:		    if (*p == openparen)
branch  0 never executed
branch  1 never executed
    #####:16112:		      ++count;
    #####:16113:		    else if (*p == closeparen && --count < 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:16114:		      break;
        -:16115:		  }
        -:16116:		/* If COUNT is >= 0, there were unmatched opening parens
        -:16117:		   or braces, so we go to the simple case of a variable name
        -:16118:		   such as `$($(a)'.  */
    #####:16119:		if (count < 0)
branch  0 never executed
branch  1 never executed
        -:16120:		  {
    #####:16121:		    beg = expand_argument (beg, p); /* Expand the name.  */
call    0 never executed
    #####:16122:		    free_beg = 1; /* Remember to free BEG when finished.  */
    #####:16123:		    end = index (beg, '\0');
        -:16124:		  }
        -:16125:	      }
        -:16126:	    else
        -:16127:	      /* Advance P to the end of this reference.  After we are
        -:16128:                 finished expanding this one, P will be incremented to
        -:16129:                 continue the scan.  */
     3858:16130:	      p = end;
        -:16131:
        -:16132:	    /* This is not a reference to a built-in function and
        -:16133:	       any variable references inside are now expanded.
        -:16134:	       Is the resultant text a substitution reference?  */
        -:16135:
     3858:16136:	    colon = lindex (beg, end, ':');
call    0 returned 3858
     3858:16137:	    if (colon != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 3858
        -:16138:	      {
        -:16139:		/* This looks like a substitution reference: $(FOO:A=B).  */
        -:16140:		char *subst_beg, *subst_end, *replace_beg, *replace_end;
        -:16141:
    #####:16142:		subst_beg = colon + 1;
    #####:16143:		subst_end = index (subst_beg, '=');
    #####:16144:		if (subst_end == 0)
branch  0 never executed
branch  1 never executed
        -:16145:		  /* There is no = in sight.  Punt on the substitution
        -:16146:		     reference and treat this as a variable name containing
        -:16147:		     a colon, in the code below.  */
    #####:16148:		  colon = 0;
        -:16149:		else
        -:16150:		  {
    #####:16151:		    replace_beg = subst_end + 1;
    #####:16152:		    replace_end = end;
        -:16153:
        -:16154:		    /* Extract the variable name before the colon
        -:16155:		       and look up that variable.  */
    #####:16156:		    v = lookup_variable (beg, colon - beg);
call    0 never executed
    #####:16157:		    if (v == 0)
branch  0 never executed
branch  1 never executed
    #####:16158:		      warn_undefined (beg, colon - beg);
call    0 never executed
        -:16159:
    #####:16160:		    if (v != 0 && *v->value != '\0')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:16161:		      {
    #####:16162:			char *value = (v->recursive ? recursively_expand (v)
call    0 never executed
    #####:16163:				       : v->value);
branch  0 never executed
branch  1 never executed
        -:16164:			char *pattern, *percent;
    #####:16165:			if (free_beg)
branch  0 never executed
branch  1 never executed
        -:16166:			  {
    #####:16167:			    *subst_end = '\0';
    #####:16168:			    pattern = subst_beg;
        -:16169:			  }
        -:16170:			else
        -:16171:			  {
    #####:16172:			    pattern = (char *) alloca (subst_end - subst_beg
        -:16173:						       + 1);
    #####:16174:			    bcopy (subst_beg, pattern, subst_end - subst_beg);
    #####:16175:			    pattern[subst_end - subst_beg] = '\0';
        -:16176:			  }
    #####:16177:			percent = find_percent (pattern);
call    0 never executed
    #####:16178:			if (percent != 0)
branch  0 never executed
branch  1 never executed
        -:16179:			  {
        -:16180:			    char *replace;
    #####:16181:			    if (free_beg)
branch  0 never executed
branch  1 never executed
        -:16182:			      {
    #####:16183:				*replace_end = '\0';
    #####:16184:				replace = replace_beg;
        -:16185:			      }
        -:16186:			    else
        -:16187:			      {
    #####:16188:				replace = (char *) alloca (replace_end
        -:16189:							   - replace_beg
        -:16190:							   + 1);
    #####:16191:				bcopy (replace_beg, replace,
        -:16192:				       replace_end - replace_beg);
    #####:16193:				replace[replace_end - replace_beg] = '\0';
        -:16194:			      }
        -:16195:
    #####:16196:			    o = patsubst_expand (o, value, pattern, replace,
call    0 never executed
        -:16197:						 percent, (char *) 0);
        -:16198:			  }
        -:16199:			else
    #####:16200:			  o = subst_expand (o, value,
        -:16201:					    pattern, replace_beg,
    #####:16202:					    strlen (pattern),
    #####:16203:					    end - replace_beg,
call    0 never executed
        -:16204:					    0, 1);
    #####:16205:			if (v->recursive)
branch  0 never executed
branch  1 never executed
    #####:16206:			  free (value);
        -:16207:		      }
        -:16208:		  }
        -:16209:	      }
        -:16210:
     3858:16211:	    if (colon == 0)
branch  0 taken 3858 (fallthrough)
branch  1 taken 0
        -:16212:	      /* This is an ordinary variable reference.
        -:16213:		 Look up the value of the variable.  */
     3858:16214:		o = reference_variable (o, beg, end - beg);
call    0 returned 3858
        -:16215:
     3858:16216:	  if (free_beg)
branch  0 taken 0 (fallthrough)
branch  1 taken 3858
    #####:16217:	    free (beg);
        -:16218:	  }
     3858:16219:	  break;
        -:16220:
    #####:16221:	case '\0':
    #####:16222:	  break;
        -:16223:
    #####:16224:	default:
    #####:16225:	  if (isblank (p[-1]))
branch  0 never executed
branch  1 never executed
    #####:16226:	    break;
        -:16227:
        -:16228:	  /* A $ followed by a random char is a variable reference:
        -:16229:	     $a is equivalent to $(a).  */
        -:16230:	  {
        -:16231:	    /* We could do the expanding here, but this way
        -:16232:	       avoids code repetition at a small performance cost.  */
        -:16233:	    char name[5];
    #####:16234:	    name[0] = '$';
    #####:16235:	    name[1] = '(';
    #####:16236:	    name[2] = *p;
    #####:16237:	    name[3] = ')';
    #####:16238:	    name[4] = '\0';
    #####:16239:	    p1 = allocated_variable_expand (name);
call    0 never executed
    #####:16240:	    o = variable_buffer_output (o, p1, strlen (p1));
call    0 never executed
    #####:16241:	    free (p1);
        -:16242:	  }
        -:16243:
    #####:16244:	  break;
        -:16245:	}
        -:16246:
     5400:16247:      if (*p == '\0')
branch  0 taken 0 (fallthrough)
branch  1 taken 5400
    #####:16248:	break;
        -:16249:      else
     5400:16250:	++p;
        -:16251:    }
        -:16252:
     6164:16253:  if (save_char)
branch  0 taken 0 (fallthrough)
branch  1 taken 6164
    #####:16254:    string[length] = save_char;
        -:16255:
     6164:16256:  (void)variable_buffer_output (o, "", 1);
call    0 returned 6164
     6164:16257:  return (variable_buffer + line_offset);
        -:16258:}
        -:16259:
        -:16260:/* Scan LINE for variable references and expansion-function calls.
        -:16261:   Build in `variable_buffer' the result of expanding the references and calls.
        -:16262:   Return the address of the resulting string, which is null-terminated
        -:16263:   and is valid only until the next time this function is called.  */
        -:16264:
        -:16265:char *
function variable_expand called 6164 returned 100% blocks executed 100%
     6164:16266:variable_expand (line)
        -:16267:     char *line;
        -:16268:{
     6164:16269:  return variable_expand_string(NULL, line, (long)-1);
call    0 returned 6164
        -:16270:}
        -:16271:
        -:16272:/* Expand an argument for an expansion function.
        -:16273:   The text starting at STR and ending at END is variable-expanded
        -:16274:   into a null-terminated string that is returned as the value.
        -:16275:   This is done without clobbering `variable_buffer' or the current
        -:16276:   variable-expansion that is in progress.  */
        -:16277:
        -:16278:char *
function expand_argument called 1542 returned 100% blocks executed 80%
     1542:16279:expand_argument (str, end)
        -:16280:     char *str, *end;
        -:16281:{
        -:16282:  char *tmp;
        -:16283:
     1542:16284:  if (*end == '\0')
branch  0 taken 0 (fallthrough)
branch  1 taken 1542
    #####:16285:    tmp = str;
        -:16286:  else
        -:16287:    {
     1542:16288:      tmp = (char *) alloca (end - str + 1);
     1542:16289:      bcopy (str, tmp, end - str);
     1542:16290:      tmp[end - str] = '\0';
        -:16291:    }
        -:16292:
     1542:16293:  return allocated_variable_expand (tmp);
call    0 returned 1542
        -:16294:}
        -:16295:
        -:16296:/* Expand LINE for FILE.  Error messages refer to the file and line where
        -:16297:   FILE's commands were found.  Expansion uses FILE's variable set list.  */
        -:16298:
        -:16299:static char *
function variable_expand_for_file called 3077 returned 100% blocks executed 27%
     3077:16300:variable_expand_for_file (line, file)
        -:16301:     char *line;
        -:16302:     register struct file *file;
        -:16303:{
        -:16304:  char *result;
        -:16305:  struct variable_set_list *save, *fnext;
        -:16306:
     3077:16307:  if (file == 0)
branch  0 taken 3077 (fallthrough)
branch  1 taken 0
     3077:16308:    return variable_expand (line);
call    0 returned 3077
        -:16309:
    #####:16310:  save = current_variable_set_list;
    #####:16311:  current_variable_set_list = file->variables;
    #####:16312:  if (file->cmds && file->cmds->fileinfo.filenm)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:16313:    reading_file = &file->cmds->fileinfo;
        -:16314:  else
    #####:16315:    reading_file = 0;
    #####:16316:  fnext = file->variables->next;
        -:16317:  /* See if there's a pattern-specific variable struct for this target.  */
    #####:16318:  if (!file->pat_searched)
branch  0 never executed
branch  1 never executed
        -:16319:    {
    #####:16320:      file->patvar = lookup_pattern_var(file->name);
call    0 never executed
    #####:16321:      file->pat_searched = 1;
        -:16322:    }
    #####:16323:  if (file->patvar != 0)
branch  0 never executed
branch  1 never executed
        -:16324:    {
    #####:16325:      file->patvar->vars->next = fnext;
    #####:16326:      file->variables->next = file->patvar->vars;
        -:16327:    }
    #####:16328:  result = variable_expand (line);
call    0 never executed
    #####:16329:  current_variable_set_list = save;
    #####:16330:  reading_file = 0;
    #####:16331:  file->variables->next = fnext;
        -:16332:
    #####:16333:  return result;
        -:16334:}
        -:16335:
        -:16336:/* Like variable_expand_for_file, but the returned string is malloc'd.
        -:16337:   This function is called a lot.  It wants to be efficient.  */
        -:16338:
        -:16339:char *
function allocated_variable_expand_for_file called 3077 returned 100% blocks executed 100%
     3077:16340:allocated_variable_expand_for_file (line, file)
        -:16341:     char *line;
        -:16342:     struct file *file;
        -:16343:{
        -:16344:  char *value;
        -:16345:
     3077:16346:  char *obuf = variable_buffer;
     3077:16347:  unsigned int olen = variable_buffer_length;
        -:16348:
     3077:16349:  variable_buffer = 0;
        -:16350:
     3077:16351:  value = variable_expand_for_file (line, file);
call    0 returned 3077
        -:16352:
        -:16353:#if 0
        -:16354:  /* Waste a little memory and save time.  */
        -:16355:  value = xrealloc (value, strlen (value))
        -:16356:#endif
        -:16357:
     3077:16358:  variable_buffer = obuf;
     3077:16359:  variable_buffer_length = olen;
        -:16360:
     3077:16361:  return value;
        -:16362:}
        -:16363:
        -:16364:
        -:16365:
        -:16366:/*************************************************************
        -:16367:  ============================================================
        -:16368:  ************************************************************
        -:16369:  ============================================================
        -:16370:  ************************************************************
        -:16371:                         function.c
        -:16372:  ************************************************************
        -:16373:  ============================================================
        -:16374:  ************************************************************
        -:16375:  ============================================================
        -:16376:  *************************************************************/
        -:16377:
        -:16378:/* Builtin function expansion for GNU Make.
        -:16379:Copyright (C) 1988,89,91,92,93,94,95,96,97 Free Software Foundation, Inc.
        -:16380:This file is part of GNU Make.
        -:16381:
        -:16382:GNU Make is free software; you can redistribute it and/or modify
        -:16383:it under the terms of the GNU General Public License as published by
        -:16384:the Free Software Foundation; either version 2, or (at your option)
        -:16385:any later version.
        -:16386:
        -:16387:GNU Make is distributed in the hope that it will be useful,
        -:16388:but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:16389:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:16390:GNU General Public License for more details.
        -:16391:
        -:16392:You should have received a copy of the GNU General Public License
        -:16393:along with GNU Make; see the file COPYING.  If not, write to
        -:16394:the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
        -:16395:Boston, MA 02111-1307, USA.  */
        -:16396:
        -:16397:/* #include "make.h"  <- modification by J.Ruthruff, 7/27 */
        -:16398:/* #include "filedef.h"  <- modification by J.Ruthruff, 7/27 */
        -:16399:/* #include "variable.h"  <- modification by J.Ruthruff, 7/27 */
        -:16400:/* #include "dep.h"  <- modification by J.Ruthruff, 7/27 */
        -:16401:#include "job.h"
        -:16402:/* #include "commands.h"  <- modification by J.Ruthruff, 7/27 */
        -:16403:#undef stderr
        -:16404:#define stderr stdout
        -:16405:
        -:16406:#ifdef _AMIGA
        -:16407:#include "amiga.h"
        -:16408:#undef stderr
        -:16409:#define stderr stdout
        -:16410:#endif
        -:16411:
        -:16412:
        -:16413:struct function_table_entry
        -:16414:  {
        -:16415:    const char *name;
        -:16416:    int len;
        -:16417:    int required_args;
        -:16418:    int expand_args;
        -:16419:    char *(*func_ptr) PARAMS((char *output, char **argv, const char*funcname));
        -:16420:  };
        -:16421:
        -:16422:
        -:16423:/* Store into VARIABLE_BUFFER at O the result of scanning TEXT and replacing
        -:16424:   each occurrence of SUBST with REPLACE. TEXT is null-terminated.  SLEN is
        -:16425:   the length of SUBST and RLEN is the length of REPLACE.  If BY_WORD is
        -:16426:   nonzero, substitutions are done only on matches which are complete
        -:16427:   whitespace-delimited words.  If SUFFIX_ONLY is nonzero, substitutions are
        -:16428:   done only at the ends of whitespace-delimited words.  */
        -:16429:
        -:16430:char *
function subst_expand called 0 returned 0% blocks executed 0%
    #####:16431:subst_expand (o, text, subst, replace, slen, rlen, by_word, suffix_only)
        -:16432:     char *o;
        -:16433:     char *text;
        -:16434:     char *subst, *replace;
        -:16435:     unsigned int slen, rlen;
        -:16436:     int by_word, suffix_only;
        -:16437:{
    #####:16438:  register char *t = text;
        -:16439:  register char *p;
        -:16440:
    #####:16441:  if (slen == 0 && !by_word && !suffix_only)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:16442:    {
        -:16443:      /* The first occurrence of "" in any string is its end.  */
    #####:16444:      o = variable_buffer_output (o, t, strlen (t));
call    0 never executed
    #####:16445:      if (rlen > 0)
branch  0 never executed
branch  1 never executed
    #####:16446:	o = variable_buffer_output (o, replace, rlen);
call    0 never executed
    #####:16447:      return o;
        -:16448:    }
        -:16449:
        -:16450:  do
        -:16451:    {
    #####:16452:      if ((by_word | suffix_only) && slen == 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:16453:	/* When matching by words, the empty string should match
        -:16454:	   the end of each word, rather than the end of the whole text.  */
    #####:16455:	p = end_of_token (next_token (t));
call    0 never executed
call    1 never executed
        -:16456:      else
        -:16457:	{
    #####:16458:	  p = sindex (t, 0, subst, slen);
call    0 never executed
    #####:16459:	  if (p == 0)
branch  0 never executed
branch  1 never executed
        -:16460:	    {
        -:16461:	      /* No more matches.  Output everything left on the end.  */
    #####:16462:	      o = variable_buffer_output (o, t, strlen (t));
call    0 never executed
    #####:16463:	      return o;
        -:16464:	    }
        -:16465:	}
        -:16466:
        -:16467:      /* Output everything before this occurrence of the string to replace.  */
    #####:16468:      if (p > t)
branch  0 never executed
branch  1 never executed
    #####:16469:	o = variable_buffer_output (o, t, p - t);
call    0 never executed
        -:16470:
        -:16471:      /* If we're substituting only by fully matched words,
        -:16472:	 or only at the ends of words, check that this case qualifies.  */
    #####:16473:      if ((by_word
branch  0 never executed
branch  1 never executed
    #####:16474:	   && ((p > t && !isblank (p[-1]))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:16475:	       || (p[slen] != '\0' && !isblank (p[slen]))))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:16476:	  || (suffix_only
branch  0 never executed
branch  1 never executed
    #####:16477:	      && (p[slen] != '\0' && !isblank (p[slen]))))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:16478:	/* Struck out.  Output the rest of the string that is
        -:16479:	   no longer to be replaced.  */
    #####:16480:	o = variable_buffer_output (o, subst, slen);
call    0 never executed
    #####:16481:      else if (rlen > 0)
branch  0 never executed
branch  1 never executed
        -:16482:	/* Output the replacement string.  */
    #####:16483:	o = variable_buffer_output (o, replace, rlen);
call    0 never executed
        -:16484:
        -:16485:      /* Advance T past the string to be replaced.  */
    #####:16486:      t = p + slen;
    #####:16487:    } while (*t != '\0');
branch  0 never executed
branch  1 never executed
        -:16488:
    #####:16489:  return o;
        -:16490:}
        -:16491:
        -:16492:
        -:16493:/* Store into VARIABLE_BUFFER at O the result of scanning TEXT
        -:16494:   and replacing strings matching PATTERN with REPLACE.
        -:16495:   If PATTERN_PERCENT is not nil, PATTERN has already been
        -:16496:   run through find_percent, and PATTERN_PERCENT is the result.
        -:16497:   If REPLACE_PERCENT is not nil, REPLACE has already been
        -:16498:   run through find_percent, and REPLACE_PERCENT is the result.  */
        -:16499:
        -:16500:char *
function patsubst_expand called 0 returned 0% blocks executed 0%
    #####:16501:patsubst_expand (o, text, pattern, replace, pattern_percent, replace_percent)
        -:16502:     char *o;
        -:16503:     char *text;
        -:16504:     register char *pattern, *replace;
        -:16505:     register char *pattern_percent, *replace_percent;
        -:16506:{
        -:16507:  unsigned int pattern_prepercent_len, pattern_postpercent_len;
    #####:16508:  unsigned int replace_prepercent_len, replace_postpercent_len = 0;
        -:16509:  char *t;
        -:16510:  unsigned int len;
    #####:16511:  int doneany = 0;
        -:16512:
        -:16513:  /* We call find_percent on REPLACE before checking PATTERN so that REPLACE
        -:16514:     will be collapsed before we call subst_expand if PATTERN has no %.  */
    #####:16515:  if (replace_percent == 0)
branch  0 never executed
branch  1 never executed
    #####:16516:    replace_percent = find_percent (replace);
call    0 never executed
    #####:16517:  if (replace_percent != 0)
branch  0 never executed
branch  1 never executed
        -:16518:    {
        -:16519:      /* Record the length of REPLACE before and after the % so
        -:16520:	 we don't have to compute these lengths more than once.  */
    #####:16521:      replace_prepercent_len = replace_percent - replace;
    #####:16522:      replace_postpercent_len = strlen (replace_percent + 1);
        -:16523:    }
        -:16524:  else
        -:16525:    /* We store the length of the replacement
        -:16526:       so we only need to compute it once.  */
    #####:16527:    replace_prepercent_len = strlen (replace);
        -:16528:
    #####:16529:  if (pattern_percent == 0)
branch  0 never executed
branch  1 never executed
    #####:16530:    pattern_percent = find_percent (pattern);
call    0 never executed
    #####:16531:  if (pattern_percent == 0)
branch  0 never executed
branch  1 never executed
        -:16532:    /* With no % in the pattern, this is just a simple substitution.  */
    #####:16533:    return subst_expand (o, text, pattern, replace,
    #####:16534:			 strlen (pattern), strlen (replace), 1, 0);
call    0 never executed
        -:16535:
        -:16536:  /* Record the length of PATTERN before and after the %
        -:16537:     so we don't have to compute it more than once.  */
    #####:16538:  pattern_prepercent_len = pattern_percent - pattern;
    #####:16539:  pattern_postpercent_len = strlen (pattern_percent + 1);
        -:16540:
    #####:16541:  while ((t = find_next_token (&text, &len)) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:16542:    {
    #####:16543:      int fail = 0;
        -:16544:
        -:16545:      /* Is it big enough to match?  */
    #####:16546:      if (len < pattern_prepercent_len + pattern_postpercent_len)
branch  0 never executed
branch  1 never executed
    #####:16547:	fail = 1;
        -:16548:
        -:16549:      /* Does the prefix match? */
    #####:16550:      if (!fail && pattern_prepercent_len > 0
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:16551:	  && (*t != *pattern
branch  0 never executed
branch  1 never executed
    #####:16552:	      || t[pattern_prepercent_len - 1] != pattern_percent[-1]
branch  0 never executed
branch  1 never executed
    #####:16553:	      || !strneq (t + 1, pattern + 1, pattern_prepercent_len - 1)))
branch  0 never executed
branch  1 never executed
    #####:16554:	fail = 1;
        -:16555:
        -:16556:      /* Does the suffix match? */
    #####:16557:      if (!fail && pattern_postpercent_len > 0
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:16558:	  && (t[len - 1] != pattern_percent[pattern_postpercent_len]
branch  0 never executed
branch  1 never executed
    #####:16559:	      || t[len - pattern_postpercent_len] != pattern_percent[1]
branch  0 never executed
branch  1 never executed
    #####:16560:	      || !strneq (&t[len - pattern_postpercent_len],
branch  0 never executed
branch  1 never executed
        -:16561:			  &pattern_percent[1], pattern_postpercent_len - 1)))
    #####:16562:	fail = 1;
        -:16563:
    #####:16564:      if (fail)
branch  0 never executed
branch  1 never executed
        -:16565:	/* It didn't match.  Output the string.  */
    #####:16566:	o = variable_buffer_output (o, t, len);
call    0 never executed
        -:16567:      else
        -:16568:	{
        -:16569:	  /* It matched.  Output the replacement.  */
        -:16570:
        -:16571:	  /* Output the part of the replacement before the %.  */
    #####:16572:	  o = variable_buffer_output (o, replace, replace_prepercent_len);
call    0 never executed
        -:16573:
    #####:16574:	  if (replace_percent != 0)
branch  0 never executed
branch  1 never executed
        -:16575:	    {
        -:16576:	      /* Output the part of the matched string that
        -:16577:		 matched the % in the pattern.  */
    #####:16578:	      o = variable_buffer_output (o, t + pattern_prepercent_len,
        -:16579:					  len - (pattern_prepercent_len
    #####:16580:						 + pattern_postpercent_len));
call    0 never executed
        -:16581:	      /* Output the part of the replacement after the %.  */
    #####:16582:	      o = variable_buffer_output (o, replace_percent + 1,
call    0 never executed
        -:16583:					  replace_postpercent_len);
        -:16584:	    }
        -:16585:	}
        -:16586:
        -:16587:      /* Output a space, but not if the replacement is "".  */
    #####:16588:      if (fail || replace_prepercent_len > 0
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:16589:	  || (replace_percent != 0 && len + replace_postpercent_len > 0))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:16590:	{
    #####:16591:	  o = variable_buffer_output (o, " ", 1);
call    0 never executed
    #####:16592:	  doneany = 1;
        -:16593:	}
        -:16594:    }
    #####:16595:  if (doneany)
branch  0 never executed
branch  1 never executed
        -:16596:    /* Kill the last space.  */
    #####:16597:    --o;
        -:16598:
    #####:16599:  return o;
        -:16600:}
        -:16601:
        -:16602:
        -:16603:/* Look up a function by name.
        -:16604:   The table is currently small enough that it's not really worthwhile to use
        -:16605:   a fancier lookup algorithm.  If it gets larger, maybe...
        -:16606:*/
        -:16607:
        -:16608:static const struct function_table_entry *
function lookup_function called 5400 returned 100% blocks executed 100%
     5400:16609:lookup_function (table, s)
        -:16610:     const struct function_table_entry *table;
        -:16611:     const char *s;
        -:16612:{
     5400:16613:  int len = strlen(s);
   128838:16614:  for (; table->name != NULL; ++table)
branch  0 taken 124980
branch  1 taken 3858 (fallthrough)
   124980:16615:    if (table->len <= len
branch  0 taken 108018 (fallthrough)
branch  1 taken 16962
   108018:16616:        && (isblank (s[table->len]) || s[table->len] == '\0')
branch  0 taken 103392 (fallthrough)
branch  1 taken 4626
branch  2 taken 10800 (fallthrough)
branch  3 taken 92592
    15426:16617:        && strneq (s, table->name, table->len))
branch  0 taken 1542 (fallthrough)
branch  1 taken 13884
        -:16618:#ifndef F_AA_7
     1542:16619:      return table;
        -:16620:#else
        -:16621:      return NULL;
        -:16622:#endif
        -:16623:
     3858:16624:  return NULL;
        -:16625:}
        -:16626:
        -:16627:
        -:16628:/* Return 1 if PATTERN matches STR, 0 if not.  */
        -:16629:
        -:16630:int
function pattern_matches called 0 returned 0% blocks executed 0%
    #####:16631:pattern_matches (pattern, percent, str)
        -:16632:     register char *pattern, *percent, *str;
        -:16633:{
        -:16634:  unsigned int sfxlen, strlength;
        -:16635:
    #####:16636:  if (percent == 0)
branch  0 never executed
branch  1 never executed
        -:16637:    {
    #####:16638:      unsigned int len = strlen (pattern) + 1;
    #####:16639:      char *new_chars = (char *) alloca (len);
    #####:16640:      bcopy (pattern, new_chars, len);
    #####:16641:      pattern = new_chars;
    #####:16642:      percent = find_percent (pattern);
call    0 never executed
    #####:16643:      if (percent == 0)
branch  0 never executed
branch  1 never executed
    #####:16644:	return streq (pattern, str);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -:16645:    }
        -:16646:
    #####:16647:  sfxlen = strlen (percent + 1);
    #####:16648:  strlength = strlen (str);
        -:16649:
    #####:16650:  if (strlength < (percent - pattern) + sfxlen
branch  0 never executed
branch  1 never executed
    #####:16651:      || !strneq (pattern, str, percent - pattern))
branch  0 never executed
branch  1 never executed
    #####:16652:    return 0;
        -:16653:
    #####:16654:  return !strcmp (percent + 1, str + (strlength - sfxlen));
        -:16655:}
        -:16656:
        -:16657:
        -:16658:/* Find the next comma or ENDPAREN (counting nested STARTPAREN and
        -:16659:   ENDPARENtheses), starting at PTR before END.  Return a pointer to
        -:16660:   next character.
        -:16661:
        -:16662:   If no next argument is found, return NULL.
        -:16663:*/
        -:16664:
        -:16665:static char *
function find_next_argument called 0 returned 0% blocks executed 0%
    #####:16666:find_next_argument (startparen, endparen, ptr, end)
        -:16667:     char startparen;
        -:16668:     char endparen;
        -:16669:     const char *ptr;
        -:16670:     const char *end;
        -:16671:{
    #####:16672:  int count = 0;
        -:16673:
    #####:16674:  for (; ptr < end; ++ptr)
branch  0 never executed
branch  1 never executed
    #####:16675:    if (*ptr == startparen)
branch  0 never executed
branch  1 never executed
    #####:16676:      ++count;
        -:16677:
    #####:16678:    else if (*ptr == endparen)
branch  0 never executed
branch  1 never executed
        -:16679:      {
    #####:16680:	--count;
    #####:16681:	if (count < 0)
branch  0 never executed
branch  1 never executed
    #####:16682:	  return NULL;
        -:16683:      }
        -:16684:
    #####:16685:    else if (*ptr == ',' && !count)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:16686:      return (char *)ptr;
        -:16687:
        -:16688:  /* We didn't find anything.  */
    #####:16689:  return NULL;
        -:16690:}
        -:16691:
        -:16692:
        -:16693:/* Glob-expand LINE.  The returned pointer is
        -:16694:   only good until the next call to string_glob.  */
        -:16695:
        -:16696:static char *
function string_glob called 0 returned 0% blocks executed 0%
    #####:16697:string_glob (line)
        -:16698:     char *line;
        -:16699:{
        -:16700:  static char *result = 0;
        -:16701:  static unsigned int length;
        -:16702:  register struct nameseq *chain;
        -:16703:  register unsigned int idx;
        -:16704:
    #####:16705:  chain = multi_glob (parse_file_seq
call    0 never executed
call    1 never executed
        -:16706:		      (&line, '\0', sizeof (struct nameseq),
        -:16707:		       /* We do not want parse_file_seq to strip `./'s.
        -:16708:			  That would break examples like:
        -:16709:			  $(patsubst ./%.c,obj/%.o,$(wildcard ./?*.c)).  */
        -:16710:		       0),
        -:16711:		      sizeof (struct nameseq));
        -:16712:
    #####:16713:  if (result == 0)
branch  0 never executed
branch  1 never executed
        -:16714:    {
    #####:16715:      length = 100;
    #####:16716:      result = (char *) xmalloc (100);
call    0 never executed
        -:16717:    }
        -:16718:
    #####:16719:  idx = 0;
    #####:16720:  while (chain != 0)
branch  0 never executed
branch  1 never executed
        -:16721:    {
    #####:16722:      register char *name = chain->name;
    #####:16723:      unsigned int len = strlen (name);
        -:16724:
    #####:16725:      struct nameseq *next = chain->next;
    #####:16726:      free ((char *) chain);
    #####:16727:      chain = next;
        -:16728:
        -:16729:      /* multi_glob will pass names without globbing metacharacters
        -:16730:	 through as is, but we want only files that actually exist.  */
    #####:16731:      if (file_exists_p (name))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:16732:	{
    #####:16733:	  if (idx + len + 1 > length)
branch  0 never executed
branch  1 never executed
        -:16734:	    {
    #####:16735:	      length += (len + 1) * 2;
    #####:16736:	      result = (char *) xrealloc (result, length);
call    0 never executed
        -:16737:	    }
    #####:16738:	  bcopy (name, &result[idx], len);
    #####:16739:	  idx += len;
    #####:16740:	  result[idx++] = ' ';
        -:16741:	}
        -:16742:
    #####:16743:      free (name);
        -:16744:    }
        -:16745:
        -:16746:  /* Kill the last space and terminate the string.  */
    #####:16747:  if (idx == 0)
branch  0 never executed
branch  1 never executed
    #####:16748:    result[0] = '\0';
        -:16749:  else
    #####:16750:    result[idx - 1] = '\0';
        -:16751:
    #####:16752:  return result;
        -:16753:}
        -:16754:
        -:16755:/*
        -:16756:  Builtin functions
        -:16757: */
        -:16758:
        -:16759:static char *
function func_patsubst called 0 returned 0% blocks executed 0%
    #####:16760:func_patsubst (o, argv, funcname)
        -:16761:     char *o;
        -:16762:     char **argv;
        -:16763:     const char *funcname;
        -:16764:{
    #####:16765:  o = patsubst_expand (o, argv[2], argv[0], argv[1], (char *) 0, (char *) 0);
call    0 never executed
    #####:16766:  return o;
        -:16767:}
        -:16768:
        -:16769:
        -:16770:static char *
function func_join called 0 returned 0% blocks executed 0%
    #####:16771:func_join(o, argv, funcname)
        -:16772:     char *o;
        -:16773:     char **argv;
        -:16774:     const char *funcname;
        -:16775:{
    #####:16776:  int doneany = 0;
        -:16777:
        -:16778:  /* Write each word of the first argument directly followed
        -:16779:     by the corresponding word of the second argument.
        -:16780:     If the two arguments have a different number of words,
        -:16781:     the excess words are just output separated by blanks.  */
        -:16782:  register char *tp;
        -:16783:  register char *pp;
    #####:16784:  char *list1_iterator = argv[0];
    #####:16785:  char *list2_iterator = argv[1];
        -:16786:  do
        -:16787:    {
        -:16788:      unsigned int len1, len2;
        -:16789:
    #####:16790:      tp = find_next_token (&list1_iterator, &len1);
call    0 never executed
    #####:16791:      if (tp != 0)
branch  0 never executed
branch  1 never executed
    #####:16792:	o = variable_buffer_output (o, tp, len1);
call    0 never executed
        -:16793:
    #####:16794:      pp = find_next_token (&list2_iterator, &len2);
call    0 never executed
    #####:16795:      if (pp != 0)
branch  0 never executed
branch  1 never executed
    #####:16796:	o = variable_buffer_output (o, pp, len2);
call    0 never executed
        -:16797:
    #####:16798:      if (tp != 0 || pp != 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:16799:	{
    #####:16800:	  o = variable_buffer_output (o, " ", 1);
call    0 never executed
    #####:16801:	  doneany = 1;
        -:16802:	}
        -:16803:    }
    #####:16804:  while (tp != 0 || pp != 0);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:16805:  if (doneany)
branch  0 never executed
branch  1 never executed
        -:16806:    /* Kill the last blank.  */
    #####:16807:    --o;
        -:16808:
    #####:16809:  return o;
        -:16810:}
        -:16811:
        -:16812:
        -:16813:static char *
function func_origin called 0 returned 0% blocks executed 0%
    #####:16814:func_origin(o, argv, funcname)
        -:16815:     char *o;
        -:16816:     char **argv;
        -:16817:     const char *funcname;
        -:16818:{
        -:16819:  /* Expand the argument.  */
    #####:16820:  register struct variable *v = lookup_variable (argv[0], strlen (argv[0]));
call    0 never executed
    #####:16821:  if (v == 0)
branch  0 never executed
branch  1 never executed
    #####:16822:    o = variable_buffer_output (o, "undefined", 9);
call    0 never executed
        -:16823:  else
    #####:16824:    switch (v->origin)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -:16825:      {
    #####:16826:      default:
        -:16827:      case o_invalid:
    #####:16828:	abort ();
call    0 never executed
        -:16829:	break;
    #####:16830:      case o_default:
    #####:16831:	o = variable_buffer_output (o, "default", 7);
call    0 never executed
    #####:16832:	break;
    #####:16833:      case o_env:
    #####:16834:	o = variable_buffer_output (o, "environment", 11);
call    0 never executed
    #####:16835:	break;
    #####:16836:      case o_file:
    #####:16837:	o = variable_buffer_output (o, "file", 4);
call    0 never executed
    #####:16838:	break;
    #####:16839:      case o_env_override:
    #####:16840:	o = variable_buffer_output (o, "environment override", 20);
call    0 never executed
    #####:16841:	break;
    #####:16842:      case o_command:
    #####:16843:	o = variable_buffer_output (o, "command line", 12);
call    0 never executed
    #####:16844:	break;
    #####:16845:      case o_override:
    #####:16846:	o = variable_buffer_output (o, "override", 8);
call    0 never executed
    #####:16847:	break;
    #####:16848:      case o_automatic:
    #####:16849:	o = variable_buffer_output (o, "automatic", 9);
call    0 never executed
    #####:16850:	break;
        -:16851:      }
        -:16852:
    #####:16853:  return o;
        -:16854:}
        -:16855:
        -:16856:#ifdef VMS
        -:16857:#define IS_PATHSEP(c) ((c) == ']')
        -:16858:#else
        -:16859:#if defined(__MSDOS__) || defined(WINDOWS32)
        -:16860:#define IS_PATHSEP(c) ((c) == '/' || (c) == '\\')
        -:16861:#else
        -:16862:#define IS_PATHSEP(c) ((c) == '/')
        -:16863:#endif
        -:16864:#endif
        -:16865:
        -:16866:
        -:16867:static char *
function func_notdir_suffix called 0 returned 0% blocks executed 0%
    #####:16868:func_notdir_suffix(o, argv, funcname)
        -:16869:     char *o;
        -:16870:     char **argv;
        -:16871:     const char *funcname;
        -:16872:{
        -:16873:  /* Expand the argument.  */
    #####:16874:  char *list_iterator = argv[0];
    #####:16875:  char *p2 =0;
    #####:16876:  int doneany =0;
    #####:16877:  int len=0;
        -:16878:
    #####:16879:  int is_suffix = streq(funcname, "suffix");
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:16880:  int is_notdir = !is_suffix;
    #####:16881:  while ((p2 = find_next_token (&list_iterator, &len)) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:16882:    {
    #####:16883:      char *p = p2 + len;
        -:16884:
        -:16885:
    #####:16886:      while (p >= p2 && (!is_suffix || *p != '.'))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:16887:	{
    #####:16888:	  if (IS_PATHSEP (*p))
branch  0 never executed
branch  1 never executed
    #####:16889:	    break;
    #####:16890:	  --p;
        -:16891:	}
        -:16892:
    #####:16893:      if (p >= p2)
branch  0 never executed
branch  1 never executed
        -:16894:	{
    #####:16895:	  if (is_notdir)
branch  0 never executed
branch  1 never executed
    #####:16896:	    ++p;
    #####:16897:	  else if (*p != '.')
branch  0 never executed
branch  1 never executed
    #####:16898:	    continue;
    #####:16899:	  o = variable_buffer_output (o, p, len - (p - p2));
call    0 never executed
        -:16900:	}
        -:16901:#if defined(WINDOWS32) || defined(__MSDOS__)
        -:16902:      /* Handle the case of "d:foo/bar".  */
        -:16903:      else if (streq(funcname, "notdir") && p2[0] && p2[1] == ':')
        -:16904:	{
        -:16905:	  p = p2 + 2;
        -:16906:	  o = variable_buffer_output (o, p, len - (p - p2));
        -:16907:	}
        -:16908:#endif
    #####:16909:      else if (is_notdir)
branch  0 never executed
branch  1 never executed
    #####:16910:	o = variable_buffer_output (o, p2, len);
call    0 never executed
        -:16911:
    #####:16912:      if (is_notdir || p >= p2)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:16913:	{
    #####:16914:	  o = variable_buffer_output (o, " ", 1);
call    0 never executed
    #####:16915:	  doneany = 1;
        -:16916:	}
        -:16917:    }
    #####:16918:  if (doneany)
branch  0 never executed
branch  1 never executed
        -:16919:    /* Kill last space.  */
    #####:16920:    --o;
        -:16921:
        -:16922:
    #####:16923:  return o;
        -:16924:
        -:16925:}
        -:16926:
        -:16927:
        -:16928:static char *
function func_basename_dir called 0 returned 0% blocks executed 0%
    #####:16929:func_basename_dir(o, argv, funcname)
        -:16930:     char *o;
        -:16931:     char **argv;
        -:16932:     const char *funcname;
        -:16933:{
        -:16934:  /* Expand the argument.  */
    #####:16935:  char *p3 = argv[0];
    #####:16936:  char *p2=0;
    #####:16937:  int doneany=0;
    #####:16938:  int len=0;
    #####:16939:  char *p=0;
    #####:16940:  int is_basename= streq(funcname, "basename");
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:16941:  int is_dir= !is_basename;
        -:16942:
    #####:16943:  while ((p2 = find_next_token (&p3, &len)) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:16944:	{
        -:16945:#ifndef F_AA_5
    #####:16946:      p = p2 + len;
        -:16947:#else
        -:16948:      p = p2;
        -:16949:#endif
    #####:16950:	  while (p >= p2 && (!is_basename  || *p != '.'))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:16951:	    {
    #####:16952:	      if (IS_PATHSEP(*p))
branch  0 never executed
branch  1 never executed
    #####:16953:		break;
    #####:16954:	      	    --p;
        -:16955:	    }
        -:16956:
    #####:16957:	  if (p >= p2 && (is_dir))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:16958:	    o = variable_buffer_output (o, p2, ++p - p2);
call    0 never executed
    #####:16959:	  else if (p >= p2 && (*p == '.'))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:16960:	    o = variable_buffer_output (o, p2, p - p2);
call    0 never executed
        -:16961:#if defined(WINDOWS32) || defined(__MSDOS__)
        -:16962:	/* Handle the "d:foobar" case */
        -:16963:	  else if (p2[0] && p2[1] == ':' && is_dir)
        -:16964:	    o = variable_buffer_output (o, p2, 2);
        -:16965:#endif
    #####:16966:	  else if (is_dir)
branch  0 never executed
branch  1 never executed
        -:16967:#ifdef VMS
        -:16968:	    o = variable_buffer_output (o, "[]", 2);
        -:16969:#else
        -:16970:#ifndef _AMIGA
    #####:16971:	    o = variable_buffer_output (o, "./", 2);
call    0 never executed
        -:16972:#else
        -:16973:	    ; /* Just a nop...  */
        -:16974:#endif /* AMIGA */
        -:16975:#endif /* !VMS */
        -:16976:	  else
        -:16977:	    /* The entire name is the basename.  */
    #####:16978:	    o = variable_buffer_output (o, p2, len);
call    0 never executed
        -:16979:
    #####:16980:	  o = variable_buffer_output (o, " ", 1);
call    0 never executed
    #####:16981:	  doneany = 1;
        -:16982:	}
    #####:16983:      if (doneany)
branch  0 never executed
branch  1 never executed
        -:16984:	/* Kill last space.  */
    #####:16985:	--o;
        -:16986:
        -:16987:
    #####:16988: return o;
        -:16989:}
        -:16990:
        -:16991:static char *
function func_addsuffix_addprefix called 0 returned 0% blocks executed 0%
    #####:16992:func_addsuffix_addprefix(o, argv, funcname)
        -:16993:     char *o;
        -:16994:     char **argv;
        -:16995:     const char *funcname;
        -:16996:{
    #####:16997:  int fixlen = strlen (argv[0]);
    #####:16998:  char *list_iterator = argv[1];
    #####:16999:  int is_addprefix = streq (funcname, "addprefix");
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:17000:  int is_addsuffix = !is_addprefix;
        -:17001:
    #####:17002:  int doneany =0;
    #####:17003:  char *p=0;
    #####:17004:  int len =0;
        -:17005:
    #####:17006:  while ((p = find_next_token (&list_iterator, &len)) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:17007:    {
    #####:17008:      if (is_addprefix)
branch  0 never executed
branch  1 never executed
    #####:17009:	o = variable_buffer_output (o, argv[0], fixlen);
call    0 never executed
    #####:17010:      o = variable_buffer_output (o, p, len);
call    0 never executed
    #####:17011:      if (is_addsuffix)
branch  0 never executed
branch  1 never executed
    #####:17012:	o = variable_buffer_output (o, argv[0], fixlen);
call    0 never executed
    #####:17013:      o = variable_buffer_output (o, " ", 1);
call    0 never executed
    #####:17014:      doneany = 1;
        -:17015:    }
        -:17016:
    #####:17017:  if (doneany)
branch  0 never executed
branch  1 never executed
        -:17018:    /* Kill last space.  */
    #####:17019:    --o;
        -:17020:
    #####:17021:  return o;
        -:17022:}
        -:17023:
        -:17024:static char *
function func_subst called 0 returned 0% blocks executed 0%
    #####:17025:func_subst(o, argv, funcname)
        -:17026:     char *o;
        -:17027:     char **argv;
        -:17028:     const char *funcname;
        -:17029:{
    #####:17030:  o = subst_expand (o, argv[2], argv[0], argv[1], strlen (argv[0]),
    #####:17031:		    strlen (argv[1]), 0, 0);
call    0 never executed
        -:17032:
    #####:17033:  return o;
        -:17034:}
        -:17035:
        -:17036:
        -:17037:static char *
function func_firstword called 0 returned 0% blocks executed 0%
    #####:17038:func_firstword(o, argv, funcname)
        -:17039:     char *o;
        -:17040:     char **argv;
        -:17041:     const char *funcname;
        -:17042:{
    #####:17043:  int i=0;
    #####:17044:  char *words = argv[0];
    #####:17045:  char *p = find_next_token (&words, &i);
call    0 never executed
        -:17046:
    #####:17047:  if (p != 0)
branch  0 never executed
branch  1 never executed
    #####:17048:    o = variable_buffer_output (o, p, i);
call    0 never executed
        -:17049:
    #####:17050:  return o;
        -:17051:}
        -:17052:
        -:17053:
        -:17054:static char *
function func_words called 0 returned 0% blocks executed 0%
    #####:17055:func_words(o, argv, funcname)
        -:17056:     char *o;
        -:17057:     char **argv;
        -:17058:     const char *funcname;
        -:17059:{
    #####:17060:  int i = 0;
    #####:17061:  char *word_iterator = argv[0];
        -:17062:  char buf[20];
        -:17063:
    #####:17064:  while (find_next_token (&word_iterator, (unsigned int *) 0) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:17065:    ++i;
        -:17066:
    #####:17067:  sprintf (buf, "%d", i);
    #####:17068:  o = variable_buffer_output (o, buf, strlen (buf));
call    0 never executed
        -:17069:
        -:17070:
    #####:17071:  return o;
        -:17072:}
        -:17073:
        -:17074:char *
function strip_whitespace called 0 returned 0% blocks executed 0%
    #####:17075:strip_whitespace (begpp, endpp)
        -:17076:     char **begpp;
        -:17077:     char **endpp;
        -:17078:{
    #####:17079:  while (isspace (**begpp) && *begpp <= *endpp)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:17080:    (*begpp) ++;
    #####:17081:  while (isspace (**endpp) && *endpp >= *begpp)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:17082:    (*endpp) --;
    #####:17083:  return *begpp;
        -:17084:}
        -:17085:
        -:17086:int
function is_numeric called 0 returned 0% blocks executed 0%
    #####:17087:is_numeric (p)
        -:17088:     char *p;
        -:17089:{
    #####:17090:  char *end = p + strlen (p) - 1;
    #####:17091:  char *beg = p;
    #####:17092:  strip_whitespace (&p, &end);
call    0 never executed
        -:17093:
    #####:17094:  while (p <= end)
branch  0 never executed
branch  1 never executed
    #####:17095:    if (!ISDIGIT (*(p++)))  /* ISDIGIT only evals its arg once: see make.h.  */
branch  0 never executed
branch  1 never executed
    #####:17096:      return 0;
        -:17097:
    #####:17098:  return (end - beg >= 0);
        -:17099:}
        -:17100:
        -:17101:void
function check_numeric called 0 returned 0% blocks executed 0%
    #####:17102:check_numeric (s, message)
        -:17103:     char *s;
        -:17104:     char *message;
        -:17105:{
    #####:17106:  if (!is_numeric (s))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:17107:    fatal (reading_file, message);
call    0 never executed
    #####:17108:}
        -:17109:
        -:17110:
        -:17111:
        -:17112:static char *
function func_word called 0 returned 0% blocks executed 0%
    #####:17113:func_word(o, argv, funcname)
        -:17114:     char *o;
        -:17115:     char **argv;
        -:17116:     const char *funcname;
        -:17117:{
    #####:17118:  char *end_p=0;
    #####:17119:  int i=0;
    #####:17120:  char *p=0;
        -:17121:
        -:17122:  /* Check the first argument.  */
    #####:17123:  check_numeric (argv[0], _("non-numeric first argument to `word' function"));
call    0 never executed
    #####:17124:  i =  atoi (argv[0]);
        -:17125:
    #####:17126:  if (i == 0)
branch  0 never executed
branch  1 never executed
    #####:17127:    fatal (reading_file, _("the `word' function takes a positive index argument"));
call    0 never executed
        -:17128:
        -:17129:
    #####:17130:  end_p = argv[1];
    #####:17131:  while ((p = find_next_token (&end_p, 0)) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:17132:    if (--i == 0)
branch  0 never executed
branch  1 never executed
    #####:17133:      break;
        -:17134:
    #####:17135:  if (i == 0)
branch  0 never executed
branch  1 never executed
    #####:17136:    o = variable_buffer_output (o, p, end_p - p);
call    0 never executed
        -:17137:
    #####:17138:  return o;
        -:17139:}
        -:17140:
        -:17141:static char *
function func_wordlist called 0 returned 0% blocks executed 0%
    #####:17142:func_wordlist (o, argv, funcname)
        -:17143:     char *o;
        -:17144:     char **argv;
        -:17145:     const char *funcname;
        -:17146:{
    #####:17147:  int i=0;
    #####:17148:  int j=0;
        -:17149:
        -:17150:  /* Check the first argument.  */
    #####:17151:  check_numeric (argv[0],
call    0 never executed
        -:17152:		 _("non-numeric first argument to `wordlist' function"));
    #####:17153:  i =atoi(argv[0]);
    #####:17154:  check_numeric (argv[1],
call    0 never executed
        -:17155:		 _("non-numeric second argument to `wordlist' function"));
        -:17156:
    #####:17157:  j = atoi(argv[1]);
        -:17158:
        -:17159:
        -:17160:  {
        -:17161:    char *p;
    #####:17162:    char *end_p = argv[2];
        -:17163:
    #####:17164:    int start = (i < j) ? i : j;
    #####:17165:    int count = j -i ;
    #####:17166:    if (count < 0)
branch  0 never executed
branch  1 never executed
    #####:17167:      count = - count;
    #####:17168:    count ++;
        -:17169:
        -:17170:
        -:17171:
    #####:17172:    while (((p = find_next_token (&end_p, 0)) != 0) && --start)
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -:17173:      {}
    #####:17174:    if (p)
branch  0 never executed
branch  1 never executed
        -:17175:      {
    #####:17176:	while (--count && (find_next_token (&end_p, 0) != 0))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:17177:	  {}
    #####:17178:	o = variable_buffer_output (o, p, end_p - p);
call    0 never executed
        -:17179:      }
        -:17180:  }
    #####:17181:  return o;
        -:17182:}
        -:17183:
        -:17184:static char*
function func_findstring called 0 returned 0% blocks executed 0%
    #####:17185:func_findstring(o, argv, funcname)
        -:17186:     char *o;
        -:17187:     char **argv;
        -:17188:     const char *funcname;
        -:17189:{
        -:17190:  /* Find the first occurrence of the first string in the second.  */
    #####:17191:  int i = strlen (argv[0]);
    #####:17192:  if (sindex (argv[1], 0, argv[0], i) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:17193:    o = variable_buffer_output (o, argv[0], i);
call    0 never executed
        -:17194:
    #####:17195:  return o;
        -:17196:}
        -:17197:
        -:17198:static char *
function func_foreach called 0 returned 0% blocks executed 0%
    #####:17199:func_foreach (o, argv, funcname)
        -:17200:     char *o;
        -:17201:     char **argv;
        -:17202:     const char *funcname;
        -:17203:{
        -:17204:  /* expand only the first two.  */
    #####:17205:  char *varname = expand_argument (argv[0], argv[1] - 1);
call    0 never executed
    #####:17206:  char *list = expand_argument (argv[1], argv[2] -1);
call    0 never executed
    #####:17207:  char *body = savestring (argv[2], argv[3] - argv[2] - 1);
call    0 never executed
        -:17208:
    #####:17209:  int len =0;
    #####:17210:  char *list_iterator = list;
        -:17211:  char *p;
    #####:17212:  register struct variable *var=0;
    #####:17213:  int doneany =0;
        -:17214:
    #####:17215:  push_new_variable_scope ();
call    0 never executed
    #####:17216:  var = define_variable (varname, strlen (varname), "", o_automatic, 0);
call    0 never executed
        -:17217:
        -:17218:  /* loop through LIST,  put the value in VAR and expand BODY */
    #####:17219:  while ((p = find_next_token (&list_iterator, &len)) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:17220:    {
    #####:17221:      char *result = 0;
        -:17222:
        -:17223:      {
    #####:17224:	char save = p[len];
        -:17225:
    #####:17226:	p[len] = '\0';
    #####:17227:	free (var->value);
    #####:17228:	var->value = (char *) xstrdup ((char*) p);
call    0 never executed
    #####:17229:	p[len] = save;
        -:17230:      }
        -:17231:
    #####:17232:      result = allocated_variable_expand (body);
call    0 never executed
        -:17233:
    #####:17234:      o = variable_buffer_output (o, result, strlen (result));
call    0 never executed
    #####:17235:      o = variable_buffer_output (o, " ", 1);
call    0 never executed
    #####:17236:      doneany = 1;
    #####:17237:      free (result);
        -:17238:    }
        -:17239:
    #####:17240:  if (doneany)
branch  0 never executed
branch  1 never executed
        -:17241:    /* Kill the last space.  */
    #####:17242:    --o;
        -:17243:
    #####:17244:  pop_variable_scope ();
call    0 never executed
    #####:17245:  free (varname);
    #####:17246:  free (list);
    #####:17247:  free (body);
        -:17248:
    #####:17249:  return o;
        -:17250:}
        -:17251:
        -:17252:struct a_word
        -:17253:{
        -:17254:  struct a_word *next;
        -:17255:  char *str;
        -:17256:  int matched;
        -:17257:};
        -:17258:
        -:17259:static char *
function func_filter_filterout called 0 returned 0% blocks executed 0%
    #####:17260:func_filter_filterout (o, argv, funcname)
        -:17261:     char *o;
        -:17262:     char **argv;
        -:17263:     const char *funcname;
        -:17264:{
    #####:17265:  struct  a_word   *wordhead =0;
    #####:17266:  struct  a_word *wordtail =0;
        -:17267:
    #####:17268:  int is_filter = streq (funcname, "filter");
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:17269:  char *patterns = argv[0];
        -:17270:
        -:17271:
        -:17272:  char *p;
        -:17273:  int len;
    #####:17274:  char *word_iterator = argv[1];
        -:17275:
        -:17276:  /* Chop ARGV[1] up into words and then run each pattern through.  */
    #####:17277:  while ((p = find_next_token (&word_iterator, &len)) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:17278:    {
    #####:17279:      struct a_word *w = (struct a_word *)alloca(sizeof(struct a_word));
    #####:17280:      if (wordhead == 0)
branch  0 never executed
branch  1 never executed
    #####:17281:	wordhead = w;
        -:17282:      else
    #####:17283:	wordtail->next = w;
    #####:17284:      wordtail = w;
        -:17285:
    #####:17286:      if (*word_iterator != '\0')
branch  0 never executed
branch  1 never executed
    #####:17287:	++word_iterator;
    #####:17288:      p[len] = '\0';
    #####:17289:      w->str = p;
    #####:17290:      w->matched = 0;
        -:17291:    }
        -:17292:
    #####:17293:  if (wordhead != 0)
branch  0 never executed
branch  1 never executed
        -:17294:    {
    #####:17295:      struct  a_word *wp =0;
    #####:17296:      char *pat_iterator = patterns;
    #####:17297:      int doneany = 0;
        -:17298:
    #####:17299:      wordtail->next = 0;
        -:17300:
        -:17301:
        -:17302:      /* Run each pattern through the words, killing words.  */
    #####:17303:      while ((p = find_next_token (&pat_iterator, &len)) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:17304:	{
        -:17305:	  char *percent;
    #####:17306:	  char save = p[len];
    #####:17307:	  p[len] = '\0';
        -:17308:
    #####:17309:	  percent = find_percent (p);
call    0 never executed
    #####:17310:	  for (wp = wordhead; wp != 0; wp = wp->next)
branch  0 never executed
branch  1 never executed
    #####:17311:	    wp->matched |= (percent == 0 ? streq (p, wp->str)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:17312:			    : pattern_matches (p, percent, wp->str));
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:17313:
    #####:17314:	  p[len] = save;
        -:17315:	}
        -:17316:
        -:17317:      /* Output the words that matched (or didn't, for filter-out).  */
    #####:17318:      for (wp = wordhead; wp != 0; wp = wp->next)
branch  0 never executed
branch  1 never executed
    #####:17319:	if (is_filter ? wp->matched : !wp->matched)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:17320:	  {
    #####:17321:	    o = variable_buffer_output (o, wp->str, strlen (wp->str));
call    0 never executed
    #####:17322:	    o = variable_buffer_output (o, " ", 1);
call    0 never executed
    #####:17323:	    doneany = 1;
        -:17324:	  }
        -:17325:
    #####:17326:      if (doneany)
branch  0 never executed
branch  1 never executed
        -:17327:	/* Kill the last space.  */
    #####:17328:	--o;
        -:17329:    }
        -:17330:
    #####:17331:  return o;
        -:17332:}
        -:17333:
        -:17334:
        -:17335:static char *
function func_strip called 1542 returned 100% blocks executed 28%
     1542:17336:func_strip(o, argv, funcname)
        -:17337:     char *o;
        -:17338:     char **argv;
        -:17339:     const char *funcname;
        -:17340:{
     1542:17341:  char *p = argv[0];
     1542:17342:  int doneany =0;
        -:17343:
     1542:17344:  while (*p != '\0')
branch  0 taken 0
branch  1 taken 1542 (fallthrough)
        -:17345:    {
    #####:17346:      int i=0;
    #####:17347:      char *word_start=0;
        -:17348:
    #####:17349:      while (isspace(*p))
branch  0 never executed
branch  1 never executed
    #####:17350:	++p;
    #####:17351:      word_start = p;
    #####:17352:      for (i=0; *p != '\0' && !isspace(*p); ++p, ++i)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:17353:	{}
    #####:17354:      if (!i)
branch  0 never executed
branch  1 never executed
    #####:17355:	break;
    #####:17356:      o = variable_buffer_output (o, word_start, i);
call    0 never executed
    #####:17357:      o = variable_buffer_output (o, " ", 1);
call    0 never executed
    #####:17358:      doneany = 1;
        -:17359:    }
        -:17360:
     1542:17361:  if (doneany)
branch  0 taken 0 (fallthrough)
branch  1 taken 1542
        -:17362:    /* Kill the last space.  */
    #####:17363:    --o;
     1542:17364:  return o;
        -:17365:}
        -:17366:
        -:17367:/*
        -:17368:  Print a warning or fatal message.
        -:17369:*/
        -:17370:static char *
function func_error called 0 returned 0% blocks executed 0%
    #####:17371:func_error (o, argv, funcname)
        -:17372:     char *o;
        -:17373:     char **argv;
        -:17374:     const char *funcname;
        -:17375:{
        -:17376:  char **argvp;
        -:17377:  char *msg, *p;
        -:17378:  int len;
        -:17379:
        -:17380:  /* The arguments will be broken on commas.  Rather than create yet
        -:17381:     another special case where function arguments aren't broken up,
        -:17382:     just create a format string that puts them back together.  */
    #####:17383:  for (len=0, argvp=argv; *argvp != 0; ++argvp)
branch  0 never executed
branch  1 never executed
    #####:17384:    len += strlen(*argvp) + 2;
        -:17385:
    #####:17386:  p = msg = alloca (len + 1);
        -:17387:
    #####:17388:  for (argvp=argv; argvp[1] != 0; ++argvp)
branch  0 never executed
branch  1 never executed
        -:17389:    {
    #####:17390:      strcpy(p, *argvp);
    #####:17391:      p += strlen(*argvp);
    #####:17392:      *(p++) = ',';
    #####:17393:      *(p++) = ' ';
        -:17394:    }
    #####:17395:  strcpy(p, *argvp);
        -:17396:
    #####:17397:  if (*funcname == 'e')
branch  0 never executed
branch  1 never executed
    #####:17398:    fatal (reading_file, "%s", msg);
call    0 never executed
        -:17399:
        -:17400:  /* The warning function expands to the empty string.  */
    #####:17401:  error (reading_file, "%s", msg);
call    0 never executed
        -:17402:
    #####:17403:  return o;
        -:17404:}
        -:17405:
        -:17406:
        -:17407:/*
        -:17408:  chop argv[0] into words, and sort them.
        -:17409: */
        -:17410:static char *
function func_sort called 0 returned 0% blocks executed 0%
    #####:17411:func_sort (o, argv, funcname)
        -:17412:     char *o;
        -:17413:     char **argv;
        -:17414:     const char *funcname;
        -:17415:{
    #####:17416:  char **words = 0;
    #####:17417:  int nwords = 0;
    #####:17418:  register int wordi = 0;
        -:17419:
        -:17420:  /* Chop ARGV[0] into words and put them in WORDS.  */
    #####:17421:  char *t = argv[0];
    #####:17422:  char *p=0;
        -:17423:  int len;
        -:17424:  int i;
        -:17425:
    #####:17426:  while ((p = find_next_token (&t, &len)) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:17427:    {
    #####:17428:      if (wordi >= nwords - 1)
branch  0 never executed
branch  1 never executed
        -:17429:	{
    #####:17430:	  nwords = 2* nwords + 5;
    #####:17431:	  words = (char **) xrealloc ((char *) words,
call    0 never executed
        -:17432:				      nwords * sizeof (char *));
        -:17433:	}
    #####:17434:      words[wordi++] = savestring (p, len);
call    0 never executed
        -:17435:    }
        -:17436:
    #####:17437:  if (!wordi)
branch  0 never executed
branch  1 never executed
    #####:17438:    return o;
        -:17439:
        -:17440:  /* Now sort the list of words.  */
    #####:17441:  qsort ((char *) words, wordi, sizeof (char *), alpha_compare);
call    0 never executed
        -:17442:
        -:17443:  /* Now write the sorted list.  */
    #####:17444:  for (i = 0; i < wordi; ++i)
branch  0 never executed
branch  1 never executed
        -:17445:    {
    #####:17446:      len = strlen (words[i]);
    #####:17447:      if (i == wordi - 1 || strlen (words[i + 1]) != len
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:17448:          || strcmp (words[i], words[i + 1]))
branch  0 never executed
branch  1 never executed
        -:17449:        {
    #####:17450:          o = variable_buffer_output (o, words[i], len);
call    0 never executed
    #####:17451:          o = variable_buffer_output (o, " ", 1);
call    0 never executed
        -:17452:        }
    #####:17453:      free (words[i]);
        -:17454:    }
        -:17455:  /* Kill the last space.  */
    #####:17456:  --o;
        -:17457:
    #####:17458:  free (words);
        -:17459:
    #####:17460:  return o;
        -:17461:}
        -:17462:
        -:17463:/*
        -:17464:  $(if condition,true-part[,false-part])
        -:17465:
        -:17466:  CONDITION is false iff it evaluates to an empty string.  White
        -:17467:  space before and after condition are stripped before evaluation.
        -:17468:
        -:17469:  If CONDITION is true, then TRUE-PART is evaluated, otherwise FALSE-PART is
        -:17470:  evaluated (if it exists).  Because only one of the two PARTs is evaluated,
        -:17471:  you can use $(if ...) to create side-effects (with $(shell ...), for
        -:17472:  example).
        -:17473:*/
        -:17474:
        -:17475:static char *
function func_if called 0 returned 0% blocks executed 0%
    #####:17476:func_if (o, argv, funcname)
        -:17477:     char *o;
        -:17478:     char **argv;
        -:17479:     const char *funcname;
        -:17480:{
    #####:17481:  char *begp = argv[0];
    #####:17482:  char *endp = argv[1]-1;
    #####:17483:  int result = 0;
        -:17484:
        -:17485:  /* Find the result of the condition: if we have a value, and it's not
        -:17486:     empty, the condition is true.  If we don't have a value, or it's the
        -:17487:     empty string, then it's false.  */
        -:17488:
    #####:17489:  strip_whitespace (&begp, &endp);
call    0 never executed
        -:17490:
    #####:17491:  if (begp < endp)
branch  0 never executed
branch  1 never executed
        -:17492:    {
    #####:17493:      char *expansion = expand_argument (begp, endp);
call    0 never executed
        -:17494:
    #####:17495:      result = strlen (expansion);
    #####:17496:      free (expansion);
        -:17497:    }
        -:17498:
        -:17499:  /* If the result is true (1) we want to eval the first argument, and if
        -:17500:     it's false (0) we want to eval the second.  If the argument doesn't
        -:17501:     exist we do nothing, otherwise expand it and add to the buffer.  */
        -:17502:
    #####:17503:  argv += 1 + !result;
branch  0 never executed
branch  1 never executed
        -:17504:
    #####:17505:  if (argv[0] != NULL && argv[1] != NULL)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:17506:    {
        -:17507:      char *expansion;
    #####:17508:      char **endp = argv+1;
        -:17509:
        -:17510:      /* If we're doing the else-clause, make sure we concatenate any
        -:17511:         potential extra arguments into the last argument.  */
    #####:17512:      if (!result)
branch  0 never executed
branch  1 never executed
    #####:17513:        while (*endp && **endp != '\0')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:17514:          ++endp;
        -:17515:
    #####:17516:      expansion = expand_argument (*argv, *endp-1);
call    0 never executed
        -:17517:
    #####:17518:      o = variable_buffer_output (o, expansion, strlen (expansion));
call    0 never executed
    #####:17519:      free (expansion);
        -:17520:    }
        -:17521:
    #####:17522:  return o;
        -:17523:}
        -:17524:
        -:17525:static char *
function func_wildcard called 0 returned 0% blocks executed 0%
    #####:17526:func_wildcard(o, argv, funcname)
        -:17527:     char *o;
        -:17528:     char **argv;
        -:17529:     const char *funcname;
        -:17530:{
        -:17531:
        -:17532:#ifdef _AMIGA
        -:17533:   o = wildcard_expansion (argv[0], o);
        -:17534:#else
    #####:17535:   char *p = string_glob (argv[0]);
call    0 never executed
    #####:17536:   o = variable_buffer_output (o, p, strlen (p));
call    0 never executed
        -:17537:#endif
    #####:17538:   return o;
        -:17539:}
        -:17540:
        -:17541:/*
        -:17542:  \r  is replaced on UNIX as well. Is this desirable?
        -:17543: */
        -:17544:void
function fold_newlines called 0 returned 0% blocks executed 0%
    #####:17545:fold_newlines (buffer, length)
        -:17546:     char *buffer;
        -:17547:     int *length;
        -:17548:{
    #####:17549:  char *dst = buffer;
    #####:17550:  char *src = buffer;
    #####:17551:  char *last_nonnl = buffer -1;
    #####:17552:  src[*length] = 0;
    #####:17553:  for (; *src != '\0'; ++src)
branch  0 never executed
branch  1 never executed
        -:17554:    {
    #####:17555:      if (src[0] == '\r' && src[1] == '\n')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:17556:	continue;
    #####:17557:      if (*src == '\n')
branch  0 never executed
branch  1 never executed
        -:17558:	{
    #####:17559:	  *dst++ = ' ';
        -:17560:	}
        -:17561:      else
        -:17562:	{
    #####:17563:	  last_nonnl = dst;
    #####:17564:	  *dst++ = *src;
        -:17565:	}
        -:17566:    }
    #####:17567:  *(++last_nonnl) = '\0';
    #####:17568:  *length = last_nonnl - buffer;
    #####:17569:}
        -:17570:
        -:17571:
        -:17572:
        -:17573:int shell_function_pid = 0, shell_function_completed;
        -:17574:
        -:17575:
        -:17576:#ifdef WINDOWS32
        -:17577:/*untested*/
        -:17578:
        -:17579:#include <windows.h>
        -:17580:#include <io.h>
        -:17581:#include "sub_proc.h"
        -:17582:#undef stderr
        -:17583:#define stderr stdout
        -:17584:
        -:17585:
        -:17586:void
        -:17587:windows32_openpipe (int *pipedes, int *pid_p, char **command_argv, char **envp)
        -:17588:{
        -:17589:  SECURITY_ATTRIBUTES saAttr;
        -:17590:  HANDLE hIn;
        -:17591:  HANDLE hErr;
        -:17592:  HANDLE hChildOutRd;
        -:17593:  HANDLE hChildOutWr;
        -:17594:  HANDLE hProcess;
        -:17595:
        -:17596:
        -:17597:  saAttr.nLength = sizeof(SECURITY_ATTRIBUTES);
        -:17598:  saAttr.bInheritHandle = TRUE;
        -:17599:  saAttr.lpSecurityDescriptor = NULL;
        -:17600:
        -:17601:  if (DuplicateHandle(GetCurrentProcess(),
        -:17602:		      GetStdHandle(STD_INPUT_HANDLE),
        -:17603:		      GetCurrentProcess(),
        -:17604:		      &hIn,
        -:17605:		      0,
        -:17606:		      TRUE,
        -:17607:		      DUPLICATE_SAME_ACCESS) == FALSE) {
        -:17608:    fatal (NILF, _("create_child_process: DuplicateHandle(In) failed (e=%d)\n"),
        -:17609:	   GetLastError());
        -:17610:
        -:17611:  }
        -:17612:  if (DuplicateHandle(GetCurrentProcess(),
        -:17613:		      GetStdHandle(STD_ERROR_HANDLE),
        -:17614:		      GetCurrentProcess(),
        -:17615:		      &hErr,
        -:17616:		      0,
        -:17617:		      TRUE,
        -:17618:		      DUPLICATE_SAME_ACCESS) == FALSE) {
        -:17619:    fatal (NILF, _("create_child_process: DuplicateHandle(Err) failed (e=%d)\n"),
        -:17620:	   GetLastError());
        -:17621:  }
        -:17622:
        -:17623:  if (!CreatePipe(&hChildOutRd, &hChildOutWr, &saAttr, 0))
        -:17624:    fatal (NILF, _("CreatePipe() failed (e=%d)\n"), GetLastError());
        -:17625:
        -:17626:
        -:17627:
        -:17628:  hProcess = process_init_fd(hIn, hChildOutWr, hErr);
        -:17629:
        -:17630:  if (!hProcess)
        -:17631:    fatal (NILF, _("windows32_openpipe (): process_init_fd() failed\n"));
        -:17632:
        -:17633:  else
        -:17634:    process_register(hProcess);
        -:17635:
        -:17636:  /* make sure that CreateProcess() has Path it needs */
        -:17637:  sync_Path_environment();
        -:17638:
        -:17639:  if (!process_begin(hProcess, command_argv, envp, command_argv[0], NULL))
        -:17640:    *pid_p = (int) hProcess;
        -:17641:  else
        -:17642:    fatal (NILF, _("windows32_openpipe (): unable to launch process (e=%d)\n"),
        -:17643:	   process_last_err(hProcess));
        -:17644:
        -:17645:  /* set up to read data from child */
        -:17646:  pipedes[0] = _open_osfhandle((long) hChildOutRd, O_RDONLY);
        -:17647:
        -:17648:  /* this will be closed almost right away */
        -:17649:  pipedes[1] = _open_osfhandle((long) hChildOutWr, O_APPEND);
        -:17650:}
        -:17651:#endif
        -:17652:
        -:17653:
        -:17654:#ifdef __MSDOS__
        -:17655:FILE *
        -:17656:msdos_openpipe (int* pipedes, int *pidp, char *text)
        -:17657:{
        -:17658:  FILE *fpipe=0;
        -:17659:  /* MSDOS can't fork, but it has `popen'.  */
        -:17660:  struct variable *sh = lookup_variable ("SHELL", 5);
        -:17661:  int e;
        -:17662:  extern int dos_command_running, dos_status;
        -:17663:
        -:17664:  /* Make sure not to bother processing an empty line.  */
        -:17665:  while (isblank (*text))
        -:17666:    ++text;
        -:17667:  if (*text == '\0')
        -:17668:    return 0;
        -:17669:
        -:17670:  if (sh)
        -:17671:    {
        -:17672:      char buf[PATH_MAX + 7];
        -:17673:      /* This makes sure $SHELL value is used by $(shell), even
        -:17674:	 though the target environment is not passed to it.  */
        -:17675:      sprintf (buf, "SHELL=%s", sh->value);
        -:17676:      putenv (buf);
        -:17677:    }
        -:17678:
        -:17679:  e = errno;
        -:17680:  errno = 0;
        -:17681:  dos_command_running = 1;
        -:17682:  dos_status = 0;
        -:17683:  /* If dos_status becomes non-zero, it means the child process
        -:17684:     was interrupted by a signal, like SIGINT or SIGQUIT.  See
        -:17685:     fatal_error_signal in commands.c.  */
        -:17686:  fpipe = popen (text, "rt");
        -:17687:  dos_command_running = 0;
        -:17688:  if (!fpipe || dos_status)
        -:17689:    {
        -:17690:      pipedes[0] = -1;
        -:17691:      *pidp = -1;
        -:17692:      if (dos_status)
        -:17693:	errno = EINTR;
        -:17694:      else if (errno == 0)
        -:17695:	errno = ENOMEM;
        -:17696:      shell_function_completed = -1;
        -:17697:    }
        -:17698:  else
        -:17699:    {
        -:17700:      pipedes[0] = fileno (fpipe);
        -:17701:      *pidp = 42; /* Yes, the Meaning of Life, the Universe, and Everything! */
        -:17702:      errno = e;
        -:17703:      shell_function_completed = 1;
        -:17704:    }
        -:17705:  return fpipe;
        -:17706:}
        -:17707:#endif
        -:17708:
        -:17709:/*
        -:17710:  Do shell spawning, with the naughty bits for different OSes.
        -:17711: */
        -:17712:
        -:17713:#ifdef VMS
        -:17714:
        -:17715:/* VMS can't do $(shell ...)  */
        -:17716:#define func_shell 0
        -:17717:
        -:17718:#else
        -:17719:#ifndef _AMIGA
        -:17720:static char *
function func_shell called 0 returned 0% blocks executed 0%
    #####:17721:func_shell (o, argv, funcname)
        -:17722:     char *o;
        -:17723:     char **argv;
        -:17724:     const char *funcname;
        -:17725:{
    #####:17726:  char* batch_filename = NULL;
        -:17727:  int i;
        -:17728:
        -:17729:#ifdef __MSDOS__
        -:17730:  FILE *fpipe;
        -:17731:#endif
        -:17732:  char **command_argv;
        -:17733:  char *error_prefix;
        -:17734:  char **envp;
        -:17735:  int pipedes[2];
        -:17736:  int pid;
        -:17737:
        -:17738:#ifndef __MSDOS__
        -:17739:  /* Construct the argument list.  */
    #####:17740:  command_argv = construct_command_argv (argv[0],
call    0 never executed
        -:17741:					 (char **) NULL, (struct file *) 0,
        -:17742:                                         &batch_filename);
    #####:17743:  if (command_argv == 0)
branch  0 never executed
branch  1 never executed
    #####:17744:    return o;
        -:17745:#endif
        -:17746:
        -:17747:  /* Using a target environment for `shell' loses in cases like:
        -:17748:     export var = $(shell echo foobie)
        -:17749:     because target_environment hits a loop trying to expand $(var)
        -:17750:     to put it in the environment.  This is even more confusing when
        -:17751:     var was not explicitly exported, but just appeared in the
        -:17752:     calling environment.  */
        -:17753:
    #####:17754:  envp = environ;
        -:17755:
        -:17756:  /* For error messages.  */
    #####:17757:  if (reading_file != 0)
branch  0 never executed
branch  1 never executed
        -:17758:    {
    #####:17759:      error_prefix = (char *) alloca (strlen(reading_file->filenm)+11+4);
    #####:17760:      sprintf (error_prefix,
    #####:17761:	       "%s:%lu: ", reading_file->filenm, reading_file->lineno);
        -:17762:    }
        -:17763:  else
    #####:17764:    error_prefix = "";
        -:17765:
        -:17766:#ifdef WINDOWS32
        -:17767:  windows32_openpipe (pipedes, &pid, command_argv, envp);
        -:17768:#else /* WINDOWS32 */
        -:17769:
        -:17770:# ifdef __MSDOS__
        -:17771:  fpipe = msdos_openpipe (pipedes, &pid, argv[0]);
        -:17772:  if (pipedes[0] < 0)
        -:17773:    {
        -:17774:      perror_with_name (error_prefix, "pipe");
        -:17775:      return o;
        -:17776:    }
        -:17777:# else
    #####:17778:  if (pipe (pipedes) < 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:17779:    {
    #####:17780:      perror_with_name (error_prefix, "pipe");
call    0 never executed
    #####:17781:      return o;
        -:17782:    }
        -:17783:
    #####:17784:  pid = vfork ();
call    0 never executed
    #####:17785:  if (pid < 0)
branch  0 never executed
branch  1 never executed
    #####:17786:    perror_with_name (error_prefix, "fork");
call    0 never executed
    #####:17787:  else if (pid == 0)
branch  0 never executed
branch  1 never executed
    #####:17788:    child_execute_job (0, pipedes[1], command_argv, envp);
call    0 never executed
        -:17789:  else
        -:17790:# endif /* ! __MSDOS__ */
        -:17791:
        -:17792:#endif /* WINDOWS32 */
        -:17793:    {
        -:17794:      /* We are the parent.  */
        -:17795:
        -:17796:      char *buffer;
        -:17797:      unsigned int maxlen;
        -:17798:      int cc;
        -:17799:
        -:17800:      /* Record the PID for reap_children.  */
    #####:17801:      shell_function_pid = pid;
        -:17802:#ifndef  __MSDOS__
    #####:17803:      shell_function_completed = 0;
        -:17804:
        -:17805:      /* Free the storage only the child needed.  */
    #####:17806:      free (command_argv[0]);
    #####:17807:      free ((char *) command_argv);
        -:17808:
        -:17809:      /* Close the write side of the pipe.  */
    #####:17810:      (void) close (pipedes[1]);
call    0 never executed
        -:17811:#endif
        -:17812:
        -:17813:      /* Set up and read from the pipe.  */
        -:17814:
    #####:17815:      maxlen = 200;
    #####:17816:      buffer = (char *) xmalloc (maxlen + 1);
call    0 never executed
        -:17817:
        -:17818:      /* Read from the pipe until it gets EOF.  */
    #####:17819:      i = 0;
        -:17820:      do
        -:17821:	{
    #####:17822:	  if (i == maxlen)
branch  0 never executed
branch  1 never executed
        -:17823:	    {
    #####:17824:	      maxlen += 512;
    #####:17825:	      buffer = (char *) xrealloc (buffer, maxlen + 1);
call    0 never executed
        -:17826:	    }
        -:17827:
    #####:17828:	  errno = 0;
    #####:17829:	  cc = read (pipedes[0], &buffer[i], maxlen - i);
call    0 never executed
    #####:17830:	  if (cc > 0)
branch  0 never executed
branch  1 never executed
    #####:17831:	    i += cc;
        -:17832:	}
    #####:17833:      while (cc > 0 || EINTR_SET);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:17834:
        -:17835:      /* Close the read side of the pipe.  */
        -:17836:#ifdef  __MSDOS__
        -:17837:      if (fpipe)
        -:17838:	(void) pclose (fpipe);
        -:17839:#else
    #####:17840:      (void) close (pipedes[0]);
call    0 never executed
        -:17841:#endif
        -:17842:
        -:17843:      /* Loop until child_handler sets shell_function_completed
        -:17844:	 to the status of our child shell.  */
    #####:17845:      while (shell_function_completed == 0)
branch  0 never executed
branch  1 never executed
    #####:17846:	reap_children (1, 0);
call    0 never executed
        -:17847:
    #####:17848:      if (batch_filename) {
branch  0 never executed
branch  1 never executed
    #####:17849:	if (debug_flag)
branch  0 never executed
branch  1 never executed
    #####:17850:	  printf(_("Cleaning up temporary batch file %s\n"), batch_filename);
call    0 never executed
    #####:17851:	remove(batch_filename);
call    0 never executed
    #####:17852:	free(batch_filename);
        -:17853:      }
    #####:17854:      shell_function_pid = 0;
        -:17855:
        -:17856:      /* The child_handler function will set shell_function_completed
        -:17857:	 to 1 when the child dies normally, or to -1 if it
        -:17858:	 dies with status 127, which is most likely an exec fail.  */
        -:17859:
    #####:17860:      if (shell_function_completed == -1)
branch  0 never executed
branch  1 never executed
        -:17861:	{
        -:17862:	  /* This most likely means that the execvp failed,
        -:17863:	     so we should just write out the error message
        -:17864:	     that came in over the pipe from the child.  */
    #####:17865:	  fputs (buffer, stderr);
call    0 never executed
    #####:17866:	  fflush (stderr);
call    0 never executed
        -:17867:	}
        -:17868:      else
        -:17869:	{
        -:17870:	  /* The child finished normally.  Replace all
        -:17871:	     newlines in its output with spaces, and put
        -:17872:	     that in the variable output buffer.  */
    #####:17873:	  fold_newlines (buffer, &i);
call    0 never executed
    #####:17874:	  o = variable_buffer_output (o, buffer, i);
call    0 never executed
        -:17875:	}
        -:17876:
    #####:17877:      free (buffer);
        -:17878:    }
        -:17879:
    #####:17880:  return o;
        -:17881:}
        -:17882:
        -:17883:#else	/* _AMIGA */
        -:17884:
        -:17885:/* Do the Amiga version of func_shell.  */
        -:17886:
        -:17887:static char *
        -:17888:func_shell (char *o, char **argv, const char *funcname)
        -:17889:{
        -:17890:  /* Amiga can't fork nor spawn, but I can start a program with
        -:17891:     redirection of my choice.  However, this means that we
        -:17892:     don't have an opportunity to reopen stdout to trap it.  Thus,
        -:17893:     we save our own stdout onto a new descriptor and dup a temp
        -:17894:     file's descriptor onto our stdout temporarily.  After we
        -:17895:     spawn the shell program, we dup our own stdout back to the
        -:17896:     stdout descriptor.  The buffer reading is the same as above,
        -:17897:     except that we're now reading from a file.  */
        -:17898:
        -:17899:#include <dos/dos.h>
        -:17900:#include <proto/dos.h>
        -:17901:#undef stderr
        -:17902:#define stderr stdout
        -:17903:
        -:17904:  BPTR child_stdout;
        -:17905:  char tmp_output[FILENAME_MAX];
        -:17906:  unsigned int maxlen = 200;
        -:17907:  int cc, i;
        -:17908:  char * buffer, * ptr;
        -:17909:  char ** aptr;
        -:17910:  int len = 0;
        -:17911:  char* batch_filename = NULL;
        -:17912:
        -:17913:  /* Construct the argument list.  */
        -:17914:  command_argv = construct_command_argv (argv[0], (char **) NULL,
        -:17915:                                         (struct file *) 0, &batch_filename);
        -:17916:  if (command_argv == 0)
        -:17917:    return o;
        -:17918:
        -:17919:
        -:17920:  strcpy (tmp_output, "t:MakeshXXXXXXXX");
        -:17921:  mktemp (tmp_output);
        -:17922:  child_stdout = Open (tmp_output, MODE_NEWFILE);
        -:17923:
        -:17924:  for (aptr=command_argv; *aptr; aptr++)
        -:17925:    len += strlen (*aptr) + 1;
        -:17926:
        -:17927:  buffer = xmalloc (len + 1);
        -:17928:  ptr = buffer;
        -:17929:
        -:17930:  for (aptr=command_argv; *aptr; aptr++)
        -:17931:    {
        -:17932:      strcpy (ptr, *aptr);
        -:17933:      ptr += strlen (ptr) + 1;
        -:17934:      *ptr ++ = ' ';
        -:17935:      *ptr = 0;
        -:17936:    }
        -:17937:
        -:17938:  ptr[-1] = '\n';
        -:17939:
        -:17940:  Execute (buffer, NULL, child_stdout);
        -:17941:  free (buffer);
        -:17942:
        -:17943:  Close (child_stdout);
        -:17944:
        -:17945:  child_stdout = Open (tmp_output, MODE_OLDFILE);
        -:17946:
        -:17947:  buffer = xmalloc (maxlen);
        -:17948:  i = 0;
        -:17949:  do
        -:17950:    {
        -:17951:      if (i == maxlen)
        -:17952:	{
        -:17953:	  maxlen += 512;
        -:17954:	  buffer = (char *) xrealloc (buffer, maxlen + 1);
        -:17955:	}
        -:17956:
        -:17957:      cc = Read (child_stdout, &buffer[i], maxlen - i);
        -:17958:      if (cc > 0)
        -:17959:	i += cc;
        -:17960:    } while (cc > 0);
        -:17961:
        -:17962:  Close (child_stdout);
        -:17963:
        -:17964:  fold_newlines (buffer, &i);
        -:17965:  o = variable_buffer_output (o, buffer, i);
        -:17966:  free (buffer);
        -:17967:  return o;
        -:17968:}
        -:17969:#endif  /* _AMIGA */
        -:17970:#endif  /* !VMS */
        -:17971:
        -:17972:#ifdef EXPERIMENTAL
        -:17973:
        -:17974:/*
        -:17975:  equality. Return is string-boolean, ie, the empty string is false.
        -:17976: */
        -:17977:static char *
        -:17978:func_eq (char* o, char **argv, char *funcname)
        -:17979:{
        -:17980:  int result = ! strcmp (argv[0], argv[1]);
        -:17981:  o = variable_buffer_output (o,  result ? "1" : "", result);
        -:17982:  return o;
        -:17983:}
        -:17984:
        -:17985:
        -:17986:/*
        -:17987:  string-boolean not operator.
        -:17988: */
        -:17989:static char *
        -:17990:func_not (char* o, char **argv, char *funcname)
        -:17991:{
        -:17992:  char * s = argv[0];
        -:17993:  int result = 0;
        -:17994:  while (isspace (*s))
        -:17995:    s++;
        -:17996:  result = ! (*s);
        -:17997:  o = variable_buffer_output (o,  result ? "1" : "", result);
        -:17998:  return o;
        -:17999:}
        -:18000:#endif
        -:18001:
        -:18002:
        -:18003:#define STRING_SIZE_TUPLE(_s) (_s), (sizeof(_s)-1)
        -:18004:
        -:18005:/* Lookup table for builtin functions.
        -:18006:
        -:18007:   This doesn't have to be sorted; we use a straight lookup.  We might gain
        -:18008:   some efficiency by moving most often used functions to the start of the
        -:18009:   table.
        -:18010:
        -:18011:   If REQUIRED_ARGS is positive, the function takes exactly that many
        -:18012:   arguments.  All subsequent text is included with the last argument.  So,
        -:18013:   since $(sort a,b,c) takes only one argument, it will be the full string
        -:18014:   "a,b,c".  If the value is negative, it's the minimum number of arguments.
        -:18015:   A function can have more, but if it has less an error is generated.
        -:18016:
        -:18017:   EXPAND_ARGS means that all arguments should be expanded before invocation.
        -:18018:   Functions that do namespace tricks (foreach) don't automatically expand.  */
        -:18019:
        -:18020:static char *func_call PARAMS((char *o, char **argv, const char *funcname));
        -:18021:
        -:18022:
        -:18023:static struct function_table_entry function_table[] =
        -:18024:{
        -:18025: /* Name/size */                    /* ARG EXP? Function */
        -:18026:  { STRING_SIZE_TUPLE("addprefix"),     2,  1,  func_addsuffix_addprefix},
        -:18027:  { STRING_SIZE_TUPLE("addsuffix"),     2,  1,  func_addsuffix_addprefix},
        -:18028:  { STRING_SIZE_TUPLE("basename"),      1,  1,  func_basename_dir},
        -:18029:  { STRING_SIZE_TUPLE("dir"),           1,  1,  func_basename_dir},
        -:18030:  { STRING_SIZE_TUPLE("notdir"),        1,  1,  func_notdir_suffix},
        -:18031:  { STRING_SIZE_TUPLE("subst"),         3,  1,  func_subst},
        -:18032:  { STRING_SIZE_TUPLE("suffix"),        1,  1,  func_notdir_suffix},
        -:18033:  { STRING_SIZE_TUPLE("filter"),        2,  1,  func_filter_filterout},
        -:18034:  { STRING_SIZE_TUPLE("filter-out"),    2,  1,  func_filter_filterout},
        -:18035:  { STRING_SIZE_TUPLE("findstring"),    2,  1,  func_findstring},
        -:18036:  { STRING_SIZE_TUPLE("firstword"),     1,  1,  func_firstword},
        -:18037:  { STRING_SIZE_TUPLE("join"),          2,  1,  func_join},
        -:18038:  { STRING_SIZE_TUPLE("patsubst"),      3,  1,  func_patsubst},
        -:18039:  { STRING_SIZE_TUPLE("shell"),         1,  1,  func_shell},
        -:18040:  { STRING_SIZE_TUPLE("sort"),          1,  1,  func_sort},
        -:18041:  { STRING_SIZE_TUPLE("strip"),         1,  1,  func_strip},
        -:18042:  { STRING_SIZE_TUPLE("wildcard"),      1,  1,  func_wildcard},
        -:18043:  { STRING_SIZE_TUPLE("word"),          2,  1,  func_word},
        -:18044:  { STRING_SIZE_TUPLE("wordlist"),      3,  1,  func_wordlist},
        -:18045:  { STRING_SIZE_TUPLE("words"),         1,  1,  func_words},
        -:18046:  { STRING_SIZE_TUPLE("origin"),        1,  1,  func_origin},
        -:18047:  { STRING_SIZE_TUPLE("foreach"),       3,  0,  func_foreach},
        -:18048:  { STRING_SIZE_TUPLE("call"),         -1,  1,  func_call},
        -:18049:  { STRING_SIZE_TUPLE("error"),         1,  1,  func_error},
        -:18050:  { STRING_SIZE_TUPLE("warning"),       1,  1,  func_error},
        -:18051:  { STRING_SIZE_TUPLE("if"),           -2,  0,  func_if},
        -:18052:#ifdef EXPERIMENTAL
        -:18053:  { STRING_SIZE_TUPLE("eq"),            2,  1,  func_eq},
        -:18054:  { STRING_SIZE_TUPLE("not"),           1,  1,  func_not},
        -:18055:#endif
        -:18056:  { 0 }
        -:18057:};
        -:18058:
        -:18059:
        -:18060:/* These must come after the definition of function_table[].  */
        -:18061:
        -:18062:static char *
function expand_builtin_function called 1542 returned 100% blocks executed 67%
     1542:18063:expand_builtin_function (o, argc, argv, entry_p)
        -:18064:     char *o;
        -:18065:     int argc;
        -:18066:     char **argv;
        -:18067:     struct function_table_entry *entry_p;
        -:18068:{
     1542:18069:  int min = (entry_p->required_args > 0
     1542:18070:             ? entry_p->required_args
        -:18071:             : -entry_p->required_args);
        -:18072:
     1542:18073:  if (argc < min)
branch  0 taken 0 (fallthrough)
branch  1 taken 1542
    #####:18074:    fatal (reading_file,
call    0 never executed
        -:18075:           _("Insufficient number of arguments (%d) to function `%s'"),
        -:18076:           argc, entry_p->name);
        -:18077:
     1542:18078:  if (!entry_p->func_ptr)
branch  0 taken 0 (fallthrough)
branch  1 taken 1542
    #####:18079:    fatal (reading_file, _("Unimplemented on this platform: function `%s'"),
call    0 never executed
        -:18080:           entry_p->name);
        -:18081:
     1542:18082:  return entry_p->func_ptr (o, argv, entry_p->name);
call    0 returned 1542
        -:18083:}
        -:18084:
        -:18085:/* Check for a function invocation in *STRINGP.  *STRINGP points at the
        -:18086:   opening ( or { and is not null-terminated.  If a function invocation
        -:18087:   is found, expand it into the buffer at *OP, updating *OP, incrementing
        -:18088:   *STRINGP past the reference and returning nonzero.  If not, return zero.  */
        -:18089:
        -:18090:int
function handle_function called 5400 returned 100% blocks executed 82%
     5400:18091:handle_function (op, stringp)
        -:18092:     char **op;
        -:18093:     char **stringp;
        -:18094:{
        -:18095:  const struct function_table_entry *entry_p;
     5400:18096:  char openparen = (*stringp)[0];
    5400*:18097:  char closeparen = openparen == '(' ? ')' : '}';
branch  0 taken 5400 (fallthrough)
branch  1 taken 0
     5400:18098:  char *beg = *stringp + 1;
        -:18099:  char *endref;
     5400:18100:  int count = 0;
        -:18101:  char *argbeg;
        -:18102:  register char *p;
        -:18103:  char **argv, **argvp;
        -:18104:  int nargs;
        -:18105:
     5400:18106:  entry_p = lookup_function (function_table, beg);
call    0 returned 5400
        -:18107:
     5400:18108:  if (!entry_p)
branch  0 taken 3858 (fallthrough)
branch  1 taken 1542
     3858:18109:    return 0;
        -:18110:
        -:18111:  /* We have found a call to a builtin function.  Find the end of the
        -:18112:     arguments, and do the function.  */
        -:18113:
     1542:18114:  endref = beg + entry_p->len;
        -:18115:
        -:18116:  /* Space after function name isn't part of the args.  */
     1542:18117:  p = next_token (endref);
call    0 returned 1542
     1542:18118:  argbeg = p;
        -:18119:
        -:18120:  /* Find the end of the function invocation, counting nested use of
        -:18121:     whichever kind of parens we use.  Since we're looking, count commas
        -:18122:     to get a rough estimate of how many arguments we might have.  The
        -:18123:     count might be high, but it'll never be low.  */
        -:18124:
    13878:18125:  for (nargs=1; *p != '\0'; ++p)
branch  0 taken 13878
branch  1 taken 0 (fallthrough)
    13878:18126:    if (*p == ',')
branch  0 taken 0 (fallthrough)
branch  1 taken 13878
    #####:18127:      ++nargs;
    13878:18128:    else if (*p == openparen)
branch  0 taken 1542 (fallthrough)
branch  1 taken 12336
     1542:18129:      ++count;
    12336:18130:    else if (*p == closeparen && --count < 0)
branch  0 taken 3084 (fallthrough)
branch  1 taken 9252
branch  2 taken 1542 (fallthrough)
branch  3 taken 1542
     1542:18131:      break;
        -:18132:
     1542:18133:  if (count >= 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 1542
    #####:18134:    fatal (reading_file,
        -:18135:	   _("unterminated call to function `%s': missing `%c'"),
    #####:18136:	   entry_p->name, closeparen);
call    0 never executed
        -:18137:
        -:18138:  /* Get some memory to store the arg pointers.  */
     1542:18139:  argvp = argv = (char **) alloca (sizeof(char *) * (nargs + 2));
        -:18140:
        -:18141:  /* Chop the string into arguments, then store the end pointer and a nul.
        -:18142:     If REQUIRED_ARGS is positive, as soon as we hit that many assume the
        -:18143:     rest of the string is part of the last argument.  */
     1542:18144:  *argvp = argbeg;
     1542:18145:  nargs = 1;
     1542:18146:  while (entry_p->required_args < 0 || nargs < entry_p->required_args)
branch  0 taken 0
branch  1 taken 1542 (fallthrough)
branch  2 taken 0
branch  3 taken 1542 (fallthrough)
        -:18147:    {
    #####:18148:      char *next = find_next_argument (openparen, closeparen, *argvp, p);
call    0 never executed
        -:18149:
    #####:18150:      if (!next)
branch  0 never executed
branch  1 never executed
    #####:18151:	break;
        -:18152:
    #####:18153:      *(++argvp) = next+1;
    #####:18154:      ++nargs;
        -:18155:    }
        -:18156:
     1542:18157:  *(++argvp) = p+1;
     1542:18158:  *(++argvp) = 0;
        -:18159:
        -:18160:  /* If we should expand, do it.  */
     1542:18161:  if (entry_p->expand_args)
branch  0 taken 1542 (fallthrough)
branch  1 taken 0
        -:18162:    {
     3084:18163:      for (argvp=argv; argvp[1] != 0; ++argvp)
branch  0 taken 1542
branch  1 taken 1542 (fallthrough)
     1542:18164:	*argvp = expand_argument (*argvp, argvp[1]-1);
call    0 returned 1542
        -:18165:
        -:18166:      /* end pointer doesn't make sense for expanded stuff.  */
     1542:18167:      *argvp = 0;
        -:18168:    }
        -:18169:
        -:18170:  /* Finally!  Run the function...  */
     1542:18171:  *op = expand_builtin_function (*op, nargs, argv, entry_p);
call    0 returned 1542
        -:18172:
        -:18173:  /* If we allocated memory for the expanded args, free it again.  */
     1542:18174:  if (entry_p->expand_args)
branch  0 taken 1542 (fallthrough)
branch  1 taken 0
     3084:18175:    for (argvp=argv; *argvp != 0; ++argvp)
branch  0 taken 1542
branch  1 taken 1542 (fallthrough)
     1542:18176:      free (*argvp);
        -:18177:
     1542:18178:  *stringp = p;
        -:18179:
     1542:18180:  return 1;
        -:18181:}
        -:18182:
        -:18183:
        -:18184:/* User-defined functions.  Expand the first argument as either a builtin
        -:18185:   function or a make variable, in the context of the rest of the arguments
        -:18186:   assigned to $1, $2, ... $N.  $0 is the name of the function.  */
        -:18187:
        -:18188:static char *
function func_call called 0 returned 0% blocks executed 0%
    #####:18189:func_call (o, argv, funcname)
        -:18190:     char *o;
        -:18191:     char **argv;
        -:18192:     const char *funcname;
        -:18193:{
        -:18194:  char *fname;
        -:18195:  int flen;
        -:18196:  char *body;
        -:18197:  int i;
        -:18198:  const struct function_table_entry *entry_p;
        -:18199:
        -:18200:  /* Calling nothing is a no-op.  */
    #####:18201:  if (*argv[0] == '\0')
branch  0 never executed
branch  1 never executed
    #####:18202:    return o;
        -:18203:
        -:18204:  /* There is no way to define a variable with a space in the name, so strip
        -:18205:     trailing whitespace as a favor to the user.  */
        -:18206:
    #####:18207:  flen = strlen (argv[0]);
    #####:18208:  fname = argv[0] + flen - 1;
    #####:18209:  while (isspace (*fname))
branch  0 never executed
branch  1 never executed
    #####:18210:    --fname;
    #####:18211:  fname[1] = '\0';
        -:18212:
    #####:18213:  flen = fname - argv[0] + 1;
    #####:18214:  fname = argv[0];
        -:18215:
        -:18216:  /* Are we invoking a builtin function?  */
        -:18217:
    #####:18218:  entry_p = lookup_function (function_table, fname);
call    0 never executed
        -:18219:
    #####:18220:  if (entry_p)
branch  0 never executed
branch  1 never executed
        -:18221:    {
    #####:18222:      for (i=0; argv[i+1]; ++i)
branch  0 never executed
branch  1 never executed
        -:18223:	;
        -:18224:
    #####:18225:      return expand_builtin_function (o, i, argv + 1, entry_p);
call    0 never executed
        -:18226:    }
        -:18227:
        -:18228:  /* No, so the first argument is the name of a variable to be expanded and
        -:18229:     interpreted as a function.  Create the variable reference.  */
    #####:18230:  body = alloca (flen + 4);
    #####:18231:  body[0]='$';
    #####:18232:  body[1]='(';
    #####:18233:  strcpy (body + 2, fname);
    #####:18234:  body[flen+2]=')';
    #####:18235:  body[flen+3]= '\0';
        -:18236:
        -:18237:  /* Set up arguments $(1) .. $(N).  $(0) is the function name.  */
        -:18238:
    #####:18239:  push_new_variable_scope ();
call    0 never executed
        -:18240:
    #####:18241:  for (i=0; *argv; ++i, ++argv)
branch  0 never executed
branch  1 never executed
        -:18242:    {
        -:18243:      char num[11];
        -:18244:
    #####:18245:      sprintf (num, "%d", i);
    #####:18246:      define_variable (num, strlen (num), *argv, o_automatic, 0);
call    0 never executed
        -:18247:    }
        -:18248:
        -:18249:  /* Expand the body in the context of the arguments, adding the result to
        -:18250:     the variable buffer.  */
        -:18251:
    #####:18252:  o = variable_expand_string (o, body, flen+3);
call    0 never executed
        -:18253:
    #####:18254:  pop_variable_scope ();
call    0 never executed
        -:18255:
    #####:18256:  return o + strlen(o);
        -:18257:}
        -:18258:
        -:18259:
        -:18260:
        -:18261:/*************************************************************
        -:18262:  ============================================================
        -:18263:  ************************************************************
        -:18264:  ============================================================
        -:18265:  ************************************************************
        -:18266:                         vpath.c
        -:18267:  ************************************************************
        -:18268:  ============================================================
        -:18269:  ************************************************************
        -:18270:  ============================================================
        -:18271:  *************************************************************/
        -:18272:
        -:18273:/* Implementation of pattern-matching file search paths for GNU Make.
        -:18274:Copyright (C) 1988,89,91,92,93,94,95,96,97 Free Software Foundation, Inc.
        -:18275:This file is part of GNU Make.
        -:18276:
        -:18277:GNU Make is free software; you can redistribute it and/or modify
        -:18278:it under the terms of the GNU General Public License as published by
        -:18279:the Free Software Foundation; either version 2, or (at your option)
        -:18280:any later version.
        -:18281:
        -:18282:GNU Make is distributed in the hope that it will be useful,
        -:18283:but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:18284:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:18285:GNU General Public License for more details.
        -:18286:
        -:18287:You should have received a copy of the GNU General Public License
        -:18288:along with GNU Make; see the file COPYING.  If not, write to
        -:18289:the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
        -:18290:Boston, MA 02111-1307, USA.  */
        -:18291:
        -:18292:/* #include "make.h"  <- modification by J.Ruthruff, 7/27 */
        -:18293:/* #include "filedef.h"  <- modification by J.Ruthruff, 7/27 */
        -:18294:/* #include "variable.h"  <- modification by J.Ruthruff, 7/27 */
        -:18295:#undef stderr
        -:18296:#define stderr stdout
        -:18297:#ifdef WINDOWS32
        -:18298:#include "pathstuff.h"
        -:18299:#undef stderr
        -:18300:#define stderr stdout
        -:18301:#endif
        -:18302:
        -:18303:
        -:18304:/* Structure used to represent a selective VPATH searchpath.  */
        -:18305:
        -:18306:struct vpath
        -:18307:  {
        -:18308:    struct vpath *next;	/* Pointer to next struct in the linked list.  */
        -:18309:    char *pattern;	/* The pattern to match.  */
        -:18310:    char *percent;	/* Pointer into `pattern' where the `%' is.  */
        -:18311:    unsigned int patlen;/* Length of the pattern.  */
        -:18312:    char **searchpath;	/* Null-terminated list of directories.  */
        -:18313:    unsigned int maxlen;/* Maximum length of any entry in the list.  */
        -:18314:  };
        -:18315:
        -:18316:/* Linked-list of all selective VPATHs.  */
        -:18317:
        -:18318:static struct vpath *vpaths;
        -:18319:
        -:18320:/* Structure for the general VPATH given in the variable.  */
        -:18321:
        -:18322:static struct vpath *general_vpath;
        -:18323:
        -:18324:/* Structure for GPATH given in the variable.  */
        -:18325:
        -:18326:static struct vpath *gpaths;
        -:18327:
        -:18328:static int selective_vpath_search PARAMS ((struct vpath *path, char **file, FILE_TIMESTAMP *mtime_ptr));
        -:18329:
        -:18330:/* Reverse the chain of selective VPATH lists so they
        -:18331:   will be searched in the order given in the makefiles
        -:18332:   and construct the list from the VPATH variable.  */
        -:18333:
        -:18334:void
function build_vpath_lists called 771 returned 100% blocks executed 58%
      771:18335:build_vpath_lists ()
        -:18336:{
      771:18337:  register struct vpath *new = 0;
        -:18338:  register struct vpath *old, *nexto;
        -:18339:  register char *p;
        -:18340:
        -:18341:  /* Reverse the chain.  */
     771*:18342:  for (old = vpaths; old != 0; old = nexto)
branch  0 taken 0
branch  1 taken 771 (fallthrough)
        -:18343:    {
    #####:18344:      nexto = old->next;
    #####:18345:      old->next = new;
    #####:18346:      new = old;
        -:18347:    }
        -:18348:
      771:18349:  vpaths = new;
        -:18350:
        -:18351:  /* If there is a VPATH variable with a nonnull value, construct the
        -:18352:     general VPATH list from it.  We use variable_expand rather than just
        -:18353:     calling lookup_variable so that it will be recursively expanded.  */
        -:18354:
        -:18355:  {
        -:18356:    /* Turn off --warn-undefined-variables while we expand SHELL and IFS.  */
      771:18357:    int save = warn_undefined_variables_flag;
      771:18358:    warn_undefined_variables_flag = 0;
        -:18359:
      771:18360:    p = variable_expand ("$(strip $(VPATH))");
call    0 returned 771
        -:18361:
      771:18362:    warn_undefined_variables_flag = save;
        -:18363:  }
        -:18364:
      771:18365:  if (*p != '\0')
branch  0 taken 0 (fallthrough)
branch  1 taken 771
        -:18366:    {
        -:18367:      /* Save the list of vpaths.  */
    #####:18368:      struct vpath *save_vpaths = vpaths;
        -:18369:
        -:18370:      /* Empty `vpaths' so the new one will have no next, and `vpaths'
        -:18371:	 will still be nil if P contains no existing directories.  */
    #####:18372:      vpaths = 0;
        -:18373:
        -:18374:      /* Parse P.  */
    #####:18375:      construct_vpath_list ("%", p);
call    0 never executed
        -:18376:
        -:18377:      /* Store the created path as the general path,
        -:18378:	 and restore the old list of vpaths.  */
    #####:18379:      general_vpath = vpaths;
    #####:18380:      vpaths = save_vpaths;
        -:18381:    }
        -:18382:
        -:18383:  /* If there is a GPATH variable with a nonnull value, construct the
        -:18384:     GPATH list from it.  We use variable_expand rather than just
        -:18385:     calling lookup_variable so that it will be recursively expanded.  */
        -:18386:
        -:18387:  {
        -:18388:    /* Turn off --warn-undefined-variables while we expand SHELL and IFS.  */
      771:18389:    int save = warn_undefined_variables_flag;
      771:18390:    warn_undefined_variables_flag = 0;
        -:18391:
      771:18392:    p = variable_expand ("$(strip $(GPATH))");
call    0 returned 771
        -:18393:
      771:18394:    warn_undefined_variables_flag = save;
        -:18395:  }
        -:18396:
      771:18397:  if (*p != '\0')
branch  0 taken 0 (fallthrough)
branch  1 taken 771
        -:18398:    {
        -:18399:      /* Save the list of vpaths.  */
    #####:18400:      struct vpath *save_vpaths = vpaths;
        -:18401:
        -:18402:      /* Empty `vpaths' so the new one will have no next, and `vpaths'
        -:18403:	 will still be nil if P contains no existing directories.  */
    #####:18404:      vpaths = 0;
        -:18405:
        -:18406:      /* Parse P.  */
    #####:18407:      construct_vpath_list ("%", p);
call    0 never executed
        -:18408:
        -:18409:      /* Store the created path as the GPATH,
        -:18410:	 and restore the old list of vpaths.  */
    #####:18411:      gpaths = vpaths;
    #####:18412:      vpaths = save_vpaths;
        -:18413:    }
      771:18414:}
        -:18415:
        -:18416:/* Construct the VPATH listing for the pattern and searchpath given.
        -:18417:
        -:18418:   This function is called to generate selective VPATH lists and also for
        -:18419:   the general VPATH list (which is in fact just a selective VPATH that
        -:18420:   is applied to everything).  The returned pointer is either put in the
        -:18421:   linked list of all selective VPATH lists or in the GENERAL_VPATH
        -:18422:   variable.
        -:18423:
        -:18424:   If SEARCHPATH is nil, remove all previous listings with the same
        -:18425:   pattern.  If PATTERN is nil, remove all VPATH listings.  Existing
        -:18426:   and readable directories that are not "." given in the searchpath
        -:18427:   separated by the path element separator (defined in make.h) are
        -:18428:   loaded into the directory hash table if they are not there already
        -:18429:   and put in the VPATH searchpath for the given pattern with trailing
        -:18430:   slashes stripped off if present (and if the directory is not the
        -:18431:   root, "/").  The length of the longest entry in the list is put in
        -:18432:   the structure as well.  The new entry will be at the head of the
        -:18433:   VPATHS chain.  */
        -:18434:
        -:18435:void
function construct_vpath_list called 0 returned 0% blocks executed 0%
    #####:18436:construct_vpath_list (pattern, dirpath)
        -:18437:     char *pattern, *dirpath;
        -:18438:{
        -:18439:  register unsigned int elem;
        -:18440:  register char *p;
        -:18441:  register char **vpath;
        -:18442:  register unsigned int maxvpath;
        -:18443:  unsigned int maxelem;
    #####:18444:  char *percent = NULL;
        -:18445:
    #####:18446:  if (pattern != 0)
branch  0 never executed
branch  1 never executed
        -:18447:    {
    #####:18448:      pattern = xstrdup (pattern);
call    0 never executed
    #####:18449:      percent = find_percent (pattern);
call    0 never executed
        -:18450:    }
        -:18451:
    #####:18452:  if (dirpath == 0)
branch  0 never executed
branch  1 never executed
        -:18453:    {
        -:18454:      /* Remove matching listings.  */
        -:18455:      register struct vpath *path, *lastpath;
        -:18456:
    #####:18457:      lastpath = 0;
    #####:18458:      path = vpaths;
    #####:18459:      while (path != 0)
branch  0 never executed
branch  1 never executed
        -:18460:	{
    #####:18461:	  struct vpath *next = path->next;
        -:18462:
    #####:18463:	  if (pattern == 0
branch  0 never executed
branch  1 never executed
    #####:18464:	      || (((percent == 0 && path->percent == 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:18465:		   || (percent - pattern == path->percent - path->pattern))
branch  0 never executed
branch  1 never executed
    #####:18466:		  && streq (pattern, path->pattern)))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -:18467:	    {
        -:18468:	      /* Remove it from the linked list.  */
    #####:18469:	      if (lastpath == 0)
branch  0 never executed
branch  1 never executed
    #####:18470:		vpaths = path->next;
        -:18471:	      else
    #####:18472:		lastpath->next = next;
        -:18473:
        -:18474:	      /* Free its unused storage.  */
    #####:18475:	      free (path->pattern);
    #####:18476:	      free ((char *) path->searchpath);
    #####:18477:	      free ((char *) path);
        -:18478:	    }
        -:18479:	  else
    #####:18480:	    lastpath = path;
        -:18481:
    #####:18482:	  path = next;
        -:18483:	}
        -:18484:
    #####:18485:      if (pattern != 0)
branch  0 never executed
branch  1 never executed
    #####:18486:	free (pattern);
    #####:18487:      return;
        -:18488:    }
        -:18489:
        -:18490:#ifdef WINDOWS32
        -:18491:    convert_vpath_to_windows32(dirpath, ';');
        -:18492:#endif
        -:18493:
        -:18494:  /* Figure out the maximum number of VPATH entries and put it in
        -:18495:     MAXELEM.  We start with 2, one before the first separator and one
        -:18496:     nil (the list terminator) and increment our estimated number for
        -:18497:     each separator or blank we find.  */
    #####:18498:  maxelem = 2;
    #####:18499:  p = dirpath;
    #####:18500:  while (*p != '\0')
branch  0 never executed
branch  1 never executed
    #####:18501:    if (*p++ == PATH_SEPARATOR_CHAR || isblank (*p))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:18502:      ++maxelem;
        -:18503:
    #####:18504:  vpath = (char **) xmalloc (maxelem * sizeof (char *));
call    0 never executed
    #####:18505:  maxvpath = 0;
        -:18506:
        -:18507:  /* Skip over any initial separators and blanks.  */
    #####:18508:  p = dirpath;
    #####:18509:  while (*p == PATH_SEPARATOR_CHAR || isblank (*p))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:18510:    ++p;
        -:18511:
    #####:18512:  elem = 0;
    #####:18513:  while (*p != '\0')
branch  0 never executed
branch  1 never executed
        -:18514:    {
        -:18515:      char *v;
        -:18516:      unsigned int len;
        -:18517:
        -:18518:      /* Find the end of this entry.  */
    #####:18519:      v = p;
    #####:18520:      while (*p != '\0' && *p != PATH_SEPARATOR_CHAR && !isblank (*p))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:18521:	++p;
        -:18522:
    #####:18523:      len = p - v;
        -:18524:      /* Make sure there's no trailing slash,
        -:18525:	 but still allow "/" as a directory.  */
        -:18526:#ifdef __MSDOS__
        -:18527:      /* We need also to leave alone a trailing slash in "d:/".  */
        -:18528:      if (len > 3 || (len > 1 && v[1] != ':'))
        -:18529:#endif
    #####:18530:      if (len > 1 && p[-1] == '/')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:18531:	--len;
        -:18532:
    #####:18533:      if (len > 1 || *v != '.')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:18534:	{
    #####:18535:	  v = savestring (v, len);
call    0 never executed
        -:18536:
        -:18537:	  /* Verify that the directory actually exists.  */
        -:18538:
    #####:18539:	  if (dir_file_exists_p (v, ""))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:18540:	    {
        -:18541:	      /* It does.  Put it in the list.  */
    #####:18542:	      vpath[elem++] = dir_name (v);
call    0 never executed
    #####:18543:	      free (v);
    #####:18544:	      if (len > maxvpath)
branch  0 never executed
branch  1 never executed
    #####:18545:		maxvpath = len;
        -:18546:	    }
        -:18547:	  else
        -:18548:	    /* The directory does not exist.  Omit from the list.  */
    #####:18549:	    free (v);
        -:18550:	}
        -:18551:
        -:18552:      /* Skip over separators and blanks between entries.  */
    #####:18553:      while (*p == PATH_SEPARATOR_CHAR || isblank (*p))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:18554:	++p;
        -:18555:    }
        -:18556:
    #####:18557:  if (elem > 0)
branch  0 never executed
branch  1 never executed
        -:18558:    {
        -:18559:      struct vpath *path;
        -:18560:      /* ELEM is now incremented one element past the last
        -:18561:	 entry, to where the nil-pointer terminator goes.
        -:18562:	 Usually this is maxelem - 1.  If not, shrink down.  */
    #####:18563:      if (elem < (maxelem - 1))
branch  0 never executed
branch  1 never executed
    #####:18564:	vpath = (char **) xrealloc ((char *) vpath,
    #####:18565:				    (elem + 1) * sizeof (char *));
call    0 never executed
        -:18566:
        -:18567:      /* Put the nil-pointer terminator on the end of the VPATH list.  */
    #####:18568:      vpath[elem] = 0;
        -:18569:
        -:18570:      /* Construct the vpath structure and put it into the linked list.  */
    #####:18571:      path = (struct vpath *) xmalloc (sizeof (struct vpath));
call    0 never executed
    #####:18572:      path->searchpath = vpath;
    #####:18573:      path->maxlen = maxvpath;
    #####:18574:      path->next = vpaths;
    #####:18575:      vpaths = path;
        -:18576:
        -:18577:      /* Set up the members.  */
    #####:18578:      path->pattern = pattern;
    #####:18579:      path->percent = percent;
    #####:18580:      path->patlen = strlen (pattern);
        -:18581:    }
        -:18582:  else
        -:18583:    {
        -:18584:      /* There were no entries, so free whatever space we allocated.  */
    #####:18585:      free ((char *) vpath);
    #####:18586:      if (pattern != 0)
branch  0 never executed
branch  1 never executed
    #####:18587:	free (pattern);
        -:18588:    }
        -:18589:}
        -:18590:
        -:18591:/* Search the GPATH list for a pathname string that matches the one passed
        -:18592:   in.  If it is found, return 1.  Otherwise we return 0.  */
        -:18593:
        -:18594:int
function gpath_search called 0 returned 0% blocks executed 0%
    #####:18595:gpath_search (file, len)
        -:18596:     char *file;
        -:18597:     int len;
        -:18598:{
        -:18599:  register char **gp;
        -:18600:
    #####:18601:  if (gpaths && (len <= gpaths->maxlen))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:18602:    for (gp = gpaths->searchpath; *gp != NULL; ++gp)
branch  0 never executed
branch  1 never executed
    #####:18603:      if (strneq (*gp, file, len) && (*gp)[len] == '\0')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:18604:        return 1;
        -:18605:
    #####:18606:  return 0;
        -:18607:}
        -:18608:
        -:18609:/* Search the VPATH list whose pattern matches *FILE for a directory
        -:18610:   where the name pointed to by FILE exists.  If it is found, we set *FILE to
        -:18611:   the newly malloc'd name of the existing file, *MTIME_PTR (if MTIME_PTR is
        -:18612:   not NULL) to its modtime (or zero if no stat call was done), and return 1.
        -:18613:   Otherwise we return 0.  */
        -:18614:
        -:18615:int
function vpath_search called 107169 returned 100% blocks executed 17%
   107169:18616:vpath_search (file, mtime_ptr)
        -:18617:     char **file;
        -:18618:     FILE_TIMESTAMP *mtime_ptr;
        -:18619:{
        -:18620:  register struct vpath *v;
        -:18621:
        -:18622:  /* If there are no VPATH entries or FILENAME starts at the root,
        -:18623:     there is nothing we can do.  */
        -:18624:
   107169:18625:  if (**file == '/'
branch  0 taken 0 (fallthrough)
branch  1 taken 107169
        -:18626:#if defined (WINDOWS32) || defined (__MSDOS__)
        -:18627:      || **file == '\\'
        -:18628:      || (*file)[1] == ':'
        -:18629:#endif
    #####:18630:      || (vpaths == 0 && general_vpath == 0))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
   107169:18631:    return 0;
        -:18632:
    #####:18633:  for (v = vpaths; v != 0; v = v->next)
branch  0 never executed
branch  1 never executed
    #####:18634:    if (pattern_matches (v->pattern, v->percent, *file))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:18635:      if (selective_vpath_search (v, file, mtime_ptr))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:18636:	return 1;
        -:18637:
    #####:18638:  if (general_vpath != 0
branch  0 never executed
branch  1 never executed
    #####:18639:      && selective_vpath_search (general_vpath, file, mtime_ptr))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:18640:    return 1;
        -:18641:
    #####:18642:  return 0;
        -:18643:}
        -:18644:
        -:18645:
        -:18646:/* Search the given VPATH list for a directory where the name pointed
        -:18647:   to by FILE exists.  If it is found, we set *FILE to the newly malloc'd
        -:18648:   name of the existing file, *MTIME_PTR (if MTIME_PTR is not NULL) to
        -:18649:   its modtime (or zero if no stat call was done), and we return 1.
        -:18650:   Otherwise we return 0.  */
        -:18651:
        -:18652:static int
function selective_vpath_search called 0 returned 0% blocks executed 0%
    #####:18653:selective_vpath_search (path, file, mtime_ptr)
        -:18654:     struct vpath *path;
        -:18655:     char **file;
        -:18656:     FILE_TIMESTAMP *mtime_ptr;
        -:18657:{
        -:18658:  int not_target;
        -:18659:  char *name, *n;
        -:18660:  char *filename;
    #####:18661:  register char **vpath = path->searchpath;
    #####:18662:  unsigned int maxvpath = path->maxlen;
        -:18663:  register unsigned int i;
        -:18664:  unsigned int flen, vlen, name_dplen;
    #####:18665:  int exists = 0;
        -:18666:
        -:18667:  /* Find out if *FILE is a target.
        -:18668:     If and only if it is NOT a target, we will accept prospective
        -:18669:     files that don't exist but are mentioned in a makefile.  */
        -:18670:  {
    #####:18671:    struct file *f = lookup_file (*file);
call    0 never executed
    #####:18672:    not_target = f == 0 || !f->is_target;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:18673:  }
        -:18674:
    #####:18675:  flen = strlen (*file);
        -:18676:
        -:18677:  /* Split *FILE into a directory prefix and a name-within-directory.
        -:18678:     NAME_DPLEN gets the length of the prefix; FILENAME gets the
        -:18679:     pointer to the name-within-directory and FLEN is its length.  */
        -:18680:
    #####:18681:  n = rindex (*file, '/');
        -:18682:#if defined (WINDOWS32) || defined (__MSDOS__)
        -:18683:  /* We need the rightmost slash or backslash.  */
        -:18684:  {
        -:18685:    char *bslash = rindex(*file, '\\');
        -:18686:    if (!n || bslash > n)
        -:18687:      n = bslash;
        -:18688:  }
        -:18689:#endif
    #####:18690:  name_dplen = n != 0 ? n - *file : 0;
branch  0 never executed
branch  1 never executed
    #####:18691:  filename = name_dplen > 0 ? n + 1 : *file;
branch  0 never executed
branch  1 never executed
    #####:18692:  if (name_dplen > 0)
branch  0 never executed
branch  1 never executed
    #####:18693:    flen -= name_dplen + 1;
        -:18694:
        -:18695:  /* Allocate enough space for the biggest VPATH entry,
        -:18696:     a slash, the directory prefix that came with *FILE,
        -:18697:     another slash (although this one may not always be
        -:18698:     necessary), the filename, and a null terminator.  */
    #####:18699:  name = (char *) xmalloc (maxvpath + 1 + name_dplen + 1 + flen + 1);
call    0 never executed
        -:18700:
        -:18701:  /* Try each VPATH entry.  */
    #####:18702:  for (i = 0; vpath[i] != 0; ++i)
branch  0 never executed
branch  1 never executed
        -:18703:    {
    #####:18704:      int exists_in_cache = 0;
        -:18705:
    #####:18706:      n = name;
        -:18707:
        -:18708:      /* Put the next VPATH entry into NAME at N and increment N past it.  */
    #####:18709:      vlen = strlen (vpath[i]);
    #####:18710:      bcopy (vpath[i], n, vlen);
    #####:18711:      n += vlen;
        -:18712:
        -:18713:      /* Add the directory prefix already in *FILE.  */
    #####:18714:      if (name_dplen > 0)
branch  0 never executed
branch  1 never executed
        -:18715:	{
        -:18716:#ifndef VMS
    #####:18717:	  *n++ = '/';
        -:18718:#endif
    #####:18719:	  bcopy (*file, n, name_dplen);
    #####:18720:	  n += name_dplen;
        -:18721:	}
        -:18722:
        -:18723:#if defined (WINDOWS32) || defined (__MSDOS__)
        -:18724:      /* Cause the next if to treat backslash and slash alike.  */
        -:18725:      if (n != name && n[-1] == '\\' )
        -:18726:	n[-1] = '/';
        -:18727:#endif
        -:18728:      /* Now add the name-within-directory at the end of NAME.  */
        -:18729:#ifndef VMS
    #####:18730:      if (n != name && n[-1] != '/')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:18731:	{
    #####:18732:	  *n = '/';
    #####:18733:	  bcopy (filename, n + 1, flen + 1);
        -:18734:	}
        -:18735:      else
        -:18736:#endif
    #####:18737:	bcopy (filename, n, flen + 1);
        -:18738:
        -:18739:      /* Check if the file is mentioned in a makefile.  If *FILE is not
        -:18740:	 a target, that is enough for us to decide this file exists.
        -:18741:	 If *FILE is a target, then the file must be mentioned in the
        -:18742:	 makefile also as a target to be chosen.
        -:18743:
        -:18744:	 The restriction that *FILE must not be a target for a
        -:18745:	 makefile-mentioned file to be chosen was added by an
        -:18746:	 inadequately commented change in July 1990; I am not sure off
        -:18747:	 hand what problem it fixes.
        -:18748:
        -:18749:	 In December 1993 I loosened this restriction to allow a file
        -:18750:	 to be chosen if it is mentioned as a target in a makefile.  This
        -:18751:	 seem logical.  */
        -:18752:      {
    #####:18753:	struct file *f = lookup_file (name);
call    0 never executed
    #####:18754:	if (f != 0)
branch  0 never executed
branch  1 never executed
    #####:18755:	  exists = not_target || f->is_target;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:18756:      }
        -:18757:
    #####:18758:      if (!exists)
branch  0 never executed
branch  1 never executed
        -:18759:	{
        -:18760:	  /* That file wasn't mentioned in the makefile.
        -:18761:	     See if it actually exists.  */
        -:18762:
        -:18763:#ifdef VMS
        -:18764:	  exists_in_cache = exists = dir_file_exists_p (vpath[i], filename);
        -:18765:#else
        -:18766:	  /* Clobber a null into the name at the last slash.
        -:18767:	     Now NAME is the name of the directory to look in.  */
    #####:18768:	  *n = '\0';
        -:18769:
        -:18770:	  /* We know the directory is in the hash table now because either
        -:18771:	     construct_vpath_list or the code just above put it there.
        -:18772:	     Does the file we seek exist in it?  */
    #####:18773:	  exists_in_cache = exists = dir_file_exists_p (name, filename);
call    0 never executed
        -:18774:#endif
        -:18775:	}
        -:18776:
    #####:18777:      if (exists)
branch  0 never executed
branch  1 never executed
        -:18778:	{
        -:18779:	  /* The file is in the directory cache.
        -:18780:	     Now check that it actually exists in the filesystem.
        -:18781:	     The cache may be out of date.  When vpath thinks a file
        -:18782:	     exists, but stat fails for it, confusion results in the
        -:18783:	     higher levels.  */
        -:18784:
        -:18785:	  struct stat st;
        -:18786:
        -:18787:#ifndef VMS
        -:18788:	  /* Put the slash back in NAME.  */
    #####:18789:	  *n = '/';
        -:18790:#endif
        -:18791:
    #####:18792:	  if (!exists_in_cache	/* Makefile-mentioned file need not exist.  */
branch  0 never executed
branch  1 never executed
    #####:18793:	      || stat (name, &st) == 0) /* Does it really exist?  */
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:18794:	    {
        -:18795:	      /* We have found a file.
        -:18796:		 Store the name we found into *FILE for the caller.  */
        -:18797:
    #####:18798:	      *file = savestring (name, (n + 1 - name) + flen);
call    0 never executed
        -:18799:
    #####:18800:	      if (mtime_ptr != 0)
branch  0 never executed
branch  1 never executed
        -:18801:		/* Store the modtime into *MTIME_PTR for the caller.
        -:18802:		   If we have had no need to stat the file here,
        -:18803:		   we record a zero modtime to indicate this.  */
    #####:18804:		*mtime_ptr = (exists_in_cache
        -:18805:			      ? FILE_TIMESTAMP_STAT_MODTIME (st)
    #####:18806:			      : (FILE_TIMESTAMP) 0);
branch  0 never executed
branch  1 never executed
        -:18807:
    #####:18808:	      free (name);
    #####:18809:	      return 1;
        -:18810:	    }
        -:18811:	  else
    #####:18812:	    exists = 0;
        -:18813:	}
        -:18814:    }
        -:18815:
    #####:18816:  free (name);
    #####:18817:  return 0;
        -:18818:}
        -:18819:
        -:18820:/* Print the data base of VPATH search paths.  */
        -:18821:
        -:18822:void
function print_vpath_data_base called 384 returned 100% blocks executed 31%
      384:18823:print_vpath_data_base ()
        -:18824:{
        -:18825:  register unsigned int nvpaths;
        -:18826:  register struct vpath *v;
        -:18827:
      384:18828:  puts (_("\n# VPATH Search Paths\n"));
call    0 returned 384
        -:18829:
      384:18830:  nvpaths = 0;
     384*:18831:  for (v = vpaths; v != 0; v = v->next)
branch  0 taken 0
branch  1 taken 384 (fallthrough)
        -:18832:    {
        -:18833:      register unsigned int i;
        -:18834:
    #####:18835:      ++nvpaths;
        -:18836:
    #####:18837:      printf ("vpath %s ", v->pattern);
call    0 never executed
        -:18838:
    #####:18839:      for (i = 0; v->searchpath[i] != 0; ++i)
branch  0 never executed
branch  1 never executed
    #####:18840:	printf ("%s%c", v->searchpath[i],
call    0 never executed
    #####:18841:		v->searchpath[i + 1] == 0 ? '\n' : PATH_SEPARATOR_CHAR);
branch  0 never executed
branch  1 never executed
        -:18842:    }
        -:18843:
      384:18844:  if (vpaths == 0)
branch  0 taken 384 (fallthrough)
branch  1 taken 0
      384:18845:    puts (_("# No `vpath' search paths."));
call    0 returned 384
        -:18846:  else
    #####:18847:    printf (_("\n# %u `vpath' search paths.\n"), nvpaths);
call    0 never executed
        -:18848:
      384:18849:  if (general_vpath == 0)
branch  0 taken 384 (fallthrough)
branch  1 taken 0
      384:18850:    puts (_("\n# No general (`VPATH' variable) search path."));
call    0 returned 384
        -:18851:  else
        -:18852:    {
    #####:18853:      register char **path = general_vpath->searchpath;
        -:18854:      register unsigned int i;
        -:18855:
    #####:18856:      fputs (_("\n# General (`VPATH' variable) search path:\n# "), stdout);
call    0 never executed
        -:18857:
    #####:18858:      for (i = 0; path[i] != 0; ++i)
branch  0 never executed
branch  1 never executed
    #####:18859:	printf ("%s%c", path[i],
call    0 never executed
    #####:18860:		path[i + 1] == 0 ? '\n' : PATH_SEPARATOR_CHAR);
branch  0 never executed
branch  1 never executed
        -:18861:    }
      384:18862:}
        -:18863:
        -:18864:
        -:18865:
        -:18866:/*************************************************************
        -:18867:  ============================================================
        -:18868:  ************************************************************
        -:18869:  ============================================================
        -:18870:  ************************************************************
        -:18871:                         version.c
        -:18872:  ************************************************************
        -:18873:  ============================================================
        -:18874:  ************************************************************
        -:18875:  ============================================================
        -:18876:  *************************************************************/
        -:18877:
        -:18878:/* We use <config.h> instead of "config.h" so that a compilation
        -:18879:   using -I. -I$srcdir will use ./config.h rather than $srcdir/config.h
        -:18880:   (which it would do because make.h was found in $srcdir).  */
        -:18881:#include <config.h>
        -:18882:#undef stderr
        -:18883:#define stderr stdout
        -:18884:
        -:18885:#ifndef MAKE_HOST
        -:18886:# define MAKE_HOST "unknown"
        -:18887:#endif
        -:18888:
        -:18889:char *version_string = VERSION;
        -:18890:char *make_host = MAKE_HOST;
        -:18891:
        -:18892:/*
        -:18893:  Local variables:
        -:18894:  version-control: never
        -:18895:  End:
        -:18896: */
        -:18897:
        -:18898:
        -:18899:
        -:18900:/*************************************************************
        -:18901:  ============================================================
        -:18902:  ************************************************************
        -:18903:  ============================================================
        -:18904:  ************************************************************
        -:18905:                         ar.c
        -:18906:  ************************************************************
        -:18907:  ============================================================
        -:18908:  ************************************************************
        -:18909:  ============================================================
        -:18910:  *************************************************************/
        -:18911:
        -:18912:/* Interface to `ar' archives for GNU Make.
        -:18913:Copyright (C) 1988,89,90,91,92,93,97 Free Software Foundation, Inc.
        -:18914:This file is part of GNU Make.
        -:18915:
        -:18916:GNU Make is free software; you can redistribute it and/or modify
        -:18917:it under the terms of the GNU General Public License as published by
        -:18918:the Free Software Foundation; either version 2, or (at your option)
        -:18919:any later version.
        -:18920:
        -:18921:GNU Make is distributed in the hope that it will be useful,
        -:18922:but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:18923:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:18924:GNU General Public License for more details.
        -:18925:
        -:18926:You should have received a copy of the GNU General Public License
        -:18927:along with GNU Make; see the file COPYING.  If not, write to
        -:18928:the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
        -:18929:Boston, MA 02111-1307, USA.  */
        -:18930:
        -:18931:/* #include "make.h"  <- modification by J.Ruthruff, 7/27 */
        -:18932:#undef stderr
        -:18933:#define stderr stdout
        -:18934:
        -:18935:#ifndef	NO_ARCHIVES
        -:18936:
        -:18937:/* #include "filedef.h"  <- modification by J.Ruthruff, 7/27 */
        -:18938:/* #include "dep.h"  <- modification by J.Ruthruff, 7/27 */
        -:18939:#include <fnmatch.h>
        -:18940:#undef stderr
        -:18941:#define stderr stdout
        -:18942:
        -:18943:/* Defined in arscan.c.  */
        -:18944:extern long int ar_scan PARAMS ((char *archive, long int (*function) (), long int arg));
        -:18945:extern int ar_name_equal PARAMS ((char *name, char *mem, int truncated));
        -:18946:#ifndef VMS
        -:18947:extern int ar_member_touch PARAMS ((char *arname, char *memname));
        -:18948:#endif
        -:18949:
        -:18950:/* Return nonzero if NAME is an archive-member reference, zero if not.
        -:18951:   An archive-member reference is a name like `lib(member)'.
        -:18952:   If a name like `lib((entry))' is used, a fatal error is signaled at
        -:18953:   the attempt to use this unsupported feature.  */
        -:18954:
        -:18955:int
function ar_name called 155742 returned 100% blocks executed 33%
   155742:18956:ar_name (name)
        -:18957:     char *name;
        -:18958:{
   155742:18959:  char *p = index (name, '('), *end = name + strlen (name) - 1;
        -:18960:
  155742*:18961:  if (p == 0 || p == name || *end != ')')
branch  0 taken 0 (fallthrough)
branch  1 taken 155742
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
   155742:18962:    return 0;
        -:18963:
    #####:18964:  if (p[1] == '(' && end[-1] == ')')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:18965:    fatal (NILF, _("attempt to use unsupported feature: `%s'"), name);
call    0 never executed
        -:18966:
    #####:18967:  return 1;
        -:18968:}
        -:18969:
        -:18970:
        -:18971:/* Parse the archive-member reference NAME into the archive and member names.
        -:18972:   Put the malloc'd archive name in *ARNAME_P if ARNAME_P is non-nil;
        -:18973:   put the malloc'd member name in *MEMNAME_P if MEMNAME_P is non-nil.  */
        -:18974:
        -:18975:void
function ar_parse_name called 0 returned 0% blocks executed 0%
    #####:18976:ar_parse_name (name, arname_p, memname_p)
        -:18977:     char *name, **arname_p, **memname_p;
        -:18978:{
    #####:18979:  char *p = index (name, '('), *end = name + strlen (name) - 1;
        -:18980:
    #####:18981:  if (arname_p != 0)
branch  0 never executed
branch  1 never executed
    #####:18982:    *arname_p = savestring (name, p - name);
call    0 never executed
        -:18983:
    #####:18984:  if (memname_p != 0)
branch  0 never executed
branch  1 never executed
    #####:18985:    *memname_p = savestring (p + 1, end - (p + 1));
call    0 never executed
    #####:18986:}
        -:18987:
        -:18988:static long int ar_member_date_1 PARAMS ((int desc, char *mem, int truncated, long int hdrpos,
        -:18989:	long int datapos, long int size, long int date, int uid, int gid, int mode, char *name));
        -:18990:
        -:18991:/* Return the modtime of NAME.  */
        -:18992:
        -:18993:time_t
function ar_member_date called 0 returned 0% blocks executed 0%
    #####:18994:ar_member_date (name)
        -:18995:     char *name;
        -:18996:{
        -:18997:  char *arname;
    #####:18998:  int arname_used = 0;
        -:18999:  char *memname;
        -:19000:  long int val;
        -:19001:
    #####:19002:  ar_parse_name (name, &arname, &memname);
call    0 never executed
        -:19003:
        -:19004:  /* Make sure we know the modtime of the archive itself because we are
        -:19005:     likely to be called just before commands to remake a member are run,
        -:19006:     and they will change the archive itself.
        -:19007:
        -:19008:     But we must be careful not to enter_file the archive itself if it does
        -:19009:     not exist, because pattern_search assumes that files found in the data
        -:19010:     base exist or can be made.  */
        -:19011:  {
        -:19012:    struct file *arfile;
    #####:19013:    arfile = lookup_file (arname);
call    0 never executed
    #####:19014:    if (arfile == 0 && file_exists_p (arname))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:19015:      {
    #####:19016:	arfile = enter_file (arname);
call    0 never executed
    #####:19017:	arname_used = 1;
        -:19018:      }
        -:19019:
    #####:19020:    if (arfile != 0)
branch  0 never executed
branch  1 never executed
    #####:19021:      (void) f_mtime (arfile, 0);
call    0 never executed
        -:19022:  }
        -:19023:
    #####:19024:  val = ar_scan (arname, ar_member_date_1, (long int) memname);
call    0 never executed
        -:19025:
    #####:19026:  if (!arname_used)
branch  0 never executed
branch  1 never executed
    #####:19027:    free (arname);
    #####:19028:  free (memname);
        -:19029:
    #####:19030:  return (val <= 0 ? (time_t) -1 : (time_t) val);
branch  0 never executed
branch  1 never executed
        -:19031:}
        -:19032:
        -:19033:/* This function is called by `ar_scan' to find which member to look at.  */
        -:19034:
        -:19035:/* ARGSUSED */
        -:19036:static long int
function ar_member_date_1 called 0 returned 0% blocks executed 0%
    #####:19037:ar_member_date_1 (desc, mem, truncated,
        -:19038:		  hdrpos, datapos, size, date, uid, gid, mode, name)
        -:19039:     int desc;
        -:19040:     char *mem;
        -:19041:     int truncated;
        -:19042:     long int hdrpos, datapos, size, date;
        -:19043:     int uid, gid, mode;
        -:19044:     char *name;
        -:19045:{
    #####:19046:  return ar_name_equal (name, mem, truncated) ? date : 0;
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:19047:}
        -:19048:
        -:19049:/* Set the archive-member NAME's modtime to now.  */
        -:19050:
        -:19051:#ifdef VMS
        -:19052:int
        -:19053:ar_touch (name)
        -:19054:     char *name;
        -:19055:{
        -:19056:  error (NILF, _("touch archive member is not available on VMS"));
        -:19057:  return -1;
        -:19058:}
        -:19059:#else
        -:19060:int
function ar_touch called 0 returned 0% blocks executed 0%
    #####:19061:ar_touch (name)
        -:19062:     char *name;
        -:19063:{
        -:19064:  char *arname, *memname;
    #####:19065:  int arname_used = 0;
        -:19066:  register int val;
        -:19067:
    #####:19068:  ar_parse_name (name, &arname, &memname);
call    0 never executed
        -:19069:
        -:19070:  /* Make sure we know the modtime of the archive itself before we
        -:19071:     touch the member, since this will change the archive itself.  */
        -:19072:  {
        -:19073:    struct file *arfile;
    #####:19074:    arfile = lookup_file (arname);
call    0 never executed
    #####:19075:    if (arfile == 0)
branch  0 never executed
branch  1 never executed
        -:19076:      {
    #####:19077:	arfile = enter_file (arname);
call    0 never executed
    #####:19078:	arname_used = 1;
        -:19079:      }
        -:19080:
    #####:19081:    (void) f_mtime (arfile, 0);
call    0 never executed
        -:19082:  }
        -:19083:
    #####:19084:  val = 1;
    #####:19085:  switch (ar_member_touch (arname, memname))
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
        -:19086:    {
    #####:19087:    case -1:
    #####:19088:      error (NILF, _("touch: Archive `%s' does not exist"), arname);
call    0 never executed
    #####:19089:      break;
    #####:19090:    case -2:
    #####:19091:      error (NILF, _("touch: `%s' is not a valid archive"), arname);
call    0 never executed
    #####:19092:      break;
    #####:19093:    case -3:
    #####:19094:      perror_with_name ("touch: ", arname);
call    0 never executed
    #####:19095:      break;
    #####:19096:    case 1:
    #####:19097:      error (NILF,
call    0 never executed
        -:19098:             _("touch: Member `%s' does not exist in `%s'"), memname, arname);
    #####:19099:      break;
    #####:19100:    case 0:
    #####:19101:      val = 0;
    #####:19102:      break;
    #####:19103:    default:
    #####:19104:      error (NILF,
call    0 never executed
        -:19105:             _("touch: Bad return code from ar_member_touch on `%s'"), name);
        -:19106:    }
        -:19107:
    #####:19108:  if (!arname_used)
branch  0 never executed
branch  1 never executed
    #####:19109:    free (arname);
    #####:19110:  free (memname);
        -:19111:
    #####:19112:  return val;
        -:19113:}
        -:19114:#endif /* !VMS */
        -:19115:
        -:19116:/* State of an `ar_glob' run, passed to `ar_glob_match'.  */
        -:19117:
        -:19118:struct ar_glob_state
        -:19119:  {
        -:19120:    char *arname;
        -:19121:    char *pattern;
        -:19122:    unsigned int size;
        -:19123:    struct nameseq *chain;
        -:19124:    unsigned int n;
        -:19125:  };
        -:19126:
        -:19127:/* This function is called by `ar_scan' to match one archive
        -:19128:   element against the pattern in STATE.  */
        -:19129:
        -:19130:static long int
function ar_glob_match called 0 returned 0% blocks executed 0%
    #####:19131:ar_glob_match (desc, mem, truncated,
        -:19132:	       hdrpos, datapos, size, date, uid, gid, mode,
        -:19133:	       state)
        -:19134:     int desc;
        -:19135:     char *mem;
        -:19136:     int truncated;
        -:19137:     long int hdrpos, datapos, size, date;
        -:19138:     int uid, gid, mode;
        -:19139:     struct ar_glob_state *state;
        -:19140:{
    #####:19141:  if (fnmatch (state->pattern, mem, FNM_PATHNAME|FNM_PERIOD) == 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:19142:    {
        -:19143:      /* We have a match.  Add it to the chain.  */
    #####:19144:      struct nameseq *new = (struct nameseq *) xmalloc (state->size);
call    0 never executed
    #####:19145:      new->name = concat (state->arname, mem, ")");
call    0 never executed
    #####:19146:      new->next = state->chain;
    #####:19147:      state->chain = new;
    #####:19148:      ++state->n;
        -:19149:    }
        -:19150:
    #####:19151:  return 0L;
        -:19152:}
        -:19153:
        -:19154:/* Return nonzero if PATTERN contains any metacharacters.
        -:19155:   Metacharacters can be quoted with backslashes if QUOTE is nonzero.  */
        -:19156:int
function glob_pattern_p called 0 returned 0% blocks executed 0%
    #####:19157:glob_pattern_p (pattern, quote)
        -:19158:     const char *pattern;
        -:19159:     const int quote;
        -:19160:{
        -:19161:  register const char *p;
    #####:19162:  int open = 0;
        -:19163:
    #####:19164:  for (p = pattern; *p != '\0'; ++p)
branch  0 never executed
branch  1 never executed
    #####:19165:    switch (*p)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -:19166:      {
    #####:19167:      case '?':
        -:19168:      case '*':
    #####:19169:	return 1;
        -:19170:
    #####:19171:      case '\\':
    #####:19172:	if (quote)
branch  0 never executed
branch  1 never executed
    #####:19173:	  ++p;
    #####:19174:	break;
        -:19175:
    #####:19176:      case '[':
    #####:19177:	open = 1;
    #####:19178:	break;
        -:19179:
    #####:19180:      case ']':
    #####:19181:	if (open)
branch  0 never executed
branch  1 never executed
    #####:19182:	  return 1;
    #####:19183:	break;
        -:19184:      }
        -:19185:
    #####:19186:  return 0;
        -:19187:}
        -:19188:
        -:19189:/* Glob for MEMBER_PATTERN in archive ARNAME.
        -:19190:   Return a malloc'd chain of matching elements (or nil if none).  */
        -:19191:
        -:19192:struct nameseq *
function ar_glob called 0 returned 0% blocks executed 0%
    #####:19193:ar_glob (arname, member_pattern, size)
        -:19194:     char *arname, *member_pattern;
        -:19195:     unsigned int size;
        -:19196:{
        -:19197:  struct ar_glob_state state;
        -:19198:  char **names;
        -:19199:  struct nameseq *n;
        -:19200:  unsigned int i;
        -:19201:
    #####:19202:  if (! glob_pattern_p (member_pattern, 1))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:19203:    return 0;
        -:19204:
        -:19205:  /* Scan the archive for matches.
        -:19206:     ar_glob_match will accumulate them in STATE.chain.  */
    #####:19207:  i = strlen (arname);
    #####:19208:  state.arname = (char *) alloca (i + 2);
    #####:19209:  bcopy (arname, state.arname, i);
    #####:19210:  state.arname[i] = '(';
    #####:19211:  state.arname[i + 1] = '\0';
    #####:19212:  state.pattern = member_pattern;
    #####:19213:  state.size = size;
    #####:19214:  state.chain = 0;
    #####:19215:  state.n = 0;
    #####:19216:  (void) ar_scan (arname, ar_glob_match, (long int) &state);
call    0 never executed
        -:19217:
    #####:19218:  if (state.chain == 0)
branch  0 never executed
branch  1 never executed
    #####:19219:    return 0;
        -:19220:
        -:19221:  /* Now put the names into a vector for sorting.  */
    #####:19222:  names = (char **) alloca (state.n * sizeof (char *));
    #####:19223:  i = 0;
    #####:19224:  for (n = state.chain; n != 0; n = n->next)
branch  0 never executed
branch  1 never executed
    #####:19225:    names[i++] = n->name;
        -:19226:
        -:19227:  /* Sort them alphabetically.  */
    #####:19228:  qsort ((char *) names, i, sizeof (*names), alpha_compare);
call    0 never executed
        -:19229:
        -:19230:  /* Put them back into the chain in the sorted order.  */
    #####:19231:  i = 0;
    #####:19232:  for (n = state.chain; n != 0; n = n->next)
branch  0 never executed
branch  1 never executed
    #####:19233:    n->name = names[i++];
        -:19234:
    #####:19235:  return state.chain;
        -:19236:}
        -:19237:
        -:19238:#endif	/* Not NO_ARCHIVES.  */
        -:19239:
        -:19240:
        -:19241:
        -:19242:/*************************************************************
        -:19243:  ============================================================
        -:19244:  ************************************************************
        -:19245:  ============================================================
        -:19246:  ************************************************************
        -:19247:                         arscan.c
        -:19248:  ************************************************************
        -:19249:  ============================================================
        -:19250:  ************************************************************
        -:19251:  ============================================================
        -:19252:  *************************************************************/
        -:19253:
        -:19254:/* Library function for scanning an archive file.
        -:19255:Copyright (C) 1987,89,91,92,93,94,95,97 Free Software Foundation, Inc.
        -:19256:
        -:19257:This program is free software; you can redistribute it and/or modify
        -:19258:it under the terms of the GNU General Public License as published by
        -:19259:the Free Software Foundation; either version 2, or (at your option)
        -:19260:any later version.
        -:19261:
        -:19262:This program is distributed in the hope that it will be useful,
        -:19263:but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:19264:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:19265:GNU General Public License for more details.
        -:19266:
        -:19267:You should have received a copy of the GNU General Public License
        -:19268:along with this program; if not, write to the Free Software
        -:19269:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
        -:19270:USA.  */
        -:19271:
        -:19272:/* #include "make.h"  <- modification by J.Ruthruff, 7/27 */
        -:19273:#undef stderr
        -:19274:#define stderr stdout
        -:19275:
        -:19276:#ifdef HAVE_FCNTL_H
        -:19277:#include <fcntl.h>
        -:19278:#undef stderr
        -:19279:#define stderr stdout
        -:19280:#else
        -:19281:#include <sys/file.h>
        -:19282:#undef stderr
        -:19283:#define stderr stdout
        -:19284:#endif
        -:19285:
        -:19286:#ifndef	NO_ARCHIVES
        -:19287:
        -:19288:#ifdef VMS
        -:19289:#include <lbrdef.h>
        -:19290:#include <mhddef.h>
        -:19291:#include <credef.h>
        -:19292:#include <descrip.h>
        -:19293:#include <ctype.h>
        -:19294:#undef stderr
        -:19295:#define stderr stdout
        -:19296:#if __DECC
        -:19297:#include <unixlib.h>
        -:19298:#include <lbr$routines.h>
        -:19299:#undef stderr
        -:19300:#define stderr stdout
        -:19301:#endif
        -:19302:
        -:19303:#define uppercasify(str) {char *str1; for (str1 = str; *str1; str1++) *str1 = _toupper(*str1);}
        -:19304:
        -:19305:static void *VMS_lib_idx;
        -:19306:
        -:19307:static char *VMS_saved_memname;
        -:19308:
        -:19309:static time_t VMS_member_date;
        -:19310:
        -:19311:static long int (*VMS_function) ();
        -:19312:
        -:19313:static int
        -:19314:VMS_get_member_info (module, rfa)
        -:19315:     struct dsc$descriptor_s *module;
        -:19316:     unsigned long *rfa;
        -:19317:{
        -:19318:  int status, i;
        -:19319:  long int fnval;
        -:19320:
        -:19321:  time_t val;
        -:19322:
        -:19323:  static struct dsc$descriptor_s bufdesc =
        -:19324:    { 0, DSC$K_DTYPE_T, DSC$K_CLASS_S, NULL };
        -:19325:
        -:19326:  struct mhddef *mhd;
        -:19327:  char filename[128];
        -:19328:
        -:19329:  bufdesc.dsc$a_pointer = filename;
        -:19330:  bufdesc.dsc$w_length = sizeof (filename);
        -:19331:
        -:19332:  status = lbr$set_module (&VMS_lib_idx, rfa, &bufdesc,
        -:19333:			   &bufdesc.dsc$w_length, 0);
        -:19334:  if (! status)
        -:19335:    {
        -:19336:      error (NILF, _("lbr$set_module failed to extract module info, status = %d"),
        -:19337:	     status);
        -:19338:
        -:19339:      lbr$close (&VMS_lib_idx);
        -:19340:
        -:19341:      return 0;
        -:19342:    }
        -:19343:
        -:19344:  mhd = (struct mhddef *) filename;
        -:19345:
        -:19346:  val = decc$fix_time (&mhd->mhd$l_datim);
        -:19347:
        -:19348:  for (i = 0; i < module->dsc$w_length; i++)
        -:19349:    filename[i] = _tolower (module->dsc$a_pointer[i]);
        -:19350:
        -:19351:  filename[i] = '\0';
        -:19352:
        -:19353:  VMS_member_date = (time_t) -1;
        -:19354:
        -:19355:  fnval =
        -:19356:    (*VMS_function) (-1, filename, 0, 0, 0, 0, val, 0, 0, 0,
        -:19357:		     VMS_saved_memname);
        -:19358:
        -:19359:  if (fnval)
        -:19360:    {
        -:19361:      VMS_member_date = fnval;
        -:19362:      return 0;
        -:19363:    }
        -:19364:  else
        -:19365:    return 1;
        -:19366:}
        -:19367:
        -:19368:/* Takes three arguments ARCHIVE, FUNCTION and ARG.
        -:19369:
        -:19370:   Open the archive named ARCHIVE, find its members one by one,
        -:19371:   and for each one call FUNCTION with the following arguments:
        -:19372:     archive file descriptor for reading the data,
        -:19373:     member name,
        -:19374:     member name might be truncated flag,
        -:19375:     member header position in file,
        -:19376:     member data position in file,
        -:19377:     member data size,
        -:19378:     member date,
        -:19379:     member uid,
        -:19380:     member gid,
        -:19381:     member protection mode,
        -:19382:     ARG.
        -:19383:
        -:19384:   NOTE: on VMS systems, only name, date, and arg are meaningful!
        -:19385:
        -:19386:   The descriptor is poised to read the data of the member
        -:19387:   when FUNCTION is called.  It does not matter how much
        -:19388:   data FUNCTION reads.
        -:19389:
        -:19390:   If FUNCTION returns nonzero, we immediately return
        -:19391:   what FUNCTION returned.
        -:19392:
        -:19393:   Returns -1 if archive does not exist,
        -:19394:   Returns -2 if archive has invalid format.
        -:19395:   Returns 0 if have scanned successfully.  */
        -:19396:
        -:19397:long int
        -:19398:ar_scan (archive, function, arg)
        -:19399:     char *archive;
        -:19400:     long int (*function) ();
        -:19401:     long int arg;
        -:19402:{
        -:19403:  char *p;
        -:19404:
        -:19405:  static struct dsc$descriptor_s libdesc =
        -:19406:    { 0, DSC$K_DTYPE_T, DSC$K_CLASS_S, NULL };
        -:19407:
        -:19408:  unsigned long func = LBR$C_READ;
        -:19409:  unsigned long type = LBR$C_TYP_UNK;
        -:19410:  unsigned long index = 1;
        -:19411:
        -:19412:  int status;
        -:19413:
        -:19414:  status = lbr$ini_control (&VMS_lib_idx, &func, &type, 0);
        -:19415:
        -:19416:  if (! status)
        -:19417:    {
        -:19418:      error (NILF, _("lbr$ini_control failed with status = %d"),status);
        -:19419:      return -2;
        -:19420:    }
        -:19421:
        -:19422:  libdesc.dsc$a_pointer = archive;
        -:19423:  libdesc.dsc$w_length = strlen (archive);
        -:19424:
        -:19425:  status = lbr$open (&VMS_lib_idx, &libdesc, 0, 0, 0, 0, 0);
        -:19426:
        -:19427:  if (! status)
        -:19428:    {
        -:19429:      error (NILF, _("unable to open library `%s' to lookup member `%s'"),
        -:19430:	     archive, (char *)arg);
        -:19431:      return -1;
        -:19432:    }
        -:19433:
        -:19434:  VMS_saved_memname = (char *)arg;
        -:19435:
        -:19436:  /* For comparison, delete .obj from arg name.  */
        -:19437:
        -:19438:  p = rindex (VMS_saved_memname, '.');
        -:19439:  if (p)
        -:19440:    *p = '\0';
        -:19441:
        -:19442:  VMS_function = function;
        -:19443:
        -:19444:  VMS_member_date = (time_t) -1;
        -:19445:  lbr$get_index (&VMS_lib_idx, &index, VMS_get_member_info, 0);
        -:19446:
        -:19447:  /* Undo the damage.  */
        -:19448:  if (p)
        -:19449:    *p = '.';
        -:19450:
        -:19451:  lbr$close (&VMS_lib_idx);
        -:19452:
        -:19453:  return VMS_member_date > 0 ? VMS_member_date : 0;
        -:19454:}
        -:19455:
        -:19456:#else /* !VMS */
        -:19457:
        -:19458:/* SCO Unix's compiler defines both of these.  */
        -:19459:#ifdef	M_UNIX
        -:19460:#undef	M_XENIX
        -:19461:#endif
        -:19462:
        -:19463:/* On the sun386i and in System V rel 3, ar.h defines two different archive
        -:19464:   formats depending upon whether you have defined PORTAR (normal) or PORT5AR
        -:19465:   (System V Release 1).  There is no default, one or the other must be defined
        -:19466:   to have a nonzero value.  */
        -:19467:
        -:19468:#if (!defined (PORTAR) || PORTAR == 0) && (!defined (PORT5AR) || PORT5AR == 0)
        -:19469:#undef	PORTAR
        -:19470:#ifdef M_XENIX
        -:19471:/* According to Jim Sievert <jas1@rsvl.unisys.com>, for SCO XENIX defining
        -:19472:   PORTAR to 1 gets the wrong archive format, and defining it to 0 gets the
        -:19473:   right one.  */
        -:19474:#define PORTAR 0
        -:19475:#else
        -:19476:#define PORTAR 1
        -:19477:#endif
        -:19478:#endif
        -:19479:
        -:19480:/* On AIX, define these symbols to be sure to get both archive formats.
        -:19481:   AIX 4.3 introduced the "big" archive format to support 64-bit object
        -:19482:   files, so on AIX 4.3 systems we need to support both the "normal" and
        -:19483:   "big" archive formats.  An archive's format is indicated in the
        -:19484:   "fl_magic" field of the "FL_HDR" structure.  For a normal archive,
        -:19485:   this field will be the string defined by the AIAMAG symbol.  For a
        -:19486:   "big" archive, it will be the string defined by the AIAMAGBIG symbol
        -:19487:   (at least on AIX it works this way).
        -:19488:
        -:19489:   Note: we'll define these symbols regardless of which AIX version
        -:19490:   we're compiling on, but this is okay since we'll use the new symbols
        -:19491:   only if they're present.  */
        -:19492:#ifdef _AIX
        -:19493:# define __AR_SMALL__
        -:19494:# define __AR_BIG__
        -:19495:#endif
        -:19496:
        -:19497:#ifndef WINDOWS32
        -:19498:# include <ar.h>
        -:19499:#undef stderr
        -:19500:#define stderr stdout
        -:19501:#else
        -:19502:/* These should allow us to read Windows (VC++) libraries (according to Frank
        -:19503: * Libbrecht <frankl@abzx.belgium.hp.com>)
        -:19504: */
        -:19505:# include <windows.h>
        -:19506:# include <windef.h>
        -:19507:# include <io.h>
        -:19508:#undef stderr
        -:19509:#define stderr stdout
        -:19510:# define ARMAG      IMAGE_ARCHIVE_START
        -:19511:# define SARMAG     IMAGE_ARCHIVE_START_SIZE
        -:19512:# define ar_hdr     _IMAGE_ARCHIVE_MEMBER_HEADER
        -:19513:# define ar_name    Name
        -:19514:# define ar_mode    Mode
        -:19515:# define ar_size    Size
        -:19516:# define ar_date    Date
        -:19517:# define ar_uid     UserID
        -:19518:# define ar_gid     GroupID
        -:19519:#endif
        -:19520:
        -:19521:/* Cray's <ar.h> apparently defines this.  */
        -:19522:#ifndef	AR_HDR_SIZE
        -:19523:# define   AR_HDR_SIZE	(sizeof (struct ar_hdr))
        -:19524:#endif
        -:19525:
        -:19526:/* Takes three arguments ARCHIVE, FUNCTION and ARG.
        -:19527:
        -:19528:   Open the archive named ARCHIVE, find its members one by one,
        -:19529:   and for each one call FUNCTION with the following arguments:
        -:19530:     archive file descriptor for reading the data,
        -:19531:     member name,
        -:19532:     member name might be truncated flag,
        -:19533:     member header position in file,
        -:19534:     member data position in file,
        -:19535:     member data size,
        -:19536:     member date,
        -:19537:     member uid,
        -:19538:     member gid,
        -:19539:     member protection mode,
        -:19540:     ARG.
        -:19541:
        -:19542:   The descriptor is poised to read the data of the member
        -:19543:   when FUNCTION is called.  It does not matter how much
        -:19544:   data FUNCTION reads.
        -:19545:
        -:19546:   If FUNCTION returns nonzero, we immediately return
        -:19547:   what FUNCTION returned.
        -:19548:
        -:19549:   Returns -1 if archive does not exist,
        -:19550:   Returns -2 if archive has invalid format.
        -:19551:   Returns 0 if have scanned successfully.  */
        -:19552:
        -:19553:long int
function ar_scan called 0 returned 0% blocks executed 0%
    #####:19554:ar_scan (archive, function, arg)
        -:19555:     char *archive;
        -:19556:     long int (*function) ();
        -:19557:     long int arg;
        -:19558:{
        -:19559:#ifdef AIAMAG
        -:19560:  FL_HDR fl_header;
        -:19561:#ifdef AIAMAGBIG
        -:19562:  int big_archive = 0;
        -:19563:  FL_HDR_BIG fl_header_big;
        -:19564:#endif
        -:19565:#else
    #####:19566:  int long_name = 0;
        -:19567:#endif
    #####:19568:  char *namemap = 0;
    #####:19569:  register int desc = open (archive, O_RDONLY, 0);
call    0 never executed
    #####:19570:  if (desc < 0)
branch  0 never executed
branch  1 never executed
    #####:19571:    return -1;
        -:19572:#ifdef SARMAG
        -:19573:  {
        -:19574:    char buf[SARMAG];
    #####:19575:    register int nread = read (desc, buf, SARMAG);
call    0 never executed
    #####:19576:    if (nread != SARMAG || bcmp (buf, ARMAG, SARMAG))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:19577:      {
    #####:19578:	(void) close (desc);
call    0 never executed
    #####:19579:	return -2;
        -:19580:      }
        -:19581:  }
        -:19582:#else
        -:19583:#ifdef AIAMAG
        -:19584:  {
        -:19585:    register int nread = read (desc, (char *) &fl_header, FL_HSZ);
        -:19586:
        -:19587:    if (nread != FL_HSZ)
        -:19588:      {
        -:19589:	(void) close (desc);
        -:19590:	return -2;
        -:19591:      }
        -:19592:#ifdef AIAMAGBIG
        -:19593:    /* If this is a "big" archive, then set the flag and
        -:19594:       re-read the header into the "big" structure. */
        -:19595:    if (!bcmp (fl_header.fl_magic, AIAMAGBIG, SAIAMAG))
        -:19596:      {
        -:19597:	big_archive = 1;
        -:19598:
        -:19599:	/* seek back to beginning of archive */
        -:19600:	if (lseek (desc, 0, 0) < 0)
        -:19601:	  {
        -:19602:	    (void) close (desc);
        -:19603:	    return -2;
        -:19604:	  }
        -:19605:
        -:19606:	/* re-read the header into the "big" structure */
        -:19607:	nread = read (desc, (char *) &fl_header_big, FL_HSZ_BIG);
        -:19608:	if (nread != FL_HSZ_BIG)
        -:19609:	  {
        -:19610:	    (void) close (desc);
        -:19611:	    return -2;
        -:19612:	  }
        -:19613:      }
        -:19614:    else
        -:19615:#endif
        -:19616:       /* Check to make sure this is a "normal" archive. */
        -:19617:      if (bcmp (fl_header.fl_magic, AIAMAG, SAIAMAG))
        -:19618:	{
        -:19619:          (void) close (desc);
        -:19620:          return -2;
        -:19621:	}
        -:19622:  }
        -:19623:#else
        -:19624:  {
        -:19625:#ifndef M_XENIX
        -:19626:    int buf;
        -:19627:#else
        -:19628:    unsigned short int buf;
        -:19629:#endif
        -:19630:    register int nread = read(desc, &buf, sizeof (buf));
        -:19631:    if (nread != sizeof (buf) || buf != ARMAG)
        -:19632:      {
        -:19633:	(void) close (desc);
        -:19634:	return -2;
        -:19635:      }
        -:19636:  }
        -:19637:#endif
        -:19638:#endif
        -:19639:
        -:19640:  /* Now find the members one by one.  */
        -:19641:  {
        -:19642:#ifdef SARMAG
    #####:19643:    register long int member_offset = SARMAG;
        -:19644:#else
        -:19645:#ifdef AIAMAG
        -:19646:    long int member_offset;
        -:19647:    long int last_member_offset;
        -:19648:
        -:19649:#ifdef AIAMAGBIG
        -:19650:    if ( big_archive )
        -:19651:      {
        -:19652:	sscanf (fl_header_big.fl_fstmoff, "%20ld", &member_offset);
        -:19653:	sscanf (fl_header_big.fl_lstmoff, "%20ld", &last_member_offset);
        -:19654:      }
        -:19655:    else
        -:19656:#endif
        -:19657:      {
        -:19658:	sscanf (fl_header.fl_fstmoff, "%12ld", &member_offset);
        -:19659:	sscanf (fl_header.fl_lstmoff, "%12ld", &last_member_offset);
        -:19660:      }
        -:19661:
        -:19662:    if (member_offset == 0)
        -:19663:      {
        -:19664:	/* Empty archive.  */
        -:19665:	close (desc);
        -:19666:	return 0;
        -:19667:      }
        -:19668:#else
        -:19669:#ifndef	M_XENIX
        -:19670:    register long int member_offset = sizeof (int);
        -:19671:#else	/* Xenix.  */
        -:19672:    register long int member_offset = sizeof (unsigned short int);
        -:19673:#endif	/* Not Xenix.  */
        -:19674:#endif
        -:19675:#endif
        -:19676:
        -:19677:    while (1)
    #####:19678:      {
        -:19679:	register int nread;
        -:19680:	struct ar_hdr member_header;
        -:19681:#ifdef AIAMAGBIG
        -:19682:	struct ar_hdr_big member_header_big;
        -:19683:#endif
        -:19684:#ifdef AIAMAG
        -:19685:	char name[256];
        -:19686:	int name_len;
        -:19687:	long int dateval;
        -:19688:	int uidval, gidval;
        -:19689:	long int data_offset;
        -:19690:#else
        -:19691:	char namebuf[sizeof member_header.ar_name + 1];
        -:19692:	char *name;
        -:19693:	int is_namemap;		/* Nonzero if this entry maps long names.  */
        -:19694:#endif
        -:19695:	long int eltsize;
        -:19696:	int eltmode;
        -:19697:	long int fnval;
        -:19698:
    #####:19699:	if (off_t_equal(off_t_to_int(lseek (desc, int_to_off_t(member_offset), 0)), ZERO_off_t) < 0)
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -:19700:	  /*	if (lseek (desc, member_offset, 0) < 0) */
        -:19701:	  {
    #####:19702:	    (void) close (desc);
call    0 never executed
    #####:19703:	    return -2;
        -:19704:	  }
        -:19705:
        -:19706:#ifdef AIAMAG
        -:19707:#define       AR_MEMHDR_SZ(x) (sizeof(x) - sizeof (x._ar_name))
        -:19708:
        -:19709:#ifdef AIAMAGBIG
        -:19710:	if (big_archive)
        -:19711:	  {
        -:19712:	    nread = read (desc, (char *) &member_header_big,
        -:19713:			  AR_MEMHDR_SZ(member_header_big) );
        -:19714:
        -:19715:	    if (nread != AR_MEMHDR_SZ(member_header_big))
        -:19716:	      {
        -:19717:		(void) close (desc);
        -:19718:		return -2;
        -:19719:	      }
        -:19720:
        -:19721:	    sscanf (member_header_big.ar_namlen, "%4d", &name_len);
        -:19722:	    nread = read (desc, name, name_len);
        -:19723:
        -:19724:	    if (nread != name_len)
        -:19725:	      {
        -:19726:		(void) close (desc);
        -:19727:		return -2;
        -:19728:	      }
        -:19729:
        -:19730:	    name[name_len] = 0;
        -:19731:
        -:19732:	    sscanf (member_header_big.ar_date, "%12ld", &dateval);
        -:19733:	    sscanf (member_header_big.ar_uid, "%12d", &uidval);
        -:19734:	    sscanf (member_header_big.ar_gid, "%12d", &gidval);
        -:19735:	    sscanf (member_header_big.ar_mode, "%12o", &eltmode);
        -:19736:	    sscanf (member_header_big.ar_size, "%20ld", &eltsize);
        -:19737:
        -:19738:	    data_offset = (member_offset + AR_MEMHDR_SZ(member_header_big)
        -:19739:			   + name_len + 2);
        -:19740:	  }
        -:19741:	else
        -:19742:#endif
        -:19743:	  {
        -:19744:	    nread = read (desc, (char *) &member_header,
        -:19745:			  AR_MEMHDR_SZ(member_header) );
        -:19746:
        -:19747:	    if (nread != AR_MEMHDR_SZ(member_header))
        -:19748:	      {
        -:19749:		(void) close (desc);
        -:19750:		return -2;
        -:19751:	      }
        -:19752:
        -:19753:	    sscanf (member_header.ar_namlen, "%4d", &name_len);
        -:19754:	    nread = read (desc, name, name_len);
        -:19755:
        -:19756:	    if (nread != name_len)
        -:19757:	      {
        -:19758:		(void) close (desc);
        -:19759:		return -2;
        -:19760:	      }
        -:19761:
        -:19762:	    name[name_len] = 0;
        -:19763:
        -:19764:	    sscanf (member_header.ar_date, "%12ld", &dateval);
        -:19765:	    sscanf (member_header.ar_uid, "%12d", &uidval);
        -:19766:	    sscanf (member_header.ar_gid, "%12d", &gidval);
        -:19767:	    sscanf (member_header.ar_mode, "%12o", &eltmode);
        -:19768:	    sscanf (member_header.ar_size, "%12ld", &eltsize);
        -:19769:
        -:19770:	    data_offset = (member_offset + AR_MEMHDR_SZ(member_header)
        -:19771:			   + name_len + 2);
        -:19772:	  }
        -:19773:	data_offset += data_offset % 2;
        -:19774:
        -:19775:	fnval =
        -:19776:	  (*function) (desc, name, 0,
        -:19777:		       member_offset, data_offset, eltsize,
        -:19778:		       dateval, uidval, gidval,
        -:19779:		       eltmode, arg);
        -:19780:
        -:19781:#else	/* Not AIAMAG.  */
    #####:19782:	nread = read (desc, (char *) &member_header, AR_HDR_SIZE);
call    0 never executed
    #####:19783:	if (nread == 0)
branch  0 never executed
branch  1 never executed
        -:19784:	  /* No data left means end of file; that is OK.  */
    #####:19785:	  break;
        -:19786:
    #####:19787:	if (nread != AR_HDR_SIZE
branch  0 never executed
branch  1 never executed
        -:19788:#if defined(ARFMAG) || defined(ARFZMAG)
    #####:19789:	    || (
        -:19790:# ifdef ARFMAG
    #####:19791:                bcmp (member_header.ar_fmag, ARFMAG, 2)
branch  0 never executed
branch  1 never executed
        -:19792:# else
        -:19793:                1
        -:19794:# endif
        -:19795:                &&
        -:19796:# ifdef ARFZMAG
        -:19797:                bcmp (member_header.ar_fmag, ARFZMAG, 2)
        -:19798:# else
        -:19799:                1
        -:19800:# endif
        -:19801:               )
        -:19802:#endif
        -:19803:	    )
        -:19804:	  {
    #####:19805:	    (void) close (desc);
call    0 never executed
    #####:19806:	    return -2;
        -:19807:	  }
        -:19808:
    #####:19809:	name = namebuf;
    #####:19810:	bcopy (member_header.ar_name, name, sizeof member_header.ar_name);
        -:19811:	{
    #####:19812:	  register char *p = name + sizeof member_header.ar_name;
        -:19813:	  do
    #####:19814:	    *p = '\0';
    #####:19815:	  while (p > name && *--p == ' ');
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:19816:
        -:19817:#ifndef AIAMAG
        -:19818:	  /* If the member name is "//" or "ARFILENAMES/" this may be
        -:19819:	     a list of file name mappings.  The maximum file name
        -:19820: 	     length supported by the standard archive format is 14
        -:19821: 	     characters.  This member will actually always be the
        -:19822: 	     first or second entry in the archive, but we don't check
        -:19823: 	     that.  */
    #####:19824: 	  is_namemap = (!strcmp (name, "//")
    #####:19825:			|| !strcmp (name, "ARFILENAMES/"));
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:19826:#endif	/* Not AIAMAG. */
        -:19827:	  /* On some systems, there is a slash after each member name.  */
    #####:19828:	  if (*p == '/')
branch  0 never executed
branch  1 never executed
    #####:19829:	    *p = '\0';
        -:19830:
        -:19831:#ifndef AIAMAG
        -:19832: 	  /* If the member name starts with a space or a slash, this
        -:19833: 	     is an index into the file name mappings (used by GNU ar).
        -:19834: 	     Otherwise if the member name looks like #1/NUMBER the
        -:19835: 	     real member name appears in the element data (used by
        -:19836: 	     4.4BSD).  */
    #####:19837: 	  if (! is_namemap
branch  0 never executed
branch  1 never executed
    #####:19838: 	      && (name[0] == ' ' || name[0] == '/')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:19839: 	      && namemap != 0)
branch  0 never executed
branch  1 never executed
        -:19840:	    {
    #####:19841:	      name = namemap + atoi (name + 1);
    #####:19842:	      long_name = 1;
        -:19843:	    }
    #####:19844: 	  else if (name[0] == '#'
branch  0 never executed
branch  1 never executed
    #####:19845: 		   && name[1] == '1'
branch  0 never executed
branch  1 never executed
    #####:19846: 		   && name[2] == '/')
branch  0 never executed
branch  1 never executed
        -:19847: 	    {
    #####:19848: 	      int namesize = atoi (name + 3);
        -:19849:
    #####:19850: 	      name = (char *) alloca (namesize + 1);
    #####:19851: 	      nread = read (desc, name, namesize);
call    0 never executed
    #####:19852: 	      if (nread != namesize)
branch  0 never executed
branch  1 never executed
        -:19853: 		{
    #####:19854: 		  close (desc);
call    0 never executed
    #####:19855: 		  return -2;
        -:19856: 		}
    #####:19857: 	      name[namesize] = '\0';
        -:19858:
    #####:19859:	      long_name = 1;
        -:19860: 	    }
        -:19861:#endif /* Not AIAMAG. */
        -:19862:	}
        -:19863:
        -:19864:#ifndef	M_XENIX
    #####:19865:	sscanf (member_header.ar_mode, "%o", &eltmode);
    #####:19866:	eltsize = atol (member_header.ar_size);
        -:19867:#else	/* Xenix.  */
        -:19868:	eltmode = (unsigned short int) member_header.ar_mode;
        -:19869:	eltsize = member_header.ar_size;
        -:19870:#endif	/* Not Xenix.  */
        -:19871:
        -:19872:	fnval =
    #####:19873:	  (*function) (desc, name, ! long_name, member_offset,
call    0 never executed
        -:19874:		       member_offset + AR_HDR_SIZE, eltsize,
        -:19875:#ifndef	M_XENIX
        -:19876:		       atol (member_header.ar_date),
        -:19877:		       atoi (member_header.ar_uid),
        -:19878:		       atoi (member_header.ar_gid),
        -:19879:#else	/* Xenix.  */
        -:19880:		       member_header.ar_date,
        -:19881:		       member_header.ar_uid,
        -:19882:		       member_header.ar_gid,
        -:19883:#endif	/* Not Xenix.  */
        -:19884:		       eltmode, arg);
        -:19885:
        -:19886:#endif  /* AIAMAG.  */
        -:19887:
    #####:19888:	if (fnval)
branch  0 never executed
branch  1 never executed
        -:19889:	  {
    #####:19890:	    (void) close (desc);
call    0 never executed
    #####:19891:	    return fnval;
        -:19892:	  }
        -:19893:
        -:19894:#ifdef AIAMAG
        -:19895:	if (member_offset == last_member_offset)
        -:19896:	  /* End of the chain.  */
        -:19897:	  break;
        -:19898:
        -:19899:#ifdef AIAMAGBIG
        -:19900:	if (big_archive)
        -:19901:          sscanf (member_header_big.ar_nxtmem, "%20ld", &member_offset);
        -:19902:	else
        -:19903:#endif
        -:19904:	  sscanf (member_header.ar_nxtmem, "%12ld", &member_offset);
        -:19905:
        -:19906:	if (lseek (desc, member_offset, 0) != member_offset)
        -:19907:	  {
        -:19908:	    (void) close (desc);
        -:19909:	    return -2;
        -:19910:	  }
        -:19911:#else
        -:19912:
        -:19913: 	/* If this member maps archive names, we must read it in.  The
        -:19914: 	   name map will always precede any members whose names must
        -:19915: 	   be mapped.  */
    #####:19916:	if (is_namemap)
branch  0 never executed
branch  1 never executed
        -:19917: 	  {
        -:19918: 	    char *clear;
        -:19919: 	    char *limit;
        -:19920:
    #####:19921: 	    namemap = (char *) alloca (eltsize);
    #####:19922: 	    nread = read (desc, namemap, eltsize);
call    0 never executed
    #####:19923: 	    if (nread != eltsize)
branch  0 never executed
branch  1 never executed
        -:19924: 	      {
    #####:19925: 		(void) close (desc);
call    0 never executed
    #####:19926: 		return -2;
        -:19927: 	      }
        -:19928:
        -:19929: 	    /* The names are separated by newlines.  Some formats have
        -:19930: 	       a trailing slash.  Null terminate the strings for
        -:19931: 	       convenience.  */
    #####:19932: 	    limit = namemap + eltsize;
    #####:19933: 	    for (clear = namemap; clear < limit; clear++)
branch  0 never executed
branch  1 never executed
        -:19934: 	      {
    #####:19935: 		if (*clear == '\n')
branch  0 never executed
branch  1 never executed
        -:19936: 		  {
    #####:19937: 		    *clear = '\0';
    #####:19938: 		    if (clear[-1] == '/')
branch  0 never executed
branch  1 never executed
    #####:19939: 		      clear[-1] = '\0';
        -:19940: 		  }
        -:19941: 	      }
        -:19942:
    #####:19943:	    is_namemap = 0;
        -:19944: 	  }
        -:19945:
    #####:19946:	member_offset += AR_HDR_SIZE + eltsize;
    #####:19947:	if (member_offset % 2 != 0)
branch  0 never executed
branch  1 never executed
    #####:19948:	  member_offset++;
        -:19949:#endif
        -:19950:      }
        -:19951:  }
        -:19952:
    #####:19953:  close (desc);
call    0 never executed
    #####:19954:  return 0;
        -:19955:}
        -:19956:#endif /* !VMS */
        -:19957:
        -:19958:/* Return nonzero iff NAME matches MEM.
        -:19959:   If TRUNCATED is nonzero, MEM may be truncated to
        -:19960:   sizeof (struct ar_hdr.ar_name) - 1.  */
        -:19961:
        -:19962:int
function ar_name_equal called 0 returned 0% blocks executed 0%
    #####:19963:ar_name_equal (name, mem, truncated)
        -:19964:     char *name, *mem;
        -:19965:     int truncated;
        -:19966:{
        -:19967:  char *p;
        -:19968:
    #####:19969:  p = rindex (name, '/');
    #####:19970:  if (p != 0)
branch  0 never executed
branch  1 never executed
    #####:19971:    name = p + 1;
        -:19972:
        -:19973:#ifndef VMS
    #####:19974:  if (truncated)
branch  0 never executed
branch  1 never executed
        -:19975:    {
        -:19976:#ifdef AIAMAG
        -:19977:      /* TRUNCATED should never be set on this system.  */
        -:19978:      abort ();
        -:19979:#else
        -:19980:      struct ar_hdr hdr;
        -:19981:#if !defined (__hpux) && !defined (cray)
    #####:19982:      return strneq (name, mem, sizeof(hdr.ar_name) - 1);
        -:19983:#else
        -:19984:      return strneq (name, mem, sizeof(hdr.ar_name) - 2);
        -:19985:#endif /* !__hpux && !cray */
        -:19986:#endif /* !AIAMAG */
        -:19987:    }
        -:19988:#endif /* !VMS */
        -:19989:
    #####:19990:  return !strcmp (name, mem);
        -:19991:}
        -:19992:
        -:19993:#ifndef VMS
        -:19994:/* ARGSUSED */
        -:19995:static long int
function ar_member_pos called 0 returned 0% blocks executed 0%
    #####:19996:ar_member_pos (desc, mem, truncated,
        -:19997:	       hdrpos, datapos, size, date, uid, gid, mode, name)
        -:19998:     int desc;
        -:19999:     char *mem;
        -:20000:     int truncated;
        -:20001:     long int hdrpos, datapos, size, date;
        -:20002:     int uid, gid, mode;
        -:20003:     char *name;
        -:20004:{
    #####:20005:  if (!ar_name_equal (name, mem, truncated))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:20006:    return 0;
    #####:20007:  return hdrpos;
        -:20008:}
        -:20009:
        -:20010:/* Set date of member MEMNAME in archive ARNAME to current time.
        -:20011:   Returns 0 if successful,
        -:20012:   -1 if file ARNAME does not exist,
        -:20013:   -2 if not a valid archive,
        -:20014:   -3 if other random system call error (including file read-only),
        -:20015:   1 if valid but member MEMNAME does not exist.  */
        -:20016:
        -:20017:int
function ar_member_touch called 0 returned 0% blocks executed 0%
    #####:20018:ar_member_touch (arname, memname)
        -:20019:     char *arname, *memname;
        -:20020:{
    #####:20021:  register long int pos = ar_scan (arname, ar_member_pos, (long int) memname);
call    0 never executed
        -:20022:  register int fd;
        -:20023:  struct ar_hdr ar_hdr;
        -:20024:  register int i;
        -:20025:  struct stat statbuf;
        -:20026:
    #####:20027:  if (pos < 0)
branch  0 never executed
branch  1 never executed
    #####:20028:    return (int) pos;
    #####:20029:  if (!pos)
branch  0 never executed
branch  1 never executed
    #####:20030:    return 1;
        -:20031:
    #####:20032:  fd = open (arname, O_RDWR, 0666);
call    0 never executed
    #####:20033:  if (fd < 0)
branch  0 never executed
branch  1 never executed
    #####:20034:    return -3;
        -:20035:  /* Read in this member's header */
    #####:20036:  if (off_t_equal(off_t_to_int(lseek (fd, int_to_off_t(pos), 0)), ZERO_off_t) < 0)
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -:20037:    /*  if (lseek (fd, pos, 0) < 0) */
    #####:20038:    goto lose;
    #####:20039:  if (AR_HDR_SIZE != read (fd, (char *) &ar_hdr, AR_HDR_SIZE))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:20040:    goto lose;
        -:20041:  /* Write back the header, thus touching the archive file.  */
    #####:20042:  if (off_t_equal(off_t_to_int(lseek (fd, int_to_off_t(pos), 0)), ZERO_off_t) < 0)
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -:20043:    /*  if (lseek (fd, pos, 0) < 0) */
    #####:20044:    goto lose;
    #####:20045:  if (AR_HDR_SIZE != write (fd, (char *) &ar_hdr, AR_HDR_SIZE))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:20046:    goto lose;
        -:20047:  /* The file's mtime is the time we we want.  */
    #####:20048:  while (fstat (fd, &statbuf) < 0 && EINTR_SET)
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -:20049:    ;
        -:20050:#if defined(ARFMAG) || defined(ARFZMAG) || defined(AIAMAG) || defined(WINDOWS32)
        -:20051:  /* Advance member's time to that time */
    #####:20052:  for (i = 0; i < sizeof ar_hdr.ar_date; i++)
branch  0 never executed
branch  1 never executed
    #####:20053:    ar_hdr.ar_date[i] = ' ';
    #####:20054:  sprintf (ar_hdr.ar_date, "%ld", (long int) statbuf.st_mtime);
        -:20055:#ifdef AIAMAG
        -:20056:  ar_hdr.ar_date[strlen(ar_hdr.ar_date)] = ' ';
        -:20057:#endif
        -:20058:#else
        -:20059:  ar_hdr.ar_date = statbuf.st_mtime;
        -:20060:#endif
        -:20061:  /* Write back this member's header */
    #####:20062:  if (off_t_equal(off_t_to_int(lseek (fd, int_to_off_t(pos), 0)), ZERO_off_t) < 0)
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -:20063:    /*  if (lseek (fd, pos, 0) < 0) */
    #####:20064:    goto lose;
    #####:20065:  if (AR_HDR_SIZE != write (fd, (char *) &ar_hdr, AR_HDR_SIZE))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:20066:    goto lose;
    #####:20067:  close (fd);
call    0 never executed
    #####:20068:  return 0;
        -:20069:
    #####:20070: lose:
    #####:20071:  i = errno;
    #####:20072:  close (fd);
call    0 never executed
    #####:20073:  errno = i;
    #####:20074:  return -3;
        -:20075:}
        -:20076:#endif
        -:20077:
        -:20078:#ifdef TEST
        -:20079:
        -:20080:long int
        -:20081:describe_member (desc, name, truncated,
        -:20082:		 hdrpos, datapos, size, date, uid, gid, mode)
        -:20083:     int desc;
        -:20084:     char *name;
        -:20085:     int truncated;
        -:20086:     long int hdrpos, datapos, size, date;
        -:20087:     int uid, gid, mode;
        -:20088:{
        -:20089:  extern char *ctime ();
        -:20090:
        -:20091:  printf (_("Member `%s'%s: %ld bytes at %ld (%ld).\n"),
        -:20092:	  name, truncated ? _(" (name might be truncated)") : "",
        -:20093:	  size, hdrpos, datapos);
        -:20094:  printf (_("  Date %s"), ctime (&date));
        -:20095:  printf (_("  uid = %d, gid = %d, mode = 0%o.\n"), uid, gid, mode);
        -:20096:
        -:20097:  return 0;
        -:20098:}
        -:20099:
        -:20100:main (argc, argv)
        -:20101:     int argc;
        -:20102:     char **argv;
        -:20103:{
        -:20104:  ar_scan (argv[1], describe_member);
        -:20105:  return 0;
        -:20106:}
        -:20107:
        -:20108:#endif	/* TEST.  */
        -:20109:
        -:20110:#endif	/* NO_ARCHIVES.  */
        -:20111:
        -:20112:
        -:20113:
        -:20114:/*************************************************************
        -:20115:  ============================================================
        -:20116:  ************************************************************
        -:20117:  ============================================================
        -:20118:  ************************************************************
        -:20119:                         remote-stub.c
        -:20120:  ************************************************************
        -:20121:  ============================================================
        -:20122:  ************************************************************
        -:20123:  ============================================================
        -:20124:  *************************************************************/
        -:20125:
        -:20126:/* Template for the remote job exportation interface to GNU Make.
        -:20127:Copyright (C) 1988, 1989, 1992, 1993, 1996 Free Software Foundation, Inc.
        -:20128:This file is part of GNU Make.
        -:20129:
        -:20130:GNU Make is free software; you can redistribute it and/or modify
        -:20131:it under the terms of the GNU General Public License as published by
        -:20132:the Free Software Foundation; either version 2, or (at your option)
        -:20133:any later version.
        -:20134:
        -:20135:GNU Make is distributed in the hope that it will be useful,
        -:20136:but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:20137:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:20138:GNU General Public License for more details.
        -:20139:
        -:20140:You should have received a copy of the GNU General Public License
        -:20141:along with GNU Make; see the file COPYING.  If not, write to
        -:20142:the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
        -:20143:Boston, MA 02111-1307, USA.  */
        -:20144:
        -:20145:/* #include "make.h"  <- modification by J.Ruthruff, 7/27 */
        -:20146:/* #include "filedef.h"  <- modification by J.Ruthruff, 7/27 */
        -:20147:#include "job.h"
        -:20148:/* #include "commands.h"  <- modification by J.Ruthruff, 7/27 */
        -:20149:#undef stderr
        -:20150:#define stderr stdout
        -:20151:
        -:20152:
        -:20153:char *remote_description = 0;
        -:20154:
        -:20155:/* Call once at startup even if no commands are run.  */
        -:20156:
        -:20157:void
function remote_setup called 771 returned 100% blocks executed 100%
      771:20158:remote_setup ()
        -:20159:{
      771:20160:}
        -:20161:
        -:20162:/* Called before exit.  */
        -:20163:
        -:20164:void
function remote_cleanup called 774 returned 100% blocks executed 100%
      774:20165:remote_cleanup ()
        -:20166:{
      774:20167:}
        -:20168:
        -:20169:/* Return nonzero if the next job should be done remotely.  */
        -:20170:
        -:20171:int
function start_remote_job_p called 0 returned 0% blocks executed 0%
    #####:20172:start_remote_job_p (first_p)
        -:20173:     int first_p;
        -:20174:{
    #####:20175:  return 0;
        -:20176:}
        -:20177:
        -:20178:/* Start a remote job running the command in ARGV,
        -:20179:   with environment from ENVP.  It gets standard input from STDIN_FD.  On
        -:20180:   failure, return nonzero.  On success, return zero, and set *USED_STDIN
        -:20181:   to nonzero if it will actually use STDIN_FD, zero if not, set *ID_PTR to
        -:20182:   a unique identification, and set *IS_REMOTE to zero if the job is local,
        -:20183:   nonzero if it is remote (meaning *ID_PTR is a process ID).  */
        -:20184:
        -:20185:int
function start_remote_job called 0 returned 0% blocks executed 0%
    #####:20186:start_remote_job (argv, envp, stdin_fd, is_remote, id_ptr, used_stdin)
        -:20187:     char **argv, **envp;
        -:20188:     int stdin_fd;
        -:20189:     int *is_remote;
        -:20190:     int *id_ptr;
        -:20191:     int *used_stdin;
        -:20192:{
    #####:20193:  return -1;
        -:20194:}
        -:20195:
        -:20196:/* Get the status of a dead remote child.  Block waiting for one to die
        -:20197:   if BLOCK is nonzero.  Set *EXIT_CODE_PTR to the exit status, *SIGNAL_PTR
        -:20198:   to the termination signal or zero if it exited normally, and *COREDUMP_PTR
        -:20199:   nonzero if it dumped core.  Return the ID of the child that died,
        -:20200:   0 if we would have to block and !BLOCK, or < 0 if there were none.  */
        -:20201:
        -:20202:int
function remote_status called 0 returned 0% blocks executed 0%
    #####:20203:remote_status (exit_code_ptr, signal_ptr, coredump_ptr, block)
        -:20204:     int *exit_code_ptr, *signal_ptr, *coredump_ptr;
        -:20205:     int block;
        -:20206:{
    #####:20207:  errno = ECHILD;
    #####:20208:  return -1;
        -:20209:}
        -:20210:
        -:20211:/* Block asynchronous notification of remote child death.
        -:20212:   If this notification is done by raising the child termination
        -:20213:   signal, do not block that signal.  */
        -:20214:void
function block_remote_children called 0 returned 0% blocks executed 0%
    #####:20215:block_remote_children ()
        -:20216:{
    #####:20217:  return;
        -:20218:}
        -:20219:
        -:20220:/* Restore asynchronous notification of remote child death.
        -:20221:   If this is done by raising the child termination signal,
        -:20222:   do not unblock that signal.  */
        -:20223:void
function unblock_remote_children called 0 returned 0% blocks executed 0%
    #####:20224:unblock_remote_children ()
        -:20225:{
    #####:20226:  return;
        -:20227:}
        -:20228:
        -:20229:/* Send signal SIG to child ID.  Return 0 if successful, -1 if not.  */
        -:20230:int
function remote_kill called 0 returned 0% blocks executed 0%
    #####:20231:remote_kill (id, sig)
        -:20232:     int id;
        -:20233:     int sig;
        -:20234:{
    #####:20235:  return -1;
        -:20236:}
        -:20237:
        -:20238:
        -:20239:
        -:20240:/*************************************************************
        -:20241:  ============================================================
        -:20242:  ************************************************************
        -:20243:  ============================================================
        -:20244:  ************************************************************
        -:20245:                         signame.c
        -:20246:  ************************************************************
        -:20247:  ============================================================
        -:20248:  ************************************************************
        -:20249:  ============================================================
        -:20250:  *************************************************************/
        -:20251:
        -:20252:/* Convert between signal names and numbers.
        -:20253:   Copyright (C) 1990, 1992, 1993, 1995, 1996 Free Software Foundation, Inc.
        -:20254:   This file is part of the GNU C Library.
        -:20255:
        -:20256:   The GNU C Library is free software; you can redistribute it and/or
        -:20257:   modify it under the terms of the GNU Library General Public License as
        -:20258:   published by the Free Software Foundation; either version 2 of the
        -:20259:   License, or (at your option) any later version.
        -:20260:
        -:20261:   The GNU C Library is distributed in the hope that it will be useful,
        -:20262:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:20263:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
        -:20264:   Library General Public License for more details.
        -:20265:
        -:20266:   You should have received a copy of the GNU Library General Public
        -:20267:   License along with the GNU C Library; see the file COPYING.LIB.  If not,
        -:20268:   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
        -:20269:   Boston, MA 02111-1307, USA.  */
        -:20270:
        -:20271:/* #include "make.h"  <- modification by J.Ruthruff, 7/27 */
        -:20272:
        -:20273:#include <stdio.h>
        -:20274:#include <sys/types.h>		/* Some systems need this for <signal.h>.  */
        -:20275:#include <signal.h>
        -:20276:#undef stderr
        -:20277:#define stderr stdout
        -:20278:
        -:20279:#ifdef HAVE_STRING_H
        -:20280:#include <string.h>
        -:20281:#undef stderr
        -:20282:#define stderr stdout
        -:20283:#endif
        -:20284:
        -:20285:/* Some systems declare `sys_siglist in <unistd.h>; if
        -:20286:   configure defined SYS_SIGLIST_DECLARED, it may expect
        -:20287:   to find the declaration there.  */
        -:20288:#ifdef HAVE_UNISTD_H
        -:20289:#include <unistd.h>
        -:20290:#undef stderr
        -:20291:#define stderr stdout
        -:20292:#endif
        -:20293:
        -:20294:
        -:20295:/* Some systems do not define NSIG in <signal.h>.  */
        -:20296:#ifndef	NSIG
        -:20297:#ifdef	_NSIG
        -:20298:#define	NSIG	_NSIG
        -:20299:#else
        -:20300:#define	NSIG	32
        -:20301:#endif
        -:20302:#endif
        -:20303:
        -:20304:#if !__STDC__
        -:20305:#define const
        -:20306:#endif
        -:20307:
        -:20308:#include "signame.h"
        -:20309:#undef stderr
        -:20310:#define stderr stdout
        -:20311:
        -:20312:#ifndef HAVE_SYS_SIGLIST
        -:20313:/* There is too much variation in Sys V signal numbers and names, so
        -:20314:   we must initialize them at runtime.  */
        -:20315:
        -:20316:static const char *undoc;
        -:20317:
        -:20318:const char *sys_siglist[NSIG];
        -:20319:
        -:20320:#else	/* HAVE_SYS_SIGLIST.  */
        -:20321:
        -:20322:#ifndef SYS_SIGLIST_DECLARED
        -:20323:extern char *sys_siglist[];
        -:20324:#endif	/* Not SYS_SIGLIST_DECLARED.  */
        -:20325:
        -:20326:#endif	/* Not HAVE_SYS_SIGLIST.  */
        -:20327:
        -:20328:/* Table of abbreviations for signals.  Note:  A given number can
        -:20329:   appear more than once with different abbreviations.  */
        -:20330:#define SIG_TABLE_SIZE  (NSIG*2)
        -:20331:
        -:20332:typedef struct
        -:20333:  {
        -:20334:    int number;
        -:20335:    const char *abbrev;
        -:20336:  } num_abbrev;
        -:20337:static num_abbrev sig_table[SIG_TABLE_SIZE];
        -:20338:/* Number of elements of sig_table used.  */
        -:20339:static int sig_table_nelts = 0;
        -:20340:
        -:20341:/* Enter signal number NUMBER into the tables with ABBREV and NAME.  */
        -:20342:
        -:20343:static void
function init_sig called 0 returned 0% blocks executed 0%
    #####:20344:init_sig (number, abbrev, name)
        -:20345:     int number;
        -:20346:     const char *abbrev;
        -:20347:     const char *name;
        -:20348:{
        -:20349:#ifndef HAVE_SYS_SIGLIST
        -:20350:  /* If this value is ever greater than NSIG it seems like it'd be a bug in
        -:20351:     the system headers, but... better safe than sorry.  We know, for
        -:20352:     example, that this isn't always true on VMS.  */
        -:20353:
    #####:20354:  if (number >= 0 && number < NSIG)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:20355:    sys_siglist[number] = name;
        -:20356:#endif
    #####:20357:  if (sig_table_nelts < SIG_TABLE_SIZE)
branch  0 never executed
branch  1 never executed
        -:20358:    {
    #####:20359:      sig_table[sig_table_nelts].number = number;
    #####:20360:      sig_table[sig_table_nelts++].abbrev = abbrev;
        -:20361:    }
    #####:20362:}
        -:20363:
        -:20364:void
function signame_init called 0 returned 0% blocks executed 0%
    #####:20365:signame_init ()
        -:20366:{
        -:20367:#ifndef HAVE_SYS_SIGLIST
        -:20368:  int i;
    #####:20369:  char *u = _("unknown signal");
        -:20370:
    #####:20371:  undoc = xstrdup(u);
call    0 never executed
        -:20372:
        -:20373:  /* Initialize signal names.  */
    #####:20374:  for (i = 0; i < NSIG; i++)
branch  0 never executed
branch  1 never executed
    #####:20375:    sys_siglist[i] = undoc;
        -:20376:#endif /* !HAVE_SYS_SIGLIST */
        -:20377:
        -:20378:  /* Initialize signal names.  */
        -:20379:#if defined (SIGHUP)
    #####:20380:  init_sig (SIGHUP, "HUP", _("Hangup"));
call    0 never executed
        -:20381:#endif
        -:20382:#if defined (SIGINT)
    #####:20383:  init_sig (SIGINT, "INT", _("Interrupt"));
call    0 never executed
        -:20384:#endif
        -:20385:#if defined (SIGQUIT)
    #####:20386:  init_sig (SIGQUIT, "QUIT", _("Quit"));
call    0 never executed
        -:20387:#endif
        -:20388:#if defined (SIGILL)
    #####:20389:  init_sig (SIGILL, "ILL", _("Illegal Instruction"));
call    0 never executed
        -:20390:#endif
        -:20391:#if defined (SIGTRAP)
    #####:20392:  init_sig (SIGTRAP, "TRAP", _("Trace/breakpoint trap"));
call    0 never executed
        -:20393:#endif
        -:20394:  /* If SIGIOT == SIGABRT, we want to print it as SIGABRT because
        -:20395:     SIGABRT is in ANSI and POSIX.1 and SIGIOT isn't.  */
        -:20396:#if defined (SIGABRT)
    #####:20397:  init_sig (SIGABRT, "ABRT", _("Aborted"));
call    0 never executed
        -:20398:#endif
        -:20399:#if defined (SIGIOT)
    #####:20400:  init_sig (SIGIOT, "IOT", _("IOT trap"));
call    0 never executed
        -:20401:#endif
        -:20402:#if defined (SIGEMT)
        -:20403:  init_sig (SIGEMT, "EMT", _("EMT trap"));
        -:20404:#endif
        -:20405:#if defined (SIGFPE)
    #####:20406:  init_sig (SIGFPE, "FPE", _("Floating point exception"));
call    0 never executed
        -:20407:#endif
        -:20408:#if defined (SIGKILL)
    #####:20409:  init_sig (SIGKILL, "KILL", _("Killed"));
call    0 never executed
        -:20410:#endif
        -:20411:#if defined (SIGBUS)
    #####:20412:  init_sig (SIGBUS, "BUS", _("Bus error"));
call    0 never executed
        -:20413:#endif
        -:20414:#if defined (SIGSEGV)
    #####:20415:  init_sig (SIGSEGV, "SEGV", _("Segmentation fault"));
call    0 never executed
        -:20416:#endif
        -:20417:#if defined (SIGSYS)
    #####:20418:  init_sig (SIGSYS, "SYS", _("Bad system call"));
call    0 never executed
        -:20419:#endif
        -:20420:#if defined (SIGPIPE)
    #####:20421:  init_sig (SIGPIPE, "PIPE", _("Broken pipe"));
call    0 never executed
        -:20422:#endif
        -:20423:#if defined (SIGALRM)
    #####:20424:  init_sig (SIGALRM, "ALRM", _("Alarm clock"));
call    0 never executed
        -:20425:#endif
        -:20426:#if defined (SIGTERM)
    #####:20427:  init_sig (SIGTERM, "TERM", _("Terminated"));
call    0 never executed
        -:20428:#endif
        -:20429:#if defined (SIGUSR1)
    #####:20430:  init_sig (SIGUSR1, "USR1", _("User defined signal 1"));
call    0 never executed
        -:20431:#endif
        -:20432:#if defined (SIGUSR2)
    #####:20433:  init_sig (SIGUSR2, "USR2", _("User defined signal 2"));
call    0 never executed
        -:20434:#endif
        -:20435:  /* If SIGCLD == SIGCHLD, we want to print it as SIGCHLD because that
        -:20436:     is what is in POSIX.1.  */
        -:20437:#if defined (SIGCHLD)
    #####:20438:  init_sig (SIGCHLD, "CHLD", _("Child exited"));
call    0 never executed
        -:20439:#endif
        -:20440:#if defined (SIGCLD)
    #####:20441:  init_sig (SIGCLD, "CLD", _("Child exited"));
call    0 never executed
        -:20442:#endif
        -:20443:#if defined (SIGPWR)
    #####:20444:  init_sig (SIGPWR, "PWR", _("Power failure"));
call    0 never executed
        -:20445:#endif
        -:20446:#if defined (SIGTSTP)
    #####:20447:  init_sig (SIGTSTP, "TSTP", _("Stopped"));
call    0 never executed
        -:20448:#endif
        -:20449:#if defined (SIGTTIN)
    #####:20450:  init_sig (SIGTTIN, "TTIN", _("Stopped (tty input)"));
call    0 never executed
        -:20451:#endif
        -:20452:#if defined (SIGTTOU)
    #####:20453:  init_sig (SIGTTOU, "TTOU", _("Stopped (tty output)"));
call    0 never executed
        -:20454:#endif
        -:20455:#if defined (SIGSTOP)
    #####:20456:  init_sig (SIGSTOP, "STOP", _("Stopped (signal)"));
call    0 never executed
        -:20457:#endif
        -:20458:#if defined (SIGXCPU)
    #####:20459:  init_sig (SIGXCPU, "XCPU", _("CPU time limit exceeded"));
call    0 never executed
        -:20460:#endif
        -:20461:#if defined (SIGXFSZ)
    #####:20462:  init_sig (SIGXFSZ, "XFSZ", _("File size limit exceeded"));
call    0 never executed
        -:20463:#endif
        -:20464:#if defined (SIGVTALRM)
    #####:20465:  init_sig (SIGVTALRM, "VTALRM", _("Virtual timer expired"));
call    0 never executed
        -:20466:#endif
        -:20467:#if defined (SIGPROF)
    #####:20468:  init_sig (SIGPROF, "PROF", _("Profiling timer expired"));
call    0 never executed
        -:20469:#endif
        -:20470:#if defined (SIGWINCH)
        -:20471:  /* "Window size changed" might be more accurate, but even if that
        -:20472:     is all that it means now, perhaps in the future it will be
        -:20473:     extended to cover other kinds of window changes.  */
    #####:20474:  init_sig (SIGWINCH, "WINCH", _("Window changed"));
call    0 never executed
        -:20475:#endif
        -:20476:#if defined (SIGCONT)
    #####:20477:  init_sig (SIGCONT, "CONT", _("Continued"));
call    0 never executed
        -:20478:#endif
        -:20479:#if defined (SIGURG)
    #####:20480:  init_sig (SIGURG, "URG", _("Urgent I/O condition"));
call    0 never executed
        -:20481:#endif
        -:20482:#if defined (SIGIO)
        -:20483:  /* "I/O pending" has also been suggested.  A disadvantage is
        -:20484:     that signal only happens when the process has
        -:20485:     asked for it, not everytime I/O is pending.  Another disadvantage
        -:20486:     is the confusion from giving it a different name than under Unix.  */
    #####:20487:  init_sig (SIGIO, "IO", _("I/O possible"));
call    0 never executed
        -:20488:#endif
        -:20489:#if defined (SIGWIND)
        -:20490:  init_sig (SIGWIND, "WIND", _("SIGWIND"));
        -:20491:#endif
        -:20492:#if defined (SIGPHONE)
        -:20493:  init_sig (SIGPHONE, "PHONE", _("SIGPHONE"));
        -:20494:#endif
        -:20495:#if defined (SIGPOLL)
    #####:20496:  init_sig (SIGPOLL, "POLL", _("I/O possible"));
call    0 never executed
        -:20497:#endif
        -:20498:#if defined (SIGLOST)
        -:20499:  init_sig (SIGLOST, "LOST", _("Resource lost"));
        -:20500:#endif
        -:20501:#if defined (SIGDANGER)
        -:20502:  init_sig (SIGDANGER, "DANGER", _("Danger signal"));
        -:20503:#endif
        -:20504:#if defined (SIGINFO)
        -:20505:  init_sig (SIGINFO, "INFO", _("Information request"));
        -:20506:#endif
        -:20507:#if defined (SIGNOFP)
        -:20508:  init_sig (SIGNOFP, "NOFP", _("Floating point co-processor not available"));
        -:20509:#endif
    #####:20510:}
        -:20511:
        -:20512:/* Return the abbreviation for signal NUMBER.  */
        -:20513:
        -:20514:char *
function sig_abbrev called 0 returned 0% blocks executed 0%
    #####:20515:sig_abbrev (number)
        -:20516:     int number;
        -:20517:{
        -:20518:  int i;
        -:20519:
    #####:20520:  if (sig_table_nelts == 0)
branch  0 never executed
branch  1 never executed
    #####:20521:    signame_init ();
call    0 never executed
        -:20522:
    #####:20523:  for (i = 0; i < sig_table_nelts; i++)
branch  0 never executed
branch  1 never executed
    #####:20524:    if (sig_table[i].number == number)
branch  0 never executed
branch  1 never executed
    #####:20525:      return (char *)sig_table[i].abbrev;
    #####:20526:  return NULL;
        -:20527:}
        -:20528:
        -:20529:/* Return the signal number for an ABBREV, or -1 if there is no
        -:20530:   signal by that name.  */
        -:20531:
        -:20532:int
function sig_number called 0 returned 0% blocks executed 0%
    #####:20533:sig_number (abbrev)
        -:20534:     const char *abbrev;
        -:20535:{
        -:20536:  int i;
        -:20537:
    #####:20538:  if (sig_table_nelts == 0)
branch  0 never executed
branch  1 never executed
    #####:20539:    signame_init ();
call    0 never executed
        -:20540:
        -:20541:  /* Skip over "SIG" if present.  */
    #####:20542:  if (abbrev[0] == 'S' && abbrev[1] == 'I' && abbrev[2] == 'G')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:20543:    abbrev += 3;
        -:20544:
    #####:20545:  for (i = 0; i < sig_table_nelts; i++)
branch  0 never executed
branch  1 never executed
    #####:20546:    if (abbrev[0] == sig_table[i].abbrev[0]
branch  0 never executed
branch  1 never executed
    #####:20547:	&& strcmp (abbrev, sig_table[i].abbrev) == 0)
branch  0 never executed
branch  1 never executed
    #####:20548:      return sig_table[i].number;
    #####:20549:  return -1;
        -:20550:}
        -:20551:
        -:20552:#ifndef HAVE_PSIGNAL
        -:20553:/* Print to standard error the name of SIGNAL, preceded by MESSAGE and
        -:20554:   a colon, and followed by a newline.  */
        -:20555:
        -:20556:void
        -:20557:psignal (signal, message)
        -:20558:     int signal;
        -:20559:     const char *message;
        -:20560:{
        -:20561:  if (signal <= 0 || signal >= NSIG)
        -:20562:    fprintf (stderr, "%s: unknown signal", message);
        -:20563:  else
        -:20564:    fprintf (stderr, "%s: %s\n", message, sys_siglist[signal]);
        -:20565:}
        -:20566:#endif
        -:20567:
        -:20568:#ifndef HAVE_STRSIGNAL
        -:20569:/* Return the string associated with the signal number.  */
        -:20570:
        -:20571:char *
        -:20572:strsignal (signal)
        -:20573:     int signal;
        -:20574:{
        -:20575:  static char buf[] = "Signal 12345678901234567890";
        -:20576:
        -:20577:  if (signal > 0 || signal < NSIG)
        -:20578:    return (char *) sys_siglist[signal];
        -:20579:
        -:20580:  sprintf (buf, "Signal %d", signal);
        -:20581:  return buf;
        -:20582:}
        -:20583:#endif
        -:20584:
        -:20585:
        -:20586:
        -:20587:/*************************************************************
        -:20588:  ============================================================
        -:20589:  ************************************************************
        -:20590:  ============================================================
        -:20591:  ************************************************************
        -:20592:                         getopt.c
        -:20593:  ************************************************************
        -:20594:  ============================================================
        -:20595:  ************************************************************
        -:20596:  ============================================================
        -:20597:  *************************************************************/
        -:20598:
        -:20599:/* Getopt for GNU.
        -:20600:   NOTE: getopt is now part of the C library, so if you don't know what
        -:20601:   "Keep this file name-space clean" means, talk to drepper@gnu.org
        -:20602:   before changing it!
        -:20603:
        -:20604:   Copyright (C) 1987, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98
        -:20605:   	Free Software Foundation, Inc.
        -:20606:
        -:20607:   NOTE: The canonical source of this file is maintained with the GNU C Library.
        -:20608:   Bugs can be reported to bug-glibc@gnu.org.
        -:20609:
        -:20610:   This program is free software; you can redistribute it and/or modify it
        -:20611:   under the terms of the GNU General Public License as published by the
        -:20612:   Free Software Foundation; either version 2, or (at your option) any
        -:20613:   later version.
        -:20614:
        -:20615:   This program is distributed in the hope that it will be useful,
        -:20616:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:20617:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:20618:   GNU General Public License for more details.
        -:20619:
        -:20620:   You should have received a copy of the GNU General Public License
        -:20621:   along with this program; if not, write to the Free Software
        -:20622:   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
        -:20623:   USA.  */
        -:20624:
        -:20625:/* This tells Alpha OSF/1 not to define a getopt prototype in <stdio.h>.
        -:20626:   Ditto for AIX 3.2 and <stdlib.h>.  */
        -:20627:#ifndef _NO_PROTO
        -:20628:# define _NO_PROTO
        -:20629:#endif
        -:20630:
        -:20631:#ifdef HAVE_CONFIG_H
        -:20632:# include <config.h>
        -:20633:#undef stderr
        -:20634:#define stderr stdout
        -:20635:#endif
        -:20636:
        -:20637:#if !defined __STDC__ || !__STDC__
        -:20638:/* This is a separate conditional since some stdc systems
        -:20639:   reject `defined (const)'.  */
        -:20640:# ifndef const
        -:20641:#  define const
        -:20642:# endif
        -:20643:#endif
        -:20644:
        -:20645:#include <stdio.h>
        -:20646:#undef stderr
        -:20647:#define stderr stdout
        -:20648:
        -:20649:/* Comment out all this code if we are using the GNU C Library, and are not
        -:20650:   actually compiling the library itself.  This code is part of the GNU C
        -:20651:   Library, but also included in many other GNU distributions.  Compiling
        -:20652:   and linking in this code is a waste when using the GNU C library
        -:20653:   (especially if it is a shared library).  Rather than having every GNU
        -:20654:   program understand `configure --with-gnu-libc' and omit the object files,
        -:20655:   it is simpler to just do this in the source for each such file.  */
        -:20656:
        -:20657:#define GETOPT_INTERFACE_VERSION 2
        -:20658:#if !defined _LIBC && defined __GLIBC__ && __GLIBC__ >= 2
        -:20659:# include <gnu-versions.h>
        -:20660:#undef stderr
        -:20661:#define stderr stdout
        -:20662:# if _GNU_GETOPT_INTERFACE_VERSION == GETOPT_INTERFACE_VERSION
        -:20663:#  define ELIDE_CODE
        -:20664:# endif
        -:20665:#endif
        -:20666:
        -:20667:#ifndef ELIDE_CODE
        -:20668:
        -:20669:
        -:20670:/* This needs to come after some library #include
        -:20671:   to get __GNU_LIBRARY__ defined.  */
        -:20672:#ifdef	__GNU_LIBRARY__
        -:20673:/* Don't include stdlib.h for non-GNU C libraries because some of them
        -:20674:   contain conflicting prototypes for getopt.  */
        -:20675:# include <stdlib.h>
        -:20676:# include <unistd.h>
        -:20677:#undef stderr
        -:20678:#define stderr stdout
        -:20679:#endif	/* GNU C library.  */
        -:20680:
        -:20681:#ifdef VMS
        -:20682:# include <unixlib.h>
        -:20683:# if HAVE_STRING_H - 0
        -:20684:#  include <string.h>
        -:20685:#undef stderr
        -:20686:#define stderr stdout
        -:20687:# endif
        -:20688:#endif
        -:20689:
        -:20690:#ifndef _
        -:20691:/* This is for other GNU distributions with internationalized messages.
        -:20692:   When compiling libc, the _ macro is predefined.  */
        -:20693:# ifdef HAVE_LIBINTL_H
        -:20694:#  include <libintl.h>
        -:20695:#undef stderr
        -:20696:#define stderr stdout
        -:20697:#  define _(msgid)	gettext (msgid)
        -:20698:# else
        -:20699:#  define _(msgid)	(msgid)
        -:20700:# endif
        -:20701:#endif
        -:20702:
        -:20703:/* This version of `getopt' appears to the caller like standard Unix `getopt'
        -:20704:   but it behaves differently for the user, since it allows the user
        -:20705:   to intersperse the options with the other arguments.
        -:20706:
        -:20707:   As `getopt' works, it permutes the elements of ARGV so that,
        -:20708:   when it is done, all the options precede everything else.  Thus
        -:20709:   all application programs are extended to handle flexible argument order.
        -:20710:
        -:20711:   Setting the environment variable POSIXLY_CORRECT disables permutation.
        -:20712:   Then the behavior is completely standard.
        -:20713:
        -:20714:   GNU application programs can use a third alternative mode in which
        -:20715:   they can distinguish the relative order of options and other arguments.  */
        -:20716:
        -:20717:#include "getopt.h"
        -:20718:#undef stderr
        -:20719:#define stderr stdout
        -:20720:
        -:20721:/* For communication from `getopt' to the caller.
        -:20722:   When `getopt' finds an option that takes an argument,
        -:20723:   the argument value is returned here.
        -:20724:   Also, when `ordering' is RETURN_IN_ORDER,
        -:20725:   each non-option ARGV-element is returned here.  */
        -:20726:
        -:20727:char *optarg = NULL;
        -:20728:
        -:20729:/* Index in ARGV of the next element to be scanned.
        -:20730:   This is used for communication to and from the caller
        -:20731:   and for communication between successive calls to `getopt'.
        -:20732:
        -:20733:   On entry to `getopt', zero means this is the first call; initialize.
        -:20734:
        -:20735:   When `getopt' returns -1, this is the index of the first of the
        -:20736:   non-option elements that the caller should itself scan.
        -:20737:
        -:20738:   Otherwise, `optind' communicates from one call to the next
        -:20739:   how much of ARGV has been scanned so far.  */
        -:20740:
        -:20741:/* 1003.2 says this must be 1 before any call.  */
        -:20742:int optind = 1;
        -:20743:
        -:20744:/* Formerly, initialization of getopt depended on optind==0, which
        -:20745:   causes problems with re-calling getopt as programs generally don't
        -:20746:   know that. */
        -:20747:
        -:20748:int __getopt_initialized = 0;
        -:20749:
        -:20750:/* The next char to be scanned in the option-element
        -:20751:   in which the last option character we returned was found.
        -:20752:   This allows us to pick up the scan where we left off.
        -:20753:
        -:20754:   If this is zero, or a null string, it means resume the scan
        -:20755:   by advancing to the next ARGV-element.  */
        -:20756:
        -:20757:static char *nextchar;
        -:20758:
        -:20759:/* Callers store zero here to inhibit the error message
        -:20760:   for unrecognized options.  */
        -:20761:
        -:20762:int opterr = 1;
        -:20763:
        -:20764:/* Set to an option character which was unrecognized.
        -:20765:   This must be initialized on some systems to avoid linking in the
        -:20766:   system's own getopt implementation.  */
        -:20767:
        -:20768:int optopt = '?';
        -:20769:
        -:20770:/* Describe how to deal with options that follow non-option ARGV-elements.
        -:20771:
        -:20772:   If the caller did not specify anything,
        -:20773:   the default is REQUIRE_ORDER if the environment variable
        -:20774:   POSIXLY_CORRECT is defined, PERMUTE otherwise.
        -:20775:
        -:20776:   REQUIRE_ORDER means don't recognize them as options;
        -:20777:   stop option processing when the first non-option is seen.
        -:20778:   This is what Unix does.
        -:20779:   This mode of operation is selected by either setting the environment
        -:20780:   variable POSIXLY_CORRECT, or using `+' as the first character
        -:20781:   of the list of option characters.
        -:20782:
        -:20783:   PERMUTE is the default.  We permute the contents of ARGV as we scan,
        -:20784:   so that eventually all the non-options are at the end.  This allows options
        -:20785:   to be given in any order, even with programs that were not written to
        -:20786:   expect this.
        -:20787:
        -:20788:   RETURN_IN_ORDER is an option available to programs that were written
        -:20789:   to expect options and other ARGV-elements in any order and that care about
        -:20790:   the ordering of the two.  We describe each non-option ARGV-element
        -:20791:   as if it were the argument of an option with character code 1.
        -:20792:   Using `-' as the first character of the list of option characters
        -:20793:   selects this mode of operation.
        -:20794:
        -:20795:   The special argument `--' forces an end of option-scanning regardless
        -:20796:   of the value of `ordering'.  In the case of RETURN_IN_ORDER, only
        -:20797:   `--' can cause `getopt' to return -1 with `optind' != ARGC.  */
        -:20798:
        -:20799:static enum
        -:20800:{
        -:20801:  REQUIRE_ORDER, PERMUTE, RETURN_IN_ORDER
        -:20802:} ordering;
        -:20803:
        -:20804:/* Value of POSIXLY_CORRECT environment variable.  */
        -:20805:static char *posixly_correct;
        -:20806:
        -:20807:#ifdef	__GNU_LIBRARY__
        -:20808:/* We want to avoid inclusion of string.h with non-GNU libraries
        -:20809:   because there are many ways it can cause trouble.
        -:20810:   On some systems, it contains special magic macros that don't work
        -:20811:   in GCC.  */
        -:20812:# include <string.h>
        -:20813:#undef stderr
        -:20814:#define stderr stdout
        -:20815:# define my_index	strchr
        -:20816:#else
        -:20817:
        -:20818:# if HAVE_STRING_H
        -:20819:#  include <string.h>
        -:20820:#undef stderr
        -:20821:#define stderr stdout
        -:20822:# else
        -:20823:#  include <strings.h>
        -:20824:#undef stderr
        -:20825:#define stderr stdout
        -:20826:# endif
        -:20827:
        -:20828:/* Avoid depending on library functions or files
        -:20829:   whose names are inconsistent.  */
        -:20830:
        -:20831:#ifndef getenv
        -:20832:extern char *getenv ();
        -:20833:#endif
        -:20834:
        -:20835:static char *
        -:20836:my_index (str, chr)
        -:20837:     const char *str;
        -:20838:     int chr;
        -:20839:{
        -:20840:  while (*str)
        -:20841:    {
        -:20842:      if (*str == chr)
        -:20843:	return (char *) str;
        -:20844:      str++;
        -:20845:    }
        -:20846:  return 0;
        -:20847:}
        -:20848:
        -:20849:/* If using GCC, we can safely declare strlen this way.
        -:20850:   If not using GCC, it is ok not to declare it.  */
        -:20851:#ifdef __GNUC__
        -:20852:/* Note that Motorola Delta 68k R3V7 comes with GCC but not stddef.h.
        -:20853:   That was relevant to code that was here before.  */
        -:20854:# if (!defined __STDC__ || !__STDC__) && !defined strlen
        -:20855:/* gcc with -traditional declares the built-in strlen to return int,
        -:20856:   and has done so at least since version 2.4.5. -- rms.  */
        -:20857:extern int strlen (const char *);
        -:20858:# endif /* not __STDC__ */
        -:20859:#endif /* __GNUC__ */
        -:20860:
        -:20861:#endif /* not __GNU_LIBRARY__ */
        -:20862:
        -:20863:/* Handle permutation of arguments.  */
        -:20864:
        -:20865:/* Describe the part of ARGV that contains non-options that have
        -:20866:   been skipped.  `first_nonopt' is the index in ARGV of the first of them;
        -:20867:   `last_nonopt' is the index after the last of them.  */
        -:20868:
        -:20869:static int first_nonopt;
        -:20870:static int last_nonopt;
        -:20871:
        -:20872:#ifdef _LIBC
        -:20873:/* Bash 2.0 gives us an environment variable containing flags
        -:20874:   indicating ARGV elements that should not be considered arguments.  */
        -:20875:
        -:20876:/* Defined in getopt_init.c  */
        -:20877:extern char *__getopt_nonoption_flags;
        -:20878:
        -:20879:static int nonoption_flags_max_len;
        -:20880:static int nonoption_flags_len;
        -:20881:
        -:20882:static int original_argc;
        -:20883:static char *const *original_argv;
        -:20884:
        -:20885:/* Make sure the environment variable bash 2.0 puts in the environment
        -:20886:   is valid for the getopt call we must make sure that the ARGV passed
        -:20887:   to getopt is that one passed to the process.  */
        -:20888:static void
        -:20889:__attribute__ ((unused))
        -:20890:store_args_and_env (int argc, char *const *argv)
        -:20891:{
        -:20892:  /* XXX This is no good solution.  We should rather copy the args so
        -:20893:     that we can compare them later.  But we must not use malloc(3).  */
        -:20894:  original_argc = argc;
        -:20895:  original_argv = argv;
        -:20896:}
        -:20897:# ifdef text_set_element
        -:20898:text_set_element (__libc_subinit, store_args_and_env);
        -:20899:# endif /* text_set_element */
        -:20900:
        -:20901:# define SWAP_FLAGS(ch1, ch2) \
        -:20902:  if (nonoption_flags_len > 0)						      \
        -:20903:    {									      \
        -:20904:      char __tmp = __getopt_nonoption_flags[ch1];			      \
        -:20905:      __getopt_nonoption_flags[ch1] = __getopt_nonoption_flags[ch2];	      \
        -:20906:      __getopt_nonoption_flags[ch2] = __tmp;				      \
        -:20907:    }
        -:20908:#else	/* !_LIBC */
        -:20909:# define SWAP_FLAGS(ch1, ch2)
        -:20910:#endif	/* _LIBC */
        -:20911:
        -:20912:/* Exchange two adjacent subsequences of ARGV.
        -:20913:   One subsequence is elements [first_nonopt,last_nonopt)
        -:20914:   which contains all the non-options that have been skipped so far.
        -:20915:   The other is elements [last_nonopt,optind), which contains all
        -:20916:   the options processed since those non-options were skipped.
        -:20917:
        -:20918:   `first_nonopt' and `last_nonopt' are relocated so that they describe
        -:20919:   the new indices of the non-options in ARGV after they are moved.  */
        -:20920:
        -:20921:#if defined __STDC__ && __STDC__
        -:20922:static void exchange (char **);
        -:20923:#endif
        -:20924:
        -:20925:static void
        -:20926:exchange (argv)
        -:20927:     char **argv;
        -:20928:{
        -:20929:  int bottom = first_nonopt;
        -:20930:  int middle = last_nonopt;
        -:20931:  int top = optind;
        -:20932:  char *tem;
        -:20933:
        -:20934:  /* Exchange the shorter segment with the far end of the longer segment.
        -:20935:     That puts the shorter segment into the right place.
        -:20936:     It leaves the longer segment in the right place overall,
        -:20937:     but it consists of two parts that need to be swapped next.  */
        -:20938:
        -:20939:#ifdef _LIBC
        -:20940:  /* First make sure the handling of the `__getopt_nonoption_flags'
        -:20941:     string can work normally.  Our top argument must be in the range
        -:20942:     of the string.  */
        -:20943:  if (nonoption_flags_len > 0 && top >= nonoption_flags_max_len)
        -:20944:    {
        -:20945:      /* We must extend the array.  The user plays games with us and
        -:20946:	 presents new arguments.  */
        -:20947:      char *new_str = malloc (top + 1);
        -:20948:      if (new_str == NULL)
        -:20949:	nonoption_flags_len = nonoption_flags_max_len = 0;
        -:20950:      else
        -:20951:	{
        -:20952:	  memset (__mempcpy (new_str, __getopt_nonoption_flags,
        -:20953:			     nonoption_flags_max_len),
        -:20954:		  '\0', top + 1 - nonoption_flags_max_len);
        -:20955:	  nonoption_flags_max_len = top + 1;
        -:20956:	  __getopt_nonoption_flags = new_str;
        -:20957:	}
        -:20958:    }
        -:20959:#endif
        -:20960:
        -:20961:  while (top > middle && middle > bottom)
        -:20962:    {
        -:20963:      if (top - middle > middle - bottom)
        -:20964:	{
        -:20965:	  /* Bottom segment is the short one.  */
        -:20966:	  int len = middle - bottom;
        -:20967:	  register int i;
        -:20968:
        -:20969:	  /* Swap it with the top part of the top segment.  */
        -:20970:	  for (i = 0; i < len; i++)
        -:20971:	    {
        -:20972:	      tem = argv[bottom + i];
        -:20973:	      argv[bottom + i] = argv[top - (middle - bottom) + i];
        -:20974:	      argv[top - (middle - bottom) + i] = tem;
        -:20975:	      SWAP_FLAGS (bottom + i, top - (middle - bottom) + i);
        -:20976:	    }
        -:20977:	  /* Exclude the moved bottom segment from further swapping.  */
        -:20978:	  top -= len;
        -:20979:	}
        -:20980:      else
        -:20981:	{
        -:20982:	  /* Top segment is the short one.  */
        -:20983:	  int len = top - middle;
        -:20984:	  register int i;
        -:20985:
        -:20986:	  /* Swap it with the bottom part of the bottom segment.  */
        -:20987:	  for (i = 0; i < len; i++)
        -:20988:	    {
        -:20989:	      tem = argv[bottom + i];
        -:20990:	      argv[bottom + i] = argv[middle + i];
        -:20991:	      argv[middle + i] = tem;
        -:20992:	      SWAP_FLAGS (bottom + i, middle + i);
        -:20993:	    }
        -:20994:	  /* Exclude the moved top segment from further swapping.  */
        -:20995:	  bottom += len;
        -:20996:	}
        -:20997:    }
        -:20998:
        -:20999:  /* Update records for the slots the non-options now occupy.  */
        -:21000:
        -:21001:  first_nonopt += (optind - last_nonopt);
        -:21002:  last_nonopt = optind;
        -:21003:}
        -:21004:
        -:21005:/* Initialize the internal data when the first call is made.  */
        -:21006:
        -:21007:#if defined __STDC__ && __STDC__
        -:21008:static const char *_getopt_initialize (int, char *const *, const char *);
        -:21009:#endif
        -:21010:static const char *
        -:21011:_getopt_initialize (argc, argv, optstring)
        -:21012:     int argc;
        -:21013:     char *const *argv;
        -:21014:     const char *optstring;
        -:21015:{
        -:21016:  /* Start processing options with ARGV-element 1 (since ARGV-element 0
        -:21017:     is the program name); the sequence of previously skipped
        -:21018:     non-option ARGV-elements is empty.  */
        -:21019:
        -:21020:  first_nonopt = last_nonopt = optind;
        -:21021:
        -:21022:  nextchar = NULL;
        -:21023:
        -:21024:  posixly_correct = getenv ("POSIXLY_CORRECT");
        -:21025:
        -:21026:  /* Determine how to handle the ordering of options and nonoptions.  */
        -:21027:
        -:21028:  if (optstring[0] == '-')
        -:21029:    {
        -:21030:      ordering = RETURN_IN_ORDER;
        -:21031:      ++optstring;
        -:21032:    }
        -:21033:  else if (optstring[0] == '+')
        -:21034:    {
        -:21035:      ordering = REQUIRE_ORDER;
        -:21036:      ++optstring;
        -:21037:    }
        -:21038:  else if (posixly_correct != NULL)
        -:21039:    ordering = REQUIRE_ORDER;
        -:21040:  else
        -:21041:    ordering = PERMUTE;
        -:21042:
        -:21043:#ifdef _LIBC
        -:21044:  if (posixly_correct == NULL
        -:21045:      && argc == original_argc && argv == original_argv)
        -:21046:    {
        -:21047:      if (nonoption_flags_max_len == 0)
        -:21048:	{
        -:21049:	  if (__getopt_nonoption_flags == NULL
        -:21050:	      || __getopt_nonoption_flags[0] == '\0')
        -:21051:	    nonoption_flags_max_len = -1;
        -:21052:	  else
        -:21053:	    {
        -:21054:	      const char *orig_str = __getopt_nonoption_flags;
        -:21055:	      int len = nonoption_flags_max_len = strlen (orig_str);
        -:21056:	      if (nonoption_flags_max_len < argc)
        -:21057:		nonoption_flags_max_len = argc;
        -:21058:	      __getopt_nonoption_flags =
        -:21059:		(char *) malloc (nonoption_flags_max_len);
        -:21060:	      if (__getopt_nonoption_flags == NULL)
        -:21061:		nonoption_flags_max_len = -1;
        -:21062:	      else
        -:21063:		memset (__mempcpy (__getopt_nonoption_flags, orig_str, len),
        -:21064:			'\0', nonoption_flags_max_len - len);
        -:21065:	    }
        -:21066:	}
        -:21067:      nonoption_flags_len = nonoption_flags_max_len;
        -:21068:    }
        -:21069:  else
        -:21070:    nonoption_flags_len = 0;
        -:21071:#endif
        -:21072:
        -:21073:  return optstring;
        -:21074:}
        -:21075:
        -:21076:/* Scan elements of ARGV (whose length is ARGC) for option characters
        -:21077:   given in OPTSTRING.
        -:21078:
        -:21079:   If an element of ARGV starts with '-', and is not exactly "-" or "--",
        -:21080:   then it is an option element.  The characters of this element
        -:21081:   (aside from the initial '-') are option characters.  If `getopt'
        -:21082:   is called repeatedly, it returns successively each of the option characters
        -:21083:   from each of the option elements.
        -:21084:
        -:21085:   If `getopt' finds another option character, it returns that character,
        -:21086:   updating `optind' and `nextchar' so that the next call to `getopt' can
        -:21087:   resume the scan with the following option character or ARGV-element.
        -:21088:
        -:21089:   If there are no more option characters, `getopt' returns -1.
        -:21090:   Then `optind' is the index in ARGV of the first ARGV-element
        -:21091:   that is not an option.  (The ARGV-elements have been permuted
        -:21092:   so that those that are not options now come last.)
        -:21093:
        -:21094:   OPTSTRING is a string containing the legitimate option characters.
        -:21095:   If an option character is seen that is not listed in OPTSTRING,
        -:21096:   return '?' after printing an error message.  If you set `opterr' to
        -:21097:   zero, the error message is suppressed but we still return '?'.
        -:21098:
        -:21099:   If a char in OPTSTRING is followed by a colon, that means it wants an arg,
        -:21100:   so the following text in the same ARGV-element, or the text of the following
        -:21101:   ARGV-element, is returned in `optarg'.  Two colons mean an option that
        -:21102:   wants an optional arg; if there is text in the current ARGV-element,
        -:21103:   it is returned in `optarg', otherwise `optarg' is set to zero.
        -:21104:
        -:21105:   If OPTSTRING starts with `-' or `+', it requests different methods of
        -:21106:   handling the non-option ARGV-elements.
        -:21107:   See the comments about RETURN_IN_ORDER and REQUIRE_ORDER, above.
        -:21108:
        -:21109:   Long-named options begin with `--' instead of `-'.
        -:21110:   Their names may be abbreviated as long as the abbreviation is unique
        -:21111:   or is an exact match for some defined option.  If they have an
        -:21112:   argument, it follows the option name in the same ARGV-element, separated
        -:21113:   from the option name by a `=', or else the in next ARGV-element.
        -:21114:   When `getopt' finds a long-named option, it returns 0 if that option's
        -:21115:   `flag' field is nonzero, the value of the option's `val' field
        -:21116:   if the `flag' field is zero.
        -:21117:
        -:21118:   The elements of ARGV aren't really const, because we permute them.
        -:21119:   But we pretend they're const in the prototype to be compatible
        -:21120:   with other systems.
        -:21121:
        -:21122:   LONGOPTS is a vector of `struct option' terminated by an
        -:21123:   element containing a name which is zero.
        -:21124:
        -:21125:   LONGIND returns the index in LONGOPT of the long-named option found.
        -:21126:   It is only valid when a long-named option has been found by the most
        -:21127:   recent call.
        -:21128:
        -:21129:   If LONG_ONLY is nonzero, '-' as well as '--' can introduce
        -:21130:   long-named options.  */
        -:21131:
        -:21132:int
        -:21133:_getopt_internal (argc, argv, optstring, longopts, longind, long_only)
        -:21134:     int argc;
        -:21135:     char *const *argv;
        -:21136:     const char *optstring;
        -:21137:     const struct option *longopts;
        -:21138:     int *longind;
        -:21139:     int long_only;
        -:21140:{
        -:21141:  optarg = NULL;
        -:21142:
        -:21143:  if (optind == 0 || !__getopt_initialized)
        -:21144:    {
        -:21145:      if (optind == 0)
        -:21146:	optind = 1;	/* Don't scan ARGV[0], the program name.  */
        -:21147:      optstring = _getopt_initialize (argc, argv, optstring);
        -:21148:      __getopt_initialized = 1;
        -:21149:    }
        -:21150:
        -:21151:  /* Test whether ARGV[optind] points to a non-option argument.
        -:21152:     Either it does not have option syntax, or there is an environment flag
        -:21153:     from the shell indicating it is not an option.  The later information
        -:21154:     is only used when the used in the GNU libc.  */
        -:21155:#ifdef _LIBC
        -:21156:# define NONOPTION_P (argv[optind][0] != '-' || argv[optind][1] == '\0'	      \
        -:21157:		      || (optind < nonoption_flags_len			      \
        -:21158:			  && __getopt_nonoption_flags[optind] == '1'))
        -:21159:#else
        -:21160:# define NONOPTION_P (argv[optind][0] != '-' || argv[optind][1] == '\0')
        -:21161:#endif
        -:21162:
        -:21163:  if (nextchar == NULL || *nextchar == '\0')
        -:21164:    {
        -:21165:      /* Advance to the next ARGV-element.  */
        -:21166:
        -:21167:      /* Give FIRST_NONOPT & LAST_NONOPT rational values if OPTIND has been
        -:21168:	 moved back by the user (who may also have changed the arguments).  */
        -:21169:      if (last_nonopt > optind)
        -:21170:	last_nonopt = optind;
        -:21171:      if (first_nonopt > optind)
        -:21172:	first_nonopt = optind;
        -:21173:
        -:21174:      if (ordering == PERMUTE)
        -:21175:	{
        -:21176:	  /* If we have just processed some options following some non-options,
        -:21177:	     exchange them so that the options come first.  */
        -:21178:
        -:21179:	  if (first_nonopt != last_nonopt && last_nonopt != optind)
        -:21180:	    exchange ((char **) argv);
        -:21181:	  else if (last_nonopt != optind)
        -:21182:	    first_nonopt = optind;
        -:21183:
        -:21184:	  /* Skip any additional non-options
        -:21185:	     and extend the range of non-options previously skipped.  */
        -:21186:
        -:21187:	  while (optind < argc && NONOPTION_P)
        -:21188:	    optind++;
        -:21189:	  last_nonopt = optind;
        -:21190:	}
        -:21191:
        -:21192:      /* The special ARGV-element `--' means premature end of options.
        -:21193:	 Skip it like a null option,
        -:21194:	 then exchange with previous non-options as if it were an option,
        -:21195:	 then skip everything else like a non-option.  */
        -:21196:
        -:21197:      if (optind != argc && !strcmp (argv[optind], "--"))
        -:21198:	{
        -:21199:	  optind++;
        -:21200:
        -:21201:	  if (first_nonopt != last_nonopt && last_nonopt != optind)
        -:21202:	    exchange ((char **) argv);
        -:21203:	  else if (first_nonopt == last_nonopt)
        -:21204:	    first_nonopt = optind;
        -:21205:	  last_nonopt = argc;
        -:21206:
        -:21207:	  optind = argc;
        -:21208:	}
        -:21209:
        -:21210:      /* If we have done all the ARGV-elements, stop the scan
        -:21211:	 and back over any non-options that we skipped and permuted.  */
        -:21212:
        -:21213:      if (optind == argc)
        -:21214:	{
        -:21215:	  /* Set the next-arg-index to point at the non-options
        -:21216:	     that we previously skipped, so the caller will digest them.  */
        -:21217:	  if (first_nonopt != last_nonopt)
        -:21218:	    optind = first_nonopt;
        -:21219:	  return -1;
        -:21220:	}
        -:21221:
        -:21222:      /* If we have come to a non-option and did not permute it,
        -:21223:	 either stop the scan or describe it to the caller and pass it by.  */
        -:21224:
        -:21225:      if (NONOPTION_P)
        -:21226:	{
        -:21227:	  if (ordering == REQUIRE_ORDER)
        -:21228:	    return -1;
        -:21229:	  optarg = argv[optind++];
        -:21230:	  return 1;
        -:21231:	}
        -:21232:
        -:21233:      /* We have found another option-ARGV-element.
        -:21234:	 Skip the initial punctuation.  */
        -:21235:
        -:21236:      nextchar = (argv[optind] + 1
        -:21237:		  + (longopts != NULL && argv[optind][1] == '-'));
        -:21238:    }
        -:21239:
        -:21240:  /* Decode the current option-ARGV-element.  */
        -:21241:
        -:21242:  /* Check whether the ARGV-element is a long option.
        -:21243:
        -:21244:     If long_only and the ARGV-element has the form "-f", where f is
        -:21245:     a valid short option, don't consider it an abbreviated form of
        -:21246:     a long option that starts with f.  Otherwise there would be no
        -:21247:     way to give the -f short option.
        -:21248:
        -:21249:     On the other hand, if there's a long option "fubar" and
        -:21250:     the ARGV-element is "-fu", do consider that an abbreviation of
        -:21251:     the long option, just like "--fu", and not "-f" with arg "u".
        -:21252:
        -:21253:     This distinction seems to be the most useful approach.  */
        -:21254:
        -:21255:  if (longopts != NULL
        -:21256:      && (argv[optind][1] == '-'
        -:21257:	  || (long_only && (argv[optind][2] || !my_index (optstring, argv[optind][1])))))
        -:21258:    {
        -:21259:      char *nameend;
        -:21260:      const struct option *p;
        -:21261:      const struct option *pfound = NULL;
        -:21262:      int exact = 0;
        -:21263:      int ambig = 0;
        -:21264:      int indfound = -1;
        -:21265:      int option_index;
        -:21266:
        -:21267:      for (nameend = nextchar; *nameend && *nameend != '='; nameend++)
        -:21268:	/* Do nothing.  */ ;
        -:21269:
        -:21270:      /* Test all long options for either exact match
        -:21271:	 or abbreviated matches.  */
        -:21272:      for (p = longopts, option_index = 0; p->name; p++, option_index++)
        -:21273:	if (!strncmp (p->name, nextchar, nameend - nextchar))
        -:21274:	  {
        -:21275:	    if ((unsigned int) (nameend - nextchar)
        -:21276:		== (unsigned int) strlen (p->name))
        -:21277:	      {
        -:21278:		/* Exact match found.  */
        -:21279:		pfound = p;
        -:21280:		indfound = option_index;
        -:21281:		exact = 1;
        -:21282:		break;
        -:21283:	      }
        -:21284:	    else if (pfound == NULL)
        -:21285:	      {
        -:21286:		/* First nonexact match found.  */
        -:21287:		pfound = p;
        -:21288:		indfound = option_index;
        -:21289:	      }
        -:21290:	    else
        -:21291:	      /* Second or later nonexact match found.  */
        -:21292:	      ambig = 1;
        -:21293:	  }
        -:21294:
        -:21295:      if (ambig && !exact)
        -:21296:	{
        -:21297:	  if (opterr)
        -:21298:	    fprintf (stderr, _("%s: option `%s' is ambiguous\n"),
        -:21299:		     argv[0], argv[optind]);
        -:21300:	  nextchar += strlen (nextchar);
        -:21301:	  optind++;
        -:21302:	  optopt = 0;
        -:21303:	  return '?';
        -:21304:	}
        -:21305:
        -:21306:      if (pfound != NULL)
        -:21307:	{
        -:21308:	  option_index = indfound;
        -:21309:	  optind++;
        -:21310:	  if (*nameend)
        -:21311:	    {
        -:21312:	      /* Don't test has_arg with >, because some C compilers don't
        -:21313:		 allow it to be used on enums.  */
        -:21314:	      if (pfound->has_arg)
        -:21315:		optarg = nameend + 1;
        -:21316:	      else
        -:21317:		{
        -:21318:		  if (opterr)
        -:21319:		   if (argv[optind - 1][1] == '-')
        -:21320:		    /* --option */
        -:21321:		    fprintf (stderr,
        -:21322:		     _("%s: option `--%s' doesn't allow an argument\n"),
        -:21323:		     argv[0], pfound->name);
        -:21324:		   else
        -:21325:		    /* +option or -option */
        -:21326:		    fprintf (stderr,
        -:21327:		     _("%s: option `%c%s' doesn't allow an argument\n"),
        -:21328:		     argv[0], argv[optind - 1][0], pfound->name);
        -:21329:
        -:21330:		  nextchar += strlen (nextchar);
        -:21331:
        -:21332:		  optopt = pfound->val;
        -:21333:		  return '?';
        -:21334:		}
        -:21335:	    }
        -:21336:	  else if (pfound->has_arg == 1)
        -:21337:	    {
        -:21338:	      if (optind < argc)
        -:21339:		optarg = argv[optind++];
        -:21340:	      else
        -:21341:		{
        -:21342:		  if (opterr)
        -:21343:		    fprintf (stderr,
        -:21344:			   _("%s: option `%s' requires an argument\n"),
        -:21345:			   argv[0], argv[optind - 1]);
        -:21346:		  nextchar += strlen (nextchar);
        -:21347:		  optopt = pfound->val;
        -:21348:		  return optstring[0] == ':' ? ':' : '?';
        -:21349:		}
        -:21350:	    }
        -:21351:	  nextchar += strlen (nextchar);
        -:21352:	  if (longind != NULL)
        -:21353:	    *longind = option_index;
        -:21354:	  if (pfound->flag)
        -:21355:	    {
        -:21356:	      *(pfound->flag) = pfound->val;
        -:21357:	      return 0;
        -:21358:	    }
        -:21359:	  return pfound->val;
        -:21360:	}
        -:21361:
        -:21362:      /* Can't find it as a long option.  If this is not getopt_long_only,
        -:21363:	 or the option starts with '--' or is not a valid short
        -:21364:	 option, then it's an error.
        -:21365:	 Otherwise interpret it as a short option.  */
        -:21366:      if (!long_only || argv[optind][1] == '-'
        -:21367:	  || my_index (optstring, *nextchar) == NULL)
        -:21368:	{
        -:21369:	  if (opterr)
        -:21370:	    {
        -:21371:	      if (argv[optind][1] == '-')
        -:21372:		/* --option */
        -:21373:		fprintf (stderr, _("%s: unrecognized option `--%s'\n"),
        -:21374:			 argv[0], nextchar);
        -:21375:	      else
        -:21376:		/* +option or -option */
        -:21377:		fprintf (stderr, _("%s: unrecognized option `%c%s'\n"),
        -:21378:			 argv[0], argv[optind][0], nextchar);
        -:21379:	    }
        -:21380:	  nextchar = (char *) "";
        -:21381:	  optind++;
        -:21382:	  optopt = 0;
        -:21383:	  return '?';
        -:21384:	}
        -:21385:    }
        -:21386:
        -:21387:  /* Look at and handle the next short option-character.  */
        -:21388:
        -:21389:  {
        -:21390:    char c = *nextchar++;
        -:21391:    char *temp = my_index (optstring, c);
        -:21392:
        -:21393:    /* Increment `optind' when we start to process its last character.  */
        -:21394:    if (*nextchar == '\0')
        -:21395:      ++optind;
        -:21396:
        -:21397:    if (temp == NULL || c == ':')
        -:21398:      {
        -:21399:	if (opterr)
        -:21400:	  {
        -:21401:	    if (posixly_correct)
        -:21402:	      /* 1003.2 specifies the format of this message.  */
        -:21403:	      fprintf (stderr, _("%s: illegal option -- %c\n"),
        -:21404:		       argv[0], c);
        -:21405:	    else
        -:21406:	      fprintf (stderr, _("%s: invalid option -- %c\n"),
        -:21407:		       argv[0], c);
        -:21408:	  }
        -:21409:	optopt = c;
        -:21410:	return '?';
        -:21411:      }
        -:21412:    /* Convenience. Treat POSIX -W foo same as long option --foo */
        -:21413:    if (temp[0] == 'W' && temp[1] == ';')
        -:21414:      {
        -:21415:	char *nameend;
        -:21416:	const struct option *p;
        -:21417:	const struct option *pfound = NULL;
        -:21418:	int exact = 0;
        -:21419:	int ambig = 0;
        -:21420:	int indfound = 0;
        -:21421:	int option_index;
        -:21422:
        -:21423:	/* This is an option that requires an argument.  */
        -:21424:	if (*nextchar != '\0')
        -:21425:	  {
        -:21426:	    optarg = nextchar;
        -:21427:	    /* If we end this ARGV-element by taking the rest as an arg,
        -:21428:	       we must advance to the next element now.  */
        -:21429:	    optind++;
        -:21430:	  }
        -:21431:	else if (optind == argc)
        -:21432:	  {
        -:21433:	    if (opterr)
        -:21434:	      {
        -:21435:		/* 1003.2 specifies the format of this message.  */
        -:21436:		fprintf (stderr, _("%s: option requires an argument -- %c\n"),
        -:21437:			 argv[0], c);
        -:21438:	      }
        -:21439:	    optopt = c;
        -:21440:	    if (optstring[0] == ':')
        -:21441:	      c = ':';
        -:21442:	    else
        -:21443:	      c = '?';
        -:21444:	    return c;
        -:21445:	  }
        -:21446:	else
        -:21447:	  /* We already incremented `optind' once;
        -:21448:	     increment it again when taking next ARGV-elt as argument.  */
        -:21449:	  optarg = argv[optind++];
        -:21450:
        -:21451:	/* optarg is now the argument, see if it's in the
        -:21452:	   table of longopts.  */
        -:21453:
        -:21454:	for (nextchar = nameend = optarg; *nameend && *nameend != '='; nameend++)
        -:21455:	  /* Do nothing.  */ ;
        -:21456:
        -:21457:	/* Test all long options for either exact match
        -:21458:	   or abbreviated matches.  */
        -:21459:	for (p = longopts, option_index = 0; p->name; p++, option_index++)
        -:21460:	  if (!strncmp (p->name, nextchar, nameend - nextchar))
        -:21461:	    {
        -:21462:	      if ((unsigned int) (nameend - nextchar) == strlen (p->name))
        -:21463:		{
        -:21464:		  /* Exact match found.  */
        -:21465:		  pfound = p;
        -:21466:		  indfound = option_index;
        -:21467:		  exact = 1;
        -:21468:		  break;
        -:21469:		}
        -:21470:	      else if (pfound == NULL)
        -:21471:		{
        -:21472:		  /* First nonexact match found.  */
        -:21473:		  pfound = p;
        -:21474:		  indfound = option_index;
        -:21475:		}
        -:21476:	      else
        -:21477:		/* Second or later nonexact match found.  */
        -:21478:		ambig = 1;
        -:21479:	    }
        -:21480:	if (ambig && !exact)
        -:21481:	  {
        -:21482:	    if (opterr)
        -:21483:	      fprintf (stderr, _("%s: option `-W %s' is ambiguous\n"),
        -:21484:		       argv[0], argv[optind]);
        -:21485:	    nextchar += strlen (nextchar);
        -:21486:	    optind++;
        -:21487:	    return '?';
        -:21488:	  }
        -:21489:	if (pfound != NULL)
        -:21490:	  {
        -:21491:	    option_index = indfound;
        -:21492:	    if (*nameend)
        -:21493:	      {
        -:21494:		/* Don't test has_arg with >, because some C compilers don't
        -:21495:		   allow it to be used on enums.  */
        -:21496:		if (pfound->has_arg)
        -:21497:		  optarg = nameend + 1;
        -:21498:		else
        -:21499:		  {
        -:21500:		    if (opterr)
        -:21501:		      fprintf (stderr, _("\
        -:21502:%s: option `-W %s' doesn't allow an argument\n"),
        -:21503:			       argv[0], pfound->name);
        -:21504:
        -:21505:		    nextchar += strlen (nextchar);
        -:21506:		    return '?';
        -:21507:		  }
        -:21508:	      }
        -:21509:	    else if (pfound->has_arg == 1)
        -:21510:	      {
        -:21511:		if (optind < argc)
        -:21512:		  optarg = argv[optind++];
        -:21513:		else
        -:21514:		  {
        -:21515:		    if (opterr)
        -:21516:		      fprintf (stderr,
        -:21517:			       _("%s: option `%s' requires an argument\n"),
        -:21518:			       argv[0], argv[optind - 1]);
        -:21519:		    nextchar += strlen (nextchar);
        -:21520:		    return optstring[0] == ':' ? ':' : '?';
        -:21521:		  }
        -:21522:	      }
        -:21523:	    nextchar += strlen (nextchar);
        -:21524:	    if (longind != NULL)
        -:21525:	      *longind = option_index;
        -:21526:	    if (pfound->flag)
        -:21527:	      {
        -:21528:		*(pfound->flag) = pfound->val;
        -:21529:		return 0;
        -:21530:	      }
        -:21531:	    return pfound->val;
        -:21532:	  }
        -:21533:	  nextchar = NULL;
        -:21534:	  return 'W';	/* Let the application handle it.   */
        -:21535:      }
        -:21536:    if (temp[1] == ':')
        -:21537:      {
        -:21538:	if (temp[2] == ':')
        -:21539:	  {
        -:21540:	    /* This is an option that accepts an argument optionally.  */
        -:21541:	    if (*nextchar != '\0')
        -:21542:	      {
        -:21543:		optarg = nextchar;
        -:21544:		optind++;
        -:21545:	      }
        -:21546:	    else
        -:21547:	      optarg = NULL;
        -:21548:	    nextchar = NULL;
        -:21549:	  }
        -:21550:	else
        -:21551:	  {
        -:21552:	    /* This is an option that requires an argument.  */
        -:21553:	    if (*nextchar != '\0')
        -:21554:	      {
        -:21555:		optarg = nextchar;
        -:21556:		/* If we end this ARGV-element by taking the rest as an arg,
        -:21557:		   we must advance to the next element now.  */
        -:21558:		optind++;
        -:21559:	      }
        -:21560:	    else if (optind == argc)
        -:21561:	      {
        -:21562:		if (opterr)
        -:21563:		  {
        -:21564:		    /* 1003.2 specifies the format of this message.  */
        -:21565:		    fprintf (stderr,
        -:21566:			   _("%s: option requires an argument -- %c\n"),
        -:21567:			   argv[0], c);
        -:21568:		  }
        -:21569:		optopt = c;
        -:21570:		if (optstring[0] == ':')
        -:21571:		  c = ':';
        -:21572:		else
        -:21573:		  c = '?';
        -:21574:	      }
        -:21575:	    else
        -:21576:	      /* We already incremented `optind' once;
        -:21577:		 increment it again when taking next ARGV-elt as argument.  */
        -:21578:	      optarg = argv[optind++];
        -:21579:	    nextchar = NULL;
        -:21580:	  }
        -:21581:      }
        -:21582:    return c;
        -:21583:  }
        -:21584:}
        -:21585:
        -:21586:int
        -:21587:getopt (argc, argv, optstring)
        -:21588:     int argc;
        -:21589:     char *const *argv;
        -:21590:     const char *optstring;
        -:21591:{
        -:21592:  return _getopt_internal (argc, argv, optstring,
        -:21593:			   (const struct option *) 0,
        -:21594:			   (int *) 0,
        -:21595:			   0);
        -:21596:}
        -:21597:
        -:21598:#endif	/* Not ELIDE_CODE.  */
        -:21599:
        -:21600:#ifdef TEST
        -:21601:
        -:21602:/* Compile with -DTEST to make an executable for use in testing
        -:21603:   the above definition of `getopt'.  */
        -:21604:
        -:21605:int
        -:21606:main (argc, argv)
        -:21607:     int argc;
        -:21608:     char **argv;
        -:21609:{
        -:21610:  int c;
        -:21611:  int digit_optind = 0;
        -:21612:
        -:21613:  while (1)
        -:21614:    {
        -:21615:      int this_option_optind = optind ? optind : 1;
        -:21616:
        -:21617:      c = getopt (argc, argv, "abc:d:0123456789");
        -:21618:      if (c == -1)
        -:21619:	break;
        -:21620:
        -:21621:      switch (c)
        -:21622:	{
        -:21623:	case '0':
        -:21624:	case '1':
        -:21625:	case '2':
        -:21626:	case '3':
        -:21627:	case '4':
        -:21628:	case '5':
        -:21629:	case '6':
        -:21630:	case '7':
        -:21631:	case '8':
        -:21632:	case '9':
        -:21633:	  if (digit_optind != 0 && digit_optind != this_option_optind)
        -:21634:	    printf ("digits occur in two different argv-elements.\n");
        -:21635:	  digit_optind = this_option_optind;
        -:21636:	  printf ("option %c\n", c);
        -:21637:	  break;
        -:21638:
        -:21639:	case 'a':
        -:21640:	  printf ("option a\n");
        -:21641:	  break;
        -:21642:
        -:21643:	case 'b':
        -:21644:	  printf ("option b\n");
        -:21645:	  break;
        -:21646:
        -:21647:	case 'c':
        -:21648:	  printf ("option c with value `%s'\n", optarg);
        -:21649:	  break;
        -:21650:
        -:21651:	case '?':
        -:21652:	  break;
        -:21653:
        -:21654:	default:
        -:21655:	  printf ("?? getopt returned character code 0%o ??\n", c);
        -:21656:	}
        -:21657:    }
        -:21658:
        -:21659:  if (optind < argc)
        -:21660:    {
        -:21661:      printf ("non-option ARGV-elements: ");
        -:21662:      while (optind < argc)
        -:21663:	printf ("%s ", argv[optind++]);
        -:21664:      printf ("\n");
        -:21665:    }
        -:21666:
        -:21667:  exit (0);
        -:21668:}
        -:21669:
        -:21670:#endif /* TEST */
        -:21671:
        -:21672:
        -:21673:
        -:21674:/*************************************************************
        -:21675:  ============================================================
        -:21676:  ************************************************************
        -:21677:  ============================================================
        -:21678:  ************************************************************
        -:21679:                         getopt1.c
        -:21680:  ************************************************************
        -:21681:  ============================================================
        -:21682:  ************************************************************
        -:21683:  ============================================================
        -:21684:  *************************************************************/
        -:21685:
        -:21686:/* getopt_long and getopt_long_only entry points for GNU getopt.
        -:21687:   Copyright (C) 1987,88,89,90,91,92,93,94,96,97,98
        -:21688:     Free Software Foundation, Inc.
        -:21689:
        -:21690:   NOTE: The canonical source of this file is maintained with the GNU C Library.
        -:21691:   Bugs can be reported to bug-glibc@gnu.org.
        -:21692:
        -:21693:   This program is free software; you can redistribute it and/or modify it
        -:21694:   under the terms of the GNU General Public License as published by the
        -:21695:   Free Software Foundation; either version 2, or (at your option) any
        -:21696:   later version.
        -:21697:
        -:21698:   This program is distributed in the hope that it will be useful,
        -:21699:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:21700:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:21701:   GNU General Public License for more details.
        -:21702:
        -:21703:   You should have received a copy of the GNU General Public License
        -:21704:   along with this program; if not, write to the Free Software
        -:21705:   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
        -:21706:   USA.  */
        -:21707:
        -:21708:#ifdef HAVE_CONFIG_H
        -:21709:#include <config.h>
        -:21710:#undef stderr
        -:21711:#define stderr stdout
        -:21712:#endif
        -:21713:
        -:21714:#include "getopt.h"
        -:21715:#undef stderr
        -:21716:#define stderr stdout
        -:21717:
        -:21718:#if !defined __STDC__ || !__STDC__
        -:21719:/* This is a separate conditional since some stdc systems
        -:21720:   reject `defined (const)'.  */
        -:21721:#ifndef const
        -:21722:#define const
        -:21723:#endif
        -:21724:#endif
        -:21725:
        -:21726:#include <stdio.h>
        -:21727:
        -:21728:#undef stderr
        -:21729:#define stderr stdout
        -:21730:/* Comment out all this code if we are using the GNU C Library, and are not
        -:21731:   actually compiling the library itself.  This code is part of the GNU C
        -:21732:   Library, but also included in many other GNU distributions.  Compiling
        -:21733:   and linking in this code is a waste when using the GNU C library
        -:21734:   (especially if it is a shared library).  Rather than having every GNU
        -:21735:   program understand `configure --with-gnu-libc' and omit the object files,
        -:21736:   it is simpler to just do this in the source for each such file.  */
        -:21737:
        -:21738:#define GETOPT_INTERFACE_VERSION 2
        -:21739:#if !defined _LIBC && defined __GLIBC__ && __GLIBC__ >= 2
        -:21740:#include <gnu-versions.h>
        -:21741:#undef stderr
        -:21742:#define stderr stdout
        -:21743:#if _GNU_GETOPT_INTERFACE_VERSION == GETOPT_INTERFACE_VERSION
        -:21744:#define ELIDE_CODE
        -:21745:#endif
        -:21746:#endif
        -:21747:
        -:21748:#ifndef ELIDE_CODE
        -:21749:
        -:21750:
        -:21751:/* This needs to come after some library #include
        -:21752:   to get __GNU_LIBRARY__ defined.  */
        -:21753:#ifdef __GNU_LIBRARY__
        -:21754:#include <stdlib.h>
        -:21755:#undef stderr
        -:21756:#define stderr stdout
        -:21757:#endif
        -:21758:
        -:21759:#ifndef	NULL
        -:21760:#define NULL 0
        -:21761:#endif
        -:21762:
        -:21763:int
        -:21764:getopt_long (argc, argv, options, long_options, opt_index)
        -:21765:     int argc;
        -:21766:     char *const *argv;
        -:21767:     const char *options;
        -:21768:     const struct option *long_options;
        -:21769:     int *opt_index;
        -:21770:{
        -:21771:  return _getopt_internal (argc, argv, options, long_options, opt_index, 0);
        -:21772:}
        -:21773:
        -:21774:/* Like getopt_long, but '-' as well as '--' can indicate a long option.
        -:21775:   If an option that starts with '-' (not '--') doesn't match a long option,
        -:21776:   but does match a short option, it is parsed as a short option
        -:21777:   instead.  */
        -:21778:
        -:21779:int
        -:21780:getopt_long_only (argc, argv, options, long_options, opt_index)
        -:21781:     int argc;
        -:21782:     char *const *argv;
        -:21783:     const char *options;
        -:21784:     const struct option *long_options;
        -:21785:     int *opt_index;
        -:21786:{
        -:21787:  return _getopt_internal (argc, argv, options, long_options, opt_index, 1);
        -:21788:}
        -:21789:
        -:21790:
        -:21791:#endif	/* Not ELIDE_CODE.  */
        -:21792:
        -:21793:#ifdef TEST
        -:21794:
        -:21795:#include <stdio.h>
        -:21796:#undef stderr
        -:21797:#define stderr stdout
        -:21798:
        -:21799:int
        -:21800:main (argc, argv)
        -:21801:     int argc;
        -:21802:     char **argv;
        -:21803:{
        -:21804:  int c;
        -:21805:  int digit_optind = 0;
        -:21806:
        -:21807:  while (1)
        -:21808:    {
        -:21809:      int this_option_optind = optind ? optind : 1;
        -:21810:      int option_index = 0;
        -:21811:      static struct option long_options[] =
        -:21812:      {
        -:21813:	{"add", 1, 0, 0},
        -:21814:	{"append", 0, 0, 0},
        -:21815:	{"delete", 1, 0, 0},
        -:21816:	{"verbose", 0, 0, 0},
        -:21817:	{"create", 0, 0, 0},
        -:21818:	{"file", 1, 0, 0},
        -:21819:	{0, 0, 0, 0}
        -:21820:      };
        -:21821:
        -:21822:      c = getopt_long (argc, argv, "abc:d:0123456789",
        -:21823:		       long_options, &option_index);
        -:21824:      if (c == -1)
        -:21825:	break;
        -:21826:
        -:21827:      switch (c)
        -:21828:	{
        -:21829:	case 0:
        -:21830:	  printf ("option %s", long_options[option_index].name);
        -:21831:	  if (optarg)
        -:21832:	    printf (" with arg %s", optarg);
        -:21833:	  printf ("\n");
        -:21834:	  break;
        -:21835:
        -:21836:	case '0':
        -:21837:	case '1':
        -:21838:	case '2':
        -:21839:	case '3':
        -:21840:	case '4':
        -:21841:	case '5':
        -:21842:	case '6':
        -:21843:	case '7':
        -:21844:	case '8':
        -:21845:	case '9':
        -:21846:	  if (digit_optind != 0 && digit_optind != this_option_optind)
        -:21847:	    printf ("digits occur in two different argv-elements.\n");
        -:21848:	  digit_optind = this_option_optind;
        -:21849:	  printf ("option %c\n", c);
        -:21850:	  break;
        -:21851:
        -:21852:	case 'a':
        -:21853:	  printf ("option a\n");
        -:21854:	  break;
        -:21855:
        -:21856:	case 'b':
        -:21857:	  printf ("option b\n");
        -:21858:	  break;
        -:21859:
        -:21860:	case 'c':
        -:21861:	  printf ("option c with value `%s'\n", optarg);
        -:21862:	  break;
        -:21863:
        -:21864:	case 'd':
        -:21865:	  printf ("option d with value `%s'\n", optarg);
        -:21866:	  break;
        -:21867:
        -:21868:	case '?':
        -:21869:	  break;
        -:21870:
        -:21871:	default:
        -:21872:	  printf ("?? getopt returned character code 0%o ??\n", c);
        -:21873:	}
        -:21874:    }
        -:21875:
        -:21876:  if (optind < argc)
        -:21877:    {
        -:21878:      printf ("non-option ARGV-elements: ");
        -:21879:      while (optind < argc)
        -:21880:	printf ("%s ", argv[optind++]);
        -:21881:      printf ("\n");
        -:21882:    }
        -:21883:
        -:21884:  exit (0);
        -:21885:}
        -:21886:
        -:21887:#endif /* TEST */
        -:21888:
        -:21889:
