        -:    0:Source:flex.c
        -:    0:Graph:flex.gcno
        -:    0:Data:flex.gcda
        -:    0:Runs:567
        -:    1:/* flex - tool to generate fast lexical analyzers */
        -:    2:
        -:    3:/*-
        -:    4: * Copyright (c) 1990 The Regents of the University of California.
        -:    5: * All rights reserved.
        -:    6: *
        -:    7: * This code is derived from software contributed to Berkeley by
        -:    8: * Vern Paxson.
        -:    9: * 
        -:   10: * The United States Government has rights in this work pursuant
        -:   11: * to contract no. DE-AC03-76SF00098 between the United States
        -:   12: * Department of Energy and the University of California.
        -:   13: *
        -:   14: * Redistribution and use in source and binary forms are permitted provided
        -:   15: * that: (1) source distributions retain this entire copyright notice and
        -:   16: * comment, and (2) distributions including binaries display the following
        -:   17: * acknowledgement:  ``This product includes software developed by the
        -:   18: * University of California, Berkeley and its contributors'' in the
        -:   19: * documentation or other materials provided with the distribution and in
        -:   20: * all advertising materials mentioning features or use of this software.
        -:   21: * Neither the name of the University nor the names of its contributors may
        -:   22: * be used to endorse or promote products derived from this software without
        -:   23: * specific prior written permission.
        -:   24: * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
        -:   25: * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
        -:   26: * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
        -:   27: */
        -:   28:
        -:   29:#define LINUX 1
        -:   30:
        -:   31:#ifndef lint
        -:   32:char copyright[] =
        -:   33:"@(#) Copyright (c) 1990 The Regents of the University of California.\n\
        -:   34: All rights reserved.\n";
        -:   35:#endif /* not lint */
        -:   36:
        -:   37:/* $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.seeded/v1/flex.c,v 1.1.1.2 2003/09/02 20:21:59 expsir Exp $ */
        -:   38:
        -:   39:
        -:   40:#include "flexdef.h"
        -:   41:#include "version.h"
        -:   42:#include <ctype.h>
        -:   43:#include "parse.h"
        -:   44:#include "FaultSeeds.h"
        -:   45:
        -:   46:static char flex_version[] = FLEX_VERSION;
        -:   47:
        -:   48:
        -:   49:/* declare functions that have forward references */
        -:   50:
        -:   51:void flexinit PROTO((int, char**));
        -:   52:void readin PROTO((void));
        -:   53:void set_up_initial_allocations PROTO((void));
        -:   54:
        -:   55:
        -:   56:/* these globals are all defined and commented in flexdef.h */
        -:   57:int printstats, syntaxerror, eofseen, ddebug, trace, nowarn, spprdflt;
        -:   58:int interactive, caseins, lex_compat, useecs, fulltbl, usemecs;
        -:   59:int fullspd, gen_line_dirs, performance_report, backing_up_report;
        -:   60:int C_plus_plus, long_align, use_read, yytext_is_array, csize;
        -:   61:int yymore_used, reject, real_reject, continued_action;
        -:   62:int yymore_really_used, reject_really_used;
        -:   63:int datapos, dataline, linenum;
        -:   64:FILE *skelfile = NULL;
        -:   65:
        -:   66:/* ### add for testing ### */
        -:   67:FILE *err = NULL;
        -:   68:/* ####################### */
        -:   69:
        -:   70:int skel_ind = 0;
        -:   71:char *action_array;
        -:   72:int action_size, defs1_offset, prolog_offset, action_offset, action_index;
        -:   73:char *infilename = NULL;
        -:   74:int onestate[ONE_STACK_SIZE], onesym[ONE_STACK_SIZE];
        -:   75:int onenext[ONE_STACK_SIZE], onedef[ONE_STACK_SIZE], onesp;
        -:   76:int current_mns, num_rules, num_eof_rules, default_rule;
        -:   77:int current_max_rules, lastnfa;
        -:   78:int *firstst, *lastst, *finalst, *transchar, *trans1, *trans2;
        -:   79:int *accptnum, *assoc_rule, *state_type;
        -:   80:int *rule_type, *rule_linenum, *rule_useful;
        -:   81:int current_state_type;
        -:   82:int variable_trailing_context_rules;
        -:   83:int numtemps, numprots, protprev[MSP], protnext[MSP], prottbl[MSP];
        -:   84:int protcomst[MSP], firstprot, lastprot, protsave[PROT_SAVE_SIZE];
        -:   85:int numecs, nextecm[CSIZE + 1], ecgroup[CSIZE + 1], nummecs, tecfwd[CSIZE + 1];
        -:   86:int tecbck[CSIZE + 1];
        -:   87:int lastsc, current_max_scs, *scset, *scbol, *scxclu, *sceof, *actvsc;
        -:   88:char **scname;
        -:   89:int current_max_dfa_size, current_max_xpairs;
        -:   90:int current_max_template_xpairs, current_max_dfas;
        -:   91:int lastdfa, *nxt, *chk, *tnxt;
        -:   92:int *base, *def, *nultrans, NUL_ec, tblend, firstfree, **dss, *dfasiz;
        -:   93:union dfaacc_union *dfaacc;
        -:   94:int *accsiz, *dhash, numas;
        -:   95:int numsnpairs, jambase, jamstate;
        -:   96:int lastccl, current_maxccls, *cclmap, *ccllen, *cclng, cclreuse;
        -:   97:int current_max_ccl_tbl_size;
        -:   98:Char *ccltbl;
        -:   99:char nmstr[MAXLINE];
        -:  100:int sectnum, nummt, hshcol, dfaeql, numeps, eps2, num_reallocs;
        -:  101:int tmpuses, totnst, peakpairs, numuniq, numdup, hshsave;
        -:  102:int num_backing_up, bol_needed;
        -:  103:FILE *backing_up_file;
        -:  104:int end_of_buffer_state;
        -:  105:char **input_files;
        -:  106:int num_input_files;
        -:  107:char *program_name;
        -:  108:
        -:  109:#ifndef SHORT_FILE_NAMES
        -:  110:static char *outfile_template = "lex.%s.%s";
        -:  111:#else
        -:  112:static char *outfile_template = "lex%s.%s";
        -:  113:#endif
        -:  114:static char outfile_path[64];
        -:  115:
        -:  116:static int outfile_created = 0;
        -:  117:static int use_stdout;
        -:  118:static char *skelname = NULL;
        -:  119:static char *prefix = "yy";
        -:  120:
        -:  121:
function main called 567 returned 0% blocks executed 95%
      567:  122:int main( argc, argv )
        -:  123:int argc;
        -:  124:char **argv;
        -:  125:	{
        -:  126:	int i;
        -:  127:
        -:  128:/* ### add for testing ### */
        -:  129:
      567:  130:	if(--argc >0){
branch  0 taken 567 (fallthrough)
branch  1 taken 0
      567:  131:                err = fopen( *++argv, "w" );
call    0 returned 567
      567:  132:                --argv; ++argc;
        -:  133:        }
        -:  134:/* ####################### */
        -:  135:
        -:  136:
      567:  137:	flexinit( argc, argv );
call    0 returned 552
        -:  138:
      552:  139:	readin();
call    0 returned 543
        -:  140:
      543:  141:	ntod();
call    0 returned 543
        -:  142:
     4353:  143:	for ( i = 1; i <= num_rules; ++i )
branch  0 taken 3810
branch  1 taken 543 (fallthrough)
     3810:  144:		if ( ! rule_useful[i] && i != default_rule )
branch  0 taken 85 (fallthrough)
branch  1 taken 3725
branch  2 taken 12 (fallthrough)
branch  3 taken 73
       12:  145:			line_warning( "rule cannot be matched",
       12:  146:					rule_linenum[i] );
call    0 returned 12
        -:  147:
      543:  148:	if ( spprdflt && ! reject && rule_useful[default_rule] )
branch  0 taken 3 (fallthrough)
branch  1 taken 540
branch  2 taken 1 (fallthrough)
branch  3 taken 2
branch  4 taken 1 (fallthrough)
branch  5 taken 0
        1:  149:		line_warning( "-s option given but default rule can be matched",
        1:  150:			rule_linenum[default_rule] );
call    0 returned 1
        -:  151:
        -:  152:	/* Generate the C state transition tables from the DFA. */
      543:  153:	make_tables();
call    0 returned 543
        -:  154:
        -:  155:	/* Note, flexend does not return.  It exits with its argument
        -:  156:	 * as status.
        -:  157:	 */
      543:  158:	flexend( 0 );
call    0 returned 0
        -:  159:
    #####:  160:	return 0;	/* keep compilers/lint happy */
        -:  161:	}
        -:  162:
        -:  163:
        -:  164:/* flexend - terminate flex
        -:  165: *
        -:  166: * note
        -:  167: *    This routine does not return.
        -:  168: */
        -:  169:
function flexend called 564 returned 0% blocks executed 88%
      564:  170:void flexend( exit_status )
        -:  171:int exit_status;
        -:  172:
        -:  173:	{
        -:  174:	int tblsiz;
        -:  175:	int unlink();
        -:  176:
      564:  177:	if ( skelfile != NULL )
branch  0 taken 2 (fallthrough)
branch  1 taken 562
        -:  178:		{
        2:  179:		if ( ferror( skelfile ) )
call    0 returned 2
branch  1 taken 0 (fallthrough)
branch  2 taken 2
    #####:  180:			flexfatal(
call    0 never executed
        -:  181:				"error occurred when reading skeleton file" );
        -:  182:
        2:  183:		else if ( fclose( skelfile ) )
call    0 returned 2
branch  1 taken 0 (fallthrough)
branch  2 taken 2
    #####:  184:			flexfatal(
call    0 never executed
        -:  185:				"error occurred when closing skeleton file" );
        -:  186:		}
        -:  187:
      564:  188:	if ( exit_status != 0 && outfile_created )
branch  0 taken 21 (fallthrough)
branch  1 taken 543
branch  2 taken 11 (fallthrough)
branch  3 taken 10
        -:  189:		{
       11:  190:		if ( ferror( stdout ) )
call    0 returned 11
branch  1 taken 0 (fallthrough)
branch  2 taken 11
    #####:  191:			flexfatal( "error occurred when writing output file" );
call    0 never executed
        -:  192:
       11:  193:		else if ( fclose( stdout ) )
call    0 returned 11
branch  1 taken 0 (fallthrough)
branch  2 taken 11
    #####:  194:			flexfatal( "error occurred when closing output file" );
call    0 never executed
        -:  195:
       11:  196:		else if ( unlink( outfile_path ) )
call    0 returned 11
branch  1 taken 0 (fallthrough)
branch  2 taken 11
    #####:  197:			flexfatal( "error occurred when deleting output file" );
call    0 never executed
        -:  198:		}
        -:  199:
      564:  200:	if ( backing_up_report && backing_up_file )
branch  0 taken 5 (fallthrough)
branch  1 taken 559
branch  2 taken 5 (fallthrough)
branch  3 taken 0
        -:  201:		{
        5:  202:		if ( num_backing_up == 0 )
branch  0 taken 0 (fallthrough)
branch  1 taken 5
    #####:  203:			fprintf( backing_up_file, "No backing up.\n" );
call    0 never executed
        5:  204:		else if ( fullspd || fulltbl )
branch  0 taken 5 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 5
    #####:  205:			fprintf( backing_up_file,
call    0 never executed
        -:  206:				"%d backing up (non-accepting) states.\n",
        -:  207:				num_backing_up );
        -:  208:		else
        5:  209:			fprintf( backing_up_file,
call    0 returned 5
        -:  210:				"Compressed tables always back up.\n" );
        -:  211:
        5:  212:		if ( ferror( backing_up_file ) )
call    0 returned 5
branch  1 taken 0 (fallthrough)
branch  2 taken 5
    #####:  213:			flexfatal( "error occurred when writing backup file" );
call    0 never executed
        -:  214:
        5:  215:		else if ( fclose( backing_up_file ) )
call    0 returned 5
branch  1 taken 0 (fallthrough)
branch  2 taken 5
    #####:  216:			flexfatal( "error occurred when closing backup file" );
call    0 never executed
        -:  217:		}
        -:  218:
      564:  219:	if ( printstats )
branch  0 taken 9 (fallthrough)
branch  1 taken 555
        -:  220:		{
        9:  221:		fprintf( err, "%s version %s usage statistics:\n",
call    0 returned 9
        -:  222:			program_name, flex_version );
        -:  223:
        9:  224:		fprintf( err, "  scanner options: -" );
call    0 returned 9
        -:  225:
        9:  226:		if ( C_plus_plus )
branch  0 taken 0 (fallthrough)
branch  1 taken 9
    #####:  227:			putc( '+', err );
call    0 never executed
        9:  228:		if ( backing_up_report )
branch  0 taken 3 (fallthrough)
branch  1 taken 6
        3:  229:			putc( 'b', err );
call    0 returned 3
        9:  230:		if ( ddebug )
branch  0 taken 2 (fallthrough)
branch  1 taken 7
        2:  231:			putc( 'd', err );
call    0 returned 2
        9:  232:		if ( caseins )
branch  0 taken 2 (fallthrough)
branch  1 taken 7
        2:  233:			putc( 'i', err );
call    0 returned 2
        9:  234:		if ( lex_compat )
branch  0 taken 2 (fallthrough)
branch  1 taken 7
        2:  235:			putc( 'l', err );
call    0 returned 2
        9:  236:		if ( performance_report > 0 )
branch  0 taken 2 (fallthrough)
branch  1 taken 7
        2:  237:			putc( 'p', err );
call    0 returned 2
        9:  238:		if ( performance_report > 1 )
branch  0 taken 0 (fallthrough)
branch  1 taken 9
    #####:  239:			putc( 'p', err );
call    0 never executed
        9:  240:		if ( spprdflt )
branch  0 taken 2 (fallthrough)
branch  1 taken 7
        2:  241:			putc( 's', err );
call    0 returned 2
        9:  242:		if ( use_stdout )
branch  0 taken 2 (fallthrough)
branch  1 taken 7
        2:  243:			putc( 't', err );
call    0 returned 2
        9:  244:		if ( printstats )
branch  0 taken 9 (fallthrough)
branch  1 taken 0
        9:  245:			putc( 'v', err );	/* always true! */
call    0 returned 9
        9:  246:		if ( nowarn )
branch  0 taken 2 (fallthrough)
branch  1 taken 7
        2:  247:			putc( 'w', err );
call    0 returned 2
        9:  248:		if ( ! interactive )
branch  0 taken 3 (fallthrough)
branch  1 taken 6
        3:  249:			putc( 'B', err );
call    0 returned 3
        9:  250:		if ( interactive )
branch  0 taken 6 (fallthrough)
branch  1 taken 3
        6:  251:			putc( 'I', err );
call    0 returned 6
        9:  252:		if ( ! gen_line_dirs )
branch  0 taken 2 (fallthrough)
branch  1 taken 7
        2:  253:			putc( 'L', err );
call    0 returned 2
        9:  254:		if ( trace )
branch  0 taken 4 (fallthrough)
branch  1 taken 5
        4:  255:			putc( 'T', err );
call    0 returned 4
        9:  256:		if ( csize == 128 )
branch  0 taken 1 (fallthrough)
branch  1 taken 8
        1:  257:			putc( '7', err );
call    0 returned 1
        -:  258:		else
        8:  259:			putc( '8', err );
call    0 returned 8
        -:  260:
        9:  261:		fprintf( err, " -C" );
call    0 returned 9
        -:  262:
        9:  263:		if ( long_align )
branch  0 taken 3 (fallthrough)
branch  1 taken 6
        3:  264:			putc( 'a', err );
call    0 returned 3
        9:  265:		if ( fulltbl )
branch  0 taken 1 (fallthrough)
branch  1 taken 8
        1:  266:			putc( 'f', err );
call    0 returned 1
        9:  267:		if ( fullspd )
branch  0 taken 1 (fallthrough)
branch  1 taken 8
        1:  268:			putc( 'F', err );
call    0 returned 1
        9:  269:		if ( useecs )
branch  0 taken 8 (fallthrough)
branch  1 taken 1
        8:  270:			putc( 'e', err );
call    0 returned 8
        9:  271:		if ( usemecs )
branch  0 taken 8 (fallthrough)
branch  1 taken 1
        8:  272:			putc( 'm', err );
call    0 returned 8
        9:  273:		if ( use_read )
branch  0 taken 2 (fallthrough)
branch  1 taken 7
        2:  274:			putc( 'r', err );
call    0 returned 2
        -:  275:
        9:  276:		if ( skelname )
branch  0 taken 1 (fallthrough)
branch  1 taken 8
        1:  277:			fprintf( err, " -S%s", skelname );
call    0 returned 1
        -:  278:
        9:  279:		if ( strcmp( prefix, "yy" ) )
branch  0 taken 0 (fallthrough)
branch  1 taken 9
    #####:  280:			fprintf( err, " -P%s", prefix );
call    0 never executed
        -:  281:
        9:  282:		putc( '\n', err );
call    0 returned 9
        -:  283:
        9:  284:		fprintf( err, "  %d/%d NFA states\n", lastnfa, current_mns );
call    0 returned 9
        9:  285:		fprintf( err, "  %d/%d DFA states (%d words)\n", lastdfa,
call    0 returned 9
        -:  286:			current_max_dfas, totnst );
        9:  287:		fprintf( err, "  %d rules\n",
        9:  288:		num_rules + num_eof_rules - 1 /* - 1 for def. rule */ );
call    0 returned 9
        -:  289:
        9:  290:		if ( num_backing_up == 0 )
branch  0 taken 2 (fallthrough)
branch  1 taken 7
        2:  291:			fprintf( err, "  No backing up\n" );
call    0 returned 2
        7:  292:		else if ( fullspd || fulltbl )
branch  0 taken 7 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 7
    #####:  293:			fprintf( err,
call    0 never executed
        -:  294:				"  %d backing-up (non-accepting) states\n",
        -:  295:				num_backing_up );
        -:  296:		else
        7:  297:			fprintf( err,
call    0 returned 7
        -:  298:				"  Compressed tables always back-up\n" );
        -:  299:
        9:  300:		if ( bol_needed )
branch  0 taken 0 (fallthrough)
branch  1 taken 9
    #####:  301:			fprintf( err,
call    0 never executed
        -:  302:				"  Beginning-of-line patterns used\n" );
        -:  303:
        9:  304:		fprintf( err, "  %d/%d start conditions\n", lastsc,
call    0 returned 9
        -:  305:			current_max_scs );
        9:  306:		fprintf( err,
call    0 returned 9
        -:  307:			"  %d epsilon states, %d double epsilon states\n",
        -:  308:			numeps, eps2 );
        -:  309:
        9:  310:		if ( lastccl == 0 )
branch  0 taken 2 (fallthrough)
branch  1 taken 7
        2:  311:			fprintf( err, "  no character classes\n" );
call    0 returned 2
        -:  312:		else
        7:  313:			fprintf( err,
        -:  314:	"  %d/%d character classes needed %d/%d words of storage, %d reused\n",
        -:  315:				lastccl, current_maxccls,
        7:  316:				cclmap[lastccl] + ccllen[lastccl],
call    0 returned 7
        -:  317:				current_max_ccl_tbl_size, cclreuse );
        -:  318:
        9:  319:		fprintf( err, "  %d state/nextstate pairs created\n",
call    0 returned 9
        -:  320:			numsnpairs );
        9:  321:		fprintf( err, "  %d/%d unique/duplicate transitions\n",
call    0 returned 9
        -:  322:			numuniq, numdup );
        -:  323:
        9:  324:		if ( fulltbl )
branch  0 taken 1 (fallthrough)
branch  1 taken 8
        -:  325:			{
        1:  326:			tblsiz = lastdfa * numecs;
        1:  327:			fprintf( err, "  %d table entries\n", tblsiz );
call    0 returned 1
        -:  328:			}
        -:  329:
        -:  330:		else
        -:  331:			{
        8:  332:			tblsiz = 2 * (lastdfa + numtemps) + 2 * tblend;
        -:  333:
        8:  334:			fprintf( err, "  %d/%d base-def entries created\n",
call    0 returned 8
        -:  335:				lastdfa + numtemps, current_max_dfas );
        8:  336:			fprintf( err,
call    0 returned 8
        -:  337:				"  %d/%d (peak %d) nxt-chk entries created\n",
        -:  338:				tblend, current_max_xpairs, peakpairs );
        8:  339:			fprintf( err,
call    0 returned 8
        -:  340:			"  %d/%d (peak %d) template nxt-chk entries created\n",
        -:  341:				numtemps * nummecs, current_max_template_xpairs,
        -:  342:				numtemps * numecs );
        8:  343:			fprintf( err, "  %d empty table entries\n", nummt );
call    0 returned 8
        8:  344:			fprintf( err, "  %d protos created\n", numprots );
call    0 returned 8
        8:  345:			fprintf( err, "  %d templates created, %d uses\n",
call    0 returned 8
        -:  346:				numtemps, tmpuses );
        -:  347:			}
        -:  348:
        9:  349:		if ( useecs )
branch  0 taken 8 (fallthrough)
branch  1 taken 1
        -:  350:			{
        8:  351:			tblsiz = tblsiz + csize;
        8:  352:			fprintf( err,
call    0 returned 8
        -:  353:				"  %d/%d equivalence classes created\n",
        -:  354:				numecs, csize );
        -:  355:			}
        -:  356:
        9:  357:		if ( usemecs )
branch  0 taken 8 (fallthrough)
branch  1 taken 1
        -:  358:			{
        8:  359:			tblsiz = tblsiz + numecs;
        8:  360:			fprintf( err,
call    0 returned 8
        -:  361:				"  %d/%d meta-equivalence classes created\n",
        -:  362:				nummecs, csize );
        -:  363:			}
        -:  364:
        9:  365:		fprintf( err,
call    0 returned 9
        -:  366:			"  %d (%d saved) hash collisions, %d DFAs equal\n",
        -:  367:			hshcol, hshsave, dfaeql );
        9:  368:		fprintf( err, "  %d sets of reallocations needed\n",
call    0 returned 9
        -:  369:			num_reallocs );
        9:  370:		fprintf( err, "  %d total table entries needed\n", tblsiz );
call    0 returned 9
        -:  371:		}
        -:  372:
        -:  373:#ifndef VMS
      564:  374:	exit( exit_status );
        -:  375:#else
        -:  376:	exit( exit_status + 1 );
        -:  377:#endif
        -:  378:	}
        -:  379:
        -:  380:
        -:  381:/* flexinit - initialize flex */
        -:  382:
function flexinit called 567 returned 97% blocks executed 93%
      567:  383:void flexinit( argc, argv )
        -:  384:int argc;
        -:  385:char **argv;
        -:  386:	{
        -:  387:	int i, sawcmpflag;
        -:  388:	int csize_given, interactive_given;
        -:  389:	char *arg, *mktemp();
        -:  390:
      567:  391:	printstats = syntaxerror = trace = spprdflt = caseins = false;
      567:  392:	lex_compat = false;
      567:  393:	C_plus_plus = backing_up_report = ddebug = fulltbl = fullspd = false;
      567:  394:	long_align = nowarn = yymore_used = continued_action = reject = false;
      567:  395:	yytext_is_array = yymore_really_used = reject_really_used = false;
      567:  396:	gen_line_dirs = usemecs = useecs = true;
      567:  397:	performance_report = 0;
        -:  398:
      567:  399:	sawcmpflag = false;
      567:  400:	use_read = use_stdout = false;
      567:  401:	csize_given = false;
      567:  402:	interactive_given = false;
        -:  403:
        -:  404:	/* Initialize dynamic array for holding the rule actions. */
      567:  405:	action_size = 2048;	/* default size of action array in bytes */
      567:  406:	action_array = allocate_character_array( action_size );
call    0 returned 567
      567:  407:	defs1_offset = prolog_offset = action_offset = action_index = 0;
      567:  408:	action_array[0] = '\0';
        -:  409:
        -:  410:/* Commented by Amit Goel on 5th September 2001 to remove nomdeterminism */
        -:  411:/*	program_name = argv[0];  */
        -:  412:/* Added by Amit Goel on 5th September 2001 */
      567:  413:        program_name = "Executable";
        -:  414:
      567:  415:	if ( program_name[0] != '\0' &&
branch  0 taken 567 (fallthrough)
branch  1 taken 0
      567:  416:	     program_name[strlen( program_name ) - 1] == '+' )
branch  0 taken 0 (fallthrough)
branch  1 taken 567
    #####:  417:		C_plus_plus = true;
        -:  418:
        -:  419:/* ### add for testing ### */
      567:  420:        ++argv;--argc;
        -:  421:/* ####################### */
        -:  422:
        -:  423:
        -:  424:	/* read flags */
     1516:  425:	for ( --argc, ++argv; argc ; --argc, ++argv )
branch  0 taken 1516
branch  1 taken 0 (fallthrough)
        -:  426:		{
     1516:  427:		if ( argv[0][0] != '-' || argv[0][1] == '\0' )
branch  0 taken 956 (fallthrough)
branch  1 taken 560
branch  2 taken 956 (fallthrough)
branch  3 taken 0
        -:  428:			break;
        -:  429:
      956:  430:		arg = argv[0];
        -:  431:
     1614:  432:		for ( i = 1; arg[i] != '\0'; ++i )
branch  0 taken 1148
branch  1 taken 466 (fallthrough)
     1148:  433:			switch ( arg[i] )
branch  0 taken 0
branch  1 taken 2
branch  2 taken 5
branch  3 taken 1
branch  4 taken 478
branch  5 taken 252
branch  6 taken 84
branch  7 taken 80
branch  8 taken 1
branch  9 taken 3
branch 10 taken 3
branch 11 taken 163
branch 12 taken 3
branch 13 taken 1
branch 14 taken 4
branch 15 taken 15
branch 16 taken 4
branch 17 taken 3
branch 18 taken 3
branch 19 taken 24
branch 20 taken 9
branch 21 taken 1
branch 22 taken 3
branch 23 taken 3
branch 24 taken 2
branch 25 taken 1
        -:  434:				{
    #####:  435:				case '+':
    #####:  436:					C_plus_plus = true;
    #####:  437:					break;
        -:  438:
        2:  439:				case 'B':
        2:  440:					interactive = false;
        2:  441:					interactive_given = true;
        2:  442:					break;
        -:  443:
        5:  444:				case 'b':
        5:  445:					backing_up_report = true;
        5:  446:					break;
        -:  447:
        1:  448:				case 'c':
        1:  449:					fprintf( err,
call    0 returned 1
        -:  450:	"%s: Assuming use of deprecated -c flag is really intended to be -C\n",
        -:  451:					program_name );
        -:  452:
        -:  453:					/* fall through */
        -:  454:
      479:  455:				case 'C':
      479:  456:					if ( i != 1 )
branch  0 taken 1 (fallthrough)
branch  1 taken 478
        1:  457:						flexerror(
call    0 returned 0
        -:  458:					"-C flag must be given separately" );
        -:  459:
      478:  460:					if ( ! sawcmpflag )
branch  0 taken 477 (fallthrough)
branch  1 taken 1
        -:  461:						{
      477:  462:						useecs = false;
      477:  463:						usemecs = false;
      477:  464:						fulltbl = false;
      477:  465:						sawcmpflag = true;
        -:  466:						}
        -:  467:
     1402:  468:					for ( ++i; arg[i] != '\0'; ++i )
branch  0 taken 925
branch  1 taken 477 (fallthrough)
      925:  469:						switch ( arg[i] )
branch  0 taken 243
branch  1 taken 243
branch  2 taken 15
branch  3 taken 18
branch  4 taken 163
branch  5 taken 242
branch  6 taken 1
        -:  470:							{
      243:  471:							case 'a':
      243:  472:								long_align =
        -:  473:									true;
      243:  474:								break;
        -:  475:
      243:  476:							case 'e':
      243:  477:								useecs = true;
      243:  478:								break;
        -:  479:
       15:  480:							case 'F':
       15:  481:								fullspd = true;
       15:  482:								break;
        -:  483:
       18:  484:							case 'f':
       18:  485:								fulltbl = true;
       18:  486:								break;
        -:  487:
      163:  488:							case 'm':
      163:  489:								usemecs = true;
      163:  490:								break;
        -:  491:
      242:  492:							case 'r':
      242:  493:								use_read = true;
      242:  494:								break;
        -:  495:
        1:  496:							default:
        1:  497:								lerrif(
        -:  498:						"unknown -C option '%c'",
        1:  499:								(int) arg[i] );
call    0 returned 0
    #####:  500:								break;
        -:  501:							}
        -:  502:
      477:  503:					goto get_next_arg;
        -:  504:
      252:  505:				case 'd':
      252:  506:					ddebug = true;
      252:  507:					break;
        -:  508:
       84:  509:				case 'f':
       84:  510:					useecs = usemecs = false;
       84:  511:					use_read = fulltbl = true;
       84:  512:					break;
        -:  513:
       80:  514:				case 'F':
       80:  515:					useecs = usemecs = false;
       80:  516:					use_read = fullspd = true;
       80:  517:					break;
        -:  518:
        1:  519:				case 'h':
        1:  520:					usage();
call    0 returned 1
        1:  521:					exit( 0 );
call    0 returned 0
        -:  522:
        3:  523:				case 'I':
        3:  524:					interactive = true;
        3:  525:					interactive_given = true;
        3:  526:					break;
        -:  527:
        3:  528:				case 'i':
        3:  529:					caseins = true;
        3:  530:					break;
        -:  531:
      163:  532:				case 'l':
      163:  533:					lex_compat = true;
      163:  534:					break;
        -:  535:
        3:  536:				case 'L':
        3:  537:					gen_line_dirs = false;
        3:  538:					break;
        -:  539:
        1:  540:				case 'n':
        -:  541:					/* Stupid do-nothing deprecated
        -:  542:					 * option.
        -:  543:					 */
        1:  544:					break;
        -:  545:
        4:  546:				case 'P':
        4:  547:					if ( i != 1 )
branch  0 taken 1 (fallthrough)
branch  1 taken 3
        1:  548:						flexerror(
call    0 returned 0
        -:  549:					"-P flag must be given separately" );
        -:  550:
        3:  551:					prefix = arg + i + 1;
        3:  552:					goto get_next_arg;
        -:  553:
       15:  554:				case 'p':
       15:  555:					++performance_report;
       15:  556:					break;
        -:  557:
        4:  558:				case 'S':
        4:  559:					if ( i != 1 )
branch  0 taken 1 (fallthrough)
branch  1 taken 3
        1:  560:						flexerror(
call    0 returned 0
        -:  561:					"-S flag must be given separately" );
        -:  562:
        3:  563:					skelname = arg + i + 1;
        3:  564:					goto get_next_arg;
        -:  565:
        3:  566:				case 's':
        3:  567:					spprdflt = true;
        3:  568:					break;
        -:  569:
        3:  570:				case 't':
        3:  571:					use_stdout = true;
        3:  572:					break;
        -:  573:
       24:  574:				case 'T':
       24:  575:					trace = true;
       24:  576:					break;
        -:  577:
        9:  578:				case 'v':
        9:  579:					printstats = true;
        9:  580:					break;
        -:  581:
        1:  582:				case 'V':
        1:  583:					fprintf( err, "%s version %s\n",
call    0 returned 1
        -:  584:						program_name, flex_version );
        1:  585:					exit( 0 );
call    0 returned 0
        -:  586:
        3:  587:				case 'w':
        3:  588:					nowarn = true;
        3:  589:					break;
        -:  590:
        3:  591:				case '7':
        3:  592:					csize = 128;
        3:  593:					csize_given = true;
        3:  594:					break;
        -:  595:
        2:  596:				case '8':
        2:  597:					csize = CSIZE;
        2:  598:					csize_given = true;
        2:  599:					break;
        -:  600:
        1:  601:				default:
        1:  602:					fprintf( err,
        -:  603:						"%s: unknown flag '%c'\n",
        1:  604:						program_name, (int) arg[i] );
call    0 returned 1
        1:  605:					usage();
call    0 returned 1
        1:  606:					exit( 1 );
call    0 returned 0
        -:  607:				}
        -:  608:
        -:  609:		/* Used by -C, -S and -P flags in lieu of a "continue 2"
        -:  610:		 * control.
        -:  611:		 */
      949:  612:		get_next_arg: ;
        -:  613:		}
        -:  614:
      560:  615:	if ( ! csize_given )
branch  0 taken 555 (fallthrough)
branch  1 taken 5
        -:  616:		{
      555:  617:		if ( (fulltbl || fullspd) && ! useecs )
branch  0 taken 526 (fallthrough)
branch  1 taken 29
branch  2 taken 94 (fallthrough)
branch  3 taken 432
branch  4 taken 80 (fallthrough)
branch  5 taken 43
       80:  618:			csize = DEFAULT_CSIZE;
        -:  619:		else
      475:  620:			csize = CSIZE;
        -:  621:		}
        -:  622:
      560:  623:	if ( ! interactive_given )
branch  0 taken 555 (fallthrough)
branch  1 taken 5
        -:  624:		{
      555:  625:		if ( fulltbl || fullspd )
branch  0 taken 527 (fallthrough)
branch  1 taken 28
branch  2 taken 94 (fallthrough)
branch  3 taken 433
      122:  626:			interactive = false;
        -:  627:		else
      433:  628:			interactive = true;
        -:  629:		}
        -:  630:
      560:  631:	if ( lex_compat )
branch  0 taken 163 (fallthrough)
branch  1 taken 397
        -:  632:		{
      163:  633:		if ( C_plus_plus )
branch  0 taken 0 (fallthrough)
branch  1 taken 163
    #####:  634:			flexerror( "Can't use -+ with -l option" );
call    0 never executed
        -:  635:
      163:  636:		if ( fulltbl || fullspd )
branch  0 taken 162 (fallthrough)
branch  1 taken 1
branch  2 taken 0 (fallthrough)
branch  3 taken 162
        1:  637:			flexerror( "Can't use -f or -F with -l option" );
call    0 returned 0
        -:  638:
        -:  639:		/* Don't rely on detecting use of yymore() and REJECT,
        -:  640:		 * just assume they'll be used.
        -:  641:		 */
      162:  642:		yymore_really_used = reject_really_used = true;
        -:  643:
      162:  644:		yytext_is_array = true;
      162:  645:		use_read = false;
        -:  646:		}
        -:  647:
      559:  648:	if ( (fulltbl || fullspd) && usemecs )
branch  0 taken 531 (fallthrough)
branch  1 taken 28
branch  2 taken 94 (fallthrough)
branch  3 taken 437
branch  4 taken 3 (fallthrough)
branch  5 taken 119
        3:  649:		flexerror( "-Cf/-CF and -Cm don't make sense together" );
call    0 returned 0
        -:  650:
      556:  651:	if ( (fulltbl || fullspd) && interactive )
branch  0 taken 530 (fallthrough)
branch  1 taken 26
branch  2 taken 93 (fallthrough)
branch  3 taken 437
branch  4 taken 1 (fallthrough)
branch  5 taken 118
        1:  652:		flexerror( "-Cf/-CF and -I are incompatible" );
call    0 returned 0
        -:  653:
      555:  654:	if ( fulltbl && fullspd )
branch  0 taken 25 (fallthrough)
branch  1 taken 530
branch  2 taken 1 (fallthrough)
branch  3 taken 24
        1:  655:		flexerror( "-Cf and -CF are mutually exclusive" );
call    0 returned 0
        -:  656:
     554*:  657:	if ( C_plus_plus && fullspd )
branch  0 taken 0 (fallthrough)
branch  1 taken 554
branch  2 never executed
branch  3 never executed
    #####:  658:		flexerror( "Can't use -+ with -CF option" );
call    0 never executed
        -:  659:
      554:  660:	if ( ! use_stdout )
branch  0 taken 551 (fallthrough)
branch  1 taken 3
        -:  661:		{
        -:  662:		FILE *prev_stdout;
        -:  663:		char *suffix;
        -:  664:
      551:  665:		if ( C_plus_plus )
branch  0 taken 0 (fallthrough)
branch  1 taken 551
    #####:  666:			suffix = "cc";
        -:  667:		else
      551:  668:			suffix = "c";
        -:  669:
      551:  670:		sprintf( outfile_path, outfile_template, prefix, suffix );
        -:  671:
      551:  672:		prev_stdout = freopen( outfile_path, "w", stdout );
call    0 returned 551
        -:  673:
      551:  674:		if ( prev_stdout == NULL )
branch  0 taken 0 (fallthrough)
branch  1 taken 551
    #####:  675:			lerrsf( "could not create %s", outfile_path );
call    0 never executed
        -:  676:
      551:  677:		outfile_created = 1;
        -:  678:		}
        -:  679:
      554:  680:	num_input_files = argc;
      554:  681:	input_files = argv;
     554*:  682:	set_input_file( num_input_files > 0 ? input_files[0] : NULL );
branch  0 taken 554 (fallthrough)
branch  1 taken 0
call    2 returned 553
        -:  683:
      553:  684:	if ( backing_up_report )
branch  0 taken 5 (fallthrough)
branch  1 taken 548
        -:  685:		{
        -:  686:#ifndef SHORT_FILE_NAMES
        5:  687:		backing_up_file = fopen( "lex.backup", "w" );
call    0 returned 5
        -:  688:#else
        -:  689:		backing_up_file = fopen( "lex.bck", "w" );
        -:  690:#endif
        -:  691:
        5:  692:		if ( backing_up_file == NULL )
branch  0 taken 0 (fallthrough)
branch  1 taken 5
    #####:  693:			flexerror( "could not create lex.backup" );
call    0 never executed
        -:  694:		}
        -:  695:
        -:  696:	else
      548:  697:		backing_up_file = NULL;
        -:  698:
        -:  699:
      553:  700:	lastccl = 0;
      553:  701:	lastsc = 0;
        -:  702:
      553:  703:	if ( skelname && (skelfile = fopen( skelname, "r" )) == NULL )
branch  0 taken 3 (fallthrough)
branch  1 taken 550
call    2 returned 3
branch  3 taken 1 (fallthrough)
branch  4 taken 2
        1:  704:		lerrsf( "can't open skeleton file %s", skelname );
call    0 returned 0
        -:  705:#ifndef F_JR_1
      552:  706:	if ( strcmp( prefix, "yy" ) )
branch  0 taken 1 (fallthrough)
branch  1 taken 551
        -:  707:#else
        -:  708:    if ( yy_strcmp( prefix, "yy" ) )
        -:  709:#endif
        -:  710:		{
        -:  711:#define GEN_PREFIX(name) printf( "#define yy%s %s%s\n", name, prefix, name );
        1:  712:		GEN_PREFIX( "FlexLexer" );
call    0 returned 1
        1:  713:		GEN_PREFIX( "_create_buffer" );
call    0 returned 1
        1:  714:		GEN_PREFIX( "_delete_buffer" );
call    0 returned 1
        1:  715:		GEN_PREFIX( "_flex_debug" );
call    0 returned 1
        1:  716:		GEN_PREFIX( "_init_buffer" );
call    0 returned 1
        1:  717:		GEN_PREFIX( "_load_buffer_state" );
call    0 returned 1
        1:  718:		GEN_PREFIX( "_switch_to_buffer" );
call    0 returned 1
        1:  719:		GEN_PREFIX( "in" );
call    0 returned 1
        1:  720:		GEN_PREFIX( "leng" );
call    0 returned 1
        1:  721:		GEN_PREFIX( "lex" );
call    0 returned 1
        1:  722:		GEN_PREFIX( "out" );
call    0 returned 1
        1:  723:		GEN_PREFIX( "restart" );
call    0 returned 1
        1:  724:		GEN_PREFIX( "text" );
call    0 returned 1
        1:  725:		GEN_PREFIX( "wrap" );
call    0 returned 1
        1:  726:		printf( "\n" );
call    0 returned 1
        -:  727:		}
        -:  728:
        -:  729:
      552:  730:	lastdfa = lastnfa = 0;
      552:  731:	num_rules = num_eof_rules = default_rule = 0;
      552:  732:	numas = numsnpairs = tmpuses = 0;
      552:  733:	numecs = numeps = eps2 = num_reallocs = hshcol = dfaeql = totnst = 0;
      552:  734:	numuniq = numdup = hshsave = eofseen = datapos = dataline = 0;
      552:  735:	num_backing_up = onesp = numprots = 0;
      552:  736:	variable_trailing_context_rules = bol_needed = false;
        -:  737:
      552:  738:	linenum = sectnum = 1;
      552:  739:	firstprot = NIL;
        -:  740:
        -:  741:	/* Used in mkprot() so that the first proto goes in slot 1
        -:  742:	 * of the proto queue.
        -:  743:	 */
      552:  744:	lastprot = 1;
        -:  745:
      552:  746:	if ( useecs )
branch  0 taken 302 (fallthrough)
branch  1 taken 250
        -:  747:		{
        -:  748:		/* Set up doubly-linked equivalence classes. */
        -:  749:
        -:  750:		/* We loop all the way up to csize, since ecgroup[csize] is
        -:  751:		 * the position used for NUL characters.
        -:  752:		 */
      302:  753:		ecgroup[1] = NIL;
        -:  754:
    76928:  755:		for ( i = 2; i <= csize; ++i )
branch  0 taken 76626
branch  1 taken 302 (fallthrough)
        -:  756:			{
    76626:  757:			ecgroup[i] = i - 1;
    76626:  758:			nextecm[i - 1] = i;
        -:  759:			}
        -:  760:
      302:  761:		nextecm[csize] = NIL;
        -:  762:		}
        -:  763:
        -:  764:	else
        -:  765:		{
        -:  766:		/* Put everything in its own equivalence class. */
    54522:  767:		for ( i = 1; i <= csize; ++i )
branch  0 taken 54272
branch  1 taken 250 (fallthrough)
        -:  768:			{
    54272:  769:			ecgroup[i] = i;
    54272:  770:			nextecm[i] = BAD_SUBSCRIPT;	/* to catch errors */
        -:  771:			}
        -:  772:		}
        -:  773:
      552:  774:	set_up_initial_allocations();
call    0 returned 552
      552:  775:	}
        -:  776:
        -:  777:
        -:  778:/* readin - read in the rules section of the input file(s) */
        -:  779:
function readin called 552 returned 98% blocks executed 86%
      552:  780:void readin()
        -:  781:	{
      552:  782:	skelout();
call    0 returned 552
        -:  783:
      552:  784:	line_directive_out( (FILE *) 0 );
call    0 returned 552
        -:  785:
      552:  786:	if ( yyparse() )
call    0 returned 551
branch  1 taken 0 (fallthrough)
branch  2 taken 551
        -:  787:		{
    #####:  788:		pinpoint_message( "fatal parse error" );
call    0 never executed
    #####:  789:		flexend( 1 );
call    0 never executed
        -:  790:		}
        -:  791:
      551:  792:	if ( syntaxerror )
branch  0 taken 6 (fallthrough)
branch  1 taken 545
        6:  793:		flexend( 1 );
call    0 returned 0
        -:  794:
        -:  795:#ifndef F_AA_3
      545:  796:	if ( yymore_really_used == REALLY_USED )
branch  0 taken 162 (fallthrough)
branch  1 taken 383
        -:  797:#else
        -:  798:	if ( yymore_really_used = REALLY_NOT_USED )
        -:  799:#endif
        -:  800:
      162:  801:		yymore_used = true;
      383:  802:	else if ( yymore_really_used == REALLY_NOT_USED )
branch  0 taken 0 (fallthrough)
branch  1 taken 383
    #####:  803:		yymore_used = false;
        -:  804:
      545:  805:	if ( reject_really_used == REALLY_USED )
branch  0 taken 162 (fallthrough)
branch  1 taken 383
      162:  806:		reject = true;
      383:  807:	else if ( reject_really_used == REALLY_NOT_USED )
branch  0 taken 0 (fallthrough)
branch  1 taken 383
    #####:  808:		reject = false;
        -:  809:
        -:  810:#ifndef	F_HD_1
      545:  811:	if ( performance_report > 0 )
branch  0 taken 12 (fallthrough)
branch  1 taken 533
        -:  812:#else
        -:  813:	if ( performance_report >= 0 )
        -:  814:#endif
        -:  815:		{
       12:  816:		if ( lex_compat )
branch  0 taken 2 (fallthrough)
branch  1 taken 10
        -:  817:			{
        2:  818:			fprintf( err,
call    0 returned 2
        -:  819:"-l AT&T lex compatibility option entails a large performance penalty\n" );
        2:  820:			fprintf( err,
call    0 returned 2
        -:  821:" and may be the actual source of other reported performance penalties\n" );
        -:  822:			}
        -:  823:
       12:  824:		if ( performance_report > 1 )
branch  0 taken 1 (fallthrough)
branch  1 taken 11
        -:  825:			{
        1:  826:			if ( interactive )
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:  827:				fprintf( err,
call    0 returned 1
        -:  828:		"-I (interactive) entails a minor performance penalty\n" );
        -:  829:
        1:  830:			if ( yymore_used )
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:  831:				fprintf( err,
call    0 never executed
        -:  832:			"yymore() entails a minor performance penalty\n" );
        -:  833:			}
        -:  834:
       12:  835:		if ( reject )
branch  0 taken 5 (fallthrough)
branch  1 taken 7
        5:  836:			fprintf( err,
call    0 returned 5
        -:  837:			"REJECT entails a large performance penalty\n" );
        -:  838:
       12:  839:		if ( variable_trailing_context_rules )
branch  0 taken 1 (fallthrough)
branch  1 taken 11
        1:  840:			fprintf( err,
call    0 returned 1
        -:  841:"Variable trailing context rules entail a large performance penalty\n" );
        -:  842:		}
        -:  843:
      545:  844:	if ( reject )
branch  0 taken 169 (fallthrough)
branch  1 taken 376
      169:  845:		real_reject = true;
        -:  846:
      545:  847:	if ( variable_trailing_context_rules )
branch  0 taken 33 (fallthrough)
branch  1 taken 512
       33:  848:		reject = true;
        -:  849:
        -:  850:#ifndef F_AA_6
      545:  851:	if ( (fulltbl || fullspd) && reject )
branch  0 taken 521 (fallthrough)
branch  1 taken 24
branch  2 taken 93 (fallthrough)
branch  3 taken 428
branch  4 taken 2 (fallthrough)
branch  5 taken 115
        -:  852:#else
        -:  853:	if ( fulltbl || (fullspd && reject) )
        -:  854:#endif
        -:  855:		{
        2:  856:		if ( real_reject )
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2:  857:			flexerror( "REJECT cannot be used with -f or -F" );
call    0 returned 0
        -:  858:		else
    #####:  859:			flexerror(
call    0 never executed
        -:  860:	"variable trailing context rules cannot be used with -f or -F" );
        -:  861:		}
        -:  862:
      543:  863:	if ( csize == 256 )
branch  0 taken 467 (fallthrough)
branch  1 taken 76
      467:  864:		puts( "typedef unsigned char YY_CHAR;" );
call    0 returned 467
        -:  865:	else
       76:  866:		puts( "typedef char YY_CHAR;" );
call    0 returned 76
        -:  867:
      543:  868:	if ( C_plus_plus )
branch  0 taken 0 (fallthrough)
branch  1 taken 543
        -:  869:		{
    #####:  870:		puts( "#define yytext_ptr yytext" );
call    0 never executed
        -:  871:
    #####:  872:		if ( interactive )
branch  0 never executed
branch  1 never executed
    #####:  873:			puts( "#define YY_INTERACTIVE" );
call    0 never executed
        -:  874:		}
        -:  875:
      543:  876:	if ( fullspd )
branch  0 taken 92 (fallthrough)
branch  1 taken 451
       92:  877:		printf(
call    0 returned 92
        -:  878:		"typedef const struct yy_trans_info *yy_state_type;\n" );
      451:  879:	else if ( ! C_plus_plus )
branch  0 taken 451 (fallthrough)
branch  1 taken 0
      451:  880:		printf( "typedef int yy_state_type;\n" );
call    0 returned 451
        -:  881:
      543:  882:	if ( reject )
branch  0 taken 169 (fallthrough)
branch  1 taken 374
      169:  883:		printf( "\n#define YY_USES_REJECT\n" );
call    0 returned 169
        -:  884:
      543:  885:	if ( ddebug )
branch  0 taken 252 (fallthrough)
branch  1 taken 291
      252:  886:		puts( "\n#define FLEX_DEBUG" );
call    0 returned 252
        -:  887:
      543:  888:	if ( lex_compat )
branch  0 taken 162 (fallthrough)
branch  1 taken 381
        -:  889:		{
      162:  890:		printf( "FILE *yyin = stdin, *yyout = stdout;\n" );
call    0 returned 162
      162:  891:		printf( "extern int yylineno;\n" );
call    0 returned 162
      162:  892:		printf( "int yylineno = 1;\n" );
call    0 returned 162
        -:  893:		}
      381:  894:	else if ( ! C_plus_plus )
branch  0 taken 381 (fallthrough)
branch  1 taken 0
      381:  895:		printf( "FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;\n" );
call    0 returned 381
        -:  896:
      543:  897:	if ( C_plus_plus )
branch  0 taken 0 (fallthrough)
branch  1 taken 543
    #####:  898:		printf( "\n#include <FlexLexer.h>\n" );
call    0 never executed
        -:  899:
        -:  900:	else
        -:  901:		{
      543:  902:		if ( yytext_is_array )
branch  0 taken 162 (fallthrough)
branch  1 taken 381
      162:  903:			puts( "extern char yytext[];\n" );
call    0 returned 162
        -:  904:
        -:  905:		else
        -:  906:			{
      381:  907:			puts( "extern char *yytext;" );
call    0 returned 381
      381:  908:			puts( "#define yytext_ptr yytext" );
call    0 returned 381
        -:  909:			}
        -:  910:		}
        -:  911:
      543:  912:	if ( useecs )
branch  0 taken 295 (fallthrough)
branch  1 taken 248
      295:  913:		numecs = cre8ecs( nextecm, ecgroup, csize );
call    0 returned 295
        -:  914:	else
      248:  915:		numecs = csize;
        -:  916:
        -:  917:	/* Now map the equivalence class for NUL to its expected place. */
      543:  918:	ecgroup[0] = ecgroup[csize];
      543:  919:	NUL_ec = ABS( ecgroup[0] );
        -:  920:
      543:  921:	if ( useecs )
branch  0 taken 295 (fallthrough)
branch  1 taken 248
      295:  922:		ccl2ecl();
call    0 returned 295
      543:  923:	}
        -:  924:
        -:  925:
        -:  926:/* set_up_initial_allocations - allocate memory for internal tables */
        -:  927:
function set_up_initial_allocations called 552 returned 100% blocks executed 100%
      552:  928:void set_up_initial_allocations()
        -:  929:	{
      552:  930:	current_mns = INITIAL_MNS;
      552:  931:	firstst = allocate_integer_array( current_mns );
call    0 returned 552
      552:  932:	lastst = allocate_integer_array( current_mns );
call    0 returned 552
      552:  933:	finalst = allocate_integer_array( current_mns );
call    0 returned 552
      552:  934:	transchar = allocate_integer_array( current_mns );
call    0 returned 552
      552:  935:	trans1 = allocate_integer_array( current_mns );
call    0 returned 552
      552:  936:	trans2 = allocate_integer_array( current_mns );
call    0 returned 552
      552:  937:	accptnum = allocate_integer_array( current_mns );
call    0 returned 552
      552:  938:	assoc_rule = allocate_integer_array( current_mns );
call    0 returned 552
      552:  939:	state_type = allocate_integer_array( current_mns );
call    0 returned 552
        -:  940:
      552:  941:	current_max_rules = INITIAL_MAX_RULES;
      552:  942:	rule_type = allocate_integer_array( current_max_rules );
call    0 returned 552
      552:  943:	rule_linenum = allocate_integer_array( current_max_rules );
call    0 returned 552
      552:  944:	rule_useful = allocate_integer_array( current_max_rules );
call    0 returned 552
        -:  945:
      552:  946:	current_max_scs = INITIAL_MAX_SCS;
      552:  947:	scset = allocate_integer_array( current_max_scs );
call    0 returned 552
      552:  948:	scbol = allocate_integer_array( current_max_scs );
call    0 returned 552
      552:  949:	scxclu = allocate_integer_array( current_max_scs );
call    0 returned 552
      552:  950:	sceof = allocate_integer_array( current_max_scs );
call    0 returned 552
      552:  951:	scname = allocate_char_ptr_array( current_max_scs );
call    0 returned 552
      552:  952:	actvsc = allocate_integer_array( current_max_scs );
call    0 returned 552
        -:  953:
      552:  954:	current_maxccls = INITIAL_MAX_CCLS;
      552:  955:	cclmap = allocate_integer_array( current_maxccls );
call    0 returned 552
      552:  956:	ccllen = allocate_integer_array( current_maxccls );
call    0 returned 552
      552:  957:	cclng = allocate_integer_array( current_maxccls );
call    0 returned 552
        -:  958:
      552:  959:	current_max_ccl_tbl_size = INITIAL_MAX_CCL_TBL_SIZE;
      552:  960:	ccltbl = allocate_Character_array( current_max_ccl_tbl_size );
call    0 returned 552
        -:  961:
      552:  962:	current_max_dfa_size = INITIAL_MAX_DFA_SIZE;
        -:  963:
      552:  964:	current_max_xpairs = INITIAL_MAX_XPAIRS;
      552:  965:	nxt = allocate_integer_array( current_max_xpairs );
call    0 returned 552
      552:  966:	chk = allocate_integer_array( current_max_xpairs );
call    0 returned 552
        -:  967:
      552:  968:	current_max_template_xpairs = INITIAL_MAX_TEMPLATE_XPAIRS;
      552:  969:	tnxt = allocate_integer_array( current_max_template_xpairs );
call    0 returned 552
        -:  970:
      552:  971:	current_max_dfas = INITIAL_MAX_DFAS;
      552:  972:	base = allocate_integer_array( current_max_dfas );
call    0 returned 552
      552:  973:	def = allocate_integer_array( current_max_dfas );
call    0 returned 552
      552:  974:	dfasiz = allocate_integer_array( current_max_dfas );
call    0 returned 552
      552:  975:	accsiz = allocate_integer_array( current_max_dfas );
call    0 returned 552
      552:  976:	dhash = allocate_integer_array( current_max_dfas );
call    0 returned 552
      552:  977:	dss = allocate_int_ptr_array( current_max_dfas );
call    0 returned 552
      552:  978:	dfaacc = allocate_dfaacc_union( current_max_dfas );
call    0 returned 552
        -:  979:
      552:  980:	nultrans = (int *) 0;
      552:  981:	}
        -:  982:
        -:  983:
function usage called 2 returned 100% blocks executed 100%
        2:  984:void usage()
        -:  985:	{
        2:  986:	fprintf( err,
call    0 returned 2
        -:  987:"%s [-bcdfhilnpstvwBFILTV78+ -C[aefFmr] -Pprefix -Sskeleton] [file ...]\n",
        -:  988:		program_name );
        -:  989:
        2:  990:	fprintf( err,
call    0 returned 2
        -:  991:		"\t-b  generate backing-up information to lex.backup\n" );
        2:  992:	fprintf( err, "\t-c  do-nothing POSIX option\n" );
call    0 returned 2
        2:  993:	fprintf( err, "\t-d  turn on debug mode in generated scanner\n" );
call    0 returned 2
        2:  994:	fprintf( err, "\t-f  generate fast, large scanner\n" );
call    0 returned 2
        2:  995:	fprintf( err, "\t-h  produce this help message\n" );
call    0 returned 2
        2:  996:	fprintf( err, "\t-i  generate case-insensitive scanner\n" );
call    0 returned 2
        2:  997:	fprintf( err, "\t-l  maximal compatibility with original lex\n" );
call    0 returned 2
        2:  998:	fprintf( err, "\t-n  do-nothing POSIX option\n" );
call    0 returned 2
        2:  999:	fprintf( err, "\t-p  generate performance report to stderr\n" );
call    0 returned 2
        2: 1000:	fprintf( err,
call    0 returned 2
        -: 1001:		"\t-s  suppress default rule to ECHO unmatched text\n" );
        2: 1002:	fprintf( err,
call    0 returned 2
        -: 1003:	"\t-t  write generated scanner on stdout instead of lex.yy.c\n" );
        2: 1004:	fprintf( err,
call    0 returned 2
        -: 1005:		"\t-v  write summary of scanner statistics to stderr\n" );
        2: 1006:	fprintf( err, "\t-w  do not generate warnings\n" );
call    0 returned 2
        2: 1007:	fprintf( err, "\t-B  generate batch scanner (opposite of -I)\n" );
call    0 returned 2
        2: 1008:	fprintf( err,
call    0 returned 2
        -: 1009:		"\t-F  use alternative fast scanner representation\n" );
        2: 1010:	fprintf( err,
call    0 returned 2
        -: 1011:		"\t-I  generate interactive scanner (opposite of -B)\n" );
        2: 1012:	fprintf( err, "\t-L  suppress #line directives in scanner\n" );
call    0 returned 2
        2: 1013:	fprintf( err, "\t-T  %s should run in trace mode\n", program_name );
call    0 returned 2
        2: 1014:	fprintf( err, "\t-V  report %s version\n", program_name );
call    0 returned 2
        2: 1015:	fprintf( err, "\t-7  generate 7-bit scanner\n" );
call    0 returned 2
        2: 1016:	fprintf( err, "\t-8  generate 8-bit scanner\n" );
call    0 returned 2
        2: 1017:	fprintf( err, "\t-+  generate C++ scanner class\n" );
call    0 returned 2
        2: 1018:	fprintf( err,
call    0 returned 2
        -: 1019:	"\t-C  specify degree of table compression (default is -Cem):\n" );
        2: 1020:	fprintf( err,
call    0 returned 2
        -: 1021:	"\t\t-Ca  trade off larger tables for better memory alignment\n" );
        2: 1022:	fprintf( err, "\t\t-Ce  construct equivalence classes\n" );
call    0 returned 2
        2: 1023:	fprintf( err,
call    0 returned 2
        -: 1024:	"\t\t-Cf  do not compress scanner tables; use -f representation\n" );
        2: 1025:	fprintf( err,
call    0 returned 2
        -: 1026:	"\t\t-CF  do not compress scanner tables; use -F representation\n" );
        2: 1027:	fprintf( err, "\t\t-Cm  construct meta-equivalence classes\n" );
call    0 returned 2
        2: 1028:	fprintf( err,
call    0 returned 2
        -: 1029:		"\t\t-Cr  use read() instead of stdio for scanner input\n" );
        2: 1030:	fprintf( err, "\t-P  specify scanner prefix other than \"yy\"\n" );
call    0 returned 2
        2: 1031:	fprintf( err, "\t-S  specify skeleton file\n" );
call    0 returned 2
        2: 1032:	}
        -: 1033:/* ccl - routines for character classes */
        -: 1034:
        -: 1035:/*-
        -: 1036: * Copyright (c) 1990 The Regents of the University of California.
        -: 1037: * All rights reserved.
        -: 1038: *
        -: 1039: * This code is derived from software contributed to Berkeley by
        -: 1040: * Vern Paxson.
        -: 1041: * 
        -: 1042: * The United States Government has rights in this work pursuant
        -: 1043: * to contract no. DE-AC03-76SF00098 between the United States
        -: 1044: * Department of Energy and the University of California.
        -: 1045: *
        -: 1046: * Redistribution and use in source and binary forms are permitted provided
        -: 1047: * that: (1) source distributions retain this entire copyright notice and
        -: 1048: * comment, and (2) distributions including binaries display the following
        -: 1049: * acknowledgement:  ``This product includes software developed by the
        -: 1050: * University of California, Berkeley and its contributors'' in the
        -: 1051: * documentation or other materials provided with the distribution and in
        -: 1052: * all advertising materials mentioning features or use of this software.
        -: 1053: * Neither the name of the University nor the names of its contributors may
        -: 1054: * be used to endorse or promote products derived from this software without
        -: 1055: * specific prior written permission.
        -: 1056: * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
        -: 1057: * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
        -: 1058: * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
        -: 1059: */
        -: 1060:
        -: 1061:/* $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.seeded/v1/flex.c,v 1.1.1.2 2003/09/02 20:21:59 expsir Exp $ */
        -: 1062:
        -: 1063:
        -: 1064:/* ccladd - add a single character to a ccl */
        -: 1065:
function ccladd called 25144 returned 100% blocks executed 100%
    25144: 1066:void ccladd( cclp, ch )
        -: 1067:int cclp;
        -: 1068:int ch;
        -: 1069:	{
        -: 1070:	int ind, len, newpos, i;
        -: 1071:
    25144: 1072:	check_char( ch );
call    0 returned 25144
        -: 1073:
    25144: 1074:	len = ccllen[cclp];
    25144: 1075:	ind = cclmap[cclp];
        -: 1076:
        -: 1077:	/* check to see if the character is already in the ccl */
        -: 1078:
   485548: 1079:	for ( i = 0; i < len; ++i )
branch  0 taken 460615
branch  1 taken 24933 (fallthrough)
   460615: 1080:		if ( ccltbl[ind + i] == ch )
branch  0 taken 211 (fallthrough)
branch  1 taken 460404
      211: 1081:			return;
        -: 1082:
    24933: 1083:	newpos = ind + len;
        -: 1084:
    24933: 1085:	if ( newpos >= current_max_ccl_tbl_size )
branch  0 taken 40 (fallthrough)
branch  1 taken 24893
        -: 1086:		{
       40: 1087:		current_max_ccl_tbl_size += MAX_CCL_TBL_SIZE_INCREMENT;
        -: 1088:
       40: 1089:		++num_reallocs;
        -: 1090:
       40: 1091:		ccltbl = reallocate_Character_array( ccltbl,
call    0 returned 40
        -: 1092:						current_max_ccl_tbl_size );
        -: 1093:		}
        -: 1094:
    24933: 1095:	ccllen[cclp] = len + 1;
    24933: 1096:	ccltbl[newpos] = ch;
        -: 1097:	}
        -: 1098:
        -: 1099:
        -: 1100:/* cclinit - return an empty ccl */
        -: 1101:
function cclinit called 2054 returned 100% blocks executed 100%
     2054: 1102:int cclinit()
        -: 1103:	{
     2054: 1104:	if ( ++lastccl >= current_maxccls )
branch  0 taken 2 (fallthrough)
branch  1 taken 2052
        -: 1105:		{
        2: 1106:		current_maxccls += MAX_CCLS_INCREMENT;
        -: 1107:
        2: 1108:		++num_reallocs;
        -: 1109:
        2: 1110:		cclmap = reallocate_integer_array( cclmap, current_maxccls );
call    0 returned 2
        2: 1111:		ccllen = reallocate_integer_array( ccllen, current_maxccls );
call    0 returned 2
        2: 1112:		cclng = reallocate_integer_array( cclng, current_maxccls );
call    0 returned 2
        -: 1113:		}
        -: 1114:
     2054: 1115:	if ( lastccl == 1 )
branch  0 taken 551 (fallthrough)
branch  1 taken 1503
        -: 1116:		/* we're making the first ccl */
      551: 1117:		cclmap[lastccl] = 0;
        -: 1118:
        -: 1119:	else
        -: 1120:		/* The new pointer is just past the end of the last ccl.
        -: 1121:		 * Since the cclmap points to the \first/ character of a
        -: 1122:		 * ccl, adding the length of the ccl to the cclmap pointer
        -: 1123:		 * will produce a cursor to the first free space.
        -: 1124:		 */
     1503: 1125:		cclmap[lastccl] = cclmap[lastccl - 1] + ccllen[lastccl - 1];
        -: 1126:
     2054: 1127:	ccllen[lastccl] = 0;
     2054: 1128:	cclng[lastccl] = 0;	/* ccl's start out life un-negated */
        -: 1129:
     2054: 1130:	return lastccl;
        -: 1131:	}
        -: 1132:
        -: 1133:
        -: 1134:/* cclnegate - negate the given ccl */
        -: 1135:
function cclnegate called 979 returned 100% blocks executed 100%
      979: 1136:void cclnegate( cclp )
        -: 1137:int cclp;
        -: 1138:	{
      979: 1139:	cclng[cclp] = 1;
      979: 1140:	}
        -: 1141:
        -: 1142:
        -: 1143:/* list_character_set - list the members of a set of characters in CCL form
        -: 1144: *
        -: 1145: * Writes to the given file a character-class representation of those
        -: 1146: * characters present in the given CCL.  A character is present if it
        -: 1147: * has a non-zero value in the cset array.
        -: 1148: */
        -: 1149:
function list_character_set called 8 returned 100% blocks executed 100%
        8: 1150:void list_character_set( file, cset )
        -: 1151:FILE *file;
        -: 1152:int cset[];
        -: 1153:	{
        -: 1154:	register int i;
        -: 1155:
        8: 1156:	putc( '[', file );
call    0 returned 8
        -: 1157:
      908: 1158:	for ( i = 0; i < csize; ++i )
branch  0 taken 900
branch  1 taken 8 (fallthrough)
        -: 1159:		{
      900: 1160:		if ( cset[i] )
branch  0 taken 12 (fallthrough)
branch  1 taken 888
        -: 1161:			{
       12: 1162:			register int start_char = i;
        -: 1163:
       12: 1164:			putc( ' ', file );
call    0 returned 12
        -: 1165:
       12: 1166:			fputs( readable_form( i ), file );
call    0 returned 12
call    1 returned 12
        -: 1167:
      896: 1168:			while ( ++i < csize && cset[i] )
branch  0 taken 892 (fallthrough)
branch  1 taken 4
branch  2 taken 884
branch  3 taken 8 (fallthrough)
        -: 1169:				;
        -: 1170:
       12: 1171:			if ( i - 1 > start_char )
branch  0 taken 8 (fallthrough)
branch  1 taken 4
        -: 1172:				/* this was a run */
        8: 1173:				fprintf( file, "-%s", readable_form( i - 1 ) );
call    0 returned 8
call    1 returned 8
        -: 1174:
       12: 1175:			putc( ' ', file );
call    0 returned 12
        -: 1176:			}
        -: 1177:		}
        -: 1178:
        8: 1179:	putc( ']', file );
call    0 returned 8
        8: 1180:	}
        -: 1181:/* dfa - DFA construction routines */
        -: 1182:
        -: 1183:/*-
        -: 1184: * Copyright (c) 1990 The Regents of the University of California.
        -: 1185: * All rights reserved.
        -: 1186: *
        -: 1187: * This code is derived from software contributed to Berkeley by
        -: 1188: * Vern Paxson.
        -: 1189: * 
        -: 1190: * The United States Government has rights in this work pursuant
        -: 1191: * to contract no. DE-AC03-76SF00098 between the United States
        -: 1192: * Department of Energy and the University of California.
        -: 1193: *
        -: 1194: * Redistribution and use in source and binary forms are permitted provided
        -: 1195: * that: (1) source distributions retain this entire copyright notice and
        -: 1196: * comment, and (2) distributions including binaries display the following
        -: 1197: * acknowledgement:  ``This product includes software developed by the
        -: 1198: * University of California, Berkeley and its contributors'' in the
        -: 1199: * documentation or other materials provided with the distribution and in
        -: 1200: * all advertising materials mentioning features or use of this software.
        -: 1201: * Neither the name of the University nor the names of its contributors may
        -: 1202: * be used to endorse or promote products derived from this software without
        -: 1203: * specific prior written permission.
        -: 1204: * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
        -: 1205: * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
        -: 1206: * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
        -: 1207: */
        -: 1208:
        -: 1209:/* $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.seeded/v1/flex.c,v 1.1.1.2 2003/09/02 20:21:59 expsir Exp $ */
        -: 1210:
        -: 1211:
        -: 1212:
        -: 1213:/* declare functions that have forward references */
        -: 1214:
        -: 1215:void dump_associated_rules PROTO((FILE*, int));
        -: 1216:void dump_transitions PROTO((FILE*, int[]));
        -: 1217:void sympartition PROTO((int[], int, int[], int[]));
        -: 1218:int symfollowset PROTO((int[], int, int, int[]));
        -: 1219:
        -: 1220:
        -: 1221:/* check_for_backing_up - check a DFA state for backing up
        -: 1222: *
        -: 1223: * synopsis
        -: 1224: *     void check_for_backing_up( int ds, int state[numecs] );
        -: 1225: *
        -: 1226: * ds is the number of the state to check and state[] is its out-transitions,
        -: 1227: * indexed by equivalence class.
        -: 1228: */
        -: 1229:
function check_for_backing_up called 12369 returned 100% blocks executed 100%
    12369: 1230:void check_for_backing_up( ds, state )
        -: 1231:int ds;
        -: 1232:int state[];
        -: 1233:	{
    12369: 1234:	if ( (reject && ! dfaacc[ds].dfaacc_set) ||
branch  0 taken 4669 (fallthrough)
branch  1 taken 7700
branch  2 taken 3911 (fallthrough)
branch  3 taken 758
    11611: 1235:	     (! reject && ! dfaacc[ds].dfaacc_state) )
branch  0 taken 7700 (fallthrough)
branch  1 taken 3911
branch  2 taken 1721 (fallthrough)
branch  3 taken 5979
        -: 1236:		{ /* state is non-accepting */
     2479: 1237:		++num_backing_up;
        -: 1238:
     2479: 1239:		if ( backing_up_report )
branch  0 taken 4 (fallthrough)
branch  1 taken 2475
        -: 1240:			{
        4: 1241:			fprintf( backing_up_file,
call    0 returned 4
        -: 1242:				"State #%d is non-accepting -\n", ds );
        -: 1243:
        -: 1244:			/* identify the state */
        4: 1245:			dump_associated_rules( backing_up_file, ds );
call    0 returned 4
        -: 1246:
        -: 1247:			/* Now identify it further using the out- and
        -: 1248:			 * jam-transitions.
        -: 1249:			 */
        4: 1250:			dump_transitions( backing_up_file, state );
call    0 returned 4
        -: 1251:
        4: 1252:			putc( '\n', backing_up_file );
call    0 returned 4
        -: 1253:			}
        -: 1254:		}
    12369: 1255:	}
        -: 1256:
        -: 1257:
        -: 1258:/* check_trailing_context - check to see if NFA state set constitutes
        -: 1259: *                          "dangerous" trailing context
        -: 1260: *
        -: 1261: * synopsis
        -: 1262: *    void check_trailing_context( int nfa_states[num_states+1], int num_states,
        -: 1263: *				int accset[nacc+1], int nacc );
        -: 1264: *
        -: 1265: * NOTES
        -: 1266: *  Trailing context is "dangerous" if both the head and the trailing
        -: 1267: *  part are of variable size \and/ there's a DFA state which contains
        -: 1268: *  both an accepting state for the head part of the rule and NFA states
        -: 1269: *  which occur after the beginning of the trailing context.
        -: 1270: *
        -: 1271: *  When such a rule is matched, it's impossible to tell if having been
        -: 1272: *  in the DFA state indicates the beginning of the trailing context or
        -: 1273: *  further-along scanning of the pattern.  In these cases, a warning
        -: 1274: *  message is issued.
        -: 1275: *
        -: 1276: *    nfa_states[1 .. num_states] is the list of NFA states in the DFA.
        -: 1277: *    accset[1 .. nacc] is the list of accepting numbers for the DFA state.
        -: 1278: */
        -: 1279:
function check_trailing_context called 446 returned 100% blocks executed 100%
      446: 1280:void check_trailing_context( nfa_states, num_states, accset, nacc )
        -: 1281:int *nfa_states, num_states;
        -: 1282:int *accset;
        -: 1283:register int nacc;
        -: 1284:	{
        -: 1285:	register int i, j;
        -: 1286:
     1191: 1287:	for ( i = 1; i <= num_states; ++i )
branch  0 taken 778
branch  1 taken 413 (fallthrough)
        -: 1288:		{
      778: 1289:		int ns = nfa_states[i];
      778: 1290:		register int type = state_type[ns];
      778: 1291:		register int ar = assoc_rule[ns];
        -: 1292:
      778: 1293:		if ( type == STATE_NORMAL || rule_type[ar] != RULE_VARIABLE )
branch  0 taken 101 (fallthrough)
branch  1 taken 677
branch  2 taken 101 (fallthrough)
branch  3 taken 0
        -: 1294:			{ /* do nothing */
        -: 1295:			}
        -: 1296:
      101: 1297:		else if ( type == STATE_TRAILING_CONTEXT )
branch  0 taken 101 (fallthrough)
branch  1 taken 0
        -: 1298:			{
        -: 1299:			/* Potential trouble.  Scan set of accepting numbers
        -: 1300:			 * for the one marking the end of the "head".  We
        -: 1301:			 * assume that this looping will be fairly cheap
        -: 1302:			 * since it's rare that an accepting number set
        -: 1303:			 * is large.
        -: 1304:			 */
      202: 1305:			for ( j = 1; j <= nacc; ++j )
branch  0 taken 134
branch  1 taken 68 (fallthrough)
      134: 1306:				if ( accset[j] & YY_TRAILING_HEAD_MASK )
branch  0 taken 33 (fallthrough)
branch  1 taken 101
        -: 1307:					{
       33: 1308:					line_warning(
        -: 1309:						"dangerous trailing context",
       33: 1310:						rule_linenum[ar] );
call    0 returned 33
       33: 1311:					return;
        -: 1312:					}
        -: 1313:			}
        -: 1314:		}
        -: 1315:	}
        -: 1316:
        -: 1317:
        -: 1318:/* dump_associated_rules - list the rules associated with a DFA state
        -: 1319: *
        -: 1320: * Goes through the set of NFA states associated with the DFA and
        -: 1321: * extracts the first MAX_ASSOC_RULES unique rules, sorts them,
        -: 1322: * and writes a report to the given file.
        -: 1323: */
        -: 1324:
function dump_associated_rules called 4 returned 100% blocks executed 95%
        4: 1325:void dump_associated_rules( file, ds )
        -: 1326:FILE *file;
        -: 1327:int ds;
        -: 1328:	{
        -: 1329:	register int i, j;
        4: 1330:	register int num_associated_rules = 0;
        -: 1331:	int rule_set[MAX_ASSOC_RULES + 1];
        4: 1332:	int *dset = dss[ds];
        4: 1333:	int size = dfasiz[ds];
        -: 1334:
       16: 1335:	for ( i = 1; i <= size; ++i )
branch  0 taken 12
branch  1 taken 4 (fallthrough)
        -: 1336:		{
       12: 1337:		register int rule_num = rule_linenum[assoc_rule[dset[i]]];
        -: 1338:
      12*: 1339:		for ( j = 1; j <= num_associated_rules; ++j )
branch  0 taken 8
branch  1 taken 4 (fallthrough)
        8: 1340:			if ( rule_num == rule_set[j] )
branch  0 taken 8 (fallthrough)
branch  1 taken 0
        8: 1341:				break;
        -: 1342:
       12: 1343:		if ( j > num_associated_rules )
branch  0 taken 4 (fallthrough)
branch  1 taken 8
        -: 1344:			{ /* new rule */
        4: 1345:			if ( num_associated_rules < MAX_ASSOC_RULES )
branch  0 taken 4 (fallthrough)
branch  1 taken 0
        4: 1346:				rule_set[++num_associated_rules] = rule_num;
        -: 1347:			}
        -: 1348:		}
        -: 1349:
        4: 1350:	bubble( rule_set, num_associated_rules );
call    0 returned 4
        -: 1351:
        4: 1352:	fprintf( file, " associated rule line numbers:" );
call    0 returned 4
        -: 1353:
        8: 1354:	for ( i = 1; i <= num_associated_rules; ++i )
branch  0 taken 4
branch  1 taken 4 (fallthrough)
        -: 1355:		{
        4: 1356:		if ( i % 8 == 1 )
branch  0 taken 4 (fallthrough)
branch  1 taken 0
        4: 1357:			putc( '\n', file );
call    0 returned 4
        -: 1358:
        4: 1359:		fprintf( file, "\t%d", rule_set[i] );
call    0 returned 4
        -: 1360:		}
        -: 1361:
        4: 1362:	putc( '\n', file );
call    0 returned 4
        4: 1363:	}
        -: 1364:
        -: 1365:
        -: 1366:/* dump_transitions - list the transitions associated with a DFA state
        -: 1367: *
        -: 1368: * synopsis
        -: 1369: *     dump_transitions( FILE *file, int state[numecs] );
        -: 1370: *
        -: 1371: * Goes through the set of out-transitions and lists them in human-readable
        -: 1372: * form (i.e., not as equivalence classes); also lists jam transitions
        -: 1373: * (i.e., all those which are not out-transitions, plus EOF).  The dump
        -: 1374: * is done to the given file.
        -: 1375: */
        -: 1376:
function dump_transitions called 4 returned 100% blocks executed 100%
        4: 1377:void dump_transitions( file, state )
        -: 1378:FILE *file;
        -: 1379:int state[];
        -: 1380:	{
        -: 1381:	register int i, ec;
        -: 1382:	int out_char_set[CSIZE];
        -: 1383:
      900: 1384:	for ( i = 0; i < csize; ++i )
branch  0 taken 896
branch  1 taken 4 (fallthrough)
        -: 1385:		{
      896: 1386:		ec = ABS( ecgroup[i] ); 
      896: 1387:		out_char_set[i] = state[ec];
        -: 1388:		}
        -: 1389:
        4: 1390:	fprintf( file, " out-transitions: " );
call    0 returned 4
        -: 1391:
        4: 1392:	list_character_set( file, out_char_set );
call    0 returned 4
        -: 1393:
        -: 1394:	/* now invert the members of the set to get the jam transitions */
      900: 1395:	for ( i = 0; i < csize; ++i )
branch  0 taken 896
branch  1 taken 4 (fallthrough)
      896: 1396:		out_char_set[i] = ! out_char_set[i];
        -: 1397:
        4: 1398:	fprintf( file, "\n jam-transitions: EOF " );
call    0 returned 4
        -: 1399:
        4: 1400:	list_character_set( file, out_char_set );
call    0 returned 4
        -: 1401:
        4: 1402:	putc( '\n', file );
call    0 returned 4
        4: 1403:	}
        -: 1404:
        -: 1405:
        -: 1406:/* epsclosure - construct the epsilon closure of a set of ndfa states
        -: 1407: *
        -: 1408: * synopsis
        -: 1409: *    int *epsclosure( int t[num_states], int *numstates_addr,
        -: 1410: *			int accset[num_rules+1], int *nacc_addr,
        -: 1411: *			int *hashval_addr );
        -: 1412: *
        -: 1413: * NOTES
        -: 1414: *  The epsilon closure is the set of all states reachable by an arbitrary
        -: 1415: *  number of epsilon transitions, which themselves do not have epsilon
        -: 1416: *  transitions going out, unioned with the set of states which have non-null
        -: 1417: *  accepting numbers.  t is an array of size numstates of nfa state numbers.
        -: 1418: *  Upon return, t holds the epsilon closure and *numstates_addr is updated.
        -: 1419: *  accset holds a list of the accepting numbers, and the size of accset is
        -: 1420: *  given by *nacc_addr.  t may be subjected to reallocation if it is not
        -: 1421: *  large enough to hold the epsilon closure.
        -: 1422: *
        -: 1423: *  hashval is the hash value for the dfa corresponding to the state set.
        -: 1424: */
        -: 1425:
function epsclosure called 26686 returned 100% blocks executed 75%
    26686: 1426:int *epsclosure( t, ns_addr, accset, nacc_addr, hv_addr )
        -: 1427:int *t, *ns_addr, accset[], *nacc_addr, *hv_addr;
        -: 1428:	{
        -: 1429:	register int stkpos, ns, tsp;
    26686: 1430:	int numstates = *ns_addr, nacc, hashval, transsym, nfaccnum;
        -: 1431:	int stkend, nstate;
        -: 1432:	static int did_stk_init = false, *stk; 
        -: 1433:
        -: 1434:#define MARK_STATE(state) \
        -: 1435:trans1[state] = trans1[state] - MARKER_DIFFERENCE;
        -: 1436:
        -: 1437:#define IS_MARKED(state) (trans1[state] < 0)
        -: 1438:
        -: 1439:#define UNMARK_STATE(state) \
        -: 1440:trans1[state] = trans1[state] + MARKER_DIFFERENCE;
        -: 1441:
        -: 1442:#define CHECK_ACCEPT(state) \
        -: 1443:{ \
        -: 1444:nfaccnum = accptnum[state]; \
        -: 1445:if ( nfaccnum != NIL ) \
        -: 1446:accset[++nacc] = nfaccnum; \
        -: 1447:}
        -: 1448:
        -: 1449:#define DO_REALLOCATION \
        -: 1450:{ \
        -: 1451:current_max_dfa_size += MAX_DFA_SIZE_INCREMENT; \
        -: 1452:++num_reallocs; \
        -: 1453:t = reallocate_integer_array( t, current_max_dfa_size ); \
        -: 1454:stk = reallocate_integer_array( stk, current_max_dfa_size ); \
        -: 1455:} \
        -: 1456:
        -: 1457:#define PUT_ON_STACK(state) \
        -: 1458:{ \
        -: 1459:if ( ++stkend >= current_max_dfa_size ) \
        -: 1460:DO_REALLOCATION \
        -: 1461:stk[stkend] = state; \
        -: 1462:MARK_STATE(state) \
        -: 1463:}
        -: 1464:
        -: 1465:#define ADD_STATE(state) \
        -: 1466:{ \
        -: 1467:if ( ++numstates >= current_max_dfa_size ) \
        -: 1468:DO_REALLOCATION \
        -: 1469:t[numstates] = state; \
        -: 1470:hashval += state; \
        -: 1471:}
        -: 1472:
        -: 1473:#define STACK_STATE(state) \
        -: 1474:{ \
        -: 1475:PUT_ON_STACK(state) \
        -: 1476:CHECK_ACCEPT(state) \
        -: 1477:if ( nfaccnum != NIL || transchar[state] != SYM_EPSILON ) \
        -: 1478:ADD_STATE(state) \
        -: 1479:}
        -: 1480:
        -: 1481:
    26686: 1482:	if ( ! did_stk_init )
branch  0 taken 543 (fallthrough)
branch  1 taken 26143
        -: 1483:		{
      543: 1484:		stk = allocate_integer_array( current_max_dfa_size );
call    0 returned 543
      543: 1485:		did_stk_init = true;
        -: 1486:		}
        -: 1487:
    26686: 1488:	nacc = stkend = hashval = 0;
        -: 1489:
    83610: 1490:	for ( nstate = 1; nstate <= numstates; ++nstate )
branch  0 taken 56924
branch  1 taken 26686 (fallthrough)
        -: 1491:		{
    56924: 1492:		ns = t[nstate];
        -: 1493:
        -: 1494:		/* The state could be marked if we've already pushed it onto
        -: 1495:		 * the stack.
        -: 1496:		 */
    56924: 1497:		if ( ! IS_MARKED(ns) )
branch  0 taken 56924 (fallthrough)
branch  1 taken 0
        -: 1498:			{
   56924*: 1499:			PUT_ON_STACK(ns)
branch  0 taken 0 (fallthrough)
branch  1 taken 56924
call    2 never executed
call    3 never executed
    56924: 1500:			CHECK_ACCEPT(ns)
branch  0 taken 31561 (fallthrough)
branch  1 taken 25363
    56924: 1501:			hashval += ns;
        -: 1502:			}
        -: 1503:		}
        -: 1504:
   151342: 1505:	for ( stkpos = 1; stkpos <= stkend; ++stkpos )
branch  0 taken 124656
branch  1 taken 26686 (fallthrough)
        -: 1506:		{
   124656: 1507:		ns = stk[stkpos];
   124656: 1508:		transsym = transchar[ns];
        -: 1509:
   124656: 1510:		if ( transsym == SYM_EPSILON )
branch  0 taken 76876 (fallthrough)
branch  1 taken 47780
        -: 1511:			{
    76876: 1512:			tsp = trans1[ns] + MARKER_DIFFERENCE;
        -: 1513:
    76876: 1514:			if ( tsp != NO_TRANSITION )
branch  0 taken 42386 (fallthrough)
branch  1 taken 34490
        -: 1515:				{
    42386: 1516:				if ( ! IS_MARKED(tsp) )
branch  0 taken 42386 (fallthrough)
branch  1 taken 0
   42386*: 1517:					STACK_STATE(tsp)
branch  0 taken 1 (fallthrough)
branch  1 taken 42385
call    2 returned 1
call    3 returned 1
branch  4 taken 0 (fallthrough)
branch  5 taken 42386
branch  6 taken 42386 (fallthrough)
branch  7 taken 0
branch  8 taken 31452 (fallthrough)
branch  9 taken 10934
branch 10 taken 0 (fallthrough)
branch 11 taken 31452
call   12 never executed
call   13 never executed
        -: 1518:
    42386: 1519:				tsp = trans2[ns];
        -: 1520:
    42386: 1521:				if ( tsp != NO_TRANSITION && ! IS_MARKED(tsp) )
branch  0 taken 25347 (fallthrough)
branch  1 taken 17039
branch  2 taken 25346 (fallthrough)
branch  3 taken 1
   25346*: 1522:					STACK_STATE(tsp)
branch  0 taken 0 (fallthrough)
branch  1 taken 25346
call    2 never executed
call    3 never executed
branch  4 taken 12818 (fallthrough)
branch  5 taken 12528
branch  6 taken 12528 (fallthrough)
branch  7 taken 12818
branch  8 taken 7000 (fallthrough)
branch  9 taken 5528
branch 10 taken 0 (fallthrough)
branch 11 taken 19818
call   12 never executed
call   13 never executed
        -: 1523:				}
        -: 1524:			}
        -: 1525:		}
        -: 1526:
        -: 1527:	/* Clear out "visit" markers. */
        -: 1528:
   151342: 1529:	for ( stkpos = 1; stkpos <= stkend; ++stkpos )
branch  0 taken 124656
branch  1 taken 26686 (fallthrough)
        -: 1530:		{
   124656: 1531:		if ( IS_MARKED(stk[stkpos]) )
branch  0 taken 124656 (fallthrough)
branch  1 taken 0
   124656: 1532:			UNMARK_STATE(stk[stkpos])
        -: 1533:		else
    #####: 1534:			flexfatal( "consistency check failed in epsclosure()" );
call    0 never executed
        -: 1535:		}
        -: 1536:
    26686: 1537:	*ns_addr = numstates;
    26686: 1538:	*hv_addr = hashval;
    26686: 1539:	*nacc_addr = nacc;
        -: 1540:
    26686: 1541:	return t;
        -: 1542:	}
        -: 1543:
        -: 1544:
        -: 1545:/* increase_max_dfas - increase the maximum number of DFAs */
        -: 1546:
function increase_max_dfas called 1 returned 100% blocks executed 82%
        1: 1547:void increase_max_dfas()
        -: 1548:	{
        1: 1549:	current_max_dfas += MAX_DFAS_INCREMENT;
        -: 1550:
        1: 1551:	++num_reallocs;
        -: 1552:
        1: 1553:	base = reallocate_integer_array( base, current_max_dfas );
call    0 returned 1
        1: 1554:	def = reallocate_integer_array( def, current_max_dfas );
call    0 returned 1
        1: 1555:	dfasiz = reallocate_integer_array( dfasiz, current_max_dfas );
call    0 returned 1
        1: 1556:	accsiz = reallocate_integer_array( accsiz, current_max_dfas );
call    0 returned 1
        1: 1557:	dhash = reallocate_integer_array( dhash, current_max_dfas );
call    0 returned 1
        1: 1558:	dss = reallocate_int_ptr_array( dss, current_max_dfas );
call    0 returned 1
        1: 1559:	dfaacc = reallocate_dfaacc_union( dfaacc, current_max_dfas );
call    0 returned 1
        -: 1560:
        1: 1561:	if ( nultrans )
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 1562:		nultrans =
    #####: 1563:			reallocate_integer_array( nultrans, current_max_dfas );
call    0 never executed
        1: 1564:	}
        -: 1565:
        -: 1566:
        -: 1567:/* ntod - convert an ndfa to a dfa
        -: 1568: *
        -: 1569: * Creates the dfa corresponding to the ndfa we've constructed.  The
        -: 1570: * dfa starts out in state #1.
        -: 1571: */
        -: 1572:
function ntod called 543 returned 100% blocks executed 92%
      543: 1573:void ntod()
        -: 1574:	{
        -: 1575:	int *accset, ds, nacc, newds;
        -: 1576:	int sym, hashval, numstates, dsize;
        -: 1577:	int num_full_table_rows;	/* used only for -f */
        -: 1578:	int *nset, *dset;
        -: 1579:	int targptr, totaltrans, i, comstate, comfreq, targ;
        -: 1580:	int *epsclosure(), snstods(), symlist[CSIZE + 1];
        -: 1581:	int num_start_states;
        -: 1582:	int todo_head, todo_next;
        -: 1583:
        -: 1584:	/* Note that the following are indexed by *equivalence classes*
        -: 1585:	 * and not by characters.  Since equivalence classes are indexed
        -: 1586:	 * beginning with 1, even if the scanner accepts NUL's, this
        -: 1587:	 * means that (since every character is potentially in its own
        -: 1588:	 * equivalence class) these arrays must have room for indices
        -: 1589:	 * from 1 to CSIZE, so their size must be CSIZE + 1.
        -: 1590:	 */
        -: 1591:	int duplist[CSIZE + 1], state[CSIZE + 1];
        -: 1592:	int targfreq[CSIZE + 1], targstate[CSIZE + 1];
        -: 1593:
      543: 1594:	accset = allocate_integer_array( num_rules + 1 );
call    0 returned 543
      543: 1595:	nset = allocate_integer_array( current_max_dfa_size );
call    0 returned 543
        -: 1596:
        -: 1597:	/* The "todo" queue is represented by the head, which is the DFA
        -: 1598:	 * state currently being processed, and the "next", which is the
        -: 1599:	 * next DFA state number available (not in use).  We depend on the
        -: 1600:	 * fact that snstods() returns DFA's \in increasing order/, and thus
        -: 1601:	 * need only know the bounds of the dfas to be processed.
        -: 1602:	 */
      543: 1603:	todo_head = todo_next = 0;
        -: 1604:
   130366: 1605:	for ( i = 0; i <= csize; ++i )
branch  0 taken 129823
branch  1 taken 543 (fallthrough)
        -: 1606:		{
   129823: 1607:		duplist[i] = NIL;
   129823: 1608:		symlist[i] = false;
        -: 1609:		}
        -: 1610:
     4896: 1611:	for ( i = 0; i <= num_rules; ++i )
branch  0 taken 4353
branch  1 taken 543 (fallthrough)
     4353: 1612:		accset[i] = NIL;
        -: 1613:
      543: 1614:	if ( trace )
branch  0 taken 14 (fallthrough)
branch  1 taken 529
        -: 1615:		{
       14: 1616:		dumpnfa( scset[1] );
call    0 returned 14
       14: 1617:		fputs( "\n\nDFA Dump:\n\n", err );
call    0 returned 14
        -: 1618:		}
        -: 1619:
      543: 1620:	inittbl();
call    0 returned 543
        -: 1621:
        -: 1622:	/* Check to see whether we should build a separate table for
        -: 1623:	 * transitions on NUL characters.  We don't do this for full-speed
        -: 1624:	 * (-F) scanners, since for them we don't have a simple state
        -: 1625:	 * number lying around with which to index the table.  We also
        -: 1626:	 * don't bother doing it for scanners unless (1) NUL is in its own
        -: 1627:	 * equivalence class (indicated by a positive value of
        -: 1628:	 * ecgroup[NUL]), (2) NUL's equivalence class is the last
        -: 1629:	 * equivalence class, and (3) the number of equivalence classes is
        -: 1630:	 * the same as the number of characters.  This latter case comes
        -: 1631:	 * about when useecs is false or when it's true but every character
        -: 1632:	 * still manages to land in its own class (unlikely, but it's
        -: 1633:	 * cheap to check for).  If all these things are true then the
        -: 1634:	 * character code needed to represent NUL's equivalence class for
        -: 1635:	 * indexing the tables is going to take one more bit than the
        -: 1636:	 * number of characters, and therefore we won't be assured of
        -: 1637:	 * being able to fit it into a YY_CHAR variable.  This rules out
        -: 1638:	 * storing the transitions in a compressed table, since the code
        -: 1639:	 * for interpreting them uses a YY_CHAR variable (perhaps it
        -: 1640:	 * should just use an integer, though; this is worth pondering ...
        -: 1641:	 * ###).
        -: 1642:	 *
        -: 1643:	 * Finally, for full tables, we want the number of entries in the
        -: 1644:	 * table to be a power of two so the array references go fast (it
        -: 1645:	 * will just take a shift to compute the major index).  If
        -: 1646:	 * encoding NUL's transitions in the table will spoil this, we
        -: 1647:	 * give it its own table (note that this will be the case if we're
        -: 1648:	 * not using equivalence classes).
        -: 1649:	 */
        -: 1650:
        -: 1651:	/* Note that the test for ecgroup[0] == numecs below accomplishes
        -: 1652:	 * both (1) and (2) above
        -: 1653:	 */
      543: 1654:	if ( ! fullspd && ecgroup[0] == numecs )
branch  0 taken 451 (fallthrough)
branch  1 taken 92
branch  2 taken 198 (fallthrough)
branch  3 taken 253
        -: 1655:		{
        -: 1656:		/* NUL is alone in its equivalence class, which is the
        -: 1657:		 * last one.
        -: 1658:		 */
      198: 1659:		int use_NUL_table = (numecs == csize);
        -: 1660:
      198: 1661:		if ( fulltbl && ! use_NUL_table )
branch  0 taken 22 (fallthrough)
branch  1 taken 176
branch  2 taken 0 (fallthrough)
branch  3 taken 22
        -: 1662:			{
        -: 1663:			/* We still may want to use the table if numecs
        -: 1664:			 * is a power of 2.
        -: 1665:			 */
        -: 1666:			int power_of_two;
        -: 1667:
    #####: 1668:			for ( power_of_two = 1; power_of_two <= csize;
branch  0 never executed
branch  1 never executed
    #####: 1669:			      power_of_two *= 2 )
    #####: 1670:				if ( numecs == power_of_two )
branch  0 never executed
branch  1 never executed
        -: 1671:					{
    #####: 1672:					use_NUL_table = true;
    #####: 1673:					break;
        -: 1674:					}
        -: 1675:			}
        -: 1676:
      198: 1677:		if ( use_NUL_table )
branch  0 taken 196 (fallthrough)
branch  1 taken 2
      196: 1678:			nultrans = allocate_integer_array( current_max_dfas );
call    0 returned 196
        -: 1679:
        -: 1680:		/* From now on, nultrans != nil indicates that we're
        -: 1681:		 * saving null transitions for later, separate encoding.
        -: 1682:		 */
        -: 1683:		}
        -: 1684:
        -: 1685:
      543: 1686:	if ( fullspd )
branch  0 taken 92 (fallthrough)
branch  1 taken 451
        -: 1687:		{
     7416: 1688:		for ( i = 0; i <= numecs; ++i )
branch  0 taken 7324
branch  1 taken 92 (fallthrough)
     7324: 1689:			state[i] = 0;
        -: 1690:
       92: 1691:		place_state( state, 0, 0 );
call    0 returned 92
       92: 1692:		dfaacc[i].dfaacc_state = 0;
        -: 1693:		}
        -: 1694:
      451: 1695:	else if ( fulltbl )
branch  0 taken 23 (fallthrough)
branch  1 taken 428
        -: 1696:		{
       23: 1697:		if ( nultrans )
branch  0 taken 22 (fallthrough)
branch  1 taken 1
        -: 1698:			/* We won't be including NUL's transitions in the
        -: 1699:			 * table, so build it for entries from 0 .. numecs - 1.
        -: 1700:			 */
       22: 1701:			num_full_table_rows = numecs;
        -: 1702:
        -: 1703:		else
        -: 1704:			/* Take into account the fact that we'll be including
        -: 1705:			 * the NUL entries in the transition table.  Build it
        -: 1706:			 * from 0 .. numecs.
        -: 1707:			 */
        1: 1708:			num_full_table_rows = numecs + 1;
        -: 1709:
        -: 1710:		/* Unless -Ca, declare it "short" because it's a real
        -: 1711:		 * long-shot that that won't be large enough.
        -: 1712:		 */
      23*: 1713:		printf( "static const %s yy_nxt[][%d] =\n    {\n",
call    0 returned 23
        -: 1714:			/* '}' so vi doesn't get too confused */
       23: 1715:			long_align ? "long" : "short", num_full_table_rows );
branch  0 taken 0 (fallthrough)
branch  1 taken 23
        -: 1716:
        -: 1717:		/* Generate 0 entries for state #0. */
     2851: 1718:		for ( i = 0; i < num_full_table_rows; ++i )
branch  0 taken 2828
branch  1 taken 23 (fallthrough)
     2828: 1719:			mk2data( 0 );
call    0 returned 2828
        -: 1720:
        -: 1721:		/* Force ',' and dataflush() next call to mk2data().*/
       23: 1722:		datapos = NUMDATAITEMS;
        -: 1723:
        -: 1724:		/* Force extra blank line next dataflush(). */
       23: 1725:		dataline = NUMDATALINES;
        -: 1726:		}
        -: 1727:
        -: 1728:	/* Create the first states. */
        -: 1729:
      543: 1730:	num_start_states = lastsc * 2;
        -: 1731:
     1667: 1732:	for ( i = 1; i <= num_start_states; ++i )
branch  0 taken 1124
branch  1 taken 543 (fallthrough)
        -: 1733:		{
     1124: 1734:		numstates = 1;
        -: 1735:
        -: 1736:		/* For each start condition, make one state for the case when
        -: 1737:		 * we're at the beginning of the line (the '^' operator) and
        -: 1738:		 * one for the case when we're not.
        -: 1739:		 */
     1124: 1740:		if ( i % 2 == 1 )
branch  0 taken 562 (fallthrough)
branch  1 taken 562
      562: 1741:			nset[numstates] = scset[(i / 2) + 1];
        -: 1742:		else
      562: 1743:			nset[numstates] =
      562: 1744:				mkbranch( scbol[i / 2], scset[i / 2] );
call    0 returned 562
        -: 1745:
     1124: 1746:		nset = epsclosure( nset, &numstates, accset, &nacc, &hashval );
call    0 returned 1124
        -: 1747:
     1124: 1748:		if ( snstods( nset, numstates, accset, nacc, hashval, &ds ) )
call    0 returned 1124
branch  1 taken 1124 (fallthrough)
branch  2 taken 0
        -: 1749:			{
     1124: 1750:			numas += nacc;
     1124: 1751:			totnst += numstates;
     1124: 1752:			++todo_next;
        -: 1753:
     1124: 1754:			if ( variable_trailing_context_rules && nacc > 0 )
branch  0 taken 66 (fallthrough)
branch  1 taken 1058
branch  2 taken 0 (fallthrough)
branch  3 taken 66
    #####: 1755:				check_trailing_context( nset, numstates,
call    0 never executed
        -: 1756:							accset, nacc );
        -: 1757:			}
        -: 1758:		}
        -: 1759:
      543: 1760:	if ( ! fullspd )
branch  0 taken 451 (fallthrough)
branch  1 taken 92
        -: 1761:		{
      451: 1762:		if ( ! snstods( nset, 0, accset, 0, 0, &end_of_buffer_state ) )
call    0 returned 451
branch  1 taken 0 (fallthrough)
branch  2 taken 451
    #####: 1763:			flexfatal(
call    0 never executed
        -: 1764:				"could not create unique end-of-buffer state" );
        -: 1765:
      451: 1766:		++numas;
      451: 1767:		++num_start_states;
      451: 1768:		++todo_next;
        -: 1769:		}
        -: 1770:
    14487: 1771:	while ( todo_head < todo_next )
branch  0 taken 13944
branch  1 taken 543 (fallthrough)
        -: 1772:		{
    13944: 1773:		targptr = 0;
    13944: 1774:		totaltrans = 0;
        -: 1775:
  1490595: 1776:		for ( i = 1; i <= numecs; ++i )
branch  0 taken 1476651
branch  1 taken 13944 (fallthrough)
  1476651: 1777:			state[i] = 0;
        -: 1778:
    13944: 1779:		ds = ++todo_head;
        -: 1780:
    13944: 1781:		dset = dss[ds];
    13944: 1782:		dsize = dfasiz[ds];
        -: 1783:
    13944: 1784:		if ( trace )
branch  0 taken 1396 (fallthrough)
branch  1 taken 12548
     1396: 1785:			fprintf( err, "state # %d:\n", ds );
call    0 returned 1396
        -: 1786:
    13944: 1787:		sympartition( dset, dsize, symlist, duplist );
call    0 returned 13944
        -: 1788:
  1490595: 1789:		for ( sym = 1; sym <= numecs; ++sym )
branch  0 taken 1476651
branch  1 taken 13944 (fallthrough)
        -: 1790:			{
  1476651: 1791:			if ( symlist[sym] )
branch  0 taken 286119 (fallthrough)
branch  1 taken 1190532
        -: 1792:				{
   286119: 1793:				symlist[sym] = 0;
        -: 1794:
   286119: 1795:				if ( duplist[sym] == NIL )
branch  0 taken 25562 (fallthrough)
branch  1 taken 260557
        -: 1796:					{
        -: 1797:					/* Symbol has unique out-transitions. */
    25562: 1798:					numstates = symfollowset( dset, dsize,
call    0 returned 25562
        -: 1799:								sym, nset );
    25562: 1800:					nset = epsclosure( nset, &numstates,
call    0 returned 25562
        -: 1801:						accset, &nacc, &hashval );
        -: 1802:
    25562: 1803:					if ( snstods( nset, numstates, accset,
call    0 returned 25562
branch  1 taken 12369 (fallthrough)
branch  2 taken 13193
        -: 1804:						nacc, hashval, &newds ) )
        -: 1805:						{
    12369: 1806:						totnst = totnst + numstates;
    12369: 1807:						++todo_next;
    12369: 1808:						numas += nacc;
        -: 1809:
    12369: 1810:						if (
    12369: 1811:					variable_trailing_context_rules &&
branch  0 taken 696 (fallthrough)
branch  1 taken 11673
      696: 1812:							nacc > 0 )
branch  0 taken 446 (fallthrough)
branch  1 taken 250
      446: 1813:							check_trailing_context(
call    0 returned 446
        -: 1814:								nset, numstates,
        -: 1815:								accset, nacc );
        -: 1816:						}
        -: 1817:
    25562: 1818:					state[sym] = newds;
        -: 1819:
    25562: 1820:					if ( trace )
branch  0 taken 4878 (fallthrough)
branch  1 taken 20684
     4878: 1821:						fprintf( err, "\t%d\t%d\n",
call    0 returned 4878
        -: 1822:							sym, newds );
        -: 1823:
    25562: 1824:					targfreq[++targptr] = 1;
    25562: 1825:					targstate[targptr] = newds;
    25562: 1826:					++numuniq;
        -: 1827:					}
        -: 1828:
        -: 1829:				else
        -: 1830:					{
        -: 1831:					/* sym's equivalence class has the same
        -: 1832:					 * transitions as duplist(sym)'s
        -: 1833:					 * equivalence class.
        -: 1834:					 */
   260557: 1835:					targ = state[duplist[sym]];
   260557: 1836:					state[sym] = targ;
        -: 1837:
   260557: 1838:					if ( trace )
branch  0 taken 57113 (fallthrough)
branch  1 taken 203444
    57113: 1839:						fprintf( err, "\t%d\t%d\n",
call    0 returned 57113
        -: 1840:							sym, targ );
        -: 1841:
        -: 1842:					/* Update frequency count for
        -: 1843:					 * destination state.
        -: 1844:					 */
        -: 1845:
   260557: 1846:					i = 0;
   355011: 1847:					while ( targstate[++i] != targ )
branch  0 taken 94454
branch  1 taken 260557 (fallthrough)
        -: 1848:						;
        -: 1849:
   260557: 1850:					++targfreq[i];
   260557: 1851:					++numdup;
        -: 1852:					}
        -: 1853:
   286119: 1854:				++totaltrans;
   286119: 1855:				duplist[sym] = NIL;
        -: 1856:				}
        -: 1857:			}
        -: 1858:
    13944: 1859:		numsnpairs = numsnpairs + totaltrans;
        -: 1860:
    13944: 1861:		if ( caseins && ! useecs )
branch  0 taken 106 (fallthrough)
branch  1 taken 13838
branch  2 taken 0 (fallthrough)
branch  3 taken 106
        -: 1862:			{
        -: 1863:			register int j;
        -: 1864:
    #####: 1865:			for ( i = 'A', j = 'a'; i <= 'Z'; ++i, ++j )
branch  0 never executed
branch  1 never executed
    #####: 1866:				state[i] = state[j];
        -: 1867:			}
        -: 1868:
    13944: 1869:		if ( ds > num_start_states )
branch  0 taken 12369 (fallthrough)
branch  1 taken 1575
    12369: 1870:			check_for_backing_up( ds, state );
call    0 returned 12369
        -: 1871:
    13944: 1872:		if ( nultrans )
branch  0 taken 4710 (fallthrough)
branch  1 taken 9234
        -: 1873:			{
     4710: 1874:			nultrans[ds] = state[NUL_ec];
     4710: 1875:			state[NUL_ec] = 0;	/* remove transition */
        -: 1876:			}
        -: 1877:
    13944: 1878:		if ( fulltbl )
branch  0 taken 542 (fallthrough)
branch  1 taken 13402
        -: 1879:			{
        -: 1880:			/* Supply array's 0-element. */
      542: 1881:			if ( ds == end_of_buffer_state )
branch  0 taken 23 (fallthrough)
branch  1 taken 519
       23: 1882:				mk2data( -end_of_buffer_state );
call    0 returned 23
        -: 1883:			else
      519: 1884:				mk2data( end_of_buffer_state );
call    0 returned 519
        -: 1885:
    67288: 1886:			for ( i = 1; i < num_full_table_rows; ++i )
branch  0 taken 66746
branch  1 taken 542 (fallthrough)
        -: 1887:				/* Jams are marked by negative of state
        -: 1888:				 * number.
        -: 1889:				 */
    66746: 1890:				mk2data( state[i] ? state[i] : -ds );
branch  0 taken 11603 (fallthrough)
branch  1 taken 55143
call    2 returned 66746
        -: 1891:
        -: 1892:			/* Force ',' and dataflush() next call to mk2data().*/
      542: 1893:			datapos = NUMDATAITEMS;
        -: 1894:
        -: 1895:			/* Force extra blank line next dataflush(). */
      542: 1896:			dataline = NUMDATALINES;
        -: 1897:			}
        -: 1898:
    13402: 1899:		else if ( fullspd )
branch  0 taken 2170 (fallthrough)
branch  1 taken 11232
     2170: 1900:			place_state( state, ds, totaltrans );
call    0 returned 2170
        -: 1901:
    11232: 1902:		else if ( ds == end_of_buffer_state )
branch  0 taken 428 (fallthrough)
branch  1 taken 10804
        -: 1903:			/* Special case this state to make sure it does what
        -: 1904:			 * it's supposed to, i.e., jam on end-of-buffer.
        -: 1905:			 */
      428: 1906:			stack1( ds, 0, 0, JAMSTATE );
call    0 returned 428
        -: 1907:
        -: 1908:		else /* normal, compressed state */
        -: 1909:			{
        -: 1910:			/* Determine which destination state is the most
        -: 1911:			 * common, and how many transitions to it there are.
        -: 1912:			 */
        -: 1913:
    10804: 1914:			comfreq = 0;
    10804: 1915:			comstate = 0;
        -: 1916:
    31794: 1917:			for ( i = 1; i <= targptr; ++i )
branch  0 taken 20990
branch  1 taken 10804 (fallthrough)
    20990: 1918:				if ( targfreq[i] > comfreq )
branch  0 taken 9104 (fallthrough)
branch  1 taken 11886
        -: 1919:					{
     9104: 1920:					comfreq = targfreq[i];
     9104: 1921:					comstate = targstate[i];
        -: 1922:					}
        -: 1923:
    10804: 1924:			bldtbl( state, ds, totaltrans, comstate, comfreq );
call    0 returned 10804
        -: 1925:			}
        -: 1926:		}
        -: 1927:
      543: 1928:	if ( fulltbl )
branch  0 taken 23 (fallthrough)
branch  1 taken 520
       23: 1929:		dataend();
call    0 returned 23
        -: 1930:
      520: 1931:	else if ( ! fullspd )
branch  0 taken 428 (fallthrough)
branch  1 taken 92
        -: 1932:		{
      428: 1933:		cmptmps();  /* create compressed template entries */
call    0 returned 428
        -: 1934:
        -: 1935:		/* Create tables for all the states with only one
        -: 1936:		 * out-transition.
        -: 1937:		 */
     6108: 1938:		while ( onesp > 0 )
branch  0 taken 5680
branch  1 taken 428 (fallthrough)
        -: 1939:			{
     5680: 1940:			mk1tbl( onestate[onesp], onesym[onesp], onenext[onesp],
call    0 returned 5680
        -: 1941:			onedef[onesp] );
     5680: 1942:			--onesp;
        -: 1943:			}
        -: 1944:
      428: 1945:		mkdeftbl();
call    0 returned 428
        -: 1946:		}
        -: 1947:
      543: 1948:	flex_free( (void *) accset );
call    0 returned 543
      543: 1949:	flex_free( (void *) nset );
call    0 returned 543
        -: 1950:#ifndef	F_HD_2
        -: 1951:
        -: 1952:#else
        -: 1953:	flex_free( (void *) dset );
        -: 1954:#endif
      543: 1955:	}
        -: 1956:
        -: 1957:
        -: 1958:/* snstods - converts a set of ndfa states into a dfa state
        -: 1959: *
        -: 1960: * synopsis
        -: 1961: *    is_new_state = snstods( int sns[numstates], int numstates,
        -: 1962: *				int accset[num_rules+1], int nacc,
        -: 1963: *				int hashval, int *newds_addr );
        -: 1964: *
        -: 1965: * On return, the dfa state number is in newds.
        -: 1966: */
        -: 1967:
function snstods called 27137 returned 100% blocks executed 100%
    27137: 1968:int snstods( sns, numstates, accset, nacc, hashval, newds_addr )
        -: 1969:int sns[], numstates, accset[], nacc, hashval, *newds_addr;
        -: 1970:	{
    27137: 1971:	int didsort = 0;
        -: 1972:	register int i, j;
        -: 1973:	int newds, *oldsns;
        -: 1974:
  1247634: 1975:	for ( i = 1; i <= lastdfa; ++i )
branch  0 taken 1233690
branch  1 taken 13944 (fallthrough)
  1233690: 1976:		if ( hashval == dhash[i] )
branch  0 taken 13338 (fallthrough)
branch  1 taken 1220352
        -: 1977:			{
    13338: 1978:			if ( numstates == dfasiz[i] )
branch  0 taken 13197 (fallthrough)
branch  1 taken 141
        -: 1979:				{
    13197: 1980:				oldsns = dss[i];
        -: 1981:
    13197: 1982:				if ( ! didsort )
branch  0 taken 13197 (fallthrough)
branch  1 taken 0
        -: 1983:					{
        -: 1984:					/* We sort the states in sns so we
        -: 1985:					 * can compare it to oldsns quickly.
        -: 1986:					 * We use bubble because there probably
        -: 1987:					 * aren't very many states.
        -: 1988:					 */
    13197: 1989:					bubble( sns, numstates );
call    0 returned 13197
    13197: 1990:					didsort = 1;
        -: 1991:					}
        -: 1992:
    64380: 1993:				for ( j = 1; j <= numstates; ++j )
branch  0 taken 51187
branch  1 taken 13193 (fallthrough)
    51187: 1994:					if ( sns[j] != oldsns[j] )
branch  0 taken 4 (fallthrough)
branch  1 taken 51183
        4: 1995:						break;
        -: 1996:
    13197: 1997:				if ( j > numstates )
branch  0 taken 13193 (fallthrough)
branch  1 taken 4
        -: 1998:					{
    13193: 1999:					++dfaeql;
    13193: 2000:					*newds_addr = i;
    13193: 2001:					return 0;
        -: 2002:					}
        -: 2003:
        4: 2004:				++hshcol;
        -: 2005:				}
        -: 2006:
        -: 2007:			else
      141: 2008:				++hshsave;
        -: 2009:			}
        -: 2010:
        -: 2011:	/* Make a new dfa. */
        -: 2012:
    13944: 2013:	if ( ++lastdfa >= current_max_dfas )
branch  0 taken 1 (fallthrough)
branch  1 taken 13943
        1: 2014:		increase_max_dfas();
call    0 returned 1
        -: 2015:
    13944: 2016:	newds = lastdfa;
        -: 2017:
    13944: 2018:	dss[newds] = allocate_integer_array( numstates + 1 );
call    0 returned 13944
        -: 2019:
        -: 2020:	/* If we haven't already sorted the states in sns, we do so now,
        -: 2021:	 * so that future comparisons with it can be made quickly.
        -: 2022:	 */
        -: 2023:
    13944: 2024:	if ( ! didsort )
branch  0 taken 13940 (fallthrough)
branch  1 taken 4
    13940: 2025:		bubble( sns, numstates );
call    0 returned 13940
        -: 2026:
    70973: 2027:	for ( i = 1; i <= numstates; ++i )
branch  0 taken 57029
branch  1 taken 13944 (fallthrough)
    57029: 2028:		dss[newds][i] = sns[i];
        -: 2029:
    13944: 2030:	dfasiz[newds] = numstates;
    13944: 2031:	dhash[newds] = hashval;
        -: 2032:
    13944: 2033:	if ( nacc == 0 )
branch  0 taken 3638 (fallthrough)
branch  1 taken 10306
        -: 2034:		{
     3638: 2035:		if ( reject )
branch  0 taken 1143 (fallthrough)
branch  1 taken 2495
     1143: 2036:			dfaacc[newds].dfaacc_set = (int *) 0;
        -: 2037:		else
     2495: 2038:			dfaacc[newds].dfaacc_state = 0;
        -: 2039:
     3638: 2040:		accsiz[newds] = 0;
        -: 2041:		}
        -: 2042:
    10306: 2043:	else if ( reject )
branch  0 taken 4045 (fallthrough)
branch  1 taken 6261
        -: 2044:		{
        -: 2045:		/* We sort the accepting set in increasing order so the
        -: 2046:		 * disambiguating rule that the first rule listed is considered
        -: 2047:		 * match in the event of ties will work.  We use a bubble
        -: 2048:		 * sort since the list is probably quite small.
        -: 2049:		 */
        -: 2050:
     4045: 2051:		bubble( accset, nacc );
call    0 returned 4045
        -: 2052:
     4045: 2053:		dfaacc[newds].dfaacc_set = allocate_integer_array( nacc + 1 );
call    0 returned 4045
        -: 2054:
        -: 2055:		/* Save the accepting set for later */
    14446: 2056:		for ( i = 1; i <= nacc; ++i )
branch  0 taken 10401
branch  1 taken 4045 (fallthrough)
        -: 2057:			{
    10401: 2058:			dfaacc[newds].dfaacc_set[i] = accset[i];
        -: 2059:
    10401: 2060:			if ( accset[i] <= num_rules )
branch  0 taken 10335 (fallthrough)
branch  1 taken 66
        -: 2061:				/* Who knows, perhaps a REJECT can yield
        -: 2062:				 * this rule.
        -: 2063:				 */
    10335: 2064:				rule_useful[accset[i]] = true;
        -: 2065:			}
        -: 2066:
     4045: 2067:		accsiz[newds] = nacc;
        -: 2068:		}
        -: 2069:
        -: 2070:	else
        -: 2071:		{
        -: 2072:		/* Find lowest numbered rule so the disambiguating rule
        -: 2073:		 * will work.
        -: 2074:		 */
     6261: 2075:		j = num_rules + 1;
        -: 2076:
    15646: 2077:		for ( i = 1; i <= nacc; ++i )
branch  0 taken 9385
branch  1 taken 6261 (fallthrough)
     9385: 2078:			if ( accset[i] < j )
branch  0 taken 6905 (fallthrough)
branch  1 taken 2480
     6905: 2079:				j = accset[i];
        -: 2080:
     6261: 2081:		dfaacc[newds].dfaacc_state = j;
        -: 2082:
     6261: 2083:		if ( j <= num_rules )
branch  0 taken 6261 (fallthrough)
branch  1 taken 0
     6261: 2084:			rule_useful[j] = true;
        -: 2085:		}
        -: 2086:
    13944: 2087:	*newds_addr = newds;
        -: 2088:
    13944: 2089:	return 1;
        -: 2090:	}
        -: 2091:
        -: 2092:
        -: 2093:/* symfollowset - follow the symbol transitions one step
        -: 2094: *
        -: 2095: * synopsis
        -: 2096: *    numstates = symfollowset( int ds[current_max_dfa_size], int dsize,
        -: 2097: *				int transsym, int nset[current_max_dfa_size] );
        -: 2098: */
        -: 2099:
function symfollowset called 25562 returned 100% blocks executed 94%
    25562: 2100:int symfollowset( ds, dsize, transsym, nset )
        -: 2101:int ds[], dsize, transsym, nset[];
        -: 2102:	{
        -: 2103:	int ns, tsp, sym, i, j, lenccl, ch, numstates, ccllist;
        -: 2104:
    25562: 2105:	numstates = 0;
        -: 2106:
   296581: 2107:	for ( i = 1; i <= dsize; ++i )
branch  0 taken 271019
branch  1 taken 25562 (fallthrough)
        -: 2108:		{ /* for each nfa state ns in the state set of ds */
   271019: 2109:		ns = ds[i];
   271019: 2110:		sym = transchar[ns];
   271019: 2111:		tsp = trans1[ns];
        -: 2112:
   271019: 2113:		if ( sym < 0 )
branch  0 taken 66527 (fallthrough)
branch  1 taken 204492
        -: 2114:			{ /* it's a character class */
    66527: 2115:			sym = -sym;
    66527: 2116:			ccllist = cclmap[sym];
    66527: 2117:			lenccl = ccllen[sym];
        -: 2118:
    66527: 2119:			if ( cclng[sym] )
branch  0 taken 21085 (fallthrough)
branch  1 taken 45442
        -: 2120:				{
    51802: 2121:				for ( j = 0; j < lenccl; ++j )
branch  0 taken 34501
branch  1 taken 17301 (fallthrough)
        -: 2122:					{
        -: 2123:					/* Loop through negated character
        -: 2124:					 * class.
        -: 2125:					 */
    34501: 2126:					ch = ccltbl[ccllist + j];
        -: 2127:
    34501: 2128:					if ( ch == 0 )
branch  0 taken 0 (fallthrough)
branch  1 taken 34501
    #####: 2129:						ch = NUL_ec;
        -: 2130:
    34501: 2131:					if ( ch > transsym )
branch  0 taken 2330 (fallthrough)
branch  1 taken 32171
        -: 2132:						/* Transsym isn't in negated
        -: 2133:						 * ccl.
        -: 2134:						 */
     2330: 2135:						break;
        -: 2136:
    32171: 2137:					else if ( ch == transsym )
branch  0 taken 1454 (fallthrough)
branch  1 taken 30717
     1454: 2138:						/* next 2 */ goto bottom;
        -: 2139:					}
        -: 2140:
        -: 2141:				/* Didn't find transsym in ccl. */
    19631: 2142:				nset[++numstates] = tsp;
        -: 2143:				}
        -: 2144:
        -: 2145:			else
   179956: 2146:				for ( j = 0; j < lenccl; ++j )
branch  0 taken 171388
branch  1 taken 8568 (fallthrough)
        -: 2147:					{
   171388: 2148:					ch = ccltbl[ccllist + j];
        -: 2149:
   171388: 2150:					if ( ch == 0 )
branch  0 taken 6 (fallthrough)
branch  1 taken 171382
        6: 2151:						ch = NUL_ec;
        -: 2152:
   171388: 2153:					if ( ch > transsym )
branch  0 taken 17031 (fallthrough)
branch  1 taken 154357
    17031: 2154:						break;
   154357: 2155:					else if ( ch == transsym )
branch  0 taken 19843 (fallthrough)
branch  1 taken 134514
        -: 2156:						{
    19843: 2157:						nset[++numstates] = tsp;
    19843: 2158:						break;
        -: 2159:						}
        -: 2160:					}
        -: 2161:			}
        -: 2162:
   204492: 2163:		else if ( sym >= 'A' && sym <= 'Z' && caseins )
branch  0 taken 186438 (fallthrough)
branch  1 taken 18054
branch  2 taken 6091 (fallthrough)
branch  3 taken 180347
branch  4 taken 0 (fallthrough)
branch  5 taken 6091
    #####: 2164:			flexfatal( "consistency check failed in symfollowset" );
call    0 never executed
        -: 2165:
   204492: 2166:		else if ( sym == SYM_EPSILON )
branch  0 taken 138015 (fallthrough)
branch  1 taken 66477
        -: 2167:			{ /* do nothing */
        -: 2168:			}
        -: 2169:
   138015: 2170:		else if ( ABS( ecgroup[sym] ) == transsym )
branch  0 taken 121689 (fallthrough)
branch  1 taken 16326
    16326: 2171:			nset[++numstates] = tsp;
        -: 2172:
   271019: 2173:		bottom: ;
        -: 2174:		}
        -: 2175:
    25562: 2176:	return numstates;
        -: 2177:	}
        -: 2178:
        -: 2179:
        -: 2180:/* sympartition - partition characters with same out-transitions
        -: 2181: *
        -: 2182: * synopsis
        -: 2183: *    sympartition( int ds[current_max_dfa_size], int numstates,
        -: 2184: *			int symlist[numecs], int duplist[numecs] );
        -: 2185: */
        -: 2186:
function sympartition called 13944 returned 100% blocks executed 94%
    13944: 2187:void sympartition( ds, numstates, symlist, duplist )
        -: 2188:int ds[], numstates;
        -: 2189:int symlist[], duplist[];
        -: 2190:	{
        -: 2191:	int tch, i, j, k, ns, dupfwd[CSIZE + 1], lenccl, cclp, ich;
        -: 2192:
        -: 2193:	/* Partitioning is done by creating equivalence classes for those
        -: 2194:	 * characters which have out-transitions from the given state.  Thus
        -: 2195:	 * we are really creating equivalence classes of equivalence classes.
        -: 2196:	 */
        -: 2197:
  1490595: 2198:	for ( i = 1; i <= numecs; ++i )
branch  0 taken 1476651
branch  1 taken 13944 (fallthrough)
        -: 2199:		{ /* initialize equivalence class list */
  1476651: 2200:		duplist[i] = i - 1;
  1476651: 2201:		dupfwd[i] = i + 1;
        -: 2202:		}
        -: 2203:
    13944: 2204:	duplist[1] = NIL;
    13944: 2205:	dupfwd[numecs] = NIL;
        -: 2206:
    70973: 2207:	for ( i = 1; i <= numstates; ++i )
branch  0 taken 57029
branch  1 taken 13944 (fallthrough)
        -: 2208:		{
    57029: 2209:		ns = ds[i];
    57029: 2210:		tch = transchar[ns];
        -: 2211:
    57029: 2212:		if ( tch != SYM_EPSILON )
branch  0 taken 29498 (fallthrough)
branch  1 taken 27531
        -: 2213:			{
    29498: 2214:			if ( tch < -lastccl || tch >= csize )
branch  0 taken 29498 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 29498
        -: 2215:				{
    #####: 2216:				flexfatal(
call    0 never executed
        -: 2217:			"bad transition character detected in sympartition()" );
        -: 2218:				}
        -: 2219:
    29498: 2220:			if ( tch >= 0 )
branch  0 taken 16326 (fallthrough)
branch  1 taken 13172
        -: 2221:				{ /* character transition */
    16326: 2222:				int ec = ecgroup[tch];
        -: 2223:
    16326: 2224:				mkechar( ec, dupfwd, duplist );
call    0 returned 16326
    16326: 2225:				symlist[ec] = 1;
        -: 2226:				}
        -: 2227:
        -: 2228:			else
        -: 2229:				{ /* character class */
    13172: 2230:				tch = -tch;
        -: 2231:
    13172: 2232:				lenccl = ccllen[tch];
    13172: 2233:				cclp = cclmap[tch];
    13172: 2234:				mkeccl( ccltbl + cclp, lenccl, dupfwd,
call    0 returned 13172
        -: 2235:					duplist, numecs, NUL_ec );
        -: 2236:
    13172: 2237:				if ( cclng[tch] )
branch  0 taken 3108 (fallthrough)
branch  1 taken 10064
        -: 2238:					{
     3108: 2239:					j = 0;
        -: 2240:
    11399: 2241:					for ( k = 0; k < lenccl; ++k )
branch  0 taken 8291
branch  1 taken 3108 (fallthrough)
        -: 2242:						{
     8291: 2243:						ich = ccltbl[cclp + k];
        -: 2244:
     8291: 2245:						if ( ich == 0 )
branch  0 taken 0 (fallthrough)
branch  1 taken 8291
    #####: 2246:							ich = NUL_ec;
        -: 2247:
    35713: 2248:						for ( ++j; j < ich; ++j )
branch  0 taken 27422
branch  1 taken 8291 (fallthrough)
    27422: 2249:							symlist[j] = 1;
        -: 2250:						}
        -: 2251:
   243637: 2252:					for ( ++j; j <= numecs; ++j )
branch  0 taken 240529
branch  1 taken 3108
   240529: 2253:						symlist[j] = 1;
        -: 2254:					}
        -: 2255:
        -: 2256:				else
   203268: 2257:					for ( k = 0; k < lenccl; ++k )
branch  0 taken 193204
branch  1 taken 10064 (fallthrough)
        -: 2258:						{
   193204: 2259:						ich = ccltbl[cclp + k];
        -: 2260:
   193204: 2261:						if ( ich == 0 )
branch  0 taken 2 (fallthrough)
branch  1 taken 193202
        2: 2262:							ich = NUL_ec;
        -: 2263:
   193204: 2264:						symlist[ich] = 1;
        -: 2265:						}
        -: 2266:				}
        -: 2267:			}
        -: 2268:		}
    13944: 2269:	}
        -: 2270:/* ecs - equivalence class routines */
        -: 2271:
        -: 2272:/*-
        -: 2273: * Copyright (c) 1990 The Regents of the University of California.
        -: 2274: * All rights reserved.
        -: 2275: *
        -: 2276: * This code is derived from software contributed to Berkeley by
        -: 2277: * Vern Paxson.
        -: 2278: * 
        -: 2279: * The United States Government has rights in this work pursuant
        -: 2280: * to contract no. DE-AC03-76SF00098 between the United States
        -: 2281: * Department of Energy and the University of California.
        -: 2282: *
        -: 2283: * Redistribution and use in source and binary forms are permitted provided
        -: 2284: * that: (1) source distributions retain this entire copyright notice and
        -: 2285: * comment, and (2) distributions including binaries display the following
        -: 2286: * acknowledgement:  ``This product includes software developed by the
        -: 2287: * University of California, Berkeley and its contributors'' in the
        -: 2288: * documentation or other materials provided with the distribution and in
        -: 2289: * all advertising materials mentioning features or use of this software.
        -: 2290: * Neither the name of the University nor the names of its contributors may
        -: 2291: * be used to endorse or promote products derived from this software without
        -: 2292: * specific prior written permission.
        -: 2293: * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
        -: 2294: * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
        -: 2295: * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
        -: 2296: */
        -: 2297:
        -: 2298:/* $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.seeded/v1/flex.c,v 1.1.1.2 2003/09/02 20:21:59 expsir Exp $ */
        -: 2299:
        -: 2300:
        -: 2301:/* ccl2ecl - convert character classes to set of equivalence classes */
        -: 2302:
function ccl2ecl called 295 returned 100% blocks executed 100%
      295: 2303:void ccl2ecl()
        -: 2304:	{
        -: 2305:	int i, ich, newlen, cclp, ccls, cclmec;
        -: 2306:
     1286: 2307:	for ( i = 1; i <= lastccl; ++i )
branch  0 taken 991
branch  1 taken 295 (fallthrough)
        -: 2308:		{
        -: 2309:		/* We loop through each character class, and for each character
        -: 2310:		 * in the class, add the character's equivalence class to the
        -: 2311:		 * new "character" class we are creating.  Thus when we are all
        -: 2312:		 * done, character classes will really consist of collections
        -: 2313:		 * of equivalence classes
        -: 2314:		 */
        -: 2315:
      991: 2316:		newlen = 0;
      991: 2317:		cclp = cclmap[i];
        -: 2318:
     8522: 2319:		for ( ccls = 0; ccls < ccllen[i]; ++ccls )
branch  0 taken 7531
branch  1 taken 991 (fallthrough)
        -: 2320:			{
     7531: 2321:			ich = ccltbl[cclp + ccls];
     7531: 2322:			cclmec = ecgroup[ich];
        -: 2323:
     7531: 2324:			if ( cclmec > 0 )
branch  0 taken 3149 (fallthrough)
branch  1 taken 4382
        -: 2325:				{
     3149: 2326:				ccltbl[cclp + newlen] = cclmec;
     3149: 2327:				++newlen;
        -: 2328:				}
        -: 2329:			}
        -: 2330:
      991: 2331:		ccllen[i] = newlen;
        -: 2332:		}
      295: 2333:	}
        -: 2334:
        -: 2335:
        -: 2336:/* cre8ecs - associate equivalence class numbers with class members
        -: 2337: *
        -: 2338: * fwd is the forward linked-list of equivalence class members.  bck
        -: 2339: * is the backward linked-list, and num is the number of class members.
        -: 2340: *
        -: 2341: * Returned is the number of classes.
        -: 2342: */
        -: 2343:
function cre8ecs called 509 returned 100% blocks executed 100%
      509: 2344:int cre8ecs( fwd, bck, num )
        -: 2345:int fwd[], bck[], num;
        -: 2346:	{
        -: 2347:	int i, j, numcl;
        -: 2348:
      509: 2349:	numcl = 0;
        -: 2350:
        -: 2351:	/* Create equivalence class numbers.  From now on, ABS( bck(x) )
        -: 2352:	 * is the equivalence class number for object x.  If bck(x)
        -: 2353:	 * is positive, then x is the representative of its equivalence
        -: 2354:	 * class.
        -: 2355:	 */
    98069: 2356:	for ( i = 1; i <= num; ++i )
branch  0 taken 97560
branch  1 taken 509 (fallthrough)
    97560: 2357:		if ( bck[i] == NIL )
branch  0 taken 4549 (fallthrough)
branch  1 taken 93011
        -: 2358:			{
     4549: 2359:			bck[i] = ++numcl;
    97560: 2360:			for ( j = fwd[i]; j != NIL; j = fwd[j] )
branch  0 taken 93011
branch  1 taken 4549 (fallthrough)
    93011: 2361:				bck[j] = -numcl;
        -: 2362:			}
        -: 2363:
      509: 2364:	return numcl;
        -: 2365:	}
        -: 2366:
        -: 2367:
        -: 2368:/* mkeccl - update equivalence classes based on character class xtions
        -: 2369: *
        -: 2370: * synopsis
        -: 2371: *    Char ccls[];
        -: 2372: *    int lenccl, fwd[llsiz], bck[llsiz], llsiz, NUL_mapping;
        -: 2373: *    void mkeccl( Char ccls[], int lenccl, int fwd[llsiz], int bck[llsiz],
        -: 2374: *			int llsiz, int NUL_mapping );
        -: 2375: *
        -: 2376: * ccls contains the elements of the character class, lenccl is the
        -: 2377: * number of elements in the ccl, fwd is the forward link-list of equivalent
        -: 2378: * characters, bck is the backward link-list, and llsiz size of the link-list.
        -: 2379: *
        -: 2380: * NUL_mapping is the value which NUL (0) should be mapped to.
        -: 2381: */
        -: 2382:
function mkeccl called 14421 returned 100% blocks executed 100%
    14421: 2383:void mkeccl( ccls, lenccl, fwd, bck, llsiz, NUL_mapping )
        -: 2384:Char ccls[];
        -: 2385:int lenccl, fwd[], bck[], llsiz, NUL_mapping;
        -: 2386:	{
        -: 2387:	int cclp, oldec, newec;
        -: 2388:	int cclm, i, j;
        -: 2389:	static unsigned char cclflags[CSIZE];	/* initialized to all '\0' */
        -: 2390:
        -: 2391:	/* Note that it doesn't matter whether or not the character class is
        -: 2392:	 * negated.  The same results will be obtained in either case.
        -: 2393:	 */
        -: 2394:
    14421: 2395:	cclp = 0;
        -: 2396:
    36243: 2397:	while ( cclp < lenccl )
branch  0 taken 21822
branch  1 taken 14421 (fallthrough)
        -: 2398:		{
    21822: 2399:		cclm = ccls[cclp];
        -: 2400:
    21822: 2401:		if ( NUL_mapping && cclm == 0 )
branch  0 taken 21466 (fallthrough)
branch  1 taken 356
branch  2 taken 4 (fallthrough)
branch  3 taken 21462
        4: 2402:			cclm = NUL_mapping;
        -: 2403:
    21822: 2404:		oldec = bck[cclm];
    21822: 2405:		newec = cclm;
        -: 2406:
    21822: 2407:		j = cclp + 1;
        -: 2408:
   798064: 2409:		for ( i = fwd[cclm]; i != NIL && i <= llsiz; i = fwd[i] )
branch  0 taken 776242 (fallthrough)
branch  1 taken 21822
branch  2 taken 776242
branch  3 taken 0 (fallthrough)
        -: 2410:			{ /* look for the symbol in the character class */
  1005291: 2411:			for ( ; j < lenccl; ++j )
branch  0 taken 561767
branch  1 taken 443524 (fallthrough)
        -: 2412:				{
        -: 2413:				register int ccl_char;
        -: 2414:
   561767: 2415:				if ( NUL_mapping && ccls[j] == 0 )
branch  0 taken 509277 (fallthrough)
branch  1 taken 52490
branch  2 taken 750 (fallthrough)
branch  3 taken 508527
      750: 2416:					ccl_char = NUL_mapping;
        -: 2417:				else
   561017: 2418:					ccl_char = ccls[j];
        -: 2419:
   561767: 2420:				if ( ccl_char > i )
branch  0 taken 107835 (fallthrough)
branch  1 taken 453932
   107835: 2421:					break;
        -: 2422:
   453932: 2423:				if ( ccl_char == i && ! cclflags[j] )
branch  0 taken 224883 (fallthrough)
branch  1 taken 229049
branch  2 taken 224883 (fallthrough)
branch  3 taken 0
        -: 2424:					{
        -: 2425:					/* We found an old companion of cclm
        -: 2426:					 * in the ccl.  Link it into the new
        -: 2427:					 * equivalence class and flag it as
        -: 2428:					 * having been processed.
        -: 2429:					 */
        -: 2430:
   224883: 2431:					bck[i] = newec;
   224883: 2432:					fwd[newec] = i;
   224883: 2433:					newec = i;
        -: 2434:					/* Set flag so we don't reprocess. */
   224883: 2435:					cclflags[j] = 1;
        -: 2436:
        -: 2437:					/* Get next equivalence class member. */
        -: 2438:					/* continue 2 */
   224883: 2439:					goto next_pt;
        -: 2440:					}
        -: 2441:				}
        -: 2442:
        -: 2443:			/* Symbol isn't in character class.  Put it in the old
        -: 2444:			 * equivalence class.
        -: 2445:			 */
        -: 2446:
   551359: 2447:			bck[i] = oldec;
        -: 2448:
   551359: 2449:			if ( oldec != NIL )
branch  0 taken 550723 (fallthrough)
branch  1 taken 636
   550723: 2450:				fwd[oldec] = i;
        -: 2451:
   551359: 2452:			oldec = i;
        -: 2453:
   776242: 2454:			next_pt: ;
        -: 2455:			}
        -: 2456:
    21822: 2457:		if ( bck[cclm] != NIL || oldec != bck[cclm] )
branch  0 taken 11739 (fallthrough)
branch  1 taken 10083
branch  2 taken 636 (fallthrough)
branch  3 taken 11103
        -: 2458:			{
    10719: 2459:			bck[cclm] = NIL;
    10719: 2460:			fwd[oldec] = NIL;
        -: 2461:			}
        -: 2462:
    21822: 2463:		fwd[newec] = NIL;
        -: 2464:
        -: 2465:		/* Find next ccl member to process. */
        -: 2466:
   246705: 2467:		for ( ++cclp; cclflags[cclp] && cclp < lenccl; ++cclp )
branch  0 taken 224883 (fallthrough)
branch  1 taken 21822
branch  2 taken 224883
branch  3 taken 0 (fallthrough)
        -: 2468:			{
        -: 2469:			/* Reset "doesn't need processing" flag. */
   224883: 2470:			cclflags[cclp] = 0;
        -: 2471:			}
        -: 2472:		}
    14421: 2473:	}
        -: 2474:
        -: 2475:
        -: 2476:/* mkechar - create equivalence class for single character */
        -: 2477:
function mkechar called 23834 returned 100% blocks executed 100%
    23834: 2478:void mkechar( tch, fwd, bck )
        -: 2479:int tch, fwd[], bck[];
        -: 2480:	{
        -: 2481:	/* If until now the character has been a proper subset of
        -: 2482:	 * an equivalence class, break it away to create a new ec
        -: 2483:	 */
        -: 2484:
    23834: 2485:	if ( fwd[tch] != NIL )
branch  0 taken 16676 (fallthrough)
branch  1 taken 7158
    16676: 2486:		bck[fwd[tch]] = bck[tch];
        -: 2487:
    23834: 2488:	if ( bck[tch] != NIL )
branch  0 taken 17714 (fallthrough)
branch  1 taken 6120
    17714: 2489:		fwd[bck[tch]] = fwd[tch];
        -: 2490:
    23834: 2491:	fwd[tch] = NIL;
    23834: 2492:	bck[tch] = NIL;
    23834: 2493:	}
        -: 2494:/* gen - actual generation (writing) of flex scanners */
        -: 2495:
        -: 2496:/*-
        -: 2497: * Copyright (c) 1990 The Regents of the University of California.
        -: 2498: * All rights reserved.
        -: 2499: *
        -: 2500: * This code is derived from software contributed to Berkeley by
        -: 2501: * Vern Paxson.
        -: 2502: * 
        -: 2503: * The United States Government has rights in this work pursuant
        -: 2504: * to contract no. DE-AC03-76SF00098 between the United States
        -: 2505: * Department of Energy and the University of California.
        -: 2506: *
        -: 2507: * Redistribution and use in source and binary forms are permitted provided
        -: 2508: * that: (1) source distributions retain this entire copyright notice and
        -: 2509: * comment, and (2) distributions including binaries display the following
        -: 2510: * acknowledgement:  ``This product includes software developed by the
        -: 2511: * University of California, Berkeley and its contributors'' in the
        -: 2512: * documentation or other materials provided with the distribution and in
        -: 2513: * all advertising materials mentioning features or use of this software.
        -: 2514: * Neither the name of the University nor the names of its contributors may
        -: 2515: * be used to endorse or promote products derived from this software without
        -: 2516: * specific prior written permission.
        -: 2517: * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
        -: 2518: * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
        -: 2519: * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
        -: 2520: */
        -: 2521:
        -: 2522:/* $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.seeded/v1/flex.c,v 1.1.1.2 2003/09/02 20:21:59 expsir Exp $ */
        -: 2523:
        -: 2524:
        -: 2525:
        -: 2526:/* declare functions that have forward references */
        -: 2527:
        -: 2528:void gen_next_state PROTO((int));
        -: 2529:void genecs PROTO((void));
        -: 2530:void indent_put2s PROTO((char [], char []));
        -: 2531:void indent_puts PROTO((char []));
        -: 2532:
        -: 2533:
        -: 2534:static int indent_level = 0; /* each level is 8 spaces */
        -: 2535:
        -: 2536:#define indent_up() (++indent_level)
        -: 2537:#define indent_down() (--indent_level)
        -: 2538:#define set_indent(indent_val) indent_level = indent_val
        -: 2539:
        -: 2540:/* Almost everything is done in terms of arrays starting at 1, so provide
        -: 2541: * a null entry for the zero element of all C arrays.  (The exception
        -: 2542: * to this is that the fast table representation generally uses the
        -: 2543: * 0 elements of its arrays, too.)
        -: 2544: */
        -: 2545:static char C_int_decl[] = "static const int %s[%d] =\n    {   0,\n";
        -: 2546:static char C_short_decl[] = "static const short int %s[%d] =\n    {   0,\n";
        -: 2547:static char C_long_decl[] = "static const long int %s[%d] =\n    {   0,\n";
        -: 2548:static char C_state_decl[] =
        -: 2549:	"static const yy_state_type %s[%d] =\n    {   0,\n";
        -: 2550:
        -: 2551:
        -: 2552:/* Indent to the current level. */
        -: 2553:
function do_indent called 40414 returned 100% blocks executed 78%
    40414: 2554:void do_indent()
        -: 2555:	{
    40414: 2556:	register int i = indent_level * 8;
        -: 2557:
   145436: 2558:	while ( i >= 8 )
branch  0 taken 105022
branch  1 taken 40414 (fallthrough)
        -: 2559:		{
   105022: 2560:		putchar( '\t' );
call    0 returned 105022
   105022: 2561:		i -= 8;
        -: 2562:		}
        -: 2563:
    40414: 2564:	while ( i > 0 )
branch  0 taken 0
branch  1 taken 40414 (fallthrough)
        -: 2565:		{
    #####: 2566:		putchar( ' ' );
call    0 never executed
    #####: 2567:		--i;
        -: 2568:		}
    40414: 2569:	}
        -: 2570:
        -: 2571:
        -: 2572:/* Generate the code to keep backing-up information. */
        -: 2573:
function gen_backing_up called 1625 returned 100% blocks executed 100%
     1625: 2574:void gen_backing_up()
        -: 2575:	{
     1625: 2576:	if ( reject || num_backing_up == 0 )
branch  0 taken 1118 (fallthrough)
branch  1 taken 507
branch  2 taken 2 (fallthrough)
branch  3 taken 1116
      509: 2577:		return;
        -: 2578:
     1116: 2579:	if ( fullspd )
branch  0 taken 276 (fallthrough)
branch  1 taken 840
      276: 2580:		indent_puts( "if ( yy_current_state[-1].yy_nxt )" );
call    0 returned 276
        -: 2581:	else
      840: 2582:		indent_puts( "if ( yy_accept[yy_current_state] )" );
call    0 returned 840
        -: 2583:
     1116: 2584:	indent_up();
     1116: 2585:	indent_puts( "{" );
call    0 returned 1116
     1116: 2586:	indent_puts( "yy_last_accepting_state = yy_current_state;" );
call    0 returned 1116
     1116: 2587:	indent_puts( "yy_last_accepting_cpos = yy_cp;" );
call    0 returned 1116
     1116: 2588:	indent_puts( "}" );
call    0 returned 1116
     1116: 2589:	indent_down();
        -: 2590:	}
        -: 2591:
        -: 2592:
        -: 2593:/* Generate the code to perform the backing up. */
        -: 2594:
function gen_bu_action called 543 returned 100% blocks executed 100%
      543: 2595:void gen_bu_action()
        -: 2596:	{
      543: 2597:	if ( reject || num_backing_up == 0 )
branch  0 taken 374 (fallthrough)
branch  1 taken 169
branch  2 taken 2 (fallthrough)
branch  3 taken 372
      171: 2598:		return;
        -: 2599:
      372: 2600:	set_indent( 3 );
        -: 2601:
      372: 2602:	indent_puts( "case 0: /* must back up */" );
call    0 returned 372
      372: 2603:	indent_puts( "/* undo the effects of YY_DO_BEFORE_ACTION */" );
call    0 returned 372
      372: 2604:	indent_puts( "*yy_cp = yy_hold_char;" );
call    0 returned 372
        -: 2605:
      372: 2606:	if ( fullspd || fulltbl )
branch  0 taken 280 (fallthrough)
branch  1 taken 92
branch  2 taken 21 (fallthrough)
branch  3 taken 259
      113: 2607:		indent_puts( "yy_cp = yy_last_accepting_cpos + 1;" );
call    0 returned 113
        -: 2608:	else
        -: 2609:		/* Backing-up info for compressed tables is taken \after/
        -: 2610:		 * yy_cp has been incremented for the next state.
        -: 2611:		 */
      259: 2612:		indent_puts( "yy_cp = yy_last_accepting_cpos;" );
call    0 returned 259
        -: 2613:
      372: 2614:	indent_puts( "yy_current_state = yy_last_accepting_state;" );
call    0 returned 372
      372: 2615:	indent_puts( "goto yy_find_action;" );
call    0 returned 372
      372: 2616:	putchar( '\n' );
call    0 returned 372
        -: 2617:
      372: 2618:	set_indent( 0 );
        -: 2619:	}
        -: 2620:
        -: 2621:
        -: 2622:/* genctbl - generates full speed compressed transition table */
        -: 2623:
function genctbl called 92 returned 100% blocks executed 94%
       92: 2624:void genctbl()
        -: 2625:	{
        -: 2626:	register int i;
       92: 2627:	int end_of_buffer_action = num_rules + 1;
        -: 2628:
        -: 2629:	/* Table of verify for transition and offset to next state. */
       92: 2630:	printf( "static const struct yy_trans_info yy_transition[%d] =\n",
       92: 2631:		tblend + numecs + 1 );
call    0 returned 92
       92: 2632:	printf( "    {\n" );
call    0 returned 92
        -: 2633:
        -: 2634:	/* We want the transition to be represented as the offset to the
        -: 2635:	 * next state, not the actual state number, which is what it currently
        -: 2636:	 * is.  The offset is base[nxt[i]] - (base of current state)].  That's
        -: 2637:	 * just the difference between the starting points of the two involved
        -: 2638:	 * states (to - from).
        -: 2639:	 *
        -: 2640:	 * First, though, we need to find some way to put in our end-of-buffer
        -: 2641:	 * flags and states.  We do this by making a state with absolutely no
        -: 2642:	 * transitions.  We put it at the end of the table.
        -: 2643:	 */
        -: 2644:
        -: 2645:	/* We need to have room in nxt/chk for two more slots: One for the
        -: 2646:	 * action and one for the end-of-buffer transition.  We now *assume*
        -: 2647:	 * that we're guaranteed the only character we'll try to index this
        -: 2648:	 * nxt/chk pair with is EOB, i.e., 0, so we don't have to make sure
        -: 2649:	 * there's room for jam entries for other characters.
        -: 2650:	 */
        -: 2651:
       92: 2652:	while ( tblend + 2 >= current_max_xpairs )
branch  0 taken 0
branch  1 taken 92 (fallthrough)
    #####: 2653:		expand_nxt_chk();
call    0 never executed
        -: 2654:
       92: 2655:	while ( lastdfa + 1 >= current_max_dfas )
branch  0 taken 0
branch  1 taken 92 (fallthrough)
    #####: 2656:		increase_max_dfas();
call    0 never executed
        -: 2657:
       92: 2658:	base[lastdfa + 1] = tblend + 2;
       92: 2659:	nxt[tblend + 1] = end_of_buffer_action;
       92: 2660:	chk[tblend + 1] = numecs + 1;
       92: 2661:	chk[tblend + 2] = 1; /* anything but EOB */
        -: 2662:
        -: 2663:	/* So that "make test" won't show arb. differences. */
       92: 2664:	nxt[tblend + 2] = 0;
        -: 2665:
        -: 2666:	/* Make sure every state has an end-of-buffer transition and an
        -: 2667:	 * action #.
        -: 2668:	 */
     2354: 2669:	for ( i = 0; i <= lastdfa; ++i )
branch  0 taken 2262
branch  1 taken 92 (fallthrough)
        -: 2670:		{
     2262: 2671:		int anum = dfaacc[i].dfaacc_state;
        -: 2672:#ifndef	F_HD_3
     2262: 2673:		int offset = base[i];
        -: 2674:#else
        -: 2675:		int offset = base[i+1]; 
        -: 2676:#endif
        -: 2677:
        -: 2678:#ifndef F_AA_2
     2262: 2679:		chk[offset] = EOB_POSITION;
        -: 2680:#else
        -: 2681:		chk[offset - 1] = EOB_POSITION;
        -: 2682:#endif
     2262: 2683:		chk[offset - 1] = ACTION_POSITION;
     2262: 2684:		nxt[offset - 1] = anum;	/* action number */
        -: 2685:		}
        -: 2686:
    55605: 2687:	for ( i = 0; i <= tblend; ++i )
branch  0 taken 55513
branch  1 taken 92 (fallthrough)
        -: 2688:		{
    55513: 2689:		if ( chk[i] == EOB_POSITION )
branch  0 taken 2262 (fallthrough)
branch  1 taken 53251
     2262: 2690:			transition_struct_out( 0, base[lastdfa + 1] - i );
call    0 returned 2262
        -: 2691:
    53251: 2692:		else if ( chk[i] == ACTION_POSITION )
branch  0 taken 2262 (fallthrough)
branch  1 taken 50989
     2262: 2693:			transition_struct_out( 0, nxt[i] );
call    0 returned 2262
        -: 2694:
    50989: 2695:		else if ( chk[i] > numecs || chk[i] == 0 )
branch  0 taken 50989 (fallthrough)
branch  1 taken 0
branch  2 taken 18266 (fallthrough)
branch  3 taken 32723
    18266: 2696:			transition_struct_out( 0, 0 );	/* unused slot */
call    0 returned 18266
        -: 2697:
        -: 2698:		else	/* verify, transition */
    32723: 2699:			transition_struct_out( chk[i],
    32723: 2700:						base[nxt[i]] - (i - chk[i]) );
call    0 returned 32723
        -: 2701:		}
        -: 2702:
        -: 2703:
        -: 2704:	/* Here's the final, end-of-buffer state. */
       92: 2705:	transition_struct_out( chk[tblend + 1], nxt[tblend + 1] );
call    0 returned 92
       92: 2706:	transition_struct_out( chk[tblend + 2], nxt[tblend + 2] );
call    0 returned 92
        -: 2707:
       92: 2708:	printf( "    };\n" );
call    0 returned 92
       92: 2709:	printf( "\n" );
call    0 returned 92
        -: 2710:
        -: 2711:	/* Table of pointers to start states. */
       92: 2712:	printf(
        -: 2713:	"static const struct yy_trans_info *yy_start_state_list[%d] =\n",
       92: 2714:		lastsc * 2 + 1 );
call    0 returned 92
       92: 2715:	printf( "    {\n" );	/* } so vi doesn't get confused */
call    0 returned 92
        -: 2716:
      368: 2717:	for ( i = 0; i <= lastsc * 2; ++i )
branch  0 taken 276
branch  1 taken 92 (fallthrough)
      276: 2718:		printf( "    &yy_transition[%d],\n", base[i] );
call    0 returned 276
        -: 2719:
       92: 2720:	dataend();
call    0 returned 92
        -: 2721:
       92: 2722:	if ( useecs )
branch  0 taken 40 (fallthrough)
branch  1 taken 52
       40: 2723:		genecs();
call    0 returned 40
       92: 2724:	}
        -: 2725:
        -: 2726:
        -: 2727:/* Generate equivalence-class tables. */
        -: 2728:
function genecs called 295 returned 100% blocks executed 100%
      295: 2729:void genecs()
        -: 2730:	{
        -: 2731:	Char clower();
        -: 2732:	register int i, j;
        -: 2733:	int numrows;
        -: 2734:
      295: 2735:	printf( C_int_decl, "yy_ec", csize );
call    0 returned 295
        -: 2736:
    75264: 2737:	for ( i = 1; i < csize; ++i )
branch  0 taken 74969
branch  1 taken 295 (fallthrough)
        -: 2738:		{
    74969: 2739:		if ( caseins && (i >= 'A') && (i <= 'Z') )
branch  0 taken 637 (fallthrough)
branch  1 taken 74332
branch  2 taken 445 (fallthrough)
branch  3 taken 192
branch  4 taken 78 (fallthrough)
branch  5 taken 367
       78: 2740:			ecgroup[i] = ecgroup[clower( i )];
call    0 returned 78
        -: 2741:
    74969: 2742:		ecgroup[i] = ABS( ecgroup[i] );
    74969: 2743:		mkdata( ecgroup[i] );
call    0 returned 74969
        -: 2744:		}
        -: 2745:
      295: 2746:	dataend();
call    0 returned 295
        -: 2747:
      295: 2748:	if ( trace )
branch  0 taken 14 (fallthrough)
branch  1 taken 281
        -: 2749:		{
       14: 2750:		fputs( "\n\nEquivalence Classes:\n\n", err );
call    0 returned 14
        -: 2751:
       14: 2752:		numrows = csize / 8;
        -: 2753:
      446: 2754:		for ( j = 0; j < numrows; ++j )
branch  0 taken 432
branch  1 taken 14 (fallthrough)
        -: 2755:			{
     3888: 2756:			for ( i = j; i < csize; i = i + numrows )
branch  0 taken 3456
branch  1 taken 432 (fallthrough)
        -: 2757:				{
     3456: 2758:				fprintf( err, "%4s = %-2d",
call    0 returned 3456
call    1 returned 3456
        -: 2759:					readable_form( i ), ecgroup[i] );
        -: 2760:
     3456: 2761:				putc( ' ', err );
call    0 returned 3456
        -: 2762:				}
        -: 2763:
      432: 2764:			putc( '\n', err );
call    0 returned 432
        -: 2765:			}
        -: 2766:		}
      295: 2767:	}
        -: 2768:
        -: 2769:
        -: 2770:/* Generate the code to find the action number. */
        -: 2771:
function gen_find_action called 543 returned 100% blocks executed 100%
      543: 2772:void gen_find_action()
        -: 2773:	{
      543: 2774:	if ( fullspd )
branch  0 taken 92 (fallthrough)
branch  1 taken 451
       92: 2775:		indent_puts( "yy_act = yy_current_state[-1].yy_nxt;" );
call    0 returned 92
        -: 2776:
      451: 2777:	else if ( fulltbl )
branch  0 taken 23 (fallthrough)
branch  1 taken 428
       23: 2778:		indent_puts( "yy_act = yy_accept[yy_current_state];" );
call    0 returned 23
        -: 2779:
      428: 2780:	else if ( reject )
branch  0 taken 169 (fallthrough)
branch  1 taken 259
        -: 2781:		{
      169: 2782:		indent_puts( "yy_current_state = *--yy_state_ptr;" );
call    0 returned 169
      169: 2783:		indent_puts( "yy_lp = yy_accept[yy_current_state];" );
call    0 returned 169
        -: 2784:
      169: 2785:		puts(
call    0 returned 169
        -: 2786:		"find_rule: /* we branch to this label when backing up */" );
        -: 2787:
      169: 2788:		indent_puts(
call    0 returned 169
        -: 2789:		"for ( ; ; ) /* until we find what rule we matched */" );
        -: 2790:
      169: 2791:		indent_up();
        -: 2792:
      169: 2793:		indent_puts( "{" );
call    0 returned 169
        -: 2794:
      169: 2795:		indent_puts(
call    0 returned 169
        -: 2796:		"if ( yy_lp && yy_lp < yy_accept[yy_current_state + 1] )" );
      169: 2797:		indent_up();
      169: 2798:		indent_puts( "{" );
call    0 returned 169
      169: 2799:		indent_puts( "yy_act = yy_acclist[yy_lp];" );
call    0 returned 169
        -: 2800:
      169: 2801:		if ( variable_trailing_context_rules )
branch  0 taken 33 (fallthrough)
branch  1 taken 136
        -: 2802:			{
       33: 2803:			indent_puts( "if ( yy_act & YY_TRAILING_HEAD_MASK ||" );
call    0 returned 33
       33: 2804:			indent_puts( "     yy_looking_for_trail_begin )" );
call    0 returned 33
       33: 2805:			indent_up();
       33: 2806:			indent_puts( "{" );
call    0 returned 33
        -: 2807:
       33: 2808:			indent_puts(
call    0 returned 33
        -: 2809:				"if ( yy_act == yy_looking_for_trail_begin )" );
       33: 2810:			indent_up();
       33: 2811:			indent_puts( "{" );
call    0 returned 33
       33: 2812:			indent_puts( "yy_looking_for_trail_begin = 0;" );
call    0 returned 33
       33: 2813:			indent_puts( "yy_act &= ~YY_TRAILING_HEAD_MASK;" );
call    0 returned 33
       33: 2814:			indent_puts( "break;" );
call    0 returned 33
       33: 2815:			indent_puts( "}" );
call    0 returned 33
       33: 2816:			indent_down();
        -: 2817:
       33: 2818:			indent_puts( "}" );
call    0 returned 33
       33: 2819:			indent_down();
        -: 2820:
       33: 2821:			indent_puts( "else if ( yy_act & YY_TRAILING_MASK )" );
call    0 returned 33
       33: 2822:			indent_up();
       33: 2823:			indent_puts( "{" );
call    0 returned 33
       33: 2824:			indent_puts(
call    0 returned 33
        -: 2825:		"yy_looking_for_trail_begin = yy_act & ~YY_TRAILING_MASK;" );
       33: 2826:			indent_puts(
call    0 returned 33
        -: 2827:		"yy_looking_for_trail_begin |= YY_TRAILING_HEAD_MASK;" );
        -: 2828:
       33: 2829:			if ( real_reject )
branch  0 taken 31 (fallthrough)
branch  1 taken 2
        -: 2830:				{
        -: 2831:				/* Remember matched text in case we back up
        -: 2832:				 * due to REJECT.
        -: 2833:				 */
       31: 2834:				indent_puts( "yy_full_match = yy_cp;" );
call    0 returned 31
       31: 2835:				indent_puts( "yy_full_state = yy_state_ptr;" );
call    0 returned 31
       31: 2836:				indent_puts( "yy_full_lp = yy_lp;" );
call    0 returned 31
        -: 2837:				}
        -: 2838:
       33: 2839:			indent_puts( "}" );
call    0 returned 33
       33: 2840:			indent_down();
        -: 2841:
       33: 2842:			indent_puts( "else" );
call    0 returned 33
       33: 2843:			indent_up();
       33: 2844:			indent_puts( "{" );
call    0 returned 33
       33: 2845:			indent_puts( "yy_full_match = yy_cp;" );
call    0 returned 33
       33: 2846:			indent_puts( "yy_full_state = yy_state_ptr;" );
call    0 returned 33
       33: 2847:			indent_puts( "yy_full_lp = yy_lp;" );
call    0 returned 33
       33: 2848:			indent_puts( "break;" );
call    0 returned 33
       33: 2849:			indent_puts( "}" );
call    0 returned 33
       33: 2850:			indent_down();
        -: 2851:
       33: 2852:			indent_puts( "++yy_lp;" );
call    0 returned 33
       33: 2853:			indent_puts( "goto find_rule;" );
call    0 returned 33
        -: 2854:			}
        -: 2855:
        -: 2856:		else
        -: 2857:		{
        -: 2858:		/* Remember matched text in case we back up due to trailing
        -: 2859:		 * context plus REJECT.
        -: 2860:		 */
      136: 2861:		indent_up();
      136: 2862:		indent_puts( "{" );
call    0 returned 136
      136: 2863:		indent_puts( "yy_full_match = yy_cp;" );
call    0 returned 136
      136: 2864:		indent_puts( "break;" );
call    0 returned 136
      136: 2865:		indent_puts( "}" );
call    0 returned 136
      136: 2866:		indent_down();
        -: 2867:		}
        -: 2868:
      169: 2869:		indent_puts( "}" );
call    0 returned 169
      169: 2870:		indent_down();
        -: 2871:
      169: 2872:		indent_puts( "--yy_cp;" );
call    0 returned 169
        -: 2873:
        -: 2874:		/* We could consolidate the following two lines with those at
        -: 2875:		 * the beginning, but at the cost of complaints that we're
        -: 2876:		 * branching inside a loop.
        -: 2877:		 */
      169: 2878:		indent_puts( "yy_current_state = *--yy_state_ptr;" );
call    0 returned 169
      169: 2879:		indent_puts( "yy_lp = yy_accept[yy_current_state];" );
call    0 returned 169
        -: 2880:
      169: 2881:		indent_puts( "}" );
call    0 returned 169
        -: 2882:
      169: 2883:		indent_down();
        -: 2884:		}
        -: 2885:
        -: 2886:	else
        -: 2887:		/* compressed */
      259: 2888:		indent_puts( "yy_act = yy_accept[yy_current_state];" );
call    0 returned 259
      543: 2889:	}
        -: 2890:
        -: 2891:
        -: 2892:/* genftbl - generates full transition table */
        -: 2893:
function genftbl called 23 returned 100% blocks executed 93%
       23: 2894:void genftbl()
        -: 2895:	{
        -: 2896:	register int i;
       23: 2897:	int end_of_buffer_action = num_rules + 1;
        -: 2898:
      23*: 2899:	printf( long_align ? C_long_decl : C_short_decl,
branch  0 taken 0 (fallthrough)
branch  1 taken 23
call    2 returned 23
        -: 2900:		"yy_accept", lastdfa + 1 );
        -: 2901:
       23: 2902:	dfaacc[end_of_buffer_state].dfaacc_state = end_of_buffer_action;
        -: 2903:
      565: 2904:	for ( i = 1; i <= lastdfa; ++i )
branch  0 taken 542
branch  1 taken 23 (fallthrough)
        -: 2905:		{
      542: 2906:		register int anum = dfaacc[i].dfaacc_state;
        -: 2907:
      542: 2908:		mkdata( anum );
call    0 returned 542
        -: 2909:
      542: 2910:		if ( trace && anum )
branch  0 taken 18 (fallthrough)
branch  1 taken 524
branch  2 taken 16 (fallthrough)
branch  3 taken 2
       16: 2911:			fprintf( err, "state # %d accepts: [%d]\n",
call    0 returned 16
        -: 2912:				i, anum );
        -: 2913:		}
        -: 2914:
       23: 2915:	dataend();
call    0 returned 23
        -: 2916:
       23: 2917:	if ( useecs )
branch  0 taken 1 (fallthrough)
branch  1 taken 22
        1: 2918:		genecs();
call    0 returned 1
        -: 2919:
        -: 2920:	/* Don't have to dump the actual full table entries - they were
        -: 2921:	 * created on-the-fly.
        -: 2922:	 */
       23: 2923:	}
        -: 2924:
        -: 2925:
        -: 2926:/* Generate the code to find the next compressed-table state. */
        -: 2927:
function gen_next_compressed_state called 1110 returned 100% blocks executed 100%
     1110: 2928:void gen_next_compressed_state( char_map )
        -: 2929:char *char_map;
        -: 2930:	{
     1110: 2931:	indent_put2s( "register YY_CHAR yy_c = %s;", char_map );
call    0 returned 1110
        -: 2932:
        -: 2933:	/* Save the backing-up info \before/ computing the next state
        -: 2934:	 * because we always compute one more state than needed - we
        -: 2935:	 * always proceed until we reach a jam state
        -: 2936:	 */
     1110: 2937:	gen_backing_up();
call    0 returned 1110
        -: 2938:
     1110: 2939:	indent_puts(
call    0 returned 1110
        -: 2940:"while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )" );
     1110: 2941:	indent_up();
     1110: 2942:	indent_puts( "{" );
call    0 returned 1110
     1110: 2943:	indent_puts( "yy_current_state = (int) yy_def[yy_current_state];" );
call    0 returned 1110
        -: 2944:
     1110: 2945:	if ( usemecs )
branch  0 taken 562 (fallthrough)
branch  1 taken 548
        -: 2946:		{
        -: 2947:		/* We've arrange it so that templates are never chained
        -: 2948:		 * to one another.  This means we can afford to make a
        -: 2949:		 * very simple test to see if we need to convert to
        -: 2950:		 * yy_c's meta-equivalence class without worrying
        -: 2951:		 * about erroneously looking up the meta-equivalence
        -: 2952:		 * class twice
        -: 2953:		 */
      562: 2954:		do_indent();
call    0 returned 562
        -: 2955:
        -: 2956:		/* lastdfa + 2 is the beginning of the templates */
      562: 2957:		printf( "if ( yy_current_state >= %d )\n", lastdfa + 2 );
call    0 returned 562
        -: 2958:
      562: 2959:		indent_up();
      562: 2960:		indent_puts( "yy_c = yy_meta[(unsigned int) yy_c];" );
call    0 returned 562
      562: 2961:		indent_down();
        -: 2962:		}
        -: 2963:
     1110: 2964:	indent_puts( "}" );
call    0 returned 1110
     1110: 2965:	indent_down();
        -: 2966:
     1110: 2967:	indent_puts(
call    0 returned 1110
        -: 2968:"yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];" );
     1110: 2969:	}
        -: 2970:
        -: 2971:
        -: 2972:/* Generate the code to find the next match. */
        -: 2973:
function gen_next_match called 543 returned 100% blocks executed 100%
      543: 2974:void gen_next_match()
        -: 2975:	{
        -: 2976:	/* NOTE - changes in here should be reflected in gen_next_state() and
        -: 2977:	 * gen_NUL_trans().
        -: 2978:	 */
        -: 2979:
     1086: 2980:	char *char_map = useecs ?
      543: 2981:				"yy_ec[YY_SC_TO_UI(*yy_cp)]" :
branch  0 taken 295 (fallthrough)
branch  1 taken 248
        -: 2982:#ifndef	F_HD_4
        -: 2983:				"YY_SC_TO_UI(*yy_cp)";
        -: 2984:#else
        -: 2985:				"";
        -: 2986:#endif
        -: 2987:
     1086: 2988:	char *char_map_2 = useecs ?
      543: 2989:				"yy_ec[YY_SC_TO_UI(*++yy_cp)]" :
branch  0 taken 295 (fallthrough)
branch  1 taken 248
        -: 2990:				"YY_SC_TO_UI(*++yy_cp)";
      543: 2991:	if ( fulltbl )
branch  0 taken 23 (fallthrough)
branch  1 taken 520
        -: 2992:		{
       23: 2993:		indent_put2s(
call    0 returned 23
        -: 2994:	"while ( (yy_current_state = yy_nxt[yy_current_state][%s]) > 0 )",
        -: 2995:				char_map );
        -: 2996:
       23: 2997:		indent_up();
        -: 2998:
       23: 2999:		if ( num_backing_up > 0 )
branch  0 taken 21 (fallthrough)
branch  1 taken 2
        -: 3000:			{
       21: 3001:			indent_puts( "{" );	/* } for vi */
call    0 returned 21
       21: 3002:			gen_backing_up();
call    0 returned 21
       21: 3003:			putchar( '\n' );
call    0 returned 21
        -: 3004:			}
        -: 3005:
       23: 3006:		indent_puts( "++yy_cp;" );
call    0 returned 23
        -: 3007:
       23: 3008:		if ( num_backing_up > 0 )
branch  0 taken 21 (fallthrough)
branch  1 taken 2
        -: 3009:			/* { for vi */
       21: 3010:			indent_puts( "}" );
call    0 returned 21
        -: 3011:
       23: 3012:		indent_down();
        -: 3013:
       23: 3014:		putchar( '\n' );
call    0 returned 23
       23: 3015:		indent_puts( "yy_current_state = -yy_current_state;" );
call    0 returned 23
        -: 3016:		}
        -: 3017:
      520: 3018:	else if ( fullspd )
branch  0 taken 92 (fallthrough)
branch  1 taken 428
        -: 3019:		{
       92: 3020:		indent_puts( "{" );	/* } for vi */
call    0 returned 92
       92: 3021:		indent_puts(
call    0 returned 92
        -: 3022:		"register const struct yy_trans_info *yy_trans_info;\n" );
       92: 3023:		indent_puts( "register YY_CHAR yy_c;\n" );
call    0 returned 92
       92: 3024:		indent_put2s( "for ( yy_c = %s;", char_map );
call    0 returned 92
       92: 3025:		indent_puts(
call    0 returned 92
        -: 3026:	"      (yy_trans_info = &yy_current_state[(unsigned int) yy_c])->" );
       92: 3027:		indent_puts( "yy_verify == yy_c;" );
call    0 returned 92
       92: 3028:		indent_put2s( "      yy_c = %s )", char_map_2 );
call    0 returned 92
        -: 3029:
       92: 3030:		indent_up();
        -: 3031:
       92: 3032:		if ( num_backing_up > 0 )
branch  0 taken 92 (fallthrough)
branch  1 taken 0
       92: 3033:			indent_puts( "{" );	/* } for vi */
call    0 returned 92
        -: 3034:
       92: 3035:		indent_puts( "yy_current_state += yy_trans_info->yy_nxt;" );
call    0 returned 92
        -: 3036:
       92: 3037:		if ( num_backing_up > 0 )
branch  0 taken 92 (fallthrough)
branch  1 taken 0
        -: 3038:			{
       92: 3039:			putchar( '\n' );
call    0 returned 92
       92: 3040:			gen_backing_up();	/* { for vi */
call    0 returned 92
       92: 3041:			indent_puts( "}" );
call    0 returned 92
        -: 3042:			}
        -: 3043:
       92: 3044:		indent_down();	/* { for vi */
       92: 3045:		indent_puts( "}" );
call    0 returned 92
        -: 3046:		}
        -: 3047:
        -: 3048:	else
        -: 3049:		{ /* compressed */
      428: 3050:		indent_puts( "do" );
call    0 returned 428
        -: 3051:
      428: 3052:		indent_up();
      428: 3053:		indent_puts( "{" );	/* } for vi */
call    0 returned 428
        -: 3054:
      428: 3055:		gen_next_state( false );
call    0 returned 428
        -: 3056:
      428: 3057:		indent_puts( "++yy_cp;" );
call    0 returned 428
        -: 3058:
        -: 3059:		/* { for vi */
      428: 3060:		indent_puts( "}" );
call    0 returned 428
      428: 3061:		indent_down();
        -: 3062:
      428: 3063:		do_indent();
call    0 returned 428
        -: 3064:
      428: 3065:		if ( interactive )
branch  0 taken 426 (fallthrough)
branch  1 taken 2
      426: 3066:			printf( "while ( yy_base[yy_current_state] != %d );\n",
call    0 returned 426
        -: 3067:				jambase );
        -: 3068:		else
        2: 3069:			printf( "while ( yy_current_state != %d );\n",
call    0 returned 2
        -: 3070:				jamstate );
        -: 3071:
      428: 3072:		if ( ! reject && ! interactive )
branch  0 taken 259 (fallthrough)
branch  1 taken 169
branch  2 taken 1 (fallthrough)
branch  3 taken 258
        -: 3073:			{
        -: 3074:			/* Do the guaranteed-needed backing up to figure out
        -: 3075:			 * the match.
        -: 3076:			 */
        1: 3077:			indent_puts( "yy_cp = yy_last_accepting_cpos;" );
call    0 returned 1
        1: 3078:			indent_puts(
call    0 returned 1
        -: 3079:				"yy_current_state = yy_last_accepting_state;" );
        -: 3080:			}
        -: 3081:		}
      543: 3082:	}
        -: 3083:
        -: 3084:
        -: 3085:/* Generate the code to find the next state. */
        -: 3086:
function gen_next_state called 971 returned 100% blocks executed 100%
      971: 3087:void gen_next_state( worry_about_NULs )
        -: 3088:int worry_about_NULs;
        -: 3089:	{ /* NOTE - changes in here should be reflected in get_next_match() */
        -: 3090:	char char_map[256];
        -: 3091:
      971: 3092:	if ( worry_about_NULs && ! nultrans )
branch  0 taken 543 (fallthrough)
branch  1 taken 428
branch  2 taken 347 (fallthrough)
branch  3 taken 196
        -: 3093:#ifndef F_JR_6
        -: 3094:		{
      347: 3095:		if ( useecs )
branch  0 taken 295 (fallthrough)
branch  1 taken 52
      295: 3096:			(void) sprintf( char_map,
        -: 3097:				"(*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : %d)",
        -: 3098:					NUL_ec );
        -: 3099:		else
       52: 3100:			(void) sprintf( char_map,
        -: 3101:				"(*yy_cp ? YY_SC_TO_UI(*yy_cp) : %d)", NUL_ec );
        -: 3102:		}
        -: 3103:#else
        -: 3104:        {
        -: 3105:        if ( useecs )
        -: 3106:            (void) sprintf( char_map,
        -: 3107:                "(yy_cp ? yy_ec[YY_SC_TO_UI(yy_cp)] : %d)",
        -: 3108:                    NUL_ec );
        -: 3109:        else
        -: 3110:            (void) sprintf( char_map,
        -: 3111:                "(yy_cp ? YY_SC_TO_UI(yy_cp) : %d)", NUL_ec );
        -: 3112:        }
        -: 3113:
        -: 3114:#endif
        -: 3115:
        -: 3116:	else
      624: 3117:		strcpy( char_map, useecs ? "yy_ec[YY_SC_TO_UI(*yy_cp)]" :
branch  0 taken 254 (fallthrough)
branch  1 taken 370
        -: 3118:					   "YY_SC_TO_UI(*yy_cp)" );
        -: 3119:
      971: 3120:	if ( worry_about_NULs && nultrans )
branch  0 taken 543 (fallthrough)
branch  1 taken 428
branch  2 taken 196 (fallthrough)
branch  3 taken 347
        -: 3121:		{
      196: 3122:		if ( ! fulltbl && ! fullspd )
branch  0 taken 174 (fallthrough)
branch  1 taken 22
branch  2 taken 174 (fallthrough)
branch  3 taken 0
        -: 3123:			/* Compressed tables back up *before* they match. */
      174: 3124:			gen_backing_up();
call    0 returned 174
        -: 3125:
      196: 3126:		indent_puts( "if ( *yy_cp )" );
call    0 returned 196
      196: 3127:		indent_up();
      196: 3128:		indent_puts( "{" );	/* } for vi */
call    0 returned 196
        -: 3129:		}
        -: 3130:
      971: 3131:	if ( fulltbl )
branch  0 taken 23 (fallthrough)
branch  1 taken 948
       23: 3132:		indent_put2s(
call    0 returned 23
        -: 3133:			"yy_current_state = yy_nxt[yy_current_state][%s];", 
        -: 3134:				char_map );
        -: 3135:
      948: 3136:	else if ( fullspd )
branch  0 taken 92 (fallthrough)
branch  1 taken 856
       92: 3137:		indent_put2s(
call    0 returned 92
        -: 3138:			"yy_current_state += yy_current_state[%s].yy_nxt;",
        -: 3139:				char_map );
        -: 3140:
        -: 3141:	else
      856: 3142:		gen_next_compressed_state( char_map );
call    0 returned 856
        -: 3143:
      971: 3144:	if ( worry_about_NULs && nultrans )
branch  0 taken 543 (fallthrough)
branch  1 taken 428
branch  2 taken 196 (fallthrough)
branch  3 taken 347
        -: 3145:		{
        -: 3146:		/* { for vi */
      196: 3147:		indent_puts( "}" );
call    0 returned 196
      196: 3148:		indent_down();
      196: 3149:		indent_puts( "else" );
call    0 returned 196
      196: 3150:		indent_up();
      196: 3151:		indent_puts(
call    0 returned 196
        -: 3152:			"yy_current_state = yy_NUL_trans[yy_current_state];" );
      196: 3153:		indent_down();
        -: 3154:		}
        -: 3155:
      971: 3156:	if ( fullspd || fulltbl )
branch  0 taken 879 (fallthrough)
branch  1 taken 92
branch  2 taken 23 (fallthrough)
branch  3 taken 856
      115: 3157:		gen_backing_up();
call    0 returned 115
        -: 3158:
      971: 3159:	if ( reject )
branch  0 taken 338 (fallthrough)
branch  1 taken 633
      338: 3160:		indent_puts( "*yy_state_ptr++ = yy_current_state;" );
call    0 returned 338
      971: 3161:	}
        -: 3162:
        -: 3163:
        -: 3164:/* Generate the code to make a NUL transition. */
        -: 3165:
function gen_NUL_trans called 543 returned 100% blocks executed 100%
      543: 3166:void gen_NUL_trans()
        -: 3167:	{ /* NOTE - changes in here should be reflected in get_next_match() */
      543: 3168:	int need_backing_up = (num_backing_up > 0 && ! reject);
branch  0 taken 541 (fallthrough)
branch  1 taken 2
branch  2 taken 372 (fallthrough)
branch  3 taken 169
        -: 3169:
      543: 3170:	if ( need_backing_up )
branch  0 taken 372 (fallthrough)
branch  1 taken 171
        -: 3171:		/* We'll need yy_cp lying around for the gen_backing_up(). */
      372: 3172:		indent_puts( "register char *yy_cp = yy_c_buf_p;" );
call    0 returned 372
        -: 3173:
      543: 3174:	putchar( '\n' );
call    0 returned 543
        -: 3175:
      543: 3176:	if ( nultrans )
branch  0 taken 196 (fallthrough)
branch  1 taken 347
        -: 3177:		{
      196: 3178:		indent_puts(
call    0 returned 196
        -: 3179:			"yy_current_state = yy_NUL_trans[yy_current_state];" );
      196: 3180:		indent_puts( "yy_is_jam = (yy_current_state == 0);" );
call    0 returned 196
        -: 3181:		}
        -: 3182:
      347: 3183:	else if ( fulltbl )
branch  0 taken 1 (fallthrough)
branch  1 taken 346
        -: 3184:		{
        1: 3185:		do_indent();
call    0 returned 1
        1: 3186:		printf( "yy_current_state = yy_nxt[yy_current_state][%d];\n",
call    0 returned 1
        -: 3187:			NUL_ec );
        1: 3188:		indent_puts( "yy_is_jam = (yy_current_state <= 0);" );
call    0 returned 1
        -: 3189:		}
        -: 3190:
      346: 3191:	else if ( fullspd )
branch  0 taken 92 (fallthrough)
branch  1 taken 254
        -: 3192:		{
       92: 3193:		do_indent();
call    0 returned 92
       92: 3194:		printf( "register int yy_c = %d;\n", NUL_ec );
call    0 returned 92
        -: 3195:
       92: 3196:		indent_puts(
call    0 returned 92
        -: 3197:		"register const struct yy_trans_info *yy_trans_info;\n" );
       92: 3198:		indent_puts(
call    0 returned 92
        -: 3199:		"yy_trans_info = &yy_current_state[(unsigned int) yy_c];" );
       92: 3200:		indent_puts( "yy_current_state += yy_trans_info->yy_nxt;" );
call    0 returned 92
        -: 3201:
       92: 3202:		indent_puts(
call    0 returned 92
        -: 3203:			"yy_is_jam = (yy_trans_info->yy_verify != yy_c);" );
        -: 3204:		}
        -: 3205:
        -: 3206:	else
        -: 3207:		{
        -: 3208:		char NUL_ec_str[20];
        -: 3209:
      254: 3210:		(void) sprintf( NUL_ec_str, "%d", NUL_ec );
      254: 3211:		gen_next_compressed_state( NUL_ec_str );
call    0 returned 254
        -: 3212:
      254: 3213:		if ( reject )
branch  0 taken 99 (fallthrough)
branch  1 taken 155
       99: 3214:			indent_puts( "*yy_state_ptr++ = yy_current_state;" );
call    0 returned 99
        -: 3215:
      254: 3216:		do_indent();
call    0 returned 254
        -: 3217:
      254: 3218:		printf( "yy_is_jam = (yy_current_state == %d);\n", jamstate );
call    0 returned 254
        -: 3219:		}
        -: 3220:
        -: 3221:	/* If we've entered an accepting state, back up; note that
        -: 3222:	 * compressed tables have *already* done such backing up, so
        -: 3223:	 * we needn't bother with it again.
        -: 3224:	 */
      543: 3225:	if ( need_backing_up && (fullspd || fulltbl) )
branch  0 taken 372 (fallthrough)
branch  1 taken 171
branch  2 taken 280 (fallthrough)
branch  3 taken 92
branch  4 taken 21 (fallthrough)
branch  5 taken 259
        -: 3226:		{
      113: 3227:		putchar( '\n' );
call    0 returned 113
      113: 3228:		indent_puts( "if ( ! yy_is_jam )" );
call    0 returned 113
      113: 3229:		indent_up();
      113: 3230:		indent_puts( "{" );
call    0 returned 113
      113: 3231:		gen_backing_up();
call    0 returned 113
      113: 3232:		indent_puts( "}" );
call    0 returned 113
      113: 3233:		indent_down();
        -: 3234:		}
      543: 3235:	}
        -: 3236:
        -: 3237:
        -: 3238:/* Generate the code to find the start state. */
        -: 3239:
function gen_start_state called 1086 returned 100% blocks executed 100%
     1086: 3240:void gen_start_state()
        -: 3241:	{
     1086: 3242:	if ( fullspd )
branch  0 taken 184 (fallthrough)
branch  1 taken 902
      184: 3243:		indent_put2s(
call    0 returned 184
        -: 3244:			"yy_current_state = yy_start_state_list[yy_start%s];",
      184: 3245:			bol_needed ? " + (yy_bp[-1] == '\\n' ? 1 : 0)" : "" );
branch  0 taken 36 (fallthrough)
branch  1 taken 148
        -: 3246:
        -: 3247:	else
        -: 3248:		{
      902: 3249:		indent_puts( "yy_current_state = yy_start;" );
call    0 returned 902
        -: 3250:
      902: 3251:		if ( bol_needed )
branch  0 taken 162 (fallthrough)
branch  1 taken 740
        -: 3252:			{
      162: 3253:			indent_puts( "if ( yy_bp[-1] == '\\n' )" );
call    0 returned 162
      162: 3254:			indent_up();
      162: 3255:			indent_puts( "++yy_current_state;" );
call    0 returned 162
      162: 3256:			indent_down();
        -: 3257:			}
        -: 3258:
      902: 3259:		if ( reject )
branch  0 taken 338 (fallthrough)
branch  1 taken 564
        -: 3260:			{
        -: 3261:			/* Set up for storing up states. */
      338: 3262:			indent_puts( "yy_state_ptr = yy_state_buf;" );
call    0 returned 338
      338: 3263:			indent_puts( "*yy_state_ptr++ = yy_current_state;" );
call    0 returned 338
        -: 3264:			}
        -: 3265:		}
     1086: 3266:	}
        -: 3267:
        -: 3268:
        -: 3269:/* gentabs - generate data statements for the transition tables */
        -: 3270:
function gentabs called 428 returned 100% blocks executed 100%
      428: 3271:void gentabs()
        -: 3272:	{
        -: 3273:	int i, j, k, *accset, nacc, *acc_array, total_states;
      428: 3274:	int end_of_buffer_action = num_rules + 1;
        -: 3275:
        -: 3276:	/* *Everything* is done in terms of arrays starting at 1, so provide
        -: 3277:	 * a null entry for the zero element of all C arrays.
        -: 3278:	 */
        -: 3279:	static char C_char_decl[] =
        -: 3280:		"static const YY_CHAR %s[%d] =\n    {   0,\n";	/* } for vi */
        -: 3281:
      428: 3282:	acc_array = allocate_integer_array( current_max_dfas );
call    0 returned 428
      428: 3283:	nummt = 0;
        -: 3284:
        -: 3285:	/* The compressed table format jams by entering the "jam state",
        -: 3286:	 * losing information about the previous state in the process.
        -: 3287:	 * In order to recover the previous state, we effectively need
        -: 3288:	 * to keep backing-up information.
        -: 3289:	 */
      428: 3290:	++num_backing_up;
        -: 3291:
      428: 3292:	if ( reject )
branch  0 taken 169 (fallthrough)
branch  1 taken 259
        -: 3293:		{
        -: 3294:		/* Write out accepting list and pointer list.
        -: 3295:		 *
        -: 3296:		 * First we generate the "yy_acclist" array.  In the process,
        -: 3297:		 * we compute the indices that will go into the "yy_accept"
        -: 3298:		 * array, and save the indices in the dfaacc array.
        -: 3299:		 */
        -: 3300:		int EOB_accepting_list[2];
        -: 3301:
        -: 3302:		/* Set up accepting structures for the End Of Buffer state. */
      169: 3303:		EOB_accepting_list[0] = 0;
      169: 3304:		EOB_accepting_list[1] = end_of_buffer_action;
      169: 3305:		accsiz[end_of_buffer_state] = 1;
      169: 3306:		dfaacc[end_of_buffer_state].dfaacc_set = EOB_accepting_list;
        -: 3307:
      169: 3308:		printf( long_align ? C_long_decl : C_short_decl,
call    0 returned 169
      169: 3309:			"yy_acclist", MAX( numas, 1 ) + 1 );
branch  0 taken 80 (fallthrough)
branch  1 taken 89
        -: 3310:
      169: 3311:		j = 1;	/* index into "yy_acclist" array */
        -: 3312:
     5357: 3313:		for ( i = 1; i <= lastdfa; ++i )
branch  0 taken 5188
branch  1 taken 169 (fallthrough)
        -: 3314:			{
     5188: 3315:			acc_array[i] = j;
        -: 3316:
     5188: 3317:			if ( accsiz[i] != 0 )
branch  0 taken 4214 (fallthrough)
branch  1 taken 974
        -: 3318:				{
     4214: 3319:				accset = dfaacc[i].dfaacc_set;
     4214: 3320:				nacc = accsiz[i];
        -: 3321:
     4214: 3322:				if ( trace )
branch  0 taken 1224 (fallthrough)
branch  1 taken 2990
     1224: 3323:					fprintf( err,
call    0 returned 1224
        -: 3324:						"state # %d accepts: ", i );
        -: 3325:
    14784: 3326:				for ( k = 1; k <= nacc; ++k )
branch  0 taken 10570
branch  1 taken 4214 (fallthrough)
        -: 3327:					{
    10570: 3328:					int accnum = accset[k];
        -: 3329:
    10570: 3330:					++j;
        -: 3331:
    10570: 3332:					if ( variable_trailing_context_rules &&
branch  0 taken 607 (fallthrough)
branch  1 taken 9963
      607: 3333:					  ! (accnum & YY_TRAILING_HEAD_MASK) &&
branch  0 taken 541 (fallthrough)
branch  1 taken 66
branch  2 taken 541 (fallthrough)
branch  3 taken 0
      541: 3334:					   accnum > 0 && accnum <= num_rules &&
branch  0 taken 508 (fallthrough)
branch  1 taken 33
      508: 3335:					  rule_type[accnum] == RULE_VARIABLE )
branch  0 taken 66 (fallthrough)
branch  1 taken 442
        -: 3336:						{
        -: 3337:						/* Special hack to flag
        -: 3338:						 * accepting number as part
        -: 3339:						 * of trailing context rule.
        -: 3340:						 */
       66: 3341:						accnum |= YY_TRAILING_MASK;
        -: 3342:						}
        -: 3343:
    10570: 3344:					mkdata( accnum );
call    0 returned 10570
        -: 3345:
    10570: 3346:					if ( trace )
branch  0 taken 6155 (fallthrough)
branch  1 taken 4415
        -: 3347:						{
     6155: 3348:						fprintf( err, "[%d]",
     6155: 3349:							accset[k] );
call    0 returned 6155
        -: 3350:
     6155: 3351:						if ( k < nacc )
branch  0 taken 4931 (fallthrough)
branch  1 taken 1224
     4931: 3352:							fputs( ", ", err );
call    0 returned 4931
        -: 3353:						else
     1224: 3354:							putc( '\n', err );
call    0 returned 1224
        -: 3355:						}
        -: 3356:					}
        -: 3357:				}
        -: 3358:			}
        -: 3359:
        -: 3360:		/* add accepting number for the "jam" state */
      169: 3361:		acc_array[i] = j;
        -: 3362:
      169: 3363:		dataend();
call    0 returned 169
        -: 3364:		}
        -: 3365:
        -: 3366:	else
        -: 3367:		{
      259: 3368:		dfaacc[end_of_buffer_state].dfaacc_state = end_of_buffer_action;
        -: 3369:
     6303: 3370:		for ( i = 1; i <= lastdfa; ++i )
branch  0 taken 6044
branch  1 taken 259 (fallthrough)
     6044: 3371:			acc_array[i] = dfaacc[i].dfaacc_state;
        -: 3372:
        -: 3373:		/* add accepting number for jam state */
      259: 3374:		acc_array[i] = 0;
        -: 3375:		}
        -: 3376:
        -: 3377:	/* Spit out "yy_accept" array.  If we're doing "reject", it'll be
        -: 3378:	 * pointers into the "yy_acclist" array.  Otherwise it's actual
        -: 3379:	 * accepting numbers.  In either case, we just dump the numbers.
        -: 3380:	 */
        -: 3381:
        -: 3382:	/* "lastdfa + 2" is the size of "yy_accept"; includes room for C arrays
        -: 3383:	 * beginning at 0 and for "jam" state.
        -: 3384:	 */
      428: 3385:	k = lastdfa + 2;
        -: 3386:
      428: 3387:	if ( reject )
branch  0 taken 169 (fallthrough)
branch  1 taken 259
        -: 3388:		/* We put a "cap" on the table associating lists of accepting
        -: 3389:		 * numbers with state numbers.  This is needed because we tell
        -: 3390:		 * where the end of an accepting list is by looking at where
        -: 3391:		 * the list for the next state starts.
        -: 3392:		 */
      169: 3393:		++k;
        -: 3394:
      428: 3395:	printf( long_align ? C_long_decl : C_short_decl, "yy_accept", k );
branch  0 taken 201 (fallthrough)
branch  1 taken 227
call    2 returned 428
        -: 3396:
    11660: 3397:	for ( i = 1; i <= lastdfa; ++i )
branch  0 taken 11232
branch  1 taken 428 (fallthrough)
        -: 3398:		{
    11232: 3399:		mkdata( acc_array[i] );
call    0 returned 11232
        -: 3400:
    11232: 3401:		if ( ! reject && trace && acc_array[i] )
branch  0 taken 6044 (fallthrough)
branch  1 taken 5188
branch  2 taken 129 (fallthrough)
branch  3 taken 5915
branch  4 taken 93 (fallthrough)
branch  5 taken 36
       93: 3402:			fprintf( err, "state # %d accepts: [%d]\n",
       93: 3403:				i, acc_array[i] );
call    0 returned 93
        -: 3404:		}
        -: 3405:
        -: 3406:	/* Add entry for "jam" state. */
      428: 3407:	mkdata( acc_array[i] );
call    0 returned 428
        -: 3408:
      428: 3409:	if ( reject )
branch  0 taken 169 (fallthrough)
branch  1 taken 259
        -: 3410:		/* Add "cap" for the list. */
      169: 3411:		mkdata( acc_array[i] );
call    0 returned 169
        -: 3412:
      428: 3413:	dataend();
call    0 returned 428
        -: 3414:
      428: 3415:	if ( useecs )
branch  0 taken 254 (fallthrough)
branch  1 taken 174
      254: 3416:		genecs();
call    0 returned 254
        -: 3417:
      428: 3418:	if ( usemecs )
branch  0 taken 214 (fallthrough)
branch  1 taken 214
        -: 3419:		{
        -: 3420:		/* Write out meta-equivalence classes (used to index
        -: 3421:		 * templates with).
        -: 3422:		 */
        -: 3423:
      214: 3424:		if ( trace )
branch  0 taken 13 (fallthrough)
branch  1 taken 201
       13: 3425:			fputs( "\n\nMeta-Equivalence Classes:\n", err );
call    0 returned 13
        -: 3426:
        -: 3427:#ifndef	F_HD_5
      214: 3428:		printf( C_int_decl, "yy_meta", numecs + 1 ); 
call    0 returned 214
        -: 3429:#else
        -: 3430:		printf( C_char_decl, "yy_meta", numecs + 1 ); 
        -: 3431:#endif
        -: 3432:
    22510: 3433:		for ( i = 1; i <= numecs; ++i )
branch  0 taken 22296
branch  1 taken 214 (fallthrough)
        -: 3434:			{
    22296: 3435:			if ( trace )
branch  0 taken 204 (fallthrough)
branch  1 taken 22092
      204: 3436:				fprintf( err, "%d = %d\n",
      204: 3437:					i, ABS( tecbck[i] ) );
call    0 returned 204
        -: 3438:
    22296: 3439:			mkdata( ABS( tecbck[i] ) );
call    0 returned 22296
        -: 3440:			}
        -: 3441:
      214: 3442:		dataend();
call    0 returned 214
        -: 3443:		}
        -: 3444:
      428: 3445:	total_states = lastdfa + numtemps;
        -: 3446:
      428: 3447:	printf( (tblend >= MAX_SHORT || long_align) ?
branch  0 taken 428 (fallthrough)
branch  1 taken 0
branch  2 taken 201 (fallthrough)
branch  3 taken 227
call    4 returned 428
        -: 3448:			C_long_decl : C_short_decl,
        -: 3449:		"yy_base", total_states + 1 );
        -: 3450:
    11660: 3451:	for ( i = 1; i <= lastdfa; ++i )
branch  0 taken 11232
branch  1 taken 428 (fallthrough)
        -: 3452:		{
    11232: 3453:		register int d = def[i];
        -: 3454:
    11232: 3455:		if ( base[i] == JAMSTATE )
branch  0 taken 1942 (fallthrough)
branch  1 taken 9290
     1942: 3456:			base[i] = jambase;
        -: 3457:
    11232: 3458:		if ( d == JAMSTATE )
branch  0 taken 7466 (fallthrough)
branch  1 taken 3766
     7466: 3459:			def[i] = jamstate;
        -: 3460:
     3766: 3461:		else if ( d < 0 )
branch  0 taken 2455 (fallthrough)
branch  1 taken 1311
        -: 3462:			{
        -: 3463:			/* Template reference. */
     2455: 3464:			++tmpuses;
     2455: 3465:			def[i] = lastdfa - d + 1;
        -: 3466:			}
        -: 3467:
    11232: 3468:		mkdata( base[i] );
call    0 returned 11232
        -: 3469:		}
        -: 3470:
        -: 3471:	/* Generate jam state's base index. */
      428: 3472:	mkdata( base[i] );
call    0 returned 428
        -: 3473:
     1056: 3474:	for ( ++i /* skip jam state */; i <= total_states; ++i )
branch  0 taken 628
branch  1 taken 428 (fallthrough)
        -: 3475:		{
      628: 3476:		mkdata( base[i] );
call    0 returned 628
      628: 3477:		def[i] = jamstate;
        -: 3478:		}
        -: 3479:
      428: 3480:	dataend();
call    0 returned 428
        -: 3481:
      428: 3482:	printf( (total_states >= MAX_SHORT || long_align) ?
branch  0 taken 428 (fallthrough)
branch  1 taken 0
branch  2 taken 201 (fallthrough)
branch  3 taken 227
call    4 returned 428
        -: 3483:			C_long_decl : C_short_decl,
        -: 3484:		"yy_def", total_states + 1 );
        -: 3485:
    12716: 3486:	for ( i = 1; i <= total_states; ++i )
branch  0 taken 12288
branch  1 taken 428 (fallthrough)
    12288: 3487:		mkdata( def[i] );
call    0 returned 12288
        -: 3488:
      428: 3489:	dataend();
call    0 returned 428
        -: 3490:
      428: 3491:	printf( (total_states >= MAX_SHORT || long_align) ?
branch  0 taken 428 (fallthrough)
branch  1 taken 0
branch  2 taken 201 (fallthrough)
branch  3 taken 227
call    4 returned 428
        -: 3492:			C_long_decl : C_short_decl,
        -: 3493:		"yy_nxt", tblend + 1 );
        -: 3494:
   159559: 3495:	for ( i = 1; i <= tblend; ++i )
branch  0 taken 159131
branch  1 taken 428 (fallthrough)
        -: 3496:		{
   159131: 3497:		if ( nxt[i] == 0 || chk[i] == 0 )
branch  0 taken 89422 (fallthrough)
branch  1 taken 69709
branch  2 taken 0 (fallthrough)
branch  3 taken 89422
    69709: 3498:			nxt[i] = jamstate;	/* new state is the JAM state */
        -: 3499:
   159131: 3500:		mkdata( nxt[i] );
call    0 returned 159131
        -: 3501:		}
        -: 3502:
      428: 3503:	dataend();
call    0 returned 428
        -: 3504:
      428: 3505:	printf( (total_states >= MAX_SHORT || long_align) ?
branch  0 taken 428 (fallthrough)
branch  1 taken 0
branch  2 taken 201 (fallthrough)
branch  3 taken 227
call    4 returned 428
        -: 3506:			C_long_decl : C_short_decl,
        -: 3507:		"yy_chk", tblend + 1 );
        -: 3508:
   159559: 3509:	for ( i = 1; i <= tblend; ++i )
branch  0 taken 159131
branch  1 taken 428 (fallthrough)
        -: 3510:		{
   159131: 3511:		if ( chk[i] == 0 )
branch  0 taken 21241 (fallthrough)
branch  1 taken 137890
    21241: 3512:			++nummt;
        -: 3513:
   159131: 3514:		mkdata( chk[i] );
call    0 returned 159131
        -: 3515:		}
        -: 3516:
      428: 3517:	dataend();
call    0 returned 428
      428: 3518:	}
        -: 3519:
        -: 3520:
        -: 3521:/* Write out a formatted string (with a secondary string argument) at the
        -: 3522: * current indentation level, adding a final newline.
        -: 3523: */
        -: 3524:
function indent_put2s called 1708 returned 100% blocks executed 100%
     1708: 3525:void indent_put2s( fmt, arg )
        -: 3526:char fmt[], arg[];
        -: 3527:	{
     1708: 3528:	do_indent();
call    0 returned 1708
     1708: 3529:	printf( fmt, arg );
call    0 returned 1708
     1708: 3530:	putchar( '\n' );
call    0 returned 1708
     1708: 3531:	}
        -: 3532:
        -: 3533:
        -: 3534:/* Write out a string at the current indentation level, adding a final
        -: 3535: * newline.
        -: 3536: */
        -: 3537:
function indent_puts called 35820 returned 100% blocks executed 100%
    35820: 3538:void indent_puts( str )
        -: 3539:char str[];
        -: 3540:	{
    35820: 3541:	do_indent();
call    0 returned 35820
    35820: 3542:	puts( str );
call    0 returned 35820
    35820: 3543:	}
        -: 3544:
        -: 3545:
        -: 3546:/* make_tables - generate transition tables and finishes generating output file
        -: 3547: */
        -: 3548:
function make_tables called 543 returned 100% blocks executed 100%
      543: 3549:void make_tables()
        -: 3550:	{
        -: 3551:	register int i;
      543: 3552:	int did_eof_rule = false;
        -: 3553:
      543: 3554:	skelout();
call    0 returned 543
        -: 3555:
        -: 3556:	/* First, take care of YY_DO_BEFORE_ACTION depending on yymore
        -: 3557:	 * being used.
        -: 3558:	 */
      543: 3559:	set_indent( 1 );
        -: 3560:
      543: 3561:	if ( yymore_used )
branch  0 taken 167 (fallthrough)
branch  1 taken 376
        -: 3562:		{
      167: 3563:		indent_puts( "yytext_ptr -= yy_more_len; \\" );
call    0 returned 167
      167: 3564:		indent_puts( "yyleng = yy_cp - yytext_ptr; \\" );
call    0 returned 167
        -: 3565:		}
        -: 3566:
        -: 3567:	else
      376: 3568:		indent_puts( "yyleng = yy_cp - yy_bp; \\" );
call    0 returned 376
        -: 3569:
        -: 3570:	/* Now also deal with copying yytext_ptr to yytext if needed. */
      543: 3571:	skelout();
call    0 returned 543
      543: 3572:	if ( yytext_is_array )
branch  0 taken 162 (fallthrough)
branch  1 taken 381
        -: 3573:		{
      162: 3574:		indent_puts( "if ( yyleng >= YYLMAX ) \\" );
call    0 returned 162
      162: 3575:		indent_up();
      162: 3576:		indent_puts(
call    0 returned 162
        -: 3577:		"YY_FATAL_ERROR( \"token too large, exceeds YYLMAX\" ); \\" );
      162: 3578:		indent_down();
        -: 3579:#ifndef F_JR_5
      162: 3580:		indent_puts(
call    0 returned 162
        -: 3581:		"yy_flex_strncpy( yytext, yytext_ptr, yyleng + 1 ); \\" );
        -: 3582:#else
        -: 3583:        indent_puts(
        -: 3584:        "yy_flex_strncpy( yytext, yytext_ptr, yyleng); \\" );
        -: 3585:#endif
        -: 3586:		}
        -: 3587:
      543: 3588:	set_indent( 0 );
        -: 3589:
      543: 3590:	skelout();
call    0 returned 543
        -: 3591:
        -: 3592:
      543: 3593:	printf( "#define YY_END_OF_BUFFER %d\n", num_rules + 1 );
call    0 returned 543
        -: 3594:
      543: 3595:	if ( fullspd )
branch  0 taken 92 (fallthrough)
branch  1 taken 451
        -: 3596:		{
        -: 3597:		/* Need to define the transet type as a size large
        -: 3598:		 * enough to hold the biggest offset.
        -: 3599:		 */
       92: 3600:		int total_table_size = tblend + numecs + 1;
       92: 3601:		char *trans_offset_type =
       92: 3602:			(total_table_size >= MAX_SHORT || long_align) ?
branch  0 taken 40 (fallthrough)
branch  1 taken 52
      184: 3603:				"long" : "short";
branch  0 taken 92 (fallthrough)
branch  1 taken 0
        -: 3604:
       92: 3605:		set_indent( 0 );
       92: 3606:		indent_puts( "struct yy_trans_info" );
call    0 returned 92
       92: 3607:		indent_up();
       92: 3608:		indent_puts( "{" ); 	/* } for vi */
call    0 returned 92
        -: 3609:
       92: 3610:		if ( long_align )
branch  0 taken 40 (fallthrough)
branch  1 taken 52
       40: 3611:			indent_puts( "long yy_verify;" );
call    0 returned 40
        -: 3612:		else
       52: 3613:			indent_puts( "short yy_verify;" );
call    0 returned 52
        -: 3614:
        -: 3615:		/* In cases where its sister yy_verify *is* a "yes, there is
        -: 3616:		 * a transition", yy_nxt is the offset (in records) to the
        -: 3617:		 * next state.  In most cases where there is no transition,
        -: 3618:		 * the value of yy_nxt is irrelevant.  If yy_nxt is the -1th
        -: 3619:		 * record of a state, though, then yy_nxt is the action number
        -: 3620:		 * for that state.
        -: 3621:		 */
        -: 3622:
       92: 3623:		indent_put2s( "%s yy_nxt;", trans_offset_type );
call    0 returned 92
       92: 3624:		indent_puts( "};" );
call    0 returned 92
       92: 3625:		indent_down();
        -: 3626:		}
        -: 3627:
      543: 3628:	if ( fullspd )
branch  0 taken 92 (fallthrough)
branch  1 taken 451
       92: 3629:		genctbl();
call    0 returned 92
      451: 3630:	else if ( fulltbl )
branch  0 taken 23 (fallthrough)
branch  1 taken 428
       23: 3631:		genftbl();
call    0 returned 23
        -: 3632:	else
      428: 3633:		gentabs();
call    0 returned 428
        -: 3634:
        -: 3635:	/* Definitions for backing up.  We don't need them if REJECT
        -: 3636:	 * is being used because then we use an alternative backin-up
        -: 3637:	 * technique instead.
        -: 3638:	 */
      543: 3639:	if ( num_backing_up > 0 && ! reject )
branch  0 taken 541 (fallthrough)
branch  1 taken 2
branch  2 taken 372 (fallthrough)
branch  3 taken 169
        -: 3640:		{
      372: 3641:		if ( ! C_plus_plus )
branch  0 taken 372 (fallthrough)
branch  1 taken 0
        -: 3642:			{
      372: 3643:			indent_puts(
call    0 returned 372
        -: 3644:			"static yy_state_type yy_last_accepting_state;" );
      372: 3645:			indent_puts(
call    0 returned 372
        -: 3646:				"static char *yy_last_accepting_cpos;\n" );
        -: 3647:			}
        -: 3648:		}
        -: 3649:
      543: 3650:	if ( nultrans )
branch  0 taken 196 (fallthrough)
branch  1 taken 347
        -: 3651:		{
      196: 3652:		printf( C_state_decl, "yy_NUL_trans", lastdfa + 1 );
call    0 returned 196
        -: 3653:
     4906: 3654:		for ( i = 1; i <= lastdfa; ++i )
branch  0 taken 4710
branch  1 taken 196 (fallthrough)
        -: 3655:			{
     4710: 3656:			if ( fullspd )
branch  0 taken 0 (fallthrough)
branch  1 taken 4710
    #####: 3657:				printf( "    &yy_transition[%d],\n", base[i] );
call    0 never executed
        -: 3658:			else
     4710: 3659:				mkdata( nultrans[i] );
call    0 returned 4710
        -: 3660:			}
        -: 3661:
      196: 3662:		dataend();
call    0 returned 196
        -: 3663:		}
        -: 3664:
      543: 3665:	if ( ddebug )
branch  0 taken 252 (fallthrough)
branch  1 taken 291
        -: 3666:		{ /* Spit out table mapping rules to line numbers. */
      252: 3667:		indent_puts( "extern int yy_flex_debug;" );
call    0 returned 252
      252: 3668:		indent_puts( "int yy_flex_debug = 1;\n" );
call    0 returned 252
        -: 3669:
      252: 3670:		printf( long_align ? C_long_decl : C_short_decl,
branch  0 taken 120 (fallthrough)
branch  1 taken 132
call    2 returned 252
        -: 3671:			"yy_rule_linenum", num_rules );
     1531: 3672:		for ( i = 1; i < num_rules; ++i )
branch  0 taken 1279
branch  1 taken 252 (fallthrough)
     1279: 3673:			mkdata( rule_linenum[i] );
call    0 returned 1279
      252: 3674:		dataend();
call    0 returned 252
        -: 3675:		}
        -: 3676:
      543: 3677:	if ( reject )
branch  0 taken 169 (fallthrough)
branch  1 taken 374
        -: 3678:		{
        -: 3679:		/* Declare state buffer variables. */
      169: 3680:		if ( ! C_plus_plus )
branch  0 taken 169 (fallthrough)
branch  1 taken 0
        -: 3681:			{
      169: 3682:			puts(
call    0 returned 169
        -: 3683:	"static yy_state_type yy_state_buf[YY_BUF_SIZE + 2], *yy_state_ptr;" );
      169: 3684:			puts( "static char *yy_full_match;" );
call    0 returned 169
      169: 3685:			puts( "static int yy_lp;" );
call    0 returned 169
        -: 3686:			}
        -: 3687:
      169: 3688:		if ( variable_trailing_context_rules )
branch  0 taken 33 (fallthrough)
branch  1 taken 136
        -: 3689:			{
       33: 3690:			if ( ! C_plus_plus )
branch  0 taken 33 (fallthrough)
branch  1 taken 0
        -: 3691:				{
       33: 3692:				puts(
call    0 returned 33
        -: 3693:				"static int yy_looking_for_trail_begin = 0;" );
       33: 3694:				puts( "static int yy_full_lp;" );
call    0 returned 33
       33: 3695:				puts( "static int *yy_full_state;" );
call    0 returned 33
        -: 3696:				}
        -: 3697:
       33: 3698:			printf( "#define YY_TRAILING_MASK 0x%x\n",
call    0 returned 33
        -: 3699:				(unsigned int) YY_TRAILING_MASK );
       33: 3700:			printf( "#define YY_TRAILING_HEAD_MASK 0x%x\n",
call    0 returned 33
        -: 3701:				(unsigned int) YY_TRAILING_HEAD_MASK );
        -: 3702:			}
        -: 3703:
      169: 3704:		puts( "#define REJECT \\" );
call    0 returned 169
      169: 3705:		puts( "{ \\" );		/* } for vi */
call    0 returned 169
      169: 3706:		puts(
call    0 returned 169
        -: 3707:	"*yy_cp = yy_hold_char; /* undo effects of setting up yytext */ \\" );
      169: 3708:		puts(
call    0 returned 169
        -: 3709:	"yy_cp = yy_full_match; /* restore poss. backed-over text */ \\" );
        -: 3710:
      169: 3711:		if ( variable_trailing_context_rules )
branch  0 taken 33 (fallthrough)
branch  1 taken 136
        -: 3712:			{
       33: 3713:			puts(
call    0 returned 33
        -: 3714:		"yy_lp = yy_full_lp; /* restore orig. accepting pos. */ \\" );
       33: 3715:			puts(
call    0 returned 33
        -: 3716:		"yy_state_ptr = yy_full_state; /* restore orig. state */ \\" );
       33: 3717:			puts(
call    0 returned 33
        -: 3718:	"yy_current_state = *yy_state_ptr; /* restore curr. state */ \\" );
        -: 3719:			}
        -: 3720:
      169: 3721:		puts( "++yy_lp; \\" );
call    0 returned 169
      169: 3722:		puts( "goto find_rule; \\" );
call    0 returned 169
        -: 3723:		/* { for vi */
      169: 3724:		puts( "}" );
call    0 returned 169
        -: 3725:		}
        -: 3726:
        -: 3727:	else
        -: 3728:		{
      374: 3729:		puts(
call    0 returned 374
        -: 3730:		"/* The intent behind this definition is that it'll catch" );
      374: 3731:		puts( " * any uses of REJECT which flex missed." );
call    0 returned 374
      374: 3732:		puts( " */" );
call    0 returned 374
      374: 3733:		puts( "#define REJECT reject_used_but_not_detected" );
call    0 returned 374
        -: 3734:		}
        -: 3735:
      543: 3736:	if ( yymore_used )
branch  0 taken 167 (fallthrough)
branch  1 taken 376
        -: 3737:		{
      167: 3738:		if ( ! C_plus_plus )
branch  0 taken 167 (fallthrough)
branch  1 taken 0
        -: 3739:			{
      167: 3740:			indent_puts( "static int yy_more_flag = 0;" );
call    0 returned 167
      167: 3741:			indent_puts( "static int yy_more_len = 0;" );
call    0 returned 167
        -: 3742:			}
        -: 3743:
      167: 3744:		indent_puts( "#define yymore() (yy_more_flag = 1)" );
call    0 returned 167
      167: 3745:		indent_puts( "#define YY_MORE_ADJ yy_more_len" );
call    0 returned 167
        -: 3746:		}
        -: 3747:
        -: 3748:	else
        -: 3749:		{
      376: 3750:		indent_puts( "#define yymore() yymore_used_but_not_detected" );
call    0 returned 376
      376: 3751:		indent_puts( "#define YY_MORE_ADJ 0" );
call    0 returned 376
        -: 3752:		}
        -: 3753:
      543: 3754:	if ( ! C_plus_plus )
branch  0 taken 543 (fallthrough)
branch  1 taken 0
        -: 3755:		{
      543: 3756:		if ( yytext_is_array )
branch  0 taken 162 (fallthrough)
branch  1 taken 381
        -: 3757:			{
      162: 3758:			puts( "#ifndef YYLMAX" );
call    0 returned 162
      162: 3759:			puts( "#define YYLMAX 8192" );
call    0 returned 162
      162: 3760:			puts( "#endif\n" );
call    0 returned 162
      162: 3761:			puts( "char yytext[YYLMAX];" );
call    0 returned 162
      162: 3762:			puts( "char *yytext_ptr;" );
call    0 returned 162
        -: 3763:			}
        -: 3764:
        -: 3765:		else
      381: 3766:			puts( "char *yytext;" );
call    0 returned 381
        -: 3767:		}
        -: 3768:
      543: 3769:	fputs( &action_array[defs1_offset], stdout );
call    0 returned 543
        -: 3770:
      543: 3771:	skelout();
call    0 returned 543
        -: 3772:
      543: 3773:	if ( ! C_plus_plus )
branch  0 taken 543 (fallthrough)
branch  1 taken 0
        -: 3774:		{
      543: 3775:		if ( use_read )
branch  0 taken 240 (fallthrough)
branch  1 taken 303
        -: 3776:			{
      240: 3777:			printf(
call    0 returned 240
        -: 3778:"\tif ( (result = read( fileno(yyin), (char *) buf, max_size )) < 0 ) \\\n" );
      240: 3779:			printf(
call    0 returned 240
        -: 3780:		"\t\tYY_FATAL_ERROR( \"input in flex scanner failed\" );\n" );
        -: 3781:			}
        -: 3782:
        -: 3783:		else
        -: 3784:			{
      303: 3785:			printf(
call    0 returned 303
        -: 3786:			"\tif ( yy_current_buffer->yy_is_interactive ) \\\n" );
      303: 3787:			printf( "\t\t{ \\\n" );
call    0 returned 303
      303: 3788:			printf( "\t\tint c = getc( yyin ); \\\n" );
call    0 returned 303
      303: 3789:			printf( "\t\tresult = c == EOF ? 0 : 1; \\\n" );
call    0 returned 303
        -: 3790:#ifndef F_JR_4
      303: 3791:			printf( "\t\tbuf[0] = (char) c; \\\n" );
call    0 returned 303
        -: 3792:#else
        -: 3793:            printf( "\t\buf[0] = (char) c; \\\n" );
        -: 3794:#endif
      303: 3795:			printf( "\t\t} \\\n" );
call    0 returned 303
        -: 3796:			
      303: 3797:            printf(
call    0 returned 303
        -: 3798:	"\telse if ( ((result = fread( buf, 1, max_size, yyin )) == 0) \\\n" );
      303: 3799:			printf( "\t\t  && ferror( yyin ) ) \\\n" );
call    0 returned 303
      303: 3800:			printf(
call    0 returned 303
        -: 3801:		"\t\tYY_FATAL_ERROR( \"input in flex scanner failed\" );\n" );
        -: 3802:			}
        -: 3803:		}
        -: 3804:
      543: 3805:	skelout();
call    0 returned 543
        -: 3806:
        -: 3807:	/* Copy prolog to output file. */
      543: 3808:	fputs( &action_array[prolog_offset], stdout );
call    0 returned 543
        -: 3809:
      543: 3810:	skelout();
call    0 returned 543
        -: 3811:
      543: 3812:	set_indent( 2 );
        -: 3813:
      543: 3814:	if ( yymore_used )
branch  0 taken 167 (fallthrough)
branch  1 taken 376
        -: 3815:		{
      167: 3816:		indent_puts( "yy_more_len = 0;" );
call    0 returned 167
      167: 3817:		indent_puts( "if ( yy_more_flag )" );
call    0 returned 167
      167: 3818:		indent_up();
      167: 3819:		indent_puts( "{" );
call    0 returned 167
      167: 3820:		indent_puts( "yy_more_len = yyleng;" );
call    0 returned 167
      167: 3821:		indent_puts( "yy_more_flag = 0;" );
call    0 returned 167
      167: 3822:		indent_puts( "}" );
call    0 returned 167
      167: 3823:		indent_down();
        -: 3824:		}
        -: 3825:
      543: 3826:	skelout();
call    0 returned 543
        -: 3827:
      543: 3828:	gen_start_state();
call    0 returned 543
        -: 3829:
        -: 3830:	/* Note, don't use any indentation. */
      543: 3831:	puts( "yy_match:" );
call    0 returned 543
      543: 3832:	gen_next_match();
call    0 returned 543
        -: 3833:
      543: 3834:	skelout();
call    0 returned 543
      543: 3835:	set_indent( 2 );
      543: 3836:	gen_find_action();
call    0 returned 543
        -: 3837:
      543: 3838:	skelout();
call    0 returned 543
      543: 3839:	if ( lex_compat )
branch  0 taken 162 (fallthrough)
branch  1 taken 381
        -: 3840:		{
      162: 3841:		indent_puts( "if ( yy_act != YY_END_OF_BUFFER )" );
call    0 returned 162
      162: 3842:		indent_up();
      162: 3843:		indent_puts( "{" );
call    0 returned 162
      162: 3844:		indent_puts( "int yyl;" );
call    0 returned 162
      162: 3845:		indent_puts( "for ( yyl = 0; yyl < yyleng; ++yyl )" );
call    0 returned 162
      162: 3846:		indent_up();
      162: 3847:		indent_puts( "if ( yytext[yyl] == '\\n' )" );
call    0 returned 162
      162: 3848:		indent_up();
      162: 3849:		indent_puts( "++yylineno;" );
call    0 returned 162
      162: 3850:		indent_down();
      162: 3851:		indent_down();
      162: 3852:		indent_puts( "}" );
call    0 returned 162
      162: 3853:		indent_down();
        -: 3854:		}
        -: 3855:
      543: 3856:	skelout();
call    0 returned 543
      543: 3857:	if ( ddebug )
branch  0 taken 252 (fallthrough)
branch  1 taken 291
        -: 3858:		{
      252: 3859:		indent_puts( "if ( yy_flex_debug )" );
call    0 returned 252
      252: 3860:		indent_up();
        -: 3861:
      252: 3862:		indent_puts( "{" );
call    0 returned 252
      252: 3863:		indent_puts( "if ( yy_act == 0 )" );
call    0 returned 252
      252: 3864:		indent_up();
      252: 3865:		indent_puts(
call    0 returned 252
        -: 3866:			"fprintf( stderr, \"--scanner backing up\\n\" );" );
      252: 3867:		indent_down();
        -: 3868:
      252: 3869:		do_indent();
call    0 returned 252
      252: 3870:		printf( "else if ( yy_act < %d )\n", num_rules );
call    0 returned 252
      252: 3871:		indent_up();
      252: 3872:		indent_puts(
call    0 returned 252
        -: 3873:	"fprintf( stderr, \"--accepting rule at line %d (\\\"%s\\\")\\n\"," );
      252: 3874:		indent_puts( "         yy_rule_linenum[yy_act], yytext );" );
call    0 returned 252
      252: 3875:		indent_down();
        -: 3876:
      252: 3877:		do_indent();
call    0 returned 252
      252: 3878:		printf( "else if ( yy_act == %d )\n", num_rules );
call    0 returned 252
      252: 3879:		indent_up();
      252: 3880:		indent_puts(
call    0 returned 252
        -: 3881:	"fprintf( stderr, \"--accepting default rule (\\\"%s\\\")\\n\"," );
      252: 3882:		indent_puts( "         yytext );" );
call    0 returned 252
      252: 3883:		indent_down();
        -: 3884:
      252: 3885:		do_indent();
call    0 returned 252
      252: 3886:		printf( "else if ( yy_act == %d )\n", num_rules + 1 );
call    0 returned 252
      252: 3887:		indent_up();
      252: 3888:		indent_puts(
call    0 returned 252
        -: 3889:	"fprintf( stderr, \"--(end of buffer or a NUL)\\n\" );" );
      252: 3890:		indent_down();
        -: 3891:
      252: 3892:		do_indent();
call    0 returned 252
      252: 3893:		printf( "else\n" );
call    0 returned 252
      252: 3894:		indent_up();
      252: 3895:		indent_puts(
call    0 returned 252
        -: 3896:	"fprintf( stderr, \"--EOF (start condition %d)\\n\", YY_START );" );
      252: 3897:		indent_down();
        -: 3898:
      252: 3899:		indent_puts( "}" );
call    0 returned 252
      252: 3900:		indent_down();
        -: 3901:		}
        -: 3902:
        -: 3903:	/* Copy actions to output file. */
      543: 3904:	skelout();
call    0 returned 543
      543: 3905:	indent_up();
      543: 3906:	gen_bu_action();
call    0 returned 543
      543: 3907:	fputs( &action_array[action_offset], stdout );
call    0 returned 543
        -: 3908:
        -: 3909:	/* generate cases for any missing EOF rules */
     1105: 3910:	for ( i = 1; i <= lastsc; ++i )
branch  0 taken 562
branch  1 taken 543 (fallthrough)
      562: 3911:		if ( ! sceof[i] )
branch  0 taken 541 (fallthrough)
branch  1 taken 21
        -: 3912:			{
      541: 3913:			do_indent();
call    0 returned 541
      541: 3914:			printf( "case YY_STATE_EOF(%s):\n", scname[i] );
call    0 returned 541
      541: 3915:			did_eof_rule = true;
        -: 3916:			}
        -: 3917:
      543: 3918:	if ( did_eof_rule )
branch  0 taken 537 (fallthrough)
branch  1 taken 6
        -: 3919:		{
      537: 3920:		indent_up();
      537: 3921:		indent_puts( "yyterminate();" );
call    0 returned 537
      537: 3922:		indent_down();
        -: 3923:		}
        -: 3924:
        -: 3925:
        -: 3926:	/* Generate code for handling NUL's, if needed. */
        -: 3927:
        -: 3928:	/* First, deal with backing up and setting up yy_cp if the scanner
        -: 3929:	 * finds that it should JAM on the NUL.
        -: 3930:	 */
      543: 3931:	skelout();
call    0 returned 543
      543: 3932:	set_indent( 7 );
        -: 3933:
      543: 3934:	if ( fullspd || fulltbl )
branch  0 taken 451 (fallthrough)
branch  1 taken 92
branch  2 taken 23 (fallthrough)
branch  3 taken 428
      115: 3935:		indent_puts( "yy_cp = yy_c_buf_p;" );
call    0 returned 115
        -: 3936:
        -: 3937:	else
        -: 3938:		{ /* compressed table */
      428: 3939:		if ( ! reject && ! interactive )
branch  0 taken 259 (fallthrough)
branch  1 taken 169
branch  2 taken 1 (fallthrough)
branch  3 taken 258
        -: 3940:			{
        -: 3941:			/* Do the guaranteed-needed backing up to figure
        -: 3942:			 * out the match.
        -: 3943:			 */
        1: 3944:			indent_puts( "yy_cp = yy_last_accepting_cpos;" );
call    0 returned 1
        1: 3945:			indent_puts(
call    0 returned 1
        -: 3946:				"yy_current_state = yy_last_accepting_state;" );
        -: 3947:			}
        -: 3948:#ifndef F_JR_3
        -: 3949:		else
        -: 3950:			/* Still need to initialize yy_cp, though
        -: 3951:			 * yy_current_state was set up by
        -: 3952:			 * yy_get_previous_state().
        -: 3953:			 */
      427: 3954:			indent_puts( "yy_cp = yy_c_buf_p;" );
call    0 returned 427
        -: 3955:#else
        -: 3956:;  /* do nothing */
        -: 3957:#endif
        -: 3958:		}
        -: 3959:
        -: 3960:
        -: 3961:	/* Generate code for yy_get_previous_state(). */
      543: 3962:	set_indent( 1 );
      543: 3963:	skelout();
call    0 returned 543
        -: 3964:
      543: 3965:	if ( bol_needed )
branch  0 taken 99 (fallthrough)
branch  1 taken 444
       99: 3966:		indent_puts( "register char *yy_bp = yytext_ptr;\n" );
call    0 returned 99
        -: 3967:
      543: 3968:	gen_start_state();
call    0 returned 543
        -: 3969:
      543: 3970:	set_indent( 2 );
      543: 3971:	skelout();
call    0 returned 543
      543: 3972:	gen_next_state( true );
call    0 returned 543
        -: 3973:
      543: 3974:	set_indent( 1 );
      543: 3975:	skelout();
call    0 returned 543
      543: 3976:	gen_NUL_trans();
call    0 returned 543
        -: 3977:
      543: 3978:	skelout();
call    0 returned 543
      543: 3979:	if ( lex_compat )
branch  0 taken 162 (fallthrough)
branch  1 taken 381
        -: 3980:		{ /* update yylineno inside of unput() */
      162: 3981:		indent_puts( "if ( c == '\\n' )" );
call    0 returned 162
      162: 3982:		indent_up();
      162: 3983:		indent_puts( "--yylineno;" );
call    0 returned 162
      162: 3984:		indent_down();
        -: 3985:		}
        -: 3986:
      543: 3987:	skelout();
call    0 returned 543
        -: 3988:
        -: 3989:	/* Copy remainder of input to output. */
        -: 3990:
      543: 3991:	line_directive_out( stdout );
call    0 returned 543
        -: 3992:
      543: 3993:	if ( sectnum == 3 )
branch  0 taken 112 (fallthrough)
branch  1 taken 431
      112: 3994:		(void) flexscan(); /* copy remainder of input to output */
call    0 returned 112
      543: 3995:	}
        -: 3996:/* misc - miscellaneous flex routines */
        -: 3997:
        -: 3998:/*-
        -: 3999: * Copyright (c) 1990 The Regents of the University of California.
        -: 4000: * All rights reserved.
        -: 4001: *
        -: 4002: * This code is derived from software contributed to Berkeley by
        -: 4003: * Vern Paxson.
        -: 4004: * 
        -: 4005: * The United States Government has rights in this work pursuant
        -: 4006: * to contract no. DE-AC03-76SF00098 between the United States
        -: 4007: * Department of Energy and the University of California.
        -: 4008: *
        -: 4009: * Redistribution and use in source and binary forms are permitted provided
        -: 4010: * that: (1) source distributions retain this entire copyright notice and
        -: 4011: * comment, and (2) distributions including binaries display the following
        -: 4012: * acknowledgement:  ``This product includes software developed by the
        -: 4013: * University of California, Berkeley and its contributors'' in the
        -: 4014: * documentation or other materials provided with the distribution and in
        -: 4015: * all advertising materials mentioning features or use of this software.
        -: 4016: * Neither the name of the University nor the names of its contributors may
        -: 4017: * be used to endorse or promote products derived from this software without
        -: 4018: * specific prior written permission.
        -: 4019: * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
        -: 4020: * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
        -: 4021: * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
        -: 4022: */
        -: 4023:
        -: 4024:/* $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.seeded/v1/flex.c,v 1.1.1.2 2003/09/02 20:21:59 expsir Exp $ */
        -: 4025:
        -: 4026:
        -: 4027:
        -: 4028:
        -: 4029:/* declare functions that have forward references */
        -: 4030:
        -: 4031:void dataflush PROTO((void));
        -: 4032:int otoi PROTO((Char []));
        -: 4033:
        -: 4034:
function add_action called 62218 returned 100% blocks executed 100%
    62218: 4035:void add_action( new_text )
        -: 4036:char *new_text;
        -: 4037:	{
    62218: 4038:	int len = strlen( new_text );
        -: 4039:
    62231: 4040:	while ( len + action_index >= action_size - 10 /* slop */ )
branch  0 taken 13
branch  1 taken 62218 (fallthrough)
        -: 4041:		{
       13: 4042:		action_size *= 2;
       13: 4043:		action_array =
       13: 4044:			reallocate_character_array( action_array, action_size );
call    0 returned 13
        -: 4045:		}
        -: 4046:
    62218: 4047:	strcpy( &action_array[action_index], new_text );
        -: 4048:
    62218: 4049:	action_index += len;
    62218: 4050:	}
        -: 4051:
        -: 4052:
        -: 4053:/* allocate_array - allocate memory for an integer array of the given size */
        -: 4054:
function allocate_array called 40559 returned 100% blocks executed 71%
    40559: 4055:void *allocate_array( size, element_size )
        -: 4056:int size, element_size;
        -: 4057:	{
        -: 4058:	register void *mem;
        -: 4059:
        -: 4060:	/* On 16-bit int machines (e.g., 80286) we might be trying to
        -: 4061:	 * allocate more than a signed int can hold, and that won't
        -: 4062:	 * work.  Cheap test:
        -: 4063:	 */
    40559: 4064:	if ( element_size * size <= 0 )
branch  0 taken 0 (fallthrough)
branch  1 taken 40559
    #####: 4065:		flexfatal( "request for < 1 byte in allocate_array()" );
call    0 never executed
        -: 4066:
        -: 4067:#ifndef	F_HD_6
    40559: 4068:	mem = flex_alloc( element_size * size); 
call    0 returned 40559
        -: 4069:#else
        -: 4070:	mem = flex_alloc( element_size);
        -: 4071:#endif
        -: 4072:				"";
        -: 4073:
    40559: 4074:	if ( mem == NULL )
branch  0 taken 0 (fallthrough)
branch  1 taken 40559
    #####: 4075:		flexfatal( "memory allocation failed in allocate_array()" );
call    0 never executed
        -: 4076:
    40559: 4077:	return mem;
        -: 4078:	}
        -: 4079:
        -: 4080:
        -: 4081:/* all_lower - true if a string is all lower-case */
        -: 4082:
function all_lower called 5 returned 100% blocks executed 88%
        5: 4083:int all_lower( str )
        -: 4084:register char *str;
        -: 4085:	{
       35: 4086:	while ( *str )
branch  0 taken 30
branch  1 taken 5 (fallthrough)
        -: 4087:		{
       30: 4088:		if ( ! isascii( (Char) *str ) || ! islower( *str ) )
branch  0 taken 30 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 30
    #####: 4089:			return 0;
       30: 4090:		++str;
        -: 4091:		}
        -: 4092:
        5: 4093:	return 1;
        -: 4094:	}
        -: 4095:
        -: 4096:
        -: 4097:/* all_upper - true if a string is all upper-case */
        -: 4098:
function all_upper called 8 returned 100% blocks executed 88%
        8: 4099:int all_upper( str )
        -: 4100:register char *str;
        -: 4101:	{
       56: 4102:	while ( *str )
branch  0 taken 48
branch  1 taken 8 (fallthrough)
        -: 4103:		{
       48: 4104:		if ( ! isascii( (Char) *str ) || ! isupper( *str ) )
branch  0 taken 48 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 48
    #####: 4105:			return 0;
       48: 4106:		++str;
        -: 4107:		}
        -: 4108:
        8: 4109:	return 1;
        -: 4110:	}
        -: 4111:
        -: 4112:
        -: 4113:/* bubble - bubble sort an integer array in increasing order
        -: 4114: *
        -: 4115: * synopsis
        -: 4116: *   int v[n], n;
        -: 4117: *   void bubble( v, n );
        -: 4118: *
        -: 4119: * description
        -: 4120: *   sorts the first n elements of array v and replaces them in
        -: 4121: *   increasing order.
        -: 4122: *
        -: 4123: * passed
        -: 4124: *   v - the array to be sorted
        -: 4125: *   n - the number of elements of 'v' to be sorted
        -: 4126: */
        -: 4127:
function bubble called 31186 returned 100% blocks executed 100%
    31186: 4128:void bubble( v, n )
        -: 4129:int v[], n;
        -: 4130:	{
        -: 4131:	register int i, j, k;
        -: 4132:
   119050: 4133:	for ( i = n; i > 1; --i )
branch  0 taken 87864
branch  1 taken 31186 (fallthrough)
   770536: 4134:		for ( j = 1; j < i; ++j )
branch  0 taken 682672
branch  1 taken 87864 (fallthrough)
   682672: 4135:			if ( v[j] > v[j + 1] )	/* compare */
branch  0 taken 466672 (fallthrough)
branch  1 taken 216000
        -: 4136:				{
   466672: 4137:				k = v[j];	/* exchange */
   466672: 4138:				v[j] = v[j + 1];
   466672: 4139:				v[j + 1] = k;
        -: 4140:				}
    31186: 4141:	}
        -: 4142:
        -: 4143:
        -: 4144:/* check_char - checks a character to make sure it's within the range
        -: 4145: *		we're expecting.  If not, generates fatal error message
        -: 4146: *		and exits.
        -: 4147: */
        -: 4148:
function check_char called 37079 returned 100% blocks executed 71%
    37079: 4149:void check_char( c )
        -: 4150:int c;
        -: 4151:	{
    37079: 4152:	if ( c >= CSIZE )
branch  0 taken 0 (fallthrough)
branch  1 taken 37079
    #####: 4153:		lerrsf( "bad character '%s' detected in check_char()",
call    0 never executed
call    1 never executed
        -: 4154:			readable_form( c ) );
        -: 4155:
    37079: 4156:	if ( c >= csize )
branch  0 taken 1 (fallthrough)
branch  1 taken 37078
        1: 4157:		lerrsf( "scanner requires -8 flag to use the character '%s'",
call    0 returned 1
call    1 returned 0
        -: 4158:			readable_form( c ) );
    37078: 4159:	}
        -: 4160:
        -: 4161:
        -: 4162:
        -: 4163:/* clower - replace upper-case letter to lower-case */
        -: 4164:
function clower called 83 returned 100% blocks executed 100%
       83: 4165:Char clower( c )
        -: 4166:register int c;
        -: 4167:	{
       83: 4168:	return (Char) ((isascii( c ) && isupper( c )) ? tolower( c ) : c);
branch  0 taken 83 (fallthrough)
branch  1 taken 0
branch  2 taken 78 (fallthrough)
branch  3 taken 5
        -: 4169:	}
        -: 4170:
        -: 4171:
        -: 4172:/* copy_string - returns a dynamically allocated copy of a string */
        -: 4173:
function copy_string called 812 returned 100% blocks executed 90%
      812: 4174:char *copy_string( str )
        -: 4175:register char *str;
        -: 4176:	{
        -: 4177:	register char *c;
        -: 4178:	char *copy;
        -: 4179:
        -: 4180:	/* find length */
     5630: 4181:	for ( c = str; *c; ++c )
branch  0 taken 4818
branch  1 taken 812 (fallthrough)
        -: 4182:		;
        -: 4183:
      812: 4184:	copy = (char *) flex_alloc( (c - str + 1) * sizeof( char ) );
call    0 returned 812
        -: 4185:
      812: 4186:	if ( copy == NULL )
branch  0 taken 0 (fallthrough)
branch  1 taken 812
    #####: 4187:		flexfatal( "dynamic memory failure in copy_string()" );
call    0 never executed
        -: 4188:
     5630: 4189:	for ( c = copy; (*c++ = *str++); )
branch  0 taken 4818
branch  1 taken 812 (fallthrough)
        -: 4190:		;
        -: 4191:
      812: 4192:	return copy;
        -: 4193:	}
        -: 4194:
        -: 4195:
        -: 4196:/* copy_unsigned_string -
        -: 4197: *    returns a dynamically allocated copy of a (potentially) unsigned string
        -: 4198: */
        -: 4199:
function copy_unsigned_string called 1534 returned 100% blocks executed 100%
     1534: 4200:Char *copy_unsigned_string( str )
        -: 4201:register Char *str;
        -: 4202:	{
        -: 4203:	register Char *c;
        -: 4204:	Char *copy;
        -: 4205:
        -: 4206:	/* find length */
    10901: 4207:	for ( c = str; *c; ++c )
branch  0 taken 9367
branch  1 taken 1534 (fallthrough)
        -: 4208:		;
        -: 4209:
     1534: 4210:	copy = allocate_Character_array( c - str + 1 );
call    0 returned 1534
        -: 4211:
    10901: 4212:	for ( c = copy; (*c++ = *str++); )
branch  0 taken 9367
branch  1 taken 1534 (fallthrough)
        -: 4213:		;
        -: 4214:
     1534: 4215:	return copy;
        -: 4216:	}
        -: 4217:
        -: 4218:
        -: 4219:/* cshell - shell sort a character array in increasing order
        -: 4220: *
        -: 4221: * synopsis
        -: 4222: *
        -: 4223: *   Char v[n];
        -: 4224: *   int n, special_case_0;
        -: 4225: *   cshell( v, n, special_case_0 );
        -: 4226: *
        -: 4227: * description
        -: 4228: *   Does a shell sort of the first n elements of array v.
        -: 4229: *   If special_case_0 is true, then any element equal to 0
        -: 4230: *   is instead assumed to have infinite weight.
        -: 4231: *
        -: 4232: * passed
        -: 4233: *   v - array to be sorted
        -: 4234: *   n - number of elements of v to be sorted
        -: 4235: */
        -: 4236:
function cshell called 847 returned 100% blocks executed 89%
      847: 4237:void cshell( v, n, special_case_0 )
        -: 4238:Char v[];
        -: 4239:int n, special_case_0;
        -: 4240:	{
        -: 4241:	int gap, i, j, jg;
        -: 4242:	Char k;
        -: 4243:
     3457: 4244:	for ( gap = n / 2; gap > 0; gap = gap / 2 )
branch  0 taken 2610
branch  1 taken 847 (fallthrough)
    74679: 4245:		for ( i = gap; i < n; ++i )
branch  0 taken 72069
branch  1 taken 2610 (fallthrough)
    96864: 4246:			for ( j = i - gap; j >= 0; j = j - gap )
branch  0 taken 92593
branch  1 taken 4271 (fallthrough)
        -: 4247:				{
    92593: 4248:				jg = j + gap;
        -: 4249:
    92593: 4250:				if ( special_case_0 )
branch  0 taken 92593 (fallthrough)
branch  1 taken 0
        -: 4251:					{
    92593: 4252:					if ( v[jg] == 0 )
branch  0 taken 7 (fallthrough)
branch  1 taken 92586
        7: 4253:						break;
        -: 4254:
    92586: 4255:					else if ( v[j] != 0 && v[j] <= v[jg] )
branch  0 taken 92577 (fallthrough)
branch  1 taken 9
branch  2 taken 67791 (fallthrough)
branch  3 taken 24786
    67791: 4256:						break;
        -: 4257:					}
        -: 4258:
    #####: 4259:				else if ( v[j] <= v[jg] )
branch  0 never executed
branch  1 never executed
    #####: 4260:					break;
        -: 4261:
    24795: 4262:				k = v[j];
    24795: 4263:				v[j] = v[jg];
    24795: 4264:				v[jg] = k;
        -: 4265:				}
      847: 4266:	}
        -: 4267:
        -: 4268:
        -: 4269:/* dataend - finish up a block of data declarations */
        -: 4270:
function dataend called 3404 returned 100% blocks executed 100%
     3404: 4271:void dataend()
        -: 4272:	{
     3404: 4273:	if ( datapos > 0 )
branch  0 taken 3385 (fallthrough)
branch  1 taken 19
     3385: 4274:		dataflush();
call    0 returned 3385
        -: 4275:
        -: 4276:	/* add terminator for initialization; { for vi */
     3404: 4277:	puts( "    } ;\n" );
call    0 returned 3404
        -: 4278:
     3404: 4279:	dataline = 0;
     3404: 4280:	datapos = 0;
     3404: 4281:	}
        -: 4282:
        -: 4283:
        -: 4284:/* dataflush - flush generated data statements */
        -: 4285:
function dataflush called 55710 returned 100% blocks executed 100%
    55710: 4286:void dataflush()
        -: 4287:	{
    55710: 4288:	putchar( '\n' );
call    0 returned 55710
        -: 4289:
    55710: 4290:	if ( ++dataline >= NUMDATALINES )
branch  0 taken 4963 (fallthrough)
branch  1 taken 50747
        -: 4291:		{
        -: 4292:		/* Put out a blank line so that the table is grouped into
        -: 4293:		 * large blocks that enable the user to find elements easily.
        -: 4294:		 */
     4963: 4295:		putchar( '\n' );
call    0 returned 4963
     4963: 4296:		dataline = 0;
        -: 4297:		}
        -: 4298:
        -: 4299:	/* Reset the number of characters written on the current line. */
    55710: 4300:	datapos = 0;
    55710: 4301:	}
        -: 4302:
        -: 4303:
        -: 4304:/* flexerror - report an error message and terminate */
        -: 4305:
function flexerror called 15 returned 0% blocks executed 100%
       15: 4306:void flexerror( msg )
        -: 4307:char msg[];
        -: 4308:	{
       15: 4309:	fprintf( err, "%s: %s\n", program_name, msg );
call    0 returned 15
       15: 4310:	flexend( 1 );
call    0 returned 0
    #####: 4311:	}
        -: 4312:
        -: 4313:
        -: 4314:/* flexfatal - report a fatal error message and terminate */
        -: 4315:
function flexfatal called 0 returned 0% blocks executed 0%
    #####: 4316:void flexfatal( msg )
        -: 4317:char msg[];
        -: 4318:	{
    #####: 4319:	fprintf( err, "%s: fatal internal error, %s\n", program_name, msg );
call    0 never executed
    #####: 4320:	exit( 1 );
        -: 4321:	}
        -: 4322:
        -: 4323:
        -: 4324:/* lerrif - report an error message formatted with one integer argument */
        -: 4325:
function lerrif called 1 returned 0% blocks executed 100%
        1: 4326:void lerrif( msg, arg )
        -: 4327:char msg[];
        -: 4328:int arg;
        -: 4329:	{
        -: 4330:	char errmsg[MAXLINE];
        1: 4331:	(void) sprintf( errmsg, msg, arg );
        1: 4332:	flexerror( errmsg );
call    0 returned 0
    #####: 4333:	}
        -: 4334:
        -: 4335:
        -: 4336:/* lerrsf - report an error message formatted with one string argument */
        -: 4337:
function lerrsf called 3 returned 0% blocks executed 100%
        3: 4338:void lerrsf( msg, arg )
        -: 4339:char msg[], arg[];
        -: 4340:	{
        -: 4341:	char errmsg[MAXLINE];
        -: 4342:
        3: 4343:	(void) sprintf( errmsg, msg, arg );
        3: 4344:	flexerror( errmsg );
call    0 returned 0
    #####: 4345:	}
        -: 4346:
        -: 4347:
        -: 4348:/* htoi - convert a hexadecimal digit string to an integer value */
        -: 4349:
function htoi called 3 returned 100% blocks executed 100%
        3: 4350:int htoi( str )
        -: 4351:Char str[];
        -: 4352:	{
        -: 4353:	unsigned int result;
        -: 4354:
        3: 4355:	(void) sscanf( (char *) str, "%x", &result );
        -: 4356:
        3: 4357:	return result;
        -: 4358:	}
        -: 4359:
        -: 4360:
        -: 4361:/* is_hex_digit - returns true if a character is a valid hex digit, false
        -: 4362: *		  otherwise
        -: 4363: */
        -: 4364:
function is_hex_digit called 7 returned 100% blocks executed 100%
        7: 4365:int is_hex_digit( ch )
        -: 4366:int ch;
        -: 4367:	{
        7: 4368:	if ( isdigit( ch ) )
branch  0 taken 2 (fallthrough)
branch  1 taken 5
        2: 4369:		return 1;
        -: 4370:
        5: 4371:	switch ( clower( ch ) )
call    0 returned 5
branch  1 taken 2 (fallthrough)
branch  2 taken 3
        -: 4372:		{
        2: 4373:		case 'a':
        -: 4374:		case 'b':
        -: 4375:		case 'c':
        -: 4376:		case 'd':
        -: 4377:		case 'e':
        -: 4378:		case 'f':
        2: 4379:			return 1;
        -: 4380:
        3: 4381:		default:
        3: 4382:			return 0;
        -: 4383:		}
        -: 4384:	}
        -: 4385:
        -: 4386:
        -: 4387:/* line_directive_out - spit out a "# line" statement */
        -: 4388:
function line_directive_out called 5831 returned 100% blocks executed 100%
     5831: 4389:void line_directive_out( output_file )
        -: 4390:FILE *output_file;
        -: 4391:	{
     5831: 4392:	if ( infilename && gen_line_dirs )
branch  0 taken 5831 (fallthrough)
branch  1 taken 0
branch  2 taken 5794 (fallthrough)
branch  3 taken 37
        -: 4393:		{
        -: 4394:		char directive[MAXLINE];
     5794: 4395:		sprintf( directive, "# line %d \"%s\"\n", linenum, infilename );
        -: 4396:
        -: 4397:		/* If output_file is nil then we should put the directive in
        -: 4398:		 * the accumulated actions.
        -: 4399:		 */
     5794: 4400:		if ( output_file )
branch  0 taken 540 (fallthrough)
branch  1 taken 5254
      540: 4401:			fputs( directive, output_file );
call    0 returned 540
        -: 4402:		else
     5254: 4403:			add_action( directive );
call    0 returned 5254
        -: 4404:		}
     5831: 4405:	}
        -: 4406:
        -: 4407:
        -: 4408:/* mark_defs1 - mark the current position in the action array as
        -: 4409: *               representing where the user's section 1 definitions end
        -: 4410: *		 and the prolog begins
        -: 4411: */
function mark_defs1 called 552 returned 100% blocks executed 100%
      552: 4412:void mark_defs1()
        -: 4413:	{
      552: 4414:	defs1_offset = 0;
      552: 4415:	action_array[action_index++] = '\0';
      552: 4416:	action_offset = prolog_offset = action_index;
      552: 4417:	action_array[action_index] = '\0';
      552: 4418:	}
        -: 4419:
        -: 4420:
        -: 4421:/* mark_prolog - mark the current position in the action array as
        -: 4422: *               representing the end of the action prolog
        -: 4423: */
function mark_prolog called 552 returned 100% blocks executed 100%
      552: 4424:void mark_prolog()
        -: 4425:	{
      552: 4426:	action_array[action_index++] = '\0';
      552: 4427:	action_offset = action_index;
      552: 4428:	action_array[action_index] = '\0';
      552: 4429:	}
        -: 4430:
        -: 4431:
        -: 4432:/* mk2data - generate a data statement for a two-dimensional array
        -: 4433: *
        -: 4434: * Generates a data statement initializing the current 2-D array to "value".
        -: 4435: */
function mk2data called 70116 returned 100% blocks executed 100%
    70116: 4436:void mk2data( value )
        -: 4437:int value;
        -: 4438:	{
    70116: 4439:	if ( datapos >= NUMDATAITEMS )
branch  0 taken 7113 (fallthrough)
branch  1 taken 63003
        -: 4440:		{
     7113: 4441:		putchar( ',' );
call    0 returned 7113
     7113: 4442:		dataflush();
call    0 returned 7113
        -: 4443:		}
        -: 4444:
    70116: 4445:	if ( datapos == 0 )
branch  0 taken 7136 (fallthrough)
branch  1 taken 62980
        -: 4446:		/* Indent. */
     7136: 4447:		fputs( "    ", stdout );
call    0 returned 7136
        -: 4448:
        -: 4449:	else
    62980: 4450:		putchar( ',' );
call    0 returned 62980
        -: 4451:
    70116: 4452:	++datapos;
        -: 4453:
    70116: 4454:	printf( "%5d", value );
call    0 returned 70116
    70116: 4455:	}
        -: 4456:
        -: 4457:
        -: 4458:/* mkdata - generate a data statement
        -: 4459: *
        -: 4460: * Generates a data statement initializing the current array element to
        -: 4461: * "value".
        -: 4462: */
function mkdata called 469033 returned 100% blocks executed 100%
   469033: 4463:void mkdata( value )
        -: 4464:int value;
        -: 4465:	{
   469033: 4466:	if ( datapos >= NUMDATAITEMS )
branch  0 taken 45212 (fallthrough)
branch  1 taken 423821
        -: 4467:		{
    45212: 4468:		putchar( ',' );
call    0 returned 45212
    45212: 4469:		dataflush();
call    0 returned 45212
        -: 4470:		}
        -: 4471:
   469033: 4472:	if ( datapos == 0 )
branch  0 taken 48500 (fallthrough)
branch  1 taken 420533
        -: 4473:		/* Indent. */
    48500: 4474:		fputs( "    ", stdout );
call    0 returned 48500
        -: 4475:	else
   420533: 4476:		putchar( ',' );
call    0 returned 420533
        -: 4477:
   469033: 4478:	++datapos;
        -: 4479:
   469033: 4480:	printf( "%5d", value );
call    0 returned 469033
   469033: 4481:	}
        -: 4482:
        -: 4483:
        -: 4484:/* myctoi - return the integer represented by a string of digits */
        -: 4485:
function myctoi called 396 returned 100% blocks executed 100%
      396: 4486:int myctoi( array )
        -: 4487:char array[];
        -: 4488:	{
      396: 4489:	int val = 0;
        -: 4490:
      396: 4491:	(void) sscanf( array, "%d", &val );
        -: 4492:
      396: 4493:	return val;
        -: 4494:	}
        -: 4495:
        -: 4496:
        -: 4497:/* myesc - return character corresponding to escape sequence */
        -: 4498:
function myesc called 591 returned 100% blocks executed 100%
      591: 4499:Char myesc( array )
        -: 4500:Char array[];
        -: 4501:	{
        -: 4502:	Char c, esc_char;
        -: 4503:
      591: 4504:	switch ( array[1] )
branch  0 taken 1
branch  1 taken 1
branch  2 taken 337
branch  3 taken 1
branch  4 taken 122
branch  5 taken 4
branch  6 taken 1
branch  7 taken 20
branch  8 taken 3
branch  9 taken 101
        -: 4505:		{
        1: 4506:		case 'b': return '\b';
        1: 4507:		case 'f': return '\f';
      337: 4508:		case 'n': return '\n';
        1: 4509:		case 'r': return '\r';
      122: 4510:		case 't': return '\t';
        -: 4511:
        -: 4512:#ifdef __STDC__
        4: 4513:		case 'a': return '\a';
        1: 4514:		case 'v': return '\v';
        -: 4515:#else
        -: 4516:		case 'a': return '\007';
        -: 4517:		case 'v': return '\013';
        -: 4518:#endif
        -: 4519:
       20: 4520:		case '0':
        -: 4521:		case '1':
        -: 4522:		case '2':
        -: 4523:		case '3':
        -: 4524:		case '4':
        -: 4525:		case '5':
        -: 4526:		case '6':
        -: 4527:		case '7':
        -: 4528:		case '8':
        -: 4529:		case '9':
        -: 4530:			{ /* \<octal> */
       20: 4531:			int sptr = 1;
        -: 4532:
       69: 4533:			while ( isascii( array[sptr] ) &&
branch  0 taken 69 (fallthrough)
branch  1 taken 0
       69: 4534:				isdigit( array[sptr] ) )
branch  0 taken 49
branch  1 taken 20 (fallthrough)
        -: 4535:				/* Don't increment inside loop control
        -: 4536:				 * because if isdigit() is a macro it might
        -: 4537:				 * expand into multiple increments ...
        -: 4538:				 */
       49: 4539:				++sptr;
        -: 4540:
       20: 4541:			c = array[sptr];
       20: 4542:			array[sptr] = '\0';
        -: 4543:
       20: 4544:			esc_char = otoi( array + 1 );
call    0 returned 20
        -: 4545:
       20: 4546:			array[sptr] = c;
        -: 4547:
       20: 4548:			return esc_char;
        -: 4549:			}
        -: 4550:
        3: 4551:		case 'x':
        -: 4552:			{ /* \x<hex> */
        3: 4553:			int sptr = 2;
        -: 4554:
       14: 4555:			while ( isascii( array[sptr] ) &&
branch  0 taken 7 (fallthrough)
branch  1 taken 0
branch  2 taken 4
branch  3 taken 3 (fallthrough)
        7: 4556:				is_hex_digit( (char) array[sptr] ) )
call    0 returned 7
        -: 4557:				/* Don't increment inside loop control
        -: 4558:				 * because if isdigit() is a macro it might
        -: 4559:				 * expand into multiple increments ...
        -: 4560:				 */
        4: 4561:				++sptr;
        -: 4562:
        3: 4563:			c = array[sptr];
        3: 4564:			array[sptr] = '\0';
        -: 4565:
        3: 4566:			esc_char = htoi( array + 2 );
call    0 returned 3
        -: 4567:
        3: 4568:			array[sptr] = c;
        -: 4569:
        3: 4570:			return esc_char;
        -: 4571:			}
        -: 4572:
      101: 4573:		default:
      101: 4574:			return array[1];
        -: 4575:		}
        -: 4576:	}
        -: 4577:
        -: 4578:
        -: 4579:/* otoi - convert an octal digit string to an integer value */
        -: 4580:
function otoi called 20 returned 100% blocks executed 100%
       20: 4581:int otoi( str )
        -: 4582:Char str[];
        -: 4583:	{
        -: 4584:	unsigned int result;
        -: 4585:
       20: 4586:	(void) sscanf( (char *) str, "%o", &result );
       20: 4587:	return result;
        -: 4588:	}
        -: 4589:
        -: 4590:
        -: 4591:/* readable_form - return the the human-readable form of a character
        -: 4592: *
        -: 4593: * The returned string is in static storage.
        -: 4594: */
        -: 4595:
function readable_form called 3477 returned 100% blocks executed 100%
     3477: 4596:char *readable_form( c )
        -: 4597:register int c;
        -: 4598:	{
        -: 4599:	static char rform[10];
        -: 4600:
     3477: 4601:	if ( (c >= 0 && c < 32) || c >= 127 )
branch  0 taken 3477 (fallthrough)
branch  1 taken 0
branch  2 taken 3013 (fallthrough)
branch  3 taken 464
branch  4 taken 1683 (fallthrough)
branch  5 taken 1330
        -: 4602:		{
     2147: 4603:		switch ( c )
branch  0 taken 14
branch  1 taken 14
branch  2 taken 18
branch  3 taken 14
branch  4 taken 18
branch  5 taken 14
branch  6 taken 18
branch  7 taken 2037
        -: 4604:			{
       14: 4605:			case '\b': return "\\b";
       14: 4606:			case '\f': return "\\f";
       18: 4607:			case '\n': return "\\n";
       14: 4608:			case '\r': return "\\r";
       18: 4609:			case '\t': return "\\t";
        -: 4610:
        -: 4611:#ifdef __STDC__
       14: 4612:			case '\a': return "\\a";
       18: 4613:			case '\v': return "\\v";
        -: 4614:#endif
        -: 4615:
     2037: 4616:			default:
     2037: 4617:				(void) sprintf( rform, "\\%.3o",
        -: 4618:						(unsigned int) c );
     2037: 4619:				return rform;
        -: 4620:			}
        -: 4621:		}
        -: 4622:
     1330: 4623:	else if ( c == ' ' )
branch  0 taken 14 (fallthrough)
branch  1 taken 1316
       14: 4624:		return "' '";
        -: 4625:
        -: 4626:	else
        -: 4627:		{
     1316: 4628:		rform[0] = c;
     1316: 4629:		rform[1] = '\0';
        -: 4630:
     1316: 4631:		return rform;
        -: 4632:		}
        -: 4633:	}
        -: 4634:
        -: 4635:
        -: 4636:/* reallocate_array - increase the size of a dynamic array */
        -: 4637:
function reallocate_array called 171 returned 100% blocks executed 71%
      171: 4638:void *reallocate_array( array, size, element_size )
        -: 4639:void *array;
        -: 4640:int size, element_size;
        -: 4641:	{
        -: 4642:	register void *new_array;
        -: 4643:
        -: 4644:	/* Same worry as in allocate_array(): */
      171: 4645:	if ( size * element_size <= 0 )
branch  0 taken 0 (fallthrough)
branch  1 taken 171
    #####: 4646:		flexfatal(
call    0 never executed
        -: 4647:			"attempt to increase array size by less than 1 byte" );
        -: 4648:
      171: 4649:	new_array = flex_realloc( array, size * element_size );
call    0 returned 171
        -: 4650:
      171: 4651:	if ( new_array == NULL )
branch  0 taken 0 (fallthrough)
branch  1 taken 171
    #####: 4652:		flexfatal( "attempt to increase array size failed" );
call    0 never executed
        -: 4653:
      171: 4654:	return new_array;
        -: 4655:	}
        -: 4656:
        -: 4657:
        -: 4658:/* skelout - write out one section of the skeleton file
        -: 4659: *
        -: 4660: * Description
        -: 4661: *    Copies skelfile or skel array to stdout until a line beginning with
        -: 4662: *    "%%" or EOF is found.
        -: 4663: */
function skelout called 9783 returned 100% blocks executed 95%
     9783: 4664:void skelout()
        -: 4665:	{
        -: 4666:	char buf_storage[MAXLINE];
     9783: 4667:	char *buf = buf_storage;
     9783: 4668:	int do_copy = 1;
        -: 4669:
        -: 4670:	/* Loop pulling lines either from the skelfile, if we're using
        -: 4671:	 * one, or from the skel[] array.
        -: 4672:	 */
  1332154: 4673:	while ( skelfile ?
branch  0 taken 38 (fallthrough)
branch  1 taken 666039
branch  2 taken 665500
branch  3 taken 577 (fallthrough)
       38: 4674:		(fgets( buf, MAXLINE, skelfile ) != NULL) :
call    0 returned 38
   666039: 4675:		((buf = skel[skel_ind++]) != 0) )
        -: 4676:		{ /* copy from skel array */
   665500: 4677:		if ( buf[0] == '%' )
branch  0 taken 54767 (fallthrough)
branch  1 taken 610733
        -: 4678:			{ /* control line */
    54767: 4679:			switch ( buf[1] )
branch  0 taken 9206
branch  1 taken 13543
branch  2 taken 15193
branch  3 taken 16825
branch  4 taken 0
        -: 4680:				{
     9206: 4681:				case '%':
     9206: 4682:					return;
        -: 4683:
    13543: 4684:				case '+':
    13543: 4685:					do_copy = C_plus_plus;
    13543: 4686:					break;
        -: 4687:
    15193: 4688:				case '-':
    15193: 4689:					do_copy = ! C_plus_plus;
    15193: 4690:					break;
        -: 4691:
    16825: 4692:				case '*':
    16825: 4693:					do_copy = 1;
    16825: 4694:					break;
        -: 4695:
    #####: 4696:				default:
    #####: 4697:					flexfatal(
call    0 never executed
        -: 4698:						"bad line in skeleton file" );
        -: 4699:				}
        -: 4700:			}
        -: 4701:
   610733: 4702:		else if ( do_copy )
branch  0 taken 576091 (fallthrough)
branch  1 taken 34642
        -: 4703:			{
   576091: 4704:			if ( skelfile )
branch  0 taken 2 (fallthrough)
branch  1 taken 576089
        -: 4705:				/* Skeleton file reads include final
        -: 4706:				 * newline, skel[] array does not.
        -: 4707:				 */
        2: 4708:				fputs( buf, stdout );
call    0 returned 2
        -: 4709:			else
   576089: 4710:				printf( "%s\n", buf );
call    0 returned 576089
        -: 4711:			}
        -: 4712:		}
        -: 4713:	}
        -: 4714:
        -: 4715:
        -: 4716:/* transition_struct_out - output a yy_trans_info structure
        -: 4717: *
        -: 4718: * outputs the yy_trans_info structure with the two elements, element_v and
        -: 4719: * element_n.  Formats the output with spaces and carriage returns.
        -: 4720: */
        -: 4721:
function transition_struct_out called 55697 returned 100% blocks executed 100%
    55697: 4722:void transition_struct_out( element_v, element_n )
        -: 4723:int element_v, element_n;
        -: 4724:	{
    55697: 4725:	printf( "%7d, %5d,", element_v, element_n );
call    0 returned 55697
        -: 4726:
    55697: 4727:	datapos += TRANS_STRUCT_PRINT_LENGTH;
        -: 4728:
    55697: 4729:	if ( datapos >= 75 )
branch  0 taken 11103 (fallthrough)
branch  1 taken 44594
        -: 4730:		{
    11103: 4731:		putchar( '\n' );
call    0 returned 11103
        -: 4732:
    11103: 4733:		if ( ++dataline % 10 == 0 )
branch  0 taken 1062 (fallthrough)
branch  1 taken 10041
     1062: 4734:			putchar( '\n' );
call    0 returned 1062
        -: 4735:
    11103: 4736:		datapos = 0;
        -: 4737:		}
    55697: 4738:	}
        -: 4739:
        -: 4740:
        -: 4741:/* The following is only needed when building flex's parser using certain
        -: 4742: * broken versions of bison.
        -: 4743: */
function yy_flex_xmalloc called 0 returned 0% blocks executed 0%
    #####: 4744:void *yy_flex_xmalloc( size )
        -: 4745:int size;
        -: 4746:	{
        -: 4747:
        -: 4748:#ifndef F_AA_5
    #####: 4749:	void *result = flex_alloc( size );
call    0 never executed
        -: 4750:#else
        -: 4751:	void *result = yy_flex_alloc( size );
        -: 4752:#endif
    #####: 4753:	if ( ! result  )
branch  0 never executed
branch  1 never executed
    #####: 4754:		flexfatal( "memory allocation failed in yy_flex_xmalloc()" );
call    0 never executed
        -: 4755:
    #####: 4756:	return result;
        -: 4757:	}
        -: 4758:
        -: 4759:
        -: 4760:/* zero_out - set a region of memory to 0
        -: 4761: *
        -: 4762: * Sets region_ptr[0] through region_ptr[size_in_bytes - 1] to zero.
        -: 4763: */
        -: 4764:
function zero_out called 575 returned 100% blocks executed 100%
      575: 4765:void zero_out( region_ptr, size_in_bytes )
        -: 4766:char *region_ptr;
        -: 4767:int size_in_bytes;
        -: 4768:	{
        -: 4769:	register char *rp, *rp_end;
        -: 4770:
      575: 4771:	rp = region_ptr;
      575: 4772:	rp_end = region_ptr + size_in_bytes;
        -: 4773:
  4600575: 4774:	while ( rp < rp_end )
branch  0 taken 4600000
branch  1 taken 575 (fallthrough)
  4600000: 4775:		*rp++ = 0;
      575: 4776:	}
        -: 4777:/* nfa - NFA construction routines */
        -: 4778:
        -: 4779:/*-
        -: 4780: * Copyright (c) 1990 The Regents of the University of California.
        -: 4781: * All rights reserved.
        -: 4782: *
        -: 4783: * This code is derived from software contributed to Berkeley by
        -: 4784: * Vern Paxson.
        -: 4785: * 
        -: 4786: * The United States Government has rights in this work pursuant
        -: 4787: * to contract no. DE-AC03-76SF00098 between the United States
        -: 4788: * Department of Energy and the University of California.
        -: 4789: *
        -: 4790: * Redistribution and use in source and binary forms are permitted provided
        -: 4791: * that: (1) source distributions retain this entire copyright notice and
        -: 4792: * comment, and (2) distributions including binaries display the following
        -: 4793: * acknowledgement:  ``This product includes software developed by the
        -: 4794: * University of California, Berkeley and its contributors'' in the
        -: 4795: * documentation or other materials provided with the distribution and in
        -: 4796: * all advertising materials mentioning features or use of this software.
        -: 4797: * Neither the name of the University nor the names of its contributors may
        -: 4798: * be used to endorse or promote products derived from this software without
        -: 4799: * specific prior written permission.
        -: 4800: * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
        -: 4801: * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
        -: 4802: * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
        -: 4803: */
        -: 4804:
        -: 4805:/* $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.seeded/v1/flex.c,v 1.1.1.2 2003/09/02 20:21:59 expsir Exp $ */
        -: 4806:
        -: 4807:
        -: 4808:
        -: 4809:/* declare functions that have forward references */
        -: 4810:
        -: 4811:int dupmachine PROTO((int));
        -: 4812:void mkxtion PROTO((int, int));
        -: 4813:
        -: 4814:
        -: 4815:/* add_accept - add an accepting state to a machine
        -: 4816: *
        -: 4817: * accepting_number becomes mach's accepting number.
        -: 4818: */
        -: 4819:
function add_accept called 4122 returned 100% blocks executed 100%
     4122: 4820:void add_accept( mach, accepting_number )
        -: 4821:int mach, accepting_number;
        -: 4822:	{
        -: 4823:	/* Hang the accepting number off an epsilon state.  if it is associated
        -: 4824:	 * with a state that has a non-epsilon out-transition, then the state
        -: 4825:	 * will accept BEFORE it makes that transition, i.e., one character
        -: 4826:	 * too soon.
        -: 4827:	 */
        -: 4828:
     4122: 4829:	if ( transchar[finalst[mach]] == SYM_EPSILON )
branch  0 taken 1405 (fallthrough)
branch  1 taken 2717
     1405: 4830:		accptnum[finalst[mach]] = accepting_number;
        -: 4831:
        -: 4832:	else
        -: 4833:		{
     2717: 4834:		int astate = mkstate( SYM_EPSILON );
call    0 returned 2717
     2717: 4835:		accptnum[astate] = accepting_number;
     2717: 4836:		(void) link_machines( mach, astate );
call    0 returned 2717
        -: 4837:		}
     4122: 4838:	}
        -: 4839:
        -: 4840:
        -: 4841:/* copysingl - make a given number of copies of a singleton machine
        -: 4842: *
        -: 4843: * synopsis
        -: 4844: *
        -: 4845: *   newsng = copysingl( singl, num );
        -: 4846: *
        -: 4847: *     newsng - a new singleton composed of num copies of singl
        -: 4848: *     singl  - a singleton machine
        -: 4849: *     num    - the number of copies of singl to be present in newsng
        -: 4850: */
        -: 4851:
function copysingl called 296 returned 100% blocks executed 100%
      296: 4852:int copysingl( singl, num )
        -: 4853:int singl, num;
        -: 4854:	{
        -: 4855:	int copy, i;
        -: 4856:
      296: 4857:	copy = mkstate( SYM_EPSILON );
call    0 returned 296
        -: 4858:
      786: 4859:	for ( i = 1; i <= num; ++i )
branch  0 taken 490
branch  1 taken 296 (fallthrough)
      490: 4860:		copy = link_machines( copy, dupmachine( singl ) );
call    0 returned 490
call    1 returned 490
        -: 4861:
      296: 4862:	return copy;
        -: 4863:	}
        -: 4864:
        -: 4865:
        -: 4866:/* dumpnfa - debugging routine to write out an nfa */
        -: 4867:
function dumpnfa called 14 returned 100% blocks executed 100%
       14: 4868:void dumpnfa( state1 )
        -: 4869:int state1;
        -: 4870:
        -: 4871:	{
        -: 4872:	int sym, tsp1, tsp2, anum, ns;
        -: 4873:
       14: 4874:	fprintf( err,
call    0 returned 14
        -: 4875:		"\n\n********** beginning dump of nfa with start state %d\n",
        -: 4876:		state1 );
        -: 4877:
        -: 4878:	/* We probably should loop starting at firstst[state1] and going to
        -: 4879:	 * lastst[state1], but they're not maintained properly when we "or"
        -: 4880:	 * all of the rules together.  So we use our knowledge that the machine
        -: 4881:	 * starts at state 1 and ends at lastnfa.
        -: 4882:	 */
        -: 4883:
        -: 4884:	/* for ( ns = firstst[state1]; ns <= lastst[state1]; ++ns ) */
     4072: 4885:	for ( ns = 1; ns <= lastnfa; ++ns )
branch  0 taken 4058
branch  1 taken 14 (fallthrough)
        -: 4886:		{
     4058: 4887:		fprintf( err, "state # %4d\t", ns );
call    0 returned 4058
        -: 4888:
     4058: 4889:		sym = transchar[ns];
     4058: 4890:		tsp1 = trans1[ns];
     4058: 4891:		tsp2 = trans2[ns];
     4058: 4892:		anum = accptnum[ns];
        -: 4893:
     4058: 4894:		fprintf( err, "%3d:  %4d, %4d", sym, tsp1, tsp2 );
call    0 returned 4058
        -: 4895:
     4058: 4896:		if ( anum != NIL )
branch  0 taken 639 (fallthrough)
branch  1 taken 3419
      639: 4897:			fprintf( err, "  [%d]", anum );
call    0 returned 639
        -: 4898:
     4058: 4899:		fprintf( err, "\n" );
call    0 returned 4058
        -: 4900:		}
        -: 4901:
       14: 4902:	fprintf( err, "********** end of dump\n" );
call    0 returned 14
       14: 4903:	}
        -: 4904:
        -: 4905:
        -: 4906:/* dupmachine - make a duplicate of a given machine
        -: 4907: *
        -: 4908: * synopsis
        -: 4909: *
        -: 4910: *   copy = dupmachine( mach );
        -: 4911: *
        -: 4912: *     copy - holds duplicate of mach
        -: 4913: *     mach - machine to be duplicated
        -: 4914: *
        -: 4915: * note that the copy of mach is NOT an exact duplicate; rather, all the
        -: 4916: * transition states values are adjusted so that the copy is self-contained,
        -: 4917: * as the original should have been.
        -: 4918: *
        -: 4919: * also note that the original MUST be contiguous, with its low and high
        -: 4920: * states accessible by the arrays firstst and lastst
        -: 4921: */
        -: 4922:
function dupmachine called 886 returned 100% blocks executed 62%
      886: 4923:int dupmachine( mach )
        -: 4924:int mach;
        -: 4925:	{
        -: 4926:	int i, init, state_offset;
      886: 4927:	int state = 0;
      886: 4928:	int last = lastst[mach];
        -: 4929:
     1772: 4930:	for ( i = firstst[mach]; i <= last; ++i )
branch  0 taken 886
branch  1 taken 886 (fallthrough)
        -: 4931:		{
      886: 4932:		state = mkstate( transchar[i] );
call    0 returned 886
        -: 4933:
      886: 4934:		if ( trans1[i] != NO_TRANSITION )
branch  0 taken 0 (fallthrough)
branch  1 taken 886
        -: 4935:			{
    #####: 4936:			mkxtion( finalst[state], trans1[i] + state - i );
call    0 never executed
        -: 4937:
    #####: 4938:			if ( transchar[i] == SYM_EPSILON &&
branch  0 never executed
branch  1 never executed
    #####: 4939:			     trans2[i] != NO_TRANSITION )
branch  0 never executed
branch  1 never executed
    #####: 4940:				mkxtion( finalst[state],
    #####: 4941:					trans2[i] + state - i );
call    0 never executed
        -: 4942:			}
        -: 4943:
      886: 4944:		accptnum[state] = accptnum[i];
        -: 4945:		}
        -: 4946:
      886: 4947:	if ( state == 0 )
branch  0 taken 0 (fallthrough)
branch  1 taken 886
    #####: 4948:		flexfatal( "empty machine in dupmachine()" );
call    0 never executed
        -: 4949:
      886: 4950:	state_offset = state - i + 1;
        -: 4951:
      886: 4952:	init = mach + state_offset;
      886: 4953:	firstst[init] = firstst[mach] + state_offset;
      886: 4954:	finalst[init] = finalst[mach] + state_offset;
      886: 4955:	lastst[init] = lastst[mach] + state_offset;
        -: 4956:
      886: 4957:	return init;
        -: 4958:	}
        -: 4959:
        -: 4960:
        -: 4961:/* finish_rule - finish up the processing for a rule
        -: 4962: *
        -: 4963: * An accepting number is added to the given machine.  If variable_trail_rule
        -: 4964: * is true then the rule has trailing context and both the head and trail
        -: 4965: * are variable size.  Otherwise if headcnt or trailcnt is non-zero then
        -: 4966: * the machine recognizes a pattern with trailing context and headcnt is
        -: 4967: * the number of characters in the matched part of the pattern, or zero
        -: 4968: * if the matched part has variable length.  trailcnt is the number of
        -: 4969: * trailing context characters in the pattern, or zero if the trailing
        -: 4970: * context has variable length.
        -: 4971: */
        -: 4972:
function finish_rule called 4058 returned 100% blocks executed 100%
     4058: 4973:void finish_rule( mach, variable_trail_rule, headcnt, trailcnt )
        -: 4974:int mach, variable_trail_rule, headcnt, trailcnt;
        -: 4975:	{
        -: 4976:	char action_text[MAXLINE];
        -: 4977:
     4058: 4978:	add_accept( mach, num_rules );
call    0 returned 4058
        -: 4979:
        -: 4980:	/* We did this in new_rule(), but it often gets the wrong
        -: 4981:	 * number because we do it before we start parsing the current rule.
        -: 4982:	 */
     4058: 4983:	rule_linenum[num_rules] = linenum;
        -: 4984:
        -: 4985:	/* If this is a continued action, then the line-number has already
        -: 4986:	 * been updated, giving us the wrong number.
        -: 4987:	 */
     4058: 4988:	if ( continued_action )
branch  0 taken 11 (fallthrough)
branch  1 taken 4047
       11: 4989:		--rule_linenum[num_rules];
        -: 4990:
     4058: 4991:	sprintf( action_text, "case %d:\n", num_rules );
     4058: 4992:	add_action( action_text );
call    0 returned 4058
        -: 4993:
     4058: 4994:	if ( variable_trail_rule )
branch  0 taken 64 (fallthrough)
branch  1 taken 3994
        -: 4995:		{
       64: 4996:		rule_type[num_rules] = RULE_VARIABLE;
        -: 4997:
       64: 4998:		if ( performance_report > 0 )
branch  0 taken 1 (fallthrough)
branch  1 taken 63
        1: 4999:			fprintf( err,
        -: 5000:				"Variable trailing context rule at line %d\n",
        1: 5001:				rule_linenum[num_rules] );
call    0 returned 1
        -: 5002:
       64: 5003:		variable_trailing_context_rules = true;
        -: 5004:		}
        -: 5005:
        -: 5006:	else
        -: 5007:		{
     3994: 5008:		rule_type[num_rules] = RULE_NORMAL;
        -: 5009:
     3994: 5010:		if ( headcnt > 0 || trailcnt > 0 )
branch  0 taken 3917 (fallthrough)
branch  1 taken 77
branch  2 taken 72 (fallthrough)
branch  3 taken 3845
        -: 5011:			{
        -: 5012:			/* Do trailing context magic to not match the trailing
        -: 5013:			 * characters.
        -: 5014:			 */
      149: 5015:			char *scanner_cp = "yy_c_buf_p = yy_cp";
      149: 5016:			char *scanner_bp = "yy_bp";
        -: 5017:
      149: 5018:			add_action(
call    0 returned 149
        -: 5019:	"*yy_cp = yy_hold_char; /* undo effects of setting up yytext */\n" );
        -: 5020:
      149: 5021:			if ( headcnt > 0 )
branch  0 taken 77 (fallthrough)
branch  1 taken 72
        -: 5022:				{
       77: 5023:				sprintf( action_text, "%s = %s + %d;\n",
        -: 5024:				scanner_cp, scanner_bp, headcnt );
       77: 5025:				add_action( action_text );
call    0 returned 77
        -: 5026:				}
        -: 5027:
        -: 5028:			else
        -: 5029:				{
       72: 5030:				sprintf( action_text, "%s -= %d;\n",
        -: 5031:					scanner_cp, trailcnt );
       72: 5032:				add_action( action_text );
call    0 returned 72
        -: 5033:				}
        -: 5034:
      149: 5035:			add_action(
call    0 returned 149
        -: 5036:			"YY_DO_BEFORE_ACTION; /* set up yytext again */\n" );
        -: 5037:			}
        -: 5038:		}
        -: 5039:
        -: 5040:	/* Okay, in the action code at this point yytext and yyleng have
        -: 5041:	 * their proper final values for this rule, so here's the point
        -: 5042:	 * to do any user action.  But don't do it for continued actions,
        -: 5043:	 * as that'll result in multiple YY_USER_ACTION's.
        -: 5044:	 */
        -: 5045:#ifndef F_AA_1	
     4058: 5046:	if ( ! continued_action )
branch  0 taken 4047 (fallthrough)
branch  1 taken 11
        -: 5047:#else 
        -: 5048:	if ( continued_action )
        -: 5049:#endif
        -: 5050:#ifndef F_JR_2
     4047: 5051:        add_action( "YY_USER_ACTION\n" );
call    0 returned 4047
        -: 5052:#else
        -: 5053:        add_action( "YY_USER_ACTION" );
        -: 5054:#endif
        -: 5055:
     4058: 5056:	line_directive_out( (FILE *) 0 );
call    0 returned 4058
     4058: 5057:	}
        -: 5058:
        -: 5059:
        -: 5060:/* link_machines - connect two machines together
        -: 5061: *
        -: 5062: * synopsis
        -: 5063: *
        -: 5064: *   new = link_machines( first, last );
        -: 5065: *
        -: 5066: *     new    - a machine constructed by connecting first to last
        -: 5067: *     first  - the machine whose successor is to be last
        -: 5068: *     last   - the machine whose predecessor is to be first
        -: 5069: *
        -: 5070: * note: this routine concatenates the machine first with the machine
        -: 5071: *  last to produce a machine new which will pattern-match first first
        -: 5072: *  and then last, and will fail if either of the sub-patterns fails.
        -: 5073: *  FIRST is set to new by the operation.  last is unmolested.
        -: 5074: */
        -: 5075:
function link_machines called 18374 returned 100% blocks executed 71%
    18374: 5076:int link_machines( first, last )
        -: 5077:int first, last;
        -: 5078:	{
    18374: 5079:	if ( first == NIL )
branch  0 taken 0 (fallthrough)
branch  1 taken 18374
    #####: 5080:		return last;
        -: 5081:
    18374: 5082:	else if ( last == NIL )
branch  0 taken 0 (fallthrough)
branch  1 taken 18374
    #####: 5083:		return first;
        -: 5084:
        -: 5085:	else
        -: 5086:		{
    18374: 5087:		mkxtion( finalst[first], last );
call    0 returned 18374
    18374: 5088:		finalst[first] = finalst[last];
    18374: 5089:		lastst[first] = MAX( lastst[first], lastst[last] );
    18374: 5090:		firstst[first] = MIN( firstst[first], firstst[last] );
        -: 5091:
    18374: 5092:		return first;
        -: 5093:		}
        -: 5094:	}
        -: 5095:
        -: 5096:
        -: 5097:/* mark_beginning_as_normal - mark each "beginning" state in a machine
        -: 5098: *                            as being a "normal" (i.e., not trailing context-
        -: 5099: *                            associated) states
        -: 5100: *
        -: 5101: * The "beginning" states are the epsilon closure of the first state
        -: 5102: */
        -: 5103:
function mark_beginning_as_normal called 110 returned 100% blocks executed 36%
      110: 5104:void mark_beginning_as_normal( mach )
        -: 5105:register int mach;
        -: 5106:	{
      110: 5107:	switch ( state_type[mach] )
branch  0 taken 0
branch  1 taken 110
branch  2 taken 0
        -: 5108:		{
    #####: 5109:		case STATE_NORMAL:
        -: 5110:			/* Oh, we've already visited here. */
    #####: 5111:			return;
        -: 5112:
      110: 5113:		case STATE_TRAILING_CONTEXT:
      110: 5114:			state_type[mach] = STATE_NORMAL;
        -: 5115:
      110: 5116:			if ( transchar[mach] == SYM_EPSILON )
branch  0 taken 0 (fallthrough)
branch  1 taken 110
        -: 5117:				{
    #####: 5118:				if ( trans1[mach] != NO_TRANSITION )
branch  0 never executed
branch  1 never executed
    #####: 5119:					mark_beginning_as_normal(
    #####: 5120:						trans1[mach] );
call    0 never executed
        -: 5121:
    #####: 5122:				if ( trans2[mach] != NO_TRANSITION )
branch  0 never executed
branch  1 never executed
    #####: 5123:					mark_beginning_as_normal(
    #####: 5124:						trans2[mach] );
call    0 never executed
        -: 5125:				}
      110: 5126:			break;
        -: 5127:
    #####: 5128:		default:
    #####: 5129:			flexerror(
call    0 never executed
        -: 5130:				"bad state type in mark_beginning_as_normal()" );
    #####: 5131:			break;
        -: 5132:		}
        -: 5133:	}
        -: 5134:
        -: 5135:
        -: 5136:/* mkbranch - make a machine that branches to two machines
        -: 5137: *
        -: 5138: * synopsis
        -: 5139: *
        -: 5140: *   branch = mkbranch( first, second );
        -: 5141: *
        -: 5142: *     branch - a machine which matches either first's pattern or second's
        -: 5143: *     first, second - machines whose patterns are to be or'ed (the | operator)
        -: 5144: *
        -: 5145: * Note that first and second are NEITHER destroyed by the operation.  Also,
        -: 5146: * the resulting machine CANNOT be used with any other "mk" operation except
        -: 5147: * more mkbranch's.  Compare with mkor()
        -: 5148: */
        -: 5149:
function mkbranch called 4671 returned 100% blocks executed 78%
     4671: 5150:int mkbranch( first, second )
        -: 5151:int first, second;
        -: 5152:	{
        -: 5153:	int eps;
        -: 5154:
     4671: 5155:	if ( first == NO_TRANSITION )
branch  0 taken 0 (fallthrough)
branch  1 taken 4671
    #####: 5156:		return second;
        -: 5157:
     4671: 5158:	else if ( second == NO_TRANSITION )
branch  0 taken 0 (fallthrough)
branch  1 taken 4671
    #####: 5159:		return first;
        -: 5160:
     4671: 5161:	eps = mkstate( SYM_EPSILON );
call    0 returned 4671
        -: 5162:
     4671: 5163:	mkxtion( eps, first );
call    0 returned 4671
     4671: 5164:	mkxtion( eps, second );
call    0 returned 4671
        -: 5165:
     4671: 5166:	return eps;
        -: 5167:	}
        -: 5168:
        -: 5169:
        -: 5170:/* mkclos - convert a machine into a closure
        -: 5171: *
        -: 5172: * synopsis
        -: 5173: *   new = mkclos( state );
        -: 5174: *
        -: 5175: * new - a new state which matches the closure of "state"
        -: 5176: */
        -: 5177:
function mkclos called 940 returned 100% blocks executed 100%
      940: 5178:int mkclos( state )
        -: 5179:int state;
        -: 5180:	{
      940: 5181:	return mkopt( mkposcl( state ) );
call    0 returned 940
call    1 returned 940
        -: 5182:	}
        -: 5183:
        -: 5184:
        -: 5185:/* mkopt - make a machine optional
        -: 5186: *
        -: 5187: * synopsis
        -: 5188: *
        -: 5189: *   new = mkopt( mach );
        -: 5190: *
        -: 5191: *     new  - a machine which optionally matches whatever mach matched
        -: 5192: *     mach - the machine to make optional
        -: 5193: *
        -: 5194: * notes:
        -: 5195: *     1. mach must be the last machine created
        -: 5196: *     2. mach is destroyed by the call
        -: 5197: */
        -: 5198:
function mkopt called 1242 returned 100% blocks executed 100%
     1242: 5199:int mkopt( mach )
        -: 5200:int mach;
        -: 5201:	{
        -: 5202:	int eps;
        -: 5203:
     1242: 5204:	if ( ! SUPER_FREE_EPSILON(finalst[mach]) )
branch  0 taken 1240 (fallthrough)
branch  1 taken 2
branch  2 taken 940 (fallthrough)
branch  3 taken 300
        -: 5205:		{
      942: 5206:		eps = mkstate( SYM_EPSILON );
call    0 returned 942
      942: 5207:		mach = link_machines( mach, eps );
call    0 returned 942
        -: 5208:		}
        -: 5209:
        -: 5210:	/* Can't skimp on the following if FREE_EPSILON(mach) is true because
        -: 5211:	 * some state interior to "mach" might point back to the beginning
        -: 5212:	 * for a closure.
        -: 5213:	 */
     1242: 5214:	eps = mkstate( SYM_EPSILON );
call    0 returned 1242
     1242: 5215:	mach = link_machines( eps, mach );
call    0 returned 1242
        -: 5216:
     1242: 5217:	mkxtion( mach, finalst[mach] );
call    0 returned 1242
        -: 5218:
     1242: 5219:	return mach;
        -: 5220:	}
        -: 5221:
        -: 5222:
        -: 5223:/* mkor - make a machine that matches either one of two machines
        -: 5224: *
        -: 5225: * synopsis
        -: 5226: *
        -: 5227: *   new = mkor( first, second );
        -: 5228: *
        -: 5229: *     new - a machine which matches either first's pattern or second's
        -: 5230: *     first, second - machines whose patterns are to be or'ed (the | operator)
        -: 5231: *
        -: 5232: * note that first and second are both destroyed by the operation
        -: 5233: * the code is rather convoluted because an attempt is made to minimize
        -: 5234: * the number of epsilon states needed
        -: 5235: */
        -: 5236:
function mkor called 1095 returned 100% blocks executed 90%
     1095: 5237:int mkor( first, second )
        -: 5238:int first, second;
        -: 5239:	{
        -: 5240:	int eps, orend;
        -: 5241:
     1095: 5242:	if ( first == NIL )
branch  0 taken 0 (fallthrough)
branch  1 taken 1095
    #####: 5243:		return second;
        -: 5244:
     1095: 5245:	else if ( second == NIL )
branch  0 taken 0 (fallthrough)
branch  1 taken 1095
    #####: 5246:		return first;
        -: 5247:
        -: 5248:	else
        -: 5249:		{
        -: 5250:		/* See comment in mkopt() about why we can't use the first
        -: 5251:		 * state of "first" or "second" if they satisfy "FREE_EPSILON".
        -: 5252:		 */
     1095: 5253:		eps = mkstate( SYM_EPSILON );
call    0 returned 1095
        -: 5254:
     1095: 5255:		first = link_machines( eps, first );
call    0 returned 1095
        -: 5256:
     1095: 5257:		mkxtion( first, second );
call    0 returned 1095
        -: 5258:
     1095: 5259:		if ( SUPER_FREE_EPSILON(finalst[first]) &&
branch  0 taken 666 (fallthrough)
branch  1 taken 429
branch  2 taken 666 (fallthrough)
branch  3 taken 0
      666: 5260:		     accptnum[finalst[first]] == NIL )
branch  0 taken 666 (fallthrough)
branch  1 taken 0
        -: 5261:			{
      666: 5262:			orend = finalst[first];
      666: 5263:			mkxtion( finalst[second], orend );
call    0 returned 666
        -: 5264:			}
        -: 5265:
      429: 5266:		else if ( SUPER_FREE_EPSILON(finalst[second]) &&
branch  0 taken 100 (fallthrough)
branch  1 taken 329
branch  2 taken 100 (fallthrough)
branch  3 taken 0
      100: 5267:			  accptnum[finalst[second]] == NIL )
branch  0 taken 100 (fallthrough)
branch  1 taken 0
        -: 5268:			{
      100: 5269:			orend = finalst[second];
      100: 5270:			mkxtion( finalst[first], orend );
call    0 returned 100
        -: 5271:			}
        -: 5272:
        -: 5273:		else
        -: 5274:			{
      329: 5275:			eps = mkstate( SYM_EPSILON );
call    0 returned 329
        -: 5276:
      329: 5277:			first = link_machines( first, eps );
call    0 returned 329
      329: 5278:			orend = finalst[first];
        -: 5279:
      329: 5280:			mkxtion( finalst[second], orend );
call    0 returned 329
        -: 5281:			}
        -: 5282:		}
        -: 5283:
     1095: 5284:	finalst[first] = orend;
     1095: 5285:	return first;
        -: 5286:	}
        -: 5287:
        -: 5288:
        -: 5289:/* mkposcl - convert a machine into a positive closure
        -: 5290: *
        -: 5291: * synopsis
        -: 5292: *   new = mkposcl( state );
        -: 5293: *
        -: 5294: *    new - a machine matching the positive closure of "state"
        -: 5295: */
        -: 5296:
function mkposcl called 1286 returned 100% blocks executed 67%
     1286: 5297:int mkposcl( state )
        -: 5298:int state;
        -: 5299:	{
        -: 5300:	int eps;
        -: 5301:
    1286*: 5302:	if ( SUPER_FREE_EPSILON(finalst[state]) )
branch  0 taken 0 (fallthrough)
branch  1 taken 1286
branch  2 never executed
branch  3 never executed
        -: 5303:		{
    #####: 5304:		mkxtion( finalst[state], state );
call    0 never executed
    #####: 5305:		return state;
        -: 5306:		}
        -: 5307:
        -: 5308:	else
        -: 5309:		{
     1286: 5310:		eps = mkstate( SYM_EPSILON );
call    0 returned 1286
     1286: 5311:		mkxtion( eps, state );
call    0 returned 1286
     1286: 5312:		return link_machines( state, eps );
call    0 returned 1286
        -: 5313:		}
        -: 5314:	}
        -: 5315:
        -: 5316:
        -: 5317:/* mkrep - make a replicated machine
        -: 5318: *
        -: 5319: * synopsis
        -: 5320: *   new = mkrep( mach, lb, ub );
        -: 5321: *
        -: 5322: *    new - a machine that matches whatever "mach" matched from "lb"
        -: 5323: *          number of times to "ub" number of times
        -: 5324: *
        -: 5325: * note
        -: 5326: *   if "ub" is INFINITY then "new" matches "lb" or more occurrences of "mach"
        -: 5327: */
        -: 5328:
function mkrep called 198 returned 100% blocks executed 100%
      198: 5329:int mkrep( mach, lb, ub )
        -: 5330:int mach, lb, ub;
        -: 5331:	{
        -: 5332:	int base_mach, tail, copy, i;
        -: 5333:
      198: 5334:	base_mach = copysingl( mach, lb - 1 );
call    0 returned 198
        -: 5335:
      198: 5336:	if ( ub == INFINITY )
branch  0 taken 98 (fallthrough)
branch  1 taken 100
        -: 5337:		{
       98: 5338:		copy = dupmachine( mach );
call    0 returned 98
       98: 5339:		mach = link_machines( mach,
call    0 returned 98
call    1 returned 98
call    2 returned 98
        -: 5340:		link_machines( base_mach, mkclos( copy ) ) );
        -: 5341:		}
        -: 5342:
        -: 5343:	else
        -: 5344:		{
      100: 5345:		tail = mkstate( SYM_EPSILON );
call    0 returned 100
        -: 5346:
      398: 5347:		for ( i = lb; i < ub; ++i )
branch  0 taken 298
branch  1 taken 100 (fallthrough)
        -: 5348:			{
      298: 5349:			copy = dupmachine( mach );
call    0 returned 298
      298: 5350:			tail = mkopt( link_machines( copy, tail ) );
call    0 returned 298
call    1 returned 298
        -: 5351:			}
        -: 5352:
      100: 5353:		mach = link_machines( mach, link_machines( base_mach, tail ) );
call    0 returned 100
call    1 returned 100
        -: 5354:		}
        -: 5355:
      198: 5356:	return mach;
        -: 5357:	}
        -: 5358:
        -: 5359:
        -: 5360:/* mkstate - create a state with a transition on a given symbol
        -: 5361: *
        -: 5362: * synopsis
        -: 5363: *
        -: 5364: *   state = mkstate( sym );
        -: 5365: *
        -: 5366: *     state - a new state matching sym
        -: 5367: *     sym   - the symbol the new state is to have an out-transition on
        -: 5368: *
        -: 5369: * note that this routine makes new states in ascending order through the
        -: 5370: * state array (and increments LASTNFA accordingly).  The routine DUPMACHINE
        -: 5371: * relies on machines being made in ascending order and that they are
        -: 5372: * CONTIGUOUS.  Change it and you will have to rewrite DUPMACHINE (kludge
        -: 5373: * that it admittedly is)
        -: 5374: */
        -: 5375:
function mkstate called 29344 returned 100% blocks executed 96%
    29344: 5376:int mkstate( sym )
        -: 5377:int sym;
        -: 5378:	{
    29344: 5379:	if ( ++lastnfa >= current_mns )
branch  0 taken 2 (fallthrough)
branch  1 taken 29342
        -: 5380:		{
        2: 5381:		if ( (current_mns += MNS_INCREMENT) >= MAXIMUM_MNS )
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####: 5382:			lerrif(
call    0 never executed
        -: 5383:			"input rules are too complicated (>= %d NFA states)",
        -: 5384:				current_mns );
        -: 5385:
        2: 5386:		++num_reallocs;
        -: 5387:
        2: 5388:		firstst = reallocate_integer_array( firstst, current_mns );
call    0 returned 2
        2: 5389:		lastst = reallocate_integer_array( lastst, current_mns );
call    0 returned 2
        2: 5390:		finalst = reallocate_integer_array( finalst, current_mns );
call    0 returned 2
        2: 5391:		transchar = reallocate_integer_array( transchar, current_mns );
call    0 returned 2
        2: 5392:		trans1 = reallocate_integer_array( trans1, current_mns );
call    0 returned 2
        2: 5393:		trans2 = reallocate_integer_array( trans2, current_mns );
call    0 returned 2
        2: 5394:		accptnum = reallocate_integer_array( accptnum, current_mns );
call    0 returned 2
        2: 5395:		assoc_rule =
        2: 5396:			reallocate_integer_array( assoc_rule, current_mns );
call    0 returned 2
        2: 5397:		state_type =
        2: 5398:			reallocate_integer_array( state_type, current_mns );
call    0 returned 2
        -: 5399:		}
        -: 5400:
    29344: 5401:	firstst[lastnfa] = lastnfa;
    29344: 5402:	finalst[lastnfa] = lastnfa;
    29344: 5403:	lastst[lastnfa] = lastnfa;
    29344: 5404:	transchar[lastnfa] = sym;
    29344: 5405:	trans1[lastnfa] = NO_TRANSITION;
    29344: 5406:	trans2[lastnfa] = NO_TRANSITION;
    29344: 5407:	accptnum[lastnfa] = NIL;
    29344: 5408:	assoc_rule[lastnfa] = num_rules;
    29344: 5409:	state_type[lastnfa] = current_state_type;
        -: 5410:
        -: 5411:	/* Fix up equivalence classes base on this transition.  Note that any
        -: 5412:	 * character which has its own transition gets its own equivalence
        -: 5413:	 * class.  Thus only characters which are only in character classes
        -: 5414:	 * have a chance at being in the same equivalence class.  E.g. "a|b"
        -: 5415:	 * puts 'a' and 'b' into two different equivalence classes.  "[ab]"
        -: 5416:	 * puts them in the same equivalence class (barring other differences
        -: 5417:	 * elsewhere in the input).
        -: 5418:	 */
        -: 5419:
    29344: 5420:	if ( sym < 0 )
branch  0 taken 27056 (fallthrough)
branch  1 taken 2288
        -: 5421:		{
        -: 5422:		/* We don't have to update the equivalence classes since
        -: 5423:		 * that was already done when the ccl was created for the
        -: 5424:		 * first time.
        -: 5425:		 */
        -: 5426:		}
        -: 5427:
    27056: 5428:	else if ( sym == SYM_EPSILON )
branch  0 taken 15121 (fallthrough)
branch  1 taken 11935
    15121: 5429:		++numeps;
        -: 5430:
        -: 5431:	else
        -: 5432:		{
    11935: 5433:		check_char( sym );
call    0 returned 11934
        -: 5434:
    11934: 5435:		if ( useecs )
branch  0 taken 7508 (fallthrough)
branch  1 taken 4426
        -: 5436:			/* Map NUL's to csize. */
     7508: 5437:			mkechar( sym ? sym : csize, nextecm, ecgroup );
branch  0 taken 7506 (fallthrough)
branch  1 taken 2
call    2 returned 7508
        -: 5438:		}
        -: 5439:
    29343: 5440:	return lastnfa;
        -: 5441:	}
        -: 5442:
        -: 5443:
        -: 5444:/* mkxtion - make a transition from one state to another
        -: 5445: *
        -: 5446: * synopsis
        -: 5447: *
        -: 5448: *   mkxtion( statefrom, stateto );
        -: 5449: *
        -: 5450: *     statefrom - the state from which the transition is to be made
        -: 5451: *     stateto   - the state to which the transition is to be made
        -: 5452: */
        -: 5453:
function mkxtion called 32434 returned 100% blocks executed 86%
    32434: 5454:void mkxtion( statefrom, stateto )
        -: 5455:int statefrom, stateto;
        -: 5456:	{
    32434: 5457:	if ( trans1[statefrom] == NO_TRANSITION )
branch  0 taken 24374 (fallthrough)
branch  1 taken 8060
    24374: 5458:		trans1[statefrom] = stateto;
        -: 5459:
     8060: 5460:	else if ( (transchar[statefrom] != SYM_EPSILON) ||
branch  0 taken 8060 (fallthrough)
branch  1 taken 0
     8060: 5461:		  (trans2[statefrom] != NO_TRANSITION) )
branch  0 taken 0 (fallthrough)
branch  1 taken 8060
    #####: 5462:		flexfatal( "found too many transitions in mkxtion()" );
call    0 never executed
        -: 5463:
        -: 5464:	else
        -: 5465:		{ /* second out-transition for an epsilon state */
     8060: 5466:		++eps2;
     8060: 5467:		trans2[statefrom] = stateto;
        -: 5468:		}
    32434: 5469:	}
        -: 5470:
        -: 5471:/* new_rule - initialize for a new rule */
        -: 5472:
function new_rule called 4076 returned 100% blocks executed 88%
     4076: 5473:void new_rule()
        -: 5474:	{
     4076: 5475:	if ( ++num_rules >= current_max_rules )
branch  0 taken 7 (fallthrough)
branch  1 taken 4069
        -: 5476:		{
        7: 5477:		++num_reallocs;
        7: 5478:		current_max_rules += MAX_RULES_INCREMENT;
        7: 5479:		rule_type = reallocate_integer_array( rule_type,
call    0 returned 7
        -: 5480:							current_max_rules );
        7: 5481:		rule_linenum = reallocate_integer_array( rule_linenum,
call    0 returned 7
        -: 5482:							current_max_rules );
        7: 5483:		rule_useful = reallocate_integer_array( rule_useful,
call    0 returned 7
        -: 5484:							current_max_rules );
        -: 5485:		}
        -: 5486:
     4076: 5487:	if ( num_rules > MAX_RULE )
branch  0 taken 0 (fallthrough)
branch  1 taken 4076
    #####: 5488:		lerrif( "too many rules (> %d)!", MAX_RULE );
call    0 never executed
        -: 5489:
     4076: 5490:	rule_linenum[num_rules] = linenum;
     4076: 5491:	rule_useful[num_rules] = false;
     4076: 5492:	}
        -: 5493:/* File created from flex.skel via mkskel.sh */
        -: 5494:
        -: 5495:
        -: 5496:char *skel[] = {
        -: 5497:  "/* A lexical scanner generated by flex */",
        -: 5498:  "",
        -: 5499:  "/* Scanner skeleton version:",
        -: 5500:  " * $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.seeded/v1/flex.c,v 1.1.1.2 2003/09/02 20:21:59 expsir Exp $",
        -: 5501:  " */",
        -: 5502:  "",
        -: 5503:  "#define FLEX_SCANNER",
        -: 5504:  "",
        -: 5505:  "%-",
        -: 5506:  "#include <stdio.h>",
        -: 5507:  "%*",
        -: 5508:  "",
        -: 5509:  "",
        -: 5510:  "/* cfront 1.2 defines \"c_plusplus\" instead of \"__cplusplus\" */",
        -: 5511:  "#ifdef c_plusplus",
        -: 5512:  "#ifndef __cplusplus",
        -: 5513:  "#define __cplusplus",
        -: 5514:  "#endif",
        -: 5515:  "#endif",
        -: 5516:  "",
        -: 5517:  "",
        -: 5518:  "#ifdef __cplusplus",
        -: 5519:  "",
        -: 5520:  "#include <stdlib.h>",
        -: 5521:  "%+",
        -: 5522:  "class istream;",
        -: 5523:  "%*",
        -: 5524:  "#include <unistd.h>",
        -: 5525:  "",
        -: 5526:  "/* Use prototypes in function declarations. */",
        -: 5527:  "#define YY_USE_PROTOS",
        -: 5528:  "",
        -: 5529:  "/* The \"const\" storage-class-modifier is valid. */",
        -: 5530:  "#define YY_USE_CONST",
        -: 5531:  "",
        -: 5532:  "#else	/* ! __cplusplus */",
        -: 5533:  "",
        -: 5534:  "#ifdef __STDC__",
        -: 5535:  "",
        -: 5536:  "#define YY_USE_PROTOS",
        -: 5537:  "#define YY_USE_CONST",
        -: 5538:  "",
        -: 5539:  "#endif	/* __STDC__ */",
        -: 5540:  "#endif	/* ! __cplusplus */",
        -: 5541:  "",
        -: 5542:  "",
        -: 5543:  "#ifdef __TURBOC__",
        -: 5544:  "#define YY_USE_CONST",
        -: 5545:  "#endif",
        -: 5546:  "",
        -: 5547:  "",
        -: 5548:  "#ifndef YY_USE_CONST",
        -: 5549:  "#ifndef const",
        -: 5550:  "#define const",
        -: 5551:  "#endif",
        -: 5552:  "#endif",
        -: 5553:  "",
        -: 5554:  "",
        -: 5555:  "#ifdef YY_USE_PROTOS",
        -: 5556:  "#define YY_PROTO(proto) proto",
        -: 5557:  "#else",
        -: 5558:  "#define YY_PROTO(proto) ()",
        -: 5559:  "#endif",
        -: 5560:  "",
        -: 5561:  "/* Returned upon end-of-file. */",
        -: 5562:  "#define YY_NULL 0",
        -: 5563:  "",
        -: 5564:  "/* Promotes a possibly negative, possibly signed char to an unsigned",
        -: 5565:  " * integer for use as an array index.  If the signed char is negative,",
        -: 5566:  " * we want to instead treat it as an 8-bit unsigned char, hence the",
        -: 5567:  " * double cast.",
        -: 5568:  " */",
        -: 5569:  "#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)",
        -: 5570:  "",
        -: 5571:  "/* Enter a start condition.  This macro really ought to take a parameter,",
        -: 5572:  " * but we do it the disgusting crufty way forced on us by the ()-less",
        -: 5573:  " * definition of BEGIN.",
        -: 5574:  " */",
        -: 5575:  "#define BEGIN yy_start = 1 + 2 *",
        -: 5576:  "",
        -: 5577:  "/* Translate the current start state into a value that can be later handed",
        -: 5578:  " * to BEGIN to return to the state.",
        -: 5579:  " */",
        -: 5580:  "#define YY_START ((yy_start - 1) / 2)",
        -: 5581:  "",
        -: 5582:  "/* Action number for EOF rule of a given start state. */",
        -: 5583:  "#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)",
        -: 5584:  "",
        -: 5585:  "/* Special action meaning \"start processing a new file\".  Now included",
        -: 5586:  " * only for backward compatibility with previous versions of flex.",
        -: 5587:  " */",
        -: 5588:  "#define YY_NEW_FILE yyrestart( yyin )",
        -: 5589:  "",
        -: 5590:  "#define YY_END_OF_BUFFER_CHAR 0",
        -: 5591:  "",
        -: 5592:  "/* Size of default input buffer. */",
        -: 5593:  "#define YY_BUF_SIZE 16384",
        -: 5594:  "",
        -: 5595:  "typedef struct yy_buffer_state *YY_BUFFER_STATE;",
        -: 5596:  "",
        -: 5597:  "extern int yyleng;",
        -: 5598:  "%-",
        -: 5599:  "extern FILE *yyin, *yyout;",
        -: 5600:  "%*",
        -: 5601:  "",
        -: 5602:  "#ifdef __cplusplus",
        -: 5603:  "extern \"C\" {",
        -: 5604:  "#endif",
        -: 5605:  "	extern int yywrap YY_PROTO(( void ));",
        -: 5606:  "#ifdef __cplusplus",
        -: 5607:  "	}",
        -: 5608:  "#endif",
        -: 5609:  "",
        -: 5610:  "#define EOB_ACT_CONTINUE_SCAN 0",
        -: 5611:  "#define EOB_ACT_END_OF_FILE 1",
        -: 5612:  "#define EOB_ACT_LAST_MATCH 2",
        -: 5613:  "",
        -: 5614:  "/* The funky do-while in the following #define is used to turn the definition",
        -: 5615:  " * int a single C statement (which needs a semi-colon terminator).  This",
        -: 5616:  " * avoids problems with code like:",
        -: 5617:  " *",
        -: 5618:  " * 	if ( condition_holds )",
        -: 5619:  " *		yyless( 5 );",
        -: 5620:  " *	else",
        -: 5621:  " *		do_something_else();",
        -: 5622:  " *",
        -: 5623:  " * Prior to using the do-while the compiler would get upset at the",
        -: 5624:  " * \"else\" because it interpreted the \"if\" statement as being all",
        -: 5625:  " * done when it reached the ';' after the yyless() call.",
        -: 5626:  " */",
        -: 5627:  "",
        -: 5628:  "/* Return all but the first 'n' matched characters back to the input stream. */",
        -: 5629:  "",
        -: 5630:  "#define yyless(n) \\",
        -: 5631:  "	do \\",
        -: 5632:  "		{ \\",
        -: 5633:  "		/* Undo effects of setting up yytext. */ \\",
        -: 5634:  "		*yy_cp = yy_hold_char; \\",
        -: 5635:  "		yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \\",
        -: 5636:  "		YY_DO_BEFORE_ACTION; /* set up yytext again */ \\",
        -: 5637:  "		} \\",
        -: 5638:  "	while ( 0 )",
        -: 5639:  "",
        -: 5640:  "#define unput(c) yyunput( c, yytext_ptr )",
        -: 5641:  "",
        -: 5642:  "",
        -: 5643:  "struct yy_buffer_state",
        -: 5644:  "	{",
        -: 5645:  "%-",
        -: 5646:  "	FILE *yy_input_file;",
        -: 5647:  "%+",
        -: 5648:  "	istream* yy_input_file;",
        -: 5649:  "%*",
        -: 5650:  "",
        -: 5651:  "	char *yy_ch_buf;		/* input buffer */",
        -: 5652:  "	char *yy_buf_pos;		/* current position in input buffer */",
        -: 5653:  "",
        -: 5654:  "	/* Size of input buffer in bytes, not including room for EOB",
        -: 5655:  "	 * characters.",
        -: 5656:  "	 */",
        -: 5657:  "	int yy_buf_size;",
        -: 5658:  "",
        -: 5659:  "	/* Number of characters read into yy_ch_buf, not including EOB",
        -: 5660:  "	 * characters.",
        -: 5661:  "	 */",
        -: 5662:  "	int yy_n_chars;",
        -: 5663:  "",
        -: 5664:  "	/* Whether this is an \"interactive\" input source; if so, and",
        -: 5665:  "	 * if we're using stdio for input, then we want to use getc()",
        -: 5666:  "	 * instead of fread(), to make sure we stop fetching input after",
        -: 5667:  "	 * each newline.",
        -: 5668:  "	 */",
        -: 5669:  "	int yy_is_interactive;",
        -: 5670:  "",
        -: 5671:  "	/* Whether to try to fill the input buffer when we reach the",
        -: 5672:  "	 * end of it.",
        -: 5673:  "	 */",
        -: 5674:  "	int yy_fill_buffer;",
        -: 5675:  "",
        -: 5676:  "	int yy_buffer_status;",
        -: 5677:  "#define YY_BUFFER_NEW 0",
        -: 5678:  "#define YY_BUFFER_NORMAL 1",
        -: 5679:  "	/* When an EOF's been seen but there's still some text to process",
        -: 5680:  "	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we",
        -: 5681:  "	 * shouldn't try reading from the input source any more.  We might",
        -: 5682:  "	 * still have a bunch of tokens to match, though, because of",
        -: 5683:  "	 * possible backing-up.",
        -: 5684:  "	 *",
        -: 5685:  "	 * When we actually see the EOF, we change the status to \"new\"",
        -: 5686:  "	 * (via yyrestart()), so that the user can continue scanning by",
        -: 5687:  "	 * just pointing yyin at a new input file.",
        -: 5688:  "	 */",
        -: 5689:  "#define YY_BUFFER_EOF_PENDING 2",
        -: 5690:  "	};",
        -: 5691:  "",
        -: 5692:  "%- Standard (non-C++) definition",
        -: 5693:  "static YY_BUFFER_STATE yy_current_buffer = 0;",
        -: 5694:  "%*",
        -: 5695:  "",
        -: 5696:  "/* We provide macros for accessing buffer states in case in the",
        -: 5697:  " * future we want to put the buffer states in a more general",
        -: 5698:  " * \"scanner state\".",
        -: 5699:  " */",
        -: 5700:  "#define YY_CURRENT_BUFFER yy_current_buffer",
        -: 5701:  "",
        -: 5702:  "",
        -: 5703:  "%- Standard (non-C++) definition",
        -: 5704:  "/* yy_hold_char holds the character lost when yytext is formed. */",
        -: 5705:  "static char yy_hold_char;",
        -: 5706:  "",
        -: 5707:  "static int yy_n_chars;		/* number of characters read into yy_ch_buf */",
        -: 5708:  "",
        -: 5709:  "",
        -: 5710:  "int yyleng;",
        -: 5711:  "",
        -: 5712:  "/* Points to current character in buffer. */",
        -: 5713:  "static char *yy_c_buf_p = (char *) 0;",
        -: 5714:  "static int yy_init = 1;		/* whether we need to initialize */",
        -: 5715:  "static int yy_start = 0;	/* start state number */",
        -: 5716:  "",
        -: 5717:  "/* Flag which is used to allow yywrap()'s to do buffer switches",
        -: 5718:  " * instead of setting up a fresh yyin.  A bit of a hack ...",
        -: 5719:  " */",
        -: 5720:  "static int yy_did_buffer_switch_on_eof;",
        -: 5721:  "",
        -: 5722:  "static void yyunput YY_PROTO(( int c, char *buf_ptr ));",
        -: 5723:  "void yyrestart YY_PROTO(( FILE *input_file ));",
        -: 5724:  "void yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));",
        -: 5725:  "void yy_load_buffer_state YY_PROTO(( void ));",
        -: 5726:  "YY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *file, int size ));",
        -: 5727:  "void yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));",
        -: 5728:  "void yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));",
        -: 5729:  "",
        -: 5730:  "static int yy_start_stack_ptr = 0;",
        -: 5731:  "static int yy_start_stack_depth = 0;",
        -: 5732:  "static int *yy_start_stack = 0;",
        -: 5733:  "static void yy_push_state YY_PROTO(( int new_state ));",
        -: 5734:  "static void yy_pop_state YY_PROTO(( void ));",
        -: 5735:  "static int yy_top_state YY_PROTO(( void ));",
        -: 5736:  "%*",
        -: 5737:  "",
        -: 5738:  "static void *yy_flex_alloc YY_PROTO(( unsigned int ));",
        -: 5739:  "static void *yy_flex_realloc YY_PROTO(( void *, unsigned int ));",
        -: 5740:  "static void yy_flex_free YY_PROTO(( void * ));",
        -: 5741:  "",
        -: 5742:  "#define yy_new_buffer yy_create_buffer",
        -: 5743:  "",
        -: 5744:  "%% yytext/yyin/yyout/yy_state_type/yylineno etc. def's & init go here",
        -: 5745:  "",
        -: 5746:  "#ifndef yytext_ptr",
        -: 5747:  "static void yy_flex_strncpy YY_PROTO(( char *, const char *, int ));",
        -: 5748:  "#endif",
        -: 5749:  "",
        -: 5750:  "%- Standard (non-C++) definition",
        -: 5751:  "#ifdef __cplusplus",
        -: 5752:  "static int yyinput YY_PROTO(( void ));",
        -: 5753:  "#else",
        -: 5754:  "static int input YY_PROTO(( void ));",
        -: 5755:  "#endif",
        -: 5756:  "%*",
        -: 5757:  "",
        -: 5758:  "%- Standard (non-C++) definition",
        -: 5759:  "static yy_state_type yy_get_previous_state YY_PROTO(( void ));",
        -: 5760:  "static yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));",
        -: 5761:  "static int yy_get_next_buffer YY_PROTO(( void ));",
        -: 5762:  "static void yy_fatal_error YY_PROTO(( const char msg[] ));",
        -: 5763:  "%*",
        -: 5764:  "",
        -: 5765:  "/* Done after the current pattern has been matched and before the",
        -: 5766:  " * corresponding action - sets up yytext.",
        -: 5767:  " */",
        -: 5768:  "#define YY_DO_BEFORE_ACTION \\",
        -: 5769:  "	yytext_ptr = yy_bp; \\",
        -: 5770:  "%% code to fiddle yytext and yyleng for yymore() goes here",
        -: 5771:  "	yy_hold_char = *yy_cp; \\",
        -: 5772:  "	*yy_cp = '\\0'; \\",
        -: 5773:  "%% code to copy yytext_ptr to yytext[] goes here, if %array",
        -: 5774:  "	yy_c_buf_p = yy_cp;",
        -: 5775:  "",
        -: 5776:  "%% data tables for the DFA and the user's section 1 definitions go here",
        -: 5777:  "",
        -: 5778:  "/* Macros after this point can all be overridden by user definitions in",
        -: 5779:  " * section 1.",
        -: 5780:  " */",
        -: 5781:  "",
        -: 5782:  "#ifdef YY_MALLOC_DECL",
        -: 5783:  "YY_MALLOC_DECL",
        -: 5784:  "#else",
        -: 5785:  "#if __STDC__",
        -: 5786:  "#ifndef __cplusplus",
        -: 5787:  "#include <stdlib.h>",
        -: 5788:  "#endif",
        -: 5789:  "#else",
        -: 5790:  "/* Just try to get by without declaring the routines.  This will fail",
        -: 5791:  " * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)",
        -: 5792:  " * or sizeof(void*) != sizeof(int).",
        -: 5793:  " */",
        -: 5794:  "#endif",
        -: 5795:  "#endif",
        -: 5796:  "",
        -: 5797:  "/* Amount of stuff to slurp up with each read. */",
        -: 5798:  "#ifndef YY_READ_BUF_SIZE",
        -: 5799:  "#define YY_READ_BUF_SIZE 8192",
        -: 5800:  "#endif",
        -: 5801:  "",
        -: 5802:  "/* Copy whatever the last rule matched to the standard output. */",
        -: 5803:  "",
        -: 5804:  "#ifndef ECHO",
        -: 5805:  "%- Standard (non-C++) definition",
        -: 5806:  "/* This used to be an fputs(), but since the string might contain NUL's,",
        -: 5807:  " * we now use fwrite().",
        -: 5808:  " */",
        -: 5809:  "#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )",
        -: 5810:  "%+ C++ definition",
        -: 5811:  "#define ECHO LexerOutput( yytext, yyleng )",
        -: 5812:  "%*",
        -: 5813:  "#endif",
        -: 5814:  "",
        -: 5815:  "/* Gets input and stuffs it into \"buf\".  number of characters read, or YY_NULL,",
        -: 5816:  " * is returned in \"result\".",
        -: 5817:  " */",
        -: 5818:  "#ifndef YY_INPUT",
        -: 5819:  "#define YY_INPUT(buf,result,max_size) \\",
        -: 5820:  "%% fread()/read() definition of YY_INPUT goes here unless we're doing C++",
        -: 5821:  "%+ C++ definition",
        -: 5822:  "	if ( (result = LexerInput( (char *) buf, max_size )) < 0 ) \\",
        -: 5823:  "		YY_FATAL_ERROR( \"input in flex scanner failed\" );",
        -: 5824:  "%*",
        -: 5825:  "#endif",
        -: 5826:  "",
        -: 5827:  "/* No semi-colon after return; correct usage is to write \"yyterminate();\" -",
        -: 5828:  " * we don't want an extra ';' after the \"return\" because that will cause",
        -: 5829:  " * some compilers to complain about unreachable statements.",
        -: 5830:  " */",
        -: 5831:  "#ifndef yyterminate",
        -: 5832:  "#define yyterminate() return YY_NULL",
        -: 5833:  "#endif",
        -: 5834:  "",
        -: 5835:  "/* Number of entries by which start-condition stack grows. */",
        -: 5836:  "#ifndef YY_START_STACK_INCR",
        -: 5837:  "#define YY_START_STACK_INCR 25",
        -: 5838:  "#endif",
        -: 5839:  "",
        -: 5840:  "/* Report a fatal error. */",
        -: 5841:  "#ifndef YY_FATAL_ERROR",
        -: 5842:  "%-",
        -: 5843:  "#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )",
        -: 5844:  "%+",
        -: 5845:  "#define YY_FATAL_ERROR(msg) LexerError( msg )",
        -: 5846:  "%*",
        -: 5847:  "#endif",
        -: 5848:  "",
        -: 5849:  "/* Default declaration of generated scanner - a define so the user can",
        -: 5850:  " * easily add parameters.",
        -: 5851:  " */",
        -: 5852:  "#ifndef YY_DECL",
        -: 5853:  "%- Standard (non-C++) definition",
        -: 5854:  "#define YY_DECL int yylex YY_PROTO(( void ))",
        -: 5855:  "%+ C++ definition",
        -: 5856:  "#define YY_DECL int yyFlexLexer::yylex()",
        -: 5857:  "%*",
        -: 5858:  "#endif",
        -: 5859:  "",
        -: 5860:  "/* Code executed at the beginning of each rule, after yytext and yyleng",
        -: 5861:  " * have been set up.",
        -: 5862:  " */",
        -: 5863:  "#ifndef YY_USER_ACTION",
        -: 5864:  "#define YY_USER_ACTION",
        -: 5865:  "#endif",
        -: 5866:  "",
        -: 5867:  "/* Code executed at the end of each rule. */",
        -: 5868:  "#ifndef YY_BREAK",
        -: 5869:  "#define YY_BREAK break;",
        -: 5870:  "#endif",
        -: 5871:  "",
        -: 5872:  "YY_DECL",
        -: 5873:  "	{",
        -: 5874:  "	register yy_state_type yy_current_state;",
        -: 5875:  "	register char *yy_cp, *yy_bp;",
        -: 5876:  "	register int yy_act;",
        -: 5877:  "",
        -: 5878:  "%% user's declarations go here",
        -: 5879:  "",
        -: 5880:  "	if ( yy_init )",
        -: 5881:  "		{",
        -: 5882:  "#ifdef YY_USER_INIT",
        -: 5883:  "		YY_USER_INIT;",
        -: 5884:  "#endif",
        -: 5885:  "",
        -: 5886:  "		if ( ! yy_start )",
        -: 5887:  "			yy_start = 1;	/* first start state */",
        -: 5888:  "",
        -: 5889:  "		if ( ! yyin )",
        -: 5890:  "%-",
        -: 5891:  "			yyin = stdin;",
        -: 5892:  "%+",
        -: 5893:  "			yyin = &cin;",
        -: 5894:  "%*",
        -: 5895:  "",
        -: 5896:  "		if ( ! yyout )",
        -: 5897:  "%-",
        -: 5898:  "			yyout = stdout;",
        -: 5899:  "%+",
        -: 5900:  "			yyout = &cout;",
        -: 5901:  "%*",
        -: 5902:  "",
        -: 5903:  "		if ( yy_current_buffer )",
        -: 5904:  "			yy_init_buffer( yy_current_buffer, yyin );",
        -: 5905:  "		else",
        -: 5906:  "			yy_current_buffer =",
        -: 5907:  "				yy_create_buffer( yyin, YY_BUF_SIZE );",
        -: 5908:  "",
        -: 5909:  "		yy_load_buffer_state();",
        -: 5910:  "",
        -: 5911:  "		yy_init = 0;",
        -: 5912:  "		}",
        -: 5913:  "",
        -: 5914:  "	while ( 1 )		/* loops until end-of-file is reached */",
        -: 5915:  "		{",
        -: 5916:  "%% yymore()-related code goes here",
        -: 5917:  "		yy_cp = yy_c_buf_p;",
        -: 5918:  "",
        -: 5919:  "		/* Support of yytext. */",
        -: 5920:  "		*yy_cp = yy_hold_char;",
        -: 5921:  "",
        -: 5922:  "		/* yy_bp points to the position in yy_ch_buf of the start of",
        -: 5923:  "		 * the current run.",
        -: 5924:  "		 */",
        -: 5925:  "		yy_bp = yy_cp;",
        -: 5926:  "",
        -: 5927:  "%% code to set up and find next match goes here",
        -: 5928:  "",
        -: 5929:  "yy_find_action:",
        -: 5930:  "%% code to find the action number goes here",
        -: 5931:  "",
        -: 5932:  "		YY_DO_BEFORE_ACTION;",
        -: 5933:  "",
        -: 5934:  "%% code for yylineno update goes here, if -l option",
        -: 5935:  "",
        -: 5936:  "do_action:	/* This label is used only to access EOF actions. */",
        -: 5937:  "",
        -: 5938:  "%% debug code goes here",
        -: 5939:  "",
        -: 5940:  "		switch ( yy_act )",
        -: 5941:  "	{ /* beginning of action switch */",
        -: 5942:  "%% actions go here",
        -: 5943:  "",
        -: 5944:  "	case YY_END_OF_BUFFER:",
        -: 5945:  "		{",
        -: 5946:  "		/* Amount of text matched not including the EOB char. */",
        -: 5947:  "		int yy_amount_of_matched_text = yy_cp - yytext_ptr - 1;",
        -: 5948:  "",
        -: 5949:  "		/* Undo the effects of YY_DO_BEFORE_ACTION. */",
        -: 5950:  "		*yy_cp = yy_hold_char;",
        -: 5951:  "",
        -: 5952:  "		if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )",
        -: 5953:  "			{",
        -: 5954:  "			/* We're scanning a new file or input source.  It's",
        -: 5955:  "			 * possible that this happened because the user",
        -: 5956:  "			 * just pointed yyin at a new source and called",
        -: 5957:  "			 * yylex().  If so, then we have to assure",
        -: 5958:  "			 * consistency between yy_current_buffer and our",
        -: 5959:  "			 * globals.  Here is the right place to do so, because",
        -: 5960:  "			 * this is the first action (other than possibly a",
        -: 5961:  "			 * back-up) that will match for the new input source.",
        -: 5962:  "			 */",
        -: 5963:  "			yy_n_chars = yy_current_buffer->yy_n_chars;",
        -: 5964:  "			yy_current_buffer->yy_input_file = yyin;",
        -: 5965:  "			yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;",
        -: 5966:  "			}",
        -: 5967:  "",
        -: 5968:  "		/* Note that here we test for yy_c_buf_p \"<=\" to the position",
        -: 5969:  "		 * of the first EOB in the buffer, since yy_c_buf_p will",
        -: 5970:  "		 * already have been incremented past the NUL character",
        -: 5971:  "		 * (since all states make transitions on EOB to the",
        -: 5972:  "		 * end-of-buffer state).  Contrast this with the test",
        -: 5973:  "		 * in input().",
        -: 5974:  "		 */",
        -: 5975:  "		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )",
        -: 5976:  "			{ /* This was really a NUL. */",
        -: 5977:  "			yy_state_type yy_next_state;",
        -: 5978:  "",
        -: 5979:  "			yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;",
        -: 5980:  "",
        -: 5981:  "			yy_current_state = yy_get_previous_state();",
        -: 5982:  "",
        -: 5983:  "			/* Okay, we're now positioned to make the NUL",
        -: 5984:  "			 * transition.  We couldn't have",
        -: 5985:  "			 * yy_get_previous_state() go ahead and do it",
        -: 5986:  "			 * for us because it doesn't know how to deal",
        -: 5987:  "			 * with the possibility of jamming (and we don't",
        -: 5988:  "			 * want to build jamming into it because then it",
        -: 5989:  "			 * will run more slowly).",
        -: 5990:  "			 */",
        -: 5991:  "",
        -: 5992:  "			yy_next_state = yy_try_NUL_trans( yy_current_state );",
        -: 5993:  "",
        -: 5994:  "			yy_bp = yytext_ptr + YY_MORE_ADJ;",
        -: 5995:  "",
        -: 5996:  "			if ( yy_next_state )",
        -: 5997:  "				{",
        -: 5998:  "				/* Consume the NUL. */",
        -: 5999:  "				yy_cp = ++yy_c_buf_p;",
        -: 6000:  "				yy_current_state = yy_next_state;",
        -: 6001:  "				goto yy_match;",
        -: 6002:  "				}",
        -: 6003:  "",
        -: 6004:  "			else",
        -: 6005:  "				{",
        -: 6006:  "%% code to do back-up for compressed tables and set up yy_cp goes here",
        -: 6007:  "				goto yy_find_action;",
        -: 6008:  "				}",
        -: 6009:  "			}",
        -: 6010:  "",
        -: 6011:  "		else switch ( yy_get_next_buffer() )",
        -: 6012:  "			{",
        -: 6013:  "			case EOB_ACT_END_OF_FILE:",
        -: 6014:  "				{",
        -: 6015:  "				yy_did_buffer_switch_on_eof = 0;",
        -: 6016:  "",
        -: 6017:  "				if ( yywrap() )",
        -: 6018:  "					{",
        -: 6019:  "					/* Note: because we've taken care in",
        -: 6020:  "					 * yy_get_next_buffer() to have set up",
        -: 6021:  "					 * yytext, we can now set up",
        -: 6022:  "					 * yy_c_buf_p so that if some total",
        -: 6023:  "					 * hoser (like flex itself) wants to",
        -: 6024:  "					 * call the scanner after we return the",
        -: 6025:  "					 * YY_NULL, it'll still work - another",
        -: 6026:  "					 * YY_NULL will get returned.",
        -: 6027:  "					 */",
        -: 6028:  "					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;",
        -: 6029:  "",
        -: 6030:  "					yy_act = YY_STATE_EOF(YY_START);",
        -: 6031:  "					goto do_action;",
        -: 6032:  "					}",
        -: 6033:  "",
        -: 6034:  "				else",
        -: 6035:  "					{",
        -: 6036:  "					if ( ! yy_did_buffer_switch_on_eof )",
        -: 6037:  "						YY_NEW_FILE;",
        -: 6038:  "					}",
        -: 6039:  "				break;",
        -: 6040:  "				}",
        -: 6041:  "",
        -: 6042:  "			case EOB_ACT_CONTINUE_SCAN:",
        -: 6043:  "				yy_c_buf_p =",
        -: 6044:  "					yytext_ptr + yy_amount_of_matched_text;",
        -: 6045:  "",
        -: 6046:  "				yy_current_state = yy_get_previous_state();",
        -: 6047:  "",
        -: 6048:  "				yy_cp = yy_c_buf_p;",
        -: 6049:  "				yy_bp = yytext_ptr + YY_MORE_ADJ;",
        -: 6050:  "				goto yy_match;",
        -: 6051:  "",
        -: 6052:  "			case EOB_ACT_LAST_MATCH:",
        -: 6053:  "				yy_c_buf_p =",
        -: 6054:  "				&yy_current_buffer->yy_ch_buf[yy_n_chars];",
        -: 6055:  "",
        -: 6056:  "				yy_current_state = yy_get_previous_state();",
        -: 6057:  "",
        -: 6058:  "				yy_cp = yy_c_buf_p;",
        -: 6059:  "				yy_bp = yytext_ptr + YY_MORE_ADJ;",
        -: 6060:  "				goto yy_find_action;",
        -: 6061:  "			}",
        -: 6062:  "		break;",
        -: 6063:  "		}",
        -: 6064:  "",
        -: 6065:  "	default:",
        -: 6066:  "		YY_FATAL_ERROR(",
        -: 6067:  "			\"fatal flex scanner internal error--no action found\" );",
        -: 6068:  "	} /* end of action switch */",
        -: 6069:  "		} /* end of scanning one token */",
        -: 6070:  "	} /* end of yylex */",
        -: 6071:  "",
        -: 6072:  "%+",
        -: 6073:  "#ifdef YY_INTERACTIVE",
        -: 6074:  "int yyFlexLexer::LexerInput( char* buf, int /* max_size */ )",
        -: 6075:  "#else",
        -: 6076:  "int yyFlexLexer::LexerInput( char* buf, int max_size )",
        -: 6077:  "#endif",
        -: 6078:  "	{",
        -: 6079:  "	if ( yyin->eof() || yyin->fail() )",
        -: 6080:  "		return 0;",
        -: 6081:  "",
        -: 6082:  "#ifdef YY_INTERACTIVE",
        -: 6083:  "	yyin->get( buf[0] );",
        -: 6084:  "",
        -: 6085:  "	if ( yyin->eof() )",
        -: 6086:  "		return 0;",
        -: 6087:  "",
        -: 6088:  "	if ( yyin->bad() )",
        -: 6089:  "		return -1;",
        -: 6090:  "",
        -: 6091:  "	return 1;",
        -: 6092:  "",
        -: 6093:  "#else",
        -: 6094:  "	(void) yyin->read( buf, max_size );",
        -: 6095:  "",
        -: 6096:  "	if ( yyin->bad() )",
        -: 6097:  "		return -1;",
        -: 6098:  "	else",
        -: 6099:  "		return yyin->gcount();",
        -: 6100:  "#endif",
        -: 6101:  "	}",
        -: 6102:  "",
        -: 6103:  "void yyFlexLexer::LexerOutput( const char* buf, int size )",
        -: 6104:  "	{",
        -: 6105:  "	(void) yyout->write( buf, size );",
        -: 6106:  "	}",
        -: 6107:  "%*",
        -: 6108:  "",
        -: 6109:  "/* yy_get_next_buffer - try to read in a new buffer",
        -: 6110:  " *",
        -: 6111:  " * Returns a code representing an action:",
        -: 6112:  " *	EOB_ACT_LAST_MATCH -",
        -: 6113:  " *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position",
        -: 6114:  " *	EOB_ACT_END_OF_FILE - end of file",
        -: 6115:  " */",
        -: 6116:  "",
        -: 6117:  "%-",
        -: 6118:  "static int yy_get_next_buffer()",
        -: 6119:  "%+",
        -: 6120:  "int yyFlexLexer::yy_get_next_buffer()",
        -: 6121:  "%*",
        -: 6122:  "	{",
        -: 6123:  "	register char *dest = yy_current_buffer->yy_ch_buf;",
        -: 6124:  "	register char *source = yytext_ptr - 1; /* copy prev. char, too */",
        -: 6125:  "	register int number_to_move, i;",
        -: 6126:  "	int ret_val;",
        -: 6127:  "",
        -: 6128:  "	if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )",
        -: 6129:  "		YY_FATAL_ERROR(",
        -: 6130:  "		\"fatal flex scanner internal error--end of buffer missed\" );",
        -: 6131:  "",
        -: 6132:  "	if ( yy_current_buffer->yy_fill_buffer == 0 )",
        -: 6133:  "		{ /* Don't try to fill the buffer, so this is an EOF. */",
        -: 6134:  "		if ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )",
        -: 6135:  "			{",
        -: 6136:  "			/* We matched a singled characater, the EOB, so",
        -: 6137:  "			 * treat this as a final EOF.",
        -: 6138:  "			 */",
        -: 6139:  "			return EOB_ACT_END_OF_FILE;",
        -: 6140:  "			}",
        -: 6141:  "",
        -: 6142:  "		else",
        -: 6143:  "			{",
        -: 6144:  "			/* We matched some text prior to the EOB, first",
        -: 6145:  "			 * process it.",
        -: 6146:  "			 */",
        -: 6147:  "			return EOB_ACT_LAST_MATCH;",
        -: 6148:  "			}",
        -: 6149:  "		}",
        -: 6150:  "",
        -: 6151:  "	/* Try to read more data. */",
        -: 6152:  "",
        -: 6153:  "	/* First move last chars to start of buffer. */",
        -: 6154:  "	number_to_move = yy_c_buf_p - yytext_ptr;",
        -: 6155:  "",
        -: 6156:  "	for ( i = 0; i < number_to_move; ++i )",
        -: 6157:  "		*(dest++) = *(source++);",
        -: 6158:  "",
        -: 6159:  "	if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )",
        -: 6160:  "		/* don't do the read, it's not guaranteed to return an EOF,",
        -: 6161:  "		 * just force an EOF",
        -: 6162:  "		 */",
        -: 6163:  "		yy_n_chars = 0;",
        -: 6164:  "",
        -: 6165:  "	else",
        -: 6166:  "		{",
        -: 6167:  "		int num_to_read =",
        -: 6168:  "			yy_current_buffer->yy_buf_size - number_to_move - 1;",
        -: 6169:  "",
        -: 6170:  "		while ( num_to_read <= 0 )",
        -: 6171:  "			{ /* Not enough room in the buffer - grow it. */",
        -: 6172:  "#ifdef YY_USES_REJECT",
        -: 6173:  "			YY_FATAL_ERROR(",
        -: 6174:  "\"input buffer overflow, can't enlarge buffer because scanner uses REJECT\" );",
        -: 6175:  "#else",
        -: 6176:  "",
        -: 6177:  "			/* just a shorter name for the current buffer */",
        -: 6178:  "			YY_BUFFER_STATE b = yy_current_buffer;",
        -: 6179:  "",
        -: 6180:  "			int yy_c_buf_p_offset = yy_c_buf_p - b->yy_ch_buf;",
        -: 6181:  "",
        -: 6182:  "			b->yy_buf_size *= 2;",
        -: 6183:  "			b->yy_ch_buf = (char *)",
        -: 6184:  "				yy_flex_realloc( (void *) b->yy_ch_buf,",
        -: 6185:  "						 b->yy_buf_size );",
        -: 6186:  "",
        -: 6187:  "			if ( ! b->yy_ch_buf )",
        -: 6188:  "				YY_FATAL_ERROR(",
        -: 6189:  "				\"fatal error - scanner input buffer overflow\" );",
        -: 6190:  "",
        -: 6191:  "			yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];",
        -: 6192:  "",
        -: 6193:  "			num_to_read = yy_current_buffer->yy_buf_size -",
        -: 6194:  "						number_to_move - 1;",
        -: 6195:  "#endif",
        -: 6196:  "			}",
        -: 6197:  "",
        -: 6198:  "		if ( num_to_read > YY_READ_BUF_SIZE )",
        -: 6199:  "			num_to_read = YY_READ_BUF_SIZE;",
        -: 6200:  "",
        -: 6201:  "		/* Read in more data. */",
        -: 6202:  "		YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),",
        -: 6203:  "			yy_n_chars, num_to_read );",
        -: 6204:  "		}",
        -: 6205:  "",
        -: 6206:  "	if ( yy_n_chars == 0 )",
        -: 6207:  "		{",
        -: 6208:  "		if ( number_to_move - YY_MORE_ADJ == 1 )",
        -: 6209:  "			{",
        -: 6210:  "			ret_val = EOB_ACT_END_OF_FILE;",
        -: 6211:  "			yyrestart( yyin );",
        -: 6212:  "			}",
        -: 6213:  "",
        -: 6214:  "		else",
        -: 6215:  "			{",
        -: 6216:  "			ret_val = EOB_ACT_LAST_MATCH;",
        -: 6217:  "			yy_current_buffer->yy_buffer_status =",
        -: 6218:  "				YY_BUFFER_EOF_PENDING;",
        -: 6219:  "			}",
        -: 6220:  "		}",
        -: 6221:  "",
        -: 6222:  "	else",
        -: 6223:  "		ret_val = EOB_ACT_CONTINUE_SCAN;",
        -: 6224:  "",
        -: 6225:  "	yy_n_chars += number_to_move;",
        -: 6226:  "	yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;",
        -: 6227:  "	yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;",
        -: 6228:  "",
        -: 6229:  "	/* yytext begins at the second character in yy_ch_buf; the first",
        -: 6230:  "	 * character is the one which preceded it before reading in the latest",
        -: 6231:  "	 * buffer; it needs to be kept around in case it's a newline, so",
        -: 6232:  "	 * yy_get_previous_state() will have with '^' rules active.",
        -: 6233:  "	 */",
        -: 6234:  "",
        -: 6235:  "	yytext_ptr = &yy_current_buffer->yy_ch_buf[1];",
        -: 6236:  "",
        -: 6237:  "	return ret_val;",
        -: 6238:  "	}",
        -: 6239:  "",
        -: 6240:  "",
        -: 6241:  "/* yy_get_previous_state - get the state just before the EOB char was reached */",
        -: 6242:  "",
        -: 6243:  "%-",
        -: 6244:  "static yy_state_type yy_get_previous_state()",
        -: 6245:  "%+",
        -: 6246:  "yy_state_type yyFlexLexer::yy_get_previous_state()",
        -: 6247:  "%*",
        -: 6248:  "	{",
        -: 6249:  "	register yy_state_type yy_current_state;",
        -: 6250:  "	register char *yy_cp;",
        -: 6251:  "",
        -: 6252:  "%% code to get the start state into yy_current_state goes here",
        -: 6253:  "",
        -: 6254:  "	for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )",
        -: 6255:  "		{",
        -: 6256:  "%% code to find the next state goes here",
        -: 6257:  "		}",
        -: 6258:  "",
        -: 6259:  "	return yy_current_state;",
        -: 6260:  "	}",
        -: 6261:  "",
        -: 6262:  "",
        -: 6263:  "/* yy_try_NUL_trans - try to make a transition on the NUL character",
        -: 6264:  " *",
        -: 6265:  " * synopsis",
        -: 6266:  " *	next_state = yy_try_NUL_trans( current_state );",
        -: 6267:  " */",
        -: 6268:  "",
        -: 6269:  "%-",
        -: 6270:  "#ifdef YY_USE_PROTOS",
        -: 6271:  "static yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )",
        -: 6272:  "#else",
        -: 6273:  "static yy_state_type yy_try_NUL_trans( yy_current_state )",
        -: 6274:  "yy_state_type yy_current_state;",
        -: 6275:  "#endif",
        -: 6276:  "%+",
        -: 6277:  "yy_state_type yyFlexLexer::yy_try_NUL_trans( yy_state_type yy_current_state )",
        -: 6278:  "%*",
        -: 6279:  "	{",
        -: 6280:  "	register int yy_is_jam;",
        -: 6281:  "%% code to find the next state, and perhaps do backing up, goes here",
        -: 6282:  "",
        -: 6283:  "	return yy_is_jam ? 0 : yy_current_state;",
        -: 6284:  "	}",
        -: 6285:  "",
        -: 6286:  "",
        -: 6287:  "%-",
        -: 6288:  "#ifdef YY_USE_PROTOS",
        -: 6289:  "static void yyunput( int c, register char *yy_bp )",
        -: 6290:  "#else",
        -: 6291:  "static void yyunput( c, yy_bp )",
        -: 6292:  "int c;",
        -: 6293:  "register char *yy_bp;",
        -: 6294:  "#endif",
        -: 6295:  "%+",
        -: 6296:  "void yyFlexLexer::yyunput( int c, register char* yy_bp )",
        -: 6297:  "%*",
        -: 6298:  "	{",
        -: 6299:  "	register char *yy_cp = yy_c_buf_p;",
        -: 6300:  "",
        -: 6301:  "	/* undo effects of setting up yytext */",
        -: 6302:  "	*yy_cp = yy_hold_char;",
        -: 6303:  "",
        -: 6304:  "	if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )",
        -: 6305:  "		{ /* need to shift things up to make room */",
        -: 6306:  "		/* +2 for EOB chars. */",
        -: 6307:  "		register int number_to_move = yy_n_chars + 2;",
        -: 6308:  "		register char *dest = &yy_current_buffer->yy_ch_buf[",
        -: 6309:  "					yy_current_buffer->yy_buf_size + 2];",
        -: 6310:  "		register char *source =",
        -: 6311:  "				&yy_current_buffer->yy_ch_buf[number_to_move];",
        -: 6312:  "",
        -: 6313:  "		while ( source > yy_current_buffer->yy_ch_buf )",
        -: 6314:  "			*--dest = *--source;",
        -: 6315:  "",
        -: 6316:  "		yy_cp += dest - source;",
        -: 6317:  "		yy_bp += dest - source;",
        -: 6318:  "		yy_n_chars = yy_current_buffer->yy_buf_size;",
        -: 6319:  "",
        -: 6320:  "		if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )",
        -: 6321:  "			YY_FATAL_ERROR( \"flex scanner push-back overflow\" );",
        -: 6322:  "		}",
        -: 6323:  "",
        -: 6324:  "	if ( yy_cp > yy_bp && yy_cp[-1] == '\\n' )",
        -: 6325:  "		yy_cp[-2] = '\\n';",
        -: 6326:  "",
        -: 6327:  "	*--yy_cp = (char) c;",
        -: 6328:  "",
        -: 6329:  "%% update yylineno here, if doing -l",
        -: 6330:  "",
        -: 6331:  "	/* Note: the formal parameter *must* be called \"yy_bp\" for this",
        -: 6332:  "	 * macro to now work correctly.",
        -: 6333:  "	 */",
        -: 6334:  "	YY_DO_BEFORE_ACTION; /* set up yytext again */",
        -: 6335:  "	}",
        -: 6336:  "",
        -: 6337:  "",
        -: 6338:  "%-",
        -: 6339:  "#ifdef __cplusplus",
        -: 6340:  "static int yyinput()",
        -: 6341:  "#else",
        -: 6342:  "static int input()",
        -: 6343:  "#endif",
        -: 6344:  "%+",
        -: 6345:  "int yyFlexLexer::yyinput()",
        -: 6346:  "%*",
        -: 6347:  "	{",
        -: 6348:  "	int c;",
        -: 6349:  "",
        -: 6350:  "	*yy_c_buf_p = yy_hold_char;",
        -: 6351:  "",
        -: 6352:  "	if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )",
        -: 6353:  "		{",
        -: 6354:  "		/* yy_c_buf_p now points to the character we want to return.",
        -: 6355:  "		 * If this occurs *before* the EOB characters, then it's a",
        -: 6356:  "		 * valid NUL; if not, then we've hit the end of the buffer.",
        -: 6357:  "		 */",
        -: 6358:  "		if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )",
        -: 6359:  "			/* This was really a NUL. */",
        -: 6360:  "			*yy_c_buf_p = '\\0';",
        -: 6361:  "",
        -: 6362:  "		else",
        -: 6363:  "			{ /* need more input */",
        -: 6364:  "			yytext_ptr = yy_c_buf_p;",
        -: 6365:  "			++yy_c_buf_p;",
        -: 6366:  "",
        -: 6367:  "			switch ( yy_get_next_buffer() )",
        -: 6368:  "				{",
        -: 6369:  "				case EOB_ACT_END_OF_FILE:",
        -: 6370:  "					{",
        -: 6371:  "					if ( yywrap() )",
        -: 6372:  "						{",
        -: 6373:  "						yy_c_buf_p =",
        -: 6374:  "						yytext_ptr + YY_MORE_ADJ;",
        -: 6375:  "						return EOF;",
        -: 6376:  "						}",
        -: 6377:  "",
        -: 6378:  "					YY_NEW_FILE;",
        -: 6379:  "#ifdef __cplusplus",
        -: 6380:  "					return yyinput();",
        -: 6381:  "#else",
        -: 6382:  "					return input();",
        -: 6383:  "#endif",
        -: 6384:  "					}",
        -: 6385:  "",
        -: 6386:  "				case EOB_ACT_CONTINUE_SCAN:",
        -: 6387:  "					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;",
        -: 6388:  "					break;",
        -: 6389:  "",
        -: 6390:  "				case EOB_ACT_LAST_MATCH:",
        -: 6391:  "#ifdef __cplusplus",
        -: 6392:  "					YY_FATAL_ERROR(",
        -: 6393:  "					\"unexpected last match in yyinput()\" );",
        -: 6394:  "#else",
        -: 6395:  "					YY_FATAL_ERROR(",
        -: 6396:  "					\"unexpected last match in input()\" );",
        -: 6397:  "#endif",
        -: 6398:  "				}",
        -: 6399:  "			}",
        -: 6400:  "		}",
        -: 6401:  "",
        -: 6402:  "	c = *(unsigned char *) yy_c_buf_p;	/* cast for 8-bit char's */",
        -: 6403:  "	*yy_c_buf_p = '\\0';	/* preserve yytext */",
        -: 6404:  "	yy_hold_char = *++yy_c_buf_p;",
        -: 6405:  "",
        -: 6406:  "	return c;",
        -: 6407:  "	}",
        -: 6408:  "",
        -: 6409:  "",
        -: 6410:  "%-",
        -: 6411:  "#ifdef YY_USE_PROTOS",
        -: 6412:  "void yyrestart( FILE *input_file )",
        -: 6413:  "#else",
        -: 6414:  "void yyrestart( input_file )",
        -: 6415:  "FILE *input_file;",
        -: 6416:  "#endif",
        -: 6417:  "%+",
        -: 6418:  "void yyFlexLexer::yyrestart( istream* input_file )",
        -: 6419:  "%*",
        -: 6420:  "	{",
        -: 6421:  "	if ( ! yy_current_buffer )",
        -: 6422:  "		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );",
        -: 6423:  "",
        -: 6424:  "	yy_init_buffer( yy_current_buffer, input_file );",
        -: 6425:  "	yy_load_buffer_state();",
        -: 6426:  "	}",
        -: 6427:  "",
        -: 6428:  "",
        -: 6429:  "%-",
        -: 6430:  "#ifdef YY_USE_PROTOS",
        -: 6431:  "void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )",
        -: 6432:  "#else",
        -: 6433:  "void yy_switch_to_buffer( new_buffer )",
        -: 6434:  "YY_BUFFER_STATE new_buffer;",
        -: 6435:  "#endif",
        -: 6436:  "%+",
        -: 6437:  "void yyFlexLexer::yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )",
        -: 6438:  "%*",
        -: 6439:  "	{",
        -: 6440:  "	if ( yy_current_buffer == new_buffer )",
        -: 6441:  "		return;",
        -: 6442:  "",
        -: 6443:  "	if ( yy_current_buffer )",
        -: 6444:  "		{",
        -: 6445:  "		/* Flush out information for old buffer. */",
        -: 6446:  "		*yy_c_buf_p = yy_hold_char;",
        -: 6447:  "		yy_current_buffer->yy_buf_pos = yy_c_buf_p;",
        -: 6448:  "		yy_current_buffer->yy_n_chars = yy_n_chars;",
        -: 6449:  "		}",
        -: 6450:  "",
        -: 6451:  "	yy_current_buffer = new_buffer;",
        -: 6452:  "	yy_load_buffer_state();",
        -: 6453:  "",
        -: 6454:  "	/* We don't actually know whether we did this switch during",
        -: 6455:  "	 * EOF (yywrap()) processing, but the only time this flag",
        -: 6456:  "	 * is looked at is after yywrap() is called, so it's safe",
        -: 6457:  "	 * to go ahead and always set it.",
        -: 6458:  "	 */",
        -: 6459:  "	yy_did_buffer_switch_on_eof = 1;",
        -: 6460:  "	}",
        -: 6461:  "",
        -: 6462:  "",
        -: 6463:  "%-",
        -: 6464:  "#ifdef YY_USE_PROTOS",
        -: 6465:  "void yy_load_buffer_state( void )",
        -: 6466:  "#else",
        -: 6467:  "void yy_load_buffer_state()",
        -: 6468:  "#endif",
        -: 6469:  "%+",
        -: 6470:  "void yyFlexLexer::yy_load_buffer_state()",
        -: 6471:  "%*",
        -: 6472:  "	{",
        -: 6473:  "	yy_n_chars = yy_current_buffer->yy_n_chars;",
        -: 6474:  "	yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;",
        -: 6475:  "	yyin = yy_current_buffer->yy_input_file;",
        -: 6476:  "	yy_hold_char = *yy_c_buf_p;",
        -: 6477:  "	}",
        -: 6478:  "",
        -: 6479:  "",
        -: 6480:  "%-",
        -: 6481:  "#ifdef YY_USE_PROTOS",
        -: 6482:  "YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )",
        -: 6483:  "#else",
        -: 6484:  "YY_BUFFER_STATE yy_create_buffer( file, size )",
        -: 6485:  "FILE *file;",
        -: 6486:  "int size;",
        -: 6487:  "#endif",
        -: 6488:  "%+",
        -: 6489:  "YY_BUFFER_STATE yyFlexLexer::yy_create_buffer( istream* file, int size )",
        -: 6490:  "%*",
        -: 6491:  "	{",
        -: 6492:  "	YY_BUFFER_STATE b;",
        -: 6493:  "",
        -: 6494:  "	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );",
        -: 6495:  "",
        -: 6496:  "	if ( ! b )",
        -: 6497:  "		YY_FATAL_ERROR( \"out of dynamic memory in yy_create_buffer()\" );",
        -: 6498:  "",
        -: 6499:  "	b->yy_buf_size = size;",
        -: 6500:  "",
        -: 6501:  "	/* yy_ch_buf has to be 2 characters longer than the size given because",
        -: 6502:  "	 * we need to put in 2 end-of-buffer characters.",
        -: 6503:  "	 */",
        -: 6504:  "	b->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );",
        -: 6505:  "",
        -: 6506:  "	if ( ! b->yy_ch_buf )",
        -: 6507:  "		YY_FATAL_ERROR( \"out of dynamic memory in yy_create_buffer()\" );",
        -: 6508:  "",
        -: 6509:  "	yy_init_buffer( b, file );",
        -: 6510:  "",
        -: 6511:  "	return b;",
        -: 6512:  "	}",
        -: 6513:  "",
        -: 6514:  "",
        -: 6515:  "%-",
        -: 6516:  "#ifdef YY_USE_PROTOS",
        -: 6517:  "void yy_delete_buffer( YY_BUFFER_STATE b )",
        -: 6518:  "#else",
        -: 6519:  "void yy_delete_buffer( b )",
        -: 6520:  "YY_BUFFER_STATE b;",
        -: 6521:  "#endif",
        -: 6522:  "%+",
        -: 6523:  "void yyFlexLexer::yy_delete_buffer( YY_BUFFER_STATE b )",
        -: 6524:  "%*",
        -: 6525:  "	{",
        -: 6526:  "	if ( b == yy_current_buffer )",
        -: 6527:  "		yy_current_buffer = (YY_BUFFER_STATE) 0;",
        -: 6528:  "",
        -: 6529:  "	yy_flex_free( (void *) b->yy_ch_buf );",
        -: 6530:  "	yy_flex_free( (void *) b );",
        -: 6531:  "	}",
        -: 6532:  "",
        -: 6533:  "",
        -: 6534:  "%-",
        -: 6535:  "#ifdef YY_USE_PROTOS",
        -: 6536:  "void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )",
        -: 6537:  "#else",
        -: 6538:  "void yy_init_buffer( b, file )",
        -: 6539:  "YY_BUFFER_STATE b;",
        -: 6540:  "FILE *file;",
        -: 6541:  "#endif",
        -: 6542:  "%+",
        -: 6543:  "void yyFlexLexer::yy_init_buffer( YY_BUFFER_STATE b, istream* file )",
        -: 6544:  "%*",
        -: 6545:  "	{",
        -: 6546:  "	b->yy_input_file = file;",
        -: 6547:  "",
        -: 6548:  "	/* We put in the '\\n' and start reading from [1] so that an",
        -: 6549:  "	 * initial match-at-newline will be true.",
        -: 6550:  "	 */",
        -: 6551:  "",
        -: 6552:  "	b->yy_ch_buf[0] = '\\n';",
        -: 6553:  "	b->yy_n_chars = 1;",
        -: 6554:  "",
        -: 6555:  "	/* We always need two end-of-buffer characters.  The first causes",
        -: 6556:  "	 * a transition to the end-of-buffer state.  The second causes",
        -: 6557:  "	 * a jam in that state.",
        -: 6558:  "	 */",
        -: 6559:  "	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;",
        -: 6560:  "	b->yy_ch_buf[2] = YY_END_OF_BUFFER_CHAR;",
        -: 6561:  "",
        -: 6562:  "	b->yy_buf_pos = &b->yy_ch_buf[1];",
        -: 6563:  "",
        -: 6564:  "%-",
        -: 6565:  "	b->yy_is_interactive = file ? isatty( fileno(file) ) : 0;",
        -: 6566:  "%+",
        -: 6567:  "	b->yy_is_interactive = 0;",
        -: 6568:  "%*",
        -: 6569:  "",
        -: 6570:  "	b->yy_fill_buffer = 1;",
        -: 6571:  "",
        -: 6572:  "	b->yy_buffer_status = YY_BUFFER_NEW;",
        -: 6573:  "	}",
        -: 6574:  "",
        -: 6575:  "",
        -: 6576:  "%-",
        -: 6577:  "#ifdef YY_USE_PROTOS",
        -: 6578:  "static void yy_push_state( int new_state )",
        -: 6579:  "#else",
        -: 6580:  "static void yy_push_state( new_state )",
        -: 6581:  "int new_state;",
        -: 6582:  "#endif",
        -: 6583:  "%+",
        -: 6584:  "void yyFlexLexer::yy_push_state( int new_state )",
        -: 6585:  "%*",
        -: 6586:  "	{",
        -: 6587:  "	if ( yy_start_stack_ptr >= yy_start_stack_depth )",
        -: 6588:  "		{",
        -: 6589:  "		int new_size;",
        -: 6590:  "",
        -: 6591:  "		yy_start_stack_depth += YY_START_STACK_INCR;",
        -: 6592:  "		new_size = yy_start_stack_depth * sizeof( int );",
        -: 6593:  "",
        -: 6594:  "		if ( ! yy_start_stack )",
        -: 6595:  "			yy_start_stack = (int *) yy_flex_alloc( new_size );",
        -: 6596:  "",
        -: 6597:  "		else",
        -: 6598:  "			yy_start_stack = (int *) yy_flex_realloc(",
        -: 6599:  "					(void *) yy_start_stack, new_size );",
        -: 6600:  "",
        -: 6601:  "		if ( ! yy_start_stack )",
        -: 6602:  "			YY_FATAL_ERROR(",
        -: 6603:  "			\"out of memory expanding start-condition stack\" );",
        -: 6604:  "		}",
        -: 6605:  "",
        -: 6606:  "	yy_start_stack[yy_start_stack_ptr++] = YY_START;",
        -: 6607:  "",
        -: 6608:  "	BEGIN(new_state);",
        -: 6609:  "	}",
        -: 6610:  "",
        -: 6611:  "",
        -: 6612:  "%-",
        -: 6613:  "static void yy_pop_state()",
        -: 6614:  "%+",
        -: 6615:  "void yyFlexLexer::yy_pop_state()",
        -: 6616:  "%*",
        -: 6617:  "	{",
        -: 6618:  "	if ( --yy_start_stack_ptr < 0 )",
        -: 6619:  "		YY_FATAL_ERROR( \"start-condition stack underflow\" );",
        -: 6620:  "",
        -: 6621:  "	BEGIN(yy_start_stack[yy_start_stack_ptr]);",
        -: 6622:  "	}",
        -: 6623:  "",
        -: 6624:  "",
        -: 6625:  "%-",
        -: 6626:  "static int yy_top_state()",
        -: 6627:  "%+",
        -: 6628:  "int yyFlexLexer::yy_top_state()",
        -: 6629:  "%*",
        -: 6630:  "	{",
        -: 6631:  "	return yy_start_stack[yy_start_stack_ptr - 1];",
        -: 6632:  "	}",
        -: 6633:  "",
        -: 6634:  "",
        -: 6635:  "%-",
        -: 6636:  "#ifdef YY_USE_PROTOS",
        -: 6637:  "static void yy_fatal_error( const char msg[] )",
        -: 6638:  "#else",
        -: 6639:  "static void yy_fatal_error( msg )",
        -: 6640:  "char msg[];",
        -: 6641:  "#endif",
        -: 6642:  "	{",
        -: 6643:  "FILE *err;",  /* ### modified(Jan.24.2001) ### */
        -: 6644:  "	(void) fprintf( err, \"%s\\n\", msg );",
        -: 6645:  "	exit( 1 );",
        -: 6646:  "	}",
        -: 6647:  "",
        -: 6648:  "%+",
        -: 6649:  "",
        -: 6650:  "void yyFlexLexer::LexerError( const char msg[] )",
        -: 6651:  "	{",
        -: 6652:  "	cerr << msg << '\\n';",
        -: 6653:  "	exit( 1 );",
        -: 6654:  "	}",
        -: 6655:  "%*",
        -: 6656:  "",
        -: 6657:  "",
        -: 6658:  "/* Redefine yyless() so it works in section 3 code. */",
        -: 6659:  "",
        -: 6660:  "#undef yyless",
        -: 6661:  "#define yyless(n) \\",
        -: 6662:  "	do \\",
        -: 6663:  "		{ \\",
        -: 6664:  "		/* Undo effects of setting up yytext. */ \\",
        -: 6665:  "		yytext[yyleng] = yy_hold_char; \\",
        -: 6666:  "		yy_c_buf_p = yytext + n - YY_MORE_ADJ; \\",
        -: 6667:  "		yy_hold_char = *yy_c_buf_p; \\",
        -: 6668:  "		*yy_c_buf_p = '\\0'; \\",
        -: 6669:  "		yyleng = n; \\",
        -: 6670:  "		} \\",
        -: 6671:  "	while ( 0 )",
        -: 6672:  "",
        -: 6673:  "",
        -: 6674:  "/* Internal utility routines. */",
        -: 6675:  "",
        -: 6676:  "#ifndef yytext_ptr",
        -: 6677:  "#ifdef YY_USE_PROTOS",
        -: 6678:  "static void yy_flex_strncpy( char *s1, const char *s2, int n )",
        -: 6679:  "#else",
        -: 6680:  "static void yy_flex_strncpy( s1, s2, n )",
        -: 6681:  "char *s1;",
        -: 6682:  "const char *s2;",
        -: 6683:  "int n;",
        -: 6684:  "#endif",
        -: 6685:  "	{",
        -: 6686:  "	register int i;",
        -: 6687:  "	for ( i = 0; i < n; ++i )",
        -: 6688:  "		s1[i] = s2[i];",
        -: 6689:  "	}",
        -: 6690:  "#endif",
        -: 6691:  "",
        -: 6692:  "",
        -: 6693:  "#ifdef YY_USE_PROTOS",
        -: 6694:  "static void *yy_flex_alloc( unsigned int size )",
        -: 6695:  "#else",
        -: 6696:  "static void *yy_flex_alloc( size )",
        -: 6697:  "unsigned int size;",
        -: 6698:  "#endif",
        -: 6699:  "	{",
        -: 6700:  "	return (void *) malloc( size );",
        -: 6701:  "	}",
        -: 6702:  "",
        -: 6703:  "#ifdef YY_USE_PROTOS",
        -: 6704:  "static void *yy_flex_realloc( void *ptr, unsigned int size )",
        -: 6705:  "#else",
        -: 6706:  "static void *yy_flex_realloc( ptr, size )",
        -: 6707:  "void *ptr;",
        -: 6708:  "unsigned int size;",
        -: 6709:  "#endif",
        -: 6710:  "	{",
        -: 6711:  "	return (void *) realloc( ptr, size );",
        -: 6712:  "	}",
        -: 6713:  "",
        -: 6714:  "#ifdef YY_USE_PROTOS",
        -: 6715:  "static void yy_flex_free( void *ptr )",
        -: 6716:  "#else",
        -: 6717:  "static void yy_flex_free( ptr )",
        -: 6718:  "void *ptr;",
        -: 6719:  "#endif",
        -: 6720:  "	{",
        -: 6721:  "	free( ptr );",
        -: 6722:  "	}",
        -: 6723:  0
        -: 6724:};
        -: 6725:/* sym - symbol table routines */
        -: 6726:
        -: 6727:/*-
        -: 6728: * Copyright (c) 1990 The Regents of the University of California.
        -: 6729: * All rights reserved.
        -: 6730: *
        -: 6731: * This code is derived from software contributed to Berkeley by
        -: 6732: * Vern Paxson.
        -: 6733: * 
        -: 6734: * The United States Government has rights in this work pursuant
        -: 6735: * to contract no. DE-AC03-76SF00098 between the United States
        -: 6736: * Department of Energy and the University of California.
        -: 6737: *
        -: 6738: * Redistribution and use in source and binary forms are permitted provided
        -: 6739: * that: (1) source distributions retain this entire copyright notice and
        -: 6740: * comment, and (2) distributions including binaries display the following
        -: 6741: * acknowledgement:  ``This product includes software developed by the
        -: 6742: * University of California, Berkeley and its contributors'' in the
        -: 6743: * documentation or other materials provided with the distribution and in
        -: 6744: * all advertising materials mentioning features or use of this software.
        -: 6745: * Neither the name of the University nor the names of its contributors may
        -: 6746: * be used to endorse or promote products derived from this software without
        -: 6747: * specific prior written permission.
        -: 6748: * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
        -: 6749: * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
        -: 6750: * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
        -: 6751: */
        -: 6752:
        -: 6753:/* $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.seeded/v1/flex.c,v 1.1.1.2 2003/09/02 20:21:59 expsir Exp $ */
        -: 6754:
        -: 6755:
        -: 6756:
        -: 6757:/* declare functions that have forward references */
        -: 6758:
        -: 6759:int hashfunct PROTO((register char[], int));
        -: 6760:
        -: 6761:
        -: 6762:struct hash_entry *ndtbl[NAME_TABLE_HASH_SIZE];
        -: 6763:struct hash_entry *sctbl[START_COND_HASH_SIZE];
        -: 6764:struct hash_entry *ccltab[CCL_HASH_SIZE];
        -: 6765:
        -: 6766:struct hash_entry *findsym();
        -: 6767:
        -: 6768:
        -: 6769:/* addsym - add symbol and definitions to symbol table
        -: 6770: *
        -: 6771: * -1 is returned if the symbol already exists, and the change not made.
        -: 6772: */
        -: 6773:
function addsym called 2105 returned 100% blocks executed 93%
     2105: 6774:int addsym( sym, str_def, int_def, table, table_size )
        -: 6775:register char sym[];
        -: 6776:char *str_def;
        -: 6777:int int_def;
        -: 6778:hash_table table;
        -: 6779:int table_size;
        -: 6780:	{
     2105: 6781:	int hash_val = hashfunct( sym, table_size );
call    0 returned 2105
     2105: 6782:	register struct hash_entry *sym_entry = table[hash_val];
        -: 6783:	register struct hash_entry *new_entry;
        -: 6784:	register struct hash_entry *successor;
        -: 6785:
     2337: 6786:	while ( sym_entry )
branch  0 taken 233
branch  1 taken 2104 (fallthrough)
        -: 6787:		{
      233: 6788:		if ( ! strcmp( sym, sym_entry->name ) )
branch  0 taken 1 (fallthrough)
branch  1 taken 232
        -: 6789:			{ /* entry already exists */
        1: 6790:			return -1;
        -: 6791:			}
        -: 6792:
      232: 6793:		sym_entry = sym_entry->next;
        -: 6794:		}
        -: 6795:
        -: 6796:	/* create new entry */
        -: 6797:	new_entry = (struct hash_entry *)
     2104: 6798:		flex_alloc( sizeof( struct hash_entry ) );
call    0 returned 2104
        -: 6799:
     2104: 6800:	if ( new_entry == NULL )
branch  0 taken 0 (fallthrough)
branch  1 taken 2104
    #####: 6801:		flexfatal( "symbol table memory allocation failed" );
call    0 never executed
        -: 6802:
     2104: 6803:	if ( (successor = table[hash_val]) )
branch  0 taken 133 (fallthrough)
branch  1 taken 1971
        -: 6804:		{
      133: 6805:		new_entry->next = successor;
      133: 6806:		successor->prev = new_entry;
        -: 6807:		}
        -: 6808:	else
     1971: 6809:		new_entry->next = NULL;
        -: 6810:
     2104: 6811:	new_entry->prev = NULL;
     2104: 6812:	new_entry->name = sym;
     2104: 6813:	new_entry->str_val = str_def;
     2104: 6814:	new_entry->int_val = int_def;
        -: 6815:
     2104: 6816:	table[hash_val] = new_entry;
        -: 6817:
     2104: 6818:	return 0;
        -: 6819:	}
        -: 6820:
        -: 6821:
        -: 6822:/* cclinstal - save the text of a character class */
        -: 6823:
function cclinstal called 1293 returned 100% blocks executed 100%
     1293: 6824:void cclinstal( ccltxt, cclnum )
        -: 6825:Char ccltxt[];
        -: 6826:int cclnum;
        -: 6827:	{
        -: 6828:	/* We don't bother checking the return status because we are not
        -: 6829:	 * called unless the symbol is new.
        -: 6830:	 */
        -: 6831:	Char *copy_unsigned_string();
        -: 6832:
     1293: 6833:	(void) addsym( (char *) copy_unsigned_string( ccltxt ),
call    0 returned 1293
call    1 returned 1293
        -: 6834:			(char *) 0, cclnum,
        -: 6835:			ccltab, CCL_HASH_SIZE );
     1293: 6836:	}
        -: 6837:
        -: 6838:
        -: 6839:/* ccllookup - lookup the number associated with character class text
        -: 6840: *
        -: 6841: * Returns 0 if there's no CCL associated with the text.
        -: 6842: */
        -: 6843:
function ccllookup called 1524 returned 100% blocks executed 100%
     1524: 6844:int ccllookup( ccltxt )
        -: 6845:Char ccltxt[];
        -: 6846:	{
     1524: 6847:	return findsym( (char *) ccltxt, ccltab, CCL_HASH_SIZE )->int_val;
call    0 returned 1524
        -: 6848:	}
        -: 6849:
        -: 6850:
        -: 6851:/* findsym - find symbol in symbol table */
        -: 6852:
function findsym called 1996 returned 100% blocks executed 100%
     1996: 6853:struct hash_entry *findsym( sym, table, table_size )
        -: 6854:register char sym[];
        -: 6855:hash_table table;
        -: 6856:int table_size;
        -: 6857:	{
        -: 6858:	static struct hash_entry empty_entry =
        -: 6859:		{
        -: 6860:		(struct hash_entry *) 0, (struct hash_entry *) 0,
        -: 6861:		(char *) 0, (char *) 0, 0,
        -: 6862:		} ;
     1996: 6863:	register struct hash_entry *sym_entry =
     1996: 6864:		table[hashfunct( sym, table_size )];
call    0 returned 1996
        -: 6865:
     2228: 6866:	while ( sym_entry )
branch  0 taken 931
branch  1 taken 1297 (fallthrough)
        -: 6867:		{
      931: 6868:		if ( ! strcmp( sym, sym_entry->name ) )
branch  0 taken 699 (fallthrough)
branch  1 taken 232
      699: 6869:			return sym_entry;
      232: 6870:		sym_entry = sym_entry->next;
        -: 6871:		}
        -: 6872:
     1297: 6873:	return &empty_entry;
        -: 6874:	}
        -: 6875:
        -: 6876:    
        -: 6877:/* hashfunct - compute the hash value for "str" and hash size "hash_size" */
        -: 6878:
function hashfunct called 4101 returned 100% blocks executed 100%
     4101: 6879:int hashfunct( str, hash_size )
        -: 6880:register char str[];
        -: 6881:int hash_size;
        -: 6882:	{
        -: 6883:	register int hashval;
        -: 6884:	register int locstr;
        -: 6885:
     4101: 6886:	hashval = 0;
     4101: 6887:	locstr = 0;
        -: 6888:
    26034: 6889:	while ( str[locstr] )
branch  0 taken 21933
branch  1 taken 4101 (fallthrough)
        -: 6890:		{
    21933: 6891:		hashval = (hashval << 1) + (unsigned char) str[locstr++];
    21933: 6892:		hashval %= hash_size;
        -: 6893:		}
        -: 6894:
     4101: 6895:	return hashval;
        -: 6896:	}
        -: 6897:
        -: 6898:
        -: 6899:/* ndinstal - install a name definition */
        -: 6900:
function ndinstal called 241 returned 100% blocks executed 100%
      241: 6901:void ndinstal( name, definition )
        -: 6902:char name[];
        -: 6903:Char definition[];
        -: 6904:	{
        -: 6905:	char *copy_string();
        -: 6906:	Char *copy_unsigned_string();
        -: 6907:
      241: 6908:	if ( addsym( copy_string( name ),
call    0 returned 241
call    1 returned 241
branch  2 taken 1 (fallthrough)
branch  3 taken 240
      241: 6909:			(char *) copy_unsigned_string( definition ), 0,
call    0 returned 241
        -: 6910:			ndtbl, NAME_TABLE_HASH_SIZE ) )
        1: 6911:		synerr( "name defined twice" );
call    0 returned 1
      241: 6912:	}
        -: 6913:
        -: 6914:
        -: 6915:/* ndlookup - lookup a name definition
        -: 6916: *
        -: 6917: * Returns a nil pointer if the name definition does not exist.
        -: 6918: */
        -: 6919:
function ndlookup called 455 returned 100% blocks executed 100%
      455: 6920:Char *ndlookup( nd )
        -: 6921:char nd[];
        -: 6922:	{
      455: 6923:	return (Char *) findsym( nd, ndtbl, NAME_TABLE_HASH_SIZE )->str_val;
call    0 returned 455
        -: 6924:	}
        -: 6925:
        -: 6926:
        -: 6927:/* scextend - increase the maximum number of start conditions */
        -: 6928:
function scextend called 0 returned 0% blocks executed 0%
    #####: 6929:void scextend()
        -: 6930:	{
    #####: 6931:	current_max_scs += MAX_SCS_INCREMENT;
        -: 6932:
    #####: 6933:	++num_reallocs;
        -: 6934:
    #####: 6935:	scset = reallocate_integer_array( scset, current_max_scs );
call    0 never executed
    #####: 6936:	scbol = reallocate_integer_array( scbol, current_max_scs );
call    0 never executed
    #####: 6937:	scxclu = reallocate_integer_array( scxclu, current_max_scs );
call    0 never executed
    #####: 6938:	sceof = reallocate_integer_array( sceof, current_max_scs );
call    0 never executed
    #####: 6939:	scname = reallocate_char_ptr_array( scname, current_max_scs );
call    0 never executed
    #####: 6940:	actvsc = reallocate_integer_array( actvsc, current_max_scs );
call    0 never executed
    #####: 6941:	}
        -: 6942:
        -: 6943:
        -: 6944:/* scinstal - make a start condition
        -: 6945: *
        -: 6946: * NOTE
        -: 6947: *    The start condition is "exclusive" if xcluflg is true.
        -: 6948: */
        -: 6949:
function scinstal called 571 returned 100% blocks executed 80%
      571: 6950:void scinstal( str, xcluflg )
        -: 6951:char str[];
        -: 6952:int xcluflg;
        -: 6953:	{
        -: 6954:	char *copy_string();
        -: 6955:
        -: 6956:	/* Generate start condition definition, for use in BEGIN et al. */
      571: 6957:	printf( "#define %s %d\n", str, lastsc );
call    0 returned 571
        -: 6958:
      571: 6959:	if ( ++lastsc >= current_max_scs )
branch  0 taken 0 (fallthrough)
branch  1 taken 571
    #####: 6960:		scextend();
call    0 never executed
        -: 6961:
      571: 6962:	scname[lastsc] = copy_string( str );
call    0 returned 571
        -: 6963:
      571: 6964:	if ( addsym( scname[lastsc], (char *) 0, lastsc,
call    0 returned 571
branch  1 taken 0 (fallthrough)
branch  2 taken 571
        -: 6965:			sctbl, START_COND_HASH_SIZE ) )
    #####: 6966:		format_pinpoint_message( "start condition %s declared twice",
call    0 never executed
        -: 6967:					str );
        -: 6968:
      571: 6969:	scset[lastsc] = mkstate( SYM_EPSILON );
call    0 returned 571
      571: 6970:	scbol[lastsc] = mkstate( SYM_EPSILON );
call    0 returned 571
      571: 6971:	scxclu[lastsc] = xcluflg;
      571: 6972:	sceof[lastsc] = false;
      571: 6973:	}
        -: 6974:
        -: 6975:
        -: 6976:/* sclookup - lookup the number associated with a start condition
        -: 6977: *
        -: 6978: * Returns 0 if no such start condition.
        -: 6979: */
        -: 6980:
function sclookup called 17 returned 100% blocks executed 100%
       17: 6981:int sclookup( str )
        -: 6982:char str[];
        -: 6983:	{
       17: 6984:	return findsym( str, sctbl, START_COND_HASH_SIZE )->int_val;
call    0 returned 17
        -: 6985:	}
        -: 6986:/* tblcmp - table compression routines */
        -: 6987:
        -: 6988:/*-
        -: 6989: * Copyright (c) 1990 The Regents of the University of California.
        -: 6990: * All rights reserved.
        -: 6991: *
        -: 6992: * This code is derived from software contributed to Berkeley by
        -: 6993: * Vern Paxson.
        -: 6994: * 
        -: 6995: * The United States Government has rights in this work pursuant
        -: 6996: * to contract no. DE-AC03-76SF00098 between the United States
        -: 6997: * Department of Energy and the University of California.
        -: 6998: *
        -: 6999: * Redistribution and use in source and binary forms are permitted provided
        -: 7000: * that: (1) source distributions retain this entire copyright notice and
        -: 7001: * comment, and (2) distributions including binaries display the following
        -: 7002: * acknowledgement:  ``This product includes software developed by the
        -: 7003: * University of California, Berkeley and its contributors'' in the
        -: 7004: * documentation or other materials provided with the distribution and in
        -: 7005: * all advertising materials mentioning features or use of this software.
        -: 7006: * Neither the name of the University nor the names of its contributors may
        -: 7007: * be used to endorse or promote products derived from this software without
        -: 7008: * specific prior written permission.
        -: 7009: * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
        -: 7010: * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
        -: 7011: * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
        -: 7012: */
        -: 7013:
        -: 7014:/* $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.seeded/v1/flex.c,v 1.1.1.2 2003/09/02 20:21:59 expsir Exp $ */
        -: 7015:
        -: 7016:
        -: 7017:
        -: 7018:/* declarations for functions that have forward references */
        -: 7019:
        -: 7020:void mkentry PROTO((register int*, int, int, int, int));
        -: 7021:void mkprot PROTO((int[], int, int));
        -: 7022:void mktemplate PROTO((int[], int, int));
        -: 7023:void mv2front PROTO((int));
        -: 7024:int tbldiff PROTO((int[], int, int[]));
        -: 7025:
        -: 7026:
        -: 7027:/* bldtbl - build table entries for dfa state
        -: 7028: *
        -: 7029: * synopsis
        -: 7030: *   int state[numecs], statenum, totaltrans, comstate, comfreq;
        -: 7031: *   bldtbl( state, statenum, totaltrans, comstate, comfreq );
        -: 7032: *
        -: 7033: * State is the statenum'th dfa state.  It is indexed by equivalence class and
        -: 7034: * gives the number of the state to enter for a given equivalence class.
        -: 7035: * totaltrans is the total number of transitions out of the state.  Comstate
        -: 7036: * is that state which is the destination of the most transitions out of State.
        -: 7037: * Comfreq is how many transitions there are out of State to Comstate.
        -: 7038: *
        -: 7039: * A note on terminology:
        -: 7040: *    "protos" are transition tables which have a high probability of
        -: 7041: * either being redundant (a state processed later will have an identical
        -: 7042: * transition table) or nearly redundant (a state processed later will have
        -: 7043: * many of the same out-transitions).  A "most recently used" queue of
        -: 7044: * protos is kept around with the hope that most states will find a proto
        -: 7045: * which is similar enough to be usable, and therefore compacting the
        -: 7046: * output tables.
        -: 7047: *    "templates" are a special type of proto.  If a transition table is
        -: 7048: * homogeneous or nearly homogeneous (all transitions go to the same
        -: 7049: * destination) then the odds are good that future states will also go
        -: 7050: * to the same destination state on basically the same character set.
        -: 7051: * These homogeneous states are so common when dealing with large rule
        -: 7052: * sets that they merit special attention.  If the transition table were
        -: 7053: * simply made into a proto, then (typically) each subsequent, similar
        -: 7054: * state will differ from the proto for two out-transitions.  One of these
        -: 7055: * out-transitions will be that character on which the proto does not go
        -: 7056: * to the common destination, and one will be that character on which the
        -: 7057: * state does not go to the common destination.  Templates, on the other
        -: 7058: * hand, go to the common state on EVERY transition character, and therefore
        -: 7059: * cost only one difference.
        -: 7060: */
        -: 7061:
function bldtbl called 10804 returned 100% blocks executed 100%
    10804: 7062:void bldtbl( state, statenum, totaltrans, comstate, comfreq )
        -: 7063:int state[], statenum, totaltrans, comstate, comfreq;
        -: 7064:	{
        -: 7065:	int extptr, extrct[2][CSIZE + 1];
        -: 7066:	int mindiff, minprot, i, d;
        -: 7067:
        -: 7068:	/* If extptr is 0 then the first array of extrct holds the result
        -: 7069:	 * of the "best difference" to date, which is those transitions
        -: 7070:	 * which occur in "state" but not in the proto which, to date,
        -: 7071:	 * has the fewest differences between itself and "state".  If
        -: 7072:	 * extptr is 1 then the second array of extrct hold the best
        -: 7073:	 * difference.  The two arrays are toggled between so that the
        -: 7074:	 * best difference to date can be kept around and also a difference
        -: 7075:	 * just created by checking against a candidate "best" proto.
        -: 7076:	 */
        -: 7077:
    10804: 7078:	extptr = 0;
        -: 7079:
        -: 7080:	/* If the state has too few out-transitions, don't bother trying to
        -: 7081:	 * compact its tables.
        -: 7082:	 */
        -: 7083:
    10804: 7084:	if ( (totaltrans * 100) < (numecs * PROTO_SIZE_PERCENTAGE) )
branch  0 taken 6801 (fallthrough)
branch  1 taken 4003
     6801: 7085:		mkentry( state, numecs, statenum, JAMSTATE, totaltrans );
call    0 returned 6801
        -: 7086:
        -: 7087:	else
        -: 7088:		{
        -: 7089:		/* "checkcom" is true if we should only check "state" against
        -: 7090:		 * protos which have the same "comstate" value.
        -: 7091:		 */
     4003: 7092:		int checkcom =
     4003: 7093:			comfreq * 100 > totaltrans * CHECK_COM_PERCENTAGE;
        -: 7094:
     4003: 7095:		minprot = firstprot;
     4003: 7096:		mindiff = totaltrans;
        -: 7097:
     4003: 7098:		if ( checkcom )
branch  0 taken 2570 (fallthrough)
branch  1 taken 1433
        -: 7099:			{
        -: 7100:			/* Find first proto which has the same "comstate". */
     3831: 7101:			for ( i = firstprot; i != NIL; i = protnext[i] )
branch  0 taken 3159
branch  1 taken 672 (fallthrough)
     3159: 7102:				if ( protcomst[i] == comstate )
branch  0 taken 1898 (fallthrough)
branch  1 taken 1261
        -: 7103:					{
     1898: 7104:					minprot = i;
     1898: 7105:					mindiff = tbldiff( state, minprot,
     1898: 7106:							extrct[extptr] );
call    0 returned 1898
     1898: 7107:					break;
        -: 7108:					}
        -: 7109:			}
        -: 7110:
        -: 7111:		else
        -: 7112:			{
        -: 7113:			/* Since we've decided that the most common destination
        -: 7114:			 * out of "state" does not occur with a high enough
        -: 7115:			 * frequency, we set the "comstate" to zero, assuring
        -: 7116:			 * that if this state is entered into the proto list,
        -: 7117:			 * it will not be considered a template.
        -: 7118:			 */
     1433: 7119:			comstate = 0;
        -: 7120:
     1433: 7121:			if ( firstprot != NIL )
branch  0 taken 1289 (fallthrough)
branch  1 taken 144
        -: 7122:				{
     1289: 7123:				minprot = firstprot;
     1289: 7124:				mindiff = tbldiff( state, minprot,
     1289: 7125:						extrct[extptr] );
call    0 returned 1289
        -: 7126:				}
        -: 7127:			}
        -: 7128:
        -: 7129:		/* We now have the first interesting proto in "minprot".  If
        -: 7130:		 * it matches within the tolerances set for the first proto,
        -: 7131:		 * we don't want to bother scanning the rest of the proto list
        -: 7132:		 * to see if we have any other reasonable matches.
        -: 7133:		 */
        -: 7134:
     4003: 7135:		if ( mindiff * 100 > totaltrans * FIRST_MATCH_DIFF_PERCENTAGE )
branch  0 taken 1657 (fallthrough)
branch  1 taken 2346
        -: 7136:			{
        -: 7137:			/* Not a good enough match.  Scan the rest of the
        -: 7138:			 * protos.
        -: 7139:			 */
    14106: 7140:			for ( i = minprot; i != NIL; i = protnext[i] )
branch  0 taken 12449
branch  1 taken 1657 (fallthrough)
        -: 7141:				{
    12449: 7142:				d = tbldiff( state, i, extrct[1 - extptr] );
call    0 returned 12449
    12449: 7143:				if ( d < mindiff )
branch  0 taken 72 (fallthrough)
branch  1 taken 12377
        -: 7144:					{
       72: 7145:					extptr = 1 - extptr;
       72: 7146:					mindiff = d;
       72: 7147:					minprot = i;
        -: 7148:					}
        -: 7149:				}
        -: 7150:			}
        -: 7151:
        -: 7152:		/* Check if the proto we've decided on as our best bet is close
        -: 7153:		 * enough to the state we want to match to be usable.
        -: 7154:		 */
        -: 7155:
     4003: 7156:		if ( mindiff * 100 > totaltrans * ACCEPTABLE_DIFF_PERCENTAGE )
branch  0 taken 865 (fallthrough)
branch  1 taken 3138
        -: 7157:			{
        -: 7158:			/* No good.  If the state is homogeneous enough,
        -: 7159:			 * we make a template out of it.  Otherwise, we
        -: 7160:			 * make a proto.
        -: 7161:			 */
        -: 7162:
      865: 7163:			if ( comfreq * 100 >=
      865: 7164:			     totaltrans * TEMPLATE_SAME_PERCENTAGE )
branch  0 taken 628 (fallthrough)
branch  1 taken 237
      628: 7165:				mktemplate( state, statenum, comstate );
call    0 returned 628
        -: 7166:
        -: 7167:			else
        -: 7168:				{
      237: 7169:				mkprot( state, statenum, comstate );
call    0 returned 237
      237: 7170:				mkentry( state, numecs, statenum,
call    0 returned 237
        -: 7171:					JAMSTATE, totaltrans );
        -: 7172:				}
        -: 7173:			}
        -: 7174:
        -: 7175:		else
        -: 7176:			{ /* use the proto */
     3138: 7177:			mkentry( extrct[extptr], numecs, statenum,
call    0 returned 3138
        -: 7178:				prottbl[minprot], mindiff );
        -: 7179:
        -: 7180:			/* If this state was sufficiently different from the
        -: 7181:			 * proto we built it from, make it, too, a proto.
        -: 7182:			 */
        -: 7183:
     3138: 7184:			if ( mindiff * 100 >=
     3138: 7185:			     totaltrans * NEW_PROTO_DIFF_PERCENTAGE )
branch  0 taken 118 (fallthrough)
branch  1 taken 3020
      118: 7186:				mkprot( state, statenum, comstate );
call    0 returned 118
        -: 7187:
        -: 7188:			/* Since mkprot added a new proto to the proto queue,
        -: 7189:			 * it's possible that "minprot" is no longer on the
        -: 7190:			 * proto queue (if it happened to have been the last
        -: 7191:			 * entry, it would have been bumped off).  If it's
        -: 7192:			 * not there, then the new proto took its physical
        -: 7193:			 * place (though logically the new proto is at the
        -: 7194:			 * beginning of the queue), so in that case the
        -: 7195:			 * following call will do nothing.
        -: 7196:			 */
        -: 7197:
     3138: 7198:			mv2front( minprot );
call    0 returned 3138
        -: 7199:			}
        -: 7200:		}
    10804: 7201:	}
        -: 7202:
        -: 7203:
        -: 7204:/* cmptmps - compress template table entries
        -: 7205: *
        -: 7206: * Template tables are compressed by using the 'template equivalence
        -: 7207: * classes', which are collections of transition character equivalence
        -: 7208: * classes which always appear together in templates - really meta-equivalence
        -: 7209: * classes.
        -: 7210: */
        -: 7211:
function cmptmps called 428 returned 100% blocks executed 95%
      428: 7212:void cmptmps()
        -: 7213:	{
        -: 7214:	int tmpstorage[CSIZE + 1];
      428: 7215:	register int *tmp = tmpstorage, i, j;
        -: 7216:	int totaltrans, trans;
        -: 7217:
      428: 7218:	peakpairs = numtemps * numecs + tblend;
        -: 7219:
      428: 7220:	if ( usemecs )
branch  0 taken 214 (fallthrough)
branch  1 taken 214
        -: 7221:		{
        -: 7222:		/* Create equivalence classes based on data gathered on
        -: 7223:		 * template transitions.
        -: 7224:		 */
      214: 7225:		nummecs = cre8ecs( tecfwd, tecbck, numecs );
call    0 returned 214
        -: 7226:		}
        -: 7227:
        -: 7228:	else
      214: 7229:		nummecs = numecs;
        -: 7230:
      428: 7231:	while ( lastdfa + numtemps + 1 >= current_max_dfas )
branch  0 taken 0
branch  1 taken 428 (fallthrough)
    #####: 7232:		increase_max_dfas();
call    0 never executed
        -: 7233:
        -: 7234:	/* Loop through each template. */
        -: 7235:
     1056: 7236:	for ( i = 1; i <= numtemps; ++i )
branch  0 taken 628
branch  1 taken 428 (fallthrough)
        -: 7237:		{
        -: 7238:		/* Number of non-jam transitions out of this template. */
      628: 7239:		totaltrans = 0;
        -: 7240:
    58895: 7241:		for ( j = 1; j <= numecs; ++j )
branch  0 taken 58267
branch  1 taken 628 (fallthrough)
        -: 7242:			{
    58267: 7243:			trans = tnxt[numecs * i + j];
        -: 7244:
    58267: 7245:			if ( usemecs )
branch  0 taken 27518 (fallthrough)
branch  1 taken 30749
        -: 7246:				{
        -: 7247:				/* The absolute value of tecbck is the
        -: 7248:				 * meta-equivalence class of a given
        -: 7249:				 * equivalence class, as set up by cre8ecs().
        -: 7250:				 */
    27518: 7251:				if ( tecbck[j] > 0 )
branch  0 taken 960 (fallthrough)
branch  1 taken 26558
        -: 7252:					{
      960: 7253:					tmp[tecbck[j]] = trans;
        -: 7254:
      960: 7255:					if ( trans > 0 )
branch  0 taken 458 (fallthrough)
branch  1 taken 502
      458: 7256:						++totaltrans;
        -: 7257:					}
        -: 7258:				}
        -: 7259:
        -: 7260:			else
        -: 7261:				{
    30749: 7262:				tmp[j] = trans;
        -: 7263:
    30749: 7264:				if ( trans > 0 )
branch  0 taken 29563 (fallthrough)
branch  1 taken 1186
    29563: 7265:					++totaltrans;
        -: 7266:				}
        -: 7267:			}
        -: 7268:
        -: 7269:		/* It is assumed (in a rather subtle way) in the skeleton
        -: 7270:		 * that if we're using meta-equivalence classes, the def[]
        -: 7271:		 * entry for all templates is the jam template, i.e.,
        -: 7272:		 * templates never default to other non-jam table entries
        -: 7273:		 * (e.g., another template)
        -: 7274:		 */
        -: 7275:
        -: 7276:		/* Leave room for the jam-state after the last real state. */
      628: 7277:		mkentry( tmp, nummecs, lastdfa + i + 1, JAMSTATE, totaltrans );
call    0 returned 628
        -: 7278:		}
      428: 7279:	}
        -: 7280:
        -: 7281:
        -: 7282:
        -: 7283:/* expand_nxt_chk - expand the next check arrays */
        -: 7284:
function expand_nxt_chk called 32 returned 100% blocks executed 100%
       32: 7285:void expand_nxt_chk()
        -: 7286:	{
       32: 7287:	register int old_max = current_max_xpairs;
        -: 7288:
       32: 7289:	current_max_xpairs += MAX_XPAIRS_INCREMENT;
        -: 7290:
       32: 7291:	++num_reallocs;
        -: 7292:
       32: 7293:	nxt = reallocate_integer_array( nxt, current_max_xpairs );
call    0 returned 32
       32: 7294:	chk = reallocate_integer_array( chk, current_max_xpairs );
call    0 returned 32
        -: 7295:
       32: 7296:	zero_out( (char *) (chk + old_max),
call    0 returned 32
        -: 7297:		MAX_XPAIRS_INCREMENT * sizeof( int ) / sizeof( char ) );
       32: 7298:	}
        -: 7299:
        -: 7300:
        -: 7301:/* find_table_space - finds a space in the table for a state to be placed
        -: 7302: *
        -: 7303: * synopsis
        -: 7304: *     int *state, numtrans, block_start;
        -: 7305: *     int find_table_space();
        -: 7306: *
        -: 7307: *     block_start = find_table_space( state, numtrans );
        -: 7308: *
        -: 7309: * State is the state to be added to the full speed transition table.
        -: 7310: * Numtrans is the number of out-transitions for the state.
        -: 7311: *
        -: 7312: * find_table_space() returns the position of the start of the first block (in
        -: 7313: * chk) able to accommodate the state
        -: 7314: *
        -: 7315: * In determining if a state will or will not fit, find_table_space() must take
        -: 7316: * into account the fact that an end-of-buffer state will be added at [0],
        -: 7317: * and an action number will be added in [-1].
        -: 7318: */
        -: 7319:
function find_table_space called 2262 returned 100% blocks executed 93%
     2262: 7320:int find_table_space( state, numtrans )
        -: 7321:int *state, numtrans;
        -: 7322:	{
        -: 7323:	/* Firstfree is the position of the first possible occurrence of two
        -: 7324:	 * consecutive unused records in the chk and nxt arrays.
        -: 7325:	 */
        -: 7326:	register int i;
        -: 7327:	register int *state_ptr, *chk_ptr;
        -: 7328:	register int *ptr_to_last_entry_in_state;
        -: 7329:
        -: 7330:	/* If there are too many out-transitions, put the state at the end of
        -: 7331:	 * nxt and chk.
        -: 7332:	 */
     2262: 7333:	if ( numtrans > MAX_XTIONS_FULL_INTERIOR_FIT )
branch  0 taken 764 (fallthrough)
branch  1 taken 1498
        -: 7334:		{
        -: 7335:		/* If table is empty, return the first available spot in
        -: 7336:		 * chk/nxt, which should be 1.
        -: 7337:		 */
      764: 7338:		if ( tblend < 2 )
branch  0 taken 0 (fallthrough)
branch  1 taken 764
    #####: 7339:			return 1;
        -: 7340:
        -: 7341:		/* Start searching for table space near the end of
        -: 7342:		 * chk/nxt arrays.
        -: 7343:		 */
      764: 7344:		i = tblend - numecs;
        -: 7345:		}
        -: 7346:
        -: 7347:	else
        -: 7348:		/* Start searching for table space from the beginning
        -: 7349:		 * (skipping only the elements which will definitely not
        -: 7350:		 * hold the new state).
        -: 7351:		 */
     1498: 7352:		i = firstfree;
        -: 7353:
        -: 7354:	while ( 1 )	/* loops until a space is found */
        -: 7355:		{
    14707: 7356:		while ( i + numecs >= current_max_xpairs )
branch  0 taken 0
branch  1 taken 14707 (fallthrough)
    #####: 7357:			expand_nxt_chk();
call    0 never executed
        -: 7358:
        -: 7359:		/* Loops until space for end-of-buffer and action number
        -: 7360:		 * are found.
        -: 7361:		 */
        -: 7362:		while ( 1 )
        -: 7363:			{
        -: 7364:			/* Check for action number space. */
    58555: 7365:			if ( chk[i - 1] == 0 )
branch  0 taken 15749 (fallthrough)
branch  1 taken 42806
        -: 7366:				{
        -: 7367:				/* Check for end-of-buffer space. */
    15749: 7368:				if ( chk[i] == 0 )
branch  0 taken 14707 (fallthrough)
branch  1 taken 1042
    14707: 7369:					break;
        -: 7370:
        -: 7371:				else
        -: 7372:					/* Since i != 0, there is no use
        -: 7373:					 * checking to see if (++i) - 1 == 0,
        -: 7374:					 * because that's the same as i == 0,
        -: 7375:					 * so we skip a space.
        -: 7376:					 */
     1042: 7377:					i += 2;
        -: 7378:				}
        -: 7379:
        -: 7380:			else
    42806: 7381:				++i;
        -: 7382:
    43858: 7383:			while ( i + numecs >= current_max_xpairs )
branch  0 taken 10
branch  1 taken 43848 (fallthrough)
       10: 7384:				expand_nxt_chk();
call    0 returned 10
        -: 7385:			}
        -: 7386:
        -: 7387:		/* If we started search from the beginning, store the new
        -: 7388:		 * firstfree for the next call of find_table_space().
        -: 7389:		 */
    14707: 7390:		if ( numtrans <= MAX_XTIONS_FULL_INTERIOR_FIT )
branch  0 taken 2239 (fallthrough)
branch  1 taken 12468
     2239: 7391:			firstfree = i + 1;
        -: 7392:
        -: 7393:		/* Check to see if all elements in chk (and therefore nxt)
        -: 7394:		 * that are needed for the new state have not yet been taken.
        -: 7395:		 */
        -: 7396:
    14707: 7397:		state_ptr = &state[1];
    14707: 7398:		ptr_to_last_entry_in_state = &chk[i + numecs + 1];
        -: 7399:
    14707: 7400:		for ( chk_ptr = &chk[i + 1];
   788801: 7401:		      chk_ptr != ptr_to_last_entry_in_state; ++chk_ptr )
branch  0 taken 786539
branch  1 taken 2262 (fallthrough)
   786539: 7402:			if ( *(state_ptr++) != 0 && *chk_ptr != 0 )
branch  0 taken 100036 (fallthrough)
branch  1 taken 686503
branch  2 taken 12445 (fallthrough)
branch  3 taken 87591
    12445: 7403:				break;
        -: 7404:
    14707: 7405:		if ( chk_ptr == ptr_to_last_entry_in_state )
branch  0 taken 2262 (fallthrough)
branch  1 taken 12445
     2262: 7406:			return i;
        -: 7407:
        -: 7408:		else
    12445: 7409:		++i;
        -: 7410:		}
        -: 7411:	}
        -: 7412:
        -: 7413:
        -: 7414:/* inittbl - initialize transition tables
        -: 7415: *
        -: 7416: * Initializes "firstfree" to be one beyond the end of the table.  Initializes
        -: 7417: * all "chk" entries to be zero.
        -: 7418: */
function inittbl called 543 returned 100% blocks executed 100%
      543: 7419:void inittbl()
        -: 7420:	{
        -: 7421:	register int i;
        -: 7422:
      543: 7423:	zero_out( (char *) chk,
call    0 returned 543
        -: 7424:		current_max_xpairs * sizeof( int ) / sizeof( char ) );
        -: 7425:
      543: 7426:	tblend = 0;
      543: 7427:	firstfree = tblend + 1;
      543: 7428:	numtemps = 0;
        -: 7429:
      543: 7430:	if ( usemecs )
branch  0 taken 214 (fallthrough)
branch  1 taken 329
        -: 7431:		{
        -: 7432:		/* Set up doubly-linked meta-equivalence classes; these
        -: 7433:		 * are sets of equivalence classes which all have identical
        -: 7434:		 * transitions out of TEMPLATES.
        -: 7435:		 */
        -: 7436:
      214: 7437:		tecbck[1] = NIL;
        -: 7438:
    22296: 7439:		for ( i = 2; i <= numecs; ++i )
branch  0 taken 22082
branch  1 taken 214 (fallthrough)
        -: 7440:			{
    22082: 7441:			tecbck[i] = i - 1;
    22082: 7442:			tecfwd[i - 1] = i;
        -: 7443:			}
        -: 7444:
      214: 7445:		tecfwd[numecs] = NIL;
        -: 7446:		}
      543: 7447:	}
        -: 7448:
        -: 7449:
        -: 7450:/* mkdeftbl - make the default, "jam" table entries */
        -: 7451:
function mkdeftbl called 428 returned 100% blocks executed 100%
      428: 7452:void mkdeftbl()
        -: 7453:	{
        -: 7454:	int i;
        -: 7455:
      428: 7456:	jamstate = lastdfa + 1;
        -: 7457:
      428: 7458:	++tblend; /* room for transition on end-of-buffer character */
        -: 7459:
      446: 7460:	while ( tblend + numecs >= current_max_xpairs )
branch  0 taken 18
branch  1 taken 428 (fallthrough)
       18: 7461:		expand_nxt_chk();
call    0 returned 18
        -: 7462:
        -: 7463:	/* Add in default end-of-buffer transition. */
      428: 7464:	nxt[tblend] = end_of_buffer_state;
      428: 7465:	chk[tblend] = jamstate;
        -: 7466:
    48468: 7467:	for ( i = 1; i <= numecs; ++i )
branch  0 taken 48040
branch  1 taken 428 (fallthrough)
        -: 7468:		{
    48040: 7469:		nxt[tblend + i] = 0;
    48040: 7470:		chk[tblend + i] = jamstate;
        -: 7471:		}
        -: 7472:
      428: 7473:	jambase = tblend;
        -: 7474:
      428: 7475:	base[jamstate] = jambase;
      428: 7476:	def[jamstate] = 0;
        -: 7477:
      428: 7478:	tblend += numecs;
      428: 7479:	++numtemps;
      428: 7480:	}
        -: 7481:
        -: 7482:
        -: 7483:/* mkentry - create base/def and nxt/chk entries for transition array
        -: 7484: *
        -: 7485: * synopsis
        -: 7486: *   int state[numchars + 1], numchars, statenum, deflink, totaltrans;
        -: 7487: *   mkentry( state, numchars, statenum, deflink, totaltrans );
        -: 7488: *
        -: 7489: * "state" is a transition array "numchars" characters in size, "statenum"
        -: 7490: * is the offset to be used into the base/def tables, and "deflink" is the
        -: 7491: * entry to put in the "def" table entry.  If "deflink" is equal to
        -: 7492: * "JAMSTATE", then no attempt will be made to fit zero entries of "state"
        -: 7493: * (i.e., jam entries) into the table.  It is assumed that by linking to
        -: 7494: * "JAMSTATE" they will be taken care of.  In any case, entries in "state"
        -: 7495: * marking transitions to "SAME_TRANS" are treated as though they will be
        -: 7496: * taken care of by whereever "deflink" points.  "totaltrans" is the total
        -: 7497: * number of transitions out of the state.  If it is below a certain threshold,
        -: 7498: * the tables are searched for an interior spot that will accommodate the
        -: 7499: * state array.
        -: 7500: */
        -: 7501:
function mkentry called 11432 returned 100% blocks executed 98%
    11432: 7502:void mkentry( state, numchars, statenum, deflink, totaltrans )
        -: 7503:register int *state;
        -: 7504:int numchars, statenum, deflink, totaltrans;
        -: 7505:	{
        -: 7506:	register int minec, maxec, i, baseaddr;
        -: 7507:	int tblbase, tbllast;
        -: 7508:
    11432: 7509:	if ( totaltrans == 0 )
branch  0 taken 2597 (fallthrough)
branch  1 taken 8835
        -: 7510:		{ /* there are no out-transitions */
     2597: 7511:		if ( deflink == JAMSTATE )
branch  0 taken 1942 (fallthrough)
branch  1 taken 655
     1942: 7512:			base[statenum] = JAMSTATE;
        -: 7513:		else
      655: 7514:			base[statenum] = 0;
        -: 7515:
     2597: 7516:		def[statenum] = deflink;
     2597: 7517:		return;
        -: 7518:		}
        -: 7519:
   296134: 7520:	for ( minec = 1; minec <= numchars; ++minec )
branch  0 taken 296134
branch  1 taken 0 (fallthrough)
        -: 7521:		{
   296134: 7522:		if ( state[minec] != SAME_TRANS )
branch  0 taken 231154 (fallthrough)
branch  1 taken 64980
   231154: 7523:			if ( state[minec] != 0 || deflink != JAMSTATE )
branch  0 taken 222319 (fallthrough)
branch  1 taken 8835
branch  2 taken 222319 (fallthrough)
branch  3 taken 0
        -: 7524:				break;
        -: 7525:		}
        -: 7526:
     8835: 7527:	if ( totaltrans == 1 )
branch  0 taken 5252 (fallthrough)
branch  1 taken 3583
        -: 7528:		{
        -: 7529:		/* There's only one out-transition.  Save it for later to fill
        -: 7530:		 * in holes in the tables.
        -: 7531:		 */
     5252: 7532:		stack1( statenum, minec, state[minec], deflink );
call    0 returned 5252
     5252: 7533:		return;
        -: 7534:		}
        -: 7535:
   258478: 7536:	for ( maxec = numchars; maxec > 0; --maxec )
branch  0 taken 258478
branch  1 taken 0 (fallthrough)
        -: 7537:		{
   258478: 7538:		if ( state[maxec] != SAME_TRANS )
branch  0 taken 207090 (fallthrough)
branch  1 taken 51388
   207090: 7539:			if ( state[maxec] != 0 || deflink != JAMSTATE )
branch  0 taken 203507 (fallthrough)
branch  1 taken 3583
branch  2 taken 203507 (fallthrough)
branch  3 taken 0
        -: 7540:				break;
        -: 7541:		}
        -: 7542:
        -: 7543:	/* Whether we try to fit the state table in the middle of the table
        -: 7544:	 * entries we have already generated, or if we just take the state
        -: 7545:	 * table at the end of the nxt/chk tables, we must make sure that we
        -: 7546:	 * have a valid base address (i.e., non-negative).  Note that
        -: 7547:	 * negative base addresses dangerous at run-time (because indexing
        -: 7548:	 * the nxt array with one and a low-valued character will access
        -: 7549:	 * memory before the start of the array.
        -: 7550:	 */
        -: 7551:
        -: 7552:	/* Find the first transition of state that we need to worry about. */
     3583: 7553:	if ( totaltrans * 100 <= numchars * INTERIOR_FIT_PERCENTAGE )
branch  0 taken 2777 (fallthrough)
branch  1 taken 806
        -: 7554:		{
        -: 7555:		/* Attempt to squeeze it into the middle of the tables. */
     2777: 7556:		baseaddr = firstfree;
        -: 7557:
    64072: 7558:		while ( baseaddr < minec )
branch  0 taken 61295
branch  1 taken 2777 (fallthrough)
        -: 7559:			{
        -: 7560:			/* Using baseaddr would result in a negative base
        -: 7561:			 * address below; find the next free slot.
        -: 7562:			 */
    93597: 7563:			for ( ++baseaddr; chk[baseaddr] != 0; ++baseaddr )
branch  0 taken 32302
branch  1 taken 61295 (fallthrough)
        -: 7564:				;
        -: 7565:			}
        -: 7566:
     2777: 7567:		while ( baseaddr + maxec - minec + 1 >= current_max_xpairs )
branch  0 taken 0
branch  1 taken 2777 (fallthrough)
    #####: 7568:			expand_nxt_chk();
call    0 never executed
        -: 7569:
 26584268: 7570:		for ( i = minec; i <= maxec; ++i )
branch  0 taken 26581491
branch  1 taken 2777
 26581491: 7571:			if ( state[i] != SAME_TRANS &&
branch  0 taken 4043362 (fallthrough)
branch  1 taken 22538129
  4043362: 7572:			     (state[i] != 0 || deflink != JAMSTATE) &&
branch  0 taken 263034 (fallthrough)
branch  1 taken 3780328
branch  2 taken 0 (fallthrough)
branch  3 taken 263034
  3780328: 7573:			     chk[baseaddr + i - minec] != 0 )
branch  0 taken 1502489 (fallthrough)
branch  1 taken 2277839
        -: 7574:				{ /* baseaddr unsuitable - find another */
  1502489: 7575:				for ( ++baseaddr;
  5211672: 7576:				      baseaddr < current_max_xpairs &&
branch  0 taken 5211672 (fallthrough)
branch  1 taken 0
  5211672: 7577:				      chk[baseaddr] != 0; ++baseaddr )
branch  0 taken 3709183
branch  1 taken 1502489 (fallthrough)
        -: 7578:					;
        -: 7579:
  1502492: 7580:				while ( baseaddr + maxec - minec + 1 >=
branch  0 taken 3
branch  1 taken 1502489 (fallthrough)
        -: 7581:					current_max_xpairs )
        3: 7582:					expand_nxt_chk();
call    0 returned 3
        -: 7583:
        -: 7584:				/* Reset the loop counter so we'll start all
        -: 7585:				 * over again next time it's incremented.
        -: 7586:				 */
        -: 7587:
  1502489: 7588:				i = minec - 1;
        -: 7589:				}
        -: 7590:		}
        -: 7591:
        -: 7592:	else
        -: 7593:		{
        -: 7594:		/* Ensure that the base address we eventually generate is
        -: 7595:		 * non-negative.
        -: 7596:		 */
      806: 7597:		baseaddr = MAX( tblend + 1, minec );
branch  0 taken 489 (fallthrough)
branch  1 taken 317
        -: 7598:		}
        -: 7599:
     3583: 7600:	tblbase = baseaddr - minec;
     3583: 7601:	tbllast = tblbase + maxec;
        -: 7602:
     3584: 7603:	while ( tbllast + 1 >= current_max_xpairs )
branch  0 taken 1
branch  1 taken 3583 (fallthrough)
        1: 7604:		expand_nxt_chk();
call    0 returned 1
        -: 7605:
     3583: 7606:	base[statenum] = tblbase;
     3583: 7607:	def[statenum] = deflink;
        -: 7608:
   186417: 7609:	for ( i = minec; i <= maxec; ++i )
branch  0 taken 182834
branch  1 taken 3583 (fallthrough)
   182834: 7610:		if ( state[i] != SAME_TRANS )
branch  0 taken 129223 (fallthrough)
branch  1 taken 53611
   129223: 7611:			if ( state[i] != 0 || deflink != JAMSTATE )
branch  0 taken 45481 (fallthrough)
branch  1 taken 83742
branch  2 taken 0 (fallthrough)
branch  3 taken 45481
        -: 7612:				{
    83742: 7613:				nxt[tblbase + i] = state[i];
    83742: 7614:				chk[tblbase + i] = statenum;
        -: 7615:				}
        -: 7616:
     3583: 7617:	if ( baseaddr == firstfree )
branch  0 taken 427 (fallthrough)
branch  1 taken 3156
        -: 7618:		/* Find next free slot in tables. */
     4043: 7619:		for ( ++firstfree; chk[firstfree] != 0; ++firstfree )
branch  0 taken 3616
branch  1 taken 427 (fallthrough)
        -: 7620:			;
        -: 7621:
     3583: 7622:	tblend = MAX( tblend, tbllast );
        -: 7623:	}
        -: 7624:
        -: 7625:
        -: 7626:/* mk1tbl - create table entries for a state (or state fragment) which
        -: 7627: *            has only one out-transition
        -: 7628: */
        -: 7629:
function mk1tbl called 5680 returned 100% blocks executed 80%
     5680: 7630:void mk1tbl( state, sym, onenxt, onedef )
        -: 7631:int state, sym, onenxt, onedef;
        -: 7632:	{
     5680: 7633:	if ( firstfree < sym )
branch  0 taken 273 (fallthrough)
branch  1 taken 5407
      273: 7634:		firstfree = sym;
        -: 7635:
    19650: 7636:	while ( chk[firstfree] != 0 )
branch  0 taken 13970
branch  1 taken 5680 (fallthrough)
    13970: 7637:		if ( ++firstfree >= current_max_xpairs )
branch  0 taken 0 (fallthrough)
branch  1 taken 13970
    #####: 7638:			expand_nxt_chk();
call    0 never executed
        -: 7639:
     5680: 7640:	base[state] = firstfree - sym;
     5680: 7641:	def[state] = onedef;
     5680: 7642:	chk[firstfree] = state;
     5680: 7643:	nxt[firstfree] = onenxt;
        -: 7644:
     5680: 7645:	if ( firstfree > tblend )
branch  0 taken 4101 (fallthrough)
branch  1 taken 1579
        -: 7646:		{
     4101: 7647:		tblend = firstfree++;
        -: 7648:
     4101: 7649:		if ( firstfree >= current_max_xpairs )
branch  0 taken 0 (fallthrough)
branch  1 taken 4101
    #####: 7650:			expand_nxt_chk();
call    0 never executed
        -: 7651:		}
     5680: 7652:	}
        -: 7653:
        -: 7654:
        -: 7655:/* mkprot - create new proto entry */
        -: 7656:
function mkprot called 983 returned 100% blocks executed 90%
      983: 7657:void mkprot( state, statenum, comstate )
        -: 7658:int state[], statenum, comstate;
        -: 7659:	{
        -: 7660:	int i, slot, tblbase;
        -: 7661:
      983: 7662:	if ( ++numprots >= MSP || numecs * numprots >= PROT_SAVE_SIZE )
branch  0 taken 983 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 983
        -: 7663:		{
        -: 7664:		/* Gotta make room for the new proto by dropping last entry in
        -: 7665:		 * the queue.
        -: 7666:		 */
    #####: 7667:		slot = lastprot;
    #####: 7668:		lastprot = protprev[lastprot];
    #####: 7669:		protnext[lastprot] = NIL;
        -: 7670:		}
        -: 7671:
        -: 7672:	else
      983: 7673:		slot = numprots;
        -: 7674:
      983: 7675:	protnext[slot] = firstprot;
        -: 7676:
      983: 7677:	if ( firstprot != NIL )
branch  0 taken 555 (fallthrough)
branch  1 taken 428
      555: 7678:		protprev[firstprot] = slot;
        -: 7679:
      983: 7680:	firstprot = slot;
      983: 7681:	prottbl[slot] = statenum;
      983: 7682:	protcomst[slot] = comstate;
        -: 7683:
        -: 7684:	/* Copy state into save area so it can be compared with rapidly. */
      983: 7685:	tblbase = numecs * (slot - 1);
        -: 7686:
    64778: 7687:	for ( i = 1; i <= numecs; ++i )
branch  0 taken 63795
branch  1 taken 983 (fallthrough)
    63795: 7688:		protsave[tblbase + i] = state[i];
      983: 7689:	}
        -: 7690:
        -: 7691:
        -: 7692:/* mktemplate - create a template entry based on a state, and connect the state
        -: 7693: *              to it
        -: 7694: */
        -: 7695:
function mktemplate called 628 returned 100% blocks executed 87%
      628: 7696:void mktemplate( state, statenum, comstate )
        -: 7697:int state[], statenum, comstate;
        -: 7698:	{
        -: 7699:	int i, numdiff, tmpbase, tmp[CSIZE + 1];
        -: 7700:	Char transset[CSIZE + 1];
        -: 7701:	int tsptr;
        -: 7702:
      628: 7703:	++numtemps;
        -: 7704:
      628: 7705:	tsptr = 0;
        -: 7706:
        -: 7707:	/* Calculate where we will temporarily store the transition table
        -: 7708:	 * of the template in the tnxt[] array.  The final transition table
        -: 7709:	 * gets created by cmptmps().
        -: 7710:	 */
        -: 7711:
      628: 7712:	tmpbase = numtemps * numecs;
        -: 7713:
      628: 7714:	if ( tmpbase + numecs >= current_max_template_xpairs )
branch  0 taken 0 (fallthrough)
branch  1 taken 628
        -: 7715:		{
    #####: 7716:		current_max_template_xpairs += MAX_TEMPLATE_XPAIRS_INCREMENT;
        -: 7717:
    #####: 7718:		++num_reallocs;
        -: 7719:
    #####: 7720:		tnxt = reallocate_integer_array( tnxt,
call    0 never executed
        -: 7721:			current_max_template_xpairs );
        -: 7722:		}
        -: 7723:
    58895: 7724:	for ( i = 1; i <= numecs; ++i )
branch  0 taken 58267
branch  1 taken 628 (fallthrough)
    58267: 7725:		if ( state[i] == 0 )
branch  0 taken 2366 (fallthrough)
branch  1 taken 55901
     2366: 7726:			tnxt[tmpbase + i] = 0;
        -: 7727:		else
        -: 7728:			{
    55901: 7729:			transset[tsptr++] = i;
    55901: 7730:			tnxt[tmpbase + i] = comstate;
        -: 7731:			}
        -: 7732:
      628: 7733:	if ( usemecs )
branch  0 taken 322 (fallthrough)
branch  1 taken 306
      322: 7734:		mkeccl( transset, tsptr, tecfwd, tecbck, numecs, 0 );
call    0 returned 322
        -: 7735:
      628: 7736:	mkprot( tnxt + tmpbase, -numtemps, comstate );
call    0 returned 628
        -: 7737:
        -: 7738:	/* We rely on the fact that mkprot adds things to the beginning
        -: 7739:	 * of the proto queue.
        -: 7740:	 */
        -: 7741:
      628: 7742:	numdiff = tbldiff( state, firstprot, tmp );
call    0 returned 628
      628: 7743:	mkentry( tmp, numecs, statenum, -numtemps, numdiff );
call    0 returned 628
      628: 7744:	}
        -: 7745:
        -: 7746:
        -: 7747:/* mv2front - move proto queue element to front of queue */
        -: 7748:
function mv2front called 3138 returned 100% blocks executed 100%
     3138: 7749:void mv2front( qelm )
        -: 7750:int qelm;
        -: 7751:	{
     3138: 7752:	if ( firstprot != qelm )
branch  0 taken 393 (fallthrough)
branch  1 taken 2745
        -: 7753:		{
      393: 7754:		if ( qelm == lastprot )
branch  0 taken 58 (fallthrough)
branch  1 taken 335
       58: 7755:			lastprot = protprev[lastprot];
        -: 7756:
      393: 7757:		protnext[protprev[qelm]] = protnext[qelm];
        -: 7758:
      393: 7759:		if ( protnext[qelm] != NIL )
branch  0 taken 335 (fallthrough)
branch  1 taken 58
      335: 7760:			protprev[protnext[qelm]] = protprev[qelm];
        -: 7761:
      393: 7762:		protprev[qelm] = NIL;
      393: 7763:		protnext[qelm] = firstprot;
      393: 7764:		protprev[firstprot] = qelm;
      393: 7765:		firstprot = qelm;
        -: 7766:		}
     3138: 7767:	}
        -: 7768:
        -: 7769:
        -: 7770:/* place_state - place a state into full speed transition table
        -: 7771: *
        -: 7772: * State is the statenum'th state.  It is indexed by equivalence class and
        -: 7773: * gives the number of the state to enter for a given equivalence class.
        -: 7774: * Transnum is the number of out-transitions for the state.
        -: 7775: */
        -: 7776:
function place_state called 2262 returned 100% blocks executed 100%
     2262: 7777:void place_state( state, statenum, transnum )
        -: 7778:int *state, statenum, transnum;
        -: 7779:	{
        -: 7780:	register int i;
        -: 7781:	register int *state_ptr;
     2262: 7782:	int position = find_table_space( state, transnum );
call    0 returned 2262
        -: 7783:
        -: 7784:	/* "base" is the table of start positions. */
     2262: 7785:	base[statenum] = position;
        -: 7786:
        -: 7787:	/* Put in action number marker; this non-zero number makes sure that
        -: 7788:	 * find_table_space() knows that this position in chk/nxt is taken
        -: 7789:	 * and should not be used for another accepting number in another
        -: 7790:	 * state.
        -: 7791:	 */
     2262: 7792:	chk[position - 1] = 1;
        -: 7793:
        -: 7794:	/* Put in end-of-buffer marker; this is for the same purposes as
        -: 7795:	 * above.
        -: 7796:	 */
     2262: 7797:	chk[position] = 1;
        -: 7798:
        -: 7799:	/* Place the state into chk and nxt. */
     2262: 7800:	state_ptr = &state[1];
        -: 7801:
   181878: 7802:	for ( i = 1; i <= numecs; ++i, ++state_ptr )
branch  0 taken 179616
branch  1 taken 2262 (fallthrough)
   179616: 7803:		if ( *state_ptr != 0 )
branch  0 taken 32723 (fallthrough)
branch  1 taken 146893
        -: 7804:			{
    32723: 7805:			chk[position + i] = i;
    32723: 7806:			nxt[position + i] = *state_ptr;
        -: 7807:			}
        -: 7808:
     2262: 7809:	if ( position + numecs > tblend )
branch  0 taken 2226 (fallthrough)
branch  1 taken 36
     2226: 7810:		tblend = position + numecs;
     2262: 7811:	}
        -: 7812:
        -: 7813:
        -: 7814:/* stack1 - save states with only one out-transition to be processed later
        -: 7815: *
        -: 7816: * If there's room for another state on the "one-transition" stack, the
        -: 7817: * state is pushed onto it, to be processed later by mk1tbl.  If there's
        -: 7818: * no room, we process the sucker right now.
        -: 7819: */
        -: 7820:
function stack1 called 5680 returned 100% blocks executed 75%
     5680: 7821:void stack1( statenum, sym, nextstate, deflink )
        -: 7822:int statenum, sym, nextstate, deflink;
        -: 7823:	{
     5680: 7824:	if ( onesp >= ONE_STACK_SIZE - 1 )
branch  0 taken 0 (fallthrough)
branch  1 taken 5680
    #####: 7825:		mk1tbl( statenum, sym, nextstate, deflink );
call    0 never executed
        -: 7826:
        -: 7827:	else
        -: 7828:		{
     5680: 7829:		++onesp;
     5680: 7830:		onestate[onesp] = statenum;
     5680: 7831:		onesym[onesp] = sym;
     5680: 7832:		onenext[onesp] = nextstate;
     5680: 7833:		onedef[onesp] = deflink;
        -: 7834:		}
     5680: 7835:	}
        -: 7836:
        -: 7837:
        -: 7838:/* tbldiff - compute differences between two state tables
        -: 7839: *
        -: 7840: * "state" is the state array which is to be extracted from the pr'th
        -: 7841: * proto.  "pr" is both the number of the proto we are extracting from
        -: 7842: * and an index into the save area where we can find the proto's complete
        -: 7843: * state table.  Each entry in "state" which differs from the corresponding
        -: 7844: * entry of "pr" will appear in "ext".
        -: 7845: *
        -: 7846: * Entries which are the same in both "state" and "pr" will be marked
        -: 7847: * as transitions to "SAME_TRANS" in "ext".  The total number of differences
        -: 7848: * between "state" and "pr" is returned as function value.  Note that this
        -: 7849: * number is "numecs" minus the number of "SAME_TRANS" entries in "ext".
        -: 7850: */
        -: 7851:
function tbldiff called 16264 returned 100% blocks executed 100%
    16264: 7852:int tbldiff( state, pr, ext )
        -: 7853:int state[], pr, ext[];
        -: 7854:	{
    16264: 7855:	register int i, *sp = state, *ep = ext, *protp;
    16264: 7856:	register int numdiff = 0;
        -: 7857:
    16264: 7858:	protp = &protsave[numecs * (pr - 1)];
        -: 7859:
   909941: 7860:	for ( i = numecs; i > 0; --i )
branch  0 taken 893677
branch  1 taken 16264 (fallthrough)
        -: 7861:		{
   893677: 7862:		if ( *++protp == *++sp )
branch  0 taken 460171 (fallthrough)
branch  1 taken 433506
   460171: 7863:			*++ep = SAME_TRANS;
        -: 7864:		else
        -: 7865:			{
   433506: 7866:			*++ep = *sp;
   433506: 7867:			++numdiff;
        -: 7868:			}
        -: 7869:		}
        -: 7870:
    16264: 7871:	return numdiff;
        -: 7872:	}
        -: 7873:/* yylex - scanner front-end for flex */
        -: 7874:
        -: 7875:/*-
        -: 7876: * Copyright (c) 1990 The Regents of the University of California.
        -: 7877: * All rights reserved.
        -: 7878: *
        -: 7879: * This code is derived from software contributed to Berkeley by
        -: 7880: * Vern Paxson.
        -: 7881: * 
        -: 7882: * The United States Government has rights in this work pursuant
        -: 7883: * to contract no. DE-AC03-76SF00098 between the United States
        -: 7884: * Department of Energy and the University of California.
        -: 7885: *
        -: 7886: * Redistribution and use in source and binary forms are permitted provided
        -: 7887: * that: (1) source distributions retain this entire copyright notice and
        -: 7888: * comment, and (2) distributions including binaries display the following
        -: 7889: * acknowledgement:  ``This product includes software developed by the
        -: 7890: * University of California, Berkeley and its contributors'' in the
        -: 7891: * documentation or other materials provided with the distribution and in
        -: 7892: * all advertising materials mentioning features or use of this software.
        -: 7893: * Neither the name of the University nor the names of its contributors may
        -: 7894: * be used to endorse or promote products derived from this software without
        -: 7895: * specific prior written permission.
        -: 7896: * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
        -: 7897: * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
        -: 7898: * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
        -: 7899: */
        -: 7900:
        -: 7901:/* $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.seeded/v1/flex.c,v 1.1.1.2 2003/09/02 20:21:59 expsir Exp $ */
        -: 7902:
        -: 7903:
        -: 7904:
        -: 7905:/* yylex - scan for a regular expression token */
        -: 7906:
function yylex called 31208 returned 100% blocks executed 91%
    31208: 7907:int yylex()
        -: 7908:	{
        -: 7909:	int toktype;
        -: 7910:	static int beglin = false;
        -: 7911:
    31208: 7912:	if ( eofseen )
branch  0 taken 0 (fallthrough)
branch  1 taken 31208
    #####: 7913:		toktype = EOF;
        -: 7914:	else
    31208: 7915:		toktype = flexscan();
call    0 returned 31208
        -: 7916:
    31208: 7917:	if ( toktype == EOF || toktype == 0 )
branch  0 taken 31208 (fallthrough)
branch  1 taken 0
branch  2 taken 551 (fallthrough)
branch  3 taken 30657
        -: 7918:		{
      551: 7919:		eofseen = 1;
        -: 7920:
      551: 7921:		if ( sectnum == 1 )
branch  0 taken 0 (fallthrough)
branch  1 taken 551
        -: 7922:			{
    #####: 7923:			synerr( "premature EOF" );
call    0 never executed
    #####: 7924:			sectnum = 2;
    #####: 7925:			toktype = SECTEND;
        -: 7926:			}
        -: 7927:
        -: 7928:		else
      551: 7929:			toktype = 0;
        -: 7930:		}
        -: 7931:
    31208: 7932:	if ( trace )
branch  0 taken 4774 (fallthrough)
branch  1 taken 26434
        -: 7933:		{
     4774: 7934:		if ( beglin )
branch  0 taken 753 (fallthrough)
branch  1 taken 4021
        -: 7935:			{
      753: 7936:			fprintf( err, "%d\t", num_rules + 1 );
call    0 returned 753
      753: 7937:			beglin = 0;
        -: 7938:			}
        -: 7939:
     4774: 7940:		switch ( toktype )
branch  0 taken 866
branch  1 taken 746
branch  2 taken 1
branch  3 taken 10
branch  4 taken 11
branch  5 taken 18
branch  6 taken 18
branch  7 taken 3056
branch  8 taken 10
branch  9 taken 18
branch 10 taken 3
branch 11 taken 17
branch 12 taken 0
        -: 7941:			{
      866: 7942:			case '<':
        -: 7943:			case '>':
        -: 7944:			case '^':
        -: 7945:			case '$':
        -: 7946:			case '"':
        -: 7947:			case '[':
        -: 7948:			case ']':
        -: 7949:			case '{':
        -: 7950:			case '}':
        -: 7951:			case '|':
        -: 7952:			case '(':
        -: 7953:			case ')':
        -: 7954:			case '-':
        -: 7955:			case '/':
        -: 7956:			case '\\':
        -: 7957:			case '?':
        -: 7958:			case '.':
        -: 7959:			case '*':
        -: 7960:			case '+':
        -: 7961:			case ',':
      866: 7962:				(void) putc( toktype, err );
call    0 returned 866
      866: 7963:				break;
        -: 7964:
      746: 7965:			case '\n':
      746: 7966:				(void) putc( '\n', err );
call    0 returned 746
        -: 7967:
      746: 7968:				if ( sectnum == 2 )
branch  0 taken 735 (fallthrough)
branch  1 taken 11
      735: 7969:				beglin = 1;
        -: 7970:
      746: 7971:				break;
        -: 7972:
        1: 7973:			case SCDECL:
        1: 7974:				fputs( "%s", err );
call    0 returned 1
        1: 7975:				break;
        -: 7976:
       10: 7977:			case XSCDECL:
       10: 7978:				fputs( "%x", err );
call    0 returned 10
       10: 7979:				break;
        -: 7980:
       11: 7981:			case WHITESPACE:
       11: 7982:				(void) putc( ' ', err );
call    0 returned 11
       11: 7983:				break;
        -: 7984:
       18: 7985:			case SECTEND:
       18: 7986:				fputs( "%%\n", err );
call    0 returned 18
        -: 7987:
        -: 7988:				/* We set beglin to be true so we'll start
        -: 7989:				 * writing out numbers as we echo rules.
        -: 7990:				 * flexscan() has already assigned sectnum.
        -: 7991:				 */
        -: 7992:
       18: 7993:				if ( sectnum == 2 )
branch  0 taken 18 (fallthrough)
branch  1 taken 0
       18: 7994:				beglin = 1;
        -: 7995:
       18: 7996:				break;
        -: 7997:
       18: 7998:			case NAME:
       18: 7999:				fprintf( err, "'%s'", nmstr );
call    0 returned 18
       18: 8000:				break;
        -: 8001:
     3056: 8002:			case CHAR:
     3056: 8003:				switch ( yylval )
branch  0 taken 60
branch  1 taken 2996
        -: 8004:					{
       60: 8005:					case '<':
        -: 8006:					case '>':
        -: 8007:					case '^':
        -: 8008:					case '$':
        -: 8009:					case '"':
        -: 8010:					case '[':
        -: 8011:					case ']':
        -: 8012:					case '{':
        -: 8013:					case '}':
        -: 8014:					case '|':
        -: 8015:					case '(':
        -: 8016:					case ')':
        -: 8017:					case '-':
        -: 8018:					case '/':
        -: 8019:					case '\\':
        -: 8020:					case '?':
        -: 8021:					case '.':
        -: 8022:					case '*':
        -: 8023:					case '+':
        -: 8024:					case ',':
       60: 8025:						fprintf( err, "\\%c",
call    0 returned 60
        -: 8026:							yylval );
       60: 8027:						break;
        -: 8028:
     2996: 8029:					default:
     2996: 8030:						if ( ! isascii( yylval ) ||
branch  0 taken 2990 (fallthrough)
branch  1 taken 6
     2990: 8031:						     ! isprint( yylval ) )
branch  0 taken 33 (fallthrough)
branch  1 taken 2957
       39: 8032:							fprintf( err,
call    0 returned 39
        -: 8033:								"\\%.3o",
        -: 8034:							(unsigned int) yylval );
        -: 8035:						else
     2957: 8036:							(void) putc( yylval,
call    0 returned 2957
        -: 8037:								err );
     2996: 8038:					break;
        -: 8039:					}
        -: 8040:
     3056: 8041:				break;
        -: 8042:
       10: 8043:			case NUMBER:
       10: 8044:				fprintf( err, "%d", yylval );
call    0 returned 10
       10: 8045:				break;
        -: 8046:
       18: 8047:			case PREVCCL:
       18: 8048:				fprintf( err, "[%d]", yylval );
call    0 returned 18
       18: 8049:				break;
        -: 8050:
        3: 8051:			case EOF_OP:
        3: 8052:				fprintf( err, "<<EOF>>" );
call    0 returned 3
        3: 8053:				break;
        -: 8054:
       17: 8055:			case 0:
       17: 8056:				fprintf( err, "End Marker" );
call    0 returned 17
       17: 8057:				break;
        -: 8058:
    #####: 8059:			default:
    #####: 8060:				fprintf( err,
call    0 never executed
        -: 8061:					"*Something Weird* - tok: %d val: %d\n",
        -: 8062:					toktype, yylval );
    #####: 8063:				break;
        -: 8064:			}
        -: 8065:		}
        -: 8066:
    31208: 8067:	return toktype;
        -: 8068:	}
        -: 8069:
        -: 8070:/*  A Bison parser, made from ./parse.y
        -: 8071:    by GNU Bison version 1.28  */
        -: 8072:
        -: 8073:#define YYBISON 1  /* Identify Bison output.  */
        -: 8074:
        -: 8075:#define	CHAR	257
        -: 8076:#define	NUMBER	258
        -: 8077:#define	SECTEND	259
        -: 8078:#define	SCDECL	260
        -: 8079:#define	XSCDECL	261
        -: 8080:#define	WHITESPACE	262
        -: 8081:#define	NAME	263
        -: 8082:#define	PREVCCL	264
        -: 8083:#define	EOF_OP	265
        -: 8084:
        -: 8085:
        -: 8086:/*-
        -: 8087: * Copyright (c) 1990 The Regents of the University of California.
        -: 8088: * All rights reserved.
        -: 8089: *
        -: 8090: * This code is derived from software contributed to Berkeley by
        -: 8091: * Vern Paxson.
        -: 8092: * 
        -: 8093: * The United States Government has rights in this work pursuant
        -: 8094: * to contract no. DE-AC03-76SF00098 between the United States
        -: 8095: * Department of Energy and the University of California.
        -: 8096: *
        -: 8097: * Redistribution and use in source and binary forms are permitted provided
        -: 8098: * that: (1) source distributions retain this entire copyright notice and
        -: 8099: * comment, and (2) distributions including binaries display the following
        -: 8100: * acknowledgement:  ``This product includes software developed by the
        -: 8101: * University of California, Berkeley and its contributors'' in the
        -: 8102: * documentation or other materials provided with the distribution and in
        -: 8103: * all advertising materials mentioning features or use of this software.
        -: 8104: * Neither the name of the University nor the names of its contributors may
        -: 8105: * be used to endorse or promote products derived from this software without
        -: 8106: * specific prior written permission.
        -: 8107: * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
        -: 8108: * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
        -: 8109: * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
        -: 8110: */
        -: 8111:
        -: 8112:/* $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.seeded/v1/flex.c,v 1.1.1.2 2003/09/02 20:21:59 expsir Exp $ */
        -: 8113:
        -: 8114:#define alloca malloc
        -: 8115:
        -: 8116:int pat, scnum, eps, headcnt, trailcnt, anyccl, lastchar, i, actvp, rulelen;
        -: 8117:int trlcontxt, xcluflg, cclsorted, varlength, variable_trail_rule;
        -: 8118:int *active_ss;
        -: 8119:Char clower();
        -: 8120:void build_eof_action();
        -: 8121:void yyerror();
        -: 8122:
        -: 8123:static int madeany = false;  /* whether we've made the '.' character class */
        -: 8124:int previous_continued_action;	/* whether the previous rule's action was '|' */
        -: 8125:
        -: 8126:/* On some over-ambitious machines, such as DEC Alpha's, the default
        -: 8127: * token type is "long" instead of "int"; this leads to problems with
        -: 8128: * declaring yylval in flexdef.h.  But so far, all the yacc's I've seen
        -: 8129: * wrap their definitions of YYSTYPE with "#ifndef YYSTYPE"'s, so the
        -: 8130: * following should ensure that the default token type is "int".
        -: 8131: */
        -: 8132:#define YYSTYPE int
        -: 8133:
        -: 8134:#ifndef YYSTYPE
        -: 8135:#define YYSTYPE int
        -: 8136:#endif
        -: 8137:#include <stdio.h>
        -: 8138:
        -: 8139:#ifndef __cplusplus
        -: 8140:#ifndef __STDC__
        -: 8141:#define const
        -: 8142:#endif
        -: 8143:#endif
        -: 8144:
        -: 8145:
        -: 8146:
        -: 8147:#define	YYFINAL		85
        -: 8148:#define	YYFLAG		-32768
        -: 8149:#define	YYNTBASE	32
        -: 8150:
        -: 8151:#define YYTRANSLATE(x) ((unsigned)(x) <= 265 ? yytranslate[x] : 53)
        -: 8152:
        -: 8153:static const char yytranslate[] = {     0,
        -: 8154:     2,     2,     2,     2,     2,     2,     2,     2,     2,    12,
        -: 8155:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 8156:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 8157:     2,     2,     2,    26,     2,    18,     2,     2,     2,    27,
        -: 8158:    28,    16,    21,    17,    31,    25,    20,     2,     2,     2,
        -: 8159:     2,     2,     2,     2,     2,     2,     2,     2,     2,    14,
        -: 8160:     2,    15,    22,     2,     2,     2,     2,     2,     2,     2,
        -: 8161:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 8162:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 8163:    29,     2,    30,    13,     2,     2,     2,     2,     2,     2,
        -: 8164:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 8165:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 8166:     2,     2,    23,    19,    24,     2,     2,     2,     2,     2,
        -: 8167:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 8168:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 8169:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 8170:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 8171:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 8172:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 8173:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 8174:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 8175:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 8176:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 8177:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 8178:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 8179:     2,     2,     2,     2,     2,     1,     3,     4,     5,     6,
        -: 8180:     7,     8,     9,    10,    11
        -: 8181:};
        -: 8182:
        -: 8183:#if YYDEBUG != 0
        -: 8184:static const short yyprhs[] = {     0,
        -: 8185:     0,     6,     7,    13,    14,    17,    19,    21,    23,    27,
        -: 8186:    29,    31,    36,    37,    38,    42,    45,    48,    50,    53,
        -: 8187:    55,    57,    61,    65,    69,    70,    73,    75,    77,    80,
        -: 8188:    84,    87,    89,    93,    95,    98,   101,   103,   106,   109,
        -: 8189:   112,   119,   125,   130,   132,   134,   136,   140,   144,   146,
        -: 8190:   150,   155,   160,   163,   164,   167
        -: 8191:};
        -: 8192:
        -: 8193:static const short yyrhs[] = {    33,
        -: 8194:    34,    35,    38,    39,     0,     0,    34,    36,     8,    37,
        -: 8195:    12,     0,     0,     1,    12,     0,     5,     0,     6,     0,
        -: 8196:     7,     0,    37,     8,     9,     0,     9,     0,     1,     0,
        -: 8197:    38,    39,    40,    12,     0,     0,     0,    41,    13,    45,
        -: 8198:     0,    41,    45,     0,    13,    45,     0,    45,     0,    41,
        -: 8199:    11,     0,    11,     0,     1,     0,    14,    42,    15,     0,
        -: 8200:    14,    16,    15,     0,    42,    17,    44,     0,     0,    43,
        -: 8201:    44,     0,     1,     0,     9,     0,    47,    46,     0,    47,
        -: 8202:    46,    18,     0,    46,    18,     0,    46,     0,    46,    19,
        -: 8203:    48,     0,    48,     0,    46,    20,     0,    48,    49,     0,
        -: 8204:    49,     0,    49,    16,     0,    49,    21,     0,    49,    22,
        -: 8205:     0,    49,    23,     4,    17,     4,    24,     0,    49,    23,
        -: 8206:     4,    17,    24,     0,    49,    23,     4,    24,     0,    25,
        -: 8207:     0,    50,     0,    10,     0,    26,    52,    26,     0,    27,
        -: 8208:    46,    28,     0,     3,     0,    29,    51,    30,     0,    29,
        -: 8209:    13,    51,    30,     0,    51,     3,    31,     3,     0,    51,
        -: 8210:     3,     0,     0,    52,     3,     0,     0
        -: 8211:};
        -: 8212:
        -: 8213:#endif
        -: 8214:
        -: 8215:#if YYDEBUG != 0
        -: 8216:static const short yyrline[] = { 0,
        -: 8217:    82,   111,   124,   125,   126,   130,   143,   146,   150,   153,
        -: 8218:   156,   160,   161,   164,   175,   195,   206,   230,   241,   244,
        -: 8219:   263,   267,   269,   278,   280,   282,   282,   286,   307,   362,
        -: 8220:   365,   408,   426,   432,   437,   464,   472,   476,   483,   489,
        -: 8221:   495,   523,   537,   556,   578,   596,   603,   606,   609,   620,
        -: 8222:   623,   630,   658,   669,   677,   687
        -: 8223:};
        -: 8224:#endif
        -: 8225:
        -: 8226:
        -: 8227:#if YYDEBUG != 0 || defined (YYERROR_VERBOSE)
        -: 8228:
        -: 8229:static const char * const yytname[] = {   "$","error","$undefined.","CHAR","NUMBER",
        -: 8230:"SECTEND","SCDECL","XSCDECL","WHITESPACE","NAME","PREVCCL","EOF_OP","'\\n'",
        -: 8231:"'^'","'<'","'>'","'*'","','","'$'","'|'","'/'","'+'","'?'","'{'","'}'","'.'",
        -: 8232:"'\\\"'","'('","')'","'['","']'","'-'","goal","initlex","sect1","sect1end","startconddecl",
        -: 8233:"namelist1","sect2","initforrule","flexrule","scon","namelist2","@1","sconname",
        -: 8234:"rule","re","re2","series","singleton","fullccl","ccl","string", NULL
        -: 8235:};
        -: 8236:#endif
        -: 8237:
        -: 8238:static const short yyr1[] = {     0,
        -: 8239:    32,    33,    34,    34,    34,    35,    36,    36,    37,    37,
        -: 8240:    37,    38,    38,    39,    40,    40,    40,    40,    40,    40,
        -: 8241:    40,    41,    41,    42,    43,    42,    42,    44,    45,    45,
        -: 8242:    45,    45,    46,    46,    47,    48,    48,    49,    49,    49,
        -: 8243:    49,    49,    49,    49,    49,    49,    49,    49,    49,    50,
        -: 8244:    50,    51,    51,    51,    52,    52
        -: 8245:};
        -: 8246:
        -: 8247:static const short yyr2[] = {     0,
        -: 8248:     5,     0,     5,     0,     2,     1,     1,     1,     3,     1,
        -: 8249:     1,     4,     0,     0,     3,     2,     2,     1,     2,     1,
        -: 8250:     1,     3,     3,     3,     0,     2,     1,     1,     2,     3,
        -: 8251:     2,     1,     3,     1,     2,     2,     1,     2,     2,     2,
        -: 8252:     6,     5,     4,     1,     1,     1,     3,     3,     1,     3,
        -: 8253:     4,     4,     2,     0,     2,     0
        -: 8254:};
        -: 8255:
        -: 8256:static const short yydefact[] = {     2,
        -: 8257:     0,     0,     0,     5,     6,     7,     8,    13,     0,    14,
        -: 8258:     0,     0,    11,    10,     0,    21,    49,    46,    20,     0,
        -: 8259:     0,    44,    56,     0,    54,     0,     0,    18,    32,     0,
        -: 8260:    34,    37,    45,     0,     3,    17,    27,     0,     0,     0,
        -: 8261:     0,     0,    54,     0,    12,    19,     0,    16,    31,     0,
        -: 8262:    35,    29,    36,    38,    39,    40,     0,     9,    23,    22,
        -: 8263:     0,    28,    26,    55,    47,    48,     0,    53,    50,    15,
        -: 8264:    33,    30,     0,    24,    51,     0,     0,    43,    52,     0,
        -: 8265:    42,    41,     0,     0,     0
        -: 8266:};
        -: 8267:
        -: 8268:static const short yydefgoto[] = {    83,
        -: 8269:     1,     3,     8,     9,    15,    10,    12,    26,    27,    39,
        -: 8270:    40,    63,    28,    29,    30,    31,    32,    33,    44,    41
        -: 8271:};
        -: 8272:
        -: 8273:static const short yypact[] = {-32768,
        -: 8274:    61,    -2,    64,-32768,-32768,-32768,-32768,-32768,    13,-32768,
        -: 8275:    34,     1,-32768,-32768,    30,-32768,-32768,-32768,-32768,    21,
        -: 8276:    48,-32768,-32768,    21,    31,    33,    26,-32768,    54,    21,
        -: 8277:    21,    38,-32768,    47,-32768,-32768,-32768,    43,     5,    56,
        -: 8278:    15,   -11,-32768,     2,-32768,-32768,    21,-32768,-32768,    21,
        -: 8279:-32768,    57,    38,-32768,-32768,-32768,    59,-32768,-32768,-32768,
        -: 8280:    56,-32768,-32768,-32768,-32768,-32768,     4,    46,-32768,-32768,
        -: 8281:    21,-32768,    -8,-32768,-32768,    75,    -1,-32768,-32768,    55,
        -: 8282:-32768,-32768,    80,    81,-32768
        -: 8283:};
        -: 8284:
        -: 8285:static const short yypgoto[] = {-32768,
        -: 8286:-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
        -: 8287:-32768,    22,   -14,    -5,-32768,    32,   -31,-32768,    41,-32768
        -: 8288:};
        -: 8289:
        -: 8290:
        -: 8291:#define	YYLAST		84
        -: 8292:
        -: 8293:
        -: 8294:static const short yytable[] = {    53,
        -: 8295:    -1,    16,    80,    17,    68,    36,    68,    50,    77,     4,
        -: 8296:    18,    19,    48,    20,    21,    78,    66,    64,    42,    60,
        -: 8297:    11,    61,    81,    17,    52,    22,    23,    24,    17,    25,
        -: 8298:    18,    69,    70,    75,    13,    18,    46,    34,    47,    53,
        -: 8299:    65,    35,    14,    43,    45,    22,    23,    24,    37,    25,
        -: 8300:    22,    23,    24,    54,    25,    58,   -25,    59,    55,    56,
        -: 8301:    57,     2,    73,    38,    62,    -4,    -4,    -4,     5,     6,
        -: 8302:     7,    49,    50,    51,    72,    50,    76,    79,    82,    84,
        -: 8303:    85,    71,    74,    67
        -: 8304:};
        -: 8305:
        -: 8306:static const short yycheck[] = {    31,
        -: 8307:     0,     1,     4,     3,     3,    20,     3,    19,    17,    12,
        -: 8308:    10,    11,    27,    13,    14,    24,    28,     3,    24,    15,
        -: 8309:     8,    17,    24,     3,    30,    25,    26,    27,     3,    29,
        -: 8310:    10,    30,    47,    30,     1,    10,    11,     8,    13,    71,
        -: 8311:    26,    12,     9,    13,    12,    25,    26,    27,     1,    29,
        -: 8312:    25,    26,    27,    16,    29,     9,     9,    15,    21,    22,
        -: 8313:    23,     1,     4,    16,     9,     5,     6,     7,     5,     6,
        -: 8314:     7,    18,    19,    20,    18,    19,    31,     3,    24,     0,
        -: 8315:     0,    50,    61,    43
        -: 8316:};
        -: 8317:/* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
        -: 8318:/* This file comes from bison-1.28.  */
        -: 8319:
        -: 8320:/* Skeleton output parser for bison,
        -: 8321:   Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.
        -: 8322:
        -: 8323:   This program is free software; you can redistribute it and/or modify
        -: 8324:   it under the terms of the GNU General Public License as published by
        -: 8325:   the Free Software Foundation; either version 2, or (at your option)
        -: 8326:   any later version.
        -: 8327:
        -: 8328:   This program is distributed in the hope that it will be useful,
        -: 8329:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 8330:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 8331:   GNU General Public License for more details.
        -: 8332:
        -: 8333:   You should have received a copy of the GNU General Public License
        -: 8334:   along with this program; if not, write to the Free Software
        -: 8335:   Foundation, Inc., 59 Temple Place - Suite 330,
        -: 8336:   Boston, MA 02111-1307, USA.  */
        -: 8337:
        -: 8338:/* As a special exception, when this file is copied by Bison into a
        -: 8339:   Bison output file, you may use that output file without restriction.
        -: 8340:   This special exception was added by the Free Software Foundation
        -: 8341:   in version 1.24 of Bison.  */
        -: 8342:
        -: 8343:/* This is the parser code that is written into each bison parser
        -: 8344:  when the %semantic_parser declaration is not specified in the grammar.
        -: 8345:  It was written by Richard Stallman by simplifying the hairy parser
        -: 8346:  used when %semantic_parser is specified.  */
        -: 8347:
        -: 8348:#define YYSTACK_ALLOC malloc
        -: 8349:
        -: 8350:/* Note: there must be only one dollar sign in this file.
        -: 8351:   It is replaced by the list of actions, each action
        -: 8352:   as one case of the switch.  */
        -: 8353:
        -: 8354:#define yyerrok		(yyerrstatus = 0)
        -: 8355:#define yyclearin	(yychar = YYEMPTY)
        -: 8356:#define YYEMPTY		-2
        -: 8357:#define YYEOF		0
        -: 8358:#define YYACCEPT	goto yyacceptlab
        -: 8359:#define YYABORT 	goto yyabortlab
        -: 8360:#define YYERROR		goto yyerrlab1
        -: 8361:/* Like YYERROR except do call yyerror.
        -: 8362:   This remains here temporarily to ease the
        -: 8363:   transition to the new meaning of YYERROR, for GCC.
        -: 8364:   Once GCC version 2 has supplanted version 1, this can go.  */
        -: 8365:#define YYFAIL		goto yyerrlab
        -: 8366:#define YYRECOVERING()  (!!yyerrstatus)
        -: 8367:#define YYBACKUP(token, value) \
        -: 8368:do								\
        -: 8369:  if (yychar == YYEMPTY && yylen == 1)				\
        -: 8370:    { yychar = (token), yylval = (value);			\
        -: 8371:      yychar1 = YYTRANSLATE (yychar);				\
        -: 8372:      YYPOPSTACK;						\
        -: 8373:      goto yybackup;						\
        -: 8374:    }								\
        -: 8375:  else								\
        -: 8376:    { yyerror ("syntax error: cannot back up"); YYERROR; }	\
        -: 8377:while (0)
        -: 8378:
        -: 8379:#define YYTERROR	1
        -: 8380:#define YYERRCODE	256
        -: 8381:
        -: 8382:#ifndef YYPURE
        -: 8383:#define YYLEX		yylex()
        -: 8384:#endif
        -: 8385:
        -: 8386:#ifdef YYPURE
        -: 8387:#ifdef YYLSP_NEEDED
        -: 8388:#ifdef YYLEX_PARAM
        -: 8389:#define YYLEX		yylex(&yylval, &yylloc, YYLEX_PARAM)
        -: 8390:#else
        -: 8391:#define YYLEX		yylex(&yylval, &yylloc)
        -: 8392:#endif
        -: 8393:#else /* not YYLSP_NEEDED */
        -: 8394:#ifdef YYLEX_PARAM
        -: 8395:#define YYLEX		yylex(&yylval, YYLEX_PARAM)
        -: 8396:#else
        -: 8397:#define YYLEX		yylex(&yylval)
        -: 8398:#endif
        -: 8399:#endif /* not YYLSP_NEEDED */
        -: 8400:#endif
        -: 8401:
        -: 8402:/* If nonreentrant, generate the variables here */
        -: 8403:
        -: 8404:#ifndef YYPURE
        -: 8405:
        -: 8406:int	yychar;			/*  the lookahead symbol		*/
        -: 8407:YYSTYPE	yylval;			/*  the semantic value of the		*/
        -: 8408:				/*  lookahead symbol			*/
        -: 8409:
        -: 8410:#ifdef YYLSP_NEEDED
        -: 8411:YYLTYPE yylloc;			/*  location data for the lookahead	*/
        -: 8412:				/*  symbol				*/
        -: 8413:#endif
        -: 8414:
        -: 8415:int yynerrs;			/*  number of parse errors so far       */
        -: 8416:#endif  /* not YYPURE */
        -: 8417:
        -: 8418:#if YYDEBUG != 0
        -: 8419:int yydebug;			/*  nonzero means print parse trace	*/
        -: 8420:/* Since this is uninitialized, it does not stop multiple parsers
        -: 8421:   from coexisting.  */
        -: 8422:#endif
        -: 8423:
        -: 8424:/*  YYINITDEPTH indicates the initial size of the parser's stacks	*/
        -: 8425:
        -: 8426:#ifndef	YYINITDEPTH
        -: 8427:#define YYINITDEPTH 200
        -: 8428:#endif
        -: 8429:
        -: 8430:/*  YYMAXDEPTH is the maximum size the stacks can grow to
        -: 8431:    (effective only if the built-in stack extension method is used).  */
        -: 8432:
        -: 8433:#if YYMAXDEPTH == 0
        -: 8434:#undef YYMAXDEPTH
        -: 8435:#endif
        -: 8436:
        -: 8437:#ifndef YYMAXDEPTH
        -: 8438:#define YYMAXDEPTH 10000
        -: 8439:#endif
        -: 8440:/* Define __yy_memcpy.  Note that the size argument
        -: 8441:   should be passed with type unsigned int, because that is what the non-GCC
        -: 8442:   definitions require.  With GCC, __builtin_memcpy takes an arg
        -: 8443:   of type size_t, but it can handle unsigned int.  */
        -: 8444:
        -: 8445:#if __GNUC__ > 1		/* GNU C and GNU C++ define this.  */
        -: 8446:#define __yy_memcpy(TO,FROM,COUNT)	__builtin_memcpy(TO,FROM,COUNT)
        -: 8447:#else				/* not GNU C or C++ */
        -: 8448:#ifndef __cplusplus
        -: 8449:
        -: 8450:/* This is the most reliable way to avoid incompatibilities
        -: 8451:   in available built-in functions on various systems.  */
        -: 8452:static void
        -: 8453:__yy_memcpy (to, from, count)
        -: 8454:     char *to;
        -: 8455:     char *from;
        -: 8456:     unsigned int count;
        -: 8457:{
        -: 8458:  register char *f = from;
        -: 8459:  register char *t = to;
        -: 8460:  register int i = count;
        -: 8461:
        -: 8462:  while (i-- > 0)
        -: 8463:    *t++ = *f++;
        -: 8464:}
        -: 8465:
        -: 8466:#else /* __cplusplus */
        -: 8467:
        -: 8468:/* This is the most reliable way to avoid incompatibilities
        -: 8469:   in available built-in functions on various systems.  */
        -: 8470:static void
        -: 8471:__yy_memcpy (char *to, char *from, unsigned int count)
        -: 8472:{
        -: 8473:  register char *t = to;
        -: 8474:  register char *f = from;
        -: 8475:  register int i = count;
        -: 8476:
        -: 8477:  while (i-- > 0)
        -: 8478:    *t++ = *f++;
        -: 8479:}
        -: 8480:
        -: 8481:#endif
        -: 8482:#endif
        -: 8483:
        -: 8484:/* The user can define YYPARSE_PARAM as the name of an argument to be passed
        -: 8485:   into yyparse.  The argument should have type void *.
        -: 8486:   It should actually point to an object.
        -: 8487:   Grammar actions can access the variable by casting it
        -: 8488:   to the proper pointer type.  */
        -: 8489:
        -: 8490:#ifdef YYPARSE_PARAM
        -: 8491:#ifdef __cplusplus
        -: 8492:#define YYPARSE_PARAM_ARG void *YYPARSE_PARAM
        -: 8493:#define YYPARSE_PARAM_DECL
        -: 8494:#else /* not __cplusplus */
        -: 8495:#define YYPARSE_PARAM_ARG YYPARSE_PARAM
        -: 8496:#define YYPARSE_PARAM_DECL void *YYPARSE_PARAM;
        -: 8497:#endif /* not __cplusplus */
        -: 8498:#else /* not YYPARSE_PARAM */
        -: 8499:#define YYPARSE_PARAM_ARG
        -: 8500:#define YYPARSE_PARAM_DECL
        -: 8501:#endif /* not YYPARSE_PARAM */
        -: 8502:
        -: 8503:/* Prevent warning if -Wstrict-prototypes.  */
        -: 8504:#ifdef __GNUC__
        -: 8505:#ifdef YYPARSE_PARAM
        -: 8506:int yyparse (void *);
        -: 8507:#else
        -: 8508:int yyparse (void);
        -: 8509:#endif
        -: 8510:#endif
        -: 8511:
        -: 8512:int
function yyparse called 552 returned 100% blocks executed 77%
      552: 8513:yyparse(YYPARSE_PARAM_ARG)
        -: 8514:     YYPARSE_PARAM_DECL
        -: 8515:{
        -: 8516:  register int yystate;
        -: 8517:  register int yyn;
        -: 8518:  register short *yyssp;
        -: 8519:  register YYSTYPE *yyvsp;
        -: 8520:  int yyerrstatus;	/*  number of tokens to shift before error messages enabled */
      552: 8521:  int yychar1 = 0;		/*  lookahead token as an internal (translated) token number */
        -: 8522:
        -: 8523:  short	yyssa[YYINITDEPTH];	/*  the state stack			*/
        -: 8524:  YYSTYPE yyvsa[YYINITDEPTH];	/*  the semantic value stack		*/
        -: 8525:
      552: 8526:  short *yyss = yyssa;		/*  refer to the stacks thru separate pointers */
      552: 8527:  YYSTYPE *yyvs = yyvsa;	/*  to allow yyoverflow to reallocate them elsewhere */
        -: 8528:
        -: 8529:#ifdef YYLSP_NEEDED
        -: 8530:  YYLTYPE yylsa[YYINITDEPTH];	/*  the location stack			*/
        -: 8531:  YYLTYPE *yyls = yylsa;
        -: 8532:  YYLTYPE *yylsp;
        -: 8533:
        -: 8534:#define YYPOPSTACK   (yyvsp--, yyssp--, yylsp--)
        -: 8535:#else
        -: 8536:#define YYPOPSTACK   (yyvsp--, yyssp--)
        -: 8537:#endif
        -: 8538:
      552: 8539:  int yystacksize = YYINITDEPTH;
      552: 8540:  int yyfree_stacks = 0;
        -: 8541:
        -: 8542:#ifdef YYPURE
        -: 8543:  int yychar;
        -: 8544:  YYSTYPE yylval;
        -: 8545:  int yynerrs;
        -: 8546:#ifdef YYLSP_NEEDED
        -: 8547:  YYLTYPE yylloc;
        -: 8548:#endif
        -: 8549:#endif
        -: 8550:
        -: 8551:  YYSTYPE yyval;		/*  the variable used to return		*/
        -: 8552:				/*  semantic values from the action	*/
        -: 8553:				/*  routines				*/
        -: 8554:
        -: 8555:  int yylen;
        -: 8556:
        -: 8557:#if YYDEBUG != 0
        -: 8558:  if (yydebug)
        -: 8559:    fprintf(err, "Starting parse\n");
        -: 8560:#endif
        -: 8561:
      552: 8562:  yystate = 0;
      552: 8563:  yyerrstatus = 0;
      552: 8564:  yynerrs = 0;
      552: 8565:  yychar = YYEMPTY;		/* Cause a token to be read.  */
        -: 8566:
        -: 8567:  /* Initialize stack pointers.
        -: 8568:     Waste one element of value and location stack
        -: 8569:     so that they stay on the same level as the state stack.
        -: 8570:     The wasted elements are never initialized.  */
        -: 8571:
      552: 8572:  yyssp = yyss - 1;
      552: 8573:  yyvsp = yyvs;
        -: 8574:#ifdef YYLSP_NEEDED
        -: 8575:  yylsp = yyls;
        -: 8576:#endif
        -: 8577:
        -: 8578:/* Push a new state, which is found in  yystate  .  */
        -: 8579:/* In all cases, when you get here, the value and location stacks
        -: 8580:   have just been pushed. so pushing a state here evens the stacks.  */
    89919: 8581:yynewstate:
        -: 8582:
    89919: 8583:  *++yyssp = yystate;
        -: 8584:
    89919: 8585:  if (yyssp >= yyss + yystacksize - 1)
branch  0 taken 0 (fallthrough)
branch  1 taken 89919
        -: 8586:    {
        -: 8587:      /* Give user a chance to reallocate the stack */
        -: 8588:      /* Use copies of these so that the &'s don't force the real ones into memory. */
    #####: 8589:      YYSTYPE *yyvs1 = yyvs;
    #####: 8590:      short *yyss1 = yyss;
        -: 8591:#ifdef YYLSP_NEEDED
        -: 8592:      YYLTYPE *yyls1 = yyls;
        -: 8593:#endif
        -: 8594:
        -: 8595:      /* Get the current used size of the three stacks, in elements.  */
    #####: 8596:      int size = yyssp - yyss + 1;
        -: 8597:
        -: 8598:#ifdef yyoverflow
        -: 8599:      /* Each stack pointer address is followed by the size of
        -: 8600:	 the data in use in that stack, in bytes.  */
        -: 8601:#ifdef YYLSP_NEEDED
        -: 8602:      /* This used to be a conditional around just the two extra args,
        -: 8603:	 but that might be undefined if yyoverflow is a macro.  */
        -: 8604:      yyoverflow("parser stack overflow",
        -: 8605:		 &yyss1, size * sizeof (*yyssp),
        -: 8606:		 &yyvs1, size * sizeof (*yyvsp),
        -: 8607:		 &yyls1, size * sizeof (*yylsp),
        -: 8608:		 &yystacksize);
        -: 8609:#else
        -: 8610:      yyoverflow("parser stack overflow",
        -: 8611:		 &yyss1, size * sizeof (*yyssp),
        -: 8612:		 &yyvs1, size * sizeof (*yyvsp),
        -: 8613:		 &yystacksize);
        -: 8614:#endif
        -: 8615:
        -: 8616:      yyss = yyss1; yyvs = yyvs1;
        -: 8617:#ifdef YYLSP_NEEDED
        -: 8618:      yyls = yyls1;
        -: 8619:#endif
        -: 8620:#else /* no yyoverflow */
        -: 8621:      /* Extend the stack our own way.  */
    #####: 8622:      if (yystacksize >= YYMAXDEPTH)
branch  0 never executed
branch  1 never executed
        -: 8623:	{
    #####: 8624:	  yyerror("parser stack overflow");
call    0 never executed
    #####: 8625:	  if (yyfree_stacks)
branch  0 never executed
branch  1 never executed
        -: 8626:	    {
    #####: 8627:	      free (yyss);
    #####: 8628:	      free (yyvs);
        -: 8629:#ifdef YYLSP_NEEDED
        -: 8630:	      free (yyls);
        -: 8631:#endif
        -: 8632:	    }
    #####: 8633:	  return 2;
        -: 8634:	}
    #####: 8635:      yystacksize *= 2;
    #####: 8636:      if (yystacksize > YYMAXDEPTH)
branch  0 never executed
branch  1 never executed
    #####: 8637:	yystacksize = YYMAXDEPTH;
        -: 8638:#ifndef YYSTACK_USE_ALLOCA
    #####: 8639:      yyfree_stacks = 1;
        -: 8640:#endif
    #####: 8641:      yyss = (short *) YYSTACK_ALLOC (yystacksize * sizeof (*yyssp));
    #####: 8642:      __yy_memcpy ((char *)yyss, (char *)yyss1,
        -: 8643:		   size * (unsigned int) sizeof (*yyssp));
    #####: 8644:      yyvs = (YYSTYPE *) YYSTACK_ALLOC (yystacksize * sizeof (*yyvsp));
    #####: 8645:      __yy_memcpy ((char *)yyvs, (char *)yyvs1,
        -: 8646:		   size * (unsigned int) sizeof (*yyvsp));
        -: 8647:#ifdef YYLSP_NEEDED
        -: 8648:      yyls = (YYLTYPE *) YYSTACK_ALLOC (yystacksize * sizeof (*yylsp));
        -: 8649:      __yy_memcpy ((char *)yyls, (char *)yyls1,
        -: 8650:		   size * (unsigned int) sizeof (*yylsp));
        -: 8651:#endif
        -: 8652:#endif /* no yyoverflow */
        -: 8653:
    #####: 8654:      yyssp = yyss + size - 1;
    #####: 8655:      yyvsp = yyvs + size - 1;
        -: 8656:#ifdef YYLSP_NEEDED
        -: 8657:      yylsp = yyls + size - 1;
        -: 8658:#endif
        -: 8659:
        -: 8660:#if YYDEBUG != 0
        -: 8661:      if (yydebug)
        -: 8662:	fprintf(err, "Stack size increased to %d\n", yystacksize);
        -: 8663:#endif
        -: 8664:
    #####: 8665:      if (yyssp >= yyss + yystacksize - 1)
branch  0 never executed
branch  1 never executed
    #####: 8666:	YYABORT;
        -: 8667:    }
        -: 8668:
        -: 8669:#if YYDEBUG != 0
        -: 8670:  if (yydebug)
        -: 8671:    fprintf(err, "Entering state %d\n", yystate);
        -: 8672:#endif
        -: 8673:
    89919: 8674:  goto yybackup;
    89919: 8675: yybackup:
        -: 8676:
        -: 8677:/* Do appropriate processing given the current state.  */
        -: 8678:/* Read a lookahead token if we need one and don't already have one.  */
        -: 8679:/* yyresume: */
        -: 8680:
        -: 8681:  /* First try to decide what to do without reference to lookahead token.  */
        -: 8682:
    89919: 8683:  yyn = yypact[yystate];
    89919: 8684:  if (yyn == YYFLAG)
branch  0 taken 32436 (fallthrough)
branch  1 taken 57483
    32436: 8685:    goto yydefault;
        -: 8686:
        -: 8687:  /* Not known => get a lookahead token if don't already have one.  */
        -: 8688:
        -: 8689:  /* yychar is either YYEMPTY or YYEOF
        -: 8690:     or a valid token in external form.  */
        -: 8691:
    57483: 8692:  if (yychar == YYEMPTY)
branch  0 taken 31208 (fallthrough)
branch  1 taken 26275
        -: 8693:    {
        -: 8694:#if YYDEBUG != 0
        -: 8695:      if (yydebug)
        -: 8696:	fprintf(err, "Reading a token: ");
        -: 8697:#endif
    31208: 8698:      yychar = YYLEX;
call    0 returned 31208
        -: 8699:    }
        -: 8700:
        -: 8701:  /* Convert token to internal form (in yychar1) for indexing tables with */
        -: 8702:
    57483: 8703:  if (yychar <= 0)		/* This means end of input. */
branch  0 taken 1653 (fallthrough)
branch  1 taken 55830
        -: 8704:    {
     1653: 8705:      yychar1 = 0;
     1653: 8706:      yychar = YYEOF;		/* Don't call YYLEX any more */
        -: 8707:
        -: 8708:#if YYDEBUG != 0
        -: 8709:      if (yydebug)
        -: 8710:	fprintf(err, "Now at end of input.\n");
        -: 8711:#endif
        -: 8712:    }
        -: 8713:  else
        -: 8714:    {
   55830*: 8715:      yychar1 = YYTRANSLATE(yychar);
branch  0 taken 55830 (fallthrough)
branch  1 taken 0
        -: 8716:
        -: 8717:#if YYDEBUG != 0
        -: 8718:      if (yydebug)
        -: 8719:	{
        -: 8720:	  fprintf (err, "Next token is %d (%s", yychar, yytname[yychar1]);
        -: 8721:	  /* Give the individual parser a way to print the precise meaning
        -: 8722:	     of a token, for further debugging info.  */
        -: 8723:#ifdef YYPRINT
        -: 8724:	  YYPRINT (err, yychar, yylval);
        -: 8725:#endif
        -: 8726:	  fprintf (err, ")\n");
        -: 8727:	}
        -: 8728:#endif
        -: 8729:    }
        -: 8730:
    57483: 8731:  yyn += yychar1;
    57483: 8732:  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != yychar1)
branch  0 taken 57483 (fallthrough)
branch  1 taken 0
branch  2 taken 57483 (fallthrough)
branch  3 taken 0
branch  4 taken 24617 (fallthrough)
branch  5 taken 32866
    24617: 8733:    goto yydefault;
        -: 8734:
    32866: 8735:  yyn = yytable[yyn];
        -: 8736:
        -: 8737:  /* yyn is what to do for this token type in this state.
        -: 8738:     Negative => reduce, -yyn is rule number.
        -: 8739:     Positive => shift, yyn is new state.
        -: 8740:       New state is final state => don't bother to shift,
        -: 8741:       just return success.
        -: 8742:     0, or most negative number => error.  */
        -: 8743:
    32866: 8744:  if (yyn < 0)
branch  0 taken 1116 (fallthrough)
branch  1 taken 31750
        -: 8745:    {
     1116: 8746:      if (yyn == YYFLAG)
branch  0 taken 0 (fallthrough)
branch  1 taken 1116
    #####: 8747:	goto yyerrlab;
     1116: 8748:      yyn = -yyn;
     1116: 8749:      goto yyreduce;
        -: 8750:    }
    31750: 8751:  else if (yyn == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 31750
    #####: 8752:    goto yyerrlab;
        -: 8753:
    31750: 8754:  if (yyn == YYFINAL)
branch  0 taken 551 (fallthrough)
branch  1 taken 31199
      551: 8755:    YYACCEPT;
        -: 8756:
        -: 8757:  /* Shift the lookahead token.  */
        -: 8758:
        -: 8759:#if YYDEBUG != 0
        -: 8760:  if (yydebug)
        -: 8761:    fprintf(err, "Shifting token %d (%s), ", yychar, yytname[yychar1]);
        -: 8762:#endif
        -: 8763:
        -: 8764:  /* Discard the token being shifted unless it is eof.  */
    31199: 8765:  if (yychar != YYEOF)
branch  0 taken 30648 (fallthrough)
branch  1 taken 551
    30648: 8766:    yychar = YYEMPTY;
        -: 8767:
    31199: 8768:  *++yyvsp = yylval;
        -: 8769:#ifdef YYLSP_NEEDED
        -: 8770:  *++yylsp = yylloc;
        -: 8771:#endif
        -: 8772:
        -: 8773:  /* count tokens shifted since error; after three, turn off error status.  */
    31199: 8774:  if (yyerrstatus) yyerrstatus--;
branch  0 taken 16 (fallthrough)
branch  1 taken 31183
        -: 8775:
    31199: 8776:  yystate = yyn;
    31199: 8777:  goto yynewstate;
        -: 8778:
        -: 8779:/* Do the default action for the current state.  */
    57053: 8780:yydefault:
        -: 8781:
    57053: 8782:  yyn = yydefact[yystate];
    57053: 8783:  if (yyn == 0)
branch  0 taken 15 (fallthrough)
branch  1 taken 57038
       15: 8784:    goto yyerrlab;
        -: 8785:
        -: 8786:/* Do a reduction.  yyn is the number of a rule to reduce with.  */
    57038: 8787:yyreduce:
    58154: 8788:  yylen = yyr2[yyn];
    58154: 8789:  if (yylen > 0)
branch  0 taken 50026 (fallthrough)
branch  1 taken 8128
    50026: 8790:    yyval = yyvsp[1-yylen]; /* implement default value of the action */
        -: 8791:
        -: 8792:#if YYDEBUG != 0
        -: 8793:  if (yydebug)
        -: 8794:    {
        -: 8795:      int i;
        -: 8796:
        -: 8797:      fprintf (err, "Reducing via rule %d (line %d), ",
        -: 8798:	       yyn, yyrline[yyn]);
        -: 8799:
        -: 8800:      /* Print the symbols being reduced, and their result.  */
        -: 8801:      for (i = yyprhs[yyn]; yyrhs[i] > 0; i++)
        -: 8802:	fprintf (err, "%s ", yytname[yyrhs[i]]);
        -: 8803:      fprintf (err, " -> %s\n", yytname[yyr1[yyn]]);
        -: 8804:    }
        -: 8805:#endif
        -: 8806:
        -: 8807:
    58154: 8808:  switch (yyn) {
branch  0 taken 551
branch  1 taken 552
branch  2 taken 0
branch  3 taken 552
branch  4 taken 1
branch  5 taken 18
branch  6 taken 0
branch  7 taken 19
branch  8 taken 0
branch  9 taken 4076
branch 10 taken 0
branch 11 taken 11
branch 12 taken 100
branch 13 taken 3396
branch 14 taken 5
branch 15 taken 6
branch 16 taken 15
branch 17 taken 3
branch 18 taken 13
branch 19 taken 0
branch 20 taken 17
branch 21 taken 110
branch 22 taken 0
branch 23 taken 103
branch 24 taken 3294
branch 25 taken 1095
branch 26 taken 4208
branch 27 taken 111
branch 28 taken 7055
branch 29 taken 5303
branch 30 taken 842
branch 31 taken 346
branch 32 taken 4
branch 33 taken 100
branch 34 taken 98
branch 35 taken 98
branch 36 taken 213
branch 37 taken 1293
branch 38 taken 231
branch 39 taken 1090
branch 40 taken 588
branch 41 taken 8944
branch 42 taken 1075
branch 43 taken 218
branch 44 taken 876
branch 45 taken 2462
branch 46 taken 1293
branch 47 taken 2002
branch 48 taken 1090
branch 49 taken 4677
        -: 8809:
      551: 8810:case 1:
        -: 8811:{ /* add default rule */
        -: 8812:			int def_rule;
        -: 8813:
      551: 8814:			pat = cclinit();
call    0 returned 551
      551: 8815:			cclnegate( pat );
call    0 returned 551
        -: 8816:
      551: 8817:			def_rule = mkstate( -pat );
call    0 returned 551
        -: 8818:
        -: 8819:			/* Remember the number of the default rule so we
        -: 8820:			 * don't generate "can't match" warnings for it.
        -: 8821:			 */
      551: 8822:			default_rule = num_rules;
        -: 8823:
      551: 8824:			finish_rule( def_rule, false, 0, 0 );
call    0 returned 551
        -: 8825:
     1121: 8826:			for ( i = 1; i <= lastsc; ++i )
branch  0 taken 570
branch  1 taken 551 (fallthrough)
      570: 8827:				scset[i] = mkbranch( scset[i], def_rule );
call    0 returned 570
        -: 8828:
      551: 8829:			if ( spprdflt )
branch  0 taken 3 (fallthrough)
branch  1 taken 548
        3: 8830:				add_action(
call    0 returned 3
        -: 8831:				"YY_FATAL_ERROR( \"flex scanner jammed\" )" );
        -: 8832:			else
      548: 8833:				add_action( "ECHO" );
call    0 returned 548
        -: 8834:
      551: 8835:			add_action( ";\n\tYY_BREAK\n" );
call    0 returned 551
        -: 8836:			;
      551: 8837:    break;}
      552: 8838:case 2:
        -: 8839:{ /* initialize for processing rules */
        -: 8840:
        -: 8841:			/* Create default DFA start condition. */
      552: 8842:			scinstal( "INITIAL", false );
call    0 returned 552
        -: 8843:
        -: 8844:			/* Initially, the start condition scoping is
        -: 8845:			 * "no start conditions active".
        -: 8846:			 */
      552: 8847:			actvp = 0;
        -: 8848:			;
      552: 8849:    break;}
    #####: 8850:case 5:
    #####: 8851:{ synerr( "unknown error processing section 1" ); ;
call    0 never executed
    #####: 8852:    break;}
      552: 8853:case 6:
        -: 8854:{
        -: 8855:			/* We now know how many start conditions there
        -: 8856:			 * are, so create the "activity" map indicating
        -: 8857:			 * which conditions are active.
        -: 8858:			 */
      552: 8859:			active_ss = allocate_integer_array( lastsc + 1 );
call    0 returned 552
        -: 8860:
     1123: 8861:			for ( i = 1; i <= lastsc; ++i )
branch  0 taken 571
branch  1 taken 552 (fallthrough)
      571: 8862:				active_ss[i] = 0;
        -: 8863:			;
      552: 8864:    break;}
        1: 8865:case 7:
        1: 8866:{ xcluflg = false; ;
        1: 8867:    break;}
       18: 8868:case 8:
       18: 8869:{ xcluflg = true; ;
       18: 8870:    break;}
    #####: 8871:case 9:
    #####: 8872:{ scinstal( nmstr, xcluflg ); ;
call    0 never executed
    #####: 8873:    break;}
       19: 8874:case 10:
       19: 8875:{ scinstal( nmstr, xcluflg ); ;
call    0 returned 19
       19: 8876:    break;}
    #####: 8877:case 11:
    #####: 8878:{ synerr( "bad start condition list" ); ;
call    0 never executed
    #####: 8879:    break;}
     4076: 8880:case 14:
        -: 8881:{
        -: 8882:			/* Initialize for a parse of one rule. */
     4076: 8883:			trlcontxt = variable_trail_rule = varlength = false;
     4076: 8884:			trailcnt = headcnt = rulelen = 0;
     4076: 8885:			current_state_type = STATE_NORMAL;
     4076: 8886:			previous_continued_action = continued_action;
     4076: 8887:			new_rule();
call    0 returned 4076
        -: 8888:			;
     4076: 8889:    break;}
    #####: 8890:case 15:
        -: 8891:{
    #####: 8892:			pat = yyvsp[0];
    #####: 8893:			finish_rule( pat, variable_trail_rule,
call    0 never executed
        -: 8894:				headcnt, trailcnt );
        -: 8895:
    #####: 8896:			for ( i = 1; i <= actvp; ++i )
branch  0 never executed
branch  1 never executed
    #####: 8897:				scbol[actvsc[i]] =
    #####: 8898:					mkbranch( scbol[actvsc[i]], pat );
call    0 never executed
        -: 8899:
    #####: 8900:			if ( ! bol_needed )
branch  0 never executed
branch  1 never executed
        -: 8901:				{
    #####: 8902:				bol_needed = true;
        -: 8903:
    #####: 8904:				if ( performance_report > 1 )
branch  0 never executed
branch  1 never executed
    #####: 8905:					pinpoint_message( 
call    0 never executed
        -: 8906:			"'^' operator results in sub-optimal performance" );
        -: 8907:				}
        -: 8908:			;
    #####: 8909:    break;}
       11: 8910:case 16:
        -: 8911:{
       11: 8912:			pat = yyvsp[0];
       11: 8913:			finish_rule( pat, variable_trail_rule,
call    0 returned 11
        -: 8914:				headcnt, trailcnt );
        -: 8915:
       42: 8916:			for ( i = 1; i <= actvp; ++i )
branch  0 taken 31
branch  1 taken 11 (fallthrough)
       31: 8917:				scset[actvsc[i]] =
       31: 8918:					mkbranch( scset[actvsc[i]], pat );
call    0 returned 31
        -: 8919:			;
       11: 8920:    break;}
      100: 8921:case 17:
        -: 8922:{
      100: 8923:			pat = yyvsp[0];
      100: 8924:			finish_rule( pat, variable_trail_rule,
call    0 returned 100
        -: 8925:				headcnt, trailcnt );
        -: 8926:
        -: 8927:			/* Add to all non-exclusive start conditions,
        -: 8928:			 * including the default (0) start condition.
        -: 8929:			 */
        -: 8930:
      212: 8931:			for ( i = 1; i <= lastsc; ++i )
branch  0 taken 112
branch  1 taken 100 (fallthrough)
      112: 8932:				if ( ! scxclu[i] )
branch  0 taken 100 (fallthrough)
branch  1 taken 12
      100: 8933:					scbol[i] = mkbranch( scbol[i], pat );
call    0 returned 100
        -: 8934:
      100: 8935:			if ( ! bol_needed )
branch  0 taken 99 (fallthrough)
branch  1 taken 1
        -: 8936:				{
       99: 8937:				bol_needed = true;
        -: 8938:
       99: 8939:				if ( performance_report > 1 )
branch  0 taken 0 (fallthrough)
branch  1 taken 99
    #####: 8940:					pinpoint_message(
call    0 never executed
        -: 8941:			"'^' operator results in sub-optimal performance" );
        -: 8942:				}
        -: 8943:			;
      100: 8944:    break;}
     3396: 8945:case 18:
        -: 8946:{
     3396: 8947:			pat = yyvsp[0];
     3396: 8948:			finish_rule( pat, variable_trail_rule,
call    0 returned 3396
        -: 8949:				headcnt, trailcnt );
        -: 8950:
    10137: 8951:			for ( i = 1; i <= lastsc; ++i )
branch  0 taken 6741
branch  1 taken 3396 (fallthrough)
     6741: 8952:				if ( ! scxclu[i] )
branch  0 taken 3408 (fallthrough)
branch  1 taken 3333
     3408: 8953:					scset[i] = mkbranch( scset[i], pat );
call    0 returned 3408
        -: 8954:			;
     3396: 8955:    break;}
        5: 8956:case 19:
        5: 8957:{ build_eof_action(); ;
call    0 returned 5
        5: 8958:    break;}
        6: 8959:case 20:
        -: 8960:{
        -: 8961:			/* This EOF applies to all start conditions
        -: 8962:			 * which don't already have EOF actions.
        -: 8963:			 */
        6: 8964:			actvp = 0;
        -: 8965:
       27: 8966:			for ( i = 1; i <= lastsc; ++i )
branch  0 taken 21
branch  1 taken 6 (fallthrough)
       21: 8967:				if ( ! sceof[i] )
branch  0 taken 17 (fallthrough)
branch  1 taken 4
       17: 8968:					actvsc[++actvp] = i;
        -: 8969:
        6: 8970:			if ( actvp == 0 )
branch  0 taken 0 (fallthrough)
branch  1 taken 6
    #####: 8971:				warn(
call    0 never executed
        -: 8972:			"all start conditions already have <<EOF>> rules" );
        -: 8973:
        -: 8974:			else
        6: 8975:				build_eof_action();
call    0 returned 6
        -: 8976:			;
        6: 8977:    break;}
       15: 8978:case 21:
       15: 8979:{ synerr( "unrecognized rule" ); ;
call    0 returned 15
       15: 8980:    break;}
        3: 8981:case 23:
        -: 8982:{
        3: 8983:			actvp = 0;
        -: 8984:
       22: 8985:			for ( i = 1; i <= lastsc; ++i )
branch  0 taken 19
branch  1 taken 3 (fallthrough)
       19: 8986:				actvsc[++actvp] = i;
        -: 8987:			;
        3: 8988:    break;}
       13: 8989:case 25:
       13: 8990:{ actvp = 0; ;
       13: 8991:    break;}
    #####: 8992:case 27:
    #####: 8993:{ synerr( "bad start condition list" ); ;
call    0 never executed
    #####: 8994:    break;}
       17: 8995:case 28:
        -: 8996:{
       17: 8997:			if ( (scnum = sclookup( nmstr )) == 0 )
call    0 returned 17
branch  1 taken 0 (fallthrough)
branch  2 taken 17
    #####: 8998:				format_pinpoint_message(
call    0 never executed
        -: 8999:					"undeclared start condition %s",
        -: 9000:					nmstr );
        -: 9001:			else
        -: 9002:				{
       17: 9003:				if ( ++actvp >= current_max_scs )
branch  0 taken 0 (fallthrough)
branch  1 taken 17
        -: 9004:					/* Some bozo has included multiple
        -: 9005:					 * instances of start condition names.
        -: 9006:					 */
    #####: 9007:					pinpoint_message(
call    0 never executed
        -: 9008:				"too many start conditions in <> construct!" );
        -: 9009:
        -: 9010:				else
       17: 9011:					actvsc[actvp] = scnum;
        -: 9012:				}
        -: 9013:			;
       17: 9014:    break;}
      110: 9015:case 29:
        -: 9016:{
      110: 9017:			if ( transchar[lastst[yyvsp[0]]] != SYM_EPSILON )
branch  0 taken 108 (fallthrough)
branch  1 taken 2
        -: 9018:				/* Provide final transition \now/ so it
        -: 9019:				 * will be marked as a trailing context
        -: 9020:				 * state.
        -: 9021:				 */
      108: 9022:				yyvsp[0] = link_machines( yyvsp[0],
call    0 returned 108
call    1 returned 108
        -: 9023:						mkstate( SYM_EPSILON ) );
        -: 9024:
      110: 9025:			mark_beginning_as_normal( yyvsp[0] );
call    0 returned 110
      110: 9026:			current_state_type = STATE_NORMAL;
        -: 9027:
      110: 9028:			if ( previous_continued_action )
branch  0 taken 2 (fallthrough)
branch  1 taken 108
        -: 9029:				{
        -: 9030:				/* We need to treat this as variable trailing
        -: 9031:				 * context so that the backup does not happen
        -: 9032:				 * in the action but before the action switch
        -: 9033:				 * statement.  If the backup happens in the
        -: 9034:				 * action, then the rules "falling into" this
        -: 9035:				 * one's action will *also* do the backup,
        -: 9036:				 * erroneously.
        -: 9037:				 */
        2: 9038:				if ( ! varlength || headcnt != 0 )
branch  0 taken 2 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 2
    #####: 9039:					warn(
call    0 never executed
        -: 9040:		"trailing context made variable due to preceding '|' action" );
        -: 9041:
        -: 9042:				/* Mark as variable. */
        2: 9043:				varlength = true;
        2: 9044:				headcnt = 0;
        -: 9045:				}
        -: 9046:
      110: 9047:			if ( lex_compat || (varlength && headcnt == 0) )
branch  0 taken 79 (fallthrough)
branch  1 taken 31
branch  2 taken 2 (fallthrough)
branch  3 taken 77
branch  4 taken 2 (fallthrough)
branch  5 taken 0
        -: 9048:				{ /* variable trailing context rule */
        -: 9049:				/* Mark the first part of the rule as the
        -: 9050:				 * accepting "head" part of a trailing
        -: 9051:				 * context rule.
        -: 9052:				 *
        -: 9053:				 * By the way, we didn't do this at the
        -: 9054:				 * beginning of this production because back
        -: 9055:				 * then current_state_type was set up for a
        -: 9056:				 * trail rule, and add_accept() can create
        -: 9057:				 * a new state ...
        -: 9058:				 */
       33: 9059:				add_accept( yyvsp[-1],
call    0 returned 33
        -: 9060:					num_rules | YY_TRAILING_HEAD_MASK );
       33: 9061:				variable_trail_rule = true;
        -: 9062:				}
        -: 9063:			
        -: 9064:			else
       77: 9065:				trailcnt = rulelen;
        -: 9066:
      110: 9067:			yyval = link_machines( yyvsp[-1], yyvsp[0] );
call    0 returned 110
        -: 9068:			;
      110: 9069:    break;}
    #####: 9070:case 30:
    #####: 9071:{ synerr( "trailing context used twice" ); ;
call    0 never executed
    #####: 9072:    break;}
      103: 9073:case 31:
        -: 9074:{
      103: 9075:			headcnt = 0;
      103: 9076:			trailcnt = 1;
      103: 9077:			rulelen = 1;
        -: 9078:#ifndef	F_HD_7
      103: 9079:			varlength = false; 
        -: 9080:#else
        -: 9081:			varlength = true; 
        -: 9082:#endif
        -: 9083:
      103: 9084:			current_state_type = STATE_TRAILING_CONTEXT;
        -: 9085:
      103: 9086:			if ( trlcontxt )
branch  0 taken 0 (fallthrough)
branch  1 taken 103
        -: 9087:				{
    #####: 9088:				synerr( "trailing context used twice" );
call    0 never executed
    #####: 9089:				yyval = mkstate( SYM_EPSILON );
call    0 never executed
        -: 9090:				}
        -: 9091:
      103: 9092:			else if ( previous_continued_action )
branch  0 taken 0 (fallthrough)
branch  1 taken 103
        -: 9093:				{
        -: 9094:				/* See the comment in the rule for "re2 re"
        -: 9095:				 * above.
        -: 9096:				 */
    #####: 9097:				warn(
call    0 never executed
        -: 9098:		"trailing context made variable due to preceding '|' action" );
        -: 9099:
    #####: 9100:				varlength = true;
        -: 9101:				}
        -: 9102:
      103: 9103:			if ( lex_compat || varlength )
branch  0 taken 72 (fallthrough)
branch  1 taken 31
branch  2 taken 0 (fallthrough)
branch  3 taken 72
        -: 9104:				{
        -: 9105:				/* Again, see the comment in the rule for
        -: 9106:				 * "re2 re" above.
        -: 9107:				 */
       31: 9108:				add_accept( yyvsp[-1],
call    0 returned 31
        -: 9109:					num_rules | YY_TRAILING_HEAD_MASK );
       31: 9110:				variable_trail_rule = true;
        -: 9111:				}
        -: 9112:
      103: 9113:			trlcontxt = true;
        -: 9114:
      103: 9115:			eps = mkstate( SYM_EPSILON );
call    0 returned 103
      103: 9116:			yyval = link_machines( yyvsp[-1],
call    0 returned 103
call    1 returned 103
call    2 returned 103
        -: 9117:				link_machines( eps, mkstate( '\n' ) ) );
        -: 9118:			;
      103: 9119:    break;}
     3294: 9120:case 32:
        -: 9121:{
     3294: 9122:			yyval = yyvsp[0];
        -: 9123:
     3294: 9124:			if ( trlcontxt )
branch  0 taken 0 (fallthrough)
branch  1 taken 3294
        -: 9125:				{
    #####: 9126:				if ( lex_compat || (varlength && headcnt == 0) )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 9127:					/* Both head and trail are
        -: 9128:					 * variable-length.
        -: 9129:					 */
    #####: 9130:					variable_trail_rule = true;
        -: 9131:				else
    #####: 9132:					trailcnt = rulelen;
        -: 9133:				}
        -: 9134:			;
     3294: 9135:    break;}
     1095: 9136:case 33:
        -: 9137:{
     1095: 9138:			varlength = true;
     1095: 9139:			yyval = mkor( yyvsp[-2], yyvsp[0] );
call    0 returned 1095
        -: 9140:			;
     1095: 9141:    break;}
     4208: 9142:case 34:
     4208: 9143:{ yyval = yyvsp[0]; ;
     4208: 9144:    break;}
      111: 9145:case 35:
        -: 9146:{
        -: 9147:			/* This rule is written separately so the
        -: 9148:			 * reduction will occur before the trailing
        -: 9149:			 * series is parsed.
        -: 9150:			 */
        -: 9151:
      111: 9152:			if ( trlcontxt )
branch  0 taken 0 (fallthrough)
branch  1 taken 111
    #####: 9153:				synerr( "trailing context used twice" );
call    0 never executed
        -: 9154:			else
      111: 9155:				trlcontxt = true;
        -: 9156:
      111: 9157:			if ( varlength )
branch  0 taken 3 (fallthrough)
branch  1 taken 108
        -: 9158:				/* We hope the trailing context is
        -: 9159:				 * fixed-length.
        -: 9160:				 */
        3: 9161:				varlength = false;
        -: 9162:			else
      108: 9163:				headcnt = rulelen;
        -: 9164:
      111: 9165:			rulelen = 0;
        -: 9166:
      111: 9167:			current_state_type = STATE_TRAILING_CONTEXT;
      111: 9168:			yyval = yyvsp[-1];
        -: 9169:			;
      111: 9170:    break;}
     7055: 9171:case 36:
        -: 9172:{
        -: 9173:			/* This is where concatenation of adjacent patterns
        -: 9174:			 * gets done.
        -: 9175:			 */
     7055: 9176:			yyval = link_machines( yyvsp[-1], yyvsp[0] );
call    0 returned 7055
        -: 9177:			;
     7055: 9178:    break;}
     5303: 9179:case 37:
     5303: 9180:{ yyval = yyvsp[0]; ;
     5303: 9181:    break;}
      842: 9182:case 38:
        -: 9183:{
      842: 9184:			varlength = true;
        -: 9185:
      842: 9186:			yyval = mkclos( yyvsp[-1] );
call    0 returned 842
        -: 9187:			;
      842: 9188:    break;}
      346: 9189:case 39:
        -: 9190:{
      346: 9191:			varlength = true;
      346: 9192:			yyval = mkposcl( yyvsp[-1] );
call    0 returned 346
        -: 9193:			;
      346: 9194:    break;}
        4: 9195:case 40:
        -: 9196:{
        4: 9197:			varlength = true;
        4: 9198:			yyval = mkopt( yyvsp[-1] );
call    0 returned 4
        -: 9199:			;
        4: 9200:    break;}
      100: 9201:case 41:
        -: 9202:{
      100: 9203:			varlength = true;
        -: 9204:
      100: 9205:			if ( yyvsp[-3] > yyvsp[-1] || yyvsp[-3] < 0 )
branch  0 taken 100 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 100
        -: 9206:				{
    #####: 9207:				synerr( "bad iteration values" );
call    0 never executed
    #####: 9208:				yyval = yyvsp[-5];
        -: 9209:				}
        -: 9210:			else
        -: 9211:				{
      100: 9212:				if ( yyvsp[-3] == 0 )
branch  0 taken 0 (fallthrough)
branch  1 taken 100
        -: 9213:					{
    #####: 9214:					if ( yyvsp[-1] <= 0 )
branch  0 never executed
branch  1 never executed
        -: 9215:						{
    #####: 9216:						synerr(
call    0 never executed
        -: 9217:						"bad iteration values" );
    #####: 9218:						yyval = yyvsp[-5];
        -: 9219:						}
        -: 9220:					else
    #####: 9221:						yyval = mkopt(
call    0 never executed
    #####: 9222:							mkrep( yyvsp[-5], 1, yyvsp[-1] ) );
call    0 never executed
        -: 9223:					}
        -: 9224:				else
      100: 9225:					yyval = mkrep( yyvsp[-5], yyvsp[-3], yyvsp[-1] );
call    0 returned 100
        -: 9226:				}
        -: 9227:			;
      100: 9228:    break;}
       98: 9229:case 42:
        -: 9230:{
       98: 9231:			varlength = true;
        -: 9232:
       98: 9233:			if ( yyvsp[-2] <= 0 )
branch  0 taken 0 (fallthrough)
branch  1 taken 98
        -: 9234:				{
    #####: 9235:				synerr( "iteration value must be positive" );
call    0 never executed
    #####: 9236:				yyval = yyvsp[-4];
        -: 9237:				}
        -: 9238:
        -: 9239:			else
       98: 9240:				yyval = mkrep( yyvsp[-4], yyvsp[-2], INFINITY );
call    0 returned 98
        -: 9241:			;
       98: 9242:    break;}
       98: 9243:case 43:
        -: 9244:{
        -: 9245:			/* The singleton could be something like "(foo)",
        -: 9246:			 * in which case we have no idea what its length
        -: 9247:			 * is, so we punt here.
        -: 9248:			 */
       98: 9249:			varlength = true;
        -: 9250:
       98: 9251:			if ( yyvsp[-1] <= 0 )
branch  0 taken 0 (fallthrough)
branch  1 taken 98
        -: 9252:				{
    #####: 9253:				synerr( "iteration value must be positive" );
call    0 never executed
    #####: 9254:				yyval = yyvsp[-3];
        -: 9255:				}
        -: 9256:
        -: 9257:			else
       98: 9258:				yyval = link_machines( yyvsp[-3],
call    0 returned 98
       98: 9259:						copysingl( yyvsp[-3], yyvsp[-1] - 1 ) );
call    0 returned 98
        -: 9260:			;
       98: 9261:    break;}
      213: 9262:case 44:
        -: 9263:{
      213: 9264:			if ( ! madeany )
branch  0 taken 210 (fallthrough)
branch  1 taken 3
        -: 9265:				{
        -: 9266:				/* Create the '.' character class. */
      210: 9267:				anyccl = cclinit();
call    0 returned 210
      210: 9268:				ccladd( anyccl, '\n' );
call    0 returned 210
      210: 9269:				cclnegate( anyccl );
call    0 returned 210
        -: 9270:
      210: 9271:				if ( useecs )
branch  0 taken 115 (fallthrough)
branch  1 taken 95
      115: 9272:					mkeccl( ccltbl + cclmap[anyccl],
      115: 9273:						ccllen[anyccl], nextecm,
call    0 returned 115
        -: 9274:						ecgroup, csize, csize );
        -: 9275:
      210: 9276:				madeany = true;
        -: 9277:				}
        -: 9278:
      213: 9279:			++rulelen;
        -: 9280:
      213: 9281:			yyval = mkstate( -anyccl );
call    0 returned 213
        -: 9282:			;
      213: 9283:    break;}
     1293: 9284:case 45:
        -: 9285:{
     1293: 9286:			if ( ! cclsorted )
branch  0 taken 847 (fallthrough)
branch  1 taken 446
        -: 9287:				/* Sort characters for fast searching.  We
        -: 9288:				 * use a shell sort since this list could
        -: 9289:				 * be large.
        -: 9290:				 */
      847: 9291:				cshell( ccltbl + cclmap[yyvsp[0]], ccllen[yyvsp[0]], true );
call    0 returned 847
        -: 9292:
     1293: 9293:			if ( useecs )
branch  0 taken 812 (fallthrough)
branch  1 taken 481
      812: 9294:				mkeccl( ccltbl + cclmap[yyvsp[0]], ccllen[yyvsp[0]],
call    0 returned 812
        -: 9295:					nextecm, ecgroup, csize, csize );
        -: 9296:
     1293: 9297:			++rulelen;
        -: 9298:
     1293: 9299:			yyval = mkstate( -yyvsp[0] );
call    0 returned 1293
        -: 9300:			;
     1293: 9301:    break;}
      231: 9302:case 46:
        -: 9303:{
      231: 9304:			++rulelen;
        -: 9305:
      231: 9306:			yyval = mkstate( -yyvsp[0] );
call    0 returned 231
        -: 9307:			;
      231: 9308:    break;}
     1090: 9309:case 47:
     1090: 9310:{ yyval = yyvsp[-1]; ;
     1090: 9311:    break;}
      588: 9312:case 48:
      588: 9313:{ yyval = yyvsp[-1]; ;
      588: 9314:    break;}
     8944: 9315:case 49:
        -: 9316:{
     8944: 9317:			++rulelen;
        -: 9318:
     8944: 9319:			if ( caseins && yyvsp[0] >= 'A' && yyvsp[0] <= 'Z' )
branch  0 taken 73 (fallthrough)
branch  1 taken 8871
branch  2 taken 72 (fallthrough)
branch  3 taken 1
branch  4 taken 0 (fallthrough)
branch  5 taken 72
    #####: 9320:				yyvsp[0] = clower( yyvsp[0] );
call    0 never executed
        -: 9321:
     8944: 9322:			yyval = mkstate( yyvsp[0] );
call    0 returned 8943
        -: 9323:			;
     8943: 9324:    break;}
     1075: 9325:case 50:
     1075: 9326:{ yyval = yyvsp[-1]; ;
     1075: 9327:    break;}
      218: 9328:case 51:
        -: 9329:{
      218: 9330:			cclnegate( yyvsp[-1] );
call    0 returned 218
      218: 9331:			yyval = yyvsp[-1];
        -: 9332:			;
      218: 9333:    break;}
      876: 9334:case 52:
        -: 9335:{
      876: 9336:			if ( caseins )
branch  0 taken 9 (fallthrough)
branch  1 taken 867
        -: 9337:				{
        9: 9338:				if ( yyvsp[-2] >= 'A' && yyvsp[-2] <= 'Z' )
branch  0 taken 4 (fallthrough)
branch  1 taken 5
branch  2 taken 0 (fallthrough)
branch  3 taken 4
    #####: 9339:					yyvsp[-2] = clower( yyvsp[-2] );
call    0 never executed
        9: 9340:				if ( yyvsp[0] >= 'A' && yyvsp[0] <= 'Z' )
branch  0 taken 4 (fallthrough)
branch  1 taken 5
branch  2 taken 0 (fallthrough)
branch  3 taken 4
    #####: 9341:					yyvsp[0] = clower( yyvsp[0] );
call    0 never executed
        -: 9342:				}
        -: 9343:
      876: 9344:			if ( yyvsp[-2] > yyvsp[0] )
branch  0 taken 2 (fallthrough)
branch  1 taken 874
        2: 9345:				synerr( "negative range in character class" );
call    0 returned 2
        -: 9346:
        -: 9347:			else
        -: 9348:				{
    23346: 9349:				for ( i = yyvsp[-2]; i <= yyvsp[0]; ++i )
branch  0 taken 22472
branch  1 taken 874 (fallthrough)
    22472: 9350:					ccladd( yyvsp[-3], i );
call    0 returned 22472
        -: 9351:
        -: 9352:				/* Keep track if this ccl is staying in
        -: 9353:				 * alphabetical order.
        -: 9354:				 */
      874: 9355:				cclsorted = cclsorted && (yyvsp[-2] > lastchar);
branch  0 taken 844 (fallthrough)
branch  1 taken 30
branch  2 taken 556 (fallthrough)
branch  3 taken 288
      874: 9356:				lastchar = yyvsp[0];
        -: 9357:				}
        -: 9358:
      876: 9359:			yyval = yyvsp[-3];
        -: 9360:			;
      876: 9361:    break;}
     2462: 9362:case 53:
        -: 9363:{
     2462: 9364:			if ( caseins && yyvsp[0] >= 'A' && yyvsp[0] <= 'Z' )
branch  0 taken 10 (fallthrough)
branch  1 taken 2452
branch  2 taken 2 (fallthrough)
branch  3 taken 8
branch  4 taken 0 (fallthrough)
branch  5 taken 2
    #####: 9365:				yyvsp[0] = clower( yyvsp[0] );
call    0 never executed
        -: 9366:
     2462: 9367:			ccladd( yyvsp[-1], yyvsp[0] );
call    0 returned 2462
     2462: 9368:			cclsorted = cclsorted && (yyvsp[0] > lastchar);
branch  0 taken 2345 (fallthrough)
branch  1 taken 117
branch  2 taken 1786 (fallthrough)
branch  3 taken 559
     2462: 9369:			lastchar = yyvsp[0];
     2462: 9370:			yyval = yyvsp[-1];
        -: 9371:			;
     2462: 9372:    break;}
     1293: 9373:case 54:
        -: 9374:{
     1293: 9375:			cclsorted = true;
     1293: 9376:			lastchar = 0;
     1293: 9377:			yyval = cclinit();
call    0 returned 1293
        -: 9378:			;
     1293: 9379:    break;}
     2002: 9380:case 55:
        -: 9381:{
     2002: 9382:			if ( caseins && yyvsp[0] >= 'A' && yyvsp[0] <= 'Z' )
branch  0 taken 18 (fallthrough)
branch  1 taken 1984
branch  2 taken 6 (fallthrough)
branch  3 taken 12
branch  4 taken 0 (fallthrough)
branch  5 taken 6
    #####: 9383:				yyvsp[0] = clower( yyvsp[0] );
call    0 never executed
        -: 9384:
     2002: 9385:			++rulelen;
        -: 9386:
     2002: 9387:			yyval = link_machines( yyvsp[-1], mkstate( yyvsp[0] ) );
call    0 returned 2002
call    1 returned 2002
        -: 9388:			;
     2002: 9389:    break;}
     1090: 9390:case 56:
     1090: 9391:{ yyval = mkstate( SYM_EPSILON ); ;
call    0 returned 1090
     1090: 9392:    break;}
        -: 9393:}
        -: 9394:   /* the action file gets copied in in place of this dollarsign */
    58153: 9395:  yyvsp -= yylen;
    58153: 9396:  yyssp -= yylen;
        -: 9397:#ifdef YYLSP_NEEDED
        -: 9398:  yylsp -= yylen;
        -: 9399:#endif
        -: 9400:
        -: 9401:#if YYDEBUG != 0
        -: 9402:  if (yydebug)
        -: 9403:    {
        -: 9404:      short *ssp1 = yyss - 1;
        -: 9405:      fprintf (err, "state stack now");
        -: 9406:      while (ssp1 != yyssp)
        -: 9407:	fprintf (err, " %d", *++ssp1);
        -: 9408:      fprintf (err, "\n");
        -: 9409:    }
        -: 9410:#endif
        -: 9411:
    58153: 9412:  *++yyvsp = yyval;
        -: 9413:
        -: 9414:#ifdef YYLSP_NEEDED
        -: 9415:  yylsp++;
        -: 9416:  if (yylen == 0)
        -: 9417:    {
        -: 9418:      yylsp->first_line = yylloc.first_line;
        -: 9419:      yylsp->first_column = yylloc.first_column;
        -: 9420:      yylsp->last_line = (yylsp-1)->last_line;
        -: 9421:      yylsp->last_column = (yylsp-1)->last_column;
        -: 9422:      yylsp->text = 0;
        -: 9423:    }
        -: 9424:  else
        -: 9425:    {
        -: 9426:      yylsp->last_line = (yylsp+yylen-1)->last_line;
        -: 9427:      yylsp->last_column = (yylsp+yylen-1)->last_column;
        -: 9428:    }
        -: 9429:#endif
        -: 9430:
        -: 9431:  /* Now "shift" the result of the reduction.
        -: 9432:     Determine what state that goes to,
        -: 9433:     based on the state we popped back to
        -: 9434:     and the rule number reduced by.  */
        -: 9435:
    58153: 9436:  yyn = yyr1[yyn];
        -: 9437:
    58153: 9438:  yystate = yypgoto[yyn - YYNTBASE] + *yyssp;
    58153: 9439:  if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *yyssp)
branch  0 taken 31108 (fallthrough)
branch  1 taken 27045
branch  2 taken 31108 (fallthrough)
branch  3 taken 0
branch  4 taken 13226 (fallthrough)
branch  5 taken 17882
    13226: 9440:    yystate = yytable[yystate];
        -: 9441:  else
    44927: 9442:    yystate = yydefgoto[yyn - YYNTBASE];
        -: 9443:
    58153: 9444:  goto yynewstate;
        -: 9445:
       15: 9446:yyerrlab:   /* here on detecting error */
        -: 9447:
       15: 9448:  if (! yyerrstatus)
branch  0 taken 5 (fallthrough)
branch  1 taken 10
        -: 9449:    /* If not already recovering from an error, report this error.  */
        -: 9450:    {
        5: 9451:      ++yynerrs;
        -: 9452:
        -: 9453:#ifdef YYERROR_VERBOSE
        -: 9454:      yyn = yypact[yystate];
        -: 9455:
        -: 9456:      if (yyn > YYFLAG && yyn < YYLAST)
        -: 9457:	{
        -: 9458:	  int size = 0;
        -: 9459:	  char *msg;
        -: 9460:	  int x, count;
        -: 9461:
        -: 9462:	  count = 0;
        -: 9463:	  /* Start X at -yyn if nec to avoid negative indexes in yycheck.  */
        -: 9464:	  for (x = (yyn < 0 ? -yyn : 0);
        -: 9465:	       x < (sizeof(yytname) / sizeof(char *)); x++)
        -: 9466:	    if (yycheck[x + yyn] == x)
        -: 9467:	      size += strlen(yytname[x]) + 15, count++;
        -: 9468:	  msg = (char *) malloc(size + 15);
        -: 9469:	  if (msg != 0)
        -: 9470:	    {
        -: 9471:	      strcpy(msg, "parse error");
        -: 9472:
        -: 9473:	      if (count < 5)
        -: 9474:		{
        -: 9475:		  count = 0;
        -: 9476:		  for (x = (yyn < 0 ? -yyn : 0);
        -: 9477:		       x < (sizeof(yytname) / sizeof(char *)); x++)
        -: 9478:		    if (yycheck[x + yyn] == x)
        -: 9479:		      {
        -: 9480:			strcat(msg, count == 0 ? ", expecting `" : " or `");
        -: 9481:			strcat(msg, yytname[x]);
        -: 9482:			strcat(msg, "'");
        -: 9483:			count++;
        -: 9484:		      }
        -: 9485:		}
        -: 9486:	      yyerror(msg);
        -: 9487:	      free(msg);
        -: 9488:	    }
        -: 9489:	  else
        -: 9490:	    yyerror ("parse error; also virtual memory exceeded");
        -: 9491:	}
        -: 9492:      else
        -: 9493:#endif /* YYERROR_VERBOSE */
        5: 9494:	yyerror("parse error");
call    0 returned 5
        -: 9495:    }
        -: 9496:
       15: 9497:  goto yyerrlab1;
       15: 9498:yyerrlab1:   /* here on error raised explicitly by an action */
        -: 9499:
       15: 9500:  if (yyerrstatus == 3)
branch  0 taken 9 (fallthrough)
branch  1 taken 6
        -: 9501:    {
        -: 9502:      /* if just tried and failed to reuse lookahead token after an error, discard it.  */
        -: 9503:
        -: 9504:      /* return failure if at end of input */
        9: 9505:      if (yychar == YYEOF)
branch  0 taken 0 (fallthrough)
branch  1 taken 9
    #####: 9506:	YYABORT;
        -: 9507:
        -: 9508:#if YYDEBUG != 0
        -: 9509:      if (yydebug)
        -: 9510:	fprintf(err, "Discarding token %d (%s).\n", yychar, yytname[yychar1]);
        -: 9511:#endif
        -: 9512:
        9: 9513:      yychar = YYEMPTY;
        -: 9514:    }
        -: 9515:
        -: 9516:  /* Else will try to reuse lookahead token
        -: 9517:     after shifting the error token.  */
        -: 9518:
       15: 9519:  yyerrstatus = 3;		/* Each real token shifted decrements this */
        -: 9520:
       15: 9521:  goto yyerrhandle;
        -: 9522:
       14: 9523:yyerrdefault:  /* current state does not do anything special for the error token. */
        -: 9524:
        -: 9525:#if 0
        -: 9526:  /* This is wrong; only states that explicitly want error tokens
        -: 9527:     should shift them.  */
        -: 9528:  yyn = yydefact[yystate];  /* If its default is to accept any token, ok.  Otherwise pop it.*/
        -: 9529:  if (yyn) goto yydefault;
        -: 9530:#endif
        -: 9531:
       14: 9532:yyerrpop:   /* pop the current state because it cannot handle the error token */
        -: 9533:
      14*: 9534:  if (yyssp == yyss) YYABORT;
branch  0 taken 0 (fallthrough)
branch  1 taken 14
       14: 9535:  yyvsp--;
       14: 9536:  yystate = *--yyssp;
        -: 9537:#ifdef YYLSP_NEEDED
        -: 9538:  yylsp--;
        -: 9539:#endif
        -: 9540:
        -: 9541:#if YYDEBUG != 0
        -: 9542:  if (yydebug)
        -: 9543:    {
        -: 9544:      short *ssp1 = yyss - 1;
        -: 9545:      fprintf (err, "Error: state stack now");
        -: 9546:      while (ssp1 != yyssp)
        -: 9547:	fprintf (err, " %d", *++ssp1);
        -: 9548:      fprintf (err, "\n");
        -: 9549:    }
        -: 9550:#endif
        -: 9551:
       29: 9552:yyerrhandle:
        -: 9553:
       29: 9554:  yyn = yypact[yystate];
       29: 9555:  if (yyn == YYFLAG)
branch  0 taken 0 (fallthrough)
branch  1 taken 29
    #####: 9556:    goto yyerrdefault;
        -: 9557:
       29: 9558:  yyn += YYTERROR;
       29: 9559:  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != YYTERROR)
branch  0 taken 27 (fallthrough)
branch  1 taken 2
branch  2 taken 27 (fallthrough)
branch  3 taken 0
branch  4 taken 12 (fallthrough)
branch  5 taken 15
       14: 9560:    goto yyerrdefault;
        -: 9561:
       15: 9562:  yyn = yytable[yyn];
       15: 9563:  if (yyn < 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 15
        -: 9564:    {
    #####: 9565:      if (yyn == YYFLAG)
branch  0 never executed
branch  1 never executed
    #####: 9566:	goto yyerrpop;
    #####: 9567:      yyn = -yyn;
    #####: 9568:      goto yyreduce;
        -: 9569:    }
       15: 9570:  else if (yyn == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 15
    #####: 9571:    goto yyerrpop;
        -: 9572:
       15: 9573:  if (yyn == YYFINAL)
branch  0 taken 0 (fallthrough)
branch  1 taken 15
    #####: 9574:    YYACCEPT;
        -: 9575:
        -: 9576:#if YYDEBUG != 0
        -: 9577:  if (yydebug)
        -: 9578:    fprintf(err, "Shifting error token, ");
        -: 9579:#endif
        -: 9580:
       15: 9581:  *++yyvsp = yylval;
        -: 9582:#ifdef YYLSP_NEEDED
        -: 9583:  *++yylsp = yylloc;
        -: 9584:#endif
        -: 9585:
       15: 9586:  yystate = yyn;
       15: 9587:  goto yynewstate;
        -: 9588:
      551: 9589: yyacceptlab:
        -: 9590:  /* YYACCEPT comes here.  */
      551: 9591:  if (yyfree_stacks)
branch  0 taken 0 (fallthrough)
branch  1 taken 551
        -: 9592:    {
    #####: 9593:      free (yyss);
    #####: 9594:      free (yyvs);
        -: 9595:#ifdef YYLSP_NEEDED
        -: 9596:      free (yyls);
        -: 9597:#endif
        -: 9598:    }
      551: 9599:  return 0;
        -: 9600:
    #####: 9601: yyabortlab:
        -: 9602:  /* YYABORT comes here.  */
    #####: 9603:  if (yyfree_stacks)
branch  0 never executed
branch  1 never executed
        -: 9604:    {
    #####: 9605:      free (yyss);
    #####: 9606:      free (yyvs);
        -: 9607:#ifdef YYLSP_NEEDED
        -: 9608:      free (yyls);
        -: 9609:#endif
        -: 9610:    }
    #####: 9611:  return 1;
        -: 9612:}
        -: 9613:
        -: 9614:
        -: 9615:
        -: 9616:/* build_eof_action - build the "<<EOF>>" action for the active start
        -: 9617: *                    conditions
        -: 9618: */
        -: 9619:
function build_eof_action called 11 returned 100% blocks executed 100%
       11: 9620:void build_eof_action()
        -: 9621:	{
        -: 9622:	register int i;
        -: 9623:	char action_text[MAXLINE];
        -: 9624:
       33: 9625:	for ( i = 1; i <= actvp; ++i )
branch  0 taken 22
branch  1 taken 11 (fallthrough)
        -: 9626:		{
       22: 9627:		if ( sceof[actvsc[i]] )
branch  0 taken 1 (fallthrough)
branch  1 taken 21
        1: 9628:			format_pinpoint_message(
        -: 9629:				"multiple <<EOF>> rules for start condition %s",
        1: 9630:				scname[actvsc[i]] );
call    0 returned 1
        -: 9631:
        -: 9632:		else
        -: 9633:			{
       21: 9634:			sceof[actvsc[i]] = true;
       21: 9635:			sprintf( action_text, "case YY_STATE_EOF(%s):\n",
       21: 9636:			scname[actvsc[i]] );
       21: 9637:			add_action( action_text );
call    0 returned 21
        -: 9638:			}
        -: 9639:		}
        -: 9640:
       11: 9641:	line_directive_out( (FILE *) 0 );
call    0 returned 11
        -: 9642:
        -: 9643:	/* This isn't a normal rule after all - don't count it as
        -: 9644:	 * such, so we don't have any holes in the rule numbering
        -: 9645:	 * (which make generating "rule can never match" warnings
        -: 9646:	 * more difficult.
        -: 9647:	 */
       11: 9648:	--num_rules;
       11: 9649:	++num_eof_rules;
       11: 9650:	}
        -: 9651:
        -: 9652:
        -: 9653:/* format_synerr - write out formatted syntax error */
        -: 9654:
function format_synerr called 4 returned 100% blocks executed 100%
        4: 9655:void format_synerr( msg, arg )
        -: 9656:char msg[], arg[];
        -: 9657:	{
        -: 9658:	char errmsg[MAXLINE];
        -: 9659:
        4: 9660:	(void) sprintf( errmsg, msg, arg );
        4: 9661:	synerr( errmsg );
call    0 returned 4
        4: 9662:	}
        -: 9663:
        -: 9664:
        -: 9665:/* synerr - report a syntax error */
        -: 9666:
function synerr called 22 returned 100% blocks executed 100%
       22: 9667:void synerr( str )
        -: 9668:char str[];
        -: 9669:	{
       22: 9670:	syntaxerror = true;
       22: 9671:	pinpoint_message( str );
call    0 returned 22
       22: 9672:	}
        -: 9673:
        -: 9674:
        -: 9675:/* warn - report a warning, unless -w was given */
        -: 9676:
function warn called 0 returned 0% blocks executed 0%
    #####: 9677:void warn( str )
        -: 9678:char str[];
        -: 9679:	{
    #####: 9680:	line_warning( str, linenum );
call    0 never executed
    #####: 9681:	}
        -: 9682:
        -: 9683:/* format_pinpoint_message - write out a message formatted with one string,
        -: 9684: *			     pinpointing its location
        -: 9685: */
        -: 9686:
function format_pinpoint_message called 1 returned 100% blocks executed 100%
        1: 9687:void format_pinpoint_message( msg, arg )
        -: 9688:char msg[], arg[];
        -: 9689:	{
        -: 9690:	char errmsg[MAXLINE];
        -: 9691:
        1: 9692:	(void) sprintf( errmsg, msg, arg );
        1: 9693:	pinpoint_message( errmsg );
call    0 returned 1
        1: 9694:	}
        -: 9695:
        -: 9696:
        -: 9697:/* pinpoint_message - write out a message, pinpointing its location */
        -: 9698:
function pinpoint_message called 23 returned 100% blocks executed 100%
       23: 9699:void pinpoint_message( str )
        -: 9700:char str[];
        -: 9701:	{
       23: 9702:	line_pinpoint( str, linenum );
call    0 returned 23
       23: 9703:	}
        -: 9704:
        -: 9705:
        -: 9706:/* line_warning - report a warning at a given line, unless -w was given */
        -: 9707:
function line_warning called 46 returned 100% blocks executed 100%
       46: 9708:void line_warning( str, line )
        -: 9709:char str[];
        -: 9710:int line;
        -: 9711:	{
        -: 9712:	char warning[MAXLINE];
        -: 9713:
       46: 9714:	if ( ! nowarn )
branch  0 taken 45 (fallthrough)
branch  1 taken 1
        -: 9715:		{
       45: 9716:		sprintf( warning, "warning, %s", str );
       45: 9717:		line_pinpoint( warning, line );
call    0 returned 45
        -: 9718:		}
       46: 9719:	}
        -: 9720:
        -: 9721:
        -: 9722:/* line_pinpoint - write out a message, pinpointing it at the given line */
        -: 9723:
function line_pinpoint called 68 returned 100% blocks executed 100%
       68: 9724:void line_pinpoint( str, line )
        -: 9725:char str[];
        -: 9726:int line;
        -: 9727:	{
       68: 9728:	fprintf( err, "\"%s\", line %d: %s\n", infilename, line, str );
call    0 returned 68
       68: 9729:	}
        -: 9730:
        -: 9731:
        -: 9732:/* yyerror - eat up an error message from the parser;
        -: 9733: *	     currently, messages are ignore
        -: 9734: */
        -: 9735:
function yyerror called 5 returned 100% blocks executed 100%
        5: 9736:void yyerror( msg )
        -: 9737:char msg[];
        -: 9738:	{
        5: 9739:	}
        -: 9740:/* A lexical scanner generated by flex */
        -: 9741:
        -: 9742:/* Scanner skeleton version:
        -: 9743: * $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.seeded/v1/flex.c,v 1.1.1.2 2003/09/02 20:21:59 expsir Exp $
        -: 9744: */
        -: 9745:
        -: 9746:#define FLEX_SCANNER
        -: 9747:
        -: 9748:#include <stdio.h>
        -: 9749:
        -: 9750:
        -: 9751:/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
        -: 9752:#ifdef c_plusplus
        -: 9753:#ifndef __cplusplus
        -: 9754:#define __cplusplus
        -: 9755:#endif
        -: 9756:#endif
        -: 9757:
        -: 9758:
        -: 9759:#ifdef __cplusplus
        -: 9760:
        -: 9761:#include <stdlib.h>
        -: 9762:#include <unistd.h>
        -: 9763:
        -: 9764:/* Use prototypes in function declarations. */
        -: 9765:#define YY_USE_PROTOS
        -: 9766:
        -: 9767:/* The "const" storage-class-modifier is valid. */
        -: 9768:#define YY_USE_CONST
        -: 9769:
        -: 9770:#else	/* ! __cplusplus */
        -: 9771:
        -: 9772:#ifdef __STDC__
        -: 9773:
        -: 9774:#define YY_USE_PROTOS
        -: 9775:#define YY_USE_CONST
        -: 9776:
        -: 9777:#endif	/* __STDC__ */
        -: 9778:#endif	/* ! __cplusplus */
        -: 9779:
        -: 9780:
        -: 9781:#ifdef __TURBOC__
        -: 9782:#define YY_USE_CONST
        -: 9783:#endif
        -: 9784:
        -: 9785:
        -: 9786:#ifndef YY_USE_CONST
        -: 9787:#ifndef const
        -: 9788:#define const
        -: 9789:#endif
        -: 9790:#endif
        -: 9791:
        -: 9792:
        -: 9793:#if 0  // Moved to flexdef.h
        -: 9794:#ifdef YY_USE_PROTOS
        -: 9795:#define YY_PROTO(proto) proto
        -: 9796:#else
        -: 9797:#define YY_PROTO(proto) ()
        -: 9798:#endif
        -: 9799:#endif
        -: 9800:
        -: 9801:
        -: 9802:/* Returned upon end-of-file. */
        -: 9803:#define YY_NULL 0
        -: 9804:
        -: 9805:/* Promotes a possibly negative, possibly signed char to an unsigned
        -: 9806: * integer for use as an array index.  If the signed char is negative,
        -: 9807: * we want to instead treat it as an 8-bit unsigned char, hence the
        -: 9808: * double cast.
        -: 9809: */
        -: 9810:#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
        -: 9811:
        -: 9812:/* Enter a start condition.  This macro really ought to take a parameter,
        -: 9813: * but we do it the disgusting crufty way forced on us by the ()-less
        -: 9814: * definition of BEGIN.
        -: 9815: */
        -: 9816:#define BEGIN yy_start = 1 + 2 *
        -: 9817:
        -: 9818:/* Translate the current start state into a value that can be later handed
        -: 9819: * to BEGIN to return to the state.
        -: 9820: */
        -: 9821:#define YY_START ((yy_start - 1) / 2)
        -: 9822:
        -: 9823:/* Action number for EOF rule of a given start state. */
        -: 9824:#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
        -: 9825:
        -: 9826:/* Special action meaning "start processing a new file".  Now included
        -: 9827: * only for backward compatibility with previous versions of flex.
        -: 9828: */
        -: 9829:#define YY_NEW_FILE yyrestart( yyin )
        -: 9830:
        -: 9831:#define YY_END_OF_BUFFER_CHAR 0
        -: 9832:
        -: 9833:/* Size of default input buffer. */
        -: 9834:#define YY_BUF_SIZE 16384
        -: 9835:
        -: 9836:typedef struct yy_buffer_state *YY_BUFFER_STATE;
        -: 9837:
        -: 9838:extern int yyleng;
        -: 9839:extern FILE *yyin, *yyout;
        -: 9840:
        -: 9841:#ifdef __cplusplus
        -: 9842:extern "C" {
        -: 9843:#endif
        -: 9844:	extern int yywrap YY_PROTO(( void ));
        -: 9845:#ifdef __cplusplus
        -: 9846:	}
        -: 9847:#endif
        -: 9848:
        -: 9849:#define EOB_ACT_CONTINUE_SCAN 0
        -: 9850:#define EOB_ACT_END_OF_FILE 1
        -: 9851:#define EOB_ACT_LAST_MATCH 2
        -: 9852:
        -: 9853:/* The funky do-while in the following #define is used to turn the definition
        -: 9854: * int a single C statement (which needs a semi-colon terminator).  This
        -: 9855: * avoids problems with code like:
        -: 9856: *
        -: 9857: * 	if ( condition_holds )
        -: 9858: *		yyless( 5 );
        -: 9859: *	else
        -: 9860: *		do_something_else();
        -: 9861: *
        -: 9862: * Prior to using the do-while the compiler would get upset at the
        -: 9863: * "else" because it interpreted the "if" statement as being all
        -: 9864: * done when it reached the ';' after the yyless() call.
        -: 9865: */
        -: 9866:
        -: 9867:/* Return all but the first 'n' matched characters back to the input stream. */
        -: 9868:
        -: 9869:#define yyless(n) \
        -: 9870:	do \
        -: 9871:		{ \
        -: 9872:		/* Undo effects of setting up yytext. */ \
        -: 9873:		*yy_cp = yy_hold_char; \
        -: 9874:		yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \
        -: 9875:		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
        -: 9876:		} \
        -: 9877:	while ( 0 )
        -: 9878:
        -: 9879:#define unput(c) yyunput( c, yytext_ptr )
        -: 9880:
        -: 9881:
        -: 9882:struct yy_buffer_state
        -: 9883:	{
        -: 9884:	FILE *yy_input_file;
        -: 9885:
        -: 9886:	char *yy_ch_buf;		/* input buffer */
        -: 9887:	char *yy_buf_pos;		/* current position in input buffer */
        -: 9888:
        -: 9889:	/* Size of input buffer in bytes, not including room for EOB
        -: 9890:	 * characters.
        -: 9891:	 */
        -: 9892:	int yy_buf_size;
        -: 9893:
        -: 9894:	/* Number of characters read into yy_ch_buf, not including EOB
        -: 9895:	 * characters.
        -: 9896:	 */
        -: 9897:	int yy_n_chars;
        -: 9898:
        -: 9899:	/* Whether this is an "interactive" input source; if so, and
        -: 9900:	 * if we're using stdio for input, then we want to use getc()
        -: 9901:	 * instead of fread(), to make sure we stop fetching input after
        -: 9902:	 * each newline.
        -: 9903:	 */
        -: 9904:	int yy_is_interactive;
        -: 9905:
        -: 9906:	/* Whether to try to fill the input buffer when we reach the
        -: 9907:	 * end of it.
        -: 9908:	 */
        -: 9909:	int yy_fill_buffer;
        -: 9910:
        -: 9911:	int yy_buffer_status;
        -: 9912:#define YY_BUFFER_NEW 0
        -: 9913:#define YY_BUFFER_NORMAL 1
        -: 9914:	/* When an EOF's been seen but there's still some text to process
        -: 9915:	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
        -: 9916:	 * shouldn't try reading from the input source any more.  We might
        -: 9917:	 * still have a bunch of tokens to match, though, because of
        -: 9918:	 * possible backing-up.
        -: 9919:	 *
        -: 9920:	 * When we actually see the EOF, we change the status to "new"
        -: 9921:	 * (via yyrestart()), so that the user can continue scanning by
        -: 9922:	 * just pointing yyin at a new input file.
        -: 9923:	 */
        -: 9924:#ifndef	F_HD_8
        -: 9925:#define YY_BUFFER_EOF_PENDING 2 
        -: 9926:#else
        -: 9927:#define YY_BUFFER_EOF_PENDING 1 
        -: 9928:#endif
        -: 9929:	};
        -: 9930:
        -: 9931:static YY_BUFFER_STATE yy_current_buffer = 0;
        -: 9932:
        -: 9933:/* We provide macros for accessing buffer states in case in the
        -: 9934: * future we want to put the buffer states in a more general
        -: 9935: * "scanner state".
        -: 9936: */
        -: 9937:#define YY_CURRENT_BUFFER yy_current_buffer
        -: 9938:
        -: 9939:
        -: 9940:/* yy_hold_char holds the character lost when yytext is formed. */
        -: 9941:static char yy_hold_char;
        -: 9942:
        -: 9943:static int yy_n_chars;		/* number of characters read into yy_ch_buf */
        -: 9944:
        -: 9945:
        -: 9946:int yyleng;
        -: 9947:
        -: 9948:/* Points to current character in buffer. */
        -: 9949:static char *yy_c_buf_p = (char *) 0;
        -: 9950:static int yy_init = 1;		/* whether we need to initialize */
        -: 9951:static int yy_start = 0;	/* start state number */
        -: 9952:
        -: 9953:/* Flag which is used to allow yywrap()'s to do buffer switches
        -: 9954: * instead of setting up a fresh yyin.  A bit of a hack ...
        -: 9955: */
        -: 9956:static int yy_did_buffer_switch_on_eof;
        -: 9957:
        -: 9958:static void yyunput YY_PROTO(( int c, char *buf_ptr ));
        -: 9959:void yyrestart YY_PROTO(( FILE *input_file ));
        -: 9960:void yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));
        -: 9961:void yy_load_buffer_state YY_PROTO(( void ));
        -: 9962:YY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *file, int size ));
        -: 9963:void yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));
        -: 9964:void yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));
        -: 9965:
        -: 9966:static int yy_start_stack_ptr = 0;
        -: 9967:static int yy_start_stack_depth = 0;
        -: 9968:static int *yy_start_stack = 0;
        -: 9969:static void yy_push_state YY_PROTO(( int new_state ));
        -: 9970:static void yy_pop_state YY_PROTO(( void ));
        -: 9971:static int yy_top_state YY_PROTO(( void ));
        -: 9972:
        -: 9973://static void *yy_flex_alloc YY_PROTO(( unsigned int ));
        -: 9974:static void *yy_flex_realloc YY_PROTO(( void *, unsigned int ));
        -: 9975:static void yy_flex_free YY_PROTO(( void * ));
        -: 9976:
        -: 9977:#define yy_new_buffer yy_create_buffer
        -: 9978:
        -: 9979:#define INITIAL 0
        -: 9980:#define SECT2 1
        -: 9981:#define SECT2PROLOG 2
        -: 9982:#define SECT3 3
        -: 9983:#define CODEBLOCK 4
        -: 9984:#define PICKUPDEF 5
        -: 9985:#define SC 6
        -: 9986:#define CARETISBOL 7
        -: 9987:#define NUM 8
        -: 9988:#define QUOTE 9
        -: 9989:#define FIRSTCCL 10
        -: 9990:#define CCL 11
        -: 9991:#define ACTION 12
        -: 9992:#define RECOVER 13
        -: 9993:#define BRACEERROR 14
        -: 9994:#define C_COMMENT 15
        -: 9995:#define ACTION_COMMENT 16
        -: 9996:#define ACTION_STRING 17
        -: 9997:#define PERCENT_BRACE_ACTION 18
        -: 9998:#define USED_LIST 19
        -: 9999:#define CODEBLOCK_2 20
        -:10000:typedef unsigned char YY_CHAR;
        -:10001:typedef int yy_state_type;
        -:10002:FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
        -:10003:extern char *yytext;
        -:10004:#define yytext_ptr yytext
        -:10005:
        -:10006:#ifndef yytext_ptr
        -:10007:static void yy_flex_strncpy YY_PROTO(( char *, const char *, int ));
        -:10008:#endif
        -:10009:
        -:10010:#ifdef __cplusplus
        -:10011:static int yyinput YY_PROTO(( void ));
        -:10012:#else
        -:10013:static int input YY_PROTO(( void ));
        -:10014:#endif
        -:10015:
        -:10016:static yy_state_type yy_get_previous_state YY_PROTO(( void ));
        -:10017:static yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));
        -:10018:static int yy_get_next_buffer YY_PROTO(( void ));
        -:10019:static void yy_fatal_error YY_PROTO(( const char msg[] ));
        -:10020:
        -:10021:/* Done after the current pattern has been matched and before the
        -:10022: * corresponding action - sets up yytext.
        -:10023: */
        -:10024:#define YY_DO_BEFORE_ACTION \
        -:10025:	yytext_ptr = yy_bp; \
        -:10026:	yyleng = yy_cp - yy_bp; \
        -:10027:	yy_hold_char = *yy_cp; \
        -:10028:	*yy_cp = '\0'; \
        -:10029:	yy_c_buf_p = yy_cp;
        -:10030:
        -:10031:#define YY_END_OF_BUFFER 113
        -:10032:static const short int yy_accept[408] =
        -:10033:    {   0,
        -:10034:        0,    0,    0,    0,   41,   41,  110,  110,    0,    0,
        -:10035:        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        -:10036:        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        -:10037:        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        -:10038:        0,    0,  113,  111,    6,   17,  111,   15,    1,   16,
        -:10039:      111,  111,  111,   14,   60,   53,   54,   60,   47,   60,
        -:10040:       59,   60,   60,   60,   60,   44,   43,   60,   60,   45,
        -:10041:       46,   41,   42,   41,   40,   39,   40,   40,  110,  110,
        -:10042:       26,   27,   26,   26,   26,   26,   26,   26,   29,   28,
        -:10043:       30,   29,   65,   61,   62,   64,   66,   80,   81,   80,
        -:10044:
        -:10045:       78,   77,   79,   67,   69,   67,   68,   67,   72,   72,
        -:10046:       72,   74,   76,   74,   74,   74,   75,   92,   97,   92,
        -:10047:       96,   98,   98,   93,   93,   93,   90,   91,  111,   31,
        -:10048:      111,   83,  111,   82,   20,   22,   20,   21,  101,  102,
        -:10049:      101,  100,  103,  105,  103,  106,  107,   88,   88,   89,
        -:10050:       88,   88,   88,   88,   88,   88,   36,   33,   32,   36,
        -:10051:       36,   36,   88,    6,   17,    0,   17,   15,    1,   16,
        -:10052:        0,   16,   13,    7,    0,    0,    0,    3,    0,    4,
        -:10053:        0,    2,   14,   53,   54,    0,    0,    0,   54,   50,
        -:10054:       50,    0,    0,   57,    0,  108,  108,  108,   49,   48,
        -:10055:
        -:10056:       49,   44,   43,    0,   43,   56,   44,   41,   42,   40,
        -:10057:       39,   39,   37,   38,  110,  110,   26,   27,   26,   26,
        -:10058:       26,   26,   29,   28,   30,   63,   64,   81,   77,   69,
        -:10059:      109,  109,  109,   70,   71,   76,   73,   92,   97,    0,
        -:10060:       95,    0,   94,   93,   93,   93,    0,   31,    0,   31,
        -:10061:       31,   83,   20,   22,   18,  101,  102,  101,  102,  102,
        -:10062:       99,  103,  105,  104,   88,   88,   88,   89,   85,   88,
        -:10063:       88,   88,   36,   33,   32,   36,   36,   84,   13,    7,
        -:10064:        0,   12,    0,    0,    0,    0,    3,    0,    0,    4,
        -:10065:        0,    5,    0,   51,    0,   52,    0,    0,   57,    0,
        -:10066:
        -:10067:       57,   57,  108,  108,   49,   49,   58,   56,   37,   38,
        -:10068:       26,   26,   26,   23,   26,    0,  109,  109,   93,   93,
        -:10069:        0,   19,    0,   85,   85,   88,   88,   36,   36,   12,
        -:10070:        0,    0,    0,    3,    0,    0,    4,    5,    5,   52,
        -:10071:       52,    0,   57,   57,   57,   57,  108,   26,   26,   23,
        -:10072:       23,    0,  109,   93,   93,   19,   19,   88,   88,   36,
        -:10073:       36,    0,    0,    0,   10,    0,   57,   57,   57,   57,
        -:10074:       26,   26,   93,   93,   88,   88,   36,   36,    0,    0,
        -:10075:        0,    0,   57,   57,   24,   25,   86,   87,   86,   87,
        -:10076:       34,   35,    0,    9,    0,    0,   11,   55,    9,    9,
        -:10077:
        -:10078:        0,    0,    8,    0,    8,    8,    0
        -:10079:    } ;
        -:10080:
        -:10081:static const int yy_ec[256] =
        -:10082:    {   0,
        -:10083:        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
        -:10084:        1,    1,    4,    1,    1,    1,    1,    1,    1,    1,
        -:10085:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:10086:        1,    2,    1,    5,    1,    6,    7,    1,    8,    9,
        -:10087:        9,   10,    9,   11,   12,    9,   13,   14,   14,   14,
        -:10088:       14,   14,   14,   14,   14,   14,   14,    1,    1,   15,
        -:10089:        1,   16,    9,    1,   22,   23,   24,   25,   26,   27,
        -:10090:       21,   21,   28,   29,   30,   21,   31,   32,   33,   34,
        -:10091:       21,   35,   36,   37,   38,   21,   21,   39,   40,   21,
        -:10092:       17,   18,   19,   20,   21,    1,   22,   23,   24,   25,
        -:10093:
        -:10094:       26,   27,   21,   21,   28,   29,   30,   21,   31,   32,
        -:10095:       33,   34,   21,   35,   36,   37,   38,   21,   21,   39,
        -:10096:       40,   21,   41,   42,   43,    1,    1,    1,    1,    1,
        -:10097:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:10098:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:10099:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:10100:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:10101:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:10102:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:10103:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:10104:
        -:10105:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:10106:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:10107:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:10108:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:10109:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:10110:        1,    1,    1,    1,    1
        -:10111:    } ;
        -:10112:
        -:10113:static const int yy_meta[44] =
        -:10114:    {   0,
        -:10115:        1,    2,    3,    1,    4,    1,    1,    5,    1,    6,
        -:10116:        1,    7,    5,    8,    1,    1,    1,    9,   10,    1,
        -:10117:       11,   12,   12,   12,   12,   12,   12,   11,   11,   11,
        -:10118:       11,   11,   11,   11,   11,   11,   13,   11,   11,   11,
        -:10119:        5,    1,   14
        -:10120:    } ;
        -:10121:
        -:10122:static const short int yy_base[470] =
        -:10123:    {   0,
        -:10124:        0,   43,   85,  126,   89,  102, 1611, 1610,  168, 1605,
        -:10125:      108,  111,  211,    0, 1591, 1590,  252,  254,  116,  119,
        -:10126:       98,  122,  144,  146,  297,    0,   93,  104,  338,  340,
        -:10127:      149,  151,  257,  266,  268,  274,  383,    0,  425,  428,
        -:10128:     1596, 1595, 1607, 1615,  278, 1602, 1602,    0,  281, 1600,
        -:10129:     1600,  462, 1592,    0, 1615,  431, 1597, 1597, 1615,  285,
        -:10130:     1615, 1584, 1580,  331,  503,  437, 1593, 1593,  110, 1580,
        -:10131:     1615,    0, 1590, 1590,    0, 1590, 1588,  221, 1587, 1615,
        -:10132:        0, 1585, 1585, 1615,    0, 1561, 1546, 1511,    0, 1551,
        -:10133:     1543, 1543, 1615, 1615, 1498,    0, 1615, 1615, 1500, 1487,
        -:10134:
        -:10135:     1615, 1463, 1615, 1615, 1466, 1460, 1615,  332, 1615,  333,
        -:10136:      126, 1615, 1411, 1398,    0,  334, 1615,    0, 1383, 1383,
        -:10137:     1615,  341, 1371,    0, 1354, 1336, 1615, 1615,  271, 1371,
        -:10138:      287, 1370, 1366, 1615,    0, 1362, 1349, 1331,  290, 1335,
        -:10139:      347, 1325,    0, 1323, 1310, 1615,    0,    0,  350, 1306,
        -:10140:     1287, 1246, 1615,    0, 1249, 1227,    0, 1264, 1261, 1255,
        -:10141:     1225, 1197, 1213,  351, 1213, 1213, 1615,    0,  358, 1198,
        -:10142:     1193, 1615,    0,    0,  443,  361,  447,    0,  342,    0,
        -:10143:      363, 1615,    0,  451, 1191, 1188, 1149,  365, 1615, 1615,
        -:10144:     1185, 1181, 1155, 1135,  423, 1615, 1125,    0,    0, 1615,
        -:10145:
        -:10146:      546,  588, 1121, 1108, 1615,    0, 1615,    0, 1615,    0,
        -:10147:        0, 1095,    0,    0, 1088, 1615,    0, 1615,    0, 1061,
        -:10148:     1041,  630,    0, 1069, 1615, 1615,    0, 1615,  838, 1615,
        -:10149:     1615,  837,    0, 1615, 1615, 1615, 1615,    0, 1615,  434,
        -:10150:     1615,    0, 1615,    0,  821,  817,  373,  843,  376, 1615,
        -:10151:      842, 1615,    0, 1615,  463,  467,  834,  471, 1615,  833,
        -:10152:     1615,    0, 1615, 1615,    0,  441,  793, 1615,  673,    0,
        -:10153:      805,  802,    0,  830, 1615,  795,  792, 1615,    0,    0,
        -:10154:      594,  818,  817,  597,  784,  790,    0,  775,  786,    0,
        -:10155:      473,  807,  478, 1615,  486,  806,  590,  776,  790,  588,
        -:10156:
        -:10157:      469,  703,  793,    0,    0,    0, 1615,    0,    0,    0,
        -:10158:      780,  772,    0,  800,  800,  730,  788,    0,  775,  767,
        -:10159:      600,  795,  602,    0,  773,  772,  764,  770,  762, 1615,
        -:10160:      610,  772,  751,    0,  740,  745,    0, 1615,  765, 1615,
        -:10161:      764,  740,  488,  803,  601,  817, 1615,  742,  730, 1615,
        -:10162:      760,  760, 1615,  738,  726, 1615,  756,  735,  723,  733,
        -:10163:      721,  714,  716,  726, 1615,  724,  602,  831,  715,  658,
        -:10164:      512,  473,  454,  459,  435,  438,  422,  430,  606,  410,
        -:10165:      357,  342,  338,  278,    0,    0,    0,    0,    0,    0,
        -:10166:        0,    0,  614,  255,  618,  131, 1615, 1615, 1615,  156,
        -:10167:
        -:10168:      620,  622,  153,  625, 1615,   95, 1615,  858,  872,  886,
        -:10169:      900,  914,  928,  942,  956,  970,  984,  998, 1012, 1026,
        -:10170:     1040, 1054, 1062, 1075, 1081, 1094, 1108, 1122, 1136, 1150,
        -:10171:     1164, 1178, 1186, 1199, 1207, 1220, 1234, 1248, 1262, 1272,
        -:10172:     1280, 1293, 1307, 1321, 1335, 1349, 1363, 1371, 1384, 1398,
        -:10173:     1412, 1416, 1419, 1432, 1446, 1460,  710, 1474, 1487, 1501,
        -:10174:     1515,  711, 1529, 1537, 1544,  712,  743, 1557, 1571
        -:10175:    } ;
        -:10176:
        -:10177:static const short int yy_def[470] =
        -:10178:    {   0,
        -:10179:      407,  407,  408,  408,  409,  410,  411,  411,  407,    9,
        -:10180:      412,  412,  407,   13,  413,  413,  414,  414,  415,  415,
        -:10181:      416,  416,  417,  417,  407,   25,  418,  418,  413,  413,
        -:10182:      419,  419,  420,  420,  421,  421,  407,   37,  422,  422,
        -:10183:       37,   37,  407,  407,  407,  407,  407,  423,  407,  407,
        -:10184:      407,  424,  407,  425,  407,  407,  407,  407,  407,  407,
        -:10185:      407,  407,  426,  427,  407,  407,  407,  407,  407,  407,
        -:10186:      407,  428,  407,  428,  429,  430,  429,  429,  431,  407,
        -:10187:      432,  407,  432,  407,  433,  433,  433,  432,  434,  407,
        -:10188:      407,  434,  407,  407,  407,  435,  407,  407,  407,  407,
        -:10189:
        -:10190:      407,  407,  407,  407,  407,  407,  407,  427,  407,  436,
        -:10191:      437,  407,  407,  407,  438,  427,  407,  439,  407,  439,
        -:10192:      407,  440,  407,  441,  441,  441,  407,  407,  442,  407,
        -:10193:      442,  407,  407,  407,  443,  407,  443,  407,  444,  407,
        -:10194:      444,  407,  445,  407,  445,  407,  446,  447,  447,  407,
        -:10195:      447,  447,  407,  448,  448,  448,  449,  407,  407,  449,
        -:10196:      449,  449,  447,  407,  407,  407,  407,  423,  407,  407,
        -:10197:      407,  407,  450,  451,  407,  407,  407,  452,  407,  453,
        -:10198:      454,  407,  425,  407,  407,  407,  407,  455,  407,  407,
        -:10199:      407,  407,  407,  456,  426,  407,  407,  457,  458,  407,
        -:10200:
        -:10201:      407,  407,  407,  407,  407,  459,  407,  428,  407,  429,
        -:10202:      430,  430,  460,  461,  431,  407,  432,  407,  433,  433,
        -:10203:      433,  407,  434,  407,  407,  407,  435,  407,  407,  407,
        -:10204:      407,  407,  462,  407,  407,  407,  407,  439,  407,  440,
        -:10205:      407,  440,  407,  441,  441,  441,  442,  407,  442,  407,
        -:10206:      407,  407,  443,  407,  463,  444,  407,  444,  407,  407,
        -:10207:      407,  445,  407,  407,  447,  447,  447,  407,  407,  448,
        -:10208:      448,  448,  449,  407,  407,  449,  449,  407,  450,  451,
        -:10209:      407,  407,  407,  407,  407,  407,  464,  407,  407,  465,
        -:10210:      454,  407,  454,  407,  455,  407,  455,  407,  456,  456,
        -:10211:
        -:10212:      456,  456,  407,  466,  458,  201,  407,  459,  460,  461,
        -:10213:      433,  433,  222,  407,  222,  222,  407,  467,  441,  441,
        -:10214:      463,  407,  463,  269,  269,  448,  448,  449,  449,  407,
        -:10215:      407,  407,  407,  464,  407,  407,  465,  407,  407,  407,
        -:10216:      407,  407,  456,  456,  456,  456,  407,  433,  433,  407,
        -:10217:      407,  316,  407,  441,  441,  407,  407,  448,  448,  449,
        -:10218:      449,  407,  407,  407,  407,  407,  456,  456,  456,  456,
        -:10219:      433,  433,  441,  441,  448,  448,  449,  449,  468,  407,
        -:10220:      407,  407,  456,  456,  433,  433,  441,  441,  448,  448,
        -:10221:      449,  449,  468,  407,  468,  407,  407,  407,  407,  407,
        -:10222:
        -:10223:      469,  469,  407,  469,  407,  407,    0,  407,  407,  407,
        -:10224:      407,  407,  407,  407,  407,  407,  407,  407,  407,  407,
        -:10225:      407,  407,  407,  407,  407,  407,  407,  407,  407,  407,
        -:10226:      407,  407,  407,  407,  407,  407,  407,  407,  407,  407,
        -:10227:      407,  407,  407,  407,  407,  407,  407,  407,  407,  407,
        -:10228:      407,  407,  407,  407,  407,  407,  407,  407,  407,  407,
        -:10229:      407,  407,  407,  407,  407,  407,  407,  407,  407
        -:10230:    } ;
        -:10231:
        -:10232:static const short int yy_nxt[1659] =
        -:10233:    {   0,
        -:10234:       44,   45,   46,   47,   44,   44,   44,   44,   44,   44,
        -:10235:       44,   44,   44,   44,   44,   44,   44,   44,   44,   44,
        -:10236:       48,   48,   48,   48,   48,   48,   48,   48,   48,   48,
        -:10237:       48,   48,   48,   48,   48,   48,   48,   48,   48,   48,
        -:10238:       44,   44,   44,   44,   49,   50,   51,   44,   44,   52,
        -:10239:       44,   44,   44,   44,   44,   53,   44,   44,   44,   44,
        -:10240:       44,   44,   44,   54,   54,   54,   54,   54,   54,   54,
        -:10241:       54,   54,   54,   54,   54,   54,   54,   54,   54,   54,
        -:10242:       54,   54,   54,   44,   44,   44,   56,   57,   58,   59,
        -:10243:       60,   73,   74,   61,   61,  130,  131,   61,  405,   62,
        -:10244:
        -:10245:       44,   63,   64,   76,   73,   77,  130,  131,   78,   90,
        -:10246:       91,   92,   90,   91,   92,  110,  206,  111,  105,  106,
        -:10247:      107,  105,  106,  107,   44,   65,   61,   66,   67,   68,
        -:10248:       59,   60,   69,  108,   61,   61,  108,  235,   61,  110,
        -:10249:       70,  111,   63,   64,  235,   71,  113,  114,  113,  114,
        -:10250:      207,  136,  137,  136,  137,  115,  405,  115,  138,  399,
        -:10251:      138,  116,  117,  116,  117,  401,   65,   61,   81,   81,
        -:10252:       82,   83,   81,   81,   81,   81,   81,   84,   81,   81,
        -:10253:       81,   81,   81,   81,   81,   81,   81,   81,   85,   85,
        -:10254:       85,   85,   85,   85,   85,   85,   85,   85,   85,   85,
        -:10255:
        -:10256:       85,   85,   86,   85,   85,   85,   85,   87,   81,   81,
        -:10257:       81,   93,   93,   44,   93,   93,   93,   93,   93,   93,
        -:10258:       94,   94,   93,   93,   93,   93,   95,   93,   93,   93,
        -:10259:       93,   96,   96,   96,   96,   96,   96,   96,   96,   96,
        -:10260:       96,   96,   96,   96,   96,   96,   96,   96,   96,   96,
        -:10261:       96,   93,   93,   93,   99,  100,   99,  100,  399,  140,
        -:10262:      141,  213,  101,  214,  101,  102,  142,  102,  140,  141,
        -:10263:      144,  145,  146,  248,  249,  142,  144,  145,  146,  164,
        -:10264:      165,  166,  169,  170,  171,  147,  190,  191,  192,  251,
        -:10265:      249,  147,  257,  258,  103,  300,  103,  118,  118,  119,
        -:10266:
        -:10267:      120,  121,  118,  118,  122,  118,  118,  118,  118,  123,
        -:10268:      118,  118,  118,  118,  118,  118,  118,  124,  124,  124,
        -:10269:      124,  124,  124,  124,  124,  124,  124,  124,  124,  124,
        -:10270:      124,  125,  124,  124,  124,  124,  126,  127,  118,  128,
        -:10271:      132,  133,  132,  133,  197,  197,  232,  197,  241,  260,
        -:10272:      258,  266,  164,  165,  166,  300,  267,  398,  242,  169,
        -:10273:      170,  171,  281,  282,  283,  292,  293,  296,  297,  198,
        -:10274:      198,  233,  198,  288,  284,  248,  249,  289,  251,  249,
        -:10275:      134,  397,  134,  148,  149,  150,  151,  148,  148,  152,
        -:10276:      148,  148,  153,  148,  148,  148,  148,  148,  148,  148,
        -:10277:
        -:10278:      148,  148,  148,  154,  154,  154,  154,  154,  154,  154,
        -:10279:      154,  154,  154,  154,  154,  154,  154,  155,  154,  154,
        -:10280:      154,  154,  156,  148,  148,  148,  158,  159,  160,  158,
        -:10281:      159,  160,  184,  185,  186,  396,  301,  187,  202,  203,
        -:10282:      204,  241,  266,  187,  281,  282,  283,  267,  281,  282,
        -:10283:      283,  242,  184,  185,  186,  392,  284,  187,  391,  161,
        -:10284:      284,  302,  161,  390,  162,  322,  323,  162,  174,  257,
        -:10285:      258,  389,  188,  260,  258,  292,  293,  285,  188,  286,
        -:10286:      339,  293,  345,  175,  388,  176,  300,  176,  296,  297,
        -:10287:      387,  176,  188,  176,  176,  177,  176,  178,  386,  179,
        -:10288:
        -:10289:      180,  367,  181,  199,  199,  300,  199,  199,  199,  199,
        -:10290:      199,  199,  199,  199,  199,  199,  200,  199,  199,  199,
        -:10291:      199,  199,  199,  201,  201,  201,  201,  201,  201,  201,
        -:10292:      201,  201,  201,  201,  201,  201,  201,  201,  201,  201,
        -:10293:      201,  201,  201,  199,  199,  199,  305,  305,  385,  305,
        -:10294:      305,  305,  305,  305,  305,  305,  305,  306,  305,  306,
        -:10295:      305,  305,  305,  305,  305,  305,  306,  306,  306,  306,
        -:10296:      306,  306,  306,  306,  306,  306,  306,  306,  306,  306,
        -:10297:      306,  306,  306,  306,  306,  306,  305,  305,  307,  202,
        -:10298:      203,  204,  341,  297,  187,  281,  282,  283,  331,  282,
        -:10299:
        -:10300:      283,  343,  322,  323,  357,  323,  299,  284,  394,  395,
        -:10301:      284,  331,  282,  283,  369,  383,  394,  395,  300,  300,
        -:10302:      400,  395,  403,  404,  403,  404,  344,  406,  404,  188,
        -:10303:      313,  313,  314,  315,  313,  313,  313,  313,  313,  316,
        -:10304:      313,  313,  313,  313,  313,  313,  313,  313,  313,  313,
        -:10305:      316,  316,  316,  316,  316,  316,  316,  316,  316,  316,
        -:10306:      316,  316,  316,  316,  316,  316,  316,  316,  316,  316,
        -:10307:      313,  313,  313,  324,  324,  300,  324,  324,  324,  324,
        -:10308:      324,  324,  325,  324,  324,  324,  324,  324,  324,  324,
        -:10309:      324,  324,  324,  325,  325,  325,  325,  325,  325,  325,
        -:10310:
        -:10311:      325,  325,  325,  325,  325,  325,  325,  325,  325,  325,
        -:10312:      325,  325,  325,  324,  324,  324,  346,  304,  318,  347,
        -:10313:      300,  304,  318,  347,  346,  346,  346,  346,  346,  346,
        -:10314:      316,  316,  300,  352,  316,  316,  316,  316,  316,  382,
        -:10315:      316,  316,  316,  316,  316,  316,  316,  316,  316,  316,
        -:10316:      353,  381,  380,  379,  353,  378,  377,  376,  375,  356,
        -:10317:      374,  373,  351,  350,  372,  371,  366,  340,  338,  365,
        -:10318:      316,  316,  316,  325,  325,  364,  325,  325,  325,  325,
        -:10319:      325,  325,  363,  325,  325,  325,  325,  325,  325,  325,
        -:10320:      325,  325,  325,  362,  361,  360,  359,  358,  356,  355,
        -:10321:
        -:10322:      354,  231,  351,  350,  349,  348,  196,  300,  342,  340,
        -:10323:      338,  336,  335,  325,  325,  325,  368,  333,  332,  330,
        -:10324:      300,  330,  329,  328,  368,  368,  368,  368,  368,  368,
        -:10325:      370,  274,  327,  326,  300,  269,  259,  259,  370,  370,
        -:10326:      370,  370,  370,  370,  384,  250,  250,  320,  300,  319,
        -:10327:      317,  229,  384,  384,  384,  384,  384,  384,   55,   55,
        -:10328:       55,   55,   55,   55,   55,   55,   55,   55,   55,   55,
        -:10329:       55,   55,   72,   72,   72,   72,   72,   72,   72,   72,
        -:10330:       72,   72,   72,   72,   72,   72,   75,   75,   75,   75,
        -:10331:       75,   75,   75,   75,   75,   75,   75,   75,   75,   75,
        -:10332:
        -:10333:       79,   79,   79,   79,   79,   79,   79,   79,   79,   79,
        -:10334:       79,   79,   79,   79,   89,   89,   89,   89,   89,   89,
        -:10335:       89,   89,   89,   89,   89,   89,   89,   89,   44,   44,
        -:10336:       44,   44,   44,   44,   44,   44,   44,   44,   44,   44,
        -:10337:       44,   44,   98,   98,   98,   98,   98,   98,   98,   98,
        -:10338:       98,   98,   98,   98,   98,   98,  104,  104,  104,  104,
        -:10339:      104,  104,  104,  104,  104,  104,  104,  104,  104,  104,
        -:10340:      109,  109,  109,  109,  109,  109,  109,  109,  109,  109,
        -:10341:      109,  109,  109,  109,  112,  112,  112,  112,  112,  112,
        -:10342:      112,  112,  112,  112,  112,  112,  112,  112,  129,  129,
        -:10343:
        -:10344:      129,  129,  129,  129,  129,  129,  129,  129,  129,  129,
        -:10345:      129,  129,  135,  135,  135,  135,  135,  135,  135,  135,
        -:10346:      135,  135,  135,  135,  135,  135,  139,  139,  139,  139,
        -:10347:      139,  139,  139,  139,  139,  139,  139,  139,  139,  139,
        -:10348:      143,  143,  143,  143,  143,  143,  143,  143,  143,  143,
        -:10349:      143,  143,  143,  143,  157,  157,  157,  157,  157,  157,
        -:10350:      157,  157,  157,  157,  157,  157,  157,  157,  168,  168,
        -:10351:      224,  312,  168,  168,  168,  173,  173,  173,  173,  173,
        -:10352:      173,  173,  173,  173,  173,  173,  173,  183,  183,  311,
        -:10353:      216,  183,  183,  183,  194,  194,  212,  194,  194,  194,
        -:10354:
        -:10355:      194,  194,  194,  194,  194,  194,  194,  194,  196,  196,
        -:10356:      205,  196,  196,  196,  196,  196,  196,  196,  196,  196,
        -:10357:      196,  196,  208,  208,  205,  208,  208,  208,  208,  208,
        -:10358:      208,  208,  208,  208,  208,  208,  210,  210,  303,  210,
        -:10359:      210,  210,  210,  210,  210,  210,  210,  210,  210,  210,
        -:10360:      211,  211,  300,  211,  211,  211,  211,  211,  211,  211,
        -:10361:      211,  211,  211,  211,  215,  215,  215,  215,  215,  215,
        -:10362:      215,  215,  215,  215,  215,  215,  215,  215,  217,  217,
        -:10363:      298,  217,  217,  190,  217,  217,  217,  217,  190,  294,
        -:10364:      189,  217,  219,  219,  189,  172,  219,  219,  219,  223,
        -:10365:
        -:10366:      223,  172,  223,  223,  223,  223,  223,  223,  223,  223,
        -:10367:      223,  223,  223,  227,  227,  167,  167,  227,  227,  227,
        -:10368:      231,  231,  278,  231,  231,  231,  231,  231,  231,  231,
        -:10369:      231,  231,  231,  231,  234,  234,  277,  234,  234,  234,
        -:10370:      234,  234,  234,  234,  234,  234,  234,  234,  237,  237,
        -:10371:      276,  237,  237,  237,  237,  237,  237,  275,  237,  237,
        -:10372:      237,  237,  238,  238,  275,  274,  272,  238,  238,  238,
        -:10373:      238,  238,  240,  240,  271,  240,  240,  240,  240,  240,
        -:10374:      240,  240,  240,  240,  240,  240,  244,  244,  269,  268,
        -:10375:      244,  244,  244,  247,  247,  247,  247,  247,  247,  247,
        -:10376:
        -:10377:      247,  247,  247,  247,  247,  247,  247,  253,  253,  268,
        -:10378:      253,  253,  263,  253,  253,  253,  253,  253,  253,  253,
        -:10379:      253,  256,  256,  256,  256,  256,  263,  256,  256,  256,
        -:10380:      256,  256,  256,  256,  256,  262,  262,  261,  259,  262,
        -:10381:      262,  262,  262,  255,  262,  262,  262,  262,  262,  264,
        -:10382:      264,  254,  264,  264,  264,  264,  264,  264,  264,  264,
        -:10383:      264,  264,  264,  265,  265,  254,  265,  265,  252,  265,
        -:10384:      265,  265,  265,  252,  250,  246,  265,  270,  270,  245,
        -:10385:      243,  270,  270,  270,  273,  239,  239,  273,  273,  273,
        -:10386:      273,  273,  273,  273,  273,  273,  273,  273,  279,  279,
        -:10387:
        -:10388:      236,  279,  279,  279,  279,  279,  279,  279,  279,  279,
        -:10389:      279,  279,  280,  280,  236,  280,  280,  280,  280,  280,
        -:10390:      280,  280,  280,  280,  280,  280,  287,  287,  287,  290,
        -:10391:      290,  290,  291,  291,  291,  291,  291,  291,  291,  291,
        -:10392:      291,  291,  291,  291,  291,  291,  295,  295,  295,  295,
        -:10393:      295,  295,  295,  295,  295,  295,  295,  295,  295,  295,
        -:10394:      299,  299,  230,  299,  299,  299,  299,  299,  299,  230,
        -:10395:      299,  299,  299,  299,  305,  305,  229,  305,  305,  305,
        -:10396:      305,  305,  305,  305,  305,  305,  305,  308,  308,  228,
        -:10397:      308,  308,  308,  308,  308,  308,  308,  308,  308,  308,
        -:10398:
        -:10399:      308,  309,  309,  228,  309,  309,  309,  309,  309,  309,
        -:10400:      309,  309,  309,  309,  309,  310,  310,  226,  310,  310,
        -:10401:      310,  310,  310,  310,  310,  310,  310,  310,  310,  321,
        -:10402:      321,  321,  321,  321,  321,  321,  321,  321,  321,  321,
        -:10403:      321,  321,  321,  334,  334,  225,  225,  334,  334,  334,
        -:10404:      337,  337,  224,  222,  337,  337,  337,  393,  393,  393,
        -:10405:      393,  393,  393,  393,  393,  393,  393,  393,  393,  393,
        -:10406:      393,  402,  402,  402,  402,  402,  402,  402,  402,  402,
        -:10407:      402,  402,  402,  402,  402,  221,  220,  218,  218,  216,
        -:10408:      209,  212,  209,  209,  193,  205,  205,  195,  193,  189,
        -:10409:
        -:10410:      189,  182,  172,  172,  167,  167,  407,  163,  163,   97,
        -:10411:       97,   88,   80,   80,   43,  407,  407,  407,  407,  407,
        -:10412:      407,  407,  407,  407,  407,  407,  407,  407,  407,  407,
        -:10413:      407,  407,  407,  407,  407,  407,  407,  407,  407,  407,
        -:10414:      407,  407,  407,  407,  407,  407,  407,  407,  407,  407,
        -:10415:      407,  407,  407,  407,  407,  407,  407,  407
        -:10416:    } ;
        -:10417:
        -:10418:static const short int yy_chk[1659] =
        -:10419:    {   0,
        -:10420:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:10421:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:10422:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:10423:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:10424:        1,    1,    1,    2,    2,    2,    2,    2,    2,    2,
        -:10425:        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
        -:10426:        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
        -:10427:        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
        -:10428:        2,    2,    2,    2,    2,    2,    3,    3,    3,    3,
        -:10429:        3,    5,    5,    3,    3,   27,   27,    3,  406,    3,
        -:10430:
        -:10431:       21,    3,    3,    6,    6,    6,   28,   28,    6,   11,
        -:10432:       11,   11,   12,   12,   12,   21,   69,   21,   19,   19,
        -:10433:       19,   20,   20,   20,   22,    3,    3,    4,    4,    4,
        -:10434:        4,    4,    4,   19,    4,    4,   20,  111,    4,   22,
        -:10435:        4,   22,    4,    4,  111,    4,   23,   23,   24,   24,
        -:10436:       69,   31,   31,   32,   32,   23,  403,   24,   31,  400,
        -:10437:       32,   23,   23,   24,   24,  396,    4,    4,    9,    9,
        -:10438:        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
        -:10439:        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
        -:10440:        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
        -:10441:
        -:10442:        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
        -:10443:        9,   13,   13,   13,   13,   13,   13,   13,   13,   13,
        -:10444:       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
        -:10445:       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
        -:10446:       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
        -:10447:       13,   13,   13,   13,   17,   17,   18,   18,  394,   33,
        -:10448:       33,   78,   17,   78,   18,   17,   33,   18,   34,   34,
        -:10449:       35,   35,   35,  129,  129,   34,   36,   36,   36,   45,
        -:10450:       45,   45,   49,   49,   49,   35,   60,   60,   60,  131,
        -:10451:      131,   36,  139,  139,   17,  384,   18,   25,   25,   25,
        -:10452:
        -:10453:       25,   25,   25,   25,   25,   25,   25,   25,   25,   25,
        -:10454:       25,   25,   25,   25,   25,   25,   25,   25,   25,   25,
        -:10455:       25,   25,   25,   25,   25,   25,   25,   25,   25,   25,
        -:10456:       25,   25,   25,   25,   25,   25,   25,   25,   25,   25,
        -:10457:       29,   29,   30,   30,   64,  108,  110,  116,  122,  141,
        -:10458:      141,  149,  164,  164,  164,  383,  149,  382,  122,  169,
        -:10459:      169,  169,  176,  176,  176,  181,  181,  188,  188,   64,
        -:10460:      108,  110,  116,  179,  176,  247,  247,  179,  249,  249,
        -:10461:       29,  381,   30,   37,   37,   37,   37,   37,   37,   37,
        -:10462:       37,   37,   37,   37,   37,   37,   37,   37,   37,   37,
        -:10463:
        -:10464:       37,   37,   37,   37,   37,   37,   37,   37,   37,   37,
        -:10465:       37,   37,   37,   37,   37,   37,   37,   37,   37,   37,
        -:10466:       37,   37,   37,   37,   37,   37,   39,   39,   39,   40,
        -:10467:       40,   40,   56,   56,   56,  380,  195,   56,   66,   66,
        -:10468:       66,  240,  266,   66,  175,  175,  175,  266,  177,  177,
        -:10469:      177,  240,  184,  184,  184,  378,  175,  184,  377,   39,
        -:10470:      177,  195,   40,  376,   39,  255,  255,   40,   52,  256,
        -:10471:      256,  375,   56,  258,  258,  291,  291,  175,   66,  177,
        -:10472:      293,  293,  301,   52,  374,   52,  301,   52,  295,  295,
        -:10473:      373,   52,  184,   52,   52,   52,   52,   52,  372,   52,
        -:10474:
        -:10475:       52,  343,   52,   65,   65,  343,   65,   65,   65,   65,
        -:10476:       65,   65,   65,   65,   65,   65,   65,   65,   65,   65,
        -:10477:       65,   65,   65,   65,   65,   65,   65,   65,   65,   65,
        -:10478:       65,   65,   65,   65,   65,   65,   65,   65,   65,   65,
        -:10479:       65,   65,   65,   65,   65,   65,  201,  201,  371,  201,
        -:10480:      201,  201,  201,  201,  201,  201,  201,  201,  201,  201,
        -:10481:      201,  201,  201,  201,  201,  201,  201,  201,  201,  201,
        -:10482:      201,  201,  201,  201,  201,  201,  201,  201,  201,  201,
        -:10483:      201,  201,  201,  201,  201,  201,  201,  201,  201,  202,
        -:10484:      202,  202,  297,  297,  202,  281,  281,  281,  284,  284,
        -:10485:
        -:10486:      284,  300,  321,  321,  323,  323,  300,  281,  379,  379,
        -:10487:      284,  331,  331,  331,  345,  367,  393,  393,  345,  367,
        -:10488:      395,  395,  401,  401,  402,  402,  300,  404,  404,  202,
        -:10489:      222,  222,  222,  222,  222,  222,  222,  222,  222,  222,
        -:10490:      222,  222,  222,  222,  222,  222,  222,  222,  222,  222,
        -:10491:      222,  222,  222,  222,  222,  222,  222,  222,  222,  222,
        -:10492:      222,  222,  222,  222,  222,  222,  222,  222,  222,  222,
        -:10493:      222,  222,  222,  269,  269,  370,  269,  269,  269,  269,
        -:10494:      269,  269,  269,  269,  269,  269,  269,  269,  269,  269,
        -:10495:      269,  269,  269,  269,  269,  269,  269,  269,  269,  269,
        -:10496:
        -:10497:      269,  269,  269,  269,  269,  269,  269,  269,  269,  269,
        -:10498:      269,  269,  269,  269,  269,  269,  302,  457,  462,  466,
        -:10499:      302,  457,  462,  466,  302,  302,  302,  302,  302,  302,
        -:10500:      316,  316,  369,  316,  316,  316,  316,  316,  316,  366,
        -:10501:      316,  316,  316,  316,  316,  316,  316,  316,  316,  316,
        -:10502:      467,  364,  363,  362,  467,  361,  360,  359,  358,  357,
        -:10503:      355,  354,  352,  351,  349,  348,  342,  341,  339,  336,
        -:10504:      316,  316,  316,  325,  325,  335,  325,  325,  325,  325,
        -:10505:      325,  325,  333,  325,  325,  325,  325,  325,  325,  325,
        -:10506:      325,  325,  325,  332,  329,  328,  327,  326,  322,  320,
        -:10507:
        -:10508:      319,  317,  315,  314,  312,  311,  303,  299,  298,  296,
        -:10509:      292,  289,  288,  325,  325,  325,  344,  286,  285,  283,
        -:10510:      344,  282,  277,  276,  344,  344,  344,  344,  344,  344,
        -:10511:      346,  274,  272,  271,  346,  267,  260,  257,  346,  346,
        -:10512:      346,  346,  346,  346,  368,  251,  248,  246,  368,  245,
        -:10513:      232,  229,  368,  368,  368,  368,  368,  368,  408,  408,
        -:10514:      408,  408,  408,  408,  408,  408,  408,  408,  408,  408,
        -:10515:      408,  408,  409,  409,  409,  409,  409,  409,  409,  409,
        -:10516:      409,  409,  409,  409,  409,  409,  410,  410,  410,  410,
        -:10517:      410,  410,  410,  410,  410,  410,  410,  410,  410,  410,
        -:10518:
        -:10519:      411,  411,  411,  411,  411,  411,  411,  411,  411,  411,
        -:10520:      411,  411,  411,  411,  412,  412,  412,  412,  412,  412,
        -:10521:      412,  412,  412,  412,  412,  412,  412,  412,  413,  413,
        -:10522:      413,  413,  413,  413,  413,  413,  413,  413,  413,  413,
        -:10523:      413,  413,  414,  414,  414,  414,  414,  414,  414,  414,
        -:10524:      414,  414,  414,  414,  414,  414,  415,  415,  415,  415,
        -:10525:      415,  415,  415,  415,  415,  415,  415,  415,  415,  415,
        -:10526:      416,  416,  416,  416,  416,  416,  416,  416,  416,  416,
        -:10527:      416,  416,  416,  416,  417,  417,  417,  417,  417,  417,
        -:10528:      417,  417,  417,  417,  417,  417,  417,  417,  418,  418,
        -:10529:
        -:10530:      418,  418,  418,  418,  418,  418,  418,  418,  418,  418,
        -:10531:      418,  418,  419,  419,  419,  419,  419,  419,  419,  419,
        -:10532:      419,  419,  419,  419,  419,  419,  420,  420,  420,  420,
        -:10533:      420,  420,  420,  420,  420,  420,  420,  420,  420,  420,
        -:10534:      421,  421,  421,  421,  421,  421,  421,  421,  421,  421,
        -:10535:      421,  421,  421,  421,  422,  422,  422,  422,  422,  422,
        -:10536:      422,  422,  422,  422,  422,  422,  422,  422,  423,  423,
        -:10537:      224,  221,  423,  423,  423,  424,  424,  424,  424,  424,
        -:10538:      424,  424,  424,  424,  424,  424,  424,  425,  425,  220,
        -:10539:      215,  425,  425,  425,  426,  426,  212,  426,  426,  426,
        -:10540:
        -:10541:      426,  426,  426,  426,  426,  426,  426,  426,  427,  427,
        -:10542:      204,  427,  427,  427,  427,  427,  427,  427,  427,  427,
        -:10543:      427,  427,  428,  428,  203,  428,  428,  428,  428,  428,
        -:10544:      428,  428,  428,  428,  428,  428,  429,  429,  197,  429,
        -:10545:      429,  429,  429,  429,  429,  429,  429,  429,  429,  429,
        -:10546:      430,  430,  194,  430,  430,  430,  430,  430,  430,  430,
        -:10547:      430,  430,  430,  430,  431,  431,  431,  431,  431,  431,
        -:10548:      431,  431,  431,  431,  431,  431,  431,  431,  432,  432,
        -:10549:      193,  432,  432,  192,  432,  432,  432,  432,  191,  187,
        -:10550:      186,  432,  433,  433,  185,  171,  433,  433,  433,  434,
        -:10551:
        -:10552:      434,  170,  434,  434,  434,  434,  434,  434,  434,  434,
        -:10553:      434,  434,  434,  435,  435,  166,  165,  435,  435,  435,
        -:10554:      436,  436,  163,  436,  436,  436,  436,  436,  436,  436,
        -:10555:      436,  436,  436,  436,  437,  437,  162,  437,  437,  437,
        -:10556:      437,  437,  437,  437,  437,  437,  437,  437,  438,  438,
        -:10557:      161,  438,  438,  438,  438,  438,  438,  160,  438,  438,
        -:10558:      438,  438,  439,  439,  159,  158,  156,  439,  439,  439,
        -:10559:      439,  439,  440,  440,  155,  440,  440,  440,  440,  440,
        -:10560:      440,  440,  440,  440,  440,  440,  441,  441,  152,  151,
        -:10561:      441,  441,  441,  442,  442,  442,  442,  442,  442,  442,
        -:10562:
        -:10563:      442,  442,  442,  442,  442,  442,  442,  443,  443,  150,
        -:10564:      443,  443,  145,  443,  443,  443,  443,  443,  443,  443,
        -:10565:      443,  444,  444,  444,  444,  444,  144,  444,  444,  444,
        -:10566:      444,  444,  444,  444,  444,  445,  445,  142,  140,  445,
        -:10567:      445,  445,  445,  138,  445,  445,  445,  445,  445,  446,
        -:10568:      446,  137,  446,  446,  446,  446,  446,  446,  446,  446,
        -:10569:      446,  446,  446,  447,  447,  136,  447,  447,  133,  447,
        -:10570:      447,  447,  447,  132,  130,  126,  447,  448,  448,  125,
        -:10571:      123,  448,  448,  448,  449,  120,  119,  449,  449,  449,
        -:10572:      449,  449,  449,  449,  449,  449,  449,  449,  450,  450,
        -:10573:
        -:10574:      114,  450,  450,  450,  450,  450,  450,  450,  450,  450,
        -:10575:      450,  450,  451,  451,  113,  451,  451,  451,  451,  451,
        -:10576:      451,  451,  451,  451,  451,  451,  452,  452,  452,  453,
        -:10577:      453,  453,  454,  454,  454,  454,  454,  454,  454,  454,
        -:10578:      454,  454,  454,  454,  454,  454,  455,  455,  455,  455,
        -:10579:      455,  455,  455,  455,  455,  455,  455,  455,  455,  455,
        -:10580:      456,  456,  106,  456,  456,  456,  456,  456,  456,  105,
        -:10581:      456,  456,  456,  456,  458,  458,  102,  458,  458,  458,
        -:10582:      458,  458,  458,  458,  458,  458,  458,  459,  459,  100,
        -:10583:      459,  459,  459,  459,  459,  459,  459,  459,  459,  459,
        -:10584:
        -:10585:      459,  460,  460,   99,  460,  460,  460,  460,  460,  460,
        -:10586:      460,  460,  460,  460,  460,  461,  461,   95,  461,  461,
        -:10587:      461,  461,  461,  461,  461,  461,  461,  461,  461,  463,
        -:10588:      463,  463,  463,  463,  463,  463,  463,  463,  463,  463,
        -:10589:      463,  463,  463,  464,  464,   92,   91,  464,  464,  464,
        -:10590:      465,  465,   90,   88,  465,  465,  465,  468,  468,  468,
        -:10591:      468,  468,  468,  468,  468,  468,  468,  468,  468,  468,
        -:10592:      468,  469,  469,  469,  469,  469,  469,  469,  469,  469,
        -:10593:      469,  469,  469,  469,  469,   87,   86,   83,   82,   79,
        -:10594:       77,   76,   74,   73,   70,   68,   67,   63,   62,   58,
        -:10595:
        -:10596:       57,   53,   51,   50,   47,   46,   43,   42,   41,   16,
        -:10597:       15,   10,    8,    7,  407,  407,  407,  407,  407,  407,
        -:10598:      407,  407,  407,  407,  407,  407,  407,  407,  407,  407,
        -:10599:      407,  407,  407,  407,  407,  407,  407,  407,  407,  407,
        -:10600:      407,  407,  407,  407,  407,  407,  407,  407,  407,  407,
        -:10601:      407,  407,  407,  407,  407,  407,  407,  407
        -:10602:    } ;
        -:10603:
        -:10604:static yy_state_type yy_last_accepting_state;
        -:10605:static char *yy_last_accepting_cpos;
        -:10606:
        -:10607:/* The intent behind this definition is that it'll catch
        -:10608: * any uses of REJECT which flex missed.
        -:10609: */
        -:10610:#define REJECT reject_used_but_not_detected
        -:10611:#define yymore() yymore_used_but_not_detected
        -:10612:#define YY_MORE_ADJ 0
        -:10613:char *yytext;
        -:10614:/* scan.l - scanner for flex input */
        -:10615:/*-
        -:10616: * Copyright (c) 1990 The Regents of the University of California.
        -:10617: * All rights reserved.
        -:10618: *
        -:10619: * This code is derived from software contributed to Berkeley by
        -:10620: * Vern Paxson.
        -:10621: * 
        -:10622: * The United States Government has rights in this work pursuant
        -:10623: * to contract no. DE-AC03-76SF00098 between the United States
        -:10624: * Department of Energy and the University of California.
        -:10625: *
        -:10626: * Redistribution and use in source and binary forms are permitted provided
        -:10627: * that: (1) source distributions retain this entire copyright notice and
        -:10628: * comment, and (2) distributions including binaries display the following
        -:10629: * acknowledgement:  ``This product includes software developed by the
        -:10630: * University of California, Berkeley and its contributors'' in the
        -:10631: * documentation or other materials provided with the distribution and in
        -:10632: * all advertising materials mentioning features or use of this software.
        -:10633: * Neither the name of the University nor the names of its contributors may
        -:10634: * be used to endorse or promote products derived from this software without
        -:10635: * specific prior written permission.
        -:10636: * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
        -:10637: * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
        -:10638: * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
        -:10639: */
        -:10640:
        -:10641:/* $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.seeded/v1/flex.c,v 1.1.1.2 2003/09/02 20:21:59 expsir Exp $ */
        -:10642:
        -:10643:
        -:10644:#define ACTION_ECHO add_action( yytext )
        -:10645:#define MARK_END_OF_PROLOG mark_prolog();
        -:10646:
        -:10647:#define YY_DECL \
        -:10648:	int flexscan()
        -:10649:
        -:10650:#define RETURNCHAR \
        -:10651:	yylval = (unsigned char) yytext[0]; \
        -:10652:	return CHAR;
        -:10653:
        -:10654:#define RETURNNAME \
        -:10655:	strcpy( nmstr, yytext ); \
        -:10656:	return NAME;
        -:10657:
        -:10658:#define PUT_BACK_STRING(str, start) \
        -:10659:	for ( i = strlen( str ) - 1; i >= start; --i ) \
        -:10660:		unput((str)[i])
        -:10661:
        -:10662:#define CHECK_REJECT(str) \
        -:10663:	if ( all_upper( str ) ) \
        -:10664:		reject = true;
        -:10665:
        -:10666:#define CHECK_YYMORE(str) \
        -:10667:	if ( all_lower( str ) ) \
        -:10668:		yymore_used = true;
        -:10669:
        -:10670:/* Macros after this point can all be overridden by user definitions in
        -:10671: * section 1.
        -:10672: */
        -:10673:
        -:10674:#ifdef YY_MALLOC_DECL
        -:10675:YY_MALLOC_DECL
        -:10676:#else
        -:10677:#if __STDC__
        -:10678:#ifndef __cplusplus
        -:10679:#include <stdlib.h>
        -:10680:#endif
        -:10681:#else
        -:10682:/* Just try to get by without declaring the routines.  This will fail
        -:10683: * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)
        -:10684: * or sizeof(void*) != sizeof(int).
        -:10685: */
        -:10686:#endif
        -:10687:#endif
        -:10688:
        -:10689:/* Amount of stuff to slurp up with each read. */
        -:10690:#ifndef YY_READ_BUF_SIZE
        -:10691:#define YY_READ_BUF_SIZE 8192
        -:10692:#endif
        -:10693:
        -:10694:/* Copy whatever the last rule matched to the standard output. */
        -:10695:
        -:10696:#ifndef ECHO
        -:10697:/* This used to be an fputs(), but since the string might contain NUL's,
        -:10698: * we now use fwrite().
        -:10699: */
        -:10700:#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )
        -:10701:#endif
        -:10702:
        -:10703:/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
        -:10704: * is returned in "result".
        -:10705: */
        -:10706:#ifndef YY_INPUT
        -:10707:#define YY_INPUT(buf,result,max_size) \
        -:10708:	if ( yy_current_buffer->yy_is_interactive ) \
        -:10709:		{ \
        -:10710:		int c = getc( yyin ); \
        -:10711:		result = c == EOF ? 0 : 1; \
        -:10712:		buf[0] = (char) c; \
        -:10713:		} \
        -:10714:	else if ( ((result = fread( buf, 1, max_size, yyin )) == 0) \
        -:10715:		  && ferror( yyin ) ) \
        -:10716:		YY_FATAL_ERROR( "input in flex scanner failed" );
        -:10717:#endif
        -:10718:
        -:10719:/* No semi-colon after return; correct usage is to write "yyterminate();" -
        -:10720: * we don't want an extra ';' after the "return" because that will cause
        -:10721: * some compilers to complain about unreachable statements.
        -:10722: */
        -:10723:#ifndef yyterminate
        -:10724:#define yyterminate() return YY_NULL
        -:10725:#endif
        -:10726:
        -:10727:/* Number of entries by which start-condition stack grows. */
        -:10728:#ifndef YY_START_STACK_INCR
        -:10729:#define YY_START_STACK_INCR 25
        -:10730:#endif
        -:10731:
        -:10732:/* Report a fatal error. */
        -:10733:#ifndef YY_FATAL_ERROR
        -:10734:#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
        -:10735:#endif
        -:10736:
        -:10737:/* Default declaration of generated scanner - a define so the user can
        -:10738: * easily add parameters.
        -:10739: */
        -:10740:#ifndef YY_DECL
        -:10741:#define YY_DECL int yylex YY_PROTO(( void ))
        -:10742:#endif
        -:10743:
        -:10744:/* Code executed at the beginning of each rule, after yytext and yyleng
        -:10745: * have been set up.
        -:10746: */
        -:10747:#ifndef YY_USER_ACTION
        -:10748:#define YY_USER_ACTION
        -:10749:#endif
        -:10750:
        -:10751:/* Code executed at the end of each rule. */
        -:10752:#ifndef YY_BREAK
        -:10753:#define YY_BREAK break;
        -:10754:#endif
        -:10755:
function flexscan called 31320 returned 100% blocks executed 66%
    31320:10756:YY_DECL
        -:10757:	{
        -:10758:	register yy_state_type yy_current_state;
        -:10759:	register char *yy_cp, *yy_bp;
        -:10760:	register int yy_act;
        -:10761:
        -:10762:
        -:10763:	static int bracelevel, didadef, indented_code, checking_used;
        -:10764:
    31320:10765:	int doing_codeblock = false;
        -:10766:	int i;
        -:10767:	Char nmdef[MAXLINE], myesc();
        -:10768:
        -:10769:
        -:10770:
    31320:10771:	if ( yy_init )
branch  0 taken 552 (fallthrough)
branch  1 taken 30768
        -:10772:		{
        -:10773:#ifdef YY_USER_INIT
        -:10774:		YY_USER_INIT;
        -:10775:#endif
        -:10776:
      552:10777:		if ( ! yy_start )
branch  0 taken 552 (fallthrough)
branch  1 taken 0
      552:10778:			yy_start = 1;	/* first start state */
        -:10779:
      552:10780:		if ( ! yyin )
branch  0 taken 0 (fallthrough)
branch  1 taken 552
    #####:10781:			yyin = stdin;
        -:10782:
      552:10783:		if ( ! yyout )
branch  0 taken 552 (fallthrough)
branch  1 taken 0
      552:10784:			yyout = stdout;
        -:10785:
      552:10786:		if ( yy_current_buffer )
branch  0 taken 0 (fallthrough)
branch  1 taken 552
    #####:10787:			yy_init_buffer( yy_current_buffer, yyin );
call    0 never executed
        -:10788:		else
      552:10789:			yy_current_buffer =
      552:10790:				yy_create_buffer( yyin, YY_BUF_SIZE );
call    0 returned 552
        -:10791:
      552:10792:		yy_load_buffer_state();
call    0 returned 552
        -:10793:
      552:10794:		yy_init = 0;
        -:10795:		}
        -:10796:
        -:10797:	while ( 1 )		/* loops until end-of-file is reached */
        -:10798:		{
    80117:10799:		yy_cp = yy_c_buf_p;
        -:10800:
        -:10801:		/* Support of yytext. */
    80117:10802:		*yy_cp = yy_hold_char;
        -:10803:
        -:10804:		/* yy_bp points to the position in yy_ch_buf of the start of
        -:10805:		 * the current run.
        -:10806:		 */
    80117:10807:		yy_bp = yy_cp;
        -:10808:
    80117:10809:		yy_current_state = yy_start;
    80117:10810:		if ( yy_bp[-1] == '\n' )
branch  0 taken 69900 (fallthrough)
branch  1 taken 10217
    10217:10811:			++yy_current_state;
    80117:10812:yy_match:
        -:10813:		do
        -:10814:			{
   317623:10815:			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
   317623:10816:			if ( yy_accept[yy_current_state] )
branch  0 taken 239477 (fallthrough)
branch  1 taken 78146
        -:10817:				{
   239477:10818:				yy_last_accepting_state = yy_current_state;
   239477:10819:				yy_last_accepting_cpos = yy_cp;
        -:10820:				}
   594756:10821:			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
branch  0 taken 277133
branch  1 taken 317623 (fallthrough)
        -:10822:				{
   277133:10823:				yy_current_state = (int) yy_def[yy_current_state];
   277133:10824:				if ( yy_current_state >= 408 )
branch  0 taken 232415 (fallthrough)
branch  1 taken 44718
   232415:10825:					yy_c = yy_meta[(unsigned int) yy_c];
        -:10826:				}
   317623:10827:			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
   317623:10828:			++yy_cp;
        -:10829:			}
   317623:10830:		while ( yy_base[yy_current_state] != 1615 );
branch  0 taken 236950
branch  1 taken 80673 (fallthrough)
        -:10831:
    80673:10832:yy_find_action:
   123311:10833:		yy_act = yy_accept[yy_current_state];
        -:10834:
   123311:10835:		YY_DO_BEFORE_ACTION;
        -:10836:
        -:10837:
   123856:10838:do_action:	/* This label is used only to access EOF actions. */
        -:10839:
        -:10840:
   123856:10841:		switch ( yy_act )
branch  0 taken 42197
branch  1 taken 8
branch  2 taken 111
branch  3 taken 1
branch  4 taken 18
branch  5 taken 115
branch  6 taken 19
branch  7 taken 552
branch  8 taken 0
branch  9 taken 0
branch 10 taken 0
branch 11 taken 0
branch 12 taken 0
branch 13 taken 0
branch 14 taken 241
branch 15 taken 19
branch 16 taken 346
branch 17 taken 19
branch 18 taken 0
branch 19 taken 111
branch 20 taken 111
branch 21 taken 0
branch 22 taken 0
branch 23 taken 115
branch 24 taken 0
branch 25 taken 0
branch 26 taken 3135
branch 27 taken 233
branch 28 taken 241
branch 29 taken 241
branch 30 taken 241
branch 31 taken 0
branch 32 taken 0
branch 33 taken 0
branch 34 taken 0
branch 35 taken 0
branch 36 taken 0
branch 37 taken 0
branch 38 taken 0
branch 39 taken 0
branch 40 taken 551
branch 41 taken 0
branch 42 taken 982
branch 43 taken 1
branch 44 taken 924
branch 45 taken 1
branch 46 taken 16
branch 47 taken 100
branch 48 taken 1091
branch 49 taken 296
branch 50 taken 0
branch 51 taken 103
branch 52 taken 0
branch 53 taken 11
branch 54 taken 3492
branch 55 taken 21
branch 56 taken 11
branch 57 taken 118
branch 58 taken 1524
branch 59 taken 455
branch 60 taken 3795
branch 61 taken 8921
branch 62 taken 7
branch 63 taken 16
branch 64 taken 0
branch 65 taken 17
branch 66 taken 0
branch 67 taken 0
branch 68 taken 1904
branch 69 taken 1091
branch 70 taken 0
branch 71 taken 218
branch 72 taken 0
branch 73 taken 1064
branch 74 taken 876
branch 75 taken 2681
branch 76 taken 1293
branch 77 taken 0
branch 78 taken 396
branch 79 taken 198
branch 80 taken 296
branch 81 taken 0
branch 82 taken 0
branch 83 taken 0
branch 84 taken 0
branch 85 taken 0
branch 86 taken 0
branch 87 taken 8
branch 88 taken 5
branch 89 taken 9
branch 90 taken 1
branch 91 taken 376
branch 92 taken 376
branch 93 taken 11854
branch 94 taken 7458
branch 95 taken 236
branch 96 taken 9
branch 97 taken 3601
branch 98 taken 4294
branch 99 taken 0
branch 100 taken 236
branch 101 taken 0
branch 102 taken 236
branch 103 taken 0
branch 104 taken 3601
branch 105 taken 3191
branch 106 taken 0
branch 107 taken 3601
branch 108 taken 0
branch 109 taken 0
branch 110 taken 580
branch 111 taken 11
branch 112 taken 1542
branch 113 taken 112
branch 114 taken 0
branch 115 taken 0
branch 116 taken 432
branch 117 taken 1543
branch 118 taken 0
        -:10842:	{ /* beginning of action switch */
    42197:10843:			case 0: /* must back up */
        -:10844:			/* undo the effects of YY_DO_BEFORE_ACTION */
    42197:10845:			*yy_cp = yy_hold_char;
    42197:10846:			yy_cp = yy_last_accepting_cpos;
    42197:10847:			yy_current_state = yy_last_accepting_state;
    42197:10848:			goto yy_find_action;
        -:10849:
        8:10850:case 1:
        -:10851:YY_USER_ACTION
        8:10852:indented_code = true; BEGIN(CODEBLOCK);
        8:10853:	YY_BREAK
      111:10854:case 2:
        -:10855:YY_USER_ACTION
      111:10856:ACTION_ECHO; BEGIN(C_COMMENT);
call    0 returned 111
      111:10857:	YY_BREAK
        1:10858:case 3:
        -:10859:YY_USER_ACTION
        1:10860:return SCDECL;
        -:10861:	YY_BREAK
       18:10862:case 4:
        -:10863:YY_USER_ACTION
       18:10864:return XSCDECL;
        -:10865:	YY_BREAK
      115:10866:case 5:
        -:10867:YY_USER_ACTION
        -:10868:{
      115:10869:			++linenum;
      115:10870:			line_directive_out( (FILE *) 0 );
call    0 returned 115
      115:10871:			indented_code = false;
      115:10872:			BEGIN(CODEBLOCK);
        -:10873:			}
      115:10874:	YY_BREAK
       19:10875:case 6:
        -:10876:YY_USER_ACTION
       19:10877:return WHITESPACE;
        -:10878:	YY_BREAK
      552:10879:case 7:
        -:10880:YY_USER_ACTION
        -:10881:{
      552:10882:			sectnum = 2;
      552:10883:			bracelevel = 0;
      552:10884:			mark_defs1();
call    0 returned 552
      552:10885:			line_directive_out( (FILE *) 0 );
call    0 returned 552
      552:10886:			BEGIN(SECT2PROLOG);
      552:10887:			return SECTEND;
        -:10888:			}
        -:10889:	YY_BREAK
    #####:10890:case 8:
        -:10891:YY_USER_ACTION
        -:10892:{
    #####:10893:			if ( lex_compat )
branch  0 never executed
branch  1 never executed
    #####:10894:				warn( "%pointer incompatible with -l option" );
call    0 never executed
        -:10895:			else
    #####:10896:				yytext_is_array = false;
    #####:10897:			++linenum;
        -:10898:			}
    #####:10899:	YY_BREAK
    #####:10900:case 9:
        -:10901:YY_USER_ACTION
        -:10902:{
    #####:10903:			if ( C_plus_plus )
branch  0 never executed
branch  1 never executed
    #####:10904:				warn( "%array incompatible with -+ option" );
call    0 never executed
        -:10905:			else
    #####:10906:				yytext_is_array = true;
    #####:10907:			++linenum;
        -:10908:			}
    #####:10909:	YY_BREAK
    #####:10910:case 10:
        -:10911:YY_USER_ACTION
        -:10912:{
    #####:10913:			warn( "%used/%unused have been deprecated" );
call    0 never executed
    #####:10914:			checking_used = REALLY_USED; BEGIN(USED_LIST);
        -:10915:			}
    #####:10916:	YY_BREAK
    #####:10917:case 11:
        -:10918:YY_USER_ACTION
        -:10919:{
    #####:10920:			warn( "%used/%unused have been deprecated" );
call    0 never executed
    #####:10921:			checking_used = REALLY_NOT_USED; BEGIN(USED_LIST);
        -:10922:			}
    #####:10923:	YY_BREAK
    #####:10924:case 12:
        -:10925:YY_USER_ACTION
    #####:10926:++linenum;	/* ignore */
    #####:10927:	YY_BREAK
    #####:10928:case 13:
        -:10929:YY_USER_ACTION
    #####:10930:synerr( "unrecognized '%' directive" );
call    0 never executed
    #####:10931:	YY_BREAK
      241:10932:case 14:
        -:10933:YY_USER_ACTION
        -:10934:{
      241:10935:			strcpy( nmstr, yytext );
      241:10936:			didadef = false;
      241:10937:			BEGIN(PICKUPDEF);
        -:10938:			}
      241:10939:	YY_BREAK
       19:10940:case 15:
        -:10941:YY_USER_ACTION
       19:10942:RETURNNAME;
        -:10943:	YY_BREAK
      346:10944:case 16:
        -:10945:YY_USER_ACTION
      346:10946:++linenum; /* allows blank lines in section 1 */
      346:10947:	YY_BREAK
       19:10948:case 17:
        -:10949:YY_USER_ACTION
       19:10950:++linenum; return '\n';
        -:10951:	YY_BREAK
    #####:10952:case 18:
        -:10953:YY_USER_ACTION
    #####:10954:ACTION_ECHO; BEGIN(INITIAL);
call    0 never executed
    #####:10955:	YY_BREAK
      111:10956:case 19:
        -:10957:YY_USER_ACTION
      111:10958:++linenum; ACTION_ECHO; BEGIN(INITIAL);
call    0 returned 111
      111:10959:	YY_BREAK
      111:10960:case 20:
        -:10961:YY_USER_ACTION
      111:10962:ACTION_ECHO;
call    0 returned 111
      111:10963:	YY_BREAK
    #####:10964:case 21:
        -:10965:YY_USER_ACTION
    #####:10966:ACTION_ECHO;
call    0 never executed
    #####:10967:	YY_BREAK
    #####:10968:case 22:
        -:10969:YY_USER_ACTION
    #####:10970:++linenum; ACTION_ECHO;
call    0 never executed
    #####:10971:	YY_BREAK
      115:10972:case 23:
        -:10973:YY_USER_ACTION
      115:10974:++linenum; BEGIN(INITIAL);
      115:10975:	YY_BREAK
    #####:10976:case 24:
        -:10977:YY_USER_ACTION
    #####:10978:ACTION_ECHO; CHECK_REJECT(yytext);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:10979:	YY_BREAK
    #####:10980:case 25:
        -:10981:YY_USER_ACTION
    #####:10982:ACTION_ECHO; CHECK_YYMORE(yytext);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:10983:	YY_BREAK
     3135:10984:case 26:
        -:10985:YY_USER_ACTION
     3135:10986:ACTION_ECHO;
call    0 returned 3135
     3135:10987:	YY_BREAK
      233:10988:case 27:
        -:10989:YY_USER_ACTION
        -:10990:{
      233:10991:			++linenum;
      233:10992:			ACTION_ECHO;
call    0 returned 233
      233:10993:			if ( indented_code )
branch  0 taken 8 (fallthrough)
branch  1 taken 225
        8:10994:				BEGIN(INITIAL);
        -:10995:			}
      233:10996:	YY_BREAK
      241:10997:case 28:
        -:10998:YY_USER_ACTION
        -:10999:/* separates name and definition */
      241:11000:	YY_BREAK
      241:11001:case 29:
        -:11002:YY_USER_ACTION
        -:11003:{
      241:11004:			strcpy( (char *) nmdef, yytext );
        -:11005:
        -:11006:			/* Skip trailing whitespace. */
      241:11007:			for ( i = strlen( (char *) nmdef ) - 1;
      241:11008:			      i >= 0 && (nmdef[i] == ' ' || nmdef[i] == '\t');
branch  0 taken 241 (fallthrough)
branch  1 taken 0
branch  2 taken 0
branch  3 taken 241 (fallthrough)
branch  4 taken 0
branch  5 taken 241 (fallthrough)
    #####:11009:			      --i )
        -:11010:				;
        -:11011:
      241:11012:			nmdef[i + 1] = '\0';
        -:11013:
      241:11014:			ndinstal( nmstr, nmdef );
call    0 returned 241
      241:11015:			didadef = true;
        -:11016:			}
      241:11017:	YY_BREAK
      241:11018:case 30:
        -:11019:YY_USER_ACTION
        -:11020:{
      241:11021:			if ( ! didadef )
branch  0 taken 0 (fallthrough)
branch  1 taken 241
    #####:11022:				synerr( "incomplete name definition" );
call    0 never executed
      241:11023:			BEGIN(INITIAL);
      241:11024:			++linenum;
        -:11025:			}
      241:11026:	YY_BREAK
    #####:11027:case 31:
        -:11028:YY_USER_ACTION
    #####:11029:++linenum; BEGIN(INITIAL); RETURNNAME;
        -:11030:	YY_BREAK
    #####:11031:case 32:
        -:11032:YY_USER_ACTION
    #####:11033:++linenum; BEGIN(INITIAL);
    #####:11034:	YY_BREAK
    #####:11035:case 33:
        -:11036:YY_USER_ACTION
        -:11037:
    #####:11038:	YY_BREAK
    #####:11039:case 34:
        -:11040:YY_USER_ACTION
        -:11041:{
    #####:11042:			if ( all_upper( yytext ) )
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:11043:				reject_really_used = checking_used;
        -:11044:			else
    #####:11045:				synerr(
call    0 never executed
        -:11046:				"unrecognized %used/%unused construct" );
        -:11047:			}
    #####:11048:	YY_BREAK
    #####:11049:case 35:
        -:11050:YY_USER_ACTION
        -:11051:{
    #####:11052:			if ( all_lower( yytext ) )
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:11053:				yymore_really_used = checking_used;
        -:11054:			else
    #####:11055:				synerr(
call    0 never executed
        -:11056:				"unrecognized %used/%unused construct" );
        -:11057:			}
    #####:11058:	YY_BREAK
    #####:11059:case 36:
        -:11060:YY_USER_ACTION
    #####:11061:synerr( "unrecognized %used/%unused construct" );
call    0 never executed
    #####:11062:	YY_BREAK
    #####:11063:case 37:
        -:11064:YY_USER_ACTION
    #####:11065:++bracelevel; yyless( 2 );	/* eat only %{ */
    #####:11066:	YY_BREAK
    #####:11067:case 38:
        -:11068:YY_USER_ACTION
    #####:11069:--bracelevel; yyless( 2 );	/* eat only %} */
    #####:11070:	YY_BREAK
    #####:11071:case 39:
        -:11072:YY_USER_ACTION
    #####:11073:ACTION_ECHO;	/* indented code in prolog */
call    0 never executed
    #####:11074:	YY_BREAK
      551:11075:case 40:
        -:11076:YY_USER_ACTION
        -:11077:{	/* non-indented code */
      551:11078:			if ( bracelevel <= 0 )
branch  0 taken 551 (fallthrough)
branch  1 taken 0
        -:11079:				{ /* not in %{ ... %} */
      551:11080:				yyless( 0 );	/* put it all back */
      551:11081:				mark_prolog();
call    0 returned 551
      551:11082:				BEGIN(SECT2);
        -:11083:				}
        -:11084:			else
    #####:11085:				ACTION_ECHO;
call    0 never executed
        -:11086:			}
      551:11087:	YY_BREAK
    #####:11088:case 41:
        -:11089:YY_USER_ACTION
    #####:11090:ACTION_ECHO;
call    0 never executed
    #####:11091:	YY_BREAK
      982:11092:case 42:
        -:11093:YY_USER_ACTION
      982:11094:++linenum; ACTION_ECHO;
call    0 returned 982
      982:11095:	YY_BREAK
        1:11096:case YY_STATE_EOF(SECT2PROLOG):
        -:11097:{
        1:11098:			mark_prolog();
call    0 returned 1
        1:11099:			sectnum = 0;
        1:11100:			yyterminate(); /* to stop the parser */
        -:11101:			}
        -:11102:	YY_BREAK
      924:11103:case 43:
        -:11104:YY_USER_ACTION
      924:11105:++linenum; /* allow blank lines in section 2 */
      924:11106:	YY_BREAK
        1:11107:case 44:
        -:11108:YY_USER_ACTION
        -:11109:{
        1:11110:			indented_code = (yytext[0] != '%');
        1:11111:			doing_codeblock = true;
        1:11112:			bracelevel = 1;
        -:11113:
        1:11114:			if ( indented_code )
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:11115:				ACTION_ECHO;
call    0 returned 1
        -:11116:
        1:11117:			BEGIN(CODEBLOCK_2);
        -:11118:			}
        1:11119:	YY_BREAK
       16:11120:case 45:
        -:11121:YY_USER_ACTION
       16:11122:BEGIN(SC); return '<';
        -:11123:	YY_BREAK
      100:11124:case 46:
        -:11125:YY_USER_ACTION
      100:11126:return '^';
        -:11127:	YY_BREAK
     1091:11128:case 47:
        -:11129:YY_USER_ACTION
     1091:11130:BEGIN(QUOTE); return '"';
        -:11131:	YY_BREAK
      296:11132:case 48:
      296:11133:*yy_cp = yy_hold_char; /* undo effects of setting up yytext */
      296:11134:yy_c_buf_p = yy_cp = yy_bp + 1;
      296:11135:YY_DO_BEFORE_ACTION; /* set up yytext again */
        -:11136:YY_USER_ACTION
      296:11137:BEGIN(NUM); return '{';
        -:11138:	YY_BREAK
    #####:11139:case 49:
        -:11140:YY_USER_ACTION
    #####:11141:BEGIN(BRACEERROR);
    #####:11142:	YY_BREAK
      103:11143:case 50:
      103:11144:*yy_cp = yy_hold_char; /* undo effects of setting up yytext */
      103:11145:yy_c_buf_p = yy_cp = yy_bp + 1;
      103:11146:YY_DO_BEFORE_ACTION; /* set up yytext again */
        -:11147:YY_USER_ACTION
      103:11148:return '$';
        -:11149:	YY_BREAK
    #####:11150:case 51:
        -:11151:YY_USER_ACTION
        -:11152:{
    #####:11153:			bracelevel = 1;
    #####:11154:			BEGIN(PERCENT_BRACE_ACTION);
    #####:11155:			return '\n';
        -:11156:			}
        -:11157:	YY_BREAK
       11:11158:case 52:
        -:11159:YY_USER_ACTION
       11:11160:continued_action = true; ++linenum; return '\n';
        -:11161:	YY_BREAK
     3492:11162:case 53:
        -:11163:YY_USER_ACTION
        -:11164:{
        -:11165:			/* This rule is separate from the one below because
        -:11166:			 * otherwise we get variable trailing context, so
        -:11167:			 * we can't build the scanner using -{f,F}.
        -:11168:			 */
     3492:11169:			bracelevel = 0;
     3492:11170:			continued_action = false;
     3492:11171:			BEGIN(ACTION);
     3492:11172:			return '\n';
        -:11173:			}
        -:11174:	YY_BREAK
       21:11175:case 54:
        -:11176:YY_USER_ACTION
        -:11177:{
       21:11178:			bracelevel = 0;
       21:11179:			continued_action = false;
       21:11180:			BEGIN(ACTION);
       21:11181:			unput( '\n' );	/* so <ACTION> sees it */
call    0 returned 21
       21:11182:			return '\n';
        -:11183:			}
        -:11184:	YY_BREAK
       11:11185:case 55:
        -:11186:YY_USER_ACTION
       11:11187:return EOF_OP;
        -:11188:	YY_BREAK
      118:11189:case 56:
        -:11190:YY_USER_ACTION
        -:11191:{
      118:11192:			sectnum = 3;
      118:11193:			BEGIN(SECT3);
      118:11194:			yyterminate(); /* to stop the parser */
        -:11195:			}
        -:11196:	YY_BREAK
     1524:11197:case 57:
        -:11198:YY_USER_ACTION
        -:11199:{
        -:11200:			int cclval;
        -:11201:
     1524:11202:			strcpy( nmstr, yytext );
        -:11203:
        -:11204:			/* Check to see if we've already encountered this
        -:11205:			 * ccl.
        -:11206:			 */
     1524:11207:			if ( (cclval = ccllookup( (Char *) nmstr )) )
call    0 returned 1524
branch  1 taken 231 (fallthrough)
branch  2 taken 1293
        -:11208:				{
      231:11209:				if ( input() != ']' )
call    0 returned 231
branch  1 taken 0 (fallthrough)
branch  2 taken 231
    #####:11210:					synerr( "bad character class" );
call    0 never executed
        -:11211:
      231:11212:				yylval = cclval;
      231:11213:				++cclreuse;
      231:11214:				return PREVCCL;
        -:11215:				}
        -:11216:			else
        -:11217:				{
        -:11218:				/* We fudge a bit.  We know that this ccl will
        -:11219:				 * soon be numbered as lastccl + 1 by cclinit.
        -:11220:				 */
     1293:11221:				cclinstal( (Char *) nmstr, lastccl + 1 );
call    0 returned 1293
        -:11222:
        -:11223:				/* Push back everything but the leading bracket
        -:11224:				 * so the ccl can be rescanned.
        -:11225:				 */
     1293:11226:				yyless( 1 );
        -:11227:
     1293:11228:				BEGIN(FIRSTCCL);
     1293:11229:				return '[';
        -:11230:				}
        -:11231:			}
        -:11232:	YY_BREAK
      455:11233:case 58:
        -:11234:YY_USER_ACTION
        -:11235:{
        -:11236:			register Char *nmdefptr;
        -:11237:			Char *ndlookup();
        -:11238:
      455:11239:			strcpy( nmstr, yytext + 1 );
      455:11240:			nmstr[yyleng - 2] = '\0';  /* chop trailing brace */
        -:11241:
      455:11242:			if ( ! (nmdefptr = ndlookup( nmstr )) )
call    0 returned 455
branch  1 taken 4 (fallthrough)
branch  2 taken 451
        4:11243:				format_synerr( "undefined definition {%s}",
call    0 returned 4
        -:11244:						nmstr );
        -:11245:
        -:11246:			else
        -:11247:				{ /* push back name surrounded by ()'s */
      451:11248:				int len = strlen( (char *) nmdefptr );
        -:11249:
      451:11250:				if ( lex_compat || nmdefptr[0] == '^' ||
branch  0 taken 314 (fallthrough)
branch  1 taken 137
branch  2 taken 314 (fallthrough)
branch  3 taken 0
branch  4 taken 314 (fallthrough)
branch  5 taken 0
      314:11251:				     (len > 0 && nmdefptr[len - 1] == '$') )
branch  0 taken 0 (fallthrough)
branch  1 taken 314
        -:11252:					{ /* don't use ()'s after all */
     1137:11253:					PUT_BACK_STRING((char *) nmdefptr, 0);
call    0 returned 1000
branch  1 taken 1000
branch  2 taken 137 (fallthrough)
        -:11254:
      137:11255:					if ( nmdefptr[0] == '^' )
branch  0 taken 0 (fallthrough)
branch  1 taken 137
    #####:11256:						BEGIN(CARETISBOL);
        -:11257:					}
        -:11258:
        -:11259:				else
        -:11260:					{
      314:11261:					unput(')');
call    0 returned 314
     2624:11262:					PUT_BACK_STRING((char *) nmdefptr, 0);
call    0 returned 2310
branch  1 taken 2310
branch  2 taken 314 (fallthrough)
      314:11263:					unput('(');
call    0 returned 314
        -:11264:					}
        -:11265:				}
        -:11266:			}
      455:11267:	YY_BREAK
     3795:11268:case 59:
        -:11269:YY_USER_ACTION
     3795:11270:return (unsigned char) yytext[0];
        -:11271:	YY_BREAK
     8921:11272:case 60:
        -:11273:YY_USER_ACTION
     8921:11274:RETURNCHAR;
        -:11275:	YY_BREAK
        7:11276:case 61:
        -:11277:YY_USER_ACTION
        7:11278:return (unsigned char) yytext[0];
        -:11279:	YY_BREAK
       16:11280:case 62:
        -:11281:YY_USER_ACTION
       16:11282:BEGIN(SECT2); return '>';
        -:11283:	YY_BREAK
    #####:11284:case 63:
    #####:11285:*yy_cp = yy_hold_char; /* undo effects of setting up yytext */
    #####:11286:yy_c_buf_p = yy_cp = yy_bp + 1;
    #####:11287:YY_DO_BEFORE_ACTION; /* set up yytext again */
        -:11288:YY_USER_ACTION
    #####:11289:BEGIN(CARETISBOL); return '>';
        -:11290:	YY_BREAK
       17:11291:case 64:
        -:11292:YY_USER_ACTION
       17:11293:RETURNNAME;
        -:11294:	YY_BREAK
    #####:11295:case 65:
        -:11296:YY_USER_ACTION
        -:11297:{
    #####:11298:			format_synerr( "bad <start condition>: %s", yytext );
call    0 never executed
        -:11299:			}
    #####:11300:	YY_BREAK
    #####:11301:case 66:
        -:11302:YY_USER_ACTION
    #####:11303:BEGIN(SECT2); return '^';
        -:11304:	YY_BREAK
     1904:11305:case 67:
        -:11306:YY_USER_ACTION
     1904:11307:RETURNCHAR;
        -:11308:	YY_BREAK
     1091:11309:case 68:
        -:11310:YY_USER_ACTION
     1091:11311:BEGIN(SECT2); return '"';
        -:11312:	YY_BREAK
    #####:11313:case 69:
        -:11314:YY_USER_ACTION
        -:11315:{
    #####:11316:			synerr( "missing quote" );
call    0 never executed
    #####:11317:			BEGIN(SECT2);
    #####:11318:			++linenum;
    #####:11319:			return '"';
        -:11320:			}
        -:11321:	YY_BREAK
      218:11322:case 70:
      218:11323:*yy_cp = yy_hold_char; /* undo effects of setting up yytext */
      218:11324:yy_c_buf_p = yy_cp = yy_bp + 1;
      218:11325:YY_DO_BEFORE_ACTION; /* set up yytext again */
        -:11326:YY_USER_ACTION
      218:11327:BEGIN(CCL); return '^';
        -:11328:	YY_BREAK
    #####:11329:case 71:
    #####:11330:*yy_cp = yy_hold_char; /* undo effects of setting up yytext */
    #####:11331:yy_c_buf_p = yy_cp = yy_bp + 1;
    #####:11332:YY_DO_BEFORE_ACTION; /* set up yytext again */
        -:11333:YY_USER_ACTION
    #####:11334:return '^';
        -:11335:	YY_BREAK
     1064:11336:case 72:
        -:11337:YY_USER_ACTION
     1064:11338:BEGIN(CCL); RETURNCHAR;
        -:11339:	YY_BREAK
      876:11340:case 73:
      876:11341:*yy_cp = yy_hold_char; /* undo effects of setting up yytext */
      876:11342:yy_c_buf_p = yy_cp = yy_bp + 1;
      876:11343:YY_DO_BEFORE_ACTION; /* set up yytext again */
        -:11344:YY_USER_ACTION
      876:11345:return '-';
        -:11346:	YY_BREAK
     2681:11347:case 74:
        -:11348:YY_USER_ACTION
     2681:11349:RETURNCHAR;
        -:11350:	YY_BREAK
     1293:11351:case 75:
        -:11352:YY_USER_ACTION
     1293:11353:BEGIN(SECT2); return ']';
        -:11354:	YY_BREAK
    #####:11355:case 76:
        -:11356:YY_USER_ACTION
        -:11357:{
    #####:11358:			synerr( "bad character class" );
call    0 never executed
    #####:11359:			BEGIN(SECT2);
    #####:11360:			return ']';
        -:11361:			}
        -:11362:	YY_BREAK
      396:11363:case 77:
        -:11364:YY_USER_ACTION
        -:11365:{
      396:11366:			yylval = myctoi( yytext );
call    0 returned 396
      396:11367:			return NUMBER;
        -:11368:			}
        -:11369:	YY_BREAK
      198:11370:case 78:
        -:11371:YY_USER_ACTION
      198:11372:return ',';
        -:11373:	YY_BREAK
      296:11374:case 79:
        -:11375:YY_USER_ACTION
      296:11376:BEGIN(SECT2); return '}';
        -:11377:	YY_BREAK
    #####:11378:case 80:
        -:11379:YY_USER_ACTION
        -:11380:{
    #####:11381:			synerr( "bad character inside {}'s" );
call    0 never executed
    #####:11382:			BEGIN(SECT2);
    #####:11383:			return '}';
        -:11384:			}
        -:11385:	YY_BREAK
    #####:11386:case 81:
        -:11387:YY_USER_ACTION
        -:11388:{
    #####:11389:			synerr( "missing }" );
call    0 never executed
    #####:11390:			BEGIN(SECT2);
    #####:11391:			++linenum;
    #####:11392:			return '}';
        -:11393:			}
        -:11394:	YY_BREAK
    #####:11395:case 82:
        -:11396:YY_USER_ACTION
    #####:11397:synerr( "bad name in {}'s" ); BEGIN(SECT2);
call    0 never executed
    #####:11398:	YY_BREAK
    #####:11399:case 83:
        -:11400:YY_USER_ACTION
    #####:11401:synerr( "missing }" ); ++linenum; BEGIN(SECT2);
call    0 never executed
    #####:11402:	YY_BREAK
    #####:11403:case 84:
        -:11404:YY_USER_ACTION
    #####:11405:ACTION_ECHO; BEGIN(ACTION_COMMENT);
call    0 never executed
    #####:11406:	YY_BREAK
    #####:11407:case 85:
        -:11408:YY_USER_ACTION
    #####:11409:bracelevel = 0;
    #####:11410:	YY_BREAK
        8:11411:case 86:
        -:11412:YY_USER_ACTION
        -:11413:{
        8:11414:			ACTION_ECHO;
call    0 returned 8
        8:11415:			CHECK_REJECT(yytext);
call    0 returned 8
branch  1 taken 8 (fallthrough)
branch  2 taken 0
        -:11416:			}
        8:11417:	YY_BREAK
        5:11418:case 87:
        -:11419:YY_USER_ACTION
        -:11420:{
        5:11421:			ACTION_ECHO;
call    0 returned 5
        5:11422:			CHECK_YYMORE(yytext);
call    0 returned 5
branch  1 taken 5 (fallthrough)
branch  2 taken 0
        -:11423:			}
        5:11424:	YY_BREAK
        9:11425:case 88:
        -:11426:YY_USER_ACTION
        9:11427:ACTION_ECHO;
call    0 returned 9
        9:11428:	YY_BREAK
        1:11429:case 89:
        -:11430:YY_USER_ACTION
        -:11431:{
        1:11432:			++linenum;
        1:11433:			ACTION_ECHO;
call    0 returned 1
        1:11434:			if ( bracelevel == 0 ||
branch  0 taken 1 (fallthrough)
branch  1 taken 0
branch  2 taken 1 (fallthrough)
branch  3 taken 0
        1:11435:			     (doing_codeblock && indented_code) )
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -:11436:				{
        1:11437:				if ( ! doing_codeblock )
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:11438:					add_action( "\tYY_BREAK\n" );
call    0 never executed
        -:11439:				
        1:11440:				doing_codeblock = false;
        1:11441:				BEGIN(SECT2);
        -:11442:				}
        -:11443:			}
        1:11444:	YY_BREAK
        -:11445:	/* Reject and YYmore() are checked for above, in PERCENT_BRACE_ACTION */
      376:11446:case 90:
        -:11447:YY_USER_ACTION
      376:11448:ACTION_ECHO; ++bracelevel;
call    0 returned 376
      376:11449:	YY_BREAK
      376:11450:case 91:
        -:11451:YY_USER_ACTION
      376:11452:ACTION_ECHO; --bracelevel;
call    0 returned 376
      376:11453:	YY_BREAK
    11854:11454:case 92:
        -:11455:YY_USER_ACTION
    11854:11456:ACTION_ECHO;
call    0 returned 11854
    11854:11457:	YY_BREAK
     7458:11458:case 93:
        -:11459:YY_USER_ACTION
     7458:11460:ACTION_ECHO;
call    0 returned 7458
     7458:11461:	YY_BREAK
      236:11462:case 94:
        -:11463:YY_USER_ACTION
      236:11464:ACTION_ECHO; BEGIN(ACTION_COMMENT);
call    0 returned 236
      236:11465:	YY_BREAK
        9:11466:case 95:
        -:11467:YY_USER_ACTION
        9:11468:ACTION_ECHO; /* character constant */
call    0 returned 9
        9:11469:	YY_BREAK
     3601:11470:case 96:
        -:11471:YY_USER_ACTION
     3601:11472:ACTION_ECHO; BEGIN(ACTION_STRING);
call    0 returned 3601
     3601:11473:	YY_BREAK
     4294:11474:case 97:
        -:11475:YY_USER_ACTION
        -:11476:{
     4294:11477:			++linenum;
     4294:11478:			ACTION_ECHO;
call    0 returned 4294
     4294:11479:			if ( bracelevel == 0 )
branch  0 taken 3513 (fallthrough)
branch  1 taken 781
        -:11480:				{
     3513:11481:				add_action( "\tYY_BREAK\n" );
call    0 returned 3513
     3513:11482:				BEGIN(SECT2);
        -:11483:				}
        -:11484:			}
     4294:11485:	YY_BREAK
    #####:11486:case 98:
        -:11487:YY_USER_ACTION
    #####:11488:ACTION_ECHO;
call    0 never executed
    #####:11489:	YY_BREAK
      236:11490:case 99:
        -:11491:YY_USER_ACTION
        -:11492:{
      236:11493:			ACTION_ECHO;
call    0 returned 236
      236:11494:			if ( doing_codeblock )
branch  0 taken 0 (fallthrough)
branch  1 taken 236
    #####:11495:				BEGIN(CODEBLOCK_2);
        -:11496:			else
      236:11497:				BEGIN(ACTION);
        -:11498:			}
      236:11499:	YY_BREAK
    #####:11500:case 100:
        -:11501:YY_USER_ACTION
    #####:11502:ACTION_ECHO;
call    0 never executed
    #####:11503:	YY_BREAK
      236:11504:case 101:
        -:11505:YY_USER_ACTION
      236:11506:ACTION_ECHO;
call    0 returned 236
      236:11507:	YY_BREAK
    #####:11508:case 102:
        -:11509:YY_USER_ACTION
    #####:11510:++linenum; ACTION_ECHO;
call    0 never executed
    #####:11511:	YY_BREAK
     3601:11512:case 103:
        -:11513:YY_USER_ACTION
     3601:11514:ACTION_ECHO;
call    0 returned 3601
     3601:11515:	YY_BREAK
     3191:11516:case 104:
        -:11517:YY_USER_ACTION
     3191:11518:ACTION_ECHO;
call    0 returned 3191
     3191:11519:	YY_BREAK
    #####:11520:case 105:
        -:11521:YY_USER_ACTION
    #####:11522:++linenum; ACTION_ECHO;
call    0 never executed
    #####:11523:	YY_BREAK
     3601:11524:case 106:
        -:11525:YY_USER_ACTION
     3601:11526:ACTION_ECHO; BEGIN(ACTION);
call    0 returned 3601
     3601:11527:	YY_BREAK
    #####:11528:case 107:
        -:11529:YY_USER_ACTION
    #####:11530:ACTION_ECHO;
call    0 never executed
    #####:11531:	YY_BREAK
    #####:11532:case YY_STATE_EOF(ACTION):
        -:11533:case YY_STATE_EOF(ACTION_COMMENT):
        -:11534:case YY_STATE_EOF(ACTION_STRING):
        -:11535:{
    #####:11536:			synerr( "EOF encountered inside an action" );
call    0 never executed
    #####:11537:			yyterminate();
        -:11538:			}
        -:11539:	YY_BREAK
      580:11540:case 108:
        -:11541:YY_USER_ACTION
        -:11542:{
      580:11543:			yylval = myesc( (Char *) yytext );
call    0 returned 580
      580:11544:			return CHAR;
        -:11545:			}
        -:11546:	YY_BREAK
       11:11547:case 109:
        -:11548:YY_USER_ACTION
        -:11549:{
       11:11550:			yylval = myesc( (Char *) yytext );
call    0 returned 11
       11:11551:			BEGIN(CCL);
       11:11552:			return CHAR;
        -:11553:			}
        -:11554:	YY_BREAK
     1542:11555:case 110:
        -:11556:YY_USER_ACTION
     1542:11557:ECHO;
call    0 returned 1542
     1542:11558:	YY_BREAK
      112:11559:case YY_STATE_EOF(SECT3):
      112:11560:sectnum = 0; yyterminate();
        -:11561:	YY_BREAK
    #####:11562:case 111:
        -:11563:YY_USER_ACTION
    #####:11564:format_synerr( "bad character: %s", yytext );
call    0 never executed
    #####:11565:	YY_BREAK
    #####:11566:case 112:
        -:11567:YY_USER_ACTION
    #####:11568:YY_FATAL_ERROR( "flex scanner jammed" );
call    0 never executed
    #####:11569:	YY_BREAK
      432:11570:case YY_STATE_EOF(INITIAL):
        -:11571:case YY_STATE_EOF(SECT2):
        -:11572:case YY_STATE_EOF(CODEBLOCK):
        -:11573:case YY_STATE_EOF(PICKUPDEF):
        -:11574:case YY_STATE_EOF(SC):
        -:11575:case YY_STATE_EOF(CARETISBOL):
        -:11576:case YY_STATE_EOF(NUM):
        -:11577:case YY_STATE_EOF(QUOTE):
        -:11578:case YY_STATE_EOF(FIRSTCCL):
        -:11579:case YY_STATE_EOF(CCL):
        -:11580:case YY_STATE_EOF(RECOVER):
        -:11581:case YY_STATE_EOF(BRACEERROR):
        -:11582:case YY_STATE_EOF(C_COMMENT):
        -:11583:case YY_STATE_EOF(PERCENT_BRACE_ACTION):
        -:11584:case YY_STATE_EOF(USED_LIST):
        -:11585:case YY_STATE_EOF(CODEBLOCK_2):
      432:11586:	yyterminate();
        -:11587:
     1543:11588:	case YY_END_OF_BUFFER:
        -:11589:		{
        -:11590:		/* Amount of text matched not including the EOB char. */
     1543:11591:		int yy_amount_of_matched_text = yy_cp - yytext_ptr - 1;
        -:11592:
        -:11593:		/* Undo the effects of YY_DO_BEFORE_ACTION. */
     1543:11594:		*yy_cp = yy_hold_char;
        -:11595:
     1543:11596:		if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )
branch  0 taken 553 (fallthrough)
branch  1 taken 990
        -:11597:			{
        -:11598:			/* We're scanning a new file or input source.  It's
        -:11599:			 * possible that this happened because the user
        -:11600:			 * just pointed yyin at a new source and called
        -:11601:			 * yylex().  If so, then we have to assure
        -:11602:			 * consistency between yy_current_buffer and our
        -:11603:			 * globals.  Here is the right place to do so, because
        -:11604:			 * this is the first action (other than possibly a
        -:11605:			 * back-up) that will match for the new input source.
        -:11606:			 */
      553:11607:			yy_n_chars = yy_current_buffer->yy_n_chars;
      553:11608:			yy_current_buffer->yy_input_file = yyin;
      553:11609:			yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;
        -:11610:			}
        -:11611:
        -:11612:		/* Note that here we test for yy_c_buf_p "<=" to the position
        -:11613:		 * of the first EOB in the buffer, since yy_c_buf_p will
        -:11614:		 * already have been incremented past the NUL character
        -:11615:		 * (since all states make transitions on EOB to the
        -:11616:		 * end-of-buffer state).  Contrast this with the test
        -:11617:		 * in input().
        -:11618:		 */
     1543:11619:		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
branch  0 taken 0 (fallthrough)
branch  1 taken 1543
        -:11620:			{ /* This was really a NUL. */
        -:11621:			yy_state_type yy_next_state;
        -:11622:
    #####:11623:			yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;
        -:11624:
    #####:11625:			yy_current_state = yy_get_previous_state();
call    0 never executed
        -:11626:
        -:11627:			/* Okay, we're now positioned to make the NUL
        -:11628:			 * transition.  We couldn't have
        -:11629:			 * yy_get_previous_state() go ahead and do it
        -:11630:			 * for us because it doesn't know how to deal
        -:11631:			 * with the possibility of jamming (and we don't
        -:11632:			 * want to build jamming into it because then it
        -:11633:			 * will run more slowly).
        -:11634:			 */
        -:11635:
    #####:11636:			yy_next_state = yy_try_NUL_trans( yy_current_state );
call    0 never executed
        -:11637:
    #####:11638:			yy_bp = yytext_ptr + YY_MORE_ADJ;
        -:11639:
    #####:11640:			if ( yy_next_state )
branch  0 never executed
branch  1 never executed
        -:11641:				{
        -:11642:				/* Consume the NUL. */
    #####:11643:				yy_cp = ++yy_c_buf_p;
    #####:11644:				yy_current_state = yy_next_state;
    #####:11645:				goto yy_match;
        -:11646:				}
        -:11647:
        -:11648:			else
        -:11649:				{
    #####:11650:							yy_cp = yy_c_buf_p;
    #####:11651:				goto yy_find_action;
        -:11652:				}
        -:11653:			}
        -:11654:
     1543:11655:		else switch ( yy_get_next_buffer() )
call    0 returned 1543
        -:11656:			{
      546:11657:			case EOB_ACT_END_OF_FILE:
        -:11658:				{
      546:11659:				yy_did_buffer_switch_on_eof = 0;
        -:11660:
      546:11661:				if ( yywrap() )
call    0 returned 546
branch  1 taken 545 (fallthrough)
branch  2 taken 1
        -:11662:					{
        -:11663:					/* Note: because we've taken care in
        -:11664:					 * yy_get_next_buffer() to have set up
        -:11665:					 * yytext, we can now set up
        -:11666:					 * yy_c_buf_p so that if some total
        -:11667:					 * hoser (like flex itself) wants to
        -:11668:					 * call the scanner after we return the
        -:11669:					 * YY_NULL, it'll still work - another
        -:11670:					 * YY_NULL will get returned.
        -:11671:					 */
      545:11672:					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;
        -:11673:
      545:11674:					yy_act = YY_STATE_EOF(YY_START);
      545:11675:					goto do_action;
        -:11676:					}
        -:11677:
        -:11678:				else
        -:11679:					{
        1:11680:					if ( ! yy_did_buffer_switch_on_eof )
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:11681:						YY_NEW_FILE;
call    0 returned 1
        -:11682:					}
        1:11683:				break;
        -:11684:				}
        -:11685:
      556:11686:			case EOB_ACT_CONTINUE_SCAN:
      556:11687:				yy_c_buf_p =
      556:11688:					yytext_ptr + yy_amount_of_matched_text;
        -:11689:
      556:11690:				yy_current_state = yy_get_previous_state();
call    0 returned 556
        -:11691:
      556:11692:				yy_cp = yy_c_buf_p;
      556:11693:				yy_bp = yytext_ptr + YY_MORE_ADJ;
      556:11694:				goto yy_match;
        -:11695:
      441:11696:			case EOB_ACT_LAST_MATCH:
      441:11697:				yy_c_buf_p =
      441:11698:				&yy_current_buffer->yy_ch_buf[yy_n_chars];
        -:11699:
      441:11700:				yy_current_state = yy_get_previous_state();
call    0 returned 441
        -:11701:
      441:11702:				yy_cp = yy_c_buf_p;
      441:11703:				yy_bp = yytext_ptr + YY_MORE_ADJ;
      441:11704:				goto yy_find_action;
        -:11705:			}
        1:11706:		break;
        -:11707:		}
        -:11708:
    #####:11709:	default:
    #####:11710:		YY_FATAL_ERROR(
call    0 never executed
        -:11711:			"fatal flex scanner internal error--no action found" );
        -:11712:	} /* end of action switch */
        -:11713:		} /* end of scanning one token */
        -:11714:	} /* end of yylex */
        -:11715:
        -:11716:
        -:11717:/* yy_get_next_buffer - try to read in a new buffer
        -:11718: *
        -:11719: * Returns a code representing an action:
        -:11720: *	EOB_ACT_LAST_MATCH -
        -:11721: *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
        -:11722: *	EOB_ACT_END_OF_FILE - end of file
        -:11723: */
        -:11724:
function yy_get_next_buffer called 1543 returned 100% blocks executed 68%
     1543:11725:static int yy_get_next_buffer()
        -:11726:	{
     1543:11727:	register char *dest = yy_current_buffer->yy_ch_buf;
     1543:11728:	register char *source = yytext_ptr - 1; /* copy prev. char, too */
        -:11729:	register int number_to_move, i;
        -:11730:	int ret_val;
        -:11731:
     1543:11732:	if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
branch  0 taken 0 (fallthrough)
branch  1 taken 1543
    #####:11733:		YY_FATAL_ERROR(
call    0 never executed
        -:11734:		"fatal flex scanner internal error--end of buffer missed" );
        -:11735:
     1543:11736:	if ( yy_current_buffer->yy_fill_buffer == 0 )
branch  0 taken 0 (fallthrough)
branch  1 taken 1543
        -:11737:		{ /* Don't try to fill the buffer, so this is an EOF. */
        -:11738:#ifndef F_AA_4
    #####:11739:		if ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )
branch  0 never executed
branch  1 never executed
        -:11740:#else
        -:11741:		if ( yytext_ptr - yy_c_buf_p - YY_MORE_ADJ == 1 )
        -:11742:#endif
        -:11743:
        -:11744:			{
        -:11745:			/* We matched a singled characater, the EOB, so
        -:11746:			 * treat this as a final EOF.
        -:11747:			 */
    #####:11748:			return EOB_ACT_END_OF_FILE;
        -:11749:			}
        -:11750:
        -:11751:		else
        -:11752:			{
        -:11753:			/* We matched some text prior to the EOB, first
        -:11754:			 * process it.
        -:11755:			 */
    #####:11756:			return EOB_ACT_LAST_MATCH;
        -:11757:			}
        -:11758:		}
        -:11759:
        -:11760:	/* Try to read more data. */
        -:11761:
        -:11762:	/* First move last chars to start of buffer. */
     1543:11763:	number_to_move = yy_c_buf_p - yytext_ptr;
        -:11764:
     3530:11765:	for ( i = 0; i < number_to_move; ++i )
branch  0 taken 1987
branch  1 taken 1543 (fallthrough)
     1987:11766:		*(dest++) = *(source++);
        -:11767:
     1543:11768:	if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )
branch  0 taken 441 (fallthrough)
branch  1 taken 1102
        -:11769:		/* don't do the read, it's not guaranteed to return an EOF,
        -:11770:		 * just force an EOF
        -:11771:		 */
      441:11772:		yy_n_chars = 0;
        -:11773:
        -:11774:	else
        -:11775:		{
     1102:11776:		int num_to_read =
     1102:11777:			yy_current_buffer->yy_buf_size - number_to_move - 1;
        -:11778:
     1102:11779:		while ( num_to_read <= 0 )
branch  0 taken 0
branch  1 taken 1102 (fallthrough)
        -:11780:			{ /* Not enough room in the buffer - grow it. */
        -:11781:#ifdef YY_USES_REJECT
        -:11782:			YY_FATAL_ERROR(
        -:11783:"input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
        -:11784:#else
        -:11785:
        -:11786:			/* just a shorter name for the current buffer */
    #####:11787:			YY_BUFFER_STATE b = yy_current_buffer;
        -:11788:
    #####:11789:			int yy_c_buf_p_offset = yy_c_buf_p - b->yy_ch_buf;
        -:11790:
    #####:11791:			b->yy_buf_size *= 2;
    #####:11792:			b->yy_ch_buf = (char *)
    #####:11793:				yy_flex_realloc( (void *) b->yy_ch_buf,
call    0 never executed
        -:11794:						 b->yy_buf_size );
        -:11795:
    #####:11796:			if ( ! b->yy_ch_buf )
branch  0 never executed
branch  1 never executed
    #####:11797:				YY_FATAL_ERROR(
call    0 never executed
        -:11798:				"fatal error - scanner input buffer overflow" );
        -:11799:
    #####:11800:			yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];
        -:11801:
    #####:11802:			num_to_read = yy_current_buffer->yy_buf_size -
        -:11803:						number_to_move - 1;
        -:11804:#endif
        -:11805:			}
        -:11806:
     1102:11807:		if ( num_to_read > YY_READ_BUF_SIZE )
branch  0 taken 1102 (fallthrough)
branch  1 taken 0
     1102:11808:			num_to_read = YY_READ_BUF_SIZE;
        -:11809:
        -:11810:		/* Read in more data. */
    1102*:11811:		YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
branch  0 taken 0 (fallthrough)
branch  1 taken 1102
call    2 never executed
call    3 returned 1102
branch  4 taken 546 (fallthrough)
branch  5 taken 556
call    6 returned 546
branch  7 taken 0 (fallthrough)
branch  8 taken 546
call    9 never executed
        -:11812:			yy_n_chars, num_to_read );
        -:11813:		}
        -:11814:
     1543:11815:	if ( yy_n_chars == 0 )
branch  0 taken 987 (fallthrough)
branch  1 taken 556
        -:11816:		{
      987:11817:		if ( number_to_move - YY_MORE_ADJ == 1 )
branch  0 taken 546 (fallthrough)
branch  1 taken 441
        -:11818:			{
      546:11819:			ret_val = EOB_ACT_END_OF_FILE;
      546:11820:			yyrestart( yyin );
call    0 returned 546
        -:11821:			}
        -:11822:
        -:11823:		else
        -:11824:			{
      441:11825:			ret_val = EOB_ACT_LAST_MATCH;
      441:11826:			yy_current_buffer->yy_buffer_status =
        -:11827:				YY_BUFFER_EOF_PENDING;
        -:11828:			}
        -:11829:		}
        -:11830:
        -:11831:	else
      556:11832:		ret_val = EOB_ACT_CONTINUE_SCAN;
        -:11833:
     1543:11834:	yy_n_chars += number_to_move;
     1543:11835:	yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
     1543:11836:	yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
        -:11837:
        -:11838:	/* yytext begins at the second character in yy_ch_buf; the first
        -:11839:	 * character is the one which preceded it before reading in the latest
        -:11840:	 * buffer; it needs to be kept around in case it's a newline, so
        -:11841:	 * yy_get_previous_state() will have with '^' rules active.
        -:11842:	 */
        -:11843:
     1543:11844:	yytext_ptr = &yy_current_buffer->yy_ch_buf[1];
        -:11845:
     1543:11846:	return ret_val;
        -:11847:	}
        -:11848:
        -:11849:
        -:11850:/* yy_get_previous_state - get the state just before the EOB char was reached */
        -:11851:
function yy_get_previous_state called 997 returned 100% blocks executed 94%
      997:11852:static yy_state_type yy_get_previous_state()
        -:11853:	{
        -:11854:	register yy_state_type yy_current_state;
        -:11855:	register char *yy_cp;
        -:11856:
      997:11857:	register char *yy_bp = yytext_ptr;
        -:11858:
      997:11859:	yy_current_state = yy_start;
      997:11860:	if ( yy_bp[-1] == '\n' )
branch  0 taken 567 (fallthrough)
branch  1 taken 430
      567:11861:		++yy_current_state;
        -:11862:
     1441:11863:	for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
branch  0 taken 444
branch  1 taken 997 (fallthrough)
        -:11864:		{
     444*:11865:		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
branch  0 taken 444 (fallthrough)
branch  1 taken 0
      444:11866:		if ( yy_accept[yy_current_state] )
branch  0 taken 2 (fallthrough)
branch  1 taken 442
        -:11867:			{
        2:11868:			yy_last_accepting_state = yy_current_state;
        2:11869:			yy_last_accepting_cpos = yy_cp;
        -:11870:			}
      454:11871:		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
branch  0 taken 10
branch  1 taken 444 (fallthrough)
        -:11872:			{
       10:11873:			yy_current_state = (int) yy_def[yy_current_state];
       10:11874:			if ( yy_current_state >= 408 )
branch  0 taken 1 (fallthrough)
branch  1 taken 9
        1:11875:				yy_c = yy_meta[(unsigned int) yy_c];
        -:11876:			}
      444:11877:		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
        -:11878:		}
        -:11879:
      997:11880:	return yy_current_state;
        -:11881:	}
        -:11882:
        -:11883:
        -:11884:/* yy_try_NUL_trans - try to make a transition on the NUL character
        -:11885: *
        -:11886: * synopsis
        -:11887: *	next_state = yy_try_NUL_trans( current_state );
        -:11888: */
        -:11889:
        -:11890:#ifdef YY_USE_PROTOS
function yy_try_NUL_trans called 0 returned 0% blocks executed 0%
    #####:11891:static yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )
        -:11892:#else
        -:11893:static yy_state_type yy_try_NUL_trans( yy_current_state )
        -:11894:yy_state_type yy_current_state;
        -:11895:#endif
        -:11896:	{
        -:11897:	register int yy_is_jam;
    #####:11898:	register char *yy_cp = yy_c_buf_p;
        -:11899:
    #####:11900:	register YY_CHAR yy_c = 1;
    #####:11901:	if ( yy_accept[yy_current_state] )
branch  0 never executed
branch  1 never executed
        -:11902:		{
    #####:11903:		yy_last_accepting_state = yy_current_state;
    #####:11904:		yy_last_accepting_cpos = yy_cp;
        -:11905:		}
    #####:11906:	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
branch  0 never executed
branch  1 never executed
        -:11907:		{
    #####:11908:		yy_current_state = (int) yy_def[yy_current_state];
    #####:11909:		if ( yy_current_state >= 408 )
branch  0 never executed
branch  1 never executed
    #####:11910:			yy_c = yy_meta[(unsigned int) yy_c];
        -:11911:		}
    #####:11912:	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
    #####:11913:	yy_is_jam = (yy_current_state == 407);
        -:11914:
    #####:11915:	return yy_is_jam ? 0 : yy_current_state;
branch  0 never executed
branch  1 never executed
        -:11916:	}
        -:11917:
        -:11918:
        -:11919:#ifdef YY_USE_PROTOS
function yyunput called 3959 returned 100% blocks executed 50%
     3959:11920:static void yyunput( int c, register char *yy_bp )
        -:11921:#else
        -:11922:static void yyunput( c, yy_bp )
        -:11923:int c;
        -:11924:register char *yy_bp;
        -:11925:#endif
        -:11926:	{
     3959:11927:	register char *yy_cp = yy_c_buf_p;
        -:11928:
        -:11929:	/* undo effects of setting up yytext */
     3959:11930:	*yy_cp = yy_hold_char;
        -:11931:
     3959:11932:	if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
branch  0 taken 0 (fallthrough)
branch  1 taken 3959
        -:11933:		{ /* need to shift things up to make room */
        -:11934:		/* +2 for EOB chars. */
    #####:11935:		register int number_to_move = yy_n_chars + 2;
    #####:11936:		register char *dest = &yy_current_buffer->yy_ch_buf[
    #####:11937:					yy_current_buffer->yy_buf_size + 2];
    #####:11938:		register char *source =
    #####:11939:				&yy_current_buffer->yy_ch_buf[number_to_move];
        -:11940:
    #####:11941:		while ( source > yy_current_buffer->yy_ch_buf )
branch  0 never executed
branch  1 never executed
    #####:11942:			*--dest = *--source;
        -:11943:
    #####:11944:		yy_cp += dest - source;
    #####:11945:		yy_bp += dest - source;
    #####:11946:		yy_n_chars = yy_current_buffer->yy_buf_size;
        -:11947:
    #####:11948:		if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
branch  0 never executed
branch  1 never executed
    #####:11949:			YY_FATAL_ERROR( "flex scanner push-back overflow" );
call    0 never executed
        -:11950:		}
        -:11951:
     3959:11952:	if ( yy_cp > yy_bp && yy_cp[-1] == '\n' )
branch  0 taken 2639 (fallthrough)
branch  1 taken 1320
branch  2 taken 21 (fallthrough)
branch  3 taken 2618
       21:11953:		yy_cp[-2] = '\n';
        -:11954:
     3959:11955:	*--yy_cp = (char) c;
        -:11956:
        -:11957:
        -:11958:	/* Note: the formal parameter *must* be called "yy_bp" for this
        -:11959:	 * macro to now work correctly.
        -:11960:	 */
     3959:11961:	YY_DO_BEFORE_ACTION; /* set up yytext again */
     3959:11962:	}
        -:11963:
        -:11964:
        -:11965:#ifdef __cplusplus
        -:11966:static int yyinput()
        -:11967:#else
function input called 231 returned 100% blocks executed 20%
      231:11968:static int input()
        -:11969:#endif
        -:11970:	{
        -:11971:	int c;
        -:11972:
      231:11973:	*yy_c_buf_p = yy_hold_char;
        -:11974:
      231:11975:	if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
branch  0 taken 0 (fallthrough)
branch  1 taken 231
        -:11976:		{
        -:11977:		/* yy_c_buf_p now points to the character we want to return.
        -:11978:		 * If this occurs *before* the EOB characters, then it's a
        -:11979:		 * valid NUL; if not, then we've hit the end of the buffer.
        -:11980:		 */
    #####:11981:		if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
branch  0 never executed
branch  1 never executed
        -:11982:			/* This was really a NUL. */
    #####:11983:			*yy_c_buf_p = '\0';
        -:11984:
        -:11985:		else
        -:11986:			{ /* need more input */
    #####:11987:			yytext_ptr = yy_c_buf_p;
    #####:11988:			++yy_c_buf_p;
        -:11989:
    #####:11990:			switch ( yy_get_next_buffer() )
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -:11991:				{
    #####:11992:				case EOB_ACT_END_OF_FILE:
        -:11993:					{
    #####:11994:					if ( yywrap() )
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:11995:						{
    #####:11996:						yy_c_buf_p =
        -:11997:						yytext_ptr + YY_MORE_ADJ;
    #####:11998:						return EOF;
        -:11999:						}
        -:12000:
    #####:12001:					YY_NEW_FILE;
call    0 never executed
        -:12002:#ifdef __cplusplus
        -:12003:					return yyinput();
        -:12004:#else
    #####:12005:					return input();
call    0 never executed
        -:12006:#endif
        -:12007:					}
        -:12008:
    #####:12009:				case EOB_ACT_CONTINUE_SCAN:
    #####:12010:					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;
    #####:12011:					break;
        -:12012:
    #####:12013:				case EOB_ACT_LAST_MATCH:
        -:12014:#ifdef __cplusplus
        -:12015:					YY_FATAL_ERROR(
        -:12016:					"unexpected last match in yyinput()" );
        -:12017:#else
    #####:12018:					YY_FATAL_ERROR(
call    0 never executed
        -:12019:					"unexpected last match in input()" );
        -:12020:#endif
        -:12021:				}
        -:12022:			}
        -:12023:		}
        -:12024:
      231:12025:	c = *(unsigned char *) yy_c_buf_p;	/* cast for 8-bit char's */
      231:12026:	*yy_c_buf_p = '\0';	/* preserve yytext */
      231:12027:	yy_hold_char = *++yy_c_buf_p;
        -:12028:
      231:12029:	return c;
        -:12030:	}
        -:12031:
        -:12032:
        -:12033:#ifdef YY_USE_PROTOS
function yyrestart called 547 returned 100% blocks executed 67%
      547:12034:void yyrestart( FILE *input_file )
        -:12035:#else
        -:12036:void yyrestart( input_file )
        -:12037:FILE *input_file;
        -:12038:#endif
        -:12039:	{
      547:12040:	if ( ! yy_current_buffer )
branch  0 taken 0 (fallthrough)
branch  1 taken 547
    #####:12041:		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );
call    0 never executed
        -:12042:
      547:12043:	yy_init_buffer( yy_current_buffer, input_file );
call    0 returned 547
      547:12044:	yy_load_buffer_state();
call    0 returned 547
      547:12045:	}
        -:12046:
        -:12047:
        -:12048:#ifdef YY_USE_PROTOS
function yy_switch_to_buffer called 0 returned 0% blocks executed 0%
    #####:12049:void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
        -:12050:#else
        -:12051:void yy_switch_to_buffer( new_buffer )
        -:12052:YY_BUFFER_STATE new_buffer;
        -:12053:#endif
        -:12054:	{
    #####:12055:	if ( yy_current_buffer == new_buffer )
branch  0 never executed
branch  1 never executed
    #####:12056:		return;
        -:12057:
    #####:12058:	if ( yy_current_buffer )
branch  0 never executed
branch  1 never executed
        -:12059:		{
        -:12060:		/* Flush out information for old buffer. */
    #####:12061:		*yy_c_buf_p = yy_hold_char;
    #####:12062:		yy_current_buffer->yy_buf_pos = yy_c_buf_p;
    #####:12063:		yy_current_buffer->yy_n_chars = yy_n_chars;
        -:12064:		}
        -:12065:
    #####:12066:	yy_current_buffer = new_buffer;
    #####:12067:	yy_load_buffer_state();
call    0 never executed
        -:12068:
        -:12069:	/* We don't actually know whether we did this switch during
        -:12070:	 * EOF (yywrap()) processing, but the only time this flag
        -:12071:	 * is looked at is after yywrap() is called, so it's safe
        -:12072:	 * to go ahead and always set it.
        -:12073:	 */
    #####:12074:	yy_did_buffer_switch_on_eof = 1;
        -:12075:	}
        -:12076:
        -:12077:
        -:12078:#ifdef YY_USE_PROTOS
function yy_load_buffer_state called 1099 returned 100% blocks executed 100%
     1099:12079:void yy_load_buffer_state( void )
        -:12080:#else
        -:12081:void yy_load_buffer_state()
        -:12082:#endif
        -:12083:	{
     1099:12084:	yy_n_chars = yy_current_buffer->yy_n_chars;
     1099:12085:	yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
     1099:12086:	yyin = yy_current_buffer->yy_input_file;
     1099:12087:	yy_hold_char = *yy_c_buf_p;
     1099:12088:	}
        -:12089:
        -:12090:
        -:12091:#ifdef YY_USE_PROTOS
function yy_create_buffer called 552 returned 100% blocks executed 78%
      552:12092:YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )
        -:12093:#else
        -:12094:YY_BUFFER_STATE yy_create_buffer( file, size )
        -:12095:FILE *file;
        -:12096:int size;
        -:12097:#endif
        -:12098:	{
        -:12099:	YY_BUFFER_STATE b;
        -:12100:
      552:12101:	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
call    0 returned 552
        -:12102:
      552:12103:	if ( ! b )
branch  0 taken 0 (fallthrough)
branch  1 taken 552
    #####:12104:		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
call    0 never executed
        -:12105:
      552:12106:	b->yy_buf_size = size;
        -:12107:
        -:12108:	/* yy_ch_buf has to be 2 characters longer than the size given because
        -:12109:	 * we need to put in 2 end-of-buffer characters.
        -:12110:	 */
      552:12111:	b->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );
call    0 returned 552
        -:12112:
      552:12113:	if ( ! b->yy_ch_buf )
branch  0 taken 0 (fallthrough)
branch  1 taken 552
    #####:12114:		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
call    0 never executed
        -:12115:
      552:12116:	yy_init_buffer( b, file );
call    0 returned 552
        -:12117:
      552:12118:	return b;
        -:12119:	}
        -:12120:
        -:12121:
        -:12122:#ifdef YY_USE_PROTOS
function yy_delete_buffer called 0 returned 0% blocks executed 0%
    #####:12123:void yy_delete_buffer( YY_BUFFER_STATE b )
        -:12124:#else
        -:12125:void yy_delete_buffer( b )
        -:12126:YY_BUFFER_STATE b;
        -:12127:#endif
        -:12128:	{
    #####:12129:	if ( b == yy_current_buffer )
branch  0 never executed
branch  1 never executed
    #####:12130:		yy_current_buffer = (YY_BUFFER_STATE) 0;
        -:12131:
    #####:12132:	yy_flex_free( (void *) b->yy_ch_buf );
call    0 never executed
    #####:12133:	yy_flex_free( (void *) b );
call    0 never executed
    #####:12134:	}
        -:12135:
        -:12136:
        -:12137:#ifdef YY_USE_PROTOS
function yy_init_buffer called 1099 returned 100% blocks executed 80%
     1099:12138:void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )
        -:12139:#else
        -:12140:void yy_init_buffer( b, file )
        -:12141:YY_BUFFER_STATE b;
        -:12142:FILE *file;
        -:12143:#endif
        -:12144:	{
     1099:12145:	b->yy_input_file = file;
        -:12146:
        -:12147:	/* We put in the '\n' and start reading from [1] so that an
        -:12148:	 * initial match-at-newline will be true.
        -:12149:	 */
        -:12150:
     1099:12151:	b->yy_ch_buf[0] = '\n';
     1099:12152:	b->yy_n_chars = 1;
        -:12153:
        -:12154:	/* We always need two end-of-buffer characters.  The first causes
        -:12155:	 * a transition to the end-of-buffer state.  The second causes
        -:12156:	 * a jam in that state.
        -:12157:	 */
     1099:12158:	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
     1099:12159:	b->yy_ch_buf[2] = YY_END_OF_BUFFER_CHAR;
        -:12160:
     1099:12161:	b->yy_buf_pos = &b->yy_ch_buf[1];
        -:12162:
    1099*:12163:	b->yy_is_interactive = file ? isatty( fileno(file) ) : 0;
branch  0 taken 1099 (fallthrough)
branch  1 taken 0
call    2 returned 1099
call    3 returned 1099
        -:12164:
     1099:12165:	b->yy_fill_buffer = 1;
        -:12166:
     1099:12167:	b->yy_buffer_status = YY_BUFFER_NEW;
     1099:12168:	}
        -:12169:
        -:12170:
        -:12171:#ifdef YY_USE_PROTOS
function yy_push_state called 0 returned 0% blocks executed 0%
    #####:12172:static void yy_push_state( int new_state )
        -:12173:#else
        -:12174:static void yy_push_state( new_state )
        -:12175:int new_state;
        -:12176:#endif
        -:12177:	{
    #####:12178:	if ( yy_start_stack_ptr >= yy_start_stack_depth )
branch  0 never executed
branch  1 never executed
        -:12179:		{
        -:12180:		int new_size;
        -:12181:
    #####:12182:		yy_start_stack_depth += YY_START_STACK_INCR;
    #####:12183:		new_size = yy_start_stack_depth * sizeof( int );
        -:12184:
    #####:12185:		if ( ! yy_start_stack )
branch  0 never executed
branch  1 never executed
    #####:12186:			yy_start_stack = (int *) yy_flex_alloc( new_size );
call    0 never executed
        -:12187:
        -:12188:		else
    #####:12189:			yy_start_stack = (int *) yy_flex_realloc(
call    0 never executed
        -:12190:					(void *) yy_start_stack, new_size );
        -:12191:
    #####:12192:		if ( ! yy_start_stack )
branch  0 never executed
branch  1 never executed
    #####:12193:			YY_FATAL_ERROR(
call    0 never executed
        -:12194:			"out of memory expanding start-condition stack" );
        -:12195:		}
        -:12196:
    #####:12197:	yy_start_stack[yy_start_stack_ptr++] = YY_START;
        -:12198:
    #####:12199:	BEGIN(new_state);
    #####:12200:	}
        -:12201:
        -:12202:
function yy_pop_state called 0 returned 0% blocks executed 0%
    #####:12203:static void yy_pop_state()
        -:12204:	{
    #####:12205:	if ( --yy_start_stack_ptr < 0 )
branch  0 never executed
branch  1 never executed
    #####:12206:		YY_FATAL_ERROR( "start-condition stack underflow" );
call    0 never executed
        -:12207:
    #####:12208:	BEGIN(yy_start_stack[yy_start_stack_ptr]);
    #####:12209:	}
        -:12210:
        -:12211:
function yy_top_state called 0 returned 0% blocks executed 0%
    #####:12212:static int yy_top_state()
        -:12213:	{
    #####:12214:	return yy_start_stack[yy_start_stack_ptr - 1];
        -:12215:	}
        -:12216:
        -:12217:
        -:12218:#ifdef YY_USE_PROTOS
function yy_fatal_error called 0 returned 0% blocks executed 0%
    #####:12219:static void yy_fatal_error( const char msg[] )
        -:12220:#else
        -:12221:static void yy_fatal_error( msg )
        -:12222:char msg[];
        -:12223:#endif
        -:12224:	{
    #####:12225:	(void) fprintf( err, "%s\n", msg );
call    0 never executed
    #####:12226:	exit( 1 );
        -:12227:	}
        -:12228:
        -:12229:
        -:12230:
        -:12231:/* Redefine yyless() so it works in section 3 code. */
        -:12232:
        -:12233:#undef yyless
        -:12234:#define yyless(n) \
        -:12235:	do \
        -:12236:		{ \
        -:12237:		/* Undo effects of setting up yytext. */ \
        -:12238:		yytext[yyleng] = yy_hold_char; \
        -:12239:		yy_c_buf_p = yytext + n - YY_MORE_ADJ; \
        -:12240:		yy_hold_char = *yy_c_buf_p; \
        -:12241:		*yy_c_buf_p = '\0'; \
        -:12242:		yyleng = n; \
        -:12243:		} \
        -:12244:	while ( 0 )
        -:12245:
        -:12246:
        -:12247:/* Internal utility routines. */
        -:12248:
        -:12249:#ifndef yytext_ptr
        -:12250:#ifdef YY_USE_PROTOS
        -:12251:static void yy_flex_strncpy( char *s1, const char *s2, int n )
        -:12252:#else
        -:12253:static void yy_flex_strncpy( s1, s2, n )
        -:12254:char *s1;
        -:12255:const char *s2;
        -:12256:int n;
        -:12257:#endif
        -:12258:	{
        -:12259:	register int i;
        -:12260:	for ( i = 0; i < n; ++i )
        -:12261:		s1[i] = s2[i];
        -:12262:	}
        -:12263:#endif
        -:12264:
        -:12265:
        -:12266:#ifdef YY_USE_PROTOS
function yy_flex_alloc called 44579 returned 100% blocks executed 100%
    44579:12267:static void *yy_flex_alloc( unsigned int size )
        -:12268:#else
        -:12269:static void *yy_flex_alloc( size )
        -:12270:unsigned int size;
        -:12271:#endif
        -:12272:	{
    44579:12273:	return (void *) malloc( size );
        -:12274:	}
        -:12275:
        -:12276:#ifdef YY_USE_PROTOS
function yy_flex_realloc called 171 returned 100% blocks executed 100%
      171:12277:static void *yy_flex_realloc( void *ptr, unsigned int size )
        -:12278:#else
        -:12279:static void *yy_flex_realloc( ptr, size )
        -:12280:void *ptr;
        -:12281:unsigned int size;
        -:12282:#endif
        -:12283:	{
      171:12284:	return (void *) realloc( ptr, size );
        -:12285:	}
        -:12286:
        -:12287:#ifdef YY_USE_PROTOS
function yy_flex_free called 1086 returned 100% blocks executed 100%
     1086:12288:static void yy_flex_free( void *ptr )
        -:12289:#else
        -:12290:static void yy_flex_free( ptr )
        -:12291:void *ptr;
        -:12292:#endif
        -:12293:	{
     1086:12294:	free( ptr );
     1086:12295:	}
        -:12296:
        -:12297:
        -:12298:
function yywrap called 546 returned 100% blocks executed 100%
      546:12299:int yywrap()
        -:12300:	{
      546:12301:	if ( --num_input_files > 0 )
branch  0 taken 1 (fallthrough)
branch  1 taken 545
        -:12302:		{
        1:12303:		set_input_file( *++input_files );
call    0 returned 1
        1:12304:		return 0;
        -:12305:		}
        -:12306:
        -:12307:	else
      545:12308:		return 1;
        -:12309:	}
        -:12310:
        -:12311:
        -:12312:/* set_input_file - open the given file (if NULL, stdin) for scanning */
        -:12313:
function set_input_file called 555 returned 100% blocks executed 83%
      555:12314:void set_input_file( file )
        -:12315:char *file;
        -:12316:	{
      555:12317:	if ( file )
branch  0 taken 555 (fallthrough)
branch  1 taken 0
        -:12318:		{
      555:12319:		infilename = file;
      555:12320:		yyin = fopen( infilename, "r" );
call    0 returned 555
        -:12321:
      555:12322:		if ( yyin == NULL )
branch  0 taken 1 (fallthrough)
branch  1 taken 554
        1:12323:			lerrsf( "can't open %s", file );
call    0 returned 0
        -:12324:		}
        -:12325:
        -:12326:	else
        -:12327:		{
    #####:12328:		yyin = stdin;
    #####:12329:		infilename = "<stdin>";
        -:12330:		}
      554:12331:	}
        -:12332:
        -:12333:
        -:12334:/* Wrapper routines for accessing the scanner's malloc routines. */
        -:12335:
function flex_alloc called 43475 returned 100% blocks executed 100%
    43475:12336:void *flex_alloc( size )
        -:12337:unsigned int size;
        -:12338:	{
    43475:12339:	return yy_flex_alloc( size );
call    0 returned 43475
        -:12340:	}
        -:12341:
function flex_realloc called 171 returned 100% blocks executed 100%
      171:12342:void *flex_realloc( ptr, size )
        -:12343:void *ptr;
        -:12344:unsigned int size;
        -:12345:	{
      171:12346:	return yy_flex_realloc( ptr, size );
call    0 returned 171
        -:12347:	}
        -:12348:
function flex_free called 1086 returned 100% blocks executed 100%
     1086:12349:void flex_free( ptr )
        -:12350:void *ptr;
        -:12351:	{
     1086:12352:	yy_flex_free( ptr );
call    0 returned 1086
     1086:12353:	}
