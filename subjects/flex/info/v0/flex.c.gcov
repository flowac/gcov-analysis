        -:    0:Source:flex.c
        -:    0:Graph:flex.gcno
        -:    0:Data:flex.gcda
        -:    0:Runs:564
        -:    1:/* flex - tool to generate fast lexical analyzers */
        -:    2:
        -:    3:/*-
        -:    4: * Copyright (c) 1990 The Regents of the University of California.
        -:    5: * All rights reserved.
        -:    6: *
        -:    7: * This code is derived from software contributed to Berkeley by
        -:    8: * Vern Paxson.
        -:    9: * 
        -:   10: * The United States Government has rights in this work pursuant
        -:   11: * to contract no. DE-AC03-76SF00098 between the United States
        -:   12: * Department of Energy and the University of California.
        -:   13: *
        -:   14: * Redistribution and use in source and binary forms are permitted provided
        -:   15: * that: (1) source distributions retain this entire copyright notice and
        -:   16: * comment, and (2) distributions including binaries display the following
        -:   17: * acknowledgement:  ``This product includes software developed by the
        -:   18: * University of California, Berkeley and its contributors'' in the
        -:   19: * documentation or other materials provided with the distribution and in
        -:   20: * all advertising materials mentioning features or use of this software.
        -:   21: * Neither the name of the University nor the names of its contributors may
        -:   22: * be used to endorse or promote products derived from this software without
        -:   23: * specific prior written permission.
        -:   24: * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
        -:   25: * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
        -:   26: * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
        -:   27: */
        -:   28:
        -:   29:#define LINUX 1
        -:   30:
        -:   31:#ifndef lint
        -:   32:char copyright[] =
        -:   33:"@(#) Copyright (c) 1990 The Regents of the University of California.\n\
        -:   34: All rights reserved.\n";
        -:   35:#endif /* not lint */
        -:   36:
        -:   37:/* $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.orig/v0/flex.c,v 1.1.1.1 2003/06/02 17:12:00 expsir Exp $ */
        -:   38:
        -:   39:
        -:   40:#include "flexdef.h"
        -:   41:#include "version.h"
        -:   42:#include <ctype.h> 
        -:   43:#include "parse.h"
        -:   44:
        -:   45:static char flex_version[] = FLEX_VERSION;
        -:   46:
        -:   47:
        -:   48:/* declare functions that have forward references */
        -:   49:
        -:   50:void flexinit PROTO((int, char**));
        -:   51:void readin PROTO((void));
        -:   52:void set_up_initial_allocations PROTO((void));
        -:   53:
        -:   54:
        -:   55:/* these globals are all defined and commented in flexdef.h */
        -:   56:int printstats, syntaxerror, eofseen, ddebug, trace, nowarn, spprdflt;
        -:   57:int interactive, caseins, lex_compat, useecs, fulltbl, usemecs;
        -:   58:int fullspd, gen_line_dirs, performance_report, backing_up_report;
        -:   59:int C_plus_plus, long_align, use_read, yytext_is_array, csize;
        -:   60:int yymore_used, reject, real_reject, continued_action;
        -:   61:int yymore_really_used, reject_really_used;
        -:   62:int datapos, dataline, linenum;
        -:   63:FILE *skelfile = NULL;
        -:   64:
        -:   65:/* ### add for testing ### */
        -:   66:FILE *err = NULL;
        -:   67:/* ####################### */
        -:   68:
        -:   69:int skel_ind = 0;
        -:   70:char *action_array;
        -:   71:int action_size, defs1_offset, prolog_offset, action_offset, action_index;
        -:   72:char *infilename = NULL;
        -:   73:int onestate[ONE_STACK_SIZE], onesym[ONE_STACK_SIZE];
        -:   74:int onenext[ONE_STACK_SIZE], onedef[ONE_STACK_SIZE], onesp;
        -:   75:int current_mns, num_rules, num_eof_rules, default_rule;
        -:   76:int current_max_rules, lastnfa;
        -:   77:int *firstst, *lastst, *finalst, *transchar, *trans1, *trans2;
        -:   78:int *accptnum, *assoc_rule, *state_type;
        -:   79:int *rule_type, *rule_linenum, *rule_useful;
        -:   80:int current_state_type;
        -:   81:int variable_trailing_context_rules;
        -:   82:int numtemps, numprots, protprev[MSP], protnext[MSP], prottbl[MSP];
        -:   83:int protcomst[MSP], firstprot, lastprot, protsave[PROT_SAVE_SIZE];
        -:   84:int numecs, nextecm[CSIZE + 1], ecgroup[CSIZE + 1], nummecs, tecfwd[CSIZE + 1];
        -:   85:int tecbck[CSIZE + 1];
        -:   86:int lastsc, current_max_scs, *scset, *scbol, *scxclu, *sceof, *actvsc;
        -:   87:char **scname;
        -:   88:int current_max_dfa_size, current_max_xpairs;
        -:   89:int current_max_template_xpairs, current_max_dfas;
        -:   90:int lastdfa, *nxt, *chk, *tnxt;
        -:   91:int *base, *def, *nultrans, NUL_ec, tblend, firstfree, **dss, *dfasiz;
        -:   92:union dfaacc_union *dfaacc;
        -:   93:int *accsiz, *dhash, numas;
        -:   94:int numsnpairs, jambase, jamstate;
        -:   95:int lastccl, current_maxccls, *cclmap, *ccllen, *cclng, cclreuse;
        -:   96:int current_max_ccl_tbl_size;
        -:   97:Char *ccltbl;
        -:   98:char nmstr[MAXLINE];
        -:   99:int sectnum, nummt, hshcol, dfaeql, numeps, eps2, num_reallocs;
        -:  100:int tmpuses, totnst, peakpairs, numuniq, numdup, hshsave;
        -:  101:int num_backing_up, bol_needed;
        -:  102:FILE *backing_up_file;
        -:  103:int end_of_buffer_state;
        -:  104:char **input_files;
        -:  105:int num_input_files;
        -:  106:char *program_name;
        -:  107:
        -:  108:#ifndef SHORT_FILE_NAMES
        -:  109:static char *outfile_template = "lex.%s.%s";
        -:  110:#else
        -:  111:static char *outfile_template = "lex%s.%s";
        -:  112:#endif
        -:  113:static char outfile_path[64];
        -:  114:
        -:  115:static int outfile_created = 0;
        -:  116:static int use_stdout;
        -:  117:static char *skelname = NULL;
        -:  118:static char *prefix = "yy";
        -:  119:
        -:  120:
function main called 564 returned 0% blocks executed 91%
      564:  121:int main( argc, argv )
        -:  122:int argc;
        -:  123:char **argv;
        -:  124:	{
        -:  125:	int i;
        -:  126:
        -:  127:/* ### add for testing ### */
      564:  128:	if(--argc >0){
branch  0 taken 564 (fallthrough)
branch  1 taken 0
      564:  129:		err = fopen( *++argv, "w" );
call    0 returned 564
      564:  130:		--argv; ++argc;
        -:  131:	}
        -:  132:/* ####################### */
        -:  133:
      564:  134:	flexinit( argc, argv );
call    0 returned 549
        -:  135:
      549:  136:	readin();
call    0 returned 549
        -:  137:
      549:  138:	if ( syntaxerror )
branch  0 taken 6 (fallthrough)
branch  1 taken 543
        6:  139:		flexend( 1 );
call    0 returned 0
        -:  140:
      543:  141:	if ( yymore_really_used == REALLY_USED )
branch  0 taken 162 (fallthrough)
branch  1 taken 381
      162:  142:		yymore_used = true;
      381:  143:	else if ( yymore_really_used == REALLY_NOT_USED )
branch  0 taken 0 (fallthrough)
branch  1 taken 381
    #####:  144:		yymore_used = false;
        -:  145:
      543:  146:	if ( reject_really_used == REALLY_USED )
branch  0 taken 162 (fallthrough)
branch  1 taken 381
      162:  147:		reject = true;
      381:  148:	else if ( reject_really_used == REALLY_NOT_USED )
branch  0 taken 0 (fallthrough)
branch  1 taken 381
    #####:  149:		reject = false;
        -:  150:
      543:  151:	if ( performance_report > 0 )
branch  0 taken 12 (fallthrough)
branch  1 taken 531
        -:  152:		{
       12:  153:		if ( lex_compat )
branch  0 taken 2 (fallthrough)
branch  1 taken 10
        -:  154:			{
        2:  155:			fprintf( err,
call    0 returned 2
        -:  156:"-l AT&T lex compatibility option entails a large performance penalty\n" );
        2:  157:			fprintf( err,
call    0 returned 2
        -:  158:" and may be the actual source of other reported performance penalties\n" );
        -:  159:			}
        -:  160:
       12:  161:		if ( performance_report > 1 )
branch  0 taken 1 (fallthrough)
branch  1 taken 11
        -:  162:			{
        1:  163:			if ( interactive )
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:  164:				fprintf( err,
call    0 returned 1
        -:  165:		"-I (interactive) entails a minor performance penalty\n" );
        -:  166:
        1:  167:			if ( yymore_used )
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:  168:				fprintf( err,
call    0 never executed
        -:  169:			"yymore() entails a minor performance penalty\n" );
        -:  170:			}
        -:  171:
       12:  172:		if ( reject )
branch  0 taken 5 (fallthrough)
branch  1 taken 7
        5:  173:			fprintf( err,
call    0 returned 5
        -:  174:			"REJECT entails a large performance penalty\n" );
        -:  175:
       12:  176:		if ( variable_trailing_context_rules )
branch  0 taken 1 (fallthrough)
branch  1 taken 11
        1:  177:			fprintf( err,
call    0 returned 1
        -:  178:"Variable trailing context rules entail a large performance penalty\n" );
        -:  179:		}
        -:  180:
      543:  181:	if ( reject )
branch  0 taken 168 (fallthrough)
branch  1 taken 375
      168:  182:		real_reject = true;
        -:  183:
      543:  184:	if ( variable_trailing_context_rules )
branch  0 taken 35 (fallthrough)
branch  1 taken 508
       35:  185:		reject = true;
        -:  186:
      543:  187:	if ( (fulltbl || fullspd) && reject )
branch  0 taken 519 (fallthrough)
branch  1 taken 24
branch  2 taken 93 (fallthrough)
branch  3 taken 426
branch  4 taken 2 (fallthrough)
branch  5 taken 115
        -:  188:		{
        2:  189:		if ( real_reject )
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2:  190:			flexerror( "REJECT cannot be used with -f or -F" );
call    0 returned 0
        -:  191:		else
    #####:  192:			flexerror(
call    0 never executed
        -:  193:	"variable trailing context rules cannot be used with -f or -F" );
        -:  194:		}
        -:  195:
      541:  196:	ntod();
call    0 returned 541
        -:  197:
     3782:  198:	for ( i = 1; i <= num_rules; ++i )
branch  0 taken 3241
branch  1 taken 541 (fallthrough)
     3241:  199:		if ( ! rule_useful[i] && i != default_rule )
branch  0 taken 79 (fallthrough)
branch  1 taken 3162
branch  2 taken 6 (fallthrough)
branch  3 taken 73
        6:  200:			line_warning( "rule cannot be matched",
        6:  201:					rule_linenum[i] );
call    0 returned 6
        -:  202:
      541:  203:	if ( spprdflt && ! reject && rule_useful[default_rule] )
branch  0 taken 3 (fallthrough)
branch  1 taken 538
branch  2 taken 1 (fallthrough)
branch  3 taken 2
branch  4 taken 1 (fallthrough)
branch  5 taken 0
        1:  204:		line_warning( "-s option given but default rule can be matched",
        1:  205:			rule_linenum[default_rule] );
call    0 returned 1
        -:  206:
        -:  207:	/* Generate the C state transition tables from the DFA. */
      541:  208:	make_tables();
call    0 returned 541
        -:  209:
        -:  210:	/* Note, flexend does not return.  It exits with its argument
        -:  211:	 * as status.
        -:  212:	 */
      541:  213:	flexend( 0 );
call    0 returned 0
        -:  214:
        -:  215:
    #####:  216:	return 0;	/* keep compilers/lint happy */
        -:  217:	}
        -:  218:
        -:  219:
        -:  220:/* flexend - terminate flex
        -:  221: *
        -:  222: * note
        -:  223: *    This routine does not return.
        -:  224: */
        -:  225:
function flexend called 561 returned 0% blocks executed 88%
      561:  226:void flexend( exit_status )
        -:  227:int exit_status;
        -:  228:
        -:  229:	{
        -:  230:	int tblsiz;
        -:  231:	int unlink();
        -:  232:
      561:  233:	if ( skelfile != NULL )
branch  0 taken 2 (fallthrough)
branch  1 taken 559
        -:  234:		{
        2:  235:		if ( ferror( skelfile ) )
call    0 returned 2
branch  1 taken 0 (fallthrough)
branch  2 taken 2
    #####:  236:			flexfatal(
call    0 never executed
        -:  237:				"error occurred when reading skeleton file" );
        -:  238:
        2:  239:		else if ( fclose( skelfile ) )
call    0 returned 2
branch  1 taken 0 (fallthrough)
branch  2 taken 2
    #####:  240:			flexfatal(
call    0 never executed
        -:  241:				"error occurred when closing skeleton file" );
        -:  242:		}
        -:  243:
      561:  244:	if ( exit_status != 0 && outfile_created )
branch  0 taken 20 (fallthrough)
branch  1 taken 541
branch  2 taken 10 (fallthrough)
branch  3 taken 10
        -:  245:		{
       10:  246:		if ( ferror( stdout ) )
call    0 returned 10
branch  1 taken 0 (fallthrough)
branch  2 taken 10
    #####:  247:			flexfatal( "error occurred when writing output file" );
call    0 never executed
        -:  248:
       10:  249:		else if ( fclose( stdout ) )
call    0 returned 10
branch  1 taken 0 (fallthrough)
branch  2 taken 10
    #####:  250:			flexfatal( "error occurred when closing output file" );
call    0 never executed
        -:  251:
       10:  252:		else if ( unlink( outfile_path ) )
call    0 returned 10
branch  1 taken 0 (fallthrough)
branch  2 taken 10
    #####:  253:			flexfatal( "error occurred when deleting output file" );
call    0 never executed
        -:  254:		}
        -:  255:
      561:  256:	if ( backing_up_report && backing_up_file )
branch  0 taken 5 (fallthrough)
branch  1 taken 556
branch  2 taken 5 (fallthrough)
branch  3 taken 0
        -:  257:		{
        5:  258:		if ( num_backing_up == 0 )
branch  0 taken 0 (fallthrough)
branch  1 taken 5
    #####:  259:			fprintf( backing_up_file, "No backing up.\n" );
call    0 never executed
        5:  260:		else if ( fullspd || fulltbl )
branch  0 taken 5 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 5
    #####:  261:			fprintf( backing_up_file,
call    0 never executed
        -:  262:				"%d backing up (non-accepting) states.\n",
        -:  263:				num_backing_up );
        -:  264:		else
        5:  265:			fprintf( backing_up_file,
call    0 returned 5
        -:  266:				"Compressed tables always back up.\n" );
        -:  267:
        5:  268:		if ( ferror( backing_up_file ) )
call    0 returned 5
branch  1 taken 0 (fallthrough)
branch  2 taken 5
    #####:  269:			flexfatal( "error occurred when writing backup file" );
call    0 never executed
        -:  270:
        5:  271:		else if ( fclose( backing_up_file ) )
call    0 returned 5
branch  1 taken 0 (fallthrough)
branch  2 taken 5
    #####:  272:			flexfatal( "error occurred when closing backup file" );
call    0 never executed
        -:  273:		}
        -:  274:
      561:  275:	if ( printstats )
branch  0 taken 9 (fallthrough)
branch  1 taken 552
        -:  276:		{
        9:  277:		fprintf( err, "%s version %s usage statistics:\n",
call    0 returned 9
        -:  278:			program_name, flex_version );
        -:  279:
        9:  280:		fprintf( err, "  scanner options: -" );
call    0 returned 9
        -:  281:
        9:  282:		if ( C_plus_plus )
branch  0 taken 0 (fallthrough)
branch  1 taken 9
    #####:  283:			putc( '+', err );
call    0 never executed
        9:  284:		if ( backing_up_report )
branch  0 taken 3 (fallthrough)
branch  1 taken 6
        3:  285:			putc( 'b', err );
call    0 returned 3
        9:  286:		if ( ddebug )
branch  0 taken 2 (fallthrough)
branch  1 taken 7
        2:  287:			putc( 'd', err );
call    0 returned 2
        9:  288:		if ( caseins )
branch  0 taken 2 (fallthrough)
branch  1 taken 7
        2:  289:			putc( 'i', err );
call    0 returned 2
        9:  290:		if ( lex_compat )
branch  0 taken 2 (fallthrough)
branch  1 taken 7
        2:  291:			putc( 'l', err );
call    0 returned 2
        9:  292:		if ( performance_report > 0 )
branch  0 taken 2 (fallthrough)
branch  1 taken 7
        2:  293:			putc( 'p', err );
call    0 returned 2
        9:  294:		if ( performance_report > 1 )
branch  0 taken 0 (fallthrough)
branch  1 taken 9
    #####:  295:			putc( 'p', err );
call    0 never executed
        9:  296:		if ( spprdflt )
branch  0 taken 2 (fallthrough)
branch  1 taken 7
        2:  297:			putc( 's', err );
call    0 returned 2
        9:  298:		if ( use_stdout )
branch  0 taken 2 (fallthrough)
branch  1 taken 7
        2:  299:			putc( 't', err );
call    0 returned 2
        9:  300:		if ( printstats )
branch  0 taken 9 (fallthrough)
branch  1 taken 0
        9:  301:			putc( 'v', err );	/* always true! */
call    0 returned 9
        9:  302:		if ( nowarn )
branch  0 taken 2 (fallthrough)
branch  1 taken 7
        2:  303:			putc( 'w', err );
call    0 returned 2
        9:  304:		if ( ! interactive )
branch  0 taken 3 (fallthrough)
branch  1 taken 6
        3:  305:			putc( 'B', err );
call    0 returned 3
        9:  306:		if ( interactive )
branch  0 taken 6 (fallthrough)
branch  1 taken 3
        6:  307:			putc( 'I', err );
call    0 returned 6
        9:  308:		if ( ! gen_line_dirs )
branch  0 taken 2 (fallthrough)
branch  1 taken 7
        2:  309:			putc( 'L', err );
call    0 returned 2
        9:  310:		if ( trace )
branch  0 taken 4 (fallthrough)
branch  1 taken 5
        4:  311:			putc( 'T', err );
call    0 returned 4
        9:  312:		if ( csize == 128 )
branch  0 taken 1 (fallthrough)
branch  1 taken 8
        1:  313:			putc( '7', err );
call    0 returned 1
        -:  314:		else
        8:  315:			putc( '8', err );
call    0 returned 8
        -:  316:
        9:  317:		fprintf( err, " -C" );
call    0 returned 9
        -:  318:
        9:  319:		if ( long_align )
branch  0 taken 3 (fallthrough)
branch  1 taken 6
        3:  320:			putc( 'a', err );
call    0 returned 3
        9:  321:		if ( fulltbl )
branch  0 taken 1 (fallthrough)
branch  1 taken 8
        1:  322:			putc( 'f', err );
call    0 returned 1
        9:  323:		if ( fullspd )
branch  0 taken 1 (fallthrough)
branch  1 taken 8
        1:  324:			putc( 'F', err );
call    0 returned 1
        9:  325:		if ( useecs )
branch  0 taken 8 (fallthrough)
branch  1 taken 1
        8:  326:			putc( 'e', err );
call    0 returned 8
        9:  327:		if ( usemecs )
branch  0 taken 8 (fallthrough)
branch  1 taken 1
        8:  328:			putc( 'm', err );
call    0 returned 8
        9:  329:		if ( use_read )
branch  0 taken 2 (fallthrough)
branch  1 taken 7
        2:  330:			putc( 'r', err );
call    0 returned 2
        -:  331:
        9:  332:		if ( skelname )
branch  0 taken 1 (fallthrough)
branch  1 taken 8
        1:  333:			fprintf( err, " -S%s", skelname );
call    0 returned 1
        -:  334:
        9:  335:		if ( yy_strcmp( prefix, "yy" ) )
call    0 returned 9
branch  1 taken 0 (fallthrough)
branch  2 taken 9
    #####:  336:			fprintf( err, " -P%s", prefix );
call    0 never executed
        -:  337:
        9:  338:		putc( '\n', err );
call    0 returned 9
        -:  339:
        9:  340:		fprintf( err, "  %d/%d NFA states\n", lastnfa, current_mns );
call    0 returned 9
        9:  341:		fprintf( err, "  %d/%d DFA states (%d words)\n", lastdfa,
call    0 returned 9
        -:  342:			current_max_dfas, totnst );
        9:  343:		fprintf( err, "  %d rules\n",
        9:  344:		num_rules + num_eof_rules - 1 /* - 1 for def. rule */ );
call    0 returned 9
        -:  345:
        9:  346:		if ( num_backing_up == 0 )
branch  0 taken 2 (fallthrough)
branch  1 taken 7
        2:  347:			fprintf( err, "  No backing up\n" );
call    0 returned 2
        7:  348:		else if ( fullspd || fulltbl )
branch  0 taken 7 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 7
    #####:  349:			fprintf( err,
call    0 never executed
        -:  350:				"  %d backing-up (non-accepting) states\n",
        -:  351:				num_backing_up );
        -:  352:		else
        7:  353:			fprintf( err,
call    0 returned 7
        -:  354:				"  Compressed tables always back-up\n" );
        -:  355:
        9:  356:		if ( bol_needed )
branch  0 taken 0 (fallthrough)
branch  1 taken 9
    #####:  357:			fprintf( err,
call    0 never executed
        -:  358:				"  Beginning-of-line patterns used\n" );
        -:  359:
        9:  360:		fprintf( err, "  %d/%d start conditions\n", lastsc,
call    0 returned 9
        -:  361:			current_max_scs );
        9:  362:		fprintf( err,
call    0 returned 9
        -:  363:			"  %d epsilon states, %d double epsilon states\n",
        -:  364:			numeps, eps2 );
        -:  365:
        9:  366:		if ( lastccl == 0 )
branch  0 taken 2 (fallthrough)
branch  1 taken 7
        2:  367:			fprintf( err, "  no character classes\n" );
call    0 returned 2
        -:  368:		else
        7:  369:			fprintf( err,
        -:  370:	"  %d/%d character classes needed %d/%d words of storage, %d reused\n",
        -:  371:				lastccl, current_maxccls,
        7:  372:				cclmap[lastccl] + ccllen[lastccl],
call    0 returned 7
        -:  373:				current_max_ccl_tbl_size, cclreuse );
        -:  374:
        9:  375:		fprintf( err, "  %d state/nextstate pairs created\n",
call    0 returned 9
        -:  376:			numsnpairs );
        9:  377:		fprintf( err, "  %d/%d unique/duplicate transitions\n",
call    0 returned 9
        -:  378:			numuniq, numdup );
        -:  379:
        9:  380:		if ( fulltbl )
branch  0 taken 1 (fallthrough)
branch  1 taken 8
        -:  381:			{
        1:  382:			tblsiz = lastdfa * numecs;
        1:  383:			fprintf( err, "  %d table entries\n", tblsiz );
call    0 returned 1
        -:  384:			}
        -:  385:
        -:  386:		else
        -:  387:			{
        8:  388:			tblsiz = 2 * (lastdfa + numtemps) + 2 * tblend;
        -:  389:
        8:  390:			fprintf( err, "  %d/%d base-def entries created\n",
call    0 returned 8
        -:  391:				lastdfa + numtemps, current_max_dfas );
        8:  392:			fprintf( err,
call    0 returned 8
        -:  393:				"  %d/%d (peak %d) nxt-chk entries created\n",
        -:  394:				tblend, current_max_xpairs, peakpairs );
        8:  395:			fprintf( err,
call    0 returned 8
        -:  396:			"  %d/%d (peak %d) template nxt-chk entries created\n",
        -:  397:				numtemps * nummecs, current_max_template_xpairs,
        -:  398:				numtemps * numecs );
        8:  399:			fprintf( err, "  %d empty table entries\n", nummt );
call    0 returned 8
        8:  400:			fprintf( err, "  %d protos created\n", numprots );
call    0 returned 8
        8:  401:			fprintf( err, "  %d templates created, %d uses\n",
call    0 returned 8
        -:  402:				numtemps, tmpuses );
        -:  403:			}
        -:  404:
        9:  405:		if ( useecs )
branch  0 taken 8 (fallthrough)
branch  1 taken 1
        -:  406:			{
        8:  407:			tblsiz = tblsiz + csize;
        8:  408:			fprintf( err,
call    0 returned 8
        -:  409:				"  %d/%d equivalence classes created\n",
        -:  410:				numecs, csize );
        -:  411:			}
        -:  412:
        9:  413:		if ( usemecs )
branch  0 taken 8 (fallthrough)
branch  1 taken 1
        -:  414:			{
        8:  415:			tblsiz = tblsiz + numecs;
        8:  416:			fprintf( err,
call    0 returned 8
        -:  417:				"  %d/%d meta-equivalence classes created\n",
        -:  418:				nummecs, csize );
        -:  419:			}
        -:  420:
        9:  421:		fprintf( err,
call    0 returned 9
        -:  422:			"  %d (%d saved) hash collisions, %d DFAs equal\n",
        -:  423:			hshcol, hshsave, dfaeql );
        9:  424:		fprintf( err, "  %d sets of reallocations needed\n",
call    0 returned 9
        -:  425:			num_reallocs );
        9:  426:		fprintf( err, "  %d total table entries needed\n", tblsiz );
call    0 returned 9
        -:  427:		}
        -:  428:
        -:  429:#ifndef VMS
      561:  430:	exit( exit_status );
        -:  431:#else
        -:  432:	exit( exit_status + 1 );
        -:  433:#endif
        -:  434:	}
        -:  435:
        -:  436:
        -:  437:/* flexinit - initialize flex */
        -:  438:
function flexinit called 564 returned 97% blocks executed 93%
      564:  439:void flexinit( argc, argv )
        -:  440:int argc;
        -:  441:char **argv;
        -:  442:	{
        -:  443:	int i, sawcmpflag;
        -:  444:	int csize_given, interactive_given;
        -:  445:	char *arg, *mktemp();
        -:  446:
      564:  447:	printstats = syntaxerror = trace = spprdflt = caseins = false;
      564:  448:	lex_compat = false;
      564:  449:	C_plus_plus = backing_up_report = ddebug = fulltbl = fullspd = false;
      564:  450:	long_align = nowarn = yymore_used = continued_action = reject = false;
      564:  451:	yytext_is_array = yymore_really_used = reject_really_used = false;
      564:  452:	gen_line_dirs = usemecs = useecs = true;
      564:  453:	performance_report = 0;
        -:  454:
      564:  455:	sawcmpflag = false;
      564:  456:	use_read = use_stdout = false;
      564:  457:	csize_given = false;
      564:  458:	interactive_given = false;
        -:  459:
        -:  460:	/* Initialize dynamic array for holding the rule actions. */
      564:  461:	action_size = 2048;	/* default size of action array in bytes */
      564:  462:	action_array = allocate_character_array( action_size );
call    0 returned 564
      564:  463:	defs1_offset = prolog_offset = action_offset = action_index = 0;
      564:  464:	action_array[0] = '\0';
        -:  465:/* Commented by Amit Goel on 5th September 2001 to remove nomdeterminism */
        -:  466:/*	program_name = argv[0];  */
        -:  467:/* Added by Amit Goel on 5th September 2001 */
      564:  468:        program_name = "Executable";
        -:  469:
      564:  470:	if ( program_name[0] != '\0' &&
branch  0 taken 564 (fallthrough)
branch  1 taken 0
      564:  471:	     program_name[yy_strlen( program_name ) - 1] == '+' )
call    0 returned 564
branch  1 taken 0 (fallthrough)
branch  2 taken 564
    #####:  472:		C_plus_plus = true;
        -:  473:
        -:  474:/* ### add for testing ### */
      564:  475:	++argv;--argc;
        -:  476:/* ####################### */
        -:  477:
        -:  478:	/* read flags */
     1508:  479:	for ( --argc, ++argv; argc ; --argc, ++argv )
branch  0 taken 1508
branch  1 taken 0 (fallthrough)
        -:  480:		{
     1508:  481:		if ( argv[0][0] != '-' || argv[0][1] == '\0' )
branch  0 taken 951 (fallthrough)
branch  1 taken 557
branch  2 taken 951 (fallthrough)
branch  3 taken 0
        -:  482:			break;
        -:  483:
      951:  484:		arg = argv[0];
        -:  485:
     1604:  486:		for ( i = 1; arg[i] != '\0'; ++i )
branch  0 taken 1143
branch  1 taken 461 (fallthrough)
     1143:  487:			switch ( arg[i] )
branch  0 taken 0
branch  1 taken 2
branch  2 taken 5
branch  3 taken 1
branch  4 taken 478
branch  5 taken 252
branch  6 taken 84
branch  7 taken 80
branch  8 taken 1
branch  9 taken 3
branch 10 taken 3
branch 11 taken 163
branch 12 taken 3
branch 13 taken 1
branch 14 taken 4
branch 15 taken 15
branch 16 taken 4
branch 17 taken 3
branch 18 taken 3
branch 19 taken 21
branch 20 taken 9
branch 21 taken 1
branch 22 taken 3
branch 23 taken 2
branch 24 taken 1
branch 25 taken 1
        -:  488:				{
    #####:  489:				case '+':
    #####:  490:					C_plus_plus = true;
    #####:  491:					break;
        -:  492:
        2:  493:				case 'B':
        2:  494:					interactive = false;
        2:  495:					interactive_given = true;
        2:  496:					break;
        -:  497:
        5:  498:				case 'b':
        5:  499:					backing_up_report = true;
        5:  500:					break;
        -:  501:
        1:  502:				case 'c':
        1:  503:					fprintf( err,
call    0 returned 1
        -:  504:	"%s: Assuming use of deprecated -c flag is really intended to be -C\n",
        -:  505:					program_name );
        -:  506:
        -:  507:					/* fall through */
        -:  508:
      479:  509:				case 'C':
      479:  510:					if ( i != 1 )
branch  0 taken 1 (fallthrough)
branch  1 taken 478
        1:  511:						flexerror(
call    0 returned 0
        -:  512:					"-C flag must be given separately" );
        -:  513:
      478:  514:					if ( ! sawcmpflag )
branch  0 taken 477 (fallthrough)
branch  1 taken 1
        -:  515:						{
      477:  516:						useecs = false;
      477:  517:						usemecs = false;
      477:  518:						fulltbl = false;
      477:  519:						sawcmpflag = true;
        -:  520:						}
        -:  521:
     1402:  522:					for ( ++i; arg[i] != '\0'; ++i )
branch  0 taken 925
branch  1 taken 477 (fallthrough)
      925:  523:						switch ( arg[i] )
branch  0 taken 243
branch  1 taken 243
branch  2 taken 15
branch  3 taken 18
branch  4 taken 163
branch  5 taken 242
branch  6 taken 1
        -:  524:							{
      243:  525:							case 'a':
      243:  526:								long_align =
        -:  527:									true;
      243:  528:								break;
        -:  529:
      243:  530:							case 'e':
      243:  531:								useecs = true;
      243:  532:								break;
        -:  533:
       15:  534:							case 'F':
       15:  535:								fullspd = true;
       15:  536:								break;
        -:  537:
       18:  538:							case 'f':
       18:  539:								fulltbl = true;
       18:  540:								break;
        -:  541:
      163:  542:							case 'm':
      163:  543:								usemecs = true;
      163:  544:								break;
        -:  545:
      242:  546:							case 'r':
      242:  547:								use_read = true;
      242:  548:								break;
        -:  549:
        1:  550:							default:
        1:  551:								lerrif(
        -:  552:						"unknown -C option '%c'",
        1:  553:								(int) arg[i] );
call    0 returned 0
    #####:  554:								break;
        -:  555:							}
        -:  556:
      477:  557:					goto get_next_arg;
        -:  558:
      252:  559:				case 'd':
      252:  560:					ddebug = true;
      252:  561:					break;
        -:  562:
       84:  563:				case 'f':
       84:  564:					useecs = usemecs = false;
       84:  565:					use_read = fulltbl = true;
       84:  566:					break;
        -:  567:
       80:  568:				case 'F':
       80:  569:					useecs = usemecs = false;
       80:  570:					use_read = fullspd = true;
       80:  571:					break;
        -:  572:
        1:  573:				case 'h':
        1:  574:					usage();
call    0 returned 1
        1:  575:					exit( 0 );
call    0 returned 0
        -:  576:
        3:  577:				case 'I':
        3:  578:					interactive = true;
        3:  579:					interactive_given = true;
        3:  580:					break;
        -:  581:
        3:  582:				case 'i':
        3:  583:					caseins = true;
        3:  584:					break;
        -:  585:
      163:  586:				case 'l':
      163:  587:					lex_compat = true;
      163:  588:					break;
        -:  589:
        3:  590:				case 'L':
        3:  591:					gen_line_dirs = false;
        3:  592:					break;
        -:  593:
        1:  594:				case 'n':
        -:  595:					/* Stupid do-nothing deprecated
        -:  596:					 * option.
        -:  597:					 */
        1:  598:					break;
        -:  599:
        4:  600:				case 'P':
        4:  601:					if ( i != 1 )
branch  0 taken 1 (fallthrough)
branch  1 taken 3
        1:  602:						flexerror(
call    0 returned 0
        -:  603:					"-P flag must be given separately" );
        -:  604:
        3:  605:					prefix = arg + i + 1;
        3:  606:					goto get_next_arg;
        -:  607:
       15:  608:				case 'p':
       15:  609:					++performance_report;
       15:  610:					break;
        -:  611:
        4:  612:				case 'S':
        4:  613:					if ( i != 1 )
branch  0 taken 1 (fallthrough)
branch  1 taken 3
        1:  614:						flexerror(
call    0 returned 0
        -:  615:					"-S flag must be given separately" );
        -:  616:
        3:  617:					skelname = arg + i + 1;
        3:  618:					goto get_next_arg;
        -:  619:
        3:  620:				case 's':
        3:  621:					spprdflt = true;
        3:  622:					break;
        -:  623:
        3:  624:				case 't':
        3:  625:					use_stdout = true;
        3:  626:					break;
        -:  627:
       21:  628:				case 'T':
       21:  629:					trace = true;
       21:  630:					break;
        -:  631:
        9:  632:				case 'v':
        9:  633:					printstats = true;
        9:  634:					break;
        -:  635:
        1:  636:				case 'V':
        1:  637:					fprintf( err, "%s version %s\n",
call    0 returned 1
        -:  638:						program_name, flex_version );
        1:  639:					exit( 0 );
call    0 returned 0
        -:  640:
        3:  641:				case 'w':
        3:  642:					nowarn = true;
        3:  643:					break;
        -:  644:
        2:  645:				case '7':
        2:  646:					csize = 128;
        2:  647:					csize_given = true;
        2:  648:					break;
        -:  649:
        1:  650:				case '8':
        1:  651:					csize = CSIZE;
        1:  652:					csize_given = true;
        1:  653:					break;
        -:  654:
        1:  655:				default:
        1:  656:					fprintf( err,
        -:  657:						"%s: unknown flag '%c'\n",
        1:  658:						program_name, (int) arg[i] );
call    0 returned 1
        1:  659:					usage();
call    0 returned 1
        1:  660:					exit( 1 );
call    0 returned 0
        -:  661:				}
        -:  662:
        -:  663:		/* Used by -C, -S and -P flags in lieu of a "continue 2"
        -:  664:		 * control.
        -:  665:		 */
      944:  666:		get_next_arg: ;
        -:  667:		}
        -:  668:
      557:  669:	if ( ! csize_given )
branch  0 taken 554 (fallthrough)
branch  1 taken 3
        -:  670:		{
      554:  671:		if ( (fulltbl || fullspd) && ! useecs )
branch  0 taken 525 (fallthrough)
branch  1 taken 29
branch  2 taken 94 (fallthrough)
branch  3 taken 431
branch  4 taken 80 (fallthrough)
branch  5 taken 43
       80:  672:			csize = DEFAULT_CSIZE;
        -:  673:		else
      474:  674:			csize = CSIZE;
        -:  675:		}
        -:  676:
      557:  677:	if ( ! interactive_given )
branch  0 taken 552 (fallthrough)
branch  1 taken 5
        -:  678:		{
      552:  679:		if ( fulltbl || fullspd )
branch  0 taken 524 (fallthrough)
branch  1 taken 28
branch  2 taken 94 (fallthrough)
branch  3 taken 430
      122:  680:			interactive = false;
        -:  681:		else
      430:  682:			interactive = true;
        -:  683:		}
        -:  684:
      557:  685:	if ( lex_compat )
branch  0 taken 163 (fallthrough)
branch  1 taken 394
        -:  686:		{
      163:  687:		if ( C_plus_plus )
branch  0 taken 0 (fallthrough)
branch  1 taken 163
    #####:  688:			flexerror( "Can't use -+ with -l option" );
call    0 never executed
        -:  689:
      163:  690:		if ( fulltbl || fullspd )
branch  0 taken 162 (fallthrough)
branch  1 taken 1
branch  2 taken 0 (fallthrough)
branch  3 taken 162
        1:  691:			flexerror( "Can't use -f or -F with -l option" );
call    0 returned 0
        -:  692:
        -:  693:		/* Don't rely on detecting use of yymore() and REJECT,
        -:  694:		 * just assume they'll be used.
        -:  695:		 */
      162:  696:		yymore_really_used = reject_really_used = true;
        -:  697:
      162:  698:		yytext_is_array = true;
      162:  699:		use_read = false;
        -:  700:		}
        -:  701:
      556:  702:	if ( (fulltbl || fullspd) && usemecs )
branch  0 taken 528 (fallthrough)
branch  1 taken 28
branch  2 taken 94 (fallthrough)
branch  3 taken 434
branch  4 taken 3 (fallthrough)
branch  5 taken 119
        3:  703:		flexerror( "-Cf/-CF and -Cm don't make sense together" );
call    0 returned 0
        -:  704:
      553:  705:	if ( (fulltbl || fullspd) && interactive )
branch  0 taken 527 (fallthrough)
branch  1 taken 26
branch  2 taken 93 (fallthrough)
branch  3 taken 434
branch  4 taken 1 (fallthrough)
branch  5 taken 118
        1:  706:		flexerror( "-Cf/-CF and -I are incompatible" );
call    0 returned 0
        -:  707:
      552:  708:	if ( fulltbl && fullspd )
branch  0 taken 25 (fallthrough)
branch  1 taken 527
branch  2 taken 1 (fallthrough)
branch  3 taken 24
        1:  709:		flexerror( "-Cf and -CF are mutually exclusive" );
call    0 returned 0
        -:  710:
     551*:  711:	if ( C_plus_plus && fullspd )
branch  0 taken 0 (fallthrough)
branch  1 taken 551
branch  2 never executed
branch  3 never executed
    #####:  712:		flexerror( "Can't use -+ with -CF option" );
call    0 never executed
        -:  713:
      551:  714:	if ( ! use_stdout )
branch  0 taken 548 (fallthrough)
branch  1 taken 3
        -:  715:		{
        -:  716:		FILE *prev_stdout;
        -:  717:		char *suffix;
        -:  718:
      548:  719:		if ( C_plus_plus )
branch  0 taken 0 (fallthrough)
branch  1 taken 548
    #####:  720:			suffix = "cc";
        -:  721:		else
      548:  722:			suffix = "c";
        -:  723:
      548:  724:		sprintf( outfile_path, outfile_template, prefix, suffix );
        -:  725:
      548:  726:		prev_stdout = freopen( outfile_path, "w", stdout );
call    0 returned 548
        -:  727:
      548:  728:		if ( prev_stdout == NULL )
branch  0 taken 0 (fallthrough)
branch  1 taken 548
    #####:  729:			lerrsf( "could not create %s", outfile_path );
call    0 never executed
        -:  730:
      548:  731:		outfile_created = 1;
        -:  732:		}
        -:  733:
      551:  734:	num_input_files = argc;
      551:  735:	input_files = argv;
     551*:  736:	set_input_file( num_input_files > 0 ? input_files[0] : NULL );
branch  0 taken 551 (fallthrough)
branch  1 taken 0
call    2 returned 550
        -:  737:	
        -:  738:
      550:  739:	if ( backing_up_report )
branch  0 taken 5 (fallthrough)
branch  1 taken 545
        -:  740:		{
        -:  741:#ifndef SHORT_FILE_NAMES
        5:  742:		backing_up_file = fopen( "lex.backup", "w" );
call    0 returned 5
        -:  743:#else
        -:  744:		backing_up_file = fopen( "lex.bck", "w" );
        -:  745:#endif
        -:  746:
        5:  747:		if ( backing_up_file == NULL )
branch  0 taken 0 (fallthrough)
branch  1 taken 5
    #####:  748:			flexerror( "could not create lex.backup" );
call    0 never executed
        -:  749:		}
        -:  750:
        -:  751:	else
      545:  752:		backing_up_file = NULL;
        -:  753:
        -:  754:
      550:  755:	lastccl = 0;
      550:  756:	lastsc = 0;
        -:  757:
      550:  758:	if ( skelname && (skelfile = fopen( skelname, "r" )) == NULL )
branch  0 taken 3 (fallthrough)
branch  1 taken 547
call    2 returned 3
branch  3 taken 1 (fallthrough)
branch  4 taken 2
        1:  759:		lerrsf( "can't open skeleton file %s", skelname );
call    0 returned 0
        -:  760:
      549:  761:	if ( yy_strcmp( prefix, "yy" ) )
call    0 returned 549
branch  1 taken 1 (fallthrough)
branch  2 taken 548
        -:  762:		{
        -:  763:#define GEN_PREFIX(name) printf( "#define yy%s %s%s\n", name, prefix, name );
        1:  764:		GEN_PREFIX( "FlexLexer" );
call    0 returned 1
        1:  765:		GEN_PREFIX( "_create_buffer" );
call    0 returned 1
        1:  766:		GEN_PREFIX( "_delete_buffer" );
call    0 returned 1
        1:  767:		GEN_PREFIX( "_flex_debug" );
call    0 returned 1
        1:  768:		GEN_PREFIX( "_init_buffer" );
call    0 returned 1
        1:  769:		GEN_PREFIX( "_load_buffer_state" );
call    0 returned 1
        1:  770:		GEN_PREFIX( "_switch_to_buffer" );
call    0 returned 1
        1:  771:		GEN_PREFIX( "in" );
call    0 returned 1
        1:  772:		GEN_PREFIX( "leng" );
call    0 returned 1
        1:  773:		GEN_PREFIX( "lex" );
call    0 returned 1
        1:  774:		GEN_PREFIX( "out" );
call    0 returned 1
        1:  775:		GEN_PREFIX( "restart" );
call    0 returned 1
        1:  776:		GEN_PREFIX( "text" );
call    0 returned 1
        1:  777:		GEN_PREFIX( "wrap" );
call    0 returned 1
        1:  778:		printf( "\n" );
call    0 returned 1
        -:  779:		}
        -:  780:
        -:  781:
      549:  782:	lastdfa = lastnfa = 0;
      549:  783:	num_rules = num_eof_rules = default_rule = 0;
      549:  784:	numas = numsnpairs = tmpuses = 0;
      549:  785:	numecs = numeps = eps2 = num_reallocs = hshcol = dfaeql = totnst = 0;
      549:  786:	numuniq = numdup = hshsave = eofseen = datapos = dataline = 0;
      549:  787:	num_backing_up = onesp = numprots = 0;
      549:  788:	variable_trailing_context_rules = bol_needed = false;
        -:  789:
      549:  790:	linenum = sectnum = 1;
      549:  791:	firstprot = NIL;
        -:  792:
        -:  793:	/* Used in mkprot() so that the first proto goes in slot 1
        -:  794:	 * of the proto queue.
        -:  795:	 */
      549:  796:	lastprot = 1;
        -:  797:
      549:  798:	if ( useecs )
branch  0 taken 299 (fallthrough)
branch  1 taken 250
        -:  799:		{
        -:  800:		/* Set up doubly-linked equivalence classes. */
        -:  801:
        -:  802:		/* We loop all the way up to csize, since ecgroup[csize] is
        -:  803:		 * the position used for NUL characters.
        -:  804:		 */
      299:  805:		ecgroup[1] = NIL;
        -:  806:
    76288:  807:		for ( i = 2; i <= csize; ++i )
branch  0 taken 75989
branch  1 taken 299 (fallthrough)
        -:  808:			{
    75989:  809:			ecgroup[i] = i - 1;
    75989:  810:			nextecm[i - 1] = i;
        -:  811:			}
        -:  812:
      299:  813:		nextecm[csize] = NIL;
        -:  814:		}
        -:  815:
        -:  816:	else
        -:  817:		{
        -:  818:		/* Put everything in its own equivalence class. */
    54522:  819:		for ( i = 1; i <= csize; ++i )
branch  0 taken 54272
branch  1 taken 250 (fallthrough)
        -:  820:			{
    54272:  821:			ecgroup[i] = i;
    54272:  822:			nextecm[i] = BAD_SUBSCRIPT;	/* to catch errors */
        -:  823:			}
        -:  824:		}
        -:  825:
      549:  826:	set_up_initial_allocations();
call    0 returned 549
      549:  827:	}
        -:  828:
        -:  829:
        -:  830:/* readin - read in the rules section of the input file(s) */
        -:  831:
function readin called 549 returned 100% blocks executed 85%
      549:  832:void readin()
        -:  833:	{
      549:  834:	skelout();
call    0 returned 549
        -:  835:
      549:  836:	line_directive_out( (FILE *) 0 );
call    0 returned 549
        -:  837:
      549:  838:	if ( yyparse() )
call    0 returned 549
branch  1 taken 0 (fallthrough)
branch  2 taken 549
        -:  839:		{
    #####:  840:		pinpoint_message( "fatal parse error" );
call    0 never executed
    #####:  841:		flexend( 1 );
call    0 never executed
        -:  842:		}
        -:  843:
      549:  844:	if ( csize == 256 )
branch  0 taken 471 (fallthrough)
branch  1 taken 78
      471:  845:		puts( "typedef unsigned char YY_CHAR;" );
call    0 returned 471
        -:  846:	else
       78:  847:		puts( "typedef char YY_CHAR;" );
call    0 returned 78
        -:  848:
      549:  849:	if ( C_plus_plus )
branch  0 taken 0 (fallthrough)
branch  1 taken 549
        -:  850:		{
    #####:  851:		puts( "#define yytext_ptr yytext" );
call    0 never executed
        -:  852:
    #####:  853:		if ( interactive )
branch  0 never executed
branch  1 never executed
    #####:  854:			puts( "#define YY_INTERACTIVE" );
call    0 never executed
        -:  855:		}
        -:  856:
      549:  857:	if ( fullspd )
branch  0 taken 93 (fallthrough)
branch  1 taken 456
       93:  858:		printf(
call    0 returned 93
        -:  859:		"typedef const struct yy_trans_info *yy_state_type;\n" );
      456:  860:	else if ( ! C_plus_plus )
branch  0 taken 456 (fallthrough)
branch  1 taken 0
      456:  861:		printf( "typedef int yy_state_type;\n" );
call    0 returned 456
        -:  862:
      549:  863:	if ( reject )
branch  0 taken 6 (fallthrough)
branch  1 taken 543
        6:  864:		printf( "\n#define YY_USES_REJECT\n" );
call    0 returned 6
        -:  865:
      549:  866:	if ( ddebug )
branch  0 taken 252 (fallthrough)
branch  1 taken 297
      252:  867:		puts( "\n#define FLEX_DEBUG" );
call    0 returned 252
        -:  868:
      549:  869:	if ( lex_compat )
branch  0 taken 162 (fallthrough)
branch  1 taken 387
        -:  870:		{
      162:  871:		printf( "FILE *yyin = stdin, *yyout = stdout;\n" );
call    0 returned 162
      162:  872:		printf( "extern int yylineno;\n" );
call    0 returned 162
      162:  873:		printf( "int yylineno = 1;\n" );
call    0 returned 162
        -:  874:		}
      387:  875:	else if ( ! C_plus_plus )
branch  0 taken 387 (fallthrough)
branch  1 taken 0
      387:  876:		printf( "FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;\n" );
call    0 returned 387
        -:  877:
      549:  878:	if ( C_plus_plus )
branch  0 taken 0 (fallthrough)
branch  1 taken 549
    #####:  879:		printf( "\n#include \"FlexLexer.h\"\n" );
call    0 never executed
        -:  880:
        -:  881:	else
        -:  882:		{
      549:  883:		if ( yytext_is_array )
branch  0 taken 162 (fallthrough)
branch  1 taken 387
      162:  884:			puts( "extern char yytext[];\n" );
call    0 returned 162
        -:  885:
        -:  886:		else
        -:  887:			{
      387:  888:			puts( "extern char *yytext;" );
call    0 returned 387
      387:  889:			puts( "#define yytext_ptr yytext" );
call    0 returned 387
        -:  890:			}
        -:  891:		}
        -:  892:
      549:  893:	if ( useecs )
branch  0 taken 299 (fallthrough)
branch  1 taken 250
      299:  894:		numecs = cre8ecs( nextecm, ecgroup, csize );
call    0 returned 299
        -:  895:	else
      250:  896:		numecs = csize;
        -:  897:
        -:  898:	/* Now map the equivalence class for NUL to its expected place. */
      549:  899:	ecgroup[0] = ecgroup[csize];
      549:  900:	NUL_ec = abs( ecgroup[0] );
        -:  901:
      549:  902:	if ( useecs )
branch  0 taken 299 (fallthrough)
branch  1 taken 250
      299:  903:		ccl2ecl();
call    0 returned 299
      549:  904:	}
        -:  905:
        -:  906:
        -:  907:/* set_up_initial_allocations - allocate memory for internal tables */
        -:  908:
function set_up_initial_allocations called 549 returned 100% blocks executed 100%
      549:  909:void set_up_initial_allocations()
        -:  910:	{
      549:  911:	current_mns = INITIAL_MNS;
      549:  912:	firstst = allocate_integer_array( current_mns );
call    0 returned 549
      549:  913:	lastst = allocate_integer_array( current_mns );
call    0 returned 549
      549:  914:	finalst = allocate_integer_array( current_mns );
call    0 returned 549
      549:  915:	transchar = allocate_integer_array( current_mns );
call    0 returned 549
      549:  916:	trans1 = allocate_integer_array( current_mns );
call    0 returned 549
      549:  917:	trans2 = allocate_integer_array( current_mns );
call    0 returned 549
      549:  918:	accptnum = allocate_integer_array( current_mns );
call    0 returned 549
      549:  919:	assoc_rule = allocate_integer_array( current_mns );
call    0 returned 549
      549:  920:	state_type = allocate_integer_array( current_mns );
call    0 returned 549
        -:  921:
      549:  922:	current_max_rules = INITIAL_MAX_RULES;
      549:  923:	rule_type = allocate_integer_array( current_max_rules );
call    0 returned 549
      549:  924:	rule_linenum = allocate_integer_array( current_max_rules );
call    0 returned 549
      549:  925:	rule_useful = allocate_integer_array( current_max_rules );
call    0 returned 549
        -:  926:
      549:  927:	current_max_scs = INITIAL_MAX_SCS;
      549:  928:	scset = allocate_integer_array( current_max_scs );
call    0 returned 549
      549:  929:	scbol = allocate_integer_array( current_max_scs );
call    0 returned 549
      549:  930:	scxclu = allocate_integer_array( current_max_scs );
call    0 returned 549
      549:  931:	sceof = allocate_integer_array( current_max_scs );
call    0 returned 549
      549:  932:	scname = allocate_char_ptr_array( current_max_scs );
call    0 returned 549
      549:  933:	actvsc = allocate_integer_array( current_max_scs );
call    0 returned 549
        -:  934:
      549:  935:	current_maxccls = INITIAL_MAX_CCLS;
      549:  936:	cclmap = allocate_integer_array( current_maxccls );
call    0 returned 549
      549:  937:	ccllen = allocate_integer_array( current_maxccls );
call    0 returned 549
      549:  938:	cclng = allocate_integer_array( current_maxccls );
call    0 returned 549
        -:  939:
      549:  940:	current_max_ccl_tbl_size = INITIAL_MAX_CCL_TBL_SIZE;
      549:  941:	ccltbl = allocate_Character_array( current_max_ccl_tbl_size );
call    0 returned 549
        -:  942:
      549:  943:	current_max_dfa_size = INITIAL_MAX_DFA_SIZE;
        -:  944:
      549:  945:	current_max_xpairs = INITIAL_MAX_XPAIRS;
      549:  946:	nxt = allocate_integer_array( current_max_xpairs );
call    0 returned 549
      549:  947:	chk = allocate_integer_array( current_max_xpairs );
call    0 returned 549
        -:  948:
      549:  949:	current_max_template_xpairs = INITIAL_MAX_TEMPLATE_XPAIRS;
      549:  950:	tnxt = allocate_integer_array( current_max_template_xpairs );
call    0 returned 549
        -:  951:
      549:  952:	current_max_dfas = INITIAL_MAX_DFAS;
      549:  953:	base = allocate_integer_array( current_max_dfas );
call    0 returned 549
      549:  954:	def = allocate_integer_array( current_max_dfas );
call    0 returned 549
      549:  955:	dfasiz = allocate_integer_array( current_max_dfas );
call    0 returned 549
      549:  956:	accsiz = allocate_integer_array( current_max_dfas );
call    0 returned 549
      549:  957:	dhash = allocate_integer_array( current_max_dfas );
call    0 returned 549
      549:  958:	dss = allocate_int_ptr_array( current_max_dfas );
call    0 returned 549
      549:  959:	dfaacc = allocate_dfaacc_union( current_max_dfas );
call    0 returned 549
        -:  960:
      549:  961:	nultrans = (int *) 0;
      549:  962:	}
        -:  963:
        -:  964:
function usage called 2 returned 100% blocks executed 100%
        2:  965:void usage()
        -:  966:	{
        2:  967:	fprintf( err,
call    0 returned 2
        -:  968:"%s [-bcdfhilnpstvwBFILTV78+ -C[aefFmr] -Pprefix -Sskeleton] [file ...]\n",
        -:  969:		program_name );
        -:  970:
        2:  971:	fprintf( err,
call    0 returned 2
        -:  972:		"\t-b  generate backing-up information to lex.backup\n" );
        2:  973:	fprintf( err, "\t-c  do-nothing POSIX option\n" );
call    0 returned 2
        2:  974:	fprintf( err, "\t-d  turn on debug mode in generated scanner\n" );
call    0 returned 2
        2:  975:	fprintf( err, "\t-f  generate fast, large scanner\n" );
call    0 returned 2
        2:  976:	fprintf( err, "\t-h  produce this help message\n" );
call    0 returned 2
        2:  977:	fprintf( err, "\t-i  generate case-insensitive scanner\n" );
call    0 returned 2
        2:  978:	fprintf( err, "\t-l  maximal compatibility with original lex\n" );
call    0 returned 2
        2:  979:	fprintf( err, "\t-n  do-nothing POSIX option\n" );
call    0 returned 2
        2:  980:	fprintf( err, "\t-p  generate performance report to stderr\n" );
call    0 returned 2
        2:  981:	fprintf( err,
call    0 returned 2
        -:  982:		"\t-s  suppress default rule to ECHO unmatched text\n" );
        2:  983:	fprintf( err,
call    0 returned 2
        -:  984:	"\t-t  write generated scanner on stdout instead of lex.yy.c\n" );
        2:  985:	fprintf( err,
call    0 returned 2
        -:  986:		"\t-v  write summary of scanner statistics to stderr\n" );
        2:  987:	fprintf( err, "\t-w  do not generate warnings\n" );
call    0 returned 2
        2:  988:	fprintf( err, "\t-B  generate batch scanner (opposite of -I)\n" );
call    0 returned 2
        2:  989:	fprintf( err,
call    0 returned 2
        -:  990:		"\t-F  use alternative fast scanner representation\n" );
        2:  991:	fprintf( err,
call    0 returned 2
        -:  992:		"\t-I  generate interactive scanner (opposite of -B)\n" );
        2:  993:	fprintf( err, "\t-L  suppress #line directives in scanner\n" );
call    0 returned 2
        2:  994:	fprintf( err, "\t-T  %s should run in trace mode\n", program_name );
call    0 returned 2
        2:  995:	fprintf( err, "\t-V  report %s version\n", program_name );
call    0 returned 2
        2:  996:	fprintf( err, "\t-7  generate 7-bit scanner\n" );
call    0 returned 2
        2:  997:	fprintf( err, "\t-8  generate 8-bit scanner\n" );
call    0 returned 2
        2:  998:	fprintf( err, "\t-+  generate C++ scanner class\n" );
call    0 returned 2
        2:  999:	fprintf( err,
call    0 returned 2
        -: 1000:	"\t-C  specify degree of table compression (default is -Cem):\n" );
        2: 1001:	fprintf( err,
call    0 returned 2
        -: 1002:	"\t\t-Ca  trade off larger tables for better memory alignment\n" );
        2: 1003:	fprintf( err, "\t\t-Ce  construct equivalence classes\n" );
call    0 returned 2
        2: 1004:	fprintf( err,
call    0 returned 2
        -: 1005:	"\t\t-Cf  do not compress scanner tables; use -f representation\n" );
        2: 1006:	fprintf( err,
call    0 returned 2
        -: 1007:	"\t\t-CF  do not compress scanner tables; use -F representation\n" );
        2: 1008:	fprintf( err, "\t\t-Cm  construct meta-equivalence classes\n" );
call    0 returned 2
        2: 1009:	fprintf( err,
call    0 returned 2
        -: 1010:		"\t\t-Cr  use read() instead of stdio for scanner input\n" );
        2: 1011:	fprintf( err, "\t-P  specify scanner prefix other than \"yy\"\n" );
call    0 returned 2
        2: 1012:	fprintf( err, "\t-S  specify skeleton file\n" );
call    0 returned 2
        2: 1013:	}
        -: 1014:/* ccl - routines for character classes */
        -: 1015:
        -: 1016:/*-
        -: 1017: * Copyright (c) 1990 The Regents of the University of California.
        -: 1018: * All rights reserved.
        -: 1019: *
        -: 1020: * This code is derived from software contributed to Berkeley by
        -: 1021: * Vern Paxson.
        -: 1022: * 
        -: 1023: * The United States Government has rights in this work pursuant
        -: 1024: * to contract no. DE-AC03-76SF00098 between the United States
        -: 1025: * Department of Energy and the University of California.
        -: 1026: *
        -: 1027: * Redistribution and use in source and binary forms are permitted provided
        -: 1028: * that: (1) source distributions retain this entire copyright notice and
        -: 1029: * comment, and (2) distributions including binaries display the following
        -: 1030: * acknowledgement:  ``This product includes software developed by the
        -: 1031: * University of California, Berkeley and its contributors'' in the
        -: 1032: * documentation or other materials provided with the distribution and in
        -: 1033: * all advertising materials mentioning features or use of this software.
        -: 1034: * Neither the name of the University nor the names of its contributors may
        -: 1035: * be used to endorse or promote products derived from this software without
        -: 1036: * specific prior written permission.
        -: 1037: * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
        -: 1038: * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
        -: 1039: * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
        -: 1040: */
        -: 1041:
        -: 1042:/* $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.orig/v0/flex.c,v 1.1.1.1 2003/06/02 17:12:00 expsir Exp $ */
        -: 1043:
        -: 1044:
        -: 1045:/* ccladd - add a single character to a ccl */
        -: 1046:
function ccladd called 24813 returned 100% blocks executed 100%
    24813: 1047:void ccladd( cclp, ch )
        -: 1048:int cclp;
        -: 1049:int ch;
        -: 1050:	{
        -: 1051:	int ind, len, newpos, i;
        -: 1052:
    24813: 1053:	check_char( ch );
call    0 returned 24813
        -: 1054:
    24813: 1055:	len = ccllen[cclp];
    24813: 1056:	ind = cclmap[cclp];
        -: 1057:
        -: 1058:	/* check to see if the character is already in the ccl */
        -: 1059:
   477949: 1060:	for ( i = 0; i < len; ++i )
branch  0 taken 453347
branch  1 taken 24602 (fallthrough)
   453347: 1061:		if ( ccltbl[ind + i] == ch )
branch  0 taken 211 (fallthrough)
branch  1 taken 453136
      211: 1062:			return;
        -: 1063:
    24602: 1064:	newpos = ind + len;
        -: 1065:
    24602: 1066:	if ( newpos >= current_max_ccl_tbl_size )
branch  0 taken 40 (fallthrough)
branch  1 taken 24562
        -: 1067:		{
       40: 1068:		current_max_ccl_tbl_size += MAX_CCL_TBL_SIZE_INCREMENT;
        -: 1069:
       40: 1070:		++num_reallocs;
        -: 1071:
       40: 1072:		ccltbl = reallocate_Character_array( ccltbl,
call    0 returned 40
        -: 1073:						current_max_ccl_tbl_size );
        -: 1074:		}
        -: 1075:
    24602: 1076:	ccllen[cclp] = len + 1;
    24602: 1077:	ccltbl[newpos] = ch;
        -: 1078:	}
        -: 1079:
        -: 1080:
        -: 1081:/* cclinit - return an empty ccl */
        -: 1082:
function cclinit called 2031 returned 100% blocks executed 100%
     2031: 1083:int cclinit()
        -: 1084:	{
     2031: 1085:	if ( ++lastccl >= current_maxccls )
branch  0 taken 2 (fallthrough)
branch  1 taken 2029
        -: 1086:		{
        2: 1087:		current_maxccls += MAX_CCLS_INCREMENT;
        -: 1088:
        2: 1089:		++num_reallocs;
        -: 1090:
        2: 1091:		cclmap = reallocate_integer_array( cclmap, current_maxccls );
call    0 returned 2
        2: 1092:		ccllen = reallocate_integer_array( ccllen, current_maxccls );
call    0 returned 2
        2: 1093:		cclng = reallocate_integer_array( cclng, current_maxccls );
call    0 returned 2
        -: 1094:		}
        -: 1095:
     2031: 1096:	if ( lastccl == 1 )
branch  0 taken 549 (fallthrough)
branch  1 taken 1482
        -: 1097:		/* we're making the first ccl */
      549: 1098:		cclmap[lastccl] = 0;
        -: 1099:
        -: 1100:	else
        -: 1101:		/* The new pointer is just past the end of the last ccl.
        -: 1102:		 * Since the cclmap points to the \first/ character of a
        -: 1103:		 * ccl, adding the length of the ccl to the cclmap pointer
        -: 1104:		 * will produce a cursor to the first free space.
        -: 1105:		 */
     1482: 1106:		cclmap[lastccl] = cclmap[lastccl - 1] + ccllen[lastccl - 1];
        -: 1107:
     2031: 1108:	ccllen[lastccl] = 0;
     2031: 1109:	cclng[lastccl] = 0;	/* ccl's start out life un-negated */
        -: 1110:
     2031: 1111:	return lastccl;
        -: 1112:	}
        -: 1113:
        -: 1114:
        -: 1115:/* cclnegate - negate the given ccl */
        -: 1116:
function cclnegate called 972 returned 100% blocks executed 100%
      972: 1117:void cclnegate( cclp )
        -: 1118:int cclp;
        -: 1119:	{
      972: 1120:	cclng[cclp] = 1;
      972: 1121:	}
        -: 1122:
        -: 1123:
        -: 1124:/* list_character_set - list the members of a set of characters in CCL form
        -: 1125: *
        -: 1126: * Writes to the given file a character-class representation of those
        -: 1127: * characters present in the given CCL.  A character is present if it
        -: 1128: * has a non-zero value in the cset array.
        -: 1129: */
        -: 1130:
function list_character_set called 8 returned 100% blocks executed 100%
        8: 1131:void list_character_set( file, cset )
        -: 1132:FILE *file;
        -: 1133:int cset[];
        -: 1134:	{
        -: 1135:	register int i;
        -: 1136:
        8: 1137:	putc( '[', file );
call    0 returned 8
        -: 1138:
      908: 1139:	for ( i = 0; i < csize; ++i )
branch  0 taken 900
branch  1 taken 8 (fallthrough)
        -: 1140:		{
      900: 1141:		if ( cset[i] )
branch  0 taken 12 (fallthrough)
branch  1 taken 888
        -: 1142:			{
       12: 1143:			register int start_char = i;
        -: 1144:
       12: 1145:			putc( ' ', file );
call    0 returned 12
        -: 1146:
       12: 1147:			fputs( readable_form( i ), file );
call    0 returned 12
call    1 returned 12
        -: 1148:
      896: 1149:			while ( ++i < csize && cset[i] )
branch  0 taken 892 (fallthrough)
branch  1 taken 4
branch  2 taken 884
branch  3 taken 8 (fallthrough)
        -: 1150:				;
        -: 1151:
       12: 1152:			if ( i - 1 > start_char )
branch  0 taken 8 (fallthrough)
branch  1 taken 4
        -: 1153:				/* this was a run */
        8: 1154:				fprintf( file, "-%s", readable_form( i - 1 ) );
call    0 returned 8
call    1 returned 8
        -: 1155:
       12: 1156:			putc( ' ', file );
call    0 returned 12
        -: 1157:			}
        -: 1158:		}
        -: 1159:
        8: 1160:	putc( ']', file );
call    0 returned 8
        8: 1161:	}
        -: 1162:/* dfa - DFA construction routines */
        -: 1163:
        -: 1164:/*-
        -: 1165: * Copyright (c) 1990 The Regents of the University of California.
        -: 1166: * All rights reserved.
        -: 1167: *
        -: 1168: * This code is derived from software contributed to Berkeley by
        -: 1169: * Vern Paxson.
        -: 1170: * 
        -: 1171: * The United States Government has rights in this work pursuant
        -: 1172: * to contract no. DE-AC03-76SF00098 between the United States
        -: 1173: * Department of Energy and the University of California.
        -: 1174: *
        -: 1175: * Redistribution and use in source and binary forms are permitted provided
        -: 1176: * that: (1) source distributions retain this entire copyright notice and
        -: 1177: * comment, and (2) distributions including binaries display the following
        -: 1178: * acknowledgement:  ``This product includes software developed by the
        -: 1179: * University of California, Berkeley and its contributors'' in the
        -: 1180: * documentation or other materials provided with the distribution and in
        -: 1181: * all advertising materials mentioning features or use of this software.
        -: 1182: * Neither the name of the University nor the names of its contributors may
        -: 1183: * be used to endorse or promote products derived from this software without
        -: 1184: * specific prior written permission.
        -: 1185: * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
        -: 1186: * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
        -: 1187: * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
        -: 1188: */
        -: 1189:
        -: 1190:/* $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.orig/v0/flex.c,v 1.1.1.1 2003/06/02 17:12:00 expsir Exp $ */
        -: 1191:
        -: 1192:
        -: 1193:
        -: 1194:/* declare functions that have forward references */
        -: 1195:
        -: 1196:void dump_associated_rules PROTO((FILE*, int));
        -: 1197:void dump_transitions PROTO((FILE*, int[]));
        -: 1198:void sympartition PROTO((int[], int, int[], int[]));
        -: 1199:int symfollowset PROTO((int[], int, int, int[]));
        -: 1200:
        -: 1201:
        -: 1202:/* check_for_backing_up - check a DFA state for backing up
        -: 1203: *
        -: 1204: * synopsis
        -: 1205: *     void check_for_backing_up( int ds, int state[numecs] );
        -: 1206: *
        -: 1207: * ds is the number of the state to check and state[] is its out-transitions,
        -: 1208: * indexed by equivalence class.
        -: 1209: */
        -: 1210:
function check_for_backing_up called 11249 returned 100% blocks executed 100%
    11249: 1211:void check_for_backing_up( ds, state )
        -: 1212:int ds;
        -: 1213:int state[];
        -: 1214:	{
    11249: 1215:	if ( (reject && ! dfaacc[ds].dfaacc_set) ||
branch  0 taken 3567 (fallthrough)
branch  1 taken 7682
branch  2 taken 2812 (fallthrough)
branch  3 taken 755
    10494: 1216:	     (! reject && ! dfaacc[ds].dfaacc_state) )
branch  0 taken 7682 (fallthrough)
branch  1 taken 2812
branch  2 taken 1721 (fallthrough)
branch  3 taken 5961
        -: 1217:		{ /* state is non-accepting */
     2476: 1218:		++num_backing_up;
        -: 1219:
     2476: 1220:		if ( backing_up_report )
branch  0 taken 4 (fallthrough)
branch  1 taken 2472
        -: 1221:			{
        4: 1222:			fprintf( backing_up_file,
call    0 returned 4
        -: 1223:				"State #%d is non-accepting -\n", ds );
        -: 1224:
        -: 1225:			/* identify the state */
        4: 1226:			dump_associated_rules( backing_up_file, ds );
call    0 returned 4
        -: 1227:
        -: 1228:			/* Now identify it further using the out- and
        -: 1229:			 * jam-transitions.
        -: 1230:			 */
        4: 1231:			dump_transitions( backing_up_file, state );
call    0 returned 4
        -: 1232:
        4: 1233:			putc( '\n', backing_up_file );
call    0 returned 4
        -: 1234:			}
        -: 1235:		}
    11249: 1236:	}
        -: 1237:
        -: 1238:
        -: 1239:/* check_trailing_context - check to see if NFA state set constitutes
        -: 1240: *                          "dangerous" trailing context
        -: 1241: *
        -: 1242: * synopsis
        -: 1243: *    void check_trailing_context( int nfa_states[num_states+1], int num_states,
        -: 1244: *				int accset[nacc+1], int nacc );
        -: 1245: *
        -: 1246: * NOTES
        -: 1247: *  Trailing context is "dangerous" if both the head and the trailing
        -: 1248: *  part are of variable size \and/ there's a DFA state which contains
        -: 1249: *  both an accepting state for the head part of the rule and NFA states
        -: 1250: *  which occur after the beginning of the trailing context.
        -: 1251: *
        -: 1252: *  When such a rule is matched, it's impossible to tell if having been
        -: 1253: *  in the DFA state indicates the beginning of the trailing context or
        -: 1254: *  further-along scanning of the pattern.  In these cases, a warning
        -: 1255: *  message is issued.
        -: 1256: *
        -: 1257: *    nfa_states[1 .. num_states] is the list of NFA states in the DFA.
        -: 1258: *    accset[1 .. nacc] is the list of accepting numbers for the DFA state.
        -: 1259: */
        -: 1260:
function check_trailing_context called 454 returned 100% blocks executed 100%
      454: 1261:void check_trailing_context( nfa_states, num_states, accset, nacc )
        -: 1262:int *nfa_states, num_states;
        -: 1263:int *accset;
        -: 1264:register int nacc;
        -: 1265:	{
        -: 1266:	register int i, j;
        -: 1267:
     1318: 1268:	for ( i = 1; i <= num_states; ++i )
branch  0 taken 866
branch  1 taken 452 (fallthrough)
        -: 1269:		{
      866: 1270:		int ns = nfa_states[i];
      866: 1271:		register int type = state_type[ns];
      866: 1272:		register int ar = assoc_rule[ns];
        -: 1273:
      866: 1274:		if ( type == STATE_NORMAL || rule_type[ar] != RULE_VARIABLE )
branch  0 taken 39 (fallthrough)
branch  1 taken 827
branch  2 taken 39 (fallthrough)
branch  3 taken 0
        -: 1275:			{ /* do nothing */
        -: 1276:			}
        -: 1277:
       39: 1278:		else if ( type == STATE_TRAILING_CONTEXT )
branch  0 taken 39 (fallthrough)
branch  1 taken 0
        -: 1279:			{
        -: 1280:			/* Potential trouble.  Scan set of accepting numbers
        -: 1281:			 * for the one marking the end of the "head".  We
        -: 1282:			 * assume that this looping will be fairly cheap
        -: 1283:			 * since it's rare that an accepting number set
        -: 1284:			 * is large.
        -: 1285:			 */
       78: 1286:			for ( j = 1; j <= nacc; ++j )
branch  0 taken 41
branch  1 taken 37 (fallthrough)
       41: 1287:				if ( accset[j] & YY_TRAILING_HEAD_MASK )
branch  0 taken 2 (fallthrough)
branch  1 taken 39
        -: 1288:					{
        2: 1289:					line_warning(
        -: 1290:						"dangerous trailing context",
        2: 1291:						rule_linenum[ar] );
call    0 returned 2
        2: 1292:					return;
        -: 1293:					}
        -: 1294:			}
        -: 1295:		}
        -: 1296:	}
        -: 1297:
        -: 1298:
        -: 1299:/* dump_associated_rules - list the rules associated with a DFA state
        -: 1300: *
        -: 1301: * Goes through the set of NFA states associated with the DFA and
        -: 1302: * extracts the first MAX_ASSOC_RULES unique rules, sorts them,
        -: 1303: * and writes a report to the given file.
        -: 1304: */
        -: 1305:
function dump_associated_rules called 4 returned 100% blocks executed 95%
        4: 1306:void dump_associated_rules( file, ds )
        -: 1307:FILE *file;
        -: 1308:int ds;
        -: 1309:	{
        -: 1310:	register int i, j;
        4: 1311:	register int num_associated_rules = 0;
        -: 1312:	int rule_set[MAX_ASSOC_RULES + 1];
        4: 1313:	int *dset = dss[ds];
        4: 1314:	int size = dfasiz[ds];
        -: 1315:
       16: 1316:	for ( i = 1; i <= size; ++i )
branch  0 taken 12
branch  1 taken 4 (fallthrough)
        -: 1317:		{
       12: 1318:		register int rule_num = rule_linenum[assoc_rule[dset[i]]];
        -: 1319:
      12*: 1320:		for ( j = 1; j <= num_associated_rules; ++j )
branch  0 taken 8
branch  1 taken 4 (fallthrough)
        8: 1321:			if ( rule_num == rule_set[j] )
branch  0 taken 8 (fallthrough)
branch  1 taken 0
        8: 1322:				break;
        -: 1323:
       12: 1324:		if ( j > num_associated_rules )
branch  0 taken 4 (fallthrough)
branch  1 taken 8
        -: 1325:			{ /* new rule */
        4: 1326:			if ( num_associated_rules < MAX_ASSOC_RULES )
branch  0 taken 4 (fallthrough)
branch  1 taken 0
        4: 1327:				rule_set[++num_associated_rules] = rule_num;
        -: 1328:			}
        -: 1329:		}
        -: 1330:
        4: 1331:	bubble( rule_set, num_associated_rules );
call    0 returned 4
        -: 1332:
        4: 1333:	fprintf( file, " associated rule line numbers:" );
call    0 returned 4
        -: 1334:
        8: 1335:	for ( i = 1; i <= num_associated_rules; ++i )
branch  0 taken 4
branch  1 taken 4 (fallthrough)
        -: 1336:		{
        4: 1337:		if ( i % 8 == 1 )
branch  0 taken 4 (fallthrough)
branch  1 taken 0
        4: 1338:			putc( '\n', file );
call    0 returned 4
        -: 1339:
        4: 1340:		fprintf( file, "\t%d", rule_set[i] );
call    0 returned 4
        -: 1341:		}
        -: 1342:
        4: 1343:	putc( '\n', file );
call    0 returned 4
        4: 1344:	}
        -: 1345:
        -: 1346:
        -: 1347:/* dump_transitions - list the transitions associated with a DFA state
        -: 1348: *
        -: 1349: * synopsis
        -: 1350: *     dump_transitions( FILE *file, int state[numecs] );
        -: 1351: *
        -: 1352: * Goes through the set of out-transitions and lists them in human-readable
        -: 1353: * form (i.e., not as equivalence classes); also lists jam transitions
        -: 1354: * (i.e., all those which are not out-transitions, plus EOF).  The dump
        -: 1355: * is done to the given file.
        -: 1356: */
        -: 1357:
function dump_transitions called 4 returned 100% blocks executed 100%
        4: 1358:void dump_transitions( file, state )
        -: 1359:FILE *file;
        -: 1360:int state[];
        -: 1361:	{
        -: 1362:	register int i, ec;
        -: 1363:	int out_char_set[CSIZE];
        -: 1364:
      900: 1365:	for ( i = 0; i < csize; ++i )
branch  0 taken 896
branch  1 taken 4 (fallthrough)
        -: 1366:		{
      896: 1367:		ec = abs( ecgroup[i] );
      896: 1368:		out_char_set[i] = state[ec];
        -: 1369:		}
        -: 1370:
        4: 1371:	fprintf( file, " out-transitions: " );
call    0 returned 4
        -: 1372:
        4: 1373:	list_character_set( file, out_char_set );
call    0 returned 4
        -: 1374:
        -: 1375:	/* now invert the members of the set to get the jam transitions */
      900: 1376:	for ( i = 0; i < csize; ++i )
branch  0 taken 896
branch  1 taken 4 (fallthrough)
      896: 1377:		out_char_set[i] = ! out_char_set[i];
        -: 1378:
        4: 1379:	fprintf( file, "\n jam-transitions: EOF " );
call    0 returned 4
        -: 1380:
        4: 1381:	list_character_set( file, out_char_set );
call    0 returned 4
        -: 1382:
        4: 1383:	putc( '\n', file );
call    0 returned 4
        4: 1384:	}
        -: 1385:
        -: 1386:
        -: 1387:/* epsclosure - construct the epsilon closure of a set of ndfa states
        -: 1388: *
        -: 1389: * synopsis
        -: 1390: *    int *epsclosure( int t[num_states], int *numstates_addr,
        -: 1391: *			int accset[num_rules+1], int *nacc_addr,
        -: 1392: *			int *hashval_addr );
        -: 1393: *
        -: 1394: * NOTES
        -: 1395: *  The epsilon closure is the set of all states reachable by an arbitrary
        -: 1396: *  number of epsilon transitions, which themselves do not have epsilon
        -: 1397: *  transitions going out, unioned with the set of states which have non-null
        -: 1398: *  accepting numbers.  t is an array of size numstates of nfa state numbers.
        -: 1399: *  Upon return, t holds the epsilon closure and *numstates_addr is updated.
        -: 1400: *  accset holds a list of the accepting numbers, and the size of accset is
        -: 1401: *  given by *nacc_addr.  t may be subjected to reallocation if it is not
        -: 1402: *  large enough to hold the epsilon closure.
        -: 1403: *
        -: 1404: *  hashval is the hash value for the dfa corresponding to the state set.
        -: 1405: */
        -: 1406:
function epsclosure called 22265 returned 100% blocks executed 70%
    22265: 1407:int *epsclosure( t, ns_addr, accset, nacc_addr, hv_addr )
        -: 1408:int *t, *ns_addr, accset[], *nacc_addr, *hv_addr;
        -: 1409:	{
        -: 1410:	register int stkpos, ns, tsp;
    22265: 1411:	int numstates = *ns_addr, nacc, hashval, transsym, nfaccnum;
        -: 1412:	int stkend, nstate;
        -: 1413:	static int did_stk_init = false, *stk; 
        -: 1414:
        -: 1415:#define MARK_STATE(state) \
        -: 1416:trans1[state] = trans1[state] - MARKER_DIFFERENCE;
        -: 1417:
        -: 1418:#define IS_MARKED(state) (trans1[state] < 0)
        -: 1419:
        -: 1420:#define UNMARK_STATE(state) \
        -: 1421:trans1[state] = trans1[state] + MARKER_DIFFERENCE;
        -: 1422:
        -: 1423:#define CHECK_ACCEPT(state) \
        -: 1424:{ \
        -: 1425:nfaccnum = accptnum[state]; \
        -: 1426:if ( nfaccnum != NIL ) \
        -: 1427:accset[++nacc] = nfaccnum; \
        -: 1428:}
        -: 1429:
        -: 1430:#define DO_REALLOCATION \
        -: 1431:{ \
        -: 1432:current_max_dfa_size += MAX_DFA_SIZE_INCREMENT; \
        -: 1433:++num_reallocs; \
        -: 1434:t = reallocate_integer_array( t, current_max_dfa_size ); \
        -: 1435:stk = reallocate_integer_array( stk, current_max_dfa_size ); \
        -: 1436:} \
        -: 1437:
        -: 1438:#define PUT_ON_STACK(state) \
        -: 1439:{ \
        -: 1440:if ( ++stkend >= current_max_dfa_size ) \
        -: 1441:DO_REALLOCATION \
        -: 1442:stk[stkend] = state; \
        -: 1443:MARK_STATE(state) \
        -: 1444:}
        -: 1445:
        -: 1446:#define ADD_STATE(state) \
        -: 1447:{ \
        -: 1448:if ( ++numstates >= current_max_dfa_size ) \
        -: 1449:DO_REALLOCATION \
        -: 1450:t[numstates] = state; \
        -: 1451:hashval += state; \
        -: 1452:}
        -: 1453:
        -: 1454:#define STACK_STATE(state) \
        -: 1455:{ \
        -: 1456:PUT_ON_STACK(state) \
        -: 1457:CHECK_ACCEPT(state) \
        -: 1458:if ( nfaccnum != NIL || transchar[state] != SYM_EPSILON ) \
        -: 1459:ADD_STATE(state) \
        -: 1460:}
        -: 1461:
        -: 1462:
    22265: 1463:	if ( ! did_stk_init )
branch  0 taken 541 (fallthrough)
branch  1 taken 21724
        -: 1464:		{
      541: 1465:		stk = allocate_integer_array( current_max_dfa_size );
call    0 returned 541
      541: 1466:		did_stk_init = true;
        -: 1467:		}
        -: 1468:
    22265: 1469:	nacc = stkend = hashval = 0;
        -: 1470:
    62070: 1471:	for ( nstate = 1; nstate <= numstates; ++nstate )
branch  0 taken 39805
branch  1 taken 22265 (fallthrough)
        -: 1472:		{
    39805: 1473:		ns = t[nstate];
        -: 1474:
        -: 1475:		/* The state could be marked if we've already pushed it onto
        -: 1476:		 * the stack.
        -: 1477:		 */
    39805: 1478:		if ( ! IS_MARKED(ns) )
branch  0 taken 39805 (fallthrough)
branch  1 taken 0
        -: 1479:			{
   39805*: 1480:			PUT_ON_STACK(ns)
branch  0 taken 0 (fallthrough)
branch  1 taken 39805
call    2 never executed
call    3 never executed
    39805: 1481:			CHECK_ACCEPT(ns)
branch  0 taken 19860 (fallthrough)
branch  1 taken 19945
    39805: 1482:			hashval += ns;
        -: 1483:			}
        -: 1484:		}
        -: 1485:
   110131: 1486:	for ( stkpos = 1; stkpos <= stkend; ++stkpos )
branch  0 taken 87866
branch  1 taken 22265 (fallthrough)
        -: 1487:		{
    87866: 1488:		ns = stk[stkpos];
    87866: 1489:		transsym = transchar[ns];
        -: 1490:
    87866: 1491:		if ( transsym == SYM_EPSILON )
branch  0 taken 57144 (fallthrough)
branch  1 taken 30722
        -: 1492:			{
    57144: 1493:			tsp = trans1[ns] + MARKER_DIFFERENCE;
        -: 1494:
    57144: 1495:			if ( tsp != NO_TRANSITION )
branch  0 taken 27282 (fallthrough)
branch  1 taken 29862
        -: 1496:				{
    27282: 1497:				if ( ! IS_MARKED(tsp) )
branch  0 taken 27282 (fallthrough)
branch  1 taken 0
   27282*: 1498:					STACK_STATE(tsp)
branch  0 taken 0 (fallthrough)
branch  1 taken 27282
call    2 never executed
call    3 never executed
branch  4 taken 0 (fallthrough)
branch  5 taken 27282
branch  6 taken 27282 (fallthrough)
branch  7 taken 0
branch  8 taken 17728 (fallthrough)
branch  9 taken 9554
branch 10 taken 0 (fallthrough)
branch 11 taken 17728
call   12 never executed
call   13 never executed
        -: 1499:
    27282: 1500:				tsp = trans2[ns];
        -: 1501:
    27282: 1502:				if ( tsp != NO_TRANSITION && ! IS_MARKED(tsp) )
branch  0 taken 20780 (fallthrough)
branch  1 taken 6502
branch  2 taken 20779 (fallthrough)
branch  3 taken 1
   20779*: 1503:					STACK_STATE(tsp)
branch  0 taken 0 (fallthrough)
branch  1 taken 20779
call    2 never executed
call    3 never executed
branch  4 taken 9661 (fallthrough)
branch  5 taken 11118
branch  6 taken 11118 (fallthrough)
branch  7 taken 9661
branch  8 taken 5846 (fallthrough)
branch  9 taken 5272
branch 10 taken 0 (fallthrough)
branch 11 taken 15507
call   12 never executed
call   13 never executed
        -: 1504:				}
        -: 1505:			}
        -: 1506:		}
        -: 1507:
        -: 1508:	/* Clear out "visit" markers. */
        -: 1509:
   110131: 1510:	for ( stkpos = 1; stkpos <= stkend; ++stkpos )
branch  0 taken 87866
branch  1 taken 22265 (fallthrough)
        -: 1511:		{
    87866: 1512:		if ( IS_MARKED(stk[stkpos]) )
branch  0 taken 87866 (fallthrough)
branch  1 taken 0
    87866: 1513:			UNMARK_STATE(stk[stkpos])
        -: 1514:		else
    #####: 1515:			flexfatal( "consistency check failed in epsclosure()" );
call    0 never executed
        -: 1516:		}
        -: 1517:
    22265: 1518:	*ns_addr = numstates;
    22265: 1519:	*hv_addr = hashval;
    22265: 1520:	*nacc_addr = nacc;
        -: 1521:
    22265: 1522:	return t;
        -: 1523:	}
        -: 1524:
        -: 1525:
        -: 1526:/* increase_max_dfas - increase the maximum number of DFAs */
        -: 1527:
function increase_max_dfas called 0 returned 0% blocks executed 0%
    #####: 1528:void increase_max_dfas()
        -: 1529:	{
    #####: 1530:	current_max_dfas += MAX_DFAS_INCREMENT;
        -: 1531:
    #####: 1532:	++num_reallocs;
        -: 1533:
    #####: 1534:	base = reallocate_integer_array( base, current_max_dfas );
call    0 never executed
    #####: 1535:	def = reallocate_integer_array( def, current_max_dfas );
call    0 never executed
    #####: 1536:	dfasiz = reallocate_integer_array( dfasiz, current_max_dfas );
call    0 never executed
    #####: 1537:	accsiz = reallocate_integer_array( accsiz, current_max_dfas );
call    0 never executed
    #####: 1538:	dhash = reallocate_integer_array( dhash, current_max_dfas );
call    0 never executed
    #####: 1539:	dss = reallocate_int_ptr_array( dss, current_max_dfas );
call    0 never executed
    #####: 1540:	dfaacc = reallocate_dfaacc_union( dfaacc, current_max_dfas );
call    0 never executed
        -: 1541:
    #####: 1542:	if ( nultrans )
branch  0 never executed
branch  1 never executed
    #####: 1543:		nultrans =
    #####: 1544:			reallocate_integer_array( nultrans, current_max_dfas );
call    0 never executed
    #####: 1545:	}
        -: 1546:
        -: 1547:
        -: 1548:/* ntod - convert an ndfa to a dfa
        -: 1549: *
        -: 1550: * Creates the dfa corresponding to the ndfa we've constructed.  The
        -: 1551: * dfa starts out in state #1.
        -: 1552: */
        -: 1553:
function ntod called 541 returned 100% blocks executed 92%
      541: 1554:void ntod()
        -: 1555:	{
        -: 1556:	int *accset, ds, nacc, newds;
        -: 1557:	int sym, hashval, numstates, dsize;
        -: 1558:	int num_full_table_rows;	/* used only for -f */
        -: 1559:	int *nset, *dset;
        -: 1560:	int targptr, totaltrans, i, comstate, comfreq, targ;
        -: 1561:	int *epsclosure(), snstods(), symlist[CSIZE + 1];
        -: 1562:	int num_start_states;
        -: 1563:	int todo_head, todo_next;
        -: 1564:
        -: 1565:	/* Note that the following are indexed by *equivalence classes*
        -: 1566:	 * and not by characters.  Since equivalence classes are indexed
        -: 1567:	 * beginning with 1, even if the scanner accepts NUL's, this
        -: 1568:	 * means that (since every character is potentially in its own
        -: 1569:	 * equivalence class) these arrays must have room for indices
        -: 1570:	 * from 1 to CSIZE, so their size must be CSIZE + 1.
        -: 1571:	 */
        -: 1572:	int duplist[CSIZE + 1], state[CSIZE + 1];
        -: 1573:	int targfreq[CSIZE + 1], targstate[CSIZE + 1];
        -: 1574:
      541: 1575:	accset = allocate_integer_array( num_rules + 1 );
call    0 returned 541
      541: 1576:	nset = allocate_integer_array( current_max_dfa_size );
call    0 returned 541
        -: 1577:
        -: 1578:	/* The "todo" queue is represented by the head, which is the DFA
        -: 1579:	 * state currently being processed, and the "next", which is the
        -: 1580:	 * next DFA state number available (not in use).  We depend on the
        -: 1581:	 * fact that snstods() returns DFA's \in increasing order/, and thus
        -: 1582:	 * need only know the bounds of the dfas to be processed.
        -: 1583:	 */
      541: 1584:	todo_head = todo_next = 0;
        -: 1585:
   129850: 1586:	for ( i = 0; i <= csize; ++i )
branch  0 taken 129309
branch  1 taken 541 (fallthrough)
        -: 1587:		{
   129309: 1588:		duplist[i] = NIL;
   129309: 1589:		symlist[i] = false;
        -: 1590:		}
        -: 1591:
     4323: 1592:	for ( i = 0; i <= num_rules; ++i )
branch  0 taken 3782
branch  1 taken 541 (fallthrough)
     3782: 1593:		accset[i] = NIL;
        -: 1594:
      541: 1595:	if ( trace )
branch  0 taken 12 (fallthrough)
branch  1 taken 529
        -: 1596:		{
       12: 1597:		dumpnfa( scset[1] );
call    0 returned 12
       12: 1598:		fputs( "\n\nDFA Dump:\n\n", err );
call    0 returned 12
        -: 1599:		}
        -: 1600:
      541: 1601:	inittbl();
call    0 returned 541
        -: 1602:
        -: 1603:	/* Check to see whether we should build a separate table for
        -: 1604:	 * transitions on NUL characters.  We don't do this for full-speed
        -: 1605:	 * (-F) scanners, since for them we don't have a simple state
        -: 1606:	 * number lying around with which to index the table.  We also
        -: 1607:	 * don't bother doing it for scanners unless (1) NUL is in its own
        -: 1608:	 * equivalence class (indicated by a positive value of
        -: 1609:	 * ecgroup[NUL]), (2) NUL's equivalence class is the last
        -: 1610:	 * equivalence class, and (3) the number of equivalence classes is
        -: 1611:	 * the same as the number of characters.  This latter case comes
        -: 1612:	 * about when useecs is false or when its true but every character
        -: 1613:	 * still manages to land in its own class (unlikely, but it's
        -: 1614:	 * cheap to check for).  If all these things are true then the
        -: 1615:	 * character code needed to represent NUL's equivalence class for
        -: 1616:	 * indexing the tables is going to take one more bit than the
        -: 1617:	 * number of characters, and therefore we won't be assured of
        -: 1618:	 * being able to fit it into a YY_CHAR variable.  This rules out
        -: 1619:	 * storing the transitions in a compressed table, since the code
        -: 1620:	 * for interpreting them uses a YY_CHAR variable (perhaps it
        -: 1621:	 * should just use an integer, though; this is worth pondering ...
        -: 1622:	 * ###).
        -: 1623:	 *
        -: 1624:	 * Finally, for full tables, we want the number of entries in the
        -: 1625:	 * table to be a power of two so the array references go fast (it
        -: 1626:	 * will just take a shift to compute the major index).  If
        -: 1627:	 * encoding NUL's transitions in the table will spoil this, we
        -: 1628:	 * give it its own table (note that this will be the case if we're
        -: 1629:	 * not using equivalence classes).
        -: 1630:	 */
        -: 1631:
        -: 1632:	/* Note that the test for ecgroup[0] == numecs below accomplishes
        -: 1633:	 * both (1) and (2) above
        -: 1634:	 */
      541: 1635:	if ( ! fullspd && ecgroup[0] == numecs )
branch  0 taken 449 (fallthrough)
branch  1 taken 92
branch  2 taken 197 (fallthrough)
branch  3 taken 252
        -: 1636:		{
        -: 1637:		/* NUL is alone in its equivalence class, which is the
        -: 1638:		 * last one.
        -: 1639:		 */
      197: 1640:		int use_NUL_table = (numecs == csize);
        -: 1641:
      197: 1642:		if ( fulltbl && ! use_NUL_table )
branch  0 taken 22 (fallthrough)
branch  1 taken 175
branch  2 taken 0 (fallthrough)
branch  3 taken 22
        -: 1643:			{
        -: 1644:			/* We still may want to use the table if numecs
        -: 1645:			 * is a power of 2.
        -: 1646:			 */
        -: 1647:			int power_of_two;
        -: 1648:
    #####: 1649:			for ( power_of_two = 1; power_of_two <= csize;
branch  0 never executed
branch  1 never executed
    #####: 1650:			      power_of_two *= 2 )
    #####: 1651:				if ( numecs == power_of_two )
branch  0 never executed
branch  1 never executed
        -: 1652:					{
    #####: 1653:					use_NUL_table = true;
    #####: 1654:					break;
        -: 1655:					}
        -: 1656:			}
        -: 1657:
      197: 1658:		if ( use_NUL_table )
branch  0 taken 196 (fallthrough)
branch  1 taken 1
      196: 1659:			nultrans = allocate_integer_array( current_max_dfas );
call    0 returned 196
        -: 1660:
        -: 1661:		/* From now on, nultrans != nil indicates that we're
        -: 1662:		 * saving null transitions for later, separate encoding.
        -: 1663:		 */
        -: 1664:		}
        -: 1665:
        -: 1666:
      541: 1667:	if ( fullspd )
branch  0 taken 92 (fallthrough)
branch  1 taken 449
        -: 1668:		{
     7416: 1669:		for ( i = 0; i <= numecs; ++i )
branch  0 taken 7324
branch  1 taken 92 (fallthrough)
     7324: 1670:			state[i] = 0;
       92: 1671:		place_state( state, 0, 0 );
call    0 returned 92
        -: 1672:		}
        -: 1673:
      449: 1674:	else if ( fulltbl )
branch  0 taken 23 (fallthrough)
branch  1 taken 426
        -: 1675:		{
       23: 1676:		if ( nultrans )
branch  0 taken 22 (fallthrough)
branch  1 taken 1
        -: 1677:			/* We won't be including NUL's transitions in the
        -: 1678:			 * table, so build it for entries from 0 .. numecs - 1.
        -: 1679:			 */
       22: 1680:			num_full_table_rows = numecs;
        -: 1681:
        -: 1682:		else
        -: 1683:			/* Take into account the fact that we'll be including
        -: 1684:			 * the NUL entries in the transition table.  Build it
        -: 1685:			 * from 0 .. numecs.
        -: 1686:			 */
        1: 1687:			num_full_table_rows = numecs + 1;
        -: 1688:
        -: 1689:		/* Unless -Ca, declare it "short" because it's a real
        -: 1690:		 * long-shot that that won't be large enough.
        -: 1691:		 */
      23*: 1692:		printf( "static const %s yy_nxt[][%d] =\n    {\n",
call    0 returned 23
        -: 1693:			/* '}' so vi doesn't get too confused */
       23: 1694:			long_align ? "long" : "short", num_full_table_rows );
branch  0 taken 0 (fallthrough)
branch  1 taken 23
        -: 1695:
        -: 1696:		/* Generate 0 entries for state #0. */
     2851: 1697:		for ( i = 0; i < num_full_table_rows; ++i )
branch  0 taken 2828
branch  1 taken 23 (fallthrough)
     2828: 1698:			mk2data( 0 );
call    0 returned 2828
        -: 1699:
        -: 1700:		/* Force ',' and dataflush() next call to mk2data().*/
       23: 1701:		datapos = NUMDATAITEMS;
        -: 1702:
        -: 1703:		/* Force extra blank line next dataflush(). */
       23: 1704:		dataline = NUMDATALINES;
        -: 1705:		}
        -: 1706:
        -: 1707:	/* Create the first states. */
        -: 1708:
      541: 1709:	num_start_states = lastsc * 2;
        -: 1710:
     1649: 1711:	for ( i = 1; i <= num_start_states; ++i )
branch  0 taken 1108
branch  1 taken 541 (fallthrough)
        -: 1712:		{
     1108: 1713:		numstates = 1;
        -: 1714:
        -: 1715:		/* For each start condition, make one state for the case when
        -: 1716:		 * we're at the beginning of the line (the '^' operator) and
        -: 1717:		 * one for the case when we're not.
        -: 1718:		 */
     1108: 1719:		if ( i % 2 == 1 )
branch  0 taken 554 (fallthrough)
branch  1 taken 554
      554: 1720:			nset[numstates] = scset[(i / 2) + 1];
        -: 1721:		else
      554: 1722:			nset[numstates] =
      554: 1723:				mkbranch( scbol[i / 2], scset[i / 2] );
call    0 returned 554
        -: 1724:
     1108: 1725:		nset = epsclosure( nset, &numstates, accset, &nacc, &hashval );
call    0 returned 1108
        -: 1726:
     1108: 1727:		if ( snstods( nset, numstates, accset, nacc, hashval, &ds ) )
call    0 returned 1108
branch  1 taken 1108 (fallthrough)
branch  2 taken 0
        -: 1728:			{
     1108: 1729:			numas += nacc;
     1108: 1730:			totnst += numstates;
     1108: 1731:			++todo_next;
        -: 1732:
     1108: 1733:			if ( variable_trailing_context_rules && nacc > 0 )
branch  0 taken 70 (fallthrough)
branch  1 taken 1038
branch  2 taken 0 (fallthrough)
branch  3 taken 70
    #####: 1734:				check_trailing_context( nset, numstates,
call    0 never executed
        -: 1735:							accset, nacc );
        -: 1736:			}
        -: 1737:		}
        -: 1738:
      541: 1739:	if ( ! fullspd )
branch  0 taken 449 (fallthrough)
branch  1 taken 92
        -: 1740:		{
      449: 1741:		if ( ! snstods( nset, 0, accset, 0, 0, &end_of_buffer_state ) )
call    0 returned 449
branch  1 taken 0 (fallthrough)
branch  2 taken 449
    #####: 1742:			flexfatal(
call    0 never executed
        -: 1743:				"could not create unique end-of-buffer state" );
        -: 1744:
      449: 1745:		++numas;
      449: 1746:		++num_start_states;
      449: 1747:		++todo_next;
        -: 1748:		}
        -: 1749:
    13347: 1750:	while ( todo_head < todo_next )
branch  0 taken 12806
branch  1 taken 541 (fallthrough)
        -: 1751:		{
    12806: 1752:		targptr = 0;
    12806: 1753:		totaltrans = 0;
        -: 1754:
  1425202: 1755:		for ( i = 1; i <= numecs; ++i )
branch  0 taken 1412396
branch  1 taken 12806 (fallthrough)
  1412396: 1756:			state[i] = 0;
        -: 1757:
    12806: 1758:		ds = ++todo_head;
        -: 1759:
    12806: 1760:		dset = dss[ds];
    12806: 1761:		dsize = dfasiz[ds];
        -: 1762:
    12806: 1763:		if ( trace )
branch  0 taken 258 (fallthrough)
branch  1 taken 12548
      258: 1764:			fprintf( err, "state # %d:\n", ds );
call    0 returned 258
        -: 1765:
    12806: 1766:		sympartition( dset, dsize, symlist, duplist );
call    0 returned 12806
        -: 1767:
  1425202: 1768:		for ( sym = 1; sym <= numecs; ++sym )
branch  0 taken 1412396
branch  1 taken 12806 (fallthrough)
        -: 1769:			{
  1412396: 1770:			if ( symlist[sym] )
branch  0 taken 226268 (fallthrough)
branch  1 taken 1186128
        -: 1771:				{
   226268: 1772:				symlist[sym] = 0;
        -: 1773:
   226268: 1774:				if ( duplist[sym] == NIL )
branch  0 taken 21157 (fallthrough)
branch  1 taken 205111
        -: 1775:					{
        -: 1776:					/* Symbol has unique out-transitions. */
    21157: 1777:					numstates = symfollowset( dset, dsize,
call    0 returned 21157
        -: 1778:								sym, nset );
    21157: 1779:					nset = epsclosure( nset, &numstates,
call    0 returned 21157
        -: 1780:						accset, &nacc, &hashval );
        -: 1781:
    21157: 1782:					if ( snstods( nset, numstates, accset,
call    0 returned 21157
branch  1 taken 11249 (fallthrough)
branch  2 taken 9908
        -: 1783:						nacc, hashval, &newds ) )
        -: 1784:						{
    11249: 1785:						totnst = totnst + numstates;
    11249: 1786:						++todo_next;
    11249: 1787:						numas += nacc;
        -: 1788:
    11249: 1789:						if (
    11249: 1790:					variable_trailing_context_rules &&
branch  0 taken 704 (fallthrough)
branch  1 taken 10545
      704: 1791:							nacc > 0 )
branch  0 taken 454 (fallthrough)
branch  1 taken 250
      454: 1792:							check_trailing_context(
call    0 returned 454
        -: 1793:								nset, numstates,
        -: 1794:								accset, nacc );
        -: 1795:						}
        -: 1796:
    21157: 1797:					state[sym] = newds;
        -: 1798:
    21157: 1799:					if ( trace )
branch  0 taken 473 (fallthrough)
branch  1 taken 20684
      473: 1800:						fprintf( err, "\t%d\t%d\n",
call    0 returned 473
        -: 1801:							sym, newds );
        -: 1802:
    21157: 1803:					targfreq[++targptr] = 1;
    21157: 1804:					targstate[targptr] = newds;
    21157: 1805:					++numuniq;
        -: 1806:					}
        -: 1807:
        -: 1808:				else
        -: 1809:					{
        -: 1810:					/* sym's equivalence class has the same
        -: 1811:					 * transitions as duplist(sym)'s
        -: 1812:					 * equivalence class.
        -: 1813:					 */
   205111: 1814:					targ = state[duplist[sym]];
   205111: 1815:					state[sym] = targ;
        -: 1816:
   205111: 1817:					if ( trace )
branch  0 taken 1667 (fallthrough)
branch  1 taken 203444
     1667: 1818:						fprintf( err, "\t%d\t%d\n",
call    0 returned 1667
        -: 1819:							sym, targ );
        -: 1820:
        -: 1821:					/* Update frequency count for
        -: 1822:					 * destination state.
        -: 1823:					 */
        -: 1824:
   205111: 1825:					i = 0;
   247557: 1826:					while ( targstate[++i] != targ )
branch  0 taken 42446
branch  1 taken 205111 (fallthrough)
        -: 1827:						;
        -: 1828:
   205111: 1829:					++targfreq[i];
   205111: 1830:					++numdup;
        -: 1831:					}
        -: 1832:
   226268: 1833:				++totaltrans;
   226268: 1834:				duplist[sym] = NIL;
        -: 1835:				}
        -: 1836:			}
        -: 1837:
    12806: 1838:		numsnpairs = numsnpairs + totaltrans;
        -: 1839:
    12806: 1840:		if ( caseins && ! useecs )
branch  0 taken 106 (fallthrough)
branch  1 taken 12700
branch  2 taken 0 (fallthrough)
branch  3 taken 106
        -: 1841:			{
        -: 1842:			register int j;
        -: 1843:
    #####: 1844:			for ( i = 'A', j = 'a'; i <= 'Z'; ++i, ++j )
branch  0 never executed
branch  1 never executed
    #####: 1845:				state[i] = state[j];
        -: 1846:			}
        -: 1847:
    12806: 1848:		if ( ds > num_start_states )
branch  0 taken 11249 (fallthrough)
branch  1 taken 1557
    11249: 1849:			check_for_backing_up( ds, state );
call    0 returned 11249
        -: 1850:
    12806: 1851:		if ( nultrans )
branch  0 taken 4710 (fallthrough)
branch  1 taken 8096
        -: 1852:			{
     4710: 1853:			nultrans[ds] = state[NUL_ec];
     4710: 1854:			state[NUL_ec] = 0;	/* remove transition */
        -: 1855:			}
        -: 1856:
    12806: 1857:		if ( fulltbl )
branch  0 taken 542 (fallthrough)
branch  1 taken 12264
        -: 1858:			{
        -: 1859:			/* Supply array's 0-element. */
      542: 1860:			if ( ds == end_of_buffer_state )
branch  0 taken 23 (fallthrough)
branch  1 taken 519
       23: 1861:				mk2data( -end_of_buffer_state );
call    0 returned 23
        -: 1862:			else
      519: 1863:				mk2data( end_of_buffer_state );
call    0 returned 519
        -: 1864:
    67288: 1865:			for ( i = 1; i < num_full_table_rows; ++i )
branch  0 taken 66746
branch  1 taken 542 (fallthrough)
        -: 1866:				/* Jams are marked by negative of state
        -: 1867:				 * number.
        -: 1868:				 */
    66746: 1869:				mk2data( state[i] ? state[i] : -ds );
branch  0 taken 11603 (fallthrough)
branch  1 taken 55143
call    2 returned 66746
        -: 1870:
        -: 1871:			/* Force ',' and dataflush() next call to mk2data().*/
      542: 1872:			datapos = NUMDATAITEMS;
        -: 1873:
        -: 1874:			/* Force extra blank line next dataflush(). */
      542: 1875:			dataline = NUMDATALINES;
        -: 1876:			}
        -: 1877:
    12264: 1878:		else if ( fullspd )
branch  0 taken 2170 (fallthrough)
branch  1 taken 10094
     2170: 1879:			place_state( state, ds, totaltrans );
call    0 returned 2170
        -: 1880:
    10094: 1881:		else if ( ds == end_of_buffer_state )
branch  0 taken 426 (fallthrough)
branch  1 taken 9668
        -: 1882:			/* Special case this state to make sure it does what
        -: 1883:			 * it's supposed to, i.e., jam on end-of-buffer.
        -: 1884:			 */
      426: 1885:			stack1( ds, 0, 0, JAMSTATE );
call    0 returned 426
        -: 1886:
        -: 1887:		else /* normal, compressed state */
        -: 1888:			{
        -: 1889:			/* Determine which destination state is the most
        -: 1890:			 * common, and how many transitions to it there are.
        -: 1891:			 */
        -: 1892:
     9668: 1893:			comfreq = 0;
     9668: 1894:			comstate = 0;
        -: 1895:
    26253: 1896:			for ( i = 1; i <= targptr; ++i )
branch  0 taken 16585
branch  1 taken 9668 (fallthrough)
    16585: 1897:				if ( targfreq[i] > comfreq )
branch  0 taken 7982 (fallthrough)
branch  1 taken 8603
        -: 1898:					{
     7982: 1899:					comfreq = targfreq[i];
     7982: 1900:					comstate = targstate[i];
        -: 1901:					}
        -: 1902:
     9668: 1903:			bldtbl( state, ds, totaltrans, comstate, comfreq );
call    0 returned 9668
        -: 1904:			}
        -: 1905:		}
        -: 1906:
      541: 1907:	if ( fulltbl )
branch  0 taken 23 (fallthrough)
branch  1 taken 518
       23: 1908:		dataend();
call    0 returned 23
        -: 1909:
      518: 1910:	else if ( ! fullspd )
branch  0 taken 426 (fallthrough)
branch  1 taken 92
        -: 1911:		{
      426: 1912:		cmptmps();  /* create compressed template entries */
call    0 returned 426
        -: 1913:
        -: 1914:		/* Create tables for all the states with only one
        -: 1915:		 * out-transition.
        -: 1916:		 */
     6038: 1917:		while ( onesp > 0 )
branch  0 taken 5612
branch  1 taken 426 (fallthrough)
        -: 1918:			{
     5612: 1919:			mk1tbl( onestate[onesp], onesym[onesp], onenext[onesp],
call    0 returned 5612
        -: 1920:			onedef[onesp] );
     5612: 1921:			--onesp;
        -: 1922:			}
        -: 1923:
      426: 1924:		mkdeftbl();
call    0 returned 426
        -: 1925:		}
      541: 1926:	}
        -: 1927:
        -: 1928:
        -: 1929:/* snstods - converts a set of ndfa states into a dfa state
        -: 1930: *
        -: 1931: * synopsis
        -: 1932: *    is_new_state = snstods( int sns[numstates], int numstates,
        -: 1933: *				int accset[num_rules+1], int nacc,
        -: 1934: *				int hashval, int *newds_addr );
        -: 1935: *
        -: 1936: * On return, the dfa state number is in newds.
        -: 1937: */
        -: 1938:
function snstods called 22714 returned 100% blocks executed 98%
    22714: 1939:int snstods( sns, numstates, accset, nacc, hashval, newds_addr )
        -: 1940:int sns[], numstates, accset[], nacc, hashval, *newds_addr;
        -: 1941:	{
    22714: 1942:	int didsort = 0;
        -: 1943:	register int i, j;
        -: 1944:	int newds, *oldsns;
        -: 1945:
   328037: 1946:	for ( i = 1; i <= lastdfa; ++i )
branch  0 taken 315231
branch  1 taken 12806 (fallthrough)
   315231: 1947:		if ( hashval == dhash[i] )
branch  0 taken 10031 (fallthrough)
branch  1 taken 305200
        -: 1948:			{
    10031: 1949:			if ( numstates == dfasiz[i] )
branch  0 taken 9909 (fallthrough)
branch  1 taken 122
        -: 1950:				{
     9909: 1951:				oldsns = dss[i];
        -: 1952:
     9909: 1953:				if ( ! didsort )
branch  0 taken 9909 (fallthrough)
branch  1 taken 0
        -: 1954:					{
        -: 1955:					/* We sort the states in sns so we
        -: 1956:					 * can compare it to oldsns quickly.
        -: 1957:					 * We use bubble because there probably
        -: 1958:					 * aren't very many states.
        -: 1959:					 */
     9909: 1960:					bubble( sns, numstates );
call    0 returned 9909
     9909: 1961:					didsort = 1;
        -: 1962:					}
        -: 1963:
    41046: 1964:				for ( j = 1; j <= numstates; ++j )
branch  0 taken 31138
branch  1 taken 9908 (fallthrough)
    31138: 1965:					if ( sns[j] != oldsns[j] )
branch  0 taken 1 (fallthrough)
branch  1 taken 31137
        1: 1966:						break;
        -: 1967:
     9909: 1968:				if ( j > numstates )
branch  0 taken 9908 (fallthrough)
branch  1 taken 1
        -: 1969:					{
     9908: 1970:					++dfaeql;
     9908: 1971:					*newds_addr = i;
     9908: 1972:					return 0;
        -: 1973:					}
        -: 1974:
        1: 1975:				++hshcol;
        -: 1976:				}
        -: 1977:
        -: 1978:			else
      122: 1979:				++hshsave;
        -: 1980:			}
        -: 1981:
        -: 1982:	/* Make a new dfa. */
        -: 1983:
    12806: 1984:	if ( ++lastdfa >= current_max_dfas )
branch  0 taken 0 (fallthrough)
branch  1 taken 12806
    #####: 1985:		increase_max_dfas();
call    0 never executed
        -: 1986:
    12806: 1987:	newds = lastdfa;
        -: 1988:
    12806: 1989:	dss[newds] = allocate_integer_array( numstates + 1 );
call    0 returned 12806
        -: 1990:
        -: 1991:	/* If we haven't already sorted the states in sns, we do so now,
        -: 1992:	 * so that future comparisons with it can be made quickly.
        -: 1993:	 */
        -: 1994:
    12806: 1995:	if ( ! didsort )
branch  0 taken 12805 (fallthrough)
branch  1 taken 1
    12805: 1996:		bubble( sns, numstates );
call    0 returned 12805
        -: 1997:
    54709: 1998:	for ( i = 1; i <= numstates; ++i )
branch  0 taken 41903
branch  1 taken 12806 (fallthrough)
    41903: 1999:		dss[newds][i] = sns[i];
        -: 2000:
    12806: 2001:	dfasiz[newds] = numstates;
    12806: 2002:	dhash[newds] = hashval;
        -: 2003:
    12806: 2004:	if ( nacc == 0 )
branch  0 taken 3621 (fallthrough)
branch  1 taken 9185
        -: 2005:		{
     3621: 2006:		if ( reject )
branch  0 taken 1135 (fallthrough)
branch  1 taken 2486
     1135: 2007:			dfaacc[newds].dfaacc_set = (int *) 0;
        -: 2008:		else
     2486: 2009:			dfaacc[newds].dfaacc_state = 0;
        -: 2010:
     3621: 2011:		accsiz[newds] = 0;
        -: 2012:		}
        -: 2013:
     9185: 2014:	else if ( reject )
branch  0 taken 2942 (fallthrough)
branch  1 taken 6243
        -: 2015:		{
        -: 2016:		/* We sort the accepting set in increasing order so the
        -: 2017:		 * disambiguating rule that the first rule listed is considered
        -: 2018:		 * match in the event of ties will work.  We use a bubble
        -: 2019:		 * sort since the list is probably quite small.
        -: 2020:		 */
        -: 2021:
     2942: 2022:		bubble( accset, nacc );
call    0 returned 2942
        -: 2023:
     2942: 2024:		dfaacc[newds].dfaacc_set = allocate_integer_array( nacc + 1 );
call    0 returned 2942
        -: 2025:
        -: 2026:		/* Save the accepting set for later */
     7373: 2027:		for ( i = 1; i <= nacc; ++i )
branch  0 taken 4431
branch  1 taken 2942 (fallthrough)
        -: 2028:			{
     4431: 2029:			dfaacc[newds].dfaacc_set[i] = accset[i];
        -: 2030:
     4431: 2031:			if ( accset[i] <= num_rules )
branch  0 taken 4361 (fallthrough)
branch  1 taken 70
        -: 2032:				/* Who knows, perhaps a REJECT can yield
        -: 2033:				 * this rule.
        -: 2034:				 */
     4361: 2035:				rule_useful[accset[i]] = true;
        -: 2036:			}
        -: 2037:
     2942: 2038:		accsiz[newds] = nacc;
        -: 2039:		}
        -: 2040:
        -: 2041:	else
        -: 2042:		{
        -: 2043:		/* Find lowest numbered rule so the disambiguating rule
        -: 2044:		 * will work.
        -: 2045:		 */
     6243: 2046:		j = num_rules + 1;
        -: 2047:
    15599: 2048:		for ( i = 1; i <= nacc; ++i )
branch  0 taken 9356
branch  1 taken 6243 (fallthrough)
     9356: 2049:			if ( accset[i] < j )
branch  0 taken 6887 (fallthrough)
branch  1 taken 2469
     6887: 2050:				j = accset[i];
        -: 2051:
     6243: 2052:		dfaacc[newds].dfaacc_state = j;
        -: 2053:
     6243: 2054:		if ( j <= num_rules )
branch  0 taken 6243 (fallthrough)
branch  1 taken 0
     6243: 2055:			rule_useful[j] = true;
        -: 2056:		}
        -: 2057:
    12806: 2058:	*newds_addr = newds;
        -: 2059:
    12806: 2060:	return 1;
        -: 2061:	}
        -: 2062:
        -: 2063:
        -: 2064:/* symfollowset - follow the symbol transitions one step
        -: 2065: *
        -: 2066: * synopsis
        -: 2067: *    numstates = symfollowset( int ds[current_max_dfa_size], int dsize,
        -: 2068: *				int transsym, int nset[current_max_dfa_size] );
        -: 2069: */
        -: 2070:
function symfollowset called 21157 returned 100% blocks executed 94%
    21157: 2071:int symfollowset( ds, dsize, transsym, nset )
        -: 2072:int ds[], dsize, transsym, nset[];
        -: 2073:	{
        -: 2074:	int ns, tsp, sym, i, j, lenccl, ch, numstates, ccllist;
        -: 2075:
    21157: 2076:	numstates = 0;
        -: 2077:
   173173: 2078:	for ( i = 1; i <= dsize; ++i )
branch  0 taken 152016
branch  1 taken 21157 (fallthrough)
        -: 2079:		{ /* for each nfa state ns in the state set of ds */
   152016: 2080:		ns = ds[i];
   152016: 2081:		sym = transchar[ns];
   152016: 2082:		tsp = trans1[ns];
        -: 2083:
   152016: 2084:		if ( sym < 0 )
branch  0 taken 43707 (fallthrough)
branch  1 taken 108309
        -: 2085:			{ /* it's a character class */
    43707: 2086:			sym = -sym;
    43707: 2087:			ccllist = cclmap[sym];
    43707: 2088:			lenccl = ccllen[sym];
        -: 2089:
    43707: 2090:			if ( cclng[sym] )
branch  0 taken 15814 (fallthrough)
branch  1 taken 27893
        -: 2091:				{
    34882: 2092:				for ( j = 0; j < lenccl; ++j )
branch  0 taken 21332
branch  1 taken 13550 (fallthrough)
        -: 2093:					{
        -: 2094:					/* Loop through negated character
        -: 2095:					 * class.
        -: 2096:					 */
    21332: 2097:					ch = ccltbl[ccllist + j];
        -: 2098:
    21332: 2099:					if ( ch == 0 )
branch  0 taken 0 (fallthrough)
branch  1 taken 21332
    #####: 2100:						ch = NUL_ec;
        -: 2101:
    21332: 2102:					if ( ch > transsym )
branch  0 taken 1050 (fallthrough)
branch  1 taken 20282
        -: 2103:						/* Transsym isn't in negated
        -: 2104:						 * ccl.
        -: 2105:						 */
     1050: 2106:						break;
        -: 2107:
    20282: 2108:					else if ( ch == transsym )
branch  0 taken 1214 (fallthrough)
branch  1 taken 19068
     1214: 2109:						/* next 2 */ goto bottom;
        -: 2110:					}
        -: 2111:
        -: 2112:				/* Didn't find transsym in ccl. */
    14600: 2113:				nset[++numstates] = tsp;
        -: 2114:				}
        -: 2115:
        -: 2116:			else
   108825: 2117:				for ( j = 0; j < lenccl; ++j )
branch  0 taken 100991
branch  1 taken 7834 (fallthrough)
        -: 2118:					{
   100991: 2119:					ch = ccltbl[ccllist + j];
        -: 2120:
   100991: 2121:					if ( ch == 0 )
branch  0 taken 6 (fallthrough)
branch  1 taken 100985
        6: 2122:						ch = NUL_ec;
        -: 2123:
   100991: 2124:					if ( ch > transsym )
branch  0 taken 9390 (fallthrough)
branch  1 taken 91601
     9390: 2125:						break;
    91601: 2126:					else if ( ch == transsym )
branch  0 taken 10669 (fallthrough)
branch  1 taken 80932
        -: 2127:						{
    10669: 2128:						nset[++numstates] = tsp;
    10669: 2129:						break;
        -: 2130:						}
        -: 2131:					}
        -: 2132:			}
        -: 2133:
   108309: 2134:		else if ( sym >= 'A' && sym <= 'Z' && caseins )
branch  0 taken 91687 (fallthrough)
branch  1 taken 16622
branch  2 taken 4530 (fallthrough)
branch  3 taken 87157
branch  4 taken 0 (fallthrough)
branch  5 taken 4530
    #####: 2135:			flexfatal( "consistency check failed in symfollowset" );
call    0 never executed
        -: 2136:
   108309: 2137:		else if ( sym == SYM_EPSILON )
branch  0 taken 71416 (fallthrough)
branch  1 taken 36893
        -: 2138:			{ /* do nothing */
        -: 2139:			}
        -: 2140:
    71416: 2141:		else if ( abs( ecgroup[sym] ) == transsym )
branch  0 taken 57988 (fallthrough)
branch  1 taken 13428
    13428: 2142:			nset[++numstates] = tsp;
        -: 2143:
   152016: 2144:		bottom: ;
        -: 2145:		}
        -: 2146:
    21157: 2147:	return numstates;
        -: 2148:	}
        -: 2149:
        -: 2150:
        -: 2151:/* sympartition - partition characters with same out-transitions
        -: 2152: *
        -: 2153: * synopsis
        -: 2154: *    sympartition( int ds[current_max_dfa_size], int numstates,
        -: 2155: *			int symlist[numecs], int duplist[numecs] );
        -: 2156: */
        -: 2157:
function sympartition called 12806 returned 100% blocks executed 94%
    12806: 2158:void sympartition( ds, numstates, symlist, duplist )
        -: 2159:int ds[], numstates;
        -: 2160:int symlist[], duplist[];
        -: 2161:	{
        -: 2162:	int tch, i, j, k, ns, dupfwd[CSIZE + 1], lenccl, cclp, ich;
        -: 2163:
        -: 2164:	/* Partitioning is done by creating equivalence classes for those
        -: 2165:	 * characters which have out-transitions from the given state.  Thus
        -: 2166:	 * we are really creating equivalence classes of equivalence classes.
        -: 2167:	 */
        -: 2168:
  1425202: 2169:	for ( i = 1; i <= numecs; ++i )
branch  0 taken 1412396
branch  1 taken 12806 (fallthrough)
        -: 2170:		{ /* initialize equivalence class list */
  1412396: 2171:		duplist[i] = i - 1;
  1412396: 2172:		dupfwd[i] = i + 1;
        -: 2173:		}
        -: 2174:
    12806: 2175:	duplist[1] = NIL;
    12806: 2176:	dupfwd[numecs] = NIL;
        -: 2177:
    54709: 2178:	for ( i = 1; i <= numstates; ++i )
branch  0 taken 41903
branch  1 taken 12806 (fallthrough)
        -: 2179:		{
    41903: 2180:		ns = ds[i];
    41903: 2181:		tch = transchar[ns];
        -: 2182:
    41903: 2183:		if ( tch != SYM_EPSILON )
branch  0 taken 21459 (fallthrough)
branch  1 taken 20444
        -: 2184:			{
    21459: 2185:			if ( tch < -lastccl || tch >= csize )
branch  0 taken 21459 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 21459
        -: 2186:				{
    #####: 2187:				flexfatal(
call    0 never executed
        -: 2188:			"bad transition character detected in sympartition()" );
        -: 2189:				}
        -: 2190:
    21459: 2191:			if ( tch >= 0 )
branch  0 taken 13428 (fallthrough)
branch  1 taken 8031
        -: 2192:				{ /* character transition */
    13428: 2193:				int ec = ecgroup[tch];
        -: 2194:
    13428: 2195:				mkechar( ec, dupfwd, duplist );
call    0 returned 13428
    13428: 2196:				symlist[ec] = 1;
        -: 2197:				}
        -: 2198:
        -: 2199:			else
        -: 2200:				{ /* character class */
     8031: 2201:				tch = -tch;
        -: 2202:
     8031: 2203:				lenccl = ccllen[tch];
     8031: 2204:				cclp = cclmap[tch];
     8031: 2205:				mkeccl( ccltbl + cclp, lenccl, dupfwd,
call    0 returned 8031
        -: 2206:					duplist, numecs, NUL_ec );
        -: 2207:
     8031: 2208:				if ( cclng[tch] )
branch  0 taken 1946 (fallthrough)
branch  1 taken 6085
        -: 2209:					{
     1946: 2210:					j = 0;
        -: 2211:
     5824: 2212:					for ( k = 0; k < lenccl; ++k )
branch  0 taken 3878
branch  1 taken 1946 (fallthrough)
        -: 2213:						{
     3878: 2214:						ich = ccltbl[cclp + k];
        -: 2215:
     3878: 2216:						if ( ich == 0 )
branch  0 taken 0 (fallthrough)
branch  1 taken 3878
    #####: 2217:							ich = NUL_ec;
        -: 2218:
    26640: 2219:						for ( ++j; j < ich; ++j )
branch  0 taken 22762
branch  1 taken 3878 (fallthrough)
    22762: 2220:							symlist[j] = 1;
        -: 2221:						}
        -: 2222:
   185408: 2223:					for ( ++j; j <= numecs; ++j )
branch  0 taken 183462
branch  1 taken 1946
   183462: 2224:						symlist[j] = 1;
        -: 2225:					}
        -: 2226:
        -: 2227:				else
    96297: 2228:					for ( k = 0; k < lenccl; ++k )
branch  0 taken 90212
branch  1 taken 6085 (fallthrough)
        -: 2229:						{
    90212: 2230:						ich = ccltbl[cclp + k];
        -: 2231:
    90212: 2232:						if ( ich == 0 )
branch  0 taken 2 (fallthrough)
branch  1 taken 90210
        2: 2233:							ich = NUL_ec;
        -: 2234:
    90212: 2235:						symlist[ich] = 1;
        -: 2236:						}
        -: 2237:				}
        -: 2238:			}
        -: 2239:		}
    12806: 2240:	}
        -: 2241:/* ecs - equivalence class routines */
        -: 2242:
        -: 2243:/*-
        -: 2244: * Copyright (c) 1990 The Regents of the University of California.
        -: 2245: * All rights reserved.
        -: 2246: *
        -: 2247: * This code is derived from software contributed to Berkeley by
        -: 2248: * Vern Paxson.
        -: 2249: * 
        -: 2250: * The United States Government has rights in this work pursuant
        -: 2251: * to contract no. DE-AC03-76SF00098 between the United States
        -: 2252: * Department of Energy and the University of California.
        -: 2253: *
        -: 2254: * Redistribution and use in source and binary forms are permitted provided
        -: 2255: * that: (1) source distributions retain this entire copyright notice and
        -: 2256: * comment, and (2) distributions including binaries display the following
        -: 2257: * acknowledgement:  ``This product includes software developed by the
        -: 2258: * University of California, Berkeley and its contributors'' in the
        -: 2259: * documentation or other materials provided with the distribution and in
        -: 2260: * all advertising materials mentioning features or use of this software.
        -: 2261: * Neither the name of the University nor the names of its contributors may
        -: 2262: * be used to endorse or promote products derived from this software without
        -: 2263: * specific prior written permission.
        -: 2264: * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
        -: 2265: * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
        -: 2266: * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
        -: 2267: */
        -: 2268:
        -: 2269:/* $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.orig/v0/flex.c,v 1.1.1.1 2003/06/02 17:12:00 expsir Exp $ */
        -: 2270:
        -: 2271:
        -: 2272:/* ccl2ecl - convert character classes to set of equivalence classes */
        -: 2273:
function ccl2ecl called 299 returned 100% blocks executed 100%
      299: 2274:void ccl2ecl()
        -: 2275:	{
        -: 2276:	int i, ich, newlen, cclp, ccls, cclmec;
        -: 2277:
     1504: 2278:	for ( i = 1; i <= lastccl; ++i )
branch  0 taken 1205
branch  1 taken 299 (fallthrough)
        -: 2279:		{
        -: 2280:		/* We loop through each character class, and for each character
        -: 2281:		 * in the class, add the character's equivalence class to the
        -: 2282:		 * new "character" class we are creating.  Thus when we are all
        -: 2283:		 * done, character classes will really consist of collections
        -: 2284:		 * of equivalence classes
        -: 2285:		 */
        -: 2286:
     1205: 2287:		newlen = 0;
     1205: 2288:		cclp = cclmap[i];
        -: 2289:
    19746: 2290:		for ( ccls = 0; ccls < ccllen[i]; ++ccls )
branch  0 taken 18541
branch  1 taken 1205 (fallthrough)
        -: 2291:			{
    18541: 2292:			ich = ccltbl[cclp + ccls];
    18541: 2293:			cclmec = ecgroup[ich];
        -: 2294:
    18541: 2295:			if ( cclmec > 0 )
branch  0 taken 4737 (fallthrough)
branch  1 taken 13804
        -: 2296:				{
     4737: 2297:				ccltbl[cclp + newlen] = cclmec;
     4737: 2298:				++newlen;
        -: 2299:				}
        -: 2300:			}
        -: 2301:
     1205: 2302:		ccllen[i] = newlen;
        -: 2303:		}
      299: 2304:	}
        -: 2305:
        -: 2306:
        -: 2307:/* cre8ecs - associate equivalence class numbers with class members
        -: 2308: *
        -: 2309: * fwd is the forward linked-list of equivalence class members.  bck
        -: 2310: * is the backward linked-list, and num is the number of class members.
        -: 2311: *
        -: 2312: * Returned is the number of classes.
        -: 2313: */
        -: 2314:
function cre8ecs called 511 returned 100% blocks executed 100%
      511: 2315:int cre8ecs( fwd, bck, num )
        -: 2316:int fwd[], bck[], num;
        -: 2317:	{
        -: 2318:	int i, j, numcl;
        -: 2319:
      511: 2320:	numcl = 0;
        -: 2321:
        -: 2322:	/* Create equivalence class numbers.  From now on, abs( bck(x) )
        -: 2323:	 * is the equivalence class number for object x.  If bck(x)
        -: 2324:	 * is positive, then x is the representative of its equivalence
        -: 2325:	 * class.
        -: 2326:	 */
    99028: 2327:	for ( i = 1; i <= num; ++i )
branch  0 taken 98517
branch  1 taken 511 (fallthrough)
    98517: 2328:		if ( bck[i] == NIL )
branch  0 taken 4651 (fallthrough)
branch  1 taken 93866
        -: 2329:			{
     4651: 2330:			bck[i] = ++numcl;
    98517: 2331:			for ( j = fwd[i]; j != NIL; j = fwd[j] )
branch  0 taken 93866
branch  1 taken 4651 (fallthrough)
    93866: 2332:				bck[j] = -numcl;
        -: 2333:			}
        -: 2334:
      511: 2335:	return numcl;
        -: 2336:	}
        -: 2337:
        -: 2338:
        -: 2339:/* mkeccl - update equivalence classes based on character class xtions
        -: 2340: *
        -: 2341: * synopsis
        -: 2342: *    Char ccls[];
        -: 2343: *    int lenccl, fwd[llsiz], bck[llsiz], llsiz, NUL_mapping;
        -: 2344: *    void mkeccl( Char ccls[], int lenccl, int fwd[llsiz], int bck[llsiz],
        -: 2345: *			int llsiz, int NUL_mapping );
        -: 2346: *
        -: 2347: * ccls contains the elements of the character class, lenccl is the
        -: 2348: * number of elements in the ccl, fwd is the forward link-list of equivalent
        -: 2349: * characters, bck is the backward link-list, and llsiz size of the link-list.
        -: 2350: *
        -: 2351: * NUL_mapping is the value which NUL (0) should be mapped to.
        -: 2352: */
        -: 2353:
function mkeccl called 9253 returned 100% blocks executed 100%
     9253: 2354:void mkeccl( ccls, lenccl, fwd, bck, llsiz, NUL_mapping )
        -: 2355:Char ccls[];
        -: 2356:int lenccl, fwd[], bck[], llsiz, NUL_mapping;
        -: 2357:	{
        -: 2358:	int cclp, oldec, newec;
        -: 2359:	int cclm, i, j;
        -: 2360:	static unsigned char cclflags[CSIZE];	/* initialized to all '\0' */
        -: 2361:
        -: 2362:	/* Note that it doesn't matter whether or not the character class is
        -: 2363:	 * negated.  The same results will be obtained in either case.
        -: 2364:	 */
        -: 2365:
     9253: 2366:	cclp = 0;
        -: 2367:
    24186: 2368:	while ( cclp < lenccl )
branch  0 taken 14933
branch  1 taken 9253 (fallthrough)
        -: 2369:		{
    14933: 2370:		cclm = ccls[cclp];
        -: 2371:
    14933: 2372:		if ( NUL_mapping && cclm == 0 )
branch  0 taken 14588 (fallthrough)
branch  1 taken 345
branch  2 taken 3 (fallthrough)
branch  3 taken 14585
        3: 2373:			cclm = NUL_mapping;
        -: 2374:
    14933: 2375:		oldec = bck[cclm];
    14933: 2376:		newec = cclm;
        -: 2377:
    14933: 2378:		j = cclp + 1;
        -: 2379:
   640936: 2380:		for ( i = fwd[cclm]; i != NIL && i <= llsiz; i = fwd[i] )
branch  0 taken 626003 (fallthrough)
branch  1 taken 14933
branch  2 taken 626003
branch  3 taken 0 (fallthrough)
        -: 2381:			{ /* look for the symbol in the character class */
   755326: 2382:			for ( ; j < lenccl; ++j )
branch  0 taken 346396
branch  1 taken 408930 (fallthrough)
        -: 2383:				{
        -: 2384:				register int ccl_char;
        -: 2385:
   346396: 2386:				if ( NUL_mapping && ccls[j] == 0 )
branch  0 taken 294609 (fallthrough)
branch  1 taken 51787
branch  2 taken 441 (fallthrough)
branch  3 taken 294168
      441: 2387:					ccl_char = NUL_mapping;
        -: 2388:				else
   345955: 2389:					ccl_char = ccls[j];
        -: 2390:
   346396: 2391:				if ( ccl_char > i )
branch  0 taken 93348 (fallthrough)
branch  1 taken 253048
    93348: 2392:					break;
        -: 2393:
   253048: 2394:				if ( ccl_char == i && ! cclflags[j] )
branch  0 taken 123725 (fallthrough)
branch  1 taken 129323
branch  2 taken 123725 (fallthrough)
branch  3 taken 0
        -: 2395:					{
        -: 2396:					/* We found an old companion of cclm
        -: 2397:					 * in the ccl.  Link it into the new
        -: 2398:					 * equivalence class and flag it as
        -: 2399:					 * having been processed.
        -: 2400:					 */
        -: 2401:
   123725: 2402:					bck[i] = newec;
   123725: 2403:					fwd[newec] = i;
   123725: 2404:					newec = i;
        -: 2405:					/* Set flag so we don't reprocess. */
   123725: 2406:					cclflags[j] = 1;
        -: 2407:
        -: 2408:					/* Get next equivalence class member. */
        -: 2409:					/* continue 2 */
   123725: 2410:					goto next_pt;
        -: 2411:					}
        -: 2412:				}
        -: 2413:
        -: 2414:			/* Symbol isn't in character class.  Put it in the old
        -: 2415:			 * equivalence class.
        -: 2416:			 */
        -: 2417:
   502278: 2418:			bck[i] = oldec;
        -: 2419:
   502278: 2420:			if ( oldec != NIL )
branch  0 taken 501658 (fallthrough)
branch  1 taken 620
   501658: 2421:				fwd[oldec] = i;
        -: 2422:
   502278: 2423:			oldec = i;
        -: 2424:
   626003: 2425:			next_pt: ;
        -: 2426:			}
        -: 2427:
    14933: 2428:		if ( bck[cclm] != NIL || oldec != bck[cclm] )
branch  0 taken 8007 (fallthrough)
branch  1 taken 6926
branch  2 taken 620 (fallthrough)
branch  3 taken 7387
        -: 2429:			{
     7546: 2430:			bck[cclm] = NIL;
     7546: 2431:			fwd[oldec] = NIL;
        -: 2432:			}
        -: 2433:
    14933: 2434:		fwd[newec] = NIL;
        -: 2435:
        -: 2436:		/* Find next ccl member to process. */
        -: 2437:
   138658: 2438:		for ( ++cclp; cclflags[cclp] && cclp < lenccl; ++cclp )
branch  0 taken 123725 (fallthrough)
branch  1 taken 14933
branch  2 taken 123725
branch  3 taken 0 (fallthrough)
        -: 2439:			{
        -: 2440:			/* Reset "doesn't need processing" flag. */
   123725: 2441:			cclflags[cclp] = 0;
        -: 2442:			}
        -: 2443:		}
     9253: 2444:	}
        -: 2445:
        -: 2446:
        -: 2447:/* mkechar - create equivalence class for single character */
        -: 2448:
function mkechar called 18697 returned 100% blocks executed 100%
    18697: 2449:void mkechar( tch, fwd, bck )
        -: 2450:int tch, fwd[], bck[];
        -: 2451:	{
        -: 2452:	/* If until now the character has been a proper subset of
        -: 2453:	 * an equivalence class, break it away to create a new ec
        -: 2454:	 */
        -: 2455:
    18697: 2456:	if ( fwd[tch] != NIL )
branch  0 taken 15456 (fallthrough)
branch  1 taken 3241
    15456: 2457:		bck[fwd[tch]] = bck[tch];
        -: 2458:
    18697: 2459:	if ( bck[tch] != NIL )
branch  0 taken 16588 (fallthrough)
branch  1 taken 2109
    16588: 2460:		fwd[bck[tch]] = fwd[tch];
        -: 2461:
    18697: 2462:	fwd[tch] = NIL;
    18697: 2463:	bck[tch] = NIL;
    18697: 2464:	}
        -: 2465:/* gen - actual generation (writing) of flex scanners */
        -: 2466:
        -: 2467:/*-
        -: 2468: * Copyright (c) 1990 The Regents of the University of California.
        -: 2469: * All rights reserved.
        -: 2470: *
        -: 2471: * This code is derived from software contributed to Berkeley by
        -: 2472: * Vern Paxson.
        -: 2473: * 
        -: 2474: * The United States Government has rights in this work pursuant
        -: 2475: * to contract no. DE-AC03-76SF00098 between the United States
        -: 2476: * Department of Energy and the University of California.
        -: 2477: *
        -: 2478: * Redistribution and use in source and binary forms are permitted provided
        -: 2479: * that: (1) source distributions retain this entire copyright notice and
        -: 2480: * comment, and (2) distributions including binaries display the following
        -: 2481: * acknowledgement:  ``This product includes software developed by the
        -: 2482: * University of California, Berkeley and its contributors'' in the
        -: 2483: * documentation or other materials provided with the distribution and in
        -: 2484: * all advertising materials mentioning features or use of this software.
        -: 2485: * Neither the name of the University nor the names of its contributors may
        -: 2486: * be used to endorse or promote products derived from this software without
        -: 2487: * specific prior written permission.
        -: 2488: * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
        -: 2489: * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
        -: 2490: * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
        -: 2491: */
        -: 2492:
        -: 2493:/* $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.orig/v0/flex.c,v 1.1.1.1 2003/06/02 17:12:00 expsir Exp $ */
        -: 2494:
        -: 2495:
        -: 2496:
        -: 2497:/* declare functions that have forward references */
        -: 2498:
        -: 2499:void gen_next_state PROTO((int));
        -: 2500:void genecs PROTO((void));
        -: 2501:void indent_put2s PROTO((char [], char []));
        -: 2502:void indent_puts PROTO((char []));
        -: 2503:
        -: 2504:
        -: 2505:static int indent_level = 0; /* each level is 8 spaces */
        -: 2506:
        -: 2507:#define indent_up() (++indent_level)
        -: 2508:#define indent_down() (--indent_level)
        -: 2509:#define set_indent(indent_val) indent_level = indent_val
        -: 2510:
        -: 2511:/* *Everything* is done in terms of arrays starting at 1, so provide
        -: 2512: * a null entry for the zero element of all C arrays.
        -: 2513: */
        -: 2514:static char C_short_decl[] = "static const short int %s[%d] =\n    {   0,\n";
        -: 2515:static char C_long_decl[] = "static const long int %s[%d] =\n    {   0,\n";
        -: 2516:static char C_state_decl[] =
        -: 2517:	"static const yy_state_type %s[%d] =\n    {   0,\n";
        -: 2518:
        -: 2519:
        -: 2520:/* Indent to the current level. */
        -: 2521:
function do_indent called 39888 returned 100% blocks executed 78%
    39888: 2522:void do_indent()
        -: 2523:	{
    39888: 2524:	register int i = indent_level * 8;
        -: 2525:
   141804: 2526:	while ( i >= 8 )
branch  0 taken 101916
branch  1 taken 39888 (fallthrough)
        -: 2527:		{
   101916: 2528:		putchar( '\t' );
call    0 returned 101916
   101916: 2529:		i -= 8;
        -: 2530:		}
        -: 2531:
    39888: 2532:	while ( i > 0 )
branch  0 taken 0
branch  1 taken 39888 (fallthrough)
        -: 2533:		{
    #####: 2534:		putchar( ' ' );
call    0 never executed
    #####: 2535:		--i;
        -: 2536:		}
    39888: 2537:	}
        -: 2538:
        -: 2539:
        -: 2540:/* Generate the code to keep backing-up information. */
        -: 2541:
function gen_backing_up called 1619 returned 100% blocks executed 100%
     1619: 2542:void gen_backing_up()
        -: 2543:	{
     1619: 2544:	if ( reject || num_backing_up == 0 )
branch  0 taken 1109 (fallthrough)
branch  1 taken 510
branch  2 taken 2 (fallthrough)
branch  3 taken 1107
      512: 2545:		return;
        -: 2546:
     1107: 2547:	if ( fullspd )
branch  0 taken 276 (fallthrough)
branch  1 taken 831
      276: 2548:		indent_puts( "if ( yy_current_state[-1].yy_nxt )" );
call    0 returned 276
        -: 2549:	else
      831: 2550:		indent_puts( "if ( yy_accept[yy_current_state] )" );
call    0 returned 831
        -: 2551:
     1107: 2552:	indent_up();
     1107: 2553:	indent_puts( "{" );
call    0 returned 1107
     1107: 2554:	indent_puts( "yy_last_accepting_state = yy_current_state;" );
call    0 returned 1107
     1107: 2555:	indent_puts( "yy_last_accepting_cpos = yy_cp;" );
call    0 returned 1107
     1107: 2556:	indent_puts( "}" );
call    0 returned 1107
     1107: 2557:	indent_down();
        -: 2558:	}
        -: 2559:
        -: 2560:
        -: 2561:/* Generate the code to perform the backing up. */
        -: 2562:
function gen_bu_action called 541 returned 100% blocks executed 100%
      541: 2563:void gen_bu_action()
        -: 2564:	{
      541: 2565:	if ( reject || num_backing_up == 0 )
branch  0 taken 371 (fallthrough)
branch  1 taken 170
branch  2 taken 2 (fallthrough)
branch  3 taken 369
      172: 2566:		return;
        -: 2567:
      369: 2568:	set_indent( 3 );
        -: 2569:
      369: 2570:	indent_puts( "case 0: /* must back up */" );
call    0 returned 369
      369: 2571:	indent_puts( "/* undo the effects of YY_DO_BEFORE_ACTION */" );
call    0 returned 369
      369: 2572:	indent_puts( "*yy_cp = yy_hold_char;" );
call    0 returned 369
        -: 2573:
      369: 2574:	if ( fullspd || fulltbl )
branch  0 taken 277 (fallthrough)
branch  1 taken 92
branch  2 taken 21 (fallthrough)
branch  3 taken 256
      113: 2575:		indent_puts( "yy_cp = yy_last_accepting_cpos + 1;" );
call    0 returned 113
        -: 2576:	else
        -: 2577:		/* Backing-up info for compressed tables is taken \after/
        -: 2578:		 * yy_cp has been incremented for the next state.
        -: 2579:		 */
      256: 2580:		indent_puts( "yy_cp = yy_last_accepting_cpos;" );
call    0 returned 256
        -: 2581:
      369: 2582:	indent_puts( "yy_current_state = yy_last_accepting_state;" );
call    0 returned 369
      369: 2583:	indent_puts( "goto yy_find_action;" );
call    0 returned 369
      369: 2584:	putchar( '\n' );
call    0 returned 369
        -: 2585:
      369: 2586:	set_indent( 0 );
        -: 2587:	}
        -: 2588:
        -: 2589:
        -: 2590:/* genctbl - generates full speed compressed transition table */
        -: 2591:
function genctbl called 92 returned 100% blocks executed 94%
       92: 2592:void genctbl()
        -: 2593:	{
        -: 2594:	register int i;
       92: 2595:	int end_of_buffer_action = num_rules + 1;
        -: 2596:
        -: 2597:	/* Table of verify for transition and offset to next state. */
       92: 2598:	printf( "static const struct yy_trans_info yy_transition[%d] =\n",
       92: 2599:		tblend + numecs + 1 );
call    0 returned 92
       92: 2600:	printf( "    {\n" );
call    0 returned 92
        -: 2601:
        -: 2602:	/* We want the transition to be represented as the offset to the
        -: 2603:	 * next state, not the actual state number, which is what it currently
        -: 2604:	 * is.  The offset is base[nxt[i]] - (base of current state)].  That's
        -: 2605:	 * just the difference between the starting points of the two involved
        -: 2606:	 * states (to - from).
        -: 2607:	 *
        -: 2608:	 * First, though, we need to find some way to put in our end-of-buffer
        -: 2609:	 * flags and states.  We do this by making a state with absolutely no
        -: 2610:	 * transitions.  We put it at the end of the table.
        -: 2611:	 */
        -: 2612:
        -: 2613:	/* We need to have room in nxt/chk for two more slots: One for the
        -: 2614:	 * action and one for the end-of-buffer transition.  We now *assume*
        -: 2615:	 * that we're guaranteed the only character we'll try to index this
        -: 2616:	 * nxt/chk pair with is EOB, i.e., 0, so we don't have to make sure
        -: 2617:	 * there's room for jam entries for other characters.
        -: 2618:	 */
        -: 2619:
       92: 2620:	while ( tblend + 2 >= current_max_xpairs )
branch  0 taken 0
branch  1 taken 92 (fallthrough)
    #####: 2621:		expand_nxt_chk();
call    0 never executed
        -: 2622:
       92: 2623:	while ( lastdfa + 1 >= current_max_dfas )
branch  0 taken 0
branch  1 taken 92 (fallthrough)
    #####: 2624:		increase_max_dfas();
call    0 never executed
        -: 2625:
       92: 2626:	base[lastdfa + 1] = tblend + 2;
       92: 2627:	nxt[tblend + 1] = end_of_buffer_action;
       92: 2628:	chk[tblend + 1] = numecs + 1;
       92: 2629:	chk[tblend + 2] = 1; /* anything but EOB */
        -: 2630:
        -: 2631:	/* So that "make test" won't show arb. differences. */
       92: 2632:	nxt[tblend + 2] = 0;
        -: 2633:
        -: 2634:	/* Make sure every state has a end-of-buffer transition and an
        -: 2635:	 * action #.
        -: 2636:	 */
     2354: 2637:	for ( i = 0; i <= lastdfa; ++i )
branch  0 taken 2262
branch  1 taken 92 (fallthrough)
        -: 2638:		{
     2262: 2639:		register int anum = dfaacc[i].dfaacc_state;
        -: 2640:
     2262: 2641:		chk[base[i]] = EOB_POSITION;
     2262: 2642:		chk[base[i] - 1] = ACTION_POSITION;
     2262: 2643:		nxt[base[i] - 1] = anum;	/* action number */
        -: 2644:		}
        -: 2645:
    55605: 2646:	for ( i = 0; i <= tblend; ++i )
branch  0 taken 55513
branch  1 taken 92 (fallthrough)
        -: 2647:		{
    55513: 2648:		if ( chk[i] == EOB_POSITION )
branch  0 taken 2262 (fallthrough)
branch  1 taken 53251
     2262: 2649:			transition_struct_out( 0, base[lastdfa + 1] - i );
call    0 returned 2262
        -: 2650:
    53251: 2651:		else if ( chk[i] == ACTION_POSITION )
branch  0 taken 2262 (fallthrough)
branch  1 taken 50989
     2262: 2652:			transition_struct_out( 0, nxt[i] );
call    0 returned 2262
        -: 2653:
    50989: 2654:		else if ( chk[i] > numecs || chk[i] == 0 )
branch  0 taken 50989 (fallthrough)
branch  1 taken 0
branch  2 taken 18266 (fallthrough)
branch  3 taken 32723
    18266: 2655:			transition_struct_out( 0, 0 );	/* unused slot */
call    0 returned 18266
        -: 2656:
        -: 2657:		else	/* verify, transition */
    32723: 2658:			transition_struct_out( chk[i],
    32723: 2659:						base[nxt[i]] - (i - chk[i]) );
call    0 returned 32723
        -: 2660:		}
        -: 2661:
        -: 2662:
        -: 2663:	/* Here's the final, end-of-buffer state. */
       92: 2664:	transition_struct_out( chk[tblend + 1], nxt[tblend + 1] );
call    0 returned 92
       92: 2665:	transition_struct_out( chk[tblend + 2], nxt[tblend + 2] );
call    0 returned 92
        -: 2666:
       92: 2667:	printf( "    };\n" );
call    0 returned 92
       92: 2668:	printf( "\n" );
call    0 returned 92
        -: 2669:
        -: 2670:	/* Table of pointers to start states. */
       92: 2671:	printf(
        -: 2672:	"static const struct yy_trans_info *yy_start_state_list[%d] =\n",
       92: 2673:		lastsc * 2 + 1 );
call    0 returned 92
       92: 2674:	printf( "    {\n" );	/* } so vi doesn't get confused */
call    0 returned 92
        -: 2675:
      368: 2676:	for ( i = 0; i <= lastsc * 2; ++i )
branch  0 taken 276
branch  1 taken 92 (fallthrough)
      276: 2677:		printf( "    &yy_transition[%d],\n", base[i] );
call    0 returned 276
        -: 2678:
       92: 2679:	dataend();
call    0 returned 92
        -: 2680:
       92: 2681:	if ( useecs )
branch  0 taken 40 (fallthrough)
branch  1 taken 52
       40: 2682:		genecs();
call    0 returned 40
       92: 2683:	}
        -: 2684:
        -: 2685:
        -: 2686:/* Generate equivalence-class tables. */
        -: 2687:
function genecs called 293 returned 100% blocks executed 96%
      293: 2688:void genecs()
        -: 2689:	{
        -: 2690:	Char clower();
        -: 2691:	static char C_char_decl[] = "static const %s %s[%d] =\n    {   0,\n";
        -: 2692:					/* } so vi doesn't get confused */
        -: 2693:	register int i, j;
        -: 2694:	int numrows;
        -: 2695:
      293: 2696:	if ( numecs < csize )
branch  0 taken 293 (fallthrough)
branch  1 taken 0
      293: 2697:		printf( C_char_decl, "YY_CHAR", "yy_ec", csize );
call    0 returned 293
        -: 2698:	else
    #####: 2699:		printf( C_char_decl, "short", "yy_ec", csize );
call    0 never executed
        -: 2700:
    74752: 2701:	for ( i = 1; i < csize; ++i )
branch  0 taken 74459
branch  1 taken 293 (fallthrough)
        -: 2702:		{
    74459: 2703:		if ( caseins && (i >= 'A') && (i <= 'Z') )
branch  0 taken 637 (fallthrough)
branch  1 taken 73822
branch  2 taken 445 (fallthrough)
branch  3 taken 192
branch  4 taken 78 (fallthrough)
branch  5 taken 367
       78: 2704:			ecgroup[i] = ecgroup[clower( i )];
call    0 returned 78
        -: 2705:
    74459: 2706:		ecgroup[i] = abs( ecgroup[i] );
    74459: 2707:		mkdata( ecgroup[i] );
call    0 returned 74459
        -: 2708:		}
        -: 2709:
      293: 2710:	dataend();
call    0 returned 293
        -: 2711:
      293: 2712:	if ( trace )
branch  0 taken 12 (fallthrough)
branch  1 taken 281
        -: 2713:		{
       12: 2714:		fputs( "\n\nEquivalence Classes:\n\n", err );
call    0 returned 12
        -: 2715:
       12: 2716:		numrows = csize / 8;
        -: 2717:
      380: 2718:		for ( j = 0; j < numrows; ++j )
branch  0 taken 368
branch  1 taken 12 (fallthrough)
        -: 2719:			{
     3312: 2720:			for ( i = j; i < csize; i = i + numrows )
branch  0 taken 2944
branch  1 taken 368 (fallthrough)
        -: 2721:				{
     2944: 2722:				fprintf( err, "%4s = %-2d",
call    0 returned 2944
call    1 returned 2944
        -: 2723:					readable_form( i ), ecgroup[i] );
        -: 2724:
     2944: 2725:				putc( ' ', err );
call    0 returned 2944
        -: 2726:				}
        -: 2727:
      368: 2728:			putc( '\n', err );
call    0 returned 368
        -: 2729:			}
        -: 2730:		}
      293: 2731:	}
        -: 2732:
        -: 2733:
        -: 2734:/* Generate the code to find the action number. */
        -: 2735:
function gen_find_action called 541 returned 100% blocks executed 100%
      541: 2736:void gen_find_action()
        -: 2737:	{
      541: 2738:	if ( fullspd )
branch  0 taken 92 (fallthrough)
branch  1 taken 449
       92: 2739:		indent_puts( "yy_act = yy_current_state[-1].yy_nxt;" );
call    0 returned 92
        -: 2740:
      449: 2741:	else if ( fulltbl )
branch  0 taken 23 (fallthrough)
branch  1 taken 426
       23: 2742:		indent_puts( "yy_act = yy_accept[yy_current_state];" );
call    0 returned 23
        -: 2743:
      426: 2744:	else if ( reject )
branch  0 taken 170 (fallthrough)
branch  1 taken 256
        -: 2745:		{
      170: 2746:		indent_puts( "yy_current_state = *--yy_state_ptr;" );
call    0 returned 170
      170: 2747:		indent_puts( "yy_lp = yy_accept[yy_current_state];" );
call    0 returned 170
        -: 2748:
      170: 2749:		puts(
call    0 returned 170
        -: 2750:		"find_rule: /* we branch to this label when backing up */" );
        -: 2751:
      170: 2752:		indent_puts(
call    0 returned 170
        -: 2753:		"for ( ; ; ) /* until we find what rule we matched */" );
        -: 2754:
      170: 2755:		indent_up();
        -: 2756:
      170: 2757:		indent_puts( "{" );
call    0 returned 170
        -: 2758:
      170: 2759:		indent_puts(
call    0 returned 170
        -: 2760:		"if ( yy_lp && yy_lp < yy_accept[yy_current_state + 1] )" );
      170: 2761:		indent_up();
      170: 2762:		indent_puts( "{" );
call    0 returned 170
      170: 2763:		indent_puts( "yy_act = yy_acclist[yy_lp];" );
call    0 returned 170
        -: 2764:
      170: 2765:		if ( variable_trailing_context_rules )
branch  0 taken 35 (fallthrough)
branch  1 taken 135
        -: 2766:			{
       35: 2767:			indent_puts( "if ( yy_act & YY_TRAILING_HEAD_MASK ||" );
call    0 returned 35
       35: 2768:			indent_puts( "     yy_looking_for_trail_begin )" );
call    0 returned 35
       35: 2769:			indent_up();
       35: 2770:			indent_puts( "{" );
call    0 returned 35
        -: 2771:
       35: 2772:			indent_puts(
call    0 returned 35
        -: 2773:				"if ( yy_act == yy_looking_for_trail_begin )" );
       35: 2774:			indent_up();
       35: 2775:			indent_puts( "{" );
call    0 returned 35
       35: 2776:			indent_puts( "yy_looking_for_trail_begin = 0;" );
call    0 returned 35
       35: 2777:			indent_puts( "yy_act &= ~YY_TRAILING_HEAD_MASK;" );
call    0 returned 35
       35: 2778:			indent_puts( "break;" );
call    0 returned 35
       35: 2779:			indent_puts( "}" );
call    0 returned 35
       35: 2780:			indent_down();
        -: 2781:
       35: 2782:			indent_puts( "}" );
call    0 returned 35
       35: 2783:			indent_down();
        -: 2784:
       35: 2785:			indent_puts( "else if ( yy_act & YY_TRAILING_MASK )" );
call    0 returned 35
       35: 2786:			indent_up();
       35: 2787:			indent_puts( "{" );
call    0 returned 35
       35: 2788:			indent_puts(
call    0 returned 35
        -: 2789:		"yy_looking_for_trail_begin = yy_act & ~YY_TRAILING_MASK;" );
       35: 2790:			indent_puts(
call    0 returned 35
        -: 2791:		"yy_looking_for_trail_begin |= YY_TRAILING_HEAD_MASK;" );
        -: 2792:
       35: 2793:			if ( real_reject )
branch  0 taken 31 (fallthrough)
branch  1 taken 4
        -: 2794:				{
        -: 2795:				/* Remember matched text in case we back up
        -: 2796:				 * due to REJECT.
        -: 2797:				 */
       31: 2798:				indent_puts( "yy_full_match = yy_cp;" );
call    0 returned 31
       31: 2799:				indent_puts( "yy_full_state = yy_state_ptr;" );
call    0 returned 31
       31: 2800:				indent_puts( "yy_full_lp = yy_lp;" );
call    0 returned 31
        -: 2801:				}
        -: 2802:
       35: 2803:			indent_puts( "}" );
call    0 returned 35
       35: 2804:			indent_down();
        -: 2805:
       35: 2806:			indent_puts( "else" );
call    0 returned 35
       35: 2807:			indent_up();
       35: 2808:			indent_puts( "{" );
call    0 returned 35
       35: 2809:			indent_puts( "yy_full_match = yy_cp;" );
call    0 returned 35
       35: 2810:			indent_puts( "yy_full_state = yy_state_ptr;" );
call    0 returned 35
       35: 2811:			indent_puts( "yy_full_lp = yy_lp;" );
call    0 returned 35
       35: 2812:			indent_puts( "break;" );
call    0 returned 35
       35: 2813:			indent_puts( "}" );
call    0 returned 35
       35: 2814:			indent_down();
        -: 2815:
       35: 2816:			indent_puts( "++yy_lp;" );
call    0 returned 35
       35: 2817:			indent_puts( "goto find_rule;" );
call    0 returned 35
        -: 2818:			}
        -: 2819:
        -: 2820:		else
        -: 2821:		{
        -: 2822:		/* Remember matched text in case we back up due to trailing
        -: 2823:		 * context plus REJECT.
        -: 2824:		 */
      135: 2825:		indent_up();
      135: 2826:		indent_puts( "{" );
call    0 returned 135
      135: 2827:		indent_puts( "yy_full_match = yy_cp;" );
call    0 returned 135
      135: 2828:		indent_puts( "break;" );
call    0 returned 135
      135: 2829:		indent_puts( "}" );
call    0 returned 135
      135: 2830:		indent_down();
        -: 2831:		}
        -: 2832:
      170: 2833:		indent_puts( "}" );
call    0 returned 170
      170: 2834:		indent_down();
        -: 2835:
      170: 2836:		indent_puts( "--yy_cp;" );
call    0 returned 170
        -: 2837:
        -: 2838:		/* We could consolidate the following two lines with those at
        -: 2839:		 * the beginning, but at the cost of complaints that we're
        -: 2840:		 * branching inside a loop.
        -: 2841:		 */
      170: 2842:		indent_puts( "yy_current_state = *--yy_state_ptr;" );
call    0 returned 170
      170: 2843:		indent_puts( "yy_lp = yy_accept[yy_current_state];" );
call    0 returned 170
        -: 2844:
      170: 2845:		indent_puts( "}" );
call    0 returned 170
        -: 2846:
      170: 2847:		indent_down();
        -: 2848:		}
        -: 2849:
        -: 2850:	else
        -: 2851:		/* compressed */
      256: 2852:		indent_puts( "yy_act = yy_accept[yy_current_state];" );
call    0 returned 256
      541: 2853:	}
        -: 2854:
        -: 2855:
        -: 2856:/* genftbl - generates full transition table */
        -: 2857:
function genftbl called 23 returned 100% blocks executed 93%
       23: 2858:void genftbl()
        -: 2859:	{
        -: 2860:	register int i;
       23: 2861:	int end_of_buffer_action = num_rules + 1;
        -: 2862:
      23*: 2863:	printf( long_align ? C_long_decl : C_short_decl,
branch  0 taken 0 (fallthrough)
branch  1 taken 23
call    2 returned 23
        -: 2864:		"yy_accept", lastdfa + 1 );
        -: 2865:
       23: 2866:	dfaacc[end_of_buffer_state].dfaacc_state = end_of_buffer_action;
        -: 2867:
      565: 2868:	for ( i = 1; i <= lastdfa; ++i )
branch  0 taken 542
branch  1 taken 23 (fallthrough)
        -: 2869:		{
      542: 2870:		register int anum = dfaacc[i].dfaacc_state;
        -: 2871:
      542: 2872:		mkdata( anum );
call    0 returned 542
        -: 2873:
      542: 2874:		if ( trace && anum )
branch  0 taken 18 (fallthrough)
branch  1 taken 524
branch  2 taken 16 (fallthrough)
branch  3 taken 2
       16: 2875:			fprintf( err, "state # %d accepts: [%d]\n",
call    0 returned 16
        -: 2876:				i, anum );
        -: 2877:		}
        -: 2878:
       23: 2879:	dataend();
call    0 returned 23
        -: 2880:
       23: 2881:	if ( useecs )
branch  0 taken 1 (fallthrough)
branch  1 taken 22
        1: 2882:		genecs();
call    0 returned 1
        -: 2883:
        -: 2884:	/* Don't have to dump the actual full table entries - they were
        -: 2885:	 * created on-the-fly.
        -: 2886:	 */
       23: 2887:	}
        -: 2888:
        -: 2889:
        -: 2890:/* Generate the code to find the next compressed-table state. */
        -: 2891:
function gen_next_compressed_state called 1104 returned 100% blocks executed 100%
     1104: 2892:void gen_next_compressed_state( char_map )
        -: 2893:char *char_map;
        -: 2894:	{
     1104: 2895:	indent_put2s( "register YY_CHAR yy_c = %s;", char_map );
call    0 returned 1104
        -: 2896:
        -: 2897:	/* Save the backing-up info \before/ computing the next state
        -: 2898:	 * because we always compute one more state than needed - we
        -: 2899:	 * always proceed until we reach a jam state
        -: 2900:	 */
     1104: 2901:	gen_backing_up();
call    0 returned 1104
        -: 2902:
     1104: 2903:	indent_puts(
call    0 returned 1104
        -: 2904:"while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )" );
     1104: 2905:	indent_up();
     1104: 2906:	indent_puts( "{" );
call    0 returned 1104
     1104: 2907:	indent_puts( "yy_current_state = (int) yy_def[yy_current_state];" );
call    0 returned 1104
        -: 2908:
     1104: 2909:	if ( usemecs )
branch  0 taken 556 (fallthrough)
branch  1 taken 548
        -: 2910:		{
        -: 2911:		/* We've arrange it so that templates are never chained
        -: 2912:		 * to one another.  This means we can afford to make a
        -: 2913:		 * very simple test to see if we need to convert to
        -: 2914:		 * yy_c's meta-equivalence class without worrying
        -: 2915:		 * about erroneously looking up the meta-equivalence
        -: 2916:		 * class twice
        -: 2917:		 */
      556: 2918:		do_indent();
call    0 returned 556
        -: 2919:
        -: 2920:		/* lastdfa + 2 is the beginning of the templates */
      556: 2921:		printf( "if ( yy_current_state >= %d )\n", lastdfa + 2 );
call    0 returned 556
        -: 2922:
      556: 2923:		indent_up();
      556: 2924:		indent_puts( "yy_c = yy_meta[(unsigned int) yy_c];" );
call    0 returned 556
      556: 2925:		indent_down();
        -: 2926:		}
        -: 2927:
     1104: 2928:	indent_puts( "}" );
call    0 returned 1104
     1104: 2929:	indent_down();
        -: 2930:
     1104: 2931:	indent_puts(
call    0 returned 1104
        -: 2932:"yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];" );
     1104: 2933:	}
        -: 2934:
        -: 2935:
        -: 2936:/* Generate the code to find the next match. */
        -: 2937:
function gen_next_match called 541 returned 100% blocks executed 100%
      541: 2938:void gen_next_match()
        -: 2939:	{
        -: 2940:	/* NOTE - changes in here should be reflected in gen_next_state() and
        -: 2941:	 * gen_NUL_trans().
        -: 2942:	 */
      541: 2943:	char *char_map = useecs ? "yy_ec[(unsigned int) *yy_cp]" : "*yy_cp";
branch  0 taken 293 (fallthrough)
branch  1 taken 248
      541: 2944:	char *char_map_2 =
      541: 2945:		useecs ? "yy_ec[(unsigned int) *++yy_cp]" : "*++yy_cp";
branch  0 taken 293 (fallthrough)
branch  1 taken 248
        -: 2946:
      541: 2947:	if ( fulltbl )
branch  0 taken 23 (fallthrough)
branch  1 taken 518
        -: 2948:		{
       23: 2949:		indent_put2s(
call    0 returned 23
        -: 2950:"while ( (yy_current_state = yy_nxt[yy_current_state][(unsigned int)%s]) > 0 )",
        -: 2951:				char_map );
        -: 2952:
       23: 2953:		indent_up();
        -: 2954:
       23: 2955:		if ( num_backing_up > 0 )
branch  0 taken 21 (fallthrough)
branch  1 taken 2
        -: 2956:			{
       21: 2957:			indent_puts( "{" );	/* } for vi */
call    0 returned 21
       21: 2958:			gen_backing_up();
call    0 returned 21
       21: 2959:			putchar( '\n' );
call    0 returned 21
        -: 2960:			}
        -: 2961:
       23: 2962:		indent_puts( "++yy_cp;" );
call    0 returned 23
        -: 2963:
       23: 2964:		if ( num_backing_up > 0 )
branch  0 taken 21 (fallthrough)
branch  1 taken 2
        -: 2965:			/* { for vi */
       21: 2966:			indent_puts( "}" );
call    0 returned 21
        -: 2967:
       23: 2968:		indent_down();
        -: 2969:
       23: 2970:		putchar( '\n' );
call    0 returned 23
       23: 2971:		indent_puts( "yy_current_state = -yy_current_state;" );
call    0 returned 23
        -: 2972:		}
        -: 2973:
      518: 2974:	else if ( fullspd )
branch  0 taken 92 (fallthrough)
branch  1 taken 426
        -: 2975:		{
       92: 2976:		indent_puts( "{" );	/* } for vi */
call    0 returned 92
       92: 2977:		indent_puts(
call    0 returned 92
        -: 2978:		"register const struct yy_trans_info *yy_trans_info;\n" );
       92: 2979:		indent_puts( "register YY_CHAR yy_c;\n" );
call    0 returned 92
       92: 2980:		indent_put2s( "for ( yy_c = %s;", char_map );
call    0 returned 92
       92: 2981:		indent_puts(
call    0 returned 92
        -: 2982:	"      (yy_trans_info = &yy_current_state[(unsigned int) yy_c])->" );
       92: 2983:		indent_puts( "yy_verify == yy_c;" );
call    0 returned 92
       92: 2984:		indent_put2s( "      yy_c = %s )", char_map_2 );
call    0 returned 92
        -: 2985:
       92: 2986:		indent_up();
        -: 2987:
       92: 2988:		if ( num_backing_up > 0 )
branch  0 taken 92 (fallthrough)
branch  1 taken 0
       92: 2989:			indent_puts( "{" );	/* } for vi */
call    0 returned 92
        -: 2990:
       92: 2991:		indent_puts( "yy_current_state += yy_trans_info->yy_nxt;" );
call    0 returned 92
        -: 2992:
       92: 2993:		if ( num_backing_up > 0 )
branch  0 taken 92 (fallthrough)
branch  1 taken 0
        -: 2994:			{
       92: 2995:			putchar( '\n' );
call    0 returned 92
       92: 2996:			gen_backing_up();	/* { for vi */
call    0 returned 92
       92: 2997:			indent_puts( "}" );
call    0 returned 92
        -: 2998:			}
        -: 2999:
       92: 3000:		indent_down();	/* { for vi */
       92: 3001:		indent_puts( "}" );
call    0 returned 92
        -: 3002:		}
        -: 3003:
        -: 3004:	else
        -: 3005:		{ /* compressed */
      426: 3006:		indent_puts( "do" );
call    0 returned 426
        -: 3007:
      426: 3008:		indent_up();
      426: 3009:		indent_puts( "{" );	/* } for vi */
call    0 returned 426
        -: 3010:
      426: 3011:		gen_next_state( false );
call    0 returned 426
        -: 3012:
      426: 3013:		indent_puts( "++yy_cp;" );
call    0 returned 426
        -: 3014:
        -: 3015:		/* { for vi */
      426: 3016:		indent_puts( "}" );
call    0 returned 426
      426: 3017:		indent_down();
        -: 3018:
      426: 3019:		do_indent();
call    0 returned 426
        -: 3020:
      426: 3021:		if ( interactive )
branch  0 taken 424 (fallthrough)
branch  1 taken 2
      424: 3022:			printf( "while ( yy_base[yy_current_state] != %d );\n",
call    0 returned 424
        -: 3023:				jambase );
        -: 3024:		else
        2: 3025:			printf( "while ( yy_current_state != %d );\n",
call    0 returned 2
        -: 3026:				jamstate );
        -: 3027:
      426: 3028:		if ( ! reject && ! interactive )
branch  0 taken 256 (fallthrough)
branch  1 taken 170
branch  2 taken 1 (fallthrough)
branch  3 taken 255
        -: 3029:			{
        -: 3030:			/* Do the guaranteed-needed backing up to figure out
        -: 3031:			 * the match.
        -: 3032:			 */
        1: 3033:			indent_puts( "yy_cp = yy_last_accepting_cpos;" );
call    0 returned 1
        1: 3034:			indent_puts(
call    0 returned 1
        -: 3035:				"yy_current_state = yy_last_accepting_state;" );
        -: 3036:			}
        -: 3037:		}
      541: 3038:	}
        -: 3039:
        -: 3040:
        -: 3041:/* Generate the code to find the next state. */
        -: 3042:
function gen_next_state called 967 returned 100% blocks executed 100%
      967: 3043:void gen_next_state( worry_about_NULs )
        -: 3044:int worry_about_NULs;
        -: 3045:	{ /* NOTE - changes in here should be reflected in get_next_match() */
        -: 3046:	char char_map[256];
        -: 3047:
      967: 3048:	if ( worry_about_NULs && ! nultrans )
branch  0 taken 541 (fallthrough)
branch  1 taken 426
branch  2 taken 345 (fallthrough)
branch  3 taken 196
        -: 3049:		{
      345: 3050:		if ( useecs )
branch  0 taken 293 (fallthrough)
branch  1 taken 52
      293: 3051:			(void) sprintf( char_map,
        -: 3052:				"(*yy_cp ? yy_ec[(unsigned int) *yy_cp] : %d)",
        -: 3053:					NUL_ec );
        -: 3054:		else
       52: 3055:			(void) sprintf( char_map,
        -: 3056:				"(*yy_cp ? *yy_cp : %d)", NUL_ec );
        -: 3057:		}
        -: 3058:
        -: 3059:	else
      622: 3060:		yy_strcpy( char_map,
call    0 returned 622
      622: 3061:			useecs ? "yy_ec[(unsigned int) *yy_cp]" : "*yy_cp" );
branch  0 taken 252 (fallthrough)
branch  1 taken 370
        -: 3062:
      967: 3063:	if ( worry_about_NULs && nultrans )
branch  0 taken 541 (fallthrough)
branch  1 taken 426
branch  2 taken 196 (fallthrough)
branch  3 taken 345
        -: 3064:		{
      196: 3065:		if ( ! fulltbl && ! fullspd )
branch  0 taken 174 (fallthrough)
branch  1 taken 22
branch  2 taken 174 (fallthrough)
branch  3 taken 0
        -: 3066:			/* Compressed tables back up *before* they match. */
      174: 3067:			gen_backing_up();
call    0 returned 174
        -: 3068:
      196: 3069:		indent_puts( "if ( *yy_cp )" );
call    0 returned 196
      196: 3070:		indent_up();
      196: 3071:		indent_puts( "{" );	/* } for vi */
call    0 returned 196
        -: 3072:		}
        -: 3073:
      967: 3074:	if ( fulltbl )
branch  0 taken 23 (fallthrough)
branch  1 taken 944
       23: 3075:		indent_put2s(
call    0 returned 23
        -: 3076:	"yy_current_state = yy_nxt[yy_current_state][(unsigned int) %s];", 
        -: 3077:				char_map );
        -: 3078:
      944: 3079:	else if ( fullspd )
branch  0 taken 92 (fallthrough)
branch  1 taken 852
       92: 3080:		indent_put2s(
call    0 returned 92
        -: 3081:	"yy_current_state += yy_current_state[(unsigned int) %s].yy_nxt;",
        -: 3082:				char_map );
        -: 3083:
        -: 3084:	else
      852: 3085:		gen_next_compressed_state( char_map );
call    0 returned 852
        -: 3086:
      967: 3087:	if ( worry_about_NULs && nultrans )
branch  0 taken 541 (fallthrough)
branch  1 taken 426
branch  2 taken 196 (fallthrough)
branch  3 taken 345
        -: 3088:		{
        -: 3089:		/* { for vi */
      196: 3090:		indent_puts( "}" );
call    0 returned 196
      196: 3091:		indent_down();
      196: 3092:		indent_puts( "else" );
call    0 returned 196
      196: 3093:		indent_up();
      196: 3094:		indent_puts(
call    0 returned 196
        -: 3095:			"yy_current_state = yy_NUL_trans[yy_current_state];" );
      196: 3096:		indent_down();
        -: 3097:		}
        -: 3098:
      967: 3099:	if ( fullspd || fulltbl )
branch  0 taken 875 (fallthrough)
branch  1 taken 92
branch  2 taken 23 (fallthrough)
branch  3 taken 852
      115: 3100:		gen_backing_up();
call    0 returned 115
        -: 3101:
      967: 3102:	if ( reject )
branch  0 taken 340 (fallthrough)
branch  1 taken 627
      340: 3103:		indent_puts( "*yy_state_ptr++ = yy_current_state;" );
call    0 returned 340
      967: 3104:	}
        -: 3105:
        -: 3106:
        -: 3107:/* Generate the code to make a NUL transition. */
        -: 3108:
function gen_NUL_trans called 541 returned 100% blocks executed 100%
      541: 3109:void gen_NUL_trans()
        -: 3110:	{ /* NOTE - changes in here should be reflected in get_next_match() */
      541: 3111:	int need_backing_up = (num_backing_up > 0 && ! reject);
branch  0 taken 539 (fallthrough)
branch  1 taken 2
branch  2 taken 369 (fallthrough)
branch  3 taken 170
        -: 3112:
      541: 3113:	if ( need_backing_up )
branch  0 taken 369 (fallthrough)
branch  1 taken 172
        -: 3114:		/* We'll need yy_cp lying around for the gen_backing_up(). */
      369: 3115:		indent_puts( "register char *yy_cp = yy_c_buf_p;" );
call    0 returned 369
        -: 3116:
      541: 3117:	putchar( '\n' );
call    0 returned 541
        -: 3118:
      541: 3119:	if ( nultrans )
branch  0 taken 196 (fallthrough)
branch  1 taken 345
        -: 3120:		{
      196: 3121:		indent_puts(
call    0 returned 196
        -: 3122:			"yy_current_state = yy_NUL_trans[yy_current_state];" );
      196: 3123:		indent_puts( "yy_is_jam = (yy_current_state == 0);" );
call    0 returned 196
        -: 3124:		}
        -: 3125:
      345: 3126:	else if ( fulltbl )
branch  0 taken 1 (fallthrough)
branch  1 taken 344
        -: 3127:		{
        1: 3128:		do_indent();
call    0 returned 1
        1: 3129:		printf( "yy_current_state = yy_nxt[yy_current_state][%d];\n",
call    0 returned 1
        -: 3130:			NUL_ec );
        1: 3131:		indent_puts( "yy_is_jam = (yy_current_state <= 0);" );
call    0 returned 1
        -: 3132:		}
        -: 3133:
      344: 3134:	else if ( fullspd )
branch  0 taken 92 (fallthrough)
branch  1 taken 252
        -: 3135:		{
       92: 3136:		do_indent();
call    0 returned 92
       92: 3137:		printf( "register int yy_c = %d;\n", NUL_ec );
call    0 returned 92
        -: 3138:
       92: 3139:		indent_puts(
call    0 returned 92
        -: 3140:		"register const struct yy_trans_info *yy_trans_info;\n" );
       92: 3141:		indent_puts(
call    0 returned 92
        -: 3142:		"yy_trans_info = &yy_current_state[(unsigned int) yy_c];" );
       92: 3143:		indent_puts( "yy_current_state += yy_trans_info->yy_nxt;" );
call    0 returned 92
        -: 3144:
       92: 3145:		indent_puts(
call    0 returned 92
        -: 3146:			"yy_is_jam = (yy_trans_info->yy_verify != yy_c);" );
        -: 3147:		}
        -: 3148:
        -: 3149:	else
        -: 3150:		{
        -: 3151:		char NUL_ec_str[20];
        -: 3152:
      252: 3153:		(void) sprintf( NUL_ec_str, "%d", NUL_ec );
      252: 3154:		gen_next_compressed_state( NUL_ec_str );
call    0 returned 252
        -: 3155:
      252: 3156:		if ( reject )
branch  0 taken 99 (fallthrough)
branch  1 taken 153
       99: 3157:			indent_puts( "*yy_state_ptr++ = yy_current_state;" );
call    0 returned 99
        -: 3158:
      252: 3159:		do_indent();
call    0 returned 252
        -: 3160:
      252: 3161:		printf( "yy_is_jam = (yy_current_state == %d);\n", jamstate );
call    0 returned 252
        -: 3162:		}
        -: 3163:
        -: 3164:	/* If we've entered an accepting state, back up; note that
        -: 3165:	 * compressed tables have *already* done such backing up, so
        -: 3166:	 * we needn't bother with it again.
        -: 3167:	 */
      541: 3168:	if ( need_backing_up && (fullspd || fulltbl) )
branch  0 taken 369 (fallthrough)
branch  1 taken 172
branch  2 taken 277 (fallthrough)
branch  3 taken 92
branch  4 taken 21 (fallthrough)
branch  5 taken 256
        -: 3169:		{
      113: 3170:		putchar( '\n' );
call    0 returned 113
      113: 3171:		indent_puts( "if ( ! yy_is_jam )" );
call    0 returned 113
      113: 3172:		indent_up();
      113: 3173:		indent_puts( "{" );
call    0 returned 113
      113: 3174:		gen_backing_up();
call    0 returned 113
      113: 3175:		indent_puts( "}" );
call    0 returned 113
      113: 3176:		indent_down();
        -: 3177:		}
      541: 3178:	}
        -: 3179:
        -: 3180:
        -: 3181:/* Generate the code to find the start state. */
        -: 3182:
function gen_start_state called 1082 returned 100% blocks executed 100%
     1082: 3183:void gen_start_state()
        -: 3184:	{
     1082: 3185:	if ( fullspd )
branch  0 taken 184 (fallthrough)
branch  1 taken 898
      184: 3186:		indent_put2s(
call    0 returned 184
        -: 3187:			"yy_current_state = yy_start_state_list[yy_start%s];",
      184: 3188:			bol_needed ? " + (yy_bp[-1] == '\\n' ? 1 : 0)" : "" );
branch  0 taken 36 (fallthrough)
branch  1 taken 148
        -: 3189:
        -: 3190:	else
        -: 3191:		{
      898: 3192:		indent_puts( "yy_current_state = yy_start;" );
call    0 returned 898
        -: 3193:
      898: 3194:		if ( bol_needed )
branch  0 taken 160 (fallthrough)
branch  1 taken 738
        -: 3195:			{
      160: 3196:			indent_puts( "if ( yy_bp[-1] == '\\n' )" );
call    0 returned 160
      160: 3197:			indent_up();
      160: 3198:			indent_puts( "++yy_current_state;" );
call    0 returned 160
      160: 3199:			indent_down();
        -: 3200:			}
        -: 3201:
      898: 3202:		if ( reject )
branch  0 taken 340 (fallthrough)
branch  1 taken 558
        -: 3203:			{
        -: 3204:			/* Set up for storing up states. */
      340: 3205:			indent_puts( "yy_state_ptr = yy_state_buf;" );
call    0 returned 340
      340: 3206:			indent_puts( "*yy_state_ptr++ = yy_current_state;" );
call    0 returned 340
        -: 3207:			}
        -: 3208:		}
     1082: 3209:	}
        -: 3210:
        -: 3211:
        -: 3212:/* gentabs - generate data statements for the transition tables */
        -: 3213:
function gentabs called 426 returned 100% blocks executed 100%
      426: 3214:void gentabs()
        -: 3215:	{
        -: 3216:	int i, j, k, *accset, nacc, *acc_array, total_states;
      426: 3217:	int end_of_buffer_action = num_rules + 1;
        -: 3218:
        -: 3219:	/* *Everything* is done in terms of arrays starting at 1, so provide
        -: 3220:	 * a null entry for the zero element of all C arrays.
        -: 3221:	 */
        -: 3222:	static char C_char_decl[] =
        -: 3223:		"static const YY_CHAR %s[%d] =\n    {   0,\n";	/* } for vi */
        -: 3224:
      426: 3225:	acc_array = allocate_integer_array( current_max_dfas );
call    0 returned 426
      426: 3226:	nummt = 0;
        -: 3227:
        -: 3228:	/* The compressed table format jams by entering the "jam state",
        -: 3229:	 * losing information about the previous state in the process.
        -: 3230:	 * In order to recover the previous state, we effectively need
        -: 3231:	 * to keep backing-up information.
        -: 3232:	 */
      426: 3233:	++num_backing_up;
        -: 3234:
      426: 3235:	if ( reject )
branch  0 taken 170 (fallthrough)
branch  1 taken 256
        -: 3236:		{
        -: 3237:		/* Write out accepting list and pointer list.
        -: 3238:		 *
        -: 3239:		 * First we generate the "yy_acclist" array.  In the process,
        -: 3240:		 * we compute the indices that will go into the "yy_accept"
        -: 3241:		 * array, and save the indices in the dfaacc array.
        -: 3242:		 */
        -: 3243:		int EOB_accepting_list[2];
        -: 3244:
        -: 3245:		/* Set up accepting structures for the End Of Buffer state. */
      170: 3246:		EOB_accepting_list[0] = 0;
      170: 3247:		EOB_accepting_list[1] = end_of_buffer_action;
      170: 3248:		accsiz[end_of_buffer_state] = 1;
      170: 3249:		dfaacc[end_of_buffer_state].dfaacc_set = EOB_accepting_list;
        -: 3250:
      170: 3251:		printf( long_align ? C_long_decl : C_short_decl,
call    0 returned 170
      170: 3252:			"yy_acclist", max( numas, 1 ) + 1 );
branch  0 taken 81 (fallthrough)
branch  1 taken 89
        -: 3253:
      170: 3254:		j = 1;	/* index into "yy_acclist" array */
        -: 3255:
     4247: 3256:		for ( i = 1; i <= lastdfa; ++i )
branch  0 taken 4077
branch  1 taken 170 (fallthrough)
        -: 3257:			{
     4077: 3258:			acc_array[i] = j;
        -: 3259:
     4077: 3260:			if ( accsiz[i] != 0 )
branch  0 taken 3112 (fallthrough)
branch  1 taken 965
        -: 3261:				{
     3112: 3262:				accset = dfaacc[i].dfaacc_set;
     3112: 3263:				nacc = accsiz[i];
        -: 3264:
     3112: 3265:				if ( trace )
branch  0 taken 112 (fallthrough)
branch  1 taken 3000
      112: 3266:					fprintf( err,
call    0 returned 112
        -: 3267:						"state # %d accepts: ", i );
        -: 3268:
     7713: 3269:				for ( k = 1; k <= nacc; ++k )
branch  0 taken 4601
branch  1 taken 3112 (fallthrough)
        -: 3270:					{
     4601: 3271:					int accnum = accset[k];
        -: 3272:
     4601: 3273:					++j;
        -: 3274:
     4601: 3275:					if ( variable_trailing_context_rules &&
branch  0 taken 623 (fallthrough)
branch  1 taken 3978
      623: 3276:					  ! (accnum & YY_TRAILING_HEAD_MASK) &&
branch  0 taken 553 (fallthrough)
branch  1 taken 70
branch  2 taken 553 (fallthrough)
branch  3 taken 0
      553: 3277:					   accnum > 0 && accnum <= num_rules &&
branch  0 taken 518 (fallthrough)
branch  1 taken 35
      518: 3278:					  rule_type[accnum] == RULE_VARIABLE )
branch  0 taken 68 (fallthrough)
branch  1 taken 450
        -: 3279:						{
        -: 3280:						/* Special hack to flag
        -: 3281:						 * accepting number as part
        -: 3282:						 * of trailing context rule.
        -: 3283:						 */
       68: 3284:						accnum |= YY_TRAILING_MASK;
        -: 3285:						}
        -: 3286:
     4601: 3287:					mkdata( accnum );
call    0 returned 4601
        -: 3288:
     4601: 3289:					if ( trace )
branch  0 taken 170 (fallthrough)
branch  1 taken 4431
        -: 3290:						{
      170: 3291:						fprintf( err, "[%d]",
      170: 3292:							accset[k] );
call    0 returned 170
        -: 3293:
      170: 3294:						if ( k < nacc )
branch  0 taken 58 (fallthrough)
branch  1 taken 112
       58: 3295:							fputs( ", ", err );
call    0 returned 58
        -: 3296:						else
      112: 3297:							putc( '\n', err );
call    0 returned 112
        -: 3298:						}
        -: 3299:					}
        -: 3300:				}
        -: 3301:			}
        -: 3302:
        -: 3303:		/* add accepting number for the "jam" state */
      170: 3304:		acc_array[i] = j;
        -: 3305:
      170: 3306:		dataend();
call    0 returned 170
        -: 3307:		}
        -: 3308:
        -: 3309:	else
        -: 3310:		{
      256: 3311:		dfaacc[end_of_buffer_state].dfaacc_state = end_of_buffer_action;
        -: 3312:
     6273: 3313:		for ( i = 1; i <= lastdfa; ++i )
branch  0 taken 6017
branch  1 taken 256 (fallthrough)
     6017: 3314:			acc_array[i] = dfaacc[i].dfaacc_state;
        -: 3315:
        -: 3316:		/* add accepting number for jam state */
      256: 3317:		acc_array[i] = 0;
        -: 3318:		}
        -: 3319:
        -: 3320:	/* Spit out "yy_accept" array.  If we're doing "reject", it'll be
        -: 3321:	 * pointers into the "yy_acclist" array.  Otherwise it's actual
        -: 3322:	 * accepting numbers.  In either case, we just dump the numbers.
        -: 3323:	 */
        -: 3324:
        -: 3325:	/* "lastdfa + 2" is the size of "yy_accept"; includes room for C arrays
        -: 3326:	 * beginning at 0 and for "jam" state.
        -: 3327:	 */
      426: 3328:	k = lastdfa + 2;
        -: 3329:
      426: 3330:	if ( reject )
branch  0 taken 170 (fallthrough)
branch  1 taken 256
        -: 3331:		/* We put a "cap" on the table associating lists of accepting
        -: 3332:		 * numbers with state numbers.  This is needed because we tell
        -: 3333:		 * where the end of an accepting list is by looking at where
        -: 3334:		 * the list for the next state starts.
        -: 3335:		 */
      170: 3336:		++k;
        -: 3337:
      426: 3338:	printf( long_align ? C_long_decl : C_short_decl, "yy_accept", k );
branch  0 taken 201 (fallthrough)
branch  1 taken 225
call    2 returned 426
        -: 3339:
    10520: 3340:	for ( i = 1; i <= lastdfa; ++i )
branch  0 taken 10094
branch  1 taken 426 (fallthrough)
        -: 3341:		{
    10094: 3342:		mkdata( acc_array[i] );
call    0 returned 10094
        -: 3343:
    10094: 3344:		if ( ! reject && trace && acc_array[i] )
branch  0 taken 6017 (fallthrough)
branch  1 taken 4077
branch  2 taken 116 (fallthrough)
branch  3 taken 5901
branch  4 taken 82 (fallthrough)
branch  5 taken 34
       82: 3345:			fprintf( err, "state # %d accepts: [%d]\n",
       82: 3346:				i, acc_array[i] );
call    0 returned 82
        -: 3347:		}
        -: 3348:
        -: 3349:	/* Add entry for "jam" state. */
      426: 3350:	mkdata( acc_array[i] );
call    0 returned 426
        -: 3351:
      426: 3352:	if ( reject )
branch  0 taken 170 (fallthrough)
branch  1 taken 256
        -: 3353:		/* Add "cap" for the list. */
      170: 3354:		mkdata( acc_array[i] );
call    0 returned 170
        -: 3355:
      426: 3356:	dataend();
call    0 returned 426
        -: 3357:
      426: 3358:	if ( useecs )
branch  0 taken 252 (fallthrough)
branch  1 taken 174
      252: 3359:		genecs();
call    0 returned 252
        -: 3360:
      426: 3361:	if ( usemecs )
branch  0 taken 212 (fallthrough)
branch  1 taken 214
        -: 3362:		{
        -: 3363:		/* Write out meta-equivalence classes (used to index
        -: 3364:		 * templates with).
        -: 3365:		 */
        -: 3366:
      212: 3367:		if ( trace )
branch  0 taken 11 (fallthrough)
branch  1 taken 201
       11: 3368:			fputs( "\n\nMeta-Equivalence Classes:\n", err );
call    0 returned 11
        -: 3369:
      212: 3370:		printf( C_char_decl, "yy_meta", numecs + 1 );
call    0 returned 212
        -: 3371:
    22441: 3372:		for ( i = 1; i <= numecs; ++i )
branch  0 taken 22229
branch  1 taken 212 (fallthrough)
        -: 3373:			{
    22229: 3374:			if ( trace )
branch  0 taken 137 (fallthrough)
branch  1 taken 22092
      137: 3375:				fprintf( err, "%d = %d\n",
      137: 3376:					i, abs( tecbck[i] ) );
call    0 returned 137
        -: 3377:
    22229: 3378:			mkdata( abs( tecbck[i] ) );
call    0 returned 22229
        -: 3379:			}
        -: 3380:
      212: 3381:		dataend();
call    0 returned 212
        -: 3382:		}
        -: 3383:
      426: 3384:	total_states = lastdfa + numtemps;
        -: 3385:
      426: 3386:	printf( (tblend >= MAX_SHORT || long_align) ?
branch  0 taken 426 (fallthrough)
branch  1 taken 0
branch  2 taken 201 (fallthrough)
branch  3 taken 225
call    4 returned 426
        -: 3387:			C_long_decl : C_short_decl,
        -: 3388:		"yy_base", total_states + 1 );
        -: 3389:
    10520: 3390:	for ( i = 1; i <= lastdfa; ++i )
branch  0 taken 10094
branch  1 taken 426 (fallthrough)
        -: 3391:		{
    10094: 3392:		register int d = def[i];
        -: 3393:
    10094: 3394:		if ( base[i] == JAMSTATE )
branch  0 taken 1925 (fallthrough)
branch  1 taken 8169
     1925: 3395:			base[i] = jambase;
        -: 3396:
    10094: 3397:		if ( d == JAMSTATE )
branch  0 taken 7431 (fallthrough)
branch  1 taken 2663
     7431: 3398:			def[i] = jamstate;
        -: 3399:
     2663: 3400:		else if ( d < 0 )
branch  0 taken 2432 (fallthrough)
branch  1 taken 231
        -: 3401:			{
        -: 3402:			/* Template reference. */
     2432: 3403:			++tmpuses;
     2432: 3404:			def[i] = lastdfa - d + 1;
        -: 3405:			}
        -: 3406:
    10094: 3407:		mkdata( base[i] );
call    0 returned 10094
        -: 3408:		}
        -: 3409:
        -: 3410:	/* Generate jam state's base index. */
      426: 3411:	mkdata( base[i] );
call    0 returned 426
        -: 3412:
     1048: 3413:	for ( ++i /* skip jam state */; i <= total_states; ++i )
branch  0 taken 622
branch  1 taken 426 (fallthrough)
        -: 3414:		{
      622: 3415:		mkdata( base[i] );
call    0 returned 622
      622: 3416:		def[i] = jamstate;
        -: 3417:		}
        -: 3418:
      426: 3419:	dataend();
call    0 returned 426
        -: 3420:
      426: 3421:	printf( (total_states >= MAX_SHORT || long_align) ?
branch  0 taken 426 (fallthrough)
branch  1 taken 0
branch  2 taken 201 (fallthrough)
branch  3 taken 225
call    4 returned 426
        -: 3422:			C_long_decl : C_short_decl,
        -: 3423:		"yy_def", total_states + 1 );
        -: 3424:
    11568: 3425:	for ( i = 1; i <= total_states; ++i )
branch  0 taken 11142
branch  1 taken 426 (fallthrough)
    11142: 3426:		mkdata( def[i] );
call    0 returned 11142
        -: 3427:
      426: 3428:	dataend();
call    0 returned 426
        -: 3429:
      426: 3430:	printf( (total_states >= MAX_SHORT || long_align) ?
branch  0 taken 426 (fallthrough)
branch  1 taken 0
branch  2 taken 201 (fallthrough)
branch  3 taken 225
call    4 returned 426
        -: 3431:			C_long_decl : C_short_decl,
        -: 3432:		"yy_nxt", tblend + 1 );
        -: 3433:
   150537: 3434:	for ( i = 1; i <= tblend; ++i )
branch  0 taken 150111
branch  1 taken 426 (fallthrough)
        -: 3435:		{
   150111: 3436:		if ( nxt[i] == 0 || chk[i] == 0 )
branch  0 taken 83191 (fallthrough)
branch  1 taken 66920
branch  2 taken 0 (fallthrough)
branch  3 taken 83191
    66920: 3437:			nxt[i] = jamstate;	/* new state is the JAM state */
        -: 3438:
   150111: 3439:		mkdata( nxt[i] );
call    0 returned 150111
        -: 3440:		}
        -: 3441:
      426: 3442:	dataend();
call    0 returned 426
        -: 3443:
      426: 3444:	printf( (total_states >= MAX_SHORT || long_align) ?
branch  0 taken 426 (fallthrough)
branch  1 taken 0
branch  2 taken 201 (fallthrough)
branch  3 taken 225
call    4 returned 426
        -: 3445:			C_long_decl : C_short_decl,
        -: 3446:		"yy_chk", tblend + 1 );
        -: 3447:
   150537: 3448:	for ( i = 1; i <= tblend; ++i )
branch  0 taken 150111
branch  1 taken 426 (fallthrough)
        -: 3449:		{
   150111: 3450:		if ( chk[i] == 0 )
branch  0 taken 18521 (fallthrough)
branch  1 taken 131590
    18521: 3451:			++nummt;
        -: 3452:
   150111: 3453:		mkdata( chk[i] );
call    0 returned 150111
        -: 3454:		}
        -: 3455:
      426: 3456:	dataend();
call    0 returned 426
      426: 3457:	}
        -: 3458:
        -: 3459:
        -: 3460:/* Write out a formatted string (with a secondary string argument) at the
        -: 3461: * current indentation level, adding a final newline.
        -: 3462: */
        -: 3463:
function indent_put2s called 1702 returned 100% blocks executed 100%
     1702: 3464:void indent_put2s( fmt, arg )
        -: 3465:char fmt[], arg[];
        -: 3466:	{
     1702: 3467:	do_indent();
call    0 returned 1702
     1702: 3468:	printf( fmt, arg );
call    0 returned 1702
     1702: 3469:	putchar( '\n' );
call    0 returned 1702
     1702: 3470:	}
        -: 3471:
        -: 3472:
        -: 3473:/* Write out a string at the current indentation level, adding a final
        -: 3474: * newline.
        -: 3475: */
        -: 3476:
function indent_puts called 35311 returned 100% blocks executed 100%
    35311: 3477:void indent_puts( str )
        -: 3478:char str[];
        -: 3479:	{
    35311: 3480:	do_indent();
call    0 returned 35311
    35311: 3481:	puts( str );
call    0 returned 35311
    35311: 3482:	}
        -: 3483:
        -: 3484:
        -: 3485:/* make_tables - generate transition tables and finishes generating output file
        -: 3486: */
        -: 3487:
function make_tables called 541 returned 100% blocks executed 99%
      541: 3488:void make_tables()
        -: 3489:	{
        -: 3490:	register int i;
      541: 3491:	int did_eof_rule = false;
        -: 3492:
      541: 3493:	skelout();
call    0 returned 541
        -: 3494:
        -: 3495:	/* First, take care of YY_DO_BEFORE_ACTION depending on yymore
        -: 3496:	 * being used.
        -: 3497:	 */
      541: 3498:	set_indent( 1 );
        -: 3499:
      541: 3500:	if ( yymore_used )
branch  0 taken 166 (fallthrough)
branch  1 taken 375
        -: 3501:		{
      166: 3502:		indent_puts( "yytext_ptr -= yy_more_len; \\" );
call    0 returned 166
      166: 3503:		indent_puts( "yyleng = yy_cp - yytext_ptr; \\" );
call    0 returned 166
        -: 3504:		}
        -: 3505:
        -: 3506:	else
      375: 3507:		indent_puts( "yyleng = yy_cp - yy_bp; \\" );
call    0 returned 375
        -: 3508:
        -: 3509:	/* Now also deal with copying yytext_ptr to yytext if needed. */
      541: 3510:	skelout();
call    0 returned 541
      541: 3511:	if ( yytext_is_array )
branch  0 taken 162 (fallthrough)
branch  1 taken 379
        -: 3512:		{
      162: 3513:		indent_puts( "if ( yyleng >= YYLMAX ) \\" );
call    0 returned 162
      162: 3514:		indent_up();
      162: 3515:		indent_puts(
call    0 returned 162
        -: 3516:		"YY_FATAL_ERROR( \"token too large, exceeds YYLMAX\" ); \\" );
      162: 3517:		indent_down();
      162: 3518:		indent_puts( "yy_strcpy( yytext, yytext_ptr ); \\" );
call    0 returned 162
        -: 3519:		}
        -: 3520:
      541: 3521:	set_indent( 0 );
        -: 3522:
      541: 3523:	skelout();
call    0 returned 541
        -: 3524:
        -: 3525:
      541: 3526:	printf( "#define YY_END_OF_BUFFER %d\n", num_rules + 1 );
call    0 returned 541
        -: 3527:
      541: 3528:	if ( fullspd )
branch  0 taken 92 (fallthrough)
branch  1 taken 449
        -: 3529:		{
        -: 3530:		/* Need to define the transet type as a size large
        -: 3531:		 * enough to hold the biggest offset.
        -: 3532:		 */
       92: 3533:		int total_table_size = tblend + numecs + 1;
       92: 3534:		char *trans_offset_type =
       92: 3535:			(total_table_size >= MAX_SHORT || long_align) ?
branch  0 taken 40 (fallthrough)
branch  1 taken 52
      184: 3536:				"long" : "short";
branch  0 taken 92 (fallthrough)
branch  1 taken 0
        -: 3537:
       92: 3538:		set_indent( 0 );
       92: 3539:		indent_puts( "struct yy_trans_info" );
call    0 returned 92
       92: 3540:		indent_up();
       92: 3541:		indent_puts( "{" ); 	/* } for vi */
call    0 returned 92
        -: 3542:
       92: 3543:		if ( long_align )
branch  0 taken 40 (fallthrough)
branch  1 taken 52
       40: 3544:			indent_puts( "long yy_verify;" );
call    0 returned 40
        -: 3545:		else
       52: 3546:			indent_puts( "short yy_verify;" );
call    0 returned 52
        -: 3547:
        -: 3548:		/* In cases where its sister yy_verify *is* a "yes, there is
        -: 3549:		 * a transition", yy_nxt is the offset (in records) to the
        -: 3550:		 * next state.  In most cases where there is no transition,
        -: 3551:		 * the value of yy_nxt is irrelevant.  If yy_nxt is the -1th
        -: 3552:		 * record of a state, though, then yy_nxt is the action number
        -: 3553:		 * for that state.
        -: 3554:		 */
        -: 3555:
       92: 3556:		indent_put2s( "%s yy_nxt;", trans_offset_type );
call    0 returned 92
       92: 3557:		indent_puts( "};" );
call    0 returned 92
       92: 3558:		indent_down();
        -: 3559:		}
        -: 3560:
      541: 3561:	if ( fullspd )
branch  0 taken 92 (fallthrough)
branch  1 taken 449
       92: 3562:		genctbl();
call    0 returned 92
      449: 3563:	else if ( fulltbl )
branch  0 taken 23 (fallthrough)
branch  1 taken 426
       23: 3564:		genftbl();
call    0 returned 23
        -: 3565:	else
      426: 3566:		gentabs();
call    0 returned 426
        -: 3567:
        -: 3568:	/* Definitions for backing up.  We don't need them if REJECT
        -: 3569:	 * is being used because then we use an alternative backin-up
        -: 3570:	 * technique instead.
        -: 3571:	 */
      541: 3572:	if ( num_backing_up > 0 && ! reject )
branch  0 taken 539 (fallthrough)
branch  1 taken 2
branch  2 taken 369 (fallthrough)
branch  3 taken 170
        -: 3573:		{
      369: 3574:		if ( ! C_plus_plus )
branch  0 taken 369 (fallthrough)
branch  1 taken 0
        -: 3575:			{
      369: 3576:			indent_puts(
call    0 returned 369
        -: 3577:			"static yy_state_type yy_last_accepting_state;" );
      369: 3578:			indent_puts(
call    0 returned 369
        -: 3579:				"static char *yy_last_accepting_cpos;\n" );
        -: 3580:			}
        -: 3581:		}
        -: 3582:
      541: 3583:	if ( nultrans )
branch  0 taken 196 (fallthrough)
branch  1 taken 345
        -: 3584:		{
      196: 3585:		printf( C_state_decl, "yy_NUL_trans", lastdfa + 1 );
call    0 returned 196
        -: 3586:
     4906: 3587:		for ( i = 1; i <= lastdfa; ++i )
branch  0 taken 4710
branch  1 taken 196 (fallthrough)
        -: 3588:			{
     4710: 3589:			if ( fullspd )
branch  0 taken 0 (fallthrough)
branch  1 taken 4710
    #####: 3590:				printf( "    &yy_transition[%d],\n", base[i] );
call    0 never executed
        -: 3591:			else
     4710: 3592:				mkdata( nultrans[i] );
call    0 returned 4710
        -: 3593:			}
        -: 3594:
      196: 3595:		dataend();
call    0 returned 196
        -: 3596:		}
        -: 3597:
      541: 3598:	if ( ddebug )
branch  0 taken 252 (fallthrough)
branch  1 taken 289
        -: 3599:		{ /* Spit out table mapping rules to line numbers. */
      252: 3600:		indent_puts( "extern int yy_flex_debug;" );
call    0 returned 252
      252: 3601:		indent_puts( "int yy_flex_debug = 1;\n" );
call    0 returned 252
        -: 3602:
      252: 3603:		printf( long_align ? C_long_decl : C_short_decl,
branch  0 taken 120 (fallthrough)
branch  1 taken 132
call    2 returned 252
        -: 3604:			"yy_rule_linenum", num_rules );
     1531: 3605:		for ( i = 1; i < num_rules; ++i )
branch  0 taken 1279
branch  1 taken 252 (fallthrough)
     1279: 3606:			mkdata( rule_linenum[i] );
call    0 returned 1279
      252: 3607:		dataend();
call    0 returned 252
        -: 3608:		}
        -: 3609:
      541: 3610:	if ( reject )
branch  0 taken 170 (fallthrough)
branch  1 taken 371
        -: 3611:		{
        -: 3612:		/* Declare state buffer variables. */
      170: 3613:		if ( ! C_plus_plus )
branch  0 taken 170 (fallthrough)
branch  1 taken 0
        -: 3614:			{
      170: 3615:			puts(
call    0 returned 170
        -: 3616:	"static yy_state_type yy_state_buf[YY_BUF_SIZE + 2], *yy_state_ptr;" );
      170: 3617:			puts( "static char *yy_full_match;" );
call    0 returned 170
      170: 3618:			puts( "static int yy_lp;" );
call    0 returned 170
        -: 3619:			}
        -: 3620:
      170: 3621:		if ( variable_trailing_context_rules )
branch  0 taken 35 (fallthrough)
branch  1 taken 135
        -: 3622:			{
       35: 3623:			if ( ! C_plus_plus )
branch  0 taken 35 (fallthrough)
branch  1 taken 0
        -: 3624:				{
       35: 3625:				puts(
call    0 returned 35
        -: 3626:				"static int yy_looking_for_trail_begin = 0;" );
       35: 3627:				puts( "static int yy_full_lp;" );
call    0 returned 35
       35: 3628:				puts( "static int *yy_full_state;" );
call    0 returned 35
        -: 3629:				}
        -: 3630:
       35: 3631:			printf( "#define YY_TRAILING_MASK 0x%x\n",
call    0 returned 35
        -: 3632:				(unsigned int) YY_TRAILING_MASK );
       35: 3633:			printf( "#define YY_TRAILING_HEAD_MASK 0x%x\n",
call    0 returned 35
        -: 3634:				(unsigned int) YY_TRAILING_HEAD_MASK );
        -: 3635:			}
        -: 3636:
      170: 3637:		puts( "#define REJECT \\" );
call    0 returned 170
      170: 3638:		puts( "{ \\" );		/* } for vi */
call    0 returned 170
      170: 3639:		puts(
call    0 returned 170
        -: 3640:	"*yy_cp = yy_hold_char; /* undo effects of setting up yytext */ \\" );
      170: 3641:		puts(
call    0 returned 170
        -: 3642:	"yy_cp = yy_full_match; /* restore poss. backed-over text */ \\" );
        -: 3643:
      170: 3644:		if ( variable_trailing_context_rules )
branch  0 taken 35 (fallthrough)
branch  1 taken 135
        -: 3645:			{
       35: 3646:			puts(
call    0 returned 35
        -: 3647:		"yy_lp = yy_full_lp; /* restore orig. accepting pos. */ \\" );
       35: 3648:			puts(
call    0 returned 35
        -: 3649:		"yy_state_ptr = yy_full_state; /* restore orig. state */ \\" );
       35: 3650:			puts(
call    0 returned 35
        -: 3651:	"yy_current_state = *yy_state_ptr; /* restore curr. state */ \\" );
        -: 3652:			}
        -: 3653:
      170: 3654:		puts( "++yy_lp; \\" );
call    0 returned 170
      170: 3655:		puts( "goto find_rule; \\" );
call    0 returned 170
        -: 3656:		/* { for vi */
      170: 3657:		puts( "}" );
call    0 returned 170
        -: 3658:		}
        -: 3659:
        -: 3660:	else
        -: 3661:		{
      371: 3662:		puts(
call    0 returned 371
        -: 3663:		"/* The intent behind this definition is that it'll catch" );
      371: 3664:		puts( " * any uses of REJECT which flex missed." );
call    0 returned 371
      371: 3665:		puts( " */" );
call    0 returned 371
      371: 3666:		puts( "#define REJECT reject_used_but_not_detected" );
call    0 returned 371
        -: 3667:		}
        -: 3668:
      541: 3669:	if ( yymore_used )
branch  0 taken 166 (fallthrough)
branch  1 taken 375
        -: 3670:		{
      166: 3671:		if ( ! C_plus_plus )
branch  0 taken 166 (fallthrough)
branch  1 taken 0
        -: 3672:			{
      166: 3673:			indent_puts( "static int yy_more_flag = 0;" );
call    0 returned 166
      166: 3674:			indent_puts( "static int yy_more_len = 0;" );
call    0 returned 166
        -: 3675:			}
        -: 3676:
      166: 3677:		indent_puts( "#define yymore() (yy_more_flag = 1)" );
call    0 returned 166
      166: 3678:		indent_puts( "#define YY_MORE_ADJ yy_more_len" );
call    0 returned 166
        -: 3679:		}
        -: 3680:
        -: 3681:	else
        -: 3682:		{
      375: 3683:		indent_puts( "#define yymore() yymore_used_but_not_detected" );
call    0 returned 375
      375: 3684:		indent_puts( "#define YY_MORE_ADJ 0" );
call    0 returned 375
        -: 3685:		}
        -: 3686:
      541: 3687:	if ( ! C_plus_plus )
branch  0 taken 541 (fallthrough)
branch  1 taken 0
        -: 3688:		{
      541: 3689:		if ( yytext_is_array )
branch  0 taken 162 (fallthrough)
branch  1 taken 379
        -: 3690:			{
      162: 3691:			puts( "#ifndef YYLMAX" );
call    0 returned 162
      162: 3692:			puts( "#define YYLMAX 8192" );
call    0 returned 162
      162: 3693:			puts( "#endif\n" );
call    0 returned 162
      162: 3694:			puts( "char yytext[YYLMAX];" );
call    0 returned 162
      162: 3695:			puts( "char *yytext_ptr;" );
call    0 returned 162
        -: 3696:			}
        -: 3697:
        -: 3698:		else
      379: 3699:			puts( "char *yytext;" );
call    0 returned 379
        -: 3700:		}
        -: 3701:
      541: 3702:	fputs( &action_array[defs1_offset], stdout );
call    0 returned 541
        -: 3703:
      541: 3704:	skelout();
call    0 returned 541
        -: 3705:
      541: 3706:	if ( ! C_plus_plus )
branch  0 taken 541 (fallthrough)
branch  1 taken 0
        -: 3707:		{
      541: 3708:		if ( use_read )
branch  0 taken 240 (fallthrough)
branch  1 taken 301
        -: 3709:			{
      240: 3710:			printf(
call    0 returned 240
        -: 3711:"\tif ( (result = read( fileno(yyin), (char *) buf, max_size )) < 0 ) \\\n" );
      240: 3712:			printf(
call    0 returned 240
        -: 3713:		"\t\tYY_FATAL_ERROR( \"input in flex scanner failed\" );\n" );
        -: 3714:			}
        -: 3715:
        -: 3716:		else
        -: 3717:			{
      301: 3718:			printf(
call    0 returned 301
        -: 3719:			"\tif ( yy_current_buffer->is_interactive ) \\\n" );
      301: 3720:			printf(
call    0 returned 301
        -: 3721:"\t\tresult = ((int) (buf[0] = getc( yyin ))) == EOF ? 0 : 1; \\\n" );
      301: 3722:			printf(
call    0 returned 301
        -: 3723:"\telse if ( ((result = fread( (char *) buf, 1, max_size, yyin )) == 0)\\\n" );
      301: 3724:			printf( "\t\t  && ferror( yyin ) ) \\\n" );
call    0 returned 301
      301: 3725:			printf(
call    0 returned 301
        -: 3726:		"\t\tYY_FATAL_ERROR( \"input in flex scanner failed\" );\n" );
        -: 3727:			}
        -: 3728:		}
        -: 3729:
      541: 3730:	skelout();
call    0 returned 541
        -: 3731:
        -: 3732:	/* Copy prolog to output file. */
      541: 3733:	fputs( &action_array[prolog_offset], stdout );
call    0 returned 541
        -: 3734:
      541: 3735:	skelout();
call    0 returned 541
        -: 3736:
      541: 3737:	set_indent( 2 );
        -: 3738:
      541: 3739:	if ( yymore_used )
branch  0 taken 166 (fallthrough)
branch  1 taken 375
        -: 3740:		{
      166: 3741:		indent_puts( "yy_more_len = 0;" );
call    0 returned 166
      166: 3742:		indent_puts( "if ( yy_more_flag )" );
call    0 returned 166
      166: 3743:		indent_up();
      166: 3744:		indent_puts( "{" );
call    0 returned 166
      166: 3745:		indent_puts( "yy_more_len = yyleng;" );
call    0 returned 166
      166: 3746:		indent_puts( "yy_more_flag = 0;" );
call    0 returned 166
      166: 3747:		indent_puts( "}" );
call    0 returned 166
      166: 3748:		indent_down();
        -: 3749:		}
        -: 3750:
      541: 3751:	skelout();
call    0 returned 541
        -: 3752:
      541: 3753:	gen_start_state();
call    0 returned 541
        -: 3754:
        -: 3755:	/* Note, don't use any indentation. */
      541: 3756:	puts( "yy_match:" );
call    0 returned 541
      541: 3757:	gen_next_match();
call    0 returned 541
        -: 3758:
      541: 3759:	skelout();
call    0 returned 541
      541: 3760:	set_indent( 2 );
      541: 3761:	gen_find_action();
call    0 returned 541
        -: 3762:
      541: 3763:	skelout();
call    0 returned 541
      541: 3764:	if ( lex_compat )
branch  0 taken 162 (fallthrough)
branch  1 taken 379
        -: 3765:		{
      162: 3766:		indent_puts( "if ( yy_act != YY_END_OF_BUFFER )" );
call    0 returned 162
      162: 3767:		indent_up();
      162: 3768:		indent_puts( "{" );
call    0 returned 162
      162: 3769:		indent_puts( "int yyl;" );
call    0 returned 162
      162: 3770:		indent_puts( "for ( yyl = 0; yyl < yyleng; ++yyl )" );
call    0 returned 162
      162: 3771:		indent_up();
      162: 3772:		indent_puts( "if ( yytext[yyl] == '\\n' )" );
call    0 returned 162
      162: 3773:		indent_up();
      162: 3774:		indent_puts( "++yylineno;" );
call    0 returned 162
      162: 3775:		indent_down();
      162: 3776:		indent_down();
      162: 3777:		indent_puts( "}" );
call    0 returned 162
      162: 3778:		indent_down();
        -: 3779:		}
        -: 3780:
      541: 3781:	skelout();
call    0 returned 541
      541: 3782:	if ( ddebug )
branch  0 taken 252 (fallthrough)
branch  1 taken 289
        -: 3783:		{
      252: 3784:		indent_puts( "if ( yy_flex_debug )" );
call    0 returned 252
      252: 3785:		indent_up();
        -: 3786:
      252: 3787:		indent_puts( "{" );
call    0 returned 252
      252: 3788:		indent_puts( "if ( yy_act == 0 )" );
call    0 returned 252
      252: 3789:		indent_up();
      252: 3790:		indent_puts(
call    0 returned 252
        -: 3791:			"fprintf( stderr, \"--scanner backing up\\n\" );" );
      252: 3792:		indent_down();
        -: 3793:
      252: 3794:		do_indent();
call    0 returned 252
      252: 3795:		printf( "else if ( yy_act < %d )\n", num_rules );
call    0 returned 252
      252: 3796:		indent_up();
      252: 3797:		indent_puts(
call    0 returned 252
        -: 3798:	"fprintf( stderr, \"--accepting rule at line %d (\\\"%s\\\")\\n\"," );
      252: 3799:		indent_puts( "         yy_rule_linenum[yy_act], yytext );" );
call    0 returned 252
      252: 3800:		indent_down();
        -: 3801:
      252: 3802:		do_indent();
call    0 returned 252
      252: 3803:		printf( "else if ( yy_act == %d )\n", num_rules );
call    0 returned 252
      252: 3804:		indent_up();
      252: 3805:		indent_puts(
call    0 returned 252
        -: 3806:	"fprintf( stderr, \"--accepting default rule (\\\"%s\\\")\\n\"," );
      252: 3807:		indent_puts( "         yytext );" );
call    0 returned 252
      252: 3808:		indent_down();
        -: 3809:
      252: 3810:		do_indent();
call    0 returned 252
      252: 3811:		printf( "else if ( yy_act == %d )\n", num_rules + 1 );
call    0 returned 252
      252: 3812:		indent_up();
      252: 3813:		indent_puts(
call    0 returned 252
        -: 3814:	"fprintf( stderr, \"--(end of buffer or a NUL)\\n\" );" );
      252: 3815:		indent_down();
        -: 3816:
      252: 3817:		do_indent();
call    0 returned 252
      252: 3818:		printf( "else\n" );
call    0 returned 252
      252: 3819:		indent_up();
      252: 3820:		indent_puts(
call    0 returned 252
        -: 3821:	"fprintf( stderr, \"--EOF (start condition %d)\\n\", YY_START );" );
      252: 3822:		indent_down();
        -: 3823:
      252: 3824:		indent_puts( "}" );
call    0 returned 252
      252: 3825:		indent_down();
        -: 3826:		}
        -: 3827:
        -: 3828:	/* Copy actions to output file. */
      541: 3829:	skelout();
call    0 returned 541
      541: 3830:	indent_up();
      541: 3831:	gen_bu_action();
call    0 returned 541
      541: 3832:	fputs( &action_array[action_offset], stdout );
call    0 returned 541
        -: 3833:
        -: 3834:	/* generate cases for any missing EOF rules */
     1095: 3835:	for ( i = 1; i <= lastsc; ++i )
branch  0 taken 554
branch  1 taken 541 (fallthrough)
      554: 3836:		if ( ! sceof[i] )
branch  0 taken 540 (fallthrough)
branch  1 taken 14
        -: 3837:			{
      540: 3838:			do_indent();
call    0 returned 540
      540: 3839:			printf( "case YY_STATE_EOF(%s):\n", scname[i] );
call    0 returned 540
      540: 3840:			did_eof_rule = true;
        -: 3841:			}
        -: 3842:
      541: 3843:	if ( did_eof_rule )
branch  0 taken 536 (fallthrough)
branch  1 taken 5
        -: 3844:		{
      536: 3845:		indent_up();
      536: 3846:		indent_puts( "yyterminate();" );
call    0 returned 536
      536: 3847:		indent_down();
        -: 3848:		}
        -: 3849:
        -: 3850:
        -: 3851:	/* Generate code for handling NUL's, if needed. */
        -: 3852:
        -: 3853:	/* First, deal with backing up and setting up yy_cp if the scanner
        -: 3854:	 * finds that it should JAM on the NUL>
        -: 3855:	 */
      541: 3856:	skelout();
call    0 returned 541
      541: 3857:	set_indent( 7 );
        -: 3858:
      541: 3859:	if ( fullspd || fulltbl )
branch  0 taken 449 (fallthrough)
branch  1 taken 92
branch  2 taken 23 (fallthrough)
branch  3 taken 426
      115: 3860:		indent_puts( "yy_cp = yy_c_buf_p;" );
call    0 returned 115
        -: 3861:
        -: 3862:	else
        -: 3863:		{ /* compressed table */
      426: 3864:		if ( ! reject && ! interactive )
branch  0 taken 256 (fallthrough)
branch  1 taken 170
branch  2 taken 1 (fallthrough)
branch  3 taken 255
        -: 3865:			{
        -: 3866:			/* Do the guaranteed-needed backing up to figure
        -: 3867:			 * out the match.
        -: 3868:			 */
        1: 3869:			indent_puts( "yy_cp = yy_last_accepting_cpos;" );
call    0 returned 1
        1: 3870:			indent_puts(
call    0 returned 1
        -: 3871:				"yy_current_state = yy_last_accepting_state;" );
        -: 3872:			}
        -: 3873:		}
        -: 3874:
        -: 3875:
        -: 3876:	/* Generate code for yy_get_previous_state(). */
      541: 3877:	set_indent( 1 );
      541: 3878:	skelout();
call    0 returned 541
        -: 3879:
      541: 3880:	if ( bol_needed )
branch  0 taken 98 (fallthrough)
branch  1 taken 443
       98: 3881:		indent_puts( "register char *yy_bp = yytext_ptr;\n" );
call    0 returned 98
        -: 3882:
      541: 3883:	gen_start_state();
call    0 returned 541
        -: 3884:
      541: 3885:	set_indent( 2 );
      541: 3886:	skelout();
call    0 returned 541
      541: 3887:	gen_next_state( true );
call    0 returned 541
        -: 3888:
      541: 3889:	set_indent( 1 );
      541: 3890:	skelout();
call    0 returned 541
      541: 3891:	gen_NUL_trans();
call    0 returned 541
        -: 3892:
      541: 3893:	skelout();
call    0 returned 541
      541: 3894:	if ( lex_compat )
branch  0 taken 162 (fallthrough)
branch  1 taken 379
        -: 3895:		{ /* update yylineno inside of unput() */
      162: 3896:		indent_puts( "if ( c == '\\n' )" );
call    0 returned 162
      162: 3897:		indent_up();
      162: 3898:		indent_puts( "--yylineno;" );
call    0 returned 162
      162: 3899:		indent_down();
        -: 3900:		}
        -: 3901:
      541: 3902:	skelout();
call    0 returned 541
        -: 3903:
        -: 3904:	/* Copy remainder of input to output. */
        -: 3905:
      541: 3906:	line_directive_out( stdout );
call    0 returned 541
        -: 3907:
      541: 3908:	if ( sectnum == 3 )
branch  0 taken 111 (fallthrough)
branch  1 taken 430
      111: 3909:		(void) flexscan(); /* copy remainder of input to output */
call    0 returned 111
      541: 3910:	}
        -: 3911:/* misc - miscellaneous flex routines */
        -: 3912:
        -: 3913:/*-
        -: 3914: * Copyright (c) 1990 The Regents of the University of California.
        -: 3915: * All rights reserved.
        -: 3916: *
        -: 3917: * This code is derived from software contributed to Berkeley by
        -: 3918: * Vern Paxson.
        -: 3919: * 
        -: 3920: * The United States Government has rights in this work pursuant
        -: 3921: * to contract no. DE-AC03-76SF00098 between the United States
        -: 3922: * Department of Energy and the University of California.
        -: 3923: *
        -: 3924: * Redistribution and use in source and binary forms are permitted provided
        -: 3925: * that: (1) source distributions retain this entire copyright notice and
        -: 3926: * comment, and (2) distributions including binaries display the following
        -: 3927: * acknowledgement:  ``This product includes software developed by the
        -: 3928: * University of California, Berkeley and its contributors'' in the
        -: 3929: * documentation or other materials provided with the distribution and in
        -: 3930: * all advertising materials mentioning features or use of this software.
        -: 3931: * Neither the name of the University nor the names of its contributors may
        -: 3932: * be used to endorse or promote products derived from this software without
        -: 3933: * specific prior written permission.
        -: 3934: * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
        -: 3935: * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
        -: 3936: * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
        -: 3937: */
        -: 3938:
        -: 3939:/* $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.orig/v0/flex.c,v 1.1.1.1 2003/06/02 17:12:00 expsir Exp $ */
        -: 3940:
        -: 3941:
        -: 3942:
        -: 3943:
        -: 3944:/* declare functions that have forward references */
        -: 3945:
        -: 3946:void dataflush PROTO((void));
        -: 3947:int otoi PROTO((Char []));
        -: 3948:
        -: 3949:
function add_action called 48430 returned 100% blocks executed 100%
    48430: 3950:void add_action( new_text )
        -: 3951:char *new_text;
        -: 3952:	{
    48430: 3953:	int len = yy_strlen( new_text );
call    0 returned 48430
        -: 3954:
    48438: 3955:	while ( len + action_index >= action_size - 10 /* slop */ )
branch  0 taken 8
branch  1 taken 48430 (fallthrough)
        -: 3956:		{
        8: 3957:		action_size *= 2;
        8: 3958:		action_array =
        8: 3959:			reallocate_character_array( action_array, action_size );
call    0 returned 8
        -: 3960:		}
        -: 3961:
    48430: 3962:	yy_strcpy( &action_array[action_index], new_text );
call    0 returned 48430
        -: 3963:
    48430: 3964:	action_index += len;
    48430: 3965:	}
        -: 3966:
        -: 3967:
        -: 3968:/* allocate_array - allocate memory for an integer array of the given size */
        -: 3969:
function allocate_array called 38182 returned 100% blocks executed 71%
    38182: 3970:void *allocate_array( size, element_size )
        -: 3971:int size, element_size;
        -: 3972:	{
        -: 3973:	register void *mem;
        -: 3974:
        -: 3975:	/* On 16-bit int machines (e.g., 80286) we might be trying to
        -: 3976:	 * allocate more than a signed int can hold, and that won't
        -: 3977:	 * work.  Cheap test:
        -: 3978:	 */
    38182: 3979:	if ( element_size * size <= 0 )
branch  0 taken 0 (fallthrough)
branch  1 taken 38182
    #####: 3980:		flexfatal( "request for < 1 byte in allocate_array()" );
call    0 never executed
        -: 3981:
    38182: 3982:	mem = yy_flex_alloc( element_size * size );
call    0 returned 38182
        -: 3983:
    38182: 3984:	if ( mem == NULL )
branch  0 taken 0 (fallthrough)
branch  1 taken 38182
    #####: 3985:		flexfatal( "memory allocation failed in allocate_array()" );
call    0 never executed
        -: 3986:
    38182: 3987:	return mem;
        -: 3988:	}
        -: 3989:
        -: 3990:
        -: 3991:/* all_lower - true if a string is all lower-case */
        -: 3992:
function all_lower called 4 returned 100% blocks executed 88%
        4: 3993:int all_lower( str )
        -: 3994:register char *str;
        -: 3995:	{
       28: 3996:	while ( *str )
branch  0 taken 24
branch  1 taken 4 (fallthrough)
        -: 3997:		{
       24: 3998:		if ( ! isascii( (Char) *str ) || ! islower( *str ) )
branch  0 taken 24 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 24
    #####: 3999:			return 0;
       24: 4000:		++str;
        -: 4001:		}
        -: 4002:
        4: 4003:	return 1;
        -: 4004:	}
        -: 4005:
        -: 4006:
        -: 4007:/* all_upper - true if a string is all upper-case */
        -: 4008:
function all_upper called 6 returned 100% blocks executed 88%
        6: 4009:int all_upper( str )
        -: 4010:register char *str;
        -: 4011:	{
       42: 4012:	while ( *str )
branch  0 taken 36
branch  1 taken 6 (fallthrough)
        -: 4013:		{
       36: 4014:		if ( ! isascii( (Char) *str ) || ! isupper( *str ) )
branch  0 taken 36 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 36
    #####: 4015:			return 0;
       36: 4016:		++str;
        -: 4017:		}
        -: 4018:
        6: 4019:	return 1;
        -: 4020:	}
        -: 4021:
        -: 4022:
        -: 4023:/* bubble - bubble sort an integer array in increasing order
        -: 4024: *
        -: 4025: * synopsis
        -: 4026: *   int v[n], n;
        -: 4027: *   void bubble( v, n );
        -: 4028: *
        -: 4029: * description
        -: 4030: *   sorts the first n elements of array v and replaces them in
        -: 4031: *   increasing order.
        -: 4032: *
        -: 4033: * passed
        -: 4034: *   v - the array to be sorted
        -: 4035: *   n - the number of elements of 'v' to be sorted
        -: 4036: */
        -: 4037:
function bubble called 25660 returned 100% blocks executed 100%
    25660: 4038:void bubble( v, n )
        -: 4039:int v[], n;
        -: 4040:	{
        -: 4041:	register int i, j, k;
        -: 4042:
    77924: 4043:	for ( i = n; i > 1; --i )
branch  0 taken 52264
branch  1 taken 25660 (fallthrough)
   197597: 4044:		for ( j = 1; j < i; ++j )
branch  0 taken 145333
branch  1 taken 52264 (fallthrough)
   145333: 4045:			if ( v[j] > v[j + 1] )	/* compare */
branch  0 taken 77267 (fallthrough)
branch  1 taken 68066
        -: 4046:				{
    77267: 4047:				k = v[j];	/* exchange */
    77267: 4048:				v[j] = v[j + 1];
    77267: 4049:				v[j + 1] = k;
        -: 4050:				}
    25660: 4051:	}
        -: 4052:
        -: 4053:
        -: 4054:/* check_char - checks a character to make sure it's within the range
        -: 4055: *		we're expecting.  If not, generates fatal error message
        -: 4056: *		and exits.
        -: 4057: */
        -: 4058:
function check_char called 34508 returned 100% blocks executed 43%
    34508: 4059:void check_char( c )
        -: 4060:int c;
        -: 4061:	{
    34508: 4062:	if ( c >= CSIZE )
branch  0 taken 0 (fallthrough)
branch  1 taken 34508
    #####: 4063:		lerrsf( "bad character '%s' detected in check_char()",
call    0 never executed
call    1 never executed
        -: 4064:			readable_form( c ) );
        -: 4065:
    34508: 4066:	if ( c >= csize )
branch  0 taken 0 (fallthrough)
branch  1 taken 34508
    #####: 4067:		lerrsf( "scanner requires -8 flag to use the character '%s'",
call    0 never executed
call    1 never executed
        -: 4068:			readable_form( c ) );
    34508: 4069:	}
        -: 4070:
        -: 4071:
        -: 4072:
        -: 4073:/* clower - replace upper-case letter to lower-case */
        -: 4074:
function clower called 83 returned 100% blocks executed 100%
       83: 4075:Char clower( c )
        -: 4076:register int c;
        -: 4077:	{
       83: 4078:	return (Char) ((isascii( c ) && isupper( c )) ? tolower( c ) : c);
branch  0 taken 83 (fallthrough)
branch  1 taken 0
branch  2 taken 78 (fallthrough)
branch  3 taken 5
        -: 4079:	}
        -: 4080:
        -: 4081:
        -: 4082:/* copy_string - returns a dynamically allocated copy of a string */
        -: 4083:
function copy_string called 797 returned 100% blocks executed 90%
      797: 4084:char *copy_string( str )
        -: 4085:register char *str;
        -: 4086:	{
        -: 4087:	register char *c;
        -: 4088:	char *copy;
        -: 4089:
        -: 4090:	/* find length */
     5546: 4091:	for ( c = str; *c; ++c )
branch  0 taken 4749
branch  1 taken 797 (fallthrough)
        -: 4092:		;
        -: 4093:
      797: 4094:	copy = (char *) yy_flex_alloc( (c - str + 1) * sizeof( char ) );
call    0 returned 797
        -: 4095:
      797: 4096:	if ( copy == NULL )
branch  0 taken 0 (fallthrough)
branch  1 taken 797
    #####: 4097:		flexfatal( "dynamic memory failure in copy_string()" );
call    0 never executed
        -: 4098:
     5546: 4099:	for ( c = copy; (*c++ = *str++); )
branch  0 taken 4749
branch  1 taken 797 (fallthrough)
        -: 4100:		;
        -: 4101:
      797: 4102:	return copy;
        -: 4103:	}
        -: 4104:
        -: 4105:
        -: 4106:/* copy_unsigned_string -
        -: 4107: *    returns a dynamically allocated copy of a (potentially) unsigned string
        -: 4108: */
        -: 4109:
function copy_unsigned_string called 1508 returned 100% blocks executed 100%
     1508: 4110:Char *copy_unsigned_string( str )
        -: 4111:register Char *str;
        -: 4112:	{
        -: 4113:	register Char *c;
        -: 4114:	Char *copy;
        -: 4115:
        -: 4116:	/* find length */
    10704: 4117:	for ( c = str; *c; ++c )
branch  0 taken 9196
branch  1 taken 1508 (fallthrough)
        -: 4118:		;
        -: 4119:
     1508: 4120:	copy = allocate_Character_array( c - str + 1 );
call    0 returned 1508
        -: 4121:
    10704: 4122:	for ( c = copy; (*c++ = *str++); )
branch  0 taken 9196
branch  1 taken 1508 (fallthrough)
        -: 4123:		;
        -: 4124:
     1508: 4125:	return copy;
        -: 4126:	}
        -: 4127:
        -: 4128:
        -: 4129:/* cshell - shell sort a character array in increasing order
        -: 4130: *
        -: 4131: * synopsis
        -: 4132: *
        -: 4133: *   Char v[n];
        -: 4134: *   int n, special_case_0;
        -: 4135: *   cshell( v, n, special_case_0 );
        -: 4136: *
        -: 4137: * description
        -: 4138: *   Does a shell sort of the first n elements of array v.
        -: 4139: *   If special_case_0 is true, then any element equal to 0
        -: 4140: *   is instead assumed to have infinite weight.
        -: 4141: *
        -: 4142: * passed
        -: 4143: *   v - array to be sorted
        -: 4144: *   n - number of elements of v to be sorted
        -: 4145: */
        -: 4146:
function cshell called 835 returned 100% blocks executed 89%
      835: 4147:void cshell( v, n, special_case_0 )
        -: 4148:Char v[];
        -: 4149:int n, special_case_0;
        -: 4150:	{
        -: 4151:	int gap, i, j, jg;
        -: 4152:	Char k;
        -: 4153:
     3415: 4154:	for ( gap = n / 2; gap > 0; gap = gap / 2 )
branch  0 taken 2580
branch  1 taken 835 (fallthrough)
    74127: 4155:		for ( i = gap; i < n; ++i )
branch  0 taken 71547
branch  1 taken 2580 (fallthrough)
    96146: 4156:			for ( j = i - gap; j >= 0; j = j - gap )
branch  0 taken 91925
branch  1 taken 4221 (fallthrough)
        -: 4157:				{
    91925: 4158:				jg = j + gap;
        -: 4159:
    91925: 4160:				if ( special_case_0 )
branch  0 taken 91925 (fallthrough)
branch  1 taken 0
        -: 4161:					{
    91925: 4162:					if ( v[jg] == 0 )
branch  0 taken 4 (fallthrough)
branch  1 taken 91921
        4: 4163:						break;
        -: 4164:
    91921: 4165:					else if ( v[j] != 0 && v[j] <= v[jg] )
branch  0 taken 91915 (fallthrough)
branch  1 taken 6
branch  2 taken 67322 (fallthrough)
branch  3 taken 24593
    67322: 4166:						break;
        -: 4167:					}
        -: 4168:
    #####: 4169:				else if ( v[j] <= v[jg] )
branch  0 never executed
branch  1 never executed
    #####: 4170:					break;
        -: 4171:
    24599: 4172:				k = v[j];
    24599: 4173:				v[j] = v[jg];
    24599: 4174:				v[jg] = k;
        -: 4175:				}
      835: 4176:	}
        -: 4177:
        -: 4178:
        -: 4179:/* dataend - finish up a block of data declarations */
        -: 4180:
function dataend called 3391 returned 100% blocks executed 100%
     3391: 4181:void dataend()
        -: 4182:	{
     3391: 4183:	if ( datapos > 0 )
branch  0 taken 3372 (fallthrough)
branch  1 taken 19
     3372: 4184:		dataflush();
call    0 returned 3372
        -: 4185:
        -: 4186:	/* add terminator for initialization; { for vi */
     3391: 4187:	puts( "    } ;\n" );
call    0 returned 3391
        -: 4188:
     3391: 4189:	dataline = 0;
     3391: 4190:	datapos = 0;
     3391: 4191:	}
        -: 4192:
        -: 4193:
        -: 4194:/* dataflush - flush generated data statements */
        -: 4195:
function dataflush called 52901 returned 100% blocks executed 100%
    52901: 4196:void dataflush()
        -: 4197:	{
    52901: 4198:	putchar( '\n' );
call    0 returned 52901
        -: 4199:
    52901: 4200:	if ( ++dataline >= NUMDATALINES )
branch  0 taken 4687 (fallthrough)
branch  1 taken 48214
        -: 4201:		{
        -: 4202:		/* Put out a blank line so that the table is grouped into
        -: 4203:		 * large blocks that enable the user to find elements easily.
        -: 4204:		 */
     4687: 4205:		putchar( '\n' );
call    0 returned 4687
     4687: 4206:		dataline = 0;
        -: 4207:		}
        -: 4208:
        -: 4209:	/* Reset the number of characters written on the current line. */
    52901: 4210:	datapos = 0;
    52901: 4211:	}
        -: 4212:
        -: 4213:
        -: 4214:/* flexerror - report an error message and terminate */
        -: 4215:
function flexerror called 14 returned 0% blocks executed 100%
       14: 4216:void flexerror( msg )
        -: 4217:char msg[];
        -: 4218:	{
       14: 4219:	fprintf( err, "%s: %s\n", program_name, msg );
call    0 returned 14
       14: 4220:	flexend( 1 );
call    0 returned 0
    #####: 4221:	}
        -: 4222:
        -: 4223:
        -: 4224:/* flexfatal - report a fatal error message and terminate */
        -: 4225:
function flexfatal called 0 returned 0% blocks executed 0%
    #####: 4226:void flexfatal( msg )
        -: 4227:char msg[];
        -: 4228:	{
    #####: 4229:	fprintf( err, "%s: fatal internal error, %s\n", program_name, msg );
call    0 never executed
    #####: 4230:	exit( 1 );
        -: 4231:	}
        -: 4232:
        -: 4233:
        -: 4234:/* lerrif - report an error message formatted with one integer argument */
        -: 4235:
function lerrif called 1 returned 0% blocks executed 100%
        1: 4236:void lerrif( msg, arg )
        -: 4237:char msg[];
        -: 4238:int arg;
        -: 4239:	{
        -: 4240:	char errmsg[MAXLINE];
        1: 4241:	(void) sprintf( errmsg, msg, arg );
        1: 4242:	flexerror( errmsg );
call    0 returned 0
    #####: 4243:	}
        -: 4244:
        -: 4245:
        -: 4246:/* lerrsf - report an error message formatted with one string argument */
        -: 4247:
function lerrsf called 2 returned 0% blocks executed 100%
        2: 4248:void lerrsf( msg, arg )
        -: 4249:char msg[], arg[];
        -: 4250:	{
        -: 4251:	char errmsg[MAXLINE];
        -: 4252:
        2: 4253:	(void) sprintf( errmsg, msg, arg );
        2: 4254:	flexerror( errmsg );
call    0 returned 0
    #####: 4255:	}
        -: 4256:
        -: 4257:
        -: 4258:/* htoi - convert a hexadecimal digit string to an integer value */
        -: 4259:
function htoi called 3 returned 100% blocks executed 100%
        3: 4260:int htoi( str )
        -: 4261:Char str[];
        -: 4262:	{
        -: 4263:	unsigned int result;
        -: 4264:
        3: 4265:	(void) sscanf( (char *) str, "%x", &result );
        -: 4266:
        3: 4267:	return result;
        -: 4268:	}
        -: 4269:
        -: 4270:
        -: 4271:/* is_hex_digit - returns true if a character is a valid hex digit, false
        -: 4272: *		  otherwise
        -: 4273: */
        -: 4274:
function is_hex_digit called 7 returned 100% blocks executed 100%
        7: 4275:int is_hex_digit( ch )
        -: 4276:int ch;
        -: 4277:	{
        7: 4278:	if ( isdigit( ch ) )
branch  0 taken 2 (fallthrough)
branch  1 taken 5
        2: 4279:		return 1;
        -: 4280:
        5: 4281:	switch ( clower( ch ) )
call    0 returned 5
branch  1 taken 2 (fallthrough)
branch  2 taken 3
        -: 4282:		{
        2: 4283:		case 'a':
        -: 4284:		case 'b':
        -: 4285:		case 'c':
        -: 4286:		case 'd':
        -: 4287:		case 'e':
        -: 4288:		case 'f':
        2: 4289:			return 1;
        -: 4290:
        3: 4291:		default:
        3: 4292:			return 0;
        -: 4293:		}
        -: 4294:	}
        -: 4295:
        -: 4296:
        -: 4297:/* line_directive_out - spit out a "# line" statement */
        -: 4298:
function line_directive_out called 5252 returned 100% blocks executed 100%
     5252: 4299:void line_directive_out( output_file )
        -: 4300:FILE *output_file;
        -: 4301:	{
     5252: 4302:	if ( infilename && gen_line_dirs )
branch  0 taken 5252 (fallthrough)
branch  1 taken 0
branch  2 taken 5215 (fallthrough)
branch  3 taken 37
        -: 4303:		{
        -: 4304:		char directive[MAXLINE];
     5215: 4305:		sprintf( directive, "# line %d \"%s\"\n", linenum, infilename );
        -: 4306:
        -: 4307:		/* If output_file is nil then we should put the directive in
        -: 4308:		 * the accumulated actions.
        -: 4309:		 */
     5215: 4310:		if ( output_file )
branch  0 taken 538 (fallthrough)
branch  1 taken 4677
      538: 4311:			fputs( directive, output_file );
call    0 returned 538
        -: 4312:		else
     4677: 4313:			add_action( directive );
call    0 returned 4677
        -: 4314:		}
     5252: 4315:	}
        -: 4316:
        -: 4317:
        -: 4318:/* mark_defs1 - mark the current position in the action array as
        -: 4319: *               representing where the user's section 1 definitions end
        -: 4320: *		 and the prolog begins
        -: 4321: */
function mark_defs1 called 549 returned 100% blocks executed 100%
      549: 4322:void mark_defs1()
        -: 4323:	{
      549: 4324:	defs1_offset = 0;
      549: 4325:	action_array[action_index++] = '\0';
      549: 4326:	action_offset = prolog_offset = action_index;
      549: 4327:	action_array[action_index] = '\0';
      549: 4328:	}
        -: 4329:
        -: 4330:
        -: 4331:/* mark_prolog - mark the current position in the action array as
        -: 4332: *               representing the end of the action prolog
        -: 4333: */
function mark_prolog called 549 returned 100% blocks executed 100%
      549: 4334:void mark_prolog()
        -: 4335:	{
      549: 4336:	action_array[action_index++] = '\0';
      549: 4337:	action_offset = action_index;
      549: 4338:	action_array[action_index] = '\0';
      549: 4339:	}
        -: 4340:
        -: 4341:
        -: 4342:/* mk2data - generate a data statement for a two-dimensional array
        -: 4343: *
        -: 4344: * Generates a data statement initializing the current 2-D array to "value".
        -: 4345: */
function mk2data called 70116 returned 100% blocks executed 100%
    70116: 4346:void mk2data( value )
        -: 4347:int value;
        -: 4348:	{
    70116: 4349:	if ( datapos >= NUMDATAITEMS )
branch  0 taken 7113 (fallthrough)
branch  1 taken 63003
        -: 4350:		{
     7113: 4351:		putchar( ',' );
call    0 returned 7113
     7113: 4352:		dataflush();
call    0 returned 7113
        -: 4353:		}
        -: 4354:
    70116: 4355:	if ( datapos == 0 )
branch  0 taken 7136 (fallthrough)
branch  1 taken 62980
        -: 4356:		/* Indent. */
     7136: 4357:		fputs( "    ", stdout );
call    0 returned 7136
        -: 4358:
        -: 4359:	else
    62980: 4360:		putchar( ',' );
call    0 returned 62980
        -: 4361:
    70116: 4362:	++datapos;
        -: 4363:
    70116: 4364:	printf( "%5d", value );
call    0 returned 70116
    70116: 4365:	}
        -: 4366:
        -: 4367:
        -: 4368:/* mkdata - generate a data statement
        -: 4369: *
        -: 4370: * Generates a data statement initializing the current array element to
        -: 4371: * "value".
        -: 4372: */
function mkdata called 441016 returned 100% blocks executed 100%
   441016: 4373:void mkdata( value )
        -: 4374:int value;
        -: 4375:	{
   441016: 4376:	if ( datapos >= NUMDATAITEMS )
branch  0 taken 42416 (fallthrough)
branch  1 taken 398600
        -: 4377:		{
    42416: 4378:		putchar( ',' );
call    0 returned 42416
    42416: 4379:		dataflush();
call    0 returned 42416
        -: 4380:		}
        -: 4381:
   441016: 4382:	if ( datapos == 0 )
branch  0 taken 45691 (fallthrough)
branch  1 taken 395325
        -: 4383:		/* Indent. */
    45691: 4384:		fputs( "    ", stdout );
call    0 returned 45691
        -: 4385:	else
   395325: 4386:		putchar( ',' );
call    0 returned 395325
        -: 4387:
   441016: 4388:	++datapos;
        -: 4389:
   441016: 4390:	printf( "%5d", value );
call    0 returned 441016
   441016: 4391:	}
        -: 4392:
        -: 4393:
        -: 4394:/* myctoi - return the integer represented by a string of digits */
        -: 4395:
function myctoi called 390 returned 100% blocks executed 100%
      390: 4396:int myctoi( array )
        -: 4397:char array[];
        -: 4398:	{
      390: 4399:	int val = 0;
        -: 4400:
      390: 4401:	(void) sscanf( array, "%d", &val );
        -: 4402:
      390: 4403:	return val;
        -: 4404:	}
        -: 4405:
        -: 4406:
        -: 4407:/* myesc - return character corresponding to escape sequence */
        -: 4408:
function myesc called 569 returned 100% blocks executed 100%
      569: 4409:Char myesc( array )
        -: 4410:Char array[];
        -: 4411:	{
        -: 4412:	Char c, esc_char;
        -: 4413:
      569: 4414:	switch ( array[1] )
branch  0 taken 1
branch  1 taken 1
branch  2 taken 329
branch  3 taken 1
branch  4 taken 119
branch  5 taken 3
branch  6 taken 1
branch  7 taken 11
branch  8 taken 3
branch  9 taken 100
        -: 4415:		{
        1: 4416:		case 'b': return '\b';
        1: 4417:		case 'f': return '\f';
      329: 4418:		case 'n': return '\n';
        1: 4419:		case 'r': return '\r';
      119: 4420:		case 't': return '\t';
        -: 4421:
        -: 4422:#ifdef __STDC__
        3: 4423:		case 'a': return '\a';
        1: 4424:		case 'v': return '\v';
        -: 4425:#else
        -: 4426:		case 'a': return '\007';
        -: 4427:		case 'v': return '\013';
        -: 4428:#endif
        -: 4429:
       11: 4430:		case '0':
        -: 4431:		case '1':
        -: 4432:		case '2':
        -: 4433:		case '3':
        -: 4434:		case '4':
        -: 4435:		case '5':
        -: 4436:		case '6':
        -: 4437:		case '7':
        -: 4438:		case '8':
        -: 4439:		case '9':
        -: 4440:			{ /* \<octal> */
       11: 4441:			int sptr = 1;
        -: 4442:
       36: 4443:			while ( isascii( array[sptr] ) &&
branch  0 taken 36 (fallthrough)
branch  1 taken 0
       36: 4444:				isdigit( array[sptr] ) )
branch  0 taken 25
branch  1 taken 11 (fallthrough)
        -: 4445:				/* Don't increment inside loop control
        -: 4446:				 * because if isdigit() is a macro it might
        -: 4447:				 * expand into multiple increments ...
        -: 4448:				 */
       25: 4449:				++sptr;
        -: 4450:
       11: 4451:			c = array[sptr];
       11: 4452:			array[sptr] = '\0';
        -: 4453:
       11: 4454:			esc_char = otoi( array + 1 );
call    0 returned 11
        -: 4455:
       11: 4456:			array[sptr] = c;
        -: 4457:
       11: 4458:			return esc_char;
        -: 4459:			}
        -: 4460:
        3: 4461:		case 'x':
        -: 4462:			{ /* \x<hex> */
        3: 4463:			int sptr = 2;
        -: 4464:
       14: 4465:			while ( isascii( array[sptr] ) &&
branch  0 taken 7 (fallthrough)
branch  1 taken 0
branch  2 taken 4
branch  3 taken 3 (fallthrough)
        7: 4466:				is_hex_digit( (char) array[sptr] ) )
call    0 returned 7
        -: 4467:				/* Don't increment inside loop control
        -: 4468:				 * because if isdigit() is a macro it might
        -: 4469:				 * expand into multiple increments ...
        -: 4470:				 */
        4: 4471:				++sptr;
        -: 4472:
        3: 4473:			c = array[sptr];
        3: 4474:			array[sptr] = '\0';
        -: 4475:
        3: 4476:			esc_char = htoi( array + 2 );
call    0 returned 3
        -: 4477:
        3: 4478:			array[sptr] = c;
        -: 4479:
        3: 4480:			return esc_char;
        -: 4481:			}
        -: 4482:
      100: 4483:		default:
      100: 4484:			return array[1];
        -: 4485:		}
        -: 4486:	}
        -: 4487:
        -: 4488:
        -: 4489:/* otoi - convert an octal digit string to an integer value */
        -: 4490:
function otoi called 11 returned 100% blocks executed 100%
       11: 4491:int otoi( str )
        -: 4492:Char str[];
        -: 4493:	{
        -: 4494:	unsigned int result;
        -: 4495:
       11: 4496:	(void) sscanf( (char *) str, "%o", &result );
       11: 4497:	return result;
        -: 4498:	}
        -: 4499:
        -: 4500:
        -: 4501:/* readable_form - return the the human-readable form of a character
        -: 4502: *
        -: 4503: * The returned string is in static storage.
        -: 4504: */
        -: 4505:
function readable_form called 2964 returned 100% blocks executed 100%
     2964: 4506:char *readable_form( c )
        -: 4507:register int c;
        -: 4508:	{
        -: 4509:	static char rform[10];
        -: 4510:
     2964: 4511:	if ( (c >= 0 && c < 32) || c >= 127 )
branch  0 taken 2964 (fallthrough)
branch  1 taken 0
branch  2 taken 2564 (fallthrough)
branch  3 taken 400
branch  4 taken 1424 (fallthrough)
branch  5 taken 1140
        -: 4512:		{
     1824: 4513:		switch ( c )
branch  0 taken 12
branch  1 taken 12
branch  2 taken 16
branch  3 taken 12
branch  4 taken 16
branch  5 taken 12
branch  6 taken 16
branch  7 taken 1728
        -: 4514:			{
       12: 4515:			case '\b': return "\\b";
       12: 4516:			case '\f': return "\\f";
       16: 4517:			case '\n': return "\\n";
       12: 4518:			case '\r': return "\\r";
       16: 4519:			case '\t': return "\\t";
        -: 4520:
        -: 4521:#ifdef __STDC__
       12: 4522:			case '\a': return "\\a";
       16: 4523:			case '\v': return "\\v";
        -: 4524:#endif
        -: 4525:
     1728: 4526:			default:
     1728: 4527:				(void) sprintf( rform, "\\%.3o",
        -: 4528:						(unsigned int) c );
     1728: 4529:				return rform;
        -: 4530:			}
        -: 4531:		}
        -: 4532:
     1140: 4533:	else if ( c == ' ' )
branch  0 taken 12 (fallthrough)
branch  1 taken 1128
       12: 4534:		return "' '";
        -: 4535:
        -: 4536:	else
        -: 4537:		{
     1128: 4538:		rform[0] = c;
     1128: 4539:		rform[1] = '\0';
        -: 4540:
     1128: 4541:		return rform;
        -: 4542:		}
        -: 4543:	}
        -: 4544:
        -: 4545:
        -: 4546:/* reallocate_array - increase the size of a dynamic array */
        -: 4547:
function reallocate_array called 116 returned 100% blocks executed 71%
      116: 4548:void *reallocate_array( array, size, element_size )
        -: 4549:void *array;
        -: 4550:int size, element_size;
        -: 4551:	{
        -: 4552:	register void *new_array;
        -: 4553:
        -: 4554:	/* Same worry as in allocate_array(): */
      116: 4555:	if ( size * element_size <= 0 )
branch  0 taken 0 (fallthrough)
branch  1 taken 116
    #####: 4556:		flexfatal(
call    0 never executed
        -: 4557:			"attempt to increase array size by less than 1 byte" );
        -: 4558:
      116: 4559:	new_array = yy_flex_realloc( array, size * element_size );
call    0 returned 116
        -: 4560:
      116: 4561:	if ( new_array == NULL )
branch  0 taken 0 (fallthrough)
branch  1 taken 116
    #####: 4562:		flexfatal( "attempt to increase array size failed" );
call    0 never executed
        -: 4563:
      116: 4564:	return new_array;
        -: 4565:	}
        -: 4566:
        -: 4567:
        -: 4568:/* skelout - write out one section of the skeleton file
        -: 4569: *
        -: 4570: * Description
        -: 4571: *    Copies skelfile or skel array to stdout until a line beginning with
        -: 4572: *    "%%" or EOF is found.
        -: 4573: */
function skelout called 9746 returned 100% blocks executed 95%
     9746: 4574:void skelout()
        -: 4575:	{
        -: 4576:	char buf_storage[MAXLINE];
     9746: 4577:	char *buf = buf_storage;
     9746: 4578:	int do_copy = 1;
        -: 4579:
        -: 4580:	/* Loop pulling lines either from the skelfile, if we're using
        -: 4581:	 * one, or from the skel[] array.
        -: 4582:	 */
  1112938: 4583:	while ( skelfile ?
branch  0 taken 38 (fallthrough)
branch  1 taken 556431
branch  2 taken 555894
branch  3 taken 575 (fallthrough)
       38: 4584:		(fgets( buf, MAXLINE, skelfile ) != NULL) :
call    0 returned 38
   556431: 4585:		((buf = skel[skel_ind++]) != 0) )
        -: 4586:		{ /* copy from skel array */
   555894: 4587:		if ( buf[0] == '%' )
branch  0 taken 49700 (fallthrough)
branch  1 taken 506194
        -: 4588:			{ /* control line */
    49700: 4589:			switch ( buf[1] )
branch  0 taken 9171
branch  1 taken 11874
branch  2 taken 13515
branch  3 taken 15140
branch  4 taken 0
        -: 4590:				{
     9171: 4591:				case '%':
     9171: 4592:					return;
        -: 4593:
    11874: 4594:				case '+':
    11874: 4595:					do_copy = C_plus_plus;
    11874: 4596:					break;
        -: 4597:
    13515: 4598:				case '-':
    13515: 4599:					do_copy = ! C_plus_plus;
    13515: 4600:					break;
        -: 4601:
    15140: 4602:				case '*':
    15140: 4603:					do_copy = 1;
    15140: 4604:					break;
        -: 4605:
    #####: 4606:				default:
    #####: 4607:					flexfatal(
call    0 never executed
        -: 4608:						"bad line in skeleton file" );
        -: 4609:				}
        -: 4610:			}
        -: 4611:
   506194: 4612:		else if ( do_copy )
branch  0 taken 475994 (fallthrough)
branch  1 taken 30200
        -: 4613:			{
   475994: 4614:			if ( skelfile )
branch  0 taken 2 (fallthrough)
branch  1 taken 475992
        -: 4615:				/* Skeleton file reads include final
        -: 4616:				 * newline, skel[] array does not.
        -: 4617:				 */
        2: 4618:				fputs( buf, stdout );
call    0 returned 2
        -: 4619:			else
   475992: 4620:				printf( "%s\n", buf );
call    0 returned 475992
        -: 4621:			}
        -: 4622:		}
        -: 4623:	}
        -: 4624:
        -: 4625:
        -: 4626:/* transition_struct_out - output a yy_trans_info structure
        -: 4627: *
        -: 4628: * outputs the yy_trans_info structure with the two elements, element_v and
        -: 4629: * element_n.  Formats the output with spaces and carriage returns.
        -: 4630: */
        -: 4631:
function transition_struct_out called 55697 returned 100% blocks executed 100%
    55697: 4632:void transition_struct_out( element_v, element_n )
        -: 4633:int element_v, element_n;
        -: 4634:	{
    55697: 4635:	printf( "%7d, %5d,", element_v, element_n );
call    0 returned 55697
        -: 4636:
    55697: 4637:	datapos += TRANS_STRUCT_PRINT_LENGTH;
        -: 4638:
    55697: 4639:	if ( datapos >= 75 )
branch  0 taken 11103 (fallthrough)
branch  1 taken 44594
        -: 4640:		{
    11103: 4641:		putchar( '\n' );
call    0 returned 11103
        -: 4642:
    11103: 4643:		if ( ++dataline % 10 == 0 )
branch  0 taken 1062 (fallthrough)
branch  1 taken 10041
     1062: 4644:			putchar( '\n' );
call    0 returned 1062
        -: 4645:
    11103: 4646:		datapos = 0;
        -: 4647:		}
    55697: 4648:	}
        -: 4649:
        -: 4650:
        -: 4651:/* The following is only needed when building flex's parser using certain
        -: 4652: * broken versions of bison.
        -: 4653: */
function yy_flex_xmalloc called 0 returned 0% blocks executed 0%
    #####: 4654:void *yy_flex_xmalloc( size )
        -: 4655:int size;
        -: 4656:	{
    #####: 4657:	void *result = yy_flex_alloc( size );
call    0 never executed
        -: 4658:
    #####: 4659:	if ( ! result  )
branch  0 never executed
branch  1 never executed
    #####: 4660:		flexfatal( "memory allocation failed in yy_flex_xmalloc()" );
call    0 never executed
        -: 4661:
    #####: 4662:	return result;
        -: 4663:	}
        -: 4664:
        -: 4665:
        -: 4666:/* zero_out - set a region of memory to 0
        -: 4667: *
        -: 4668: * Sets region_ptr[0] through region_ptr[size_in_bytes - 1] to zero.
        -: 4669: */
        -: 4670:
function zero_out called 569 returned 100% blocks executed 100%
      569: 4671:void zero_out( region_ptr, size_in_bytes )
        -: 4672:char *region_ptr;
        -: 4673:int size_in_bytes;
        -: 4674:	{
        -: 4675:	register char *rp, *rp_end;
        -: 4676:
      569: 4677:	rp = region_ptr;
      569: 4678:	rp_end = region_ptr + size_in_bytes;
        -: 4679:
  4552569: 4680:	while ( rp < rp_end )
branch  0 taken 4552000
branch  1 taken 569 (fallthrough)
  4552000: 4681:		*rp++ = 0;
      569: 4682:	}
        -: 4683:/* nfa - NFA construction routines */
        -: 4684:
        -: 4685:/*-
        -: 4686: * Copyright (c) 1990 The Regents of the University of California.
        -: 4687: * All rights reserved.
        -: 4688: *
        -: 4689: * This code is derived from software contributed to Berkeley by
        -: 4690: * Vern Paxson.
        -: 4691: * 
        -: 4692: * The United States Government has rights in this work pursuant
        -: 4693: * to contract no. DE-AC03-76SF00098 between the United States
        -: 4694: * Department of Energy and the University of California.
        -: 4695: *
        -: 4696: * Redistribution and use in source and binary forms are permitted provided
        -: 4697: * that: (1) source distributions retain this entire copyright notice and
        -: 4698: * comment, and (2) distributions including binaries display the following
        -: 4699: * acknowledgement:  ``This product includes software developed by the
        -: 4700: * University of California, Berkeley and its contributors'' in the
        -: 4701: * documentation or other materials provided with the distribution and in
        -: 4702: * all advertising materials mentioning features or use of this software.
        -: 4703: * Neither the name of the University nor the names of its contributors may
        -: 4704: * be used to endorse or promote products derived from this software without
        -: 4705: * specific prior written permission.
        -: 4706: * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
        -: 4707: * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
        -: 4708: * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
        -: 4709: */
        -: 4710:
        -: 4711:/* $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.orig/v0/flex.c,v 1.1.1.1 2003/06/02 17:12:00 expsir Exp $ */
        -: 4712:
        -: 4713:
        -: 4714:
        -: 4715:/* declare functions that have forward references */
        -: 4716:
        -: 4717:int dupmachine PROTO((int));
        -: 4718:void mkxtion PROTO((int, int));
        -: 4719:
        -: 4720:
        -: 4721:/* add_accept - add an accepting state to a machine
        -: 4722: *
        -: 4723: * accepting_number becomes mach's accepting number.
        -: 4724: */
        -: 4725:
function add_accept called 3555 returned 100% blocks executed 100%
     3555: 4726:void add_accept( mach, accepting_number )
        -: 4727:int mach, accepting_number;
        -: 4728:	{
        -: 4729:	/* Hang the accepting number off an epsilon state.  if it is associated
        -: 4730:	 * with a state that has a non-epsilon out-transition, then the state
        -: 4731:	 * will accept BEFORE it makes that transition, i.e., one character
        -: 4732:	 * too soon.
        -: 4733:	 */
        -: 4734:
     3555: 4735:	if ( transchar[finalst[mach]] == SYM_EPSILON )
branch  0 taken 1369 (fallthrough)
branch  1 taken 2186
     1369: 4736:		accptnum[finalst[mach]] = accepting_number;
        -: 4737:
        -: 4738:	else
        -: 4739:		{
     2186: 4740:		int astate = mkstate( SYM_EPSILON );
call    0 returned 2186
     2186: 4741:		accptnum[astate] = accepting_number;
     2186: 4742:		(void) link_machines( mach, astate );
call    0 returned 2186
        -: 4743:		}
     3555: 4744:	}
        -: 4745:
        -: 4746:
        -: 4747:/* copysingl - make a given number of copies of a singleton machine
        -: 4748: *
        -: 4749: * synopsis
        -: 4750: *
        -: 4751: *   newsng = copysingl( singl, num );
        -: 4752: *
        -: 4753: *     newsng - a new singleton composed of num copies of singl
        -: 4754: *     singl  - a singleton machine
        -: 4755: *     num    - the number of copies of singl to be present in newsng
        -: 4756: */
        -: 4757:
function copysingl called 292 returned 100% blocks executed 100%
      292: 4758:int copysingl( singl, num )
        -: 4759:int singl, num;
        -: 4760:	{
        -: 4761:	int copy, i;
        -: 4762:
      292: 4763:	copy = mkstate( SYM_EPSILON );
call    0 returned 292
        -: 4764:
      777: 4765:	for ( i = 1; i <= num; ++i )
branch  0 taken 485
branch  1 taken 292 (fallthrough)
      485: 4766:		copy = link_machines( copy, dupmachine( singl ) );
call    0 returned 485
call    1 returned 485
        -: 4767:
      292: 4768:	return copy;
        -: 4769:	}
        -: 4770:
        -: 4771:
        -: 4772:/* dumpnfa - debugging routine to write out an nfa */
        -: 4773:
function dumpnfa called 12 returned 100% blocks executed 100%
       12: 4774:void dumpnfa( state1 )
        -: 4775:int state1;
        -: 4776:
        -: 4777:	{
        -: 4778:	int sym, tsp1, tsp2, anum, ns;
        -: 4779:
       12: 4780:	fprintf( err,
call    0 returned 12
        -: 4781:		"\n\n********** beginning dump of nfa with start state %d\n",
        -: 4782:		state1 );
        -: 4783:
        -: 4784:	/* We probably should loop starting at firstst[state1] and going to
        -: 4785:	 * lastst[state1], but they're not maintained properly when we "or"
        -: 4786:	 * all of the rules together.  So we use our knowledge that the machine
        -: 4787:	 * starts at state 1 and ends at lastnfa.
        -: 4788:	 */
        -: 4789:
        -: 4790:	/* for ( ns = firstst[state1]; ns <= lastst[state1]; ++ns ) */
      546: 4791:	for ( ns = 1; ns <= lastnfa; ++ns )
branch  0 taken 534
branch  1 taken 12 (fallthrough)
        -: 4792:		{
      534: 4793:		fprintf( err, "state # %4d\t", ns );
call    0 returned 534
        -: 4794:
      534: 4795:		sym = transchar[ns];
      534: 4796:		tsp1 = trans1[ns];
      534: 4797:		tsp2 = trans2[ns];
      534: 4798:		anum = accptnum[ns];
        -: 4799:
      534: 4800:		fprintf( err, "%3d:  %4d, %4d", sym, tsp1, tsp2 );
call    0 returned 534
        -: 4801:
      534: 4802:		if ( anum != NIL )
branch  0 taken 70 (fallthrough)
branch  1 taken 464
       70: 4803:			fprintf( err, "  [%d]", anum );
call    0 returned 70
        -: 4804:
      534: 4805:		fprintf( err, "\n" );
call    0 returned 534
        -: 4806:		}
        -: 4807:
       12: 4808:	fprintf( err, "********** end of dump\n" );
call    0 returned 12
       12: 4809:	}
        -: 4810:
        -: 4811:
        -: 4812:/* dupmachine - make a duplicate of a given machine
        -: 4813: *
        -: 4814: * synopsis
        -: 4815: *
        -: 4816: *   copy = dupmachine( mach );
        -: 4817: *
        -: 4818: *     copy - holds duplicate of mach
        -: 4819: *     mach - machine to be duplicated
        -: 4820: *
        -: 4821: * note that the copy of mach is NOT an exact duplicate; rather, all the
        -: 4822: * transition states values are adjusted so that the copy is self-contained,
        -: 4823: * as the original should have been.
        -: 4824: *
        -: 4825: * also note that the original MUST be contiguous, with its low and high
        -: 4826: * states accessible by the arrays firstst and lastst
        -: 4827: */
        -: 4828:
function dupmachine called 875 returned 100% blocks executed 62%
      875: 4829:int dupmachine( mach )
        -: 4830:int mach;
        -: 4831:	{
        -: 4832:	int i, init, state_offset;
      875: 4833:	int state = 0;
      875: 4834:	int last = lastst[mach];
        -: 4835:
     1750: 4836:	for ( i = firstst[mach]; i <= last; ++i )
branch  0 taken 875
branch  1 taken 875 (fallthrough)
        -: 4837:		{
      875: 4838:		state = mkstate( transchar[i] );
call    0 returned 875
        -: 4839:
      875: 4840:		if ( trans1[i] != NO_TRANSITION )
branch  0 taken 0 (fallthrough)
branch  1 taken 875
        -: 4841:			{
    #####: 4842:			mkxtion( finalst[state], trans1[i] + state - i );
call    0 never executed
        -: 4843:
    #####: 4844:			if ( transchar[i] == SYM_EPSILON &&
branch  0 never executed
branch  1 never executed
    #####: 4845:			     trans2[i] != NO_TRANSITION )
branch  0 never executed
branch  1 never executed
    #####: 4846:				mkxtion( finalst[state],
    #####: 4847:					trans2[i] + state - i );
call    0 never executed
        -: 4848:			}
        -: 4849:
      875: 4850:		accptnum[state] = accptnum[i];
        -: 4851:		}
        -: 4852:
      875: 4853:	if ( state == 0 )
branch  0 taken 0 (fallthrough)
branch  1 taken 875
    #####: 4854:		flexfatal( "empty machine in dupmachine()" );
call    0 never executed
        -: 4855:
      875: 4856:	state_offset = state - i + 1;
        -: 4857:
      875: 4858:	init = mach + state_offset;
      875: 4859:	firstst[init] = firstst[mach] + state_offset;
      875: 4860:	finalst[init] = finalst[mach] + state_offset;
      875: 4861:	lastst[init] = lastst[mach] + state_offset;
        -: 4862:
      875: 4863:	return init;
        -: 4864:	}
        -: 4865:
        -: 4866:
        -: 4867:/* finish_rule - finish up the processing for a rule
        -: 4868: *
        -: 4869: * An accepting number is added to the given machine.  If variable_trail_rule
        -: 4870: * is true then the rule has trailing context and both the head and trail
        -: 4871: * are variable size.  Otherwise if headcnt or trailcnt is non-zero then
        -: 4872: * the machine recognizes a pattern with trailing context and headcnt is
        -: 4873: * the number of characters in the matched part of the pattern, or zero
        -: 4874: * if the matched part has variable length.  trailcnt is the number of
        -: 4875: * trailing context characters in the pattern, or zero if the trailing
        -: 4876: * context has variable length.
        -: 4877: */
        -: 4878:
function finish_rule called 3489 returned 100% blocks executed 94%
     3489: 4879:void finish_rule( mach, variable_trail_rule, headcnt, trailcnt )
        -: 4880:int mach, variable_trail_rule, headcnt, trailcnt;
        -: 4881:	{
        -: 4882:	char action_text[MAXLINE];
        -: 4883:
     3489: 4884:	add_accept( mach, num_rules );
call    0 returned 3489
        -: 4885:
        -: 4886:	/* We did this in new_rule(), but it often gets the wrong
        -: 4887:	 * number because we do it before we start parsing the current rule.
        -: 4888:	 */
     3489: 4889:	rule_linenum[num_rules] = linenum;
        -: 4890:
        -: 4891:	/* If this is a continued action, then the line-number has already
        -: 4892:	 * been updated, giving us the wrong number.
        -: 4893:	 */
     3489: 4894:	if ( continued_action )
branch  0 taken 8 (fallthrough)
branch  1 taken 3481
        8: 4895:		--rule_linenum[num_rules];
        -: 4896:
     3489: 4897:	sprintf( action_text, "case %d:\n", num_rules );
     3489: 4898:	add_action( action_text );
call    0 returned 3489
        -: 4899:
     3489: 4900:	if ( variable_trail_rule )
branch  0 taken 66 (fallthrough)
branch  1 taken 3423
        -: 4901:		{
       66: 4902:		rule_type[num_rules] = RULE_VARIABLE;
        -: 4903:
       66: 4904:		if ( performance_report > 0 )
branch  0 taken 1 (fallthrough)
branch  1 taken 65
        1: 4905:			fprintf( err,
        -: 4906:				"Variable trailing context rule at line %d\n",
        1: 4907:				rule_linenum[num_rules] );
call    0 returned 1
        -: 4908:
       66: 4909:		variable_trailing_context_rules = true;
        -: 4910:		}
        -: 4911:
        -: 4912:	else
        -: 4913:		{
     3423: 4914:		rule_type[num_rules] = RULE_NORMAL;
        -: 4915:
     3423: 4916:		if ( headcnt > 0 || trailcnt > 0 )
branch  0 taken 3291 (fallthrough)
branch  1 taken 132
branch  2 taken 0 (fallthrough)
branch  3 taken 3291
        -: 4917:			{
        -: 4918:			/* Do trailing context magic to not match the trailing
        -: 4919:			 * characters.
        -: 4920:			 */
      132: 4921:			char *scanner_cp = "yy_c_buf_p = yy_cp";
      132: 4922:			char *scanner_bp = "yy_bp";
        -: 4923:
      132: 4924:			add_action(
call    0 returned 132
        -: 4925:	"*yy_cp = yy_hold_char; /* undo effects of setting up yytext */\n" );
        -: 4926:
      132: 4927:			if ( headcnt > 0 )
branch  0 taken 132 (fallthrough)
branch  1 taken 0
        -: 4928:				{
      132: 4929:				sprintf( action_text, "%s = %s + %d;\n",
        -: 4930:				scanner_cp, scanner_bp, headcnt );
      132: 4931:				add_action( action_text );
call    0 returned 132
        -: 4932:				}
        -: 4933:
        -: 4934:			else
        -: 4935:				{
    #####: 4936:				sprintf( action_text, "%s -= %d;\n",
        -: 4937:					scanner_cp, trailcnt );
    #####: 4938:				add_action( action_text );
call    0 never executed
        -: 4939:				}
        -: 4940:
      132: 4941:			add_action(
call    0 returned 132
        -: 4942:			"YY_DO_BEFORE_ACTION; /* set up yytext again */\n" );
        -: 4943:			}
        -: 4944:		}
        -: 4945:
     3489: 4946:	line_directive_out( (FILE *) 0 );
call    0 returned 3489
     3489: 4947:	}
        -: 4948:
        -: 4949:
        -: 4950:/* link_machines - connect two machines together
        -: 4951: *
        -: 4952: * synopsis
        -: 4953: *
        -: 4954: *   new = link_machines( first, last );
        -: 4955: *
        -: 4956: *     new    - a machine constructed by connecting first to last
        -: 4957: *     first  - the machine whose successor is to be last
        -: 4958: *     last   - the machine whose predecessor is to be first
        -: 4959: *
        -: 4960: * note: this routine concatenates the machine first with the machine
        -: 4961: *  last to produce a machine new which will pattern-match first first
        -: 4962: *  and then last, and will fail if either of the sub-patterns fails.
        -: 4963: *  FIRST is set to new by the operation.  last is unmolested.
        -: 4964: */
        -: 4965:
function link_machines called 16038 returned 100% blocks executed 71%
    16038: 4966:int link_machines( first, last )
        -: 4967:int first, last;
        -: 4968:	{
    16038: 4969:	if ( first == NIL )
branch  0 taken 0 (fallthrough)
branch  1 taken 16038
    #####: 4970:		return last;
        -: 4971:
    16038: 4972:	else if ( last == NIL )
branch  0 taken 0 (fallthrough)
branch  1 taken 16038
    #####: 4973:		return first;
        -: 4974:
        -: 4975:	else
        -: 4976:		{
    16038: 4977:		mkxtion( finalst[first], last );
call    0 returned 16038
    16038: 4978:		finalst[first] = finalst[last];
    16038: 4979:		lastst[first] = max( lastst[first], lastst[last] );
    16038: 4980:		firstst[first] = min( firstst[first], firstst[last] );
        -: 4981:
    16038: 4982:		return first;
        -: 4983:		}
        -: 4984:	}
        -: 4985:
        -: 4986:
        -: 4987:/* mark_beginning_as_normal - mark each "beginning" state in a machine
        -: 4988: *                            as being a "normal" (i.e., not trailing context-
        -: 4989: *                            associated) states
        -: 4990: *
        -: 4991: * The "beginning" states are the epsilon closure of the first state
        -: 4992: */
        -: 4993:
function mark_beginning_as_normal called 98 returned 100% blocks executed 36%
       98: 4994:void mark_beginning_as_normal( mach )
        -: 4995:register int mach;
        -: 4996:	{
       98: 4997:	switch ( state_type[mach] )
branch  0 taken 0
branch  1 taken 98
branch  2 taken 0
        -: 4998:		{
    #####: 4999:		case STATE_NORMAL:
        -: 5000:			/* Oh, we've already visited here. */
    #####: 5001:			return;
        -: 5002:
       98: 5003:		case STATE_TRAILING_CONTEXT:
       98: 5004:			state_type[mach] = STATE_NORMAL;
        -: 5005:
       98: 5006:			if ( transchar[mach] == SYM_EPSILON )
branch  0 taken 0 (fallthrough)
branch  1 taken 98
        -: 5007:				{
    #####: 5008:				if ( trans1[mach] != NO_TRANSITION )
branch  0 never executed
branch  1 never executed
    #####: 5009:					mark_beginning_as_normal(
    #####: 5010:						trans1[mach] );
call    0 never executed
        -: 5011:
    #####: 5012:				if ( trans2[mach] != NO_TRANSITION )
branch  0 never executed
branch  1 never executed
    #####: 5013:					mark_beginning_as_normal(
    #####: 5014:						trans2[mach] );
call    0 never executed
        -: 5015:				}
       98: 5016:			break;
        -: 5017:
    #####: 5018:		default:
    #####: 5019:			flexerror(
call    0 never executed
        -: 5020:				"bad state type in mark_beginning_as_normal()" );
    #####: 5021:			break;
        -: 5022:		}
        -: 5023:	}
        -: 5024:
        -: 5025:
        -: 5026:/* mkbranch - make a machine that branches to two machines
        -: 5027: *
        -: 5028: * synopsis
        -: 5029: *
        -: 5030: *   branch = mkbranch( first, second );
        -: 5031: *
        -: 5032: *     branch - a machine which matches either first's pattern or second's
        -: 5033: *     first, second - machines whose patterns are to be or'ed (the | operator)
        -: 5034: *
        -: 5035: * Note that first and second are NEITHER destroyed by the operation.  Also,
        -: 5036: * the resulting machine CANNOT be used with any other "mk" operation except
        -: 5037: * more mkbranch's.  Compare with mkor()
        -: 5038: */
        -: 5039:
function mkbranch called 4074 returned 100% blocks executed 78%
     4074: 5040:int mkbranch( first, second )
        -: 5041:int first, second;
        -: 5042:	{
        -: 5043:	int eps;
        -: 5044:
     4074: 5045:	if ( first == NO_TRANSITION )
branch  0 taken 0 (fallthrough)
branch  1 taken 4074
    #####: 5046:		return second;
        -: 5047:
     4074: 5048:	else if ( second == NO_TRANSITION )
branch  0 taken 0 (fallthrough)
branch  1 taken 4074
    #####: 5049:		return first;
        -: 5050:
     4074: 5051:	eps = mkstate( SYM_EPSILON );
call    0 returned 4074
        -: 5052:
     4074: 5053:	mkxtion( eps, first );
call    0 returned 4074
     4074: 5054:	mkxtion( eps, second );
call    0 returned 4074
        -: 5055:
     4074: 5056:	return eps;
        -: 5057:	}
        -: 5058:
        -: 5059:
        -: 5060:/* mkclos - convert a machine into a closure
        -: 5061: *
        -: 5062: * synopsis
        -: 5063: *   new = mkclos( state );
        -: 5064: *
        -: 5065: * new - a new state which matches the closure of "state"
        -: 5066: */
        -: 5067:
function mkclos called 927 returned 100% blocks executed 100%
      927: 5068:int mkclos( state )
        -: 5069:int state;
        -: 5070:	{
      927: 5071:	return mkopt( mkposcl( state ) );
call    0 returned 927
call    1 returned 927
        -: 5072:	}
        -: 5073:
        -: 5074:
        -: 5075:/* mkopt - make a machine optional
        -: 5076: *
        -: 5077: * synopsis
        -: 5078: *
        -: 5079: *   new = mkopt( mach );
        -: 5080: *
        -: 5081: *     new  - a machine which optionally matches whatever mach matched
        -: 5082: *     mach - the machine to make optional
        -: 5083: *
        -: 5084: * notes:
        -: 5085: *     1. mach must be the last machine created
        -: 5086: *     2. mach is destroyed by the call
        -: 5087: */
        -: 5088:
function mkopt called 1222 returned 100% blocks executed 100%
     1222: 5089:int mkopt( mach )
        -: 5090:int mach;
        -: 5091:	{
        -: 5092:	int eps;
        -: 5093:
     1222: 5094:	if ( ! SUPER_FREE_EPSILON(finalst[mach]) )
branch  0 taken 1221 (fallthrough)
branch  1 taken 1
branch  2 taken 927 (fallthrough)
branch  3 taken 294
        -: 5095:		{
      928: 5096:		eps = mkstate( SYM_EPSILON );
call    0 returned 928
      928: 5097:		mach = link_machines( mach, eps );
call    0 returned 928
        -: 5098:		}
        -: 5099:
        -: 5100:	/* Can't skimp on the following if FREE_EPSILON(mach) is true because
        -: 5101:	 * some state interior to "mach" might point back to the beginning
        -: 5102:	 * for a closure.
        -: 5103:	 */
     1222: 5104:	eps = mkstate( SYM_EPSILON );
call    0 returned 1222
     1222: 5105:	mach = link_machines( eps, mach );
call    0 returned 1222
        -: 5106:
     1222: 5107:	mkxtion( mach, finalst[mach] );
call    0 returned 1222
        -: 5108:
     1222: 5109:	return mach;
        -: 5110:	}
        -: 5111:
        -: 5112:
        -: 5113:/* mkor - make a machine that matches either one of two machines
        -: 5114: *
        -: 5115: * synopsis
        -: 5116: *
        -: 5117: *   new = mkor( first, second );
        -: 5118: *
        -: 5119: *     new - a machine which matches either first's pattern or second's
        -: 5120: *     first, second - machines whose patterns are to be or'ed (the | operator)
        -: 5121: *
        -: 5122: * note that first and second are both destroyed by the operation
        -: 5123: * the code is rather convoluted because an attempt is made to minimize
        -: 5124: * the number of epsilon states needed
        -: 5125: */
        -: 5126:
function mkor called 1081 returned 100% blocks executed 90%
     1081: 5127:int mkor( first, second )
        -: 5128:int first, second;
        -: 5129:	{
        -: 5130:	int eps, orend;
        -: 5131:
     1081: 5132:	if ( first == NIL )
branch  0 taken 0 (fallthrough)
branch  1 taken 1081
    #####: 5133:		return second;
        -: 5134:
     1081: 5135:	else if ( second == NIL )
branch  0 taken 0 (fallthrough)
branch  1 taken 1081
    #####: 5136:		return first;
        -: 5137:
        -: 5138:	else
        -: 5139:		{
        -: 5140:		/* See comment in mkopt() about why we can't use the first
        -: 5141:		 * state of "first" or "second" if they satisfy "FREE_EPSILON".
        -: 5142:		 */
     1081: 5143:		eps = mkstate( SYM_EPSILON );
call    0 returned 1081
        -: 5144:
     1081: 5145:		first = link_machines( eps, first );
call    0 returned 1081
        -: 5146:
     1081: 5147:		mkxtion( first, second );
call    0 returned 1081
        -: 5148:
     1081: 5149:		if ( SUPER_FREE_EPSILON(finalst[first]) &&
branch  0 taken 660 (fallthrough)
branch  1 taken 421
branch  2 taken 660 (fallthrough)
branch  3 taken 0
      660: 5150:		     accptnum[finalst[first]] == NIL )
branch  0 taken 660 (fallthrough)
branch  1 taken 0
        -: 5151:			{
      660: 5152:			orend = finalst[first];
      660: 5153:			mkxtion( finalst[second], orend );
call    0 returned 660
        -: 5154:			}
        -: 5155:
      421: 5156:		else if ( SUPER_FREE_EPSILON(finalst[second]) &&
branch  0 taken 98 (fallthrough)
branch  1 taken 323
branch  2 taken 98 (fallthrough)
branch  3 taken 0
       98: 5157:			  accptnum[finalst[second]] == NIL )
branch  0 taken 98 (fallthrough)
branch  1 taken 0
        -: 5158:			{
       98: 5159:			orend = finalst[second];
       98: 5160:			mkxtion( finalst[first], orend );
call    0 returned 98
        -: 5161:			}
        -: 5162:
        -: 5163:		else
        -: 5164:			{
      323: 5165:			eps = mkstate( SYM_EPSILON );
call    0 returned 323
        -: 5166:
      323: 5167:			first = link_machines( first, eps );
call    0 returned 323
      323: 5168:			orend = finalst[first];
        -: 5169:
      323: 5170:			mkxtion( finalst[second], orend );
call    0 returned 323
        -: 5171:			}
        -: 5172:		}
        -: 5173:
     1081: 5174:	finalst[first] = orend;
     1081: 5175:	return first;
        -: 5176:	}
        -: 5177:
        -: 5178:
        -: 5179:/* mkposcl - convert a machine into a positive closure
        -: 5180: *
        -: 5181: * synopsis
        -: 5182: *   new = mkposcl( state );
        -: 5183: *
        -: 5184: *    new - a machine matching the positive closure of "state"
        -: 5185: */
        -: 5186:
function mkposcl called 1263 returned 100% blocks executed 67%
     1263: 5187:int mkposcl( state )
        -: 5188:int state;
        -: 5189:	{
        -: 5190:	int eps;
        -: 5191:
    1263*: 5192:	if ( SUPER_FREE_EPSILON(finalst[state]) )
branch  0 taken 0 (fallthrough)
branch  1 taken 1263
branch  2 never executed
branch  3 never executed
        -: 5193:		{
    #####: 5194:		mkxtion( finalst[state], state );
call    0 never executed
    #####: 5195:		return state;
        -: 5196:		}
        -: 5197:
        -: 5198:	else
        -: 5199:		{
     1263: 5200:		eps = mkstate( SYM_EPSILON );
call    0 returned 1263
     1263: 5201:		mkxtion( eps, state );
call    0 returned 1263
     1263: 5202:		return link_machines( state, eps );
call    0 returned 1263
        -: 5203:		}
        -: 5204:	}
        -: 5205:
        -: 5206:
        -: 5207:/* mkrep - make a replicated machine
        -: 5208: *
        -: 5209: * synopsis
        -: 5210: *   new = mkrep( mach, lb, ub );
        -: 5211: *
        -: 5212: *    new - a machine that matches whatever "mach" matched from "lb"
        -: 5213: *          number of times to "ub" number of times
        -: 5214: *
        -: 5215: * note
        -: 5216: *   if "ub" is INFINITY then "new" matches "lb" or more occurrences of "mach"
        -: 5217: */
        -: 5218:
function mkrep called 195 returned 100% blocks executed 100%
      195: 5219:int mkrep( mach, lb, ub )
        -: 5220:int mach, lb, ub;
        -: 5221:	{
        -: 5222:	int base_mach, tail, copy, i;
        -: 5223:
      195: 5224:	base_mach = copysingl( mach, lb - 1 );
call    0 returned 195
        -: 5225:
      195: 5226:	if ( ub == INFINITY )
branch  0 taken 97 (fallthrough)
branch  1 taken 98
        -: 5227:		{
       97: 5228:		copy = dupmachine( mach );
call    0 returned 97
       97: 5229:		mach = link_machines( mach,
call    0 returned 97
call    1 returned 97
call    2 returned 97
        -: 5230:		link_machines( base_mach, mkclos( copy ) ) );
        -: 5231:		}
        -: 5232:
        -: 5233:	else
        -: 5234:		{
       98: 5235:		tail = mkstate( SYM_EPSILON );
call    0 returned 98
        -: 5236:
      391: 5237:		for ( i = lb; i < ub; ++i )
branch  0 taken 293
branch  1 taken 98 (fallthrough)
        -: 5238:			{
      293: 5239:			copy = dupmachine( mach );
call    0 returned 293
      293: 5240:			tail = mkopt( link_machines( copy, tail ) );
call    0 returned 293
call    1 returned 293
        -: 5241:			}
        -: 5242:
       98: 5243:		mach = link_machines( mach, link_machines( base_mach, tail ) );
call    0 returned 98
call    1 returned 98
        -: 5244:		}
        -: 5245:
      195: 5246:	return mach;
        -: 5247:	}
        -: 5248:
        -: 5249:
        -: 5250:/* mkstate - create a state with a transition on a given symbol
        -: 5251: *
        -: 5252: * synopsis
        -: 5253: *
        -: 5254: *   state = mkstate( sym );
        -: 5255: *
        -: 5256: *     state - a new state matching sym
        -: 5257: *     sym   - the symbol the new state is to have an out-transition on
        -: 5258: *
        -: 5259: * note that this routine makes new states in ascending order through the
        -: 5260: * state array (and increments LASTNFA accordingly).  The routine DUPMACHINE
        -: 5261: * relies on machines being made in ascending order and that they are
        -: 5262: * CONTIGUOUS.  Change it and you will have to rewrite DUPMACHINE (kludge
        -: 5263: * that it admittedly is)
        -: 5264: */
        -: 5265:
function mkstate called 25809 returned 100% blocks executed 50%
    25809: 5266:int mkstate( sym )
        -: 5267:int sym;
        -: 5268:	{
    25809: 5269:	if ( ++lastnfa >= current_mns )
branch  0 taken 0 (fallthrough)
branch  1 taken 25809
        -: 5270:		{
    #####: 5271:		if ( (current_mns += MNS_INCREMENT) >= MAXIMUM_MNS )
branch  0 never executed
branch  1 never executed
    #####: 5272:			lerrif(
call    0 never executed
        -: 5273:			"input rules are too complicated (>= %d NFA states)",
        -: 5274:				current_mns );
        -: 5275:
    #####: 5276:		++num_reallocs;
        -: 5277:
    #####: 5278:		firstst = reallocate_integer_array( firstst, current_mns );
call    0 never executed
    #####: 5279:		lastst = reallocate_integer_array( lastst, current_mns );
call    0 never executed
    #####: 5280:		finalst = reallocate_integer_array( finalst, current_mns );
call    0 never executed
    #####: 5281:		transchar = reallocate_integer_array( transchar, current_mns );
call    0 never executed
    #####: 5282:		trans1 = reallocate_integer_array( trans1, current_mns );
call    0 never executed
    #####: 5283:		trans2 = reallocate_integer_array( trans2, current_mns );
call    0 never executed
    #####: 5284:		accptnum = reallocate_integer_array( accptnum, current_mns );
call    0 never executed
    #####: 5285:		assoc_rule =
    #####: 5286:			reallocate_integer_array( assoc_rule, current_mns );
call    0 never executed
    #####: 5287:		state_type =
    #####: 5288:			reallocate_integer_array( state_type, current_mns );
call    0 never executed
        -: 5289:		}
        -: 5290:
    25809: 5291:	firstst[lastnfa] = lastnfa;
    25809: 5292:	finalst[lastnfa] = lastnfa;
    25809: 5293:	lastst[lastnfa] = lastnfa;
    25809: 5294:	transchar[lastnfa] = sym;
    25809: 5295:	trans1[lastnfa] = NO_TRANSITION;
    25809: 5296:	trans2[lastnfa] = NO_TRANSITION;
    25809: 5297:	accptnum[lastnfa] = NIL;
    25809: 5298:	assoc_rule[lastnfa] = num_rules;
    25809: 5299:	state_type[lastnfa] = current_state_type;
        -: 5300:
        -: 5301:	/* Fix up equivalence classes base on this transition.  Note that any
        -: 5302:	 * character which has its own transition gets its own equivalence
        -: 5303:	 * class.  Thus only characters which are only in character classes
        -: 5304:	 * have a chance at being in the same equivalence class.  E.g. "a|b"
        -: 5305:	 * puts 'a' and 'b' into two different equivalence classes.  "[ab]"
        -: 5306:	 * puts them in the same equivalence class (barring other differences
        -: 5307:	 * elsewhere in the input).
        -: 5308:	 */
        -: 5309:
    25809: 5310:	if ( sym < 0 )
branch  0 taken 23556 (fallthrough)
branch  1 taken 2253
        -: 5311:		{
        -: 5312:		/* We don't have to update the equivalence classes since
        -: 5313:		 * that was already done when the ccl was created for the
        -: 5314:		 * first time.
        -: 5315:		 */
        -: 5316:		}
        -: 5317:
    23556: 5318:	else if ( sym == SYM_EPSILON )
branch  0 taken 13861 (fallthrough)
branch  1 taken 9695
    13861: 5319:		++numeps;
        -: 5320:
        -: 5321:	else
        -: 5322:		{
     9695: 5323:		check_char( sym );
call    0 returned 9695
        -: 5324:
     9695: 5325:		if ( useecs )
branch  0 taken 5269 (fallthrough)
branch  1 taken 4426
        -: 5326:			/* Map NUL's to csize. */
     5269: 5327:			mkechar( sym ? sym : csize, nextecm, ecgroup );
branch  0 taken 5268 (fallthrough)
branch  1 taken 1
call    2 returned 5269
        -: 5328:		}
        -: 5329:
    25809: 5330:	return lastnfa;
        -: 5331:	}
        -: 5332:
        -: 5333:
        -: 5334:/* mkxtion - make a transition from one state to another
        -: 5335: *
        -: 5336: * synopsis
        -: 5337: *
        -: 5338: *   mkxtion( statefrom, stateto );
        -: 5339: *
        -: 5340: *     statefrom - the state from which the transition is to be made
        -: 5341: *     stateto   - the state to which the transition is to be made
        -: 5342: */
        -: 5343:
function mkxtion called 28833 returned 100% blocks executed 86%
    28833: 5344:void mkxtion( statefrom, stateto )
        -: 5345:int statefrom, stateto;
        -: 5346:	{
    28833: 5347:	if ( trans1[statefrom] == NO_TRANSITION )
branch  0 taken 21419 (fallthrough)
branch  1 taken 7414
    21419: 5348:		trans1[statefrom] = stateto;
        -: 5349:
     7414: 5350:	else if ( (transchar[statefrom] != SYM_EPSILON) ||
branch  0 taken 7414 (fallthrough)
branch  1 taken 0
     7414: 5351:		  (trans2[statefrom] != NO_TRANSITION) )
branch  0 taken 0 (fallthrough)
branch  1 taken 7414
    #####: 5352:		flexfatal( "found too many transitions in mkxtion()" );
call    0 never executed
        -: 5353:
        -: 5354:	else
        -: 5355:		{ /* second out-transition for an epsilon state */
     7414: 5356:		++eps2;
     7414: 5357:		trans2[statefrom] = stateto;
        -: 5358:		}
    28833: 5359:	}
        -: 5360:
        -: 5361:/* new_rule - initialize for a new rule */
        -: 5362:
function new_rule called 3504 returned 100% blocks executed 88%
     3504: 5363:void new_rule()
        -: 5364:	{
     3504: 5365:	if ( ++num_rules >= current_max_rules )
branch  0 taken 2 (fallthrough)
branch  1 taken 3502
        -: 5366:		{
        2: 5367:		++num_reallocs;
        2: 5368:		current_max_rules += MAX_RULES_INCREMENT;
        2: 5369:		rule_type = reallocate_integer_array( rule_type,
call    0 returned 2
        -: 5370:							current_max_rules );
        2: 5371:		rule_linenum = reallocate_integer_array( rule_linenum,
call    0 returned 2
        -: 5372:							current_max_rules );
        2: 5373:		rule_useful = reallocate_integer_array( rule_useful,
call    0 returned 2
        -: 5374:							current_max_rules );
        -: 5375:		}
        -: 5376:
     3504: 5377:	if ( num_rules > MAX_RULE )
branch  0 taken 0 (fallthrough)
branch  1 taken 3504
    #####: 5378:		lerrif( "too many rules (> %d)!", MAX_RULE );
call    0 never executed
        -: 5379:
     3504: 5380:	rule_linenum[num_rules] = linenum;
     3504: 5381:	rule_useful[num_rules] = false;
     3504: 5382:	}
        -: 5383:/* File created from flex.skel via mkskel.sh */
        -: 5384:
        -: 5385:
        -: 5386:char *skel[] = {
        -: 5387:  "/* A lexical scanner generated by flex */",
        -: 5388:  "",
        -: 5389:  "/* Scanner skeleton version:",
        -: 5390:  " * $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.orig/v0/flex.c,v 1.1.1.1 2003/06/02 17:12:00 expsir Exp $",
        -: 5391:  " */",
        -: 5392:  "",
        -: 5393:  "#define FLEX_SCANNER",
        -: 5394:  "",
        -: 5395:  "%-",
        -: 5396:  "#include <stdio.h>",
        -: 5397:  "%*",
        -: 5398:  "",
        -: 5399:  "",
        -: 5400:  "/* cfront 1.2 defines \"c_plusplus\" instead of \"__cplusplus\" */",
        -: 5401:  "#ifdef c_plusplus",
        -: 5402:  "#ifndef __cplusplus",
        -: 5403:  "#define __cplusplus",
        -: 5404:  "#endif",
        -: 5405:  "#endif",
        -: 5406:  "",
        -: 5407:  "",
        -: 5408:  "#ifdef __cplusplus",
        -: 5409:  "",
        -: 5410:  "#include <stdlib.h>",
        -: 5411:  "%+",
        -: 5412:  "class istream;",
        -: 5413:  "%*",
        -: 5414:  "#include <unistd.h>",
        -: 5415:  "",
        -: 5416:  "/* Use prototypes in function declarations. */",
        -: 5417:  "#define YY_USE_PROTOS",
        -: 5418:  "",
        -: 5419:  "/* The \"const\" storage-class-modifier is valid. */",
        -: 5420:  "#define YY_USE_CONST",
        -: 5421:  "",
        -: 5422:  "#else	/* ! __cplusplus */",
        -: 5423:  "",
        -: 5424:  "#ifdef __STDC__",
        -: 5425:  "",
        -: 5426:  "#define YY_USE_PROTOS",
        -: 5427:  "#define YY_USE_CONST",
        -: 5428:  "",
        -: 5429:  "#endif	/* __STDC__ */",
        -: 5430:  "#endif	/* ! __cplusplus */",
        -: 5431:  "",
        -: 5432:  "",
        -: 5433:  "#ifdef __TURBOC__",
        -: 5434:  "#define YY_USE_CONST",
        -: 5435:  "#endif",
        -: 5436:  "",
        -: 5437:  "",
        -: 5438:  "#ifndef YY_USE_CONST",
        -: 5439:  "#ifndef const",
        -: 5440:  "#define const",
        -: 5441:  "#endif",
        -: 5442:  "#endif",
        -: 5443:  "",
        -: 5444:  "",
        -: 5445:  "#ifdef YY_USE_PROTOS",
        -: 5446:  "#define YY_PROTO(proto) proto",
        -: 5447:  "#else",
        -: 5448:  "#define YY_PROTO(proto) ()",
        -: 5449:  "#endif",
        -: 5450:  "",
        -: 5451:  "/* Returned upon end-of-file. */",
        -: 5452:  "#define YY_NULL 0",
        -: 5453:  "",
        -: 5454:  "/* Enter a start condition.  This macro really ought to take a parameter,",
        -: 5455:  " * but we do it the disgusting crufty way forced on us by the ()-less",
        -: 5456:  " * definition of BEGIN.",
        -: 5457:  " */",
        -: 5458:  "#define BEGIN yy_start = 1 + 2 *",
        -: 5459:  "",
        -: 5460:  "/* Translate the current start state into a value that can be later handed",
        -: 5461:  " * to BEGIN to return to the state.",
        -: 5462:  " */",
        -: 5463:  "#define YY_START ((yy_start - 1) / 2)",
        -: 5464:  "",
        -: 5465:  "/* Action number for EOF rule of a given start state. */",
        -: 5466:  "#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)",
        -: 5467:  "",
        -: 5468:  "/* Special action meaning \"start processing a new file\".  Now included",
        -: 5469:  " * only for backward compatibility with previous versions of flex.",
        -: 5470:  " */",
        -: 5471:  "#define YY_NEW_FILE yyrestart( yyin )",
        -: 5472:  "",
        -: 5473:  "#define YY_END_OF_BUFFER_CHAR 0",
        -: 5474:  "",
        -: 5475:  "/* Size of default input buffer. */",
        -: 5476:  "#define YY_BUF_SIZE 16384",
        -: 5477:  "",
        -: 5478:  "typedef struct yy_buffer_state *YY_BUFFER_STATE;",
        -: 5479:  "",
        -: 5480:  "extern int yyleng;",
        -: 5481:  "%-",
        -: 5482:  "extern FILE *yyin, *yyout;",
        -: 5483:  "%*",
        -: 5484:  "",
        -: 5485:  "#ifdef __cplusplus",
        -: 5486:  "extern \"C\" {",
        -: 5487:  "#endif",
        -: 5488:  "	extern void *yy_flex_alloc YY_PROTO(( int ));",
        -: 5489:  "	extern void *yy_flex_realloc YY_PROTO(( void *ptr, int size ));",
        -: 5490:  "	extern void yy_flex_free YY_PROTO(( void * ));",
        -: 5491:  "	extern int yywrap YY_PROTO(( void ));",
        -: 5492:  "	extern void yy_strcpy YY_PROTO(( char *s1, const char *s2 ));",
        -: 5493:  "#ifdef __cplusplus",
        -: 5494:  "	}",
        -: 5495:  "#endif",
        -: 5496:  "",
        -: 5497:  "#define EOB_ACT_CONTINUE_SCAN 0",
        -: 5498:  "#define EOB_ACT_END_OF_FILE 1",
        -: 5499:  "#define EOB_ACT_LAST_MATCH 2",
        -: 5500:  "",
        -: 5501:  "/* The funky do-while in the following #define is used to turn the definition",
        -: 5502:  " * int a single C statement (which needs a semi-colon terminator).  This",
        -: 5503:  " * avoids problems with code like:",
        -: 5504:  " *",
        -: 5505:  " * 	if ( condition_holds )",
        -: 5506:  " *		yyless( 5 );",
        -: 5507:  " *	else",
        -: 5508:  " *		do_something_else();",
        -: 5509:  " *",
        -: 5510:  " * Prior to using the do-while the compiler would get upset at the",
        -: 5511:  " * \"else\" because it interpreted the \"if\" statement as being all",
        -: 5512:  " * done when it reached the ';' after the yyless() call.",
        -: 5513:  " */",
        -: 5514:  "",
        -: 5515:  "/* Return all but the first 'n' matched characters back to the input stream. */",
        -: 5516:  "",
        -: 5517:  "#define yyless(n) \\",
        -: 5518:  "	do \\",
        -: 5519:  "		{ \\",
        -: 5520:  "		/* Undo effects of setting up yytext. */ \\",
        -: 5521:  "		*yy_cp = yy_hold_char; \\",
        -: 5522:  "		yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \\",
        -: 5523:  "		YY_DO_BEFORE_ACTION; /* set up yytext again */ \\",
        -: 5524:  "		} \\",
        -: 5525:  "	while ( 0 )",
        -: 5526:  "",
        -: 5527:  "#define unput(c) yyunput( c, yytext_ptr )",
        -: 5528:  "",
        -: 5529:  "",
        -: 5530:  "struct yy_buffer_state",
        -: 5531:  "	{",
        -: 5532:  "%-",
        -: 5533:  "	FILE *yy_input_file;",
        -: 5534:  "%+",
        -: 5535:  "	istream* yy_input_file;",
        -: 5536:  "%*",
        -: 5537:  "",
        -: 5538:  "	char *yy_ch_buf;		/* input buffer */",
        -: 5539:  "	char *yy_buf_pos;		/* current position in input buffer */",
        -: 5540:  "",
        -: 5541:  "	/* Size of input buffer in bytes, not including room for EOB",
        -: 5542:  "	 * characters.",
        -: 5543:  "	 */",
        -: 5544:  "	int yy_buf_size;",
        -: 5545:  "",
        -: 5546:  "	/* Number of characters read into yy_ch_buf, not including EOB",
        -: 5547:  "	 * characters.",
        -: 5548:  "	 */",
        -: 5549:  "	int yy_n_chars;",
        -: 5550:  "",
        -: 5551:  "	/* Whether this is an \"interactive\" input source; if so, and",
        -: 5552:  "	 * if we're using stdio for input, then we want to use getc()",
        -: 5553:  "	 * instead of fread(), to make sure we stop fetching input after",
        -: 5554:  "	 * each newline.",
        -: 5555:  "	 */",
        -: 5556:  "	int is_interactive;",
        -: 5557:  "",
        -: 5558:  "	/* Whether we've seen an EOF on this buffer. */",
        -: 5559:  "	int yy_eof_status;",
        -: 5560:  "#define EOF_NOT_SEEN 0",
        -: 5561:  "	/* \"Pending\" happens when the EOF has been seen but there's still",
        -: 5562:  "	 * some text to process.  Note that when we actually see the EOF,",
        -: 5563:  "	 * we switch the status back to \"not seen\" (via yyrestart()), so",
        -: 5564:  "	 * that the user can continue scanning by just pointing yyin at",
        -: 5565:  "	 * a new input file.",
        -: 5566:  "	 */",
        -: 5567:  "#define EOF_PENDING 1",
        -: 5568:  "	};",
        -: 5569:  "",
        -: 5570:  "%- Standard (non-C++) definition",
        -: 5571:  "static YY_BUFFER_STATE yy_current_buffer = 0;",
        -: 5572:  "%*",
        -: 5573:  "",
        -: 5574:  "/* We provide macros for accessing buffer states in case in the",
        -: 5575:  " * future we want to put the buffer states in a more general",
        -: 5576:  " * \"scanner state\".",
        -: 5577:  " */",
        -: 5578:  "#define YY_CURRENT_BUFFER yy_current_buffer",
        -: 5579:  "",
        -: 5580:  "",
        -: 5581:  "%- Standard (non-C++) definition",
        -: 5582:  "/* yy_hold_char holds the character lost when yytext is formed. */",
        -: 5583:  "static char yy_hold_char;",
        -: 5584:  "",
        -: 5585:  "static int yy_n_chars;		/* number of characters read into yy_ch_buf */",
        -: 5586:  "",
        -: 5587:  "",
        -: 5588:  "int yyleng;",
        -: 5589:  "",
        -: 5590:  "/* Points to current character in buffer. */",
        -: 5591:  "static char *yy_c_buf_p = (char *) 0;",
        -: 5592:  "static int yy_init = 1;		/* whether we need to initialize */",
        -: 5593:  "static int yy_start = 0;	/* start state number */",
        -: 5594:  "",
        -: 5595:  "/* Flag which is used to allow yywrap()'s to do buffer switches",
        -: 5596:  " * instead of setting up a fresh yyin.  A bit of a hack ...",
        -: 5597:  " */",
        -: 5598:  "static int yy_did_buffer_switch_on_eof;",
        -: 5599:  "",
        -: 5600:  "static void yyunput YY_PROTO(( int c, char *buf_ptr ));",
        -: 5601:  "void yyrestart YY_PROTO(( FILE *input_file ));",
        -: 5602:  "void yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));",
        -: 5603:  "void yy_load_buffer_state YY_PROTO(( void ));",
        -: 5604:  "YY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *file, int size ));",
        -: 5605:  "void yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));",
        -: 5606:  "void yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));",
        -: 5607:  "%*",
        -: 5608:  "",
        -: 5609:  "#define yy_new_buffer yy_create_buffer",
        -: 5610:  "",
        -: 5611:  "%% yytext/yyin/yyout/yy_state_type/yylineno etc. def's & init go here",
        -: 5612:  "",
        -: 5613:  "%- Standard (non-C++) definition",
        -: 5614:  "#ifdef __cplusplus",
        -: 5615:  "static int yyinput YY_PROTO(( void ));",
        -: 5616:  "#else",
        -: 5617:  "static int input YY_PROTO(( void ));",
        -: 5618:  "#endif",
        -: 5619:  "%*",
        -: 5620:  "",
        -: 5621:  "%- Standard (non-C++) definition",
        -: 5622:  "static yy_state_type yy_get_previous_state YY_PROTO(( void ));",
        -: 5623:  "static yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));",
        -: 5624:  "static int yy_get_next_buffer YY_PROTO(( void ));",
        -: 5625:  "%*",
        -: 5626:  "static void yy_fatal_error YY_PROTO(( const char msg[] ));",
        -: 5627:  "",
        -: 5628:  "/* Done after the current pattern has been matched and before the",
        -: 5629:  " * corresponding action - sets up yytext.",
        -: 5630:  " */",
        -: 5631:  "#define YY_DO_BEFORE_ACTION \\",
        -: 5632:  "	yytext_ptr = yy_bp; \\",
        -: 5633:  "%% code to fiddle yytext and yyleng for yymore() goes here",
        -: 5634:  "	yy_hold_char = *yy_cp; \\",
        -: 5635:  "	*yy_cp = '\\0'; \\",
        -: 5636:  "%% code to copy yytext_ptr to yytext[] goes here, if %array",
        -: 5637:  "	yy_c_buf_p = yy_cp;",
        -: 5638:  "",
        -: 5639:  "%% data tables for the DFA and the user's section 1 definitions go here",
        -: 5640:  "",
        -: 5641:  "/* Macros after this point can all be overridden by user definitions in",
        -: 5642:  " * section 1.",
        -: 5643:  " */",
        -: 5644:  "",
        -: 5645:  "/* Amount of stuff to slurp up with each read. */",
        -: 5646:  "#ifndef YY_READ_BUF_SIZE",
        -: 5647:  "#define YY_READ_BUF_SIZE 8192",
        -: 5648:  "#endif",
        -: 5649:  "",
        -: 5650:  "/* Copy whatever the last rule matched to the standard output. */",
        -: 5651:  "",
        -: 5652:  "#ifndef ECHO",
        -: 5653:  "%- Standard (non-C++) definition",
        -: 5654:  "/* This used to be an fputs(), but since the string might contain NUL's,",
        -: 5655:  " * we now use fwrite().",
        -: 5656:  " */",
        -: 5657:  "#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )",
        -: 5658:  "%+ C++ definition",
        -: 5659:  "#define ECHO LexerOutput( yytext, yyleng )",
        -: 5660:  "%*",
        -: 5661:  "#endif",
        -: 5662:  "",
        -: 5663:  "/* Gets input and stuffs it into \"buf\".  number of characters read, or YY_NULL,",
        -: 5664:  " * is returned in \"result\".",
        -: 5665:  " */",
        -: 5666:  "#ifndef YY_INPUT",
        -: 5667:  "#define YY_INPUT(buf,result,max_size) \\",
        -: 5668:  "%% fread()/read() definition of YY_INPUT goes here unless we're doing C++",
        -: 5669:  "%+ C++ definition",
        -: 5670:  "	if ( (result = LexerInput( (char *) buf, max_size )) < 0 ) \\",
        -: 5671:  "		YY_FATAL_ERROR( \"input in flex scanner failed\" );",
        -: 5672:  "%*",
        -: 5673:  "#endif",
        -: 5674:  "",
        -: 5675:  "/* No semi-colon after return; correct usage is to write \"yyterminate();\" -",
        -: 5676:  " * we don't want an extra ';' after the \"return\" because that will cause",
        -: 5677:  " * some compilers to complain about unreachable statements.",
        -: 5678:  " */",
        -: 5679:  "#ifndef yyterminate",
        -: 5680:  "#define yyterminate() return YY_NULL",
        -: 5681:  "#endif",
        -: 5682:  "",
        -: 5683:  "/* Report a fatal error. */",
        -: 5684:  "#ifndef YY_FATAL_ERROR",
        -: 5685:  "#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )",
        -: 5686:  "#endif",
        -: 5687:  "",
        -: 5688:  "/* Default declaration of generated scanner - a define so the user can",
        -: 5689:  " * easily add parameters.",
        -: 5690:  " */",
        -: 5691:  "#ifndef YY_DECL",
        -: 5692:  "%- Standard (non-C++) definition",
        -: 5693:  "#define YY_DECL int yylex YY_PROTO(( void ))",
        -: 5694:  "%+ C++ definition",
        -: 5695:  "#define YY_DECL int yyFlexLexer::yylex()",
        -: 5696:  "%*",
        -: 5697:  "#endif",
        -: 5698:  "",
        -: 5699:  "/* Code executed at the end of each rule. */",
        -: 5700:  "#ifndef YY_BREAK",
        -: 5701:  "#define YY_BREAK break;",
        -: 5702:  "#endif",
        -: 5703:  "",
        -: 5704:  "YY_DECL",
        -: 5705:  "	{",
        -: 5706:  "	register yy_state_type yy_current_state;",
        -: 5707:  "	register char *yy_cp, *yy_bp;",
        -: 5708:  "	register int yy_act;",
        -: 5709:  "",
        -: 5710:  "%% user's declarations go here",
        -: 5711:  "",
        -: 5712:  "	if ( yy_init )",
        -: 5713:  "		{",
        -: 5714:  "#ifdef YY_USER_INIT",
        -: 5715:  "		YY_USER_INIT;",
        -: 5716:  "#endif",
        -: 5717:  "",
        -: 5718:  "		if ( ! yy_start )",
        -: 5719:  "			yy_start = 1;	/* first start state */",
        -: 5720:  "",
        -: 5721:  "		if ( ! yyin )",
        -: 5722:  "%-",
        -: 5723:  "			yyin = stdin;",
        -: 5724:  "%+",
        -: 5725:  "			yyin = &cin;",
        -: 5726:  "%*",
        -: 5727:  "",
        -: 5728:  "		if ( ! yyout )",
        -: 5729:  "%-",
        -: 5730:  "			yyout = stdout;",
        -: 5731:  "%+",
        -: 5732:  "			yyout = &cout;",
        -: 5733:  "%*",
        -: 5734:  "",
        -: 5735:  "		if ( yy_current_buffer )",
        -: 5736:  "			yy_init_buffer( yy_current_buffer, yyin );",
        -: 5737:  "		else",
        -: 5738:  "			yy_current_buffer =",
        -: 5739:  "				yy_create_buffer( yyin, YY_BUF_SIZE );",
        -: 5740:  "",
        -: 5741:  "		yy_load_buffer_state();",
        -: 5742:  "",
        -: 5743:  "		yy_init = 0;",
        -: 5744:  "		}",
        -: 5745:  "",
        -: 5746:  "	while ( 1 )		/* loops until end-of-file is reached */",
        -: 5747:  "		{",
        -: 5748:  "%% yymore()-related code goes here",
        -: 5749:  "		yy_cp = yy_c_buf_p;",
        -: 5750:  "",
        -: 5751:  "		/* Support of yytext. */",
        -: 5752:  "		*yy_cp = yy_hold_char;",
        -: 5753:  "",
        -: 5754:  "		/* yy_bp points to the position in yy_ch_buf of the start of",
        -: 5755:  "		 * the current run.",
        -: 5756:  "		 */",
        -: 5757:  "		yy_bp = yy_cp;",
        -: 5758:  "",
        -: 5759:  "%% code to set up and find next match goes here",
        -: 5760:  "",
        -: 5761:  "yy_find_action:",
        -: 5762:  "%% code to find the action number goes here",
        -: 5763:  "",
        -: 5764:  "		YY_DO_BEFORE_ACTION;",
        -: 5765:  "",
        -: 5766:  "#ifdef YY_USER_ACTION",
        -: 5767:  "		if ( yy_act != YY_END_OF_BUFFER )",
        -: 5768:  "			{",
        -: 5769:  "			YY_USER_ACTION;",
        -: 5770:  "			}",
        -: 5771:  "#endif",
        -: 5772:  "",
        -: 5773:  "%% code for yylineno update goes here, if -l option",
        -: 5774:  "",
        -: 5775:  "do_action:	/* This label is used only to access EOF actions. */",
        -: 5776:  "",
        -: 5777:  "%% debug code goes here",
        -: 5778:  "",
        -: 5779:  "		switch ( yy_act )",
        -: 5780:  "	{ /* beginning of action switch */",
        -: 5781:  "%% actions go here",
        -: 5782:  "",
        -: 5783:  "	case YY_END_OF_BUFFER:",
        -: 5784:  "		{",
        -: 5785:  "		/* Amount of text matched not including the EOB char. */",
        -: 5786:  "		int yy_amount_of_matched_text = yy_cp - yytext_ptr - 1;",
        -: 5787:  "",
        -: 5788:  "		/* Undo the effects of YY_DO_BEFORE_ACTION. */",
        -: 5789:  "		*yy_cp = yy_hold_char;",
        -: 5790:  "",
        -: 5791:  "		/* Note that here we test for yy_c_buf_p \"<=\" to the position",
        -: 5792:  "		 * of the first EOB in the buffer, since yy_c_buf_p will",
        -: 5793:  "		 * already have been incremented past the NUL character",
        -: 5794:  "		 * (since all states make transitions on EOB to the",
        -: 5795:  "		 * end-of-buffer state).  Contrast this with the test",
        -: 5796:  "		 * in input().",
        -: 5797:  "		 */",
        -: 5798:  "		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )",
        -: 5799:  "			{ /* This was really a NUL. */",
        -: 5800:  "			yy_state_type yy_next_state;",
        -: 5801:  "",
        -: 5802:  "			yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;",
        -: 5803:  "",
        -: 5804:  "			yy_current_state = yy_get_previous_state();",
        -: 5805:  "",
        -: 5806:  "			/* Okay, we're now positioned to make the NUL",
        -: 5807:  "			 * transition.  We couldn't have",
        -: 5808:  "			 * yy_get_previous_state() go ahead and do it",
        -: 5809:  "			 * for us because it doesn't know how to deal",
        -: 5810:  "			 * with the possibility of jamming (and we don't",
        -: 5811:  "			 * want to build jamming into it because then it",
        -: 5812:  "			 * will run more slowly).",
        -: 5813:  "			 */",
        -: 5814:  "",
        -: 5815:  "			yy_next_state = yy_try_NUL_trans( yy_current_state );",
        -: 5816:  "",
        -: 5817:  "			yy_bp = yytext_ptr + YY_MORE_ADJ;",
        -: 5818:  "",
        -: 5819:  "			if ( yy_next_state )",
        -: 5820:  "				{",
        -: 5821:  "				/* Consume the NUL. */",
        -: 5822:  "				yy_cp = ++yy_c_buf_p;",
        -: 5823:  "				yy_current_state = yy_next_state;",
        -: 5824:  "				goto yy_match;",
        -: 5825:  "				}",
        -: 5826:  "",
        -: 5827:  "			else",
        -: 5828:  "				{",
        -: 5829:  "%% code to do back-up for compressed tables and set up yy_cp goes here",
        -: 5830:  "				goto yy_find_action;",
        -: 5831:  "				}",
        -: 5832:  "			}",
        -: 5833:  "",
        -: 5834:  "		else switch ( yy_get_next_buffer() )",
        -: 5835:  "			{",
        -: 5836:  "			case EOB_ACT_END_OF_FILE:",
        -: 5837:  "				{",
        -: 5838:  "				yy_did_buffer_switch_on_eof = 0;",
        -: 5839:  "",
        -: 5840:  "				if ( yywrap() )",
        -: 5841:  "					{",
        -: 5842:  "					/* Note: because we've taken care in",
        -: 5843:  "					 * yy_get_next_buffer() to have set up",
        -: 5844:  "					 * yytext, we can now set up",
        -: 5845:  "					 * yy_c_buf_p so that if some total",
        -: 5846:  "					 * hoser (like flex itself) wants to",
        -: 5847:  "					 * call the scanner after we return the",
        -: 5848:  "					 * YY_NULL, it'll still work - another",
        -: 5849:  "					 * YY_NULL will get returned.",
        -: 5850:  "					 */",
        -: 5851:  "					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;",
        -: 5852:  "",
        -: 5853:  "					yy_act = YY_STATE_EOF(YY_START);",
        -: 5854:  "					goto do_action;",
        -: 5855:  "					}",
        -: 5856:  "",
        -: 5857:  "				else",
        -: 5858:  "					{",
        -: 5859:  "					if ( ! yy_did_buffer_switch_on_eof )",
        -: 5860:  "						YY_NEW_FILE;",
        -: 5861:  "					}",
        -: 5862:  "				break;",
        -: 5863:  "				}",
        -: 5864:  "",
        -: 5865:  "			case EOB_ACT_CONTINUE_SCAN:",
        -: 5866:  "				yy_c_buf_p =",
        -: 5867:  "					yytext_ptr + yy_amount_of_matched_text;",
        -: 5868:  "",
        -: 5869:  "				yy_current_state = yy_get_previous_state();",
        -: 5870:  "",
        -: 5871:  "				yy_cp = yy_c_buf_p;",
        -: 5872:  "				yy_bp = yytext_ptr + YY_MORE_ADJ;",
        -: 5873:  "				goto yy_match;",
        -: 5874:  "",
        -: 5875:  "			case EOB_ACT_LAST_MATCH:",
        -: 5876:  "				yy_c_buf_p =",
        -: 5877:  "				&yy_current_buffer->yy_ch_buf[yy_n_chars];",
        -: 5878:  "",
        -: 5879:  "				yy_current_state = yy_get_previous_state();",
        -: 5880:  "",
        -: 5881:  "				yy_cp = yy_c_buf_p;",
        -: 5882:  "				yy_bp = yytext_ptr + YY_MORE_ADJ;",
        -: 5883:  "				goto yy_find_action;",
        -: 5884:  "			}",
        -: 5885:  "		break;",
        -: 5886:  "		}",
        -: 5887:  "",
        -: 5888:  "	default:",
        -: 5889:  "#ifdef FLEX_DEBUG",
        -: 5890:  "%-",
        -: 5891:  "		printf( \"action # %d\\n\", yy_act );",
        -: 5892:  "%+",
        -: 5893:  "		cout << \"action # \" << yy_act << '\\n';",
        -: 5894:  "%*",
        -: 5895:  "#endif",
        -: 5896:  "		YY_FATAL_ERROR(",
        -: 5897:  "			\"fatal flex scanner internal error--no action found\" );",
        -: 5898:  "	} /* end of action switch */",
        -: 5899:  "		} /* end of scanning one token */",
        -: 5900:  "	} /* end of yylex */",
        -: 5901:  "",
        -: 5902:  "%+",
        -: 5903:  "#ifdef YY_INTERACTIVE",
        -: 5904:  "int yyFlexLexer::LexerInput( char* buf, int /* max_size */ )",
        -: 5905:  "#else",
        -: 5906:  "int yyFlexLexer::LexerInput( char* buf, int max_size )",
        -: 5907:  "#endif",
        -: 5908:  "	{",
        -: 5909:  "	if ( yyin->eof() || yyin->fail() )",
        -: 5910:  "		return 0;",
        -: 5911:  "",
        -: 5912:  "#ifdef YY_INTERACTIVE",
        -: 5913:  "	yyin->get( buf[0] );",
        -: 5914:  "",
        -: 5915:  "	if ( yyin->eof() )",
        -: 5916:  "		return 0;",
        -: 5917:  "",
        -: 5918:  "	if ( yyin->bad() )",
        -: 5919:  "		return -1;",
        -: 5920:  "",
        -: 5921:  "	return 1;",
        -: 5922:  "",
        -: 5923:  "#else",
        -: 5924:  "	(void) yyin->read( buf, max_size );",
        -: 5925:  "",
        -: 5926:  "	if ( yyin->bad() )",
        -: 5927:  "		return -1;",
        -: 5928:  "	else",
        -: 5929:  "		return yyin->gcount();",
        -: 5930:  "#endif",
        -: 5931:  "	}",
        -: 5932:  "",
        -: 5933:  "void yyFlexLexer::LexerOutput( const char* buf, int size )",
        -: 5934:  "	{",
        -: 5935:  "	(void) yyout->write( buf, size );",
        -: 5936:  "	}",
        -: 5937:  "%*",
        -: 5938:  "",
        -: 5939:  "/* yy_get_next_buffer - try to read in a new buffer",
        -: 5940:  " *",
        -: 5941:  " * Returns a code representing an action:",
        -: 5942:  " *	EOB_ACT_LAST_MATCH -",
        -: 5943:  " *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position",
        -: 5944:  " *	EOB_ACT_END_OF_FILE - end of file",
        -: 5945:  " */",
        -: 5946:  "",
        -: 5947:  "%-",
        -: 5948:  "static int yy_get_next_buffer()",
        -: 5949:  "%+",
        -: 5950:  "int yyFlexLexer::yy_get_next_buffer()",
        -: 5951:  "%*",
        -: 5952:  "	{",
        -: 5953:  "	register char *dest = yy_current_buffer->yy_ch_buf;",
        -: 5954:  "	register char *source = yytext_ptr - 1; /* copy prev. char, too */",
        -: 5955:  "	register int number_to_move, i;",
        -: 5956:  "	int ret_val;",
        -: 5957:  "",
        -: 5958:  "	if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )",
        -: 5959:  "		YY_FATAL_ERROR(",
        -: 5960:  "		\"fatal flex scanner internal error--end of buffer missed\" );",
        -: 5961:  "",
        -: 5962:  "	/* Try to read more data. */",
        -: 5963:  "",
        -: 5964:  "	/* First move last chars to start of buffer. */",
        -: 5965:  "	number_to_move = yy_c_buf_p - yytext_ptr;",
        -: 5966:  "",
        -: 5967:  "	for ( i = 0; i < number_to_move; ++i )",
        -: 5968:  "		*(dest++) = *(source++);",
        -: 5969:  "",
        -: 5970:  "	if ( yy_current_buffer->yy_eof_status != EOF_NOT_SEEN )",
        -: 5971:  "		/* don't do the read, it's not guaranteed to return an EOF,",
        -: 5972:  "		 * just force an EOF",
        -: 5973:  "		 */",
        -: 5974:  "		yy_n_chars = 0;",
        -: 5975:  "",
        -: 5976:  "	else",
        -: 5977:  "		{",
        -: 5978:  "		int num_to_read =",
        -: 5979:  "			yy_current_buffer->yy_buf_size - number_to_move - 1;",
        -: 5980:  "",
        -: 5981:  "		while ( num_to_read <= 0 )",
        -: 5982:  "			{ /* Not enough room in the buffer - grow it. */",
        -: 5983:  "#ifdef YY_USES_REJECT",
        -: 5984:  "			YY_FATAL_ERROR(",
        -: 5985:  "\"input buffer overflow, can't enlarge buffer because scanner uses REJECT\" );",
        -: 5986:  "#else",
        -: 5987:  "",
        -: 5988:  "			/* just a shorter name for the current buffer */",
        -: 5989:  "			YY_BUFFER_STATE b = yy_current_buffer;",
        -: 5990:  "",
        -: 5991:  "			int yy_c_buf_p_offset = yy_c_buf_p - b->yy_ch_buf;",
        -: 5992:  "",
        -: 5993:  "			b->yy_buf_size *= 2;",
        -: 5994:  "			b->yy_ch_buf = (char *)",
        -: 5995:  "				yy_flex_realloc( (void *) b->yy_ch_buf,",
        -: 5996:  "						 b->yy_buf_size );",
        -: 5997:  "",
        -: 5998:  "			if ( ! b->yy_ch_buf )",
        -: 5999:  "				YY_FATAL_ERROR(",
        -: 6000:  "				\"fatal error - scanner input buffer overflow\" );",
        -: 6001:  "",
        -: 6002:  "			yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];",
        -: 6003:  "",
        -: 6004:  "			num_to_read = yy_current_buffer->yy_buf_size -",
        -: 6005:  "						number_to_move - 1;",
        -: 6006:  "#endif",
        -: 6007:  "			}",
        -: 6008:  "",
        -: 6009:  "		if ( num_to_read > YY_READ_BUF_SIZE )",
        -: 6010:  "			num_to_read = YY_READ_BUF_SIZE;",
        -: 6011:  "",
        -: 6012:  "		/* Read in more data. */",
        -: 6013:  "		YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),",
        -: 6014:  "			yy_n_chars, num_to_read );",
        -: 6015:  "		}",
        -: 6016:  "",
        -: 6017:  "	if ( yy_n_chars == 0 )",
        -: 6018:  "		{",
        -: 6019:  "		if ( number_to_move - YY_MORE_ADJ == 1 )",
        -: 6020:  "			{",
        -: 6021:  "			ret_val = EOB_ACT_END_OF_FILE;",
        -: 6022:  "			yyrestart( yyin );",
        -: 6023:  "			}",
        -: 6024:  "",
        -: 6025:  "		else",
        -: 6026:  "			{",
        -: 6027:  "			ret_val = EOB_ACT_LAST_MATCH;",
        -: 6028:  "			yy_current_buffer->yy_eof_status = EOF_PENDING;",
        -: 6029:  "			}",
        -: 6030:  "		}",
        -: 6031:  "",
        -: 6032:  "	else",
        -: 6033:  "		ret_val = EOB_ACT_CONTINUE_SCAN;",
        -: 6034:  "",
        -: 6035:  "	yy_n_chars += number_to_move;",
        -: 6036:  "	yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;",
        -: 6037:  "	yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;",
        -: 6038:  "",
        -: 6039:  "	/* yytext begins at the second character in yy_ch_buf; the first",
        -: 6040:  "	 * character is the one which preceded it before reading in the latest",
        -: 6041:  "	 * buffer; it needs to be kept around in case it's a newline, so",
        -: 6042:  "	 * yy_get_previous_state() will have with '^' rules active.",
        -: 6043:  "	 */",
        -: 6044:  "",
        -: 6045:  "	yytext_ptr = &yy_current_buffer->yy_ch_buf[1];",
        -: 6046:  "",
        -: 6047:  "	return ret_val;",
        -: 6048:  "	}",
        -: 6049:  "",
        -: 6050:  "",
        -: 6051:  "/* yy_get_previous_state - get the state just before the EOB char was reached */",
        -: 6052:  "",
        -: 6053:  "%-",
        -: 6054:  "static yy_state_type yy_get_previous_state()",
        -: 6055:  "%+",
        -: 6056:  "yy_state_type yyFlexLexer::yy_get_previous_state()",
        -: 6057:  "%*",
        -: 6058:  "	{",
        -: 6059:  "	register yy_state_type yy_current_state;",
        -: 6060:  "	register char *yy_cp;",
        -: 6061:  "",
        -: 6062:  "%% code to get the start state into yy_current_state goes here",
        -: 6063:  "",
        -: 6064:  "	for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )",
        -: 6065:  "		{",
        -: 6066:  "%% code to find the next state goes here",
        -: 6067:  "		}",
        -: 6068:  "",
        -: 6069:  "	return yy_current_state;",
        -: 6070:  "	}",
        -: 6071:  "",
        -: 6072:  "",
        -: 6073:  "/* yy_try_NUL_trans - try to make a transition on the NUL character",
        -: 6074:  " *",
        -: 6075:  " * synopsis",
        -: 6076:  " *	next_state = yy_try_NUL_trans( current_state );",
        -: 6077:  " */",
        -: 6078:  "",
        -: 6079:  "%-",
        -: 6080:  "#ifdef YY_USE_PROTOS",
        -: 6081:  "static yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )",
        -: 6082:  "#else",
        -: 6083:  "static yy_state_type yy_try_NUL_trans( yy_current_state )",
        -: 6084:  "yy_state_type yy_current_state;",
        -: 6085:  "#endif",
        -: 6086:  "%+",
        -: 6087:  "yy_state_type yyFlexLexer::yy_try_NUL_trans( yy_state_type yy_current_state )",
        -: 6088:  "%*",
        -: 6089:  "	{",
        -: 6090:  "	register int yy_is_jam;",
        -: 6091:  "%% code to find the next state, and perhaps do backing up, goes here",
        -: 6092:  "",
        -: 6093:  "	return yy_is_jam ? 0 : yy_current_state;",
        -: 6094:  "	}",
        -: 6095:  "",
        -: 6096:  "",
        -: 6097:  "%-",
        -: 6098:  "#ifdef YY_USE_PROTOS",
        -: 6099:  "static void yyunput( int c, register char *yy_bp )",
        -: 6100:  "#else",
        -: 6101:  "static void yyunput( c, yy_bp )",
        -: 6102:  "int c;",
        -: 6103:  "register char *yy_bp;",
        -: 6104:  "#endif",
        -: 6105:  "%+",
        -: 6106:  "void yyFlexLexer::yyunput( int c, register char* yy_bp )",
        -: 6107:  "%*",
        -: 6108:  "	{",
        -: 6109:  "	register char *yy_cp = yy_c_buf_p;",
        -: 6110:  "",
        -: 6111:  "	/* undo effects of setting up yytext */",
        -: 6112:  "	*yy_cp = yy_hold_char;",
        -: 6113:  "",
        -: 6114:  "	if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )",
        -: 6115:  "		{ /* need to shift things up to make room */",
        -: 6116:  "		/* +2 for EOB chars. */",
        -: 6117:  "		register int number_to_move = yy_n_chars + 2;",
        -: 6118:  "		register char *dest = &yy_current_buffer->yy_ch_buf[",
        -: 6119:  "					yy_current_buffer->yy_buf_size + 2];",
        -: 6120:  "		register char *source =",
        -: 6121:  "				&yy_current_buffer->yy_ch_buf[number_to_move];",
        -: 6122:  "",
        -: 6123:  "		while ( source > yy_current_buffer->yy_ch_buf )",
        -: 6124:  "			*--dest = *--source;",
        -: 6125:  "",
        -: 6126:  "		yy_cp += dest - source;",
        -: 6127:  "		yy_bp += dest - source;",
        -: 6128:  "		yy_n_chars = yy_current_buffer->yy_buf_size;",
        -: 6129:  "",
        -: 6130:  "		if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )",
        -: 6131:  "			YY_FATAL_ERROR( \"flex scanner push-back overflow\" );",
        -: 6132:  "		}",
        -: 6133:  "",
        -: 6134:  "	if ( yy_cp > yy_bp && yy_cp[-1] == '\\n' )",
        -: 6135:  "		yy_cp[-2] = '\\n';",
        -: 6136:  "",
        -: 6137:  "	*--yy_cp = (char) c;",
        -: 6138:  "",
        -: 6139:  "%% update yylineno here, if doing -l",
        -: 6140:  "",
        -: 6141:  "	/* Note: the formal parameter *must* be called \"yy_bp\" for this",
        -: 6142:  "	 * macro to now work correctly.",
        -: 6143:  "	 */",
        -: 6144:  "	YY_DO_BEFORE_ACTION; /* set up yytext again */",
        -: 6145:  "	}",
        -: 6146:  "",
        -: 6147:  "",
        -: 6148:  "%-",
        -: 6149:  "#ifdef __cplusplus",
        -: 6150:  "static int yyinput()",
        -: 6151:  "#else",
        -: 6152:  "static int input()",
        -: 6153:  "#endif",
        -: 6154:  "%+",
        -: 6155:  "int yyFlexLexer::yyinput()",
        -: 6156:  "%*",
        -: 6157:  "	{",
        -: 6158:  "	int c;",
        -: 6159:  "",
        -: 6160:  "	*yy_c_buf_p = yy_hold_char;",
        -: 6161:  "",
        -: 6162:  "	if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )",
        -: 6163:  "		{",
        -: 6164:  "		/* yy_c_buf_p now points to the character we want to return.",
        -: 6165:  "		 * If this occurs *before* the EOB characters, then it's a",
        -: 6166:  "		 * valid NUL; if not, then we've hit the end of the buffer.",
        -: 6167:  "		 */",
        -: 6168:  "		if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )",
        -: 6169:  "			/* This was really a NUL. */",
        -: 6170:  "			*yy_c_buf_p = '\\0';",
        -: 6171:  "",
        -: 6172:  "		else",
        -: 6173:  "			{ /* need more input */",
        -: 6174:  "			yytext_ptr = yy_c_buf_p;",
        -: 6175:  "			++yy_c_buf_p;",
        -: 6176:  "",
        -: 6177:  "			switch ( yy_get_next_buffer() )",
        -: 6178:  "				{",
        -: 6179:  "				case EOB_ACT_END_OF_FILE:",
        -: 6180:  "					{",
        -: 6181:  "					if ( yywrap() )",
        -: 6182:  "						{",
        -: 6183:  "						yy_c_buf_p =",
        -: 6184:  "						yytext_ptr + YY_MORE_ADJ;",
        -: 6185:  "						return EOF;",
        -: 6186:  "						}",
        -: 6187:  "",
        -: 6188:  "					YY_NEW_FILE;",
        -: 6189:  "#ifdef __cplusplus",
        -: 6190:  "					return yyinput();",
        -: 6191:  "#else",
        -: 6192:  "					return input();",
        -: 6193:  "#endif",
        -: 6194:  "					}",
        -: 6195:  "",
        -: 6196:  "				case EOB_ACT_CONTINUE_SCAN:",
        -: 6197:  "					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;",
        -: 6198:  "					break;",
        -: 6199:  "",
        -: 6200:  "				case EOB_ACT_LAST_MATCH:",
        -: 6201:  "#ifdef __cplusplus",
        -: 6202:  "					YY_FATAL_ERROR(",
        -: 6203:  "					\"unexpected last match in yyinput()\" );",
        -: 6204:  "#else",
        -: 6205:  "					YY_FATAL_ERROR(",
        -: 6206:  "					\"unexpected last match in input()\" );",
        -: 6207:  "#endif",
        -: 6208:  "				}",
        -: 6209:  "			}",
        -: 6210:  "		}",
        -: 6211:  "",
        -: 6212:  "	c = *yy_c_buf_p;",
        -: 6213:  "	*yy_c_buf_p = '\\0';	/* preserve yytext */",
        -: 6214:  "	yy_hold_char = *++yy_c_buf_p;",
        -: 6215:  "",
        -: 6216:  "	return c;",
        -: 6217:  "	}",
        -: 6218:  "",
        -: 6219:  "",
        -: 6220:  "%-",
        -: 6221:  "#ifdef YY_USE_PROTOS",
        -: 6222:  "void yyrestart( FILE *input_file )",
        -: 6223:  "#else",
        -: 6224:  "void yyrestart( input_file )",
        -: 6225:  "FILE *input_file;",
        -: 6226:  "#endif",
        -: 6227:  "%+",
        -: 6228:  "void yyFlexLexer::yyrestart( istream* input_file )",
        -: 6229:  "%*",
        -: 6230:  "	{",
        -: 6231:  "	if ( ! yy_current_buffer )",
        -: 6232:  "		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );",
        -: 6233:  "",
        -: 6234:  "	yy_init_buffer( yy_current_buffer, input_file );",
        -: 6235:  "	yy_load_buffer_state();",
        -: 6236:  "	}",
        -: 6237:  "",
        -: 6238:  "",
        -: 6239:  "%-",
        -: 6240:  "#ifdef YY_USE_PROTOS",
        -: 6241:  "void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )",
        -: 6242:  "#else",
        -: 6243:  "void yy_switch_to_buffer( new_buffer )",
        -: 6244:  "YY_BUFFER_STATE new_buffer;",
        -: 6245:  "#endif",
        -: 6246:  "%+",
        -: 6247:  "void yyFlexLexer::yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )",
        -: 6248:  "%*",
        -: 6249:  "	{",
        -: 6250:  "	if ( yy_current_buffer == new_buffer )",
        -: 6251:  "		return;",
        -: 6252:  "",
        -: 6253:  "	if ( yy_current_buffer )",
        -: 6254:  "		{",
        -: 6255:  "		/* Flush out information for old buffer. */",
        -: 6256:  "		*yy_c_buf_p = yy_hold_char;",
        -: 6257:  "		yy_current_buffer->yy_buf_pos = yy_c_buf_p;",
        -: 6258:  "		yy_current_buffer->yy_n_chars = yy_n_chars;",
        -: 6259:  "		}",
        -: 6260:  "",
        -: 6261:  "	yy_current_buffer = new_buffer;",
        -: 6262:  "	yy_load_buffer_state();",
        -: 6263:  "",
        -: 6264:  "	/* We don't actually know whether we did this switch during",
        -: 6265:  "	 * EOF (yywrap()) processing, but the only time this flag",
        -: 6266:  "	 * is looked at is after yywrap() is called, so it's safe",
        -: 6267:  "	 * to go ahead and always set it.",
        -: 6268:  "	 */",
        -: 6269:  "	yy_did_buffer_switch_on_eof = 1;",
        -: 6270:  "	}",
        -: 6271:  "",
        -: 6272:  "",
        -: 6273:  "%-",
        -: 6274:  "#ifdef YY_USE_PROTOS",
        -: 6275:  "void yy_load_buffer_state( void )",
        -: 6276:  "#else",
        -: 6277:  "void yy_load_buffer_state()",
        -: 6278:  "#endif",
        -: 6279:  "%+",
        -: 6280:  "void yyFlexLexer::yy_load_buffer_state()",
        -: 6281:  "%*",
        -: 6282:  "	{",
        -: 6283:  "	yy_n_chars = yy_current_buffer->yy_n_chars;",
        -: 6284:  "	yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;",
        -: 6285:  "	yyin = yy_current_buffer->yy_input_file;",
        -: 6286:  "	yy_hold_char = *yy_c_buf_p;",
        -: 6287:  "	}",
        -: 6288:  "",
        -: 6289:  "",
        -: 6290:  "%-",
        -: 6291:  "#ifdef YY_USE_PROTOS",
        -: 6292:  "YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )",
        -: 6293:  "#else",
        -: 6294:  "YY_BUFFER_STATE yy_create_buffer( file, size )",
        -: 6295:  "FILE *file;",
        -: 6296:  "int size;",
        -: 6297:  "#endif",
        -: 6298:  "%+",
        -: 6299:  "YY_BUFFER_STATE yyFlexLexer::yy_create_buffer( istream* file, int size )",
        -: 6300:  "%*",
        -: 6301:  "	{",
        -: 6302:  "	YY_BUFFER_STATE b;",
        -: 6303:  "",
        -: 6304:  "	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );",
        -: 6305:  "",
        -: 6306:  "	if ( ! b )",
        -: 6307:  "		YY_FATAL_ERROR( \"out of dynamic memory in yy_create_buffer()\" );",
        -: 6308:  "",
        -: 6309:  "	b->yy_buf_size = size;",
        -: 6310:  "",
        -: 6311:  "	/* yy_ch_buf has to be 2 characters longer than the size given because",
        -: 6312:  "	 * we need to put in 2 end-of-buffer characters.",
        -: 6313:  "	 */",
        -: 6314:  "	b->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );",
        -: 6315:  "",
        -: 6316:  "	if ( ! b->yy_ch_buf )",
        -: 6317:  "		YY_FATAL_ERROR( \"out of dynamic memory in yy_create_buffer()\" );",
        -: 6318:  "",
        -: 6319:  "	yy_init_buffer( b, file );",
        -: 6320:  "",
        -: 6321:  "	return b;",
        -: 6322:  "	}",
        -: 6323:  "",
        -: 6324:  "",
        -: 6325:  "%-",
        -: 6326:  "#ifdef YY_USE_PROTOS",
        -: 6327:  "void yy_delete_buffer( YY_BUFFER_STATE b )",
        -: 6328:  "#else",
        -: 6329:  "void yy_delete_buffer( b )",
        -: 6330:  "YY_BUFFER_STATE b;",
        -: 6331:  "#endif",
        -: 6332:  "%+",
        -: 6333:  "void yyFlexLexer::yy_delete_buffer( YY_BUFFER_STATE b )",
        -: 6334:  "%*",
        -: 6335:  "	{",
        -: 6336:  "	if ( b == yy_current_buffer )",
        -: 6337:  "		yy_current_buffer = (YY_BUFFER_STATE) 0;",
        -: 6338:  "",
        -: 6339:  "	yy_flex_free( (void *) b->yy_ch_buf );",
        -: 6340:  "	yy_flex_free( (void *) b );",
        -: 6341:  "	}",
        -: 6342:  "",
        -: 6343:  "",
        -: 6344:  "%-",
        -: 6345:  "#ifdef YY_USE_PROTOS",
        -: 6346:  "void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )",
        -: 6347:  "#else",
        -: 6348:  "void yy_init_buffer( b, file )",
        -: 6349:  "YY_BUFFER_STATE b;",
        -: 6350:  "FILE *file;",
        -: 6351:  "#endif",
        -: 6352:  "%+",
        -: 6353:  "void yyFlexLexer::yy_init_buffer( YY_BUFFER_STATE b, istream* file )",
        -: 6354:  "%*",
        -: 6355:  "	{",
        -: 6356:  "	b->yy_input_file = file;",
        -: 6357:  "",
        -: 6358:  "	/* We put in the '\\n' and start reading from [1] so that an",
        -: 6359:  "	 * initial match-at-newline will be true.",
        -: 6360:  "	 */",
        -: 6361:  "",
        -: 6362:  "	b->yy_ch_buf[0] = '\\n';",
        -: 6363:  "	b->yy_n_chars = 1;",
        -: 6364:  "",
        -: 6365:  "	/* We always need two end-of-buffer characters.  The first causes",
        -: 6366:  "	 * a transition to the end-of-buffer state.  The second causes",
        -: 6367:  "	 * a jam in that state.",
        -: 6368:  "	 */",
        -: 6369:  "	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;",
        -: 6370:  "	b->yy_ch_buf[2] = YY_END_OF_BUFFER_CHAR;",
        -: 6371:  "",
        -: 6372:  "	b->yy_buf_pos = &b->yy_ch_buf[1];",
        -: 6373:  "",
        -: 6374:  "%-",
        -: 6375:  "	b->is_interactive = file ? isatty( fileno(file) ) : 0;",
        -: 6376:  "%+",
        -: 6377:  "	b->is_interactive = 0;",
        -: 6378:  "%*",
        -: 6379:  "",
        -: 6380:  "	b->yy_eof_status = EOF_NOT_SEEN;",
        -: 6381:  "	}",
        -: 6382:  "",
        -: 6383:  "",
        -: 6384:  "#ifdef YY_USE_PROTOS",
        -: 6385:  "static void yy_fatal_error( const char msg[] )",
        -: 6386:  "#else",
        -: 6387:  "static void yy_fatal_error( msg )",
        -: 6388:  "char msg[];",
        -: 6389:  "#endif",
        -: 6390:  "	{",
        -: 6391:  "%-",
        -: 6392:  "FILE *err;",  /* ### modified(Jan.24.2001) ### */
        -: 6393:  "	(void) fprintf( err, \"%s\\n\", msg );",
        -: 6394:  "%+",
        -: 6395:  "	cerr << msg << '\\n';",
        -: 6396:  "%*",
        -: 6397:  "	exit( 1 );",
        -: 6398:  "	}",
        -: 6399:  "",
        -: 6400:  "",
        -: 6401:  "/* Redefine yyless() so it works in section 3 code. */",
        -: 6402:  "",
        -: 6403:  "#undef yyless",
        -: 6404:  "#define yyless(n) \\",
        -: 6405:  "	do \\",
        -: 6406:  "		{ \\",
        -: 6407:  "		/* Undo effects of setting up yytext. */ \\",
        -: 6408:  "		yytext[yyleng] = yy_hold_char; \\",
        -: 6409:  "		yy_c_buf_p = yytext + n - YY_MORE_ADJ; \\",
        -: 6410:  "		yy_hold_char = *yy_c_buf_p; \\",
        -: 6411:  "		*yy_c_buf_p = '\\0'; \\",
        -: 6412:  "		yyleng = n; \\",
        -: 6413:  "		} \\",
        -: 6414:  "	while ( 0 )",
        -: 6415:  0
        -: 6416:};
        -: 6417:/* sym - symbol table routines */
        -: 6418:
        -: 6419:/*-
        -: 6420: * Copyright (c) 1990 The Regents of the University of California.
        -: 6421: * All rights reserved.
        -: 6422: *
        -: 6423: * This code is derived from software contributed to Berkeley by
        -: 6424: * Vern Paxson.
        -: 6425: * 
        -: 6426: * The United States Government has rights in this work pursuant
        -: 6427: * to contract no. DE-AC03-76SF00098 between the United States
        -: 6428: * Department of Energy and the University of California.
        -: 6429: *
        -: 6430: * Redistribution and use in source and binary forms are permitted provided
        -: 6431: * that: (1) source distributions retain this entire copyright notice and
        -: 6432: * comment, and (2) distributions including binaries display the following
        -: 6433: * acknowledgement:  ``This product includes software developed by the
        -: 6434: * University of California, Berkeley and its contributors'' in the
        -: 6435: * documentation or other materials provided with the distribution and in
        -: 6436: * all advertising materials mentioning features or use of this software.
        -: 6437: * Neither the name of the University nor the names of its contributors may
        -: 6438: * be used to endorse or promote products derived from this software without
        -: 6439: * specific prior written permission.
        -: 6440: * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
        -: 6441: * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
        -: 6442: * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
        -: 6443: */
        -: 6444:
        -: 6445:/* $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.orig/v0/flex.c,v 1.1.1.1 2003/06/02 17:12:00 expsir Exp $ */
        -: 6446:
        -: 6447:
        -: 6448:
        -: 6449:/* declare functions that have forward references */
        -: 6450:
        -: 6451:int hashfunct PROTO((register char[], int));
        -: 6452:
        -: 6453:
        -: 6454:struct hash_entry *ndtbl[NAME_TABLE_HASH_SIZE];
        -: 6455:struct hash_entry *sctbl[START_COND_HASH_SIZE];
        -: 6456:struct hash_entry *ccltab[CCL_HASH_SIZE];
        -: 6457:
        -: 6458:struct hash_entry *findsym();
        -: 6459:
        -: 6460:
        -: 6461:/* addsym - add symbol and definitions to symbol table
        -: 6462: *
        -: 6463: * -1 is returned if the symbol already exists, and the change not made.
        -: 6464: */
        -: 6465:
function addsym called 2070 returned 100% blocks executed 93%
     2070: 6466:int addsym( sym, str_def, int_def, table, table_size )
        -: 6467:register char sym[];
        -: 6468:char *str_def;
        -: 6469:int int_def;
        -: 6470:hash_table table;
        -: 6471:int table_size;
        -: 6472:	{
     2070: 6473:	int hash_val = hashfunct( sym, table_size );
call    0 returned 2070
     2070: 6474:	register struct hash_entry *sym_entry = table[hash_val];
        -: 6475:	register struct hash_entry *new_entry;
        -: 6476:	register struct hash_entry *successor;
        -: 6477:
     2298: 6478:	while ( sym_entry )
branch  0 taken 229
branch  1 taken 2069 (fallthrough)
        -: 6479:		{
      229: 6480:		if ( ! yy_strcmp( sym, sym_entry->name ) )
call    0 returned 229
branch  1 taken 1 (fallthrough)
branch  2 taken 228
        -: 6481:			{ /* entry already exists */
        1: 6482:			return -1;
        -: 6483:			}
        -: 6484:
      228: 6485:		sym_entry = sym_entry->next;
        -: 6486:		}
        -: 6487:
        -: 6488:	/* create new entry */
        -: 6489:	new_entry = (struct hash_entry *)
     2069: 6490:		yy_flex_alloc( sizeof( struct hash_entry ) );
call    0 returned 2069
        -: 6491:
     2069: 6492:	if ( new_entry == NULL )
branch  0 taken 0 (fallthrough)
branch  1 taken 2069
    #####: 6493:		flexfatal( "symbol table memory allocation failed" );
call    0 never executed
        -: 6494:
     2069: 6495:	if ( (successor = table[hash_val]) )
branch  0 taken 130 (fallthrough)
branch  1 taken 1939
        -: 6496:		{
      130: 6497:		new_entry->next = successor;
      130: 6498:		successor->prev = new_entry;
        -: 6499:		}
        -: 6500:	else
     1939: 6501:		new_entry->next = NULL;
        -: 6502:
     2069: 6503:	new_entry->prev = NULL;
     2069: 6504:	new_entry->name = sym;
     2069: 6505:	new_entry->str_val = str_def;
     2069: 6506:	new_entry->int_val = int_def;
        -: 6507:
     2069: 6508:	table[hash_val] = new_entry;
        -: 6509:
     2069: 6510:	return 0;
        -: 6511:	}
        -: 6512:
        -: 6513:
        -: 6514:/* cclinstal - save the text of a character class */
        -: 6515:
function cclinstal called 1273 returned 100% blocks executed 100%
     1273: 6516:void cclinstal( ccltxt, cclnum )
        -: 6517:Char ccltxt[];
        -: 6518:int cclnum;
        -: 6519:	{
        -: 6520:	/* We don't bother checking the return status because we are not
        -: 6521:	 * called unless the symbol is new.
        -: 6522:	 */
        -: 6523:	Char *copy_unsigned_string();
        -: 6524:
     1273: 6525:	(void) addsym( (char *) copy_unsigned_string( ccltxt ),
call    0 returned 1273
call    1 returned 1273
        -: 6526:			(char *) 0, cclnum,
        -: 6527:			ccltab, CCL_HASH_SIZE );
     1273: 6528:	}
        -: 6529:
        -: 6530:
        -: 6531:/* ccllookup - lookup the number associated with character class text
        -: 6532: *
        -: 6533: * Returns 0 if there's no CCL associated with the text.
        -: 6534: */
        -: 6535:
function ccllookup called 1495 returned 100% blocks executed 100%
     1495: 6536:int ccllookup( ccltxt )
        -: 6537:Char ccltxt[];
        -: 6538:	{
     1495: 6539:	return findsym( (char *) ccltxt, ccltab, CCL_HASH_SIZE )->int_val;
call    0 returned 1495
        -: 6540:	}
        -: 6541:
        -: 6542:
        -: 6543:/* findsym - find symbol in symbol table */
        -: 6544:
function findsym called 1954 returned 100% blocks executed 100%
     1954: 6545:struct hash_entry *findsym( sym, table, table_size )
        -: 6546:register char sym[];
        -: 6547:hash_table table;
        -: 6548:int table_size;
        -: 6549:	{
        -: 6550:	static struct hash_entry empty_entry =
        -: 6551:		{
        -: 6552:		(struct hash_entry *) 0, (struct hash_entry *) 0,
        -: 6553:		(char *) 0, (char *) 0, 0,
        -: 6554:		} ;
     1954: 6555:	register struct hash_entry *sym_entry =
     1954: 6556:		table[hashfunct( sym, table_size )];
call    0 returned 1954
        -: 6557:
     2182: 6558:	while ( sym_entry )
branch  0 taken 905
branch  1 taken 1277 (fallthrough)
        -: 6559:		{
      905: 6560:		if ( ! yy_strcmp( sym, sym_entry->name ) )
call    0 returned 905
branch  1 taken 677 (fallthrough)
branch  2 taken 228
      677: 6561:			return sym_entry;
      228: 6562:		sym_entry = sym_entry->next;
        -: 6563:		}
        -: 6564:
     1277: 6565:	return &empty_entry;
        -: 6566:	}
        -: 6567:
        -: 6568:    
        -: 6569:/* hashfunct - compute the hash value for "str" and hash size "hash_size" */
        -: 6570:
function hashfunct called 4024 returned 100% blocks executed 100%
     4024: 6571:int hashfunct( str, hash_size )
        -: 6572:register char str[];
        -: 6573:int hash_size;
        -: 6574:	{
        -: 6575:	register int hashval;
        -: 6576:	register int locstr;
        -: 6577:
     4024: 6578:	hashval = 0;
     4024: 6579:	locstr = 0;
        -: 6580:
    25565: 6581:	while ( str[locstr] )
branch  0 taken 21541
branch  1 taken 4024 (fallthrough)
        -: 6582:		{
    21541: 6583:		hashval = (hashval << 1) + (unsigned char) str[locstr++];
    21541: 6584:		hashval %= hash_size;
        -: 6585:		}
        -: 6586:
     4024: 6587:	return hashval;
        -: 6588:	}
        -: 6589:
        -: 6590:
        -: 6591:/* ndinstal - install a name definition */
        -: 6592:
function ndinstal called 235 returned 100% blocks executed 100%
      235: 6593:void ndinstal( name, definition )
        -: 6594:char name[];
        -: 6595:Char definition[];
        -: 6596:	{
        -: 6597:	char *copy_string();
        -: 6598:	Char *copy_unsigned_string();
        -: 6599:
      235: 6600:	if ( addsym( copy_string( name ),
call    0 returned 235
call    1 returned 235
branch  2 taken 1 (fallthrough)
branch  3 taken 234
      235: 6601:			(char *) copy_unsigned_string( definition ), 0,
call    0 returned 235
        -: 6602:			ndtbl, NAME_TABLE_HASH_SIZE ) )
        1: 6603:		synerr( "name defined twice" );
call    0 returned 1
      235: 6604:	}
        -: 6605:
        -: 6606:
        -: 6607:/* ndlookup - lookup a name definition
        -: 6608: *
        -: 6609: * Returns a nil pointer if the name definition does not exist.
        -: 6610: */
        -: 6611:
function ndlookup called 449 returned 100% blocks executed 100%
      449: 6612:Char *ndlookup( nd )
        -: 6613:char nd[];
        -: 6614:	{
      449: 6615:	return (Char *) findsym( nd, ndtbl, NAME_TABLE_HASH_SIZE )->str_val;
call    0 returned 449
        -: 6616:	}
        -: 6617:
        -: 6618:
        -: 6619:/* scextend - increase the maximum number of start conditions */
        -: 6620:
function scextend called 0 returned 0% blocks executed 0%
    #####: 6621:void scextend()
        -: 6622:	{
    #####: 6623:	current_max_scs += MAX_SCS_INCREMENT;
        -: 6624:
    #####: 6625:	++num_reallocs;
        -: 6626:
    #####: 6627:	scset = reallocate_integer_array( scset, current_max_scs );
call    0 never executed
    #####: 6628:	scbol = reallocate_integer_array( scbol, current_max_scs );
call    0 never executed
    #####: 6629:	scxclu = reallocate_integer_array( scxclu, current_max_scs );
call    0 never executed
    #####: 6630:	sceof = reallocate_integer_array( sceof, current_max_scs );
call    0 never executed
    #####: 6631:	scname = reallocate_char_ptr_array( scname, current_max_scs );
call    0 never executed
    #####: 6632:	actvsc = reallocate_integer_array( actvsc, current_max_scs );
call    0 never executed
    #####: 6633:	}
        -: 6634:
        -: 6635:
        -: 6636:/* scinstal - make a start condition
        -: 6637: *
        -: 6638: * NOTE
        -: 6639: *    The start condition is "exclusive" if xcluflg is true.
        -: 6640: */
        -: 6641:
function scinstal called 562 returned 100% blocks executed 80%
      562: 6642:void scinstal( str, xcluflg )
        -: 6643:char str[];
        -: 6644:int xcluflg;
        -: 6645:	{
        -: 6646:	char *copy_string();
        -: 6647:
        -: 6648:	/* Generate start condition definition, for use in BEGIN et al. */
      562: 6649:	printf( "#define %s %d\n", str, lastsc );
call    0 returned 562
        -: 6650:
      562: 6651:	if ( ++lastsc >= current_max_scs )
branch  0 taken 0 (fallthrough)
branch  1 taken 562
    #####: 6652:		scextend();
call    0 never executed
        -: 6653:
      562: 6654:	scname[lastsc] = copy_string( str );
call    0 returned 562
        -: 6655:
      562: 6656:	if ( addsym( scname[lastsc], (char *) 0, lastsc,
call    0 returned 562
branch  1 taken 0 (fallthrough)
branch  2 taken 562
        -: 6657:			sctbl, START_COND_HASH_SIZE ) )
    #####: 6658:		format_pinpoint_message( "start condition %s declared twice",
call    0 never executed
        -: 6659:					str );
        -: 6660:
      562: 6661:	scset[lastsc] = mkstate( SYM_EPSILON );
call    0 returned 562
      562: 6662:	scbol[lastsc] = mkstate( SYM_EPSILON );
call    0 returned 562
      562: 6663:	scxclu[lastsc] = xcluflg;
      562: 6664:	sceof[lastsc] = false;
      562: 6665:	}
        -: 6666:
        -: 6667:
        -: 6668:/* sclookup - lookup the number associated with a start condition
        -: 6669: *
        -: 6670: * Returns 0 if no such start condition.
        -: 6671: */
        -: 6672:
function sclookup called 10 returned 100% blocks executed 100%
       10: 6673:int sclookup( str )
        -: 6674:char str[];
        -: 6675:	{
       10: 6676:	return findsym( str, sctbl, START_COND_HASH_SIZE )->int_val;
call    0 returned 10
        -: 6677:	}
        -: 6678:/* tblcmp - table compression routines */
        -: 6679:
        -: 6680:/*-
        -: 6681: * Copyright (c) 1990 The Regents of the University of California.
        -: 6682: * All rights reserved.
        -: 6683: *
        -: 6684: * This code is derived from software contributed to Berkeley by
        -: 6685: * Vern Paxson.
        -: 6686: * 
        -: 6687: * The United States Government has rights in this work pursuant
        -: 6688: * to contract no. DE-AC03-76SF00098 between the United States
        -: 6689: * Department of Energy and the University of California.
        -: 6690: *
        -: 6691: * Redistribution and use in source and binary forms are permitted provided
        -: 6692: * that: (1) source distributions retain this entire copyright notice and
        -: 6693: * comment, and (2) distributions including binaries display the following
        -: 6694: * acknowledgement:  ``This product includes software developed by the
        -: 6695: * University of California, Berkeley and its contributors'' in the
        -: 6696: * documentation or other materials provided with the distribution and in
        -: 6697: * all advertising materials mentioning features or use of this software.
        -: 6698: * Neither the name of the University nor the names of its contributors may
        -: 6699: * be used to endorse or promote products derived from this software without
        -: 6700: * specific prior written permission.
        -: 6701: * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
        -: 6702: * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
        -: 6703: * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
        -: 6704: */
        -: 6705:
        -: 6706:/* $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.orig/v0/flex.c,v 1.1.1.1 2003/06/02 17:12:00 expsir Exp $ */
        -: 6707:
        -: 6708:
        -: 6709:
        -: 6710:/* declarations for functions that have forward references */
        -: 6711:
        -: 6712:void mkentry PROTO((register int*, int, int, int, int));
        -: 6713:void mkprot PROTO((int[], int, int));
        -: 6714:void mktemplate PROTO((int[], int, int));
        -: 6715:void mv2front PROTO((int));
        -: 6716:int tbldiff PROTO((int[], int, int[]));
        -: 6717:
        -: 6718:
        -: 6719:/* bldtbl - build table entries for dfa state
        -: 6720: *
        -: 6721: * synopsis
        -: 6722: *   int state[numecs], statenum, totaltrans, comstate, comfreq;
        -: 6723: *   bldtbl( state, statenum, totaltrans, comstate, comfreq );
        -: 6724: *
        -: 6725: * State is the statenum'th dfa state.  It is indexed by equivalence class and
        -: 6726: * gives the number of the state to enter for a given equivalence class.
        -: 6727: * totaltrans is the total number of transitions out of the state.  Comstate
        -: 6728: * is that state which is the destination of the most transitions out of State.
        -: 6729: * Comfreq is how many transitions there are out of State to Comstate.
        -: 6730: *
        -: 6731: * A note on terminology:
        -: 6732: *    "protos" are transition tables which have a high probability of
        -: 6733: * either being redundant (a state processed later will have an identical
        -: 6734: * transition table) or nearly redundant (a state processed later will have
        -: 6735: * many of the same out-transitions).  A "most recently used" queue of
        -: 6736: * protos is kept around with the hope that most states will find a proto
        -: 6737: * which is similar enough to be usable, and therefore compacting the
        -: 6738: * output tables.
        -: 6739: *    "templates" are a special type of proto.  If a transition table is
        -: 6740: * homogeneous or nearly homogeneous (all transitions go to the same
        -: 6741: * destination) then the odds are good that future states will also go
        -: 6742: * to the same destination state on basically the same character set.
        -: 6743: * These homogeneous states are so common when dealing with large rule
        -: 6744: * sets that they merit special attention.  If the transition table were
        -: 6745: * simply made into a proto, then (typically) each subsequent, similar
        -: 6746: * state will differ from the proto for two out-transitions.  One of these
        -: 6747: * out-transitions will be that character on which the proto does not go
        -: 6748: * to the common destination, and one will be that character on which the
        -: 6749: * state does not go to the common destination.  Templates, on the other
        -: 6750: * hand, go to the common state on EVERY transition character, and therefore
        -: 6751: * cost only one difference.
        -: 6752: */
        -: 6753:
function bldtbl called 9668 returned 100% blocks executed 100%
     9668: 6754:void bldtbl( state, statenum, totaltrans, comstate, comfreq )
        -: 6755:int state[], statenum, totaltrans, comstate, comfreq;
        -: 6756:	{
        -: 6757:	int extptr, extrct[2][CSIZE + 1];
        -: 6758:	int mindiff, minprot, i, d;
        -: 6759:
        -: 6760:	/* If extptr is 0 then the first array of extrct holds the result
        -: 6761:	 * of the "best difference" to date, which is those transitions
        -: 6762:	 * which occur in "state" but not in the proto which, to date,
        -: 6763:	 * has the fewest differences between itself and "state".  If
        -: 6764:	 * extptr is 1 then the second array of extrct hold the best
        -: 6765:	 * difference.  The two arrays are toggled between so that the
        -: 6766:	 * best difference to date can be kept around and also a difference
        -: 6767:	 * just created by checking against a candidate "best" proto.
        -: 6768:	 */
        -: 6769:
     9668: 6770:	extptr = 0;
        -: 6771:
        -: 6772:	/* If the state has too few out-transitions, don't bother trying to
        -: 6773:	 * compact its tables.
        -: 6774:	 */
        -: 6775:
     9668: 6776:	if ( (totaltrans * 100) < (numecs * PROTO_SIZE_PERCENTAGE) )
branch  0 taken 6774 (fallthrough)
branch  1 taken 2894
     6774: 6777:		mkentry( state, numecs, statenum, JAMSTATE, totaltrans );
call    0 returned 6774
        -: 6778:
        -: 6779:	else
        -: 6780:		{
        -: 6781:		/* "checkcom" is true if we should only check "state" against
        -: 6782:		 * protos which have the same "comstate" value.
        -: 6783:		 */
     2894: 6784:		int checkcom =
     2894: 6785:			comfreq * 100 > totaltrans * CHECK_COM_PERCENTAGE;
        -: 6786:
     2894: 6787:		minprot = firstprot;
     2894: 6788:		mindiff = totaltrans;
        -: 6789:
     2894: 6790:		if ( checkcom )
branch  0 taken 2475 (fallthrough)
branch  1 taken 419
        -: 6791:			{
        -: 6792:			/* Find first proto which has the same "comstate". */
     3580: 6793:			for ( i = firstprot; i != NIL; i = protnext[i] )
branch  0 taken 2916
branch  1 taken 664 (fallthrough)
     2916: 6794:				if ( protcomst[i] == comstate )
branch  0 taken 1811 (fallthrough)
branch  1 taken 1105
        -: 6795:					{
     1811: 6796:					minprot = i;
     1811: 6797:					mindiff = tbldiff( state, minprot,
     1811: 6798:							extrct[extptr] );
call    0 returned 1811
     1811: 6799:					break;
        -: 6800:					}
        -: 6801:			}
        -: 6802:
        -: 6803:		else
        -: 6804:			{
        -: 6805:			/* Since we've decided that the most common destination
        -: 6806:			 * out of "state" does not occur with a high enough
        -: 6807:			 * frequency, we set the "comstate" to zero, assuring
        -: 6808:			 * that if this state is entered into the proto list,
        -: 6809:			 * it will not be considered a template.
        -: 6810:			 */
      419: 6811:			comstate = 0;
        -: 6812:
      419: 6813:			if ( firstprot != NIL )
branch  0 taken 277 (fallthrough)
branch  1 taken 142
        -: 6814:				{
      277: 6815:				minprot = firstprot;
      277: 6816:				mindiff = tbldiff( state, minprot,
      277: 6817:						extrct[extptr] );
call    0 returned 277
        -: 6818:				}
        -: 6819:			}
        -: 6820:
        -: 6821:		/* We now have the first interesting proto in "minprot".  If
        -: 6822:		 * it matches within the tolerances set for the first proto,
        -: 6823:		 * we don't want to bother scanning the rest of the proto list
        -: 6824:		 * to see if we have any other reasonable matches.
        -: 6825:		 */
        -: 6826:
     2894: 6827:		if ( mindiff * 100 > totaltrans * FIRST_MATCH_DIFF_PERCENTAGE )
branch  0 taken 1042 (fallthrough)
branch  1 taken 1852
        -: 6828:			{
        -: 6829:			/* Not a good enough match.  Scan the rest of the
        -: 6830:			 * protos.
        -: 6831:			 */
     2291: 6832:			for ( i = minprot; i != NIL; i = protnext[i] )
branch  0 taken 1249
branch  1 taken 1042 (fallthrough)
        -: 6833:				{
     1249: 6834:				d = tbldiff( state, i, extrct[1 - extptr] );
call    0 returned 1249
     1249: 6835:				if ( d < mindiff )
branch  0 taken 2 (fallthrough)
branch  1 taken 1247
        -: 6836:					{
        2: 6837:					extptr = 1 - extptr;
        2: 6838:					mindiff = d;
        2: 6839:					minprot = i;
        -: 6840:					}
        -: 6841:				}
        -: 6842:			}
        -: 6843:
        -: 6844:		/* Check if the proto we've decided on as our best bet is close
        -: 6845:		 * enough to the state we want to match to be usable.
        -: 6846:		 */
        -: 6847:
     2894: 6848:		if ( mindiff * 100 > totaltrans * ACCEPTABLE_DIFF_PERCENTAGE )
branch  0 taken 853 (fallthrough)
branch  1 taken 2041
        -: 6849:			{
        -: 6850:			/* No good.  If the state is homogeneous enough,
        -: 6851:			 * we make a template out of it.  Otherwise, we
        -: 6852:			 * make a proto.
        -: 6853:			 */
        -: 6854:
      853: 6855:			if ( comfreq * 100 >=
      853: 6856:			     totaltrans * TEMPLATE_SAME_PERCENTAGE )
branch  0 taken 622 (fallthrough)
branch  1 taken 231
      622: 6857:				mktemplate( state, statenum, comstate );
call    0 returned 622
        -: 6858:
        -: 6859:			else
        -: 6860:				{
      231: 6861:				mkprot( state, statenum, comstate );
call    0 returned 231
      231: 6862:				mkentry( state, numecs, statenum,
call    0 returned 231
        -: 6863:					JAMSTATE, totaltrans );
        -: 6864:				}
        -: 6865:			}
        -: 6866:
        -: 6867:		else
        -: 6868:			{ /* use the proto */
     2041: 6869:			mkentry( extrct[extptr], numecs, statenum,
call    0 returned 2041
        -: 6870:				prottbl[minprot], mindiff );
        -: 6871:
        -: 6872:			/* If this state was sufficiently different from the
        -: 6873:			 * proto we built it from, make it, too, a proto.
        -: 6874:			 */
        -: 6875:
     2041: 6876:			if ( mindiff * 100 >=
     2041: 6877:			     totaltrans * NEW_PROTO_DIFF_PERCENTAGE )
branch  0 taken 109 (fallthrough)
branch  1 taken 1932
      109: 6878:				mkprot( state, statenum, comstate );
call    0 returned 109
        -: 6879:
        -: 6880:			/* Since mkprot added a new proto to the proto queue,
        -: 6881:			 * it's possible that "minprot" is no longer on the
        -: 6882:			 * proto queue (if it happened to have been the last
        -: 6883:			 * entry, it would have been bumped off).  If it's
        -: 6884:			 * not there, then the new proto took its physical
        -: 6885:			 * place (though logically the new proto is at the
        -: 6886:			 * beginning of the queue), so in that case the
        -: 6887:			 * following call will do nothing.
        -: 6888:			 */
        -: 6889:
     2041: 6890:			mv2front( minprot );
call    0 returned 2041
        -: 6891:			}
        -: 6892:		}
     9668: 6893:	}
        -: 6894:
        -: 6895:
        -: 6896:/* cmptmps - compress template table entries
        -: 6897: *
        -: 6898: * Template tables are compressed by using the 'template equivalence
        -: 6899: * classes', which are collections of transition character equivalence
        -: 6900: * classes which always appear together in templates - really meta-equivalence
        -: 6901: * classes.
        -: 6902: */
        -: 6903:
function cmptmps called 426 returned 100% blocks executed 95%
      426: 6904:void cmptmps()
        -: 6905:	{
        -: 6906:	int tmpstorage[CSIZE + 1];
      426: 6907:	register int *tmp = tmpstorage, i, j;
        -: 6908:	int totaltrans, trans;
        -: 6909:
      426: 6910:	peakpairs = numtemps * numecs + tblend;
        -: 6911:
      426: 6912:	if ( usemecs )
branch  0 taken 212 (fallthrough)
branch  1 taken 214
        -: 6913:		{
        -: 6914:		/* Create equivalence classes based on data gathered on
        -: 6915:		 * template transitions.
        -: 6916:		 */
      212: 6917:		nummecs = cre8ecs( tecfwd, tecbck, numecs );
call    0 returned 212
        -: 6918:		}
        -: 6919:
        -: 6920:	else
      214: 6921:		nummecs = numecs;
        -: 6922:
      426: 6923:	while ( lastdfa + numtemps + 1 >= current_max_dfas )
branch  0 taken 0
branch  1 taken 426 (fallthrough)
    #####: 6924:		increase_max_dfas();
call    0 never executed
        -: 6925:
        -: 6926:	/* Loop through each template. */
        -: 6927:
     1048: 6928:	for ( i = 1; i <= numtemps; ++i )
branch  0 taken 622
branch  1 taken 426 (fallthrough)
        -: 6929:		{
        -: 6930:		/* Number of non-jam transitions out of this template. */
      622: 6931:		totaltrans = 0;
        -: 6932:
    58547: 6933:		for ( j = 1; j <= numecs; ++j )
branch  0 taken 57925
branch  1 taken 622 (fallthrough)
        -: 6934:			{
    57925: 6935:			trans = tnxt[numecs * i + j];
        -: 6936:
    57925: 6937:			if ( usemecs )
branch  0 taken 27176 (fallthrough)
branch  1 taken 30749
        -: 6938:				{
        -: 6939:				/* The absolute value of tecbck is the
        -: 6940:				 * meta-equivalence class of a given
        -: 6941:				 * equivalence class, as set up by cre8ecs().
        -: 6942:				 */
    27176: 6943:				if ( tecbck[j] > 0 )
branch  0 taken 936 (fallthrough)
branch  1 taken 26240
        -: 6944:					{
      936: 6945:					tmp[tecbck[j]] = trans;
        -: 6946:
      936: 6947:					if ( trans > 0 )
branch  0 taken 439 (fallthrough)
branch  1 taken 497
      439: 6948:						++totaltrans;
        -: 6949:					}
        -: 6950:				}
        -: 6951:
        -: 6952:			else
        -: 6953:				{
    30749: 6954:				tmp[j] = trans;
        -: 6955:
    30749: 6956:				if ( trans > 0 )
branch  0 taken 29563 (fallthrough)
branch  1 taken 1186
    29563: 6957:					++totaltrans;
        -: 6958:				}
        -: 6959:			}
        -: 6960:
        -: 6961:		/* It is assumed (in a rather subtle way) in the skeleton
        -: 6962:		 * that if we're using meta-equivalence classes, the def[]
        -: 6963:		 * entry for all templates is the jam template, i.e.,
        -: 6964:		 * templates never default to other non-jam table entries
        -: 6965:		 * (e.g., another template)
        -: 6966:		 */
        -: 6967:
        -: 6968:		/* Leave room for the jam-state after the last real state. */
      622: 6969:		mkentry( tmp, nummecs, lastdfa + i + 1, JAMSTATE, totaltrans );
call    0 returned 622
        -: 6970:		}
      426: 6971:	}
        -: 6972:
        -: 6973:
        -: 6974:
        -: 6975:/* expand_nxt_chk - expand the next check arrays */
        -: 6976:
function expand_nxt_chk called 28 returned 100% blocks executed 100%
       28: 6977:void expand_nxt_chk()
        -: 6978:	{
       28: 6979:	register int old_max = current_max_xpairs;
        -: 6980:
       28: 6981:	current_max_xpairs += MAX_XPAIRS_INCREMENT;
        -: 6982:
       28: 6983:	++num_reallocs;
        -: 6984:
       28: 6985:	nxt = reallocate_integer_array( nxt, current_max_xpairs );
call    0 returned 28
       28: 6986:	chk = reallocate_integer_array( chk, current_max_xpairs );
call    0 returned 28
        -: 6987:
       28: 6988:	zero_out( (char *) (chk + old_max),
call    0 returned 28
        -: 6989:		MAX_XPAIRS_INCREMENT * sizeof( int ) / sizeof( char ) );
       28: 6990:	}
        -: 6991:
        -: 6992:
        -: 6993:/* find_table_space - finds a space in the table for a state to be placed
        -: 6994: *
        -: 6995: * synopsis
        -: 6996: *     int *state, numtrans, block_start;
        -: 6997: *     int find_table_space();
        -: 6998: *
        -: 6999: *     block_start = find_table_space( state, numtrans );
        -: 7000: *
        -: 7001: * State is the state to be added to the full speed transition table.
        -: 7002: * Numtrans is the number of out-transitions for the state.
        -: 7003: *
        -: 7004: * find_table_space() returns the position of the start of the first block (in
        -: 7005: * chk) able to accommodate the state
        -: 7006: *
        -: 7007: * In determining if a state will or will not fit, find_table_space() must take
        -: 7008: * into account the fact that an end-of-buffer state will be added at [0],
        -: 7009: * and an action number will be added in [-1].
        -: 7010: */
        -: 7011:
function find_table_space called 2262 returned 100% blocks executed 93%
     2262: 7012:int find_table_space( state, numtrans )
        -: 7013:int *state, numtrans;
        -: 7014:	{
        -: 7015:	/* Firstfree is the position of the first possible occurrence of two
        -: 7016:	 * consecutive unused records in the chk and nxt arrays.
        -: 7017:	 */
        -: 7018:	register int i;
        -: 7019:	register int *state_ptr, *chk_ptr;
        -: 7020:	register int *ptr_to_last_entry_in_state;
        -: 7021:
        -: 7022:	/* If there are too many out-transitions, put the state at the end of
        -: 7023:	 * nxt and chk.
        -: 7024:	 */
     2262: 7025:	if ( numtrans > MAX_XTIONS_FULL_INTERIOR_FIT )
branch  0 taken 764 (fallthrough)
branch  1 taken 1498
        -: 7026:		{
        -: 7027:		/* If table is empty, return the first available spot in
        -: 7028:		 * chk/nxt, which should be 1.
        -: 7029:		 */
      764: 7030:		if ( tblend < 2 )
branch  0 taken 0 (fallthrough)
branch  1 taken 764
    #####: 7031:			return 1;
        -: 7032:
        -: 7033:		/* Start searching for table space near the end of
        -: 7034:		 * chk/nxt arrays.
        -: 7035:		 */
      764: 7036:		i = tblend - numecs;
        -: 7037:		}
        -: 7038:
        -: 7039:	else
        -: 7040:		/* Start searching for table space from the beginning
        -: 7041:		 * (skipping only the elements which will definitely not
        -: 7042:		 * hold the new state).
        -: 7043:		 */
     1498: 7044:		i = firstfree;
        -: 7045:
        -: 7046:	while ( 1 )	/* loops until a space is found */
        -: 7047:		{
    14707: 7048:		while ( i + numecs >= current_max_xpairs )
branch  0 taken 0
branch  1 taken 14707 (fallthrough)
    #####: 7049:			expand_nxt_chk();
call    0 never executed
        -: 7050:
        -: 7051:		/* Loops until space for end-of-buffer and action number
        -: 7052:		 * are found.
        -: 7053:		 */
        -: 7054:		while ( 1 )
        -: 7055:			{
        -: 7056:			/* Check for action number space. */
    58555: 7057:			if ( chk[i - 1] == 0 )
branch  0 taken 15749 (fallthrough)
branch  1 taken 42806
        -: 7058:				{
        -: 7059:				/* Check for end-of-buffer space. */
    15749: 7060:				if ( chk[i] == 0 )
branch  0 taken 14707 (fallthrough)
branch  1 taken 1042
    14707: 7061:					break;
        -: 7062:
        -: 7063:				else
        -: 7064:					/* Since i != 0, there is no use
        -: 7065:					 * checking to see if (++i) - 1 == 0,
        -: 7066:					 * because that's the same as i == 0,
        -: 7067:					 * so we skip a space.
        -: 7068:					 */
     1042: 7069:					i += 2;
        -: 7070:				}
        -: 7071:
        -: 7072:			else
    42806: 7073:				++i;
        -: 7074:
    43858: 7075:			while ( i + numecs >= current_max_xpairs )
branch  0 taken 10
branch  1 taken 43848 (fallthrough)
       10: 7076:				expand_nxt_chk();
call    0 returned 10
        -: 7077:			}
        -: 7078:
        -: 7079:		/* If we started search from the beginning, store the new
        -: 7080:		 * firstfree for the next call of find_table_space().
        -: 7081:		 */
    14707: 7082:		if ( numtrans <= MAX_XTIONS_FULL_INTERIOR_FIT )
branch  0 taken 2239 (fallthrough)
branch  1 taken 12468
     2239: 7083:			firstfree = i + 1;
        -: 7084:
        -: 7085:		/* Check to see if all elements in chk (and therefore nxt)
        -: 7086:		 * that are needed for the new state have not yet been taken.
        -: 7087:		 */
        -: 7088:
    14707: 7089:		state_ptr = &state[1];
    14707: 7090:		ptr_to_last_entry_in_state = &chk[i + numecs + 1];
        -: 7091:
    14707: 7092:		for ( chk_ptr = &chk[i + 1];
   788801: 7093:		      chk_ptr != ptr_to_last_entry_in_state; ++chk_ptr )
branch  0 taken 786539
branch  1 taken 2262 (fallthrough)
   786539: 7094:			if ( *(state_ptr++) != 0 && *chk_ptr != 0 )
branch  0 taken 100036 (fallthrough)
branch  1 taken 686503
branch  2 taken 12445 (fallthrough)
branch  3 taken 87591
    12445: 7095:				break;
        -: 7096:
    14707: 7097:		if ( chk_ptr == ptr_to_last_entry_in_state )
branch  0 taken 2262 (fallthrough)
branch  1 taken 12445
     2262: 7098:			return i;
        -: 7099:
        -: 7100:		else
    12445: 7101:		++i;
        -: 7102:		}
        -: 7103:	}
        -: 7104:
        -: 7105:
        -: 7106:/* inittbl - initialize transition tables
        -: 7107: *
        -: 7108: * Initializes "firstfree" to be one beyond the end of the table.  Initializes
        -: 7109: * all "chk" entries to be zero.
        -: 7110: */
function inittbl called 541 returned 100% blocks executed 100%
      541: 7111:void inittbl()
        -: 7112:	{
        -: 7113:	register int i;
        -: 7114:
      541: 7115:	zero_out( (char *) chk,
call    0 returned 541
        -: 7116:		current_max_xpairs * sizeof( int ) / sizeof( char ) );
        -: 7117:
      541: 7118:	tblend = 0;
      541: 7119:	firstfree = tblend + 1;
      541: 7120:	numtemps = 0;
        -: 7121:
      541: 7122:	if ( usemecs )
branch  0 taken 212 (fallthrough)
branch  1 taken 329
        -: 7123:		{
        -: 7124:		/* Set up doubly-linked meta-equivalence classes; these
        -: 7125:		 * are sets of equivalence classes which all have identical
        -: 7126:		 * transitions out of TEMPLATES.
        -: 7127:		 */
        -: 7128:
      212: 7129:		tecbck[1] = NIL;
        -: 7130:
    22229: 7131:		for ( i = 2; i <= numecs; ++i )
branch  0 taken 22017
branch  1 taken 212 (fallthrough)
        -: 7132:			{
    22017: 7133:			tecbck[i] = i - 1;
    22017: 7134:			tecfwd[i - 1] = i;
        -: 7135:			}
        -: 7136:
      212: 7137:		tecfwd[numecs] = NIL;
        -: 7138:		}
      541: 7139:	}
        -: 7140:
        -: 7141:
        -: 7142:/* mkdeftbl - make the default, "jam" table entries */
        -: 7143:
function mkdeftbl called 426 returned 100% blocks executed 100%
      426: 7144:void mkdeftbl()
        -: 7145:	{
        -: 7146:	int i;
        -: 7147:
      426: 7148:	jamstate = lastdfa + 1;
        -: 7149:
      426: 7150:	++tblend; /* room for transition on end-of-buffer character */
        -: 7151:
      444: 7152:	while ( tblend + numecs >= current_max_xpairs )
branch  0 taken 18
branch  1 taken 426 (fallthrough)
       18: 7153:		expand_nxt_chk();
call    0 returned 18
        -: 7154:
        -: 7155:	/* Add in default end-of-buffer transition. */
      426: 7156:	nxt[tblend] = end_of_buffer_state;
      426: 7157:	chk[tblend] = jamstate;
        -: 7158:
    48399: 7159:	for ( i = 1; i <= numecs; ++i )
branch  0 taken 47973
branch  1 taken 426 (fallthrough)
        -: 7160:		{
    47973: 7161:		nxt[tblend + i] = 0;
    47973: 7162:		chk[tblend + i] = jamstate;
        -: 7163:		}
        -: 7164:
      426: 7165:	jambase = tblend;
        -: 7166:
      426: 7167:	base[jamstate] = jambase;
      426: 7168:	def[jamstate] = 0;
        -: 7169:
      426: 7170:	tblend += numecs;
      426: 7171:	++numtemps;
      426: 7172:	}
        -: 7173:
        -: 7174:
        -: 7175:/* mkentry - create base/def and nxt/chk entries for transition array
        -: 7176: *
        -: 7177: * synopsis
        -: 7178: *   int state[numchars + 1], numchars, statenum, deflink, totaltrans;
        -: 7179: *   mkentry( state, numchars, statenum, deflink, totaltrans );
        -: 7180: *
        -: 7181: * "state" is a transition array "numchars" characters in size, "statenum"
        -: 7182: * is the offset to be used into the base/def tables, and "deflink" is the
        -: 7183: * entry to put in the "def" table entry.  If "deflink" is equal to
        -: 7184: * "JAMSTATE", then no attempt will be made to fit zero entries of "state"
        -: 7185: * (i.e., jam entries) into the table.  It is assumed that by linking to
        -: 7186: * "JAMSTATE" they will be taken care of.  In any case, entries in "state"
        -: 7187: * marking transitions to "SAME_TRANS" are treated as though they will be
        -: 7188: * taken care of by whereever "deflink" points.  "totaltrans" is the total
        -: 7189: * number of transitions out of the state.  If it is below a certain threshold,
        -: 7190: * the tables are searched for an interior spot that will accommodate the
        -: 7191: * state array.
        -: 7192: */
        -: 7193:
function mkentry called 10290 returned 100% blocks executed 95%
    10290: 7194:void mkentry( state, numchars, statenum, deflink, totaltrans )
        -: 7195:register int *state;
        -: 7196:int numchars, statenum, deflink, totaltrans;
        -: 7197:	{
        -: 7198:	register int minec, maxec, i, baseaddr;
        -: 7199:	int tblbase, tbllast;
        -: 7200:
    10290: 7201:	if ( totaltrans == 0 )
branch  0 taken 2544 (fallthrough)
branch  1 taken 7746
        -: 7202:		{ /* there are no out-transitions */
     2544: 7203:		if ( deflink == JAMSTATE )
branch  0 taken 1925 (fallthrough)
branch  1 taken 619
     1925: 7204:			base[statenum] = JAMSTATE;
        -: 7205:		else
      619: 7206:			base[statenum] = 0;
        -: 7207:
     2544: 7208:		def[statenum] = deflink;
     2544: 7209:		return;
        -: 7210:		}
        -: 7211:
   280522: 7212:	for ( minec = 1; minec <= numchars; ++minec )
branch  0 taken 280522
branch  1 taken 0 (fallthrough)
        -: 7213:		{
   280522: 7214:		if ( state[minec] != SAME_TRANS )
branch  0 taken 229972 (fallthrough)
branch  1 taken 50550
   229972: 7215:			if ( state[minec] != 0 || deflink != JAMSTATE )
branch  0 taken 222226 (fallthrough)
branch  1 taken 7746
branch  2 taken 222226 (fallthrough)
branch  3 taken 0
        -: 7216:				break;
        -: 7217:		}
        -: 7218:
     7746: 7219:	if ( totaltrans == 1 )
branch  0 taken 5186 (fallthrough)
branch  1 taken 2560
        -: 7220:		{
        -: 7221:		/* There's only one out-transition.  Save it for later to fill
        -: 7222:		 * in holes in the tables.
        -: 7223:		 */
     5186: 7224:		stack1( statenum, minec, state[minec], deflink );
call    0 returned 5186
     5186: 7225:		return;
        -: 7226:		}
        -: 7227:
   254610: 7228:	for ( maxec = numchars; maxec > 0; --maxec )
branch  0 taken 254610
branch  1 taken 0 (fallthrough)
        -: 7229:		{
   254610: 7230:		if ( state[maxec] != SAME_TRANS )
branch  0 taken 205811 (fallthrough)
branch  1 taken 48799
   205811: 7231:			if ( state[maxec] != 0 || deflink != JAMSTATE )
branch  0 taken 203251 (fallthrough)
branch  1 taken 2560
branch  2 taken 203251 (fallthrough)
branch  3 taken 0
        -: 7232:				break;
        -: 7233:		}
        -: 7234:
        -: 7235:	/* Whether we try to fit the state table in the middle of the table
        -: 7236:	 * entries we have already generated, or if we just take the state
        -: 7237:	 * table at the end of the nxt/chk tables, we must make sure that we
        -: 7238:	 * have a valid base address (i.e., non-negative).  Note that
        -: 7239:	 * negative base addresses dangerous at run-time (because indexing
        -: 7240:	 * the nxt array with one and a low-valued character will access
        -: 7241:	 * memory before the start of the array.
        -: 7242:	 */
        -: 7243:
        -: 7244:	/* Find the first transition of state that we need to worry about. */
     2560: 7245:	if ( totaltrans * 100 <= numchars * INTERIOR_FIT_PERCENTAGE )
branch  0 taken 1805 (fallthrough)
branch  1 taken 755
        -: 7246:		{
        -: 7247:		/* Attempt to squeeze it into the middle of the tables. */
     1805: 7248:		baseaddr = firstfree;
        -: 7249:
    63100: 7250:		while ( baseaddr < minec )
branch  0 taken 61295
branch  1 taken 1805 (fallthrough)
        -: 7251:			{
        -: 7252:			/* Using baseaddr would result in a negative base
        -: 7253:			 * address below; find the next free slot.
        -: 7254:			 */
    93597: 7255:			for ( ++baseaddr; chk[baseaddr] != 0; ++baseaddr )
branch  0 taken 32302
branch  1 taken 61295 (fallthrough)
        -: 7256:				;
        -: 7257:			}
        -: 7258:
     1805: 7259:		while ( baseaddr + maxec - minec + 1 >= current_max_xpairs )
branch  0 taken 0
branch  1 taken 1805 (fallthrough)
    #####: 7260:			expand_nxt_chk();
call    0 never executed
        -: 7261:
   547446: 7262:		for ( i = minec; i <= maxec; ++i )
branch  0 taken 545641
branch  1 taken 1805
   545641: 7263:			if ( state[i] != SAME_TRANS &&
branch  0 taken 523583 (fallthrough)
branch  1 taken 22058
   523583: 7264:			     (state[i] != 0 || deflink != JAMSTATE) &&
branch  0 taken 263008 (fallthrough)
branch  1 taken 260575
branch  2 taken 0 (fallthrough)
branch  3 taken 263008
   260575: 7265:			     chk[baseaddr + i - minec] != 0 )
branch  0 taken 47436 (fallthrough)
branch  1 taken 213139
        -: 7266:				{ /* baseaddr unsuitable - find another */
    47436: 7267:				for ( ++baseaddr;
   586307: 7268:				      baseaddr < current_max_xpairs &&
branch  0 taken 586307 (fallthrough)
branch  1 taken 0
   586307: 7269:				      chk[baseaddr] != 0; ++baseaddr )
branch  0 taken 538871
branch  1 taken 47436 (fallthrough)
        -: 7270:					;
        -: 7271:
    47436: 7272:				while ( baseaddr + maxec - minec + 1 >=
branch  0 taken 0
branch  1 taken 47436 (fallthrough)
        -: 7273:					current_max_xpairs )
    #####: 7274:					expand_nxt_chk();
call    0 never executed
        -: 7275:
        -: 7276:				/* Reset the loop counter so we'll start all
        -: 7277:				 * over again next time it's incremented.
        -: 7278:				 */
        -: 7279:
    47436: 7280:				i = minec - 1;
        -: 7281:				}
        -: 7282:		}
        -: 7283:
        -: 7284:	else
        -: 7285:		{
        -: 7286:		/* Ensure that the base address we eventually generate is
        -: 7287:		 * non-negative.
        -: 7288:		 */
      755: 7289:		baseaddr = max( tblend + 1, minec );
branch  0 taken 440 (fallthrough)
branch  1 taken 315
        -: 7290:		}
        -: 7291:
     2560: 7292:	tblbase = baseaddr - minec;
     2560: 7293:	tbllast = tblbase + maxec;
        -: 7294:
     2560: 7295:	while ( tbllast + 1 >= current_max_xpairs )
branch  0 taken 0
branch  1 taken 2560 (fallthrough)
    #####: 7296:		expand_nxt_chk();
call    0 never executed
        -: 7297:
     2560: 7298:	base[statenum] = tblbase;
     2560: 7299:	def[statenum] = deflink;
        -: 7300:
   142806: 7301:	for ( i = minec; i <= maxec; ++i )
branch  0 taken 140246
branch  1 taken 2560 (fallthrough)
   140246: 7302:		if ( state[i] != SAME_TRANS )
branch  0 taken 123046 (fallthrough)
branch  1 taken 17200
   123046: 7303:			if ( state[i] != 0 || deflink != JAMSTATE )
branch  0 taken 45467 (fallthrough)
branch  1 taken 77579
branch  2 taken 0 (fallthrough)
branch  3 taken 45467
        -: 7304:				{
    77579: 7305:				nxt[tblbase + i] = state[i];
    77579: 7306:				chk[tblbase + i] = statenum;
        -: 7307:				}
        -: 7308:
     2560: 7309:	if ( baseaddr == firstfree )
branch  0 taken 412 (fallthrough)
branch  1 taken 2148
        -: 7310:		/* Find next free slot in tables. */
     3946: 7311:		for ( ++firstfree; chk[firstfree] != 0; ++firstfree )
branch  0 taken 3534
branch  1 taken 412 (fallthrough)
        -: 7312:			;
        -: 7313:
     2560: 7314:	tblend = max( tblend, tbllast );
        -: 7315:	}
        -: 7316:
        -: 7317:
        -: 7318:/* mk1tbl - create table entries for a state (or state fragment) which
        -: 7319: *            has only one out-transition
        -: 7320: */
        -: 7321:
function mk1tbl called 5612 returned 100% blocks executed 80%
     5612: 7322:void mk1tbl( state, sym, onenxt, onedef )
        -: 7323:int state, sym, onenxt, onedef;
        -: 7324:	{
     5612: 7325:	if ( firstfree < sym )
branch  0 taken 273 (fallthrough)
branch  1 taken 5339
      273: 7326:		firstfree = sym;
        -: 7327:
    19208: 7328:	while ( chk[firstfree] != 0 )
branch  0 taken 13596
branch  1 taken 5612 (fallthrough)
    13596: 7329:		if ( ++firstfree >= current_max_xpairs )
branch  0 taken 0 (fallthrough)
branch  1 taken 13596
    #####: 7330:			expand_nxt_chk();
call    0 never executed
        -: 7331:
     5612: 7332:	base[state] = firstfree - sym;
     5612: 7333:	def[state] = onedef;
     5612: 7334:	chk[firstfree] = state;
     5612: 7335:	nxt[firstfree] = onenxt;
        -: 7336:
     5612: 7337:	if ( firstfree > tblend )
branch  0 taken 4097 (fallthrough)
branch  1 taken 1515
        -: 7338:		{
     4097: 7339:		tblend = firstfree++;
        -: 7340:
     4097: 7341:		if ( firstfree >= current_max_xpairs )
branch  0 taken 0 (fallthrough)
branch  1 taken 4097
    #####: 7342:			expand_nxt_chk();
call    0 never executed
        -: 7343:		}
     5612: 7344:	}
        -: 7345:
        -: 7346:
        -: 7347:/* mkprot - create new proto entry */
        -: 7348:
function mkprot called 962 returned 100% blocks executed 90%
      962: 7349:void mkprot( state, statenum, comstate )
        -: 7350:int state[], statenum, comstate;
        -: 7351:	{
        -: 7352:	int i, slot, tblbase;
        -: 7353:
      962: 7354:	if ( ++numprots >= MSP || numecs * numprots >= PROT_SAVE_SIZE )
branch  0 taken 962 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 962
        -: 7355:		{
        -: 7356:		/* Gotta make room for the new proto by dropping last entry in
        -: 7357:		 * the queue.
        -: 7358:		 */
    #####: 7359:		slot = lastprot;
    #####: 7360:		lastprot = protprev[lastprot];
    #####: 7361:		protnext[lastprot] = NIL;
        -: 7362:		}
        -: 7363:
        -: 7364:	else
      962: 7365:		slot = numprots;
        -: 7366:
      962: 7367:	protnext[slot] = firstprot;
        -: 7368:
      962: 7369:	if ( firstprot != NIL )
branch  0 taken 536 (fallthrough)
branch  1 taken 426
      536: 7370:		protprev[firstprot] = slot;
        -: 7371:
      962: 7372:	firstprot = slot;
      962: 7373:	prottbl[slot] = statenum;
      962: 7374:	protcomst[slot] = comstate;
        -: 7375:
        -: 7376:	/* Copy state into save area so it can be compared with rapidly. */
      962: 7377:	tblbase = numecs * (slot - 1);
        -: 7378:
    63607: 7379:	for ( i = 1; i <= numecs; ++i )
branch  0 taken 62645
branch  1 taken 962 (fallthrough)
    62645: 7380:		protsave[tblbase + i] = state[i];
      962: 7381:	}
        -: 7382:
        -: 7383:
        -: 7384:/* mktemplate - create a template entry based on a state, and connect the state
        -: 7385: *              to it
        -: 7386: */
        -: 7387:
function mktemplate called 622 returned 100% blocks executed 87%
      622: 7388:void mktemplate( state, statenum, comstate )
        -: 7389:int state[], statenum, comstate;
        -: 7390:	{
        -: 7391:	int i, numdiff, tmpbase, tmp[CSIZE + 1];
        -: 7392:	Char transset[CSIZE + 1];
        -: 7393:	int tsptr;
        -: 7394:
      622: 7395:	++numtemps;
        -: 7396:
      622: 7397:	tsptr = 0;
        -: 7398:
        -: 7399:	/* Calculate where we will temporarily store the transition table
        -: 7400:	 * of the template in the tnxt[] array.  The final transition table
        -: 7401:	 * gets created by cmptmps().
        -: 7402:	 */
        -: 7403:
      622: 7404:	tmpbase = numtemps * numecs;
        -: 7405:
      622: 7406:	if ( tmpbase + numecs >= current_max_template_xpairs )
branch  0 taken 0 (fallthrough)
branch  1 taken 622
        -: 7407:		{
    #####: 7408:		current_max_template_xpairs += MAX_TEMPLATE_XPAIRS_INCREMENT;
        -: 7409:
    #####: 7410:		++num_reallocs;
        -: 7411:
    #####: 7412:		tnxt = reallocate_integer_array( tnxt,
call    0 never executed
        -: 7413:			current_max_template_xpairs );
        -: 7414:		}
        -: 7415:
    58547: 7416:	for ( i = 1; i <= numecs; ++i )
branch  0 taken 57925
branch  1 taken 622 (fallthrough)
    57925: 7417:		if ( state[i] == 0 )
branch  0 taken 2335 (fallthrough)
branch  1 taken 55590
     2335: 7418:			tnxt[tmpbase + i] = 0;
        -: 7419:		else
        -: 7420:			{
    55590: 7421:			transset[tsptr++] = i;
    55590: 7422:			tnxt[tmpbase + i] = comstate;
        -: 7423:			}
        -: 7424:
      622: 7425:	if ( usemecs )
branch  0 taken 316 (fallthrough)
branch  1 taken 306
      316: 7426:		mkeccl( transset, tsptr, tecfwd, tecbck, numecs, 0 );
call    0 returned 316
        -: 7427:
      622: 7428:	mkprot( tnxt + tmpbase, -numtemps, comstate );
call    0 returned 622
        -: 7429:
        -: 7430:	/* We rely on the fact that mkprot adds things to the beginning
        -: 7431:	 * of the proto queue.
        -: 7432:	 */
        -: 7433:
      622: 7434:	numdiff = tbldiff( state, firstprot, tmp );
call    0 returned 622
      622: 7435:	mkentry( tmp, numecs, statenum, -numtemps, numdiff );
call    0 returned 622
      622: 7436:	}
        -: 7437:
        -: 7438:
        -: 7439:/* mv2front - move proto queue element to front of queue */
        -: 7440:
function mv2front called 2041 returned 100% blocks executed 100%
     2041: 7441:void mv2front( qelm )
        -: 7442:int qelm;
        -: 7443:	{
     2041: 7444:	if ( firstprot != qelm )
branch  0 taken 304 (fallthrough)
branch  1 taken 1737
        -: 7445:		{
      304: 7446:		if ( qelm == lastprot )
branch  0 taken 58 (fallthrough)
branch  1 taken 246
       58: 7447:			lastprot = protprev[lastprot];
        -: 7448:
      304: 7449:		protnext[protprev[qelm]] = protnext[qelm];
        -: 7450:
      304: 7451:		if ( protnext[qelm] != NIL )
branch  0 taken 246 (fallthrough)
branch  1 taken 58
      246: 7452:			protprev[protnext[qelm]] = protprev[qelm];
        -: 7453:
      304: 7454:		protprev[qelm] = NIL;
      304: 7455:		protnext[qelm] = firstprot;
      304: 7456:		protprev[firstprot] = qelm;
      304: 7457:		firstprot = qelm;
        -: 7458:		}
     2041: 7459:	}
        -: 7460:
        -: 7461:
        -: 7462:/* place_state - place a state into full speed transition table
        -: 7463: *
        -: 7464: * State is the statenum'th state.  It is indexed by equivalence class and
        -: 7465: * gives the number of the state to enter for a given equivalence class.
        -: 7466: * Transnum is the number of out-transitions for the state.
        -: 7467: */
        -: 7468:
function place_state called 2262 returned 100% blocks executed 100%
     2262: 7469:void place_state( state, statenum, transnum )
        -: 7470:int *state, statenum, transnum;
        -: 7471:	{
        -: 7472:	register int i;
        -: 7473:	register int *state_ptr;
     2262: 7474:	int position = find_table_space( state, transnum );
call    0 returned 2262
        -: 7475:
        -: 7476:	/* "base" is the table of start positions. */
     2262: 7477:	base[statenum] = position;
        -: 7478:
        -: 7479:	/* Put in action number marker; this non-zero number makes sure that
        -: 7480:	 * find_table_space() knows that this position in chk/nxt is taken
        -: 7481:	 * and should not be used for another accepting number in another
        -: 7482:	 * state.
        -: 7483:	 */
     2262: 7484:	chk[position - 1] = 1;
        -: 7485:
        -: 7486:	/* Put in end-of-buffer marker; this is for the same purposes as
        -: 7487:	 * above.
        -: 7488:	 */
     2262: 7489:	chk[position] = 1;
        -: 7490:
        -: 7491:	/* Place the state into chk and nxt. */
     2262: 7492:	state_ptr = &state[1];
        -: 7493:
   181878: 7494:	for ( i = 1; i <= numecs; ++i, ++state_ptr )
branch  0 taken 179616
branch  1 taken 2262 (fallthrough)
   179616: 7495:		if ( *state_ptr != 0 )
branch  0 taken 32723 (fallthrough)
branch  1 taken 146893
        -: 7496:			{
    32723: 7497:			chk[position + i] = i;
    32723: 7498:			nxt[position + i] = *state_ptr;
        -: 7499:			}
        -: 7500:
     2262: 7501:	if ( position + numecs > tblend )
branch  0 taken 2226 (fallthrough)
branch  1 taken 36
     2226: 7502:		tblend = position + numecs;
     2262: 7503:	}
        -: 7504:
        -: 7505:
        -: 7506:/* stack1 - save states with only one out-transition to be processed later
        -: 7507: *
        -: 7508: * If there's room for another state on the "one-transition" stack, the
        -: 7509: * state is pushed onto it, to be processed later by mk1tbl.  If there's
        -: 7510: * no room, we process the sucker right now.
        -: 7511: */
        -: 7512:
function stack1 called 5612 returned 100% blocks executed 75%
     5612: 7513:void stack1( statenum, sym, nextstate, deflink )
        -: 7514:int statenum, sym, nextstate, deflink;
        -: 7515:	{
     5612: 7516:	if ( onesp >= ONE_STACK_SIZE - 1 )
branch  0 taken 0 (fallthrough)
branch  1 taken 5612
    #####: 7517:		mk1tbl( statenum, sym, nextstate, deflink );
call    0 never executed
        -: 7518:
        -: 7519:	else
        -: 7520:		{
     5612: 7521:		++onesp;
     5612: 7522:		onestate[onesp] = statenum;
     5612: 7523:		onesym[onesp] = sym;
     5612: 7524:		onenext[onesp] = nextstate;
     5612: 7525:		onedef[onesp] = deflink;
        -: 7526:		}
     5612: 7527:	}
        -: 7528:
        -: 7529:
        -: 7530:/* tbldiff - compute differences between two state tables
        -: 7531: *
        -: 7532: * "state" is the state array which is to be extracted from the pr'th
        -: 7533: * proto.  "pr" is both the number of the proto we are extracting from
        -: 7534: * and an index into the save area where we can find the proto's complete
        -: 7535: * state table.  Each entry in "state" which differs from the corresponding
        -: 7536: * entry of "pr" will appear in "ext".
        -: 7537: *
        -: 7538: * Entries which are the same in both "state" and "pr" will be marked
        -: 7539: * as transitions to "SAME_TRANS" in "ext".  The total number of differences
        -: 7540: * between "state" and "pr" is returned as function value.  Note that this
        -: 7541: * number is "numecs" minus the number of "SAME_TRANS" entries in "ext".
        -: 7542: */
        -: 7543:
function tbldiff called 3959 returned 100% blocks executed 100%
     3959: 7544:int tbldiff( state, pr, ext )
        -: 7545:int state[], pr, ext[];
        -: 7546:	{
     3959: 7547:	register int i, *sp = state, *ep = ext, *protp;
     3959: 7548:	register int numdiff = 0;
        -: 7549:
     3959: 7550:	protp = &protsave[numecs * (pr - 1)];
        -: 7551:
   196298: 7552:	for ( i = numecs; i > 0; --i )
branch  0 taken 192339
branch  1 taken 3959 (fallthrough)
        -: 7553:		{
   192339: 7554:		if ( *++protp == *++sp )
branch  0 taken 162625 (fallthrough)
branch  1 taken 29714
   162625: 7555:			*++ep = SAME_TRANS;
        -: 7556:		else
        -: 7557:			{
    29714: 7558:			*++ep = *sp;
    29714: 7559:			++numdiff;
        -: 7560:			}
        -: 7561:		}
        -: 7562:
     3959: 7563:	return numdiff;
        -: 7564:	}
        -: 7565:/* yylex - scanner front-end for flex */
        -: 7566:
        -: 7567:/*-
        -: 7568: * Copyright (c) 1990 The Regents of the University of California.
        -: 7569: * All rights reserved.
        -: 7570: *
        -: 7571: * This code is derived from software contributed to Berkeley by
        -: 7572: * Vern Paxson.
        -: 7573: * 
        -: 7574: * The United States Government has rights in this work pursuant
        -: 7575: * to contract no. DE-AC03-76SF00098 between the United States
        -: 7576: * Department of Energy and the University of California.
        -: 7577: *
        -: 7578: * Redistribution and use in source and binary forms are permitted provided
        -: 7579: * that: (1) source distributions retain this entire copyright notice and
        -: 7580: * comment, and (2) distributions including binaries display the following
        -: 7581: * acknowledgement:  ``This product includes software developed by the
        -: 7582: * University of California, Berkeley and its contributors'' in the
        -: 7583: * documentation or other materials provided with the distribution and in
        -: 7584: * all advertising materials mentioning features or use of this software.
        -: 7585: * Neither the name of the University nor the names of its contributors may
        -: 7586: * be used to endorse or promote products derived from this software without
        -: 7587: * specific prior written permission.
        -: 7588: * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
        -: 7589: * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
        -: 7590: * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
        -: 7591: */
        -: 7592:
        -: 7593:/* $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.orig/v0/flex.c,v 1.1.1.1 2003/06/02 17:12:00 expsir Exp $ */
        -: 7594:
        -: 7595:
        -: 7596:
        -: 7597:/* yylex - scan for a regular expression token */
        -: 7598:
function yylex called 27966 returned 100% blocks executed 91%
    27966: 7599:int yylex()
        -: 7600:	{
        -: 7601:	int toktype;
        -: 7602:	static int beglin = false;
        -: 7603:
    27966: 7604:	if ( eofseen )
branch  0 taken 0 (fallthrough)
branch  1 taken 27966
    #####: 7605:		toktype = EOF;
        -: 7606:	else
    27966: 7607:		toktype = flexscan();
call    0 returned 27966
        -: 7608:
    27966: 7609:	if ( toktype == EOF || toktype == 0 )
branch  0 taken 27966 (fallthrough)
branch  1 taken 0
branch  2 taken 549 (fallthrough)
branch  3 taken 27417
        -: 7610:		{
      549: 7611:		eofseen = 1;
        -: 7612:
      549: 7613:		if ( sectnum == 1 )
branch  0 taken 0 (fallthrough)
branch  1 taken 549
        -: 7614:			{
    #####: 7615:			synerr( "premature EOF" );
call    0 never executed
    #####: 7616:			sectnum = 2;
    #####: 7617:			toktype = SECTEND;
        -: 7618:			}
        -: 7619:
        -: 7620:		else
      549: 7621:			toktype = 0;
        -: 7622:		}
        -: 7623:
    27966: 7624:	if ( trace )
branch  0 taken 1532 (fallthrough)
branch  1 taken 26434
        -: 7625:		{
     1532: 7626:		if ( beglin )
branch  0 taken 181 (fallthrough)
branch  1 taken 1351
        -: 7627:			{
      181: 7628:			fprintf( err, "%d\t", num_rules + 1 );
call    0 returned 181
      181: 7629:			beglin = 0;
        -: 7630:			}
        -: 7631:
     1532: 7632:		switch ( toktype )
branch  0 taken 525
branch  1 taken 171
branch  2 taken 1
branch  3 taken 4
branch  4 taken 5
branch  5 taken 15
branch  6 taken 5
branch  7 taken 777
branch  8 taken 4
branch  9 taken 9
branch 10 taken 1
branch 11 taken 15
branch 12 taken 0
        -: 7633:			{
      525: 7634:			case '<':
        -: 7635:			case '>':
        -: 7636:			case '^':
        -: 7637:			case '$':
        -: 7638:			case '"':
        -: 7639:			case '[':
        -: 7640:			case ']':
        -: 7641:			case '{':
        -: 7642:			case '}':
        -: 7643:			case '|':
        -: 7644:			case '(':
        -: 7645:			case ')':
        -: 7646:			case '-':
        -: 7647:			case '/':
        -: 7648:			case '\\':
        -: 7649:			case '?':
        -: 7650:			case '.':
        -: 7651:			case '*':
        -: 7652:			case '+':
        -: 7653:			case ',':
      525: 7654:				(void) putc( toktype, err );
call    0 returned 525
      525: 7655:				break;
        -: 7656:
      171: 7657:			case '\n':
      171: 7658:				(void) putc( '\n', err );
call    0 returned 171
        -: 7659:
      171: 7660:				if ( sectnum == 2 )
branch  0 taken 166 (fallthrough)
branch  1 taken 5
      166: 7661:				beglin = 1;
        -: 7662:
      171: 7663:				break;
        -: 7664:
        1: 7665:			case SCDECL:
        1: 7666:				fputs( "%s", err );
call    0 returned 1
        1: 7667:				break;
        -: 7668:
        4: 7669:			case XSCDECL:
        4: 7670:				fputs( "%x", err );
call    0 returned 4
        4: 7671:				break;
        -: 7672:
        5: 7673:			case WHITESPACE:
        5: 7674:				(void) putc( ' ', err );
call    0 returned 5
        5: 7675:				break;
        -: 7676:
       15: 7677:			case SECTEND:
       15: 7678:				fputs( "%%\n", err );
call    0 returned 15
        -: 7679:
        -: 7680:				/* We set beglin to be true so we'll start
        -: 7681:				 * writing out numbers as we echo rules.
        -: 7682:				 * flexscan() has already assigned sectnum.
        -: 7683:				 */
        -: 7684:
       15: 7685:				if ( sectnum == 2 )
branch  0 taken 15 (fallthrough)
branch  1 taken 0
       15: 7686:				beglin = 1;
        -: 7687:
       15: 7688:				break;
        -: 7689:
        5: 7690:			case NAME:
        5: 7691:				fprintf( err, "'%s'", nmstr );
call    0 returned 5
        5: 7692:				break;
        -: 7693:
      777: 7694:			case CHAR:
      777: 7695:				switch ( yylval )
branch  0 taken 36
branch  1 taken 741
        -: 7696:					{
       36: 7697:					case '<':
        -: 7698:					case '>':
        -: 7699:					case '^':
        -: 7700:					case '$':
        -: 7701:					case '"':
        -: 7702:					case '[':
        -: 7703:					case ']':
        -: 7704:					case '{':
        -: 7705:					case '}':
        -: 7706:					case '|':
        -: 7707:					case '(':
        -: 7708:					case ')':
        -: 7709:					case '-':
        -: 7710:					case '/':
        -: 7711:					case '\\':
        -: 7712:					case '?':
        -: 7713:					case '.':
        -: 7714:					case '*':
        -: 7715:					case '+':
        -: 7716:					case ',':
       36: 7717:						fprintf( err, "\\%c",
call    0 returned 36
        -: 7718:							yylval );
       36: 7719:						break;
        -: 7720:
      741: 7721:					default:
      741: 7722:						if ( ! isascii( yylval ) ||
branch  0 taken 741 (fallthrough)
branch  1 taken 0
      741: 7723:						     ! isprint( yylval ) )
branch  0 taken 17 (fallthrough)
branch  1 taken 724
       17: 7724:							fprintf( err,
call    0 returned 17
        -: 7725:								"\\%.3o",
        -: 7726:							(unsigned int) yylval );
        -: 7727:						else
      724: 7728:							(void) putc( yylval,
call    0 returned 724
        -: 7729:								err );
      741: 7730:					break;
        -: 7731:					}
        -: 7732:
      777: 7733:				break;
        -: 7734:
        4: 7735:			case NUMBER:
        4: 7736:				fprintf( err, "%d", yylval );
call    0 returned 4
        4: 7737:				break;
        -: 7738:
        9: 7739:			case PREVCCL:
        9: 7740:				fprintf( err, "[%d]", yylval );
call    0 returned 9
        9: 7741:				break;
        -: 7742:
        1: 7743:			case EOF_OP:
        1: 7744:				fprintf( err, "<<EOF>>" );
call    0 returned 1
        1: 7745:				break;
        -: 7746:
       15: 7747:			case 0:
       15: 7748:				fprintf( err, "End Marker" );
call    0 returned 15
       15: 7749:				break;
        -: 7750:
    #####: 7751:			default:
    #####: 7752:				fprintf( err,
call    0 never executed
        -: 7753:					"*Something Weird* - tok: %d val: %d\n",
        -: 7754:					toktype, yylval );
    #####: 7755:				break;
        -: 7756:			}
        -: 7757:		}
        -: 7758:
    27966: 7759:	return toktype;
        -: 7760:	}
        -: 7761:
        -: 7762:/*  A Bison parser, made from ./parse.y
        -: 7763:    by GNU Bison version 1.28  */
        -: 7764:
        -: 7765:#define YYBISON 1  /* Identify Bison output.  */
        -: 7766:
        -: 7767:#define	CHAR	257
        -: 7768:#define	NUMBER	258
        -: 7769:#define	SECTEND	259
        -: 7770:#define	SCDECL	260
        -: 7771:#define	XSCDECL	261
        -: 7772:#define	WHITESPACE	262
        -: 7773:#define	NAME	263
        -: 7774:#define	PREVCCL	264
        -: 7775:#define	EOF_OP	265
        -: 7776:
        -: 7777:
        -: 7778:/*-
        -: 7779: * Copyright (c) 1990 The Regents of the University of California.
        -: 7780: * All rights reserved.
        -: 7781: *
        -: 7782: * This code is derived from software contributed to Berkeley by
        -: 7783: * Vern Paxson.
        -: 7784: * 
        -: 7785: * The United States Government has rights in this work pursuant
        -: 7786: * to contract no. DE-AC03-76SF00098 between the United States
        -: 7787: * Department of Energy and the University of California.
        -: 7788: *
        -: 7789: * Redistribution and use in source and binary forms are permitted provided
        -: 7790: * that: (1) source distributions retain this entire copyright notice and
        -: 7791: * comment, and (2) distributions including binaries display the following
        -: 7792: * acknowledgement:  ``This product includes software developed by the
        -: 7793: * University of California, Berkeley and its contributors'' in the
        -: 7794: * documentation or other materials provided with the distribution and in
        -: 7795: * all advertising materials mentioning features or use of this software.
        -: 7796: * Neither the name of the University nor the names of its contributors may
        -: 7797: * be used to endorse or promote products derived from this software without
        -: 7798: * specific prior written permission.
        -: 7799: * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
        -: 7800: * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
        -: 7801: * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
        -: 7802: */
        -: 7803:
        -: 7804:/* $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.orig/v0/flex.c,v 1.1.1.1 2003/06/02 17:12:00 expsir Exp $ */
        -: 7805:
        -: 7806:
        -: 7807:/* Some versions of bison are broken in that they use alloca() but don't
        -: 7808: * declare it properly.  The following is the patented (just kidding!)
        -: 7809: * #ifdef chud to fix the problem, courtesy of Francois Pinard.
        -: 7810: */
        -: 7811:#ifdef YYBISON
        -: 7812:/* AIX requires this to be the first thing in the file.  */
        -: 7813:#if (defined(__GNUC__) && (!defined(LINUX)))
        -: 7814:#define alloca __builtin_alloca
        -: 7815:#else /* not __GNUC__ */
        -: 7816:#if HAVE_ALLOCA_H
        -: 7817:#include <alloca.h>
        -: 7818:#else /* not HAVE_ALLOCA_H */
        -: 7819:#ifdef _AIX
        -: 7820: #pragma alloca
        -: 7821:#else /* not _AIX */
        -: 7822:char *alloca ();
        -: 7823:#endif /* not _AIX */
        -: 7824:#endif /* not HAVE_ALLOCA_H */
        -: 7825:#endif /* not __GNUC__ */
        -: 7826:#endif /* YYBISON */
        -: 7827:
        -: 7828:/* Bletch, ^^^^ that was ugly! */
        -: 7829:
        -: 7830:
        -: 7831:
        -: 7832:int pat, scnum, eps, headcnt, trailcnt, anyccl, lastchar, i, actvp, rulelen;
        -: 7833:int trlcontxt, xcluflg, cclsorted, varlength, variable_trail_rule;
        -: 7834:int *active_ss;
        -: 7835:Char clower();
        -: 7836:void build_eof_action();
        -: 7837:void yyerror();
        -: 7838:
        -: 7839:static int madeany = false;  /* whether we've made the '.' character class */
        -: 7840:int previous_continued_action;	/* whether the previous rule's action was '|' */
        -: 7841:
        -: 7842:/* On some over-ambitious machines, such as DEC Alpha's, the default
        -: 7843: * token type is "long" instead of "int"; this leads to problems with
        -: 7844: * declaring yylval in flexdef.h.  But so far, all the yacc's I've seen
        -: 7845: * wrap their definitions of YYSTYPE with "#ifndef YYSTYPE"'s, so the
        -: 7846: * following should ensure that the default token type is "int".
        -: 7847: */
        -: 7848:#define YYSTYPE int
        -: 7849:
        -: 7850:#ifndef YYSTYPE
        -: 7851:#define YYSTYPE int
        -: 7852:#endif
        -: 7853:#include <stdio.h>
        -: 7854:
        -: 7855:#ifndef __cplusplus
        -: 7856:#ifndef __STDC__
        -: 7857:#define const
        -: 7858:#endif
        -: 7859:#endif
        -: 7860:
        -: 7861:
        -: 7862:
        -: 7863:#define	YYFINAL		85
        -: 7864:#define	YYFLAG		-32768
        -: 7865:#define	YYNTBASE	32
        -: 7866:
        -: 7867:#define YYTRANSLATE(x) ((unsigned)(x) <= 265 ? yytranslate[x] : 53)
        -: 7868:
        -: 7869:static const char yytranslate[] = {     0,
        -: 7870:     2,     2,     2,     2,     2,     2,     2,     2,     2,    12,
        -: 7871:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 7872:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 7873:     2,     2,     2,    26,     2,    18,     2,     2,     2,    27,
        -: 7874:    28,    16,    21,    17,    31,    25,    20,     2,     2,     2,
        -: 7875:     2,     2,     2,     2,     2,     2,     2,     2,     2,    14,
        -: 7876:     2,    15,    22,     2,     2,     2,     2,     2,     2,     2,
        -: 7877:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 7878:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 7879:    29,     2,    30,    13,     2,     2,     2,     2,     2,     2,
        -: 7880:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 7881:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 7882:     2,     2,    23,    19,    24,     2,     2,     2,     2,     2,
        -: 7883:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 7884:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 7885:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 7886:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 7887:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 7888:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 7889:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 7890:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 7891:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 7892:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 7893:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 7894:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 7895:     2,     2,     2,     2,     2,     1,     3,     4,     5,     6,
        -: 7896:     7,     8,     9,    10,    11
        -: 7897:};
        -: 7898:
        -: 7899:#if YYDEBUG != 0
        -: 7900:static const short yyprhs[] = {     0,
        -: 7901:     0,     6,     7,    13,    14,    17,    19,    21,    23,    27,
        -: 7902:    29,    31,    36,    37,    38,    42,    45,    48,    50,    53,
        -: 7903:    55,    57,    61,    65,    69,    70,    73,    75,    77,    80,
        -: 7904:    84,    87,    89,    93,    95,    98,   101,   103,   106,   109,
        -: 7905:   112,   119,   125,   130,   132,   134,   136,   140,   144,   146,
        -: 7906:   150,   155,   160,   163,   164,   167
        -: 7907:};
        -: 7908:
        -: 7909:static const short yyrhs[] = {    33,
        -: 7910:    34,    35,    38,    39,     0,     0,    34,    36,     8,    37,
        -: 7911:    12,     0,     0,     1,    12,     0,     5,     0,     6,     0,
        -: 7912:     7,     0,    37,     8,     9,     0,     9,     0,     1,     0,
        -: 7913:    38,    39,    40,    12,     0,     0,     0,    41,    13,    45,
        -: 7914:     0,    41,    45,     0,    13,    45,     0,    45,     0,    41,
        -: 7915:    11,     0,    11,     0,     1,     0,    14,    42,    15,     0,
        -: 7916:    14,    16,    15,     0,    42,    17,    44,     0,     0,    43,
        -: 7917:    44,     0,     1,     0,     9,     0,    47,    46,     0,    47,
        -: 7918:    46,    18,     0,    46,    18,     0,    46,     0,    46,    19,
        -: 7919:    48,     0,    48,     0,    46,    20,     0,    48,    49,     0,
        -: 7920:    49,     0,    49,    16,     0,    49,    21,     0,    49,    22,
        -: 7921:     0,    49,    23,     4,    17,     4,    24,     0,    49,    23,
        -: 7922:     4,    17,    24,     0,    49,    23,     4,    24,     0,    25,
        -: 7923:     0,    50,     0,    10,     0,    26,    52,    26,     0,    27,
        -: 7924:    46,    28,     0,     3,     0,    29,    51,    30,     0,    29,
        -: 7925:    13,    51,    30,     0,    51,     3,    31,     3,     0,    51,
        -: 7926:     3,     0,     0,    52,     3,     0,     0
        -: 7927:};
        -: 7928:
        -: 7929:#endif
        -: 7930:
        -: 7931:#if YYDEBUG != 0
        -: 7932:static const short yyrline[] = { 0,
        -: 7933:    82,   111,   124,   125,   126,   130,   143,   146,   150,   153,
        -: 7934:   156,   160,   161,   164,   175,   195,   206,   230,   241,   244,
        -: 7935:   263,   267,   269,   278,   280,   282,   282,   286,   307,   362,
        -: 7936:   365,   413,   431,   437,   442,   469,   477,   481,   488,   494,
        -: 7937:   500,   528,   542,   561,   583,   601,   608,   611,   614,   625,
        -: 7938:   628,   635,   663,   674,   682,   692
        -: 7939:};
        -: 7940:#endif
        -: 7941:
        -: 7942:
        -: 7943:#if YYDEBUG != 0 || defined (YYERROR_VERBOSE)
        -: 7944:
        -: 7945:static const char * const yytname[] = {   "$","error","$undefined.","CHAR","NUMBER",
        -: 7946:"SECTEND","SCDECL","XSCDECL","WHITESPACE","NAME","PREVCCL","EOF_OP","'\\n'",
        -: 7947:"'^'","'<'","'>'","'*'","','","'$'","'|'","'/'","'+'","'?'","'{'","'}'","'.'",
        -: 7948:"'\\\"'","'('","')'","'['","']'","'-'","goal","initlex","sect1","sect1end","startconddecl",
        -: 7949:"namelist1","sect2","initforrule","flexrule","scon","namelist2","@1","sconname",
        -: 7950:"rule","re","re2","series","singleton","fullccl","ccl","string", NULL
        -: 7951:};
        -: 7952:#endif
        -: 7953:
        -: 7954:static const short yyr1[] = {     0,
        -: 7955:    32,    33,    34,    34,    34,    35,    36,    36,    37,    37,
        -: 7956:    37,    38,    38,    39,    40,    40,    40,    40,    40,    40,
        -: 7957:    40,    41,    41,    42,    43,    42,    42,    44,    45,    45,
        -: 7958:    45,    45,    46,    46,    47,    48,    48,    49,    49,    49,
        -: 7959:    49,    49,    49,    49,    49,    49,    49,    49,    49,    50,
        -: 7960:    50,    51,    51,    51,    52,    52
        -: 7961:};
        -: 7962:
        -: 7963:static const short yyr2[] = {     0,
        -: 7964:     5,     0,     5,     0,     2,     1,     1,     1,     3,     1,
        -: 7965:     1,     4,     0,     0,     3,     2,     2,     1,     2,     1,
        -: 7966:     1,     3,     3,     3,     0,     2,     1,     1,     2,     3,
        -: 7967:     2,     1,     3,     1,     2,     2,     1,     2,     2,     2,
        -: 7968:     6,     5,     4,     1,     1,     1,     3,     3,     1,     3,
        -: 7969:     4,     4,     2,     0,     2,     0
        -: 7970:};
        -: 7971:
        -: 7972:static const short yydefact[] = {     2,
        -: 7973:     0,     0,     0,     5,     6,     7,     8,    13,     0,    14,
        -: 7974:     0,     0,    11,    10,     0,    21,    49,    46,    20,     0,
        -: 7975:     0,    44,    56,     0,    54,     0,     0,    18,    32,     0,
        -: 7976:    34,    37,    45,     0,     3,    17,    27,     0,     0,     0,
        -: 7977:     0,     0,    54,     0,    12,    19,     0,    16,    31,     0,
        -: 7978:    35,    29,    36,    38,    39,    40,     0,     9,    23,    22,
        -: 7979:     0,    28,    26,    55,    47,    48,     0,    53,    50,    15,
        -: 7980:    33,    30,     0,    24,    51,     0,     0,    43,    52,     0,
        -: 7981:    42,    41,     0,     0,     0
        -: 7982:};
        -: 7983:
        -: 7984:static const short yydefgoto[] = {    83,
        -: 7985:     1,     3,     8,     9,    15,    10,    12,    26,    27,    39,
        -: 7986:    40,    63,    28,    29,    30,    31,    32,    33,    44,    41
        -: 7987:};
        -: 7988:
        -: 7989:static const short yypact[] = {-32768,
        -: 7990:    61,    -2,    64,-32768,-32768,-32768,-32768,-32768,    13,-32768,
        -: 7991:    34,     1,-32768,-32768,    30,-32768,-32768,-32768,-32768,    21,
        -: 7992:    48,-32768,-32768,    21,    31,    33,    26,-32768,    54,    21,
        -: 7993:    21,    38,-32768,    47,-32768,-32768,-32768,    43,     5,    56,
        -: 7994:    15,   -11,-32768,     2,-32768,-32768,    21,-32768,-32768,    21,
        -: 7995:-32768,    57,    38,-32768,-32768,-32768,    59,-32768,-32768,-32768,
        -: 7996:    56,-32768,-32768,-32768,-32768,-32768,     4,    46,-32768,-32768,
        -: 7997:    21,-32768,    -8,-32768,-32768,    75,    -1,-32768,-32768,    55,
        -: 7998:-32768,-32768,    80,    81,-32768
        -: 7999:};
        -: 8000:
        -: 8001:static const short yypgoto[] = {-32768,
        -: 8002:-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
        -: 8003:-32768,    22,   -14,    -5,-32768,    32,   -31,-32768,    41,-32768
        -: 8004:};
        -: 8005:
        -: 8006:
        -: 8007:#define	YYLAST		84
        -: 8008:
        -: 8009:
        -: 8010:static const short yytable[] = {    53,
        -: 8011:    -1,    16,    80,    17,    68,    36,    68,    50,    77,     4,
        -: 8012:    18,    19,    48,    20,    21,    78,    66,    64,    42,    60,
        -: 8013:    11,    61,    81,    17,    52,    22,    23,    24,    17,    25,
        -: 8014:    18,    69,    70,    75,    13,    18,    46,    34,    47,    53,
        -: 8015:    65,    35,    14,    43,    45,    22,    23,    24,    37,    25,
        -: 8016:    22,    23,    24,    54,    25,    58,   -25,    59,    55,    56,
        -: 8017:    57,     2,    73,    38,    62,    -4,    -4,    -4,     5,     6,
        -: 8018:     7,    49,    50,    51,    72,    50,    76,    79,    82,    84,
        -: 8019:    85,    71,    74,    67
        -: 8020:};
        -: 8021:
        -: 8022:static const short yycheck[] = {    31,
        -: 8023:     0,     1,     4,     3,     3,    20,     3,    19,    17,    12,
        -: 8024:    10,    11,    27,    13,    14,    24,    28,     3,    24,    15,
        -: 8025:     8,    17,    24,     3,    30,    25,    26,    27,     3,    29,
        -: 8026:    10,    30,    47,    30,     1,    10,    11,     8,    13,    71,
        -: 8027:    26,    12,     9,    13,    12,    25,    26,    27,     1,    29,
        -: 8028:    25,    26,    27,    16,    29,     9,     9,    15,    21,    22,
        -: 8029:    23,     1,     4,    16,     9,     5,     6,     7,     5,     6,
        -: 8030:     7,    18,    19,    20,    18,    19,    31,     3,    24,     0,
        -: 8031:     0,    50,    61,    43
        -: 8032:};
        -: 8033:/* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
        -: 8034:/* This file comes from bison-1.28.  */
        -: 8035:
        -: 8036:/* Skeleton output parser for bison,
        -: 8037:   Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.
        -: 8038:
        -: 8039:   This program is free software; you can redistribute it and/or modify
        -: 8040:   it under the terms of the GNU General Public License as published by
        -: 8041:   the Free Software Foundation; either version 2, or (at your option)
        -: 8042:   any later version.
        -: 8043:
        -: 8044:   This program is distributed in the hope that it will be useful,
        -: 8045:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 8046:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 8047:   GNU General Public License for more details.
        -: 8048:
        -: 8049:   You should have received a copy of the GNU General Public License
        -: 8050:   along with this program; if not, write to the Free Software
        -: 8051:   Foundation, Inc., 59 Temple Place - Suite 330,
        -: 8052:   Boston, MA 02111-1307, USA.  */
        -: 8053:
        -: 8054:/* As a special exception, when this file is copied by Bison into a
        -: 8055:   Bison output file, you may use that output file without restriction.
        -: 8056:   This special exception was added by the Free Software Foundation
        -: 8057:   in version 1.24 of Bison.  */
        -: 8058:
        -: 8059:/* This is the parser code that is written into each bison parser
        -: 8060:  when the %semantic_parser declaration is not specified in the grammar.
        -: 8061:  It was written by Richard Stallman by simplifying the hairy parser
        -: 8062:  used when %semantic_parser is specified.  */
        -: 8063:
        -: 8064:#ifndef YYSTACK_USE_ALLOCA
        -: 8065:#ifdef alloca
        -: 8066:#define YYSTACK_USE_ALLOCA
        -: 8067:#else /* alloca not defined */
        -: 8068:#ifdef __GNUC__
        -: 8069:#define YYSTACK_USE_ALLOCA
        -: 8070:#define alloca __builtin_alloca
        -: 8071:#else /* not GNU C.  */
        -: 8072:#if (!defined (__STDC__) && defined (sparc)) || defined (__sparc__) || defined (__sparc) || defined (__sgi) || (defined (__sun) && defined (__i386))
        -: 8073:#define YYSTACK_USE_ALLOCA
        -: 8074:#include <alloca.h>
        -: 8075:#else /* not sparc */
        -: 8076:/* We think this test detects Watcom and Microsoft C.  */
        -: 8077:/* This used to test MSDOS, but that is a bad idea
        -: 8078:   since that symbol is in the user namespace.  */
        -: 8079:#if (defined (_MSDOS) || defined (_MSDOS_)) && !defined (__TURBOC__)
        -: 8080:#if 0 /* No need for malloc.h, which pollutes the namespace;
        -: 8081:	 instead, just don't use alloca.  */
        -: 8082:#include <malloc.h>
        -: 8083:#endif
        -: 8084:#else /* not MSDOS, or __TURBOC__ */
        -: 8085:#if defined(_AIX)
        -: 8086:/* I don't know what this was needed for, but it pollutes the namespace.
        -: 8087:   So I turned it off.   rms, 2 May 1997.  */
        -: 8088:/* #include <malloc.h>  */
        -: 8089: #pragma alloca
        -: 8090:#define YYSTACK_USE_ALLOCA
        -: 8091:#else /* not MSDOS, or __TURBOC__, or _AIX */
        -: 8092:#if 0
        -: 8093:#ifdef __hpux /* haible@ilog.fr says this works for HPUX 9.05 and up,
        -: 8094:		 and on HPUX 10.  Eventually we can turn this on.  */
        -: 8095:#define YYSTACK_USE_ALLOCA
        -: 8096:#define alloca __builtin_alloca
        -: 8097:#endif /* __hpux */
        -: 8098:#endif
        -: 8099:#endif /* not _AIX */
        -: 8100:#endif /* not MSDOS, or __TURBOC__ */
        -: 8101:#endif /* not sparc */
        -: 8102:#endif /* not GNU C */
        -: 8103:#endif /* alloca not defined */
        -: 8104:#endif /* YYSTACK_USE_ALLOCA not defined */
        -: 8105:
        -: 8106:#ifdef YYSTACK_USE_ALLOCA
        -: 8107:#define YYSTACK_ALLOC alloca
        -: 8108:#else
        -: 8109:#define YYSTACK_ALLOC malloc
        -: 8110:#endif
        -: 8111:
        -: 8112:/* Note: there must be only one dollar sign in this file.
        -: 8113:   It is replaced by the list of actions, each action
        -: 8114:   as one case of the switch.  */
        -: 8115:
        -: 8116:#define yyerrok		(yyerrstatus = 0)
        -: 8117:#define yyclearin	(yychar = YYEMPTY)
        -: 8118:#define YYEMPTY		-2
        -: 8119:#define YYEOF		0
        -: 8120:#define YYACCEPT	goto yyacceptlab
        -: 8121:#define YYABORT 	goto yyabortlab
        -: 8122:#define YYERROR		goto yyerrlab1
        -: 8123:/* Like YYERROR except do call yyerror.
        -: 8124:   This remains here temporarily to ease the
        -: 8125:   transition to the new meaning of YYERROR, for GCC.
        -: 8126:   Once GCC version 2 has supplanted version 1, this can go.  */
        -: 8127:#define YYFAIL		goto yyerrlab
        -: 8128:#define YYRECOVERING()  (!!yyerrstatus)
        -: 8129:#define YYBACKUP(token, value) \
        -: 8130:do								\
        -: 8131:  if (yychar == YYEMPTY && yylen == 1)				\
        -: 8132:    { yychar = (token), yylval = (value);			\
        -: 8133:      yychar1 = YYTRANSLATE (yychar);				\
        -: 8134:      YYPOPSTACK;						\
        -: 8135:      goto yybackup;						\
        -: 8136:    }								\
        -: 8137:  else								\
        -: 8138:    { yyerror ("syntax error: cannot back up"); YYERROR; }	\
        -: 8139:while (0)
        -: 8140:
        -: 8141:#define YYTERROR	1
        -: 8142:#define YYERRCODE	256
        -: 8143:
        -: 8144:#ifndef YYPURE
        -: 8145:#define YYLEX		yylex()
        -: 8146:#endif
        -: 8147:
        -: 8148:#ifdef YYPURE
        -: 8149:#ifdef YYLSP_NEEDED
        -: 8150:#ifdef YYLEX_PARAM
        -: 8151:#define YYLEX		yylex(&yylval, &yylloc, YYLEX_PARAM)
        -: 8152:#else
        -: 8153:#define YYLEX		yylex(&yylval, &yylloc)
        -: 8154:#endif
        -: 8155:#else /* not YYLSP_NEEDED */
        -: 8156:#ifdef YYLEX_PARAM
        -: 8157:#define YYLEX		yylex(&yylval, YYLEX_PARAM)
        -: 8158:#else
        -: 8159:#define YYLEX		yylex(&yylval)
        -: 8160:#endif
        -: 8161:#endif /* not YYLSP_NEEDED */
        -: 8162:#endif
        -: 8163:
        -: 8164:/* If nonreentrant, generate the variables here */
        -: 8165:
        -: 8166:#ifndef YYPURE
        -: 8167:
        -: 8168:int	yychar;			/*  the lookahead symbol		*/
        -: 8169:YYSTYPE	yylval;			/*  the semantic value of the		*/
        -: 8170:				/*  lookahead symbol			*/
        -: 8171:
        -: 8172:#ifdef YYLSP_NEEDED
        -: 8173:YYLTYPE yylloc;			/*  location data for the lookahead	*/
        -: 8174:				/*  symbol				*/
        -: 8175:#endif
        -: 8176:
        -: 8177:int yynerrs;			/*  number of parse errors so far       */
        -: 8178:#endif  /* not YYPURE */
        -: 8179:
        -: 8180:#if YYDEBUG != 0
        -: 8181:int yydebug;			/*  nonzero means print parse trace	*/
        -: 8182:/* Since this is uninitialized, it does not stop multiple parsers
        -: 8183:   from coexisting.  */
        -: 8184:#endif
        -: 8185:
        -: 8186:/*  YYINITDEPTH indicates the initial size of the parser's stacks	*/
        -: 8187:
        -: 8188:#ifndef	YYINITDEPTH
        -: 8189:#define YYINITDEPTH 200
        -: 8190:#endif
        -: 8191:
        -: 8192:/*  YYMAXDEPTH is the maximum size the stacks can grow to
        -: 8193:    (effective only if the built-in stack extension method is used).  */
        -: 8194:
        -: 8195:#if YYMAXDEPTH == 0
        -: 8196:#undef YYMAXDEPTH
        -: 8197:#endif
        -: 8198:
        -: 8199:#ifndef YYMAXDEPTH
        -: 8200:#define YYMAXDEPTH 10000
        -: 8201:#endif
        -: 8202:/* Define __yy_memcpy.  Note that the size argument
        -: 8203:   should be passed with type unsigned int, because that is what the non-GCC
        -: 8204:   definitions require.  With GCC, __builtin_memcpy takes an arg
        -: 8205:   of type size_t, but it can handle unsigned int.  */
        -: 8206:
        -: 8207:#if __GNUC__ > 1		/* GNU C and GNU C++ define this.  */
        -: 8208:#define __yy_memcpy(TO,FROM,COUNT)	__builtin_memcpy(TO,FROM,COUNT)
        -: 8209:#else				/* not GNU C or C++ */
        -: 8210:#ifndef __cplusplus
        -: 8211:
        -: 8212:/* This is the most reliable way to avoid incompatibilities
        -: 8213:   in available built-in functions on various systems.  */
        -: 8214:static void
        -: 8215:__yy_memcpy (to, from, count)
        -: 8216:     char *to;
        -: 8217:     char *from;
        -: 8218:     unsigned int count;
        -: 8219:{
        -: 8220:  register char *f = from;
        -: 8221:  register char *t = to;
        -: 8222:  register int i = count;
        -: 8223:
        -: 8224:  while (i-- > 0)
        -: 8225:    *t++ = *f++;
        -: 8226:}
        -: 8227:
        -: 8228:#else /* __cplusplus */
        -: 8229:
        -: 8230:/* This is the most reliable way to avoid incompatibilities
        -: 8231:   in available built-in functions on various systems.  */
        -: 8232:static void
        -: 8233:__yy_memcpy (char *to, char *from, unsigned int count)
        -: 8234:{
        -: 8235:  register char *t = to;
        -: 8236:  register char *f = from;
        -: 8237:  register int i = count;
        -: 8238:
        -: 8239:  while (i-- > 0)
        -: 8240:    *t++ = *f++;
        -: 8241:}
        -: 8242:
        -: 8243:#endif
        -: 8244:#endif
        -: 8245:
        -: 8246:/* The user can define YYPARSE_PARAM as the name of an argument to be passed
        -: 8247:   into yyparse.  The argument should have type void *.
        -: 8248:   It should actually point to an object.
        -: 8249:   Grammar actions can access the variable by casting it
        -: 8250:   to the proper pointer type.  */
        -: 8251:
        -: 8252:#ifdef YYPARSE_PARAM
        -: 8253:#ifdef __cplusplus
        -: 8254:#define YYPARSE_PARAM_ARG void *YYPARSE_PARAM
        -: 8255:#define YYPARSE_PARAM_DECL
        -: 8256:#else /* not __cplusplus */
        -: 8257:#define YYPARSE_PARAM_ARG YYPARSE_PARAM
        -: 8258:#define YYPARSE_PARAM_DECL void *YYPARSE_PARAM;
        -: 8259:#endif /* not __cplusplus */
        -: 8260:#else /* not YYPARSE_PARAM */
        -: 8261:#define YYPARSE_PARAM_ARG
        -: 8262:#define YYPARSE_PARAM_DECL
        -: 8263:#endif /* not YYPARSE_PARAM */
        -: 8264:
        -: 8265:/* Prevent warning if -Wstrict-prototypes.  */
        -: 8266:#ifdef __GNUC__
        -: 8267:#ifdef YYPARSE_PARAM
        -: 8268:int yyparse (void *);
        -: 8269:#else
        -: 8270:int yyparse (void);
        -: 8271:#endif
        -: 8272:#endif
        -: 8273:
        -: 8274:int
function yyparse called 549 returned 100% blocks executed 76%
      549: 8275:yyparse(YYPARSE_PARAM_ARG)
        -: 8276:     YYPARSE_PARAM_DECL
        -: 8277:{
        -: 8278:  register int yystate;
        -: 8279:  register int yyn;
        -: 8280:  register short *yyssp;
        -: 8281:  register YYSTYPE *yyvsp;
        -: 8282:  int yyerrstatus;	/*  number of tokens to shift before error messages enabled */
      549: 8283:  int yychar1 = 0;		/*  lookahead token as an internal (translated) token number */
        -: 8284:
        -: 8285:  short	yyssa[YYINITDEPTH];	/*  the state stack			*/
        -: 8286:  YYSTYPE yyvsa[YYINITDEPTH];	/*  the semantic value stack		*/
        -: 8287:
      549: 8288:  short *yyss = yyssa;		/*  refer to the stacks thru separate pointers */
      549: 8289:  YYSTYPE *yyvs = yyvsa;	/*  to allow yyoverflow to reallocate them elsewhere */
        -: 8290:
        -: 8291:#ifdef YYLSP_NEEDED
        -: 8292:  YYLTYPE yylsa[YYINITDEPTH];	/*  the location stack			*/
        -: 8293:  YYLTYPE *yyls = yylsa;
        -: 8294:  YYLTYPE *yylsp;
        -: 8295:
        -: 8296:#define YYPOPSTACK   (yyvsp--, yyssp--, yylsp--)
        -: 8297:#else
        -: 8298:#define YYPOPSTACK   (yyvsp--, yyssp--)
        -: 8299:#endif
        -: 8300:
      549: 8301:  int yystacksize = YYINITDEPTH;
      549: 8302:  int yyfree_stacks = 0;
        -: 8303:
        -: 8304:#ifdef YYPURE
        -: 8305:  int yychar;
        -: 8306:  YYSTYPE yylval;
        -: 8307:  int yynerrs;
        -: 8308:#ifdef YYLSP_NEEDED
        -: 8309:  YYLTYPE yylloc;
        -: 8310:#endif
        -: 8311:#endif
        -: 8312:
        -: 8313:  YYSTYPE yyval;		/*  the variable used to return		*/
        -: 8314:				/*  semantic values from the action	*/
        -: 8315:				/*  routines				*/
        -: 8316:
        -: 8317:  int yylen;
        -: 8318:
        -: 8319:#if YYDEBUG != 0
        -: 8320:  if (yydebug)
        -: 8321:    fprintf(err, "Starting parse\n");
        -: 8322:#endif
        -: 8323:
      549: 8324:  yystate = 0;
      549: 8325:  yyerrstatus = 0;
      549: 8326:  yynerrs = 0;
      549: 8327:  yychar = YYEMPTY;		/* Cause a token to be read.  */
        -: 8328:
        -: 8329:  /* Initialize stack pointers.
        -: 8330:     Waste one element of value and location stack
        -: 8331:     so that they stay on the same level as the state stack.
        -: 8332:     The wasted elements are never initialized.  */
        -: 8333:
      549: 8334:  yyssp = yyss - 1;
      549: 8335:  yyvsp = yyvs;
        -: 8336:#ifdef YYLSP_NEEDED
        -: 8337:  yylsp = yyls;
        -: 8338:#endif
        -: 8339:
        -: 8340:/* Push a new state, which is found in  yystate  .  */
        -: 8341:/* In all cases, when you get here, the value and location stacks
        -: 8342:   have just been pushed. so pushing a state here evens the stacks.  */
    78848: 8343:yynewstate:
        -: 8344:
    78848: 8345:  *++yyssp = yystate;
        -: 8346:
    78848: 8347:  if (yyssp >= yyss + yystacksize - 1)
branch  0 taken 0 (fallthrough)
branch  1 taken 78848
        -: 8348:    {
        -: 8349:      /* Give user a chance to reallocate the stack */
        -: 8350:      /* Use copies of these so that the &'s don't force the real ones into memory. */
    #####: 8351:      YYSTYPE *yyvs1 = yyvs;
    #####: 8352:      short *yyss1 = yyss;
        -: 8353:#ifdef YYLSP_NEEDED
        -: 8354:      YYLTYPE *yyls1 = yyls;
        -: 8355:#endif
        -: 8356:
        -: 8357:      /* Get the current used size of the three stacks, in elements.  */
    #####: 8358:      int size = yyssp - yyss + 1;
        -: 8359:
        -: 8360:#ifdef yyoverflow
        -: 8361:      /* Each stack pointer address is followed by the size of
        -: 8362:	 the data in use in that stack, in bytes.  */
        -: 8363:#ifdef YYLSP_NEEDED
        -: 8364:      /* This used to be a conditional around just the two extra args,
        -: 8365:	 but that might be undefined if yyoverflow is a macro.  */
        -: 8366:      yyoverflow("parser stack overflow",
        -: 8367:		 &yyss1, size * sizeof (*yyssp),
        -: 8368:		 &yyvs1, size * sizeof (*yyvsp),
        -: 8369:		 &yyls1, size * sizeof (*yylsp),
        -: 8370:		 &yystacksize);
        -: 8371:#else
        -: 8372:      yyoverflow("parser stack overflow",
        -: 8373:		 &yyss1, size * sizeof (*yyssp),
        -: 8374:		 &yyvs1, size * sizeof (*yyvsp),
        -: 8375:		 &yystacksize);
        -: 8376:#endif
        -: 8377:
        -: 8378:      yyss = yyss1; yyvs = yyvs1;
        -: 8379:#ifdef YYLSP_NEEDED
        -: 8380:      yyls = yyls1;
        -: 8381:#endif
        -: 8382:#else /* no yyoverflow */
        -: 8383:      /* Extend the stack our own way.  */
    #####: 8384:      if (yystacksize >= YYMAXDEPTH)
branch  0 never executed
branch  1 never executed
        -: 8385:	{
    #####: 8386:	  yyerror("parser stack overflow");
call    0 never executed
    #####: 8387:	  if (yyfree_stacks)
branch  0 never executed
branch  1 never executed
        -: 8388:	    {
    #####: 8389:	      free (yyss);
    #####: 8390:	      free (yyvs);
        -: 8391:#ifdef YYLSP_NEEDED
        -: 8392:	      free (yyls);
        -: 8393:#endif
        -: 8394:	    }
    #####: 8395:	  return 2;
        -: 8396:	}
    #####: 8397:      yystacksize *= 2;
    #####: 8398:      if (yystacksize > YYMAXDEPTH)
branch  0 never executed
branch  1 never executed
    #####: 8399:	yystacksize = YYMAXDEPTH;
        -: 8400:#ifndef YYSTACK_USE_ALLOCA
        -: 8401:      yyfree_stacks = 1;
        -: 8402:#endif
    #####: 8403:      yyss = (short *) YYSTACK_ALLOC (yystacksize * sizeof (*yyssp));
    #####: 8404:      __yy_memcpy ((char *)yyss, (char *)yyss1,
        -: 8405:		   size * (unsigned int) sizeof (*yyssp));
    #####: 8406:      yyvs = (YYSTYPE *) YYSTACK_ALLOC (yystacksize * sizeof (*yyvsp));
    #####: 8407:      __yy_memcpy ((char *)yyvs, (char *)yyvs1,
        -: 8408:		   size * (unsigned int) sizeof (*yyvsp));
        -: 8409:#ifdef YYLSP_NEEDED
        -: 8410:      yyls = (YYLTYPE *) YYSTACK_ALLOC (yystacksize * sizeof (*yylsp));
        -: 8411:      __yy_memcpy ((char *)yyls, (char *)yyls1,
        -: 8412:		   size * (unsigned int) sizeof (*yylsp));
        -: 8413:#endif
        -: 8414:#endif /* no yyoverflow */
        -: 8415:
    #####: 8416:      yyssp = yyss + size - 1;
    #####: 8417:      yyvsp = yyvs + size - 1;
        -: 8418:#ifdef YYLSP_NEEDED
        -: 8419:      yylsp = yyls + size - 1;
        -: 8420:#endif
        -: 8421:
        -: 8422:#if YYDEBUG != 0
        -: 8423:      if (yydebug)
        -: 8424:	fprintf(err, "Stack size increased to %d\n", yystacksize);
        -: 8425:#endif
        -: 8426:
    #####: 8427:      if (yyssp >= yyss + yystacksize - 1)
branch  0 never executed
branch  1 never executed
    #####: 8428:	YYABORT;
        -: 8429:    }
        -: 8430:
        -: 8431:#if YYDEBUG != 0
        -: 8432:  if (yydebug)
        -: 8433:    fprintf(err, "Entering state %d\n", yystate);
        -: 8434:#endif
        -: 8435:
    78848: 8436:  goto yybackup;
    78848: 8437: yybackup:
        -: 8438:
        -: 8439:/* Do appropriate processing given the current state.  */
        -: 8440:/* Read a lookahead token if we need one and don't already have one.  */
        -: 8441:/* yyresume: */
        -: 8442:
        -: 8443:  /* First try to decide what to do without reference to lookahead token.  */
        -: 8444:
    78848: 8445:  yyn = yypact[yystate];
    78848: 8446:  if (yyn == YYFLAG)
branch  0 taken 28225 (fallthrough)
branch  1 taken 50623
    28225: 8447:    goto yydefault;
        -: 8448:
        -: 8449:  /* Not known => get a lookahead token if don't already have one.  */
        -: 8450:
        -: 8451:  /* yychar is either YYEMPTY or YYEOF
        -: 8452:     or a valid token in external form.  */
        -: 8453:
    50623: 8454:  if (yychar == YYEMPTY)
branch  0 taken 27966 (fallthrough)
branch  1 taken 22657
        -: 8455:    {
        -: 8456:#if YYDEBUG != 0
        -: 8457:      if (yydebug)
        -: 8458:	fprintf(err, "Reading a token: ");
        -: 8459:#endif
    27966: 8460:      yychar = YYLEX;
call    0 returned 27966
        -: 8461:    }
        -: 8462:
        -: 8463:  /* Convert token to internal form (in yychar1) for indexing tables with */
        -: 8464:
    50623: 8465:  if (yychar <= 0)		/* This means end of input. */
branch  0 taken 1647 (fallthrough)
branch  1 taken 48976
        -: 8466:    {
     1647: 8467:      yychar1 = 0;
     1647: 8468:      yychar = YYEOF;		/* Don't call YYLEX any more */
        -: 8469:
        -: 8470:#if YYDEBUG != 0
        -: 8471:      if (yydebug)
        -: 8472:	fprintf(err, "Now at end of input.\n");
        -: 8473:#endif
        -: 8474:    }
        -: 8475:  else
        -: 8476:    {
   48976*: 8477:      yychar1 = YYTRANSLATE(yychar);
branch  0 taken 48976 (fallthrough)
branch  1 taken 0
        -: 8478:
        -: 8479:#if YYDEBUG != 0
        -: 8480:      if (yydebug)
        -: 8481:	{
        -: 8482:	  fprintf (err, "Next token is %d (%s", yychar, yytname[yychar1]);
        -: 8483:	  /* Give the individual parser a way to print the precise meaning
        -: 8484:	     of a token, for further debugging info.  */
        -: 8485:#ifdef YYPRINT
        -: 8486:	  YYPRINT (err, yychar, yylval);
        -: 8487:#endif
        -: 8488:	  fprintf (err, ")\n");
        -: 8489:	}
        -: 8490:#endif
        -: 8491:    }
        -: 8492:
    50623: 8493:  yyn += yychar1;
    50623: 8494:  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != yychar1)
branch  0 taken 50623 (fallthrough)
branch  1 taken 0
branch  2 taken 50623 (fallthrough)
branch  3 taken 0
branch  4 taken 21011 (fallthrough)
branch  5 taken 29612
    21011: 8495:    goto yydefault;
        -: 8496:
    29612: 8497:  yyn = yytable[yyn];
        -: 8498:
        -: 8499:  /* yyn is what to do for this token type in this state.
        -: 8500:     Negative => reduce, -yyn is rule number.
        -: 8501:     Positive => shift, yyn is new state.
        -: 8502:       New state is final state => don't bother to shift,
        -: 8503:       just return success.
        -: 8504:     0, or most negative number => error.  */
        -: 8505:
    29612: 8506:  if (yyn < 0)
branch  0 taken 1106 (fallthrough)
branch  1 taken 28506
        -: 8507:    {
     1106: 8508:      if (yyn == YYFLAG)
branch  0 taken 0 (fallthrough)
branch  1 taken 1106
    #####: 8509:	goto yyerrlab;
     1106: 8510:      yyn = -yyn;
     1106: 8511:      goto yyreduce;
        -: 8512:    }
    28506: 8513:  else if (yyn == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 28506
    #####: 8514:    goto yyerrlab;
        -: 8515:
    28506: 8516:  if (yyn == YYFINAL)
branch  0 taken 549 (fallthrough)
branch  1 taken 27957
      549: 8517:    YYACCEPT;
        -: 8518:
        -: 8519:  /* Shift the lookahead token.  */
        -: 8520:
        -: 8521:#if YYDEBUG != 0
        -: 8522:  if (yydebug)
        -: 8523:    fprintf(err, "Shifting token %d (%s), ", yychar, yytname[yychar1]);
        -: 8524:#endif
        -: 8525:
        -: 8526:  /* Discard the token being shifted unless it is eof.  */
    27957: 8527:  if (yychar != YYEOF)
branch  0 taken 27408 (fallthrough)
branch  1 taken 549
    27408: 8528:    yychar = YYEMPTY;
        -: 8529:
    27957: 8530:  *++yyvsp = yylval;
        -: 8531:#ifdef YYLSP_NEEDED
        -: 8532:  *++yylsp = yylloc;
        -: 8533:#endif
        -: 8534:
        -: 8535:  /* count tokens shifted since error; after three, turn off error status.  */
    27957: 8536:  if (yyerrstatus) yyerrstatus--;
branch  0 taken 16 (fallthrough)
branch  1 taken 27941
        -: 8537:
    27957: 8538:  yystate = yyn;
    27957: 8539:  goto yynewstate;
        -: 8540:
        -: 8541:/* Do the default action for the current state.  */
    49236: 8542:yydefault:
        -: 8543:
    49236: 8544:  yyn = yydefact[yystate];
    49236: 8545:  if (yyn == 0)
branch  0 taken 15 (fallthrough)
branch  1 taken 49221
       15: 8546:    goto yyerrlab;
        -: 8547:
        -: 8548:/* Do a reduction.  yyn is the number of a rule to reduce with.  */
    49221: 8549:yyreduce:
    50327: 8550:  yylen = yyr2[yyn];
    50327: 8551:  if (yylen > 0)
branch  0 taken 42821 (fallthrough)
branch  1 taken 7506
    42821: 8552:    yyval = yyvsp[1-yylen]; /* implement default value of the action */
        -: 8553:
        -: 8554:#if YYDEBUG != 0
        -: 8555:  if (yydebug)
        -: 8556:    {
        -: 8557:      int i;
        -: 8558:
        -: 8559:      fprintf (err, "Reducing via rule %d (line %d), ",
        -: 8560:	       yyn, yyrline[yyn]);
        -: 8561:
        -: 8562:      /* Print the symbols being reduced, and their result.  */
        -: 8563:      for (i = yyprhs[yyn]; yyrhs[i] > 0; i++)
        -: 8564:	fprintf (err, "%s ", yytname[yyrhs[i]]);
        -: 8565:      fprintf (err, " -> %s\n", yytname[yyr1[yyn]]);
        -: 8566:    }
        -: 8567:#endif
        -: 8568:
        -: 8569:
    50327: 8570:  switch (yyn) {
branch  0 taken 549
branch  1 taken 549
branch  2 taken 0
branch  3 taken 549
branch  4 taken 1
branch  5 taken 12
branch  6 taken 0
branch  7 taken 13
branch  8 taken 0
branch  9 taken 3504
branch 10 taken 0
branch 11 taken 5
branch 12 taken 98
branch 13 taken 2837
branch 14 taken 4
branch 15 taken 5
branch 16 taken 15
branch 17 taken 1
branch 18 taken 8
branch 19 taken 0
branch 20 taken 10
branch 21 taken 98
branch 22 taken 0
branch 23 taken 100
branch 24 taken 2742
branch 25 taken 1081
branch 26 taken 3547
branch 27 taken 99
branch 28 taken 5406
branch 29 taken 4628
branch 30 taken 830
branch 31 taken 336
branch 32 taken 2
branch 33 taken 98
branch 34 taken 97
branch 35 taken 97
branch 36 taken 209
branch 37 taken 1273
branch 38 taken 222
branch 39 taken 1074
branch 40 taken 506
branch 41 taken 6750
branch 42 taken 1059
branch 43 taken 214
branch 44 taken 863
branch 45 taken 2435
branch 46 taken 1273
branch 47 taken 1970
branch 48 taken 1074
branch 49 taken 4084
        -: 8571:
      549: 8572:case 1:
        -: 8573:{ /* add default rule */
        -: 8574:			int def_rule;
        -: 8575:
      549: 8576:			pat = cclinit();
call    0 returned 549
      549: 8577:			cclnegate( pat );
call    0 returned 549
        -: 8578:
      549: 8579:			def_rule = mkstate( -pat );
call    0 returned 549
        -: 8580:
        -: 8581:			/* Remember the number of the default rule so we
        -: 8582:			 * don't generate "can't match" warnings for it.
        -: 8583:			 */
      549: 8584:			default_rule = num_rules;
        -: 8585:
      549: 8586:			finish_rule( def_rule, false, 0, 0 );
call    0 returned 549
        -: 8587:
     1111: 8588:			for ( i = 1; i <= lastsc; ++i )
branch  0 taken 562
branch  1 taken 549 (fallthrough)
      562: 8589:				scset[i] = mkbranch( scset[i], def_rule );
call    0 returned 562
        -: 8590:
      549: 8591:			if ( spprdflt )
branch  0 taken 3 (fallthrough)
branch  1 taken 546
        3: 8592:				add_action(
call    0 returned 3
        -: 8593:				"YY_FATAL_ERROR( \"flex scanner jammed\" )" );
        -: 8594:			else
      546: 8595:				add_action( "ECHO" );
call    0 returned 546
        -: 8596:
      549: 8597:			add_action( ";\n\tYY_BREAK\n" );
call    0 returned 549
        -: 8598:			;
      549: 8599:    break;}
      549: 8600:case 2:
        -: 8601:{ /* initialize for processing rules */
        -: 8602:
        -: 8603:			/* Create default DFA start condition. */
      549: 8604:			scinstal( "INITIAL", false );
call    0 returned 549
        -: 8605:
        -: 8606:			/* Initially, the start condition scoping is
        -: 8607:			 * "no start conditions active".
        -: 8608:			 */
      549: 8609:			actvp = 0;
        -: 8610:			;
      549: 8611:    break;}
    #####: 8612:case 5:
    #####: 8613:{ synerr( "unknown error processing section 1" ); ;
call    0 never executed
    #####: 8614:    break;}
      549: 8615:case 6:
        -: 8616:{
        -: 8617:			/* We now know how many start conditions there
        -: 8618:			 * are, so create the "activity" map indicating
        -: 8619:			 * which conditions are active.
        -: 8620:			 */
      549: 8621:			active_ss = allocate_integer_array( lastsc + 1 );
call    0 returned 549
        -: 8622:
     1111: 8623:			for ( i = 1; i <= lastsc; ++i )
branch  0 taken 562
branch  1 taken 549 (fallthrough)
      562: 8624:				active_ss[i] = 0;
        -: 8625:			;
      549: 8626:    break;}
        1: 8627:case 7:
        1: 8628:{ xcluflg = false; ;
        1: 8629:    break;}
       12: 8630:case 8:
       12: 8631:{ xcluflg = true; ;
       12: 8632:    break;}
    #####: 8633:case 9:
    #####: 8634:{ scinstal( nmstr, xcluflg ); ;
call    0 never executed
    #####: 8635:    break;}
       13: 8636:case 10:
       13: 8637:{ scinstal( nmstr, xcluflg ); ;
call    0 returned 13
       13: 8638:    break;}
    #####: 8639:case 11:
    #####: 8640:{ synerr( "bad start condition list" ); ;
call    0 never executed
    #####: 8641:    break;}
     3504: 8642:case 14:
        -: 8643:{
        -: 8644:			/* Initialize for a parse of one rule. */
     3504: 8645:			trlcontxt = variable_trail_rule = varlength = false;
     3504: 8646:			trailcnt = headcnt = rulelen = 0;
     3504: 8647:			current_state_type = STATE_NORMAL;
     3504: 8648:			previous_continued_action = continued_action;
     3504: 8649:			new_rule();
call    0 returned 3504
        -: 8650:			;
     3504: 8651:    break;}
    #####: 8652:case 15:
        -: 8653:{
    #####: 8654:			pat = yyvsp[0];
    #####: 8655:			finish_rule( pat, variable_trail_rule,
call    0 never executed
        -: 8656:				headcnt, trailcnt );
        -: 8657:
    #####: 8658:			for ( i = 1; i <= actvp; ++i )
branch  0 never executed
branch  1 never executed
    #####: 8659:				scbol[actvsc[i]] =
    #####: 8660:					mkbranch( scbol[actvsc[i]], pat );
call    0 never executed
        -: 8661:
    #####: 8662:			if ( ! bol_needed )
branch  0 never executed
branch  1 never executed
        -: 8663:				{
    #####: 8664:				bol_needed = true;
        -: 8665:
    #####: 8666:				if ( performance_report > 1 )
branch  0 never executed
branch  1 never executed
    #####: 8667:					pinpoint_message( 
call    0 never executed
        -: 8668:			"'^' operator results in sub-optimal performance" );
        -: 8669:				}
        -: 8670:			;
    #####: 8671:    break;}
        5: 8672:case 16:
        -: 8673:{
        5: 8674:			pat = yyvsp[0];
        5: 8675:			finish_rule( pat, variable_trail_rule,
call    0 returned 5
        -: 8676:				headcnt, trailcnt );
        -: 8677:
       16: 8678:			for ( i = 1; i <= actvp; ++i )
branch  0 taken 11
branch  1 taken 5 (fallthrough)
       11: 8679:				scset[actvsc[i]] =
       11: 8680:					mkbranch( scset[actvsc[i]], pat );
call    0 returned 11
        -: 8681:			;
        5: 8682:    break;}
       98: 8683:case 17:
        -: 8684:{
       98: 8685:			pat = yyvsp[0];
       98: 8686:			finish_rule( pat, variable_trail_rule,
call    0 returned 98
        -: 8687:				headcnt, trailcnt );
        -: 8688:
        -: 8689:			/* Add to all non-exclusive start conditions,
        -: 8690:			 * including the default (0) start condition.
        -: 8691:			 */
        -: 8692:
      196: 8693:			for ( i = 1; i <= lastsc; ++i )
branch  0 taken 98
branch  1 taken 98 (fallthrough)
       98: 8694:				if ( ! scxclu[i] )
branch  0 taken 98 (fallthrough)
branch  1 taken 0
       98: 8695:					scbol[i] = mkbranch( scbol[i], pat );
call    0 returned 98
        -: 8696:
       98: 8697:			if ( ! bol_needed )
branch  0 taken 98 (fallthrough)
branch  1 taken 0
        -: 8698:				{
       98: 8699:				bol_needed = true;
        -: 8700:
       98: 8701:				if ( performance_report > 1 )
branch  0 taken 0 (fallthrough)
branch  1 taken 98
    #####: 8702:					pinpoint_message(
call    0 never executed
        -: 8703:			"'^' operator results in sub-optimal performance" );
        -: 8704:				}
        -: 8705:			;
       98: 8706:    break;}
     2837: 8707:case 18:
        -: 8708:{
     2837: 8709:			pat = yyvsp[0];
     2837: 8710:			finish_rule( pat, variable_trail_rule,
call    0 returned 2837
        -: 8711:				headcnt, trailcnt );
        -: 8712:
     5737: 8713:			for ( i = 1; i <= lastsc; ++i )
branch  0 taken 2900
branch  1 taken 2837 (fallthrough)
     2900: 8714:				if ( ! scxclu[i] )
branch  0 taken 2849 (fallthrough)
branch  1 taken 51
     2849: 8715:					scset[i] = mkbranch( scset[i], pat );
call    0 returned 2849
        -: 8716:			;
     2837: 8717:    break;}
        4: 8718:case 19:
        4: 8719:{ build_eof_action(); ;
call    0 returned 4
        4: 8720:    break;}
        5: 8721:case 20:
        -: 8722:{
        -: 8723:			/* This EOF applies to all start conditions
        -: 8724:			 * which don't already have EOF actions.
        -: 8725:			 */
        5: 8726:			actvp = 0;
        -: 8727:
       19: 8728:			for ( i = 1; i <= lastsc; ++i )
branch  0 taken 14
branch  1 taken 5 (fallthrough)
       14: 8729:				if ( ! sceof[i] )
branch  0 taken 11 (fallthrough)
branch  1 taken 3
       11: 8730:					actvsc[++actvp] = i;
        -: 8731:
        5: 8732:			if ( actvp == 0 )
branch  0 taken 0 (fallthrough)
branch  1 taken 5
    #####: 8733:				warn(
call    0 never executed
        -: 8734:			"all start conditions already have <<EOF>> rules" );
        -: 8735:
        -: 8736:			else
        5: 8737:				build_eof_action();
call    0 returned 5
        -: 8738:			;
        5: 8739:    break;}
       15: 8740:case 21:
       15: 8741:{ synerr( "unrecognized rule" ); ;
call    0 returned 15
       15: 8742:    break;}
        1: 8743:case 23:
        -: 8744:{
        1: 8745:			actvp = 0;
        -: 8746:
        6: 8747:			for ( i = 1; i <= lastsc; ++i )
branch  0 taken 5
branch  1 taken 1 (fallthrough)
        5: 8748:				actvsc[++actvp] = i;
        -: 8749:			;
        1: 8750:    break;}
        8: 8751:case 25:
        8: 8752:{ actvp = 0; ;
        8: 8753:    break;}
    #####: 8754:case 27:
    #####: 8755:{ synerr( "bad start condition list" ); ;
call    0 never executed
    #####: 8756:    break;}
       10: 8757:case 28:
        -: 8758:{
       10: 8759:			if ( (scnum = sclookup( nmstr )) == 0 )
call    0 returned 10
branch  1 taken 0 (fallthrough)
branch  2 taken 10
    #####: 8760:				format_pinpoint_message(
call    0 never executed
        -: 8761:					"undeclared start condition %s",
        -: 8762:					nmstr );
        -: 8763:			else
        -: 8764:				{
       10: 8765:				if ( ++actvp >= current_max_scs )
branch  0 taken 0 (fallthrough)
branch  1 taken 10
        -: 8766:					/* Some bozo has included multiple
        -: 8767:					 * instances of start condition names.
        -: 8768:					 */
    #####: 8769:					pinpoint_message(
call    0 never executed
        -: 8770:				"too many start conditions in <> construct!" );
        -: 8771:
        -: 8772:				else
       10: 8773:					actvsc[actvp] = scnum;
        -: 8774:				}
        -: 8775:			;
       10: 8776:    break;}
       98: 8777:case 29:
        -: 8778:{
       98: 8779:			if ( transchar[lastst[yyvsp[0]]] != SYM_EPSILON )
branch  0 taken 96 (fallthrough)
branch  1 taken 2
        -: 8780:				/* Provide final transition \now/ so it
        -: 8781:				 * will be marked as a trailing context
        -: 8782:				 * state.
        -: 8783:				 */
       96: 8784:				yyvsp[0] = link_machines( yyvsp[0],
call    0 returned 96
call    1 returned 96
        -: 8785:						mkstate( SYM_EPSILON ) );
        -: 8786:
       98: 8787:			mark_beginning_as_normal( yyvsp[0] );
call    0 returned 98
       98: 8788:			current_state_type = STATE_NORMAL;
        -: 8789:
       98: 8790:			if ( previous_continued_action )
branch  0 taken 2 (fallthrough)
branch  1 taken 96
        -: 8791:				{
        -: 8792:				/* We need to treat this as variable trailing
        -: 8793:				 * context so that the backup does not happen
        -: 8794:				 * in the action but before the action switch
        -: 8795:				 * statement.  If the backup happens in the
        -: 8796:				 * action, then the rules "falling into" this
        -: 8797:				 * one's action will *also* do the backup,
        -: 8798:				 * erroneously.
        -: 8799:				 */
        2: 8800:				if ( ! varlength || headcnt != 0 )
branch  0 taken 2 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 2
    #####: 8801:					warn(
call    0 never executed
        -: 8802:		"trailing context made variable due to preceding '|' action" );
        -: 8803:
        -: 8804:				/* Mark as variable. */
        2: 8805:				varlength = true;
        2: 8806:				headcnt = 0;
        -: 8807:				}
        -: 8808:
       98: 8809:			if ( lex_compat || (varlength && headcnt == 0) )
branch  0 taken 67 (fallthrough)
branch  1 taken 31
branch  2 taken 2 (fallthrough)
branch  3 taken 65
branch  4 taken 2 (fallthrough)
branch  5 taken 0
        -: 8810:				{ /* variable trailing context rule */
        -: 8811:				/* Mark the first part of the rule as the
        -: 8812:				 * accepting "head" part of a trailing
        -: 8813:				 * context rule.
        -: 8814:				 *
        -: 8815:				 * By the way, we didn't do this at the
        -: 8816:				 * beginning of this production because back
        -: 8817:				 * then current_state_type was set up for a
        -: 8818:				 * trail rule, and add_accept() can create
        -: 8819:				 * a new state ...
        -: 8820:				 */
       33: 8821:				add_accept( yyvsp[-1],
call    0 returned 33
        -: 8822:					num_rules | YY_TRAILING_HEAD_MASK );
       33: 8823:				variable_trail_rule = true;
        -: 8824:				}
        -: 8825:			
        -: 8826:			else
       65: 8827:				trailcnt = rulelen;
        -: 8828:
       98: 8829:			yyval = link_machines( yyvsp[-1], yyvsp[0] );
call    0 returned 98
        -: 8830:			;
       98: 8831:    break;}
    #####: 8832:case 30:
    #####: 8833:{ synerr( "trailing context used twice" ); ;
call    0 never executed
    #####: 8834:    break;}
      100: 8835:case 31:
        -: 8836:{
      100: 8837:			if ( trlcontxt )
branch  0 taken 0 (fallthrough)
branch  1 taken 100
        -: 8838:				{
    #####: 8839:				synerr( "trailing context used twice" );
call    0 never executed
    #####: 8840:				yyval = mkstate( SYM_EPSILON );
call    0 never executed
        -: 8841:				}
        -: 8842:
      100: 8843:			else if ( previous_continued_action )
branch  0 taken 0 (fallthrough)
branch  1 taken 100
        -: 8844:				{
        -: 8845:				/* See the comment in the rule for "re2 re"
        -: 8846:				 * above.
        -: 8847:				 */
    #####: 8848:				if ( ! varlength || headcnt != 0 )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 8849:					warn(
call    0 never executed
        -: 8850:		"trailing context made variable due to preceding '|' action" );
        -: 8851:
        -: 8852:				/* Mark as variable. */
    #####: 8853:				varlength = true;
    #####: 8854:				headcnt = 0;
        -: 8855:				}
        -: 8856:
      100: 8857:			if ( lex_compat || (varlength && headcnt == 0) )
branch  0 taken 69 (fallthrough)
branch  1 taken 31
branch  2 taken 2 (fallthrough)
branch  3 taken 67
branch  4 taken 2 (fallthrough)
branch  5 taken 0
        -: 8858:				{
        -: 8859:				/* Again, see the comment in the rule for
        -: 8860:				 * "re2 re" above.
        -: 8861:				 */
       33: 8862:				add_accept( yyvsp[-1],
call    0 returned 33
        -: 8863:					num_rules | YY_TRAILING_HEAD_MASK );
       33: 8864:				variable_trail_rule = true;
        -: 8865:				}
        -: 8866:
        -: 8867:			else
        -: 8868:				{
       67: 8869:				if ( ! varlength )
branch  0 taken 67 (fallthrough)
branch  1 taken 0
       67: 8870:					headcnt = rulelen;
        -: 8871:
       67: 8872:				++rulelen;
       67: 8873:				trailcnt = 1;
        -: 8874:				}
        -: 8875:
      100: 8876:			trlcontxt = true;
        -: 8877:
      100: 8878:			eps = mkstate( SYM_EPSILON );
call    0 returned 100
      100: 8879:			yyval = link_machines( yyvsp[-1],
call    0 returned 100
call    1 returned 100
call    2 returned 100
        -: 8880:				link_machines( eps, mkstate( '\n' ) ) );
        -: 8881:			;
      100: 8882:    break;}
     2742: 8883:case 32:
        -: 8884:{
     2742: 8885:			yyval = yyvsp[0];
        -: 8886:
     2742: 8887:			if ( trlcontxt )
branch  0 taken 0 (fallthrough)
branch  1 taken 2742
        -: 8888:				{
    #####: 8889:				if ( lex_compat || (varlength && headcnt == 0) )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 8890:					/* Both head and trail are
        -: 8891:					 * variable-length.
        -: 8892:					 */
    #####: 8893:					variable_trail_rule = true;
        -: 8894:				else
    #####: 8895:					trailcnt = rulelen;
        -: 8896:				}
        -: 8897:			;
     2742: 8898:    break;}
     1081: 8899:case 33:
        -: 8900:{
     1081: 8901:			varlength = true;
     1081: 8902:			yyval = mkor( yyvsp[-2], yyvsp[0] );
call    0 returned 1081
        -: 8903:			;
     1081: 8904:    break;}
     3547: 8905:case 34:
     3547: 8906:{ yyval = yyvsp[0]; ;
     3547: 8907:    break;}
       99: 8908:case 35:
        -: 8909:{
        -: 8910:			/* This rule is written separately so the
        -: 8911:			 * reduction will occur before the trailing
        -: 8912:			 * series is parsed.
        -: 8913:			 */
        -: 8914:
       99: 8915:			if ( trlcontxt )
branch  0 taken 0 (fallthrough)
branch  1 taken 99
    #####: 8916:				synerr( "trailing context used twice" );
call    0 never executed
        -: 8917:			else
       99: 8918:				trlcontxt = true;
        -: 8919:
       99: 8920:			if ( varlength )
branch  0 taken 3 (fallthrough)
branch  1 taken 96
        -: 8921:				/* We hope the trailing context is
        -: 8922:				 * fixed-length.
        -: 8923:				 */
        3: 8924:				varlength = false;
        -: 8925:			else
       96: 8926:				headcnt = rulelen;
        -: 8927:
       99: 8928:			rulelen = 0;
        -: 8929:
       99: 8930:			current_state_type = STATE_TRAILING_CONTEXT;
       99: 8931:			yyval = yyvsp[-1];
        -: 8932:			;
       99: 8933:    break;}
     5406: 8934:case 36:
        -: 8935:{
        -: 8936:			/* This is where concatenation of adjacent patterns
        -: 8937:			 * gets done.
        -: 8938:			 */
     5406: 8939:			yyval = link_machines( yyvsp[-1], yyvsp[0] );
call    0 returned 5406
        -: 8940:			;
     5406: 8941:    break;}
     4628: 8942:case 37:
     4628: 8943:{ yyval = yyvsp[0]; ;
     4628: 8944:    break;}
      830: 8945:case 38:
        -: 8946:{
      830: 8947:			varlength = true;
        -: 8948:
      830: 8949:			yyval = mkclos( yyvsp[-1] );
call    0 returned 830
        -: 8950:			;
      830: 8951:    break;}
      336: 8952:case 39:
        -: 8953:{
      336: 8954:			varlength = true;
      336: 8955:			yyval = mkposcl( yyvsp[-1] );
call    0 returned 336
        -: 8956:			;
      336: 8957:    break;}
        2: 8958:case 40:
        -: 8959:{
        2: 8960:			varlength = true;
        2: 8961:			yyval = mkopt( yyvsp[-1] );
call    0 returned 2
        -: 8962:			;
        2: 8963:    break;}
       98: 8964:case 41:
        -: 8965:{
       98: 8966:			varlength = true;
        -: 8967:
       98: 8968:			if ( yyvsp[-3] > yyvsp[-1] || yyvsp[-3] < 0 )
branch  0 taken 98 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 98
        -: 8969:				{
    #####: 8970:				synerr( "bad iteration values" );
call    0 never executed
    #####: 8971:				yyval = yyvsp[-5];
        -: 8972:				}
        -: 8973:			else
        -: 8974:				{
       98: 8975:				if ( yyvsp[-3] == 0 )
branch  0 taken 0 (fallthrough)
branch  1 taken 98
        -: 8976:					{
    #####: 8977:					if ( yyvsp[-1] <= 0 )
branch  0 never executed
branch  1 never executed
        -: 8978:						{
    #####: 8979:						synerr(
call    0 never executed
        -: 8980:						"bad iteration values" );
    #####: 8981:						yyval = yyvsp[-5];
        -: 8982:						}
        -: 8983:					else
    #####: 8984:						yyval = mkopt(
call    0 never executed
    #####: 8985:							mkrep( yyvsp[-5], 1, yyvsp[-1] ) );
call    0 never executed
        -: 8986:					}
        -: 8987:				else
       98: 8988:					yyval = mkrep( yyvsp[-5], yyvsp[-3], yyvsp[-1] );
call    0 returned 98
        -: 8989:				}
        -: 8990:			;
       98: 8991:    break;}
       97: 8992:case 42:
        -: 8993:{
       97: 8994:			varlength = true;
        -: 8995:
       97: 8996:			if ( yyvsp[-2] <= 0 )
branch  0 taken 0 (fallthrough)
branch  1 taken 97
        -: 8997:				{
    #####: 8998:				synerr( "iteration value must be positive" );
call    0 never executed
    #####: 8999:				yyval = yyvsp[-4];
        -: 9000:				}
        -: 9001:
        -: 9002:			else
       97: 9003:				yyval = mkrep( yyvsp[-4], yyvsp[-2], INFINITY );
call    0 returned 97
        -: 9004:			;
       97: 9005:    break;}
       97: 9006:case 43:
        -: 9007:{
        -: 9008:			/* The singleton could be something like "(foo)",
        -: 9009:			 * in which case we have no idea what its length
        -: 9010:			 * is, so we punt here.
        -: 9011:			 */
       97: 9012:			varlength = true;
        -: 9013:
       97: 9014:			if ( yyvsp[-1] <= 0 )
branch  0 taken 0 (fallthrough)
branch  1 taken 97
        -: 9015:				{
    #####: 9016:				synerr( "iteration value must be positive" );
call    0 never executed
    #####: 9017:				yyval = yyvsp[-3];
        -: 9018:				}
        -: 9019:
        -: 9020:			else
       97: 9021:				yyval = link_machines( yyvsp[-3],
call    0 returned 97
       97: 9022:						copysingl( yyvsp[-3], yyvsp[-1] - 1 ) );
call    0 returned 97
        -: 9023:			;
       97: 9024:    break;}
      209: 9025:case 44:
        -: 9026:{
      209: 9027:			if ( ! madeany )
branch  0 taken 209 (fallthrough)
branch  1 taken 0
        -: 9028:				{
        -: 9029:				/* Create the '.' character class. */
      209: 9030:				anyccl = cclinit();
call    0 returned 209
      209: 9031:				ccladd( anyccl, '\n' );
call    0 returned 209
      209: 9032:				cclnegate( anyccl );
call    0 returned 209
        -: 9033:
      209: 9034:				if ( useecs )
branch  0 taken 114 (fallthrough)
branch  1 taken 95
      114: 9035:					mkeccl( ccltbl + cclmap[anyccl],
      114: 9036:						ccllen[anyccl], nextecm,
call    0 returned 114
        -: 9037:						ecgroup, csize, csize );
        -: 9038:
      209: 9039:				madeany = true;
        -: 9040:				}
        -: 9041:
      209: 9042:			++rulelen;
        -: 9043:
      209: 9044:			yyval = mkstate( -anyccl );
call    0 returned 209
        -: 9045:			;
      209: 9046:    break;}
     1273: 9047:case 45:
        -: 9048:{
     1273: 9049:			if ( ! cclsorted )
branch  0 taken 835 (fallthrough)
branch  1 taken 438
        -: 9050:				/* Sort characters for fast searching.  We
        -: 9051:				 * use a shell sort since this list could
        -: 9052:				 * be large.
        -: 9053:				 */
      835: 9054:				cshell( ccltbl + cclmap[yyvsp[0]], ccllen[yyvsp[0]], true );
call    0 returned 835
        -: 9055:
     1273: 9056:			if ( useecs )
branch  0 taken 792 (fallthrough)
branch  1 taken 481
      792: 9057:				mkeccl( ccltbl + cclmap[yyvsp[0]], ccllen[yyvsp[0]],
call    0 returned 792
        -: 9058:					nextecm, ecgroup, csize, csize );
        -: 9059:
     1273: 9060:			++rulelen;
        -: 9061:
     1273: 9062:			yyval = mkstate( -yyvsp[0] );
call    0 returned 1273
        -: 9063:			;
     1273: 9064:    break;}
      222: 9065:case 46:
        -: 9066:{
      222: 9067:			++rulelen;
        -: 9068:
      222: 9069:			yyval = mkstate( -yyvsp[0] );
call    0 returned 222
        -: 9070:			;
      222: 9071:    break;}
     1074: 9072:case 47:
     1074: 9073:{ yyval = yyvsp[-1]; ;
     1074: 9074:    break;}
      506: 9075:case 48:
      506: 9076:{ yyval = yyvsp[-1]; ;
      506: 9077:    break;}
     6750: 9078:case 49:
        -: 9079:{
     6750: 9080:			++rulelen;
        -: 9081:
     6750: 9082:			if ( caseins && yyvsp[0] >= 'A' && yyvsp[0] <= 'Z' )
branch  0 taken 73 (fallthrough)
branch  1 taken 6677
branch  2 taken 72 (fallthrough)
branch  3 taken 1
branch  4 taken 0 (fallthrough)
branch  5 taken 72
    #####: 9083:				yyvsp[0] = clower( yyvsp[0] );
call    0 never executed
        -: 9084:
     6750: 9085:			yyval = mkstate( yyvsp[0] );
call    0 returned 6750
        -: 9086:			;
     6750: 9087:    break;}
     1059: 9088:case 50:
     1059: 9089:{ yyval = yyvsp[-1]; ;
     1059: 9090:    break;}
      214: 9091:case 51:
        -: 9092:{
      214: 9093:			cclnegate( yyvsp[-1] );
call    0 returned 214
      214: 9094:			yyval = yyvsp[-1];
        -: 9095:			;
      214: 9096:    break;}
      863: 9097:case 52:
        -: 9098:{
      863: 9099:			if ( caseins )
branch  0 taken 9 (fallthrough)
branch  1 taken 854
        -: 9100:				{
        9: 9101:				if ( yyvsp[-2] >= 'A' && yyvsp[-2] <= 'Z' )
branch  0 taken 4 (fallthrough)
branch  1 taken 5
branch  2 taken 0 (fallthrough)
branch  3 taken 4
    #####: 9102:					yyvsp[-2] = clower( yyvsp[-2] );
call    0 never executed
        9: 9103:				if ( yyvsp[0] >= 'A' && yyvsp[0] <= 'Z' )
branch  0 taken 4 (fallthrough)
branch  1 taken 5
branch  2 taken 0 (fallthrough)
branch  3 taken 4
    #####: 9104:					yyvsp[0] = clower( yyvsp[0] );
call    0 never executed
        -: 9105:				}
        -: 9106:
      863: 9107:			if ( yyvsp[-2] > yyvsp[0] )
branch  0 taken 2 (fallthrough)
branch  1 taken 861
        2: 9108:				synerr( "negative range in character class" );
call    0 returned 2
        -: 9109:
        -: 9110:			else
        -: 9111:				{
    23030: 9112:				for ( i = yyvsp[-2]; i <= yyvsp[0]; ++i )
branch  0 taken 22169
branch  1 taken 861 (fallthrough)
    22169: 9113:					ccladd( yyvsp[-3], i );
call    0 returned 22169
        -: 9114:
        -: 9115:				/* Keep track if this ccl is staying in
        -: 9116:				 * alphabetical order.
        -: 9117:				 */
      861: 9118:				cclsorted = cclsorted && (yyvsp[-2] > lastchar);
branch  0 taken 831 (fallthrough)
branch  1 taken 30
branch  2 taken 546 (fallthrough)
branch  3 taken 285
      861: 9119:				lastchar = yyvsp[0];
        -: 9120:				}
        -: 9121:
      863: 9122:			yyval = yyvsp[-3];
        -: 9123:			;
      863: 9124:    break;}
     2435: 9125:case 53:
        -: 9126:{
     2435: 9127:			if ( caseins && yyvsp[0] >= 'A' && yyvsp[0] <= 'Z' )
branch  0 taken 10 (fallthrough)
branch  1 taken 2425
branch  2 taken 2 (fallthrough)
branch  3 taken 8
branch  4 taken 0 (fallthrough)
branch  5 taken 2
    #####: 9128:				yyvsp[0] = clower( yyvsp[0] );
call    0 never executed
        -: 9129:
     2435: 9130:			ccladd( yyvsp[-1], yyvsp[0] );
call    0 returned 2435
     2435: 9131:			cclsorted = cclsorted && (yyvsp[0] > lastchar);
branch  0 taken 2320 (fallthrough)
branch  1 taken 115
branch  2 taken 1770 (fallthrough)
branch  3 taken 550
     2435: 9132:			lastchar = yyvsp[0];
     2435: 9133:			yyval = yyvsp[-1];
        -: 9134:			;
     2435: 9135:    break;}
     1273: 9136:case 54:
        -: 9137:{
     1273: 9138:			cclsorted = true;
     1273: 9139:			lastchar = 0;
     1273: 9140:			yyval = cclinit();
call    0 returned 1273
        -: 9141:			;
     1273: 9142:    break;}
     1970: 9143:case 55:
        -: 9144:{
     1970: 9145:			if ( caseins && yyvsp[0] >= 'A' && yyvsp[0] <= 'Z' )
branch  0 taken 18 (fallthrough)
branch  1 taken 1952
branch  2 taken 6 (fallthrough)
branch  3 taken 12
branch  4 taken 0 (fallthrough)
branch  5 taken 6
    #####: 9146:				yyvsp[0] = clower( yyvsp[0] );
call    0 never executed
        -: 9147:
     1970: 9148:			++rulelen;
        -: 9149:
     1970: 9150:			yyval = link_machines( yyvsp[-1], mkstate( yyvsp[0] ) );
call    0 returned 1970
call    1 returned 1970
        -: 9151:			;
     1970: 9152:    break;}
     1074: 9153:case 56:
     1074: 9154:{ yyval = mkstate( SYM_EPSILON ); ;
call    0 returned 1074
     1074: 9155:    break;}
        -: 9156:}
        -: 9157:   /* the action file gets copied in in place of this dollarsign */
    50327: 9158:  yyvsp -= yylen;
    50327: 9159:  yyssp -= yylen;
        -: 9160:#ifdef YYLSP_NEEDED
        -: 9161:  yylsp -= yylen;
        -: 9162:#endif
        -: 9163:
        -: 9164:#if YYDEBUG != 0
        -: 9165:  if (yydebug)
        -: 9166:    {
        -: 9167:      short *ssp1 = yyss - 1;
        -: 9168:      fprintf (err, "state stack now");
        -: 9169:      while (ssp1 != yyssp)
        -: 9170:	fprintf (err, " %d", *++ssp1);
        -: 9171:      fprintf (err, "\n");
        -: 9172:    }
        -: 9173:#endif
        -: 9174:
    50327: 9175:  *++yyvsp = yyval;
        -: 9176:
        -: 9177:#ifdef YYLSP_NEEDED
        -: 9178:  yylsp++;
        -: 9179:  if (yylen == 0)
        -: 9180:    {
        -: 9181:      yylsp->first_line = yylloc.first_line;
        -: 9182:      yylsp->first_column = yylloc.first_column;
        -: 9183:      yylsp->last_line = (yylsp-1)->last_line;
        -: 9184:      yylsp->last_column = (yylsp-1)->last_column;
        -: 9185:      yylsp->text = 0;
        -: 9186:    }
        -: 9187:  else
        -: 9188:    {
        -: 9189:      yylsp->last_line = (yylsp+yylen-1)->last_line;
        -: 9190:      yylsp->last_column = (yylsp+yylen-1)->last_column;
        -: 9191:    }
        -: 9192:#endif
        -: 9193:
        -: 9194:  /* Now "shift" the result of the reduction.
        -: 9195:     Determine what state that goes to,
        -: 9196:     based on the state we popped back to
        -: 9197:     and the rule number reduced by.  */
        -: 9198:
    50327: 9199:  yyn = yyr1[yyn];
        -: 9200:
    50327: 9201:  yystate = yypgoto[yyn - YYNTBASE] + *yyssp;
    50327: 9202:  if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *yyssp)
branch  0 taken 26362 (fallthrough)
branch  1 taken 23965
branch  2 taken 26362 (fallthrough)
branch  3 taken 0
branch  4 taken 11406 (fallthrough)
branch  5 taken 14956
    11406: 9203:    yystate = yytable[yystate];
        -: 9204:  else
    38921: 9205:    yystate = yydefgoto[yyn - YYNTBASE];
        -: 9206:
    50327: 9207:  goto yynewstate;
        -: 9208:
       15: 9209:yyerrlab:   /* here on detecting error */
        -: 9210:
       15: 9211:  if (! yyerrstatus)
branch  0 taken 5 (fallthrough)
branch  1 taken 10
        -: 9212:    /* If not already recovering from an error, report this error.  */
        -: 9213:    {
        5: 9214:      ++yynerrs;
        -: 9215:
        -: 9216:#ifdef YYERROR_VERBOSE
        -: 9217:      yyn = yypact[yystate];
        -: 9218:
        -: 9219:      if (yyn > YYFLAG && yyn < YYLAST)
        -: 9220:	{
        -: 9221:	  int size = 0;
        -: 9222:	  char *msg;
        -: 9223:	  int x, count;
        -: 9224:
        -: 9225:	  count = 0;
        -: 9226:	  /* Start X at -yyn if nec to avoid negative indexes in yycheck.  */
        -: 9227:	  for (x = (yyn < 0 ? -yyn : 0);
        -: 9228:	       x < (sizeof(yytname) / sizeof(char *)); x++)
        -: 9229:	    if (yycheck[x + yyn] == x)
        -: 9230:	      size += strlen(yytname[x]) + 15, count++;
        -: 9231:	  msg = (char *) malloc(size + 15);
        -: 9232:	  if (msg != 0)
        -: 9233:	    {
        -: 9234:	      strcpy(msg, "parse error");
        -: 9235:
        -: 9236:	      if (count < 5)
        -: 9237:		{
        -: 9238:		  count = 0;
        -: 9239:		  for (x = (yyn < 0 ? -yyn : 0);
        -: 9240:		       x < (sizeof(yytname) / sizeof(char *)); x++)
        -: 9241:		    if (yycheck[x + yyn] == x)
        -: 9242:		      {
        -: 9243:			strcat(msg, count == 0 ? ", expecting `" : " or `");
        -: 9244:			strcat(msg, yytname[x]);
        -: 9245:			strcat(msg, "'");
        -: 9246:			count++;
        -: 9247:		      }
        -: 9248:		}
        -: 9249:	      yyerror(msg);
        -: 9250:	      free(msg);
        -: 9251:	    }
        -: 9252:	  else
        -: 9253:	    yyerror ("parse error; also virtual memory exceeded");
        -: 9254:	}
        -: 9255:      else
        -: 9256:#endif /* YYERROR_VERBOSE */
        5: 9257:	yyerror("parse error");
call    0 returned 5
        -: 9258:    }
        -: 9259:
       15: 9260:  goto yyerrlab1;
       15: 9261:yyerrlab1:   /* here on error raised explicitly by an action */
        -: 9262:
       15: 9263:  if (yyerrstatus == 3)
branch  0 taken 9 (fallthrough)
branch  1 taken 6
        -: 9264:    {
        -: 9265:      /* if just tried and failed to reuse lookahead token after an error, discard it.  */
        -: 9266:
        -: 9267:      /* return failure if at end of input */
        9: 9268:      if (yychar == YYEOF)
branch  0 taken 0 (fallthrough)
branch  1 taken 9
    #####: 9269:	YYABORT;
        -: 9270:
        -: 9271:#if YYDEBUG != 0
        -: 9272:      if (yydebug)
        -: 9273:	fprintf(err, "Discarding token %d (%s).\n", yychar, yytname[yychar1]);
        -: 9274:#endif
        -: 9275:
        9: 9276:      yychar = YYEMPTY;
        -: 9277:    }
        -: 9278:
        -: 9279:  /* Else will try to reuse lookahead token
        -: 9280:     after shifting the error token.  */
        -: 9281:
       15: 9282:  yyerrstatus = 3;		/* Each real token shifted decrements this */
        -: 9283:
       15: 9284:  goto yyerrhandle;
        -: 9285:
       14: 9286:yyerrdefault:  /* current state does not do anything special for the error token. */
        -: 9287:
        -: 9288:#if 0
        -: 9289:  /* This is wrong; only states that explicitly want error tokens
        -: 9290:     should shift them.  */
        -: 9291:  yyn = yydefact[yystate];  /* If its default is to accept any token, ok.  Otherwise pop it.*/
        -: 9292:  if (yyn) goto yydefault;
        -: 9293:#endif
        -: 9294:
       14: 9295:yyerrpop:   /* pop the current state because it cannot handle the error token */
        -: 9296:
      14*: 9297:  if (yyssp == yyss) YYABORT;
branch  0 taken 0 (fallthrough)
branch  1 taken 14
       14: 9298:  yyvsp--;
       14: 9299:  yystate = *--yyssp;
        -: 9300:#ifdef YYLSP_NEEDED
        -: 9301:  yylsp--;
        -: 9302:#endif
        -: 9303:
        -: 9304:#if YYDEBUG != 0
        -: 9305:  if (yydebug)
        -: 9306:    {
        -: 9307:      short *ssp1 = yyss - 1;
        -: 9308:      fprintf (err, "Error: state stack now");
        -: 9309:      while (ssp1 != yyssp)
        -: 9310:	fprintf (err, " %d", *++ssp1);
        -: 9311:      fprintf (err, "\n");
        -: 9312:    }
        -: 9313:#endif
        -: 9314:
       29: 9315:yyerrhandle:
        -: 9316:
       29: 9317:  yyn = yypact[yystate];
       29: 9318:  if (yyn == YYFLAG)
branch  0 taken 0 (fallthrough)
branch  1 taken 29
    #####: 9319:    goto yyerrdefault;
        -: 9320:
       29: 9321:  yyn += YYTERROR;
       29: 9322:  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != YYTERROR)
branch  0 taken 27 (fallthrough)
branch  1 taken 2
branch  2 taken 27 (fallthrough)
branch  3 taken 0
branch  4 taken 12 (fallthrough)
branch  5 taken 15
       14: 9323:    goto yyerrdefault;
        -: 9324:
       15: 9325:  yyn = yytable[yyn];
       15: 9326:  if (yyn < 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 15
        -: 9327:    {
    #####: 9328:      if (yyn == YYFLAG)
branch  0 never executed
branch  1 never executed
    #####: 9329:	goto yyerrpop;
    #####: 9330:      yyn = -yyn;
    #####: 9331:      goto yyreduce;
        -: 9332:    }
       15: 9333:  else if (yyn == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 15
    #####: 9334:    goto yyerrpop;
        -: 9335:
       15: 9336:  if (yyn == YYFINAL)
branch  0 taken 0 (fallthrough)
branch  1 taken 15
    #####: 9337:    YYACCEPT;
        -: 9338:
        -: 9339:#if YYDEBUG != 0
        -: 9340:  if (yydebug)
        -: 9341:    fprintf(err, "Shifting error token, ");
        -: 9342:#endif
        -: 9343:
       15: 9344:  *++yyvsp = yylval;
        -: 9345:#ifdef YYLSP_NEEDED
        -: 9346:  *++yylsp = yylloc;
        -: 9347:#endif
        -: 9348:
       15: 9349:  yystate = yyn;
       15: 9350:  goto yynewstate;
        -: 9351:
      549: 9352: yyacceptlab:
        -: 9353:  /* YYACCEPT comes here.  */
      549: 9354:  if (yyfree_stacks)
branch  0 taken 0 (fallthrough)
branch  1 taken 549
        -: 9355:    {
    #####: 9356:      free (yyss);
    #####: 9357:      free (yyvs);
        -: 9358:#ifdef YYLSP_NEEDED
        -: 9359:      free (yyls);
        -: 9360:#endif
        -: 9361:    }
      549: 9362:  return 0;
        -: 9363:
    #####: 9364: yyabortlab:
        -: 9365:  /* YYABORT comes here.  */
    #####: 9366:  if (yyfree_stacks)
branch  0 never executed
branch  1 never executed
        -: 9367:    {
    #####: 9368:      free (yyss);
    #####: 9369:      free (yyvs);
        -: 9370:#ifdef YYLSP_NEEDED
        -: 9371:      free (yyls);
        -: 9372:#endif
        -: 9373:    }
    #####: 9374:  return 1;
        -: 9375:}
        -: 9376:
        -: 9377:
        -: 9378:
        -: 9379:/* build_eof_action - build the "<<EOF>>" action for the active start
        -: 9380: *                    conditions
        -: 9381: */
        -: 9382:
function build_eof_action called 9 returned 100% blocks executed 100%
        9: 9383:void build_eof_action()
        -: 9384:	{
        -: 9385:	register int i;
        -: 9386:	char action_text[MAXLINE];
        -: 9387:
       24: 9388:	for ( i = 1; i <= actvp; ++i )
branch  0 taken 15
branch  1 taken 9 (fallthrough)
        -: 9389:		{
       15: 9390:		if ( sceof[actvsc[i]] )
branch  0 taken 1 (fallthrough)
branch  1 taken 14
        1: 9391:			format_pinpoint_message(
        -: 9392:				"multiple <<EOF>> rules for start condition %s",
        1: 9393:				scname[actvsc[i]] );
call    0 returned 1
        -: 9394:
        -: 9395:		else
        -: 9396:			{
       14: 9397:			sceof[actvsc[i]] = true;
       14: 9398:			sprintf( action_text, "case YY_STATE_EOF(%s):\n",
       14: 9399:			scname[actvsc[i]] );
       14: 9400:			add_action( action_text );
call    0 returned 14
        -: 9401:			}
        -: 9402:		}
        -: 9403:
        9: 9404:	line_directive_out( (FILE *) 0 );
call    0 returned 9
        -: 9405:
        -: 9406:	/* This isn't a normal rule after all - don't count it as
        -: 9407:	 * such, so we don't have any holes in the rule numbering
        -: 9408:	 * (which make generating "rule can never match" warnings
        -: 9409:	 * more difficult.
        -: 9410:	 */
        9: 9411:	--num_rules;
        9: 9412:	++num_eof_rules;
        9: 9413:	}
        -: 9414:
        -: 9415:
        -: 9416:/* format_synerr - write out formatted syntax error */
        -: 9417:
function format_synerr called 4 returned 100% blocks executed 100%
        4: 9418:void format_synerr( msg, arg )
        -: 9419:char msg[], arg[];
        -: 9420:	{
        -: 9421:	char errmsg[MAXLINE];
        -: 9422:
        4: 9423:	(void) sprintf( errmsg, msg, arg );
        4: 9424:	synerr( errmsg );
call    0 returned 4
        4: 9425:	}
        -: 9426:
        -: 9427:
        -: 9428:/* synerr - report a syntax error */
        -: 9429:
function synerr called 22 returned 100% blocks executed 100%
       22: 9430:void synerr( str )
        -: 9431:char str[];
        -: 9432:	{
       22: 9433:	syntaxerror = true;
       22: 9434:	pinpoint_message( str );
call    0 returned 22
       22: 9435:	}
        -: 9436:
        -: 9437:
        -: 9438:/* warn - report a warning, unless -w was given */
        -: 9439:
function warn called 0 returned 0% blocks executed 0%
    #####: 9440:void warn( str )
        -: 9441:char str[];
        -: 9442:	{
    #####: 9443:	line_warning( str, linenum );
call    0 never executed
    #####: 9444:	}
        -: 9445:
        -: 9446:/* format_pinpoint_message - write out a message formatted with one string,
        -: 9447: *			     pinpointing its location
        -: 9448: */
        -: 9449:
function format_pinpoint_message called 1 returned 100% blocks executed 100%
        1: 9450:void format_pinpoint_message( msg, arg )
        -: 9451:char msg[], arg[];
        -: 9452:	{
        -: 9453:	char errmsg[MAXLINE];
        -: 9454:
        1: 9455:	(void) sprintf( errmsg, msg, arg );
        1: 9456:	pinpoint_message( errmsg );
call    0 returned 1
        1: 9457:	}
        -: 9458:
        -: 9459:
        -: 9460:/* pinpoint_message - write out a message, pinpointing its location */
        -: 9461:
function pinpoint_message called 23 returned 100% blocks executed 100%
       23: 9462:void pinpoint_message( str )
        -: 9463:char str[];
        -: 9464:	{
       23: 9465:	line_pinpoint( str, linenum );
call    0 returned 23
       23: 9466:	}
        -: 9467:
        -: 9468:
        -: 9469:/* line_warning - report a warning at a given line, unless -w was given */
        -: 9470:
function line_warning called 9 returned 100% blocks executed 100%
        9: 9471:void line_warning( str, line )
        -: 9472:char str[];
        -: 9473:int line;
        -: 9474:	{
        -: 9475:	char warning[MAXLINE];
        -: 9476:
        9: 9477:	if ( ! nowarn )
branch  0 taken 8 (fallthrough)
branch  1 taken 1
        -: 9478:		{
        8: 9479:		sprintf( warning, "warning, %s", str );
        8: 9480:		line_pinpoint( warning, line );
call    0 returned 8
        -: 9481:		}
        9: 9482:	}
        -: 9483:
        -: 9484:
        -: 9485:/* line_pinpoint - write out a message, pinpointing it at the given line */
        -: 9486:
function line_pinpoint called 31 returned 100% blocks executed 100%
       31: 9487:void line_pinpoint( str, line )
        -: 9488:char str[];
        -: 9489:int line;
        -: 9490:	{
       31: 9491:	fprintf( err, "\"%s\", line %d: %s\n", infilename, line, str );
call    0 returned 31
       31: 9492:	}
        -: 9493:
        -: 9494:
        -: 9495:/* yyerror - eat up an error message from the parser;
        -: 9496: *	     currently, messages are ignore
        -: 9497: */
        -: 9498:
function yyerror called 5 returned 100% blocks executed 100%
        5: 9499:void yyerror( msg )
        -: 9500:char msg[];
        -: 9501:	{
        5: 9502:	}
        -: 9503:/* A lexical scanner generated by flex */
        -: 9504:
        -: 9505:/* Scanner skeleton version:
        -: 9506: * $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.orig/v0/flex.c,v 1.1.1.1 2003/06/02 17:12:00 expsir Exp $
        -: 9507: */
        -: 9508:
        -: 9509:#define FLEX_SCANNER
        -: 9510:
        -: 9511:#include <stdio.h>
        -: 9512:
        -: 9513:
        -: 9514:/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
        -: 9515:#ifdef c_plusplus
        -: 9516:#ifndef __cplusplus
        -: 9517:#define __cplusplus
        -: 9518:#endif
        -: 9519:#endif
        -: 9520:
        -: 9521:
        -: 9522:#ifdef __cplusplus
        -: 9523:
        -: 9524:#include <stdlib.h>
        -: 9525:#include <unistd.h>
        -: 9526:
        -: 9527:/* Use prototypes in function declarations. */
        -: 9528:#define YY_USE_PROTOS
        -: 9529:
        -: 9530:/* The "const" storage-class-modifier is valid. */
        -: 9531:#define YY_USE_CONST
        -: 9532:
        -: 9533:#else	/* ! __cplusplus */
        -: 9534:
        -: 9535:#ifdef __STDC__
        -: 9536:
        -: 9537:#define YY_USE_PROTOS
        -: 9538:#define YY_USE_CONST
        -: 9539:
        -: 9540:#endif	/* __STDC__ */
        -: 9541:#endif	/* ! __cplusplus */
        -: 9542:
        -: 9543:
        -: 9544:#ifdef __TURBOC__
        -: 9545:#define YY_USE_CONST
        -: 9546:#endif
        -: 9547:
        -: 9548:
        -: 9549:#ifndef YY_USE_CONST
        -: 9550:#ifndef const
        -: 9551:#define const
        -: 9552:#endif
        -: 9553:#endif
        -: 9554:
        -: 9555:
        -: 9556:#ifdef YY_USE_PROTOS
        -: 9557:#define YY_PROTO(proto) proto
        -: 9558:#else
        -: 9559:#define YY_PROTO(proto) ()
        -: 9560:#endif
        -: 9561:
        -: 9562:/* Returned upon end-of-file. */
        -: 9563:#define YY_NULL 0
        -: 9564:
        -: 9565:/* Enter a start condition.  This macro really ought to take a parameter,
        -: 9566: * but we do it the disgusting crufty way forced on us by the ()-less
        -: 9567: * definition of BEGIN.
        -: 9568: */
        -: 9569:#define BEGIN yy_start = 1 + 2 *
        -: 9570:
        -: 9571:/* Translate the current start state into a value that can be later handed
        -: 9572: * to BEGIN to return to the state.
        -: 9573: */
        -: 9574:#define YY_START ((yy_start - 1) / 2)
        -: 9575:
        -: 9576:/* Action number for EOF rule of a given start state. */
        -: 9577:#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
        -: 9578:
        -: 9579:/* Special action meaning "start processing a new file".  Now included
        -: 9580: * only for backward compatibility with previous versions of flex.
        -: 9581: */
        -: 9582:#define YY_NEW_FILE yyrestart( yyin )
        -: 9583:
        -: 9584:#define YY_END_OF_BUFFER_CHAR 0
        -: 9585:
        -: 9586:/* Size of default input buffer. */
        -: 9587:#define YY_BUF_SIZE 16384
        -: 9588:
        -: 9589:typedef struct yy_buffer_state *YY_BUFFER_STATE;
        -: 9590:
        -: 9591:extern int yyleng;
        -: 9592:extern FILE *yyin, *yyout;
        -: 9593:
        -: 9594:#ifdef __cplusplus
        -: 9595:extern "C" {
        -: 9596:#endif
        -: 9597:	extern void *yy_flex_alloc YY_PROTO(( int ));
        -: 9598:	extern void *yy_flex_realloc YY_PROTO(( void *ptr, int size ));
        -: 9599:	extern void yy_flex_free YY_PROTO(( void * ));
        -: 9600:	extern int yywrap YY_PROTO(( void ));
        -: 9601:	extern void yy_strcpy YY_PROTO(( char *s1, const char *s2 ));
        -: 9602:#ifdef __cplusplus
        -: 9603:	}
        -: 9604:#endif
        -: 9605:
        -: 9606:#define EOB_ACT_CONTINUE_SCAN 0
        -: 9607:#define EOB_ACT_END_OF_FILE 1
        -: 9608:#define EOB_ACT_LAST_MATCH 2
        -: 9609:
        -: 9610:/* The funky do-while in the following #define is used to turn the definition
        -: 9611: * int a single C statement (which needs a semi-colon terminator).  This
        -: 9612: * avoids problems with code like:
        -: 9613: *
        -: 9614: * 	if ( condition_holds )
        -: 9615: *		yyless( 5 );
        -: 9616: *	else
        -: 9617: *		do_something_else();
        -: 9618: *
        -: 9619: * Prior to using the do-while the compiler would get upset at the
        -: 9620: * "else" because it interpreted the "if" statement as being all
        -: 9621: * done when it reached the ';' after the yyless() call.
        -: 9622: */
        -: 9623:
        -: 9624:/* Return all but the first 'n' matched characters back to the input stream. */
        -: 9625:
        -: 9626:#define yyless(n) \
        -: 9627:	do \
        -: 9628:		{ \
        -: 9629:		/* Undo effects of setting up yytext. */ \
        -: 9630:		*yy_cp = yy_hold_char; \
        -: 9631:		yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \
        -: 9632:		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
        -: 9633:		} \
        -: 9634:	while ( 0 )
        -: 9635:
        -: 9636:#define unput(c) yyunput( c, yytext_ptr )
        -: 9637:
        -: 9638:
        -: 9639:struct yy_buffer_state
        -: 9640:	{
        -: 9641:	FILE *yy_input_file;
        -: 9642:
        -: 9643:	char *yy_ch_buf;		/* input buffer */
        -: 9644:	char *yy_buf_pos;		/* current position in input buffer */
        -: 9645:
        -: 9646:	/* Size of input buffer in bytes, not including room for EOB
        -: 9647:	 * characters.
        -: 9648:	 */
        -: 9649:	int yy_buf_size;
        -: 9650:
        -: 9651:	/* Number of characters read into yy_ch_buf, not including EOB
        -: 9652:	 * characters.
        -: 9653:	 */
        -: 9654:	int yy_n_chars;
        -: 9655:
        -: 9656:	/* Whether this is an "interactive" input source; if so, and
        -: 9657:	 * if we're using stdio for input, then we want to use getc()
        -: 9658:	 * instead of fread(), to make sure we stop fetching input after
        -: 9659:	 * each newline.
        -: 9660:	 */
        -: 9661:	int is_interactive;
        -: 9662:
        -: 9663:	/* Whether we've seen an EOF on this buffer. */
        -: 9664:	int yy_eof_status;
        -: 9665:#define EOF_NOT_SEEN 0
        -: 9666:	/* "Pending" happens when the EOF has been seen but there's still
        -: 9667:	 * some text to process.  Note that when we actually see the EOF,
        -: 9668:	 * we switch the status back to "not seen" (via yyrestart()), so
        -: 9669:	 * that the user can continue scanning by just pointing yyin at
        -: 9670:	 * a new input file.
        -: 9671:	 */
        -: 9672:#define EOF_PENDING 1
        -: 9673:	};
        -: 9674:
        -: 9675:static YY_BUFFER_STATE yy_current_buffer = 0;
        -: 9676:
        -: 9677:/* We provide macros for accessing buffer states in case in the
        -: 9678: * future we want to put the buffer states in a more general
        -: 9679: * "scanner state".
        -: 9680: */
        -: 9681:#define YY_CURRENT_BUFFER yy_current_buffer
        -: 9682:
        -: 9683:
        -: 9684:/* yy_hold_char holds the character lost when yytext is formed. */
        -: 9685:static char yy_hold_char;
        -: 9686:
        -: 9687:static int yy_n_chars;		/* number of characters read into yy_ch_buf */
        -: 9688:
        -: 9689:
        -: 9690:int yyleng;
        -: 9691:
        -: 9692:/* Points to current character in buffer. */
        -: 9693:static char *yy_c_buf_p = (char *) 0;
        -: 9694:static int yy_init = 1;		/* whether we need to initialize */
        -: 9695:static int yy_start = 0;	/* start state number */
        -: 9696:
        -: 9697:/* Flag which is used to allow yywrap()'s to do buffer switches
        -: 9698: * instead of setting up a fresh yyin.  A bit of a hack ...
        -: 9699: */
        -: 9700:static int yy_did_buffer_switch_on_eof;
        -: 9701:
        -: 9702:static void yyunput YY_PROTO(( int c, char *buf_ptr ));
        -: 9703:void yyrestart YY_PROTO(( FILE *input_file ));
        -: 9704:void yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));
        -: 9705:void yy_load_buffer_state YY_PROTO(( void ));
        -: 9706:YY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *file, int size ));
        -: 9707:void yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));
        -: 9708:void yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));
        -: 9709:
        -: 9710:#define yy_new_buffer yy_create_buffer
        -: 9711:
        -: 9712:#define INITIAL 0
        -: 9713:#define SECT2 1
        -: 9714:#define SECT2PROLOG 2
        -: 9715:#define SECT3 3
        -: 9716:#define CODEBLOCK 4
        -: 9717:#define PICKUPDEF 5
        -: 9718:#define SC 6
        -: 9719:#define CARETISBOL 7
        -: 9720:#define NUM 8
        -: 9721:#define QUOTE 9
        -: 9722:#define FIRSTCCL 10
        -: 9723:#define CCL 11
        -: 9724:#define ACTION 12
        -: 9725:#define RECOVER 13
        -: 9726:#define BRACEERROR 14
        -: 9727:#define C_COMMENT 15
        -: 9728:#define ACTION_COMMENT 16
        -: 9729:#define ACTION_STRING 17
        -: 9730:#define PERCENT_BRACE_ACTION 18
        -: 9731:#define USED_LIST 19
        -: 9732:#define CODEBLOCK_2 20
        -: 9733:typedef unsigned char YY_CHAR;
        -: 9734:typedef int yy_state_type;
        -: 9735:FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
        -: 9736:extern char *yytext;
        -: 9737:#define yytext_ptr yytext
        -: 9738:
        -: 9739:#ifdef __cplusplus
        -: 9740:static int yyinput YY_PROTO(( void ));
        -: 9741:#else
        -: 9742:static int input YY_PROTO(( void ));
        -: 9743:#endif
        -: 9744:
        -: 9745:static yy_state_type yy_get_previous_state YY_PROTO(( void ));
        -: 9746:static yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));
        -: 9747:static int yy_get_next_buffer YY_PROTO(( void ));
        -: 9748:static void yy_fatal_error YY_PROTO(( const char msg[] ));
        -: 9749:
        -: 9750:/* Done after the current pattern has been matched and before the
        -: 9751: * corresponding action - sets up yytext.
        -: 9752: */
        -: 9753:#define YY_DO_BEFORE_ACTION \
        -: 9754:	yytext_ptr = yy_bp; \
        -: 9755:	yyleng = yy_cp - yy_bp; \
        -: 9756:	yy_hold_char = *yy_cp; \
        -: 9757:	*yy_cp = '\0'; \
        -: 9758:	yy_c_buf_p = yy_cp;
        -: 9759:
        -: 9760:#define YY_END_OF_BUFFER 113
        -: 9761:static const short int yy_accept[408] =
        -: 9762:    {   0,
        -: 9763:        0,    0,    0,    0,   41,   41,  110,  110,    0,    0,
        -: 9764:        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        -: 9765:        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        -: 9766:        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        -: 9767:        0,    0,  113,  111,    6,   17,  111,   15,    1,   16,
        -: 9768:      111,  111,  111,   14,   60,   53,   54,   60,   47,   60,
        -: 9769:       59,   60,   60,   60,   60,   44,   43,   60,   60,   45,
        -: 9770:       46,   41,   42,   41,   40,   39,   40,   40,  110,  110,
        -: 9771:       26,   27,   26,   26,   26,   26,   26,   26,   29,   28,
        -: 9772:       30,   29,   65,   61,   62,   64,   66,   80,   81,   80,
        -: 9773:
        -: 9774:       78,   77,   79,   67,   69,   67,   68,   67,   72,   72,
        -: 9775:       72,   74,   76,   74,   74,   74,   75,   92,   97,   92,
        -: 9776:       96,   98,   98,   93,   93,   93,   90,   91,  111,   31,
        -: 9777:      111,   83,  111,   82,   20,   22,   20,   21,  101,  102,
        -: 9778:      101,  100,  103,  105,  103,  106,  107,   88,   88,   89,
        -: 9779:       88,   88,   88,   88,   88,   88,   36,   33,   32,   36,
        -: 9780:       36,   36,   88,    6,   17,    0,   17,   15,    1,   16,
        -: 9781:        0,   16,   13,    7,    0,    0,    0,    3,    0,    4,
        -: 9782:        0,    2,   14,   53,   54,    0,    0,    0,   54,   50,
        -: 9783:       50,    0,    0,   57,    0,  108,  108,  108,   49,   48,
        -: 9784:
        -: 9785:       49,   44,   43,    0,   43,   56,   44,   41,   42,   40,
        -: 9786:       39,   39,   37,   38,  110,  110,   26,   27,   26,   26,
        -: 9787:       26,   26,   29,   28,   30,   63,   64,   81,   77,   69,
        -: 9788:      109,  109,  109,   70,   71,   76,   73,   92,   97,    0,
        -: 9789:       95,    0,   94,   93,   93,   93,    0,   31,    0,   31,
        -: 9790:       31,   83,   20,   22,   18,  101,  102,  101,  102,  102,
        -: 9791:       99,  103,  105,  104,   88,   88,   88,   89,   85,   88,
        -: 9792:       88,   88,   36,   33,   32,   36,   36,   84,   13,    7,
        -: 9793:        0,   12,    0,    0,    0,    0,    3,    0,    0,    4,
        -: 9794:        0,    5,    0,   51,    0,   52,    0,    0,   57,    0,
        -: 9795:
        -: 9796:       57,   57,  108,  108,   49,   49,   58,   56,   37,   38,
        -: 9797:       26,   26,   26,   23,   26,    0,  109,  109,   93,   93,
        -: 9798:        0,   19,    0,   85,   85,   88,   88,   36,   36,   12,
        -: 9799:        0,    0,    0,    3,    0,    0,    4,    5,    5,   52,
        -: 9800:       52,    0,   57,   57,   57,   57,  108,   26,   26,   23,
        -: 9801:       23,    0,  109,   93,   93,   19,   19,   88,   88,   36,
        -: 9802:       36,    0,    0,    0,   10,    0,   57,   57,   57,   57,
        -: 9803:       26,   26,   93,   93,   88,   88,   36,   36,    0,    0,
        -: 9804:        0,    0,   57,   57,   24,   25,   86,   87,   86,   87,
        -: 9805:       34,   35,    0,    9,    0,    0,   11,   55,    9,    9,
        -: 9806:
        -: 9807:        0,    0,    8,    0,    8,    8,    0
        -: 9808:    } ;
        -: 9809:
        -: 9810:static const YY_CHAR yy_ec[256] =
        -: 9811:    {   0,
        -: 9812:        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
        -: 9813:        1,    1,    4,    1,    1,    1,    1,    1,    1,    1,
        -: 9814:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -: 9815:        1,    2,    1,    5,    1,    6,    7,    1,    8,    9,
        -: 9816:        9,   10,    9,   11,   12,    9,   13,   14,   14,   14,
        -: 9817:       14,   14,   14,   14,   14,   14,   14,    1,    1,   15,
        -: 9818:        1,   16,    9,    1,   22,   23,   24,   25,   26,   27,
        -: 9819:       21,   21,   28,   29,   30,   21,   31,   32,   33,   34,
        -: 9820:       21,   35,   36,   37,   38,   21,   21,   39,   40,   21,
        -: 9821:       17,   18,   19,   20,   21,    1,   22,   23,   24,   25,
        -: 9822:
        -: 9823:       26,   27,   21,   21,   28,   29,   30,   21,   31,   32,
        -: 9824:       33,   34,   21,   35,   36,   37,   38,   21,   21,   39,
        -: 9825:       40,   21,   41,   42,   43,    1,    1,    1,    1,    1,
        -: 9826:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -: 9827:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -: 9828:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -: 9829:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -: 9830:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -: 9831:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -: 9832:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -: 9833:
        -: 9834:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -: 9835:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -: 9836:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -: 9837:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -: 9838:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -: 9839:        1,    1,    1,    1,    1
        -: 9840:    } ;
        -: 9841:
        -: 9842:static const YY_CHAR yy_meta[44] =
        -: 9843:    {   0,
        -: 9844:        1,    2,    3,    1,    4,    1,    1,    5,    1,    6,
        -: 9845:        1,    7,    5,    8,    1,    1,    1,    9,   10,    1,
        -: 9846:       11,   12,   12,   12,   12,   12,   12,   11,   11,   11,
        -: 9847:       11,   11,   11,   11,   11,   11,   13,   11,   11,   11,
        -: 9848:        5,    1,   14
        -: 9849:    } ;
        -: 9850:
        -: 9851:static const short int yy_base[470] =
        -: 9852:    {   0,
        -: 9853:        0,   43,   85,  126,   89,  102, 1611, 1610,  168, 1605,
        -: 9854:      108,  111,  211,    0, 1591, 1590,  252,  254,  116,  119,
        -: 9855:       98,  122,  144,  146,  297,    0,   93,  104,  338,  340,
        -: 9856:      149,  151,  257,  266,  268,  274,  383,    0,  425,  428,
        -: 9857:     1596, 1595, 1607, 1615,  278, 1602, 1602,    0,  281, 1600,
        -: 9858:     1600,  462, 1592,    0, 1615,  431, 1597, 1597, 1615,  285,
        -: 9859:     1615, 1584, 1580,  331,  503,  437, 1593, 1593,  110, 1580,
        -: 9860:     1615,    0, 1590, 1590,    0, 1590, 1588,  221, 1587, 1615,
        -: 9861:        0, 1585, 1585, 1615,    0, 1561, 1546, 1511,    0, 1551,
        -: 9862:     1543, 1543, 1615, 1615, 1498,    0, 1615, 1615, 1500, 1487,
        -: 9863:
        -: 9864:     1615, 1463, 1615, 1615, 1466, 1460, 1615,  332, 1615,  333,
        -: 9865:      126, 1615, 1411, 1398,    0,  334, 1615,    0, 1383, 1383,
        -: 9866:     1615,  341, 1371,    0, 1354, 1336, 1615, 1615,  271, 1371,
        -: 9867:      287, 1370, 1366, 1615,    0, 1362, 1349, 1331,  290, 1335,
        -: 9868:      347, 1325,    0, 1323, 1310, 1615,    0,    0,  350, 1306,
        -: 9869:     1287, 1246, 1615,    0, 1249, 1227,    0, 1264, 1261, 1255,
        -: 9870:     1225, 1197, 1213,  351, 1213, 1213, 1615,    0,  358, 1198,
        -: 9871:     1193, 1615,    0,    0,  443,  361,  447,    0,  342,    0,
        -: 9872:      363, 1615,    0,  451, 1191, 1188, 1149,  365, 1615, 1615,
        -: 9873:     1185, 1181, 1155, 1135,  423, 1615, 1125,    0,    0, 1615,
        -: 9874:
        -: 9875:      546,  588, 1121, 1108, 1615,    0, 1615,    0, 1615,    0,
        -: 9876:        0, 1095,    0,    0, 1088, 1615,    0, 1615,    0, 1061,
        -: 9877:     1041,  630,    0, 1069, 1615, 1615,    0, 1615,  838, 1615,
        -: 9878:     1615,  837,    0, 1615, 1615, 1615, 1615,    0, 1615,  434,
        -: 9879:     1615,    0, 1615,    0,  821,  817,  373,  843,  376, 1615,
        -: 9880:      842, 1615,    0, 1615,  463,  467,  834,  471, 1615,  833,
        -: 9881:     1615,    0, 1615, 1615,    0,  441,  793, 1615,  673,    0,
        -: 9882:      805,  802,    0,  830, 1615,  795,  792, 1615,    0,    0,
        -: 9883:      594,  818,  817,  597,  784,  790,    0,  775,  786,    0,
        -: 9884:      473,  807,  478, 1615,  486,  806,  590,  776,  790,  588,
        -: 9885:
        -: 9886:      469,  703,  793,    0,    0,    0, 1615,    0,    0,    0,
        -: 9887:      780,  772,    0,  800,  800,  730,  788,    0,  775,  767,
        -: 9888:      600,  795,  602,    0,  773,  772,  764,  770,  762, 1615,
        -: 9889:      610,  772,  751,    0,  740,  745,    0, 1615,  765, 1615,
        -: 9890:      764,  740,  488,  803,  601,  817, 1615,  742,  730, 1615,
        -: 9891:      760,  760, 1615,  738,  726, 1615,  756,  735,  723,  733,
        -: 9892:      721,  714,  716,  726, 1615,  724,  602,  831,  715,  658,
        -: 9893:      512,  473,  454,  459,  435,  438,  422,  430,  606,  410,
        -: 9894:      357,  342,  338,  278,    0,    0,    0,    0,    0,    0,
        -: 9895:        0,    0,  614,  255,  618,  131, 1615, 1615, 1615,  156,
        -: 9896:
        -: 9897:      620,  622,  153,  625, 1615,   95, 1615,  858,  872,  886,
        -: 9898:      900,  914,  928,  942,  956,  970,  984,  998, 1012, 1026,
        -: 9899:     1040, 1054, 1062, 1075, 1081, 1094, 1108, 1122, 1136, 1150,
        -: 9900:     1164, 1178, 1186, 1199, 1207, 1220, 1234, 1248, 1262, 1272,
        -: 9901:     1280, 1293, 1307, 1321, 1335, 1349, 1363, 1371, 1384, 1398,
        -: 9902:     1412, 1416, 1419, 1432, 1446, 1460,  710, 1474, 1487, 1501,
        -: 9903:     1515,  711, 1529, 1537, 1544,  712,  743, 1557, 1571
        -: 9904:    } ;
        -: 9905:
        -: 9906:static const short int yy_def[470] =
        -: 9907:    {   0,
        -: 9908:      407,  407,  408,  408,  409,  410,  411,  411,  407,    9,
        -: 9909:      412,  412,  407,   13,  413,  413,  414,  414,  415,  415,
        -: 9910:      416,  416,  417,  417,  407,   25,  418,  418,  413,  413,
        -: 9911:      419,  419,  420,  420,  421,  421,  407,   37,  422,  422,
        -: 9912:       37,   37,  407,  407,  407,  407,  407,  423,  407,  407,
        -: 9913:      407,  424,  407,  425,  407,  407,  407,  407,  407,  407,
        -: 9914:      407,  407,  426,  427,  407,  407,  407,  407,  407,  407,
        -: 9915:      407,  428,  407,  428,  429,  430,  429,  429,  431,  407,
        -: 9916:      432,  407,  432,  407,  433,  433,  433,  432,  434,  407,
        -: 9917:      407,  434,  407,  407,  407,  435,  407,  407,  407,  407,
        -: 9918:
        -: 9919:      407,  407,  407,  407,  407,  407,  407,  427,  407,  436,
        -: 9920:      437,  407,  407,  407,  438,  427,  407,  439,  407,  439,
        -: 9921:      407,  440,  407,  441,  441,  441,  407,  407,  442,  407,
        -: 9922:      442,  407,  407,  407,  443,  407,  443,  407,  444,  407,
        -: 9923:      444,  407,  445,  407,  445,  407,  446,  447,  447,  407,
        -: 9924:      447,  447,  407,  448,  448,  448,  449,  407,  407,  449,
        -: 9925:      449,  449,  447,  407,  407,  407,  407,  423,  407,  407,
        -: 9926:      407,  407,  450,  451,  407,  407,  407,  452,  407,  453,
        -: 9927:      454,  407,  425,  407,  407,  407,  407,  455,  407,  407,
        -: 9928:      407,  407,  407,  456,  426,  407,  407,  457,  458,  407,
        -: 9929:
        -: 9930:      407,  407,  407,  407,  407,  459,  407,  428,  407,  429,
        -: 9931:      430,  430,  460,  461,  431,  407,  432,  407,  433,  433,
        -: 9932:      433,  407,  434,  407,  407,  407,  435,  407,  407,  407,
        -: 9933:      407,  407,  462,  407,  407,  407,  407,  439,  407,  440,
        -: 9934:      407,  440,  407,  441,  441,  441,  442,  407,  442,  407,
        -: 9935:      407,  407,  443,  407,  463,  444,  407,  444,  407,  407,
        -: 9936:      407,  445,  407,  407,  447,  447,  447,  407,  407,  448,
        -: 9937:      448,  448,  449,  407,  407,  449,  449,  407,  450,  451,
        -: 9938:      407,  407,  407,  407,  407,  407,  464,  407,  407,  465,
        -: 9939:      454,  407,  454,  407,  455,  407,  455,  407,  456,  456,
        -: 9940:
        -: 9941:      456,  456,  407,  466,  458,  201,  407,  459,  460,  461,
        -: 9942:      433,  433,  222,  407,  222,  222,  407,  467,  441,  441,
        -: 9943:      463,  407,  463,  269,  269,  448,  448,  449,  449,  407,
        -: 9944:      407,  407,  407,  464,  407,  407,  465,  407,  407,  407,
        -: 9945:      407,  407,  456,  456,  456,  456,  407,  433,  433,  407,
        -: 9946:      407,  316,  407,  441,  441,  407,  407,  448,  448,  449,
        -: 9947:      449,  407,  407,  407,  407,  407,  456,  456,  456,  456,
        -: 9948:      433,  433,  441,  441,  448,  448,  449,  449,  468,  407,
        -: 9949:      407,  407,  456,  456,  433,  433,  441,  441,  448,  448,
        -: 9950:      449,  449,  468,  407,  468,  407,  407,  407,  407,  407,
        -: 9951:
        -: 9952:      469,  469,  407,  469,  407,  407,    0,  407,  407,  407,
        -: 9953:      407,  407,  407,  407,  407,  407,  407,  407,  407,  407,
        -: 9954:      407,  407,  407,  407,  407,  407,  407,  407,  407,  407,
        -: 9955:      407,  407,  407,  407,  407,  407,  407,  407,  407,  407,
        -: 9956:      407,  407,  407,  407,  407,  407,  407,  407,  407,  407,
        -: 9957:      407,  407,  407,  407,  407,  407,  407,  407,  407,  407,
        -: 9958:      407,  407,  407,  407,  407,  407,  407,  407,  407
        -: 9959:    } ;
        -: 9960:
        -: 9961:static const short int yy_nxt[1659] =
        -: 9962:    {   0,
        -: 9963:       44,   45,   46,   47,   44,   44,   44,   44,   44,   44,
        -: 9964:       44,   44,   44,   44,   44,   44,   44,   44,   44,   44,
        -: 9965:       48,   48,   48,   48,   48,   48,   48,   48,   48,   48,
        -: 9966:       48,   48,   48,   48,   48,   48,   48,   48,   48,   48,
        -: 9967:       44,   44,   44,   44,   49,   50,   51,   44,   44,   52,
        -: 9968:       44,   44,   44,   44,   44,   53,   44,   44,   44,   44,
        -: 9969:       44,   44,   44,   54,   54,   54,   54,   54,   54,   54,
        -: 9970:       54,   54,   54,   54,   54,   54,   54,   54,   54,   54,
        -: 9971:       54,   54,   54,   44,   44,   44,   56,   57,   58,   59,
        -: 9972:       60,   73,   74,   61,   61,  130,  131,   61,  405,   62,
        -: 9973:
        -: 9974:       44,   63,   64,   76,   73,   77,  130,  131,   78,   90,
        -: 9975:       91,   92,   90,   91,   92,  110,  206,  111,  105,  106,
        -: 9976:      107,  105,  106,  107,   44,   65,   61,   66,   67,   68,
        -: 9977:       59,   60,   69,  108,   61,   61,  108,  235,   61,  110,
        -: 9978:       70,  111,   63,   64,  235,   71,  113,  114,  113,  114,
        -: 9979:      207,  136,  137,  136,  137,  115,  405,  115,  138,  399,
        -: 9980:      138,  116,  117,  116,  117,  401,   65,   61,   81,   81,
        -: 9981:       82,   83,   81,   81,   81,   81,   81,   84,   81,   81,
        -: 9982:       81,   81,   81,   81,   81,   81,   81,   81,   85,   85,
        -: 9983:       85,   85,   85,   85,   85,   85,   85,   85,   85,   85,
        -: 9984:
        -: 9985:       85,   85,   86,   85,   85,   85,   85,   87,   81,   81,
        -: 9986:       81,   93,   93,   44,   93,   93,   93,   93,   93,   93,
        -: 9987:       94,   94,   93,   93,   93,   93,   95,   93,   93,   93,
        -: 9988:       93,   96,   96,   96,   96,   96,   96,   96,   96,   96,
        -: 9989:       96,   96,   96,   96,   96,   96,   96,   96,   96,   96,
        -: 9990:       96,   93,   93,   93,   99,  100,   99,  100,  399,  140,
        -: 9991:      141,  213,  101,  214,  101,  102,  142,  102,  140,  141,
        -: 9992:      144,  145,  146,  248,  249,  142,  144,  145,  146,  164,
        -: 9993:      165,  166,  169,  170,  171,  147,  190,  191,  192,  251,
        -: 9994:      249,  147,  257,  258,  103,  300,  103,  118,  118,  119,
        -: 9995:
        -: 9996:      120,  121,  118,  118,  122,  118,  118,  118,  118,  123,
        -: 9997:      118,  118,  118,  118,  118,  118,  118,  124,  124,  124,
        -: 9998:      124,  124,  124,  124,  124,  124,  124,  124,  124,  124,
        -: 9999:      124,  125,  124,  124,  124,  124,  126,  127,  118,  128,
        -:10000:      132,  133,  132,  133,  197,  197,  232,  197,  241,  260,
        -:10001:      258,  266,  164,  165,  166,  300,  267,  398,  242,  169,
        -:10002:      170,  171,  281,  282,  283,  292,  293,  296,  297,  198,
        -:10003:      198,  233,  198,  288,  284,  248,  249,  289,  251,  249,
        -:10004:      134,  397,  134,  148,  149,  150,  151,  148,  148,  152,
        -:10005:      148,  148,  153,  148,  148,  148,  148,  148,  148,  148,
        -:10006:
        -:10007:      148,  148,  148,  154,  154,  154,  154,  154,  154,  154,
        -:10008:      154,  154,  154,  154,  154,  154,  154,  155,  154,  154,
        -:10009:      154,  154,  156,  148,  148,  148,  158,  159,  160,  158,
        -:10010:      159,  160,  184,  185,  186,  396,  301,  187,  202,  203,
        -:10011:      204,  241,  266,  187,  281,  282,  283,  267,  281,  282,
        -:10012:      283,  242,  184,  185,  186,  392,  284,  187,  391,  161,
        -:10013:      284,  302,  161,  390,  162,  322,  323,  162,  174,  257,
        -:10014:      258,  389,  188,  260,  258,  292,  293,  285,  188,  286,
        -:10015:      339,  293,  345,  175,  388,  176,  300,  176,  296,  297,
        -:10016:      387,  176,  188,  176,  176,  177,  176,  178,  386,  179,
        -:10017:
        -:10018:      180,  367,  181,  199,  199,  300,  199,  199,  199,  199,
        -:10019:      199,  199,  199,  199,  199,  199,  200,  199,  199,  199,
        -:10020:      199,  199,  199,  201,  201,  201,  201,  201,  201,  201,
        -:10021:      201,  201,  201,  201,  201,  201,  201,  201,  201,  201,
        -:10022:      201,  201,  201,  199,  199,  199,  305,  305,  385,  305,
        -:10023:      305,  305,  305,  305,  305,  305,  305,  306,  305,  306,
        -:10024:      305,  305,  305,  305,  305,  305,  306,  306,  306,  306,
        -:10025:      306,  306,  306,  306,  306,  306,  306,  306,  306,  306,
        -:10026:      306,  306,  306,  306,  306,  306,  305,  305,  307,  202,
        -:10027:      203,  204,  341,  297,  187,  281,  282,  283,  331,  282,
        -:10028:
        -:10029:      283,  343,  322,  323,  357,  323,  299,  284,  394,  395,
        -:10030:      284,  331,  282,  283,  369,  383,  394,  395,  300,  300,
        -:10031:      400,  395,  403,  404,  403,  404,  344,  406,  404,  188,
        -:10032:      313,  313,  314,  315,  313,  313,  313,  313,  313,  316,
        -:10033:      313,  313,  313,  313,  313,  313,  313,  313,  313,  313,
        -:10034:      316,  316,  316,  316,  316,  316,  316,  316,  316,  316,
        -:10035:      316,  316,  316,  316,  316,  316,  316,  316,  316,  316,
        -:10036:      313,  313,  313,  324,  324,  300,  324,  324,  324,  324,
        -:10037:      324,  324,  325,  324,  324,  324,  324,  324,  324,  324,
        -:10038:      324,  324,  324,  325,  325,  325,  325,  325,  325,  325,
        -:10039:
        -:10040:      325,  325,  325,  325,  325,  325,  325,  325,  325,  325,
        -:10041:      325,  325,  325,  324,  324,  324,  346,  304,  318,  347,
        -:10042:      300,  304,  318,  347,  346,  346,  346,  346,  346,  346,
        -:10043:      316,  316,  300,  352,  316,  316,  316,  316,  316,  382,
        -:10044:      316,  316,  316,  316,  316,  316,  316,  316,  316,  316,
        -:10045:      353,  381,  380,  379,  353,  378,  377,  376,  375,  356,
        -:10046:      374,  373,  351,  350,  372,  371,  366,  340,  338,  365,
        -:10047:      316,  316,  316,  325,  325,  364,  325,  325,  325,  325,
        -:10048:      325,  325,  363,  325,  325,  325,  325,  325,  325,  325,
        -:10049:      325,  325,  325,  362,  361,  360,  359,  358,  356,  355,
        -:10050:
        -:10051:      354,  231,  351,  350,  349,  348,  196,  300,  342,  340,
        -:10052:      338,  336,  335,  325,  325,  325,  368,  333,  332,  330,
        -:10053:      300,  330,  329,  328,  368,  368,  368,  368,  368,  368,
        -:10054:      370,  274,  327,  326,  300,  269,  259,  259,  370,  370,
        -:10055:      370,  370,  370,  370,  384,  250,  250,  320,  300,  319,
        -:10056:      317,  229,  384,  384,  384,  384,  384,  384,   55,   55,
        -:10057:       55,   55,   55,   55,   55,   55,   55,   55,   55,   55,
        -:10058:       55,   55,   72,   72,   72,   72,   72,   72,   72,   72,
        -:10059:       72,   72,   72,   72,   72,   72,   75,   75,   75,   75,
        -:10060:       75,   75,   75,   75,   75,   75,   75,   75,   75,   75,
        -:10061:
        -:10062:       79,   79,   79,   79,   79,   79,   79,   79,   79,   79,
        -:10063:       79,   79,   79,   79,   89,   89,   89,   89,   89,   89,
        -:10064:       89,   89,   89,   89,   89,   89,   89,   89,   44,   44,
        -:10065:       44,   44,   44,   44,   44,   44,   44,   44,   44,   44,
        -:10066:       44,   44,   98,   98,   98,   98,   98,   98,   98,   98,
        -:10067:       98,   98,   98,   98,   98,   98,  104,  104,  104,  104,
        -:10068:      104,  104,  104,  104,  104,  104,  104,  104,  104,  104,
        -:10069:      109,  109,  109,  109,  109,  109,  109,  109,  109,  109,
        -:10070:      109,  109,  109,  109,  112,  112,  112,  112,  112,  112,
        -:10071:      112,  112,  112,  112,  112,  112,  112,  112,  129,  129,
        -:10072:
        -:10073:      129,  129,  129,  129,  129,  129,  129,  129,  129,  129,
        -:10074:      129,  129,  135,  135,  135,  135,  135,  135,  135,  135,
        -:10075:      135,  135,  135,  135,  135,  135,  139,  139,  139,  139,
        -:10076:      139,  139,  139,  139,  139,  139,  139,  139,  139,  139,
        -:10077:      143,  143,  143,  143,  143,  143,  143,  143,  143,  143,
        -:10078:      143,  143,  143,  143,  157,  157,  157,  157,  157,  157,
        -:10079:      157,  157,  157,  157,  157,  157,  157,  157,  168,  168,
        -:10080:      224,  312,  168,  168,  168,  173,  173,  173,  173,  173,
        -:10081:      173,  173,  173,  173,  173,  173,  173,  183,  183,  311,
        -:10082:      216,  183,  183,  183,  194,  194,  212,  194,  194,  194,
        -:10083:
        -:10084:      194,  194,  194,  194,  194,  194,  194,  194,  196,  196,
        -:10085:      205,  196,  196,  196,  196,  196,  196,  196,  196,  196,
        -:10086:      196,  196,  208,  208,  205,  208,  208,  208,  208,  208,
        -:10087:      208,  208,  208,  208,  208,  208,  210,  210,  303,  210,
        -:10088:      210,  210,  210,  210,  210,  210,  210,  210,  210,  210,
        -:10089:      211,  211,  300,  211,  211,  211,  211,  211,  211,  211,
        -:10090:      211,  211,  211,  211,  215,  215,  215,  215,  215,  215,
        -:10091:      215,  215,  215,  215,  215,  215,  215,  215,  217,  217,
        -:10092:      298,  217,  217,  190,  217,  217,  217,  217,  190,  294,
        -:10093:      189,  217,  219,  219,  189,  172,  219,  219,  219,  223,
        -:10094:
        -:10095:      223,  172,  223,  223,  223,  223,  223,  223,  223,  223,
        -:10096:      223,  223,  223,  227,  227,  167,  167,  227,  227,  227,
        -:10097:      231,  231,  278,  231,  231,  231,  231,  231,  231,  231,
        -:10098:      231,  231,  231,  231,  234,  234,  277,  234,  234,  234,
        -:10099:      234,  234,  234,  234,  234,  234,  234,  234,  237,  237,
        -:10100:      276,  237,  237,  237,  237,  237,  237,  275,  237,  237,
        -:10101:      237,  237,  238,  238,  275,  274,  272,  238,  238,  238,
        -:10102:      238,  238,  240,  240,  271,  240,  240,  240,  240,  240,
        -:10103:      240,  240,  240,  240,  240,  240,  244,  244,  269,  268,
        -:10104:      244,  244,  244,  247,  247,  247,  247,  247,  247,  247,
        -:10105:
        -:10106:      247,  247,  247,  247,  247,  247,  247,  253,  253,  268,
        -:10107:      253,  253,  263,  253,  253,  253,  253,  253,  253,  253,
        -:10108:      253,  256,  256,  256,  256,  256,  263,  256,  256,  256,
        -:10109:      256,  256,  256,  256,  256,  262,  262,  261,  259,  262,
        -:10110:      262,  262,  262,  255,  262,  262,  262,  262,  262,  264,
        -:10111:      264,  254,  264,  264,  264,  264,  264,  264,  264,  264,
        -:10112:      264,  264,  264,  265,  265,  254,  265,  265,  252,  265,
        -:10113:      265,  265,  265,  252,  250,  246,  265,  270,  270,  245,
        -:10114:      243,  270,  270,  270,  273,  239,  239,  273,  273,  273,
        -:10115:      273,  273,  273,  273,  273,  273,  273,  273,  279,  279,
        -:10116:
        -:10117:      236,  279,  279,  279,  279,  279,  279,  279,  279,  279,
        -:10118:      279,  279,  280,  280,  236,  280,  280,  280,  280,  280,
        -:10119:      280,  280,  280,  280,  280,  280,  287,  287,  287,  290,
        -:10120:      290,  290,  291,  291,  291,  291,  291,  291,  291,  291,
        -:10121:      291,  291,  291,  291,  291,  291,  295,  295,  295,  295,
        -:10122:      295,  295,  295,  295,  295,  295,  295,  295,  295,  295,
        -:10123:      299,  299,  230,  299,  299,  299,  299,  299,  299,  230,
        -:10124:      299,  299,  299,  299,  305,  305,  229,  305,  305,  305,
        -:10125:      305,  305,  305,  305,  305,  305,  305,  308,  308,  228,
        -:10126:      308,  308,  308,  308,  308,  308,  308,  308,  308,  308,
        -:10127:
        -:10128:      308,  309,  309,  228,  309,  309,  309,  309,  309,  309,
        -:10129:      309,  309,  309,  309,  309,  310,  310,  226,  310,  310,
        -:10130:      310,  310,  310,  310,  310,  310,  310,  310,  310,  321,
        -:10131:      321,  321,  321,  321,  321,  321,  321,  321,  321,  321,
        -:10132:      321,  321,  321,  334,  334,  225,  225,  334,  334,  334,
        -:10133:      337,  337,  224,  222,  337,  337,  337,  393,  393,  393,
        -:10134:      393,  393,  393,  393,  393,  393,  393,  393,  393,  393,
        -:10135:      393,  402,  402,  402,  402,  402,  402,  402,  402,  402,
        -:10136:      402,  402,  402,  402,  402,  221,  220,  218,  218,  216,
        -:10137:      209,  212,  209,  209,  193,  205,  205,  195,  193,  189,
        -:10138:
        -:10139:      189,  182,  172,  172,  167,  167,  407,  163,  163,   97,
        -:10140:       97,   88,   80,   80,   43,  407,  407,  407,  407,  407,
        -:10141:      407,  407,  407,  407,  407,  407,  407,  407,  407,  407,
        -:10142:      407,  407,  407,  407,  407,  407,  407,  407,  407,  407,
        -:10143:      407,  407,  407,  407,  407,  407,  407,  407,  407,  407,
        -:10144:      407,  407,  407,  407,  407,  407,  407,  407
        -:10145:    } ;
        -:10146:
        -:10147:static const short int yy_chk[1659] =
        -:10148:    {   0,
        -:10149:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:10150:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:10151:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:10152:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:10153:        1,    1,    1,    2,    2,    2,    2,    2,    2,    2,
        -:10154:        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
        -:10155:        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
        -:10156:        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
        -:10157:        2,    2,    2,    2,    2,    2,    3,    3,    3,    3,
        -:10158:        3,    5,    5,    3,    3,   27,   27,    3,  406,    3,
        -:10159:
        -:10160:       21,    3,    3,    6,    6,    6,   28,   28,    6,   11,
        -:10161:       11,   11,   12,   12,   12,   21,   69,   21,   19,   19,
        -:10162:       19,   20,   20,   20,   22,    3,    3,    4,    4,    4,
        -:10163:        4,    4,    4,   19,    4,    4,   20,  111,    4,   22,
        -:10164:        4,   22,    4,    4,  111,    4,   23,   23,   24,   24,
        -:10165:       69,   31,   31,   32,   32,   23,  403,   24,   31,  400,
        -:10166:       32,   23,   23,   24,   24,  396,    4,    4,    9,    9,
        -:10167:        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
        -:10168:        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
        -:10169:        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
        -:10170:
        -:10171:        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
        -:10172:        9,   13,   13,   13,   13,   13,   13,   13,   13,   13,
        -:10173:       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
        -:10174:       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
        -:10175:       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
        -:10176:       13,   13,   13,   13,   17,   17,   18,   18,  394,   33,
        -:10177:       33,   78,   17,   78,   18,   17,   33,   18,   34,   34,
        -:10178:       35,   35,   35,  129,  129,   34,   36,   36,   36,   45,
        -:10179:       45,   45,   49,   49,   49,   35,   60,   60,   60,  131,
        -:10180:      131,   36,  139,  139,   17,  384,   18,   25,   25,   25,
        -:10181:
        -:10182:       25,   25,   25,   25,   25,   25,   25,   25,   25,   25,
        -:10183:       25,   25,   25,   25,   25,   25,   25,   25,   25,   25,
        -:10184:       25,   25,   25,   25,   25,   25,   25,   25,   25,   25,
        -:10185:       25,   25,   25,   25,   25,   25,   25,   25,   25,   25,
        -:10186:       29,   29,   30,   30,   64,  108,  110,  116,  122,  141,
        -:10187:      141,  149,  164,  164,  164,  383,  149,  382,  122,  169,
        -:10188:      169,  169,  176,  176,  176,  181,  181,  188,  188,   64,
        -:10189:      108,  110,  116,  179,  176,  247,  247,  179,  249,  249,
        -:10190:       29,  381,   30,   37,   37,   37,   37,   37,   37,   37,
        -:10191:       37,   37,   37,   37,   37,   37,   37,   37,   37,   37,
        -:10192:
        -:10193:       37,   37,   37,   37,   37,   37,   37,   37,   37,   37,
        -:10194:       37,   37,   37,   37,   37,   37,   37,   37,   37,   37,
        -:10195:       37,   37,   37,   37,   37,   37,   39,   39,   39,   40,
        -:10196:       40,   40,   56,   56,   56,  380,  195,   56,   66,   66,
        -:10197:       66,  240,  266,   66,  175,  175,  175,  266,  177,  177,
        -:10198:      177,  240,  184,  184,  184,  378,  175,  184,  377,   39,
        -:10199:      177,  195,   40,  376,   39,  255,  255,   40,   52,  256,
        -:10200:      256,  375,   56,  258,  258,  291,  291,  175,   66,  177,
        -:10201:      293,  293,  301,   52,  374,   52,  301,   52,  295,  295,
        -:10202:      373,   52,  184,   52,   52,   52,   52,   52,  372,   52,
        -:10203:
        -:10204:       52,  343,   52,   65,   65,  343,   65,   65,   65,   65,
        -:10205:       65,   65,   65,   65,   65,   65,   65,   65,   65,   65,
        -:10206:       65,   65,   65,   65,   65,   65,   65,   65,   65,   65,
        -:10207:       65,   65,   65,   65,   65,   65,   65,   65,   65,   65,
        -:10208:       65,   65,   65,   65,   65,   65,  201,  201,  371,  201,
        -:10209:      201,  201,  201,  201,  201,  201,  201,  201,  201,  201,
        -:10210:      201,  201,  201,  201,  201,  201,  201,  201,  201,  201,
        -:10211:      201,  201,  201,  201,  201,  201,  201,  201,  201,  201,
        -:10212:      201,  201,  201,  201,  201,  201,  201,  201,  201,  202,
        -:10213:      202,  202,  297,  297,  202,  281,  281,  281,  284,  284,
        -:10214:
        -:10215:      284,  300,  321,  321,  323,  323,  300,  281,  379,  379,
        -:10216:      284,  331,  331,  331,  345,  367,  393,  393,  345,  367,
        -:10217:      395,  395,  401,  401,  402,  402,  300,  404,  404,  202,
        -:10218:      222,  222,  222,  222,  222,  222,  222,  222,  222,  222,
        -:10219:      222,  222,  222,  222,  222,  222,  222,  222,  222,  222,
        -:10220:      222,  222,  222,  222,  222,  222,  222,  222,  222,  222,
        -:10221:      222,  222,  222,  222,  222,  222,  222,  222,  222,  222,
        -:10222:      222,  222,  222,  269,  269,  370,  269,  269,  269,  269,
        -:10223:      269,  269,  269,  269,  269,  269,  269,  269,  269,  269,
        -:10224:      269,  269,  269,  269,  269,  269,  269,  269,  269,  269,
        -:10225:
        -:10226:      269,  269,  269,  269,  269,  269,  269,  269,  269,  269,
        -:10227:      269,  269,  269,  269,  269,  269,  302,  457,  462,  466,
        -:10228:      302,  457,  462,  466,  302,  302,  302,  302,  302,  302,
        -:10229:      316,  316,  369,  316,  316,  316,  316,  316,  316,  366,
        -:10230:      316,  316,  316,  316,  316,  316,  316,  316,  316,  316,
        -:10231:      467,  364,  363,  362,  467,  361,  360,  359,  358,  357,
        -:10232:      355,  354,  352,  351,  349,  348,  342,  341,  339,  336,
        -:10233:      316,  316,  316,  325,  325,  335,  325,  325,  325,  325,
        -:10234:      325,  325,  333,  325,  325,  325,  325,  325,  325,  325,
        -:10235:      325,  325,  325,  332,  329,  328,  327,  326,  322,  320,
        -:10236:
        -:10237:      319,  317,  315,  314,  312,  311,  303,  299,  298,  296,
        -:10238:      292,  289,  288,  325,  325,  325,  344,  286,  285,  283,
        -:10239:      344,  282,  277,  276,  344,  344,  344,  344,  344,  344,
        -:10240:      346,  274,  272,  271,  346,  267,  260,  257,  346,  346,
        -:10241:      346,  346,  346,  346,  368,  251,  248,  246,  368,  245,
        -:10242:      232,  229,  368,  368,  368,  368,  368,  368,  408,  408,
        -:10243:      408,  408,  408,  408,  408,  408,  408,  408,  408,  408,
        -:10244:      408,  408,  409,  409,  409,  409,  409,  409,  409,  409,
        -:10245:      409,  409,  409,  409,  409,  409,  410,  410,  410,  410,
        -:10246:      410,  410,  410,  410,  410,  410,  410,  410,  410,  410,
        -:10247:
        -:10248:      411,  411,  411,  411,  411,  411,  411,  411,  411,  411,
        -:10249:      411,  411,  411,  411,  412,  412,  412,  412,  412,  412,
        -:10250:      412,  412,  412,  412,  412,  412,  412,  412,  413,  413,
        -:10251:      413,  413,  413,  413,  413,  413,  413,  413,  413,  413,
        -:10252:      413,  413,  414,  414,  414,  414,  414,  414,  414,  414,
        -:10253:      414,  414,  414,  414,  414,  414,  415,  415,  415,  415,
        -:10254:      415,  415,  415,  415,  415,  415,  415,  415,  415,  415,
        -:10255:      416,  416,  416,  416,  416,  416,  416,  416,  416,  416,
        -:10256:      416,  416,  416,  416,  417,  417,  417,  417,  417,  417,
        -:10257:      417,  417,  417,  417,  417,  417,  417,  417,  418,  418,
        -:10258:
        -:10259:      418,  418,  418,  418,  418,  418,  418,  418,  418,  418,
        -:10260:      418,  418,  419,  419,  419,  419,  419,  419,  419,  419,
        -:10261:      419,  419,  419,  419,  419,  419,  420,  420,  420,  420,
        -:10262:      420,  420,  420,  420,  420,  420,  420,  420,  420,  420,
        -:10263:      421,  421,  421,  421,  421,  421,  421,  421,  421,  421,
        -:10264:      421,  421,  421,  421,  422,  422,  422,  422,  422,  422,
        -:10265:      422,  422,  422,  422,  422,  422,  422,  422,  423,  423,
        -:10266:      224,  221,  423,  423,  423,  424,  424,  424,  424,  424,
        -:10267:      424,  424,  424,  424,  424,  424,  424,  425,  425,  220,
        -:10268:      215,  425,  425,  425,  426,  426,  212,  426,  426,  426,
        -:10269:
        -:10270:      426,  426,  426,  426,  426,  426,  426,  426,  427,  427,
        -:10271:      204,  427,  427,  427,  427,  427,  427,  427,  427,  427,
        -:10272:      427,  427,  428,  428,  203,  428,  428,  428,  428,  428,
        -:10273:      428,  428,  428,  428,  428,  428,  429,  429,  197,  429,
        -:10274:      429,  429,  429,  429,  429,  429,  429,  429,  429,  429,
        -:10275:      430,  430,  194,  430,  430,  430,  430,  430,  430,  430,
        -:10276:      430,  430,  430,  430,  431,  431,  431,  431,  431,  431,
        -:10277:      431,  431,  431,  431,  431,  431,  431,  431,  432,  432,
        -:10278:      193,  432,  432,  192,  432,  432,  432,  432,  191,  187,
        -:10279:      186,  432,  433,  433,  185,  171,  433,  433,  433,  434,
        -:10280:
        -:10281:      434,  170,  434,  434,  434,  434,  434,  434,  434,  434,
        -:10282:      434,  434,  434,  435,  435,  166,  165,  435,  435,  435,
        -:10283:      436,  436,  163,  436,  436,  436,  436,  436,  436,  436,
        -:10284:      436,  436,  436,  436,  437,  437,  162,  437,  437,  437,
        -:10285:      437,  437,  437,  437,  437,  437,  437,  437,  438,  438,
        -:10286:      161,  438,  438,  438,  438,  438,  438,  160,  438,  438,
        -:10287:      438,  438,  439,  439,  159,  158,  156,  439,  439,  439,
        -:10288:      439,  439,  440,  440,  155,  440,  440,  440,  440,  440,
        -:10289:      440,  440,  440,  440,  440,  440,  441,  441,  152,  151,
        -:10290:      441,  441,  441,  442,  442,  442,  442,  442,  442,  442,
        -:10291:
        -:10292:      442,  442,  442,  442,  442,  442,  442,  443,  443,  150,
        -:10293:      443,  443,  145,  443,  443,  443,  443,  443,  443,  443,
        -:10294:      443,  444,  444,  444,  444,  444,  144,  444,  444,  444,
        -:10295:      444,  444,  444,  444,  444,  445,  445,  142,  140,  445,
        -:10296:      445,  445,  445,  138,  445,  445,  445,  445,  445,  446,
        -:10297:      446,  137,  446,  446,  446,  446,  446,  446,  446,  446,
        -:10298:      446,  446,  446,  447,  447,  136,  447,  447,  133,  447,
        -:10299:      447,  447,  447,  132,  130,  126,  447,  448,  448,  125,
        -:10300:      123,  448,  448,  448,  449,  120,  119,  449,  449,  449,
        -:10301:      449,  449,  449,  449,  449,  449,  449,  449,  450,  450,
        -:10302:
        -:10303:      114,  450,  450,  450,  450,  450,  450,  450,  450,  450,
        -:10304:      450,  450,  451,  451,  113,  451,  451,  451,  451,  451,
        -:10305:      451,  451,  451,  451,  451,  451,  452,  452,  452,  453,
        -:10306:      453,  453,  454,  454,  454,  454,  454,  454,  454,  454,
        -:10307:      454,  454,  454,  454,  454,  454,  455,  455,  455,  455,
        -:10308:      455,  455,  455,  455,  455,  455,  455,  455,  455,  455,
        -:10309:      456,  456,  106,  456,  456,  456,  456,  456,  456,  105,
        -:10310:      456,  456,  456,  456,  458,  458,  102,  458,  458,  458,
        -:10311:      458,  458,  458,  458,  458,  458,  458,  459,  459,  100,
        -:10312:      459,  459,  459,  459,  459,  459,  459,  459,  459,  459,
        -:10313:
        -:10314:      459,  460,  460,   99,  460,  460,  460,  460,  460,  460,
        -:10315:      460,  460,  460,  460,  460,  461,  461,   95,  461,  461,
        -:10316:      461,  461,  461,  461,  461,  461,  461,  461,  461,  463,
        -:10317:      463,  463,  463,  463,  463,  463,  463,  463,  463,  463,
        -:10318:      463,  463,  463,  464,  464,   92,   91,  464,  464,  464,
        -:10319:      465,  465,   90,   88,  465,  465,  465,  468,  468,  468,
        -:10320:      468,  468,  468,  468,  468,  468,  468,  468,  468,  468,
        -:10321:      468,  469,  469,  469,  469,  469,  469,  469,  469,  469,
        -:10322:      469,  469,  469,  469,  469,   87,   86,   83,   82,   79,
        -:10323:       77,   76,   74,   73,   70,   68,   67,   63,   62,   58,
        -:10324:
        -:10325:       57,   53,   51,   50,   47,   46,   43,   42,   41,   16,
        -:10326:       15,   10,    8,    7,  407,  407,  407,  407,  407,  407,
        -:10327:      407,  407,  407,  407,  407,  407,  407,  407,  407,  407,
        -:10328:      407,  407,  407,  407,  407,  407,  407,  407,  407,  407,
        -:10329:      407,  407,  407,  407,  407,  407,  407,  407,  407,  407,
        -:10330:      407,  407,  407,  407,  407,  407,  407,  407
        -:10331:    } ;
        -:10332:
        -:10333:static yy_state_type yy_last_accepting_state;
        -:10334:static char *yy_last_accepting_cpos;
        -:10335:
        -:10336:/* The intent behind this definition is that it'll catch
        -:10337: * any uses of REJECT which flex missed.
        -:10338: */
        -:10339:#define REJECT reject_used_but_not_detected
        -:10340:#define yymore() yymore_used_but_not_detected
        -:10341:#define YY_MORE_ADJ 0
        -:10342:char *yytext;
        -:10343:/* scan.l - scanner for flex input */
        -:10344:/*-
        -:10345: * Copyright (c) 1990 The Regents of the University of California.
        -:10346: * All rights reserved.
        -:10347: *
        -:10348: * This code is derived from software contributed to Berkeley by
        -:10349: * Vern Paxson.
        -:10350: * 
        -:10351: * The United States Government has rights in this work pursuant
        -:10352: * to contract no. DE-AC03-76SF00098 between the United States
        -:10353: * Department of Energy and the University of California.
        -:10354: *
        -:10355: * Redistribution and use in source and binary forms are permitted provided
        -:10356: * that: (1) source distributions retain this entire copyright notice and
        -:10357: * comment, and (2) distributions including binaries display the following
        -:10358: * acknowledgement:  ``This product includes software developed by the
        -:10359: * University of California, Berkeley and its contributors'' in the
        -:10360: * documentation or other materials provided with the distribution and in
        -:10361: * all advertising materials mentioning features or use of this software.
        -:10362: * Neither the name of the University nor the names of its contributors may
        -:10363: * be used to endorse or promote products derived from this software without
        -:10364: * specific prior written permission.
        -:10365: * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
        -:10366: * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
        -:10367: * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
        -:10368: */
        -:10369:
        -:10370:/* $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.orig/v0/flex.c,v 1.1.1.1 2003/06/02 17:12:00 expsir Exp $ */
        -:10371:
        -:10372:
        -:10373:#define ACTION_ECHO add_action( yytext )
        -:10374:#define MARK_END_OF_PROLOG mark_prolog();
        -:10375:
        -:10376:#define YY_DECL \
        -:10377:	int flexscan()
        -:10378:
        -:10379:#define RETURNCHAR \
        -:10380:	yylval = yytext[0]; \
        -:10381:	return CHAR;
        -:10382:
        -:10383:#define RETURNNAME \
        -:10384:	yy_strcpy( nmstr, yytext ); \
        -:10385:	return NAME;
        -:10386:
        -:10387:#define PUT_BACK_STRING(str, start) \
        -:10388:	for ( i = yy_strlen( str ) - 1; i >= start; --i ) \
        -:10389:		unput((str)[i])
        -:10390:
        -:10391:#define CHECK_REJECT(str) \
        -:10392:	if ( all_upper( str ) ) \
        -:10393:		reject = true;
        -:10394:
        -:10395:#define CHECK_YYMORE(str) \
        -:10396:	if ( all_lower( str ) ) \
        -:10397:		yymore_used = true;
        -:10398:
        -:10399:/* Macros after this point can all be overridden by user definitions in
        -:10400: * section 1.
        -:10401: */
        -:10402:
        -:10403:/* Amount of stuff to slurp up with each read. */
        -:10404:#ifndef YY_READ_BUF_SIZE
        -:10405:#define YY_READ_BUF_SIZE 8192
        -:10406:#endif
        -:10407:
        -:10408:/* Copy whatever the last rule matched to the standard output. */
        -:10409:
        -:10410:#ifndef ECHO
        -:10411:/* This used to be an fputs(), but since the string might contain NUL's,
        -:10412: * we now use fwrite().
        -:10413: */
        -:10414:#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )
        -:10415:#endif
        -:10416:
        -:10417:/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
        -:10418: * is returned in "result".
        -:10419: */
        -:10420:#ifndef YY_INPUT
        -:10421:#define YY_INPUT(buf,result,max_size) \
        -:10422:	if ( yy_current_buffer->is_interactive ) \
        -:10423:		result = ((int) (buf[0] = getc( yyin ))) == EOF ? 0 : 1; \
        -:10424:	else if ( ((result = fread( (char *) buf, 1, max_size, yyin )) == 0)\
        -:10425:		  && ferror( yyin ) ) \
        -:10426:		YY_FATAL_ERROR( "input in flex scanner failed" );
        -:10427:#endif
        -:10428:
        -:10429:/* No semi-colon after return; correct usage is to write "yyterminate();" -
        -:10430: * we don't want an extra ';' after the "return" because that will cause
        -:10431: * some compilers to complain about unreachable statements.
        -:10432: */
        -:10433:#ifndef yyterminate
        -:10434:#define yyterminate() return YY_NULL
        -:10435:#endif
        -:10436:
        -:10437:/* Report a fatal error. */
        -:10438:#ifndef YY_FATAL_ERROR
        -:10439:#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
        -:10440:#endif
        -:10441:
        -:10442:/* Default declaration of generated scanner - a define so the user can
        -:10443: * easily add parameters.
        -:10444: */
        -:10445:#ifndef YY_DECL
        -:10446:#define YY_DECL int yylex YY_PROTO(( void ))
        -:10447:#endif
        -:10448:
        -:10449:/* Code executed at the end of each rule. */
        -:10450:#ifndef YY_BREAK
        -:10451:#define YY_BREAK break;
        -:10452:#endif
        -:10453:
function flexscan called 28077 returned 100% blocks executed 67%
    28077:10454:YY_DECL
        -:10455:	{
        -:10456:	register yy_state_type yy_current_state;
        -:10457:	register char *yy_cp, *yy_bp;
        -:10458:	register int yy_act;
        -:10459:
        -:10460:
        -:10461:	static int bracelevel, didadef, indented_code, checking_used;
        -:10462:
    28077:10463:	int doing_codeblock = false;
        -:10464:	int i;
        -:10465:	Char nmdef[MAXLINE], myesc();
        -:10466:
        -:10467:
        -:10468:
    28077:10469:	if ( yy_init )
branch  0 taken 549 (fallthrough)
branch  1 taken 27528
        -:10470:		{
        -:10471:#ifdef YY_USER_INIT
        -:10472:		YY_USER_INIT;
        -:10473:#endif
        -:10474:
      549:10475:		if ( ! yy_start )
branch  0 taken 549 (fallthrough)
branch  1 taken 0
      549:10476:			yy_start = 1;	/* first start state */
        -:10477:
      549:10478:		if ( ! yyin )
branch  0 taken 0 (fallthrough)
branch  1 taken 549
    #####:10479:			yyin = stdin;
        -:10480:
      549:10481:		if ( ! yyout )
branch  0 taken 549 (fallthrough)
branch  1 taken 0
      549:10482:			yyout = stdout;
        -:10483:
      549:10484:		if ( yy_current_buffer )
branch  0 taken 0 (fallthrough)
branch  1 taken 549
    #####:10485:			yy_init_buffer( yy_current_buffer, yyin );
call    0 never executed
        -:10486:		else
      549:10487:			yy_current_buffer =
      549:10488:				yy_create_buffer( yyin, YY_BUF_SIZE );
call    0 returned 549
        -:10489:
      549:10490:		yy_load_buffer_state();
call    0 returned 549
        -:10491:
      549:10492:		yy_init = 0;
        -:10493:		}
        -:10494:
        -:10495:	while ( 1 )		/* loops until end-of-file is reached */
        -:10496:		{
    68816:10497:		yy_cp = yy_c_buf_p;
        -:10498:
        -:10499:		/* Support of yytext. */
    68816:10500:		*yy_cp = yy_hold_char;
        -:10501:
        -:10502:		/* yy_bp points to the position in yy_ch_buf of the start of
        -:10503:		 * the current run.
        -:10504:		 */
    68816:10505:		yy_bp = yy_cp;
        -:10506:
    68816:10507:		yy_current_state = yy_start;
    68816:10508:		if ( yy_bp[-1] == '\n' )
branch  0 taken 59303 (fallthrough)
branch  1 taken 9513
     9513:10509:			++yy_current_state;
    69366:10510:yy_match:
        -:10511:		do
        -:10512:			{
   281167:10513:			register YY_CHAR yy_c = yy_ec[(unsigned int) *yy_cp];
   281167:10514:			if ( yy_accept[yy_current_state] )
branch  0 taken 214324 (fallthrough)
branch  1 taken 66843
        -:10515:				{
   214324:10516:				yy_last_accepting_state = yy_current_state;
   214324:10517:				yy_last_accepting_cpos = yy_cp;
        -:10518:				}
   525697:10519:			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
branch  0 taken 244530
branch  1 taken 281167 (fallthrough)
        -:10520:				{
   244530:10521:				yy_current_state = (int) yy_def[yy_current_state];
   244530:10522:				if ( yy_current_state >= 408 )
branch  0 taken 206154 (fallthrough)
branch  1 taken 38376
   206154:10523:					yy_c = yy_meta[(unsigned int) yy_c];
        -:10524:				}
   281167:10525:			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
   281167:10526:			++yy_cp;
        -:10527:			}
   281167:10528:		while ( yy_base[yy_current_state] != 1615 );
branch  0 taken 211801
branch  1 taken 69366 (fallthrough)
        -:10529:
    69366:10530:yy_find_action:
   105733:10531:		yy_act = yy_accept[yy_current_state];
        -:10532:
   105733:10533:		YY_DO_BEFORE_ACTION;
        -:10534:
        -:10535:#ifdef YY_USER_ACTION
        -:10536:		if ( yy_act != YY_END_OF_BUFFER )
        -:10537:			{
        -:10538:			YY_USER_ACTION;
        -:10539:			}
        -:10540:#endif
        -:10541:
        -:10542:
   106276:10543:do_action:	/* This label is used only to access EOF actions. */
        -:10544:
        -:10545:
   106276:10546:		switch ( yy_act )
branch  0 taken 35927
branch  1 taken 6
branch  2 taken 111
branch  3 taken 1
branch  4 taken 12
branch  5 taken 115
branch  6 taken 13
branch  7 taken 549
branch  8 taken 0
branch  9 taken 0
branch 10 taken 0
branch 11 taken 0
branch 12 taken 0
branch 13 taken 0
branch 14 taken 235
branch 15 taken 13
branch 16 taken 344
branch 17 taken 13
branch 18 taken 0
branch 19 taken 111
branch 20 taken 111
branch 21 taken 0
branch 22 taken 0
branch 23 taken 115
branch 24 taken 0
branch 25 taken 0
branch 26 taken 3125
branch 27 taken 231
branch 28 taken 235
branch 29 taken 235
branch 30 taken 235
branch 31 taken 0
branch 32 taken 0
branch 33 taken 0
branch 34 taken 0
branch 35 taken 0
branch 36 taken 0
branch 37 taken 0
branch 38 taken 0
branch 39 taken 0
branch 40 taken 548
branch 41 taken 0
branch 42 taken 978
branch 43 taken 1
branch 44 taken 900
branch 45 taken 1
branch 46 taken 9
branch 47 taken 98
branch 48 taken 1075
branch 49 taken 292
branch 50 taken 0
branch 51 taken 100
branch 52 taken 0
branch 53 taken 8
branch 54 taken 2938
branch 55 taken 9
branch 56 taken 9
branch 57 taken 117
branch 58 taken 1495
branch 59 taken 449
branch 60 taken 3577
branch 61 taken 6732
branch 62 taken 3
branch 63 taken 9
branch 64 taken 0
branch 65 taken 10
branch 66 taken 0
branch 67 taken 0
branch 68 taken 1873
branch 69 taken 1075
branch 70 taken 0
branch 71 taken 214
branch 72 taken 0
branch 73 taken 1052
branch 74 taken 863
branch 75 taken 2656
branch 76 taken 1273
branch 77 taken 0
branch 78 taken 390
branch 79 taken 195
branch 80 taken 292
branch 81 taken 0
branch 82 taken 0
branch 83 taken 0
branch 84 taken 0
branch 85 taken 0
branch 86 taken 0
branch 87 taken 6
branch 88 taken 4
branch 89 taken 9
branch 90 taken 1
branch 91 taken 362
branch 92 taken 362
branch 93 taken 9372
branch 94 taken 5943
branch 95 taken 230
branch 96 taken 6
branch 97 taken 2678
branch 98 taken 3688
branch 99 taken 0
branch 100 taken 230
branch 101 taken 0
branch 102 taken 230
branch 103 taken 0
branch 104 taken 2678
branch 105 taken 2664
branch 106 taken 0
branch 107 taken 2678
branch 108 taken 0
branch 109 taken 0
branch 110 taken 562
branch 111 taken 7
branch 112 taken 1512
branch 113 taken 111
branch 114 taken 0
branch 115 taken 0
branch 116 taken 431
branch 117 taken 1534
branch 118 taken 0
        -:10547:	{ /* beginning of action switch */
    35927:10548:			case 0: /* must back up */
        -:10549:			/* undo the effects of YY_DO_BEFORE_ACTION */
    35927:10550:			*yy_cp = yy_hold_char;
    35927:10551:			yy_cp = yy_last_accepting_cpos;
    35927:10552:			yy_current_state = yy_last_accepting_state;
    35927:10553:			goto yy_find_action;
        -:10554:
        6:10555:case 1:
        6:10556:indented_code = true; BEGIN(CODEBLOCK);
        6:10557:	YY_BREAK
      111:10558:case 2:
      111:10559:ACTION_ECHO; BEGIN(C_COMMENT);
call    0 returned 111
      111:10560:	YY_BREAK
        1:10561:case 3:
        1:10562:return SCDECL;
        -:10563:	YY_BREAK
       12:10564:case 4:
       12:10565:return XSCDECL;
        -:10566:	YY_BREAK
      115:10567:case 5:
        -:10568:{
      115:10569:			++linenum;
      115:10570:			line_directive_out( (FILE *) 0 );
call    0 returned 115
      115:10571:			indented_code = false;
      115:10572:			BEGIN(CODEBLOCK);
        -:10573:			}
      115:10574:	YY_BREAK
       13:10575:case 6:
       13:10576:return WHITESPACE;
        -:10577:	YY_BREAK
      549:10578:case 7:
        -:10579:{
      549:10580:			sectnum = 2;
      549:10581:			bracelevel = 0;
      549:10582:			mark_defs1();
call    0 returned 549
      549:10583:			line_directive_out( (FILE *) 0 );
call    0 returned 549
      549:10584:			BEGIN(SECT2PROLOG);
      549:10585:			return SECTEND;
        -:10586:			}
        -:10587:	YY_BREAK
    #####:10588:case 8:
        -:10589:{
    #####:10590:			if ( lex_compat )
branch  0 never executed
branch  1 never executed
    #####:10591:				warn( "%pointer incompatible with -l option" );
call    0 never executed
        -:10592:			else
    #####:10593:				yytext_is_array = false;
    #####:10594:			++linenum;
        -:10595:			}
    #####:10596:	YY_BREAK
    #####:10597:case 9:
        -:10598:{
    #####:10599:			if ( C_plus_plus )
branch  0 never executed
branch  1 never executed
    #####:10600:				warn( "%array incompatible with -+ option" );
call    0 never executed
        -:10601:			else
    #####:10602:				yytext_is_array = true;
    #####:10603:			++linenum;
        -:10604:			}
    #####:10605:	YY_BREAK
    #####:10606:case 10:
        -:10607:{
    #####:10608:			warn( "%used/%unused have been deprecated" );
call    0 never executed
    #####:10609:			checking_used = REALLY_USED; BEGIN(USED_LIST);
        -:10610:			}
    #####:10611:	YY_BREAK
    #####:10612:case 11:
        -:10613:{
    #####:10614:			warn( "%used/%unused have been deprecated" );
call    0 never executed
    #####:10615:			checking_used = REALLY_NOT_USED; BEGIN(USED_LIST);
        -:10616:			}
    #####:10617:	YY_BREAK
    #####:10618:case 12:
    #####:10619:++linenum;	/* ignore */
    #####:10620:	YY_BREAK
    #####:10621:case 13:
    #####:10622:synerr( "unrecognized '%' directive" );
call    0 never executed
    #####:10623:	YY_BREAK
      235:10624:case 14:
        -:10625:{
      235:10626:			yy_strcpy( nmstr, yytext );
call    0 returned 235
      235:10627:			didadef = false;
      235:10628:			BEGIN(PICKUPDEF);
        -:10629:			}
      235:10630:	YY_BREAK
       13:10631:case 15:
       13:10632:RETURNNAME;
call    0 returned 13
        -:10633:	YY_BREAK
      344:10634:case 16:
      344:10635:++linenum; /* allows blank lines in section 1 */
      344:10636:	YY_BREAK
       13:10637:case 17:
       13:10638:++linenum; return '\n';
        -:10639:	YY_BREAK
    #####:10640:case 18:
    #####:10641:ACTION_ECHO; BEGIN(INITIAL);
call    0 never executed
    #####:10642:	YY_BREAK
      111:10643:case 19:
      111:10644:++linenum; ACTION_ECHO; BEGIN(INITIAL);
call    0 returned 111
      111:10645:	YY_BREAK
      111:10646:case 20:
      111:10647:ACTION_ECHO;
call    0 returned 111
      111:10648:	YY_BREAK
    #####:10649:case 21:
    #####:10650:ACTION_ECHO;
call    0 never executed
    #####:10651:	YY_BREAK
    #####:10652:case 22:
    #####:10653:++linenum; ACTION_ECHO;
call    0 never executed
    #####:10654:	YY_BREAK
      115:10655:case 23:
      115:10656:++linenum; BEGIN(INITIAL);
      115:10657:	YY_BREAK
    #####:10658:case 24:
    #####:10659:ACTION_ECHO; CHECK_REJECT(yytext);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:10660:	YY_BREAK
    #####:10661:case 25:
    #####:10662:ACTION_ECHO; CHECK_YYMORE(yytext);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:10663:	YY_BREAK
     3125:10664:case 26:
     3125:10665:ACTION_ECHO;
call    0 returned 3125
     3125:10666:	YY_BREAK
      231:10667:case 27:
        -:10668:{
      231:10669:			++linenum;
      231:10670:			ACTION_ECHO;
call    0 returned 231
      231:10671:			if ( indented_code )
branch  0 taken 6 (fallthrough)
branch  1 taken 225
        6:10672:				BEGIN(INITIAL);
        -:10673:			}
      231:10674:	YY_BREAK
      235:10675:case 28:
        -:10676:/* separates name and definition */
      235:10677:	YY_BREAK
      235:10678:case 29:
        -:10679:{
      235:10680:			yy_strcpy( (char *) nmdef, yytext );
call    0 returned 235
        -:10681:
        -:10682:			/* Skip trailing whitespace. */
      235:10683:			for ( i = yy_strlen( (char *) nmdef ) - 1;
call    0 returned 235
      235:10684:			      i >= 0 && (nmdef[i] == ' ' || nmdef[i] == '\t');
branch  0 taken 235 (fallthrough)
branch  1 taken 0
branch  2 taken 0
branch  3 taken 235 (fallthrough)
branch  4 taken 0
branch  5 taken 235 (fallthrough)
    #####:10685:			      --i )
        -:10686:				;
        -:10687:
      235:10688:			nmdef[i + 1] = '\0';
        -:10689:
      235:10690:			ndinstal( nmstr, nmdef );
call    0 returned 235
      235:10691:			didadef = true;
        -:10692:			}
      235:10693:	YY_BREAK
      235:10694:case 30:
        -:10695:{
      235:10696:			if ( ! didadef )
branch  0 taken 0 (fallthrough)
branch  1 taken 235
    #####:10697:				synerr( "incomplete name definition" );
call    0 never executed
      235:10698:			BEGIN(INITIAL);
      235:10699:			++linenum;
        -:10700:			}
      235:10701:	YY_BREAK
    #####:10702:case 31:
    #####:10703:++linenum; BEGIN(INITIAL); RETURNNAME;
call    0 never executed
        -:10704:	YY_BREAK
    #####:10705:case 32:
    #####:10706:++linenum; BEGIN(INITIAL);
    #####:10707:	YY_BREAK
    #####:10708:case 33:
        -:10709:
    #####:10710:	YY_BREAK
    #####:10711:case 34:
        -:10712:{
    #####:10713:			if ( all_upper( yytext ) )
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:10714:				reject_really_used = checking_used;
        -:10715:			else
    #####:10716:				synerr(
call    0 never executed
        -:10717:				"unrecognized %used/%unused construct" );
        -:10718:			}
    #####:10719:	YY_BREAK
    #####:10720:case 35:
        -:10721:{
    #####:10722:			if ( all_lower( yytext ) )
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:10723:				yymore_really_used = checking_used;
        -:10724:			else
    #####:10725:				synerr(
call    0 never executed
        -:10726:				"unrecognized %used/%unused construct" );
        -:10727:			}
    #####:10728:	YY_BREAK
    #####:10729:case 36:
    #####:10730:synerr( "unrecognized %used/%unused construct" );
call    0 never executed
    #####:10731:	YY_BREAK
    #####:10732:case 37:
    #####:10733:++bracelevel; yyless( 2 );	/* eat only %{ */
    #####:10734:	YY_BREAK
    #####:10735:case 38:
    #####:10736:--bracelevel; yyless( 2 );	/* eat only %} */
    #####:10737:	YY_BREAK
    #####:10738:case 39:
    #####:10739:ACTION_ECHO;	/* indented code in prolog */
call    0 never executed
    #####:10740:	YY_BREAK
      548:10741:case 40:
        -:10742:{	/* non-indented code */
      548:10743:			if ( bracelevel <= 0 )
branch  0 taken 548 (fallthrough)
branch  1 taken 0
        -:10744:				{ /* not in %{ ... %} */
      548:10745:				yyless( 0 );	/* put it all back */
      548:10746:				mark_prolog();
call    0 returned 548
      548:10747:				BEGIN(SECT2);
        -:10748:				}
        -:10749:			else
    #####:10750:				ACTION_ECHO;
call    0 never executed
        -:10751:			}
      548:10752:	YY_BREAK
    #####:10753:case 41:
    #####:10754:ACTION_ECHO;
call    0 never executed
    #####:10755:	YY_BREAK
      978:10756:case 42:
      978:10757:++linenum; ACTION_ECHO;
call    0 returned 978
      978:10758:	YY_BREAK
        1:10759:case YY_STATE_EOF(SECT2PROLOG):
        -:10760:{
        1:10761:			mark_prolog();
call    0 returned 1
        1:10762:			sectnum = 0;
        1:10763:			yyterminate(); /* to stop the parser */
        -:10764:			}
        -:10765:	YY_BREAK
      900:10766:case 43:
      900:10767:++linenum; /* allow blank lines in section 2 */
      900:10768:	YY_BREAK
        1:10769:case 44:
        -:10770:{
        1:10771:			indented_code = (yytext[0] != '%');
        1:10772:			doing_codeblock = true;
        1:10773:			bracelevel = 1;
        -:10774:
        1:10775:			if ( indented_code )
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:10776:				ACTION_ECHO;
call    0 returned 1
        -:10777:
        1:10778:			BEGIN(CODEBLOCK_2);
        -:10779:			}
        1:10780:	YY_BREAK
        9:10781:case 45:
        9:10782:BEGIN(SC); return '<';
        -:10783:	YY_BREAK
       98:10784:case 46:
       98:10785:return '^';
        -:10786:	YY_BREAK
     1075:10787:case 47:
     1075:10788:BEGIN(QUOTE); return '"';
        -:10789:	YY_BREAK
      292:10790:case 48:
      292:10791:*yy_cp = yy_hold_char; /* undo effects of setting up yytext */
      292:10792:yy_c_buf_p = yy_cp = yy_bp + 1;
      292:10793:YY_DO_BEFORE_ACTION; /* set up yytext again */
      292:10794:BEGIN(NUM); return '{';
        -:10795:	YY_BREAK
    #####:10796:case 49:
    #####:10797:BEGIN(BRACEERROR);
    #####:10798:	YY_BREAK
      100:10799:case 50:
      100:10800:*yy_cp = yy_hold_char; /* undo effects of setting up yytext */
      100:10801:yy_c_buf_p = yy_cp = yy_bp + 1;
      100:10802:YY_DO_BEFORE_ACTION; /* set up yytext again */
      100:10803:return '$';
        -:10804:	YY_BREAK
    #####:10805:case 51:
        -:10806:{
    #####:10807:			bracelevel = 1;
    #####:10808:			BEGIN(PERCENT_BRACE_ACTION);
    #####:10809:			return '\n';
        -:10810:			}
        -:10811:	YY_BREAK
        8:10812:case 52:
        8:10813:continued_action = true; ++linenum; return '\n';
        -:10814:	YY_BREAK
     2938:10815:case 53:
        -:10816:{
        -:10817:			/* This rule is separate from the one below because
        -:10818:			 * otherwise we get variable trailing context, so
        -:10819:			 * we can't build the scanner using -{f,F}.
        -:10820:			 */
     2938:10821:			bracelevel = 0;
     2938:10822:			continued_action = false;
     2938:10823:			BEGIN(ACTION);
     2938:10824:			return '\n';
        -:10825:			}
        -:10826:	YY_BREAK
        9:10827:case 54:
        -:10828:{
        9:10829:			bracelevel = 0;
        9:10830:			continued_action = false;
        9:10831:			BEGIN(ACTION);
        9:10832:			unput( '\n' );	/* so <ACTION> sees it */
call    0 returned 9
        9:10833:			return '\n';
        -:10834:			}
        -:10835:	YY_BREAK
        9:10836:case 55:
        9:10837:return EOF_OP;
        -:10838:	YY_BREAK
      117:10839:case 56:
        -:10840:{
      117:10841:			sectnum = 3;
      117:10842:			BEGIN(SECT3);
      117:10843:			yyterminate(); /* to stop the parser */
        -:10844:			}
        -:10845:	YY_BREAK
     1495:10846:case 57:
        -:10847:{
        -:10848:			int cclval;
        -:10849:
     1495:10850:			yy_strcpy( nmstr, yytext );
call    0 returned 1495
        -:10851:
        -:10852:			/* Check to see if we've already encountered this
        -:10853:			 * ccl.
        -:10854:			 */
     1495:10855:			if ( (cclval = ccllookup( (Char *) nmstr )) )
call    0 returned 1495
branch  1 taken 222 (fallthrough)
branch  2 taken 1273
        -:10856:				{
      222:10857:				if ( input() != ']' )
call    0 returned 222
branch  1 taken 0 (fallthrough)
branch  2 taken 222
    #####:10858:					synerr( "bad character class" );
call    0 never executed
        -:10859:
      222:10860:				yylval = cclval;
      222:10861:				++cclreuse;
      222:10862:				return PREVCCL;
        -:10863:				}
        -:10864:			else
        -:10865:				{
        -:10866:				/* We fudge a bit.  We know that this ccl will
        -:10867:				 * soon be numbered as lastccl + 1 by cclinit.
        -:10868:				 */
     1273:10869:				cclinstal( (Char *) nmstr, lastccl + 1 );
call    0 returned 1273
        -:10870:
        -:10871:				/* Push back everything but the leading bracket
        -:10872:				 * so the ccl can be rescanned.
        -:10873:				 */
     1273:10874:				yyless( 1 );
        -:10875:
     1273:10876:				BEGIN(FIRSTCCL);
     1273:10877:				return '[';
        -:10878:				}
        -:10879:			}
        -:10880:	YY_BREAK
      449:10881:case 58:
        -:10882:{
        -:10883:			register Char *nmdefptr;
        -:10884:			Char *ndlookup();
        -:10885:
      449:10886:			yy_strcpy( nmstr, yytext + 1 );
call    0 returned 449
      449:10887:			nmstr[yyleng - 2] = '\0';  /* chop trailing brace */
        -:10888:
      449:10889:			if ( ! (nmdefptr = ndlookup( nmstr )) )
call    0 returned 449
branch  1 taken 4 (fallthrough)
branch  2 taken 445
        4:10890:				format_synerr( "undefined definition {%s}",
call    0 returned 4
        -:10891:						nmstr );
        -:10892:
        -:10893:			else
        -:10894:				{ /* push back name surrounded by ()'s */
      445:10895:				int len = yy_strlen( (char *) nmdefptr );
call    0 returned 445
        -:10896:
      445:10897:				if ( lex_compat || nmdefptr[0] == '^' ||
branch  0 taken 308 (fallthrough)
branch  1 taken 137
branch  2 taken 308 (fallthrough)
branch  3 taken 0
branch  4 taken 308 (fallthrough)
branch  5 taken 0
      308:10898:				     (len > 0 && nmdefptr[len - 1] == '$') )
branch  0 taken 0 (fallthrough)
branch  1 taken 308
        -:10899:					{ /* don't use ()'s after all */
     1137:10900:					PUT_BACK_STRING((char *) nmdefptr, 0);
call    0 returned 137
call    1 returned 1000
branch  2 taken 1000
branch  3 taken 137 (fallthrough)
        -:10901:
      137:10902:					if ( nmdefptr[0] == '^' )
branch  0 taken 0 (fallthrough)
branch  1 taken 137
    #####:10903:						BEGIN(CARETISBOL);
        -:10904:					}
        -:10905:
        -:10906:				else
        -:10907:					{
      308:10908:					unput(')');
call    0 returned 308
     2570:10909:					PUT_BACK_STRING((char *) nmdefptr, 0);
call    0 returned 308
call    1 returned 2262
branch  2 taken 2262
branch  3 taken 308 (fallthrough)
      308:10910:					unput('(');
call    0 returned 308
        -:10911:					}
        -:10912:				}
        -:10913:			}
      449:10914:	YY_BREAK
     3577:10915:case 59:
     3577:10916:return (int) yytext[0];
        -:10917:	YY_BREAK
     6732:10918:case 60:
     6732:10919:RETURNCHAR;
        -:10920:	YY_BREAK
        3:10921:case 61:
        3:10922:return (int) yytext[0];
        -:10923:	YY_BREAK
        9:10924:case 62:
        9:10925:BEGIN(SECT2); return '>';
        -:10926:	YY_BREAK
    #####:10927:case 63:
    #####:10928:*yy_cp = yy_hold_char; /* undo effects of setting up yytext */
    #####:10929:yy_c_buf_p = yy_cp = yy_bp + 1;
    #####:10930:YY_DO_BEFORE_ACTION; /* set up yytext again */
    #####:10931:BEGIN(CARETISBOL); return '>';
        -:10932:	YY_BREAK
       10:10933:case 64:
       10:10934:RETURNNAME;
call    0 returned 10
        -:10935:	YY_BREAK
    #####:10936:case 65:
        -:10937:{
    #####:10938:			format_synerr( "bad <start condition>: %s", yytext );
call    0 never executed
        -:10939:			}
    #####:10940:	YY_BREAK
    #####:10941:case 66:
    #####:10942:BEGIN(SECT2); return '^';
        -:10943:	YY_BREAK
     1873:10944:case 67:
     1873:10945:RETURNCHAR;
        -:10946:	YY_BREAK
     1075:10947:case 68:
     1075:10948:BEGIN(SECT2); return '"';
        -:10949:	YY_BREAK
    #####:10950:case 69:
        -:10951:{
    #####:10952:			synerr( "missing quote" );
call    0 never executed
    #####:10953:			BEGIN(SECT2);
    #####:10954:			++linenum;
    #####:10955:			return '"';
        -:10956:			}
        -:10957:	YY_BREAK
      214:10958:case 70:
      214:10959:*yy_cp = yy_hold_char; /* undo effects of setting up yytext */
      214:10960:yy_c_buf_p = yy_cp = yy_bp + 1;
      214:10961:YY_DO_BEFORE_ACTION; /* set up yytext again */
      214:10962:BEGIN(CCL); return '^';
        -:10963:	YY_BREAK
    #####:10964:case 71:
    #####:10965:*yy_cp = yy_hold_char; /* undo effects of setting up yytext */
    #####:10966:yy_c_buf_p = yy_cp = yy_bp + 1;
    #####:10967:YY_DO_BEFORE_ACTION; /* set up yytext again */
    #####:10968:return '^';
        -:10969:	YY_BREAK
     1052:10970:case 72:
     1052:10971:BEGIN(CCL); RETURNCHAR;
        -:10972:	YY_BREAK
      863:10973:case 73:
      863:10974:*yy_cp = yy_hold_char; /* undo effects of setting up yytext */
      863:10975:yy_c_buf_p = yy_cp = yy_bp + 1;
      863:10976:YY_DO_BEFORE_ACTION; /* set up yytext again */
      863:10977:return '-';
        -:10978:	YY_BREAK
     2656:10979:case 74:
     2656:10980:RETURNCHAR;
        -:10981:	YY_BREAK
     1273:10982:case 75:
     1273:10983:BEGIN(SECT2); return ']';
        -:10984:	YY_BREAK
    #####:10985:case 76:
        -:10986:{
    #####:10987:			synerr( "bad character class" );
call    0 never executed
    #####:10988:			BEGIN(SECT2);
    #####:10989:			return ']';
        -:10990:			}
        -:10991:	YY_BREAK
      390:10992:case 77:
        -:10993:{
      390:10994:			yylval = myctoi( yytext );
call    0 returned 390
      390:10995:			return NUMBER;
        -:10996:			}
        -:10997:	YY_BREAK
      195:10998:case 78:
      195:10999:return ',';
        -:11000:	YY_BREAK
      292:11001:case 79:
      292:11002:BEGIN(SECT2); return '}';
        -:11003:	YY_BREAK
    #####:11004:case 80:
        -:11005:{
    #####:11006:			synerr( "bad character inside {}'s" );
call    0 never executed
    #####:11007:			BEGIN(SECT2);
    #####:11008:			return '}';
        -:11009:			}
        -:11010:	YY_BREAK
    #####:11011:case 81:
        -:11012:{
    #####:11013:			synerr( "missing }" );
call    0 never executed
    #####:11014:			BEGIN(SECT2);
    #####:11015:			++linenum;
    #####:11016:			return '}';
        -:11017:			}
        -:11018:	YY_BREAK
    #####:11019:case 82:
    #####:11020:synerr( "bad name in {}'s" ); BEGIN(SECT2);
call    0 never executed
    #####:11021:	YY_BREAK
    #####:11022:case 83:
    #####:11023:synerr( "missing }" ); ++linenum; BEGIN(SECT2);
call    0 never executed
    #####:11024:	YY_BREAK
    #####:11025:case 84:
    #####:11026:ACTION_ECHO; BEGIN(ACTION_COMMENT);
call    0 never executed
    #####:11027:	YY_BREAK
    #####:11028:case 85:
    #####:11029:bracelevel = 0;
    #####:11030:	YY_BREAK
        6:11031:case 86:
        -:11032:{
        6:11033:			ACTION_ECHO;
call    0 returned 6
        6:11034:			CHECK_REJECT(yytext);
call    0 returned 6
branch  1 taken 6 (fallthrough)
branch  2 taken 0
        -:11035:			}
        6:11036:	YY_BREAK
        4:11037:case 87:
        -:11038:{
        4:11039:			ACTION_ECHO;
call    0 returned 4
        4:11040:			CHECK_YYMORE(yytext);
call    0 returned 4
branch  1 taken 4 (fallthrough)
branch  2 taken 0
        -:11041:			}
        4:11042:	YY_BREAK
        9:11043:case 88:
        9:11044:ACTION_ECHO;
call    0 returned 9
        9:11045:	YY_BREAK
        1:11046:case 89:
        -:11047:{
        1:11048:			++linenum;
        1:11049:			ACTION_ECHO;
call    0 returned 1
        1:11050:			if ( bracelevel == 0 ||
branch  0 taken 1 (fallthrough)
branch  1 taken 0
branch  2 taken 1 (fallthrough)
branch  3 taken 0
        1:11051:			     (doing_codeblock && indented_code) )
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -:11052:				{
        1:11053:				if ( ! doing_codeblock )
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:11054:					add_action( "\tYY_BREAK\n" );
call    0 never executed
        -:11055:				
        1:11056:				doing_codeblock = false;
        1:11057:				BEGIN(SECT2);
        -:11058:				}
        -:11059:			}
        1:11060:	YY_BREAK
        -:11061:	/* Reject and YYmore() are checked for above, in PERCENT_BRACE_ACTION */
      362:11062:case 90:
      362:11063:ACTION_ECHO; ++bracelevel;
call    0 returned 362
      362:11064:	YY_BREAK
      362:11065:case 91:
      362:11066:ACTION_ECHO; --bracelevel;
call    0 returned 362
      362:11067:	YY_BREAK
     9372:11068:case 92:
     9372:11069:ACTION_ECHO;
call    0 returned 9372
     9372:11070:	YY_BREAK
     5943:11071:case 93:
     5943:11072:ACTION_ECHO;
call    0 returned 5943
     5943:11073:	YY_BREAK
      230:11074:case 94:
      230:11075:ACTION_ECHO; BEGIN(ACTION_COMMENT);
call    0 returned 230
      230:11076:	YY_BREAK
        6:11077:case 95:
        6:11078:ACTION_ECHO; /* character constant */
call    0 returned 6
        6:11079:	YY_BREAK
     2678:11080:case 96:
     2678:11081:ACTION_ECHO; BEGIN(ACTION_STRING);
call    0 returned 2678
     2678:11082:	YY_BREAK
     3688:11083:case 97:
        -:11084:{
     3688:11085:			++linenum;
     3688:11086:			ACTION_ECHO;
call    0 returned 3688
     3688:11087:			if ( bracelevel == 0 )
branch  0 taken 2947 (fallthrough)
branch  1 taken 741
        -:11088:				{
     2947:11089:				add_action( "\tYY_BREAK\n" );
call    0 returned 2947
     2947:11090:				BEGIN(SECT2);
        -:11091:				}
        -:11092:			}
     3688:11093:	YY_BREAK
    #####:11094:case 98:
    #####:11095:ACTION_ECHO;
call    0 never executed
    #####:11096:	YY_BREAK
      230:11097:case 99:
        -:11098:{
      230:11099:			ACTION_ECHO;
call    0 returned 230
      230:11100:			if ( doing_codeblock )
branch  0 taken 0 (fallthrough)
branch  1 taken 230
    #####:11101:				BEGIN(CODEBLOCK_2);
        -:11102:			else
      230:11103:				BEGIN(ACTION);
        -:11104:			}
      230:11105:	YY_BREAK
    #####:11106:case 100:
    #####:11107:ACTION_ECHO;
call    0 never executed
    #####:11108:	YY_BREAK
      230:11109:case 101:
      230:11110:ACTION_ECHO;
call    0 returned 230
      230:11111:	YY_BREAK
    #####:11112:case 102:
    #####:11113:++linenum; ACTION_ECHO;
call    0 never executed
    #####:11114:	YY_BREAK
     2678:11115:case 103:
     2678:11116:ACTION_ECHO;
call    0 returned 2678
     2678:11117:	YY_BREAK
     2664:11118:case 104:
     2664:11119:ACTION_ECHO;
call    0 returned 2664
     2664:11120:	YY_BREAK
    #####:11121:case 105:
    #####:11122:++linenum; ACTION_ECHO;
call    0 never executed
    #####:11123:	YY_BREAK
     2678:11124:case 106:
     2678:11125:ACTION_ECHO; BEGIN(ACTION);
call    0 returned 2678
     2678:11126:	YY_BREAK
    #####:11127:case 107:
    #####:11128:ACTION_ECHO;
call    0 never executed
    #####:11129:	YY_BREAK
    #####:11130:case YY_STATE_EOF(ACTION):
        -:11131:case YY_STATE_EOF(ACTION_COMMENT):
        -:11132:case YY_STATE_EOF(ACTION_STRING):
        -:11133:{
    #####:11134:			synerr( "EOF encountered inside an action" );
call    0 never executed
    #####:11135:			yyterminate();
        -:11136:			}
        -:11137:	YY_BREAK
      562:11138:case 108:
        -:11139:{
      562:11140:			yylval = myesc( (Char *) yytext );
call    0 returned 562
      562:11141:			return CHAR;
        -:11142:			}
        -:11143:	YY_BREAK
        7:11144:case 109:
        -:11145:{
        7:11146:			yylval = myesc( (Char *) yytext );
call    0 returned 7
        7:11147:			BEGIN(CCL);
        7:11148:			return CHAR;
        -:11149:			}
        -:11150:	YY_BREAK
     1512:11151:case 110:
     1512:11152:ECHO;
call    0 returned 1512
     1512:11153:	YY_BREAK
      111:11154:case YY_STATE_EOF(SECT3):
      111:11155:sectnum = 0; yyterminate();
        -:11156:	YY_BREAK
    #####:11157:case 111:
    #####:11158:format_synerr( "bad character: %s", yytext );
call    0 never executed
    #####:11159:	YY_BREAK
    #####:11160:case 112:
    #####:11161:YY_FATAL_ERROR( "flex scanner jammed" );
call    0 never executed
    #####:11162:	YY_BREAK
      431:11163:case YY_STATE_EOF(INITIAL):
        -:11164:case YY_STATE_EOF(SECT2):
        -:11165:case YY_STATE_EOF(CODEBLOCK):
        -:11166:case YY_STATE_EOF(PICKUPDEF):
        -:11167:case YY_STATE_EOF(SC):
        -:11168:case YY_STATE_EOF(CARETISBOL):
        -:11169:case YY_STATE_EOF(NUM):
        -:11170:case YY_STATE_EOF(QUOTE):
        -:11171:case YY_STATE_EOF(FIRSTCCL):
        -:11172:case YY_STATE_EOF(CCL):
        -:11173:case YY_STATE_EOF(RECOVER):
        -:11174:case YY_STATE_EOF(BRACEERROR):
        -:11175:case YY_STATE_EOF(C_COMMENT):
        -:11176:case YY_STATE_EOF(PERCENT_BRACE_ACTION):
        -:11177:case YY_STATE_EOF(USED_LIST):
        -:11178:case YY_STATE_EOF(CODEBLOCK_2):
      431:11179:	yyterminate();
        -:11180:
     1534:11181:	case YY_END_OF_BUFFER:
        -:11182:		{
        -:11183:		/* Amount of text matched not including the EOB char. */
     1534:11184:		int yy_amount_of_matched_text = yy_cp - yytext_ptr - 1;
        -:11185:
        -:11186:		/* Undo the effects of YY_DO_BEFORE_ACTION. */
     1534:11187:		*yy_cp = yy_hold_char;
        -:11188:
        -:11189:		/* Note that here we test for yy_c_buf_p "<=" to the position
        -:11190:		 * of the first EOB in the buffer, since yy_c_buf_p will
        -:11191:		 * already have been incremented past the NUL character
        -:11192:		 * (since all states make transitions on EOB to the
        -:11193:		 * end-of-buffer state).  Contrast this with the test
        -:11194:		 * in input().
        -:11195:		 */
     1534:11196:		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
branch  0 taken 0 (fallthrough)
branch  1 taken 1534
        -:11197:			{ /* This was really a NUL. */
        -:11198:			yy_state_type yy_next_state;
        -:11199:
    #####:11200:			yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;
        -:11201:
    #####:11202:			yy_current_state = yy_get_previous_state();
call    0 never executed
        -:11203:
        -:11204:			/* Okay, we're now positioned to make the NUL
        -:11205:			 * transition.  We couldn't have
        -:11206:			 * yy_get_previous_state() go ahead and do it
        -:11207:			 * for us because it doesn't know how to deal
        -:11208:			 * with the possibility of jamming (and we don't
        -:11209:			 * want to build jamming into it because then it
        -:11210:			 * will run more slowly).
        -:11211:			 */
        -:11212:
    #####:11213:			yy_next_state = yy_try_NUL_trans( yy_current_state );
call    0 never executed
        -:11214:
    #####:11215:			yy_bp = yytext_ptr + YY_MORE_ADJ;
        -:11216:
    #####:11217:			if ( yy_next_state )
branch  0 never executed
branch  1 never executed
        -:11218:				{
        -:11219:				/* Consume the NUL. */
    #####:11220:				yy_cp = ++yy_c_buf_p;
    #####:11221:				yy_current_state = yy_next_state;
    #####:11222:				goto yy_match;
        -:11223:				}
        -:11224:
        -:11225:			else
        -:11226:				{
    #####:11227:				goto yy_find_action;
        -:11228:				}
        -:11229:			}
        -:11230:
     1534:11231:		else switch ( yy_get_next_buffer() )
call    0 returned 1534
        -:11232:			{
      544:11233:			case EOB_ACT_END_OF_FILE:
        -:11234:				{
      544:11235:				yy_did_buffer_switch_on_eof = 0;
        -:11236:
      544:11237:				if ( yywrap() )
call    0 returned 544
branch  1 taken 543 (fallthrough)
branch  2 taken 1
        -:11238:					{
        -:11239:					/* Note: because we've taken care in
        -:11240:					 * yy_get_next_buffer() to have set up
        -:11241:					 * yytext, we can now set up
        -:11242:					 * yy_c_buf_p so that if some total
        -:11243:					 * hoser (like flex itself) wants to
        -:11244:					 * call the scanner after we return the
        -:11245:					 * YY_NULL, it'll still work - another
        -:11246:					 * YY_NULL will get returned.
        -:11247:					 */
      543:11248:					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;
        -:11249:
      543:11250:					yy_act = YY_STATE_EOF(YY_START);
      543:11251:					goto do_action;
        -:11252:					}
        -:11253:
        -:11254:				else
        -:11255:					{
        1:11256:					if ( ! yy_did_buffer_switch_on_eof )
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:11257:						YY_NEW_FILE;
call    0 returned 1
        -:11258:					}
        1:11259:				break;
        -:11260:				}
        -:11261:
      550:11262:			case EOB_ACT_CONTINUE_SCAN:
      550:11263:				yy_c_buf_p =
      550:11264:					yytext_ptr + yy_amount_of_matched_text;
        -:11265:
      550:11266:				yy_current_state = yy_get_previous_state();
call    0 returned 550
        -:11267:
      550:11268:				yy_cp = yy_c_buf_p;
      550:11269:				yy_bp = yytext_ptr + YY_MORE_ADJ;
      550:11270:				goto yy_match;
        -:11271:
      440:11272:			case EOB_ACT_LAST_MATCH:
      440:11273:				yy_c_buf_p =
      440:11274:				&yy_current_buffer->yy_ch_buf[yy_n_chars];
        -:11275:
      440:11276:				yy_current_state = yy_get_previous_state();
call    0 returned 440
        -:11277:
      440:11278:				yy_cp = yy_c_buf_p;
      440:11279:				yy_bp = yytext_ptr + YY_MORE_ADJ;
      440:11280:				goto yy_find_action;
        -:11281:			}
        1:11282:		break;
        -:11283:		}
        -:11284:
    #####:11285:	default:
        -:11286:#ifdef FLEX_DEBUG
        -:11287:		printf( "action # %d\n", yy_act );
        -:11288:#endif
    #####:11289:		YY_FATAL_ERROR(
call    0 never executed
        -:11290:			"fatal flex scanner internal error--no action found" );
        -:11291:	} /* end of action switch */
        -:11292:		} /* end of scanning one token */
        -:11293:	} /* end of yylex */
        -:11294:
        -:11295:
        -:11296:/* yy_get_next_buffer - try to read in a new buffer
        -:11297: *
        -:11298: * Returns a code representing an action:
        -:11299: *	EOB_ACT_LAST_MATCH -
        -:11300: *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
        -:11301: *	EOB_ACT_END_OF_FILE - end of file
        -:11302: */
        -:11303:
function yy_get_next_buffer called 1534 returned 100% blocks executed 73%
     1534:11304:static int yy_get_next_buffer()
        -:11305:	{
     1534:11306:	register char *dest = yy_current_buffer->yy_ch_buf;
     1534:11307:	register char *source = yytext_ptr - 1; /* copy prev. char, too */
        -:11308:	register int number_to_move, i;
        -:11309:	int ret_val;
        -:11310:
     1534:11311:	if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
branch  0 taken 0 (fallthrough)
branch  1 taken 1534
    #####:11312:		YY_FATAL_ERROR(
call    0 never executed
        -:11313:		"fatal flex scanner internal error--end of buffer missed" );
        -:11314:
        -:11315:	/* Try to read more data. */
        -:11316:
        -:11317:	/* First move last chars to start of buffer. */
     1534:11318:	number_to_move = yy_c_buf_p - yytext_ptr;
        -:11319:
     3508:11320:	for ( i = 0; i < number_to_move; ++i )
branch  0 taken 1974
branch  1 taken 1534 (fallthrough)
     1974:11321:		*(dest++) = *(source++);
        -:11322:
     1534:11323:	if ( yy_current_buffer->yy_eof_status != EOF_NOT_SEEN )
branch  0 taken 440 (fallthrough)
branch  1 taken 1094
        -:11324:		/* don't do the read, it's not guaranteed to return an EOF,
        -:11325:		 * just force an EOF
        -:11326:		 */
      440:11327:		yy_n_chars = 0;
        -:11328:
        -:11329:	else
        -:11330:		{
     1094:11331:		int num_to_read =
     1094:11332:			yy_current_buffer->yy_buf_size - number_to_move - 1;
        -:11333:
     1094:11334:		while ( num_to_read <= 0 )
branch  0 taken 0
branch  1 taken 1094 (fallthrough)
        -:11335:			{ /* Not enough room in the buffer - grow it. */
        -:11336:#ifdef YY_USES_REJECT
        -:11337:			YY_FATAL_ERROR(
        -:11338:"input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
        -:11339:#else
        -:11340:
        -:11341:			/* just a shorter name for the current buffer */
    #####:11342:			YY_BUFFER_STATE b = yy_current_buffer;
        -:11343:
    #####:11344:			int yy_c_buf_p_offset = yy_c_buf_p - b->yy_ch_buf;
        -:11345:
    #####:11346:			b->yy_buf_size *= 2;
    #####:11347:			b->yy_ch_buf = (char *)
    #####:11348:				yy_flex_realloc( (void *) b->yy_ch_buf,
call    0 never executed
        -:11349:						 b->yy_buf_size );
        -:11350:
    #####:11351:			if ( ! b->yy_ch_buf )
branch  0 never executed
branch  1 never executed
    #####:11352:				YY_FATAL_ERROR(
call    0 never executed
        -:11353:				"fatal error - scanner input buffer overflow" );
        -:11354:
    #####:11355:			yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];
        -:11356:
    #####:11357:			num_to_read = yy_current_buffer->yy_buf_size -
        -:11358:						number_to_move - 1;
        -:11359:#endif
        -:11360:			}
        -:11361:
     1094:11362:		if ( num_to_read > YY_READ_BUF_SIZE )
branch  0 taken 1094 (fallthrough)
branch  1 taken 0
     1094:11363:			num_to_read = YY_READ_BUF_SIZE;
        -:11364:
        -:11365:		/* Read in more data. */
    1094*:11366:		YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
branch  0 taken 0 (fallthrough)
branch  1 taken 1094
call    2 never executed
call    3 returned 1094
branch  4 taken 544 (fallthrough)
branch  5 taken 550
call    6 returned 544
branch  7 taken 0 (fallthrough)
branch  8 taken 544
call    9 never executed
        -:11367:			yy_n_chars, num_to_read );
        -:11368:		}
        -:11369:
     1534:11370:	if ( yy_n_chars == 0 )
branch  0 taken 984 (fallthrough)
branch  1 taken 550
        -:11371:		{
      984:11372:		if ( number_to_move - YY_MORE_ADJ == 1 )
branch  0 taken 544 (fallthrough)
branch  1 taken 440
        -:11373:			{
      544:11374:			ret_val = EOB_ACT_END_OF_FILE;
      544:11375:			yyrestart( yyin );
call    0 returned 544
        -:11376:			}
        -:11377:
        -:11378:		else
        -:11379:			{
      440:11380:			ret_val = EOB_ACT_LAST_MATCH;
      440:11381:			yy_current_buffer->yy_eof_status = EOF_PENDING;
        -:11382:			}
        -:11383:		}
        -:11384:
        -:11385:	else
      550:11386:		ret_val = EOB_ACT_CONTINUE_SCAN;
        -:11387:
     1534:11388:	yy_n_chars += number_to_move;
     1534:11389:	yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
     1534:11390:	yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
        -:11391:
        -:11392:	/* yytext begins at the second character in yy_ch_buf; the first
        -:11393:	 * character is the one which preceded it before reading in the latest
        -:11394:	 * buffer; it needs to be kept around in case it's a newline, so
        -:11395:	 * yy_get_previous_state() will have with '^' rules active.
        -:11396:	 */
        -:11397:
     1534:11398:	yytext_ptr = &yy_current_buffer->yy_ch_buf[1];
        -:11399:
     1534:11400:	return ret_val;
        -:11401:	}
        -:11402:
        -:11403:
        -:11404:/* yy_get_previous_state - get the state just before the EOB char was reached */
        -:11405:
function yy_get_previous_state called 990 returned 100% blocks executed 88%
      990:11406:static yy_state_type yy_get_previous_state()
        -:11407:	{
        -:11408:	register yy_state_type yy_current_state;
        -:11409:	register char *yy_cp;
        -:11410:
      990:11411:	register char *yy_bp = yytext_ptr;
        -:11412:
      990:11413:	yy_current_state = yy_start;
      990:11414:	if ( yy_bp[-1] == '\n' )
branch  0 taken 563 (fallthrough)
branch  1 taken 427
      563:11415:		++yy_current_state;
        -:11416:
     1430:11417:	for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
branch  0 taken 440
branch  1 taken 990 (fallthrough)
        -:11418:		{
     440*:11419:		register YY_CHAR yy_c = (*yy_cp ? yy_ec[(unsigned int) *yy_cp] : 1);
branch  0 taken 440 (fallthrough)
branch  1 taken 0
      440:11420:		if ( yy_accept[yy_current_state] )
branch  0 taken 1 (fallthrough)
branch  1 taken 439
        -:11421:			{
        1:11422:			yy_last_accepting_state = yy_current_state;
        1:11423:			yy_last_accepting_cpos = yy_cp;
        -:11424:			}
      449:11425:		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
branch  0 taken 9
branch  1 taken 440 (fallthrough)
        -:11426:			{
        9:11427:			yy_current_state = (int) yy_def[yy_current_state];
        9:11428:			if ( yy_current_state >= 408 )
branch  0 taken 0 (fallthrough)
branch  1 taken 9
    #####:11429:				yy_c = yy_meta[(unsigned int) yy_c];
        -:11430:			}
      440:11431:		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
        -:11432:		}
        -:11433:
      990:11434:	return yy_current_state;
        -:11435:	}
        -:11436:
        -:11437:
        -:11438:/* yy_try_NUL_trans - try to make a transition on the NUL character
        -:11439: *
        -:11440: * synopsis
        -:11441: *	next_state = yy_try_NUL_trans( current_state );
        -:11442: */
        -:11443:
        -:11444:#ifdef YY_USE_PROTOS
function yy_try_NUL_trans called 0 returned 0% blocks executed 0%
    #####:11445:static yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )
        -:11446:#else
        -:11447:static yy_state_type yy_try_NUL_trans( yy_current_state )
        -:11448:yy_state_type yy_current_state;
        -:11449:#endif
        -:11450:	{
        -:11451:	register int yy_is_jam;
    #####:11452:	register char *yy_cp = yy_c_buf_p;
        -:11453:
    #####:11454:	register YY_CHAR yy_c = 1;
    #####:11455:	if ( yy_accept[yy_current_state] )
branch  0 never executed
branch  1 never executed
        -:11456:		{
    #####:11457:		yy_last_accepting_state = yy_current_state;
    #####:11458:		yy_last_accepting_cpos = yy_cp;
        -:11459:		}
    #####:11460:	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
branch  0 never executed
branch  1 never executed
        -:11461:		{
    #####:11462:		yy_current_state = (int) yy_def[yy_current_state];
    #####:11463:		if ( yy_current_state >= 408 )
branch  0 never executed
branch  1 never executed
    #####:11464:			yy_c = yy_meta[(unsigned int) yy_c];
        -:11465:		}
    #####:11466:	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
    #####:11467:	yy_is_jam = (yy_current_state == 407);
        -:11468:
    #####:11469:	return yy_is_jam ? 0 : yy_current_state;
branch  0 never executed
branch  1 never executed
        -:11470:	}
        -:11471:
        -:11472:
        -:11473:#ifdef YY_USE_PROTOS
function yyunput called 3887 returned 100% blocks executed 50%
     3887:11474:static void yyunput( int c, register char *yy_bp )
        -:11475:#else
        -:11476:static void yyunput( c, yy_bp )
        -:11477:int c;
        -:11478:register char *yy_bp;
        -:11479:#endif
        -:11480:	{
     3887:11481:	register char *yy_cp = yy_c_buf_p;
        -:11482:
        -:11483:	/* undo effects of setting up yytext */
     3887:11484:	*yy_cp = yy_hold_char;
        -:11485:
     3887:11486:	if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
branch  0 taken 0 (fallthrough)
branch  1 taken 3887
        -:11487:		{ /* need to shift things up to make room */
        -:11488:		/* +2 for EOB chars. */
    #####:11489:		register int number_to_move = yy_n_chars + 2;
    #####:11490:		register char *dest = &yy_current_buffer->yy_ch_buf[
    #####:11491:					yy_current_buffer->yy_buf_size + 2];
    #####:11492:		register char *source =
    #####:11493:				&yy_current_buffer->yy_ch_buf[number_to_move];
        -:11494:
    #####:11495:		while ( source > yy_current_buffer->yy_ch_buf )
branch  0 never executed
branch  1 never executed
    #####:11496:			*--dest = *--source;
        -:11497:
    #####:11498:		yy_cp += dest - source;
    #####:11499:		yy_bp += dest - source;
    #####:11500:		yy_n_chars = yy_current_buffer->yy_buf_size;
        -:11501:
    #####:11502:		if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
branch  0 never executed
branch  1 never executed
    #####:11503:			YY_FATAL_ERROR( "flex scanner push-back overflow" );
call    0 never executed
        -:11504:		}
        -:11505:
     3887:11506:	if ( yy_cp > yy_bp && yy_cp[-1] == '\n' )
branch  0 taken 2589 (fallthrough)
branch  1 taken 1298
branch  2 taken 9 (fallthrough)
branch  3 taken 2580
        9:11507:		yy_cp[-2] = '\n';
        -:11508:
     3887:11509:	*--yy_cp = (char) c;
        -:11510:
        -:11511:
        -:11512:	/* Note: the formal parameter *must* be called "yy_bp" for this
        -:11513:	 * macro to now work correctly.
        -:11514:	 */
     3887:11515:	YY_DO_BEFORE_ACTION; /* set up yytext again */
     3887:11516:	}
        -:11517:
        -:11518:
        -:11519:#ifdef __cplusplus
        -:11520:static int yyinput()
        -:11521:#else
function input called 222 returned 100% blocks executed 20%
      222:11522:static int input()
        -:11523:#endif
        -:11524:	{
        -:11525:	int c;
        -:11526:
      222:11527:	*yy_c_buf_p = yy_hold_char;
        -:11528:
      222:11529:	if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
branch  0 taken 0 (fallthrough)
branch  1 taken 222
        -:11530:		{
        -:11531:		/* yy_c_buf_p now points to the character we want to return.
        -:11532:		 * If this occurs *before* the EOB characters, then it's a
        -:11533:		 * valid NUL; if not, then we've hit the end of the buffer.
        -:11534:		 */
    #####:11535:		if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
branch  0 never executed
branch  1 never executed
        -:11536:			/* This was really a NUL. */
    #####:11537:			*yy_c_buf_p = '\0';
        -:11538:
        -:11539:		else
        -:11540:			{ /* need more input */
    #####:11541:			yytext_ptr = yy_c_buf_p;
    #####:11542:			++yy_c_buf_p;
        -:11543:
    #####:11544:			switch ( yy_get_next_buffer() )
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -:11545:				{
    #####:11546:				case EOB_ACT_END_OF_FILE:
        -:11547:					{
    #####:11548:					if ( yywrap() )
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:11549:						{
    #####:11550:						yy_c_buf_p =
        -:11551:						yytext_ptr + YY_MORE_ADJ;
    #####:11552:						return EOF;
        -:11553:						}
        -:11554:
    #####:11555:					YY_NEW_FILE;
call    0 never executed
        -:11556:#ifdef __cplusplus
        -:11557:					return yyinput();
        -:11558:#else
    #####:11559:					return input();
call    0 never executed
        -:11560:#endif
        -:11561:					}
        -:11562:
    #####:11563:				case EOB_ACT_CONTINUE_SCAN:
    #####:11564:					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;
    #####:11565:					break;
        -:11566:
    #####:11567:				case EOB_ACT_LAST_MATCH:
        -:11568:#ifdef __cplusplus
        -:11569:					YY_FATAL_ERROR(
        -:11570:					"unexpected last match in yyinput()" );
        -:11571:#else
    #####:11572:					YY_FATAL_ERROR(
call    0 never executed
        -:11573:					"unexpected last match in input()" );
        -:11574:#endif
        -:11575:				}
        -:11576:			}
        -:11577:		}
        -:11578:
      222:11579:	c = *yy_c_buf_p;
      222:11580:	*yy_c_buf_p = '\0';	/* preserve yytext */
      222:11581:	yy_hold_char = *++yy_c_buf_p;
        -:11582:
      222:11583:	return c;
        -:11584:	}
        -:11585:
        -:11586:
        -:11587:#ifdef YY_USE_PROTOS
function yyrestart called 545 returned 100% blocks executed 67%
      545:11588:void yyrestart( FILE *input_file )
        -:11589:#else
        -:11590:void yyrestart( input_file )
        -:11591:FILE *input_file;
        -:11592:#endif
        -:11593:	{
      545:11594:	if ( ! yy_current_buffer )
branch  0 taken 0 (fallthrough)
branch  1 taken 545
    #####:11595:		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );
call    0 never executed
        -:11596:
      545:11597:	yy_init_buffer( yy_current_buffer, input_file );
call    0 returned 545
      545:11598:	yy_load_buffer_state();
call    0 returned 545
      545:11599:	}
        -:11600:
        -:11601:
        -:11602:#ifdef YY_USE_PROTOS
function yy_switch_to_buffer called 0 returned 0% blocks executed 0%
    #####:11603:void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
        -:11604:#else
        -:11605:void yy_switch_to_buffer( new_buffer )
        -:11606:YY_BUFFER_STATE new_buffer;
        -:11607:#endif
        -:11608:	{
    #####:11609:	if ( yy_current_buffer == new_buffer )
branch  0 never executed
branch  1 never executed
    #####:11610:		return;
        -:11611:
    #####:11612:	if ( yy_current_buffer )
branch  0 never executed
branch  1 never executed
        -:11613:		{
        -:11614:		/* Flush out information for old buffer. */
    #####:11615:		*yy_c_buf_p = yy_hold_char;
    #####:11616:		yy_current_buffer->yy_buf_pos = yy_c_buf_p;
    #####:11617:		yy_current_buffer->yy_n_chars = yy_n_chars;
        -:11618:		}
        -:11619:
    #####:11620:	yy_current_buffer = new_buffer;
    #####:11621:	yy_load_buffer_state();
call    0 never executed
        -:11622:
        -:11623:	/* We don't actually know whether we did this switch during
        -:11624:	 * EOF (yywrap()) processing, but the only time this flag
        -:11625:	 * is looked at is after yywrap() is called, so it's safe
        -:11626:	 * to go ahead and always set it.
        -:11627:	 */
    #####:11628:	yy_did_buffer_switch_on_eof = 1;
        -:11629:	}
        -:11630:
        -:11631:
        -:11632:#ifdef YY_USE_PROTOS
function yy_load_buffer_state called 1094 returned 100% blocks executed 100%
     1094:11633:void yy_load_buffer_state( void )
        -:11634:#else
        -:11635:void yy_load_buffer_state()
        -:11636:#endif
        -:11637:	{
     1094:11638:	yy_n_chars = yy_current_buffer->yy_n_chars;
     1094:11639:	yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
     1094:11640:	yyin = yy_current_buffer->yy_input_file;
     1094:11641:	yy_hold_char = *yy_c_buf_p;
     1094:11642:	}
        -:11643:
        -:11644:
        -:11645:#ifdef YY_USE_PROTOS
function yy_create_buffer called 549 returned 100% blocks executed 78%
      549:11646:YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )
        -:11647:#else
        -:11648:YY_BUFFER_STATE yy_create_buffer( file, size )
        -:11649:FILE *file;
        -:11650:int size;
        -:11651:#endif
        -:11652:	{
        -:11653:	YY_BUFFER_STATE b;
        -:11654:
      549:11655:	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
call    0 returned 549
        -:11656:
      549:11657:	if ( ! b )
branch  0 taken 0 (fallthrough)
branch  1 taken 549
    #####:11658:		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
call    0 never executed
        -:11659:
      549:11660:	b->yy_buf_size = size;
        -:11661:
        -:11662:	/* yy_ch_buf has to be 2 characters longer than the size given because
        -:11663:	 * we need to put in 2 end-of-buffer characters.
        -:11664:	 */
      549:11665:	b->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );
call    0 returned 549
        -:11666:
      549:11667:	if ( ! b->yy_ch_buf )
branch  0 taken 0 (fallthrough)
branch  1 taken 549
    #####:11668:		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
call    0 never executed
        -:11669:
      549:11670:	yy_init_buffer( b, file );
call    0 returned 549
        -:11671:
      549:11672:	return b;
        -:11673:	}
        -:11674:
        -:11675:
        -:11676:#ifdef YY_USE_PROTOS
function yy_delete_buffer called 0 returned 0% blocks executed 0%
    #####:11677:void yy_delete_buffer( YY_BUFFER_STATE b )
        -:11678:#else
        -:11679:void yy_delete_buffer( b )
        -:11680:YY_BUFFER_STATE b;
        -:11681:#endif
        -:11682:	{
    #####:11683:	if ( b == yy_current_buffer )
branch  0 never executed
branch  1 never executed
    #####:11684:		yy_current_buffer = (YY_BUFFER_STATE) 0;
        -:11685:
    #####:11686:	yy_flex_free( (void *) b->yy_ch_buf );
call    0 never executed
    #####:11687:	yy_flex_free( (void *) b );
call    0 never executed
    #####:11688:	}
        -:11689:
        -:11690:
        -:11691:#ifdef YY_USE_PROTOS
function yy_init_buffer called 1094 returned 100% blocks executed 80%
     1094:11692:void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )
        -:11693:#else
        -:11694:void yy_init_buffer( b, file )
        -:11695:YY_BUFFER_STATE b;
        -:11696:FILE *file;
        -:11697:#endif
        -:11698:	{
     1094:11699:	b->yy_input_file = file;
        -:11700:
        -:11701:	/* We put in the '\n' and start reading from [1] so that an
        -:11702:	 * initial match-at-newline will be true.
        -:11703:	 */
        -:11704:
     1094:11705:	b->yy_ch_buf[0] = '\n';
     1094:11706:	b->yy_n_chars = 1;
        -:11707:
        -:11708:	/* We always need two end-of-buffer characters.  The first causes
        -:11709:	 * a transition to the end-of-buffer state.  The second causes
        -:11710:	 * a jam in that state.
        -:11711:	 */
     1094:11712:	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
     1094:11713:	b->yy_ch_buf[2] = YY_END_OF_BUFFER_CHAR;
        -:11714:
     1094:11715:	b->yy_buf_pos = &b->yy_ch_buf[1];
        -:11716:
    1094*:11717:	b->is_interactive = file ? isatty( fileno(file) ) : 0;
branch  0 taken 1094 (fallthrough)
branch  1 taken 0
call    2 returned 1094
call    3 returned 1094
        -:11718:
     1094:11719:	b->yy_eof_status = EOF_NOT_SEEN;
     1094:11720:	}
        -:11721:
        -:11722:
        -:11723:#ifdef YY_USE_PROTOS
function yy_fatal_error called 0 returned 0% blocks executed 0%
    #####:11724:static void yy_fatal_error( const char msg[] )
        -:11725:#else
        -:11726:static void yy_fatal_error( msg )
        -:11727:char msg[];
        -:11728:#endif
        -:11729:	{
    #####:11730:	(void) fprintf( err, "%s\n", msg );
call    0 never executed
    #####:11731:	exit( 1 );
        -:11732:	}
        -:11733:
        -:11734:
        -:11735:/* Redefine yyless() so it works in section 3 code. */
        -:11736:
        -:11737:#undef yyless
        -:11738:#define yyless(n) \
        -:11739:	do \
        -:11740:		{ \
        -:11741:		/* Undo effects of setting up yytext. */ \
        -:11742:		yytext[yyleng] = yy_hold_char; \
        -:11743:		yy_c_buf_p = yytext + n - YY_MORE_ADJ; \
        -:11744:		yy_hold_char = *yy_c_buf_p; \
        -:11745:		*yy_c_buf_p = '\0'; \
        -:11746:		yyleng = n; \
        -:11747:		} \
        -:11748:	while ( 0 )
        -:11749:
        -:11750:
        -:11751:
function yywrap called 544 returned 100% blocks executed 100%
      544:11752:int yywrap()
        -:11753:	{
      544:11754:	if ( --num_input_files > 0 )
branch  0 taken 1 (fallthrough)
branch  1 taken 543
        -:11755:		{
        1:11756:		set_input_file( *++input_files );
call    0 returned 1
        1:11757:		return 0;
        -:11758:		}
        -:11759:
        -:11760:	else
      543:11761:		return 1;
        -:11762:	}
        -:11763:
        -:11764:
        -:11765:/* set_input_file - open the given file (if NULL, stdin) for scanning */
        -:11766:
function set_input_file called 552 returned 100% blocks executed 83%
      552:11767:void set_input_file( file )
        -:11768:char *file;
        -:11769:	{
      552:11770:	if ( file )
branch  0 taken 552 (fallthrough)
branch  1 taken 0
        -:11771:		{
      552:11772:		infilename = file;
      552:11773:		yyin = fopen( infilename, "r" );
call    0 returned 552
        -:11774:
      552:11775:		if ( yyin == NULL )
branch  0 taken 1 (fallthrough)
branch  1 taken 551
        1:11776:			lerrsf( "can't open %s", file );
call    0 returned 0
        -:11777:		}
        -:11778:
        -:11779:	else
        -:11780:		{
    #####:11781:		yyin = stdin;
    #####:11782:		infilename = "<stdin>";
        -:11783:		}
      551:11784:	}
