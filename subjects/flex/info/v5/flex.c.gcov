        -:    0:Source:flex.c
        -:    0:Graph:flex.gcno
        -:    0:Data:flex.gcda
        -:    0:Runs:567
        -:    1:/* flex - tool to generate fast lexical analyzers */
        -:    2:
        -:    3:/*-
        -:    4: * Copyright (c) 1990 The Regents of the University of California.
        -:    5: * All rights reserved.
        -:    6: *
        -:    7: * This code is derived from software contributed to Berkeley by
        -:    8: * Vern Paxson.
        -:    9: *
        -:   10: * The United States Government has rights in this work pursuant
        -:   11: * to contract no. DE-AC03-76SF00098 between the United States
        -:   12: * Department of Energy and the University of California.
        -:   13: *
        -:   14: * Redistribution and use in source and binary forms with or without
        -:   15: * modification are permitted provided that: (1) source distributions retain
        -:   16: * this entire copyright notice and comment, and (2) distributions including
        -:   17: * binaries display the following acknowledgement:  ``This product includes
        -:   18: * software developed by the University of California, Berkeley and its
        -:   19: * contributors'' in the documentation or other materials provided with the
        -:   20: * distribution and in all advertising materials mentioning features or use
        -:   21: * of this software.  Neither the name of the University nor the names of
        -:   22: * its contributors may be used to endorse or promote products derived from
        -:   23: * this software without specific prior written permission.
        -:   24: * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
        -:   25: * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
        -:   26: * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
        -:   27: */
        -:   28:
        -:   29:#ifndef lint
        -:   30:char copyright[] =
        -:   31:"@(#) Copyright (c) 1990 The Regents of the University of California.\n\
        -:   32: All rights reserved.\n";
        -:   33:#endif /* not lint */
        -:   34:
        -:   35:/* $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.seeded/v5/flex.c,v 1.1.1.2 2003/09/02 20:22:00 expsir Exp $ */
        -:   36:
        -:   37:
        -:   38:#include "flexdef.h"
        -:   39:#include "version.h"
        -:   40:#include <ctype.h> 
        -:   41:#include "parse.h"
        -:   42:#include "FaultSeeds.h"
        -:   43:
        -:   44:static char flex_version[] = FLEX_VERSION;
        -:   45:
        -:   46:
        -:   47:/* declare functions that have forward references */
        -:   48:
        -:   49:void flexinit PROTO((int, char**));
        -:   50:void readin PROTO((void));
        -:   51:void set_up_initial_allocations PROTO((void));
        -:   52:
        -:   53:#ifdef NEED_ARGV_FIXUP
        -:   54:extern void argv_fixup PROTO((int *, char ***));
        -:   55:#endif
        -:   56:
        -:   57:
        -:   58:/* these globals are all defined and commented in flexdef.h */
        -:   59:int printstats, syntaxerror, eofseen, ddebug, trace, nowarn, spprdflt;
        -:   60:int interactive, caseins, lex_compat, do_yylineno, useecs, fulltbl, usemecs;
        -:   61:int fullspd, gen_line_dirs, performance_report, backing_up_report;
        -:   62:int C_plus_plus, long_align, use_read, yytext_is_array, do_yywrap, csize;
        -:   63:int yymore_used, reject, real_reject, continued_action, in_rule;
        -:   64:int yymore_really_used, reject_really_used;
        -:   65:int datapos, dataline, linenum, out_linenum;
        -:   66:FILE *skelfile = NULL;
        -:   67:
        -:   68:/* ### add for testing ### */
        -:   69:FILE *err = NULL;
        -:   70:/* ####################### */
        -:   71:
        -:   72:int skel_ind = 0;
        -:   73:char *action_array;
        -:   74:int action_size, defs1_offset, prolog_offset, action_offset, action_index;
        -:   75:char *infilename = NULL, *outfilename = NULL;
        -:   76:int did_outfilename;
        -:   77:char *prefix, *yyclass;
        -:   78:int do_stdinit, use_stdout;
        -:   79:int onestate[ONE_STACK_SIZE], onesym[ONE_STACK_SIZE];
        -:   80:int onenext[ONE_STACK_SIZE], onedef[ONE_STACK_SIZE], onesp;
        -:   81:int current_mns, current_max_rules;
        -:   82:int num_rules, num_eof_rules, default_rule, lastnfa;
        -:   83:int *firstst, *lastst, *finalst, *transchar, *trans1, *trans2;
        -:   84:int *accptnum, *assoc_rule, *state_type;
        -:   85:int *rule_type, *rule_linenum, *rule_useful;
        -:   86:int current_state_type;
        -:   87:int variable_trailing_context_rules;
        -:   88:int numtemps, numprots, protprev[MSP], protnext[MSP], prottbl[MSP];
        -:   89:int protcomst[MSP], firstprot, lastprot, protsave[PROT_SAVE_SIZE];
        -:   90:int numecs, nextecm[CSIZE + 1], ecgroup[CSIZE + 1], nummecs, tecfwd[CSIZE + 1];
        -:   91:int tecbck[CSIZE + 1];
        -:   92:int lastsc, *scset, *scbol, *scxclu, *sceof;
        -:   93:int current_max_scs;
        -:   94:char **scname;
        -:   95:int current_max_dfa_size, current_max_xpairs;
        -:   96:int current_max_template_xpairs, current_max_dfas;
        -:   97:int lastdfa, *nxt, *chk, *tnxt;
        -:   98:int *base, *def, *nultrans, NUL_ec, tblend, firstfree, **dss, *dfasiz;
        -:   99:union dfaacc_union *dfaacc;
        -:  100:int *accsiz, *dhash, numas;
        -:  101:int numsnpairs, jambase, jamstate;
        -:  102:int lastccl, *cclmap, *ccllen, *cclng, cclreuse;
        -:  103:int current_maxccls, current_max_ccl_tbl_size;
        -:  104:Char *ccltbl;
        -:  105:char nmstr[MAXLINE];
        -:  106:int sectnum, nummt, hshcol, dfaeql, numeps, eps2, num_reallocs;
        -:  107:int tmpuses, totnst, peakpairs, numuniq, numdup, hshsave;
        -:  108:int num_backing_up, bol_needed;
        -:  109:FILE *backing_up_file;
        -:  110:int end_of_buffer_state;
        -:  111:char **input_files;
        -:  112:int num_input_files;
        -:  113:
        -:  114:/* Make sure program_name is initialized so we don't crash if writing
        -:  115: * out an error message before getting the program name from argv[0].
        -:  116: */
        -:  117:char *program_name = "flex";
        -:  118:
        -:  119:#ifndef SHORT_FILE_NAMES
        -:  120:static char *outfile_template = "lex.%s.%s";
        -:  121:static char *backing_name = "lex.backup";
        -:  122:#else
        -:  123:static char *outfile_template = "lex%s.%s";
        -:  124:static char *backing_name = "lex.bck";
        -:  125:#endif
        -:  126:
        -:  127:#ifdef THINK_C
        -:  128:#include <console.h>
        -:  129:#endif
        -:  130:
        -:  131:#ifdef MS_DOS
        -:  132:extern unsigned _stklen = 16384;
        -:  133:#endif
        -:  134:
        -:  135:static char outfile_path[MAXLINE];
        -:  136:static int outfile_created = 0;
        -:  137:static char *skelname = NULL;
        -:  138:
        -:  139:
function main called 567 returned 0% blocks executed 95%
      567:  140:int main( argc, argv )
        -:  141:int argc;
        -:  142:char **argv;
        -:  143:	{
        -:  144:	int i;
        -:  145:
        -:  146:#ifdef THINK_C
        -:  147:	argc = ccommand( &argv );
        -:  148:#endif
        -:  149:#ifdef NEED_ARGV_FIXUP
        -:  150:	argv_fixup( &argc, &argv );
        -:  151:#endif
        -:  152:
        -:  153:/* ### add for testing ### */
      567:  154:        if(--argc >0){
branch  0 taken 567 (fallthrough)
branch  1 taken 0
      567:  155:                err = fopen( *++argv, "w" );
call    0 returned 567
      567:  156:                --argv; ++argc;
        -:  157:        }
        -:  158:/* ####################### */
        -:  159:
      567:  160:	flexinit( argc, argv );
call    0 returned 560
        -:  161:
      560:  162:	readin();
call    0 returned 543
        -:  163:
      543:  164:	ntod();
call    0 returned 543
        -:  165:
     4360:  166:	for ( i = 1; i <= num_rules; ++i )
branch  0 taken 3817
branch  1 taken 543 (fallthrough)
     3817:  167:		if ( ! rule_useful[i] && i != default_rule )
branch  0 taken 86 (fallthrough)
branch  1 taken 3731
branch  2 taken 12 (fallthrough)
branch  3 taken 74
       12:  168:			line_warning( _( "rule cannot be matched" ),
       12:  169:					rule_linenum[i] );
call    0 returned 12
        -:  170:
      543:  171:	if ( spprdflt && ! reject && rule_useful[default_rule] )
branch  0 taken 3 (fallthrough)
branch  1 taken 540
branch  2 taken 1 (fallthrough)
branch  3 taken 2
branch  4 taken 1 (fallthrough)
branch  5 taken 0
        1:  172:		line_warning(
        -:  173:			_( "-s option given but default rule can be matched" ),
        1:  174:			rule_linenum[default_rule] );
call    0 returned 1
        -:  175:
        -:  176:	/* Generate the C state transition tables from the DFA. */
      543:  177:	make_tables();
call    0 returned 543
        -:  178:
        -:  179:	/* Note, flexend does not return.  It exits with its argument
        -:  180:	 * as status.
        -:  181:	 */
      543:  182:	flexend( 0 );
call    0 returned 0
        -:  183:
    #####:  184:	return 0;	/* keep compilers/lint happy */
        -:  185:	}
        -:  186:
        -:  187:
        -:  188:/* check_options - check user-specified options */
        -:  189:
function check_options called 560 returned 99% blocks executed 87%
      560:  190:void check_options()
        -:  191:	{
        -:  192:	int i;
        -:  193:
      560:  194:	if ( lex_compat )
branch  0 taken 163 (fallthrough)
branch  1 taken 397
        -:  195:		{
      163:  196:		if ( C_plus_plus )
branch  0 taken 0 (fallthrough)
branch  1 taken 163
    #####:  197:			flexerror( _( "Can't use -+ with -l option" ) );
call    0 never executed
        -:  198:
      163:  199:		if ( fulltbl || fullspd )
branch  0 taken 162 (fallthrough)
branch  1 taken 1
branch  2 taken 0 (fallthrough)
branch  3 taken 162
        1:  200:			flexerror( _( "Can't use -f or -F with -l option" ) );
call    0 returned 0
        -:  201:
        -:  202:		/* Don't rely on detecting use of yymore() and REJECT,
        -:  203:		 * just assume they'll be used.
        -:  204:		 */
      162:  205:		yymore_really_used = reject_really_used = true;
        -:  206:
      162:  207:		yytext_is_array = true;
      162:  208:		do_yylineno = true;
      162:  209:		use_read = false;
        -:  210:		}
        -:  211:
      559:  212:	if ( do_yylineno )
branch  0 taken 162 (fallthrough)
branch  1 taken 397
        -:  213:		/* This should really be "maintain_backup_tables = true" */
      162:  214:		reject_really_used = true;
        -:  215:
      559:  216:	if ( csize == unspecified )
branch  0 taken 554 (fallthrough)
branch  1 taken 5
        -:  217:		{
      554:  218:		if ( (fulltbl || fullspd) && ! useecs )
branch  0 taken 526 (fallthrough)
branch  1 taken 28
branch  2 taken 94 (fallthrough)
branch  3 taken 432
branch  4 taken 79 (fallthrough)
branch  5 taken 43
       79:  219:			csize = DEFAULT_CSIZE;
        -:  220:		else
      475:  221:			csize = CSIZE;
        -:  222:		}
        -:  223:
      559:  224:	if ( interactive == unspecified )
branch  0 taken 554 (fallthrough)
branch  1 taken 5
        -:  225:		{
      554:  226:		if ( fulltbl || fullspd )
branch  0 taken 527 (fallthrough)
branch  1 taken 27
branch  2 taken 94 (fallthrough)
branch  3 taken 433
      121:  227:			interactive = false;
        -:  228:		else
      433:  229:			interactive = true;
        -:  230:		}
        -:  231:
      559:  232:	if ( fulltbl || fullspd )
branch  0 taken 531 (fallthrough)
branch  1 taken 28
branch  2 taken 94 (fallthrough)
branch  3 taken 437
        -:  233:		{
      122:  234:		if ( usemecs )
branch  0 taken 3 (fallthrough)
branch  1 taken 119
        3:  235:			flexerror(
call    0 returned 0
        -:  236:			_( "-Cf/-CF and -Cm don't make sense together" ) );
        -:  237:
      119:  238:		if ( interactive )
branch  0 taken 1 (fallthrough)
branch  1 taken 118
        1:  239:			flexerror( _( "-Cf/-CF and -I are incompatible" ) );
call    0 returned 0
        -:  240:
      118:  241:		if ( lex_compat )
branch  0 taken 0 (fallthrough)
branch  1 taken 118
    #####:  242:			flexerror(
call    0 never executed
        -:  243:		_( "-Cf/-CF are incompatible with lex-compatibility mode" ) );
        -:  244:
      118:  245:		if ( do_yylineno )
branch  0 taken 0 (fallthrough)
branch  1 taken 118
    #####:  246:			flexerror(
call    0 never executed
        -:  247:			_( "-Cf/-CF and %option yylineno are incompatible" ) );
        -:  248:
      118:  249:		if ( fulltbl && fullspd )
branch  0 taken 25 (fallthrough)
branch  1 taken 93
branch  2 taken 1 (fallthrough)
branch  3 taken 24
        1:  250:			flexerror( _( "-Cf and -CF are mutually exclusive" ) );
call    0 returned 0
        -:  251:		}
        -:  252:
     554*:  253:	if ( C_plus_plus && fullspd )
branch  0 taken 0 (fallthrough)
branch  1 taken 554
branch  2 never executed
branch  3 never executed
    #####:  254:		flexerror( _( "Can't use -+ with -CF option" ) );
call    0 never executed
        -:  255:
     554*:  256:	if ( C_plus_plus && yytext_is_array )
branch  0 taken 0 (fallthrough)
branch  1 taken 554
branch  2 never executed
branch  3 never executed
        -:  257:		{
    #####:  258:		warn( _( "%array incompatible with -+ option" ) );
call    0 never executed
    #####:  259:		yytext_is_array = false;
        -:  260:		}
        -:  261:
      554:  262:	if ( useecs )
branch  0 taken 305 (fallthrough)
branch  1 taken 249
        -:  263:		{ /* Set up doubly-linked equivalence classes. */
        -:  264:
        -:  265:		/* We loop all the way up to csize, since ecgroup[csize] is
        -:  266:		 * the position used for NUL characters.
        -:  267:		 */
      305:  268:		ecgroup[1] = NIL;
        -:  269:
    77696:  270:		for ( i = 2; i <= csize; ++i )
branch  0 taken 77391
branch  1 taken 305 (fallthrough)
        -:  271:			{
    77391:  272:			ecgroup[i] = i - 1;
    77391:  273:			nextecm[i - 1] = i;
        -:  274:			}
        -:  275:
      305:  276:		nextecm[csize] = NIL;
        -:  277:		}
        -:  278:
        -:  279:	else
        -:  280:		{
        -:  281:		/* Put everything in its own equivalence class. */
    54265:  282:		for ( i = 1; i <= csize; ++i )
branch  0 taken 54016
branch  1 taken 249 (fallthrough)
        -:  283:			{
    54016:  284:			ecgroup[i] = i;
    54016:  285:			nextecm[i] = BAD_SUBSCRIPT;	/* to catch errors */
        -:  286:			}
        -:  287:		}
        -:  288:
      554:  289:	if ( ! use_stdout )
branch  0 taken 551 (fallthrough)
branch  1 taken 3
        -:  290:		{
        -:  291:		FILE *prev_stdout;
        -:  292:
      551:  293:		if ( ! did_outfilename )
branch  0 taken 550 (fallthrough)
branch  1 taken 1
        -:  294:			{
        -:  295:			char *suffix;
        -:  296:
      550:  297:			if ( C_plus_plus )
branch  0 taken 0 (fallthrough)
branch  1 taken 550
    #####:  298:				suffix = "cc";
        -:  299:			else
      550:  300:				suffix = "c";
        -:  301:
      550:  302:			sprintf( outfile_path, outfile_template,
        -:  303:				prefix, suffix );
        -:  304:
      550:  305:			outfilename = outfile_path;
        -:  306:			}
        -:  307:
      551:  308:		prev_stdout = freopen( outfilename, "w", stdout );
call    0 returned 551
        -:  309:
      551:  310:		if ( prev_stdout == NULL )
branch  0 taken 0 (fallthrough)
branch  1 taken 551
    #####:  311:			lerrsf( _( "could not create %s" ), outfilename );
call    0 never executed
        -:  312:
      551:  313:		outfile_created = 1;
        -:  314:		}
        -:  315:
      554:  316:	if ( skelname && (skelfile = fopen( skelname, "r" )) == NULL )
branch  0 taken 3 (fallthrough)
branch  1 taken 551
call    2 returned 3
branch  3 taken 1 (fallthrough)
branch  4 taken 2
        1:  317:		lerrsf( _( "can't open skeleton file %s" ), skelname );
call    0 returned 0
        -:  318:
      553:  319:	if ( strcmp( prefix, "yy" ) )
branch  0 taken 1 (fallthrough)
branch  1 taken 552
        -:  320:		{
        -:  321:#define GEN_PREFIX(name) out_str3( "#define yy%s %s%s\n", name, prefix, name )
        1:  322:		if ( C_plus_plus )
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:  323:			GEN_PREFIX( "FlexLexer" );
call    0 never executed
        -:  324:		else
        -:  325:			{
        1:  326:			GEN_PREFIX( "_create_buffer" );
call    0 returned 1
        1:  327:			GEN_PREFIX( "_delete_buffer" );
call    0 returned 1
        1:  328:			GEN_PREFIX( "_scan_buffer" );
call    0 returned 1
        1:  329:			GEN_PREFIX( "_scan_string" );
call    0 returned 1
        1:  330:			GEN_PREFIX( "_scan_bytes" );
call    0 returned 1
        1:  331:			GEN_PREFIX( "_flex_debug" );
call    0 returned 1
        1:  332:			GEN_PREFIX( "_init_buffer" );
call    0 returned 1
        1:  333:			GEN_PREFIX( "_flush_buffer" );
call    0 returned 1
        1:  334:			GEN_PREFIX( "_load_buffer_state" );
call    0 returned 1
        1:  335:			GEN_PREFIX( "_switch_to_buffer" );
call    0 returned 1
        1:  336:			GEN_PREFIX( "in" );
call    0 returned 1
        1:  337:			GEN_PREFIX( "leng" );
call    0 returned 1
        1:  338:			GEN_PREFIX( "lex" );
call    0 returned 1
        1:  339:			GEN_PREFIX( "out" );
call    0 returned 1
        1:  340:			GEN_PREFIX( "restart" );
call    0 returned 1
        1:  341:			GEN_PREFIX( "text" );
call    0 returned 1
        -:  342:
        1:  343:			if ( do_yylineno )
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:  344:				GEN_PREFIX( "lineno" );
call    0 never executed
        -:  345:			}
        -:  346:
        1:  347:		if ( do_yywrap )
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:  348:			GEN_PREFIX( "wrap" );
call    0 returned 1
        -:  349:
        1:  350:		outn( "" );
call    0 returned 1
        -:  351:		}
        -:  352:
      553:  353:	if ( did_outfilename )
branch  0 taken 1 (fallthrough)
branch  1 taken 552
        1:  354:		line_directive_out( stdout, 0 );
call    0 returned 1
        -:  355:
      553:  356:	skelout();
call    0 returned 553
      553:  357:	}
        -:  358:
        -:  359:
        -:  360:/* flexend - terminate flex
        -:  361: *
        -:  362: * note
        -:  363: *    This routine does not return.
        -:  364: */
        -:  365:
function flexend called 565 returned 0% blocks executed 87%
      565:  366:void flexend( exit_status )
        -:  367:int exit_status;
        -:  368:
        -:  369:	{
        -:  370:	int tblsiz;
        -:  371:	int unlink();
        -:  372:
      565:  373:	if ( skelfile != NULL )
branch  0 taken 2 (fallthrough)
branch  1 taken 563
        -:  374:		{
        2:  375:		if ( ferror( skelfile ) )
call    0 returned 2
branch  1 taken 0 (fallthrough)
branch  2 taken 2
    #####:  376:			lerrsf( _( "input error reading skeleton file %s" ),
call    0 never executed
        -:  377:				skelname );
        -:  378:
        2:  379:		else if ( fclose( skelfile ) )
call    0 returned 2
branch  1 taken 0 (fallthrough)
branch  2 taken 2
    #####:  380:			lerrsf( _( "error closing skeleton file %s" ),
call    0 never executed
        -:  381:				skelname );
        -:  382:		}
        -:  383:
      565:  384:	if ( exit_status != 0 && outfile_created )
branch  0 taken 22 (fallthrough)
branch  1 taken 543
branch  2 taken 11 (fallthrough)
branch  3 taken 11
        -:  385:		{
       11:  386:		if ( ferror( stdout ) )
call    0 returned 11
branch  1 taken 0 (fallthrough)
branch  2 taken 11
    #####:  387:			lerrsf( _( "error writing output file %s" ),
call    0 never executed
        -:  388:				outfilename );
        -:  389:
       11:  390:		else if ( fclose( stdout ) )
call    0 returned 11
branch  1 taken 0 (fallthrough)
branch  2 taken 11
    #####:  391:			lerrsf( _( "error closing output file %s" ),
call    0 never executed
        -:  392:				outfilename );
        -:  393:
       11:  394:		else if ( unlink( outfilename ) )
call    0 returned 11
branch  1 taken 0 (fallthrough)
branch  2 taken 11
    #####:  395:			lerrsf( _( "error deleting output file %s" ),
call    0 never executed
        -:  396:				outfilename );
        -:  397:		}
        -:  398:
      565:  399:	if ( backing_up_report && backing_up_file )
branch  0 taken 5 (fallthrough)
branch  1 taken 560
branch  2 taken 5 (fallthrough)
branch  3 taken 0
        -:  400:		{
        5:  401:		if ( num_backing_up == 0 )
branch  0 taken 0 (fallthrough)
branch  1 taken 5
    #####:  402:			fprintf( backing_up_file, _( "No backing up.\n" ) );
call    0 never executed
        5:  403:		else if ( fullspd || fulltbl )
branch  0 taken 5 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 5
    #####:  404:			fprintf( backing_up_file,
call    0 never executed
        -:  405:				_( "%d backing up (non-accepting) states.\n" ),
        -:  406:				num_backing_up );
        -:  407:		else
        5:  408:			fprintf( backing_up_file,
call    0 returned 5
        -:  409:				_( "Compressed tables always back up.\n" ) );
        -:  410:
        5:  411:		if ( ferror( backing_up_file ) )
call    0 returned 5
branch  1 taken 0 (fallthrough)
branch  2 taken 5
    #####:  412:			lerrsf( _( "error writing backup file %s" ),
call    0 never executed
        -:  413:				backing_name );
        -:  414:
        5:  415:		else if ( fclose( backing_up_file ) )
call    0 returned 5
branch  1 taken 0 (fallthrough)
branch  2 taken 5
    #####:  416:			lerrsf( _( "error closing backup file %s" ),
call    0 never executed
        -:  417:				backing_name );
        -:  418:		}
        -:  419:
      565:  420:	if ( printstats )
branch  0 taken 9 (fallthrough)
branch  1 taken 556
        -:  421:		{
        9:  422:		fprintf( err, _( "%s version %s usage statistics:\n" ),
call    0 returned 9
        -:  423:			program_name, flex_version );
        -:  424:
        9:  425:		fprintf( err, _( "  scanner options: -" ) );
call    0 returned 9
        -:  426:
        9:  427:		if ( C_plus_plus )
branch  0 taken 0 (fallthrough)
branch  1 taken 9
    #####:  428:			putc( '+', err );
call    0 never executed
        9:  429:		if ( backing_up_report )
branch  0 taken 3 (fallthrough)
branch  1 taken 6
        3:  430:			putc( 'b', err );
call    0 returned 3
        9:  431:		if ( ddebug )
branch  0 taken 2 (fallthrough)
branch  1 taken 7
        2:  432:			putc( 'd', err );
call    0 returned 2
        9:  433:		if ( caseins )
branch  0 taken 2 (fallthrough)
branch  1 taken 7
        2:  434:			putc( 'i', err );
call    0 returned 2
        9:  435:		if ( lex_compat )
branch  0 taken 2 (fallthrough)
branch  1 taken 7
        2:  436:			putc( 'l', err );
call    0 returned 2
        9:  437:		if ( performance_report > 0 )
branch  0 taken 2 (fallthrough)
branch  1 taken 7
        2:  438:			putc( 'p', err );
call    0 returned 2
        9:  439:		if ( performance_report > 1 )
branch  0 taken 0 (fallthrough)
branch  1 taken 9
    #####:  440:			putc( 'p', err );
call    0 never executed
        9:  441:		if ( spprdflt )
branch  0 taken 2 (fallthrough)
branch  1 taken 7
        2:  442:			putc( 's', err );
call    0 returned 2
        9:  443:		if ( use_stdout )
branch  0 taken 2 (fallthrough)
branch  1 taken 7
        2:  444:			putc( 't', err );
call    0 returned 2
        9:  445:		if ( printstats )
branch  0 taken 9 (fallthrough)
branch  1 taken 0
        9:  446:			putc( 'v', err );	/* always true! */
call    0 returned 9
        9:  447:		if ( nowarn )
branch  0 taken 2 (fallthrough)
branch  1 taken 7
        2:  448:			putc( 'w', err );
call    0 returned 2
        9:  449:		if ( interactive == false )
branch  0 taken 3 (fallthrough)
branch  1 taken 6
        3:  450:			putc( 'B', err );
call    0 returned 3
        9:  451:		if ( interactive == true )
branch  0 taken 6 (fallthrough)
branch  1 taken 3
        6:  452:			putc( 'I', err );
call    0 returned 6
        9:  453:		if ( ! gen_line_dirs )
branch  0 taken 2 (fallthrough)
branch  1 taken 7
        2:  454:			putc( 'L', err );
call    0 returned 2
        9:  455:		if ( trace )
branch  0 taken 4 (fallthrough)
branch  1 taken 5
        4:  456:			putc( 'T', err );
call    0 returned 4
        -:  457:
        9:  458:		if ( csize == unspecified )
branch  0 taken 0 (fallthrough)
branch  1 taken 9
        -:  459:			/* We encountered an error fairly early on, so csize
        -:  460:			 * never got specified.  Define it now, to prevent
        -:  461:			 * bogus table sizes being written out below.
        -:  462:			 */
    #####:  463:			csize = 256;
        -:  464:
        9:  465:		if ( csize == 128 )
branch  0 taken 1 (fallthrough)
branch  1 taken 8
        1:  466:			putc( '7', err );
call    0 returned 1
        -:  467:		else
        8:  468:			putc( '8', err );
call    0 returned 8
        -:  469:
        9:  470:		fprintf( err, " -C" );
call    0 returned 9
        -:  471:
        9:  472:		if ( long_align )
branch  0 taken 3 (fallthrough)
branch  1 taken 6
        3:  473:			putc( 'a', err );
call    0 returned 3
        9:  474:		if ( fulltbl )
branch  0 taken 1 (fallthrough)
branch  1 taken 8
        1:  475:			putc( 'f', err );
call    0 returned 1
        9:  476:		if ( fullspd )
branch  0 taken 1 (fallthrough)
branch  1 taken 8
        1:  477:			putc( 'F', err );
call    0 returned 1
        9:  478:		if ( useecs )
branch  0 taken 8 (fallthrough)
branch  1 taken 1
        8:  479:			putc( 'e', err );
call    0 returned 8
        9:  480:		if ( usemecs )
branch  0 taken 8 (fallthrough)
branch  1 taken 1
        8:  481:			putc( 'm', err );
call    0 returned 8
        9:  482:		if ( use_read )
branch  0 taken 2 (fallthrough)
branch  1 taken 7
        2:  483:			putc( 'r', err );
call    0 returned 2
        -:  484:
        9:  485:		if ( did_outfilename )
branch  0 taken 0 (fallthrough)
branch  1 taken 9
    #####:  486:			fprintf( err, " -o%s", outfilename );
call    0 never executed
        -:  487:
        9:  488:		if ( skelname )
branch  0 taken 1 (fallthrough)
branch  1 taken 8
        1:  489:			fprintf( err, " -S%s", skelname );
call    0 returned 1
        -:  490:
        9:  491:		if ( strcmp( prefix, "yy" ) )
branch  0 taken 0 (fallthrough)
branch  1 taken 9
    #####:  492:			fprintf( err, " -P%s", prefix );
call    0 never executed
        -:  493:
        9:  494:		putc( '\n', err );
call    0 returned 9
        -:  495:
        9:  496:		fprintf( err, _( "  %d/%d NFA states\n" ),
call    0 returned 9
        -:  497:			lastnfa, current_mns );
        9:  498:		fprintf( err, _( "  %d/%d DFA states (%d words)\n" ),
call    0 returned 9
        -:  499:			lastdfa, current_max_dfas, totnst );
        9:  500:		fprintf( err, _( "  %d rules\n" ),
        9:  501:		num_rules + num_eof_rules - 1 /* - 1 for def. rule */ );
call    0 returned 9
        -:  502:
        9:  503:		if ( num_backing_up == 0 )
branch  0 taken 2 (fallthrough)
branch  1 taken 7
        2:  504:			fprintf( err, _( "  No backing up\n" ) );
call    0 returned 2
        7:  505:		else if ( fullspd || fulltbl )
branch  0 taken 7 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 7
    #####:  506:			fprintf( err,
call    0 never executed
        -:  507:			_( "  %d backing-up (non-accepting) states\n" ),
        -:  508:				num_backing_up );
        -:  509:		else
        7:  510:			fprintf( err,
call    0 returned 7
        -:  511:				_( "  Compressed tables always back-up\n" ) );
        -:  512:
        9:  513:		if ( bol_needed )
branch  0 taken 0 (fallthrough)
branch  1 taken 9
    #####:  514:			fprintf( err,
call    0 never executed
        -:  515:				_( "  Beginning-of-line patterns used\n" ) );
        -:  516:
        9:  517:		fprintf( err, _( "  %d/%d start conditions\n" ), lastsc,
call    0 returned 9
        -:  518:			current_max_scs );
        9:  519:		fprintf( err,
call    0 returned 9
        -:  520:			_( "  %d epsilon states, %d double epsilon states\n" ),
        -:  521:			numeps, eps2 );
        -:  522:
        9:  523:		if ( lastccl == 0 )
branch  0 taken 2 (fallthrough)
branch  1 taken 7
        2:  524:			fprintf( err, _( "  no character classes\n" ) );
call    0 returned 2
        -:  525:		else
        7:  526:			fprintf( err,
        -:  527:_( "  %d/%d character classes needed %d/%d words of storage, %d reused\n" ),
        -:  528:				lastccl, current_maxccls,
        7:  529:				cclmap[lastccl] + ccllen[lastccl],
call    0 returned 7
        -:  530:				current_max_ccl_tbl_size, cclreuse );
        -:  531:
        9:  532:		fprintf( err, _( "  %d state/nextstate pairs created\n" ),
call    0 returned 9
        -:  533:			numsnpairs );
        9:  534:		fprintf( err, _( "  %d/%d unique/duplicate transitions\n" ),
call    0 returned 9
        -:  535:			numuniq, numdup );
        -:  536:
        9:  537:		if ( fulltbl )
branch  0 taken 1 (fallthrough)
branch  1 taken 8
        -:  538:			{
        1:  539:			tblsiz = lastdfa * numecs;
        1:  540:			fprintf( err, _( "  %d table entries\n" ), tblsiz );
call    0 returned 1
        -:  541:			}
        -:  542:
        -:  543:		else
        -:  544:			{
        8:  545:			tblsiz = 2 * (lastdfa + numtemps) + 2 * tblend;
        -:  546:
        8:  547:			fprintf( err,
call    0 returned 8
        -:  548:				_( "  %d/%d base-def entries created\n" ),
        -:  549:				lastdfa + numtemps, current_max_dfas );
        8:  550:			fprintf( err,
call    0 returned 8
        -:  551:			_( "  %d/%d (peak %d) nxt-chk entries created\n" ),
        -:  552:				tblend, current_max_xpairs, peakpairs );
        8:  553:			fprintf( err,
call    0 returned 8
        -:  554:		_( "  %d/%d (peak %d) template nxt-chk entries created\n" ),
        -:  555:				numtemps * nummecs,
        -:  556:				current_max_template_xpairs,
        -:  557:				numtemps * numecs );
        8:  558:			fprintf( err, _( "  %d empty table entries\n" ),
call    0 returned 8
        -:  559:				nummt );
        8:  560:			fprintf( err, _( "  %d protos created\n" ),
call    0 returned 8
        -:  561:				numprots );
        8:  562:			fprintf( err,
call    0 returned 8
        -:  563:				_( "  %d templates created, %d uses\n" ),
        -:  564:				numtemps, tmpuses );
        -:  565:			}
        -:  566:
        9:  567:		if ( useecs )
branch  0 taken 8 (fallthrough)
branch  1 taken 1
        -:  568:			{
        8:  569:			tblsiz = tblsiz + csize;
        8:  570:			fprintf( err,
call    0 returned 8
        -:  571:				_( "  %d/%d equivalence classes created\n" ),
        -:  572:				numecs, csize );
        -:  573:			}
        -:  574:
        9:  575:		if ( usemecs )
branch  0 taken 8 (fallthrough)
branch  1 taken 1
        -:  576:			{
        8:  577:			tblsiz = tblsiz + numecs;
        8:  578:			fprintf( err,
call    0 returned 8
        -:  579:			_( "  %d/%d meta-equivalence classes created\n" ),
        -:  580:				nummecs, csize );
        -:  581:			}
        -:  582:
        9:  583:		fprintf( err,
call    0 returned 9
        -:  584:		_( "  %d (%d saved) hash collisions, %d DFAs equal\n" ),
        -:  585:			hshcol, hshsave, dfaeql );
        9:  586:		fprintf( err, _( "  %d sets of reallocations needed\n" ),
call    0 returned 9
        -:  587:			num_reallocs );
        9:  588:		fprintf( err, _( "  %d total table entries needed\n" ),
call    0 returned 9
        -:  589:			tblsiz );
        -:  590:		}
        -:  591:
      565:  592:	exit( exit_status );
        -:  593:	}
        -:  594:
        -:  595:
        -:  596:/* flexinit - initialize flex */
        -:  597:
function flexinit called 567 returned 99% blocks executed 84%
      567:  598:void flexinit( argc, argv )
        -:  599:int argc;
        -:  600:char **argv;
        -:  601:	{
        -:  602:	int i, sawcmpflag;
        -:  603:	char *arg;
        -:  604:
      567:  605:	printstats = syntaxerror = trace = spprdflt = caseins = false;
      567:  606:	lex_compat = C_plus_plus = backing_up_report = ddebug = fulltbl = false;
      567:  607:	fullspd = long_align = nowarn = yymore_used = continued_action = false;
      567:  608:	do_yylineno = yytext_is_array = in_rule = reject = do_stdinit = false;
      567:  609:	yymore_really_used = reject_really_used = unspecified;
      567:  610:	interactive = csize = unspecified;
      567:  611:	do_yywrap = gen_line_dirs = usemecs = useecs = true;
      567:  612:	performance_report = 0;
      567:  613:	did_outfilename = 0;
      567:  614:	prefix = "yy";
      567:  615:	yyclass = 0;
      567:  616:	use_read = use_stdout = false;
        -:  617:
      567:  618:	sawcmpflag = false;
        -:  619:
        -:  620:	/* Initialize dynamic array for holding the rule actions. */
      567:  621:	action_size = 2048;	/* default size of action array in bytes */
      567:  622:	action_array = allocate_character_array( action_size );
call    0 returned 567
      567:  623:	defs1_offset = prolog_offset = action_offset = action_index = 0;
      567:  624:	action_array[0] = '\0';
        -:  625:
        -:  626:/* Commented by Amit Goel on 5th September 2001 to remove nomdeterminism */
        -:  627:/*	program_name = argv[0];    */
        -:  628:/* Added by Amit Goel on 5th September 2001 */
      567:  629:        program_name = "Executable";
        -:  630:
      567:  631:	if ( program_name[0] != '\0' &&
branch  0 taken 567 (fallthrough)
branch  1 taken 0
      567:  632:	     program_name[strlen( program_name ) - 1] == '+' )
branch  0 taken 0 (fallthrough)
branch  1 taken 567
    #####:  633:		C_plus_plus = true;
        -:  634:
        -:  635:/* ### add for testing ### */
      567:  636:        ++argv;--argc;
        -:  637:/* ####################### */
        -:  638:
        -:  639:	/* read flags */
     1517:  640:	for ( --argc, ++argv; argc ; --argc, ++argv )
branch  0 taken 1517
branch  1 taken 0 (fallthrough)
        -:  641:		{
     1517:  642:		arg = argv[0];
        -:  643:
     1517:  644:		if ( arg[0] != '-' || arg[1] == '\0' )
branch  0 taken 956 (fallthrough)
branch  1 taken 561
branch  2 taken 956 (fallthrough)
branch  3 taken 0
        -:  645:			break;
        -:  646:
      956:  647:		if ( arg[1] == '-' )
branch  0 taken 0 (fallthrough)
branch  1 taken 956
        -:  648:			{ /* --option */
    #####:  649:			if ( ! strcmp( arg, "--help" ) )
branch  0 never executed
branch  1 never executed
    #####:  650:				arg = "-h";
        -:  651:
    #####:  652:			else if ( ! strcmp( arg, "--version" ) )
branch  0 never executed
branch  1 never executed
    #####:  653:				arg = "-V";
        -:  654:
    #####:  655:			else if ( ! strcmp( arg, "--" ) )
branch  0 never executed
branch  1 never executed
        -:  656:				{ /* end of options */
    #####:  657:				--argc;
    #####:  658:				++argv;
    #####:  659:				break;
        -:  660:				}
        -:  661:			}
        -:  662:
     1615:  663:		for ( i = 1; arg[i] != '\0'; ++i )
branch  0 taken 1148
branch  1 taken 467 (fallthrough)
     1148:  664:			switch ( arg[i] )
branch  0 taken 0
branch  1 taken 2
branch  2 taken 5
branch  3 taken 1
branch  4 taken 478
branch  5 taken 252
branch  6 taken 84
branch  7 taken 80
branch  8 taken 1
branch  9 taken 3
branch 10 taken 3
branch 11 taken 163
branch 12 taken 3
branch 13 taken 1
branch 14 taken 1
branch 15 taken 4
branch 16 taken 15
branch 17 taken 4
branch 18 taken 3
branch 19 taken 3
branch 20 taken 24
branch 21 taken 9
branch 22 taken 1
branch 23 taken 3
branch 24 taken 3
branch 25 taken 2
branch 26 taken 0
        -:  665:				{
    #####:  666:				case '+':
    #####:  667:					C_plus_plus = true;
    #####:  668:					break;
        -:  669:
        2:  670:				case 'B':
        2:  671:					interactive = false;
        2:  672:					break;
        -:  673:
        5:  674:				case 'b':
        5:  675:					backing_up_report = true;
        5:  676:					break;
        -:  677:
        1:  678:				case 'c':
        1:  679:					break;
        -:  680:
      478:  681:				case 'C':
      478:  682:					if ( i != 1 )
branch  0 taken 1 (fallthrough)
branch  1 taken 477
        1:  683:						flexerror(
call    0 returned 0
        -:  684:				_( "-C flag must be given separately" ) );
        -:  685:
      477:  686:					if ( ! sawcmpflag )
branch  0 taken 476 (fallthrough)
branch  1 taken 1
        -:  687:						{
      476:  688:						useecs = false;
      476:  689:						usemecs = false;
      476:  690:						fulltbl = false;
      476:  691:						sawcmpflag = true;
        -:  692:						}
        -:  693:
     1401:  694:					for ( ++i; arg[i] != '\0'; ++i )
branch  0 taken 925
branch  1 taken 476 (fallthrough)
      925:  695:						switch ( arg[i] )
branch  0 taken 243
branch  1 taken 243
branch  2 taken 15
branch  3 taken 18
branch  4 taken 163
branch  5 taken 242
branch  6 taken 1
        -:  696:							{
      243:  697:							case 'a':
      243:  698:								long_align =
        -:  699:									true;
      243:  700:								break;
        -:  701:
      243:  702:							case 'e':
      243:  703:								useecs = true;
      243:  704:								break;
        -:  705:
       15:  706:							case 'F':
       15:  707:								fullspd = true;
       15:  708:								break;
        -:  709:
       18:  710:							case 'f':
       18:  711:								fulltbl = true;
       18:  712:								break;
        -:  713:
      163:  714:							case 'm':
      163:  715:								usemecs = true;
      163:  716:								break;
        -:  717:
      242:  718:							case 'r':
      242:  719:								use_read = true;
      242:  720:								break;
        -:  721:
        1:  722:							default:
        1:  723:								lerrif(
        -:  724:						_( "unknown -C option '%c'" ),
        1:  725:								(int) arg[i] );
call    0 returned 0
    #####:  726:								break;
        -:  727:							}
        -:  728:
      476:  729:					goto get_next_arg;
        -:  730:
      252:  731:				case 'd':
      252:  732:					ddebug = true;
      252:  733:					break;
        -:  734:
       84:  735:				case 'f':
       84:  736:					useecs = usemecs = false;
       84:  737:					use_read = fulltbl = true;
       84:  738:					break;
        -:  739:
       80:  740:				case 'F':
       80:  741:					useecs = usemecs = false;
       80:  742:					use_read = fullspd = true;
       80:  743:					break;
        -:  744:
        1:  745:				case '?':
        -:  746:				case 'h':
        1:  747:					usage();
call    0 returned 1
        1:  748:					exit( 0 );
call    0 returned 0
        -:  749:
        3:  750:				case 'I':
        3:  751:					interactive = true;
        3:  752:					break;
        -:  753:
        3:  754:				case 'i':
        3:  755:					caseins = true;
        3:  756:					break;
        -:  757:
      163:  758:				case 'l':
      163:  759:					lex_compat = true;
      163:  760:					break;
        -:  761:
        3:  762:				case 'L':
        3:  763:					gen_line_dirs = false;
        3:  764:					break;
        -:  765:
        1:  766:				case 'n':
        -:  767:					/* Stupid do-nothing deprecated
        -:  768:					 * option.
        -:  769:					 */
        1:  770:					break;
        -:  771:
        1:  772:				case 'o':
        1:  773:					if ( i != 1 )
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:  774:						flexerror(
call    0 never executed
        -:  775:				_( "-o flag must be given separately" ) );
        -:  776:
        1:  777:					outfilename = arg + i + 1;
        1:  778:					did_outfilename = 1;
        1:  779:					goto get_next_arg;
        -:  780:
        4:  781:				case 'P':
        4:  782:					if ( i != 1 )
branch  0 taken 1 (fallthrough)
branch  1 taken 3
        1:  783:						flexerror(
call    0 returned 0
        -:  784:				_( "-P flag must be given separately" ) );
        -:  785:
        3:  786:					prefix = arg + i + 1;
        3:  787:					goto get_next_arg;
        -:  788:
       15:  789:				case 'p':
       15:  790:					++performance_report;
       15:  791:					break;
        -:  792:
        4:  793:				case 'S':
        4:  794:					if ( i != 1 )
branch  0 taken 1 (fallthrough)
branch  1 taken 3
        1:  795:						flexerror(
call    0 returned 0
        -:  796:				_( "-S flag must be given separately" ) );
        -:  797:
        3:  798:					skelname = arg + i + 1;
        3:  799:					goto get_next_arg;
        -:  800:
        3:  801:				case 's':
        3:  802:					spprdflt = true;
        3:  803:					break;
        -:  804:
        3:  805:				case 't':
        3:  806:					use_stdout = true;
        3:  807:					break;
        -:  808:
       24:  809:				case 'T':
       24:  810:					trace = true;
       24:  811:					break;
        -:  812:
        9:  813:				case 'v':
        9:  814:					printstats = true;
        9:  815:					break;
        -:  816:
        1:  817:				case 'V':
        1:  818:					printf( _( "%s version %s\n" ),
call    0 returned 1
        -:  819:						program_name, flex_version );
        1:  820:					exit( 0 );
call    0 returned 0
        -:  821:
        3:  822:				case 'w':
        3:  823:					nowarn = true;
        3:  824:					break;
        -:  825:
        3:  826:				case '7':
        3:  827:					csize = 128;
        3:  828:					break;
        -:  829:
        2:  830:				case '8':
        2:  831:					csize = CSIZE;
        2:  832:					break;
        -:  833:
    #####:  834:				default:
    #####:  835:					fprintf( err,
        -:  836:		_( "%s: unknown flag '%c'.  For usage, try\n\t%s --help\n" ),
    #####:  837:						program_name, (int) arg[i],
call    0 never executed
        -:  838:						program_name );
    #####:  839:					exit( 1 );
call    0 never executed
        -:  840:				}
        -:  841:
        -:  842:		/* Used by -C, -S, -o, and -P flags in lieu of a "continue 2"
        -:  843:		 * control.
        -:  844:		 */
      950:  845:		get_next_arg: ;
        -:  846:		}
        -:  847:
      561:  848:	num_input_files = argc;
      561:  849:	input_files = argv;
     561*:  850:	set_input_file( num_input_files > 0 ? input_files[0] : NULL );
branch  0 taken 561 (fallthrough)
branch  1 taken 0
call    2 returned 560
        -:  851:
      560:  852:	lastccl = lastsc = lastdfa = lastnfa = 0;
      560:  853:	num_rules = num_eof_rules = default_rule = 0;
      560:  854:	numas = numsnpairs = tmpuses = 0;
      560:  855:	numecs = numeps = eps2 = num_reallocs = hshcol = dfaeql = totnst = 0;
      560:  856:	numuniq = numdup = hshsave = eofseen = datapos = dataline = 0;
      560:  857:	num_backing_up = onesp = numprots = 0;
      560:  858:	variable_trailing_context_rules = bol_needed = false;
        -:  859:
      560:  860:	out_linenum = linenum = sectnum = 1;
      560:  861:	firstprot = NIL;
        -:  862:
        -:  863:	/* Used in mkprot() so that the first proto goes in slot 1
        -:  864:	 * of the proto queue.
        -:  865:	 */
      560:  866:	lastprot = 1;
        -:  867:
      560:  868:	set_up_initial_allocations();
call    0 returned 560
      560:  869:	}
        -:  870:
        -:  871:
        -:  872:/* readin - read in the rules section of the input file(s) */
        -:  873:
function readin called 560 returned 97% blocks executed 71%
      560:  874:void readin()
        -:  875:	{
        -:  876:	static char yy_stdinit[] = "FILE *yyin = stdin, *yyout = stdout;";
        -:  877:	static char yy_nostdinit[] =
        -:  878:		"FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;";
        -:  879:
      560:  880:	line_directive_out( (FILE *) 0, 1 );
call    0 returned 560
        -:  881:
      560:  882:	if ( yyparse() )
call    0 returned 552
branch  1 taken 1 (fallthrough)
branch  2 taken 551
        -:  883:		{
        1:  884:		pinpoint_message( _( "fatal parse error" ) );
call    0 returned 1
        1:  885:		flexend( 1 );
call    0 returned 0
        -:  886:		}
        -:  887:
      551:  888:	if ( syntaxerror )
branch  0 taken 6 (fallthrough)
branch  1 taken 545
        6:  889:		flexend( 1 );
call    0 returned 0
        -:  890:
      545:  891:	if ( backing_up_report )
branch  0 taken 5 (fallthrough)
branch  1 taken 540
        -:  892:		{
        5:  893:		backing_up_file = fopen( backing_name, "w" );
call    0 returned 5
        5:  894:		if ( backing_up_file == NULL )
branch  0 taken 0 (fallthrough)
branch  1 taken 5
    #####:  895:			lerrsf(
call    0 never executed
        -:  896:			_( "could not create backing-up info file %s" ),
        -:  897:				backing_name );
        -:  898:		}
        -:  899:
        -:  900:	else
      540:  901:		backing_up_file = NULL;
        -:  902:
      545:  903:	if ( yymore_really_used == true )
branch  0 taken 161 (fallthrough)
branch  1 taken 384
      161:  904:		yymore_used = true;
      384:  905:	else if ( yymore_really_used == false )
branch  0 taken 0 (fallthrough)
branch  1 taken 384
    #####:  906:		yymore_used = false;
        -:  907:
      545:  908:	if ( reject_really_used == true )
branch  0 taken 161 (fallthrough)
branch  1 taken 384
      161:  909:		reject = true;
      384:  910:	else if ( reject_really_used == false )
branch  0 taken 0 (fallthrough)
branch  1 taken 384
    #####:  911:		reject = false;
        -:  912:
      545:  913:	if ( performance_report > 0 )
branch  0 taken 12 (fallthrough)
branch  1 taken 533
        -:  914:		{
       12:  915:		if ( lex_compat )
branch  0 taken 2 (fallthrough)
branch  1 taken 10
        -:  916:			{
        2:  917:			fprintf( err,
call    0 returned 2
        -:  918:_( "-l AT&T lex compatibility option entails a large performance penalty\n" ) );
        2:  919:			fprintf( err,
call    0 returned 2
        -:  920:_( " and may be the actual source of other reported performance penalties\n" ) );
        -:  921:			}
        -:  922:
       10:  923:		else if ( do_yylineno )
branch  0 taken 0 (fallthrough)
branch  1 taken 10
        -:  924:			{
    #####:  925:			fprintf( err,
call    0 never executed
        -:  926:	_( "%%option yylineno entails a large performance penalty\n" ) );
        -:  927:			}
        -:  928:
       12:  929:		if ( performance_report > 1 )
branch  0 taken 1 (fallthrough)
branch  1 taken 11
        -:  930:			{
        1:  931:			if ( interactive )
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:  932:				fprintf( err,
call    0 returned 1
        -:  933:	_( "-I (interactive) entails a minor performance penalty\n" ) );
        -:  934:
        1:  935:			if ( yymore_used )
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:  936:				fprintf( err,
call    0 never executed
        -:  937:		_( "yymore() entails a minor performance penalty\n" ) );
        -:  938:			}
        -:  939:
       12:  940:		if ( reject )
branch  0 taken 5 (fallthrough)
branch  1 taken 7
        5:  941:			fprintf( err,
call    0 returned 5
        -:  942:			_( "REJECT entails a large performance penalty\n" ) );
        -:  943:
       12:  944:		if ( variable_trailing_context_rules )
branch  0 taken 1 (fallthrough)
branch  1 taken 11
        1:  945:			fprintf( err,
call    0 returned 1
        -:  946:_( "Variable trailing context rules entail a large performance penalty\n" ) );
        -:  947:		}
        -:  948:
      545:  949:	if ( reject )
branch  0 taken 168 (fallthrough)
branch  1 taken 377
      168:  950:		real_reject = true;
        -:  951:
      545:  952:	if ( variable_trailing_context_rules )
branch  0 taken 33 (fallthrough)
branch  1 taken 512
       33:  953:		reject = true;
        -:  954:
      545:  955:	if ( (fulltbl || fullspd) && reject )
branch  0 taken 521 (fallthrough)
branch  1 taken 24
branch  2 taken 93 (fallthrough)
branch  3 taken 428
branch  4 taken 2 (fallthrough)
branch  5 taken 115
        -:  956:		{
        2:  957:		if ( real_reject )
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2:  958:			flexerror(
call    0 returned 0
        -:  959:				_( "REJECT cannot be used with -f or -F" ) );
    #####:  960:		else if ( do_yylineno )
branch  0 never executed
branch  1 never executed
    #####:  961:			flexerror(
call    0 never executed
        -:  962:			_( "%option yylineno cannot be used with -f or -F" ) );
        -:  963:		else
    #####:  964:			flexerror(
call    0 never executed
        -:  965:	_( "variable trailing context rules cannot be used with -f or -F" ) );
        -:  966:		}
        -:  967:
      543:  968:	if ( reject )
branch  0 taken 168 (fallthrough)
branch  1 taken 375
      168:  969:		outn( "\n#define YY_USES_REJECT" );
call    0 returned 168
        -:  970:
      543:  971:	if ( ! do_yywrap )
branch  0 taken 0 (fallthrough)
branch  1 taken 543
        -:  972:		{
    #####:  973:		outn( "\n#define yywrap() 1" );
call    0 never executed
    #####:  974:		outn( "#define YY_SKIP_YYWRAP" );
call    0 never executed
        -:  975:		}
        -:  976:
      543:  977:	if ( ddebug )
branch  0 taken 252 (fallthrough)
branch  1 taken 291
      252:  978:		outn( "\n#define FLEX_DEBUG" );
call    0 returned 252
        -:  979:
      543:  980:	if ( csize == 256 )
branch  0 taken 467 (fallthrough)
branch  1 taken 76
      467:  981:		outn( "typedef unsigned char YY_CHAR;" );
call    0 returned 467
        -:  982:	else
       76:  983:		outn( "typedef char YY_CHAR;" );
call    0 returned 76
        -:  984:
      543:  985:	if ( C_plus_plus )
branch  0 taken 0 (fallthrough)
branch  1 taken 543
        -:  986:		{
    #####:  987:		outn( "#define yytext_ptr yytext" );
call    0 never executed
        -:  988:
    #####:  989:		if ( interactive )
branch  0 never executed
branch  1 never executed
    #####:  990:			outn( "#define YY_INTERACTIVE" );
call    0 never executed
        -:  991:		}
        -:  992:
        -:  993:	else
        -:  994:		{
      543:  995:		if ( do_stdinit )
branch  0 taken 0 (fallthrough)
branch  1 taken 543
        -:  996:			{
    #####:  997:			outn( "#ifdef VMS" );
call    0 never executed
    #####:  998:			outn( "#ifndef __VMS_POSIX" );
call    0 never executed
    #####:  999:			outn( yy_nostdinit );
call    0 never executed
    #####: 1000:			outn( "#else" );
call    0 never executed
    #####: 1001:			outn( yy_stdinit );
call    0 never executed
    #####: 1002:			outn( "#endif" );
call    0 never executed
    #####: 1003:			outn( "#else" );
call    0 never executed
    #####: 1004:			outn( yy_stdinit );
call    0 never executed
    #####: 1005:			outn( "#endif" );
call    0 never executed
        -: 1006:			}
        -: 1007:
        -: 1008:		else
      543: 1009:			outn( yy_nostdinit );
call    0 returned 543
        -: 1010:		}
        -: 1011:
      543: 1012:	if ( fullspd )
branch  0 taken 92 (fallthrough)
branch  1 taken 451
       92: 1013:		outn( "typedef yyconst struct yy_trans_info *yy_state_type;" );
call    0 returned 92
      451: 1014:	else if ( ! C_plus_plus )
branch  0 taken 451 (fallthrough)
branch  1 taken 0
      451: 1015:		outn( "typedef int yy_state_type;" );
call    0 returned 451
        -: 1016:
      543: 1017:	if ( ddebug )
branch  0 taken 252 (fallthrough)
branch  1 taken 291
      252: 1018:		outn( "\n#define FLEX_DEBUG" );
call    0 returned 252
        -: 1019:
      543: 1020:	if ( lex_compat )
branch  0 taken 161 (fallthrough)
branch  1 taken 382
      161: 1021:		outn( "#define YY_FLEX_LEX_COMPAT" );
call    0 returned 161
        -: 1022:
      543: 1023:	if ( do_yylineno && ! C_plus_plus )
branch  0 taken 161 (fallthrough)
branch  1 taken 382
branch  2 taken 161 (fallthrough)
branch  3 taken 0
        -: 1024:		{
      161: 1025:		outn( "extern int yylineno;" );
call    0 returned 161
      161: 1026:		outn( "int yylineno = 1;" );
call    0 returned 161
        -: 1027:		}
        -: 1028:
      543: 1029:	if ( C_plus_plus )
branch  0 taken 0 (fallthrough)
branch  1 taken 543
        -: 1030:		{
    #####: 1031:		outn( "\n#include <FlexLexer.h>" );
call    0 never executed
        -: 1032:
    #####: 1033:		if ( yyclass )
branch  0 never executed
branch  1 never executed
        -: 1034:			{
    #####: 1035:			outn( "int yyFlexLexer::yylex()" );
call    0 never executed
    #####: 1036:			outn( "\t{" );
call    0 never executed
    #####: 1037:			outn(
call    0 never executed
        -: 1038:"\tLexerError( \"yyFlexLexer::yylex invoked but %option yyclass used\" );" );
    #####: 1039:			outn( "\treturn 0;" );
call    0 never executed
    #####: 1040:			outn( "\t}" );
call    0 never executed
        -: 1041:	
    #####: 1042:			out_str( "\n#define YY_DECL int %s::yylex()\n",
call    0 never executed
        -: 1043:				yyclass );
        -: 1044:			}
        -: 1045:		}
        -: 1046:
        -: 1047:	else
        -: 1048:		{
      543: 1049:		if ( yytext_is_array )
branch  0 taken 161 (fallthrough)
branch  1 taken 382
      161: 1050:			outn( "extern char yytext[];\n" );
call    0 returned 161
        -: 1051:
        -: 1052:		else
        -: 1053:			{
      382: 1054:			outn( "extern char *yytext;" );
call    0 returned 382
      382: 1055:			outn( "#define yytext_ptr yytext" );
call    0 returned 382
        -: 1056:			}
        -: 1057:
      543: 1058:		if ( yyclass )
branch  0 taken 0 (fallthrough)
branch  1 taken 543
    #####: 1059:			flexerror(
call    0 never executed
        -: 1060:		_( "%option yyclass only meaningful for C++ scanners" ) );
        -: 1061:		}
        -: 1062:
      543: 1063:	if ( useecs )
branch  0 taken 296 (fallthrough)
branch  1 taken 247
      296: 1064:		numecs = cre8ecs( nextecm, ecgroup, csize );
call    0 returned 296
        -: 1065:	else
      247: 1066:		numecs = csize;
        -: 1067:
        -: 1068:	/* Now map the equivalence class for NUL to its expected place. */
      543: 1069:	ecgroup[0] = ecgroup[csize];
      543: 1070:	NUL_ec = ABS( ecgroup[0] );
        -: 1071:
      543: 1072:	if ( useecs )
branch  0 taken 296 (fallthrough)
branch  1 taken 247
      296: 1073:		ccl2ecl();
call    0 returned 296
      543: 1074:	}
        -: 1075:
        -: 1076:
        -: 1077:/* set_up_initial_allocations - allocate memory for internal tables */
        -: 1078:
function set_up_initial_allocations called 560 returned 100% blocks executed 100%
      560: 1079:void set_up_initial_allocations()
        -: 1080:	{
      560: 1081:	current_mns = INITIAL_MNS;
      560: 1082:	firstst = allocate_integer_array( current_mns );
call    0 returned 560
      560: 1083:	lastst = allocate_integer_array( current_mns );
call    0 returned 560
      560: 1084:	finalst = allocate_integer_array( current_mns );
call    0 returned 560
      560: 1085:	transchar = allocate_integer_array( current_mns );
call    0 returned 560
      560: 1086:	trans1 = allocate_integer_array( current_mns );
call    0 returned 560
      560: 1087:	trans2 = allocate_integer_array( current_mns );
call    0 returned 560
      560: 1088:	accptnum = allocate_integer_array( current_mns );
call    0 returned 560
      560: 1089:	assoc_rule = allocate_integer_array( current_mns );
call    0 returned 560
      560: 1090:	state_type = allocate_integer_array( current_mns );
call    0 returned 560
        -: 1091:
      560: 1092:	current_max_rules = INITIAL_MAX_RULES;
      560: 1093:	rule_type = allocate_integer_array( current_max_rules );
call    0 returned 560
      560: 1094:	rule_linenum = allocate_integer_array( current_max_rules );
call    0 returned 560
      560: 1095:	rule_useful = allocate_integer_array( current_max_rules );
call    0 returned 560
        -: 1096:
      560: 1097:	current_max_scs = INITIAL_MAX_SCS;
      560: 1098:	scset = allocate_integer_array( current_max_scs );
call    0 returned 560
      560: 1099:	scbol = allocate_integer_array( current_max_scs );
call    0 returned 560
      560: 1100:	scxclu = allocate_integer_array( current_max_scs );
call    0 returned 560
      560: 1101:	sceof = allocate_integer_array( current_max_scs );
call    0 returned 560
      560: 1102:	scname = allocate_char_ptr_array( current_max_scs );
call    0 returned 560
        -: 1103:
      560: 1104:	current_maxccls = INITIAL_MAX_CCLS;
      560: 1105:	cclmap = allocate_integer_array( current_maxccls );
call    0 returned 560
      560: 1106:	ccllen = allocate_integer_array( current_maxccls );
call    0 returned 560
      560: 1107:	cclng = allocate_integer_array( current_maxccls );
call    0 returned 560
        -: 1108:
      560: 1109:	current_max_ccl_tbl_size = INITIAL_MAX_CCL_TBL_SIZE;
      560: 1110:	ccltbl = allocate_Character_array( current_max_ccl_tbl_size );
call    0 returned 560
        -: 1111:
      560: 1112:	current_max_dfa_size = INITIAL_MAX_DFA_SIZE;
        -: 1113:
      560: 1114:	current_max_xpairs = INITIAL_MAX_XPAIRS;
      560: 1115:	nxt = allocate_integer_array( current_max_xpairs );
call    0 returned 560
      560: 1116:	chk = allocate_integer_array( current_max_xpairs );
call    0 returned 560
        -: 1117:
      560: 1118:	current_max_template_xpairs = INITIAL_MAX_TEMPLATE_XPAIRS;
      560: 1119:	tnxt = allocate_integer_array( current_max_template_xpairs );
call    0 returned 560
        -: 1120:
      560: 1121:	current_max_dfas = INITIAL_MAX_DFAS;
      560: 1122:	base = allocate_integer_array( current_max_dfas );
call    0 returned 560
      560: 1123:	def = allocate_integer_array( current_max_dfas );
call    0 returned 560
      560: 1124:	dfasiz = allocate_integer_array( current_max_dfas );
call    0 returned 560
      560: 1125:	accsiz = allocate_integer_array( current_max_dfas );
call    0 returned 560
      560: 1126:	dhash = allocate_integer_array( current_max_dfas );
call    0 returned 560
      560: 1127:	dss = allocate_int_ptr_array( current_max_dfas );
call    0 returned 560
      560: 1128:	dfaacc = allocate_dfaacc_union( current_max_dfas );
call    0 returned 560
        -: 1129:
      560: 1130:	nultrans = (int *) 0;
      560: 1131:	}
        -: 1132:
        -: 1133:
function usage called 1 returned 100% blocks executed 98%
        1: 1134:void usage()
        -: 1135:	{
        -: 1136:/*	FILE *f = stdout;*/ /* #### f is replaced by err for testing. #### */
        -: 1137:
        1: 1138:	fprintf( err,
call    0 returned 1
        -: 1139:_( "%s [-bcdfhilnpstvwBFILTV78+? -C[aefFmr] -ooutput -Pprefix -Sskeleton]\n" ),
        -: 1140:		program_name );
        1: 1141:	fprintf( err, _( "\t[--help --version] [file ...]\n" ) );
call    0 returned 1
        -: 1142:
        1: 1143:	fprintf( err, _( "\t-b  generate backing-up information to %s\n" ),
call    0 returned 1
        -: 1144:		backing_name );
        1: 1145:	fprintf( err, _( "\t-c  do-nothing POSIX option\n" ) );
call    0 returned 1
        1: 1146:	fprintf( err, _( "\t-d  turn on debug mode in generated scanner\n" ) );
call    0 returned 1
        1: 1147:	fprintf( err, _( "\t-f  generate fast, large scanner\n" ) );
call    0 returned 1
        1: 1148:	fprintf( err, _( "\t-h  produce this help message\n" ) );
call    0 returned 1
        1: 1149:	fprintf( err, _( "\t-i  generate case-insensitive scanner\n" ) );
call    0 returned 1
        1: 1150:	fprintf( err, _( "\t-l  maximal compatibility with original lex\n" ) );
call    0 returned 1
        1: 1151:	fprintf( err, _( "\t-n  do-nothing POSIX option\n" ) );
call    0 returned 1
        1: 1152:	fprintf( err, _( "\t-p  generate performance report to err\n" ) );
call    0 returned 1
        1: 1153:	fprintf( err,
call    0 returned 1
        -: 1154:		_( "\t-s  suppress default rule to ECHO unmatched text\n" ) );
        -: 1155:
        1: 1156:	if ( ! did_outfilename )
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -: 1157:		{
       1*: 1158:		sprintf( outfile_path, outfile_template,
        1: 1159:			prefix, C_plus_plus ? "cc" : "c" );
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        1: 1160:		outfilename = outfile_path;
        -: 1161:		}
        -: 1162:
        1: 1163:	fprintf( err,
call    0 returned 1
        -: 1164:		_( "\t-t  write generated scanner on stdout instead of %s\n" ),
        -: 1165:		outfilename );
        -: 1166:
        1: 1167:	fprintf( err,
call    0 returned 1
        -: 1168:		_( "\t-v  write summary of scanner statistics to f\n" ) );
        1: 1169:	fprintf( err, _( "\t-w  do not generate warnings\n" ) );
call    0 returned 1
        1: 1170:	fprintf( err, _( "\t-B  generate batch scanner (opposite of -I)\n" ) );
call    0 returned 1
        1: 1171:	fprintf( err,
call    0 returned 1
        -: 1172:		_( "\t-F  use alternative fast scanner representation\n" ) );
        1: 1173:	fprintf( err,
call    0 returned 1
        -: 1174:		_( "\t-I  generate interactive scanner (opposite of -B)\n" ) );
        1: 1175:	fprintf( err, _( "\t-L  suppress #line directives in scanner\n" ) );
call    0 returned 1
        1: 1176:	fprintf( err, _( "\t-T  %s should run in trace mode\n" ), program_name );
call    0 returned 1
        1: 1177:	fprintf( err, _( "\t-V  report %s version\n" ), program_name );
call    0 returned 1
        1: 1178:	fprintf( err, _( "\t-7  generate 7-bit scanner\n" ) );
call    0 returned 1
        1: 1179:	fprintf( err, _( "\t-8  generate 8-bit scanner\n" ) );
call    0 returned 1
        1: 1180:	fprintf( err, _( "\t-+  generate C++ scanner class\n" ) );
call    0 returned 1
        1: 1181:	fprintf( err, _( "\t-?  produce this help message\n" ) );
call    0 returned 1
        1: 1182:	fprintf( err,
call    0 returned 1
        -: 1183:_( "\t-C  specify degree of table compression (default is -Cem):\n" ) );
        1: 1184:	fprintf( err,
call    0 returned 1
        -: 1185:_( "\t\t-Ca  trade off larger tables for better memory alignment\n" ) );
        1: 1186:	fprintf( err, _( "\t\t-Ce  construct equivalence classes\n" ) );
call    0 returned 1
        1: 1187:	fprintf( err,
call    0 returned 1
        -: 1188:_( "\t\t-Cf  do not compress scanner tables; use -f representation\n" ) );
        1: 1189:	fprintf( err,
call    0 returned 1
        -: 1190:_( "\t\t-CF  do not compress scanner tables; use -F representation\n" ) );
        1: 1191:	fprintf( err, _( "\t\t-Cm  construct meta-equivalence classes\n" ) );
call    0 returned 1
        1: 1192:	fprintf( err,
call    0 returned 1
        -: 1193:	_( "\t\t-Cr  use read() instead of stdio for scanner input\n" ) );
        1: 1194:	fprintf( err, _( "\t-o  specify output filename\n" ) );
call    0 returned 1
        1: 1195:	fprintf( err, _( "\t-P  specify scanner prefix other than \"yy\"\n" ) );
call    0 returned 1
        1: 1196:	fprintf( err, _( "\t-S  specify skeleton file\n" ) );
call    0 returned 1
        1: 1197:	fprintf( err, _( "\t--help     produce this help message\n" ) );
call    0 returned 1
        1: 1198:	fprintf( err, _( "\t--version  report %s version\n" ), program_name );
call    0 returned 1
        1: 1199:	}
        -: 1200:/* ccl - routines for character classes */
        -: 1201:
        -: 1202:/*-
        -: 1203: * Copyright (c) 1990 The Regents of the University of California.
        -: 1204: * All rights reserved.
        -: 1205: *
        -: 1206: * This code is derived from software contributed to Berkeley by
        -: 1207: * Vern Paxson.
        -: 1208: * 
        -: 1209: * The United States Government has rights in this work pursuant
        -: 1210: * to contract no. DE-AC03-76SF00098 between the United States
        -: 1211: * Department of Energy and the University of California.
        -: 1212: *
        -: 1213: * Redistribution and use in source and binary forms with or without
        -: 1214: * modification are permitted provided that: (1) source distributions retain
        -: 1215: * this entire copyright notice and comment, and (2) distributions including
        -: 1216: * binaries display the following acknowledgement:  ``This product includes
        -: 1217: * software developed by the University of California, Berkeley and its
        -: 1218: * contributors'' in the documentation or other materials provided with the
        -: 1219: * distribution and in all advertising materials mentioning features or use
        -: 1220: * of this software.  Neither the name of the University nor the names of
        -: 1221: * its contributors may be used to endorse or promote products derived from
        -: 1222: * this software without specific prior written permission.
        -: 1223: * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
        -: 1224: * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
        -: 1225: * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
        -: 1226: */
        -: 1227:
        -: 1228:/* $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.seeded/v5/flex.c,v 1.1.1.2 2003/09/02 20:22:00 expsir Exp $ */
        -: 1229:
        -: 1230:
        -: 1231:/* ccladd - add a single character to a ccl */
        -: 1232:
function ccladd called 25222 returned 100% blocks executed 100%
    25222: 1233:void ccladd( cclp, ch )
        -: 1234:int cclp;
        -: 1235:int ch;
        -: 1236:	{
        -: 1237:	int ind, len, newpos, i;
        -: 1238:
    25222: 1239:	check_char( ch );
call    0 returned 25222
        -: 1240:
    25222: 1241:	len = ccllen[cclp];
    25222: 1242:	ind = cclmap[cclp];
        -: 1243:
        -: 1244:	/* check to see if the character is already in the ccl */
        -: 1245:
   486630: 1246:	for ( i = 0; i < len; ++i )
branch  0 taken 461619
branch  1 taken 25011 (fallthrough)
   461619: 1247:		if ( ccltbl[ind + i] == ch )
branch  0 taken 211 (fallthrough)
branch  1 taken 461408
      211: 1248:			return;
        -: 1249:
    25011: 1250:	newpos = ind + len;
        -: 1251:
    25011: 1252:	if ( newpos >= current_max_ccl_tbl_size )
branch  0 taken 40 (fallthrough)
branch  1 taken 24971
        -: 1253:		{
       40: 1254:		current_max_ccl_tbl_size += MAX_CCL_TBL_SIZE_INCREMENT;
        -: 1255:
       40: 1256:		++num_reallocs;
        -: 1257:
       40: 1258:		ccltbl = reallocate_Character_array( ccltbl,
call    0 returned 40
        -: 1259:						current_max_ccl_tbl_size );
        -: 1260:		}
        -: 1261:
    25011: 1262:	ccllen[cclp] = len + 1;
    25011: 1263:	ccltbl[newpos] = ch;
        -: 1264:	}
        -: 1265:
        -: 1266:
        -: 1267:/* cclinit - return an empty ccl */
        -: 1268:
function cclinit called 2060 returned 100% blocks executed 100%
     2060: 1269:int cclinit()
        -: 1270:	{
     2060: 1271:	if ( ++lastccl >= current_maxccls )
branch  0 taken 2 (fallthrough)
branch  1 taken 2058
        -: 1272:		{
        2: 1273:		current_maxccls += MAX_CCLS_INCREMENT;
        -: 1274:
        2: 1275:		++num_reallocs;
        -: 1276:
        2: 1277:		cclmap = reallocate_integer_array( cclmap, current_maxccls );
call    0 returned 2
        2: 1278:		ccllen = reallocate_integer_array( ccllen, current_maxccls );
call    0 returned 2
        2: 1279:		cclng = reallocate_integer_array( cclng, current_maxccls );
call    0 returned 2
        -: 1280:		}
        -: 1281:
     2060: 1282:	if ( lastccl == 1 )
branch  0 taken 551 (fallthrough)
branch  1 taken 1509
        -: 1283:		/* we're making the first ccl */
      551: 1284:		cclmap[lastccl] = 0;
        -: 1285:
        -: 1286:	else
        -: 1287:		/* The new pointer is just past the end of the last ccl.
        -: 1288:		 * Since the cclmap points to the \first/ character of a
        -: 1289:		 * ccl, adding the length of the ccl to the cclmap pointer
        -: 1290:		 * will produce a cursor to the first free space.
        -: 1291:		 */
     1509: 1292:		cclmap[lastccl] = cclmap[lastccl - 1] + ccllen[lastccl - 1];
        -: 1293:
     2060: 1294:	ccllen[lastccl] = 0;
     2060: 1295:	cclng[lastccl] = 0;	/* ccl's start out life un-negated */
        -: 1296:
     2060: 1297:	return lastccl;
        -: 1298:	}
        -: 1299:
        -: 1300:
        -: 1301:/* cclnegate - negate the given ccl */
        -: 1302:
function cclnegate called 981 returned 100% blocks executed 100%
      981: 1303:void cclnegate( cclp )
        -: 1304:int cclp;
        -: 1305:	{
      981: 1306:	cclng[cclp] = 1;
      981: 1307:	}
        -: 1308:
        -: 1309:
        -: 1310:/* list_character_set - list the members of a set of characters in CCL form
        -: 1311: *
        -: 1312: * Writes to the given file a character-class representation of those
        -: 1313: * characters present in the given CCL.  A character is present if it
        -: 1314: * has a non-zero value in the cset array.
        -: 1315: */
        -: 1316:
function list_character_set called 8 returned 100% blocks executed 100%
        8: 1317:void list_character_set( file, cset )
        -: 1318:FILE *file;
        -: 1319:int cset[];
        -: 1320:	{
        -: 1321:	register int i;
        -: 1322:
        8: 1323:	putc( '[', file );
call    0 returned 8
        -: 1324:
      908: 1325:	for ( i = 0; i < csize; ++i )
branch  0 taken 900
branch  1 taken 8 (fallthrough)
        -: 1326:		{
      900: 1327:		if ( cset[i] )
branch  0 taken 12 (fallthrough)
branch  1 taken 888
        -: 1328:			{
       12: 1329:			register int start_char = i;
        -: 1330:
       12: 1331:			putc( ' ', file );
call    0 returned 12
        -: 1332:
       12: 1333:			fputs( readable_form( i ), file );
call    0 returned 12
call    1 returned 12
        -: 1334:
      896: 1335:			while ( ++i < csize && cset[i] )
branch  0 taken 892 (fallthrough)
branch  1 taken 4
branch  2 taken 884
branch  3 taken 8 (fallthrough)
        -: 1336:				;
        -: 1337:
       12: 1338:			if ( i - 1 > start_char )
branch  0 taken 8 (fallthrough)
branch  1 taken 4
        -: 1339:				/* this was a run */
        8: 1340:				fprintf( file, "-%s", readable_form( i - 1 ) );
call    0 returned 8
call    1 returned 8
        -: 1341:
       12: 1342:			putc( ' ', file );
call    0 returned 12
        -: 1343:			}
        -: 1344:		}
        -: 1345:
        8: 1346:	putc( ']', file );
call    0 returned 8
        8: 1347:	}
        -: 1348:/* dfa - DFA construction routines */
        -: 1349:
        -: 1350:/*-
        -: 1351: * Copyright (c) 1990 The Regents of the University of California.
        -: 1352: * All rights reserved.
        -: 1353: *
        -: 1354: * This code is derived from software contributed to Berkeley by
        -: 1355: * Vern Paxson.
        -: 1356: * 
        -: 1357: * The United States Government has rights in this work pursuant
        -: 1358: * to contract no. DE-AC03-76SF00098 between the United States
        -: 1359: * Department of Energy and the University of California.
        -: 1360: *
        -: 1361: * Redistribution and use in source and binary forms with or without
        -: 1362: * modification are permitted provided that: (1) source distributions retain
        -: 1363: * this entire copyright notice and comment, and (2) distributions including
        -: 1364: * binaries display the following acknowledgement:  ``This product includes
        -: 1365: * software developed by the University of California, Berkeley and its
        -: 1366: * contributors'' in the documentation or other materials provided with the
        -: 1367: * distribution and in all advertising materials mentioning features or use
        -: 1368: * of this software.  Neither the name of the University nor the names of
        -: 1369: * its contributors may be used to endorse or promote products derived from
        -: 1370: * this software without specific prior written permission.
        -: 1371: * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
        -: 1372: * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
        -: 1373: * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
        -: 1374: */
        -: 1375:
        -: 1376:/* $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.seeded/v5/flex.c,v 1.1.1.2 2003/09/02 20:22:00 expsir Exp $ */
        -: 1377:
        -: 1378:
        -: 1379:
        -: 1380:/* declare functions that have forward references */
        -: 1381:
        -: 1382:void dump_associated_rules PROTO((FILE*, int));
        -: 1383:void dump_transitions PROTO((FILE*, int[]));
        -: 1384:void sympartition PROTO((int[], int, int[], int[]));
        -: 1385:int symfollowset PROTO((int[], int, int, int[]));
        -: 1386:
        -: 1387:
        -: 1388:/* check_for_backing_up - check a DFA state for backing up
        -: 1389: *
        -: 1390: * synopsis
        -: 1391: *     void check_for_backing_up( int ds, int state[numecs] );
        -: 1392: *
        -: 1393: * ds is the number of the state to check and state[] is its out-transitions,
        -: 1394: * indexed by equivalence class.
        -: 1395: */
        -: 1396:
function check_for_backing_up called 12403 returned 100% blocks executed 100%
    12403: 1397:void check_for_backing_up( ds, state )
        -: 1398:int ds;
        -: 1399:int state[];
        -: 1400:	{
    12403: 1401:	if ( (reject && ! dfaacc[ds].dfaacc_set) ||
branch  0 taken 4663 (fallthrough)
branch  1 taken 7740
branch  2 taken 3907 (fallthrough)
branch  3 taken 756
    11647: 1402:	     (! reject && ! dfaacc[ds].dfaacc_state) )
branch  0 taken 7740 (fallthrough)
branch  1 taken 3907
branch  2 taken 1722 (fallthrough)
branch  3 taken 6018
        -: 1403:		{ /* state is non-accepting */
     2478: 1404:		++num_backing_up;
        -: 1405:
     2478: 1406:		if ( backing_up_report )
branch  0 taken 4 (fallthrough)
branch  1 taken 2474
        -: 1407:			{
        4: 1408:			fprintf( backing_up_file,
call    0 returned 4
        -: 1409:				_( "State #%d is non-accepting -\n" ), ds );
        -: 1410:
        -: 1411:			/* identify the state */
        4: 1412:			dump_associated_rules( backing_up_file, ds );
call    0 returned 4
        -: 1413:
        -: 1414:			/* Now identify it further using the out- and
        -: 1415:			 * jam-transitions.
        -: 1416:			 */
        4: 1417:			dump_transitions( backing_up_file, state );
call    0 returned 4
        -: 1418:
        4: 1419:			putc( '\n', backing_up_file );
call    0 returned 4
        -: 1420:			}
        -: 1421:		}
    12403: 1422:	}
        -: 1423:
        -: 1424:
        -: 1425:/* check_trailing_context - check to see if NFA state set constitutes
        -: 1426: *                          "dangerous" trailing context
        -: 1427: *
        -: 1428: * synopsis
        -: 1429: *    void check_trailing_context( int nfa_states[num_states+1], int num_states,
        -: 1430: *				int accset[nacc+1], int nacc );
        -: 1431: *
        -: 1432: * NOTES
        -: 1433: *  Trailing context is "dangerous" if both the head and the trailing
        -: 1434: *  part are of variable size \and/ there's a DFA state which contains
        -: 1435: *  both an accepting state for the head part of the rule and NFA states
        -: 1436: *  which occur after the beginning of the trailing context.
        -: 1437: *
        -: 1438: *  When such a rule is matched, it's impossible to tell if having been
        -: 1439: *  in the DFA state indicates the beginning of the trailing context or
        -: 1440: *  further-along scanning of the pattern.  In these cases, a warning
        -: 1441: *  message is issued.
        -: 1442: *
        -: 1443: *    nfa_states[1 .. num_states] is the list of NFA states in the DFA.
        -: 1444: *    accset[1 .. nacc] is the list of accepting numbers for the DFA state.
        -: 1445: */
        -: 1446:
function check_trailing_context called 446 returned 100% blocks executed 100%
      446: 1447:void check_trailing_context( nfa_states, num_states, accset, nacc )
        -: 1448:int *nfa_states, num_states;
        -: 1449:int *accset;
        -: 1450:int nacc;
        -: 1451:	{
        -: 1452:	register int i, j;
        -: 1453:
     1191: 1454:	for ( i = 1; i <= num_states; ++i )
branch  0 taken 778
branch  1 taken 413 (fallthrough)
        -: 1455:		{
      778: 1456:		int ns = nfa_states[i];
      778: 1457:		register int type = state_type[ns];
      778: 1458:		register int ar = assoc_rule[ns];
        -: 1459:
      778: 1460:		if ( type == STATE_NORMAL || rule_type[ar] != RULE_VARIABLE )
branch  0 taken 101 (fallthrough)
branch  1 taken 677
branch  2 taken 101 (fallthrough)
branch  3 taken 0
        -: 1461:			{ /* do nothing */
        -: 1462:			}
        -: 1463:
      101: 1464:		else if ( type == STATE_TRAILING_CONTEXT )
branch  0 taken 101 (fallthrough)
branch  1 taken 0
        -: 1465:			{
        -: 1466:			/* Potential trouble.  Scan set of accepting numbers
        -: 1467:			 * for the one marking the end of the "head".  We
        -: 1468:			 * assume that this looping will be fairly cheap
        -: 1469:			 * since it's rare that an accepting number set
        -: 1470:			 * is large.
        -: 1471:			 */
      202: 1472:			for ( j = 1; j <= nacc; ++j )
branch  0 taken 134
branch  1 taken 68 (fallthrough)
      134: 1473:				if ( accset[j] & YY_TRAILING_HEAD_MASK )
branch  0 taken 33 (fallthrough)
branch  1 taken 101
        -: 1474:					{
       33: 1475:					line_warning(
        -: 1476:					_( "dangerous trailing context" ),
       33: 1477:						rule_linenum[ar] );
call    0 returned 33
       33: 1478:					return;
        -: 1479:					}
        -: 1480:			}
        -: 1481:		}
        -: 1482:	}
        -: 1483:
        -: 1484:
        -: 1485:/* dump_associated_rules - list the rules associated with a DFA state
        -: 1486: *
        -: 1487: * Goes through the set of NFA states associated with the DFA and
        -: 1488: * extracts the first MAX_ASSOC_RULES unique rules, sorts them,
        -: 1489: * and writes a report to the given file.
        -: 1490: */
        -: 1491:
function dump_associated_rules called 4 returned 100% blocks executed 95%
        4: 1492:void dump_associated_rules( file, ds )
        -: 1493:FILE *file;
        -: 1494:int ds;
        -: 1495:	{
        -: 1496:	register int i, j;
        4: 1497:	register int num_associated_rules = 0;
        -: 1498:	int rule_set[MAX_ASSOC_RULES + 1];
        4: 1499:	int *dset = dss[ds];
        4: 1500:	int size = dfasiz[ds];
        -: 1501:
       16: 1502:	for ( i = 1; i <= size; ++i )
branch  0 taken 12
branch  1 taken 4 (fallthrough)
        -: 1503:		{
       12: 1504:		register int rule_num = rule_linenum[assoc_rule[dset[i]]];
        -: 1505:
      12*: 1506:		for ( j = 1; j <= num_associated_rules; ++j )
branch  0 taken 8
branch  1 taken 4 (fallthrough)
        8: 1507:			if ( rule_num == rule_set[j] )
branch  0 taken 8 (fallthrough)
branch  1 taken 0
        8: 1508:				break;
        -: 1509:
       12: 1510:		if ( j > num_associated_rules )
branch  0 taken 4 (fallthrough)
branch  1 taken 8
        -: 1511:			{ /* new rule */
        4: 1512:			if ( num_associated_rules < MAX_ASSOC_RULES )
branch  0 taken 4 (fallthrough)
branch  1 taken 0
        4: 1513:				rule_set[++num_associated_rules] = rule_num;
        -: 1514:			}
        -: 1515:		}
        -: 1516:
        4: 1517:	bubble( rule_set, num_associated_rules );
call    0 returned 4
        -: 1518:
        4: 1519:	fprintf( file, _( " associated rule line numbers:" ) );
call    0 returned 4
        -: 1520:
        8: 1521:	for ( i = 1; i <= num_associated_rules; ++i )
branch  0 taken 4
branch  1 taken 4 (fallthrough)
        -: 1522:		{
        4: 1523:		if ( i % 8 == 1 )
branch  0 taken 4 (fallthrough)
branch  1 taken 0
        4: 1524:			putc( '\n', file );
call    0 returned 4
        -: 1525:
        4: 1526:		fprintf( file, "\t%d", rule_set[i] );
call    0 returned 4
        -: 1527:		}
        -: 1528:
        4: 1529:	putc( '\n', file );
call    0 returned 4
        4: 1530:	}
        -: 1531:
        -: 1532:
        -: 1533:/* dump_transitions - list the transitions associated with a DFA state
        -: 1534: *
        -: 1535: * synopsis
        -: 1536: *     dump_transitions( FILE *file, int state[numecs] );
        -: 1537: *
        -: 1538: * Goes through the set of out-transitions and lists them in human-readable
        -: 1539: * form (i.e., not as equivalence classes); also lists jam transitions
        -: 1540: * (i.e., all those which are not out-transitions, plus EOF).  The dump
        -: 1541: * is done to the given file.
        -: 1542: */
        -: 1543:
function dump_transitions called 4 returned 100% blocks executed 100%
        4: 1544:void dump_transitions( file, state )
        -: 1545:FILE *file;
        -: 1546:int state[];
        -: 1547:	{
        -: 1548:	register int i, ec;
        -: 1549:	int out_char_set[CSIZE];
        -: 1550:
      900: 1551:	for ( i = 0; i < csize; ++i )
branch  0 taken 896
branch  1 taken 4 (fallthrough)
        -: 1552:		{
      896: 1553:		ec = ABS( ecgroup[i] );
      896: 1554:		out_char_set[i] = state[ec];
        -: 1555:		}
        -: 1556:
        4: 1557:	fprintf( file, _( " out-transitions: " ) );
call    0 returned 4
        -: 1558:
        4: 1559:	list_character_set( file, out_char_set );
call    0 returned 4
        -: 1560:
        -: 1561:	/* now invert the members of the set to get the jam transitions */
      900: 1562:	for ( i = 0; i < csize; ++i )
branch  0 taken 896
branch  1 taken 4 (fallthrough)
      896: 1563:		out_char_set[i] = ! out_char_set[i];
        -: 1564:
        4: 1565:	fprintf( file, _( "\n jam-transitions: EOF " ) );
call    0 returned 4
        -: 1566:
        4: 1567:	list_character_set( file, out_char_set );
call    0 returned 4
        -: 1568:
        4: 1569:	putc( '\n', file );
call    0 returned 4
        4: 1570:	}
        -: 1571:
        -: 1572:
        -: 1573:/* epsclosure - construct the epsilon closure of a set of ndfa states
        -: 1574: *
        -: 1575: * synopsis
        -: 1576: *    int *epsclosure( int t[num_states], int *numstates_addr,
        -: 1577: *			int accset[num_rules+1], int *nacc_addr,
        -: 1578: *			int *hashval_addr );
        -: 1579: *
        -: 1580: * NOTES
        -: 1581: *  The epsilon closure is the set of all states reachable by an arbitrary
        -: 1582: *  number of epsilon transitions, which themselves do not have epsilon
        -: 1583: *  transitions going out, unioned with the set of states which have non-null
        -: 1584: *  accepting numbers.  t is an array of size numstates of nfa state numbers.
        -: 1585: *  Upon return, t holds the epsilon closure and *numstates_addr is updated.
        -: 1586: *  accset holds a list of the accepting numbers, and the size of accset is
        -: 1587: *  given by *nacc_addr.  t may be subjected to reallocation if it is not
        -: 1588: *  large enough to hold the epsilon closure.
        -: 1589: *
        -: 1590: *  hashval is the hash value for the dfa corresponding to the state set.
        -: 1591: */
        -: 1592:
function epsclosure called 26774 returned 100% blocks executed 75%
    26774: 1593:int *epsclosure( t, ns_addr, accset, nacc_addr, hv_addr )
        -: 1594:int *t, *ns_addr, accset[], *nacc_addr, *hv_addr;
        -: 1595:	{
        -: 1596:	register int stkpos, ns, tsp;
    26774: 1597:	int numstates = *ns_addr, nacc, hashval, transsym, nfaccnum;
        -: 1598:	int stkend, nstate;
        -: 1599:	static int did_stk_init = false, *stk; 
        -: 1600:
        -: 1601:#define MARK_STATE(state) \
        -: 1602:trans1[state] = trans1[state] - MARKER_DIFFERENCE;
        -: 1603:
        -: 1604:#define IS_MARKED(state) (trans1[state] < 0)
        -: 1605:
        -: 1606:#define UNMARK_STATE(state) \
        -: 1607:trans1[state] = trans1[state] + MARKER_DIFFERENCE;
        -: 1608:
        -: 1609:#define CHECK_ACCEPT(state) \
        -: 1610:{ \
        -: 1611:nfaccnum = accptnum[state]; \
        -: 1612:if ( nfaccnum != NIL ) \
        -: 1613:accset[++nacc] = nfaccnum; \
        -: 1614:}
        -: 1615:
        -: 1616:#define DO_REALLOCATION \
        -: 1617:{ \
        -: 1618:current_max_dfa_size += MAX_DFA_SIZE_INCREMENT; \
        -: 1619:++num_reallocs; \
        -: 1620:t = reallocate_integer_array( t, current_max_dfa_size ); \
        -: 1621:stk = reallocate_integer_array( stk, current_max_dfa_size ); \
        -: 1622:} \
        -: 1623:
        -: 1624:#define PUT_ON_STACK(state) \
        -: 1625:{ \
        -: 1626:if ( ++stkend >= current_max_dfa_size ) \
        -: 1627:DO_REALLOCATION \
        -: 1628:stk[stkend] = state; \
        -: 1629:MARK_STATE(state) \
        -: 1630:}
        -: 1631:
        -: 1632:#define ADD_STATE(state) \
        -: 1633:{ \
        -: 1634:if ( ++numstates >= current_max_dfa_size ) \
        -: 1635:DO_REALLOCATION \
        -: 1636:t[numstates] = state; \
        -: 1637:hashval += state; \
        -: 1638:}
        -: 1639:
        -: 1640:#define STACK_STATE(state) \
        -: 1641:{ \
        -: 1642:PUT_ON_STACK(state) \
        -: 1643:CHECK_ACCEPT(state) \
        -: 1644:if ( nfaccnum != NIL || transchar[state] != SYM_EPSILON ) \
        -: 1645:ADD_STATE(state) \
        -: 1646:}
        -: 1647:
        -: 1648:
    26774: 1649:	if ( ! did_stk_init )
branch  0 taken 543 (fallthrough)
branch  1 taken 26231
        -: 1650:		{
      543: 1651:		stk = allocate_integer_array( current_max_dfa_size );
call    0 returned 543
      543: 1652:		did_stk_init = true;
        -: 1653:		}
        -: 1654:
    26774: 1655:	nacc = stkend = hashval = 0;
        -: 1656:
    83883: 1657:	for ( nstate = 1; nstate <= numstates; ++nstate )
branch  0 taken 57109
branch  1 taken 26774 (fallthrough)
        -: 1658:		{
    57109: 1659:		ns = t[nstate];
        -: 1660:
        -: 1661:		/* The state could be marked if we've already pushed it onto
        -: 1662:		 * the stack.
        -: 1663:		 */
    57109: 1664:		if ( ! IS_MARKED(ns) )
branch  0 taken 57109 (fallthrough)
branch  1 taken 0
        -: 1665:			{
   57109*: 1666:			PUT_ON_STACK(ns)
branch  0 taken 0 (fallthrough)
branch  1 taken 57109
call    2 never executed
call    3 never executed
    57109: 1667:			CHECK_ACCEPT(ns)
branch  0 taken 31638 (fallthrough)
branch  1 taken 25471
    57109: 1668:			hashval += ns;
        -: 1669:			}
        -: 1670:		}
        -: 1671:
   151870: 1672:	for ( stkpos = 1; stkpos <= stkend; ++stkpos )
branch  0 taken 125096
branch  1 taken 26774 (fallthrough)
        -: 1673:		{
   125096: 1674:		ns = stk[stkpos];
   125096: 1675:		transsym = transchar[ns];
        -: 1676:
   125096: 1677:		if ( transsym == SYM_EPSILON )
branch  0 taken 77165 (fallthrough)
branch  1 taken 47931
        -: 1678:			{
    77165: 1679:			tsp = trans1[ns] + MARKER_DIFFERENCE;
        -: 1680:
    77165: 1681:			if ( tsp != NO_TRANSITION )
branch  0 taken 42528 (fallthrough)
branch  1 taken 34637
        -: 1682:				{
    42528: 1683:				if ( ! IS_MARKED(tsp) )
branch  0 taken 42528 (fallthrough)
branch  1 taken 0
   42528*: 1684:					STACK_STATE(tsp)
branch  0 taken 1 (fallthrough)
branch  1 taken 42527
call    2 returned 1
call    3 returned 1
branch  4 taken 0 (fallthrough)
branch  5 taken 42528
branch  6 taken 42528 (fallthrough)
branch  7 taken 0
branch  8 taken 31562 (fallthrough)
branch  9 taken 10966
branch 10 taken 0 (fallthrough)
branch 11 taken 31562
call   12 never executed
call   13 never executed
        -: 1685:
    42528: 1686:				tsp = trans2[ns];
        -: 1687:
    42528: 1688:				if ( tsp != NO_TRANSITION && ! IS_MARKED(tsp) )
branch  0 taken 25460 (fallthrough)
branch  1 taken 17068
branch  2 taken 25459 (fallthrough)
branch  3 taken 1
   25459*: 1689:					STACK_STATE(tsp)
branch  0 taken 0 (fallthrough)
branch  1 taken 25459
call    2 never executed
call    3 never executed
branch  4 taken 12895 (fallthrough)
branch  5 taken 12564
branch  6 taken 12564 (fallthrough)
branch  7 taken 12895
branch  8 taken 7016 (fallthrough)
branch  9 taken 5548
branch 10 taken 0 (fallthrough)
branch 11 taken 19911
call   12 never executed
call   13 never executed
        -: 1690:				}
        -: 1691:			}
        -: 1692:		}
        -: 1693:
        -: 1694:	/* Clear out "visit" markers. */
        -: 1695:
   151870: 1696:	for ( stkpos = 1; stkpos <= stkend; ++stkpos )
branch  0 taken 125096
branch  1 taken 26774 (fallthrough)
        -: 1697:		{
   125096: 1698:		if ( IS_MARKED(stk[stkpos]) )
branch  0 taken 125096 (fallthrough)
branch  1 taken 0
   125096: 1699:			UNMARK_STATE(stk[stkpos])
        -: 1700:		else
    #####: 1701:			flexfatal(
call    0 never executed
        -: 1702:			_( "consistency check failed in epsclosure()" ) );
        -: 1703:		}
        -: 1704:
    26774: 1705:	*ns_addr = numstates;
    26774: 1706:	*hv_addr = hashval;
    26774: 1707:	*nacc_addr = nacc;
        -: 1708:
    26774: 1709:	return t;
        -: 1710:	}
        -: 1711:
        -: 1712:
        -: 1713:/* increase_max_dfas - increase the maximum number of DFAs */
        -: 1714:
function increase_max_dfas called 1 returned 100% blocks executed 82%
        1: 1715:void increase_max_dfas()
        -: 1716:	{
        1: 1717:	current_max_dfas += MAX_DFAS_INCREMENT;
        -: 1718:
        1: 1719:	++num_reallocs;
        -: 1720:
        1: 1721:	base = reallocate_integer_array( base, current_max_dfas );
call    0 returned 1
        1: 1722:	def = reallocate_integer_array( def, current_max_dfas );
call    0 returned 1
        1: 1723:	dfasiz = reallocate_integer_array( dfasiz, current_max_dfas );
call    0 returned 1
        1: 1724:	accsiz = reallocate_integer_array( accsiz, current_max_dfas );
call    0 returned 1
        1: 1725:	dhash = reallocate_integer_array( dhash, current_max_dfas );
call    0 returned 1
        1: 1726:	dss = reallocate_int_ptr_array( dss, current_max_dfas );
call    0 returned 1
        1: 1727:	dfaacc = reallocate_dfaacc_union( dfaacc, current_max_dfas );
call    0 returned 1
        -: 1728:
        1: 1729:	if ( nultrans )
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 1730:		nultrans =
    #####: 1731:			reallocate_integer_array( nultrans, current_max_dfas );
call    0 never executed
        1: 1732:	}
        -: 1733:
        -: 1734:
        -: 1735:/* ntod - convert an ndfa to a dfa
        -: 1736: *
        -: 1737: * Creates the dfa corresponding to the ndfa we've constructed.  The
        -: 1738: * dfa starts out in state #1.
        -: 1739: */
        -: 1740:
function ntod called 543 returned 100% blocks executed 88%
      543: 1741:void ntod()
        -: 1742:	{
        -: 1743:	int *accset, ds, nacc, newds;
        -: 1744:	int sym, hashval, numstates, dsize;
        -: 1745:	int num_full_table_rows;	/* used only for -f */
        -: 1746:	int *nset, *dset;
        -: 1747:	int targptr, totaltrans, i, comstate, comfreq, targ;
        -: 1748:	int symlist[CSIZE + 1];
        -: 1749:	int num_start_states;
        -: 1750:	int todo_head, todo_next;
        -: 1751:
        -: 1752:	/* Note that the following are indexed by *equivalence classes*
        -: 1753:	 * and not by characters.  Since equivalence classes are indexed
        -: 1754:	 * beginning with 1, even if the scanner accepts NUL's, this
        -: 1755:	 * means that (since every character is potentially in its own
        -: 1756:	 * equivalence class) these arrays must have room for indices
        -: 1757:	 * from 1 to CSIZE, so their size must be CSIZE + 1.
        -: 1758:	 */
        -: 1759:	int duplist[CSIZE + 1], state[CSIZE + 1];
        -: 1760:	int targfreq[CSIZE + 1], targstate[CSIZE + 1];
        -: 1761:
      543: 1762:	accset = allocate_integer_array( num_rules + 1 );
call    0 returned 543
      543: 1763:	nset = allocate_integer_array( current_max_dfa_size );
call    0 returned 543
        -: 1764:
        -: 1765:	/* The "todo" queue is represented by the head, which is the DFA
        -: 1766:	 * state currently being processed, and the "next", which is the
        -: 1767:	 * next DFA state number available (not in use).  We depend on the
        -: 1768:	 * fact that snstods() returns DFA's \in increasing order/, and thus
        -: 1769:	 * need only know the bounds of the dfas to be processed.
        -: 1770:	 */
      543: 1771:	todo_head = todo_next = 0;
        -: 1772:
   130366: 1773:	for ( i = 0; i <= csize; ++i )
branch  0 taken 129823
branch  1 taken 543 (fallthrough)
        -: 1774:		{
   129823: 1775:		duplist[i] = NIL;
   129823: 1776:		symlist[i] = false;
        -: 1777:		}
        -: 1778:
     4903: 1779:	for ( i = 0; i <= num_rules; ++i )
branch  0 taken 4360
branch  1 taken 543 (fallthrough)
     4360: 1780:		accset[i] = NIL;
        -: 1781:
      543: 1782:	if ( trace )
branch  0 taken 14 (fallthrough)
branch  1 taken 529
        -: 1783:		{
       14: 1784:		dumpnfa( scset[1] );
call    0 returned 14
       14: 1785:		fputs( _( "\n\nDFA Dump:\n\n" ), err );
call    0 returned 14
        -: 1786:		}
        -: 1787:
      543: 1788:	inittbl();
call    0 returned 543
        -: 1789:
        -: 1790:	/* Check to see whether we should build a separate table for
        -: 1791:	 * transitions on NUL characters.  We don't do this for full-speed
        -: 1792:	 * (-F) scanners, since for them we don't have a simple state
        -: 1793:	 * number lying around with which to index the table.  We also
        -: 1794:	 * don't bother doing it for scanners unless (1) NUL is in its own
        -: 1795:	 * equivalence class (indicated by a positive value of
        -: 1796:	 * ecgroup[NUL]), (2) NUL's equivalence class is the last
        -: 1797:	 * equivalence class, and (3) the number of equivalence classes is
        -: 1798:	 * the same as the number of characters.  This latter case comes
        -: 1799:	 * about when useecs is false or when it's true but every character
        -: 1800:	 * still manages to land in its own class (unlikely, but it's
        -: 1801:	 * cheap to check for).  If all these things are true then the
        -: 1802:	 * character code needed to represent NUL's equivalence class for
        -: 1803:	 * indexing the tables is going to take one more bit than the
        -: 1804:	 * number of characters, and therefore we won't be assured of
        -: 1805:	 * being able to fit it into a YY_CHAR variable.  This rules out
        -: 1806:	 * storing the transitions in a compressed table, since the code
        -: 1807:	 * for interpreting them uses a YY_CHAR variable (perhaps it
        -: 1808:	 * should just use an integer, though; this is worth pondering ...
        -: 1809:	 * ###).
        -: 1810:	 *
        -: 1811:	 * Finally, for full tables, we want the number of entries in the
        -: 1812:	 * table to be a power of two so the array references go fast (it
        -: 1813:	 * will just take a shift to compute the major index).  If
        -: 1814:	 * encoding NUL's transitions in the table will spoil this, we
        -: 1815:	 * give it its own table (note that this will be the case if we're
        -: 1816:	 * not using equivalence classes).
        -: 1817:	 */
        -: 1818:
        -: 1819:	/* Note that the test for ecgroup[0] == numecs below accomplishes
        -: 1820:	 * both (1) and (2) above
        -: 1821:	 */
      543: 1822:	if ( ! fullspd && ecgroup[0] == numecs )
branch  0 taken 451 (fallthrough)
branch  1 taken 92
branch  2 taken 197 (fallthrough)
branch  3 taken 254
        -: 1823:		{
        -: 1824:		/* NUL is alone in its equivalence class, which is the
        -: 1825:		 * last one.
        -: 1826:		 */
      197: 1827:		int use_NUL_table = (numecs == csize);
        -: 1828:
      197: 1829:		if ( fulltbl && ! use_NUL_table )
branch  0 taken 22 (fallthrough)
branch  1 taken 175
branch  2 taken 0 (fallthrough)
branch  3 taken 22
        -: 1830:			{
        -: 1831:			/* We still may want to use the table if numecs
        -: 1832:			 * is a power of 2.
        -: 1833:			 */
        -: 1834:			int power_of_two;
        -: 1835:
    #####: 1836:			for ( power_of_two = 1; power_of_two <= csize;
branch  0 never executed
branch  1 never executed
    #####: 1837:			      power_of_two *= 2 )
    #####: 1838:				if ( numecs == power_of_two )
branch  0 never executed
branch  1 never executed
        -: 1839:					{
    #####: 1840:					use_NUL_table = true;
    #####: 1841:					break;
        -: 1842:					}
        -: 1843:			}
        -: 1844:
      197: 1845:		if ( use_NUL_table )
branch  0 taken 195 (fallthrough)
branch  1 taken 2
      195: 1846:			nultrans = allocate_integer_array( current_max_dfas );
call    0 returned 195
        -: 1847:
        -: 1848:		/* From now on, nultrans != nil indicates that we're
        -: 1849:		 * saving null transitions for later, separate encoding.
        -: 1850:		 */
        -: 1851:		}
        -: 1852:
        -: 1853:
      543: 1854:	if ( fullspd )
branch  0 taken 92 (fallthrough)
branch  1 taken 451
        -: 1855:		{
     7416: 1856:		for ( i = 0; i <= numecs; ++i )
branch  0 taken 7324
branch  1 taken 92 (fallthrough)
     7324: 1857:			state[i] = 0;
        -: 1858:
       92: 1859:		place_state( state, 0, 0 );
call    0 returned 92
       92: 1860:		dfaacc[0].dfaacc_state = 0;
        -: 1861:		}
        -: 1862:
      451: 1863:	else if ( fulltbl )
branch  0 taken 23 (fallthrough)
branch  1 taken 428
        -: 1864:		{
       23: 1865:		if ( nultrans )
branch  0 taken 22 (fallthrough)
branch  1 taken 1
        -: 1866:			/* We won't be including NUL's transitions in the
        -: 1867:			 * table, so build it for entries from 0 .. numecs - 1.
        -: 1868:			 */
       22: 1869:			num_full_table_rows = numecs;
        -: 1870:
        -: 1871:		else
        -: 1872:			/* Take into account the fact that we'll be including
        -: 1873:			 * the NUL entries in the transition table.  Build it
        -: 1874:			 * from 0 .. numecs.
        -: 1875:			 */
        1: 1876:			num_full_table_rows = numecs + 1;
        -: 1877:
        -: 1878:		/* Unless -Ca, declare it "short" because it's a real
        -: 1879:		 * long-shot that that won't be large enough.
        -: 1880:		 */
      23*: 1881:		out_str_dec( "static yyconst %s yy_nxt[][%d] =\n    {\n",
call    0 returned 23
        -: 1882:			/* '}' so vi doesn't get too confused */
       23: 1883:			long_align ? "long" : "short", num_full_table_rows );
branch  0 taken 0 (fallthrough)
branch  1 taken 23
        -: 1884:
       23: 1885:		outn( "    {" );
call    0 returned 23
        -: 1886:
        -: 1887:		/* Generate 0 entries for state #0. */
     2851: 1888:		for ( i = 0; i < num_full_table_rows; ++i )
branch  0 taken 2828
branch  1 taken 23 (fallthrough)
     2828: 1889:			mk2data( 0 );
call    0 returned 2828
        -: 1890:
       23: 1891:		dataflush();
call    0 returned 23
       23: 1892:		outn( "    },\n" );
call    0 returned 23
        -: 1893:		}
        -: 1894:
        -: 1895:	/* Create the first states. */
        -: 1896:
      543: 1897:	num_start_states = lastsc * 2;
        -: 1898:
     1667: 1899:	for ( i = 1; i <= num_start_states; ++i )
branch  0 taken 1124
branch  1 taken 543 (fallthrough)
        -: 1900:		{
     1124: 1901:		numstates = 1;
        -: 1902:
        -: 1903:		/* For each start condition, make one state for the case when
        -: 1904:		 * we're at the beginning of the line (the '^' operator) and
        -: 1905:		 * one for the case when we're not.
        -: 1906:		 */
     1124: 1907:		if ( i % 2 == 1 )
branch  0 taken 562 (fallthrough)
branch  1 taken 562
      562: 1908:			nset[numstates] = scset[(i / 2) + 1];
        -: 1909:		else
      562: 1910:			nset[numstates] =
      562: 1911:				mkbranch( scbol[i / 2], scset[i / 2] );
call    0 returned 562
        -: 1912:
     1124: 1913:		nset = epsclosure( nset, &numstates, accset, &nacc, &hashval );
call    0 returned 1124
        -: 1914:
     1124: 1915:		if ( snstods( nset, numstates, accset, nacc, hashval, &ds ) )
call    0 returned 1124
branch  1 taken 1124 (fallthrough)
branch  2 taken 0
        -: 1916:			{
     1124: 1917:			numas += nacc;
     1124: 1918:			totnst += numstates;
     1124: 1919:			++todo_next;
        -: 1920:
     1124: 1921:			if ( variable_trailing_context_rules && nacc > 0 )
branch  0 taken 66 (fallthrough)
branch  1 taken 1058
branch  2 taken 0 (fallthrough)
branch  3 taken 66
    #####: 1922:				check_trailing_context( nset, numstates,
call    0 never executed
        -: 1923:							accset, nacc );
        -: 1924:			}
        -: 1925:		}
        -: 1926:
      543: 1927:	if ( ! fullspd )
branch  0 taken 451 (fallthrough)
branch  1 taken 92
        -: 1928:		{
      451: 1929:		if ( ! snstods( nset, 0, accset, 0, 0, &end_of_buffer_state ) )
call    0 returned 451
branch  1 taken 0 (fallthrough)
branch  2 taken 451
    #####: 1930:			flexfatal(
call    0 never executed
        -: 1931:			_( "could not create unique end-of-buffer state" ) );
        -: 1932:
      451: 1933:		++numas;
      451: 1934:		++num_start_states;
      451: 1935:		++todo_next;
        -: 1936:		}
        -: 1937:
    14521: 1938:	while ( todo_head < todo_next )
branch  0 taken 13978
branch  1 taken 543 (fallthrough)
        -: 1939:		{
    13978: 1940:		targptr = 0;
    13978: 1941:		totaltrans = 0;
        -: 1942:
  1490169: 1943:		for ( i = 1; i <= numecs; ++i )
branch  0 taken 1476191
branch  1 taken 13978 (fallthrough)
  1476191: 1944:			state[i] = 0;
        -: 1945:
    13978: 1946:		ds = ++todo_head;
        -: 1947:
    13978: 1948:		dset = dss[ds];
    13978: 1949:		dsize = dfasiz[ds];
        -: 1950:
    13978: 1951:		if ( trace )
branch  0 taken 1396 (fallthrough)
branch  1 taken 12582
     1396: 1952:			fprintf( err, _( "state # %d:\n" ), ds );
call    0 returned 1396
        -: 1953:
    13978: 1954:		sympartition( dset, dsize, symlist, duplist );
call    0 returned 13978
        -: 1955:
  1490169: 1956:		for ( sym = 1; sym <= numecs; ++sym )
branch  0 taken 1476191
branch  1 taken 13978 (fallthrough)
        -: 1957:			{
  1476191: 1958:			if ( symlist[sym] )
branch  0 taken 286139 (fallthrough)
branch  1 taken 1190052
        -: 1959:				{
   286139: 1960:				symlist[sym] = 0;
        -: 1961:
   286139: 1962:				if ( duplist[sym] == NIL )
branch  0 taken 25650 (fallthrough)
branch  1 taken 260489
        -: 1963:					{
        -: 1964:					/* Symbol has unique out-transitions. */
    25650: 1965:					numstates = symfollowset( dset, dsize,
call    0 returned 25650
        -: 1966:								sym, nset );
    25650: 1967:					nset = epsclosure( nset, &numstates,
call    0 returned 25650
        -: 1968:						accset, &nacc, &hashval );
        -: 1969:
    25650: 1970:					if ( snstods( nset, numstates, accset,
call    0 returned 25650
branch  1 taken 12403 (fallthrough)
branch  2 taken 13247
        -: 1971:						nacc, hashval, &newds ) )
        -: 1972:						{
    12403: 1973:						totnst = totnst + numstates;
    12403: 1974:						++todo_next;
    12403: 1975:						numas += nacc;
        -: 1976:
    12403: 1977:						if (
    12403: 1978:					variable_trailing_context_rules &&
branch  0 taken 696 (fallthrough)
branch  1 taken 11707
      696: 1979:							nacc > 0 )
branch  0 taken 446 (fallthrough)
branch  1 taken 250
      446: 1980:							check_trailing_context(
call    0 returned 446
        -: 1981:								nset, numstates,
        -: 1982:								accset, nacc );
        -: 1983:						}
        -: 1984:
    25650: 1985:					state[sym] = newds;
        -: 1986:
    25650: 1987:					if ( trace )
branch  0 taken 4878 (fallthrough)
branch  1 taken 20772
     4878: 1988:						fprintf( err, "\t%d\t%d\n",
call    0 returned 4878
        -: 1989:							sym, newds );
        -: 1990:
    25650: 1991:					targfreq[++targptr] = 1;
    25650: 1992:					targstate[targptr] = newds;
    25650: 1993:					++numuniq;
        -: 1994:					}
        -: 1995:
        -: 1996:				else
        -: 1997:					{
        -: 1998:					/* sym's equivalence class has the same
        -: 1999:					 * transitions as duplist(sym)'s
        -: 2000:					 * equivalence class.
        -: 2001:					 */
   260489: 2002:					targ = state[duplist[sym]];
   260489: 2003:					state[sym] = targ;
        -: 2004:
   260489: 2005:					if ( trace )
branch  0 taken 57113 (fallthrough)
branch  1 taken 203376
    57113: 2006:						fprintf( err, "\t%d\t%d\n",
call    0 returned 57113
        -: 2007:							sym, targ );
        -: 2008:
        -: 2009:					/* Update frequency count for
        -: 2010:					 * destination state.
        -: 2011:					 */
        -: 2012:
   260489: 2013:					i = 0;
   355053: 2014:					while ( targstate[++i] != targ )
branch  0 taken 94564
branch  1 taken 260489 (fallthrough)
        -: 2015:						;
        -: 2016:
   260489: 2017:					++targfreq[i];
   260489: 2018:					++numdup;
        -: 2019:					}
        -: 2020:
   286139: 2021:				++totaltrans;
   286139: 2022:				duplist[sym] = NIL;
        -: 2023:				}
        -: 2024:			}
        -: 2025:
    13978: 2026:		if ( caseins && ! useecs )
branch  0 taken 106 (fallthrough)
branch  1 taken 13872
branch  2 taken 0 (fallthrough)
branch  3 taken 106
        -: 2027:			{
        -: 2028:			register int j;
        -: 2029:
    #####: 2030:			for ( i = 'A', j = 'a'; i <= 'Z'; ++i, ++j )
branch  0 never executed
branch  1 never executed
        -: 2031:				{
    #####: 2032:				if ( state[i] == 0 && state[j] != 0 )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2033:					/* We're adding a transition. */
    #####: 2034:					++totaltrans;
        -: 2035:
    #####: 2036:				else if ( state[i] != 0 && state[j] == 0 )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2037:					/* We're taking away a transition. */
    #####: 2038:					--totaltrans;
        -: 2039:
    #####: 2040:				state[i] = state[j];
        -: 2041:				}
        -: 2042:			}
        -: 2043:
    13978: 2044:		numsnpairs += totaltrans;
        -: 2045:
    13978: 2046:		if ( ds > num_start_states )
branch  0 taken 12403 (fallthrough)
branch  1 taken 1575
    12403: 2047:			check_for_backing_up( ds, state );
call    0 returned 12403
        -: 2048:
    13978: 2049:		if ( nultrans )
branch  0 taken 4704 (fallthrough)
branch  1 taken 9274
        -: 2050:			{
     4704: 2051:			nultrans[ds] = state[NUL_ec];
     4704: 2052:			state[NUL_ec] = 0;	/* remove transition */
        -: 2053:			}
        -: 2054:
    13978: 2055:		if ( fulltbl )
branch  0 taken 542 (fallthrough)
branch  1 taken 13436
        -: 2056:			{
      542: 2057:			outn( "    {" );
call    0 returned 542
        -: 2058:
        -: 2059:			/* Supply array's 0-element. */
      542: 2060:			if ( ds == end_of_buffer_state )
branch  0 taken 23 (fallthrough)
branch  1 taken 519
       23: 2061:				mk2data( -end_of_buffer_state );
call    0 returned 23
        -: 2062:			else
      519: 2063:				mk2data( end_of_buffer_state );
call    0 returned 519
        -: 2064:
    67288: 2065:			for ( i = 1; i < num_full_table_rows; ++i )
branch  0 taken 66746
branch  1 taken 542 (fallthrough)
        -: 2066:				/* Jams are marked by negative of state
        -: 2067:				 * number.
        -: 2068:				 */
    66746: 2069:				mk2data( state[i] ? state[i] : -ds );
branch  0 taken 11603 (fallthrough)
branch  1 taken 55143
call    2 returned 66746
        -: 2070:
      542: 2071:			dataflush();
call    0 returned 542
      542: 2072:			outn( "    },\n" );
call    0 returned 542
        -: 2073:			}
        -: 2074:
    13436: 2075:		else if ( fullspd )
branch  0 taken 2170 (fallthrough)
branch  1 taken 11266
     2170: 2076:			place_state( state, ds, totaltrans );
call    0 returned 2170
        -: 2077:
    11266: 2078:		else if ( ds == end_of_buffer_state )
branch  0 taken 428 (fallthrough)
branch  1 taken 10838
        -: 2079:			/* Special case this state to make sure it does what
        -: 2080:			 * it's supposed to, i.e., jam on end-of-buffer.
        -: 2081:			 */
      428: 2082:			stack1( ds, 0, 0, JAMSTATE );
call    0 returned 428
        -: 2083:
        -: 2084:		else /* normal, compressed state */
        -: 2085:			{
        -: 2086:			/* Determine which destination state is the most
        -: 2087:			 * common, and how many transitions to it there are.
        -: 2088:			 */
        -: 2089:
    10838: 2090:			comfreq = 0;
    10838: 2091:			comstate = 0;
        -: 2092:
    31916: 2093:			for ( i = 1; i <= targptr; ++i )
branch  0 taken 21078
branch  1 taken 10838 (fallthrough)
    21078: 2094:				if ( targfreq[i] > comfreq )
branch  0 taken 9139 (fallthrough)
branch  1 taken 11939
        -: 2095:					{
     9139: 2096:					comfreq = targfreq[i];
     9139: 2097:					comstate = targstate[i];
        -: 2098:					}
        -: 2099:
    10838: 2100:			bldtbl( state, ds, totaltrans, comstate, comfreq );
call    0 returned 10838
        -: 2101:			}
        -: 2102:		}
        -: 2103:
      543: 2104:	if ( fulltbl )
branch  0 taken 23 (fallthrough)
branch  1 taken 520
       23: 2105:		dataend();
call    0 returned 23
        -: 2106:
      520: 2107:	else if ( ! fullspd )
branch  0 taken 428 (fallthrough)
branch  1 taken 92
        -: 2108:		{
      428: 2109:		cmptmps();  /* create compressed template entries */
call    0 returned 428
        -: 2110:
        -: 2111:		/* Create tables for all the states with only one
        -: 2112:		 * out-transition.
        -: 2113:		 */
     6135: 2114:		while ( onesp > 0 )
branch  0 taken 5707
branch  1 taken 428 (fallthrough)
        -: 2115:			{
     5707: 2116:			mk1tbl( onestate[onesp], onesym[onesp], onenext[onesp],
call    0 returned 5707
        -: 2117:			onedef[onesp] );
     5707: 2118:			--onesp;
        -: 2119:			}
        -: 2120:
      428: 2121:		mkdeftbl();
call    0 returned 428
        -: 2122:		}
        -: 2123:
      543: 2124:	flex_free( (void *) accset );
call    0 returned 543
      543: 2125:	flex_free( (void *) nset );
call    0 returned 543
      543: 2126:	}
        -: 2127:
        -: 2128:
        -: 2129:/* snstods - converts a set of ndfa states into a dfa state
        -: 2130: *
        -: 2131: * synopsis
        -: 2132: *    is_new_state = snstods( int sns[numstates], int numstates,
        -: 2133: *				int accset[num_rules+1], int nacc,
        -: 2134: *				int hashval, int *newds_addr );
        -: 2135: *
        -: 2136: * On return, the dfa state number is in newds.
        -: 2137: */
        -: 2138:
function snstods called 27225 returned 100% blocks executed 100%
    27225: 2139:int snstods( sns, numstates, accset, nacc, hashval, newds_addr )
        -: 2140:int sns[], numstates, accset[], nacc, hashval, *newds_addr;
        -: 2141:	{
    27225: 2142:	int didsort = 0;
        -: 2143:	register int i, j;
        -: 2144:	int newds, *oldsns;
        -: 2145:
  1249498: 2146:	for ( i = 1; i <= lastdfa; ++i )
branch  0 taken 1235520
branch  1 taken 13978 (fallthrough)
  1235520: 2147:		if ( hashval == dhash[i] )
branch  0 taken 13393 (fallthrough)
branch  1 taken 1222127
        -: 2148:			{
    13393: 2149:			if ( numstates == dfasiz[i] )
branch  0 taken 13251 (fallthrough)
branch  1 taken 142
        -: 2150:				{
    13251: 2151:				oldsns = dss[i];
        -: 2152:
    13251: 2153:				if ( ! didsort )
branch  0 taken 13251 (fallthrough)
branch  1 taken 0
        -: 2154:					{
        -: 2155:					/* We sort the states in sns so we
        -: 2156:					 * can compare it to oldsns quickly.
        -: 2157:					 * We use bubble because there probably
        -: 2158:					 * aren't very many states.
        -: 2159:					 */
    13251: 2160:					bubble( sns, numstates );
call    0 returned 13251
    13251: 2161:					didsort = 1;
        -: 2162:					}
        -: 2163:
    64633: 2164:				for ( j = 1; j <= numstates; ++j )
branch  0 taken 51386
branch  1 taken 13247 (fallthrough)
    51386: 2165:					if ( sns[j] != oldsns[j] )
branch  0 taken 4 (fallthrough)
branch  1 taken 51382
        4: 2166:						break;
        -: 2167:
    13251: 2168:				if ( j > numstates )
branch  0 taken 13247 (fallthrough)
branch  1 taken 4
        -: 2169:					{
    13247: 2170:					++dfaeql;
    13247: 2171:					*newds_addr = i;
    13247: 2172:					return 0;
        -: 2173:					}
        -: 2174:
        4: 2175:				++hshcol;
        -: 2176:				}
        -: 2177:
        -: 2178:			else
      142: 2179:				++hshsave;
        -: 2180:			}
        -: 2181:
        -: 2182:	/* Make a new dfa. */
        -: 2183:
    13978: 2184:	if ( ++lastdfa >= current_max_dfas )
branch  0 taken 1 (fallthrough)
branch  1 taken 13977
        1: 2185:		increase_max_dfas();
call    0 returned 1
        -: 2186:
    13978: 2187:	newds = lastdfa;
        -: 2188:
    13978: 2189:	dss[newds] = allocate_integer_array( numstates + 1 );
call    0 returned 13978
        -: 2190:
        -: 2191:	/* If we haven't already sorted the states in sns, we do so now,
        -: 2192:	 * so that future comparisons with it can be made quickly.
        -: 2193:	 */
        -: 2194:
    13978: 2195:	if ( ! didsort )
branch  0 taken 13974 (fallthrough)
branch  1 taken 4
    13974: 2196:		bubble( sns, numstates );
call    0 returned 13974
        -: 2197:
    71196: 2198:	for ( i = 1; i <= numstates; ++i )
branch  0 taken 57218
branch  1 taken 13978 (fallthrough)
    57218: 2199:		dss[newds][i] = sns[i];
        -: 2200:
    13978: 2201:	dfasiz[newds] = numstates;
    13978: 2202:	dhash[newds] = hashval;
        -: 2203:
    13978: 2204:	if ( nacc == 0 )
branch  0 taken 3635 (fallthrough)
branch  1 taken 10343
        -: 2205:		{
     3635: 2206:		if ( reject )
branch  0 taken 1138 (fallthrough)
branch  1 taken 2497
     1138: 2207:			dfaacc[newds].dfaacc_set = (int *) 0;
        -: 2208:		else
     2497: 2209:			dfaacc[newds].dfaacc_state = 0;
        -: 2210:
     3635: 2211:		accsiz[newds] = 0;
        -: 2212:		}
        -: 2213:
    10343: 2214:	else if ( reject )
branch  0 taken 4041 (fallthrough)
branch  1 taken 6302
        -: 2215:		{
        -: 2216:		/* We sort the accepting set in increasing order so the
        -: 2217:		 * disambiguating rule that the first rule listed is considered
        -: 2218:		 * match in the event of ties will work.  We use a bubble
        -: 2219:		 * sort since the list is probably quite small.
        -: 2220:		 */
        -: 2221:
     4041: 2222:		bubble( accset, nacc );
call    0 returned 4041
        -: 2223:
     4041: 2224:		dfaacc[newds].dfaacc_set = allocate_integer_array( nacc + 1 );
call    0 returned 4041
        -: 2225:
        -: 2226:		/* Save the accepting set for later */
    14438: 2227:		for ( i = 1; i <= nacc; ++i )
branch  0 taken 10397
branch  1 taken 4041 (fallthrough)
        -: 2228:			{
    10397: 2229:			dfaacc[newds].dfaacc_set[i] = accset[i];
        -: 2230:
    10397: 2231:			if ( accset[i] <= num_rules )
branch  0 taken 10331 (fallthrough)
branch  1 taken 66
        -: 2232:				/* Who knows, perhaps a REJECT can yield
        -: 2233:				 * this rule.
        -: 2234:				 */
    10331: 2235:				rule_useful[accset[i]] = true;
        -: 2236:			}
        -: 2237:
     4041: 2238:		accsiz[newds] = nacc;
        -: 2239:		}
        -: 2240:
        -: 2241:	else
        -: 2242:		{
        -: 2243:		/* Find lowest numbered rule so the disambiguating rule
        -: 2244:		 * will work.
        -: 2245:		 */
     6302: 2246:		j = num_rules + 1;
        -: 2247:
    15752: 2248:		for ( i = 1; i <= nacc; ++i )
branch  0 taken 9450
branch  1 taken 6302 (fallthrough)
     9450: 2249:			if ( accset[i] < j )
branch  0 taken 6954 (fallthrough)
branch  1 taken 2496
     6954: 2250:				j = accset[i];
        -: 2251:
     6302: 2252:		dfaacc[newds].dfaacc_state = j;
        -: 2253:
     6302: 2254:		if ( j <= num_rules )
branch  0 taken 6302 (fallthrough)
branch  1 taken 0
     6302: 2255:			rule_useful[j] = true;
        -: 2256:		}
        -: 2257:
    13978: 2258:	*newds_addr = newds;
        -: 2259:
    13978: 2260:	return 1;
        -: 2261:	}
        -: 2262:
        -: 2263:
        -: 2264:/* symfollowset - follow the symbol transitions one step
        -: 2265: *
        -: 2266: * synopsis
        -: 2267: *    numstates = symfollowset( int ds[current_max_dfa_size], int dsize,
        -: 2268: *				int transsym, int nset[current_max_dfa_size] );
        -: 2269: */
        -: 2270:
function symfollowset called 25650 returned 100% blocks executed 94%
    25650: 2271:int symfollowset( ds, dsize, transsym, nset )
        -: 2272:int ds[], dsize, transsym, nset[];
        -: 2273:	{
        -: 2274:	int ns, tsp, sym, i, j, lenccl, ch, numstates, ccllist;
        -: 2275:
    25650: 2276:	numstates = 0;
        -: 2277:
   297542: 2278:	for ( i = 1; i <= dsize; ++i )
branch  0 taken 271892
branch  1 taken 25650 (fallthrough)
        -: 2279:		{ /* for each nfa state ns in the state set of ds */
   271892: 2280:		ns = ds[i];
   271892: 2281:		sym = transchar[ns];
   271892: 2282:		tsp = trans1[ns];
        -: 2283:
   271892: 2284:		if ( sym < 0 )
branch  0 taken 66783 (fallthrough)
branch  1 taken 205109
        -: 2285:			{ /* it's a character class */
    66783: 2286:			sym = -sym;
    66783: 2287:			ccllist = cclmap[sym];
    66783: 2288:			lenccl = ccllen[sym];
        -: 2289:
    66783: 2290:			if ( cclng[sym] )
branch  0 taken 21147 (fallthrough)
branch  1 taken 45636
        -: 2291:				{
    51892: 2292:				for ( j = 0; j < lenccl; ++j )
branch  0 taken 34539
branch  1 taken 17353 (fallthrough)
        -: 2293:					{
        -: 2294:					/* Loop through negated character
        -: 2295:					 * class.
        -: 2296:					 */
    34539: 2297:					ch = ccltbl[ccllist + j];
        -: 2298:
    34539: 2299:					if ( ch == 0 )
branch  0 taken 0 (fallthrough)
branch  1 taken 34539
    #####: 2300:						ch = NUL_ec;
        -: 2301:
    34539: 2302:					if ( ch > transsym )
branch  0 taken 2336 (fallthrough)
branch  1 taken 32203
        -: 2303:						/* Transsym isn't in negated
        -: 2304:						 * ccl.
        -: 2305:						 */
     2336: 2306:						break;
        -: 2307:
    32203: 2308:					else if ( ch == transsym )
branch  0 taken 1458 (fallthrough)
branch  1 taken 30745
     1458: 2309:						/* next 2 */ goto bottom;
        -: 2310:					}
        -: 2311:
        -: 2312:				/* Didn't find transsym in ccl. */
    19689: 2313:				nset[++numstates] = tsp;
        -: 2314:				}
        -: 2315:
        -: 2316:			else
   180565: 2317:				for ( j = 0; j < lenccl; ++j )
branch  0 taken 171937
branch  1 taken 8628 (fallthrough)
        -: 2318:					{
   171937: 2319:					ch = ccltbl[ccllist + j];
        -: 2320:
   171937: 2321:					if ( ch == 0 )
branch  0 taken 6 (fallthrough)
branch  1 taken 171931
        6: 2322:						ch = NUL_ec;
        -: 2323:
   171937: 2324:					if ( ch > transsym )
branch  0 taken 17081 (fallthrough)
branch  1 taken 154856
    17081: 2325:						break;
   154856: 2326:					else if ( ch == transsym )
branch  0 taken 19927 (fallthrough)
branch  1 taken 134929
        -: 2327:						{
    19927: 2328:						nset[++numstates] = tsp;
    19927: 2329:						break;
        -: 2330:						}
        -: 2331:					}
        -: 2332:			}
        -: 2333:
   205109: 2334:		else if ( sym >= 'A' && sym <= 'Z' && caseins )
branch  0 taken 186923 (fallthrough)
branch  1 taken 18186
branch  2 taken 6091 (fallthrough)
branch  3 taken 180832
branch  4 taken 0 (fallthrough)
branch  5 taken 6091
    #####: 2335:			flexfatal(
call    0 never executed
        -: 2336:			_( "consistency check failed in symfollowset" ) );
        -: 2337:
   205109: 2338:		else if ( sym == SYM_EPSILON )
branch  0 taken 138409 (fallthrough)
branch  1 taken 66700
        -: 2339:			{ /* do nothing */
        -: 2340:			}
        -: 2341:
   138409: 2342:		else if ( ABS( ecgroup[sym] ) == transsym )
branch  0 taken 122040 (fallthrough)
branch  1 taken 16369
    16369: 2343:			nset[++numstates] = tsp;
        -: 2344:
   271892: 2345:		bottom: ;
        -: 2346:		}
        -: 2347:
    25650: 2348:	return numstates;
        -: 2349:	}
        -: 2350:
        -: 2351:
        -: 2352:/* sympartition - partition characters with same out-transitions
        -: 2353: *
        -: 2354: * synopsis
        -: 2355: *    sympartition( int ds[current_max_dfa_size], int numstates,
        -: 2356: *			int symlist[numecs], int duplist[numecs] );
        -: 2357: */
        -: 2358:
function sympartition called 13978 returned 100% blocks executed 94%
    13978: 2359:void sympartition( ds, numstates, symlist, duplist )
        -: 2360:int ds[], numstates;
        -: 2361:int symlist[], duplist[];
        -: 2362:	{
        -: 2363:	int tch, i, j, k, ns, dupfwd[CSIZE + 1], lenccl, cclp, ich;
        -: 2364:
        -: 2365:	/* Partitioning is done by creating equivalence classes for those
        -: 2366:	 * characters which have out-transitions from the given state.  Thus
        -: 2367:	 * we are really creating equivalence classes of equivalence classes.
        -: 2368:	 */
        -: 2369:
  1490169: 2370:	for ( i = 1; i <= numecs; ++i )
branch  0 taken 1476191
branch  1 taken 13978 (fallthrough)
        -: 2371:		{ /* initialize equivalence class list */
  1476191: 2372:		duplist[i] = i - 1;
  1476191: 2373:		dupfwd[i] = i + 1;
        -: 2374:		}
        -: 2375:
    13978: 2376:	duplist[1] = NIL;
    13978: 2377:	dupfwd[numecs] = NIL;
        -: 2378:
    71196: 2379:	for ( i = 1; i <= numstates; ++i )
branch  0 taken 57218
branch  1 taken 13978 (fallthrough)
        -: 2380:		{
    57218: 2381:		ns = ds[i];
    57218: 2382:		tch = transchar[ns];
        -: 2383:
    57218: 2384:		if ( tch != SYM_EPSILON )
branch  0 taken 29590 (fallthrough)
branch  1 taken 27628
        -: 2385:			{
    29590: 2386:			if ( tch < -lastccl || tch >= csize )
branch  0 taken 29590 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 29590
        -: 2387:				{
    #####: 2388:				flexfatal(
call    0 never executed
        -: 2389:		_( "bad transition character detected in sympartition()" ) );
        -: 2390:				}
        -: 2391:
    29590: 2392:			if ( tch >= 0 )
branch  0 taken 16369 (fallthrough)
branch  1 taken 13221
        -: 2393:				{ /* character transition */
    16369: 2394:				int ec = ecgroup[tch];
        -: 2395:
    16369: 2396:				mkechar( ec, dupfwd, duplist );
call    0 returned 16369
    16369: 2397:				symlist[ec] = 1;
        -: 2398:				}
        -: 2399:
        -: 2400:			else
        -: 2401:				{ /* character class */
    13221: 2402:				tch = -tch;
        -: 2403:
    13221: 2404:				lenccl = ccllen[tch];
    13221: 2405:				cclp = cclmap[tch];
    13221: 2406:				mkeccl( ccltbl + cclp, lenccl, dupfwd,
call    0 returned 13221
        -: 2407:					duplist, numecs, NUL_ec );
        -: 2408:
    13221: 2409:				if ( cclng[tch] )
branch  0 taken 3112 (fallthrough)
branch  1 taken 10109
        -: 2410:					{
     3112: 2411:					j = 0;
        -: 2412:
    11409: 2413:					for ( k = 0; k < lenccl; ++k )
branch  0 taken 8297
branch  1 taken 3112 (fallthrough)
        -: 2414:						{
     8297: 2415:						ich = ccltbl[cclp + k];
        -: 2416:
     8297: 2417:						if ( ich == 0 )
branch  0 taken 0 (fallthrough)
branch  1 taken 8297
    #####: 2418:							ich = NUL_ec;
        -: 2419:
    35771: 2420:						for ( ++j; j < ich; ++j )
branch  0 taken 27474
branch  1 taken 8297 (fallthrough)
    27474: 2421:							symlist[j] = 1;
        -: 2422:						}
        -: 2423:
   243219: 2424:					for ( ++j; j <= numecs; ++j )
branch  0 taken 240107
branch  1 taken 3112
   240107: 2425:						symlist[j] = 1;
        -: 2426:					}
        -: 2427:
        -: 2428:				else
   203775: 2429:					for ( k = 0; k < lenccl; ++k )
branch  0 taken 193666
branch  1 taken 10109 (fallthrough)
        -: 2430:						{
   193666: 2431:						ich = ccltbl[cclp + k];
        -: 2432:
   193666: 2433:						if ( ich == 0 )
branch  0 taken 2 (fallthrough)
branch  1 taken 193664
        2: 2434:							ich = NUL_ec;
        -: 2435:
   193666: 2436:						symlist[ich] = 1;
        -: 2437:						}
        -: 2438:				}
        -: 2439:			}
        -: 2440:		}
    13978: 2441:	}
        -: 2442:/* ecs - equivalence class routines */
        -: 2443:
        -: 2444:/*-
        -: 2445: * Copyright (c) 1990 The Regents of the University of California.
        -: 2446: * All rights reserved.
        -: 2447: *
        -: 2448: * This code is derived from software contributed to Berkeley by
        -: 2449: * Vern Paxson.
        -: 2450: * 
        -: 2451: * The United States Government has rights in this work pursuant
        -: 2452: * to contract no. DE-AC03-76SF00098 between the United States
        -: 2453: * Department of Energy and the University of California.
        -: 2454: *
        -: 2455: * Redistribution and use in source and binary forms with or without
        -: 2456: * modification are permitted provided that: (1) source distributions retain
        -: 2457: * this entire copyright notice and comment, and (2) distributions including
        -: 2458: * binaries display the following acknowledgement:  ``This product includes
        -: 2459: * software developed by the University of California, Berkeley and its
        -: 2460: * contributors'' in the documentation or other materials provided with the
        -: 2461: * distribution and in all advertising materials mentioning features or use
        -: 2462: * of this software.  Neither the name of the University nor the names of
        -: 2463: * its contributors may be used to endorse or promote products derived from
        -: 2464: * this software without specific prior written permission.
        -: 2465: * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
        -: 2466: * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
        -: 2467: * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
        -: 2468: */
        -: 2469:
        -: 2470:/* $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.seeded/v5/flex.c,v 1.1.1.2 2003/09/02 20:22:00 expsir Exp $ */
        -: 2471:
        -: 2472:
        -: 2473:/* ccl2ecl - convert character classes to set of equivalence classes */
        -: 2474:
function ccl2ecl called 296 returned 100% blocks executed 100%
      296: 2475:void ccl2ecl()
        -: 2476:	{
        -: 2477:	int i, ich, newlen, cclp, ccls, cclmec;
        -: 2478:
     1295: 2479:	for ( i = 1; i <= lastccl; ++i )
branch  0 taken 999
branch  1 taken 296 (fallthrough)
        -: 2480:		{
        -: 2481:		/* We loop through each character class, and for each character
        -: 2482:		 * in the class, add the character's equivalence class to the
        -: 2483:		 * new "character" class we are creating.  Thus when we are all
        -: 2484:		 * done, character classes will really consist of collections
        -: 2485:		 * of equivalence classes
        -: 2486:		 */
        -: 2487:
      999: 2488:		newlen = 0;
      999: 2489:		cclp = cclmap[i];
        -: 2490:
     8618: 2491:		for ( ccls = 0; ccls < ccllen[i]; ++ccls )
branch  0 taken 7619
branch  1 taken 999 (fallthrough)
        -: 2492:			{
     7619: 2493:			ich = ccltbl[cclp + ccls];
     7619: 2494:			cclmec = ecgroup[ich];
        -: 2495:
     7619: 2496:			if ( cclmec > 0 )
branch  0 taken 3187 (fallthrough)
branch  1 taken 4432
        -: 2497:				{
     3187: 2498:				ccltbl[cclp + newlen] = cclmec;
     3187: 2499:				++newlen;
        -: 2500:				}
        -: 2501:			}
        -: 2502:
      999: 2503:		ccllen[i] = newlen;
        -: 2504:		}
      296: 2505:	}
        -: 2506:
        -: 2507:
        -: 2508:/* cre8ecs - associate equivalence class numbers with class members
        -: 2509: *
        -: 2510: * fwd is the forward linked-list of equivalence class members.  bck
        -: 2511: * is the backward linked-list, and num is the number of class members.
        -: 2512: *
        -: 2513: * Returned is the number of classes.
        -: 2514: */
        -: 2515:
function cre8ecs called 511 returned 100% blocks executed 100%
      511: 2516:int cre8ecs( fwd, bck, num )
        -: 2517:int fwd[], bck[], num;
        -: 2518:	{
        -: 2519:	int i, j, numcl;
        -: 2520:
      511: 2521:	numcl = 0;
        -: 2522:
        -: 2523:	/* Create equivalence class numbers.  From now on, ABS( bck(x) )
        -: 2524:	 * is the equivalence class number for object x.  If bck(x)
        -: 2525:	 * is positive, then x is the representative of its equivalence
        -: 2526:	 * class.
        -: 2527:	 */
    98349: 2528:	for ( i = 1; i <= num; ++i )
branch  0 taken 97838
branch  1 taken 511 (fallthrough)
    97838: 2529:		if ( bck[i] == NIL )
branch  0 taken 4572 (fallthrough)
branch  1 taken 93266
        -: 2530:			{
     4572: 2531:			bck[i] = ++numcl;
    97838: 2532:			for ( j = fwd[i]; j != NIL; j = fwd[j] )
branch  0 taken 93266
branch  1 taken 4572 (fallthrough)
    93266: 2533:				bck[j] = -numcl;
        -: 2534:			}
        -: 2535:
      511: 2536:	return numcl;
        -: 2537:	}
        -: 2538:
        -: 2539:
        -: 2540:/* mkeccl - update equivalence classes based on character class xtions
        -: 2541: *
        -: 2542: * synopsis
        -: 2543: *    Char ccls[];
        -: 2544: *    int lenccl, fwd[llsiz], bck[llsiz], llsiz, NUL_mapping;
        -: 2545: *    void mkeccl( Char ccls[], int lenccl, int fwd[llsiz], int bck[llsiz],
        -: 2546: *			int llsiz, int NUL_mapping );
        -: 2547: *
        -: 2548: * ccls contains the elements of the character class, lenccl is the
        -: 2549: * number of elements in the ccl, fwd is the forward link-list of equivalent
        -: 2550: * characters, bck is the backward link-list, and llsiz size of the link-list.
        -: 2551: *
        -: 2552: * NUL_mapping is the value which NUL (0) should be mapped to.
        -: 2553: */
        -: 2554:
function mkeccl called 14475 returned 100% blocks executed 100%
    14475: 2555:void mkeccl( ccls, lenccl, fwd, bck, llsiz, NUL_mapping )
        -: 2556:Char ccls[];
        -: 2557:int lenccl, fwd[], bck[], llsiz, NUL_mapping;
        -: 2558:	{
        -: 2559:	int cclp, oldec, newec;
        -: 2560:	int cclm, i, j;
        -: 2561:	static unsigned char cclflags[CSIZE];	/* initialized to all '\0' */
        -: 2562:
        -: 2563:	/* Note that it doesn't matter whether or not the character class is
        -: 2564:	 * negated.  The same results will be obtained in either case.
        -: 2565:	 */
        -: 2566:
    14475: 2567:	cclp = 0;
        -: 2568:
    36419: 2569:	while ( cclp < lenccl )
branch  0 taken 21944
branch  1 taken 14475 (fallthrough)
        -: 2570:		{
    21944: 2571:		cclm = ccls[cclp];
        -: 2572:
    21944: 2573:		if ( NUL_mapping && cclm == 0 )
branch  0 taken 21589 (fallthrough)
branch  1 taken 355
branch  2 taken 4 (fallthrough)
branch  3 taken 21585
        4: 2574:			cclm = NUL_mapping;
        -: 2575:
    21944: 2576:		oldec = bck[cclm];
    21944: 2577:		newec = cclm;
        -: 2578:
    21944: 2579:		j = cclp + 1;
        -: 2580:
   799070: 2581:		for ( i = fwd[cclm]; i != NIL && i <= llsiz; i = fwd[i] )
branch  0 taken 777126 (fallthrough)
branch  1 taken 21944
branch  2 taken 777126
branch  3 taken 0 (fallthrough)
        -: 2582:			{ /* look for the symbol in the character class */
  1006718: 2583:			for ( ; j < lenccl; ++j )
branch  0 taken 562914
branch  1 taken 443804 (fallthrough)
        -: 2584:				{
        -: 2585:				register int ccl_char;
        -: 2586:
   562914: 2587:				if ( NUL_mapping && ccls[j] == 0 )
branch  0 taken 510342 (fallthrough)
branch  1 taken 52572
branch  2 taken 750 (fallthrough)
branch  3 taken 509592
      750: 2588:					ccl_char = NUL_mapping;
        -: 2589:				else
   562164: 2590:					ccl_char = ccls[j];
        -: 2591:
   562914: 2592:				if ( ccl_char > i )
branch  0 taken 107973 (fallthrough)
branch  1 taken 454941
   107973: 2593:					break;
        -: 2594:
   454941: 2595:				if ( ccl_char == i && ! cclflags[j] )
branch  0 taken 225349 (fallthrough)
branch  1 taken 229592
branch  2 taken 225349 (fallthrough)
branch  3 taken 0
        -: 2596:					{
        -: 2597:					/* We found an old companion of cclm
        -: 2598:					 * in the ccl.  Link it into the new
        -: 2599:					 * equivalence class and flag it as
        -: 2600:					 * having been processed.
        -: 2601:					 */
        -: 2602:
   225349: 2603:					bck[i] = newec;
   225349: 2604:					fwd[newec] = i;
   225349: 2605:					newec = i;
        -: 2606:					/* Set flag so we don't reprocess. */
   225349: 2607:					cclflags[j] = 1;
        -: 2608:
        -: 2609:					/* Get next equivalence class member. */
        -: 2610:					/* continue 2 */
   225349: 2611:					goto next_pt;
        -: 2612:					}
        -: 2613:				}
        -: 2614:
        -: 2615:			/* Symbol isn't in character class.  Put it in the old
        -: 2616:			 * equivalence class.
        -: 2617:			 */
        -: 2618:
   551777: 2619:			bck[i] = oldec;
        -: 2620:
   551777: 2621:			if ( oldec != NIL )
branch  0 taken 551140 (fallthrough)
branch  1 taken 637
   551140: 2622:				fwd[oldec] = i;
        -: 2623:
   551777: 2624:			oldec = i;
        -: 2625:
   777126: 2626:			next_pt: ;
        -: 2627:			}
        -: 2628:
    21944: 2629:		if ( bck[cclm] != NIL || oldec != bck[cclm] )
branch  0 taken 11812 (fallthrough)
branch  1 taken 10132
branch  2 taken 637 (fallthrough)
branch  3 taken 11175
        -: 2630:			{
    10769: 2631:			bck[cclm] = NIL;
    10769: 2632:			fwd[oldec] = NIL;
        -: 2633:			}
        -: 2634:
    21944: 2635:		fwd[newec] = NIL;
        -: 2636:
        -: 2637:		/* Find next ccl member to process. */
        -: 2638:
   247293: 2639:		for ( ++cclp; cclflags[cclp] && cclp < lenccl; ++cclp )
branch  0 taken 225349 (fallthrough)
branch  1 taken 21944
branch  2 taken 225349
branch  3 taken 0 (fallthrough)
        -: 2640:			{
        -: 2641:			/* Reset "doesn't need processing" flag. */
   225349: 2642:			cclflags[cclp] = 0;
        -: 2643:			}
        -: 2644:		}
    14475: 2645:	}
        -: 2646:
        -: 2647:
        -: 2648:/* mkechar - create equivalence class for single character */
        -: 2649:
function mkechar called 23930 returned 100% blocks executed 100%
    23930: 2650:void mkechar( tch, fwd, bck )
        -: 2651:int tch, fwd[], bck[];
        -: 2652:	{
        -: 2653:	/* If until now the character has been a proper subset of
        -: 2654:	 * an equivalence class, break it away to create a new ec
        -: 2655:	 */
        -: 2656:
    23930: 2657:	if ( fwd[tch] != NIL )
branch  0 taken 16745 (fallthrough)
branch  1 taken 7185
    16745: 2658:		bck[fwd[tch]] = bck[tch];
        -: 2659:
    23930: 2660:	if ( bck[tch] != NIL )
branch  0 taken 17785 (fallthrough)
branch  1 taken 6145
    17785: 2661:		fwd[bck[tch]] = fwd[tch];
        -: 2662:
    23930: 2663:	fwd[tch] = NIL;
    23930: 2664:	bck[tch] = NIL;
    23930: 2665:	}
        -: 2666:/* gen - actual generation (writing) of flex scanners */
        -: 2667:
        -: 2668:/*-
        -: 2669: * Copyright (c) 1990 The Regents of the University of California.
        -: 2670: * All rights reserved.
        -: 2671: *
        -: 2672: * This code is derived from software contributed to Berkeley by
        -: 2673: * Vern Paxson.
        -: 2674: * 
        -: 2675: * The United States Government has rights in this work pursuant
        -: 2676: * to contract no. DE-AC03-76SF00098 between the United States
        -: 2677: * Department of Energy and the University of California.
        -: 2678: *
        -: 2679: * Redistribution and use in source and binary forms with or without
        -: 2680: * modification are permitted provided that: (1) source distributions retain
        -: 2681: * this entire copyright notice and comment, and (2) distributions including
        -: 2682: * binaries display the following acknowledgement:  ``This product includes
        -: 2683: * software developed by the University of California, Berkeley and its
        -: 2684: * contributors'' in the documentation or other materials provided with the
        -: 2685: * distribution and in all advertising materials mentioning features or use
        -: 2686: * of this software.  Neither the name of the University nor the names of
        -: 2687: * its contributors may be used to endorse or promote products derived from
        -: 2688: * this software without specific prior written permission.
        -: 2689: * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
        -: 2690: * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
        -: 2691: * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
        -: 2692: */
        -: 2693:
        -: 2694:/* $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.seeded/v5/flex.c,v 1.1.1.2 2003/09/02 20:22:00 expsir Exp $ */
        -: 2695:
        -: 2696:
        -: 2697:
        -: 2698:/* declare functions that have forward references */
        -: 2699:
        -: 2700:void gen_next_state PROTO((int));
        -: 2701:void genecs PROTO((void));
        -: 2702:void indent_put2s PROTO((char [], char []));
        -: 2703:void indent_puts PROTO((char []));
        -: 2704:
        -: 2705:
        -: 2706:static int indent_level = 0; /* each level is 8 spaces */
        -: 2707:
        -: 2708:#define indent_up() (++indent_level)
        -: 2709:#define indent_down() (--indent_level)
        -: 2710:#define set_indent(indent_val) indent_level = indent_val
        -: 2711:
        -: 2712:/* Almost everything is done in terms of arrays starting at 1, so provide
        -: 2713: * a null entry for the zero element of all C arrays.  (The exception
        -: 2714: * to this is that the fast table representation generally uses the
        -: 2715: * 0 elements of its arrays, too.)
        -: 2716: */
        -: 2717:static char C_int_decl[] = "static yyconst int %s[%d] =\n    {   0,\n";
        -: 2718:static char C_short_decl[] = "static yyconst short int %s[%d] =\n    {   0,\n";
        -: 2719:static char C_long_decl[] = "static yyconst long int %s[%d] =\n    {   0,\n";
        -: 2720:static char C_state_decl[] =
        -: 2721:	"static yyconst yy_state_type %s[%d] =\n    {   0,\n";
        -: 2722:
        -: 2723:
        -: 2724:/* Indent to the current level. */
        -: 2725:
function do_indent called 44197 returned 100% blocks executed 78%
    44197: 2726:void do_indent()
        -: 2727:	{
    44197: 2728:	register int i = indent_level * 8;
        -: 2729:
   151531: 2730:	while ( i >= 8 )
branch  0 taken 107334
branch  1 taken 44197 (fallthrough)
        -: 2731:		{
   107334: 2732:		outc( '\t' );
call    0 returned 107334
   107334: 2733:		i -= 8;
        -: 2734:		}
        -: 2735:
    44197: 2736:	while ( i > 0 )
branch  0 taken 0
branch  1 taken 44197 (fallthrough)
        -: 2737:		{
    #####: 2738:		outc( ' ' );
call    0 never executed
    #####: 2739:		--i;
        -: 2740:		}
    44197: 2741:	}
        -: 2742:
        -: 2743:
        -: 2744:/* Generate the code to keep backing-up information. */
        -: 2745:
function gen_backing_up called 1625 returned 100% blocks executed 100%
     1625: 2746:void gen_backing_up()
        -: 2747:	{
     1625: 2748:	if ( reject || num_backing_up == 0 )
branch  0 taken 1121 (fallthrough)
branch  1 taken 504
branch  2 taken 2 (fallthrough)
branch  3 taken 1119
      506: 2749:		return;
        -: 2750:
     1119: 2751:	if ( fullspd )
branch  0 taken 276 (fallthrough)
branch  1 taken 843
      276: 2752:		indent_puts( "if ( yy_current_state[-1].yy_nxt )" );
call    0 returned 276
        -: 2753:	else
      843: 2754:		indent_puts( "if ( yy_accept[yy_current_state] )" );
call    0 returned 843
        -: 2755:
     1119: 2756:	indent_up();
     1119: 2757:	indent_puts( "{" );
call    0 returned 1119
     1119: 2758:	indent_puts( "yy_last_accepting_state = yy_current_state;" );
call    0 returned 1119
     1119: 2759:	indent_puts( "yy_last_accepting_cpos = yy_cp;" );
call    0 returned 1119
     1119: 2760:	indent_puts( "}" );
call    0 returned 1119
     1119: 2761:	indent_down();
        -: 2762:	}
        -: 2763:
        -: 2764:
        -: 2765:/* Generate the code to perform the backing up. */
        -: 2766:
function gen_bu_action called 543 returned 100% blocks executed 100%
      543: 2767:void gen_bu_action()
        -: 2768:	{
      543: 2769:	if ( reject || num_backing_up == 0 )
branch  0 taken 375 (fallthrough)
branch  1 taken 168
branch  2 taken 2 (fallthrough)
branch  3 taken 373
      170: 2770:		return;
        -: 2771:
      373: 2772:	set_indent( 3 );
        -: 2773:
      373: 2774:	indent_puts( "case 0: /* must back up */" );
call    0 returned 373
      373: 2775:	indent_puts( "/* undo the effects of YY_DO_BEFORE_ACTION */" );
call    0 returned 373
      373: 2776:	indent_puts( "*yy_cp = yy_hold_char;" );
call    0 returned 373
        -: 2777:
      373: 2778:	if ( fullspd || fulltbl )
branch  0 taken 281 (fallthrough)
branch  1 taken 92
branch  2 taken 21 (fallthrough)
branch  3 taken 260
      113: 2779:		indent_puts( "yy_cp = yy_last_accepting_cpos + 1;" );
call    0 returned 113
        -: 2780:	else
        -: 2781:		/* Backing-up info for compressed tables is taken \after/
        -: 2782:		 * yy_cp has been incremented for the next state.
        -: 2783:		 */
      260: 2784:		indent_puts( "yy_cp = yy_last_accepting_cpos;" );
call    0 returned 260
        -: 2785:
      373: 2786:	indent_puts( "yy_current_state = yy_last_accepting_state;" );
call    0 returned 373
      373: 2787:	indent_puts( "goto yy_find_action;" );
call    0 returned 373
      373: 2788:	outc( '\n' );
call    0 returned 373
        -: 2789:
      373: 2790:	set_indent( 0 );
        -: 2791:	}
        -: 2792:
        -: 2793:
        -: 2794:/* genctbl - generates full speed compressed transition table */
        -: 2795:
function genctbl called 92 returned 100% blocks executed 94%
       92: 2796:void genctbl()
        -: 2797:	{
        -: 2798:	register int i;
       92: 2799:	int end_of_buffer_action = num_rules + 1;
        -: 2800:
        -: 2801:	/* Table of verify for transition and offset to next state. */
       92: 2802:	out_dec( "static yyconst struct yy_trans_info yy_transition[%d] =\n",
       92: 2803:		tblend + numecs + 1 );
call    0 returned 92
       92: 2804:	outn( "    {" );
call    0 returned 92
        -: 2805:
        -: 2806:	/* We want the transition to be represented as the offset to the
        -: 2807:	 * next state, not the actual state number, which is what it currently
        -: 2808:	 * is.  The offset is base[nxt[i]] - (base of current state)].  That's
        -: 2809:	 * just the difference between the starting points of the two involved
        -: 2810:	 * states (to - from).
        -: 2811:	 *
        -: 2812:	 * First, though, we need to find some way to put in our end-of-buffer
        -: 2813:	 * flags and states.  We do this by making a state with absolutely no
        -: 2814:	 * transitions.  We put it at the end of the table.
        -: 2815:	 */
        -: 2816:
        -: 2817:	/* We need to have room in nxt/chk for two more slots: One for the
        -: 2818:	 * action and one for the end-of-buffer transition.  We now *assume*
        -: 2819:	 * that we're guaranteed the only character we'll try to index this
        -: 2820:	 * nxt/chk pair with is EOB, i.e., 0, so we don't have to make sure
        -: 2821:	 * there's room for jam entries for other characters.
        -: 2822:	 */
        -: 2823:
       92: 2824:	while ( tblend + 2 >= current_max_xpairs )
branch  0 taken 0
branch  1 taken 92 (fallthrough)
    #####: 2825:		expand_nxt_chk();
call    0 never executed
        -: 2826:
       92: 2827:	while ( lastdfa + 1 >= current_max_dfas )
branch  0 taken 0
branch  1 taken 92 (fallthrough)
    #####: 2828:		increase_max_dfas();
call    0 never executed
        -: 2829:
       92: 2830:	base[lastdfa + 1] = tblend + 2;
       92: 2831:	nxt[tblend + 1] = end_of_buffer_action;
       92: 2832:	chk[tblend + 1] = numecs + 1;
       92: 2833:	chk[tblend + 2] = 1; /* anything but EOB */
        -: 2834:
        -: 2835:	/* So that "make test" won't show arb. differences. */
       92: 2836:	nxt[tblend + 2] = 0;
        -: 2837:
        -: 2838:	/* Make sure every state has an end-of-buffer transition and an
        -: 2839:	 * action #.
        -: 2840:	 */
     2354: 2841:	for ( i = 0; i <= lastdfa; ++i )
branch  0 taken 2262
branch  1 taken 92 (fallthrough)
        -: 2842:		{
     2262: 2843:		int anum = dfaacc[i].dfaacc_state;
     2262: 2844:		int offset = base[i];
        -: 2845:
     2262: 2846:		chk[offset] = EOB_POSITION;
     2262: 2847:		chk[offset - 1] = ACTION_POSITION;
     2262: 2848:		nxt[offset - 1] = anum;	/* action number */
        -: 2849:		}
        -: 2850:
    55605: 2851:	for ( i = 0; i <= tblend; ++i )
branch  0 taken 55513
branch  1 taken 92 (fallthrough)
        -: 2852:		{
    55513: 2853:		if ( chk[i] == EOB_POSITION )
branch  0 taken 2262 (fallthrough)
branch  1 taken 53251
     2262: 2854:			transition_struct_out( 0, base[lastdfa + 1] - i );
call    0 returned 2262
        -: 2855:
    53251: 2856:		else if ( chk[i] == ACTION_POSITION )
branch  0 taken 2262 (fallthrough)
branch  1 taken 50989
     2262: 2857:			transition_struct_out( 0, nxt[i] );
call    0 returned 2262
        -: 2858:
    50989: 2859:		else if ( chk[i] > numecs || chk[i] == 0 )
branch  0 taken 50989 (fallthrough)
branch  1 taken 0
branch  2 taken 18266 (fallthrough)
branch  3 taken 32723
    18266: 2860:			transition_struct_out( 0, 0 );	/* unused slot */
call    0 returned 18266
        -: 2861:
        -: 2862:		else	/* verify, transition */
    32723: 2863:			transition_struct_out( chk[i],
    32723: 2864:						base[nxt[i]] - (i - chk[i]) );
call    0 returned 32723
        -: 2865:		}
        -: 2866:
        -: 2867:
        -: 2868:	/* Here's the final, end-of-buffer state. */
       92: 2869:	transition_struct_out( chk[tblend + 1], nxt[tblend + 1] );
call    0 returned 92
       92: 2870:	transition_struct_out( chk[tblend + 2], nxt[tblend + 2] );
call    0 returned 92
        -: 2871:
       92: 2872:	outn( "    };\n" );
call    0 returned 92
        -: 2873:
        -: 2874:	/* Table of pointers to start states. */
       92: 2875:	out_dec(
        -: 2876:	"static yyconst struct yy_trans_info *yy_start_state_list[%d] =\n",
       92: 2877:		lastsc * 2 + 1 );
call    0 returned 92
       92: 2878:	outn( "    {" );	/* } so vi doesn't get confused */
call    0 returned 92
        -: 2879:
      368: 2880:	for ( i = 0; i <= lastsc * 2; ++i )
branch  0 taken 276
branch  1 taken 92 (fallthrough)
      276: 2881:		out_dec( "    &yy_transition[%d],\n", base[i] );
call    0 returned 276
        -: 2882:
       92: 2883:	dataend();
call    0 returned 92
        -: 2884:
       92: 2885:	if ( useecs )
branch  0 taken 40 (fallthrough)
branch  1 taken 52
       40: 2886:		genecs();
call    0 returned 40
       92: 2887:	}
        -: 2888:
        -: 2889:
        -: 2890:/* Generate equivalence-class tables. */
        -: 2891:
function genecs called 296 returned 100% blocks executed 100%
      296: 2892:void genecs()
        -: 2893:	{
        -: 2894:	register int i, j;
        -: 2895:	int numrows;
        -: 2896:
      296: 2897:	out_str_dec( C_int_decl, "yy_ec", csize );
call    0 returned 296
        -: 2898:
    75520: 2899:	for ( i = 1; i < csize; ++i )
branch  0 taken 75224
branch  1 taken 296 (fallthrough)
        -: 2900:		{
    75224: 2901:		if ( caseins && (i >= 'A') && (i <= 'Z') )
branch  0 taken 637 (fallthrough)
branch  1 taken 74587
branch  2 taken 445 (fallthrough)
branch  3 taken 192
branch  4 taken 78 (fallthrough)
branch  5 taken 367
       78: 2902:			ecgroup[i] = ecgroup[clower( i )];
call    0 returned 78
        -: 2903:
    75224: 2904:		ecgroup[i] = ABS( ecgroup[i] );
    75224: 2905:		mkdata( ecgroup[i] );
call    0 returned 75224
        -: 2906:		}
        -: 2907:
      296: 2908:	dataend();
call    0 returned 296
        -: 2909:
      296: 2910:	if ( trace )
branch  0 taken 14 (fallthrough)
branch  1 taken 282
        -: 2911:		{
       14: 2912:		fputs( _( "\n\nEquivalence Classes:\n\n" ), err );
call    0 returned 14
        -: 2913:
       14: 2914:		numrows = csize / 8;
        -: 2915:
      446: 2916:		for ( j = 0; j < numrows; ++j )
branch  0 taken 432
branch  1 taken 14 (fallthrough)
        -: 2917:			{
     3888: 2918:			for ( i = j; i < csize; i = i + numrows )
branch  0 taken 3456
branch  1 taken 432 (fallthrough)
        -: 2919:				{
     3456: 2920:				fprintf( err, "%4s = %-2d",
call    0 returned 3456
call    1 returned 3456
        -: 2921:					readable_form( i ), ecgroup[i] );
        -: 2922:
     3456: 2923:				putc( ' ', err );
call    0 returned 3456
        -: 2924:				}
        -: 2925:
      432: 2926:			putc( '\n', err );
call    0 returned 432
        -: 2927:			}
        -: 2928:		}
      296: 2929:	}
        -: 2930:
        -: 2931:
        -: 2932:/* Generate the code to find the action number. */
        -: 2933:
function gen_find_action called 543 returned 100% blocks executed 100%
      543: 2934:void gen_find_action()
        -: 2935:	{
      543: 2936:	if ( fullspd )
branch  0 taken 92 (fallthrough)
branch  1 taken 451
       92: 2937:		indent_puts( "yy_act = yy_current_state[-1].yy_nxt;" );
call    0 returned 92
        -: 2938:
      451: 2939:	else if ( fulltbl )
branch  0 taken 23 (fallthrough)
branch  1 taken 428
       23: 2940:		indent_puts( "yy_act = yy_accept[yy_current_state];" );
call    0 returned 23
        -: 2941:
      428: 2942:	else if ( reject )
branch  0 taken 168 (fallthrough)
branch  1 taken 260
        -: 2943:		{
      168: 2944:		indent_puts( "yy_current_state = *--yy_state_ptr;" );
call    0 returned 168
      168: 2945:		indent_puts( "yy_lp = yy_accept[yy_current_state];" );
call    0 returned 168
        -: 2946:
      168: 2947:		outn(
call    0 returned 168
        -: 2948:		"find_rule: /* we branch to this label when backing up */" );
        -: 2949:
      168: 2950:		indent_puts(
call    0 returned 168
        -: 2951:		"for ( ; ; ) /* until we find what rule we matched */" );
        -: 2952:
      168: 2953:		indent_up();
        -: 2954:
      168: 2955:		indent_puts( "{" );
call    0 returned 168
        -: 2956:
      168: 2957:		indent_puts(
call    0 returned 168
        -: 2958:		"if ( yy_lp && yy_lp < yy_accept[yy_current_state + 1] )" );
      168: 2959:		indent_up();
      168: 2960:		indent_puts( "{" );
call    0 returned 168
      168: 2961:		indent_puts( "yy_act = yy_acclist[yy_lp];" );
call    0 returned 168
        -: 2962:
      168: 2963:		if ( variable_trailing_context_rules )
branch  0 taken 33 (fallthrough)
branch  1 taken 135
        -: 2964:			{
       33: 2965:			indent_puts( "if ( yy_act & YY_TRAILING_HEAD_MASK ||" );
call    0 returned 33
       33: 2966:			indent_puts( "     yy_looking_for_trail_begin )" );
call    0 returned 33
       33: 2967:			indent_up();
       33: 2968:			indent_puts( "{" );
call    0 returned 33
        -: 2969:
       33: 2970:			indent_puts(
call    0 returned 33
        -: 2971:				"if ( yy_act == yy_looking_for_trail_begin )" );
       33: 2972:			indent_up();
       33: 2973:			indent_puts( "{" );
call    0 returned 33
       33: 2974:			indent_puts( "yy_looking_for_trail_begin = 0;" );
call    0 returned 33
       33: 2975:			indent_puts( "yy_act &= ~YY_TRAILING_HEAD_MASK;" );
call    0 returned 33
       33: 2976:			indent_puts( "break;" );
call    0 returned 33
       33: 2977:			indent_puts( "}" );
call    0 returned 33
       33: 2978:			indent_down();
        -: 2979:
       33: 2980:			indent_puts( "}" );
call    0 returned 33
       33: 2981:			indent_down();
        -: 2982:
       33: 2983:			indent_puts( "else if ( yy_act & YY_TRAILING_MASK )" );
call    0 returned 33
       33: 2984:			indent_up();
       33: 2985:			indent_puts( "{" );
call    0 returned 33
       33: 2986:			indent_puts(
call    0 returned 33
        -: 2987:		"yy_looking_for_trail_begin = yy_act & ~YY_TRAILING_MASK;" );
       33: 2988:			indent_puts(
call    0 returned 33
        -: 2989:		"yy_looking_for_trail_begin |= YY_TRAILING_HEAD_MASK;" );
        -: 2990:
       33: 2991:			if ( real_reject )
branch  0 taken 31 (fallthrough)
branch  1 taken 2
        -: 2992:				{
        -: 2993:				/* Remember matched text in case we back up
        -: 2994:				 * due to REJECT.
        -: 2995:				 */
       31: 2996:				indent_puts( "yy_full_match = yy_cp;" );
call    0 returned 31
       31: 2997:				indent_puts( "yy_full_state = yy_state_ptr;" );
call    0 returned 31
       31: 2998:				indent_puts( "yy_full_lp = yy_lp;" );
call    0 returned 31
        -: 2999:				}
        -: 3000:
       33: 3001:			indent_puts( "}" );
call    0 returned 33
       33: 3002:			indent_down();
        -: 3003:
       33: 3004:			indent_puts( "else" );
call    0 returned 33
       33: 3005:			indent_up();
       33: 3006:			indent_puts( "{" );
call    0 returned 33
       33: 3007:			indent_puts( "yy_full_match = yy_cp;" );
call    0 returned 33
       33: 3008:			indent_puts( "yy_full_state = yy_state_ptr;" );
call    0 returned 33
       33: 3009:			indent_puts( "yy_full_lp = yy_lp;" );
call    0 returned 33
       33: 3010:			indent_puts( "break;" );
call    0 returned 33
       33: 3011:			indent_puts( "}" );
call    0 returned 33
       33: 3012:			indent_down();
        -: 3013:
       33: 3014:			indent_puts( "++yy_lp;" );
call    0 returned 33
       33: 3015:			indent_puts( "goto find_rule;" );
call    0 returned 33
        -: 3016:			}
        -: 3017:
        -: 3018:		else
        -: 3019:			{
        -: 3020:			/* Remember matched text in case we back up due to
        -: 3021:			 * trailing context plus REJECT.
        -: 3022:			 */
      135: 3023:			indent_up();
      135: 3024:			indent_puts( "{" );
call    0 returned 135
      135: 3025:			indent_puts( "yy_full_match = yy_cp;" );
call    0 returned 135
      135: 3026:			indent_puts( "break;" );
call    0 returned 135
      135: 3027:			indent_puts( "}" );
call    0 returned 135
      135: 3028:			indent_down();
        -: 3029:			}
        -: 3030:
      168: 3031:		indent_puts( "}" );
call    0 returned 168
      168: 3032:		indent_down();
        -: 3033:
      168: 3034:		indent_puts( "--yy_cp;" );
call    0 returned 168
        -: 3035:
        -: 3036:		/* We could consolidate the following two lines with those at
        -: 3037:		 * the beginning, but at the cost of complaints that we're
        -: 3038:		 * branching inside a loop.
        -: 3039:		 */
      168: 3040:		indent_puts( "yy_current_state = *--yy_state_ptr;" );
call    0 returned 168
      168: 3041:		indent_puts( "yy_lp = yy_accept[yy_current_state];" );
call    0 returned 168
        -: 3042:
      168: 3043:		indent_puts( "}" );
call    0 returned 168
        -: 3044:
      168: 3045:		indent_down();
        -: 3046:		}
        -: 3047:
        -: 3048:	else
        -: 3049:		{ /* compressed */
      260: 3050:		indent_puts( "yy_act = yy_accept[yy_current_state];" );
call    0 returned 260
        -: 3051:
      260: 3052:		if ( interactive && ! reject )
branch  0 taken 259 (fallthrough)
branch  1 taken 1
branch  2 taken 259 (fallthrough)
branch  3 taken 0
        -: 3053:			{
        -: 3054:			/* Do the guaranteed-needed backing up to figure out
        -: 3055:			 * the match.
        -: 3056:			 */
      259: 3057:			indent_puts( "if ( yy_act == 0 )" );
call    0 returned 259
      259: 3058:			indent_up();
      259: 3059:			indent_puts( "{ /* have to back up */" );
call    0 returned 259
      259: 3060:			indent_puts( "yy_cp = yy_last_accepting_cpos;" );
call    0 returned 259
      259: 3061:			indent_puts(
call    0 returned 259
        -: 3062:				"yy_current_state = yy_last_accepting_state;" );
      259: 3063:			indent_puts( "yy_act = yy_accept[yy_current_state];" );
call    0 returned 259
      259: 3064:			indent_puts( "}" );
call    0 returned 259
      259: 3065:			indent_down();
        -: 3066:			}
        -: 3067:		}
      543: 3068:	}
        -: 3069:
        -: 3070:
        -: 3071:/* genftbl - generate full transition table */
        -: 3072:
function genftbl called 23 returned 100% blocks executed 93%
       23: 3073:void genftbl()
        -: 3074:	{
        -: 3075:	register int i;
       23: 3076:	int end_of_buffer_action = num_rules + 1;
        -: 3077:
      23*: 3078:	out_str_dec( long_align ? C_long_decl : C_short_decl,
branch  0 taken 0 (fallthrough)
branch  1 taken 23
call    2 returned 23
        -: 3079:		"yy_accept", lastdfa + 1 );
        -: 3080:
       23: 3081:	dfaacc[end_of_buffer_state].dfaacc_state = end_of_buffer_action;
        -: 3082:
      565: 3083:	for ( i = 1; i <= lastdfa; ++i )
branch  0 taken 542
branch  1 taken 23 (fallthrough)
        -: 3084:		{
      542: 3085:		register int anum = dfaacc[i].dfaacc_state;
        -: 3086:
      542: 3087:		mkdata( anum );
call    0 returned 542
        -: 3088:
      542: 3089:		if ( trace && anum )
branch  0 taken 18 (fallthrough)
branch  1 taken 524
branch  2 taken 16 (fallthrough)
branch  3 taken 2
       16: 3090:			fprintf( err, _( "state # %d accepts: [%d]\n" ),
call    0 returned 16
        -: 3091:				i, anum );
        -: 3092:		}
        -: 3093:
       23: 3094:	dataend();
call    0 returned 23
        -: 3095:
       23: 3096:	if ( useecs )
branch  0 taken 1 (fallthrough)
branch  1 taken 22
        1: 3097:		genecs();
call    0 returned 1
        -: 3098:
        -: 3099:	/* Don't have to dump the actual full table entries - they were
        -: 3100:	 * created on-the-fly.
        -: 3101:	 */
       23: 3102:	}
        -: 3103:
        -: 3104:
        -: 3105:/* Generate the code to find the next compressed-table state. */
        -: 3106:
function gen_next_compressed_state called 1111 returned 100% blocks executed 100%
     1111: 3107:void gen_next_compressed_state( char_map )
        -: 3108:char *char_map;
        -: 3109:	{
     1111: 3110:	indent_put2s( "register YY_CHAR yy_c = %s;", char_map );
call    0 returned 1111
        -: 3111:
        -: 3112:	/* Save the backing-up info \before/ computing the next state
        -: 3113:	 * because we always compute one more state than needed - we
        -: 3114:	 * always proceed until we reach a jam state
        -: 3115:	 */
     1111: 3116:	gen_backing_up();
call    0 returned 1111
        -: 3117:
     1111: 3118:	indent_puts(
call    0 returned 1111
        -: 3119:"while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )" );
     1111: 3120:	indent_up();
     1111: 3121:	indent_puts( "{" );
call    0 returned 1111
     1111: 3122:	indent_puts( "yy_current_state = (int) yy_def[yy_current_state];" );
call    0 returned 1111
        -: 3123:
     1111: 3124:	if ( usemecs )
branch  0 taken 565 (fallthrough)
branch  1 taken 546
        -: 3125:		{
        -: 3126:		/* We've arrange it so that templates are never chained
        -: 3127:		 * to one another.  This means we can afford to make a
        -: 3128:		 * very simple test to see if we need to convert to
        -: 3129:		 * yy_c's meta-equivalence class without worrying
        -: 3130:		 * about erroneously looking up the meta-equivalence
        -: 3131:		 * class twice
        -: 3132:		 */
      565: 3133:		do_indent();
call    0 returned 565
        -: 3134:
        -: 3135:		/* lastdfa + 2 is the beginning of the templates */
      565: 3136:		out_dec( "if ( yy_current_state >= %d )\n", lastdfa + 2 );
call    0 returned 565
        -: 3137:
      565: 3138:		indent_up();
      565: 3139:		indent_puts( "yy_c = yy_meta[(unsigned int) yy_c];" );
call    0 returned 565
      565: 3140:		indent_down();
        -: 3141:		}
        -: 3142:
     1111: 3143:	indent_puts( "}" );
call    0 returned 1111
     1111: 3144:	indent_down();
        -: 3145:
     1111: 3146:	indent_puts(
call    0 returned 1111
        -: 3147:"yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];" );
     1111: 3148:	}
        -: 3149:
        -: 3150:
        -: 3151:/* Generate the code to find the next match. */
        -: 3152:
function gen_next_match called 543 returned 100% blocks executed 100%
      543: 3153:void gen_next_match()
        -: 3154:	{
        -: 3155:	/* NOTE - changes in here should be reflected in gen_next_state() and
        -: 3156:	 * gen_NUL_trans().
        -: 3157:	 */
     1086: 3158:	char *char_map = useecs ?
      543: 3159:				"yy_ec[YY_SC_TO_UI(*yy_cp)]" :
branch  0 taken 296 (fallthrough)
branch  1 taken 247
        -: 3160:				"YY_SC_TO_UI(*yy_cp)";
        -: 3161:
     1086: 3162:	char *char_map_2 = useecs ?
      543: 3163:				"yy_ec[YY_SC_TO_UI(*++yy_cp)]" :
branch  0 taken 296 (fallthrough)
branch  1 taken 247
        -: 3164:				"YY_SC_TO_UI(*++yy_cp)";
        -: 3165:
      543: 3166:	if ( fulltbl )
branch  0 taken 23 (fallthrough)
branch  1 taken 520
        -: 3167:		{
       23: 3168:		indent_put2s(
call    0 returned 23
        -: 3169:	"while ( (yy_current_state = yy_nxt[yy_current_state][%s]) > 0 )",
        -: 3170:				char_map );
        -: 3171:
       23: 3172:		indent_up();
        -: 3173:
       23: 3174:		if ( num_backing_up > 0 )
branch  0 taken 21 (fallthrough)
branch  1 taken 2
        -: 3175:			{
       21: 3176:			indent_puts( "{" );	/* } for vi */
call    0 returned 21
       21: 3177:			gen_backing_up();
call    0 returned 21
       21: 3178:			outc( '\n' );
call    0 returned 21
        -: 3179:			}
        -: 3180:
       23: 3181:		indent_puts( "++yy_cp;" );
call    0 returned 23
        -: 3182:
       23: 3183:		if ( num_backing_up > 0 )
branch  0 taken 21 (fallthrough)
branch  1 taken 2
        -: 3184:			/* { for vi */
       21: 3185:			indent_puts( "}" );
call    0 returned 21
        -: 3186:
       23: 3187:		indent_down();
        -: 3188:
       23: 3189:		outc( '\n' );
call    0 returned 23
       23: 3190:		indent_puts( "yy_current_state = -yy_current_state;" );
call    0 returned 23
        -: 3191:		}
        -: 3192:
      520: 3193:	else if ( fullspd )
branch  0 taken 92 (fallthrough)
branch  1 taken 428
        -: 3194:		{
       92: 3195:		indent_puts( "{" );	/* } for vi */
call    0 returned 92
       92: 3196:		indent_puts(
call    0 returned 92
        -: 3197:		"register yyconst struct yy_trans_info *yy_trans_info;\n" );
       92: 3198:		indent_puts( "register YY_CHAR yy_c;\n" );
call    0 returned 92
       92: 3199:		indent_put2s( "for ( yy_c = %s;", char_map );
call    0 returned 92
       92: 3200:		indent_puts(
call    0 returned 92
        -: 3201:	"      (yy_trans_info = &yy_current_state[(unsigned int) yy_c])->" );
       92: 3202:		indent_puts( "yy_verify == yy_c;" );
call    0 returned 92
       92: 3203:		indent_put2s( "      yy_c = %s )", char_map_2 );
call    0 returned 92
        -: 3204:
       92: 3205:		indent_up();
        -: 3206:
       92: 3207:		if ( num_backing_up > 0 )
branch  0 taken 92 (fallthrough)
branch  1 taken 0
       92: 3208:			indent_puts( "{" );	/* } for vi */
call    0 returned 92
        -: 3209:
       92: 3210:		indent_puts( "yy_current_state += yy_trans_info->yy_nxt;" );
call    0 returned 92
        -: 3211:
       92: 3212:		if ( num_backing_up > 0 )
branch  0 taken 92 (fallthrough)
branch  1 taken 0
        -: 3213:			{
       92: 3214:			outc( '\n' );
call    0 returned 92
       92: 3215:			gen_backing_up();	/* { for vi */
call    0 returned 92
       92: 3216:			indent_puts( "}" );
call    0 returned 92
        -: 3217:			}
        -: 3218:
       92: 3219:		indent_down();	/* { for vi */
       92: 3220:		indent_puts( "}" );
call    0 returned 92
        -: 3221:		}
        -: 3222:
        -: 3223:	else
        -: 3224:		{ /* compressed */
      428: 3225:		indent_puts( "do" );
call    0 returned 428
        -: 3226:
      428: 3227:		indent_up();
      428: 3228:		indent_puts( "{" );	/* } for vi */
call    0 returned 428
        -: 3229:
      428: 3230:		gen_next_state( false );
call    0 returned 428
        -: 3231:
      428: 3232:		indent_puts( "++yy_cp;" );
call    0 returned 428
        -: 3233:
        -: 3234:		/* { for vi */
      428: 3235:		indent_puts( "}" );
call    0 returned 428
      428: 3236:		indent_down();
        -: 3237:
      428: 3238:		do_indent();
call    0 returned 428
        -: 3239:
      428: 3240:		if ( interactive )
branch  0 taken 426 (fallthrough)
branch  1 taken 2
      426: 3241:			out_dec( "while ( yy_base[yy_current_state] != %d );\n",
call    0 returned 426
        -: 3242:				jambase );
        -: 3243:		else
        2: 3244:			out_dec( "while ( yy_current_state != %d );\n",
call    0 returned 2
        -: 3245:				jamstate );
        -: 3246:
      428: 3247:		if ( ! reject && ! interactive )
branch  0 taken 260 (fallthrough)
branch  1 taken 168
branch  2 taken 1 (fallthrough)
branch  3 taken 259
        -: 3248:			{
        -: 3249:			/* Do the guaranteed-needed backing up to figure out
        -: 3250:			 * the match.
        -: 3251:			 */
        1: 3252:			indent_puts( "yy_cp = yy_last_accepting_cpos;" );
call    0 returned 1
        1: 3253:			indent_puts(
call    0 returned 1
        -: 3254:				"yy_current_state = yy_last_accepting_state;" );
        -: 3255:			}
        -: 3256:		}
      543: 3257:	}
        -: 3258:
        -: 3259:
        -: 3260:/* Generate the code to find the next state. */
        -: 3261:
function gen_next_state called 971 returned 100% blocks executed 100%
      971: 3262:void gen_next_state( worry_about_NULs )
        -: 3263:int worry_about_NULs;
        -: 3264:	{ /* NOTE - changes in here should be reflected in gen_next_match() */
        -: 3265:	char char_map[256];
        -: 3266:
      971: 3267:	if ( worry_about_NULs && ! nultrans )
branch  0 taken 543 (fallthrough)
branch  1 taken 428
branch  2 taken 348 (fallthrough)
branch  3 taken 195
        -: 3268:		{
      348: 3269:		if ( useecs )
branch  0 taken 296 (fallthrough)
branch  1 taken 52
      296: 3270:			(void) sprintf( char_map,
        -: 3271:				"(*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : %d)",
        -: 3272:					NUL_ec );
        -: 3273:		else
       52: 3274:			(void) sprintf( char_map,
        -: 3275:				"(*yy_cp ? YY_SC_TO_UI(*yy_cp) : %d)", NUL_ec );
        -: 3276:		}
        -: 3277:
        -: 3278:	else
      623: 3279:		strcpy( char_map, useecs ?
branch  0 taken 255 (fallthrough)
branch  1 taken 368
        -: 3280:			"yy_ec[YY_SC_TO_UI(*yy_cp)]" : "YY_SC_TO_UI(*yy_cp)" );
        -: 3281:
      971: 3282:	if ( worry_about_NULs && nultrans )
branch  0 taken 543 (fallthrough)
branch  1 taken 428
branch  2 taken 195 (fallthrough)
branch  3 taken 348
        -: 3283:		{
      195: 3284:		if ( ! fulltbl && ! fullspd )
branch  0 taken 173 (fallthrough)
branch  1 taken 22
branch  2 taken 173 (fallthrough)
branch  3 taken 0
        -: 3285:			/* Compressed tables back up *before* they match. */
      173: 3286:			gen_backing_up();
call    0 returned 173
        -: 3287:
      195: 3288:		indent_puts( "if ( *yy_cp )" );
call    0 returned 195
      195: 3289:		indent_up();
      195: 3290:		indent_puts( "{" );	/* } for vi */
call    0 returned 195
        -: 3291:		}
        -: 3292:
      971: 3293:	if ( fulltbl )
branch  0 taken 23 (fallthrough)
branch  1 taken 948
       23: 3294:		indent_put2s(
call    0 returned 23
        -: 3295:			"yy_current_state = yy_nxt[yy_current_state][%s];", 
        -: 3296:				char_map );
        -: 3297:
      948: 3298:	else if ( fullspd )
branch  0 taken 92 (fallthrough)
branch  1 taken 856
       92: 3299:		indent_put2s(
call    0 returned 92
        -: 3300:			"yy_current_state += yy_current_state[%s].yy_nxt;",
        -: 3301:				char_map );
        -: 3302:
        -: 3303:	else
      856: 3304:		gen_next_compressed_state( char_map );
call    0 returned 856
        -: 3305:
      971: 3306:	if ( worry_about_NULs && nultrans )
branch  0 taken 543 (fallthrough)
branch  1 taken 428
branch  2 taken 195 (fallthrough)
branch  3 taken 348
        -: 3307:		{
        -: 3308:		/* { for vi */
      195: 3309:		indent_puts( "}" );
call    0 returned 195
      195: 3310:		indent_down();
      195: 3311:		indent_puts( "else" );
call    0 returned 195
      195: 3312:		indent_up();
      195: 3313:		indent_puts(
call    0 returned 195
        -: 3314:			"yy_current_state = yy_NUL_trans[yy_current_state];" );
      195: 3315:		indent_down();
        -: 3316:		}
        -: 3317:
      971: 3318:	if ( fullspd || fulltbl )
branch  0 taken 879 (fallthrough)
branch  1 taken 92
branch  2 taken 23 (fallthrough)
branch  3 taken 856
      115: 3319:		gen_backing_up();
call    0 returned 115
        -: 3320:
      971: 3321:	if ( reject )
branch  0 taken 336 (fallthrough)
branch  1 taken 635
      336: 3322:		indent_puts( "*yy_state_ptr++ = yy_current_state;" );
call    0 returned 336
      971: 3323:	}
        -: 3324:
        -: 3325:
        -: 3326:/* Generate the code to make a NUL transition. */
        -: 3327:
function gen_NUL_trans called 543 returned 100% blocks executed 100%
      543: 3328:void gen_NUL_trans()
        -: 3329:	{ /* NOTE - changes in here should be reflected in gen_next_match() */
        -: 3330:	/* Only generate a definition for "yy_cp" if we'll generate code
        -: 3331:	 * that uses it.  Otherwise lint and the like complain.
        -: 3332:	 */
      543: 3333:	int need_backing_up = (num_backing_up > 0 && ! reject);
branch  0 taken 541 (fallthrough)
branch  1 taken 2
branch  2 taken 373 (fallthrough)
branch  3 taken 168
        -: 3334:
      543: 3335:	if ( need_backing_up && (! nultrans || fullspd || fulltbl) )
branch  0 taken 373 (fallthrough)
branch  1 taken 170
branch  2 taken 124 (fallthrough)
branch  3 taken 249
branch  4 taken 124 (fallthrough)
branch  5 taken 0
branch  6 taken 21 (fallthrough)
branch  7 taken 103
        -: 3336:		/* We're going to need yy_cp lying around for the call
        -: 3337:		 * below to gen_backing_up().
        -: 3338:		 */
      270: 3339:		indent_puts( "register char *yy_cp = yy_c_buf_p;" );
call    0 returned 270
        -: 3340:
      543: 3341:	outc( '\n' );
call    0 returned 543
        -: 3342:
      543: 3343:	if ( nultrans )
branch  0 taken 195 (fallthrough)
branch  1 taken 348
        -: 3344:		{
      195: 3345:		indent_puts(
call    0 returned 195
        -: 3346:			"yy_current_state = yy_NUL_trans[yy_current_state];" );
      195: 3347:		indent_puts( "yy_is_jam = (yy_current_state == 0);" );
call    0 returned 195
        -: 3348:		}
        -: 3349:
      348: 3350:	else if ( fulltbl )
branch  0 taken 1 (fallthrough)
branch  1 taken 347
        -: 3351:		{
        1: 3352:		do_indent();
call    0 returned 1
        1: 3353:		out_dec( "yy_current_state = yy_nxt[yy_current_state][%d];\n",
call    0 returned 1
        -: 3354:			NUL_ec );
        1: 3355:		indent_puts( "yy_is_jam = (yy_current_state <= 0);" );
call    0 returned 1
        -: 3356:		}
        -: 3357:
      347: 3358:	else if ( fullspd )
branch  0 taken 92 (fallthrough)
branch  1 taken 255
        -: 3359:		{
       92: 3360:		do_indent();
call    0 returned 92
       92: 3361:		out_dec( "register int yy_c = %d;\n", NUL_ec );
call    0 returned 92
        -: 3362:
       92: 3363:		indent_puts(
call    0 returned 92
        -: 3364:		"register yyconst struct yy_trans_info *yy_trans_info;\n" );
       92: 3365:		indent_puts(
call    0 returned 92
        -: 3366:		"yy_trans_info = &yy_current_state[(unsigned int) yy_c];" );
       92: 3367:		indent_puts( "yy_current_state += yy_trans_info->yy_nxt;" );
call    0 returned 92
        -: 3368:
       92: 3369:		indent_puts(
call    0 returned 92
        -: 3370:			"yy_is_jam = (yy_trans_info->yy_verify != yy_c);" );
        -: 3371:		}
        -: 3372:
        -: 3373:	else
        -: 3374:		{
        -: 3375:		char NUL_ec_str[20];
        -: 3376:
      255: 3377:		(void) sprintf( NUL_ec_str, "%d", NUL_ec );
      255: 3378:		gen_next_compressed_state( NUL_ec_str );
call    0 returned 255
        -: 3379:
      255: 3380:		do_indent();
call    0 returned 255
      255: 3381:		out_dec( "yy_is_jam = (yy_current_state == %d);\n", jamstate );
call    0 returned 255
        -: 3382:
      255: 3383:		if ( reject )
branch  0 taken 98 (fallthrough)
branch  1 taken 157
        -: 3384:			{
        -: 3385:			/* Only stack this state if it's a transition we
        -: 3386:			 * actually make.  If we stack it on a jam, then
        -: 3387:			 * the state stack and yy_c_buf_p get out of sync.
        -: 3388:			 */
       98: 3389:			indent_puts( "if ( ! yy_is_jam )" );
call    0 returned 98
       98: 3390:			indent_up();
       98: 3391:			indent_puts( "*yy_state_ptr++ = yy_current_state;" );
call    0 returned 98
       98: 3392:			indent_down();
        -: 3393:			}
        -: 3394:		}
        -: 3395:
        -: 3396:	/* If we've entered an accepting state, back up; note that
        -: 3397:	 * compressed tables have *already* done such backing up, so
        -: 3398:	 * we needn't bother with it again.
        -: 3399:	 */
      543: 3400:	if ( need_backing_up && (fullspd || fulltbl) )
branch  0 taken 373 (fallthrough)
branch  1 taken 170
branch  2 taken 281 (fallthrough)
branch  3 taken 92
branch  4 taken 21 (fallthrough)
branch  5 taken 260
        -: 3401:		{
      113: 3402:		outc( '\n' );
call    0 returned 113
      113: 3403:		indent_puts( "if ( ! yy_is_jam )" );
call    0 returned 113
      113: 3404:		indent_up();
      113: 3405:		indent_puts( "{" );
call    0 returned 113
      113: 3406:		gen_backing_up();
call    0 returned 113
      113: 3407:		indent_puts( "}" );
call    0 returned 113
      113: 3408:		indent_down();
        -: 3409:		}
      543: 3410:	}
        -: 3411:
        -: 3412:
        -: 3413:/* Generate the code to find the start state. */
        -: 3414:
function gen_start_state called 1086 returned 100% blocks executed 100%
     1086: 3415:void gen_start_state()
        -: 3416:	{
     1086: 3417:	if ( fullspd )
branch  0 taken 184 (fallthrough)
branch  1 taken 902
        -: 3418:		{
      184: 3419:		if ( bol_needed )
branch  0 taken 36 (fallthrough)
branch  1 taken 148
        -: 3420:			{
       36: 3421:			indent_puts(
call    0 returned 36
        -: 3422:	"yy_current_state = yy_start_state_list[yy_start + YY_AT_BOL()];" );
        -: 3423:			}
        -: 3424:		else
      148: 3425:			indent_puts(
call    0 returned 148
        -: 3426:			"yy_current_state = yy_start_state_list[yy_start];" );
        -: 3427:		}
        -: 3428:
        -: 3429:	else
        -: 3430:		{
      902: 3431:		indent_puts( "yy_current_state = yy_start;" );
call    0 returned 902
        -: 3432:
      902: 3433:		if ( bol_needed )
branch  0 taken 162 (fallthrough)
branch  1 taken 740
      162: 3434:			indent_puts( "yy_current_state += YY_AT_BOL();" );
call    0 returned 162
        -: 3435:
      902: 3436:		if ( reject )
branch  0 taken 336 (fallthrough)
branch  1 taken 566
        -: 3437:			{
        -: 3438:			/* Set up for storing up states. */
      336: 3439:			indent_puts( "yy_state_ptr = yy_state_buf;" );
call    0 returned 336
      336: 3440:			indent_puts( "*yy_state_ptr++ = yy_current_state;" );
call    0 returned 336
        -: 3441:			}
        -: 3442:		}
     1086: 3443:	}
        -: 3444:
        -: 3445:
        -: 3446:/* gentabs - generate data statements for the transition tables */
        -: 3447:
function gentabs called 428 returned 100% blocks executed 100%
      428: 3448:void gentabs()
        -: 3449:	{
        -: 3450:	int i, j, k, *accset, nacc, *acc_array, total_states;
      428: 3451:	int end_of_buffer_action = num_rules + 1;
        -: 3452:
      428: 3453:	acc_array = allocate_integer_array( current_max_dfas );
call    0 returned 428
      428: 3454:	nummt = 0;
        -: 3455:
        -: 3456:	/* The compressed table format jams by entering the "jam state",
        -: 3457:	 * losing information about the previous state in the process.
        -: 3458:	 * In order to recover the previous state, we effectively need
        -: 3459:	 * to keep backing-up information.
        -: 3460:	 */
      428: 3461:	++num_backing_up;
        -: 3462:
      428: 3463:	if ( reject )
branch  0 taken 168 (fallthrough)
branch  1 taken 260
        -: 3464:		{
        -: 3465:		/* Write out accepting list and pointer list.
        -: 3466:		 *
        -: 3467:		 * First we generate the "yy_acclist" array.  In the process,
        -: 3468:		 * we compute the indices that will go into the "yy_accept"
        -: 3469:		 * array, and save the indices in the dfaacc array.
        -: 3470:		 */
        -: 3471:		int EOB_accepting_list[2];
        -: 3472:
        -: 3473:		/* Set up accepting structures for the End Of Buffer state. */
      168: 3474:		EOB_accepting_list[0] = 0;
      168: 3475:		EOB_accepting_list[1] = end_of_buffer_action;
      168: 3476:		accsiz[end_of_buffer_state] = 1;
      168: 3477:		dfaacc[end_of_buffer_state].dfaacc_set = EOB_accepting_list;
        -: 3478:
      168: 3479:		out_str_dec( long_align ? C_long_decl : C_short_decl,
call    0 returned 168
      168: 3480:			"yy_acclist", MAX( numas, 1 ) + 1 );
branch  0 taken 79 (fallthrough)
branch  1 taken 89
        -: 3481:
      168: 3482:		j = 1;	/* index into "yy_acclist" array */
        -: 3483:
     5347: 3484:		for ( i = 1; i <= lastdfa; ++i )
branch  0 taken 5179
branch  1 taken 168 (fallthrough)
        -: 3485:			{
     5179: 3486:			acc_array[i] = j;
        -: 3487:
     5179: 3488:			if ( accsiz[i] != 0 )
branch  0 taken 4209 (fallthrough)
branch  1 taken 970
        -: 3489:				{
     4209: 3490:				accset = dfaacc[i].dfaacc_set;
     4209: 3491:				nacc = accsiz[i];
        -: 3492:
     4209: 3493:				if ( trace )
branch  0 taken 1224 (fallthrough)
branch  1 taken 2985
     1224: 3494:					fprintf( err,
call    0 returned 1224
        -: 3495:						_( "state # %d accepts: " ),
        -: 3496:						i );
        -: 3497:
    14774: 3498:				for ( k = 1; k <= nacc; ++k )
branch  0 taken 10565
branch  1 taken 4209 (fallthrough)
        -: 3499:					{
    10565: 3500:					int accnum = accset[k];
        -: 3501:
    10565: 3502:					++j;
        -: 3503:
    10565: 3504:					if ( variable_trailing_context_rules &&
branch  0 taken 607 (fallthrough)
branch  1 taken 9958
      607: 3505:					  ! (accnum & YY_TRAILING_HEAD_MASK) &&
branch  0 taken 541 (fallthrough)
branch  1 taken 66
branch  2 taken 541 (fallthrough)
branch  3 taken 0
      541: 3506:					   accnum > 0 && accnum <= num_rules &&
branch  0 taken 508 (fallthrough)
branch  1 taken 33
      508: 3507:					  rule_type[accnum] == RULE_VARIABLE )
branch  0 taken 66 (fallthrough)
branch  1 taken 442
        -: 3508:						{
        -: 3509:						/* Special hack to flag
        -: 3510:						 * accepting number as part
        -: 3511:						 * of trailing context rule.
        -: 3512:						 */
       66: 3513:						accnum |= YY_TRAILING_MASK;
        -: 3514:						}
        -: 3515:
    10565: 3516:					mkdata( accnum );
call    0 returned 10565
        -: 3517:
    10565: 3518:					if ( trace )
branch  0 taken 6155 (fallthrough)
branch  1 taken 4410
        -: 3519:						{
     6155: 3520:						fprintf( err, "[%d]",
     6155: 3521:							accset[k] );
call    0 returned 6155
        -: 3522:
     6155: 3523:						if ( k < nacc )
branch  0 taken 4931 (fallthrough)
branch  1 taken 1224
     4931: 3524:							fputs( ", ", err );
call    0 returned 4931
        -: 3525:						else
     1224: 3526:							putc( '\n', err );
call    0 returned 1224
        -: 3527:						}
        -: 3528:					}
        -: 3529:				}
        -: 3530:			}
        -: 3531:
        -: 3532:		/* add accepting number for the "jam" state */
      168: 3533:		acc_array[i] = j;
        -: 3534:
      168: 3535:		dataend();
call    0 returned 168
        -: 3536:		}
        -: 3537:
        -: 3538:	else
        -: 3539:		{
      260: 3540:		dfaacc[end_of_buffer_state].dfaacc_state = end_of_buffer_action;
        -: 3541:
     6347: 3542:		for ( i = 1; i <= lastdfa; ++i )
branch  0 taken 6087
branch  1 taken 260 (fallthrough)
     6087: 3543:			acc_array[i] = dfaacc[i].dfaacc_state;
        -: 3544:
        -: 3545:		/* add accepting number for jam state */
      260: 3546:		acc_array[i] = 0;
        -: 3547:		}
        -: 3548:
        -: 3549:	/* Spit out "yy_accept" array.  If we're doing "reject", it'll be
        -: 3550:	 * pointers into the "yy_acclist" array.  Otherwise it's actual
        -: 3551:	 * accepting numbers.  In either case, we just dump the numbers.
        -: 3552:	 */
        -: 3553:
        -: 3554:	/* "lastdfa + 2" is the size of "yy_accept"; includes room for C arrays
        -: 3555:	 * beginning at 0 and for "jam" state.
        -: 3556:	 */
      428: 3557:	k = lastdfa + 2;
        -: 3558:
      428: 3559:	if ( reject )
branch  0 taken 168 (fallthrough)
branch  1 taken 260
        -: 3560:		/* We put a "cap" on the table associating lists of accepting
        -: 3561:		 * numbers with state numbers.  This is needed because we tell
        -: 3562:		 * where the end of an accepting list is by looking at where
        -: 3563:		 * the list for the next state starts.
        -: 3564:		 */
      168: 3565:		++k;
        -: 3566:
      428: 3567:	out_str_dec( long_align ? C_long_decl : C_short_decl, "yy_accept", k );
branch  0 taken 200 (fallthrough)
branch  1 taken 228
call    2 returned 428
        -: 3568:
    11694: 3569:	for ( i = 1; i <= lastdfa; ++i )
branch  0 taken 11266
branch  1 taken 428 (fallthrough)
        -: 3570:		{
    11266: 3571:		mkdata( acc_array[i] );
call    0 returned 11266
        -: 3572:
    11266: 3573:		if ( ! reject && trace && acc_array[i] )
branch  0 taken 6087 (fallthrough)
branch  1 taken 5179
branch  2 taken 129 (fallthrough)
branch  3 taken 5958
branch  4 taken 93 (fallthrough)
branch  5 taken 36
       93: 3574:			fprintf( err, _( "state # %d accepts: [%d]\n" ),
       93: 3575:				i, acc_array[i] );
call    0 returned 93
        -: 3576:		}
        -: 3577:
        -: 3578:	/* Add entry for "jam" state. */
      428: 3579:	mkdata( acc_array[i] );
call    0 returned 428
        -: 3580:
      428: 3581:	if ( reject )
branch  0 taken 168 (fallthrough)
branch  1 taken 260
        -: 3582:		/* Add "cap" for the list. */
      168: 3583:		mkdata( acc_array[i] );
call    0 returned 168
        -: 3584:
      428: 3585:	dataend();
call    0 returned 428
        -: 3586:
      428: 3587:	if ( useecs )
branch  0 taken 255 (fallthrough)
branch  1 taken 173
      255: 3588:		genecs();
call    0 returned 255
        -: 3589:
      428: 3590:	if ( usemecs )
branch  0 taken 215 (fallthrough)
branch  1 taken 213
        -: 3591:		{
        -: 3592:		/* Write out meta-equivalence classes (used to index
        -: 3593:		 * templates with).
        -: 3594:		 */
        -: 3595:
      215: 3596:		if ( trace )
branch  0 taken 13 (fallthrough)
branch  1 taken 202
       13: 3597:			fputs( _( "\n\nMeta-Equivalence Classes:\n" ),
call    0 returned 13
        -: 3598:			      err );
        -: 3599:
      215: 3600:		out_str_dec( C_int_decl, "yy_meta", numecs + 1 );
call    0 returned 215
        -: 3601:
    22533: 3602:		for ( i = 1; i <= numecs; ++i )
branch  0 taken 22318
branch  1 taken 215 (fallthrough)
        -: 3603:			{
    22318: 3604:			if ( trace )
branch  0 taken 204 (fallthrough)
branch  1 taken 22114
      204: 3605:				fprintf( err, "%d = %d\n",
      204: 3606:					i, ABS( tecbck[i] ) );
call    0 returned 204
        -: 3607:
    22318: 3608:			mkdata( ABS( tecbck[i] ) );
call    0 returned 22318
        -: 3609:			}
        -: 3610:
      215: 3611:		dataend();
call    0 returned 215
        -: 3612:		}
        -: 3613:
      428: 3614:	total_states = lastdfa + numtemps;
        -: 3615:
      428: 3616:	out_str_dec( (tblend >= MAX_SHORT || long_align) ?
branch  0 taken 428 (fallthrough)
branch  1 taken 0
branch  2 taken 200 (fallthrough)
branch  3 taken 228
call    4 returned 428
        -: 3617:			C_long_decl : C_short_decl,
        -: 3618:		"yy_base", total_states + 1 );
        -: 3619:
    11694: 3620:	for ( i = 1; i <= lastdfa; ++i )
branch  0 taken 11266
branch  1 taken 428 (fallthrough)
        -: 3621:		{
    11266: 3622:		register int d = def[i];
        -: 3623:
    11266: 3624:		if ( base[i] == JAMSTATE )
branch  0 taken 1943 (fallthrough)
branch  1 taken 9323
     1943: 3625:			base[i] = jambase;
        -: 3626:
    11266: 3627:		if ( d == JAMSTATE )
branch  0 taken 7474 (fallthrough)
branch  1 taken 3792
     7474: 3628:			def[i] = jamstate;
        -: 3629:
     3792: 3630:		else if ( d < 0 )
branch  0 taken 2479 (fallthrough)
branch  1 taken 1313
        -: 3631:			{
        -: 3632:			/* Template reference. */
     2479: 3633:			++tmpuses;
     2479: 3634:			def[i] = lastdfa - d + 1;
        -: 3635:			}
        -: 3636:
    11266: 3637:		mkdata( base[i] );
call    0 returned 11266
        -: 3638:		}
        -: 3639:
        -: 3640:	/* Generate jam state's base index. */
      428: 3641:	mkdata( base[i] );
call    0 returned 428
        -: 3642:
     1053: 3643:	for ( ++i /* skip jam state */; i <= total_states; ++i )
branch  0 taken 625
branch  1 taken 428 (fallthrough)
        -: 3644:		{
      625: 3645:		mkdata( base[i] );
call    0 returned 625
      625: 3646:		def[i] = jamstate;
        -: 3647:		}
        -: 3648:
      428: 3649:	dataend();
call    0 returned 428
        -: 3650:
      428: 3651:	out_str_dec( (total_states >= MAX_SHORT || long_align) ?
branch  0 taken 428 (fallthrough)
branch  1 taken 0
branch  2 taken 200 (fallthrough)
branch  3 taken 228
call    4 returned 428
        -: 3652:			C_long_decl : C_short_decl,
        -: 3653:		"yy_def", total_states + 1 );
        -: 3654:
    12747: 3655:	for ( i = 1; i <= total_states; ++i )
branch  0 taken 12319
branch  1 taken 428 (fallthrough)
    12319: 3656:		mkdata( def[i] );
call    0 returned 12319
        -: 3657:
      428: 3658:	dataend();
call    0 returned 428
        -: 3659:
      428: 3660:	out_str_dec( (total_states >= MAX_SHORT || long_align) ?
branch  0 taken 428 (fallthrough)
branch  1 taken 0
branch  2 taken 200 (fallthrough)
branch  3 taken 228
call    4 returned 428
        -: 3661:			C_long_decl : C_short_decl,
        -: 3662:		"yy_nxt", tblend + 1 );
        -: 3663:
   159041: 3664:	for ( i = 1; i <= tblend; ++i )
branch  0 taken 158613
branch  1 taken 428 (fallthrough)
        -: 3665:		{
        -: 3666:		/* Note, the order of the following test is important.
        -: 3667:		 * If chk[i] is 0, then nxt[i] is undefined.
        -: 3668:		 */
   158613: 3669:		if ( chk[i] == 0 || nxt[i] == 0 )
branch  0 taken 137420 (fallthrough)
branch  1 taken 21193
branch  2 taken 48234 (fallthrough)
branch  3 taken 89186
    69427: 3670:			nxt[i] = jamstate;	/* new state is the JAM state */
        -: 3671:
   158613: 3672:		mkdata( nxt[i] );
call    0 returned 158613
        -: 3673:		}
        -: 3674:
      428: 3675:	dataend();
call    0 returned 428
        -: 3676:
      428: 3677:	out_str_dec( (total_states >= MAX_SHORT || long_align) ?
branch  0 taken 428 (fallthrough)
branch  1 taken 0
branch  2 taken 200 (fallthrough)
branch  3 taken 228
call    4 returned 428
        -: 3678:			C_long_decl : C_short_decl,
        -: 3679:		"yy_chk", tblend + 1 );
        -: 3680:
   159041: 3681:	for ( i = 1; i <= tblend; ++i )
branch  0 taken 158613
branch  1 taken 428 (fallthrough)
        -: 3682:		{
   158613: 3683:		if ( chk[i] == 0 )
branch  0 taken 21193 (fallthrough)
branch  1 taken 137420
    21193: 3684:			++nummt;
        -: 3685:
   158613: 3686:		mkdata( chk[i] );
call    0 returned 158613
        -: 3687:		}
        -: 3688:
      428: 3689:	dataend();
call    0 returned 428
      428: 3690:	}
        -: 3691:
        -: 3692:
        -: 3693:/* Write out a formatted string (with a secondary string argument) at the
        -: 3694: * current indentation level, adding a final newline.
        -: 3695: */
        -: 3696:
function indent_put2s called 1525 returned 100% blocks executed 100%
     1525: 3697:void indent_put2s( fmt, arg )
        -: 3698:char fmt[], arg[];
        -: 3699:	{
     1525: 3700:	do_indent();
call    0 returned 1525
     1525: 3701:	out_str( fmt, arg );
call    0 returned 1525
     1525: 3702:	outn( "" );
call    0 returned 1525
     1525: 3703:	}
        -: 3704:
        -: 3705:
        -: 3706:/* Write out a string at the current indentation level, adding a final
        -: 3707: * newline.
        -: 3708: */
        -: 3709:
function indent_puts called 39782 returned 100% blocks executed 100%
    39782: 3710:void indent_puts( str )
        -: 3711:char str[];
        -: 3712:	{
    39782: 3713:	do_indent();
call    0 returned 39782
    39782: 3714:	outn( str );
call    0 returned 39782
    39782: 3715:	}
        -: 3716:
        -: 3717:
        -: 3718:/* make_tables - generate transition tables and finishes generating output file
        -: 3719: */
        -: 3720:
function make_tables called 543 returned 100% blocks executed 97%
      543: 3721:void make_tables()
        -: 3722:	{
        -: 3723:	register int i;
      543: 3724:	int did_eof_rule = false;
        -: 3725:
      543: 3726:	skelout();
call    0 returned 543
        -: 3727:
        -: 3728:	/* First, take care of YY_DO_BEFORE_ACTION depending on yymore
        -: 3729:	 * being used.
        -: 3730:	 */
      543: 3731:	set_indent( 1 );
        -: 3732:
      543: 3733:	if ( yymore_used && ! yytext_is_array )
branch  0 taken 166 (fallthrough)
branch  1 taken 377
branch  2 taken 5 (fallthrough)
branch  3 taken 161
        -: 3734:		{
        5: 3735:		indent_puts( "yytext_ptr -= yy_more_len; \\" );
call    0 returned 5
        5: 3736:		indent_puts( "yyleng = (int) (yy_cp - yytext_ptr); \\" );
call    0 returned 5
        -: 3737:		}
        -: 3738:
        -: 3739:	else
      538: 3740:		indent_puts( "yyleng = (int) (yy_cp - yy_bp); \\" );
call    0 returned 538
        -: 3741:
        -: 3742:	/* Now also deal with copying yytext_ptr to yytext if needed. */
      543: 3743:	skelout();
call    0 returned 543
      543: 3744:	if ( yytext_is_array )
branch  0 taken 161 (fallthrough)
branch  1 taken 382
        -: 3745:		{
      161: 3746:		if ( yymore_used )
branch  0 taken 161 (fallthrough)
branch  1 taken 0
      161: 3747:			indent_puts(
call    0 returned 161
        -: 3748:				"if ( yyleng + yy_more_offset >= YYLMAX ) \\" );
        -: 3749:		else
    #####: 3750:			indent_puts( "if ( yyleng >= YYLMAX ) \\" );
call    0 never executed
        -: 3751:
      161: 3752:		indent_up();
      161: 3753:		indent_puts(
call    0 returned 161
        -: 3754:		"YY_FATAL_ERROR( \"token too large, exceeds YYLMAX\" ); \\" );
      161: 3755:		indent_down();
        -: 3756:
      161: 3757:		if ( yymore_used )
branch  0 taken 161 (fallthrough)
branch  1 taken 0
        -: 3758:			{
      161: 3759:			indent_puts(
call    0 returned 161
        -: 3760:"yy_flex_strncpy( &yytext[yy_more_offset], yytext_ptr, yyleng + 1 ); \\" );
      161: 3761:			indent_puts( "yyleng += yy_more_offset; \\" );
call    0 returned 161
      161: 3762:			indent_puts(
call    0 returned 161
        -: 3763:				"yy_prev_more_offset = yy_more_offset; \\" );
      161: 3764:			indent_puts( "yy_more_offset = 0; \\" );
call    0 returned 161
        -: 3765:			}
        -: 3766:		else
        -: 3767:			{
    #####: 3768:			indent_puts(
call    0 never executed
        -: 3769:		"yy_flex_strncpy( yytext, yytext_ptr, yyleng + 1 ); \\" );
        -: 3770:			}
        -: 3771:		}
        -: 3772:
      543: 3773:	set_indent( 0 );
        -: 3774:
      543: 3775:	skelout();
call    0 returned 543
        -: 3776:
        -: 3777:
      543: 3778:	out_dec( "#define YY_NUM_RULES %d\n", num_rules );
call    0 returned 543
      543: 3779:	out_dec( "#define YY_END_OF_BUFFER %d\n", num_rules + 1 );
call    0 returned 543
        -: 3780:
      543: 3781:	if ( fullspd )
branch  0 taken 92 (fallthrough)
branch  1 taken 451
        -: 3782:		{
        -: 3783:		/* Need to define the transet type as a size large
        -: 3784:		 * enough to hold the biggest offset.
        -: 3785:		 */
       92: 3786:		int total_table_size = tblend + numecs + 1;
       92: 3787:		char *trans_offset_type =
       92: 3788:			(total_table_size >= MAX_SHORT || long_align) ?
branch  0 taken 40 (fallthrough)
branch  1 taken 52
      184: 3789:				"long" : "short";
branch  0 taken 92 (fallthrough)
branch  1 taken 0
        -: 3790:
       92: 3791:		set_indent( 0 );
       92: 3792:		indent_puts( "struct yy_trans_info" );
call    0 returned 92
       92: 3793:		indent_up();
       92: 3794:		indent_puts( "{" ); 	/* } for vi */
call    0 returned 92
        -: 3795:
       92: 3796:		if ( long_align )
branch  0 taken 40 (fallthrough)
branch  1 taken 52
       40: 3797:			indent_puts( "long yy_verify;" );
call    0 returned 40
        -: 3798:		else
       52: 3799:			indent_puts( "short yy_verify;" );
call    0 returned 52
        -: 3800:
        -: 3801:		/* In cases where its sister yy_verify *is* a "yes, there is
        -: 3802:		 * a transition", yy_nxt is the offset (in records) to the
        -: 3803:		 * next state.  In most cases where there is no transition,
        -: 3804:		 * the value of yy_nxt is irrelevant.  If yy_nxt is the -1th
        -: 3805:		 * record of a state, though, then yy_nxt is the action number
        -: 3806:		 * for that state.
        -: 3807:		 */
        -: 3808:
       92: 3809:		indent_put2s( "%s yy_nxt;", trans_offset_type );
call    0 returned 92
       92: 3810:		indent_puts( "};" );
call    0 returned 92
       92: 3811:		indent_down();
        -: 3812:		}
        -: 3813:
      543: 3814:	if ( fullspd )
branch  0 taken 92 (fallthrough)
branch  1 taken 451
       92: 3815:		genctbl();
call    0 returned 92
      451: 3816:	else if ( fulltbl )
branch  0 taken 23 (fallthrough)
branch  1 taken 428
       23: 3817:		genftbl();
call    0 returned 23
        -: 3818:	else
      428: 3819:		gentabs();
call    0 returned 428
        -: 3820:
        -: 3821:	/* Definitions for backing up.  We don't need them if REJECT
        -: 3822:	 * is being used because then we use an alternative backin-up
        -: 3823:	 * technique instead.
        -: 3824:	 */
      543: 3825:	if ( num_backing_up > 0 && ! reject )
branch  0 taken 541 (fallthrough)
branch  1 taken 2
branch  2 taken 373 (fallthrough)
branch  3 taken 168
        -: 3826:		{
      373: 3827:		if ( ! C_plus_plus )
branch  0 taken 373 (fallthrough)
branch  1 taken 0
        -: 3828:			{
      373: 3829:			indent_puts(
call    0 returned 373
        -: 3830:			"static yy_state_type yy_last_accepting_state;" );
      373: 3831:			indent_puts(
call    0 returned 373
        -: 3832:				"static char *yy_last_accepting_cpos;\n" );
        -: 3833:			}
        -: 3834:		}
        -: 3835:
      543: 3836:	if ( nultrans )
branch  0 taken 195 (fallthrough)
branch  1 taken 348
        -: 3837:		{
      195: 3838:		out_str_dec( C_state_decl, "yy_NUL_trans", lastdfa + 1 );
call    0 returned 195
        -: 3839:
     4899: 3840:		for ( i = 1; i <= lastdfa; ++i )
branch  0 taken 4704
branch  1 taken 195 (fallthrough)
        -: 3841:			{
     4704: 3842:			if ( fullspd )
branch  0 taken 0 (fallthrough)
branch  1 taken 4704
    #####: 3843:				out_dec( "    &yy_transition[%d],\n", base[i] );
call    0 never executed
        -: 3844:			else
     4704: 3845:				mkdata( nultrans[i] );
call    0 returned 4704
        -: 3846:			}
        -: 3847:
      195: 3848:		dataend();
call    0 returned 195
        -: 3849:		}
        -: 3850:
      543: 3851:	if ( ddebug )
branch  0 taken 252 (fallthrough)
branch  1 taken 291
        -: 3852:		{ /* Spit out table mapping rules to line numbers. */
      252: 3853:		if ( ! C_plus_plus )
branch  0 taken 252 (fallthrough)
branch  1 taken 0
        -: 3854:			{
      252: 3855:			indent_puts( "extern int yy_flex_debug;" );
call    0 returned 252
      252: 3856:			indent_puts( "int yy_flex_debug = 1;\n" );
call    0 returned 252
        -: 3857:			}
        -: 3858:
      252: 3859:		out_str_dec( long_align ? C_long_decl : C_short_decl,
branch  0 taken 120 (fallthrough)
branch  1 taken 132
call    2 returned 252
        -: 3860:			"yy_rule_linenum", num_rules );
     1531: 3861:		for ( i = 1; i < num_rules; ++i )
branch  0 taken 1279
branch  1 taken 252 (fallthrough)
     1279: 3862:			mkdata( rule_linenum[i] );
call    0 returned 1279
      252: 3863:		dataend();
call    0 returned 252
        -: 3864:		}
        -: 3865:
      543: 3866:	if ( reject )
branch  0 taken 168 (fallthrough)
branch  1 taken 375
        -: 3867:		{
        -: 3868:		/* Declare state buffer variables. */
      168: 3869:		if ( ! C_plus_plus )
branch  0 taken 168 (fallthrough)
branch  1 taken 0
        -: 3870:			{
      168: 3871:			outn(
call    0 returned 168
        -: 3872:	"static yy_state_type yy_state_buf[YY_BUF_SIZE + 2], *yy_state_ptr;" );
      168: 3873:			outn( "static char *yy_full_match;" );
call    0 returned 168
      168: 3874:			outn( "static int yy_lp;" );
call    0 returned 168
        -: 3875:			}
        -: 3876:
      168: 3877:		if ( variable_trailing_context_rules )
branch  0 taken 33 (fallthrough)
branch  1 taken 135
        -: 3878:			{
       33: 3879:			if ( ! C_plus_plus )
branch  0 taken 33 (fallthrough)
branch  1 taken 0
        -: 3880:				{
       33: 3881:				outn(
call    0 returned 33
        -: 3882:				"static int yy_looking_for_trail_begin = 0;" );
       33: 3883:				outn( "static int yy_full_lp;" );
call    0 returned 33
       33: 3884:				outn( "static int *yy_full_state;" );
call    0 returned 33
        -: 3885:				}
        -: 3886:
       33: 3887:			out_hex( "#define YY_TRAILING_MASK 0x%x\n",
call    0 returned 33
        -: 3888:				(unsigned int) YY_TRAILING_MASK );
       33: 3889:			out_hex( "#define YY_TRAILING_HEAD_MASK 0x%x\n",
call    0 returned 33
        -: 3890:				(unsigned int) YY_TRAILING_HEAD_MASK );
        -: 3891:			}
        -: 3892:
      168: 3893:		outn( "#define REJECT \\" );
call    0 returned 168
      168: 3894:		outn( "{ \\" );		/* } for vi */
call    0 returned 168
      168: 3895:		outn(
call    0 returned 168
        -: 3896:	"*yy_cp = yy_hold_char; /* undo effects of setting up yytext */ \\" );
      168: 3897:		outn(
call    0 returned 168
        -: 3898:	"yy_cp = yy_full_match; /* restore poss. backed-over text */ \\" );
        -: 3899:
      168: 3900:		if ( variable_trailing_context_rules )
branch  0 taken 33 (fallthrough)
branch  1 taken 135
        -: 3901:			{
       33: 3902:			outn(
call    0 returned 33
        -: 3903:		"yy_lp = yy_full_lp; /* restore orig. accepting pos. */ \\" );
       33: 3904:			outn(
call    0 returned 33
        -: 3905:		"yy_state_ptr = yy_full_state; /* restore orig. state */ \\" );
       33: 3906:			outn(
call    0 returned 33
        -: 3907:	"yy_current_state = *yy_state_ptr; /* restore curr. state */ \\" );
        -: 3908:			}
        -: 3909:
      168: 3910:		outn( "++yy_lp; \\" );
call    0 returned 168
      168: 3911:		outn( "goto find_rule; \\" );
call    0 returned 168
        -: 3912:		/* { for vi */
      168: 3913:		outn( "}" );
call    0 returned 168
        -: 3914:		}
        -: 3915:
        -: 3916:	else
        -: 3917:		{
      375: 3918:		outn(
call    0 returned 375
        -: 3919:		"/* The intent behind this definition is that it'll catch" );
      375: 3920:		outn( " * any uses of REJECT which flex missed." );
call    0 returned 375
      375: 3921:		outn( " */" );
call    0 returned 375
      375: 3922:		outn( "#define REJECT reject_used_but_not_detected" );
call    0 returned 375
        -: 3923:		}
        -: 3924:
      543: 3925:	if ( yymore_used )
branch  0 taken 166 (fallthrough)
branch  1 taken 377
        -: 3926:		{
      166: 3927:		if ( ! C_plus_plus )
branch  0 taken 166 (fallthrough)
branch  1 taken 0
        -: 3928:			{
      166: 3929:			if ( yytext_is_array )
branch  0 taken 161 (fallthrough)
branch  1 taken 5
        -: 3930:				{
      161: 3931:				indent_puts( "static int yy_more_offset = 0;" );
call    0 returned 161
      161: 3932:				indent_puts(
call    0 returned 161
        -: 3933:					"static int yy_prev_more_offset = 0;" );
        -: 3934:				}
        -: 3935:			else
        -: 3936:				{
        5: 3937:				indent_puts( "static int yy_more_flag = 0;" );
call    0 returned 5
        5: 3938:				indent_puts( "static int yy_more_len = 0;" );
call    0 returned 5
        -: 3939:				}
        -: 3940:			}
        -: 3941:
      166: 3942:		if ( yytext_is_array )
branch  0 taken 161 (fallthrough)
branch  1 taken 5
        -: 3943:			{
      161: 3944:			indent_puts(
call    0 returned 161
        -: 3945:	"#define yymore() (yy_more_offset = yy_flex_strlen( yytext ))" );
      161: 3946:			indent_puts( "#define YY_NEED_STRLEN" );
call    0 returned 161
      161: 3947:			indent_puts( "#define YY_MORE_ADJ 0" );
call    0 returned 161
      161: 3948:			indent_puts( "#define YY_RESTORE_YY_MORE_OFFSET \\" );
call    0 returned 161
      161: 3949:			indent_up();
      161: 3950:			indent_puts( "{ \\" );
call    0 returned 161
      161: 3951:			indent_puts( "yy_more_offset = yy_prev_more_offset; \\" );
call    0 returned 161
      161: 3952:			indent_puts( "yyleng -= yy_more_offset; \\" );
call    0 returned 161
      161: 3953:			indent_puts( "}" );
call    0 returned 161
      161: 3954:			indent_down();
        -: 3955:			}
        -: 3956:		else
        -: 3957:			{
        5: 3958:			indent_puts( "#define yymore() (yy_more_flag = 1)" );
call    0 returned 5
        5: 3959:			indent_puts( "#define YY_MORE_ADJ yy_more_len" );
call    0 returned 5
        5: 3960:			indent_puts( "#define YY_RESTORE_YY_MORE_OFFSET" );
call    0 returned 5
        -: 3961:			}
        -: 3962:		}
        -: 3963:
        -: 3964:	else
        -: 3965:		{
      377: 3966:		indent_puts( "#define yymore() yymore_used_but_not_detected" );
call    0 returned 377
      377: 3967:		indent_puts( "#define YY_MORE_ADJ 0" );
call    0 returned 377
      377: 3968:		indent_puts( "#define YY_RESTORE_YY_MORE_OFFSET" );
call    0 returned 377
        -: 3969:		}
        -: 3970:
      543: 3971:	if ( ! C_plus_plus )
branch  0 taken 543 (fallthrough)
branch  1 taken 0
        -: 3972:		{
      543: 3973:		if ( yytext_is_array )
branch  0 taken 161 (fallthrough)
branch  1 taken 382
        -: 3974:			{
      161: 3975:			outn( "#ifndef YYLMAX" );
call    0 returned 161
      161: 3976:			outn( "#define YYLMAX 8192" );
call    0 returned 161
      161: 3977:			outn( "#endif\n" );
call    0 returned 161
      161: 3978:			outn( "char yytext[YYLMAX];" );
call    0 returned 161
      161: 3979:			outn( "char *yytext_ptr;" );
call    0 returned 161
        -: 3980:			}
        -: 3981:
        -: 3982:		else
      382: 3983:			outn( "char *yytext;" );
call    0 returned 382
        -: 3984:		}
        -: 3985:
      543: 3986:	out( &action_array[defs1_offset] );
call    0 returned 543
        -: 3987:
      543: 3988:	line_directive_out( stdout, 0 );
call    0 returned 543
        -: 3989:
      543: 3990:	skelout();
call    0 returned 543
        -: 3991:
      543: 3992:	if ( ! C_plus_plus )
branch  0 taken 543 (fallthrough)
branch  1 taken 0
        -: 3993:		{
      543: 3994:		if ( use_read )
branch  0 taken 240 (fallthrough)
branch  1 taken 303
        -: 3995:			{
      240: 3996:			outn(
call    0 returned 240
        -: 3997:"\tif ( (result = read( fileno(yyin), (char *) buf, max_size )) < 0 ) \\" );
      240: 3998:			outn(
call    0 returned 240
        -: 3999:		"\t\tYY_FATAL_ERROR( \"input in flex scanner failed\" );" );
        -: 4000:			}
        -: 4001:
        -: 4002:		else
        -: 4003:			{
      303: 4004:			outn(
call    0 returned 303
        -: 4005:			"\tif ( yy_current_buffer->yy_is_interactive ) \\" );
      303: 4006:			outn( "\t\t{ \\" );
call    0 returned 303
      303: 4007:			outn( "\t\tint c = '*', n; \\" );
call    0 returned 303
      303: 4008:			outn( "\t\tfor ( n = 0; n < max_size && \\" );
call    0 returned 303
      303: 4009:	outn( "\t\t\t     (c = getc( yyin )) != EOF && c != '\\n'; ++n ) \\" );
call    0 returned 303
      303: 4010:			outn( "\t\t\tbuf[n] = (char) c; \\" );
call    0 returned 303
      303: 4011:			outn( "\t\tif ( c == '\\n' ) \\" );
call    0 returned 303
      303: 4012:			outn( "\t\t\tbuf[n++] = (char) c; \\" );
call    0 returned 303
      303: 4013:			outn( "\t\tif ( c == EOF && ferror( yyin ) ) \\" );
call    0 returned 303
      303: 4014:			outn(
call    0 returned 303
        -: 4015:	"\t\t\tYY_FATAL_ERROR( \"input in flex scanner failed\" ); \\" );
      303: 4016:			outn( "\t\tresult = n; \\" );
call    0 returned 303
      303: 4017:			outn( "\t\t} \\" );
call    0 returned 303
      303: 4018:			outn(
call    0 returned 303
        -: 4019:	"\telse if ( ((result = fread( buf, 1, max_size, yyin )) == 0) \\" );
      303: 4020:			outn( "\t\t  && ferror( yyin ) ) \\" );
call    0 returned 303
      303: 4021:			outn(
call    0 returned 303
        -: 4022:		"\t\tYY_FATAL_ERROR( \"input in flex scanner failed\" );" );
        -: 4023:			}
        -: 4024:		}
        -: 4025:
      543: 4026:	skelout();
call    0 returned 543
        -: 4027:
      543: 4028:	indent_puts( "#define YY_RULE_SETUP \\" );
call    0 returned 543
      543: 4029:	indent_up();
      543: 4030:	if ( bol_needed )
branch  0 taken 99 (fallthrough)
branch  1 taken 444
        -: 4031:		{
       99: 4032:		indent_puts( "if ( yyleng > 0 ) \\" );
call    0 returned 99
       99: 4033:		indent_up();
       99: 4034:		indent_puts( "yy_current_buffer->yy_at_bol = \\" );
call    0 returned 99
       99: 4035:		indent_puts( "\t\t(yytext[yyleng - 1] == '\\n'); \\" );
call    0 returned 99
       99: 4036:		indent_down();
        -: 4037:		}
      543: 4038:	indent_puts( "YY_USER_ACTION" );
call    0 returned 543
      543: 4039:	indent_down();
        -: 4040:
      543: 4041:	skelout();
call    0 returned 543
        -: 4042:
        -: 4043:	/* Copy prolog to output file. */
      543: 4044:	out( &action_array[prolog_offset] );
call    0 returned 543
        -: 4045:
      543: 4046:	line_directive_out( stdout, 0 );
call    0 returned 543
        -: 4047:
      543: 4048:	skelout();
call    0 returned 543
        -: 4049:
      543: 4050:	set_indent( 2 );
        -: 4051:
      543: 4052:	if ( yymore_used && ! yytext_is_array )
branch  0 taken 166 (fallthrough)
branch  1 taken 377
branch  2 taken 5 (fallthrough)
branch  3 taken 161
        -: 4053:		{
        5: 4054:		indent_puts( "yy_more_len = 0;" );
call    0 returned 5
        5: 4055:		indent_puts( "if ( yy_more_flag )" );
call    0 returned 5
        5: 4056:		indent_up();
        5: 4057:		indent_puts( "{" );
call    0 returned 5
        5: 4058:		indent_puts( "yy_more_len = yy_c_buf_p - yytext_ptr;" );
call    0 returned 5
        5: 4059:		indent_puts( "yy_more_flag = 0;" );
call    0 returned 5
        5: 4060:		indent_puts( "}" );
call    0 returned 5
        5: 4061:		indent_down();
        -: 4062:		}
        -: 4063:
      543: 4064:	skelout();
call    0 returned 543
        -: 4065:
      543: 4066:	gen_start_state();
call    0 returned 543
        -: 4067:
        -: 4068:	/* Note, don't use any indentation. */
      543: 4069:	outn( "yy_match:" );
call    0 returned 543
      543: 4070:	gen_next_match();
call    0 returned 543
        -: 4071:
      543: 4072:	skelout();
call    0 returned 543
      543: 4073:	set_indent( 2 );
      543: 4074:	gen_find_action();
call    0 returned 543
        -: 4075:
      543: 4076:	skelout();
call    0 returned 543
      543: 4077:	if ( do_yylineno )
branch  0 taken 161 (fallthrough)
branch  1 taken 382
        -: 4078:		{
      161: 4079:		indent_puts( "if ( yy_act != YY_END_OF_BUFFER )" );
call    0 returned 161
      161: 4080:		indent_up();
      161: 4081:		indent_puts( "{" );
call    0 returned 161
      161: 4082:		indent_puts( "int yyl;" );
call    0 returned 161
      161: 4083:		indent_puts( "for ( yyl = 0; yyl < yyleng; ++yyl )" );
call    0 returned 161
      161: 4084:		indent_up();
      161: 4085:		indent_puts( "if ( yytext[yyl] == '\\n' )" );
call    0 returned 161
      161: 4086:		indent_up();
      161: 4087:		indent_puts( "++yylineno;" );
call    0 returned 161
      161: 4088:		indent_down();
      161: 4089:		indent_down();
      161: 4090:		indent_puts( "}" );
call    0 returned 161
      161: 4091:		indent_down();
        -: 4092:		}
        -: 4093:
      543: 4094:	skelout();
call    0 returned 543
      543: 4095:	if ( ddebug )
branch  0 taken 252 (fallthrough)
branch  1 taken 291
        -: 4096:		{
      252: 4097:		indent_puts( "if ( yy_flex_debug )" );
call    0 returned 252
      252: 4098:		indent_up();
        -: 4099:
      252: 4100:		indent_puts( "{" );
call    0 returned 252
      252: 4101:		indent_puts( "if ( yy_act == 0 )" );
call    0 returned 252
      252: 4102:		indent_up();
     252*: 4103:		indent_puts( C_plus_plus ?
branch  0 taken 0 (fallthrough)
branch  1 taken 252
call    2 returned 252
        -: 4104:			"cerr << \"--scanner backing up\\n\";" :
        -: 4105:			"fprintf( err, \"--scanner backing up\\n\" );" );
      252: 4106:		indent_down();
        -: 4107:
      252: 4108:		do_indent();
call    0 returned 252
      252: 4109:		out_dec( "else if ( yy_act < %d )\n", num_rules );
call    0 returned 252
      252: 4110:		indent_up();
        -: 4111:
      252: 4112:		if ( C_plus_plus )
branch  0 taken 0 (fallthrough)
branch  1 taken 252
        -: 4113:			{
    #####: 4114:			indent_puts(
call    0 never executed
        -: 4115:	"cerr << \"--accepting rule at line \" << yy_rule_linenum[yy_act] <<" );
    #####: 4116:			indent_puts(
call    0 never executed
        -: 4117:			"         \"(\\\"\" << yytext << \"\\\")\\n\";" );
        -: 4118:			}
        -: 4119:		else
        -: 4120:			{
      252: 4121:			indent_puts(
call    0 returned 252
        -: 4122:	"fprintf( err, \"--accepting rule at line %d (\\\"%s\\\")\\n\"," );
        -: 4123:
      252: 4124:			indent_puts(
call    0 returned 252
        -: 4125:				"         yy_rule_linenum[yy_act], yytext );" );
        -: 4126:			}
        -: 4127:
      252: 4128:		indent_down();
        -: 4129:
      252: 4130:		do_indent();
call    0 returned 252
      252: 4131:		out_dec( "else if ( yy_act == %d )\n", num_rules );
call    0 returned 252
      252: 4132:		indent_up();
        -: 4133:
      252: 4134:		if ( C_plus_plus )
branch  0 taken 0 (fallthrough)
branch  1 taken 252
        -: 4135:			{
    #####: 4136:			indent_puts(
call    0 never executed
        -: 4137:"cerr << \"--accepting default rule (\\\"\" << yytext << \"\\\")\\n\";" );
        -: 4138:			}
        -: 4139:		else
        -: 4140:			{
      252: 4141:			indent_puts(
call    0 returned 252
        -: 4142:	"fprintf( err, \"--accepting default rule (\\\"%s\\\")\\n\"," );
      252: 4143:			indent_puts( "         yytext );" );
call    0 returned 252
        -: 4144:			}
        -: 4145:
      252: 4146:		indent_down();
        -: 4147:
      252: 4148:		do_indent();
call    0 returned 252
      252: 4149:		out_dec( "else if ( yy_act == %d )\n", num_rules + 1 );
call    0 returned 252
      252: 4150:		indent_up();
        -: 4151:
     252*: 4152:		indent_puts( C_plus_plus ?
branch  0 taken 0 (fallthrough)
branch  1 taken 252
call    2 returned 252
        -: 4153:			"cerr << \"--(end of buffer or a NUL)\\n\";" :
        -: 4154:		"fprintf( err, \"--(end of buffer or a NUL)\\n\" );" );
        -: 4155:
      252: 4156:		indent_down();
        -: 4157:
      252: 4158:		do_indent();
call    0 returned 252
      252: 4159:		outn( "else" );
call    0 returned 252
      252: 4160:		indent_up();
        -: 4161:
      252: 4162:		if ( C_plus_plus )
branch  0 taken 0 (fallthrough)
branch  1 taken 252
        -: 4163:			{
    #####: 4164:			indent_puts(
call    0 never executed
        -: 4165:	"cerr << \"--EOF (start condition \" << YY_START << \")\\n\";" );
        -: 4166:			}
        -: 4167:		else
        -: 4168:			{
      252: 4169:			indent_puts(
call    0 returned 252
        -: 4170:	"fprintf( err, \"--EOF (start condition %d)\\n\", YY_START );" );
        -: 4171:			}
        -: 4172:
      252: 4173:		indent_down();
        -: 4174:
      252: 4175:		indent_puts( "}" );
call    0 returned 252
      252: 4176:		indent_down();
        -: 4177:		}
        -: 4178:
        -: 4179:	/* Copy actions to output file. */
      543: 4180:	skelout();
call    0 returned 543
      543: 4181:	indent_up();
      543: 4182:	gen_bu_action();
call    0 returned 543
      543: 4183:	out( &action_array[action_offset] );
call    0 returned 543
        -: 4184:
      543: 4185:	line_directive_out( stdout, 0 );
call    0 returned 543
        -: 4186:
        -: 4187:	/* generate cases for any missing EOF rules */
     1105: 4188:	for ( i = 1; i <= lastsc; ++i )
branch  0 taken 562
branch  1 taken 543 (fallthrough)
      562: 4189:		if ( ! sceof[i] )
branch  0 taken 541 (fallthrough)
branch  1 taken 21
        -: 4190:			{
      541: 4191:			do_indent();
call    0 returned 541
      541: 4192:			out_str( "case YY_STATE_EOF(%s):\n", scname[i] );
call    0 returned 541
      541: 4193:			did_eof_rule = true;
        -: 4194:			}
        -: 4195:
      543: 4196:	if ( did_eof_rule )
branch  0 taken 537 (fallthrough)
branch  1 taken 6
        -: 4197:		{
      537: 4198:		indent_up();
      537: 4199:		indent_puts( "yyterminate();" );
call    0 returned 537
      537: 4200:		indent_down();
        -: 4201:		}
        -: 4202:
        -: 4203:
        -: 4204:	/* Generate code for handling NUL's, if needed. */
        -: 4205:
        -: 4206:	/* First, deal with backing up and setting up yy_cp if the scanner
        -: 4207:	 * finds that it should JAM on the NUL.
        -: 4208:	 */
      543: 4209:	skelout();
call    0 returned 543
      543: 4210:	set_indent( 4 );
        -: 4211:
      543: 4212:	if ( fullspd || fulltbl )
branch  0 taken 451 (fallthrough)
branch  1 taken 92
branch  2 taken 23 (fallthrough)
branch  3 taken 428
      115: 4213:		indent_puts( "yy_cp = yy_c_buf_p;" );
call    0 returned 115
        -: 4214:
        -: 4215:	else
        -: 4216:		{ /* compressed table */
      428: 4217:		if ( ! reject && ! interactive )
branch  0 taken 260 (fallthrough)
branch  1 taken 168
branch  2 taken 1 (fallthrough)
branch  3 taken 259
        -: 4218:			{
        -: 4219:			/* Do the guaranteed-needed backing up to figure
        -: 4220:			 * out the match.
        -: 4221:			 */
        1: 4222:			indent_puts( "yy_cp = yy_last_accepting_cpos;" );
call    0 returned 1
        1: 4223:			indent_puts(
call    0 returned 1
        -: 4224:				"yy_current_state = yy_last_accepting_state;" );
        -: 4225:			}
        -: 4226:
        -: 4227:		else
        -: 4228:			/* Still need to initialize yy_cp, though
        -: 4229:			 * yy_current_state was set up by
        -: 4230:			 * yy_get_previous_state().
        -: 4231:			 */
      427: 4232:			indent_puts( "yy_cp = yy_c_buf_p;" );
call    0 returned 427
        -: 4233:		}
        -: 4234:
        -: 4235:
        -: 4236:	/* Generate code for yy_get_previous_state(). */
      543: 4237:	set_indent( 1 );
      543: 4238:	skelout();
call    0 returned 543
        -: 4239:
      543: 4240:	gen_start_state();
call    0 returned 543
        -: 4241:
      543: 4242:	set_indent( 2 );
      543: 4243:	skelout();
call    0 returned 543
      543: 4244:	gen_next_state( true );
call    0 returned 543
        -: 4245:
      543: 4246:	set_indent( 1 );
      543: 4247:	skelout();
call    0 returned 543
      543: 4248:	gen_NUL_trans();
call    0 returned 543
        -: 4249:
      543: 4250:	skelout();
call    0 returned 543
      543: 4251:	if ( do_yylineno )
branch  0 taken 161 (fallthrough)
branch  1 taken 382
        -: 4252:		{ /* update yylineno inside of unput() */
      161: 4253:		indent_puts( "if ( c == '\\n' )" );
call    0 returned 161
      161: 4254:		indent_up();
      161: 4255:		indent_puts( "--yylineno;" );
call    0 returned 161
      161: 4256:		indent_down();
        -: 4257:		}
        -: 4258:
      543: 4259:	skelout();
call    0 returned 543
        -: 4260:	/* Update BOL and yylineno inside of input(). */
      543: 4261:	if ( bol_needed )
branch  0 taken 99 (fallthrough)
branch  1 taken 444
        -: 4262:		{
       99: 4263:		indent_puts( "yy_current_buffer->yy_at_bol = (c == '\\n');" );
call    0 returned 99
       99: 4264:		if ( do_yylineno )
branch  0 taken 31 (fallthrough)
branch  1 taken 68
        -: 4265:			{
       31: 4266:			indent_puts( "if ( yy_current_buffer->yy_at_bol )" );
call    0 returned 31
       31: 4267:			indent_up();
       31: 4268:			indent_puts( "++yylineno;" );
call    0 returned 31
       31: 4269:			indent_down();
        -: 4270:			}
        -: 4271:		}
        -: 4272:
      444: 4273:	else if ( do_yylineno )
branch  0 taken 130 (fallthrough)
branch  1 taken 314
        -: 4274:		{
      130: 4275:		indent_puts( "if ( c == '\\n' )" );
call    0 returned 130
      130: 4276:		indent_up();
      130: 4277:		indent_puts( "++yylineno;" );
call    0 returned 130
      130: 4278:		indent_down();
        -: 4279:		}
        -: 4280:
      543: 4281:	skelout();
call    0 returned 543
        -: 4282:
        -: 4283:	/* Copy remainder of input to output. */
        -: 4284:
      543: 4285:	line_directive_out( stdout, 1 );
call    0 returned 543
        -: 4286:
      543: 4287:	if ( sectnum == 3 )
branch  0 taken 113 (fallthrough)
branch  1 taken 430
      113: 4288:		(void) flexscan(); /* copy remainder of input to output */
call    0 returned 113
      543: 4289:	}
        -: 4290:/* misc - miscellaneous flex routines */
        -: 4291:
        -: 4292:/*-
        -: 4293: * Copyright (c) 1990 The Regents of the University of California.
        -: 4294: * All rights reserved.
        -: 4295: *
        -: 4296: * This code is derived from software contributed to Berkeley by
        -: 4297: * Vern Paxson.
        -: 4298: * 
        -: 4299: * The United States Government has rights in this work pursuant
        -: 4300: * to contract no. DE-AC03-76SF00098 between the United States
        -: 4301: * Department of Energy and the University of California.
        -: 4302: *
        -: 4303: * Redistribution and use in source and binary forms with or without
        -: 4304: * modification are permitted provided that: (1) source distributions retain
        -: 4305: * this entire copyright notice and comment, and (2) distributions including
        -: 4306: * binaries display the following acknowledgement:  ``This product includes
        -: 4307: * software developed by the University of California, Berkeley and its
        -: 4308: * contributors'' in the documentation or other materials provided with the
        -: 4309: * distribution and in all advertising materials mentioning features or use
        -: 4310: * of this software.  Neither the name of the University nor the names of
        -: 4311: * its contributors may be used to endorse or promote products derived from
        -: 4312: * this software without specific prior written permission.
        -: 4313: * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
        -: 4314: * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
        -: 4315: * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
        -: 4316: */
        -: 4317:
        -: 4318:/* $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.seeded/v5/flex.c,v 1.1.1.2 2003/09/02 20:22:00 expsir Exp $ */
        -: 4319:
        -: 4320:
        -: 4321:
function action_define called 579 returned 100% blocks executed 67%
      579: 4322:void action_define( defname, value )
        -: 4323:char *defname;
        -: 4324:int value;
        -: 4325:	{
        -: 4326:	char buf[MAXLINE];
        -: 4327:
      579: 4328:	if ( (int) strlen( defname ) > MAXLINE / 2 )
branch  0 taken 0 (fallthrough)
branch  1 taken 579
        -: 4329:		{
    #####: 4330:		format_pinpoint_message( _( "name \"%s\" ridiculously long" ), 
call    0 never executed
        -: 4331:			defname );
    #####: 4332:		return;
        -: 4333:		}
        -: 4334:
      579: 4335:	sprintf( buf, "#define %s %d\n", defname, value );
      579: 4336:	add_action( buf );
call    0 returned 579
        -: 4337:	}
        -: 4338:
        -: 4339:
function add_action called 63345 returned 100% blocks executed 88%
    63345: 4340:void add_action( new_text )
        -: 4341:char *new_text;
        -: 4342:	{
    63345: 4343:	int len = strlen( new_text );
        -: 4344:
    63358: 4345:	while ( len + action_index >= action_size - 10 /* slop */ )
branch  0 taken 13
branch  1 taken 63345 (fallthrough)
        -: 4346:		{
       13: 4347:		int new_size = action_size * 2;
        -: 4348:
       13: 4349:		if ( new_size <= 0 )
branch  0 taken 0 (fallthrough)
branch  1 taken 13
        -: 4350:			/* Increase just a little, to try to avoid overflow
        -: 4351:			 * on 16-bit machines.
        -: 4352:			 */
    #####: 4353:			action_size += action_size / 8;
        -: 4354:		else
       13: 4355:			action_size = new_size;
        -: 4356:
       13: 4357:		action_array =
       13: 4358:			reallocate_character_array( action_array, action_size );
call    0 returned 13
        -: 4359:		}
        -: 4360:
    63345: 4361:	strcpy( &action_array[action_index], new_text );
        -: 4362:
    63345: 4363:	action_index += len;
    63345: 4364:	}
        -: 4365:
        -: 4366:
        -: 4367:/* allocate_array - allocate memory for an integer array of the given size */
        -: 4368:
function allocate_array called 40306 returned 100% blocks executed 80%
    40306: 4369:void *allocate_array( size, element_size )
        -: 4370:int size;
        -: 4371:size_t element_size;
        -: 4372:	{
        -: 4373:	register void *mem;
    40306: 4374:	size_t num_bytes = element_size * size;
        -: 4375:
    40306: 4376:	mem = flex_alloc( num_bytes );
call    0 returned 40306
    40306: 4377:	if ( ! mem )
branch  0 taken 0 (fallthrough)
branch  1 taken 40306
    #####: 4378:		flexfatal(
call    0 never executed
        -: 4379:			_( "memory allocation failed in allocate_array()" ) );
        -: 4380:
    40306: 4381:	return mem;
        -: 4382:	}
        -: 4383:
        -: 4384:
        -: 4385:/* all_lower - true if a string is all lower-case */
        -: 4386:
function all_lower called 5 returned 100% blocks executed 88%
        5: 4387:int all_lower( str )
        -: 4388:register char *str;
        -: 4389:	{
       35: 4390:	while ( *str )
branch  0 taken 30
branch  1 taken 5 (fallthrough)
        -: 4391:		{
       30: 4392:		if ( ! isascii( (Char) *str ) || ! islower( *str ) )
branch  0 taken 30 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 30
    #####: 4393:			return 0;
       30: 4394:		++str;
        -: 4395:		}
        -: 4396:
        5: 4397:	return 1;
        -: 4398:	}
        -: 4399:
        -: 4400:
        -: 4401:/* all_upper - true if a string is all upper-case */
        -: 4402:
function all_upper called 8 returned 100% blocks executed 88%
        8: 4403:int all_upper( str )
        -: 4404:register char *str;
        -: 4405:	{
       56: 4406:	while ( *str )
branch  0 taken 48
branch  1 taken 8 (fallthrough)
        -: 4407:		{
       48: 4408:		if ( ! isascii( (Char) *str ) || ! isupper( *str ) )
branch  0 taken 48 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 48
    #####: 4409:			return 0;
       48: 4410:		++str;
        -: 4411:		}
        -: 4412:
        8: 4413:	return 1;
        -: 4414:	}
        -: 4415:
        -: 4416:
        -: 4417:/* bubble - bubble sort an integer array in increasing order
        -: 4418: *
        -: 4419: * synopsis
        -: 4420: *   int v[n], n;
        -: 4421: *   void bubble( v, n );
        -: 4422: *
        -: 4423: * description
        -: 4424: *   sorts the first n elements of array v and replaces them in
        -: 4425: *   increasing order.
        -: 4426: *
        -: 4427: * passed
        -: 4428: *   v - the array to be sorted
        -: 4429: *   n - the number of elements of 'v' to be sorted
        -: 4430: */
        -: 4431:
function bubble called 31270 returned 100% blocks executed 100%
    31270: 4432:void bubble( v, n )
        -: 4433:int v[], n;
        -: 4434:	{
        -: 4435:	register int i, j, k;
        -: 4436:
   119434: 4437:	for ( i = n; i > 1; --i )
branch  0 taken 88164
branch  1 taken 31270 (fallthrough)
   771767: 4438:		for ( j = 1; j < i; ++j )
branch  0 taken 683603
branch  1 taken 88164 (fallthrough)
   683603: 4439:			if ( v[j] > v[j + 1] )	/* compare */
branch  0 taken 467146 (fallthrough)
branch  1 taken 216457
        -: 4440:				{
   467146: 4441:				k = v[j];	/* exchange */
   467146: 4442:				v[j] = v[j + 1];
   467146: 4443:				v[j + 1] = k;
        -: 4444:				}
    31270: 4445:	}
        -: 4446:
        -: 4447:
        -: 4448:/* check_char - checks a character to make sure it's within the range
        -: 4449: *		we're expecting.  If not, generates fatal error message
        -: 4450: *		and exits.
        -: 4451: */
        -: 4452:
function check_char called 37210 returned 100% blocks executed 71%
    37210: 4453:void check_char( c )
        -: 4454:int c;
        -: 4455:	{
    37210: 4456:	if ( c >= CSIZE )
branch  0 taken 0 (fallthrough)
branch  1 taken 37210
    #####: 4457:		lerrsf( _( "bad character '%s' detected in check_char()" ),
call    0 never executed
    #####: 4458:			readable_form( c ) );
call    0 never executed
        -: 4459:
    37210: 4460:	if ( c >= csize )
branch  0 taken 1 (fallthrough)
branch  1 taken 37209
        1: 4461:		lerrsf(
call    0 returned 0
        -: 4462:		_( "scanner requires -8 flag to use the character %s" ),
        1: 4463:			readable_form( c ) );
call    0 returned 1
    37209: 4464:	}
        -: 4465:
        -: 4466:
        -: 4467:
        -: 4468:/* clower - replace upper-case letter to lower-case */
        -: 4469:
function clower called 78 returned 100% blocks executed 83%
       78: 4470:Char clower( c )
        -: 4471:register int c;
        -: 4472:	{
      78*: 4473:	return (Char) ((isascii( c ) && isupper( c )) ? tolower( c ) : c);
branch  0 taken 78 (fallthrough)
branch  1 taken 0
branch  2 taken 78 (fallthrough)
branch  3 taken 0
        -: 4474:	}
        -: 4475:
        -: 4476:
        -: 4477:/* copy_string - returns a dynamically allocated copy of a string */
        -: 4478:
function copy_string called 1398 returned 100% blocks executed 90%
     1398: 4479:char *copy_string( str )
        -: 4480:register const char *str;
        -: 4481:	{
        -: 4482:	register const char *c1;
        -: 4483:	register char *c2;
        -: 4484:	char *copy;
        -: 4485:	unsigned int size;
        -: 4486:
        -: 4487:	/* find length */
    15980: 4488:	for ( c1 = str; *c1; ++c1 )
branch  0 taken 14582
branch  1 taken 1398 (fallthrough)
        -: 4489:		;
        -: 4490:
     1398: 4491:	size = (c1 - str + 1) * sizeof( char );
     1398: 4492:	copy = (char *) flex_alloc( size );
call    0 returned 1398
        -: 4493:
     1398: 4494:	if ( copy == NULL )
branch  0 taken 0 (fallthrough)
branch  1 taken 1398
    #####: 4495:		flexfatal( _( "dynamic memory failure in copy_string()" ) );
call    0 never executed
        -: 4496:
    15980: 4497:	for ( c2 = copy; (*c2++ = *str++) != 0; )
branch  0 taken 14582
branch  1 taken 1398 (fallthrough)
        -: 4498:		;
        -: 4499:
     1398: 4500:	return copy;
        -: 4501:	}
        -: 4502:
        -: 4503:
        -: 4504:/* copy_unsigned_string -
        -: 4505: *    returns a dynamically allocated copy of a (potentially) unsigned string
        -: 4506: */
        -: 4507:
function copy_unsigned_string called 1555 returned 100% blocks executed 100%
     1555: 4508:Char *copy_unsigned_string( str )
        -: 4509:register Char *str;
        -: 4510:	{
        -: 4511:	register Char *c;
        -: 4512:	Char *copy;
        -: 4513:
        -: 4514:	/* find length */
    11100: 4515:	for ( c = str; *c; ++c )
branch  0 taken 9545
branch  1 taken 1555 (fallthrough)
        -: 4516:		;
        -: 4517:
     1555: 4518:	copy = allocate_Character_array( c - str + 1 );
call    0 returned 1555
        -: 4519:
    11100: 4520:	for ( c = copy; (*c++ = *str++) != 0; )
branch  0 taken 9545
branch  1 taken 1555 (fallthrough)
        -: 4521:		;
        -: 4522:
     1555: 4523:	return copy;
        -: 4524:	}
        -: 4525:
        -: 4526:
        -: 4527:/* cshell - shell sort a character array in increasing order
        -: 4528: *
        -: 4529: * synopsis
        -: 4530: *
        -: 4531: *   Char v[n];
        -: 4532: *   int n, special_case_0;
        -: 4533: *   cshell( v, n, special_case_0 );
        -: 4534: *
        -: 4535: * description
        -: 4536: *   Does a shell sort of the first n elements of array v.
        -: 4537: *   If special_case_0 is true, then any element equal to 0
        -: 4538: *   is instead assumed to have infinite weight.
        -: 4539: *
        -: 4540: * passed
        -: 4541: *   v - array to be sorted
        -: 4542: *   n - number of elements of v to be sorted
        -: 4543: */
        -: 4544:
function cshell called 850 returned 100% blocks executed 89%
      850: 4545:void cshell( v, n, special_case_0 )
        -: 4546:Char v[];
        -: 4547:int n, special_case_0;
        -: 4548:	{
        -: 4549:	int gap, i, j, jg;
        -: 4550:	Char k;
        -: 4551:
     3467: 4552:	for ( gap = n / 2; gap > 0; gap = gap / 2 )
branch  0 taken 2617
branch  1 taken 850 (fallthrough)
    74835: 4553:		for ( i = gap; i < n; ++i )
branch  0 taken 72218
branch  1 taken 2617 (fallthrough)
    97074: 4554:			for ( j = i - gap; j >= 0; j = j - gap )
branch  0 taken 92782
branch  1 taken 4292 (fallthrough)
        -: 4555:				{
    92782: 4556:				jg = j + gap;
        -: 4557:
    92782: 4558:				if ( special_case_0 )
branch  0 taken 92782 (fallthrough)
branch  1 taken 0
        -: 4559:					{
    92782: 4560:					if ( v[jg] == 0 )
branch  0 taken 7 (fallthrough)
branch  1 taken 92775
        7: 4561:						break;
        -: 4562:
    92775: 4563:					else if ( v[j] != 0 && v[j] <= v[jg] )
branch  0 taken 92766 (fallthrough)
branch  1 taken 9
branch  2 taken 67919 (fallthrough)
branch  3 taken 24847
    67919: 4564:						break;
        -: 4565:					}
        -: 4566:
    #####: 4567:				else if ( v[j] <= v[jg] )
branch  0 never executed
branch  1 never executed
    #####: 4568:					break;
        -: 4569:
    24856: 4570:				k = v[j];
    24856: 4571:				v[j] = v[jg];
    24856: 4572:				v[jg] = k;
        -: 4573:				}
      850: 4574:	}
        -: 4575:
        -: 4576:
        -: 4577:/* dataend - finish up a block of data declarations */
        -: 4578:
function dataend called 3404 returned 100% blocks executed 100%
     3404: 4579:void dataend()
        -: 4580:	{
     3404: 4581:	if ( datapos > 0 )
branch  0 taken 3362 (fallthrough)
branch  1 taken 42
     3362: 4582:		dataflush();
call    0 returned 3362
        -: 4583:
        -: 4584:	/* add terminator for initialization; { for vi */
     3404: 4585:	outn( "    } ;\n" );
call    0 returned 3404
        -: 4586:
     3404: 4587:	dataline = 0;
     3404: 4588:	datapos = 0;
     3404: 4589:	}
        -: 4590:
        -: 4591:
        -: 4592:/* dataflush - flush generated data statements */
        -: 4593:
function dataflush called 55642 returned 100% blocks executed 100%
    55642: 4594:void dataflush()
        -: 4595:	{
    55642: 4596:	outc( '\n' );
call    0 returned 55642
        -: 4597:
    55642: 4598:	if ( ++dataline >= NUMDATALINES )
branch  0 taken 4549 (fallthrough)
branch  1 taken 51093
        -: 4599:		{
        -: 4600:		/* Put out a blank line so that the table is grouped into
        -: 4601:		 * large blocks that enable the user to find elements easily.
        -: 4602:		 */
     4549: 4603:		outc( '\n' );
call    0 returned 4549
     4549: 4604:		dataline = 0;
        -: 4605:		}
        -: 4606:
        -: 4607:	/* Reset the number of characters written on the current line. */
    55642: 4608:	datapos = 0;
    55642: 4609:	}
        -: 4610:
        -: 4611:
        -: 4612:/* flexerror - report an error message and terminate */
        -: 4613:
function flexerror called 15 returned 0% blocks executed 100%
       15: 4614:void flexerror( msg )
        -: 4615:const char msg[];
        -: 4616:	{
       15: 4617:	fprintf( err, "%s: %s\n", program_name, msg );
call    0 returned 15
       15: 4618:	flexend( 1 );
call    0 returned 0
    #####: 4619:	}
        -: 4620:
        -: 4621:
        -: 4622:/* flexfatal - report a fatal error message and terminate */
        -: 4623:
function flexfatal called 0 returned 0% blocks executed 0%
    #####: 4624:void flexfatal( msg )
        -: 4625:const char msg[];
        -: 4626:	{
    #####: 4627:	fprintf( err, _( "%s: fatal internal error, %s\n" ),
call    0 never executed
        -: 4628:		program_name, msg );
    #####: 4629:	exit( 1 );
        -: 4630:	}
        -: 4631:
        -: 4632:
        -: 4633:/* htoi - convert a hexadecimal digit string to an integer value */
        -: 4634:
function htoi called 3 returned 100% blocks executed 100%
        3: 4635:int htoi( str )
        -: 4636:Char str[];
        -: 4637:	{
        -: 4638:	unsigned int result;
        -: 4639:
        3: 4640:	(void) sscanf( (char *) str, "%x", &result );
        -: 4641:
        3: 4642:	return result;
        -: 4643:	}
        -: 4644:
        -: 4645:
        -: 4646:/* lerrif - report an error message formatted with one integer argument */
        -: 4647:
function lerrif called 1 returned 0% blocks executed 100%
        1: 4648:void lerrif( msg, arg )
        -: 4649:const char msg[];
        -: 4650:int arg;
        -: 4651:	{
        -: 4652:	char errmsg[MAXLINE];
        1: 4653:	(void) sprintf( errmsg, msg, arg );
        1: 4654:	flexerror( errmsg );
call    0 returned 0
    #####: 4655:	}
        -: 4656:
        -: 4657:
        -: 4658:/* lerrsf - report an error message formatted with one string argument */
        -: 4659:
function lerrsf called 3 returned 0% blocks executed 100%
        3: 4660:void lerrsf( msg, arg )
        -: 4661:const char msg[], arg[];
        -: 4662:	{
        -: 4663:	char errmsg[MAXLINE];
        -: 4664:
        3: 4665:	(void) sprintf( errmsg, msg, arg );
        3: 4666:	flexerror( errmsg );
call    0 returned 0
    #####: 4667:	}
        -: 4668:
        -: 4669:
        -: 4670:/* line_directive_out - spit out a "#line" statement */
        -: 4671:
function line_directive_out called 7494 returned 100% blocks executed 96%
     7494: 4672:void line_directive_out( output_file, do_infile )
        -: 4673:FILE *output_file;
        -: 4674:int do_infile;
        -: 4675:	{
        -: 4676:	char directive[MAXLINE], filename[MAXLINE];
        -: 4677:	char *s1, *s2, *s3;
        -: 4678:	static char line_fmt[] = "#line %d \"%s\"\n";
        -: 4679:
     7494: 4680:	if ( ! gen_line_dirs )
branch  0 taken 46 (fallthrough)
branch  1 taken 7448
       49: 4681:		return;
        -: 4682:
     7448: 4683:	if ( (do_infile && ! infilename) || (! do_infile && ! outfilename) )
branch  0 taken 5827 (fallthrough)
branch  1 taken 1621
branch  2 taken 5827 (fallthrough)
branch  3 taken 0
branch  4 taken 1621 (fallthrough)
branch  5 taken 5827
branch  6 taken 3 (fallthrough)
branch  7 taken 1618
        -: 4684:		/* don't know the filename to use, skip */
        3: 4685:		return;
        -: 4686:
     7445: 4687:	s1 = do_infile ? infilename : outfilename;
branch  0 taken 5827 (fallthrough)
branch  1 taken 1618
     7445: 4688:	s2 = filename;
     7445: 4689:	s3 = &filename[sizeof( filename ) - 2];
        -: 4690:
   116260: 4691:	while ( s2 < s3 && *s1 )
branch  0 taken 116260 (fallthrough)
branch  1 taken 0
branch  2 taken 108815
branch  3 taken 7445 (fallthrough)
        -: 4692:		{
   108815: 4693:		if ( *s1 == '\\' )
branch  0 taken 0 (fallthrough)
branch  1 taken 108815
        -: 4694:			/* Escape the '\' */
    #####: 4695:			*s2++ = '\\';
        -: 4696:
   108815: 4697:		*s2++ = *s1++;
        -: 4698:		}
        -: 4699:
     7445: 4700:	*s2 = '\0';
        -: 4701:
     7445: 4702:	if ( do_infile )
branch  0 taken 5827 (fallthrough)
branch  1 taken 1618
     5827: 4703:		sprintf( directive, line_fmt, linenum, filename );
        -: 4704:	else
        -: 4705:		{
     1618: 4706:		if ( output_file == stdout )
branch  0 taken 1618 (fallthrough)
branch  1 taken 0
        -: 4707:			/* Account for the line directive itself. */
     1618: 4708:			++out_linenum;
        -: 4709:
     1618: 4710:		sprintf( directive, line_fmt, out_linenum, filename );
        -: 4711:		}
        -: 4712:
        -: 4713:	/* If output_file is nil then we should put the directive in
        -: 4714:	 * the accumulated actions.
        -: 4715:	 */
     7445: 4716:	if ( output_file )
branch  0 taken 2158 (fallthrough)
branch  1 taken 5287
        -: 4717:		{
     2158: 4718:		fputs( directive, output_file );
call    0 returned 2158
        -: 4719:		}
        -: 4720:	else
     5287: 4721:		add_action( directive );
call    0 returned 5287
        -: 4722:	}
        -: 4723:
        -: 4724:
        -: 4725:/* mark_defs1 - mark the current position in the action array as
        -: 4726: *               representing where the user's section 1 definitions end
        -: 4727: *		 and the prolog begins
        -: 4728: */
function mark_defs1 called 560 returned 100% blocks executed 100%
      560: 4729:void mark_defs1()
        -: 4730:	{
      560: 4731:	defs1_offset = 0;
      560: 4732:	action_array[action_index++] = '\0';
      560: 4733:	action_offset = prolog_offset = action_index;
      560: 4734:	action_array[action_index] = '\0';
      560: 4735:	}
        -: 4736:
        -: 4737:
        -: 4738:/* mark_prolog - mark the current position in the action array as
        -: 4739: *               representing the end of the action prolog
        -: 4740: */
function mark_prolog called 553 returned 100% blocks executed 100%
      553: 4741:void mark_prolog()
        -: 4742:	{
      553: 4743:	action_array[action_index++] = '\0';
      553: 4744:	action_offset = action_index;
      553: 4745:	action_array[action_index] = '\0';
      553: 4746:	}
        -: 4747:
        -: 4748:
        -: 4749:/* mk2data - generate a data statement for a two-dimensional array
        -: 4750: *
        -: 4751: * Generates a data statement initializing the current 2-D array to "value".
        -: 4752: */
function mk2data called 70116 returned 100% blocks executed 100%
    70116: 4753:void mk2data( value )
        -: 4754:int value;
        -: 4755:	{
    70116: 4756:	if ( datapos >= NUMDATAITEMS )
branch  0 taken 6571 (fallthrough)
branch  1 taken 63545
        -: 4757:		{
     6571: 4758:		outc( ',' );
call    0 returned 6571
     6571: 4759:		dataflush();
call    0 returned 6571
        -: 4760:		}
        -: 4761:
    70116: 4762:	if ( datapos == 0 )
branch  0 taken 7136 (fallthrough)
branch  1 taken 62980
        -: 4763:		/* Indent. */
     7136: 4764:		out( "    " );
call    0 returned 7136
        -: 4765:
        -: 4766:	else
    62980: 4767:		outc( ',' );
call    0 returned 62980
        -: 4768:
    70116: 4769:	++datapos;
        -: 4770:
    70116: 4771:	out_dec( "%5d", value );
call    0 returned 70116
    70116: 4772:	}
        -: 4773:
        -: 4774:
        -: 4775:/* mkdata - generate a data statement
        -: 4776: *
        -: 4777: * Generates a data statement initializing the current array element to
        -: 4778: * "value".
        -: 4779: */
function mkdata called 468358 returned 100% blocks executed 100%
   468358: 4780:void mkdata( value )
        -: 4781:int value;
        -: 4782:	{
   468358: 4783:	if ( datapos >= NUMDATAITEMS )
branch  0 taken 45144 (fallthrough)
branch  1 taken 423214
        -: 4784:		{
    45144: 4785:		outc( ',' );
call    0 returned 45144
    45144: 4786:		dataflush();
call    0 returned 45144
        -: 4787:		}
        -: 4788:
   468358: 4789:	if ( datapos == 0 )
branch  0 taken 48432 (fallthrough)
branch  1 taken 419926
        -: 4790:		/* Indent. */
    48432: 4791:		out( "    " );
call    0 returned 48432
        -: 4792:	else
   419926: 4793:		outc( ',' );
call    0 returned 419926
        -: 4794:
   468358: 4795:	++datapos;
        -: 4796:
   468358: 4797:	out_dec( "%5d", value );
call    0 returned 468358
   468358: 4798:	}
        -: 4799:
        -: 4800:
        -: 4801:/* myctoi - return the integer represented by a string of digits */
        -: 4802:
function myctoi called 396 returned 100% blocks executed 100%
      396: 4803:int myctoi( array )
        -: 4804:char array[];
        -: 4805:	{
      396: 4806:	int val = 0;
        -: 4807:
      396: 4808:	(void) sscanf( array, "%d", &val );
        -: 4809:
      396: 4810:	return val;
        -: 4811:	}
        -: 4812:
        -: 4813:
        -: 4814:/* myesc - return character corresponding to escape sequence */
        -: 4815:
function myesc called 595 returned 100% blocks executed 100%
      595: 4816:Char myesc( array )
        -: 4817:Char array[];
        -: 4818:	{
        -: 4819:	Char c, esc_char;
        -: 4820:
      595: 4821:	switch ( array[1] )
branch  0 taken 1
branch  1 taken 1
branch  2 taken 340
branch  3 taken 1
branch  4 taken 123
branch  5 taken 4
branch  6 taken 1
branch  7 taken 20
branch  8 taken 3
branch  9 taken 101
        -: 4822:		{
        1: 4823:		case 'b': return '\b';
        1: 4824:		case 'f': return '\f';
      340: 4825:		case 'n': return '\n';
        1: 4826:		case 'r': return '\r';
      123: 4827:		case 't': return '\t';
        -: 4828:
        -: 4829:#if __STDC__
        4: 4830:		case 'a': return '\a';
        1: 4831:		case 'v': return '\v';
        -: 4832:#else
        -: 4833:		case 'a': return '\007';
        -: 4834:		case 'v': return '\013';
        -: 4835:#endif
        -: 4836:
       20: 4837:		case '0':
        -: 4838:		case '1':
        -: 4839:		case '2':
        -: 4840:		case '3':
        -: 4841:		case '4':
        -: 4842:		case '5':
        -: 4843:		case '6':
        -: 4844:		case '7':
        -: 4845:			{ /* \<octal> */
       20: 4846:			int sptr = 1;
        -: 4847:
       69: 4848:			while ( isascii( array[sptr] ) &&
branch  0 taken 69 (fallthrough)
branch  1 taken 0
       69: 4849:				isdigit( array[sptr] ) )
branch  0 taken 49
branch  1 taken 20 (fallthrough)
        -: 4850:				/* Don't increment inside loop control
        -: 4851:				 * because if isdigit() is a macro it might
        -: 4852:				 * expand into multiple increments ...
        -: 4853:				 */
       49: 4854:				++sptr;
        -: 4855:
       20: 4856:			c = array[sptr];
       20: 4857:			array[sptr] = '\0';
        -: 4858:
       20: 4859:			esc_char = otoi( array + 1 );
call    0 returned 20
        -: 4860:
       20: 4861:			array[sptr] = c;
        -: 4862:
       20: 4863:			return esc_char;
        -: 4864:			}
        -: 4865:
        3: 4866:		case 'x':
        -: 4867:			{ /* \x<hex> */
        3: 4868:			int sptr = 2;
        -: 4869:
        7: 4870:			while ( isascii( array[sptr] ) &&
branch  0 taken 7 (fallthrough)
branch  1 taken 0
        7: 4871:				isxdigit( (char) array[sptr] ) )
branch  0 taken 4
branch  1 taken 3 (fallthrough)
        -: 4872:				/* Don't increment inside loop control
        -: 4873:				 * because if isdigit() is a macro it might
        -: 4874:				 * expand into multiple increments ...
        -: 4875:				 */
        4: 4876:				++sptr;
        -: 4877:
        3: 4878:			c = array[sptr];
        3: 4879:			array[sptr] = '\0';
        -: 4880:
        3: 4881:			esc_char = htoi( array + 2 );
call    0 returned 3
        -: 4882:
        3: 4883:			array[sptr] = c;
        -: 4884:
        3: 4885:			return esc_char;
        -: 4886:			}
        -: 4887:
      101: 4888:		default:
      101: 4889:			return array[1];
        -: 4890:		}
        -: 4891:	}
        -: 4892:
        -: 4893:
        -: 4894:/* otoi - convert an octal digit string to an integer value */
        -: 4895:
function otoi called 20 returned 100% blocks executed 100%
       20: 4896:int otoi( str )
        -: 4897:Char str[];
        -: 4898:	{
        -: 4899:	unsigned int result;
        -: 4900:
       20: 4901:	(void) sscanf( (char *) str, "%o", &result );
       20: 4902:	return result;
        -: 4903:	}
        -: 4904:
        -: 4905:
        -: 4906:/* out - various flavors of outputing a (possibly formatted) string for the
        -: 4907: *	 generated scanner, keeping track of the line count.
        -: 4908: */
        -: 4909:
function out called 57199 returned 100% blocks executed 100%
    57199: 4910:void out( str )
        -: 4911:const char str[];
        -: 4912:	{
    57199: 4913:	fputs( str, stdout );
call    0 returned 57199
    57199: 4914:	out_line_count( str );
call    0 returned 57199
    57199: 4915:	}
        -: 4916:
function out_dec called 542117 returned 100% blocks executed 100%
   542117: 4917:void out_dec( fmt, n )
        -: 4918:const char fmt[];
        -: 4919:int n;
        -: 4920:	{
   542117: 4921:	printf( fmt, n );
call    0 returned 542117
   542117: 4922:	out_line_count( fmt );
call    0 returned 542117
   542117: 4923:	}
        -: 4924:
function out_dec2 called 55697 returned 100% blocks executed 100%
    55697: 4925:void out_dec2( fmt, n1, n2 )
        -: 4926:const char fmt[];
        -: 4927:int n1, n2;
        -: 4928:	{
    55697: 4929:	printf( fmt, n1, n2 );
call    0 returned 55697
    55697: 4930:	out_line_count( fmt );
call    0 returned 55697
    55697: 4931:	}
        -: 4932:
function out_hex called 66 returned 100% blocks executed 100%
       66: 4933:void out_hex( fmt, x )
        -: 4934:const char fmt[];
        -: 4935:unsigned int x;
        -: 4936:	{
       66: 4937:	printf( fmt, x );
call    0 returned 66
       66: 4938:	out_line_count( fmt );
call    0 returned 66
       66: 4939:	}
        -: 4940:
function out_line_count called 1438705 returned 100% blocks executed 100%
  1438705: 4941:void out_line_count( str )
        -: 4942:const char str[];
        -: 4943:	{
        -: 4944:	register int i;
        -: 4945:
 21808732: 4946:	for ( i = 0; str[i]; ++i )
branch  0 taken 20370027
branch  1 taken 1438705 (fallthrough)
 20370027: 4947:		if ( str[i] == '\n' )
branch  0 taken 40214 (fallthrough)
branch  1 taken 20329813
    40214: 4948:			++out_linenum;
  1438705: 4949:	}
        -: 4950:
function out_str called 2066 returned 100% blocks executed 100%
     2066: 4951:void out_str( fmt, str )
        -: 4952:const char fmt[], str[];
        -: 4953:	{
     2066: 4954:	printf( fmt, str );
call    0 returned 2066
     2066: 4955:	out_line_count( fmt );
call    0 returned 2066
     2066: 4956:	out_line_count( str );
call    0 returned 2066
     2066: 4957:	}
        -: 4958:
function out_str3 called 17 returned 100% blocks executed 100%
       17: 4959:void out_str3( fmt, s1, s2, s3 )
        -: 4960:const char fmt[], s1[], s2[], s3[];
        -: 4961:	{
       17: 4962:	printf( fmt, s1, s2, s3 );
call    0 returned 17
       17: 4963:	out_line_count( fmt );
call    0 returned 17
       17: 4964:	out_line_count( s1 );
call    0 returned 17
       17: 4965:	out_line_count( s2 );
call    0 returned 17
       17: 4966:	out_line_count( s3 );
call    0 returned 17
       17: 4967:	}
        -: 4968:
function out_str_dec called 3312 returned 100% blocks executed 100%
     3312: 4969:void out_str_dec( fmt, str, n )
        -: 4970:const char fmt[], str[];
        -: 4971:int n;
        -: 4972:	{
     3312: 4973:	printf( fmt, str, n );
call    0 returned 3312
     3312: 4974:	out_line_count( fmt );
call    0 returned 3312
     3312: 4975:	out_line_count( str );
call    0 returned 3312
     3312: 4976:	}
        -: 4977:
function outc called 715476 returned 100% blocks executed 100%
   715476: 4978:void outc( c )
        -: 4979:int c;
        -: 4980:	{
   715476: 4981:	putc( c, stdout );
call    0 returned 715476
        -: 4982:
   715476: 4983:	if ( c == '\n' )
branch  0 taken 73521 (fallthrough)
branch  1 taken 641955
    73521: 4984:		++out_linenum;
   715476: 4985:	}
        -: 4986:
function outn called 772802 returned 100% blocks executed 100%
   772802: 4987:void outn( str )
        -: 4988:const char str[];
        -: 4989:	{
   772802: 4990:	puts( str );
call    0 returned 772802
   772802: 4991:	out_line_count( str );
call    0 returned 772802
   772802: 4992:	++out_linenum;
   772802: 4993:	}
        -: 4994:
        -: 4995:
        -: 4996:/* readable_form - return the the human-readable form of a character
        -: 4997: *
        -: 4998: * The returned string is in static storage.
        -: 4999: */
        -: 5000:
function readable_form called 3477 returned 100% blocks executed 100%
     3477: 5001:char *readable_form( c )
        -: 5002:register int c;
        -: 5003:	{
        -: 5004:	static char rform[10];
        -: 5005:
     3477: 5006:	if ( (c >= 0 && c < 32) || c >= 127 )
branch  0 taken 3477 (fallthrough)
branch  1 taken 0
branch  2 taken 3013 (fallthrough)
branch  3 taken 464
branch  4 taken 1683 (fallthrough)
branch  5 taken 1330
        -: 5007:		{
     2147: 5008:		switch ( c )
branch  0 taken 14
branch  1 taken 14
branch  2 taken 18
branch  3 taken 14
branch  4 taken 18
branch  5 taken 14
branch  6 taken 18
branch  7 taken 2037
        -: 5009:			{
       14: 5010:			case '\b': return "\\b";
       14: 5011:			case '\f': return "\\f";
       18: 5012:			case '\n': return "\\n";
       14: 5013:			case '\r': return "\\r";
       18: 5014:			case '\t': return "\\t";
        -: 5015:
        -: 5016:#if __STDC__
       14: 5017:			case '\a': return "\\a";
       18: 5018:			case '\v': return "\\v";
        -: 5019:#endif
        -: 5020:
     2037: 5021:			default:
     2037: 5022:				(void) sprintf( rform, "\\%.3o",
        -: 5023:						(unsigned int) c );
     2037: 5024:				return rform;
        -: 5025:			}
        -: 5026:		}
        -: 5027:
     1330: 5028:	else if ( c == ' ' )
branch  0 taken 14 (fallthrough)
branch  1 taken 1316
       14: 5029:		return "' '";
        -: 5030:
        -: 5031:	else
        -: 5032:		{
     1316: 5033:		rform[0] = c;
     1316: 5034:		rform[1] = '\0';
        -: 5035:
     1316: 5036:		return rform;
        -: 5037:		}
        -: 5038:	}
        -: 5039:
        -: 5040:
        -: 5041:/* reallocate_array - increase the size of a dynamic array */
        -: 5042:
function reallocate_array called 171 returned 100% blocks executed 80%
      171: 5043:void *reallocate_array( array, size, element_size )
        -: 5044:void *array;
        -: 5045:int size;
        -: 5046:size_t element_size;
        -: 5047:	{
        -: 5048:	register void *new_array;
      171: 5049:	size_t num_bytes = element_size * size;
        -: 5050:
      171: 5051:	new_array = flex_realloc( array, num_bytes );
call    0 returned 171
      171: 5052:	if ( ! new_array )
branch  0 taken 0 (fallthrough)
branch  1 taken 171
    #####: 5053:		flexfatal( _( "attempt to increase array size failed" ) );
call    0 never executed
        -: 5054:
      171: 5055:	return new_array;
        -: 5056:	}
        -: 5057:
        -: 5058:
        -: 5059:/* skelout - write out one section of the skeleton file
        -: 5060: *
        -: 5061: * Description
        -: 5062: *    Copies skelfile or skel array to stdout until a line beginning with
        -: 5063: *    "%%" or EOF is found.
        -: 5064: */
function skelout called 10870 returned 100% blocks executed 95%
    10870: 5065:void skelout()
        -: 5066:	{
        -: 5067:	char buf_storage[MAXLINE];
    10870: 5068:	char *buf = buf_storage;
    10870: 5069:	int do_copy = 1;
        -: 5070:
        -: 5071:	/* Loop pulling lines either from the skelfile, if we're using
        -: 5072:	 * one, or from the skel[] array.
        -: 5073:	 */
  1675190: 5074:	while ( skelfile ?
branch  0 taken 42 (fallthrough)
branch  1 taken 837553
branch  2 taken 837014
branch  3 taken 581 (fallthrough)
       42: 5075:		(fgets( buf, MAXLINE, skelfile ) != NULL) :
call    0 returned 42
   837553: 5076:		((buf = (char *) skel[skel_ind++]) != 0) )
        -: 5077:		{ /* copy from skel array */
   837014: 5078:		if ( buf[0] == '%' )
branch  0 taken 63437 (fallthrough)
branch  1 taken 773577
        -: 5079:			{ /* control line */
    63437: 5080:			switch ( buf[1] )
branch  0 taken 10289
branch  1 taken 14086
branch  2 taken 18444
branch  3 taken 20618
branch  4 taken 0
        -: 5081:				{
    10289: 5082:				case '%':
    10289: 5083:					return;
        -: 5084:
    14086: 5085:				case '+':
    14086: 5086:					do_copy = C_plus_plus;
    14086: 5087:					break;
        -: 5088:
    18444: 5089:				case '-':
    18444: 5090:					do_copy = ! C_plus_plus;
    18444: 5091:					break;
        -: 5092:
    20618: 5093:				case '*':
    20618: 5094:					do_copy = 1;
    20618: 5095:					break;
        -: 5096:
    #####: 5097:				default:
    #####: 5098:					flexfatal(
call    0 never executed
        -: 5099:					_( "bad line in skeleton file" ) );
        -: 5100:				}
        -: 5101:			}
        -: 5102:
   773577: 5103:		else if ( do_copy )
branch  0 taken 712424 (fallthrough)
branch  1 taken 61153
        -: 5104:			{
   712424: 5105:			if ( skelfile )
branch  0 taken 2 (fallthrough)
branch  1 taken 712422
        -: 5106:				/* Skeleton file reads include final
        -: 5107:				 * newline, skel[] array does not.
        -: 5108:				 */
        2: 5109:				out( buf );
call    0 returned 2
        -: 5110:			else
   712422: 5111:				outn( buf );
call    0 returned 712422
        -: 5112:			}
        -: 5113:		}
        -: 5114:	}
        -: 5115:
        -: 5116:
        -: 5117:/* transition_struct_out - output a yy_trans_info structure
        -: 5118: *
        -: 5119: * outputs the yy_trans_info structure with the two elements, element_v and
        -: 5120: * element_n.  Formats the output with spaces and carriage returns.
        -: 5121: */
        -: 5122:
function transition_struct_out called 55697 returned 100% blocks executed 100%
    55697: 5123:void transition_struct_out( element_v, element_n )
        -: 5124:int element_v, element_n;
        -: 5125:	{
    55697: 5126:	out_dec2( " {%4d,%4d },", element_v, element_n );
call    0 returned 55697
        -: 5127:
    55697: 5128:	datapos += TRANS_STRUCT_PRINT_LENGTH;
        -: 5129:
    55697: 5130:	if ( datapos >= 79 - TRANS_STRUCT_PRINT_LENGTH )
branch  0 taken 11103 (fallthrough)
branch  1 taken 44594
        -: 5131:		{
    11103: 5132:		outc( '\n' );
call    0 returned 11103
        -: 5133:
    11103: 5134:		if ( ++dataline % 10 == 0 )
branch  0 taken 1062 (fallthrough)
branch  1 taken 10041
     1062: 5135:			outc( '\n' );
call    0 returned 1062
        -: 5136:
    11103: 5137:		datapos = 0;
        -: 5138:		}
    55697: 5139:	}
        -: 5140:
        -: 5141:
        -: 5142:/* The following is only needed when building flex's parser using certain
        -: 5143: * broken versions of bison.
        -: 5144: */
function yy_flex_xmalloc called 0 returned 0% blocks executed 0%
    #####: 5145:void *yy_flex_xmalloc( size )
        -: 5146:int size;
        -: 5147:	{
    #####: 5148:	void *result = flex_alloc( (size_t) size );
call    0 never executed
        -: 5149:
    #####: 5150:	if ( ! result  )
branch  0 never executed
branch  1 never executed
    #####: 5151:		flexfatal(
call    0 never executed
        -: 5152:			_( "memory allocation failed in yy_flex_xmalloc()" ) );
        -: 5153:
    #####: 5154:	return result;
        -: 5155:	}
        -: 5156:
        -: 5157:
        -: 5158:/* zero_out - set a region of memory to 0
        -: 5159: *
        -: 5160: * Sets region_ptr[0] through region_ptr[size_in_bytes - 1] to zero.
        -: 5161: */
        -: 5162:
function zero_out called 575 returned 100% blocks executed 100%
      575: 5163:void zero_out( region_ptr, size_in_bytes )
        -: 5164:char *region_ptr;
        -: 5165:size_t size_in_bytes;
        -: 5166:	{
        -: 5167:	register char *rp, *rp_end;
        -: 5168:
      575: 5169:	rp = region_ptr;
      575: 5170:	rp_end = region_ptr + size_in_bytes;
        -: 5171:
  4600575: 5172:	while ( rp < rp_end )
branch  0 taken 4600000
branch  1 taken 575 (fallthrough)
  4600000: 5173:		*rp++ = 0;
      575: 5174:	}
        -: 5175:/* nfa - NFA construction routines */
        -: 5176:
        -: 5177:/*-
        -: 5178: * Copyright (c) 1990 The Regents of the University of California.
        -: 5179: * All rights reserved.
        -: 5180: *
        -: 5181: * This code is derived from software contributed to Berkeley by
        -: 5182: * Vern Paxson.
        -: 5183: * 
        -: 5184: * The United States Government has rights in this work pursuant
        -: 5185: * to contract no. DE-AC03-76SF00098 between the United States
        -: 5186: * Department of Energy and the University of California.
        -: 5187: *
        -: 5188: * Redistribution and use in source and binary forms with or without
        -: 5189: * modification are permitted provided that: (1) source distributions retain
        -: 5190: * this entire copyright notice and comment, and (2) distributions including
        -: 5191: * binaries display the following acknowledgement:  ``This product includes
        -: 5192: * software developed by the University of California, Berkeley and its
        -: 5193: * contributors'' in the documentation or other materials provided with the
        -: 5194: * distribution and in all advertising materials mentioning features or use
        -: 5195: * of this software.  Neither the name of the University nor the names of
        -: 5196: * its contributors may be used to endorse or promote products derived from
        -: 5197: * this software without specific prior written permission.
        -: 5198: * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
        -: 5199: * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
        -: 5200: * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
        -: 5201: */
        -: 5202:
        -: 5203:/* $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.seeded/v5/flex.c,v 1.1.1.2 2003/09/02 20:22:00 expsir Exp $ */
        -: 5204:
        -: 5205:
        -: 5206:
        -: 5207:/* declare functions that have forward references */
        -: 5208:
        -: 5209:int dupmachine PROTO((int));
        -: 5210:void mkxtion PROTO((int, int));
        -: 5211:
        -: 5212:
        -: 5213:/* add_accept - add an accepting state to a machine
        -: 5214: *
        -: 5215: * accepting_number becomes mach's accepting number.
        -: 5216: */
        -: 5217:
function add_accept called 4131 returned 100% blocks executed 100%
     4131: 5218:void add_accept( mach, accepting_number )
        -: 5219:int mach, accepting_number;
        -: 5220:	{
        -: 5221:	/* Hang the accepting number off an epsilon state.  if it is associated
        -: 5222:	 * with a state that has a non-epsilon out-transition, then the state
        -: 5223:	 * will accept BEFORE it makes that transition, i.e., one character
        -: 5224:	 * too soon.
        -: 5225:	 */
        -: 5226:
     4131: 5227:	if ( transchar[finalst[mach]] == SYM_EPSILON )
branch  0 taken 1411 (fallthrough)
branch  1 taken 2720
     1411: 5228:		accptnum[finalst[mach]] = accepting_number;
        -: 5229:
        -: 5230:	else
        -: 5231:		{
     2720: 5232:		int astate = mkstate( SYM_EPSILON );
call    0 returned 2720
     2720: 5233:		accptnum[astate] = accepting_number;
     2720: 5234:		(void) link_machines( mach, astate );
call    0 returned 2720
        -: 5235:		}
     4131: 5236:	}
        -: 5237:
        -: 5238:
        -: 5239:/* copysingl - make a given number of copies of a singleton machine
        -: 5240: *
        -: 5241: * synopsis
        -: 5242: *
        -: 5243: *   newsng = copysingl( singl, num );
        -: 5244: *
        -: 5245: *     newsng - a new singleton composed of num copies of singl
        -: 5246: *     singl  - a singleton machine
        -: 5247: *     num    - the number of copies of singl to be present in newsng
        -: 5248: */
        -: 5249:
function copysingl called 296 returned 100% blocks executed 100%
      296: 5250:int copysingl( singl, num )
        -: 5251:int singl, num;
        -: 5252:	{
        -: 5253:	int copy, i;
        -: 5254:
      296: 5255:	copy = mkstate( SYM_EPSILON );
call    0 returned 296
        -: 5256:
      786: 5257:	for ( i = 1; i <= num; ++i )
branch  0 taken 490
branch  1 taken 296 (fallthrough)
      490: 5258:		copy = link_machines( copy, dupmachine( singl ) );
call    0 returned 490
call    1 returned 490
        -: 5259:
      296: 5260:	return copy;
        -: 5261:	}
        -: 5262:
        -: 5263:
        -: 5264:/* dumpnfa - debugging routine to write out an nfa */
        -: 5265:
function dumpnfa called 14 returned 100% blocks executed 100%
       14: 5266:void dumpnfa( state1 )
        -: 5267:int state1;
        -: 5268:
        -: 5269:	{
        -: 5270:	int sym, tsp1, tsp2, anum, ns;
        -: 5271:
       14: 5272:	fprintf( err,
call    0 returned 14
        -: 5273:	_( "\n\n********** beginning dump of nfa with start state %d\n" ),
        -: 5274:		state1 );
        -: 5275:
        -: 5276:	/* We probably should loop starting at firstst[state1] and going to
        -: 5277:	 * lastst[state1], but they're not maintained properly when we "or"
        -: 5278:	 * all of the rules together.  So we use our knowledge that the machine
        -: 5279:	 * starts at state 1 and ends at lastnfa.
        -: 5280:	 */
        -: 5281:
        -: 5282:	/* for ( ns = firstst[state1]; ns <= lastst[state1]; ++ns ) */
     4072: 5283:	for ( ns = 1; ns <= lastnfa; ++ns )
branch  0 taken 4058
branch  1 taken 14 (fallthrough)
        -: 5284:		{
     4058: 5285:		fprintf( err, _( "state # %4d\t" ), ns );
call    0 returned 4058
        -: 5286:
     4058: 5287:		sym = transchar[ns];
     4058: 5288:		tsp1 = trans1[ns];
     4058: 5289:		tsp2 = trans2[ns];
     4058: 5290:		anum = accptnum[ns];
        -: 5291:
     4058: 5292:		fprintf( err, "%3d:  %4d, %4d", sym, tsp1, tsp2 );
call    0 returned 4058
        -: 5293:
     4058: 5294:		if ( anum != NIL )
branch  0 taken 639 (fallthrough)
branch  1 taken 3419
      639: 5295:			fprintf( err, "  [%d]", anum );
call    0 returned 639
        -: 5296:
     4058: 5297:		fprintf( err, "\n" );
call    0 returned 4058
        -: 5298:		}
        -: 5299:
       14: 5300:	fprintf( err, _( "********** end of dump\n" ) );
call    0 returned 14
       14: 5301:	}
        -: 5302:
        -: 5303:
        -: 5304:/* dupmachine - make a duplicate of a given machine
        -: 5305: *
        -: 5306: * synopsis
        -: 5307: *
        -: 5308: *   copy = dupmachine( mach );
        -: 5309: *
        -: 5310: *     copy - holds duplicate of mach
        -: 5311: *     mach - machine to be duplicated
        -: 5312: *
        -: 5313: * note that the copy of mach is NOT an exact duplicate; rather, all the
        -: 5314: * transition states values are adjusted so that the copy is self-contained,
        -: 5315: * as the original should have been.
        -: 5316: *
        -: 5317: * also note that the original MUST be contiguous, with its low and high
        -: 5318: * states accessible by the arrays firstst and lastst
        -: 5319: */
        -: 5320:
function dupmachine called 886 returned 100% blocks executed 62%
      886: 5321:int dupmachine( mach )
        -: 5322:int mach;
        -: 5323:	{
        -: 5324:	int i, init, state_offset;
      886: 5325:	int state = 0;
      886: 5326:	int last = lastst[mach];
        -: 5327:
     1772: 5328:	for ( i = firstst[mach]; i <= last; ++i )
branch  0 taken 886
branch  1 taken 886 (fallthrough)
        -: 5329:		{
      886: 5330:		state = mkstate( transchar[i] );
call    0 returned 886
        -: 5331:
      886: 5332:		if ( trans1[i] != NO_TRANSITION )
branch  0 taken 0 (fallthrough)
branch  1 taken 886
        -: 5333:			{
    #####: 5334:			mkxtion( finalst[state], trans1[i] + state - i );
call    0 never executed
        -: 5335:
    #####: 5336:			if ( transchar[i] == SYM_EPSILON &&
branch  0 never executed
branch  1 never executed
    #####: 5337:			     trans2[i] != NO_TRANSITION )
branch  0 never executed
branch  1 never executed
    #####: 5338:				mkxtion( finalst[state],
    #####: 5339:					trans2[i] + state - i );
call    0 never executed
        -: 5340:			}
        -: 5341:
      886: 5342:		accptnum[state] = accptnum[i];
        -: 5343:		}
        -: 5344:
      886: 5345:	if ( state == 0 )
branch  0 taken 0 (fallthrough)
branch  1 taken 886
    #####: 5346:		flexfatal( _( "empty machine in dupmachine()" ) );
call    0 never executed
        -: 5347:
      886: 5348:	state_offset = state - i + 1;
        -: 5349:
      886: 5350:	init = mach + state_offset;
      886: 5351:	firstst[init] = firstst[mach] + state_offset;
      886: 5352:	finalst[init] = finalst[mach] + state_offset;
      886: 5353:	lastst[init] = lastst[mach] + state_offset;
        -: 5354:
      886: 5355:	return init;
        -: 5356:	}
        -: 5357:
        -: 5358:
        -: 5359:/* finish_rule - finish up the processing for a rule
        -: 5360: *
        -: 5361: * An accepting number is added to the given machine.  If variable_trail_rule
        -: 5362: * is true then the rule has trailing context and both the head and trail
        -: 5363: * are variable size.  Otherwise if headcnt or trailcnt is non-zero then
        -: 5364: * the machine recognizes a pattern with trailing context and headcnt is
        -: 5365: * the number of characters in the matched part of the pattern, or zero
        -: 5366: * if the matched part has variable length.  trailcnt is the number of
        -: 5367: * trailing context characters in the pattern, or zero if the trailing
        -: 5368: * context has variable length.
        -: 5369: */
        -: 5370:
function finish_rule called 4067 returned 100% blocks executed 100%
     4067: 5371:void finish_rule( mach, variable_trail_rule, headcnt, trailcnt )
        -: 5372:int mach, variable_trail_rule, headcnt, trailcnt;
        -: 5373:	{
        -: 5374:	char action_text[MAXLINE];
        -: 5375:
     4067: 5376:	add_accept( mach, num_rules );
call    0 returned 4067
        -: 5377:
        -: 5378:	/* We did this in new_rule(), but it often gets the wrong
        -: 5379:	 * number because we do it before we start parsing the current rule.
        -: 5380:	 */
     4067: 5381:	rule_linenum[num_rules] = linenum;
        -: 5382:
        -: 5383:	/* If this is a continued action, then the line-number has already
        -: 5384:	 * been updated, giving us the wrong number.
        -: 5385:	 */
     4067: 5386:	if ( continued_action )
branch  0 taken 11 (fallthrough)
branch  1 taken 4056
       11: 5387:		--rule_linenum[num_rules];
        -: 5388:
     4067: 5389:	sprintf( action_text, "case %d:\n", num_rules );
     4067: 5390:	add_action( action_text );
call    0 returned 4067
        -: 5391:
     4067: 5392:	if ( variable_trail_rule )
branch  0 taken 64 (fallthrough)
branch  1 taken 4003
        -: 5393:		{
       64: 5394:		rule_type[num_rules] = RULE_VARIABLE;
        -: 5395:
       64: 5396:		if ( performance_report > 0 )
branch  0 taken 1 (fallthrough)
branch  1 taken 63
        1: 5397:			fprintf( err,
        -: 5398:			_( "Variable trailing context rule at line %d\n" ),
        1: 5399:				rule_linenum[num_rules] );
call    0 returned 1
        -: 5400:
       64: 5401:		variable_trailing_context_rules = true;
        -: 5402:		}
        -: 5403:
        -: 5404:	else
        -: 5405:		{
     4003: 5406:		rule_type[num_rules] = RULE_NORMAL;
        -: 5407:
     4003: 5408:		if ( headcnt > 0 || trailcnt > 0 )
branch  0 taken 3926 (fallthrough)
branch  1 taken 77
branch  2 taken 72 (fallthrough)
branch  3 taken 3854
        -: 5409:			{
        -: 5410:			/* Do trailing context magic to not match the trailing
        -: 5411:			 * characters.
        -: 5412:			 */
      149: 5413:			char *scanner_cp = "yy_c_buf_p = yy_cp";
      149: 5414:			char *scanner_bp = "yy_bp";
        -: 5415:
      149: 5416:			add_action(
call    0 returned 149
        -: 5417:	"*yy_cp = yy_hold_char; /* undo effects of setting up yytext */\n" );
        -: 5418:
      149: 5419:			if ( headcnt > 0 )
branch  0 taken 77 (fallthrough)
branch  1 taken 72
        -: 5420:				{
       77: 5421:				sprintf( action_text, "%s = %s + %d;\n",
        -: 5422:				scanner_cp, scanner_bp, headcnt );
       77: 5423:				add_action( action_text );
call    0 returned 77
        -: 5424:				}
        -: 5425:
        -: 5426:			else
        -: 5427:				{
       72: 5428:				sprintf( action_text, "%s -= %d;\n",
        -: 5429:					scanner_cp, trailcnt );
       72: 5430:				add_action( action_text );
call    0 returned 72
        -: 5431:				}
        -: 5432:
      149: 5433:			add_action(
call    0 returned 149
        -: 5434:			"YY_DO_BEFORE_ACTION; /* set up yytext again */\n" );
        -: 5435:			}
        -: 5436:		}
        -: 5437:
        -: 5438:	/* Okay, in the action code at this point yytext and yyleng have
        -: 5439:	 * their proper final values for this rule, so here's the point
        -: 5440:	 * to do any user action.  But don't do it for continued actions,
        -: 5441:	 * as that'll result in multiple YY_RULE_SETUP's.
        -: 5442:	 */
     4067: 5443:	if ( ! continued_action )
branch  0 taken 4056 (fallthrough)
branch  1 taken 11
     4056: 5444:		add_action( "YY_RULE_SETUP\n" );
call    0 returned 4056
        -: 5445:
     4067: 5446:	line_directive_out( (FILE *) 0, 1 );
call    0 returned 4067
     4067: 5447:	}
        -: 5448:
        -: 5449:
        -: 5450:/* link_machines - connect two machines together
        -: 5451: *
        -: 5452: * synopsis
        -: 5453: *
        -: 5454: *   new = link_machines( first, last );
        -: 5455: *
        -: 5456: *     new    - a machine constructed by connecting first to last
        -: 5457: *     first  - the machine whose successor is to be last
        -: 5458: *     last   - the machine whose predecessor is to be first
        -: 5459: *
        -: 5460: * note: this routine concatenates the machine first with the machine
        -: 5461: *  last to produce a machine new which will pattern-match first first
        -: 5462: *  and then last, and will fail if either of the sub-patterns fails.
        -: 5463: *  FIRST is set to new by the operation.  last is unmolested.
        -: 5464: */
        -: 5465:
function link_machines called 18453 returned 100% blocks executed 71%
    18453: 5466:int link_machines( first, last )
        -: 5467:int first, last;
        -: 5468:	{
    18453: 5469:	if ( first == NIL )
branch  0 taken 0 (fallthrough)
branch  1 taken 18453
    #####: 5470:		return last;
        -: 5471:
    18453: 5472:	else if ( last == NIL )
branch  0 taken 0 (fallthrough)
branch  1 taken 18453
    #####: 5473:		return first;
        -: 5474:
        -: 5475:	else
        -: 5476:		{
    18453: 5477:		mkxtion( finalst[first], last );
call    0 returned 18453
    18453: 5478:		finalst[first] = finalst[last];
    18453: 5479:		lastst[first] = MAX( lastst[first], lastst[last] );
    18453: 5480:		firstst[first] = MIN( firstst[first], firstst[last] );
        -: 5481:
    18453: 5482:		return first;
        -: 5483:		}
        -: 5484:	}
        -: 5485:
        -: 5486:
        -: 5487:/* mark_beginning_as_normal - mark each "beginning" state in a machine
        -: 5488: *                            as being a "normal" (i.e., not trailing context-
        -: 5489: *                            associated) states
        -: 5490: *
        -: 5491: * The "beginning" states are the epsilon closure of the first state
        -: 5492: */
        -: 5493:
function mark_beginning_as_normal called 110 returned 100% blocks executed 36%
      110: 5494:void mark_beginning_as_normal( mach )
        -: 5495:register int mach;
        -: 5496:	{
      110: 5497:	switch ( state_type[mach] )
branch  0 taken 0
branch  1 taken 110
branch  2 taken 0
        -: 5498:		{
    #####: 5499:		case STATE_NORMAL:
        -: 5500:			/* Oh, we've already visited here. */
    #####: 5501:			return;
        -: 5502:
      110: 5503:		case STATE_TRAILING_CONTEXT:
      110: 5504:			state_type[mach] = STATE_NORMAL;
        -: 5505:
      110: 5506:			if ( transchar[mach] == SYM_EPSILON )
branch  0 taken 0 (fallthrough)
branch  1 taken 110
        -: 5507:				{
    #####: 5508:				if ( trans1[mach] != NO_TRANSITION )
branch  0 never executed
branch  1 never executed
    #####: 5509:					mark_beginning_as_normal(
    #####: 5510:						trans1[mach] );
call    0 never executed
        -: 5511:
    #####: 5512:				if ( trans2[mach] != NO_TRANSITION )
branch  0 never executed
branch  1 never executed
    #####: 5513:					mark_beginning_as_normal(
    #####: 5514:						trans2[mach] );
call    0 never executed
        -: 5515:				}
      110: 5516:			break;
        -: 5517:
    #####: 5518:		default:
    #####: 5519:			flexerror(
call    0 never executed
        -: 5520:			_( "bad state type in mark_beginning_as_normal()" ) );
    #####: 5521:			break;
        -: 5522:		}
        -: 5523:	}
        -: 5524:
        -: 5525:
        -: 5526:/* mkbranch - make a machine that branches to two machines
        -: 5527: *
        -: 5528: * synopsis
        -: 5529: *
        -: 5530: *   branch = mkbranch( first, second );
        -: 5531: *
        -: 5532: *     branch - a machine which matches either first's pattern or second's
        -: 5533: *     first, second - machines whose patterns are to be or'ed (the | operator)
        -: 5534: *
        -: 5535: * Note that first and second are NEITHER destroyed by the operation.  Also,
        -: 5536: * the resulting machine CANNOT be used with any other "mk" operation except
        -: 5537: * more mkbranch's.  Compare with mkor()
        -: 5538: */
        -: 5539:
function mkbranch called 4680 returned 100% blocks executed 78%
     4680: 5540:int mkbranch( first, second )
        -: 5541:int first, second;
        -: 5542:	{
        -: 5543:	int eps;
        -: 5544:
     4680: 5545:	if ( first == NO_TRANSITION )
branch  0 taken 0 (fallthrough)
branch  1 taken 4680
    #####: 5546:		return second;
        -: 5547:
     4680: 5548:	else if ( second == NO_TRANSITION )
branch  0 taken 0 (fallthrough)
branch  1 taken 4680
    #####: 5549:		return first;
        -: 5550:
     4680: 5551:	eps = mkstate( SYM_EPSILON );
call    0 returned 4680
        -: 5552:
     4680: 5553:	mkxtion( eps, first );
call    0 returned 4680
     4680: 5554:	mkxtion( eps, second );
call    0 returned 4680
        -: 5555:
     4680: 5556:	return eps;
        -: 5557:	}
        -: 5558:
        -: 5559:
        -: 5560:/* mkclos - convert a machine into a closure
        -: 5561: *
        -: 5562: * synopsis
        -: 5563: *   new = mkclos( state );
        -: 5564: *
        -: 5565: * new - a new state which matches the closure of "state"
        -: 5566: */
        -: 5567:
function mkclos called 944 returned 100% blocks executed 100%
      944: 5568:int mkclos( state )
        -: 5569:int state;
        -: 5570:	{
      944: 5571:	return mkopt( mkposcl( state ) );
call    0 returned 944
call    1 returned 944
        -: 5572:	}
        -: 5573:
        -: 5574:
        -: 5575:/* mkopt - make a machine optional
        -: 5576: *
        -: 5577: * synopsis
        -: 5578: *
        -: 5579: *   new = mkopt( mach );
        -: 5580: *
        -: 5581: *     new  - a machine which optionally matches whatever mach matched
        -: 5582: *     mach - the machine to make optional
        -: 5583: *
        -: 5584: * notes:
        -: 5585: *     1. mach must be the last machine created
        -: 5586: *     2. mach is destroyed by the call
        -: 5587: */
        -: 5588:
function mkopt called 1246 returned 100% blocks executed 100%
     1246: 5589:int mkopt( mach )
        -: 5590:int mach;
        -: 5591:	{
        -: 5592:	int eps;
        -: 5593:
     1246: 5594:	if ( ! SUPER_FREE_EPSILON(finalst[mach]) )
branch  0 taken 1244 (fallthrough)
branch  1 taken 2
branch  2 taken 944 (fallthrough)
branch  3 taken 300
        -: 5595:		{
      946: 5596:		eps = mkstate( SYM_EPSILON );
call    0 returned 946
      946: 5597:		mach = link_machines( mach, eps );
call    0 returned 946
        -: 5598:		}
        -: 5599:
        -: 5600:	/* Can't skimp on the following if FREE_EPSILON(mach) is true because
        -: 5601:	 * some state interior to "mach" might point back to the beginning
        -: 5602:	 * for a closure.
        -: 5603:	 */
     1246: 5604:	eps = mkstate( SYM_EPSILON );
call    0 returned 1246
     1246: 5605:	mach = link_machines( eps, mach );
call    0 returned 1246
        -: 5606:
     1246: 5607:	mkxtion( mach, finalst[mach] );
call    0 returned 1246
        -: 5608:
     1246: 5609:	return mach;
        -: 5610:	}
        -: 5611:
        -: 5612:
        -: 5613:/* mkor - make a machine that matches either one of two machines
        -: 5614: *
        -: 5615: * synopsis
        -: 5616: *
        -: 5617: *   new = mkor( first, second );
        -: 5618: *
        -: 5619: *     new - a machine which matches either first's pattern or second's
        -: 5620: *     first, second - machines whose patterns are to be or'ed (the | operator)
        -: 5621: *
        -: 5622: * note that first and second are both destroyed by the operation
        -: 5623: * the code is rather convoluted because an attempt is made to minimize
        -: 5624: * the number of epsilon states needed
        -: 5625: */
        -: 5626:
function mkor called 1103 returned 100% blocks executed 90%
     1103: 5627:int mkor( first, second )
        -: 5628:int first, second;
        -: 5629:	{
        -: 5630:	int eps, orend;
        -: 5631:
     1103: 5632:	if ( first == NIL )
branch  0 taken 0 (fallthrough)
branch  1 taken 1103
    #####: 5633:		return second;
        -: 5634:
     1103: 5635:	else if ( second == NIL )
branch  0 taken 0 (fallthrough)
branch  1 taken 1103
    #####: 5636:		return first;
        -: 5637:
        -: 5638:	else
        -: 5639:		{
        -: 5640:		/* See comment in mkopt() about why we can't use the first
        -: 5641:		 * state of "first" or "second" if they satisfy "FREE_EPSILON".
        -: 5642:		 */
     1103: 5643:		eps = mkstate( SYM_EPSILON );
call    0 returned 1103
        -: 5644:
     1103: 5645:		first = link_machines( eps, first );
call    0 returned 1103
        -: 5646:
     1103: 5647:		mkxtion( first, second );
call    0 returned 1103
        -: 5648:
     1103: 5649:		if ( SUPER_FREE_EPSILON(finalst[first]) &&
branch  0 taken 672 (fallthrough)
branch  1 taken 431
branch  2 taken 672 (fallthrough)
branch  3 taken 0
      672: 5650:		     accptnum[finalst[first]] == NIL )
branch  0 taken 672 (fallthrough)
branch  1 taken 0
        -: 5651:			{
      672: 5652:			orend = finalst[first];
      672: 5653:			mkxtion( finalst[second], orend );
call    0 returned 672
        -: 5654:			}
        -: 5655:
      431: 5656:		else if ( SUPER_FREE_EPSILON(finalst[second]) &&
branch  0 taken 100 (fallthrough)
branch  1 taken 331
branch  2 taken 100 (fallthrough)
branch  3 taken 0
      100: 5657:			  accptnum[finalst[second]] == NIL )
branch  0 taken 100 (fallthrough)
branch  1 taken 0
        -: 5658:			{
      100: 5659:			orend = finalst[second];
      100: 5660:			mkxtion( finalst[first], orend );
call    0 returned 100
        -: 5661:			}
        -: 5662:
        -: 5663:		else
        -: 5664:			{
      331: 5665:			eps = mkstate( SYM_EPSILON );
call    0 returned 331
        -: 5666:
      331: 5667:			first = link_machines( first, eps );
call    0 returned 331
      331: 5668:			orend = finalst[first];
        -: 5669:
      331: 5670:			mkxtion( finalst[second], orend );
call    0 returned 331
        -: 5671:			}
        -: 5672:		}
        -: 5673:
     1103: 5674:	finalst[first] = orend;
     1103: 5675:	return first;
        -: 5676:	}
        -: 5677:
        -: 5678:
        -: 5679:/* mkposcl - convert a machine into a positive closure
        -: 5680: *
        -: 5681: * synopsis
        -: 5682: *   new = mkposcl( state );
        -: 5683: *
        -: 5684: *    new - a machine matching the positive closure of "state"
        -: 5685: */
        -: 5686:
function mkposcl called 1292 returned 100% blocks executed 67%
     1292: 5687:int mkposcl( state )
        -: 5688:int state;
        -: 5689:	{
        -: 5690:	int eps;
        -: 5691:
    1292*: 5692:	if ( SUPER_FREE_EPSILON(finalst[state]) )
branch  0 taken 0 (fallthrough)
branch  1 taken 1292
branch  2 never executed
branch  3 never executed
        -: 5693:		{
    #####: 5694:		mkxtion( finalst[state], state );
call    0 never executed
    #####: 5695:		return state;
        -: 5696:		}
        -: 5697:
        -: 5698:	else
        -: 5699:		{
     1292: 5700:		eps = mkstate( SYM_EPSILON );
call    0 returned 1292
     1292: 5701:		mkxtion( eps, state );
call    0 returned 1292
     1292: 5702:		return link_machines( state, eps );
call    0 returned 1292
        -: 5703:		}
        -: 5704:	}
        -: 5705:
        -: 5706:
        -: 5707:/* mkrep - make a replicated machine
        -: 5708: *
        -: 5709: * synopsis
        -: 5710: *   new = mkrep( mach, lb, ub );
        -: 5711: *
        -: 5712: *    new - a machine that matches whatever "mach" matched from "lb"
        -: 5713: *          number of times to "ub" number of times
        -: 5714: *
        -: 5715: * note
        -: 5716: *   if "ub" is INFINITY then "new" matches "lb" or more occurrences of "mach"
        -: 5717: */
        -: 5718:
function mkrep called 198 returned 100% blocks executed 100%
      198: 5719:int mkrep( mach, lb, ub )
        -: 5720:int mach, lb, ub;
        -: 5721:	{
        -: 5722:	int base_mach, tail, copy, i;
        -: 5723:
      198: 5724:	base_mach = copysingl( mach, lb - 1 );
call    0 returned 198
        -: 5725:
      198: 5726:	if ( ub == INFINITY )
branch  0 taken 98 (fallthrough)
branch  1 taken 100
        -: 5727:		{
       98: 5728:		copy = dupmachine( mach );
call    0 returned 98
       98: 5729:		mach = link_machines( mach,
call    0 returned 98
call    1 returned 98
call    2 returned 98
        -: 5730:		link_machines( base_mach, mkclos( copy ) ) );
        -: 5731:		}
        -: 5732:
        -: 5733:	else
        -: 5734:		{
      100: 5735:		tail = mkstate( SYM_EPSILON );
call    0 returned 100
        -: 5736:
      398: 5737:		for ( i = lb; i < ub; ++i )
branch  0 taken 298
branch  1 taken 100 (fallthrough)
        -: 5738:			{
      298: 5739:			copy = dupmachine( mach );
call    0 returned 298
      298: 5740:			tail = mkopt( link_machines( copy, tail ) );
call    0 returned 298
call    1 returned 298
        -: 5741:			}
        -: 5742:
      100: 5743:		mach = link_machines( mach, link_machines( base_mach, tail ) );
call    0 returned 100
call    1 returned 100
        -: 5744:		}
        -: 5745:
      198: 5746:	return mach;
        -: 5747:	}
        -: 5748:
        -: 5749:
        -: 5750:/* mkstate - create a state with a transition on a given symbol
        -: 5751: *
        -: 5752: * synopsis
        -: 5753: *
        -: 5754: *   state = mkstate( sym );
        -: 5755: *
        -: 5756: *     state - a new state matching sym
        -: 5757: *     sym   - the symbol the new state is to have an out-transition on
        -: 5758: *
        -: 5759: * note that this routine makes new states in ascending order through the
        -: 5760: * state array (and increments LASTNFA accordingly).  The routine DUPMACHINE
        -: 5761: * relies on machines being made in ascending order and that they are
        -: 5762: * CONTIGUOUS.  Change it and you will have to rewrite DUPMACHINE (kludge
        -: 5763: * that it admittedly is)
        -: 5764: */
        -: 5765:
function mkstate called 29465 returned 100% blocks executed 96%
    29465: 5766:int mkstate( sym )
        -: 5767:int sym;
        -: 5768:	{
    29465: 5769:	if ( ++lastnfa >= current_mns )
branch  0 taken 2 (fallthrough)
branch  1 taken 29463
        -: 5770:		{
        2: 5771:		if ( (current_mns += MNS_INCREMENT) >= MAXIMUM_MNS )
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####: 5772:			lerrif(
call    0 never executed
        -: 5773:		_( "input rules are too complicated (>= %d NFA states)" ),
        -: 5774:				current_mns );
        -: 5775:
        2: 5776:		++num_reallocs;
        -: 5777:
        2: 5778:		firstst = reallocate_integer_array( firstst, current_mns );
call    0 returned 2
        2: 5779:		lastst = reallocate_integer_array( lastst, current_mns );
call    0 returned 2
        2: 5780:		finalst = reallocate_integer_array( finalst, current_mns );
call    0 returned 2
        2: 5781:		transchar = reallocate_integer_array( transchar, current_mns );
call    0 returned 2
        2: 5782:		trans1 = reallocate_integer_array( trans1, current_mns );
call    0 returned 2
        2: 5783:		trans2 = reallocate_integer_array( trans2, current_mns );
call    0 returned 2
        2: 5784:		accptnum = reallocate_integer_array( accptnum, current_mns );
call    0 returned 2
        2: 5785:		assoc_rule =
        2: 5786:			reallocate_integer_array( assoc_rule, current_mns );
call    0 returned 2
        2: 5787:		state_type =
        2: 5788:			reallocate_integer_array( state_type, current_mns );
call    0 returned 2
        -: 5789:		}
        -: 5790:
    29465: 5791:	firstst[lastnfa] = lastnfa;
    29465: 5792:	finalst[lastnfa] = lastnfa;
    29465: 5793:	lastst[lastnfa] = lastnfa;
    29465: 5794:	transchar[lastnfa] = sym;
    29465: 5795:	trans1[lastnfa] = NO_TRANSITION;
    29465: 5796:	trans2[lastnfa] = NO_TRANSITION;
    29465: 5797:	accptnum[lastnfa] = NIL;
    29465: 5798:	assoc_rule[lastnfa] = num_rules;
    29465: 5799:	state_type[lastnfa] = current_state_type;
        -: 5800:
        -: 5801:	/* Fix up equivalence classes base on this transition.  Note that any
        -: 5802:	 * character which has its own transition gets its own equivalence
        -: 5803:	 * class.  Thus only characters which are only in character classes
        -: 5804:	 * have a chance at being in the same equivalence class.  E.g. "a|b"
        -: 5805:	 * puts 'a' and 'b' into two different equivalence classes.  "[ab]"
        -: 5806:	 * puts them in the same equivalence class (barring other differences
        -: 5807:	 * elsewhere in the input).
        -: 5808:	 */
        -: 5809:
    29465: 5810:	if ( sym < 0 )
branch  0 taken 27169 (fallthrough)
branch  1 taken 2296
        -: 5811:		{
        -: 5812:		/* We don't have to update the equivalence classes since
        -: 5813:		 * that was already done when the ccl was created for the
        -: 5814:		 * first time.
        -: 5815:		 */
        -: 5816:		}
        -: 5817:
    27169: 5818:	else if ( sym == SYM_EPSILON )
branch  0 taken 15181 (fallthrough)
branch  1 taken 11988
    15181: 5819:		++numeps;
        -: 5820:
        -: 5821:	else
        -: 5822:		{
    11988: 5823:		check_char( sym );
call    0 returned 11987
        -: 5824:
    11987: 5825:		if ( useecs )
branch  0 taken 7561 (fallthrough)
branch  1 taken 4426
        -: 5826:			/* Map NUL's to csize. */
     7561: 5827:			mkechar( sym ? sym : csize, nextecm, ecgroup );
branch  0 taken 7559 (fallthrough)
branch  1 taken 2
call    2 returned 7561
        -: 5828:		}
        -: 5829:
    29464: 5830:	return lastnfa;
        -: 5831:	}
        -: 5832:
        -: 5833:
        -: 5834:/* mkxtion - make a transition from one state to another
        -: 5835: *
        -: 5836: * synopsis
        -: 5837: *
        -: 5838: *   mkxtion( statefrom, stateto );
        -: 5839: *
        -: 5840: *     statefrom - the state from which the transition is to be made
        -: 5841: *     stateto   - the state to which the transition is to be made
        -: 5842: */
        -: 5843:
function mkxtion called 32557 returned 100% blocks executed 86%
    32557: 5844:void mkxtion( statefrom, stateto )
        -: 5845:int statefrom, stateto;
        -: 5846:	{
    32557: 5847:	if ( trans1[statefrom] == NO_TRANSITION )
branch  0 taken 24471 (fallthrough)
branch  1 taken 8086
    24471: 5848:		trans1[statefrom] = stateto;
        -: 5849:
     8086: 5850:	else if ( (transchar[statefrom] != SYM_EPSILON) ||
branch  0 taken 8086 (fallthrough)
branch  1 taken 0
     8086: 5851:		  (trans2[statefrom] != NO_TRANSITION) )
branch  0 taken 0 (fallthrough)
branch  1 taken 8086
    #####: 5852:		flexfatal( _( "found too many transitions in mkxtion()" ) );
call    0 never executed
        -: 5853:
        -: 5854:	else
        -: 5855:		{ /* second out-transition for an epsilon state */
     8086: 5856:		++eps2;
     8086: 5857:		trans2[statefrom] = stateto;
        -: 5858:		}
    32557: 5859:	}
        -: 5860:
        -: 5861:/* new_rule - initialize for a new rule */
        -: 5862:
function new_rule called 4086 returned 100% blocks executed 88%
     4086: 5863:void new_rule()
        -: 5864:	{
     4086: 5865:	if ( ++num_rules >= current_max_rules )
branch  0 taken 7 (fallthrough)
branch  1 taken 4079
        -: 5866:		{
        7: 5867:		++num_reallocs;
        7: 5868:		current_max_rules += MAX_RULES_INCREMENT;
        7: 5869:		rule_type = reallocate_integer_array( rule_type,
call    0 returned 7
        -: 5870:							current_max_rules );
        7: 5871:		rule_linenum = reallocate_integer_array( rule_linenum,
call    0 returned 7
        -: 5872:							current_max_rules );
        7: 5873:		rule_useful = reallocate_integer_array( rule_useful,
call    0 returned 7
        -: 5874:							current_max_rules );
        -: 5875:		}
        -: 5876:
     4086: 5877:	if ( num_rules > MAX_RULE )
branch  0 taken 0 (fallthrough)
branch  1 taken 4086
    #####: 5878:		lerrif( _( "too many rules (> %d)!" ), MAX_RULE );
call    0 never executed
        -: 5879:
     4086: 5880:	rule_linenum[num_rules] = linenum;
     4086: 5881:	rule_useful[num_rules] = false;
     4086: 5882:	}
        -: 5883:/* File created from flex.skl via mkskel.sh */
        -: 5884:
        -: 5885:
        -: 5886:const char *skel[] = {
        -: 5887:  "/* A lexical scanner generated by flex */",
        -: 5888:  "",
        -: 5889:  "/* Scanner skeleton version:",
        -: 5890:  " * $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.seeded/v5/flex.c,v 1.1.1.2 2003/09/02 20:22:00 expsir Exp $",
        -: 5891:  " */",
        -: 5892:  "",
        -: 5893:  "#define FLEX_SCANNER",
        -: 5894:  "#define YY_FLEX_MAJOR_VERSION 2",
        -: 5895:  "#define YY_FLEX_MINOR_VERSION 5",
        -: 5896:  "",
        -: 5897:  "%-",
        -: 5898:  "#include <stdio.h>",
        -: 5899:  "%*",
        -: 5900:  "",
        -: 5901:  "",
        -: 5902:  "/* cfront 1.2 defines \"c_plusplus\" instead of \"__cplusplus\" */",
        -: 5903:  "#ifdef c_plusplus",
        -: 5904:  "#ifndef __cplusplus",
        -: 5905:  "#define __cplusplus",
        -: 5906:  "#endif",
        -: 5907:  "#endif",
        -: 5908:  "",
        -: 5909:  "",
        -: 5910:  "#ifdef __cplusplus",
        -: 5911:  "",
        -: 5912:  "#include <stdlib.h>",
        -: 5913:  "%+",
        -: 5914:  "class istream;",
        -: 5915:  "%*",
        -: 5916:  "#include <unistd.h>",
        -: 5917:  "",
        -: 5918:  "/* Use prototypes in function declarations. */",
        -: 5919:  "#define YY_USE_PROTOS",
        -: 5920:  "",
        -: 5921:  "/* The \"const\" storage-class-modifier is valid. */",
        -: 5922:  "#define YY_USE_CONST",
        -: 5923:  "",
        -: 5924:  "#else	/* ! __cplusplus */",
        -: 5925:  "",
        -: 5926:  "#if __STDC__",
        -: 5927:  "",
        -: 5928:  "#define YY_USE_PROTOS",
        -: 5929:  "#define YY_USE_CONST",
        -: 5930:  "",
        -: 5931:  "#endif	/* __STDC__ */",
        -: 5932:  "#endif	/* ! __cplusplus */",
        -: 5933:  "",
        -: 5934:  "#ifdef __TURBOC__",
        -: 5935:  " #pragma warn -rch",
        -: 5936:  " #pragma warn -use",
        -: 5937:  "#include <io.h>",
        -: 5938:  "#include <stdlib.h>",
        -: 5939:  "#define YY_USE_CONST",
        -: 5940:  "#define YY_USE_PROTOS",
        -: 5941:  "#endif",
        -: 5942:  "",
        -: 5943:  "#ifdef YY_USE_CONST",
        -: 5944:  "#define yyconst const",
        -: 5945:  "#else",
        -: 5946:  "#define yyconst",
        -: 5947:  "#endif",
        -: 5948:  "",
        -: 5949:  "",
        -: 5950:  "#ifdef YY_USE_PROTOS",
        -: 5951:  "#define YY_PROTO(proto) proto",
        -: 5952:  "#else",
        -: 5953:  "#define YY_PROTO(proto) ()",
        -: 5954:  "#endif",
        -: 5955:  "",
        -: 5956:  "/* Returned upon end-of-file. */",
        -: 5957:  "#define YY_NULL 0",
        -: 5958:  "",
        -: 5959:  "/* Promotes a possibly negative, possibly signed char to an unsigned",
        -: 5960:  " * integer for use as an array index.  If the signed char is negative,",
        -: 5961:  " * we want to instead treat it as an 8-bit unsigned char, hence the",
        -: 5962:  " * double cast.",
        -: 5963:  " */",
        -: 5964:  "#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)",
        -: 5965:  "",
        -: 5966:  "/* Enter a start condition.  This macro really ought to take a parameter,",
        -: 5967:  " * but we do it the disgusting crufty way forced on us by the ()-less",
        -: 5968:  " * definition of BEGIN.",
        -: 5969:  " */",
        -: 5970:  "#define BEGIN yy_start = 1 + 2 *",
        -: 5971:  "",
        -: 5972:  "/* Translate the current start state into a value that can be later handed",
        -: 5973:  " * to BEGIN to return to the state.  The YYSTATE alias is for lex",
        -: 5974:  " * compatibility.",
        -: 5975:  " */",
        -: 5976:  "#define YY_START ((yy_start - 1) / 2)",
        -: 5977:  "#define YYSTATE YY_START",
        -: 5978:  "",
        -: 5979:  "/* Action number for EOF rule of a given start state. */",
        -: 5980:  "#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)",
        -: 5981:  "",
        -: 5982:  "/* Special action meaning \"start processing a new file\". */",
        -: 5983:  "#define YY_NEW_FILE yyrestart( yyin )",
        -: 5984:  "",
        -: 5985:  "#define YY_END_OF_BUFFER_CHAR 0",
        -: 5986:  "",
        -: 5987:  "/* Size of default input buffer. */",
        -: 5988:  "#define YY_BUF_SIZE 16384",
        -: 5989:  "",
        -: 5990:  "typedef struct yy_buffer_state *YY_BUFFER_STATE;",
        -: 5991:  "",
        -: 5992:  "extern int yyleng;",
        -: 5993:  "%-",
        -: 5994:  "extern FILE *yyin, *yyout;",
        -: 5995:  "%*",
        -: 5996:  "",
        -: 5997:  "#define EOB_ACT_CONTINUE_SCAN 0",
        -: 5998:  "#define EOB_ACT_END_OF_FILE 1",
        -: 5999:  "#define EOB_ACT_LAST_MATCH 2",
        -: 6000:  "",
        -: 6001:  "/* The funky do-while in the following #define is used to turn the definition",
        -: 6002:  " * int a single C statement (which needs a semi-colon terminator).  This",
        -: 6003:  " * avoids problems with code like:",
        -: 6004:  " *",
        -: 6005:  " * 	if ( condition_holds )",
        -: 6006:  " *		yyless( 5 );",
        -: 6007:  " *	else",
        -: 6008:  " *		do_something_else();",
        -: 6009:  " *",
        -: 6010:  " * Prior to using the do-while the compiler would get upset at the",
        -: 6011:  " * \"else\" because it interpreted the \"if\" statement as being all",
        -: 6012:  " * done when it reached the ';' after the yyless() call.",
        -: 6013:  " */",
        -: 6014:  "",
        -: 6015:  "/* Return all but the first 'n' matched characters back to the input stream. */",
        -: 6016:  "",
        -: 6017:  "#define yyless(n) \\",
        -: 6018:  "	do \\",
        -: 6019:  "		{ \\",
        -: 6020:  "		/* Undo effects of setting up yytext. */ \\",
        -: 6021:  "		*yy_cp = yy_hold_char; \\",
        -: 6022:  "		YY_RESTORE_YY_MORE_OFFSET \\",
        -: 6023:  "		yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \\",
        -: 6024:  "		YY_DO_BEFORE_ACTION; /* set up yytext again */ \\",
        -: 6025:  "		} \\",
        -: 6026:  "	while ( 0 )",
        -: 6027:  "",
        -: 6028:  "#define unput(c) yyunput( c, yytext_ptr )",
        -: 6029:  "",
        -: 6030:  "/* The following is because we cannot portably get our hands on size_t",
        -: 6031:  " * (without autoconf's help, which isn't available because we want",
        -: 6032:  " * flex-generated scanners to compile on their own).",
        -: 6033:  " */",
        -: 6034:  "typedef unsigned int yy_size_t;",
        -: 6035:  "",
        -: 6036:  "",
        -: 6037:  "struct yy_buffer_state",
        -: 6038:  "	{",
        -: 6039:  "%-",
        -: 6040:  "	FILE *yy_input_file;",
        -: 6041:  "%+",
        -: 6042:  "	istream* yy_input_file;",
        -: 6043:  "%*",
        -: 6044:  "",
        -: 6045:  "	char *yy_ch_buf;		/* input buffer */",
        -: 6046:  "	char *yy_buf_pos;		/* current position in input buffer */",
        -: 6047:  "",
        -: 6048:  "	/* Size of input buffer in bytes, not including room for EOB",
        -: 6049:  "	 * characters.",
        -: 6050:  "	 */",
        -: 6051:  "	yy_size_t yy_buf_size;",
        -: 6052:  "",
        -: 6053:  "	/* Number of characters read into yy_ch_buf, not including EOB",
        -: 6054:  "	 * characters.",
        -: 6055:  "	 */",
        -: 6056:  "	int yy_n_chars;",
        -: 6057:  "",
        -: 6058:  "	/* Whether we \"own\" the buffer - i.e., we know we created it,",
        -: 6059:  "	 * and can realloc() it to grow it, and should free() it to",
        -: 6060:  "	 * delete it.",
        -: 6061:  "	 */",
        -: 6062:  "	int yy_is_our_buffer;",
        -: 6063:  "",
        -: 6064:  "	/* Whether this is an \"interactive\" input source; if so, and",
        -: 6065:  "	 * if we're using stdio for input, then we want to use getc()",
        -: 6066:  "	 * instead of fread(), to make sure we stop fetching input after",
        -: 6067:  "	 * each newline.",
        -: 6068:  "	 */",
        -: 6069:  "	int yy_is_interactive;",
        -: 6070:  "",
        -: 6071:  "	/* Whether we're considered to be at the beginning of a line.",
        -: 6072:  "	 * If so, '^' rules will be active on the next match, otherwise",
        -: 6073:  "	 * not.",
        -: 6074:  "	 */",
        -: 6075:  "	int yy_at_bol;",
        -: 6076:  "",
        -: 6077:  "	/* Whether to try to fill the input buffer when we reach the",
        -: 6078:  "	 * end of it.",
        -: 6079:  "	 */",
        -: 6080:  "	int yy_fill_buffer;",
        -: 6081:  "",
        -: 6082:  "	int yy_buffer_status;",
        -: 6083:  "#define YY_BUFFER_NEW 0",
        -: 6084:  "#define YY_BUFFER_NORMAL 1",
        -: 6085:  "	/* When an EOF's been seen but there's still some text to process",
        -: 6086:  "	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we",
        -: 6087:  "	 * shouldn't try reading from the input source any more.  We might",
        -: 6088:  "	 * still have a bunch of tokens to match, though, because of",
        -: 6089:  "	 * possible backing-up.",
        -: 6090:  "	 *",
        -: 6091:  "	 * When we actually see the EOF, we change the status to \"new\"",
        -: 6092:  "	 * (via yyrestart()), so that the user can continue scanning by",
        -: 6093:  "	 * just pointing yyin at a new input file.",
        -: 6094:  "	 */",
        -: 6095:  "#define YY_BUFFER_EOF_PENDING 2",
        -: 6096:  "	};",
        -: 6097:  "",
        -: 6098:  "%- Standard (non-C++) definition",
        -: 6099:  "static YY_BUFFER_STATE yy_current_buffer = 0;",
        -: 6100:  "%*",
        -: 6101:  "",
        -: 6102:  "/* We provide macros for accessing buffer states in case in the",
        -: 6103:  " * future we want to put the buffer states in a more general",
        -: 6104:  " * \"scanner state\".",
        -: 6105:  " */",
        -: 6106:  "#define YY_CURRENT_BUFFER yy_current_buffer",
        -: 6107:  "",
        -: 6108:  "",
        -: 6109:  "%- Standard (non-C++) definition",
        -: 6110:  "/* yy_hold_char holds the character lost when yytext is formed. */",
        -: 6111:  "static char yy_hold_char;",
        -: 6112:  "",
        -: 6113:  "static int yy_n_chars;		/* number of characters read into yy_ch_buf */",
        -: 6114:  "",
        -: 6115:  "",
        -: 6116:  "int yyleng;",
        -: 6117:  "",
        -: 6118:  "/* Points to current character in buffer. */",
        -: 6119:  "static char *yy_c_buf_p = (char *) 0;",
        -: 6120:  "static int yy_init = 1;		/* whether we need to initialize */",
        -: 6121:  "static int yy_start = 0;	/* start state number */",
        -: 6122:  "",
        -: 6123:  "/* Flag which is used to allow yywrap()'s to do buffer switches",
        -: 6124:  " * instead of setting up a fresh yyin.  A bit of a hack ...",
        -: 6125:  " */",
        -: 6126:  "static int yy_did_buffer_switch_on_eof;",
        -: 6127:  "",
        -: 6128:  "void yyrestart YY_PROTO(( FILE *input_file ));",
        -: 6129:  "",
        -: 6130:  "void yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));",
        -: 6131:  "void yy_load_buffer_state YY_PROTO(( void ));",
        -: 6132:  "YY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *file, int size ));",
        -: 6133:  "void yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));",
        -: 6134:  "void yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));",
        -: 6135:  "void yy_flush_buffer YY_PROTO(( YY_BUFFER_STATE b ));",
        -: 6136:  "#define YY_FLUSH_BUFFER yy_flush_buffer( yy_current_buffer )",
        -: 6137:  "",
        -: 6138:  "YY_BUFFER_STATE yy_scan_buffer YY_PROTO(( char *base, yy_size_t size ));",
        -: 6139:  "YY_BUFFER_STATE yy_scan_string YY_PROTO(( yyconst char *yy_str ));",
        -: 6140:  "YY_BUFFER_STATE yy_scan_bytes YY_PROTO(( yyconst char *bytes, int len ));",
        -: 6141:  "%*",
        -: 6142:  "",
        -: 6143:  "static void *yy_flex_alloc YY_PROTO(( yy_size_t ));",
        -: 6144:  "static void *yy_flex_realloc YY_PROTO(( void *, yy_size_t ));",
        -: 6145:  "static void yy_flex_free YY_PROTO(( void * ));",
        -: 6146:  "",
        -: 6147:  "#define yy_new_buffer yy_create_buffer",
        -: 6148:  "",
        -: 6149:  "#define yy_set_interactive(is_interactive) \\",
        -: 6150:  "	{ \\",
        -: 6151:  "	if ( ! yy_current_buffer ) \\",
        -: 6152:  "		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \\",
        -: 6153:  "	yy_current_buffer->yy_is_interactive = is_interactive; \\",
        -: 6154:  "	}",
        -: 6155:  "",
        -: 6156:  "#define yy_set_bol(at_bol) \\",
        -: 6157:  "	{ \\",
        -: 6158:  "	if ( ! yy_current_buffer ) \\",
        -: 6159:  "		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \\",
        -: 6160:  "	yy_current_buffer->yy_at_bol = at_bol; \\",
        -: 6161:  "	}",
        -: 6162:  "",
        -: 6163:  "#define YY_AT_BOL() (yy_current_buffer->yy_at_bol)",
        -: 6164:  "",
        -: 6165:  "%% yytext/yyin/yyout/yy_state_type/yylineno etc. def's & init go here",
        -: 6166:  "",
        -: 6167:  "%- Standard (non-C++) definition",
        -: 6168:  "static yy_state_type yy_get_previous_state YY_PROTO(( void ));",
        -: 6169:  "static yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));",
        -: 6170:  "static int yy_get_next_buffer YY_PROTO(( void ));",
        -: 6171:  "static void yy_fatal_error YY_PROTO(( yyconst char msg[] ));",
        -: 6172:  "%*",
        -: 6173:  "",
        -: 6174:  "/* Done after the current pattern has been matched and before the",
        -: 6175:  " * corresponding action - sets up yytext.",
        -: 6176:  " */",
        -: 6177:  "#define YY_DO_BEFORE_ACTION \\",
        -: 6178:  "	yytext_ptr = yy_bp; \\",
        -: 6179:  "%% code to fiddle yytext and yyleng for yymore() goes here",
        -: 6180:  "	yy_hold_char = *yy_cp; \\",
        -: 6181:  "	*yy_cp = '\\0'; \\",
        -: 6182:  "%% code to copy yytext_ptr to yytext[] goes here, if %array",
        -: 6183:  "	yy_c_buf_p = yy_cp;",
        -: 6184:  "",
        -: 6185:  "%% data tables for the DFA and the user's section 1 definitions go here",
        -: 6186:  "",
        -: 6187:  "/* Macros after this point can all be overridden by user definitions in",
        -: 6188:  " * section 1.",
        -: 6189:  " */",
        -: 6190:  "",
        -: 6191:  "#ifndef YY_SKIP_YYWRAP",
        -: 6192:  "#ifdef __cplusplus",
        -: 6193:  "extern \"C\" int yywrap YY_PROTO(( void ));",
        -: 6194:  "#else",
        -: 6195:  "extern int yywrap YY_PROTO(( void ));",
        -: 6196:  "#endif",
        -: 6197:  "#endif",
        -: 6198:  "",
        -: 6199:  "%-",
        -: 6200:  "#ifndef YY_NO_UNPUT",
        -: 6201:  "static void yyunput YY_PROTO(( int c, char *buf_ptr ));",
        -: 6202:  "#endif",
        -: 6203:  "%*",
        -: 6204:  "",
        -: 6205:  "#ifndef yytext_ptr",
        -: 6206:  "static void yy_flex_strncpy YY_PROTO(( char *, yyconst char *, int ));",
        -: 6207:  "#endif",
        -: 6208:  "",
        -: 6209:  "#ifdef YY_NEED_STRLEN",
        -: 6210:  "static int yy_flex_strlen YY_PROTO(( yyconst char * ));",
        -: 6211:  "#endif",
        -: 6212:  "",
        -: 6213:  "#ifndef YY_NO_INPUT",
        -: 6214:  "%- Standard (non-C++) definition",
        -: 6215:  "#ifdef __cplusplus",
        -: 6216:  "static int yyinput YY_PROTO(( void ));",
        -: 6217:  "#else",
        -: 6218:  "static int input YY_PROTO(( void ));",
        -: 6219:  "#endif",
        -: 6220:  "%*",
        -: 6221:  "#endif",
        -: 6222:  "",
        -: 6223:  "#if YY_STACK_USED",
        -: 6224:  "static int yy_start_stack_ptr = 0;",
        -: 6225:  "static int yy_start_stack_depth = 0;",
        -: 6226:  "static int *yy_start_stack = 0;",
        -: 6227:  "#ifndef YY_NO_PUSH_STATE",
        -: 6228:  "static void yy_push_state YY_PROTO(( int new_state ));",
        -: 6229:  "#endif",
        -: 6230:  "#ifndef YY_NO_POP_STATE",
        -: 6231:  "static void yy_pop_state YY_PROTO(( void ));",
        -: 6232:  "#endif",
        -: 6233:  "#ifndef YY_NO_TOP_STATE",
        -: 6234:  "static int yy_top_state YY_PROTO(( void ));",
        -: 6235:  "#endif",
        -: 6236:  "",
        -: 6237:  "#else",
        -: 6238:  "#define YY_NO_PUSH_STATE 1",
        -: 6239:  "#define YY_NO_POP_STATE 1",
        -: 6240:  "#define YY_NO_TOP_STATE 1",
        -: 6241:  "#endif",
        -: 6242:  "",
        -: 6243:  "#ifdef YY_MALLOC_DECL",
        -: 6244:  "YY_MALLOC_DECL",
        -: 6245:  "#else",
        -: 6246:  "#if __STDC__",
        -: 6247:  "#ifndef __cplusplus",
        -: 6248:  "#include <stdlib.h>",
        -: 6249:  "#endif",
        -: 6250:  "#else",
        -: 6251:  "/* Just try to get by without declaring the routines.  This will fail",
        -: 6252:  " * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)",
        -: 6253:  " * or sizeof(void*) != sizeof(int).",
        -: 6254:  " */",
        -: 6255:  "#endif",
        -: 6256:  "#endif",
        -: 6257:  "",
        -: 6258:  "/* Amount of stuff to slurp up with each read. */",
        -: 6259:  "#ifndef YY_READ_BUF_SIZE",
        -: 6260:  "#define YY_READ_BUF_SIZE 8192",
        -: 6261:  "#endif",
        -: 6262:  "",
        -: 6263:  "/* Copy whatever the last rule matched to the standard output. */",
        -: 6264:  "",
        -: 6265:  "#ifndef ECHO",
        -: 6266:  "%- Standard (non-C++) definition",
        -: 6267:  "/* This used to be an fputs(), but since the string might contain NUL's,",
        -: 6268:  " * we now use fwrite().",
        -: 6269:  " */",
        -: 6270:  "#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )",
        -: 6271:  "%+ C++ definition",
        -: 6272:  "#define ECHO LexerOutput( yytext, yyleng )",
        -: 6273:  "%*",
        -: 6274:  "#endif",
        -: 6275:  "",
        -: 6276:  "/* Gets input and stuffs it into \"buf\".  number of characters read, or YY_NULL,",
        -: 6277:  " * is returned in \"result\".",
        -: 6278:  " */",
        -: 6279:  "#ifndef YY_INPUT",
        -: 6280:  "#define YY_INPUT(buf,result,max_size) \\",
        -: 6281:  "%% fread()/read() definition of YY_INPUT goes here unless we're doing C++",
        -: 6282:  "%+ C++ definition",
        -: 6283:  "	if ( (result = LexerInput( (char *) buf, max_size )) < 0 ) \\",
        -: 6284:  "		YY_FATAL_ERROR( \"input in flex scanner failed\" );",
        -: 6285:  "%*",
        -: 6286:  "#endif",
        -: 6287:  "",
        -: 6288:  "/* No semi-colon after return; correct usage is to write \"yyterminate();\" -",
        -: 6289:  " * we don't want an extra ';' after the \"return\" because that will cause",
        -: 6290:  " * some compilers to complain about unreachable statements.",
        -: 6291:  " */",
        -: 6292:  "#ifndef yyterminate",
        -: 6293:  "#define yyterminate() return YY_NULL",
        -: 6294:  "#endif",
        -: 6295:  "",
        -: 6296:  "/* Number of entries by which start-condition stack grows. */",
        -: 6297:  "#ifndef YY_START_STACK_INCR",
        -: 6298:  "#define YY_START_STACK_INCR 25",
        -: 6299:  "#endif",
        -: 6300:  "",
        -: 6301:  "/* Report a fatal error. */",
        -: 6302:  "#ifndef YY_FATAL_ERROR",
        -: 6303:  "%-",
        -: 6304:  "#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )",
        -: 6305:  "%+",
        -: 6306:  "#define YY_FATAL_ERROR(msg) LexerError( msg )",
        -: 6307:  "%*",
        -: 6308:  "#endif",
        -: 6309:  "",
        -: 6310:  "/* Default declaration of generated scanner - a define so the user can",
        -: 6311:  " * easily add parameters.",
        -: 6312:  " */",
        -: 6313:  "#ifndef YY_DECL",
        -: 6314:  "%- Standard (non-C++) definition",
        -: 6315:  "#define YY_DECL int yylex YY_PROTO(( void ))",
        -: 6316:  "%+ C++ definition",
        -: 6317:  "#define YY_DECL int yyFlexLexer::yylex()",
        -: 6318:  "%*",
        -: 6319:  "#endif",
        -: 6320:  "",
        -: 6321:  "/* Code executed at the beginning of each rule, after yytext and yyleng",
        -: 6322:  " * have been set up.",
        -: 6323:  " */",
        -: 6324:  "#ifndef YY_USER_ACTION",
        -: 6325:  "#define YY_USER_ACTION",
        -: 6326:  "#endif",
        -: 6327:  "",
        -: 6328:  "/* Code executed at the end of each rule. */",
        -: 6329:  "#ifndef YY_BREAK",
        -: 6330:  "#define YY_BREAK break;",
        -: 6331:  "#endif",
        -: 6332:  "",
        -: 6333:  "%% YY_RULE_SETUP definition goes here",
        -: 6334:  "",
        -: 6335:  "YY_DECL",
        -: 6336:  "	{",
        -: 6337:  "	register yy_state_type yy_current_state;",
        -: 6338:  "	register char *yy_cp, *yy_bp;",
        -: 6339:  "	register int yy_act;",
        -: 6340:  "",
        -: 6341:  "%% user's declarations go here",
        -: 6342:  "",
        -: 6343:  "	if ( yy_init )",
        -: 6344:  "		{",
        -: 6345:  "		yy_init = 0;",
        -: 6346:  "",
        -: 6347:  "#ifdef YY_USER_INIT",
        -: 6348:  "		YY_USER_INIT;",
        -: 6349:  "#endif",
        -: 6350:  "",
        -: 6351:  "		if ( ! yy_start )",
        -: 6352:  "			yy_start = 1;	/* first start state */",
        -: 6353:  "",
        -: 6354:  "		if ( ! yyin )",
        -: 6355:  "%-",
        -: 6356:  "			yyin = stdin;",
        -: 6357:  "%+",
        -: 6358:  "			yyin = &cin;",
        -: 6359:  "%*",
        -: 6360:  "",
        -: 6361:  "		if ( ! yyout )",
        -: 6362:  "%-",
        -: 6363:  "			yyout = stdout;",
        -: 6364:  "%+",
        -: 6365:  "			yyout = &cout;",
        -: 6366:  "%*",
        -: 6367:  "",
        -: 6368:  "		if ( ! yy_current_buffer )",
        -: 6369:  "			yy_current_buffer =",
        -: 6370:  "				yy_create_buffer( yyin, YY_BUF_SIZE );",
        -: 6371:  "",
        -: 6372:  "		yy_load_buffer_state();",
        -: 6373:  "		}",
        -: 6374:  "",
        -: 6375:  "	while ( 1 )		/* loops until end-of-file is reached */",
        -: 6376:  "		{",
        -: 6377:  "%% yymore()-related code goes here",
        -: 6378:  "		yy_cp = yy_c_buf_p;",
        -: 6379:  "",
        -: 6380:  "		/* Support of yytext. */",
        -: 6381:  "		*yy_cp = yy_hold_char;",
        -: 6382:  "",
        -: 6383:  "		/* yy_bp points to the position in yy_ch_buf of the start of",
        -: 6384:  "		 * the current run.",
        -: 6385:  "		 */",
        -: 6386:  "		yy_bp = yy_cp;",
        -: 6387:  "",
        -: 6388:  "%% code to set up and find next match goes here",
        -: 6389:  "",
        -: 6390:  "yy_find_action:",
        -: 6391:  "%% code to find the action number goes here",
        -: 6392:  "",
        -: 6393:  "		YY_DO_BEFORE_ACTION;",
        -: 6394:  "",
        -: 6395:  "%% code for yylineno update goes here",
        -: 6396:  "",
        -: 6397:  "do_action:	/* This label is used only to access EOF actions. */",
        -: 6398:  "",
        -: 6399:  "%% debug code goes here",
        -: 6400:  "",
        -: 6401:  "		switch ( yy_act )",
        -: 6402:  "	{ /* beginning of action switch */",
        -: 6403:  "%% actions go here",
        -: 6404:  "",
        -: 6405:  "	case YY_END_OF_BUFFER:",
        -: 6406:  "		{",
        -: 6407:  "		/* Amount of text matched not including the EOB char. */",
        -: 6408:  "		int yy_amount_of_matched_text = (int) (yy_cp - yytext_ptr) - 1;",
        -: 6409:  "",
        -: 6410:  "		/* Undo the effects of YY_DO_BEFORE_ACTION. */",
        -: 6411:  "		*yy_cp = yy_hold_char;",
        -: 6412:  "		YY_RESTORE_YY_MORE_OFFSET",
        -: 6413:  "",
        -: 6414:  "		if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )",
        -: 6415:  "			{",
        -: 6416:  "			/* We're scanning a new file or input source.  It's",
        -: 6417:  "			 * possible that this happened because the user",
        -: 6418:  "			 * just pointed yyin at a new source and called",
        -: 6419:  "			 * yylex().  If so, then we have to assure",
        -: 6420:  "			 * consistency between yy_current_buffer and our",
        -: 6421:  "			 * globals.  Here is the right place to do so, because",
        -: 6422:  "			 * this is the first action (other than possibly a",
        -: 6423:  "			 * back-up) that will match for the new input source.",
        -: 6424:  "			 */",
        -: 6425:  "			yy_n_chars = yy_current_buffer->yy_n_chars;",
        -: 6426:  "			yy_current_buffer->yy_input_file = yyin;",
        -: 6427:  "			yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;",
        -: 6428:  "			}",
        -: 6429:  "",
        -: 6430:  "		/* Note that here we test for yy_c_buf_p \"<=\" to the position",
        -: 6431:  "		 * of the first EOB in the buffer, since yy_c_buf_p will",
        -: 6432:  "		 * already have been incremented past the NUL character",
        -: 6433:  "		 * (since all states make transitions on EOB to the",
        -: 6434:  "		 * end-of-buffer state).  Contrast this with the test",
        -: 6435:  "		 * in input().",
        -: 6436:  "		 */",
        -: 6437:  "		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )",
        -: 6438:  "			{ /* This was really a NUL. */",
        -: 6439:  "			yy_state_type yy_next_state;",
        -: 6440:  "",
        -: 6441:  "			yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;",
        -: 6442:  "",
        -: 6443:  "			yy_current_state = yy_get_previous_state();",
        -: 6444:  "",
        -: 6445:  "			/* Okay, we're now positioned to make the NUL",
        -: 6446:  "			 * transition.  We couldn't have",
        -: 6447:  "			 * yy_get_previous_state() go ahead and do it",
        -: 6448:  "			 * for us because it doesn't know how to deal",
        -: 6449:  "			 * with the possibility of jamming (and we don't",
        -: 6450:  "			 * want to build jamming into it because then it",
        -: 6451:  "			 * will run more slowly).",
        -: 6452:  "			 */",
        -: 6453:  "",
        -: 6454:  "			yy_next_state = yy_try_NUL_trans( yy_current_state );",
        -: 6455:  "",
        -: 6456:  "			yy_bp = yytext_ptr + YY_MORE_ADJ;",
        -: 6457:  "",
        -: 6458:  "			if ( yy_next_state )",
        -: 6459:  "				{",
        -: 6460:  "				/* Consume the NUL. */",
        -: 6461:  "				yy_cp = ++yy_c_buf_p;",
        -: 6462:  "				yy_current_state = yy_next_state;",
        -: 6463:  "				goto yy_match;",
        -: 6464:  "				}",
        -: 6465:  "",
        -: 6466:  "			else",
        -: 6467:  "				{",
        -: 6468:  "%% code to do back-up for compressed tables and set up yy_cp goes here",
        -: 6469:  "				goto yy_find_action;",
        -: 6470:  "				}",
        -: 6471:  "			}",
        -: 6472:  "",
        -: 6473:  "		else switch ( yy_get_next_buffer() )",
        -: 6474:  "			{",
        -: 6475:  "			case EOB_ACT_END_OF_FILE:",
        -: 6476:  "				{",
        -: 6477:  "				yy_did_buffer_switch_on_eof = 0;",
        -: 6478:  "",
        -: 6479:  "				if ( yywrap() )",
        -: 6480:  "					{",
        -: 6481:  "					/* Note: because we've taken care in",
        -: 6482:  "					 * yy_get_next_buffer() to have set up",
        -: 6483:  "					 * yytext, we can now set up",
        -: 6484:  "					 * yy_c_buf_p so that if some total",
        -: 6485:  "					 * hoser (like flex itself) wants to",
        -: 6486:  "					 * call the scanner after we return the",
        -: 6487:  "					 * YY_NULL, it'll still work - another",
        -: 6488:  "					 * YY_NULL will get returned.",
        -: 6489:  "					 */",
        -: 6490:  "					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;",
        -: 6491:  "",
        -: 6492:  "					yy_act = YY_STATE_EOF(YY_START);",
        -: 6493:  "					goto do_action;",
        -: 6494:  "					}",
        -: 6495:  "",
        -: 6496:  "				else",
        -: 6497:  "					{",
        -: 6498:  "					if ( ! yy_did_buffer_switch_on_eof )",
        -: 6499:  "						YY_NEW_FILE;",
        -: 6500:  "					}",
        -: 6501:  "				break;",
        -: 6502:  "				}",
        -: 6503:  "",
        -: 6504:  "			case EOB_ACT_CONTINUE_SCAN:",
        -: 6505:  "				yy_c_buf_p =",
        -: 6506:  "					yytext_ptr + yy_amount_of_matched_text;",
        -: 6507:  "",
        -: 6508:  "				yy_current_state = yy_get_previous_state();",
        -: 6509:  "",
        -: 6510:  "				yy_cp = yy_c_buf_p;",
        -: 6511:  "				yy_bp = yytext_ptr + YY_MORE_ADJ;",
        -: 6512:  "				goto yy_match;",
        -: 6513:  "",
        -: 6514:  "			case EOB_ACT_LAST_MATCH:",
        -: 6515:  "				yy_c_buf_p =",
        -: 6516:  "				&yy_current_buffer->yy_ch_buf[yy_n_chars];",
        -: 6517:  "",
        -: 6518:  "				yy_current_state = yy_get_previous_state();",
        -: 6519:  "",
        -: 6520:  "				yy_cp = yy_c_buf_p;",
        -: 6521:  "				yy_bp = yytext_ptr + YY_MORE_ADJ;",
        -: 6522:  "				goto yy_find_action;",
        -: 6523:  "			}",
        -: 6524:  "		break;",
        -: 6525:  "		}",
        -: 6526:  "",
        -: 6527:  "	default:",
        -: 6528:  "		YY_FATAL_ERROR(",
        -: 6529:  "			\"fatal flex scanner internal error--no action found\" );",
        -: 6530:  "	} /* end of action switch */",
        -: 6531:  "		} /* end of scanning one token */",
        -: 6532:  "	} /* end of yylex */",
        -: 6533:  "",
        -: 6534:  "%+",
        -: 6535:  "yyFlexLexer::yyFlexLexer( istream* arg_yyin, ostream* arg_yyout )",
        -: 6536:  "	{",
        -: 6537:  "	yyin = arg_yyin;",
        -: 6538:  "	yyout = arg_yyout;",
        -: 6539:  "	yy_c_buf_p = 0;",
        -: 6540:  "	yy_init = 1;",
        -: 6541:  "	yy_start = 0;",
        -: 6542:  "	yy_flex_debug = 0;",
        -: 6543:  "	yylineno = 1;	// this will only get updated if %option yylineno",
        -: 6544:  "",
        -: 6545:  "	yy_did_buffer_switch_on_eof = 0;",
        -: 6546:  "",
        -: 6547:  "	yy_looking_for_trail_begin = 0;",
        -: 6548:  "	yy_more_flag = 0;",
        -: 6549:  "	yy_more_len = 0;",
        -: 6550:  "	yy_more_offset = yy_prev_more_offset = 0;",
        -: 6551:  "",
        -: 6552:  "	yy_start_stack_ptr = yy_start_stack_depth = 0;",
        -: 6553:  "	yy_start_stack = 0;",
        -: 6554:  "",
        -: 6555:  "	yy_current_buffer = 0;",
        -: 6556:  "",
        -: 6557:  "#ifdef YY_USES_REJECT",
        -: 6558:  "	yy_state_buf = new yy_state_type[YY_BUF_SIZE + 2];",
        -: 6559:  "#else",
        -: 6560:  "	yy_state_buf = 0;",
        -: 6561:  "#endif",
        -: 6562:  "	}",
        -: 6563:  "",
        -: 6564:  "yyFlexLexer::~yyFlexLexer()",
        -: 6565:  "	{",
        -: 6566:  "	delete yy_state_buf;",
        -: 6567:  "	yy_delete_buffer( yy_current_buffer );",
        -: 6568:  "	}",
        -: 6569:  "",
        -: 6570:  "void yyFlexLexer::switch_streams( istream* new_in, ostream* new_out )",
        -: 6571:  "	{",
        -: 6572:  "	if ( new_in )",
        -: 6573:  "		{",
        -: 6574:  "		yy_delete_buffer( yy_current_buffer );",
        -: 6575:  "		yy_switch_to_buffer( yy_create_buffer( new_in, YY_BUF_SIZE ) );",
        -: 6576:  "		}",
        -: 6577:  "",
        -: 6578:  "	if ( new_out )",
        -: 6579:  "		yyout = new_out;",
        -: 6580:  "	}",
        -: 6581:  "",
        -: 6582:  "#ifdef YY_INTERACTIVE",
        -: 6583:  "int yyFlexLexer::LexerInput( char* buf, int /* max_size */ )",
        -: 6584:  "#else",
        -: 6585:  "int yyFlexLexer::LexerInput( char* buf, int max_size )",
        -: 6586:  "#endif",
        -: 6587:  "	{",
        -: 6588:  "	if ( yyin->eof() || yyin->fail() )",
        -: 6589:  "		return 0;",
        -: 6590:  "",
        -: 6591:  "#ifdef YY_INTERACTIVE",
        -: 6592:  "	yyin->get( buf[0] );",
        -: 6593:  "",
        -: 6594:  "	if ( yyin->eof() )",
        -: 6595:  "		return 0;",
        -: 6596:  "",
        -: 6597:  "	if ( yyin->bad() )",
        -: 6598:  "		return -1;",
        -: 6599:  "",
        -: 6600:  "	return 1;",
        -: 6601:  "",
        -: 6602:  "#else",
        -: 6603:  "	(void) yyin->read( buf, max_size );",
        -: 6604:  "",
        -: 6605:  "	if ( yyin->bad() )",
        -: 6606:  "		return -1;",
        -: 6607:  "	else",
        -: 6608:  "		return yyin->gcount();",
        -: 6609:  "#endif",
        -: 6610:  "	}",
        -: 6611:  "",
        -: 6612:  "void yyFlexLexer::LexerOutput( const char* buf, int size )",
        -: 6613:  "	{",
        -: 6614:  "	(void) yyout->write( buf, size );",
        -: 6615:  "	}",
        -: 6616:  "%*",
        -: 6617:  "",
        -: 6618:  "/* yy_get_next_buffer - try to read in a new buffer",
        -: 6619:  " *",
        -: 6620:  " * Returns a code representing an action:",
        -: 6621:  " *	EOB_ACT_LAST_MATCH -",
        -: 6622:  " *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position",
        -: 6623:  " *	EOB_ACT_END_OF_FILE - end of file",
        -: 6624:  " */",
        -: 6625:  "",
        -: 6626:  "%-",
        -: 6627:  "static int yy_get_next_buffer()",
        -: 6628:  "%+",
        -: 6629:  "int yyFlexLexer::yy_get_next_buffer()",
        -: 6630:  "%*",
        -: 6631:  "	{",
        -: 6632:  "	register char *dest = yy_current_buffer->yy_ch_buf;",
        -: 6633:  "	register char *source = yytext_ptr;",
        -: 6634:  "	register int number_to_move, i;",
        -: 6635:  "	int ret_val;",
        -: 6636:  "",
        -: 6637:  "	if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )",
        -: 6638:  "		YY_FATAL_ERROR(",
        -: 6639:  "		\"fatal flex scanner internal error--end of buffer missed\" );",
        -: 6640:  "",
        -: 6641:  "	if ( yy_current_buffer->yy_fill_buffer == 0 )",
        -: 6642:  "		{ /* Don't try to fill the buffer, so this is an EOF. */",
        -: 6643:  "		if ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )",
        -: 6644:  "			{",
        -: 6645:  "			/* We matched a single character, the EOB, so",
        -: 6646:  "			 * treat this as a final EOF.",
        -: 6647:  "			 */",
        -: 6648:  "			return EOB_ACT_END_OF_FILE;",
        -: 6649:  "			}",
        -: 6650:  "",
        -: 6651:  "		else",
        -: 6652:  "			{",
        -: 6653:  "			/* We matched some text prior to the EOB, first",
        -: 6654:  "			 * process it.",
        -: 6655:  "			 */",
        -: 6656:  "			return EOB_ACT_LAST_MATCH;",
        -: 6657:  "			}",
        -: 6658:  "		}",
        -: 6659:  "",
        -: 6660:  "	/* Try to read more data. */",
        -: 6661:  "",
        -: 6662:  "	/* First move last chars to start of buffer. */",
        -: 6663:  "	number_to_move = (int) (yy_c_buf_p - yytext_ptr) - 1;",
        -: 6664:  "",
        -: 6665:  "	for ( i = 0; i < number_to_move; ++i )",
        -: 6666:  "		*(dest++) = *(source++);",
        -: 6667:  "",
        -: 6668:  "	if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )",
        -: 6669:  "		/* don't do the read, it's not guaranteed to return an EOF,",
        -: 6670:  "		 * just force an EOF",
        -: 6671:  "		 */",
        -: 6672:  "		yy_current_buffer->yy_n_chars = yy_n_chars = 0;",
        -: 6673:  "",
        -: 6674:  "	else",
        -: 6675:  "		{",
        -: 6676:  "		int num_to_read =",
        -: 6677:  "			yy_current_buffer->yy_buf_size - number_to_move - 1;",
        -: 6678:  "",
        -: 6679:  "		while ( num_to_read <= 0 )",
        -: 6680:  "			{ /* Not enough room in the buffer - grow it. */",
        -: 6681:  "#ifdef YY_USES_REJECT",
        -: 6682:  "			YY_FATAL_ERROR(",
        -: 6683:  "\"input buffer overflow, can't enlarge buffer because scanner uses REJECT\" );",
        -: 6684:  "#else",
        -: 6685:  "",
        -: 6686:  "			/* just a shorter name for the current buffer */",
        -: 6687:  "			YY_BUFFER_STATE b = yy_current_buffer;",
        -: 6688:  "",
        -: 6689:  "			int yy_c_buf_p_offset =",
        -: 6690:  "				(int) (yy_c_buf_p - b->yy_ch_buf);",
        -: 6691:  "",
        -: 6692:  "			if ( b->yy_is_our_buffer )",
        -: 6693:  "				{",
        -: 6694:  "				int new_size = b->yy_buf_size * 2;",
        -: 6695:  "",
        -: 6696:  "				if ( new_size <= 0 )",
        -: 6697:  "					b->yy_buf_size += b->yy_buf_size / 8;",
        -: 6698:  "				else",
        -: 6699:  "					b->yy_buf_size *= 2;",
        -: 6700:  "",
        -: 6701:  "				b->yy_ch_buf = (char *)",
        -: 6702:  "					/* Include room in for 2 EOB chars. */",
        -: 6703:  "					yy_flex_realloc( (void *) b->yy_ch_buf,",
        -: 6704:  "							 b->yy_buf_size + 2 );",
        -: 6705:  "				}",
        -: 6706:  "			else",
        -: 6707:  "				/* Can't grow it, we don't own it. */",
        -: 6708:  "				b->yy_ch_buf = 0;",
        -: 6709:  "",
        -: 6710:  "			if ( ! b->yy_ch_buf )",
        -: 6711:  "				YY_FATAL_ERROR(",
        -: 6712:  "				\"fatal error - scanner input buffer overflow\" );",
        -: 6713:  "",
        -: 6714:  "			yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];",
        -: 6715:  "",
        -: 6716:  "			num_to_read = yy_current_buffer->yy_buf_size -",
        -: 6717:  "						number_to_move - 1;",
        -: 6718:  "#endif",
        -: 6719:  "			}",
        -: 6720:  "",
        -: 6721:  "		if ( num_to_read > YY_READ_BUF_SIZE )",
        -: 6722:  "			num_to_read = YY_READ_BUF_SIZE;",
        -: 6723:  "",
        -: 6724:  "		/* Read in more data. */",
        -: 6725:  "		YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),",
        -: 6726:  "			yy_n_chars, num_to_read );",
        -: 6727:  "",
        -: 6728:  "		yy_current_buffer->yy_n_chars = yy_n_chars;",
        -: 6729:  "		}",
        -: 6730:  "",
        -: 6731:  "	if ( yy_n_chars == 0 )",
        -: 6732:  "		{",
        -: 6733:  "		if ( number_to_move == YY_MORE_ADJ )",
        -: 6734:  "			{",
        -: 6735:  "			ret_val = EOB_ACT_END_OF_FILE;",
        -: 6736:  "			yyrestart( yyin );",
        -: 6737:  "			}",
        -: 6738:  "",
        -: 6739:  "		else",
        -: 6740:  "			{",
        -: 6741:  "			ret_val = EOB_ACT_LAST_MATCH;",
        -: 6742:  "			yy_current_buffer->yy_buffer_status =",
        -: 6743:  "				YY_BUFFER_EOF_PENDING;",
        -: 6744:  "			}",
        -: 6745:  "		}",
        -: 6746:  "",
        -: 6747:  "	else",
        -: 6748:  "		ret_val = EOB_ACT_CONTINUE_SCAN;",
        -: 6749:  "",
        -: 6750:  "	yy_n_chars += number_to_move;",
        -: 6751:  "	yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;",
        -: 6752:  "	yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;",
        -: 6753:  "",
        -: 6754:  "	yytext_ptr = &yy_current_buffer->yy_ch_buf[0];",
        -: 6755:  "",
        -: 6756:  "	return ret_val;",
        -: 6757:  "	}",
        -: 6758:  "",
        -: 6759:  "",
        -: 6760:  "/* yy_get_previous_state - get the state just before the EOB char was reached */",
        -: 6761:  "",
        -: 6762:  "%-",
        -: 6763:  "static yy_state_type yy_get_previous_state()",
        -: 6764:  "%+",
        -: 6765:  "yy_state_type yyFlexLexer::yy_get_previous_state()",
        -: 6766:  "%*",
        -: 6767:  "	{",
        -: 6768:  "	register yy_state_type yy_current_state;",
        -: 6769:  "	register char *yy_cp;",
        -: 6770:  "",
        -: 6771:  "%% code to get the start state into yy_current_state goes here",
        -: 6772:  "",
        -: 6773:  "	for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )",
        -: 6774:  "		{",
        -: 6775:  "%% code to find the next state goes here",
        -: 6776:  "		}",
        -: 6777:  "",
        -: 6778:  "	return yy_current_state;",
        -: 6779:  "	}",
        -: 6780:  "",
        -: 6781:  "",
        -: 6782:  "/* yy_try_NUL_trans - try to make a transition on the NUL character",
        -: 6783:  " *",
        -: 6784:  " * synopsis",
        -: 6785:  " *	next_state = yy_try_NUL_trans( current_state );",
        -: 6786:  " */",
        -: 6787:  "",
        -: 6788:  "%-",
        -: 6789:  "#ifdef YY_USE_PROTOS",
        -: 6790:  "static yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )",
        -: 6791:  "#else",
        -: 6792:  "static yy_state_type yy_try_NUL_trans( yy_current_state )",
        -: 6793:  "yy_state_type yy_current_state;",
        -: 6794:  "#endif",
        -: 6795:  "%+",
        -: 6796:  "yy_state_type yyFlexLexer::yy_try_NUL_trans( yy_state_type yy_current_state )",
        -: 6797:  "%*",
        -: 6798:  "	{",
        -: 6799:  "	register int yy_is_jam;",
        -: 6800:  "%% code to find the next state, and perhaps do backing up, goes here",
        -: 6801:  "",
        -: 6802:  "	return yy_is_jam ? 0 : yy_current_state;",
        -: 6803:  "	}",
        -: 6804:  "",
        -: 6805:  "",
        -: 6806:  "%-",
        -: 6807:  "#ifndef YY_NO_UNPUT",
        -: 6808:  "#ifdef YY_USE_PROTOS",
        -: 6809:  "static void yyunput( int c, register char *yy_bp )",
        -: 6810:  "#else",
        -: 6811:  "static void yyunput( c, yy_bp )",
        -: 6812:  "int c;",
        -: 6813:  "register char *yy_bp;",
        -: 6814:  "#endif",
        -: 6815:  "%+",
        -: 6816:  "void yyFlexLexer::yyunput( int c, register char* yy_bp )",
        -: 6817:  "%*",
        -: 6818:  "	{",
        -: 6819:  "	register char *yy_cp = yy_c_buf_p;",
        -: 6820:  "",
        -: 6821:  "	/* undo effects of setting up yytext */",
        -: 6822:  "	*yy_cp = yy_hold_char;",
        -: 6823:  "",
        -: 6824:  "	if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )",
        -: 6825:  "		{ /* need to shift things up to make room */",
        -: 6826:  "		/* +2 for EOB chars. */",
        -: 6827:  "		register int number_to_move = yy_n_chars + 2;",
        -: 6828:  "		register char *dest = &yy_current_buffer->yy_ch_buf[",
        -: 6829:  "					yy_current_buffer->yy_buf_size + 2];",
        -: 6830:  "		register char *source =",
        -: 6831:  "				&yy_current_buffer->yy_ch_buf[number_to_move];",
        -: 6832:  "",
        -: 6833:  "		while ( source > yy_current_buffer->yy_ch_buf )",
        -: 6834:  "			*--dest = *--source;",
        -: 6835:  "",
        -: 6836:  "		yy_cp += (int) (dest - source);",
        -: 6837:  "		yy_bp += (int) (dest - source);",
        -: 6838:  "		yy_current_buffer->yy_n_chars =",
        -: 6839:#ifndef F_HD_5
        -: 6840:  "			yy_n_chars = yy_current_buffer->yy_buf_size;",
        -: 6841:#else
        -: 6842:
        -: 6843:#endif
        -: 6844:  "",
        -: 6845:  "		if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )",
        -: 6846:  "			YY_FATAL_ERROR( \"flex scanner push-back overflow\" );",
        -: 6847:  "		}",
        -: 6848:  "",
        -: 6849:  "	*--yy_cp = (char) c;",
        -: 6850:  "",
        -: 6851:  "%% update yylineno here",
        -: 6852:  "",
        -: 6853:  "	yytext_ptr = yy_bp;",
        -: 6854:  "	yy_hold_char = *yy_cp;",
        -: 6855:  "	yy_c_buf_p = yy_cp;",
        -: 6856:  "	}",
        -: 6857:  "%-",
        -: 6858:  "#endif	/* ifndef YY_NO_UNPUT */",
        -: 6859:  "%*",
        -: 6860:  "",
        -: 6861:  "",
        -: 6862:  "%-",
        -: 6863:  "#ifdef __cplusplus",
        -: 6864:  "static int yyinput()",
        -: 6865:  "#else",
        -: 6866:  "static int input()",
        -: 6867:  "#endif",
        -: 6868:  "%+",
        -: 6869:  "int yyFlexLexer::yyinput()",
        -: 6870:  "%*",
        -: 6871:  "	{",
        -: 6872:  "	int c;",
        -: 6873:  "",
        -: 6874:  "	*yy_c_buf_p = yy_hold_char;",
        -: 6875:  "",
        -: 6876:  "	if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )",
        -: 6877:  "		{",
        -: 6878:  "		/* yy_c_buf_p now points to the character we want to return.",
        -: 6879:  "		 * If this occurs *before* the EOB characters, then it's a",
        -: 6880:  "		 * valid NUL; if not, then we've hit the end of the buffer.",
        -: 6881:  "		 */",
        -: 6882:  "		if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )",
        -: 6883:  "			/* This was really a NUL. */",
        -: 6884:  "			*yy_c_buf_p = '\\0';",
        -: 6885:  "",
        -: 6886:  "		else",
        -: 6887:  "			{ /* need more input */",
        -: 6888:  "			int offset = yy_c_buf_p - yytext_ptr;",
        -: 6889:  "			++yy_c_buf_p;",
        -: 6890:  "",
        -: 6891:  "			switch ( yy_get_next_buffer() )",
        -: 6892:  "				{",
        -: 6893:  "				case EOB_ACT_LAST_MATCH:",
        -: 6894:  "					/* This happens because yy_g_n_b()",
        -: 6895:  "					 * sees that we've accumulated a",
        -: 6896:  "					 * token and flags that we need to",
        -: 6897:  "					 * try matching the token before",
        -: 6898:  "					 * proceeding.  But for input(),",
        -: 6899:  "					 * there's no matching to consider.",
        -: 6900:  "					 * So convert the EOB_ACT_LAST_MATCH",
        -: 6901:  "					 * to EOB_ACT_END_OF_FILE.",
        -: 6902:  "					 */",
        -: 6903:  "",
        -: 6904:  "					/* Reset buffer status. */",
        -: 6905:  "					yyrestart( yyin );",
        -: 6906:  "",
        -: 6907:  "					/* fall through */",
        -: 6908:  "",
        -: 6909:  "				case EOB_ACT_END_OF_FILE:",
        -: 6910:  "					{",
        -: 6911:  "					if ( yywrap() )",
        -: 6912:  "						return EOF;",
        -: 6913:  "",
        -: 6914:  "					if ( ! yy_did_buffer_switch_on_eof )",
        -: 6915:  "						YY_NEW_FILE;",
        -: 6916:  "#ifdef __cplusplus",
        -: 6917:  "					return yyinput();",
        -: 6918:  "#else",
        -: 6919:  "					return input();",
        -: 6920:  "#endif",
        -: 6921:  "					}",
        -: 6922:  "",
        -: 6923:  "				case EOB_ACT_CONTINUE_SCAN:",
        -: 6924:  "					yy_c_buf_p = yytext_ptr + offset;",
        -: 6925:  "					break;",
        -: 6926:#ifndef F_HD_6
        -: 6927:#else
        -: 6928:"                            case EOB_ACT_LAST_MATCH:",
        -: 6929:#endif
        -: 6930:  "				}",
        -: 6931:  "			}",
        -: 6932:  "		}",
        -: 6933:  "",
        -: 6934:  "	c = *(unsigned char *) yy_c_buf_p;	/* cast for 8-bit char's */",
        -: 6935:  "	*yy_c_buf_p = '\\0';	/* preserve yytext */",
        -: 6936:  "	yy_hold_char = *++yy_c_buf_p;",
        -: 6937:  "",
        -: 6938:  "%% update BOL and yylineno",
        -: 6939:  "",
        -: 6940:  "	return c;",
        -: 6941:  "	}",
        -: 6942:  "",
        -: 6943:  "",
        -: 6944:  "%-",
        -: 6945:  "#ifdef YY_USE_PROTOS",
        -: 6946:  "void yyrestart( FILE *input_file )",
        -: 6947:  "#else",
        -: 6948:  "void yyrestart( input_file )",
        -: 6949:  "FILE *input_file;",
        -: 6950:  "#endif",
        -: 6951:  "%+",
        -: 6952:  "void yyFlexLexer::yyrestart( istream* input_file )",
        -: 6953:  "%*",
        -: 6954:  "	{",
        -: 6955:  "	if ( ! yy_current_buffer )",
        -: 6956:  "		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );",
        -: 6957:  "",
        -: 6958:  "	yy_init_buffer( yy_current_buffer, input_file );",
        -: 6959:  "	yy_load_buffer_state();",
        -: 6960:  "	}",
        -: 6961:  "",
        -: 6962:  "",
        -: 6963:  "%-",
        -: 6964:  "#ifdef YY_USE_PROTOS",
        -: 6965:  "void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )",
        -: 6966:  "#else",
        -: 6967:  "void yy_switch_to_buffer( new_buffer )",
        -: 6968:  "YY_BUFFER_STATE new_buffer;",
        -: 6969:  "#endif",
        -: 6970:  "%+",
        -: 6971:  "void yyFlexLexer::yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )",
        -: 6972:  "%*",
        -: 6973:  "	{",
        -: 6974:  "	if ( yy_current_buffer == new_buffer )",
        -: 6975:  "		return;",
        -: 6976:  "",
        -: 6977:  "	if ( yy_current_buffer )",
        -: 6978:  "		{",
        -: 6979:  "		/* Flush out information for old buffer. */",
        -: 6980:  "		*yy_c_buf_p = yy_hold_char;",
        -: 6981:  "		yy_current_buffer->yy_buf_pos = yy_c_buf_p;",
        -: 6982:  "		yy_current_buffer->yy_n_chars = yy_n_chars;",
        -: 6983:  "		}",
        -: 6984:  "",
        -: 6985:  "	yy_current_buffer = new_buffer;",
        -: 6986:  "	yy_load_buffer_state();",
        -: 6987:  "",
        -: 6988:  "	/* We don't actually know whether we did this switch during",
        -: 6989:  "	 * EOF (yywrap()) processing, but the only time this flag",
        -: 6990:  "	 * is looked at is after yywrap() is called, so it's safe",
        -: 6991:  "	 * to go ahead and always set it.",
        -: 6992:  "	 */",
        -: 6993:  "	yy_did_buffer_switch_on_eof = 1;",
        -: 6994:  "	}",
        -: 6995:  "",
        -: 6996:  "",
        -: 6997:  "%-",
        -: 6998:  "#ifdef YY_USE_PROTOS",
        -: 6999:  "void yy_load_buffer_state( void )",
        -: 7000:  "#else",
        -: 7001:  "void yy_load_buffer_state()",
        -: 7002:  "#endif",
        -: 7003:  "%+",
        -: 7004:  "void yyFlexLexer::yy_load_buffer_state()",
        -: 7005:  "%*",
        -: 7006:  "	{",
        -: 7007:  "	yy_n_chars = yy_current_buffer->yy_n_chars;",
        -: 7008:  "	yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;",
        -: 7009:  "	yyin = yy_current_buffer->yy_input_file;",
        -: 7010:  "	yy_hold_char = *yy_c_buf_p;",
        -: 7011:  "	}",
        -: 7012:  "",
        -: 7013:  "",
        -: 7014:  "%-",
        -: 7015:  "#ifdef YY_USE_PROTOS",
        -: 7016:  "YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )",
        -: 7017:  "#else",
        -: 7018:  "YY_BUFFER_STATE yy_create_buffer( file, size )",
        -: 7019:  "FILE *file;",
        -: 7020:  "int size;",
        -: 7021:  "#endif",
        -: 7022:  "%+",
        -: 7023:  "YY_BUFFER_STATE yyFlexLexer::yy_create_buffer( istream* file, int size )",
        -: 7024:  "%*",
        -: 7025:  "	{",
        -: 7026:  "	YY_BUFFER_STATE b;",
        -: 7027:  "",
        -: 7028:  "	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );",
        -: 7029:  "	if ( ! b )",
        -: 7030:  "		YY_FATAL_ERROR( \"out of dynamic memory in yy_create_buffer()\" );",
        -: 7031:  "",
        -: 7032:  "	b->yy_buf_size = size;",
        -: 7033:  "",
        -: 7034:  "	/* yy_ch_buf has to be 2 characters longer than the size given because",
        -: 7035:  "	 * we need to put in 2 end-of-buffer characters.",
        -: 7036:  "	 */",
        -: 7037:  "	b->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );",
        -: 7038:  "	if ( ! b->yy_ch_buf )",
        -: 7039:  "		YY_FATAL_ERROR( \"out of dynamic memory in yy_create_buffer()\" );",
        -: 7040:  "",
        -: 7041:  "	b->yy_is_our_buffer = 1;",
        -: 7042:  "",
        -: 7043:  "	yy_init_buffer( b, file );",
        -: 7044:  "",
        -: 7045:  "	return b;",
        -: 7046:  "	}",
        -: 7047:  "",
        -: 7048:  "",
        -: 7049:  "%-",
        -: 7050:  "#ifdef YY_USE_PROTOS",
        -: 7051:  "void yy_delete_buffer( YY_BUFFER_STATE b )",
        -: 7052:  "#else",
        -: 7053:  "void yy_delete_buffer( b )",
        -: 7054:  "YY_BUFFER_STATE b;",
        -: 7055:  "#endif",
        -: 7056:  "%+",
        -: 7057:  "void yyFlexLexer::yy_delete_buffer( YY_BUFFER_STATE b )",
        -: 7058:  "%*",
        -: 7059:  "	{",
        -: 7060:  "	if ( ! b )",
        -: 7061:  "		return;",
        -: 7062:  "",
        -: 7063:  "	if ( b == yy_current_buffer )",
        -: 7064:  "		yy_current_buffer = (YY_BUFFER_STATE) 0;",
        -: 7065:  "",
        -: 7066:  "	if ( b->yy_is_our_buffer )",
        -: 7067:  "		yy_flex_free( (void *) b->yy_ch_buf );",
        -: 7068:  "",
        -: 7069:  "	yy_flex_free( (void *) b );",
        -: 7070:  "	}",
        -: 7071:  "",
        -: 7072:  "",
        -: 7073:  "%-",
        -: 7074:  "#ifndef YY_ALWAYS_INTERACTIVE",
        -: 7075:  "#ifndef YY_NEVER_INTERACTIVE",
        -: 7076:  "extern int isatty YY_PROTO(( int ));",
        -: 7077:  "#endif",
        -: 7078:  "#endif",
        -: 7079:  "",
        -: 7080:  "#ifdef YY_USE_PROTOS",
        -: 7081:  "void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )",
        -: 7082:  "#else",
        -: 7083:  "void yy_init_buffer( b, file )",
        -: 7084:  "YY_BUFFER_STATE b;",
        -: 7085:  "FILE *file;",
        -: 7086:  "#endif",
        -: 7087:  "",
        -: 7088:  "%+",
        -: 7089:  "extern \"C\" int isatty YY_PROTO(( int ));",
        -: 7090:  "void yyFlexLexer::yy_init_buffer( YY_BUFFER_STATE b, istream* file )",
        -: 7091:  "%*",
        -: 7092:  "",
        -: 7093:  "	{",
        -: 7094:  "	yy_flush_buffer( b );",
        -: 7095:  "",
        -: 7096:  "	b->yy_input_file = file;",
        -: 7097:  "	b->yy_fill_buffer = 1;",
        -: 7098:  "",
        -: 7099:  "%-",
        -: 7100:  "#if YY_ALWAYS_INTERACTIVE",
        -: 7101:  "	b->yy_is_interactive = 1;",
        -: 7102:  "#else",
        -: 7103:  "#if YY_NEVER_INTERACTIVE",
        -: 7104:  "	b->yy_is_interactive = 0;",
        -: 7105:  "#else",
        -: 7106:  "	b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;",
        -: 7107:  "#endif",
        -: 7108:  "#endif",
        -: 7109:  "%+",
        -: 7110:  "	b->yy_is_interactive = 0;",
        -: 7111:  "%*",
        -: 7112:  "	}",
        -: 7113:  "",
        -: 7114:  "",
        -: 7115:  "%-",
        -: 7116:  "#ifdef YY_USE_PROTOS",
        -: 7117:  "void yy_flush_buffer( YY_BUFFER_STATE b )",
        -: 7118:  "#else",
        -: 7119:  "void yy_flush_buffer( b )",
        -: 7120:  "YY_BUFFER_STATE b;",
        -: 7121:  "#endif",
        -: 7122:  "",
        -: 7123:  "%+",
        -: 7124:  "void yyFlexLexer::yy_flush_buffer( YY_BUFFER_STATE b )",
        -: 7125:  "%*",
        -: 7126:  "	{",
        -: 7127:  "	if ( ! b )",
        -: 7128:  "		return;",
        -: 7129:#ifndef F_HD_4
        -: 7130:  "",
        -: 7131:#else
        -: 7132:
        -: 7133:#endif
        -: 7134:  "	b->yy_n_chars = 0;",
        -: 7135:  "",
        -: 7136:  "	/* We always need two end-of-buffer characters.  The first causes",
        -: 7137:  "	 * a transition to the end-of-buffer state.  The second causes",
        -: 7138:  "	 * a jam in that state.",
        -: 7139:  "	 */",
        -: 7140:  "	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;",
        -: 7141:  "	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;",
        -: 7142:  "",
        -: 7143:  "	b->yy_buf_pos = &b->yy_ch_buf[0];",
        -: 7144:  "",
        -: 7145:  "	b->yy_at_bol = 1;",
        -: 7146:  "	b->yy_buffer_status = YY_BUFFER_NEW;",
        -: 7147:  "",
        -: 7148:  "	if ( b == yy_current_buffer )",
        -: 7149:  "		yy_load_buffer_state();",
        -: 7150:  "	}",
        -: 7151:  "%*",
        -: 7152:  "",
        -: 7153:  "",
        -: 7154:  "#ifndef YY_NO_SCAN_BUFFER",
        -: 7155:  "%-",
        -: 7156:  "#ifdef YY_USE_PROTOS",
        -: 7157:  "YY_BUFFER_STATE yy_scan_buffer( char *base, yy_size_t size )",
        -: 7158:  "#else",
        -: 7159:  "YY_BUFFER_STATE yy_scan_buffer( base, size )",
        -: 7160:  "char *base;",
        -: 7161:  "yy_size_t size;",
        -: 7162:  "#endif",
        -: 7163:  "	{",
        -: 7164:  "	YY_BUFFER_STATE b;",
        -: 7165:  "",
        -: 7166:  "	if ( size < 2 ||",
        -: 7167:  "	     base[size-2] != YY_END_OF_BUFFER_CHAR ||",
        -: 7168:  "	     base[size-1] != YY_END_OF_BUFFER_CHAR )",
        -: 7169:  "		/* They forgot to leave room for the EOB's. */",
        -: 7170:  "		return 0;",
        -: 7171:  "",
        -: 7172:  "	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );",
        -: 7173:  "	if ( ! b )",
        -: 7174:  "		YY_FATAL_ERROR( \"out of dynamic memory in yy_scan_buffer()\" );",
        -: 7175:  "",
        -: 7176:  "	b->yy_buf_size = size - 2;	/* \"- 2\" to take care of EOB's */",
        -: 7177:  "	b->yy_buf_pos = b->yy_ch_buf = base;",
        -: 7178:  "	b->yy_is_our_buffer = 0;",
        -: 7179:  "	b->yy_input_file = 0;",
        -: 7180:  "	b->yy_n_chars = b->yy_buf_size;",
        -: 7181:  "	b->yy_is_interactive = 0;",
        -: 7182:  "	b->yy_at_bol = 1;",
        -: 7183:  "	b->yy_fill_buffer = 0;",
        -: 7184:  "	b->yy_buffer_status = YY_BUFFER_NEW;",
        -: 7185:  "",
        -: 7186:  "	yy_switch_to_buffer( b );",
        -: 7187:  "",
        -: 7188:  "	return b;",
        -: 7189:  "	}",
        -: 7190:  "%*",
        -: 7191:  "#endif",
        -: 7192:  "",
        -: 7193:  "",
        -: 7194:  "#ifndef YY_NO_SCAN_STRING",
        -: 7195:  "%-",
        -: 7196:  "#ifdef YY_USE_PROTOS",
        -: 7197:  "YY_BUFFER_STATE yy_scan_string( yyconst char *yy_str )",
        -: 7198:  "#else",
        -: 7199:  "YY_BUFFER_STATE yy_scan_string( yy_str )",
        -: 7200:  "yyconst char *yy_str;",
        -: 7201:  "#endif",
        -: 7202:  "	{",
        -: 7203:  "	int len;",
        -: 7204:  "	for ( len = 0; yy_str[len]; ++len )",
        -: 7205:  "		;",
        -: 7206:  "",
        -: 7207:  "	return yy_scan_bytes( yy_str, len );",
        -: 7208:  "	}",
        -: 7209:  "%*",
        -: 7210:  "#endif",
        -: 7211:  "",
        -: 7212:  "",
        -: 7213:  "#ifndef YY_NO_SCAN_BYTES",
        -: 7214:  "%-",
        -: 7215:  "#ifdef YY_USE_PROTOS",
        -: 7216:  "YY_BUFFER_STATE yy_scan_bytes( yyconst char *bytes, int len )",
        -: 7217:  "#else",
        -: 7218:  "YY_BUFFER_STATE yy_scan_bytes( bytes, len )",
        -: 7219:  "yyconst char *bytes;",
        -: 7220:  "int len;",
        -: 7221:  "#endif",
        -: 7222:  "	{",
        -: 7223:  "	YY_BUFFER_STATE b;",
        -: 7224:  "	char *buf;",
        -: 7225:  "	yy_size_t n;",
        -: 7226:  "	int i;",
        -: 7227:  "",
        -: 7228:  "	/* Get memory for full buffer, including space for trailing EOB's. */",
        -: 7229:  "	n = len + 2;",
        -: 7230:  "	buf = (char *) yy_flex_alloc( n );",
        -: 7231:  "	if ( ! buf )",
        -: 7232:  "		YY_FATAL_ERROR( \"out of dynamic memory in yy_scan_bytes()\" );",
        -: 7233:  "",
        -: 7234:  "	for ( i = 0; i < len; ++i )",
        -: 7235:  "		buf[i] = bytes[i];",
        -: 7236:  "",
        -: 7237:  "	buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;",
        -: 7238:  "",
        -: 7239:  "	b = yy_scan_buffer( buf, n );",
        -: 7240:  "	if ( ! b )",
        -: 7241:  "		YY_FATAL_ERROR( \"bad buffer in yy_scan_bytes()\" );",
        -: 7242:  "",
        -: 7243:  "	/* It's okay to grow etc. this buffer, and we should throw it",
        -: 7244:  "	 * away when we're done.",
        -: 7245:  "	 */",
        -: 7246:  "	b->yy_is_our_buffer = 1;",
        -: 7247:  "",
        -: 7248:  "	return b;",
        -: 7249:  "	}",
        -: 7250:  "%*",
        -: 7251:  "#endif",
        -: 7252:  "",
        -: 7253:  "",
        -: 7254:  "#ifndef YY_NO_PUSH_STATE",
        -: 7255:  "%-",
        -: 7256:  "#ifdef YY_USE_PROTOS",
        -: 7257:  "static void yy_push_state( int new_state )",
        -: 7258:  "#else",
        -: 7259:  "static void yy_push_state( new_state )",
        -: 7260:  "int new_state;",
        -: 7261:  "#endif",
        -: 7262:  "%+",
        -: 7263:  "void yyFlexLexer::yy_push_state( int new_state )",
        -: 7264:  "%*",
        -: 7265:  "	{",
        -: 7266:  "	if ( yy_start_stack_ptr >= yy_start_stack_depth )",
        -: 7267:  "		{",
        -: 7268:  "		yy_size_t new_size;",
        -: 7269:  "",
        -: 7270:  "		yy_start_stack_depth += YY_START_STACK_INCR;",
        -: 7271:  "		new_size = yy_start_stack_depth * sizeof( int );",
        -: 7272:  "",
        -: 7273:  "		if ( ! yy_start_stack )",
        -: 7274:  "			yy_start_stack = (int *) yy_flex_alloc( new_size );",
        -: 7275:  "",
        -: 7276:  "		else",
        -: 7277:  "			yy_start_stack = (int *) yy_flex_realloc(",
        -: 7278:  "					(void *) yy_start_stack, new_size );",
        -: 7279:  "",
        -: 7280:  "		if ( ! yy_start_stack )",
        -: 7281:  "			YY_FATAL_ERROR(",
        -: 7282:  "			\"out of memory expanding start-condition stack\" );",
        -: 7283:  "		}",
        -: 7284:  "",
        -: 7285:  "	yy_start_stack[yy_start_stack_ptr++] = YY_START;",
        -: 7286:  "",
        -: 7287:  "	BEGIN(new_state);",
        -: 7288:  "	}",
        -: 7289:  "#endif",
        -: 7290:  "",
        -: 7291:  "",
        -: 7292:  "#ifndef YY_NO_POP_STATE",
        -: 7293:  "%-",
        -: 7294:  "static void yy_pop_state()",
        -: 7295:  "%+",
        -: 7296:  "void yyFlexLexer::yy_pop_state()",
        -: 7297:  "%*",
        -: 7298:  "	{",
        -: 7299:  "	if ( --yy_start_stack_ptr < 0 )",
        -: 7300:  "		YY_FATAL_ERROR( \"start-condition stack underflow\" );",
        -: 7301:  "",
        -: 7302:  "	BEGIN(yy_start_stack[yy_start_stack_ptr]);",
        -: 7303:  "	}",
        -: 7304:  "#endif",
        -: 7305:  "",
        -: 7306:  "",
        -: 7307:  "#ifndef YY_NO_TOP_STATE",
        -: 7308:  "%-",
        -: 7309:  "static int yy_top_state()",
        -: 7310:  "%+",
        -: 7311:  "int yyFlexLexer::yy_top_state()",
        -: 7312:  "%*",
        -: 7313:  "	{",
        -: 7314:  "	return yy_start_stack[yy_start_stack_ptr - 1];",
        -: 7315:  "	}",
        -: 7316:  "#endif",
        -: 7317:  "",
        -: 7318:  "#ifndef YY_EXIT_FAILURE",
        -: 7319:  "#define YY_EXIT_FAILURE 2",
        -: 7320:  "#endif",
        -: 7321:  "",
        -: 7322:  "%-",
        -: 7323:  "#ifdef YY_USE_PROTOS",
        -: 7324:  "static void yy_fatal_error( yyconst char msg[] )",
        -: 7325:  "#else",
        -: 7326:  "static void yy_fatal_error( msg )",
        -: 7327:  "char msg[];",
        -: 7328:  "#endif",
        -: 7329:  "	{",
        -: 7330:  "FILE *err;",  /* ### modified(Jan.24.2001) ### */
        -: 7331:  "	(void) fprintf( err, \"%s\\n\", msg );",
        -: 7332:  "	exit( YY_EXIT_FAILURE );",
        -: 7333:  "	}",
        -: 7334:  "",
        -: 7335:  "%+",
        -: 7336:  "",
        -: 7337:  "void yyFlexLexer::LexerError( yyconst char msg[] )",
        -: 7338:  "	{",
        -: 7339:  "	cerr << msg << '\\n';",
        -: 7340:  "	exit( YY_EXIT_FAILURE );",
        -: 7341:  "	}",
        -: 7342:  "%*",
        -: 7343:  "",
        -: 7344:  "",
        -: 7345:  "/* Redefine yyless() so it works in section 3 code. */",
        -: 7346:  "",
        -: 7347:  "#undef yyless",
        -: 7348:  "#define yyless(n) \\",
        -: 7349:  "	do \\",
        -: 7350:  "		{ \\",
        -: 7351:  "		/* Undo effects of setting up yytext. */ \\",
        -: 7352:  "		yytext[yyleng] = yy_hold_char; \\",
        -: 7353:  "		yy_c_buf_p = yytext + n; \\",
        -: 7354:  "		yy_hold_char = *yy_c_buf_p; \\",
        -: 7355:  "		*yy_c_buf_p = '\\0'; \\",
        -: 7356:  "		yyleng = n; \\",
        -: 7357:  "		} \\",
        -: 7358:  "	while ( 0 )",
        -: 7359:  "",
        -: 7360:  "",
        -: 7361:  "/* Internal utility routines. */",
        -: 7362:  "",
        -: 7363:  "#ifndef yytext_ptr",
        -: 7364:  "#ifdef YY_USE_PROTOS",
        -: 7365:  "static void yy_flex_strncpy( char *s1, yyconst char *s2, int n )",
        -: 7366:  "#else",
        -: 7367:  "static void yy_flex_strncpy( s1, s2, n )",
        -: 7368:  "char *s1;",
        -: 7369:  "yyconst char *s2;",
        -: 7370:  "int n;",
        -: 7371:  "#endif",
        -: 7372:  "	{",
        -: 7373:  "	register int i;",
        -: 7374:  "	for ( i = 0; i < n; ++i )",
        -: 7375:  "		s1[i] = s2[i];",
        -: 7376:  "	}",
        -: 7377:  "#endif",
        -: 7378:  "",
        -: 7379:  "#ifdef YY_NEED_STRLEN",
        -: 7380:  "#ifdef YY_USE_PROTOS",
        -: 7381:  "static int yy_flex_strlen( yyconst char *s )",
        -: 7382:  "#else",
        -: 7383:  "static int yy_flex_strlen( s )",
        -: 7384:  "yyconst char *s;",
        -: 7385:  "#endif",
        -: 7386:  "	{",
        -: 7387:  "	register int n;",
        -: 7388:  "	for ( n = 0; s[n]; ++n )",
        -: 7389:  "		;",
        -: 7390:  "",
        -: 7391:  "	return n;",
        -: 7392:  "	}",
        -: 7393:  "#endif",
        -: 7394:  "",
        -: 7395:  "",
        -: 7396:  "#ifdef YY_USE_PROTOS",
        -: 7397:  "static void *yy_flex_alloc( yy_size_t size )",
        -: 7398:  "#else",
        -: 7399:  "static void *yy_flex_alloc( size )",
        -: 7400:  "yy_size_t size;",
        -: 7401:  "#endif",
        -: 7402:  "	{",
        -: 7403:  "	return (void *) malloc( size );",
        -: 7404:  "	}",
        -: 7405:  "",
        -: 7406:  "#ifdef YY_USE_PROTOS",
        -: 7407:  "static void *yy_flex_realloc( void *ptr, yy_size_t size )",
        -: 7408:  "#else",
        -: 7409:  "static void *yy_flex_realloc( ptr, size )",
        -: 7410:  "void *ptr;",
        -: 7411:  "yy_size_t size;",
        -: 7412:  "#endif",
        -: 7413:  "	{",
        -: 7414:  "	/* The cast to (char *) in the following accommodates both",
        -: 7415:  "	 * implementations that use char* generic pointers, and those",
        -: 7416:  "	 * that use void* generic pointers.  It works with the latter",
        -: 7417:  "	 * because both ANSI C and C++ allow castless assignment from",
        -: 7418:  "	 * any pointer type to void*, and deal with argument conversions",
        -: 7419:  "	 * as though doing an assignment.",
        -: 7420:  "	 */",
        -: 7421:  "	return (void *) realloc( (char *) ptr, size );",
        -: 7422:  "	}",
        -: 7423:  "",
        -: 7424:  "#ifdef YY_USE_PROTOS",
        -: 7425:  "static void yy_flex_free( void *ptr )",
        -: 7426:  "#else",
        -: 7427:  "static void yy_flex_free( ptr )",
        -: 7428:  "void *ptr;",
        -: 7429:  "#endif",
        -: 7430:  "	{",
        -: 7431:  "	free( ptr );",
        -: 7432:  "	}",
        -: 7433:  "",
        -: 7434:  "#if YY_MAIN",
        -: 7435:  "int main()",
        -: 7436:  "	{",
        -: 7437:  "	yylex();",
        -: 7438:  "	return 0;",
        -: 7439:  "	}",
        -: 7440:  "#endif",
        -: 7441:  0
        -: 7442:};
        -: 7443:/* sym - symbol table routines */
        -: 7444:
        -: 7445:/*-
        -: 7446: * Copyright (c) 1990 The Regents of the University of California.
        -: 7447: * All rights reserved.
        -: 7448: *
        -: 7449: * This code is derived from software contributed to Berkeley by
        -: 7450: * Vern Paxson.
        -: 7451: * 
        -: 7452: * The United States Government has rights in this work pursuant
        -: 7453: * to contract no. DE-AC03-76SF00098 between the United States
        -: 7454: * Department of Energy and the University of California.
        -: 7455: *
        -: 7456: * Redistribution and use in source and binary forms with or without
        -: 7457: * modification are permitted provided that: (1) source distributions retain
        -: 7458: * this entire copyright notice and comment, and (2) distributions including
        -: 7459: * binaries display the following acknowledgement:  ``This product includes
        -: 7460: * software developed by the University of California, Berkeley and its
        -: 7461: * contributors'' in the documentation or other materials provided with the
        -: 7462: * distribution and in all advertising materials mentioning features or use
        -: 7463: * of this software.  Neither the name of the University nor the names of
        -: 7464: * its contributors may be used to endorse or promote products derived from
        -: 7465: * this software without specific prior written permission.
        -: 7466: * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
        -: 7467: * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
        -: 7468: * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
        -: 7469: */
        -: 7470:
        -: 7471:/* $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.seeded/v5/flex.c,v 1.1.1.2 2003/09/02 20:22:00 expsir Exp $ */
        -: 7472:
        -: 7473:
        -: 7474:
        -: 7475:/* declare functions that have forward references */
        -: 7476:
        -: 7477:int hashfunct PROTO((register char[], int));
        -: 7478:
        -: 7479:
        -: 7480:struct hash_entry *ndtbl[NAME_TABLE_HASH_SIZE];
        -: 7481:struct hash_entry *sctbl[START_COND_HASH_SIZE];
        -: 7482:struct hash_entry *ccltab[CCL_HASH_SIZE];
        -: 7483:
        -: 7484:struct hash_entry *findsym();
        -: 7485:
        -: 7486:
        -: 7487:/* addsym - add symbol and definitions to symbol table
        -: 7488: *
        -: 7489: * -1 is returned if the symbol already exists, and the change not made.
        -: 7490: */
        -: 7491:
function addsym called 2134 returned 100% blocks executed 93%
     2134: 7492:int addsym( sym, str_def, int_def, table, table_size )
        -: 7493:register char sym[];
        -: 7494:char *str_def;
        -: 7495:int int_def;
        -: 7496:hash_table table;
        -: 7497:int table_size;
        -: 7498:	{
     2134: 7499:	int hash_val = hashfunct( sym, table_size );
call    0 returned 2134
     2134: 7500:	register struct hash_entry *sym_entry = table[hash_val];
        -: 7501:	register struct hash_entry *new_entry;
        -: 7502:	register struct hash_entry *successor;
        -: 7503:
     2366: 7504:	while ( sym_entry )
branch  0 taken 233
branch  1 taken 2133 (fallthrough)
        -: 7505:		{
      233: 7506:		if ( ! strcmp( sym, sym_entry->name ) )
branch  0 taken 1 (fallthrough)
branch  1 taken 232
        -: 7507:			{ /* entry already exists */
        1: 7508:			return -1;
        -: 7509:			}
        -: 7510:
      232: 7511:		sym_entry = sym_entry->next;
        -: 7512:		}
        -: 7513:
        -: 7514:	/* create new entry */
        -: 7515:	new_entry = (struct hash_entry *)
     2133: 7516:		flex_alloc( sizeof( struct hash_entry ) );
call    0 returned 2133
        -: 7517:
     2133: 7518:	if ( new_entry == NULL )
branch  0 taken 0 (fallthrough)
branch  1 taken 2133
    #####: 7519:		flexfatal( _( "symbol table memory allocation failed" ) );
call    0 never executed
        -: 7520:
     2133: 7521:	if ( (successor = table[hash_val]) != 0 )
branch  0 taken 133 (fallthrough)
branch  1 taken 2000
        -: 7522:		{
      133: 7523:		new_entry->next = successor;
      133: 7524:		successor->prev = new_entry;
        -: 7525:		}
        -: 7526:	else
     2000: 7527:		new_entry->next = NULL;
        -: 7528:
     2133: 7529:	new_entry->prev = NULL;
     2133: 7530:	new_entry->name = sym;
     2133: 7531:	new_entry->str_val = str_def;
     2133: 7532:	new_entry->int_val = int_def;
        -: 7533:
     2133: 7534:	table[hash_val] = new_entry;
        -: 7535:
     2133: 7536:	return 0;
        -: 7537:	}
        -: 7538:
        -: 7539:
        -: 7540:/* cclinstal - save the text of a character class */
        -: 7541:
function cclinstal called 1298 returned 100% blocks executed 100%
     1298: 7542:void cclinstal( ccltxt, cclnum )
        -: 7543:Char ccltxt[];
        -: 7544:int cclnum;
        -: 7545:	{
        -: 7546:	/* We don't bother checking the return status because we are not
        -: 7547:	 * called unless the symbol is new.
        -: 7548:	 */
        -: 7549:	Char *copy_unsigned_string();
        -: 7550:
     1298: 7551:	(void) addsym( (char *) copy_unsigned_string( ccltxt ),
call    0 returned 1298
call    1 returned 1298
        -: 7552:			(char *) 0, cclnum,
        -: 7553:			ccltab, CCL_HASH_SIZE );
     1298: 7554:	}
        -: 7555:
        -: 7556:
        -: 7557:/* ccllookup - lookup the number associated with character class text
        -: 7558: *
        -: 7559: * Returns 0 if there's no CCL associated with the text.
        -: 7560: */
        -: 7561:
function ccllookup called 1531 returned 100% blocks executed 100%
     1531: 7562:int ccllookup( ccltxt )
        -: 7563:Char ccltxt[];
        -: 7564:	{
     1531: 7565:	return findsym( (char *) ccltxt, ccltab, CCL_HASH_SIZE )->int_val;
call    0 returned 1531
        -: 7566:	}
        -: 7567:
        -: 7568:
        -: 7569:/* findsym - find symbol in symbol table */
        -: 7570:
function findsym called 2007 returned 100% blocks executed 100%
     2007: 7571:struct hash_entry *findsym( sym, table, table_size )
        -: 7572:register char sym[];
        -: 7573:hash_table table;
        -: 7574:int table_size;
        -: 7575:	{
        -: 7576:	static struct hash_entry empty_entry =
        -: 7577:		{
        -: 7578:		(struct hash_entry *) 0, (struct hash_entry *) 0,
        -: 7579:		(char *) 0, (char *) 0, 0,
        -: 7580:		} ;
     2007: 7581:	register struct hash_entry *sym_entry =
     2007: 7582:		table[hashfunct( sym, table_size )];
call    0 returned 2007
        -: 7583:
     2239: 7584:	while ( sym_entry )
branch  0 taken 937
branch  1 taken 1302 (fallthrough)
        -: 7585:		{
      937: 7586:		if ( ! strcmp( sym, sym_entry->name ) )
branch  0 taken 705 (fallthrough)
branch  1 taken 232
      705: 7587:			return sym_entry;
      232: 7588:		sym_entry = sym_entry->next;
        -: 7589:		}
        -: 7590:
     1302: 7591:	return &empty_entry;
        -: 7592:	}
        -: 7593:
        -: 7594:
        -: 7595:/* hashfunct - compute the hash value for "str" and hash size "hash_size" */
        -: 7596:
function hashfunct called 4141 returned 100% blocks executed 100%
     4141: 7597:int hashfunct( str, hash_size )
        -: 7598:register char str[];
        -: 7599:int hash_size;
        -: 7600:	{
        -: 7601:	register int hashval;
        -: 7602:	register int locstr;
        -: 7603:
     4141: 7604:	hashval = 0;
     4141: 7605:	locstr = 0;
        -: 7606:
    26263: 7607:	while ( str[locstr] )
branch  0 taken 22122
branch  1 taken 4141 (fallthrough)
        -: 7608:		{
    22122: 7609:		hashval = (hashval << 1) + (unsigned char) str[locstr++];
    22122: 7610:		hashval %= hash_size;
        -: 7611:		}
        -: 7612:
     4141: 7613:	return hashval;
        -: 7614:	}
        -: 7615:
        -: 7616:
        -: 7617:/* ndinstal - install a name definition */
        -: 7618:
function ndinstal called 257 returned 100% blocks executed 100%
      257: 7619:void ndinstal( name, definition )
        -: 7620:char name[];
        -: 7621:Char definition[];
        -: 7622:	{
        -: 7623:	char *copy_string();
        -: 7624:	Char *copy_unsigned_string();
        -: 7625:
      257: 7626:	if ( addsym( copy_string( name ),
call    0 returned 257
call    1 returned 257
branch  2 taken 1 (fallthrough)
branch  3 taken 256
      257: 7627:			(char *) copy_unsigned_string( definition ), 0,
call    0 returned 257
        -: 7628:			ndtbl, NAME_TABLE_HASH_SIZE ) )
        1: 7629:		synerr( _( "name defined twice" ) );
call    0 returned 1
      257: 7630:	}
        -: 7631:
        -: 7632:
        -: 7633:/* ndlookup - lookup a name definition
        -: 7634: *
        -: 7635: * Returns a nil pointer if the name definition does not exist.
        -: 7636: */
        -: 7637:
function ndlookup called 459 returned 100% blocks executed 100%
      459: 7638:Char *ndlookup( nd )
        -: 7639:char nd[];
        -: 7640:	{
      459: 7641:	return (Char *) findsym( nd, ndtbl, NAME_TABLE_HASH_SIZE )->str_val;
call    0 returned 459
        -: 7642:	}
        -: 7643:
        -: 7644:
        -: 7645:/* scextend - increase the maximum number of start conditions */
        -: 7646:
function scextend called 0 returned 0% blocks executed 0%
    #####: 7647:void scextend()
        -: 7648:	{
    #####: 7649:	current_max_scs += MAX_SCS_INCREMENT;
        -: 7650:
    #####: 7651:	++num_reallocs;
        -: 7652:
    #####: 7653:	scset = reallocate_integer_array( scset, current_max_scs );
call    0 never executed
    #####: 7654:	scbol = reallocate_integer_array( scbol, current_max_scs );
call    0 never executed
    #####: 7655:	scxclu = reallocate_integer_array( scxclu, current_max_scs );
call    0 never executed
    #####: 7656:	sceof = reallocate_integer_array( sceof, current_max_scs );
call    0 never executed
    #####: 7657:	scname = reallocate_char_ptr_array( scname, current_max_scs );
call    0 never executed
    #####: 7658:	}
        -: 7659:
        -: 7660:
        -: 7661:/* scinstal - make a start condition
        -: 7662: *
        -: 7663: * NOTE
        -: 7664: *    The start condition is "exclusive" if xcluflg is true.
        -: 7665: */
        -: 7666:
function scinstal called 579 returned 100% blocks executed 80%
      579: 7667:void scinstal( str, xcluflg )
        -: 7668:char str[];
        -: 7669:int xcluflg;
        -: 7670:	{
        -: 7671:	char *copy_string();
        -: 7672:
        -: 7673:	/* Generate start condition definition, for use in BEGIN et al. */
      579: 7674:	action_define( str, lastsc );
call    0 returned 579
        -: 7675:
      579: 7676:	if ( ++lastsc >= current_max_scs )
branch  0 taken 0 (fallthrough)
branch  1 taken 579
    #####: 7677:		scextend();
call    0 never executed
        -: 7678:
      579: 7679:	scname[lastsc] = copy_string( str );
call    0 returned 579
        -: 7680:
      579: 7681:	if ( addsym( scname[lastsc], (char *) 0, lastsc,
call    0 returned 579
branch  1 taken 0 (fallthrough)
branch  2 taken 579
        -: 7682:			sctbl, START_COND_HASH_SIZE ) )
    #####: 7683:		format_pinpoint_message(
call    0 never executed
        -: 7684:				_( "start condition %s declared twice" ),
        -: 7685:					str );
        -: 7686:
      579: 7687:	scset[lastsc] = mkstate( SYM_EPSILON );
call    0 returned 579
      579: 7688:	scbol[lastsc] = mkstate( SYM_EPSILON );
call    0 returned 579
      579: 7689:	scxclu[lastsc] = xcluflg;
      579: 7690:	sceof[lastsc] = false;
      579: 7691:	}
        -: 7692:
        -: 7693:
        -: 7694:/* sclookup - lookup the number associated with a start condition
        -: 7695: *
        -: 7696: * Returns 0 if no such start condition.
        -: 7697: */
        -: 7698:
function sclookup called 17 returned 100% blocks executed 100%
       17: 7699:int sclookup( str )
        -: 7700:char str[];
        -: 7701:	{
       17: 7702:	return findsym( str, sctbl, START_COND_HASH_SIZE )->int_val;
call    0 returned 17
        -: 7703:	}
        -: 7704:/* tblcmp - table compression routines */
        -: 7705:
        -: 7706:/*-
        -: 7707: * Copyright (c) 1990 The Regents of the University of California.
        -: 7708: * All rights reserved.
        -: 7709: *
        -: 7710: * This code is derived from software contributed to Berkeley by
        -: 7711: * Vern Paxson.
        -: 7712: * 
        -: 7713: * The United States Government has rights in this work pursuant
        -: 7714: * to contract no. DE-AC03-76SF00098 between the United States
        -: 7715: * Department of Energy and the University of California.
        -: 7716: *
        -: 7717: * Redistribution and use in source and binary forms with or without
        -: 7718: * modification are permitted provided that: (1) source distributions retain
        -: 7719: * this entire copyright notice and comment, and (2) distributions including
        -: 7720: * binaries display the following acknowledgement:  ``This product includes
        -: 7721: * software developed by the University of California, Berkeley and its
        -: 7722: * contributors'' in the documentation or other materials provided with the
        -: 7723: * distribution and in all advertising materials mentioning features or use
        -: 7724: * of this software.  Neither the name of the University nor the names of
        -: 7725: * its contributors may be used to endorse or promote products derived from
        -: 7726: * this software without specific prior written permission.
        -: 7727: * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
        -: 7728: * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
        -: 7729: * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
        -: 7730: */
        -: 7731:
        -: 7732:/* $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.seeded/v5/flex.c,v 1.1.1.2 2003/09/02 20:22:00 expsir Exp $ */
        -: 7733:
        -: 7734:
        -: 7735:
        -: 7736:/* declarations for functions that have forward references */
        -: 7737:
        -: 7738:void mkentry PROTO((register int*, int, int, int, int));
        -: 7739:void mkprot PROTO((int[], int, int));
        -: 7740:void mktemplate PROTO((int[], int, int));
        -: 7741:void mv2front PROTO((int));
        -: 7742:int tbldiff PROTO((int[], int, int[]));
        -: 7743:
        -: 7744:
        -: 7745:/* bldtbl - build table entries for dfa state
        -: 7746: *
        -: 7747: * synopsis
        -: 7748: *   int state[numecs], statenum, totaltrans, comstate, comfreq;
        -: 7749: *   bldtbl( state, statenum, totaltrans, comstate, comfreq );
        -: 7750: *
        -: 7751: * State is the statenum'th dfa state.  It is indexed by equivalence class and
        -: 7752: * gives the number of the state to enter for a given equivalence class.
        -: 7753: * totaltrans is the total number of transitions out of the state.  Comstate
        -: 7754: * is that state which is the destination of the most transitions out of State.
        -: 7755: * Comfreq is how many transitions there are out of State to Comstate.
        -: 7756: *
        -: 7757: * A note on terminology:
        -: 7758: *    "protos" are transition tables which have a high probability of
        -: 7759: * either being redundant (a state processed later will have an identical
        -: 7760: * transition table) or nearly redundant (a state processed later will have
        -: 7761: * many of the same out-transitions).  A "most recently used" queue of
        -: 7762: * protos is kept around with the hope that most states will find a proto
        -: 7763: * which is similar enough to be usable, and therefore compacting the
        -: 7764: * output tables.
        -: 7765: *    "templates" are a special type of proto.  If a transition table is
        -: 7766: * homogeneous or nearly homogeneous (all transitions go to the same
        -: 7767: * destination) then the odds are good that future states will also go
        -: 7768: * to the same destination state on basically the same character set.
        -: 7769: * These homogeneous states are so common when dealing with large rule
        -: 7770: * sets that they merit special attention.  If the transition table were
        -: 7771: * simply made into a proto, then (typically) each subsequent, similar
        -: 7772: * state will differ from the proto for two out-transitions.  One of these
        -: 7773: * out-transitions will be that character on which the proto does not go
        -: 7774: * to the common destination, and one will be that character on which the
        -: 7775: * state does not go to the common destination.  Templates, on the other
        -: 7776: * hand, go to the common state on EVERY transition character, and therefore
        -: 7777: * cost only one difference.
        -: 7778: */
        -: 7779:
function bldtbl called 10838 returned 100% blocks executed 100%
    10838: 7780:void bldtbl( state, statenum, totaltrans, comstate, comfreq )
        -: 7781:int state[], statenum, totaltrans, comstate, comfreq;
        -: 7782:	{
        -: 7783:	int extptr, extrct[2][CSIZE + 1];
        -: 7784:	int mindiff, minprot, i, d;
        -: 7785:
        -: 7786:	/* If extptr is 0 then the first array of extrct holds the result
        -: 7787:	 * of the "best difference" to date, which is those transitions
        -: 7788:	 * which occur in "state" but not in the proto which, to date,
        -: 7789:	 * has the fewest differences between itself and "state".  If
        -: 7790:	 * extptr is 1 then the second array of extrct hold the best
        -: 7791:	 * difference.  The two arrays are toggled between so that the
        -: 7792:	 * best difference to date can be kept around and also a difference
        -: 7793:	 * just created by checking against a candidate "best" proto.
        -: 7794:	 */
        -: 7795:
    10838: 7796:	extptr = 0;
        -: 7797:
        -: 7798:	/* If the state has too few out-transitions, don't bother trying to
        -: 7799:	 * compact its tables.
        -: 7800:	 */
        -: 7801:
    10838: 7802:	if ( (totaltrans * 100) < (numecs * PROTO_SIZE_PERCENTAGE) )
branch  0 taken 6807 (fallthrough)
branch  1 taken 4031
     6807: 7803:		mkentry( state, numecs, statenum, JAMSTATE, totaltrans );
call    0 returned 6807
        -: 7804:
        -: 7805:	else
        -: 7806:		{
        -: 7807:		/* "checkcom" is true if we should only check "state" against
        -: 7808:		 * protos which have the same "comstate" value.
        -: 7809:		 */
     4031: 7810:		int checkcom =
     4031: 7811:			comfreq * 100 > totaltrans * CHECK_COM_PERCENTAGE;
        -: 7812:
     4031: 7813:		minprot = firstprot;
     4031: 7814:		mindiff = totaltrans;
        -: 7815:
     4031: 7816:		if ( checkcom )
branch  0 taken 2594 (fallthrough)
branch  1 taken 1437
        -: 7817:			{
        -: 7818:			/* Find first proto which has the same "comstate". */
     3853: 7819:			for ( i = firstprot; i != NIL; i = protnext[i] )
branch  0 taken 3183
branch  1 taken 670 (fallthrough)
     3183: 7820:				if ( protcomst[i] == comstate )
branch  0 taken 1924 (fallthrough)
branch  1 taken 1259
        -: 7821:					{
     1924: 7822:					minprot = i;
     1924: 7823:					mindiff = tbldiff( state, minprot,
     1924: 7824:							extrct[extptr] );
call    0 returned 1924
     1924: 7825:					break;
        -: 7826:					}
        -: 7827:			}
        -: 7828:
        -: 7829:		else
        -: 7830:			{
        -: 7831:			/* Since we've decided that the most common destination
        -: 7832:			 * out of "state" does not occur with a high enough
        -: 7833:			 * frequency, we set the "comstate" to zero, assuring
        -: 7834:			 * that if this state is entered into the proto list,
        -: 7835:			 * it will not be considered a template.
        -: 7836:			 */
     1437: 7837:			comstate = 0;
        -: 7838:
     1437: 7839:			if ( firstprot != NIL )
branch  0 taken 1291 (fallthrough)
branch  1 taken 146
        -: 7840:				{
     1291: 7841:				minprot = firstprot;
     1291: 7842:				mindiff = tbldiff( state, minprot,
     1291: 7843:						extrct[extptr] );
call    0 returned 1291
        -: 7844:				}
        -: 7845:			}
        -: 7846:
        -: 7847:		/* We now have the first interesting proto in "minprot".  If
        -: 7848:		 * it matches within the tolerances set for the first proto,
        -: 7849:		 * we don't want to bother scanning the rest of the proto list
        -: 7850:		 * to see if we have any other reasonable matches.
        -: 7851:		 */
        -: 7852:
     4031: 7853:		if ( mindiff * 100 > totaltrans * FIRST_MATCH_DIFF_PERCENTAGE )
branch  0 taken 1655 (fallthrough)
branch  1 taken 2376
        -: 7854:			{
        -: 7855:			/* Not a good enough match.  Scan the rest of the
        -: 7856:			 * protos.
        -: 7857:			 */
    14093: 7858:			for ( i = minprot; i != NIL; i = protnext[i] )
branch  0 taken 12438
branch  1 taken 1655 (fallthrough)
        -: 7859:				{
    12438: 7860:				d = tbldiff( state, i, extrct[1 - extptr] );
call    0 returned 12438
    12438: 7861:				if ( d < mindiff )
branch  0 taken 71 (fallthrough)
branch  1 taken 12367
        -: 7862:					{
       71: 7863:					extptr = 1 - extptr;
       71: 7864:					mindiff = d;
       71: 7865:					minprot = i;
        -: 7866:					}
        -: 7867:				}
        -: 7868:			}
        -: 7869:
        -: 7870:		/* Check if the proto we've decided on as our best bet is close
        -: 7871:		 * enough to the state we want to match to be usable.
        -: 7872:		 */
        -: 7873:
     4031: 7874:		if ( mindiff * 100 > totaltrans * ACCEPTABLE_DIFF_PERCENTAGE )
branch  0 taken 864 (fallthrough)
branch  1 taken 3167
        -: 7875:			{
        -: 7876:			/* No good.  If the state is homogeneous enough,
        -: 7877:			 * we make a template out of it.  Otherwise, we
        -: 7878:			 * make a proto.
        -: 7879:			 */
        -: 7880:
      864: 7881:			if ( comfreq * 100 >=
      864: 7882:			     totaltrans * TEMPLATE_SAME_PERCENTAGE )
branch  0 taken 625 (fallthrough)
branch  1 taken 239
      625: 7883:				mktemplate( state, statenum, comstate );
call    0 returned 625
        -: 7884:
        -: 7885:			else
        -: 7886:				{
      239: 7887:				mkprot( state, statenum, comstate );
call    0 returned 239
      239: 7888:				mkentry( state, numecs, statenum,
call    0 returned 239
        -: 7889:					JAMSTATE, totaltrans );
        -: 7890:				}
        -: 7891:			}
        -: 7892:
        -: 7893:		else
        -: 7894:			{ /* use the proto */
     3167: 7895:			mkentry( extrct[extptr], numecs, statenum,
call    0 returned 3167
        -: 7896:				prottbl[minprot], mindiff );
        -: 7897:
        -: 7898:			/* If this state was sufficiently different from the
        -: 7899:			 * proto we built it from, make it, too, a proto.
        -: 7900:			 */
        -: 7901:
     3167: 7902:			if ( mindiff * 100 >=
     3167: 7903:			     totaltrans * NEW_PROTO_DIFF_PERCENTAGE )
branch  0 taken 117 (fallthrough)
branch  1 taken 3050
      117: 7904:				mkprot( state, statenum, comstate );
call    0 returned 117
        -: 7905:
        -: 7906:			/* Since mkprot added a new proto to the proto queue,
        -: 7907:			 * it's possible that "minprot" is no longer on the
        -: 7908:			 * proto queue (if it happened to have been the last
        -: 7909:			 * entry, it would have been bumped off).  If it's
        -: 7910:			 * not there, then the new proto took its physical
        -: 7911:			 * place (though logically the new proto is at the
        -: 7912:			 * beginning of the queue), so in that case the
        -: 7913:			 * following call will do nothing.
        -: 7914:			 */
        -: 7915:
     3167: 7916:			mv2front( minprot );
call    0 returned 3167
        -: 7917:			}
        -: 7918:		}
    10838: 7919:	}
        -: 7920:
        -: 7921:
        -: 7922:/* cmptmps - compress template table entries
        -: 7923: *
        -: 7924: * Template tables are compressed by using the 'template equivalence
        -: 7925: * classes', which are collections of transition character equivalence
        -: 7926: * classes which always appear together in templates - really meta-equivalence
        -: 7927: * classes.
        -: 7928: */
        -: 7929:
function cmptmps called 428 returned 100% blocks executed 95%
      428: 7930:void cmptmps()
        -: 7931:	{
        -: 7932:	int tmpstorage[CSIZE + 1];
      428: 7933:	register int *tmp = tmpstorage, i, j;
        -: 7934:	int totaltrans, trans;
        -: 7935:
      428: 7936:	peakpairs = numtemps * numecs + tblend;
        -: 7937:
      428: 7938:	if ( usemecs )
branch  0 taken 215 (fallthrough)
branch  1 taken 213
        -: 7939:		{
        -: 7940:		/* Create equivalence classes based on data gathered on
        -: 7941:		 * template transitions.
        -: 7942:		 */
      215: 7943:		nummecs = cre8ecs( tecfwd, tecbck, numecs );
call    0 returned 215
        -: 7944:		}
        -: 7945:
        -: 7946:	else
      213: 7947:		nummecs = numecs;
        -: 7948:
      428: 7949:	while ( lastdfa + numtemps + 1 >= current_max_dfas )
branch  0 taken 0
branch  1 taken 428 (fallthrough)
    #####: 7950:		increase_max_dfas();
call    0 never executed
        -: 7951:
        -: 7952:	/* Loop through each template. */
        -: 7953:
     1053: 7954:	for ( i = 1; i <= numtemps; ++i )
branch  0 taken 625
branch  1 taken 428 (fallthrough)
        -: 7955:		{
        -: 7956:		/* Number of non-jam transitions out of this template. */
      625: 7957:		totaltrans = 0;
        -: 7958:
    58660: 7959:		for ( j = 1; j <= numecs; ++j )
branch  0 taken 58035
branch  1 taken 625 (fallthrough)
        -: 7960:			{
    58035: 7961:			trans = tnxt[numecs * i + j];
        -: 7962:
    58035: 7963:			if ( usemecs )
branch  0 taken 27542 (fallthrough)
branch  1 taken 30493
        -: 7964:				{
        -: 7965:				/* The absolute value of tecbck is the
        -: 7966:				 * meta-equivalence class of a given
        -: 7967:				 * equivalence class, as set up by cre8ecs().
        -: 7968:				 */
    27542: 7969:				if ( tecbck[j] > 0 )
branch  0 taken 948 (fallthrough)
branch  1 taken 26594
        -: 7970:					{
      948: 7971:					tmp[tecbck[j]] = trans;
        -: 7972:
      948: 7973:					if ( trans > 0 )
branch  0 taken 454 (fallthrough)
branch  1 taken 494
      454: 7974:						++totaltrans;
        -: 7975:					}
        -: 7976:				}
        -: 7977:
        -: 7978:			else
        -: 7979:				{
    30493: 7980:				tmp[j] = trans;
        -: 7981:
    30493: 7982:				if ( trans > 0 )
branch  0 taken 29308 (fallthrough)
branch  1 taken 1185
    29308: 7983:					++totaltrans;
        -: 7984:				}
        -: 7985:			}
        -: 7986:
        -: 7987:		/* It is assumed (in a rather subtle way) in the skeleton
        -: 7988:		 * that if we're using meta-equivalence classes, the def[]
        -: 7989:		 * entry for all templates is the jam template, i.e.,
        -: 7990:		 * templates never default to other non-jam table entries
        -: 7991:		 * (e.g., another template)
        -: 7992:		 */
        -: 7993:
        -: 7994:		/* Leave room for the jam-state after the last real state. */
      625: 7995:		mkentry( tmp, nummecs, lastdfa + i + 1, JAMSTATE, totaltrans );
call    0 returned 625
        -: 7996:		}
      428: 7997:	}
        -: 7998:
        -: 7999:
        -: 8000:
        -: 8001:/* expand_nxt_chk - expand the next check arrays */
        -: 8002:
function expand_nxt_chk called 32 returned 100% blocks executed 100%
       32: 8003:void expand_nxt_chk()
        -: 8004:	{
       32: 8005:	register int old_max = current_max_xpairs;
        -: 8006:
       32: 8007:	current_max_xpairs += MAX_XPAIRS_INCREMENT;
        -: 8008:
       32: 8009:	++num_reallocs;
        -: 8010:
       32: 8011:	nxt = reallocate_integer_array( nxt, current_max_xpairs );
call    0 returned 32
       32: 8012:	chk = reallocate_integer_array( chk, current_max_xpairs );
call    0 returned 32
        -: 8013:
       32: 8014:	zero_out( (char *) (chk + old_max),
call    0 returned 32
        -: 8015:		(size_t) (MAX_XPAIRS_INCREMENT * sizeof( int )) );
       32: 8016:	}
        -: 8017:
        -: 8018:
        -: 8019:/* find_table_space - finds a space in the table for a state to be placed
        -: 8020: *
        -: 8021: * synopsis
        -: 8022: *     int *state, numtrans, block_start;
        -: 8023: *     int find_table_space();
        -: 8024: *
        -: 8025: *     block_start = find_table_space( state, numtrans );
        -: 8026: *
        -: 8027: * State is the state to be added to the full speed transition table.
        -: 8028: * Numtrans is the number of out-transitions for the state.
        -: 8029: *
        -: 8030: * find_table_space() returns the position of the start of the first block (in
        -: 8031: * chk) able to accommodate the state
        -: 8032: *
        -: 8033: * In determining if a state will or will not fit, find_table_space() must take
        -: 8034: * into account the fact that an end-of-buffer state will be added at [0],
        -: 8035: * and an action number will be added in [-1].
        -: 8036: */
        -: 8037:
function find_table_space called 2262 returned 100% blocks executed 93%
     2262: 8038:int find_table_space( state, numtrans )
        -: 8039:int *state, numtrans;
        -: 8040:	{
        -: 8041:	/* Firstfree is the position of the first possible occurrence of two
        -: 8042:	 * consecutive unused records in the chk and nxt arrays.
        -: 8043:	 */
        -: 8044:	register int i;
        -: 8045:	register int *state_ptr, *chk_ptr;
        -: 8046:	register int *ptr_to_last_entry_in_state;
        -: 8047:
        -: 8048:	/* If there are too many out-transitions, put the state at the end of
        -: 8049:	 * nxt and chk.
        -: 8050:	 */
     2262: 8051:	if ( numtrans > MAX_XTIONS_FULL_INTERIOR_FIT )
branch  0 taken 764 (fallthrough)
branch  1 taken 1498
        -: 8052:		{
        -: 8053:		/* If table is empty, return the first available spot in
        -: 8054:		 * chk/nxt, which should be 1.
        -: 8055:		 */
      764: 8056:		if ( tblend < 2 )
branch  0 taken 0 (fallthrough)
branch  1 taken 764
    #####: 8057:			return 1;
        -: 8058:
        -: 8059:		/* Start searching for table space near the end of
        -: 8060:		 * chk/nxt arrays.
        -: 8061:		 */
      764: 8062:		i = tblend - numecs;
        -: 8063:		}
        -: 8064:
        -: 8065:	else
        -: 8066:		/* Start searching for table space from the beginning
        -: 8067:		 * (skipping only the elements which will definitely not
        -: 8068:		 * hold the new state).
        -: 8069:		 */
     1498: 8070:		i = firstfree;
        -: 8071:
        -: 8072:	while ( 1 )	/* loops until a space is found */
        -: 8073:		{
    14707: 8074:		while ( i + numecs >= current_max_xpairs )
branch  0 taken 0
branch  1 taken 14707 (fallthrough)
    #####: 8075:			expand_nxt_chk();
call    0 never executed
        -: 8076:
        -: 8077:		/* Loops until space for end-of-buffer and action number
        -: 8078:		 * are found.
        -: 8079:		 */
        -: 8080:		while ( 1 )
        -: 8081:			{
        -: 8082:			/* Check for action number space. */
    58555: 8083:			if ( chk[i - 1] == 0 )
branch  0 taken 15749 (fallthrough)
branch  1 taken 42806
        -: 8084:				{
        -: 8085:				/* Check for end-of-buffer space. */
    15749: 8086:				if ( chk[i] == 0 )
branch  0 taken 14707 (fallthrough)
branch  1 taken 1042
    14707: 8087:					break;
        -: 8088:
        -: 8089:				else
        -: 8090:					/* Since i != 0, there is no use
        -: 8091:					 * checking to see if (++i) - 1 == 0,
        -: 8092:					 * because that's the same as i == 0,
        -: 8093:					 * so we skip a space.
        -: 8094:					 */
     1042: 8095:					i += 2;
        -: 8096:				}
        -: 8097:
        -: 8098:			else
    42806: 8099:				++i;
        -: 8100:
    43858: 8101:			while ( i + numecs >= current_max_xpairs )
branch  0 taken 10
branch  1 taken 43848 (fallthrough)
       10: 8102:				expand_nxt_chk();
call    0 returned 10
        -: 8103:			}
        -: 8104:
        -: 8105:		/* If we started search from the beginning, store the new
        -: 8106:		 * firstfree for the next call of find_table_space().
        -: 8107:		 */
    14707: 8108:		if ( numtrans <= MAX_XTIONS_FULL_INTERIOR_FIT )
branch  0 taken 2239 (fallthrough)
branch  1 taken 12468
     2239: 8109:			firstfree = i + 1;
        -: 8110:
        -: 8111:		/* Check to see if all elements in chk (and therefore nxt)
        -: 8112:		 * that are needed for the new state have not yet been taken.
        -: 8113:		 */
        -: 8114:
    14707: 8115:		state_ptr = &state[1];
    14707: 8116:		ptr_to_last_entry_in_state = &chk[i + numecs + 1];
        -: 8117:
    14707: 8118:		for ( chk_ptr = &chk[i + 1];
   788801: 8119:		      chk_ptr != ptr_to_last_entry_in_state; ++chk_ptr )
branch  0 taken 786539
branch  1 taken 2262 (fallthrough)
   786539: 8120:			if ( *(state_ptr++) != 0 && *chk_ptr != 0 )
branch  0 taken 100036 (fallthrough)
branch  1 taken 686503
branch  2 taken 12445 (fallthrough)
branch  3 taken 87591
    12445: 8121:				break;
        -: 8122:
    14707: 8123:		if ( chk_ptr == ptr_to_last_entry_in_state )
branch  0 taken 2262 (fallthrough)
branch  1 taken 12445
     2262: 8124:			return i;
        -: 8125:
        -: 8126:		else
    12445: 8127:		++i;
        -: 8128:		}
        -: 8129:	}
        -: 8130:
        -: 8131:
        -: 8132:/* inittbl - initialize transition tables
        -: 8133: *
        -: 8134: * Initializes "firstfree" to be one beyond the end of the table.  Initializes
        -: 8135: * all "chk" entries to be zero.
        -: 8136: */
function inittbl called 543 returned 100% blocks executed 100%
      543: 8137:void inittbl()
        -: 8138:	{
        -: 8139:	register int i;
        -: 8140:
      543: 8141:	zero_out( (char *) chk, (size_t) (current_max_xpairs * sizeof( int )) );
call    0 returned 543
        -: 8142:
      543: 8143:	tblend = 0;
      543: 8144:	firstfree = tblend + 1;
      543: 8145:	numtemps = 0;
        -: 8146:
      543: 8147:	if ( usemecs )
branch  0 taken 215 (fallthrough)
branch  1 taken 328
        -: 8148:		{
        -: 8149:		/* Set up doubly-linked meta-equivalence classes; these
        -: 8150:		 * are sets of equivalence classes which all have identical
        -: 8151:		 * transitions out of TEMPLATES.
        -: 8152:		 */
        -: 8153:
      215: 8154:		tecbck[1] = NIL;
        -: 8155:
    22318: 8156:		for ( i = 2; i <= numecs; ++i )
branch  0 taken 22103
branch  1 taken 215 (fallthrough)
        -: 8157:			{
    22103: 8158:			tecbck[i] = i - 1;
    22103: 8159:			tecfwd[i - 1] = i;
        -: 8160:			}
        -: 8161:
      215: 8162:		tecfwd[numecs] = NIL;
        -: 8163:		}
      543: 8164:	}
        -: 8165:
        -: 8166:
        -: 8167:/* mkdeftbl - make the default, "jam" table entries */
        -: 8168:
function mkdeftbl called 428 returned 100% blocks executed 100%
      428: 8169:void mkdeftbl()
        -: 8170:	{
        -: 8171:	int i;
        -: 8172:
      428: 8173:	jamstate = lastdfa + 1;
        -: 8174:
      428: 8175:	++tblend; /* room for transition on end-of-buffer character */
        -: 8176:
      446: 8177:	while ( tblend + numecs >= current_max_xpairs )
branch  0 taken 18
branch  1 taken 428 (fallthrough)
       18: 8178:		expand_nxt_chk();
call    0 returned 18
        -: 8179:
        -: 8180:	/* Add in default end-of-buffer transition. */
      428: 8181:	nxt[tblend] = end_of_buffer_state;
      428: 8182:	chk[tblend] = jamstate;
        -: 8183:
    48234: 8184:	for ( i = 1; i <= numecs; ++i )
branch  0 taken 47806
branch  1 taken 428 (fallthrough)
        -: 8185:		{
    47806: 8186:		nxt[tblend + i] = 0;
    47806: 8187:		chk[tblend + i] = jamstate;
        -: 8188:		}
        -: 8189:
      428: 8190:	jambase = tblend;
        -: 8191:
      428: 8192:	base[jamstate] = jambase;
      428: 8193:	def[jamstate] = 0;
        -: 8194:
      428: 8195:	tblend += numecs;
      428: 8196:	++numtemps;
      428: 8197:	}
        -: 8198:
        -: 8199:
        -: 8200:/* mkentry - create base/def and nxt/chk entries for transition array
        -: 8201: *
        -: 8202: * synopsis
        -: 8203: *   int state[numchars + 1], numchars, statenum, deflink, totaltrans;
        -: 8204: *   mkentry( state, numchars, statenum, deflink, totaltrans );
        -: 8205: *
        -: 8206: * "state" is a transition array "numchars" characters in size, "statenum"
        -: 8207: * is the offset to be used into the base/def tables, and "deflink" is the
        -: 8208: * entry to put in the "def" table entry.  If "deflink" is equal to
        -: 8209: * "JAMSTATE", then no attempt will be made to fit zero entries of "state"
        -: 8210: * (i.e., jam entries) into the table.  It is assumed that by linking to
        -: 8211: * "JAMSTATE" they will be taken care of.  In any case, entries in "state"
        -: 8212: * marking transitions to "SAME_TRANS" are treated as though they will be
        -: 8213: * taken care of by whereever "deflink" points.  "totaltrans" is the total
        -: 8214: * number of transitions out of the state.  If it is below a certain threshold,
        -: 8215: * the tables are searched for an interior spot that will accommodate the
        -: 8216: * state array.
        -: 8217: */
        -: 8218:
function mkentry called 11463 returned 100% blocks executed 98%
    11463: 8219:void mkentry( state, numchars, statenum, deflink, totaltrans )
        -: 8220:register int *state;
        -: 8221:int numchars, statenum, deflink, totaltrans;
        -: 8222:	{
        -: 8223:	register int minec, maxec, i, baseaddr;
        -: 8224:	int tblbase, tbllast;
        -: 8225:
    11463: 8226:	if ( totaltrans == 0 )
branch  0 taken 2601 (fallthrough)
branch  1 taken 8862
        -: 8227:		{ /* there are no out-transitions */
     2601: 8228:		if ( deflink == JAMSTATE )
branch  0 taken 1943 (fallthrough)
branch  1 taken 658
     1943: 8229:			base[statenum] = JAMSTATE;
        -: 8230:		else
      658: 8231:			base[statenum] = 0;
        -: 8232:
     2601: 8233:		def[statenum] = deflink;
     2601: 8234:		return;
        -: 8235:		}
        -: 8236:
   296460: 8237:	for ( minec = 1; minec <= numchars; ++minec )
branch  0 taken 296460
branch  1 taken 0 (fallthrough)
        -: 8238:		{
   296460: 8239:		if ( state[minec] != SAME_TRANS )
branch  0 taken 231113 (fallthrough)
branch  1 taken 65347
   231113: 8240:			if ( state[minec] != 0 || deflink != JAMSTATE )
branch  0 taken 222251 (fallthrough)
branch  1 taken 8862
branch  2 taken 222251 (fallthrough)
branch  3 taken 0
        -: 8241:				break;
        -: 8242:		}
        -: 8243:
     8862: 8244:	if ( totaltrans == 1 )
branch  0 taken 5279 (fallthrough)
branch  1 taken 3583
        -: 8245:		{
        -: 8246:		/* There's only one out-transition.  Save it for later to fill
        -: 8247:		 * in holes in the tables.
        -: 8248:		 */
     5279: 8249:		stack1( statenum, minec, state[minec], deflink );
call    0 returned 5279
     5279: 8250:		return;
        -: 8251:		}
        -: 8252:
   257780: 8253:	for ( maxec = numchars; maxec > 0; --maxec )
branch  0 taken 257780
branch  1 taken 0 (fallthrough)
        -: 8254:		{
   257780: 8255:		if ( state[maxec] != SAME_TRANS )
branch  0 taken 206794 (fallthrough)
branch  1 taken 50986
   206794: 8256:			if ( state[maxec] != 0 || deflink != JAMSTATE )
branch  0 taken 203211 (fallthrough)
branch  1 taken 3583
branch  2 taken 203211 (fallthrough)
branch  3 taken 0
        -: 8257:				break;
        -: 8258:		}
        -: 8259:
        -: 8260:	/* Whether we try to fit the state table in the middle of the table
        -: 8261:	 * entries we have already generated, or if we just take the state
        -: 8262:	 * table at the end of the nxt/chk tables, we must make sure that we
        -: 8263:	 * have a valid base address (i.e., non-negative).  Note that
        -: 8264:	 * negative base addresses dangerous at run-time (because indexing
        -: 8265:	 * the nxt array with one and a low-valued character will access
        -: 8266:	 * memory before the start of the array.
        -: 8267:	 */
        -: 8268:
        -: 8269:	/* Find the first transition of state that we need to worry about. */
     3583: 8270:	if ( totaltrans * 100 <= numchars * INTERIOR_FIT_PERCENTAGE )
branch  0 taken 2778 (fallthrough)
branch  1 taken 805
        -: 8271:		{
        -: 8272:		/* Attempt to squeeze it into the middle of the tables. */
     2778: 8273:		baseaddr = firstfree;
        -: 8274:
    63885: 8275:		while ( baseaddr < minec )
branch  0 taken 61107
branch  1 taken 2778 (fallthrough)
        -: 8276:			{
        -: 8277:			/* Using baseaddr would result in a negative base
        -: 8278:			 * address below; find the next free slot.
        -: 8279:			 */
    93349: 8280:			for ( ++baseaddr; chk[baseaddr] != 0; ++baseaddr )
branch  0 taken 32242
branch  1 taken 61107 (fallthrough)
        -: 8281:				;
        -: 8282:			}
        -: 8283:
     2778: 8284:		while ( baseaddr + maxec - minec + 1 >= current_max_xpairs )
branch  0 taken 0
branch  1 taken 2778 (fallthrough)
    #####: 8285:			expand_nxt_chk();
call    0 never executed
        -: 8286:
 26584246: 8287:		for ( i = minec; i <= maxec; ++i )
branch  0 taken 26581468
branch  1 taken 2778
 26581468: 8288:			if ( state[i] != SAME_TRANS &&
branch  0 taken 4043339 (fallthrough)
branch  1 taken 22538129
  4043339: 8289:			     (state[i] != 0 || deflink != JAMSTATE) &&
branch  0 taken 263037 (fallthrough)
branch  1 taken 3780302
branch  2 taken 0 (fallthrough)
branch  3 taken 263037
  3780302: 8290:			     chk[baseaddr + i - minec] != 0 )
branch  0 taken 1502491 (fallthrough)
branch  1 taken 2277811
        -: 8291:				{ /* baseaddr unsuitable - find another */
  1502491: 8292:				for ( ++baseaddr;
  5211678: 8293:				      baseaddr < current_max_xpairs &&
branch  0 taken 5211678 (fallthrough)
branch  1 taken 0
  5211678: 8294:				      chk[baseaddr] != 0; ++baseaddr )
branch  0 taken 3709187
branch  1 taken 1502491 (fallthrough)
        -: 8295:					;
        -: 8296:
  1502494: 8297:				while ( baseaddr + maxec - minec + 1 >=
branch  0 taken 3
branch  1 taken 1502491 (fallthrough)
        -: 8298:					current_max_xpairs )
        3: 8299:					expand_nxt_chk();
call    0 returned 3
        -: 8300:
        -: 8301:				/* Reset the loop counter so we'll start all
        -: 8302:				 * over again next time it's incremented.
        -: 8303:				 */
        -: 8304:
  1502491: 8305:				i = minec - 1;
        -: 8306:				}
        -: 8307:		}
        -: 8308:
        -: 8309:	else
        -: 8310:		{
        -: 8311:		/* Ensure that the base address we eventually generate is
        -: 8312:		 * non-negative.
        -: 8313:		 */
      805: 8314:		baseaddr = MAX( tblend + 1, minec );
branch  0 taken 487 (fallthrough)
branch  1 taken 318
        -: 8315:		}
        -: 8316:
     3583: 8317:	tblbase = baseaddr - minec;
     3583: 8318:	tbllast = tblbase + maxec;
        -: 8319:
     3584: 8320:	while ( tbllast + 1 >= current_max_xpairs )
branch  0 taken 1
branch  1 taken 3583 (fallthrough)
        1: 8321:		expand_nxt_chk();
call    0 returned 1
        -: 8322:
     3583: 8323:	base[statenum] = tblbase;
     3583: 8324:	def[statenum] = deflink;
        -: 8325:
   186157: 8326:	for ( i = minec; i <= maxec; ++i )
branch  0 taken 182574
branch  1 taken 3583 (fallthrough)
   182574: 8327:		if ( state[i] != SAME_TRANS )
branch  0 taken 128963 (fallthrough)
branch  1 taken 53611
   128963: 8328:			if ( state[i] != 0 || deflink != JAMSTATE )
branch  0 taken 45484 (fallthrough)
branch  1 taken 83479
branch  2 taken 0 (fallthrough)
branch  3 taken 45484
        -: 8329:				{
    83479: 8330:				nxt[tblbase + i] = state[i];
    83479: 8331:				chk[tblbase + i] = statenum;
        -: 8332:				}
        -: 8333:
     3583: 8334:	if ( baseaddr == firstfree )
branch  0 taken 432 (fallthrough)
branch  1 taken 3151
        -: 8335:		/* Find next free slot in tables. */
     4076: 8336:		for ( ++firstfree; chk[firstfree] != 0; ++firstfree )
branch  0 taken 3644
branch  1 taken 432 (fallthrough)
        -: 8337:			;
        -: 8338:
     3583: 8339:	tblend = MAX( tblend, tbllast );
        -: 8340:	}
        -: 8341:
        -: 8342:
        -: 8343:/* mk1tbl - create table entries for a state (or state fragment) which
        -: 8344: *            has only one out-transition
        -: 8345: */
        -: 8346:
function mk1tbl called 5707 returned 100% blocks executed 80%
     5707: 8347:void mk1tbl( state, sym, onenxt, onedef )
        -: 8348:int state, sym, onenxt, onedef;
        -: 8349:	{
     5707: 8350:	if ( firstfree < sym )
branch  0 taken 272 (fallthrough)
branch  1 taken 5435
      272: 8351:		firstfree = sym;
        -: 8352:
    19679: 8353:	while ( chk[firstfree] != 0 )
branch  0 taken 13972
branch  1 taken 5707 (fallthrough)
    13972: 8354:		if ( ++firstfree >= current_max_xpairs )
branch  0 taken 0 (fallthrough)
branch  1 taken 13972
    #####: 8355:			expand_nxt_chk();
call    0 never executed
        -: 8356:
     5707: 8357:	base[state] = firstfree - sym;
     5707: 8358:	def[state] = onedef;
     5707: 8359:	chk[firstfree] = state;
     5707: 8360:	nxt[firstfree] = onenxt;
        -: 8361:
     5707: 8362:	if ( firstfree > tblend )
branch  0 taken 4126 (fallthrough)
branch  1 taken 1581
        -: 8363:		{
     4126: 8364:		tblend = firstfree++;
        -: 8365:
     4126: 8366:		if ( firstfree >= current_max_xpairs )
branch  0 taken 0 (fallthrough)
branch  1 taken 4126
    #####: 8367:			expand_nxt_chk();
call    0 never executed
        -: 8368:		}
     5707: 8369:	}
        -: 8370:
        -: 8371:
        -: 8372:/* mkprot - create new proto entry */
        -: 8373:
function mkprot called 981 returned 100% blocks executed 90%
      981: 8374:void mkprot( state, statenum, comstate )
        -: 8375:int state[], statenum, comstate;
        -: 8376:	{
        -: 8377:	int i, slot, tblbase;
        -: 8378:
      981: 8379:	if ( ++numprots >= MSP || numecs * numprots >= PROT_SAVE_SIZE )
branch  0 taken 981 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 981
        -: 8380:		{
        -: 8381:		/* Gotta make room for the new proto by dropping last entry in
        -: 8382:		 * the queue.
        -: 8383:		 */
    #####: 8384:		slot = lastprot;
    #####: 8385:		lastprot = protprev[lastprot];
    #####: 8386:		protnext[lastprot] = NIL;
        -: 8387:		}
        -: 8388:
        -: 8389:	else
      981: 8390:		slot = numprots;
        -: 8391:
      981: 8392:	protnext[slot] = firstprot;
        -: 8393:
      981: 8394:	if ( firstprot != NIL )
branch  0 taken 553 (fallthrough)
branch  1 taken 428
      553: 8395:		protprev[firstprot] = slot;
        -: 8396:
      981: 8397:	firstprot = slot;
      981: 8398:	prottbl[slot] = statenum;
      981: 8399:	protcomst[slot] = comstate;
        -: 8400:
        -: 8401:	/* Copy state into save area so it can be compared with rapidly. */
      981: 8402:	tblbase = numecs * (slot - 1);
        -: 8403:
    64566: 8404:	for ( i = 1; i <= numecs; ++i )
branch  0 taken 63585
branch  1 taken 981 (fallthrough)
    63585: 8405:		protsave[tblbase + i] = state[i];
      981: 8406:	}
        -: 8407:
        -: 8408:
        -: 8409:/* mktemplate - create a template entry based on a state, and connect the state
        -: 8410: *              to it
        -: 8411: */
        -: 8412:
function mktemplate called 625 returned 100% blocks executed 87%
      625: 8413:void mktemplate( state, statenum, comstate )
        -: 8414:int state[], statenum, comstate;
        -: 8415:	{
        -: 8416:	int i, numdiff, tmpbase, tmp[CSIZE + 1];
        -: 8417:	Char transset[CSIZE + 1];
        -: 8418:	int tsptr;
        -: 8419:
      625: 8420:	++numtemps;
        -: 8421:
      625: 8422:	tsptr = 0;
        -: 8423:
        -: 8424:	/* Calculate where we will temporarily store the transition table
        -: 8425:	 * of the template in the tnxt[] array.  The final transition table
        -: 8426:	 * gets created by cmptmps().
        -: 8427:	 */
        -: 8428:
      625: 8429:	tmpbase = numtemps * numecs;
        -: 8430:
      625: 8431:	if ( tmpbase + numecs >= current_max_template_xpairs )
branch  0 taken 0 (fallthrough)
branch  1 taken 625
        -: 8432:		{
    #####: 8433:		current_max_template_xpairs += MAX_TEMPLATE_XPAIRS_INCREMENT;
        -: 8434:
    #####: 8435:		++num_reallocs;
        -: 8436:
    #####: 8437:		tnxt = reallocate_integer_array( tnxt,
call    0 never executed
        -: 8438:			current_max_template_xpairs );
        -: 8439:		}
        -: 8440:
    58660: 8441:	for ( i = 1; i <= numecs; ++i )
branch  0 taken 58035
branch  1 taken 625 (fallthrough)
    58035: 8442:		if ( state[i] == 0 )
branch  0 taken 2357 (fallthrough)
branch  1 taken 55678
     2357: 8443:			tnxt[tmpbase + i] = 0;
        -: 8444:		else
        -: 8445:			{
    55678: 8446:			transset[tsptr++] = i;
    55678: 8447:			tnxt[tmpbase + i] = comstate;
        -: 8448:			}
        -: 8449:
      625: 8450:	if ( usemecs )
branch  0 taken 320 (fallthrough)
branch  1 taken 305
      320: 8451:		mkeccl( transset, tsptr, tecfwd, tecbck, numecs, 0 );
call    0 returned 320
        -: 8452:
      625: 8453:	mkprot( tnxt + tmpbase, -numtemps, comstate );
call    0 returned 625
        -: 8454:
        -: 8455:	/* We rely on the fact that mkprot adds things to the beginning
        -: 8456:	 * of the proto queue.
        -: 8457:	 */
        -: 8458:
      625: 8459:	numdiff = tbldiff( state, firstprot, tmp );
call    0 returned 625
      625: 8460:	mkentry( tmp, numecs, statenum, -numtemps, numdiff );
call    0 returned 625
      625: 8461:	}
        -: 8462:
        -: 8463:
        -: 8464:/* mv2front - move proto queue element to front of queue */
        -: 8465:
function mv2front called 3167 returned 100% blocks executed 100%
     3167: 8466:void mv2front( qelm )
        -: 8467:int qelm;
        -: 8468:	{
     3167: 8469:	if ( firstprot != qelm )
branch  0 taken 395 (fallthrough)
branch  1 taken 2772
        -: 8470:		{
      395: 8471:		if ( qelm == lastprot )
branch  0 taken 57 (fallthrough)
branch  1 taken 338
       57: 8472:			lastprot = protprev[lastprot];
        -: 8473:
      395: 8474:		protnext[protprev[qelm]] = protnext[qelm];
        -: 8475:
      395: 8476:		if ( protnext[qelm] != NIL )
branch  0 taken 338 (fallthrough)
branch  1 taken 57
      338: 8477:			protprev[protnext[qelm]] = protprev[qelm];
        -: 8478:
      395: 8479:		protprev[qelm] = NIL;
      395: 8480:		protnext[qelm] = firstprot;
      395: 8481:		protprev[firstprot] = qelm;
      395: 8482:		firstprot = qelm;
        -: 8483:		}
     3167: 8484:	}
        -: 8485:
        -: 8486:
        -: 8487:/* place_state - place a state into full speed transition table
        -: 8488: *
        -: 8489: * State is the statenum'th state.  It is indexed by equivalence class and
        -: 8490: * gives the number of the state to enter for a given equivalence class.
        -: 8491: * Transnum is the number of out-transitions for the state.
        -: 8492: */
        -: 8493:
function place_state called 2262 returned 100% blocks executed 100%
     2262: 8494:void place_state( state, statenum, transnum )
        -: 8495:int *state, statenum, transnum;
        -: 8496:	{
        -: 8497:	register int i;
        -: 8498:	register int *state_ptr;
     2262: 8499:	int position = find_table_space( state, transnum );
call    0 returned 2262
        -: 8500:
        -: 8501:	/* "base" is the table of start positions. */
     2262: 8502:	base[statenum] = position;
        -: 8503:
        -: 8504:	/* Put in action number marker; this non-zero number makes sure that
        -: 8505:	 * find_table_space() knows that this position in chk/nxt is taken
        -: 8506:	 * and should not be used for another accepting number in another
        -: 8507:	 * state.
        -: 8508:	 */
     2262: 8509:	chk[position - 1] = 1;
        -: 8510:
        -: 8511:	/* Put in end-of-buffer marker; this is for the same purposes as
        -: 8512:	 * above.
        -: 8513:	 */
     2262: 8514:	chk[position] = 1;
        -: 8515:
        -: 8516:	/* Place the state into chk and nxt. */
     2262: 8517:	state_ptr = &state[1];
        -: 8518:
   181878: 8519:	for ( i = 1; i <= numecs; ++i, ++state_ptr )
branch  0 taken 179616
branch  1 taken 2262 (fallthrough)
   179616: 8520:		if ( *state_ptr != 0 )
branch  0 taken 32723 (fallthrough)
branch  1 taken 146893
        -: 8521:			{
    32723: 8522:			chk[position + i] = i;
    32723: 8523:			nxt[position + i] = *state_ptr;
        -: 8524:			}
        -: 8525:
     2262: 8526:	if ( position + numecs > tblend )
branch  0 taken 2226 (fallthrough)
branch  1 taken 36
     2226: 8527:		tblend = position + numecs;
     2262: 8528:	}
        -: 8529:
        -: 8530:
        -: 8531:/* stack1 - save states with only one out-transition to be processed later
        -: 8532: *
        -: 8533: * If there's room for another state on the "one-transition" stack, the
        -: 8534: * state is pushed onto it, to be processed later by mk1tbl.  If there's
        -: 8535: * no room, we process the sucker right now.
        -: 8536: */
        -: 8537:
function stack1 called 5707 returned 100% blocks executed 75%
     5707: 8538:void stack1( statenum, sym, nextstate, deflink )
        -: 8539:int statenum, sym, nextstate, deflink;
        -: 8540:	{
     5707: 8541:	if ( onesp >= ONE_STACK_SIZE - 1 )
branch  0 taken 0 (fallthrough)
branch  1 taken 5707
    #####: 8542:		mk1tbl( statenum, sym, nextstate, deflink );
call    0 never executed
        -: 8543:
        -: 8544:	else
        -: 8545:		{
     5707: 8546:		++onesp;
     5707: 8547:		onestate[onesp] = statenum;
     5707: 8548:		onesym[onesp] = sym;
     5707: 8549:		onenext[onesp] = nextstate;
     5707: 8550:		onedef[onesp] = deflink;
        -: 8551:		}
     5707: 8552:	}
        -: 8553:
        -: 8554:
        -: 8555:/* tbldiff - compute differences between two state tables
        -: 8556: *
        -: 8557: * "state" is the state array which is to be extracted from the pr'th
        -: 8558: * proto.  "pr" is both the number of the proto we are extracting from
        -: 8559: * and an index into the save area where we can find the proto's complete
        -: 8560: * state table.  Each entry in "state" which differs from the corresponding
        -: 8561: * entry of "pr" will appear in "ext".
        -: 8562: *
        -: 8563: * Entries which are the same in both "state" and "pr" will be marked
        -: 8564: * as transitions to "SAME_TRANS" in "ext".  The total number of differences
        -: 8565: * between "state" and "pr" is returned as function value.  Note that this
        -: 8566: * number is "numecs" minus the number of "SAME_TRANS" entries in "ext".
        -: 8567: */
        -: 8568:
function tbldiff called 16278 returned 100% blocks executed 100%
    16278: 8569:int tbldiff( state, pr, ext )
        -: 8570:int state[], pr, ext[];
        -: 8571:	{
    16278: 8572:	register int i, *sp = state, *ep = ext, *protp;
    16278: 8573:	register int numdiff = 0;
        -: 8574:
    16278: 8575:	protp = &protsave[numecs * (pr - 1)];
        -: 8576:
   910203: 8577:	for ( i = numecs; i > 0; --i )
branch  0 taken 893925
branch  1 taken 16278 (fallthrough)
        -: 8578:		{
   893925: 8579:		if ( *++protp == *++sp )
branch  0 taken 460400 (fallthrough)
branch  1 taken 433525
   460400: 8580:			*++ep = SAME_TRANS;
        -: 8581:		else
        -: 8582:			{
   433525: 8583:			*++ep = *sp;
   433525: 8584:			++numdiff;
        -: 8585:			}
        -: 8586:		}
        -: 8587:
    16278: 8588:	return numdiff;
        -: 8589:	}
        -: 8590:/* yylex - scanner front-end for flex */
        -: 8591:
        -: 8592:/*-
        -: 8593: * Copyright (c) 1990 The Regents of the University of California.
        -: 8594: * All rights reserved.
        -: 8595: *
        -: 8596: * This code is derived from software contributed to Berkeley by
        -: 8597: * Vern Paxson.
        -: 8598: * 
        -: 8599: * The United States Government has rights in this work pursuant
        -: 8600: * to contract no. DE-AC03-76SF00098 between the United States
        -: 8601: * Department of Energy and the University of California.
        -: 8602: *
        -: 8603: * Redistribution and use in source and binary forms with or without
        -: 8604: * modification are permitted provided that: (1) source distributions retain
        -: 8605: * this entire copyright notice and comment, and (2) distributions including
        -: 8606: * binaries display the following acknowledgement:  ``This product includes
        -: 8607: * software developed by the University of California, Berkeley and its
        -: 8608: * contributors'' in the documentation or other materials provided with the
        -: 8609: * distribution and in all advertising materials mentioning features or use
        -: 8610: * of this software.  Neither the name of the University nor the names of
        -: 8611: * its contributors may be used to endorse or promote products derived from
        -: 8612: * this software without specific prior written permission.
        -: 8613: * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
        -: 8614: * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
        -: 8615: * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
        -: 8616: */
        -: 8617:
        -: 8618:/* $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.seeded/v5/flex.c,v 1.1.1.2 2003/09/02 20:22:00 expsir Exp $ */
        -: 8619:
        -: 8620:
        -: 8621:
        -: 8622:/* yylex - scan for a regular expression token */
        -: 8623:
function yylex called 31314 returned 100% blocks executed 84%
    31314: 8624:int yylex()
        -: 8625:	{
        -: 8626:	int toktype;
        -: 8627:	static int beglin = false;
        -: 8628:	extern char *yytext;
        -: 8629:
    31314: 8630:	if ( eofseen )
branch  0 taken 0 (fallthrough)
branch  1 taken 31314
    #####: 8631:		toktype = EOF;
        -: 8632:	else
    31314: 8633:		toktype = flexscan();
call    0 returned 31314
        -: 8634:
    31314: 8635:	if ( toktype == EOF || toktype == 0 )
branch  0 taken 31314 (fallthrough)
branch  1 taken 0
branch  2 taken 552 (fallthrough)
branch  3 taken 30762
        -: 8636:		{
      552: 8637:		eofseen = 1;
        -: 8638:
      552: 8639:		if ( sectnum == 1 )
branch  0 taken 0 (fallthrough)
branch  1 taken 552
        -: 8640:			{
    #####: 8641:			synerr( _( "premature EOF" ) );
call    0 never executed
    #####: 8642:			sectnum = 2;
    #####: 8643:			toktype = SECTEND;
        -: 8644:			}
        -: 8645:
        -: 8646:		else
      552: 8647:			toktype = 0;
        -: 8648:		}
        -: 8649:
    31314: 8650:	if ( trace )
branch  0 taken 4753 (fallthrough)
branch  1 taken 26561
        -: 8651:		{
     4753: 8652:		if ( beglin )
branch  0 taken 753 (fallthrough)
branch  1 taken 4000
        -: 8653:			{
      753: 8654:			fprintf( err, "%d\t", num_rules + 1 );
call    0 returned 753
      753: 8655:			beglin = 0;
        -: 8656:			}
        -: 8657:
     4753: 8658:		switch ( toktype )
branch  0 taken 866
branch  1 taken 735
branch  2 taken 1
branch  3 taken 10
branch  4 taken 19
branch  5 taken 18
branch  6 taken 3056
branch  7 taken 10
branch  8 taken 18
branch  9 taken 3
branch 10 taken 0
branch 11 taken 0
branch 12 taken 17
branch 13 taken 0
        -: 8659:			{
      866: 8660:			case '<':
        -: 8661:			case '>':
        -: 8662:			case '^':
        -: 8663:			case '$':
        -: 8664:			case '"':
        -: 8665:			case '[':
        -: 8666:			case ']':
        -: 8667:			case '{':
        -: 8668:			case '}':
        -: 8669:			case '|':
        -: 8670:			case '(':
        -: 8671:			case ')':
        -: 8672:			case '-':
        -: 8673:			case '/':
        -: 8674:			case '\\':
        -: 8675:			case '?':
        -: 8676:			case '.':
        -: 8677:			case '*':
        -: 8678:			case '+':
        -: 8679:			case ',':
      866: 8680:				(void) putc( toktype, err );
call    0 returned 866
      866: 8681:				break;
        -: 8682:
      735: 8683:			case '\n':
      735: 8684:				(void) putc( '\n', err );
call    0 returned 735
        -: 8685:
      735: 8686:				if ( sectnum == 2 )
branch  0 taken 735 (fallthrough)
branch  1 taken 0
      735: 8687:				beglin = 1;
        -: 8688:
      735: 8689:				break;
        -: 8690:
        1: 8691:			case SCDECL:
        1: 8692:				fputs( "%s", err );
call    0 returned 1
        1: 8693:				break;
        -: 8694:
       10: 8695:			case XSCDECL:
       10: 8696:				fputs( "%x", err );
call    0 returned 10
       10: 8697:				break;
        -: 8698:
       19: 8699:			case SECTEND:
       19: 8700:				fputs( "%%\n", err );
call    0 returned 19
        -: 8701:
        -: 8702:				/* We set beglin to be true so we'll start
        -: 8703:				 * writing out numbers as we echo rules.
        -: 8704:				 * flexscan() has already assigned sectnum.
        -: 8705:				 */
       19: 8706:				if ( sectnum == 2 )
branch  0 taken 19 (fallthrough)
branch  1 taken 0
       19: 8707:					beglin = 1;
        -: 8708:
       19: 8709:				break;
        -: 8710:
       18: 8711:			case NAME:
       18: 8712:				fprintf( err, "'%s'", nmstr );
call    0 returned 18
       18: 8713:				break;
        -: 8714:
     3056: 8715:			case CHAR:
     3056: 8716:				switch ( yylval )
branch  0 taken 60
branch  1 taken 2996
        -: 8717:					{
       60: 8718:					case '<':
        -: 8719:					case '>':
        -: 8720:					case '^':
        -: 8721:					case '$':
        -: 8722:					case '"':
        -: 8723:					case '[':
        -: 8724:					case ']':
        -: 8725:					case '{':
        -: 8726:					case '}':
        -: 8727:					case '|':
        -: 8728:					case '(':
        -: 8729:					case ')':
        -: 8730:					case '-':
        -: 8731:					case '/':
        -: 8732:					case '\\':
        -: 8733:					case '?':
        -: 8734:					case '.':
        -: 8735:					case '*':
        -: 8736:					case '+':
        -: 8737:					case ',':
       60: 8738:						fprintf( err, "\\%c",
call    0 returned 60
        -: 8739:							yylval );
       60: 8740:						break;
        -: 8741:
     2996: 8742:					default:
     2996: 8743:						if ( ! isascii( yylval ) ||
branch  0 taken 2990 (fallthrough)
branch  1 taken 6
     2990: 8744:						     ! isprint( yylval ) )
branch  0 taken 33 (fallthrough)
branch  1 taken 2957
       39: 8745:							fprintf( err,
call    0 returned 39
        -: 8746:								"\\%.3o",
        -: 8747:							(unsigned int) yylval );
        -: 8748:						else
     2957: 8749:							(void) putc( yylval,
call    0 returned 2957
        -: 8750:								err );
     2996: 8751:					break;
        -: 8752:					}
        -: 8753:
     3056: 8754:				break;
        -: 8755:
       10: 8756:			case NUMBER:
       10: 8757:				fprintf( err, "%d", yylval );
call    0 returned 10
       10: 8758:				break;
        -: 8759:
       18: 8760:			case PREVCCL:
       18: 8761:				fprintf( err, "[%d]", yylval );
call    0 returned 18
       18: 8762:				break;
        -: 8763:
        3: 8764:			case EOF_OP:
        3: 8765:				fprintf( err, "<<EOF>>" );
call    0 returned 3
        3: 8766:				break;
        -: 8767:
    #####: 8768:			case OPTION_OP:
    #####: 8769:				fprintf( err, "%s ", yytext );
call    0 never executed
    #####: 8770:				break;
        -: 8771:
    #####: 8772:			case OPT_OUTFILE:
        -: 8773:			case OPT_PREFIX:
        -: 8774:			case CCE_ALNUM:
        -: 8775:			case CCE_ALPHA:
        -: 8776:			case CCE_BLANK:
        -: 8777:			case CCE_CNTRL:
        -: 8778:			case CCE_DIGIT:
        -: 8779:			case CCE_GRAPH:
        -: 8780:			case CCE_LOWER:
        -: 8781:			case CCE_PRINT:
        -: 8782:			case CCE_PUNCT:
        -: 8783:			case CCE_SPACE:
        -: 8784:			case CCE_UPPER:
        -: 8785:			case CCE_XDIGIT:
    #####: 8786:				fprintf( err, "%s", yytext );
call    0 never executed
    #####: 8787:				break;
        -: 8788:
       17: 8789:			case 0:
       17: 8790:				fprintf( err, _( "End Marker\n" ) );
call    0 returned 17
       17: 8791:				break;
        -: 8792:
    #####: 8793:			default:
    #####: 8794:				fprintf( err,
call    0 never executed
        -: 8795:				_( "*Something Weird* - tok: %d val: %d\n" ),
        -: 8796:					toktype, yylval );
    #####: 8797:				break;
        -: 8798:			}
        -: 8799:		}
        -: 8800:
    31314: 8801:	return toktype;
        -: 8802:	}
        -: 8803:
        -: 8804:/*  A Bison parser, made from ./parse.y
        -: 8805:    by GNU Bison version 1.28  */
        -: 8806:
        -: 8807:#define YYBISON 1  /* Identify Bison output.  */
        -: 8808:
        -: 8809:#define	CHAR	257
        -: 8810:#define	NUMBER	258
        -: 8811:#define	SECTEND	259
        -: 8812:#define	SCDECL	260
        -: 8813:#define	XSCDECL	261
        -: 8814:#define	NAME	262
        -: 8815:#define	PREVCCL	263
        -: 8816:#define	EOF_OP	264
        -: 8817:#define	OPTION_OP	265
        -: 8818:#define	OPT_OUTFILE	266
        -: 8819:#define	OPT_PREFIX	267
        -: 8820:#define	OPT_YYCLASS	268
        -: 8821:#define	CCE_ALNUM	269
        -: 8822:#define	CCE_ALPHA	270
        -: 8823:#define	CCE_BLANK	271
        -: 8824:#define	CCE_CNTRL	272
        -: 8825:#define	CCE_DIGIT	273
        -: 8826:#define	CCE_GRAPH	274
        -: 8827:#define	CCE_LOWER	275
        -: 8828:#define	CCE_PRINT	276
        -: 8829:#define	CCE_PUNCT	277
        -: 8830:#define	CCE_SPACE	278
        -: 8831:#define	CCE_UPPER	279
        -: 8832:#define	CCE_XDIGIT	280
        -: 8833:
        -: 8834:
        -: 8835:/*-
        -: 8836: * Copyright (c) 1990 The Regents of the University of California.
        -: 8837: * All rights reserved.
        -: 8838: *
        -: 8839: * This code is derived from software contributed to Berkeley by
        -: 8840: * Vern Paxson.
        -: 8841: * 
        -: 8842: * The United States Government has rights in this work pursuant
        -: 8843: * to contract no. DE-AC03-76SF00098 between the United States
        -: 8844: * Department of Energy and the University of California.
        -: 8845: *
        -: 8846: * Redistribution and use in source and binary forms with or without
        -: 8847: * modification are permitted provided that: (1) source distributions retain
        -: 8848: * this entire copyright notice and comment, and (2) distributions including
        -: 8849: * binaries display the following acknowledgement:  ``This product includes
        -: 8850: * software developed by the University of California, Berkeley and its
        -: 8851: * contributors'' in the documentation or other materials provided with the
        -: 8852: * distribution and in all advertising materials mentioning features or use
        -: 8853: * of this software.  Neither the name of the University nor the names of
        -: 8854: * its contributors may be used to endorse or promote products derived from
        -: 8855: * this software without specific prior written permission.
        -: 8856: * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
        -: 8857: * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
        -: 8858: * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
        -: 8859: */
        -: 8860:
        -: 8861:/* $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.seeded/v5/flex.c,v 1.1.1.2 2003/09/02 20:22:00 expsir Exp $ */
        -: 8862:
        -: 8863:
        -: 8864:/* Some versions of bison are broken in that they use alloca() but don't
        -: 8865: * declare it properly.  The following is the patented (just kidding!)
        -: 8866: * #ifdef chud to fix the problem, courtesy of Francois Pinard.
        -: 8867: */
        -: 8868:#ifdef YYBISON
        -: 8869:/* AIX requires this to be the first thing in the file.  What a piece.  */
        -: 8870:# ifdef _AIX
        -: 8871: #pragma alloca
        -: 8872:# endif
        -: 8873:#endif
        -: 8874:
        -: 8875:
        -: 8876:/* The remainder of the alloca() cruft has to come after including flexdef.h,
        -: 8877: * so HAVE_ALLOCA_H is (possibly) defined.
        -: 8878: */
        -: 8879:#ifdef YYBISON
        -: 8880:# ifdef __GNUC__
        -: 8881:#  ifndef alloca
        -: 8882:#   define alloca __builtin_alloca
        -: 8883:#  endif
        -: 8884:# else
        -: 8885:#  if HAVE_ALLOCA_H
        -: 8886:#   include <alloca.h>
        -: 8887:#  else
        -: 8888:#   ifdef __hpux
        -: 8889:void *alloca ();
        -: 8890:#   else
        -: 8891:#    ifdef __TURBOC__
        -: 8892:#     include <malloc.h>
        -: 8893:#    else
        -: 8894:char *alloca ();
        -: 8895:#    endif
        -: 8896:#   endif
        -: 8897:#  endif
        -: 8898:# endif
        -: 8899:#endif
        -: 8900:
        -: 8901:/* Bletch, ^^^^ that was ugly! */
        -: 8902:
        -: 8903:
        -: 8904:int pat, scnum, eps, headcnt, trailcnt, anyccl, lastchar, i, rulelen;
        -: 8905:int trlcontxt, xcluflg, currccl, cclsorted, varlength, variable_trail_rule;
        -: 8906:
        -: 8907:int *scon_stk;
        -: 8908:int scon_stk_ptr;
        -: 8909:
        -: 8910:static int madeany = false;  /* whether we've made the '.' character class */
        -: 8911:int previous_continued_action;	/* whether the previous rule's action was '|' */
        -: 8912:
        -: 8913:/* Expand a POSIX character class expression. */
        -: 8914:#define CCL_EXPR(func) \
        -: 8915:	{ \
        -: 8916:	int c; \
        -: 8917:	for ( c = 0; c < csize; ++c ) \
        -: 8918:		if ( isascii(c) && func(c) ) \
        -: 8919:			ccladd( currccl, c ); \
        -: 8920:	}
        -: 8921:
        -: 8922:/* While POSIX defines isblank(), it's not ANSI C. */
        -: 8923:#define IS_BLANK(c) ((c) == ' ' || (c) == '\t')
        -: 8924:
        -: 8925:/* On some over-ambitious machines, such as DEC Alpha's, the default
        -: 8926: * token type is "long" instead of "int"; this leads to problems with
        -: 8927: * declaring yylval in flexdef.h.  But so far, all the yacc's I've seen
        -: 8928: * wrap their definitions of YYSTYPE with "#ifndef YYSTYPE"'s, so the
        -: 8929: * following should ensure that the default token type is "int".
        -: 8930: */
        -: 8931:#define YYSTYPE int
        -: 8932:
        -: 8933:#ifndef YYSTYPE
        -: 8934:#define YYSTYPE int
        -: 8935:#endif
        -: 8936:#include <stdio.h>
        -: 8937:
        -: 8938:#ifndef __cplusplus
        -: 8939:#ifndef __STDC__
        -: 8940:#define const
        -: 8941:#endif
        -: 8942:#endif
        -: 8943:
        -: 8944:
        -: 8945:
        -: 8946:#define	YYFINAL		107
        -: 8947:#define	YYFLAG		-32768
        -: 8948:#define	YYNTBASE	48
        -: 8949:
        -: 8950:#define YYTRANSLATE(x) ((unsigned)(x) <= 280 ? yytranslate[x] : 73)
        -: 8951:
        -: 8952:static const char yytranslate[] = {     0,
        -: 8953:     2,     2,     2,     2,     2,     2,     2,     2,     2,    28,
        -: 8954:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 8955:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 8956:     2,     2,     2,    42,     2,    36,     2,     2,     2,    43,
        -: 8957:    44,    34,    39,    35,    47,    41,    38,     2,     2,     2,
        -: 8958:     2,     2,     2,     2,     2,     2,     2,     2,     2,    32,
        -: 8959:    27,    33,    40,     2,     2,     2,     2,     2,     2,     2,
        -: 8960:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 8961:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 8962:    45,     2,    46,    31,     2,     2,     2,     2,     2,     2,
        -: 8963:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 8964:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 8965:     2,     2,    29,    37,    30,     2,     2,     2,     2,     2,
        -: 8966:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 8967:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 8968:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 8969:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 8970:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 8971:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 8972:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 8973:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 8974:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 8975:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 8976:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 8977:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 8978:     2,     2,     2,     2,     2,     1,     3,     4,     5,     6,
        -: 8979:     7,     8,     9,    10,    11,    12,    13,    14,    15,    16,
        -: 8980:    17,    18,    19,    20,    21,    22,    23,    24,    25,    26
        -: 8981:};
        -: 8982:
        -: 8983:#if YYDEBUG != 0
        -: 8984:static const short yyprhs[] = {     0,
        -: 8985:     0,     6,     7,    11,    14,    15,    17,    19,    21,    23,
        -: 8986:    26,    28,    30,    33,    36,    37,    41,    45,    49,    55,
        -: 8987:    61,    62,    63,    66,    68,    70,    72,    73,    78,    82,
        -: 8988:    83,    87,    89,    91,    93,    96,   100,   103,   105,   109,
        -: 8989:   111,   114,   117,   119,   122,   125,   128,   135,   141,   146,
        -: 8990:   148,   150,   152,   156,   160,   162,   166,   171,   176,   179,
        -: 8991:   182,   183,   185,   187,   189,   191,   193,   195,   197,   199,
        -: 8992:   201,   203,   205,   207,   210
        -: 8993:};
        -: 8994:
        -: 8995:static const short yyrhs[] = {    49,
        -: 8996:    50,    51,    57,    58,     0,     0,    50,    52,    53,     0,
        -: 8997:    50,    54,     0,     0,     1,     0,     5,     0,     6,     0,
        -: 8998:     7,     0,    53,     8,     0,     8,     0,     1,     0,    11,
        -: 8999:    55,     0,    55,    56,     0,     0,    12,    27,     8,     0,
        -: 9000:    13,    27,     8,     0,    14,    27,     8,     0,    57,    61,
        -: 9001:    58,    59,    28,     0,    57,    61,    29,    57,    30,     0,
        -: 9002:     0,     0,    31,    64,     0,    64,     0,    10,     0,     1,
        -: 9003:     0,     0,    32,    60,    62,    33,     0,    32,    34,    33,
        -: 9004:     0,     0,    62,    35,    63,     0,    63,     0,     1,     0,
        -: 9005:     8,     0,    66,    65,     0,    66,    65,    36,     0,    65,
        -: 9006:    36,     0,    65,     0,    65,    37,    67,     0,    67,     0,
        -: 9007:    65,    38,     0,    67,    68,     0,    68,     0,    68,    34,
        -: 9008:     0,    68,    39,     0,    68,    40,     0,    68,    29,     4,
        -: 9009:    35,     4,    30,     0,    68,    29,     4,    35,    30,     0,
        -: 9010:    68,    29,     4,    30,     0,    41,     0,    69,     0,     9,
        -: 9011:     0,    42,    72,    42,     0,    43,    65,    44,     0,     3,
        -: 9012:     0,    45,    70,    46,     0,    45,    31,    70,    46,     0,
        -: 9013:    70,     3,    47,     3,     0,    70,     3,     0,    70,    71,
        -: 9014:     0,     0,    15,     0,    16,     0,    17,     0,    18,     0,
        -: 9015:    19,     0,    20,     0,    21,     0,    22,     0,    23,     0,
        -: 9016:    24,     0,    25,     0,    26,     0,    72,     3,     0,     0
        -: 9017:};
        -: 9018:
        -: 9019:#endif
        -: 9020:
        -: 9021:#if YYDEBUG != 0
        -: 9022:static const short yyrline[] = { 0,
        -: 9023:   112,   141,   149,   150,   151,   152,   156,   164,   167,   171,
        -: 9024:   174,   177,   181,   184,   185,   188,   193,   195,   199,   201,
        -: 9025:   203,   206,   219,   255,   279,   302,   306,   310,   313,   330,
        -: 9026:   334,   336,   338,   342,   365,   420,   423,   466,   484,   490,
        -: 9027:   495,   522,   530,   534,   541,   547,   553,   581,   595,   614,
        -: 9028:   636,   654,   661,   664,   667,   678,   681,   688,   716,   727,
        -: 9029:   734,   742,   743,   744,   745,   746,   747,   748,   749,   750,
        -: 9030:   751,   752,   758,   761,   771
        -: 9031:};
        -: 9032:#endif
        -: 9033:
        -: 9034:
        -: 9035:#if YYDEBUG != 0 || defined (YYERROR_VERBOSE)
        -: 9036:
        -: 9037:static const char * const yytname[] = {   "$","error","$undefined.","CHAR","NUMBER",
        -: 9038:"SECTEND","SCDECL","XSCDECL","NAME","PREVCCL","EOF_OP","OPTION_OP","OPT_OUTFILE",
        -: 9039:"OPT_PREFIX","OPT_YYCLASS","CCE_ALNUM","CCE_ALPHA","CCE_BLANK","CCE_CNTRL","CCE_DIGIT",
        -: 9040:"CCE_GRAPH","CCE_LOWER","CCE_PRINT","CCE_PUNCT","CCE_SPACE","CCE_UPPER","CCE_XDIGIT",
        -: 9041:"'='","'\\n'","'{'","'}'","'^'","'<'","'>'","'*'","','","'$'","'|'","'/'","'+'",
        -: 9042:"'?'","'.'","'\\\"'","'('","')'","'['","']'","'-'","goal","initlex","sect1",
        -: 9043:"sect1end","startconddecl","namelist1","options","optionlist","option","sect2",
        -: 9044:"initforrule","flexrule","scon_stk_ptr","scon","namelist2","sconname","rule",
        -: 9045:"re","re2","series","singleton","fullccl","ccl","ccl_expr","string", NULL
        -: 9046:};
        -: 9047:#endif
        -: 9048:
        -: 9049:static const short yyr1[] = {     0,
        -: 9050:    48,    49,    50,    50,    50,    50,    51,    52,    52,    53,
        -: 9051:    53,    53,    54,    55,    55,    56,    56,    56,    57,    57,
        -: 9052:    57,    58,    59,    59,    59,    59,    60,    61,    61,    61,
        -: 9053:    62,    62,    62,    63,    64,    64,    64,    64,    65,    65,
        -: 9054:    66,    67,    67,    68,    68,    68,    68,    68,    68,    68,
        -: 9055:    68,    68,    68,    68,    68,    69,    69,    70,    70,    70,
        -: 9056:    70,    71,    71,    71,    71,    71,    71,    71,    71,    71,
        -: 9057:    71,    71,    71,    72,    72
        -: 9058:};
        -: 9059:
        -: 9060:static const short yyr2[] = {     0,
        -: 9061:     5,     0,     3,     2,     0,     1,     1,     1,     1,     2,
        -: 9062:     1,     1,     2,     2,     0,     3,     3,     3,     5,     5,
        -: 9063:     0,     0,     2,     1,     1,     1,     0,     4,     3,     0,
        -: 9064:     3,     1,     1,     1,     2,     3,     2,     1,     3,     1,
        -: 9065:     2,     2,     1,     2,     2,     2,     6,     5,     4,     1,
        -: 9066:     1,     1,     3,     3,     1,     3,     4,     4,     2,     2,
        -: 9067:     0,     1,     1,     1,     1,     1,     1,     1,     1,     1,
        -: 9068:     1,     1,     1,     2,     0
        -: 9069:};
        -: 9070:
        -: 9071:static const short yydefact[] = {     2,
        -: 9072:     0,     6,     0,     7,     8,     9,    15,    21,     0,     4,
        -: 9073:    13,    30,    12,    11,     3,     0,     0,     0,    14,    27,
        -: 9074:     1,    22,    10,     0,     0,     0,     0,     0,    21,     0,
        -: 9075:    16,    17,    18,    29,    33,    34,     0,    32,    30,    26,
        -: 9076:    55,    52,    25,     0,    50,    75,     0,    61,     0,    24,
        -: 9077:    38,     0,    40,    43,    51,    28,     0,    20,    23,     0,
        -: 9078:     0,    61,     0,    19,    37,     0,    41,    35,    42,     0,
        -: 9079:    44,    45,    46,    31,    74,    53,    54,     0,    59,    62,
        -: 9080:    63,    64,    65,    66,    67,    68,    69,    70,    71,    72,
        -: 9081:    73,    56,    60,    39,    36,     0,    57,     0,    49,     0,
        -: 9082:    58,     0,    48,    47,     0,     0,     0
        -: 9083:};
        -: 9084:
        -: 9085:static const short yydefgoto[] = {   105,
        -: 9086:     1,     3,     8,     9,    15,    10,    11,    19,    12,    21,
        -: 9087:    49,    28,    22,    37,    38,    50,    51,    52,    53,    54,
        -: 9088:    55,    63,    93,    60
        -: 9089:};
        -: 9090:
        -: 9091:static const short yypact[] = {-32768,
        -: 9092:    78,-32768,    81,-32768,-32768,-32768,-32768,-32768,     6,-32768,
        -: 9093:    -2,     5,-32768,-32768,    -7,   -14,     1,     9,-32768,    28,
        -: 9094:-32768,    14,-32768,    55,    65,    74,    57,    30,-32768,    -1,
        -: 9095:-32768,-32768,-32768,-32768,-32768,-32768,    58,-32768,    44,-32768,
        -: 9096:-32768,-32768,-32768,    24,-32768,-32768,    24,    63,    69,-32768,
        -: 9097:    23,    24,    24,    41,-32768,-32768,    90,-32768,-32768,    26,
        -: 9098:    27,-32768,     0,-32768,-32768,    24,-32768,    59,    41,    95,
        -: 9099:-32768,-32768,-32768,-32768,-32768,-32768,-32768,    32,    53,-32768,
        -: 9100:-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
        -: 9101:-32768,-32768,-32768,    24,-32768,     4,-32768,    98,-32768,     2,
        -: 9102:-32768,    72,-32768,-32768,   103,   104,-32768
        -: 9103:};
        -: 9104:
        -: 9105:static const short yypgoto[] = {-32768,
        -: 9106:-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,    76,    84,
        -: 9107:-32768,-32768,-32768,-32768,    50,    64,    25,-32768,    43,   -49,
        -: 9108:-32768,    48,-32768,-32768
        -: 9109:};
        -: 9110:
        -: 9111:
        -: 9112:#define	YYLAST		110
        -: 9113:
        -: 9114:
        -: 9115:static const short yytable[] = {    40,
        -: 9116:    23,    41,    79,    69,   -22,   102,    13,    42,    43,    16,
        -: 9117:    17,    18,    24,    14,    80,    81,    82,    83,    84,    85,
        -: 9118:    86,    87,    88,    89,    90,    91,    41,    25,    75,    44,
        -: 9119:    35,   103,    42,    99,    79,    26,    20,    36,   100,    45,
        -: 9120:    46,    47,    29,    48,    69,    92,    80,    81,    82,    83,
        -: 9121:    84,    85,    86,    87,    88,    89,    90,    91,    65,    66,
        -: 9122:    67,    27,    31,    66,    45,    46,    47,    76,    48,    70,
        -: 9123:    77,    61,    32,    58,    71,    20,    68,    97,     2,    72,
        -: 9124:    73,    33,    -5,    -5,    -5,     4,     5,     6,    -5,    34,
        -: 9125:    56,     7,    57,    62,    95,    66,    64,    36,    96,    98,
        -: 9126:   101,   104,   106,   107,    39,    30,    74,    59,    94,    78
        -: 9127:};
        -: 9128:
        -: 9129:static const short yycheck[] = {     1,
        -: 9130:     8,     3,     3,    53,     0,     4,     1,     9,    10,    12,
        -: 9131:    13,    14,    27,     8,    15,    16,    17,    18,    19,    20,
        -: 9132:    21,    22,    23,    24,    25,    26,     3,    27,     3,    31,
        -: 9133:     1,    30,     9,    30,     3,    27,    32,     8,    35,    41,
        -: 9134:    42,    43,    29,    45,    94,    46,    15,    16,    17,    18,
        -: 9135:    19,    20,    21,    22,    23,    24,    25,    26,    36,    37,
        -: 9136:    38,    34,     8,    37,    41,    42,    43,    42,    45,    29,
        -: 9137:    44,    47,     8,    30,    34,    32,    52,    46,     1,    39,
        -: 9138:    40,     8,     5,     6,     7,     5,     6,     7,    11,    33,
        -: 9139:    33,    11,    35,    31,    36,    37,    28,     8,     4,    47,
        -: 9140:     3,    30,     0,     0,    29,    22,    57,    44,    66,    62
        -: 9141:};
        -: 9142:/* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
        -: 9143:/* This file comes from bison-1.28.  */
        -: 9144:
        -: 9145:/* Skeleton output parser for bison,
        -: 9146:   Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.
        -: 9147:
        -: 9148:   This program is free software; you can redistribute it and/or modify
        -: 9149:   it under the terms of the GNU General Public License as published by
        -: 9150:   the Free Software Foundation; either version 2, or (at your option)
        -: 9151:   any later version.
        -: 9152:
        -: 9153:   This program is distributed in the hope that it will be useful,
        -: 9154:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 9155:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 9156:   GNU General Public License for more details.
        -: 9157:
        -: 9158:   You should have received a copy of the GNU General Public License
        -: 9159:   along with this program; if not, write to the Free Software
        -: 9160:   Foundation, Inc., 59 Temple Place - Suite 330,
        -: 9161:   Boston, MA 02111-1307, USA.  */
        -: 9162:
        -: 9163:/* As a special exception, when this file is copied by Bison into a
        -: 9164:   Bison output file, you may use that output file without restriction.
        -: 9165:   This special exception was added by the Free Software Foundation
        -: 9166:   in version 1.24 of Bison.  */
        -: 9167:
        -: 9168:/* This is the parser code that is written into each bison parser
        -: 9169:  when the %semantic_parser declaration is not specified in the grammar.
        -: 9170:  It was written by Richard Stallman by simplifying the hairy parser
        -: 9171:  used when %semantic_parser is specified.  */
        -: 9172:
        -: 9173:#ifndef YYSTACK_USE_ALLOCA
        -: 9174:#ifdef alloca
        -: 9175:#define YYSTACK_USE_ALLOCA
        -: 9176:#else /* alloca not defined */
        -: 9177:#ifdef __GNUC__
        -: 9178:#define YYSTACK_USE_ALLOCA
        -: 9179:#define alloca __builtin_alloca
        -: 9180:#else /* not GNU C.  */
        -: 9181:#if (!defined (__STDC__) && defined (sparc)) || defined (__sparc__) || defined (__sparc) || defined (__sgi) || (defined (__sun) && defined (__i386))
        -: 9182:#define YYSTACK_USE_ALLOCA
        -: 9183:#include <alloca.h>
        -: 9184:#else /* not sparc */
        -: 9185:/* We think this test detects Watcom and Microsoft C.  */
        -: 9186:/* This used to test MSDOS, but that is a bad idea
        -: 9187:   since that symbol is in the user namespace.  */
        -: 9188:#if (defined (_MSDOS) || defined (_MSDOS_)) && !defined (__TURBOC__)
        -: 9189:#if 0 /* No need for malloc.h, which pollutes the namespace;
        -: 9190:	 instead, just don't use alloca.  */
        -: 9191:#include <malloc.h>
        -: 9192:#endif
        -: 9193:#else /* not MSDOS, or __TURBOC__ */
        -: 9194:#if defined(_AIX)
        -: 9195:/* I don't know what this was needed for, but it pollutes the namespace.
        -: 9196:   So I turned it off.   rms, 2 May 1997.  */
        -: 9197:/* #include <malloc.h>  */
        -: 9198: #pragma alloca
        -: 9199:#define YYSTACK_USE_ALLOCA
        -: 9200:#else /* not MSDOS, or __TURBOC__, or _AIX */
        -: 9201:#if 0
        -: 9202:#ifdef __hpux /* haible@ilog.fr says this works for HPUX 9.05 and up,
        -: 9203:		 and on HPUX 10.  Eventually we can turn this on.  */
        -: 9204:#define YYSTACK_USE_ALLOCA
        -: 9205:#define alloca __builtin_alloca
        -: 9206:#endif /* __hpux */
        -: 9207:#endif
        -: 9208:#endif /* not _AIX */
        -: 9209:#endif /* not MSDOS, or __TURBOC__ */
        -: 9210:#endif /* not sparc */
        -: 9211:#endif /* not GNU C */
        -: 9212:#endif /* alloca not defined */
        -: 9213:#endif /* YYSTACK_USE_ALLOCA not defined */
        -: 9214:
        -: 9215:#ifdef YYSTACK_USE_ALLOCA
        -: 9216:#define YYSTACK_ALLOC alloca
        -: 9217:#else
        -: 9218:#define YYSTACK_ALLOC malloc
        -: 9219:#endif
        -: 9220:
        -: 9221:/* Note: there must be only one dollar sign in this file.
        -: 9222:   It is replaced by the list of actions, each action
        -: 9223:   as one case of the switch.  */
        -: 9224:
        -: 9225:#define yyerrok		(yyerrstatus = 0)
        -: 9226:#define yyclearin	(yychar = YYEMPTY)
        -: 9227:#define YYEMPTY		-2
        -: 9228:#define YYEOF		0
        -: 9229:#define YYACCEPT	goto yyacceptlab
        -: 9230:#define YYABORT 	goto yyabortlab
        -: 9231:#define YYERROR		goto yyerrlab1
        -: 9232:/* Like YYERROR except do call yyerror.
        -: 9233:   This remains here temporarily to ease the
        -: 9234:   transition to the new meaning of YYERROR, for GCC.
        -: 9235:   Once GCC version 2 has supplanted version 1, this can go.  */
        -: 9236:#define YYFAIL		goto yyerrlab
        -: 9237:#define YYRECOVERING()  (!!yyerrstatus)
        -: 9238:#define YYBACKUP(token, value) \
        -: 9239:do								\
        -: 9240:  if (yychar == YYEMPTY && yylen == 1)				\
        -: 9241:    { yychar = (token), yylval = (value);			\
        -: 9242:      yychar1 = YYTRANSLATE (yychar);				\
        -: 9243:      YYPOPSTACK;						\
        -: 9244:      goto yybackup;						\
        -: 9245:    }								\
        -: 9246:  else								\
        -: 9247:    { yyerror ("syntax error: cannot back up"); YYERROR; }	\
        -: 9248:while (0)
        -: 9249:
        -: 9250:#define YYTERROR	1
        -: 9251:#define YYERRCODE	256
        -: 9252:
        -: 9253:#ifndef YYPURE
        -: 9254:#define YYLEX		yylex()
        -: 9255:#endif
        -: 9256:
        -: 9257:#ifdef YYPURE
        -: 9258:#ifdef YYLSP_NEEDED
        -: 9259:#ifdef YYLEX_PARAM
        -: 9260:#define YYLEX		yylex(&yylval, &yylloc, YYLEX_PARAM)
        -: 9261:#else
        -: 9262:#define YYLEX		yylex(&yylval, &yylloc)
        -: 9263:#endif
        -: 9264:#else /* not YYLSP_NEEDED */
        -: 9265:#ifdef YYLEX_PARAM
        -: 9266:#define YYLEX		yylex(&yylval, YYLEX_PARAM)
        -: 9267:#else
        -: 9268:#define YYLEX		yylex(&yylval)
        -: 9269:#endif
        -: 9270:#endif /* not YYLSP_NEEDED */
        -: 9271:#endif
        -: 9272:
        -: 9273:/* If nonreentrant, generate the variables here */
        -: 9274:
        -: 9275:#ifndef YYPURE
        -: 9276:
        -: 9277:int	yychar;			/*  the lookahead symbol		*/
        -: 9278:YYSTYPE	yylval;			/*  the semantic value of the		*/
        -: 9279:				/*  lookahead symbol			*/
        -: 9280:
        -: 9281:#ifdef YYLSP_NEEDED
        -: 9282:YYLTYPE yylloc;			/*  location data for the lookahead	*/
        -: 9283:				/*  symbol				*/
        -: 9284:#endif
        -: 9285:
        -: 9286:int yynerrs;			/*  number of parse errors so far       */
        -: 9287:#endif  /* not YYPURE */
        -: 9288:
        -: 9289:#if YYDEBUG != 0
        -: 9290:int yydebug;			/*  nonzero means print parse trace	*/
        -: 9291:/* Since this is uninitialized, it does not stop multiple parsers
        -: 9292:   from coexisting.  */
        -: 9293:#endif
        -: 9294:
        -: 9295:/*  YYINITDEPTH indicates the initial size of the parser's stacks	*/
        -: 9296:
        -: 9297:#ifndef	YYINITDEPTH
        -: 9298:#define YYINITDEPTH 200
        -: 9299:#endif
        -: 9300:
        -: 9301:/*  YYMAXDEPTH is the maximum size the stacks can grow to
        -: 9302:    (effective only if the built-in stack extension method is used).  */
        -: 9303:
        -: 9304:#if YYMAXDEPTH == 0
        -: 9305:#undef YYMAXDEPTH
        -: 9306:#endif
        -: 9307:
        -: 9308:#ifndef YYMAXDEPTH
        -: 9309:#define YYMAXDEPTH 10000
        -: 9310:#endif
        -: 9311:/* Define __yy_memcpy.  Note that the size argument
        -: 9312:   should be passed with type unsigned int, because that is what the non-GCC
        -: 9313:   definitions require.  With GCC, __builtin_memcpy takes an arg
        -: 9314:   of type size_t, but it can handle unsigned int.  */
        -: 9315:
        -: 9316:#if __GNUC__ > 1		/* GNU C and GNU C++ define this.  */
        -: 9317:#define __yy_memcpy(TO,FROM,COUNT)	__builtin_memcpy(TO,FROM,COUNT)
        -: 9318:#else				/* not GNU C or C++ */
        -: 9319:#ifndef __cplusplus
        -: 9320:
        -: 9321:/* This is the most reliable way to avoid incompatibilities
        -: 9322:   in available built-in functions on various systems.  */
        -: 9323:static void
        -: 9324:__yy_memcpy (to, from, count)
        -: 9325:     char *to;
        -: 9326:     char *from;
        -: 9327:     unsigned int count;
        -: 9328:{
        -: 9329:  register char *f = from;
        -: 9330:  register char *t = to;
        -: 9331:  register int i = count;
        -: 9332:
        -: 9333:  while (i-- > 0)
        -: 9334:    *t++ = *f++;
        -: 9335:}
        -: 9336:
        -: 9337:#else /* __cplusplus */
        -: 9338:
        -: 9339:/* This is the most reliable way to avoid incompatibilities
        -: 9340:   in available built-in functions on various systems.  */
        -: 9341:static void
        -: 9342:__yy_memcpy (char *to, char *from, unsigned int count)
        -: 9343:{
        -: 9344:  register char *t = to;
        -: 9345:  register char *f = from;
        -: 9346:  register int i = count;
        -: 9347:
        -: 9348:  while (i-- > 0)
        -: 9349:    *t++ = *f++;
        -: 9350:}
        -: 9351:
        -: 9352:#endif
        -: 9353:#endif
        -: 9354:
        -: 9355:/* The user can define YYPARSE_PARAM as the name of an argument to be passed
        -: 9356:   into yyparse.  The argument should have type void *.
        -: 9357:   It should actually point to an object.
        -: 9358:   Grammar actions can access the variable by casting it
        -: 9359:   to the proper pointer type.  */
        -: 9360:
        -: 9361:#ifdef YYPARSE_PARAM
        -: 9362:#ifdef __cplusplus
        -: 9363:#define YYPARSE_PARAM_ARG void *YYPARSE_PARAM
        -: 9364:#define YYPARSE_PARAM_DECL
        -: 9365:#else /* not __cplusplus */
        -: 9366:#define YYPARSE_PARAM_ARG YYPARSE_PARAM
        -: 9367:#define YYPARSE_PARAM_DECL void *YYPARSE_PARAM;
        -: 9368:#endif /* not __cplusplus */
        -: 9369:#else /* not YYPARSE_PARAM */
        -: 9370:#define YYPARSE_PARAM_ARG
        -: 9371:#define YYPARSE_PARAM_DECL
        -: 9372:#endif /* not YYPARSE_PARAM */
        -: 9373:
        -: 9374:/* Prevent warning if -Wstrict-prototypes.  */
        -: 9375:#ifdef __GNUC__
        -: 9376:#ifdef YYPARSE_PARAM
        -: 9377:int yyparse (void *);
        -: 9378:#else
        -: 9379:int yyparse (void);
        -: 9380:#endif
        -: 9381:#endif
        -: 9382:
        -: 9383:int
function yyparse called 560 returned 99% blocks executed 61%
      560: 9384:yyparse(YYPARSE_PARAM_ARG)
        -: 9385:     YYPARSE_PARAM_DECL
        -: 9386:{
        -: 9387:  register int yystate;
        -: 9388:  register int yyn;
        -: 9389:  register short *yyssp;
        -: 9390:  register YYSTYPE *yyvsp;
        -: 9391:  int yyerrstatus;	/*  number of tokens to shift before error messages enabled */
      560: 9392:  int yychar1 = 0;		/*  lookahead token as an internal (translated) token number */
        -: 9393:
        -: 9394:  short	yyssa[YYINITDEPTH];	/*  the state stack			*/
        -: 9395:  YYSTYPE yyvsa[YYINITDEPTH];	/*  the semantic value stack		*/
        -: 9396:
      560: 9397:  short *yyss = yyssa;		/*  refer to the stacks thru separate pointers */
      560: 9398:  YYSTYPE *yyvs = yyvsa;	/*  to allow yyoverflow to reallocate them elsewhere */
        -: 9399:
        -: 9400:#ifdef YYLSP_NEEDED
        -: 9401:  YYLTYPE yylsa[YYINITDEPTH];	/*  the location stack			*/
        -: 9402:  YYLTYPE *yyls = yylsa;
        -: 9403:  YYLTYPE *yylsp;
        -: 9404:
        -: 9405:#define YYPOPSTACK   (yyvsp--, yyssp--, yylsp--)
        -: 9406:#else
        -: 9407:#define YYPOPSTACK   (yyvsp--, yyssp--)
        -: 9408:#endif
        -: 9409:
      560: 9410:  int yystacksize = YYINITDEPTH;
      560: 9411:  int yyfree_stacks = 0;
        -: 9412:
        -: 9413:#ifdef YYPURE
        -: 9414:  int yychar;
        -: 9415:  YYSTYPE yylval;
        -: 9416:  int yynerrs;
        -: 9417:#ifdef YYLSP_NEEDED
        -: 9418:  YYLTYPE yylloc;
        -: 9419:#endif
        -: 9420:#endif
        -: 9421:
        -: 9422:  YYSTYPE yyval;		/*  the variable used to return		*/
        -: 9423:				/*  semantic values from the action	*/
        -: 9424:				/*  routines				*/
        -: 9425:
        -: 9426:  int yylen;
        -: 9427:
        -: 9428:#if YYDEBUG != 0
        -: 9429:  if (yydebug)
        -: 9430:    fprintf(err, "Starting parse\n");
        -: 9431:#endif
        -: 9432:
      560: 9433:  yystate = 0;
      560: 9434:  yyerrstatus = 0;
      560: 9435:  yynerrs = 0;
      560: 9436:  yychar = YYEMPTY;		/* Cause a token to be read.  */
        -: 9437:
        -: 9438:  /* Initialize stack pointers.
        -: 9439:     Waste one element of value and location stack
        -: 9440:     so that they stay on the same level as the state stack.
        -: 9441:     The wasted elements are never initialized.  */
        -: 9442:
      560: 9443:  yyssp = yyss - 1;
      560: 9444:  yyvsp = yyvs;
        -: 9445:#ifdef YYLSP_NEEDED
        -: 9446:  yylsp = yyls;
        -: 9447:#endif
        -: 9448:
        -: 9449:/* Push a new state, which is found in  yystate  .  */
        -: 9450:/* In all cases, when you get here, the value and location stacks
        -: 9451:   have just been pushed. so pushing a state here evens the stacks.  */
    93801: 9452:yynewstate:
        -: 9453:
    93801: 9454:  *++yyssp = yystate;
        -: 9455:
    93801: 9456:  if (yyssp >= yyss + yystacksize - 1)
branch  0 taken 0 (fallthrough)
branch  1 taken 93801
        -: 9457:    {
        -: 9458:      /* Give user a chance to reallocate the stack */
        -: 9459:      /* Use copies of these so that the &'s don't force the real ones into memory. */
    #####: 9460:      YYSTYPE *yyvs1 = yyvs;
    #####: 9461:      short *yyss1 = yyss;
        -: 9462:#ifdef YYLSP_NEEDED
        -: 9463:      YYLTYPE *yyls1 = yyls;
        -: 9464:#endif
        -: 9465:
        -: 9466:      /* Get the current used size of the three stacks, in elements.  */
    #####: 9467:      int size = yyssp - yyss + 1;
        -: 9468:
        -: 9469:#ifdef yyoverflow
        -: 9470:      /* Each stack pointer address is followed by the size of
        -: 9471:	 the data in use in that stack, in bytes.  */
        -: 9472:#ifdef YYLSP_NEEDED
        -: 9473:      /* This used to be a conditional around just the two extra args,
        -: 9474:	 but that might be undefined if yyoverflow is a macro.  */
        -: 9475:      yyoverflow("parser stack overflow",
        -: 9476:		 &yyss1, size * sizeof (*yyssp),
        -: 9477:		 &yyvs1, size * sizeof (*yyvsp),
        -: 9478:		 &yyls1, size * sizeof (*yylsp),
        -: 9479:		 &yystacksize);
        -: 9480:#else
        -: 9481:      yyoverflow("parser stack overflow",
        -: 9482:		 &yyss1, size * sizeof (*yyssp),
        -: 9483:		 &yyvs1, size * sizeof (*yyvsp),
        -: 9484:		 &yystacksize);
        -: 9485:#endif
        -: 9486:
        -: 9487:      yyss = yyss1; yyvs = yyvs1;
        -: 9488:#ifdef YYLSP_NEEDED
        -: 9489:      yyls = yyls1;
        -: 9490:#endif
        -: 9491:#else /* no yyoverflow */
        -: 9492:      /* Extend the stack our own way.  */
    #####: 9493:      if (yystacksize >= YYMAXDEPTH)
branch  0 never executed
branch  1 never executed
        -: 9494:	{
    #####: 9495:	  yyerror("parser stack overflow");
call    0 never executed
    #####: 9496:	  if (yyfree_stacks)
branch  0 never executed
branch  1 never executed
        -: 9497:	    {
    #####: 9498:	      free (yyss);
    #####: 9499:	      free (yyvs);
        -: 9500:#ifdef YYLSP_NEEDED
        -: 9501:	      free (yyls);
        -: 9502:#endif
        -: 9503:	    }
    #####: 9504:	  return 2;
        -: 9505:	}
    #####: 9506:      yystacksize *= 2;
    #####: 9507:      if (yystacksize > YYMAXDEPTH)
branch  0 never executed
branch  1 never executed
    #####: 9508:	yystacksize = YYMAXDEPTH;
        -: 9509:#ifndef YYSTACK_USE_ALLOCA
        -: 9510:      yyfree_stacks = 1;
        -: 9511:#endif
    #####: 9512:      yyss = (short *) YYSTACK_ALLOC (yystacksize * sizeof (*yyssp));
    #####: 9513:      __yy_memcpy ((char *)yyss, (char *)yyss1,
        -: 9514:		   size * (unsigned int) sizeof (*yyssp));
    #####: 9515:      yyvs = (YYSTYPE *) YYSTACK_ALLOC (yystacksize * sizeof (*yyvsp));
    #####: 9516:      __yy_memcpy ((char *)yyvs, (char *)yyvs1,
        -: 9517:		   size * (unsigned int) sizeof (*yyvsp));
        -: 9518:#ifdef YYLSP_NEEDED
        -: 9519:      yyls = (YYLTYPE *) YYSTACK_ALLOC (yystacksize * sizeof (*yylsp));
        -: 9520:      __yy_memcpy ((char *)yyls, (char *)yyls1,
        -: 9521:		   size * (unsigned int) sizeof (*yylsp));
        -: 9522:#endif
        -: 9523:#endif /* no yyoverflow */
        -: 9524:
    #####: 9525:      yyssp = yyss + size - 1;
    #####: 9526:      yyvsp = yyvs + size - 1;
        -: 9527:#ifdef YYLSP_NEEDED
        -: 9528:      yylsp = yyls + size - 1;
        -: 9529:#endif
        -: 9530:
        -: 9531:#if YYDEBUG != 0
        -: 9532:      if (yydebug)
        -: 9533:	fprintf(err, "Stack size increased to %d\n", yystacksize);
        -: 9534:#endif
        -: 9535:
    #####: 9536:      if (yyssp >= yyss + yystacksize - 1)
branch  0 never executed
branch  1 never executed
    #####: 9537:	YYABORT;
        -: 9538:    }
        -: 9539:
        -: 9540:#if YYDEBUG != 0
        -: 9541:  if (yydebug)
        -: 9542:    fprintf(err, "Entering state %d\n", yystate);
        -: 9543:#endif
        -: 9544:
    93801: 9545:  goto yybackup;
    93801: 9546: yybackup:
        -: 9547:
        -: 9548:/* Do appropriate processing given the current state.  */
        -: 9549:/* Read a lookahead token if we need one and don't already have one.  */
        -: 9550:/* yyresume: */
        -: 9551:
        -: 9552:  /* First try to decide what to do without reference to lookahead token.  */
        -: 9553:
    93801: 9554:  yyn = yypact[yystate];
    93801: 9555:  if (yyn == YYFLAG)
branch  0 taken 29029 (fallthrough)
branch  1 taken 64772
    29029: 9556:    goto yydefault;
        -: 9557:
        -: 9558:  /* Not known => get a lookahead token if don't already have one.  */
        -: 9559:
        -: 9560:  /* yychar is either YYEMPTY or YYEOF
        -: 9561:     or a valid token in external form.  */
        -: 9562:
    64772: 9563:  if (yychar == YYEMPTY)
branch  0 taken 31314 (fallthrough)
branch  1 taken 33458
        -: 9564:    {
        -: 9565:#if YYDEBUG != 0
        -: 9566:      if (yydebug)
        -: 9567:	fprintf(err, "Reading a token: ");
        -: 9568:#endif
    31314: 9569:      yychar = YYLEX;
call    0 returned 31314
        -: 9570:    }
        -: 9571:
        -: 9572:  /* Convert token to internal form (in yychar1) for indexing tables with */
        -: 9573:
    64772: 9574:  if (yychar <= 0)		/* This means end of input. */
branch  0 taken 1657 (fallthrough)
branch  1 taken 63115
        -: 9575:    {
     1657: 9576:      yychar1 = 0;
     1657: 9577:      yychar = YYEOF;		/* Don't call YYLEX any more */
        -: 9578:
        -: 9579:#if YYDEBUG != 0
        -: 9580:      if (yydebug)
        -: 9581:	fprintf(err, "Now at end of input.\n");
        -: 9582:#endif
        -: 9583:    }
        -: 9584:  else
        -: 9585:    {
   63115*: 9586:      yychar1 = YYTRANSLATE(yychar);
branch  0 taken 63115 (fallthrough)
branch  1 taken 0
        -: 9587:
        -: 9588:#if YYDEBUG != 0
        -: 9589:      if (yydebug)
        -: 9590:	{
        -: 9591:	  fprintf (err, "Next token is %d (%s", yychar, yytname[yychar1]);
        -: 9592:	  /* Give the individual parser a way to print the precise meaning
        -: 9593:	     of a token, for further debugging info.  */
        -: 9594:#ifdef YYPRINT
        -: 9595:	  YYPRINT (err, yychar, yylval);
        -: 9596:#endif
        -: 9597:	  fprintf (err, ")\n");
        -: 9598:	}
        -: 9599:#endif
        -: 9600:    }
        -: 9601:
    64772: 9602:  yyn += yychar1;
    64772: 9603:  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != yychar1)
branch  0 taken 64764 (fallthrough)
branch  1 taken 8
branch  2 taken 64762 (fallthrough)
branch  3 taken 2
branch  4 taken 31797 (fallthrough)
branch  5 taken 32965
    31807: 9604:    goto yydefault;
        -: 9605:
    32965: 9606:  yyn = yytable[yyn];
        -: 9607:
        -: 9608:  /* yyn is what to do for this token type in this state.
        -: 9609:     Negative => reduce, -yyn is rule number.
        -: 9610:     Positive => shift, yyn is new state.
        -: 9611:       New state is final state => don't bother to shift,
        -: 9612:       just return success.
        -: 9613:     0, or most negative number => error.  */
        -: 9614:
    32965: 9615:  if (yyn < 0)
branch  0 taken 1111 (fallthrough)
branch  1 taken 31854
        -: 9616:    {
     1111: 9617:      if (yyn == YYFLAG)
branch  0 taken 0 (fallthrough)
branch  1 taken 1111
    #####: 9618:	goto yyerrlab;
     1111: 9619:      yyn = -yyn;
     1111: 9620:      goto yyreduce;
        -: 9621:    }
    31854: 9622:  else if (yyn == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 31854
    #####: 9623:    goto yyerrlab;
        -: 9624:
    31854: 9625:  if (yyn == YYFINAL)
branch  0 taken 551 (fallthrough)
branch  1 taken 31303
      551: 9626:    YYACCEPT;
        -: 9627:
        -: 9628:  /* Shift the lookahead token.  */
        -: 9629:
        -: 9630:#if YYDEBUG != 0
        -: 9631:  if (yydebug)
        -: 9632:    fprintf(err, "Shifting token %d (%s), ", yychar, yytname[yychar1]);
        -: 9633:#endif
        -: 9634:
        -: 9635:  /* Discard the token being shifted unless it is eof.  */
    31303: 9636:  if (yychar != YYEOF)
branch  0 taken 30752 (fallthrough)
branch  1 taken 551
    30752: 9637:    yychar = YYEMPTY;
        -: 9638:
    31303: 9639:  *++yyvsp = yylval;
        -: 9640:#ifdef YYLSP_NEEDED
        -: 9641:  *++yylsp = yylloc;
        -: 9642:#endif
        -: 9643:
        -: 9644:  /* count tokens shifted since error; after three, turn off error status.  */
    31303: 9645:  if (yyerrstatus) yyerrstatus--;
branch  0 taken 17 (fallthrough)
branch  1 taken 31286
        -: 9646:
    31303: 9647:  yystate = yyn;
    31303: 9648:  goto yynewstate;
        -: 9649:
        -: 9650:/* Do the default action for the current state.  */
    60836: 9651:yydefault:
        -: 9652:
    60836: 9653:  yyn = yydefact[yystate];
    60836: 9654:  if (yyn == 0)
branch  0 taken 19 (fallthrough)
branch  1 taken 60817
       19: 9655:    goto yyerrlab;
        -: 9656:
        -: 9657:/* Do a reduction.  yyn is the number of a rule to reduce with.  */
    60817: 9658:yyreduce:
    61928: 9659:  yylen = yyr2[yyn];
    61928: 9660:  if (yylen > 0)
branch  0 taken 50239 (fallthrough)
branch  1 taken 11689
    50239: 9661:    yyval = yyvsp[1-yylen]; /* implement default value of the action */
        -: 9662:
        -: 9663:#if YYDEBUG != 0
        -: 9664:  if (yydebug)
        -: 9665:    {
        -: 9666:      int i;
        -: 9667:
        -: 9668:      fprintf (err, "Reducing via rule %d (line %d), ",
        -: 9669:	       yyn, yyrline[yyn]);
        -: 9670:
        -: 9671:      /* Print the symbols being reduced, and their result.  */
        -: 9672:      for (i = yyprhs[yyn]; yyrhs[i] > 0; i++)
        -: 9673:	fprintf (err, "%s ", yytname[yyrhs[i]]);
        -: 9674:      fprintf (err, " -> %s\n", yytname[yyr1[yyn]]);
        -: 9675:    }
        -: 9676:#endif
        -: 9677:
        -: 9678:
    61928: 9679:  switch (yyn) {
branch  0 taken 551
branch  1 taken 560
branch  2 taken 0
branch  3 taken 560
branch  4 taken 1
branch  5 taken 18
branch  6 taken 0
branch  7 taken 19
branch  8 taken 0
branch  9 taken 0
branch 10 taken 0
branch 11 taken 0
branch 12 taken 3533
branch 13 taken 0
branch 14 taken 4086
branch 15 taken 100
branch 16 taken 3416
branch 17 taken 11
branch 18 taken 18
branch 19 taken 13
branch 20 taken 13
branch 21 taken 3
branch 22 taken 3520
branch 23 taken 0
branch 24 taken 17
branch 25 taken 110
branch 26 taken 0
branch 27 taken 103
branch 28 taken 3303
branch 29 taken 1103
branch 30 taken 4222
branch 31 taken 111
branch 32 taken 7092
branch 33 taken 5325
branch 34 taken 846
branch 35 taken 348
branch 36 taken 4
branch 37 taken 100
branch 38 taken 98
branch 39 taken 98
branch 40 taken 214
branch 41 taken 1298
branch 42 taken 233
branch 43 taken 1098
branch 44 taken 593
branch 45 taken 8982
branch 46 taken 1079
branch 47 taken 219
branch 48 taken 880
branch 49 taken 2467
branch 50 taken 0
branch 51 taken 1298
branch 52 taken 0
branch 53 taken 0
branch 54 taken 0
branch 55 taken 0
branch 56 taken 0
branch 57 taken 0
branch 58 taken 0
branch 59 taken 0
branch 60 taken 0
branch 61 taken 0
branch 62 taken 0
branch 63 taken 0
branch 64 taken 2017
branch 65 taken 1098
branch 66 taken 1150
        -: 9680:
      551: 9681:case 1:
        -: 9682:{ /* add default rule */
        -: 9683:			int def_rule;
        -: 9684:
      551: 9685:			pat = cclinit();
call    0 returned 551
      551: 9686:			cclnegate( pat );
call    0 returned 551
        -: 9687:
      551: 9688:			def_rule = mkstate( -pat );
call    0 returned 551
        -: 9689:
        -: 9690:			/* Remember the number of the default rule so we
        -: 9691:			 * don't generate "can't match" warnings for it.
        -: 9692:			 */
      551: 9693:			default_rule = num_rules;
        -: 9694:
      551: 9695:			finish_rule( def_rule, false, 0, 0 );
call    0 returned 551
        -: 9696:
     1121: 9697:			for ( i = 1; i <= lastsc; ++i )
branch  0 taken 570
branch  1 taken 551 (fallthrough)
      570: 9698:				scset[i] = mkbranch( scset[i], def_rule );
call    0 returned 570
        -: 9699:
      551: 9700:			if ( spprdflt )
branch  0 taken 3 (fallthrough)
branch  1 taken 548
        3: 9701:				add_action(
call    0 returned 3
        -: 9702:				"YY_FATAL_ERROR( \"flex scanner jammed\" )" );
        -: 9703:			else
      548: 9704:				add_action( "ECHO" );
call    0 returned 548
        -: 9705:
      551: 9706:			add_action( ";\n\tYY_BREAK\n" );
call    0 returned 551
        -: 9707:			;
      551: 9708:    break;}
      560: 9709:case 2:
        -: 9710:{ /* initialize for processing rules */
        -: 9711:
        -: 9712:			/* Create default DFA start condition. */
      560: 9713:			scinstal( "INITIAL", false );
call    0 returned 560
        -: 9714:			;
      560: 9715:    break;}
    #####: 9716:case 6:
    #####: 9717:{ synerr( "unknown error processing section 1" ); ;
call    0 never executed
    #####: 9718:    break;}
      560: 9719:case 7:
        -: 9720:{
      560: 9721:			check_options();
call    0 returned 553
      553: 9722:			scon_stk = allocate_integer_array( lastsc + 1 );
call    0 returned 553
      553: 9723:			scon_stk_ptr = 0;
        -: 9724:			;
      553: 9725:    break;}
        1: 9726:case 8:
        1: 9727:{ xcluflg = false; ;
        1: 9728:    break;}
       18: 9729:case 9:
       18: 9730:{ xcluflg = true; ;
       18: 9731:    break;}
    #####: 9732:case 10:
    #####: 9733:{ scinstal( nmstr, xcluflg ); ;
call    0 never executed
    #####: 9734:    break;}
       19: 9735:case 11:
       19: 9736:{ scinstal( nmstr, xcluflg ); ;
call    0 returned 19
       19: 9737:    break;}
    #####: 9738:case 12:
    #####: 9739:{ synerr( "bad start condition list" ); ;
call    0 never executed
    #####: 9740:    break;}
    #####: 9741:case 16:
        -: 9742:{
    #####: 9743:			outfilename = copy_string( nmstr );
call    0 never executed
    #####: 9744:			did_outfilename = 1;
        -: 9745:			;
    #####: 9746:    break;}
    #####: 9747:case 17:
    #####: 9748:{ prefix = copy_string( nmstr ); ;
call    0 never executed
    #####: 9749:    break;}
    #####: 9750:case 18:
    #####: 9751:{ yyclass = copy_string( nmstr ); ;
call    0 never executed
    #####: 9752:    break;}
     3533: 9753:case 19:
     3533: 9754:{ scon_stk_ptr = yyvsp[-3]; ;
     3533: 9755:    break;}
    #####: 9756:case 20:
    #####: 9757:{ scon_stk_ptr = yyvsp[-3]; ;
    #####: 9758:    break;}
     4086: 9759:case 22:
        -: 9760:{
        -: 9761:			/* Initialize for a parse of one rule. */
     4086: 9762:			trlcontxt = variable_trail_rule = varlength = false;
     4086: 9763:			trailcnt = headcnt = rulelen = 0;
     4086: 9764:			current_state_type = STATE_NORMAL;
     4086: 9765:			previous_continued_action = continued_action;
     4086: 9766:			in_rule = true;
        -: 9767:
     4086: 9768:			new_rule();
call    0 returned 4086
        -: 9769:			;
     4086: 9770:    break;}
      100: 9771:case 23:
        -: 9772:{
      100: 9773:			pat = yyvsp[0];
      100: 9774:			finish_rule( pat, variable_trail_rule,
call    0 returned 100
        -: 9775:				headcnt, trailcnt );
        -: 9776:
      100: 9777:			if ( scon_stk_ptr > 0 )
branch  0 taken 0 (fallthrough)
branch  1 taken 100
        -: 9778:				{
    #####: 9779:				for ( i = 1; i <= scon_stk_ptr; ++i )
branch  0 never executed
branch  1 never executed
    #####: 9780:					scbol[scon_stk[i]] =
    #####: 9781:						mkbranch( scbol[scon_stk[i]],
call    0 never executed
        -: 9782:								pat );
        -: 9783:				}
        -: 9784:
        -: 9785:			else
        -: 9786:				{
        -: 9787:				/* Add to all non-exclusive start conditions,
        -: 9788:				 * including the default (0) start condition.
        -: 9789:				 */
        -: 9790:
      212: 9791:				for ( i = 1; i <= lastsc; ++i )
branch  0 taken 112
branch  1 taken 100 (fallthrough)
      112: 9792:					if ( ! scxclu[i] )
branch  0 taken 100 (fallthrough)
branch  1 taken 12
      100: 9793:						scbol[i] = mkbranch( scbol[i],
call    0 returned 100
        -: 9794:									pat );
        -: 9795:				}
        -: 9796:
      100: 9797:			if ( ! bol_needed )
branch  0 taken 99 (fallthrough)
branch  1 taken 1
        -: 9798:				{
       99: 9799:				bol_needed = true;
        -: 9800:
       99: 9801:				if ( performance_report > 1 )
branch  0 taken 0 (fallthrough)
branch  1 taken 99
    #####: 9802:					pinpoint_message(
call    0 never executed
        -: 9803:			"'^' operator results in sub-optimal performance" );
        -: 9804:				}
        -: 9805:			;
      100: 9806:    break;}
     3416: 9807:case 24:
        -: 9808:{
     3416: 9809:			pat = yyvsp[0];
     3416: 9810:			finish_rule( pat, variable_trail_rule,
call    0 returned 3416
        -: 9811:				headcnt, trailcnt );
        -: 9812:
     3416: 9813:			if ( scon_stk_ptr > 0 )
branch  0 taken 11 (fallthrough)
branch  1 taken 3405
        -: 9814:				{
       42: 9815:				for ( i = 1; i <= scon_stk_ptr; ++i )
branch  0 taken 31
branch  1 taken 11
       31: 9816:					scset[scon_stk[i]] =
       31: 9817:						mkbranch( scset[scon_stk[i]],
call    0 returned 31
        -: 9818:								pat );
        -: 9819:				}
        -: 9820:
        -: 9821:			else
        -: 9822:				{
    10155: 9823:				for ( i = 1; i <= lastsc; ++i )
branch  0 taken 6750
branch  1 taken 3405 (fallthrough)
     6750: 9824:					if ( ! scxclu[i] )
branch  0 taken 3417 (fallthrough)
branch  1 taken 3333
     3417: 9825:						scset[i] =
     3417: 9826:							mkbranch( scset[i],
call    0 returned 3417
        -: 9827:								pat );
        -: 9828:				}
        -: 9829:			;
     3416: 9830:    break;}
       11: 9831:case 25:
        -: 9832:{
       11: 9833:			if ( scon_stk_ptr > 0 )
branch  0 taken 5 (fallthrough)
branch  1 taken 6
        5: 9834:				build_eof_action();
call    0 returned 5
        -: 9835:	
        -: 9836:			else
        -: 9837:				{
        -: 9838:				/* This EOF applies to all start conditions
        -: 9839:				 * which don't already have EOF actions.
        -: 9840:				 */
       27: 9841:				for ( i = 1; i <= lastsc; ++i )
branch  0 taken 21
branch  1 taken 6 (fallthrough)
       21: 9842:					if ( ! sceof[i] )
branch  0 taken 17 (fallthrough)
branch  1 taken 4
       17: 9843:						scon_stk[++scon_stk_ptr] = i;
        -: 9844:
        6: 9845:				if ( scon_stk_ptr == 0 )
branch  0 taken 0 (fallthrough)
branch  1 taken 6
    #####: 9846:					warn(
call    0 never executed
        -: 9847:			"all start conditions already have <<EOF>> rules" );
        -: 9848:
        -: 9849:				else
        6: 9850:					build_eof_action();
call    0 returned 6
        -: 9851:				}
        -: 9852:			;
       11: 9853:    break;}
       18: 9854:case 26:
       18: 9855:{ synerr( "unrecognized rule" ); ;
call    0 returned 18
       18: 9856:    break;}
       13: 9857:case 27:
       13: 9858:{ yyval = scon_stk_ptr; ;
       13: 9859:    break;}
       13: 9860:case 28:
       13: 9861:{ yyval = yyvsp[-2]; ;
       13: 9862:    break;}
        3: 9863:case 29:
        -: 9864:{
        3: 9865:			yyval = scon_stk_ptr;
        -: 9866:
       22: 9867:			for ( i = 1; i <= lastsc; ++i )
branch  0 taken 19
branch  1 taken 3 (fallthrough)
        -: 9868:				{
        -: 9869:				int j;
        -: 9870:
       71: 9871:				for ( j = 1; j <= scon_stk_ptr; ++j )
branch  0 taken 52
branch  1 taken 19 (fallthrough)
       52: 9872:					if ( scon_stk[j] == i )
branch  0 taken 0 (fallthrough)
branch  1 taken 52
    #####: 9873:						break;
        -: 9874:
       19: 9875:				if ( j > scon_stk_ptr )
branch  0 taken 19 (fallthrough)
branch  1 taken 0
       19: 9876:					scon_stk[++scon_stk_ptr] = i;
        -: 9877:				}
        -: 9878:			;
        3: 9879:    break;}
     3520: 9880:case 30:
     3520: 9881:{ yyval = scon_stk_ptr; ;
     3520: 9882:    break;}
    #####: 9883:case 33:
    #####: 9884:{ synerr( "bad start condition list" ); ;
call    0 never executed
    #####: 9885:    break;}
       17: 9886:case 34:
        -: 9887:{
       17: 9888:			if ( (scnum = sclookup( nmstr )) == 0 )
call    0 returned 17
branch  1 taken 0 (fallthrough)
branch  2 taken 17
    #####: 9889:				format_pinpoint_message(
call    0 never executed
        -: 9890:					"undeclared start condition %s",
        -: 9891:					nmstr );
        -: 9892:			else
        -: 9893:				{
       23: 9894:				for ( i = 1; i <= scon_stk_ptr; ++i )
branch  0 taken 6
branch  1 taken 17 (fallthrough)
        6: 9895:					if ( scon_stk[i] == scnum )
branch  0 taken 0 (fallthrough)
branch  1 taken 6
        -: 9896:						{
    #####: 9897:						format_warn(
        -: 9898:							"<%s> specified twice",
    #####: 9899:							scname[scnum] );
call    0 never executed
    #####: 9900:						break;
        -: 9901:						}
        -: 9902:
       17: 9903:				if ( i > scon_stk_ptr )
branch  0 taken 17 (fallthrough)
branch  1 taken 0
       17: 9904:					scon_stk[++scon_stk_ptr] = scnum;
        -: 9905:				}
        -: 9906:			;
       17: 9907:    break;}
      110: 9908:case 35:
        -: 9909:{
      110: 9910:			if ( transchar[lastst[yyvsp[0]]] != SYM_EPSILON )
branch  0 taken 108 (fallthrough)
branch  1 taken 2
        -: 9911:				/* Provide final transition \now/ so it
        -: 9912:				 * will be marked as a trailing context
        -: 9913:				 * state.
        -: 9914:				 */
      108: 9915:				yyvsp[0] = link_machines( yyvsp[0],
call    0 returned 108
call    1 returned 108
        -: 9916:						mkstate( SYM_EPSILON ) );
        -: 9917:
      110: 9918:			mark_beginning_as_normal( yyvsp[0] );
call    0 returned 110
      110: 9919:			current_state_type = STATE_NORMAL;
        -: 9920:
      110: 9921:			if ( previous_continued_action )
branch  0 taken 2 (fallthrough)
branch  1 taken 108
        -: 9922:				{
        -: 9923:				/* We need to treat this as variable trailing
        -: 9924:				 * context so that the backup does not happen
        -: 9925:				 * in the action but before the action switch
        -: 9926:				 * statement.  If the backup happens in the
        -: 9927:				 * action, then the rules "falling into" this
        -: 9928:				 * one's action will *also* do the backup,
        -: 9929:				 * erroneously.
        -: 9930:				 */
        2: 9931:				if ( ! varlength || headcnt != 0 )
branch  0 taken 2 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 2
    #####: 9932:					warn(
call    0 never executed
        -: 9933:		"trailing context made variable due to preceding '|' action" );
        -: 9934:
        -: 9935:				/* Mark as variable. */
        2: 9936:				varlength = true;
        2: 9937:				headcnt = 0;
        -: 9938:				}
        -: 9939:
      110: 9940:			if ( lex_compat || (varlength && headcnt == 0) )
branch  0 taken 79 (fallthrough)
branch  1 taken 31
branch  2 taken 2 (fallthrough)
branch  3 taken 77
branch  4 taken 2 (fallthrough)
branch  5 taken 0
        -: 9941:				{ /* variable trailing context rule */
        -: 9942:				/* Mark the first part of the rule as the
        -: 9943:				 * accepting "head" part of a trailing
        -: 9944:				 * context rule.
        -: 9945:				 *
        -: 9946:				 * By the way, we didn't do this at the
        -: 9947:				 * beginning of this production because back
        -: 9948:				 * then current_state_type was set up for a
        -: 9949:				 * trail rule, and add_accept() can create
        -: 9950:				 * a new state ...
        -: 9951:				 */
       33: 9952:				add_accept( yyvsp[-1],
call    0 returned 33
        -: 9953:					num_rules | YY_TRAILING_HEAD_MASK );
       33: 9954:				variable_trail_rule = true;
        -: 9955:				}
        -: 9956:			
        -: 9957:			else
       77: 9958:				trailcnt = rulelen;
        -: 9959:
      110: 9960:			yyval = link_machines( yyvsp[-1], yyvsp[0] );
call    0 returned 110
        -: 9961:			;
      110: 9962:    break;}
    #####: 9963:case 36:
    #####: 9964:{ synerr( "trailing context used twice" ); ;
call    0 never executed
    #####: 9965:    break;}
      103: 9966:case 37:
        -: 9967:{
      103: 9968:			headcnt = 0;
      103: 9969:			trailcnt = 1;
      103: 9970:			rulelen = 1;
      103: 9971:			varlength = false;
        -: 9972:
      103: 9973:			current_state_type = STATE_TRAILING_CONTEXT;
        -: 9974:
      103: 9975:			if ( trlcontxt )
branch  0 taken 0 (fallthrough)
branch  1 taken 103
        -: 9976:				{
    #####: 9977:				synerr( "trailing context used twice" );
call    0 never executed
    #####: 9978:				yyval = mkstate( SYM_EPSILON );
call    0 never executed
        -: 9979:				}
        -: 9980:
      103: 9981:			else if ( previous_continued_action )
branch  0 taken 0 (fallthrough)
branch  1 taken 103
        -: 9982:				{
        -: 9983:				/* See the comment in the rule for "re2 re"
        -: 9984:				 * above.
        -: 9985:				 */
    #####: 9986:				warn(
call    0 never executed
        -: 9987:		"trailing context made variable due to preceding '|' action" );
        -: 9988:
    #####: 9989:				varlength = true;
        -: 9990:				}
        -: 9991:
      103: 9992:			if ( lex_compat || varlength )
branch  0 taken 72 (fallthrough)
branch  1 taken 31
branch  2 taken 0 (fallthrough)
branch  3 taken 72
        -: 9993:				{
        -: 9994:				/* Again, see the comment in the rule for
        -: 9995:				 * "re2 re" above.
        -: 9996:				 */
       31: 9997:				add_accept( yyvsp[-1],
call    0 returned 31
        -: 9998:					num_rules | YY_TRAILING_HEAD_MASK );
       31: 9999:				variable_trail_rule = true;
        -:10000:				}
        -:10001:
      103:10002:			trlcontxt = true;
        -:10003:
      103:10004:			eps = mkstate( SYM_EPSILON );
call    0 returned 103
      103:10005:			yyval = link_machines( yyvsp[-1],
call    0 returned 103
call    1 returned 103
call    2 returned 103
        -:10006:				link_machines( eps, mkstate( '\n' ) ) );
        -:10007:			;
      103:10008:    break;}
     3303:10009:case 38:
        -:10010:{
     3303:10011:			yyval = yyvsp[0];
        -:10012:
     3303:10013:			if ( trlcontxt )
branch  0 taken 0 (fallthrough)
branch  1 taken 3303
        -:10014:				{
    #####:10015:				if ( lex_compat || (varlength && headcnt == 0) )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:10016:					/* Both head and trail are
        -:10017:					 * variable-length.
        -:10018:					 */
    #####:10019:					variable_trail_rule = true;
        -:10020:				else
    #####:10021:					trailcnt = rulelen;
        -:10022:				}
        -:10023:			;
     3303:10024:    break;}
     1103:10025:case 39:
        -:10026:{
     1103:10027:			varlength = true;
     1103:10028:			yyval = mkor( yyvsp[-2], yyvsp[0] );
call    0 returned 1103
        -:10029:			;
     1103:10030:    break;}
     4222:10031:case 40:
     4222:10032:{ yyval = yyvsp[0]; ;
     4222:10033:    break;}
      111:10034:case 41:
        -:10035:{
        -:10036:			/* This rule is written separately so the
        -:10037:			 * reduction will occur before the trailing
        -:10038:			 * series is parsed.
        -:10039:			 */
        -:10040:
      111:10041:			if ( trlcontxt )
branch  0 taken 0 (fallthrough)
branch  1 taken 111
    #####:10042:				synerr( "trailing context used twice" );
call    0 never executed
        -:10043:			else
      111:10044:				trlcontxt = true;
        -:10045:
      111:10046:			if ( varlength )
branch  0 taken 3 (fallthrough)
branch  1 taken 108
        -:10047:				/* We hope the trailing context is
        -:10048:				 * fixed-length.
        -:10049:				 */
        3:10050:				varlength = false;
        -:10051:			else
      108:10052:				headcnt = rulelen;
        -:10053:
      111:10054:			rulelen = 0;
        -:10055:
      111:10056:			current_state_type = STATE_TRAILING_CONTEXT;
      111:10057:			yyval = yyvsp[-1];
        -:10058:			;
      111:10059:    break;}
     7092:10060:case 42:
        -:10061:{
        -:10062:			/* This is where concatenation of adjacent patterns
        -:10063:			 * gets done.
        -:10064:			 */
     7092:10065:			yyval = link_machines( yyvsp[-1], yyvsp[0] );
call    0 returned 7092
        -:10066:			;
     7092:10067:    break;}
     5325:10068:case 43:
     5325:10069:{ yyval = yyvsp[0]; ;
     5325:10070:    break;}
      846:10071:case 44:
        -:10072:{
      846:10073:			varlength = true;
        -:10074:
      846:10075:			yyval = mkclos( yyvsp[-1] );
call    0 returned 846
        -:10076:			;
      846:10077:    break;}
      348:10078:case 45:
        -:10079:{
      348:10080:			varlength = true;
      348:10081:			yyval = mkposcl( yyvsp[-1] );
call    0 returned 348
        -:10082:			;
      348:10083:    break;}
        4:10084:case 46:
        -:10085:{
        4:10086:			varlength = true;
        4:10087:			yyval = mkopt( yyvsp[-1] );
call    0 returned 4
        -:10088:			;
        4:10089:    break;}
      100:10090:case 47:
        -:10091:{
      100:10092:			varlength = true;
        -:10093:
      100:10094:			if ( yyvsp[-3] > yyvsp[-1] || yyvsp[-3] < 0 )
branch  0 taken 100 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 100
        -:10095:				{
    #####:10096:				synerr( "bad iteration values" );
call    0 never executed
    #####:10097:				yyval = yyvsp[-5];
        -:10098:				}
        -:10099:			else
        -:10100:				{
      100:10101:				if ( yyvsp[-3] == 0 )
branch  0 taken 0 (fallthrough)
branch  1 taken 100
        -:10102:					{
    #####:10103:					if ( yyvsp[-1] <= 0 )
branch  0 never executed
branch  1 never executed
        -:10104:						{
    #####:10105:						synerr(
call    0 never executed
        -:10106:						"bad iteration values" );
    #####:10107:						yyval = yyvsp[-5];
        -:10108:						}
        -:10109:					else
    #####:10110:						yyval = mkopt(
call    0 never executed
    #####:10111:							mkrep( yyvsp[-5], 1, yyvsp[-1] ) );
call    0 never executed
        -:10112:					}
        -:10113:				else
      100:10114:					yyval = mkrep( yyvsp[-5], yyvsp[-3], yyvsp[-1] );
call    0 returned 100
        -:10115:				}
        -:10116:			;
      100:10117:    break;}
       98:10118:case 48:
        -:10119:{
       98:10120:			varlength = true;
        -:10121:
       98:10122:			if ( yyvsp[-2] <= 0 )
branch  0 taken 0 (fallthrough)
branch  1 taken 98
        -:10123:				{
    #####:10124:				synerr( "iteration value must be positive" );
call    0 never executed
    #####:10125:				yyval = yyvsp[-4];
        -:10126:				}
        -:10127:
        -:10128:			else
       98:10129:				yyval = mkrep( yyvsp[-4], yyvsp[-2], INFINITY );
call    0 returned 98
        -:10130:			;
       98:10131:    break;}
       98:10132:case 49:
        -:10133:{
        -:10134:			/* The singleton could be something like "(foo)",
        -:10135:			 * in which case we have no idea what its length
        -:10136:			 * is, so we punt here.
        -:10137:			 */
       98:10138:			varlength = true;
        -:10139:
       98:10140:			if ( yyvsp[-1] <= 0 )
branch  0 taken 0 (fallthrough)
branch  1 taken 98
        -:10141:				{
    #####:10142:				synerr( "iteration value must be positive" );
call    0 never executed
    #####:10143:				yyval = yyvsp[-3];
        -:10144:				}
        -:10145:
        -:10146:			else
       98:10147:				yyval = link_machines( yyvsp[-3],
call    0 returned 98
       98:10148:						copysingl( yyvsp[-3], yyvsp[-1] - 1 ) );
call    0 returned 98
        -:10149:			;
       98:10150:    break;}
      214:10151:case 50:
        -:10152:{
      214:10153:			if ( ! madeany )
branch  0 taken 211 (fallthrough)
branch  1 taken 3
        -:10154:				{
        -:10155:				/* Create the '.' character class. */
      211:10156:				anyccl = cclinit();
call    0 returned 211
      211:10157:				ccladd( anyccl, '\n' );
call    0 returned 211
      211:10158:				cclnegate( anyccl );
call    0 returned 211
        -:10159:
      211:10160:				if ( useecs )
branch  0 taken 116 (fallthrough)
branch  1 taken 95
      116:10161:					mkeccl( ccltbl + cclmap[anyccl],
      116:10162:						ccllen[anyccl], nextecm,
call    0 returned 116
        -:10163:						ecgroup, csize, csize );
        -:10164:
      211:10165:				madeany = true;
        -:10166:				}
        -:10167:
      214:10168:			++rulelen;
        -:10169:
      214:10170:			yyval = mkstate( -anyccl );
call    0 returned 214
        -:10171:			;
      214:10172:    break;}
     1298:10173:case 51:
        -:10174:{
     1298:10175:			if ( ! cclsorted )
branch  0 taken 850 (fallthrough)
branch  1 taken 448
        -:10176:				/* Sort characters for fast searching.  We
        -:10177:				 * use a shell sort since this list could
        -:10178:				 * be large.
        -:10179:				 */
      850:10180:				cshell( ccltbl + cclmap[yyvsp[0]], ccllen[yyvsp[0]], true );
call    0 returned 850
        -:10181:
     1298:10182:			if ( useecs )
branch  0 taken 818 (fallthrough)
branch  1 taken 480
      818:10183:				mkeccl( ccltbl + cclmap[yyvsp[0]], ccllen[yyvsp[0]],
call    0 returned 818
        -:10184:					nextecm, ecgroup, csize, csize );
        -:10185:
     1298:10186:			++rulelen;
        -:10187:
     1298:10188:			yyval = mkstate( -yyvsp[0] );
call    0 returned 1298
        -:10189:			;
     1298:10190:    break;}
      233:10191:case 52:
        -:10192:{
      233:10193:			++rulelen;
        -:10194:
      233:10195:			yyval = mkstate( -yyvsp[0] );
call    0 returned 233
        -:10196:			;
      233:10197:    break;}
     1098:10198:case 53:
     1098:10199:{ yyval = yyvsp[-1]; ;
     1098:10200:    break;}
      593:10201:case 54:
      593:10202:{ yyval = yyvsp[-1]; ;
      593:10203:    break;}
     8982:10204:case 55:
        -:10205:{
     8982:10206:			++rulelen;
        -:10207:
     8982:10208:			if ( caseins && yyvsp[0] >= 'A' && yyvsp[0] <= 'Z' )
branch  0 taken 73 (fallthrough)
branch  1 taken 8909
branch  2 taken 72 (fallthrough)
branch  3 taken 1
branch  4 taken 0 (fallthrough)
branch  5 taken 72
    #####:10209:				yyvsp[0] = clower( yyvsp[0] );
call    0 never executed
        -:10210:
     8982:10211:			yyval = mkstate( yyvsp[0] );
call    0 returned 8981
        -:10212:			;
     8981:10213:    break;}
     1079:10214:case 56:
     1079:10215:{ yyval = yyvsp[-1]; ;
     1079:10216:    break;}
      219:10217:case 57:
        -:10218:{
      219:10219:			cclnegate( yyvsp[-1] );
call    0 returned 219
      219:10220:			yyval = yyvsp[-1];
        -:10221:			;
      219:10222:    break;}
      880:10223:case 58:
        -:10224:{
      880:10225:			if ( caseins )
branch  0 taken 9 (fallthrough)
branch  1 taken 871
        -:10226:				{
        9:10227:				if ( yyvsp[-2] >= 'A' && yyvsp[-2] <= 'Z' )
branch  0 taken 4 (fallthrough)
branch  1 taken 5
branch  2 taken 0 (fallthrough)
branch  3 taken 4
    #####:10228:					yyvsp[-2] = clower( yyvsp[-2] );
call    0 never executed
        9:10229:				if ( yyvsp[0] >= 'A' && yyvsp[0] <= 'Z' )
branch  0 taken 4 (fallthrough)
branch  1 taken 5
branch  2 taken 0 (fallthrough)
branch  3 taken 4
    #####:10230:					yyvsp[0] = clower( yyvsp[0] );
call    0 never executed
        -:10231:				}
        -:10232:
      880:10233:			if ( yyvsp[-2] > yyvsp[0] )
branch  0 taken 2 (fallthrough)
branch  1 taken 878
        2:10234:				synerr( "negative range in character class" );
call    0 returned 2
        -:10235:
        -:10236:			else
        -:10237:				{
    23422:10238:				for ( i = yyvsp[-2]; i <= yyvsp[0]; ++i )
branch  0 taken 22544
branch  1 taken 878 (fallthrough)
    22544:10239:					ccladd( yyvsp[-3], i );
call    0 returned 22544
        -:10240:
        -:10241:				/* Keep track if this ccl is staying in
        -:10242:				 * alphabetical order.
        -:10243:				 */
      878:10244:				cclsorted = cclsorted && (yyvsp[-2] > lastchar);
branch  0 taken 848 (fallthrough)
branch  1 taken 30
branch  2 taken 559 (fallthrough)
branch  3 taken 289
      878:10245:				lastchar = yyvsp[0];
        -:10246:				}
        -:10247:
      880:10248:			yyval = yyvsp[-3];
        -:10249:			;
      880:10250:    break;}
     2467:10251:case 59:
        -:10252:{
     2467:10253:			if ( caseins && yyvsp[0] >= 'A' && yyvsp[0] <= 'Z' )
branch  0 taken 10 (fallthrough)
branch  1 taken 2457
branch  2 taken 2 (fallthrough)
branch  3 taken 8
branch  4 taken 0 (fallthrough)
branch  5 taken 2
    #####:10254:				yyvsp[0] = clower( yyvsp[0] );
call    0 never executed
        -:10255:
     2467:10256:			ccladd( yyvsp[-1], yyvsp[0] );
call    0 returned 2467
     2467:10257:			cclsorted = cclsorted && (yyvsp[0] > lastchar);
branch  0 taken 2349 (fallthrough)
branch  1 taken 118
branch  2 taken 1788 (fallthrough)
branch  3 taken 561
     2467:10258:			lastchar = yyvsp[0];
     2467:10259:			yyval = yyvsp[-1];
        -:10260:			;
     2467:10261:    break;}
    #####:10262:case 60:
        -:10263:{
        -:10264:			/* Too hard to properly maintain cclsorted. */
    #####:10265:			cclsorted = false;
    #####:10266:			yyval = yyvsp[-1];
        -:10267:			;
    #####:10268:    break;}
     1298:10269:case 61:
        -:10270:{
     1298:10271:			cclsorted = true;
     1298:10272:			lastchar = 0;
     1298:10273:			currccl = yyval = cclinit();
call    0 returned 1298
        -:10274:			;
     1298:10275:    break;}
    #####:10276:case 62:
    #####:10277:{ CCL_EXPR(isalnum) ;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
    #####:10278:    break;}
    #####:10279:case 63:
    #####:10280:{ CCL_EXPR(isalpha) ;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
    #####:10281:    break;}
    #####:10282:case 64:
    #####:10283:{ CCL_EXPR(IS_BLANK) ;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
    #####:10284:    break;}
    #####:10285:case 65:
    #####:10286:{ CCL_EXPR(iscntrl) ;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
    #####:10287:    break;}
    #####:10288:case 66:
    #####:10289:{ CCL_EXPR(isdigit) ;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
    #####:10290:    break;}
    #####:10291:case 67:
    #####:10292:{ CCL_EXPR(isgraph) ;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
    #####:10293:    break;}
    #####:10294:case 68:
    #####:10295:{ CCL_EXPR(islower) ;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
    #####:10296:    break;}
    #####:10297:case 69:
    #####:10298:{ CCL_EXPR(isprint) ;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
    #####:10299:    break;}
    #####:10300:case 70:
    #####:10301:{ CCL_EXPR(ispunct) ;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
    #####:10302:    break;}
    #####:10303:case 71:
    #####:10304:{ CCL_EXPR(isspace) ;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
    #####:10305:    break;}
    #####:10306:case 72:
        -:10307:{
    #####:10308:				if ( caseins )
branch  0 never executed
branch  1 never executed
    #####:10309:					CCL_EXPR(islower)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
        -:10310:				else
    #####:10311:					CCL_EXPR(isupper)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
        -:10312:				;
    #####:10313:    break;}
    #####:10314:case 73:
    #####:10315:{ CCL_EXPR(isxdigit) ;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
    #####:10316:    break;}
     2017:10317:case 74:
        -:10318:{
     2017:10319:			if ( caseins && yyvsp[0] >= 'A' && yyvsp[0] <= 'Z' )
branch  0 taken 18 (fallthrough)
branch  1 taken 1999
branch  2 taken 6 (fallthrough)
branch  3 taken 12
branch  4 taken 0 (fallthrough)
branch  5 taken 6
    #####:10320:				yyvsp[0] = clower( yyvsp[0] );
call    0 never executed
        -:10321:
     2017:10322:			++rulelen;
        -:10323:
     2017:10324:			yyval = link_machines( yyvsp[-1], mkstate( yyvsp[0] ) );
call    0 returned 2017
call    1 returned 2017
        -:10325:			;
     2017:10326:    break;}
     1098:10327:case 75:
     1098:10328:{ yyval = mkstate( SYM_EPSILON ); ;
call    0 returned 1098
     1098:10329:    break;}
        -:10330:}
        -:10331:   /* the action file gets copied in in place of this dollarsign */
    61920:10332:  yyvsp -= yylen;
    61920:10333:  yyssp -= yylen;
        -:10334:#ifdef YYLSP_NEEDED
        -:10335:  yylsp -= yylen;
        -:10336:#endif
        -:10337:
        -:10338:#if YYDEBUG != 0
        -:10339:  if (yydebug)
        -:10340:    {
        -:10341:      short *ssp1 = yyss - 1;
        -:10342:      fprintf (err, "state stack now");
        -:10343:      while (ssp1 != yyssp)
        -:10344:	fprintf (err, " %d", *++ssp1);
        -:10345:      fprintf (err, "\n");
        -:10346:    }
        -:10347:#endif
        -:10348:
    61920:10349:  *++yyvsp = yyval;
        -:10350:
        -:10351:#ifdef YYLSP_NEEDED
        -:10352:  yylsp++;
        -:10353:  if (yylen == 0)
        -:10354:    {
        -:10355:      yylsp->first_line = yylloc.first_line;
        -:10356:      yylsp->first_column = yylloc.first_column;
        -:10357:      yylsp->last_line = (yylsp-1)->last_line;
        -:10358:      yylsp->last_column = (yylsp-1)->last_column;
        -:10359:      yylsp->text = 0;
        -:10360:    }
        -:10361:  else
        -:10362:    {
        -:10363:      yylsp->last_line = (yylsp+yylen-1)->last_line;
        -:10364:      yylsp->last_column = (yylsp+yylen-1)->last_column;
        -:10365:    }
        -:10366:#endif
        -:10367:
        -:10368:  /* Now "shift" the result of the reduction.
        -:10369:     Determine what state that goes to,
        -:10370:     based on the state we popped back to
        -:10371:     and the rule number reduced by.  */
        -:10372:
    61920:10373:  yyn = yyr1[yyn];
        -:10374:
    61920:10375:  yystate = yypgoto[yyn - YYNTBASE] + *yyssp;
    61920:10376:  if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *yyssp)
branch  0 taken 42939 (fallthrough)
branch  1 taken 18981
branch  2 taken 42939 (fallthrough)
branch  3 taken 0
branch  4 taken 16832 (fallthrough)
branch  5 taken 26107
    16832:10377:    yystate = yytable[yystate];
        -:10378:  else
    45088:10379:    yystate = yydefgoto[yyn - YYNTBASE];
        -:10380:
    61920:10381:  goto yynewstate;
        -:10382:
       19:10383:yyerrlab:   /* here on detecting error */
        -:10384:
       19:10385:  if (! yyerrstatus)
branch  0 taken 6 (fallthrough)
branch  1 taken 13
        -:10386:    /* If not already recovering from an error, report this error.  */
        -:10387:    {
        6:10388:      ++yynerrs;
        -:10389:
        -:10390:#ifdef YYERROR_VERBOSE
        -:10391:      yyn = yypact[yystate];
        -:10392:
        -:10393:      if (yyn > YYFLAG && yyn < YYLAST)
        -:10394:	{
        -:10395:	  int size = 0;
        -:10396:	  char *msg;
        -:10397:	  int x, count;
        -:10398:
        -:10399:	  count = 0;
        -:10400:	  /* Start X at -yyn if nec to avoid negative indexes in yycheck.  */
        -:10401:	  for (x = (yyn < 0 ? -yyn : 0);
        -:10402:	       x < (sizeof(yytname) / sizeof(char *)); x++)
        -:10403:	    if (yycheck[x + yyn] == x)
        -:10404:	      size += strlen(yytname[x]) + 15, count++;
        -:10405:	  msg = (char *) malloc(size + 15);
        -:10406:	  if (msg != 0)
        -:10407:	    {
        -:10408:	      strcpy(msg, "parse error");
        -:10409:
        -:10410:	      if (count < 5)
        -:10411:		{
        -:10412:		  count = 0;
        -:10413:		  for (x = (yyn < 0 ? -yyn : 0);
        -:10414:		       x < (sizeof(yytname) / sizeof(char *)); x++)
        -:10415:		    if (yycheck[x + yyn] == x)
        -:10416:		      {
        -:10417:			strcat(msg, count == 0 ? ", expecting `" : " or `");
        -:10418:			strcat(msg, yytname[x]);
        -:10419:			strcat(msg, "'");
        -:10420:			count++;
        -:10421:		      }
        -:10422:		}
        -:10423:	      yyerror(msg);
        -:10424:	      free(msg);
        -:10425:	    }
        -:10426:	  else
        -:10427:	    yyerror ("parse error; also virtual memory exceeded");
        -:10428:	}
        -:10429:      else
        -:10430:#endif /* YYERROR_VERBOSE */
        6:10431:	yyerror("parse error");
call    0 returned 6
        -:10432:    }
        -:10433:
       19:10434:  goto yyerrlab1;
       19:10435:yyerrlab1:   /* here on error raised explicitly by an action */
        -:10436:
       19:10437:  if (yyerrstatus == 3)
branch  0 taken 11 (fallthrough)
branch  1 taken 8
        -:10438:    {
        -:10439:      /* if just tried and failed to reuse lookahead token after an error, discard it.  */
        -:10440:
        -:10441:      /* return failure if at end of input */
       11:10442:      if (yychar == YYEOF)
branch  0 taken 1 (fallthrough)
branch  1 taken 10
        1:10443:	YYABORT;
        -:10444:
        -:10445:#if YYDEBUG != 0
        -:10446:      if (yydebug)
        -:10447:	fprintf(err, "Discarding token %d (%s).\n", yychar, yytname[yychar1]);
        -:10448:#endif
        -:10449:
       10:10450:      yychar = YYEMPTY;
        -:10451:    }
        -:10452:
        -:10453:  /* Else will try to reuse lookahead token
        -:10454:     after shifting the error token.  */
        -:10455:
       18:10456:  yyerrstatus = 3;		/* Each real token shifted decrements this */
        -:10457:
       18:10458:  goto yyerrhandle;
        -:10459:
       16:10460:yyerrdefault:  /* current state does not do anything special for the error token. */
        -:10461:
        -:10462:#if 0
        -:10463:  /* This is wrong; only states that explicitly want error tokens
        -:10464:     should shift them.  */
        -:10465:  yyn = yydefact[yystate];  /* If its default is to accept any token, ok.  Otherwise pop it.*/
        -:10466:  if (yyn) goto yydefault;
        -:10467:#endif
        -:10468:
       16:10469:yyerrpop:   /* pop the current state because it cannot handle the error token */
        -:10470:
      16*:10471:  if (yyssp == yyss) YYABORT;
branch  0 taken 0 (fallthrough)
branch  1 taken 16
       16:10472:  yyvsp--;
       16:10473:  yystate = *--yyssp;
        -:10474:#ifdef YYLSP_NEEDED
        -:10475:  yylsp--;
        -:10476:#endif
        -:10477:
        -:10478:#if YYDEBUG != 0
        -:10479:  if (yydebug)
        -:10480:    {
        -:10481:      short *ssp1 = yyss - 1;
        -:10482:      fprintf (err, "Error: state stack now");
        -:10483:      while (ssp1 != yyssp)
        -:10484:	fprintf (err, " %d", *++ssp1);
        -:10485:      fprintf (err, "\n");
        -:10486:    }
        -:10487:#endif
        -:10488:
       34:10489:yyerrhandle:
        -:10490:
       34:10491:  yyn = yypact[yystate];
       34:10492:  if (yyn == YYFLAG)
branch  0 taken 0 (fallthrough)
branch  1 taken 34
    #####:10493:    goto yyerrdefault;
        -:10494:
       34:10495:  yyn += YYTERROR;
       34:10496:  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != YYTERROR)
branch  0 taken 34 (fallthrough)
branch  1 taken 0
branch  2 taken 34 (fallthrough)
branch  3 taken 0
branch  4 taken 16 (fallthrough)
branch  5 taken 18
       16:10497:    goto yyerrdefault;
        -:10498:
       18:10499:  yyn = yytable[yyn];
       18:10500:  if (yyn < 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 18
        -:10501:    {
    #####:10502:      if (yyn == YYFLAG)
branch  0 never executed
branch  1 never executed
    #####:10503:	goto yyerrpop;
    #####:10504:      yyn = -yyn;
    #####:10505:      goto yyreduce;
        -:10506:    }
       18:10507:  else if (yyn == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 18
    #####:10508:    goto yyerrpop;
        -:10509:
       18:10510:  if (yyn == YYFINAL)
branch  0 taken 0 (fallthrough)
branch  1 taken 18
    #####:10511:    YYACCEPT;
        -:10512:
        -:10513:#if YYDEBUG != 0
        -:10514:  if (yydebug)
        -:10515:    fprintf(err, "Shifting error token, ");
        -:10516:#endif
        -:10517:
       18:10518:  *++yyvsp = yylval;
        -:10519:#ifdef YYLSP_NEEDED
        -:10520:  *++yylsp = yylloc;
        -:10521:#endif
        -:10522:
       18:10523:  yystate = yyn;
       18:10524:  goto yynewstate;
        -:10525:
      551:10526: yyacceptlab:
        -:10527:  /* YYACCEPT comes here.  */
      551:10528:  if (yyfree_stacks)
branch  0 taken 0 (fallthrough)
branch  1 taken 551
        -:10529:    {
    #####:10530:      free (yyss);
    #####:10531:      free (yyvs);
        -:10532:#ifdef YYLSP_NEEDED
        -:10533:      free (yyls);
        -:10534:#endif
        -:10535:    }
      551:10536:  return 0;
        -:10537:
        1:10538: yyabortlab:
        -:10539:  /* YYABORT comes here.  */
        1:10540:  if (yyfree_stacks)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -:10541:    {
    #####:10542:      free (yyss);
    #####:10543:      free (yyvs);
        -:10544:#ifdef YYLSP_NEEDED
        -:10545:      free (yyls);
        -:10546:#endif
        -:10547:    }
        1:10548:  return 1;
        -:10549:}
        -:10550:
        -:10551:
        -:10552:
        -:10553:/* build_eof_action - build the "<<EOF>>" action for the active start
        -:10554: *                    conditions
        -:10555: */
        -:10556:
function build_eof_action called 11 returned 100% blocks executed 100%
       11:10557:void build_eof_action()
        -:10558:	{
        -:10559:	register int i;
        -:10560:	char action_text[MAXLINE];
        -:10561:
       33:10562:	for ( i = 1; i <= scon_stk_ptr; ++i )
branch  0 taken 22
branch  1 taken 11 (fallthrough)
        -:10563:		{
       22:10564:		if ( sceof[scon_stk[i]] )
branch  0 taken 1 (fallthrough)
branch  1 taken 21
        1:10565:			format_pinpoint_message(
        -:10566:				"multiple <<EOF>> rules for start condition %s",
        1:10567:				scname[scon_stk[i]] );
call    0 returned 1
        -:10568:
        -:10569:		else
        -:10570:			{
       21:10571:			sceof[scon_stk[i]] = true;
       21:10572:			sprintf( action_text, "case YY_STATE_EOF(%s):\n",
       21:10573:				scname[scon_stk[i]] );
       21:10574:			add_action( action_text );
call    0 returned 21
        -:10575:			}
        -:10576:		}
        -:10577:
       11:10578:	line_directive_out( (FILE *) 0, 1 );
call    0 returned 11
        -:10579:
        -:10580:	/* This isn't a normal rule after all - don't count it as
        -:10581:	 * such, so we don't have any holes in the rule numbering
        -:10582:	 * (which make generating "rule can never match" warnings
        -:10583:	 * more difficult.
        -:10584:	 */
       11:10585:	--num_rules;
       11:10586:	++num_eof_rules;
       11:10587:	}
        -:10588:
        -:10589:
        -:10590:/* format_synerr - write out formatted syntax error */
        -:10591:
function format_synerr called 4 returned 100% blocks executed 100%
        4:10592:void format_synerr( msg, arg )
        -:10593:char msg[], arg[];
        -:10594:	{
        -:10595:	char errmsg[MAXLINE];
        -:10596:
        4:10597:	(void) sprintf( errmsg, msg, arg );
        4:10598:	synerr( errmsg );
call    0 returned 4
        4:10599:	}
        -:10600:
        -:10601:
        -:10602:/* synerr - report a syntax error */
        -:10603:
function synerr called 25 returned 100% blocks executed 100%
       25:10604:void synerr( str )
        -:10605:char str[];
        -:10606:	{
       25:10607:	syntaxerror = true;
       25:10608:	pinpoint_message( str );
call    0 returned 25
       25:10609:	}
        -:10610:
        -:10611:
        -:10612:/* format_warn - write out formatted warning */
        -:10613:
function format_warn called 0 returned 0% blocks executed 0%
    #####:10614:void format_warn( msg, arg )
        -:10615:char msg[], arg[];
        -:10616:	{
        -:10617:	char warn_msg[MAXLINE];
        -:10618:
    #####:10619:	(void) sprintf( warn_msg, msg, arg );
    #####:10620:	warn( warn_msg );
call    0 never executed
    #####:10621:	}
        -:10622:
        -:10623:
        -:10624:/* warn - report a warning, unless -w was given */
        -:10625:
function warn called 0 returned 0% blocks executed 0%
    #####:10626:void warn( str )
        -:10627:char str[];
        -:10628:	{
    #####:10629:	line_warning( str, linenum );
call    0 never executed
    #####:10630:	}
        -:10631:
        -:10632:/* format_pinpoint_message - write out a message formatted with one string,
        -:10633: *			     pinpointing its location
        -:10634: */
        -:10635:
function format_pinpoint_message called 1 returned 100% blocks executed 100%
        1:10636:void format_pinpoint_message( msg, arg )
        -:10637:char msg[], arg[];
        -:10638:	{
        -:10639:	char errmsg[MAXLINE];
        -:10640:
        1:10641:	(void) sprintf( errmsg, msg, arg );
        1:10642:	pinpoint_message( errmsg );
call    0 returned 1
        1:10643:	}
        -:10644:
        -:10645:
        -:10646:/* pinpoint_message - write out a message, pinpointing its location */
        -:10647:
function pinpoint_message called 27 returned 100% blocks executed 100%
       27:10648:void pinpoint_message( str )
        -:10649:char str[];
        -:10650:	{
       27:10651:	line_pinpoint( str, linenum );
call    0 returned 27
       27:10652:	}
        -:10653:
        -:10654:
        -:10655:/* line_warning - report a warning at a given line, unless -w was given */
        -:10656:
function line_warning called 46 returned 100% blocks executed 100%
       46:10657:void line_warning( str, line )
        -:10658:char str[];
        -:10659:int line;
        -:10660:	{
        -:10661:	char warning[MAXLINE];
        -:10662:
       46:10663:	if ( ! nowarn )
branch  0 taken 45 (fallthrough)
branch  1 taken 1
        -:10664:		{
       45:10665:		sprintf( warning, "warning, %s", str );
       45:10666:		line_pinpoint( warning, line );
call    0 returned 45
        -:10667:		}
       46:10668:	}
        -:10669:
        -:10670:
        -:10671:/* line_pinpoint - write out a message, pinpointing it at the given line */
        -:10672:
function line_pinpoint called 72 returned 100% blocks executed 100%
       72:10673:void line_pinpoint( str, line )
        -:10674:char str[];
        -:10675:int line;
        -:10676:	{
       72:10677:	fprintf( err, "\"%s\", line %d: %s\n", infilename, line, str );
call    0 returned 72
       72:10678:	}
        -:10679:
        -:10680:
        -:10681:/* yyerror - eat up an error message from the parser;
        -:10682: *	     currently, messages are ignore
        -:10683: */
        -:10684:
function yyerror called 6 returned 100% blocks executed 100%
        6:10685:void yyerror( msg )
        -:10686:char msg[];
        -:10687:	{
        6:10688:	}
        -:10689:/* A lexical scanner generated by flex */
        -:10690:
        -:10691:/* Scanner skeleton version:
        -:10692: * $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.seeded/v5/flex.c,v 1.1.1.2 2003/09/02 20:22:00 expsir Exp $
        -:10693: */
        -:10694:
        -:10695:#define FLEX_SCANNER
        -:10696:#define YY_FLEX_MAJOR_VERSION 2
        -:10697:#define YY_FLEX_MINOR_VERSION 5
        -:10698:
        -:10699:#include <stdio.h>
        -:10700:
        -:10701:
        -:10702:/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
        -:10703:#ifdef c_plusplus
        -:10704:#ifndef __cplusplus
        -:10705:#define __cplusplus
        -:10706:#endif
        -:10707:#endif
        -:10708:
        -:10709:
        -:10710:#ifdef __cplusplus
        -:10711:
        -:10712:#include <stdlib.h>
        -:10713:#include <unistd.h>
        -:10714:
        -:10715:/* Use prototypes in function declarations. */
        -:10716:#define YY_USE_PROTOS
        -:10717:
        -:10718:/* The "const" storage-class-modifier is valid. */
        -:10719:#define YY_USE_CONST
        -:10720:
        -:10721:#else	/* ! __cplusplus */
        -:10722:
        -:10723:#if __STDC__
        -:10724:
        -:10725:#define YY_USE_PROTOS
        -:10726:#define YY_USE_CONST
        -:10727:
        -:10728:#endif	/* __STDC__ */
        -:10729:#endif	/* ! __cplusplus */
        -:10730:
        -:10731:#ifdef __TURBOC__
        -:10732: #pragma warn -rch
        -:10733: #pragma warn -use
        -:10734:#include <io.h>
        -:10735:#include <stdlib.h>
        -:10736:#define YY_USE_CONST
        -:10737:#define YY_USE_PROTOS
        -:10738:#endif
        -:10739:
        -:10740:#ifdef YY_USE_CONST
        -:10741:#define yyconst const
        -:10742:#else
        -:10743:#define yyconst
        -:10744:#endif
        -:10745:
        -:10746:
        -:10747:#ifdef YY_USE_PROTOS
        -:10748:#define YY_PROTO(proto) proto
        -:10749:#else
        -:10750:#define YY_PROTO(proto) ()
        -:10751:#endif
        -:10752:
        -:10753:/* Returned upon end-of-file. */
        -:10754:#define YY_NULL 0
        -:10755:
        -:10756:/* Promotes a possibly negative, possibly signed char to an unsigned
        -:10757: * integer for use as an array index.  If the signed char is negative,
        -:10758: * we want to instead treat it as an 8-bit unsigned char, hence the
        -:10759: * double cast.
        -:10760: */
        -:10761:#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
        -:10762:
        -:10763:/* Enter a start condition.  This macro really ought to take a parameter,
        -:10764: * but we do it the disgusting crufty way forced on us by the ()-less
        -:10765: * definition of BEGIN.
        -:10766: */
        -:10767:#define BEGIN yy_start = 1 + 2 *
        -:10768:
        -:10769:/* Translate the current start state into a value that can be later handed
        -:10770: * to BEGIN to return to the state.  The YYSTATE alias is for lex
        -:10771: * compatibility.
        -:10772: */
        -:10773:#define YY_START ((yy_start - 1) / 2)
        -:10774:#define YYSTATE YY_START
        -:10775:
        -:10776:/* Action number for EOF rule of a given start state. */
        -:10777:#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
        -:10778:
        -:10779:/* Special action meaning "start processing a new file". */
        -:10780:#define YY_NEW_FILE yyrestart( yyin )
        -:10781:
        -:10782:#define YY_END_OF_BUFFER_CHAR 0
        -:10783:
        -:10784:/* Size of default input buffer. */
        -:10785:#define YY_BUF_SIZE 16384
        -:10786:
        -:10787:typedef struct yy_buffer_state *YY_BUFFER_STATE;
        -:10788:
        -:10789:extern int yyleng;
        -:10790:extern FILE *yyin, *yyout;
        -:10791:
        -:10792:#define EOB_ACT_CONTINUE_SCAN 0
        -:10793:#define EOB_ACT_END_OF_FILE 1
        -:10794:#define EOB_ACT_LAST_MATCH 2
        -:10795:
        -:10796:/* The funky do-while in the following #define is used to turn the definition
        -:10797: * int a single C statement (which needs a semi-colon terminator).  This
        -:10798: * avoids problems with code like:
        -:10799: *
        -:10800: * 	if ( condition_holds )
        -:10801: *		yyless( 5 );
        -:10802: *	else
        -:10803: *		do_something_else();
        -:10804: *
        -:10805: * Prior to using the do-while the compiler would get upset at the
        -:10806: * "else" because it interpreted the "if" statement as being all
        -:10807: * done when it reached the ';' after the yyless() call.
        -:10808: */
        -:10809:
        -:10810:/* Return all but the first 'n' matched characters back to the input stream. */
        -:10811:
        -:10812:#define yyless(n) \
        -:10813:	do \
        -:10814:		{ \
        -:10815:		/* Undo effects of setting up yytext. */ \
        -:10816:		*yy_cp = yy_hold_char; \
        -:10817:		YY_RESTORE_YY_MORE_OFFSET \
        -:10818:		yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \
        -:10819:		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
        -:10820:		} \
        -:10821:	while ( 0 )
        -:10822:
        -:10823:#define unput(c) yyunput( c, yytext_ptr )
        -:10824:
        -:10825:/* The following is because we cannot portably get our hands on size_t
        -:10826: * (without autoconf's help, which isn't available because we want
        -:10827: * flex-generated scanners to compile on their own).
        -:10828: */
        -:10829:typedef unsigned int yy_size_t;
        -:10830:
        -:10831:
        -:10832:struct yy_buffer_state
        -:10833:	{
        -:10834:	FILE *yy_input_file;
        -:10835:
        -:10836:	char *yy_ch_buf;		/* input buffer */
        -:10837:	char *yy_buf_pos;		/* current position in input buffer */
        -:10838:
        -:10839:	/* Size of input buffer in bytes, not including room for EOB
        -:10840:	 * characters.
        -:10841:	 */
        -:10842:	yy_size_t yy_buf_size;
        -:10843:
        -:10844:	/* Number of characters read into yy_ch_buf, not including EOB
        -:10845:	 * characters.
        -:10846:	 */
        -:10847:	int yy_n_chars;
        -:10848:
        -:10849:	/* Whether we "own" the buffer - i.e., we know we created it,
        -:10850:	 * and can realloc() it to grow it, and should free() it to
        -:10851:	 * delete it.
        -:10852:	 */
        -:10853:	int yy_is_our_buffer;
        -:10854:
        -:10855:	/* Whether this is an "interactive" input source; if so, and
        -:10856:	 * if we're using stdio for input, then we want to use getc()
        -:10857:	 * instead of fread(), to make sure we stop fetching input after
        -:10858:	 * each newline.
        -:10859:	 */
        -:10860:	int yy_is_interactive;
        -:10861:
        -:10862:	/* Whether we're considered to be at the beginning of a line.
        -:10863:	 * If so, '^' rules will be active on the next match, otherwise
        -:10864:	 * not.
        -:10865:	 */
        -:10866:	int yy_at_bol;
        -:10867:
        -:10868:	/* Whether to try to fill the input buffer when we reach the
        -:10869:	 * end of it.
        -:10870:	 */
        -:10871:	int yy_fill_buffer;
        -:10872:
        -:10873:	int yy_buffer_status;
        -:10874:#define YY_BUFFER_NEW 0
        -:10875:#define YY_BUFFER_NORMAL 1
        -:10876:	/* When an EOF's been seen but there's still some text to process
        -:10877:	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
        -:10878:	 * shouldn't try reading from the input source any more.  We might
        -:10879:	 * still have a bunch of tokens to match, though, because of
        -:10880:	 * possible backing-up.
        -:10881:	 *
        -:10882:	 * When we actually see the EOF, we change the status to "new"
        -:10883:	 * (via yyrestart()), so that the user can continue scanning by
        -:10884:	 * just pointing yyin at a new input file.
        -:10885:	 */
        -:10886:#define YY_BUFFER_EOF_PENDING 2
        -:10887:	};
        -:10888:
        -:10889:static YY_BUFFER_STATE yy_current_buffer = 0;
        -:10890:
        -:10891:/* We provide macros for accessing buffer states in case in the
        -:10892: * future we want to put the buffer states in a more general
        -:10893: * "scanner state".
        -:10894: */
        -:10895:#define YY_CURRENT_BUFFER yy_current_buffer
        -:10896:
        -:10897:
        -:10898:/* yy_hold_char holds the character lost when yytext is formed. */
        -:10899:static char yy_hold_char;
        -:10900:
        -:10901:static int yy_n_chars;		/* number of characters read into yy_ch_buf */
        -:10902:
        -:10903:
        -:10904:int yyleng;
        -:10905:
        -:10906:/* Points to current character in buffer. */
        -:10907:static char *yy_c_buf_p = (char *) 0;
        -:10908:static int yy_init = 1;		/* whether we need to initialize */
        -:10909:static int yy_start = 0;	/* start state number */
        -:10910:
        -:10911:/* Flag which is used to allow yywrap()'s to do buffer switches
        -:10912: * instead of setting up a fresh yyin.  A bit of a hack ...
        -:10913: */
        -:10914:static int yy_did_buffer_switch_on_eof;
        -:10915:
        -:10916:void yyrestart YY_PROTO(( FILE *input_file ));
        -:10917:
        -:10918:void yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));
        -:10919:void yy_load_buffer_state YY_PROTO(( void ));
        -:10920:YY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *file, int size ));
        -:10921:void yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));
        -:10922:void yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));
        -:10923:void yy_flush_buffer YY_PROTO(( YY_BUFFER_STATE b ));
        -:10924:#define YY_FLUSH_BUFFER yy_flush_buffer( yy_current_buffer )
        -:10925:
        -:10926:YY_BUFFER_STATE yy_scan_buffer YY_PROTO(( char *base, yy_size_t size ));
        -:10927:YY_BUFFER_STATE yy_scan_string YY_PROTO(( yyconst char *yy_str ));
        -:10928:YY_BUFFER_STATE yy_scan_bytes YY_PROTO(( yyconst char *bytes, int len ));
        -:10929:
        -:10930:static void *yy_flex_alloc YY_PROTO(( yy_size_t ));
        -:10931:static void *yy_flex_realloc YY_PROTO(( void *, yy_size_t ));
        -:10932:static void yy_flex_free YY_PROTO(( void * ));
        -:10933:
        -:10934:#define yy_new_buffer yy_create_buffer
        -:10935:
        -:10936:#define yy_set_interactive(is_interactive) \
        -:10937:	{ \
        -:10938:	if ( ! yy_current_buffer ) \
        -:10939:		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
        -:10940:	yy_current_buffer->yy_is_interactive = is_interactive; \
        -:10941:	}
        -:10942:
        -:10943:#define yy_set_bol(at_bol) \
        -:10944:	{ \
        -:10945:	if ( ! yy_current_buffer ) \
        -:10946:		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
        -:10947:	yy_current_buffer->yy_at_bol = at_bol; \
        -:10948:	}
        -:10949:
        -:10950:#define YY_AT_BOL() (yy_current_buffer->yy_at_bol)
        -:10951:
        -:10952:typedef unsigned char YY_CHAR;
        -:10953:FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
        -:10954:typedef int yy_state_type;
        -:10955:extern char *yytext;
        -:10956:#define yytext_ptr yytext
        -:10957:
        -:10958:static yy_state_type yy_get_previous_state YY_PROTO(( void ));
        -:10959:static yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));
        -:10960:static int yy_get_next_buffer YY_PROTO(( void ));
        -:10961:static void yy_fatal_error YY_PROTO(( yyconst char msg[] ));
        -:10962:
        -:10963:/* Done after the current pattern has been matched and before the
        -:10964: * corresponding action - sets up yytext.
        -:10965: */
        -:10966:#define YY_DO_BEFORE_ACTION \
        -:10967:	yytext_ptr = yy_bp; \
        -:10968:	yyleng = (int) (yy_cp - yy_bp); \
        -:10969:	yy_hold_char = *yy_cp; \
        -:10970:	*yy_cp = '\0'; \
        -:10971:	yy_c_buf_p = yy_cp;
        -:10972:
        -:10973:#define YY_NUM_RULES 165
        -:10974:#define YY_END_OF_BUFFER 166
        -:10975:static yyconst short int yy_accept[769] =
        -:10976:    {   0,
        -:10977:        0,    0,    0,    0,   87,   87,  163,  163,    0,    0,
        -:10978:        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        -:10979:        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        -:10980:        0,    0,    0,    0,    0,    0,    0,    0,  166,  164,
        -:10981:        7,   18,  164,   16,    1,   17,  164,  164,  164,  164,
        -:10982:       15,  108,  100,  101,  108,   93,  108,  107,  108,  108,
        -:10983:      108,  107,   99,   89,  108,  108,   91,   92,   87,   88,
        -:10984:       87,   86,   85,   86,   86,  163,  163,   28,   29,   28,
        -:10985:       28,   28,   28,   28,   28,   31,   30,   32,   31,  113,
        -:10986:      109,  110,  112,  114,  141,  142,  141,  139,  138,  140,
        -:10987:
        -:10988:      115,  117,  115,  116,  115,  120,  120,  120,  120,  122,
        -:10989:      124,  122,  122,  122,  122,  123,  151,  155,  151,  154,
        -:10990:      156,  156,  152,  152,  152,  149,  150,  164,   82,  164,
        -:10991:       21,   22,   21,   20,  157,  159,  157,  160,  161,  147,
        -:10992:      147,  148,  147,  147,  147,  147,  147,  147,  147,   81,
        -:10993:       34,   33,   81,   81,   81,   81,   35,   81,   81,   81,
        -:10994:       81,   81,   81,   81,   81,   81,   81,   81,   81,   81,
        -:10995:       81,   81,   81,   81,   81,   81,   26,   23,   26,   24,
        -:10996:        7,   18,    0,   16,    1,   17,    0,    0,    0,   14,
        -:10997:        8,    0,    0,    0,    0,    4,    5,    0,    2,   15,
        -:10998:
        -:10999:      100,  101,    0,    0,    0,   95,    0,    0,  105,  105,
        -:11000:        0,  162,  162,  162,   94,    0,   99,   89,    0,    0,
        -:11001:        0,   91,   92,  104,   90,    0,   87,   88,   86,   85,
        -:11002:       85,   83,   84,  163,  163,   28,   29,   28,   28,   28,
        -:11003:       28,   31,   30,   32,  111,  112,  142,  138,  117,    0,
        -:11004:      118,  119,  124,  121,  151,  155,    0,  153,    0,  144,
        -:11005:      152,  152,  152,    0,   82,    0,   21,   22,   21,   19,
        -:11006:      157,  159,  158,  147,  147,  147,  148,  143,  147,  147,
        -:11007:      147,   34,   33,    0,   80,    0,    0,   81,   81,   81,
        -:11008:       81,   81,   81,   81,   81,   81,   81,   81,   81,   81,
        -:11009:
        -:11010:       81,   81,   81,   36,   81,   81,   81,   81,   81,   81,
        -:11011:       81,   81,   81,   81,    0,   25,   24,    0,   14,    8,
        -:11012:        0,   12,    0,    0,    0,    0,    0,    4,    5,    0,
        -:11013:        6,    0,   96,    0,   97,    0,    0,  105,  105,    0,
        -:11014:      105,  105,  105,  162,  162,    0,  106,   90,   98,    0,
        -:11015:      104,    0,   83,   84,   28,   28,   28,   27,   28,    0,
        -:11016:        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        -:11017:        0,  152,  152,  143,  143,  147,  147,    0,    0,   81,
        -:11018:       81,   81,   81,   81,   44,   81,   81,   81,   49,   81,
        -:11019:       81,   81,   81,   81,   81,   81,   81,   81,   81,   81,
        -:11020:
        -:11021:       81,   81,   81,   81,   81,   81,   81,   81,    0,   81,
        -:11022:       81,   81,   81,    0,    0,    0,   12,    0,    0,    0,
        -:11023:        0,    0,    0,    4,    5,    0,  105,  105,  105,  105,
        -:11024:      105,  105,  162,    0,    0,   28,   28,    0,    0,    0,
        -:11025:        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        -:11026:      152,  152,  147,  147,   37,   38,   81,   81,   81,   81,
        -:11027:       81,   81,   81,   81,   50,   51,   81,   81,   81,   55,
        -:11028:       81,   81,   81,   81,   81,   81,   60,   81,   81,   81,
        -:11029:       81,   81,   81,   67,    0,    0,    0,   81,   81,   81,
        -:11030:       81,    0,   13,    0,    0,    0,    0,    0,    0,  105,
        -:11031:
        -:11032:      105,  105,  105,  105,  105,    0,    0,   28,   28,  137,
        -:11033:        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        -:11034:        0,    0,  152,  152,  147,  147,   39,   81,   41,   81,
        -:11035:       43,   81,   81,   81,   47,   81,   52,   81,   81,   81,
        -:11036:       81,   81,   81,   81,   81,   81,   62,   81,   81,   65,
        -:11037:       81,    0,    0,    0,    0,   81,   81,   81,   81,    3,
        -:11038:        0,    0,    0,    0,  105,  105,  105,    0,    0,   28,
        -:11039:       28,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        -:11040:        0,    0,    0,  145,  146,  145,  146,   81,   42,   81,
        -:11041:       81,   81,   81,   81,   81,   81,   81,   81,   81,   81,
        -:11042:
        -:11043:       81,   78,   61,   81,   64,   81,    0,    0,    0,    0,
        -:11044:       81,   81,   69,   70,    0,   10,    0,   11,    0,  103,
        -:11045:        0,  102,    0,    0,    0,    0,    0,    0,    0,    0,
        -:11046:        0,    0,    0,    0,   81,   81,   81,   45,   81,   48,
        -:11047:       81,   81,   81,   81,   77,   81,   59,   63,   66,    0,
        -:11048:        0,    0,    0,   79,   81,    0,  102,    0,    0,    0,
        -:11049:        0,    0,    0,    0,    0,    0,    0,    0,    0,   81,
        -:11050:       81,   81,   46,   81,   81,   56,   81,   81,    0,    0,
        -:11051:        0,    0,   68,    0,    9,    0,  125,  126,  127,  128,
        -:11052:      129,  130,  131,  132,  133,  134,  135,    0,   81,   81,
        -:11053:
        -:11054:       81,   81,   81,   81,   81,    0,    0,    0,    0,    0,
        -:11055:      136,   81,   81,   81,   81,   54,   81,   81,    0,    0,
        -:11056:        0,    0,    0,    0,   81,   81,   81,   53,   81,   58,
        -:11057:        0,    0,    0,    0,    0,    0,   81,   81,   81,   81,
        -:11058:       72,    0,    0,    0,    0,   73,   81,   81,   81,   81,
        -:11059:       71,    0,   75,    0,   81,   81,   81,   74,   76,   81,
        -:11060:       81,   81,   81,   81,   81,   57,   40,    0
        -:11061:    } ;
        -:11062:
        -:11063:static yyconst int yy_ec[256] =
        -:11064:    {   0,
        -:11065:        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
        -:11066:        1,    1,    4,    1,    1,    1,    1,    1,    1,    1,
        -:11067:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:11068:        1,    2,    1,    5,    6,    7,    8,    1,    9,   10,
        -:11069:       10,   11,   12,   13,   14,   10,   15,   16,   16,   16,
        -:11070:       16,   16,   16,   16,   17,   18,   19,   20,    1,   21,
        -:11071:       22,   23,   10,    1,   31,   32,   33,   34,   35,   36,
        -:11072:       37,   38,   39,   40,   41,   42,   43,   44,   45,   46,
        -:11073:       47,   48,   49,   50,   51,   52,   53,   54,   55,   47,
        -:11074:       26,   27,   28,   29,   30,    1,   31,   32,   33,   34,
        -:11075:
        -:11076:       35,   36,   37,   38,   39,   40,   41,   42,   43,   44,
        -:11077:       45,   46,   47,   48,   49,   50,   51,   52,   53,   54,
        -:11078:       55,   47,   56,   57,   58,    1,    1,    1,    1,    1,
        -:11079:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:11080:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:11081:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:11082:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:11083:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:11084:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:11085:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:11086:
        -:11087:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:11088:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:11089:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:11090:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:11091:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:11092:        1,    1,    1,    1,    1
        -:11093:    } ;
        -:11094:
        -:11095:static yyconst int yy_meta[59] =
        -:11096:    {   0,
        -:11097:        1,    1,    2,    1,    3,    1,    1,    1,    4,    1,
        -:11098:        5,    6,    1,    7,    4,    8,    8,    8,    8,    1,
        -:11099:        1,    1,    1,    9,   10,    1,   11,   12,    1,   13,
        -:11100:       14,   14,   14,   14,   14,   14,   15,   15,   15,   15,
        -:11101:       15,   15,   15,   15,   15,   15,   15,   15,   15,   15,
        -:11102:       15,   15,   15,   15,   15,    4,    1,   16
        -:11103:    } ;
        -:11104:
        -:11105:static yyconst short int yy_base[858] =
        -:11106:    {   0,
        -:11107:        0,   58,  115,  172,  120,  129, 2712, 2711,  230, 2705,
        -:11108:      136,  141,  288,    0, 2683, 2682,  144,  151,  185,  191,
        -:11109:      178,  188,  344,  347,  375,    0,  125,  131,  147,  216,
        -:11110:      431,  434,  461,    0,  519,    0,  205,  349, 2710, 2716,
        -:11111:      353, 2716, 2706,    0,  360, 2716, 2705,  144,  570, 2696,
        -:11112:        0, 2716,  577, 2716, 2703, 2716,  438, 2716, 2684,  126,
        -:11113:      149,  427,  591, 2716, 2701,  141, 2682, 2716,    0, 2716,
        -:11114:     2699,    0, 2699, 2697,  155, 2696, 2716,    0, 2716, 2695,
        -:11115:     2716,    0, 2662, 2641, 2637,    0, 2692, 2716, 2690, 2716,
        -:11116:     2716, 2663,    0, 2716, 2716, 2716, 2688, 2716,  431, 2716,
        -:11117:
        -:11118:     2716, 2716, 2687, 2716,  567, 2716, 2669,  571,  164, 2716,
        -:11119:     2716, 2685,    0, 2667,  573, 2716,    0, 2716, 2683, 2716,
        -:11120:      573, 2674,    0, 2649, 2628, 2716, 2716,  222, 2716,  356,
        -:11121:      448, 2716,  450, 2667,    0, 2716, 2678, 2716,    0,    0,
        -:11122:      198, 2716, 2677, 2621, 2716, 2667,    0, 2642, 2621, 2716,
        -:11123:     2673, 2716, 2671, 2668, 2640, 2639, 2716,  544, 2639,  579,
        -:11124:     2634, 2635,  318,    0, 2623, 2631,  424,  562, 2614,  587,
        -:11125:     2629, 2613, 2618, 2626, 2629, 2604, 2716, 2716, 2653,  612,
        -:11126:      634, 2716, 2654,    0,  637, 2716, 2653,  600, 2616,    0,
        -:11127:        0,  641,  647,  651,  669,    0,    0,  453, 2716,    0,
        -:11128:
        -:11129:      672, 2716, 2651, 2597,  605, 2716, 2649, 2616,  620,  657,
        -:11130:      645, 2716,  662,    0, 2716, 2592,  688, 2716, 2646, 2592,
        -:11131:     2636, 2625, 2716,    0, 2716, 2610,    0, 2716,    0,    0,
        -:11132:     2642,    0,    0, 2640, 2716,    0, 2716,    0, 2602, 2598,
        -:11133:      745,    0, 2638, 2716, 2716,    0, 2716,  688, 2716,  773,
        -:11134:     2716, 2716, 2716, 2716,    0, 2716,  673, 2716,    0, 2716,
        -:11135:        0, 2599, 2595,  690, 2716,  698,  707, 2716,  709, 2716,
        -:11136:        0, 2716, 2716,    0,  596, 2579, 2716,  827,    0, 2596,
        -:11137:     2592, 2632, 2716, 2628, 2716, 2593, 2592,    0,  642, 2582,
        -:11138:      563, 2617, 2579,  620, 2578, 2577, 2583,  669, 2570, 2584,
        -:11139:
        -:11140:     2572,    0, 2569, 2716, 2570, 2571, 2579, 2582,  685,  125,
        -:11141:     2570, 2567, 2566,  688, 2608, 2716,  716, 2568,    0,    0,
        -:11142:      720, 2716, 2608,  884, 2562, 2559, 2569,    0,    0,  723,
        -:11143:     2716,  739, 2716,  805, 2716,  808, 2562,  787,  869,  876,
        -:11144:      930,  881,  973,  800,    0, 2548, 2716, 2716, 2716, 2570,
        -:11145:        0, 2559,    0,    0, 2568, 2557,    0, 2716,    0, 1009,
        -:11146:     2581,  678,  870,  871,  874,  879,  913,  992,  974, 1013,
        -:11147:      885, 2565, 2554,    0, 1067, 2563, 2552, 2546, 2545, 2557,
        -:11148:     2562, 2561, 2550, 2557,    0, 2554, 2537, 2556,    0, 2536,
        -:11149:     2543, 2533, 2548, 2568, 2537, 2549, 2544, 2542, 2541, 2532,
        -:11150:
        -:11151:     2539, 2540, 2538, 2539,  578, 2520, 2538, 2525,  860, 2526,
        -:11152:     2528, 2521, 2517, 2529,  817, 1044, 2716,  822, 1095,  914,
        -:11153:     2532, 2523, 2517,    0,    0, 2524, 1102, 1025, 1142, 2539,
        -:11154:     1028, 1163, 2716, 2513, 2521, 2523, 2507,    0, 2526, 1058,
        -:11155:      891, 1014, 1019,  894, 1038, 1080, 1072, 1086, 1083, 1081,
        -:11156:     2520, 2504, 2518, 2502, 2716, 2716, 2505, 2493, 2492, 2495,
        -:11157:     2507, 1148, 2507, 2492,    0,    0, 2492, 2493, 2507,    0,
        -:11158:     2525, 2490, 2498, 2522, 2485, 2495,    0, 2500, 2491, 2487,
        -:11159:     2479, 2479, 2483,    0,  875, 2494, 2481, 2494, 2480, 2475,
        -:11160:     2491, 2519, 2716,  920,  999, 2465, 2474, 2468, 2494, 2496,
        -:11161:
        -:11162:     1105, 1184, 1081,  902,  969, 2479, 2491, 2463, 2477, 2716,
        -:11163:      165, 1090, 1144, 1143, 1147, 1163, 1095, 1145, 1037, 1085,
        -:11164:     1150, 1173, 2461, 2475, 2459, 2473,    0, 2458,    0, 2460,
        -:11165:        0, 1165, 2454, 2469,    0, 2461,    0, 2471, 2410, 2414,
        -:11166:     2434, 2400, 2393, 2405, 2385, 2382,    0, 2383, 2335,    0,
        -:11167:     2335, 2330, 2326, 2309, 2278, 2259, 2269, 2268, 2256, 2297,
        -:11168:     1046, 2238, 2242, 2253, 1179, 1142, 1145, 2247, 2246,    0,
        -:11169:        0, 1191, 1192, 1172, 1201, 1202, 1204, 1205, 1206, 1207,
        -:11170:     1209, 1210, 1208,    0,    0,    0,    0, 2254,    0, 2221,
        -:11171:     2229, 2218, 2208, 2200, 2209, 2198, 2195, 2165, 2168, 2149,
        -:11172:
        -:11173:     2132,    0,    0, 2129,    0, 2139, 2143, 2134, 2124, 2137,
        -:11174:     2117, 2116,    0,    0, 1228, 2716, 1232, 2716, 2111, 2716,
        -:11175:     2117, 2716, 2115, 2114, 2108, 2107, 2106, 2103, 2102, 2098,
        -:11176:     2095, 2063, 2047, 1213, 2012, 1986, 1975,    0, 1954,    0,
        -:11177:     1947, 1950, 1941, 1945,    0, 1942,    0,    0,    0, 1938,
        -:11178:     1940, 1934, 1905,    0, 1872, 1234, 2716, 1888, 1882, 1881,
        -:11179:     1864, 1848, 1832, 1828, 1827, 1826, 1823, 1806, 1809, 1784,
        -:11180:     1787, 1772,    0, 1781, 1786,    0, 1766, 1767, 1759, 1744,
        -:11181:     1213, 1736,    0, 1236, 2716, 1245, 2716, 2716, 2716, 2716,
        -:11182:     2716, 2716, 2716, 2716, 2716, 2716, 2716, 1750, 1727, 1720,
        -:11183:
        -:11184:     1701, 1687, 1670, 1681, 1667, 1679, 1659,  689, 1658, 1671,
        -:11185:     2716, 1657, 1627, 1621, 1635,    0, 1603, 1596, 1595, 1608,
        -:11186:     1602, 1587, 1586, 1583, 1581, 1587, 1555,    0, 1547,    0,
        -:11187:     1527, 1507, 1520, 1503, 1483, 1482, 1485, 1443, 1440, 1228,
        -:11188:     2716, 1225, 1224, 1206, 1210, 2716, 1213, 1202, 1018,  948,
        -:11189:     2716,  945, 2716,  884,  780,  771,  779, 2716, 2716,  689,
        -:11190:      673,  581,  408,  318,   86,    0,    0, 2716, 1263, 1279,
        -:11191:     1295, 1311, 1327, 1343, 1359, 1375, 1391, 1407, 1423, 1439,
        -:11192:     1455, 1471, 1481, 1496, 1505, 1520, 1536, 1545, 1560, 1576,
        -:11193:     1592, 1608, 1624, 1634, 1649, 1659, 1674, 1690, 1706, 1718,
        -:11194:
        -:11195:     1728, 1743, 1759, 1775, 1791, 1807, 1817, 1832, 1843, 1236,
        -:11196:     1858, 1874, 1890, 1898, 1905, 1920, 1936, 1952, 1968, 1977,
        -:11197:     1985, 2001, 2017, 2033, 2049, 2065, 2081, 2097, 2113, 2123,
        -:11198:     2138, 2148, 2155, 2170, 2182, 2192, 2207, 2223, 2239, 2255,
        -:11199:     2265, 2280, 2291, 2306, 2322, 2338, 2354, 2364, 2373, 2388,
        -:11200:     2404, 2420, 2429, 2437, 2453, 2469, 2485
        -:11201:    } ;
        -:11202:
        -:11203:static yyconst short int yy_def[858] =
        -:11204:    {   0,
        -:11205:      768,  768,  769,  769,  770,  771,  772,  772,  768,    9,
        -:11206:      773,  773,  768,   13,  774,  774,  775,  775,  776,  776,
        -:11207:      777,  777,  778,  778,  768,   25,  779,  779,  780,  780,
        -:11208:      781,  781,  768,   33,  768,   35,  782,  782,  768,  768,
        -:11209:      768,  768,  768,  783,  768,  768,  768,  768,  784,  768,
        -:11210:      785,  768,  768,  768,  768,  768,  768,  768,  768,  786,
        -:11211:      787,  788,  768,  768,  768,  768,  768,  768,  789,  768,
        -:11212:      789,  790,  791,  790,  790,  792,  768,  793,  768,  793,
        -:11213:      768,  794,  794,  794,  793,  795,  768,  768,  795,  768,
        -:11214:      768,  768,  796,  768,  768,  768,  768,  768,  768,  768,
        -:11215:
        -:11216:      768,  768,  768,  768,  787,  768,  768,  787,  797,  768,
        -:11217:      768,  768,  798,  768,  787,  768,  799,  768,  799,  768,
        -:11218:      800,  768,  801,  801,  801,  768,  768,  802,  768,  802,
        -:11219:      803,  768,  803,  768,  804,  768,  804,  768,  805,  806,
        -:11220:      806,  768,  806,  806,  768,  806,  807,  807,  807,  768,
        -:11221:      768,  768,  768,  808,  768,  768,  768,  809,  809,  809,
        -:11222:      809,  809,  809,  809,  809,  809,  809,  810,  809,  809,
        -:11223:      809,  809,  809,  809,  809,  809,  768,  768,  811,  768,
        -:11224:      768,  768,  768,  783,  768,  768,  768,  768,  768,  812,
        -:11225:      813,  768,  768,  768,  768,  814,  815,  816,  768,  785,
        -:11226:
        -:11227:      768,  768,  768,  768,  817,  768,  768,  768,  818,  818,
        -:11228:      819,  768,  768,  820,  768,  821,  768,  768,  768,  768,
        -:11229:      768,  768,  768,  822,  768,  768,  823,  768,  824,  825,
        -:11230:      825,  826,  827,  828,  768,  829,  768,  830,  830,  830,
        -:11231:      768,  831,  768,  768,  768,  832,  768,  768,  768,  833,
        -:11232:      768,  768,  768,  768,  834,  768,  835,  768,  835,  768,
        -:11233:      836,  836,  836,  837,  768,  837,  838,  768,  838,  768,
        -:11234:      839,  768,  768,  840,  840,  840,  768,  768,  841,  841,
        -:11235:      841,  768,  768,  842,  768,  768,  768,  843,  843,  843,
        -:11236:      843,  843,  843,  843,  843,  843,  843,  843,  843,  843,
        -:11237:
        -:11238:      843,  843,  843,  768,  843,  843,  843,  843,  843,  843,
        -:11239:      843,  843,  843,  843,  844,  768,  768,  768,  845,  846,
        -:11240:      847,  768,  768,  768,  768,  768,  768,  848,  849,  850,
        -:11241:      768,  850,  768,  851,  768,  851,  768,  852,  852,  852,
        -:11242:      768,  852,  852,  768,  853,  854,  768,  768,  768,  768,
        -:11243:      855,  768,  826,  827,  830,  830,  241,  768,  241,  241,
        -:11244:      833,  833,  833,  833,  833,  833,  833,  833,  833,  833,
        -:11245:      833,  836,  836,  278,  278,  841,  841,  768,  768,  843,
        -:11246:      843,  843,  843,  843,  843,  843,  843,  843,  843,  843,
        -:11247:      843,  843,  843,  843,  843,  843,  843,  843,  843,  843,
        -:11248:
        -:11249:      843,  843,  843,  843,  843,  843,  843,  843,  768,  843,
        -:11250:      843,  843,  843,  768,  847,  847,  768,  847,  847,  768,
        -:11251:      768,  768,  768,  848,  849,  768,  341,  852,  343,  341,
        -:11252:      852,  343,  768,  768,  768,  830,  830,  360,  768,  833,
        -:11253:      833,  833,  833,  833,  833,  833,  833,  833,  833,  833,
        -:11254:      836,  836,  841,  841,  768,  768,  843,  843,  843,  843,
        -:11255:      843,  843,  843,  843,  843,  843,  843,  843,  843,  843,
        -:11256:      843,  843,  843,  843,  843,  843,  843,  843,  843,  843,
        -:11257:      843,  843,  843,  843,  768,  768,  768,  843,  843,  843,
        -:11258:      843,  768,  768,  847,  847,  768,  768,  768,  768,  427,
        -:11259:
        -:11260:      852,  343,  852,  852,  852,  768,  768,  830,  830,  768,
        -:11261:      833,  833,  833,  833,  833,  833,  833,  833,  833,  833,
        -:11262:      833,  833,  836,  836,  841,  841,  843,  843,  843,  843,
        -:11263:      843,  843,  843,  843,  843,  843,  843,  843,  843,  843,
        -:11264:      843,  843,  843,  843,  843,  843,  843,  843,  843,  843,
        -:11265:      843,  768,  768,  768,  768,  843,  843,  843,  843,  768,
        -:11266:      856,  768,  768,  768,  852,  852,  852,  768,  768,  830,
        -:11267:      830,  833,  833,  833,  833,  833,  833,  833,  833,  833,
        -:11268:      833,  833,  833,  836,  836,  841,  841,  843,  843,  843,
        -:11269:      843,  843,  843,  843,  843,  843,  843,  843,  843,  843,
        -:11270:
        -:11271:      843,  843,  843,  843,  843,  843,  768,  768,  768,  768,
        -:11272:      843,  843,  843,  843,  856,  768,  856,  768,  768,  768,
        -:11273:      768,  768,  833,  833,  833,  833,  833,  833,  833,  833,
        -:11274:      833,  833,  833,  833,  843,  843,  843,  843,  843,  843,
        -:11275:      843,  843,  843,  843,  843,  843,  843,  843,  843,  768,
        -:11276:      768,  768,  768,  843,  843,  857,  768,  768,  768,  768,
        -:11277:      768,  768,  768,  768,  768,  768,  768,  768,  833,  843,
        -:11278:      843,  843,  843,  843,  843,  843,  843,  843,  768,  768,
        -:11279:      768,  768,  843,  857,  768,  857,  768,  768,  768,  768,
        -:11280:      768,  768,  768,  768,  768,  768,  768,  768,  843,  843,
        -:11281:
        -:11282:      843,  843,  843,  843,  843,  768,  768,  768,  768,  768,
        -:11283:      768,  843,  843,  843,  843,  843,  843,  843,  768,  768,
        -:11284:      768,  768,  768,  768,  843,  843,  843,  843,  843,  843,
        -:11285:      768,  768,  768,  768,  768,  768,  843,  843,  843,  843,
        -:11286:      768,  768,  768,  768,  768,  768,  843,  843,  843,  843,
        -:11287:      768,  768,  768,  768,  843,  843,  843,  768,  768,  843,
        -:11288:      843,  843,  843,  843,  843,  843,  843,    0,  768,  768,
        -:11289:      768,  768,  768,  768,  768,  768,  768,  768,  768,  768,
        -:11290:      768,  768,  768,  768,  768,  768,  768,  768,  768,  768,
        -:11291:      768,  768,  768,  768,  768,  768,  768,  768,  768,  768,
        -:11292:
        -:11293:      768,  768,  768,  768,  768,  768,  768,  768,  768,  768,
        -:11294:      768,  768,  768,  768,  768,  768,  768,  768,  768,  768,
        -:11295:      768,  768,  768,  768,  768,  768,  768,  768,  768,  768,
        -:11296:      768,  768,  768,  768,  768,  768,  768,  768,  768,  768,
        -:11297:      768,  768,  768,  768,  768,  768,  768,  768,  768,  768,
        -:11298:      768,  768,  768,  768,  768,  768,  768
        -:11299:    } ;
        -:11300:
        -:11301:static yyconst short int yy_nxt[2775] =
        -:11302:    {   0,
        -:11303:       40,   41,   42,   43,   40,   40,   40,   40,   40,   40,
        -:11304:       40,   40,   40,   40,   40,   40,   40,   40,   40,   40,
        -:11305:       40,   40,   40,   44,   44,   40,   40,   40,   40,   44,
        -:11306:       44,   44,   44,   44,   44,   44,   44,   44,   44,   44,
        -:11307:       44,   44,   44,   44,   44,   44,   44,   44,   44,   44,
        -:11308:       44,   44,   44,   44,   44,   40,   40,   40,   40,   45,
        -:11309:       46,   47,   40,   48,   40,   49,   40,   40,   40,   40,
        -:11310:       40,   40,   50,   40,   40,   40,   40,   40,   40,   40,
        -:11311:       40,   51,   51,   40,   40,   40,   40,   51,   51,   51,
        -:11312:       51,   51,   51,   51,   51,   51,   51,   51,   51,   51,
        -:11313:
        -:11314:       51,   51,   51,   51,   51,   51,   51,   51,   51,   51,
        -:11315:       51,   51,   51,   40,   40,   40,   53,   54,   55,   56,
        -:11316:      767,   57,   70,   71,   58,   58,   58,  129,  130,   58,
        -:11317:       73,   70,   74,  129,  130,   59,   75,   87,   88,   89,
        -:11318:       60,   61,   87,   88,   89,  188,   96,   97,  224,  132,
        -:11319:      133,  210,  211,   96,   97,  404,   98,  134,  405,   99,
        -:11320:       99,   99,   99,   98,  213,  213,   99,   99,   99,   99,
        -:11321:       62,   58,   58,   63,   64,   65,   56,  252,   57,   66,
        -:11322:       40,   58,   58,   58,  439,  189,   58,  102,  103,  104,
        -:11323:       40,  252,   67,  102,  103,  104,  225,   60,   61,  275,
        -:11324:
        -:11325:       68,  100,  214,  107,  108,  276,  109,  178,  100,  179,
        -:11326:      232,  105,  233,  107,  108,  572,  109,  105,  132,  133,
        -:11327:      180,  180,  180,  180,  265,  266,  134,   62,   58,   58,
        -:11328:       78,   78,   79,   80,   78,   78,   78,   78,   78,   78,
        -:11329:       81,   78,   78,   78,   78,   78,   78,   78,   78,   78,
        -:11330:       78,   78,   78,   82,   82,   78,   78,   78,   78,   82,
        -:11331:       82,   82,   82,   82,   82,   82,   82,   82,   82,   82,
        -:11332:       82,   82,   82,   82,   82,   82,   82,   83,   82,   82,
        -:11333:       82,   82,   82,   82,   84,   78,   78,   78,   90,   90,
        -:11334:       40,   90,   90,   90,   90,   90,   90,   90,   91,   90,
        -:11335:
        -:11336:       91,   90,   90,   90,   90,   90,   90,   90,   90,   90,
        -:11337:       92,   93,   93,   90,   90,   90,   90,   93,   93,   93,
        -:11338:       93,   93,   93,   93,   93,   93,   93,   93,   93,   93,
        -:11339:       93,   93,   93,   93,   93,   93,   93,   93,   93,   93,
        -:11340:       93,   93,   93,   90,   90,   90,  111,  112,  296,  111,
        -:11341:      112,  178,  766,  179,  181,  182,  183,  113,  265,  266,
        -:11342:      113,  185,  186,  187,  180,  180,  180,  180,  297,  114,
        -:11343:      115,  116,  114,  115,  116,  117,  117,  118,  119,  120,
        -:11344:      117,  117,  117,  121,  117,  117,  117,  117,  117,  122,
        -:11345:      117,  117,  117,  117,  117,  117,  117,  117,  123,  123,
        -:11346:
        -:11347:      117,  117,  117,  117,  123,  123,  123,  123,  123,  123,
        -:11348:      123,  123,  123,  123,  123,  123,  123,  123,  123,  123,
        -:11349:      123,  123,  124,  123,  123,  123,  123,  123,  123,  125,
        -:11350:      126,  117,  127,  136,  137,  138,  136,  137,  138,  206,
        -:11351:      206,  207,  215,  215,  215,  215,  248,  248,  248,  248,
        -:11352:      268,  269,  268,  269,  300,  331,  332,  139,  301,  765,
        -:11353:      139,  140,  141,  142,  143,  140,  140,  140,  144,  140,
        -:11354:      140,  145,  140,  140,  140,  146,  140,  140,  140,  140,
        -:11355:      140,  140,  140,  140,  147,  147,  140,  140,  140,  140,
        -:11356:      147,  147,  147,  147,  147,  147,  147,  147,  147,  147,
        -:11357:
        -:11358:      147,  147,  147,  147,  147,  147,  147,  147,  148,  147,
        -:11359:      147,  147,  147,  147,  147,  149,  140,  140,  140,  150,
        -:11360:      151,  152,  153,  154,  150,  150,  150,  150,  150,  150,
        -:11361:      150,  150,  150,  150,  150,  155,  156,  150,  150,  150,
        -:11362:      157,  150,  150,  150,  150,  150,  150,  150,  150,  158,
        -:11363:      159,  160,  161,  162,  163,  164,  164,  165,  164,  164,
        -:11364:      166,  167,  168,  169,  170,  164,  171,  172,  164,  173,
        -:11365:      174,  175,  164,  176,  150,  150,  150,  191,  201,  202,
        -:11366:      203,  258,  213,  213,  204,  289,  213,  213,  213,  213,
        -:11367:      292,  290,  217,  218,  219,  383,  303,  275,  220,  259,
        -:11368:
        -:11369:      192,  188,  193,  276,  193,  221,  304,  335,  336,  293,
        -:11370:      193,  222,  384,  193,  194,  195,  480,  193,  196,  223,
        -:11371:      214,  306,  481,  197,  214,  198,  214,  317,  317,  317,
        -:11372:      317,  307,  764,  205,  308,  181,  182,  183,  185,  186,
        -:11373:      187,  189,  321,  322,  323,  339,  340,  205,  321,  322,
        -:11374:      323,  387,  321,  322,  323,  388,  324,  324,  324,  324,
        -:11375:      342,  342,  324,  324,  324,  324,  324,  324,  324,  324,
        -:11376:      321,  322,  323,  201,  202,  203,  341,  344,  344,  204,
        -:11377:      380,  258,  339,  340,  324,  324,  324,  324,  325,  217,
        -:11378:      218,  219,  265,  266,  381,  220,  326,  439,  343,  259,
        -:11379:
        -:11380:      265,  266,  221,  248,  248,  248,  248,  673,  222,  268,
        -:11381:      269,  268,  269,  327,  392,  402,  223,  409,  393,  440,
        -:11382:      410,  416,  417,  418,  403,  331,  332,  763,  205,  411,
        -:11383:      412,  317,  317,  317,  317,  419,  419,  419,  419,  721,
        -:11384:      413,  331,  332,  722,  205,  357,  357,  358,  359,  357,
        -:11385:      357,  357,  357,  357,  357,  360,  357,  357,  357,  357,
        -:11386:      357,  357,  357,  357,  357,  357,  357,  357,  360,  360,
        -:11387:      357,  357,  357,  357,  360,  360,  360,  360,  360,  360,
        -:11388:      360,  360,  360,  360,  360,  360,  360,  360,  360,  360,
        -:11389:      360,  360,  360,  360,  360,  360,  360,  360,  360,  360,
        -:11390:
        -:11391:      357,  357,  357,  362,  363,  364,  365,  335,  336,  366,
        -:11392:      335,  336,  339,  340,  367,  212,  212,  762,  368,  493,
        -:11393:      494,  369,  761,  370,  417,  494,  371,  374,  374,  760,
        -:11394:      374,  374,  374,  374,  374,  374,  374,  375,  374,  374,
        -:11395:      374,  374,  374,  374,  374,  374,  374,  374,  374,  374,
        -:11396:      375,  375,  374,  374,  374,  374,  375,  375,  375,  375,
        -:11397:      375,  375,  375,  375,  375,  375,  375,  375,  375,  375,
        -:11398:      375,  375,  375,  375,  375,  375,  375,  375,  375,  375,
        -:11399:      375,  375,  374,  374,  374,  420,  322,  323,  427,  439,
        -:11400:      439,  428,  428,  439,  339,  340,  431,  431,  439,  324,
        -:11401:
        -:11402:      324,  324,  324,  338,  439,  485,  339,  340,  486,  487,
        -:11403:      439,  441,  443,  439,  442,  420,  322,  323,  450,  552,
        -:11404:      759,  513,  493,  494,  516,  553,  444,  339,  340,  429,
        -:11405:      338,  338,  439,  338,  338,  338,  338,  338,  338,  338,
        -:11406:      338,  338,  338,  338,  338,  338,  338,  338,  338,  338,
        -:11407:      338,  338,  338,  430,  430,  339,  340,  445,  338,  338,
        -:11408:      430,  430,  430,  430,  430,  430,  430,  430,  430,  430,
        -:11409:      430,  430,  430,  430,  430,  430,  430,  430,  430,  430,
        -:11410:      430,  430,  430,  430,  430,  338,  338,  338,  432,  432,
        -:11411:      432,  432,  758,  439,  339,  340,  432,  757,  339,  340,
        -:11412:
        -:11413:      495,  417,  418,  432,  432,  432,  432,  432,  432,  360,
        -:11414:      360,  439,  438,  360,  360,  360,  360,  360,  360,  448,
        -:11415:      360,  360,  360,  360,  360,  360,  360,  360,  360,  360,
        -:11416:      360,  360,  439,  439,  360,  360,  360,  360,  439,  446,
        -:11417:      501,  501,  447,  504,  504,  416,  417,  418,  616,  617,
        -:11418:      339,  340,  638,  339,  340,  515,  439,  439,  449,  419,
        -:11419:      419,  419,  419,  514,  360,  360,  360,  375,  375,  580,
        -:11420:      375,  375,  375,  375,  375,  375,  375,  439,  375,  375,
        -:11421:      375,  375,  375,  375,  375,  375,  375,  375,  375,  375,
        -:11422:      517,  439,  375,  375,  375,  375,  495,  417,  418,  439,
        -:11423:
        -:11424:      439,  511,  439,  512,  439,  439,  339,  340,  209,  439,
        -:11425:      419,  419,  419,  419,  439,  519,  520,  581,  518,  522,
        -:11426:      566,  566,  375,  375,  375,  500,  500,  573,  521,  578,
        -:11427:      339,  340,  500,  500,  500,  500,  500,  500,  500,  500,
        -:11428:      500,  500,  500,  500,  500,  500,  500,  500,  500,  500,
        -:11429:      500,  500,  500,  500,  500,  500,  500,  502,  502,  502,
        -:11430:      502,  532,  439,  439,  439,  502,  439,  339,  340,  439,
        -:11431:      339,  340,  502,  502,  502,  502,  502,  502,  505,  505,
        -:11432:      505,  505,  439,  533,  582,  576,  505,  574,  579,  534,
        -:11433:      575,  439,  439,  505,  505,  505,  505,  505,  505,  567,
        -:11434:
        -:11435:      567,  567,  567,  590,  339,  340,  338,  567,  577,  583,
        -:11436:      439,  439,  625,  591,  567,  567,  567,  567,  567,  567,
        -:11437:      439,  439,  624,  439,  439,  439,  439,  439,  439,  439,
        -:11438:      616,  617,  439,  623,  616,  617,  685,  686,  685,  686,
        -:11439:      756,  628,  626,  632,  708,  755,  634,  685,  686,  302,
        -:11440:      302,  627,  629,  754,  753,  630,  631,  633,  752,  751,
        -:11441:      750,  709,  669,   52,   52,   52,   52,   52,   52,   52,
        -:11442:       52,   52,   52,   52,   52,   52,   52,   52,   52,   69,
        -:11443:       69,   69,   69,   69,   69,   69,   69,   69,   69,   69,
        -:11444:       69,   69,   69,   69,   69,   72,   72,   72,   72,   72,
        -:11445:
        -:11446:       72,   72,   72,   72,   72,   72,   72,   72,   72,   72,
        -:11447:       72,   76,   76,   76,   76,   76,   76,   76,   76,   76,
        -:11448:       76,   76,   76,   76,   76,   76,   76,   86,   86,   86,
        -:11449:       86,   86,   86,   86,   86,   86,   86,   86,   86,   86,
        -:11450:       86,   86,   86,   40,   40,   40,   40,   40,   40,   40,
        -:11451:       40,   40,   40,   40,   40,   40,   40,   40,   40,   95,
        -:11452:       95,   95,   95,   95,   95,   95,   95,   95,   95,   95,
        -:11453:       95,   95,   95,   95,   95,  101,  101,  101,  101,  101,
        -:11454:      101,  101,  101,  101,  101,  101,  101,  101,  101,  101,
        -:11455:      101,  106,  106,  106,  106,  106,  106,  106,  106,  106,
        -:11456:
        -:11457:      106,  106,  106,  106,  106,  106,  106,  110,  110,  110,
        -:11458:      110,  110,  110,  110,  110,  110,  110,  110,  110,  110,
        -:11459:      110,  110,  110,  128,  128,  128,  128,  128,  128,  128,
        -:11460:      128,  128,  128,  128,  128,  128,  128,  128,  128,  131,
        -:11461:      131,  131,  131,  131,  131,  131,  131,  131,  131,  131,
        -:11462:      131,  131,  131,  131,  131,  135,  135,  135,  135,  135,
        -:11463:      135,  135,  135,  135,  135,  135,  135,  135,  135,  135,
        -:11464:      135,  177,  177,  177,  177,  177,  177,  177,  177,  177,
        -:11465:      177,  177,  177,  177,  177,  177,  177,  184,  184,  184,
        -:11466:      184,  749,  748,  184,  184,  184,  190,  190,  190,  190,
        -:11467:
        -:11468:      190,  190,  190,  190,  190,  190,  190,  190,  190,  190,
        -:11469:      190,  200,  200,  200,  200,  747,  746,  200,  200,  200,
        -:11470:      209,  745,  209,  209,  209,  209,  209,  209,  209,  209,
        -:11471:      209,  209,  209,  209,  209,  209,  212,  744,  212,  212,
        -:11472:      212,  212,  212,  212,  212,  212,  212,  212,  212,  212,
        -:11473:      212,  212,  216,  216,  216,  743,  742,  216,  216,  216,
        -:11474:      227,  741,  227,  227,  227,  227,  227,  227,  227,  227,
        -:11475:      227,  227,  227,  227,  227,  227,  229,  740,  229,  229,
        -:11476:      229,  229,  229,  229,  229,  229,  229,  229,  229,  229,
        -:11477:      229,  229,  230,  739,  230,  230,  230,  230,  230,  230,
        -:11478:
        -:11479:      230,  230,  230,  230,  230,  230,  230,  230,  234,  234,
        -:11480:      234,  234,  234,  234,  234,  234,  234,  234,  234,  234,
        -:11481:      234,  234,  234,  234,  236,  738,  236,  236,  737,  236,
        -:11482:      236,  236,  736,  735,  236,  236,  734,  733,  732,  236,
        -:11483:      238,  238,  238,  238,  731,  730,  238,  238,  238,  242,
        -:11484:      729,  242,  242,  242,  242,  242,  242,  242,  242,  242,
        -:11485:      242,  242,  242,  242,  242,  246,  246,  246,  246,  728,
        -:11486:      727,  246,  246,  246,  251,  726,  251,  251,  251,  251,
        -:11487:      251,  251,  251,  251,  251,  251,  251,  251,  251,  251,
        -:11488:      254,  725,  254,  254,  254,  254,  254,  254,  254,  254,
        -:11489:
        -:11490:      254,  724,  254,  254,  254,  254,  255,  723,  720,  719,
        -:11491:      255,  255,  255,  255,  718,  717,  255,  255,  257,  716,
        -:11492:      257,  257,  257,  257,  257,  257,  257,  257,  257,  257,
        -:11493:      257,  257,  257,  257,  261,  261,  261,  261,  715,  714,
        -:11494:      261,  261,  261,  264,  264,  264,  264,  264,  264,  264,
        -:11495:      264,  264,  264,  264,  264,  264,  264,  264,  264,  267,
        -:11496:      267,  267,  267,  713,  267,  267,  267,  267,  267,  267,
        -:11497:      267,  267,  267,  267,  267,  271,  712,  711,  271,  271,
        -:11498:      271,  271,  271,  271,  271,  710,  271,  271,  271,  271,
        -:11499:      271,  273,  707,  273,  273,  273,  273,  273,  273,  273,
        -:11500:
        -:11501:      273,  273,  273,  273,  273,  273,  273,  274,  706,  274,
        -:11502:      274,  705,  274,  274,  274,  704,  703,  274,  274,  702,
        -:11503:      701,  700,  274,  279,  279,  279,  279,  699,  698,  279,
        -:11504:      279,  279,  284,  697,  284,  284,  284,  284,  284,  284,
        -:11505:      284,  284,  284,  284,  284,  284,  284,  284,  288,  288,
        -:11506:      696,  288,  288,  695,  694,  693,  288,  288,  315,  692,
        -:11507:      315,  315,  315,  315,  315,  315,  315,  315,  315,  315,
        -:11508:      315,  315,  315,  315,  319,  691,  319,  319,  319,  319,
        -:11509:      319,  319,  319,  319,  319,  319,  319,  319,  319,  319,
        -:11510:      320,  690,  320,  320,  320,  320,  320,  320,  320,  320,
        -:11511:
        -:11512:      320,  320,  320,  320,  320,  320,  328,  328,  689,  688,
        -:11513:      328,  328,  328,  329,  329,  687,  683,  329,  329,  329,
        -:11514:      330,  330,  330,  330,  330,  330,  330,  330,  330,  330,
        -:11515:      330,  330,  330,  330,  330,  330,  334,  334,  334,  334,
        -:11516:      334,  334,  334,  334,  334,  334,  334,  334,  334,  334,
        -:11517:      334,  334,  338,  682,  338,  338,  338,  338,  338,  338,
        -:11518:      338,  338,  338,  681,  338,  338,  338,  338,  209,  680,
        -:11519:      209,  209,  209,  209,  209,  209,  209,  209,  209,  209,
        -:11520:      209,  209,  209,  209,  345,  345,  679,  678,  677,  676,
        -:11521:      345,  346,  346,  346,  346,  675,  674,  346,  346,  346,
        -:11522:
        -:11523:      346,  351,  673,  351,  351,  351,  351,  351,  351,  351,
        -:11524:      351,  351,  351,  351,  351,  351,  351,  227,  672,  227,
        -:11525:      227,  227,  227,  227,  227,  227,  227,  227,  227,  227,
        -:11526:      227,  227,  227,  229,  671,  229,  229,  229,  229,  229,
        -:11527:      229,  229,  229,  229,  229,  229,  229,  229,  229,  230,
        -:11528:      670,  230,  230,  230,  230,  230,  230,  230,  230,  230,
        -:11529:      230,  230,  230,  230,  230,  353,  668,  353,  353,  353,
        -:11530:      353,  353,  353,  353,  353,  353,  353,  353,  353,  353,
        -:11531:      353,  354,  667,  354,  354,  354,  354,  354,  354,  354,
        -:11532:      354,  354,  354,  354,  354,  354,  354,  234,  234,  234,
        -:11533:
        -:11534:      234,  234,  234,  234,  234,  234,  234,  234,  234,  234,
        -:11535:      234,  234,  234,  236,  666,  236,  236,  665,  236,  236,
        -:11536:      236,  664,  663,  236,  236,  662,  661,  660,  236,  238,
        -:11537:      238,  238,  238,  659,  658,  238,  238,  238,  242,  657,
        -:11538:      242,  242,  242,  242,  242,  242,  242,  242,  242,  242,
        -:11539:      242,  242,  242,  242,  246,  246,  246,  246,  656,  655,
        -:11540:      246,  246,  246,  361,  361,  654,  653,  652,  361,  361,
        -:11541:      255,  651,  650,  649,  255,  255,  255,  255,  648,  647,
        -:11542:      255,  255,  257,  646,  257,  257,  257,  257,  257,  257,
        -:11543:      257,  257,  257,  257,  257,  257,  257,  257,  261,  261,
        -:11544:
        -:11545:      261,  261,  645,  644,  261,  261,  261,  264,  264,  264,
        -:11546:      264,  264,  264,  264,  264,  264,  264,  264,  264,  264,
        -:11547:      264,  264,  264,  267,  267,  267,  267,  643,  267,  267,
        -:11548:      267,  267,  267,  267,  267,  267,  267,  267,  267,  271,
        -:11549:      642,  641,  271,  271,  271,  271,  271,  271,  271,  640,
        -:11550:      271,  271,  271,  271,  271,  274,  639,  274,  274,  638,
        -:11551:      274,  274,  274,  637,  636,  274,  274,  635,  622,  621,
        -:11552:      274,  279,  279,  279,  279,  620,  619,  279,  279,  279,
        -:11553:      284,  618,  284,  284,  284,  284,  284,  284,  284,  284,
        -:11554:      284,  284,  284,  284,  284,  284,  288,  288,  560,  288,
        -:11555:
        -:11556:      288,  614,  613,  612,  288,  288,  315,  611,  315,  315,
        -:11557:      315,  315,  315,  315,  315,  315,  315,  315,  315,  315,
        -:11558:      315,  315,  319,  610,  319,  319,  319,  319,  319,  319,
        -:11559:      319,  319,  319,  319,  319,  319,  319,  319,  320,  609,
        -:11560:      320,  320,  320,  320,  320,  320,  320,  320,  320,  320,
        -:11561:      320,  320,  320,  320,  415,  415,  415,  415,  415,  415,
        -:11562:      415,  415,  415,  415,  415,  415,  415,  415,  415,  415,
        -:11563:      424,  424,  424,  424,  608,  607,  424,  424,  424,  425,
        -:11564:      425,  425,  425,  606,  605,  425,  425,  425,  330,  330,
        -:11565:      330,  330,  330,  330,  330,  330,  330,  330,  330,  330,
        -:11566:
        -:11567:      330,  330,  330,  330,  334,  334,  334,  334,  334,  334,
        -:11568:      334,  334,  334,  334,  334,  334,  334,  334,  334,  334,
        -:11569:      338,  604,  338,  338,  338,  338,  338,  338,  338,  338,
        -:11570:      338,  603,  338,  338,  338,  338,  433,  433,  602,  601,
        -:11571:      600,  599,  433,  346,  346,  346,  346,  598,  597,  346,
        -:11572:      346,  346,  346,  351,  596,  351,  351,  351,  351,  351,
        -:11573:      351,  351,  351,  351,  351,  351,  351,  351,  351,  615,
        -:11574:      615,  615,  615,  615,  615,  615,  615,  615,  615,  615,
        -:11575:      615,  615,  615,  615,  615,  684,  684,  684,  684,  684,
        -:11576:      684,  684,  684,  684,  684,  684,  684,  684,  684,  684,
        -:11577:
        -:11578:      684,  595,  594,  593,  592,  589,  588,  587,  586,  585,
        -:11579:      584,  571,  570,  569,  568,  565,  564,  563,  562,  561,
        -:11580:      560,  559,  558,  557,  556,  555,  554,  551,  550,  549,
        -:11581:      548,  547,  546,  545,  544,  543,  542,  541,  540,  539,
        -:11582:      538,  537,  536,  535,  531,  530,  529,  528,  527,  526,
        -:11583:      525,  524,  523,  510,  509,  508,  507,  506,  503,  499,
        -:11584:      498,  497,  496,  492,  491,  490,  489,  488,  484,  483,
        -:11585:      482,  479,  478,  477,  476,  475,  474,  473,  472,  471,
        -:11586:      470,  469,  468,  467,  466,  465,  464,  463,  462,  461,
        -:11587:      460,  459,  458,  457,  456,  455,  454,  453,  452,  451,
        -:11588:
        -:11589:      439,  437,  436,  435,  434,  347,  426,  423,  422,  421,
        -:11590:      322,  414,  316,  408,  407,  406,  401,  400,  399,  398,
        -:11591:      397,  396,  395,  394,  391,  390,  389,  386,  385,  382,
        -:11592:      379,  378,  285,  282,  377,  376,  278,  373,  372,  243,
        -:11593:      356,  355,  235,  231,  352,  350,  349,  348,  218,  347,
        -:11594:      337,  206,  333,  202,  318,  186,  182,  316,  314,  313,
        -:11595:      312,  311,  310,  309,  305,  299,  298,  295,  294,  291,
        -:11596:      287,  286,  285,  283,  282,  281,  280,  260,  278,  277,
        -:11597:      272,  270,  263,  262,  260,  256,  250,  253,  250,  249,
        -:11598:      247,  245,  244,  243,  241,  240,  239,  237,  235,  228,
        -:11599:
        -:11600:      231,  228,  226,  218,  208,  202,  199,  186,  182,  768,
        -:11601:       94,   94,   85,   77,   77,   39,  768,  768,  768,  768,
        -:11602:      768,  768,  768,  768,  768,  768,  768,  768,  768,  768,
        -:11603:      768,  768,  768,  768,  768,  768,  768,  768,  768,  768,
        -:11604:      768,  768,  768,  768,  768,  768,  768,  768,  768,  768,
        -:11605:      768,  768,  768,  768,  768,  768,  768,  768,  768,  768,
        -:11606:      768,  768,  768,  768,  768,  768,  768,  768,  768,  768,
        -:11607:      768,  768,  768,  768
        -:11608:    } ;
        -:11609:
        -:11610:static yyconst short int yy_chk[2775] =
        -:11611:    {   0,
        -:11612:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:11613:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:11614:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:11615:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:11616:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:11617:        1,    1,    1,    1,    1,    1,    1,    1,    2,    2,
        -:11618:        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
        -:11619:        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
        -:11620:        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
        -:11621:        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
        -:11622:
        -:11623:        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
        -:11624:        2,    2,    2,    2,    2,    2,    3,    3,    3,    3,
        -:11625:      765,    3,    5,    5,    3,    3,    3,   27,   27,    3,
        -:11626:        6,    6,    6,   28,   28,    3,    6,   11,   11,   11,
        -:11627:        3,    3,   12,   12,   12,   48,   17,   17,   66,   29,
        -:11628:       29,   60,   60,   18,   18,  310,   17,   29,  310,   17,
        -:11629:       17,   17,   17,   18,   61,   61,   18,   18,   18,   18,
        -:11630:        3,    3,    3,    4,    4,    4,    4,  109,    4,    4,
        -:11631:       21,    4,    4,    4,  511,   48,    4,   19,   19,   19,
        -:11632:       22,  109,    4,   20,   20,   20,   66,    4,    4,  141,
        -:11633:
        -:11634:        4,   17,   61,   21,   21,  141,   21,   37,   18,   37,
        -:11635:       75,   19,   75,   22,   22,  511,   22,   20,   30,   30,
        -:11636:       37,   37,   37,   37,  128,  128,   30,    4,    4,    4,
        -:11637:        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
        -:11638:        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
        -:11639:        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
        -:11640:        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
        -:11641:        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
        -:11642:        9,    9,    9,    9,    9,    9,    9,    9,   13,   13,
        -:11643:       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
        -:11644:
        -:11645:       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
        -:11646:       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
        -:11647:       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
        -:11648:       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
        -:11649:       13,   13,   13,   13,   13,   13,   23,   23,  163,   24,
        -:11650:       24,   38,  764,   38,   41,   41,   41,   23,  130,  130,
        -:11651:       24,   45,   45,   45,   38,   38,   38,   38,  163,   23,
        -:11652:       23,   23,   24,   24,   24,   25,   25,   25,   25,   25,
        -:11653:       25,   25,   25,   25,   25,   25,   25,   25,   25,   25,
        -:11654:       25,   25,   25,   25,   25,   25,   25,   25,   25,   25,
        -:11655:
        -:11656:       25,   25,   25,   25,   25,   25,   25,   25,   25,   25,
        -:11657:       25,   25,   25,   25,   25,   25,   25,   25,   25,   25,
        -:11658:       25,   25,   25,   25,   25,   25,   25,   25,   25,   25,
        -:11659:       25,   25,   25,   31,   31,   31,   32,   32,   32,   57,
        -:11660:       57,   57,   62,   62,   62,   62,   99,   99,   99,   99,
        -:11661:      131,  131,  133,  133,  167,  198,  198,   31,  167,  763,
        -:11662:       32,   33,   33,   33,   33,   33,   33,   33,   33,   33,
        -:11663:       33,   33,   33,   33,   33,   33,   33,   33,   33,   33,
        -:11664:       33,   33,   33,   33,   33,   33,   33,   33,   33,   33,
        -:11665:       33,   33,   33,   33,   33,   33,   33,   33,   33,   33,
        -:11666:
        -:11667:       33,   33,   33,   33,   33,   33,   33,   33,   33,   33,
        -:11668:       33,   33,   33,   33,   33,   33,   33,   33,   33,   35,
        -:11669:       35,   35,   35,   35,   35,   35,   35,   35,   35,   35,
        -:11670:       35,   35,   35,   35,   35,   35,   35,   35,   35,   35,
        -:11671:       35,   35,   35,   35,   35,   35,   35,   35,   35,   35,
        -:11672:       35,   35,   35,   35,   35,   35,   35,   35,   35,   35,
        -:11673:       35,   35,   35,   35,   35,   35,   35,   35,   35,   35,
        -:11674:       35,   35,   35,   35,   35,   35,   35,   49,   53,   53,
        -:11675:       53,  121,  105,  105,   53,  158,  108,  108,  115,  115,
        -:11676:      160,  158,   63,   63,   63,  291,  168,  275,   63,  121,
        -:11677:
        -:11678:       49,  188,   49,  275,   49,   63,  168,  205,  205,  160,
        -:11679:       49,   63,  291,   49,   49,   49,  405,   49,   49,   63,
        -:11680:      105,  170,  405,   49,  108,   49,  115,  180,  180,  180,
        -:11681:      180,  170,  762,   53,  170,  181,  181,  181,  185,  185,
        -:11682:      185,  188,  192,  192,  192,  209,  209,   63,  193,  193,
        -:11683:      193,  294,  194,  194,  194,  294,  192,  192,  192,  192,
        -:11684:      211,  211,  193,  193,  193,  193,  194,  194,  194,  194,
        -:11685:      195,  195,  195,  201,  201,  201,  210,  213,  213,  201,
        -:11686:      289,  257,  210,  210,  195,  195,  195,  195,  192,  217,
        -:11687:      217,  217,  264,  264,  289,  217,  194,  362,  211,  257,
        -:11688:
        -:11689:      266,  266,  217,  248,  248,  248,  248,  761,  217,  267,
        -:11690:      267,  269,  269,  195,  298,  309,  217,  314,  298,  362,
        -:11691:      314,  321,  321,  321,  309,  330,  330,  760,  201,  314,
        -:11692:      314,  317,  317,  317,  317,  321,  321,  321,  321,  708,
        -:11693:      314,  332,  332,  708,  217,  241,  241,  241,  241,  241,
        -:11694:      241,  241,  241,  241,  241,  241,  241,  241,  241,  241,
        -:11695:      241,  241,  241,  241,  241,  241,  241,  241,  241,  241,
        -:11696:      241,  241,  241,  241,  241,  241,  241,  241,  241,  241,
        -:11697:      241,  241,  241,  241,  241,  241,  241,  241,  241,  241,
        -:11698:      241,  241,  241,  241,  241,  241,  241,  241,  241,  241,
        -:11699:
        -:11700:      241,  241,  241,  250,  250,  250,  250,  334,  334,  250,
        -:11701:      336,  336,  338,  338,  250,  344,  344,  757,  250,  415,
        -:11702:      415,  250,  756,  250,  418,  418,  250,  278,  278,  755,
        -:11703:      278,  278,  278,  278,  278,  278,  278,  278,  278,  278,
        -:11704:      278,  278,  278,  278,  278,  278,  278,  278,  278,  278,
        -:11705:      278,  278,  278,  278,  278,  278,  278,  278,  278,  278,
        -:11706:      278,  278,  278,  278,  278,  278,  278,  278,  278,  278,
        -:11707:      278,  278,  278,  278,  278,  278,  278,  278,  278,  278,
        -:11708:      278,  278,  278,  278,  278,  324,  324,  324,  339,  363,
        -:11709:      364,  340,  340,  365,  339,  339,  342,  342,  366,  324,
        -:11710:
        -:11711:      324,  324,  324,  340,  371,  409,  342,  342,  409,  409,
        -:11712:      441,  363,  365,  444,  364,  420,  420,  420,  371,  485,
        -:11713:      754,  441,  494,  494,  444,  485,  366,  504,  504,  340,
        -:11714:      341,  341,  367,  341,  341,  341,  341,  341,  341,  341,
        -:11715:      341,  341,  341,  341,  341,  341,  341,  341,  341,  341,
        -:11716:      341,  341,  341,  341,  341,  341,  341,  367,  341,  341,
        -:11717:      341,  341,  341,  341,  341,  341,  341,  341,  341,  341,
        -:11718:      341,  341,  341,  341,  341,  341,  341,  341,  341,  341,
        -:11719:      341,  341,  341,  341,  341,  341,  341,  341,  343,  343,
        -:11720:      343,  343,  752,  369,  505,  505,  343,  750,  343,  343,
        -:11721:
        -:11722:      495,  495,  495,  343,  343,  343,  343,  343,  343,  360,
        -:11723:      360,  368,  360,  360,  360,  360,  360,  360,  360,  369,
        -:11724:      360,  360,  360,  360,  360,  360,  360,  360,  360,  360,
        -:11725:      360,  360,  370,  442,  360,  360,  360,  360,  443,  368,
        -:11726:      428,  428,  368,  431,  431,  416,  416,  416,  561,  561,
        -:11727:      428,  428,  749,  431,  431,  443,  519,  445,  370,  416,
        -:11728:      416,  416,  416,  442,  360,  360,  360,  375,  375,  519,
        -:11729:      375,  375,  375,  375,  375,  375,  375,  440,  375,  375,
        -:11730:      375,  375,  375,  375,  375,  375,  375,  375,  375,  375,
        -:11731:      445,  447,  375,  375,  375,  375,  419,  419,  419,  446,
        -:11732:
        -:11733:      450,  440,  449,  440,  520,  448,  503,  503,  503,  512,
        -:11734:      419,  419,  419,  419,  517,  447,  448,  520,  446,  450,
        -:11735:      501,  501,  375,  375,  375,  427,  427,  512,  449,  517,
        -:11736:      501,  501,  427,  427,  427,  427,  427,  427,  427,  427,
        -:11737:      427,  427,  427,  427,  427,  427,  427,  427,  427,  427,
        -:11738:      427,  427,  427,  427,  427,  427,  427,  429,  429,  429,
        -:11739:      429,  462,  514,  513,  518,  429,  515,  566,  566,  521,
        -:11740:      567,  567,  429,  429,  429,  429,  429,  429,  432,  432,
        -:11741:      432,  432,  516,  462,  521,  515,  432,  513,  518,  462,
        -:11742:      514,  574,  522,  432,  432,  432,  432,  432,  432,  502,
        -:11743:
        -:11744:      502,  502,  502,  532,  565,  565,  565,  502,  516,  522,
        -:11745:      572,  573,  574,  532,  502,  502,  502,  502,  502,  502,
        -:11746:      575,  576,  573,  577,  578,  579,  580,  583,  581,  582,
        -:11747:      615,  615,  634,  572,  617,  617,  656,  656,  684,  684,
        -:11748:      748,  577,  575,  581,  681,  747,  583,  686,  686,  810,
        -:11749:      810,  576,  578,  745,  744,  579,  580,  582,  743,  742,
        -:11750:      740,  681,  634,  769,  769,  769,  769,  769,  769,  769,
        -:11751:      769,  769,  769,  769,  769,  769,  769,  769,  769,  770,
        -:11752:      770,  770,  770,  770,  770,  770,  770,  770,  770,  770,
        -:11753:      770,  770,  770,  770,  770,  771,  771,  771,  771,  771,
        -:11754:
        -:11755:      771,  771,  771,  771,  771,  771,  771,  771,  771,  771,
        -:11756:      771,  772,  772,  772,  772,  772,  772,  772,  772,  772,
        -:11757:      772,  772,  772,  772,  772,  772,  772,  773,  773,  773,
        -:11758:      773,  773,  773,  773,  773,  773,  773,  773,  773,  773,
        -:11759:      773,  773,  773,  774,  774,  774,  774,  774,  774,  774,
        -:11760:      774,  774,  774,  774,  774,  774,  774,  774,  774,  775,
        -:11761:      775,  775,  775,  775,  775,  775,  775,  775,  775,  775,
        -:11762:      775,  775,  775,  775,  775,  776,  776,  776,  776,  776,
        -:11763:      776,  776,  776,  776,  776,  776,  776,  776,  776,  776,
        -:11764:      776,  777,  777,  777,  777,  777,  777,  777,  777,  777,
        -:11765:
        -:11766:      777,  777,  777,  777,  777,  777,  777,  778,  778,  778,
        -:11767:      778,  778,  778,  778,  778,  778,  778,  778,  778,  778,
        -:11768:      778,  778,  778,  779,  779,  779,  779,  779,  779,  779,
        -:11769:      779,  779,  779,  779,  779,  779,  779,  779,  779,  780,
        -:11770:      780,  780,  780,  780,  780,  780,  780,  780,  780,  780,
        -:11771:      780,  780,  780,  780,  780,  781,  781,  781,  781,  781,
        -:11772:      781,  781,  781,  781,  781,  781,  781,  781,  781,  781,
        -:11773:      781,  782,  782,  782,  782,  782,  782,  782,  782,  782,
        -:11774:      782,  782,  782,  782,  782,  782,  782,  783,  783,  783,
        -:11775:      783,  739,  738,  783,  783,  783,  784,  784,  784,  784,
        -:11776:
        -:11777:      784,  784,  784,  784,  784,  784,  784,  784,  784,  784,
        -:11778:      784,  785,  785,  785,  785,  737,  736,  785,  785,  785,
        -:11779:      786,  735,  786,  786,  786,  786,  786,  786,  786,  786,
        -:11780:      786,  786,  786,  786,  786,  786,  787,  734,  787,  787,
        -:11781:      787,  787,  787,  787,  787,  787,  787,  787,  787,  787,
        -:11782:      787,  787,  788,  788,  788,  733,  732,  788,  788,  788,
        -:11783:      789,  731,  789,  789,  789,  789,  789,  789,  789,  789,
        -:11784:      789,  789,  789,  789,  789,  789,  790,  729,  790,  790,
        -:11785:      790,  790,  790,  790,  790,  790,  790,  790,  790,  790,
        -:11786:      790,  790,  791,  727,  791,  791,  791,  791,  791,  791,
        -:11787:
        -:11788:      791,  791,  791,  791,  791,  791,  791,  791,  792,  792,
        -:11789:      792,  792,  792,  792,  792,  792,  792,  792,  792,  792,
        -:11790:      792,  792,  792,  792,  793,  726,  793,  793,  725,  793,
        -:11791:      793,  793,  724,  723,  793,  793,  722,  721,  720,  793,
        -:11792:      794,  794,  794,  794,  719,  718,  794,  794,  794,  795,
        -:11793:      717,  795,  795,  795,  795,  795,  795,  795,  795,  795,
        -:11794:      795,  795,  795,  795,  795,  796,  796,  796,  796,  715,
        -:11795:      714,  796,  796,  796,  797,  713,  797,  797,  797,  797,
        -:11796:      797,  797,  797,  797,  797,  797,  797,  797,  797,  797,
        -:11797:      798,  712,  798,  798,  798,  798,  798,  798,  798,  798,
        -:11798:
        -:11799:      798,  710,  798,  798,  798,  798,  799,  709,  707,  706,
        -:11800:      799,  799,  799,  799,  705,  704,  799,  799,  800,  703,
        -:11801:      800,  800,  800,  800,  800,  800,  800,  800,  800,  800,
        -:11802:      800,  800,  800,  800,  801,  801,  801,  801,  702,  701,
        -:11803:      801,  801,  801,  802,  802,  802,  802,  802,  802,  802,
        -:11804:      802,  802,  802,  802,  802,  802,  802,  802,  802,  803,
        -:11805:      803,  803,  803,  700,  803,  803,  803,  803,  803,  803,
        -:11806:      803,  803,  803,  803,  803,  804,  699,  698,  804,  804,
        -:11807:      804,  804,  804,  804,  804,  682,  804,  804,  804,  804,
        -:11808:      804,  805,  680,  805,  805,  805,  805,  805,  805,  805,
        -:11809:
        -:11810:      805,  805,  805,  805,  805,  805,  805,  806,  679,  806,
        -:11811:      806,  678,  806,  806,  806,  677,  675,  806,  806,  674,
        -:11812:      672,  671,  806,  807,  807,  807,  807,  670,  669,  807,
        -:11813:      807,  807,  808,  668,  808,  808,  808,  808,  808,  808,
        -:11814:      808,  808,  808,  808,  808,  808,  808,  808,  809,  809,
        -:11815:      667,  809,  809,  666,  665,  664,  809,  809,  811,  663,
        -:11816:      811,  811,  811,  811,  811,  811,  811,  811,  811,  811,
        -:11817:      811,  811,  811,  811,  812,  662,  812,  812,  812,  812,
        -:11818:      812,  812,  812,  812,  812,  812,  812,  812,  812,  812,
        -:11819:      813,  661,  813,  813,  813,  813,  813,  813,  813,  813,
        -:11820:
        -:11821:      813,  813,  813,  813,  813,  813,  814,  814,  660,  659,
        -:11822:      814,  814,  814,  815,  815,  658,  655,  815,  815,  815,
        -:11823:      816,  816,  816,  816,  816,  816,  816,  816,  816,  816,
        -:11824:      816,  816,  816,  816,  816,  816,  817,  817,  817,  817,
        -:11825:      817,  817,  817,  817,  817,  817,  817,  817,  817,  817,
        -:11826:      817,  817,  818,  653,  818,  818,  818,  818,  818,  818,
        -:11827:      818,  818,  818,  652,  818,  818,  818,  818,  819,  651,
        -:11828:      819,  819,  819,  819,  819,  819,  819,  819,  819,  819,
        -:11829:      819,  819,  819,  819,  820,  820,  650,  646,  644,  643,
        -:11830:      820,  821,  821,  821,  821,  642,  641,  821,  821,  821,
        -:11831:
        -:11832:      821,  822,  639,  822,  822,  822,  822,  822,  822,  822,
        -:11833:      822,  822,  822,  822,  822,  822,  822,  823,  637,  823,
        -:11834:      823,  823,  823,  823,  823,  823,  823,  823,  823,  823,
        -:11835:      823,  823,  823,  824,  636,  824,  824,  824,  824,  824,
        -:11836:      824,  824,  824,  824,  824,  824,  824,  824,  824,  825,
        -:11837:      635,  825,  825,  825,  825,  825,  825,  825,  825,  825,
        -:11838:      825,  825,  825,  825,  825,  826,  633,  826,  826,  826,
        -:11839:      826,  826,  826,  826,  826,  826,  826,  826,  826,  826,
        -:11840:      826,  827,  632,  827,  827,  827,  827,  827,  827,  827,
        -:11841:      827,  827,  827,  827,  827,  827,  827,  828,  828,  828,
        -:11842:
        -:11843:      828,  828,  828,  828,  828,  828,  828,  828,  828,  828,
        -:11844:      828,  828,  828,  829,  631,  829,  829,  630,  829,  829,
        -:11845:      829,  629,  628,  829,  829,  627,  626,  625,  829,  830,
        -:11846:      830,  830,  830,  624,  623,  830,  830,  830,  831,  621,
        -:11847:      831,  831,  831,  831,  831,  831,  831,  831,  831,  831,
        -:11848:      831,  831,  831,  831,  832,  832,  832,  832,  619,  612,
        -:11849:      832,  832,  832,  833,  833,  611,  610,  609,  833,  833,
        -:11850:      834,  608,  607,  606,  834,  834,  834,  834,  604,  601,
        -:11851:      834,  834,  835,  600,  835,  835,  835,  835,  835,  835,
        -:11852:      835,  835,  835,  835,  835,  835,  835,  835,  836,  836,
        -:11853:
        -:11854:      836,  836,  599,  598,  836,  836,  836,  837,  837,  837,
        -:11855:      837,  837,  837,  837,  837,  837,  837,  837,  837,  837,
        -:11856:      837,  837,  837,  838,  838,  838,  838,  597,  838,  838,
        -:11857:      838,  838,  838,  838,  838,  838,  838,  838,  838,  839,
        -:11858:      596,  595,  839,  839,  839,  839,  839,  839,  839,  594,
        -:11859:      839,  839,  839,  839,  839,  840,  593,  840,  840,  592,
        -:11860:      840,  840,  840,  591,  590,  840,  840,  588,  569,  568,
        -:11861:      840,  841,  841,  841,  841,  564,  563,  841,  841,  841,
        -:11862:      842,  562,  842,  842,  842,  842,  842,  842,  842,  842,
        -:11863:      842,  842,  842,  842,  842,  842,  843,  843,  560,  843,
        -:11864:
        -:11865:      843,  559,  558,  557,  843,  843,  844,  556,  844,  844,
        -:11866:      844,  844,  844,  844,  844,  844,  844,  844,  844,  844,
        -:11867:      844,  844,  845,  555,  845,  845,  845,  845,  845,  845,
        -:11868:      845,  845,  845,  845,  845,  845,  845,  845,  846,  554,
        -:11869:      846,  846,  846,  846,  846,  846,  846,  846,  846,  846,
        -:11870:      846,  846,  846,  846,  847,  847,  847,  847,  847,  847,
        -:11871:      847,  847,  847,  847,  847,  847,  847,  847,  847,  847,
        -:11872:      848,  848,  848,  848,  553,  552,  848,  848,  848,  849,
        -:11873:      849,  849,  849,  551,  549,  849,  849,  849,  850,  850,
        -:11874:      850,  850,  850,  850,  850,  850,  850,  850,  850,  850,
        -:11875:
        -:11876:      850,  850,  850,  850,  851,  851,  851,  851,  851,  851,
        -:11877:      851,  851,  851,  851,  851,  851,  851,  851,  851,  851,
        -:11878:      852,  548,  852,  852,  852,  852,  852,  852,  852,  852,
        -:11879:      852,  546,  852,  852,  852,  852,  853,  853,  545,  544,
        -:11880:      543,  542,  853,  854,  854,  854,  854,  541,  540,  854,
        -:11881:      854,  854,  854,  855,  539,  855,  855,  855,  855,  855,
        -:11882:      855,  855,  855,  855,  855,  855,  855,  855,  855,  856,
        -:11883:      856,  856,  856,  856,  856,  856,  856,  856,  856,  856,
        -:11884:      856,  856,  856,  856,  856,  857,  857,  857,  857,  857,
        -:11885:      857,  857,  857,  857,  857,  857,  857,  857,  857,  857,
        -:11886:
        -:11887:      857,  538,  536,  534,  533,  530,  528,  526,  525,  524,
        -:11888:      523,  509,  508,  507,  506,  500,  499,  498,  497,  496,
        -:11889:      492,  491,  490,  489,  488,  487,  486,  483,  482,  481,
        -:11890:      480,  479,  478,  476,  475,  474,  473,  472,  471,  469,
        -:11891:      468,  467,  464,  463,  461,  460,  459,  458,  457,  454,
        -:11892:      453,  452,  451,  439,  437,  436,  435,  434,  430,  426,
        -:11893:      423,  422,  421,  414,  413,  412,  411,  410,  408,  407,
        -:11894:      406,  404,  403,  402,  401,  400,  399,  398,  397,  396,
        -:11895:      395,  394,  393,  392,  391,  390,  388,  387,  386,  384,
        -:11896:      383,  382,  381,  380,  379,  378,  377,  376,  373,  372,
        -:11897:
        -:11898:      361,  356,  355,  352,  350,  346,  337,  327,  326,  325,
        -:11899:      323,  318,  315,  313,  312,  311,  308,  307,  306,  305,
        -:11900:      303,  301,  300,  299,  297,  296,  295,  293,  292,  290,
        -:11901:      287,  286,  284,  282,  281,  280,  276,  263,  262,  243,
        -:11902:      240,  239,  234,  231,  226,  222,  221,  220,  219,  216,
        -:11903:      208,  207,  204,  203,  189,  187,  183,  179,  176,  175,
        -:11904:      174,  173,  172,  171,  169,  166,  165,  162,  161,  159,
        -:11905:      156,  155,  154,  153,  151,  149,  148,  146,  144,  143,
        -:11906:      137,  134,  125,  124,  122,  119,  114,  112,  107,  103,
        -:11907:       97,   92,   89,   87,   85,   84,   83,   80,   76,   74,
        -:11908:
        -:11909:       73,   71,   67,   65,   59,   55,   50,   47,   43,   39,
        -:11910:       16,   15,   10,    8,    7,  768,  768,  768,  768,  768,
        -:11911:      768,  768,  768,  768,  768,  768,  768,  768,  768,  768,
        -:11912:      768,  768,  768,  768,  768,  768,  768,  768,  768,  768,
        -:11913:      768,  768,  768,  768,  768,  768,  768,  768,  768,  768,
        -:11914:      768,  768,  768,  768,  768,  768,  768,  768,  768,  768,
        -:11915:      768,  768,  768,  768,  768,  768,  768,  768,  768,  768,
        -:11916:      768,  768,  768,  768
        -:11917:    } ;
        -:11918:
        -:11919:static yy_state_type yy_last_accepting_state;
        -:11920:static char *yy_last_accepting_cpos;
        -:11921:
        -:11922:/* The intent behind this definition is that it'll catch
        -:11923: * any uses of REJECT which flex missed.
        -:11924: */
        -:11925:#define REJECT reject_used_but_not_detected
        -:11926:#define yymore() yymore_used_but_not_detected
        -:11927:#define YY_MORE_ADJ 0
        -:11928:#define YY_RESTORE_YY_MORE_OFFSET
        -:11929:char *yytext;
        -:11930:#define INITIAL 0
        -:11931:/* scan.l - scanner for flex input */
        -:11932:/*-
        -:11933: * Copyright (c) 1990 The Regents of the University of California.
        -:11934: * All rights reserved.
        -:11935: *
        -:11936: * This code is derived from software contributed to Berkeley by
        -:11937: * Vern Paxson.
        -:11938: * 
        -:11939: * The United States Government has rights in this work pursuant
        -:11940: * to contract no. DE-AC03-76SF00098 between the United States
        -:11941: * Department of Energy and the University of California.
        -:11942: *
        -:11943: * Redistribution and use in source and binary forms with or without
        -:11944: * modification are permitted provided that: (1) source distributions retain
        -:11945: * this entire copyright notice and comment, and (2) distributions including
        -:11946: * binaries display the following acknowledgement:  ``This product includes
        -:11947: * software developed by the University of California, Berkeley and its
        -:11948: * contributors'' in the documentation or other materials provided with the
        -:11949: * distribution and in all advertising materials mentioning features or use
        -:11950: * of this software.  Neither the name of the University nor the names of
        -:11951: * its contributors may be used to endorse or promote products derived from
        -:11952: * this software without specific prior written permission.
        -:11953: * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
        -:11954: * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
        -:11955: * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
        -:11956: */
        -:11957:
        -:11958:/* $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.seeded/v5/flex.c,v 1.1.1.2 2003/09/02 20:22:00 expsir Exp $ */
        -:11959:
        -:11960:
        -:11961:#define ACTION_ECHO add_action( yytext )
        -:11962:#define ACTION_IFDEF(def, should_define) \
        -:11963:	{ \
        -:11964:	if ( should_define ) \
        -:11965:		action_define( def, 1 ); \
        -:11966:	}
        -:11967:
        -:11968:#define MARK_END_OF_PROLOG mark_prolog();
        -:11969:
        -:11970:#define YY_DECL \
        -:11971:	int flexscan()
        -:11972:
        -:11973:#define RETURNCHAR \
        -:11974:	yylval = (unsigned char) yytext[0]; \
        -:11975:	return CHAR;
        -:11976:
        -:11977:#define RETURNNAME \
        -:11978:	strcpy( nmstr, yytext ); \
        -:11979:	return NAME;
        -:11980:
        -:11981:#define PUT_BACK_STRING(str, start) \
        -:11982:	for ( i = strlen( str ) - 1; i >= start; --i ) \
        -:11983:		unput((str)[i])
        -:11984:
        -:11985:#define CHECK_REJECT(str) \
        -:11986:	if ( all_upper( str ) ) \
        -:11987:		reject = true;
        -:11988:
        -:11989:#define CHECK_YYMORE(str) \
        -:11990:	if ( all_lower( str ) ) \
        -:11991:		yymore_used = true;
        -:11992:#define YY_STACK_USED 1
        -:11993:#define YY_NO_TOP_STATE 1
        -:11994:#define SECT2 1
        -:11995:#define SECT2PROLOG 2
        -:11996:#define SECT3 3
        -:11997:#define CODEBLOCK 4
        -:11998:#define PICKUPDEF 5
        -:11999:#define SC 6
        -:12000:#define CARETISBOL 7
        -:12001:#define NUM 8
        -:12002:#define QUOTE 9
        -:12003:
        -:12004:#define FIRSTCCL 10
        -:12005:#define CCL 11
        -:12006:#define ACTION 12
        -:12007:#define RECOVER 13
        -:12008:#define COMMENT 14
        -:12009:#define ACTION_STRING 15
        -:12010:#define PERCENT_BRACE_ACTION 16
        -:12011:
        -:12012:#define OPTION 17
        -:12013:#define LINEDIR 18
        -:12014:
        -:12015:
        -:12016:/* Macros after this point can all be overridden by user definitions in
        -:12017: * section 1.
        -:12018: */
        -:12019:
        -:12020:#ifndef YY_SKIP_YYWRAP
        -:12021:#ifdef __cplusplus
        -:12022:extern "C" int yywrap YY_PROTO(( void ));
        -:12023:#else
        -:12024:extern int yywrap YY_PROTO(( void ));
        -:12025:#endif
        -:12026:#endif
        -:12027:
        -:12028:#ifndef YY_NO_UNPUT
        -:12029:static void yyunput YY_PROTO(( int c, char *buf_ptr ));
        -:12030:#endif
        -:12031:
        -:12032:#ifndef yytext_ptr
        -:12033:static void yy_flex_strncpy YY_PROTO(( char *, yyconst char *, int ));
        -:12034:#endif
        -:12035:
        -:12036:#ifdef YY_NEED_STRLEN
        -:12037:static int yy_flex_strlen YY_PROTO(( yyconst char * ));
        -:12038:#endif
        -:12039:
        -:12040:#ifndef YY_NO_INPUT
        -:12041:#ifdef __cplusplus
        -:12042:static int yyinput YY_PROTO(( void ));
        -:12043:#else
        -:12044:static int input YY_PROTO(( void ));
        -:12045:#endif
        -:12046:#endif
        -:12047:
        -:12048:#if YY_STACK_USED
        -:12049:static int yy_start_stack_ptr = 0;
        -:12050:static int yy_start_stack_depth = 0;
        -:12051:static int *yy_start_stack = 0;
        -:12052:#ifndef YY_NO_PUSH_STATE
        -:12053:static void yy_push_state YY_PROTO(( int new_state ));
        -:12054:#endif
        -:12055:#ifndef YY_NO_POP_STATE
        -:12056:static void yy_pop_state YY_PROTO(( void ));
        -:12057:#endif
        -:12058:#ifndef YY_NO_TOP_STATE
        -:12059:static int yy_top_state YY_PROTO(( void ));
        -:12060:#endif
        -:12061:
        -:12062:#else
        -:12063:#define YY_NO_PUSH_STATE 1
        -:12064:#define YY_NO_POP_STATE 1
        -:12065:#define YY_NO_TOP_STATE 1
        -:12066:#endif
        -:12067:
        -:12068:#ifdef YY_MALLOC_DECL
        -:12069:YY_MALLOC_DECL
        -:12070:#else
        -:12071:#if __STDC__
        -:12072:#ifndef __cplusplus
        -:12073:#include <stdlib.h>
        -:12074:#endif
        -:12075:#else
        -:12076:/* Just try to get by without declaring the routines.  This will fail
        -:12077: * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)
        -:12078: * or sizeof(void*) != sizeof(int).
        -:12079: */
        -:12080:#endif
        -:12081:#endif
        -:12082:
        -:12083:/* Amount of stuff to slurp up with each read. */
        -:12084:#ifndef YY_READ_BUF_SIZE
        -:12085:#define YY_READ_BUF_SIZE 8192
        -:12086:#endif
        -:12087:
        -:12088:/* Copy whatever the last rule matched to the standard output. */
        -:12089:
        -:12090:#ifndef ECHO
        -:12091:/* This used to be an fputs(), but since the string might contain NUL's,
        -:12092: * we now use fwrite().
        -:12093: */
        -:12094:#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )
        -:12095:#endif
        -:12096:
        -:12097:/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
        -:12098: * is returned in "result".
        -:12099: */
        -:12100:#ifndef YY_INPUT
        -:12101:#define YY_INPUT(buf,result,max_size) \
        -:12102:	if ( yy_current_buffer->yy_is_interactive ) \
        -:12103:		{ \
        -:12104:		int c = '*', n; \
        -:12105:		for ( n = 0; n < max_size && \
        -:12106:			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
        -:12107:			buf[n] = (char) c; \
        -:12108:		if ( c == '\n' ) \
        -:12109:			buf[n++] = (char) c; \
        -:12110:		if ( c == EOF && ferror( yyin ) ) \
        -:12111:			YY_FATAL_ERROR( "input in flex scanner failed" ); \
        -:12112:		result = n; \
        -:12113:		} \
        -:12114:	else if ( ((result = fread( buf, 1, max_size, yyin )) == 0) \
        -:12115:		  && ferror( yyin ) ) \
        -:12116:		YY_FATAL_ERROR( "input in flex scanner failed" );
        -:12117:#endif
        -:12118:
        -:12119:/* No semi-colon after return; correct usage is to write "yyterminate();" -
        -:12120: * we don't want an extra ';' after the "return" because that will cause
        -:12121: * some compilers to complain about unreachable statements.
        -:12122: */
        -:12123:#ifndef yyterminate
        -:12124:#define yyterminate() return YY_NULL
        -:12125:#endif
        -:12126:
        -:12127:/* Number of entries by which start-condition stack grows. */
        -:12128:#ifndef YY_START_STACK_INCR
        -:12129:#define YY_START_STACK_INCR 25
        -:12130:#endif
        -:12131:
        -:12132:/* Report a fatal error. */
        -:12133:#ifndef YY_FATAL_ERROR
        -:12134:#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
        -:12135:#endif
        -:12136:
        -:12137:/* Default declaration of generated scanner - a define so the user can
        -:12138: * easily add parameters.
        -:12139: */
        -:12140:#ifndef YY_DECL
        -:12141:#define YY_DECL int yylex YY_PROTO(( void ))
        -:12142:#endif
        -:12143:
        -:12144:/* Code executed at the beginning of each rule, after yytext and yyleng
        -:12145: * have been set up.
        -:12146: */
        -:12147:#ifndef YY_USER_ACTION
        -:12148:#define YY_USER_ACTION
        -:12149:#endif
        -:12150:
        -:12151:/* Code executed at the end of each rule. */
        -:12152:#ifndef YY_BREAK
        -:12153:#define YY_BREAK break;
        -:12154:#endif
        -:12155:
        -:12156:#define YY_RULE_SETUP \
        -:12157:	if ( yyleng > 0 ) \
        -:12158:		yy_current_buffer->yy_at_bol = \
        -:12159:				(yytext[yyleng - 1] == '\n'); \
        -:12160:	YY_USER_ACTION
        -:12161:
function flexscan called 31427 returned 100% blocks executed 46%
    31427:12162:YY_DECL
        -:12163:	{
        -:12164:	register yy_state_type yy_current_state;
        -:12165:	register char *yy_cp, *yy_bp;
        -:12166:	register int yy_act;
        -:12167:
        -:12168:
        -:12169:	static int bracelevel, didadef, indented_code;
        -:12170:	static int doing_rule_action = false;
        -:12171:	static int option_sense;
        -:12172:
    31427:12173:	int doing_codeblock = false;
        -:12174:	int i;
        -:12175:	Char nmdef[MAXLINE], myesc();
        -:12176:
        -:12177:
        -:12178:
    31427:12179:	if ( yy_init )
branch  0 taken 560 (fallthrough)
branch  1 taken 30867
        -:12180:		{
      560:12181:		yy_init = 0;
        -:12182:
        -:12183:#ifdef YY_USER_INIT
        -:12184:		YY_USER_INIT;
        -:12185:#endif
        -:12186:
      560:12187:		if ( ! yy_start )
branch  0 taken 560 (fallthrough)
branch  1 taken 0
      560:12188:			yy_start = 1;	/* first start state */
        -:12189:
      560:12190:		if ( ! yyin )
branch  0 taken 0 (fallthrough)
branch  1 taken 560
    #####:12191:			yyin = stdin;
        -:12192:
      560:12193:		if ( ! yyout )
branch  0 taken 560 (fallthrough)
branch  1 taken 0
      560:12194:			yyout = stdout;
        -:12195:
      560:12196:		if ( ! yy_current_buffer )
branch  0 taken 560 (fallthrough)
branch  1 taken 0
      560:12197:			yy_current_buffer =
      560:12198:				yy_create_buffer( yyin, YY_BUF_SIZE );
call    0 returned 560
        -:12199:
      560:12200:		yy_load_buffer_state();
call    0 returned 560
        -:12201:		}
        -:12202:
        -:12203:	while ( 1 )		/* loops until end-of-file is reached */
        -:12204:		{
    80863:12205:		yy_cp = yy_c_buf_p;
        -:12206:
        -:12207:		/* Support of yytext. */
    80863:12208:		*yy_cp = yy_hold_char;
        -:12209:
        -:12210:		/* yy_bp points to the position in yy_ch_buf of the start of
        -:12211:		 * the current run.
        -:12212:		 */
    80863:12213:		yy_bp = yy_cp;
        -:12214:
    80863:12215:		yy_current_state = yy_start;
    80863:12216:		yy_current_state += YY_AT_BOL();
    81427:12217:yy_match:
        -:12218:		do
        -:12219:			{
   312034:12220:			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
   312034:12221:			if ( yy_accept[yy_current_state] )
branch  0 taken 231179 (fallthrough)
branch  1 taken 80855
        -:12222:				{
   231179:12223:				yy_last_accepting_state = yy_current_state;
   231179:12224:				yy_last_accepting_cpos = yy_cp;
        -:12225:				}
   584169:12226:			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
branch  0 taken 272135
branch  1 taken 312034 (fallthrough)
        -:12227:				{
   272135:12228:				yy_current_state = (int) yy_def[yy_current_state];
   272135:12229:				if ( yy_current_state >= 769 )
branch  0 taken 235958 (fallthrough)
branch  1 taken 36177
   235958:12230:					yy_c = yy_meta[(unsigned int) yy_c];
        -:12231:				}
   312034:12232:			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
   312034:12233:			++yy_cp;
        -:12234:			}
   312034:12235:		while ( yy_base[yy_current_state] != 2716 );
branch  0 taken 230607
branch  1 taken 81427 (fallthrough)
        -:12236:
    81427:12237:yy_find_action:
    81427:12238:		yy_act = yy_accept[yy_current_state];
    81427:12239:		if ( yy_act == 0 )
branch  0 taken 35127 (fallthrough)
branch  1 taken 46300
        -:12240:			{ /* have to back up */
    35127:12241:			yy_cp = yy_last_accepting_cpos;
    35127:12242:			yy_current_state = yy_last_accepting_state;
    35127:12243:			yy_act = yy_accept[yy_current_state];
        -:12244:			}
        -:12245:
    81427:12246:		YY_DO_BEFORE_ACTION;
        -:12247:
        -:12248:
    81973:12249:do_action:	/* This label is used only to access EOF actions. */
        -:12250:
        -:12251:
    81973:12252:		switch ( yy_act )
branch  0 taken 0
branch  1 taken 8
branch  2 taken 119
branch  3 taken 0
branch  4 taken 1
branch  5 taken 18
branch  6 taken 123
branch  7 taken 19
branch  8 taken 560
branch  9 taken 0
branch 10 taken 0
branch 11 taken 0
branch 12 taken 0
branch 13 taken 0
branch 14 taken 0
branch 15 taken 257
branch 16 taken 19
branch 17 taken 370
branch 18 taken 138
branch 19 taken 357
branch 20 taken 0
branch 21 taken 357
branch 22 taken 0
branch 23 taken 0
branch 24 taken 0
branch 25 taken 0
branch 26 taken 0
branch 27 taken 123
branch 28 taken 3359
branch 29 taken 249
branch 30 taken 257
branch 31 taken 257
branch 32 taken 257
branch 33 taken 0
branch 34 taken 0
branch 35 taken 0
branch 36 taken 0
branch 37 taken 0
branch 38 taken 0
branch 39 taken 0
branch 40 taken 0
branch 41 taken 0
branch 42 taken 0
branch 43 taken 0
branch 44 taken 0
branch 45 taken 0
branch 46 taken 0
branch 47 taken 0
branch 48 taken 0
branch 49 taken 0
branch 50 taken 0
branch 51 taken 0
branch 52 taken 0
branch 53 taken 0
branch 54 taken 0
branch 55 taken 0
branch 56 taken 0
branch 57 taken 0
branch 58 taken 0
branch 59 taken 0
branch 60 taken 0
branch 61 taken 0
branch 62 taken 0
branch 63 taken 0
branch 64 taken 0
branch 65 taken 0
branch 66 taken 0
branch 67 taken 0
branch 68 taken 0
branch 69 taken 0
branch 70 taken 0
branch 71 taken 0
branch 72 taken 0
branch 73 taken 0
branch 74 taken 0
branch 75 taken 0
branch 76 taken 0
branch 77 taken 0
branch 78 taken 0
branch 79 taken 0
branch 80 taken 0
branch 81 taken 0
branch 82 taken 0
branch 83 taken 0
branch 84 taken 0
branch 85 taken 0
branch 86 taken 552
branch 87 taken 0
branch 88 taken 984
branch 89 taken 1
branch 90 taken 932
branch 91 taken 0
branch 92 taken 16
branch 93 taken 100
branch 94 taken 1099
branch 95 taken 296
branch 96 taken 103
branch 97 taken 0
branch 98 taken 11
branch 99 taken 0
branch 100 taken 1
branch 101 taken 3500
branch 102 taken 22
branch 103 taken 11
branch 104 taken 119
branch 105 taken 1531
branch 106 taken 459
branch 107 taken 3822
branch 108 taken 8959
branch 109 taken 7
branch 110 taken 16
branch 111 taken 0
branch 112 taken 17
branch 113 taken 0
branch 114 taken 0
branch 115 taken 1918
branch 116 taken 1099
branch 117 taken 0
branch 118 taken 219
branch 119 taken 0
branch 120 taken 1068
branch 121 taken 880
branch 122 taken 2687
branch 123 taken 1298
branch 124 taken 0
branch 125 taken 0
branch 126 taken 0
branch 127 taken 0
branch 128 taken 0
branch 129 taken 0
branch 130 taken 0
branch 131 taken 0
branch 132 taken 0
branch 133 taken 0
branch 134 taken 0
branch 135 taken 0
branch 136 taken 0
branch 137 taken 0
branch 138 taken 396
branch 139 taken 198
branch 140 taken 296
branch 141 taken 0
branch 142 taken 0
branch 143 taken 0
branch 144 taken 238
branch 145 taken 8
branch 146 taken 5
branch 147 taken 0
branch 148 taken 0
branch 149 taken 379
branch 150 taken 379
branch 151 taken 11882
branch 152 taken 7474
branch 153 taken 9
branch 154 taken 3607
branch 155 taken 4309
branch 156 taken 0
branch 157 taken 3607
branch 158 taken 3197
branch 159 taken 0
branch 160 taken 3607
branch 161 taken 0
branch 162 taken 0
branch 163 taken 595
branch 164 taken 1556
branch 165 taken 113
branch 166 taken 0
branch 167 taken 0
branch 168 taken 432
branch 169 taken 1111
branch 170 taken 0
        -:12253:	{ /* beginning of action switch */
    #####:12254:			case 0: /* must back up */
        -:12255:			/* undo the effects of YY_DO_BEFORE_ACTION */
    #####:12256:			*yy_cp = yy_hold_char;
    #####:12257:			yy_cp = yy_last_accepting_cpos;
    #####:12258:			yy_current_state = yy_last_accepting_state;
    #####:12259:			goto yy_find_action;
        -:12260:
        -:12261:
        8:12262:case 1:
        8:12263:YY_RULE_SETUP
branch  0 taken 8 (fallthrough)
branch  1 taken 0
        8:12264:indented_code = true; BEGIN(CODEBLOCK);
        8:12265:	YY_BREAK
      119:12266:case 2:
      119:12267:YY_RULE_SETUP
branch  0 taken 119 (fallthrough)
branch  1 taken 0
      119:12268:ACTION_ECHO; yy_push_state( COMMENT );
call    0 returned 119
call    1 returned 119
      119:12269:	YY_BREAK
    #####:12270:case 3:
    #####:12271:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:12272:yy_push_state( LINEDIR );
call    0 never executed
    #####:12273:	YY_BREAK
        1:12274:case 4:
        1:12275:YY_RULE_SETUP
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:12276:return SCDECL;
        -:12277:	YY_BREAK
       18:12278:case 5:
       18:12279:YY_RULE_SETUP
branch  0 taken 18 (fallthrough)
branch  1 taken 0
       18:12280:return XSCDECL;
        -:12281:	YY_BREAK
      123:12282:case 6:
      123:12283:YY_RULE_SETUP
branch  0 taken 123 (fallthrough)
branch  1 taken 0
        -:12284:{
      123:12285:			++linenum;
      123:12286:			line_directive_out( (FILE *) 0, 1 );
call    0 returned 123
      123:12287:			indented_code = false;
      123:12288:			BEGIN(CODEBLOCK);
        -:12289:			}
      123:12290:	YY_BREAK
       19:12291:case 7:
       19:12292:YY_RULE_SETUP
branch  0 taken 19 (fallthrough)
branch  1 taken 0
        -:12293:/* discard */
       19:12294:	YY_BREAK
      560:12295:case 8:
      560:12296:YY_RULE_SETUP
branch  0 taken 560 (fallthrough)
branch  1 taken 0
        -:12297:{
      560:12298:			sectnum = 2;
      560:12299:			bracelevel = 0;
      560:12300:			mark_defs1();
call    0 returned 560
      560:12301:			line_directive_out( (FILE *) 0, 1 );
call    0 returned 560
      560:12302:			BEGIN(SECT2PROLOG);
      560:12303:			return SECTEND;
        -:12304:			}
        -:12305:	YY_BREAK
    #####:12306:case 9:
    #####:12307:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:12308:yytext_is_array = false; ++linenum;
    #####:12309:	YY_BREAK
    #####:12310:case 10:
    #####:12311:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:12312:yytext_is_array = true; ++linenum;
    #####:12313:	YY_BREAK
    #####:12314:case 11:
    #####:12315:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:12316:BEGIN(OPTION); return OPTION_OP;
        -:12317:	YY_BREAK
    #####:12318:case 12:
    #####:12319:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:12320:++linenum; /* ignore */
    #####:12321:	YY_BREAK
    #####:12322:case 13:
    #####:12323:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:12324:++linenum;	/* ignore */
    #####:12325:	YY_BREAK
    #####:12326:case 14:
    #####:12327:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:12328:synerr( _( "unrecognized '%' directive" ) );
call    0 never executed
    #####:12329:	YY_BREAK
      257:12330:case 15:
      257:12331:YY_RULE_SETUP
branch  0 taken 257 (fallthrough)
branch  1 taken 0
        -:12332:{
      257:12333:			strcpy( nmstr, yytext );
      257:12334:			didadef = false;
      257:12335:			BEGIN(PICKUPDEF);
        -:12336:			}
      257:12337:	YY_BREAK
       19:12338:case 16:
       19:12339:YY_RULE_SETUP
branch  0 taken 19 (fallthrough)
branch  1 taken 0
       19:12340:RETURNNAME;
        -:12341:	YY_BREAK
      370:12342:case 17:
      370:12343:YY_RULE_SETUP
branch  0 taken 370 (fallthrough)
branch  1 taken 0
      370:12344:++linenum; /* allows blank lines in section 1 */
      370:12345:	YY_BREAK
      138:12346:case 18:
      138:12347:YY_RULE_SETUP
branch  0 taken 138 (fallthrough)
branch  1 taken 0
      138:12348:ACTION_ECHO; ++linenum; /* maybe end of comment line */
call    0 returned 138
      138:12349:	YY_BREAK
        -:12350:
        -:12351:
      357:12352:case 19:
      357:12353:YY_RULE_SETUP
branch  0 taken 357 (fallthrough)
branch  1 taken 0
      357:12354:ACTION_ECHO; yy_pop_state();
call    0 returned 357
call    1 returned 357
      357:12355:	YY_BREAK
    #####:12356:case 20:
    #####:12357:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:12358:ACTION_ECHO;
call    0 never executed
    #####:12359:	YY_BREAK
      357:12360:case 21:
      357:12361:YY_RULE_SETUP
branch  0 taken 357 (fallthrough)
branch  1 taken 0
      357:12362:ACTION_ECHO;
call    0 returned 357
      357:12363:	YY_BREAK
    #####:12364:case 22:
    #####:12365:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:12366:++linenum; ACTION_ECHO;
call    0 never executed
    #####:12367:	YY_BREAK
        -:12368:
        -:12369:
    #####:12370:case 23:
    #####:12371:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:12372:yy_pop_state();
call    0 never executed
    #####:12373:	YY_BREAK
    #####:12374:case 24:
    #####:12375:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:12376:linenum = myctoi( yytext );
call    0 never executed
    #####:12377:	YY_BREAK
    #####:12378:case 25:
    #####:12379:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
        -:12380:{
    #####:12381:			flex_free( (void *) infilename );
call    0 never executed
    #####:12382:			infilename = copy_string( yytext + 1 );
call    0 never executed
    #####:12383:			infilename[strlen( infilename ) - 1] = '\0';
        -:12384:			}
    #####:12385:	YY_BREAK
    #####:12386:case 26:
    #####:12387:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
        -:12388:/* ignore spurious characters */
    #####:12389:	YY_BREAK
        -:12390:
        -:12391:
      123:12392:case 27:
      123:12393:YY_RULE_SETUP
branch  0 taken 123 (fallthrough)
branch  1 taken 0
      123:12394:++linenum; BEGIN(INITIAL);
      123:12395:	YY_BREAK
     3359:12396:case 28:
     3359:12397:YY_RULE_SETUP
branch  0 taken 3359 (fallthrough)
branch  1 taken 0
     3359:12398:ACTION_ECHO;
call    0 returned 3359
     3359:12399:	YY_BREAK
      249:12400:case 29:
      249:12401:YY_RULE_SETUP
branch  0 taken 249 (fallthrough)
branch  1 taken 0
        -:12402:{
      249:12403:			++linenum;
      249:12404:			ACTION_ECHO;
call    0 returned 249
      249:12405:			if ( indented_code )
branch  0 taken 8 (fallthrough)
branch  1 taken 241
        8:12406:				BEGIN(INITIAL);
        -:12407:			}
      249:12408:	YY_BREAK
        -:12409:
        -:12410:
      257:12411:case 30:
      257:12412:YY_RULE_SETUP
branch  0 taken 257 (fallthrough)
branch  1 taken 0
        -:12413:/* separates name and definition */
      257:12414:	YY_BREAK
      257:12415:case 31:
      257:12416:YY_RULE_SETUP
branch  0 taken 257 (fallthrough)
branch  1 taken 0
        -:12417:{
      257:12418:			strcpy( (char *) nmdef, yytext );
        -:12419:
        -:12420:			/* Skip trailing whitespace. */
      257:12421:			for ( i = strlen( (char *) nmdef ) - 1;
      257:12422:			      i >= 0 && (nmdef[i] == ' ' || nmdef[i] == '\t');
branch  0 taken 257 (fallthrough)
branch  1 taken 0
branch  2 taken 0
branch  3 taken 257 (fallthrough)
branch  4 taken 0
branch  5 taken 257 (fallthrough)
    #####:12423:			      --i )
        -:12424:				;
        -:12425:
      257:12426:			nmdef[i + 1] = '\0';
        -:12427:
      257:12428:			ndinstal( nmstr, nmdef );
call    0 returned 257
      257:12429:			didadef = true;
        -:12430:			}
      257:12431:	YY_BREAK
      257:12432:case 32:
      257:12433:YY_RULE_SETUP
branch  0 taken 257 (fallthrough)
branch  1 taken 0
        -:12434:{
      257:12435:			if ( ! didadef )
branch  0 taken 0 (fallthrough)
branch  1 taken 257
    #####:12436:				synerr( _( "incomplete name definition" ) );
call    0 never executed
      257:12437:			BEGIN(INITIAL);
      257:12438:			++linenum;
        -:12439:			}
      257:12440:	YY_BREAK
        -:12441:
        -:12442:
    #####:12443:case 33:
    #####:12444:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:12445:++linenum; BEGIN(INITIAL);
    #####:12446:	YY_BREAK
    #####:12447:case 34:
    #####:12448:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:12449:option_sense = true;
    #####:12450:	YY_BREAK
    #####:12451:case 35:
    #####:12452:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:12453:return '=';
        -:12454:	YY_BREAK
    #####:12455:case 36:
    #####:12456:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:12457:option_sense = ! option_sense;
    #####:12458:	YY_BREAK
    #####:12459:case 37:
    #####:12460:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:12461:csize = option_sense ? 128 : 256;
branch  0 never executed
branch  1 never executed
    #####:12462:	YY_BREAK
    #####:12463:case 38:
    #####:12464:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:12465:csize = option_sense ? 256 : 128;
branch  0 never executed
branch  1 never executed
    #####:12466:	YY_BREAK
    #####:12467:case 39:
    #####:12468:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:12469:long_align = option_sense;
    #####:12470:	YY_BREAK
    #####:12471:case 40:
    #####:12472:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
        -:12473:{
    #####:12474:			action_define( "YY_ALWAYS_INTERACTIVE", option_sense );
call    0 never executed
        -:12475:			}
    #####:12476:	YY_BREAK
    #####:12477:case 41:
    #####:12478:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:12479:yytext_is_array = option_sense;
    #####:12480:	YY_BREAK
    #####:12481:case 42:
    #####:12482:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:12483:backing_up_report = option_sense;
    #####:12484:	YY_BREAK
    #####:12485:case 43:
    #####:12486:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:12487:interactive = ! option_sense;
    #####:12488:	YY_BREAK
    #####:12489:case 44:
    #####:12490:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:12491:C_plus_plus = option_sense;
    #####:12492:	YY_BREAK
    #####:12493:case 45:
    #####:12494:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:12495:caseins = ! option_sense;
    #####:12496:	YY_BREAK
    #####:12497:case 46:
    #####:12498:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:12499:caseins = option_sense;
    #####:12500:	YY_BREAK
    #####:12501:case 47:
    #####:12502:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:12503:ddebug = option_sense;
    #####:12504:	YY_BREAK
    #####:12505:case 48:
    #####:12506:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:12507:spprdflt = ! option_sense;
    #####:12508:	YY_BREAK
    #####:12509:case 49:
    #####:12510:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:12511:useecs = option_sense;
    #####:12512:	YY_BREAK
    #####:12513:case 50:
    #####:12514:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
        -:12515:{
    #####:12516:			useecs = usemecs = false;
    #####:12517:			use_read = fullspd = true;
        -:12518:			}
    #####:12519:	YY_BREAK
    #####:12520:case 51:
    #####:12521:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
        -:12522:{
    #####:12523:			useecs = usemecs = false;
    #####:12524:			use_read = fulltbl = true;
        -:12525:			}
    #####:12526:	YY_BREAK
    #####:12527:case 52:
    #####:12528:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:12529:ACTION_IFDEF("YY_NO_INPUT", ! option_sense);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:12530:	YY_BREAK
    #####:12531:case 53:
    #####:12532:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:12533:interactive = option_sense;
    #####:12534:	YY_BREAK
    #####:12535:case 54:
    #####:12536:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:12537:lex_compat = option_sense;
    #####:12538:	YY_BREAK
    #####:12539:case 55:
    #####:12540:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
        -:12541:{
    #####:12542:			action_define( "YY_MAIN", option_sense );
call    0 never executed
    #####:12543:			do_yywrap = ! option_sense;
        -:12544:			}
    #####:12545:	YY_BREAK
    #####:12546:case 56:
    #####:12547:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:12548:usemecs = option_sense;
    #####:12549:	YY_BREAK
    #####:12550:case 57:
    #####:12551:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
        -:12552:{
    #####:12553:			action_define( "YY_NEVER_INTERACTIVE", option_sense );
call    0 never executed
        -:12554:			}
    #####:12555:	YY_BREAK
    #####:12556:case 58:
    #####:12557:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:12558:performance_report += option_sense ? 1 : -1;
branch  0 never executed
branch  1 never executed
    #####:12559:	YY_BREAK
    #####:12560:case 59:
    #####:12561:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:12562:yytext_is_array = ! option_sense;
    #####:12563:	YY_BREAK
    #####:12564:case 60:
    #####:12565:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:12566:use_read = option_sense;
    #####:12567:	YY_BREAK
    #####:12568:case 61:
    #####:12569:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:12570:reject_really_used = option_sense;
    #####:12571:	YY_BREAK
    #####:12572:case 62:
    #####:12573:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:12574:action_define( "YY_STACK_USED", option_sense );
call    0 never executed
    #####:12575:	YY_BREAK
    #####:12576:case 63:
    #####:12577:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:12578:do_stdinit = option_sense;
    #####:12579:	YY_BREAK
    #####:12580:case 64:
    #####:12581:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:12582:use_stdout = option_sense;
    #####:12583:	YY_BREAK
    #####:12584:case 65:
    #####:12585:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:12586:ACTION_IFDEF("YY_NO_UNPUT", ! option_sense);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:12587:	YY_BREAK
    #####:12588:case 66:
    #####:12589:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:12590:printstats = option_sense;
    #####:12591:	YY_BREAK
    #####:12592:case 67:
    #####:12593:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:12594:nowarn = ! option_sense;
    #####:12595:	YY_BREAK
    #####:12596:case 68:
    #####:12597:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:12598:do_yylineno = option_sense;
    #####:12599:	YY_BREAK
    #####:12600:case 69:
    #####:12601:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:12602:yymore_really_used = option_sense;
    #####:12603:	YY_BREAK
    #####:12604:case 70:
    #####:12605:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:12606:do_yywrap = option_sense;
    #####:12607:	YY_BREAK
    #####:12608:case 71:
    #####:12609:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:12610:ACTION_IFDEF("YY_NO_PUSH_STATE", ! option_sense);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:12611:	YY_BREAK
    #####:12612:case 72:
    #####:12613:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:12614:ACTION_IFDEF("YY_NO_POP_STATE", ! option_sense);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:12615:	YY_BREAK
    #####:12616:case 73:
    #####:12617:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:12618:ACTION_IFDEF("YY_NO_TOP_STATE", ! option_sense);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:12619:	YY_BREAK
    #####:12620:case 74:
    #####:12621:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:12622:ACTION_IFDEF("YY_NO_SCAN_BUFFER", ! option_sense);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:12623:	YY_BREAK
    #####:12624:case 75:
    #####:12625:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:12626:ACTION_IFDEF("YY_NO_SCAN_BYTES", ! option_sense);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:12627:	YY_BREAK
    #####:12628:case 76:
    #####:12629:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:12630:ACTION_IFDEF("YY_NO_SCAN_STRING", ! option_sense);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:12631:	YY_BREAK
    #####:12632:case 77:
    #####:12633:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:12634:return OPT_OUTFILE;
        -:12635:	YY_BREAK
    #####:12636:case 78:
    #####:12637:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:12638:return OPT_PREFIX;
        -:12639:	YY_BREAK
    #####:12640:case 79:
    #####:12641:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:12642:return OPT_YYCLASS;
        -:12643:	YY_BREAK
    #####:12644:case 80:
    #####:12645:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
        -:12646:{
    #####:12647:			strcpy( nmstr, yytext + 1 );
    #####:12648:			nmstr[strlen( nmstr ) - 1] = '\0';
    #####:12649:			return NAME;
        -:12650:			}
        -:12651:	YY_BREAK
    #####:12652:case 81:
    #####:12653:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
        -:12654:{
    #####:12655:			format_synerr( _( "unrecognized %%option: %s" ),
call    0 never executed
        -:12656:				yytext );
    #####:12657:			BEGIN(RECOVER);
        -:12658:			}
    #####:12659:	YY_BREAK
        -:12660:
    #####:12661:case 82:
    #####:12662:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:12663:++linenum; BEGIN(INITIAL);
    #####:12664:	YY_BREAK
        -:12665:
    #####:12666:case 83:
    #####:12667:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:12668:++bracelevel; yyless( 2 );	/* eat only %{ */
    #####:12669:	YY_BREAK
    #####:12670:case 84:
    #####:12671:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:12672:--bracelevel; yyless( 2 );	/* eat only %} */
    #####:12673:	YY_BREAK
    #####:12674:case 85:
    #####:12675:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:12676:ACTION_ECHO;	/* indented code in prolog */
call    0 never executed
    #####:12677:	YY_BREAK
      552:12678:case 86:
      552:12679:YY_RULE_SETUP
branch  0 taken 552 (fallthrough)
branch  1 taken 0
        -:12680:{	/* non-indented code */
      552:12681:			if ( bracelevel <= 0 )
branch  0 taken 552 (fallthrough)
branch  1 taken 0
        -:12682:				{ /* not in %{ ... %} */
      552:12683:				yyless( 0 );	/* put it all back */
     552*:12684:				yy_set_bol( 1 );
branch  0 taken 0 (fallthrough)
branch  1 taken 552
call    2 never executed
      552:12685:				mark_prolog();
call    0 returned 552
      552:12686:				BEGIN(SECT2);
        -:12687:				}
        -:12688:			else
    #####:12689:				ACTION_ECHO;
call    0 never executed
        -:12690:			}
      552:12691:	YY_BREAK
    #####:12692:case 87:
    #####:12693:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:12694:ACTION_ECHO;
call    0 never executed
    #####:12695:	YY_BREAK
      984:12696:case 88:
      984:12697:YY_RULE_SETUP
branch  0 taken 984 (fallthrough)
branch  1 taken 0
      984:12698:++linenum; ACTION_ECHO;
call    0 returned 984
      984:12699:	YY_BREAK
        1:12700:case YY_STATE_EOF(SECT2PROLOG):
        -:12701:{
        1:12702:			mark_prolog();
call    0 returned 1
        1:12703:			sectnum = 0;
        1:12704:			yyterminate(); /* to stop the parser */
        -:12705:			}
        -:12706:	YY_BREAK
        -:12707:
        -:12708:
      932:12709:case 89:
      932:12710:YY_RULE_SETUP
branch  0 taken 932 (fallthrough)
branch  1 taken 0
      932:12711:++linenum; /* allow blank lines in section 2 */
      932:12712:	YY_BREAK
    #####:12713:case 90:
    #####:12714:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
        -:12715:{
    #####:12716:			indented_code = false;
    #####:12717:			doing_codeblock = true;
    #####:12718:			bracelevel = 1;
    #####:12719:			BEGIN(PERCENT_BRACE_ACTION);
        -:12720:			}
    #####:12721:	YY_BREAK
       16:12722:case 91:
       16:12723:YY_RULE_SETUP
branch  0 taken 16 (fallthrough)
branch  1 taken 0
       16:12724:BEGIN(SC); return '<';
        -:12725:	YY_BREAK
      100:12726:case 92:
      100:12727:YY_RULE_SETUP
branch  0 taken 100 (fallthrough)
branch  1 taken 0
      100:12728:return '^';
        -:12729:	YY_BREAK
     1099:12730:case 93:
     1099:12731:YY_RULE_SETUP
branch  0 taken 1099 (fallthrough)
branch  1 taken 0
     1099:12732:BEGIN(QUOTE); return '"';
        -:12733:	YY_BREAK
      296:12734:case 94:
      296:12735:*yy_cp = yy_hold_char; /* undo effects of setting up yytext */
      296:12736:yy_c_buf_p = yy_cp = yy_bp + 1;
      296:12737:YY_DO_BEFORE_ACTION; /* set up yytext again */
      296:12738:YY_RULE_SETUP
branch  0 taken 296 (fallthrough)
branch  1 taken 0
      296:12739:BEGIN(NUM); return '{';
        -:12740:	YY_BREAK
      103:12741:case 95:
      103:12742:*yy_cp = yy_hold_char; /* undo effects of setting up yytext */
      103:12743:yy_c_buf_p = yy_cp = yy_bp + 1;
      103:12744:YY_DO_BEFORE_ACTION; /* set up yytext again */
      103:12745:YY_RULE_SETUP
branch  0 taken 103 (fallthrough)
branch  1 taken 0
      103:12746:return '$';
        -:12747:	YY_BREAK
    #####:12748:case 96:
    #####:12749:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
        -:12750:{
    #####:12751:			bracelevel = 1;
    #####:12752:			BEGIN(PERCENT_BRACE_ACTION);
        -:12753:
    #####:12754:			if ( in_rule )
branch  0 never executed
branch  1 never executed
        -:12755:				{
    #####:12756:				doing_rule_action = true;
    #####:12757:				in_rule = false;
    #####:12758:				return '\n';
        -:12759:				}
        -:12760:			}
    #####:12761:	YY_BREAK
       11:12762:case 97:
       11:12763:YY_RULE_SETUP
branch  0 taken 11 (fallthrough)
branch  1 taken 0
       11:12764:continued_action = true; ++linenum; return '\n';
        -:12765:	YY_BREAK
    #####:12766:case 98:
    #####:12767:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
        -:12768:{
    #####:12769:			yyless( yyleng - 2 );	/* put back '/', '*' */
    #####:12770:			bracelevel = 0;
    #####:12771:			continued_action = false;
    #####:12772:			BEGIN(ACTION);
        -:12773:			}
    #####:12774:	YY_BREAK
        1:12775:case 99:
        1:12776:YY_RULE_SETUP
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -:12777:/* allow indented rules */
        1:12778:	YY_BREAK
     3500:12779:case 100:
     3500:12780:YY_RULE_SETUP
branch  0 taken 3500 (fallthrough)
branch  1 taken 0
        -:12781:{
        -:12782:			/* This rule is separate from the one below because
        -:12783:			 * otherwise we get variable trailing context, so
        -:12784:			 * we can't build the scanner using -{f,F}.
        -:12785:			 */
     3500:12786:			bracelevel = 0;
     3500:12787:			continued_action = false;
     3500:12788:			BEGIN(ACTION);
        -:12789:
     3500:12790:			if ( in_rule )
branch  0 taken 3500 (fallthrough)
branch  1 taken 0
        -:12791:				{
     3500:12792:				doing_rule_action = true;
     3500:12793:				in_rule = false;
     3500:12794:				return '\n';
        -:12795:				}
        -:12796:			}
    #####:12797:	YY_BREAK
       22:12798:case 101:
       22:12799:YY_RULE_SETUP
branch  0 taken 22 (fallthrough)
branch  1 taken 0
        -:12800:{
       22:12801:			bracelevel = 0;
       22:12802:			continued_action = false;
       22:12803:			BEGIN(ACTION);
       22:12804:			unput( '\n' );	/* so <ACTION> sees it */
call    0 returned 22
        -:12805:
       22:12806:			if ( in_rule )
branch  0 taken 22 (fallthrough)
branch  1 taken 0
        -:12807:				{
       22:12808:				doing_rule_action = true;
       22:12809:				in_rule = false;
       22:12810:				return '\n';
        -:12811:				}
        -:12812:			}
    #####:12813:	YY_BREAK
       11:12814:case 102:
        -:12815:case 103:
       11:12816:YY_RULE_SETUP
branch  0 taken 11 (fallthrough)
branch  1 taken 0
       11:12817:return EOF_OP;
        -:12818:	YY_BREAK
      119:12819:case 104:
      119:12820:YY_RULE_SETUP
branch  0 taken 119 (fallthrough)
branch  1 taken 0
        -:12821:{
      119:12822:			sectnum = 3;
      119:12823:			BEGIN(SECT3);
      119:12824:			yyterminate(); /* to stop the parser */
        -:12825:			}
        -:12826:	YY_BREAK
     1531:12827:case 105:
     1531:12828:YY_RULE_SETUP
branch  0 taken 1531 (fallthrough)
branch  1 taken 0
        -:12829:{
        -:12830:			int cclval;
        -:12831:
     1531:12832:			strcpy( nmstr, yytext );
        -:12833:
        -:12834:			/* Check to see if we've already encountered this
        -:12835:			 * ccl.
        -:12836:			 */
     1531:12837:			if ( (cclval = ccllookup( (Char *) nmstr )) != 0 )
call    0 returned 1531
branch  1 taken 233 (fallthrough)
branch  2 taken 1298
        -:12838:				{
      233:12839:				if ( input() != ']' )
call    0 returned 233
branch  1 taken 0 (fallthrough)
branch  2 taken 233
    #####:12840:					synerr( _( "bad character class" ) );
call    0 never executed
        -:12841:
      233:12842:				yylval = cclval;
      233:12843:				++cclreuse;
      233:12844:				return PREVCCL;
        -:12845:				}
        -:12846:			else
        -:12847:				{
        -:12848:				/* We fudge a bit.  We know that this ccl will
        -:12849:				 * soon be numbered as lastccl + 1 by cclinit.
        -:12850:				 */
     1298:12851:				cclinstal( (Char *) nmstr, lastccl + 1 );
call    0 returned 1298
        -:12852:
        -:12853:				/* Push back everything but the leading bracket
        -:12854:				 * so the ccl can be rescanned.
        -:12855:				 */
     1298:12856:				yyless( 1 );
        -:12857:
     1298:12858:				BEGIN(FIRSTCCL);
     1298:12859:				return '[';
        -:12860:				}
        -:12861:			}
        -:12862:	YY_BREAK
      459:12863:case 106:
      459:12864:YY_RULE_SETUP
branch  0 taken 459 (fallthrough)
branch  1 taken 0
        -:12865:{
        -:12866:			register Char *nmdefptr;
        -:12867:			Char *ndlookup();
        -:12868:
      459:12869:			strcpy( nmstr, yytext + 1 );
      459:12870:			nmstr[yyleng - 2] = '\0';  /* chop trailing brace */
        -:12871:
      459:12872:			if ( (nmdefptr = ndlookup( nmstr )) == 0 )
call    0 returned 459
branch  1 taken 4 (fallthrough)
branch  2 taken 455
        4:12873:				format_synerr(
call    0 returned 4
        -:12874:					_( "undefined definition {%s}" ),
        -:12875:						nmstr );
        -:12876:
        -:12877:			else
        -:12878:				{ /* push back name surrounded by ()'s */
      455:12879:				int len = strlen( (char *) nmdefptr );
        -:12880:
      455:12881:				if ( lex_compat || nmdefptr[0] == '^' ||
branch  0 taken 318 (fallthrough)
branch  1 taken 137
branch  2 taken 318 (fallthrough)
branch  3 taken 0
branch  4 taken 318 (fallthrough)
branch  5 taken 0
      318:12882:				     (len > 0 && nmdefptr[len - 1] == '$') )
branch  0 taken 0 (fallthrough)
branch  1 taken 318
        -:12883:					{ /* don't use ()'s after all */
     1137:12884:					PUT_BACK_STRING((char *) nmdefptr, 0);
call    0 returned 1000
branch  1 taken 1000
branch  2 taken 137 (fallthrough)
        -:12885:
      137:12886:					if ( nmdefptr[0] == '^' )
branch  0 taken 0 (fallthrough)
branch  1 taken 137
    #####:12887:						BEGIN(CARETISBOL);
        -:12888:					}
        -:12889:
        -:12890:				else
        -:12891:					{
      318:12892:					unput(')');
call    0 returned 318
     2657:12893:					PUT_BACK_STRING((char *) nmdefptr, 0);
call    0 returned 2339
branch  1 taken 2339
branch  2 taken 318 (fallthrough)
      318:12894:					unput('(');
call    0 returned 318
        -:12895:					}
        -:12896:				}
        -:12897:			}
      459:12898:	YY_BREAK
     3822:12899:case 107:
     3822:12900:YY_RULE_SETUP
branch  0 taken 3822 (fallthrough)
branch  1 taken 0
     3822:12901:return (unsigned char) yytext[0];
        -:12902:	YY_BREAK
     8959:12903:case 108:
     8959:12904:YY_RULE_SETUP
branch  0 taken 8959 (fallthrough)
branch  1 taken 0
     8959:12905:RETURNCHAR;
        -:12906:	YY_BREAK
        -:12907:
        -:12908:
        7:12909:case 109:
        7:12910:YY_RULE_SETUP
branch  0 taken 7 (fallthrough)
branch  1 taken 0
        7:12911:return (unsigned char) yytext[0];
        -:12912:	YY_BREAK
       16:12913:case 110:
       16:12914:YY_RULE_SETUP
branch  0 taken 16 (fallthrough)
branch  1 taken 0
       16:12915:BEGIN(SECT2); return '>';
        -:12916:	YY_BREAK
    #####:12917:case 111:
    #####:12918:*yy_cp = yy_hold_char; /* undo effects of setting up yytext */
    #####:12919:yy_c_buf_p = yy_cp = yy_bp + 1;
    #####:12920:YY_DO_BEFORE_ACTION; /* set up yytext again */
    #####:12921:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:12922:BEGIN(CARETISBOL); return '>';
        -:12923:	YY_BREAK
       17:12924:case 112:
       17:12925:YY_RULE_SETUP
branch  0 taken 17 (fallthrough)
branch  1 taken 0
       17:12926:RETURNNAME;
        -:12927:	YY_BREAK
    #####:12928:case 113:
    #####:12929:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
        -:12930:{
    #####:12931:			format_synerr( _( "bad <start condition>: %s" ),
call    0 never executed
        -:12932:				yytext );
        -:12933:			}
    #####:12934:	YY_BREAK
        -:12935:
    #####:12936:case 114:
    #####:12937:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:12938:BEGIN(SECT2); return '^';
        -:12939:	YY_BREAK
        -:12940:
     1918:12941:case 115:
     1918:12942:YY_RULE_SETUP
branch  0 taken 1918 (fallthrough)
branch  1 taken 0
     1918:12943:RETURNCHAR;
        -:12944:	YY_BREAK
     1099:12945:case 116:
     1099:12946:YY_RULE_SETUP
branch  0 taken 1099 (fallthrough)
branch  1 taken 0
     1099:12947:BEGIN(SECT2); return '"';
        -:12948:	YY_BREAK
    #####:12949:case 117:
    #####:12950:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
        -:12951:{
    #####:12952:			synerr( _( "missing quote" ) );
call    0 never executed
    #####:12953:			BEGIN(SECT2);
    #####:12954:			++linenum;
    #####:12955:			return '"';
        -:12956:			}
        -:12957:	YY_BREAK
        -:12958:
        -:12959:
      219:12960:case 118:
      219:12961:*yy_cp = yy_hold_char; /* undo effects of setting up yytext */
      219:12962:yy_c_buf_p = yy_cp = yy_bp + 1;
      219:12963:YY_DO_BEFORE_ACTION; /* set up yytext again */
      219:12964:YY_RULE_SETUP
branch  0 taken 219 (fallthrough)
branch  1 taken 0
      219:12965:BEGIN(CCL); return '^';
        -:12966:	YY_BREAK
    #####:12967:case 119:
    #####:12968:*yy_cp = yy_hold_char; /* undo effects of setting up yytext */
    #####:12969:yy_c_buf_p = yy_cp = yy_bp + 1;
    #####:12970:YY_DO_BEFORE_ACTION; /* set up yytext again */
    #####:12971:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:12972:return '^';
        -:12973:	YY_BREAK
     1068:12974:case 120:
     1068:12975:YY_RULE_SETUP
branch  0 taken 1068 (fallthrough)
branch  1 taken 0
     1068:12976:BEGIN(CCL); RETURNCHAR;
        -:12977:	YY_BREAK
        -:12978:
        -:12979:
      880:12980:case 121:
      880:12981:*yy_cp = yy_hold_char; /* undo effects of setting up yytext */
      880:12982:yy_c_buf_p = yy_cp = yy_bp + 1;
      880:12983:YY_DO_BEFORE_ACTION; /* set up yytext again */
      880:12984:YY_RULE_SETUP
branch  0 taken 880 (fallthrough)
branch  1 taken 0
      880:12985:return '-';
        -:12986:	YY_BREAK
     2687:12987:case 122:
     2687:12988:YY_RULE_SETUP
branch  0 taken 2687 (fallthrough)
branch  1 taken 0
     2687:12989:RETURNCHAR;
        -:12990:	YY_BREAK
     1298:12991:case 123:
     1298:12992:YY_RULE_SETUP
branch  0 taken 1298 (fallthrough)
branch  1 taken 0
     1298:12993:BEGIN(SECT2); return ']';
        -:12994:	YY_BREAK
    #####:12995:case 124:
    #####:12996:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
        -:12997:{
    #####:12998:			synerr( _( "bad character class" ) );
call    0 never executed
    #####:12999:			BEGIN(SECT2);
    #####:13000:			return ']';
        -:13001:			}
        -:13002:	YY_BREAK
        -:13003:
        -:13004:
    #####:13005:case 125:
    #####:13006:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:13007:BEGIN(CCL); return CCE_ALNUM;
        -:13008:	YY_BREAK
    #####:13009:case 126:
    #####:13010:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:13011:BEGIN(CCL); return CCE_ALPHA;
        -:13012:	YY_BREAK
    #####:13013:case 127:
    #####:13014:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:13015:BEGIN(CCL); return CCE_BLANK;
        -:13016:	YY_BREAK
    #####:13017:case 128:
    #####:13018:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:13019:BEGIN(CCL); return CCE_CNTRL;
        -:13020:	YY_BREAK
    #####:13021:case 129:
    #####:13022:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:13023:BEGIN(CCL); return CCE_DIGIT;
        -:13024:	YY_BREAK
    #####:13025:case 130:
    #####:13026:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:13027:BEGIN(CCL); return CCE_GRAPH;
        -:13028:	YY_BREAK
    #####:13029:case 131:
    #####:13030:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:13031:BEGIN(CCL); return CCE_LOWER;
        -:13032:	YY_BREAK
    #####:13033:case 132:
    #####:13034:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:13035:BEGIN(CCL); return CCE_PRINT;
        -:13036:	YY_BREAK
    #####:13037:case 133:
    #####:13038:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:13039:BEGIN(CCL); return CCE_PUNCT;
        -:13040:	YY_BREAK
    #####:13041:case 134:
    #####:13042:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:13043:BEGIN(CCL); return CCE_SPACE;
        -:13044:	YY_BREAK
    #####:13045:case 135:
    #####:13046:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:13047:BEGIN(CCL); return CCE_UPPER;
        -:13048:	YY_BREAK
    #####:13049:case 136:
    #####:13050:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:13051:BEGIN(CCL); return CCE_XDIGIT;
        -:13052:	YY_BREAK
    #####:13053:case 137:
    #####:13054:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
        -:13055:{
    #####:13056:			format_synerr(
call    0 never executed
        -:13057:				_( "bad character class expression: %s" ),
        -:13058:					yytext );
    #####:13059:			BEGIN(CCL); return CCE_ALNUM;
        -:13060:			}
        -:13061:	YY_BREAK
        -:13062:
        -:13063:
      396:13064:case 138:
      396:13065:YY_RULE_SETUP
branch  0 taken 396 (fallthrough)
branch  1 taken 0
        -:13066:{
      396:13067:			yylval = myctoi( yytext );
call    0 returned 396
      396:13068:			return NUMBER;
        -:13069:			}
        -:13070:	YY_BREAK
      198:13071:case 139:
      198:13072:YY_RULE_SETUP
branch  0 taken 198 (fallthrough)
branch  1 taken 0
      198:13073:return ',';
        -:13074:	YY_BREAK
      296:13075:case 140:
      296:13076:YY_RULE_SETUP
branch  0 taken 296 (fallthrough)
branch  1 taken 0
      296:13077:BEGIN(SECT2); return '}';
        -:13078:	YY_BREAK
    #####:13079:case 141:
    #####:13080:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
        -:13081:{
    #####:13082:			synerr( _( "bad character inside {}'s" ) );
call    0 never executed
    #####:13083:			BEGIN(SECT2);
    #####:13084:			return '}';
        -:13085:			}
        -:13086:	YY_BREAK
    #####:13087:case 142:
    #####:13088:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
        -:13089:{
    #####:13090:			synerr( _( "missing }" ) );
call    0 never executed
    #####:13091:			BEGIN(SECT2);
    #####:13092:			++linenum;
    #####:13093:			return '}';
        -:13094:			}
        -:13095:	YY_BREAK
        -:13096:
        -:13097:
    #####:13098:case 143:
    #####:13099:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:13100:bracelevel = 0;
    #####:13101:	YY_BREAK
      238:13102:case 144:
      238:13103:YY_RULE_SETUP
branch  0 taken 238 (fallthrough)
branch  1 taken 0
      238:13104:ACTION_ECHO; yy_push_state( COMMENT );
call    0 returned 238
call    1 returned 238
      238:13105:	YY_BREAK
        -:13106:
        8:13107:case 145:
        8:13108:YY_RULE_SETUP
branch  0 taken 8 (fallthrough)
branch  1 taken 0
        -:13109:{
        8:13110:			ACTION_ECHO;
call    0 returned 8
        8:13111:			CHECK_REJECT(yytext);
call    0 returned 8
branch  1 taken 8 (fallthrough)
branch  2 taken 0
        -:13112:			}
        8:13113:	YY_BREAK
        5:13114:case 146:
        5:13115:YY_RULE_SETUP
branch  0 taken 5 (fallthrough)
branch  1 taken 0
        -:13116:{
        5:13117:			ACTION_ECHO;
call    0 returned 5
        5:13118:			CHECK_YYMORE(yytext);
call    0 returned 5
branch  1 taken 5 (fallthrough)
branch  2 taken 0
        -:13119:			}
        5:13120:	YY_BREAK
        -:13121:
    #####:13122:case 147:
    #####:13123:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:13124:ACTION_ECHO;
call    0 never executed
    #####:13125:	YY_BREAK
    #####:13126:case 148:
    #####:13127:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
        -:13128:{
    #####:13129:			++linenum;
    #####:13130:			ACTION_ECHO;
call    0 never executed
    #####:13131:			if ( bracelevel == 0 ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:13132:			     (doing_codeblock && indented_code) )
branch  0 never executed
branch  1 never executed
        -:13133:				{
    #####:13134:				if ( doing_rule_action )
branch  0 never executed
branch  1 never executed
    #####:13135:					add_action( "\tYY_BREAK\n" );
call    0 never executed
        -:13136:
    #####:13137:				doing_rule_action = doing_codeblock = false;
    #####:13138:				BEGIN(SECT2);
        -:13139:				}
        -:13140:			}
    #####:13141:	YY_BREAK
        -:13142:
        -:13143:/* Reject and YYmore() are checked for above, in PERCENT_BRACE_ACTION */
        -:13144:
      379:13145:case 149:
      379:13146:YY_RULE_SETUP
branch  0 taken 379 (fallthrough)
branch  1 taken 0
      379:13147:ACTION_ECHO; ++bracelevel;
call    0 returned 379
      379:13148:	YY_BREAK
      379:13149:case 150:
      379:13150:YY_RULE_SETUP
branch  0 taken 379 (fallthrough)
branch  1 taken 0
      379:13151:ACTION_ECHO; --bracelevel;
call    0 returned 379
      379:13152:	YY_BREAK
    11882:13153:case 151:
    11882:13154:YY_RULE_SETUP
branch  0 taken 11882 (fallthrough)
branch  1 taken 0
    11882:13155:ACTION_ECHO;
call    0 returned 11882
    11882:13156:	YY_BREAK
     7474:13157:case 152:
     7474:13158:YY_RULE_SETUP
branch  0 taken 7474 (fallthrough)
branch  1 taken 0
     7474:13159:ACTION_ECHO;
call    0 returned 7474
     7474:13160:	YY_BREAK
        9:13161:case 153:
        9:13162:YY_RULE_SETUP
branch  0 taken 9 (fallthrough)
branch  1 taken 0
        9:13163:ACTION_ECHO; /* character constant */
call    0 returned 9
        9:13164:	YY_BREAK
     3607:13165:case 154:
     3607:13166:YY_RULE_SETUP
branch  0 taken 3607 (fallthrough)
branch  1 taken 0
     3607:13167:ACTION_ECHO; BEGIN(ACTION_STRING);
call    0 returned 3607
     3607:13168:	YY_BREAK
     4309:13169:case 155:
     4309:13170:YY_RULE_SETUP
branch  0 taken 4309 (fallthrough)
branch  1 taken 0
        -:13171:{
     4309:13172:			++linenum;
     4309:13173:			ACTION_ECHO;
call    0 returned 4309
     4309:13174:			if ( bracelevel == 0 )
branch  0 taken 3522 (fallthrough)
branch  1 taken 787
        -:13175:				{
     3522:13176:				if ( doing_rule_action )
branch  0 taken 3522 (fallthrough)
branch  1 taken 0
     3522:13177:					add_action( "\tYY_BREAK\n" );
call    0 returned 3522
        -:13178:
     3522:13179:				doing_rule_action = false;
     3522:13180:				BEGIN(SECT2);
        -:13181:				}
        -:13182:			}
     4309:13183:	YY_BREAK
    #####:13184:case 156:
    #####:13185:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:13186:ACTION_ECHO;
call    0 never executed
    #####:13187:	YY_BREAK
        -:13188:
        -:13189:
     3607:13190:case 157:
     3607:13191:YY_RULE_SETUP
branch  0 taken 3607 (fallthrough)
branch  1 taken 0
     3607:13192:ACTION_ECHO;
call    0 returned 3607
     3607:13193:	YY_BREAK
     3197:13194:case 158:
     3197:13195:YY_RULE_SETUP
branch  0 taken 3197 (fallthrough)
branch  1 taken 0
     3197:13196:ACTION_ECHO;
call    0 returned 3197
     3197:13197:	YY_BREAK
    #####:13198:case 159:
    #####:13199:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:13200:++linenum; ACTION_ECHO;
call    0 never executed
    #####:13201:	YY_BREAK
     3607:13202:case 160:
     3607:13203:YY_RULE_SETUP
branch  0 taken 3607 (fallthrough)
branch  1 taken 0
     3607:13204:ACTION_ECHO; BEGIN(ACTION);
call    0 returned 3607
     3607:13205:	YY_BREAK
    #####:13206:case 161:
    #####:13207:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:13208:ACTION_ECHO;
call    0 never executed
    #####:13209:	YY_BREAK
        -:13210:
    #####:13211:case YY_STATE_EOF(COMMENT):
        -:13212:case YY_STATE_EOF(ACTION):
        -:13213:case YY_STATE_EOF(ACTION_STRING):
        -:13214:{
    #####:13215:			synerr( _( "EOF encountered inside an action" ) );
call    0 never executed
    #####:13216:			yyterminate();
        -:13217:			}
        -:13218:	YY_BREAK
      595:13219:case 162:
      595:13220:YY_RULE_SETUP
branch  0 taken 595 (fallthrough)
branch  1 taken 0
        -:13221:{
      595:13222:			yylval = myesc( (Char *) yytext );
call    0 returned 595
        -:13223:
      595:13224:			if ( YY_START == FIRSTCCL )
branch  0 taken 11 (fallthrough)
branch  1 taken 584
       11:13225:				BEGIN(CCL);
        -:13226:
      595:13227:			return CHAR;
        -:13228:			}
        -:13229:	YY_BREAK
        -:13230:
     1556:13231:case 163:
     1556:13232:YY_RULE_SETUP
branch  0 taken 1556 (fallthrough)
branch  1 taken 0
     1556:13233:ECHO;
call    0 returned 1556
     1556:13234:	YY_BREAK
      113:13235:case YY_STATE_EOF(SECT3):
      113:13236:sectnum = 0; yyterminate();
        -:13237:	YY_BREAK
        -:13238:
    #####:13239:case 164:
    #####:13240:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:13241:format_synerr( _( "bad character: %s" ), yytext );
call    0 never executed
    #####:13242:	YY_BREAK
    #####:13243:case 165:
    #####:13244:YY_RULE_SETUP
branch  0 never executed
branch  1 never executed
    #####:13245:YY_FATAL_ERROR( "flex scanner jammed" );
call    0 never executed
    #####:13246:	YY_BREAK
      432:13247:case YY_STATE_EOF(INITIAL):
        -:13248:case YY_STATE_EOF(SECT2):
        -:13249:case YY_STATE_EOF(CODEBLOCK):
        -:13250:case YY_STATE_EOF(PICKUPDEF):
        -:13251:case YY_STATE_EOF(SC):
        -:13252:case YY_STATE_EOF(CARETISBOL):
        -:13253:case YY_STATE_EOF(NUM):
        -:13254:case YY_STATE_EOF(QUOTE):
        -:13255:case YY_STATE_EOF(FIRSTCCL):
        -:13256:case YY_STATE_EOF(CCL):
        -:13257:case YY_STATE_EOF(RECOVER):
        -:13258:case YY_STATE_EOF(PERCENT_BRACE_ACTION):
        -:13259:case YY_STATE_EOF(OPTION):
        -:13260:case YY_STATE_EOF(LINEDIR):
      432:13261:	yyterminate();
        -:13262:
     1111:13263:	case YY_END_OF_BUFFER:
        -:13264:		{
        -:13265:		/* Amount of text matched not including the EOB char. */
     1111:13266:		int yy_amount_of_matched_text = (int) (yy_cp - yytext_ptr) - 1;
        -:13267:
        -:13268:		/* Undo the effects of YY_DO_BEFORE_ACTION. */
     1111:13269:		*yy_cp = yy_hold_char;
        -:13270:		YY_RESTORE_YY_MORE_OFFSET
        -:13271:
     1111:13272:		if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )
branch  0 taken 561 (fallthrough)
branch  1 taken 550
        -:13273:			{
        -:13274:			/* We're scanning a new file or input source.  It's
        -:13275:			 * possible that this happened because the user
        -:13276:			 * just pointed yyin at a new source and called
        -:13277:			 * yylex().  If so, then we have to assure
        -:13278:			 * consistency between yy_current_buffer and our
        -:13279:			 * globals.  Here is the right place to do so, because
        -:13280:			 * this is the first action (other than possibly a
        -:13281:			 * back-up) that will match for the new input source.
        -:13282:			 */
      561:13283:			yy_n_chars = yy_current_buffer->yy_n_chars;
      561:13284:			yy_current_buffer->yy_input_file = yyin;
      561:13285:			yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;
        -:13286:			}
        -:13287:
        -:13288:		/* Note that here we test for yy_c_buf_p "<=" to the position
        -:13289:		 * of the first EOB in the buffer, since yy_c_buf_p will
        -:13290:		 * already have been incremented past the NUL character
        -:13291:		 * (since all states make transitions on EOB to the
        -:13292:		 * end-of-buffer state).  Contrast this with the test
        -:13293:		 * in input().
        -:13294:		 */
     1111:13295:		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
branch  0 taken 0 (fallthrough)
branch  1 taken 1111
        -:13296:			{ /* This was really a NUL. */
        -:13297:			yy_state_type yy_next_state;
        -:13298:
    #####:13299:			yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;
        -:13300:
    #####:13301:			yy_current_state = yy_get_previous_state();
call    0 never executed
        -:13302:
        -:13303:			/* Okay, we're now positioned to make the NUL
        -:13304:			 * transition.  We couldn't have
        -:13305:			 * yy_get_previous_state() go ahead and do it
        -:13306:			 * for us because it doesn't know how to deal
        -:13307:			 * with the possibility of jamming (and we don't
        -:13308:			 * want to build jamming into it because then it
        -:13309:			 * will run more slowly).
        -:13310:			 */
        -:13311:
    #####:13312:			yy_next_state = yy_try_NUL_trans( yy_current_state );
call    0 never executed
        -:13313:
    #####:13314:			yy_bp = yytext_ptr + YY_MORE_ADJ;
        -:13315:
    #####:13316:			if ( yy_next_state )
branch  0 never executed
branch  1 never executed
        -:13317:				{
        -:13318:				/* Consume the NUL. */
    #####:13319:				yy_cp = ++yy_c_buf_p;
    #####:13320:				yy_current_state = yy_next_state;
    #####:13321:				goto yy_match;
        -:13322:				}
        -:13323:
        -:13324:			else
        -:13325:				{
    #####:13326:				yy_cp = yy_c_buf_p;
    #####:13327:				goto yy_find_action;
        -:13328:				}
        -:13329:			}
        -:13330:
     1111:13331:		else switch ( yy_get_next_buffer() )
call    0 returned 1111
        -:13332:			{
      547:13333:			case EOB_ACT_END_OF_FILE:
        -:13334:				{
      547:13335:				yy_did_buffer_switch_on_eof = 0;
        -:13336:
      547:13337:				if ( yywrap() )
call    0 returned 547
branch  1 taken 546 (fallthrough)
branch  2 taken 1
        -:13338:					{
        -:13339:					/* Note: because we've taken care in
        -:13340:					 * yy_get_next_buffer() to have set up
        -:13341:					 * yytext, we can now set up
        -:13342:					 * yy_c_buf_p so that if some total
        -:13343:					 * hoser (like flex itself) wants to
        -:13344:					 * call the scanner after we return the
        -:13345:					 * YY_NULL, it'll still work - another
        -:13346:					 * YY_NULL will get returned.
        -:13347:					 */
      546:13348:					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;
        -:13349:
      546:13350:					yy_act = YY_STATE_EOF(YY_START);
      546:13351:					goto do_action;
        -:13352:					}
        -:13353:
        -:13354:				else
        -:13355:					{
        1:13356:					if ( ! yy_did_buffer_switch_on_eof )
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:13357:						YY_NEW_FILE;
call    0 returned 1
        -:13358:					}
        1:13359:				break;
        -:13360:				}
        -:13361:
      564:13362:			case EOB_ACT_CONTINUE_SCAN:
      564:13363:				yy_c_buf_p =
      564:13364:					yytext_ptr + yy_amount_of_matched_text;
        -:13365:
      564:13366:				yy_current_state = yy_get_previous_state();
call    0 returned 564
        -:13367:
      564:13368:				yy_cp = yy_c_buf_p;
      564:13369:				yy_bp = yytext_ptr + YY_MORE_ADJ;
      564:13370:				goto yy_match;
        -:13371:
    #####:13372:			case EOB_ACT_LAST_MATCH:
    #####:13373:				yy_c_buf_p =
    #####:13374:				&yy_current_buffer->yy_ch_buf[yy_n_chars];
        -:13375:
    #####:13376:				yy_current_state = yy_get_previous_state();
call    0 never executed
        -:13377:
    #####:13378:				yy_cp = yy_c_buf_p;
    #####:13379:				yy_bp = yytext_ptr + YY_MORE_ADJ;
    #####:13380:				goto yy_find_action;
        -:13381:			}
        1:13382:		break;
        -:13383:		}
        -:13384:
    #####:13385:	default:
    #####:13386:		YY_FATAL_ERROR(
call    0 never executed
        -:13387:			"fatal flex scanner internal error--no action found" );
        -:13388:	} /* end of action switch */
        -:13389:		} /* end of scanning one token */
        -:13390:	} /* end of yylex */
        -:13391:
        -:13392:
        -:13393:/* yy_get_next_buffer - try to read in a new buffer
        -:13394: *
        -:13395: * Returns a code representing an action:
        -:13396: *	EOB_ACT_LAST_MATCH -
        -:13397: *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
        -:13398: *	EOB_ACT_END_OF_FILE - end of file
        -:13399: */
        -:13400:
function yy_get_next_buffer called 1111 returned 100% blocks executed 42%
     1111:13401:static int yy_get_next_buffer()
        -:13402:	{
     1111:13403:	register char *dest = yy_current_buffer->yy_ch_buf;
     1111:13404:	register char *source = yytext_ptr;
        -:13405:	register int number_to_move, i;
        -:13406:	int ret_val;
        -:13407:
     1111:13408:	if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
branch  0 taken 0 (fallthrough)
branch  1 taken 1111
    #####:13409:		YY_FATAL_ERROR(
call    0 never executed
        -:13410:		"fatal flex scanner internal error--end of buffer missed" );
        -:13411:
     1111:13412:	if ( yy_current_buffer->yy_fill_buffer == 0 )
branch  0 taken 0 (fallthrough)
branch  1 taken 1111
        -:13413:		{ /* Don't try to fill the buffer, so this is an EOF. */
    #####:13414:		if ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )
branch  0 never executed
branch  1 never executed
        -:13415:			{
        -:13416:			/* We matched a single character, the EOB, so
        -:13417:			 * treat this as a final EOF.
        -:13418:			 */
    #####:13419:			return EOB_ACT_END_OF_FILE;
        -:13420:			}
        -:13421:
        -:13422:		else
        -:13423:			{
        -:13424:			/* We matched some text prior to the EOB, first
        -:13425:			 * process it.
        -:13426:			 */
    #####:13427:			return EOB_ACT_LAST_MATCH;
        -:13428:			}
        -:13429:		}
        -:13430:
        -:13431:	/* Try to read more data. */
        -:13432:
        -:13433:	/* First move last chars to start of buffer. */
     1111:13434:	number_to_move = (int) (yy_c_buf_p - yytext_ptr) - 1;
        -:13435:
     1114:13436:	for ( i = 0; i < number_to_move; ++i )
branch  0 taken 3
branch  1 taken 1111 (fallthrough)
        3:13437:		*(dest++) = *(source++);
        -:13438:
     1111:13439:	if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )
branch  0 taken 0 (fallthrough)
branch  1 taken 1111
        -:13440:		/* don't do the read, it's not guaranteed to return an EOF,
        -:13441:		 * just force an EOF
        -:13442:		 */
        -:13443:#ifndef F_JR_1
    #####:13444:		yy_current_buffer->yy_n_chars = yy_n_chars = 0;
        -:13445:#else
        -:13446:        yy_current_buffer->yy_n_chars = yy_n_chars;
        -:13447:#endif
        -:13448:	else
        -:13449:		{
     1111:13450:		int num_to_read =
     1111:13451:			yy_current_buffer->yy_buf_size - number_to_move - 1;
        -:13452:
     1111:13453:		while ( num_to_read <= 0 )
branch  0 taken 0
branch  1 taken 1111 (fallthrough)
        -:13454:			{ /* Not enough room in the buffer - grow it. */
        -:13455:#ifdef YY_USES_REJECT
        -:13456:			YY_FATAL_ERROR(
        -:13457:"input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
        -:13458:#else
        -:13459:
        -:13460:			/* just a shorter name for the current buffer */
    #####:13461:			YY_BUFFER_STATE b = yy_current_buffer;
        -:13462:
    #####:13463:			int yy_c_buf_p_offset =
    #####:13464:				(int) (yy_c_buf_p - b->yy_ch_buf);
        -:13465:
    #####:13466:			if ( b->yy_is_our_buffer )
branch  0 never executed
branch  1 never executed
        -:13467:				{
    #####:13468:				int new_size = b->yy_buf_size * 2;
        -:13469:
    #####:13470:				if ( new_size <= 0 )
branch  0 never executed
branch  1 never executed
    #####:13471:					b->yy_buf_size += b->yy_buf_size / 8;
        -:13472:				else
    #####:13473:					b->yy_buf_size *= 2;
        -:13474:
    #####:13475:				b->yy_ch_buf = (char *)
        -:13476:					/* Include room in for 2 EOB chars. */
    #####:13477:					yy_flex_realloc( (void *) b->yy_ch_buf,
    #####:13478:							 b->yy_buf_size + 2 );
call    0 never executed
        -:13479:				}
        -:13480:			else
        -:13481:				/* Can't grow it, we don't own it. */
    #####:13482:				b->yy_ch_buf = 0;
        -:13483:
    #####:13484:			if ( ! b->yy_ch_buf )
branch  0 never executed
branch  1 never executed
    #####:13485:				YY_FATAL_ERROR(
call    0 never executed
        -:13486:				"fatal error - scanner input buffer overflow" );
        -:13487:
    #####:13488:			yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];
        -:13489:
    #####:13490:			num_to_read = yy_current_buffer->yy_buf_size -
    #####:13491:						number_to_move - 1;
        -:13492:#endif
        -:13493:			}
        -:13494:
     1111:13495:		if ( num_to_read > YY_READ_BUF_SIZE )
branch  0 taken 1111 (fallthrough)
branch  1 taken 0
     1111:13496:			num_to_read = YY_READ_BUF_SIZE;
        -:13497:
        -:13498:		/* Read in more data. */
    1111*:13499:		YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
branch  0 taken 0 (fallthrough)
branch  1 taken 1111
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
call   13 never executed
branch 14 never executed
branch 15 never executed
call   16 never executed
call   17 returned 1111
branch 18 taken 547 (fallthrough)
branch 19 taken 564
call   20 returned 547
branch 21 taken 0 (fallthrough)
branch 22 taken 547
call   23 never executed
        -:13500:			yy_n_chars, num_to_read );
        -:13501:#ifndef F_JR_2
     1111:13502:		yy_current_buffer->yy_n_chars = yy_n_chars;
        -:13503:#else
        -:13504:        yy_current_buffer->yy_n_chars = yy_n_chars = 0;
        -:13505:#endif
        -:13506:		}
        -:13507:
     1111:13508:	if ( yy_n_chars == 0 )
branch  0 taken 547 (fallthrough)
branch  1 taken 564
        -:13509:		{
      547:13510:		if ( number_to_move == YY_MORE_ADJ )
branch  0 taken 547 (fallthrough)
branch  1 taken 0
        -:13511:			{
      547:13512:			ret_val = EOB_ACT_END_OF_FILE;
      547:13513:			yyrestart( yyin );
call    0 returned 547
        -:13514:			}
        -:13515:
        -:13516:		else
        -:13517:			{
    #####:13518:			ret_val = EOB_ACT_LAST_MATCH;
    #####:13519:			yy_current_buffer->yy_buffer_status =
        -:13520:				YY_BUFFER_EOF_PENDING;
        -:13521:			}
        -:13522:		}
        -:13523:
        -:13524:	else
      564:13525:		ret_val = EOB_ACT_CONTINUE_SCAN;
        -:13526:
     1111:13527:	yy_n_chars += number_to_move;
     1111:13528:	yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
     1111:13529:	yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
        -:13530:
     1111:13531:	yytext_ptr = &yy_current_buffer->yy_ch_buf[0];
        -:13532:
     1111:13533:	return ret_val;
        -:13534:	}
        -:13535:
        -:13536:
        -:13537:/* yy_get_previous_state - get the state just before the EOB char was reached */
        -:13538:
function yy_get_previous_state called 564 returned 100% blocks executed 93%
      564:13539:static yy_state_type yy_get_previous_state()
        -:13540:	{
        -:13541:	register yy_state_type yy_current_state;
        -:13542:	register char *yy_cp;
        -:13543:
      564:13544:	yy_current_state = yy_start;
      564:13545:	yy_current_state += YY_AT_BOL();
        -:13546:
      567:13547:	for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
branch  0 taken 3
branch  1 taken 564 (fallthrough)
        -:13548:		{
       3*:13549:		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        3:13550:		if ( yy_accept[yy_current_state] )
branch  0 taken 1 (fallthrough)
branch  1 taken 2
        -:13551:			{
        1:13552:			yy_last_accepting_state = yy_current_state;
        1:13553:			yy_last_accepting_cpos = yy_cp;
        -:13554:			}
        4:13555:		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
branch  0 taken 1
branch  1 taken 3 (fallthrough)
        -:13556:			{
        1:13557:			yy_current_state = (int) yy_def[yy_current_state];
        1:13558:			if ( yy_current_state >= 769 )
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:13559:				yy_c = yy_meta[(unsigned int) yy_c];
        -:13560:			}
        3:13561:		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
        -:13562:		}
        -:13563:
      564:13564:	return yy_current_state;
        -:13565:	}
        -:13566:
        -:13567:
        -:13568:/* yy_try_NUL_trans - try to make a transition on the NUL character
        -:13569: *
        -:13570: * synopsis
        -:13571: *	next_state = yy_try_NUL_trans( current_state );
        -:13572: */
        -:13573:
        -:13574:#ifdef YY_USE_PROTOS
function yy_try_NUL_trans called 0 returned 0% blocks executed 0%
    #####:13575:static yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )
        -:13576:#else
        -:13577:static yy_state_type yy_try_NUL_trans( yy_current_state )
        -:13578:yy_state_type yy_current_state;
        -:13579:#endif
        -:13580:	{
        -:13581:	register int yy_is_jam;
    #####:13582:	register char *yy_cp = yy_c_buf_p;
        -:13583:
    #####:13584:	register YY_CHAR yy_c = 1;
    #####:13585:	if ( yy_accept[yy_current_state] )
branch  0 never executed
branch  1 never executed
        -:13586:		{
    #####:13587:		yy_last_accepting_state = yy_current_state;
    #####:13588:		yy_last_accepting_cpos = yy_cp;
        -:13589:		}
    #####:13590:	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
branch  0 never executed
branch  1 never executed
        -:13591:		{
    #####:13592:		yy_current_state = (int) yy_def[yy_current_state];
    #####:13593:		if ( yy_current_state >= 769 )
branch  0 never executed
branch  1 never executed
    #####:13594:			yy_c = yy_meta[(unsigned int) yy_c];
        -:13595:		}
    #####:13596:	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
    #####:13597:	yy_is_jam = (yy_current_state == 768);
        -:13598:
    #####:13599:	return yy_is_jam ? 0 : yy_current_state;
branch  0 never executed
branch  1 never executed
        -:13600:	}
        -:13601:
        -:13602:
        -:13603:#ifndef YY_NO_UNPUT
        -:13604:#ifdef YY_USE_PROTOS
function yyunput called 3997 returned 100% blocks executed 29%
     3997:13605:static void yyunput( int c, register char *yy_bp )
        -:13606:#else
        -:13607:static void yyunput( c, yy_bp )
        -:13608:int c;
        -:13609:register char *yy_bp;
        -:13610:#endif
        -:13611:	{
     3997:13612:	register char *yy_cp = yy_c_buf_p;
        -:13613:
        -:13614:	/* undo effects of setting up yytext */
     3997:13615:	*yy_cp = yy_hold_char;
        -:13616:
     3997:13617:	if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
branch  0 taken 0 (fallthrough)
branch  1 taken 3997
        -:13618:		{ /* need to shift things up to make room */
        -:13619:		/* +2 for EOB chars. */
    #####:13620:		register int number_to_move = yy_n_chars + 2;
    #####:13621:		register char *dest = &yy_current_buffer->yy_ch_buf[
    #####:13622:					yy_current_buffer->yy_buf_size + 2];
    #####:13623:		register char *source =
    #####:13624:				&yy_current_buffer->yy_ch_buf[number_to_move];
        -:13625:
    #####:13626:		while ( source > yy_current_buffer->yy_ch_buf )
branch  0 never executed
branch  1 never executed
    #####:13627:			*--dest = *--source;
        -:13628:
    #####:13629:		yy_cp += (int) (dest - source);
    #####:13630:		yy_bp += (int) (dest - source);
        -:13631:#ifndef F_AA_5
    #####:13632:		yy_current_buffer->yy_n_chars =
    #####:13633:			yy_n_chars = yy_current_buffer->yy_buf_size;
        -:13634:#else
        -:13635:		yy_current_buffer->yy_n_chars =
        -:13636:			yy_current_buffer->yy_buf_size;
        -:13637:#endif
        -:13638:
    #####:13639:		if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
branch  0 never executed
branch  1 never executed
    #####:13640:			YY_FATAL_ERROR( "flex scanner push-back overflow" );
call    0 never executed
        -:13641:		}
        -:13642:
     3997:13643:	*--yy_cp = (char) c;
        -:13644:
        -:13645:
     3997:13646:	yytext_ptr = yy_bp;
     3997:13647:	yy_hold_char = *yy_cp;
     3997:13648:	yy_c_buf_p = yy_cp;
     3997:13649:	}
        -:13650:#endif	/* ifndef YY_NO_UNPUT */
        -:13651:
        -:13652:
        -:13653:#ifdef __cplusplus
        -:13654:static int yyinput()
        -:13655:#else
function input called 233 returned 100% blocks executed 19%
      233:13656:static int input()
        -:13657:#endif
        -:13658:	{
        -:13659:	int c;
        -:13660:
      233:13661:	*yy_c_buf_p = yy_hold_char;
        -:13662:
      233:13663:	if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
branch  0 taken 0 (fallthrough)
branch  1 taken 233
        -:13664:		{
        -:13665:		/* yy_c_buf_p now points to the character we want to return.
        -:13666:		 * If this occurs *before* the EOB characters, then it's a
        -:13667:		 * valid NUL; if not, then we've hit the end of the buffer.
        -:13668:		 */
    #####:13669:		if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
branch  0 never executed
branch  1 never executed
        -:13670:			/* This was really a NUL. */
    #####:13671:			*yy_c_buf_p = '\0';
        -:13672:
        -:13673:		else
        -:13674:			{ /* need more input */
    #####:13675:			int offset = yy_c_buf_p - yytext_ptr;
    #####:13676:			++yy_c_buf_p;
        -:13677:
    #####:13678:			switch ( yy_get_next_buffer() )
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -:13679:				{
    #####:13680:				case EOB_ACT_LAST_MATCH:
        -:13681:					/* This happens because yy_g_n_b()
        -:13682:					 * sees that we've accumulated a
        -:13683:					 * token and flags that we need to
        -:13684:					 * try matching the token before
        -:13685:					 * proceeding.  But for input(),
        -:13686:					 * there's no matching to consider.
        -:13687:					 * So convert the EOB_ACT_LAST_MATCH
        -:13688:					 * to EOB_ACT_END_OF_FILE.
        -:13689:					 */
        -:13690:
        -:13691:					/* Reset buffer status. */
        -:13692:#ifndef F_AA_3
    #####:13693:					yyrestart( yyin );
call    0 never executed
        -:13694:#else
        -:13695:
        -:13696:#endif
        -:13697:
        -:13698:					/* fall through */
        -:13699:
    #####:13700:				case EOB_ACT_END_OF_FILE:
        -:13701:					{
    #####:13702:					if ( yywrap() )
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:13703:						return EOF;
        -:13704:
    #####:13705:					if ( ! yy_did_buffer_switch_on_eof )
branch  0 never executed
branch  1 never executed
    #####:13706:						YY_NEW_FILE;
call    0 never executed
        -:13707:#ifdef __cplusplus
        -:13708:					return yyinput();
        -:13709:#else
    #####:13710:					return input();
call    0 never executed
        -:13711:#endif
        -:13712:					}
        -:13713:
    #####:13714:				case EOB_ACT_CONTINUE_SCAN:
    #####:13715:					yy_c_buf_p = yytext_ptr + offset;
    #####:13716:					break;
        -:13717:				}
        -:13718:			}
        -:13719:		}
        -:13720:
      233:13721:	c = *(unsigned char *) yy_c_buf_p;	/* cast for 8-bit char's */
      233:13722:	*yy_c_buf_p = '\0';	/* preserve yytext */
      233:13723:	yy_hold_char = *++yy_c_buf_p;
        -:13724:
      233:13725:	yy_current_buffer->yy_at_bol = (c == '\n');
        -:13726:
      233:13727:	return c;
        -:13728:	}
        -:13729:
        -:13730:
        -:13731:#ifdef YY_USE_PROTOS
function yyrestart called 548 returned 100% blocks executed 67%
      548:13732:void yyrestart( FILE *input_file )
        -:13733:#else
        -:13734:void yyrestart( input_file )
        -:13735:FILE *input_file;
        -:13736:#endif
        -:13737:	{
      548:13738:	if ( ! yy_current_buffer )
branch  0 taken 0 (fallthrough)
branch  1 taken 548
    #####:13739:		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );
call    0 never executed
        -:13740:
      548:13741:	yy_init_buffer( yy_current_buffer, input_file );
call    0 returned 548
      548:13742:	yy_load_buffer_state();
call    0 returned 548
      548:13743:	}
        -:13744:
        -:13745:
        -:13746:#ifdef YY_USE_PROTOS
function yy_switch_to_buffer called 0 returned 0% blocks executed 0%
    #####:13747:void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
        -:13748:#else
        -:13749:void yy_switch_to_buffer( new_buffer )
        -:13750:YY_BUFFER_STATE new_buffer;
        -:13751:#endif
        -:13752:	{
    #####:13753:	if ( yy_current_buffer == new_buffer )
branch  0 never executed
branch  1 never executed
    #####:13754:		return;
        -:13755:
    #####:13756:	if ( yy_current_buffer )
branch  0 never executed
branch  1 never executed
        -:13757:		{
        -:13758:		/* Flush out information for old buffer. */
    #####:13759:		*yy_c_buf_p = yy_hold_char;
    #####:13760:		yy_current_buffer->yy_buf_pos = yy_c_buf_p;
    #####:13761:		yy_current_buffer->yy_n_chars = yy_n_chars;
        -:13762:		}
        -:13763:
    #####:13764:	yy_current_buffer = new_buffer;
    #####:13765:	yy_load_buffer_state();
call    0 never executed
        -:13766:
        -:13767:	/* We don't actually know whether we did this switch during
        -:13768:	 * EOF (yywrap()) processing, but the only time this flag
        -:13769:	 * is looked at is after yywrap() is called, so it's safe
        -:13770:	 * to go ahead and always set it.
        -:13771:	 */
    #####:13772:	yy_did_buffer_switch_on_eof = 1;
        -:13773:	}
        -:13774:
        -:13775:
        -:13776:#ifdef YY_USE_PROTOS
function yy_load_buffer_state called 1656 returned 100% blocks executed 100%
     1656:13777:void yy_load_buffer_state( void )
        -:13778:#else
        -:13779:void yy_load_buffer_state()
        -:13780:#endif
        -:13781:	{
     1656:13782:	yy_n_chars = yy_current_buffer->yy_n_chars;
     1656:13783:	yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
     1656:13784:	yyin = yy_current_buffer->yy_input_file;
     1656:13785:	yy_hold_char = *yy_c_buf_p;
     1656:13786:	}
        -:13787:
        -:13788:
        -:13789:#ifdef YY_USE_PROTOS
function yy_create_buffer called 560 returned 100% blocks executed 78%
      560:13790:YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )
        -:13791:#else
        -:13792:YY_BUFFER_STATE yy_create_buffer( file, size )
        -:13793:FILE *file;
        -:13794:int size;
        -:13795:#endif
        -:13796:	{
        -:13797:	YY_BUFFER_STATE b;
        -:13798:
      560:13799:	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
call    0 returned 560
      560:13800:	if ( ! b )
branch  0 taken 0 (fallthrough)
branch  1 taken 560
    #####:13801:		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
call    0 never executed
        -:13802:
      560:13803:	b->yy_buf_size = size;
        -:13804:
        -:13805:	/* yy_ch_buf has to be 2 characters longer than the size given because
        -:13806:	 * we need to put in 2 end-of-buffer characters.
        -:13807:	 */
      560:13808:	b->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );
call    0 returned 560
      560:13809:	if ( ! b->yy_ch_buf )
branch  0 taken 0 (fallthrough)
branch  1 taken 560
    #####:13810:		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
call    0 never executed
        -:13811:
      560:13812:	b->yy_is_our_buffer = 1;
        -:13813:
      560:13814:	yy_init_buffer( b, file );
call    0 returned 560
        -:13815:
      560:13816:	return b;
        -:13817:	}
        -:13818:
        -:13819:
        -:13820:#ifdef YY_USE_PROTOS
function yy_delete_buffer called 0 returned 0% blocks executed 0%
    #####:13821:void yy_delete_buffer( YY_BUFFER_STATE b )
        -:13822:#else
        -:13823:void yy_delete_buffer( b )
        -:13824:YY_BUFFER_STATE b;
        -:13825:#endif
        -:13826:	{
    #####:13827:	if ( ! b )
branch  0 never executed
branch  1 never executed
    #####:13828:		return;
        -:13829:
    #####:13830:	if ( b == yy_current_buffer )
branch  0 never executed
branch  1 never executed
    #####:13831:		yy_current_buffer = (YY_BUFFER_STATE) 0;
        -:13832:
    #####:13833:	if ( b->yy_is_our_buffer )
branch  0 never executed
branch  1 never executed
    #####:13834:		yy_flex_free( (void *) b->yy_ch_buf );
call    0 never executed
        -:13835:
    #####:13836:	yy_flex_free( (void *) b );
call    0 never executed
        -:13837:	}
        -:13838:
        -:13839:
        -:13840:#ifndef YY_ALWAYS_INTERACTIVE
        -:13841:#ifndef YY_NEVER_INTERACTIVE
        -:13842:extern int isatty YY_PROTO(( int ));
        -:13843:#endif
        -:13844:#endif
        -:13845:
        -:13846:#ifdef YY_USE_PROTOS
function yy_init_buffer called 1108 returned 100% blocks executed 88%
     1108:13847:void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )
        -:13848:#else
        -:13849:void yy_init_buffer( b, file )
        -:13850:YY_BUFFER_STATE b;
        -:13851:FILE *file;
        -:13852:#endif
        -:13853:
        -:13854:
        -:13855:	{
     1108:13856:	yy_flush_buffer( b );
call    0 returned 1108
        -:13857:
     1108:13858:	b->yy_input_file = file;
     1108:13859:	b->yy_fill_buffer = 1;
        -:13860:
        -:13861:#if YY_ALWAYS_INTERACTIVE
        -:13862:	b->yy_is_interactive = 1;
        -:13863:#else
        -:13864:#if YY_NEVER_INTERACTIVE
        -:13865:	b->yy_is_interactive = 0;
        -:13866:#else
    1108*:13867:	b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
branch  0 taken 1108 (fallthrough)
branch  1 taken 0
call    2 returned 1108
call    3 returned 1108
branch  4 taken 0 (fallthrough)
branch  5 taken 1108
        -:13868:#endif
        -:13869:#endif
     1108:13870:	}
        -:13871:
        -:13872:
        -:13873:#ifdef YY_USE_PROTOS
function yy_flush_buffer called 1108 returned 100% blocks executed 80%
     1108:13874:void yy_flush_buffer( YY_BUFFER_STATE b )
        -:13875:#else
        -:13876:void yy_flush_buffer( b )
        -:13877:YY_BUFFER_STATE b;
        -:13878:#endif
        -:13879:
        -:13880:	{
        -:13881:#ifndef F_AA_4
     1108:13882:	if ( ! b )
branch  0 taken 0 (fallthrough)
branch  1 taken 1108
        -:13883:#else
        -:13884:	if ( b )
        -:13885:#endif
    #####:13886:		return;
        -:13887:
     1108:13888:	b->yy_n_chars = 0;
        -:13889:
        -:13890:	/* We always need two end-of-buffer characters.  The first causes
        -:13891:	 * a transition to the end-of-buffer state.  The second causes
        -:13892:	 * a jam in that state.
        -:13893:	 */
     1108:13894:	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
     1108:13895:	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
        -:13896:
     1108:13897:	b->yy_buf_pos = &b->yy_ch_buf[0];
        -:13898:
     1108:13899:	b->yy_at_bol = 1;
     1108:13900:	b->yy_buffer_status = YY_BUFFER_NEW;
        -:13901:
     1108:13902:	if ( b == yy_current_buffer )
branch  0 taken 548 (fallthrough)
branch  1 taken 560
      548:13903:		yy_load_buffer_state();
call    0 returned 548
        -:13904:	}
        -:13905:
        -:13906:
        -:13907:#ifndef YY_NO_SCAN_BUFFER
        -:13908:#ifdef YY_USE_PROTOS
function yy_scan_buffer called 0 returned 0% blocks executed 0%
    #####:13909:YY_BUFFER_STATE yy_scan_buffer( char *base, yy_size_t size )
        -:13910:#else
        -:13911:YY_BUFFER_STATE yy_scan_buffer( base, size )
        -:13912:char *base;
        -:13913:yy_size_t size;
        -:13914:#endif
        -:13915:	{
        -:13916:	YY_BUFFER_STATE b;
        -:13917:
    #####:13918:	if ( size < 2 ||
branch  0 never executed
branch  1 never executed
    #####:13919:	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
branch  0 never executed
branch  1 never executed
    #####:13920:	     base[size-1] != YY_END_OF_BUFFER_CHAR )
branch  0 never executed
branch  1 never executed
        -:13921:		/* They forgot to leave room for the EOB's. */
    #####:13922:		return 0;
        -:13923:
    #####:13924:	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
call    0 never executed
    #####:13925:	if ( ! b )
branch  0 never executed
branch  1 never executed
    #####:13926:		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
call    0 never executed
        -:13927:
    #####:13928:	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
    #####:13929:	b->yy_buf_pos = b->yy_ch_buf = base;
    #####:13930:	b->yy_is_our_buffer = 0;
    #####:13931:	b->yy_input_file = 0;
    #####:13932:	b->yy_n_chars = b->yy_buf_size;
    #####:13933:	b->yy_is_interactive = 0;
    #####:13934:	b->yy_at_bol = 1;
    #####:13935:	b->yy_fill_buffer = 0;
    #####:13936:	b->yy_buffer_status = YY_BUFFER_NEW;
        -:13937:
    #####:13938:	yy_switch_to_buffer( b );
call    0 never executed
        -:13939:
    #####:13940:	return b;
        -:13941:	}
        -:13942:#endif
        -:13943:
        -:13944:
        -:13945:#ifndef YY_NO_SCAN_STRING
        -:13946:#ifdef YY_USE_PROTOS
function yy_scan_string called 0 returned 0% blocks executed 0%
    #####:13947:YY_BUFFER_STATE yy_scan_string( yyconst char *yy_str )
        -:13948:#else
        -:13949:YY_BUFFER_STATE yy_scan_string( yy_str )
        -:13950:#ifndef F_HD_3
        -:13951:yyconst char *yy_str;
        -:13952:#else
        -:13953:
        -:13954:#endif
        -:13955:#endif
        -:13956:	{
        -:13957:	int len;
    #####:13958:	for ( len = 0; yy_str[len]; ++len )
branch  0 never executed
branch  1 never executed
        -:13959:		;
        -:13960:
    #####:13961:	return yy_scan_bytes( yy_str, len );
call    0 never executed
        -:13962:	}
        -:13963:#endif
        -:13964:
        -:13965:
        -:13966:#ifndef YY_NO_SCAN_BYTES
        -:13967:#ifdef YY_USE_PROTOS
function yy_scan_bytes called 0 returned 0% blocks executed 0%
    #####:13968:YY_BUFFER_STATE yy_scan_bytes( yyconst char *bytes, int len )
        -:13969:#else
        -:13970:YY_BUFFER_STATE yy_scan_bytes( bytes, len )
        -:13971:yyconst char *bytes;
        -:13972:int len;
        -:13973:#endif
        -:13974:	{
        -:13975:	YY_BUFFER_STATE b;
        -:13976:	char *buf;
        -:13977:	yy_size_t n;
        -:13978:	int i;
        -:13979:
        -:13980:	/* Get memory for full buffer, including space for trailing EOB's. */
    #####:13981:	n = len + 2;
    #####:13982:	buf = (char *) yy_flex_alloc( n );
call    0 never executed
    #####:13983:	if ( ! buf )
branch  0 never executed
branch  1 never executed
    #####:13984:		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
call    0 never executed
        -:13985:
    #####:13986:	for ( i = 0; i < len; ++i )
branch  0 never executed
branch  1 never executed
    #####:13987:		buf[i] = bytes[i];
        -:13988:
    #####:13989:	buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;
        -:13990:
    #####:13991:	b = yy_scan_buffer( buf, n );
call    0 never executed
    #####:13992:	if ( ! b )
branch  0 never executed
branch  1 never executed
    #####:13993:		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
call    0 never executed
        -:13994:
        -:13995:	/* It's okay to grow etc. this buffer, and we should throw it
        -:13996:	 * away when we're done.
        -:13997:	 */
    #####:13998:	b->yy_is_our_buffer = 1;
        -:13999:
    #####:14000:	return b;
        -:14001:	}
        -:14002:#endif
        -:14003:
        -:14004:
        -:14005:#ifndef YY_NO_PUSH_STATE
        -:14006:#ifdef YY_USE_PROTOS
function yy_push_state called 357 returned 100% blocks executed 67%
      357:14007:static void yy_push_state( int new_state )
        -:14008:#else
        -:14009:static void yy_push_state( new_state )
        -:14010:int new_state;
        -:14011:#endif
        -:14012:	{
      357:14013:	if ( yy_start_stack_ptr >= yy_start_stack_depth )
branch  0 taken 124 (fallthrough)
branch  1 taken 233
        -:14014:		{
        -:14015:		yy_size_t new_size;
        -:14016:
      124:14017:		yy_start_stack_depth += YY_START_STACK_INCR;
      124:14018:		new_size = yy_start_stack_depth * sizeof( int );
        -:14019:
      124:14020:		if ( ! yy_start_stack )
branch  0 taken 124 (fallthrough)
branch  1 taken 0
      124:14021:			yy_start_stack = (int *) yy_flex_alloc( new_size );
call    0 returned 124
        -:14022:
        -:14023:		else
    #####:14024:			yy_start_stack = (int *) yy_flex_realloc(
call    0 never executed
        -:14025:					(void *) yy_start_stack, new_size );
        -:14026:
      124:14027:		if ( ! yy_start_stack )
branch  0 taken 0 (fallthrough)
branch  1 taken 124
    #####:14028:			YY_FATAL_ERROR(
call    0 never executed
        -:14029:			"out of memory expanding start-condition stack" );
        -:14030:		}
        -:14031:
      357:14032:	yy_start_stack[yy_start_stack_ptr++] = YY_START;
        -:14033:
      357:14034:	BEGIN(new_state);
      357:14035:	}
        -:14036:#endif
        -:14037:
        -:14038:
        -:14039:#ifndef YY_NO_POP_STATE
function yy_pop_state called 357 returned 100% blocks executed 67%
      357:14040:static void yy_pop_state()
        -:14041:	{
      357:14042:	if ( --yy_start_stack_ptr < 0 )
branch  0 taken 0 (fallthrough)
branch  1 taken 357
    #####:14043:		YY_FATAL_ERROR( "start-condition stack underflow" );
call    0 never executed
        -:14044:
      357:14045:	BEGIN(yy_start_stack[yy_start_stack_ptr]);
      357:14046:	}
        -:14047:#endif
        -:14048:
        -:14049:
        -:14050:#ifndef YY_NO_TOP_STATE
        -:14051:static int yy_top_state()
        -:14052:	{
        -:14053:	return yy_start_stack[yy_start_stack_ptr - 1];
        -:14054:	}
        -:14055:#endif
        -:14056:
        -:14057:#ifndef YY_EXIT_FAILURE
        -:14058:#define YY_EXIT_FAILURE 2
        -:14059:#endif
        -:14060:
        -:14061:#ifdef YY_USE_PROTOS
function yy_fatal_error called 0 returned 0% blocks executed 0%
    #####:14062:static void yy_fatal_error( yyconst char msg[] )
        -:14063:#else
        -:14064:static void yy_fatal_error( msg )
        -:14065:char msg[];
        -:14066:#endif
        -:14067:	{
    #####:14068:	(void) fprintf( err, "%s\n", msg );
call    0 never executed
    #####:14069:	exit( YY_EXIT_FAILURE );
        -:14070:	}
        -:14071:
        -:14072:
        -:14073:
        -:14074:/* Redefine yyless() so it works in section 3 code. */
        -:14075:
        -:14076:#undef yyless
        -:14077:#define yyless(n) \
        -:14078:	do \
        -:14079:		{ \
        -:14080:		/* Undo effects of setting up yytext. */ \
        -:14081:		yytext[yyleng] = yy_hold_char; \
        -:14082:		yy_c_buf_p = yytext + n; \
        -:14083:		yy_hold_char = *yy_c_buf_p; \
        -:14084:		*yy_c_buf_p = '\0'; \
        -:14085:		yyleng = n; \
        -:14086:		} \
        -:14087:	while ( 0 )
        -:14088:
        -:14089:
        -:14090:/* Internal utility routines. */
        -:14091:
        -:14092:#ifndef yytext_ptr
        -:14093:#ifdef YY_USE_PROTOS
        -:14094:static void yy_flex_strncpy( char *s1, yyconst char *s2, int n )
        -:14095:#else
        -:14096:static void yy_flex_strncpy( s1, s2, n )
        -:14097:char *s1;
        -:14098:yyconst char *s2;
        -:14099:int n;
        -:14100:#endif
        -:14101:	{
        -:14102:	register int i;
        -:14103:	for ( i = 0; i < n; ++i )
        -:14104:		s1[i] = s2[i];
        -:14105:	}
        -:14106:#endif
        -:14107:
        -:14108:#ifdef YY_NEED_STRLEN
        -:14109:#ifdef YY_USE_PROTOS
        -:14110:static int yy_flex_strlen( yyconst char *s )
        -:14111:#else
        -:14112:static int yy_flex_strlen( s )
        -:14113:yyconst char *s;
        -:14114:#endif
        -:14115:	{
        -:14116:	register int n;
        -:14117:	for ( n = 0; s[n]; ++n )
        -:14118:		;
        -:14119:
        -:14120:	return n;
        -:14121:	}
        -:14122:#endif
        -:14123:
        -:14124:
        -:14125:#ifdef YY_USE_PROTOS
function yy_flex_alloc called 1244 returned 100% blocks executed 100%
     1244:14126:static void *yy_flex_alloc( yy_size_t size )
        -:14127:#else
        -:14128:static void *yy_flex_alloc( size )
        -:14129:yy_size_t size;
        -:14130:#endif
        -:14131:	{
     1244:14132:	return (void *) malloc( size );
        -:14133:	}
        -:14134:
        -:14135:#ifdef YY_USE_PROTOS
function yy_flex_realloc called 0 returned 0% blocks executed 0%
    #####:14136:static void *yy_flex_realloc( void *ptr, yy_size_t size )
        -:14137:#else
        -:14138:static void *yy_flex_realloc( ptr, size )
        -:14139:void *ptr;
        -:14140:yy_size_t size;
        -:14141:#endif
        -:14142:	{
        -:14143:	/* The cast to (char *) in the following accommodates both
        -:14144:	 * implementations that use char* generic pointers, and those
        -:14145:	 * that use void* generic pointers.  It works with the latter
        -:14146:	 * because both ANSI C and C++ allow castless assignment from
        -:14147:	 * any pointer type to void*, and deal with argument conversions
        -:14148:	 * as though doing an assignment.
        -:14149:	 */
    #####:14150:	return (void *) realloc( (char *) ptr, size );
        -:14151:	}
        -:14152:
        -:14153:#ifdef YY_USE_PROTOS
function yy_flex_free called 0 returned 0% blocks executed 0%
    #####:14154:static void yy_flex_free( void *ptr )
        -:14155:#else
        -:14156:static void yy_flex_free( ptr )
        -:14157:void *ptr;
        -:14158:#endif
        -:14159:	{
    #####:14160:	free( ptr );
    #####:14161:	}
        -:14162:
        -:14163:#if YY_MAIN
        -:14164:int main()
        -:14165:	{
        -:14166:	yylex();
        -:14167:	return 0;
        -:14168:	}
        -:14169:#endif
        -:14170:
        -:14171:
        -:14172:
function yywrap called 547 returned 100% blocks executed 100%
      547:14173:int yywrap()
        -:14174:	{
      547:14175:	if ( --num_input_files > 0 )
branch  0 taken 1 (fallthrough)
branch  1 taken 546
        -:14176:		{
        1:14177:		set_input_file( *++input_files );
call    0 returned 1
        1:14178:		return 0;
        -:14179:		}
        -:14180:
        -:14181:	else
      546:14182:		return 1;
        -:14183:	}
        -:14184:
        -:14185:
        -:14186:/* set_input_file - open the given file (if NULL, stdin) for scanning */
        -:14187:
function set_input_file called 562 returned 100% blocks executed 80%
      562:14188:void set_input_file( file )
        -:14189:char *file;
        -:14190:	{
      562:14191:	if ( file && strcmp( file, "-" ) )
branch  0 taken 562 (fallthrough)
branch  1 taken 0
branch  2 taken 562 (fallthrough)
branch  3 taken 0
        -:14192:		{
      562:14193:		infilename = copy_string( file );
call    0 returned 562
      562:14194:		yyin = fopen( infilename, "r" );
call    0 returned 562
        -:14195:
      562:14196:		if ( yyin == NULL )
branch  0 taken 1 (fallthrough)
branch  1 taken 561
        1:14197:			lerrsf( _( "can't open %s" ), file );
call    0 returned 0
        -:14198:		}
        -:14199:
        -:14200:	else
        -:14201:		{
    #####:14202:		yyin = stdin;
    #####:14203:		infilename = copy_string( "<stdin>" );
call    0 never executed
        -:14204:		}
        -:14205:
      561:14206:	linenum = 1;
      561:14207:	}
        -:14208:
        -:14209:
        -:14210:/* Wrapper routines for accessing the scanner's malloc routines. */
        -:14211:
function flex_alloc called 43837 returned 100% blocks executed 100%
    43837:14212:void *flex_alloc( size )
        -:14213:size_t size;
        -:14214:	{
    43837:14215:	return (void *) malloc( size );
        -:14216:	}
        -:14217:
function flex_realloc called 171 returned 100% blocks executed 100%
      171:14218:void *flex_realloc( ptr, size )
        -:14219:void *ptr;
        -:14220:size_t size;
        -:14221:	{
      171:14222:	return (void *) realloc( ptr, size );
        -:14223:	}
        -:14224:
function flex_free called 1086 returned 100% blocks executed 100%
     1086:14225:void flex_free( ptr )
        -:14226:void *ptr;
        -:14227:	{
     1086:14228:	if ( ptr )
branch  0 taken 1086 (fallthrough)
branch  1 taken 0
     1086:14229:		free( ptr );
     1086:14230:	}
