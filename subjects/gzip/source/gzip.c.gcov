        -:    0:Source:gzip.c
        -:    0:Graph:gzip.gcno
        -:    0:Data:gzip.gcda
        -:    0:Runs:1
        -:    1:#include "crypt.h"
        -:    2:#include "getopt.h"
        -:    3:#include "config.h"
        -:    4:#include "gzip.h" 
        -:    5:#include "lzw.h"   
        -:    6:#include "tailor.h"
        -:    7:#include "revision.h"
        -:    8:#include "FaultSeeds.h"
        -:    9:
        -:   10:#include <stdio.h>
        -:   11:#include <ctype.h>
        -:   12:#include <sys/types.h>
        -:   13:#include <sys/stat.h>
        -:   14:#include <errno.h>
        -:   15:#include <signal.h>   
        -:   16:
        -:   17:/* bits.c -- output variable-length bit strings
        -:   18: * Copyright (C) 1992-1993 Jean-loup Gailly
        -:   19: * This is free software; you can redistribute it and/or modify it under the
        -:   20: * terms of the GNU General Public License, see the file COPYING.
        -:   21: */
        -:   22:
        -:   23:
        -:   24:/*
        -:   25: *  PURPOSE
        -:   26: *
        -:   27: *      Output variable-length bit strings. Compression can be done
        -:   28: *      to a file or to memory. (The latter is not supported in this version.)
        -:   29: *
        -:   30: *  DISCUSSION
        -:   31: *
        -:   32: *      The PKZIP "deflate" file format interprets compressed file data
        -:   33: *      as a sequence of bits.  Multi-bit strings in the file may cross
        -:   34: *      byte boundaries without restriction.
        -:   35: *
        -:   36: *      The first bit of each byte is the low-order bit.
        -:   37: *
        -:   38: *      The routines in this file allow a variable-length bit value to
        -:   39: *      be output right-to-left (useful for literal values). For
        -:   40: *      left-to-right output (useful for code strings from the tree routines),
        -:   41: *      the bits must have been reversed first with bi_reverse().
        -:   42: *
        -:   43: *      For in-memory compression, the compressed bit stream goes directly
        -:   44: *      into the requested output buffer. The input data is read in blocks
        -:   45: *      by the mem_read() function. The buffer is limited to 64K on 16 bit
        -:   46: *      machines.
        -:   47: *
        -:   48: *  INTERFACE
        -:   49: *
        -:   50: *      void bi_init (FILE *zipfile)
        -:   51: *          Initialize the bit string routines.
        -:   52: *
        -:   53: *      void send_bits (int value, int length)
        -:   54: *          Write out a bit string, taking the source bits right to
        -:   55: *          left.
        -:   56: *
        -:   57: *      int bi_reverse (int value, int length)
        -:   58: *          Reverse the bits of a bit string, taking the source bits left to
        -:   59: *          right and emitting them right to left.
        -:   60: *
        -:   61: *      void bi_windup (void)
        -:   62: *          Write out any remaining bits in an incomplete byte.
        -:   63: *
        -:   64: *      void copy_block(char *buf, unsigned len, int header)
        -:   65: *          Copy a stored block to the zip file, storing first the length and
        -:   66: *          its one's complement if requested.
        -:   67: *
        -:   68: */
        -:   69:
        -:   70:#ifdef DEBUG
        -:   71:#  include <stdio.h>
        -:   72:#endif
        -:   73:
        -:   74:#ifdef RCSID
        -:   75:static char rcsid[] = "$Id: bits.c,v 0.9 1993/06/11 10:16:58 jloup Exp $";
        -:   76:#endif
        -:   77:
        -:   78:/* ===========================================================================
        -:   79: * Local data used by the "bit string" routines.
        -:   80: */
        -:   81:
        -:   82:local file_t zfile; /* output gzip file */
        -:   83:
        -:   84:local unsigned short bi_buf;
        -:   85:/* Output buffer. bits are inserted starting at the bottom (least significant
        -:   86: * bits).
        -:   87: */
        -:   88:
        -:   89:#define Buf_size (8 * 2*sizeof(char))
        -:   90:/* Number of bits used within bi_buf. (bi_buf might be implemented on
        -:   91: * more than 16 bits on some systems.)
        -:   92: */
        -:   93:
        -:   94:local int bi_valid;
        -:   95:/* Number of valid bits in bi_buf.  All bits above the last valid bit
        -:   96: * are always zero.
        -:   97: */
        -:   98:
        -:   99:int (*read_buf) OF((char *buf, unsigned size));
        -:  100:/* Current input function. Set to mem_read for in-memory compression */
        -:  101:
        -:  102:#ifdef DEBUG
        -:  103:  off_t bits_sent;   /* bit length of the compressed data */
        -:  104:#endif
        -:  105:
        -:  106:/* ===========================================================================
        -:  107: * Initialize the bit string routines.
        -:  108: */
function bi_init called 1 returned 100% blocks executed 100%
        1:  109:void bi_init (zipfile)
        -:  110:    file_t zipfile; /* output zip file, NO_FILE for in-memory compression */
        -:  111:{
        1:  112:    zfile  = zipfile;
        1:  113:    bi_buf = 0;
        1:  114:    bi_valid = 0;
        -:  115:#ifdef DEBUG
        -:  116:    bits_sent = 0L;
        -:  117:#endif
        -:  118:
        -:  119:    /* Set the defaults for file compression. They are set by memcompress
        -:  120:     * for in-memory compression.
        -:  121:     */
        1:  122:    if (zfile != NO_FILE) {
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:  123:	read_buf  = file_read;
        -:  124:    }
        1:  125:}
        -:  126:
        -:  127:/* ===========================================================================
        -:  128: * Send a value on a given number of bits.
        -:  129: * IN assertion: length <= 16 and value fits in length bits.
        -:  130: */
function send_bits called 17225 returned 100% blocks executed 60%
    17225:  131:void send_bits(value, length)
        -:  132:    int value;  /* value to send */
        -:  133:    int length; /* number of bits */
        -:  134:{
        -:  135:#ifdef DEBUG
        -:  136:    Tracev((stderr," l %2d v %4x ", length, value));
        -:  137:    Assert(length > 0 && length <= 15, "invalid length");
        -:  138:    bits_sent += (off_t)length;
        -:  139:#endif
        -:  140:    /* If not enough room in bi_buf, use (valid) bits from bi_buf and
        -:  141:     * (16 - bi_valid) bits from value, leaving (width - (16-bi_valid))
        -:  142:     * unused bits in value.
        -:  143:     */
    17225:  144:    if (bi_valid > (int)Buf_size - length) {
branch  0 taken 6184 (fallthrough)
branch  1 taken 11041
     6184:  145:        bi_buf |= (value << bi_valid);
    6184*:  146:        put_short(bi_buf);
branch  0 taken 6184 (fallthrough)
branch  1 taken 0
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
     6184:  147:        bi_buf = (ush)value >> (Buf_size - bi_valid);
     6184:  148:        bi_valid += length - Buf_size;
        -:  149:    } else {
    11041:  150:        bi_buf |= value << bi_valid;
    11041:  151:        bi_valid += length;
        -:  152:    }
    17225:  153:}
        -:  154:
        -:  155:/* ===========================================================================
        -:  156: * Reverse the first len bits of a code, using straightforward code (a faster
        -:  157: * method would use a table)
        -:  158: * IN assertion: 1 <= len <= 15
        -:  159: */
function bi_reverse called 474 returned 100% blocks executed 100%
      474:  160:unsigned bi_reverse(code, len)
        -:  161:    unsigned code; /* the value to invert */
        -:  162:    int len;       /* its bit length */
        -:  163:{
      474:  164:    register unsigned res = 0;
        -:  165:    do {
     3743:  166:        res |= code & 1;
     3743:  167:        code >>= 1, res <<= 1;
     3743:  168:    } while (--len > 0);
branch  0 taken 3269
branch  1 taken 474 (fallthrough)
      474:  169:    return res >> 1;
        -:  170:}
        -:  171:
        -:  172:/* ===========================================================================
        -:  173: * Write out any remaining bits in an incomplete byte.
        -:  174: */
function bi_windup called 1 returned 100% blocks executed 36%
        1:  175:void bi_windup()
        -:  176:{
        1:  177:    if (bi_valid > 8) {
branch  0 taken 1 (fallthrough)
branch  1 taken 0
       1*:  178:        put_short(bi_buf);
branch  0 taken 1 (fallthrough)
branch  1 taken 0
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
    #####:  179:    } else if (bi_valid > 0) {
branch  0 never executed
branch  1 never executed
    #####:  180:        put_byte(bi_buf);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  181:    }
        1:  182:    bi_buf = 0;
        1:  183:    bi_valid = 0;
        -:  184:#ifdef DEBUG
        -:  185:    bits_sent = (bits_sent+7) & ~7;
        -:  186:#endif
        1:  187:}
        -:  188:
        -:  189:/* ===========================================================================
        -:  190: * Copy a stored block to the zip file, storing first the length and its
        -:  191: * one's complement if requested.
        -:  192: */
function copy_block called 0 returned 0% blocks executed 0%
    #####:  193:void copy_block(buf, len, header)
        -:  194:    char     *buf;    /* the input data */
        -:  195:    unsigned len;     /* its length */
        -:  196:    int      header;  /* true if block header must be written */
        -:  197:{
    #####:  198:    bi_windup();              /* align on byte boundary */
call    0 never executed
        -:  199:
    #####:  200:    if (header) {
branch  0 never executed
branch  1 never executed
    #####:  201:        put_short((ush)len);   
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
    #####:  202:        put_short((ush)~len);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
        -:  203:#ifdef DEBUG
        -:  204:        bits_sent += 2*16;
        -:  205:#endif
        -:  206:    }
        -:  207:#ifdef DEBUG
        -:  208:    bits_sent += (off_t)len<<3;
        -:  209:#endif
    #####:  210:    while (len--) {
branch  0 never executed
branch  1 never executed
        -:  211:#ifdef CRYPT
        -:  212:        int t;
        -:  213:	if (key) zencode(*buf, t);
        -:  214:#endif
    #####:  215:	put_byte(*buf++);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  216:    }
    #####:  217:}
        -:  218:/* crypt.c (dummy version) -- do not perform encryption
        -:  219: * Hardly worth copyrighting :-)
        -:  220: */
        -:  221:#ifdef RCSID
        -:  222:static char rcsid[] = "$Id: crypt.c,v 0.6 1993/03/22 09:48:47 jloup Exp $";
        -:  223:#endif
        -:  224:/* deflate.c -- compress data using the deflation algorithm
        -:  225: * Copyright (C) 1992-1993 Jean-loup Gailly
        -:  226: * This is free software; you can redistribute it and/or modify it under the
        -:  227: * terms of the GNU General Public License, see the file COPYING.
        -:  228: */
        -:  229:
        -:  230:/*
        -:  231: *  PURPOSE
        -:  232: *
        -:  233: *      Identify new text as repetitions of old text within a fixed-
        -:  234: *      length sliding window trailing behind the new text.
        -:  235: *
        -:  236: *  DISCUSSION
        -:  237: *
        -:  238: *      The "deflation" process depends on being able to identify portions
        -:  239: *      of the input text which are identical to earlier input (within a
        -:  240: *      sliding window trailing behind the input currently being processed).
        -:  241: *
        -:  242: *      The most straightforward technique turns out to be the fastest for
        -:  243: *      most input files: try all possible matches and select the longest.
        -:  244: *      The key feature of this algorithm is that insertions into the string
        -:  245: *      dictionary are very simple and thus fast, and deletions are avoided
        -:  246: *      completely. Insertions are performed at each input character, whereas
        -:  247: *      string matches are performed only when the previous match ends. So it
        -:  248: *      is preferable to spend more time in matches to allow very fast string
        -:  249: *      insertions and avoid deletions. The matching algorithm for small
        -:  250: *      strings is inspired from that of Rabin & Karp. A brute force approach
        -:  251: *      is used to find longer strings when a small match has been found.
        -:  252: *      A similar algorithm is used in comic (by Jan-Mark Wams) and freeze
        -:  253: *      (by Leonid Broukhis).
        -:  254: *         A previous version of this file used a more sophisticated algorithm
        -:  255: *      (by Fiala and Greene) which is guaranteed to run in linear amortized
        -:  256: *      time, but has a larger average cost, uses more memory and is patented.
        -:  257: *      However the F&G algorithm may be faster for some highly redundant
        -:  258: *      files if the parameter max_chain_length (described below) is too large.
        -:  259: *
        -:  260: *  ACKNOWLEDGEMENTS
        -:  261: *
        -:  262: *      The idea of lazy evaluation of matches is due to Jan-Mark Wams, and
        -:  263: *      I found it in 'freeze' written by Leonid Broukhis.
        -:  264: *      Thanks to many info-zippers for bug reports and testing.
        -:  265: *
        -:  266: *  REFERENCES
        -:  267: *
        -:  268: *      APPNOTE.TXT documentation file in PKZIP 1.93a distribution.
        -:  269: *
        -:  270: *      A description of the Rabin and Karp algorithm is given in the book
        -:  271: *         "Algorithms" by R. Sedgewick, Addison-Wesley, p252.
        -:  272: *
        -:  273: *      Fiala,E.R., and Greene,D.H.
        -:  274: *         Data Compression with Finite Windows, Comm.ACM, 32,4 (1989) 490-595
        -:  275: *
        -:  276: *  INTERFACE
        -:  277: *
        -:  278: *      void lm_init (int pack_level, ush *flags)
        -:  279: *          Initialize the "longest match" routines for a new file
        -:  280: *
        -:  281: *      off_t deflate (void)
        -:  282: *          Processes a new input file and return its compressed length. Sets
        -:  283: *          the compressed length, crc, deflate flags and internal file
        -:  284: *          attributes.
        -:  285: */
        -:  286:
        -:  287:#ifdef RCSID
        -:  288:static char rcsid[] = "$Id: deflate.c,v 0.15 1993/06/24 10:53:53 jloup Exp $";
        -:  289:#endif
        -:  290:
        -:  291:/* ===========================================================================
        -:  292: * Configuration parameters
        -:  293: */
        -:  294:
        -:  295:/* Compile with MEDIUM_MEM to reduce the memory requirements or
        -:  296: * with SMALL_MEM to use as little memory as possible. Use BIG_MEM if the
        -:  297: * entire input file can be held in memory (not possible on 16 bit systems).
        -:  298: * Warning: defining these symbols affects HASH_BITS (see below) and thus
        -:  299: * affects the compression ratio. The compressed output
        -:  300: * is still correct, and might even be smaller in some cases.
        -:  301: */
        -:  302:
        -:  303:#ifdef SMALL_MEM
        -:  304:#   define HASH_BITS  13  /* Number of bits used to hash strings */
        -:  305:#endif
        -:  306:#ifdef MEDIUM_MEM
        -:  307:#   define HASH_BITS  14
        -:  308:#endif
        -:  309:#ifndef HASH_BITS
        -:  310:#   define HASH_BITS  15
        -:  311:   /* For portability to 16 bit machines, do not use values above 15. */
        -:  312:#endif
        -:  313:
        -:  314:/* To save space (see unlzw.c), we overlay prev+head with tab_prefix and
        -:  315: * window with tab_suffix. Check that we can do this:
        -:  316: */
        -:  317:#if (WSIZE<<1) > (1<<BITS)
        -:  318:   error: cannot overlay window with tab_suffix and prev with tab_prefix0
        -:  319:#endif
        -:  320:#if HASH_BITS > BITS-1
        -:  321:   error: cannot overlay head with tab_prefix1
        -:  322:#endif
        -:  323:
        -:  324:#define HASH_SIZE (unsigned)(1<<HASH_BITS)
        -:  325:#define HASH_MASK (HASH_SIZE-1)
        -:  326:#define WMASK     (WSIZE-1)
        -:  327:/* HASH_SIZE and WSIZE must be powers of two */
        -:  328:
        -:  329:#define NIL 0
        -:  330:/* Tail of hash chains */
        -:  331:
        -:  332:#define FAST 4
        -:  333:#define SLOW 2
        -:  334:/* speed options for the general purpose bit flag */
        -:  335:
        -:  336:#ifndef TOO_FAR
        -:  337:#  define TOO_FAR 4096
        -:  338:#endif
        -:  339:/* Matches of length 3 are discarded if their distance exceeds TOO_FAR */
        -:  340:
        -:  341:/* ===========================================================================
        -:  342: * Local data used by the "longest match" routines.
        -:  343: */
        -:  344:
        -:  345:typedef ush Pos;
        -:  346:typedef unsigned IPos;
        -:  347:/* A Pos is an index in the character window. We use short instead of int to
        -:  348: * save space in the various tables. IPos is used only for parameter passing.
        -:  349: */
        -:  350:
        -:  351:/* DECLARE(uch, window, 2L*WSIZE); */
        -:  352:/* Sliding window. Input bytes are read into the second half of the window,
        -:  353: * and move to the first half later to keep a dictionary of at least WSIZE
        -:  354: * bytes. With this organization, matches are limited to a distance of
        -:  355: * WSIZE-MAX_MATCH bytes, but this ensures that IO is always
        -:  356: * performed with a length multiple of the block size. Also, it limits
        -:  357: * the window size to 64K, which is quite useful on MSDOS.
        -:  358: * To do: limit the window size to WSIZE+BSZ if SMALL_MEM (the code would
        -:  359: * be less efficient).
        -:  360: */
        -:  361:
        -:  362:/* DECLARE(Pos, prev, WSIZE); */
        -:  363:/* Link to older string with same hash index. To limit the size of this
        -:  364: * array to 64K, this link is maintained only for the last 32K strings.
        -:  365: * An index in this array is thus a window index modulo 32K.
        -:  366: */
        -:  367:
        -:  368:/* DECLARE(Pos, head, 1<<HASH_BITS); */
        -:  369:/* Heads of the hash chains or NIL. */
        -:  370:
        -:  371:ulg window_size = (ulg)2*WSIZE;
        -:  372:/* window size, 2*WSIZE except for MMAP or BIG_MEM, where it is the
        -:  373: * input file length plus MIN_LOOKAHEAD.
        -:  374: */
        -:  375:
        -:  376:long block_start;
        -:  377:/* window position at the beginning of the current output block. Gets
        -:  378: * negative when the window is moved backwards.
        -:  379: */
        -:  380:
        -:  381:local unsigned ins_h;  /* hash index of string to be inserted */
        -:  382:
        -:  383:#define H_SHIFT  ((HASH_BITS+MIN_MATCH-1)/MIN_MATCH)
        -:  384:/* Number of bits by which ins_h and del_h must be shifted at each
        -:  385: * input step. It must be such that after MIN_MATCH steps, the oldest
        -:  386: * byte no longer takes part in the hash key, that is:
        -:  387: *   H_SHIFT * MIN_MATCH >= HASH_BITS
        -:  388: */
        -:  389:
        -:  390:unsigned int near prev_length;
        -:  391:/* Length of the best match at previous step. Matches not greater than this
        -:  392: * are discarded. This is used in the lazy match evaluation.
        -:  393: */
        -:  394:
        -:  395:      unsigned near strstart;      /* start of string to insert */
        -:  396:      unsigned near match_start;   /* start of matching string */
        -:  397:local int           eofile;        /* flag set at end of input file */
        -:  398:local unsigned      lookahead;     /* number of valid bytes ahead in window */
        -:  399:
        -:  400:unsigned near max_chain_length;
        -:  401:/* To speed up deflation, hash chains are never searched beyond this length.
        -:  402: * A higher limit improves compression ratio but degrades the speed.
        -:  403: */
        -:  404:
        -:  405:local unsigned int max_lazy_match;
        -:  406:/* Attempt to find a better match only when the current match is strictly
        -:  407: * smaller than this value. This mechanism is used only for compression
        -:  408: * levels >= 4.
        -:  409: */
        -:  410:#define max_insert_length  max_lazy_match
        -:  411:/* Insert new strings in the hash table only if the match length
        -:  412: * is not greater than this length. This saves time but degrades compression.
        -:  413: * max_insert_length is used only for compression levels <= 3.
        -:  414: */
        -:  415:
        -:  416:local int compr_level;
        -:  417:/* compression level (1..9) */
        -:  418:
        -:  419:unsigned near good_match;
        -:  420:/* Use a faster search when the previous match is longer than this */
        -:  421:
        -:  422:
        -:  423:/* Values for max_lazy_match, good_match and max_chain_length, depending on
        -:  424: * the desired pack level (0..9). The values given below have been tuned to
        -:  425: * exclude worst case performance for pathological files. Better values may be
        -:  426: * found for specific files.
        -:  427: */
        -:  428:
        -:  429:typedef struct config {
        -:  430:   ush good_length; /* reduce lazy search above this match length */
        -:  431:   ush max_lazy;    /* do not perform lazy search above this match length */
        -:  432:   ush nice_length; /* quit search above this match length */
        -:  433:   ush max_chain;
        -:  434:} config;
        -:  435:
        -:  436:#ifdef  FULL_SEARCH
        -:  437:# define nice_match MAX_MATCH
        -:  438:#else
        -:  439:  int near nice_match; /* Stop searching when current match exceeds this */
        -:  440:#endif
        -:  441:
        -:  442:local config configuration_table[10] = {
        -:  443:/*      good lazy nice chain */
        -:  444:/* 0 */ {0,    0,  0,    0},  /* store only */
        -:  445:/* 1 */ {4,    4,  8,    4},  /* maximum speed, no lazy matches */
        -:  446:/* 2 */ {4,    5, 16,    8},
        -:  447:/* 3 */ {4,    6, 32,   32},
        -:  448:
        -:  449:/* 4 */ {4,    4, 16,   16},  /* lazy matches */
        -:  450:/* 5 */ {8,   16, 32,   32},
        -:  451:/* 6 */ {8,   16, 128, 128},
        -:  452:/* 7 */ {8,   32, 128, 256},
        -:  453:/* 8 */ {32, 128, 258, 1024},
        -:  454:/* 9 */ {32, 258, 258, 4096}}; /* maximum compression */
        -:  455:
        -:  456:/* Note: the deflate() code requires max_lazy >= MIN_MATCH and max_chain >= 4
        -:  457: * For deflate_fast() (levels <= 3) good is ignored and lazy has a different
        -:  458: * meaning.
        -:  459: */
        -:  460:
        -:  461:#define EQUAL 0
        -:  462:/* result of memcmp for equal strings */
        -:  463:
        -:  464:/* ===========================================================================
        -:  465: *  Prototypes for local functions.
        -:  466: */
        -:  467:local void fill_window   OF((void));
        -:  468:local off_t deflate_fast OF((void));
        -:  469:
        -:  470:      int  longest_match OF((IPos cur_match));
        -:  471:
        -:  472:#ifdef ASMV
        -:  473:      void match_init OF((void)); /* asm code initialization */
        -:  474:#endif
        -:  475:
        -:  476:#ifdef DEBUG
        -:  477:local  void check_match OF((IPos start, IPos match, int length));
        -:  478:#endif
        -:  479:
        -:  480:/* ===========================================================================
        -:  481: * Update a hash value with the given input byte
        -:  482: * IN  assertion: all calls to to UPDATE_HASH are made with consecutive
        -:  483: *    input characters, so that a running hash key can be computed from the
        -:  484: *    previous key instead of complete recalculation each time.
        -:  485: */
        -:  486:#define UPDATE_HASH(h,c) (h = (((h)<<H_SHIFT) ^ (c)) & HASH_MASK)
        -:  487:
        -:  488:/* ===========================================================================
        -:  489: * Insert string s in the dictionary and set match_head to the previous head
        -:  490: * of the hash chain (the most recent string with same hash key). Return
        -:  491: * the previous length of the hash chain.
        -:  492: * IN  assertion: all calls to to INSERT_STRING are made with consecutive
        -:  493: *    input characters and the first MIN_MATCH bytes of s are valid
        -:  494: *    (except for the last MIN_MATCH-1 bytes of the input file).
        -:  495: */
        -:  496:#define INSERT_STRING(s, match_head) \
        -:  497:   (UPDATE_HASH(ins_h, window[(s) + MIN_MATCH-1]), \
        -:  498:    prev[(s) & WMASK] = match_head = head[ins_h], \
        -:  499:    head[ins_h] = (s))
        -:  500:
        -:  501:/* ===========================================================================
        -:  502: * Initialize the "longest match" routines for a new file
        -:  503: */
function lm_init called 1 returned 100% blocks executed 74%
        1:  504:void lm_init (pack_level, flags)
        -:  505:    int pack_level; /* 0: store, 1: best speed, 9: best compression */
        -:  506:    ush *flags;     /* general purpose bit flag */
        -:  507:{
        -:  508:    register unsigned j;
        -:  509:
       1*:  510:    if (pack_level < 1 || pack_level > 9) error("bad pack level");
branch  0 taken 1 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 1
call    4 never executed
        1:  511:    compr_level = pack_level;
        -:  512:
        -:  513:    /* Initialize the hash table. */
        -:  514:#if defined(MAXSEG_64K) && HASH_BITS == 15
        -:  515:    for (j = 0;  j < HASH_SIZE; j++) head[j] = NIL;
        -:  516:#else
        1:  517:    memzero((char*)head, HASH_SIZE*sizeof(*head));
        -:  518:#endif
        -:  519:    /* prev will be initialized on the fly */
        -:  520:
        -:  521:    /* Set the default configuration parameters:
        -:  522:     */
        1:  523:    max_lazy_match   = configuration_table[pack_level].max_lazy;
        1:  524:    good_match       = configuration_table[pack_level].good_length;
        -:  525:#ifndef FULL_SEARCH
        1:  526:    nice_match       = configuration_table[pack_level].nice_length;
        -:  527:#endif
        1:  528:    max_chain_length = configuration_table[pack_level].max_chain;
        1:  529:    if (pack_level == 1) {
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:  530:       *flags |= FAST;
        1:  531:    } else if (pack_level == 9) {
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:  532:       *flags |= SLOW;
        -:  533:    }
        -:  534:    /* ??? reduce max_chain_length for binary files */
        -:  535:
        1:  536:    strstart = 0;
        1:  537:    block_start = 0L;
        -:  538:#ifdef ASMV
        -:  539:    match_init(); /* initialize the asm code */
        -:  540:#endif
        -:  541:
        1:  542:    lookahead = read_buf((char*)window,
call    0 returned 1
        -:  543:			 sizeof(int) <= 2 ? (unsigned)WSIZE : 2*WSIZE);
        -:  544:
        1:  545:    if (lookahead == 0 || lookahead == (unsigned)EOF) {
branch  0 taken 1 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 1
    #####:  546:       eofile = 1, lookahead = 0;
    #####:  547:       return;
        -:  548:    }
        1:  549:    eofile = 0;
        -:  550:    /* Make sure that we always have enough lookahead. This is important
        -:  551:     * if input comes from a device such as a tty.
        -:  552:     */
       1*:  553:    while (lookahead < MIN_LOOKAHEAD && !eofile) fill_window();
call    0 never executed
branch  1 taken 0 (fallthrough)
branch  2 taken 1
branch  3 never executed
branch  4 never executed
        -:  554:
        1:  555:    ins_h = 0;
        3:  556:    for (j=0; j<MIN_MATCH-1; j++) UPDATE_HASH(ins_h, window[j]);
branch  0 taken 2
branch  1 taken 1 (fallthrough)
        -:  557:    /* If lookahead < MIN_MATCH, ins_h is garbage, but this is
        -:  558:     * not important since only literal bytes will be emitted.
        -:  559:     */
        -:  560:}
        -:  561:
        -:  562:/* ===========================================================================
        -:  563: * Set match_start to the longest match starting at the given string and
        -:  564: * return its length. Matches shorter or equal to prev_length are discarded,
        -:  565: * in which case the result is equal to prev_length and match_start is
        -:  566: * garbage.
        -:  567: * IN assertions: cur_match is the head of the hash chain for the current
        -:  568: *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
        -:  569: */
        -:  570:#ifndef ASMV
        -:  571:/* For MSDOS, OS/2 and 386 Unix, an optimized version is in match.asm or
        -:  572: * match.s. The code is functionally equivalent, so you can use the C version
        -:  573: * if desired.
        -:  574: */
function longest_match called 5078 returned 100% blocks executed 96%
     5078:  575:int longest_match(cur_match)
        -:  576:    IPos cur_match;                             /* current match */
        -:  577:{
     5078:  578:    unsigned chain_length = max_chain_length;   /* max hash chain length */
     5078:  579:    register uch *scan = window + strstart;     /* current string */
        -:  580:    register uch *match;                        /* matched string */
        -:  581:    register int len;                           /* length of current match */
     5078:  582:    int best_len = prev_length;                 /* best match length so far */
     5078:  583:    IPos limit = strstart > (IPos)MAX_DIST ? strstart - (IPos)MAX_DIST : NIL;
        -:  584:    /* Stop when cur_match becomes <= limit. To simplify the code,
        -:  585:     * we prevent matches with the string of window index 0.
        -:  586:     */
        -:  587:
        -:  588:/* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
        -:  589: * It is easy to get rid of this optimization if necessary.
        -:  590: */
        -:  591:#if HASH_BITS < 8 || MAX_MATCH != 258
        -:  592:   error: Code too clever
        -:  593:#endif
        -:  594:
        -:  595:#ifdef UNALIGNED_OK
        -:  596:    /* Compare two bytes at a time. Note: this is not always beneficial.
        -:  597:     * Try with and without -DUNALIGNED_OK to check.
        -:  598:     */
        -:  599:    register uch *strend = window + strstart + MAX_MATCH - 1;
        -:  600:    register ush scan_start = *(ush*)scan;
        -:  601:    register ush scan_end   = *(ush*)(scan+best_len-1);
        -:  602:#else
     5078:  603:    register uch *strend = window + strstart + MAX_MATCH;
     5078:  604:    register uch scan_end1  = scan[best_len-1];
     5078:  605:    register uch scan_end   = scan[best_len];
        -:  606:#endif
        -:  607:
        -:  608:    /* Do not waste too much time if we already have a good match: */
     5078:  609:    if (prev_length >= good_match) {
branch  0 taken 0 (fallthrough)
branch  1 taken 5078
    #####:  610:        chain_length >>= 2;
        -:  611:    }
        -:  612:    Assert(strstart <= window_size-MIN_LOOKAHEAD, "insufficient lookahead");
        -:  613:
        -:  614:    do {
        -:  615:        Assert(cur_match < strstart, "no future");
   186497:  616:        match = window + cur_match;
        -:  617:
        -:  618:        /* Skip to next match if the match length cannot increase
        -:  619:         * or if the match length is less than 2:
        -:  620:         */
        -:  621:#if (defined(UNALIGNED_OK) && MAX_MATCH == 258)
        -:  622:        /* This code assumes sizeof(unsigned short) == 2. Do not use
        -:  623:         * UNALIGNED_OK if your compiler uses a different size.
        -:  624:         */
        -:  625:        if (*(ush*)(match+best_len-1) != scan_end ||
        -:  626:            *(ush*)match != scan_start) continue;
        -:  627:
        -:  628:        /* It is not necessary to compare scan[2] and match[2] since they are
        -:  629:         * always equal when the other bytes match, given that the hash keys
        -:  630:         * are equal and that HASH_BITS >= 8. Compare 2 bytes at a time at
        -:  631:         * strstart+3, +5, ... up to strstart+257. We check for insufficient
        -:  632:         * lookahead only every 4th comparison; the 128th check will be made
        -:  633:         * at strstart+257. If MAX_MATCH-2 is not a multiple of 8, it is
        -:  634:         * necessary to put more guard bytes at the end of the window, or
        -:  635:         * to check more often for insufficient lookahead.
        -:  636:         */
        -:  637:        scan++, match++;
        -:  638:        do {
        -:  639:        } while (*(ush*)(scan+=2) == *(ush*)(match+=2) &&
        -:  640:                 *(ush*)(scan+=2) == *(ush*)(match+=2) &&
        -:  641:                 *(ush*)(scan+=2) == *(ush*)(match+=2) &&
        -:  642:                 *(ush*)(scan+=2) == *(ush*)(match+=2) &&
        -:  643:                 scan < strend);
        -:  644:        /* The funny "do {}" generates better code on most compilers */
        -:  645:
        -:  646:        /* Here, scan <= window+strstart+257 */
        -:  647:        Assert(scan <= window+(unsigned)(window_size-1), "wild scan");
        -:  648:        if (*scan == *match) scan++;
        -:  649:
        -:  650:        len = (MAX_MATCH - 1) - (int)(strend-scan);
        -:  651:        scan = strend - (MAX_MATCH-1);
        -:  652:
        -:  653:#else /* UNALIGNED_OK */
        -:  654:
   186497:  655:        if (match[best_len]   != scan_end  ||
branch  0 taken 17025 (fallthrough)
branch  1 taken 169472
    17025:  656:            match[best_len-1] != scan_end1 ||
branch  0 taken 11456 (fallthrough)
branch  1 taken 5569
    11456:  657:            *match            != *scan     ||
branch  0 taken 8161 (fallthrough)
branch  1 taken 3295
   186497:  658:            *++match          != scan[1])      continue;
branch  0 taken 0 (fallthrough)
branch  1 taken 8161
        -:  659:
        -:  660:        /* The check at best_len-1 can be removed because it will be made
        -:  661:         * again later. (This heuristic is not always a win.)
        -:  662:         * It is not necessary to compare scan[2] and match[2] since they
        -:  663:         * are always equal when the other bytes match, given that
        -:  664:         * the hash keys are equal and that HASH_BITS >= 8.
        -:  665:         */
     8161:  666:        scan += 2, match++;
        -:  667:
        -:  668:        /* We check for insufficient lookahead only every 8th comparison;
        -:  669:         * the 256th check will be made at strstart+258.
        -:  670:         */
        -:  671:        do {
     6547:  672:        } while (*++scan == *++match && *++scan == *++match &&
branch  0 taken 4881 (fallthrough)
branch  1 taken 1666
     4881:  673:                 *++scan == *++match && *++scan == *++match &&
branch  0 taken 3769 (fallthrough)
branch  1 taken 1112
branch  2 taken 2794 (fallthrough)
branch  3 taken 975
     2794:  674:                 *++scan == *++match && *++scan == *++match &&
branch  0 taken 2157 (fallthrough)
branch  1 taken 637
branch  2 taken 1683 (fallthrough)
branch  3 taken 474
     9844:  675:                 *++scan == *++match && *++scan == *++match &&
branch  0 taken 6547 (fallthrough)
branch  1 taken 2687
branch  2 taken 1340 (fallthrough)
branch  3 taken 343
branch  4 taken 1074 (fallthrough)
branch  5 taken 266
branch  6 taken 1073
branch  7 taken 1 (fallthrough)
        -:  676:                 scan < strend);
        -:  677:
     8161:  678:        len = MAX_MATCH - (int)(strend - scan);
     8161:  679:        scan = strend - MAX_MATCH;
        -:  680:
        -:  681:#endif /* UNALIGNED_OK */
        -:  682:
     8161:  683:        if (len > best_len) {
branch  0 taken 7609 (fallthrough)
branch  1 taken 552
     7609:  684:            match_start = cur_match;
     7609:  685:            best_len = len;
     7609:  686:            if (len >= nice_match) break;
branch  0 taken 1 (fallthrough)
branch  1 taken 7608
        -:  687:#ifdef UNALIGNED_OK
        -:  688:            scan_end = *(ush*)(scan+best_len-1);
        -:  689:#else
     7608:  690:            scan_end1  = scan[best_len-1];
     7608:  691:            scan_end   = scan[best_len];
        -:  692:#endif
        -:  693:        }
   186496:  694:    } while ((cur_match = prev[cur_match & WMASK]) > limit
   186496:  695:	     && --chain_length != 0);
branch  0 taken 181419 (fallthrough)
branch  1 taken 5077
branch  2 taken 181419
branch  3 taken 0 (fallthrough)
        -:  696:
     5078:  697:    return best_len;
        -:  698:}
        -:  699:#endif /* ASMV */
        -:  700:
        -:  701:#ifdef DEBUG
        -:  702:/* ===========================================================================
        -:  703: * Check that the match at match_start is indeed a match.
        -:  704: */
        -:  705:local void check_match(start, match, length)
        -:  706:    IPos start, match;
        -:  707:    int length;
        -:  708:{
        -:  709:    /* check that the match is indeed a match */
        -:  710:    if (memcmp((char*)window + match,
        -:  711:                (char*)window + start, length) != EQUAL) {
        -:  712:        fprintf(stderr,
        -:  713:            " start %d, match %d, length %d\n",
        -:  714:            start, match, length);
        -:  715:        error("invalid match");
        -:  716:    }
        -:  717:    if (verbose > 1) {
        -:  718:        fprintf(stderr,"\\[%d,%d]", start-match, length);
        -:  719:        do { putc(window[start++], stderr); } while (--length != 0);
        -:  720:    }
        -:  721:}
        -:  722:#else
        -:  723:#  define check_match(start, match, length)
        -:  724:#endif
        -:  725:
        -:  726:/* ===========================================================================
        -:  727: * Fill the window when the lookahead becomes insufficient.
        -:  728: * Updates strstart and lookahead, and sets eofile if end of input file.
        -:  729: * IN assertion: lookahead < MIN_LOOKAHEAD && strstart + lookahead > 0
        -:  730: * OUT assertions: at least one byte has been read, or eofile is set;
        -:  731: *    file reads are performed for at least two bytes (required for the
        -:  732: *    translate_eol option).
        -:  733: */
function fill_window called 1 returned 100% blocks executed 30%
        1:  734:local void fill_window()
        -:  735:{
        -:  736:    register unsigned n, m;
        1:  737:    unsigned more = (unsigned)(window_size - (ulg)lookahead - (ulg)strstart);
        -:  738:    /* Amount of free space at the end of the window. */
        -:  739:
        -:  740:    /* If the window is almost full and there is insufficient lookahead,
        -:  741:     * move the upper half to the lower one to make room in the upper half.
        -:  742:     */
        1:  743:    if (more == (unsigned)EOF) {
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -:  744:        /* Very unlikely, but possible on 16 bit machine if strstart == 0
        -:  745:         * and lookahead == 1 (input done one byte at time)
        -:  746:         */
    #####:  747:        more--;
        1:  748:    } else if (strstart >= WSIZE+MAX_DIST) {
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -:  749:        /* By the IN assertion, the window is not empty so we can't confuse
        -:  750:         * more == 0 with more == 64K on a 16 bit machine.
        -:  751:         */
        -:  752:        Assert(window_size == (ulg)2*WSIZE, "no sliding with BIG_MEM");
        -:  753:
    #####:  754:        memcpy((char*)window, (char*)window+WSIZE, (unsigned)WSIZE);
    #####:  755:        match_start -= WSIZE;
    #####:  756:        strstart    -= WSIZE; /* we now have strstart >= MAX_DIST: */
        -:  757:
    #####:  758:        block_start -= (long) WSIZE;
        -:  759:
    #####:  760:        for (n = 0; n < HASH_SIZE; n++) {
branch  0 never executed
branch  1 never executed
    #####:  761:            m = head[n];
    #####:  762:            head[n] = (Pos)(m >= WSIZE ? m-WSIZE : NIL);
branch  0 never executed
branch  1 never executed
        -:  763:        }
    #####:  764:        for (n = 0; n < WSIZE; n++) {
branch  0 never executed
branch  1 never executed
    #####:  765:            m = prev[n];
    #####:  766:            prev[n] = (Pos)(m >= WSIZE ? m-WSIZE : NIL);
branch  0 never executed
branch  1 never executed
        -:  767:            /* If n is not on any hash chain, prev[n] is garbage but
        -:  768:             * its value will never be used.
        -:  769:             */
        -:  770:        }
    #####:  771:        more += WSIZE;
        -:  772:    }
        -:  773:    /* At this point, more >= 2 */
        1:  774:    if (!eofile) {
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:  775:        n = read_buf((char*)window+strstart+lookahead, more);
call    0 returned 1
       1*:  776:        if (n == 0 || n == (unsigned)EOF) {
branch  0 taken 0 (fallthrough)
branch  1 taken 1
branch  2 never executed
branch  3 never executed
        1:  777:            eofile = 1;
        -:  778:        } else {
    #####:  779:            lookahead += n;
        -:  780:        }
        -:  781:    }
        1:  782:}
        -:  783:
        -:  784:/* ===========================================================================
        -:  785: * Flush the current block, with given end-of-file flag.
        -:  786: * IN assertion: strstart is set to the end of the current match.
        -:  787: */
        -:  788:#define FLUSH_BLOCK(eof) \
        -:  789:   flush_block(block_start >= 0L ? (char*)&window[(unsigned)block_start] : \
        -:  790:                (char*)NULL, (long)strstart - block_start, (eof))
        -:  791:
        -:  792:/* ===========================================================================
        -:  793: * Processes a new input file and return its compressed length. This
        -:  794: * function does not perform lazy evaluationof matches and inserts
        -:  795: * new strings in the dictionary only for unmatched strings or for short
        -:  796: * matches. It is used only for the fast compression options.
        -:  797: */
function deflate_fast called 1 returned 100% blocks executed 77%
        1:  798:local off_t deflate_fast()
        -:  799:{
        -:  800:    IPos hash_head; /* head of the hash chain */
        -:  801:    int flush;      /* set if current block must be flushed */
        1:  802:    unsigned match_length = 0;  /* length of best match */
        -:  803:
        1:  804:    prev_length = MIN_MATCH-1;
     6991:  805:    while (lookahead != 0) {
branch  0 taken 6990
branch  1 taken 1 (fallthrough)
        -:  806:        /* Insert the string window[strstart .. strstart+2] in the
        -:  807:         * dictionary, and set hash_head to the head of the hash chain:
        -:  808:         */
     6990:  809:        INSERT_STRING(strstart, hash_head);
        -:  810:
        -:  811:        /* Find the longest match, discarding those <= prev_length.
        -:  812:         * At this point we have always match_length < MIN_MATCH
        -:  813:         */
     6990:  814:        if (hash_head != NIL && strstart - hash_head <= MAX_DIST) {
branch  0 taken 5078 (fallthrough)
branch  1 taken 1912
branch  2 taken 5078 (fallthrough)
branch  3 taken 0
        -:  815:            /* To simplify the code, we prevent matches with the string
        -:  816:             * of window index 0 (in particular we have to avoid a match
        -:  817:             * of the string with itself at the start of the input file).
        -:  818:             */
     5078:  819:            match_length = longest_match (hash_head);
call    0 returned 5078
        -:  820:            /* longest_match() sets match_start */
     5078:  821:            if (match_length > lookahead) match_length = lookahead;
branch  0 taken 1 (fallthrough)
branch  1 taken 5077
        -:  822:        }
     6990:  823:        if (match_length >= MIN_MATCH) {
branch  0 taken 4719 (fallthrough)
branch  1 taken 2271
        -:  824:            check_match(strstart, match_start, match_length);
        -:  825:
     4719:  826:            flush = ct_tally(strstart-match_start, match_length - MIN_MATCH);
call    0 returned 4719
        -:  827:
     4719:  828:            lookahead -= match_length;
        -:  829:
        -:  830:	    /* Insert new strings in the hash table only if the match length
        -:  831:             * is not too large. This saves time but degrades compression.
        -:  832:             */
     4719:  833:            if (match_length <= max_insert_length) {
branch  0 taken 4719 (fallthrough)
branch  1 taken 0
     4719:  834:                match_length--; /* string at strstart already in hash table */
        -:  835:                do {
    27241:  836:                    strstart++;
    27241:  837:                    INSERT_STRING(strstart, hash_head);
        -:  838:                    /* strstart never exceeds WSIZE-MAX_MATCH, so there are
        -:  839:                     * always MIN_MATCH bytes ahead. If lookahead < MIN_MATCH
        -:  840:                     * these bytes are garbage, but it does not matter since
        -:  841:                     * the next lookahead bytes will be emitted as literals.
        -:  842:                     */
    27241:  843:                } while (--match_length != 0);
branch  0 taken 22522
branch  1 taken 4719 (fallthrough)
     4719:  844:	        strstart++; 
        -:  845:            } else {
    #####:  846:	        strstart += match_length;
    #####:  847:	        match_length = 0;
    #####:  848:	        ins_h = window[strstart];
    #####:  849:	        UPDATE_HASH(ins_h, window[strstart+1]);
        -:  850:#if MIN_MATCH != 3
        -:  851:                Call UPDATE_HASH() MIN_MATCH-3 more times
        -:  852:#endif
        -:  853:            }
        -:  854:        } else {
        -:  855:            /* No match, output a literal byte */
        -:  856:            Tracevv((stderr,"%c",window[strstart]));
     2271:  857:            flush = ct_tally (0, window[strstart]);
call    0 returned 2271
     2271:  858:            lookahead--;
     2271:  859:	    strstart++; 
        -:  860:        }
    6990*:  861:        if (flush) FLUSH_BLOCK(0), block_start = strstart;
branch  0 taken 0 (fallthrough)
branch  1 taken 6990
branch  2 never executed
branch  3 never executed
call    4 never executed
        -:  862:
        -:  863:        /* Make sure that we always have enough lookahead, except
        -:  864:         * at the end of the input file. We need MAX_MATCH bytes
        -:  865:         * for the next match, plus MIN_MATCH bytes to insert the
        -:  866:         * string following the next match.
        -:  867:         */
     6991:  868:        while (lookahead < MIN_LOOKAHEAD && !eofile) fill_window();
call    0 returned 1
branch  1 taken 91 (fallthrough)
branch  2 taken 6900
branch  3 taken 1
branch  4 taken 90 (fallthrough)
        -:  869:
        -:  870:    }
       1*:  871:    return FLUSH_BLOCK(1); /* eof */
branch  0 taken 1 (fallthrough)
branch  1 taken 0
call    2 returned 1
        -:  872:}
        -:  873:
        -:  874:/* ===========================================================================
        -:  875: * Same as above, but achieves better compression. We use a lazy
        -:  876: * evaluation for matches: a match is finally adopted only if there is
        -:  877: * no better match at the next window position.
        -:  878: */
function deflate called 1 returned 100% blocks executed 9%
        1:  879:off_t deflate()
        -:  880:{
        -:  881:    IPos hash_head;          /* head of hash chain */
        -:  882:    IPos prev_match;         /* previous match */
        -:  883:    int flush;               /* set if current block must be flushed */
        1:  884:    int match_available = 0; /* set if previous match exists */
        1:  885:    register unsigned match_length = MIN_MATCH-1; /* length of best match */
        -:  886:
        -:  887:#ifdef FAULTY_F_TW_1
        1:  888:    if (compr_level >= 3) return deflate_fast();
branch  0 taken 1 (fallthrough)
branch  1 taken 0
call    2 returned 1
        -:  889:#else
        -:  890:    if (compr_level <= 3) return deflate_fast(); /* optimized for speed */
        -:  891:#endif
        -:  892:
        -:  893:    /* Process the input block. */
    #####:  894:    while (lookahead != 0) {
branch  0 never executed
branch  1 never executed
        -:  895:        /* Insert the string window[strstart .. strstart+2] in the
        -:  896:         * dictionary, and set hash_head to the head of the hash chain:
        -:  897:         */
    #####:  898:        INSERT_STRING(strstart, hash_head);
        -:  899:
        -:  900:        /* Find the longest match, discarding those <= prev_length.
        -:  901:         */
    #####:  902:        prev_length = match_length, prev_match = match_start;
    #####:  903:        match_length = MIN_MATCH-1;
        -:  904:
    #####:  905:        if (hash_head != NIL && prev_length < max_lazy_match &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  906:            strstart - hash_head <= MAX_DIST) {
branch  0 never executed
branch  1 never executed
        -:  907:            /* To simplify the code, we prevent matches with the string
        -:  908:             * of window index 0 (in particular we have to avoid a match
        -:  909:             * of the string with itself at the start of the input file).
        -:  910:             */
    #####:  911:            match_length = longest_match (hash_head);
call    0 never executed
        -:  912:            /* longest_match() sets match_start */
    #####:  913:            if (match_length > lookahead) match_length = lookahead;
branch  0 never executed
branch  1 never executed
        -:  914:
        -:  915:            /* Ignore a length 3 match if it is too distant: */
    #####:  916:            if (match_length == MIN_MATCH && strstart-match_start > TOO_FAR){
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  917:                /* If prev_match is also MIN_MATCH, match_start is garbage
        -:  918:                 * but we will ignore the current match anyway.
        -:  919:                 */
    #####:  920:                match_length--;
        -:  921:            }
        -:  922:        }
        -:  923:        /* If there was a match at the previous step and the current
        -:  924:         * match is not better, output the previous match:
        -:  925:         */
    #####:  926:        if (prev_length >= MIN_MATCH && match_length <= prev_length) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  927:
        -:  928:            check_match(strstart-1, prev_match, prev_length);
        -:  929:
    #####:  930:            flush = ct_tally(strstart-1-prev_match, prev_length - MIN_MATCH);
call    0 never executed
        -:  931:
        -:  932:            /* Insert in hash table all strings up to the end of the match.
        -:  933:             * strstart-1 and strstart are already inserted.
        -:  934:             */
    #####:  935:            lookahead -= prev_length-1;
    #####:  936:            prev_length -= 2;
        -:  937:            do {
    #####:  938:                strstart++;
    #####:  939:                INSERT_STRING(strstart, hash_head);
        -:  940:                /* strstart never exceeds WSIZE-MAX_MATCH, so there are
        -:  941:                 * always MIN_MATCH bytes ahead. If lookahead < MIN_MATCH
        -:  942:                 * these bytes are garbage, but it does not matter since the
        -:  943:                 * next lookahead bytes will always be emitted as literals.
        -:  944:                 */
    #####:  945:            } while (--prev_length != 0);
branch  0 never executed
branch  1 never executed
    #####:  946:            match_available = 0;
    #####:  947:            match_length = MIN_MATCH-1;
    #####:  948:            strstart++;
    #####:  949:            if (flush) FLUSH_BLOCK(0), block_start = strstart;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -:  950:
    #####:  951:        } else if (match_available) {
branch  0 never executed
branch  1 never executed
        -:  952:            /* If there was no match at the previous position, output a
        -:  953:             * single literal. If there was a match but the current match
        -:  954:             * is longer, truncate the previous match to a single literal.
        -:  955:             */
        -:  956:            Tracevv((stderr,"%c",window[strstart-1]));
    #####:  957:            if (ct_tally (0, window[strstart-1])) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  958:                FLUSH_BLOCK(0), block_start = strstart;
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  959:            }
    #####:  960:            strstart++;
    #####:  961:            lookahead--;
        -:  962:        } else {
        -:  963:            /* There is no previous match to compare with, wait for
        -:  964:             * the next step to decide.
        -:  965:             */
    #####:  966:            match_available = 1;
    #####:  967:            strstart++;
    #####:  968:            lookahead--;
        -:  969:        }
        -:  970:        Assert (strstart <= bytes_in && lookahead <= bytes_in, "a bit too far");
        -:  971:
        -:  972:        /* Make sure that we always have enough lookahead, except
        -:  973:         * at the end of the input file. We need MAX_MATCH bytes
        -:  974:         * for the next match, plus MIN_MATCH bytes to insert the
        -:  975:         * string following the next match.
        -:  976:         */
    #####:  977:        while (lookahead < MIN_LOOKAHEAD && !eofile) fill_window();
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -:  978:    }
    #####:  979:    if (match_available) ct_tally (0, window[strstart-1]);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  980:
    #####:  981:    return FLUSH_BLOCK(1); /* eof */
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  982:}
        -:  983:/* inflate.c -- Not copyrighted 1992 by Mark Adler
        -:  984:   version c10p1, 10 January 1993 */
        -:  985:
        -:  986:/* You can do whatever you like with this source file, though I would
        -:  987:   prefer that if you modify it and redistribute it that you include
        -:  988:   comments to that effect with your name and the date.  Thank you.
        -:  989:   [The history has been moved to the file ChangeLog.]
        -:  990: */
        -:  991:
        -:  992:/*
        -:  993:   Inflate deflated (PKZIP's method 8 compressed) data.  The compression
        -:  994:   method searches for as much of the current string of bytes (up to a
        -:  995:   length of 258) in the previous 32K bytes.  If it doesn't find any
        -:  996:   matches (of at least length 3), it codes the next byte.  Otherwise, it
        -:  997:   codes the length of the matched string and its distance backwards from
        -:  998:   the current position.  There is a single Huffman code that codes both
        -:  999:   single bytes (called "literals") and match lengths.  A second Huffman
        -: 1000:   code codes the distance information, which follows a length code.  Each
        -: 1001:   length or distance code actually represents a base value and a number
        -: 1002:   of "extra" (sometimes zero) bits to get to add to the base value.  At
        -: 1003:   the end of each deflated block is a special end-of-block (EOB) literal/
        -: 1004:   length code.  The decoding process is basically: get a literal/length
        -: 1005:   code; if EOB then done; if a literal, emit the decoded byte; if a
        -: 1006:   length then get the distance and emit the referred-to bytes from the
        -: 1007:   sliding window of previously emitted data.
        -: 1008:
        -: 1009:   There are (currently) three kinds of inflate blocks: stored, fixed, and
        -: 1010:   dynamic.  The compressor deals with some chunk of data at a time, and
        -: 1011:   decides which method to use on a chunk-by-chunk basis.  A chunk might
        -: 1012:   typically be 32K or 64K.  If the chunk is uncompressible, then the
        -: 1013:   "stored" method is used.  In this case, the bytes are simply stored as
        -: 1014:   is, eight bits per byte, with none of the above coding.  The bytes are
        -: 1015:   preceded by a count, since there is no longer an EOB code.
        -: 1016:
        -: 1017:   If the data is compressible, then either the fixed or dynamic methods
        -: 1018:   are used.  In the dynamic method, the compressed data is preceded by
        -: 1019:   an encoding of the literal/length and distance Huffman codes that are
        -: 1020:   to be used to decode this block.  The representation is itself Huffman
        -: 1021:   coded, and so is preceded by a description of that code.  These code
        -: 1022:   descriptions take up a little space, and so for small blocks, there is
        -: 1023:   a predefined set of codes, called the fixed codes.  The fixed method is
        -: 1024:   used if the block codes up smaller that way (usually for quite small
        -: 1025:   chunks), otherwise the dynamic method is used.  In the latter case, the
        -: 1026:   codes are customized to the probabilities in the current block, and so
        -: 1027:   can code it much better than the pre-determined fixed codes.
        -: 1028: 
        -: 1029:   The Huffman codes themselves are decoded using a mutli-level table
        -: 1030:   lookup, in order to maximize the speed of decoding plus the speed of
        -: 1031:   building the decoding tables.  See the comments below that precede the
        -: 1032:   lbits and dbits tuning parameters.
        -: 1033: */
        -: 1034:
        -: 1035:
        -: 1036:/*
        -: 1037:   Notes beyond the 1.93a appnote.txt:
        -: 1038:
        -: 1039:   1. Distance pointers never point before the beginning of the output
        -: 1040:      stream.
        -: 1041:   2. Distance pointers can point back across blocks, up to 32k away.
        -: 1042:   3. There is an implied maximum of 7 bits for the bit length table and
        -: 1043:      15 bits for the actual data.
        -: 1044:   4. If only one code exists, then it is encoded using one bit.  (Zero
        -: 1045:      would be more efficient, but perhaps a little confusing.)  If two
        -: 1046:      codes exist, they are coded using one bit each (0 and 1).
        -: 1047:   5. There is no way of sending zero distance codes--a dummy must be
        -: 1048:      sent if there are none.  (History: a pre 2.0 version of PKZIP would
        -: 1049:      store blocks with no distance codes, but this was discovered to be
        -: 1050:      too harsh a criterion.)  Valid only for 1.93a.  2.04c does allow
        -: 1051:      zero distance codes, which is sent as one code of zero bits in
        -: 1052:      length.
        -: 1053:   6. There are up to 286 literal/length codes.  Code 256 represents the
        -: 1054:      end-of-block.  Note however that the static length tree defines
        -: 1055:      288 codes just to fill out the Huffman codes.  Codes 286 and 287
        -: 1056:      cannot be used though, since there is no length base or extra bits
        -: 1057:      defined for them.  Similarly, there are up to 30 distance codes.
        -: 1058:      However, static trees define 32 codes (all 5 bits) to fill out the
        -: 1059:      Huffman codes, but the last two had better not show up in the data.
        -: 1060:   7. Unzip can check dynamic Huffman blocks for complete code sets.
        -: 1061:      The exception is that a single code would not be complete (see #4).
        -: 1062:   8. The five bits following the block type is really the number of
        -: 1063:      literal codes sent minus 257.
        -: 1064:   9. Length codes 8,16,16 are interpreted as 13 length codes of 8 bits
        -: 1065:      (1+6+6).  Therefore, to output three times the length, you output
        -: 1066:      three codes (1+1+1), whereas to output four times the same length,
        -: 1067:      you only need two codes (1+3).  Hmm.
        -: 1068:  10. In the tree reconstruction algorithm, Code = Code + Increment
        -: 1069:      only if BitLength(i) is not zero.  (Pretty obvious.)
        -: 1070:  11. Correction: 4 Bits: # of Bit Length codes - 4     (4 - 19)
        -: 1071:  12. Note: length code 284 can represent 227-258, but length code 285
        -: 1072:      really is 258.  The last length deserves its own, short code
        -: 1073:      since it gets used a lot in very redundant files.  The length
        -: 1074:      258 is special since 258 - 3 (the min match length) is 255.
        -: 1075:  13. The literal/length and distance code bit lengths are read as a
        -: 1076:      single stream of lengths.  It is possible (and advantageous) for
        -: 1077:      a repeat code (16, 17, or 18) to go across the boundary between
        -: 1078:      the two sets of lengths.
        -: 1079: */
        -: 1080:
        -: 1081:#ifdef RCSID
        -: 1082:static char rcsid[] = "$Id: inflate.c,v 0.14 1993/06/10 13:27:04 jloup Exp $";
        -: 1083:#endif
        -: 1084:
        -: 1085:#if defined STDC_HEADERS || defined HAVE_STDLIB_H
        -: 1086:#  include <stdlib.h>
        -: 1087:#endif
        -: 1088:
        -: 1089:#define slide window
        -: 1090:
        -: 1091:/* Huffman code lookup table entry--this entry is four bytes for machines
        -: 1092:   that have 16-bit pointers (e.g. PC's in the small or medium model).
        -: 1093:   Valid extra bits are 0..13.  e == 15 is EOB (end of block), e == 16
        -: 1094:   means that v is a literal, 16 < e < 32 means that v is a pointer to
        -: 1095:   the next table, which codes e - 16 bits, and lastly e == 99 indicates
        -: 1096:   an unused code.  If a code with e == 99 is looked up, this implies an
        -: 1097:   error in the data. */
        -: 1098:struct huft {
        -: 1099:  uch e;                /* number of extra bits or operation */
        -: 1100:  uch b;                /* number of bits in this code or subcode */
        -: 1101:  union {
        -: 1102:    ush n;              /* literal, length base, or distance base */
        -: 1103:    struct huft *t;     /* pointer to next level of table */
        -: 1104:  } v;
        -: 1105:};
        -: 1106:
        -: 1107:
        -: 1108:/* Function prototypes */
        -: 1109:int huft_build OF((unsigned *, unsigned, unsigned, ush *, ush *,
        -: 1110:                   struct huft **, int *));
        -: 1111:int huft_free OF((struct huft *));
        -: 1112:int inflate_codes OF((struct huft *, struct huft *, int, int));
        -: 1113:int inflate_stored OF((void));
        -: 1114:int inflate_fixed OF((void));
        -: 1115:int inflate_dynamic OF((void));
        -: 1116:int inflate_block OF((int *));
        -: 1117:int inflate OF((void));
        -: 1118:
        -: 1119:
        -: 1120:/* The inflate algorithm uses a sliding 32K byte window on the uncompressed
        -: 1121:   stream to find repeated byte strings.  This is implemented here as a
        -: 1122:   circular buffer.  The index is updated simply by incrementing and then
        -: 1123:   and'ing with 0x7fff (32K-1). */
        -: 1124:/* It is left to other modules to supply the 32K area.  It is assumed
        -: 1125:   to be usable as if it were declared "uch slide[32768];" or as just
        -: 1126:   "uch *slide;" and then malloc'ed in the latter case.  The definition
        -: 1127:   must be in unzip.h, included above. */
        -: 1128:/* unsigned wp;             current position in slide */
        -: 1129:#define wp outcnt
        -: 1130:#define flush_output(w) (wp=(w),flush_window())
        -: 1131:
        -: 1132:/* Tables for deflate from PKZIP's appnote.txt. */
        -: 1133:static unsigned border[] = {    /* Order of the bit length code lengths */
        -: 1134:        16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
        -: 1135:static ush cplens[] = {         /* Copy lengths for literal codes 257..285 */
        -: 1136:        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
        -: 1137:        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
        -: 1138:        /* note: see note #13 above about the 258 in this list. */
        -: 1139:static ush cplext[] = {         /* Extra bits for literal codes 257..285 */
        -: 1140:        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
        -: 1141:        3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99}; /* 99==invalid */
        -: 1142:static ush cpdist[] = {         /* Copy offsets for distance codes 0..29 */
        -: 1143:        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
        -: 1144:        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
        -: 1145:        8193, 12289, 16385, 24577};
        -: 1146:static ush cpdext[] = {         /* Extra bits for distance codes */
        -: 1147:        0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,
        -: 1148:        7, 7, 8, 8, 9, 9, 10, 10, 11, 11,
        -: 1149:        12, 12, 13, 13};
        -: 1150:
        -: 1151:
        -: 1152:
        -: 1153:/* Macros for inflate() bit peeking and grabbing.
        -: 1154:   The usage is:
        -: 1155:   
        -: 1156:        NEEDBITS(j)
        -: 1157:        x = b & mask_bits[j];
        -: 1158:        DUMPBITS(j)
        -: 1159:
        -: 1160:   where NEEDBITS makes sure that b has at least j bits in it, and
        -: 1161:   DUMPBITS removes the bits from b.  The macros use the variable k
        -: 1162:   for the number of bits in b.  Normally, b and k are register
        -: 1163:   variables for speed, and are initialized at the beginning of a
        -: 1164:   routine that uses these macros from a global bit buffer and count.
        -: 1165:
        -: 1166:   If we assume that EOB will be the longest code, then we will never
        -: 1167:   ask for bits with NEEDBITS that are beyond the end of the stream.
        -: 1168:   So, NEEDBITS should not read any more bytes than are needed to
        -: 1169:   meet the request.  Then no bytes need to be "returned" to the buffer
        -: 1170:   at the end of the last block.
        -: 1171:
        -: 1172:   However, this assumption is not true for fixed blocks--the EOB code
        -: 1173:   is 7 bits, but the other literal/length codes can be 8 or 9 bits.
        -: 1174:   (The EOB code is shorter than other codes because fixed blocks are
        -: 1175:   generally short.  So, while a block always has an EOB, many other
        -: 1176:   literal/length codes have a significantly lower probability of
        -: 1177:   showing up at all.)  However, by making the first table have a
        -: 1178:   lookup of seven bits, the EOB code will be found in that first
        -: 1179:   lookup, and so will not require that too many bits be pulled from
        -: 1180:   the stream.
        -: 1181: */
        -: 1182:
        -: 1183:ulg bb;                         /* bit buffer */
        -: 1184:unsigned bk;                    /* bits in bit buffer */
        -: 1185:
        -: 1186:ush mask_bits[] = {
        -: 1187:    0x0000,
        -: 1188:    0x0001, 0x0003, 0x0007, 0x000f, 0x001f, 0x003f, 0x007f, 0x00ff,
        -: 1189:    0x01ff, 0x03ff, 0x07ff, 0x0fff, 0x1fff, 0x3fff, 0x7fff, 0xffff
        -: 1190:};
        -: 1191:
        -: 1192:#ifdef CRYPT
        -: 1193:  uch cc;
        -: 1194:#  define NEXTBYTE() \
        -: 1195:     (decrypt ? (cc = get_byte(), zdecode(cc), cc) : get_byte())
        -: 1196:#else
        -: 1197:#  define NEXTBYTE()  (uch)get_byte()
        -: 1198:#endif
        -: 1199:#define NEEDBITS(n) {while(k<(n)){b|=((ulg)NEXTBYTE())<<k;k+=8;}}
        -: 1200:#define DUMPBITS(n) {b>>=(n);k-=(n);}
        -: 1201:
        -: 1202:
        -: 1203:/*
        -: 1204:   Huffman code decoding is performed using a multi-level table lookup.
        -: 1205:   The fastest way to decode is to simply build a lookup table whose
        -: 1206:   size is determined by the longest code.  However, the time it takes
        -: 1207:   to build this table can also be a factor if the data being decoded
        -: 1208:   is not very long.  The most common codes are necessarily the
        -: 1209:   shortest codes, so those codes dominate the decoding time, and hence
        -: 1210:   the speed.  The idea is you can have a shorter table that decodes the
        -: 1211:   shorter, more probable codes, and then point to subsidiary tables for
        -: 1212:   the longer codes.  The time it costs to decode the longer codes is
        -: 1213:   then traded against the time it takes to make longer tables.
        -: 1214:
        -: 1215:   This results of this trade are in the variables lbits and dbits
        -: 1216:   below.  lbits is the number of bits the first level table for literal/
        -: 1217:   length codes can decode in one step, and dbits is the same thing for
        -: 1218:   the distance codes.  Subsequent tables are also less than or equal to
        -: 1219:   those sizes.  These values may be adjusted either when all of the
        -: 1220:   codes are shorter than that, in which case the longest code length in
        -: 1221:   bits is used, or when the shortest code is *longer* than the requested
        -: 1222:   table size, in which case the length of the shortest code in bits is
        -: 1223:   used.
        -: 1224:
        -: 1225:   There are two different values for the two tables, since they code a
        -: 1226:   different number of possibilities each.  The literal/length table
        -: 1227:   codes 286 possible values, or in a flat code, a little over eight
        -: 1228:   bits.  The distance table codes 30 possible values, or a little less
        -: 1229:   than five bits, flat.  The optimum values for speed end up being
        -: 1230:   about one bit more than those, so lbits is 8+1 and dbits is 5+1.
        -: 1231:   The optimum values may differ though from machine to machine, and
        -: 1232:   possibly even between compilers.  Your mileage may vary.
        -: 1233: */
        -: 1234:
        -: 1235:
        -: 1236:int lbits = 9;          /* bits in base literal/length lookup table */
        -: 1237:int dbits = 6;          /* bits in base distance lookup table */
        -: 1238:
        -: 1239:
        -: 1240:/* If BMAX needs to be larger than 16, then h and x[] should be ulg. */
        -: 1241:#define BMAX 16         /* maximum bit length of any code (16 for explode) */
        -: 1242:#define N_MAX 288       /* maximum number of codes in any set */
        -: 1243:
        -: 1244:
        -: 1245:unsigned hufts;         /* track memory usage */
        -: 1246:
        -: 1247:
function huft_build called 0 returned 0% blocks executed 0%
    #####: 1248:int huft_build(b, n, s, d, e, t, m)
        -: 1249:unsigned *b;            /* code lengths in bits (all assumed <= BMAX) */
        -: 1250:unsigned n;             /* number of codes (assumed <= N_MAX) */
        -: 1251:unsigned s;             /* number of simple-valued codes (0..s-1) */
        -: 1252:ush *d;                 /* list of base values for non-simple codes */
        -: 1253:ush *e;                 /* list of extra bits for non-simple codes */
        -: 1254:struct huft **t;        /* result: starting table */
        -: 1255:int *m;                 /* maximum lookup bits, returns actual */
        -: 1256:/* Given a list of code lengths and a maximum table size, make a set of
        -: 1257:   tables to decode that set of codes.  Return zero on success, one if
        -: 1258:   the given code set is incomplete (the tables are still built in this
        -: 1259:   case), two if the input is invalid (all zero length codes or an
        -: 1260:   oversubscribed set of lengths), and three if not enough memory. */
        -: 1261:{
        -: 1262:  unsigned a;                   /* counter for codes of length k */
        -: 1263:  unsigned c[BMAX+1];           /* bit length count table */
        -: 1264:  unsigned f;                   /* i repeats in table every f entries */
        -: 1265:  int g;                        /* maximum code length */
        -: 1266:  int h;                        /* table level */
        -: 1267:  register unsigned i;          /* counter, current code */
        -: 1268:  register unsigned j;          /* counter */
        -: 1269:  register int k;               /* number of bits in current code */
        -: 1270:  int l;                        /* bits per table (returned in m) */
        -: 1271:  register unsigned *p;         /* pointer into c[], b[], or v[] */
        -: 1272:  register struct huft *q;      /* points to current table */
        -: 1273:  struct huft r;                /* table entry for structure assignment */
        -: 1274:  struct huft *u[BMAX];         /* table stack */
        -: 1275:  unsigned v[N_MAX];            /* values in order of bit length */
        -: 1276:  register int w;               /* bits before this table == (l * h) */
        -: 1277:  unsigned x[BMAX+1];           /* bit offsets, then code stack */
        -: 1278:  unsigned *xp;                 /* pointer into x */
        -: 1279:  int y;                        /* number of dummy codes added */
        -: 1280:  unsigned z;                   /* number of entries in current table */
        -: 1281:
        -: 1282:
        -: 1283:  /* Generate counts for each bit length */
    #####: 1284:  memzero(c, sizeof(c));
    #####: 1285:  p = b;  i = n;
        -: 1286:  do {
        -: 1287:    Tracecv(*p, (stderr, (n-i >= ' ' && n-i <= '~' ? "%c %d\n" : "0x%x %d\n"), 
        -: 1288:	    n-i, *p));
    #####: 1289:    c[*p]++;                    /* assume all entries <= BMAX */
    #####: 1290:    p++;                      /* Can't combine with above line (Solaris bug) */
    #####: 1291:  } while (--i);
branch  0 never executed
branch  1 never executed
    #####: 1292:  if (c[0] == n)                /* null input--all zero length codes */
branch  0 never executed
branch  1 never executed
        -: 1293:  {
    #####: 1294:    *t = (struct huft *)NULL;
    #####: 1295:    *m = 0;
    #####: 1296:    return 0;
        -: 1297:  }
        -: 1298:
        -: 1299:
        -: 1300:  /* Find minimum and maximum length, bound *m by those */
    #####: 1301:  l = *m;
    #####: 1302:  for (j = 1; j <= BMAX; j++)
branch  0 never executed
branch  1 never executed
    #####: 1303:    if (c[j])
branch  0 never executed
branch  1 never executed
    #####: 1304:      break;
    #####: 1305:  k = j;                        /* minimum code length */
    #####: 1306:  if ((unsigned)l < j)
branch  0 never executed
branch  1 never executed
    #####: 1307:    l = j;
    #####: 1308:  for (i = BMAX; i; i--)
branch  0 never executed
branch  1 never executed
    #####: 1309:    if (c[i])
branch  0 never executed
branch  1 never executed
    #####: 1310:      break;
    #####: 1311:  g = i;                        /* maximum code length */
    #####: 1312:  if ((unsigned)l > i)
branch  0 never executed
branch  1 never executed
    #####: 1313:    l = i;
    #####: 1314:  *m = l;
        -: 1315:
        -: 1316:
        -: 1317:  /* Adjust last length count to fill out codes, if needed */
    #####: 1318:  for (y = 1 << j; j < i; j++, y <<= 1)
branch  0 never executed
branch  1 never executed
    #####: 1319:    if ((y -= c[j]) < 0)
branch  0 never executed
branch  1 never executed
    #####: 1320:      return 2;                 /* bad input: more codes than bits */
    #####: 1321:  if ((y -= c[i]) < 0)
branch  0 never executed
branch  1 never executed
    #####: 1322:    return 2;
    #####: 1323:  c[i] += y;
        -: 1324:
        -: 1325:
        -: 1326:  /* Generate starting offsets into the value table for each length */
    #####: 1327:  x[1] = j = 0;
    #####: 1328:  p = c + 1;  xp = x + 2;
    #####: 1329:  while (--i) {                 /* note that i == g from above */
branch  0 never executed
branch  1 never executed
    #####: 1330:    *xp++ = (j += *p++);
        -: 1331:  }
        -: 1332:
        -: 1333:
        -: 1334:  /* Make a table of values in order of bit lengths */
    #####: 1335:  p = b;  i = 0;
        -: 1336:  do {
    #####: 1337:    if ((j = *p++) != 0)
branch  0 never executed
branch  1 never executed
    #####: 1338:      v[x[j]++] = i;
    #####: 1339:  } while (++i < n);
branch  0 never executed
branch  1 never executed
    #####: 1340:  n = x[g];                   /* set n to length of v */
        -: 1341:
        -: 1342:
        -: 1343:  /* Generate the Huffman codes and for each, make the table entries */
    #####: 1344:  x[0] = i = 0;                 /* first Huffman code is zero */
    #####: 1345:  p = v;                        /* grab values in bit order */
    #####: 1346:  h = -1;                       /* no tables yet--level -1 */
    #####: 1347:  w = -l;                       /* bits decoded == (l * h) */
    #####: 1348:  u[0] = (struct huft *)NULL;   /* just to keep compilers happy */
    #####: 1349:  q = (struct huft *)NULL;      /* ditto */
    #####: 1350:  z = 0;                        /* ditto */
        -: 1351:
        -: 1352:  /* go through the bit lengths (k already is bits in shortest code) */
    #####: 1353:  for (; k <= g; k++)
branch  0 never executed
branch  1 never executed
        -: 1354:  {
    #####: 1355:    a = c[k];
    #####: 1356:    while (a--)
branch  0 never executed
branch  1 never executed
        -: 1357:    {
        -: 1358:      /* here i is the Huffman code of length k bits for value *p */
        -: 1359:      /* make tables up to required level */
    #####: 1360:      while (k > w + l)
branch  0 never executed
branch  1 never executed
        -: 1361:      {
    #####: 1362:        h++;
    #####: 1363:        w += l;                 /* previous table always l bits */
        -: 1364:
        -: 1365:        /* compute minimum size table less than or equal to l bits */
    #####: 1366:        z = (z = g - w) > (unsigned)l ? l : z;  /* upper limit on table size */
branch  0 never executed
branch  1 never executed
    #####: 1367:        if ((f = 1 << (j = k - w)) > a + 1)     /* try a k-w bit table */
branch  0 never executed
branch  1 never executed
        -: 1368:        {                       /* too few codes for k-w bit table */
    #####: 1369:          f -= a + 1;           /* deduct codes from patterns left */
    #####: 1370:          xp = c + k;
    #####: 1371:	  if (j < z)
branch  0 never executed
branch  1 never executed
    #####: 1372:	    while (++j < z)       /* try smaller tables up to z bits */
branch  0 never executed
branch  1 never executed
        -: 1373:	    {
    #####: 1374:	      if ((f <<= 1) <= *++xp)
branch  0 never executed
branch  1 never executed
    #####: 1375:		break;            /* enough codes to use up j bits */
    #####: 1376:	      f -= *xp;           /* else deduct codes from patterns */
        -: 1377:	    }
        -: 1378:        }
    #####: 1379:        z = 1 << j;             /* table entries for j-bit table */
        -: 1380:
        -: 1381:        /* allocate and link in new table */
    #####: 1382:        if ((q = (struct huft *)malloc((z + 1)*sizeof(struct huft))) ==
branch  0 never executed
branch  1 never executed
        -: 1383:            (struct huft *)NULL)
        -: 1384:        {
    #####: 1385:          if (h)
branch  0 never executed
branch  1 never executed
    #####: 1386:            huft_free(u[0]);
call    0 never executed
    #####: 1387:          return 3;             /* not enough memory */
        -: 1388:        }
    #####: 1389:        hufts += z + 1;         /* track memory usage */
    #####: 1390:        *t = q + 1;             /* link to list for huft_free() */
    #####: 1391:        *(t = &(q->v.t)) = (struct huft *)NULL;
    #####: 1392:        u[h] = ++q;             /* table starts after link */
        -: 1393:
        -: 1394:        /* connect to last table, if there is one */
    #####: 1395:        if (h)
branch  0 never executed
branch  1 never executed
        -: 1396:        {
    #####: 1397:          x[h] = i;             /* save pattern for backing up */
    #####: 1398:          r.b = (uch)l;         /* bits to dump before this table */
    #####: 1399:          r.e = (uch)(16 + j);  /* bits in this table */
    #####: 1400:          r.v.t = q;            /* pointer to this table */
    #####: 1401:          j = i >> (w - l);     /* (get around Turbo C bug) */
    #####: 1402:          u[h-1][j] = r;        /* connect to last table */
        -: 1403:        }
        -: 1404:      }
        -: 1405:
        -: 1406:      /* set up table entry in r */
    #####: 1407:      r.b = (uch)(k - w);
    #####: 1408:      if (p >= v + n)
branch  0 never executed
branch  1 never executed
    #####: 1409:        r.e = 99;               /* out of values--invalid code */
    #####: 1410:      else if (*p < s)
branch  0 never executed
branch  1 never executed
        -: 1411:      {
    #####: 1412:        r.e = (uch)(*p < 256 ? 16 : 15);    /* 256 is end-of-block code */
branch  0 never executed
branch  1 never executed
    #####: 1413:        r.v.n = (ush)(*p);             /* simple code is just the value */
    #####: 1414:	p++;                           /* one compiler does not like *p++ */
        -: 1415:      }
        -: 1416:      else
        -: 1417:      {
    #####: 1418:        r.e = (uch)e[*p - s];   /* non-simple--look up in lists */
    #####: 1419:        r.v.n = d[*p++ - s];
        -: 1420:      }
        -: 1421:
        -: 1422:      /* fill code-like entries with r */
    #####: 1423:      f = 1 << (k - w);
    #####: 1424:      for (j = i >> w; j < z; j += f)
branch  0 never executed
branch  1 never executed
    #####: 1425:        q[j] = r;
        -: 1426:
        -: 1427:      /* backwards increment the k-bit code i */
    #####: 1428:      for (j = 1 << (k - 1); i & j; j >>= 1)
branch  0 never executed
branch  1 never executed
    #####: 1429:        i ^= j;
    #####: 1430:      i ^= j;
        -: 1431:
        -: 1432:      /* backup over finished tables */
    #####: 1433:      while ((i & ((1 << w) - 1)) != x[h])
branch  0 never executed
branch  1 never executed
        -: 1434:      {
    #####: 1435:        h--;                    /* don't need to update q */
    #####: 1436:        w -= l;
        -: 1437:      }
        -: 1438:    }
        -: 1439:  }
        -: 1440:
        -: 1441:
        -: 1442:  /* Return true (1) if we were given an incomplete table */
    #####: 1443:  return y != 0 && g != 1;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1444:}
        -: 1445:
        -: 1446:
        -: 1447:
function huft_free called 0 returned 0% blocks executed 0%
    #####: 1448:int huft_free(t)
        -: 1449:struct huft *t;         /* table to free */
        -: 1450:/* Free the malloc'ed tables built by huft_build(), which makes a linked
        -: 1451:   list of the tables it made, with the links in a dummy first entry of
        -: 1452:   each table. */
        -: 1453:{
        -: 1454:  register struct huft *p, *q;
        -: 1455:
        -: 1456:
        -: 1457:  /* Go through linked list, freeing from the malloced (t[-1]) address. */
    #####: 1458:  p = t;
    #####: 1459:  while (p != (struct huft *)NULL)
branch  0 never executed
branch  1 never executed
        -: 1460:  {
    #####: 1461:    q = (--p)->v.t;
    #####: 1462:    free((char*)p);
    #####: 1463:    p = q;
        -: 1464:  } 
    #####: 1465:  return 0;
        -: 1466:}
        -: 1467:
        -: 1468:
function inflate_codes called 0 returned 0% blocks executed 0%
    #####: 1469:int inflate_codes(tl, td, bl, bd)
        -: 1470:struct huft *tl, *td;   /* literal/length and distance decoder tables */
        -: 1471:int bl, bd;             /* number of bits decoded by tl[] and td[] */
        -: 1472:/* inflate (decompress) the codes in a deflated (compressed) block.
        -: 1473:   Return an error code or zero if it all goes ok. */
        -: 1474:{
        -: 1475:  register unsigned e;  /* table entry flag/number of extra bits */
        -: 1476:  unsigned n, d;        /* length and index for copy */
        -: 1477:  unsigned w;           /* current window position */
        -: 1478:  struct huft *t;       /* pointer to table entry */
        -: 1479:  unsigned ml, md;      /* masks for bl and bd bits */
        -: 1480:  register ulg b;       /* bit buffer */
        -: 1481:  register unsigned k;  /* number of bits in bit buffer */
        -: 1482:
        -: 1483:
        -: 1484:  /* make local copies of globals */
    #####: 1485:  b = bb;                       /* initialize bit buffer */
    #####: 1486:  k = bk;
    #####: 1487:  w = wp;                       /* initialize window position */
        -: 1488:
        -: 1489:  /* inflate the coded data */
    #####: 1490:  ml = mask_bits[bl];           /* precompute masks for speed */
    #####: 1491:  md = mask_bits[bd];
        -: 1492:  for (;;)                      /* do until end of block */
        -: 1493:  {
    #####: 1494:    NEEDBITS((unsigned)bl)
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1495:    if ((e = (t = tl + ((unsigned)b & ml))->e) > 16)
branch  0 never executed
branch  1 never executed
        -: 1496:      do {
    #####: 1497:        if (e == 99)
branch  0 never executed
branch  1 never executed
    #####: 1498:          return 1;
    #####: 1499:        DUMPBITS(t->b)
    #####: 1500:        e -= 16;
    #####: 1501:        NEEDBITS(e)
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1502:      } while ((e = (t = t->v.t + ((unsigned)b & mask_bits[e]))->e) > 16);
branch  0 never executed
branch  1 never executed
    #####: 1503:    DUMPBITS(t->b)
    #####: 1504:    if (e == 16)                /* then it's a literal */
branch  0 never executed
branch  1 never executed
        -: 1505:    {
    #####: 1506:      slide[w++] = (uch)t->v.n;
        -: 1507:      Tracevv((stderr, "%c", slide[w-1]));
    #####: 1508:      if (w == WSIZE)
branch  0 never executed
branch  1 never executed
        -: 1509:      {
    #####: 1510:        flush_output(w);
call    0 never executed
    #####: 1511:        w = 0;
        -: 1512:      }
        -: 1513:    }
        -: 1514:    else                        /* it's an EOB or a length */
        -: 1515:    {
        -: 1516:      /* exit if end of block */
    #####: 1517:      if (e == 15)
branch  0 never executed
branch  1 never executed
    #####: 1518:        break;
        -: 1519:
        -: 1520:      /* get length of block to copy */
    #####: 1521:      NEEDBITS(e)
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1522:      n = t->v.n + ((unsigned)b & mask_bits[e]);
    #####: 1523:      DUMPBITS(e);
        -: 1524:
        -: 1525:      /* decode distance of block to copy */
    #####: 1526:      NEEDBITS((unsigned)bd)
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1527:      if ((e = (t = td + ((unsigned)b & md))->e) > 16)
branch  0 never executed
branch  1 never executed
        -: 1528:        do {
    #####: 1529:          if (e == 99)
branch  0 never executed
branch  1 never executed
    #####: 1530:            return 1;
    #####: 1531:          DUMPBITS(t->b)
    #####: 1532:          e -= 16;
    #####: 1533:          NEEDBITS(e)
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1534:        } while ((e = (t = t->v.t + ((unsigned)b & mask_bits[e]))->e) > 16);
branch  0 never executed
branch  1 never executed
    #####: 1535:      DUMPBITS(t->b)
    #####: 1536:      NEEDBITS(e)
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1537:      d = w - t->v.n - ((unsigned)b & mask_bits[e]);
    #####: 1538:      DUMPBITS(e)
        -: 1539:      Tracevv((stderr,"\\[%d,%d]", w-d, n));
        -: 1540:
        -: 1541:      /* do the copy */
        -: 1542:      do {
    #####: 1543:        n -= (e = (e = WSIZE - ((d &= WSIZE-1) > w ? d : w)) > n ? n : e);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1544:#if !defined(NOMEMCPY) && !defined(DEBUG)
    #####: 1545:        if (w - d >= e)         /* (this test assumes unsigned comparison) */
branch  0 never executed
branch  1 never executed
        -: 1546:        {
    #####: 1547:          memcpy(slide + w, slide + d, e);
    #####: 1548:          w += e;
    #####: 1549:          d += e;
        -: 1550:        }
        -: 1551:        else                      /* do it slow to avoid memcpy() overlap */
        -: 1552:#endif /* !NOMEMCPY */
        -: 1553:          do {
    #####: 1554:            slide[w++] = slide[d++];
        -: 1555:	    Tracevv((stderr, "%c", slide[w-1]));
    #####: 1556:          } while (--e);
branch  0 never executed
branch  1 never executed
    #####: 1557:        if (w == WSIZE)
branch  0 never executed
branch  1 never executed
        -: 1558:        {
    #####: 1559:          flush_output(w);
call    0 never executed
    #####: 1560:          w = 0;
        -: 1561:        }
    #####: 1562:      } while (n);
branch  0 never executed
branch  1 never executed
        -: 1563:    }
        -: 1564:  }
        -: 1565:
        -: 1566:
        -: 1567:  /* restore the globals from the locals */
    #####: 1568:  wp = w;                       /* restore global window pointer */
    #####: 1569:  bb = b;                       /* restore global bit buffer */
    #####: 1570:  bk = k;
        -: 1571:
        -: 1572:  /* done */
    #####: 1573:  return 0;
        -: 1574:}
        -: 1575:
        -: 1576:
        -: 1577:
function inflate_stored called 0 returned 0% blocks executed 0%
    #####: 1578:int inflate_stored()
        -: 1579:/* "decompress" an inflated type 0 (stored) block. */
        -: 1580:{
        -: 1581:  unsigned n;           /* number of bytes in block */
        -: 1582:  unsigned w;           /* current window position */
        -: 1583:  register ulg b;       /* bit buffer */
        -: 1584:  register unsigned k;  /* number of bits in bit buffer */
        -: 1585:
        -: 1586:
        -: 1587:  /* make local copies of globals */
    #####: 1588:  b = bb;                       /* initialize bit buffer */
    #####: 1589:  k = bk;
    #####: 1590:  w = wp;                       /* initialize window position */
        -: 1591:
        -: 1592:
        -: 1593:  /* go to byte boundary */
    #####: 1594:  n = k & 7;
    #####: 1595:  DUMPBITS(n);
        -: 1596:
        -: 1597:
        -: 1598:  /* get the length and its complement */
    #####: 1599:  NEEDBITS(16)
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1600:  n = ((unsigned)b & 0xffff);
    #####: 1601:  DUMPBITS(16)
    #####: 1602:  NEEDBITS(16)
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1603:  if (n != (unsigned)((~b) & 0xffff))
branch  0 never executed
branch  1 never executed
    #####: 1604:    return 1;                   /* error in compressed data */
    #####: 1605:  DUMPBITS(16)
        -: 1606:
        -: 1607:
        -: 1608:  /* read and output the compressed data */
    #####: 1609:  while (n--)
branch  0 never executed
branch  1 never executed
        -: 1610:  {
    #####: 1611:    NEEDBITS(8)
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1612:    slide[w++] = (uch)b;
    #####: 1613:    if (w == WSIZE)
branch  0 never executed
branch  1 never executed
        -: 1614:    {
    #####: 1615:      flush_output(w);
call    0 never executed
    #####: 1616:      w = 0;
        -: 1617:    }
    #####: 1618:    DUMPBITS(8)
        -: 1619:  }
        -: 1620:
        -: 1621:
        -: 1622:  /* restore the globals from the locals */
    #####: 1623:  wp = w;                       /* restore global window pointer */
    #####: 1624:  bb = b;                       /* restore global bit buffer */
    #####: 1625:  bk = k;
    #####: 1626:  return 0;
        -: 1627:}
        -: 1628:
        -: 1629:
        -: 1630:
function inflate_fixed called 0 returned 0% blocks executed 0%
    #####: 1631:int inflate_fixed()
        -: 1632:/* decompress an inflated type 1 (fixed Huffman codes) block.  We should
        -: 1633:   either replace this with a custom decoder, or at least precompute the
        -: 1634:   Huffman tables. */
        -: 1635:{
        -: 1636:  int i;                /* temporary variable */
        -: 1637:  struct huft *tl;      /* literal/length code table */
        -: 1638:  struct huft *td;      /* distance code table */
        -: 1639:  int bl;               /* lookup bits for tl */
        -: 1640:  int bd;               /* lookup bits for td */
        -: 1641:  unsigned l[288];      /* length list for huft_build */
        -: 1642:
        -: 1643:
        -: 1644:  /* set up literal table */
    #####: 1645:  for (i = 0; i < 144; i++)
branch  0 never executed
branch  1 never executed
    #####: 1646:    l[i] = 8;
    #####: 1647:  for (; i < 256; i++)
branch  0 never executed
branch  1 never executed
    #####: 1648:    l[i] = 9;
    #####: 1649:  for (; i < 280; i++)
branch  0 never executed
branch  1 never executed
    #####: 1650:    l[i] = 7;
    #####: 1651:  for (; i < 288; i++)          /* make a complete, but wrong code set */
branch  0 never executed
branch  1 never executed
    #####: 1652:    l[i] = 8;
    #####: 1653:  bl = 7;
    #####: 1654:  if ((i = huft_build(l, 288, 257, cplens, cplext, &tl, &bl)) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1655:    return i;
        -: 1656:
        -: 1657:
        -: 1658:  /* set up distance table */
    #####: 1659:  for (i = 0; i < 30; i++)      /* make an incomplete code set */
branch  0 never executed
branch  1 never executed
    #####: 1660:    l[i] = 5;
    #####: 1661:  bd = 5;
    #####: 1662:  if ((i = huft_build(l, 30, 0, cpdist, cpdext, &td, &bd)) > 1)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1663:  {
    #####: 1664:    huft_free(tl);
call    0 never executed
    #####: 1665:    return i;
        -: 1666:  }
        -: 1667:
        -: 1668:
        -: 1669:  /* decompress until an end-of-block code */
    #####: 1670:  if (inflate_codes(tl, td, bl, bd))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1671:    return 1;
        -: 1672:
        -: 1673:
        -: 1674:  /* free the decoding tables, return */
    #####: 1675:  huft_free(tl);
call    0 never executed
    #####: 1676:  huft_free(td);
call    0 never executed
    #####: 1677:  return 0;
        -: 1678:}
        -: 1679:
        -: 1680:
        -: 1681:
function inflate_dynamic called 0 returned 0% blocks executed 0%
    #####: 1682:int inflate_dynamic()
        -: 1683:/* decompress an inflated type 2 (dynamic Huffman codes) block. */
        -: 1684:{
        -: 1685:  int i;                /* temporary variables */
        -: 1686:  unsigned j;
        -: 1687:  unsigned l;           /* last length */
        -: 1688:  unsigned m;           /* mask for bit lengths table */
        -: 1689:  unsigned n;           /* number of lengths to get */
        -: 1690:  struct huft *tl;      /* literal/length code table */
        -: 1691:  struct huft *td;      /* distance code table */
        -: 1692:  int bl;               /* lookup bits for tl */
        -: 1693:  int bd;               /* lookup bits for td */
        -: 1694:  unsigned nb;          /* number of bit length codes */
        -: 1695:  unsigned nl;          /* number of literal/length codes */
        -: 1696:  unsigned nd;          /* number of distance codes */
        -: 1697:#ifdef PKZIP_BUG_WORKAROUND
        -: 1698:  unsigned ll[288+32];  /* literal/length and distance code lengths */
        -: 1699:#else
        -: 1700:  unsigned ll[286+30];  /* literal/length and distance code lengths */
        -: 1701:#endif
        -: 1702:  register ulg b;       /* bit buffer */
        -: 1703:  register unsigned k;  /* number of bits in bit buffer */
        -: 1704:
        -: 1705:
        -: 1706:  /* make local bit buffer */
    #####: 1707:  b = bb;
    #####: 1708:  k = bk;
        -: 1709:
        -: 1710:
        -: 1711:  /* read in table lengths */
    #####: 1712:  NEEDBITS(5)
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1713:  nl = 257 + ((unsigned)b & 0x1f);      /* number of literal/length codes */
    #####: 1714:  DUMPBITS(5)
    #####: 1715:  NEEDBITS(5)
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1716:  nd = 1 + ((unsigned)b & 0x1f);        /* number of distance codes */
    #####: 1717:  DUMPBITS(5)
    #####: 1718:  NEEDBITS(4)
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1719:  nb = 4 + ((unsigned)b & 0xf);         /* number of bit length codes */
    #####: 1720:  DUMPBITS(4)
        -: 1721:#ifdef PKZIP_BUG_WORKAROUND
        -: 1722:  if (nl > 288 || nd > 32)
        -: 1723:#else
    #####: 1724:  if (nl > 286 || nd > 30)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1725:#endif
    #####: 1726:    return 1;                   /* bad lengths */
        -: 1727:
        -: 1728:
        -: 1729:  /* read in bit-length-code lengths */
    #####: 1730:  for (j = 0; j < nb; j++)
branch  0 never executed
branch  1 never executed
        -: 1731:  {
    #####: 1732:    NEEDBITS(3)
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1733:    ll[border[j]] = (unsigned)b & 7;
    #####: 1734:    DUMPBITS(3)
        -: 1735:  }
    #####: 1736:  for (; j < 19; j++)
branch  0 never executed
branch  1 never executed
    #####: 1737:    ll[border[j]] = 0;
        -: 1738:
        -: 1739:
        -: 1740:  /* build decoding table for trees--single level, 7 bit lookup */
    #####: 1741:  bl = 7;
    #####: 1742:  if ((i = huft_build(ll, 19, 19, NULL, NULL, &tl, &bl)) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1743:  {
    #####: 1744:    if (i == 1)
branch  0 never executed
branch  1 never executed
    #####: 1745:      huft_free(tl);
call    0 never executed
    #####: 1746:    return i;                   /* incomplete code set */
        -: 1747:  }
        -: 1748:
        -: 1749:#ifdef FAULTY_F_KL_1
    #####: 1750:  tl = NULL;
        -: 1751:#else
        -: 1752:  if (tl == NULL)		/* Grrrhhh */
        -: 1753:	return 2;
        -: 1754:#endif
        -: 1755:
        -: 1756:  /* read in literal and distance code lengths */
    #####: 1757:  n = nl + nd;
    #####: 1758:  m = mask_bits[bl];
    #####: 1759:  i = l = 0;
    #####: 1760:  while ((unsigned)i < n)
branch  0 never executed
branch  1 never executed
        -: 1761:  {
    #####: 1762:    NEEDBITS((unsigned)bl)
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1763:    j = (td = tl + ((unsigned)b & m))->b;
    #####: 1764:    DUMPBITS(j)
    #####: 1765:    j = td->v.n;
    #####: 1766:    if (j < 16)                 /* length of code in bits (0..15) */
branch  0 never executed
branch  1 never executed
    #####: 1767:      ll[i++] = l = j;          /* save last length in l */
    #####: 1768:    else if (j == 16)           /* repeat last length 3 to 6 times */
branch  0 never executed
branch  1 never executed
        -: 1769:    {
    #####: 1770:      NEEDBITS(2)
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1771:      j = 3 + ((unsigned)b & 3);
    #####: 1772:      DUMPBITS(2)
    #####: 1773:      if ((unsigned)i + j > n)
branch  0 never executed
branch  1 never executed
    #####: 1774:        return 1;
    #####: 1775:      while (j--)
branch  0 never executed
branch  1 never executed
    #####: 1776:        ll[i++] = l;
        -: 1777:    }
    #####: 1778:    else if (j == 17)           /* 3 to 10 zero length codes */
branch  0 never executed
branch  1 never executed
        -: 1779:    {
    #####: 1780:      NEEDBITS(3)
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1781:      j = 3 + ((unsigned)b & 7);
    #####: 1782:      DUMPBITS(3)
    #####: 1783:      if ((unsigned)i + j > n)
branch  0 never executed
branch  1 never executed
    #####: 1784:        return 1;
    #####: 1785:      while (j--)
branch  0 never executed
branch  1 never executed
    #####: 1786:        ll[i++] = 0;
    #####: 1787:      l = 0;
        -: 1788:    }
        -: 1789:    else                        /* j == 18: 11 to 138 zero length codes */
        -: 1790:    {
    #####: 1791:      NEEDBITS(7)
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1792:      j = 11 + ((unsigned)b & 0x7f);
    #####: 1793:      DUMPBITS(7)
    #####: 1794:      if ((unsigned)i + j > n)
branch  0 never executed
branch  1 never executed
    #####: 1795:        return 1;
    #####: 1796:      while (j--)
branch  0 never executed
branch  1 never executed
    #####: 1797:        ll[i++] = 0;
    #####: 1798:      l = 0;
        -: 1799:    }
        -: 1800:  }
        -: 1801:
        -: 1802:
        -: 1803:  /* free decoding table for trees */
    #####: 1804:  huft_free(tl);
call    0 never executed
        -: 1805:
        -: 1806:
        -: 1807:  /* restore the global bit buffer */
    #####: 1808:  bb = b;
    #####: 1809:  bk = k;
        -: 1810:
        -: 1811:
        -: 1812:  /* build the decoding tables for literal/length and distance codes */
    #####: 1813:  bl = lbits;
    #####: 1814:  if ((i = huft_build(ll, nl, 257, cplens, cplext, &tl, &bl)) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1815:  {
    #####: 1816:    if (i == 1) {
branch  0 never executed
branch  1 never executed
    #####: 1817:      fprintf(stderr, " incomplete literal tree\n");
call    0 never executed
    #####: 1818:      huft_free(tl);
call    0 never executed
        -: 1819:    }
    #####: 1820:    return i;                   /* incomplete code set */
        -: 1821:  }
    #####: 1822:  bd = dbits;
    #####: 1823:  if ((i = huft_build(ll + nl, nd, 0, cpdist, cpdext, &td, &bd)) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1824:  {
    #####: 1825:    if (i == 1) {
branch  0 never executed
branch  1 never executed
    #####: 1826:      fprintf(stderr, " incomplete distance tree\n");
call    0 never executed
        -: 1827:#ifdef PKZIP_BUG_WORKAROUND
        -: 1828:      i = 0;
        -: 1829:    }
        -: 1830:#else
    #####: 1831:      huft_free(td);
call    0 never executed
        -: 1832:    }
    #####: 1833:    huft_free(tl);
call    0 never executed
    #####: 1834:    return i;                   /* incomplete code set */
        -: 1835:#endif
        -: 1836:  }
        -: 1837:
        -: 1838:
        -: 1839:  /* decompress until an end-of-block code */
    #####: 1840:  if (inflate_codes(tl, td, bl, bd))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1841:    return 1;
        -: 1842:
        -: 1843:
        -: 1844:  /* free the decoding tables, return */
    #####: 1845:  huft_free(tl);
call    0 never executed
    #####: 1846:  huft_free(td);
call    0 never executed
    #####: 1847:  return 0;
        -: 1848:}
        -: 1849:
        -: 1850:
        -: 1851:
function inflate_block called 0 returned 0% blocks executed 0%
    #####: 1852:int inflate_block(e)
        -: 1853:int *e;                 /* last block flag */
        -: 1854:/* decompress an inflated block */
        -: 1855:{
        -: 1856:  unsigned t;           /* block type */
        -: 1857:  register ulg b;       /* bit buffer */
        -: 1858:  register unsigned k;  /* number of bits in bit buffer */
        -: 1859:
        -: 1860:
        -: 1861:  /* make local bit buffer */
    #####: 1862:  b = bb;
    #####: 1863:  k = bk;
        -: 1864:
        -: 1865:
        -: 1866:  /* read in last block bit */
    #####: 1867:  NEEDBITS(1)
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1868:  *e = (int)b & 1;
    #####: 1869:  DUMPBITS(1)
        -: 1870:
        -: 1871:
        -: 1872:  /* read in block type */
    #####: 1873:  NEEDBITS(2)
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1874:  t = (unsigned)b & 3;
    #####: 1875:  DUMPBITS(2)
        -: 1876:
        -: 1877:
        -: 1878:  /* restore the global bit buffer */
    #####: 1879:  bb = b;
    #####: 1880:  bk = k;
        -: 1881:
        -: 1882:
        -: 1883:  /* inflate that block type */
    #####: 1884:  if (t == 2)
branch  0 never executed
branch  1 never executed
    #####: 1885:    return inflate_dynamic();
call    0 never executed
    #####: 1886:  if (t == 0)
branch  0 never executed
branch  1 never executed
    #####: 1887:    return inflate_stored();
call    0 never executed
    #####: 1888:  if (t == 1)
branch  0 never executed
branch  1 never executed
    #####: 1889:    return inflate_fixed();
call    0 never executed
        -: 1890:
        -: 1891:
        -: 1892:  /* bad block type */
    #####: 1893:  return 2;
        -: 1894:}
        -: 1895:
        -: 1896:
        -: 1897:
function inflate called 0 returned 0% blocks executed 0%
    #####: 1898:int inflate()
        -: 1899:/* decompress an inflated entry */
        -: 1900:{
        -: 1901:  int e;                /* last block flag */
        -: 1902:  int r;                /* result code */
        -: 1903:  unsigned h;           /* maximum struct huft's malloc'ed */
        -: 1904:
        -: 1905:
        -: 1906:  /* initialize window, bit buffer */
    #####: 1907:  wp = 0;
    #####: 1908:  bk = 0;
    #####: 1909:  bb = 0;
        -: 1910:
        -: 1911:
        -: 1912:  /* decompress until the last block */
    #####: 1913:  h = 0;
        -: 1914:  do {
    #####: 1915:    hufts = 0;
    #####: 1916:    if ((r = inflate_block(&e)) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1917:      return r;
    #####: 1918:    if (hufts > h)
branch  0 never executed
branch  1 never executed
    #####: 1919:      h = hufts;
    #####: 1920:  } while (!e);
branch  0 never executed
branch  1 never executed
        -: 1921:
        -: 1922:  /* Undo too much lookahead. The next read will be byte aligned so we
        -: 1923:   * can discard unused bits in the last meaningful byte.
        -: 1924:   */
    #####: 1925:  while (bk >= 8) {
branch  0 never executed
branch  1 never executed
    #####: 1926:    bk -= 8;
    #####: 1927:    inptr--;
        -: 1928:  }
        -: 1929:
        -: 1930:  /* flush out slide */
    #####: 1931:  flush_output(wp);
call    0 never executed
        -: 1932:
        -: 1933:
        -: 1934:  /* return success */
        -: 1935:#ifdef DEBUG
        -: 1936:  fprintf(stderr, "<%u> ", h);
        -: 1937:#endif /* DEBUG */
    #####: 1938:  return 0;
        -: 1939:}
        -: 1940:/* lzw.c -- compress files in LZW format.
        -: 1941: * This is a dummy version avoiding patent problems.
        -: 1942: */
        -: 1943:
        -: 1944:#ifdef RCSID
        -: 1945:static char rcsid[] = "$Id: lzw.c,v 0.9 1993/06/10 13:27:31 jloup Exp $";
        -: 1946:#endif
        -: 1947:
        -: 1948:static int msg_done = 0;
        -: 1949:
        -: 1950:/* Compress in to out with lzw method. */
function lzw called 0 returned 0% blocks executed 0%
    #####: 1951:int lzw(in, out)
        -: 1952:    int in, out;
        -: 1953:{
    #####: 1954:    if (msg_done) return ERROR;
branch  0 never executed
branch  1 never executed
    #####: 1955:    msg_done = 1;
    #####: 1956:    fprintf(stderr,"output in compress .Z format not supported\n");
call    0 never executed
    #####: 1957:    if (in != out) { /* avoid warnings on unused variables */
branch  0 never executed
branch  1 never executed
    #####: 1958:        exit_code = ERROR;
        -: 1959:    }
    #####: 1960:    return ERROR;
        -: 1961:}
        -: 1962:/* trees.c -- output deflated data using Huffman coding
        -: 1963: * Copyright (C) 1992-1993 Jean-loup Gailly
        -: 1964: * This is free software; you can redistribute it and/or modify it under the
        -: 1965: * terms of the GNU General Public License, see the file COPYING.
        -: 1966: */
        -: 1967:
        -: 1968:/*
        -: 1969: *  PURPOSE
        -: 1970: *
        -: 1971: *      Encode various sets of source values using variable-length
        -: 1972: *      binary code trees.
        -: 1973: *
        -: 1974: *  DISCUSSION
        -: 1975: *
        -: 1976: *      The PKZIP "deflation" process uses several Huffman trees. The more
        -: 1977: *      common source values are represented by shorter bit sequences.
        -: 1978: *
        -: 1979: *      Each code tree is stored in the ZIP file in a compressed form
        -: 1980: *      which is itself a Huffman encoding of the lengths of
        -: 1981: *      all the code strings (in ascending order by source values).
        -: 1982: *      The actual code strings are reconstructed from the lengths in
        -: 1983: *      the UNZIP process, as described in the "application note"
        -: 1984: *      (APPNOTE.TXT) distributed as part of PKWARE's PKZIP program.
        -: 1985: *
        -: 1986: *  REFERENCES
        -: 1987: *
        -: 1988: *      Lynch, Thomas J.
        -: 1989: *          Data Compression:  Techniques and Applications, pp. 53-55.
        -: 1990: *          Lifetime Learning Publications, 1985.  ISBN 0-534-03418-7.
        -: 1991: *
        -: 1992: *      Storer, James A.
        -: 1993: *          Data Compression:  Methods and Theory, pp. 49-50.
        -: 1994: *          Computer Science Press, 1988.  ISBN 0-7167-8156-5.
        -: 1995: *
        -: 1996: *      Sedgewick, R.
        -: 1997: *          Algorithms, p290.
        -: 1998: *          Addison-Wesley, 1983. ISBN 0-201-06672-6.
        -: 1999: *
        -: 2000: *  INTERFACE
        -: 2001: *
        -: 2002: *      void ct_init (ush *attr, int *methodp)
        -: 2003: *          Allocate the match buffer, initialize the various tables and save
        -: 2004: *          the location of the internal file attribute (ascii/binary) and
        -: 2005: *          method (DEFLATE/STORE)
        -: 2006: *
        -: 2007: *      void ct_tally (int dist, int lc);
        -: 2008: *          Save the match info and tally the frequency counts.
        -: 2009: *
        -: 2010: *      off_t flush_block (char *buf, ulg stored_len, int eof)
        -: 2011: *          Determine the best encoding for the current block: dynamic trees,
        -: 2012: *          static trees or store, and output the encoded block to the zip
        -: 2013: *          file. Returns the total compressed length for the file so far.
        -: 2014: *
        -: 2015: */
        -: 2016:
        -: 2017:#ifdef RCSID
        -: 2018:static char rcsid[] = "$Id: trees.c,v 0.12 1993/06/10 13:27:54 jloup Exp $";
        -: 2019:#endif
        -: 2020:
        -: 2021:/* ===========================================================================
        -: 2022: * Constants
        -: 2023: */
        -: 2024:
        -: 2025:#define MAX_BITS 15
        -: 2026:/* All codes must not exceed MAX_BITS bits */
        -: 2027:
        -: 2028:#define MAX_BL_BITS 7
        -: 2029:/* Bit length codes must not exceed MAX_BL_BITS bits */
        -: 2030:
        -: 2031:#define LENGTH_CODES 29
        -: 2032:/* number of length codes, not counting the special END_BLOCK code */
        -: 2033:
        -: 2034:#define LITERALS  256
        -: 2035:/* number of literal bytes 0..255 */
        -: 2036:
        -: 2037:#define END_BLOCK 256
        -: 2038:/* end of block literal code */
        -: 2039:
        -: 2040:#define L_CODES (LITERALS+1+LENGTH_CODES)
        -: 2041:/* number of Literal or Length codes, including the END_BLOCK code */
        -: 2042:
        -: 2043:#define D_CODES   30
        -: 2044:/* number of distance codes */
        -: 2045:
        -: 2046:#define BL_CODES  19
        -: 2047:/* number of codes used to transfer the bit lengths */
        -: 2048:
        -: 2049:
        -: 2050:local int near extra_lbits[LENGTH_CODES] /* extra bits for each length code */
        -: 2051:   = {0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0};
        -: 2052:
        -: 2053:local int near extra_dbits[D_CODES] /* extra bits for each distance code */
        -: 2054:   = {0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};
        -: 2055:
        -: 2056:local int near extra_blbits[BL_CODES]/* extra bits for each bit length code */
        -: 2057:   = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7};
        -: 2058:
        -: 2059:#define STORED_BLOCK 0
        -: 2060:#define STATIC_TREES 1
        -: 2061:#define DYN_TREES    2
        -: 2062:/* The three kinds of block type */
        -: 2063:
        -: 2064:#ifndef LIT_BUFSIZE
        -: 2065:#  ifdef SMALL_MEM
        -: 2066:#    define LIT_BUFSIZE  0x2000
        -: 2067:#  else
        -: 2068:#  ifdef MEDIUM_MEM
        -: 2069:#    define LIT_BUFSIZE  0x4000
        -: 2070:#  else
        -: 2071:#    define LIT_BUFSIZE  0x8000
        -: 2072:#  endif
        -: 2073:#  endif
        -: 2074:#endif
        -: 2075:#ifndef DIST_BUFSIZE
        -: 2076:#  define DIST_BUFSIZE  LIT_BUFSIZE
        -: 2077:#endif
        -: 2078:/* Sizes of match buffers for literals/lengths and distances.  There are
        -: 2079: * 4 reasons for limiting LIT_BUFSIZE to 64K:
        -: 2080: *   - frequencies can be kept in 16 bit counters
        -: 2081: *   - if compression is not successful for the first block, all input data is
        -: 2082: *     still in the window so we can still emit a stored block even when input
        -: 2083: *     comes from standard input.  (This can also be done for all blocks if
        -: 2084: *     LIT_BUFSIZE is not greater than 32K.)
        -: 2085: *   - if compression is not successful for a file smaller than 64K, we can
        -: 2086: *     even emit a stored file instead of a stored block (saving 5 bytes).
        -: 2087: *   - creating new Huffman trees less frequently may not provide fast
        -: 2088: *     adaptation to changes in the input data statistics. (Take for
        -: 2089: *     example a binary file with poorly compressible code followed by
        -: 2090: *     a highly compressible string table.) Smaller buffer sizes give
        -: 2091: *     fast adaptation but have of course the overhead of transmitting trees
        -: 2092: *     more frequently.
        -: 2093: *   - I can't count above 4
        -: 2094: * The current code is general and allows DIST_BUFSIZE < LIT_BUFSIZE (to save
        -: 2095: * memory at the expense of compression). Some optimizations would be possible
        -: 2096: * if we rely on DIST_BUFSIZE == LIT_BUFSIZE.
        -: 2097: */
        -: 2098:#if LIT_BUFSIZE > INBUFSIZ
        -: 2099:    error cannot overlay l_buf and inbuf
        -: 2100:#endif
        -: 2101:
        -: 2102:#define REP_3_6      16
        -: 2103:/* repeat previous bit length 3-6 times (2 bits of repeat count) */
        -: 2104:
        -: 2105:#define REPZ_3_10    17
        -: 2106:/* repeat a zero length 3-10 times  (3 bits of repeat count) */
        -: 2107:
        -: 2108:#define REPZ_11_138  18
        -: 2109:/* repeat a zero length 11-138 times  (7 bits of repeat count) */
        -: 2110:
        -: 2111:/* ===========================================================================
        -: 2112: * Local data
        -: 2113: */
        -: 2114:
        -: 2115:/* Data structure describing a single value and its code string. */
        -: 2116:typedef struct ct_data {
        -: 2117:    union {
        -: 2118:        ush  freq;       /* frequency count */
        -: 2119:        ush  code;       /* bit string */
        -: 2120:    } fc;
        -: 2121:    union {
        -: 2122:        ush  dad;        /* father node in Huffman tree */
        -: 2123:        ush  len;        /* length of bit string */
        -: 2124:    } dl;
        -: 2125:} ct_data;
        -: 2126:
        -: 2127:#define Freq fc.freq
        -: 2128:#define Code fc.code
        -: 2129:#define Dad  dl.dad
        -: 2130:#define Len  dl.len
        -: 2131:
        -: 2132:#define HEAP_SIZE (2*L_CODES+1)
        -: 2133:/* maximum heap size */
        -: 2134:
        -: 2135:local ct_data near dyn_ltree[HEAP_SIZE];   /* literal and length tree */
        -: 2136:local ct_data near dyn_dtree[2*D_CODES+1]; /* distance tree */
        -: 2137:
        -: 2138:local ct_data near static_ltree[L_CODES+2];
        -: 2139:/* The static literal tree. Since the bit lengths are imposed, there is no
        -: 2140: * need for the L_CODES extra codes used during heap construction. However
        -: 2141: * The codes 286 and 287 are needed to build a canonical tree (see ct_init
        -: 2142: * below).
        -: 2143: */
        -: 2144:
        -: 2145:local ct_data near static_dtree[D_CODES];
        -: 2146:/* The static distance tree. (Actually a trivial tree since all codes use
        -: 2147: * 5 bits.)
        -: 2148: */
        -: 2149:
        -: 2150:local ct_data near bl_tree[2*BL_CODES+1];
        -: 2151:/* Huffman tree for the bit lengths */
        -: 2152:
        -: 2153:typedef struct tree_desc {
        -: 2154:    ct_data near *dyn_tree;      /* the dynamic tree */
        -: 2155:    ct_data near *static_tree;   /* corresponding static tree or NULL */
        -: 2156:    int     near *extra_bits;    /* extra bits for each code or NULL */
        -: 2157:    int     extra_base;          /* base index for extra_bits */
        -: 2158:    int     elems;               /* max number of elements in the tree */
        -: 2159:    int     max_length;          /* max bit length for the codes */
        -: 2160:    int     max_code;            /* largest code with non zero frequency */
        -: 2161:} tree_desc;
        -: 2162:
        -: 2163:local tree_desc near l_desc =
        -: 2164:{dyn_ltree, static_ltree, extra_lbits, LITERALS+1, L_CODES, MAX_BITS, 0};
        -: 2165:
        -: 2166:local tree_desc near d_desc =
        -: 2167:{dyn_dtree, static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS, 0};
        -: 2168:
        -: 2169:local tree_desc near bl_desc =
        -: 2170:{bl_tree, (ct_data near *)0, extra_blbits, 0,      BL_CODES, MAX_BL_BITS, 0};
        -: 2171:
        -: 2172:
        -: 2173:local ush near bl_count[MAX_BITS+1];
        -: 2174:/* number of codes at each bit length for an optimal tree */
        -: 2175:
        -: 2176:local uch near bl_order[BL_CODES]
        -: 2177:   = {16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15};
        -: 2178:/* The lengths of the bit length codes are sent in order of decreasing
        -: 2179: * probability, to avoid transmitting the lengths for unused bit length codes.
        -: 2180: */
        -: 2181:
        -: 2182:local int near heap[2*L_CODES+1]; /* heap used to build the Huffman trees */
        -: 2183:local int heap_len;               /* number of elements in the heap */
        -: 2184:local int heap_max;               /* element of largest frequency */
        -: 2185:/* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
        -: 2186: * The same heap array is used to build all trees.
        -: 2187: */
        -: 2188:
        -: 2189:local uch near depth[2*L_CODES+1];
        -: 2190:/* Depth of each subtree used as tie breaker for trees of equal frequency */
        -: 2191:
        -: 2192:local uch length_code[MAX_MATCH-MIN_MATCH+1];
        -: 2193:/* length code for each normalized match length (0 == MIN_MATCH) */
        -: 2194:
        -: 2195:local uch dist_code[512];
        -: 2196:/* distance codes. The first 256 values correspond to the distances
        -: 2197: * 3 .. 258, the last 256 values correspond to the top 8 bits of
        -: 2198: * the 15 bit distances.
        -: 2199: */
        -: 2200:
        -: 2201:local int near base_length[LENGTH_CODES];
        -: 2202:/* First normalized length for each code (0 = MIN_MATCH) */
        -: 2203:
        -: 2204:local int near base_dist[D_CODES];
        -: 2205:/* First normalized distance for each code (0 = distance of 1) */
        -: 2206:
        -: 2207:#define l_buf inbuf
        -: 2208:/* DECLARE(uch, l_buf, LIT_BUFSIZE);  buffer for literals or lengths */
        -: 2209:
        -: 2210:/* DECLARE(ush, d_buf, DIST_BUFSIZE); buffer for distances */
        -: 2211:
        -: 2212:local uch near flag_buf[(LIT_BUFSIZE/8)];
        -: 2213:/* flag_buf is a bit array distinguishing literals from lengths in
        -: 2214: * l_buf, thus indicating the presence or absence of a distance.
        -: 2215: */
        -: 2216:
        -: 2217:local unsigned last_lit;    /* running index in l_buf */
        -: 2218:local unsigned last_dist;   /* running index in d_buf */
        -: 2219:local unsigned last_flags;  /* running index in flag_buf */
        -: 2220:local uch flags;            /* current flags not yet saved in flag_buf */
        -: 2221:local uch flag_bit;         /* current bit used in flags */
        -: 2222:/* bits are filled in flags starting at bit 0 (least significant).
        -: 2223: * Note: these flags are overkill in the current code since we don't
        -: 2224: * take advantage of DIST_BUFSIZE == LIT_BUFSIZE.
        -: 2225: */
        -: 2226:
        -: 2227:local ulg opt_len;        /* bit length of current block with optimal trees */
        -: 2228:local ulg static_len;     /* bit length of current block with static trees */
        -: 2229:
        -: 2230:local off_t compressed_len; /* total bit length of compressed file */
        -: 2231:
        -: 2232:local off_t input_len;      /* total byte length of input file */
        -: 2233:/* input_len is for debugging only since we can get it by other means. */
        -: 2234:
        -: 2235:ush *file_type;        /* pointer to UNKNOWN, BINARY or ASCII */
        -: 2236:int *file_method;      /* pointer to DEFLATE or STORE */
        -: 2237:
        -: 2238:#ifdef DEBUG
        -: 2239:extern off_t bits_sent;  /* bit length of the compressed data */
        -: 2240:#endif
        -: 2241:
        -: 2242:extern long block_start;       /* window offset of current block */
        -: 2243:extern unsigned near strstart; /* window offset of current string */
        -: 2244:
        -: 2245:/* ===========================================================================
        -: 2246: * Local (static) routines in this file.
        -: 2247: */
        -: 2248:
        -: 2249:local void init_block     OF((void));
        -: 2250:local void pqdownheap     OF((ct_data near *tree, int k));
        -: 2251:local void gen_bitlen     OF((tree_desc near *desc));
        -: 2252:local void gen_codes      OF((ct_data near *tree, int max_code));
        -: 2253:local void build_tree     OF((tree_desc near *desc));
        -: 2254:local void scan_tree      OF((ct_data near *tree, int max_code));
        -: 2255:local void send_tree      OF((ct_data near *tree, int max_code));
        -: 2256:local int  build_bl_tree  OF((void));
        -: 2257:local void send_all_trees OF((int lcodes, int dcodes, int blcodes));
        -: 2258:local void compress_block OF((ct_data near *ltree, ct_data near *dtree));
        -: 2259:local void set_file_type  OF((void));
        -: 2260:
        -: 2261:
        -: 2262:#ifndef DEBUG
        -: 2263:#  define send_code(c, tree) send_bits(tree[c].Code, tree[c].Len)
        -: 2264:   /* Send a code of the given tree. c and tree must not have side effects */
        -: 2265:
        -: 2266:#else /* DEBUG */
        -: 2267:#  define send_code(c, tree) \
        -: 2268:     { if (verbose>1) fprintf(stderr,"\ncd %3d ",(c)); \
        -: 2269:       send_bits(tree[c].Code, tree[c].Len); }
        -: 2270:#endif
        -: 2271:
        -: 2272:#define d_code(dist) \
        -: 2273:   ((dist) < 256 ? dist_code[dist] : dist_code[256+((dist)>>7)])
        -: 2274:/* Mapping from a distance to a distance code. dist is the distance - 1 and
        -: 2275: * must not have side effects. dist_code[256] and dist_code[257] are never
        -: 2276: * used.
        -: 2277: */
        -: 2278:
        -: 2279:#define MAX(a,b) (a >= b ? a : b)
        -: 2280:/* the arguments must not have side effects */
        -: 2281:
        -: 2282:/* ===========================================================================
        -: 2283: * Allocate the match buffer, initialize the various tables and save the
        -: 2284: * location of the internal file attribute (ascii/binary) and method
        -: 2285: * (DEFLATE/STORE).
        -: 2286: */
function ct_init called 1 returned 100% blocks executed 98%
        1: 2287:void ct_init(attr, methodp)
        -: 2288:    ush  *attr;   /* pointer to internal file attribute */
        -: 2289:    int  *methodp; /* pointer to compression method */
        -: 2290:{
        -: 2291:    int n;        /* iterates over tree elements */
        -: 2292:    int bits;     /* bit counter */
        -: 2293:    int length;   /* length value */
        -: 2294:    int code;     /* code value */
        -: 2295:    int dist;     /* distance index */
        -: 2296:
        1: 2297:    file_type = attr;
        1: 2298:    file_method = methodp;
        1: 2299:    compressed_len = input_len = 0L;
        -: 2300:        
       1*: 2301:    if (static_dtree[0].Len != 0) return; /* ct_init already called */
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -: 2302:
        -: 2303:    /* Initialize the mapping length (0..255) -> length code (0..28) */
        1: 2304:    length = 0;
       29: 2305:    for (code = 0; code < LENGTH_CODES-1; code++) {
branch  0 taken 28
branch  1 taken 1 (fallthrough)
       28: 2306:        base_length[code] = length;
      284: 2307:        for (n = 0; n < (1<<extra_lbits[code]); n++) {
branch  0 taken 256
branch  1 taken 28 (fallthrough)
      256: 2308:            length_code[length++] = (uch)code;
        -: 2309:        }
        -: 2310:    }
        -: 2311:    Assert (length == 256, "ct_init: length != 256");
        -: 2312:    /* Note that the length 255 (match length 258) can be represented
        -: 2313:     * in two different ways: code 284 + 5 bits or code 285, so we
        -: 2314:     * overwrite length_code[255] to use the best encoding:
        -: 2315:     */
        1: 2316:    length_code[length-1] = (uch)code;
        -: 2317:
        -: 2318:    /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
        1: 2319:    dist = 0;
       17: 2320:    for (code = 0 ; code < 16; code++) {
branch  0 taken 16
branch  1 taken 1 (fallthrough)
       16: 2321:        base_dist[code] = dist;
      272: 2322:        for (n = 0; n < (1<<extra_dbits[code]); n++) {
branch  0 taken 256
branch  1 taken 16 (fallthrough)
      256: 2323:            dist_code[dist++] = (uch)code;
        -: 2324:        }
        -: 2325:    }
        -: 2326:    Assert (dist == 256, "ct_init: dist != 256");
        1: 2327:    dist >>= 7; /* from now on, all distances are divided by 128 */
       15: 2328:    for ( ; code < D_CODES; code++) {
branch  0 taken 14
branch  1 taken 1 (fallthrough)
       14: 2329:        base_dist[code] = dist << 7;
      268: 2330:        for (n = 0; n < (1<<(extra_dbits[code]-7)); n++) {
branch  0 taken 254
branch  1 taken 14 (fallthrough)
      254: 2331:            dist_code[256 + dist++] = (uch)code;
        -: 2332:        }
        -: 2333:    }
        -: 2334:    Assert (dist == 256, "ct_init: 256+dist != 512");
        -: 2335:
        -: 2336:    /* Construct the codes of the static literal tree */
       17: 2337:    for (bits = 0; bits <= MAX_BITS; bits++) bl_count[bits] = 0;
branch  0 taken 16
branch  1 taken 1 (fallthrough)
        1: 2338:    n = 0;
      145: 2339:    while (n <= 143) static_ltree[n++].Len = 8, bl_count[8]++;
branch  0 taken 144
branch  1 taken 1 (fallthrough)
      113: 2340:    while (n <= 255) static_ltree[n++].Len = 9, bl_count[9]++;
branch  0 taken 112
branch  1 taken 1 (fallthrough)
       25: 2341:    while (n <= 279) static_ltree[n++].Len = 7, bl_count[7]++;
branch  0 taken 24
branch  1 taken 1 (fallthrough)
        9: 2342:    while (n <= 287) static_ltree[n++].Len = 8, bl_count[8]++;
branch  0 taken 8
branch  1 taken 1 (fallthrough)
        -: 2343:    /* Codes 286 and 287 do not exist, but we must include them in the
        -: 2344:     * tree construction to get a canonical Huffman tree (longest code
        -: 2345:     * all ones)
        -: 2346:     */
        1: 2347:    gen_codes((ct_data near *)static_ltree, L_CODES+1);
call    0 returned 1
        -: 2348:
        -: 2349:    /* The static distance tree is trivial: */
       31: 2350:    for (n = 0; n < D_CODES; n++) {
branch  0 taken 30
branch  1 taken 1 (fallthrough)
       30: 2351:        static_dtree[n].Len = 5;
       30: 2352:        static_dtree[n].Code = bi_reverse(n, 5);
call    0 returned 30
        -: 2353:    }
        -: 2354:
        -: 2355:    /* Initialize the first block of the first file: */
        1: 2356:    init_block();
call    0 returned 1
        -: 2357:}
        -: 2358:
        -: 2359:/* ===========================================================================
        -: 2360: * Initialize a new block.
        -: 2361: */
function init_block called 2 returned 100% blocks executed 100%
        2: 2362:local void init_block()
        -: 2363:{
        -: 2364:    int n; /* iterates over tree elements */
        -: 2365:
        -: 2366:    /* Initialize the trees. */
      574: 2367:    for (n = 0; n < L_CODES;  n++) dyn_ltree[n].Freq = 0;
branch  0 taken 572
branch  1 taken 2 (fallthrough)
       62: 2368:    for (n = 0; n < D_CODES;  n++) dyn_dtree[n].Freq = 0;
branch  0 taken 60
branch  1 taken 2 (fallthrough)
       40: 2369:    for (n = 0; n < BL_CODES; n++) bl_tree[n].Freq = 0;
branch  0 taken 38
branch  1 taken 2 (fallthrough)
        -: 2370:
        2: 2371:    dyn_ltree[END_BLOCK].Freq = 1;
        2: 2372:    opt_len = static_len = 0L;
        2: 2373:    last_lit = last_dist = last_flags = 0;
        2: 2374:    flags = 0; flag_bit = 1;
        2: 2375:}
        -: 2376:
        -: 2377:#define SMALLEST 1
        -: 2378:/* Index within the heap array of least frequent node in the Huffman tree */
        -: 2379:
        -: 2380:
        -: 2381:/* ===========================================================================
        -: 2382: * Remove the smallest element from the heap and recreate the heap with
        -: 2383: * one less element. Updates heap and heap_len.
        -: 2384: */
        -: 2385:#define pqremove(tree, top) \
        -: 2386:{\
        -: 2387:    top = heap[SMALLEST]; \
        -: 2388:    heap[SMALLEST] = heap[heap_len--]; \
        -: 2389:    pqdownheap(tree, SMALLEST); \
        -: 2390:}
        -: 2391:
        -: 2392:/* ===========================================================================
        -: 2393: * Compares to subtrees, using the tree depth as tie breaker when
        -: 2394: * the subtrees have equal frequency. This minimizes the worst case length.
        -: 2395: */
        -: 2396:#define smaller(tree, n, m) \
        -: 2397:   (tree[n].Freq < tree[m].Freq || \
        -: 2398:   (tree[n].Freq == tree[m].Freq && depth[n] <= depth[m]))
        -: 2399:
        -: 2400:/* ===========================================================================
        -: 2401: * Restore the heap property by moving down the tree starting at node k,
        -: 2402: * exchanging a node with the smallest of its two sons if necessary, stopping
        -: 2403: * when the heap property is re-established (each father smaller than its
        -: 2404: * two sons).
        -: 2405: */
function pqdownheap called 383 returned 100% blocks executed 100%
      383: 2406:local void pqdownheap(tree, k)
        -: 2407:    ct_data near *tree;  /* the tree to restore */
        -: 2408:    int k;               /* node to move down */
        -: 2409:{
      383: 2410:    int v = heap[k];
      383: 2411:    int j = k << 1;  /* left son of k */
     1540: 2412:    while (j <= heap_len) {
branch  0 taken 1289
branch  1 taken 251 (fallthrough)
        -: 2413:        /* Set j to the smallest of the two sons: */
     1289: 2414:        if (j < heap_len && smaller(tree, heap[j+1], heap[j])) j++;
branch  0 taken 1262 (fallthrough)
branch  1 taken 27
branch  2 taken 748 (fallthrough)
branch  3 taken 514
branch  4 taken 155 (fallthrough)
branch  5 taken 593
branch  6 taken 108 (fallthrough)
branch  7 taken 47
        -: 2415:
        -: 2416:        /* Exit if v is smaller than both sons */
     1289: 2417:        if (smaller(tree, v, heap[j])) break;
branch  0 taken 1167 (fallthrough)
branch  1 taken 122
branch  2 taken 25 (fallthrough)
branch  3 taken 1142
branch  4 taken 15 (fallthrough)
branch  5 taken 10
        -: 2418:
        -: 2419:        /* Exchange v with the smallest son */
     1157: 2420:        heap[k] = heap[j];  k = j;
        -: 2421:
        -: 2422:        /* And continue down the tree, setting j to the left son of k */
     1157: 2423:        j <<= 1;
        -: 2424:    }
      383: 2425:    heap[k] = v;
      383: 2426:}
        -: 2427:
        -: 2428:/* ===========================================================================
        -: 2429: * Compute the optimal bit lengths for a tree and update the total bit length
        -: 2430: * for the current block.
        -: 2431: * IN assertion: the fields freq and dad are set, heap[heap_max] and
        -: 2432: *    above are the tree nodes sorted by increasing frequency.
        -: 2433: * OUT assertions: the field len is set to the optimal bit length, the
        -: 2434: *     array bl_count contains the frequencies for each bit length.
        -: 2435: *     The length opt_len is updated; static_len is also updated if stree is
        -: 2436: *     not null.
        -: 2437: */
function gen_bitlen called 3 returned 100% blocks executed 52%
        3: 2438:local void gen_bitlen(desc)
        -: 2439:    tree_desc near *desc; /* the tree descriptor */
        -: 2440:{
        3: 2441:    ct_data near *tree  = desc->dyn_tree;
        3: 2442:    int near *extra     = desc->extra_bits;
        3: 2443:    int base            = desc->extra_base;
        3: 2444:    int max_code        = desc->max_code;
        3: 2445:    int max_length      = desc->max_length;
        3: 2446:    ct_data near *stree = desc->static_tree;
        -: 2447:    int h;              /* heap index */
        -: 2448:    int n, m;           /* iterate over the tree elements */
        -: 2449:    int bits;           /* bit length */
        -: 2450:    int xbits;          /* extra bits */
        -: 2451:    ush f;              /* frequency */
        3: 2452:    int overflow = 0;   /* number of elements with bit length too large */
        -: 2453:
       51: 2454:    for (bits = 0; bits <= MAX_BITS; bits++) bl_count[bits] = 0;
branch  0 taken 48
branch  1 taken 3 (fallthrough)
        -: 2455:
        -: 2456:    /* In a first pass, compute the optimal bit lengths (which may
        -: 2457:     * overflow in the case of the bit length tree).
        -: 2458:     */
        3: 2459:    tree[heap[heap_max]].Len = 0; /* root of the heap */
        -: 2460:
      309: 2461:    for (h = heap_max+1; h < HEAP_SIZE; h++) {
branch  0 taken 306
branch  1 taken 3 (fallthrough)
      306: 2462:        n = heap[h];
      306: 2463:        bits = tree[tree[n].Dad].Len + 1;
     306*: 2464:        if (bits > max_length) bits = max_length, overflow++;
branch  0 taken 0 (fallthrough)
branch  1 taken 306
      306: 2465:        tree[n].Len = (ush)bits;
        -: 2466:        /* We overwrite tree[n].Dad which is no longer needed */
        -: 2467:
      306: 2468:        if (n > max_code) continue; /* not a leaf node */
branch  0 taken 150 (fallthrough)
branch  1 taken 156
        -: 2469:
      156: 2470:        bl_count[bits]++;
      156: 2471:        xbits = 0;
      156: 2472:        if (n >= base) xbits = extra[n-base];
branch  0 taken 64 (fallthrough)
branch  1 taken 92
      156: 2473:        f = tree[n].Freq;
      156: 2474:        opt_len += (ulg)f * (bits + xbits);
      156: 2475:        if (stree) static_len += (ulg)f * (stree[n].Len + xbits);
branch  0 taken 141 (fallthrough)
branch  1 taken 15
        -: 2476:    }
        3: 2477:    if (overflow == 0) return;
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        -: 2478:
        -: 2479:    Trace((stderr,"\nbit length overflow\n"));
        -: 2480:    /* This happens for example on obj2 and pic of the Calgary corpus */
        -: 2481:
        -: 2482:    /* Find the first bit length which could increase: */
        -: 2483:    do {
    #####: 2484:        bits = max_length-1;
    #####: 2485:        while (bl_count[bits] == 0) bits--;
branch  0 never executed
branch  1 never executed
    #####: 2486:        bl_count[bits]--;      /* move one leaf down the tree */
    #####: 2487:        bl_count[bits+1] += 2; /* move one overflow item as its brother */
    #####: 2488:        bl_count[max_length]--;
        -: 2489:        /* The brother of the overflow item also moves one step up,
        -: 2490:         * but this does not affect bl_count[max_length]
        -: 2491:         */
    #####: 2492:        overflow -= 2;
    #####: 2493:    } while (overflow > 0);
branch  0 never executed
branch  1 never executed
        -: 2494:
        -: 2495:    /* Now recompute all bit lengths, scanning in increasing frequency.
        -: 2496:     * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
        -: 2497:     * lengths instead of fixing only the wrong ones. This idea is taken
        -: 2498:     * from 'ar' written by Haruhiko Okumura.)
        -: 2499:     */
    #####: 2500:    for (bits = max_length; bits != 0; bits--) {
branch  0 never executed
branch  1 never executed
    #####: 2501:        n = bl_count[bits];
    #####: 2502:        while (n != 0) {
branch  0 never executed
branch  1 never executed
    #####: 2503:            m = heap[--h];
    #####: 2504:            if (m > max_code) continue;
branch  0 never executed
branch  1 never executed
    #####: 2505:            if (tree[m].Len != (unsigned) bits) {
branch  0 never executed
branch  1 never executed
        -: 2506:                Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
    #####: 2507:                opt_len += ((long)bits-(long)tree[m].Len)*(long)tree[m].Freq;
    #####: 2508:                tree[m].Len = (ush)bits;
        -: 2509:            }
    #####: 2510:            n--;
        -: 2511:        }
        -: 2512:    }
        -: 2513:}
        -: 2514:
        -: 2515:/* ===========================================================================
        -: 2516: * Generate the codes for a given tree and bit counts (which need not be
        -: 2517: * optimal).
        -: 2518: * IN assertion: the array bl_count contains the bit length statistics for
        -: 2519: * the given tree and the field len is set for all tree elements.
        -: 2520: * OUT assertion: the field code is set for all tree elements of non
        -: 2521: *     zero code length.
        -: 2522: */
function gen_codes called 4 returned 100% blocks executed 100%
        4: 2523:local void gen_codes (tree, max_code)
        -: 2524:    ct_data near *tree;        /* the tree to decorate */
        -: 2525:    int max_code;              /* largest code with non zero frequency */
        -: 2526:{
        -: 2527:    ush next_code[MAX_BITS+1]; /* next code value for each bit length */
        4: 2528:    ush code = 0;              /* running code value */
        -: 2529:    int bits;                  /* bit index */
        -: 2530:    int n;                     /* code index */
        -: 2531:
        -: 2532:    /* The distribution counts are first used to generate the code values
        -: 2533:     * without bit reversal.
        -: 2534:     */
       64: 2535:    for (bits = 1; bits <= MAX_BITS; bits++) {
branch  0 taken 60
branch  1 taken 4 (fallthrough)
       60: 2536:        next_code[bits] = code = (code + bl_count[bits-1]) << 1;
        -: 2537:    }
        -: 2538:    /* Check that the bit counts in bl_count are consistent. The last code
        -: 2539:     * must be all ones.
        -: 2540:     */
        -: 2541:    Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
        -: 2542:            "inconsistent bit counts");
        -: 2543:    Tracev((stderr,"\ngen_codes: max_code %d ", max_code));
        -: 2544:
      627: 2545:    for (n = 0;  n <= max_code; n++) {
branch  0 taken 623
branch  1 taken 4 (fallthrough)
      623: 2546:        int len = tree[n].Len;
      623: 2547:        if (len == 0) continue;
branch  0 taken 179 (fallthrough)
branch  1 taken 444
        -: 2548:        /* Now reverse the bits */
      444: 2549:        tree[n].Code = bi_reverse(next_code[len]++, len);
call    0 returned 444
        -: 2550:
        -: 2551:        Tracec(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
        -: 2552:             n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
        -: 2553:    }
        4: 2554:}
        -: 2555:
        -: 2556:/* ===========================================================================
        -: 2557: * Construct one Huffman tree and assigns the code bit strings and lengths.
        -: 2558: * Update the total bit length for the current block.
        -: 2559: * IN assertion: the field freq is set for all tree elements.
        -: 2560: * OUT assertions: the fields len and code are set to the optimal bit length
        -: 2561: *     and corresponding code. The length opt_len is updated; static_len is
        -: 2562: *     also updated if stree is not null. The field max_code is set.
        -: 2563: */
function build_tree called 3 returned 100% blocks executed 81%
        3: 2564:local void build_tree(desc)
        -: 2565:    tree_desc near *desc; /* the tree descriptor */
        -: 2566:{
        3: 2567:    ct_data near *tree   = desc->dyn_tree;
        3: 2568:    ct_data near *stree  = desc->static_tree;
        3: 2569:    int elems            = desc->elems;
        -: 2570:    int n, m;          /* iterate over heap elements */
        3: 2571:    int max_code = -1; /* largest code with non zero frequency */
        3: 2572:    int node = elems;  /* next internal node of the tree */
        -: 2573:
        -: 2574:    /* Construct the initial heap, with least frequent element in
        -: 2575:     * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
        -: 2576:     * heap[0] is not used.
        -: 2577:     */
        3: 2578:    heap_len = 0, heap_max = HEAP_SIZE;
        -: 2579:
      338: 2580:    for (n = 0; n < elems; n++) {
branch  0 taken 335
branch  1 taken 3 (fallthrough)
      335: 2581:        if (tree[n].Freq != 0) {
branch  0 taken 156 (fallthrough)
branch  1 taken 179
      156: 2582:            heap[++heap_len] = max_code = n;
      156: 2583:            depth[n] = 0;
        -: 2584:        } else {
      179: 2585:            tree[n].Len = 0;
        -: 2586:        }
        -: 2587:    }
        -: 2588:
        -: 2589:    /* The pkzip format requires that at least one distance code exists,
        -: 2590:     * and that at least one bit should be sent even if there is only one
        -: 2591:     * possible code. So to avoid special checks later on we force at least
        -: 2592:     * two codes of non zero frequency.
        -: 2593:     */
        3: 2594:    while (heap_len < 2) {
branch  0 taken 0
branch  1 taken 3 (fallthrough)
    #####: 2595:        int new = heap[++heap_len] = (max_code < 2 ? ++max_code : 0);
branch  0 never executed
branch  1 never executed
    #####: 2596:        tree[new].Freq = 1;
    #####: 2597:        depth[new] = 0;
    #####: 2598:        opt_len--; if (stree) static_len -= stree[new].Len;
branch  0 never executed
branch  1 never executed
        -: 2599:        /* new is 0 or 1 so it does not have extra bits */
        -: 2600:    }
        3: 2601:    desc->max_code = max_code;
        -: 2602:
        -: 2603:    /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
        -: 2604:     * establish sub-heaps of increasing lengths:
        -: 2605:     */
       80: 2606:    for (n = heap_len/2; n >= 1; n--) pqdownheap(tree, n);
call    0 returned 77
branch  1 taken 77
branch  2 taken 3 (fallthrough)
        -: 2607:
        -: 2608:    /* Construct the Huffman tree by repeatedly combining the least two
        -: 2609:     * frequent nodes.
        -: 2610:     */
        -: 2611:    do {
      153: 2612:        pqremove(tree, n);   /* n = node of least frequency */
call    0 returned 153
      153: 2613:        m = heap[SMALLEST];  /* m = node of next least frequency */
        -: 2614:
      153: 2615:        heap[--heap_max] = n; /* keep the nodes sorted by frequency */
      153: 2616:        heap[--heap_max] = m;
        -: 2617:
        -: 2618:        /* Create a new node father of n and m */
      153: 2619:        tree[node].Freq = tree[n].Freq + tree[m].Freq;
      153: 2620:        depth[node] = (uch) (MAX(depth[n], depth[m]) + 1);
branch  0 taken 98 (fallthrough)
branch  1 taken 55
      153: 2621:        tree[n].Dad = tree[m].Dad = (ush)node;
        -: 2622:#ifdef DUMP_BL_TREE
        -: 2623:        if (tree == bl_tree) {
        -: 2624:            fprintf(stderr,"\nnode %d(%d), sons %d(%d) %d(%d)",
        -: 2625:                    node, tree[node].Freq, n, tree[n].Freq, m, tree[m].Freq);
        -: 2626:        }
        -: 2627:#endif
        -: 2628:        /* and insert the new node in the heap */
      153: 2629:        heap[SMALLEST] = node++;
      153: 2630:        pqdownheap(tree, SMALLEST);
call    0 returned 153
        -: 2631:
      153: 2632:    } while (heap_len >= 2);
branch  0 taken 150
branch  1 taken 3 (fallthrough)
        -: 2633:
        3: 2634:    heap[--heap_max] = heap[SMALLEST];
        -: 2635:
        -: 2636:    /* At this point, the fields freq and dad are set. We can now
        -: 2637:     * generate the bit lengths.
        -: 2638:     */
        3: 2639:    gen_bitlen((tree_desc near *)desc);
call    0 returned 3
        -: 2640:
        -: 2641:    /* The field len is now set, we can generate the bit codes */
        3: 2642:    gen_codes ((ct_data near *)tree, max_code);
call    0 returned 3
        3: 2643:}
        -: 2644:
        -: 2645:/* ===========================================================================
        -: 2646: * Scan a literal or distance tree to determine the frequencies of the codes
        -: 2647: * in the bit length tree. Updates opt_len to take into account the repeat
        -: 2648: * counts. (The contribution of the bit length codes will be added later
        -: 2649: * during the construction of bl_tree.)
        -: 2650: */
function scan_tree called 2 returned 100% blocks executed 100%
        2: 2651:local void scan_tree (tree, max_code)
        -: 2652:    ct_data near *tree; /* the tree to be scanned */
        -: 2653:    int max_code;       /* and its largest code of non zero frequency */
        -: 2654:{
        -: 2655:    int n;                     /* iterates over all tree elements */
        2: 2656:    int prevlen = -1;          /* last emitted length */
        -: 2657:    int curlen;                /* length of current code */
        2: 2658:    int nextlen = tree[0].Len; /* length of next code */
        2: 2659:    int count = 0;             /* repeat count of the current code */
        2: 2660:    int max_count = 7;         /* max repeat count */
        2: 2661:    int min_count = 4;         /* min repeat count */
        -: 2662:
        2: 2663:    if (nextlen == 0) max_count = 138, min_count = 3;
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        2: 2664:    tree[max_code+1].Len = (ush)0xffff; /* guard */
        -: 2665:
      318: 2666:    for (n = 0; n <= max_code; n++) {
branch  0 taken 316
branch  1 taken 2 (fallthrough)
      316: 2667:        curlen = nextlen; nextlen = tree[n+1].Len;
      316: 2668:        if (++count < max_count && curlen == nextlen) {
branch  0 taken 315 (fallthrough)
branch  1 taken 1
branch  2 taken 210 (fallthrough)
branch  3 taken 105
      210: 2669:            continue;
      106: 2670:        } else if (count < min_count) {
branch  0 taken 95 (fallthrough)
branch  1 taken 11
       95: 2671:            bl_tree[curlen].Freq += count;
       11: 2672:        } else if (curlen != 0) {
branch  0 taken 6 (fallthrough)
branch  1 taken 5
        6: 2673:            if (curlen != prevlen) bl_tree[curlen].Freq++;
branch  0 taken 5 (fallthrough)
branch  1 taken 1
        6: 2674:            bl_tree[REP_3_6].Freq++;
        5: 2675:        } else if (count <= 10) {
branch  0 taken 3 (fallthrough)
branch  1 taken 2
        3: 2676:            bl_tree[REPZ_3_10].Freq++;
        -: 2677:        } else {
        2: 2678:            bl_tree[REPZ_11_138].Freq++;
        -: 2679:        }
      106: 2680:        count = 0; prevlen = curlen;
      106: 2681:        if (nextlen == 0) {
branch  0 taken 12 (fallthrough)
branch  1 taken 94
       12: 2682:            max_count = 138, min_count = 3;
       94: 2683:        } else if (curlen == nextlen) {
branch  0 taken 1 (fallthrough)
branch  1 taken 93
        1: 2684:            max_count = 6, min_count = 3;
        -: 2685:        } else {
       93: 2686:            max_count = 7, min_count = 4;
        -: 2687:        }
        -: 2688:    }
        2: 2689:}
        -: 2690:
        -: 2691:/* ===========================================================================
        -: 2692: * Send a literal or distance tree in compressed form, using the codes in
        -: 2693: * bl_tree.
        -: 2694: */
function send_tree called 2 returned 100% blocks executed 100%
        2: 2695:local void send_tree (tree, max_code)
        -: 2696:    ct_data near *tree; /* the tree to be scanned */
        -: 2697:    int max_code;       /* and its largest code of non zero frequency */
        -: 2698:{
        -: 2699:    int n;                     /* iterates over all tree elements */
        2: 2700:    int prevlen = -1;          /* last emitted length */
        -: 2701:    int curlen;                /* length of current code */
        2: 2702:    int nextlen = tree[0].Len; /* length of next code */
        2: 2703:    int count = 0;             /* repeat count of the current code */
        2: 2704:    int max_count = 7;         /* max repeat count */
        2: 2705:    int min_count = 4;         /* min repeat count */
        -: 2706:
        -: 2707:    /* tree[max_code+1].Len = -1; */  /* guard already set */
        2: 2708:    if (nextlen == 0) max_count = 138, min_count = 3;
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        -: 2709:
      318: 2710:    for (n = 0; n <= max_code; n++) {
branch  0 taken 316
branch  1 taken 2 (fallthrough)
      316: 2711:        curlen = nextlen; nextlen = tree[n+1].Len;
      316: 2712:        if (++count < max_count && curlen == nextlen) {
branch  0 taken 315 (fallthrough)
branch  1 taken 1
branch  2 taken 210 (fallthrough)
branch  3 taken 105
      210: 2713:            continue;
      106: 2714:        } else if (count < min_count) {
branch  0 taken 95 (fallthrough)
branch  1 taken 11
      121: 2715:            do { send_code(curlen, bl_tree); } while (--count != 0);
call    0 returned 121
branch  1 taken 26
branch  2 taken 95
        -: 2716:
       11: 2717:        } else if (curlen != 0) {
branch  0 taken 6 (fallthrough)
branch  1 taken 5
        6: 2718:            if (curlen != prevlen) {
branch  0 taken 5 (fallthrough)
branch  1 taken 1
        5: 2719:                send_code(curlen, bl_tree); count--;
call    0 returned 5
        -: 2720:            }
        -: 2721:            Assert(count >= 3 && count <= 6, " 3_6?");
        6: 2722:            send_code(REP_3_6, bl_tree); send_bits(count-3, 2);
call    0 returned 6
call    1 returned 6
        -: 2723:
        5: 2724:        } else if (count <= 10) {
branch  0 taken 3 (fallthrough)
branch  1 taken 2
        3: 2725:            send_code(REPZ_3_10, bl_tree); send_bits(count-3, 3);
call    0 returned 3
call    1 returned 3
        -: 2726:
        -: 2727:        } else {
        2: 2728:            send_code(REPZ_11_138, bl_tree); send_bits(count-11, 7);
call    0 returned 2
call    1 returned 2
        -: 2729:        }
      106: 2730:        count = 0; prevlen = curlen;
      106: 2731:        if (nextlen == 0) {
branch  0 taken 12 (fallthrough)
branch  1 taken 94
       12: 2732:            max_count = 138, min_count = 3;
       94: 2733:        } else if (curlen == nextlen) {
branch  0 taken 1 (fallthrough)
branch  1 taken 93
        1: 2734:            max_count = 6, min_count = 3;
        -: 2735:        } else {
       93: 2736:            max_count = 7, min_count = 4;
        -: 2737:        }
        -: 2738:    }
        2: 2739:}
        -: 2740:
        -: 2741:/* ===========================================================================
        -: 2742: * Construct the Huffman tree for the bit lengths and return the index in
        -: 2743: * bl_order of the last bit length code to send.
        -: 2744: */
function build_bl_tree called 1 returned 100% blocks executed 100%
        1: 2745:local int build_bl_tree()
        -: 2746:{
        -: 2747:    int max_blindex;  /* index of last bit length code of non zero freq */
        -: 2748:
        -: 2749:    /* Determine the bit length frequencies for literal and distance trees */
        1: 2750:    scan_tree((ct_data near *)dyn_ltree, l_desc.max_code);
call    0 returned 1
        1: 2751:    scan_tree((ct_data near *)dyn_dtree, d_desc.max_code);
call    0 returned 1
        -: 2752:
        -: 2753:    /* Build the bit length tree: */
        1: 2754:    build_tree((tree_desc near *)(&bl_desc));
call    0 returned 1
        -: 2755:    /* opt_len now includes the length of the tree representations, except
        -: 2756:     * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
        -: 2757:     */
        -: 2758:
        -: 2759:    /* Determine the number of bit length codes to send. The pkzip format
        -: 2760:     * requires that at least 4 bit length codes be sent. (appnote.txt says
        -: 2761:     * 3 but the actual value used is 4.)
        -: 2762:     */
        5: 2763:    for (max_blindex = BL_CODES-1; max_blindex >= 3; max_blindex--) {
branch  0 taken 5
branch  1 taken 0 (fallthrough)
        5: 2764:        if (bl_tree[bl_order[max_blindex]].Len != 0) break;
branch  0 taken 1 (fallthrough)
branch  1 taken 4
        -: 2765:    }
        -: 2766:    /* Update opt_len to include the bit length tree and counts */
        1: 2767:    opt_len += 3*(max_blindex+1) + 5+5+4;
        -: 2768:    Tracev((stderr, "\ndyn trees: dyn %lu, stat %lu", opt_len, static_len));
        -: 2769:
        1: 2770:    return max_blindex;
        -: 2771:}
        -: 2772:
        -: 2773:/* ===========================================================================
        -: 2774: * Send the header for a block using dynamic Huffman trees: the counts, the
        -: 2775: * lengths of the bit length codes, the literal tree and the distance tree.
        -: 2776: * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
        -: 2777: */
function send_all_trees called 1 returned 100% blocks executed 100%
        1: 2778:local void send_all_trees(lcodes, dcodes, blcodes)
        -: 2779:    int lcodes, dcodes, blcodes; /* number of codes for each tree */
        -: 2780:{
        -: 2781:    int rank;                    /* index in bl_order */
        -: 2782:
        -: 2783:    Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
        -: 2784:    Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
        -: 2785:            "too many codes");
        -: 2786:    Tracev((stderr, "\nbl counts: "));
        1: 2787:    send_bits(lcodes-257, 5); /* not +255 as stated in appnote.txt */
call    0 returned 1
        1: 2788:    send_bits(dcodes-1,   5);
call    0 returned 1
        1: 2789:    send_bits(blcodes-4,  4); /* not -3 as stated in appnote.txt */
call    0 returned 1
       16: 2790:    for (rank = 0; rank < blcodes; rank++) {
branch  0 taken 15
branch  1 taken 1 (fallthrough)
        -: 2791:        Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
       15: 2792:        send_bits(bl_tree[bl_order[rank]].Len, 3);
call    0 returned 15
        -: 2793:    }
        -: 2794:
        1: 2795:    send_tree((ct_data near *)dyn_ltree, lcodes-1); /* send the literal tree */
call    0 returned 1
        -: 2796:
        1: 2797:    send_tree((ct_data near *)dyn_dtree, dcodes-1); /* send the distance tree */
call    0 returned 1
        1: 2798:}
        -: 2799:
        -: 2800:/* ===========================================================================
        -: 2801: * Determine the best encoding for the current block: dynamic trees, static
        -: 2802: * trees or store, and output the encoded block to the zip file. This function
        -: 2803: * returns the total compressed length for the file so far.
        -: 2804: */
function flush_block called 1 returned 100% blocks executed 68%
        1: 2805:off_t flush_block(buf, stored_len, eof)
        -: 2806:    char *buf;        /* input block, or NULL if too old */
        -: 2807:    ulg stored_len;   /* length of input block */
        -: 2808:    int eof;          /* true if this is the last block for a file */
        -: 2809:{
        -: 2810:    ulg opt_lenb, static_lenb; /* opt_len and static_len in bytes */
        -: 2811:    int max_blindex;  /* index of last bit length code of non zero freq */
        -: 2812:
        1: 2813:    flag_buf[last_flags] = flags; /* Save the flags for the last 8 items */
        -: 2814:
        -: 2815:     /* Check if the file is ascii or binary */
       1*: 2816:    if (*file_type == (ush)UNKNOWN) set_file_type();
branch  0 taken 0 (fallthrough)
branch  1 taken 1
call    2 never executed
        -: 2817:
        -: 2818:    /* Construct the literal and distance trees */
        1: 2819:    build_tree((tree_desc near *)(&l_desc));
call    0 returned 1
        -: 2820:    Tracev((stderr, "\nlit data: dyn %lu, stat %lu", opt_len, static_len));
        -: 2821:
        1: 2822:    build_tree((tree_desc near *)(&d_desc));
call    0 returned 1
        -: 2823:    Tracev((stderr, "\ndist data: dyn %lu, stat %lu", opt_len, static_len));
        -: 2824:    /* At this point, opt_len and static_len are the total bit lengths of
        -: 2825:     * the compressed block data, excluding the tree representations.
        -: 2826:     */
        -: 2827:
        -: 2828:    /* Build the bit length tree for the above two trees, and get the index
        -: 2829:     * in bl_order of the last bit length code to send.
        -: 2830:     */
        1: 2831:    max_blindex = build_bl_tree();
call    0 returned 1
        -: 2832:
        -: 2833:    /* Determine the best encoding. Compute first the block length in bytes */
        1: 2834:    opt_lenb = (opt_len+3+7)>>3;
        1: 2835:    static_lenb = (static_len+3+7)>>3;
        1: 2836:    input_len += stored_len; /* for debugging only */
        -: 2837:
        -: 2838:    Trace((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u dist %u ",
        -: 2839:            opt_lenb, opt_len, static_lenb, static_len, stored_len,
        -: 2840:            last_lit, last_dist));
        -: 2841:
       1*: 2842:    if (static_lenb <= opt_lenb) opt_lenb = static_lenb;
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -: 2843:
        -: 2844:    /* If compression failed and this is the first and last block,
        -: 2845:     * and if the zip file can be seeked (to rewrite the local header),
        -: 2846:     * the whole file is transformed into a stored file:
        -: 2847:     */
        -: 2848:#ifdef FORCE_METHOD
        -: 2849:    if (level == 1 && eof && compressed_len == 0L) { /* force stored file */
        -: 2850:#else
        -: 2851:    if (stored_len <= opt_lenb && eof && compressed_len == 0L && seekable()) {
        -: 2852:#endif
        -: 2853:        /* Since LIT_BUFSIZE <= 2*WSIZE, the input data must be there: */
        -: 2854:        if (buf == (char*)0) error ("block vanished");
        -: 2855:
        -: 2856:        copy_block(buf, (unsigned)stored_len, 0); /* without header */
        -: 2857:        compressed_len = stored_len << 3;
        -: 2858:        *file_method = STORED;
        -: 2859:
        -: 2860:#ifdef FORCE_METHOD
        -: 2861:    } else if (level == 2 && buf != (char*)0) { /* force stored block */
        -: 2862:#else
       1*: 2863:    } else if (stored_len+4 <= opt_lenb && buf != (char*)0) {
branch  0 taken 0 (fallthrough)
branch  1 taken 1
branch  2 never executed
branch  3 never executed
        -: 2864:                       /* 4: two words for the lengths */
        -: 2865:#endif
        -: 2866:        /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
        -: 2867:         * Otherwise we can't have processed more than WSIZE input bytes since
        -: 2868:         * the last block flush, because compression would have been
        -: 2869:         * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
        -: 2870:         * transform a block into a stored block.
        -: 2871:         */
    #####: 2872:        send_bits((STORED_BLOCK<<1)+eof, 3);  /* send block type */
call    0 never executed
    #####: 2873:        compressed_len = (compressed_len + 3 + 7) & ~7L;
    #####: 2874:        compressed_len += (stored_len + 4) << 3;
        -: 2875:
    #####: 2876:        copy_block(buf, (unsigned)stored_len, 1); /* with header */
call    0 never executed
        -: 2877:
        -: 2878:#ifdef FORCE_METHOD
        -: 2879:    } else if (level == 3) { /* force static trees */
        -: 2880:#else
        1: 2881:    } else if (static_lenb == opt_lenb) {
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -: 2882:#endif
    #####: 2883:        send_bits((STATIC_TREES<<1)+eof, 3);
call    0 never executed
    #####: 2884:        compress_block((ct_data near *)static_ltree, (ct_data near *)static_dtree);
call    0 never executed
    #####: 2885:        compressed_len += 3 + static_len;
        -: 2886:    } else {
        1: 2887:        send_bits((DYN_TREES<<1)+eof, 3);
call    0 returned 1
        1: 2888:        send_all_trees(l_desc.max_code+1, d_desc.max_code+1, max_blindex+1);
call    0 returned 1
        1: 2889:        compress_block((ct_data near *)dyn_ltree, (ct_data near *)dyn_dtree);
call    0 returned 1
        1: 2890:        compressed_len += 3 + opt_len;
        -: 2891:    }
        -: 2892:    Assert (compressed_len == bits_sent, "bad compressed size");
        1: 2893:    init_block();
call    0 returned 1
        -: 2894:
        1: 2895:    if (eof) {
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -: 2896:        Assert (input_len == bytes_in, "bad input size");
        1: 2897:        bi_windup();
call    0 returned 1
        1: 2898:        compressed_len += 7;  /* align on byte boundary */
        -: 2899:    }
        -: 2900:
        1: 2901:    return compressed_len >> 3;
        -: 2902:}
        -: 2903:
        -: 2904:/* ===========================================================================
        -: 2905: * Save the match info and tally the frequency counts. Return true if
        -: 2906: * the current block must be flushed.
        -: 2907: */
function ct_tally called 6990 returned 100% blocks executed 86%
     6990: 2908:int ct_tally (dist, lc)
        -: 2909:    int dist;  /* distance of matched string */
        -: 2910:    int lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
        -: 2911:{
     6990: 2912:    l_buf[last_lit++] = (uch)lc;
     6990: 2913:    if (dist == 0) {
branch  0 taken 2271 (fallthrough)
branch  1 taken 4719
        -: 2914:        /* lc is the unmatched char */
     2271: 2915:        dyn_ltree[lc].Freq++;
        -: 2916:    } else {
        -: 2917:        /* Here, lc is the match length - MIN_MATCH */
     4719: 2918:        dist--;             /* dist = match distance - 1 */
        -: 2919:        Assert((ush)dist < (ush)MAX_DIST &&
        -: 2920:               (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
        -: 2921:               (ush)d_code(dist) < (ush)D_CODES,  "ct_tally: bad match");
        -: 2922:
     4719: 2923:        dyn_ltree[length_code[lc]+LITERALS+1].Freq++;
     4719: 2924:        dyn_dtree[d_code(dist)].Freq++;
branch  0 taken 1012 (fallthrough)
branch  1 taken 3707
        -: 2925:
     4719: 2926:        d_buf[last_dist++] = (ush)dist;
     4719: 2927:        flags |= flag_bit;
        -: 2928:    }
     6990: 2929:    flag_bit <<= 1;
        -: 2930:
        -: 2931:    /* Output the flags if they fill a byte: */
     6990: 2932:    if ((last_lit & 7) == 0) {
branch  0 taken 873 (fallthrough)
branch  1 taken 6117
      873: 2933:        flag_buf[last_flags++] = flags;
      873: 2934:        flags = 0, flag_bit = 1;
        -: 2935:    }
        -: 2936:    /* Try to guess if it is profitable to stop the current block here */
     6990: 2937:    if (level > 2 && (last_lit & 0xfff) == 0) {
branch  0 taken 6990 (fallthrough)
branch  1 taken 0
branch  2 taken 1 (fallthrough)
branch  3 taken 6989
        -: 2938:        /* Compute an upper bound for the compressed length */
        1: 2939:        ulg out_length = (ulg)last_lit*8L;
        1: 2940:        ulg in_length = (ulg)strstart-block_start;
        -: 2941:        int dcode;
       31: 2942:        for (dcode = 0; dcode < D_CODES; dcode++) {
branch  0 taken 30
branch  1 taken 1 (fallthrough)
       30: 2943:            out_length += (ulg)dyn_dtree[dcode].Freq*(5L+extra_dbits[dcode]);
        -: 2944:        }
        1: 2945:        out_length >>= 3;
        -: 2946:        Trace((stderr,"\nlast_lit %u, last_dist %u, in %ld, out ~%ld(%ld%%) ",
        -: 2947:               last_lit, last_dist, in_length, out_length,
        -: 2948:               100L - out_length*100L/in_length));
       1*: 2949:        if (last_dist < last_lit/2 && out_length < in_length/2) return 1;
branch  0 taken 0 (fallthrough)
branch  1 taken 1
branch  2 never executed
branch  3 never executed
        -: 2950:    }
    6990*: 2951:    return (last_lit == LIT_BUFSIZE-1 || last_dist == DIST_BUFSIZE);
branch  0 taken 6990 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 6990
        -: 2952:    /* We avoid equality with LIT_BUFSIZE because of wraparound at 64K
        -: 2953:     * on 16 bit machines and because stored blocks are restricted to
        -: 2954:     * 64K-1 bytes.
        -: 2955:     */
        -: 2956:}
        -: 2957:
        -: 2958:/* ===========================================================================
        -: 2959: * Send the block data compressed using the given Huffman trees
        -: 2960: */
function compress_block called 1 returned 100% blocks executed 100%
        1: 2961:local void compress_block(ltree, dtree)
        -: 2962:    ct_data near *ltree; /* literal tree */
        -: 2963:    ct_data near *dtree; /* distance tree */
        -: 2964:{
        -: 2965:    unsigned dist;      /* distance of matched string */
        -: 2966:    int lc;             /* match length or unmatched char (if dist == 0) */
        1: 2967:    unsigned lx = 0;    /* running index in l_buf */
        1: 2968:    unsigned dx = 0;    /* running index in d_buf */
        1: 2969:    unsigned fx = 0;    /* running index in flag_buf */
        1: 2970:    uch flag = 0;       /* current flags */
        -: 2971:    unsigned code;      /* the code to send */
        -: 2972:    int extra;          /* number of extra bits to send */
        -: 2973:
        1: 2974:    if (last_lit != 0) do {
branch  0 taken 1 (fallthrough)
branch  1 taken 0
     6990: 2975:        if ((lx & 7) == 0) flag = flag_buf[fx++];
branch  0 taken 874 (fallthrough)
branch  1 taken 6116
     6990: 2976:        lc = l_buf[lx++];
     6990: 2977:        if ((flag & 1) == 0) {
branch  0 taken 2271 (fallthrough)
branch  1 taken 4719
     2271: 2978:            send_code(lc, ltree); /* send a literal byte */
call    0 returned 2271
        -: 2979:            Tracecv(isgraph(lc), (stderr," '%c' ", lc));
        -: 2980:        } else {
        -: 2981:            /* Here, lc is the match length - MIN_MATCH */
     4719: 2982:            code = length_code[lc];
     4719: 2983:            send_code(code+LITERALS+1, ltree); /* send the length code */
call    0 returned 4719
     4719: 2984:            extra = extra_lbits[code];
     4719: 2985:            if (extra != 0) {
branch  0 taken 641 (fallthrough)
branch  1 taken 4078
      641: 2986:                lc -= base_length[code];
      641: 2987:                send_bits(lc, extra);        /* send the extra length bits */
call    0 returned 641
        -: 2988:            }
     4719: 2989:            dist = d_buf[dx++];
        -: 2990:            /* Here, dist is the match distance - 1 */
     4719: 2991:            code = d_code(dist);
branch  0 taken 1012 (fallthrough)
branch  1 taken 3707
        -: 2992:            Assert (code < D_CODES, "bad d_code");
        -: 2993:
     4719: 2994:            send_code(code, dtree);       /* send the distance code */
call    0 returned 4719
     4719: 2995:            extra = extra_dbits[code];
     4719: 2996:            if (extra != 0) {
branch  0 taken 4707 (fallthrough)
branch  1 taken 12
     4707: 2997:                dist -= base_dist[code];
     4707: 2998:                send_bits(dist, extra);   /* send the extra distance bits */
call    0 returned 4707
        -: 2999:            }
        -: 3000:        } /* literal or match pair ? */
     6990: 3001:        flag >>= 1;
     6990: 3002:    } while (lx < last_lit);
branch  0 taken 6989
branch  1 taken 1 (fallthrough)
        -: 3003:
        1: 3004:    send_code(END_BLOCK, ltree);
call    0 returned 1
        1: 3005:}
        -: 3006:
        -: 3007:/* ===========================================================================
        -: 3008: * Set the file type to ASCII or BINARY, using a crude approximation:
        -: 3009: * binary if more than 20% of the bytes are <= 6 or >= 128, ascii otherwise.
        -: 3010: * IN assertion: the fields freq of dyn_ltree are set and the total of all
        -: 3011: * frequencies does not exceed 64K (to fit in an int on 16 bit machines).
        -: 3012: */
function set_file_type called 0 returned 0% blocks executed 0%
    #####: 3013:local void set_file_type()
        -: 3014:{
    #####: 3015:    int n = 0;
    #####: 3016:    unsigned ascii_freq = 0;
    #####: 3017:    unsigned bin_freq = 0;
    #####: 3018:    while (n < 7)        bin_freq += dyn_ltree[n++].Freq;
branch  0 never executed
branch  1 never executed
    #####: 3019:    while (n < 128)    ascii_freq += dyn_ltree[n++].Freq;
branch  0 never executed
branch  1 never executed
    #####: 3020:    while (n < LITERALS) bin_freq += dyn_ltree[n++].Freq;
branch  0 never executed
branch  1 never executed
    #####: 3021:    *file_type = bin_freq > (ascii_freq >> 2) ? BINARY : ASCII;
        -: 3022:    if (*file_type == BINARY && translate_eol) {
        -: 3023:        warning ("-l used on binary file");
        -: 3024:    }
    #####: 3025:}
        -: 3026:/* unlzh.c -- decompress files in SCO compress -H (LZH) format.
        -: 3027: * The code in this file is directly derived from the public domain 'ar002'
        -: 3028: * written by Haruhiko Okumura.
        -: 3029: */
        -: 3030:
        -: 3031:#ifdef RCSID
        -: 3032:static char rcsid[] = "$Id: unlzh.c,v 1.2 1993/06/24 10:59:01 jloup Exp $";
        -: 3033:#endif
        -: 3034:
        -: 3035:/* decode.c */
        -: 3036:
        -: 3037:local unsigned  decode  OF((unsigned count, uch buffer[]));
        -: 3038:local void decode_start OF((void));
        -: 3039:
        -: 3040:/* huf.c */
        -: 3041:local void huf_decode_start OF((void));
        -: 3042:local unsigned decode_c     OF((void));
        -: 3043:local unsigned decode_p     OF((void));
        -: 3044:local void read_pt_len      OF((int nn, int nbit, int i_special));
        -: 3045:local void read_c_len       OF((void));
        -: 3046:
        -: 3047:/* io.c */
        -: 3048:local void fillbuf      OF((int n));
        -: 3049:local unsigned getbits  OF((int n));
        -: 3050:local void init_getbits OF((void));
        -: 3051:
        -: 3052:/* maketbl.c */
        -: 3053:
        -: 3054:local void make_table OF((int nchar, uch bitlen[],
        -: 3055:			  int tablebits, ush table[]));
        -: 3056:
        -: 3057:
        -: 3058:#define DICBIT    13    /* 12(-lh4-) or 13(-lh5-) */
        -: 3059:#define DICSIZ ((unsigned) 1 << DICBIT)
        -: 3060:
        -: 3061:#ifndef CHAR_BIT
        -: 3062:#  define CHAR_BIT 8
        -: 3063:#endif
        -: 3064:
        -: 3065:#ifndef UCHAR_MAX
        -: 3066:#  define UCHAR_MAX 255
        -: 3067:#endif
        -: 3068:
        -: 3069:#define BITBUFSIZ (CHAR_BIT * 2 * sizeof(char))
        -: 3070:/* Do not use CHAR_BIT * sizeof(bitbuf), does not work on machines
        -: 3071: * for which short is not on 16 bits (Cray).
        -: 3072: */
        -: 3073:
        -: 3074:/* encode.c and decode.c */
        -: 3075:
        -: 3076:#define MAXMATCH 256    /* formerly F (not more than UCHAR_MAX + 1) */
        -: 3077:#define THRESHOLD  3    /* choose optimal value */
        -: 3078:
        -: 3079:/* huf.c */
        -: 3080:
        -: 3081:#define NC (UCHAR_MAX + MAXMATCH + 2 - THRESHOLD)
        -: 3082:	/* alphabet = {0, 1, 2, ..., NC - 1} */
        -: 3083:#define CBIT 9  /* $\lfloor \log_2 NC \rfloor + 1$ */
        -: 3084:#define CODE_BIT  16  /* codeword length */
        -: 3085:
        -: 3086:#define NP (DICBIT + 1)
        -: 3087:#define NT (CODE_BIT + 3)
        -: 3088:#define PBIT 4  /* smallest integer such that (1U << PBIT) > NP */
        -: 3089:#define TBIT 5  /* smallest integer such that (1U << TBIT) > NT */
        -: 3090:#if NT > NP
        -: 3091:# define NPT NT
        -: 3092:#else
        -: 3093:# define NPT NP
        -: 3094:#endif
        -: 3095:
        -: 3096:/* local ush left[2 * NC - 1]; */
        -: 3097:/* local ush right[2 * NC - 1]; */
        -: 3098:#define left  prev
        -: 3099:#define right head
        -: 3100:#if NC > (1<<(BITS-2))
        -: 3101:    error cannot overlay left+right and prev
        -: 3102:#endif
        -: 3103:
        -: 3104:/* local uch c_len[NC]; */
        -: 3105:#define c_len outbuf
        -: 3106:#if NC > OUTBUFSIZ
        -: 3107:    error cannot overlay c_len and outbuf
        -: 3108:#endif
        -: 3109:
        -: 3110:local uch pt_len[NPT];
        -: 3111:local unsigned blocksize;
        -: 3112:local ush pt_table[256];
        -: 3113:
        -: 3114:/* local ush c_table[4096]; */
        -: 3115:#define c_table d_buf
        -: 3116:#if (DIST_BUFSIZE-1) < 4095
        -: 3117:    error cannot overlay c_table and d_buf
        -: 3118:#endif
        -: 3119:
        -: 3120:/***********************************************************
        -: 3121:        io.c -- input/output
        -: 3122:***********************************************************/
        -: 3123:
        -: 3124:local ush       bitbuf;
        -: 3125:local unsigned  subbitbuf;
        -: 3126:local int       bitcount;
        -: 3127:
function fillbuf called 0 returned 0% blocks executed 0%
    #####: 3128:local void fillbuf(n)  /* Shift bitbuf n bits left, read n bits */
        -: 3129:    int n;
        -: 3130:{
    #####: 3131:    bitbuf <<= n;
    #####: 3132:    while (n > bitcount) {
branch  0 never executed
branch  1 never executed
    #####: 3133:	bitbuf |= subbitbuf << (n -= bitcount);
    #####: 3134:	subbitbuf = (unsigned)try_byte();
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 3135:	if ((int)subbitbuf == EOF) subbitbuf = 0;
branch  0 never executed
branch  1 never executed
    #####: 3136:	bitcount = CHAR_BIT;
        -: 3137:    }
    #####: 3138:    bitbuf |= subbitbuf >> (bitcount -= n);
    #####: 3139:}
        -: 3140:
function getbits called 0 returned 0% blocks executed 0%
    #####: 3141:local unsigned getbits(n)
        -: 3142:    int n;
        -: 3143:{
        -: 3144:    unsigned x;
        -: 3145:
    #####: 3146:    x = bitbuf >> (BITBUFSIZ - n);  fillbuf(n);
call    0 never executed
    #####: 3147:    return x;
        -: 3148:}
        -: 3149:
function init_getbits called 0 returned 0% blocks executed 0%
    #####: 3150:local void init_getbits()
        -: 3151:{
    #####: 3152:    bitbuf = 0;  subbitbuf = 0;  bitcount = 0;
    #####: 3153:    fillbuf(BITBUFSIZ);
call    0 never executed
    #####: 3154:}
        -: 3155:
        -: 3156:/***********************************************************
        -: 3157:	maketbl.c -- make table for decoding
        -: 3158:***********************************************************/
        -: 3159:
function make_table called 0 returned 0% blocks executed 0%
    #####: 3160:local void make_table(nchar, bitlen, tablebits, table)
        -: 3161:    int nchar;
        -: 3162:    uch bitlen[];
        -: 3163:    int tablebits;
        -: 3164:    ush table[];
        -: 3165:{
        -: 3166:    ush count[17], weight[17], start[18], *p;
        -: 3167:    unsigned i, k, len, ch, jutbits, avail, nextcode, mask;
        -: 3168:
    #####: 3169:    for (i = 1; i <= 16; i++) count[i] = 0;
branch  0 never executed
branch  1 never executed
    #####: 3170:    for (i = 0; i < (unsigned)nchar; i++) count[bitlen[i]]++;
branch  0 never executed
branch  1 never executed
        -: 3171:
    #####: 3172:    start[1] = 0;
    #####: 3173:    for (i = 1; i <= 16; i++)
branch  0 never executed
branch  1 never executed
    #####: 3174:	start[i + 1] = start[i] + (count[i] << (16 - i));
    #####: 3175:    if ((start[17] & 0xffff) != 0)
branch  0 never executed
branch  1 never executed
    #####: 3176:	error("Bad table\n");
call    0 never executed
        -: 3177:
    #####: 3178:    jutbits = 16 - tablebits;
    #####: 3179:    for (i = 1; i <= (unsigned)tablebits; i++) {
branch  0 never executed
branch  1 never executed
    #####: 3180:	start[i] >>= jutbits;
    #####: 3181:	weight[i] = (unsigned) 1 << (tablebits - i);
        -: 3182:    }
    #####: 3183:    while (i <= 16) {
branch  0 never executed
branch  1 never executed
    #####: 3184:	weight[i] = (unsigned) 1 << (16 - i);
    #####: 3185:	i++;
        -: 3186:    }
        -: 3187:
    #####: 3188:    i = start[tablebits + 1] >> jutbits;
    #####: 3189:    if (i != 0) {
branch  0 never executed
branch  1 never executed
    #####: 3190:	k = 1 << tablebits;
    #####: 3191:	while (i != k) table[i++] = 0;
branch  0 never executed
branch  1 never executed
        -: 3192:    }
        -: 3193:
    #####: 3194:    avail = nchar;
    #####: 3195:    mask = (unsigned) 1 << (15 - tablebits);
    #####: 3196:    for (ch = 0; ch < (unsigned)nchar; ch++) {
branch  0 never executed
branch  1 never executed
    #####: 3197:	if ((len = bitlen[ch]) == 0) continue;
branch  0 never executed
branch  1 never executed
    #####: 3198:	nextcode = start[len] + weight[len];
    #####: 3199:	if (len <= (unsigned)tablebits) {
branch  0 never executed
branch  1 never executed
    #####: 3200:	    for (i = start[len]; i < nextcode; i++) table[i] = ch;
branch  0 never executed
branch  1 never executed
        -: 3201:	} else {
    #####: 3202:	    k = start[len];
    #####: 3203:	    p = &table[k >> jutbits];
    #####: 3204:	    i = len - tablebits;
    #####: 3205:	    while (i != 0) {
branch  0 never executed
branch  1 never executed
    #####: 3206:		if (*p == 0) {
branch  0 never executed
branch  1 never executed
    #####: 3207:		    right[avail] = left[avail] = 0;
    #####: 3208:		    *p = avail++;
        -: 3209:		}
    #####: 3210:		if (k & mask) p = &right[*p];
branch  0 never executed
branch  1 never executed
    #####: 3211:		else          p = &left[*p];
    #####: 3212:		k <<= 1;  i--;
        -: 3213:	    }
    #####: 3214:	    *p = ch;
        -: 3215:	}
    #####: 3216:	start[len] = nextcode;
        -: 3217:    }
    #####: 3218:}
        -: 3219:
        -: 3220:/***********************************************************
        -: 3221:        huf.c -- static Huffman
        -: 3222:***********************************************************/
        -: 3223:
function read_pt_len called 0 returned 0% blocks executed 0%
    #####: 3224:local void read_pt_len(nn, nbit, i_special)
        -: 3225:    int nn;
        -: 3226:    int nbit;
        -: 3227:    int i_special;
        -: 3228:{
        -: 3229:    int i, c, n;
        -: 3230:    unsigned mask;
        -: 3231:
    #####: 3232:    n = getbits(nbit);
call    0 never executed
    #####: 3233:    if (n == 0) {
branch  0 never executed
branch  1 never executed
    #####: 3234:	c = getbits(nbit);
call    0 never executed
    #####: 3235:	for (i = 0; i < nn; i++) pt_len[i] = 0;
branch  0 never executed
branch  1 never executed
    #####: 3236:	for (i = 0; i < 256; i++) pt_table[i] = c;
branch  0 never executed
branch  1 never executed
        -: 3237:    } else {
    #####: 3238:	i = 0;
    #####: 3239:	while (i < n) {
branch  0 never executed
branch  1 never executed
    #####: 3240:	    c = bitbuf >> (BITBUFSIZ - 3);
    #####: 3241:	    if (c == 7) {
branch  0 never executed
branch  1 never executed
    #####: 3242:		mask = (unsigned) 1 << (BITBUFSIZ - 1 - 3);
    #####: 3243:		while (mask & bitbuf) {  mask >>= 1;  c++;  }
branch  0 never executed
branch  1 never executed
        -: 3244:	    }
    #####: 3245:	    fillbuf((c < 7) ? 3 : c - 3);
call    0 never executed
    #####: 3246:	    pt_len[i++] = c;
    #####: 3247:	    if (i == i_special) {
branch  0 never executed
branch  1 never executed
    #####: 3248:		c = getbits(2);
call    0 never executed
    #####: 3249:		while (--c >= 0) pt_len[i++] = 0;
branch  0 never executed
branch  1 never executed
        -: 3250:	    }
        -: 3251:	}
    #####: 3252:	while (i < nn) pt_len[i++] = 0;
branch  0 never executed
branch  1 never executed
    #####: 3253:	make_table(nn, pt_len, 8, pt_table);
call    0 never executed
        -: 3254:    }
    #####: 3255:}
        -: 3256:
function read_c_len called 0 returned 0% blocks executed 0%
    #####: 3257:local void read_c_len()
        -: 3258:{
        -: 3259:    int i, c, n;
        -: 3260:    unsigned mask;
        -: 3261:
    #####: 3262:    n = getbits(CBIT);
call    0 never executed
    #####: 3263:    if (n == 0) {
branch  0 never executed
branch  1 never executed
    #####: 3264:	c = getbits(CBIT);
call    0 never executed
    #####: 3265:	for (i = 0; i < NC; i++) c_len[i] = 0;
branch  0 never executed
branch  1 never executed
    #####: 3266:	for (i = 0; i < 4096; i++) c_table[i] = c;
branch  0 never executed
branch  1 never executed
        -: 3267:    } else {
    #####: 3268:	i = 0;
    #####: 3269:	while (i < n) {
branch  0 never executed
branch  1 never executed
    #####: 3270:	    c = pt_table[bitbuf >> (BITBUFSIZ - 8)];
    #####: 3271:	    if (c >= NT) {
branch  0 never executed
branch  1 never executed
    #####: 3272:		mask = (unsigned) 1 << (BITBUFSIZ - 1 - 8);
        -: 3273:		do {
    #####: 3274:		    if (bitbuf & mask) c = right[c];
branch  0 never executed
branch  1 never executed
    #####: 3275:		    else               c = left [c];
    #####: 3276:		    mask >>= 1;
    #####: 3277:		} while (c >= NT);
branch  0 never executed
branch  1 never executed
        -: 3278:	    }
    #####: 3279:	    fillbuf((int) pt_len[c]);
call    0 never executed
    #####: 3280:	    if (c <= 2) {
branch  0 never executed
branch  1 never executed
    #####: 3281:		if      (c == 0) c = 1;
branch  0 never executed
branch  1 never executed
    #####: 3282:		else if (c == 1) c = getbits(4) + 3;
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 3283:		else             c = getbits(CBIT) + 20;
call    0 never executed
    #####: 3284:		while (--c >= 0) c_len[i++] = 0;
branch  0 never executed
branch  1 never executed
    #####: 3285:	    } else c_len[i++] = c - 2;
        -: 3286:	}
    #####: 3287:	while (i < NC) c_len[i++] = 0;
branch  0 never executed
branch  1 never executed
    #####: 3288:	make_table(NC, c_len, 12, c_table);
call    0 never executed
        -: 3289:    }
    #####: 3290:}
        -: 3291:
function decode_c called 0 returned 0% blocks executed 0%
    #####: 3292:local unsigned decode_c()
        -: 3293:{
        -: 3294:    unsigned j, mask;
        -: 3295:
    #####: 3296:    if (blocksize == 0) {
branch  0 never executed
branch  1 never executed
    #####: 3297:	blocksize = getbits(16);
call    0 never executed
    #####: 3298:	if (blocksize == 0) {
branch  0 never executed
branch  1 never executed
    #####: 3299:	    return NC; /* end of file */
        -: 3300:	}
    #####: 3301:	read_pt_len(NT, TBIT, 3);
call    0 never executed
    #####: 3302:	read_c_len();
call    0 never executed
    #####: 3303:	read_pt_len(NP, PBIT, -1);
call    0 never executed
        -: 3304:    }
    #####: 3305:    blocksize--;
    #####: 3306:    j = c_table[bitbuf >> (BITBUFSIZ - 12)];
    #####: 3307:    if (j >= NC) {
branch  0 never executed
branch  1 never executed
    #####: 3308:	mask = (unsigned) 1 << (BITBUFSIZ - 1 - 12);
        -: 3309:	do {
    #####: 3310:	    if (bitbuf & mask) j = right[j];
branch  0 never executed
branch  1 never executed
    #####: 3311:	    else               j = left [j];
    #####: 3312:	    mask >>= 1;
    #####: 3313:	} while (j >= NC);
branch  0 never executed
branch  1 never executed
        -: 3314:    }
    #####: 3315:    fillbuf((int) c_len[j]);
call    0 never executed
    #####: 3316:    return j;
        -: 3317:}
        -: 3318:
function decode_p called 0 returned 0% blocks executed 0%
    #####: 3319:local unsigned decode_p()
        -: 3320:{
        -: 3321:    unsigned j, mask;
        -: 3322:
    #####: 3323:    j = pt_table[bitbuf >> (BITBUFSIZ - 8)];
    #####: 3324:    if (j >= NP) {
branch  0 never executed
branch  1 never executed
    #####: 3325:	mask = (unsigned) 1 << (BITBUFSIZ - 1 - 8);
        -: 3326:	do {
    #####: 3327:	    if (bitbuf & mask) j = right[j];
branch  0 never executed
branch  1 never executed
    #####: 3328:	    else               j = left [j];
    #####: 3329:	    mask >>= 1;
    #####: 3330:	} while (j >= NP);
branch  0 never executed
branch  1 never executed
        -: 3331:    }
    #####: 3332:    fillbuf((int) pt_len[j]);
call    0 never executed
    #####: 3333:    if (j != 0) j = ((unsigned) 1 << (j - 1)) + getbits((int) (j - 1));
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 3334:    return j;
        -: 3335:}
        -: 3336:
function huf_decode_start called 0 returned 0% blocks executed 0%
    #####: 3337:local void huf_decode_start()
        -: 3338:{
    #####: 3339:    init_getbits();  blocksize = 0;
call    0 never executed
    #####: 3340:}
        -: 3341:
        -: 3342:/***********************************************************
        -: 3343:        decode.c
        -: 3344:***********************************************************/
        -: 3345:
        -: 3346:local int j;    /* remaining bytes to copy */
        -: 3347:local int done; /* set at end of input */
        -: 3348:
function decode_start called 0 returned 0% blocks executed 0%
    #####: 3349:local void decode_start()
        -: 3350:{
    #####: 3351:    huf_decode_start();
call    0 never executed
    #####: 3352:    j = 0;
    #####: 3353:    done = 0;
    #####: 3354:}
        -: 3355:
        -: 3356:/* Decode the input and return the number of decoded bytes put in buffer
        -: 3357: */
function decode called 0 returned 0% blocks executed 0%
    #####: 3358:local unsigned decode(count, buffer)
        -: 3359:    unsigned count;
        -: 3360:    uch buffer[];
        -: 3361:    /* The calling function must keep the number of
        -: 3362:       bytes to be processed.  This function decodes
        -: 3363:       either 'count' bytes or 'DICSIZ' bytes, whichever
        -: 3364:       is smaller, into the array 'buffer[]' of size
        -: 3365:       'DICSIZ' or more.
        -: 3366:       Call decode_start() once for each new file
        -: 3367:       before calling this function.
        -: 3368:     */
        -: 3369:{
        -: 3370:    local unsigned i;
        -: 3371:    unsigned r, c;
        -: 3372:
    #####: 3373:    r = 0;
    #####: 3374:    while (--j >= 0) {
branch  0 never executed
branch  1 never executed
    #####: 3375:	buffer[r] = buffer[i];
    #####: 3376:	i = (i + 1) & (DICSIZ - 1);
    #####: 3377:	if (++r == count) return r;
branch  0 never executed
branch  1 never executed
        -: 3378:    }
        -: 3379:    for ( ; ; ) {
    #####: 3380:	c = decode_c();
call    0 never executed
    #####: 3381:	if (c == NC) {
branch  0 never executed
branch  1 never executed
    #####: 3382:	    done = 1;
    #####: 3383:	    return r;
        -: 3384:	}
    #####: 3385:	if (c <= UCHAR_MAX) {
branch  0 never executed
branch  1 never executed
    #####: 3386:	    buffer[r] = c;
    #####: 3387:	    if (++r == count) return r;
branch  0 never executed
branch  1 never executed
        -: 3388:	} else {
    #####: 3389:	    j = c - (UCHAR_MAX + 1 - THRESHOLD);
    #####: 3390:	    i = (r - decode_p() - 1) & (DICSIZ - 1);
call    0 never executed
    #####: 3391:	    while (--j >= 0) {
branch  0 never executed
branch  1 never executed
    #####: 3392:		buffer[r] = buffer[i];
    #####: 3393:		i = (i + 1) & (DICSIZ - 1);
    #####: 3394:		if (++r == count) return r;
branch  0 never executed
branch  1 never executed
        -: 3395:	    }
        -: 3396:	}
        -: 3397:    }
        -: 3398:}
        -: 3399:
        -: 3400:
        -: 3401:/* ===========================================================================
        -: 3402: * Unlzh in to out. Return OK or ERROR.
        -: 3403: */
function unlzh called 0 returned 0% blocks executed 0%
    #####: 3404:int unlzh(in, out)
        -: 3405:    int in;
        -: 3406:    int out;
        -: 3407:{
        -: 3408:    unsigned n;
    #####: 3409:    ifd = in;
    #####: 3410:    ofd = out;
        -: 3411:
    #####: 3412:    decode_start();
call    0 never executed
    #####: 3413:    while (!done) {
branch  0 never executed
branch  1 never executed
    #####: 3414:	n = decode((unsigned) DICSIZ, window);
call    0 never executed
    #####: 3415:	if (!test && n > 0) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3416:	    write_buf(out, (char*)window, n);
call    0 never executed
        -: 3417:	}
        -: 3418:    }
    #####: 3419:    return OK;
        -: 3420:}
        -: 3421:/* unlzw.c -- decompress files in LZW format.
        -: 3422: * The code in this file is directly derived from the public domain 'compress'
        -: 3423: * written by Spencer Thomas, Joe Orost, James Woods, Jim McKie, Steve Davies,
        -: 3424: * Ken Turkowski, Dave Mack and Peter Jannesen.
        -: 3425: *
        -: 3426: * This is a temporary version which will be rewritten in some future version
        -: 3427: * to accommodate in-memory decompression.
        -: 3428: */
        -: 3429:
        -: 3430:#ifdef RCSID
        -: 3431:static char rcsid[] = "$Id: unlzw.c,v 0.15 1993/06/10 13:28:35 jloup Exp $";
        -: 3432:#endif
        -: 3433:
        -: 3434:#ifdef HAVE_UNISTD_H
        -: 3435:#  include <unistd.h>
        -: 3436:#endif
        -: 3437:#ifdef HAVE_FCNTL_H
        -: 3438:#  include <fcntl.h>
        -: 3439:#endif
        -: 3440:
        -: 3441:typedef	unsigned char	char_type;
        -: 3442:typedef          long   code_int;
        -: 3443:typedef unsigned long 	count_int;
        -: 3444:typedef unsigned short	count_short;
        -: 3445:typedef unsigned long 	cmp_code_int;
        -: 3446:
        -: 3447:#define MAXCODE(n)	(1L << (n))
        -: 3448:    
        -: 3449:#ifndef	REGISTERS
        -: 3450:#	define	REGISTERS	2
        -: 3451:#endif
        -: 3452:#define	REG1	
        -: 3453:#define	REG2	
        -: 3454:#define	REG3	
        -: 3455:#define	REG4	
        -: 3456:#define	REG5	
        -: 3457:#define	REG6	
        -: 3458:#define	REG7	
        -: 3459:#define	REG8	
        -: 3460:#define	REG9	
        -: 3461:#define	REG10
        -: 3462:#define	REG11	
        -: 3463:#define	REG12	
        -: 3464:#define	REG13
        -: 3465:#define	REG14
        -: 3466:#define	REG15
        -: 3467:#define	REG16
        -: 3468:#if REGISTERS >= 1
        -: 3469:#	undef	REG1
        -: 3470:#	define	REG1	register
        -: 3471:#endif
        -: 3472:#if REGISTERS >= 2
        -: 3473:#	undef	REG2
        -: 3474:#	define	REG2	register
        -: 3475:#endif
        -: 3476:#if REGISTERS >= 3
        -: 3477:#	undef	REG3
        -: 3478:#	define	REG3	register
        -: 3479:#endif
        -: 3480:#if REGISTERS >= 4
        -: 3481:#	undef	REG4
        -: 3482:#	define	REG4	register
        -: 3483:#endif
        -: 3484:#if REGISTERS >= 5
        -: 3485:#	undef	REG5
        -: 3486:#	define	REG5	register
        -: 3487:#endif
        -: 3488:#if REGISTERS >= 6
        -: 3489:#	undef	REG6
        -: 3490:#	define	REG6	register
        -: 3491:#endif
        -: 3492:#if REGISTERS >= 7
        -: 3493:#	undef	REG7
        -: 3494:#	define	REG7	register
        -: 3495:#endif
        -: 3496:#if REGISTERS >= 8
        -: 3497:#	undef	REG8
        -: 3498:#	define	REG8	register
        -: 3499:#endif
        -: 3500:#if REGISTERS >= 9
        -: 3501:#	undef	REG9
        -: 3502:#	define	REG9	register
        -: 3503:#endif
        -: 3504:#if REGISTERS >= 10
        -: 3505:#	undef	REG10
        -: 3506:#	define	REG10	register
        -: 3507:#endif
        -: 3508:#if REGISTERS >= 11
        -: 3509:#	undef	REG11
        -: 3510:#	define	REG11	register
        -: 3511:#endif
        -: 3512:#if REGISTERS >= 12
        -: 3513:#	undef	REG12
        -: 3514:#	define	REG12	register
        -: 3515:#endif
        -: 3516:#if REGISTERS >= 13
        -: 3517:#	undef	REG13
        -: 3518:#	define	REG13	register
        -: 3519:#endif
        -: 3520:#if REGISTERS >= 14
        -: 3521:#	undef	REG14
        -: 3522:#	define	REG14	register
        -: 3523:#endif
        -: 3524:#if REGISTERS >= 15
        -: 3525:#	undef	REG15
        -: 3526:#	define	REG15	register
        -: 3527:#endif
        -: 3528:#if REGISTERS >= 16
        -: 3529:#	undef	REG16
        -: 3530:#	define	REG16	register
        -: 3531:#endif
        -: 3532:    
        -: 3533:#ifndef	BYTEORDER
        -: 3534:#	define	BYTEORDER	0000
        -: 3535:#endif
        -: 3536:	
        -: 3537:#ifndef	NOALLIGN
        -: 3538:#	define	NOALLIGN	0
        -: 3539:#endif
        -: 3540:
        -: 3541:
        -: 3542:union	bytes {
        -: 3543:    long  word;
        -: 3544:    struct {
        -: 3545:#if BYTEORDER == 4321
        -: 3546:	char_type	b1;
        -: 3547:	char_type	b2;
        -: 3548:	char_type	b3;
        -: 3549:	char_type	b4;
        -: 3550:#else
        -: 3551:#if BYTEORDER == 1234
        -: 3552:	char_type	b4;
        -: 3553:	char_type	b3;
        -: 3554:	char_type	b2;
        -: 3555:	char_type	b1;
        -: 3556:#else
        -: 3557:#	undef	BYTEORDER
        -: 3558:	int  dummy;
        -: 3559:#endif
        -: 3560:#endif
        -: 3561:    } bytes;
        -: 3562:};
        -: 3563:
        -: 3564:#if BYTEORDER == 4321 && NOALLIGN == 1
        -: 3565:#  define input(b,o,c,n,m){ \
        -: 3566:     (c) = (*(long *)(&(b)[(o)>>3])>>((o)&0x7))&(m); \
        -: 3567:     (o) += (n); \
        -: 3568:   }
        -: 3569:#else
        -: 3570:#  define input(b,o,c,n,m){ \
        -: 3571:     REG1 char_type *p = &(b)[(o)>>3]; \
        -: 3572:     (c) = ((((long)(p[0]))|((long)(p[1])<<8)| \
        -: 3573:     ((long)(p[2])<<16))>>((o)&0x7))&(m); \
        -: 3574:     (o) += (n); \
        -: 3575:   }
        -: 3576:#endif
        -: 3577:
        -: 3578:#ifndef MAXSEG_64K
        -: 3579:   /* DECLARE(ush, tab_prefix, (1<<BITS)); -- prefix code */
        -: 3580:#  define tab_prefixof(i) tab_prefix[i]
        -: 3581:#  define clear_tab_prefixof()	memzero(tab_prefix, 256);
        -: 3582:#else
        -: 3583:   /* DECLARE(ush, tab_prefix0, (1<<(BITS-1)); -- prefix for even codes */
        -: 3584:   /* DECLARE(ush, tab_prefix1, (1<<(BITS-1)); -- prefix for odd  codes */
        -: 3585:   ush *tab_prefix[2];
        -: 3586:#  define tab_prefixof(i) tab_prefix[(i)&1][(i)>>1]
        -: 3587:#  define clear_tab_prefixof()	\
        -: 3588:      memzero(tab_prefix0, 128), \
        -: 3589:      memzero(tab_prefix1, 128);
        -: 3590:#endif
        -: 3591:#define de_stack        ((char_type *)(&d_buf[DIST_BUFSIZE-1]))
        -: 3592:#define tab_suffixof(i) tab_suffix[i]
        -: 3593:
        -: 3594:int block_mode = BLOCK_MODE; /* block compress mode -C compatible with 2.0 */
        -: 3595:
        -: 3596:/* ============================================================================
        -: 3597: * Decompress in to out.  This routine adapts to the codes in the
        -: 3598: * file building the "string" table on-the-fly; requiring no table to
        -: 3599: * be stored in the compressed file.
        -: 3600: * IN assertions: the buffer inbuf contains already the beginning of
        -: 3601: *   the compressed data, from offsets iptr to insize-1 included.
        -: 3602: *   The magic header has already been checked and skipped.
        -: 3603: *   bytes_in and bytes_out have been initialized.
        -: 3604: */
function unlzw called 0 returned 0% blocks executed 0%
    #####: 3605:int unlzw(in, out) 
        -: 3606:    int in, out;    /* input and output file descriptors */
        -: 3607:{
        -: 3608:    REG2   char_type  *stackp;
        -: 3609:    REG3   code_int   code;
        -: 3610:    REG4   int        finchar;
        -: 3611:    REG5   code_int   oldcode;
        -: 3612:    REG6   code_int   incode;
        -: 3613:    REG7   long       inbits;
        -: 3614:    REG8   long       posbits;
        -: 3615:    REG9   int        outpos;
        -: 3616:/*  REG10  int        insize; (global) */
        -: 3617:    REG11  unsigned   bitmask;
        -: 3618:    REG12  code_int   free_ent;
        -: 3619:    REG13  code_int   maxcode;
        -: 3620:    REG14  code_int   maxmaxcode;
        -: 3621:    REG15  int        n_bits;
        -: 3622:    REG16  int        rsize;
        -: 3623:    
        -: 3624:#ifdef MAXSEG_64K
        -: 3625:    tab_prefix[0] = tab_prefix0;
        -: 3626:    tab_prefix[1] = tab_prefix1;
        -: 3627:#endif
    #####: 3628:    maxbits = get_byte();
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 3629:    block_mode = maxbits & BLOCK_MODE;
    #####: 3630:    if ((maxbits & LZW_RESERVED) != 0) {
branch  0 never executed
branch  1 never executed
    #####: 3631:	WARN((stderr, "\n%s: %s: warning, unknown flags 0x%x\n",
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 3632:	      progname, ifname, maxbits & LZW_RESERVED));
        -: 3633:    }
    #####: 3634:    maxbits &= BIT_MASK;
    #####: 3635:    maxmaxcode = MAXCODE(maxbits);
        -: 3636:    
    #####: 3637:    if (maxbits > BITS) {
branch  0 never executed
branch  1 never executed
    #####: 3638:	fprintf(stderr,
call    0 never executed
        -: 3639:		"\n%s: %s: compressed with %d bits, can only handle %d bits\n",
        -: 3640:		progname, ifname, maxbits, BITS);
    #####: 3641:	exit_code = ERROR;
    #####: 3642:	return ERROR;
        -: 3643:    }
    #####: 3644:    rsize = insize;
    #####: 3645:    maxcode = MAXCODE(n_bits = INIT_BITS)-1;
    #####: 3646:    bitmask = (1<<n_bits)-1;
    #####: 3647:    oldcode = -1;
    #####: 3648:    finchar = 0;
    #####: 3649:    outpos = 0;
    #####: 3650:    posbits = inptr<<3;
        -: 3651:
    #####: 3652:    free_ent = ((block_mode) ? FIRST : 256);
branch  0 never executed
branch  1 never executed
        -: 3653:    
    #####: 3654:    clear_tab_prefixof(); /* Initialize the first 256 entries in the table. */
        -: 3655:    
    #####: 3656:    for (code = 255 ; code >= 0 ; --code) {
branch  0 never executed
branch  1 never executed
    #####: 3657:	tab_suffixof(code) = (char_type)code;
        -: 3658:    }
        -: 3659:    do {
        -: 3660:	REG1 int i;
        -: 3661:	int  e;
        -: 3662:	int  o;
        -: 3663:	
    #####: 3664:    resetbuf:
    #####: 3665:	e = insize-(o = (posbits>>3));
        -: 3666:	
    #####: 3667:	for (i = 0 ; i < e ; ++i) {
branch  0 never executed
branch  1 never executed
    #####: 3668:	    inbuf[i] = inbuf[i+o];
        -: 3669:	}
    #####: 3670:	insize = e;
    #####: 3671:	posbits = 0;
        -: 3672:	
    #####: 3673:	if (insize < INBUF_EXTRA) {
branch  0 never executed
branch  1 never executed
    #####: 3674:	    if ((rsize = read(in, (char*)inbuf+insize, INBUFSIZ)) == -1) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3675:		read_error();
call    0 never executed
        -: 3676:	    }
    #####: 3677:	    insize += rsize;
    #####: 3678:	    bytes_in += (off_t)rsize;
        -: 3679:	}
    #####: 3680:	inbits = ((rsize != 0) ? ((long)insize - insize%n_bits)<<3 : 
branch  0 never executed
branch  1 never executed
    #####: 3681:		  ((long)insize<<3)-(n_bits-1));
        -: 3682:	
    #####: 3683:	while (inbits > posbits) {
branch  0 never executed
branch  1 never executed
    #####: 3684:	    if (free_ent > maxcode) {
branch  0 never executed
branch  1 never executed
    #####: 3685:		posbits = ((posbits-1) +
    #####: 3686:			   ((n_bits<<3)-(posbits-1+(n_bits<<3))%(n_bits<<3)));
    #####: 3687:		++n_bits;
    #####: 3688:		if (n_bits == maxbits) {
branch  0 never executed
branch  1 never executed
    #####: 3689:		    maxcode = maxmaxcode;
        -: 3690:		} else {
    #####: 3691:		    maxcode = MAXCODE(n_bits)-1;
        -: 3692:		}
    #####: 3693:		bitmask = (1<<n_bits)-1;
    #####: 3694:		goto resetbuf;
        -: 3695:	    }
    #####: 3696:	    input(inbuf,posbits,code,n_bits,bitmask);
        -: 3697:	    Tracev((stderr, "%d ", code));
        -: 3698:
    #####: 3699:	    if (oldcode == -1) {
branch  0 never executed
branch  1 never executed
    #####: 3700:		if (code >= 256) error("corrupt input.");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 3701:		outbuf[outpos++] = (char_type)(finchar = (int)(oldcode=code));
    #####: 3702:		continue;
        -: 3703:	    }
    #####: 3704:	    if (code == CLEAR && block_mode) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3705:		clear_tab_prefixof();
    #####: 3706:		free_ent = FIRST - 1;
    #####: 3707:		posbits = ((posbits-1) +
    #####: 3708:			   ((n_bits<<3)-(posbits-1+(n_bits<<3))%(n_bits<<3)));
    #####: 3709:		maxcode = MAXCODE(n_bits = INIT_BITS)-1;
    #####: 3710:		bitmask = (1<<n_bits)-1;
    #####: 3711:		goto resetbuf;
        -: 3712:	    }
    #####: 3713:	    incode = code;
    #####: 3714:	    stackp = de_stack;
        -: 3715:	    
    #####: 3716:	    if (code >= free_ent) { /* Special case for KwKwK string. */
branch  0 never executed
branch  1 never executed
    #####: 3717:		if (code > free_ent) {
branch  0 never executed
branch  1 never executed
        -: 3718:#ifdef DEBUG		    
        -: 3719:		    char_type *p;
        -: 3720:
        -: 3721:		    posbits -= n_bits;
        -: 3722:		    p = &inbuf[posbits>>3];
        -: 3723:		    fprintf(stderr,
        -: 3724:			    "code:%ld free_ent:%ld n_bits:%d insize:%u\n",
        -: 3725:			    code, free_ent, n_bits, insize);
        -: 3726:		    fprintf(stderr,
        -: 3727:			    "posbits:%ld inbuf:%02X %02X %02X %02X %02X\n",
        -: 3728:			    posbits, p[-1],p[0],p[1],p[2],p[3]);
        -: 3729:#endif
    #####: 3730:		    if (!test && outpos > 0) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3731:			write_buf(out, (char*)outbuf, outpos);
call    0 never executed
    #####: 3732:			bytes_out += (off_t)outpos;
        -: 3733:		    }
    #####: 3734:		    error(to_stdout ? "corrupt input." :
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 3735:			  "corrupt input. Use zcat to recover some data.");
        -: 3736:		}
    #####: 3737:		*--stackp = (char_type)finchar;
    #####: 3738:		code = oldcode;
        -: 3739:	    }
        -: 3740:
    #####: 3741:	    while ((cmp_code_int)code >= (cmp_code_int)256) {
branch  0 never executed
branch  1 never executed
        -: 3742:		/* Generate output characters in reverse order */
    #####: 3743:		*--stackp = tab_suffixof(code);
    #####: 3744:		code = tab_prefixof(code);
        -: 3745:	    }
    #####: 3746:	    *--stackp =	(char_type)(finchar = tab_suffixof(code));
        -: 3747:	    
        -: 3748:	    /* And put them out in forward order */
        -: 3749:	    {
        -: 3750:		REG1 int	i;
        -: 3751:	    
    #####: 3752:		if (outpos+(i = (de_stack-stackp)) >= OUTBUFSIZ) {
branch  0 never executed
branch  1 never executed
        -: 3753:		    do {
    #####: 3754:			if (i > OUTBUFSIZ-outpos) i = OUTBUFSIZ-outpos;
branch  0 never executed
branch  1 never executed
        -: 3755:
    #####: 3756:			if (i > 0) {
branch  0 never executed
branch  1 never executed
    #####: 3757:			    memcpy(outbuf+outpos, stackp, i);
    #####: 3758:			    outpos += i;
        -: 3759:			}
    #####: 3760:			if (outpos >= OUTBUFSIZ) {
branch  0 never executed
branch  1 never executed
    #####: 3761:			    if (!test) {
branch  0 never executed
branch  1 never executed
    #####: 3762:				write_buf(out, (char*)outbuf, outpos);
call    0 never executed
    #####: 3763:				bytes_out += (off_t)outpos;
        -: 3764:			    }
    #####: 3765:			    outpos = 0;
        -: 3766:			}
    #####: 3767:			stackp+= i;
    #####: 3768:		    } while ((i = (de_stack-stackp)) > 0);
branch  0 never executed
branch  1 never executed
        -: 3769:		} else {
    #####: 3770:		    memcpy(outbuf+outpos, stackp, i);
    #####: 3771:		    outpos += i;
        -: 3772:		}
        -: 3773:	    }
        -: 3774:
    #####: 3775:	    if ((code = free_ent) < maxmaxcode) { /* Generate the new entry. */
branch  0 never executed
branch  1 never executed
        -: 3776:
    #####: 3777:		tab_prefixof(code) = (unsigned short)oldcode;
    #####: 3778:		tab_suffixof(code) = (char_type)finchar;
    #####: 3779:		free_ent = code+1;
        -: 3780:	    } 
    #####: 3781:	    oldcode = incode;	/* Remember previous code.	*/
        -: 3782:	}
    #####: 3783:    } while (rsize != 0);
branch  0 never executed
branch  1 never executed
        -: 3784:    
    #####: 3785:    if (!test && outpos > 0) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3786:	write_buf(out, (char*)outbuf, outpos);
call    0 never executed
    #####: 3787:	bytes_out += (off_t)outpos;
        -: 3788:    }
    #####: 3789:    return OK;
        -: 3790:}
        -: 3791:/* unpack.c -- decompress files in pack format.
        -: 3792: * Copyright (C) 1992-1993 Jean-loup Gailly
        -: 3793: * This is free software; you can redistribute it and/or modify it under the
        -: 3794: * terms of the GNU General Public License, see the file COPYING.
        -: 3795: */
        -: 3796:
        -: 3797:#ifdef RCSID
        -: 3798:static char rcsid[] = "$Id: unpack.c,v 1.4 1993/06/11 19:25:36 jloup Exp $";
        -: 3799:#endif
        -: 3800:
        -: 3801:#define MIN(a,b) ((a) <= (b) ? (a) : (b))
        -: 3802:/* The arguments must not have side effects. */
        -: 3803:
        -: 3804:#define MAX_BITLEN 25
        -: 3805:/* Maximum length of Huffman codes. (Minor modifications to the code
        -: 3806: * would be needed to support 32 bits codes, but pack never generates
        -: 3807: * more than 24 bits anyway.)
        -: 3808: */
        -: 3809:
        -: 3810:#define LITERALS 256
        -: 3811:/* Number of literals, excluding the End of Block (EOB) code */
        -: 3812:
        -: 3813:#define MAX_PEEK 12
        -: 3814:/* Maximum number of 'peek' bits used to optimize traversal of the
        -: 3815: * Huffman tree.
        -: 3816: */
        -: 3817:
        -: 3818:local ulg orig_len;       /* original uncompressed length */
        -: 3819:local int max_len;        /* maximum bit length of Huffman codes */
        -: 3820:
        -: 3821:local uch literal[LITERALS];
        -: 3822:/* The literal bytes present in the Huffman tree. The EOB code is not
        -: 3823: * represented.
        -: 3824: */
        -: 3825:
        -: 3826:local int lit_base[MAX_BITLEN+1];
        -: 3827:/* All literals of a given bit length are contiguous in literal[] and
        -: 3828: * have contiguous codes. literal[code+lit_base[len]] is the literal
        -: 3829: * for a code of len bits.
        -: 3830: */
        -: 3831:
        -: 3832:local int leaves [MAX_BITLEN+1]; /* Number of leaves for each bit length */
        -: 3833:local int parents[MAX_BITLEN+1]; /* Number of parents for each bit length */
        -: 3834:
        -: 3835:local int peek_bits; /* Number of peek bits currently used */
        -: 3836:
        -: 3837:/* local uch prefix_len[1 << MAX_PEEK]; */
        -: 3838:#define prefix_len outbuf
        -: 3839:/* For each bit pattern b of peek_bits bits, prefix_len[b] is the length
        -: 3840: * of the Huffman code starting with a prefix of b (upper bits), or 0
        -: 3841: * if all codes of prefix b have more than peek_bits bits. It is not
        -: 3842: * necessary to have a huge table (large MAX_PEEK) because most of the
        -: 3843: * codes encountered in the input stream are short codes (by construction).
        -: 3844: * So for most codes a single lookup will be necessary.
        -: 3845: */
        -: 3846:#if (1<<MAX_PEEK) > OUTBUFSIZ
        -: 3847:    error cannot overlay prefix_len and outbuf
        -: 3848:#endif
        -: 3849:
        -: 3850:local ulg un_bitbuf;
        -: 3851:/* Bits are added on the low part of bitbuf and read from the high part. */
        -: 3852:
        -: 3853:local int valid;                  /* number of valid bits in bitbuf */
        -: 3854:/* all bits above the last valid bit are always zero */
        -: 3855:
        -: 3856:/* Set code to the next 'bits' input bits without skipping them. code
        -: 3857: * must be the name of a simple variable and bits must not have side effects.
        -: 3858: * IN assertions: bits <= 25 (so that we still have room for an extra byte
        -: 3859: * when valid is only 24), and mask = (1<<bits)-1.
        -: 3860: */
        -: 3861:#define look_bits(code,bits,mask) \
        -: 3862:{ \
        -: 3863:  while (valid < (bits)) un_bitbuf = (un_bitbuf<<8) | (ulg)get_byte(), valid += 8; \
        -: 3864:  code = (un_bitbuf >> (valid-(bits))) & (mask); \
        -: 3865:}
        -: 3866:
        -: 3867:/* Skip the given number of bits (after having peeked at them): */
        -: 3868:#define skip_bits(bits)  (valid -= (bits))
        -: 3869:
        -: 3870:#define clear_bitbuf() (valid = 0, un_bitbuf = 0)
        -: 3871:
        -: 3872:/* Local functions */
        -: 3873:
        -: 3874:local void read_tree  OF((void));
        -: 3875:local void un_build_tree OF((void));
        -: 3876:
        -: 3877:/* ===========================================================================
        -: 3878: * Read the Huffman tree.
        -: 3879: */
function read_tree called 0 returned 0% blocks executed 0%
    #####: 3880:local void read_tree()
        -: 3881:{
        -: 3882:    int len;  /* bit length */
        -: 3883:    int base; /* base offset for a sequence of leaves */
        -: 3884:    int n;
        -: 3885:
        -: 3886:    /* Read the original input size, MSB first */
    #####: 3887:    orig_len = 0;
    #####: 3888:    for (n = 1; n <= 4; n++) orig_len = (orig_len << 8) | (ulg)get_byte();
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 3889:
    #####: 3890:    max_len = (int)get_byte(); /* maximum bit length of Huffman codes */
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 3891:    if (max_len > MAX_BITLEN) {
branch  0 never executed
branch  1 never executed
    #####: 3892:	error("invalid compressed data -- Huffman code > 32 bits");
call    0 never executed
        -: 3893:    }
        -: 3894:
        -: 3895:    /* Get the number of leaves at each bit length */
    #####: 3896:    n = 0;
    #####: 3897:    for (len = 1; len <= max_len; len++) {
branch  0 never executed
branch  1 never executed
    #####: 3898:	leaves[len] = (int)get_byte();
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 3899:	n += leaves[len];
        -: 3900:    }
    #####: 3901:    if (n > LITERALS) {
branch  0 never executed
branch  1 never executed
    #####: 3902:	error("too many leaves in Huffman tree");
call    0 never executed
        -: 3903:    }
        -: 3904:    Trace((stderr, "orig_len %lu, max_len %d, leaves %d\n",
        -: 3905:	   orig_len, max_len, n));
        -: 3906:    /* There are at least 2 and at most 256 leaves of length max_len.
        -: 3907:     * (Pack arbitrarily rejects empty files and files consisting of
        -: 3908:     * a single byte even repeated.) To fit the last leaf count in a
        -: 3909:     * byte, it is offset by 2. However, the last literal is the EOB
        -: 3910:     * code, and is not transmitted explicitly in the tree, so we must
        -: 3911:     * adjust here by one only.
        -: 3912:     */
    #####: 3913:    leaves[max_len]++;
        -: 3914:
        -: 3915:    /* Now read the leaves themselves */
    #####: 3916:    base = 0;
    #####: 3917:    for (len = 1; len <= max_len; len++) {
branch  0 never executed
branch  1 never executed
        -: 3918:	/* Remember where the literals of this length start in literal[] : */
    #####: 3919:	lit_base[len] = base;
        -: 3920:	/* And read the literals: */
    #####: 3921:	for (n = leaves[len]; n > 0; n--) {
branch  0 never executed
branch  1 never executed
    #####: 3922:	    literal[base++] = (uch)get_byte();
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 3923:	}
        -: 3924:    }
    #####: 3925:    leaves[max_len]++; /* Now include the EOB code in the Huffman tree */
    #####: 3926:}
        -: 3927:
        -: 3928:/* ===========================================================================
        -: 3929: * Build the Huffman tree and the prefix table.
        -: 3930: */
function un_build_tree called 0 returned 0% blocks executed 0%
    #####: 3931:local void un_build_tree()
        -: 3932:{
    #####: 3933:    int nodes = 0; /* number of nodes (parents+leaves) at current bit length */
        -: 3934:    int len;       /* current bit length */
        -: 3935:    uch *prefixp;  /* pointer in prefix_len */
        -: 3936:
    #####: 3937:    for (len = max_len; len >= 1; len--) {
branch  0 never executed
branch  1 never executed
        -: 3938:	/* The number of parent nodes at this level is half the total
        -: 3939:	 * number of nodes at parent level:
        -: 3940:	 */
    #####: 3941:	nodes >>= 1;
    #####: 3942:	parents[len] = nodes;
        -: 3943:	/* Update lit_base by the appropriate bias to skip the parent nodes
        -: 3944:	 * (which are not represented in the literal array):
        -: 3945:	 */
    #####: 3946:	lit_base[len] -= nodes;
        -: 3947:	/* Restore nodes to be parents+leaves: */
    #####: 3948:	nodes += leaves[len];
        -: 3949:    }
        -: 3950:    /* Construct the prefix table, from shortest leaves to longest ones.
        -: 3951:     * The shortest code is all ones, so we start at the end of the table.
        -: 3952:     */
    #####: 3953:    peek_bits = MIN(max_len, MAX_PEEK);
    #####: 3954:    prefixp = &prefix_len[1<<peek_bits];
    #####: 3955:    for (len = 1; len <= peek_bits; len++) {
branch  0 never executed
branch  1 never executed
    #####: 3956:	int prefixes = leaves[len] << (peek_bits-len); /* may be 0 */
    #####: 3957:	while (prefixes--) *--prefixp = (uch)len;
branch  0 never executed
branch  1 never executed
        -: 3958:    }
        -: 3959:    /* The length of all other codes is unknown: */
    #####: 3960:    while (prefixp > prefix_len) *--prefixp = 0;
branch  0 never executed
branch  1 never executed
    #####: 3961:}
        -: 3962:
        -: 3963:/* ===========================================================================
        -: 3964: * Unpack in to out.  This routine does not support the old pack format
        -: 3965: * with magic header \037\037.
        -: 3966: *
        -: 3967: * IN assertions: the buffer inbuf contains already the beginning of
        -: 3968: *   the compressed data, from offsets inptr to insize-1 included.
        -: 3969: *   The magic header has already been checked. The output buffer is cleared.
        -: 3970: */
function unpack called 0 returned 0% blocks executed 0%
    #####: 3971:int unpack(in, out)
        -: 3972:    int in, out;            /* input and output file descriptors */
        -: 3973:{
        -: 3974:    int len;                /* Bit length of current code */
        -: 3975:    unsigned eob;           /* End Of Block code */
        -: 3976:    register unsigned peek; /* lookahead bits */
        -: 3977:    unsigned peek_mask;     /* Mask for peek_bits bits */
        -: 3978:
    #####: 3979:    ifd = in;
    #####: 3980:    ofd = out;
        -: 3981:
    #####: 3982:    read_tree();     /* Read the Huffman tree */
call    0 never executed
    #####: 3983:    un_build_tree();    /* Build the prefix table */
call    0 never executed
    #####: 3984:    clear_bitbuf();  /* Initialize bit input */
    #####: 3985:    peek_mask = (1<<peek_bits)-1;
        -: 3986:
        -: 3987:    /* The eob code is the largest code among all leaves of maximal length: */
    #####: 3988:    eob = leaves[max_len]-1;
        -: 3989:    Trace((stderr, "eob %d %x\n", max_len, eob));
        -: 3990:
        -: 3991:    /* Decode the input data: */
        -: 3992:    for (;;) {
        -: 3993:	/* Since eob is the longest code and not shorter than max_len,
        -: 3994:         * we can peek at max_len bits without having the risk of reading
        -: 3995:         * beyond the end of file.
        -: 3996:	 */
    #####: 3997:	look_bits(peek, peek_bits, peek_mask);
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 3998:	len = prefix_len[peek];
    #####: 3999:	if (len > 0) {
branch  0 never executed
branch  1 never executed
    #####: 4000:	    peek >>= peek_bits - len; /* discard the extra bits */
        -: 4001:	} else {
        -: 4002:	    /* Code of more than peek_bits bits, we must traverse the tree */
    #####: 4003:	    ulg mask = peek_mask;
    #####: 4004:	    len = peek_bits;
        -: 4005:	    do {
    #####: 4006:                len++, mask = (mask<<1)+1;
    #####: 4007:		look_bits(peek, len, mask);
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 4008:	    } while (peek < (unsigned)parents[len]);
branch  0 never executed
branch  1 never executed
        -: 4009:	    /* loop as long as peek is a parent node */
        -: 4010:	}
        -: 4011:	/* At this point, peek is the next complete code, of len bits */
    #####: 4012:	if (peek == eob && len == max_len) break; /* end of file? */
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4013:	put_ubyte(literal[peek+lit_base[len]]);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 4014:	Tracev((stderr,"%02d %04x %c\n", len, peek,
        -: 4015:		literal[peek+lit_base[len]]));
    #####: 4016:	skip_bits(len);
        -: 4017:    } /* for (;;) */
        -: 4018:
    #####: 4019:    flush_window();
call    0 never executed
    #####: 4020:    if (orig_len != (ulg)(bytes_out & 0xffffffff)) {
branch  0 never executed
branch  1 never executed
    #####: 4021:	error("invalid compressed data--length error");
call    0 never executed
        -: 4022:    }
    #####: 4023:    return OK;
        -: 4024:}
        -: 4025:/* unzip.c -- decompress files in gzip or pkzip format.
        -: 4026: * Copyright (C) 1992-1993 Jean-loup Gailly
        -: 4027: * This is free software; you can redistribute it and/or modify it under the
        -: 4028: * terms of the GNU General Public License, see the file COPYING.
        -: 4029: *
        -: 4030: * The code in this file is derived from the file funzip.c written
        -: 4031: * and put in the public domain by Mark Adler.
        -: 4032: */
        -: 4033:
        -: 4034:/*
        -: 4035:   This version can extract files in gzip or pkzip format.
        -: 4036:   For the latter, only the first entry is extracted, and it has to be
        -: 4037:   either deflated or stored.
        -: 4038: */
        -: 4039:
        -: 4040:#ifdef RCSID
        -: 4041:static char rcsid[] = "$Id: unzip.c,v 0.13 1993/06/10 13:29:00 jloup Exp $";
        -: 4042:#endif
        -: 4043:
        -: 4044:/* PKZIP header definitions */
        -: 4045:#define LOCSIG 0x04034b50L      /* four-byte lead-in (lsb first) */
        -: 4046:#define LOCFLG 6                /* offset of bit flag */
        -: 4047:#define  CRPFLG 1               /*  bit for encrypted entry */
        -: 4048:#define  EXTFLG 8               /*  bit for extended local header */
        -: 4049:#define LOCHOW 8                /* offset of compression method */
        -: 4050:#define LOCTIM 10               /* file mod time (for decryption) */
        -: 4051:#define LOCCRC 14               /* offset of crc */
        -: 4052:#define LOCSIZ 18               /* offset of compressed size */
        -: 4053:#define LOCLEN 22               /* offset of uncompressed length */
        -: 4054:#define LOCFIL 26               /* offset of file name field length */
        -: 4055:#define LOCEXT 28               /* offset of extra field length */
        -: 4056:#define LOCHDR 30               /* size of local header, including sig */
        -: 4057:#define EXTHDR 16               /* size of extended local header, inc sig */
        -: 4058:#define RAND_HEAD_LEN  12       /* length of encryption random header */
        -: 4059:
        -: 4060:
        -: 4061:/* Globals */
        -: 4062:
        -: 4063:int decrypt;        /* flag to turn on decryption */
        -: 4064:char *key;          /* not used--needed to link crypt.c */
        -: 4065:int pkzip = 0;      /* set for a pkzip file */
        -: 4066:int ext_header = 0; /* set if extended local header */
        -: 4067:
        -: 4068:/* ===========================================================================
        -: 4069: * Check zip file and advance inptr to the start of the compressed data.
        -: 4070: * Get ofname from the local header if necessary.
        -: 4071: */
function check_zipfile called 0 returned 0% blocks executed 0%
    #####: 4072:int check_zipfile(in)
        -: 4073:    int in;   /* input file descriptors */
        -: 4074:{
    #####: 4075:    uch *h = inbuf + inptr; /* first local header */
        -: 4076:
    #####: 4077:    ifd = in;
        -: 4078:
        -: 4079:    /* Check validity of local header, and skip name and extra fields */
    #####: 4080:    inptr += LOCHDR + SH(h + LOCFIL) + SH(h + LOCEXT);
        -: 4081:
    #####: 4082:    if (inptr > insize || LG(h) != LOCSIG) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4083:	fprintf(stderr, "\n%s: %s: not a valid zip file\n",
call    0 never executed
        -: 4084:		progname, ifname);
    #####: 4085:	exit_code = ERROR;
    #####: 4086:	return ERROR;
        -: 4087:    }
    #####: 4088:    method = h[LOCHOW];
    #####: 4089:    if (method != STORED && method != DEFLATED) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4090:	fprintf(stderr,
call    0 never executed
        -: 4091:		"\n%s: %s: first entry not deflated or stored -- use unzip\n",
        -: 4092:		progname, ifname);
    #####: 4093:	exit_code = ERROR;
    #####: 4094:	return ERROR;
        -: 4095:    }
        -: 4096:
        -: 4097:    /* If entry encrypted, decrypt and validate encryption header */
    #####: 4098:    if ((decrypt = h[LOCFLG] & CRPFLG) != 0) {
branch  0 never executed
branch  1 never executed
    #####: 4099:	fprintf(stderr, "\n%s: %s: encrypted file -- use unzip\n",
call    0 never executed
        -: 4100:		progname, ifname);
    #####: 4101:	exit_code = ERROR;
    #####: 4102:	return ERROR;
        -: 4103:    }
        -: 4104:
        -: 4105:    /* Save flags for unzip() */
    #####: 4106:    ext_header = (h[LOCFLG] & EXTFLG) != 0;
    #####: 4107:    pkzip = 1;
        -: 4108:
        -: 4109:    /* Get ofname and time stamp from local header (to be done) */
    #####: 4110:    return OK;
        -: 4111:}
        -: 4112:
        -: 4113:/* ===========================================================================
        -: 4114: * Unzip in to out.  This routine works on both gzip and pkzip files.
        -: 4115: *
        -: 4116: * IN assertions: the buffer inbuf contains already the beginning of
        -: 4117: *   the compressed data, from offsets inptr to insize-1 included.
        -: 4118: *   The magic header has already been checked. The output buffer is cleared.
        -: 4119: */
function unzip called 0 returned 0% blocks executed 0%
    #####: 4120:int unzip(in, out)
        -: 4121:    int in, out;   /* input and output file descriptors */
        -: 4122:{
    #####: 4123:    ulg orig_crc = 0;       /* original crc */
    #####: 4124:    ulg orig_len = 0;       /* original uncompressed length */
        -: 4125:    int n;
        -: 4126:    uch buf[EXTHDR];        /* extended local header */
        -: 4127:#ifdef FAULTY_F_KL_2
    #####: 4128:    int err = -1;
        -: 4129:#else
        -: 4130:    int err = OK;
        -: 4131:#endif
        -: 4132:
    #####: 4133:    ifd = in;
    #####: 4134:    ofd = out;
        -: 4135:
    #####: 4136:    updcrc(NULL, 0);           /* initialize crc */
call    0 never executed
        -: 4137:
    #####: 4138:    if (pkzip && !ext_header) {  /* crc and length at the end otherwise */
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4139:	orig_crc = LG(inbuf + LOCCRC);
    #####: 4140:	orig_len = LG(inbuf + LOCLEN);
        -: 4141:    }
        -: 4142:
        -: 4143:    /* Decompress */
    #####: 4144:    if (method == DEFLATED)  {
branch  0 never executed
branch  1 never executed
        -: 4145:
    #####: 4146:	int res = inflate();
call    0 never executed
        -: 4147:
    #####: 4148:	if (res == 3) {
branch  0 never executed
branch  1 never executed
    #####: 4149:	    error("out of memory");
call    0 never executed
    #####: 4150:	} else if (res != 0) {
branch  0 never executed
branch  1 never executed
    #####: 4151:	    error("invalid compressed data--format violated");
call    0 never executed
        -: 4152:	}
        -: 4153:
    #####: 4154:    } else if (pkzip && method == STORED) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 4155:
    #####: 4156:	register ulg n = LG(inbuf + LOCLEN);
        -: 4157:
    #####: 4158:	if (n != LG(inbuf + LOCSIZ) - (decrypt ? RAND_HEAD_LEN : 0)) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 4159:
    #####: 4160:	    fprintf(stderr, "len %ld, siz %ld\n", n, LG(inbuf + LOCSIZ));
call    0 never executed
    #####: 4161:	    error("invalid compressed data--length mismatch");
call    0 never executed
        -: 4162:	}
    #####: 4163:	while (n--) {
branch  0 never executed
branch  1 never executed
    #####: 4164:	    uch c = (uch)get_byte();
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 4165:	    put_ubyte(c);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 4166:	}
    #####: 4167:	flush_window();
call    0 never executed
        -: 4168:    } else {
    #####: 4169:	error("internal error, invalid method");
call    0 never executed
        -: 4170:    }
        -: 4171:
        -: 4172:    /* Get the crc and original length */
    #####: 4173:    if (!pkzip) {
branch  0 never executed
branch  1 never executed
        -: 4174:        /* crc32  (see algorithm.doc)
        -: 4175:	 * uncompressed input size modulo 2^32
        -: 4176:         */
    #####: 4177:	for (n = 0; n < 8; n++) {
branch  0 never executed
branch  1 never executed
    #####: 4178:	    buf[n] = (uch)get_byte(); /* may cause an error if EOF */
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 4179:	}
    #####: 4180:	orig_crc = LG(buf);
    #####: 4181:	orig_len = LG(buf+4);
        -: 4182:
    #####: 4183:    } else if (ext_header) {  /* If extended header, check it */
branch  0 never executed
branch  1 never executed
        -: 4184:	/* signature - 4bytes: 0x50 0x4b 0x07 0x08
        -: 4185:	 * CRC-32 value
        -: 4186:         * compressed size 4-bytes
        -: 4187:         * uncompressed size 4-bytes
        -: 4188:	 */
    #####: 4189:	for (n = 0; n < EXTHDR; n++) {
branch  0 never executed
branch  1 never executed
    #####: 4190:	    buf[n] = (uch)get_byte(); /* may cause an error if EOF */
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 4191:	}
    #####: 4192:	orig_crc = LG(buf+4);
    #####: 4193:	orig_len = LG(buf+12);
        -: 4194:    }
        -: 4195:
        -: 4196:    /* Validate decompression */
    #####: 4197:    if (orig_crc != updcrc(outbuf, 0)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 4198:	fprintf(stderr, "\n%s: %s: invalid compressed data--crc error\n",
call    0 never executed
        -: 4199:		progname, ifname);
    #####: 4200:	err = ERROR;
        -: 4201:    }
    #####: 4202:    if (orig_len != (ulg)(bytes_out & 0xffffffff)) {
branch  0 never executed
branch  1 never executed
    #####: 4203:	fprintf(stderr, "\n%s: %s: invalid compressed data--length error\n",
call    0 never executed
        -: 4204:		progname, ifname);
    #####: 4205:	err = ERROR;
        -: 4206:    }
        -: 4207:
        -: 4208:    /* Check if there are more entries in a pkzip file */
    #####: 4209:    if (pkzip && inptr + 4 < insize && LG(inbuf+inptr) == LOCSIG) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 4210:	if (to_stdout) {
branch  0 never executed
branch  1 never executed
    #####: 4211:	    WARN((stderr,
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 4212:		  "%s: %s has more than one entry--rest ignored\n",
        -: 4213:		  progname, ifname));
        -: 4214:	} else {
        -: 4215:	    /* Don't destroy the input zip file */
    #####: 4216:	    fprintf(stderr,
call    0 never executed
        -: 4217:		    "%s: %s has more than one entry -- unchanged\n",
        -: 4218:		    progname, ifname);
    #####: 4219:	    err = ERROR;
        -: 4220:	}
        -: 4221:    }
    #####: 4222:    ext_header = pkzip = 0; /* for next file */
    #####: 4223:    if (err == OK) return OK;
branch  0 never executed
branch  1 never executed
    #####: 4224:    exit_code = ERROR;
    #####: 4225:    if (!test) abort_gzip();
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 4226:    return err;
        -: 4227:}
        -: 4228:/* util.c -- utility functions for gzip support
        -: 4229: * Copyright (C) 1992-1993 Jean-loup Gailly
        -: 4230: * This is free software; you can redistribute it and/or modify it under the
        -: 4231: * terms of the GNU General Public License, see the file COPYING.
        -: 4232: */
        -: 4233:
        -: 4234:#ifdef RCSID
        -: 4235:static char rcsid[] = "$Id: util.c,v 0.15 1993/06/15 09:04:13 jloup Exp $";
        -: 4236:#endif
        -: 4237:
        -: 4238:#ifdef HAVE_LIMITS_H
        -: 4239:#  include <limits.h>
        -: 4240:#endif
        -: 4241:#ifdef HAVE_UNISTD_H
        -: 4242:#  include <unistd.h>
        -: 4243:#endif
        -: 4244:#ifdef HAVE_FCNTL_H
        -: 4245:#  include <fcntl.h>
        -: 4246:#endif
        -: 4247:
        -: 4248:#if defined STDC_HEADERS || defined HAVE_STDLIB_H
        -: 4249:#  include <stdlib.h>
        -: 4250:#else
        -: 4251:   extern int errno;
        -: 4252:#endif
        -: 4253:
        -: 4254:#ifndef CHAR_BIT
        -: 4255:#  define CHAR_BIT 8
        -: 4256:#endif
        -: 4257:
        -: 4258:extern ulg crc_32_tab[];   /* crc table, defined below */
        -: 4259:
        -: 4260:/* ===========================================================================
        -: 4261: * Copy input to output unchanged: zcat == cat with --force.
        -: 4262: * IN assertion: insize bytes have already been read in inbuf.
        -: 4263: */
function copy called 0 returned 0% blocks executed 0%
    #####: 4264:int copy(in, out)
        -: 4265:    int in, out;   /* input and output file descriptors */
        -: 4266:{
    #####: 4267:    errno = 0;
        -: 4268:#ifdef FAULTY_F_TW_2
    #####: 4269:    while (insize <= 0 && (int)insize != EOF) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 4270:#else
        -: 4271:    while (insize != 0 && (int)insize != -1) {
        -: 4272:#endif
    #####: 4273:	write_buf(out, (char*)inbuf, insize);
call    0 never executed
    #####: 4274:	bytes_out += insize;
    #####: 4275:	insize = read(in, (char*)inbuf, INBUFSIZ);
call    0 never executed
        -: 4276:    }
    #####: 4277:    if ((int)insize == -1) {
branch  0 never executed
branch  1 never executed
    #####: 4278:	read_error();
call    0 never executed
        -: 4279:    }
    #####: 4280:    bytes_in = bytes_out;
    #####: 4281:    return OK;
        -: 4282:}
        -: 4283:
        -: 4284:/* ===========================================================================
        -: 4285: * Run a set of bytes through the crc shift register.  If s is a NULL
        -: 4286: * pointer, then initialize the crc shift register contents instead.
        -: 4287: * Return the current crc in either case.
        -: 4288: */
function updcrc called 2 returned 100% blocks executed 100%
        2: 4289:ulg updcrc(s, n)
        -: 4290:    uch *s;                 /* pointer to bytes to pump through */
        -: 4291:    unsigned n;             /* number of bytes in s[] */
        -: 4292:{
        -: 4293:    register ulg c;         /* temporary variable */
        -: 4294:
        -: 4295:    static ulg crc = (ulg)0xffffffffL; /* shift register contents */
        -: 4296:
        2: 4297:    if (s == NULL) {
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        1: 4298:	c = 0xffffffffL;
        -: 4299:    } else {
        1: 4300:	c = crc;
        1: 4301:        if (n) do {
branch  0 taken 1 (fallthrough)
branch  1 taken 0
    34231: 4302:            c = crc_32_tab[((int)c ^ (*s++)) & 0xff] ^ (c >> 8);
    34231: 4303:        } while (--n);
branch  0 taken 34230
branch  1 taken 1 (fallthrough)
        -: 4304:    }
        2: 4305:    crc = c;
        2: 4306:    return c ^ 0xffffffffL;       /* (instead of ~c for 64-bit machines) */
        -: 4307:}
        -: 4308:
        -: 4309:/* ===========================================================================
        -: 4310: * Clear input and output buffers
        -: 4311: */
function clear_bufs called 1 returned 100% blocks executed 100%
        1: 4312:void clear_bufs()
        -: 4313:{
        1: 4314:    outcnt = 0;
        1: 4315:    insize = inptr = 0;
        1: 4316:    bytes_in = bytes_out = 0L;
        1: 4317:}
        -: 4318:
        -: 4319:/* ===========================================================================
        -: 4320: * Fill the input buffer. This is called only when the buffer is empty.
        -: 4321: */
function fill_inbuf called 0 returned 0% blocks executed 0%
    #####: 4322:int fill_inbuf(eof_ok)
        -: 4323:    int eof_ok;          /* set if EOF acceptable as a result */
        -: 4324:{
        -: 4325:    int len;
        -: 4326:
        -: 4327:    /* Read as much as possible */
    #####: 4328:    insize = 0;
        -: 4329:    do {
    #####: 4330:	len = read(ifd, (char*)inbuf+insize, INBUFSIZ-insize);
call    0 never executed
    #####: 4331:	if (len == 0) break;
branch  0 never executed
branch  1 never executed
    #####: 4332:	if (len == -1) {
branch  0 never executed
branch  1 never executed
    #####: 4333:	  read_error();
call    0 never executed
    #####: 4334:	  break;
        -: 4335:	}
    #####: 4336:	insize += len;
    #####: 4337:    } while (insize < INBUFSIZ);
branch  0 never executed
branch  1 never executed
        -: 4338:
    #####: 4339:    if (insize == 0) {
branch  0 never executed
branch  1 never executed
    #####: 4340:	if (eof_ok) return EOF;
branch  0 never executed
branch  1 never executed
        -: 4341:#ifdef FAULTY_F_KL_3
    #####: 4342:	flush_window();
call    0 never executed
    #####: 4343:	flush_window();
call    0 never executed
        -: 4344:#else
        -: 4345:	flush_window();
        -: 4346:#endif
    #####: 4347:	errno = 0;
    #####: 4348:	read_error();
call    0 never executed
        -: 4349:    }
    #####: 4350:    bytes_in += (off_t)insize;
    #####: 4351:    inptr = 1;
    #####: 4352:    return inbuf[0];
        -: 4353:}
        -: 4354:
        -: 4355:/* ===========================================================================
        -: 4356: * Write the output buffer outbuf[0..outcnt-1] and update bytes_out.
        -: 4357: * (used for the compressed data only)
        -: 4358: */
function flush_outbuf called 1 returned 100% blocks executed 80%
        1: 4359:void flush_outbuf()
        -: 4360:{
       1*: 4361:    if (outcnt == 0) return;
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -: 4362:
        1: 4363:    write_buf(ofd, (char *)outbuf, outcnt);
call    0 returned 1
        1: 4364:    bytes_out += (off_t)outcnt;
        1: 4365:    outcnt = 0;
        -: 4366:}
        -: 4367:
        -: 4368:/* ===========================================================================
        -: 4369: * Write the output window window[0..outcnt-1] and update crc and bytes_out.
        -: 4370: * (Used for the decompressed data only.)
        -: 4371: */
function flush_window called 0 returned 0% blocks executed 0%
    #####: 4372:void flush_window()
        -: 4373:{
    #####: 4374:    if (outcnt == 0) return;
branch  0 never executed
branch  1 never executed
    #####: 4375:    updcrc(window, outcnt);
call    0 never executed
        -: 4376:
    #####: 4377:    if (!test) {
branch  0 never executed
branch  1 never executed
    #####: 4378:	write_buf(ofd, (char *)window, outcnt);
call    0 never executed
        -: 4379:    }
    #####: 4380:    bytes_out += (off_t)outcnt;
    #####: 4381:    outcnt = 0;
        -: 4382:}
        -: 4383:
        -: 4384:/* ===========================================================================
        -: 4385: * Does the same as write(), but also handles partial pipe writes and checks
        -: 4386: * for error return.
        -: 4387: */
function write_buf called 1 returned 100% blocks executed 57%
        1: 4388:void write_buf(fd, buf, cnt)
        -: 4389:    int       fd;
        -: 4390:    voidp     buf;
        -: 4391:    unsigned  cnt;
        -: 4392:{
        -: 4393:    unsigned  n;
        -: 4394:
        1: 4395:    while ((n = write(fd, buf, cnt)) != cnt) {
call    0 returned 1
branch  1 taken 0
branch  2 taken 1 (fallthrough)
    #####: 4396:	if (n == (unsigned)(-1)) {
branch  0 never executed
branch  1 never executed
    #####: 4397:	    write_error();
call    0 never executed
        -: 4398:	}
    #####: 4399:	cnt -= n;
    #####: 4400:	buf = (voidp)((char*)buf+n);
        -: 4401:    }
        1: 4402:}
        -: 4403:
        -: 4404:/* ========================================================================
        -: 4405: * Put string s in lower case, return s.
        -: 4406: */
function strlwr called 0 returned 0% blocks executed 0%
    #####: 4407:char *strlwr(s)
        -: 4408:    char *s;
        -: 4409:{
        -: 4410:    char *t;
    #####: 4411:    for (t = s; *t; t++)
branch  0 never executed
branch  1 never executed
    #####: 4412:      *t = tolow ((unsigned char) *t);
branch  0 never executed
branch  1 never executed
    #####: 4413:    return s;
        -: 4414:}
        -: 4415:
        -: 4416:/* ========================================================================
        -: 4417: * Return the base name of a file (remove any directory prefix and
        -: 4418: * any version suffix). For systems with file names that are not
        -: 4419: * case sensitive, force the base name to lower case.
        -: 4420: */
function base_name called 1 returned 100% blocks executed 100%
        1: 4421:char *base_name(fname)
        -: 4422:    char *fname;
        -: 4423:{
        -: 4424:    char *p;
        -: 4425:
        1: 4426:    if ((p = strrchr(fname, PATH_SEP))  != NULL) fname = p+1;
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -: 4427:#ifdef PATH_SEP2
        -: 4428:    if ((p = strrchr(fname, PATH_SEP2)) != NULL) fname = p+1;
        -: 4429:#endif
        -: 4430:#ifdef PATH_SEP3
        -: 4431:    if ((p = strrchr(fname, PATH_SEP3)) != NULL) fname = p+1;
        -: 4432:#endif
        -: 4433:#ifdef SUFFIX_SEP
        -: 4434:    if ((p = strrchr(fname, SUFFIX_SEP)) != NULL) *p = '\0';
        -: 4435:#endif
        -: 4436:    if (casemap('A') == 'a') strlwr(fname);
        1: 4437:    return fname;
        -: 4438:}
        -: 4439:
        -: 4440:/* ========================================================================
        -: 4441: * Unlink a file, working around the unlink readonly bug (if present).
        -: 4442: */
function xunlink called 0 returned 0% blocks executed 0%
    #####: 4443:int xunlink (filename)
        -: 4444:     char *filename;
        -: 4445:{
    #####: 4446:  int r = unlink (filename);
call    0 never executed
        -: 4447:
        -: 4448:#ifdef UNLINK_READONLY_BUG
        -: 4449:  if (r != 0)
        -: 4450:    {
        -: 4451:      int e = errno;
        -: 4452:      if (chmod (filename, S_IWUSR) != 0)
        -: 4453:	{
        -: 4454:	  errno = e;
        -: 4455:	  return -1;
        -: 4456:	}
        -: 4457:
        -: 4458:      r = unlink (filename);
        -: 4459:    }
        -: 4460:#endif
        -: 4461:
    #####: 4462:  return r;
        -: 4463:}
        -: 4464:
        -: 4465:/* ========================================================================
        -: 4466: * Make a file name legal for file systems not allowing file names with
        -: 4467: * multiple dots or starting with a dot (such as MSDOS), by changing
        -: 4468: * all dots except the last one into underlines.  A target dependent
        -: 4469: * function can be used instead of this simple function by defining the macro
        -: 4470: * MAKE_LEGAL_NAME in tailor.h and providing the function in a target
        -: 4471: * dependent module.
        -: 4472: */
function make_simple_name called 0 returned 0% blocks executed 0%
    #####: 4473:void make_simple_name(name)
        -: 4474:    char *name;
        -: 4475:{
    #####: 4476:    char *p = strrchr(name, '.');
    #####: 4477:    if (p == NULL) return;
branch  0 never executed
branch  1 never executed
    #####: 4478:    if (p == name) p++;
branch  0 never executed
branch  1 never executed
        -: 4479:    do {
    #####: 4480:        if (*--p == '.') *p = '_';
branch  0 never executed
branch  1 never executed
    #####: 4481:    } while (p != name);
branch  0 never executed
branch  1 never executed
        -: 4482:}
        -: 4483:
        -: 4484:
        -: 4485:#if !defined HAVE_STRING_H && !defined STDC_HEADERS
        -: 4486:
        -: 4487:/* Provide missing strspn and strcspn functions. */
        -: 4488:
        -: 4489:#  ifndef __STDC__
        -: 4490:#    define const
        -: 4491:#  endif
        -: 4492:
        -: 4493:int strspn  OF((const char *s, const char *accept));
        -: 4494:int strcspn OF((const char *s, const char *reject));
        -: 4495:
        -: 4496:/* ========================================================================
        -: 4497: * Return the length of the maximum initial segment
        -: 4498: * of s which contains only characters in accept.
        -: 4499: */
        -: 4500:int strspn(s, accept)
        -: 4501:    const char *s;
        -: 4502:    const char *accept;
        -: 4503:{
        -: 4504:    register const char *p;
        -: 4505:    register const char *a;
        -: 4506:    register int count = 0;
        -: 4507:
        -: 4508:    for (p = s; *p != '\0'; ++p) {
        -: 4509:	for (a = accept; *a != '\0'; ++a) {
        -: 4510:	    if (*p == *a) break;
        -: 4511:	}
        -: 4512:	if (*a == '\0') return count;
        -: 4513:	++count;
        -: 4514:    }
        -: 4515:    return count;
        -: 4516:}
        -: 4517:
        -: 4518:/* ========================================================================
        -: 4519: * Return the length of the maximum inital segment of s
        -: 4520: * which contains no characters from reject.
        -: 4521: */
        -: 4522:int strcspn(s, reject)
        -: 4523:    const char *s;
        -: 4524:    const char *reject;
        -: 4525:{
        -: 4526:    register int count = 0;
        -: 4527:
        -: 4528:    while (*s != '\0') {
        -: 4529:	if (strchr(reject, *s++) != NULL) return count;
        -: 4530:	++count;
        -: 4531:    }
        -: 4532:    return count;
        -: 4533:}
        -: 4534:
        -: 4535:#endif
        -: 4536:
        -: 4537:/* ========================================================================
        -: 4538: * Add an environment variable (if any) before argv, and update argc.
        -: 4539: * Return the expanded environment variable to be freed later, or NULL 
        -: 4540: * if no options were added to argv.
        -: 4541: */
        -: 4542:#define SEPARATOR	" \t"	/* separators in env variable */
        -: 4543:
function add_envopt called 1 returned 100% blocks executed 15%
        1: 4544:char *add_envopt(argcp, argvp, env)
        -: 4545:    int *argcp;          /* pointer to argc */
        -: 4546:    char ***argvp;       /* pointer to argv */
        -: 4547:    char *env;           /* name of environment variable */
        -: 4548:{
        -: 4549:    char *p;             /* running pointer through env variable */
        -: 4550:    char **oargv;        /* runs through old argv array */
        -: 4551:    char **nargv;        /* runs through new argv array */
        1: 4552:    int	 oargc = *argcp; /* old argc */
        1: 4553:    int  nargc = 0;      /* number of arguments in env variable */
        -: 4554:
        1: 4555:    env = (char*)getenv(env);
call    0 returned 1
        1: 4556:    if (env == NULL) return NULL;
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -: 4557:
    #####: 4558:    p = (char*)xmalloc(strlen(env)+1);
call    0 never executed
    #####: 4559:    env = strcpy(p, env);                    /* keep env variable intact */
        -: 4560:
    #####: 4561:    for (p = env; *p; nargc++ ) {            /* move through env */
branch  0 never executed
branch  1 never executed
    #####: 4562:	p += strspn(p, SEPARATOR);	     /* skip leading separators */
    #####: 4563:	if (*p == '\0') break;
branch  0 never executed
branch  1 never executed
        -: 4564:
    #####: 4565:	p += strcspn(p, SEPARATOR);	     /* find end of word */
    #####: 4566:	if (*p) *p++ = '\0';		     /* mark it */
branch  0 never executed
branch  1 never executed
        -: 4567:    }
    #####: 4568:    if (nargc == 0) {
branch  0 never executed
branch  1 never executed
    #####: 4569:	free(env);
    #####: 4570:	return NULL;
        -: 4571:    }
    #####: 4572:    *argcp += nargc;
        -: 4573:    /* Allocate the new argv array, with an extra element just in case
        -: 4574:     * the original arg list did not end with a NULL.
        -: 4575:     */
    #####: 4576:    nargv = (char**)calloc(*argcp+1, sizeof(char *));
    #####: 4577:    if (nargv == NULL) error("out of memory");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 4578:    oargv  = *argvp;
    #####: 4579:    *argvp = nargv;
        -: 4580:
        -: 4581:    /* Copy the program name first */
    #####: 4582:    if (oargc-- < 0) error("argc<=0");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 4583:    *(nargv++) = *(oargv++);
        -: 4584:
        -: 4585:    /* Then copy the environment args */
    #####: 4586:    for (p = env; nargc > 0; nargc--) {
branch  0 never executed
branch  1 never executed
    #####: 4587:	p += strspn(p, SEPARATOR);	     /* skip separators */
    #####: 4588:	*(nargv++) = p;			     /* store start */
    #####: 4589:	while (*p++) ;			     /* skip over word */
branch  0 never executed
branch  1 never executed
        -: 4590:    }
        -: 4591:
        -: 4592:    /* Finally copy the old args and add a NULL (usual convention) */
    #####: 4593:    while (oargc--) *(nargv++) = *(oargv++);
branch  0 never executed
branch  1 never executed
    #####: 4594:    *nargv = NULL;
    #####: 4595:    return env;
        -: 4596:}
        -: 4597:
        -: 4598:/* ========================================================================
        -: 4599: * Error handlers.
        -: 4600: */
function error called 0 returned 0% blocks executed 0%
    #####: 4601:void error(m)
        -: 4602:    char *m;
        -: 4603:{
    #####: 4604:    fprintf(stderr, "\n%s: %s: %s\n", progname, ifname, m);
call    0 never executed
    #####: 4605:    abort_gzip();
call    0 never executed
    #####: 4606:}
        -: 4607:
function warning called 0 returned 0% blocks executed 0%
    #####: 4608:void warning (m)
        -: 4609:    char *m;
        -: 4610:{
    #####: 4611:    WARN ((stderr, "%s: %s: warning: %s\n", progname, ifname, m));
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 4612:}
        -: 4613:
function read_error called 0 returned 0% blocks executed 0%
    #####: 4614:void read_error()
        -: 4615:{
        -: 4616:#ifdef FAULTY_F_KL_4
    #####: 4617:    int e = 0;
        -: 4618:#else
        -: 4619:    int e = errno;
        -: 4620:#endif
    #####: 4621:    fprintf(stderr, "\n%s: ", progname);
call    0 never executed
    #####: 4622:    if (e != 0) {
branch  0 never executed
branch  1 never executed
    #####: 4623:	errno = e;
    #####: 4624:	perror(ifname);
call    0 never executed
        -: 4625:    } else {
    #####: 4626:	fprintf(stderr, "%s: unexpected end of file\n", ifname);
call    0 never executed
        -: 4627:    }
    #####: 4628:    abort_gzip();
call    0 never executed
    #####: 4629:}
        -: 4630:
function write_error called 0 returned 0% blocks executed 0%
    #####: 4631:void write_error()
        -: 4632:{
    #####: 4633:    int e = errno;
    #####: 4634:    fprintf(stderr, "\n%s: ", progname);
call    0 never executed
    #####: 4635:    errno = e;
    #####: 4636:    perror(ofname);
call    0 never executed
    #####: 4637:    abort_gzip();
call    0 never executed
    #####: 4638:}
        -: 4639:
        -: 4640:/* ========================================================================
        -: 4641: * Display compression ratio on the given stream on 6 characters.
        -: 4642: */
function display_ratio called 0 returned 0% blocks executed 0%
    #####: 4643:void display_ratio(num, den, file)
        -: 4644:    off_t num;
        -: 4645:    off_t den;
        -: 4646:    FILE *file;
        -: 4647:{
        -: 4648:    long ratio;  /* 1000 times the compression ratio */
        -: 4649:
    #####: 4650:    if (den == 0) {
branch  0 never executed
branch  1 never executed
    #####: 4651:	ratio = 0; /* no compression */
    #####: 4652:    } else if (den < 2147483L) { /* (2**31 -1)/1000 */
branch  0 never executed
branch  1 never executed
    #####: 4653:	ratio = 1000L*num/den;
        -: 4654:    } else {
    #####: 4655:	ratio = num/(den/1000L);
        -: 4656:    }
    #####: 4657:    if (ratio < 0) {
branch  0 never executed
branch  1 never executed
    #####: 4658:	putc('-', file);
call    0 never executed
    #####: 4659:	ratio = -ratio;
        -: 4660:    } else {
    #####: 4661:	putc(' ', file);
call    0 never executed
        -: 4662:    }
    #####: 4663:    fprint_off(file, ratio / 10, 2);
call    0 never executed
    #####: 4664:    fprintf(file, ".%d%%", (int) (ratio % 10));
call    0 never executed
    #####: 4665:}
        -: 4666:
        -: 4667:/* ========================================================================
        -: 4668: * Print an off_t.  There's no completely portable way to use printf,
        -: 4669: * so we do it ourselves.
        -: 4670: */
function fprint_off called 0 returned 0% blocks executed 0%
    #####: 4671:void fprint_off(file, offset, width)
        -: 4672:    FILE *file;
        -: 4673:    off_t offset;
        -: 4674:    int width;
        -: 4675:{
        -: 4676:    char buf[CHAR_BIT * sizeof (off_t)];
    #####: 4677:    char *p = buf + sizeof buf;
    #####: 4678:    int negative = offset < 0;
        -: 4679:    /* Don't negate offset here; it might overflow.  */
        -: 4680:    do {
    #####: 4681:	int remainder = offset % 10;
    #####: 4682:	int quotient = offset / 10;
    #####: 4683:	if (offset < 0 && 0 < remainder) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4684:	    remainder -= 10;
    #####: 4685:	    quotient++;
        -: 4686:	}
    #####: 4687:	*--p = (remainder < 0 ? -remainder : remainder) + '0';
    #####: 4688:	width--;
    #####: 4689:	offset = quotient;
    #####: 4690:    } while (offset != 0);
branch  0 never executed
branch  1 never executed
    #####: 4691:    for (width -= negative;  0 < width;  width--) {
branch  0 never executed
branch  1 never executed
    #####: 4692:	putc (' ', file);
call    0 never executed
        -: 4693:    }
    #####: 4694:    if (negative) {
branch  0 never executed
branch  1 never executed
    #####: 4695:	putc ('-', file);
call    0 never executed
        -: 4696:    }
    #####: 4697:    for (;  p < buf + sizeof buf;  p++)
branch  0 never executed
branch  1 never executed
    #####: 4698:	putc (*p, file);
call    0 never executed
    #####: 4699:}
        -: 4700:
        -: 4701:/* ========================================================================
        -: 4702: * Semi-safe malloc -- never returns NULL.
        -: 4703: */
function xmalloc called 0 returned 0% blocks executed 0%
    #####: 4704:voidp xmalloc (size)
        -: 4705:    unsigned size;
        -: 4706:{
    #####: 4707:    voidp cp = (voidp)malloc (size);
        -: 4708:
    #####: 4709:    if (cp == NULL) error("out of memory");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 4710:    return cp;
        -: 4711:}
        -: 4712:
        -: 4713:/* ========================================================================
        -: 4714: * Table of CRC-32's of all single-byte values (made by makecrc.c)
        -: 4715: */
        -: 4716:ulg crc_32_tab[] = {
        -: 4717:  0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL, 0x076dc419L,
        -: 4718:  0x706af48fL, 0xe963a535L, 0x9e6495a3L, 0x0edb8832L, 0x79dcb8a4L,
        -: 4719:  0xe0d5e91eL, 0x97d2d988L, 0x09b64c2bL, 0x7eb17cbdL, 0xe7b82d07L,
        -: 4720:  0x90bf1d91L, 0x1db71064L, 0x6ab020f2L, 0xf3b97148L, 0x84be41deL,
        -: 4721:  0x1adad47dL, 0x6ddde4ebL, 0xf4d4b551L, 0x83d385c7L, 0x136c9856L,
        -: 4722:  0x646ba8c0L, 0xfd62f97aL, 0x8a65c9ecL, 0x14015c4fL, 0x63066cd9L,
        -: 4723:  0xfa0f3d63L, 0x8d080df5L, 0x3b6e20c8L, 0x4c69105eL, 0xd56041e4L,
        -: 4724:  0xa2677172L, 0x3c03e4d1L, 0x4b04d447L, 0xd20d85fdL, 0xa50ab56bL,
        -: 4725:  0x35b5a8faL, 0x42b2986cL, 0xdbbbc9d6L, 0xacbcf940L, 0x32d86ce3L,
        -: 4726:  0x45df5c75L, 0xdcd60dcfL, 0xabd13d59L, 0x26d930acL, 0x51de003aL,
        -: 4727:  0xc8d75180L, 0xbfd06116L, 0x21b4f4b5L, 0x56b3c423L, 0xcfba9599L,
        -: 4728:  0xb8bda50fL, 0x2802b89eL, 0x5f058808L, 0xc60cd9b2L, 0xb10be924L,
        -: 4729:  0x2f6f7c87L, 0x58684c11L, 0xc1611dabL, 0xb6662d3dL, 0x76dc4190L,
        -: 4730:  0x01db7106L, 0x98d220bcL, 0xefd5102aL, 0x71b18589L, 0x06b6b51fL,
        -: 4731:  0x9fbfe4a5L, 0xe8b8d433L, 0x7807c9a2L, 0x0f00f934L, 0x9609a88eL,
        -: 4732:  0xe10e9818L, 0x7f6a0dbbL, 0x086d3d2dL, 0x91646c97L, 0xe6635c01L,
        -: 4733:  0x6b6b51f4L, 0x1c6c6162L, 0x856530d8L, 0xf262004eL, 0x6c0695edL,
        -: 4734:  0x1b01a57bL, 0x8208f4c1L, 0xf50fc457L, 0x65b0d9c6L, 0x12b7e950L,
        -: 4735:  0x8bbeb8eaL, 0xfcb9887cL, 0x62dd1ddfL, 0x15da2d49L, 0x8cd37cf3L,
        -: 4736:  0xfbd44c65L, 0x4db26158L, 0x3ab551ceL, 0xa3bc0074L, 0xd4bb30e2L,
        -: 4737:  0x4adfa541L, 0x3dd895d7L, 0xa4d1c46dL, 0xd3d6f4fbL, 0x4369e96aL,
        -: 4738:  0x346ed9fcL, 0xad678846L, 0xda60b8d0L, 0x44042d73L, 0x33031de5L,
        -: 4739:  0xaa0a4c5fL, 0xdd0d7cc9L, 0x5005713cL, 0x270241aaL, 0xbe0b1010L,
        -: 4740:  0xc90c2086L, 0x5768b525L, 0x206f85b3L, 0xb966d409L, 0xce61e49fL,
        -: 4741:  0x5edef90eL, 0x29d9c998L, 0xb0d09822L, 0xc7d7a8b4L, 0x59b33d17L,
        -: 4742:  0x2eb40d81L, 0xb7bd5c3bL, 0xc0ba6cadL, 0xedb88320L, 0x9abfb3b6L,
        -: 4743:  0x03b6e20cL, 0x74b1d29aL, 0xead54739L, 0x9dd277afL, 0x04db2615L,
        -: 4744:  0x73dc1683L, 0xe3630b12L, 0x94643b84L, 0x0d6d6a3eL, 0x7a6a5aa8L,
        -: 4745:  0xe40ecf0bL, 0x9309ff9dL, 0x0a00ae27L, 0x7d079eb1L, 0xf00f9344L,
        -: 4746:  0x8708a3d2L, 0x1e01f268L, 0x6906c2feL, 0xf762575dL, 0x806567cbL,
        -: 4747:  0x196c3671L, 0x6e6b06e7L, 0xfed41b76L, 0x89d32be0L, 0x10da7a5aL,
        -: 4748:  0x67dd4accL, 0xf9b9df6fL, 0x8ebeeff9L, 0x17b7be43L, 0x60b08ed5L,
        -: 4749:  0xd6d6a3e8L, 0xa1d1937eL, 0x38d8c2c4L, 0x4fdff252L, 0xd1bb67f1L,
        -: 4750:  0xa6bc5767L, 0x3fb506ddL, 0x48b2364bL, 0xd80d2bdaL, 0xaf0a1b4cL,
        -: 4751:  0x36034af6L, 0x41047a60L, 0xdf60efc3L, 0xa867df55L, 0x316e8eefL,
        -: 4752:  0x4669be79L, 0xcb61b38cL, 0xbc66831aL, 0x256fd2a0L, 0x5268e236L,
        -: 4753:  0xcc0c7795L, 0xbb0b4703L, 0x220216b9L, 0x5505262fL, 0xc5ba3bbeL,
        -: 4754:  0xb2bd0b28L, 0x2bb45a92L, 0x5cb36a04L, 0xc2d7ffa7L, 0xb5d0cf31L,
        -: 4755:  0x2cd99e8bL, 0x5bdeae1dL, 0x9b64c2b0L, 0xec63f226L, 0x756aa39cL,
        -: 4756:  0x026d930aL, 0x9c0906a9L, 0xeb0e363fL, 0x72076785L, 0x05005713L,
        -: 4757:  0x95bf4a82L, 0xe2b87a14L, 0x7bb12baeL, 0x0cb61b38L, 0x92d28e9bL,
        -: 4758:  0xe5d5be0dL, 0x7cdcefb7L, 0x0bdbdf21L, 0x86d3d2d4L, 0xf1d4e242L,
        -: 4759:  0x68ddb3f8L, 0x1fda836eL, 0x81be16cdL, 0xf6b9265bL, 0x6fb077e1L,
        -: 4760:  0x18b74777L, 0x88085ae6L, 0xff0f6a70L, 0x66063bcaL, 0x11010b5cL,
        -: 4761:  0x8f659effL, 0xf862ae69L, 0x616bffd3L, 0x166ccf45L, 0xa00ae278L,
        -: 4762:  0xd70dd2eeL, 0x4e048354L, 0x3903b3c2L, 0xa7672661L, 0xd06016f7L,
        -: 4763:  0x4969474dL, 0x3e6e77dbL, 0xaed16a4aL, 0xd9d65adcL, 0x40df0b66L,
        -: 4764:  0x37d83bf0L, 0xa9bcae53L, 0xdebb9ec5L, 0x47b2cf7fL, 0x30b5ffe9L,
        -: 4765:  0xbdbdf21cL, 0xcabac28aL, 0x53b39330L, 0x24b4a3a6L, 0xbad03605L,
        -: 4766:  0xcdd70693L, 0x54de5729L, 0x23d967bfL, 0xb3667a2eL, 0xc4614ab8L,
        -: 4767:  0x5d681b02L, 0x2a6f2b94L, 0xb40bbe37L, 0xc30c8ea1L, 0x5a05df1bL,
        -: 4768:  0x2d02ef8dL
        -: 4769:};
        -: 4770:/* zip.c -- compress files to the gzip or pkzip format
        -: 4771: * Copyright (C) 1992-1993 Jean-loup Gailly
        -: 4772: * This is free software; you can redistribute it and/or modify it under the
        -: 4773: * terms of the GNU General Public License, see the file COPYING.
        -: 4774: */
        -: 4775:
        -: 4776:#ifdef RCSID
        -: 4777:static char rcsid[] = "$Id: zip.c,v 0.17 1993/06/10 13:29:25 jloup Exp $";
        -: 4778:#endif
        -: 4779:
        -: 4780:#ifdef HAVE_UNISTD_H
        -: 4781:#  include <unistd.h>
        -: 4782:#endif
        -: 4783:#ifdef HAVE_FCNTL_H
        -: 4784:#  include <fcntl.h>
        -: 4785:#endif
        -: 4786:
        -: 4787:local ulg crc;       /* crc on uncompressed file data */
        -: 4788:off_t header_bytes;   /* number of bytes in gzip header */
        -: 4789:
        -: 4790:/* ===========================================================================
        -: 4791: * Deflate in to out.
        -: 4792: * IN assertions: the input and output buffers are cleared.
        -: 4793: *   The variables time_stamp and save_orig_name are initialized.
        -: 4794: */
function zip called 1 returned 100% blocks executed 41%
        1: 4795:int zip(in, out)
        -: 4796:    int in, out;            /* input and output file descriptors */
        -: 4797:{
        1: 4798:    uch  flags = 0;         /* general purpose bit flags */
        1: 4799:    ush  attr = 0;          /* ascii/binary flag */
        1: 4800:    ush  deflate_flags = 0; /* pkzip -es, -en or -ex equivalent */
        -: 4801:
        1: 4802:    ifd = in;
        1: 4803:    ofd = out;
        1: 4804:    outcnt = 0;
        -: 4805:
        -: 4806:    /* Write the header to the gzip file. See algorithm.doc for the format */
        -: 4807:
        1: 4808:    method = DEFLATED;
       1*: 4809:    put_byte(GZIP_MAGIC[0]); /* magic header */
branch  0 taken 0 (fallthrough)
branch  1 taken 1
call    2 never executed
       1*: 4810:    put_byte(GZIP_MAGIC[1]);
branch  0 taken 0 (fallthrough)
branch  1 taken 1
call    2 never executed
       1*: 4811:    put_byte(DEFLATED);      /* compression method */
branch  0 taken 0 (fallthrough)
branch  1 taken 1
call    2 never executed
        -: 4812:
        1: 4813:    if (save_orig_name) {
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 4814:	flags |= ORIG_NAME;
        -: 4815:    }
       1*: 4816:    put_byte(flags);         /* general flags */
branch  0 taken 0 (fallthrough)
branch  1 taken 1
call    2 never executed
        -: 4817:    /* this is not original code -- inserted by MAPSTEXT */
        1: 4818:    time_stamp = 0;
       1*: 4819:    put_long(time_stamp == (time_stamp & 0xffffffff)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
branch  2 taken 1 (fallthrough)
branch  3 taken 0
branch  4 taken 1 (fallthrough)
branch  5 taken 0
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
call   10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
call   15 never executed
branch 16 taken 1 (fallthrough)
branch 17 taken 0
branch 18 taken 1 (fallthrough)
branch 19 taken 0
branch 20 taken 1 (fallthrough)
branch 21 taken 0
branch 22 never executed
branch 23 never executed
branch 24 never executed
branch 25 never executed
call   26 never executed
branch 27 never executed
branch 28 never executed
branch 29 never executed
branch 30 never executed
call   31 never executed
        -: 4820:	     ? (ulg)time_stamp : (ulg)0);
        -: 4821:
        -: 4822:    /* Write deflated file to zip file */
        1: 4823:    crc = updcrc(0, 0);
call    0 returned 1
        -: 4824:
        1: 4825:    bi_init(out);
call    0 returned 1
        1: 4826:    ct_init(&attr, &method);
call    0 returned 1
        1: 4827:    lm_init(level, &deflate_flags);
call    0 returned 1
        -: 4828:
       1*: 4829:    put_byte((uch)deflate_flags); /* extra flags */
branch  0 taken 0 (fallthrough)
branch  1 taken 1
call    2 never executed
       1*: 4830:    put_byte(OS_CODE);            /* OS identifier */
branch  0 taken 0 (fallthrough)
branch  1 taken 1
call    2 never executed
        -: 4831:
        1: 4832:    if (save_orig_name) {
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 4833:	char *p = base_name(ifname); /* Don't save the directory part. */
call    0 never executed
        -: 4834:	do {
    #####: 4835:	    put_char(*p);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 4836:	} while (*p++);
branch  0 never executed
branch  1 never executed
        -: 4837:    }
        1: 4838:    header_bytes = (off_t)outcnt;
        -: 4839:
        1: 4840:    (void)deflate();
call    0 returned 1
        -: 4841:
        -: 4842:#if !defined(NO_SIZE_CHECK) && !defined(RECORD_IO)
        -: 4843:  /* Check input size (but not in VMS -- variable record lengths mess it up)
        -: 4844:   * and not on MSDOS -- diet in TSR mode reports an incorrect file size)
        -: 4845:   */
        -: 4846:    if (ifile_size != -1L && bytes_in != ifile_size) {
        -: 4847:	fprintf(stderr, "%s: %s: file size changed while zipping\n",
        -: 4848:		progname, ifname);
        -: 4849:    }
        -: 4850:#endif
        -: 4851:
        -: 4852:    /* Write the crc and uncompressed size */
       1*: 4853:    put_long(crc);
branch  0 taken 1 (fallthrough)
branch  1 taken 0
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
branch  8 taken 1 (fallthrough)
branch  9 taken 0
branch 10 never executed
branch 11 never executed
call   12 never executed
branch 13 never executed
branch 14 never executed
call   15 never executed
       1*: 4854:    put_long((ulg)bytes_in);
branch  0 taken 1 (fallthrough)
branch  1 taken 0
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
branch  8 taken 1 (fallthrough)
branch  9 taken 0
branch 10 never executed
branch 11 never executed
call   12 never executed
branch 13 never executed
branch 14 never executed
call   15 never executed
        1: 4855:    header_bytes += 2*sizeof(long);
        -: 4856:
        1: 4857:    flush_outbuf();
call    0 returned 1
        1: 4858:    return OK;
        -: 4859:}
        -: 4860:
        -: 4861:
        -: 4862:/* ===========================================================================
        -: 4863: * Read a new buffer from the current input file, perform end-of-line
        -: 4864: * translation, and update the crc and input file size.
        -: 4865: * IN assertion: size >= 2 (for end-of-line translation)
        -: 4866: */
function file_read called 2 returned 100% blocks executed 78%
        2: 4867:int file_read(buf, size)
        -: 4868:    char *buf;
        -: 4869:    unsigned size;
        -: 4870:{
        -: 4871:    unsigned len;
        -: 4872:
        -: 4873:    Assert(insize == 0, "inbuf not empty");
        -: 4874:
        2: 4875:    len = read(ifd, buf, size);
call    0 returned 2
        2: 4876:    if (len == 0) return (int)len;
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        1: 4877:    if (len == (unsigned)-1) {
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 4878:	read_error();
call    0 never executed
    #####: 4879:	return EOF;
        -: 4880:    }
        -: 4881:
        1: 4882:    crc = updcrc((uch*)buf, len);
call    0 returned 1
        1: 4883:    bytes_in += (off_t)len;
        1: 4884:    return (int)len;
        -: 4885:}
        -: 4886:/* gzip (GNU zip) -- compress files with zip algorithm and 'compress' interface
        -: 4887: * Copyright (C) 1992-1993 Jean-loup Gailly
        -: 4888: * The unzip code was written and put in the public domain by Mark Adler.
        -: 4889: * Portions of the lzw code are derived from the public domain 'compress'
        -: 4890: * written by Spencer Thomas, Joe Orost, James Woods, Jim McKie, Steve Davies,
        -: 4891: * Ken Turkowski, Dave Mack and Peter Jannesen.
        -: 4892: *
        -: 4893: * See the license_msg below and the file COPYING for the software license.
        -: 4894: * See the file algorithm.doc for the compression algorithms and file formats.
        -: 4895: */
        -: 4896:
        -: 4897:static char  *license_msg[] = {
        -: 4898:"Copyright 1999 Free Software Foundation",
        -: 4899:"Copyright 1992-1993 Jean-loup Gailly",
        -: 4900:"This program comes with ABSOLUTELY NO WARRANTY.",
        -: 4901:"You may redistribute copies of this program",
        -: 4902:"under the terms of the GNU General Public License.",
        -: 4903:"For more information about these matters, see the file named COPYING.",
        -: 4904:0};
        -: 4905:
        -: 4906:/* Compress files with zip algorithm and 'compress' interface.
        -: 4907: * See usage() and help() functions below for all options.
        -: 4908: * Outputs:
        -: 4909: *        file.gz:   compressed file with same mode, owner, and utimes
        -: 4910: *     or stdout with -c option or if stdin used as input.
        -: 4911: * If the output file name had to be truncated, the original name is kept
        -: 4912: * in the compressed file.
        -: 4913: * On MSDOS, file.tmp -> file.tmz. On VMS, file.tmp -> file.tmp-gz.
        -: 4914: *
        -: 4915: * Using gz on MSDOS would create too many file name conflicts. For
        -: 4916: * example, foo.txt -> foo.tgz (.tgz must be reserved as shorthand for
        -: 4917: * tar.gz). Similarly, foo.dir and foo.doc would both be mapped to foo.dgz.
        -: 4918: * I also considered 12345678.txt -> 12345txt.gz but this truncates the name
        -: 4919: * too heavily. There is no ideal solution given the MSDOS 8+3 limitation. 
        -: 4920: *
        -: 4921: * For the meaning of all compilation flags, see comments in Makefile.in.
        -: 4922: */
        -: 4923:
        -: 4924:#ifdef RCSID
        -: 4925:static char rcsid[] = "$Id: gzip.c,v 0.24 1993/06/24 10:52:07 jloup Exp $";
        -: 4926:#endif
        -: 4927:
        -: 4928:		/* configuration */
        -: 4929:
        -: 4930:#ifdef HAVE_TIME_H
        -: 4931:#  include <time.h>
        -: 4932:#else
        -: 4933:#  include <sys/time.h>
        -: 4934:#endif
        -: 4935:
        -: 4936:#ifdef HAVE_FCNTL_H
        -: 4937:#  include <fcntl.h>
        -: 4938:#endif
        -: 4939:
        -: 4940:#ifdef HAVE_LIMITS_H
        -: 4941:#  include <limits.h>
        -: 4942:#endif
        -: 4943:
        -: 4944:#ifdef HAVE_UNISTD_H
        -: 4945:#  include <unistd.h>
        -: 4946:#endif
        -: 4947:
        -: 4948:#if defined STDC_HEADERS || defined HAVE_STDLIB_H
        -: 4949:#  include <stdlib.h>
        -: 4950:#else
        -: 4951:   extern int errno;
        -: 4952:#endif
        -: 4953:
        -: 4954:#ifdef HAVE_DIRENT_H
        -: 4955:#  include <dirent.h>
        -: 4956:#  define NAMLEN(direct) strlen((direct)->d_name)
        -: 4957:#  define DIR_OPT "DIRENT"
        -: 4958:#else
        -: 4959:#  define dirent direct
        -: 4960:#  define NAMLEN(direct) ((direct)->d_namlen)
        -: 4961:#  ifdef HAVE_SYS_NDIR_H
        -: 4962:#    include <sys/ndir.h>
        -: 4963:#    define DIR_OPT "SYS_NDIR"
        -: 4964:#  endif
        -: 4965:#  ifdef HAVE_SYS_DIR_H
        -: 4966:#    include <sys/dir.h>
        -: 4967:#    define DIR_OPT "SYS_DIR"
        -: 4968:#  endif
        -: 4969:#  ifdef HAVE_NDIR_H
        -: 4970:#    include <ndir.h>
        -: 4971:#    define DIR_OPT "NDIR"
        -: 4972:#  endif
        -: 4973:#  ifndef DIR_OPT
        -: 4974:#    define DIR_OPT "NO_DIR"
        -: 4975:#  endif
        -: 4976:#endif
        -: 4977:
        -: 4978:#ifdef CLOSEDIR_VOID
        -: 4979:# define CLOSEDIR(d) (closedir(d), 0)
        -: 4980:#else
        -: 4981:# define CLOSEDIR(d) closedir(d)
        -: 4982:#endif
        -: 4983:
        -: 4984:#ifdef HAVE_UTIME
        -: 4985:#  ifdef HAVE_UTIME_H
        -: 4986:#    include <utime.h>
        -: 4987:#    define TIME_OPT "UTIME"
        -: 4988:#  else
        -: 4989:#    ifdef HAVE_SYS_UTIME_H
        -: 4990:#      include <sys/utime.h>
        -: 4991:#      define TIME_OPT "SYS_UTIME"
        -: 4992:#    else
        -: 4993:       struct utimbuf {
        -: 4994:         time_t actime;
        -: 4995:         time_t modtime;
        -: 4996:       };
        -: 4997:#      define TIME_OPT "STRUCT_UTIMBUF"
        -: 4998:#    endif
        -: 4999:#  endif
        -: 5000:#else
        -: 5001:#  define TIME_OPT "NO_UTIME"
        -: 5002:#endif
        -: 5003:
        -: 5004:#if !defined(S_ISDIR) && defined(S_IFDIR)
        -: 5005:#  define S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)
        -: 5006:#endif
        -: 5007:#if !defined(S_ISREG) && defined(S_IFREG)
        -: 5008:#  define S_ISREG(m) (((m) & S_IFMT) == S_IFREG)
        -: 5009:#endif
        -: 5010:
        -: 5011:typedef RETSIGTYPE (*sig_type) OF((int));
        -: 5012:
        -: 5013:#ifndef	O_BINARY
        -: 5014:#  define  O_BINARY  0  /* creation mode for open() */
        -: 5015:#endif
        -: 5016:
        -: 5017:#ifndef O_CREAT
        -: 5018:   /* Pure BSD system? */
        -: 5019:#  include <sys/file.h>
        -: 5020:#  ifndef O_CREAT
        -: 5021:#    define O_CREAT FCREAT
        -: 5022:#  endif
        -: 5023:#  ifndef O_EXCL
        -: 5024:#    define O_EXCL FEXCL
        -: 5025:#  endif
        -: 5026:#endif
        -: 5027:
        -: 5028:#ifndef S_IRUSR
        -: 5029:#  define S_IRUSR 0400
        -: 5030:#endif
        -: 5031:#ifndef S_IWUSR
        -: 5032:#  define S_IWUSR 0200
        -: 5033:#endif
        -: 5034:#define RW_USER (S_IRUSR | S_IWUSR)  /* creation mode for open() */
        -: 5035:
        -: 5036:#ifndef MAX_PATH_LEN
        -: 5037:#  define MAX_PATH_LEN   1024 /* max pathname length */
        -: 5038:#endif
        -: 5039:
        -: 5040:#ifndef SEEK_END
        -: 5041:#  define SEEK_END 2
        -: 5042:#endif
        -: 5043:
        -: 5044:#ifndef CHAR_BIT
        -: 5045:#  define CHAR_BIT 8
        -: 5046:#endif
        -: 5047:
        -: 5048:#ifdef off_t
        -: 5049:  off_t lseek OF((int fd, off_t offset, int whence));
        -: 5050:#endif
        -: 5051:
        -: 5052:#ifndef OFF_T_MIN
        -: 5053:#define OFF_T_MIN (~ (off_t) 0 << (sizeof (off_t) * CHAR_BIT - 1))
        -: 5054:#endif
        -: 5055:
        -: 5056:#ifndef OFF_T_MAX
        -: 5057:#define OFF_T_MAX (~ (off_t) 0 - OFF_T_MIN)
        -: 5058:#endif
        -: 5059:
        -: 5060:/* Separator for file name parts (see shorten_name()) */
        -: 5061:#ifdef NO_MULTIPLE_DOTS
        -: 5062:#  define PART_SEP "-"
        -: 5063:#else
        -: 5064:#  define PART_SEP "."
        -: 5065:#endif
        -: 5066:
        -: 5067:		/* global buffers */
        -: 5068:
        -: 5069:DECLARE(uch, inbuf,  INBUFSIZ +INBUF_EXTRA);
        -: 5070:DECLARE(uch, outbuf, OUTBUFSIZ+OUTBUF_EXTRA);
        -: 5071:DECLARE(ush, d_buf,  DIST_BUFSIZE);
        -: 5072:DECLARE(uch, window, 2L*WSIZE);
        -: 5073:#ifndef MAXSEG_64K
        -: 5074:    DECLARE(ush, tab_prefix, 1L<<BITS);
        -: 5075:#else
        -: 5076:    DECLARE(ush, tab_prefix0, 1L<<(BITS-1));
        -: 5077:    DECLARE(ush, tab_prefix1, 1L<<(BITS-1));
        -: 5078:#endif
        -: 5079:
        -: 5080:		/* local variables */
        -: 5081:
        -: 5082:int ascii = 0;        /* convert end-of-lines to local OS conventions */
        -: 5083:int to_stdout = 0;    /* output to stdout (-c) */
        -: 5084:int decompress = 0;   /* decompress (-d) */
        -: 5085:int force = 0;        /* don't ask questions, compress links (-f) */
        -: 5086:int no_name = -1;     /* don't save or restore the original file name */
        -: 5087:int no_time = -1;     /* don't save or restore the original file time */
        -: 5088:int recursive = 0;    /* recurse through directories (-r) */
        -: 5089:int list = 0;         /* list the file contents (-l) */
        -: 5090:int verbose = 0;      /* be verbose (-v) */
        -: 5091:int quiet = 0;        /* be very quiet (-q) */
        -: 5092:int do_lzw = 0;       /* generate output compatible with old compress (-Z) */
        -: 5093:int test = 0;         /* test .gz file integrity */
        -: 5094:int foreground;       /* set if program run in foreground */
        -: 5095:char *progname;       /* program name */
        -: 5096:int maxbits = BITS;   /* max bits per code for LZW */
        -: 5097:int method = DEFLATED;/* compression method */
        -: 5098:int level = 6;        /* compression level */
        -: 5099:int exit_code = OK;   /* program exit code */
        -: 5100:int save_orig_name;   /* set if original name must be saved */
        -: 5101:int last_member;      /* set for .zip and .Z files */
        -: 5102:int part_nb;          /* number of parts in .gz file */
        -: 5103:time_t time_stamp;      /* original time stamp (modification time) */
        -: 5104:off_t ifile_size;      /* input file size, -1 for devices (debug only) */
        -: 5105:char *env;            /* contents of GZIP env variable */
        -: 5106:char **args = NULL;   /* argv pointer if GZIP env variable defined */
        -: 5107:char *z_suffix;       /* default suffix (can be set with --suffix) */
        -: 5108:int  z_len;           /* strlen(z_suffix) */
        -: 5109:
        -: 5110:off_t bytes_in;             /* number of input bytes */
        -: 5111:off_t bytes_out;            /* number of output bytes */
        -: 5112:off_t total_in;		    /* input bytes for all files */
        -: 5113:off_t total_out;	    /* output bytes for all files */
        -: 5114:char ifname[MAX_PATH_LEN]; /* input file name */
        -: 5115:char ofname[MAX_PATH_LEN]; /* output file name */
        -: 5116:int  remove_ofname = 0;	   /* remove output file on error */
        -: 5117:struct stat istat;         /* status for input file */
        -: 5118:int  ifd;                  /* input file descriptor */
        -: 5119:int  ofd;                  /* output file descriptor */
        -: 5120:unsigned insize;           /* valid bytes in inbuf */
        -: 5121:unsigned inptr;            /* index of next byte to be processed in inbuf */
        -: 5122:unsigned outcnt;           /* bytes in output buffer */
        -: 5123:
        -: 5124:struct option longopts[] =
        -: 5125:{
        -: 5126: /* { name  has_arg  *flag  val } */
        -: 5127:    {"ascii",      0, 0, 'a'}, /* ascii text mode */
        -: 5128:    {"to-stdout",  0, 0, 'c'}, /* write output on standard output */
        -: 5129:    {"stdout",     0, 0, 'c'}, /* write output on standard output */
        -: 5130:    {"decompress", 0, 0, 'd'}, /* decompress */
        -: 5131:    {"uncompress", 0, 0, 'd'}, /* decompress */
        -: 5132: /* {"encrypt",    0, 0, 'e'},    encrypt */
        -: 5133:    {"force",      0, 0, 'f'}, /* force overwrite of output file */
        -: 5134:    {"help",       0, 0, 'h'}, /* give help */
        -: 5135: /* {"pkzip",      0, 0, 'k'},    force output in pkzip format */
        -: 5136:    {"list",       0, 0, 'l'}, /* list .gz file contents */
        -: 5137:    {"license",    0, 0, 'L'}, /* display software license */
        -: 5138:    {"no-name",    0, 0, 'n'}, /* don't save or restore original name & time */
        -: 5139:    {"name",       0, 0, 'N'}, /* save or restore original name & time */
        -: 5140:    {"quiet",      0, 0, 'q'}, /* quiet mode */
        -: 5141:    {"silent",     0, 0, 'q'}, /* quiet mode */
        -: 5142:    {"recursive",  0, 0, 'r'}, /* recurse through directories */
        -: 5143:    {"suffix",     1, 0, 'S'}, /* use given suffix instead of .gz */
        -: 5144:    {"test",       0, 0, 't'}, /* test compressed file integrity */
        -: 5145:    {"no-time",    0, 0, 'T'}, /* don't save or restore the time stamp */
        -: 5146:    {"verbose",    0, 0, 'v'}, /* verbose mode */
        -: 5147:    {"version",    0, 0, 'V'}, /* display version number */
        -: 5148:    {"fast",       0, 0, '1'}, /* compress faster */
        -: 5149:    {"best",       0, 0, '9'}, /* compress better */
        -: 5150:    {"lzw",        0, 0, 'Z'}, /* make output compatible with old compress */
        -: 5151:    {"bits",       1, 0, 'b'}, /* max number of bits per code (implies -Z) */
        -: 5152:    { 0, 0, 0, 0 }
        -: 5153:};
        -: 5154:
        -: 5155:/* local functions */
        -: 5156:
        -: 5157:local void usage        OF((void));
        -: 5158:local void help         OF((void));
        -: 5159:local void license      OF((void));
        -: 5160:local void version      OF((void));
        -: 5161:local int input_eof	OF((void));
        -: 5162:local void treat_stdin  OF((void));
        -: 5163:local void treat_file   OF((char *iname));
        -: 5164:local int create_outfile OF((void));
        -: 5165:local int  do_stat      OF((char *name, struct stat *sbuf));
        -: 5166:local char *get_suffix  OF((char *name));
        -: 5167:local int  get_istat    OF((char *iname, struct stat *sbuf));
        -: 5168:local int  make_ofname  OF((void));
        -: 5169:local int  same_file    OF((struct stat *stat1, struct stat *stat2));
        -: 5170:local int name_too_long OF((char *name, struct stat *statb));
        -: 5171:local void shorten_name  OF((char *name));
        -: 5172:local int  get_method   OF((int in));
        -: 5173:local void do_list      OF((int ifd, int method));
        -: 5174:local int  check_ofname OF((void));
        -: 5175:local void copy_stat    OF((struct stat *ifstat));
        -: 5176:local void do_exit      OF((int exitcode));
        -: 5177:      int main          OF((int argc, char **argv));
        -: 5178:int (*work) OF((int infile, int outfile)) = zip; /* function to call */
        -: 5179:
        -: 5180:#ifndef NO_DIR
        -: 5181:local void treat_dir    OF((char *dir));
        -: 5182:#endif
        -: 5183:#ifdef HAVE_UTIME
        -: 5184:local void reset_times  OF((char *name, struct stat *statb));
        -: 5185:#endif
        -: 5186:
        -: 5187:#define strequ(s1, s2) (strcmp((s1),(s2)) == 0)
        -: 5188:
        -: 5189:/* ======================================================================== */
function usage called 0 returned 0% blocks executed 0%
    #####: 5190:local void usage()
        -: 5191:{
    #####: 5192:    printf ("usage: %s [-%scdfhlLnN%stvV19] [-S suffix] [file ...]\n",
call    0 never executed
        -: 5193:	    progname,
        -: 5194:#if O_BINARY
        -: 5195:	    "a",
        -: 5196:#else
        -: 5197:	    "",
        -: 5198:#endif
        -: 5199:#ifdef NO_DIR
        -: 5200:	    ""
        -: 5201:#else
        -: 5202:	    "r"
        -: 5203:#endif
        -: 5204:	    );
    #####: 5205:}
        -: 5206:
        -: 5207:/* ======================================================================== */
function help called 0 returned 0% blocks executed 0%
    #####: 5208:local void help()
        -: 5209:{
        -: 5210:    static char  *help_msg[] = {
        -: 5211:#if O_BINARY
        -: 5212: " -a --ascii       ascii text; convert end-of-lines using local conventions",
        -: 5213:#endif
        -: 5214: " -c --stdout      write on standard output, keep original files unchanged",
        -: 5215: " -d --decompress  decompress",
        -: 5216:/* -e --encrypt     encrypt */
        -: 5217: " -f --force       force overwrite of output file and compress links",
        -: 5218: " -h --help        give this help",
        -: 5219:/* -k --pkzip       force output in pkzip format */
        -: 5220: " -l --list        list compressed file contents",
        -: 5221: " -L --license     display software license",
        -: 5222:#ifdef UNDOCUMENTED
        -: 5223: " -m --no-time     do not save or restore the original modification time",
        -: 5224: " -M --time        save or restore the original modification time",
        -: 5225:#endif
        -: 5226: " -n --no-name     do not save or restore the original name and time stamp",
        -: 5227: " -N --name        save or restore the original name and time stamp",
        -: 5228: " -q --quiet       suppress all warnings",
        -: 5229:#ifndef NO_DIR
        -: 5230: " -r --recursive   operate recursively on directories",
        -: 5231:#endif
        -: 5232: " -S .suf  --suffix .suf     use suffix .suf on compressed files",
        -: 5233: " -t --test        test compressed file integrity",
        -: 5234: " -v --verbose     verbose mode",
        -: 5235: " -V --version     display version number",
        -: 5236: " -1 --fast        compress faster",
        -: 5237: " -9 --best        compress better",
        -: 5238:#ifdef LZW
        -: 5239: " -Z --lzw         produce output compatible with old compress",
        -: 5240: " -b --bits maxbits   max number of bits per code (implies -Z)",
        -: 5241:#endif
        -: 5242: " file...          files to (de)compress. If none given, use standard input.",
        -: 5243: "Report bugs to <bug-gzip@gnu.org>.",
        -: 5244:  0};
    #####: 5245:    char **p = help_msg;
        -: 5246:
    #####: 5247:    printf ("%s %s\n(%s)\n", progname, VERSION, REVDATE);
call    0 never executed
    #####: 5248:    usage();
call    0 never executed
    #####: 5249:    while (*p) printf ("%s\n", *p++);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 5250:}
        -: 5251:
        -: 5252:/* ======================================================================== */
function license called 0 returned 0% blocks executed 0%
    #####: 5253:local void license()
        -: 5254:{
    #####: 5255:    char **p = license_msg;
        -: 5256:
    #####: 5257:    printf ("%s %s\n(%s)\n", progname, VERSION, REVDATE);
call    0 never executed
    #####: 5258:    while (*p) printf ("%s\n", *p++);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 5259:}
        -: 5260:
        -: 5261:/* ======================================================================== */
function version called 0 returned 0% blocks executed 0%
    #####: 5262:local void version()
        -: 5263:{
    #####: 5264:    license ();
call    0 never executed
    #####: 5265:    printf ("Compilation options:\n%s %s ", DIR_OPT, TIME_OPT);
call    0 never executed
        -: 5266:#ifdef STDC_HEADERS
    #####: 5267:    printf ("STDC_HEADERS ");
call    0 never executed
        -: 5268:#endif
        -: 5269:#ifdef HAVE_UNISTD_H
    #####: 5270:    printf ("HAVE_UNISTD_H ");
call    0 never executed
        -: 5271:#endif
        -: 5272:#ifdef HAVE_MEMORY_H
    #####: 5273:    printf ("HAVE_MEMORY_H ");
call    0 never executed
        -: 5274:#endif
        -: 5275:#ifdef HAVE_STRING_H
    #####: 5276:    printf ("HAVE_STRING_H ");
call    0 never executed
        -: 5277:#endif
        -: 5278:#ifdef HAVE_LSTAT
        -: 5279:    printf ("HAVE_LSTAT ");
        -: 5280:#endif
        -: 5281:#ifdef NO_MULTIPLE_DOTS
        -: 5282:    printf ("NO_MULTIPLE_DOTS ");
        -: 5283:#endif
        -: 5284:#ifdef HAVE_CHOWN
        -: 5285:    printf ("HAVE_CHOWN ");
        -: 5286:#endif
        -: 5287:#ifdef PROTO
        -: 5288:    printf ("PROTO ");
        -: 5289:#endif
        -: 5290:#ifdef ASMV
        -: 5291:    printf ("ASMV ");
        -: 5292:#endif
        -: 5293:#ifdef DEBUG
        -: 5294:    printf ("DEBUG ");
        -: 5295:#endif
        -: 5296:#ifdef DYN_ALLOC
        -: 5297:    printf ("DYN_ALLOC ");
        -: 5298:#endif
        -: 5299:#ifdef MAXSEG_64K
        -: 5300:    printf ("MAXSEG_64K");
        -: 5301:#endif
    #####: 5302:    printf ("\n");
call    0 never executed
    #####: 5303:    printf ("Written by Jean-loup Gailly.\n");
call    0 never executed
    #####: 5304:}
        -: 5305:
function progerror called 0 returned 0% blocks executed 0%
    #####: 5306:local void progerror (string)
        -: 5307:    char *string;
        -: 5308:{
    #####: 5309:    int e = errno;
    #####: 5310:    fprintf(stderr, "%s: ", progname);
call    0 never executed
    #####: 5311:    errno = e;
    #####: 5312:    perror(string);
call    0 never executed
    #####: 5313:    exit_code = ERROR;
    #####: 5314:}
        -: 5315:
        -: 5316:/* ======================================================================== */
function main called 1 returned 0% blocks executed 43%
        1: 5317:int main (argc, argv)
        -: 5318:    int argc;
        -: 5319:    char **argv;
        -: 5320:{
        -: 5321:    int file_count;     /* number of files to precess */
        -: 5322:    int proglen;        /* length of progname */
        -: 5323:    int optc;           /* current option */
        -: 5324:
        -: 5325:    EXPAND(argc, argv); /* wild card expansion if necessary */
        -: 5326:
        1: 5327:    progname = base_name (argv[0]);
call    0 returned 1
        1: 5328:    proglen = strlen(progname);
        -: 5329:
        -: 5330:    /* Suppress .exe for MSDOS, OS/2 and VMS: */
        1: 5331:    if (proglen > 4 && strequ(progname+proglen-4, ".exe")) {
branch  0 taken 1 (fallthrough)
branch  1 taken 0
branch  2 taken 1 (fallthrough)
branch  3 taken 0
        1: 5332:        progname[proglen-4] = '\0';
        -: 5333:    }
        -: 5334:
        -: 5335:    /* Add options in GZIP environment variable if there is one */
        1: 5336:    env = add_envopt(&argc, &argv, OPTIONS_VAR);
call    0 returned 1
       1*: 5337:    if (env != NULL) args = argv;
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -: 5338:
        1: 5339:    foreground = signal(SIGINT, SIG_IGN) != SIG_IGN;
call    0 returned 1
        1: 5340:    if (foreground) {
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 5341:	(void) signal (SIGINT, (sig_type)abort_gzip);
call    0 returned 1
        -: 5342:    }
        -: 5343:#ifdef SIGTERM
        1: 5344:    if (signal(SIGTERM, SIG_IGN) != SIG_IGN) {
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0
        1: 5345:	(void) signal(SIGTERM, (sig_type)abort_gzip);
call    0 returned 1
        -: 5346:    }
        -: 5347:#endif
        -: 5348:#ifdef SIGHUP
        1: 5349:    if (signal(SIGHUP, SIG_IGN) != SIG_IGN) {
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0
        1: 5350:	(void) signal(SIGHUP,  (sig_type)abort_gzip);
call    0 returned 1
        -: 5351:    }
        -: 5352:#endif
        -: 5353:
        -: 5354:#ifndef GNU_STANDARD
        -: 5355:    /* For compatibility with old compress, use program name as an option.
        -: 5356:     * If you compile with -DGNU_STANDARD, this program will behave as
        -: 5357:     * gzip even if it is invoked under the name gunzip or zcat.
        -: 5358:     *
        -: 5359:     * Systems which do not support links can still use -d or -dc.
        -: 5360:     * Ignore an .exe extension for MSDOS, OS/2 and VMS.
        -: 5361:     */
        1: 5362:    if (  strncmp(progname, "un",  2) == 0     /* ungzip, uncompress */
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 5363:       || strncmp(progname, "gun", 3) == 0) {  /* gunzip */
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 5364:	decompress = 1;
        1: 5365:    } else if (strequ(progname+1, "cat")       /* zcat, pcat, gcat */
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 5366:	    || strequ(progname, "gzcat")) {    /* gzcat */
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 5367:	decompress = to_stdout = 1;
        -: 5368:    }
        -: 5369:#endif
        -: 5370:
        1: 5371:    z_suffix = Z_SUFFIX;
        1: 5372:    z_len = strlen(z_suffix);
        -: 5373:
        2: 5374:    while ((optc = getopt_long (argc, argv, "ab:cdfhH?lLmMnNqrS:tvVZ123456789",
call    0 returned 2
        2: 5375:				longopts, (int *)0)) != -1) {
branch  0 taken 1
branch  1 taken 1 (fallthrough)
        1: 5376:	switch (optc) {
branch  0 taken 0
branch  1 taken 0
branch  2 taken 0
branch  3 taken 0
branch  4 taken 0
branch  5 taken 0
branch  6 taken 0
branch  7 taken 0
branch  8 taken 0
branch  9 taken 0
branch 10 taken 0
branch 11 taken 0
branch 12 taken 0
branch 13 taken 0
branch 14 taken 0
branch 15 taken 0
branch 16 taken 0
branch 17 taken 0
branch 18 taken 0
branch 19 taken 1
branch 20 taken 0
    #####: 5377:        case 'a':
    #####: 5378:            ascii = 1; break;
    #####: 5379:	case 'b':
    #####: 5380:	    maxbits = atoi(optarg);
    #####: 5381:	    break;
    #####: 5382:	case 'c':
    #####: 5383:	    to_stdout = 1; break;
    #####: 5384:	case 'd':
    #####: 5385:	    decompress = 1; break;
    #####: 5386:	case 'f':
    #####: 5387:	    force++; break;
    #####: 5388:	case 'h': case 'H': case '?':
    #####: 5389:	    help(); do_exit(OK); break;
call    0 never executed
call    1 never executed
    #####: 5390:	case 'l':
    #####: 5391:	    list = decompress = to_stdout = 1; break;
    #####: 5392:	case 'L':
    #####: 5393:	    license(); do_exit(OK); break;
call    0 never executed
call    1 never executed
    #####: 5394:	case 'm': /* undocumented, may change later */
    #####: 5395:	    no_time = 1; break;
    #####: 5396:	case 'M': /* undocumented, may change later */
    #####: 5397:	    no_time = 0; break;
    #####: 5398:	case 'n':
    #####: 5399:	    no_name = no_time = 1; break;
    #####: 5400:	case 'N':
    #####: 5401:	    no_name = no_time = 0; break;
    #####: 5402:	case 'q':
    #####: 5403:	    quiet = 1; verbose = 0; break;
    #####: 5404:	case 'r':
        -: 5405:#ifdef NO_DIR
        -: 5406:	    fprintf(stderr, "%s: -r not supported on this system\n", progname);
        -: 5407:	    usage();
        -: 5408:	    do_exit(ERROR); break;
        -: 5409:#else
    #####: 5410:	    recursive = 1; break;
        -: 5411:#endif
    #####: 5412:	case 'S':
        -: 5413:#ifdef NO_MULTIPLE_DOTS
        -: 5414:            if (*optarg == '.') optarg++;
        -: 5415:#endif
    #####: 5416:            z_len = strlen(optarg);
    #####: 5417:	    z_suffix = optarg;
    #####: 5418:            break;
    #####: 5419:	case 't':
    #####: 5420:	    test = decompress = to_stdout = 1;
    #####: 5421:	    break;
    #####: 5422:	case 'v':
    #####: 5423:	    verbose++; quiet = 0; break;
    #####: 5424:	case 'V':
    #####: 5425:	    version(); do_exit(OK); break;
call    0 never executed
call    1 never executed
    #####: 5426:	case 'Z':
        -: 5427:#ifdef LZW
        -: 5428:	    do_lzw = 1; break;
        -: 5429:#else
    #####: 5430:	    fprintf(stderr, "%s: -Z not supported in this version\n",
call    0 never executed
        -: 5431:		    progname);
    #####: 5432:	    usage();
call    0 never executed
    #####: 5433:	    do_exit(ERROR); break;
call    0 never executed
        -: 5434:#endif
        1: 5435:	case '1':  case '2':  case '3':  case '4':
        -: 5436:	case '5':  case '6':  case '7':  case '8':  case '9':
        1: 5437:	    level = optc - '0';
        1: 5438:	    break;
    #####: 5439:	default:
        -: 5440:	    /* Error message already emitted by getopt_long. */
    #####: 5441:	    usage();
call    0 never executed
    #####: 5442:	    do_exit(ERROR);
call    0 never executed
        -: 5443:	}
        -: 5444:    } /* loop on all arguments */
        -: 5445:
        -: 5446:#ifdef SIGPIPE
        -: 5447:    /* Ignore "Broken Pipe" message with --quiet */
       1*: 5448:    if (quiet && signal (SIGPIPE, SIG_IGN) != SIG_IGN)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 5449:      signal (SIGPIPE, (sig_type) abort_gzip);
call    0 never executed
        -: 5450:#endif
        -: 5451:
        -: 5452:    /* By default, save name and timestamp on compression but do not
        -: 5453:     * restore them on decompression.
        -: 5454:     */
        1: 5455:    if (no_time < 0) no_time = decompress;
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 5456:    if (no_name < 0) no_name = decompress;
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -: 5457:
        1: 5458:    file_count = argc - optind;
        -: 5459:
        -: 5460:#if O_BINARY
        -: 5461:#else
       1*: 5462:    if (ascii && !quiet) {
branch  0 taken 0 (fallthrough)
branch  1 taken 1
branch  2 never executed
branch  3 never executed
    #####: 5463:	fprintf(stderr, "%s: option --ascii ignored on this system\n",
call    0 never executed
        -: 5464:		progname);
        -: 5465:    }
        -: 5466:#endif
       1*: 5467:    if ((z_len == 0 && !decompress) || z_len > MAX_SUFFIX) {
branch  0 taken 0 (fallthrough)
branch  1 taken 1
branch  2 never executed
branch  3 never executed
branch  4 taken 0 (fallthrough)
branch  5 taken 1
    #####: 5468:        fprintf(stderr, "%s: incorrect suffix '%s'\n",
call    0 never executed
        -: 5469:                progname, optarg);
    #####: 5470:        do_exit(ERROR);
call    0 never executed
        -: 5471:    }
       1*: 5472:    if (do_lzw && !decompress) work = lzw;
branch  0 taken 0 (fallthrough)
branch  1 taken 1
branch  2 never executed
branch  3 never executed
        -: 5473:
        -: 5474:    /* Allocate all global buffers (for DYN_ALLOC option) */
        -: 5475:    ALLOC(uch, inbuf,  INBUFSIZ +INBUF_EXTRA);
        -: 5476:    ALLOC(uch, outbuf, OUTBUFSIZ+OUTBUF_EXTRA);
        -: 5477:    ALLOC(ush, d_buf,  DIST_BUFSIZE);
        -: 5478:    ALLOC(uch, window, 2L*WSIZE);
        -: 5479:#ifndef MAXSEG_64K
        -: 5480:    ALLOC(ush, tab_prefix, 1L<<BITS);
        -: 5481:#else
        -: 5482:    ALLOC(ush, tab_prefix0, 1L<<(BITS-1));
        -: 5483:    ALLOC(ush, tab_prefix1, 1L<<(BITS-1));
        -: 5484:#endif
        -: 5485:
        -: 5486:    /* And get to work */
        1: 5487:    if (file_count != 0) {
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 5488:	if (to_stdout && !test && !list && (!decompress || !ascii)) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -: 5489:	    SET_BINARY_MODE(fileno(stdout));
        -: 5490:	}
    #####: 5491:        while (optind < argc) {
branch  0 never executed
branch  1 never executed
    #####: 5492:	    treat_file(argv[optind++]);
call    0 never executed
        -: 5493:	}
        -: 5494:    } else {  /* Standard input */
        1: 5495:	treat_stdin();
call    0 returned 1
        -: 5496:    }
       1*: 5497:    if (list && !quiet && file_count > 1) {
branch  0 taken 0 (fallthrough)
branch  1 taken 1
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 5498:	do_list(-1, -1); /* print totals */
call    0 never executed
        -: 5499:    }
        1: 5500:    do_exit(exit_code);
call    0 returned 0
    #####: 5501:    return exit_code; /* just to avoid lint warning */
        -: 5502:}
        -: 5503:
        -: 5504:/* Return nonzero when at end of file on input.  */
        -: 5505:local int
function input_eof called 0 returned 0% blocks executed 0%
    #####: 5506:input_eof ()
        -: 5507:{
    #####: 5508:  if (!decompress || last_member)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 5509:    return 1;
        -: 5510:
    #####: 5511:  if (inptr == insize)
branch  0 never executed
branch  1 never executed
        -: 5512:    {
    #####: 5513:      if (insize != INBUFSIZ || fill_inbuf (1) == EOF)
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 5514:	return 1;
        -: 5515:
        -: 5516:      /* Unget the char that fill_inbuf got.  */
    #####: 5517:      inptr = 0;
        -: 5518:    }
        -: 5519:
    #####: 5520:  return 0;
        -: 5521:}
        -: 5522:
        -: 5523:/* ========================================================================
        -: 5524: * Compress or decompress stdin
        -: 5525: */
function treat_stdin called 1 returned 100% blocks executed 48%
        1: 5526:local void treat_stdin()
        -: 5527:{
        2: 5528:    if (!force && !list &&
branch  0 taken 1 (fallthrough)
branch  1 taken 0
branch  2 taken 1 (fallthrough)
branch  3 taken 0
branch  4 taken 0 (fallthrough)
branch  5 taken 1
       1*: 5529:	isatty(fileno((FILE *)(decompress ? stdin : stdout)))) {
branch  0 taken 0 (fallthrough)
branch  1 taken 1
call    2 returned 1
call    3 returned 1
        -: 5530:	/* Do not send compressed data to the terminal or read it from
        -: 5531:	 * the terminal. We get here when user invoked the program
        -: 5532:	 * without parameters, so be helpful. According to the GNU standards:
        -: 5533:	 *
        -: 5534:	 *   If there is one behavior you think is most useful when the output
        -: 5535:	 *   is to a terminal, and another that you think is most useful when
        -: 5536:	 *   the output is a file or a pipe, then it is usually best to make
        -: 5537:	 *   the default behavior the one that is useful with output to a
        -: 5538:	 *   terminal, and have an option for the other behavior.
        -: 5539:	 *
        -: 5540:	 * Here we use the --force option to get the other behavior.
        -: 5541:	 */
    #####: 5542:	fprintf(stderr,
call    0 never executed
        -: 5543:    "%s: compressed data not %s a terminal. Use -f to force %scompression.\n",
    #####: 5544:		progname, decompress ? "read from" : "written to",
branch  0 never executed
branch  1 never executed
    #####: 5545:		decompress ? "de" : "");
branch  0 never executed
branch  1 never executed
    #####: 5546:	fprintf(stderr,"For help, type: %s -h\n", progname);
call    0 never executed
    #####: 5547:	do_exit(ERROR);
call    0 never executed
        -: 5548:    }
        -: 5549:
        1: 5550:    if (decompress || !ascii) {
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -: 5551:	SET_BINARY_MODE(fileno(stdin));
        -: 5552:    }
       1*: 5553:    if (!test && !list && (!decompress || !ascii)) {
branch  0 taken 1 (fallthrough)
branch  1 taken 0
branch  2 taken 1 (fallthrough)
branch  3 taken 0
branch  4 taken 0 (fallthrough)
branch  5 taken 1
        -: 5554:	SET_BINARY_MODE(fileno(stdout));
        -: 5555:    }
        1: 5556:    strcpy(ifname, "stdin");
        1: 5557:    strcpy(ofname, "stdout");
        -: 5558:
        -: 5559:    /* Get the time stamp on the input file. */
        1: 5560:    time_stamp = 0; /* time unknown by default */
        -: 5561:
        -: 5562:#ifndef NO_STDIN_FSTAT
        1: 5563:    if (list || !no_time) {
branch  0 taken 1 (fallthrough)
branch  1 taken 0
branch  2 taken 1 (fallthrough)
branch  3 taken 0
        1: 5564:	if (fstat(fileno(stdin), &istat) != 0) {
call    0 returned 1
call    1 returned 1
branch  2 taken 0 (fallthrough)
branch  3 taken 1
    #####: 5565:	    progerror("standard input");
call    0 never executed
    #####: 5566:	    do_exit(ERROR);
call    0 never executed
        -: 5567:	}
        -: 5568:# ifdef NO_PIPE_TIMESTAMP
        -: 5569:	if (S_ISREG(istat.st_mode))
        -: 5570:# endif
        -: 5571:	/* this is not original code -- inserted by MAPSTEXT */
        -: 5572:	/* time_stamp = istat.st_mtime; */
        1: 5573:	time_stamp = 0;
        -: 5574:#endif /* NO_STDIN_FSTAT */
        -: 5575:    }
        1: 5576:    ifile_size = -1L; /* convention for unknown size */
        -: 5577:
        1: 5578:    clear_bufs(); /* clear input and output buffers */
call    0 returned 1
        1: 5579:    to_stdout = 1;
        1: 5580:    part_nb = 0;
        -: 5581:
        1: 5582:    if (decompress) {
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 5583:	method = get_method(ifd);
call    0 never executed
    #####: 5584:	if (method < 0) {
branch  0 never executed
branch  1 never executed
    #####: 5585:	    do_exit(exit_code); /* error message already emitted */
call    0 never executed
        -: 5586:	}
        -: 5587:    }
        1: 5588:    if (list) {
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 5589:        do_list(ifd, method);
call    0 never executed
    #####: 5590:        return;
        -: 5591:    }
        -: 5592:
        -: 5593:    /* Actually do the compression/decompression. Loop over zipped members.
        -: 5594:     */
        -: 5595:    for (;;) {
       1*: 5596:	if ((*work)(fileno(stdin), fileno(stdout)) != OK) return;
call    0 returned 1
call    1 returned 1
call    2 returned 1
branch  3 taken 0 (fallthrough)
branch  4 taken 1
        -: 5597:
        -: 5598:#ifdef FAULTY_F_TW_4
       1*: 5599:	if (!decompress || last_member || inptr == insize) break;
branch  0 taken 0 (fallthrough)
branch  1 taken 1
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 5600:#else
        -: 5601:	if (input_eof ())
        -: 5602:	  break;
        -: 5603:#endif
        -: 5604:
    #####: 5605:	method = get_method(ifd);
call    0 never executed
    #####: 5606:	if (method < 0) return; /* error message already emitted */
branch  0 never executed
branch  1 never executed
    #####: 5607:	bytes_out = 0;            /* required for length check */
        -: 5608:    }
        -: 5609:
        1: 5610:    if (verbose) {
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 5611:	if (test) {
branch  0 never executed
branch  1 never executed
    #####: 5612:	    fprintf(stderr, " OK\n");
call    0 never executed
        -: 5613:
    #####: 5614:	} else if (!decompress) {
branch  0 never executed
branch  1 never executed
    #####: 5615:	    display_ratio(bytes_in-(bytes_out-header_bytes), bytes_in, stderr);
call    0 never executed
    #####: 5616:	    fprintf(stderr, "\n");
call    0 never executed
        -: 5617:#ifdef DISPLAY_STDIN_RATIO
        -: 5618:	} else {
        -: 5619:	    display_ratio(bytes_out-(bytes_in-header_bytes), bytes_out,stderr);
        -: 5620:	    fprintf(stderr, "\n");
        -: 5621:#endif
        -: 5622:	}
        -: 5623:    }
        -: 5624:}
        -: 5625:
        -: 5626:/* ========================================================================
        -: 5627: * Compress or decompress the given file
        -: 5628: */
function treat_file called 0 returned 0% blocks executed 0%
    #####: 5629:local void treat_file(iname)
        -: 5630:    char *iname;
        -: 5631:{
        -: 5632:    /* Accept "-" as synonym for stdin */
    #####: 5633:    if (strequ(iname, "-")) {
branch  0 never executed
branch  1 never executed
    #####: 5634:	int cflag = to_stdout;
    #####: 5635:	treat_stdin();
call    0 never executed
    #####: 5636:	to_stdout = cflag;
    #####: 5637:	return;
        -: 5638:    }
        -: 5639:
        -: 5640:    /* Check if the input file is present, set ifname and istat: */
    #####: 5641:    if (get_istat(iname, &istat) != OK) return;
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 5642:
        -: 5643:    /* If the input name is that of a directory, recurse or ignore: */
    #####: 5644:    if (S_ISDIR(istat.st_mode)) {
branch  0 never executed
branch  1 never executed
        -: 5645:#ifndef NO_DIR
    #####: 5646:	if (recursive) {
branch  0 never executed
branch  1 never executed
        -: 5647:	    struct stat st;
    #####: 5648:	    st = istat;
    #####: 5649:	    treat_dir(iname);
call    0 never executed
        -: 5650:	    /* Warning: ifname is now garbage */
        -: 5651:#  ifndef NO_UTIME
    #####: 5652:	    reset_times (iname, &st);
call    0 never executed
        -: 5653:#  endif
        -: 5654:	} else
        -: 5655:#endif
    #####: 5656:	WARN((stderr,"%s: %s is a directory -- ignored\n", progname, ifname));
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 5657:	return;
        -: 5658:    }
    #####: 5659:    if (!S_ISREG(istat.st_mode)) {
branch  0 never executed
branch  1 never executed
    #####: 5660:	WARN((stderr,
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 5661:	      "%s: %s is not a directory or a regular file - ignored\n",
        -: 5662:	      progname, ifname));
    #####: 5663:	return;
        -: 5664:    }
    #####: 5665:    if (istat.st_nlink > 1 && !to_stdout && !force) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 5666:	WARN((stderr, "%s: %s has %d other link%c -- unchanged\n",
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
        -: 5667:	      progname, ifname,
        -: 5668:	      (int)istat.st_nlink - 1, istat.st_nlink > 2 ? 's' : ' '));
    #####: 5669:	return;
        -: 5670:    }
        -: 5671:
    #####: 5672:    ifile_size = istat.st_size;
        -: 5673:    /* this is not original code -- inserted by MAPSTEXT */
        -: 5674:    /* time_stamp = no_time && !list ? 0 : istat.st_mtime; */
    #####: 5675:    time_stamp = 0;
        -: 5676:
        -: 5677:    /* Generate output file name. For -r and (-t or -l), skip files
        -: 5678:     * without a valid gzip suffix (check done in make_ofname).
        -: 5679:     */
    #####: 5680:    if (to_stdout && !list && !test) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 5681:	strcpy(ofname, "stdout");
        -: 5682:
    #####: 5683:    } else if (make_ofname() != OK) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 5684:	return;
        -: 5685:    }
        -: 5686:
        -: 5687:    /* Open the input file and determine compression method. The mode
        -: 5688:     * parameter is ignored but required by some systems (VMS) and forbidden
        -: 5689:     * on other systems (MacOS).
        -: 5690:     */
    #####: 5691:    ifd = OPEN(ifname, ascii && !decompress ? O_RDONLY : O_RDONLY | O_BINARY,
call    0 never executed
        -: 5692:	       RW_USER);
    #####: 5693:    if (ifd == -1) {
branch  0 never executed
branch  1 never executed
    #####: 5694:	progerror(ifname);
call    0 never executed
    #####: 5695:	return;
        -: 5696:    }
    #####: 5697:    clear_bufs(); /* clear input and output buffers */
call    0 never executed
    #####: 5698:    part_nb = 0;
        -: 5699:
    #####: 5700:    if (decompress) {
branch  0 never executed
branch  1 never executed
    #####: 5701:	method = get_method(ifd); /* updates ofname if original given */
call    0 never executed
    #####: 5702:	if (method < 0) {
branch  0 never executed
branch  1 never executed
    #####: 5703:	    close(ifd);
call    0 never executed
    #####: 5704:	    return;               /* error message already emitted */
        -: 5705:	}
        -: 5706:    }
    #####: 5707:    if (list) {
branch  0 never executed
branch  1 never executed
    #####: 5708:        do_list(ifd, method);
call    0 never executed
    #####: 5709:        close(ifd);
call    0 never executed
    #####: 5710:        return;
        -: 5711:    }
        -: 5712:
        -: 5713:    /* If compressing to a file, check if ofname is not ambiguous
        -: 5714:     * because the operating system truncates names. Otherwise, generate
        -: 5715:     * a new ofname and save the original name in the compressed file.
        -: 5716:     */
    #####: 5717:    if (to_stdout) {
branch  0 never executed
branch  1 never executed
    #####: 5718:	ofd = fileno(stdout);
call    0 never executed
        -: 5719:	/* keep remove_ofname as zero */
        -: 5720:    } else {
    #####: 5721:	if (create_outfile() != OK) return;
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 5722:
    #####: 5723:	if (!decompress && save_orig_name && !verbose && !quiet) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####: 5724:	    fprintf(stderr, "%s: %s compressed to %s\n",
call    0 never executed
        -: 5725:		    progname, ifname, ofname);
        -: 5726:	}
        -: 5727:    }
        -: 5728:    /* Keep the name even if not truncated except with --no-name: */
    #####: 5729:    if (!save_orig_name) save_orig_name = !no_name;
branch  0 never executed
branch  1 never executed
        -: 5730:
    #####: 5731:    if (verbose) {
branch  0 never executed
branch  1 never executed
    #####: 5732:	fprintf(stderr, "%s:\t%s", ifname, (int)strlen(ifname) >= 15 ? 
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 5733:		"" : ((int)strlen(ifname) >= 7 ? "\t" : "\t\t"));
branch  0 never executed
branch  1 never executed
        -: 5734:    }
        -: 5735:
        -: 5736:    /* Actually do the compression/decompression. Loop over zipped members.
        -: 5737:     */
        -: 5738:    for (;;) {
    #####: 5739:	if ((*work)(ifd, ofd) != OK) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 5740:	    method = -1; /* force cleanup */
    #####: 5741:	    break;
        -: 5742:	}
        -: 5743:
    #####: 5744:	if (input_eof ())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 5745:	  break;
        -: 5746:
    #####: 5747:	method = get_method(ifd);
call    0 never executed
    #####: 5748:	if (method < 0) break;    /* error message already emitted */
branch  0 never executed
branch  1 never executed
    #####: 5749:	bytes_out = 0;            /* required for length check */
        -: 5750:    }
        -: 5751:
    #####: 5752:    close(ifd);
call    0 never executed
    #####: 5753:    if (!to_stdout && close(ofd)) {
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 5754:	write_error();
call    0 never executed
        -: 5755:    }
    #####: 5756:    if (method == -1) {
branch  0 never executed
branch  1 never executed
    #####: 5757:	if (!to_stdout) xunlink (ofname);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 5758:	return;
        -: 5759:    }
        -: 5760:    /* Display statistics */
    #####: 5761:    if(verbose) {
branch  0 never executed
branch  1 never executed
    #####: 5762:	if (test) {
branch  0 never executed
branch  1 never executed
    #####: 5763:	    fprintf(stderr, " OK");
call    0 never executed
    #####: 5764:	} else if (decompress) {
branch  0 never executed
branch  1 never executed
    #####: 5765:	    display_ratio(bytes_out-(bytes_in-header_bytes), bytes_out,stderr);
call    0 never executed
        -: 5766:	} else {
    #####: 5767:	    display_ratio(bytes_in-(bytes_out-header_bytes), bytes_in, stderr);
call    0 never executed
        -: 5768:	}
    #####: 5769:	if (!test && !to_stdout) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 5770:	    fprintf(stderr, " -- replaced with %s", ofname);
call    0 never executed
        -: 5771:	}
    #####: 5772:	fprintf(stderr, "\n");
call    0 never executed
        -: 5773:    }
        -: 5774:    /* Copy modes, times, ownership, and remove the input file */
    #####: 5775:    if (!to_stdout) {
branch  0 never executed
branch  1 never executed
    #####: 5776:	copy_stat(&istat);
call    0 never executed
        -: 5777:    }
        -: 5778:}
        -: 5779:
        -: 5780:/* ========================================================================
        -: 5781: * Create the output file. Return OK or ERROR.
        -: 5782: * Try several times if necessary to avoid truncating the z_suffix. For
        -: 5783: * example, do not create a compressed file of name "1234567890123."
        -: 5784: * Sets save_orig_name to true if the file name has been truncated.
        -: 5785: * IN assertions: the input file has already been open (ifd is set) and
        -: 5786: *   ofname has already been updated if there was an original name.
        -: 5787: * OUT assertions: ifd and ofd are closed in case of error.
        -: 5788: */
function create_outfile called 0 returned 0% blocks executed 0%
    #####: 5789:local int create_outfile()
        -: 5790:{
        -: 5791:    struct stat	ostat; /* stat for ofname */
    #####: 5792:    int flags = O_WRONLY | O_CREAT | O_EXCL | O_BINARY;
        -: 5793:
    #####: 5794:    if (ascii && decompress) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 5795:	flags &= ~O_BINARY; /* force ascii text mode */
        -: 5796:    }
        -: 5797:    for (;;) {
        -: 5798:	/* Make sure that ofname is not an existing file */
    #####: 5799:	if (check_ofname() != OK) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 5800:	    close(ifd);
call    0 never executed
    #####: 5801:	    return ERROR;
        -: 5802:	}
        -: 5803:	/* Create the output file */
    #####: 5804:	remove_ofname = 1;
    #####: 5805:	ofd = OPEN(ofname, flags, RW_USER);
call    0 never executed
    #####: 5806:	if (ofd == -1) {
branch  0 never executed
branch  1 never executed
    #####: 5807:	    progerror(ofname);
call    0 never executed
    #####: 5808:	    close(ifd);
call    0 never executed
    #####: 5809:	    return ERROR;
        -: 5810:	}
        -: 5811:
        -: 5812:	/* Check for name truncation on new file (1234567890123.gz) */
        -: 5813:#ifdef NO_FSTAT
        -: 5814:	if (stat(ofname, &ostat) != 0) {
        -: 5815:#else
    #####: 5816:	if (fstat(ofd, &ostat) != 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 5817:#endif
    #####: 5818:	    progerror(ofname);
call    0 never executed
    #####: 5819:	    close(ifd); close(ofd);
call    0 never executed
call    1 never executed
    #####: 5820:	    xunlink (ofname);
call    0 never executed
    #####: 5821:	    return ERROR;
        -: 5822:	}
    #####: 5823:	if (!name_too_long(ofname, &ostat)) return OK;
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 5824:
    #####: 5825:	if (decompress) {
branch  0 never executed
branch  1 never executed
        -: 5826:	    /* name might be too long if an original name was saved */
    #####: 5827:	    WARN((stderr, "%s: %s: warning, name truncated\n",
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 5828:		  progname, ofname));
    #####: 5829:	    return OK;
        -: 5830:	}
    #####: 5831:	close(ofd);
call    0 never executed
    #####: 5832:	xunlink (ofname);
call    0 never executed
        -: 5833:#ifdef NO_MULTIPLE_DOTS
        -: 5834:	/* Should never happen, see check_ofname() */
        -: 5835:	fprintf(stderr, "%s: %s: name too long\n", progname, ofname);
        -: 5836:	do_exit(ERROR);
        -: 5837:#endif
    #####: 5838:	shorten_name(ofname);
call    0 never executed
        -: 5839:    }
        -: 5840:}
        -: 5841:
        -: 5842:/* ========================================================================
        -: 5843: * Use lstat if available, except for -c or -f. Use stat otherwise.
        -: 5844: * This allows links when not removing the original file.
        -: 5845: */
function do_stat called 0 returned 0% blocks executed 0%
    #####: 5846:local int do_stat(name, sbuf)
        -: 5847:    char *name;
        -: 5848:    struct stat *sbuf;
        -: 5849:{
    #####: 5850:    errno = 0;
        -: 5851:#ifdef HAVE_LSTAT
        -: 5852:    if (!to_stdout && !force) {
        -: 5853:	return lstat(name, sbuf);
        -: 5854:    }
        -: 5855:#endif
    #####: 5856:    return stat(name, sbuf);
call    0 never executed
        -: 5857:}
        -: 5858:
        -: 5859:/* ========================================================================
        -: 5860: * Return a pointer to the 'z' suffix of a file name, or NULL. For all
        -: 5861: * systems, ".gz", ".z", ".Z", ".taz", ".tgz", "-gz", "-z" and "_z" are
        -: 5862: * accepted suffixes, in addition to the value of the --suffix option.
        -: 5863: * ".tgz" is a useful convention for tar.z files on systems limited
        -: 5864: * to 3 characters extensions. On such systems, ".?z" and ".??z" are
        -: 5865: * also accepted suffixes. For Unix, we do not want to accept any
        -: 5866: * .??z suffix as indicating a compressed file; some people use .xyz
        -: 5867: * to denote volume data.
        -: 5868: *   On systems allowing multiple versions of the same file (such as VMS),
        -: 5869: * this function removes any version suffix in the given name.
        -: 5870: */
function get_suffix called 0 returned 0% blocks executed 0%
    #####: 5871:local char *get_suffix(name)
        -: 5872:    char *name;
        -: 5873:{
        -: 5874:    int nlen, slen;
        -: 5875:    char suffix[MAX_SUFFIX+3]; /* last chars of name, forced to lower case */
        -: 5876:    static char *known_suffixes[] =
        -: 5877:       {NULL, ".gz", ".z", ".taz", ".tgz", "-gz", "-z", "_z",
        -: 5878:#ifdef MAX_EXT_CHARS
        -: 5879:          "z",
        -: 5880:#endif
        -: 5881:          NULL};
    #####: 5882:    char **suf = known_suffixes;
        -: 5883:
    #####: 5884:    *suf = z_suffix;
    #####: 5885:    if (strequ(z_suffix, "z")) suf++; /* check long suffixes first */
branch  0 never executed
branch  1 never executed
        -: 5886:
        -: 5887:#ifdef SUFFIX_SEP
        -: 5888:    /* strip a version number from the file name */
        -: 5889:    {
        -: 5890:	char *v = strrchr(name, SUFFIX_SEP);
        -: 5891: 	if (v != NULL) *v = '\0';
        -: 5892:    }
        -: 5893:#endif
    #####: 5894:    nlen = strlen(name);
    #####: 5895:    if (nlen <= MAX_SUFFIX+2) {
branch  0 never executed
branch  1 never executed
    #####: 5896:        strcpy(suffix, name);
        -: 5897:    } else {
    #####: 5898:        strcpy(suffix, name+nlen-MAX_SUFFIX-2);
        -: 5899:    }
    #####: 5900:    strlwr(suffix);
call    0 never executed
    #####: 5901:    slen = strlen(suffix);
        -: 5902:    do {
    #####: 5903:       int s = strlen(*suf);
    #####: 5904:       if (slen > s && suffix[slen-s-1] != PATH_SEP
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 5905:           && strequ(suffix + slen - s, *suf)) {
branch  0 never executed
branch  1 never executed
    #####: 5906:           return name+nlen-s;
        -: 5907:       }
    #####: 5908:    } while (*++suf != NULL);
branch  0 never executed
branch  1 never executed
        -: 5909:
    #####: 5910:    return NULL;
        -: 5911:}
        -: 5912:
        -: 5913:
        -: 5914:/* ========================================================================
        -: 5915: * Set ifname to the input file name (with a suffix appended if necessary)
        -: 5916: * and istat to its stats. For decompression, if no file exists with the
        -: 5917: * original name, try adding successively z_suffix, .gz, .z, -z and .Z.
        -: 5918: * For MSDOS, we try only z_suffix and z.
        -: 5919: * Return OK or ERROR.
        -: 5920: */
function get_istat called 0 returned 0% blocks executed 0%
    #####: 5921:local int get_istat(iname, sbuf)
        -: 5922:    char *iname;
        -: 5923:    struct stat *sbuf;
        -: 5924:{
        -: 5925:    int ilen;  /* strlen(ifname) */
    #####: 5926:    int z_suffix_errno = 0;
        -: 5927:    static char *suffixes[] = {NULL, ".gz", ".z", "-z", ".Z", NULL};
    #####: 5928:    char **suf = suffixes;
        -: 5929:    char *s;
        -: 5930:#ifdef NO_MULTIPLE_DOTS
        -: 5931:    char *dot; /* pointer to ifname extension, or NULL */
        -: 5932:#endif
        -: 5933:
    #####: 5934:    *suf = z_suffix;
        -: 5935:
        -: 5936:#ifdef FAULTY_F_KL_5
    #####: 5937:    if (sizeof ifname + 1 <= strlen (iname))
branch  0 never executed
branch  1 never executed
    #####: 5938:        goto name_too_long;
        -: 5939:#else
        -: 5940:    if (sizeof ifname - 1 <= strlen (iname))
        -: 5941:	goto name_too_long;
        -: 5942:#endif
        -: 5943:
    #####: 5944:    strcpy(ifname, iname);
        -: 5945:
        -: 5946:    /* If input file exists, return OK. */
    #####: 5947:    if (do_stat(ifname, sbuf) == 0) return OK;
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 5948:
    #####: 5949:    if (!decompress || errno != ENOENT) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 5950:	progerror(ifname);
call    0 never executed
    #####: 5951:	return ERROR;
        -: 5952:    }
        -: 5953:    /* file.ext doesn't exist, try adding a suffix (after removing any
        -: 5954:     * version number for VMS).
        -: 5955:     */
    #####: 5956:    s = get_suffix(ifname);
call    0 never executed
    #####: 5957:    if (s != NULL) {
branch  0 never executed
branch  1 never executed
    #####: 5958:	progerror(ifname); /* ifname already has z suffix and does not exist */
call    0 never executed
    #####: 5959:	return ERROR;
        -: 5960:    }
        -: 5961:#ifdef NO_MULTIPLE_DOTS
        -: 5962:    dot = strrchr(ifname, '.');
        -: 5963:    if (dot == NULL) {
        -: 5964:        strcat(ifname, ".");
        -: 5965:        dot = strrchr(ifname, '.');
        -: 5966:    }
        -: 5967:#endif
    #####: 5968:    ilen = strlen(ifname);
    #####: 5969:    if (strequ(z_suffix, ".gz")) suf++;
branch  0 never executed
branch  1 never executed
        -: 5970:
        -: 5971:    /* Search for all suffixes */
        -: 5972:    do {
    #####: 5973:        char *s0 = s = *suf;
    #####: 5974:        strcpy (ifname, iname);
        -: 5975:#ifdef NO_MULTIPLE_DOTS
        -: 5976:        if (*s == '.') s++;
        -: 5977:        if (*dot == '\0') strcpy (dot, ".");
        -: 5978:#endif
        -: 5979:#ifdef MAX_EXT_CHARS
        -: 5980:	if (MAX_EXT_CHARS < strlen (s) + strlen (dot + 1))
        -: 5981:	  dot[MAX_EXT_CHARS + 1 - strlen (s)] = '\0';
        -: 5982:#endif
    #####: 5983:	if (sizeof ifname <= ilen + strlen (s))
branch  0 never executed
branch  1 never executed
    #####: 5984:	  goto name_too_long;
    #####: 5985:        strcat(ifname, s);
    #####: 5986:        if (do_stat(ifname, sbuf) == 0) return OK;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 5987:	if (strequ (s0, z_suffix))
branch  0 never executed
branch  1 never executed
    #####: 5988:	  z_suffix_errno = errno;
    #####: 5989:    } while (*++suf != NULL);
branch  0 never executed
branch  1 never executed
        -: 5990:
        -: 5991:    /* No suffix found, complain using z_suffix: */
    #####: 5992:    strcpy(ifname, iname);
        -: 5993:#ifdef NO_MULTIPLE_DOTS
        -: 5994:    if (*dot == '\0') strcpy(dot, ".");
        -: 5995:#endif
        -: 5996:#ifdef MAX_EXT_CHARS
        -: 5997:    if (MAX_EXT_CHARS < z_len + strlen (dot + 1))
        -: 5998:      dot[MAX_EXT_CHARS + 1 - z_len] = '\0';
        -: 5999:#endif
    #####: 6000:    strcat(ifname, z_suffix);
    #####: 6001:    errno = z_suffix_errno;
    #####: 6002:    progerror(ifname);
call    0 never executed
    #####: 6003:    return ERROR;
        -: 6004:      
    #####: 6005: name_too_long:
    #####: 6006:    fprintf (stderr, "%s: %s: file name too long\n", progname, iname);
call    0 never executed
    #####: 6007:    exit_code = ERROR;
    #####: 6008:    return ERROR;
        -: 6009:}
        -: 6010:
        -: 6011:/* ========================================================================
        -: 6012: * Generate ofname given ifname. Return OK, or WARNING if file must be skipped.
        -: 6013: * Sets save_orig_name to true if the file name has been truncated.
        -: 6014: */
function make_ofname called 0 returned 0% blocks executed 0%
    #####: 6015:local int make_ofname()
        -: 6016:{
        -: 6017:    char *suff;            /* ofname z suffix */
        -: 6018:
    #####: 6019:    strcpy(ofname, ifname);
        -: 6020:    /* strip a version number if any and get the gzip suffix if present: */
    #####: 6021:    suff = get_suffix(ofname);
call    0 never executed
        -: 6022:
    #####: 6023:    if (decompress) {
branch  0 never executed
branch  1 never executed
    #####: 6024:	if (suff == NULL) {
branch  0 never executed
branch  1 never executed
        -: 6025:	    /* Whith -t or -l, try all files (even without .gz suffix)
        -: 6026:	     * except with -r (behave as with just -dr).
        -: 6027:             */
    #####: 6028:            if (!recursive && (list || test)) return OK;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 6029:
        -: 6030:	    /* Avoid annoying messages with -r */
    #####: 6031:	    if (verbose || (!recursive && !quiet)) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 6032:		WARN((stderr,"%s: %s: unknown suffix -- ignored\n",
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 6033:		      progname, ifname));
        -: 6034:	    }
    #####: 6035:	    return WARNING;
        -: 6036:	}
        -: 6037:	/* Make a special case for .tgz and .taz: */
    #####: 6038:	strlwr(suff);
call    0 never executed
    #####: 6039:	if (strequ(suff, ".tgz") || strequ(suff, ".taz")) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 6040:	    strcpy(suff, ".tar");
        -: 6041:	} else {
    #####: 6042:	    *suff = '\0'; /* strip the z suffix */
        -: 6043:	}
        -: 6044:        /* ofname might be changed later if infile contains an original name */
        -: 6045:
    #####: 6046:    } else if (suff != NULL) {
branch  0 never executed
branch  1 never executed
        -: 6047:	/* Avoid annoying messages with -r (see treat_dir()) */
    #####: 6048:	if (verbose || (!recursive && !quiet)) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 6049:	    fprintf(stderr, "%s: %s already has %s suffix -- unchanged\n",
call    0 never executed
        -: 6050:		    progname, ifname, suff);
        -: 6051:	}
    #####: 6052:	if (exit_code == OK) exit_code = WARNING;
branch  0 never executed
branch  1 never executed
    #####: 6053:	return WARNING;
        -: 6054:    } else {
    #####: 6055:        save_orig_name = 0;
        -: 6056:
        -: 6057:#ifdef NO_MULTIPLE_DOTS
        -: 6058:	suff = strrchr(ofname, '.');
        -: 6059:	if (suff == NULL) {
        -: 6060:	    if (sizeof ofname <= strlen (ofname) + 1)
        -: 6061:		goto name_too_long;
        -: 6062:            strcat(ofname, ".");
        -: 6063:#  ifdef MAX_EXT_CHARS
        -: 6064:	    if (strequ(z_suffix, "z")) {
        -: 6065:		if (sizeof ofname <= strlen (ofname) + 2)
        -: 6066:		    goto name_too_long;
        -: 6067:		strcat(ofname, "gz"); /* enough room */
        -: 6068:		return OK;
        -: 6069:	    }
        -: 6070:        /* On the Atari and some versions of MSDOS, name_too_long()
        -: 6071:         * does not work correctly because of a bug in stat(). So we
        -: 6072:         * must truncate here.
        -: 6073:         */
        -: 6074:        } else if (strlen(suff)-1 + z_len > MAX_SUFFIX) {
        -: 6075:            suff[MAX_SUFFIX+1-z_len] = '\0';
        -: 6076:            save_orig_name = 1;
        -: 6077:#  endif
        -: 6078:        }
        -: 6079:#endif /* NO_MULTIPLE_DOTS */
    #####: 6080:	if (sizeof ofname <= strlen (ofname) + z_len)
branch  0 never executed
branch  1 never executed
    #####: 6081:	    goto name_too_long;
    #####: 6082:	strcat(ofname, z_suffix);
        -: 6083:
        -: 6084:    } /* decompress ? */
    #####: 6085:    return OK;
        -: 6086:
    #####: 6087: name_too_long:
    #####: 6088:    WARN ((stderr, "%s: %s: file name too long\n", progname, ifname));
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 6089:    return WARNING;
        -: 6090:}
        -: 6091:
        -: 6092:
        -: 6093:/* ========================================================================
        -: 6094: * Check the magic number of the input file and update ofname if an
        -: 6095: * original name was given and to_stdout is not set.
        -: 6096: * Return the compression method, -1 for error, -2 for warning.
        -: 6097: * Set inptr to the offset of the next byte to be processed.
        -: 6098: * Updates time_stamp if there is one and --no-time is not used.
        -: 6099: * This function may be called repeatedly for an input file consisting
        -: 6100: * of several contiguous gzip'ed members.
        -: 6101: * IN assertions: there is at least one remaining compressed member.
        -: 6102: *   If the member is a zip file, it must be the only one.
        -: 6103: */
function get_method called 0 returned 0% blocks executed 0%
    #####: 6104:local int get_method(in)
        -: 6105:    int in;        /* input file descriptor */
        -: 6106:{
        -: 6107:    uch flags;     /* compression flags */
        -: 6108:    char magic[2]; /* magic header */
        -: 6109:    int imagic1;   /* like magic[1], but can represent EOF */
        -: 6110:    ulg stamp;     /* time stamp */
        -: 6111:
        -: 6112:    /* If --force and --stdout, zcat == cat, so do not complain about
        -: 6113:     * premature end of file: use try_byte instead of get_byte.
        -: 6114:     */
    #####: 6115:    if (force && to_stdout) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 6116:
        -: 6117:#ifdef FAULTY_F_TW_5
    #####: 6118:        magic[0] = (char)get_byte();
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 6119:	magic[1] = (char)get_byte();
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 6120:#else
        -: 6121:	magic[0] = (char)try_byte();
        -: 6122:	imagic1 = try_byte ();
        -: 6123:	magic[1] = (char) imagic1;
        -: 6124:#endif
        -: 6125:	/* If try_byte returned EOF, magic[1] == (char) EOF.  */
        -: 6126:    } else {
    #####: 6127:	magic[0] = (char)get_byte();
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 6128:	magic[1] = (char)get_byte();
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 6129:	imagic1 = 0; /* avoid lint warning */
        -: 6130:    }
    #####: 6131:    method = -1;                 /* unknown yet */
    #####: 6132:    part_nb++;                   /* number of parts in gzip file */
    #####: 6133:    header_bytes = 0;
    #####: 6134:    last_member = RECORD_IO;
        -: 6135:    /* assume multiple members in gzip file except for record oriented I/O */
        -: 6136:
    #####: 6137:    if (memcmp(magic, GZIP_MAGIC, 2) == 0
branch  0 never executed
branch  1 never executed
    #####: 6138:        || memcmp(magic, OLD_GZIP_MAGIC, 2) == 0) {
branch  0 never executed
branch  1 never executed
        -: 6139:
    #####: 6140:	method = (int)get_byte();
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 6141:	if (method != DEFLATED) {
branch  0 never executed
branch  1 never executed
    #####: 6142:	    fprintf(stderr,
call    0 never executed
        -: 6143:		    "%s: %s: unknown method %d -- get newer version of gzip\n",
        -: 6144:		    progname, ifname, method);
    #####: 6145:	    exit_code = ERROR;
    #####: 6146:	    return -1;
        -: 6147:	}
    #####: 6148:	work = unzip;
    #####: 6149:	flags  = (uch)get_byte();
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 6150:
    #####: 6151:	if ((flags & ENCRYPTED) != 0) {
branch  0 never executed
branch  1 never executed
    #####: 6152:	    fprintf(stderr,
call    0 never executed
        -: 6153:		    "%s: %s is encrypted -- get newer version of gzip\n",
        -: 6154:		    progname, ifname);
    #####: 6155:	    exit_code = ERROR;
    #####: 6156:	    return -1;
        -: 6157:	}
    #####: 6158:	if ((flags & CONTINUATION) != 0) {
branch  0 never executed
branch  1 never executed
    #####: 6159:	    fprintf(stderr,
call    0 never executed
        -: 6160:	   "%s: %s is a a multi-part gzip file -- get newer version of gzip\n",
        -: 6161:		    progname, ifname);
    #####: 6162:	    exit_code = ERROR;
    #####: 6163:	    if (force <= 1) return -1;
branch  0 never executed
branch  1 never executed
        -: 6164:	}
    #####: 6165:	if ((flags & RESERVED) != 0) {
branch  0 never executed
branch  1 never executed
    #####: 6166:	    fprintf(stderr,
call    0 never executed
        -: 6167:		    "%s: %s has flags 0x%x -- get newer version of gzip\n",
        -: 6168:		    progname, ifname, flags);
    #####: 6169:	    exit_code = ERROR;
    #####: 6170:	    if (force <= 1) return -1;
branch  0 never executed
branch  1 never executed
        -: 6171:	}
    #####: 6172:	stamp  = (ulg)get_byte();
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 6173:	stamp |= ((ulg)get_byte()) << 8;
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 6174:	stamp |= ((ulg)get_byte()) << 16;
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 6175:	stamp |= ((ulg)get_byte()) << 24;
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 6176:	if (stamp != 0 && !no_time) time_stamp = stamp;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 6177:	/* this is not original code -- inserted by MAPSTEXT */
    #####: 6178:	time_stamp = 0;
        -: 6179:
    #####: 6180:	(void)get_byte();  /* Ignore extra flags for the moment */
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 6181:	(void)get_byte();  /* Ignore OS type for the moment */
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 6182:
    #####: 6183:	if ((flags & CONTINUATION) != 0) {
branch  0 never executed
branch  1 never executed
    #####: 6184:	    unsigned part = (unsigned)get_byte();
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 6185:	    part |= ((unsigned)get_byte())<<8;
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 6186:	    if (verbose) {
branch  0 never executed
branch  1 never executed
    #####: 6187:		fprintf(stderr,"%s: %s: part number %u\n",
call    0 never executed
        -: 6188:			progname, ifname, part);
        -: 6189:	    }
        -: 6190:	}
    #####: 6191:	if ((flags & EXTRA_FIELD) != 0) {
branch  0 never executed
branch  1 never executed
    #####: 6192:	    unsigned len = (unsigned)get_byte();
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 6193:	    len |= ((unsigned)get_byte())<<8;
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 6194:	    if (verbose) {
branch  0 never executed
branch  1 never executed
    #####: 6195:		fprintf(stderr,"%s: %s: extra field of %u bytes ignored\n",
call    0 never executed
        -: 6196:			progname, ifname, len);
        -: 6197:	    }
    #####: 6198:	    while (len--) (void)get_byte();
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 6199:	}
        -: 6200:
        -: 6201:	/* Get original file name if it was truncated */
    #####: 6202:	if ((flags & ORIG_NAME) != 0) {
branch  0 never executed
branch  1 never executed
    #####: 6203:	    if (no_name || (to_stdout && !list) || part_nb > 1) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -: 6204:		/* Discard the old name */
        -: 6205:		char c; /* dummy used for NeXTstep 3.0 cc optimizer bug */
    #####: 6206:		do {c=get_byte();} while (c != 0);
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 6207:	    } else {
        -: 6208:		/* Copy the base name. Keep a directory prefix intact. */
    #####: 6209:                char *p = base_name (ofname);
call    0 never executed
    #####: 6210:                char *base = p;
        -: 6211:		for (;;) {
    #####: 6212:		    *p = (char)get_char();
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 6213:		    if (*p++ == '\0') break;
branch  0 never executed
branch  1 never executed
    #####: 6214:		    if (p >= ofname+sizeof(ofname)) {
branch  0 never executed
branch  1 never executed
    #####: 6215:			error("corrupted input -- file name too large");
call    0 never executed
        -: 6216:		    }
        -: 6217:		}
        -: 6218:                /* If necessary, adapt the name to local OS conventions: */
    #####: 6219:                if (!list) {
branch  0 never executed
branch  1 never executed
        -: 6220:                   MAKE_LEGAL_NAME(base);
    #####: 6221:		   if (base) list=0; /* avoid warning about unused variable */
branch  0 never executed
branch  1 never executed
        -: 6222:                }
        -: 6223:	    } /* no_name || to_stdout */
        -: 6224:	} /* ORIG_NAME */
        -: 6225:
        -: 6226:	/* Discard file comment if any */
    #####: 6227:	if ((flags & COMMENT) != 0) {
branch  0 never executed
branch  1 never executed
    #####: 6228:	    while (get_char() != 0) /* null */ ;
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 6229:	}
    #####: 6230:	if (part_nb == 1) {
branch  0 never executed
branch  1 never executed
    #####: 6231:	    header_bytes = inptr + 2*sizeof(long); /* include crc and size */
        -: 6232:	}
        -: 6233:
    #####: 6234:    } else if (memcmp(magic, PKZIP_MAGIC, 2) == 0 && inptr == 2
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 6235:	    && memcmp((char*)inbuf, PKZIP_MAGIC, 4) == 0) {
branch  0 never executed
branch  1 never executed
        -: 6236:	/* To simplify the code, we support a zip file when alone only.
        -: 6237:         * We are thus guaranteed that the entire local header fits in inbuf.
        -: 6238:         */
    #####: 6239:        inptr = 0;
    #####: 6240:	work = unzip;
    #####: 6241:	if (check_zipfile(in) != OK) return -1;
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 6242:	/* check_zipfile may get ofname from the local header */
    #####: 6243:	last_member = 1;
        -: 6244:
    #####: 6245:    } else if (memcmp(magic, PACK_MAGIC, 2) == 0) {
branch  0 never executed
branch  1 never executed
    #####: 6246:	work = unpack;
    #####: 6247:	method = PACKED;
        -: 6248:
    #####: 6249:    } else if (memcmp(magic, LZW_MAGIC, 2) == 0) {
branch  0 never executed
branch  1 never executed
    #####: 6250:	work = unlzw;
    #####: 6251:	method = COMPRESSED;
    #####: 6252:	last_member = 1;
        -: 6253:
    #####: 6254:    } else if (memcmp(magic, LZH_MAGIC, 2) == 0) {
branch  0 never executed
branch  1 never executed
    #####: 6255:	work = unlzh;
    #####: 6256:	method = LZHED;
    #####: 6257:	last_member = 1;
        -: 6258:
    #####: 6259:    } else if (force && to_stdout && !list) { /* pass input unchanged */
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 6260:	method = STORED;
    #####: 6261:	work = copy;
    #####: 6262:        inptr = 0;
    #####: 6263:	last_member = 1;
        -: 6264:    }
    #####: 6265:    if (method >= 0) return method;
branch  0 never executed
branch  1 never executed
        -: 6266:
    #####: 6267:    if (part_nb == 1) {
branch  0 never executed
branch  1 never executed
    #####: 6268:	fprintf(stderr, "\n%s: %s: not in gzip format\n", progname, ifname);
call    0 never executed
    #####: 6269:	exit_code = ERROR;
    #####: 6270:	return -1;
        -: 6271:    } else {
    #####: 6272:	if (magic[0] == 0)
branch  0 never executed
branch  1 never executed
    #####: 6273:	  {
        -: 6274:	    int inbyte;
    #####: 6275:	    for (inbyte = imagic1;  inbyte == 0;  inbyte = try_byte ())
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 6276:	      continue;
    #####: 6277:	    if (inbyte == EOF)
branch  0 never executed
branch  1 never executed
        -: 6278:	      {
    #####: 6279:		if (verbose)
branch  0 never executed
branch  1 never executed
    #####: 6280:		  WARN ((stderr, "\n%s: %s: decompression OK, trailing zero bytes ignored\n",
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 6281:			 progname, ifname));
    #####: 6282:		return -3;
        -: 6283:	      }
        -: 6284:	  }
        -: 6285:
    #####: 6286:	WARN((stderr, "\n%s: %s: decompression OK, trailing garbage ignored\n",
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 6287:	      progname, ifname));
    #####: 6288:	return -2;
        -: 6289:    }
        -: 6290:}
        -: 6291:
        -: 6292:/* ========================================================================
        -: 6293: * Display the characteristics of the compressed file.
        -: 6294: * If the given method is < 0, display the accumulated totals.
        -: 6295: * IN assertions: time_stamp, header_bytes and ifile_size are initialized.
        -: 6296: */
function do_list called 0 returned 0% blocks executed 0%
    #####: 6297:local void do_list(ifd, method)
        -: 6298:    int ifd;     /* input file descriptor */
        -: 6299:    int method;  /* compression method */
        -: 6300:{
        -: 6301:    ulg crc;  /* original crc */
        -: 6302:    static int first_time = 1;
        -: 6303:    static char* methods[MAX_METHODS] = {
        -: 6304:        "store",  /* 0 */
        -: 6305:        "compr",  /* 1 */
        -: 6306:        "pack ",  /* 2 */
        -: 6307:        "lzh  ",  /* 3 */
        -: 6308:        "", "", "", "", /* 4 to 7 reserved */
        -: 6309:        "defla"}; /* 8 */
        -: 6310:    char *date;
    #####: 6311:    int positive_off_t_width = 1;
        -: 6312:    off_t o;
        -: 6313:
        -: 6314:#ifdef FAULTY_F_KL_6
    #####: 6315:    for (o = OFF_T_MAX; 9 <= o; o /= 10) {
branch  0 never executed
branch  1 never executed
    #####: 6316:	positive_off_t_width++;
        -: 6317:    }
        -: 6318:#else
        -: 6319:    for (o = OFF_T_MAX;  9 < o;  o /= 10) {
        -: 6320:	positive_off_t_width++;
        -: 6321:    }
        -: 6322:#endif
        -: 6323:
    #####: 6324:    if (first_time && method >= 0) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 6325:	first_time = 0;
    #####: 6326:	if (verbose)  {
branch  0 never executed
branch  1 never executed
    #####: 6327:	    printf("method  crc     date  time  ");
call    0 never executed
        -: 6328:	}
    #####: 6329:	if (!quiet) {
branch  0 never executed
branch  1 never executed
    #####: 6330:	    printf("%*.*s %*.*s  ratio uncompressed_name\n",
call    0 never executed
        -: 6331:		   positive_off_t_width, positive_off_t_width, "compressed",
        -: 6332:		   positive_off_t_width, positive_off_t_width, "uncompressed");
        -: 6333:	}
    #####: 6334:    } else if (method < 0) {
branch  0 never executed
branch  1 never executed
    #####: 6335:	if (total_in <= 0 || total_out <= 0) return;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 6336:	if (verbose) {
branch  0 never executed
branch  1 never executed
    #####: 6337:	    printf("                            ");
call    0 never executed
        -: 6338:	}
    #####: 6339:	if (verbose || !quiet) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 6340:	    fprint_off(stdout, total_in, positive_off_t_width);
call    0 never executed
    #####: 6341:	    printf(" ");
call    0 never executed
    #####: 6342:	    fprint_off(stdout, total_out, positive_off_t_width);
call    0 never executed
    #####: 6343:	    printf(" ");
call    0 never executed
        -: 6344:	}
    #####: 6345:	display_ratio(total_out-(total_in-header_bytes), total_out, stdout);
call    0 never executed
        -: 6346:	/* header_bytes is not meaningful but used to ensure the same
        -: 6347:	 * ratio if there is a single file.
        -: 6348:	 */
    #####: 6349:	printf(" (totals)\n");
call    0 never executed
    #####: 6350:	return;
        -: 6351:    }
    #####: 6352:    crc = (ulg)~0; /* unknown */
    #####: 6353:    bytes_out = -1L;
    #####: 6354:    bytes_in = ifile_size;
        -: 6355:
        -: 6356:#if RECORD_IO == 0
    #####: 6357:    if (method == DEFLATED && !last_member) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 6358:        /* Get the crc and uncompressed size for gzip'ed (not zip'ed) files.
        -: 6359:         * If the lseek fails, we could use read() to get to the end, but
        -: 6360:         * --list is used to get quick results.
        -: 6361:         * Use "gunzip < foo.gz | wc -c" to get the uncompressed size if
        -: 6362:         * you are not concerned about speed.
        -: 6363:         */
    #####: 6364:        bytes_in = lseek(ifd, (off_t)(-8), SEEK_END);
call    0 never executed
    #####: 6365:        if (bytes_in != -1L) {
branch  0 never executed
branch  1 never executed
        -: 6366:            uch buf[8];
    #####: 6367:            bytes_in += 8L;
    #####: 6368:            if (read(ifd, (char*)buf, sizeof(buf)) != sizeof(buf)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 6369:                read_error();
call    0 never executed
        -: 6370:            }
    #####: 6371:            crc       = LG(buf);
    #####: 6372:	    bytes_out = LG(buf+4);
        -: 6373:	}
        -: 6374:    }
        -: 6375:#endif /* RECORD_IO */
    #####: 6376:    date = ctime((time_t*)&time_stamp) + 4; /* skip the day of the week */
call    0 never executed
    #####: 6377:    date[12] = '\0';               /* suppress the 1/100sec and the year */
    #####: 6378:    if (verbose) {
branch  0 never executed
branch  1 never executed
    #####: 6379:        printf("%5s %08lx %11s ", methods[method], crc, date);
call    0 never executed
        -: 6380:    }
    #####: 6381:    fprint_off(stdout, bytes_in, positive_off_t_width);
call    0 never executed
    #####: 6382:    printf(" ");
call    0 never executed
    #####: 6383:    fprint_off(stdout, bytes_out, positive_off_t_width);
call    0 never executed
    #####: 6384:    printf(" ");
call    0 never executed
    #####: 6385:    if (bytes_in  == -1L) {
branch  0 never executed
branch  1 never executed
    #####: 6386:	total_in = -1L;
    #####: 6387:	bytes_in = bytes_out = header_bytes = 0;
    #####: 6388:    } else if (total_in >= 0) {
branch  0 never executed
branch  1 never executed
    #####: 6389:	total_in  += bytes_in;
        -: 6390:    }
    #####: 6391:    if (bytes_out == -1L) {
branch  0 never executed
branch  1 never executed
    #####: 6392:	total_out = -1L;
    #####: 6393:	bytes_in = bytes_out = header_bytes = 0;
    #####: 6394:    } else if (total_out >= 0) {
branch  0 never executed
branch  1 never executed
    #####: 6395:	total_out += bytes_out;
        -: 6396:    }
    #####: 6397:    display_ratio(bytes_out-(bytes_in-header_bytes), bytes_out, stdout);
call    0 never executed
    #####: 6398:    printf(" %s\n", ofname);
call    0 never executed
        -: 6399:}
        -: 6400:
        -: 6401:/* ========================================================================
        -: 6402: * Return true if the two stat structures correspond to the same file.
        -: 6403: */
function same_file called 0 returned 0% blocks executed 0%
    #####: 6404:local int same_file(stat1, stat2)
        -: 6405:    struct stat *stat1;
        -: 6406:    struct stat *stat2;
        -: 6407:{
    #####: 6408:    return stat1->st_ino   == stat2->st_ino
    #####: 6409:	&& stat1->st_dev   == stat2->st_dev
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 6410:#ifdef NO_ST_INO
        -: 6411:        /* Can't rely on st_ino and st_dev, use other fields: */
        -: 6412:	&& stat1->st_mode  == stat2->st_mode
        -: 6413:	&& stat1->st_uid   == stat2->st_uid
        -: 6414:	&& stat1->st_gid   == stat2->st_gid
        -: 6415:	&& stat1->st_size  == stat2->st_size
        -: 6416:	&& stat1->st_atime == stat2->st_atime
        -: 6417:	&& stat1->st_mtime == stat2->st_mtime
        -: 6418:	&& stat1->st_ctime == stat2->st_ctime
        -: 6419:#endif
        -: 6420:	    ;
        -: 6421:}
        -: 6422:
        -: 6423:/* ========================================================================
        -: 6424: * Return true if a file name is ambiguous because the operating system
        -: 6425: * truncates file names.
        -: 6426: */
function name_too_long called 0 returned 0% blocks executed 0%
    #####: 6427:local int name_too_long(name, statb)
        -: 6428:    char *name;           /* file name to check */
        -: 6429:    struct stat *statb;   /* stat buf for this file name */
        -: 6430:{
    #####: 6431:    int s = strlen(name);
    #####: 6432:    char c = name[s-1];
        -: 6433:    struct stat	tstat; /* stat for truncated name */
        -: 6434:    int res;
        -: 6435:
    #####: 6436:    tstat = *statb;      /* Just in case OS does not fill all fields */
    #####: 6437:    name[s-1] = '\0';
    #####: 6438:    res = stat(name, &tstat) == 0 && same_file(statb, &tstat);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 6439:    name[s-1] = c;
        -: 6440:    Trace((stderr, " too_long(%s) => %d\n", name, res));
    #####: 6441:    return res;
        -: 6442:}
        -: 6443:
        -: 6444:/* ========================================================================
        -: 6445: * Shorten the given name by one character, or replace a .tar extension
        -: 6446: * with .tgz. Truncate the last part of the name which is longer than
        -: 6447: * MIN_PART characters: 1234.678.012.gz -> 123.678.012.gz. If the name
        -: 6448: * has only parts shorter than MIN_PART truncate the longest part.
        -: 6449: * For decompression, just remove the last character of the name.
        -: 6450: *
        -: 6451: * IN assertion: for compression, the suffix of the given name is z_suffix.
        -: 6452: */
function shorten_name called 0 returned 0% blocks executed 0%
    #####: 6453:local void shorten_name(name)
        -: 6454:    char *name;
        -: 6455:{
        -: 6456:    int len;                 /* length of name without z_suffix */
    #####: 6457:    char *trunc = NULL;      /* character to be truncated */
        -: 6458:    int plen;                /* current part length */
    #####: 6459:    int min_part = MIN_PART; /* current minimum part length */
        -: 6460:    char *p;
        -: 6461:
    #####: 6462:    len = strlen(name);
    #####: 6463:    if (decompress) {
branch  0 never executed
branch  1 never executed
    #####: 6464:	if (len <= 1) error("name too short");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 6465:	name[len-1] = '\0';
    #####: 6466:	return;
        -: 6467:    }
    #####: 6468:    p = get_suffix(name);
call    0 never executed
    #####: 6469:    if (p == NULL) error("can't recover suffix\n");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 6470:    *p = '\0';
    #####: 6471:    save_orig_name = 1;
        -: 6472:
        -: 6473:    /* compress 1234567890.tar to 1234567890.tgz */
    #####: 6474:    if (len > 4 && strequ(p-4, ".tar")) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 6475:	strcpy(p-4, ".tgz");
    #####: 6476:	return;
        -: 6477:    }
        -: 6478:    /* Try keeping short extensions intact:
        -: 6479:     * 1234.678.012.gz -> 123.678.012.gz
        -: 6480:     */
        -: 6481:    do {
    #####: 6482:	p = strrchr(name, PATH_SEP);
    #####: 6483:	p = p ? p+1 : name;
branch  0 never executed
branch  1 never executed
    #####: 6484:	while (*p) {
branch  0 never executed
branch  1 never executed
    #####: 6485:	    plen = strcspn(p, PART_SEP);
    #####: 6486:	    p += plen;
    #####: 6487:	    if (plen > min_part) trunc = p-1;
branch  0 never executed
branch  1 never executed
    #####: 6488:	    if (*p) p++;
branch  0 never executed
branch  1 never executed
        -: 6489:	}
    #####: 6490:    } while (trunc == NULL && --min_part != 0);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 6491:
    #####: 6492:    if (trunc != NULL) {
branch  0 never executed
branch  1 never executed
        -: 6493:	do {
    #####: 6494:	    trunc[0] = trunc[1];
    #####: 6495:	} while (*trunc++);
branch  0 never executed
branch  1 never executed
    #####: 6496:	trunc--;
        -: 6497:    } else {
    #####: 6498:	trunc = strrchr(name, PART_SEP[0]);
    #####: 6499:	if (trunc == NULL) error("internal error in shorten_name");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 6500:	if (trunc[1] == '\0') trunc--; /* force truncation */
branch  0 never executed
branch  1 never executed
        -: 6501:    }
    #####: 6502:    strcpy(trunc, z_suffix);
        -: 6503:}
        -: 6504:
        -: 6505:/* ========================================================================
        -: 6506: * If compressing to a file, check if ofname is not ambiguous
        -: 6507: * because the operating system truncates names. Otherwise, generate
        -: 6508: * a new ofname and save the original name in the compressed file.
        -: 6509: * If the compressed file already exists, ask for confirmation.
        -: 6510: *    The check for name truncation is made dynamically, because different
        -: 6511: * file systems on the same OS might use different truncation rules (on SVR4
        -: 6512: * s5 truncates to 14 chars and ufs does not truncate).
        -: 6513: *    This function returns -1 if the file must be skipped, and
        -: 6514: * updates save_orig_name if necessary.
        -: 6515: * IN assertions: save_orig_name is already set if ofname has been
        -: 6516: * already truncated because of NO_MULTIPLE_DOTS. The input file has
        -: 6517: * already been open and istat is set.
        -: 6518: */
function check_ofname called 0 returned 0% blocks executed 0%
    #####: 6519:local int check_ofname()
        -: 6520:{
        -: 6521:    struct stat	ostat; /* stat for ofname */
        -: 6522:
        -: 6523:#ifdef ENAMETOOLONG
        -: 6524:    /* Check for strictly conforming Posix systems (which return ENAMETOOLONG
        -: 6525:     * instead of silently truncating filenames).
        -: 6526:     */
    #####: 6527:    errno = 0;
    #####: 6528:    while (stat(ofname, &ostat) != 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 6529:        if (errno != ENAMETOOLONG) return 0; /* ofname does not exist */
branch  0 never executed
branch  1 never executed
    #####: 6530:	shorten_name(ofname);
call    0 never executed
        -: 6531:    }
        -: 6532:#else
        -: 6533:    if (stat(ofname, &ostat) != 0) return 0;
        -: 6534:#endif
        -: 6535:    /* Check for name truncation on existing file. Do this even on systems
        -: 6536:     * defining ENAMETOOLONG, because on most systems the strict Posix
        -: 6537:     * behavior is disabled by default (silent name truncation allowed).
        -: 6538:     */
    #####: 6539:    if (!decompress && name_too_long(ofname, &ostat)) {
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 6540:	shorten_name(ofname);
call    0 never executed
    #####: 6541:	if (stat(ofname, &ostat) != 0) return 0;
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 6542:    }
        -: 6543:
        -: 6544:    /* Check that the input and output files are different (could be
        -: 6545:     * the same by name truncation or links).
        -: 6546:     */
    #####: 6547:    if (same_file(&istat, &ostat)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 6548:	if (strequ(ifname, ofname)) {
branch  0 never executed
branch  1 never executed
    #####: 6549:	    fprintf(stderr, "%s: %s: cannot %scompress onto itself\n",
call    0 never executed
    #####: 6550:		    progname, ifname, decompress ? "de" : "");
branch  0 never executed
branch  1 never executed
        -: 6551:	} else {
    #####: 6552:	    fprintf(stderr, "%s: %s and %s are the same file\n",
call    0 never executed
        -: 6553:		    progname, ifname, ofname);
        -: 6554:	}
    #####: 6555:	exit_code = ERROR;
    #####: 6556:	return ERROR;
        -: 6557:    }
        -: 6558:    /* Ask permission to overwrite the existing file */
    #####: 6559:    if (!force) {
branch  0 never executed
branch  1 never executed
        -: 6560:	char response[80];
    #####: 6561:	strcpy(response,"n");
    #####: 6562:	fprintf(stderr, "%s: %s already exists;", progname, ofname);
call    0 never executed
    #####: 6563:	if (foreground && isatty(fileno(stdin))) {
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 6564:	    fprintf(stderr, " do you wish to overwrite (y or n)? ");
call    0 never executed
    #####: 6565:	    fflush(stderr);
call    0 never executed
    #####: 6566:	    (void)fgets(response, sizeof(response)-1, stdin);
call    0 never executed
        -: 6567:	}
    #####: 6568:	if (tolow ((unsigned char) *response) != 'y') {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 6569:	    fprintf(stderr, "\tnot overwritten\n");
call    0 never executed
    #####: 6570:	    if (exit_code == OK) exit_code = WARNING;
branch  0 never executed
branch  1 never executed
    #####: 6571:	    return ERROR;
        -: 6572:	}
        -: 6573:    }
    #####: 6574:    if (xunlink (ofname)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 6575:	progerror(ofname);
call    0 never executed
    #####: 6576:	return ERROR;
        -: 6577:    }
    #####: 6578:    return OK;
        -: 6579:}
        -: 6580:
        -: 6581:
        -: 6582:#ifndef NO_UTIME
        -: 6583:/* ========================================================================
        -: 6584: * Set the access and modification times from the given stat buffer.
        -: 6585: */
function reset_times called 0 returned 0% blocks executed 0%
    #####: 6586:local void reset_times (name, statb)
        -: 6587:    char *name;
        -: 6588:    struct stat *statb;
        -: 6589:{
        -: 6590:    struct utimbuf	timep;
        -: 6591:
        -: 6592:    /* Copy the time stamp */
    #####: 6593:    timep.actime  = statb->st_atime;
    #####: 6594:    timep.modtime = statb->st_mtime;
        -: 6595:
        -: 6596:    /* Some systems (at least OS/2) do not support utime on directories */
    #####: 6597:    if (utime(name, &timep) && !S_ISDIR(statb->st_mode)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 6598:	int e = errno;
    #####: 6599:	WARN((stderr, "%s: ", progname));
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 6600:	if (!quiet) {
branch  0 never executed
branch  1 never executed
    #####: 6601:	    errno = e;
    #####: 6602:	    perror(ofname);
call    0 never executed
        -: 6603:	}
        -: 6604:    }
    #####: 6605:}
        -: 6606:#endif
        -: 6607:
        -: 6608:
        -: 6609:/* ========================================================================
        -: 6610: * Copy modes, times, ownership from input file to output file.
        -: 6611: * IN assertion: to_stdout is false.
        -: 6612: */
function copy_stat called 0 returned 0% blocks executed 0%
    #####: 6613:local void copy_stat(ifstat)
        -: 6614:    struct stat *ifstat;
        -: 6615:{
        -: 6616:#ifndef NO_UTIME
    #####: 6617:    if (decompress && time_stamp != 0 && ifstat->st_mtime != time_stamp) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 6618:	ifstat->st_mtime = time_stamp;
    #####: 6619:	if (verbose > 1) {
branch  0 never executed
branch  1 never executed
    #####: 6620:	    fprintf(stderr, "%s: time stamp restored\n", ofname);
call    0 never executed
        -: 6621:	}
        -: 6622:    }
    #####: 6623:    reset_times(ofname, ifstat);
call    0 never executed
        -: 6624:#endif
        -: 6625:    /* Copy the protection modes */
    #####: 6626:    if (chmod(ofname, ifstat->st_mode & 07777)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 6627:	int e = errno;
    #####: 6628:	WARN((stderr, "%s: ", progname));
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 6629:	if (!quiet) {
branch  0 never executed
branch  1 never executed
    #####: 6630:	    errno = e;
    #####: 6631:	    perror(ofname);
call    0 never executed
        -: 6632:	}
        -: 6633:    }
        -: 6634:#ifndef NO_CHOWN
    #####: 6635:    chown(ofname, ifstat->st_uid, ifstat->st_gid);  /* Copy ownership */
call    0 never executed
        -: 6636:#endif
    #####: 6637:    remove_ofname = 0;
        -: 6638:    /* It's now safe to remove the input file: */
    #####: 6639:    if (xunlink (ifname)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 6640:	int e = errno;
    #####: 6641:	WARN((stderr, "%s: ", progname));
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 6642:	if (!quiet) {
branch  0 never executed
branch  1 never executed
        -: 6643:#ifdef FAULTY_F_KL_7
    #####: 6644:	    errno = e-1;
        -: 6645:#else
        -: 6646:	    errno = e;
        -: 6647:#endif
    #####: 6648:	    perror(ifname);
call    0 never executed
        -: 6649:	}
        -: 6650:    }
    #####: 6651:}
        -: 6652:
        -: 6653:#ifndef NO_DIR
        -: 6654:
        -: 6655:/* ========================================================================
        -: 6656: * Recurse through the given directory. This code is taken from ncompress.
        -: 6657: */
function treat_dir called 0 returned 0% blocks executed 0%
    #####: 6658:local void treat_dir(dir)
        -: 6659:    char *dir;
        -: 6660:{
        -: 6661:    struct dirent *dp;
        -: 6662:    DIR      *dirp;
        -: 6663:    char     nbuf[MAX_PATH_LEN];
        -: 6664:    int      len;
        -: 6665:
    #####: 6666:    dirp = opendir(dir);
call    0 never executed
        -: 6667:    
    #####: 6668:    if (dirp == NULL) {
branch  0 never executed
branch  1 never executed
    #####: 6669:	progerror(dir);
call    0 never executed
    #####: 6670:	return ;
        -: 6671:    }
        -: 6672:    /*
        -: 6673:     ** WARNING: the following algorithm could occasionally cause
        -: 6674:     ** compress to produce error warnings of the form "<filename>.gz
        -: 6675:     ** already has .gz suffix - ignored". This occurs when the
        -: 6676:     ** .gz output file is inserted into the directory below
        -: 6677:     ** readdir's current pointer.
        -: 6678:     ** These warnings are harmless but annoying, so they are suppressed
        -: 6679:     ** with option -r (except when -v is on). An alternative
        -: 6680:     ** to allowing this would be to store the entire directory
        -: 6681:     ** list in memory, then compress the entries in the stored
        -: 6682:     ** list. Given the depth-first recursive algorithm used here,
        -: 6683:     ** this could use up a tremendous amount of memory. I don't
        -: 6684:     ** think it's worth it. -- Dave Mack
        -: 6685:     ** (An other alternative might be two passes to avoid depth-first.)
        -: 6686:     */
        -: 6687:    
    #####: 6688:    while ((errno = 0, dp = readdir(dirp)) != NULL) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 6689:
    #####: 6690:	if (strequ(dp->d_name,".") || strequ(dp->d_name,"..")) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 6691:	    continue;
        -: 6692:	}
    #####: 6693:	len = strlen(dir);
    #####: 6694:	if (len + NAMLEN(dp) + 1 < MAX_PATH_LEN - 1) {
branch  0 never executed
branch  1 never executed
    #####: 6695:	    strcpy(nbuf,dir);
    #####: 6696:	    if (len != 0 /* dir = "" means current dir on Amiga */
branch  0 never executed
branch  1 never executed
        -: 6697:#ifdef PATH_SEP2
        -: 6698:		&& dir[len-1] != PATH_SEP2
        -: 6699:#endif
        -: 6700:#ifdef PATH_SEP3
        -: 6701:		&& dir[len-1] != PATH_SEP3
        -: 6702:#endif
        -: 6703:	    ) {
    #####: 6704:		nbuf[len++] = PATH_SEP;
        -: 6705:	    }
    #####: 6706:	    strcpy(nbuf+len, dp->d_name);
    #####: 6707:	    treat_file(nbuf);
call    0 never executed
        -: 6708:	} else {
    #####: 6709:	    fprintf(stderr,"%s: %s/%s: pathname too long\n",
    #####: 6710:		    progname, dir, dp->d_name);
call    0 never executed
    #####: 6711:	    exit_code = ERROR;
        -: 6712:	}
        -: 6713:    }
        -: 6714:#ifdef FAULTY_F_KL_8
    #####: 6715:    if (errno == 0)
branch  0 never executed
branch  1 never executed
    #####: 6716:	progerror(dirp);
call    0 never executed
        -: 6717:#else
        -: 6718:    if (errno != 0)
        -: 6719:	progerror(dir);
        -: 6720:#endif
    #####: 6721:    if (CLOSEDIR(dirp) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 6722:	progerror(dir);
call    0 never executed
        -: 6723:}
        -: 6724:#endif /* ? NO_DIR */
        -: 6725:
        -: 6726:/* ========================================================================
        -: 6727: * Free all dynamically allocated variables and exit with the given code.
        -: 6728: */
function do_exit called 1 returned 0% blocks executed 57%
        1: 6729:local void do_exit(exitcode)
        -: 6730:    int exitcode;
        -: 6731:{
        -: 6732:    static int in_exit = 0;
        -: 6733:
       1*: 6734:    if (in_exit) exit(exitcode);
branch  0 taken 0 (fallthrough)
branch  1 taken 1
call    2 never executed
        1: 6735:    in_exit = 1;
       1*: 6736:    if (env != NULL)  free(env),  env  = NULL;
branch  0 taken 0 (fallthrough)
branch  1 taken 1
       1*: 6737:    if (args != NULL) free((char*)args), args = NULL;
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -: 6738:    FREE(inbuf);
        -: 6739:    FREE(outbuf);
        -: 6740:    FREE(d_buf);
        -: 6741:    FREE(window);
        -: 6742:#ifndef MAXSEG_64K
        -: 6743:    FREE(tab_prefix);
        -: 6744:#else
        -: 6745:    FREE(tab_prefix0);
        -: 6746:    FREE(tab_prefix1);
        -: 6747:#endif
        1: 6748:    exit(exitcode);
        -: 6749:}
        -: 6750:
        -: 6751:/* ========================================================================
        -: 6752: * Signal and error handler.
        -: 6753: */
function abort_gzip called 0 returned 0% blocks executed 0%
    #####: 6754:RETSIGTYPE abort_gzip()
        -: 6755:{
    #####: 6756:   if (remove_ofname) {
branch  0 never executed
branch  1 never executed
    #####: 6757:       close(ofd);
call    0 never executed
    #####: 6758:       xunlink (ofname);
call    0 never executed
        -: 6759:   }
    #####: 6760:   do_exit(ERROR);
call    0 never executed
    #####: 6761:}
        -: 6762:/* Getopt for GNU.
        -: 6763:   NOTE: The canonical source of this file is maintained with the GNU
        -: 6764:   C Library.  Bugs can be reported to bug-glibc@gnu.org.
        -: 6765:
        -: 6766:   Copyright (C) 1987, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99
        -: 6767:   	Free Software Foundation, Inc.
        -: 6768:
        -: 6769:   This program is free software; you can redistribute it and/or modify it
        -: 6770:   under the terms of the GNU General Public License as published by the
        -: 6771:   Free Software Foundation; either version 2, or (at your option) any
        -: 6772:   later version.
        -: 6773:
        -: 6774:   This program is distributed in the hope that it will be useful,
        -: 6775:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 6776:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 6777:   GNU General Public License for more details.
        -: 6778:
        -: 6779:   You should have received a copy of the GNU General Public License
        -: 6780:   along with this program; if not, write to the Free Software Foundation,
        -: 6781:   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
        -: 6782:
        -: 6783:/* This tells Alpha OSF/1 not to define a getopt prototype in <stdio.h>.
        -: 6784:   Ditto for AIX 3.2 and <stdlib.h>.  */
        -: 6785:#ifndef _NO_PROTO
        -: 6786:# define _NO_PROTO
        -: 6787:#endif
        -: 6788:
        -: 6789:#ifdef HAVE_CONFIG_H
        -: 6790:# include <config.h>
        -: 6791:#else
        -: 6792:# if !defined __STDC__ || !__STDC__
        -: 6793:/* This is a separate conditional since some stdc systems
        -: 6794:   reject `defined (const)'.  */
        -: 6795:#  ifndef const
        -: 6796:#   define const
        -: 6797:#  endif
        -: 6798:# endif
        -: 6799:#endif
        -: 6800:
        -: 6801:/* Comment out all this code if we are using the GNU C Library, and are not
        -: 6802:   actually compiling the library itself.  This code is part of the GNU C
        -: 6803:   Library, but also included in many other GNU distributions.  Compiling
        -: 6804:   and linking in this code is a waste when using the GNU C library
        -: 6805:   (especially if it is a shared library).  Rather than having every GNU
        -: 6806:   program understand `configure --with-gnu-libc' and omit the object files,
        -: 6807:   it is simpler to just do this in the source for each such file.  */
        -: 6808:
        -: 6809:#define GETOPT_INTERFACE_VERSION 2
        -: 6810:#if !defined _LIBC && defined __GLIBC__ && __GLIBC__ >= 2
        -: 6811:# include <gnu-versions.h>
        -: 6812:# if _GNU_GETOPT_INTERFACE_VERSION == GETOPT_INTERFACE_VERSION
        -: 6813:#  define ELIDE_CODE
        -: 6814:# endif
        -: 6815:#endif
        -: 6816:
        -: 6817:#ifndef ELIDE_CODE
        -: 6818:
        -: 6819:
        -: 6820:/* This needs to come after some library #include
        -: 6821:   to get __GNU_LIBRARY__ defined.  */
        -: 6822:#ifdef	__GNU_LIBRARY__
        -: 6823:/* Don't include stdlib.h for non-GNU C libraries because some of them
        -: 6824:   contain conflicting prototypes for getopt.  */
        -: 6825:# include <stdlib.h>
        -: 6826:# include <unistd.h>
        -: 6827:#endif	/* GNU C library.  */
        -: 6828:
        -: 6829:#ifdef VMS
        -: 6830:# include <unixlib.h>
        -: 6831:# if HAVE_STRING_H - 0
        -: 6832:#  include <string.h>
        -: 6833:# endif
        -: 6834:#endif
        -: 6835:
        -: 6836:#ifndef _
        -: 6837:/* This is for other GNU distributions with internationalized messages.
        -: 6838:   When compiling libc, the _ macro is predefined.  */
        -: 6839:# ifdef HAVE_LIBINTL_H
        -: 6840:#  include <libintl.h>
        -: 6841:#  define _(msgid)	gettext (msgid)
        -: 6842:# else
        -: 6843:#  define _(msgid)	(msgid)
        -: 6844:# endif
        -: 6845:#endif
        -: 6846:
        -: 6847:/* This version of `getopt' appears to the caller like standard Unix `getopt'
        -: 6848:   but it behaves differently for the user, since it allows the user
        -: 6849:   to intersperse the options with the other arguments.
        -: 6850:
        -: 6851:   As `getopt' works, it permutes the elements of ARGV so that,
        -: 6852:   when it is done, all the options precede everything else.  Thus
        -: 6853:   all application programs are extended to handle flexible argument order.
        -: 6854:
        -: 6855:   Setting the environment variable POSIXLY_CORRECT disables permutation.
        -: 6856:   Then the behavior is completely standard.
        -: 6857:
        -: 6858:   GNU application programs can use a third alternative mode in which
        -: 6859:   they can distinguish the relative order of options and other arguments.  */
        -: 6860:
        -: 6861:/* For communication from `getopt' to the caller.
        -: 6862:   When `getopt' finds an option that takes an argument,
        -: 6863:   the argument value is returned here.
        -: 6864:   Also, when `ordering' is RETURN_IN_ORDER,
        -: 6865:   each non-option ARGV-element is returned here.  */
        -: 6866:
        -: 6867:char *optarg;
        -: 6868:
        -: 6869:/* Index in ARGV of the next element to be scanned.
        -: 6870:   This is used for communication to and from the caller
        -: 6871:   and for communication between successive calls to `getopt'.
        -: 6872:
        -: 6873:   On entry to `getopt', zero means this is the first call; initialize.
        -: 6874:
        -: 6875:   When `getopt' returns -1, this is the index of the first of the
        -: 6876:   non-option elements that the caller should itself scan.
        -: 6877:
        -: 6878:   Otherwise, `optind' communicates from one call to the next
        -: 6879:   how much of ARGV has been scanned so far.  */
        -: 6880:
        -: 6881:/* 1003.2 says this must be 1 before any call.  */
        -: 6882:int optind = 1;
        -: 6883:
        -: 6884:/* Formerly, initialization of getopt depended on optind==0, which
        -: 6885:   causes problems with re-calling getopt as programs generally don't
        -: 6886:   know that. */
        -: 6887:
        -: 6888:int __getopt_initialized;
        -: 6889:
        -: 6890:/* The next char to be scanned in the option-element
        -: 6891:   in which the last option character we returned was found.
        -: 6892:   This allows us to pick up the scan where we left off.
        -: 6893:
        -: 6894:   If this is zero, or a null string, it means resume the scan
        -: 6895:   by advancing to the next ARGV-element.  */
        -: 6896:
        -: 6897:static char *nextchar;
        -: 6898:
        -: 6899:/* Callers store zero here to inhibit the error message
        -: 6900:   for unrecognized options.  */
        -: 6901:
        -: 6902:int opterr = 1;
        -: 6903:
        -: 6904:/* Set to an option character which was unrecognized.
        -: 6905:   This must be initialized on some systems to avoid linking in the
        -: 6906:   system's own getopt implementation.  */
        -: 6907:
        -: 6908:int optopt = '?';
        -: 6909:
        -: 6910:/* Describe how to deal with options that follow non-option ARGV-elements.
        -: 6911:
        -: 6912:   If the caller did not specify anything,
        -: 6913:   the default is REQUIRE_ORDER if the environment variable
        -: 6914:   POSIXLY_CORRECT is defined, PERMUTE otherwise.
        -: 6915:
        -: 6916:   REQUIRE_ORDER means don't recognize them as options;
        -: 6917:   stop option processing when the first non-option is seen.
        -: 6918:   This is what Unix does.
        -: 6919:   This mode of operation is selected by either setting the environment
        -: 6920:   variable POSIXLY_CORRECT, or using `+' as the first character
        -: 6921:   of the list of option characters.
        -: 6922:
        -: 6923:   PERMUTE is the default.  We permute the contents of ARGV as we scan,
        -: 6924:   so that eventually all the non-options are at the end.  This allows options
        -: 6925:   to be given in any order, even with programs that were not written to
        -: 6926:   expect this.
        -: 6927:
        -: 6928:   RETURN_IN_ORDER is an option available to programs that were written
        -: 6929:   to expect options and other ARGV-elements in any order and that care about
        -: 6930:   the ordering of the two.  We describe each non-option ARGV-element
        -: 6931:   as if it were the argument of an option with character code 1.
        -: 6932:   Using `-' as the first character of the list of option characters
        -: 6933:   selects this mode of operation.
        -: 6934:
        -: 6935:   The special argument `--' forces an end of option-scanning regardless
        -: 6936:   of the value of `ordering'.  In the case of RETURN_IN_ORDER, only
        -: 6937:   `--' can cause `getopt' to return -1 with `optind' != ARGC.  */
        -: 6938:
        -: 6939:static enum
        -: 6940:{
        -: 6941:  REQUIRE_ORDER, PERMUTE, RETURN_IN_ORDER
        -: 6942:} ordering;
        -: 6943:
        -: 6944:/* Value of POSIXLY_CORRECT environment variable.  */
        -: 6945:static char *posixly_correct;
        -: 6946:
        -: 6947:#ifdef	__GNU_LIBRARY__
        -: 6948:/* We want to avoid inclusion of string.h with non-GNU libraries
        -: 6949:   because there are many ways it can cause trouble.
        -: 6950:   On some systems, it contains special magic macros that don't work
        -: 6951:   in GCC.  */
        -: 6952:# include <string.h>
        -: 6953:# define my_index	strchr
        -: 6954:#else
        -: 6955:
        -: 6956:# if HAVE_STRING_H
        -: 6957:#  include <string.h>
        -: 6958:# else
        -: 6959:#  include <strings.h>
        -: 6960:# endif
        -: 6961:
        -: 6962:/* Avoid depending on library functions or files
        -: 6963:   whose names are inconsistent.  */
        -: 6964:
        -: 6965:#ifndef getenv
        -: 6966:extern char *getenv ();
        -: 6967:#endif
        -: 6968:
        -: 6969:static char *
        -: 6970:my_index (str, chr)
        -: 6971:     const char *str;
        -: 6972:     int chr;
        -: 6973:{
        -: 6974:  while (*str)
        -: 6975:    {
        -: 6976:      if (*str == chr)
        -: 6977:	return (char *) str;
        -: 6978:      str++;
        -: 6979:    }
        -: 6980:  return 0;
        -: 6981:}
        -: 6982:
        -: 6983:/* If using GCC, we can safely declare strlen this way.
        -: 6984:   If not using GCC, it is ok not to declare it.  */
        -: 6985:#ifdef __GNUC__
        -: 6986:/* Note that Motorola Delta 68k R3V7 comes with GCC but not stddef.h.
        -: 6987:   That was relevant to code that was here before.  */
        -: 6988:# if (!defined __STDC__ || !__STDC__) && !defined strlen
        -: 6989:/* gcc with -traditional declares the built-in strlen to return int,
        -: 6990:   and has done so at least since version 2.4.5. -- rms.  */
        -: 6991:extern int strlen (const char *);
        -: 6992:# endif /* not __STDC__ */
        -: 6993:#endif /* __GNUC__ */
        -: 6994:
        -: 6995:#endif /* not __GNU_LIBRARY__ */
        -: 6996:
        -: 6997:/* Handle permutation of arguments.  */
        -: 6998:
        -: 6999:/* Describe the part of ARGV that contains non-options that have
        -: 7000:   been skipped.  `first_nonopt' is the index in ARGV of the first of them;
        -: 7001:   `last_nonopt' is the index after the last of them.  */
        -: 7002:
        -: 7003:static int first_nonopt;
        -: 7004:static int last_nonopt;
        -: 7005:
        -: 7006:#ifdef _LIBC
        -: 7007:/* Bash 2.0 gives us an environment variable containing flags
        -: 7008:   indicating ARGV elements that should not be considered arguments.  */
        -: 7009:
        -: 7010:/* Defined in getopt_init.c  */
        -: 7011:extern char *__getopt_nonoption_flags;
        -: 7012:
        -: 7013:static int nonoption_flags_max_len;
        -: 7014:static int nonoption_flags_len;
        -: 7015:
        -: 7016:static int original_argc;
        -: 7017:static char *const *original_argv;
        -: 7018:
        -: 7019:/* Make sure the environment variable bash 2.0 puts in the environment
        -: 7020:   is valid for the getopt call we must make sure that the ARGV passed
        -: 7021:   to getopt is that one passed to the process.  */
        -: 7022:static void
        -: 7023:__attribute__ ((unused))
        -: 7024:store_args_and_env (int argc, char *const *argv)
        -: 7025:{
        -: 7026:  /* XXX This is no good solution.  We should rather copy the args so
        -: 7027:     that we can compare them later.  But we must not use malloc(3).  */
        -: 7028:  original_argc = argc;
        -: 7029:  original_argv = argv;
        -: 7030:}
        -: 7031:# ifdef text_set_element
        -: 7032:text_set_element (__libc_subinit, store_args_and_env);
        -: 7033:# endif /* text_set_element */
        -: 7034:
        -: 7035:# define SWAP_FLAGS(ch1, ch2) \
        -: 7036:  if (nonoption_flags_len > 0)						      \
        -: 7037:    {									      \
        -: 7038:      char __tmp = __getopt_nonoption_flags[ch1];			      \
        -: 7039:      __getopt_nonoption_flags[ch1] = __getopt_nonoption_flags[ch2];	      \
        -: 7040:      __getopt_nonoption_flags[ch2] = __tmp;				      \
        -: 7041:    }
        -: 7042:#else	/* !_LIBC */
        -: 7043:# define SWAP_FLAGS(ch1, ch2)
        -: 7044:#endif	/* _LIBC */
        -: 7045:
        -: 7046:/* Exchange two adjacent subsequences of ARGV.
        -: 7047:   One subsequence is elements [first_nonopt,last_nonopt)
        -: 7048:   which contains all the non-options that have been skipped so far.
        -: 7049:   The other is elements [last_nonopt,optind), which contains all
        -: 7050:   the options processed since those non-options were skipped.
        -: 7051:
        -: 7052:   `first_nonopt' and `last_nonopt' are relocated so that they describe
        -: 7053:   the new indices of the non-options in ARGV after they are moved.  */
        -: 7054:
        -: 7055:#if defined __STDC__ && __STDC__
        -: 7056:static void exchange (char **);
        -: 7057:#endif
        -: 7058:
        -: 7059:static void
        -: 7060:exchange (argv)
        -: 7061:     char **argv;
        -: 7062:{
        -: 7063:  int bottom = first_nonopt;
        -: 7064:  int middle = last_nonopt;
        -: 7065:  int top = optind;
        -: 7066:  char *tem;
        -: 7067:
        -: 7068:  /* Exchange the shorter segment with the far end of the longer segment.
        -: 7069:     That puts the shorter segment into the right place.
        -: 7070:     It leaves the longer segment in the right place overall,
        -: 7071:     but it consists of two parts that need to be swapped next.  */
        -: 7072:
        -: 7073:#ifdef _LIBC
        -: 7074:  /* First make sure the handling of the `__getopt_nonoption_flags'
        -: 7075:     string can work normally.  Our top argument must be in the range
        -: 7076:     of the string.  */
        -: 7077:  if (nonoption_flags_len > 0 && top >= nonoption_flags_max_len)
        -: 7078:    {
        -: 7079:      /* We must extend the array.  The user plays games with us and
        -: 7080:	 presents new arguments.  */
        -: 7081:      char *new_str = malloc (top + 1);
        -: 7082:#ifdef FAULTY_F_TW_6
        -: 7083:      if (new_str != NULL)
        -: 7084:#else
        -: 7085:      if (new_str == NULL)
        -: 7086:#endif
        -: 7087:	nonoption_flags_len = nonoption_flags_max_len = 0;
        -: 7088:      else
        -: 7089:	{
        -: 7090:	  memset (__mempcpy (new_str, __getopt_nonoption_flags,
        -: 7091:			     nonoption_flags_max_len),
        -: 7092:		  '\0', top + 1 - nonoption_flags_max_len);
        -: 7093:	  nonoption_flags_max_len = top + 1;
        -: 7094:	  __getopt_nonoption_flags = new_str;
        -: 7095:	}
        -: 7096:    }
        -: 7097:#endif
        -: 7098:
        -: 7099:  while (top > middle && middle > bottom)
        -: 7100:    {
        -: 7101:      if (top - middle > middle - bottom)
        -: 7102:	{
        -: 7103:	  /* Bottom segment is the short one.  */
        -: 7104:	  int len = middle - bottom;
        -: 7105:	  register int i;
        -: 7106:
        -: 7107:	  /* Swap it with the top part of the top segment.  */
        -: 7108:	  for (i = 0; i < len; i++)
        -: 7109:	    {
        -: 7110:	      tem = argv[bottom + i];
        -: 7111:	      argv[bottom + i] = argv[top - (middle - bottom) + i];
        -: 7112:	      argv[top - (middle - bottom) + i] = tem;
        -: 7113:	      SWAP_FLAGS (bottom + i, top - (middle - bottom) + i);
        -: 7114:	    }
        -: 7115:	  /* Exclude the moved bottom segment from further swapping.  */
        -: 7116:	  top -= len;
        -: 7117:	}
        -: 7118:      else
        -: 7119:	{
        -: 7120:	  /* Top segment is the short one.  */
        -: 7121:	  int len = top - middle;
        -: 7122:	  register int i;
        -: 7123:
        -: 7124:	  /* Swap it with the bottom part of the bottom segment.  */
        -: 7125:	  for (i = 0; i < len; i++)
        -: 7126:	    {
        -: 7127:	      tem = argv[bottom + i];
        -: 7128:	      argv[bottom + i] = argv[middle + i];
        -: 7129:	      argv[middle + i] = tem;
        -: 7130:	      SWAP_FLAGS (bottom + i, middle + i);
        -: 7131:	    }
        -: 7132:	  /* Exclude the moved top segment from further swapping.  */
        -: 7133:	  bottom += len;
        -: 7134:	}
        -: 7135:    }
        -: 7136:
        -: 7137:  /* Update records for the slots the non-options now occupy.  */
        -: 7138:
        -: 7139:  first_nonopt += (optind - last_nonopt);
        -: 7140:  last_nonopt = optind;
        -: 7141:}
        -: 7142:
        -: 7143:/* Initialize the internal data when the first call is made.  */
        -: 7144:
        -: 7145:#if defined __STDC__ && __STDC__
        -: 7146:static const char *_getopt_initialize (int, char *const *, const char *);
        -: 7147:#endif
        -: 7148:static const char *
        -: 7149:_getopt_initialize (argc, argv, optstring)
        -: 7150:     int argc;
        -: 7151:     char *const *argv;
        -: 7152:     const char *optstring;
        -: 7153:{
        -: 7154:  /* Start processing options with ARGV-element 1 (since ARGV-element 0
        -: 7155:     is the program name); the sequence of previously skipped
        -: 7156:     non-option ARGV-elements is empty.  */
        -: 7157:
        -: 7158:  first_nonopt = last_nonopt = optind;
        -: 7159:
        -: 7160:  nextchar = NULL;
        -: 7161:
        -: 7162:  posixly_correct = getenv ("POSIXLY_CORRECT");
        -: 7163:
        -: 7164:  /* Determine how to handle the ordering of options and nonoptions.  */
        -: 7165:
        -: 7166:  if (optstring[0] == '-')
        -: 7167:    {
        -: 7168:      ordering = RETURN_IN_ORDER;
        -: 7169:      ++optstring;
        -: 7170:    }
        -: 7171:  else if (optstring[0] == '+')
        -: 7172:    {
        -: 7173:      ordering = REQUIRE_ORDER;
        -: 7174:      ++optstring;
        -: 7175:    }
        -: 7176:  else if (posixly_correct != NULL)
        -: 7177:    ordering = REQUIRE_ORDER;
        -: 7178:  else
        -: 7179:    ordering = PERMUTE;
        -: 7180:
        -: 7181:#ifdef _LIBC
        -: 7182:  if (posixly_correct == NULL
        -: 7183:      && argc == original_argc && argv == original_argv)
        -: 7184:    {
        -: 7185:      if (nonoption_flags_max_len == 0)
        -: 7186:	{
        -: 7187:	  if (__getopt_nonoption_flags == NULL
        -: 7188:	      || __getopt_nonoption_flags[0] == '\0')
        -: 7189:	    nonoption_flags_max_len = -1;
        -: 7190:	  else
        -: 7191:	    {
        -: 7192:	      const char *orig_str = __getopt_nonoption_flags;
        -: 7193:	      int len = nonoption_flags_max_len = strlen (orig_str);
        -: 7194:	      if (nonoption_flags_max_len < argc)
        -: 7195:		nonoption_flags_max_len = argc;
        -: 7196:	      __getopt_nonoption_flags =
        -: 7197:		(char *) malloc (nonoption_flags_max_len);
        -: 7198:	      if (__getopt_nonoption_flags == NULL)
        -: 7199:		nonoption_flags_max_len = -1;
        -: 7200:	      else
        -: 7201:		memset (__mempcpy (__getopt_nonoption_flags, orig_str, len),
        -: 7202:			'\0', nonoption_flags_max_len - len);
        -: 7203:	    }
        -: 7204:	}
        -: 7205:      nonoption_flags_len = nonoption_flags_max_len;
        -: 7206:    }
        -: 7207:  else
        -: 7208:    nonoption_flags_len = 0;
        -: 7209:#endif
        -: 7210:
        -: 7211:  return optstring;
        -: 7212:}
        -: 7213:
        -: 7214:/* Scan elements of ARGV (whose length is ARGC) for option characters
        -: 7215:   given in OPTSTRING.
        -: 7216:
        -: 7217:   If an element of ARGV starts with '-', and is not exactly "-" or "--",
        -: 7218:   then it is an option element.  The characters of this element
        -: 7219:   (aside from the initial '-') are option characters.  If `getopt'
        -: 7220:   is called repeatedly, it returns successively each of the option characters
        -: 7221:   from each of the option elements.
        -: 7222:
        -: 7223:   If `getopt' finds another option character, it returns that character,
        -: 7224:   updating `optind' and `nextchar' so that the next call to `getopt' can
        -: 7225:   resume the scan with the following option character or ARGV-element.
        -: 7226:
        -: 7227:   If there are no more option characters, `getopt' returns -1.
        -: 7228:   Then `optind' is the index in ARGV of the first ARGV-element
        -: 7229:   that is not an option.  (The ARGV-elements have been permuted
        -: 7230:   so that those that are not options now come last.)
        -: 7231:
        -: 7232:   OPTSTRING is a string containing the legitimate option characters.
        -: 7233:   If an option character is seen that is not listed in OPTSTRING,
        -: 7234:   return '?' after printing an error message.  If you set `opterr' to
        -: 7235:   zero, the error message is suppressed but we still return '?'.
        -: 7236:
        -: 7237:   If a char in OPTSTRING is followed by a colon, that means it wants an arg,
        -: 7238:   so the following text in the same ARGV-element, or the text of the following
        -: 7239:   ARGV-element, is returned in `optarg'.  Two colons mean an option that
        -: 7240:   wants an optional arg; if there is text in the current ARGV-element,
        -: 7241:   it is returned in `optarg', otherwise `optarg' is set to zero.
        -: 7242:
        -: 7243:   If OPTSTRING starts with `-' or `+', it requests different methods of
        -: 7244:   handling the non-option ARGV-elements.
        -: 7245:   See the comments about RETURN_IN_ORDER and REQUIRE_ORDER, above.
        -: 7246:
        -: 7247:   Long-named options begin with `--' instead of `-'.
        -: 7248:   Their names may be abbreviated as long as the abbreviation is unique
        -: 7249:   or is an exact match for some defined option.  If they have an
        -: 7250:   argument, it follows the option name in the same ARGV-element, separated
        -: 7251:   from the option name by a `=', or else the in next ARGV-element.
        -: 7252:   When `getopt' finds a long-named option, it returns 0 if that option's
        -: 7253:   `flag' field is nonzero, the value of the option's `val' field
        -: 7254:   if the `flag' field is zero.
        -: 7255:
        -: 7256:   The elements of ARGV aren't really const, because we permute them.
        -: 7257:   But we pretend they're const in the prototype to be compatible
        -: 7258:   with other systems.
        -: 7259:
        -: 7260:   LONGOPTS is a vector of `struct option' terminated by an
        -: 7261:   element containing a name which is zero.
        -: 7262:
        -: 7263:   LONGIND returns the index in LONGOPT of the long-named option found.
        -: 7264:   It is only valid when a long-named option has been found by the most
        -: 7265:   recent call.
        -: 7266:
        -: 7267:   If LONG_ONLY is nonzero, '-' as well as '--' can introduce
        -: 7268:   long-named options.  */
        -: 7269:
        -: 7270:int
        -: 7271:_getopt_internal (argc, argv, optstring, longopts, longind, long_only)
        -: 7272:     int argc;
        -: 7273:     char *const *argv;
        -: 7274:     const char *optstring;
        -: 7275:     const struct option *longopts;
        -: 7276:     int *longind;
        -: 7277:     int long_only;
        -: 7278:{
        -: 7279:  optarg = NULL;
        -: 7280:
        -: 7281:  if (optind == 0 || !__getopt_initialized)
        -: 7282:    {
        -: 7283:      if (optind == 0)
        -: 7284:	optind = 1;	/* Don't scan ARGV[0], the program name.  */
        -: 7285:      optstring = _getopt_initialize (argc, argv, optstring);
        -: 7286:      __getopt_initialized = 1;
        -: 7287:    }
        -: 7288:
        -: 7289:  /* Test whether ARGV[optind] points to a non-option argument.
        -: 7290:     Either it does not have option syntax, or there is an environment flag
        -: 7291:     from the shell indicating it is not an option.  The later information
        -: 7292:     is only used when the used in the GNU libc.  */
        -: 7293:#ifdef _LIBC
        -: 7294:# define NONOPTION_P (argv[optind][0] != '-' || argv[optind][1] == '\0'	      \
        -: 7295:		      || (optind < nonoption_flags_len			      \
        -: 7296:			  && __getopt_nonoption_flags[optind] == '1'))
        -: 7297:#else
        -: 7298:# define NONOPTION_P (argv[optind][0] != '-' || argv[optind][1] == '\0')
        -: 7299:#endif
        -: 7300:
        -: 7301:  if (nextchar == NULL || *nextchar == '\0')
        -: 7302:    {
        -: 7303:      /* Advance to the next ARGV-element.  */
        -: 7304:
        -: 7305:      /* Give FIRST_NONOPT & LAST_NONOPT rational values if OPTIND has been
        -: 7306:	 moved back by the user (who may also have changed the arguments).  */
        -: 7307:      if (last_nonopt > optind)
        -: 7308:	last_nonopt = optind;
        -: 7309:      if (first_nonopt > optind)
        -: 7310:	first_nonopt = optind;
        -: 7311:
        -: 7312:      if (ordering == PERMUTE)
        -: 7313:	{
        -: 7314:	  /* If we have just processed some options following some non-options,
        -: 7315:	     exchange them so that the options come first.  */
        -: 7316:
        -: 7317:	  if (first_nonopt != last_nonopt && last_nonopt != optind)
        -: 7318:	    exchange ((char **) argv);
        -: 7319:	  else if (last_nonopt != optind)
        -: 7320:	    first_nonopt = optind;
        -: 7321:
        -: 7322:	  /* Skip any additional non-options
        -: 7323:	     and extend the range of non-options previously skipped.  */
        -: 7324:
        -: 7325:	  while (optind < argc && NONOPTION_P)
        -: 7326:	    optind++;
        -: 7327:	  last_nonopt = optind;
        -: 7328:	}
        -: 7329:
        -: 7330:      /* The special ARGV-element `--' means premature end of options.
        -: 7331:	 Skip it like a null option,
        -: 7332:	 then exchange with previous non-options as if it were an option,
        -: 7333:	 then skip everything else like a non-option.  */
        -: 7334:
        -: 7335:      if (optind != argc && !strcmp (argv[optind], "--"))
        -: 7336:	{
        -: 7337:	  optind++;
        -: 7338:
        -: 7339:	  if (first_nonopt != last_nonopt && last_nonopt != optind)
        -: 7340:	    exchange ((char **) argv);
        -: 7341:	  else if (first_nonopt == last_nonopt)
        -: 7342:	    first_nonopt = optind;
        -: 7343:	  last_nonopt = argc;
        -: 7344:
        -: 7345:	  optind = argc;
        -: 7346:	}
        -: 7347:
        -: 7348:      /* If we have done all the ARGV-elements, stop the scan
        -: 7349:	 and back over any non-options that we skipped and permuted.  */
        -: 7350:
        -: 7351:      if (optind == argc)
        -: 7352:	{
        -: 7353:	  /* Set the next-arg-index to point at the non-options
        -: 7354:	     that we previously skipped, so the caller will digest them.  */
        -: 7355:	  if (first_nonopt != last_nonopt)
        -: 7356:	    optind = first_nonopt;
        -: 7357:	  return -1;
        -: 7358:	}
        -: 7359:
        -: 7360:      /* If we have come to a non-option and did not permute it,
        -: 7361:	 either stop the scan or describe it to the caller and pass it by.  */
        -: 7362:
        -: 7363:      if (NONOPTION_P)
        -: 7364:	{
        -: 7365:	  if (ordering == REQUIRE_ORDER)
        -: 7366:	    return -1;
        -: 7367:	  optarg = argv[optind++];
        -: 7368:	  return 1;
        -: 7369:	}
        -: 7370:
        -: 7371:      /* We have found another option-ARGV-element.
        -: 7372:	 Skip the initial punctuation.  */
        -: 7373:
        -: 7374:      nextchar = (argv[optind] + 1
        -: 7375:		  + (longopts != NULL && argv[optind][1] == '-'));
        -: 7376:    }
        -: 7377:
        -: 7378:  /* Decode the current option-ARGV-element.  */
        -: 7379:
        -: 7380:  /* Check whether the ARGV-element is a long option.
        -: 7381:
        -: 7382:     If long_only and the ARGV-element has the form "-f", where f is
        -: 7383:     a valid short option, don't consider it an abbreviated form of
        -: 7384:     a long option that starts with f.  Otherwise there would be no
        -: 7385:     way to give the -f short option.
        -: 7386:
        -: 7387:     On the other hand, if there's a long option "fubar" and
        -: 7388:     the ARGV-element is "-fu", do consider that an abbreviation of
        -: 7389:     the long option, just like "--fu", and not "-f" with arg "u".
        -: 7390:
        -: 7391:     This distinction seems to be the most useful approach.  */
        -: 7392:
        -: 7393:  if (longopts != NULL
        -: 7394:      && (argv[optind][1] == '-'
        -: 7395:	  || (long_only && (argv[optind][2] || !my_index (optstring, argv[optind][1])))))
        -: 7396:    {
        -: 7397:      char *nameend;
        -: 7398:      const struct option *p;
        -: 7399:      const struct option *pfound = NULL;
        -: 7400:      int exact = 0;
        -: 7401:      int ambig = 0;
        -: 7402:      int indfound = -1;
        -: 7403:      int option_index;
        -: 7404:
        -: 7405:      for (nameend = nextchar; *nameend && *nameend != '='; nameend++)
        -: 7406:	/* Do nothing.  */ ;
        -: 7407:
        -: 7408:      /* Test all long options for either exact match
        -: 7409:	 or abbreviated matches.  */
        -: 7410:      for (p = longopts, option_index = 0; p->name; p++, option_index++)
        -: 7411:	if (!strncmp (p->name, nextchar, nameend - nextchar))
        -: 7412:	  {
        -: 7413:	    if ((unsigned int) (nameend - nextchar)
        -: 7414:		== (unsigned int) strlen (p->name))
        -: 7415:	      {
        -: 7416:		/* Exact match found.  */
        -: 7417:		pfound = p;
        -: 7418:		indfound = option_index;
        -: 7419:		exact = 1;
        -: 7420:		break;
        -: 7421:	      }
        -: 7422:	    else if (pfound == NULL)
        -: 7423:	      {
        -: 7424:		/* First nonexact match found.  */
        -: 7425:		pfound = p;
        -: 7426:		indfound = option_index;
        -: 7427:	      }
        -: 7428:	    else
        -: 7429:	      /* Second or later nonexact match found.  */
        -: 7430:	      ambig = 1;
        -: 7431:	  }
        -: 7432:
        -: 7433:      if (ambig && !exact)
        -: 7434:	{
        -: 7435:	  if (opterr)
        -: 7436:	    fprintf (stderr, _("%s: option `%s' is ambiguous\n"),
        -: 7437:		     argv[0], argv[optind]);
        -: 7438:	  nextchar += strlen (nextchar);
        -: 7439:	  optind++;
        -: 7440:	  optopt = 0;
        -: 7441:	  return '?';
        -: 7442:	}
        -: 7443:
        -: 7444:      if (pfound != NULL)
        -: 7445:	{
        -: 7446:	  option_index = indfound;
        -: 7447:	  optind++;
        -: 7448:	  if (*nameend)
        -: 7449:	    {
        -: 7450:	      /* Don't test has_arg with >, because some C compilers don't
        -: 7451:		 allow it to be used on enums.  */
        -: 7452:	      if (pfound->has_arg)
        -: 7453:		optarg = nameend + 1;
        -: 7454:	      else
        -: 7455:		{
        -: 7456:		  if (opterr)
        -: 7457:		    {
        -: 7458:		      if (argv[optind - 1][1] == '-')
        -: 7459:			/* --option */
        -: 7460:			fprintf (stderr,
        -: 7461:				 _("%s: option `--%s' doesn't allow an argument\n"),
        -: 7462:				 argv[0], pfound->name);
        -: 7463:		      else
        -: 7464:			/* +option or -option */
        -: 7465:			fprintf (stderr,
        -: 7466:				 _("%s: option `%c%s' doesn't allow an argument\n"),
        -: 7467:				 argv[0], argv[optind - 1][0], pfound->name);
        -: 7468:		    }
        -: 7469:
        -: 7470:		  nextchar += strlen (nextchar);
        -: 7471:
        -: 7472:#ifdef FAULTY_F_KL_9
        -: 7473:		  optopt = 0;
        -: 7474:#else
        -: 7475:		  optopt = pfound->val;
        -: 7476:#endif
        -: 7477:		  return '?';
        -: 7478:		}
        -: 7479:	    }
        -: 7480:	  else if (pfound->has_arg == 1)
        -: 7481:	    {
        -: 7482:	      if (optind < argc)
        -: 7483:		optarg = argv[optind++];
        -: 7484:	      else
        -: 7485:		{
        -: 7486:		  if (opterr)
        -: 7487:		    fprintf (stderr,
        -: 7488:			   _("%s: option `%s' requires an argument\n"),
        -: 7489:			   argv[0], argv[optind - 1]);
        -: 7490:		  nextchar += strlen (nextchar);
        -: 7491:		  optopt = pfound->val;
        -: 7492:		  return optstring[0] == ':' ? ':' : '?';
        -: 7493:		}
        -: 7494:	    }
        -: 7495:	  nextchar += strlen (nextchar);
        -: 7496:	  if (longind != NULL)
        -: 7497:	    *longind = option_index;
        -: 7498:	  if (pfound->flag)
        -: 7499:	    {
        -: 7500:	      *(pfound->flag) = pfound->val;
        -: 7501:	      return 0;
        -: 7502:	    }
        -: 7503:	  return pfound->val;
        -: 7504:	}
        -: 7505:
        -: 7506:      /* Can't find it as a long option.  If this is not getopt_long_only,
        -: 7507:	 or the option starts with '--' or is not a valid short
        -: 7508:	 option, then it's an error.
        -: 7509:	 Otherwise interpret it as a short option.  */
        -: 7510:      if (!long_only || argv[optind][1] == '-'
        -: 7511:	  || my_index (optstring, *nextchar) == NULL)
        -: 7512:	{
        -: 7513:	  if (opterr)
        -: 7514:	    {
        -: 7515:	      if (argv[optind][1] == '-')
        -: 7516:		/* --option */
        -: 7517:		fprintf (stderr, _("%s: unrecognized option `--%s'\n"),
        -: 7518:			 argv[0], nextchar);
        -: 7519:	      else
        -: 7520:		/* +option or -option */
        -: 7521:		fprintf (stderr, _("%s: unrecognized option `%c%s'\n"),
        -: 7522:			 argv[0], argv[optind][0], nextchar);
        -: 7523:	    }
        -: 7524:	  nextchar = (char *) "";
        -: 7525:	  optind++;
        -: 7526:	  optopt = 0;
        -: 7527:	  return '?';
        -: 7528:	}
        -: 7529:    }
        -: 7530:
        -: 7531:  /* Look at and handle the next short option-character.  */
        -: 7532:
        -: 7533:  {
        -: 7534:    char c = *nextchar++;
        -: 7535:    char *temp = my_index (optstring, c);
        -: 7536:
        -: 7537:    /* Increment `optind' when we start to process its last character.  */
        -: 7538:    if (*nextchar == '\0')
        -: 7539:      ++optind;
        -: 7540:
        -: 7541:    if (temp == NULL || c == ':')
        -: 7542:      {
        -: 7543:	if (opterr)
        -: 7544:	  {
        -: 7545:	    if (posixly_correct)
        -: 7546:	      /* 1003.2 specifies the format of this message.  */
        -: 7547:	      fprintf (stderr, _("%s: illegal option -- %c\n"),
        -: 7548:		       argv[0], c);
        -: 7549:	    else
        -: 7550:	      fprintf (stderr, _("%s: invalid option -- %c\n"),
        -: 7551:		       argv[0], c);
        -: 7552:	  }
        -: 7553:	optopt = c;
        -: 7554:	return '?';
        -: 7555:      }
        -: 7556:    /* Convenience. Treat POSIX -W foo same as long option --foo */
        -: 7557:    if (temp[0] == 'W' && temp[1] == ';')
        -: 7558:      {
        -: 7559:	char *nameend;
        -: 7560:	const struct option *p;
        -: 7561:	const struct option *pfound = NULL;
        -: 7562:	int exact = 0;
        -: 7563:	int ambig = 0;
        -: 7564:	int indfound = 0;
        -: 7565:	int option_index;
        -: 7566:
        -: 7567:	/* This is an option that requires an argument.  */
        -: 7568:	if (*nextchar != '\0')
        -: 7569:	  {
        -: 7570:	    optarg = nextchar;
        -: 7571:	    /* If we end this ARGV-element by taking the rest as an arg,
        -: 7572:	       we must advance to the next element now.  */
        -: 7573:	    optind++;
        -: 7574:	  }
        -: 7575:	else if (optind == argc)
        -: 7576:	  {
        -: 7577:	    if (opterr)
        -: 7578:	      {
        -: 7579:		/* 1003.2 specifies the format of this message.  */
        -: 7580:		fprintf (stderr, _("%s: option requires an argument -- %c\n"),
        -: 7581:			 argv[0], c);
        -: 7582:	      }
        -: 7583:	    optopt = c;
        -: 7584:	    if (optstring[0] == ':')
        -: 7585:	      c = ':';
        -: 7586:	    else
        -: 7587:	      c = '?';
        -: 7588:	    return c;
        -: 7589:	  }
        -: 7590:	else
        -: 7591:	  /* We already incremented `optind' once;
        -: 7592:	     increment it again when taking next ARGV-elt as argument.  */
        -: 7593:	  optarg = argv[optind++];
        -: 7594:
        -: 7595:	/* optarg is now the argument, see if it's in the
        -: 7596:	   table of longopts.  */
        -: 7597:
        -: 7598:	for (nextchar = nameend = optarg; *nameend && *nameend != '='; nameend++)
        -: 7599:	  /* Do nothing.  */ ;
        -: 7600:
        -: 7601:	/* Test all long options for either exact match
        -: 7602:	   or abbreviated matches.  */
        -: 7603:	for (p = longopts, option_index = 0; p->name; p++, option_index++)
        -: 7604:	  if (!strncmp (p->name, nextchar, nameend - nextchar))
        -: 7605:	    {
        -: 7606:	      if ((unsigned int) (nameend - nextchar) == strlen (p->name))
        -: 7607:		{
        -: 7608:		  /* Exact match found.  */
        -: 7609:		  pfound = p;
        -: 7610:		  indfound = option_index;
        -: 7611:		  exact = 1;
        -: 7612:		  break;
        -: 7613:		}
        -: 7614:	      else if (pfound == NULL)
        -: 7615:		{
        -: 7616:		  /* First nonexact match found.  */
        -: 7617:		  pfound = p;
        -: 7618:		  indfound = option_index;
        -: 7619:		}
        -: 7620:	      else
        -: 7621:		/* Second or later nonexact match found.  */
        -: 7622:		ambig = 1;
        -: 7623:	    }
        -: 7624:	if (ambig && !exact)
        -: 7625:	  {
        -: 7626:	    if (opterr)
        -: 7627:	      fprintf (stderr, _("%s: option `-W %s' is ambiguous\n"),
        -: 7628:		       argv[0], argv[optind]);
        -: 7629:	    nextchar += strlen (nextchar);
        -: 7630:	    optind++;
        -: 7631:	    return '?';
        -: 7632:	  }
        -: 7633:	if (pfound != NULL)
        -: 7634:	  {
        -: 7635:	    option_index = indfound;
        -: 7636:	    if (*nameend)
        -: 7637:	      {
        -: 7638:		/* Don't test has_arg with >, because some C compilers don't
        -: 7639:		   allow it to be used on enums.  */
        -: 7640:		if (pfound->has_arg)
        -: 7641:		  optarg = nameend + 1;
        -: 7642:		else
        -: 7643:		  {
        -: 7644:		    if (opterr)
        -: 7645:		      fprintf (stderr, _("\
        -: 7646:%s: option `-W %s' doesn't allow an argument\n"),
        -: 7647:			       argv[0], pfound->name);
        -: 7648:
        -: 7649:		    nextchar += strlen (nextchar);
        -: 7650:		    return '?';
        -: 7651:		  }
        -: 7652:	      }
        -: 7653:	    else if (pfound->has_arg == 1)
        -: 7654:	      {
        -: 7655:		if (optind < argc)
        -: 7656:		  optarg = argv[optind++];
        -: 7657:		else
        -: 7658:		  {
        -: 7659:		    if (opterr)
        -: 7660:		      fprintf (stderr,
        -: 7661:			       _("%s: option `%s' requires an argument\n"),
        -: 7662:			       argv[0], argv[optind - 1]);
        -: 7663:		    nextchar += strlen (nextchar);
        -: 7664:		    return optstring[0] == ':' ? ':' : '?';
        -: 7665:		  }
        -: 7666:	      }
        -: 7667:	    nextchar += strlen (nextchar);
        -: 7668:	    if (longind != NULL)
        -: 7669:	      *longind = option_index;
        -: 7670:	    if (pfound->flag)
        -: 7671:	      {
        -: 7672:		*(pfound->flag) = pfound->val;
        -: 7673:		return 0;
        -: 7674:	      }
        -: 7675:	    return pfound->val;
        -: 7676:	  }
        -: 7677:	  nextchar = NULL;
        -: 7678:	  return 'W';	/* Let the application handle it.   */
        -: 7679:      }
        -: 7680:    if (temp[1] == ':')
        -: 7681:      {
        -: 7682:	if (temp[2] == ':')
        -: 7683:	  {
        -: 7684:	    /* This is an option that accepts an argument optionally.  */
        -: 7685:	    if (*nextchar != '\0')
        -: 7686:	      {
        -: 7687:		optarg = nextchar;
        -: 7688:		optind++;
        -: 7689:	      }
        -: 7690:	    else
        -: 7691:	      optarg = NULL;
        -: 7692:	    nextchar = NULL;
        -: 7693:	  }
        -: 7694:	else
        -: 7695:	  {
        -: 7696:	    /* This is an option that requires an argument.  */
        -: 7697:	    if (*nextchar != '\0')
        -: 7698:	      {
        -: 7699:		optarg = nextchar;
        -: 7700:		/* If we end this ARGV-element by taking the rest as an arg,
        -: 7701:		   we must advance to the next element now.  */
        -: 7702:		optind++;
        -: 7703:	      }
        -: 7704:	    else if (optind == argc)
        -: 7705:	      {
        -: 7706:		if (opterr)
        -: 7707:		  {
        -: 7708:		    /* 1003.2 specifies the format of this message.  */
        -: 7709:		    fprintf (stderr,
        -: 7710:			   _("%s: option requires an argument -- %c\n"),
        -: 7711:			   argv[0], c);
        -: 7712:		  }
        -: 7713:		optopt = c;
        -: 7714:		if (optstring[0] == ':')
        -: 7715:		  c = ':';
        -: 7716:		else
        -: 7717:		  c = '?';
        -: 7718:	      }
        -: 7719:	    else
        -: 7720:	      /* We already incremented `optind' once;
        -: 7721:		 increment it again when taking next ARGV-elt as argument.  */
        -: 7722:	      optarg = argv[optind++];
        -: 7723:	    nextchar = NULL;
        -: 7724:	  }
        -: 7725:      }
        -: 7726:    return c;
        -: 7727:  }
        -: 7728:}
        -: 7729:
        -: 7730:int
        -: 7731:getopt (argc, argv, optstring)
        -: 7732:     int argc;
        -: 7733:     char *const *argv;
        -: 7734:     const char *optstring;
        -: 7735:{
        -: 7736:  return _getopt_internal (argc, argv, optstring,
        -: 7737:			   (const struct option *) 0,
        -: 7738:			   (int *) 0,
        -: 7739:			   0);
        -: 7740:}
        -: 7741:
        -: 7742:#endif	/* Not ELIDE_CODE.  */
        -: 7743:
        -: 7744:#ifdef TEST
        -: 7745:
        -: 7746:/* Compile with -DTEST to make an executable for use in testing
        -: 7747:   the above definition of `getopt'.  */
        -: 7748:
        -: 7749:int
        -: 7750:main (argc, argv)
        -: 7751:     int argc;
        -: 7752:     char **argv;
        -: 7753:{
        -: 7754:  int c;
        -: 7755:  int digit_optind = 0;
        -: 7756:
        -: 7757:  while (1)
        -: 7758:    {
        -: 7759:      int this_option_optind = optind ? optind : 1;
        -: 7760:
        -: 7761:      c = getopt (argc, argv, "abc:d:0123456789");
        -: 7762:      if (c == -1)
        -: 7763:	break;
        -: 7764:
        -: 7765:      switch (c)
        -: 7766:	{
        -: 7767:	case '0':
        -: 7768:	case '1':
        -: 7769:	case '2':
        -: 7770:	case '3':
        -: 7771:	case '4':
        -: 7772:	case '5':
        -: 7773:	case '6':
        -: 7774:	case '7':
        -: 7775:	case '8':
        -: 7776:	case '9':
        -: 7777:	  if (digit_optind != 0 && digit_optind != this_option_optind)
        -: 7778:	    printf ("digits occur in two different argv-elements.\n");
        -: 7779:	  digit_optind = this_option_optind;
        -: 7780:	  printf ("option %c\n", c);
        -: 7781:	  break;
        -: 7782:
        -: 7783:	case 'a':
        -: 7784:	  printf ("option a\n");
        -: 7785:	  break;
        -: 7786:
        -: 7787:	case 'b':
        -: 7788:	  printf ("option b\n");
        -: 7789:	  break;
        -: 7790:
        -: 7791:	case 'c':
        -: 7792:	  printf ("option c with value `%s'\n", optarg);
        -: 7793:	  break;
        -: 7794:
        -: 7795:	case '?':
        -: 7796:	  break;
        -: 7797:
        -: 7798:	default:
        -: 7799:	  printf ("?? getopt returned character code 0%o ??\n", c);
        -: 7800:	}
        -: 7801:    }
        -: 7802:
        -: 7803:  if (optind < argc)
        -: 7804:    {
        -: 7805:      printf ("non-option ARGV-elements: ");
        -: 7806:      while (optind < argc)
        -: 7807:	printf ("%s ", argv[optind++]);
        -: 7808:      printf ("\n");
        -: 7809:    }
        -: 7810:
        -: 7811:  exit (0);
        -: 7812:}
        -: 7813:
        -: 7814:#endif /* TEST */
        -: 7815:/* getopt_long and getopt_long_only entry points for GNU getopt.
        -: 7816:   Copyright (C) 1987,88,89,90,91,92,93,94,96,97,98
        -: 7817:     Free Software Foundation, Inc.
        -: 7818:   NOTE: The canonical source of this file is maintained with the GNU C Library.
        -: 7819:   Bugs can be reported to bug-glibc@gnu.org.
        -: 7820:
        -: 7821:   This program is free software; you can redistribute it and/or modify it
        -: 7822:   under the terms of the GNU General Public License as published by the
        -: 7823:   Free Software Foundation; either version 2, or (at your option) any
        -: 7824:   later version.
        -: 7825:
        -: 7826:   This program is distributed in the hope that it will be useful,
        -: 7827:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 7828:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 7829:   GNU General Public License for more details.
        -: 7830:
        -: 7831:   You should have received a copy of the GNU General Public License
        -: 7832:   along with this program; if not, write to the Free Software Foundation,
        -: 7833:   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
        -: 7834:
        -: 7835:#ifdef HAVE_CONFIG_H
        -: 7836:#include <config.h>
        -: 7837:#else
        -: 7838:#if !defined __STDC__ || !__STDC__
        -: 7839:/* This is a separate conditional since some stdc systems
        -: 7840:   reject `defined (const)'.  */
        -: 7841:#ifndef const
        -: 7842:#define const
        -: 7843:#endif
        -: 7844:#endif
        -: 7845:#endif
        -: 7846:
        -: 7847:/* Comment out all this code if we are using the GNU C Library, and are not
        -: 7848:   actually compiling the library itself.  This code is part of the GNU C
        -: 7849:   Library, but also included in many other GNU distributions.  Compiling
        -: 7850:   and linking in this code is a waste when using the GNU C library
        -: 7851:   (especially if it is a shared library).  Rather than having every GNU
        -: 7852:   program understand `configure --with-gnu-libc' and omit the object files,
        -: 7853:   it is simpler to just do this in the source for each such file.  */
        -: 7854:
        -: 7855:#define GETOPT_INTERFACE_VERSION 2
        -: 7856:#if !defined _LIBC && defined __GLIBC__ && __GLIBC__ >= 2
        -: 7857:#include <gnu-versions.h>
        -: 7858:#if _GNU_GETOPT_INTERFACE_VERSION == GETOPT_INTERFACE_VERSION
        -: 7859:#define ELIDE_CODE
        -: 7860:#endif
        -: 7861:#endif
        -: 7862:
        -: 7863:#ifndef ELIDE_CODE
        -: 7864:
        -: 7865:
        -: 7866:/* This needs to come after some library #include
        -: 7867:   to get __GNU_LIBRARY__ defined.  */
        -: 7868:#ifdef __GNU_LIBRARY__
        -: 7869:#include <stdlib.h>
        -: 7870:#endif
        -: 7871:
        -: 7872:#ifndef	NULL
        -: 7873:#define NULL 0
        -: 7874:#endif
        -: 7875:
        -: 7876:int
        -: 7877:getopt_long (argc, argv, options, long_options, opt_index)
        -: 7878:     int argc;
        -: 7879:     char *const *argv;
        -: 7880:     const char *options;
        -: 7881:     const struct option *long_options;
        -: 7882:     int *opt_index;
        -: 7883:{
        -: 7884:  return _getopt_internal (argc, argv, options, long_options, opt_index, 0);
        -: 7885:}
        -: 7886:
        -: 7887:/* Like getopt_long, but '-' as well as '--' can indicate a long option.
        -: 7888:   If an option that starts with '-' (not '--') doesn't match a long option,
        -: 7889:   but does match a short option, it is parsed as a short option
        -: 7890:   instead.  */
        -: 7891:
        -: 7892:int
        -: 7893:getopt_long_only (argc, argv, options, long_options, opt_index)
        -: 7894:     int argc;
        -: 7895:     char *const *argv;
        -: 7896:     const char *options;
        -: 7897:     const struct option *long_options;
        -: 7898:     int *opt_index;
        -: 7899:{
        -: 7900:  return _getopt_internal (argc, argv, options, long_options, opt_index, 1);
        -: 7901:}
        -: 7902:
        -: 7903:
        -: 7904:#endif	/* Not ELIDE_CODE.  */
        -: 7905:
        -: 7906:#ifdef TEST
        -: 7907:
        -: 7908:int
        -: 7909:main (argc, argv)
        -: 7910:     int argc;
        -: 7911:     char **argv;
        -: 7912:{
        -: 7913:  int c;
        -: 7914:  int digit_optind = 0;
        -: 7915:
        -: 7916:  while (1)
        -: 7917:    {
        -: 7918:      int this_option_optind = optind ? optind : 1;
        -: 7919:      int option_index = 0;
        -: 7920:      static struct option long_options[] =
        -: 7921:      {
        -: 7922:	{"add", 1, 0, 0},
        -: 7923:	{"append", 0, 0, 0},
        -: 7924:	{"delete", 1, 0, 0},
        -: 7925:	{"verbose", 0, 0, 0},
        -: 7926:	{"create", 0, 0, 0},
        -: 7927:	{"file", 1, 0, 0},
        -: 7928:	{0, 0, 0, 0}
        -: 7929:      };
        -: 7930:
        -: 7931:      c = getopt_long (argc, argv, "abc:d:0123456789",
        -: 7932:		       long_options, &option_index);
        -: 7933:      if (c == -1)
        -: 7934:	break;
        -: 7935:
        -: 7936:      switch (c)
        -: 7937:	{
        -: 7938:	case 0:
        -: 7939:	  printf ("option %s", long_options[option_index].name);
        -: 7940:	  if (optarg)
        -: 7941:	    printf (" with arg %s", optarg);
        -: 7942:	  printf ("\n");
        -: 7943:	  break;
        -: 7944:
        -: 7945:	case '0':
        -: 7946:	case '1':
        -: 7947:	case '2':
        -: 7948:	case '3':
        -: 7949:	case '4':
        -: 7950:	case '5':
        -: 7951:	case '6':
        -: 7952:	case '7':
        -: 7953:	case '8':
        -: 7954:	case '9':
        -: 7955:	  if (digit_optind != 0 && digit_optind != this_option_optind)
        -: 7956:	    printf ("digits occur in two different argv-elements.\n");
        -: 7957:	  digit_optind = this_option_optind;
        -: 7958:	  printf ("option %c\n", c);
        -: 7959:	  break;
        -: 7960:
        -: 7961:	case 'a':
        -: 7962:	  printf ("option a\n");
        -: 7963:	  break;
        -: 7964:
        -: 7965:	case 'b':
        -: 7966:	  printf ("option b\n");
        -: 7967:	  break;
        -: 7968:
        -: 7969:	case 'c':
        -: 7970:	  printf ("option c with value `%s'\n", optarg);
        -: 7971:	  break;
        -: 7972:
        -: 7973:	case 'd':
        -: 7974:	  printf ("option d with value `%s'\n", optarg);
        -: 7975:	  break;
        -: 7976:
        -: 7977:	case '?':
        -: 7978:	  break;
        -: 7979:
        -: 7980:	default:
        -: 7981:	  printf ("?? getopt returned character code 0%o ??\n", c);
        -: 7982:	}
        -: 7983:    }
        -: 7984:
        -: 7985:  if (optind < argc)
        -: 7986:    {
        -: 7987:      printf ("non-option ARGV-elements: ");
        -: 7988:      while (optind < argc)
        -: 7989:	printf ("%s ", argv[optind++]);
        -: 7990:      printf ("\n");
        -: 7991:    }
        -: 7992:
        -: 7993:  exit (0);
        -: 7994:}
        -: 7995:
        -: 7996:#endif /* TEST */
