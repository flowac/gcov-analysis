        -:    0:Source:gzip.c
        -:    0:Graph:gzip.gcno
        -:    0:Data:gzip.gcda
        -:    0:Runs:214
        -:    1:#include "FaultSeeds.h"
        -:    2:#include "crypt.h"
        -:    3:#include "getopt.h"
        -:    4:#include "gzip.h"
        -:    5:#include "lzw.h"
        -:    6:#include "tailor.h"
        -:    7:#include "revision.h"
        -:    8:
        -:    9:#include <stdio.h>
        -:   10:#include <ctype.h>
        -:   11:#include <sys/types.h>
        -:   12:#include <signal.h>
        -:   13:#include <sys/stat.h>
        -:   14:#include <errno.h>
        -:   15:
        -:   16:/* bits.c -- output variable-length bit strings
        -:   17: * Copyright (C) 1992-1993 Jean-loup Gailly
        -:   18: * This is free software; you can redistribute it and/or modify it under the
        -:   19: * terms of the GNU General Public License, see the file COPYING.
        -:   20: */
        -:   21:
        -:   22:
        -:   23:/*
        -:   24: *  PURPOSE
        -:   25: *
        -:   26: *      Output variable-length bit strings. Compression can be done
        -:   27: *      to a file or to memory. (The latter is not supported in this version.)
        -:   28: *
        -:   29: *  DISCUSSION
        -:   30: *
        -:   31: *      The PKZIP "deflate" file format interprets compressed file data
        -:   32: *      as a sequence of bits.  Multi-bit strings in the file may cross
        -:   33: *      byte boundaries without restriction.
        -:   34: *
        -:   35: *      The first bit of each byte is the low-order bit.
        -:   36: *
        -:   37: *      The routines in this file allow a variable-length bit value to
        -:   38: *      be output right-to-left (useful for literal values). For
        -:   39: *      left-to-right output (useful for code strings from the tree routines),
        -:   40: *      the bits must have been reversed first with bi_reverse().
        -:   41: *
        -:   42: *      For in-memory compression, the compressed bit stream goes directly
        -:   43: *      into the requested output buffer. The input data is read in blocks
        -:   44: *      by the mem_read() function. The buffer is limited to 64K on 16 bit
        -:   45: *      machines.
        -:   46: *
        -:   47: *  INTERFACE
        -:   48: *
        -:   49: *      void bi_init (FILE *zipfile)
        -:   50: *          Initialize the bit string routines.
        -:   51: *
        -:   52: *      void send_bits (int value, int length)
        -:   53: *          Write out a bit string, taking the source bits right to
        -:   54: *          left.
        -:   55: *
        -:   56: *      int bi_reverse (int value, int length)
        -:   57: *          Reverse the bits of a bit string, taking the source bits left to
        -:   58: *          right and emitting them right to left.
        -:   59: *
        -:   60: *      void bi_windup (void)
        -:   61: *          Write out any remaining bits in an incomplete byte.
        -:   62: *
        -:   63: *      void copy_block(char *buf, unsigned len, int header)
        -:   64: *          Copy a stored block to the zip file, storing first the length and
        -:   65: *          its one's complement if requested.
        -:   66: *
        -:   67: */
        -:   68:
        -:   69:#ifdef DEBUG
        -:   70:#  include <stdio.h>
        -:   71:#endif
        -:   72:
        -:   73:#ifdef RCSID
        -:   74:static char rcsid[] = "$Id: bits.c,v 0.9 1993/06/11 10:16:58 jloup Exp $";
        -:   75:#endif
        -:   76:
        -:   77:/* ===========================================================================
        -:   78: * Local data used by the "bit string" routines.
        -:   79: */
        -:   80:
        -:   81:local file_t zfile; /* output gzip file */
        -:   82:
        -:   83:local unsigned short bi_buf;
        -:   84:/* Output buffer. bits are inserted starting at the bottom (least significant
        -:   85: * bits).
        -:   86: */
        -:   87:
        -:   88:#define Buf_size (8 * 2*sizeof(char))
        -:   89:/* Number of bits used within bi_buf. (bi_buf might be implemented on
        -:   90: * more than 16 bits on some systems.)
        -:   91: */
        -:   92:
        -:   93:local int bi_valid;
        -:   94:/* Number of valid bits in bi_buf.  All bits above the last valid bit
        -:   95: * are always zero.
        -:   96: */
        -:   97:
        -:   98:int (*read_buf) OF((char *buf, unsigned size));
        -:   99:/* Current input function. Set to mem_read for in-memory compression */
        -:  100:
        -:  101:#ifdef DEBUG
        -:  102:  ulg bits_sent;   /* bit length of the compressed data */
        -:  103:#endif
        -:  104:
        -:  105:/* ===========================================================================
        -:  106: * Initialize the bit string routines.
        -:  107: */
function bi_init called 175 returned 100% blocks executed 100%
      175:  108:void bi_init (zipfile)
        -:  109:    file_t zipfile; /* output zip file, NO_FILE for in-memory compression */
        -:  110:{
      175:  111:    zfile  = zipfile;
      175:  112:    bi_buf = 0;
      175:  113:    bi_valid = 0;
        -:  114:#ifdef DEBUG
        -:  115:    bits_sent = 0L;
        -:  116:#endif
        -:  117:
        -:  118:    /* Set the defaults for file compression. They are set by memcompress
        -:  119:     * for in-memory compression.
        -:  120:     */
      175:  121:    if (zfile != NO_FILE) {
branch  0 taken 175 (fallthrough)
branch  1 taken 0
      175:  122:	read_buf  = file_read;
        -:  123:    }
      175:  124:}
        -:  125:
        -:  126:/* ===========================================================================
        -:  127: * Send a value on a given number of bits.
        -:  128: * IN assertion: length <= 16 and value fits in length bits.
        -:  129: */
function send_bits called 3998701 returned 100% blocks executed 90%
  3998701:  130:void send_bits(value, length)
        -:  131:    int value;  /* value to send */
        -:  132:    int length; /* number of bits */
        -:  133:{
        -:  134:#ifdef DEBUG
        -:  135:    Tracev((stderr," l %2d v %4x ", length, value));
        -:  136:    Assert(length > 0 && length <= 15, "invalid length");
        -:  137:    bits_sent += (ulg)length;
        -:  138:#endif
        -:  139:    /* If not enough room in bi_buf, use (valid) bits from bi_buf and
        -:  140:     * (16 - bi_valid) bits from value, leaving (width - (16-bi_valid))
        -:  141:     * unused bits in value.
        -:  142:     */
  3998701:  143:    if (bi_valid > (int)Buf_size - length) {
branch  0 taken 1198598 (fallthrough)
branch  1 taken 2800103
  1198598:  144:        bi_buf |= (value << bi_valid);
 1198598*:  145:        put_short(bi_buf);
branch  0 taken 1198581 (fallthrough)
branch  1 taken 17
branch  2 taken 0 (fallthrough)
branch  3 taken 17
call    4 never executed
branch  5 taken 17 (fallthrough)
branch  6 taken 0
call    7 returned 17
  1198598:  146:        bi_buf = (ush)value >> (Buf_size - bi_valid);
  1198598:  147:        bi_valid += length - Buf_size;
        -:  148:    } else {
  2800103:  149:        bi_buf |= value << bi_valid;
  2800103:  150:        bi_valid += length;
        -:  151:    }
  3998701:  152:}
        -:  153:
        -:  154:/* ===========================================================================
        -:  155: * Reverse the first len bits of a code, using straightforward code (a faster
        -:  156: * method would use a table)
        -:  157: * IN assertion: 1 <= len <= 15
        -:  158: */
function bi_reverse called 85011 returned 100% blocks executed 100%
    85011:  159:unsigned bi_reverse(code, len)
        -:  160:    unsigned code; /* the value to invert */
        -:  161:    int len;       /* its bit length */
        -:  162:{
    85011:  163:    register unsigned res = 0;
        -:  164:    do {
   672964:  165:        res |= code & 1;
   672964:  166:        code >>= 1, res <<= 1;
   672964:  167:    } while (--len > 0);
branch  0 taken 587953
branch  1 taken 85011 (fallthrough)
    85011:  168:    return res >> 1;
        -:  169:}
        -:  170:
        -:  171:/* ===========================================================================
        -:  172: * Write out any remaining bits in an incomplete byte.
        -:  173: */
function bi_windup called 176 returned 100% blocks executed 55%
      176:  174:void bi_windup()
        -:  175:{
      176:  176:    if (bi_valid > 8) {
branch  0 taken 105 (fallthrough)
branch  1 taken 71
     105*:  177:        put_short(bi_buf);
branch  0 taken 105 (fallthrough)
branch  1 taken 0
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
       71:  178:    } else if (bi_valid > 0) {
branch  0 taken 70 (fallthrough)
branch  1 taken 1
      70*:  179:        put_byte(bi_buf);
branch  0 taken 0 (fallthrough)
branch  1 taken 70
call    2 never executed
        -:  180:    }
      176:  181:    bi_buf = 0;
      176:  182:    bi_valid = 0;
        -:  183:#ifdef DEBUG
        -:  184:    bits_sent = (bits_sent+7) & ~7;
        -:  185:#endif
      176:  186:}
        -:  187:
        -:  188:/* ===========================================================================
        -:  189: * Copy a stored block to the zip file, storing first the length and its
        -:  190: * one's complement if requested.
        -:  191: */
function copy_block called 1 returned 100% blocks executed 53%
        1:  192:void copy_block(buf, len, header)
        -:  193:    char     *buf;    /* the input data */
        -:  194:    unsigned len;     /* its length */
        -:  195:    int      header;  /* true if block header must be written */
        -:  196:{
        1:  197:    bi_windup();              /* align on byte boundary */
call    0 returned 1
        -:  198:
        1:  199:    if (header) {
branch  0 taken 1 (fallthrough)
branch  1 taken 0
       1*:  200:        put_short((ush)len);   
branch  0 taken 1 (fallthrough)
branch  1 taken 0
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
       1*:  201:        put_short((ush)~len);
branch  0 taken 1 (fallthrough)
branch  1 taken 0
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
        -:  202:#ifdef DEBUG
        -:  203:        bits_sent += 2*16;
        -:  204:#endif
        -:  205:    }
        -:  206:#ifdef DEBUG
        -:  207:    bits_sent += (ulg)len<<3;
        -:  208:#endif
    12047:  209:    while (len--) {
branch  0 taken 12046
branch  1 taken 1 (fallthrough)
        -:  210:#ifdef CRYPT
        -:  211:        int t;
        -:  212:	if (key) zencode(*buf, t);
        -:  213:#endif
   12046*:  214:	put_byte(*buf++);
branch  0 taken 0 (fallthrough)
branch  1 taken 12046
call    2 never executed
        -:  215:    }
        1:  216:}
        -:  217:/* crypt.c (dummy version) -- do not perform encryption
        -:  218: * Hardly worth copyrighting :-)
        -:  219: */
        -:  220:#ifdef RCSID
        -:  221:static char rcsid[] = "$Id: crypt.c,v 0.6 1993/03/22 09:48:47 jloup Exp $";
        -:  222:#endif
        -:  223:/* deflate.c -- compress data using the deflation algorithm
        -:  224: * Copyright (C) 1992-1993 Jean-loup Gailly
        -:  225: * This is free software; you can redistribute it and/or modify it under the
        -:  226: * terms of the GNU General Public License, see the file COPYING.
        -:  227: */
        -:  228:
        -:  229:/*
        -:  230: *  PURPOSE
        -:  231: *
        -:  232: *      Identify new text as repetitions of old text within a fixed-
        -:  233: *      length sliding window trailing behind the new text.
        -:  234: *
        -:  235: *  DISCUSSION
        -:  236: *
        -:  237: *      The "deflation" process depends on being able to identify portions
        -:  238: *      of the input text which are identical to earlier input (within a
        -:  239: *      sliding window trailing behind the input currently being processed).
        -:  240: *
        -:  241: *      The most straightforward technique turns out to be the fastest for
        -:  242: *      most input files: try all possible matches and select the longest.
        -:  243: *      The key feature of this algorithm is that insertions into the string
        -:  244: *      dictionary are very simple and thus fast, and deletions are avoided
        -:  245: *      completely. Insertions are performed at each input character, whereas
        -:  246: *      string matches are performed only when the previous match ends. So it
        -:  247: *      is preferable to spend more time in matches to allow very fast string
        -:  248: *      insertions and avoid deletions. The matching algorithm for small
        -:  249: *      strings is inspired from that of Rabin & Karp. A brute force approach
        -:  250: *      is used to find longer strings when a small match has been found.
        -:  251: *      A similar algorithm is used in comic (by Jan-Mark Wams) and freeze
        -:  252: *      (by Leonid Broukhis).
        -:  253: *         A previous version of this file used a more sophisticated algorithm
        -:  254: *      (by Fiala and Greene) which is guaranteed to run in linear amortized
        -:  255: *      time, but has a larger average cost, uses more memory and is patented.
        -:  256: *      However the F&G algorithm may be faster for some highly redundant
        -:  257: *      files if the parameter max_chain_length (described below) is too large.
        -:  258: *
        -:  259: *  ACKNOWLEDGEMENTS
        -:  260: *
        -:  261: *      The idea of lazy evaluation of matches is due to Jan-Mark Wams, and
        -:  262: *      I found it in 'freeze' written by Leonid Broukhis.
        -:  263: *      Thanks to many info-zippers for bug reports and testing.
        -:  264: *
        -:  265: *  REFERENCES
        -:  266: *
        -:  267: *      APPNOTE.TXT documentation file in PKZIP 1.93a distribution.
        -:  268: *
        -:  269: *      A description of the Rabin and Karp algorithm is given in the book
        -:  270: *         "Algorithms" by R. Sedgewick, Addison-Wesley, p252.
        -:  271: *
        -:  272: *      Fiala,E.R., and Greene,D.H.
        -:  273: *         Data Compression with Finite Windows, Comm.ACM, 32,4 (1989) 490-595
        -:  274: *
        -:  275: *  INTERFACE
        -:  276: *
        -:  277: *      void lm_init (int pack_level, ush *flags)
        -:  278: *          Initialize the "longest match" routines for a new file
        -:  279: *
        -:  280: *      ulg deflate (void)
        -:  281: *          Processes a new input file and return its compressed length. Sets
        -:  282: *          the compressed length, crc, deflate flags and internal file
        -:  283: *          attributes.
        -:  284: */
        -:  285:
        -:  286:#ifdef RCSID
        -:  287:static char rcsid[] = "$Id: deflate.c,v 0.15 1993/06/24 10:53:53 jloup Exp $";
        -:  288:#endif
        -:  289:
        -:  290:/* ===========================================================================
        -:  291: * Configuration parameters
        -:  292: */
        -:  293:
        -:  294:/* Compile with MEDIUM_MEM to reduce the memory requirements or
        -:  295: * with SMALL_MEM to use as little memory as possible. Use BIG_MEM if the
        -:  296: * entire input file can be held in memory (not possible on 16 bit systems).
        -:  297: * Warning: defining these symbols affects HASH_BITS (see below) and thus
        -:  298: * affects the compression ratio. The compressed output
        -:  299: * is still correct, and might even be smaller in some cases.
        -:  300: */
        -:  301:
        -:  302:#ifdef SMALL_MEM
        -:  303:#   define HASH_BITS  13  /* Number of bits used to hash strings */
        -:  304:#endif
        -:  305:#ifdef MEDIUM_MEM
        -:  306:#   define HASH_BITS  14
        -:  307:#endif
        -:  308:#ifndef HASH_BITS
        -:  309:#   define HASH_BITS  15
        -:  310:   /* For portability to 16 bit machines, do not use values above 15. */
        -:  311:#endif
        -:  312:
        -:  313:/* To save space (see unlzw.c), we overlay prev+head with tab_prefix and
        -:  314: * window with tab_suffix. Check that we can do this:
        -:  315: */
        -:  316:#if (WSIZE<<1) > (1<<BITS)
        -:  317:   error: cannot overlay window with tab_suffix and prev with tab_prefix0
        -:  318:#endif
        -:  319:#if HASH_BITS > BITS-1
        -:  320:   error: cannot overlay head with tab_prefix1
        -:  321:#endif
        -:  322:
        -:  323:#define HASH_SIZE (unsigned)(1<<HASH_BITS)
        -:  324:#define HASH_MASK (HASH_SIZE-1)
        -:  325:#define WMASK     (WSIZE-1)
        -:  326:/* HASH_SIZE and WSIZE must be powers of two */
        -:  327:
        -:  328:#define NIL 0
        -:  329:/* Tail of hash chains */
        -:  330:
        -:  331:#define FAST 4
        -:  332:#define SLOW 2
        -:  333:/* speed options for the general purpose bit flag */
        -:  334:
        -:  335:#ifndef TOO_FAR
        -:  336:#  define TOO_FAR 4096
        -:  337:#endif
        -:  338:/* Matches of length 3 are discarded if their distance exceeds TOO_FAR */
        -:  339:
        -:  340:/* ===========================================================================
        -:  341: * Local data used by the "longest match" routines.
        -:  342: */
        -:  343:
        -:  344:typedef ush Pos;
        -:  345:typedef unsigned IPos;
        -:  346:/* A Pos is an index in the character window. We use short instead of int to
        -:  347: * save space in the various tables. IPos is used only for parameter passing.
        -:  348: */
        -:  349:
        -:  350:/* DECLARE(uch, window, 2L*WSIZE); */
        -:  351:/* Sliding window. Input bytes are read into the second half of the window,
        -:  352: * and move to the first half later to keep a dictionary of at least WSIZE
        -:  353: * bytes. With this organization, matches are limited to a distance of
        -:  354: * WSIZE-MAX_MATCH bytes, but this ensures that IO is always
        -:  355: * performed with a length multiple of the block size. Also, it limits
        -:  356: * the window size to 64K, which is quite useful on MSDOS.
        -:  357: * To do: limit the window size to WSIZE+BSZ if SMALL_MEM (the code would
        -:  358: * be less efficient).
        -:  359: */
        -:  360:
        -:  361:/* DECLARE(Pos, prev, WSIZE); */
        -:  362:/* Link to older string with same hash index. To limit the size of this
        -:  363: * array to 64K, this link is maintained only for the last 32K strings.
        -:  364: * An index in this array is thus a window index modulo 32K.
        -:  365: */
        -:  366:
        -:  367:/* DECLARE(Pos, head, 1<<HASH_BITS); */
        -:  368:/* Heads of the hash chains or NIL. */
        -:  369:
        -:  370:ulg window_size = (ulg)2*WSIZE;
        -:  371:/* window size, 2*WSIZE except for MMAP or BIG_MEM, where it is the
        -:  372: * input file length plus MIN_LOOKAHEAD.
        -:  373: */
        -:  374:
        -:  375:long block_start;
        -:  376:/* window position at the beginning of the current output block. Gets
        -:  377: * negative when the window is moved backwards.
        -:  378: */
        -:  379:
        -:  380:local unsigned ins_h;  /* hash index of string to be inserted */
        -:  381:
        -:  382:#define H_SHIFT  ((HASH_BITS+MIN_MATCH-1)/MIN_MATCH)
        -:  383:/* Number of bits by which ins_h and del_h must be shifted at each
        -:  384: * input step. It must be such that after MIN_MATCH steps, the oldest
        -:  385: * byte no longer takes part in the hash key, that is:
        -:  386: *   H_SHIFT * MIN_MATCH >= HASH_BITS
        -:  387: */
        -:  388:
        -:  389:unsigned int near prev_length;
        -:  390:/* Length of the best match at previous step. Matches not greater than this
        -:  391: * are discarded. This is used in the lazy match evaluation.
        -:  392: */
        -:  393:
        -:  394:      unsigned near strstart;      /* start of string to insert */
        -:  395:      unsigned near match_start;   /* start of matching string */
        -:  396:local int           eofile;        /* flag set at end of input file */
        -:  397:local unsigned      lookahead;     /* number of valid bytes ahead in window */
        -:  398:
        -:  399:unsigned near max_chain_length;
        -:  400:/* To speed up deflation, hash chains are never searched beyond this length.
        -:  401: * A higher limit improves compression ratio but degrades the speed.
        -:  402: */
        -:  403:
        -:  404:local unsigned int max_lazy_match;
        -:  405:/* Attempt to find a better match only when the current match is strictly
        -:  406: * smaller than this value. This mechanism is used only for compression
        -:  407: * levels >= 4.
        -:  408: */
        -:  409:#define max_insert_length  max_lazy_match
        -:  410:/* Insert new strings in the hash table only if the match length
        -:  411: * is not greater than this length. This saves time but degrades compression.
        -:  412: * max_insert_length is used only for compression levels <= 3.
        -:  413: */
        -:  414:
        -:  415:local int compr_level;
        -:  416:/* compression level (1..9) */
        -:  417:
        -:  418:unsigned near good_match;
        -:  419:/* Use a faster search when the previous match is longer than this */
        -:  420:
        -:  421:
        -:  422:/* Values for max_lazy_match, good_match and max_chain_length, depending on
        -:  423: * the desired pack level (0..9). The values given below have been tuned to
        -:  424: * exclude worst case performance for pathological files. Better values may be
        -:  425: * found for specific files.
        -:  426: */
        -:  427:
        -:  428:typedef struct config {
        -:  429:   ush good_length; /* reduce lazy search above this match length */
        -:  430:   ush max_lazy;    /* do not perform lazy search above this match length */
        -:  431:   ush nice_length; /* quit search above this match length */
        -:  432:   ush max_chain;
        -:  433:} config;
        -:  434:
        -:  435:#ifdef  FULL_SEARCH
        -:  436:# define nice_match MAX_MATCH
        -:  437:#else
        -:  438:  int near nice_match; /* Stop searching when current match exceeds this */
        -:  439:#endif
        -:  440:
        -:  441:local config configuration_table[10] = {
        -:  442:/*      good lazy nice chain */
        -:  443:/* 0 */ {0,    0,  0,    0},  /* store only */
        -:  444:/* 1 */ {4,    4,  8,    4},  /* maximum speed, no lazy matches */
        -:  445:/* 2 */ {4,    5, 16,    8},
        -:  446:/* 3 */ {4,    6, 32,   32},
        -:  447:
        -:  448:/* 4 */ {4,    4, 16,   16},  /* lazy matches */
        -:  449:/* 5 */ {8,   16, 32,   32},
        -:  450:/* 6 */ {8,   16, 128, 128},
        -:  451:/* 7 */ {8,   32, 128, 256},
        -:  452:/* 8 */ {32, 128, 258, 1024},
        -:  453:/* 9 */ {32, 258, 258, 4096}}; /* maximum compression */
        -:  454:
        -:  455:/* Note: the deflate() code requires max_lazy >= MIN_MATCH and max_chain >= 4
        -:  456: * For deflate_fast() (levels <= 3) good is ignored and lazy has a different
        -:  457: * meaning.
        -:  458: */
        -:  459:
        -:  460:#define EQUAL 0
        -:  461:/* result of memcmp for equal strings */
        -:  462:
        -:  463:/* ===========================================================================
        -:  464: *  Prototypes for local functions.
        -:  465: */
        -:  466:local void fill_window   OF((void));
        -:  467:local ulg deflate_fast   OF((void));
        -:  468:
        -:  469:      int  longest_match OF((IPos cur_match));
        -:  470:#ifdef ASMV
        -:  471:      void match_init OF((void)); /* asm code initialization */
        -:  472:#endif
        -:  473:
        -:  474:#ifdef DEBUG
        -:  475:local  void check_match OF((IPos start, IPos match, int length));
        -:  476:#endif
        -:  477:
        -:  478:/* ===========================================================================
        -:  479: * Update a hash value with the given input byte
        -:  480: * IN  assertion: all calls to to UPDATE_HASH are made with consecutive
        -:  481: *    input characters, so that a running hash key can be computed from the
        -:  482: *    previous key instead of complete recalculation each time.
        -:  483: */
        -:  484:#define UPDATE_HASH(h,c) (h = (((h)<<H_SHIFT) ^ (c)) & HASH_MASK)
        -:  485:
        -:  486:/* ===========================================================================
        -:  487: * Insert string s in the dictionary and set match_head to the previous head
        -:  488: * of the hash chain (the most recent string with same hash key). Return
        -:  489: * the previous length of the hash chain.
        -:  490: * IN  assertion: all calls to to INSERT_STRING are made with consecutive
        -:  491: *    input characters and the first MIN_MATCH bytes of s are valid
        -:  492: *    (except for the last MIN_MATCH-1 bytes of the input file).
        -:  493: */
        -:  494:#define INSERT_STRING(s, match_head) \
        -:  495:   (UPDATE_HASH(ins_h, window[(s) + MIN_MATCH-1]), \
        -:  496:    prev[(s) & WMASK] = match_head = head[ins_h], \
        -:  497:    head[ins_h] = (s))
        -:  498:
        -:  499:/* ===========================================================================
        -:  500: * Initialize the "longest match" routines for a new file
        -:  501: */
function lm_init called 175 returned 100% blocks executed 84%
      175:  502:void lm_init (pack_level, flags)
        -:  503:    int pack_level; /* 0: store, 1: best speed, 9: best compression */
        -:  504:    ush *flags;     /* general purpose bit flag */
        -:  505:{
        -:  506:    register unsigned j;
        -:  507:
     175*:  508:    if (pack_level < 1 || pack_level > 9) error("bad pack level");
branch  0 taken 175 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 175
call    4 never executed
      175:  509:    compr_level = pack_level;
        -:  510:
        -:  511:    /* Initialize the hash table. */
        -:  512:#if defined(MAXSEG_64K) && HASH_BITS == 15
        -:  513:    for (j = 0;  j < HASH_SIZE; j++) head[j] = NIL;
        -:  514:#else
      175:  515:    memzero((char*)head, HASH_SIZE*sizeof(*head));
        -:  516:#endif
        -:  517:    /* prev will be initialized on the fly */
        -:  518:
        -:  519:    /* Set the default configuration parameters:
        -:  520:     */
      175:  521:    max_lazy_match   = configuration_table[pack_level].max_lazy;
      175:  522:    good_match       = configuration_table[pack_level].good_length;
        -:  523:#ifndef FULL_SEARCH
      175:  524:    nice_match       = configuration_table[pack_level].nice_length;
        -:  525:#endif
      175:  526:    max_chain_length = configuration_table[pack_level].max_chain;
      175:  527:    if (pack_level == 1) {
branch  0 taken 17 (fallthrough)
branch  1 taken 158
       17:  528:       *flags |= FAST;
      158:  529:    } else if (pack_level == 9) {
branch  0 taken 17 (fallthrough)
branch  1 taken 141
       17:  530:       *flags |= SLOW;
        -:  531:    }
        -:  532:    /* ??? reduce max_chain_length for binary files */
        -:  533:
      175:  534:    strstart = 0;
      175:  535:    block_start = 0L;
        -:  536:#ifdef ASMV
        -:  537:    match_init(); /* initialize the asm code */
        -:  538:#endif
        -:  539:
      175:  540:    lookahead = read_buf((char*)window,
call    0 returned 175
        -:  541:			 sizeof(int) <= 2 ? (unsigned)WSIZE : 2*WSIZE);
        -:  542:
      175:  543:    if (lookahead == 0 || lookahead == (unsigned)EOF) {
branch  0 taken 174 (fallthrough)
branch  1 taken 1
branch  2 taken 1 (fallthrough)
branch  3 taken 173
        2:  544:       eofile = 1, lookahead = 0;
        2:  545:       return;
        -:  546:    }
      173:  547:    eofile = 0;
        -:  548:    /* Make sure that we always have enough lookahead. This is important
        -:  549:     * if input comes from a device such as a tty.
        -:  550:     */
     173*:  551:    while (lookahead < MIN_LOOKAHEAD && !eofile) fill_window();
call    0 never executed
branch  1 taken 0 (fallthrough)
branch  2 taken 173
branch  3 never executed
branch  4 never executed
        -:  552:
      173:  553:    ins_h = 0;
      519:  554:    for (j=0; j<MIN_MATCH-1; j++) UPDATE_HASH(ins_h, window[j]);
branch  0 taken 346
branch  1 taken 173 (fallthrough)
        -:  555:    /* If lookahead < MIN_MATCH, ins_h is garbage, but this is
        -:  556:     * not important since only literal bytes will be emitted.
        -:  557:     */
        -:  558:}
        -:  559:
        -:  560:/* ===========================================================================
        -:  561: * Set match_start to the longest match starting at the given string and
        -:  562: * return its length. Matches shorter or equal to prev_length are discarded,
        -:  563: * in which case the result is equal to prev_length and match_start is
        -:  564: * garbage.
        -:  565: * IN assertions: cur_match is the head of the hash chain for the current
        -:  566: *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
        -:  567: */
        -:  568:#ifndef ASMV
        -:  569:/* For MSDOS, OS/2 and 386 Unix, an optimized version is in match.asm or
        -:  570: * match.s. The code is functionally equivalent, so you can use the C version
        -:  571: * if desired.
        -:  572: */
function longest_match called 1882478 returned 100% blocks executed 100%
  1882478:  573:int longest_match(cur_match)
        -:  574:    IPos cur_match;                             /* current match */
        -:  575:{
  1882478:  576:    unsigned chain_length = max_chain_length;   /* max hash chain length */
  1882478:  577:    register uch *scan = window + strstart;     /* current string */
        -:  578:    register uch *match;                        /* matched string */
        -:  579:    register int len;                           /* length of current match */
  1882478:  580:    int best_len = prev_length;                 /* best match length so far */
  1882478:  581:    IPos limit = strstart > (IPos)MAX_DIST ? strstart - (IPos)MAX_DIST : NIL;
        -:  582:    /* Stop when cur_match becomes <= limit. To simplify the code,
        -:  583:     * we prevent matches with the string of window index 0.
        -:  584:     */
        -:  585:
        -:  586:/* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
        -:  587: * It is easy to get rid of this optimization if necessary.
        -:  588: */
        -:  589:#if HASH_BITS < 8 || MAX_MATCH != 258
        -:  590:   error: Code too clever
        -:  591:#endif
        -:  592:
        -:  593:#ifdef UNALIGNED_OK
        -:  594:    /* Compare two bytes at a time. Note: this is not always beneficial.
        -:  595:     * Try with and without -DUNALIGNED_OK to check.
        -:  596:     */
        -:  597:    register uch *strend = window + strstart + MAX_MATCH - 1;
        -:  598:    register ush scan_start = *(ush*)scan;
        -:  599:    register ush scan_end   = *(ush*)(scan+best_len-1);
        -:  600:#else
  1882478:  601:    register uch *strend = window + strstart + MAX_MATCH;
  1882478:  602:    register uch scan_end1  = scan[best_len-1];
  1882478:  603:    register uch scan_end   = scan[best_len];
        -:  604:#endif
        -:  605:
        -:  606:    /* Do not waste too much time if we already have a good match: */
  1882478:  607:    if (prev_length >= good_match) {
branch  0 taken 114250 (fallthrough)
branch  1 taken 1768228
   114250:  608:        chain_length >>= 2;
        -:  609:    }
        -:  610:    Assert(strstart <= window_size-MIN_LOOKAHEAD, "insufficient lookahead");
        -:  611:
        -:  612:    do {
        -:  613:        Assert(cur_match < strstart, "no future");
 39870405:  614:        match = window + cur_match;
        -:  615:
        -:  616:        /* Skip to next match if the match length cannot increase
        -:  617:         * or if the match length is less than 2:
        -:  618:         */
        -:  619:#if (defined(UNALIGNED_OK) && MAX_MATCH == 258)
        -:  620:        /* This code assumes sizeof(unsigned short) == 2. Do not use
        -:  621:         * UNALIGNED_OK if your compiler uses a different size.
        -:  622:         */
        -:  623:        if (*(ush*)(match+best_len-1) != scan_end ||
        -:  624:            *(ush*)match != scan_start) continue;
        -:  625:
        -:  626:        /* It is not necessary to compare scan[2] and match[2] since they are
        -:  627:         * always equal when the other bytes match, given that the hash keys
        -:  628:         * are equal and that HASH_BITS >= 8. Compare 2 bytes at a time at
        -:  629:         * strstart+3, +5, ... up to strstart+257. We check for insufficient
        -:  630:         * lookahead only every 4th comparison; the 128th check will be made
        -:  631:         * at strstart+257. If MAX_MATCH-2 is not a multiple of 8, it is
        -:  632:         * necessary to put more guard bytes at the end of the window, or
        -:  633:         * to check more often for insufficient lookahead.
        -:  634:         */
        -:  635:        scan++, match++;
        -:  636:        do {
        -:  637:        } while (*(ush*)(scan+=2) == *(ush*)(match+=2) &&
        -:  638:                 *(ush*)(scan+=2) == *(ush*)(match+=2) &&
        -:  639:                 *(ush*)(scan+=2) == *(ush*)(match+=2) &&
        -:  640:                 *(ush*)(scan+=2) == *(ush*)(match+=2) &&
        -:  641:                 scan < strend);
        -:  642:        /* The funny "do {}" generates better code on most compilers */
        -:  643:
        -:  644:        /* Here, scan <= window+strstart+257 */
        -:  645:        Assert(scan <= window+(unsigned)(window_size-1), "wild scan");
        -:  646:        if (*scan == *match) scan++;
        -:  647:
        -:  648:        len = (MAX_MATCH - 1) - (int)(strend-scan);
        -:  649:        scan = strend - (MAX_MATCH-1);
        -:  650:
        -:  651:#else /* UNALIGNED_OK */
        -:  652:
 39870405:  653:        if (match[best_len]   != scan_end  ||
branch  0 taken 5616771 (fallthrough)
branch  1 taken 34253634
  5616771:  654:            match[best_len-1] != scan_end1 ||
branch  0 taken 2966671 (fallthrough)
branch  1 taken 2650100
  2966671:  655:            *match            != *scan     ||
branch  0 taken 1985637 (fallthrough)
branch  1 taken 981034
 39870405:  656:            *++match          != scan[1])      continue;
branch  0 taken 6279 (fallthrough)
branch  1 taken 1979358
        -:  657:
        -:  658:        /* The check at best_len-1 can be removed because it will be made
        -:  659:         * again later. (This heuristic is not always a win.)
        -:  660:         * It is not necessary to compare scan[2] and match[2] since they
        -:  661:         * are always equal when the other bytes match, given that
        -:  662:         * the hash keys are equal and that HASH_BITS >= 8.
        -:  663:         */
  1979358:  664:        scan += 2, match++;
        -:  665:
        -:  666:        /* We check for insufficient lookahead only every 8th comparison;
        -:  667:         * the 256th check will be made at strstart+258.
        -:  668:         */
        -:  669:        do {
 14279847:  670:        } while (*++scan == *++match && *++scan == *++match &&
branch  0 taken 13956569 (fallthrough)
branch  1 taken 323278
 13956569:  671:                 *++scan == *++match && *++scan == *++match &&
branch  0 taken 13743506 (fallthrough)
branch  1 taken 213063
branch  2 taken 13570244 (fallthrough)
branch  3 taken 173262
 13570244:  672:                 *++scan == *++match && *++scan == *++match &&
branch  0 taken 13448119 (fallthrough)
branch  1 taken 122125
branch  2 taken 13356178 (fallthrough)
branch  3 taken 91941
 15335536:  673:                 *++scan == *++match && *++scan == *++match &&
branch  0 taken 14279847 (fallthrough)
branch  1 taken 539057
branch  2 taken 13294763 (fallthrough)
branch  3 taken 61415
branch  4 taken 13246814 (fallthrough)
branch  5 taken 47949
branch  6 taken 12839546
branch  7 taken 407268 (fallthrough)
        -:  674:                 scan < strend);
        -:  675:
  1979358:  676:        len = MAX_MATCH - (int)(strend - scan);
  1979358:  677:        scan = strend - MAX_MATCH;
        -:  678:
        -:  679:#endif /* UNALIGNED_OK */
        -:  680:
  1979358:  681:        if (len > best_len) {
branch  0 taken 1793845 (fallthrough)
branch  1 taken 185513
  1793845:  682:            match_start = cur_match;
  1793845:  683:            best_len = len;
  1793845:  684:            if (len >= nice_match) break;
branch  0 taken 431802 (fallthrough)
branch  1 taken 1362043
        -:  685:#ifdef UNALIGNED_OK
        -:  686:            scan_end = *(ush*)(scan+best_len-1);
        -:  687:#else
  1362043:  688:            scan_end1  = scan[best_len-1];
  1362043:  689:            scan_end   = scan[best_len];
        -:  690:#endif
        -:  691:        }
 39438603:  692:    } while ((cur_match = prev[cur_match & WMASK]) > limit
 39438603:  693:	     && --chain_length != 0);
branch  0 taken 38256418 (fallthrough)
branch  1 taken 1182185
branch  2 taken 37987927
branch  3 taken 268491 (fallthrough)
        -:  694:
  1882478:  695:    return best_len;
        -:  696:}
        -:  697:#endif /* ASMV */
        -:  698:
        -:  699:#ifdef DEBUG
        -:  700:/* ===========================================================================
        -:  701: * Check that the match at match_start is indeed a match.
        -:  702: */
        -:  703:local void check_match(start, match, length)
        -:  704:    IPos start, match;
        -:  705:    int length;
        -:  706:{
        -:  707:    /* check that the match is indeed a match */
        -:  708:    if (memcmp((char*)window + match,
        -:  709:                (char*)window + start, length) != EQUAL) {
        -:  710:        fprintf(stderr,
        -:  711:            " start %d, match %d, length %d\n",
        -:  712:            start, match, length);
        -:  713:        error("invalid match");
        -:  714:    }
        -:  715:    if (verbose > 1) {
        -:  716:        fprintf(stderr,"\\[%d,%d]", start-match, length);
        -:  717:        do { putc(window[start++], stderr); } while (--length != 0);
        -:  718:    }
        -:  719:}
        -:  720:#else
        -:  721:#  define check_match(start, match, length)
        -:  722:#endif
        -:  723:
        -:  724:/* ===========================================================================
        -:  725: * Fill the window when the lookahead becomes insufficient.
        -:  726: * Updates strstart and lookahead, and sets eofile if end of input file.
        -:  727: * IN assertion: lookahead < MIN_LOOKAHEAD && strstart + lookahead > 0
        -:  728: * OUT assertions: at least one byte has been read, or eofile is set;
        -:  729: *    file reads are performed for at least two bytes (required for the
        -:  730: *    translate_eol option).
        -:  731: */
function fill_window called 3395 returned 100% blocks executed 96%
     3395:  732:local void fill_window()
        -:  733:{
        -:  734:    register unsigned n, m;
     3395:  735:    unsigned more = (unsigned)(window_size - (ulg)lookahead - (ulg)strstart);
        -:  736:    /* Amount of free space at the end of the window. */
        -:  737:
        -:  738:    /* If the window is almost full and there is insufficient lookahead,
        -:  739:     * move the upper half to the lower one to make room in the upper half.
        -:  740:     */
     3395:  741:    if (more == (unsigned)EOF) {
branch  0 taken 0 (fallthrough)
branch  1 taken 3395
        -:  742:        /* Very unlikely, but possible on 16 bit machine if strstart == 0
        -:  743:         * and lookahead == 1 (input done one byte at time)
        -:  744:         */
    #####:  745:        more--;
     3395:  746:    } else if (strstart >= WSIZE+MAX_DIST) {
branch  0 taken 3223 (fallthrough)
branch  1 taken 172
        -:  747:        /* By the IN assertion, the window is not empty so we can't confuse
        -:  748:         * more == 0 with more == 64K on a 16 bit machine.
        -:  749:         */
        -:  750:        Assert(window_size == (ulg)2*WSIZE, "no sliding with BIG_MEM");
        -:  751:
     3223:  752:        memcpy((char*)window, (char*)window+WSIZE, (unsigned)WSIZE);
     3223:  753:        match_start -= WSIZE;
     3223:  754:        strstart    -= WSIZE; /* we now have strstart >= MAX_DIST: */
        -:  755:
     3223:  756:        block_start -= (long) WSIZE;
        -:  757:
105614487:  758:        for (n = 0; n < HASH_SIZE; n++) {
branch  0 taken 105611264
branch  1 taken 3223 (fallthrough)
105611264:  759:            m = head[n];
105611264:  760:            head[n] = (Pos)(m >= WSIZE ? m-WSIZE : NIL);
branch  0 taken 67185 (fallthrough)
branch  1 taken 105544079
        -:  761:        }
105614487:  762:        for (n = 0; n < WSIZE; n++) {
branch  0 taken 105611264
branch  1 taken 3223 (fallthrough)
105611264:  763:            m = prev[n];
105611264:  764:            prev[n] = (Pos)(m >= WSIZE ? m-WSIZE : NIL);
branch  0 taken 105113304 (fallthrough)
branch  1 taken 497960
        -:  765:            /* If n is not on any hash chain, prev[n] is garbage but
        -:  766:             * its value will never be used.
        -:  767:             */
        -:  768:        }
     3223:  769:        more += WSIZE;
        -:  770:    }
        -:  771:    /* At this point, more >= 2 */
     3395:  772:    if (!eofile) {
branch  0 taken 3395 (fallthrough)
branch  1 taken 0
     3395:  773:        n = read_buf((char*)window+strstart+lookahead, more);
call    0 returned 3395
     3395:  774:        if (n == 0 || n == (unsigned)EOF) {
branch  0 taken 3222 (fallthrough)
branch  1 taken 173
branch  2 taken 0 (fallthrough)
branch  3 taken 3222
      173:  775:            eofile = 1;
        -:  776:        } else {
     3222:  777:            lookahead += n;
        -:  778:        }
        -:  779:    }
     3395:  780:}
        -:  781:
        -:  782:/* ===========================================================================
        -:  783: * Flush the current block, with given end-of-file flag.
        -:  784: * IN assertion: strstart is set to the end of the current match.
        -:  785: */
        -:  786:#define FLUSH_BLOCK(eof) \
        -:  787:   flush_block(block_start >= 0L ? (char*)&window[(unsigned)block_start] : \
        -:  788:                (char*)NULL, (long)strstart - block_start, (eof))
        -:  789:
        -:  790:/* ===========================================================================
        -:  791: * Processes a new input file and return its compressed length. This
        -:  792: * function does not perform lazy evaluationof matches and inserts
        -:  793: * new strings in the dictionary only for unmatched strings or for short
        -:  794: * matches. It is used only for the fast compression options.
        -:  795: */
function deflate_fast called 49 returned 100% blocks executed 81%
       49:  796:local ulg deflate_fast()
        -:  797:{
        -:  798:    IPos hash_head; /* head of the hash chain */
        -:  799:    int flush;      /* set if current block must be flushed */
       49:  800:    unsigned match_length = 0;  /* length of best match */
        -:  801:
       49:  802:    prev_length = MIN_MATCH-1;
   377398:  803:    while (lookahead != 0) {
branch  0 taken 377349
branch  1 taken 49 (fallthrough)
        -:  804:        /* Insert the string window[strstart .. strstart+2] in the
        -:  805:         * dictionary, and set hash_head to the head of the hash chain:
        -:  806:         */
   377349:  807:        INSERT_STRING(strstart, hash_head);
        -:  808:
        -:  809:        /* Find the longest match, discarding those <= prev_length.
        -:  810:         * At this point we have always match_length < MIN_MATCH
        -:  811:         */
   377349:  812:        if (hash_head != NIL && strstart - hash_head <= MAX_DIST) {
branch  0 taken 277067 (fallthrough)
branch  1 taken 100282
branch  2 taken 277051 (fallthrough)
branch  3 taken 16
        -:  813:            /* To simplify the code, we prevent matches with the string
        -:  814:             * of window index 0 (in particular we have to avoid a match
        -:  815:             * of the string with itself at the start of the input file).
        -:  816:             */
   277051:  817:            match_length = longest_match (hash_head);
call    0 returned 277051
        -:  818:            /* longest_match() sets match_start */
   277051:  819:            if (match_length > lookahead) match_length = lookahead;
branch  0 taken 49 (fallthrough)
branch  1 taken 277002
        -:  820:        }
   377349:  821:        if (match_length >= MIN_MATCH) {
branch  0 taken 257451 (fallthrough)
branch  1 taken 119898
        -:  822:            check_match(strstart, match_start, match_length);
        -:  823:
   257451:  824:            flush = ct_tally(strstart-match_start, match_length - MIN_MATCH);
call    0 returned 257451
        -:  825:
   257451:  826:            lookahead -= match_length;
        -:  827:
        -:  828:	    /* Insert new strings in the hash table only if the match length
        -:  829:             * is not too large. This saves time but degrades compression.
        -:  830:             */
   257451:  831:            if (match_length <= max_insert_length) {
branch  0 taken 149725 (fallthrough)
branch  1 taken 107726
   149725:  832:                match_length--; /* string at strstart already in hash table */
        -:  833:                do {
   421537:  834:                    strstart++;
   421537:  835:                    INSERT_STRING(strstart, hash_head);
        -:  836:                    /* strstart never exceeds WSIZE-MAX_MATCH, so there are
        -:  837:                     * always MIN_MATCH bytes ahead. If lookahead < MIN_MATCH
        -:  838:                     * these bytes are garbage, but it does not matter since
        -:  839:                     * the next lookahead bytes will be emitted as literals.
        -:  840:                     */
   421537:  841:                } while (--match_length != 0);
branch  0 taken 271812
branch  1 taken 149725 (fallthrough)
   149725:  842:	        strstart++; 
        -:  843:            } else {
   107726:  844:	        strstart += match_length;
   107726:  845:	        match_length = 0;
   107726:  846:	        ins_h = window[strstart];
   107726:  847:	        UPDATE_HASH(ins_h, window[strstart+1]);
        -:  848:#if MIN_MATCH != 3
        -:  849:                Call UPDATE_HASH() MIN_MATCH-3 more times
        -:  850:#endif
        -:  851:            }
        -:  852:        } else {
        -:  853:            /* No match, output a literal byte */
        -:  854:            Tracevv((stderr,"%c",window[strstart]));
   119898:  855:            flush = ct_tally (0, window[strstart]);
call    0 returned 119898
   119898:  856:            lookahead--;
   119898:  857:	    strstart++; 
        -:  858:        }
  377349*:  859:        if (flush) FLUSH_BLOCK(0), block_start = strstart;
branch  0 taken 0 (fallthrough)
branch  1 taken 377349
branch  2 never executed
branch  3 never executed
call    4 never executed
        -:  860:
        -:  861:        /* Make sure that we always have enough lookahead, except
        -:  862:         * at the end of the input file. We need MAX_MATCH bytes
        -:  863:         * for the next match, plus MIN_MATCH bytes to insert the
        -:  864:         * string following the next match.
        -:  865:         */
   377398:  866:        while (lookahead < MIN_LOOKAHEAD && !eofile) fill_window();
call    0 returned 49
branch  1 taken 4460 (fallthrough)
branch  2 taken 372938
branch  3 taken 49
branch  4 taken 4411 (fallthrough)
        -:  867:
        -:  868:    }
      49*:  869:    return FLUSH_BLOCK(1); /* eof */
branch  0 taken 49 (fallthrough)
branch  1 taken 0
call    2 returned 49
        -:  870:}
        -:  871:
        -:  872:/* ===========================================================================
        -:  873: * Same as above, but achieves better compression. We use a lazy
        -:  874: * evaluation for matches: a match is finally adopted only if there is
        -:  875: * no better match at the next window position.
        -:  876: */
function deflate called 175 returned 100% blocks executed 98%
      175:  877:ulg deflate()
        -:  878:{
        -:  879:    IPos hash_head;          /* head of hash chain */
        -:  880:    IPos prev_match;         /* previous match */
        -:  881:    int flush;               /* set if current block must be flushed */
      175:  882:    int match_available = 0; /* set if previous match exists */
      175:  883:    register unsigned match_length = MIN_MATCH-1; /* length of best match */
        -:  884:#ifdef DEBUG
        -:  885:    extern long isize;        /* byte length of input file, for debug only */
        -:  886:#endif
        -:  887:
      175:  888:    if (compr_level <= 3) return deflate_fast(); /* optimized for speed */
branch  0 taken 49 (fallthrough)
branch  1 taken 126
call    2 returned 49
        -:  889:
        -:  890:    /* Process the input block. */
  2402009:  891:    while (lookahead != 0) {
branch  0 taken 2401883
branch  1 taken 126 (fallthrough)
        -:  892:        /* Insert the string window[strstart .. strstart+2] in the
        -:  893:         * dictionary, and set hash_head to the head of the hash chain:
        -:  894:         */
  2401883:  895:        INSERT_STRING(strstart, hash_head);
        -:  896:
        -:  897:        /* Find the longest match, discarding those <= prev_length.
        -:  898:         */
  2401883:  899:        prev_length = match_length, prev_match = match_start;
  2401883:  900:        match_length = MIN_MATCH-1;
        -:  901:
  2401883:  902:        if (hash_head != NIL && prev_length < max_lazy_match &&
branch  0 taken 2099255 (fallthrough)
branch  1 taken 302628
branch  2 taken 1608086 (fallthrough)
branch  3 taken 491169
  1608086:  903:            strstart - hash_head <= MAX_DIST) {
branch  0 taken 1605427 (fallthrough)
branch  1 taken 2659
        -:  904:            /* To simplify the code, we prevent matches with the string
        -:  905:             * of window index 0 (in particular we have to avoid a match
        -:  906:             * of the string with itself at the start of the input file).
        -:  907:             */
  1605427:  908:            match_length = longest_match (hash_head);
call    0 returned 1605427
        -:  909:            /* longest_match() sets match_start */
  1605427:  910:            if (match_length > lookahead) match_length = lookahead;
branch  0 taken 123 (fallthrough)
branch  1 taken 1605304
        -:  911:
        -:  912:            /* Ignore a length 3 match if it is too distant: */
  1605427:  913:            if (match_length == MIN_MATCH && strstart-match_start > TOO_FAR){
branch  0 taken 177707 (fallthrough)
branch  1 taken 1427720
branch  2 taken 37114 (fallthrough)
branch  3 taken 140593
        -:  914:                /* If prev_match is also MIN_MATCH, match_start is garbage
        -:  915:                 * but we will ignore the current match anyway.
        -:  916:                 */
    37114:  917:                match_length--;
        -:  918:            }
        -:  919:        }
        -:  920:        /* If there was a match at the previous step and the current
        -:  921:         * match is not better, output the previous match:
        -:  922:         */
  2401883:  923:        if (prev_length >= MIN_MATCH && match_length <= prev_length) {
branch  0 taken 1059394 (fallthrough)
branch  1 taken 1342489
branch  2 taken 974186 (fallthrough)
branch  3 taken 85208
        -:  924:
        -:  925:            check_match(strstart-1, prev_match, prev_length);
        -:  926:
   974186:  927:            flush = ct_tally(strstart-1-prev_match, prev_length - MIN_MATCH);
call    0 returned 974186
        -:  928:
        -:  929:            /* Insert in hash table all strings up to the end of the match.
        -:  930:             * strstart-1 and strstart are already inserted.
        -:  931:             */
   974186:  932:            lookahead -= prev_length-1;
   974186:  933:            prev_length -= 2;
        -:  934:            do {
107416300:  935:                strstart++;
107416300:  936:                INSERT_STRING(strstart, hash_head);
        -:  937:                /* strstart never exceeds WSIZE-MAX_MATCH, so there are
        -:  938:                 * always MIN_MATCH bytes ahead. If lookahead < MIN_MATCH
        -:  939:                 * these bytes are garbage, but it does not matter since the
        -:  940:                 * next lookahead bytes will always be emitted as literals.
        -:  941:                 */
107416300:  942:            } while (--prev_length != 0);
branch  0 taken 106442114
branch  1 taken 974186 (fallthrough)
   974186:  943:            match_available = 0;
   974186:  944:            match_length = MIN_MATCH-1;
   974186:  945:            strstart++;
   974186:  946:            if (flush) FLUSH_BLOCK(0), block_start = strstart;
branch  0 taken 16 (fallthrough)
branch  1 taken 974170
branch  2 taken 1 (fallthrough)
branch  3 taken 15
call    4 returned 16
        -:  947:
  1427697:  948:        } else if (match_available) {
branch  0 taken 453391 (fallthrough)
branch  1 taken 974306
        -:  949:            /* If there was no match at the previous position, output a
        -:  950:             * single literal. If there was a match but the current match
        -:  951:             * is longer, truncate the previous match to a single literal.
        -:  952:             */
        -:  953:            Tracevv((stderr,"%c",window[strstart-1]));
   453391:  954:            if (ct_tally (0, window[strstart-1])) {
call    0 returned 453391
branch  1 taken 4 (fallthrough)
branch  2 taken 453387
       4*:  955:                FLUSH_BLOCK(0), block_start = strstart;
branch  0 taken 4 (fallthrough)
branch  1 taken 0
call    2 returned 4
        -:  956:            }
   453391:  957:            strstart++;
   453391:  958:            lookahead--;
        -:  959:        } else {
        -:  960:            /* There is no previous match to compare with, wait for
        -:  961:             * the next step to decide.
        -:  962:             */
   974306:  963:            match_available = 1;
   974306:  964:            strstart++;
   974306:  965:            lookahead--;
        -:  966:        }
        -:  967:        Assert (strstart <= isize && lookahead <= isize, "a bit too far");
        -:  968:
        -:  969:        /* Make sure that we always have enough lookahead, except
        -:  970:         * at the end of the input file. We need MAX_MATCH bytes
        -:  971:         * for the next match, plus MIN_MATCH bytes to insert the
        -:  972:         * string following the next match.
        -:  973:         */
  2405229:  974:        while (lookahead < MIN_LOOKAHEAD && !eofile) fill_window();
call    0 returned 3346
branch  1 taken 17118 (fallthrough)
branch  2 taken 2388111
branch  3 taken 3346
branch  4 taken 13772 (fallthrough)
        -:  975:    }
      126:  976:    if (match_available) ct_tally (0, window[strstart-1]);
branch  0 taken 120 (fallthrough)
branch  1 taken 6
call    2 returned 120
        -:  977:
      126:  978:    return FLUSH_BLOCK(1); /* eof */
branch  0 taken 123 (fallthrough)
branch  1 taken 3
call    2 returned 126
        -:  979:}
        -:  980:/* inflate.c -- Not copyrighted 1992 by Mark Adler
        -:  981:   version c10p1, 10 January 1993 */
        -:  982:
        -:  983:/* You can do whatever you like with this source file, though I would
        -:  984:   prefer that if you modify it and redistribute it that you include
        -:  985:   comments to that effect with your name and the date.  Thank you.
        -:  986:   [The history has been moved to the file ChangeLog.]
        -:  987: */
        -:  988:
        -:  989:/*
        -:  990:   Inflate deflated (PKZIP's method 8 compressed) data.  The compression
        -:  991:   method searches for as much of the current string of bytes (up to a
        -:  992:   length of 258) in the previous 32K bytes.  If it doesn't find any
        -:  993:   matches (of at least length 3), it codes the next byte.  Otherwise, it
        -:  994:   codes the length of the matched string and its distance backwards from
        -:  995:   the current position.  There is a single Huffman code that codes both
        -:  996:   single bytes (called "literals") and match lengths.  A second Huffman
        -:  997:   code codes the distance information, which follows a length code.  Each
        -:  998:   length or distance code actually represents a base value and a number
        -:  999:   of "extra" (sometimes zero) bits to get to add to the base value.  At
        -: 1000:   the end of each deflated block is a special end-of-block (EOB) literal/
        -: 1001:   length code.  The decoding process is basically: get a literal/length
        -: 1002:   code; if EOB then done; if a literal, emit the decoded byte; if a
        -: 1003:   length then get the distance and emit the referred-to bytes from the
        -: 1004:   sliding window of previously emitted data.
        -: 1005:
        -: 1006:   There are (currently) three kinds of inflate blocks: stored, fixed, and
        -: 1007:   dynamic.  The compressor deals with some chunk of data at a time, and
        -: 1008:   decides which method to use on a chunk-by-chunk basis.  A chunk might
        -: 1009:   typically be 32K or 64K.  If the chunk is uncompressible, then the
        -: 1010:   "stored" method is used.  In this case, the bytes are simply stored as
        -: 1011:   is, eight bits per byte, with none of the above coding.  The bytes are
        -: 1012:   preceded by a count, since there is no longer an EOB code.
        -: 1013:
        -: 1014:   If the data is compressible, then either the fixed or dynamic methods
        -: 1015:   are used.  In the dynamic method, the compressed data is preceded by
        -: 1016:   an encoding of the literal/length and distance Huffman codes that are
        -: 1017:   to be used to decode this block.  The representation is itself Huffman
        -: 1018:   coded, and so is preceded by a description of that code.  These code
        -: 1019:   descriptions take up a little space, and so for small blocks, there is
        -: 1020:   a predefined set of codes, called the fixed codes.  The fixed method is
        -: 1021:   used if the block codes up smaller that way (usually for quite small
        -: 1022:   chunks), otherwise the dynamic method is used.  In the latter case, the
        -: 1023:   codes are customized to the probabilities in the current block, and so
        -: 1024:   can code it much better than the pre-determined fixed codes.
        -: 1025: 
        -: 1026:   The Huffman codes themselves are decoded using a mutli-level table
        -: 1027:   lookup, in order to maximize the speed of decoding plus the speed of
        -: 1028:   building the decoding tables.  See the comments below that precede the
        -: 1029:   lbits and dbits tuning parameters.
        -: 1030: */
        -: 1031:
        -: 1032:
        -: 1033:/*
        -: 1034:   Notes beyond the 1.93a appnote.txt:
        -: 1035:
        -: 1036:   1. Distance pointers never point before the beginning of the output
        -: 1037:      stream.
        -: 1038:   2. Distance pointers can point back across blocks, up to 32k away.
        -: 1039:   3. There is an implied maximum of 7 bits for the bit length table and
        -: 1040:      15 bits for the actual data.
        -: 1041:   4. If only one code exists, then it is encoded using one bit.  (Zero
        -: 1042:      would be more efficient, but perhaps a little confusing.)  If two
        -: 1043:      codes exist, they are coded using one bit each (0 and 1).
        -: 1044:   5. There is no way of sending zero distance codes--a dummy must be
        -: 1045:      sent if there are none.  (History: a pre 2.0 version of PKZIP would
        -: 1046:      store blocks with no distance codes, but this was discovered to be
        -: 1047:      too harsh a criterion.)  Valid only for 1.93a.  2.04c does allow
        -: 1048:      zero distance codes, which is sent as one code of zero bits in
        -: 1049:      length.
        -: 1050:   6. There are up to 286 literal/length codes.  Code 256 represents the
        -: 1051:      end-of-block.  Note however that the static length tree defines
        -: 1052:      288 codes just to fill out the Huffman codes.  Codes 286 and 287
        -: 1053:      cannot be used though, since there is no length base or extra bits
        -: 1054:      defined for them.  Similarly, there are up to 30 distance codes.
        -: 1055:      However, static trees define 32 codes (all 5 bits) to fill out the
        -: 1056:      Huffman codes, but the last two had better not show up in the data.
        -: 1057:   7. Unzip can check dynamic Huffman blocks for complete code sets.
        -: 1058:      The exception is that a single code would not be complete (see #4).
        -: 1059:   8. The five bits following the block type is really the number of
        -: 1060:      literal codes sent minus 257.
        -: 1061:   9. Length codes 8,16,16 are interpreted as 13 length codes of 8 bits
        -: 1062:      (1+6+6).  Therefore, to output three times the length, you output
        -: 1063:      three codes (1+1+1), whereas to output four times the same length,
        -: 1064:      you only need two codes (1+3).  Hmm.
        -: 1065:  10. In the tree reconstruction algorithm, Code = Code + Increment
        -: 1066:      only if BitLength(i) is not zero.  (Pretty obvious.)
        -: 1067:  11. Correction: 4 Bits: # of Bit Length codes - 4     (4 - 19)
        -: 1068:  12. Note: length code 284 can represent 227-258, but length code 285
        -: 1069:      really is 258.  The last length deserves its own, short code
        -: 1070:      since it gets used a lot in very redundant files.  The length
        -: 1071:      258 is special since 258 - 3 (the min match length) is 255.
        -: 1072:  13. The literal/length and distance code bit lengths are read as a
        -: 1073:      single stream of lengths.  It is possible (and advantageous) for
        -: 1074:      a repeat code (16, 17, or 18) to go across the boundary between
        -: 1075:      the two sets of lengths.
        -: 1076: */
        -: 1077:
        -: 1078:#ifdef RCSID
        -: 1079:static char rcsid[] = "$Id: inflate.c,v 0.14 1993/06/10 13:27:04 jloup Exp $";
        -: 1080:#endif
        -: 1081:
        -: 1082:#if defined(STDC_HEADERS) || !defined(NO_STDLIB_H)
        -: 1083:#  include <stdlib.h>
        -: 1084:#endif
        -: 1085:
        -: 1086:#define slide window
        -: 1087:
        -: 1088:/* Huffman code lookup table entry--this entry is four bytes for machines
        -: 1089:   that have 16-bit pointers (e.g. PC's in the small or medium model).
        -: 1090:   Valid extra bits are 0..13.  e == 15 is EOB (end of block), e == 16
        -: 1091:   means that v is a literal, 16 < e < 32 means that v is a pointer to
        -: 1092:   the next table, which codes e - 16 bits, and lastly e == 99 indicates
        -: 1093:   an unused code.  If a code with e == 99 is looked up, this implies an
        -: 1094:   error in the data. */
        -: 1095:struct huft {
        -: 1096:  uch e;                /* number of extra bits or operation */
        -: 1097:  uch b;                /* number of bits in this code or subcode */
        -: 1098:  union {
        -: 1099:    ush n;              /* literal, length base, or distance base */
        -: 1100:    struct huft *t;     /* pointer to next level of table */
        -: 1101:  } v;
        -: 1102:};
        -: 1103:
        -: 1104:
        -: 1105:/* Function prototypes */
        -: 1106:int huft_build OF((unsigned *, unsigned, unsigned, ush *, ush *,
        -: 1107:                   struct huft **, int *));
        -: 1108:int huft_free OF((struct huft *));
        -: 1109:int inflate_codes OF((struct huft *, struct huft *, int, int));
        -: 1110:int inflate_stored OF((void));
        -: 1111:int inflate_fixed OF((void));
        -: 1112:int inflate_dynamic OF((void));
        -: 1113:int inflate_block OF((int *));
        -: 1114:int inflate OF((void));
        -: 1115:
        -: 1116:
        -: 1117:/* The inflate algorithm uses a sliding 32K byte window on the uncompressed
        -: 1118:   stream to find repeated byte strings.  This is implemented here as a
        -: 1119:   circular buffer.  The index is updated simply by incrementing and then
        -: 1120:   and'ing with 0x7fff (32K-1). */
        -: 1121:/* It is left to other modules to supply the 32K area.  It is assumed
        -: 1122:   to be usable as if it were declared "uch slide[32768];" or as just
        -: 1123:   "uch *slide;" and then malloc'ed in the latter case.  The definition
        -: 1124:   must be in unzip.h, included above. */
        -: 1125:/* unsigned wp;             current position in slide */
        -: 1126:#define wp outcnt
        -: 1127:#define flush_output(w) (wp=(w),flush_window())
        -: 1128:
        -: 1129:/* Tables for deflate from PKZIP's appnote.txt. */
        -: 1130:static unsigned border[] = {    /* Order of the bit length code lengths */
        -: 1131:        16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
        -: 1132:static ush cplens[] = {         /* Copy lengths for literal codes 257..285 */
        -: 1133:        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
        -: 1134:        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
        -: 1135:        /* note: see note #13 above about the 258 in this list. */
        -: 1136:static ush cplext[] = {         /* Extra bits for literal codes 257..285 */
        -: 1137:        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
        -: 1138:        3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99}; /* 99==invalid */
        -: 1139:static ush cpdist[] = {         /* Copy offsets for distance codes 0..29 */
        -: 1140:        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
        -: 1141:        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
        -: 1142:        8193, 12289, 16385, 24577};
        -: 1143:static ush cpdext[] = {         /* Extra bits for distance codes */
        -: 1144:        0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,
        -: 1145:        7, 7, 8, 8, 9, 9, 10, 10, 11, 11,
        -: 1146:        12, 12, 13, 13};
        -: 1147:
        -: 1148:
        -: 1149:
        -: 1150:/* Macros for inflate() bit peeking and grabbing.
        -: 1151:   The usage is:
        -: 1152:   
        -: 1153:        NEEDBITS(j)
        -: 1154:        x = b & mask_bits[j];
        -: 1155:        DUMPBITS(j)
        -: 1156:
        -: 1157:   where NEEDBITS makes sure that b has at least j bits in it, and
        -: 1158:   DUMPBITS removes the bits from b.  The macros use the variable k
        -: 1159:   for the number of bits in b.  Normally, b and k are register
        -: 1160:   variables for speed, and are initialized at the beginning of a
        -: 1161:   routine that uses these macros from a global bit buffer and count.
        -: 1162:
        -: 1163:   If we assume that EOB will be the longest code, then we will never
        -: 1164:   ask for bits with NEEDBITS that are beyond the end of the stream.
        -: 1165:   So, NEEDBITS should not read any more bytes than are needed to
        -: 1166:   meet the request.  Then no bytes need to be "returned" to the buffer
        -: 1167:   at the end of the last block.
        -: 1168:
        -: 1169:   However, this assumption is not true for fixed blocks--the EOB code
        -: 1170:   is 7 bits, but the other literal/length codes can be 8 or 9 bits.
        -: 1171:   (The EOB code is shorter than other codes because fixed blocks are
        -: 1172:   generally short.  So, while a block always has an EOB, many other
        -: 1173:   literal/length codes have a significantly lower probability of
        -: 1174:   showing up at all.)  However, by making the first table have a
        -: 1175:   lookup of seven bits, the EOB code will be found in that first
        -: 1176:   lookup, and so will not require that too many bits be pulled from
        -: 1177:   the stream.
        -: 1178: */
        -: 1179:
        -: 1180:ulg bb;                         /* bit buffer */
        -: 1181:unsigned bk;                    /* bits in bit buffer */
        -: 1182:
        -: 1183:ush mask_bits[] = {
        -: 1184:    0x0000,
        -: 1185:    0x0001, 0x0003, 0x0007, 0x000f, 0x001f, 0x003f, 0x007f, 0x00ff,
        -: 1186:    0x01ff, 0x03ff, 0x07ff, 0x0fff, 0x1fff, 0x3fff, 0x7fff, 0xffff
        -: 1187:};
        -: 1188:
        -: 1189:#ifdef CRYPT
        -: 1190:  uch cc;
        -: 1191:#  define NEXTBYTE() \
        -: 1192:     (decrypt ? (cc = get_byte(), zdecode(cc), cc) : get_byte())
        -: 1193:#else
        -: 1194:#  define NEXTBYTE()  (uch)get_byte()
        -: 1195:#endif
        -: 1196:#define NEEDBITS(n) {while(k<(n)){b|=((ulg)NEXTBYTE())<<k;k+=8;}}
        -: 1197:#define DUMPBITS(n) {b>>=(n);k-=(n);}
        -: 1198:
        -: 1199:
        -: 1200:/*
        -: 1201:   Huffman code decoding is performed using a multi-level table lookup.
        -: 1202:   The fastest way to decode is to simply build a lookup table whose
        -: 1203:   size is determined by the longest code.  However, the time it takes
        -: 1204:   to build this table can also be a factor if the data being decoded
        -: 1205:   is not very long.  The most common codes are necessarily the
        -: 1206:   shortest codes, so those codes dominate the decoding time, and hence
        -: 1207:   the speed.  The idea is you can have a shorter table that decodes the
        -: 1208:   shorter, more probable codes, and then point to subsidiary tables for
        -: 1209:   the longer codes.  The time it costs to decode the longer codes is
        -: 1210:   then traded against the time it takes to make longer tables.
        -: 1211:
        -: 1212:   This results of this trade are in the variables lbits and dbits
        -: 1213:   below.  lbits is the number of bits the first level table for literal/
        -: 1214:   length codes can decode in one step, and dbits is the same thing for
        -: 1215:   the distance codes.  Subsequent tables are also less than or equal to
        -: 1216:   those sizes.  These values may be adjusted either when all of the
        -: 1217:   codes are shorter than that, in which case the longest code length in
        -: 1218:   bits is used, or when the shortest code is *longer* than the requested
        -: 1219:   table size, in which case the length of the shortest code in bits is
        -: 1220:   used.
        -: 1221:
        -: 1222:   There are two different values for the two tables, since they code a
        -: 1223:   different number of possibilities each.  The literal/length table
        -: 1224:   codes 286 possible values, or in a flat code, a little over eight
        -: 1225:   bits.  The distance table codes 30 possible values, or a little less
        -: 1226:   than five bits, flat.  The optimum values for speed end up being
        -: 1227:   about one bit more than those, so lbits is 8+1 and dbits is 5+1.
        -: 1228:   The optimum values may differ though from machine to machine, and
        -: 1229:   possibly even between compilers.  Your mileage may vary.
        -: 1230: */
        -: 1231:
        -: 1232:
        -: 1233:int lbits = 9;          /* bits in base literal/length lookup table */
        -: 1234:int dbits = 6;          /* bits in base distance lookup table */
        -: 1235:
        -: 1236:
        -: 1237:/* If BMAX needs to be larger than 16, then h and x[] should be ulg. */
        -: 1238:#define BMAX 16         /* maximum bit length of any code (16 for explode) */
        -: 1239:#define N_MAX 288       /* maximum number of codes in any set */
        -: 1240:
        -: 1241:
        -: 1242:unsigned hufts;         /* track memory usage */
        -: 1243:
        -: 1244:
function huft_build called 36 returned 100% blocks executed 87%
       36: 1245:int huft_build(b, n, s, d, e, t, m)
        -: 1246:unsigned *b;            /* code lengths in bits (all assumed <= BMAX) */
        -: 1247:unsigned n;             /* number of codes (assumed <= N_MAX) */
        -: 1248:unsigned s;             /* number of simple-valued codes (0..s-1) */
        -: 1249:ush *d;                 /* list of base values for non-simple codes */
        -: 1250:ush *e;                 /* list of extra bits for non-simple codes */
        -: 1251:struct huft **t;        /* result: starting table */
        -: 1252:int *m;                 /* maximum lookup bits, returns actual */
        -: 1253:/* Given a list of code lengths and a maximum table size, make a set of
        -: 1254:   tables to decode that set of codes.  Return zero on success, one if
        -: 1255:   the given code set is incomplete (the tables are still built in this
        -: 1256:   case), two if the input is invalid (all zero length codes or an
        -: 1257:   oversubscribed set of lengths), and three if not enough memory. */
        -: 1258:{
        -: 1259:  unsigned a;                   /* counter for codes of length k */
        -: 1260:  unsigned c[BMAX+1];           /* bit length count table */
        -: 1261:  unsigned f;                   /* i repeats in table every f entries */
        -: 1262:  int g;                        /* maximum code length */
        -: 1263:  int h;                        /* table level */
        -: 1264:  register unsigned i;          /* counter, current code */
        -: 1265:  register unsigned j;          /* counter */
        -: 1266:  register int k;               /* number of bits in current code */
        -: 1267:  int l;                        /* bits per table (returned in m) */
        -: 1268:  register unsigned *p;         /* pointer into c[], b[], or v[] */
        -: 1269:  register struct huft *q;      /* points to current table */
        -: 1270:  struct huft r;                /* table entry for structure assignment */
        -: 1271:  struct huft *u[BMAX];         /* table stack */
        -: 1272:  unsigned v[N_MAX];            /* values in order of bit length */
        -: 1273:  register int w;               /* bits before this table == (l * h) */
        -: 1274:  unsigned x[BMAX+1];           /* bit offsets, then code stack */
        -: 1275:  unsigned *xp;                 /* pointer into x */
        -: 1276:  int y;                        /* number of dummy codes added */
        -: 1277:  unsigned z;                   /* number of entries in current table */
        -: 1278:
        -: 1279:
        -: 1280:  /* Generate counts for each bit length */
       36: 1281:  memzero(c, sizeof(c));
       36: 1282:  p = b;  i = n;
        -: 1283:  do {
        -: 1284:    Tracecv(*p, (stderr, (n-i >= ' ' && n-i <= '~' ? "%c %d\n" : "0x%x %d\n"), 
        -: 1285:	    n-i, *p));
        -: 1286:#ifdef FAULTY_F_KL_8
        -: 1287:    p++;                      /* Can't combine with below line (Solaris bug) */
        -: 1288:    c[*p]++;                    /* assume all entries <= BMAX */
        -: 1289:#else
     4019: 1290:    c[*p]++;                    /* assume all entries <= BMAX */
     4019: 1291:    p++;                      /* Can't combine with above line (Solaris bug) */
        -: 1292:#endif
     4019: 1293:  } while (--i);
branch  0 taken 3983
branch  1 taken 36 (fallthrough)
       36: 1294:  if (c[0] == n)                /* null input--all zero length codes */
branch  0 taken 0 (fallthrough)
branch  1 taken 36
        -: 1295:  {
    #####: 1296:    *t = (struct huft *)NULL;
    #####: 1297:    *m = 0;
    #####: 1298:    return 0;
        -: 1299:  }
        -: 1300:
        -: 1301:
        -: 1302:  /* Find minimum and maximum length, bound *m by those */
       36: 1303:  l = *m;
      121: 1304:  for (j = 1; j <= BMAX; j++)
branch  0 taken 121
branch  1 taken 0 (fallthrough)
      121: 1305:    if (c[j])
branch  0 taken 36 (fallthrough)
branch  1 taken 85
       36: 1306:      break;
       36: 1307:  k = j;                        /* minimum code length */
       36: 1308:  if ((unsigned)l < j)
branch  0 taken 0 (fallthrough)
branch  1 taken 36
    #####: 1309:    l = j;
      252: 1310:  for (i = BMAX; i; i--)
branch  0 taken 252
branch  1 taken 0 (fallthrough)
      252: 1311:    if (c[i])
branch  0 taken 36 (fallthrough)
branch  1 taken 216
       36: 1312:      break;
       36: 1313:  g = i;                        /* maximum code length */
       36: 1314:  if ((unsigned)l > i)
branch  0 taken 11 (fallthrough)
branch  1 taken 25
       11: 1315:    l = i;
       36: 1316:  *m = l;
        -: 1317:
        -: 1318:
        -: 1319:  /* Adjust last length count to fill out codes, if needed */
      275: 1320:  for (y = 1 << j; j < i; j++, y <<= 1)
branch  0 taken 239
branch  1 taken 36 (fallthrough)
      239: 1321:    if ((y -= c[j]) < 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 239
    #####: 1322:      return 2;                 /* bad input: more codes than bits */
       36: 1323:  if ((y -= c[i]) < 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 36
    #####: 1324:    return 2;
       36: 1325:  c[i] += y;
        -: 1326:
        -: 1327:
        -: 1328:  /* Generate starting offsets into the value table for each length */
       36: 1329:  x[1] = j = 0;
       36: 1330:  p = c + 1;  xp = x + 2;
      360: 1331:  while (--i) {                 /* note that i == g from above */
branch  0 taken 324
branch  1 taken 36 (fallthrough)
      324: 1332:    *xp++ = (j += *p++);
        -: 1333:  }
        -: 1334:
        -: 1335:
        -: 1336:  /* Make a table of values in order of bit lengths */
       36: 1337:  p = b;  i = 0;
        -: 1338:  do {
     4019: 1339:    if ((j = *p++) != 0)
branch  0 taken 1888 (fallthrough)
branch  1 taken 2131
     1888: 1340:      v[x[j]++] = i;
     4019: 1341:  } while (++i < n);
branch  0 taken 3983
branch  1 taken 36 (fallthrough)
        -: 1342:
        -: 1343:
        -: 1344:  /* Generate the Huffman codes and for each, make the table entries */
       36: 1345:  x[0] = i = 0;                 /* first Huffman code is zero */
       36: 1346:  p = v;                        /* grab values in bit order */
       36: 1347:  h = -1;                       /* no tables yet--level -1 */
       36: 1348:  w = -l;                       /* bits decoded == (l * h) */
       36: 1349:  u[0] = (struct huft *)NULL;   /* just to keep compilers happy */
       36: 1350:  q = (struct huft *)NULL;      /* ditto */
       36: 1351:  z = 0;                        /* ditto */
        -: 1352:
        -: 1353:  /* go through the bit lengths (k already is bits in shortest code) */
      311: 1354:  for (; k <= g; k++)
branch  0 taken 275
branch  1 taken 36 (fallthrough)
        -: 1355:  {
      275: 1356:    a = c[k];
     2163: 1357:    while (a--)
branch  0 taken 1888
branch  1 taken 275 (fallthrough)
        -: 1358:    {
        -: 1359:      /* here i is the Huffman code of length k bits for value *p */
        -: 1360:      /* make tables up to required level */
     2056: 1361:      while (k > w + l)
branch  0 taken 168
branch  1 taken 1888 (fallthrough)
        -: 1362:      {
      168: 1363:        h++;
      168: 1364:        w += l;                 /* previous table always l bits */
        -: 1365:
        -: 1366:        /* compute minimum size table less than or equal to l bits */
      168: 1367:        z = (z = g - w) > (unsigned)l ? l : z;  /* upper limit on table size */
branch  0 taken 24 (fallthrough)
branch  1 taken 144
      168: 1368:        if ((f = 1 << (j = k - w)) > a + 1)     /* try a k-w bit table */
branch  0 taken 71 (fallthrough)
branch  1 taken 97
        -: 1369:        {                       /* too few codes for k-w bit table */
       71: 1370:          f -= a + 1;           /* deduct codes from patterns left */
       71: 1371:          xp = c + k;
      194: 1372:          while (++j < z)       /* try smaller tables up to z bits */
branch  0 taken 134
branch  1 taken 60 (fallthrough)
        -: 1373:          {
      134: 1374:            if ((f <<= 1) <= *++xp)
branch  0 taken 11 (fallthrough)
branch  1 taken 123
       11: 1375:              break;            /* enough codes to use up j bits */
      123: 1376:            f -= *xp;           /* else deduct codes from patterns */
        -: 1377:          }
        -: 1378:        }
      168: 1379:        z = 1 << j;             /* table entries for j-bit table */
        -: 1380:
        -: 1381:        /* allocate and link in new table */
      168: 1382:        if ((q = (struct huft *)malloc((z + 1)*sizeof(struct huft))) ==
branch  0 taken 0 (fallthrough)
branch  1 taken 168
        -: 1383:            (struct huft *)NULL)
        -: 1384:        {
    #####: 1385:          if (h)
branch  0 never executed
branch  1 never executed
    #####: 1386:            huft_free(u[0]);
call    0 never executed
    #####: 1387:          return 3;             /* not enough memory */
        -: 1388:        }
      168: 1389:        hufts += z + 1;         /* track memory usage */
      168: 1390:        *t = q + 1;             /* link to list for huft_free() */
      168: 1391:        *(t = &(q->v.t)) = (struct huft *)NULL;
      168: 1392:        u[h] = ++q;             /* table starts after link */
        -: 1393:
        -: 1394:        /* connect to last table, if there is one */
      168: 1395:        if (h)
branch  0 taken 132 (fallthrough)
branch  1 taken 36
        -: 1396:        {
      132: 1397:          x[h] = i;             /* save pattern for backing up */
      132: 1398:          r.b = (uch)l;         /* bits to dump before this table */
      132: 1399:          r.e = (uch)(16 + j);  /* bits in this table */
      132: 1400:          r.v.t = q;            /* pointer to this table */
      132: 1401:          j = i >> (w - l);     /* (get around Turbo C bug) */
      132: 1402:          u[h-1][j] = r;        /* connect to last table */
        -: 1403:        }
        -: 1404:      }
        -: 1405:
        -: 1406:      /* set up table entry in r */
     1888: 1407:      r.b = (uch)(k - w);
     1888: 1408:      if (p >= v + n)
branch  0 taken 0 (fallthrough)
branch  1 taken 1888
    #####: 1409:        r.e = 99;               /* out of values--invalid code */
     1888: 1410:      else if (*p < s)
branch  0 taken 1283 (fallthrough)
branch  1 taken 605
        -: 1411:      {
     1283: 1412:        r.e = (uch)(*p < 256 ? 16 : 15);    /* 256 is end-of-block code */
branch  0 taken 1271 (fallthrough)
branch  1 taken 12
     1283: 1413:        r.v.n = (ush)(*p);             /* simple code is just the value */
     1283: 1414:	p++;                           /* one compiler does not like *p++ */
        -: 1415:      }
        -: 1416:      else
        -: 1417:      {
      605: 1418:        r.e = (uch)e[*p - s];   /* non-simple--look up in lists */
      605: 1419:        r.v.n = d[*p++ - s];
        -: 1420:      }
        -: 1421:
        -: 1422:      /* fill code-like entries with r */
     1888: 1423:      f = 1 << (k - w);
    10430: 1424:      for (j = i >> w; j < z; j += f)
branch  0 taken 8542
branch  1 taken 1888 (fallthrough)
     8542: 1425:        q[j] = r;
        -: 1426:
        -: 1427:      /* backwards increment the k-bit code i */
     3740: 1428:      for (j = 1 << (k - 1); i & j; j >>= 1)
branch  0 taken 1852
branch  1 taken 1888 (fallthrough)
     1852: 1429:        i ^= j;
     1888: 1430:      i ^= j;
        -: 1431:
        -: 1432:      /* backup over finished tables */
     2020: 1433:      while ((i & ((1 << w) - 1)) != x[h])
branch  0 taken 132
branch  1 taken 1888 (fallthrough)
        -: 1434:      {
      132: 1435:        h--;                    /* don't need to update q */
      132: 1436:        w -= l;
        -: 1437:      }
        -: 1438:    }
        -: 1439:  }
        -: 1440:
        -: 1441:
        -: 1442:  /* Return true (1) if we were given an incomplete table */
      36*: 1443:  return y != 0 && g != 1;
branch  0 taken 0 (fallthrough)
branch  1 taken 36
branch  2 never executed
branch  3 never executed
        -: 1444:}
        -: 1445:
        -: 1446:
        -: 1447:
function huft_free called 36 returned 100% blocks executed 100%
       36: 1448:int huft_free(t)
        -: 1449:struct huft *t;         /* table to free */
        -: 1450:/* Free the malloc'ed tables built by huft_build(), which makes a linked
        -: 1451:   list of the tables it made, with the links in a dummy first entry of
        -: 1452:   each table. */
        -: 1453:{
        -: 1454:  register struct huft *p, *q;
        -: 1455:
        -: 1456:
        -: 1457:  /* Go through linked list, freeing from the malloced (t[-1]) address. */
       36: 1458:  p = t;
      204: 1459:  while (p != (struct huft *)NULL)
branch  0 taken 168
branch  1 taken 36 (fallthrough)
        -: 1460:  {
      168: 1461:    q = (--p)->v.t;
      168: 1462:    free((char*)p);
      168: 1463:    p = q;
        -: 1464:  } 
       36: 1465:  return 0;
        -: 1466:}
        -: 1467:
        -: 1468:
function inflate_codes called 12 returned 100% blocks executed 81%
       12: 1469:int inflate_codes(tl, td, bl, bd)
        -: 1470:struct huft *tl, *td;   /* literal/length and distance decoder tables */
        -: 1471:int bl, bd;             /* number of bits decoded by tl[] and td[] */
        -: 1472:/* inflate (decompress) the codes in a deflated (compressed) block.
        -: 1473:   Return an error code or zero if it all goes ok. */
        -: 1474:{
        -: 1475:  register unsigned e;  /* table entry flag/number of extra bits */
        -: 1476:  unsigned n, d;        /* length and index for copy */
        -: 1477:  unsigned w;           /* current window position */
        -: 1478:  struct huft *t;       /* pointer to table entry */
        -: 1479:  unsigned ml, md;      /* masks for bl and bd bits */
        -: 1480:  register ulg b;       /* bit buffer */
        -: 1481:  register unsigned k;  /* number of bits in bit buffer */
        -: 1482:
        -: 1483:
        -: 1484:  /* make local copies of globals */
       12: 1485:  b = bb;                       /* initialize bit buffer */
       12: 1486:  k = bk;
       12: 1487:  w = wp;                       /* initialize window position */
        -: 1488:
        -: 1489:  /* inflate the coded data */
       12: 1490:  ml = mask_bits[bl];           /* precompute masks for speed */
       12: 1491:  md = mask_bits[bd];
        -: 1492:  for (;;)                      /* do until end of block */
        -: 1493:  {
  175355*: 1494:    NEEDBITS((unsigned)bl)
branch  0 taken 87900 (fallthrough)
branch  1 taken 0
call    2 never executed
branch  3 taken 87900
branch  4 taken 87455 (fallthrough)
    87455: 1495:    if ((e = (t = tl + ((unsigned)b & ml))->e) > 16)
branch  0 taken 1715 (fallthrough)
branch  1 taken 85740
        -: 1496:      do {
     1715: 1497:        if (e == 99)
branch  0 taken 0 (fallthrough)
branch  1 taken 1715
    #####: 1498:          return 1;
     1715: 1499:        DUMPBITS(t->b)
     1715: 1500:        e -= 16;
    2046*: 1501:        NEEDBITS(e)
branch  0 taken 331 (fallthrough)
branch  1 taken 0
call    2 never executed
branch  3 taken 331
branch  4 taken 1715 (fallthrough)
     1715: 1502:      } while ((e = (t = t->v.t + ((unsigned)b & mask_bits[e]))->e) > 16);
branch  0 taken 0
branch  1 taken 1715 (fallthrough)
    87455: 1503:    DUMPBITS(t->b)
    87455: 1504:    if (e == 16)                /* then it's a literal */
branch  0 taken 39175 (fallthrough)
branch  1 taken 48280
        -: 1505:    {
    39175: 1506:      slide[w++] = (uch)t->v.n;
        -: 1507:      Tracevv((stderr, "%c", slide[w-1]));
    39175: 1508:      if (w == WSIZE)
branch  0 taken 1 (fallthrough)
branch  1 taken 39174
        -: 1509:      {
        1: 1510:        flush_output(w);
call    0 returned 1
        1: 1511:        w = 0;
        -: 1512:      }
        -: 1513:    }
        -: 1514:    else                        /* it's an EOB or a length */
        -: 1515:    {
        -: 1516:      /* exit if end of block */
    48280: 1517:      if (e == 15)
branch  0 taken 12 (fallthrough)
branch  1 taken 48268
       12: 1518:        break;
        -: 1519:
        -: 1520:      /* get length of block to copy */
   48520*: 1521:      NEEDBITS(e)
branch  0 taken 252 (fallthrough)
branch  1 taken 0
call    2 never executed
branch  3 taken 252
branch  4 taken 48268 (fallthrough)
    48268: 1522:      n = t->v.n + ((unsigned)b & mask_bits[e]);
    48268: 1523:      DUMPBITS(e);
        -: 1524:
        -: 1525:      /* decode distance of block to copy */
   58048*: 1526:      NEEDBITS((unsigned)bd)
branch  0 taken 9780 (fallthrough)
branch  1 taken 0
call    2 never executed
branch  3 taken 9780
branch  4 taken 48268 (fallthrough)
    48268: 1527:      if ((e = (t = td + ((unsigned)b & md))->e) > 16)
branch  0 taken 1771 (fallthrough)
branch  1 taken 46497
        -: 1528:        do {
     1771: 1529:          if (e == 99)
branch  0 taken 0 (fallthrough)
branch  1 taken 1771
    #####: 1530:            return 1;
     1771: 1531:          DUMPBITS(t->b)
     1771: 1532:          e -= 16;
    2524*: 1533:          NEEDBITS(e)
branch  0 taken 753 (fallthrough)
branch  1 taken 0
call    2 never executed
branch  3 taken 753
branch  4 taken 1771 (fallthrough)
     1771: 1534:        } while ((e = (t = t->v.t + ((unsigned)b & mask_bits[e]))->e) > 16);
branch  0 taken 0
branch  1 taken 1771 (fallthrough)
    48268: 1535:      DUMPBITS(t->b)
   89405*: 1536:      NEEDBITS(e)
branch  0 taken 41137 (fallthrough)
branch  1 taken 0
call    2 never executed
branch  3 taken 41137
branch  4 taken 48268 (fallthrough)
    48268: 1537:      d = w - t->v.n - ((unsigned)b & mask_bits[e]);
    48268: 1538:      DUMPBITS(e)
        -: 1539:      Tracevv((stderr,"\\[%d,%d]", w-d, n));
        -: 1540:
        -: 1541:      /* do the copy */
        -: 1542:      do {
    48291: 1543:        n -= (e = (e = WSIZE - ((d &= WSIZE-1) > w ? d : w)) > n ? n : e);
branch  0 taken 1894 (fallthrough)
branch  1 taken 46397
branch  2 taken 48268 (fallthrough)
branch  3 taken 23
        -: 1544:#if !defined(NOMEMCPY) && !defined(DEBUG)
    48291: 1545:        if (w - d >= e)         /* (this test assumes unsigned comparison) */
branch  0 taken 48088 (fallthrough)
branch  1 taken 203
        -: 1546:        {
    48088: 1547:          memcpy(slide + w, slide + d, e);
    48088: 1548:          w += e;
    48088: 1549:          d += e;
        -: 1550:        }
        -: 1551:        else                      /* do it slow to avoid memcpy() overlap */
        -: 1552:#endif /* !NOMEMCPY */
        -: 1553:          do {
     9338: 1554:            slide[w++] = slide[d++];
        -: 1555:	    Tracevv((stderr, "%c", slide[w-1]));
     9338: 1556:          } while (--e);
branch  0 taken 9135
branch  1 taken 203 (fallthrough)
    48291: 1557:        if (w == WSIZE)
branch  0 taken 11 (fallthrough)
branch  1 taken 48280
        -: 1558:        {
       11: 1559:          flush_output(w);
call    0 returned 11
       11: 1560:          w = 0;
        -: 1561:        }
    48291: 1562:      } while (n);
branch  0 taken 23
branch  1 taken 48268 (fallthrough)
        -: 1563:    }
        -: 1564:  }
        -: 1565:
        -: 1566:
        -: 1567:  /* restore the globals from the locals */
       12: 1568:  wp = w;                       /* restore global window pointer */
       12: 1569:  bb = b;                       /* restore global bit buffer */
       12: 1570:  bk = k;
        -: 1571:
        -: 1572:  /* done */
       12: 1573:  return 0;
        -: 1574:}
        -: 1575:
        -: 1576:
        -: 1577:
function inflate_stored called 2 returned 100% blocks executed 84%
        2: 1578:int inflate_stored()
        -: 1579:/* "decompress" an inflated type 0 (stored) block. */
        -: 1580:{
        -: 1581:  unsigned n;           /* number of bytes in block */
        -: 1582:  unsigned w;           /* current window position */
        -: 1583:  register ulg b;       /* bit buffer */
        -: 1584:  register unsigned k;  /* number of bits in bit buffer */
        -: 1585:
        -: 1586:
        -: 1587:  /* make local copies of globals */
        2: 1588:  b = bb;                       /* initialize bit buffer */
        2: 1589:  k = bk;
        2: 1590:  w = wp;                       /* initialize window position */
        -: 1591:
        -: 1592:
        -: 1593:  /* go to byte boundary */
        2: 1594:  n = k & 7;
        2: 1595:  DUMPBITS(n);
        -: 1596:
        -: 1597:
        -: 1598:  /* get the length and its complement */
       6*: 1599:  NEEDBITS(16)
branch  0 taken 4 (fallthrough)
branch  1 taken 0
call    2 never executed
branch  3 taken 4
branch  4 taken 2 (fallthrough)
        2: 1600:  n = ((unsigned)b & 0xffff);
        2: 1601:  DUMPBITS(16)
       6*: 1602:  NEEDBITS(16)
branch  0 taken 4 (fallthrough)
branch  1 taken 0
call    2 never executed
branch  3 taken 4
branch  4 taken 2 (fallthrough)
        2: 1603:  if (n != (unsigned)((~b) & 0xffff))
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####: 1604:    return 1;                   /* error in compressed data */
        2: 1605:  DUMPBITS(16)
        -: 1606:
        -: 1607:
        -: 1608:  /* read and output the compressed data */
    34233: 1609:  while (n--)
branch  0 taken 34231
branch  1 taken 2 (fallthrough)
        -: 1610:  {
    68462: 1611:    NEEDBITS(8)
branch  0 taken 34230 (fallthrough)
branch  1 taken 1
call    2 returned 1
branch  3 taken 34231
branch  4 taken 34231 (fallthrough)
    34231: 1612:    slide[w++] = (uch)b;
    34231: 1613:    if (w == WSIZE)
branch  0 taken 1 (fallthrough)
branch  1 taken 34230
        -: 1614:    {
        1: 1615:      flush_output(w);
call    0 returned 1
        1: 1616:      w = 0;
        -: 1617:    }
    34231: 1618:    DUMPBITS(8)
        -: 1619:  }
        -: 1620:
        -: 1621:
        -: 1622:  /* restore the globals from the locals */
        2: 1623:  wp = w;                       /* restore global window pointer */
        2: 1624:  bb = b;                       /* restore global bit buffer */
        2: 1625:  bk = k;
        2: 1626:  return 0;
        -: 1627:}
        -: 1628:
        -: 1629:
        -: 1630:
function inflate_fixed called 0 returned 0% blocks executed 0%
    #####: 1631:int inflate_fixed()
        -: 1632:/* decompress an inflated type 1 (fixed Huffman codes) block.  We should
        -: 1633:   either replace this with a custom decoder, or at least precompute the
        -: 1634:   Huffman tables. */
        -: 1635:{
        -: 1636:  int i;                /* temporary variable */
        -: 1637:  struct huft *tl;      /* literal/length code table */
        -: 1638:  struct huft *td;      /* distance code table */
        -: 1639:  int bl;               /* lookup bits for tl */
        -: 1640:  int bd;               /* lookup bits for td */
        -: 1641:  unsigned l[288];      /* length list for huft_build */
        -: 1642:
        -: 1643:
        -: 1644:  /* set up literal table */
    #####: 1645:  for (i = 0; i < 144; i++)
branch  0 never executed
branch  1 never executed
    #####: 1646:    l[i] = 8;
    #####: 1647:  for (; i < 256; i++)
branch  0 never executed
branch  1 never executed
    #####: 1648:    l[i] = 9;
    #####: 1649:  for (; i < 280; i++)
branch  0 never executed
branch  1 never executed
    #####: 1650:    l[i] = 7;
    #####: 1651:  for (; i < 288; i++)          /* make a complete, but wrong code set */
branch  0 never executed
branch  1 never executed
    #####: 1652:    l[i] = 8;
    #####: 1653:  bl = 7;
    #####: 1654:  if ((i = huft_build(l, 288, 257, cplens, cplext, &tl, &bl)) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1655:    return i;
        -: 1656:
        -: 1657:
        -: 1658:  /* set up distance table */
    #####: 1659:  for (i = 0; i < 30; i++)      /* make an incomplete code set */
branch  0 never executed
branch  1 never executed
    #####: 1660:    l[i] = 5;
    #####: 1661:  bd = 5;
    #####: 1662:  if ((i = huft_build(l, 30, 0, cpdist, cpdext, &td, &bd)) > 1)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1663:  {
    #####: 1664:    huft_free(tl);
call    0 never executed
    #####: 1665:    return i;
        -: 1666:  }
        -: 1667:
        -: 1668:
        -: 1669:  /* decompress until an end-of-block code */
    #####: 1670:  if (inflate_codes(tl, td, bl, bd))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1671:    return 1;
        -: 1672:
        -: 1673:
        -: 1674:  /* free the decoding tables, return */
    #####: 1675:  huft_free(tl);
call    0 never executed
    #####: 1676:  huft_free(td);
call    0 never executed
    #####: 1677:  return 0;
        -: 1678:}
        -: 1679:
        -: 1680:
        -: 1681:
function inflate_dynamic called 12 returned 100% blocks executed 66%
       12: 1682:int inflate_dynamic()
        -: 1683:/* decompress an inflated type 2 (dynamic Huffman codes) block. */
        -: 1684:{
        -: 1685:  int i;                /* temporary variables */
        -: 1686:  unsigned j;
        -: 1687:  unsigned l;           /* last length */
        -: 1688:  unsigned m;           /* mask for bit lengths table */
        -: 1689:  unsigned n;           /* number of lengths to get */
        -: 1690:  struct huft *tl;      /* literal/length code table */
        -: 1691:  struct huft *td;      /* distance code table */
        -: 1692:  int bl;               /* lookup bits for tl */
        -: 1693:  int bd;               /* lookup bits for td */
        -: 1694:  unsigned nb;          /* number of bit length codes */
        -: 1695:  unsigned nl;          /* number of literal/length codes */
        -: 1696:  unsigned nd;          /* number of distance codes */
        -: 1697:#ifdef PKZIP_BUG_WORKAROUND
        -: 1698:  unsigned ll[288+32];  /* literal/length and distance code lengths */
        -: 1699:#else
        -: 1700:  unsigned ll[286+30];  /* literal/length and distance code lengths */
        -: 1701:#endif
        -: 1702:  register ulg b;       /* bit buffer */
        -: 1703:  register unsigned k;  /* number of bits in bit buffer */
        -: 1704:
        -: 1705:
        -: 1706:  /* make local bit buffer */
       12: 1707:  b = bb;
       12: 1708:  k = bk;
        -: 1709:
        -: 1710:
        -: 1711:  /* read in table lengths */
      12*: 1712:  NEEDBITS(5)
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 taken 0
branch  4 taken 12 (fallthrough)
       12: 1713:  nl = 257 + ((unsigned)b & 0x1f);      /* number of literal/length codes */
       12: 1714:  DUMPBITS(5)
      24*: 1715:  NEEDBITS(5)
branch  0 taken 12 (fallthrough)
branch  1 taken 0
call    2 never executed
branch  3 taken 12
branch  4 taken 12 (fallthrough)
       12: 1716:  nd = 1 + ((unsigned)b & 0x1f);        /* number of distance codes */
       12: 1717:  DUMPBITS(5)
      23*: 1718:  NEEDBITS(4)
branch  0 taken 11 (fallthrough)
branch  1 taken 0
call    2 never executed
branch  3 taken 11
branch  4 taken 12 (fallthrough)
       12: 1719:  nb = 4 + ((unsigned)b & 0xf);         /* number of bit length codes */
       12: 1720:  DUMPBITS(4)
        -: 1721:#ifdef PKZIP_BUG_WORKAROUND
        -: 1722:  if (nl > 288 || nd > 32)
        -: 1723:#else
       12: 1724:  if (nl > 286 || nd > 30)
branch  0 taken 12 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 12
        -: 1725:#endif
    #####: 1726:    return 1;                   /* bad lengths */
        -: 1727:
        -: 1728:
        -: 1729:  /* read in bit-length-code lengths */
      191: 1730:  for (j = 0; j < nb; j++)
branch  0 taken 179
branch  1 taken 12 (fallthrough)
        -: 1731:  {
     240*: 1732:    NEEDBITS(3)
branch  0 taken 61 (fallthrough)
branch  1 taken 0
call    2 never executed
branch  3 taken 61
branch  4 taken 179 (fallthrough)
      179: 1733:    ll[border[j]] = (unsigned)b & 7;
      179: 1734:    DUMPBITS(3)
        -: 1735:  }
       61: 1736:  for (; j < 19; j++)
branch  0 taken 49
branch  1 taken 12 (fallthrough)
       49: 1737:    ll[border[j]] = 0;
        -: 1738:
        -: 1739:
        -: 1740:  /* build decoding table for trees--single level, 7 bit lookup */
       12: 1741:  bl = 7;
       12: 1742:  if ((i = huft_build(ll, 19, 19, NULL, NULL, &tl, &bl)) != 0)
call    0 returned 12
branch  1 taken 0 (fallthrough)
branch  2 taken 12
        -: 1743:  {
    #####: 1744:    if (i == 1)
branch  0 never executed
branch  1 never executed
    #####: 1745:      huft_free(tl);
call    0 never executed
    #####: 1746:    return i;                   /* incomplete code set */
        -: 1747:  }
        -: 1748:
        -: 1749:
        -: 1750:  /* read in literal and distance code lengths */
       12: 1751:  n = nl + nd;
       12: 1752:  m = mask_bits[bl];
       12: 1753:  i = l = 0;
     1768: 1754:  while ((unsigned)i < n)
branch  0 taken 1756
branch  1 taken 12 (fallthrough)
        -: 1755:  {
    2555*: 1756:    NEEDBITS((unsigned)bl)
branch  0 taken 799 (fallthrough)
branch  1 taken 0
call    2 never executed
branch  3 taken 799
branch  4 taken 1756 (fallthrough)
     1756: 1757:    j = (td = tl + ((unsigned)b & m))->b;
     1756: 1758:    DUMPBITS(j)
     1756: 1759:    j = td->v.n;
     1756: 1760:    if (j < 16)                 /* length of code in bits (0..15) */
branch  0 taken 1662 (fallthrough)
branch  1 taken 94
     1662: 1761:      ll[i++] = l = j;          /* save last length in l */
       94: 1762:    else if (j == 16)           /* repeat last length 3 to 6 times */
branch  0 taken 38 (fallthrough)
branch  1 taken 56
        -: 1763:    {
      38*: 1764:      NEEDBITS(2)
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 taken 0
branch  4 taken 38 (fallthrough)
       38: 1765:      j = 3 + ((unsigned)b & 3);
       38: 1766:      DUMPBITS(2)
       38: 1767:      if ((unsigned)i + j > n)
branch  0 taken 0 (fallthrough)
branch  1 taken 38
    #####: 1768:        return 1;
      190: 1769:      while (j--)
branch  0 taken 152
branch  1 taken 38
      152: 1770:        ll[i++] = l;
        -: 1771:    }
       56: 1772:    else if (j == 17)           /* 3 to 10 zero length codes */
branch  0 taken 32 (fallthrough)
branch  1 taken 24
        -: 1773:    {
      42*: 1774:      NEEDBITS(3)
branch  0 taken 10 (fallthrough)
branch  1 taken 0
call    2 never executed
branch  3 taken 10
branch  4 taken 32 (fallthrough)
       32: 1775:      j = 3 + ((unsigned)b & 7);
       32: 1776:      DUMPBITS(3)
       32: 1777:      if ((unsigned)i + j > n)
branch  0 taken 0 (fallthrough)
branch  1 taken 32
    #####: 1778:        return 1;
      228: 1779:      while (j--)
branch  0 taken 196
branch  1 taken 32 (fallthrough)
      196: 1780:        ll[i++] = 0;
       32: 1781:      l = 0;
        -: 1782:    }
        -: 1783:    else                        /* j == 18: 11 to 138 zero length codes */
        -: 1784:    {
      47*: 1785:      NEEDBITS(7)
branch  0 taken 23 (fallthrough)
branch  1 taken 0
call    2 never executed
branch  3 taken 23
branch  4 taken 24 (fallthrough)
       24: 1786:      j = 11 + ((unsigned)b & 0x7f);
       24: 1787:      DUMPBITS(7)
       24: 1788:      if ((unsigned)i + j > n)
branch  0 taken 0 (fallthrough)
branch  1 taken 24
    #####: 1789:        return 1;
     1805: 1790:      while (j--)
branch  0 taken 1781
branch  1 taken 24 (fallthrough)
     1781: 1791:        ll[i++] = 0;
       24: 1792:      l = 0;
        -: 1793:    }
        -: 1794:  }
        -: 1795:
        -: 1796:
        -: 1797:  /* free decoding table for trees */
       12: 1798:  huft_free(tl);
call    0 returned 12
        -: 1799:
        -: 1800:
        -: 1801:  /* restore the global bit buffer */
       12: 1802:  bb = b;
       12: 1803:  bk = k;
        -: 1804:
        -: 1805:
        -: 1806:  /* build the decoding tables for literal/length and distance codes */
       12: 1807:  bl = lbits;
       12: 1808:  if ((i = huft_build(ll, nl, 257, cplens, cplext, &tl, &bl)) != 0)
call    0 returned 12
branch  1 taken 0 (fallthrough)
branch  2 taken 12
        -: 1809:  {
    #####: 1810:    if (i == 1) {
branch  0 never executed
branch  1 never executed
    #####: 1811:      fprintf(stderr, " incomplete literal tree\n");
call    0 never executed
    #####: 1812:      huft_free(tl);
call    0 never executed
        -: 1813:    }
    #####: 1814:    return i;                   /* incomplete code set */
        -: 1815:  }
       12: 1816:  bd = dbits;
       12: 1817:  if ((i = huft_build(ll + nl, nd, 0, cpdist, cpdext, &td, &bd)) != 0)
call    0 returned 12
branch  1 taken 0 (fallthrough)
branch  2 taken 12
        -: 1818:  {
    #####: 1819:    if (i == 1) {
branch  0 never executed
branch  1 never executed
    #####: 1820:      fprintf(stderr, " incomplete distance tree\n");
call    0 never executed
        -: 1821:#ifdef PKZIP_BUG_WORKAROUND
        -: 1822:      i = 0;
        -: 1823:    }
        -: 1824:#else
    #####: 1825:      huft_free(td);
call    0 never executed
        -: 1826:    }
    #####: 1827:    huft_free(tl);
call    0 never executed
    #####: 1828:    return i;                   /* incomplete code set */
        -: 1829:#endif
        -: 1830:  }
        -: 1831:
        -: 1832:
        -: 1833:  /* decompress until an end-of-block code */
       12: 1834:  if (inflate_codes(tl, td, bl, bd))
call    0 returned 12
branch  1 taken 0 (fallthrough)
branch  2 taken 12
    #####: 1835:    return 1;
        -: 1836:
        -: 1837:
        -: 1838:  /* free the decoding tables, return */
       12: 1839:  huft_free(tl);
call    0 returned 12
       12: 1840:  huft_free(td);
call    0 returned 12
       12: 1841:  return 0;
        -: 1842:}
        -: 1843:
        -: 1844:
        -: 1845:
function inflate_block called 14 returned 100% blocks executed 68%
       14: 1846:int inflate_block(e)
        -: 1847:int *e;                 /* last block flag */
        -: 1848:/* decompress an inflated block */
        -: 1849:{
        -: 1850:  unsigned t;           /* block type */
        -: 1851:  register ulg b;       /* bit buffer */
        -: 1852:  register unsigned k;  /* number of bits in bit buffer */
        -: 1853:
        -: 1854:
        -: 1855:  /* make local bit buffer */
       14: 1856:  b = bb;
       14: 1857:  k = bk;
        -: 1858:
        -: 1859:
        -: 1860:  /* read in last block bit */
      27*: 1861:  NEEDBITS(1)
branch  0 taken 13 (fallthrough)
branch  1 taken 0
call    2 never executed
branch  3 taken 13
branch  4 taken 14 (fallthrough)
       14: 1862:  *e = (int)b & 1;
       14: 1863:  DUMPBITS(1)
        -: 1864:
        -: 1865:
        -: 1866:  /* read in block type */
      15*: 1867:  NEEDBITS(2)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
call    2 never executed
branch  3 taken 1
branch  4 taken 14 (fallthrough)
       14: 1868:  t = (unsigned)b & 3;
       14: 1869:  DUMPBITS(2)
        -: 1870:
        -: 1871:
        -: 1872:  /* restore the global bit buffer */
       14: 1873:  bb = b;
       14: 1874:  bk = k;
        -: 1875:
        -: 1876:
        -: 1877:  /* inflate that block type */
       14: 1878:  if (t == 2)
branch  0 taken 12 (fallthrough)
branch  1 taken 2
       12: 1879:    return inflate_dynamic();
call    0 returned 12
        2: 1880:  if (t == 0)
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2: 1881:    return inflate_stored();
call    0 returned 2
    #####: 1882:  if (t == 1)
branch  0 never executed
branch  1 never executed
    #####: 1883:    return inflate_fixed();
call    0 never executed
        -: 1884:
        -: 1885:
        -: 1886:  /* bad block type */
    #####: 1887:  return 2;
        -: 1888:}
        -: 1889:
        -: 1890:
        -: 1891:
function inflate called 12 returned 100% blocks executed 86%
       12: 1892:int inflate()
        -: 1893:/* decompress an inflated entry */
        -: 1894:{
        -: 1895:  int e;                /* last block flag */
        -: 1896:  int r;                /* result code */
        -: 1897:  unsigned h;           /* maximum struct huft's malloc'ed */
        -: 1898:
        -: 1899:
        -: 1900:  /* initialize window, bit buffer */
       12: 1901:  wp = 0;
       12: 1902:  bk = 0;
       12: 1903:  bb = 0;
        -: 1904:
        -: 1905:
        -: 1906:  /* decompress until the last block */
       12: 1907:  h = 0;
        -: 1908:  do {
       14: 1909:    hufts = 0;
       14: 1910:    if ((r = inflate_block(&e)) != 0)
call    0 returned 14
branch  1 taken 0 (fallthrough)
branch  2 taken 14
    #####: 1911:      return r;
       14: 1912:    if (hufts > h)
branch  0 taken 12 (fallthrough)
branch  1 taken 2
       12: 1913:      h = hufts;
       14: 1914:  } while (!e);
branch  0 taken 2
branch  1 taken 12 (fallthrough)
        -: 1915:
        -: 1916:  /* Undo too much lookahead. The next read will be byte aligned so we
        -: 1917:   * can discard unused bits in the last meaningful byte.
        -: 1918:   */
       12: 1919:  while (bk >= 8) {
branch  0 taken 0
branch  1 taken 12 (fallthrough)
    #####: 1920:    bk -= 8;
    #####: 1921:    inptr--;
        -: 1922:  }
        -: 1923:
        -: 1924:  /* flush out slide */
       12: 1925:  flush_output(wp);
call    0 returned 12
        -: 1926:
        -: 1927:
        -: 1928:  /* return success */
        -: 1929:#ifdef DEBUG
        -: 1930:  fprintf(stderr, "<%u> ", h);
        -: 1931:#endif /* DEBUG */
       12: 1932:  return 0;
        -: 1933:}
        -: 1934:/* lzw.c -- compress files in LZW format.
        -: 1935: * This is a dummy version avoiding patent problems.
        -: 1936: */
        -: 1937:
        -: 1938:#ifdef RCSID
        -: 1939:static char rcsid[] = "$Id: lzw.c,v 0.9 1993/06/10 13:27:31 jloup Exp $";
        -: 1940:#endif
        -: 1941:
        -: 1942:static int msg_done = 0;
        -: 1943:
        -: 1944:/* Compress in to out with lzw method. */
function lzw called 0 returned 0% blocks executed 0%
    #####: 1945:int lzw(in, out)
        -: 1946:    int in, out;
        -: 1947:{
    #####: 1948:    if (msg_done) return ERROR;
branch  0 never executed
branch  1 never executed
    #####: 1949:    msg_done = 1;
    #####: 1950:    fprintf(stderr,"output in compress .Z format not supported\n");
call    0 never executed
        -: 1951:#ifndef FAULTY_F_KP_2
    #####: 1952:    if (in != out) { /* avoid warnings on unused variables */
branch  0 never executed
branch  1 never executed
        -: 1953:#else
        -: 1954:    if (in == out) { /* avoid warnings on unused variables */
        -: 1955:#endif
    #####: 1956:        exit_code = ERROR;
        -: 1957:    }
    #####: 1958:    return ERROR;
        -: 1959:}
        -: 1960:/* trees.c -- output deflated data using Huffman coding
        -: 1961: * Copyright (C) 1992-1993 Jean-loup Gailly
        -: 1962: * This is free software; you can redistribute it and/or modify it under the
        -: 1963: * terms of the GNU General Public License, see the file COPYING.
        -: 1964: */
        -: 1965:
        -: 1966:/*
        -: 1967: *  PURPOSE
        -: 1968: *
        -: 1969: *      Encode various sets of source values using variable-length
        -: 1970: *      binary code trees.
        -: 1971: *
        -: 1972: *  DISCUSSION
        -: 1973: *
        -: 1974: *      The PKZIP "deflation" process uses several Huffman trees. The more
        -: 1975: *      common source values are represented by shorter bit sequences.
        -: 1976: *
        -: 1977: *      Each code tree is stored in the ZIP file in a compressed form
        -: 1978: *      which is itself a Huffman encoding of the lengths of
        -: 1979: *      all the code strings (in ascending order by source values).
        -: 1980: *      The actual code strings are reconstructed from the lengths in
        -: 1981: *      the UNZIP process, as described in the "application note"
        -: 1982: *      (APPNOTE.TXT) distributed as part of PKWARE's PKZIP program.
        -: 1983: *
        -: 1984: *  REFERENCES
        -: 1985: *
        -: 1986: *      Lynch, Thomas J.
        -: 1987: *          Data Compression:  Techniques and Applications, pp. 53-55.
        -: 1988: *          Lifetime Learning Publications, 1985.  ISBN 0-534-03418-7.
        -: 1989: *
        -: 1990: *      Storer, James A.
        -: 1991: *          Data Compression:  Methods and Theory, pp. 49-50.
        -: 1992: *          Computer Science Press, 1988.  ISBN 0-7167-8156-5.
        -: 1993: *
        -: 1994: *      Sedgewick, R.
        -: 1995: *          Algorithms, p290.
        -: 1996: *          Addison-Wesley, 1983. ISBN 0-201-06672-6.
        -: 1997: *
        -: 1998: *  INTERFACE
        -: 1999: *
        -: 2000: *      void ct_init (ush *attr, int *methodp)
        -: 2001: *          Allocate the match buffer, initialize the various tables and save
        -: 2002: *          the location of the internal file attribute (ascii/binary) and
        -: 2003: *          method (DEFLATE/STORE)
        -: 2004: *
        -: 2005: *      void ct_tally (int dist, int lc);
        -: 2006: *          Save the match info and tally the frequency counts.
        -: 2007: *
        -: 2008: *      long flush_block (char *buf, ulg stored_len, int eof)
        -: 2009: *          Determine the best encoding for the current block: dynamic trees,
        -: 2010: *          static trees or store, and output the encoded block to the zip
        -: 2011: *          file. Returns the total compressed length for the file so far.
        -: 2012: *
        -: 2013: */
        -: 2014:
        -: 2015:#ifdef RCSID
        -: 2016:static char rcsid[] = "$Id: trees.c,v 0.12 1993/06/10 13:27:54 jloup Exp $";
        -: 2017:#endif
        -: 2018:
        -: 2019:/* ===========================================================================
        -: 2020: * Constants
        -: 2021: */
        -: 2022:
        -: 2023:#define MAX_BITS 15
        -: 2024:/* All codes must not exceed MAX_BITS bits */
        -: 2025:
        -: 2026:#define MAX_BL_BITS 7
        -: 2027:/* Bit length codes must not exceed MAX_BL_BITS bits */
        -: 2028:
        -: 2029:#define LENGTH_CODES 29
        -: 2030:/* number of length codes, not counting the special END_BLOCK code */
        -: 2031:
        -: 2032:#define LITERALS  256
        -: 2033:/* number of literal bytes 0..255 */
        -: 2034:
        -: 2035:#define END_BLOCK 256
        -: 2036:/* end of block literal code */
        -: 2037:
        -: 2038:#define L_CODES (LITERALS+1+LENGTH_CODES)
        -: 2039:/* number of Literal or Length codes, including the END_BLOCK code */
        -: 2040:
        -: 2041:#define D_CODES   30
        -: 2042:/* number of distance codes */
        -: 2043:
        -: 2044:#define BL_CODES  19
        -: 2045:/* number of codes used to transfer the bit lengths */
        -: 2046:
        -: 2047:
        -: 2048:local int near extra_lbits[LENGTH_CODES] /* extra bits for each length code */
        -: 2049:   = {0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0};
        -: 2050:
        -: 2051:local int near extra_dbits[D_CODES] /* extra bits for each distance code */
        -: 2052:   = {0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};
        -: 2053:
        -: 2054:local int near extra_blbits[BL_CODES]/* extra bits for each bit length code */
        -: 2055:   = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7};
        -: 2056:
        -: 2057:#define STORED_BLOCK 0
        -: 2058:#define STATIC_TREES 1
        -: 2059:#define DYN_TREES    2
        -: 2060:/* The three kinds of block type */
        -: 2061:
        -: 2062:#ifndef LIT_BUFSIZE
        -: 2063:#  ifdef SMALL_MEM
        -: 2064:#    define LIT_BUFSIZE  0x2000
        -: 2065:#  else
        -: 2066:#  ifdef MEDIUM_MEM
        -: 2067:#    define LIT_BUFSIZE  0x4000
        -: 2068:#  else
        -: 2069:#    define LIT_BUFSIZE  0x8000
        -: 2070:#  endif
        -: 2071:#  endif
        -: 2072:#endif
        -: 2073:#ifndef DIST_BUFSIZE
        -: 2074:#  define DIST_BUFSIZE  LIT_BUFSIZE
        -: 2075:#endif
        -: 2076:/* Sizes of match buffers for literals/lengths and distances.  There are
        -: 2077: * 4 reasons for limiting LIT_BUFSIZE to 64K:
        -: 2078: *   - frequencies can be kept in 16 bit counters
        -: 2079: *   - if compression is not successful for the first block, all input data is
        -: 2080: *     still in the window so we can still emit a stored block even when input
        -: 2081: *     comes from standard input.  (This can also be done for all blocks if
        -: 2082: *     LIT_BUFSIZE is not greater than 32K.)
        -: 2083: *   - if compression is not successful for a file smaller than 64K, we can
        -: 2084: *     even emit a stored file instead of a stored block (saving 5 bytes).
        -: 2085: *   - creating new Huffman trees less frequently may not provide fast
        -: 2086: *     adaptation to changes in the input data statistics. (Take for
        -: 2087: *     example a binary file with poorly compressible code followed by
        -: 2088: *     a highly compressible string table.) Smaller buffer sizes give
        -: 2089: *     fast adaptation but have of course the overhead of transmitting trees
        -: 2090: *     more frequently.
        -: 2091: *   - I can't count above 4
        -: 2092: * The current code is general and allows DIST_BUFSIZE < LIT_BUFSIZE (to save
        -: 2093: * memory at the expense of compression). Some optimizations would be possible
        -: 2094: * if we rely on DIST_BUFSIZE == LIT_BUFSIZE.
        -: 2095: */
        -: 2096:#if LIT_BUFSIZE > INBUFSIZ
        -: 2097:    error cannot overlay l_buf and inbuf
        -: 2098:#endif
        -: 2099:
        -: 2100:#define REP_3_6      16
        -: 2101:/* repeat previous bit length 3-6 times (2 bits of repeat count) */
        -: 2102:
        -: 2103:#define REPZ_3_10    17
        -: 2104:/* repeat a zero length 3-10 times  (3 bits of repeat count) */
        -: 2105:
        -: 2106:#define REPZ_11_138  18
        -: 2107:/* repeat a zero length 11-138 times  (7 bits of repeat count) */
        -: 2108:
        -: 2109:/* ===========================================================================
        -: 2110: * Local data
        -: 2111: */
        -: 2112:
        -: 2113:/* Data structure describing a single value and its code string. */
        -: 2114:typedef struct ct_data {
        -: 2115:    union {
        -: 2116:        ush  freq;       /* frequency count */
        -: 2117:        ush  code;       /* bit string */
        -: 2118:    } fc;
        -: 2119:    union {
        -: 2120:        ush  dad;        /* father node in Huffman tree */
        -: 2121:        ush  len;        /* length of bit string */
        -: 2122:    } dl;
        -: 2123:} ct_data;
        -: 2124:
        -: 2125:#define Freq fc.freq
        -: 2126:#define Code fc.code
        -: 2127:#define Dad  dl.dad
        -: 2128:#define Len  dl.len
        -: 2129:
        -: 2130:#define HEAP_SIZE (2*L_CODES+1)
        -: 2131:/* maximum heap size */
        -: 2132:
        -: 2133:local ct_data near dyn_ltree[HEAP_SIZE];   /* literal and length tree */
        -: 2134:local ct_data near dyn_dtree[2*D_CODES+1]; /* distance tree */
        -: 2135:
        -: 2136:local ct_data near static_ltree[L_CODES+2];
        -: 2137:/* The static literal tree. Since the bit lengths are imposed, there is no
        -: 2138: * need for the L_CODES extra codes used during heap construction. However
        -: 2139: * The codes 286 and 287 are needed to build a canonical tree (see ct_init
        -: 2140: * below).
        -: 2141: */
        -: 2142:
        -: 2143:local ct_data near static_dtree[D_CODES];
        -: 2144:/* The static distance tree. (Actually a trivial tree since all codes use
        -: 2145: * 5 bits.)
        -: 2146: */
        -: 2147:
        -: 2148:local ct_data near bl_tree[2*BL_CODES+1];
        -: 2149:/* Huffman tree for the bit lengths */
        -: 2150:
        -: 2151:typedef struct tree_desc {
        -: 2152:    ct_data near *dyn_tree;      /* the dynamic tree */
        -: 2153:    ct_data near *static_tree;   /* corresponding static tree or NULL */
        -: 2154:    int     near *extra_bits;    /* extra bits for each code or NULL */
        -: 2155:    int     extra_base;          /* base index for extra_bits */
        -: 2156:    int     elems;               /* max number of elements in the tree */
        -: 2157:    int     max_length;          /* max bit length for the codes */
        -: 2158:    int     max_code;            /* largest code with non zero frequency */
        -: 2159:} tree_desc;
        -: 2160:
        -: 2161:local tree_desc near l_desc =
        -: 2162:{dyn_ltree, static_ltree, extra_lbits, LITERALS+1, L_CODES, MAX_BITS, 0};
        -: 2163:
        -: 2164:local tree_desc near d_desc =
        -: 2165:{dyn_dtree, static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS, 0};
        -: 2166:
        -: 2167:local tree_desc near bl_desc =
        -: 2168:{bl_tree, (ct_data near *)0, extra_blbits, 0,      BL_CODES, MAX_BL_BITS, 0};
        -: 2169:
        -: 2170:
        -: 2171:local ush near bl_count[MAX_BITS+1];
        -: 2172:/* number of codes at each bit length for an optimal tree */
        -: 2173:
        -: 2174:local uch near bl_order[BL_CODES]
        -: 2175:   = {16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15};
        -: 2176:/* The lengths of the bit length codes are sent in order of decreasing
        -: 2177: * probability, to avoid transmitting the lengths for unused bit length codes.
        -: 2178: */
        -: 2179:
        -: 2180:local int near heap[2*L_CODES+1]; /* heap used to build the Huffman trees */
        -: 2181:local int heap_len;               /* number of elements in the heap */
        -: 2182:local int heap_max;               /* element of largest frequency */
        -: 2183:/* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
        -: 2184: * The same heap array is used to build all trees.
        -: 2185: */
        -: 2186:
        -: 2187:local uch near depth[2*L_CODES+1];
        -: 2188:/* Depth of each subtree used as tie breaker for trees of equal frequency */
        -: 2189:
        -: 2190:local uch length_code[MAX_MATCH-MIN_MATCH+1];
        -: 2191:/* length code for each normalized match length (0 == MIN_MATCH) */
        -: 2192:
        -: 2193:local uch dist_code[512];
        -: 2194:/* distance codes. The first 256 values correspond to the distances
        -: 2195: * 3 .. 258, the last 256 values correspond to the top 8 bits of
        -: 2196: * the 15 bit distances.
        -: 2197: */
        -: 2198:
        -: 2199:local int near base_length[LENGTH_CODES];
        -: 2200:/* First normalized length for each code (0 = MIN_MATCH) */
        -: 2201:
        -: 2202:local int near base_dist[D_CODES];
        -: 2203:/* First normalized distance for each code (0 = distance of 1) */
        -: 2204:
        -: 2205:#define l_buf inbuf
        -: 2206:/* DECLARE(uch, l_buf, LIT_BUFSIZE);  buffer for literals or lengths */
        -: 2207:
        -: 2208:/* DECLARE(ush, d_buf, DIST_BUFSIZE); buffer for distances */
        -: 2209:
        -: 2210:local uch near flag_buf[(LIT_BUFSIZE/8)];
        -: 2211:/* flag_buf is a bit array distinguishing literals from lengths in
        -: 2212: * l_buf, thus indicating the presence or absence of a distance.
        -: 2213: */
        -: 2214:
        -: 2215:local unsigned last_lit;    /* running index in l_buf */
        -: 2216:local unsigned last_dist;   /* running index in d_buf */
        -: 2217:local unsigned last_flags;  /* running index in flag_buf */
        -: 2218:local uch flags;            /* current flags not yet saved in flag_buf */
        -: 2219:local uch flag_bit;         /* current bit used in flags */
        -: 2220:/* bits are filled in flags starting at bit 0 (least significant).
        -: 2221: * Note: these flags are overkill in the current code since we don't
        -: 2222: * take advantage of DIST_BUFSIZE == LIT_BUFSIZE.
        -: 2223: */
        -: 2224:
        -: 2225:local ulg opt_len;        /* bit length of current block with optimal trees */
        -: 2226:local ulg static_len;     /* bit length of current block with static trees */
        -: 2227:
        -: 2228:local ulg compressed_len; /* total bit length of compressed file */
        -: 2229:
        -: 2230:local ulg input_len;      /* total byte length of input file */
        -: 2231:/* input_len is for debugging only since we can get it by other means. */
        -: 2232:
        -: 2233:ush *file_type;        /* pointer to UNKNOWN, BINARY or ASCII */
        -: 2234:int *file_method;      /* pointer to DEFLATE or STORE */
        -: 2235:
        -: 2236:#ifdef DEBUG
        -: 2237:extern ulg bits_sent;  /* bit length of the compressed data */
        -: 2238:extern long isize;     /* byte length of input file */
        -: 2239:#endif
        -: 2240:
        -: 2241:extern long block_start;       /* window offset of current block */
        -: 2242:extern unsigned near strstart; /* window offset of current string */
        -: 2243:
        -: 2244:/* ===========================================================================
        -: 2245: * Local (static) routines in this file.
        -: 2246: */
        -: 2247:
        -: 2248:local void init_block     OF((void));
        -: 2249:local void pqdownheap     OF((ct_data near *tree, int k));
        -: 2250:local void gen_bitlen     OF((tree_desc near *desc));
        -: 2251:local void gen_codes      OF((ct_data near *tree, int max_code));
        -: 2252:local void build_tree     OF((tree_desc near *desc));
        -: 2253:local void scan_tree      OF((ct_data near *tree, int max_code));
        -: 2254:local void send_tree      OF((ct_data near *tree, int max_code));
        -: 2255:local int  build_bl_tree  OF((void));
        -: 2256:local void send_all_trees OF((int lcodes, int dcodes, int blcodes));
        -: 2257:local void compress_block OF((ct_data near *ltree, ct_data near *dtree));
        -: 2258:local void set_file_type  OF((void));
        -: 2259:
        -: 2260:
        -: 2261:#ifndef DEBUG
        -: 2262:#  define send_code(c, tree) send_bits(tree[c].Code, tree[c].Len)
        -: 2263:   /* Send a code of the given tree. c and tree must not have side effects */
        -: 2264:
        -: 2265:#else /* DEBUG */
        -: 2266:#  define send_code(c, tree) \
        -: 2267:     { if (verbose>1) fprintf(stderr,"\ncd %3d ",(c)); \
        -: 2268:       send_bits(tree[c].Code, tree[c].Len); }
        -: 2269:#endif
        -: 2270:
        -: 2271:#define d_code(dist) \
        -: 2272:   ((dist) < 256 ? dist_code[dist] : dist_code[256+((dist)>>7)])
        -: 2273:/* Mapping from a distance to a distance code. dist is the distance - 1 and
        -: 2274: * must not have side effects. dist_code[256] and dist_code[257] are never
        -: 2275: * used.
        -: 2276: */
        -: 2277:
        -: 2278:#define MAX(a,b) (a >= b ? a : b)
        -: 2279:/* the arguments must not have side effects */
        -: 2280:
        -: 2281:/* ===========================================================================
        -: 2282: * Allocate the match buffer, initialize the various tables and save the
        -: 2283: * location of the internal file attribute (ascii/binary) and method
        -: 2284: * (DEFLATE/STORE).
        -: 2285: */
function ct_init called 175 returned 100% blocks executed 98%
      175: 2286:void ct_init(attr, methodp)
        -: 2287:    ush  *attr;   /* pointer to internal file attribute */
        -: 2288:    int  *methodp; /* pointer to compression method */
        -: 2289:{
        -: 2290:    int n;        /* iterates over tree elements */
        -: 2291:    int bits;     /* bit counter */
        -: 2292:    int length;   /* length value */
        -: 2293:    int code;     /* code value */
        -: 2294:    int dist;     /* distance index */
        -: 2295:
      175: 2296:    file_type = attr;
      175: 2297:    file_method = methodp;
      175: 2298:    compressed_len = input_len = 0L;
        -: 2299:        
     175*: 2300:    if (static_dtree[0].Len != 0) return; /* ct_init already called */
branch  0 taken 0 (fallthrough)
branch  1 taken 175
        -: 2301:
        -: 2302:    /* Initialize the mapping length (0..255) -> length code (0..28) */
      175: 2303:    length = 0;
     5075: 2304:    for (code = 0; code < LENGTH_CODES-1; code++) {
branch  0 taken 4900
branch  1 taken 175 (fallthrough)
     4900: 2305:        base_length[code] = length;
    49700: 2306:        for (n = 0; n < (1<<extra_lbits[code]); n++) {
branch  0 taken 44800
branch  1 taken 4900 (fallthrough)
    44800: 2307:            length_code[length++] = (uch)code;
        -: 2308:        }
        -: 2309:    }
        -: 2310:    Assert (length == 256, "ct_init: length != 256");
        -: 2311:    /* Note that the length 255 (match length 258) can be represented
        -: 2312:     * in two different ways: code 284 + 5 bits or code 285, so we
        -: 2313:     * overwrite length_code[255] to use the best encoding:
        -: 2314:     */
      175: 2315:    length_code[length-1] = (uch)code;
        -: 2316:
        -: 2317:    /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
      175: 2318:    dist = 0;
     2975: 2319:    for (code = 0 ; code < 16; code++) {
branch  0 taken 2800
branch  1 taken 175 (fallthrough)
     2800: 2320:        base_dist[code] = dist;
    47600: 2321:        for (n = 0; n < (1<<extra_dbits[code]); n++) {
branch  0 taken 44800
branch  1 taken 2800 (fallthrough)
    44800: 2322:            dist_code[dist++] = (uch)code;
        -: 2323:        }
        -: 2324:    }
        -: 2325:    Assert (dist == 256, "ct_init: dist != 256");
      175: 2326:    dist >>= 7; /* from now on, all distances are divided by 128 */
     2625: 2327:    for ( ; code < D_CODES; code++) {
branch  0 taken 2450
branch  1 taken 175 (fallthrough)
     2450: 2328:        base_dist[code] = dist << 7;
    46900: 2329:        for (n = 0; n < (1<<(extra_dbits[code]-7)); n++) {
branch  0 taken 44450
branch  1 taken 2450 (fallthrough)
    44450: 2330:            dist_code[256 + dist++] = (uch)code;
        -: 2331:        }
        -: 2332:    }
        -: 2333:    Assert (dist == 256, "ct_init: 256+dist != 512");
        -: 2334:
        -: 2335:    /* Construct the codes of the static literal tree */
     2975: 2336:    for (bits = 0; bits <= MAX_BITS; bits++) bl_count[bits] = 0;
branch  0 taken 2800
branch  1 taken 175 (fallthrough)
      175: 2337:    n = 0;
    25375: 2338:    while (n <= 143) static_ltree[n++].Len = 8, bl_count[8]++;
branch  0 taken 25200
branch  1 taken 175 (fallthrough)
    19775: 2339:    while (n <= 255) static_ltree[n++].Len = 9, bl_count[9]++;
branch  0 taken 19600
branch  1 taken 175 (fallthrough)
     4375: 2340:    while (n <= 279) static_ltree[n++].Len = 7, bl_count[7]++;
branch  0 taken 4200
branch  1 taken 175 (fallthrough)
     1575: 2341:    while (n <= 287) static_ltree[n++].Len = 8, bl_count[8]++;
branch  0 taken 1400
branch  1 taken 175 (fallthrough)
        -: 2342:    /* Codes 286 and 287 do not exist, but we must include them in the
        -: 2343:     * tree construction to get a canonical Huffman tree (longest code
        -: 2344:     * all ones)
        -: 2345:     */
      175: 2346:    gen_codes((ct_data near *)static_ltree, L_CODES+1);
call    0 returned 175
        -: 2347:
        -: 2348:    /* The static distance tree is trivial: */
     5425: 2349:    for (n = 0; n < D_CODES; n++) {
branch  0 taken 5250
branch  1 taken 175 (fallthrough)
     5250: 2350:        static_dtree[n].Len = 5;
     5250: 2351:        static_dtree[n].Code = bi_reverse(n, 5);
call    0 returned 5250
        -: 2352:    }
        -: 2353:
        -: 2354:    /* Initialize the first block of the first file: */
      175: 2355:    init_block();
call    0 returned 175
        -: 2356:}
        -: 2357:
        -: 2358:/* ===========================================================================
        -: 2359: * Initialize a new block.
        -: 2360: */
function init_block called 370 returned 100% blocks executed 100%
      370: 2361:local void init_block()
        -: 2362:{
        -: 2363:    int n; /* iterates over tree elements */
        -: 2364:
        -: 2365:    /* Initialize the trees. */
   106190: 2366:    for (n = 0; n < L_CODES;  n++) dyn_ltree[n].Freq = 0;
branch  0 taken 105820
branch  1 taken 370 (fallthrough)
    11470: 2367:    for (n = 0; n < D_CODES;  n++) dyn_dtree[n].Freq = 0;
branch  0 taken 11100
branch  1 taken 370 (fallthrough)
     7400: 2368:    for (n = 0; n < BL_CODES; n++) bl_tree[n].Freq = 0;
branch  0 taken 7030
branch  1 taken 370 (fallthrough)
        -: 2369:
      370: 2370:    dyn_ltree[END_BLOCK].Freq = 1;
      370: 2371:    opt_len = static_len = 0L;
      370: 2372:    last_lit = last_dist = last_flags = 0;
      370: 2373:    flags = 0; flag_bit = 1;
      370: 2374:}
        -: 2375:
        -: 2376:#define SMALLEST 1
        -: 2377:/* Index within the heap array of least frequent node in the Huffman tree */
        -: 2378:
        -: 2379:
        -: 2380:/* ===========================================================================
        -: 2381: * Remove the smallest element from the heap and recreate the heap with
        -: 2382: * one less element. Updates heap and heap_len.
        -: 2383: */
        -: 2384:#define pqremove(tree, top) \
        -: 2385:{\
        -: 2386:    top = heap[SMALLEST]; \
        -: 2387:    heap[SMALLEST] = heap[heap_len--]; \
        -: 2388:    pqdownheap(tree, SMALLEST); \
        -: 2389:}
        -: 2390:
        -: 2391:/* ===========================================================================
        -: 2392: * Compares to subtrees, using the tree depth as tie breaker when
        -: 2393: * the subtrees have equal frequency. This minimizes the worst case length.
        -: 2394: */
        -: 2395:#define smaller(tree, n, m) \
        -: 2396:   (tree[n].Freq < tree[m].Freq || \
        -: 2397:   (tree[n].Freq == tree[m].Freq && depth[n] <= depth[m]))
        -: 2398:
        -: 2399:/* ===========================================================================
        -: 2400: * Restore the heap property by moving down the tree starting at node k,
        -: 2401: * exchanging a node with the smallest of its two sons if necessary, stopping
        -: 2402: * when the heap property is re-established (each father smaller than its
        -: 2403: * two sons).
        -: 2404: */
function pqdownheap called 72081 returned 100% blocks executed 100%
    72081: 2405:local void pqdownheap(tree, k)
        -: 2406:    ct_data near *tree;  /* the tree to restore */
        -: 2407:    int k;               /* node to move down */
        -: 2408:{
    72081: 2409:    int v = heap[k];
    72081: 2410:    int j = k << 1;  /* left son of k */
   296478: 2411:    while (j <= heap_len) {
branch  0 taken 249172
branch  1 taken 47306 (fallthrough)
        -: 2412:        /* Set j to the smallest of the two sons: */
   249172: 2413:        if (j < heap_len && smaller(tree, heap[j+1], heap[j])) j++;
branch  0 taken 243793 (fallthrough)
branch  1 taken 5379
branch  2 taken 147421 (fallthrough)
branch  3 taken 96372
branch  4 taken 34050 (fallthrough)
branch  5 taken 113371
branch  6 taken 23762 (fallthrough)
branch  7 taken 10288
        -: 2414:
        -: 2415:        /* Exit if v is smaller than both sons */
   249172: 2416:        if (smaller(tree, v, heap[j])) break;
branch  0 taken 226452 (fallthrough)
branch  1 taken 22720
branch  2 taken 5113 (fallthrough)
branch  3 taken 221339
branch  4 taken 3058 (fallthrough)
branch  5 taken 2055
        -: 2417:
        -: 2418:        /* Exchange v with the smallest son */
   224397: 2419:        heap[k] = heap[j];  k = j;
        -: 2420:
        -: 2421:        /* And continue down the tree, setting j to the left son of k */
   224397: 2422:        j <<= 1;
        -: 2423:    }
    72081: 2424:    heap[k] = v;
    72081: 2425:}
        -: 2426:
        -: 2427:/* ===========================================================================
        -: 2428: * Compute the optimal bit lengths for a tree and update the total bit length
        -: 2429: * for the current block.
        -: 2430: * IN assertion: the fields freq and dad are set, heap[heap_max] and
        -: 2431: *    above are the tree nodes sorted by increasing frequency.
        -: 2432: * OUT assertions: the field len is set to the optimal bit length, the
        -: 2433: *     array bl_count contains the frequencies for each bit length.
        -: 2434: *     The length opt_len is updated; static_len is also updated if stree is
        -: 2435: *     not null.
        -: 2436: */
function gen_bitlen called 585 returned 100% blocks executed 97%
      585: 2437:local void gen_bitlen(desc)
        -: 2438:    tree_desc near *desc; /* the tree descriptor */
        -: 2439:{
      585: 2440:    ct_data near *tree  = desc->dyn_tree;
      585: 2441:    int near *extra     = desc->extra_bits;
      585: 2442:    int base            = desc->extra_base;
      585: 2443:    int max_code        = desc->max_code;
      585: 2444:    int max_length      = desc->max_length;
      585: 2445:    ct_data near *stree = desc->static_tree;
        -: 2446:    int h;              /* heap index */
        -: 2447:    int n, m;           /* iterate over the tree elements */
        -: 2448:    int bits;           /* bit length */
        -: 2449:    int xbits;          /* extra bits */
        -: 2450:    ush f;              /* frequency */
      585: 2451:    int overflow = 0;   /* number of elements with bit length too large */
        -: 2452:
     9945: 2453:    for (bits = 0; bits <= MAX_BITS; bits++) bl_count[bits] = 0;
branch  0 taken 9360
branch  1 taken 585 (fallthrough)
        -: 2454:
        -: 2455:    /* In a first pass, compute the optimal bit lengths (which may
        -: 2456:     * overflow in the case of the bit length tree).
        -: 2457:     */
      585: 2458:    tree[heap[heap_max]].Len = 0; /* root of the heap */
        -: 2459:
    58137: 2460:    for (h = heap_max+1; h < HEAP_SIZE; h++) {
branch  0 taken 57552
branch  1 taken 585 (fallthrough)
    57552: 2461:        n = heap[h];
    57552: 2462:        bits = tree[tree[n].Dad].Len + 1;
    57552: 2463:        if (bits > max_length) bits = max_length, overflow++;
branch  0 taken 6 (fallthrough)
branch  1 taken 57546
    57552: 2464:        tree[n].Len = (ush)bits;
        -: 2465:        /* We overwrite tree[n].Dad which is no longer needed */
        -: 2466:
    57552: 2467:        if (n > max_code) continue; /* not a leaf node */
branch  0 taken 28191 (fallthrough)
branch  1 taken 29361
        -: 2468:
    29361: 2469:        bl_count[bits]++;
    29361: 2470:        xbits = 0;
    29361: 2471:        if (n >= base) xbits = extra[n-base];
branch  0 taken 11494 (fallthrough)
branch  1 taken 17867
    29361: 2472:        f = tree[n].Freq;
    29361: 2473:        opt_len += (ulg)f * (bits + xbits);
    29361: 2474:        if (stree) static_len += (ulg)f * (stree[n].Len + xbits);
branch  0 taken 26697 (fallthrough)
branch  1 taken 2664
        -: 2475:    }
      585: 2476:    if (overflow == 0) return;
branch  0 taken 582 (fallthrough)
branch  1 taken 3
        -: 2477:
        -: 2478:    Trace((stderr,"\nbit length overflow\n"));
        -: 2479:    /* This happens for example on obj2 and pic of the Calgary corpus */
        -: 2480:
        -: 2481:    /* Find the first bit length which could increase: */
        -: 2482:    do {
        3: 2483:        bits = max_length-1;
       3*: 2484:        while (bl_count[bits] == 0) bits--;
branch  0 taken 0
branch  1 taken 3 (fallthrough)
        3: 2485:        bl_count[bits]--;      /* move one leaf down the tree */
        3: 2486:        bl_count[bits+1] += 2; /* move one overflow item as its brother */
        3: 2487:        bl_count[max_length]--;
        -: 2488:        /* The brother of the overflow item also moves one step up,
        -: 2489:         * but this does not affect bl_count[max_length]
        -: 2490:         */
        3: 2491:        overflow -= 2;
        3: 2492:    } while (overflow > 0);
branch  0 taken 0
branch  1 taken 3 (fallthrough)
        -: 2493:
        -: 2494:    /* Now recompute all bit lengths, scanning in increasing frequency.
        -: 2495:     * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
        -: 2496:     * lengths instead of fixing only the wrong ones. This idea is taken
        -: 2497:     * from 'ar' written by Haruhiko Okumura.)
        -: 2498:     */
       24: 2499:    for (bits = max_length; bits != 0; bits--) {
branch  0 taken 21
branch  1 taken 3 (fallthrough)
       21: 2500:        n = bl_count[bits];
       84: 2501:        while (n != 0) {
branch  0 taken 63
branch  1 taken 21 (fallthrough)
       63: 2502:            m = heap[--h];
       63: 2503:            if (m > max_code) continue;
branch  0 taken 24 (fallthrough)
branch  1 taken 39
       39: 2504:            if (tree[m].Len != (unsigned) bits) {
branch  0 taken 3 (fallthrough)
branch  1 taken 36
        -: 2505:                Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
        3: 2506:                opt_len += ((long)bits-(long)tree[m].Len)*(long)tree[m].Freq;
        3: 2507:                tree[m].Len = (ush)bits;
        -: 2508:            }
       39: 2509:            n--;
        -: 2510:        }
        -: 2511:    }
        -: 2512:}
        -: 2513:
        -: 2514:/* ===========================================================================
        -: 2515: * Generate the codes for a given tree and bit counts (which need not be
        -: 2516: * optimal).
        -: 2517: * IN assertion: the array bl_count contains the bit length statistics for
        -: 2518: * the given tree and the field len is set for all tree elements.
        -: 2519: * OUT assertion: the field code is set for all tree elements of non
        -: 2520: *     zero code length.
        -: 2521: */
function gen_codes called 760 returned 100% blocks executed 100%
      760: 2522:local void gen_codes (tree, max_code)
        -: 2523:    ct_data near *tree;        /* the tree to decorate */
        -: 2524:    int max_code;              /* largest code with non zero frequency */
        -: 2525:{
        -: 2526:    ush next_code[MAX_BITS+1]; /* next code value for each bit length */
      760: 2527:    ush code = 0;              /* running code value */
        -: 2528:    int bits;                  /* bit index */
        -: 2529:    int n;                     /* code index */
        -: 2530:
        -: 2531:    /* The distribution counts are first used to generate the code values
        -: 2532:     * without bit reversal.
        -: 2533:     */
    12160: 2534:    for (bits = 1; bits <= MAX_BITS; bits++) {
branch  0 taken 11400
branch  1 taken 760 (fallthrough)
    11400: 2535:        next_code[bits] = code = (code + bl_count[bits-1]) << 1;
        -: 2536:    }
        -: 2537:    /* Check that the bit counts in bl_count are consistent. The last code
        -: 2538:     * must be all ones.
        -: 2539:     */
        -: 2540:    Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
        -: 2541:            "inconsistent bit counts");
        -: 2542:    Tracev((stderr,"\ngen_codes: max_code %d ", max_code));
        -: 2543:
   115890: 2544:    for (n = 0;  n <= max_code; n++) {
branch  0 taken 115130
branch  1 taken 760 (fallthrough)
   115130: 2545:        int len = tree[n].Len;
   115130: 2546:        if (len == 0) continue;
branch  0 taken 35369 (fallthrough)
branch  1 taken 79761
        -: 2547:        /* Now reverse the bits */
    79761: 2548:        tree[n].Code = bi_reverse(next_code[len]++, len);
call    0 returned 79761
        -: 2549:
        -: 2550:        Tracec(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
        -: 2551:             n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
        -: 2552:    }
      760: 2553:}
        -: 2554:
        -: 2555:/* ===========================================================================
        -: 2556: * Construct one Huffman tree and assigns the code bit strings and lengths.
        -: 2557: * Update the total bit length for the current block.
        -: 2558: * IN assertion: the field freq is set for all tree elements.
        -: 2559: * OUT assertions: the fields len and code are set to the optimal bit length
        -: 2560: *     and corresponding code. The length opt_len is updated; static_len is
        -: 2561: *     also updated if stree is not null. The field max_code is set.
        -: 2562: */
function build_tree called 585 returned 100% blocks executed 100%
      585: 2563:local void build_tree(desc)
        -: 2564:    tree_desc near *desc; /* the tree descriptor */
        -: 2565:{
      585: 2566:    ct_data near *tree   = desc->dyn_tree;
      585: 2567:    ct_data near *stree  = desc->static_tree;
      585: 2568:    int elems            = desc->elems;
        -: 2569:    int n, m;          /* iterate over heap elements */
      585: 2570:    int max_code = -1; /* largest code with non zero frequency */
      585: 2571:    int node = elems;  /* next internal node of the tree */
        -: 2572:
        -: 2573:    /* Construct the initial heap, with least frequent element in
        -: 2574:     * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
        -: 2575:     * heap[0] is not used.
        -: 2576:     */
      585: 2577:    heap_len = 0, heap_max = HEAP_SIZE;
        -: 2578:
    65910: 2579:    for (n = 0; n < elems; n++) {
branch  0 taken 65325
branch  1 taken 585 (fallthrough)
    65325: 2580:        if (tree[n].Freq != 0) {
branch  0 taken 29341 (fallthrough)
branch  1 taken 35984
    29341: 2581:            heap[++heap_len] = max_code = n;
    29341: 2582:            depth[n] = 0;
        -: 2583:        } else {
    35984: 2584:            tree[n].Len = 0;
        -: 2585:        }
        -: 2586:    }
        -: 2587:
        -: 2588:    /* The pkzip format requires that at least one distance code exists,
        -: 2589:     * and that at least one bit should be sent even if there is only one
        -: 2590:     * possible code. So to avoid special checks later on we force at least
        -: 2591:     * two codes of non zero frequency.
        -: 2592:     */
      605: 2593:    while (heap_len < 2) {
branch  0 taken 20
branch  1 taken 585 (fallthrough)
       20: 2594:        int new = heap[++heap_len] = (max_code < 2 ? ++max_code : 0);
branch  0 taken 18 (fallthrough)
branch  1 taken 2
       20: 2595:        tree[new].Freq = 1;
       20: 2596:        depth[new] = 0;
       20: 2597:        opt_len--; if (stree) static_len -= stree[new].Len;
branch  0 taken 20 (fallthrough)
branch  1 taken 0
        -: 2598:        /* new is 0 or 1 so it does not have extra bits */
        -: 2599:    }
      585: 2600:    desc->max_code = max_code;
        -: 2601:
        -: 2602:    /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
        -: 2603:     * establish sub-heaps of increasing lengths:
        -: 2604:     */
    15114: 2605:    for (n = heap_len/2; n >= 1; n--) pqdownheap(tree, n);
call    0 returned 14529
branch  1 taken 14529
branch  2 taken 585 (fallthrough)
        -: 2606:
        -: 2607:    /* Construct the Huffman tree by repeatedly combining the least two
        -: 2608:     * frequent nodes.
        -: 2609:     */
        -: 2610:    do {
    28776: 2611:        pqremove(tree, n);   /* n = node of least frequency */
call    0 returned 28776
    28776: 2612:        m = heap[SMALLEST];  /* m = node of next least frequency */
        -: 2613:
    28776: 2614:        heap[--heap_max] = n; /* keep the nodes sorted by frequency */
    28776: 2615:        heap[--heap_max] = m;
        -: 2616:
        -: 2617:        /* Create a new node father of n and m */
    28776: 2618:        tree[node].Freq = tree[n].Freq + tree[m].Freq;
    28776: 2619:        depth[node] = (uch) (MAX(depth[n], depth[m]) + 1);
branch  0 taken 19163 (fallthrough)
branch  1 taken 9613
    28776: 2620:        tree[n].Dad = tree[m].Dad = (ush)node;
        -: 2621:#ifdef DUMP_BL_TREE
        -: 2622:        if (tree == bl_tree) {
        -: 2623:            fprintf(stderr,"\nnode %d(%d), sons %d(%d) %d(%d)",
        -: 2624:                    node, tree[node].Freq, n, tree[n].Freq, m, tree[m].Freq);
        -: 2625:        }
        -: 2626:#endif
        -: 2627:        /* and insert the new node in the heap */
    28776: 2628:        heap[SMALLEST] = node++;
    28776: 2629:        pqdownheap(tree, SMALLEST);
call    0 returned 28776
        -: 2630:
    28776: 2631:    } while (heap_len >= 2);
branch  0 taken 28191
branch  1 taken 585 (fallthrough)
        -: 2632:
      585: 2633:    heap[--heap_max] = heap[SMALLEST];
        -: 2634:
        -: 2635:    /* At this point, the fields freq and dad are set. We can now
        -: 2636:     * generate the bit lengths.
        -: 2637:     */
      585: 2638:    gen_bitlen((tree_desc near *)desc);
call    0 returned 585
        -: 2639:
        -: 2640:    /* The field len is now set, we can generate the bit codes */
      585: 2641:    gen_codes ((ct_data near *)tree, max_code);
call    0 returned 585
      585: 2642:}
        -: 2643:
        -: 2644:/* ===========================================================================
        -: 2645: * Scan a literal or distance tree to determine the frequencies of the codes
        -: 2646: * in the bit length tree. Updates opt_len to take into account the repeat
        -: 2647: * counts. (The contribution of the bit length codes will be added later
        -: 2648: * during the construction of bl_tree.)
        -: 2649: */
function scan_tree called 390 returned 100% blocks executed 100%
      390: 2650:local void scan_tree (tree, max_code)
        -: 2651:    ct_data near *tree; /* the tree to be scanned */
        -: 2652:    int max_code;       /* and its largest code of non zero frequency */
        -: 2653:{
        -: 2654:    int n;                     /* iterates over all tree elements */
      390: 2655:    int prevlen = -1;          /* last emitted length */
        -: 2656:    int curlen;                /* length of current code */
      390: 2657:    int nextlen = tree[0].Len; /* length of next code */
      390: 2658:    int count = 0;             /* repeat count of the current code */
      390: 2659:    int max_count = 7;         /* max repeat count */
      390: 2660:    int min_count = 4;         /* min repeat count */
        -: 2661:
      390: 2662:    if (nextlen == 0) max_count = 138, min_count = 3;
branch  0 taken 182 (fallthrough)
branch  1 taken 208
      390: 2663:    tree[max_code+1].Len = (ush)0xffff; /* guard */
        -: 2664:
    61428: 2665:    for (n = 0; n <= max_code; n++) {
branch  0 taken 61038
branch  1 taken 390 (fallthrough)
    61038: 2666:        curlen = nextlen; nextlen = tree[n+1].Len;
    61038: 2667:        if (++count < max_count && curlen == nextlen) {
branch  0 taken 60839 (fallthrough)
branch  1 taken 199
branch  2 taken 40395 (fallthrough)
branch  3 taken 20444
    40395: 2668:            continue;
    20643: 2669:        } else if (count < min_count) {
branch  0 taken 19011 (fallthrough)
branch  1 taken 1632
    19011: 2670:            bl_tree[curlen].Freq += count;
     1632: 2671:        } else if (curlen != 0) {
branch  0 taken 735 (fallthrough)
branch  1 taken 897
      735: 2672:            if (curlen != prevlen) bl_tree[curlen].Freq++;
branch  0 taken 646 (fallthrough)
branch  1 taken 89
      735: 2673:            bl_tree[REP_3_6].Freq++;
      897: 2674:        } else if (count <= 10) {
branch  0 taken 510 (fallthrough)
branch  1 taken 387
      510: 2675:            bl_tree[REPZ_3_10].Freq++;
        -: 2676:        } else {
      387: 2677:            bl_tree[REPZ_11_138].Freq++;
        -: 2678:        }
    20643: 2679:        count = 0; prevlen = curlen;
    20643: 2680:        if (nextlen == 0) {
branch  0 taken 2148 (fallthrough)
branch  1 taken 18495
     2148: 2681:            max_count = 138, min_count = 3;
    18495: 2682:        } else if (curlen == nextlen) {
branch  0 taken 179 (fallthrough)
branch  1 taken 18316
      179: 2683:            max_count = 6, min_count = 3;
        -: 2684:        } else {
    18316: 2685:            max_count = 7, min_count = 4;
        -: 2686:        }
        -: 2687:    }
      390: 2688:}
        -: 2689:
        -: 2690:/* ===========================================================================
        -: 2691: * Send a literal or distance tree in compressed form, using the codes in
        -: 2692: * bl_tree.
        -: 2693: */
function send_tree called 382 returned 100% blocks executed 100%
      382: 2694:local void send_tree (tree, max_code)
        -: 2695:    ct_data near *tree; /* the tree to be scanned */
        -: 2696:    int max_code;       /* and its largest code of non zero frequency */
        -: 2697:{
        -: 2698:    int n;                     /* iterates over all tree elements */
      382: 2699:    int prevlen = -1;          /* last emitted length */
        -: 2700:    int curlen;                /* length of current code */
      382: 2701:    int nextlen = tree[0].Len; /* length of next code */
      382: 2702:    int count = 0;             /* repeat count of the current code */
      382: 2703:    int max_count = 7;         /* max repeat count */
      382: 2704:    int min_count = 4;         /* min repeat count */
        -: 2705:
        -: 2706:    /* tree[max_code+1].Len = -1; */  /* guard already set */
      382: 2707:    if (nextlen == 0) max_count = 138, min_count = 3;
branch  0 taken 182 (fallthrough)
branch  1 taken 200
        -: 2708:
    60334: 2709:    for (n = 0; n <= max_code; n++) {
branch  0 taken 59952
branch  1 taken 382 (fallthrough)
    59952: 2710:        curlen = nextlen; nextlen = tree[n+1].Len;
    59952: 2711:        if (++count < max_count && curlen == nextlen) {
branch  0 taken 59791 (fallthrough)
branch  1 taken 161
branch  2 taken 39384 (fallthrough)
branch  3 taken 20407
    39384: 2712:            continue;
    20568: 2713:        } else if (count < min_count) {
branch  0 taken 18985 (fallthrough)
branch  1 taken 1583
    24547: 2714:            do { send_code(curlen, bl_tree); } while (--count != 0);
call    0 returned 24547
branch  1 taken 5562
branch  2 taken 18985
        -: 2715:
     1583: 2716:        } else if (curlen != 0) {
branch  0 taken 694 (fallthrough)
branch  1 taken 889
      694: 2717:            if (curlen != prevlen) {
branch  0 taken 638 (fallthrough)
branch  1 taken 56
      638: 2718:                send_code(curlen, bl_tree); count--;
call    0 returned 638
        -: 2719:            }
        -: 2720:            Assert(count >= 3 && count <= 6, " 3_6?");
      694: 2721:            send_code(REP_3_6, bl_tree); send_bits(count-3, 2);
call    0 returned 694
call    1 returned 694
        -: 2722:
      889: 2723:        } else if (count <= 10) {
branch  0 taken 510 (fallthrough)
branch  1 taken 379
      510: 2724:            send_code(REPZ_3_10, bl_tree); send_bits(count-3, 3);
call    0 returned 510
call    1 returned 510
        -: 2725:
        -: 2726:        } else {
      379: 2727:            send_code(REPZ_11_138, bl_tree); send_bits(count-11, 7);
call    0 returned 379
call    1 returned 379
        -: 2728:        }
    20568: 2729:        count = 0; prevlen = curlen;
    20568: 2730:        if (nextlen == 0) {
branch  0 taken 2140 (fallthrough)
branch  1 taken 18428
     2140: 2731:            max_count = 138, min_count = 3;
    18428: 2732:        } else if (curlen == nextlen) {
branch  0 taken 145 (fallthrough)
branch  1 taken 18283
      145: 2733:            max_count = 6, min_count = 3;
        -: 2734:        } else {
    18283: 2735:            max_count = 7, min_count = 4;
        -: 2736:        }
        -: 2737:    }
      382: 2738:}
        -: 2739:
        -: 2740:/* ===========================================================================
        -: 2741: * Construct the Huffman tree for the bit lengths and return the index in
        -: 2742: * bl_order of the last bit length code to send.
        -: 2743: */
function build_bl_tree called 195 returned 100% blocks executed 100%
      195: 2744:local int build_bl_tree()
        -: 2745:{
        -: 2746:    int max_blindex;  /* index of last bit length code of non zero freq */
        -: 2747:
        -: 2748:    /* Determine the bit length frequencies for literal and distance trees */
      195: 2749:    scan_tree((ct_data near *)dyn_ltree, l_desc.max_code);
call    0 returned 195
      195: 2750:    scan_tree((ct_data near *)dyn_dtree, d_desc.max_code);
call    0 returned 195
        -: 2751:
        -: 2752:    /* Build the bit length tree: */
      195: 2753:    build_tree((tree_desc near *)(&bl_desc));
call    0 returned 195
        -: 2754:    /* opt_len now includes the length of the tree representations, except
        -: 2755:     * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
        -: 2756:     */
        -: 2757:
        -: 2758:    /* Determine the number of bit length codes to send. The pkzip format
        -: 2759:     * requires that at least 4 bit length codes be sent. (appnote.txt says
        -: 2760:     * 3 but the actual value used is 4.)
        -: 2761:     */
      906: 2762:    for (max_blindex = BL_CODES-1; max_blindex >= 3; max_blindex--) {
branch  0 taken 906
branch  1 taken 0 (fallthrough)
      906: 2763:        if (bl_tree[bl_order[max_blindex]].Len != 0) break;
branch  0 taken 195 (fallthrough)
branch  1 taken 711
        -: 2764:    }
        -: 2765:    /* Update opt_len to include the bit length tree and counts */
      195: 2766:    opt_len += 3*(max_blindex+1) + 5+5+4;
        -: 2767:    Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld", opt_len, static_len));
        -: 2768:
      195: 2769:    return max_blindex;
        -: 2770:}
        -: 2771:
        -: 2772:/* ===========================================================================
        -: 2773: * Send the header for a block using dynamic Huffman trees: the counts, the
        -: 2774: * lengths of the bit length codes, the literal tree and the distance tree.
        -: 2775: * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
        -: 2776: */
function send_all_trees called 191 returned 100% blocks executed 100%
      191: 2777:local void send_all_trees(lcodes, dcodes, blcodes)
        -: 2778:    int lcodes, dcodes, blcodes; /* number of codes for each tree */
        -: 2779:{
        -: 2780:    int rank;                    /* index in bl_order */
        -: 2781:
        -: 2782:    Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
        -: 2783:    Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
        -: 2784:            "too many codes");
        -: 2785:    Tracev((stderr, "\nbl counts: "));
      191: 2786:    send_bits(lcodes-257, 5); /* not +255 as stated in appnote.txt */
call    0 returned 191
      191: 2787:    send_bits(dcodes-1,   5);
call    0 returned 191
      191: 2788:    send_bits(blcodes-4,  4); /* not -3 as stated in appnote.txt */
call    0 returned 191
     3113: 2789:    for (rank = 0; rank < blcodes; rank++) {
branch  0 taken 2922
branch  1 taken 191 (fallthrough)
        -: 2790:        Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
     2922: 2791:        send_bits(bl_tree[bl_order[rank]].Len, 3);
call    0 returned 2922
        -: 2792:    }
        -: 2793:    Tracev((stderr, "\nbl tree: sent %ld", bits_sent));
        -: 2794:
      191: 2795:    send_tree((ct_data near *)dyn_ltree, lcodes-1); /* send the literal tree */
call    0 returned 191
        -: 2796:    Tracev((stderr, "\nlit tree: sent %ld", bits_sent));
        -: 2797:
      191: 2798:    send_tree((ct_data near *)dyn_dtree, dcodes-1); /* send the distance tree */
call    0 returned 191
        -: 2799:    Tracev((stderr, "\ndist tree: sent %ld", bits_sent));
      191: 2800:}
        -: 2801:
        -: 2802:/* ===========================================================================
        -: 2803: * Determine the best encoding for the current block: dynamic trees, static
        -: 2804: * trees or store, and output the encoded block to the zip file. This function
        -: 2805: * returns the total compressed length for the file so far.
        -: 2806: */
function flush_block called 195 returned 100% blocks executed 96%
      195: 2807:ulg flush_block(buf, stored_len, eof)
        -: 2808:    char *buf;        /* input block, or NULL if too old */
        -: 2809:    ulg stored_len;   /* length of input block */
        -: 2810:    int eof;          /* true if this is the last block for a file */
        -: 2811:{
        -: 2812:    ulg opt_lenb, static_lenb; /* opt_len and static_len in bytes */
        -: 2813:    int max_blindex;  /* index of last bit length code of non zero freq */
        -: 2814:
      195: 2815:    flag_buf[last_flags] = flags; /* Save the flags for the last 8 items */
        -: 2816:
        -: 2817:     /* Check if the file is ascii or binary */
     195*: 2818:    if (*file_type == (ush)UNKNOWN) set_file_type();
branch  0 taken 0 (fallthrough)
branch  1 taken 195
call    2 never executed
        -: 2819:
        -: 2820:    /* Construct the literal and distance trees */
        -: 2821:
      195: 2822:    build_tree((tree_desc near *)(&l_desc));
call    0 returned 195
        -: 2823:
        -: 2824:    Tracev((stderr, "\nlit data: dyn %ld, stat %ld", opt_len, static_len));
        -: 2825:
      195: 2826:    build_tree((tree_desc near *)(&d_desc));
call    0 returned 195
        -: 2827:    Tracev((stderr, "\ndist data: dyn %ld, stat %ld", opt_len, static_len));
        -: 2828:    /* At this point, opt_len and static_len are the total bit lengths of
        -: 2829:     * the compressed block data, excluding the tree representations.
        -: 2830:     */
        -: 2831:
        -: 2832:    /* Build the bit length tree for the above two trees, and get the index
        -: 2833:     * in bl_order of the last bit length code to send.
        -: 2834:     */
      195: 2835:    max_blindex = build_bl_tree();
call    0 returned 195
        -: 2836:
        -: 2837:    /* Determine the best encoding. Compute first the block length in bytes */
      195: 2838:    opt_lenb = (opt_len+3+7)>>3;
      195: 2839:    static_lenb = (static_len+3+7)>>3;
      195: 2840:    input_len += stored_len; /* for debugging only */
        -: 2841:
        -: 2842:    Trace((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u dist %u ",
        -: 2843:            opt_lenb, opt_len, static_lenb, static_len, stored_len,
        -: 2844:            last_lit, last_dist));
        -: 2845:
      195: 2846:    if (static_lenb <= opt_lenb) opt_lenb = static_lenb;
branch  0 taken 3 (fallthrough)
branch  1 taken 192
        -: 2847:
        -: 2848:    /* If compression failed and this is the first and last block,
        -: 2849:     * and if the zip file can be seeked (to rewrite the local header),
        -: 2850:     * the whole file is transformed into a stored file:
        -: 2851:     */
        -: 2852:#ifdef FORCE_METHOD
        -: 2853:    if (level == 1 && eof && compressed_len == 0L) { /* force stored file */
        -: 2854:#else
        -: 2855:    if (stored_len <= opt_lenb && eof && compressed_len == 0L && seekable()) {
        -: 2856:#endif
        -: 2857:        /* Since LIT_BUFSIZE <= 2*WSIZE, the input data must be there: */
        -: 2858:        if (buf == (char*)0) error ("block vanished");
        -: 2859:
        -: 2860:        copy_block(buf, (unsigned)stored_len, 0); /* without header */
        -: 2861:        compressed_len = stored_len << 3;
        -: 2862:        *file_method = STORED;
        -: 2863:
        -: 2864:#ifdef FORCE_METHOD
        -: 2865:    } else if (level == 2 && buf != (char*)0) { /* force stored block */
        -: 2866:#else
      195: 2867:    } else if (stored_len+4 <= opt_lenb && buf != (char*)0) {
branch  0 taken 1 (fallthrough)
branch  1 taken 194
branch  2 taken 1 (fallthrough)
branch  3 taken 0
        -: 2868:                       /* 4: two words for the lengths */
        -: 2869:#endif
        -: 2870:        /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
        -: 2871:         * Otherwise we can't have processed more than WSIZE input bytes since
        -: 2872:         * the last block flush, because compression would have been
        -: 2873:         * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
        -: 2874:         * transform a block into a stored block.
        -: 2875:         */
        1: 2876:        send_bits((STORED_BLOCK<<1)+eof, 3);  /* send block type */
call    0 returned 1
        1: 2877:        compressed_len = (compressed_len + 3 + 7) & ~7L;
        1: 2878:        compressed_len += (stored_len + 4) << 3;
        -: 2879:
        1: 2880:        copy_block(buf, (unsigned)stored_len, 1); /* with header */
call    0 returned 1
        -: 2881:
        -: 2882:#ifdef FORCE_METHOD
        -: 2883:    } else if (level == 3) { /* force static trees */
        -: 2884:#else
      194: 2885:    } else if (static_lenb == opt_lenb) {
branch  0 taken 3 (fallthrough)
branch  1 taken 191
        -: 2886:#endif
        3: 2887:        send_bits((STATIC_TREES<<1)+eof, 3);
call    0 returned 3
        3: 2888:        compress_block((ct_data near *)static_ltree, (ct_data near *)static_dtree);
call    0 returned 3
        3: 2889:        compressed_len += 3 + static_len;
        -: 2890:    } else {
      191: 2891:        send_bits((DYN_TREES<<1)+eof, 3);
call    0 returned 191
      191: 2892:        send_all_trees(l_desc.max_code+1, d_desc.max_code+1, max_blindex+1);
call    0 returned 191
      191: 2893:        compress_block((ct_data near *)dyn_ltree, (ct_data near *)dyn_dtree);
call    0 returned 191
      191: 2894:        compressed_len += 3 + opt_len;
        -: 2895:    }
        -: 2896:    Assert (compressed_len == bits_sent, "bad compressed size");
      195: 2897:    init_block();
call    0 returned 195
        -: 2898:
      195: 2899:    if (eof) {
branch  0 taken 175 (fallthrough)
branch  1 taken 20
        -: 2900:        Assert (input_len == isize, "bad input size");
      175: 2901:        bi_windup();
call    0 returned 175
      175: 2902:        compressed_len += 7;  /* align on byte boundary */
        -: 2903:    }
        -: 2904:    Tracev((stderr,"\ncomprlen %lu(%lu) ", compressed_len>>3,
        -: 2905:           compressed_len-7*eof));
        -: 2906:
      195: 2907:    return compressed_len >> 3;
        -: 2908:}
        -: 2909:
        -: 2910:/* ===========================================================================
        -: 2911: * Save the match info and tally the frequency counts. Return true if
        -: 2912: * the current block must be flushed.
        -: 2913: */
function ct_tally called 1805046 returned 100% blocks executed 100%
  1805046: 2914:int ct_tally (dist, lc)
        -: 2915:    int dist;  /* distance of matched string */
        -: 2916:    int lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
        -: 2917:{
  1805046: 2918:    l_buf[last_lit++] = (uch)lc;
  1805046: 2919:    if (dist == 0) {
branch  0 taken 573409 (fallthrough)
branch  1 taken 1231637
        -: 2920:        /* lc is the unmatched char */
   573409: 2921:        dyn_ltree[lc].Freq++;
        -: 2922:    } else {
        -: 2923:        /* Here, lc is the match length - MIN_MATCH */
  1231637: 2924:        dist--;             /* dist = match distance - 1 */
        -: 2925:        Assert((ush)dist < (ush)MAX_DIST &&
        -: 2926:               (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
        -: 2927:               (ush)d_code(dist) < (ush)D_CODES,  "ct_tally: bad match");
        -: 2928:
  1231637: 2929:        dyn_ltree[length_code[lc]+LITERALS+1].Freq++;
  1231637: 2930:        dyn_dtree[d_code(dist)].Freq++;
branch  0 taken 604093 (fallthrough)
branch  1 taken 627544
        -: 2931:
  1231637: 2932:        d_buf[last_dist++] = (ush)dist;
  1231637: 2933:        flags |= flag_bit;
        -: 2934:    }
  1805046: 2935:    flag_bit <<= 1;
        -: 2936:
        -: 2937:    /* Output the flags if they fill a byte: */
  1805046: 2938:    if ((last_lit & 7) == 0) {
branch  0 taken 225564 (fallthrough)
branch  1 taken 1579482
   225564: 2939:        flag_buf[last_flags++] = flags;
   225564: 2940:        flags = 0, flag_bit = 1;
        -: 2941:    }
        -: 2942:    /* Try to guess if it is profitable to stop the current block here */
  1805046: 2943:    if (level > 2 && (last_lit & 0xfff) == 0) {
branch  0 taken 1545185 (fallthrough)
branch  1 taken 259861
branch  2 taken 252 (fallthrough)
branch  3 taken 1544933
        -: 2944:        /* Compute an upper bound for the compressed length */
      252: 2945:        ulg out_length = (ulg)last_lit*8L;
      252: 2946:        ulg in_length = (ulg)strstart-block_start;
        -: 2947:        int dcode;
     7812: 2948:        for (dcode = 0; dcode < D_CODES; dcode++) {
branch  0 taken 7560
branch  1 taken 252 (fallthrough)
     7560: 2949:            out_length += (ulg)dyn_dtree[dcode].Freq*(5L+extra_dbits[dcode]);
        -: 2950:        }
      252: 2951:        out_length >>= 3;
        -: 2952:        Trace((stderr,"\nlast_lit %u, last_dist %u, in %ld, out ~%ld(%ld%%) ",
        -: 2953:               last_lit, last_dist, in_length, out_length,
        -: 2954:               100L - out_length*100L/in_length));
      252: 2955:        if (last_dist < last_lit/2 && out_length < in_length/2) return 1;
branch  0 taken 11 (fallthrough)
branch  1 taken 241
branch  2 taken 6 (fallthrough)
branch  3 taken 5
        -: 2956:    }
  1805040: 2957:    return (last_lit == LIT_BUFSIZE-1 || last_dist == DIST_BUFSIZE);
branch  0 taken 1805026 (fallthrough)
branch  1 taken 14
branch  2 taken 0 (fallthrough)
branch  3 taken 1805026
        -: 2958:    /* We avoid equality with LIT_BUFSIZE because of wraparound at 64K
        -: 2959:     * on 16 bit machines and because stored blocks are restricted to
        -: 2960:     * 64K-1 bytes.
        -: 2961:     */
        -: 2962:}
        -: 2963:
        -: 2964:/* ===========================================================================
        -: 2965: * Send the block data compressed using the given Huffman trees
        -: 2966: */
function compress_block called 194 returned 100% blocks executed 100%
      194: 2967:local void compress_block(ltree, dtree)
        -: 2968:    ct_data near *ltree; /* literal tree */
        -: 2969:    ct_data near *dtree; /* distance tree */
        -: 2970:{
        -: 2971:    unsigned dist;      /* distance of matched string */
        -: 2972:    int lc;             /* match length or unmatched char (if dist == 0) */
      194: 2973:    unsigned lx = 0;    /* running index in l_buf */
      194: 2974:    unsigned dx = 0;    /* running index in d_buf */
      194: 2975:    unsigned fx = 0;    /* running index in flag_buf */
      194: 2976:    uch flag = 0;       /* current flags */
        -: 2977:    unsigned code;      /* the code to send */
        -: 2978:    int extra;          /* number of extra bits to send */
        -: 2979:
      194: 2980:    if (last_lit != 0) do {
branch  0 taken 192 (fallthrough)
branch  1 taken 2
  1793008: 2981:        if ((lx & 7) == 0) flag = flag_buf[fx++];
branch  0 taken 224213 (fallthrough)
branch  1 taken 1568795
  1793008: 2982:        lc = l_buf[lx++];
  1793008: 2983:        if ((flag & 1) == 0) {
branch  0 taken 561375 (fallthrough)
branch  1 taken 1231633
   561375: 2984:            send_code(lc, ltree); /* send a literal byte */
call    0 returned 561375
        -: 2985:            Tracecv(isgraph(lc), (stderr," '%c' ", lc));
        -: 2986:        } else {
        -: 2987:            /* Here, lc is the match length - MIN_MATCH */
  1231633: 2988:            code = length_code[lc];
  1231633: 2989:            send_code(code+LITERALS+1, ltree); /* send the length code */
call    0 returned 1231633
  1231633: 2990:            extra = extra_lbits[code];
  1231633: 2991:            if (extra != 0) {
branch  0 taken 120169 (fallthrough)
branch  1 taken 1111464
   120169: 2992:                lc -= base_length[code];
   120169: 2993:                send_bits(lc, extra);        /* send the extra length bits */
call    0 returned 120169
        -: 2994:            }
  1231633: 2995:            dist = d_buf[dx++];
        -: 2996:            /* Here, dist is the match distance - 1 */
  1231633: 2997:            code = d_code(dist);
branch  0 taken 604092 (fallthrough)
branch  1 taken 627541
        -: 2998:            Assert (code < D_CODES, "bad d_code");
        -: 2999:
  1231633: 3000:            send_code(code, dtree);       /* send the distance code */
call    0 returned 1231633
  1231633: 3001:            extra = extra_dbits[code];
  1231633: 3002:            if (extra != 0) {
branch  0 taken 821656 (fallthrough)
branch  1 taken 409977
   821656: 3003:                dist -= base_dist[code];
   821656: 3004:                send_bits(dist, extra);   /* send the extra distance bits */
call    0 returned 821656
        -: 3005:            }
        -: 3006:        } /* literal or match pair ? */
  1793008: 3007:        flag >>= 1;
  1793008: 3008:    } while (lx < last_lit);
branch  0 taken 1792816
branch  1 taken 192 (fallthrough)
        -: 3009:
      194: 3010:    send_code(END_BLOCK, ltree);
call    0 returned 194
      194: 3011:}
        -: 3012:
        -: 3013:/* ===========================================================================
        -: 3014: * Set the file type to ASCII or BINARY, using a crude approximation:
        -: 3015: * binary if more than 20% of the bytes are <= 6 or >= 128, ascii otherwise.
        -: 3016: * IN assertion: the fields freq of dyn_ltree are set and the total of all
        -: 3017: * frequencies does not exceed 64K (to fit in an int on 16 bit machines).
        -: 3018: */
function set_file_type called 0 returned 0% blocks executed 0%
    #####: 3019:local void set_file_type()
        -: 3020:{
    #####: 3021:    int n = 0;
    #####: 3022:    unsigned ascii_freq = 0;
    #####: 3023:    unsigned bin_freq = 0;
    #####: 3024:    while (n < 7)        bin_freq += dyn_ltree[n++].Freq;
branch  0 never executed
branch  1 never executed
    #####: 3025:    while (n < 128)    ascii_freq += dyn_ltree[n++].Freq;
branch  0 never executed
branch  1 never executed
    #####: 3026:    while (n < LITERALS) bin_freq += dyn_ltree[n++].Freq;
branch  0 never executed
branch  1 never executed
    #####: 3027:    *file_type = bin_freq > (ascii_freq >> 2) ? BINARY : ASCII;
        -: 3028:    if (*file_type == BINARY && translate_eol) {
        -: 3029:        warn("-l used on binary file", "");
        -: 3030:    }
    #####: 3031:}
        -: 3032:/* unlzh.c -- decompress files in SCO compress -H (LZH) format.
        -: 3033: * The code in this file is directly derived from the public domain 'ar002'
        -: 3034: * written by Haruhiko Okumura.
        -: 3035: */
        -: 3036:
        -: 3037:#ifdef RCSID
        -: 3038:static char rcsid[] = "$Id: unlzh.c,v 1.2 1993/06/24 10:59:01 jloup Exp $";
        -: 3039:#endif
        -: 3040:
        -: 3041:/* decode.c */
        -: 3042:
        -: 3043:local unsigned  decode  OF((unsigned count, uch buffer[]));
        -: 3044:local void decode_start OF((void));
        -: 3045:
        -: 3046:/* huf.c */
        -: 3047:local void huf_decode_start OF((void));
        -: 3048:local unsigned decode_c     OF((void));
        -: 3049:local unsigned decode_p     OF((void));
        -: 3050:local void read_pt_len      OF((int nn, int nbit, int i_special));
        -: 3051:local void read_c_len       OF((void));
        -: 3052:
        -: 3053:/* io.c */
        -: 3054:local void fillbuf      OF((int n));
        -: 3055:local unsigned getbits  OF((int n));
        -: 3056:local void init_getbits OF((void));
        -: 3057:
        -: 3058:/* maketbl.c */
        -: 3059:
        -: 3060:local void make_table OF((int nchar, uch bitlen[],
        -: 3061:			  int tablebits, ush table[]));
        -: 3062:
        -: 3063:
        -: 3064:#define DICBIT    13    /* 12(-lh4-) or 13(-lh5-) */
        -: 3065:#define DICSIZ ((unsigned) 1 << DICBIT)
        -: 3066:
        -: 3067:#ifndef CHAR_BIT
        -: 3068:#  define CHAR_BIT 8
        -: 3069:#endif
        -: 3070:
        -: 3071:#ifndef UCHAR_MAX
        -: 3072:#  define UCHAR_MAX 255
        -: 3073:#endif
        -: 3074:
        -: 3075:#define BITBUFSIZ (CHAR_BIT * 2 * sizeof(char))
        -: 3076:/* Do not use CHAR_BIT * sizeof(bitbuf), does not work on machines
        -: 3077: * for which short is not on 16 bits (Cray).
        -: 3078: */
        -: 3079:
        -: 3080:/* encode.c and decode.c */
        -: 3081:
        -: 3082:#define MAXMATCH 256    /* formerly F (not more than UCHAR_MAX + 1) */
        -: 3083:#define THRESHOLD  3    /* choose optimal value */
        -: 3084:
        -: 3085:/* huf.c */
        -: 3086:
        -: 3087:#define NC (UCHAR_MAX + MAXMATCH + 2 - THRESHOLD)
        -: 3088:	/* alphabet = {0, 1, 2, ..., NC - 1} */
        -: 3089:#define CBIT 9  /* $\lfloor \log_2 NC \rfloor + 1$ */
        -: 3090:#define CODE_BIT  16  /* codeword length */
        -: 3091:
        -: 3092:#define NP (DICBIT + 1)
        -: 3093:#define NT (CODE_BIT + 3)
        -: 3094:#define PBIT 4  /* smallest integer such that (1U << PBIT) > NP */
        -: 3095:#define TBIT 5  /* smallest integer such that (1U << TBIT) > NT */
        -: 3096:#if NT > NP
        -: 3097:# define NPT NT
        -: 3098:#else
        -: 3099:# define NPT NP
        -: 3100:#endif
        -: 3101:
        -: 3102:/* local ush left[2 * NC - 1]; */
        -: 3103:/* local ush right[2 * NC - 1]; */
        -: 3104:#define left  prev
        -: 3105:#define right head
        -: 3106:#if NC > (1<<(BITS-2))
        -: 3107:    error cannot overlay left+right and prev
        -: 3108:#endif
        -: 3109:
        -: 3110:/* local uch c_len[NC]; */
        -: 3111:#define c_len outbuf
        -: 3112:#if NC > OUTBUFSIZ
        -: 3113:    error cannot overlay c_len and outbuf
        -: 3114:#endif
        -: 3115:
        -: 3116:local uch pt_len[NPT];
        -: 3117:local unsigned blocksize;
        -: 3118:local ush pt_table[256];
        -: 3119:
        -: 3120:/* local ush c_table[4096]; */
        -: 3121:#define c_table d_buf
        -: 3122:#if (DIST_BUFSIZE-1) < 4095
        -: 3123:    error cannot overlay c_table and d_buf
        -: 3124:#endif
        -: 3125:
        -: 3126:/***********************************************************
        -: 3127:        io.c -- input/output
        -: 3128:***********************************************************/
        -: 3129:
        -: 3130:local ush       bitbuf;
        -: 3131:local unsigned  subbitbuf;
        -: 3132:local int       bitcount;
        -: 3133:
function fillbuf called 0 returned 0% blocks executed 0%
    #####: 3134:local void fillbuf(n)  /* Shift bitbuf n bits left, read n bits */
        -: 3135:    int n;
        -: 3136:{
    #####: 3137:    bitbuf <<= n;
    #####: 3138:    while (n > bitcount) {
branch  0 never executed
branch  1 never executed
        -: 3139:
    #####: 3140:	bitbuf |= subbitbuf << (n -= bitcount);
    #####: 3141:	subbitbuf = (unsigned)try_byte();
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 3142:	if ((int)subbitbuf == EOF) subbitbuf = 0;
branch  0 never executed
branch  1 never executed
    #####: 3143:	bitcount = CHAR_BIT;
        -: 3144:
        -: 3145:    }
    #####: 3146:    bitbuf |= subbitbuf >> (bitcount -= n);
    #####: 3147:}
        -: 3148:
function getbits called 0 returned 0% blocks executed 0%
    #####: 3149:local unsigned getbits(n)
        -: 3150:    int n;
        -: 3151:{
        -: 3152:    unsigned x;
        -: 3153:
    #####: 3154:    x = bitbuf >> (BITBUFSIZ - n);  fillbuf(n);
call    0 never executed
    #####: 3155:    return x;
        -: 3156:}
        -: 3157:
function init_getbits called 0 returned 0% blocks executed 0%
    #####: 3158:local void init_getbits()
        -: 3159:{
    #####: 3160:    bitbuf = 0;  subbitbuf = 0;  bitcount = 0;
    #####: 3161:    fillbuf(BITBUFSIZ);
call    0 never executed
    #####: 3162:}
        -: 3163:
        -: 3164:/***********************************************************
        -: 3165:	maketbl.c -- make table for decoding
        -: 3166:***********************************************************/
        -: 3167:
function make_table called 0 returned 0% blocks executed 0%
    #####: 3168:local void make_table(nchar, bitlen, tablebits, table)
        -: 3169:    int nchar;
        -: 3170:    uch bitlen[];
        -: 3171:    int tablebits;
        -: 3172:    ush table[];
        -: 3173:{
        -: 3174:    ush count[17], weight[17], start[18], *p;
        -: 3175:    unsigned i, k, len, ch, jutbits, avail, nextcode, mask;
        -: 3176:
    #####: 3177:    for (i = 1; i <= 16; i++) count[i] = 0;
branch  0 never executed
branch  1 never executed
    #####: 3178:    for (i = 0; i < (unsigned)nchar; i++) count[bitlen[i]]++;
branch  0 never executed
branch  1 never executed
        -: 3179:
    #####: 3180:    start[1] = 0;
    #####: 3181:    for (i = 1; i <= 16; i++)
branch  0 never executed
branch  1 never executed
    #####: 3182:	start[i + 1] = start[i] + (count[i] << (16 - i));
    #####: 3183:    if ((start[17] & 0xffff) != 0)
branch  0 never executed
branch  1 never executed
    #####: 3184:	error("Bad table\n");
call    0 never executed
        -: 3185:
    #####: 3186:    jutbits = 16 - tablebits;
    #####: 3187:    for (i = 1; i <= (unsigned)tablebits; i++) {
branch  0 never executed
branch  1 never executed
    #####: 3188:	start[i] >>= jutbits;
    #####: 3189:	weight[i] = (unsigned) 1 << (tablebits - i);
        -: 3190:    }
    #####: 3191:    while (i <= 16) {
branch  0 never executed
branch  1 never executed
    #####: 3192:	weight[i] = (unsigned) 1 << (16 - i);
    #####: 3193:	i++;
        -: 3194:    }
        -: 3195:
    #####: 3196:    i = start[tablebits + 1] >> jutbits;
    #####: 3197:    if (i != 0) {
branch  0 never executed
branch  1 never executed
    #####: 3198:	k = 1 << tablebits;
    #####: 3199:	while (i != k) table[i++] = 0;
branch  0 never executed
branch  1 never executed
        -: 3200:    }
        -: 3201:
    #####: 3202:    avail = nchar;
    #####: 3203:    mask = (unsigned) 1 << (15 - tablebits);
    #####: 3204:    for (ch = 0; ch < (unsigned)nchar; ch++) {
branch  0 never executed
branch  1 never executed
    #####: 3205:	if ((len = bitlen[ch]) == 0) continue;
branch  0 never executed
branch  1 never executed
    #####: 3206:	nextcode = start[len] + weight[len];
    #####: 3207:	if (len <= (unsigned)tablebits) {
branch  0 never executed
branch  1 never executed
    #####: 3208:	    for (i = start[len]; i < nextcode; i++) table[i] = ch;
branch  0 never executed
branch  1 never executed
        -: 3209:	} else {
    #####: 3210:	    k = start[len];
    #####: 3211:	    p = &table[k >> jutbits];
    #####: 3212:	    i = len - tablebits;
    #####: 3213:	    while (i != 0) {
branch  0 never executed
branch  1 never executed
    #####: 3214:		if (*p == 0) {
branch  0 never executed
branch  1 never executed
    #####: 3215:		    right[avail] = left[avail] = 0;
    #####: 3216:		    *p = avail++;
        -: 3217:		}
    #####: 3218:		if (k & mask) p = &right[*p];
branch  0 never executed
branch  1 never executed
    #####: 3219:		else          p = &left[*p];
    #####: 3220:		k <<= 1;  i--;
        -: 3221:	    }
    #####: 3222:	    *p = ch;
        -: 3223:	}
    #####: 3224:	start[len] = nextcode;
        -: 3225:    }
    #####: 3226:}
        -: 3227:
        -: 3228:/***********************************************************
        -: 3229:        huf.c -- static Huffman
        -: 3230:***********************************************************/
        -: 3231:
function read_pt_len called 0 returned 0% blocks executed 0%
    #####: 3232:local void read_pt_len(nn, nbit, i_special)
        -: 3233:    int nn;
        -: 3234:    int nbit;
        -: 3235:    int i_special;
        -: 3236:{
        -: 3237:    int i, c, n;
        -: 3238:    unsigned mask;
        -: 3239:
    #####: 3240:    n = getbits(nbit);
call    0 never executed
    #####: 3241:    if (n == 0) {
branch  0 never executed
branch  1 never executed
    #####: 3242:	c = getbits(nbit);
call    0 never executed
    #####: 3243:	for (i = 0; i < nn; i++) pt_len[i] = 0;
branch  0 never executed
branch  1 never executed
    #####: 3244:	for (i = 0; i < 256; i++) pt_table[i] = c;
branch  0 never executed
branch  1 never executed
        -: 3245:    } else {
    #####: 3246:	i = 0;
    #####: 3247:	while (i < n) {
branch  0 never executed
branch  1 never executed
    #####: 3248:	    c = bitbuf >> (BITBUFSIZ - 3);
    #####: 3249:	    if (c == 7) {
branch  0 never executed
branch  1 never executed
    #####: 3250:		mask = (unsigned) 1 << (BITBUFSIZ - 1 - 3);
    #####: 3251:		while (mask & bitbuf) {  mask >>= 1;  c++;  }
branch  0 never executed
branch  1 never executed
        -: 3252:	    }
    #####: 3253:	    fillbuf((c < 7) ? 3 : c - 3);
call    0 never executed
    #####: 3254:	    pt_len[i++] = c;
    #####: 3255:	    if (i == i_special) {
branch  0 never executed
branch  1 never executed
    #####: 3256:		c = getbits(2);
call    0 never executed
    #####: 3257:		while (--c >= 0) pt_len[i++] = 0;
branch  0 never executed
branch  1 never executed
        -: 3258:	    }
        -: 3259:	}
    #####: 3260:	while (i < nn) pt_len[i++] = 0;
branch  0 never executed
branch  1 never executed
    #####: 3261:	make_table(nn, pt_len, 8, pt_table);
call    0 never executed
        -: 3262:    }
    #####: 3263:}
        -: 3264:
function read_c_len called 0 returned 0% blocks executed 0%
    #####: 3265:local void read_c_len()
        -: 3266:{
        -: 3267:    int i, c, n;
        -: 3268:    unsigned mask;
        -: 3269:
    #####: 3270:    n = getbits(CBIT);
call    0 never executed
    #####: 3271:    if (n == 0) {
branch  0 never executed
branch  1 never executed
    #####: 3272:	c = getbits(CBIT);
call    0 never executed
    #####: 3273:	for (i = 0; i < NC; i++) c_len[i] = 0;
branch  0 never executed
branch  1 never executed
    #####: 3274:	for (i = 0; i < 4096; i++) c_table[i] = c;
branch  0 never executed
branch  1 never executed
        -: 3275:    } else {
    #####: 3276:	i = 0;
    #####: 3277:	while (i < n) {
branch  0 never executed
branch  1 never executed
    #####: 3278:	    c = pt_table[bitbuf >> (BITBUFSIZ - 8)];
    #####: 3279:	    if (c >= NT) {
branch  0 never executed
branch  1 never executed
    #####: 3280:		mask = (unsigned) 1 << (BITBUFSIZ - 1 - 8);
        -: 3281:		do {
    #####: 3282:		    if (bitbuf & mask) c = right[c];
branch  0 never executed
branch  1 never executed
    #####: 3283:		    else               c = left [c];
    #####: 3284:		    mask >>= 1;
    #####: 3285:		} while (c >= NT);
branch  0 never executed
branch  1 never executed
        -: 3286:	    }
    #####: 3287:	    fillbuf((int) pt_len[c]);
call    0 never executed
    #####: 3288:	    if (c <= 2) {
branch  0 never executed
branch  1 never executed
    #####: 3289:		if      (c == 0) c = 1;
branch  0 never executed
branch  1 never executed
    #####: 3290:		else if (c == 1) c = getbits(4) + 3;
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 3291:		else             c = getbits(CBIT) + 20;
call    0 never executed
    #####: 3292:		while (--c >= 0) c_len[i++] = 0;
branch  0 never executed
branch  1 never executed
    #####: 3293:	    } else c_len[i++] = c - 2;
        -: 3294:	}
    #####: 3295:	while (i < NC) c_len[i++] = 0;
branch  0 never executed
branch  1 never executed
    #####: 3296:	make_table(NC, c_len, 12, c_table);
call    0 never executed
        -: 3297:    }
    #####: 3298:}
        -: 3299:
function decode_c called 0 returned 0% blocks executed 0%
    #####: 3300:local unsigned decode_c()
        -: 3301:{
        -: 3302:    unsigned j, mask;
        -: 3303:
    #####: 3304:    if (blocksize == 0) {
branch  0 never executed
branch  1 never executed
    #####: 3305:	blocksize = getbits(16);
call    0 never executed
    #####: 3306:	if (blocksize == 0) {
branch  0 never executed
branch  1 never executed
    #####: 3307:	    return NC; /* end of file */
        -: 3308:	}
    #####: 3309:	read_pt_len(NT, TBIT, 3);
call    0 never executed
    #####: 3310:	read_c_len();
call    0 never executed
    #####: 3311:	read_pt_len(NP, PBIT, -1);
call    0 never executed
        -: 3312:    }
    #####: 3313:    blocksize--;
    #####: 3314:    j = c_table[bitbuf >> (BITBUFSIZ - 12)];
    #####: 3315:    if (j >= NC) {
branch  0 never executed
branch  1 never executed
    #####: 3316:	mask = (unsigned) 1 << (BITBUFSIZ - 1 - 12);
        -: 3317:	do {
    #####: 3318:	    if (bitbuf & mask) j = right[j];
branch  0 never executed
branch  1 never executed
    #####: 3319:	    else               j = left [j];
    #####: 3320:	    mask >>= 1;
    #####: 3321:	} while (j >= NC);
branch  0 never executed
branch  1 never executed
        -: 3322:    }
    #####: 3323:    fillbuf((int) c_len[j]);
call    0 never executed
    #####: 3324:    return j;
        -: 3325:}
        -: 3326:
function decode_p called 0 returned 0% blocks executed 0%
    #####: 3327:local unsigned decode_p()
        -: 3328:{
        -: 3329:    unsigned j, mask;
        -: 3330:
    #####: 3331:    j = pt_table[bitbuf >> (BITBUFSIZ - 8)];
    #####: 3332:    if (j >= NP) {
branch  0 never executed
branch  1 never executed
    #####: 3333:	mask = (unsigned) 1 << (BITBUFSIZ - 1 - 8);
        -: 3334:	do {
    #####: 3335:	    if (bitbuf & mask) j = right[j];
branch  0 never executed
branch  1 never executed
    #####: 3336:	    else               j = left [j];
    #####: 3337:	    mask >>= 1;
    #####: 3338:	} while (j >= NP);
branch  0 never executed
branch  1 never executed
        -: 3339:    }
    #####: 3340:    fillbuf((int) pt_len[j]);
call    0 never executed
    #####: 3341:    if (j != 0) j = ((unsigned) 1 << (j - 1)) + getbits((int) (j - 1));
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 3342:    return j;
        -: 3343:}
        -: 3344:
function huf_decode_start called 0 returned 0% blocks executed 0%
    #####: 3345:local void huf_decode_start()
        -: 3346:{
    #####: 3347:    init_getbits();  blocksize = 0;
call    0 never executed
    #####: 3348:}
        -: 3349:
        -: 3350:/***********************************************************
        -: 3351:        decode.c
        -: 3352:***********************************************************/
        -: 3353:
        -: 3354:local int j;    /* remaining bytes to copy */
        -: 3355:local int done; /* set at end of input */
        -: 3356:
function decode_start called 0 returned 0% blocks executed 0%
    #####: 3357:local void decode_start()
        -: 3358:{
    #####: 3359:    huf_decode_start();
call    0 never executed
    #####: 3360:    j = 0;
    #####: 3361:    done = 0;
    #####: 3362:}
        -: 3363:
        -: 3364:/* Decode the input and return the number of decoded bytes put in buffer
        -: 3365: */
function decode called 0 returned 0% blocks executed 0%
    #####: 3366:local unsigned decode(count, buffer)
        -: 3367:    unsigned count;
        -: 3368:    uch buffer[];
        -: 3369:    /* The calling function must keep the number of
        -: 3370:       bytes to be processed.  This function decodes
        -: 3371:       either 'count' bytes or 'DICSIZ' bytes, whichever
        -: 3372:       is smaller, into the array 'buffer[]' of size
        -: 3373:       'DICSIZ' or more.
        -: 3374:       Call decode_start() once for each new file
        -: 3375:       before calling this function.
        -: 3376:     */
        -: 3377:{
        -: 3378:    local unsigned i;
        -: 3379:    unsigned r, c;
        -: 3380:
    #####: 3381:    r = 0;
    #####: 3382:    while (--j >= 0) {
branch  0 never executed
branch  1 never executed
        -: 3383:
    #####: 3384:	buffer[r] = buffer[i];
        -: 3385:
    #####: 3386:	i = (i + 1) & (DICSIZ - 1);
    #####: 3387:	if (++r == count) return r;
branch  0 never executed
branch  1 never executed
        -: 3388:    }
        -: 3389:    for ( ; ; ) {
    #####: 3390:	c = decode_c();
call    0 never executed
    #####: 3391:	if (c == NC) {
branch  0 never executed
branch  1 never executed
    #####: 3392:	    done = 1;
    #####: 3393:	    return r;
        -: 3394:	}
    #####: 3395:	if (c <= UCHAR_MAX) {
branch  0 never executed
branch  1 never executed
    #####: 3396:	    buffer[r] = c;
    #####: 3397:	    if (++r == count) return r;
branch  0 never executed
branch  1 never executed
        -: 3398:	} else {
    #####: 3399:	    j = c - (UCHAR_MAX + 1 - THRESHOLD);
    #####: 3400:	    i = (r - decode_p() - 1) & (DICSIZ - 1);
call    0 never executed
    #####: 3401:	    while (--j >= 0) {
branch  0 never executed
branch  1 never executed
    #####: 3402:		buffer[r] = buffer[i];
    #####: 3403:		i = (i + 1) & (DICSIZ - 1);
    #####: 3404:		if (++r == count) return r;
branch  0 never executed
branch  1 never executed
        -: 3405:	    }
        -: 3406:	}
        -: 3407:    }
        -: 3408:}
        -: 3409:
        -: 3410:
        -: 3411:/* ===========================================================================
        -: 3412: * Unlzh in to out. Return OK or ERROR.
        -: 3413: */
function unlzh called 0 returned 0% blocks executed 0%
    #####: 3414:int unlzh(in, out)
        -: 3415:    int in;
        -: 3416:    int out;
        -: 3417:{
        -: 3418:    unsigned n;
    #####: 3419:    ifd = in;
    #####: 3420:    ofd = out;
        -: 3421:
    #####: 3422:    decode_start();
call    0 never executed
    #####: 3423:    while (!done) {
branch  0 never executed
branch  1 never executed
    #####: 3424:	n = decode((unsigned) DICSIZ, window);
call    0 never executed
    #####: 3425:	if (!test && n > 0) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3426:	    write_buf(out, (char*)window, n);
call    0 never executed
        -: 3427:	}
        -: 3428:    }
    #####: 3429:    return OK;
        -: 3430:}
        -: 3431:/* unlzw.c -- decompress files in LZW format.
        -: 3432: * The code in this file is directly derived from the public domain 'compress'
        -: 3433: * written by Spencer Thomas, Joe Orost, James Woods, Jim McKie, Steve Davies,
        -: 3434: * Ken Turkowski, Dave Mack and Peter Jannesen.
        -: 3435: *
        -: 3436: * This is a temporary version which will be rewritten in some future version
        -: 3437: * to accommodate in-memory decompression.
        -: 3438: */
        -: 3439:
        -: 3440:#ifdef RCSID
        -: 3441:static char rcsid[] = "$Id: unlzw.c,v 0.15 1993/06/10 13:28:35 jloup Exp $";
        -: 3442:#endif
        -: 3443:
        -: 3444:#ifdef HAVE_UNISTD_H
        -: 3445:#  include <unistd.h>
        -: 3446:#endif
        -: 3447:#ifndef NO_FCNTL_H
        -: 3448:#  include <fcntl.h>
        -: 3449:#endif
        -: 3450:
        -: 3451:typedef	unsigned char	char_type;
        -: 3452:typedef          long   code_int;
        -: 3453:typedef unsigned long 	count_int;
        -: 3454:typedef unsigned short	count_short;
        -: 3455:typedef unsigned long 	cmp_code_int;
        -: 3456:
        -: 3457:#define MAXCODE(n)	(1L << (n))
        -: 3458:    
        -: 3459:#ifndef	REGISTERS
        -: 3460:#	define	REGISTERS	2
        -: 3461:#endif
        -: 3462:#define	REG1	
        -: 3463:#define	REG2	
        -: 3464:#define	REG3	
        -: 3465:#define	REG4	
        -: 3466:#define	REG5	
        -: 3467:#define	REG6	
        -: 3468:#define	REG7	
        -: 3469:#define	REG8	
        -: 3470:#define	REG9	
        -: 3471:#define	REG10
        -: 3472:#define	REG11	
        -: 3473:#define	REG12	
        -: 3474:#define	REG13
        -: 3475:#define	REG14
        -: 3476:#define	REG15
        -: 3477:#define	REG16
        -: 3478:#if REGISTERS >= 1
        -: 3479:#	undef	REG1
        -: 3480:#	define	REG1	register
        -: 3481:#endif
        -: 3482:#if REGISTERS >= 2
        -: 3483:#	undef	REG2
        -: 3484:#	define	REG2	register
        -: 3485:#endif
        -: 3486:#if REGISTERS >= 3
        -: 3487:#	undef	REG3
        -: 3488:#	define	REG3	register
        -: 3489:#endif
        -: 3490:#if REGISTERS >= 4
        -: 3491:#	undef	REG4
        -: 3492:#	define	REG4	register
        -: 3493:#endif
        -: 3494:#if REGISTERS >= 5
        -: 3495:#	undef	REG5
        -: 3496:#	define	REG5	register
        -: 3497:#endif
        -: 3498:#if REGISTERS >= 6
        -: 3499:#	undef	REG6
        -: 3500:#	define	REG6	register
        -: 3501:#endif
        -: 3502:#if REGISTERS >= 7
        -: 3503:#	undef	REG7
        -: 3504:#	define	REG7	register
        -: 3505:#endif
        -: 3506:#if REGISTERS >= 8
        -: 3507:#	undef	REG8
        -: 3508:#	define	REG8	register
        -: 3509:#endif
        -: 3510:#if REGISTERS >= 9
        -: 3511:#	undef	REG9
        -: 3512:#	define	REG9	register
        -: 3513:#endif
        -: 3514:#if REGISTERS >= 10
        -: 3515:#	undef	REG10
        -: 3516:#	define	REG10	register
        -: 3517:#endif
        -: 3518:#if REGISTERS >= 11
        -: 3519:#	undef	REG11
        -: 3520:#	define	REG11	register
        -: 3521:#endif
        -: 3522:#if REGISTERS >= 12
        -: 3523:#	undef	REG12
        -: 3524:#	define	REG12	register
        -: 3525:#endif
        -: 3526:#if REGISTERS >= 13
        -: 3527:#	undef	REG13
        -: 3528:#	define	REG13	register
        -: 3529:#endif
        -: 3530:#if REGISTERS >= 14
        -: 3531:#	undef	REG14
        -: 3532:#	define	REG14	register
        -: 3533:#endif
        -: 3534:#if REGISTERS >= 15
        -: 3535:#	undef	REG15
        -: 3536:#	define	REG15	register
        -: 3537:#endif
        -: 3538:#if REGISTERS >= 16
        -: 3539:#	undef	REG16
        -: 3540:#	define	REG16	register
        -: 3541:#endif
        -: 3542:    
        -: 3543:#ifndef	BYTEORDER
        -: 3544:#	define	BYTEORDER	0000
        -: 3545:#endif
        -: 3546:	
        -: 3547:#ifndef	NOALLIGN
        -: 3548:#	define	NOALLIGN	0
        -: 3549:#endif
        -: 3550:
        -: 3551:
        -: 3552:union	bytes {
        -: 3553:    long  word;
        -: 3554:    struct {
        -: 3555:#if BYTEORDER == 4321
        -: 3556:	char_type	b1;
        -: 3557:	char_type	b2;
        -: 3558:	char_type	b3;
        -: 3559:	char_type	b4;
        -: 3560:#else
        -: 3561:#if BYTEORDER == 1234
        -: 3562:	char_type	b4;
        -: 3563:	char_type	b3;
        -: 3564:	char_type	b2;
        -: 3565:	char_type	b1;
        -: 3566:#else
        -: 3567:#	undef	BYTEORDER
        -: 3568:	int  dummy;
        -: 3569:#endif
        -: 3570:#endif
        -: 3571:    } bytes;
        -: 3572:};
        -: 3573:
        -: 3574:#if BYTEORDER == 4321 && NOALLIGN == 1
        -: 3575:#  define input(b,o,c,n,m){ \
        -: 3576:     (c) = (*(long *)(&(b)[(o)>>3])>>((o)&0x7))&(m); \
        -: 3577:     (o) += (n); \
        -: 3578:   }
        -: 3579:#else
        -: 3580:#  define input(b,o,c,n,m){ \
        -: 3581:     REG1 char_type *p = &(b)[(o)>>3]; \
        -: 3582:     (c) = ((((long)(p[0]))|((long)(p[1])<<8)| \
        -: 3583:     ((long)(p[2])<<16))>>((o)&0x7))&(m); \
        -: 3584:     (o) += (n); \
        -: 3585:   }
        -: 3586:#endif
        -: 3587:
        -: 3588:#ifndef MAXSEG_64K
        -: 3589:   /* DECLARE(ush, tab_prefix, (1<<BITS)); -- prefix code */
        -: 3590:#  define tab_prefixof(i) tab_prefix[i]
        -: 3591:#  define clear_tab_prefixof()	memzero(tab_prefix, 256);
        -: 3592:#else
        -: 3593:   /* DECLARE(ush, tab_prefix0, (1<<(BITS-1)); -- prefix for even codes */
        -: 3594:   /* DECLARE(ush, tab_prefix1, (1<<(BITS-1)); -- prefix for odd  codes */
        -: 3595:   ush *tab_prefix[2];
        -: 3596:#  define tab_prefixof(i) tab_prefix[(i)&1][(i)>>1]
        -: 3597:#  define clear_tab_prefixof()	\
        -: 3598:      memzero(tab_prefix0, 128), \
        -: 3599:      memzero(tab_prefix1, 128);
        -: 3600:#endif
        -: 3601:#define de_stack        ((char_type *)(&d_buf[DIST_BUFSIZE-1]))
        -: 3602:#define tab_suffixof(i) tab_suffix[i]
        -: 3603:
        -: 3604:int block_mode = BLOCK_MODE; /* block compress mode -C compatible with 2.0 */
        -: 3605:
        -: 3606:/* ============================================================================
        -: 3607: * Decompress in to out.  This routine adapts to the codes in the
        -: 3608: * file building the "string" table on-the-fly; requiring no table to
        -: 3609: * be stored in the compressed file.
        -: 3610: * IN assertions: the buffer inbuf contains already the beginning of
        -: 3611: *   the compressed data, from offsets iptr to insize-1 included.
        -: 3612: *   The magic header has already been checked and skipped.
        -: 3613: *   bytes_in and bytes_out have been initialized.
        -: 3614: */
function unlzw called 1 returned 100% blocks executed 74%
        1: 3615:int unlzw(in, out) 
        -: 3616:    int in, out;    /* input and output file descriptors */
        -: 3617:{
        -: 3618:    REG2   char_type  *stackp;
        -: 3619:    REG3   code_int   code;
        -: 3620:    REG4   int        finchar;
        -: 3621:    REG5   code_int   oldcode;
        -: 3622:    REG6   code_int   incode;
        -: 3623:    REG7   long       inbits;
        -: 3624:    REG8   long       posbits;
        -: 3625:    REG9   int        outpos;
        -: 3626:/*  REG10  int        insize; (global) */
        -: 3627:    REG11  unsigned   bitmask;
        -: 3628:    REG12  code_int   free_ent;
        -: 3629:    REG13  code_int   maxcode;
        -: 3630:    REG14  code_int   maxmaxcode;
        -: 3631:    REG15  int        n_bits;
        -: 3632:    REG16  int        rsize;
        -: 3633:    
        -: 3634:#ifdef MAXSEG_64K
        -: 3635:    tab_prefix[0] = tab_prefix0;
        -: 3636:    tab_prefix[1] = tab_prefix1;
        -: 3637:#endif
       1*: 3638:    maxbits = get_byte();
branch  0 taken 1 (fallthrough)
branch  1 taken 0
call    2 never executed
        1: 3639:    block_mode = maxbits & BLOCK_MODE;
        1: 3640:    if ((maxbits & LZW_RESERVED) != 0) {
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 3641:	WARN((stderr, "\n%s: %s: warning, unknown flags 0x%x\n",
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 3642:	      progname, ifname, maxbits & LZW_RESERVED));
        -: 3643:    }
        1: 3644:    maxbits &= BIT_MASK;
        1: 3645:    maxmaxcode = MAXCODE(maxbits);
        -: 3646:    
        1: 3647:    if (maxbits > BITS) {
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 3648:	fprintf(stderr,
call    0 never executed
        -: 3649:		"\n%s: %s: compressed with %d bits, can only handle %d bits\n",
        -: 3650:		progname, ifname, maxbits, BITS);
    #####: 3651:	exit_code = ERROR;
    #####: 3652:	return ERROR;
        -: 3653:    }
        1: 3654:    rsize = insize;
        1: 3655:    maxcode = MAXCODE(n_bits = INIT_BITS)-1;
        1: 3656:    bitmask = (1<<n_bits)-1;
        1: 3657:    oldcode = -1;
        1: 3658:    finchar = 0;
        1: 3659:    outpos = 0;
        1: 3660:    posbits = inptr<<3;
        -: 3661:
       1*: 3662:    free_ent = ((block_mode) ? FIRST : 256);
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -: 3663:    
        1: 3664:    clear_tab_prefixof(); /* Initialize the first 256 entries in the table. */
        -: 3665:    
      257: 3666:    for (code = 255 ; code >= 0 ; --code) {
branch  0 taken 256
branch  1 taken 1 (fallthrough)
      256: 3667:	tab_suffixof(code) = (char_type)code;
        -: 3668:    }
        -: 3669:    do {
        -: 3670:	REG1 int i;
        -: 3671:	int  e;
        -: 3672:	int  o;
        -: 3673:	
        1: 3674:    resetbuf:
        7: 3675:	e = insize-(o = (posbits>>3));
        -: 3676:	
    74495: 3677:	for (i = 0 ; i < e ; ++i) {
branch  0 taken 74488
branch  1 taken 7 (fallthrough)
    74488: 3678:	    inbuf[i] = inbuf[i+o];
        -: 3679:	}
        7: 3680:	insize = e;
        7: 3681:	posbits = 0;
        -: 3682:	
        7: 3683:	if (insize < INBUF_EXTRA) {
branch  0 taken 1 (fallthrough)
branch  1 taken 6
        1: 3684:	    if ((rsize = read(in, (char*)inbuf+insize, INBUFSIZ)) == EOF) {
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
    #####: 3685:		read_error();
call    0 never executed
        -: 3686:	    }
        1: 3687:	    insize += rsize;
        1: 3688:	    bytes_in += (ulg)rsize;
        -: 3689:	}
        7: 3690:	inbits = ((rsize != 0) ? ((long)insize - insize%n_bits)<<3 : 
branch  0 taken 6 (fallthrough)
branch  1 taken 1
        1: 3691:		  ((long)insize<<3)-(n_bits-1));
        -: 3692:	
    10145: 3693:	while (inbits > posbits) {
branch  0 taken 10143
branch  1 taken 2 (fallthrough)
    10143: 3694:	    if (free_ent > maxcode) {
branch  0 taken 5 (fallthrough)
branch  1 taken 10138
        5: 3695:		posbits = ((posbits-1) +
        5: 3696:			   ((n_bits<<3)-(posbits-1+(n_bits<<3))%(n_bits<<3)));
        5: 3697:		++n_bits;
        5: 3698:		if (n_bits == maxbits) {
branch  0 taken 0 (fallthrough)
branch  1 taken 5
    #####: 3699:		    maxcode = maxmaxcode;
        -: 3700:		} else {
        5: 3701:		    maxcode = MAXCODE(n_bits)-1;
        -: 3702:		}
        5: 3703:		bitmask = (1<<n_bits)-1;
        5: 3704:		goto resetbuf;
        -: 3705:	    }
    10138: 3706:	    input(inbuf,posbits,code,n_bits,bitmask);
        -: 3707:	    Tracev((stderr, "%d ", code));
        -: 3708:
    10138: 3709:	    if (oldcode == -1) {
branch  0 taken 1 (fallthrough)
branch  1 taken 10137
        -: 3710:#ifdef FAULTY_F_KL_1
        -: 3711:		if (code <= 256) error("corrupt input.");
        -: 3712:#else
       1*: 3713:		if (code >= 256) error("corrupt input.");
branch  0 taken 0 (fallthrough)
branch  1 taken 1
call    2 never executed
        -: 3714:#endif
        1: 3715:		outbuf[outpos++] = (char_type)(finchar = (int)(oldcode=code));
        1: 3716:		continue;
        -: 3717:	    }
   10137*: 3718:	    if (code == CLEAR && block_mode) {
branch  0 taken 0 (fallthrough)
branch  1 taken 10137
branch  2 never executed
branch  3 never executed
    #####: 3719:		clear_tab_prefixof();
    #####: 3720:		free_ent = FIRST - 1;
    #####: 3721:		posbits = ((posbits-1) +
    #####: 3722:			   ((n_bits<<3)-(posbits-1+(n_bits<<3))%(n_bits<<3)));
    #####: 3723:		maxcode = MAXCODE(n_bits = INIT_BITS)-1;
    #####: 3724:		bitmask = (1<<n_bits)-1;
    #####: 3725:		goto resetbuf;
        -: 3726:	    }
    10137: 3727:	    incode = code;
    10137: 3728:	    stackp = de_stack;
        -: 3729:	    
    10137: 3730:	    if (code >= free_ent) { /* Special case for KwKwK string. */
branch  0 taken 17 (fallthrough)
branch  1 taken 10120
       17: 3731:		if (code > free_ent) {
branch  0 taken 0 (fallthrough)
branch  1 taken 17
        -: 3732:#ifdef DEBUG		    
        -: 3733:		    char_type *p;
        -: 3734:
        -: 3735:		    posbits -= n_bits;
        -: 3736:		    p = &inbuf[posbits>>3];
        -: 3737:		    fprintf(stderr,
        -: 3738:			    "code:%ld free_ent:%ld n_bits:%d insize:%u\n",
        -: 3739:			    code, free_ent, n_bits, insize);
        -: 3740:		    fprintf(stderr,
        -: 3741:			    "posbits:%ld inbuf:%02X %02X %02X %02X %02X\n",
        -: 3742:			    posbits, p[-1],p[0],p[1],p[2],p[3]);
        -: 3743:#endif
    #####: 3744:		    if (!test && outpos > 0) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3745:			write_buf(out, (char*)outbuf, outpos);
call    0 never executed
    #####: 3746:			bytes_out += (ulg)outpos;
        -: 3747:		    }
    #####: 3748:		    error(to_stdout ? "corrupt input." :
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 3749:			  "corrupt input. Use zcat to recover some data.");
        -: 3750:		}
       17: 3751:		*--stackp = (char_type)finchar;
       17: 3752:		code = oldcode;
        -: 3753:	    }
        -: 3754:
    34213: 3755:	    while ((cmp_code_int)code >= (cmp_code_int)256) {
branch  0 taken 24076
branch  1 taken 10137 (fallthrough)
        -: 3756:		/* Generate output characters in reverse order */
    24076: 3757:		*--stackp = tab_suffixof(code);
    24076: 3758:		code = tab_prefixof(code);
        -: 3759:	    }
    10137: 3760:	    *--stackp =	(char_type)(finchar = tab_suffixof(code));
        -: 3761:	    
        -: 3762:	    /* And put them out in forward order */
        -: 3763:	    {
        -: 3764:		REG1 int	i;
        -: 3765:	    
    10137: 3766:		if (outpos+(i = (de_stack-stackp)) >= OUTBUFSIZ) {
branch  0 taken 2 (fallthrough)
branch  1 taken 10135
        -: 3767:		    do {
        4: 3768:			if (i > OUTBUFSIZ-outpos) i = OUTBUFSIZ-outpos;
branch  0 taken 2 (fallthrough)
branch  1 taken 2
        -: 3769:
        4: 3770:			if (i > 0) {
branch  0 taken 4 (fallthrough)
branch  1 taken 0
        4: 3771:			    memcpy(outbuf+outpos, stackp, i);
        4: 3772:			    outpos += i;
        -: 3773:			}
        4: 3774:			if (outpos >= OUTBUFSIZ) {
branch  0 taken 2 (fallthrough)
branch  1 taken 2
        2: 3775:			    if (!test) {
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2: 3776:				write_buf(out, (char*)outbuf, outpos);
call    0 returned 2
        2: 3777:				bytes_out += (ulg)outpos;
        -: 3778:			    }
        2: 3779:			    outpos = 0;
        -: 3780:			}
        4: 3781:			stackp+= i;
        4: 3782:		    } while ((i = (de_stack-stackp)) > 0);
branch  0 taken 2
branch  1 taken 2
        -: 3783:		} else {
    10135: 3784:		    memcpy(outbuf+outpos, stackp, i);
    10135: 3785:		    outpos += i;
        -: 3786:		}
        -: 3787:	    }
        -: 3788:
    10137: 3789:	    if ((code = free_ent) < maxmaxcode) { /* Generate the new entry. */
branch  0 taken 10137 (fallthrough)
branch  1 taken 0
        -: 3790:
    10137: 3791:		tab_prefixof(code) = (unsigned short)oldcode;
    10137: 3792:		tab_suffixof(code) = (char_type)finchar;
    10137: 3793:		free_ent = code+1;
        -: 3794:	    } 
    10137: 3795:	    oldcode = incode;	/* Remember previous code.	*/
        -: 3796:	}
        2: 3797:    } while (rsize != 0);
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        -: 3798:    
        1: 3799:    if (!test && outpos > 0) {
branch  0 taken 1 (fallthrough)
branch  1 taken 0
branch  2 taken 1 (fallthrough)
branch  3 taken 0
        1: 3800:	write_buf(out, (char*)outbuf, outpos);
call    0 returned 1
        1: 3801:	bytes_out += (ulg)outpos;
        -: 3802:    }
        1: 3803:    return OK;
        -: 3804:}
        -: 3805:/* unpack.c -- decompress files in pack format.
        -: 3806: * Copyright (C) 1992-1993 Jean-loup Gailly
        -: 3807: * This is free software; you can redistribute it and/or modify it under the
        -: 3808: * terms of the GNU General Public License, see the file COPYING.
        -: 3809: */
        -: 3810:
        -: 3811:#ifdef RCSID
        -: 3812:static char rcsid[] = "$Id: unpack.c,v 1.4 1993/06/11 19:25:36 jloup Exp $";
        -: 3813:#endif
        -: 3814:
        -: 3815:#define MIN(a,b) ((a) <= (b) ? (a) : (b))
        -: 3816:/* The arguments must not have side effects. */
        -: 3817:
        -: 3818:#define MAX_BITLEN 25
        -: 3819:/* Maximum length of Huffman codes. (Minor modifications to the code
        -: 3820: * would be needed to support 32 bits codes, but pack never generates
        -: 3821: * more than 24 bits anyway.)
        -: 3822: */
        -: 3823:
        -: 3824:#define LITERALS 256
        -: 3825:/* Number of literals, excluding the End of Block (EOB) code */
        -: 3826:
        -: 3827:#define MAX_PEEK 12
        -: 3828:/* Maximum number of 'peek' bits used to optimize traversal of the
        -: 3829: * Huffman tree.
        -: 3830: */
        -: 3831:
        -: 3832:local ulg orig_len;       /* original uncompressed length */
        -: 3833:local int max_len;        /* maximum bit length of Huffman codes */
        -: 3834:
        -: 3835:local uch literal[LITERALS];
        -: 3836:/* The literal bytes present in the Huffman tree. The EOB code is not
        -: 3837: * represented.
        -: 3838: */
        -: 3839:
        -: 3840:local int lit_base[MAX_BITLEN+1];
        -: 3841:/* All literals of a given bit length are contiguous in literal[] and
        -: 3842: * have contiguous codes. literal[code+lit_base[len]] is the literal
        -: 3843: * for a code of len bits.
        -: 3844: */
        -: 3845:
        -: 3846:local int leaves [MAX_BITLEN+1]; /* Number of leaves for each bit length */
        -: 3847:local int parents[MAX_BITLEN+1]; /* Number of parents for each bit length */
        -: 3848:
        -: 3849:local int peek_bits; /* Number of peek bits currently used */
        -: 3850:
        -: 3851:/* local uch prefix_len[1 << MAX_PEEK]; */
        -: 3852:#define prefix_len outbuf
        -: 3853:/* For each bit pattern b of peek_bits bits, prefix_len[b] is the length
        -: 3854: * of the Huffman code starting with a prefix of b (upper bits), or 0
        -: 3855: * if all codes of prefix b have more than peek_bits bits. It is not
        -: 3856: * necessary to have a huge table (large MAX_PEEK) because most of the
        -: 3857: * codes encountered in the input stream are short codes (by construction).
        -: 3858: * So for most codes a single lookup will be necessary.
        -: 3859: */
        -: 3860:#if (1<<MAX_PEEK) > OUTBUFSIZ
        -: 3861:    error cannot overlay prefix_len and outbuf
        -: 3862:#endif
        -: 3863:
        -: 3864:local ulg un_bitbuf;
        -: 3865:/* Bits are added on the low part of bitbuf and read from the high part. */
        -: 3866:
        -: 3867:local int valid;                  /* number of valid bits in bitbuf */
        -: 3868:/* all bits above the last valid bit are always zero */
        -: 3869:
        -: 3870:/* Set code to the next 'bits' input bits without skipping them. code
        -: 3871: * must be the name of a simple variable and bits must not have side effects.
        -: 3872: * IN assertions: bits <= 25 (so that we still have room for an extra byte
        -: 3873: * when valid is only 24), and mask = (1<<bits)-1.
        -: 3874: */
        -: 3875:#define look_bits(code,bits,mask) \
        -: 3876:{ \
        -: 3877:  while (valid < (bits)) un_bitbuf = (un_bitbuf<<8) | (ulg)get_byte(), valid += 8; \
        -: 3878:  code = (un_bitbuf >> (valid-(bits))) & (mask); \
        -: 3879:}
        -: 3880:
        -: 3881:/* Skip the given number of bits (after having peeked at them): */
        -: 3882:#define skip_bits(bits)  (valid -= (bits))
        -: 3883:
        -: 3884:#define clear_bitbuf() (valid = 0, un_bitbuf = 0)
        -: 3885:
        -: 3886:/* Local functions */
        -: 3887:
        -: 3888:local void read_tree  OF((void));
        -: 3889:local void un_build_tree OF((void));
        -: 3890:
        -: 3891:/* ===========================================================================
        -: 3892: * Read the Huffman tree.
        -: 3893: */
function read_tree called 1 returned 100% blocks executed 74%
        1: 3894:local void read_tree()
        -: 3895:{
        -: 3896:    int len;  /* bit length */
        -: 3897:    int base; /* base offset for a sequence of leaves */
        -: 3898:    int n;
        -: 3899:
        -: 3900:    /* Read the original input size, MSB first */
        1: 3901:    orig_len = 0;
       5*: 3902:    for (n = 1; n <= 4; n++) orig_len = (orig_len << 8) | (ulg)get_byte();
branch  0 taken 4 (fallthrough)
branch  1 taken 0
call    2 never executed
branch  3 taken 4
branch  4 taken 1 (fallthrough)
        -: 3903:
       1*: 3904:    max_len = (int)get_byte(); /* maximum bit length of Huffman codes */
branch  0 taken 1 (fallthrough)
branch  1 taken 0
call    2 never executed
        1: 3905:    if (max_len > MAX_BITLEN) {
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 3906:	error("invalid compressed data -- Huffman code > 32 bits");
call    0 never executed
        -: 3907:    }
        -: 3908:
        -: 3909:    /* Get the number of leaves at each bit length */
        1: 3910:    n = 0;
       17: 3911:    for (len = 1; len <= max_len; len++) {
branch  0 taken 16
branch  1 taken 1 (fallthrough)
      16*: 3912:	leaves[len] = (int)get_byte();
branch  0 taken 16 (fallthrough)
branch  1 taken 0
call    2 never executed
       16: 3913:	n += leaves[len];
        -: 3914:    }
        1: 3915:    if (n > LITERALS) {
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 3916:	error("too many leaves in Huffman tree");
call    0 never executed
        -: 3917:    }
        -: 3918:    Trace((stderr, "orig_len %ld, max_len %d, leaves %d\n",
        -: 3919:	   orig_len, max_len, n));
        -: 3920:    /* There are at least 2 and at most 256 leaves of length max_len.
        -: 3921:     * (Pack arbitrarily rejects empty files and files consisting of
        -: 3922:     * a single byte even repeated.) To fit the last leaf count in a
        -: 3923:     * byte, it is offset by 2. However, the last literal is the EOB
        -: 3924:     * code, and is not transmitted explicitly in the tree, so we must
        -: 3925:     * adjust here by one only.
        -: 3926:     */
        1: 3927:    leaves[max_len]++;
        -: 3928:
        -: 3929:    /* Now read the leaves themselves */
        1: 3930:    base = 0;
       17: 3931:    for (len = 1; len <= max_len; len++) {
branch  0 taken 16
branch  1 taken 1 (fallthrough)
        -: 3932:	/* Remember where the literals of this length start in literal[] : */
       16: 3933:	lit_base[len] = base;
        -: 3934:	/* And read the literals: */
      107: 3935:	for (n = leaves[len]; n > 0; n--) {
branch  0 taken 91
branch  1 taken 16 (fallthrough)
      91*: 3936:	    literal[base++] = (uch)get_byte();
branch  0 taken 91 (fallthrough)
branch  1 taken 0
call    2 never executed
        -: 3937:	}
        -: 3938:    }
        1: 3939:    leaves[max_len]++; /* Now include the EOB code in the Huffman tree */
        1: 3940:}
        -: 3941:
        -: 3942:/* ===========================================================================
        -: 3943: * Build the Huffman tree and the prefix table.
        -: 3944: */
function un_build_tree called 1 returned 100% blocks executed 100%
        1: 3945:local void un_build_tree()
        -: 3946:{
        1: 3947:    int nodes = 0; /* number of nodes (parents+leaves) at current bit length */
        -: 3948:    int len;       /* current bit length */
        -: 3949:    uch *prefixp;  /* pointer in prefix_len */
        -: 3950:
       17: 3951:    for (len = max_len; len >= 1; len--) {
branch  0 taken 16
branch  1 taken 1 (fallthrough)
        -: 3952:	/* The number of parent nodes at this level is half the total
        -: 3953:	 * number of nodes at parent level:
        -: 3954:	 */
       16: 3955:	nodes >>= 1;
       16: 3956:	parents[len] = nodes;
        -: 3957:	/* Update lit_base by the appropriate bias to skip the parent nodes
        -: 3958:	 * (which are not represented in the literal array):
        -: 3959:	 */
       16: 3960:	lit_base[len] -= nodes;
        -: 3961:	/* Restore nodes to be parents+leaves: */
       16: 3962:	nodes += leaves[len];
        -: 3963:    }
        -: 3964:    /* Construct the prefix table, from shortest leaves to longest ones.
        -: 3965:     * The shortest code is all ones, so we start at the end of the table.
        -: 3966:     */
        1: 3967:    peek_bits = MIN(max_len, MAX_PEEK);
        1: 3968:    prefixp = &prefix_len[1<<peek_bits];
       13: 3969:    for (len = 1; len <= peek_bits; len++) {
branch  0 taken 12
branch  1 taken 1 (fallthrough)
       12: 3970:	int prefixes = leaves[len] << (peek_bits-len); /* may be 0 */
     4103: 3971:	while (prefixes--) *--prefixp = (uch)len;
branch  0 taken 4091
branch  1 taken 12 (fallthrough)
        -: 3972:    }
        -: 3973:    /* The length of all other codes is unknown: */
        6: 3974:    while (prefixp > prefix_len) *--prefixp = 0;
branch  0 taken 5
branch  1 taken 1 (fallthrough)
        1: 3975:}
        -: 3976:
        -: 3977:/* ===========================================================================
        -: 3978: * Unpack in to out.  This routine does not support the old pack format
        -: 3979: * with magic header \037\037.
        -: 3980: *
        -: 3981: * IN assertions: the buffer inbuf contains already the beginning of
        -: 3982: *   the compressed data, from offsets inptr to insize-1 included.
        -: 3983: *   The magic header has already been checked. The output buffer is cleared.
        -: 3984: */
function unpack called 1 returned 100% blocks executed 84%
        1: 3985:int unpack(in, out)
        -: 3986:    int in, out;            /* input and output file descriptors */
        -: 3987:{
        -: 3988:    int len;                /* Bit length of current code */
        -: 3989:    unsigned eob;           /* End Of Block code */
        -: 3990:    register unsigned peek; /* lookahead bits */
        -: 3991:    unsigned peek_mask;     /* Mask for peek_bits bits */
        -: 3992:
        1: 3993:    ifd = in;
        1: 3994:    ofd = out;
        -: 3995:
        1: 3996:    read_tree();     /* Read the Huffman tree */
call    0 returned 1
        1: 3997:    un_build_tree();    /* Build the prefix table */
call    0 returned 1
        1: 3998:    clear_bitbuf();  /* Initialize bit input */
        1: 3999:    peek_mask = (1<<peek_bits)-1;
        -: 4000:
        -: 4001:    /* The eob code is the largest code among all leaves of maximal length: */
        1: 4002:    eob = leaves[max_len]-1;
        -: 4003:    Trace((stderr, "eob %d %x\n", max_len, eob));
        -: 4004:
        -: 4005:    /* Decode the input data: */
        -: 4006:    for (;;) {
        -: 4007:	/* Since eob is the longest code and not shorter than max_len,
        -: 4008:         * we can peek at max_len bits without having the risk of reading
        -: 4009:         * beyond the end of file.
        -: 4010:	 */
   54270*: 4011:	look_bits(peek, peek_bits, peek_mask);
branch  0 taken 20038 (fallthrough)
branch  1 taken 0
call    2 never executed
branch  3 taken 20038
branch  4 taken 34232 (fallthrough)
    34232: 4012:	len = prefix_len[peek];
    34232: 4013:	if (len > 0) {
branch  0 taken 34184 (fallthrough)
branch  1 taken 48
    34184: 4014:	    peek >>= peek_bits - len; /* discard the extra bits */
        -: 4015:	} else {
        -: 4016:	    /* Code of more than peek_bits bits, we must traverse the tree */
       48: 4017:	    ulg mask = peek_mask;
       48: 4018:	    len = peek_bits;
        -: 4019:	    do {
       76: 4020:                len++, mask = (mask<<1)+1;
      84*: 4021:		look_bits(peek, len, mask);
branch  0 taken 8 (fallthrough)
branch  1 taken 0
call    2 never executed
branch  3 taken 8
branch  4 taken 76 (fallthrough)
       76: 4022:	    } while (peek < (unsigned)parents[len]);
branch  0 taken 28
branch  1 taken 48 (fallthrough)
        -: 4023:	    /* loop as long as peek is a parent node */
        -: 4024:	}
        -: 4025:	/* At this point, peek is the next complete code, of len bits */
    34232: 4026:	if (peek == eob && len == max_len) break; /* end of file? */
branch  0 taken 2 (fallthrough)
branch  1 taken 34230
branch  2 taken 1 (fallthrough)
branch  3 taken 1
    34231: 4027:	put_ubyte(literal[peek+lit_base[len]]);
branch  0 taken 1 (fallthrough)
branch  1 taken 34230
call    2 returned 1
        -: 4028:	Tracev((stderr,"%02d %04x %c\n", len, peek,
        -: 4029:		literal[peek+lit_base[len]]));
    34231: 4030:	skip_bits(len);
        -: 4031:    } /* for (;;) */
        -: 4032:
        1: 4033:    flush_window();
call    0 returned 1
        -: 4034:    Trace((stderr, "bytes_out %ld\n", bytes_out));
        -: 4035:#ifndef FAULTY_F_KP_3
        1: 4036:    if (orig_len != (ulg)bytes_out) {
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -: 4037:#else
        -: 4038:    if (orig_len == (ulg)bytes_out) {
        -: 4039:#endif
    #####: 4040:	error("invalid compressed data--length error");
call    0 never executed
        -: 4041:    }
        1: 4042:    return OK;
        -: 4043:}
        -: 4044:/* unzip.c -- decompress files in gzip or pkzip format.
        -: 4045: * Copyright (C) 1992-1993 Jean-loup Gailly
        -: 4046: * This is free software; you can redistribute it and/or modify it under the
        -: 4047: * terms of the GNU General Public License, see the file COPYING.
        -: 4048: *
        -: 4049: * The code in this file is derived from the file funzip.c written
        -: 4050: * and put in the public domain by Mark Adler.
        -: 4051: */
        -: 4052:
        -: 4053:/*
        -: 4054:   This version can extract files in gzip or pkzip format.
        -: 4055:   For the latter, only the first entry is extracted, and it has to be
        -: 4056:   either deflated or stored.
        -: 4057: */
        -: 4058:
        -: 4059:#ifdef RCSID
        -: 4060:static char rcsid[] = "$Id: unzip.c,v 0.13 1993/06/10 13:29:00 jloup Exp $";
        -: 4061:#endif
        -: 4062:
        -: 4063:/* PKZIP header definitions */
        -: 4064:#define LOCSIG 0x04034b50L      /* four-byte lead-in (lsb first) */
        -: 4065:#define LOCFLG 6                /* offset of bit flag */
        -: 4066:#define  CRPFLG 1               /*  bit for encrypted entry */
        -: 4067:#define  EXTFLG 8               /*  bit for extended local header */
        -: 4068:#define LOCHOW 8                /* offset of compression method */
        -: 4069:#define LOCTIM 10               /* file mod time (for decryption) */
        -: 4070:#define LOCCRC 14               /* offset of crc */
        -: 4071:#define LOCSIZ 18               /* offset of compressed size */
        -: 4072:#define LOCLEN 22               /* offset of uncompressed length */
        -: 4073:#define LOCFIL 26               /* offset of file name field length */
        -: 4074:#define LOCEXT 28               /* offset of extra field length */
        -: 4075:#define LOCHDR 30               /* size of local header, including sig */
        -: 4076:#define EXTHDR 16               /* size of extended local header, inc sig */
        -: 4077:
        -: 4078:
        -: 4079:/* Globals */
        -: 4080:
        -: 4081:int decrypt;        /* flag to turn on decryption */
        -: 4082:char *key;          /* not used--needed to link crypt.c */
        -: 4083:int pkzip = 0;      /* set for a pkzip file */
        -: 4084:int ext_header = 0; /* set if extended local header */
        -: 4085:
        -: 4086:/* ===========================================================================
        -: 4087: * Check zip file and advance inptr to the start of the compressed data.
        -: 4088: * Get ofname from the local header if necessary.
        -: 4089: */
function check_zipfile called 2 returned 100% blocks executed 54%
        2: 4090:int check_zipfile(in)
        -: 4091:    int in;   /* input file descriptors */
        -: 4092:{
        2: 4093:    uch *h = inbuf + inptr; /* first local header */
        -: 4094:
        2: 4095:    ifd = in;
        -: 4096:
        -: 4097:    /* Check validity of local header, and skip name and extra fields */
        2: 4098:    inptr += LOCHDR + SH(h + LOCFIL) + SH(h + LOCEXT);
        -: 4099:
        2: 4100:    if (inptr > insize || LG(h) != LOCSIG) {
branch  0 taken 2 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 2
    #####: 4101:	fprintf(stderr, "\n%s: %s: not a valid zip file\n",
call    0 never executed
        -: 4102:		progname, ifname);
    #####: 4103:	exit_code = ERROR;
    #####: 4104:	return ERROR;
        -: 4105:    }
        2: 4106:    method = h[LOCHOW];
        2: 4107:    if (method != STORED && method != DEFLATED) {
branch  0 taken 2 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 2
    #####: 4108:	fprintf(stderr,
call    0 never executed
        -: 4109:		"\n%s: %s: first entry not deflated or stored -- use unzip\n",
        -: 4110:		progname, ifname);
    #####: 4111:	exit_code = ERROR;
    #####: 4112:	return ERROR;
        -: 4113:    }
        -: 4114:
        -: 4115:    /* If entry encrypted, decrypt and validate encryption header */
        2: 4116:    if ((decrypt = h[LOCFLG] & CRPFLG) != 0) {
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####: 4117:	fprintf(stderr, "\n%s: %s: encrypted file -- use unzip\n",
call    0 never executed
        -: 4118:		progname, ifname);
    #####: 4119:	exit_code = ERROR;
    #####: 4120:	return ERROR;
        -: 4121:    }
        -: 4122:
        -: 4123:    /* Save flags for unzip() */
        2: 4124:    ext_header = (h[LOCFLG] & EXTFLG) != 0;
        2: 4125:    pkzip = 1;
        -: 4126:
        -: 4127:    /* Get ofname and time stamp from local header (to be done) */
        2: 4128:    return OK;
        -: 4129:}
        -: 4130:
        -: 4131:/* ===========================================================================
        -: 4132: * Unzip in to out.  This routine works on both gzip and pkzip files.
        -: 4133: *
        -: 4134: * IN assertions: the buffer inbuf contains already the beginning of
        -: 4135: *   the compressed data, from offsets inptr to insize-1 included.
        -: 4136: *   The magic header has already been checked. The output buffer is cleared.
        -: 4137: */
function unzip called 12 returned 100% blocks executed 38%
       12: 4138:int unzip(in, out)
        -: 4139:    int in, out;   /* input and output file descriptors */
        -: 4140:{
       12: 4141:    ulg orig_crc = 0;       /* original crc */
       12: 4142:    ulg orig_len = 0;       /* original uncompressed length */
        -: 4143:    int n;
        -: 4144:    uch buf[EXTHDR];        /* extended local header */
        -: 4145:
       12: 4146:    ifd = in;
       12: 4147:    ofd = out;
        -: 4148:
       12: 4149:    updcrc(NULL, 0);           /* initialize crc */
call    0 returned 12
        -: 4150:
       12: 4151:    if (pkzip && !ext_header) {  /* crc and length at the end otherwise */
branch  0 taken 2 (fallthrough)
branch  1 taken 10
branch  2 taken 2 (fallthrough)
branch  3 taken 0
        2: 4152:	orig_crc = LG(inbuf + LOCCRC);
        2: 4153:	orig_len = LG(inbuf + LOCLEN);
        -: 4154:    }
        -: 4155:
        -: 4156:    /* Decompress */
       12: 4157:    if (method == DEFLATED)  {
branch  0 taken 12 (fallthrough)
branch  1 taken 0
        -: 4158:
       12: 4159:	int res = inflate();
call    0 returned 12
        -: 4160:
       12: 4161:	if (res == 3) {
branch  0 taken 0 (fallthrough)
branch  1 taken 12
    #####: 4162:	    error("out of memory");
call    0 never executed
       12: 4163:	} else if (res != 0) {
branch  0 taken 0 (fallthrough)
branch  1 taken 12
    #####: 4164:	    error("invalid compressed data--format violated");
call    0 never executed
        -: 4165:	}
        -: 4166:
    #####: 4167:    } else if (pkzip && method == STORED) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 4168:
    #####: 4169:	register ulg n = LG(inbuf + LOCLEN);
        -: 4170:
    #####: 4171:	if (n != LG(inbuf + LOCSIZ) - (decrypt ? RAND_HEAD_LEN : 0)) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 4172:
    #####: 4173:	    fprintf(stderr, "len %ld, siz %ld\n", n, LG(inbuf + LOCSIZ));
call    0 never executed
    #####: 4174:	    error("invalid compressed data--length mismatch");
call    0 never executed
        -: 4175:	}
    #####: 4176:	while (n--) {
branch  0 never executed
branch  1 never executed
    #####: 4177:	    uch c = (uch)get_byte();
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 4178:#ifdef CRYPT
        -: 4179:	    if (decrypt) zdecode(c);
        -: 4180:#endif
    #####: 4181:	    put_ubyte(c);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 4182:	}
    #####: 4183:	flush_window();
call    0 never executed
        -: 4184:    } else {
    #####: 4185:	error("internal error, invalid method");
call    0 never executed
        -: 4186:    }
        -: 4187:
        -: 4188:    /* Get the crc and original length */
       12: 4189:    if (!pkzip) {
branch  0 taken 10 (fallthrough)
branch  1 taken 2
        -: 4190:        /* crc32  (see algorithm.doc)
        -: 4191:	 * uncompressed input size modulo 2^32
        -: 4192:         */
       90: 4193:	for (n = 0; n < 8; n++) {
branch  0 taken 80
branch  1 taken 10 (fallthrough)
      80*: 4194:	    buf[n] = (uch)get_byte(); /* may cause an error if EOF */
branch  0 taken 80 (fallthrough)
branch  1 taken 0
call    2 never executed
        -: 4195:	}
       10: 4196:	orig_crc = LG(buf);
       10: 4197:	orig_len = LG(buf+4);
        -: 4198:
        2: 4199:    } else if (ext_header) {  /* If extended header, check it */
branch  0 taken 0 (fallthrough)
branch  1 taken 2
        -: 4200:	/* signature - 4bytes: 0x50 0x4b 0x07 0x08
        -: 4201:	 * CRC-32 value
        -: 4202:         * compressed size 4-bytes
        -: 4203:         * uncompressed size 4-bytes
        -: 4204:	 */
    #####: 4205:	for (n = 0; n < EXTHDR; n++) {
branch  0 never executed
branch  1 never executed
    #####: 4206:	    buf[n] = (uch)get_byte(); /* may cause an error if EOF */
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 4207:	}
    #####: 4208:	orig_crc = LG(buf+4);
    #####: 4209:	orig_len = LG(buf+12);
        -: 4210:    }
        -: 4211:
        -: 4212:    /* Validate decompression */
       12: 4213:    if (orig_crc != updcrc(outbuf, 0)) {
call    0 returned 12
branch  1 taken 0 (fallthrough)
branch  2 taken 12
    #####: 4214:	error("invalid compressed data--crc error");
call    0 never executed
        -: 4215:    }
       12: 4216:    if (orig_len != (ulg)bytes_out) {
branch  0 taken 0 (fallthrough)
branch  1 taken 12
    #####: 4217:	error("invalid compressed data--length error");
call    0 never executed
        -: 4218:    }
        -: 4219:
        -: 4220:    /* Check if there are more entries in a pkzip file */
       12: 4221:    if (pkzip && inptr + 4 < insize && LG(inbuf+inptr) == LOCSIG) {
branch  0 taken 2 (fallthrough)
branch  1 taken 10
branch  2 taken 2 (fallthrough)
branch  3 taken 0
branch  4 taken 0 (fallthrough)
branch  5 taken 2
    #####: 4222:	if (to_stdout) {
branch  0 never executed
branch  1 never executed
    #####: 4223:	    WARN((stderr,
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 4224:		  "%s: %s has more than one entry--rest ignored\n",
        -: 4225:		  progname, ifname));
        -: 4226:	} else {
        -: 4227:	    /* Don't destroy the input zip file */
    #####: 4228:	    fprintf(stderr,
call    0 never executed
        -: 4229:		    "%s: %s has more than one entry -- unchanged\n",
        -: 4230:		    progname, ifname);
    #####: 4231:	    exit_code = ERROR;
    #####: 4232:	    ext_header = pkzip = 0;
    #####: 4233:	    return ERROR;
        -: 4234:	}
        -: 4235:    }
       12: 4236:    ext_header = pkzip = 0; /* for next file */
       12: 4237:    return OK;
        -: 4238:}
        -: 4239:/* util.c -- utility functions for gzip support
        -: 4240: * Copyright (C) 1992-1993 Jean-loup Gailly
        -: 4241: * This is free software; you can redistribute it and/or modify it under the
        -: 4242: * terms of the GNU General Public License, see the file COPYING.
        -: 4243: */
        -: 4244:
        -: 4245:#ifdef RCSID
        -: 4246:static char rcsid[] = "$Id: util.c,v 0.15 1993/06/15 09:04:13 jloup Exp $";
        -: 4247:#endif
        -: 4248:
        -: 4249:#ifdef HAVE_UNISTD_H
        -: 4250:#  include <unistd.h>
        -: 4251:#endif
        -: 4252:#ifndef NO_FCNTL_H
        -: 4253:#  include <fcntl.h>
        -: 4254:#endif
        -: 4255:
        -: 4256:#if defined(STDC_HEADERS) || !defined(NO_STDLIB_H)
        -: 4257:#  include <stdlib.h>
        -: 4258:#else
        -: 4259:   extern int errno;
        -: 4260:#endif
        -: 4261:
        -: 4262:extern ulg crc_32_tab[];   /* crc table, defined below */
        -: 4263:
        -: 4264:/* ===========================================================================
        -: 4265: * Copy input to output unchanged: zcat == cat with --force.
        -: 4266: * IN assertion: insize bytes have already been read in inbuf.
        -: 4267: */
function copy called 0 returned 0% blocks executed 0%
    #####: 4268:int copy(in, out)
        -: 4269:    int in, out;   /* input and output file descriptors */
        -: 4270:{
    #####: 4271:    errno = 0;
    #####: 4272:    while (insize != 0 && (int)insize != EOF) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4273:	write_buf(out, (char*)inbuf, insize);
call    0 never executed
    #####: 4274:	bytes_out += insize;
    #####: 4275:	insize = read(in, (char*)inbuf, INBUFSIZ);
call    0 never executed
        -: 4276:    }
    #####: 4277:    if ((int)insize == EOF && errno != 0) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4278:	read_error();
call    0 never executed
        -: 4279:    }
    #####: 4280:    bytes_in = bytes_out;
    #####: 4281:    return OK;
        -: 4282:}
        -: 4283:
        -: 4284:/* ===========================================================================
        -: 4285: * Run a set of bytes through the crc shift register.  If s is a NULL
        -: 4286: * pointer, then initialize the crc shift register contents instead.
        -: 4287: * Return the current crc in either case.
        -: 4288: */
function updcrc called 3621 returned 100% blocks executed 100%
     3621: 4289:ulg updcrc(s, n)
        -: 4290:    uch *s;                 /* pointer to bytes to pump through */
        -: 4291:    unsigned n;             /* number of bytes in s[] */
        -: 4292:{
        -: 4293:    register ulg c;         /* temporary variable */
        -: 4294:
        -: 4295:    static ulg crc = (ulg)0xffffffffL; /* shift register contents */
        -: 4296:
     3621: 4297:    if (s == NULL) {
branch  0 taken 187 (fallthrough)
branch  1 taken 3434
      187: 4298:	c = 0xffffffffL;
        -: 4299:    } else {
     3434: 4300:	c = crc;
     3434: 4301:        if (n) do {
branch  0 taken 3422 (fallthrough)
branch  1 taken 12
111988194: 4302:            c = crc_32_tab[((int)c ^ (*s++)) & 0xff] ^ (c >> 8);
111988194: 4303:        } while (--n);
branch  0 taken 111984772
branch  1 taken 3422 (fallthrough)
        -: 4304:    }
     3621: 4305:    crc = c;
     3621: 4306:    return c ^ 0xffffffffL;       /* (instead of ~c for 64-bit machines) */
        -: 4307:}
        -: 4308:
        -: 4309:/* ===========================================================================
        -: 4310: * Clear input and output buffers
        -: 4311: */
function clear_bufs called 190 returned 100% blocks executed 100%
      190: 4312:void clear_bufs()
        -: 4313:{
      190: 4314:    outcnt = 0;
      190: 4315:    insize = inptr = 0;
      190: 4316:    bytes_in = bytes_out = 0L;
      190: 4317:}
        -: 4318:
        -: 4319:/* ===========================================================================
        -: 4320: * Fill the input buffer. This is called only when the buffer is empty.
        -: 4321: */
function fill_inbuf called 17 returned 94% blocks executed 91%
       17: 4322:int fill_inbuf(eof_ok)
        -: 4323:    int eof_ok;          /* set if EOF acceptable as a result */
        -: 4324:{
        -: 4325:    int len;
        -: 4326:
        -: 4327:    /* Read as much as possible */
       17: 4328:    insize = 0;
       17: 4329:    errno = 0;
        -: 4330:    do {
       31: 4331:	len = read(ifd, (char*)inbuf+insize, INBUFSIZ-insize);
call    0 returned 31
       31: 4332:        if (len == 0 || len == EOF) break;
branch  0 taken 16 (fallthrough)
branch  1 taken 15
branch  2 taken 16 (fallthrough)
branch  3 taken 0
       16: 4333:	insize += len;
       16: 4334:    } while (insize < INBUFSIZ);
branch  0 taken 14
branch  1 taken 2 (fallthrough)
        -: 4335:
       17: 4336:    if (insize == 0) {
branch  0 taken 1 (fallthrough)
branch  1 taken 16
       1*: 4337:	if (eof_ok) return EOF;
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        1: 4338:	read_error();
call    0 returned 0
        -: 4339:    }
       16: 4340:    bytes_in += (ulg)insize;
       16: 4341:    inptr = 1;
       16: 4342:    return inbuf[0];
        -: 4343:}
        -: 4344:
        -: 4345:/* ===========================================================================
        -: 4346: * Write the output buffer outbuf[0..outcnt-1] and update bytes_out.
        -: 4347: * (used for the compressed data only)
        -: 4348: */
function flush_outbuf called 192 returned 100% blocks executed 80%
      192: 4349:void flush_outbuf()
        -: 4350:{
     192*: 4351:    if (outcnt == 0) return;
branch  0 taken 0 (fallthrough)
branch  1 taken 192
        -: 4352:
      192: 4353:    write_buf(ofd, (char *)outbuf, outcnt);
call    0 returned 192
      192: 4354:    bytes_out += (ulg)outcnt;
      192: 4355:    outcnt = 0;
        -: 4356:}
        -: 4357:
        -: 4358:/* ===========================================================================
        -: 4359: * Write the output window window[0..outcnt-1] and update crc and bytes_out.
        -: 4360: * (Used for the decompressed data only.)
        -: 4361: */
function flush_window called 27 returned 100% blocks executed 86%
       27: 4362:void flush_window()
        -: 4363:{
      27*: 4364:    if (outcnt == 0) return;
branch  0 taken 0 (fallthrough)
branch  1 taken 27
       27: 4365:    updcrc(window, outcnt);
call    0 returned 27
        -: 4366:
       27: 4367:    if (!test) {
branch  0 taken 21 (fallthrough)
branch  1 taken 6
       21: 4368:	write_buf(ofd, (char *)window, outcnt);
call    0 returned 21
        -: 4369:    }
       27: 4370:    bytes_out += (ulg)outcnt;
       27: 4371:    outcnt = 0;
        -: 4372:}
        -: 4373:
        -: 4374:/* ===========================================================================
        -: 4375: * Does the same as write(), but also handles partial pipe writes and checks
        -: 4376: * for error return.
        -: 4377: */
function write_buf called 216 returned 100% blocks executed 57%
      216: 4378:void write_buf(fd, buf, cnt)
        -: 4379:    int       fd;
        -: 4380:    voidp     buf;
        -: 4381:    unsigned  cnt;
        -: 4382:{
        -: 4383:    unsigned  n;
        -: 4384:
      216: 4385:    while ((n = write(fd, buf, cnt)) != cnt) {
call    0 returned 216
branch  1 taken 0
branch  2 taken 216 (fallthrough)
    #####: 4386:	if (n == (unsigned)(-1)) {
branch  0 never executed
branch  1 never executed
    #####: 4387:	    write_error();
call    0 never executed
        -: 4388:	}
    #####: 4389:	cnt -= n;
    #####: 4390:	buf = (voidp)((char*)buf+n);
        -: 4391:    }
      216: 4392:}
        -: 4393:
        -: 4394:/* ========================================================================
        -: 4395: * Put string s in lower case, return s.
        -: 4396: */
function strlwr called 6 returned 100% blocks executed 88%
        6: 4397:char *strlwr(s)
        -: 4398:    char *s;
        -: 4399:{
        -: 4400:    char *t;
     150*: 4401:    for (t = s; *t; t++) *t = tolow(*t);
branch  0 taken 0 (fallthrough)
branch  1 taken 144
branch  2 taken 144
branch  3 taken 6 (fallthrough)
        6: 4402:    return s;
        -: 4403:}
        -: 4404:
        -: 4405:/* ========================================================================
        -: 4406: * Return the base name of a file (remove any directory prefix and
        -: 4407: * any version suffix). For systems with file names that are not
        -: 4408: * case sensitive, force the base name to lower case.
        -: 4409: */
function basename called 215 returned 100% blocks executed 100%
      215: 4410:char *basename(fname)
        -: 4411:    char *fname;
        -: 4412:{
        -: 4413:    char *p;
        -: 4414:
      215: 4415:    if ((p = strrchr(fname, PATH_SEP))  != NULL) fname = p+1;
branch  0 taken 215 (fallthrough)
branch  1 taken 0
        -: 4416:#ifdef PATH_SEP2
        -: 4417:    if ((p = strrchr(fname, PATH_SEP2)) != NULL) fname = p+1;
        -: 4418:#endif
        -: 4419:#ifdef PATH_SEP3
        -: 4420:    if ((p = strrchr(fname, PATH_SEP3)) != NULL) fname = p+1;
        -: 4421:#endif
        -: 4422:#ifdef SUFFIX_SEP
        -: 4423:    if ((p = strrchr(fname, SUFFIX_SEP)) != NULL) *p = '\0';
        -: 4424:#endif
        -: 4425:    if (casemap('A') == 'a') strlwr(fname);
      215: 4426:    return fname;
        -: 4427:}
        -: 4428:
        -: 4429:/* ========================================================================
        -: 4430: * Make a file name legal for file systems not allowing file names with
        -: 4431: * multiple dots or starting with a dot (such as MSDOS), by changing
        -: 4432: * all dots except the last one into underlines.  A target dependent
        -: 4433: * function can be used instead of this simple function by defining the macro
        -: 4434: * MAKE_LEGAL_NAME in tailor.h and providing the function in a target
        -: 4435: * dependent module.
        -: 4436: */
function make_simple_name called 0 returned 0% blocks executed 0%
    #####: 4437:void make_simple_name(name)
        -: 4438:    char *name;
        -: 4439:{
    #####: 4440:    char *p = strrchr(name, '.');
    #####: 4441:    if (p == NULL) return;
branch  0 never executed
branch  1 never executed
    #####: 4442:    if (p == name) p++;
branch  0 never executed
branch  1 never executed
        -: 4443:    do {
    #####: 4444:        if (*--p == '.') *p = '_';
branch  0 never executed
branch  1 never executed
    #####: 4445:    } while (p != name);
branch  0 never executed
branch  1 never executed
        -: 4446:}
        -: 4447:
        -: 4448:
        -: 4449:#if defined(NO_STRING_H) && !defined(STDC_HEADERS)
        -: 4450:
        -: 4451:/* Provide missing strspn and strcspn functions. */
        -: 4452:
        -: 4453:#  ifndef __STDC__
        -: 4454:#    define const
        -: 4455:#  endif
        -: 4456:
        -: 4457:int strspn  OF((const char *s, const char *accept));
        -: 4458:int strcspn OF((const char *s, const char *reject));
        -: 4459:
        -: 4460:/* ========================================================================
        -: 4461: * Return the length of the maximum initial segment
        -: 4462: * of s which contains only characters in accept.
        -: 4463: */
        -: 4464:int strspn(s, accept)
        -: 4465:    const char *s;
        -: 4466:    const char *accept;
        -: 4467:{
        -: 4468:    register const char *p;
        -: 4469:    register const char *a;
        -: 4470:    register int count = 0;
        -: 4471:
        -: 4472:    for (p = s; *p != '\0'; ++p) {
        -: 4473:	for (a = accept; *a != '\0'; ++a) {
        -: 4474:	    if (*p == *a) break;
        -: 4475:	}
        -: 4476:	if (*a == '\0') return count;
        -: 4477:	++count;
        -: 4478:    }
        -: 4479:    return count;
        -: 4480:}
        -: 4481:
        -: 4482:/* ========================================================================
        -: 4483: * Return the length of the maximum inital segment of s
        -: 4484: * which contains no characters from reject.
        -: 4485: */
        -: 4486:int strcspn(s, reject)
        -: 4487:    const char *s;
        -: 4488:    const char *reject;
        -: 4489:{
        -: 4490:    register int count = 0;
        -: 4491:
        -: 4492:    while (*s != '\0') {
        -: 4493:	if (strchr(reject, *s++) != NULL) return count;
        -: 4494:	++count;
        -: 4495:    }
        -: 4496:    return count;
        -: 4497:}
        -: 4498:
        -: 4499:#endif /* NO_STRING_H */
        -: 4500:
        -: 4501:/* ========================================================================
        -: 4502: * Add an environment variable (if any) before argv, and update argc.
        -: 4503: * Return the expanded environment variable to be freed later, or NULL 
        -: 4504: * if no options were added to argv.
        -: 4505: */
        -: 4506:#define SEPARATOR	" \t"	/* separators in env variable */
        -: 4507:
function add_envopt called 214 returned 100% blocks executed 15%
      214: 4508:char *add_envopt(argcp, argvp, env)
        -: 4509:    int *argcp;          /* pointer to argc */
        -: 4510:    char ***argvp;       /* pointer to argv */
        -: 4511:    char *env;           /* name of environment variable */
        -: 4512:{
        -: 4513:    char *p;             /* running pointer through env variable */
        -: 4514:    char **oargv;        /* runs through old argv array */
        -: 4515:    char **nargv;        /* runs through new argv array */
      214: 4516:    int	 oargc = *argcp; /* old argc */
      214: 4517:    int  nargc = 0;      /* number of arguments in env variable */
        -: 4518:
      214: 4519:    env = (char*)getenv(env);
call    0 returned 214
      214: 4520:    if (env == NULL) return NULL;
branch  0 taken 214 (fallthrough)
branch  1 taken 0
        -: 4521:
    #####: 4522:    p = (char*)xmalloc(strlen(env)+1);
call    0 never executed
    #####: 4523:    env = strcpy(p, env);                    /* keep env variable intact */
        -: 4524:
    #####: 4525:    for (p = env; *p; nargc++ ) {            /* move through env */
branch  0 never executed
branch  1 never executed
    #####: 4526:	p += strspn(p, SEPARATOR);	     /* skip leading separators */
    #####: 4527:	if (*p == '\0') break;
branch  0 never executed
branch  1 never executed
        -: 4528:
    #####: 4529:	p += strcspn(p, SEPARATOR);	     /* find end of word */
    #####: 4530:	if (*p) *p++ = '\0';		     /* mark it */
branch  0 never executed
branch  1 never executed
        -: 4531:    }
    #####: 4532:    if (nargc == 0) {
branch  0 never executed
branch  1 never executed
    #####: 4533:	free(env);
    #####: 4534:	return NULL;
        -: 4535:    }
    #####: 4536:    *argcp += nargc;
        -: 4537:    /* Allocate the new argv array, with an extra element just in case
        -: 4538:     * the original arg list did not end with a NULL.
        -: 4539:     */
    #####: 4540:    nargv = (char**)calloc(*argcp+1, sizeof(char *));
    #####: 4541:    if (nargv == NULL) error("out of memory");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 4542:    oargv  = *argvp;
    #####: 4543:    *argvp = nargv;
        -: 4544:
        -: 4545:    /* Copy the program name first */
    #####: 4546:    if (oargc-- < 0) error("argc<=0");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 4547:    *(nargv++) = *(oargv++);
        -: 4548:
        -: 4549:    /* Then copy the environment args */
    #####: 4550:    for (p = env; nargc > 0; nargc--) {
branch  0 never executed
branch  1 never executed
    #####: 4551:	p += strspn(p, SEPARATOR);	     /* skip separators */
    #####: 4552:	*(nargv++) = p;			     /* store start */
    #####: 4553:	while (*p++) ;			     /* skip over word */
branch  0 never executed
branch  1 never executed
        -: 4554:    }
        -: 4555:
        -: 4556:    /* Finally copy the old args and add a NULL (usual convention) */
    #####: 4557:    while (oargc--) *(nargv++) = *(oargv++);
branch  0 never executed
branch  1 never executed
    #####: 4558:    *nargv = NULL;
    #####: 4559:    return env;
        -: 4560:}
        -: 4561:
        -: 4562:/* ========================================================================
        -: 4563: * Error handlers.
        -: 4564: */
function error called 0 returned 0% blocks executed 0%
    #####: 4565:void error(m)
        -: 4566:    char *m;
        -: 4567:{
    #####: 4568:    fprintf(stderr, "\n%s: %s: %s\n", progname, ifname, m);
call    0 never executed
    #####: 4569:    abort_gzip();
call    0 never executed
    #####: 4570:}
        -: 4571:
function warn called 0 returned 0% blocks executed 0%
    #####: 4572:void warn(a, b)
        -: 4573:    char *a, *b;            /* message strings juxtaposed in output */
        -: 4574:{
    #####: 4575:    WARN((stderr, "%s: %s: warning: %s%s\n", progname, ifname, a, b));
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 4576:}
        -: 4577:
function read_error called 1 returned 0% blocks executed 83%
        1: 4578:void read_error()
        -: 4579:{
        1: 4580:    fprintf(stderr, "\n%s: ", progname);
call    0 returned 1
        1: 4581:    if (errno != 0) {
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 4582:	perror(ifname);
call    0 never executed
        -: 4583:    } else {
        1: 4584:	fprintf(stderr, "%s: unexpected end of file\n", ifname);
call    0 returned 1
        -: 4585:    }
        1: 4586:    abort_gzip();
call    0 returned 0
    #####: 4587:}
        -: 4588:
function write_error called 0 returned 0% blocks executed 0%
    #####: 4589:void write_error()
        -: 4590:{
    #####: 4591:    fprintf(stderr, "\n%s: ", progname);
call    0 never executed
    #####: 4592:    perror(ofname);
call    0 never executed
    #####: 4593:    abort_gzip();
call    0 never executed
    #####: 4594:}
        -: 4595:
        -: 4596:/* ========================================================================
        -: 4597: * Display compression ratio on the given stream on 6 characters.
        -: 4598: */
function display_ratio called 81 returned 100% blocks executed 64%
       81: 4599:void display_ratio(num, den, file)
        -: 4600:    long num;
        -: 4601:    long den;
        -: 4602:    FILE *file;
        -: 4603:{
        -: 4604:    long ratio;  /* 1000 times the compression ratio */
        -: 4605:
       81: 4606:    if (den == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 81
        -: 4607:	{
    #####: 4608:	ratio = 0; /* no compression */
       81: 4609:    } else if (den < 2147483L) { /* (2**31 -1)/1000 */
branch  0 taken 81 (fallthrough)
branch  1 taken 0
       81: 4610:	ratio = 1000L*num/den;
        -: 4611:    } else {
    #####: 4612:	ratio = num/(den/1000L);
        -: 4613:    }
       81: 4614:    if (ratio < 0) {
branch  0 taken 0 (fallthrough)
branch  1 taken 81
    #####: 4615:	putc('-', file);
call    0 never executed
    #####: 4616:	ratio = -ratio;
        -: 4617:    } else {
       81: 4618:	putc(' ', file);
call    0 returned 81
        -: 4619:    }
       81: 4620:    fprintf(file, "%2ld.%1ld%%", ratio / 10L, ratio % 10L);
call    0 returned 81
       81: 4621:}
        -: 4622:
        -: 4623:
        -: 4624:/* ========================================================================
        -: 4625: * Semi-safe malloc -- never returns NULL.
        -: 4626: */
function xmalloc called 0 returned 0% blocks executed 0%
    #####: 4627:voidp xmalloc (size)
        -: 4628:    unsigned size;
        -: 4629:{
    #####: 4630:    voidp cp = (voidp)malloc (size);
        -: 4631:
    #####: 4632:    if (cp == NULL) error("out of memory");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 4633:    return cp;
        -: 4634:}
        -: 4635:
        -: 4636:/* ========================================================================
        -: 4637: * Table of CRC-32's of all single-byte values (made by makecrc.c)
        -: 4638: */
        -: 4639:ulg crc_32_tab[] = {
        -: 4640:  0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL, 0x076dc419L,
        -: 4641:  0x706af48fL, 0xe963a535L, 0x9e6495a3L, 0x0edb8832L, 0x79dcb8a4L,
        -: 4642:  0xe0d5e91eL, 0x97d2d988L, 0x09b64c2bL, 0x7eb17cbdL, 0xe7b82d07L,
        -: 4643:  0x90bf1d91L, 0x1db71064L, 0x6ab020f2L, 0xf3b97148L, 0x84be41deL,
        -: 4644:  0x1adad47dL, 0x6ddde4ebL, 0xf4d4b551L, 0x83d385c7L, 0x136c9856L,
        -: 4645:  0x646ba8c0L, 0xfd62f97aL, 0x8a65c9ecL, 0x14015c4fL, 0x63066cd9L,
        -: 4646:  0xfa0f3d63L, 0x8d080df5L, 0x3b6e20c8L, 0x4c69105eL, 0xd56041e4L,
        -: 4647:  0xa2677172L, 0x3c03e4d1L, 0x4b04d447L, 0xd20d85fdL, 0xa50ab56bL,
        -: 4648:  0x35b5a8faL, 0x42b2986cL, 0xdbbbc9d6L, 0xacbcf940L, 0x32d86ce3L,
        -: 4649:  0x45df5c75L, 0xdcd60dcfL, 0xabd13d59L, 0x26d930acL, 0x51de003aL,
        -: 4650:  0xc8d75180L, 0xbfd06116L, 0x21b4f4b5L, 0x56b3c423L, 0xcfba9599L,
        -: 4651:  0xb8bda50fL, 0x2802b89eL, 0x5f058808L, 0xc60cd9b2L, 0xb10be924L,
        -: 4652:  0x2f6f7c87L, 0x58684c11L, 0xc1611dabL, 0xb6662d3dL, 0x76dc4190L,
        -: 4653:  0x01db7106L, 0x98d220bcL, 0xefd5102aL, 0x71b18589L, 0x06b6b51fL,
        -: 4654:  0x9fbfe4a5L, 0xe8b8d433L, 0x7807c9a2L, 0x0f00f934L, 0x9609a88eL,
        -: 4655:  0xe10e9818L, 0x7f6a0dbbL, 0x086d3d2dL, 0x91646c97L, 0xe6635c01L,
        -: 4656:  0x6b6b51f4L, 0x1c6c6162L, 0x856530d8L, 0xf262004eL, 0x6c0695edL,
        -: 4657:  0x1b01a57bL, 0x8208f4c1L, 0xf50fc457L, 0x65b0d9c6L, 0x12b7e950L,
        -: 4658:  0x8bbeb8eaL, 0xfcb9887cL, 0x62dd1ddfL, 0x15da2d49L, 0x8cd37cf3L,
        -: 4659:  0xfbd44c65L, 0x4db26158L, 0x3ab551ceL, 0xa3bc0074L, 0xd4bb30e2L,
        -: 4660:  0x4adfa541L, 0x3dd895d7L, 0xa4d1c46dL, 0xd3d6f4fbL, 0x4369e96aL,
        -: 4661:  0x346ed9fcL, 0xad678846L, 0xda60b8d0L, 0x44042d73L, 0x33031de5L,
        -: 4662:  0xaa0a4c5fL, 0xdd0d7cc9L, 0x5005713cL, 0x270241aaL, 0xbe0b1010L,
        -: 4663:  0xc90c2086L, 0x5768b525L, 0x206f85b3L, 0xb966d409L, 0xce61e49fL,
        -: 4664:  0x5edef90eL, 0x29d9c998L, 0xb0d09822L, 0xc7d7a8b4L, 0x59b33d17L,
        -: 4665:  0x2eb40d81L, 0xb7bd5c3bL, 0xc0ba6cadL, 0xedb88320L, 0x9abfb3b6L,
        -: 4666:  0x03b6e20cL, 0x74b1d29aL, 0xead54739L, 0x9dd277afL, 0x04db2615L,
        -: 4667:  0x73dc1683L, 0xe3630b12L, 0x94643b84L, 0x0d6d6a3eL, 0x7a6a5aa8L,
        -: 4668:  0xe40ecf0bL, 0x9309ff9dL, 0x0a00ae27L, 0x7d079eb1L, 0xf00f9344L,
        -: 4669:  0x8708a3d2L, 0x1e01f268L, 0x6906c2feL, 0xf762575dL, 0x806567cbL,
        -: 4670:  0x196c3671L, 0x6e6b06e7L, 0xfed41b76L, 0x89d32be0L, 0x10da7a5aL,
        -: 4671:  0x67dd4accL, 0xf9b9df6fL, 0x8ebeeff9L, 0x17b7be43L, 0x60b08ed5L,
        -: 4672:  0xd6d6a3e8L, 0xa1d1937eL, 0x38d8c2c4L, 0x4fdff252L, 0xd1bb67f1L,
        -: 4673:  0xa6bc5767L, 0x3fb506ddL, 0x48b2364bL, 0xd80d2bdaL, 0xaf0a1b4cL,
        -: 4674:  0x36034af6L, 0x41047a60L, 0xdf60efc3L, 0xa867df55L, 0x316e8eefL,
        -: 4675:  0x4669be79L, 0xcb61b38cL, 0xbc66831aL, 0x256fd2a0L, 0x5268e236L,
        -: 4676:  0xcc0c7795L, 0xbb0b4703L, 0x220216b9L, 0x5505262fL, 0xc5ba3bbeL,
        -: 4677:  0xb2bd0b28L, 0x2bb45a92L, 0x5cb36a04L, 0xc2d7ffa7L, 0xb5d0cf31L,
        -: 4678:  0x2cd99e8bL, 0x5bdeae1dL, 0x9b64c2b0L, 0xec63f226L, 0x756aa39cL,
        -: 4679:  0x026d930aL, 0x9c0906a9L, 0xeb0e363fL, 0x72076785L, 0x05005713L,
        -: 4680:  0x95bf4a82L, 0xe2b87a14L, 0x7bb12baeL, 0x0cb61b38L, 0x92d28e9bL,
        -: 4681:  0xe5d5be0dL, 0x7cdcefb7L, 0x0bdbdf21L, 0x86d3d2d4L, 0xf1d4e242L,
        -: 4682:  0x68ddb3f8L, 0x1fda836eL, 0x81be16cdL, 0xf6b9265bL, 0x6fb077e1L,
        -: 4683:  0x18b74777L, 0x88085ae6L, 0xff0f6a70L, 0x66063bcaL, 0x11010b5cL,
        -: 4684:  0x8f659effL, 0xf862ae69L, 0x616bffd3L, 0x166ccf45L, 0xa00ae278L,
        -: 4685:  0xd70dd2eeL, 0x4e048354L, 0x3903b3c2L, 0xa7672661L, 0xd06016f7L,
        -: 4686:  0x4969474dL, 0x3e6e77dbL, 0xaed16a4aL, 0xd9d65adcL, 0x40df0b66L,
        -: 4687:  0x37d83bf0L, 0xa9bcae53L, 0xdebb9ec5L, 0x47b2cf7fL, 0x30b5ffe9L,
        -: 4688:  0xbdbdf21cL, 0xcabac28aL, 0x53b39330L, 0x24b4a3a6L, 0xbad03605L,
        -: 4689:  0xcdd70693L, 0x54de5729L, 0x23d967bfL, 0xb3667a2eL, 0xc4614ab8L,
        -: 4690:  0x5d681b02L, 0x2a6f2b94L, 0xb40bbe37L, 0xc30c8ea1L, 0x5a05df1bL,
        -: 4691:  0x2d02ef8dL
        -: 4692:};
        -: 4693:/* zip.c -- compress files to the gzip or pkzip format
        -: 4694: * Copyright (C) 1992-1993 Jean-loup Gailly
        -: 4695: * This is free software; you can redistribute it and/or modify it under the
        -: 4696: * terms of the GNU General Public License, see the file COPYING.
        -: 4697: */
        -: 4698:
        -: 4699:#ifdef RCSID
        -: 4700:static char rcsid[] = "$Id: zip.c,v 0.17 1993/06/10 13:29:25 jloup Exp $";
        -: 4701:#endif
        -: 4702:
        -: 4703:#ifdef HAVE_UNISTD_H
        -: 4704:#  include <unistd.h>
        -: 4705:#endif
        -: 4706:#ifndef NO_FCNTL_H
        -: 4707:#  include <fcntl.h>
        -: 4708:#endif
        -: 4709:
        -: 4710:local ulg crc;       /* crc on uncompressed file data */
        -: 4711:long header_bytes;   /* number of bytes in gzip header */
        -: 4712:
        -: 4713:/* ===========================================================================
        -: 4714: * Deflate in to out.
        -: 4715: * IN assertions: the input and output buffers are cleared.
        -: 4716: *   The variables time_stamp and save_orig_name are initialized.
        -: 4717: */
function zip called 175 returned 100% blocks executed 51%
      175: 4718:int zip(in, out)
        -: 4719:    int in, out;            /* input and output file descriptors */
        -: 4720:{
      175: 4721:    uch  flags = 0;         /* general purpose bit flags */
      175: 4722:    ush  attr = 0;          /* ascii/binary flag */
      175: 4723:    ush  deflate_flags = 0; /* pkzip -es, -en or -ex equivalent */
        -: 4724:
      175: 4725:    ifd = in;
      175: 4726:    ofd = out;
      175: 4727:    outcnt = 0;
        -: 4728:
        -: 4729:    /* Write the header to the gzip file. See algorithm.doc for the format */
        -: 4730:
      175: 4731:    method = DEFLATED;
     175*: 4732:    put_byte(GZIP_MAGIC[0]); /* magic header */
branch  0 taken 0 (fallthrough)
branch  1 taken 175
call    2 never executed
     175*: 4733:    put_byte(GZIP_MAGIC[1]);
branch  0 taken 0 (fallthrough)
branch  1 taken 175
call    2 never executed
     175*: 4734:    put_byte(DEFLATED);      /* compression method */
branch  0 taken 0 (fallthrough)
branch  1 taken 175
call    2 never executed
        -: 4735:
      175: 4736:    if (save_orig_name) {
branch  0 taken 1 (fallthrough)
branch  1 taken 174
        1: 4737:	flags |= ORIG_NAME;
        -: 4738:    }
     175*: 4739:    put_byte(flags);         /* general flags */
branch  0 taken 0 (fallthrough)
branch  1 taken 175
call    2 never executed
     175*: 4740:    put_long(time_stamp);
branch  0 taken 175 (fallthrough)
branch  1 taken 0
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
branch  8 taken 175 (fallthrough)
branch  9 taken 0
branch 10 never executed
branch 11 never executed
call   12 never executed
branch 13 never executed
branch 14 never executed
call   15 never executed
        -: 4741:
        -: 4742:    /* Write deflated file to zip file */
      175: 4743:    crc = updcrc(0, 0);
call    0 returned 175
        -: 4744:
      175: 4745:    bi_init(out);
call    0 returned 175
      175: 4746:    ct_init(&attr, &method);
call    0 returned 175
      175: 4747:    lm_init(level, &deflate_flags);
call    0 returned 175
        -: 4748:
     175*: 4749:    put_byte((uch)deflate_flags); /* extra flags */
branch  0 taken 0 (fallthrough)
branch  1 taken 175
call    2 never executed
     175*: 4750:    put_byte(OS_CODE);            /* OS identifier */
branch  0 taken 0 (fallthrough)
branch  1 taken 175
call    2 never executed
        -: 4751:
      175: 4752:    if (save_orig_name) {
branch  0 taken 1 (fallthrough)
branch  1 taken 174
        1: 4753:	char *p = basename(ifname); /* Don't save the directory part. */
call    0 returned 1
        -: 4754:	do {
       7*: 4755:	    put_char(*p);
branch  0 taken 0 (fallthrough)
branch  1 taken 7
call    2 never executed
        7: 4756:	} while (*p++);
branch  0 taken 6
branch  1 taken 1 (fallthrough)
        -: 4757:    }
      175: 4758:    header_bytes = (long)outcnt;
        -: 4759:
      175: 4760:    (void)deflate();
call    0 returned 175
        -: 4761:
        -: 4762:#if !defined(NO_SIZE_CHECK) && !defined(RECORD_IO)
        -: 4763:  /* Check input size (but not in VMS -- variable record lengths mess it up)
        -: 4764:   * and not on MSDOS -- diet in TSR mode reports an incorrect file size)
        -: 4765:   */
        -: 4766:    if (ifile_size != -1L && isize != (ulg)ifile_size) {
        -: 4767:	Trace((stderr, " actual=%ld, read=%ld ", ifile_size, isize));
        -: 4768:	fprintf(stderr, "%s: %s: file size changed while zipping\n",
        -: 4769:		progname, ifname);
        -: 4770:    }
        -: 4771:#endif
        -: 4772:
        -: 4773:    /* Write the crc and uncompressed size */
     175*: 4774:    put_long(crc);
branch  0 taken 175 (fallthrough)
branch  1 taken 0
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
branch  8 taken 175 (fallthrough)
branch  9 taken 0
branch 10 never executed
branch 11 never executed
call   12 never executed
branch 13 never executed
branch 14 never executed
call   15 never executed
     175*: 4775:    put_long(isize);
branch  0 taken 175 (fallthrough)
branch  1 taken 0
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
branch  8 taken 175 (fallthrough)
branch  9 taken 0
branch 10 never executed
branch 11 never executed
call   12 never executed
branch 13 never executed
branch 14 never executed
call   15 never executed
      175: 4776:    header_bytes += 2*sizeof(long);
        -: 4777:
      175: 4778:    flush_outbuf();
call    0 returned 175
      175: 4779:    return OK;
        -: 4780:}
        -: 4781:
        -: 4782:
        -: 4783:/* ===========================================================================
        -: 4784: * Read a new buffer from the current input file, perform end-of-line
        -: 4785: * translation, and update the crc and input file size.
        -: 4786: * IN assertion: size >= 2 (for end-of-line translation)
        -: 4787: */
function file_read called 3570 returned 100% blocks executed 100%
     3570: 4788:int file_read(buf, size)
        -: 4789:    char *buf;
        -: 4790:    unsigned size;
        -: 4791:{
        -: 4792:    unsigned len;
        -: 4793:
        -: 4794:    Assert(insize == 0, "inbuf not empty");
        -: 4795:
     3570: 4796:    len = read(ifd, buf, size);
call    0 returned 3570
     3570: 4797:    if (len == (unsigned)(-1) || len == 0) return (int)len;
branch  0 taken 3569 (fallthrough)
branch  1 taken 1
branch  2 taken 174 (fallthrough)
branch  3 taken 3395
        -: 4798:
     3395: 4799:    crc = updcrc((uch*)buf, len);
call    0 returned 3395
     3395: 4800:    isize += (ulg)len;
     3395: 4801:    return (int)len;
        -: 4802:}
        -: 4803:/* gzip (GNU zip) -- compress files with zip algorithm and 'compress' interface
        -: 4804: * Copyright (C) 1992-1993 Jean-loup Gailly
        -: 4805: * The unzip code was written and put in the public domain by Mark Adler.
        -: 4806: * Portions of the lzw code are derived from the public domain 'compress'
        -: 4807: * written by Spencer Thomas, Joe Orost, James Woods, Jim McKie, Steve Davies,
        -: 4808: * Ken Turkowski, Dave Mack and Peter Jannesen.
        -: 4809: *
        -: 4810: * See the license_msg below and the file COPYING for the software license.
        -: 4811: * See the file algorithm.doc for the compression algorithms and file formats.
        -: 4812: */
        -: 4813:
        -: 4814:static char  *license_msg[] = {
        -: 4815:"   Copyright (C) 1992-1993 Jean-loup Gailly",
        -: 4816:"   This program is free software; you can redistribute it and/or modify",
        -: 4817:"   it under the terms of the GNU General Public License as published by",
        -: 4818:"   the Free Software Foundation; either version 2, or (at your option)",
        -: 4819:"   any later version.",
        -: 4820:"",
        -: 4821:"   This program is distributed in the hope that it will be useful,",
        -: 4822:"   but WITHOUT ANY WARRANTY; without even the implied warranty of",
        -: 4823:"   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
        -: 4824:"   GNU General Public License for more details.",
        -: 4825:"",
        -: 4826:"   You should have received a copy of the GNU General Public License",
        -: 4827:"   along with this program; if not, write to the Free Software",
        -: 4828:"   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.",
        -: 4829:0};
        -: 4830:
        -: 4831:/* Compress files with zip algorithm and 'compress' interface.
        -: 4832: * See usage() and help() functions below for all options.
        -: 4833: * Outputs:
        -: 4834: *        file.gz:   compressed file with same mode, owner, and utimes
        -: 4835: *     or stdout with -c option or if stdin used as input.
        -: 4836: * If the output file name had to be truncated, the original name is kept
        -: 4837: * in the compressed file.
        -: 4838: * On MSDOS, file.tmp -> file.tmz. On VMS, file.tmp -> file.tmp-gz.
        -: 4839: *
        -: 4840: * Using gz on MSDOS would create too many file name conflicts. For
        -: 4841: * example, foo.txt -> foo.tgz (.tgz must be reserved as shorthand for
        -: 4842: * tar.gz). Similarly, foo.dir and foo.doc would both be mapped to foo.dgz.
        -: 4843: * I also considered 12345678.txt -> 12345txt.gz but this truncates the name
        -: 4844: * too heavily. There is no ideal solution given the MSDOS 8+3 limitation. 
        -: 4845: *
        -: 4846: * For the meaning of all compilation flags, see comments in Makefile.in.
        -: 4847: */
        -: 4848:
        -: 4849:#ifdef RCSID
        -: 4850:static char rcsid[] = "$Id: gzip.c,v 0.24 1993/06/24 10:52:07 jloup Exp $";
        -: 4851:#endif
        -: 4852:
        -: 4853:		/* configuration */
        -: 4854:
        -: 4855:#ifdef NO_TIME_H
        -: 4856:#  include <sys/time.h>
        -: 4857:#else
        -: 4858:#  include <time.h>
        -: 4859:#endif
        -: 4860:
        -: 4861:#ifndef NO_FCNTL_H
        -: 4862:#  include <fcntl.h>
        -: 4863:#endif
        -: 4864:
        -: 4865:#ifdef HAVE_UNISTD_H
        -: 4866:#  include <unistd.h>
        -: 4867:#endif
        -: 4868:
        -: 4869:#if defined(STDC_HEADERS) || !defined(NO_STDLIB_H)
        -: 4870:#  include <stdlib.h>
        -: 4871:#else
        -: 4872:   extern int errno;
        -: 4873:#endif
        -: 4874:
        -: 4875:#if defined(DIRENT)
        -: 4876:#  include <dirent.h>
        -: 4877:   typedef struct dirent dir_type;
        -: 4878:#  define NLENGTH(dirent) ((int)strlen((dirent)->d_name))
        -: 4879:#  define DIR_OPT "DIRENT"
        -: 4880:#else
        -: 4881:#  define NLENGTH(dirent) ((dirent)->d_namlen)
        -: 4882:#  ifdef SYSDIR
        -: 4883:#    include <sys/dir.h>
        -: 4884:     typedef struct direct dir_type;
        -: 4885:#    define DIR_OPT "SYSDIR"
        -: 4886:#  else
        -: 4887:#    ifdef SYSNDIR
        -: 4888:#      include <sys/ndir.h>
        -: 4889:       typedef struct direct dir_type;
        -: 4890:#      define DIR_OPT "SYSNDIR"
        -: 4891:#    else
        -: 4892:#      ifdef NDIR
        -: 4893:#        include <ndir.h>
        -: 4894:         typedef struct direct dir_type;
        -: 4895:#        define DIR_OPT "NDIR"
        -: 4896:#      else
        -: 4897:#        define NO_DIR
        -: 4898:#        define DIR_OPT "NO_DIR"
        -: 4899:#      endif
        -: 4900:#    endif
        -: 4901:#  endif
        -: 4902:#endif
        -: 4903:
        -: 4904:#ifndef NO_UTIME
        -: 4905:#  ifndef NO_UTIME_H
        -: 4906:#    include <utime.h>
        -: 4907:#    define TIME_OPT "UTIME"
        -: 4908:#  else
        -: 4909:#    ifdef HAVE_SYS_UTIME_H
        -: 4910:#      include <sys/utime.h>
        -: 4911:#      define TIME_OPT "SYS_UTIME"
        -: 4912:#    else
        -: 4913:       struct utimbuf {
        -: 4914:         time_t actime;
        -: 4915:         time_t modtime;
        -: 4916:       };
        -: 4917:#      define TIME_OPT ""
        -: 4918:#    endif
        -: 4919:#  endif
        -: 4920:#else
        -: 4921:#  define TIME_OPT "NO_UTIME"
        -: 4922:#endif
        -: 4923:
        -: 4924:#if !defined(S_ISDIR) && defined(S_IFDIR)
        -: 4925:#  define S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)
        -: 4926:#endif
        -: 4927:#if !defined(S_ISREG) && defined(S_IFREG)
        -: 4928:#  define S_ISREG(m) (((m) & S_IFMT) == S_IFREG)
        -: 4929:#endif
        -: 4930:
        -: 4931:typedef RETSIGTYPE (*sig_type) OF((int));
        -: 4932:
        -: 4933:#ifndef	O_BINARY
        -: 4934:#  define  O_BINARY  0  /* creation mode for open() */
        -: 4935:#endif
        -: 4936:
        -: 4937:#ifndef O_CREAT
        -: 4938:   /* Pure BSD system? */
        -: 4939:#  include <sys/file.h>
        -: 4940:#  ifndef O_CREAT
        -: 4941:#    define O_CREAT FCREAT
        -: 4942:#  endif
        -: 4943:#  ifndef O_EXCL
        -: 4944:#    define O_EXCL FEXCL
        -: 4945:#  endif
        -: 4946:#endif
        -: 4947:
        -: 4948:#ifndef S_IRUSR
        -: 4949:#  define S_IRUSR 0400
        -: 4950:#endif
        -: 4951:#ifndef S_IWUSR
        -: 4952:#  define S_IWUSR 0200
        -: 4953:#endif
        -: 4954:#define RW_USER (S_IRUSR | S_IWUSR)  /* creation mode for open() */
        -: 4955:
        -: 4956:#ifndef MAX_PATH_LEN
        -: 4957:#  define MAX_PATH_LEN   1024 /* max pathname length */
        -: 4958:#endif
        -: 4959:
        -: 4960:#ifndef SEEK_END
        -: 4961:#  define SEEK_END 2
        -: 4962:#endif
        -: 4963:
        -: 4964:#ifdef NO_OFF_T
        -: 4965:  typedef long off_t;
        -: 4966:  off_t lseek OF((int fd, off_t offset, int whence));
        -: 4967:#endif
        -: 4968:
        -: 4969:/* Separator for file name parts (see shorten_name()) */
        -: 4970:#ifdef NO_MULTIPLE_DOTS
        -: 4971:#  define PART_SEP "-"
        -: 4972:#else
        -: 4973:#  define PART_SEP "."
        -: 4974:#endif
        -: 4975:
        -: 4976:		/* global buffers */
        -: 4977:
        -: 4978:DECLARE(uch, inbuf,  INBUFSIZ +INBUF_EXTRA);
        -: 4979:DECLARE(uch, outbuf, OUTBUFSIZ+OUTBUF_EXTRA);
        -: 4980:DECLARE(ush, d_buf,  DIST_BUFSIZE);
        -: 4981:DECLARE(uch, window, 2L*WSIZE);
        -: 4982:#ifndef MAXSEG_64K
        -: 4983:    DECLARE(ush, tab_prefix, 1L<<BITS);
        -: 4984:#else
        -: 4985:    DECLARE(ush, tab_prefix0, 1L<<(BITS-1));
        -: 4986:    DECLARE(ush, tab_prefix1, 1L<<(BITS-1));
        -: 4987:#endif
        -: 4988:
        -: 4989:		/* local variables */
        -: 4990:
        -: 4991:int ascii = 0;        /* convert end-of-lines to local OS conventions */
        -: 4992:int to_stdout = 0;    /* output to stdout (-c) */
        -: 4993:int decompress = 0;   /* decompress (-d) */
        -: 4994:int force = 0;        /* don't ask questions, compress links (-f) */
        -: 4995:int no_name = -1;     /* don't save or restore the original file name */
        -: 4996:int no_time = -1;     /* don't save or restore the original file time */
        -: 4997:int recursive = 0;    /* recurse through directories (-r) */
        -: 4998:int list = 0;         /* list the file contents (-l) */
        -: 4999:int verbose = 0;      /* be verbose (-v) */
        -: 5000:int quiet = 0;        /* be very quiet (-q) */
        -: 5001:int do_lzw = 0;       /* generate output compatible with old compress (-Z) */
        -: 5002:int test = 0;         /* test .gz file integrity */
        -: 5003:int foreground;       /* set if program run in foreground */
        -: 5004:char *progname;       /* program name */
        -: 5005:int maxbits = BITS;   /* max bits per code for LZW */
        -: 5006:int method = DEFLATED;/* compression method */
        -: 5007:int level = 6;        /* compression level */
        -: 5008:int exit_code = OK;   /* program exit code */
        -: 5009:int save_orig_name;   /* set if original name must be saved */
        -: 5010:int last_member;      /* set for .zip and .Z files */
        -: 5011:int part_nb;          /* number of parts in .gz file */
        -: 5012:long time_stamp;      /* original time stamp (modification time) */
        -: 5013:long ifile_size;      /* input file size, -1 for devices (debug only) */
        -: 5014:char *env;            /* contents of GZIP env variable */
        -: 5015:char **args = NULL;   /* argv pointer if GZIP env variable defined */
        -: 5016:char z_suffix[MAX_SUFFIX+1]; /* default suffix (can be set with --suffix) */
        -: 5017:int  z_len;           /* strlen(z_suffix) */
        -: 5018:
        -: 5019:long bytes_in;             /* number of input bytes */
        -: 5020:long bytes_out;            /* number of output bytes */
        -: 5021:long total_in = 0;         /* input bytes for all files */
        -: 5022:long total_out = 0;        /* output bytes for all files */
        -: 5023:char ifname[MAX_PATH_LEN]; /* input file name */
        -: 5024:char ofname[MAX_PATH_LEN]; /* output file name */
        -: 5025:int  remove_ofname = 0;	   /* remove output file on error */
        -: 5026:struct stat istat;         /* status for input file */
        -: 5027:int  ifd;                  /* input file descriptor */
        -: 5028:int  ofd;                  /* output file descriptor */
        -: 5029:unsigned insize;           /* valid bytes in inbuf */
        -: 5030:unsigned inptr;            /* index of next byte to be processed in inbuf */
        -: 5031:unsigned outcnt;           /* bytes in output buffer */
        -: 5032:
        -: 5033:struct option longopts[] =
        -: 5034:{
        -: 5035: /* { name  has_arg  *flag  val } */
        -: 5036:    {"ascii",      0, 0, 'a'}, /* ascii text mode */
        -: 5037:    {"to-stdout",  0, 0, 'c'}, /* write output on standard output */
        -: 5038:    {"stdout",     0, 0, 'c'}, /* write output on standard output */
        -: 5039:    {"decompress", 0, 0, 'd'}, /* decompress */
        -: 5040:    {"uncompress", 0, 0, 'd'}, /* decompress */
        -: 5041: /* {"encrypt",    0, 0, 'e'},    encrypt */
        -: 5042:    {"force",      0, 0, 'f'}, /* force overwrite of output file */
        -: 5043:    {"help",       0, 0, 'h'}, /* give help */
        -: 5044: /* {"pkzip",      0, 0, 'k'},    force output in pkzip format */
        -: 5045:    {"list",       0, 0, 'l'}, /* list .gz file contents */
        -: 5046:    {"license",    0, 0, 'L'}, /* display software license */
        -: 5047:    {"no-name",    0, 0, 'n'}, /* don't save or restore original name & time */
        -: 5048:    {"name",       0, 0, 'N'}, /* save or restore original name & time */
        -: 5049:    {"quiet",      0, 0, 'q'}, /* quiet mode */
        -: 5050:    {"silent",     0, 0, 'q'}, /* quiet mode */
        -: 5051:    {"recursive",  0, 0, 'r'}, /* recurse through directories */
        -: 5052:    {"suffix",     1, 0, 'S'}, /* use given suffix instead of .gz */
        -: 5053:    {"test",       0, 0, 't'}, /* test compressed file integrity */
        -: 5054:    {"no-time",    0, 0, 'T'}, /* don't save or restore the time stamp */
        -: 5055:    {"verbose",    0, 0, 'v'}, /* verbose mode */
        -: 5056:    {"version",    0, 0, 'V'}, /* display version number */
        -: 5057:    {"fast",       0, 0, '1'}, /* compress faster */
        -: 5058:    {"best",       0, 0, '9'}, /* compress better */
        -: 5059:    {"lzw",        0, 0, 'Z'}, /* make output compatible with old compress */
        -: 5060:    {"bits",       1, 0, 'b'}, /* max number of bits per code (implies -Z) */
        -: 5061:    { 0, 0, 0, 0 }
        -: 5062:};
        -: 5063:
        -: 5064:/* local functions */
        -: 5065:
        -: 5066:local void usage        OF((void));
        -: 5067:local void help         OF((void));
        -: 5068:local void license      OF((void));
        -: 5069:local void version      OF((void));
        -: 5070:local void treat_stdin  OF((void));
        -: 5071:local void treat_file   OF((char *iname));
        -: 5072:local int create_outfile OF((void));
        -: 5073:local int  do_stat      OF((char *name, struct stat *sbuf));
        -: 5074:local char *get_suffix  OF((char *name));
        -: 5075:local int  get_istat    OF((char *iname, struct stat *sbuf));
        -: 5076:local int  make_ofname  OF((void));
        -: 5077:local int  same_file    OF((struct stat *stat1, struct stat *stat2));
        -: 5078:local int name_too_long OF((char *name, struct stat *statb));
        -: 5079:local void shorten_name  OF((char *name));
        -: 5080:local int  get_method   OF((int in));
        -: 5081:local void do_list      OF((int ifd, int method));
        -: 5082:local int  check_ofname OF((void));
        -: 5083:local void copy_stat    OF((struct stat *ifstat));
        -: 5084:local void do_exit      OF((int exitcode));
        -: 5085:      int main          OF((int argc, char **argv));
        -: 5086:int (*work) OF((int infile, int outfile)) = zip; /* function to call */
        -: 5087:
        -: 5088:#ifndef NO_DIR
        -: 5089:local void treat_dir    OF((char *dir));
        -: 5090:#endif
        -: 5091:#ifndef NO_UTIME
        -: 5092:local void reset_times  OF((char *name, struct stat *statb));
        -: 5093:#endif
        -: 5094:
        -: 5095:#define strequ(s1, s2) (strcmp((s1),(s2)) == 0)
        -: 5096:
        -: 5097:/* ======================================================================== */
function usage called 2 returned 100% blocks executed 100%
        2: 5098:local void usage()
        -: 5099:{
        2: 5100:    fprintf(stderr, "usage: %s [-%scdfhlLnN%stvV19] [-S suffix] [file ...]\n",
call    0 returned 2
        -: 5101:	    progname,
        -: 5102:#if O_BINARY
        -: 5103:	    "a",
        -: 5104:#else
        -: 5105:	    "",
        -: 5106:#endif
        -: 5107:#ifdef NO_DIR
        -: 5108:	    ""
        -: 5109:#else
        -: 5110:	    "r"
        -: 5111:#endif
        -: 5112:	    );
        2: 5113:}
        -: 5114:
        -: 5115:/* ======================================================================== */
function help called 2 returned 100% blocks executed 100%
        2: 5116:local void help()
        -: 5117:{
        -: 5118:    static char  *help_msg[] = {
        -: 5119:#if O_BINARY
        -: 5120: " -a --ascii       ascii text; convert end-of-lines using local conventions",
        -: 5121:#endif
        -: 5122: " -c --stdout      write on standard output, keep original files unchanged",
        -: 5123: " -d --decompress  decompress",
        -: 5124:/* -e --encrypt     encrypt */
        -: 5125: " -f --force       force overwrite of output file and compress links",
        -: 5126: " -h --help        give this help",
        -: 5127:/* -k --pkzip       force output in pkzip format */
        -: 5128: " -l --list        list compressed file contents",
        -: 5129: " -L --license     display software license",
        -: 5130:#ifdef UNDOCUMENTED
        -: 5131: " -m --no-time     do not save or restore the original modification time",
        -: 5132: " -M --time        save or restore the original modification time",
        -: 5133:#endif
        -: 5134: " -n --no-name     do not save or restore the original name and time stamp",
        -: 5135: " -N --name        save or restore the original name and time stamp",
        -: 5136: " -q --quiet       suppress all warnings",
        -: 5137:#ifndef NO_DIR
        -: 5138: " -r --recursive   operate recursively on directories",
        -: 5139:#endif
        -: 5140: " -S .suf  --suffix .suf     use suffix .suf on compressed files",
        -: 5141: " -t --test        test compressed file integrity",
        -: 5142: " -v --verbose     verbose mode",
        -: 5143: " -V --version     display version number",
        -: 5144: " -1 --fast        compress faster",
        -: 5145: " -9 --best        compress better",
        -: 5146:#ifdef LZW
        -: 5147: " -Z --lzw         produce output compatible with old compress",
        -: 5148: " -b --bits maxbits   max number of bits per code (implies -Z)",
        -: 5149:#endif
        -: 5150: " file...          files to (de)compress. If none given, use standard input.",
        -: 5151:  0};
        2: 5152:    char **p = help_msg;
        -: 5153:
        2: 5154:    fprintf(stderr,"%s %s (%s)\n", progname, VERSION, REVDATE);
call    0 returned 2
        2: 5155:    usage();
call    0 returned 2
       36: 5156:    while (*p) fprintf(stderr, "%s\n", *p++);
call    0 returned 34
branch  1 taken 34
branch  2 taken 2 (fallthrough)
        2: 5157:}
        -: 5158:
        -: 5159:/* ======================================================================== */
function license called 2 returned 100% blocks executed 100%
        2: 5160:local void license()
        -: 5161:{
        2: 5162:    char **p = license_msg;
        -: 5163:
        2: 5164:    fprintf(stderr,"%s %s (%s)\n", progname, VERSION, REVDATE);
call    0 returned 2
       30: 5165:    while (*p) fprintf(stderr, "%s\n", *p++);
call    0 returned 28
branch  1 taken 28
branch  2 taken 2 (fallthrough)
        2: 5166:}
        -: 5167:
        -: 5168:/* ======================================================================== */
function version called 2 returned 100% blocks executed 100%
        2: 5169:local void version()
        -: 5170:{
        2: 5171:    fprintf(stderr,"%s %s (%s)\n", progname, VERSION, REVDATE);
call    0 returned 2
        -: 5172:
        2: 5173:    fprintf(stderr, "Compilation options:\n%s %s ", DIR_OPT, TIME_OPT);
call    0 returned 2
        -: 5174:#ifdef STDC_HEADERS
        2: 5175:    fprintf(stderr, "STDC_HEADERS ");
call    0 returned 2
        -: 5176:#endif
        -: 5177:#ifdef HAVE_UNISTD_H
        2: 5178:    fprintf(stderr, "HAVE_UNISTD_H ");
call    0 returned 2
        -: 5179:#endif
        -: 5180:#ifdef NO_MEMORY_H
        -: 5181:    fprintf(stderr, "NO_MEMORY_H ");
        -: 5182:#endif
        -: 5183:#ifdef NO_STRING_H
        -: 5184:    fprintf(stderr, "NO_STRING_H ");
        -: 5185:#endif
        -: 5186:#ifdef NO_SYMLINK
        -: 5187:    fprintf(stderr, "NO_SYMLINK ");
        -: 5188:#endif
        -: 5189:#ifdef NO_MULTIPLE_DOTS
        -: 5190:    fprintf(stderr, "NO_MULTIPLE_DOTS ");
        -: 5191:#endif
        -: 5192:#ifdef NO_CHOWN
        -: 5193:    fprintf(stderr, "NO_CHOWN ");
        -: 5194:#endif
        -: 5195:#ifdef PROTO
        -: 5196:    fprintf(stderr, "PROTO ");
        -: 5197:#endif
        -: 5198:#ifdef ASMV
        -: 5199:    fprintf(stderr, "ASMV ");
        -: 5200:#endif
        -: 5201:#ifdef DEBUG
        -: 5202:    fprintf(stderr, "DEBUG ");
        -: 5203:#endif
        -: 5204:#ifdef DYN_ALLOC
        -: 5205:    fprintf(stderr, "DYN_ALLOC ");
        -: 5206:#endif
        -: 5207:#ifdef MAXSEG_64K
        -: 5208:    fprintf(stderr, "MAXSEG_64K");
        -: 5209:#endif
        2: 5210:    fprintf(stderr, "\n");
call    0 returned 2
        2: 5211:}
        -: 5212:
        -: 5213:/* ======================================================================== */
function main called 214 returned 0% blocks executed 67%
      214: 5214:int main (argc, argv)
        -: 5215:    int argc;
        -: 5216:    char **argv;
        -: 5217:{
        -: 5218:    int file_count;     /* number of files to precess */
        -: 5219:    int proglen;        /* length of progname */
        -: 5220:    int optc;           /* current option */
        -: 5221:
        -: 5222:    EXPAND(argc, argv); /* wild card expansion if necessary */
        -: 5223:
      214: 5224:    progname = basename(argv[0]);
call    0 returned 214
      214: 5225:    proglen = strlen(progname);
        -: 5226:
        -: 5227:    /* Suppress .exe for MSDOS, OS/2 and VMS: */
      214: 5228:    if (proglen > 4 && strequ(progname+proglen-4, ".exe")) {
branch  0 taken 214 (fallthrough)
branch  1 taken 0
branch  2 taken 214 (fallthrough)
branch  3 taken 0
      214: 5229:        progname[proglen-4] = '\0';
        -: 5230:    }
        -: 5231:
        -: 5232:    /* Add options in GZIP environment variable if there is one */
      214: 5233:    env = add_envopt(&argc, &argv, OPTIONS_VAR);
call    0 returned 214
     214*: 5234:    if (env != NULL) args = argv;
branch  0 taken 0 (fallthrough)
branch  1 taken 214
        -: 5235:
      214: 5236:    foreground = signal(SIGINT, SIG_IGN) != SIG_IGN;
call    0 returned 214
      214: 5237:    if (foreground) {
branch  0 taken 213 (fallthrough)
branch  1 taken 1
      213: 5238:	(void) signal (SIGINT, (sig_type)abort_gzip);
call    0 returned 213
        -: 5239:    }
        -: 5240:#ifdef SIGTERM
      214: 5241:    if (signal(SIGTERM, SIG_IGN) != SIG_IGN) {
call    0 returned 214
branch  1 taken 214 (fallthrough)
branch  2 taken 0
      214: 5242:	(void) signal(SIGTERM, (sig_type)abort_gzip);
call    0 returned 214
        -: 5243:    }
        -: 5244:#endif
        -: 5245:#ifdef SIGHUP
      214: 5246:    if (signal(SIGHUP, SIG_IGN) != SIG_IGN) {
call    0 returned 214
branch  1 taken 214 (fallthrough)
branch  2 taken 0
      214: 5247:	(void) signal(SIGHUP,  (sig_type)abort_gzip);
call    0 returned 214
        -: 5248:    }
        -: 5249:#endif
        -: 5250:
        -: 5251:#ifndef GNU_STANDARD
        -: 5252:    /* For compatibility with old compress, use program name as an option.
        -: 5253:     * If you compile with -DGNU_STANDARD, this program will behave as
        -: 5254:     * gzip even if it is invoked under the name gunzip or zcat.
        -: 5255:     *
        -: 5256:     * Systems which do not support links can still use -d or -dc.
        -: 5257:     * Ignore an .exe extension for MSDOS, OS/2 and VMS.
        -: 5258:     */
      214: 5259:    if (  strncmp(progname, "un",  2) == 0     /* ungzip, uncompress */
branch  0 taken 214 (fallthrough)
branch  1 taken 0
      214: 5260:       || strncmp(progname, "gun", 3) == 0) {  /* gunzip */
branch  0 taken 0 (fallthrough)
branch  1 taken 214
    #####: 5261:	decompress = 1;
      214: 5262:    } else if (strequ(progname+1, "cat")       /* zcat, pcat, gcat */
branch  0 taken 214 (fallthrough)
branch  1 taken 0
      214: 5263:	    || strequ(progname, "gzcat")) {    /* gzcat */
branch  0 taken 0 (fallthrough)
branch  1 taken 214
    #####: 5264:	decompress = to_stdout = 1;
        -: 5265:    }
        -: 5266:#endif
        -: 5267:
      214: 5268:    strncpy(z_suffix, Z_SUFFIX, sizeof(z_suffix)-1);
      214: 5269:    z_len = strlen(z_suffix);
        -: 5270:
      716: 5271:    while ((optc = getopt_long (argc, argv, "ab:cdfhH?lLmMnNqrS:tvVZ123456789",
call    0 returned 716
      716: 5272:				longopts, (int *)0)) != EOF) {
branch  0 taken 508
branch  1 taken 208 (fallthrough)
      508: 5273:	switch (optc) {
branch  0 taken 0
branch  1 taken 0
branch  2 taken 2
branch  3 taken 13
branch  4 taken 82
branch  5 taken 2
branch  6 taken 0
branch  7 taken 2
branch  8 taken 0
branch  9 taken 0
branch 10 taken 0
branch 11 taken 0
branch 12 taken 82
branch 13 taken 83
branch 14 taken 0
branch 15 taken 3
branch 16 taken 82
branch 17 taken 2
branch 18 taken 0
branch 19 taken 155
branch 20 taken 0
    #####: 5274:        case 'a':
    #####: 5275:            ascii = 1; break;
    #####: 5276:	case 'b':
    #####: 5277:	    maxbits = atoi(optarg);
    #####: 5278:	    break;
        2: 5279:	case 'c':
        2: 5280:	    to_stdout = 1; break;
       13: 5281:	case 'd':
       13: 5282:	    decompress = 1; break;
       82: 5283:	case 'f':
       82: 5284:	    force++; break;
        2: 5285:	case 'h': case 'H': case '?':
        2: 5286:	    help(); do_exit(OK); break;
call    0 returned 2
call    1 returned 0
    #####: 5287:	case 'l':
    #####: 5288:	    list = decompress = to_stdout = 1; break;
        2: 5289:	case 'L':
        2: 5290:	    license(); do_exit(OK); break;
call    0 returned 2
call    1 returned 0
    #####: 5291:	case 'm': /* undocumented, may change later */
    #####: 5292:	    no_time = 1; break;
    #####: 5293:	case 'M': /* undocumented, may change later */
    #####: 5294:	    no_time = 0; break;
    #####: 5295:	case 'n':
    #####: 5296:	    no_name = no_time = 1; break;
    #####: 5297:	case 'N':
    #####: 5298:	    no_name = no_time = 0; break;
       82: 5299:	case 'q':
       82: 5300:	    quiet = 1; verbose = 0; break;
       83: 5301:	case 'r':
        -: 5302:#ifdef NO_DIR
        -: 5303:	    fprintf(stderr, "%s: -r not supported on this system\n", progname);
        -: 5304:	    usage();
        -: 5305:	    do_exit(ERROR); break;
        -: 5306:#else
       83: 5307:	    recursive = 1; break;
        -: 5308:#endif
    #####: 5309:	case 'S':
        -: 5310:#ifdef NO_MULTIPLE_DOTS
        -: 5311:            if (*optarg == '.') optarg++;
        -: 5312:#endif
    #####: 5313:            z_len = strlen(optarg);
    #####: 5314:            strcpy(z_suffix, optarg);
    #####: 5315:            break;
        3: 5316:	case 't':
        3: 5317:	    test = decompress = to_stdout = 1;
        3: 5318:	    break;
       82: 5319:	case 'v':
       82: 5320:	    verbose++; quiet = 0; break;
        2: 5321:	case 'V':
        2: 5322:	    version(); do_exit(OK); break;
call    0 returned 2
call    1 returned 0
    #####: 5323:	case 'Z':
        -: 5324:#ifdef LZW
        -: 5325:	    do_lzw = 1; break;
        -: 5326:#else
    #####: 5327:	    fprintf(stderr, "%s: -Z not supported in this version\n",
call    0 never executed
        -: 5328:		    progname);
    #####: 5329:	    usage();
call    0 never executed
    #####: 5330:	    do_exit(ERROR); break;
call    0 never executed
        -: 5331:#endif
      155: 5332:	case '1':  case '2':  case '3':  case '4':
        -: 5333:	case '5':  case '6':  case '7':  case '8':  case '9':
      155: 5334:	    level = optc - '0';
      155: 5335:	    break;
    #####: 5336:	default:
        -: 5337:	    /* Error message already emitted by getopt_long. */
    #####: 5338:	    usage();
call    0 never executed
    #####: 5339:	    do_exit(ERROR);
call    0 never executed
        -: 5340:	}
        -: 5341:    } /* loop on all arguments */
        -: 5342:
        -: 5343:    /* By default, save name and timestamp on compression but do not
        -: 5344:     * restore them on decompression.
        -: 5345:     */
      208: 5346:    if (no_time < 0) no_time = decompress;
branch  0 taken 208 (fallthrough)
branch  1 taken 0
      208: 5347:    if (no_name < 0) no_name = decompress;
branch  0 taken 208 (fallthrough)
branch  1 taken 0
        -: 5348:
      208: 5349:    file_count = argc - optind;
        -: 5350:
        -: 5351:#if O_BINARY
        -: 5352:#else
     208*: 5353:    if (ascii && !quiet) {
branch  0 taken 0 (fallthrough)
branch  1 taken 208
branch  2 never executed
branch  3 never executed
    #####: 5354:	fprintf(stderr, "%s: option --ascii ignored on this system\n",
call    0 never executed
        -: 5355:		progname);
        -: 5356:    }
        -: 5357:#endif
     208*: 5358:    if ((z_len == 0 && !decompress) || z_len > MAX_SUFFIX) {
branch  0 taken 0 (fallthrough)
branch  1 taken 208
branch  2 never executed
branch  3 never executed
branch  4 taken 0 (fallthrough)
branch  5 taken 208
    #####: 5359:        fprintf(stderr, "%s: incorrect suffix '%s'\n",
call    0 never executed
        -: 5360:                progname, optarg);
    #####: 5361:        do_exit(ERROR);
call    0 never executed
        -: 5362:    }
     208*: 5363:    if (do_lzw && !decompress) work = lzw;
branch  0 taken 0 (fallthrough)
branch  1 taken 208
branch  2 never executed
branch  3 never executed
        -: 5364:
        -: 5365:    /* Allocate all global buffers (for DYN_ALLOC option) */
        -: 5366:    ALLOC(uch, inbuf,  INBUFSIZ +INBUF_EXTRA);
        -: 5367:    ALLOC(uch, outbuf, OUTBUFSIZ+OUTBUF_EXTRA);
        -: 5368:    ALLOC(ush, d_buf,  DIST_BUFSIZE);
        -: 5369:    ALLOC(uch, window, 2L*WSIZE);
        -: 5370:#ifndef MAXSEG_64K
        -: 5371:    ALLOC(ush, tab_prefix, 1L<<BITS);
        -: 5372:#else
        -: 5373:    ALLOC(ush, tab_prefix0, 1L<<(BITS-1));
        -: 5374:    ALLOC(ush, tab_prefix1, 1L<<(BITS-1));
        -: 5375:#endif
        -: 5376:
        -: 5377:    /* And get to work */
      208: 5378:    if (file_count != 0) {
branch  0 taken 20 (fallthrough)
branch  1 taken 188
      20*: 5379:	if (to_stdout && !test && !list && (!decompress || !ascii)) {
branch  0 taken 2 (fallthrough)
branch  1 taken 18
branch  2 taken 1 (fallthrough)
branch  3 taken 1
branch  4 taken 1 (fallthrough)
branch  5 taken 0
branch  6 taken 0 (fallthrough)
branch  7 taken 1
        -: 5380:	    SET_BINARY_MODE(fileno(stdout));
        -: 5381:	}
       40: 5382:        while (optind < argc) {
branch  0 taken 20
branch  1 taken 20
       20: 5383:	    treat_file(argv[optind++]);
call    0 returned 20
        -: 5384:	}
        -: 5385:    } else {  /* Standard input */
      188: 5386:	treat_stdin();
call    0 returned 187
        -: 5387:    }
     207*: 5388:    if (list && !quiet && file_count > 1) {
branch  0 taken 0 (fallthrough)
branch  1 taken 207
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 5389:	do_list(-1, -1); /* print totals */
call    0 never executed
        -: 5390:    }
      207: 5391:    do_exit(exit_code);
call    0 returned 0
    #####: 5392:    return exit_code; /* just to avoid lint warning */
        -: 5393:}
        -: 5394:
        -: 5395:/* ========================================================================
        -: 5396: * Compress or decompress stdin
        -: 5397: */
function treat_stdin called 188 returned 99% blocks executed 72%
      188: 5398:local void treat_stdin()
        -: 5399:{
        -: 5400:#ifdef FAULTY_F_KL_2
        -: 5401:    if (!force && list &&
        -: 5402:	isatty(fileno((FILE *)(decompress ? stdin : stdout)))) 
        -: 5403:#else
      295: 5404:    if (!force && !list &&
branch  0 taken 107 (fallthrough)
branch  1 taken 81
branch  2 taken 107 (fallthrough)
branch  3 taken 0
branch  4 taken 0 (fallthrough)
branch  5 taken 107
      107: 5405:	isatty(fileno((FILE *)(decompress ? stdin : stdout)))) 
branch  0 taken 14 (fallthrough)
branch  1 taken 93
call    2 returned 107
call    3 returned 107
        -: 5406:#endif
        -: 5407:    {
        -: 5408:	/* Do not send compressed data to the terminal or read it from
        -: 5409:	 * the terminal. We get here when user invoked the program
        -: 5410:	 * without parameters, so be helpful. According to the GNU standards:
        -: 5411:	 *
        -: 5412:	 *   If there is one behavior you think is most useful when the output
        -: 5413:	 *   is to a terminal, and another that you think is most useful when
        -: 5414:	 *   the output is a file or a pipe, then it is usually best to make
        -: 5415:	 *   the default behavior the one that is useful with output to a
        -: 5416:	 *   terminal, and have an option for the other behavior.
        -: 5417:	 *
        -: 5418:	 * Here we use the --force option to get the other behavior.
        -: 5419:	 */
    #####: 5420:	fprintf(stderr,
call    0 never executed
        -: 5421:    "%s: compressed data not %s a terminal. Use -f to force %scompression.\n",
    #####: 5422:		progname, decompress ? "read from" : "written to",
branch  0 never executed
branch  1 never executed
    #####: 5423:		decompress ? "de" : "");
branch  0 never executed
branch  1 never executed
    #####: 5424:	fprintf(stderr,"For help, type: %s -h\n", progname);
call    0 never executed
    #####: 5425:	do_exit(ERROR);
call    0 never executed
        -: 5426:    }
        -: 5427:
      188: 5428:    if (decompress || !ascii) {
branch  0 taken 174 (fallthrough)
branch  1 taken 14
        -: 5429:	SET_BINARY_MODE(fileno(stdin));
        -: 5430:    }
      188: 5431:    if (!test && !list && (!decompress || !ascii)) {
branch  0 taken 186 (fallthrough)
branch  1 taken 2
branch  2 taken 186 (fallthrough)
branch  3 taken 0
branch  4 taken 12 (fallthrough)
branch  5 taken 174
        -: 5432:	SET_BINARY_MODE(fileno(stdout));
        -: 5433:    }
      188: 5434:    strcpy(ifname, "stdin");
      188: 5435:    strcpy(ofname, "stdout");
        -: 5436:
        -: 5437:    /* Get the time stamp on the input file. */
      188: 5438:    time_stamp = 0; /* time unknown by default */
        -: 5439:
        -: 5440:#ifndef NO_STDIN_FSTAT
      188: 5441:    if (list || !no_time) {
branch  0 taken 188 (fallthrough)
branch  1 taken 0
branch  2 taken 174 (fallthrough)
branch  3 taken 14
      174: 5442:	if (fstat(fileno(stdin), &istat) != 0) {
call    0 returned 174
call    1 returned 174
branch  2 taken 0 (fallthrough)
branch  3 taken 174
    #####: 5443:	    error("fstat(stdin)");
call    0 never executed
        -: 5444:	}
        -: 5445:# ifdef NO_PIPE_TIMESTAMP
        -: 5446:	if (S_ISREG(istat.st_mode))
        -: 5447:# endif
        -: 5448:	    /* this is not original code -- modified by MAPSTEXT */
        -: 5449:	    /* time_stamp = istat.st_mtime; */
      174: 5450:	    time_stamp = 0;
        -: 5451:#endif /* NO_STDIN_FSTAT */
        -: 5452:    }
      188: 5453:    ifile_size = -1L; /* convention for unknown size */
        -: 5454:
      188: 5455:    clear_bufs(); /* clear input and output buffers */
call    0 returned 188
      188: 5456:    to_stdout = 1;
      188: 5457:    part_nb = 0;
        -: 5458:
      188: 5459:    if (decompress) {
branch  0 taken 14 (fallthrough)
branch  1 taken 174
       14: 5460:	method = get_method(ifd);
call    0 returned 13
       13: 5461:	if (method < 0) {
branch  0 taken 0 (fallthrough)
branch  1 taken 13
    #####: 5462:	    do_exit(exit_code); /* error message already emitted */
call    0 never executed
        -: 5463:	}
        -: 5464:    }
      187: 5465:    if (list) {
branch  0 taken 0 (fallthrough)
branch  1 taken 187
    #####: 5466:        do_list(ifd, method);
call    0 never executed
    #####: 5467:        return;
        -: 5468:    }
        -: 5469:
        -: 5470:    /* Actually do the compression/decompression. Loop over zipped members.
        -: 5471:     */
        -: 5472:    for (;;) {
     187*: 5473:	if ((*work)(fileno(stdin), fileno(stdout)) != OK) return;
call    0 returned 187
call    1 returned 187
call    2 returned 187
branch  3 taken 0 (fallthrough)
branch  4 taken 187
        -: 5474:
      187: 5475:	if (!decompress || last_member || inptr == insize) break;
branch  0 taken 13 (fallthrough)
branch  1 taken 174
branch  2 taken 10 (fallthrough)
branch  3 taken 3
branch  4 taken 1 (fallthrough)
branch  5 taken 9
        -: 5476:	/* end of file */
        -: 5477:
        1: 5478:	method = get_method(ifd);
call    0 returned 1
        1: 5479:	if (method < 0) return; /* error message already emitted */
branch  0 taken 1 (fallthrough)
branch  1 taken 0
    #####: 5480:	bytes_out = 0;            /* required for length check */
        -: 5481:    }
        -: 5482:
      186: 5483:    if (verbose) {
branch  0 taken 81 (fallthrough)
branch  1 taken 105
       81: 5484:	if (test) {
branch  0 taken 0 (fallthrough)
branch  1 taken 81
    #####: 5485:	    fprintf(stderr, " OK\n");
call    0 never executed
        -: 5486:
       81: 5487:	} else if (!decompress) {
branch  0 taken 81 (fallthrough)
branch  1 taken 0
       81: 5488:	    display_ratio(bytes_in-(bytes_out-header_bytes), bytes_in, stderr);
call    0 returned 81
       81: 5489:	    fprintf(stderr, "\n");
call    0 returned 81
        -: 5490:#ifdef DISPLAY_STDIN_RATIO
        -: 5491:	} else {
        -: 5492:	    display_ratio(bytes_out-(bytes_in-header_bytes), bytes_out,stderr);
        -: 5493:	    fprintf(stderr, "\n");
        -: 5494:#endif
        -: 5495:	}
        -: 5496:    }
        -: 5497:}
        -: 5498:
        -: 5499:/* ========================================================================
        -: 5500: * Compress or decompress the given file
        -: 5501: */
function treat_file called 23 returned 100% blocks executed 40%
       23: 5502:local void treat_file(iname)
        -: 5503:    char *iname;
        -: 5504:{
        -: 5505:    /* Accept "-" as synonym for stdin */
       23: 5506:    if (strequ(iname, "-")) {
branch  0 taken 0 (fallthrough)
branch  1 taken 23
    #####: 5507:	int cflag = to_stdout;
    #####: 5508:	treat_stdin();
call    0 never executed
    #####: 5509:	to_stdout = cflag;
    #####: 5510:	return;
        -: 5511:    }
        -: 5512:
        -: 5513:    /* Check if the input file is present, set ifname and istat: */
       23: 5514:    if (get_istat(iname, &istat) != OK) return;
call    0 returned 23
branch  1 taken 15 (fallthrough)
branch  2 taken 8
        -: 5515:
        -: 5516:    /* If the input name is that of a directory, recurse or ignore: */
        8: 5517:    if (S_ISDIR(istat.st_mode)) {
branch  0 taken 3 (fallthrough)
branch  1 taken 5
        -: 5518:#ifndef NO_DIR
        3: 5519:	if (recursive) {
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        -: 5520:	    struct stat st;
        3: 5521:	    st = istat;
        3: 5522:	    treat_dir(iname);
call    0 returned 3
        -: 5523:	    /* Warning: ifname is now garbage */
        -: 5524:#  ifndef NO_UTIME
        3: 5525:	    reset_times (iname, &st);
call    0 returned 3
        -: 5526:#  endif
        -: 5527:	} else
        -: 5528:#endif
    #####: 5529:	WARN((stderr,"%s: %s is a directory -- ignored\n", progname, ifname));
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        3: 5530:	return;
        -: 5531:    }
        5: 5532:    if (!S_ISREG(istat.st_mode)) {
branch  0 taken 0 (fallthrough)
branch  1 taken 5
    #####: 5533:	WARN((stderr,
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 5534:	      "%s: %s is not a directory or a regular file - ignored\n",
        -: 5535:	      progname, ifname));
    #####: 5536:	return;
        -: 5537:    }
       5*: 5538:    if (istat.st_nlink > 1 && !to_stdout && !force) {
branch  0 taken 0 (fallthrough)
branch  1 taken 5
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 5539:	WARN((stderr, "%s: %s has %d other link%c -- unchanged\n",
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
        -: 5540:	      progname, ifname,
        -: 5541:	      (int)istat.st_nlink - 1, istat.st_nlink > 2 ? 's' : ' '));
    #####: 5542:	return;
        -: 5543:    }
        -: 5544:
        5: 5545:    ifile_size = istat.st_size;
        -: 5546:    /* this is not original code -- modified by MAPSTEXT */
        -: 5547:    /* time_stamp = no_time && !list ? 0 : istat.st_mtime; */
        5: 5548:    time_stamp = 0;
        -: 5549:
        -: 5550:    /* Generate output file name. For -r and (-t or -l), skip files
        -: 5551:     * without a valid gzip suffix (check done in make_ofname).
        -: 5552:     */
        5: 5553:    if (to_stdout && !list && !test) {
branch  0 taken 2 (fallthrough)
branch  1 taken 3
branch  2 taken 2 (fallthrough)
branch  3 taken 0
branch  4 taken 1 (fallthrough)
branch  5 taken 1
        1: 5554:	strcpy(ofname, "stdout");
        -: 5555:
        4: 5556:    } else if (make_ofname() != OK) {
call    0 returned 4
branch  1 taken 3 (fallthrough)
branch  2 taken 1
        3: 5557:	return;
        -: 5558:    }
        -: 5559:
        -: 5560:    /* Open the input file and determine compression method. The mode
        -: 5561:     * parameter is ignored but required by some systems (VMS) and forbidden
        -: 5562:     * on other systems (MacOS).
        -: 5563:     */
        2: 5564:    ifd = OPEN(ifname, ascii && !decompress ? O_RDONLY : O_RDONLY | O_BINARY,
call    0 returned 2
        -: 5565:	       RW_USER);
        2: 5566:    if (ifd == -1) {
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####: 5567:	fprintf(stderr, "%s: ", progname);
call    0 never executed
    #####: 5568:	perror(ifname);
call    0 never executed
    #####: 5569:	exit_code = ERROR;
    #####: 5570:	return;
        -: 5571:    }
        2: 5572:    clear_bufs(); /* clear input and output buffers */
call    0 returned 2
        2: 5573:    part_nb = 0;
        -: 5574:
        2: 5575:    if (decompress) {
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        1: 5576:	method = get_method(ifd); /* updates ofname if original given */
call    0 returned 1
        1: 5577:	if (method < 0) {
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 5578:	    close(ifd);
call    0 never executed
    #####: 5579:	    return;               /* error message already emitted */
        -: 5580:	}
        -: 5581:    }
        2: 5582:    if (list) {
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####: 5583:        do_list(ifd, method);
call    0 never executed
    #####: 5584:        close(ifd);
call    0 never executed
    #####: 5585:        return;
        -: 5586:    }
        -: 5587:
        -: 5588:    /* If compressing to a file, check if ofname is not ambiguous
        -: 5589:     * because the operating system truncates names. Otherwise, generate
        -: 5590:     * a new ofname and save the original name in the compressed file.
        -: 5591:     */
        2: 5592:    if (to_stdout) {
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2: 5593:	ofd = fileno(stdout);
call    0 returned 2
        -: 5594:	/* keep remove_ofname as zero */
        -: 5595:    } else {
    #####: 5596:	if (create_outfile() != OK) return;
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 5597:
    #####: 5598:	if (!decompress && save_orig_name && !verbose && !quiet) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####: 5599:	    fprintf(stderr, "%s: %s compressed to %s\n",
call    0 never executed
        -: 5600:		    progname, ifname, ofname);
        -: 5601:	}
        -: 5602:    }
        -: 5603:    /* Keep the name even if not truncated except with --no-name: */
        2: 5604:    if (!save_orig_name) save_orig_name = !no_name;
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        -: 5605:
        2: 5606:    if (verbose) {
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####: 5607:	fprintf(stderr, "%s:\t%s", ifname, (int)strlen(ifname) >= 15 ? 
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 5608:		"" : ((int)strlen(ifname) >= 7 ? "\t" : "\t\t"));
branch  0 never executed
branch  1 never executed
        -: 5609:    }
        -: 5610:
        -: 5611:    /* Actually do the compression/decompression. Loop over zipped members.
        -: 5612:     */
        -: 5613:    for (;;) {
        2: 5614:	if ((*work)(ifd, ofd) != OK) {
call    0 returned 2
branch  1 taken 0 (fallthrough)
branch  2 taken 2
    #####: 5615:	    method = -1; /* force cleanup */
    #####: 5616:	    break;
        -: 5617:	}
        2: 5618:	if (!decompress || last_member || inptr == insize) break;
branch  0 taken 1 (fallthrough)
branch  1 taken 1
branch  2 taken 1 (fallthrough)
branch  3 taken 0
branch  4 taken 0 (fallthrough)
branch  5 taken 1
        -: 5619:	/* end of file */
        -: 5620:
    #####: 5621:	method = get_method(ifd);
call    0 never executed
    #####: 5622:	if (method < 0) break;    /* error message already emitted */
branch  0 never executed
branch  1 never executed
    #####: 5623:	bytes_out = 0;            /* required for length check */
        -: 5624:    }
        -: 5625:
        2: 5626:    close(ifd);
call    0 returned 2
       2*: 5627:    if (!to_stdout && close(ofd)) {
branch  0 taken 0 (fallthrough)
branch  1 taken 2
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 5628:	write_error();
call    0 never executed
        -: 5629:    }
        2: 5630:    if (method == -1) {
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####: 5631:	if (!to_stdout) unlink (ofname);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 5632:	return;
        -: 5633:    }
        -: 5634:    /* Display statistics */
        2: 5635:    if(verbose) {
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####: 5636:	if (test) {
branch  0 never executed
branch  1 never executed
    #####: 5637:	    fprintf(stderr, " OK");
call    0 never executed
    #####: 5638:	} else if (decompress) {
branch  0 never executed
branch  1 never executed
    #####: 5639:	    display_ratio(bytes_out-(bytes_in-header_bytes), bytes_out,stderr);
call    0 never executed
        -: 5640:	} else {
    #####: 5641:	    display_ratio(bytes_in-(bytes_out-header_bytes), bytes_in, stderr);
call    0 never executed
        -: 5642:	}
    #####: 5643:	if (!test && !to_stdout) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 5644:	    fprintf(stderr, " -- replaced with %s", ofname);
call    0 never executed
        -: 5645:	}
    #####: 5646:	fprintf(stderr, "\n");
call    0 never executed
        -: 5647:    }
        -: 5648:    /* Copy modes, times, ownership, and remove the input file */
        2: 5649:    if (!to_stdout) {
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####: 5650:	copy_stat(&istat);
call    0 never executed
        -: 5651:    }
        -: 5652:}
        -: 5653:
        -: 5654:/* ========================================================================
        -: 5655: * Create the output file. Return OK or ERROR.
        -: 5656: * Try several times if necessary to avoid truncating the z_suffix. For
        -: 5657: * example, do not create a compressed file of name "1234567890123."
        -: 5658: * Sets save_orig_name to true if the file name has been truncated.
        -: 5659: * IN assertions: the input file has already been open (ifd is set) and
        -: 5660: *   ofname has already been updated if there was an original name.
        -: 5661: * OUT assertions: ifd and ofd are closed in case of error.
        -: 5662: */
function create_outfile called 0 returned 0% blocks executed 0%
    #####: 5663:local int create_outfile()
        -: 5664:{
        -: 5665:    struct stat	ostat; /* stat for ofname */
    #####: 5666:    int flags = O_WRONLY | O_CREAT | O_EXCL | O_BINARY;
        -: 5667:
    #####: 5668:    if (ascii && decompress) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 5669:	flags &= ~O_BINARY; /* force ascii text mode */
        -: 5670:    }
        -: 5671:    for (;;) {
        -: 5672:	/* Make sure that ofname is not an existing file */
    #####: 5673:	if (check_ofname() != OK) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 5674:	    close(ifd);
call    0 never executed
    #####: 5675:	    return ERROR;
        -: 5676:	}
        -: 5677:	/* Create the output file */
    #####: 5678:	remove_ofname = 1;
    #####: 5679:	ofd = OPEN(ofname, flags, RW_USER);
call    0 never executed
    #####: 5680:	if (ofd == -1) {
branch  0 never executed
branch  1 never executed
    #####: 5681:	    perror(ofname);
call    0 never executed
    #####: 5682:	    close(ifd);
call    0 never executed
    #####: 5683:	    exit_code = ERROR;
    #####: 5684:	    return ERROR;
        -: 5685:	}
        -: 5686:
        -: 5687:	/* Check for name truncation on new file (1234567890123.gz) */
        -: 5688:#ifdef NO_FSTAT
        -: 5689:	if (stat(ofname, &ostat) != 0) {
        -: 5690:#else
    #####: 5691:	if (fstat(ofd, &ostat) != 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 5692:#endif
    #####: 5693:	    fprintf(stderr, "%s: ", progname);
call    0 never executed
    #####: 5694:	    perror(ofname);
call    0 never executed
    #####: 5695:	    close(ifd); close(ofd);
call    0 never executed
call    1 never executed
    #####: 5696:	    unlink(ofname);
call    0 never executed
    #####: 5697:	    exit_code = ERROR;
    #####: 5698:	    return ERROR;
        -: 5699:	}
    #####: 5700:	if (!name_too_long(ofname, &ostat)) return OK;
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 5701:
    #####: 5702:	if (decompress) {
branch  0 never executed
branch  1 never executed
        -: 5703:	    /* name might be too long if an original name was saved */
    #####: 5704:	    WARN((stderr, "%s: %s: warning, name truncated\n",
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 5705:		  progname, ofname));
    #####: 5706:	    return OK;
        -: 5707:	}
    #####: 5708:	close(ofd);
call    0 never executed
    #####: 5709:	unlink(ofname);
call    0 never executed
        -: 5710:#ifdef NO_MULTIPLE_DOTS
        -: 5711:	/* Should never happen, see check_ofname() */
        -: 5712:	fprintf(stderr, "%s: %s: name too long\n", progname, ofname);
        -: 5713:	do_exit(ERROR);
        -: 5714:#endif
    #####: 5715:	shorten_name(ofname);
call    0 never executed
        -: 5716:    }
        -: 5717:}
        -: 5718:
        -: 5719:/* ========================================================================
        -: 5720: * Use lstat if available, except for -c or -f. Use stat otherwise.
        -: 5721: * This allows links when not removing the original file.
        -: 5722: */
function do_stat called 23 returned 100% blocks executed 100%
       23: 5723:local int do_stat(name, sbuf)
        -: 5724:    char *name;
        -: 5725:    struct stat *sbuf;
        -: 5726:{
       23: 5727:    errno = 0;
        -: 5728:#if (defined(S_IFLNK) || defined (S_ISLNK)) && !defined(NO_SYMLINK)
       23: 5729:    if (!to_stdout && !force) {
branch  0 taken 21 (fallthrough)
branch  1 taken 2
branch  2 taken 20 (fallthrough)
branch  3 taken 1
       20: 5730:	return lstat(name, sbuf);
call    0 returned 20
        -: 5731:    }
        -: 5732:#endif
        3: 5733:    return stat(name, sbuf);
call    0 returned 3
        -: 5734:}
        -: 5735:
        -: 5736:/* ========================================================================
        -: 5737: * Return a pointer to the 'z' suffix of a file name, or NULL. For all
        -: 5738: * systems, ".gz", ".z", ".Z", ".taz", ".tgz", "-gz", "-z" and "_z" are
        -: 5739: * accepted suffixes, in addition to the value of the --suffix option.
        -: 5740: * ".tgz" is a useful convention for tar.z files on systems limited
        -: 5741: * to 3 characters extensions. On such systems, ".?z" and ".??z" are
        -: 5742: * also accepted suffixes. For Unix, we do not want to accept any
        -: 5743: * .??z suffix as indicating a compressed file; some people use .xyz
        -: 5744: * to denote volume data.
        -: 5745: *   On systems allowing multiple versions of the same file (such as VMS),
        -: 5746: * this function removes any version suffix in the given name.
        -: 5747: */
function get_suffix called 5 returned 100% blocks executed 87%
        5: 5748:local char *get_suffix(name)
        -: 5749:    char *name;
        -: 5750:{
        -: 5751:    int nlen, slen;
        -: 5752:    char suffix[MAX_SUFFIX+3]; /* last chars of name, forced to lower case */
        -: 5753:    static char *known_suffixes[] =
        -: 5754:       {z_suffix, ".gz", ".z", ".taz", ".tgz", "-gz", "-z", "_z",
        -: 5755:#ifdef MAX_EXT_CHARS
        -: 5756:          "z",
        -: 5757:#endif
        -: 5758:          NULL};
        5: 5759:    char **suf = known_suffixes;
        -: 5760:
       5*: 5761:    if (strequ(z_suffix, "z")) suf++; /* check long suffixes first */
branch  0 taken 0 (fallthrough)
branch  1 taken 5
        -: 5762:
        -: 5763:#ifdef SUFFIX_SEP
        -: 5764:    /* strip a version number from the file name */
        -: 5765:    {
        -: 5766:	char *v = strrchr(name, SUFFIX_SEP);
        -: 5767: 	if (v != NULL) *v = '\0';
        -: 5768:    }
        -: 5769:#endif
        5: 5770:    nlen = strlen(name);
        5: 5771:    if (nlen <= MAX_SUFFIX+2) {
branch  0 taken 2 (fallthrough)
branch  1 taken 3
        2: 5772:        strcpy(suffix, name);
        -: 5773:    } else {
        3: 5774:        strcpy(suffix, name+nlen-MAX_SUFFIX-2);
        -: 5775:    }
        5: 5776:    strlwr(suffix);
call    0 returned 5
        5: 5777:    slen = strlen(suffix);
        -: 5778:    do {
       15: 5779:       int s = strlen(*suf);
       15: 5780:       if (slen > s && suffix[slen-s-1] != PATH_SEP
branch  0 taken 15 (fallthrough)
branch  1 taken 0
branch  2 taken 15 (fallthrough)
branch  3 taken 0
       15: 5781:           && strequ(suffix + slen - s, *suf)) {
branch  0 taken 5 (fallthrough)
branch  1 taken 10
        5: 5782:           return name+nlen-s;
        -: 5783:       }
       10: 5784:    } while (*++suf != NULL);
branch  0 taken 10
branch  1 taken 0 (fallthrough)
        -: 5785:
    #####: 5786:    return NULL;
        -: 5787:}
        -: 5788:
        -: 5789:
        -: 5790:/* ========================================================================
        -: 5791: * Set ifname to the input file name (with a suffix appended if necessary)
        -: 5792: * and istat to its stats. For decompression, if no file exists with the
        -: 5793: * original name, try adding successively z_suffix, .gz, .z, -z and .Z.
        -: 5794: * For MSDOS, we try only z_suffix and z.
        -: 5795: * Return OK or ERROR.
        -: 5796: */
function get_istat called 23 returned 100% blocks executed 57%
       23: 5797:local int get_istat(iname, sbuf)
        -: 5798:    char *iname;
        -: 5799:    struct stat *sbuf;
        -: 5800:{
        -: 5801:    int ilen;  /* strlen(ifname) */
        -: 5802:    static char *suffixes[] = {z_suffix, ".gz", ".z", "-z", ".Z", NULL};
       23: 5803:    char **suf = suffixes;
        -: 5804:    char *s;
        -: 5805:#ifdef NO_MULTIPLE_DOTS
        -: 5806:    char *dot; /* pointer to ifname extension, or NULL */
        -: 5807:#endif
        -: 5808:
       23: 5809:    strcpy(ifname, iname);
        -: 5810:
        -: 5811:    /* If input file exists, return OK. */
       23: 5812:    if (do_stat(ifname, sbuf) == 0) return OK;
call    0 returned 23
branch  1 taken 8 (fallthrough)
branch  2 taken 15
        -: 5813:
       15: 5814:    if (!decompress || errno != ENOENT) {
branch  0 taken 1 (fallthrough)
branch  1 taken 14
branch  2 taken 0 (fallthrough)
branch  3 taken 1
       14: 5815:	perror(ifname);
call    0 returned 14
       14: 5816:	exit_code = ERROR;
       14: 5817:	return ERROR;
        -: 5818:    }
        -: 5819:    /* file.ext doesn't exist, try adding a suffix (after removing any
        -: 5820:     * version number for VMS).
        -: 5821:     */
        1: 5822:    s = get_suffix(ifname);
call    0 returned 1
        1: 5823:    if (s != NULL) {
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 5824:	perror(ifname); /* ifname already has z suffix and does not exist */
call    0 returned 1
        1: 5825:	exit_code = ERROR;
        1: 5826:	return ERROR;
        -: 5827:    }
        -: 5828:#ifdef NO_MULTIPLE_DOTS
        -: 5829:    dot = strrchr(ifname, '.');
        -: 5830:    if (dot == NULL) {
        -: 5831:        strcat(ifname, ".");
        -: 5832:        dot = strrchr(ifname, '.');
        -: 5833:    }
        -: 5834:#endif
    #####: 5835:    ilen = strlen(ifname);
    #####: 5836:    if (strequ(z_suffix, ".gz")) suf++;
branch  0 never executed
branch  1 never executed
        -: 5837:
        -: 5838:    /* Search for all suffixes */
        -: 5839:    do {
    #####: 5840:        s = *suf;
        -: 5841:#ifdef NO_MULTIPLE_DOTS
        -: 5842:        if (*s == '.') s++;
        -: 5843:#endif
        -: 5844:#ifdef MAX_EXT_CHARS
        -: 5845:        strcpy(ifname, iname);
        -: 5846:        /* Needed if the suffixes are not sorted by increasing length */
        -: 5847:
        -: 5848:        if (*dot == '\0') strcpy(dot, ".");
        -: 5849:        dot[MAX_EXT_CHARS+1-strlen(s)] = '\0';
        -: 5850:#endif
    #####: 5851:        strcat(ifname, s);
    #####: 5852:        if (do_stat(ifname, sbuf) == 0) return OK;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 5853:	ifname[ilen] = '\0';
    #####: 5854:    } while (*++suf != NULL);
branch  0 never executed
branch  1 never executed
        -: 5855:
        -: 5856:    /* No suffix found, complain using z_suffix: */
        -: 5857:#ifdef MAX_EXT_CHARS
        -: 5858:    strcpy(ifname, iname);
        -: 5859:    if (*dot == '\0') strcpy(dot, ".");
        -: 5860:    dot[MAX_EXT_CHARS+1-z_len] = '\0';
        -: 5861:#endif
    #####: 5862:    strcat(ifname, z_suffix);
    #####: 5863:    perror(ifname);
call    0 never executed
    #####: 5864:    exit_code = ERROR;
    #####: 5865:    return ERROR;
        -: 5866:}
        -: 5867:
        -: 5868:/* ========================================================================
        -: 5869: * Generate ofname given ifname. Return OK, or WARNING if file must be skipped.
        -: 5870: * Sets save_orig_name to true if the file name has been truncated.
        -: 5871: */
function make_ofname called 4 returned 100% blocks executed 50%
        4: 5872:local int make_ofname()
        -: 5873:{
        -: 5874:    char *suff;            /* ofname z suffix */
        -: 5875:
        4: 5876:    strcpy(ofname, ifname);
        -: 5877:    /* strip a version number if any and get the gzip suffix if present: */
        4: 5878:    suff = get_suffix(ofname);
call    0 returned 4
        -: 5879:
        4: 5880:    if (decompress) {
branch  0 taken 1 (fallthrough)
branch  1 taken 3
        1: 5881:	if (suff == NULL) {
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -: 5882:	    /* Whith -t or -l, try all files (even without .gz suffix)
        -: 5883:	     * except with -r (behave as with just -dr).
        -: 5884:             */
        -: 5885:#ifdef FAULTY_F_KL_4
        -: 5886:	    if (recursive && (list || test)) return OK;
        -: 5887:#else
    #####: 5888:            if (!recursive && (list || test)) return OK;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 5889:#endif
        -: 5890:
        -: 5891:	    /* Avoid annoying messages with -r */
    #####: 5892:	    if (verbose || (!recursive && !quiet)) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 5893:		WARN((stderr,"%s: %s: unknown suffix -- ignored\n",
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 5894:		      progname, ifname));
        -: 5895:	    }
    #####: 5896:	    return WARNING;
        -: 5897:	}
        -: 5898:	/* Make a special case for .tgz and .taz: */
        1: 5899:	strlwr(suff);
call    0 returned 1
        1: 5900:	if (strequ(suff, ".tgz") || strequ(suff, ".taz")) {
branch  0 taken 1 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 1
    #####: 5901:	    strcpy(suff, ".tar");
        -: 5902:	} else {
        1: 5903:	    *suff = '\0'; /* strip the z suffix */
        -: 5904:	}
        -: 5905:        /* ofname might be changed later if infile contains an original name */
        -: 5906:
        3: 5907:    } else if (suff != NULL) {
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        -: 5908:	/* Avoid annoying messages with -r (see treat_dir()) */
       3*: 5909:	if (verbose || (!recursive && !quiet)) {
branch  0 taken 3 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 3
branch  4 never executed
branch  5 never executed
    #####: 5910:	    fprintf(stderr, "%s: %s already has %s suffix -- unchanged\n",
call    0 never executed
        -: 5911:		    progname, ifname, suff);
        -: 5912:	}
        3: 5913:	if (exit_code == OK) exit_code = WARNING;
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        3: 5914:	return WARNING;
        -: 5915:    } else {
    #####: 5916:        save_orig_name = 0;
        -: 5917:
        -: 5918:#ifdef NO_MULTIPLE_DOTS
        -: 5919:	suff = strrchr(ofname, '.');
        -: 5920:	if (suff == NULL) {
        -: 5921:            strcat(ofname, ".");
        -: 5922:#  ifdef MAX_EXT_CHARS
        -: 5923:	    if (strequ(z_suffix, "z")) {
        -: 5924:		strcat(ofname, "gz"); /* enough room */
        -: 5925:		return OK;
        -: 5926:	    }
        -: 5927:        /* On the Atari and some versions of MSDOS, name_too_long()
        -: 5928:         * does not work correctly because of a bug in stat(). So we
        -: 5929:         * must truncate here.
        -: 5930:         */
        -: 5931:        } else if (strlen(suff)-1 + z_len > MAX_SUFFIX) {
        -: 5932:            suff[MAX_SUFFIX+1-z_len] = '\0';
        -: 5933:            save_orig_name = 1;
        -: 5934:#  endif
        -: 5935:        }
        -: 5936:#endif /* NO_MULTIPLE_DOTS */
    #####: 5937:	strcat(ofname, z_suffix);
        -: 5938:
        -: 5939:    } /* decompress ? */
        1: 5940:    return OK;
        -: 5941:}
        -: 5942:
        -: 5943:
        -: 5944:/* ========================================================================
        -: 5945: * Check the magic number of the input file and update ofname if an
        -: 5946: * original name was given and to_stdout is not set.
        -: 5947: * Return the compression method, -1 for error, -2 for warning.
        -: 5948: * Set inptr to the offset of the next byte to be processed.
        -: 5949: * Updates time_stamp if there is one and --no-time is not used.
        -: 5950: * This function may be called repeatedly for an input file consisting
        -: 5951: * of several contiguous gzip'ed members.
        -: 5952: * IN assertions: there is at least one remaining compressed member.
        -: 5953: *   If the member is a zip file, it must be the only one.
        -: 5954: */
function get_method called 16 returned 94% blocks executed 42%
       16: 5955:local int get_method(in)
        -: 5956:    int in;        /* input file descriptor */
        -: 5957:{
        -: 5958:    uch flags;     /* compression flags */
        -: 5959:    char magic[2]; /* magic header */
        -: 5960:    ulg stamp;     /* time stamp */
        -: 5961:
        -: 5962:    /* If --force and --stdout, zcat == cat, so do not complain about
        -: 5963:     * premature end of file: use try_byte instead of get_byte.
        -: 5964:     */
      16*: 5965:    if (force && to_stdout) {
branch  0 taken 0 (fallthrough)
branch  1 taken 16
branch  2 never executed
branch  3 never executed
    #####: 5966:	magic[0] = (char)try_byte();
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 5967:	magic[1] = (char)try_byte();
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 5968:	/* If try_byte returned EOF, magic[1] == 0xff */
        -: 5969:    } else {
       16: 5970:	magic[0] = (char)get_byte();
branch  0 taken 1 (fallthrough)
branch  1 taken 15
call    2 returned 15
      16*: 5971:	magic[1] = (char)get_byte();
branch  0 taken 16 (fallthrough)
branch  1 taken 0
call    2 never executed
        -: 5972:    }
       16: 5973:    method = -1;                 /* unknown yet */
       16: 5974:    part_nb++;                   /* number of parts in gzip file */
       16: 5975:    header_bytes = 0;
       16: 5976:    last_member = RECORD_IO;
        -: 5977:    /* assume multiple members in gzip file except for record oriented I/O */
        -: 5978:
       16: 5979:    if (memcmp(magic, GZIP_MAGIC, 2) == 0
branch  0 taken 5 (fallthrough)
branch  1 taken 11
        5: 5980:        || memcmp(magic, OLD_GZIP_MAGIC, 2) == 0) {
branch  0 taken 0 (fallthrough)
branch  1 taken 5
        -: 5981:
      11*: 5982:	method = (int)get_byte();
branch  0 taken 11 (fallthrough)
branch  1 taken 0
call    2 never executed
       11: 5983:	if (method != DEFLATED) {
branch  0 taken 0 (fallthrough)
branch  1 taken 11
    #####: 5984:	    fprintf(stderr,
call    0 never executed
        -: 5985:		    "%s: %s: unknown method %d -- get newer version of gzip\n",
        -: 5986:		    progname, ifname, method);
    #####: 5987:	    exit_code = ERROR;
    #####: 5988:	    return -1;
        -: 5989:	}
       11: 5990:	work = unzip;
      11*: 5991:	flags  = (uch)get_byte();
branch  0 taken 11 (fallthrough)
branch  1 taken 0
call    2 never executed
        -: 5992:
       11: 5993:	if ((flags & ENCRYPTED) != 0) {
branch  0 taken 0 (fallthrough)
branch  1 taken 11
    #####: 5994:	    fprintf(stderr,
call    0 never executed
        -: 5995:		    "%s: %s is encrypted -- get newer version of gzip\n",
        -: 5996:		    progname, ifname);
    #####: 5997:	    exit_code = ERROR;
    #####: 5998:	    return -1;
        -: 5999:	}
       11: 6000:	if ((flags & CONTINUATION) != 0) {
branch  0 taken 0 (fallthrough)
branch  1 taken 11
    #####: 6001:	    fprintf(stderr,
call    0 never executed
        -: 6002:	   "%s: %s is a a multi-part gzip file -- get newer version of gzip\n",
        -: 6003:		    progname, ifname);
    #####: 6004:	    exit_code = ERROR;
    #####: 6005:	    if (force <= 1) return -1;
branch  0 never executed
branch  1 never executed
        -: 6006:	}
       11: 6007:	if ((flags & RESERVED) != 0) {
branch  0 taken 0 (fallthrough)
branch  1 taken 11
    #####: 6008:	    fprintf(stderr,
call    0 never executed
        -: 6009:		    "%s: %s has flags 0x%x -- get newer version of gzip\n",
        -: 6010:		    progname, ifname, flags);
    #####: 6011:	    exit_code = ERROR;
    #####: 6012:	    if (force <= 1) return -1;
branch  0 never executed
branch  1 never executed
        -: 6013:	}
      11*: 6014:	stamp  = (ulg)get_byte();
branch  0 taken 11 (fallthrough)
branch  1 taken 0
call    2 never executed
      11*: 6015:	stamp |= ((ulg)get_byte()) << 8;
branch  0 taken 11 (fallthrough)
branch  1 taken 0
call    2 never executed
      11*: 6016:	stamp |= ((ulg)get_byte()) << 16;
branch  0 taken 11 (fallthrough)
branch  1 taken 0
call    2 never executed
      11*: 6017:	stamp |= ((ulg)get_byte()) << 24;
branch  0 taken 11 (fallthrough)
branch  1 taken 0
call    2 never executed
      11*: 6018:	if (stamp != 0 && !no_time) time_stamp = stamp;
branch  0 taken 11 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 11
        -: 6019:	/* this is not original code -- modified by MAPSTEXT */
       11: 6020:	time_stamp = 0;
        -: 6021:
      11*: 6022:	(void)get_byte();  /* Ignore extra flags for the moment */
branch  0 taken 11 (fallthrough)
branch  1 taken 0
call    2 never executed
      11*: 6023:	(void)get_byte();  /* Ignore OS type for the moment */
branch  0 taken 11 (fallthrough)
branch  1 taken 0
call    2 never executed
        -: 6024:
       11: 6025:	if ((flags & CONTINUATION) != 0) {
branch  0 taken 0 (fallthrough)
branch  1 taken 11
    #####: 6026:	    unsigned part = (unsigned)get_byte();
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 6027:	    part |= ((unsigned)get_byte())<<8;
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 6028:	    if (verbose) {
branch  0 never executed
branch  1 never executed
    #####: 6029:		fprintf(stderr,"%s: %s: part number %u\n",
call    0 never executed
        -: 6030:			progname, ifname, part);
        -: 6031:	    }
        -: 6032:	}
       11: 6033:	if ((flags & EXTRA_FIELD) != 0) {
branch  0 taken 0 (fallthrough)
branch  1 taken 11
    #####: 6034:	    unsigned len = (unsigned)get_byte();
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 6035:	    len |= ((unsigned)get_byte())<<8;
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 6036:	    if (verbose) {
branch  0 never executed
branch  1 never executed
    #####: 6037:		fprintf(stderr,"%s: %s: extra field of %u bytes ignored\n",
call    0 never executed
        -: 6038:			progname, ifname, len);
        -: 6039:	    }
    #####: 6040:	    while (len--) (void)get_byte();
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 6041:	}
        -: 6042:
        -: 6043:	/* Get original file name if it was truncated */
       11: 6044:	if ((flags & ORIG_NAME) != 0) {
branch  0 taken 3 (fallthrough)
branch  1 taken 8
       5*: 6045:	    if (no_name || (to_stdout && !list) || part_nb > 1) {
branch  0 taken 0 (fallthrough)
branch  1 taken 3
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -: 6046:		/* Discard the old name */
        -: 6047:		char c; /* dummy used for NeXTstep 3.0 cc optimizer bug */
    1828*: 6048:		do {c=get_byte();} while (c != 0);
branch  0 taken 1827 (fallthrough)
branch  1 taken 1
call    2 returned 0
branch  3 taken 1825
branch  4 taken 2 (fallthrough)
        -: 6049:	    } else {
        -: 6050:		/* Copy the base name. Keep a directory prefix intact. */
    #####: 6051:                char *p = basename(ofname);
call    0 never executed
    #####: 6052:                char *base = p;
        -: 6053:		for (;;) {
    #####: 6054:		    *p = (char)get_char();
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 6055:		    if (*p++ == '\0') break;
branch  0 never executed
branch  1 never executed
    #####: 6056:		    if (p >= ofname+sizeof(ofname)) {
branch  0 never executed
branch  1 never executed
    #####: 6057:			error("corrupted input -- file name too large");
call    0 never executed
        -: 6058:		    }
        -: 6059:		}
        -: 6060:                /* If necessary, adapt the name to local OS conventions: */
    #####: 6061:                if (!list) {
branch  0 never executed
branch  1 never executed
        -: 6062:                   MAKE_LEGAL_NAME(base);
        -: 6063:#ifdef FAULTY_F_KL_10
        -: 6064:	if (base) list=1;
        -: 6065:#else
    #####: 6066:		   if (base) list=0; /* avoid warning about unused variable */
branch  0 never executed
branch  1 never executed
        -: 6067:#endif
        -: 6068:                }
        -: 6069:	    } /* no_name || to_stdout */
        -: 6070:	} /* ORIG_NAME */
        -: 6071:
        -: 6072:	/* Discard file comment if any */
       10: 6073:	if ((flags & COMMENT) != 0) {
branch  0 taken 0 (fallthrough)
branch  1 taken 10
    #####: 6074:	    while (get_char() != 0) /* null */ ;
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 6075:	}
       10: 6076:	if (part_nb == 1) {
branch  0 taken 10 (fallthrough)
branch  1 taken 0
       10: 6077:	    header_bytes = inptr + 2*sizeof(long); /* include crc and size */
        -: 6078:	}
        -: 6079:
        5: 6080:    } else if (memcmp(magic, PKZIP_MAGIC, 2) == 0 && inptr == 2
branch  0 taken 2 (fallthrough)
branch  1 taken 3
branch  2 taken 2 (fallthrough)
branch  3 taken 0
        2: 6081:	    && memcmp((char*)inbuf, PKZIP_MAGIC, 4) == 0) {
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        -: 6082:	/* To simplify the code, we support a zip file when alone only.
        -: 6083:         * We are thus guaranteed that the entire local header fits in inbuf.
        -: 6084:         */
        2: 6085:        inptr = 0;
        2: 6086:	work = unzip;
       2*: 6087:	if (check_zipfile(in) != OK) return -1;
call    0 returned 2
branch  1 taken 0 (fallthrough)
branch  2 taken 2
        -: 6088:	/* check_zipfile may get ofname from the local header */
        2: 6089:	last_member = 1;
        -: 6090:
        3: 6091:    } else if (memcmp(magic, PACK_MAGIC, 2) == 0) {
branch  0 taken 1 (fallthrough)
branch  1 taken 2
        1: 6092:	work = unpack;
        1: 6093:	method = PACKED;
        -: 6094:
        2: 6095:    } else if (memcmp(magic, LZW_MAGIC, 2) == 0) {
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        1: 6096:	work = unlzw;
        1: 6097:	method = COMPRESSED;
        1: 6098:	last_member = 1;
        -: 6099:
        1: 6100:    } else if (memcmp(magic, LZH_MAGIC, 2) == 0) {
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 6101:	work = unlzh;
    #####: 6102:	method = LZHED;
    #####: 6103:	last_member = 1;
        -: 6104:
       1*: 6105:    } else if (force && to_stdout && !list) { /* pass input unchanged */
branch  0 taken 0 (fallthrough)
branch  1 taken 1
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 6106:	method = STORED;
    #####: 6107:	work = copy;
    #####: 6108:        inptr = 0;
    #####: 6109:	last_member = 1;
        -: 6110:    }
       15: 6111:    if (method >= 0) return method;
branch  0 taken 14 (fallthrough)
branch  1 taken 1
        -: 6112:
        1: 6113:    if (part_nb == 1) {
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 6114:	fprintf(stderr, "\n%s: %s: not in gzip format\n", progname, ifname);
call    0 never executed
    #####: 6115:	exit_code = ERROR;
    #####: 6116:	return -1;
        -: 6117:    } else {
        1: 6118:	WARN((stderr, "\n%s: %s: decompression OK, trailing garbage ignored\n",
branch  0 taken 1 (fallthrough)
branch  1 taken 0
call    2 returned 1
branch  3 taken 1 (fallthrough)
branch  4 taken 0
        -: 6119:	      progname, ifname));
        1: 6120:	return -2;
        -: 6121:    }
        -: 6122:}
        -: 6123:
        -: 6124:/* ========================================================================
        -: 6125: * Display the characteristics of the compressed file.
        -: 6126: * If the given method is < 0, display the accumulated totals.
        -: 6127: * IN assertions: time_stamp, header_bytes and ifile_size are initialized.
        -: 6128: */
function do_list called 0 returned 0% blocks executed 0%
    #####: 6129:local void do_list(ifd, method)
        -: 6130:    int ifd;     /* input file descriptor */
        -: 6131:    int method;  /* compression method */
        -: 6132:{
        -: 6133:    ulg crc;  /* original crc */
        -: 6134:    static int first_time = 1;
        -: 6135:    static char* methods[MAX_METHODS] = {
        -: 6136:        "store",  /* 0 */
        -: 6137:        "compr",  /* 1 */
        -: 6138:        "pack ",  /* 2 */
        -: 6139:        "lzh  ",  /* 3 */
        -: 6140:        "", "", "", "", /* 4 to 7 reserved */
        -: 6141:        "defla"}; /* 8 */
        -: 6142:    char *date;
        -: 6143:
    #####: 6144:    if (first_time && method >= 0) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 6145:	first_time = 0;
    #####: 6146:	if (verbose)  {
branch  0 never executed
branch  1 never executed
    #####: 6147:	    printf("method  crc     date  time  ");
call    0 never executed
        -: 6148:	}
    #####: 6149:	if (!quiet) {
branch  0 never executed
branch  1 never executed
    #####: 6150:	    printf("compressed  uncompr. ratio uncompressed_name\n");
call    0 never executed
        -: 6151:	}
    #####: 6152:    } else if (method < 0) {
branch  0 never executed
branch  1 never executed
    #####: 6153:	if (total_in <= 0 || total_out <= 0) return;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 6154:	if (verbose) {
branch  0 never executed
branch  1 never executed
    #####: 6155:	    printf("                            %9lu %9lu ",
call    0 never executed
        -: 6156:		   total_in, total_out);
    #####: 6157:	} else if (!quiet) {
branch  0 never executed
branch  1 never executed
    #####: 6158:	    printf("%9ld %9ld ", total_in, total_out);
call    0 never executed
        -: 6159:	}
    #####: 6160:	display_ratio(total_out-(total_in-header_bytes), total_out, stdout);
call    0 never executed
        -: 6161:	/* header_bytes is not meaningful but used to ensure the same
        -: 6162:	 * ratio if there is a single file.
        -: 6163:	 */
    #####: 6164:	printf(" (totals)\n");
call    0 never executed
    #####: 6165:	return;
        -: 6166:    }
    #####: 6167:    crc = (ulg)~0; /* unknown */
    #####: 6168:    bytes_out = -1L;
    #####: 6169:    bytes_in = ifile_size;
        -: 6170:
        -: 6171:#if RECORD_IO == 0
    #####: 6172:    if (method == DEFLATED && !last_member) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 6173:        /* Get the crc and uncompressed size for gzip'ed (not zip'ed) files.
        -: 6174:         * If the lseek fails, we could use read() to get to the end, but
        -: 6175:         * --list is used to get quick results.
        -: 6176:         * Use "gunzip < foo.gz | wc -c" to get the uncompressed size if
        -: 6177:         * you are not concerned about speed.
        -: 6178:         */
    #####: 6179:        bytes_in = (long)lseek(ifd, (off_t)(-8), SEEK_END);
call    0 never executed
    #####: 6180:        if (bytes_in != -1L) {
branch  0 never executed
branch  1 never executed
        -: 6181:            uch buf[8];
    #####: 6182:            bytes_in += 8L;
    #####: 6183:            if (read(ifd, (char*)buf, sizeof(buf)) != sizeof(buf)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 6184:                read_error();
call    0 never executed
        -: 6185:            }
    #####: 6186:            crc       = LG(buf);
    #####: 6187:	    bytes_out = LG(buf+4);
        -: 6188:	}
        -: 6189:    }
        -: 6190:#endif /* RECORD_IO */
    #####: 6191:    date = ctime((time_t*)&time_stamp) + 4; /* skip the day of the week */
call    0 never executed
    #####: 6192:    date[12] = '\0';               /* suppress the 1/100sec and the year */
    #####: 6193:    if (verbose) {
branch  0 never executed
branch  1 never executed
    #####: 6194:        printf("%5s %08lx %11s ", methods[method], crc, date);
call    0 never executed
        -: 6195:    }
    #####: 6196:    printf("%9ld %9ld ", bytes_in, bytes_out);
call    0 never executed
    #####: 6197:    if (bytes_in  == -1L) {
branch  0 never executed
branch  1 never executed
    #####: 6198:	total_in = -1L;
    #####: 6199:	bytes_in = bytes_out = header_bytes = 0;
    #####: 6200:    } else if (total_in >= 0) {
branch  0 never executed
branch  1 never executed
    #####: 6201:	total_in  += bytes_in;
        -: 6202:    }
    #####: 6203:    if (bytes_out == -1L) {
branch  0 never executed
branch  1 never executed
    #####: 6204:	total_out = -1L;
    #####: 6205:	bytes_in = bytes_out = header_bytes = 0;
    #####: 6206:    } else if (total_out >= 0) {
branch  0 never executed
branch  1 never executed
    #####: 6207:	total_out += bytes_out;
        -: 6208:    }
    #####: 6209:    display_ratio(bytes_out-(bytes_in-header_bytes), bytes_out, stdout);
call    0 never executed
    #####: 6210:    printf(" %s\n", ofname);
call    0 never executed
        -: 6211:}
        -: 6212:
        -: 6213:/* ========================================================================
        -: 6214: * Return true if the two stat structures correspond to the same file.
        -: 6215: */
function same_file called 0 returned 0% blocks executed 0%
    #####: 6216:local int same_file(stat1, stat2)
        -: 6217:    struct stat *stat1;
        -: 6218:    struct stat *stat2;
        -: 6219:{
    #####: 6220:    return stat1->st_ino   == stat2->st_ino
    #####: 6221:	&& stat1->st_dev   == stat2->st_dev
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 6222:#ifdef NO_ST_INO
        -: 6223:        /* Can't rely on st_ino and st_dev, use other fields: */
        -: 6224:	&& stat1->st_mode  == stat2->st_mode
        -: 6225:	&& stat1->st_uid   == stat2->st_uid
        -: 6226:	&& stat1->st_gid   == stat2->st_gid
        -: 6227:	&& stat1->st_size  == stat2->st_size
        -: 6228:	&& stat1->st_atime == stat2->st_atime
        -: 6229:	&& stat1->st_mtime == stat2->st_mtime
        -: 6230:	&& stat1->st_ctime == stat2->st_ctime
        -: 6231:#endif
        -: 6232:	    ;
        -: 6233:}
        -: 6234:
        -: 6235:/* ========================================================================
        -: 6236: * Return true if a file name is ambiguous because the operating system
        -: 6237: * truncates file names.
        -: 6238: */
function name_too_long called 0 returned 0% blocks executed 0%
    #####: 6239:local int name_too_long(name, statb)
        -: 6240:    char *name;           /* file name to check */
        -: 6241:    struct stat *statb;   /* stat buf for this file name */
        -: 6242:{
    #####: 6243:    int s = strlen(name);
    #####: 6244:    char c = name[s-1];
        -: 6245:    struct stat	tstat; /* stat for truncated name */
        -: 6246:    int res;
        -: 6247:
    #####: 6248:    tstat = *statb;      /* Just in case OS does not fill all fields */
    #####: 6249:    name[s-1] = '\0';
    #####: 6250:    res = stat(name, &tstat) == 0 && same_file(statb, &tstat);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 6251:    name[s-1] = c;
        -: 6252:    Trace((stderr, " too_long(%s) => %d\n", name, res));
    #####: 6253:    return res;
        -: 6254:}
        -: 6255:
        -: 6256:/* ========================================================================
        -: 6257: * Shorten the given name by one character, or replace a .tar extension
        -: 6258: * with .tgz. Truncate the last part of the name which is longer than
        -: 6259: * MIN_PART characters: 1234.678.012.gz -> 123.678.012.gz. If the name
        -: 6260: * has only parts shorter than MIN_PART truncate the longest part.
        -: 6261: * For decompression, just remove the last character of the name.
        -: 6262: *
        -: 6263: * IN assertion: for compression, the suffix of the given name is z_suffix.
        -: 6264: */
function shorten_name called 0 returned 0% blocks executed 0%
    #####: 6265:local void shorten_name(name)
        -: 6266:    char *name;
        -: 6267:{
        -: 6268:    int len;                 /* length of name without z_suffix */
    #####: 6269:    char *trunc = NULL;      /* character to be truncated */
        -: 6270:    int plen;                /* current part length */
    #####: 6271:    int min_part = MIN_PART; /* current minimum part length */
        -: 6272:    char *p;
        -: 6273:
    #####: 6274:    len = strlen(name);
    #####: 6275:    if (decompress) {
branch  0 never executed
branch  1 never executed
    #####: 6276:	if (len <= 1) error("name too short");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 6277:#ifdef FAULTY_F_KL_6
        -: 6278:	name[len] = '\0';
        -: 6279:#else
    #####: 6280:	name[len-1] = '\0';
        -: 6281:#endif
    #####: 6282:	return;
        -: 6283:    }
    #####: 6284:    p = get_suffix(name);
call    0 never executed
    #####: 6285:    if (p == NULL) error("can't recover suffix\n");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 6286:    *p = '\0';
    #####: 6287:    save_orig_name = 1;
        -: 6288:
        -: 6289:    /* compress 1234567890.tar to 1234567890.tgz */
    #####: 6290:    if (len > 4 && strequ(p-4, ".tar")) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 6291:	strcpy(p-4, ".tgz");
    #####: 6292:	return;
        -: 6293:    }
        -: 6294:    /* Try keeping short extensions intact:
        -: 6295:     * 1234.678.012.gz -> 123.678.012.gz
        -: 6296:     */
        -: 6297:    do {
    #####: 6298:	p = strrchr(name, PATH_SEP);
    #####: 6299:	p = p ? p+1 : name;
branch  0 never executed
branch  1 never executed
    #####: 6300:	while (*p) {
branch  0 never executed
branch  1 never executed
    #####: 6301:	    plen = strcspn(p, PART_SEP);
    #####: 6302:	    p += plen;
    #####: 6303:	    if (plen > min_part) trunc = p-1;
branch  0 never executed
branch  1 never executed
    #####: 6304:	    if (*p) p++;
branch  0 never executed
branch  1 never executed
        -: 6305:	}
    #####: 6306:    } while (trunc == NULL && --min_part != 0);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 6307:
    #####: 6308:    if (trunc != NULL) {
branch  0 never executed
branch  1 never executed
        -: 6309:	do {
    #####: 6310:	    trunc[0] = trunc[1];
    #####: 6311:	} while (*trunc++);
branch  0 never executed
branch  1 never executed
    #####: 6312:	trunc--;
        -: 6313:    } else {
    #####: 6314:	trunc = strrchr(name, PART_SEP[0]);
    #####: 6315:	if (trunc == NULL) error("internal error in shorten_name");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 6316:	if (trunc[1] == '\0') trunc--; /* force truncation */
branch  0 never executed
branch  1 never executed
        -: 6317:    }
    #####: 6318:    strcpy(trunc, z_suffix);
        -: 6319:}
        -: 6320:
        -: 6321:/* ========================================================================
        -: 6322: * If compressing to a file, check if ofname is not ambiguous
        -: 6323: * because the operating system truncates names. Otherwise, generate
        -: 6324: * a new ofname and save the original name in the compressed file.
        -: 6325: * If the compressed file already exists, ask for confirmation.
        -: 6326: *    The check for name truncation is made dynamically, because different
        -: 6327: * file systems on the same OS might use different truncation rules (on SVR4
        -: 6328: * s5 truncates to 14 chars and ufs does not truncate).
        -: 6329: *    This function returns -1 if the file must be skipped, and
        -: 6330: * updates save_orig_name if necessary.
        -: 6331: * IN assertions: save_orig_name is already set if ofname has been
        -: 6332: * already truncated because of NO_MULTIPLE_DOTS. The input file has
        -: 6333: * already been open and istat is set.
        -: 6334: */
function check_ofname called 0 returned 0% blocks executed 0%
    #####: 6335:local int check_ofname()
        -: 6336:{
        -: 6337:    struct stat	ostat; /* stat for ofname */
        -: 6338:
        -: 6339:#ifdef ENAMETOOLONG
        -: 6340:    /* Check for strictly conforming Posix systems (which return ENAMETOOLONG
        -: 6341:     * instead of silently truncating filenames).
        -: 6342:     */
    #####: 6343:    errno = 0;
    #####: 6344:    while (stat(ofname, &ostat) != 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 6345:        if (errno != ENAMETOOLONG) return 0; /* ofname does not exist */
branch  0 never executed
branch  1 never executed
    #####: 6346:	shorten_name(ofname);
call    0 never executed
        -: 6347:    }
        -: 6348:#else
        -: 6349:    if (stat(ofname, &ostat) != 0) return 0;
        -: 6350:#endif
        -: 6351:    /* Check for name truncation on existing file. Do this even on systems
        -: 6352:     * defining ENAMETOOLONG, because on most systems the strict Posix
        -: 6353:     * behavior is disabled by default (silent name truncation allowed).
        -: 6354:     */
    #####: 6355:    if (!decompress && name_too_long(ofname, &ostat)) {
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 6356:	shorten_name(ofname);
call    0 never executed
    #####: 6357:	if (stat(ofname, &ostat) != 0) return 0;
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 6358:    }
        -: 6359:
        -: 6360:    /* Check that the input and output files are different (could be
        -: 6361:     * the same by name truncation or links).
        -: 6362:     */
    #####: 6363:    if (same_file(&istat, &ostat)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 6364:#ifndef FAULTY_F_KP_4
    #####: 6365:	if (strequ(ifname, ofname)) {
branch  0 never executed
branch  1 never executed
    #####: 6366:	    fprintf(stderr, "%s: %s: cannot %scompress onto itself\n",
call    0 never executed
    #####: 6367:		    progname, ifname, decompress ? "de" : "");
branch  0 never executed
branch  1 never executed
        -: 6368:	} else {
    #####: 6369:	    fprintf(stderr, "%s: %s and %s are the same file\n",
call    0 never executed
        -: 6370:		    progname, ifname, ofname);
        -: 6371:	}
        -: 6372:#else
        -: 6373:	if (strequ(ifname, ofname)) {
        -: 6374:	    fprintf(stderr, "%s: %s and %s are the same file\n",
        -: 6375:		    progname, ifname, ofname);
        -: 6376:	} else {
        -: 6377:	    fprintf(stderr, "%s: %s: cannot %scompress onto itself\n",
        -: 6378:		    progname, ifname, decompress ? "de" : "");
        -: 6379:	}
        -: 6380:#endif
    #####: 6381:	exit_code = ERROR;
    #####: 6382:	return ERROR;
        -: 6383:    }
        -: 6384:    /* Ask permission to overwrite the existing file */
    #####: 6385:    if (!force) {
branch  0 never executed
branch  1 never executed
        -: 6386:	char response[80];
    #####: 6387:	strcpy(response,"n");
    #####: 6388:	fprintf(stderr, "%s: %s already exists;", progname, ofname);
call    0 never executed
    #####: 6389:	if (foreground && isatty(fileno(stdin))) {
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 6390:	    fprintf(stderr, " do you wish to overwrite (y or n)? ");
call    0 never executed
    #####: 6391:	    fflush(stderr);
call    0 never executed
    #####: 6392:	    (void)fgets(response, sizeof(response)-1, stdin);
call    0 never executed
        -: 6393:	}
    #####: 6394:	if (tolow(*response) != 'y') {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 6395:	    fprintf(stderr, "\tnot overwritten\n");
call    0 never executed
    #####: 6396:	    if (exit_code == OK) exit_code = WARNING;
branch  0 never executed
branch  1 never executed
    #####: 6397:	    return ERROR;
        -: 6398:	}
        -: 6399:    }
    #####: 6400:    (void) chmod(ofname, 0777);
call    0 never executed
    #####: 6401:    if (unlink(ofname)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 6402:	fprintf(stderr, "%s: ", progname);
call    0 never executed
    #####: 6403:	perror(ofname);
call    0 never executed
    #####: 6404:	exit_code = ERROR;
    #####: 6405:	return ERROR;
        -: 6406:    }
    #####: 6407:    return OK;
        -: 6408:}
        -: 6409:
        -: 6410:
        -: 6411:#ifndef NO_UTIME
        -: 6412:/* ========================================================================
        -: 6413: * Set the access and modification times from the given stat buffer.
        -: 6414: */
function reset_times called 3 returned 100% blocks executed 30%
        3: 6415:local void reset_times (name, statb)
        -: 6416:    char *name;
        -: 6417:    struct stat *statb;
        -: 6418:{
        -: 6419:    struct utimbuf	timep;
        -: 6420:
        -: 6421:    /* Copy the time stamp */
        3: 6422:    timep.actime  = statb->st_atime;
        3: 6423:    timep.modtime = statb->st_mtime;
        -: 6424:
        -: 6425:    /* Some systems (at least OS/2) do not support utime on directories */
       3*: 6426:    if (utime(name, &timep) && !S_ISDIR(statb->st_mode)) {
call    0 returned 3
branch  1 taken 0 (fallthrough)
branch  2 taken 3
branch  3 never executed
branch  4 never executed
    #####: 6427:	WARN((stderr, "%s: ", progname));
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 6428:	if (!quiet) perror(ofname);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 6429:    }
        3: 6430:}
        -: 6431:#endif
        -: 6432:
        -: 6433:
        -: 6434:/* ========================================================================
        -: 6435: * Copy modes, times, ownership from input file to output file.
        -: 6436: * IN assertion: to_stdout is false.
        -: 6437: */
function copy_stat called 0 returned 0% blocks executed 0%
    #####: 6438:local void copy_stat(ifstat)
        -: 6439:    struct stat *ifstat;
        -: 6440:{
        -: 6441:#ifndef NO_UTIME
    #####: 6442:    if (decompress && time_stamp != 0 && ifstat->st_mtime != time_stamp) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 6443:	ifstat->st_mtime = time_stamp;
        -: 6444:#ifndef FAULTY_F_KP_5
    #####: 6445:	if (verbose > 1) {
branch  0 never executed
branch  1 never executed
        -: 6446:#else
        -: 6447:	if (verbose <= 1) {
        -: 6448:#endif
    #####: 6449:	    fprintf(stderr, "%s: time stamp restored\n", ofname);
call    0 never executed
        -: 6450:	}
        -: 6451:    }
    #####: 6452:    reset_times(ofname, ifstat);
call    0 never executed
        -: 6453:
        -: 6454:#endif
        -: 6455:    /* Copy the protection modes */
    #####: 6456:    if (chmod(ofname, ifstat->st_mode & 07777)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 6457:	WARN((stderr, "%s: ", progname));
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 6458:	if (!quiet) perror(ofname);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 6459:    }
        -: 6460:#ifndef NO_CHOWN
    #####: 6461:    chown(ofname, ifstat->st_uid, ifstat->st_gid);  /* Copy ownership */
call    0 never executed
        -: 6462:#endif
    #####: 6463:    remove_ofname = 0;
        -: 6464:    /* It's now safe to remove the input file: */
    #####: 6465:    (void) chmod(ifname, 0777);
call    0 never executed
    #####: 6466:    if (unlink(ifname)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 6467:	WARN((stderr, "%s: ", progname));
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 6468:	if (!quiet) perror(ifname);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 6469:    }
    #####: 6470:}
        -: 6471:
        -: 6472:#ifndef NO_DIR
        -: 6473:
        -: 6474:/* ========================================================================
        -: 6475: * Recurse through the given directory. This code is taken from ncompress.
        -: 6476: */
function treat_dir called 3 returned 100% blocks executed 79%
        3: 6477:local void treat_dir(dir)
        -: 6478:    char *dir;
        -: 6479:{
        -: 6480:    dir_type *dp;
        -: 6481:    DIR      *dirp;
        -: 6482:    char     nbuf[MAX_PATH_LEN];
        -: 6483:    int      len;
        -: 6484:
        3: 6485:    dirp = opendir(dir);
call    0 returned 3
        -: 6486:    
        3: 6487:    if (dirp == NULL) {
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####: 6488:	fprintf(stderr, "%s: %s unreadable\n", progname, dir);
call    0 never executed
    #####: 6489:	exit_code = ERROR;
    #####: 6490:	return ;
        -: 6491:    }
        -: 6492:    /*
        -: 6493:     ** WARNING: the following algorithm could occasionally cause
        -: 6494:     ** compress to produce error warnings of the form "<filename>.gz
        -: 6495:     ** already has .gz suffix - ignored". This occurs when the
        -: 6496:     ** .gz output file is inserted into the directory below
        -: 6497:     ** readdir's current pointer.
        -: 6498:     ** These warnings are harmless but annoying, so they are suppressed
        -: 6499:     ** with option -r (except when -v is on). An alternative
        -: 6500:     ** to allowing this would be to store the entire directory
        -: 6501:     ** list in memory, then compress the entries in the stored
        -: 6502:     ** list. Given the depth-first recursive algorithm used here,
        -: 6503:     ** this could use up a tremendous amount of memory. I don't
        -: 6504:     ** think it's worth it. -- Dave Mack
        -: 6505:     ** (An other alternative might be two passes to avoid depth-first.)
        -: 6506:     */
        -: 6507:    
       12: 6508:    while ((dp = readdir(dirp)) != NULL) {
call    0 returned 12
branch  1 taken 9
branch  2 taken 3 (fallthrough)
        -: 6509:
        9: 6510:	if (strequ(dp->d_name,".") || strequ(dp->d_name,"..")) {
branch  0 taken 6 (fallthrough)
branch  1 taken 3
branch  2 taken 3 (fallthrough)
branch  3 taken 3
        6: 6511:	    continue;
        -: 6512:	}
        3: 6513:	len = strlen(dir);
        3: 6514:	if (len + NLENGTH(dp) + 1 < MAX_PATH_LEN - 1) {
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        3: 6515:	    strcpy(nbuf,dir);
        3: 6516:	    if (len != 0 /* dir = "" means current dir on Amiga */
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        -: 6517:#ifdef PATH_SEP2
        -: 6518:		&& dir[len-1] != PATH_SEP2
        -: 6519:#endif
        -: 6520:#ifdef PATH_SEP3
        -: 6521:		&& dir[len-1] != PATH_SEP3
        -: 6522:#endif
        -: 6523:	    ) {
        3: 6524:		nbuf[len++] = PATH_SEP;
        -: 6525:	    }
        3: 6526:	    strcpy(nbuf+len, dp->d_name);
        3: 6527:	    treat_file(nbuf);
call    0 returned 3
        -: 6528:	} else {
    #####: 6529:	    fprintf(stderr,"%s: %s/%s: pathname too long\n",
    #####: 6530:		    progname, dir, dp->d_name);
call    0 never executed
    #####: 6531:	    exit_code = ERROR;
        -: 6532:	}
        -: 6533:    }
        3: 6534:    closedir(dirp);
call    0 returned 3
        -: 6535:}
        -: 6536:#endif /* ? NO_DIR */
        -: 6537:
        -: 6538:/* ========================================================================
        -: 6539: * Free all dynamically allocated variables and exit with the given code.
        -: 6540: */
function do_exit called 214 returned 0% blocks executed 57%
      214: 6541:local void do_exit(exitcode)
        -: 6542:    int exitcode;
        -: 6543:{
        -: 6544:#ifndef FAULTY_F_KL_7
        -: 6545:    static int in_exit = 0;
        -: 6546:#else
        -: 6547:    static int in_exit = 1;
        -: 6548:#endif
        -: 6549:
     214*: 6550:    if (in_exit) exit(exitcode);
branch  0 taken 0 (fallthrough)
branch  1 taken 214
call    2 never executed
      214: 6551:    in_exit = 1;
     214*: 6552:    if (env != NULL)  free(env),  env  = NULL;
branch  0 taken 0 (fallthrough)
branch  1 taken 214
     214*: 6553:    if (args != NULL) free((char*)args), args = NULL;
branch  0 taken 0 (fallthrough)
branch  1 taken 214
        -: 6554:    FREE(inbuf);
        -: 6555:    FREE(outbuf);
        -: 6556:    FREE(d_buf);
        -: 6557:    FREE(window);
        -: 6558:#ifndef MAXSEG_64K
        -: 6559:    FREE(tab_prefix);
        -: 6560:#else
        -: 6561:    FREE(tab_prefix0);
        -: 6562:    FREE(tab_prefix1);
        -: 6563:#endif
      214: 6564:    exit(exitcode);
        -: 6565:}
        -: 6566:
        -: 6567:/* ========================================================================
        -: 6568: * Signal and error handler.
        -: 6569: */
function abort_gzip called 1 returned 0% blocks executed 60%
        1: 6570:RETSIGTYPE abort_gzip()
        -: 6571:{
        1: 6572:   if (remove_ofname) {
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 6573:       close(ofd);
call    0 never executed
    #####: 6574:       unlink (ofname);
call    0 never executed
        -: 6575:   }
        1: 6576:   do_exit(ERROR);
call    0 returned 0
    #####: 6577:}
        -: 6578:/* Getopt for GNU.
        -: 6579:   NOTE: getopt is now part of the C library, so if you don't know what
        -: 6580:   "Keep this file name-space clean" means, talk to roland@gnu.ai.mit.edu
        -: 6581:   before changing it!
        -: 6582:
        -: 6583:   Copyright (C) 1987, 88, 89, 90, 91, 92, 1993
        -: 6584:   	Free Software Foundation, Inc.
        -: 6585:
        -: 6586:   This program is free software; you can redistribute it and/or modify it
        -: 6587:   under the terms of the GNU General Public License as published by the
        -: 6588:   Free Software Foundation; either version 2, or (at your option) any
        -: 6589:   later version.
        -: 6590:
        -: 6591:   This program is distributed in the hope that it will be useful,
        -: 6592:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 6593:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 6594:   GNU General Public License for more details.
        -: 6595:
        -: 6596:   You should have received a copy of the GNU General Public License
        -: 6597:   along with this program; if not, write to the Free Software
        -: 6598:   Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
        -: 6599:
        -: 6600:#ifdef HAVE_CONFIG_H
        -: 6601:#endif
        -: 6602:
        -: 6603:#ifndef __STDC__
        -: 6604:#  ifndef const
        -: 6605:#    define const
        -: 6606:#  endif
        -: 6607:#endif
        -: 6608:
        -: 6609:/* This tells Alpha OSF/1 not to define a getopt prototype in <stdio.h>.  */
        -: 6610:#ifndef _NO_PROTO
        -: 6611:#define _NO_PROTO
        -: 6612:#endif
        -: 6613:
        -: 6614:/* Comment out all this code if we are using the GNU C Library, and are not
        -: 6615:   actually compiling the library itself.  This code is part of the GNU C
        -: 6616:   Library, but also included in many other GNU distributions.  Compiling
        -: 6617:   and linking in this code is a waste when using the GNU C library
        -: 6618:   (especially if it is a shared library).  Rather than having every GNU
        -: 6619:   program understand `configure --with-gnu-libc' and omit the object files,
        -: 6620:   it is simpler to just do this in the source for each such file.  */
        -: 6621:
        -: 6622:#if defined (_LIBC) || !defined (__GNU_LIBRARY__)
        -: 6623:
        -: 6624:
        -: 6625:/* This needs to come after some library #include
        -: 6626:   to get __GNU_LIBRARY__ defined.  */
        -: 6627:#ifdef	__GNU_LIBRARY__
        -: 6628:/* Don't include stdlib.h for non-GNU C libraries because some of them
        -: 6629:   contain conflicting prototypes for getopt.  */
        -: 6630:#endif	/* GNU C library.  */
        -: 6631:
        -: 6632:/* If GETOPT_COMPAT is defined, `+' as well as `--' can introduce a
        -: 6633:   long-named option.  Because this is not POSIX.2 compliant, it is
        -: 6634:   being phased out.  */
        -: 6635:/* #define GETOPT_COMPAT */
        -: 6636:
        -: 6637:/* This version of `getopt' appears to the caller like standard Unix `getopt'
        -: 6638:   but it behaves differently for the user, since it allows the user
        -: 6639:   to intersperse the options with the other arguments.
        -: 6640:
        -: 6641:   As `getopt' works, it permutes the elements of ARGV so that,
        -: 6642:   when it is done, all the options precede everything else.  Thus
        -: 6643:   all application programs are extended to handle flexible argument order.
        -: 6644:
        -: 6645:   Setting the environment variable POSIXLY_CORRECT disables permutation.
        -: 6646:   Then the behavior is completely standard.
        -: 6647:
        -: 6648:   GNU application programs can use a third alternative mode in which
        -: 6649:   they can distinguish the relative order of options and other arguments.  */
        -: 6650:
        -: 6651:/* For communication from `getopt' to the caller.
        -: 6652:   When `getopt' finds an option that takes an argument,
        -: 6653:   the argument value is returned here.
        -: 6654:   Also, when `ordering' is RETURN_IN_ORDER,
        -: 6655:   each non-option ARGV-element is returned here.  */
        -: 6656:
        -: 6657:char *optarg = 0;
        -: 6658:
        -: 6659:/* Index in ARGV of the next element to be scanned.
        -: 6660:   This is used for communication to and from the caller
        -: 6661:   and for communication between successive calls to `getopt'.
        -: 6662:
        -: 6663:   On entry to `getopt', zero means this is the first call; initialize.
        -: 6664:
        -: 6665:   When `getopt' returns EOF, this is the index of the first of the
        -: 6666:   non-option elements that the caller should itself scan.
        -: 6667:
        -: 6668:   Otherwise, `optind' communicates from one call to the next
        -: 6669:   how much of ARGV has been scanned so far.  */
        -: 6670:
        -: 6671:/* XXX 1003.2 says this must be 1 before any call.  */
        -: 6672:int optind = 0;
        -: 6673:
        -: 6674:/* The next char to be scanned in the option-element
        -: 6675:   in which the last option character we returned was found.
        -: 6676:   This allows us to pick up the scan where we left off.
        -: 6677:
        -: 6678:   If this is zero, or a null string, it means resume the scan
        -: 6679:   by advancing to the next ARGV-element.  */
        -: 6680:
        -: 6681:static char *nextchar;
        -: 6682:
        -: 6683:/* Callers store zero here to inhibit the error message
        -: 6684:   for unrecognized options.  */
        -: 6685:
        -: 6686:int opterr = 1;
        -: 6687:
        -: 6688:/* Set to an option character which was unrecognized.
        -: 6689:   This must be initialized on some systems to avoid linking in the
        -: 6690:   system's own getopt implementation.  */
        -: 6691:
        -: 6692:#define BAD_OPTION '\0'
        -: 6693:int optopt = BAD_OPTION;
        -: 6694:
        -: 6695:/* Describe how to deal with options that follow non-option ARGV-elements.
        -: 6696:
        -: 6697:   If the caller did not specify anything,
        -: 6698:   the default is REQUIRE_ORDER if the environment variable
        -: 6699:   POSIXLY_CORRECT is defined, PERMUTE otherwise.
        -: 6700:
        -: 6701:   REQUIRE_ORDER means don't recognize them as options;
        -: 6702:   stop option processing when the first non-option is seen.
        -: 6703:   This is what Unix does.
        -: 6704:   This mode of operation is selected by either setting the environment
        -: 6705:   variable POSIXLY_CORRECT, or using `+' as the first character
        -: 6706:   of the list of option characters.
        -: 6707:
        -: 6708:   PERMUTE is the default.  We permute the contents of ARGV as we scan,
        -: 6709:   so that eventually all the non-options are at the end.  This allows options
        -: 6710:   to be given in any order, even with programs that were not written to
        -: 6711:   expect this.
        -: 6712:
        -: 6713:   RETURN_IN_ORDER is an option available to programs that were written
        -: 6714:   to expect options and other ARGV-elements in any order and that care about
        -: 6715:   the ordering of the two.  We describe each non-option ARGV-element
        -: 6716:   as if it were the argument of an option with character code 1.
        -: 6717:   Using `-' as the first character of the list of option characters
        -: 6718:   selects this mode of operation.
        -: 6719:
        -: 6720:   The special argument `--' forces an end of option-scanning regardless
        -: 6721:   of the value of `ordering'.  In the case of RETURN_IN_ORDER, only
        -: 6722:   `--' can cause `getopt' to return EOF with `optind' != ARGC.  */
        -: 6723:
        -: 6724:static enum
        -: 6725:{
        -: 6726:  REQUIRE_ORDER, PERMUTE, RETURN_IN_ORDER
        -: 6727:} ordering;
        -: 6728:
        -: 6729:#ifdef	__GNU_LIBRARY__
        -: 6730:/* We want to avoid inclusion of string.h with non-GNU libraries
        -: 6731:   because there are many ways it can cause trouble.
        -: 6732:   On some systems, it contains special magic macros that don't work
        -: 6733:   in GCC.  */
        -: 6734:#define	my_index	strchr
        -: 6735:#define	my_strlen	strlen
        -: 6736:#else
        -: 6737:
        -: 6738:/* Avoid depending on library functions or files
        -: 6739:   whose names are inconsistent.  */
        -: 6740:
        -: 6741:#if __STDC__ || defined(PROTO)
        -: 6742:extern char *getenv(const char *name);
        -: 6743:extern int  strcmp (const char *s1, const char *s2);
        -: 6744:extern int  strncmp(const char *s1, const char *s2, size_t);
        -: 6745:
        -: 6746:static int my_strlen(const char *s);
        -: 6747:static char *my_index (const char *str, int chr);
        -: 6748:#else
        -: 6749:extern char *getenv ();
        -: 6750:#endif
        -: 6751:
        -: 6752:static int
        -: 6753:my_strlen (str)
        -: 6754:     const char *str;
        -: 6755:{
        -: 6756:  int n = 0;
        -: 6757:  while (*str++)
        -: 6758:    n++;
        -: 6759:  return n;
        -: 6760:}
        -: 6761:
        -: 6762:static char *
        -: 6763:my_index (str, chr)
        -: 6764:     const char *str;
        -: 6765:     int chr;
        -: 6766:{
        -: 6767:  while (*str)
        -: 6768:    {
        -: 6769:      if (*str == chr)
        -: 6770:	return (char *) str;
        -: 6771:      str++;
        -: 6772:    }
        -: 6773:  return 0;
        -: 6774:}
        -: 6775:
        -: 6776:#endif				/* GNU C library.  */
        -: 6777:
        -: 6778:/* Handle permutation of arguments.  */
        -: 6779:
        -: 6780:/* Describe the part of ARGV that contains non-options that have
        -: 6781:   been skipped.  `first_nonopt' is the index in ARGV of the first of them;
        -: 6782:   `last_nonopt' is the index after the last of them.  */
        -: 6783:
        -: 6784:static int first_nonopt;
        -: 6785:static int last_nonopt;
        -: 6786:
        -: 6787:/* Exchange two adjacent subsequences of ARGV.
        -: 6788:   One subsequence is elements [first_nonopt,last_nonopt)
        -: 6789:   which contains all the non-options that have been skipped so far.
        -: 6790:   The other is elements [last_nonopt,optind), which contains all
        -: 6791:   the options processed since those non-options were skipped.
        -: 6792:
        -: 6793:   `first_nonopt' and `last_nonopt' are relocated so that they describe
        -: 6794:   the new indices of the non-options in ARGV after they are moved.
        -: 6795:
        -: 6796:   To perform the swap, we first reverse the order of all elements. So
        -: 6797:   all options now come before all non options, but they are in the
        -: 6798:   wrong order. So we put back the options and non options in original
        -: 6799:   order by reversing them again. For example:
        -: 6800:       original input:      a b c -x -y
        -: 6801:       reverse all:         -y -x c b a
        -: 6802:       reverse options:     -x -y c b a
        -: 6803:       reverse non options: -x -y a b c
        -: 6804:*/
        -: 6805:
        -: 6806:#if __STDC__ || defined(PROTO)
        -: 6807:static void exchange (char **argv);
        -: 6808:#endif
        -: 6809:
        -: 6810:static void
        -: 6811:exchange (argv)
        -: 6812:     char **argv;
        -: 6813:{
        -: 6814:  char *temp, **first, **last;
        -: 6815:
        -: 6816:  /* Reverse all the elements [first_nonopt, optind) */
        -: 6817:
        -: 6818:  first = &argv[first_nonopt];
        -: 6819:  last  = &argv[optind-1];
        -: 6820:
        -: 6821:  while (first < last) {
        -: 6822:    temp = *first; *first = *last; *last = temp; first++; last--;
        -: 6823:  }
        -: 6824:  /* Put back the options in order */
        -: 6825:  first = &argv[first_nonopt];
        -: 6826:  first_nonopt += (optind - last_nonopt);
        -: 6827:  last  = &argv[first_nonopt - 1];
        -: 6828:  while (first < last) {
        -: 6829:    temp = *first; *first = *last; *last = temp; first++; last--;
        -: 6830:  }
        -: 6831:
        -: 6832:  /* Put back the non options in order */
        -: 6833:  first = &argv[first_nonopt];
        -: 6834:  last_nonopt = optind;
        -: 6835:  last  = &argv[last_nonopt-1];
        -: 6836:  while (first < last) {
        -: 6837:    temp = *first; *first = *last; *last = temp; first++; last--;
        -: 6838:  }
        -: 6839:}
        -: 6840:
        -: 6841:/* Scan elements of ARGV (whose length is ARGC) for option characters
        -: 6842:   given in OPTSTRING.
        -: 6843:
        -: 6844:   If an element of ARGV starts with '-', and is not exactly "-" or "--",
        -: 6845:   then it is an option element.  The characters of this element
        -: 6846:   (aside from the initial '-') are option characters.  If `getopt'
        -: 6847:   is called repeatedly, it returns successively each of the option characters
        -: 6848:   from each of the option elements.
        -: 6849:
        -: 6850:   If `getopt' finds another option character, it returns that character,
        -: 6851:   updating `optind' and `nextchar' so that the next call to `getopt' can
        -: 6852:   resume the scan with the following option character or ARGV-element.
        -: 6853:
        -: 6854:   If there are no more option characters, `getopt' returns `EOF'.
        -: 6855:   Then `optind' is the index in ARGV of the first ARGV-element
        -: 6856:   that is not an option.  (The ARGV-elements have been permuted
        -: 6857:   so that those that are not options now come last.)
        -: 6858:
        -: 6859:   OPTSTRING is a string containing the legitimate option characters.
        -: 6860:   If an option character is seen that is not listed in OPTSTRING,
        -: 6861:   return BAD_OPTION after printing an error message.  If you set `opterr' to
        -: 6862:   zero, the error message is suppressed but we still return BAD_OPTION.
        -: 6863:
        -: 6864:   If a char in OPTSTRING is followed by a colon, that means it wants an arg,
        -: 6865:   so the following text in the same ARGV-element, or the text of the following
        -: 6866:   ARGV-element, is returned in `optarg'.  Two colons mean an option that
        -: 6867:   wants an optional arg; if there is text in the current ARGV-element,
        -: 6868:   it is returned in `optarg', otherwise `optarg' is set to zero.
        -: 6869:
        -: 6870:   If OPTSTRING starts with `-' or `+', it requests different methods of
        -: 6871:   handling the non-option ARGV-elements.
        -: 6872:   See the comments about RETURN_IN_ORDER and REQUIRE_ORDER, above.
        -: 6873:
        -: 6874:   Long-named options begin with `--' instead of `-'.
        -: 6875:   Their names may be abbreviated as long as the abbreviation is unique
        -: 6876:   or is an exact match for some defined option.  If they have an
        -: 6877:   argument, it follows the option name in the same ARGV-element, separated
        -: 6878:   from the option name by a `=', or else the in next ARGV-element.
        -: 6879:   When `getopt' finds a long-named option, it returns 0 if that option's
        -: 6880:   `flag' field is nonzero, the value of the option's `val' field
        -: 6881:   if the `flag' field is zero.
        -: 6882:
        -: 6883:   The elements of ARGV aren't really const, because we permute them.
        -: 6884:   But we pretend they're const in the prototype to be compatible
        -: 6885:   with other systems.
        -: 6886:
        -: 6887:   LONGOPTS is a vector of `struct option' terminated by an
        -: 6888:   element containing a name which is zero.
        -: 6889:
        -: 6890:   LONGIND returns the index in LONGOPT of the long-named option found.
        -: 6891:   It is only valid when a long-named option has been found by the most
        -: 6892:   recent call.
        -: 6893:
        -: 6894:   If LONG_ONLY is nonzero, '-' as well as '--' can introduce
        -: 6895:   long-named options.  */
        -: 6896:
        -: 6897:int
        -: 6898:_getopt_internal (argc, argv, optstring, longopts, longind, long_only)
        -: 6899:     int argc;
        -: 6900:     char *const *argv;
        -: 6901:     const char *optstring;
        -: 6902:     const struct option *longopts;
        -: 6903:     int *longind;
        -: 6904:     int long_only;
        -: 6905:{
        -: 6906:  int option_index;
        -: 6907:
        -: 6908:  optarg = 0;
        -: 6909:
        -: 6910:  /* Initialize the internal data when the first call is made.
        -: 6911:     Start processing options with ARGV-element 1 (since ARGV-element 0
        -: 6912:     is the program name); the sequence of previously skipped
        -: 6913:     non-option ARGV-elements is empty.  */
        -: 6914:
        -: 6915:  if (optind == 0)
        -: 6916:    {
        -: 6917:      first_nonopt = last_nonopt = optind = 1;
        -: 6918:
        -: 6919:      nextchar = NULL;
        -: 6920:
        -: 6921:      /* Determine how to handle the ordering of options and nonoptions.  */
        -: 6922:
        -: 6923:      if (optstring[0] == '-')
        -: 6924:	{
        -: 6925:	  ordering = RETURN_IN_ORDER;
        -: 6926:	  ++optstring;
        -: 6927:	}
        -: 6928:      else if (optstring[0] == '+')
        -: 6929:	{
        -: 6930:	  ordering = REQUIRE_ORDER;
        -: 6931:	  ++optstring;
        -: 6932:	}
        -: 6933:      else if (getenv ("POSIXLY_CORRECT") != NULL)
        -: 6934:	ordering = REQUIRE_ORDER;
        -: 6935:      else
        -: 6936:	ordering = PERMUTE;
        -: 6937:    }
        -: 6938:
        -: 6939:  if (nextchar == NULL || *nextchar == '\0')
        -: 6940:    {
        -: 6941:      if (ordering == PERMUTE)
        -: 6942:	{
        -: 6943:	  /* If we have just processed some options following some non-options,
        -: 6944:	     exchange them so that the options come first.  */
        -: 6945:
        -: 6946:	  if (first_nonopt != last_nonopt && last_nonopt != optind)
        -: 6947:	    exchange ((char **) argv);
        -: 6948:	  else if (last_nonopt != optind)
        -: 6949:	    first_nonopt = optind;
        -: 6950:
        -: 6951:	  /* Now skip any additional non-options
        -: 6952:	     and extend the range of non-options previously skipped.  */
        -: 6953:
        -: 6954:	  while (optind < argc
        -: 6955:		 && (argv[optind][0] != '-' || argv[optind][1] == '\0')
        -: 6956:#ifdef GETOPT_COMPAT
        -: 6957:		 && (longopts == NULL
        -: 6958:		     || argv[optind][0] != '+' || argv[optind][1] == '\0')
        -: 6959:#endif				/* GETOPT_COMPAT */
        -: 6960:		 )
        -: 6961:	    optind++;
        -: 6962:	  last_nonopt = optind;
        -: 6963:	}
        -: 6964:
        -: 6965:      /* Special ARGV-element `--' means premature end of options.
        -: 6966:	 Skip it like a null option,
        -: 6967:	 then exchange with previous non-options as if it were an option,
        -: 6968:	 then skip everything else like a non-option.  */
        -: 6969:
        -: 6970:      if (optind != argc && !strcmp (argv[optind], "--"))
        -: 6971:	{
        -: 6972:	  optind++;
        -: 6973:
        -: 6974:	  if (first_nonopt != last_nonopt && last_nonopt != optind)
        -: 6975:	    exchange ((char **) argv);
        -: 6976:	  else if (first_nonopt == last_nonopt)
        -: 6977:	    first_nonopt = optind;
        -: 6978:	  last_nonopt = argc;
        -: 6979:
        -: 6980:	  optind = argc;
        -: 6981:	}
        -: 6982:
        -: 6983:      /* If we have done all the ARGV-elements, stop the scan
        -: 6984:	 and back over any non-options that we skipped and permuted.  */
        -: 6985:
        -: 6986:      if (optind == argc)
        -: 6987:	{
        -: 6988:	  /* Set the next-arg-index to point at the non-options
        -: 6989:	     that we previously skipped, so the caller will digest them.  */
        -: 6990:	  if (first_nonopt != last_nonopt)
        -: 6991:	    optind = first_nonopt;
        -: 6992:	  return EOF;
        -: 6993:	}
        -: 6994:
        -: 6995:      /* If we have come to a non-option and did not permute it,
        -: 6996:	 either stop the scan or describe it to the caller and pass it by.  */
        -: 6997:
        -: 6998:      if ((argv[optind][0] != '-' || argv[optind][1] == '\0')
        -: 6999:#ifdef GETOPT_COMPAT
        -: 7000:	  && (longopts == NULL
        -: 7001:	      || argv[optind][0] != '+' || argv[optind][1] == '\0')
        -: 7002:#endif				/* GETOPT_COMPAT */
        -: 7003:	  )
        -: 7004:	{
        -: 7005:	  if (ordering == REQUIRE_ORDER)
        -: 7006:	    return EOF;
        -: 7007:	  optarg = argv[optind++];
        -: 7008:	  return 1;
        -: 7009:	}
        -: 7010:
        -: 7011:      /* We have found another option-ARGV-element.
        -: 7012:	 Start decoding its characters.  */
        -: 7013:
        -: 7014:      nextchar = (argv[optind] + 1
        -: 7015:		  + (longopts != NULL && argv[optind][1] == '-'));
        -: 7016:    }
        -: 7017:
        -: 7018:  if (longopts != NULL
        -: 7019:      && ((argv[optind][0] == '-'
        -: 7020:	   && (argv[optind][1] == '-' || long_only))
        -: 7021:#ifdef GETOPT_COMPAT
        -: 7022:	  || argv[optind][0] == '+'
        -: 7023:#endif				/* GETOPT_COMPAT */
        -: 7024:	  ))
        -: 7025:    {
        -: 7026:      const struct option *p;
        -: 7027:      char *s = nextchar;
        -: 7028:      int exact = 0;
        -: 7029:      int ambig = 0;
        -: 7030:      const struct option *pfound = NULL;
        -: 7031:      int indfound = 0;
        -: 7032:
        -: 7033:      while (*s && *s != '=')
        -: 7034:	s++;
        -: 7035:
        -: 7036:      /* Test all options for either exact match or abbreviated matches.  */
        -: 7037:      for (p = longopts, option_index = 0; p->name;
        -: 7038:	   p++, option_index++)
        -: 7039:	if (!strncmp (p->name, nextchar, s - nextchar))
        -: 7040:	  {
        -: 7041:	    if (s - nextchar == my_strlen (p->name))
        -: 7042:	      {
        -: 7043:		/* Exact match found.  */
        -: 7044:		pfound = p;
        -: 7045:		indfound = option_index;
        -: 7046:		exact = 1;
        -: 7047:		break;
        -: 7048:	      }
        -: 7049:	    else if (pfound == NULL)
        -: 7050:	      {
        -: 7051:		/* First nonexact match found.  */
        -: 7052:		pfound = p;
        -: 7053:		indfound = option_index;
        -: 7054:	      }
        -: 7055:	    else
        -: 7056:	      /* Second nonexact match found.  */
        -: 7057:	      ambig = 1;
        -: 7058:	  }
        -: 7059:
        -: 7060:      if (ambig && !exact)
        -: 7061:	{
        -: 7062:	  if (opterr)
        -: 7063:	    fprintf (stderr, "%s: option `%s' is ambiguous\n",
        -: 7064:		     argv[0], argv[optind]);
        -: 7065:	  nextchar += my_strlen (nextchar);
        -: 7066:	  optind++;
        -: 7067:	  return BAD_OPTION;
        -: 7068:	}
        -: 7069:
        -: 7070:      if (pfound != NULL)
        -: 7071:	{
        -: 7072:	  option_index = indfound;
        -: 7073:	  optind++;
        -: 7074:	  if (*s)
        -: 7075:	    {
        -: 7076:	      /* Don't test has_arg with >, because some C compilers don't
        -: 7077:		 allow it to be used on enums.  */
        -: 7078:	      if (pfound->has_arg)
        -: 7079:		optarg = s + 1;
        -: 7080:	      else
        -: 7081:		{
        -: 7082:		  if (opterr)
        -: 7083:		    {
        -: 7084:		      if (argv[optind - 1][1] == '-')
        -: 7085:			/* --option */
        -: 7086:			fprintf (stderr,
        -: 7087:				 "%s: option `--%s' doesn't allow an argument\n",
        -: 7088:				 argv[0], pfound->name);
        -: 7089:		      else
        -: 7090:			/* +option or -option */
        -: 7091:			fprintf (stderr,
        -: 7092:			     "%s: option `%c%s' doesn't allow an argument\n",
        -: 7093:			     argv[0], argv[optind - 1][0], pfound->name);
        -: 7094:		    }
        -: 7095:		  nextchar += my_strlen (nextchar);
        -: 7096:		  return BAD_OPTION;
        -: 7097:		}
        -: 7098:	    }
        -: 7099:	  else if (pfound->has_arg == 1)
        -: 7100:	    {
        -: 7101:	      if (optind < argc)
        -: 7102:		optarg = argv[optind++];
        -: 7103:	      else
        -: 7104:		{
        -: 7105:		  if (opterr)
        -: 7106:		    fprintf (stderr, "%s: option `%s' requires an argument\n",
        -: 7107:			     argv[0], argv[optind - 1]);
        -: 7108:		  nextchar += my_strlen (nextchar);
        -: 7109:		  return optstring[0] == ':' ? ':' : BAD_OPTION;
        -: 7110:		}
        -: 7111:	    }
        -: 7112:	  nextchar += my_strlen (nextchar);
        -: 7113:	  if (longind != NULL)
        -: 7114:	    *longind = option_index;
        -: 7115:	  if (pfound->flag)
        -: 7116:	    {
        -: 7117:	      *(pfound->flag) = pfound->val;
        -: 7118:	      return 0;
        -: 7119:	    }
        -: 7120:	  return pfound->val;
        -: 7121:	}
        -: 7122:      /* Can't find it as a long option.  If this is not getopt_long_only,
        -: 7123:	 or the option starts with '--' or is not a valid short
        -: 7124:	 option, then it's an error.
        -: 7125:	 Otherwise interpret it as a short option.  */
        -: 7126:      if (!long_only || argv[optind][1] == '-'
        -: 7127:#ifdef GETOPT_COMPAT
        -: 7128:	  || argv[optind][0] == '+'
        -: 7129:#endif				/* GETOPT_COMPAT */
        -: 7130:	  || my_index (optstring, *nextchar) == NULL)
        -: 7131:	{
        -: 7132:	  if (opterr)
        -: 7133:	    {
        -: 7134:	      if (argv[optind][1] == '-')
        -: 7135:		/* --option */
        -: 7136:		fprintf (stderr, "%s: unrecognized option `--%s'\n",
        -: 7137:			 argv[0], nextchar);
        -: 7138:	      else
        -: 7139:		/* +option or -option */
        -: 7140:		fprintf (stderr, "%s: unrecognized option `%c%s'\n",
        -: 7141:			 argv[0], argv[optind][0], nextchar);
        -: 7142:	    }
        -: 7143:	  nextchar = (char *) "";
        -: 7144:	  optind++;
        -: 7145:#ifndef FAULTY_F_KP_1
        -: 7146:	  return BAD_OPTION;
        -: 7147:#endif
        -: 7148:	}
        -: 7149:    }
        -: 7150:
        -: 7151:  /* Look at and handle the next option-character.  */
        -: 7152:
        -: 7153:  {
        -: 7154:    char c = *nextchar++;
        -: 7155:    char *temp = my_index (optstring, c);
        -: 7156:
        -: 7157:    /* Increment `optind' when we start to process its last character.  */
        -: 7158:    if (*nextchar == '\0')
        -: 7159:      ++optind;
        -: 7160:
        -: 7161:    if (temp == NULL || c == ':')
        -: 7162:      {
        -: 7163:	if (opterr)
        -: 7164:	  {
        -: 7165:#if 0
        -: 7166:	    if (c < 040 || c >= 0177)
        -: 7167:	      fprintf (stderr, "%s: unrecognized option, character code 0%o\n",
        -: 7168:		       argv[0], c);
        -: 7169:	    else
        -: 7170:	      fprintf (stderr, "%s: unrecognized option `-%c'\n", argv[0], c);
        -: 7171:#else
        -: 7172:	    /* 1003.2 specifies the format of this message.  */
        -: 7173:	    fprintf (stderr, "%s: illegal option -- %c\n", argv[0], c);
        -: 7174:#endif
        -: 7175:	  }
        -: 7176:	optopt = c;
        -: 7177:	return BAD_OPTION;
        -: 7178:      }
        -: 7179:    if (temp[1] == ':')
        -: 7180:      {
        -: 7181:	if (temp[2] == ':')
        -: 7182:	  {
        -: 7183:	    /* This is an option that accepts an argument optionally.  */
        -: 7184:	    if (*nextchar != '\0')
        -: 7185:	      {
        -: 7186:		optarg = nextchar;
        -: 7187:		optind++;
        -: 7188:	      }
        -: 7189:	    else
        -: 7190:	      optarg = 0;
        -: 7191:	    nextchar = NULL;
        -: 7192:	  }
        -: 7193:	else
        -: 7194:	  {
        -: 7195:	    /* This is an option that requires an argument.  */
        -: 7196:	    if (*nextchar != '\0')
        -: 7197:	      {
        -: 7198:		optarg = nextchar;
        -: 7199:		/* If we end this ARGV-element by taking the rest as an arg,
        -: 7200:		   we must advance to the next element now.  */
        -: 7201:		optind++;
        -: 7202:	      }
        -: 7203:	    else if (optind == argc)
        -: 7204:	      {
        -: 7205:		if (opterr)
        -: 7206:		  {
        -: 7207:#if 0
        -: 7208:		    fprintf (stderr, "%s: option `-%c' requires an argument\n",
        -: 7209:			     argv[0], c);
        -: 7210:#else
        -: 7211:		    /* 1003.2 specifies the format of this message.  */
        -: 7212:		    fprintf (stderr, "%s: option requires an argument -- %c\n",
        -: 7213:			     argv[0], c);
        -: 7214:#endif
        -: 7215:		  }
        -: 7216:		optopt = c;
        -: 7217:		if (optstring[0] == ':')
        -: 7218:		  c = ':';
        -: 7219:		else
        -: 7220:		  c = BAD_OPTION;
        -: 7221:	      }
        -: 7222:	    else
        -: 7223:	      /* We already incremented `optind' once;
        -: 7224:		 increment it again when taking next ARGV-elt as argument.  */
        -: 7225:	      optarg = argv[optind++];
        -: 7226:	    nextchar = NULL;
        -: 7227:	  }
        -: 7228:      }
        -: 7229:    return c;
        -: 7230:  }
        -: 7231:}
        -: 7232:
        -: 7233:int
        -: 7234:getopt (argc, argv, optstring)
        -: 7235:     int argc;
        -: 7236:     char *const *argv;
        -: 7237:     const char *optstring;
        -: 7238:{
        -: 7239:  return _getopt_internal (argc, argv, optstring,
        -: 7240:			   (const struct option *) 0,
        -: 7241:			   (int *) 0,
        -: 7242:			   0);
        -: 7243:}
        -: 7244:
        -: 7245:int
        -: 7246:getopt_long (argc, argv, options, long_options, opt_index)
        -: 7247:     int argc;
        -: 7248:     char *const *argv;
        -: 7249:     const char *options;
        -: 7250:     const struct option *long_options;
        -: 7251:     int *opt_index;
        -: 7252:{
        -: 7253:  return _getopt_internal (argc, argv, options, long_options, opt_index, 0);
        -: 7254:}
        -: 7255:
        -: 7256:#endif	/* _LIBC or not __GNU_LIBRARY__.  */
        -: 7257:
        -: 7258:#ifdef TEST
        -: 7259:
        -: 7260:/* Compile with -DTEST to make an executable for use in testing
        -: 7261:   the above definition of `getopt'.  */
        -: 7262:
        -: 7263:int
        -: 7264:main (argc, argv)
        -: 7265:     int argc;
        -: 7266:     char **argv;
        -: 7267:{
        -: 7268:  int c;
        -: 7269:  int digit_optind = 0;
        -: 7270:
        -: 7271:  while (1)
        -: 7272:    {
        -: 7273:      int this_option_optind = optind ? optind : 1;
        -: 7274:
        -: 7275:      c = getopt (argc, argv, "abc:d:0123456789");
        -: 7276:      if (c == EOF)
        -: 7277:	break;
        -: 7278:
        -: 7279:      switch (c)
        -: 7280:	{
        -: 7281:	case '0':
        -: 7282:	case '1':
        -: 7283:	case '2':
        -: 7284:	case '3':
        -: 7285:	case '4':
        -: 7286:	case '5':
        -: 7287:	case '6':
        -: 7288:	case '7':
        -: 7289:	case '8':
        -: 7290:	case '9':
        -: 7291:	  if (digit_optind != 0 && digit_optind != this_option_optind)
        -: 7292:	    printf ("digits occur in two different argv-elements.\n");
        -: 7293:	  digit_optind = this_option_optind;
        -: 7294:	  printf ("option %c\n", c);
        -: 7295:	  break;
        -: 7296:
        -: 7297:	case 'a':
        -: 7298:	  printf ("option a\n");
        -: 7299:	  break;
        -: 7300:
        -: 7301:	case 'b':
        -: 7302:	  printf ("option b\n");
        -: 7303:	  break;
        -: 7304:
        -: 7305:	case 'c':
        -: 7306:	  printf ("option c with value `%s'\n", optarg);
        -: 7307:	  break;
        -: 7308:
        -: 7309:	case BAD_OPTION:
        -: 7310:	  break;
        -: 7311:
        -: 7312:	default:
        -: 7313:	  printf ("?? getopt returned character code 0%o ??\n", c);
        -: 7314:	}
        -: 7315:    }
        -: 7316:
        -: 7317:  if (optind < argc)
        -: 7318:    {
        -: 7319:      printf ("non-option ARGV-elements: ");
        -: 7320:      while (optind < argc)
        -: 7321:	printf ("%s ", argv[optind++]);
        -: 7322:      printf ("\n");
        -: 7323:    }
        -: 7324:
        -: 7325:  exit (0);
        -: 7326:}
        -: 7327:
        -: 7328:#endif /* TEST */
