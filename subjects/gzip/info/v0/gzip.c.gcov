        -:    0:Source:gzip.c
        -:    0:Graph:gzip.gcno
        -:    0:Data:gzip.gcda
        -:    0:Runs:214
        -:    1:#include "crypt.h"
        -:    2:#include "getopt.h"
        -:    3:#include "gzip.h"
        -:    4:#include "lzw.h"
        -:    5:#include "tailor.h"
        -:    6:#include "revision.h"
        -:    7:
        -:    8:#include <stdio.h>
        -:    9:#include <ctype.h>
        -:   10:#include <sys/types.h>
        -:   11:#include <sys/stat.h>
        -:   12:#include <errno.h>
        -:   13:#include <signal.h>
        -:   14:
        -:   15:#define LINUX 1 
        -:   16:
        -:   17:/* bits.c -- output variable-length bit strings
        -:   18: * Copyright (C) 1992-1993 Jean-loup Gailly
        -:   19: * This is free software; you can redistribute it and/or modify it under the
        -:   20: * terms of the GNU General Public License, see the file COPYING.
        -:   21: */
        -:   22:
        -:   23:
        -:   24:/*
        -:   25: *  PURPOSE
        -:   26: *
        -:   27: *      Output variable-length bit strings. Compression can be done
        -:   28: *      to a file or to memory. (The latter is not supported in this version.)
        -:   29: *
        -:   30: *  DISCUSSION
        -:   31: *
        -:   32: *      The PKZIP "deflate" file format interprets compressed file data
        -:   33: *      as a sequence of bits.  Multi-bit strings in the file may cross
        -:   34: *      byte boundaries without restriction.
        -:   35: *
        -:   36: *      The first bit of each byte is the low-order bit.
        -:   37: *
        -:   38: *      The routines in this file allow a variable-length bit value to
        -:   39: *      be output right-to-left (useful for literal values). For
        -:   40: *      left-to-right output (useful for code strings from the tree routines),
        -:   41: *      the bits must have been reversed first with bi_reverse().
        -:   42: *
        -:   43: *      For in-memory compression, the compressed bit stream goes directly
        -:   44: *      into the requested output buffer. The input data is read in blocks
        -:   45: *      by the mem_read() function. The buffer is limited to 64K on 16 bit
        -:   46: *      machines.
        -:   47: *
        -:   48: *  INTERFACE
        -:   49: *
        -:   50: *      void bi_init (FILE *zipfile)
        -:   51: *          Initialize the bit string routines.
        -:   52: *
        -:   53: *      void send_bits (int value, int length)
        -:   54: *          Write out a bit string, taking the source bits right to
        -:   55: *          left.
        -:   56: *
        -:   57: *      int bi_reverse (int value, int length)
        -:   58: *          Reverse the bits of a bit string, taking the source bits left to
        -:   59: *          right and emitting them right to left.
        -:   60: *
        -:   61: *      void bi_windup (void)
        -:   62: *          Write out any remaining bits in an incomplete byte.
        -:   63: *
        -:   64: *      void copy_block(char *buf, unsigned len, int header)
        -:   65: *          Copy a stored block to the zip file, storing first the length and
        -:   66: *          its one's complement if requested.
        -:   67: *
        -:   68: */
        -:   69:
        -:   70:#ifdef DEBUG
        -:   71:#  include <stdio.h>
        -:   72:#endif
        -:   73:
        -:   74:/*
        -:   75:#ifndef lint
        -:   76:static char rcsid[] = "$Id: bits.c,v 0.8 1993/02/04 13:21:06 jloup Exp $";
        -:   77:#endif
        -:   78:*/
        -:   79:
        -:   80:/* ===========================================================================
        -:   81: * Local data used by the "bit string" routines.
        -:   82: */
        -:   83:
        -:   84:local file_t zfile; /* output gzip file */
        -:   85:
        -:   86:local unsigned short bi_buf;
        -:   87:/* Output buffer. bits are inserted starting at the bottom (least significant
        -:   88: * bits).
        -:   89: */
        -:   90:
        -:   91:#define Buf_size (8 * 2*sizeof(char))
        -:   92:/* Number of bits used within bi_buf. (bi_buf might be implemented on
        -:   93: * more than 16 bits on some systems.)
        -:   94: */
        -:   95:
        -:   96:local int bi_valid;
        -:   97:/* Number of valid bits in bi_buf.  All bits above the last valid bit
        -:   98: * are always zero.
        -:   99: */
        -:  100:
        -:  101:int (*read_buf) OF((char *buf, unsigned size)) = file_read;
        -:  102:/* Current input function. Set to mem_read for in-memory compression */
        -:  103:
        -:  104:#ifdef DEBUG
        -:  105:  ulg bits_sent;   /* bit length of the compressed data */
        -:  106:#endif
        -:  107:
        -:  108:/* ===========================================================================
        -:  109: * Initialize the bit string routines.
        -:  110: */
function bi_init called 177 returned 100% blocks executed 100%
      177:  111:void bi_init (zipfile)
        -:  112:    file_t zipfile; /* output zip file, NO_FILE for in-memory compression */
        -:  113:{
      177:  114:    zfile  = zipfile;
      177:  115:    bi_buf = 0;
      177:  116:    bi_valid = 0;
        -:  117:#ifdef DEBUG
        -:  118:    bits_sent = 0L;
        -:  119:#endif
        -:  120:
        -:  121:    /* Set the defaults for file compression. They are set by memcompress
        -:  122:     * for in-memory compression.
        -:  123:     */
      177:  124:    if (zfile != NO_FILE) {
branch  0 taken 177 (fallthrough)
branch  1 taken 0
      177:  125:        read_buf  = file_read;
        -:  126:    }
      177:  127:}
        -:  128:
        -:  129:/* ===========================================================================
        -:  130: * Send a value on a given number of bits.
        -:  131: * IN assertion: length <= 16 and value fits in length bits.
        -:  132: */
function send_bits called 3897254 returned 100% blocks executed 90%
  3897254:  133:void send_bits(value, length)
        -:  134:    int value;  /* value to send */
        -:  135:    int length; /* number of bits */
        -:  136:{
        -:  137:#ifdef DEBUG
        -:  138:    Tracev((stderr," l %2d v %4x ", length, value));
        -:  139:    Assert(length > 0 && length <= 15, "invalid length");
        -:  140:    bits_sent += (ulg)length;
        -:  141:#endif
        -:  142:    /* If not enough room in bi_buf, use (valid) bits from bi_buf and
        -:  143:     * (16 - bi_valid) bits from value, leaving (width - (16-bi_valid))
        -:  144:     * unused bits in value.
        -:  145:     */
  3897254:  146:    if (bi_valid > (int)Buf_size - length) {
branch  0 taken 1166659 (fallthrough)
branch  1 taken 2730595
  1166659:  147:        bi_buf |= (value << bi_valid);
 1166659*:  148:        put_short(bi_buf);
branch  0 taken 1166642 (fallthrough)
branch  1 taken 17
branch  2 taken 0 (fallthrough)
branch  3 taken 17
call    4 never executed
branch  5 taken 17 (fallthrough)
branch  6 taken 0
call    7 returned 17
  1166659:  149:        bi_buf = (ush)value >> (Buf_size - bi_valid);
  1166659:  150:        bi_valid += length - Buf_size;
        -:  151:    } else {
  2730595:  152:        bi_buf |= value << bi_valid;
  2730595:  153:        bi_valid += length;
        -:  154:    }
  3897254:  155:}
        -:  156:
        -:  157:/* ===========================================================================
        -:  158: * Reverse the first len bits of a code, using straightforward code (a faster
        -:  159: * method would use a table)
        -:  160: * IN assertion: 1 <= len <= 15
        -:  161: */
function bi_reverse called 85609 returned 100% blocks executed 100%
    85609:  162:unsigned bi_reverse(code, len)
        -:  163:    unsigned code; /* the value to invert */
        -:  164:    int len;       /* its bit length */
        -:  165:{
    85609:  166:    register unsigned res = 0;
        -:  167:    do {
   676231:  168:        res |= code & 1;
   676231:  169:        code >>= 1, res <<= 1;
   676231:  170:    } while (--len > 0);
branch  0 taken 590622
branch  1 taken 85609 (fallthrough)
    85609:  171:    return res >> 1;
        -:  172:}
        -:  173:
        -:  174:/* ===========================================================================
        -:  175: * Write out any remaining bits in an incomplete byte.
        -:  176: */
function bi_windup called 178 returned 100% blocks executed 55%
      178:  177:void bi_windup()
        -:  178:{
      178:  179:    if (bi_valid > 8) {
branch  0 taken 124 (fallthrough)
branch  1 taken 54
     124*:  180:        put_short(bi_buf);
branch  0 taken 124 (fallthrough)
branch  1 taken 0
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
       54:  181:    } else if (bi_valid > 0) {
branch  0 taken 53 (fallthrough)
branch  1 taken 1
      53*:  182:        put_byte(bi_buf);
branch  0 taken 0 (fallthrough)
branch  1 taken 53
call    2 never executed
        -:  183:    }
      178:  184:    bi_buf = 0;
      178:  185:    bi_valid = 0;
        -:  186:#ifdef DEBUG
        -:  187:    bits_sent = (bits_sent+7) & ~7;
        -:  188:#endif
      178:  189:}
        -:  190:
        -:  191:/* ===========================================================================
        -:  192: * Copy a stored block to the zip file, storing first the length and its
        -:  193: * one's complement if requested.
        -:  194: */
function copy_block called 1 returned 100% blocks executed 53%
        1:  195:void copy_block(buf, len, header)
        -:  196:    char     *buf;    /* the input data */
        -:  197:    unsigned len;     /* its length */
        -:  198:    int      header;  /* true if block header must be written */
        -:  199:{
        1:  200:    bi_windup();              /* align on byte boundary */
call    0 returned 1
        -:  201:
        1:  202:    if (header) {
branch  0 taken 1 (fallthrough)
branch  1 taken 0
       1*:  203:        put_short((ush)len);
branch  0 taken 1 (fallthrough)
branch  1 taken 0
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
       1*:  204:        put_short((ush)~len);
branch  0 taken 1 (fallthrough)
branch  1 taken 0
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
        -:  205:#ifdef DEBUG
        -:  206:        bits_sent += 2*16;
        -:  207:#endif
        -:  208:    }
        -:  209:#ifdef DEBUG
        -:  210:    bits_sent += (ulg)len<<3;
        -:  211:#endif
    12047:  212:    while (len--) {
branch  0 taken 12046
branch  1 taken 1 (fallthrough)
        -:  213:#ifdef CRYPT
        -:  214:        int t;
        -:  215:        if (key) zencode(*buf, t);
        -:  216:#endif
   12046*:  217:        put_byte(*buf++);
branch  0 taken 0 (fallthrough)
branch  1 taken 12046
call    2 never executed
        -:  218:    }
        1:  219:}
        -:  220:/* crypt.c (dummy version) -- do not perform encrytion
        -:  221: * Hardly worth copyrighting :-)
        -:  222: */
        -:  223:/*
        -:  224:#ifndef lint
        -:  225:static char rcsid[] = "$Id: crypt.c,v 0.5 1992/12/21 18:56:56 jloup Exp $";
        -:  226:#endif
        -:  227:*/
        -:  228:/* deflate.c -- compress data using the deflation algorithm
        -:  229: * Copyright (C) 1992-1993 Jean-loup Gailly
        -:  230: * This is free software; you can redistribute it and/or modify it under the
        -:  231: * terms of the GNU General Public License, see the file COPYING.
        -:  232: */
        -:  233:
        -:  234:/*
        -:  235: *  PURPOSE
        -:  236: *
        -:  237: *      Identify new text as repetitions of old text within a fixed-
        -:  238: *      length sliding window trailing behind the new text.
        -:  239: *
        -:  240: *  DISCUSSION
        -:  241: *
        -:  242: *      The "deflation" process depends on being able to identify portions
        -:  243: *      of the input text which are identical to earlier input (within a
        -:  244: *      sliding window trailing behind the input currently being processed).
        -:  245: *
        -:  246: *      The most straightforward technique turns out to be the fastest for
        -:  247: *      most input files: try all possible matches and select the longest.
        -:  248: *      The key feature of this algorithm is that insertions into the string
        -:  249: *      dictionary are very simple and thus fast, and deletions are avoided
        -:  250: *      completely. Insertions are performed at each input character, whereas
        -:  251: *      string matches are performed only when the previous match ends. So it
        -:  252: *      is preferable to spend more time in matches to allow very fast string
        -:  253: *      insertions and avoid deletions. The matching algorithm for small
        -:  254: *      strings is inspired from that of Rabin & Karp. A brute force approach
        -:  255: *      is used to find longer strings when a small match has been found.
        -:  256: *      A similar algorithm is used in comic (by Jan-Mark Wams) and freeze
        -:  257: *      (by Leonid Broukhis).
        -:  258: *         A previous version of this file used a more sophisticated algorithm
        -:  259: *      (by Fiala and Greene) which is guaranteed to run in linear amortized
        -:  260: *      time, but has a larger average cost, uses more memory and is patented.
        -:  261: *      However the F&G algorithm may be faster for some highly redundant
        -:  262: *      files if the parameter max_chain_length (described below) is too large.
        -:  263: *
        -:  264: *  ACKNOWLEDGEMENTS
        -:  265: *
        -:  266: *      The idea of lazy evaluation of matches is due to Jan-Mark Wams, and
        -:  267: *      I found it in 'freeze' written by Leonid Broukhis.
        -:  268: *      Thanks to many info-zippers for bug reports and testing.
        -:  269: *
        -:  270: *  REFERENCES
        -:  271: *
        -:  272: *      APPNOTE.TXT documentation file in PKZIP 1.93a distribution.
        -:  273: *
        -:  274: *      A description of the Rabin and Karp algorithm is given in the book
        -:  275: *         "Algorithms" by R. Sedgewick, Addison-Wesley, p252.
        -:  276: *
        -:  277: *      Fiala,E.R., and Greene,D.H.
        -:  278: *         Data Compression with Finite Windows, Comm.ACM, 32,4 (1989) 490-595
        -:  279: *
        -:  280: *  INTERFACE
        -:  281: *
        -:  282: *      void lm_init (int pack_level, ush *flags)
        -:  283: *          Initialize the "longest match" routines for a new file
        -:  284: *
        -:  285: *      ulg deflate (void)
        -:  286: *          Processes a new input file and return its compressed length. Sets
        -:  287: *          the compressed length, crc, deflate flags and internal file
        -:  288: *          attributes.
        -:  289: */
        -:  290:
        -:  291:/*
        -:  292:#ifndef lint
        -:  293:static char rcsid[] = "$Id: deflate.c,v 0.12 1993/03/04 19:15:33 jloup Exp $";
        -:  294:#endif
        -:  295:*/
        -:  296:
        -:  297:/* ===========================================================================
        -:  298: * Configuration parameters
        -:  299: */
        -:  300:
        -:  301:/* Compile with MEDIUM_MEM to reduce the memory requirements or
        -:  302: * with SMALL_MEM to use as little memory as possible. Use BIG_MEM if the
        -:  303: * entire input file can be held in memory (not possible on 16 bit systems).
        -:  304: * Warning: defining these symbols affects HASH_BITS (see below) and thus
        -:  305: * affects the compression ratio. The compressed output
        -:  306: * is still correct, and might even be smaller in some cases.
        -:  307: */
        -:  308:
        -:  309:#ifdef SMALL_MEM
        -:  310:#   define HASH_BITS  13  /* Number of bits used to hash strings */
        -:  311:#endif
        -:  312:#ifdef MEDIUM_MEM
        -:  313:#   define HASH_BITS  14
        -:  314:#endif
        -:  315:#ifndef HASH_BITS
        -:  316:#   define HASH_BITS  15
        -:  317:   /* For portability to 16 bit machines, do not use values above 15. */
        -:  318:#endif
        -:  319:
        -:  320:/* To save space (see unlzw.c), we overlay prev+head with tab_prefix and
        -:  321: * window with tab_suffix. Check that we can do this:
        -:  322: */
        -:  323:#if WSIZE<<1 > 1<<BITS
        -:  324:   error: cannot overlay window with tab_suffix and prev with tab_prefix0
        -:  325:#endif
        -:  326:#if HASH_BITS > BITS-1
        -:  327:   error: cannot overlay head with tab_prefix1
        -:  328:#endif
        -:  329:
        -:  330:#define HASH_SIZE (unsigned)(1<<HASH_BITS)
        -:  331:#define HASH_MASK (HASH_SIZE-1)
        -:  332:#define WMASK     (WSIZE-1)
        -:  333:/* HASH_SIZE and WSIZE must be powers of two */
        -:  334:
        -:  335:#define NIL 0
        -:  336:/* Tail of hash chains */
        -:  337:
        -:  338:#define FAST 4
        -:  339:#define SLOW 2
        -:  340:/* speed options for the general purpose bit flag */
        -:  341:
        -:  342:#ifndef TOO_FAR
        -:  343:#  define TOO_FAR 4096
        -:  344:#endif
        -:  345:/* Matches of length 3 are discarded if their distance exceeds TOO_FAR */
        -:  346:
        -:  347:/* ===========================================================================
        -:  348: * Local data used by the "longest match" routines.
        -:  349: */
        -:  350:
        -:  351:typedef ush Pos;
        -:  352:typedef unsigned IPos;
        -:  353:/* A Pos is an index in the character window. We use short instead of int to
        -:  354: * save space in the various tables. IPos is used only for parameter passing.
        -:  355: */
        -:  356:
        -:  357:/* DECLARE(uch, window, 2L*WSIZE); */
        -:  358:/* Sliding window. Input bytes are read into the second half of the window,
        -:  359: * and move to the first half later to keep a dictionary of at least WSIZE
        -:  360: * bytes. With this organization, matches are limited to a distance of
        -:  361: * WSIZE-MAX_MATCH bytes, but this ensures that IO is always
        -:  362: * performed with a length multiple of the block size. Also, it limits
        -:  363: * the window size to 64K, which is quite useful on MSDOS.
        -:  364: * To do: limit the window size to WSIZE+BSZ if SMALL_MEM (the code would
        -:  365: * be less efficient).
        -:  366: */
        -:  367:
        -:  368:/* DECLARE(Pos, prev, WSIZE); */
        -:  369:/* Link to older string with same hash index. To limit the size of this
        -:  370: * array to 64K, this link is maintained only for the last 32K strings.
        -:  371: * An index in this array is thus a window index modulo 32K.
        -:  372: */
        -:  373:
        -:  374:/* DECLARE(Pos, head, 1<<HASH_BITS); */
        -:  375:/* Heads of the hash chains or NIL. */
        -:  376:
        -:  377:ulg window_size = (ulg)2*WSIZE;
        -:  378:/* window size, 2*WSIZE except for MMAP or BIG_MEM, where it is the
        -:  379: * input file length plus MIN_LOOKAHEAD.
        -:  380: */
        -:  381:
        -:  382:long block_start;
        -:  383:/* window position at the beginning of the current output block. Gets
        -:  384: * negative when the window is moved backwards.
        -:  385: */
        -:  386:
        -:  387:local unsigned ins_h;  /* hash index of string to be inserted */
        -:  388:
        -:  389:#define H_SHIFT  ((HASH_BITS+MIN_MATCH-1)/MIN_MATCH)
        -:  390:/* Number of bits by which ins_h and del_h must be shifted at each
        -:  391: * input step. It must be such that after MIN_MATCH steps, the oldest
        -:  392: * byte no longer takes part in the hash key, that is:
        -:  393: *   H_SHIFT * MIN_MATCH >= HASH_BITS
        -:  394: */
        -:  395:
        -:  396:unsigned int near prev_length;
        -:  397:/* Length of the best match at previous step. Matches not greater than this
        -:  398: * are discarded. This is used in the lazy match evaluation.
        -:  399: */
        -:  400:
        -:  401:      unsigned near strstart;      /* start of string to insert */
        -:  402:      unsigned near match_start;   /* start of matching string */
        -:  403:local int           eofile;        /* flag set at end of input file */
        -:  404:local unsigned      lookahead;     /* number of valid bytes ahead in window */
        -:  405:
        -:  406:unsigned near max_chain_length;
        -:  407:/* To speed up deflation, hash chains are never searched beyond this length.
        -:  408: * A higher limit improves compression ratio but degrades the speed.
        -:  409: */
        -:  410:
        -:  411:local unsigned int max_lazy_match;
        -:  412:/* Attempt to find a better match only when the current match is strictly
        -:  413: * smaller than this value.
        -:  414: */
        -:  415:
        -:  416:int near good_match;
        -:  417:/* Use a faster search when the previous match is longer than this */
        -:  418:
        -:  419:
        -:  420:/* Values for max_lazy_match, good_match and max_chain_length, depending on
        -:  421: * the desired pack level (0..9). The values given below have been tuned to
        -:  422: * exclude worst case performance for pathological files. Better values may be
        -:  423: * found for specific files.
        -:  424: */
        -:  425:
        -:  426:typedef struct config {
        -:  427:   ush good_length; /* reduce lazy search above this match length */
        -:  428:   ush max_lazy;    /* do not perform lazy search above this match length */
        -:  429:   ush nice_length; /* quit search above this match length */
        -:  430:   ush max_chain;
        -:  431:} config;
        -:  432:
        -:  433:#ifdef  FULL_SEARCH
        -:  434:# define nice_match MAX_MATCH
        -:  435:#else
        -:  436:  int near nice_match; /* Stop searching when current match exceeds this */
        -:  437:#endif
        -:  438:
        -:  439:local config configuration_table[10] = {
        -:  440:/*      good lazy nice chain */
        -:  441:/* 0 */ {0,    0,  0,    0},  /* store only */
        -:  442:/* 1 */ {4,    4, 16,   16},  /* maximum speed */
        -:  443:/* 2 */ {6,    8, 16,   16},
        -:  444:/* 3 */ {8,   16, 32,   32},
        -:  445:/* 4 */ {8,   16, 64,   64},
        -:  446:/* 5 */ {8,   16, 128, 128},
        -:  447:/* 6 */ {8,   32, 128, 256},
        -:  448:/* 7 */ {8,   64, 128, 512},
        -:  449:/* 8 */ {32, 128, 258, 1024},
        -:  450:/* 9 */ {32, 258, 258, 4096}}; /* maximum compression */
        -:  451:
        -:  452:/* Note: the current code requires max_lazy >= MIN_MATCH and max_chain >= 4
        -:  453: * but these restrictions can easily be removed at a small cost.
        -:  454: */
        -:  455:
        -:  456:#define EQUAL 0
        -:  457:/* result of memcmp for equal strings */
        -:  458:
        -:  459:/* ===========================================================================
        -:  460: *  Prototypes for local functions.
        -:  461: */
        -:  462:local void fill_window   OF((void));
        -:  463:      int  longest_match OF((IPos cur_match));
        -:  464:#ifdef ASMV
        -:  465:      void match_init OF((void)); /* asm code initialization */
        -:  466:#endif
        -:  467:
        -:  468:#ifdef DEBUG
        -:  469:local  void check_match OF((IPos start, IPos match, int length));
        -:  470:#endif
        -:  471:
        -:  472:/* ===========================================================================
        -:  473: * Update a hash value with the given input byte
        -:  474: * IN  assertion: all calls to to UPDATE_HASH are made with consecutive
        -:  475: *    input characters, so that a running hash key can be computed from the
        -:  476: *    previous key instead of complete recalculation each time.
        -:  477: */
        -:  478:#define UPDATE_HASH(h,c) (h = (((h)<<H_SHIFT) ^ (c)) & HASH_MASK)
        -:  479:
        -:  480:/* ===========================================================================
        -:  481: * Insert string s in the dictionary and set match_head to the previous head
        -:  482: * of the hash chain (the most recent string with same hash key). Return
        -:  483: * the previous length of the hash chain.
        -:  484: * IN  assertion: all calls to to INSERT_STRING are made with consecutive
        -:  485: *    input characters and the first MIN_MATCH bytes of s are valid
        -:  486: *    (except for the last MIN_MATCH-1 bytes of the input file).
        -:  487: */
        -:  488:#define INSERT_STRING(s, match_head) \
        -:  489:   (UPDATE_HASH(ins_h, window[(s) + MIN_MATCH-1]), \
        -:  490:    prev[(s) & WMASK] = match_head = head[ins_h], \
        -:  491:    head[ins_h] = (s))
        -:  492:
        -:  493:/* ===========================================================================
        -:  494: * Initialize the "longest match" routines for a new file
        -:  495: */
function lm_init called 177 returned 100% blocks executed 84%
      177:  496:void lm_init (pack_level, flags)
        -:  497:    int pack_level; /* 0: store, 1: best speed, 9: best compression */
        -:  498:    ush *flags;     /* general purpose bit flag */
        -:  499:{
        -:  500:    register unsigned j;
        -:  501:
     177*:  502:    if (pack_level < 1 || pack_level > 9) error("bad pack level");
branch  0 taken 177 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 177
call    4 never executed
        -:  503:
        -:  504:    /* Initialize the hash table. */
        -:  505:#if defined(MAXSEG_64K) && HASH_BITS == 15
        -:  506:    for (j = 0;  j < HASH_SIZE; j++) head[j] = NIL;
        -:  507:#else
      177:  508:    memzero(head, HASH_SIZE*sizeof(*head));
        -:  509:#endif
        -:  510:    /* prev will be initialized on the fly */
        -:  511:
        -:  512:    /* Set the default configuration parameters:
        -:  513:     */
      177:  514:    max_lazy_match   = configuration_table[pack_level].max_lazy;
      177:  515:    good_match       = configuration_table[pack_level].good_length;
        -:  516:#ifndef FULL_SEARCH
      177:  517:    nice_match       = configuration_table[pack_level].nice_length;
        -:  518:#endif
      177:  519:    max_chain_length = configuration_table[pack_level].max_chain;
      177:  520:    if (pack_level == 1) {
branch  0 taken 17 (fallthrough)
branch  1 taken 160
       17:  521:       *flags |= FAST;
      160:  522:    } else if (pack_level == 9) {
branch  0 taken 17 (fallthrough)
branch  1 taken 143
       17:  523:       *flags |= SLOW;
        -:  524:    }
        -:  525:    /* ??? reduce max_chain_length for binary files */
        -:  526:
      177:  527:    strstart = 0;
      177:  528:    block_start = 0L;
        -:  529:#ifdef ASMV
        -:  530:    match_init(); /* initialize the asm code */
        -:  531:#endif
        -:  532:
        -:  533:#ifdef MAXSEG_64K
        -:  534:    /* Can't read a 64K block */
        -:  535:    lookahead = read_buf((char*)window, (unsigned)WSIZE);
        -:  536:#else
      177:  537:    lookahead = read_buf((char*)window, 2*WSIZE);
call    0 returned 177
        -:  538:#endif
      177:  539:    if (lookahead == 0 || lookahead == (unsigned)EOF) {
branch  0 taken 176 (fallthrough)
branch  1 taken 1
branch  2 taken 3 (fallthrough)
branch  3 taken 173
        4:  540:       eofile = 1, lookahead = 0;
        4:  541:       return;
        -:  542:    }
      173:  543:    eofile = 0;
        -:  544:    /* Make sure that we always have enough lookahead. This is important
        -:  545:     * if input comes from a device such as a tty.
        -:  546:     */
     173*:  547:    while (lookahead < MIN_LOOKAHEAD && !eofile) fill_window();
call    0 never executed
branch  1 taken 0 (fallthrough)
branch  2 taken 173
branch  3 never executed
branch  4 never executed
        -:  548:
      173:  549:    ins_h = 0;
      519:  550:    for (j=0; j<MIN_MATCH-1; j++) UPDATE_HASH(ins_h, window[j]);
branch  0 taken 346
branch  1 taken 173 (fallthrough)
        -:  551:    /* If lookahead < MIN_MATCH, ins_h is garbage, but this is
        -:  552:     * not important since only literal bytes will be emitted.
        -:  553:     */
        -:  554:}
        -:  555:
        -:  556:/* ===========================================================================
        -:  557: * Set match_start to the longest match starting at the given string and
        -:  558: * return its length. Matches shorter or equal to prev_length are discarded,
        -:  559: * in which case the result is equal to prev_length and match_start is
        -:  560: * garbage.
        -:  561: * IN assertions: cur_match is the head of the hash chain for the current
        -:  562: *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
        -:  563: */
        -:  564:#ifndef ASMV
        -:  565:/* For MSDOS, OS/2 and 386 Unix, an optimized version is in match.asm or
        -:  566: * match.s. The code is functionally equivalent, so you can use the C version
        -:  567: * if desired.
        -:  568: */
function longest_match called 2037967 returned 100% blocks executed 100%
  2037967:  569:int longest_match(cur_match)
        -:  570:    IPos cur_match;                             /* current match */
        -:  571:{
  2037967:  572:    unsigned chain_length = max_chain_length;   /* max hash chain length */
  2037967:  573:    register uch *scan = window + strstart;     /* current string */
        -:  574:    register uch *match;                        /* matched string */
        -:  575:    register int len;                           /* length of current match */
  2037967:  576:    int best_len = prev_length;                 /* best match length so far */
  2037967:  577:    IPos limit = strstart > (IPos)MAX_DIST ? strstart - (IPos)MAX_DIST : NIL;
        -:  578:    /* Stop when cur_match becomes <= limit. To simplify the code,
        -:  579:     * we prevent matches with the string of window index 0.
        -:  580:     */
        -:  581:
        -:  582:/* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
        -:  583: * It is easy to get rid of this optimization if necessary.
        -:  584: */
        -:  585:#if HASH_BITS < 8 || MAX_MATCH != 258
        -:  586:   error: Code too clever
        -:  587:#endif
        -:  588:
        -:  589:#ifdef UNALIGNED_OK
        -:  590:    /* Compare two bytes at a time. Note: this is not always beneficial.
        -:  591:     * Try with and without -DUNALIGNED_OK to check.
        -:  592:     */
        -:  593:    register uch *strend = window + strstart + MAX_MATCH - 1;
        -:  594:    register ush scan_start = *(ush*)scan;
        -:  595:    register ush scan_end   = *(ush*)(scan+best_len-1);
        -:  596:#else
  2037967:  597:    register uch *strend = window + strstart + MAX_MATCH;
  2037967:  598:    register uch scan_end1  = scan[best_len-1];
  2037967:  599:    register uch scan_end   = scan[best_len];
        -:  600:#endif
        -:  601:
        -:  602:    /* Do not waste too much time if we already have a good match: */
  2037967:  603:    if (prev_length >= good_match) {
branch  0 taken 176138 (fallthrough)
branch  1 taken 1861829
   176138:  604:        chain_length >>= 2;
        -:  605:    }
        -:  606:    Assert(strstart <= window_size-MIN_LOOKAHEAD, "insufficient lookahead");
        -:  607:
        -:  608:    do {
        -:  609:        Assert(cur_match < strstart, "no future");
 47018150:  610:        match = window + cur_match;
        -:  611:
        -:  612:        /* Skip to next match if the match length cannot increase
        -:  613:         * or if the match length is less than 2:
        -:  614:         */
        -:  615:#if (defined(UNALIGNED_OK) && MAX_MATCH == 258)
        -:  616:        /* This code assumes sizeof(unsigned short) == 2. Do not use
        -:  617:         * UNALIGNED_OK if your compiler uses a different size.
        -:  618:         */
        -:  619:        if (*(ush*)(match+best_len-1) != scan_end ||
        -:  620:            *(ush*)match != scan_start) continue;
        -:  621:
        -:  622:        /* It is not necessary to compare scan[2] and match[2] since they are
        -:  623:         * always equal when the other bytes match, given that the hash keys
        -:  624:         * are equal and that HASH_BITS >= 8. Compare 2 bytes at a time at
        -:  625:         * strstart+3, +5, ... up to strstart+257. We check for insufficient
        -:  626:         * lookahead only every 4th comparison; the 128th check will be made
        -:  627:         * at strstart+257. If MAX_MATCH-2 is not a multiple of 8, it is
        -:  628:         * necessary to put more guard bytes at the end of the window, or
        -:  629:         * to check more often for insufficient lookahead.
        -:  630:         */
        -:  631:        scan++, match++;
        -:  632:        do {
        -:  633:        } while (*(ush*)(scan+=2) == *(ush*)(match+=2) &&
        -:  634:                 *(ush*)(scan+=2) == *(ush*)(match+=2) &&
        -:  635:                 *(ush*)(scan+=2) == *(ush*)(match+=2) &&
        -:  636:                 *(ush*)(scan+=2) == *(ush*)(match+=2) &&
        -:  637:                 scan < strend);
        -:  638:        /* The funny "do {}" generates better code on most compilers */
        -:  639:
        -:  640:        /* Here, scan <= window+strstart+257 */
        -:  641:        Assert(scan <= window+(unsigned)(window_size-1), "wild scan");
        -:  642:        if (*scan == *match) scan++;
        -:  643:
        -:  644:        len = (MAX_MATCH - 1) - (int)(strend-scan);
        -:  645:        scan = strend - (MAX_MATCH-1);
        -:  646:
        -:  647:#else /* UNALIGNED_OK */
        -:  648:
 47018150:  649:        if (match[best_len]   != scan_end  ||
branch  0 taken 6082373 (fallthrough)
branch  1 taken 40935777
  6082373:  650:            match[best_len-1] != scan_end1 ||
branch  0 taken 3081812 (fallthrough)
branch  1 taken 3000561
  3081812:  651:            *match            != *scan     ||
branch  0 taken 2034708 (fallthrough)
branch  1 taken 1047104
 47018150:  652:            *++match          != scan[1])      continue;
branch  0 taken 6279 (fallthrough)
branch  1 taken 2028429
        -:  653:
        -:  654:        /* The check at best_len-1 can be removed because it will be made
        -:  655:         * again later. (This heuristic is not always a win.)
        -:  656:         * It is not necessary to compare scan[2] and match[2] since they
        -:  657:         * are always equal when the other bytes match, given that
        -:  658:         * the hash keys are equal and that HASH_BITS >= 8.
        -:  659:         */
  2028429:  660:        scan += 2, match++;
        -:  661:
        -:  662:        /* We check for insufficient lookahead only every 8th comparison;
        -:  663:         * the 256th check will be made at strstart+258.
        -:  664:         */
        -:  665:        do {
 14341569:  666:        } while (*++scan == *++match && *++scan == *++match &&
branch  0 taken 14011686 (fallthrough)
branch  1 taken 329883
 14011686:  667:                 *++scan == *++match && *++scan == *++match &&
branch  0 taken 13789366 (fallthrough)
branch  1 taken 222320
branch  2 taken 13606744 (fallthrough)
branch  3 taken 182622
 13606744:  668:                 *++scan == *++match && *++scan == *++match &&
branch  0 taken 13478410 (fallthrough)
branch  1 taken 128334
branch  2 taken 13380045 (fallthrough)
branch  3 taken 98365
 15408474:  669:                 *++scan == *++match && *++scan == *++match &&
branch  0 taken 14341569 (fallthrough)
branch  1 taken 541785
branch  2 taken 13313655 (fallthrough)
branch  3 taken 66390
branch  4 taken 13262193 (fallthrough)
branch  5 taken 51462
branch  6 taken 12854925
branch  7 taken 407268 (fallthrough)
        -:  670:                 scan < strend);
        -:  671:
  2028429:  672:        len = MAX_MATCH - (int)(strend - scan);
  2028429:  673:        scan = strend - MAX_MATCH;
        -:  674:
        -:  675:#endif /* UNALIGNED_OK */
        -:  676:
  2028429:  677:        if (len > best_len) {
branch  0 taken 1814543 (fallthrough)
branch  1 taken 213886
  1814543:  678:            match_start = cur_match;
  1814543:  679:            best_len = len;
  1814543:  680:            if (len >= nice_match) break;
branch  0 taken 414382 (fallthrough)
branch  1 taken 1400161
        -:  681:#ifdef UNALIGNED_OK
        -:  682:            scan_end = *(ush*)(scan+best_len-1);
        -:  683:#else
  1400161:  684:            scan_end1  = scan[best_len-1];
  1400161:  685:            scan_end   = scan[best_len];
        -:  686:#endif
        -:  687:        }
 46603768:  688:    } while ((cur_match = prev[cur_match & WMASK]) > limit
 46603768:  689:             && --chain_length != 0);
branch  0 taken 45238724 (fallthrough)
branch  1 taken 1365044
branch  2 taken 44980183
branch  3 taken 258541 (fallthrough)
        -:  690:
  2037967:  691:    return best_len;
        -:  692:}
        -:  693:#endif /* ASMV */
        -:  694:
        -:  695:#ifdef DEBUG
        -:  696:/* ===========================================================================
        -:  697: * Check that the match at match_start is indeed a match.
        -:  698: */
        -:  699:local void check_match(start, match, length)
        -:  700:    IPos start, match;
        -:  701:    int length;
        -:  702:{
        -:  703:    /* check that the match is indeed a match */
        -:  704:    if (memcmp((char*)window + match,
        -:  705:                (char*)window + start, length) != EQUAL) {
        -:  706:        fprintf(stderr,
        -:  707:            " start %d, match %d, length %d\n",
        -:  708:            start, match, length);
        -:  709:        error("invalid match");
        -:  710:    }
        -:  711:    if (verbose > 1) {
        -:  712:        fprintf(stderr,"\\[%d,%d]", start-match, length);
        -:  713:        do { putc(window[start++], stderr); } while (--length != 0);
        -:  714:    }
        -:  715:}
        -:  716:#else
        -:  717:#  define check_match(start, match, length)
        -:  718:#endif
        -:  719:
        -:  720:/* ===========================================================================
        -:  721: * Fill the window when the lookahead becomes insufficient.
        -:  722: * Updates strstart and lookahead, and sets eofile if end of input file.
        -:  723: * IN assertion: lookahead < MIN_LOOKAHEAD && strstart + lookahead > 0
        -:  724: * OUT assertions: at least one byte has been read, or eofile is set;
        -:  725: *    file reads are performed for at least two bytes (required for the
        -:  726: *    translate_eol option).
        -:  727: */
function fill_window called 3395 returned 100% blocks executed 96%
     3395:  728:local void fill_window()
        -:  729:{
        -:  730:    register unsigned n, m;
     3395:  731:    unsigned more = (unsigned)(window_size - (ulg)lookahead - (ulg)strstart);
        -:  732:    /* Amount of free space at the end of the window. */
        -:  733:
        -:  734:    /* If the window is almost full and there is insufficient lookahead,
        -:  735:     * move the upper half to the lower one to make room in the upper half.
        -:  736:     */
     3395:  737:    if (more == (unsigned)EOF) {
branch  0 taken 0 (fallthrough)
branch  1 taken 3395
        -:  738:        /* Very unlikely, but possible on 16 bit machine if strstart == 0
        -:  739:         * and lookahead == 1 (input done one byte at time)
        -:  740:         */
    #####:  741:        more--;
     3395:  742:    } else if (strstart >= WSIZE+MAX_DIST) {
branch  0 taken 3223 (fallthrough)
branch  1 taken 172
        -:  743:        /* By the IN assertion, the window is not empty so we can't confuse
        -:  744:         * more == 0 with more == 64K on a 16 bit machine.
        -:  745:         */
        -:  746:        Assert(window_size == (ulg)2*WSIZE, "no sliding with BIG_MEM");
        -:  747:
     3223:  748:        memcpy((char*)window, (char*)window+WSIZE, (unsigned)WSIZE);
     3223:  749:        match_start -= WSIZE;
     3223:  750:        strstart    -= WSIZE; /* we now have strstart >= MAX_DIST: */
        -:  751:
     3223:  752:        block_start -= (long) WSIZE;
        -:  753:
105614487:  754:        for (n = 0; n < HASH_SIZE; n++) {
branch  0 taken 105611264
branch  1 taken 3223 (fallthrough)
105611264:  755:            m = head[n];
105611264:  756:            head[n] = (Pos)(m >= WSIZE ? m-WSIZE : NIL);
branch  0 taken 67185 (fallthrough)
branch  1 taken 105544079
        -:  757:        }
105614487:  758:        for (n = 0; n < WSIZE; n++) {
branch  0 taken 105611264
branch  1 taken 3223 (fallthrough)
105611264:  759:            m = prev[n];
105611264:  760:            prev[n] = (Pos)(m >= WSIZE ? m-WSIZE : NIL);
branch  0 taken 105113304 (fallthrough)
branch  1 taken 497960
        -:  761:            /* If n is not on any hash chain, prev[n] is garbage but
        -:  762:             * its value will never be used.
        -:  763:             */
        -:  764:        }
     3223:  765:        more += WSIZE;
        -:  766:    }
        -:  767:    /* At this point, more >= 2 */
     3395:  768:    if (!eofile) {
branch  0 taken 3395 (fallthrough)
branch  1 taken 0
     3395:  769:        n = read_buf((char*)window+strstart+lookahead, more);
call    0 returned 3395
     3395:  770:        if (n == 0 || n == (unsigned)EOF) {
branch  0 taken 3222 (fallthrough)
branch  1 taken 173
branch  2 taken 0 (fallthrough)
branch  3 taken 3222
      173:  771:            eofile = 1;
        -:  772:        } else {
     3222:  773:            lookahead += n;
        -:  774:        }
        -:  775:    }
     3395:  776:}
        -:  777:
        -:  778:/* ===========================================================================
        -:  779: * Flush the current block, with given end-of-file flag.
        -:  780: * IN assertion: strstart is set to the end of the current match.
        -:  781: */
        -:  782:#define FLUSH_BLOCK(eof) \
        -:  783:   flush_block(block_start >= 0L ? (char*)&window[(unsigned)block_start] : \
        -:  784:                (char*)NULL, (long)strstart - block_start, (eof))
        -:  785:
        -:  786:/* ===========================================================================
        -:  787: * Processes a new input file and return its compressed length.
        -:  788: */
        -:  789:#ifdef NO_LAZY
        -:  790:ulg deflate()
        -:  791:{
        -:  792:    IPos hash_head; /* head of the hash chain */
        -:  793:    int flush;      /* set if current block must be flushed */
        -:  794:    unsigned match_length = 0;  /* length of best match */
        -:  795:
        -:  796:    prev_length = MIN_MATCH-1;
        -:  797:    while (lookahead != 0) {
        -:  798:        /* Insert the string window[strstart .. strstart+2] in the
        -:  799:         * dictionary, and set hash_head to the head of the hash chain:
        -:  800:         */
        -:  801:        INSERT_STRING(strstart, hash_head);
        -:  802:
        -:  803:        /* Find the longest match, discarding those <= prev_length.
        -:  804:         * At this point we have always match_length < MIN_MATCH
        -:  805:         */
        -:  806:        if (hash_head != NIL && strstart - hash_head <= MAX_DIST) {
        -:  807:            /* To simplify the code, we prevent matches with the string
        -:  808:             * of window index 0 (in particular we have to avoid a match
        -:  809:             * of the string with itself at the start of the input file).
        -:  810:             */
        -:  811:            match_length = longest_match (hash_head);
        -:  812:            /* longest_match() sets match_start */
        -:  813:            if (match_length > lookahead) match_length = lookahead;
        -:  814:        }
        -:  815:        if (match_length >= MIN_MATCH) {
        -:  816:            check_match(strstart, match_start, match_length);
        -:  817:
        -:  818:            flush = ct_tally(strstart-match_start, match_length - MIN_MATCH);
        -:  819:
        -:  820:            lookahead -= match_length;
        -:  821:            match_length--; /* string at strstart already in hash table */
        -:  822:            do {
        -:  823:                strstart++;
        -:  824:                INSERT_STRING(strstart, hash_head);
        -:  825:                /* strstart never exceeds WSIZE-MAX_MATCH, so there are
        -:  826:                 * always MIN_MATCH bytes ahead. If lookahead < MIN_MATCH
        -:  827:                 * these bytes are garbage, but it does not matter since the
        -:  828:                 * next lookahead bytes will always be emitted as literals.
        -:  829:                 */
        -:  830:            } while (--match_length != 0);
        -:  831:        } else {
        -:  832:            /* No match, output a literal byte */
        -:  833:            flush = ct_tally (0, window[strstart]);
        -:  834:            lookahead--;
        -:  835:        }
        -:  836:        strstart++;
        -:  837:        if (flush) FLUSH_BLOCK(0), block_start = strstart;
        -:  838:
        -:  839:        /* Make sure that we always have enough lookahead, except
        -:  840:         * at the end of the input file. We need MAX_MATCH bytes
        -:  841:         * for the next match, plus MIN_MATCH bytes to insert the
        -:  842:         * string following the next match.
        -:  843:         */
        -:  844:        while (lookahead < MIN_LOOKAHEAD && !eofile) fill_window();
        -:  845:
        -:  846:    }
        -:  847:    return FLUSH_BLOCK(1); /* eof */
        -:  848:}
        -:  849:#else /* LAZY */
        -:  850:/* ===========================================================================
        -:  851: * Same as above, but achieves better compression. We use a lazy
        -:  852: * evaluation for matches: a match is finally adopted only if there is
        -:  853: * no better match at the next window position.
        -:  854: */
function deflate called 177 returned 100% blocks executed 98%
      177:  855:ulg deflate()
        -:  856:{
        -:  857:    IPos hash_head;          /* head of hash chain */
        -:  858:    IPos prev_match;         /* previous match */
        -:  859:    int flush;               /* set if current block must be flushed */
      177:  860:    int match_available = 0; /* set if previous match exists */
      177:  861:    register unsigned match_length = MIN_MATCH-1; /* length of best match */
        -:  862:#ifdef DEBUG
        -:  863:    extern long isize;        /* byte length of input file, for debug only */
        -:  864:#endif
        -:  865:
        -:  866:    /* Process the input block. */
  2977132:  867:    while (lookahead != 0) {
branch  0 taken 2976955
branch  1 taken 177 (fallthrough)
        -:  868:        /* Insert the string window[strstart .. strstart+2] in the
        -:  869:         * dictionary, and set hash_head to the head of the hash chain:
        -:  870:         */
  2976955:  871:        INSERT_STRING(strstart, hash_head);
        -:  872:
        -:  873:        /* Find the longest match, discarding those <= prev_length.
        -:  874:         */
  2976955:  875:        prev_length = match_length, prev_match = match_start;
  2976955:  876:        match_length = MIN_MATCH-1;
        -:  877:
  2976955:  878:        if (hash_head != NIL && prev_length < max_lazy_match &&
branch  0 taken 2561256 (fallthrough)
branch  1 taken 415699
branch  2 taken 2040626 (fallthrough)
branch  3 taken 520630
  2040626:  879:            strstart - hash_head <= MAX_DIST) {
branch  0 taken 2037967 (fallthrough)
branch  1 taken 2659
        -:  880:            /* To simplify the code, we prevent matches with the string
        -:  881:             * of window index 0 (in particular we have to avoid a match
        -:  882:             * of the string with itself at the start of the input file).
        -:  883:             */
  2037967:  884:            match_length = longest_match (hash_head);
call    0 returned 2037967
        -:  885:            /* longest_match() sets match_start */
  2037967:  886:            if (match_length > lookahead) match_length = lookahead;
branch  0 taken 172 (fallthrough)
branch  1 taken 2037795
        -:  887:
        -:  888:            /* Ignore a length 3 match if it is too distant: */
  2037967:  889:            if (match_length == MIN_MATCH && strstart-match_start > TOO_FAR){
branch  0 taken 241496 (fallthrough)
branch  1 taken 1796471
branch  2 taken 50271 (fallthrough)
branch  3 taken 191225
        -:  890:                /* If prev_match is also MIN_MATCH, match_start is garbage
        -:  891:                 * but we will ignore the current match anyway.
        -:  892:                 */
    50271:  893:                match_length--;
        -:  894:            }
        -:  895:        }
        -:  896:        /* If there was a match at the previous step and the current
        -:  897:         * match is not better, output the previous match:
        -:  898:         */
  2976955:  899:        if (prev_length >= MIN_MATCH && match_length <= prev_length) {
branch  0 taken 1297430 (fallthrough)
branch  1 taken 1679525
branch  2 taken 1182279 (fallthrough)
branch  3 taken 115151
        -:  900:
        -:  901:            check_match(strstart-1, prev_match, prev_length);
        -:  902:
  1182279:  903:            flush = ct_tally(strstart-1-prev_match, prev_length - MIN_MATCH);
call    0 returned 1182279
        -:  904:
        -:  905:            /* Insert in hash table all strings up to the end of the match.
        -:  906:             * strstart-1 and strstart are already inserted.
        -:  907:             */
  1182279:  908:            lookahead -= prev_length-1;
  1182279:  909:            prev_length -= 2;
        -:  910:            do {
108518547:  911:                strstart++;
108518547:  912:                INSERT_STRING(strstart, hash_head);
        -:  913:                /* strstart never exceeds WSIZE-MAX_MATCH, so there are
        -:  914:                 * always MIN_MATCH bytes ahead. If lookahead < MIN_MATCH
        -:  915:                 * these bytes are garbage, but it does not matter since the
        -:  916:                 * next lookahead bytes will always be emitted as literals.
        -:  917:                 */
108518547:  918:            } while (--prev_length != 0);
branch  0 taken 107336268
branch  1 taken 1182279 (fallthrough)
  1182279:  919:            match_available = 0;
  1182279:  920:            match_length = MIN_MATCH-1;
  1182279:  921:            strstart++;
  1182279:  922:            if (flush) FLUSH_BLOCK(0), block_start = strstart;
branch  0 taken 16 (fallthrough)
branch  1 taken 1182263
branch  2 taken 1 (fallthrough)
branch  3 taken 15
call    4 returned 16
        -:  923:
  1794676:  924:        } else if (match_available) {
branch  0 taken 612228 (fallthrough)
branch  1 taken 1182448
        -:  925:            /* If there was no match at the previous position, output a
        -:  926:             * single literal. If there was a match but the current match
        -:  927:             * is longer, truncate the previous match to a single literal.
        -:  928:             */
        -:  929:            Tracevv((stderr,"%c",window[strstart-1]));
   612228:  930:            if (ct_tally (0, window[strstart-1])) {
call    0 returned 612228
branch  1 taken 4 (fallthrough)
branch  2 taken 612224
       4*:  931:                FLUSH_BLOCK(0), block_start = strstart;
branch  0 taken 4 (fallthrough)
branch  1 taken 0
call    2 returned 4
        -:  932:            }
   612228:  933:            strstart++;
   612228:  934:            lookahead--;
        -:  935:        } else {
        -:  936:            /* There is no previous match to compare with, wait for
        -:  937:             * the next step to decide.
        -:  938:             */
  1182448:  939:            match_available = 1;
  1182448:  940:            strstart++;
  1182448:  941:            lookahead--;
        -:  942:        }
        -:  943:        Assert (strstart <= isize && lookahead <= isize, "a bit too far");
        -:  944:
        -:  945:        /* Make sure that we always have enough lookahead, except
        -:  946:         * at the end of the input file. We need MAX_MATCH bytes
        -:  947:         * for the next match, plus MIN_MATCH bytes to insert the
        -:  948:         * string following the next match.
        -:  949:         */
  2980350:  950:        while (lookahead < MIN_LOOKAHEAD && !eofile) fill_window();
call    0 returned 3395
branch  1 taken 22756 (fallthrough)
branch  2 taken 2957594
branch  3 taken 3395
branch  4 taken 19361 (fallthrough)
        -:  951:    }
      177:  952:    if (match_available) ct_tally (0, window[strstart-1]);
branch  0 taken 169 (fallthrough)
branch  1 taken 8
call    2 returned 169
        -:  953:
      177:  954:    return FLUSH_BLOCK(1); /* eof */
branch  0 taken 174 (fallthrough)
branch  1 taken 3
call    2 returned 177
        -:  955:}
        -:  956:#endif /* LAZY */
        -:  957:/* inflate.c -- Not copyrighted 1992 by Mark Adler
        -:  958:   version c10p1, 10 January 1993 */
        -:  959:
        -:  960:/* You can do whatever you like with this source file, though I would
        -:  961:   prefer that if you modify it and redistribute it that you include
        -:  962:   comments to that effect with your name and the date.  Thank you.
        -:  963:   [The history has been moved to the file ChangeLog.]
        -:  964: */
        -:  965:
        -:  966:/*
        -:  967:   Inflate deflated (PKZIP's method 8 compressed) data.  The compression
        -:  968:   method searches for as much of the current string of bytes (up to a
        -:  969:   length of 258) in the previous 32K bytes.  If it doesn't find any
        -:  970:   matches (of at least length 3), it codes the next byte.  Otherwise, it
        -:  971:   codes the length of the matched string and its distance backwards from
        -:  972:   the current position.  There is a single Huffman code that codes both
        -:  973:   single bytes (called "literals") and match lengths.  A second Huffman
        -:  974:   code codes the distance information, which follows a length code.  Each
        -:  975:   length or distance code actually represents a base value and a number
        -:  976:   of "extra" (sometimes zero) bits to get to add to the base value.  At
        -:  977:   the end of each deflated block is a special end-of-block (EOB) literal/
        -:  978:   length code.  The decoding process is basically: get a literal/length
        -:  979:   code; if EOB then done; if a literal, emit the decoded byte; if a
        -:  980:   length then get the distance and emit the referred-to bytes from the
        -:  981:   sliding window of previously emitted data.
        -:  982:
        -:  983:   There are (currently) three kinds of inflate blocks: stored, fixed, and
        -:  984:   dynamic.  The compressor deals with some chunk of data at a time, and
        -:  985:   decides which method to use on a chunk-by-chunk basis.  A chunk might
        -:  986:   typically be 32K or 64K.  If the chunk is uncompressible, then the
        -:  987:   "stored" method is used.  In this case, the bytes are simply stored as
        -:  988:   is, eight bits per byte, with none of the above coding.  The bytes are
        -:  989:   preceded by a count, since there is no longer an EOB code.
        -:  990:
        -:  991:   If the data is compressible, then either the fixed or dynamic methods
        -:  992:   are used.  In the dynamic method, the compressed data is preceded by
        -:  993:   an encoding of the literal/length and distance Huffman codes that are
        -:  994:   to be used to decode this block.  The representation is itself Huffman
        -:  995:   coded, and so is preceded by a description of that code.  These code
        -:  996:   descriptions take up a little space, and so for small blocks, there is
        -:  997:   a predefined set of codes, called the fixed codes.  The fixed method is
        -:  998:   used if the block codes up smaller that way (usually for quite small
        -:  999:   chunks), otherwise the dynamic method is used.  In the latter case, the
        -: 1000:   codes are customized to the probabilities in the current block, and so
        -: 1001:   can code it much better than the pre-determined fixed codes.
        -: 1002:
        -: 1003:   The Huffman codes themselves are decoded using a mutli-level table
        -: 1004:   lookup, in order to maximize the speed of decoding plus the speed of
        -: 1005:   building the decoding tables.  See the comments below that precede the
        -: 1006:   lbits and dbits tuning parameters.
        -: 1007: */
        -: 1008:
        -: 1009:
        -: 1010:/*
        -: 1011:   Notes beyond the 1.93a appnote.txt:
        -: 1012:
        -: 1013:   1. Distance pointers never point before the beginning of the output
        -: 1014:      stream.
        -: 1015:   2. Distance pointers can point back across blocks, up to 32k away.
        -: 1016:   3. There is an implied maximum of 7 bits for the bit length table and
        -: 1017:      15 bits for the actual data.
        -: 1018:   4. If only one code exists, then it is encoded using one bit.  (Zero
        -: 1019:      would be more efficient, but perhaps a little confusing.)  If two
        -: 1020:      codes exist, they are coded using one bit each (0 and 1).
        -: 1021:   5. There is no way of sending zero distance codes--a dummy must be
        -: 1022:      sent if there are none.  (History: a pre 2.0 version of PKZIP would
        -: 1023:      store blocks with no distance codes, but this was discovered to be
        -: 1024:      too harsh a criterion.)  Valid only for 1.93a.  2.04c does allow
        -: 1025:      zero distance codes, which is sent as one code of zero bits in
        -: 1026:      length.
        -: 1027:   6. There are up to 286 literal/length codes.  Code 256 represents the
        -: 1028:      end-of-block.  Note however that the static length tree defines
        -: 1029:      288 codes just to fill out the Huffman codes.  Codes 286 and 287
        -: 1030:      cannot be used though, since there is no length base or extra bits
        -: 1031:      defined for them.  Similarly, there are up to 30 distance codes.
        -: 1032:      However, static trees define 32 codes (all 5 bits) to fill out the
        -: 1033:      Huffman codes, but the last two had better not show up in the data.
        -: 1034:   7. Unzip can check dynamic Huffman blocks for complete code sets.
        -: 1035:      The exception is that a single code would not be complete (see #4).
        -: 1036:   8. The five bits following the block type is really the number of
        -: 1037:      literal codes sent minus 257.
        -: 1038:   9. Length codes 8,16,16 are interpreted as 13 length codes of 8 bits
        -: 1039:      (1+6+6).  Therefore, to output three times the length, you output
        -: 1040:      three codes (1+1+1), whereas to output four times the same length,
        -: 1041:      you only need two codes (1+3).  Hmm.
        -: 1042:  10. In the tree reconstruction algorithm, Code = Code + Increment
        -: 1043:      only if BitLength(i) is not zero.  (Pretty obvious.)
        -: 1044:  11. Correction: 4 Bits: # of Bit Length codes - 4     (4 - 19)
        -: 1045:  12. Note: length code 284 can represent 227-258, but length code 285
        -: 1046:      really is 258.  The last length deserves its own, short code
        -: 1047:      since it gets used a lot in very redundant files.  The length
        -: 1048:      258 is special since 258 - 3 (the min match length) is 255.
        -: 1049:  13. The literal/length and distance code bit lengths are read as a
        -: 1050:      single stream of lengths.  It is possible (and advantageous) for
        -: 1051:      a repeat code (16, 17, or 18) to go across the boundary between
        -: 1052:      the two sets of lengths.
        -: 1053: */
        -: 1054:
        -: 1055:/*
        -: 1056:#ifndef lint
        -: 1057:static char rcsid[] = "$Id: inflate.c,v 0.12 1993/03/18 18:14:56 jloup Exp $";
        -: 1058:#endif
        -: 1059:*/
        -: 1060:
        -: 1061:#define slide window
        -: 1062:
        -: 1063:#if defined(STDC_HEADERS) || !defined(NO_STDLIB_H)
        -: 1064:#  include <sys/types.h>
        -: 1065:#  include <stdlib.h>
        -: 1066:#endif
        -: 1067:
        -: 1068:/* Huffman code lookup table entry--this entry is four bytes for machines
        -: 1069:   that have 16-bit pointers (e.g. PC's in the small or medium model).
        -: 1070:   Valid extra bits are 0..13.  e == 15 is EOB (end of block), e == 16
        -: 1071:   means that v is a literal, 16 < e < 32 means that v is a pointer to
        -: 1072:   the next table, which codes e - 16 bits, and lastly e == 99 indicates
        -: 1073:   an unused code.  If a code with e == 99 is looked up, this implies an
        -: 1074:   error in the data. */
        -: 1075:struct huft {
        -: 1076:  uch e;                /* number of extra bits or operation */
        -: 1077:  uch b;                /* number of bits in this code or subcode */
        -: 1078:  union {
        -: 1079:    ush n;              /* literal, length base, or distance base */
        -: 1080:    struct huft *t;     /* pointer to next level of table */
        -: 1081:  } v;
        -: 1082:};
        -: 1083:
        -: 1084:
        -: 1085:/* Function prototypes */
        -: 1086:int huft_build OF((unsigned *, unsigned, unsigned, ush *, ush *,
        -: 1087:                   struct huft **, int *));
        -: 1088:int huft_free OF((struct huft *));
        -: 1089:int inflate_codes OF((struct huft *, struct huft *, int, int));
        -: 1090:int inflate_stored OF((void));
        -: 1091:int inflate_fixed OF((void));
        -: 1092:int inflate_dynamic OF((void));
        -: 1093:int inflate_block OF((int *));
        -: 1094:int inflate OF((void));
        -: 1095:
        -: 1096:
        -: 1097:/* The inflate algorithm uses a sliding 32K byte window on the uncompressed
        -: 1098:   stream to find repeated byte strings.  This is implemented here as a
        -: 1099:   circular buffer.  The index is updated simply by incrementing and then
        -: 1100:   and'ing with 0x7fff (32K-1). */
        -: 1101:/* It is left to other modules to supply the 32K area.  It is assumed
        -: 1102:   to be usable as if it were declared "uch slide[32768];" or as just
        -: 1103:   "uch *slide;" and then malloc'ed in the latter case.  The definition
        -: 1104:   must be in unzip.h, included above. */
        -: 1105:/* unsigned wp;             current position in slide */
        -: 1106:#define wp outcnt
        -: 1107:#define flush_output(w) (wp=(w),flush_window())
        -: 1108:
        -: 1109:/* Tables for deflate from PKZIP's appnote.txt. */
        -: 1110:static unsigned border[] = {    /* Order of the bit length code lengths */
        -: 1111:        16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
        -: 1112:static ush cplens[] = {         /* Copy lengths for literal codes 257..285 */
        -: 1113:        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
        -: 1114:        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
        -: 1115:        /* note: see note #13 above about the 258 in this list. */
        -: 1116:static ush cplext[] = {         /* Extra bits for literal codes 257..285 */
        -: 1117:        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
        -: 1118:        3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99}; /* 99==invalid */
        -: 1119:static ush cpdist[] = {         /* Copy offsets for distance codes 0..29 */
        -: 1120:        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
        -: 1121:        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
        -: 1122:        8193, 12289, 16385, 24577};
        -: 1123:static ush cpdext[] = {         /* Extra bits for distance codes */
        -: 1124:        0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,
        -: 1125:        7, 7, 8, 8, 9, 9, 10, 10, 11, 11,
        -: 1126:        12, 12, 13, 13};
        -: 1127:
        -: 1128:
        -: 1129:
        -: 1130:/* Macros for inflate() bit peeking and grabbing.
        -: 1131:   The usage is:
        -: 1132:
        -: 1133:        NEEDBITS(j)
        -: 1134:        x = b & mask_bits[j];
        -: 1135:        DUMPBITS(j)
        -: 1136:
        -: 1137:   where NEEDBITS makes sure that b has at least j bits in it, and
        -: 1138:   DUMPBITS removes the bits from b.  The macros use the variable k
        -: 1139:   for the number of bits in b.  Normally, b and k are register
        -: 1140:   variables for speed, and are initialized at the beginning of a
        -: 1141:   routine that uses these macros from a global bit buffer and count.
        -: 1142:
        -: 1143:   If we assume that EOB will be the longest code, then we will never
        -: 1144:   ask for bits with NEEDBITS that are beyond the end of the stream.
        -: 1145:   So, NEEDBITS should not read any more bytes than are needed to
        -: 1146:   meet the request.  Then no bytes need to be "returned" to the buffer
        -: 1147:   at the end of the last block.
        -: 1148:
        -: 1149:   However, this assumption is not true for fixed blocks--the EOB code
        -: 1150:   is 7 bits, but the other literal/length codes can be 8 or 9 bits.
        -: 1151:   (The EOB code is shorter than other codes becuase fixed blocks are
        -: 1152:   generally short.  So, while a block always has an EOB, many other
        -: 1153:   literal/length codes have a significantly lower probability of
        -: 1154:   showing up at all.)  However, by making the first table have a
        -: 1155:   lookup of seven bits, the EOB code will be found in that first
        -: 1156:   lookup, and so will not require that too many bits be pulled from
        -: 1157:   the stream.
        -: 1158: */
        -: 1159:
        -: 1160:ulg bb;                         /* bit buffer */
        -: 1161:unsigned bk;                    /* bits in bit buffer */
        -: 1162:
        -: 1163:ush mask_bits[] = {
        -: 1164:    0x0000,
        -: 1165:    0x0001, 0x0003, 0x0007, 0x000f, 0x001f, 0x003f, 0x007f, 0x00ff,
        -: 1166:    0x01ff, 0x03ff, 0x07ff, 0x0fff, 0x1fff, 0x3fff, 0x7fff, 0xffff
        -: 1167:};
        -: 1168:
        -: 1169:#ifdef CRYPT
        -: 1170:  uch cc;
        -: 1171:#  define NEXTBYTE() \
        -: 1172:     (decrypt ? (cc = get_byte(), zdecode(cc), cc) : get_byte())
        -: 1173:#else
        -: 1174:#  define NEXTBYTE()  (uch)get_byte()
        -: 1175:#endif
        -: 1176:#define NEEDBITS(n) {while(k<(n)){b|=((ulg)NEXTBYTE())<<k;k+=8;}}
        -: 1177:#define DUMPBITS(n) {b>>=(n);k-=(n);}
        -: 1178:
        -: 1179:
        -: 1180:/*
        -: 1181:   Huffman code decoding is performed using a multi-level table lookup.
        -: 1182:   The fastest way to decode is to simply build a lookup table whose
        -: 1183:   size is determined by the longest code.  However, the time it takes
        -: 1184:   to build this table can also be a factor if the data being decoded
        -: 1185:   is not very long.  The most common codes are necessarily the
        -: 1186:   shortest codes, so those codes dominate the decoding time, and hence
        -: 1187:   the speed.  The idea is you can have a shorter table that decodes the
        -: 1188:   shorter, more probable codes, and then point to subsidiary tables for
        -: 1189:   the longer codes.  The time it costs to decode the longer codes is
        -: 1190:   then traded against the time it takes to make longer tables.
        -: 1191:
        -: 1192:   This results of this trade are in the variables lbits and dbits
        -: 1193:   below.  lbits is the number of bits the first level table for literal/
        -: 1194:   length codes can decode in one step, and dbits is the same thing for
        -: 1195:   the distance codes.  Subsequent tables are also less than or equal to
        -: 1196:   those sizes.  These values may be adjusted either when all of the
        -: 1197:   codes are shorter than that, in which case the longest code length in
        -: 1198:   bits is used, or when the shortest code is *longer* than the requested
        -: 1199:   table size, in which case the length of the shortest code in bits is
        -: 1200:   used.
        -: 1201:
        -: 1202:   There are two different values for the two tables, since they code a
        -: 1203:   different number of possibilities each.  The literal/length table
        -: 1204:   codes 286 possible values, or in a flat code, a little over eight
        -: 1205:   bits.  The distance table codes 30 possible values, or a little less
        -: 1206:   than five bits, flat.  The optimum values for speed end up being
        -: 1207:   about one bit more than those, so lbits is 8+1 and dbits is 5+1.
        -: 1208:   The optimum values may differ though from machine to machine, and
        -: 1209:   possibly even between compilers.  Your mileage may vary.
        -: 1210: */
        -: 1211:
        -: 1212:
        -: 1213:int lbits = 9;          /* bits in base literal/length lookup table */
        -: 1214:int dbits = 6;          /* bits in base distance lookup table */
        -: 1215:
        -: 1216:
        -: 1217:/* If BMAX needs to be larger than 16, then h and x[] should be ulg. */
        -: 1218:#define BMAX 16         /* maximum bit length of any code (16 for explode) */
        -: 1219:#define N_MAX 288       /* maximum number of codes in any set */
        -: 1220:
        -: 1221:
        -: 1222:unsigned hufts;         /* track memory usage */
        -: 1223:
        -: 1224:
function huft_build called 36 returned 100% blocks executed 87%
       36: 1225:int huft_build(b, n, s, d, e, t, m)
        -: 1226:unsigned *b;            /* code lengths in bits (all assumed <= BMAX) */
        -: 1227:unsigned n;             /* number of codes (assumed <= N_MAX) */
        -: 1228:unsigned s;             /* number of simple-valued codes (0..s-1) */
        -: 1229:ush *d;                 /* list of base values for non-simple codes */
        -: 1230:ush *e;                 /* list of extra bits for non-simple codes */
        -: 1231:struct huft **t;        /* result: starting table */
        -: 1232:int *m;                 /* maximum lookup bits, returns actual */
        -: 1233:/* Given a list of code lengths and a maximum table size, make a set of
        -: 1234:   tables to decode that set of codes.  Return zero on success, one if
        -: 1235:   the given code set is incomplete (the tables are still built in this
        -: 1236:   case), two if the input is invalid (all zero length codes or an
        -: 1237:   oversubscribed set of lengths), and three if not enough memory. */
        -: 1238:{
        -: 1239:  unsigned a;                   /* counter for codes of length k */
        -: 1240:  unsigned c[BMAX+1];           /* bit length count table */
        -: 1241:  unsigned f;                   /* i repeats in table every f entries */
        -: 1242:  int g;                        /* maximum code length */
        -: 1243:  int h;                        /* table level */
        -: 1244:  register unsigned i;          /* counter, current code */
        -: 1245:  register unsigned j;          /* counter */
        -: 1246:  register int k;               /* number of bits in current code */
        -: 1247:  int l;                        /* bits per table (returned in m) */
        -: 1248:  register unsigned *p;         /* pointer into c[], b[], or v[] */
        -: 1249:  register struct huft *q;      /* points to current table */
        -: 1250:  struct huft r;                /* table entry for structure assignment */
        -: 1251:  struct huft *u[BMAX];         /* table stack */
        -: 1252:  unsigned v[N_MAX];            /* values in order of bit length */
        -: 1253:  register int w;               /* bits before this table == (l * h) */
        -: 1254:  unsigned x[BMAX+1];           /* bit offsets, then code stack */
        -: 1255:  unsigned *xp;                 /* pointer into x */
        -: 1256:  int y;                        /* number of dummy codes added */
        -: 1257:  unsigned z;                   /* number of entries in current table */
        -: 1258:
        -: 1259:
        -: 1260:  /* Generate counts for each bit length */
       36: 1261:  memzero(c, sizeof(c));
       36: 1262:  p = b;  i = n;
        -: 1263:  do {
        -: 1264:    Tracecv(*p, (stderr, (n-i >= ' ' && n-i <= '~' ? "%c %d\n" : "0x%x %d\n"),
        -: 1265:            n-i, *p));
     4019: 1266:    c[*p++]++;                  /* assume all entries <= BMAX */
     4019: 1267:  } while (--i);
branch  0 taken 3983
branch  1 taken 36 (fallthrough)
       36: 1268:  if (c[0] == n)                /* null input--all zero length codes */
branch  0 taken 0 (fallthrough)
branch  1 taken 36
        -: 1269:  {
    #####: 1270:    *t = (struct huft *)NULL;
    #####: 1271:    *m = 0;
    #####: 1272:    return 0;
        -: 1273:  }
        -: 1274:
        -: 1275:
        -: 1276:  /* Find minimum and maximum length, bound *m by those */
       36: 1277:  l = *m;
      121: 1278:  for (j = 1; j <= BMAX; j++)
branch  0 taken 121
branch  1 taken 0 (fallthrough)
      121: 1279:    if (c[j])
branch  0 taken 36 (fallthrough)
branch  1 taken 85
       36: 1280:      break;
       36: 1281:  k = j;                        /* minimum code length */
       36: 1282:  if ((unsigned)l < j)
branch  0 taken 0 (fallthrough)
branch  1 taken 36
    #####: 1283:    l = j;
      252: 1284:  for (i = BMAX; i; i--)
branch  0 taken 252
branch  1 taken 0 (fallthrough)
      252: 1285:    if (c[i])
branch  0 taken 36 (fallthrough)
branch  1 taken 216
       36: 1286:      break;
       36: 1287:  g = i;                        /* maximum code length */
       36: 1288:  if ((unsigned)l > i)
branch  0 taken 11 (fallthrough)
branch  1 taken 25
       11: 1289:    l = i;
       36: 1290:  *m = l;
        -: 1291:
        -: 1292:
        -: 1293:  /* Adjust last length count to fill out codes, if needed */
      275: 1294:  for (y = 1 << j; j < i; j++, y <<= 1)
branch  0 taken 239
branch  1 taken 36 (fallthrough)
      239: 1295:    if ((y -= c[j]) < 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 239
    #####: 1296:      return 2;                 /* bad input: more codes than bits */
       36: 1297:  if ((y -= c[i]) < 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 36
    #####: 1298:    return 2;
       36: 1299:  c[i] += y;
        -: 1300:
        -: 1301:
        -: 1302:  /* Generate starting offsets into the value table for each length */
       36: 1303:  x[1] = j = 0;
       36: 1304:  p = c + 1;  xp = x + 2;
      360: 1305:  while (--i) {                 /* note that i == g from above */
branch  0 taken 324
branch  1 taken 36 (fallthrough)
      324: 1306:    *xp++ = (j += *p++);
        -: 1307:  }
        -: 1308:
        -: 1309:
        -: 1310:  /* Make a table of values in order of bit lengths */
       36: 1311:  p = b;  i = 0;
        -: 1312:  do {
     4019: 1313:    if ((j = *p++) != 0)
branch  0 taken 1888 (fallthrough)
branch  1 taken 2131
     1888: 1314:      v[x[j]++] = i;
     4019: 1315:  } while (++i < n);
branch  0 taken 3983
branch  1 taken 36 (fallthrough)
        -: 1316:
        -: 1317:
        -: 1318:  /* Generate the Huffman codes and for each, make the table entries */
       36: 1319:  x[0] = i = 0;                 /* first Huffman code is zero */
       36: 1320:  p = v;                        /* grab values in bit order */
       36: 1321:  h = -1;                       /* no tables yet--level -1 */
       36: 1322:  w = -l;                       /* bits decoded == (l * h) */
       36: 1323:  u[0] = (struct huft *)NULL;   /* just to keep compilers happy */
       36: 1324:  q = (struct huft *)NULL;      /* ditto */
       36: 1325:  z = 0;                        /* ditto */
        -: 1326:
        -: 1327:  /* go through the bit lengths (k already is bits in shortest code) */
      311: 1328:  for (; k <= g; k++)
branch  0 taken 275
branch  1 taken 36 (fallthrough)
        -: 1329:  {
      275: 1330:    a = c[k];
     2163: 1331:    while (a--)
branch  0 taken 1888
branch  1 taken 275 (fallthrough)
        -: 1332:    {
        -: 1333:      /* here i is the Huffman code of length k bits for value *p */
        -: 1334:      /* make tables up to required level */
     2056: 1335:      while (k > w + l)
branch  0 taken 168
branch  1 taken 1888 (fallthrough)
        -: 1336:      {
      168: 1337:        h++;
      168: 1338:        w += l;                 /* previous table always l bits */
        -: 1339:
        -: 1340:        /* compute minimum size table less than or equal to l bits */
      168: 1341:        z = (z = g - w) > (unsigned)l ? l : z;  /* upper limit on table size */
branch  0 taken 24 (fallthrough)
branch  1 taken 144
      168: 1342:        if ((f = 1 << (j = k - w)) > a + 1)     /* try a k-w bit table */
branch  0 taken 71 (fallthrough)
branch  1 taken 97
        -: 1343:        {                       /* too few codes for k-w bit table */
       71: 1344:          f -= a + 1;           /* deduct codes from patterns left */
       71: 1345:          xp = c + k;
      194: 1346:          while (++j < z)       /* try smaller tables up to z bits */
branch  0 taken 134
branch  1 taken 60 (fallthrough)
        -: 1347:          {
      134: 1348:            if ((f <<= 1) <= *++xp)
branch  0 taken 11 (fallthrough)
branch  1 taken 123
       11: 1349:              break;            /* enough codes to use up j bits */
      123: 1350:            f -= *xp;           /* else deduct codes from patterns */
        -: 1351:          }
        -: 1352:        }
      168: 1353:        z = 1 << j;             /* table entries for j-bit table */
        -: 1354:
        -: 1355:        /* allocate and link in new table */
      168: 1356:        if ((q = (struct huft *)malloc((z + 1)*sizeof(struct huft))) ==
branch  0 taken 0 (fallthrough)
branch  1 taken 168
        -: 1357:            (struct huft *)NULL)
        -: 1358:        {
    #####: 1359:          if (h)
branch  0 never executed
branch  1 never executed
    #####: 1360:            huft_free(u[0]);
call    0 never executed
    #####: 1361:          return 3;             /* not enough memory */
        -: 1362:        }
      168: 1363:        hufts += z + 1;         /* track memory usage */
      168: 1364:        *t = q + 1;             /* link to list for huft_free() */
      168: 1365:        *(t = &(q->v.t)) = (struct huft *)NULL;
      168: 1366:        u[h] = ++q;             /* table starts after link */
        -: 1367:
        -: 1368:        /* connect to last table, if there is one */
      168: 1369:        if (h)
branch  0 taken 132 (fallthrough)
branch  1 taken 36
        -: 1370:        {
      132: 1371:          x[h] = i;             /* save pattern for backing up */
      132: 1372:          r.b = (uch)l;         /* bits to dump before this table */
      132: 1373:          r.e = (uch)(16 + j);  /* bits in this table */
      132: 1374:          r.v.t = q;            /* pointer to this table */
      132: 1375:          j = i >> (w - l);     /* (get around Turbo C bug) */
      132: 1376:          u[h-1][j] = r;        /* connect to last table */
        -: 1377:        }
        -: 1378:      }
        -: 1379:
        -: 1380:      /* set up table entry in r */
     1888: 1381:      r.b = (uch)(k - w);
     1888: 1382:      if (p >= v + n)
branch  0 taken 0 (fallthrough)
branch  1 taken 1888
    #####: 1383:        r.e = 99;               /* out of values--invalid code */
     1888: 1384:      else if (*p < s)
branch  0 taken 1283 (fallthrough)
branch  1 taken 605
        -: 1385:      {
     1283: 1386:        r.e = (uch)(*p < 256 ? 16 : 15);    /* 256 is end-of-block code */
branch  0 taken 1271 (fallthrough)
branch  1 taken 12
     1283: 1387:        r.v.n = *p++;           /* simple code is just the value */
        -: 1388:      }
        -: 1389:      else
        -: 1390:      {
      605: 1391:        r.e = (uch)e[*p - s];   /* non-simple--look up in lists */
      605: 1392:        r.v.n = d[*p++ - s];
        -: 1393:      }
        -: 1394:
        -: 1395:      /* fill code-like entries with r */
     1888: 1396:      f = 1 << (k - w);
    10430: 1397:      for (j = i >> w; j < z; j += f)
branch  0 taken 8542
branch  1 taken 1888 (fallthrough)
     8542: 1398:        q[j] = r;
        -: 1399:
        -: 1400:      /* backwards increment the k-bit code i */
     3740: 1401:      for (j = 1 << (k - 1); i & j; j >>= 1)
branch  0 taken 1852
branch  1 taken 1888 (fallthrough)
     1852: 1402:        i ^= j;
     1888: 1403:      i ^= j;
        -: 1404:
        -: 1405:      /* backup over finished tables */
     2020: 1406:      while ((i & ((1 << w) - 1)) != x[h])
branch  0 taken 132
branch  1 taken 1888 (fallthrough)
        -: 1407:      {
      132: 1408:        h--;                    /* don't need to update q */
      132: 1409:        w -= l;
        -: 1410:      }
        -: 1411:    }
        -: 1412:  }
        -: 1413:
        -: 1414:
        -: 1415:  /* Return true (1) if we were given an incomplete table */
      36*: 1416:  return y != 0 && g != 1;
branch  0 taken 0 (fallthrough)
branch  1 taken 36
branch  2 never executed
branch  3 never executed
        -: 1417:}
        -: 1418:
        -: 1419:
        -: 1420:
function huft_free called 36 returned 100% blocks executed 100%
       36: 1421:int huft_free(t)
        -: 1422:struct huft *t;         /* table to free */
        -: 1423:/* Free the malloc'ed tables built by huft_build(), which makes a linked
        -: 1424:   list of the tables it made, with the links in a dummy first entry of
        -: 1425:   each table. */
        -: 1426:{
        -: 1427:  register struct huft *p, *q;
        -: 1428:
        -: 1429:
        -: 1430:  /* Go through linked list, freeing from the malloced (t[-1]) address. */
       36: 1431:  p = t;
      204: 1432:  while (p != (struct huft *)NULL)
branch  0 taken 168
branch  1 taken 36 (fallthrough)
        -: 1433:  {
      168: 1434:    q = (--p)->v.t;
      168: 1435:    free(p);
      168: 1436:    p = q;
        -: 1437:  }
       36: 1438:  return 0;
        -: 1439:}
        -: 1440:
        -: 1441:
function inflate_codes called 12 returned 100% blocks executed 81%
       12: 1442:int inflate_codes(tl, td, bl, bd)
        -: 1443:struct huft *tl, *td;   /* literal/length and distance decoder tables */
        -: 1444:int bl, bd;             /* number of bits decoded by tl[] and td[] */
        -: 1445:/* inflate (decompress) the codes in a deflated (compressed) block.
        -: 1446:   Return an error code or zero if it all goes ok. */
        -: 1447:{
        -: 1448:  register unsigned e;  /* table entry flag/number of extra bits */
        -: 1449:  unsigned n, d;        /* length and index for copy */
        -: 1450:  unsigned w;           /* current window position */
        -: 1451:  struct huft *t;       /* pointer to table entry */
        -: 1452:  unsigned ml, md;      /* masks for bl and bd bits */
        -: 1453:  register ulg b;       /* bit buffer */
        -: 1454:  register unsigned k;  /* number of bits in bit buffer */
        -: 1455:
        -: 1456:
        -: 1457:  /* make local copies of globals */
       12: 1458:  b = bb;                       /* initialize bit buffer */
       12: 1459:  k = bk;
       12: 1460:  w = wp;                       /* initialize window position */
        -: 1461:
        -: 1462:  /* inflate the coded data */
       12: 1463:  ml = mask_bits[bl];           /* precompute masks for speed */
       12: 1464:  md = mask_bits[bd];
        -: 1465:  for (;;)                      /* do until end of block */
        -: 1466:  {
  175355*: 1467:    NEEDBITS((unsigned)bl)
branch  0 taken 87900 (fallthrough)
branch  1 taken 0
call    2 never executed
branch  3 taken 87900
branch  4 taken 87455 (fallthrough)
    87455: 1468:    if ((e = (t = tl + ((unsigned)b & ml))->e) > 16)
branch  0 taken 1715 (fallthrough)
branch  1 taken 85740
        -: 1469:      do {
     1715: 1470:        if (e == 99)
branch  0 taken 0 (fallthrough)
branch  1 taken 1715
    #####: 1471:          return 1;
     1715: 1472:        DUMPBITS(t->b)
     1715: 1473:        e -= 16;
    2046*: 1474:        NEEDBITS(e)
branch  0 taken 331 (fallthrough)
branch  1 taken 0
call    2 never executed
branch  3 taken 331
branch  4 taken 1715 (fallthrough)
     1715: 1475:      } while ((e = (t = t->v.t + ((unsigned)b & mask_bits[e]))->e) > 16);
branch  0 taken 0
branch  1 taken 1715 (fallthrough)
    87455: 1476:    DUMPBITS(t->b)
    87455: 1477:    if (e == 16)                /* then it's a literal */
branch  0 taken 39175 (fallthrough)
branch  1 taken 48280
        -: 1478:    {
    39175: 1479:      slide[w++] = (uch)t->v.n;
        -: 1480:      Tracevv((stderr, "%c", slide[w-1]));
    39175: 1481:      if (w == WSIZE)
branch  0 taken 1 (fallthrough)
branch  1 taken 39174
        -: 1482:      {
        1: 1483:        flush_output(w);
call    0 returned 1
        1: 1484:        w = 0;
        -: 1485:      }
        -: 1486:    }
        -: 1487:    else                        /* it's an EOB or a length */
        -: 1488:    {
        -: 1489:      /* exit if end of block */
    48280: 1490:      if (e == 15)
branch  0 taken 12 (fallthrough)
branch  1 taken 48268
       12: 1491:        break;
        -: 1492:
        -: 1493:      /* get length of block to copy */
   48520*: 1494:      NEEDBITS(e)
branch  0 taken 252 (fallthrough)
branch  1 taken 0
call    2 never executed
branch  3 taken 252
branch  4 taken 48268 (fallthrough)
    48268: 1495:      n = t->v.n + ((unsigned)b & mask_bits[e]);
    48268: 1496:      DUMPBITS(e);
        -: 1497:
        -: 1498:      /* decode distance of block to copy */
   58048*: 1499:      NEEDBITS((unsigned)bd)
branch  0 taken 9780 (fallthrough)
branch  1 taken 0
call    2 never executed
branch  3 taken 9780
branch  4 taken 48268 (fallthrough)
    48268: 1500:      if ((e = (t = td + ((unsigned)b & md))->e) > 16)
branch  0 taken 1771 (fallthrough)
branch  1 taken 46497
        -: 1501:        do {
     1771: 1502:          if (e == 99)
branch  0 taken 0 (fallthrough)
branch  1 taken 1771
    #####: 1503:            return 1;
     1771: 1504:          DUMPBITS(t->b)
     1771: 1505:          e -= 16;
    2524*: 1506:          NEEDBITS(e)
branch  0 taken 753 (fallthrough)
branch  1 taken 0
call    2 never executed
branch  3 taken 753
branch  4 taken 1771 (fallthrough)
     1771: 1507:        } while ((e = (t = t->v.t + ((unsigned)b & mask_bits[e]))->e) > 16);
branch  0 taken 0
branch  1 taken 1771 (fallthrough)
    48268: 1508:      DUMPBITS(t->b)
   89405*: 1509:      NEEDBITS(e)
branch  0 taken 41137 (fallthrough)
branch  1 taken 0
call    2 never executed
branch  3 taken 41137
branch  4 taken 48268 (fallthrough)
    48268: 1510:      d = w - t->v.n - ((unsigned)b & mask_bits[e]);
    48268: 1511:      DUMPBITS(e)
        -: 1512:      Tracevv((stderr,"\\[%d,%d]", w-d, n));
        -: 1513:
        -: 1514:      /* do the copy */
        -: 1515:      do {
    48291: 1516:        n -= (e = (e = WSIZE - ((d &= WSIZE-1) > w ? d : w)) > n ? n : e);
branch  0 taken 1894 (fallthrough)
branch  1 taken 46397
branch  2 taken 48268 (fallthrough)
branch  3 taken 23
        -: 1517:#if !defined(NOMEMCPY) && !defined(DEBUG)
    48291: 1518:        if (w - d >= e)         /* (this test assumes unsigned comparison) */
branch  0 taken 48088 (fallthrough)
branch  1 taken 203
        -: 1519:        {
    48088: 1520:          memcpy(slide + w, slide + d, e);
    48088: 1521:          w += e;
    48088: 1522:          d += e;
        -: 1523:        }
        -: 1524:        else                      /* do it slow to avoid memcpy() overlap */
        -: 1525:#endif /* !NOMEMCPY */
        -: 1526:          do {
     9338: 1527:            slide[w++] = slide[d++];
        -: 1528:            Tracevv((stderr, "%c", slide[w-1]));
     9338: 1529:          } while (--e);
branch  0 taken 9135
branch  1 taken 203 (fallthrough)
    48291: 1530:        if (w == WSIZE)
branch  0 taken 11 (fallthrough)
branch  1 taken 48280
        -: 1531:        {
       11: 1532:          flush_output(w);
call    0 returned 11
       11: 1533:          w = 0;
        -: 1534:        }
    48291: 1535:      } while (n);
branch  0 taken 23
branch  1 taken 48268 (fallthrough)
        -: 1536:    }
        -: 1537:  }
        -: 1538:
        -: 1539:
        -: 1540:  /* restore the globals from the locals */
       12: 1541:  wp = w;                       /* restore global window pointer */
       12: 1542:  bb = b;                       /* restore global bit buffer */
       12: 1543:  bk = k;
        -: 1544:
        -: 1545:  /* done */
       12: 1546:  return 0;
        -: 1547:}
        -: 1548:
        -: 1549:
        -: 1550:
function inflate_stored called 2 returned 100% blocks executed 84%
        2: 1551:int inflate_stored()
        -: 1552:/* "decompress" an inflated type 0 (stored) block. */
        -: 1553:{
        -: 1554:  unsigned n;           /* number of bytes in block */
        -: 1555:  unsigned w;           /* current window position */
        -: 1556:  register ulg b;       /* bit buffer */
        -: 1557:  register unsigned k;  /* number of bits in bit buffer */
        -: 1558:
        -: 1559:
        -: 1560:  /* make local copies of globals */
        2: 1561:  b = bb;                       /* initialize bit buffer */
        2: 1562:  k = bk;
        2: 1563:  w = wp;                       /* initialize window position */
        -: 1564:
        -: 1565:
        -: 1566:  /* go to byte boundary */
        2: 1567:  n = k & 7;
        2: 1568:  DUMPBITS(n);
        -: 1569:
        -: 1570:
        -: 1571:  /* get the length and its complement */
       6*: 1572:  NEEDBITS(16)
branch  0 taken 4 (fallthrough)
branch  1 taken 0
call    2 never executed
branch  3 taken 4
branch  4 taken 2 (fallthrough)
        2: 1573:  n = ((unsigned)b & 0xffff);
        2: 1574:  DUMPBITS(16)
       6*: 1575:  NEEDBITS(16)
branch  0 taken 4 (fallthrough)
branch  1 taken 0
call    2 never executed
branch  3 taken 4
branch  4 taken 2 (fallthrough)
        2: 1576:  if (n != (unsigned)((~b) & 0xffff))
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####: 1577:    return 1;                   /* error in compressed data */
        2: 1578:  DUMPBITS(16)
        -: 1579:
        -: 1580:
        -: 1581:  /* read and output the compressed data */
    34233: 1582:  while (n--)
branch  0 taken 34231
branch  1 taken 2 (fallthrough)
        -: 1583:  {
    68462: 1584:    NEEDBITS(8)
branch  0 taken 34230 (fallthrough)
branch  1 taken 1
call    2 returned 1
branch  3 taken 34231
branch  4 taken 34231 (fallthrough)
    34231: 1585:    slide[w++] = (uch)b;
    34231: 1586:    if (w == WSIZE)
branch  0 taken 1 (fallthrough)
branch  1 taken 34230
        -: 1587:    {
        1: 1588:      flush_output(w);
call    0 returned 1
        1: 1589:      w = 0;
        -: 1590:    }
    34231: 1591:    DUMPBITS(8)
        -: 1592:  }
        -: 1593:
        -: 1594:
        -: 1595:  /* restore the globals from the locals */
        2: 1596:  wp = w;                       /* restore global window pointer */
        2: 1597:  bb = b;                       /* restore global bit buffer */
        2: 1598:  bk = k;
        2: 1599:  return 0;
        -: 1600:}
        -: 1601:
        -: 1602:
        -: 1603:
function inflate_fixed called 0 returned 0% blocks executed 0%
    #####: 1604:int inflate_fixed()
        -: 1605:/* decompress an inflated type 1 (fixed Huffman codes) block.  We should
        -: 1606:   either replace this with a custom decoder, or at least precompute the
        -: 1607:   Huffman tables. */
        -: 1608:{
        -: 1609:  int i;                /* temporary variable */
        -: 1610:  struct huft *tl;      /* literal/length code table */
        -: 1611:  struct huft *td;      /* distance code table */
        -: 1612:  int bl;               /* lookup bits for tl */
        -: 1613:  int bd;               /* lookup bits for td */
        -: 1614:  unsigned l[288];      /* length list for huft_build */
        -: 1615:
        -: 1616:
        -: 1617:  /* set up literal table */
    #####: 1618:  for (i = 0; i < 144; i++)
branch  0 never executed
branch  1 never executed
    #####: 1619:    l[i] = 8;
    #####: 1620:  for (; i < 256; i++)
branch  0 never executed
branch  1 never executed
    #####: 1621:    l[i] = 9;
    #####: 1622:  for (; i < 280; i++)
branch  0 never executed
branch  1 never executed
    #####: 1623:    l[i] = 7;
    #####: 1624:  for (; i < 288; i++)          /* make a complete, but wrong code set */
branch  0 never executed
branch  1 never executed
    #####: 1625:    l[i] = 8;
    #####: 1626:  bl = 7;
    #####: 1627:  if ((i = huft_build(l, 288, 257, cplens, cplext, &tl, &bl)) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1628:    return i;
        -: 1629:
        -: 1630:
        -: 1631:  /* set up distance table */
    #####: 1632:  for (i = 0; i < 30; i++)      /* make an incomplete code set */
branch  0 never executed
branch  1 never executed
    #####: 1633:    l[i] = 5;
    #####: 1634:  bd = 5;
    #####: 1635:  if ((i = huft_build(l, 30, 0, cpdist, cpdext, &td, &bd)) > 1)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1636:  {
    #####: 1637:    huft_free(tl);
call    0 never executed
    #####: 1638:    return i;
        -: 1639:  }
        -: 1640:
        -: 1641:
        -: 1642:  /* decompress until an end-of-block code */
    #####: 1643:  if (inflate_codes(tl, td, bl, bd))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1644:    return 1;
        -: 1645:
        -: 1646:
        -: 1647:  /* free the decoding tables, return */
    #####: 1648:  huft_free(tl);
call    0 never executed
    #####: 1649:  huft_free(td);
call    0 never executed
    #####: 1650:  return 0;
        -: 1651:}
        -: 1652:
        -: 1653:
        -: 1654:
function inflate_dynamic called 12 returned 100% blocks executed 66%
       12: 1655:int inflate_dynamic()
        -: 1656:/* decompress an inflated type 2 (dynamic Huffman codes) block. */
        -: 1657:{
        -: 1658:  int i;                /* temporary variables */
        -: 1659:  unsigned j;
        -: 1660:  unsigned l;           /* last length */
        -: 1661:  unsigned m;           /* mask for bit lengths table */
        -: 1662:  unsigned n;           /* number of lengths to get */
        -: 1663:  struct huft *tl;      /* literal/length code table */
        -: 1664:  struct huft *td;      /* distance code table */
        -: 1665:  int bl;               /* lookup bits for tl */
        -: 1666:  int bd;               /* lookup bits for td */
        -: 1667:  unsigned nb;          /* number of bit length codes */
        -: 1668:  unsigned nl;          /* number of literal/length codes */
        -: 1669:  unsigned nd;          /* number of distance codes */
        -: 1670:#ifdef PKZIP_BUG_WORKAROUND
        -: 1671:  unsigned ll[288+32];  /* literal/length and distance code lengths */
        -: 1672:#else
        -: 1673:  unsigned ll[286+30];  /* literal/length and distance code lengths */
        -: 1674:#endif
        -: 1675:  register ulg b;       /* bit buffer */
        -: 1676:  register unsigned k;  /* number of bits in bit buffer */
        -: 1677:
        -: 1678:
        -: 1679:  /* make local bit buffer */
       12: 1680:  b = bb;
       12: 1681:  k = bk;
        -: 1682:
        -: 1683:
        -: 1684:  /* read in table lengths */
      12*: 1685:  NEEDBITS(5)
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 taken 0
branch  4 taken 12 (fallthrough)
       12: 1686:  nl = 257 + ((unsigned)b & 0x1f);      /* number of literal/length codes */
       12: 1687:  DUMPBITS(5)
      24*: 1688:  NEEDBITS(5)
branch  0 taken 12 (fallthrough)
branch  1 taken 0
call    2 never executed
branch  3 taken 12
branch  4 taken 12 (fallthrough)
       12: 1689:  nd = 1 + ((unsigned)b & 0x1f);        /* number of distance codes */
       12: 1690:  DUMPBITS(5)
      23*: 1691:  NEEDBITS(4)
branch  0 taken 11 (fallthrough)
branch  1 taken 0
call    2 never executed
branch  3 taken 11
branch  4 taken 12 (fallthrough)
       12: 1692:  nb = 4 + ((unsigned)b & 0xf);         /* number of bit length codes */
       12: 1693:  DUMPBITS(4)
        -: 1694:#ifdef PKZIP_BUG_WORKAROUND
        -: 1695:  if (nl > 288 || nd > 32)
        -: 1696:#else
       12: 1697:  if (nl > 286 || nd > 30)
branch  0 taken 12 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 12
        -: 1698:#endif
    #####: 1699:    return 1;                   /* bad lengths */
        -: 1700:
        -: 1701:
        -: 1702:  /* read in bit-length-code lengths */
      191: 1703:  for (j = 0; j < nb; j++)
branch  0 taken 179
branch  1 taken 12 (fallthrough)
        -: 1704:  {
     240*: 1705:    NEEDBITS(3)
branch  0 taken 61 (fallthrough)
branch  1 taken 0
call    2 never executed
branch  3 taken 61
branch  4 taken 179 (fallthrough)
      179: 1706:    ll[border[j]] = (unsigned)b & 7;
      179: 1707:    DUMPBITS(3)
        -: 1708:  }
       61: 1709:  for (; j < 19; j++)
branch  0 taken 49
branch  1 taken 12 (fallthrough)
       49: 1710:    ll[border[j]] = 0;
        -: 1711:
        -: 1712:
        -: 1713:  /* build decoding table for trees--single level, 7 bit lookup */
       12: 1714:  bl = 7;
       12: 1715:  if ((i = huft_build(ll, 19, 19, NULL, NULL, &tl, &bl)) != 0)
call    0 returned 12
branch  1 taken 0 (fallthrough)
branch  2 taken 12
        -: 1716:  {
    #####: 1717:    if (i == 1)
branch  0 never executed
branch  1 never executed
    #####: 1718:      huft_free(tl);
call    0 never executed
    #####: 1719:    return i;                   /* incomplete code set */
        -: 1720:  }
        -: 1721:
        -: 1722:
        -: 1723:  /* read in literal and distance code lengths */
       12: 1724:  n = nl + nd;
       12: 1725:  m = mask_bits[bl];
       12: 1726:  i = l = 0;
     1768: 1727:  while ((unsigned)i < n)
branch  0 taken 1756
branch  1 taken 12 (fallthrough)
        -: 1728:  {
    2555*: 1729:    NEEDBITS((unsigned)bl)
branch  0 taken 799 (fallthrough)
branch  1 taken 0
call    2 never executed
branch  3 taken 799
branch  4 taken 1756 (fallthrough)
     1756: 1730:    j = (td = tl + ((unsigned)b & m))->b;
     1756: 1731:    DUMPBITS(j)
     1756: 1732:    j = td->v.n;
     1756: 1733:    if (j < 16)                 /* length of code in bits (0..15) */
branch  0 taken 1662 (fallthrough)
branch  1 taken 94
     1662: 1734:      ll[i++] = l = j;          /* save last length in l */
       94: 1735:    else if (j == 16)           /* repeat last length 3 to 6 times */
branch  0 taken 38 (fallthrough)
branch  1 taken 56
        -: 1736:    {
      38*: 1737:      NEEDBITS(2)
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 taken 0
branch  4 taken 38 (fallthrough)
       38: 1738:      j = 3 + ((unsigned)b & 3);
       38: 1739:      DUMPBITS(2)
       38: 1740:      if ((unsigned)i + j > n)
branch  0 taken 0 (fallthrough)
branch  1 taken 38
    #####: 1741:        return 1;
      190: 1742:      while (j--)
branch  0 taken 152
branch  1 taken 38
      152: 1743:        ll[i++] = l;
        -: 1744:    }
       56: 1745:    else if (j == 17)           /* 3 to 10 zero length codes */
branch  0 taken 32 (fallthrough)
branch  1 taken 24
        -: 1746:    {
      42*: 1747:      NEEDBITS(3)
branch  0 taken 10 (fallthrough)
branch  1 taken 0
call    2 never executed
branch  3 taken 10
branch  4 taken 32 (fallthrough)
       32: 1748:      j = 3 + ((unsigned)b & 7);
       32: 1749:      DUMPBITS(3)
       32: 1750:      if ((unsigned)i + j > n)
branch  0 taken 0 (fallthrough)
branch  1 taken 32
    #####: 1751:        return 1;
      228: 1752:      while (j--)
branch  0 taken 196
branch  1 taken 32 (fallthrough)
      196: 1753:        ll[i++] = 0;
       32: 1754:      l = 0;
        -: 1755:    }
        -: 1756:    else                        /* j == 18: 11 to 138 zero length codes */
        -: 1757:    {
      47*: 1758:      NEEDBITS(7)
branch  0 taken 23 (fallthrough)
branch  1 taken 0
call    2 never executed
branch  3 taken 23
branch  4 taken 24 (fallthrough)
       24: 1759:      j = 11 + ((unsigned)b & 0x7f);
       24: 1760:      DUMPBITS(7)
       24: 1761:      if ((unsigned)i + j > n)
branch  0 taken 0 (fallthrough)
branch  1 taken 24
    #####: 1762:        return 1;
     1805: 1763:      while (j--)
branch  0 taken 1781
branch  1 taken 24 (fallthrough)
     1781: 1764:        ll[i++] = 0;
       24: 1765:      l = 0;
        -: 1766:    }
        -: 1767:  }
        -: 1768:
        -: 1769:
        -: 1770:  /* free decoding table for trees */
       12: 1771:  huft_free(tl);
call    0 returned 12
        -: 1772:
        -: 1773:
        -: 1774:  /* restore the global bit buffer */
       12: 1775:  bb = b;
       12: 1776:  bk = k;
        -: 1777:
        -: 1778:
        -: 1779:  /* build the decoding tables for literal/length and distance codes */
       12: 1780:  bl = lbits;
       12: 1781:  if ((i = huft_build(ll, nl, 257, cplens, cplext, &tl, &bl)) != 0)
call    0 returned 12
branch  1 taken 0 (fallthrough)
branch  2 taken 12
        -: 1782:  {
    #####: 1783:    if (i == 1) {
branch  0 never executed
branch  1 never executed
    #####: 1784:      fprintf(stderr, " incomplete literal tree\n");
call    0 never executed
    #####: 1785:      huft_free(tl);
call    0 never executed
        -: 1786:    }
    #####: 1787:    return i;                   /* incomplete code set */
        -: 1788:  }
       12: 1789:  bd = dbits;
       12: 1790:  if ((i = huft_build(ll + nl, nd, 0, cpdist, cpdext, &td, &bd)) != 0)
call    0 returned 12
branch  1 taken 0 (fallthrough)
branch  2 taken 12
        -: 1791:  {
    #####: 1792:    if (i == 1) {
branch  0 never executed
branch  1 never executed
    #####: 1793:      fprintf(stderr, " incomplete distance tree\n");
call    0 never executed
        -: 1794:#ifdef PKZIP_BUG_WORKAROUND
        -: 1795:      i = 0;
        -: 1796:    }
        -: 1797:#else
    #####: 1798:      huft_free(td);
call    0 never executed
        -: 1799:    }
    #####: 1800:    huft_free(tl);
call    0 never executed
    #####: 1801:    return i;                   /* incomplete code set */
        -: 1802:#endif
        -: 1803:  }
        -: 1804:
        -: 1805:
        -: 1806:  /* decompress until an end-of-block code */
       12: 1807:  if (inflate_codes(tl, td, bl, bd))
call    0 returned 12
branch  1 taken 0 (fallthrough)
branch  2 taken 12
    #####: 1808:    return 1;
        -: 1809:
        -: 1810:
        -: 1811:  /* free the decoding tables, return */
       12: 1812:  huft_free(tl);
call    0 returned 12
       12: 1813:  huft_free(td);
call    0 returned 12
       12: 1814:  return 0;
        -: 1815:}
        -: 1816:
        -: 1817:
        -: 1818:
function inflate_block called 14 returned 100% blocks executed 68%
       14: 1819:int inflate_block(e)
        -: 1820:int *e;                 /* last block flag */
        -: 1821:/* decompress an inflated block */
        -: 1822:{
        -: 1823:  unsigned t;           /* block type */
        -: 1824:  register ulg b;       /* bit buffer */
        -: 1825:  register unsigned k;  /* number of bits in bit buffer */
        -: 1826:
        -: 1827:
        -: 1828:  /* make local bit buffer */
       14: 1829:  b = bb;
       14: 1830:  k = bk;
        -: 1831:
        -: 1832:
        -: 1833:  /* read in last block bit */
      27*: 1834:  NEEDBITS(1)
branch  0 taken 13 (fallthrough)
branch  1 taken 0
call    2 never executed
branch  3 taken 13
branch  4 taken 14 (fallthrough)
       14: 1835:  *e = (int)b & 1;
       14: 1836:  DUMPBITS(1)
        -: 1837:
        -: 1838:
        -: 1839:  /* read in block type */
      15*: 1840:  NEEDBITS(2)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
call    2 never executed
branch  3 taken 1
branch  4 taken 14 (fallthrough)
       14: 1841:  t = (unsigned)b & 3;
       14: 1842:  DUMPBITS(2)
        -: 1843:
        -: 1844:
        -: 1845:  /* restore the global bit buffer */
       14: 1846:  bb = b;
       14: 1847:  bk = k;
        -: 1848:
        -: 1849:
        -: 1850:  /* inflate that block type */
       14: 1851:  if (t == 2)
branch  0 taken 12 (fallthrough)
branch  1 taken 2
       12: 1852:    return inflate_dynamic();
call    0 returned 12
        2: 1853:  if (t == 0)
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2: 1854:    return inflate_stored();
call    0 returned 2
    #####: 1855:  if (t == 1)
branch  0 never executed
branch  1 never executed
    #####: 1856:    return inflate_fixed();
call    0 never executed
        -: 1857:
        -: 1858:
        -: 1859:  /* bad block type */
    #####: 1860:  return 2;
        -: 1861:}
        -: 1862:
        -: 1863:
        -: 1864:
function inflate called 12 returned 100% blocks executed 86%
       12: 1865:int inflate()
        -: 1866:/* decompress an inflated entry */
        -: 1867:{
        -: 1868:  int e;                /* last block flag */
        -: 1869:  int r;                /* result code */
        -: 1870:  unsigned h;           /* maximum struct huft's malloc'ed */
        -: 1871:
        -: 1872:
        -: 1873:  /* initialize window, bit buffer */
       12: 1874:  wp = 0;
       12: 1875:  bk = 0;
       12: 1876:  bb = 0;
        -: 1877:
        -: 1878:
        -: 1879:  /* decompress until the last block */
       12: 1880:  h = 0;
        -: 1881:  do {
       14: 1882:    hufts = 0;
       14: 1883:    if ((r = inflate_block(&e)) != 0)
call    0 returned 14
branch  1 taken 0 (fallthrough)
branch  2 taken 14
    #####: 1884:      return r;
       14: 1885:    if (hufts > h)
branch  0 taken 12 (fallthrough)
branch  1 taken 2
       12: 1886:      h = hufts;
       14: 1887:  } while (!e);
branch  0 taken 2
branch  1 taken 12 (fallthrough)
        -: 1888:
        -: 1889:  /* Undo too much lookahead. The next read will be byte aligned so we
        -: 1890:   * can discard unused bits in the last meaningful byte.
        -: 1891:   */
       12: 1892:  while (bk >= 8) {
branch  0 taken 0
branch  1 taken 12 (fallthrough)
    #####: 1893:    bk -= 8;
    #####: 1894:    inptr--;
        -: 1895:  }
        -: 1896:
        -: 1897:  /* flush out slide */
       12: 1898:  flush_output(wp);
call    0 returned 12
        -: 1899:
        -: 1900:
        -: 1901:  /* return success */
        -: 1902:#ifdef DEBUG
        -: 1903:  fprintf(stderr, "<%u> ", h);
        -: 1904:#endif /* DEBUG */
       12: 1905:  return 0;
        -: 1906:}
        -: 1907:/* lzw.c -- compress files in LZW format.
        -: 1908: * This is a dummy version avoiding patent problems.
        -: 1909: */
        -: 1910:
        -: 1911:/*
        -: 1912:#ifndef lint
        -: 1913:static char rcsid[] = "$Id: lzw.c,v 0.7 1993/02/10 16:07:22 jloup Exp $";
        -: 1914:#endif
        -: 1915:*/
        -: 1916:
        -: 1917:static int msg_done = 0;
        -: 1918:
        -: 1919:/* Compress in to out with lzw method. */
function lzw called 0 returned 0% blocks executed 0%
    #####: 1920:void lzw(in, out)
        -: 1921:    int in, out;
        -: 1922:{
    #####: 1923:    if (msg_done) return;
branch  0 never executed
branch  1 never executed
    #####: 1924:    msg_done = 1;
    #####: 1925:    fprintf(stderr,"output in compress .Z format not supported\n");
call    0 never executed
    #####: 1926:    in++, out++; /* avoid warnings on unused variables */
    #####: 1927:    exit_code = ERROR;
        -: 1928:}
        -: 1929:/* trees.c -- output deflated data using Huffman coding
        -: 1930: * Copyright (C) 1992-1993 Jean-loup Gailly
        -: 1931: * This is free software; you can redistribute it and/or modify it under the
        -: 1932: * terms of the GNU General Public License, see the file COPYING.
        -: 1933: */
        -: 1934:
        -: 1935:/*
        -: 1936: *  PURPOSE
        -: 1937: *
        -: 1938: *      Encode various sets of source values using variable-length
        -: 1939: *      binary code trees.
        -: 1940: *
        -: 1941: *  DISCUSSION
        -: 1942: *
        -: 1943: *      The PKZIP "deflation" process uses several Huffman trees. The more
        -: 1944: *      common source values are represented by shorter bit sequences.
        -: 1945: *
        -: 1946: *      Each code tree is stored in the ZIP file in a compressed form
        -: 1947: *      which is itself a Huffman encoding of the lengths of
        -: 1948: *      all the code strings (in ascending order by source values).
        -: 1949: *      The actual code strings are reconstructed from the lengths in
        -: 1950: *      the UNZIP process, as described in the "application note"
        -: 1951: *      (APPNOTE.TXT) distributed as part of PKWARE's PKZIP program.
        -: 1952: *
        -: 1953: *  REFERENCES
        -: 1954: *
        -: 1955: *      Lynch, Thomas J.
        -: 1956: *          Data Compression:  Techniques and Applications, pp. 53-55.
        -: 1957: *          Lifetime Learning Publications, 1985.  ISBN 0-534-03418-7.
        -: 1958: *
        -: 1959: *      Storer, James A.
        -: 1960: *          Data Compression:  Methods and Theory, pp. 49-50.
        -: 1961: *          Computer Science Press, 1988.  ISBN 0-7167-8156-5.
        -: 1962: *
        -: 1963: *      Sedgewick, R.
        -: 1964: *          Algorithms, p290.
        -: 1965: *          Addison-Wesley, 1983. ISBN 0-201-06672-6.
        -: 1966: *
        -: 1967: *  INTERFACE
        -: 1968: *
        -: 1969: *      void ct_init (ush *attr, int *methodp)
        -: 1970: *          Allocate the match buffer, initialize the various tables and save
        -: 1971: *          the location of the internal file attribute (ascii/binary) and
        -: 1972: *          method (DEFLATE/STORE)
        -: 1973: *
        -: 1974: *      void ct_tally (int dist, int lc);
        -: 1975: *          Save the match info and tally the frequency counts.
        -: 1976: *
        -: 1977: *      long flush_block (char *buf, ulg stored_len, int eof)
        -: 1978: *          Determine the best encoding for the current block: dynamic trees,
        -: 1979: *          static trees or store, and output the encoded block to the zip
        -: 1980: *          file. Returns the total compressed length for the file so far.
        -: 1981: *
        -: 1982: */
        -: 1983:
        -: 1984:/*
        -: 1985:#ifndef lint
        -: 1986:static char rcsid[] = "$Id: trees.c,v 0.10 1993/03/18 18:14:56 jloup Exp $";
        -: 1987:#endif
        -: 1988:*/
        -: 1989:
        -: 1990:/* ===========================================================================
        -: 1991: * Constants
        -: 1992: */
        -: 1993:
        -: 1994:#define MAX_BITS 15
        -: 1995:/* All codes must not exceed MAX_BITS bits */
        -: 1996:
        -: 1997:#define MAX_BL_BITS 7
        -: 1998:/* Bit length codes must not exceed MAX_BL_BITS bits */
        -: 1999:
        -: 2000:#define LENGTH_CODES 29
        -: 2001:/* number of length codes, not counting the special END_BLOCK code */
        -: 2002:
        -: 2003:#define LITERALS  256
        -: 2004:/* number of literal bytes 0..255 */
        -: 2005:
        -: 2006:#define END_BLOCK 256
        -: 2007:/* end of block literal code */
        -: 2008:
        -: 2009:#define L_CODES (LITERALS+1+LENGTH_CODES)
        -: 2010:/* number of Literal or Length codes, including the END_BLOCK code */
        -: 2011:
        -: 2012:#define D_CODES   30
        -: 2013:/* number of distance codes */
        -: 2014:
        -: 2015:#define BL_CODES  19
        -: 2016:/* number of codes used to transfer the bit lengths */
        -: 2017:
        -: 2018:
        -: 2019:local int near extra_lbits[LENGTH_CODES] /* extra bits for each length code */
        -: 2020:   = {0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0};
        -: 2021:
        -: 2022:local int near extra_dbits[D_CODES] /* extra bits for each distance code */
        -: 2023:   = {0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};
        -: 2024:
        -: 2025:local int near extra_blbits[BL_CODES]/* extra bits for each bit length code */
        -: 2026:   = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7};
        -: 2027:
        -: 2028:#define STORED_BLOCK 0
        -: 2029:#define STATIC_TREES 1
        -: 2030:#define DYN_TREES    2
        -: 2031:/* The three kinds of block type */
        -: 2032:
        -: 2033:#ifndef LIT_BUFSIZE
        -: 2034:#  ifdef SMALL_MEM
        -: 2035:#    define LIT_BUFSIZE  0x2000
        -: 2036:#  else
        -: 2037:#  ifdef MEDIUM_MEM
        -: 2038:#    define LIT_BUFSIZE  0x4000
        -: 2039:#  else
        -: 2040:#    define LIT_BUFSIZE  0x8000
        -: 2041:#  endif
        -: 2042:#  endif
        -: 2043:#endif
        -: 2044:#ifndef DIST_BUFSIZE
        -: 2045:#  define DIST_BUFSIZE  LIT_BUFSIZE
        -: 2046:#endif
        -: 2047:/* Sizes of match buffers for literals/lengths and distances.  There are
        -: 2048: * 4 reasons for limiting LIT_BUFSIZE to 64K:
        -: 2049: *   - frequencies can be kept in 16 bit counters
        -: 2050: *   - if compression is not successful for the first block, all input data is
        -: 2051: *     still in the window so we can still emit a stored block even when input
        -: 2052: *     comes from standard input.  (This can also be done for all blocks if
        -: 2053: *     LIT_BUFSIZE is not greater than 32K.)
        -: 2054: *   - if compression is not successful for a file smaller than 64K, we can
        -: 2055: *     even emit a stored file instead of a stored block (saving 5 bytes).
        -: 2056: *   - creating new Huffman trees less frequently may not provide fast
        -: 2057: *     adaptation to changes in the input data statistics. (Take for
        -: 2058: *     example a binary file with poorly compressible code followed by
        -: 2059: *     a highly compressible string table.) Smaller buffer sizes give
        -: 2060: *     fast adaptation but have of course the overhead of transmitting trees
        -: 2061: *     more frequently.
        -: 2062: *   - I can't count above 4
        -: 2063: * The current code is general and allows DIST_BUFSIZE < LIT_BUFSIZE (to save
        -: 2064: * memory at the expense of compression). Some optimizations would be possible
        -: 2065: * if we rely on DIST_BUFSIZE == LIT_BUFSIZE.
        -: 2066: */
        -: 2067:#if LIT_BUFSIZE > INBUFSIZ
        -: 2068:    error cannot overlay l_buf and inbuf
        -: 2069:#endif
        -: 2070:
        -: 2071:#define REP_3_6      16
        -: 2072:/* repeat previous bit length 3-6 times (2 bits of repeat count) */
        -: 2073:
        -: 2074:#define REPZ_3_10    17
        -: 2075:/* repeat a zero length 3-10 times  (3 bits of repeat count) */
        -: 2076:
        -: 2077:#define REPZ_11_138  18
        -: 2078:/* repeat a zero length 11-138 times  (7 bits of repeat count) */
        -: 2079:
        -: 2080:/* ===========================================================================
        -: 2081: * Local data
        -: 2082: */
        -: 2083:
        -: 2084:/* Data structure describing a single value and its code string. */
        -: 2085:typedef struct ct_data {
        -: 2086:    union {
        -: 2087:        ush  freq;       /* frequency count */
        -: 2088:        ush  code;       /* bit string */
        -: 2089:    } fc;
        -: 2090:    union {
        -: 2091:        ush  dad;        /* father node in Huffman tree */
        -: 2092:        ush  len;        /* length of bit string */
        -: 2093:    } dl;
        -: 2094:} ct_data;
        -: 2095:
        -: 2096:#define Freq fc.freq
        -: 2097:#define Code fc.code
        -: 2098:#define Dad  dl.dad
        -: 2099:#define Len  dl.len
        -: 2100:
        -: 2101:#define HEAP_SIZE (2*L_CODES+1)
        -: 2102:/* maximum heap size */
        -: 2103:
        -: 2104:local ct_data near dyn_ltree[HEAP_SIZE];   /* literal and length tree */
        -: 2105:local ct_data near dyn_dtree[2*D_CODES+1]; /* distance tree */
        -: 2106:
        -: 2107:local ct_data near static_ltree[L_CODES+2];
        -: 2108:/* The static literal tree. Since the bit lengths are imposed, there is no
        -: 2109: * need for the L_CODES extra codes used during heap construction. However
        -: 2110: * The codes 286 and 287 are needed to build a canonical tree (see ct_init
        -: 2111: * below).
        -: 2112: */
        -: 2113:
        -: 2114:local ct_data near static_dtree[D_CODES];
        -: 2115:/* The static distance tree. (Actually a trivial tree since all codes use
        -: 2116: * 5 bits.)
        -: 2117: */
        -: 2118:
        -: 2119:local ct_data near bl_tree[2*BL_CODES+1];
        -: 2120:/* Huffman tree for the bit lengths */
        -: 2121:
        -: 2122:typedef struct tree_desc {
        -: 2123:    ct_data near *dyn_tree;      /* the dynamic tree */
        -: 2124:    ct_data near *static_tree;   /* corresponding static tree or NULL */
        -: 2125:    int     near *extra_bits;    /* extra bits for each code or NULL */
        -: 2126:    int     extra_base;          /* base index for extra_bits */
        -: 2127:    int     elems;               /* max number of elements in the tree */
        -: 2128:    int     max_length;          /* max bit length for the codes */
        -: 2129:    int     max_code;            /* largest code with non zero frequency */
        -: 2130:} tree_desc;
        -: 2131:
        -: 2132:local tree_desc near l_desc =
        -: 2133:{dyn_ltree, static_ltree, extra_lbits, LITERALS+1, L_CODES, MAX_BITS, 0};
        -: 2134:
        -: 2135:local tree_desc near d_desc =
        -: 2136:{dyn_dtree, static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS, 0};
        -: 2137:
        -: 2138:local tree_desc near bl_desc =
        -: 2139:{bl_tree, (ct_data near *)0, extra_blbits, 0,      BL_CODES, MAX_BL_BITS, 0};
        -: 2140:
        -: 2141:
        -: 2142:local ush near bl_count[MAX_BITS+1];
        -: 2143:/* number of codes at each bit length for an optimal tree */
        -: 2144:
        -: 2145:local uch near bl_order[BL_CODES]
        -: 2146:   = {16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15};
        -: 2147:/* The lengths of the bit length codes are sent in order of decreasing
        -: 2148: * probability, to avoid transmitting the lengths for unused bit length codes.
        -: 2149: */
        -: 2150:
        -: 2151:local int near heap[2*L_CODES+1]; /* heap used to build the Huffman trees */
        -: 2152:local int heap_len;               /* number of elements in the heap */
        -: 2153:local int heap_max;               /* element of largest frequency */
        -: 2154:/* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
        -: 2155: * The same heap array is used to build all trees.
        -: 2156: */
        -: 2157:
        -: 2158:local uch near depth[2*L_CODES+1];
        -: 2159:/* Depth of each subtree used as tie breaker for trees of equal frequency */
        -: 2160:
        -: 2161:local uch length_code[MAX_MATCH-MIN_MATCH+1];
        -: 2162:/* length code for each normalized match length (0 == MIN_MATCH) */
        -: 2163:
        -: 2164:local uch dist_code[512];
        -: 2165:/* distance codes. The first 256 values correspond to the distances
        -: 2166: * 3 .. 258, the last 256 values correspond to the top 8 bits of
        -: 2167: * the 15 bit distances.
        -: 2168: */
        -: 2169:
        -: 2170:local int near base_length[LENGTH_CODES];
        -: 2171:/* First normalized length for each code (0 = MIN_MATCH) */
        -: 2172:
        -: 2173:local int near base_dist[D_CODES];
        -: 2174:/* First normalized distance for each code (0 = distance of 1) */
        -: 2175:
        -: 2176:#define l_buf inbuf
        -: 2177:/* DECLARE(uch, l_buf, LIT_BUFSIZE);  buffer for literals or lengths */
        -: 2178:
        -: 2179:/* DECLARE(ush, d_buf, DIST_BUFSIZE); buffer for distances */
        -: 2180:
        -: 2181:local uch near flag_buf[(LIT_BUFSIZE/8)];
        -: 2182:/* flag_buf is a bit array distinguishing literals from lengths in
        -: 2183: * l_buf, thus indicating the presence or absence of a distance.
        -: 2184: */
        -: 2185:
        -: 2186:local unsigned last_lit;    /* running index in l_buf */
        -: 2187:local unsigned last_dist;   /* running index in d_buf */
        -: 2188:local unsigned last_flags;  /* running index in flag_buf */
        -: 2189:local uch flags;            /* current flags not yet saved in flag_buf */
        -: 2190:local uch flag_bit;         /* current bit used in flags */
        -: 2191:/* bits are filled in flags starting at bit 0 (least significant).
        -: 2192: * Note: these flags are overkill in the current code since we don't
        -: 2193: * take advantage of DIST_BUFSIZE == LIT_BUFSIZE.
        -: 2194: */
        -: 2195:
        -: 2196:local ulg opt_len;        /* bit length of current block with optimal trees */
        -: 2197:local ulg static_len;     /* bit length of current block with static trees */
        -: 2198:
        -: 2199:local ulg compressed_len; /* total bit length of compressed file */
        -: 2200:
        -: 2201:local ulg input_len;      /* total byte length of input file */
        -: 2202:/* input_len is for debugging only since we can get it by other means. */
        -: 2203:
        -: 2204:ush *file_type;        /* pointer to UNKNOWN, BINARY or ASCII */
        -: 2205:int *file_method;      /* pointer to DEFLATE or STORE */
        -: 2206:
        -: 2207:#ifdef DEBUG
        -: 2208:extern ulg bits_sent;  /* bit length of the compressed data */
        -: 2209:extern long isize;     /* byte length of input file */
        -: 2210:#endif
        -: 2211:
        -: 2212:extern long block_start;       /* window offset of current block */
        -: 2213:extern unsigned near strstart; /* window offset of current string */
        -: 2214:
        -: 2215:/* ===========================================================================
        -: 2216: * Local (static) routines in this file.
        -: 2217: */
        -: 2218:
        -: 2219:local void init_block     OF((void));
        -: 2220:local void pqdownheap     OF((ct_data near *tree, int k));
        -: 2221:local void gen_bitlen     OF((tree_desc near *desc));
        -: 2222:local void gen_codes      OF((ct_data near *tree, int max_code));
        -: 2223:local void build_tree     OF((tree_desc near *desc));
        -: 2224:local void scan_tree      OF((ct_data near *tree, int max_code));
        -: 2225:local void send_tree      OF((ct_data near *tree, int max_code));
        -: 2226:local int  build_bl_tree  OF((void));
        -: 2227:local void send_all_trees OF((int lcodes, int dcodes, int blcodes));
        -: 2228:local void compress_block OF((ct_data near *ltree, ct_data near *dtree));
        -: 2229:local void set_file_type  OF((void));
        -: 2230:
        -: 2231:
        -: 2232:#ifndef DEBUG
        -: 2233:#  define send_code(c, tree) send_bits(tree[c].Code, tree[c].Len)
        -: 2234:   /* Send a code of the given tree. c and tree must not have side effects */
        -: 2235:
        -: 2236:#else /* DEBUG */
        -: 2237:#  define send_code(c, tree) \
        -: 2238:     { if (verbose>1) fprintf(stderr,"\ncd %3d ",(c)); \
        -: 2239:       send_bits(tree[c].Code, tree[c].Len); }
        -: 2240:#endif
        -: 2241:
        -: 2242:#define d_code(dist) \
        -: 2243:   ((dist) < 256 ? dist_code[dist] : dist_code[256+((dist)>>7)])
        -: 2244:/* Mapping from a distance to a distance code. dist is the distance - 1 and
        -: 2245: * must not have side effects. dist_code[256] and dist_code[257] are never
        -: 2246: * used.
        -: 2247: */
        -: 2248:
        -: 2249:#define MAX(a,b) (a >= b ? a : b)
        -: 2250:/* the arguments must not have side effects */
        -: 2251:
        -: 2252:/* ===========================================================================
        -: 2253: * Allocate the match buffer, initialize the various tables and save the
        -: 2254: * location of the internal file attribute (ascii/binary) and method
        -: 2255: * (DEFLATE/STORE).
        -: 2256: */
function ct_init called 177 returned 100% blocks executed 98%
      177: 2257:void ct_init(attr, methodp)
        -: 2258:    ush  *attr;   /* pointer to internal file attribute */
        -: 2259:    int  *methodp; /* pointer to compression method */
        -: 2260:{
        -: 2261:    int n;        /* iterates over tree elements */
        -: 2262:    int bits;     /* bit counter */
        -: 2263:    int length;   /* length value */
        -: 2264:    int code;     /* code value */
        -: 2265:    int dist;     /* distance index */
        -: 2266:
      177: 2267:    file_type = attr;
      177: 2268:    file_method = methodp;
      177: 2269:    compressed_len = input_len = 0L;
        -: 2270:
     177*: 2271:    if (static_dtree[0].Len != 0) return; /* ct_init already called */
branch  0 taken 0 (fallthrough)
branch  1 taken 177
        -: 2272:
        -: 2273:    /* Initialize the mapping length (0..255) -> length code (0..28) */
      177: 2274:    length = 0;
     5133: 2275:    for (code = 0; code < LENGTH_CODES-1; code++) {
branch  0 taken 4956
branch  1 taken 177 (fallthrough)
     4956: 2276:        base_length[code] = length;
    50268: 2277:        for (n = 0; n < (1<<extra_lbits[code]); n++) {
branch  0 taken 45312
branch  1 taken 4956 (fallthrough)
    45312: 2278:            length_code[length++] = (uch)code;
        -: 2279:        }
        -: 2280:    }
        -: 2281:    Assert (length == 256, "ct_init: length != 256");
        -: 2282:    /* Note that the length 255 (match length 258) can be represented
        -: 2283:     * in two different ways: code 284 + 5 bits or code 285, so we
        -: 2284:     * overwrite length_code[255] to use the best encoding:
        -: 2285:     */
      177: 2286:    length_code[length-1] = (uch)code;
        -: 2287:
        -: 2288:    /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
      177: 2289:    dist = 0;
     3009: 2290:    for (code = 0 ; code < 16; code++) {
branch  0 taken 2832
branch  1 taken 177 (fallthrough)
     2832: 2291:        base_dist[code] = dist;
    48144: 2292:        for (n = 0; n < (1<<extra_dbits[code]); n++) {
branch  0 taken 45312
branch  1 taken 2832 (fallthrough)
    45312: 2293:            dist_code[dist++] = (uch)code;
        -: 2294:        }
        -: 2295:    }
        -: 2296:    Assert (dist == 256, "ct_init: dist != 256");
      177: 2297:    dist >>= 7; /* from now on, all distances are divided by 128 */
     2655: 2298:    for ( ; code < D_CODES; code++) {
branch  0 taken 2478
branch  1 taken 177 (fallthrough)
     2478: 2299:        base_dist[code] = dist << 7;
    47436: 2300:        for (n = 0; n < (1<<(extra_dbits[code]-7)); n++) {
branch  0 taken 44958
branch  1 taken 2478 (fallthrough)
    44958: 2301:            dist_code[256 + dist++] = (uch)code;
        -: 2302:        }
        -: 2303:    }
        -: 2304:    Assert (dist == 256, "ct_init: 256+dist != 512");
        -: 2305:
        -: 2306:    /* Construct the codes of the static literal tree */
     3009: 2307:    for (bits = 0; bits <= MAX_BITS; bits++) bl_count[bits] = 0;
branch  0 taken 2832
branch  1 taken 177 (fallthrough)
      177: 2308:    n = 0;
    25665: 2309:    while (n <= 143) static_ltree[n++].Len = 8, bl_count[8]++;
branch  0 taken 25488
branch  1 taken 177 (fallthrough)
    20001: 2310:    while (n <= 255) static_ltree[n++].Len = 9, bl_count[9]++;
branch  0 taken 19824
branch  1 taken 177 (fallthrough)
     4425: 2311:    while (n <= 279) static_ltree[n++].Len = 7, bl_count[7]++;
branch  0 taken 4248
branch  1 taken 177 (fallthrough)
     1593: 2312:    while (n <= 287) static_ltree[n++].Len = 8, bl_count[8]++;
branch  0 taken 1416
branch  1 taken 177 (fallthrough)
        -: 2313:    /* Codes 286 and 287 do not exist, but we must include them in the
        -: 2314:     * tree construction to get a canonical Huffman tree (longest code
        -: 2315:     * all ones)
        -: 2316:     */
      177: 2317:    gen_codes((ct_data near *)static_ltree, L_CODES+1);
call    0 returned 177
        -: 2318:
        -: 2319:    /* The static distance tree is trivial: */
     5487: 2320:    for (n = 0; n < D_CODES; n++) {
branch  0 taken 5310
branch  1 taken 177 (fallthrough)
     5310: 2321:        static_dtree[n].Len = 5;
     5310: 2322:        static_dtree[n].Code = bi_reverse(n, 5);
call    0 returned 5310
        -: 2323:    }
        -: 2324:
        -: 2325:    /* Initialize the first block of the first file: */
      177: 2326:    init_block();
call    0 returned 177
        -: 2327:}
        -: 2328:
        -: 2329:/* ===========================================================================
        -: 2330: * Initialize a new block.
        -: 2331: */
function init_block called 374 returned 100% blocks executed 100%
      374: 2332:local void init_block()
        -: 2333:{
        -: 2334:    int n; /* iterates over tree elements */
        -: 2335:
        -: 2336:    /* Initialize the trees. */
   107338: 2337:    for (n = 0; n < L_CODES;  n++) dyn_ltree[n].Freq = 0;
branch  0 taken 106964
branch  1 taken 374 (fallthrough)
    11594: 2338:    for (n = 0; n < D_CODES;  n++) dyn_dtree[n].Freq = 0;
branch  0 taken 11220
branch  1 taken 374 (fallthrough)
     7480: 2339:    for (n = 0; n < BL_CODES; n++) bl_tree[n].Freq = 0;
branch  0 taken 7106
branch  1 taken 374 (fallthrough)
        -: 2340:
      374: 2341:    dyn_ltree[END_BLOCK].Freq = 1;
      374: 2342:    opt_len = static_len = 0L;
      374: 2343:    last_lit = last_dist = last_flags = 0;
      374: 2344:    flags = 0; flag_bit = 1;
      374: 2345:}
        -: 2346:
        -: 2347:#define SMALLEST 1
        -: 2348:/* Index within the heap array of least frequent node in the Huffman tree */
        -: 2349:
        -: 2350:
        -: 2351:/* ===========================================================================
        -: 2352: * Remove the smallest element from the heap and recreate the heap with
        -: 2353: * one less element. Updates heap and heap_len.
        -: 2354: */
        -: 2355:#define pqremove(tree, top) \
        -: 2356:{\
        -: 2357:    top = heap[SMALLEST]; \
        -: 2358:    heap[SMALLEST] = heap[heap_len--]; \
        -: 2359:    pqdownheap(tree, SMALLEST); \
        -: 2360:}
        -: 2361:
        -: 2362:/* ===========================================================================
        -: 2363: * Compares to subtrees, using the tree depth as tie breaker when
        -: 2364: * the subtrees have equal frequency. This minimizes the worst case length.
        -: 2365: */
        -: 2366:#define smaller(tree, n, m) \
        -: 2367:   (tree[n].Freq < tree[m].Freq || \
        -: 2368:   (tree[n].Freq == tree[m].Freq && depth[n] <= depth[m]))
        -: 2369:
        -: 2370:/* ===========================================================================
        -: 2371: * Restore the heap property by moving down the tree starting at node k,
        -: 2372: * exchanging a node with the smallest of its two sons if necessary, stopping
        -: 2373: * when the heap property is re-established (each father smaller than its
        -: 2374: * two sons).
        -: 2375: */
function pqdownheap called 71982 returned 100% blocks executed 100%
    71982: 2376:local void pqdownheap(tree, k)
        -: 2377:    ct_data near *tree;  /* the tree to restore */
        -: 2378:    int k;               /* node to move down */
        -: 2379:{
    71982: 2380:    int v = heap[k];
    71982: 2381:    int j = k << 1;  /* left son of k */
   296265: 2382:    while (j <= heap_len) {
branch  0 taken 249059
branch  1 taken 47206 (fallthrough)
        -: 2383:        /* Set j to the smallest of the two sons: */
   249059: 2384:        if (j < heap_len && smaller(tree, heap[j+1], heap[j])) j++;
branch  0 taken 243856 (fallthrough)
branch  1 taken 5203
branch  2 taken 146251 (fallthrough)
branch  3 taken 97605
branch  4 taken 32806 (fallthrough)
branch  5 taken 113445
branch  6 taken 22726 (fallthrough)
branch  7 taken 10080
        -: 2385:
        -: 2386:        /* Exit if v is smaller than both sons */
   249059: 2387:        if (smaller(tree, v, heap[j])) break;
branch  0 taken 226248 (fallthrough)
branch  1 taken 22811
branch  2 taken 4906 (fallthrough)
branch  3 taken 221342
branch  4 taken 2941 (fallthrough)
branch  5 taken 1965
        -: 2388:
        -: 2389:        /* Exchange v with the smallest son */
   224283: 2390:        heap[k] = heap[j];  k = j;
        -: 2391:
        -: 2392:        /* And continue down the tree, setting j to the left son of k */
   224283: 2393:        j <<= 1;
        -: 2394:    }
    71982: 2395:    heap[k] = v;
    71982: 2396:}
        -: 2397:
        -: 2398:/* ===========================================================================
        -: 2399: * Compute the optimal bit lengths for a tree and update the total bit length
        -: 2400: * for the current block.
        -: 2401: * IN assertion: the fields freq and dad are set, heap[heap_max] and
        -: 2402: *    above are the tree nodes sorted by increasing frequency.
        -: 2403: * OUT assertions: the field len is set to the optimal bit length, the
        -: 2404: *     array bl_count contains the frequencies for each bit length.
        -: 2405: *     The length opt_len is updated; static_len is also updated if stree is
        -: 2406: *     not null.
        -: 2407: */
function gen_bitlen called 591 returned 100% blocks executed 97%
      591: 2408:local void gen_bitlen(desc)
        -: 2409:    tree_desc near *desc; /* the tree descriptor */
        -: 2410:{
      591: 2411:    ct_data near *tree  = desc->dyn_tree;
      591: 2412:    int near *extra     = desc->extra_bits;
      591: 2413:    int base            = desc->extra_base;
      591: 2414:    int max_code        = desc->max_code;
      591: 2415:    int max_length      = desc->max_length;
      591: 2416:    ct_data near *stree = desc->static_tree;
        -: 2417:    int h;              /* heap index */
        -: 2418:    int n, m;           /* iterate over the tree elements */
        -: 2419:    int bits;           /* bit length */
        -: 2420:    int xbits;          /* extra bits */
        -: 2421:    ush f;              /* frequency */
      591: 2422:    int overflow = 0;   /* number of elements with bit length too large */
        -: 2423:
    10047: 2424:    for (bits = 0; bits <= MAX_BITS; bits++) bl_count[bits] = 0;
branch  0 taken 9456
branch  1 taken 591 (fallthrough)
        -: 2425:
        -: 2426:    /* In a first pass, compute the optimal bit lengths (which may
        -: 2427:     * overflow in the case of the bit length tree).
        -: 2428:     */
      591: 2429:    tree[heap[heap_max]].Len = 0; /* root of the heap */
        -: 2430:
    58055: 2431:    for (h = heap_max+1; h < HEAP_SIZE; h++) {
branch  0 taken 57464
branch  1 taken 591 (fallthrough)
    57464: 2432:        n = heap[h];
    57464: 2433:        bits = tree[tree[n].Dad].Len + 1;
    57464: 2434:        if (bits > max_length) bits = max_length, overflow++;
branch  0 taken 6 (fallthrough)
branch  1 taken 57458
    57464: 2435:        tree[n].Len = (ush)bits;
        -: 2436:        /* We overwrite tree[n].Dad which is no longer needed */
        -: 2437:
    57464: 2438:        if (n > max_code) continue; /* not a leaf node */
branch  0 taken 28141 (fallthrough)
branch  1 taken 29323
        -: 2439:
    29323: 2440:        bl_count[bits]++;
    29323: 2441:        xbits = 0;
    29323: 2442:        if (n >= base) xbits = extra[n-base];
branch  0 taken 11452 (fallthrough)
branch  1 taken 17871
    29323: 2443:        f = tree[n].Freq;
    29323: 2444:        opt_len += (ulg)f * (bits + xbits);
    29323: 2445:        if (stree) static_len += (ulg)f * (stree[n].Len + xbits);
branch  0 taken 26688 (fallthrough)
branch  1 taken 2635
        -: 2446:    }
      591: 2447:    if (overflow == 0) return;
branch  0 taken 588 (fallthrough)
branch  1 taken 3
        -: 2448:
        -: 2449:    Trace((stderr,"\nbit length overflow\n"));
        -: 2450:    /* This happens for example on obj2 and pic of the Calgary corpus */
        -: 2451:
        -: 2452:    /* Find the first bit length which could increase: */
        -: 2453:    do {
        3: 2454:        bits = max_length-1;
       3*: 2455:        while (bl_count[bits] == 0) bits--;
branch  0 taken 0
branch  1 taken 3 (fallthrough)
        3: 2456:        bl_count[bits]--;      /* move one leaf down the tree */
        3: 2457:        bl_count[bits+1] += 2; /* move one overflow item as its brother */
        3: 2458:        bl_count[max_length]--;
        -: 2459:        /* The brother of the overflow item also moves one step up,
        -: 2460:         * but this does not affect bl_count[max_length]
        -: 2461:         */
        3: 2462:        overflow -= 2;
        3: 2463:    } while (overflow > 0);
branch  0 taken 0
branch  1 taken 3 (fallthrough)
        -: 2464:
        -: 2465:    /* Now recompute all bit lengths, scanning in increasing frequency.
        -: 2466:     * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
        -: 2467:     * lengths instead of fixing only the wrong ones. This idea is taken
        -: 2468:     * from 'ar' written by Haruhiko Okumura.)
        -: 2469:     */
       24: 2470:    for (bits = max_length; bits != 0; bits--) {
branch  0 taken 21
branch  1 taken 3 (fallthrough)
       21: 2471:        n = bl_count[bits];
       84: 2472:        while (n != 0) {
branch  0 taken 63
branch  1 taken 21 (fallthrough)
       63: 2473:            m = heap[--h];
       63: 2474:            if (m > max_code) continue;
branch  0 taken 24 (fallthrough)
branch  1 taken 39
       39: 2475:            if (tree[m].Len != (unsigned) bits) {
branch  0 taken 3 (fallthrough)
branch  1 taken 36
        -: 2476:                Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
        3: 2477:                opt_len += ((long)bits-(long)tree[m].Len)*(long)tree[m].Freq;
        3: 2478:                tree[m].Len = (ush)bits;
        -: 2479:            }
       39: 2480:            n--;
        -: 2481:        }
        -: 2482:    }
        -: 2483:}
        -: 2484:
        -: 2485:/* ===========================================================================
        -: 2486: * Generate the codes for a given tree and bit counts (which need not be
        -: 2487: * optimal).
        -: 2488: * IN assertion: the array bl_count contains the bit length statistics for
        -: 2489: * the given tree and the field len is set for all tree elements.
        -: 2490: * OUT assertion: the field code is set for all tree elements of non
        -: 2491: *     zero code length.
        -: 2492: */
function gen_codes called 768 returned 100% blocks executed 100%
      768: 2493:local void gen_codes (tree, max_code)
        -: 2494:    ct_data near *tree;        /* the tree to decorate */
        -: 2495:    int max_code;              /* largest code with non zero frequency */
        -: 2496:{
        -: 2497:    ush next_code[MAX_BITS+1]; /* next code value for each bit length */
      768: 2498:    ush code = 0;              /* running code value */
        -: 2499:    int bits;                  /* bit index */
        -: 2500:    int n;                     /* code index */
        -: 2501:
        -: 2502:    /* The distribution counts are first used to generate the code values
        -: 2503:     * without bit reversal.
        -: 2504:     */
    12288: 2505:    for (bits = 1; bits <= MAX_BITS; bits++) {
branch  0 taken 11520
branch  1 taken 768 (fallthrough)
    11520: 2506:        next_code[bits] = code = (code + bl_count[bits-1]) << 1;
        -: 2507:    }
        -: 2508:    /* Check that the bit counts in bl_count are consistent. The last code
        -: 2509:     * must be all ones.
        -: 2510:     */
        -: 2511:    Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
        -: 2512:            "inconsistent bit counts");
        -: 2513:    Tracev((stderr,"\ngen_codes: max_code %d ", max_code));
        -: 2514:
   117030: 2515:    for (n = 0;  n <= max_code; n++) {
branch  0 taken 116262
branch  1 taken 768 (fallthrough)
   116262: 2516:        int len = tree[n].Len;
   116262: 2517:        if (len == 0) continue;
branch  0 taken 35963 (fallthrough)
branch  1 taken 80299
        -: 2518:        /* Now reverse the bits */
    80299: 2519:        tree[n].Code = bi_reverse(next_code[len]++, len);
call    0 returned 80299
        -: 2520:
        -: 2521:        Tracec(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
        -: 2522:             n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
        -: 2523:    }
      768: 2524:}
        -: 2525:
        -: 2526:/* ===========================================================================
        -: 2527: * Construct one Huffman tree and assigns the code bit strings and lengths.
        -: 2528: * Update the total bit length for the current block.
        -: 2529: * IN assertion: the field freq is set for all tree elements.
        -: 2530: * OUT assertions: the fields len and code are set to the optimal bit length
        -: 2531: *     and corresponding code. The length opt_len is updated; static_len is
        -: 2532: *     also updated if stree is not null. The field max_code is set.
        -: 2533: */
function build_tree called 591 returned 100% blocks executed 100%
      591: 2534:local void build_tree(desc)
        -: 2535:    tree_desc near *desc; /* the tree descriptor */
        -: 2536:{
      591: 2537:    ct_data near *tree   = desc->dyn_tree;
      591: 2538:    ct_data near *stree  = desc->static_tree;
      591: 2539:    int elems            = desc->elems;
        -: 2540:    int n, m;          /* iterate over heap elements */
      591: 2541:    int max_code = -1; /* largest code with non zero frequency */
      591: 2542:    int node = elems;  /* next internal node of the tree */
        -: 2543:
        -: 2544:    /* Construct the initial heap, with least frequent element in
        -: 2545:     * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
        -: 2546:     * heap[0] is not used.
        -: 2547:     */
      591: 2548:    heap_len = 0, heap_max = HEAP_SIZE;
        -: 2549:
    66586: 2550:    for (n = 0; n < elems; n++) {
branch  0 taken 65995
branch  1 taken 591 (fallthrough)
    65995: 2551:        if (tree[n].Freq != 0) {
branch  0 taken 29297 (fallthrough)
branch  1 taken 36698
    29297: 2552:            heap[++heap_len] = max_code = n;
    29297: 2553:            depth[n] = 0;
        -: 2554:        } else {
    36698: 2555:            tree[n].Len = 0;
        -: 2556:        }
        -: 2557:    }
        -: 2558:
        -: 2559:    /* The pkzip format requires that at least one distance code exists,
        -: 2560:     * and that at least one bit should be sent even if there is only one
        -: 2561:     * possible code. So to avoid special checks later on we force at least
        -: 2562:     * two codes of non zero frequency.
        -: 2563:     */
      617: 2564:    while (heap_len < 2) {
branch  0 taken 26
branch  1 taken 591 (fallthrough)
       26: 2565:        int new = heap[++heap_len] = (max_code < 2 ? ++max_code : 0);
branch  0 taken 22 (fallthrough)
branch  1 taken 4
       26: 2566:        tree[new].Freq = 1;
       26: 2567:        depth[new] = 0;
       26: 2568:        opt_len--; if (stree) static_len -= stree[new].Len;
branch  0 taken 26 (fallthrough)
branch  1 taken 0
        -: 2569:        /* new is 0 or 1 so it does not have extra bits */
        -: 2570:    }
      591: 2571:    desc->max_code = max_code;
        -: 2572:
        -: 2573:    /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
        -: 2574:     * establish sub-heaps of increasing lengths:
        -: 2575:     */
    15109: 2576:    for (n = heap_len/2; n >= 1; n--) pqdownheap(tree, n);
call    0 returned 14518
branch  1 taken 14518
branch  2 taken 591 (fallthrough)
        -: 2577:
        -: 2578:    /* Construct the Huffman tree by repeatedly combining the least two
        -: 2579:     * frequent nodes.
        -: 2580:     */
        -: 2581:    do {
    28732: 2582:        pqremove(tree, n);   /* n = node of least frequency */
call    0 returned 28732
    28732: 2583:        m = heap[SMALLEST];  /* m = node of next least frequency */
        -: 2584:
    28732: 2585:        heap[--heap_max] = n; /* keep the nodes sorted by frequency */
    28732: 2586:        heap[--heap_max] = m;
        -: 2587:
        -: 2588:        /* Create a new node father of n and m */
    28732: 2589:        tree[node].Freq = tree[n].Freq + tree[m].Freq;
    28732: 2590:        depth[node] = (uch) (MAX(depth[n], depth[m]) + 1);
branch  0 taken 19166 (fallthrough)
branch  1 taken 9566
    28732: 2591:        tree[n].Dad = tree[m].Dad = (ush)node;
        -: 2592:#ifdef DUMP_BL_TREE
        -: 2593:        if (tree == bl_tree) {
        -: 2594:            fprintf(stderr,"\nnode %d(%d), sons %d(%d) %d(%d)",
        -: 2595:                    node, tree[node].Freq, n, tree[n].Freq, m, tree[m].Freq);
        -: 2596:        }
        -: 2597:#endif
        -: 2598:        /* and insert the new node in the heap */
    28732: 2599:        heap[SMALLEST] = node++;
    28732: 2600:        pqdownheap(tree, SMALLEST);
call    0 returned 28732
        -: 2601:
    28732: 2602:    } while (heap_len >= 2);
branch  0 taken 28141
branch  1 taken 591 (fallthrough)
        -: 2603:
      591: 2604:    heap[--heap_max] = heap[SMALLEST];
        -: 2605:
        -: 2606:    /* At this point, the fields freq and dad are set. We can now
        -: 2607:     * generate the bit lengths.
        -: 2608:     */
      591: 2609:    gen_bitlen((tree_desc near *)desc);
call    0 returned 591
        -: 2610:
        -: 2611:    /* The field len is now set, we can generate the bit codes */
      591: 2612:    gen_codes ((ct_data near *)tree, max_code);
call    0 returned 591
      591: 2613:}
        -: 2614:
        -: 2615:/* ===========================================================================
        -: 2616: * Scan a literal or distance tree to determine the frequencies of the codes
        -: 2617: * in the bit length tree. Updates opt_len to take into account the repeat
        -: 2618: * counts. (The contribution of the bit length codes will be added later
        -: 2619: * during the construction of bl_tree.)
        -: 2620: */
function scan_tree called 394 returned 100% blocks executed 100%
      394: 2621:local void scan_tree (tree, max_code)
        -: 2622:    ct_data near *tree; /* the tree to be scanned */
        -: 2623:    int max_code;       /* and its largest code of non zero frequency */
        -: 2624:{
        -: 2625:    int n;                     /* iterates over all tree elements */
      394: 2626:    int prevlen = -1;          /* last emitted length */
        -: 2627:    int curlen;                /* length of current code */
      394: 2628:    int nextlen = tree[0].Len; /* length of next code */
      394: 2629:    int count = 0;             /* repeat count of the current code */
      394: 2630:    int max_count = 7;         /* max repeat count */
      394: 2631:    int min_count = 4;         /* min repeat count */
        -: 2632:
      394: 2633:    if (nextlen == 0) max_count = 138, min_count = 3;
branch  0 taken 182 (fallthrough)
branch  1 taken 212
      394: 2634:    tree[max_code+1].Len = (ush)0xffff; /* guard */
        -: 2635:
    61950: 2636:    for (n = 0; n <= max_code; n++) {
branch  0 taken 61556
branch  1 taken 394 (fallthrough)
    61556: 2637:        curlen = nextlen; nextlen = tree[n+1].Len;
    61556: 2638:        if (++count < max_count && curlen == nextlen) {
branch  0 taken 61323 (fallthrough)
branch  1 taken 233
branch  2 taken 41047 (fallthrough)
branch  3 taken 20276
    41047: 2639:            continue;
    20509: 2640:        } else if (count < min_count) {
branch  0 taken 18874 (fallthrough)
branch  1 taken 1635
    18874: 2641:            bl_tree[curlen].Freq += count;
     1635: 2642:        } else if (curlen != 0) {
branch  0 taken 734 (fallthrough)
branch  1 taken 901
      734: 2643:            if (curlen != prevlen) bl_tree[curlen].Freq++;
branch  0 taken 662 (fallthrough)
branch  1 taken 72
      734: 2644:            bl_tree[REP_3_6].Freq++;
      901: 2645:        } else if (count <= 10) {
branch  0 taken 510 (fallthrough)
branch  1 taken 391
      510: 2646:            bl_tree[REPZ_3_10].Freq++;
        -: 2647:        } else {
      391: 2648:            bl_tree[REPZ_11_138].Freq++;
        -: 2649:        }
    20509: 2650:        count = 0; prevlen = curlen;
    20509: 2651:        if (nextlen == 0) {
branch  0 taken 2169 (fallthrough)
branch  1 taken 18340
     2169: 2652:            max_count = 138, min_count = 3;
    18340: 2653:        } else if (curlen == nextlen) {
branch  0 taken 211 (fallthrough)
branch  1 taken 18129
      211: 2654:            max_count = 6, min_count = 3;
        -: 2655:        } else {
    18129: 2656:            max_count = 7, min_count = 4;
        -: 2657:        }
        -: 2658:    }
      394: 2659:}
        -: 2660:
        -: 2661:/* ===========================================================================
        -: 2662: * Send a literal or distance tree in compressed form, using the codes in
        -: 2663: * bl_tree.
        -: 2664: */
function send_tree called 382 returned 100% blocks executed 100%
      382: 2665:local void send_tree (tree, max_code)
        -: 2666:    ct_data near *tree; /* the tree to be scanned */
        -: 2667:    int max_code;       /* and its largest code of non zero frequency */
        -: 2668:{
        -: 2669:    int n;                     /* iterates over all tree elements */
      382: 2670:    int prevlen = -1;          /* last emitted length */
        -: 2671:    int curlen;                /* length of current code */
      382: 2672:    int nextlen = tree[0].Len; /* length of next code */
      382: 2673:    int count = 0;             /* repeat count of the current code */
      382: 2674:    int max_count = 7;         /* max repeat count */
      382: 2675:    int min_count = 4;         /* min repeat count */
        -: 2676:
        -: 2677:    /* tree[max_code+1].Len = -1; */  /* guard already set */
      382: 2678:    if (nextlen == 0) max_count = 138, min_count = 3;
branch  0 taken 182 (fallthrough)
branch  1 taken 200
        -: 2679:
    60334: 2680:    for (n = 0; n <= max_code; n++) {
branch  0 taken 59952
branch  1 taken 382 (fallthrough)
    59952: 2681:        curlen = nextlen; nextlen = tree[n+1].Len;
    59952: 2682:        if (++count < max_count && curlen == nextlen) {
branch  0 taken 59759 (fallthrough)
branch  1 taken 193
branch  2 taken 39528 (fallthrough)
branch  3 taken 20231
    39528: 2683:            continue;
    20424: 2684:        } else if (count < min_count) {
branch  0 taken 18842 (fallthrough)
branch  1 taken 1582
    24421: 2685:            do { send_code(curlen, bl_tree); } while (--count != 0);
call    0 returned 24421
branch  1 taken 5579
branch  2 taken 18842
        -: 2686:
     1582: 2687:        } else if (curlen != 0) {
branch  0 taken 693 (fallthrough)
branch  1 taken 889
      693: 2688:            if (curlen != prevlen) {
branch  0 taken 654 (fallthrough)
branch  1 taken 39
      654: 2689:                send_code(curlen, bl_tree); count--;
call    0 returned 654
        -: 2690:            }
        -: 2691:            Assert(count >= 3 && count <= 6, " 3_6?");
      693: 2692:            send_code(REP_3_6, bl_tree); send_bits(count-3, 2);
call    0 returned 693
call    1 returned 693
        -: 2693:
      889: 2694:        } else if (count <= 10) {
branch  0 taken 510 (fallthrough)
branch  1 taken 379
      510: 2695:            send_code(REPZ_3_10, bl_tree); send_bits(count-3, 3);
call    0 returned 510
call    1 returned 510
        -: 2696:
        -: 2697:        } else {
      379: 2698:            send_code(REPZ_11_138, bl_tree); send_bits(count-11, 7);
call    0 returned 379
call    1 returned 379
        -: 2699:        }
    20424: 2700:        count = 0; prevlen = curlen;
    20424: 2701:        if (nextlen == 0) {
branch  0 taken 2157 (fallthrough)
branch  1 taken 18267
     2157: 2702:            max_count = 138, min_count = 3;
    18267: 2703:        } else if (curlen == nextlen) {
branch  0 taken 177 (fallthrough)
branch  1 taken 18090
      177: 2704:            max_count = 6, min_count = 3;
        -: 2705:        } else {
    18090: 2706:            max_count = 7, min_count = 4;
        -: 2707:        }
        -: 2708:    }
      382: 2709:}
        -: 2710:
        -: 2711:/* ===========================================================================
        -: 2712: * Construct the Huffman tree for the bit lengths and return the index in
        -: 2713: * bl_order of the last bit length code to send.
        -: 2714: */
function build_bl_tree called 197 returned 100% blocks executed 100%
      197: 2715:local int build_bl_tree()
        -: 2716:{
        -: 2717:    int max_blindex;  /* index of last bit length code of non zero freq */
        -: 2718:
        -: 2719:    /* Determine the bit length frequencies for literal and distance trees */
      197: 2720:    scan_tree((ct_data near *)dyn_ltree, l_desc.max_code);
call    0 returned 197
      197: 2721:    scan_tree((ct_data near *)dyn_dtree, d_desc.max_code);
call    0 returned 197
        -: 2722:
        -: 2723:    /* Build the bit length tree: */
      197: 2724:    build_tree((tree_desc near *)(&bl_desc));
call    0 returned 197
        -: 2725:    /* opt_len now includes the length of the tree representations, except
        -: 2726:     * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
        -: 2727:     */
        -: 2728:
        -: 2729:    /* Determine the number of bit length codes to send. The pkzip format
        -: 2730:     * requires that at least 4 bit length codes be sent. (appnote.txt says
        -: 2731:     * 3 but the actual value used is 4.)
        -: 2732:     */
      927: 2733:    for (max_blindex = BL_CODES-1; max_blindex >= 3; max_blindex--) {
branch  0 taken 927
branch  1 taken 0 (fallthrough)
      927: 2734:        if (bl_tree[bl_order[max_blindex]].Len != 0) break;
branch  0 taken 197 (fallthrough)
branch  1 taken 730
        -: 2735:    }
        -: 2736:    /* Update opt_len to include the bit length tree and counts */
      197: 2737:    opt_len += 3*(max_blindex+1) + 5+5+4;
        -: 2738:    Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld", opt_len, static_len));
        -: 2739:
      197: 2740:    return max_blindex;
        -: 2741:}
        -: 2742:
        -: 2743:/* ===========================================================================
        -: 2744: * Send the header for a block using dynamic Huffman trees: the counts, the
        -: 2745: * lengths of the bit length codes, the literal tree and the distance tree.
        -: 2746: * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
        -: 2747: */
function send_all_trees called 191 returned 100% blocks executed 100%
      191: 2748:local void send_all_trees(lcodes, dcodes, blcodes)
        -: 2749:    int lcodes, dcodes, blcodes; /* number of codes for each tree */
        -: 2750:{
        -: 2751:    int rank;                    /* index in bl_order */
        -: 2752:
        -: 2753:    Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
        -: 2754:    Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
        -: 2755:            "too many codes");
        -: 2756:    Tracev((stderr, "\nbl counts: "));
      191: 2757:    send_bits(lcodes-257, 5); /* not +255 as stated in appnote.txt */
call    0 returned 191
      191: 2758:    send_bits(dcodes-1,   5);
call    0 returned 191
      191: 2759:    send_bits(blcodes-4,  4); /* not -3 as stated in appnote.txt */
call    0 returned 191
     3096: 2760:    for (rank = 0; rank < blcodes; rank++) {
branch  0 taken 2905
branch  1 taken 191 (fallthrough)
        -: 2761:        Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
     2905: 2762:        send_bits(bl_tree[bl_order[rank]].Len, 3);
call    0 returned 2905
        -: 2763:    }
        -: 2764:    Tracev((stderr, "\nbl tree: sent %ld", bits_sent));
        -: 2765:
      191: 2766:    send_tree((ct_data near *)dyn_ltree, lcodes-1); /* send the literal tree */
call    0 returned 191
        -: 2767:    Tracev((stderr, "\nlit tree: sent %ld", bits_sent));
        -: 2768:
      191: 2769:    send_tree((ct_data near *)dyn_dtree, dcodes-1); /* send the distance tree */
call    0 returned 191
        -: 2770:    Tracev((stderr, "\ndist tree: sent %ld", bits_sent));
      191: 2771:}
        -: 2772:
        -: 2773:/* ===========================================================================
        -: 2774: * Determine the best encoding for the current block: dynamic trees, static
        -: 2775: * trees or store, and output the encoded block to the zip file. This function
        -: 2776: * returns the total compressed length for the file so far.
        -: 2777: */
function flush_block called 197 returned 100% blocks executed 96%
      197: 2778:ulg flush_block(buf, stored_len, eof)
        -: 2779:    char *buf;        /* input block, or NULL if too old */
        -: 2780:    ulg stored_len;   /* length of input block */
        -: 2781:    int eof;          /* true if this is the last block for a file */
        -: 2782:{
        -: 2783:    ulg opt_lenb, static_lenb; /* opt_len and static_len in bytes */
        -: 2784:    int max_blindex;  /* index of last bit length code of non zero freq */
        -: 2785:
      197: 2786:    flag_buf[last_flags] = flags; /* Save the flags for the last 8 items */
        -: 2787:
        -: 2788:     /* Check if the file is ascii or binary */
     197*: 2789:    if (*file_type == (ush)UNKNOWN) set_file_type();
branch  0 taken 0 (fallthrough)
branch  1 taken 197
call    2 never executed
        -: 2790:
        -: 2791:    /* Construct the literal and distance trees */
      197: 2792:    build_tree((tree_desc near *)(&l_desc));
call    0 returned 197
        -: 2793:    Tracev((stderr, "\nlit data: dyn %ld, stat %ld", opt_len, static_len));
        -: 2794:
      197: 2795:    build_tree((tree_desc near *)(&d_desc));
call    0 returned 197
        -: 2796:    Tracev((stderr, "\ndist data: dyn %ld, stat %ld", opt_len, static_len));
        -: 2797:    /* At this point, opt_len and static_len are the total bit lengths of
        -: 2798:     * the compressed block data, excluding the tree representations.
        -: 2799:     */
        -: 2800:
        -: 2801:    /* Build the bit length tree for the above two trees, and get the index
        -: 2802:     * in bl_order of the last bit length code to send.
        -: 2803:     */
      197: 2804:    max_blindex = build_bl_tree();
call    0 returned 197
        -: 2805:
        -: 2806:    /* Determine the best encoding. Compute first the block length in bytes */
      197: 2807:    opt_lenb = (opt_len+3+7)>>3;
      197: 2808:    static_lenb = (static_len+3+7)>>3;
      197: 2809:    input_len += stored_len; /* for debugging only */
        -: 2810:
        -: 2811:    Trace((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u dist %u ",
        -: 2812:            opt_lenb, opt_len, static_lenb, static_len, stored_len,
        -: 2813:            last_lit, last_dist));
        -: 2814:
      197: 2815:    if (static_lenb <= opt_lenb) opt_lenb = static_lenb;
branch  0 taken 5 (fallthrough)
branch  1 taken 192
        -: 2816:
        -: 2817:    /* If compression failed and this is the first and last block,
        -: 2818:     * and if the zip file can be seeked (to rewrite the local header),
        -: 2819:     * the whole file is transformed into a stored file:
        -: 2820:     */
        -: 2821:#ifdef FORCE_METHOD
        -: 2822:    if (level == 1 && eof && compressed_len == 0L) { /* force stored file */
        -: 2823:#else
        -: 2824:    if (stored_len <= opt_lenb && eof && compressed_len == 0L && seekable()) {
        -: 2825:#endif
        -: 2826:        /* Since LIT_BUFSIZE <= 2*WSIZE, the input data must be there: */
        -: 2827:        if (buf == (char*)0) error ("block vanished");
        -: 2828:
        -: 2829:        copy_block(buf, (unsigned)stored_len, 0); /* without header */
        -: 2830:        compressed_len = stored_len << 3;
        -: 2831:        *file_method = STORED;
        -: 2832:
        -: 2833:#ifdef FORCE_METHOD
        -: 2834:    } else if (level == 2 && buf != (char*)0) { /* force stored block */
        -: 2835:#else
      197: 2836:    } else if (stored_len+4 <= opt_lenb && buf != (char*)0) {
branch  0 taken 1 (fallthrough)
branch  1 taken 196
branch  2 taken 1 (fallthrough)
branch  3 taken 0
        -: 2837:                       /* 4: two words for the lengths */
        -: 2838:#endif
        -: 2839:        /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
        -: 2840:         * Otherwise we can't have processed more than WSIZE input bytes since
        -: 2841:         * the last block flush, because compression would have been
        -: 2842:         * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
        -: 2843:         * transform a block into a stored block.
        -: 2844:         */
        1: 2845:        send_bits((STORED_BLOCK<<1)+eof, 3);  /* send block type */
call    0 returned 1
        1: 2846:        compressed_len = (compressed_len + 3 + 7) & ~7L;
        1: 2847:        compressed_len += (stored_len + 4) << 3;
        -: 2848:
        1: 2849:        copy_block(buf, (unsigned)stored_len, 1); /* with header */
call    0 returned 1
        -: 2850:
        -: 2851:#ifdef FORCE_METHOD
        -: 2852:    } else if (level == 3) { /* force static trees */
        -: 2853:#else
      196: 2854:    } else if (static_lenb == opt_lenb) {
branch  0 taken 5 (fallthrough)
branch  1 taken 191
        -: 2855:#endif
        5: 2856:        send_bits((STATIC_TREES<<1)+eof, 3);
call    0 returned 5
        5: 2857:        compress_block((ct_data near *)static_ltree, (ct_data near *)static_dtree);
call    0 returned 5
        5: 2858:        compressed_len += 3 + static_len;
        -: 2859:    } else {
      191: 2860:        send_bits((DYN_TREES<<1)+eof, 3);
call    0 returned 191
      191: 2861:        send_all_trees(l_desc.max_code+1, d_desc.max_code+1, max_blindex+1);
call    0 returned 191
      191: 2862:        compress_block((ct_data near *)dyn_ltree, (ct_data near *)dyn_dtree);
call    0 returned 191
      191: 2863:        compressed_len += 3 + opt_len;
        -: 2864:    }
        -: 2865:    Assert (compressed_len == bits_sent, "bad compressed size");
      197: 2866:    init_block();
call    0 returned 197
        -: 2867:
      197: 2868:    if (eof) {
branch  0 taken 177 (fallthrough)
branch  1 taken 20
        -: 2869:        Assert (input_len == isize, "bad input size");
      177: 2870:        bi_windup();
call    0 returned 177
      177: 2871:        compressed_len += 7;  /* align on byte boundary */
        -: 2872:    }
        -: 2873:    Tracev((stderr,"\ncomprlen %lu(%lu) ", compressed_len>>3,
        -: 2874:           compressed_len-7*eof));
        -: 2875:
      197: 2876:    return compressed_len >> 3;
        -: 2877:}
        -: 2878:
        -: 2879:/* ===========================================================================
        -: 2880: * Save the match info and tally the frequency counts. Return true if
        -: 2881: * the current block must be flushed.
        -: 2882: */
function ct_tally called 1794676 returned 100% blocks executed 100%
  1794676: 2883:int ct_tally (dist, lc)
        -: 2884:    int dist;  /* distance of matched string */
        -: 2885:    int lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
        -: 2886:{
  1794676: 2887:    l_buf[last_lit++] = (uch)lc;
  1794676: 2888:    if (dist == 0) {
branch  0 taken 612397 (fallthrough)
branch  1 taken 1182279
        -: 2889:        /* lc is the unmatched char */
   612397: 2890:        dyn_ltree[lc].Freq++;
        -: 2891:    } else {
        -: 2892:        /* Here, lc is the match length - MIN_MATCH */
  1182279: 2893:        dist--;             /* dist = match distance - 1 */
        -: 2894:        Assert((ush)dist < (ush)MAX_DIST &&
        -: 2895:               (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
        -: 2896:               (ush)d_code(dist) < (ush)D_CODES,  "ct_tally: bad match");
        -: 2897:
  1182279: 2898:        dyn_ltree[length_code[lc]+LITERALS+1].Freq++;
  1182279: 2899:        dyn_dtree[d_code(dist)].Freq++;
branch  0 taken 599615 (fallthrough)
branch  1 taken 582664
        -: 2900:
  1182279: 2901:        d_buf[last_dist++] = (ush)dist;
  1182279: 2902:        flags |= flag_bit;
        -: 2903:    }
  1794676: 2904:    flag_bit <<= 1;
        -: 2905:
        -: 2906:    /* Output the flags if they fill a byte: */
  1794676: 2907:    if ((last_lit & 7) == 0) {
branch  0 taken 224266 (fallthrough)
branch  1 taken 1570410
   224266: 2908:        flag_buf[last_flags++] = flags;
   224266: 2909:        flags = 0, flag_bit = 1;
        -: 2910:    }
        -: 2911:    /* Try to guess if it is profitable to stop the current block here */
  1794676: 2912:    if (level > 2 && (last_lit & 0xfff) == 0) {
branch  0 taken 1544017 (fallthrough)
branch  1 taken 250659
branch  2 taken 252 (fallthrough)
branch  3 taken 1543765
        -: 2913:        /* Compute an upper bound for the compressed length */
      252: 2914:        ulg out_length = (ulg)last_lit*8L;
      252: 2915:        ulg in_length = (ulg)strstart-block_start;
        -: 2916:        int dcode;
     7812: 2917:        for (dcode = 0; dcode < D_CODES; dcode++) {
branch  0 taken 7560
branch  1 taken 252 (fallthrough)
     7560: 2918:            out_length += (ulg)dyn_dtree[dcode].Freq*(5L+extra_dbits[dcode]);
        -: 2919:        }
      252: 2920:        out_length >>= 3;
        -: 2921:        Trace((stderr,"\nlast_lit %u, last_dist %u, in %ld, out ~%ld(%ld%%) ",
        -: 2922:               last_lit, last_dist, in_length, out_length,
        -: 2923:               100L - out_length*100L/in_length));
      252: 2924:        if (last_dist < last_lit/2 && out_length < in_length/2) return 1;
branch  0 taken 11 (fallthrough)
branch  1 taken 241
branch  2 taken 6 (fallthrough)
branch  3 taken 5
        -: 2925:    }
  1794670: 2926:    return (last_lit == LIT_BUFSIZE-1 || last_dist == DIST_BUFSIZE);
branch  0 taken 1794656 (fallthrough)
branch  1 taken 14
branch  2 taken 0 (fallthrough)
branch  3 taken 1794656
        -: 2927:    /* We avoid equality with LIT_BUFSIZE because of wraparound at 64K
        -: 2928:     * on 16 bit machines and because stored blocks are restricted to
        -: 2929:     * 64K-1 bytes.
        -: 2930:     */
        -: 2931:}
        -: 2932:
        -: 2933:/* ===========================================================================
        -: 2934: * Send the block data compressed using the given Huffman trees
        -: 2935: */
function compress_block called 196 returned 100% blocks executed 100%
      196: 2936:local void compress_block(ltree, dtree)
        -: 2937:    ct_data near *ltree; /* literal tree */
        -: 2938:    ct_data near *dtree; /* distance tree */
        -: 2939:{
        -: 2940:    unsigned dist;      /* distance of matched string */
        -: 2941:    int lc;             /* match length or unmatched char (if dist == 0) */
      196: 2942:    unsigned lx = 0;    /* running index in l_buf */
      196: 2943:    unsigned dx = 0;    /* running index in d_buf */
      196: 2944:    unsigned fx = 0;    /* running index in flag_buf */
      196: 2945:    uch flag = 0;       /* current flags */
        -: 2946:    unsigned code;      /* the code to send */
        -: 2947:    int extra;          /* number of extra bits to send */
        -: 2948:
      196: 2949:    if (last_lit != 0) do {
branch  0 taken 192 (fallthrough)
branch  1 taken 4
  1782638: 2950:        if ((lx & 7) == 0) flag = flag_buf[fx++];
branch  0 taken 222915 (fallthrough)
branch  1 taken 1559723
  1782638: 2951:        lc = l_buf[lx++];
  1782638: 2952:        if ((flag & 1) == 0) {
branch  0 taken 600363 (fallthrough)
branch  1 taken 1182275
   600363: 2953:            send_code(lc, ltree); /* send a literal byte */
call    0 returned 600363
        -: 2954:            Tracecv(isgraph(lc), (stderr," '%c' ", lc));
        -: 2955:        } else {
        -: 2956:            /* Here, lc is the match length - MIN_MATCH */
  1182275: 2957:            code = length_code[lc];
  1182275: 2958:            send_code(code+LITERALS+1, ltree); /* send the length code */
call    0 returned 1182275
  1182275: 2959:            extra = extra_lbits[code];
  1182275: 2960:            if (extra != 0) {
branch  0 taken 127882 (fallthrough)
branch  1 taken 1054393
   127882: 2961:                lc -= base_length[code];
   127882: 2962:                send_bits(lc, extra);        /* send the extra length bits */
call    0 returned 127882
        -: 2963:            }
  1182275: 2964:            dist = d_buf[dx++];
        -: 2965:            /* Here, dist is the match distance - 1 */
  1182275: 2966:            code = d_code(dist);
branch  0 taken 599614 (fallthrough)
branch  1 taken 582661
        -: 2967:            Assert (code < D_CODES, "bad d_code");
        -: 2968:
  1182275: 2969:            send_code(code, dtree);       /* send the distance code */
call    0 returned 1182275
  1182275: 2970:            extra = extra_dbits[code];
  1182275: 2971:            if (extra != 0) {
branch  0 taken 772349 (fallthrough)
branch  1 taken 409926
   772349: 2972:                dist -= base_dist[code];
   772349: 2973:                send_bits(dist, extra);   /* send the extra distance bits */
call    0 returned 772349
        -: 2974:            }
        -: 2975:        } /* literal or match pair ? */
  1782638: 2976:        flag >>= 1;
  1782638: 2977:    } while (lx < last_lit);
branch  0 taken 1782446
branch  1 taken 192 (fallthrough)
        -: 2978:
      196: 2979:    send_code(END_BLOCK, ltree);
call    0 returned 196
      196: 2980:}
        -: 2981:
        -: 2982:/* ===========================================================================
        -: 2983: * Set the file type to ASCII or BINARY, using a crude approximation:
        -: 2984: * binary if more than 20% of the bytes are <= 6 or >= 128, ascii otherwise.
        -: 2985: * IN assertion: the fields freq of dyn_ltree are set and the total of all
        -: 2986: * frequencies does not exceed 64K (to fit in an int on 16 bit machines).
        -: 2987: */
function set_file_type called 0 returned 0% blocks executed 0%
    #####: 2988:local void set_file_type()
        -: 2989:{
    #####: 2990:    int n = 0;
    #####: 2991:    unsigned ascii_freq = 0;
    #####: 2992:    unsigned bin_freq = 0;
    #####: 2993:    while (n < 7)        bin_freq += dyn_ltree[n++].Freq;
branch  0 never executed
branch  1 never executed
    #####: 2994:    while (n < 128)    ascii_freq += dyn_ltree[n++].Freq;
branch  0 never executed
branch  1 never executed
    #####: 2995:    while (n < LITERALS) bin_freq += dyn_ltree[n++].Freq;
branch  0 never executed
branch  1 never executed
    #####: 2996:    *file_type = bin_freq > (ascii_freq >> 2) ? BINARY : ASCII;
        -: 2997:    if (*file_type == BINARY && translate_eol) {
        -: 2998:        warn("-l used on binary file", "");
        -: 2999:    }
    #####: 3000:}
        -: 3001:/* unlzw.c -- decompress files in LZW format.
        -: 3002: * The code in this file is directly derived from the public domain 'compress'
        -: 3003: * written by Spencer Thomas, Joe Orost, James Woods, Jim McKie, Steve Davies,
        -: 3004: * Ken Turkowski, Dave Mack and Peter Jannesen.
        -: 3005: *
        -: 3006: * This is a temporary version which will be rewritten in some future version
        -: 3007: * to accommodate in-memory decompression.
        -: 3008: */
        -: 3009:
        -: 3010:/*
        -: 3011:#ifndef lint
        -: 3012:static char rcsid[] = "$Id: unlzw.c,v 0.12 1993/03/18 18:14:56 jloup Exp $";
        -: 3013:#endif
        -: 3014:*/
        -: 3015:
        -: 3016:#ifdef HAVE_UNISTD_H
        -: 3017:#  include <sys/types.h>
        -: 3018:#  include <unistd.h>
        -: 3019:#endif
        -: 3020:
        -: 3021:typedef unsigned char   char_type;
        -: 3022:typedef          long   code_int;
        -: 3023:typedef unsigned long   count_int;
        -: 3024:typedef unsigned short  count_short;
        -: 3025:typedef unsigned long   cmp_code_int;
        -: 3026:
        -: 3027:#define MAXCODE(n)      (1L << (n))
        -: 3028:
        -: 3029:#ifndef REGISTERS
        -: 3030:#       define  REGISTERS       2
        -: 3031:#endif
        -: 3032:#define REG1
        -: 3033:#define REG2
        -: 3034:#define REG3
        -: 3035:#define REG4
        -: 3036:#define REG5
        -: 3037:#define REG6
        -: 3038:#define REG7
        -: 3039:#define REG8
        -: 3040:#define REG9
        -: 3041:#define REG10
        -: 3042:#define REG11
        -: 3043:#define REG12
        -: 3044:#define REG13
        -: 3045:#define REG14
        -: 3046:#define REG15
        -: 3047:#define REG16
        -: 3048:#if REGISTERS >= 1
        -: 3049:#       undef   REG1
        -: 3050:#       define  REG1    register
        -: 3051:#endif
        -: 3052:#if REGISTERS >= 2
        -: 3053:#       undef   REG2
        -: 3054:#       define  REG2    register
        -: 3055:#endif
        -: 3056:#if REGISTERS >= 3
        -: 3057:#       undef   REG3
        -: 3058:#       define  REG3    register
        -: 3059:#endif
        -: 3060:#if REGISTERS >= 4
        -: 3061:#       undef   REG4
        -: 3062:#       define  REG4    register
        -: 3063:#endif
        -: 3064:#if REGISTERS >= 5
        -: 3065:#       undef   REG5
        -: 3066:#       define  REG5    register
        -: 3067:#endif
        -: 3068:#if REGISTERS >= 6
        -: 3069:#       undef   REG6
        -: 3070:#       define  REG6    register
        -: 3071:#endif
        -: 3072:#if REGISTERS >= 7
        -: 3073:#       undef   REG7
        -: 3074:#       define  REG7    register
        -: 3075:#endif
        -: 3076:#if REGISTERS >= 8
        -: 3077:#       undef   REG8
        -: 3078:#       define  REG8    register
        -: 3079:#endif
        -: 3080:#if REGISTERS >= 9
        -: 3081:#       undef   REG9
        -: 3082:#       define  REG9    register
        -: 3083:#endif
        -: 3084:#if REGISTERS >= 10
        -: 3085:#       undef   REG10
        -: 3086:#       define  REG10   register
        -: 3087:#endif
        -: 3088:#if REGISTERS >= 11
        -: 3089:#       undef   REG11
        -: 3090:#       define  REG11   register
        -: 3091:#endif
        -: 3092:#if REGISTERS >= 12
        -: 3093:#       undef   REG12
        -: 3094:#       define  REG12   register
        -: 3095:#endif
        -: 3096:#if REGISTERS >= 13
        -: 3097:#       undef   REG13
        -: 3098:#       define  REG13   register
        -: 3099:#endif
        -: 3100:#if REGISTERS >= 14
        -: 3101:#       undef   REG14
        -: 3102:#       define  REG14   register
        -: 3103:#endif
        -: 3104:#if REGISTERS >= 15
        -: 3105:#       undef   REG15
        -: 3106:#       define  REG15   register
        -: 3107:#endif
        -: 3108:#if REGISTERS >= 16
        -: 3109:#       undef   REG16
        -: 3110:#       define  REG16   register
        -: 3111:#endif
        -: 3112:
        -: 3113:#ifndef BYTEORDER
        -: 3114:#       define  BYTEORDER       0000
        -: 3115:#endif
        -: 3116:
        -: 3117:#ifndef NOALLIGN
        -: 3118:#       define  NOALLIGN        0
        -: 3119:#endif
        -: 3120:
        -: 3121:
        -: 3122:union   bytes {
        -: 3123:    long  word;
        -: 3124:    struct {
        -: 3125:#if BYTEORDER == 4321
        -: 3126:        char_type       b1;
        -: 3127:        char_type       b2;
        -: 3128:        char_type       b3;
        -: 3129:        char_type       b4;
        -: 3130:#else
        -: 3131:#if BYTEORDER == 1234
        -: 3132:        char_type       b4;
        -: 3133:        char_type       b3;
        -: 3134:        char_type       b2;
        -: 3135:        char_type       b1;
        -: 3136:#else
        -: 3137:#       undef   BYTEORDER
        -: 3138:        int  dummy;
        -: 3139:#endif
        -: 3140:#endif
        -: 3141:    } bytes;
        -: 3142:};
        -: 3143:
        -: 3144:#if BYTEORDER == 4321 && NOALLIGN == 1
        -: 3145:#  define input(b,o,c,n,m){ \
        -: 3146:     (c) = (*(long *)(&(b)[(o)>>3])>>((o)&0x7))&(m); \
        -: 3147:     (o) += (n); \
        -: 3148:   }
        -: 3149:#else
        -: 3150:#  define input(b,o,c,n,m){ \
        -: 3151:     REG1 char_type *p = &(b)[(o)>>3]; \
        -: 3152:     (c) = ((((long)(p[0]))|((long)(p[1])<<8)| \
        -: 3153:     ((long)(p[2])<<16))>>((o)&0x7))&(m); \
        -: 3154:     (o) += (n); \
        -: 3155:   }
        -: 3156:#endif
        -: 3157:
        -: 3158:#ifndef MAXSEG_64K
        -: 3159:   /* DECLARE(ush, tab_prefix, (1<<BITS)); -- prefix code */
        -: 3160:#  define tab_prefixof(i) tab_prefix[i]
        -: 3161:#  define clear_tab_prefixof()  memzero(tab_prefix, 256);
        -: 3162:#else
        -: 3163:   /* DECLARE(ush, tab_prefix0, (1<<(BITS-1)); -- prefix for even codes */
        -: 3164:   /* DECLARE(ush, tab_prefix1, (1<<(BITS-1)); -- prefix for odd  codes */
        -: 3165:   ush *tab_prefix[2];
        -: 3166:#  define tab_prefixof(i) tab_prefix[(i)&1][(i)>>1]
        -: 3167:#  define clear_tab_prefixof()  \
        -: 3168:      memzero(tab_prefix0, 128), \
        -: 3169:      memzero(tab_prefix1, 128);
        -: 3170:#endif
        -: 3171:#define de_stack        ((char_type *)(&d_buf[DIST_BUFSIZE-1]))
        -: 3172:#define tab_suffixof(i) tab_suffix[i]
        -: 3173:
        -: 3174:int block_mode = BLOCK_MODE; /* block compress mode -C compatible with 2.0 */
        -: 3175:
        -: 3176:/* ============================================================================
        -: 3177: * Decompress in to out.  This routine adapts to the codes in the
        -: 3178: * file building the "string" table on-the-fly; requiring no table to
        -: 3179: * be stored in the compressed file.
        -: 3180: * IN assertions: the buffer inbuf contains already the beginning of
        -: 3181: *   the compressed data, from offsets iptr to insize-1 included.
        -: 3182: *   The magic header has already been checked and skipped.
        -: 3183: *   bytes_in and bytes_out have been initialized.
        -: 3184: */
function unlzw called 1 returned 100% blocks executed 77%
        1: 3185:void unlzw(in, out)
        -: 3186:    int in, out;    /* input and output file descriptors */
        -: 3187:{
        -: 3188:    REG2   char_type  *stackp;
        -: 3189:    REG3   code_int   code;
        -: 3190:    REG4   int        finchar;
        -: 3191:    REG5   code_int   oldcode;
        -: 3192:    REG6   code_int   incode;
        -: 3193:    REG7   long       inbits;
        -: 3194:    REG8   long       posbits;
        -: 3195:    REG9   int        outpos;
        -: 3196:/*  REG10  int        insize; (global) */
        -: 3197:    REG11  unsigned   bitmask;
        -: 3198:    REG12  code_int   free_ent;
        -: 3199:    REG13  code_int   maxcode;
        -: 3200:    REG14  code_int   maxmaxcode;
        -: 3201:    REG15  int        n_bits;
        -: 3202:    REG16  int        rsize;
        -: 3203:
        -: 3204:#ifdef MAXSEG_64K
        -: 3205:    tab_prefix[0] = tab_prefix0;
        -: 3206:    tab_prefix[1] = tab_prefix1;
        -: 3207:#endif
       1*: 3208:    maxbits = get_byte();
branch  0 taken 1 (fallthrough)
branch  1 taken 0
call    2 never executed
        1: 3209:    block_mode = maxbits & BLOCK_MODE;
        1: 3210:    if ((maxbits & LZW_RESERVED) != 0) {
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 3211:        WARN((stderr, "%s: %s: warning, unknown flags 0x%x\n",
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 3212:              progname, ifname, maxbits & LZW_RESERVED));
        -: 3213:    }
        1: 3214:    maxbits &= BIT_MASK;
        1: 3215:    maxmaxcode = MAXCODE(maxbits);
        -: 3216:
        1: 3217:    if (maxbits > BITS) {
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 3218:        fprintf(stderr,
call    0 never executed
        -: 3219:                "%s: %s: compressed with %d bits, can only handle %d bits\n",
        -: 3220:                progname, ifname, maxbits, BITS);
    #####: 3221:        exit_code = ERROR;
    #####: 3222:        return;
        -: 3223:    }
        1: 3224:    rsize = insize;
        1: 3225:    maxcode = MAXCODE(n_bits = INIT_BITS)-1;
        1: 3226:    bitmask = (1<<n_bits)-1;
        1: 3227:    oldcode = -1;
        1: 3228:    finchar = 0;
        1: 3229:    outpos = 0;
        1: 3230:    posbits = inptr<<3;
        -: 3231:
       1*: 3232:    free_ent = ((block_mode) ? FIRST : 256);
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -: 3233:
        1: 3234:    clear_tab_prefixof(); /* Initialize the first 256 entries in the table. */
        -: 3235:
      257: 3236:    for (code = 255 ; code >= 0 ; --code) {
branch  0 taken 256
branch  1 taken 1 (fallthrough)
      256: 3237:        tab_suffixof(code) = (char_type)code;
        -: 3238:    }
        -: 3239:    do {
        -: 3240:        REG1 int i;
        -: 3241:        int  e;
        -: 3242:        int  o;
        -: 3243:
        1: 3244:    resetbuf:
        7: 3245:        e = insize-(o = (posbits>>3));
        -: 3246:
    74495: 3247:        for (i = 0 ; i < e ; ++i) {
branch  0 taken 74488
branch  1 taken 7 (fallthrough)
    74488: 3248:            inbuf[i] = inbuf[i+o];
        -: 3249:        }
        7: 3250:        insize = e;
        7: 3251:        posbits = 0;
        -: 3252:
        7: 3253:        if (insize < INBUF_EXTRA) {
branch  0 taken 1 (fallthrough)
branch  1 taken 6
        1: 3254:            if ((rsize = read(in, inbuf+insize, INBUFSIZ)) == EOF) {
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
    #####: 3255:                read_error();
call    0 never executed
        -: 3256:            }
        1: 3257:            insize += rsize;
        -: 3258:        }
        7: 3259:        inbits = ((rsize != 0) ? ((long)insize - insize%n_bits)<<3 :
branch  0 taken 6 (fallthrough)
branch  1 taken 1
        1: 3260:                  ((long)insize<<3)-(n_bits-1));
        -: 3261:
    10145: 3262:        while (inbits > posbits) {
branch  0 taken 10143
branch  1 taken 2 (fallthrough)
    10143: 3263:            if (free_ent > maxcode) {
branch  0 taken 5 (fallthrough)
branch  1 taken 10138
        5: 3264:                posbits = ((posbits-1) +
        5: 3265:                           ((n_bits<<3)-(posbits-1+(n_bits<<3))%(n_bits<<3)));
        5: 3266:                ++n_bits;
        5: 3267:                if (n_bits == maxbits) {
branch  0 taken 0 (fallthrough)
branch  1 taken 5
    #####: 3268:                    maxcode = maxmaxcode;
        -: 3269:                } else {
        5: 3270:                    maxcode = MAXCODE(n_bits)-1;
        -: 3271:                }
        5: 3272:                bitmask = (1<<n_bits)-1;
        5: 3273:                goto resetbuf;
        -: 3274:            }
    10138: 3275:            input(inbuf,posbits,code,n_bits,bitmask);
        -: 3276:
    10138: 3277:            if (oldcode == -1) {
branch  0 taken 1 (fallthrough)
branch  1 taken 10137
        1: 3278:                outbuf[outpos++] = (char_type)(finchar = (int)(oldcode=code));
        1: 3279:                continue;
        -: 3280:            }
   10137*: 3281:            if (code == CLEAR && block_mode) {
branch  0 taken 0 (fallthrough)
branch  1 taken 10137
branch  2 never executed
branch  3 never executed
    #####: 3282:                clear_tab_prefixof();
    #####: 3283:                free_ent = FIRST - 1;
    #####: 3284:                posbits = ((posbits-1) +
    #####: 3285:                           ((n_bits<<3)-(posbits-1+(n_bits<<3))%(n_bits<<3)));
    #####: 3286:                maxcode = MAXCODE(n_bits = INIT_BITS)-1;
    #####: 3287:                bitmask = (1<<n_bits)-1;
    #####: 3288:                goto resetbuf;
        -: 3289:            }
    10137: 3290:            incode = code;
    10137: 3291:            stackp = de_stack;
        -: 3292:
    10137: 3293:            if (code >= free_ent) { /* Special case for KwKwK string. */
branch  0 taken 17 (fallthrough)
branch  1 taken 10120
       17: 3294:                if (code > free_ent) {
branch  0 taken 0 (fallthrough)
branch  1 taken 17
        -: 3295:
        -: 3296:                    REG1 char_type *p;
        -: 3297:
    #####: 3298:                    posbits -= n_bits;
    #####: 3299:                    p = &inbuf[posbits>>3];
        -: 3300:#ifdef DEBUG
        -: 3301:                    fprintf(stderr,
        -: 3302:                            "code:%ld free_ent:%ld n_bits:%d insize:%u\n",
        -: 3303:                            code, free_ent, n_bits, insize);
        -: 3304:                    fprintf(stderr,
        -: 3305:                            "posbits:%ld inbuf:%02X %02X %02X %02X %02X\n",
        -: 3306:                            posbits, p[-1],p[0],p[1],p[2],p[3]);
        -: 3307:#endif
    #####: 3308:                    if (!test && outpos > 0) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3309:                        write_buf(out, outbuf, outpos);
call    0 never executed
        -: 3310:                    }
    #####: 3311:                    error("corrupt input. Use zcat to recover some data.");
call    0 never executed
        -: 3312:                }
       17: 3313:                *--stackp = (char_type)finchar;
       17: 3314:                code = oldcode;
        -: 3315:            }
        -: 3316:
    34213: 3317:            while ((cmp_code_int)code >= (cmp_code_int)256) {
branch  0 taken 24076
branch  1 taken 10137 (fallthrough)
        -: 3318:                /* Generate output characters in reverse order */
    24076: 3319:                *--stackp = tab_suffixof(code);
    24076: 3320:                code = tab_prefixof(code);
        -: 3321:            }
    10137: 3322:            *--stackp = (char_type)(finchar = tab_suffixof(code));
        -: 3323:
        -: 3324:            /* And put them out in forward order */
        -: 3325:            {
        -: 3326:                REG1 int        i;
        -: 3327:
    10137: 3328:                if (outpos+(i = (de_stack-stackp)) >= OUTBUFSIZ) {
branch  0 taken 2 (fallthrough)
branch  1 taken 10135
        -: 3329:                    do {
        4: 3330:                        if (i > OUTBUFSIZ-outpos) i = OUTBUFSIZ-outpos;
branch  0 taken 2 (fallthrough)
branch  1 taken 2
        -: 3331:
        4: 3332:                        if (i > 0) {
branch  0 taken 4 (fallthrough)
branch  1 taken 0
        4: 3333:                            memcpy(outbuf+outpos, stackp, i);
        4: 3334:                            outpos += i;
        -: 3335:                        }
        4: 3336:                        if (outpos >= OUTBUFSIZ) {
branch  0 taken 2 (fallthrough)
branch  1 taken 2
        2: 3337:                            if (!test) write_buf(out, outbuf, outpos);
branch  0 taken 2 (fallthrough)
branch  1 taken 0
call    2 returned 2
        2: 3338:                            outpos = 0;
        -: 3339:                        }
        4: 3340:                        stackp+= i;
        4: 3341:                    } while ((i = (de_stack-stackp)) > 0);
branch  0 taken 2
branch  1 taken 2
        -: 3342:                } else {
    10135: 3343:                    memcpy(outbuf+outpos, stackp, i);
    10135: 3344:                    outpos += i;
        -: 3345:                }
        -: 3346:            }
        -: 3347:
    10137: 3348:            if ((code = free_ent) < maxmaxcode) { /* Generate the new entry. */
branch  0 taken 10137 (fallthrough)
branch  1 taken 0
        -: 3349:
    10137: 3350:                tab_prefixof(code) = (unsigned short)oldcode;
    10137: 3351:                tab_suffixof(code) = (char_type)finchar;
    10137: 3352:                free_ent = code+1;
        -: 3353:            }
    10137: 3354:            oldcode = incode;   /* Remember previous code.      */
        -: 3355:        }
        2: 3356:        bytes_in += rsize;
        -: 3357:
        2: 3358:    } while (rsize != 0);
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        -: 3359:
        1: 3360:    if (!test && outpos > 0) write_buf(out, outbuf, outpos);
branch  0 taken 1 (fallthrough)
branch  1 taken 0
branch  2 taken 1 (fallthrough)
branch  3 taken 0
call    4 returned 1
        -: 3361:}
        -: 3362:/* unpack.c -- decompress files in pack format.
        -: 3363: * Copyright (C) 1992-1993 Jean-loup Gailly
        -: 3364: * This is free software; you can redistribute it and/or modify it under the
        -: 3365: * terms of the GNU General Public License, see the file COPYING.
        -: 3366: */
        -: 3367:
        -: 3368:/*
        -: 3369:#ifndef lint
        -: 3370:static char rcsid[] = "$Id: unpack.c,v 1.2 1993/02/04 13:21:06 jloup Exp $";
        -: 3371:#endif
        -: 3372:*/
        -: 3373:
        -: 3374:#define MIN(a,b) ((a) <= (b) ? (a) : (b))
        -: 3375:/* The arguments must not have side effects. */
        -: 3376:
        -: 3377:#define MAX_BITLEN 25
        -: 3378:/* Maximum length of Huffman codes. (Minor modifications to the code
        -: 3379: * would be needed to support 32 bits codes, but pack never generates
        -: 3380: * more than 24 bits anyway.)
        -: 3381: */
        -: 3382:
        -: 3383:#define LITERALS 256
        -: 3384:/* Number of literals, excluding the End of Block (EOB) code */
        -: 3385:
        -: 3386:#define MAX_PEEK 12
        -: 3387:/* Maximum number of 'peek' bits used to optimize traversal of the
        -: 3388: * Huffman tree.
        -: 3389: */
        -: 3390:
        -: 3391:local ulg orig_len;       /* original uncompressed length */
        -: 3392:local int max_len;        /* maximum bit length of Huffman codes */
        -: 3393:
        -: 3394:local uch literal[LITERALS];
        -: 3395:/* The literal bytes present in the Huffman tree. The EOB code is not
        -: 3396: * represented.
        -: 3397: */
        -: 3398:
        -: 3399:local int lit_base[MAX_BITLEN+1];
        -: 3400:/* All literals of a given bit length are contiguous in literal[] and
        -: 3401: * have contiguous codes. literal[code+lit_base[len]] is the literal
        -: 3402: * for a code of len bits.
        -: 3403: */
        -: 3404:
        -: 3405:local int leaves [MAX_BITLEN+1]; /* Number of leaves for each bit length */
        -: 3406:local int parents[MAX_BITLEN+1]; /* Number of parents for each bit length */
        -: 3407:
        -: 3408:local int peek_bits; /* Number of peek bits currently used */
        -: 3409:
        -: 3410:local uch prefix_len[1 << MAX_PEEK];
        -: 3411:/* For each bit pattern b of peek_bits bits, prefix_len[b] is the length
        -: 3412: * of the Huffman code starting with a prefix of b (upper bits), or 0
        -: 3413: * if all codes of prefix b have more than peek_bits bits. It is not
        -: 3414: * necessary to have a huge table (large MAX_PEEK) because most of the
        -: 3415: * codes encountered in the input stream are short codes (by construction).
        -: 3416: * So for most codes a single lookup will be necessary.
        -: 3417: */
        -: 3418:
        -: 3419:local ulg bitbuf;
        -: 3420:/* Bits are added on the low part of bitbuf and read from the high part. */
        -: 3421:
        -: 3422:local int valid;                  /* number of valid bits in bitbuf */
        -: 3423:/* all bits above the last valid bit are always zero */
        -: 3424:
        -: 3425:/* Set code to the next 'bits' input bits without skipping them. code
        -: 3426: * must be the name of a simple variable and bits must not have side effects.
        -: 3427: * IN assertions: bits <= 25 (so that we still have room for an extra byte
        -: 3428: * when valid is only 24), and mask = (1<<bits)-1.
        -: 3429: */
        -: 3430:#define look_bits(code,bits,mask) \
        -: 3431:{ \
        -: 3432:  while (valid < (bits)) bitbuf = (bitbuf<<8) | (ulg)get_byte(), valid += 8; \
        -: 3433:  code = (bitbuf >> (valid-(bits))) & (mask); \
        -: 3434:}
        -: 3435:
        -: 3436:/* Skip the given number of bits (after having peeked at them): */
        -: 3437:#define skip_bits(bits)  (valid -= (bits))
        -: 3438:
        -: 3439:#define clear_bitbuf() (valid = 0, bitbuf = 0)
        -: 3440:
        -: 3441:/* Local functions */
        -: 3442:
        -: 3443:local void read_tree  OF((void));
        -: 3444:local void un_build_tree OF((void));
        -: 3445:
        -: 3446:/* ===========================================================================
        -: 3447: * Read the Huffman tree.
        -: 3448: */
function read_tree called 1 returned 100% blocks executed 74%
        1: 3449:local void read_tree()
        -: 3450:{
        -: 3451:    int len;  /* bit length */
        -: 3452:    int base; /* base offset for a sequence of leaves */
        -: 3453:    int n;
        -: 3454:
        -: 3455:    /* Read the original input size, MSB first */
        1: 3456:    orig_len = 0;
       5*: 3457:    for (n = 1; n <= 4; n++) orig_len = (orig_len << 8) | (ulg)get_byte();
branch  0 taken 4 (fallthrough)
branch  1 taken 0
call    2 never executed
branch  3 taken 4
branch  4 taken 1 (fallthrough)
        -: 3458:
       1*: 3459:    max_len = (int)get_byte(); /* maximum bit length of Huffman codes */
branch  0 taken 1 (fallthrough)
branch  1 taken 0
call    2 never executed
        1: 3460:    if (max_len > MAX_BITLEN) {
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 3461:        error("invalid compressed data -- Huffman code > 32 bits");
call    0 never executed
        -: 3462:    }
        -: 3463:
        -: 3464:    /* Get the number of leaves at each bit length */
        1: 3465:    n = 0;
       17: 3466:    for (len = 1; len <= max_len; len++) {
branch  0 taken 16
branch  1 taken 1 (fallthrough)
      16*: 3467:        leaves[len] = (int)get_byte();
branch  0 taken 16 (fallthrough)
branch  1 taken 0
call    2 never executed
       16: 3468:        n += leaves[len];
        -: 3469:    }
        1: 3470:    if (n > LITERALS) {
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 3471:        error("too many leaves in Huffman tree");
call    0 never executed
        -: 3472:    }
        -: 3473:    Trace((stderr, "orig_len %ld, max_len %d, leaves %d\n",
        -: 3474:           orig_len, max_len, n));
        -: 3475:    /* There are at least 2 and at most 256 leaves of length max_len.
        -: 3476:     * (Pack arbitrarily rejects empty files and files consisting of
        -: 3477:     * a single byte even repeated.) To fit the last leaf count in a
        -: 3478:     * byte, it is offset by 2. However, the last literal is the EOB
        -: 3479:     * code, and is not transmitted explicitly in the tree, so we must
        -: 3480:     * adjust here by one only.
        -: 3481:     */
        1: 3482:    leaves[max_len]++;
        -: 3483:
        -: 3484:    /* Now read the leaves themselves */
        1: 3485:    base = 0;
       17: 3486:    for (len = 1; len <= max_len; len++) {
branch  0 taken 16
branch  1 taken 1 (fallthrough)
        -: 3487:        /* Remember where the literals of this length start in literal[] : */
       16: 3488:        lit_base[len] = base;
        -: 3489:        /* And read the literals: */
      107: 3490:        for (n = leaves[len]; n > 0; n--) {
branch  0 taken 91
branch  1 taken 16 (fallthrough)
      91*: 3491:            literal[base++] = (uch)get_byte();
branch  0 taken 91 (fallthrough)
branch  1 taken 0
call    2 never executed
        -: 3492:        }
        -: 3493:    }
        1: 3494:    leaves[max_len]++; /* Now include the EOB code in the Huffman tree */
        1: 3495:}
        -: 3496:
        -: 3497:/* ===========================================================================
        -: 3498: * Build the Huffman tree and the prefix table.
        -: 3499: */
function un_build_tree called 1 returned 100% blocks executed 100%
        1: 3500:local void un_build_tree()
        -: 3501:{
        1: 3502:    int nodes = 0; /* number of nodes (parents+leaves) at current bit length */
        -: 3503:    int len;       /* current bit length */
        -: 3504:    uch *prefixp;  /* pointer in prefix_len */
        -: 3505:
       17: 3506:    for (len = max_len; len >= 1; len--) {
branch  0 taken 16
branch  1 taken 1 (fallthrough)
        -: 3507:        /* The number of parent nodes at this level is half the total
        -: 3508:         * number of nodes at parent level:
        -: 3509:         */
       16: 3510:        nodes >>= 1;
       16: 3511:        parents[len] = nodes;
        -: 3512:        /* Update lit_base by the appropriate bias to skip the parent nodes
        -: 3513:         * (which are not represented in the literal array):
        -: 3514:         */
       16: 3515:        lit_base[len] -= nodes;
        -: 3516:        /* Restore nodes to be parents+leaves: */
       16: 3517:        nodes += leaves[len];
        -: 3518:    }
        -: 3519:    /* Construct the prefix table, from shortest leaves to longest ones.
        -: 3520:     * The shortest code is all ones, so we start at the end of the table.
        -: 3521:     */
        1: 3522:    peek_bits = MIN(max_len, MAX_PEEK);
        1: 3523:    prefixp = &prefix_len[1<<peek_bits];
       13: 3524:    for (len = 1; len <= peek_bits; len++) {
branch  0 taken 12
branch  1 taken 1 (fallthrough)
       12: 3525:        int prefixes = leaves[len] << (peek_bits-len); /* may be 0 */
     4103: 3526:        while (prefixes--) *--prefixp = (uch)len;
branch  0 taken 4091
branch  1 taken 12 (fallthrough)
        -: 3527:    }
        -: 3528:    /* The length of all other codes is unknown: */
        6: 3529:    while (prefixp > prefix_len) *--prefixp = 0;
branch  0 taken 5
branch  1 taken 1 (fallthrough)
        1: 3530:}
        -: 3531:
        -: 3532:/* ===========================================================================
        -: 3533: * Unpack in to out.  This routine does not support the old pack format
        -: 3534: * with magic header \037\037.
        -: 3535: *
        -: 3536: * IN assertions: the buffer inbuf contains already the beginning of
        -: 3537: *   the compressed data, from offsets inptr to insize-1 included.
        -: 3538: *   The magic header has already been checked. The output buffer is cleared.
        -: 3539: */
function unpack called 1 returned 100% blocks executed 84%
        1: 3540:void unpack(in, out)
        -: 3541:    int in, out;            /* input and output file descriptors */
        -: 3542:{
        -: 3543:    int len;                /* Bit length of current code */
        -: 3544:    unsigned eob;           /* End Of Block code */
        -: 3545:    register unsigned peek; /* lookahead bits */
        -: 3546:    unsigned peek_mask;     /* Mask for peek_bits bits */
        -: 3547:
        1: 3548:    ifd = in;
        1: 3549:    ofd = out;
        -: 3550:
        1: 3551:    read_tree();     /* Read the Huffman tree */
call    0 returned 1
        1: 3552:    un_build_tree();    /* Build the prefix table */
call    0 returned 1
        1: 3553:    clear_bitbuf();  /* Initialize bit input */
        1: 3554:    peek_mask = (1<<peek_bits)-1;
        -: 3555:
        -: 3556:    /* The eob code is the largest code among all leaves of maximal length: */
        1: 3557:    eob = leaves[max_len]-1;
        -: 3558:    Trace((stderr, "eob %d %x\n", max_len, eob));
        -: 3559:
        -: 3560:    /* Decode the input data: */
        -: 3561:    for (;;) {
        -: 3562:        /* Since eob is the longest code and not shorter than max_len,
        -: 3563:         * we can peek at max_len bits without having the risk of reading
        -: 3564:         * beyond the end of file.
        -: 3565:         */
   54270*: 3566:        look_bits(peek, peek_bits, peek_mask);
branch  0 taken 20038 (fallthrough)
branch  1 taken 0
call    2 never executed
branch  3 taken 20038
branch  4 taken 34232 (fallthrough)
    34232: 3567:        len = prefix_len[peek];
    34232: 3568:        if (len > 0) {
branch  0 taken 34184 (fallthrough)
branch  1 taken 48
    34184: 3569:            peek >>= peek_bits - len; /* discard the extra bits */
        -: 3570:        } else {
        -: 3571:            /* Code of more than peek_bits bits, we must traverse the tree */
       48: 3572:            ulg mask = peek_mask;
       48: 3573:            len = peek_bits;
        -: 3574:            do {
       76: 3575:                len++, mask = (mask<<1)+1;
      84*: 3576:                look_bits(peek, len, mask);
branch  0 taken 8 (fallthrough)
branch  1 taken 0
call    2 never executed
branch  3 taken 8
branch  4 taken 76 (fallthrough)
       76: 3577:            } while (peek < parents[len]);
branch  0 taken 28
branch  1 taken 48 (fallthrough)
        -: 3578:            /* loop as long as peek is a parent node */
        -: 3579:        }
        -: 3580:        /* At this point, peek is the next complete code, of len bits */
    34232: 3581:        if (peek == eob && len == max_len) break; /* end of file? */
branch  0 taken 2 (fallthrough)
branch  1 taken 34230
branch  2 taken 1 (fallthrough)
branch  3 taken 1
    34231: 3582:        put_char(literal[peek+lit_base[len]]);
branch  0 taken 1 (fallthrough)
branch  1 taken 34230
call    2 returned 1
        -: 3583:        Tracev((stderr,"%02d %04x %c\n", len, peek,
        -: 3584:                literal[peek+lit_base[len]]));
    34231: 3585:        skip_bits(len);
        -: 3586:    } /* for (;;) */
        -: 3587:
        1: 3588:    flush_window();
call    0 returned 1
        -: 3589:    Trace((stderr, "bytes_out %ld\n", bytes_out));
        1: 3590:    if (orig_len != bytes_out) {
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 3591:        error("invalid compressed data--length error");
call    0 never executed
        -: 3592:    }
        1: 3593:}
        -: 3594:
        -: 3595:
        -: 3596:/* unzip.c -- decompress files in gzip or pkzip format.
        -: 3597: * Copyright (C) 1992-1993 Jean-loup Gailly
        -: 3598: * This is free software; you can redistribute it and/or modify it under the
        -: 3599: * terms of the GNU General Public License, see the file COPYING.
        -: 3600: *
        -: 3601: * The code in this file is derived from the file funzip.c written
        -: 3602: * and put in the public domain by Mark Adler.
        -: 3603: */
        -: 3604:
        -: 3605:/*
        -: 3606:   This version can extract files in gzip or pkzip format.
        -: 3607:   For the latter, only the first entry is extracted, and it has to be
        -: 3608:   either deflated or stored.
        -: 3609: */
        -: 3610:
        -: 3611:/*
        -: 3612:#ifndef lint
        -: 3613:static char rcsid[] = "$Id: unzip.c,v 0.11 1993/03/04 19:15:33 jloup Exp $";
        -: 3614:#endif
        -: 3615:*/
        -: 3616:
        -: 3617:/* PKZIP header definitions */
        -: 3618:#define LOCSIG 0x04034b50L      /* four-byte lead-in (lsb first) */
        -: 3619:#define LOCFLG 6                /* offset of bit flag */
        -: 3620:#define  CRPFLG 1               /*  bit for encrypted entry */
        -: 3621:#define  EXTFLG 8               /*  bit for extended local header */
        -: 3622:#define LOCHOW 8                /* offset of compression method */
        -: 3623:#define LOCTIM 10               /* file mod time (for decryption) */
        -: 3624:#define LOCCRC 14               /* offset of crc */
        -: 3625:#define LOCSIZ 18               /* offset of compressed size */
        -: 3626:#define LOCLEN 22               /* offset of uncompressed length */
        -: 3627:#define LOCFIL 26               /* offset of file name field length */
        -: 3628:#define LOCEXT 28               /* offset of extra field length */
        -: 3629:#define LOCHDR 30               /* size of local header, including sig */
        -: 3630:#define EXTHDR 16               /* size of extended local header, inc sig */
        -: 3631:
        -: 3632:
        -: 3633:/* Globals */
        -: 3634:
        -: 3635:int decrypt;      /* flag to turn on decryption */
        -: 3636:char *key;        /* not used--needed to link crypt.c */
        -: 3637:int pkzip = 0;    /* set for a pkzip file */
        -: 3638:int extended = 0; /* set if extended local header */
        -: 3639:
        -: 3640:/* ===========================================================================
        -: 3641: * Check zip file and advance inptr to the start of the compressed data.
        -: 3642: * Get ofname from the local header if necessary.
        -: 3643: */
function check_zipfile called 2 returned 100% blocks executed 64%
        2: 3644:int check_zipfile(in)
        -: 3645:    int in;   /* input file descriptors */
        -: 3646:{
        2: 3647:    uch *h = inbuf + inptr; /* first local header */
        -: 3648:
        2: 3649:    ifd = in;
        -: 3650:
        -: 3651:    /* Check validity of local header, and skip name and extra fields */
        2: 3652:    inptr += LOCHDR + SH(h + LOCFIL) + SH(h + LOCEXT);
        -: 3653:
        2: 3654:    if (inptr > insize || LG(h) != LOCSIG) {
branch  0 taken 2 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 2
    #####: 3655:        error("input not a zip file or empty");
call    0 never executed
        -: 3656:    }
        2: 3657:    method = h[LOCHOW];
        2: 3658:    if (method != STORED && method != DEFLATED) {
branch  0 taken 2 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 2
    #####: 3659:        error("first entry not deflated or stored -- use unzip");
call    0 never executed
        -: 3660:    }
        -: 3661:
        -: 3662:    /* If entry encrypted, decrypt and validate encryption header */
        2: 3663:    if ((decrypt = h[LOCFLG] & CRPFLG) != 0) {
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####: 3664:        fprintf(stderr, "encrypted file, not yet supported.\n");
call    0 never executed
    #####: 3665:        exit_code = ERROR;
    #####: 3666:        return -1;
        -: 3667:    }
        -: 3668:
        -: 3669:    /* Save flags for unzip() */
        2: 3670:    extended = (h[LOCFLG] & EXTFLG) != 0;
        2: 3671:    pkzip = 1;
        -: 3672:
        -: 3673:    /* Get ofname and time stamp from local header (to be done) */
        2: 3674:    return 0;
        -: 3675:}
        -: 3676:
        -: 3677:/* ===========================================================================
        -: 3678: * Unzip in to out.  This routine works on both gzip and pkzip files.
        -: 3679: *
        -: 3680: * IN assertions: the buffer inbuf contains already the beginning of
        -: 3681: *   the compressed data, from offsets inptr to insize-1 included.
        -: 3682: *   The magic header has already been checked. The output buffer is cleared.
        -: 3683: */
function unzip called 13 returned 92% blocks executed 42%
       13: 3684:void unzip(in, out)
        -: 3685:    int in, out;   /* input and output file descriptors */
        -: 3686:{
       13: 3687:    ulg orig_crc = 0;       /* original crc */
       13: 3688:    ulg orig_len = 0;       /* original uncompressed length */
        -: 3689:    int n;
        -: 3690:    uch buf[EXTHDR];        /* extended local header */
        -: 3691:
       13: 3692:    ifd = in;
       13: 3693:    ofd = out;
        -: 3694:
       13: 3695:    updcrc(NULL, 0);           /* initialize crc */
call    0 returned 13
        -: 3696:
       13: 3697:    if (pkzip && !extended) {  /* crc and length at the end otherwise */
branch  0 taken 2 (fallthrough)
branch  1 taken 11
branch  2 taken 2 (fallthrough)
branch  3 taken 0
        2: 3698:        orig_crc = LG(inbuf + LOCCRC);
        2: 3699:        orig_len = LG(inbuf + LOCLEN);
        -: 3700:    }
        -: 3701:
        -: 3702:    /* Decompress */
       13: 3703:    if (method == DEFLATED)  {
branch  0 taken 12 (fallthrough)
branch  1 taken 1
        -: 3704:
       12: 3705:        int res = inflate();
call    0 returned 12
        -: 3706:
       12: 3707:        if (res == 3) {
branch  0 taken 0 (fallthrough)
branch  1 taken 12
    #####: 3708:            error("out of memory");
call    0 never executed
       12: 3709:        } else if (res != 0) {
branch  0 taken 0 (fallthrough)
branch  1 taken 12
    #####: 3710:            error("invalid compressed data--format violated");
call    0 never executed
        -: 3711:        }
        -: 3712:
       1*: 3713:    } else if (pkzip && method == STORED) {
branch  0 taken 0 (fallthrough)
branch  1 taken 1
branch  2 never executed
branch  3 never executed
        -: 3714:
    #####: 3715:        register ulg n = LG(inbuf + LOCLEN);
        -: 3716:
    #####: 3717:        if (n != LG(inbuf + LOCSIZ) - (decrypt ? RAND_HEAD_LEN : 0)) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 3718:
    #####: 3719:            fprintf(stderr, "len %ld, siz %ld\n", n, LG(inbuf + LOCSIZ));
call    0 never executed
    #####: 3720:            error("invalid compressed data--length mismatch");
call    0 never executed
        -: 3721:        }
    #####: 3722:        while (n--) {
branch  0 never executed
branch  1 never executed
    #####: 3723:            uch c = (uch)get_byte();
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 3724:#ifdef CRYPT
        -: 3725:            if (decrypt) zdecode(c);
        -: 3726:#endif
    #####: 3727:            put_char(c);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 3728:        }
    #####: 3729:        flush_window();
call    0 never executed
        -: 3730:    } else {
        1: 3731:        error("internal error, invalid method");
call    0 returned 0
        -: 3732:    }
        -: 3733:
        -: 3734:    /* Get the crc and original length */
       12: 3735:    if (!pkzip) {
branch  0 taken 10 (fallthrough)
branch  1 taken 2
        -: 3736:        /* crc32  (see algorithm.doc)
        -: 3737:         * uncompressed input size modulo 2^32
        -: 3738:         */
       90: 3739:        for (n = 0; n < 8; n++) {
branch  0 taken 80
branch  1 taken 10 (fallthrough)
      80*: 3740:            buf[n] = (uch)get_byte(); /* may cause an error if EOF */
branch  0 taken 80 (fallthrough)
branch  1 taken 0
call    2 never executed
        -: 3741:        }
       10: 3742:        orig_crc = LG(buf);
       10: 3743:        orig_len = LG(buf+4);
        -: 3744:
        2: 3745:    } else if (extended) {  /* If extended header, check it */
branch  0 taken 0 (fallthrough)
branch  1 taken 2
        -: 3746:        /* signature - 4bytes: 0x50 0x4b 0x07 0x08
        -: 3747:         * CRC-32 value
        -: 3748:         * compressed size 4-bytes
        -: 3749:         * uncompressed size 4-bytes
        -: 3750:         */
    #####: 3751:        for (n = 0; n < EXTHDR; n++) {
branch  0 never executed
branch  1 never executed
    #####: 3752:            buf[n] = (uch)get_byte(); /* may cause an error if EOF */
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 3753:        }
    #####: 3754:        orig_crc = LG(buf+4);
    #####: 3755:        orig_len = LG(buf+12);
        -: 3756:    }
        -: 3757:
        -: 3758:    /* Validate decompression */
       12: 3759:    if (orig_crc != updcrc(outbuf, 0)) {
call    0 returned 12
branch  1 taken 0 (fallthrough)
branch  2 taken 12
    #####: 3760:        error("invalid compressed data--crc error");
call    0 never executed
        -: 3761:    }
       12: 3762:    if (orig_len != bytes_out) {
branch  0 taken 0 (fallthrough)
branch  1 taken 12
    #####: 3763:        error("invalid compressed data--length error");
call    0 never executed
        -: 3764:    }
        -: 3765:
        -: 3766:    /* Check if there are more entries in a pkzip file */
       12: 3767:    if (pkzip && inptr + 4 < insize && LG(inbuf+inptr) == LOCSIG) {
branch  0 taken 2 (fallthrough)
branch  1 taken 10
branch  2 taken 2 (fallthrough)
branch  3 taken 0
branch  4 taken 0 (fallthrough)
branch  5 taken 2
    #####: 3768:        if (to_stdout) {
branch  0 never executed
branch  1 never executed
    #####: 3769:            fprintf(stderr,
call    0 never executed
        -: 3770:                  "warning: zip file has more than one entry--rest ignored\n");
        -: 3771:        } else {
        -: 3772:            /* Don't destroy the input zip file */
    #####: 3773:            error("zip file has more than one entry");
call    0 never executed
        -: 3774:        }
        -: 3775:    }
       12: 3776:    extended = pkzip = 0; /* for next file */
       12: 3777:}
        -: 3778:/* util.c -- utility functions for gzip support
        -: 3779: * Copyright (C) 1992-1993 Jean-loup Gailly
        -: 3780: * This is free software; you can redistribute it and/or modify it under the
        -: 3781: * terms of the GNU General Public License, see the file COPYING.
        -: 3782: */
        -: 3783:
        -: 3784:/*
        -: 3785:#ifndef lint
        -: 3786:static char rcsid[] = "$Id: util.c,v 0.13 1993/03/18 18:14:56 jloup Exp $";
        -: 3787:#endif
        -: 3788:*/
        -: 3789:
        -: 3790:#ifdef HAVE_UNISTD_H
        -: 3791:#  include <sys/types.h>
        -: 3792:#  include <unistd.h>
        -: 3793:#endif
        -: 3794:
        -: 3795:#if defined(STDC_HEADERS) || !defined(NO_STDLIB_H)
        -: 3796:#  include <stdlib.h>
        -: 3797:#else
        -: 3798:   extern int errno;
        -: 3799:#endif
        -: 3800:
        -: 3801:extern ulg crc_32_tab[];   /* crc table, defined below */
        -: 3802:
        -: 3803:/* ===========================================================================
        -: 3804: * Run a set of bytes through the crc shift register.  If s is a NULL
        -: 3805: * pointer, then initialize the crc shift register contents instead.
        -: 3806: * Return the current crc in either case.
        -: 3807: */
function updcrc called 3624 returned 100% blocks executed 100%
     3624: 3808:ulg updcrc(s, n)
        -: 3809:    uch *s;                 /* pointer to bytes to pump through */
        -: 3810:    unsigned n;             /* number of bytes in s[] */
        -: 3811:{
        -: 3812:    register ulg c;         /* temporary variable */
        -: 3813:
        -: 3814:    static ulg crc = (ulg)0xffffffffL; /* shift register contents */
        -: 3815:
     3624: 3816:    if (s == NULL) {
branch  0 taken 190 (fallthrough)
branch  1 taken 3434
      190: 3817:        c = 0xffffffffL;
        -: 3818:    } else {
     3434: 3819:        c = crc;
111991628: 3820:        while (n--) {
branch  0 taken 111988194
branch  1 taken 3434 (fallthrough)
111988194: 3821:            c = crc_32_tab[((int)c ^ (*s++)) & 0xff] ^ (c >> 8);
        -: 3822:        }
        -: 3823:    }
     3624: 3824:    crc = c;
     3624: 3825:    return c ^ 0xffffffffL;       /* (instead of ~c for 64-bit machines) */
        -: 3826:}
        -: 3827:
        -: 3828:/* ===========================================================================
        -: 3829: * Clear input and output buffers
        -: 3830: */
function clear_bufs called 192 returned 100% blocks executed 100%
      192: 3831:void clear_bufs()
        -: 3832:{
      192: 3833:    outcnt = 0;
      192: 3834:    insize = inptr = 0;
      192: 3835:    bytes_in = bytes_out = 0L;
      192: 3836:}
        -: 3837:
        -: 3838:/* ===========================================================================
        -: 3839: * Fill the input buffer. This is called only when the buffer is empty
        -: 3840: * and at least one byte is really needed.
        -: 3841: */
function fill_inbuf called 17 returned 94% blocks executed 100%
       17: 3842:int fill_inbuf()
        -: 3843:{
        -: 3844:    int len;
        -: 3845:
        -: 3846:    /* Read as much as possible */
       17: 3847:    insize = 0;
        -: 3848:    do {
       31: 3849:        len = read(ifd, inbuf+insize, INBUFSIZ-insize);
call    0 returned 31
       31: 3850:        if (len == 0 || len == EOF) break;
branch  0 taken 16 (fallthrough)
branch  1 taken 15
branch  2 taken 16 (fallthrough)
branch  3 taken 0
       16: 3851:        insize += len;
       16: 3852:    } while (insize < INBUFSIZ);
branch  0 taken 14
branch  1 taken 2 (fallthrough)
        -: 3853:
       17: 3854:    if (insize == 0) {
branch  0 taken 1 (fallthrough)
branch  1 taken 16
        1: 3855:        read_error();
call    0 returned 0
        -: 3856:    }
       16: 3857:    bytes_in += (ulg)insize;
       16: 3858:    inptr = 1;
       16: 3859:    return inbuf[0];
        -: 3860:}
        -: 3861:
        -: 3862:/* ===========================================================================
        -: 3863: * Write the output buffer outbuf[0..outcnt-1] and update bytes_out.
        -: 3864: * (used for the compressed data only)
        -: 3865: */
function flush_outbuf called 194 returned 100% blocks executed 80%
      194: 3866:void flush_outbuf()
        -: 3867:{
     194*: 3868:    if (outcnt == 0) return;
branch  0 taken 0 (fallthrough)
branch  1 taken 194
        -: 3869:
      194: 3870:    write_buf(ofd, (char *)outbuf, outcnt);
call    0 returned 194
      194: 3871:    bytes_out += (ulg)outcnt;
      194: 3872:    outcnt = 0;
        -: 3873:}
        -: 3874:
        -: 3875:/* ===========================================================================
        -: 3876: * Write the output window window[0..outcnt-1] and update crc and bytes_out.
        -: 3877: * (Used for the decompressed data only.)
        -: 3878: */
function flush_window called 27 returned 100% blocks executed 86%
       27: 3879:void flush_window()
        -: 3880:{
      27*: 3881:    if (outcnt == 0) return;
branch  0 taken 0 (fallthrough)
branch  1 taken 27
       27: 3882:    updcrc(window, outcnt);
call    0 returned 27
        -: 3883:
       27: 3884:    if (!test) {
branch  0 taken 21 (fallthrough)
branch  1 taken 6
       21: 3885:        write_buf(ofd, (char *)window, outcnt);
call    0 returned 21
        -: 3886:    }
       27: 3887:    bytes_out += (ulg)outcnt;
       27: 3888:    outcnt = 0;
        -: 3889:}
        -: 3890:
        -: 3891:/* ===========================================================================
        -: 3892: * Does the same as write(), but also handles partial pipe writes and checks
        -: 3893: * for error return.
        -: 3894: */
function write_buf called 218 returned 100% blocks executed 57%
      218: 3895:void write_buf(fd, buf, cnt)
        -: 3896:    int       fd;
        -: 3897:    voidp     buf;
        -: 3898:    unsigned  cnt;
        -: 3899:{
        -: 3900:    unsigned  n;
        -: 3901:
      218: 3902:    while ((n = write(fd, buf, cnt)) != cnt) {
call    0 returned 218
branch  1 taken 0
branch  2 taken 218 (fallthrough)
    #####: 3903:        if (n == (unsigned)(-1)) {
branch  0 never executed
branch  1 never executed
    #####: 3904:            write_error();
call    0 never executed
        -: 3905:        }
    #####: 3906:        cnt -= n;
    #####: 3907:        buf = (voidp)((char*)buf+n);
        -: 3908:    }
      218: 3909:}
        -: 3910:
        -: 3911:/* ========================================================================
        -: 3912: * Put string s in lower case, return s.
        -: 3913: */
function strlwr called 4 returned 100% blocks executed 88%
        4: 3914:char *strlwr(s)
        -: 3915:    char *s;
        -: 3916:{
        -: 3917:    char *t;
      12*: 3918:    for (t = s; *t; t++) *t = tolow(*t);
branch  0 taken 0 (fallthrough)
branch  1 taken 8
branch  2 taken 8
branch  3 taken 4 (fallthrough)
        4: 3919:    return s;
        -: 3920:}
        -: 3921:
        -: 3922:/* ========================================================================
        -: 3923: * Return the base name of a file (remove any directory prefix and
        -: 3924: * any version suffix). For systems with filenames that are not
        -: 3925: * case sensitive, force the base name to lower case.
        -: 3926: */
function basename called 214 returned 100% blocks executed 100%
      214: 3927:char *basename(fname)
        -: 3928:    char *fname;
        -: 3929:{
        -: 3930:    char *p;
        -: 3931:
      214: 3932:    if ((p = strrchr(fname, PATH_SEP))  != NULL) fname = p+1;
branch  0 taken 214 (fallthrough)
branch  1 taken 0
        -: 3933:#ifdef PATH_SEP2
        -: 3934:    if ((p = strrchr(fname, PATH_SEP2)) != NULL) fname = p+1;
        -: 3935:#endif
        -: 3936:#ifdef PATH_SEP3
        -: 3937:    if ((p = strrchr(fname, PATH_SEP3)) != NULL) fname = p+1;
        -: 3938:#endif
        -: 3939:#ifdef SUFFIX_SEP
        -: 3940:    if ((p = strrchr(fname, SUFFIX_SEP)) != NULL) *p = '\0';
        -: 3941:#endif
        -: 3942:    if (casemap('A') == 'a') strlwr(fname);
      214: 3943:    return fname;
        -: 3944:}
        -: 3945:
        -: 3946:#if defined(NO_STRING_H) && !defined(STDC_HEADERS)
        -: 3947:
        -: 3948:/* Provide missing strspn and strcspn functions. */
        -: 3949:
        -: 3950:#  ifndef __STDC__
        -: 3951:#    define const
        -: 3952:#  endif
        -: 3953:
        -: 3954:int strspn  OF((const char *s, const char *accept));
        -: 3955:int strcspn OF((const char *s, const char *reject));
        -: 3956:
        -: 3957:/* ========================================================================
        -: 3958: * Return the length of the maximum initial segment
        -: 3959: * of s which contains only characters in accept.
        -: 3960: */
        -: 3961:int strspn(s, accept)
        -: 3962:    const char *s;
        -: 3963:    const char *accept;
        -: 3964:{
        -: 3965:    register const char *p;
        -: 3966:    register const char *a;
        -: 3967:    register int count = 0;
        -: 3968:
        -: 3969:    for (p = s; *p != '\0'; ++p) {
        -: 3970:        for (a = accept; *a != '\0'; ++a) {
        -: 3971:            if (*p == *a) break;
        -: 3972:        }
        -: 3973:        if (*a == '\0') return count;
        -: 3974:        ++count;
        -: 3975:    }
        -: 3976:    return count;
        -: 3977:}
        -: 3978:
        -: 3979:/* ========================================================================
        -: 3980: * Return the length of the maximum inital segment of s
        -: 3981: * which contains no characters from reject.
        -: 3982: */
        -: 3983:int strcspn(s, reject)
        -: 3984:    const char *s;
        -: 3985:    const char *reject;
        -: 3986:{
        -: 3987:    register int count = 0;
        -: 3988:
        -: 3989:    while (*s != '\0') {
        -: 3990:        if (strchr(reject, *s++) != NULL) return count;
        -: 3991:        ++count;
        -: 3992:    }
        -: 3993:    return count;
        -: 3994:}
        -: 3995:
        -: 3996:#endif /* NO_STRING_H */
        -: 3997:
        -: 3998:/* ========================================================================
        -: 3999: * Add an environment variable (if any) before argv, and update argc.
        -: 4000: * Return the expanded environment variable to be freed later, or NULL
        -: 4001: * if no options were added to argv.
        -: 4002: */
        -: 4003:#define SEPARATOR       " \t"   /* separators in env variable */
        -: 4004:
function add_envopt called 214 returned 100% blocks executed 15%
      214: 4005:char *add_envopt(argcp, argvp, env)
        -: 4006:    int *argcp;          /* pointer to argc */
        -: 4007:    char ***argvp;       /* pointer to argv */
        -: 4008:    char *env;           /* name of environment variable */
        -: 4009:{
        -: 4010:    char *p;             /* running pointer through env variable */
        -: 4011:    char **oargv;        /* runs through old argv array */
        -: 4012:    char **nargv;        /* runs through new argv array */
      214: 4013:    int  oargc = *argcp; /* old argc */
      214: 4014:    int  nargc = 0;      /* number of arguments in env variable */
        -: 4015:
      214: 4016:    env = (char*)getenv(env);
call    0 returned 214
      214: 4017:    if (env == NULL) return NULL;
branch  0 taken 214 (fallthrough)
branch  1 taken 0
        -: 4018:
    #####: 4019:    p = (char*)xmalloc(strlen(env)+1);
call    0 never executed
    #####: 4020:    env = strcpy(p, env);                    /* keep env variable intact */
        -: 4021:
    #####: 4022:    for (p = env; *p; nargc++ ) {            /* move through env */
branch  0 never executed
branch  1 never executed
    #####: 4023:        p += strspn(p, SEPARATOR);           /* skip leading separators */
    #####: 4024:        if (*p == '\0') break;
branch  0 never executed
branch  1 never executed
        -: 4025:
    #####: 4026:        p += strcspn(p, SEPARATOR);          /* find end of word */
    #####: 4027:        if (*p) *p++ = '\0';                 /* mark it */
branch  0 never executed
branch  1 never executed
        -: 4028:    }
    #####: 4029:    if (nargc == 0) {
branch  0 never executed
branch  1 never executed
    #####: 4030:        free(env); env = NULL;
    #####: 4031:        return NULL;
        -: 4032:    }
    #####: 4033:    *argcp += nargc;
        -: 4034:    /* Allocate the new argv array, with an extra element just in case
        -: 4035:     * the original arg list did not end with a NULL.
        -: 4036:     */
    #####: 4037:    nargv = (char**)calloc(*argcp+1, sizeof(char *));
    #####: 4038:    if (nargv == NULL) error("out of memory");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 4039:    oargv  = *argvp;
    #####: 4040:    *argvp = nargv;
        -: 4041:
        -: 4042:    /* Copy the program name first */
    #####: 4043:    if (oargc-- < 0) error("argc<=0");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 4044:    *(nargv++) = *(oargv++);
        -: 4045:
        -: 4046:    /* Then copy the environment args */
    #####: 4047:    for (p = env; nargc > 0; nargc--) {
branch  0 never executed
branch  1 never executed
    #####: 4048:        p += strspn(p, SEPARATOR);           /* skip separators */
    #####: 4049:        *(nargv++) = p;                      /* store start */
    #####: 4050:        while (*p++) ;                       /* skip over word */
branch  0 never executed
branch  1 never executed
        -: 4051:    }
        -: 4052:
        -: 4053:    /* Finally copy the old args and add a NULL (usual convention) */
    #####: 4054:    while (oargc--) *(nargv++) = *(oargv++);
branch  0 never executed
branch  1 never executed
    #####: 4055:    *nargv = NULL;
    #####: 4056:    return env;
        -: 4057:}
        -: 4058:
        -: 4059:/* ========================================================================
        -: 4060: * Error handlers.
        -: 4061: */
function error called 1 returned 0% blocks executed 100%
        1: 4062:void error(m)
        -: 4063:    char *m;
        -: 4064:{
        1: 4065:    fprintf(stderr, "\n%s: %s: %s\n", progname, ifname, m);
call    0 returned 1
        1: 4066:    abort_gzip();
call    0 returned 0
    #####: 4067:}
        -: 4068:
function warn called 0 returned 0% blocks executed 0%
    #####: 4069:void warn(a, b)
        -: 4070:    char *a, *b;            /* message strings juxtaposed in output */
        -: 4071:{
    #####: 4072:    WARN((stderr, "%s: %s: warning: %s%s\n", progname, ifname, a, b));
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 4073:}
        -: 4074:
function read_error called 1 returned 0% blocks executed 83%
        1: 4075:void read_error()
        -: 4076:{
        1: 4077:    fprintf(stderr, "\n%s: ", progname);
call    0 returned 1
        1: 4078:    if (errno != 0) {
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 4079:        perror(ifname);
call    0 returned 1
        -: 4080:    } else {
    #####: 4081:        fprintf(stderr, "%s: unexpected end of file\n", ifname);
call    0 never executed
        -: 4082:    }
        1: 4083:    abort_gzip();
call    0 returned 0
    #####: 4084:}
        -: 4085:
function write_error called 0 returned 0% blocks executed 0%
    #####: 4086:void write_error()
        -: 4087:{
    #####: 4088:    fprintf(stderr, "\n%s: ", progname);
call    0 never executed
    #####: 4089:    perror(ofname);
call    0 never executed
    #####: 4090:    abort_gzip();
call    0 never executed
    #####: 4091:}
        -: 4092:
        -: 4093:/* ========================================================================
        -: 4094: * Display compression ratio on stderr.
        -: 4095: */
function display_ratio called 81 returned 100% blocks executed 60%
       81: 4096:void display_ratio(num, den)
        -: 4097:    long num;
        -: 4098:    long den;
        -: 4099:{
        -: 4100:    long ratio;  /* 1000 times the compression ratio */
        -: 4101:
       81: 4102:    if (den == 0) {
branch  0 taken 0 (fallthrough)
branch  1 taken 81
    #####: 4103:        ratio = 0; /* no compression */
       81: 4104:    } else if (den < 2147483L) { /* (2**31 -1)/1000 */
branch  0 taken 81 (fallthrough)
branch  1 taken 0
       81: 4105:        ratio = 1000L*num/den;
        -: 4106:    } else {
    #####: 4107:        ratio = num/(den/1000L);
        -: 4108:    }
       81: 4109:    if (ratio < 0) {
branch  0 taken 0 (fallthrough)
branch  1 taken 81
    #####: 4110:        putc('-', stderr);
call    0 never executed
    #####: 4111:        ratio = -ratio;
        -: 4112:    }
       81: 4113:    fprintf(stderr, "%2ld.%ld%%", ratio / 10L, ratio % 10L);
call    0 returned 81
       81: 4114:}
        -: 4115:
        -: 4116:
        -: 4117:/* ========================================================================
        -: 4118: * Semi-safe malloc -- never returns NULL.
        -: 4119: */
function xmalloc called 0 returned 0% blocks executed 0%
    #####: 4120:voidp xmalloc (size)
        -: 4121:    unsigned size;
        -: 4122:{
    #####: 4123:    voidp cp = (voidp)malloc (size);
        -: 4124:
    #####: 4125:    if (cp == NULL) error("out of memory");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 4126:    return cp;
        -: 4127:}
        -: 4128:
        -: 4129:/* ========================================================================
        -: 4130: * Table of CRC-32's of all single-byte values (made by makecrc.c)
        -: 4131: */
        -: 4132:ulg crc_32_tab[] = {
        -: 4133:  0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL, 0x076dc419L,
        -: 4134:  0x706af48fL, 0xe963a535L, 0x9e6495a3L, 0x0edb8832L, 0x79dcb8a4L,
        -: 4135:  0xe0d5e91eL, 0x97d2d988L, 0x09b64c2bL, 0x7eb17cbdL, 0xe7b82d07L,
        -: 4136:  0x90bf1d91L, 0x1db71064L, 0x6ab020f2L, 0xf3b97148L, 0x84be41deL,
        -: 4137:  0x1adad47dL, 0x6ddde4ebL, 0xf4d4b551L, 0x83d385c7L, 0x136c9856L,
        -: 4138:  0x646ba8c0L, 0xfd62f97aL, 0x8a65c9ecL, 0x14015c4fL, 0x63066cd9L,
        -: 4139:  0xfa0f3d63L, 0x8d080df5L, 0x3b6e20c8L, 0x4c69105eL, 0xd56041e4L,
        -: 4140:  0xa2677172L, 0x3c03e4d1L, 0x4b04d447L, 0xd20d85fdL, 0xa50ab56bL,
        -: 4141:  0x35b5a8faL, 0x42b2986cL, 0xdbbbc9d6L, 0xacbcf940L, 0x32d86ce3L,
        -: 4142:  0x45df5c75L, 0xdcd60dcfL, 0xabd13d59L, 0x26d930acL, 0x51de003aL,
        -: 4143:  0xc8d75180L, 0xbfd06116L, 0x21b4f4b5L, 0x56b3c423L, 0xcfba9599L,
        -: 4144:  0xb8bda50fL, 0x2802b89eL, 0x5f058808L, 0xc60cd9b2L, 0xb10be924L,
        -: 4145:  0x2f6f7c87L, 0x58684c11L, 0xc1611dabL, 0xb6662d3dL, 0x76dc4190L,
        -: 4146:  0x01db7106L, 0x98d220bcL, 0xefd5102aL, 0x71b18589L, 0x06b6b51fL,
        -: 4147:  0x9fbfe4a5L, 0xe8b8d433L, 0x7807c9a2L, 0x0f00f934L, 0x9609a88eL,
        -: 4148:  0xe10e9818L, 0x7f6a0dbbL, 0x086d3d2dL, 0x91646c97L, 0xe6635c01L,
        -: 4149:  0x6b6b51f4L, 0x1c6c6162L, 0x856530d8L, 0xf262004eL, 0x6c0695edL,
        -: 4150:  0x1b01a57bL, 0x8208f4c1L, 0xf50fc457L, 0x65b0d9c6L, 0x12b7e950L,
        -: 4151:  0x8bbeb8eaL, 0xfcb9887cL, 0x62dd1ddfL, 0x15da2d49L, 0x8cd37cf3L,
        -: 4152:  0xfbd44c65L, 0x4db26158L, 0x3ab551ceL, 0xa3bc0074L, 0xd4bb30e2L,
        -: 4153:  0x4adfa541L, 0x3dd895d7L, 0xa4d1c46dL, 0xd3d6f4fbL, 0x4369e96aL,
        -: 4154:  0x346ed9fcL, 0xad678846L, 0xda60b8d0L, 0x44042d73L, 0x33031de5L,
        -: 4155:  0xaa0a4c5fL, 0xdd0d7cc9L, 0x5005713cL, 0x270241aaL, 0xbe0b1010L,
        -: 4156:  0xc90c2086L, 0x5768b525L, 0x206f85b3L, 0xb966d409L, 0xce61e49fL,
        -: 4157:  0x5edef90eL, 0x29d9c998L, 0xb0d09822L, 0xc7d7a8b4L, 0x59b33d17L,
        -: 4158:  0x2eb40d81L, 0xb7bd5c3bL, 0xc0ba6cadL, 0xedb88320L, 0x9abfb3b6L,
        -: 4159:  0x03b6e20cL, 0x74b1d29aL, 0xead54739L, 0x9dd277afL, 0x04db2615L,
        -: 4160:  0x73dc1683L, 0xe3630b12L, 0x94643b84L, 0x0d6d6a3eL, 0x7a6a5aa8L,
        -: 4161:  0xe40ecf0bL, 0x9309ff9dL, 0x0a00ae27L, 0x7d079eb1L, 0xf00f9344L,
        -: 4162:  0x8708a3d2L, 0x1e01f268L, 0x6906c2feL, 0xf762575dL, 0x806567cbL,
        -: 4163:  0x196c3671L, 0x6e6b06e7L, 0xfed41b76L, 0x89d32be0L, 0x10da7a5aL,
        -: 4164:  0x67dd4accL, 0xf9b9df6fL, 0x8ebeeff9L, 0x17b7be43L, 0x60b08ed5L,
        -: 4165:  0xd6d6a3e8L, 0xa1d1937eL, 0x38d8c2c4L, 0x4fdff252L, 0xd1bb67f1L,
        -: 4166:  0xa6bc5767L, 0x3fb506ddL, 0x48b2364bL, 0xd80d2bdaL, 0xaf0a1b4cL,
        -: 4167:  0x36034af6L, 0x41047a60L, 0xdf60efc3L, 0xa867df55L, 0x316e8eefL,
        -: 4168:  0x4669be79L, 0xcb61b38cL, 0xbc66831aL, 0x256fd2a0L, 0x5268e236L,
        -: 4169:  0xcc0c7795L, 0xbb0b4703L, 0x220216b9L, 0x5505262fL, 0xc5ba3bbeL,
        -: 4170:  0xb2bd0b28L, 0x2bb45a92L, 0x5cb36a04L, 0xc2d7ffa7L, 0xb5d0cf31L,
        -: 4171:  0x2cd99e8bL, 0x5bdeae1dL, 0x9b64c2b0L, 0xec63f226L, 0x756aa39cL,
        -: 4172:  0x026d930aL, 0x9c0906a9L, 0xeb0e363fL, 0x72076785L, 0x05005713L,
        -: 4173:  0x95bf4a82L, 0xe2b87a14L, 0x7bb12baeL, 0x0cb61b38L, 0x92d28e9bL,
        -: 4174:  0xe5d5be0dL, 0x7cdcefb7L, 0x0bdbdf21L, 0x86d3d2d4L, 0xf1d4e242L,
        -: 4175:  0x68ddb3f8L, 0x1fda836eL, 0x81be16cdL, 0xf6b9265bL, 0x6fb077e1L,
        -: 4176:  0x18b74777L, 0x88085ae6L, 0xff0f6a70L, 0x66063bcaL, 0x11010b5cL,
        -: 4177:  0x8f659effL, 0xf862ae69L, 0x616bffd3L, 0x166ccf45L, 0xa00ae278L,
        -: 4178:  0xd70dd2eeL, 0x4e048354L, 0x3903b3c2L, 0xa7672661L, 0xd06016f7L,
        -: 4179:  0x4969474dL, 0x3e6e77dbL, 0xaed16a4aL, 0xd9d65adcL, 0x40df0b66L,
        -: 4180:  0x37d83bf0L, 0xa9bcae53L, 0xdebb9ec5L, 0x47b2cf7fL, 0x30b5ffe9L,
        -: 4181:  0xbdbdf21cL, 0xcabac28aL, 0x53b39330L, 0x24b4a3a6L, 0xbad03605L,
        -: 4182:  0xcdd70693L, 0x54de5729L, 0x23d967bfL, 0xb3667a2eL, 0xc4614ab8L,
        -: 4183:  0x5d681b02L, 0x2a6f2b94L, 0xb40bbe37L, 0xc30c8ea1L, 0x5a05df1bL,
        -: 4184:  0x2d02ef8dL
        -: 4185:};
        -: 4186:/* zip.c -- compress files to the gzip or pkzip format
        -: 4187: * Copyright (C) 1992-1993 Jean-loup Gailly
        -: 4188: * This is free software; you can redistribute it and/or modify it under the
        -: 4189: * terms of the GNU General Public License, see the file COPYING.
        -: 4190: */
        -: 4191:
        -: 4192:/*
        -: 4193:#ifndef lint
        -: 4194:static char rcsid[] = "$Id: zip.c,v 0.15 1993/03/18 18:14:56 jloup Exp $";
        -: 4195:#endif
        -: 4196:*/
        -: 4197:
        -: 4198:#ifdef HAVE_UNISTD_H
        -: 4199:#  include <sys/types.h>
        -: 4200:#  include <unistd.h>
        -: 4201:#endif
        -: 4202:
        -: 4203:local ulg crc;       /* crc on uncompressed file data */
        -: 4204:long overhead;       /* number of bytes in gzip header */
        -: 4205:
        -: 4206:/* ===========================================================================
        -: 4207: * Deflate in to out.
        -: 4208: * IN assertions: the input and output buffers are cleared.
        -: 4209: *   The variables time_stamp and save_orig_name are initialized.
        -: 4210: */
function zip called 177 returned 100% blocks executed 44%
      177: 4211:void zip(in, out)
        -: 4212:    int in, out;            /* input and output file descriptors */
        -: 4213:{
      177: 4214:    uch  flags = 0;         /* general purpose bit flags */
      177: 4215:    ush  attr = 0;          /* ascii/binary flag */
      177: 4216:    ush  deflate_flags = 0; /* pkzip -es, -en or -ex equivalent */
        -: 4217:
      177: 4218:    ifd = in;
      177: 4219:    ofd = out;
      177: 4220:    outcnt = 0;
        -: 4221:
        -: 4222:    /* Write the header to the gzip file. See algorithm.doc for the format */
        -: 4223:
      177: 4224:    method = DEFLATED;
     177*: 4225:    put_byte(GZIP_MAGIC[0]); /* magic header */
branch  0 taken 0 (fallthrough)
branch  1 taken 177
call    2 never executed
     177*: 4226:    put_byte(GZIP_MAGIC[1]);
branch  0 taken 0 (fallthrough)
branch  1 taken 177
call    2 never executed
     177*: 4227:    put_byte(DEFLATED);      /* compression method */
branch  0 taken 0 (fallthrough)
branch  1 taken 177
call    2 never executed
        -: 4228:
      177: 4229:    if (save_orig_name) {
branch  0 taken 0 (fallthrough)
branch  1 taken 177
    #####: 4230:        flags |= ORIG_NAME;
        -: 4231:    }
     177*: 4232:    put_byte(flags);         /* general flags */
branch  0 taken 0 (fallthrough)
branch  1 taken 177
call    2 never executed
     177*: 4233:    put_long(time_stamp);
branch  0 taken 177 (fallthrough)
branch  1 taken 0
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
branch  8 taken 177 (fallthrough)
branch  9 taken 0
branch 10 never executed
branch 11 never executed
call   12 never executed
branch 13 never executed
branch 14 never executed
call   15 never executed
        -: 4234:
        -: 4235:    /* Write deflated file to zip file */
      177: 4236:    crc = updcrc(0, 0);
call    0 returned 177
        -: 4237:
      177: 4238:    bi_init(out);
call    0 returned 177
      177: 4239:    ct_init(&attr, &method);
call    0 returned 177
      177: 4240:    lm_init(level, &deflate_flags);
call    0 returned 177
        -: 4241:
     177*: 4242:    put_byte((uch)deflate_flags); /* extra flags */
branch  0 taken 0 (fallthrough)
branch  1 taken 177
call    2 never executed
     177*: 4243:    put_byte(OS_CODE);            /* OS identifier */
branch  0 taken 0 (fallthrough)
branch  1 taken 177
call    2 never executed
        -: 4244:
      177: 4245:    if (save_orig_name) {
branch  0 taken 0 (fallthrough)
branch  1 taken 177
    #####: 4246:        char *p = basename(ifname); /* Don't save the directory part. */
call    0 never executed
        -: 4247:        do {
    #####: 4248:            put_byte(*p);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 4249:        } while (*p++);
branch  0 never executed
branch  1 never executed
        -: 4250:    }
      177: 4251:    overhead = (long)outcnt;
        -: 4252:
      177: 4253:    (void)deflate();
call    0 returned 177
        -: 4254:
        -: 4255:#if !defined(NO_SIZE_CHECK) && !defined(RECORD_IO)
        -: 4256:  /* Check input size (but not in VMS -- variable record lengths mess it up)
        -: 4257:   * and not on MSDOS -- diet in TSR mode reports an incorrect file size)
        -: 4258:   */
        -: 4259:    if (ifile_size != -1L && isize != (ulg)ifile_size) {
        -: 4260:        Trace((stderr, " actual=%ld, read=%ld ", ifile_size, isize));
        -: 4261:        fprintf(stderr, "%s: %s: file size changed while zipping\n",
        -: 4262:                progname, ifname);
        -: 4263:    }
        -: 4264:#endif
        -: 4265:
        -: 4266:    /* Write the crc and uncompressed size */
     177*: 4267:    put_long(crc);
branch  0 taken 177 (fallthrough)
branch  1 taken 0
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
branch  8 taken 177 (fallthrough)
branch  9 taken 0
branch 10 never executed
branch 11 never executed
call   12 never executed
branch 13 never executed
branch 14 never executed
call   15 never executed
     177*: 4268:    put_long(isize);
branch  0 taken 177 (fallthrough)
branch  1 taken 0
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
branch  8 taken 177 (fallthrough)
branch  9 taken 0
branch 10 never executed
branch 11 never executed
call   12 never executed
branch 13 never executed
branch 14 never executed
call   15 never executed
        -: 4269:
      177: 4270:    flush_outbuf();
call    0 returned 177
      177: 4271:}
        -: 4272:
        -: 4273:
        -: 4274:/* ===========================================================================
        -: 4275: * Read a new buffer from the current input file, perform end-of-line
        -: 4276: * translation, and update the crc and input file size.
        -: 4277: * IN assertion: size >= 2 (for end-of-line translation)
        -: 4278: */
function file_read called 3572 returned 100% blocks executed 100%
     3572: 4279:int file_read(buf, size)
        -: 4280:    char *buf;
        -: 4281:    unsigned size;
        -: 4282:{
        -: 4283:    unsigned len;
        -: 4284:
        -: 4285:    Assert(insize == 0, "inbuf not empty");
        -: 4286:
     3572: 4287:    len = read(ifd, buf, size);
call    0 returned 3572
     3572: 4288:    if (len == (unsigned)(-1) || len == 0) return (int)len;
branch  0 taken 3569 (fallthrough)
branch  1 taken 3
branch  2 taken 174 (fallthrough)
branch  3 taken 3395
        -: 4289:
     3395: 4290:    crc = updcrc((uch*)buf, len);
call    0 returned 3395
     3395: 4291:    isize += (ulg)len;
     3395: 4292:    return (int)len;
        -: 4293:}
        -: 4294:/* gzip (GNU zip) -- compress files with zip algorithm and 'compress' interface
        -: 4295: * Copyright (C) 1992-1993 Jean-loup Gailly
        -: 4296: * The unzip code was written and put in the public domain by Mark Adler.
        -: 4297: * Portions of the lzw code are derived from the public domain 'compress'
        -: 4298: * written by Spencer Thomas, Joe Orost, James Woods, Jim McKie, Steve Davies,
        -: 4299: * Ken Turkowski, Dave Mack and Peter Jannesen.
        -: 4300: *
        -: 4301: * See the license_msg below and the file COPYING for the software license.
        -: 4302: * See the file algorithm.doc for the compression algorithms and file formats.
        -: 4303: */
        -: 4304:
        -: 4305:static char  *license_msg[] = {
        -: 4306:"   Copyright (C) 1992-1993 Jean-loup Gailly",
        -: 4307:"   This program is free software; you can redistribute it and/or modify",
        -: 4308:"   it under the terms of the GNU General Public License as published by",
        -: 4309:"   the Free Software Foundation; either version 2, or (at your option)",
        -: 4310:"   any later version.",
        -: 4311:"",
        -: 4312:"   This program is distributed in the hope that it will be useful,",
        -: 4313:"   but WITHOUT ANY WARRANTY; without even the implied warranty of",
        -: 4314:"   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
        -: 4315:"   GNU General Public License for more details.",
        -: 4316:"",
        -: 4317:"   You should have received a copy of the GNU General Public License",
        -: 4318:"   along with this program; if not, write to the Free Software",
        -: 4319:"   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.",
        -: 4320:0};
        -: 4321:
        -: 4322:/* Compress files with zip algorithm and 'compress' interface.
        -: 4323: * See usage() and help() functions below for all options.
        -: 4324: * Outputs:
        -: 4325: *        file.z:   compressed file with same mode, owner, and utimes
        -: 4326: *        file.Z:   same with -Z option (old compress format)
        -: 4327: *     or stdout with -c option or if stdin used as input.
        -: 4328: * If the OS does not support file names with multiple dots (MSDOS, VMS) or
        -: 4329: * if the output file name had to be truncated, the original name is kept
        -: 4330: * in the compressed .z file. (Feature not available in old compress format.)
        -: 4331: * On MSDOS, file.tmp -> file.tmz. On VMS, file.tmp -> file.tmp-z.
        -: 4332: *
        -: 4333: * For the meaning of all compilation flags, see comments in Makefile.in.
        -: 4334: */
        -: 4335:
        -: 4336:/*
        -: 4337:#ifndef lint
        -: 4338:static char rcsid[] = "$Id: gzip.c,v 0.17 1993/03/18 18:14:56 jloup Exp $";
        -: 4339:#endif
        -: 4340:*/
        -: 4341:
        -: 4342:                /* configuration */
        -: 4343:
        -: 4344:#ifndef NO_FCNTL_H
        -: 4345:#  include <fcntl.h>
        -: 4346:#endif
        -: 4347:
        -: 4348:#ifdef HAVE_UNISTD_H
        -: 4349:#  include <unistd.h>
        -: 4350:#endif
        -: 4351:
        -: 4352:#if defined(STDC_HEADERS) || !defined(NO_STDLIB_H)
        -: 4353:#  include <stdlib.h>
        -: 4354:#else
        -: 4355:   extern int errno;
        -: 4356:#endif
        -: 4357:
        -: 4358:#if defined(DIRENT) || defined(_POSIX_VERSION)
        -: 4359:#  include <dirent.h>
        -: 4360:   typedef struct dirent dir_type;
        -: 4361:#  define NLENGTH(dirent) ((int)strlen((dirent)->d_name))
        -: 4362:#  define DIR_OPT "DIRENT"
        -: 4363:#else
        -: 4364:#  define NLENGTH(dirent) ((dirent)->d_namlen)
        -: 4365:#  ifdef SYSDIR
        -: 4366:#    include <sys/dir.h>
        -: 4367:     typedef struct direct dir_type;
        -: 4368:#    define DIR_OPT "SYSDIR"
        -: 4369:#  else
        -: 4370:#    ifdef SYSNDIR
        -: 4371:#      include <sys/ndir.h>
        -: 4372:       typedef struct direct dir_type;
        -: 4373:#      define DIR_OPT "SYSNDIR"
        -: 4374:#    else
        -: 4375:#      ifdef NDIR
        -: 4376:#        include <ndir.h>
        -: 4377:         typedef struct direct dir_type;
        -: 4378:#        define DIR_OPT "NDIR"
        -: 4379:#      else
        -: 4380:#        define NO_DIR
        -: 4381:#        define DIR_OPT "NO_DIR"
        -: 4382:#      endif
        -: 4383:#    endif
        -: 4384:#  endif
        -: 4385:#endif
        -: 4386:
        -: 4387:#ifndef NO_UTIME
        -: 4388:#  ifndef NO_UTIME_H
        -: 4389:#    include <utime.h>
        -: 4390:#    define TIME_OPT "UTIME"
        -: 4391:#  else
        -: 4392:#    ifdef HAVE_SYS_UTIME_H
        -: 4393:#      include <sys/utime.h>
        -: 4394:#      define TIME_OPT "SYS_UTIME"
        -: 4395:#    else
        -: 4396:       struct utimbuf {
        -: 4397:         time_t actime;
        -: 4398:         time_t modtime;
        -: 4399:       };
        -: 4400:#      define TIME_OPT ""
        -: 4401:#    endif
        -: 4402:#  endif
        -: 4403:#else
        -: 4404:#  define TIME_OPT "NO_UTIME"
        -: 4405:#endif
        -: 4406:
        -: 4407:#if !defined(S_ISDIR) && defined(S_IFDIR)
        -: 4408:#  define S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)
        -: 4409:#endif
        -: 4410:#if !defined(S_ISREG) && defined(S_IFREG)
        -: 4411:#  define S_ISREG(m) (((m) & S_IFMT) == S_IFREG)
        -: 4412:#endif
        -: 4413:
        -: 4414:typedef RETSIGTYPE (*sig_type)();
        -: 4415:
        -: 4416:#ifndef O_BINARY
        -: 4417:#  define  O_BINARY  0  /* creation mode for open() */
        -: 4418:#endif
        -: 4419:
        -: 4420:#ifndef O_CREAT
        -: 4421:   /* Pure BSD system? */
        -: 4422:#  include <sys/file.h>
        -: 4423:#  ifndef O_CREAT
        -: 4424:#    define O_CREAT FCREAT
        -: 4425:#  endif
        -: 4426:#  ifndef O_EXCL
        -: 4427:#    define O_EXCL FEXCL
        -: 4428:#  endif
        -: 4429:#endif
        -: 4430:
        -: 4431:#define RW_USER 0600    /* creation mode for open() */
        -: 4432:
        -: 4433:#ifndef MAX_PATH_LEN
        -: 4434:#  define MAX_PATH_LEN   1024 /* max pathname length */
        -: 4435:#endif
        -: 4436:
        -: 4437:#define MAX_HEADER_LEN   16
        -: 4438:/* max length of a compressed file header, fixed part only */
        -: 4439:
        -: 4440:                /* global buffers */
        -: 4441:
        -: 4442:DECLARE(uch, inbuf,  INBUFSIZ +INBUF_EXTRA);
        -: 4443:DECLARE(uch, outbuf, OUTBUFSIZ+OUTBUF_EXTRA);
        -: 4444:DECLARE(ush, d_buf,  DIST_BUFSIZE);
        -: 4445:DECLARE(uch, window, 2L*WSIZE);
        -: 4446:#ifndef MAXSEG_64K
        -: 4447:    DECLARE(ush, tab_prefix, 1L<<BITS);
        -: 4448:#else
        -: 4449:    DECLARE(ush, tab_prefix0, 1L<<(BITS-1));
        -: 4450:    DECLARE(ush, tab_prefix1, 1L<<(BITS-1));
        -: 4451:#endif
        -: 4452:
        -: 4453:                /* local variables */
        -: 4454:
        -: 4455:int to_stdout = 0;    /* output to stdout (-c) */
        -: 4456:int decompress = 0;   /* decompress (-d) */
        -: 4457:int force = 0;        /* don't ask questions, compress links (-f) */
        -: 4458:int recursive = 0;    /* recurse through directories (-r) */
        -: 4459:int verbose = 0;      /* be verbose (-v) */
        -: 4460:int quiet = 0;        /* be very quiet (-q) */
        -: 4461:int quit_on_tty = 0;  /* quit if compressing to or decompressing from a tty */
        -: 4462:int do_lzw = 0;       /* generate output compatible with old compress (-Z) */
        -: 4463:int test = 0;         /* test .z file integrity */
        -: 4464:int foreground;       /* set if program run in foreground */
        -: 4465:char *progname;       /* program name */
        -: 4466:int maxbits = BITS;   /* max bits per code for LZW */
        -: 4467:int method = DEFLATED;/* compression method */
        -: 4468:int level = 5;        /* compression level */
        -: 4469:int exit_code = OK;   /* program exit code */
        -: 4470:int save_orig_name;   /* set if original name must be saved */
        -: 4471:int last_member;      /* set for .zip and .Z files */
        -: 4472:int part_nb;          /* number of parts in .z file */
        -: 4473:ulg time_stamp;       /* original time stamp (modification time) */
        -: 4474:long ifile_size;      /* input file size, -1 for devices (debug only) */
        -: 4475:char *env;            /* contents of GZIP env variable */
        -: 4476:char **args = NULL;   /* argv pointer if GZIP env variable defined */
        -: 4477:
        -: 4478:long bytes_in;             /* number of input bytes */
        -: 4479:long bytes_out;            /* number of output bytes */
        -: 4480:char ifname[MAX_PATH_LEN]; /* input filename */
        -: 4481:char ofname[MAX_PATH_LEN]; /* output filename */
        -: 4482:int  remove_ofname = 0;    /* remove output file on error */
        -: 4483:struct stat istat;         /* status for input file */
        -: 4484:int  ifd;                  /* input file descriptor */
        -: 4485:int  ofd;                  /* output file descriptor */
        -: 4486:unsigned insize;           /* valid bytes in inbuf */
        -: 4487:unsigned inptr;            /* index of next byte to be processed in inbuf */
        -: 4488:unsigned outcnt;           /* bytes in output buffer */
        -: 4489:
        -: 4490:struct option longopts[] =
        -: 4491:{
        -: 4492: /* { name  has_arg  *flag  val } */
        -: 4493: /* {"ascii",      0, 0, 'a'},  ascii text mode */
        -: 4494:    {"stdout",     0, 0, 'c'}, /* write output on standard output */
        -: 4495:    {"decompress", 0, 0, 'd'}, /* decompress */
        -: 4496:    {"uncompress", 0, 0, 'd'}, /* decompress */
        -: 4497: /* {"encrypt",    0, 0, 'e'},    encrypt */
        -: 4498:    {"force",      0, 0, 'f'}, /* force overwrite of output file */
        -: 4499:    {"help",       0, 0, 'h'}, /* give help */
        -: 4500: /* {"pkzip",      0, 0, 'k'},    force output in pkzip format */
        -: 4501: /* {"list",       0, 0, 'l'},    list .z file contents */
        -: 4502:    {"license",    0, 0, 'L'}, /* display software license */
        -: 4503:    {"quiet",      0, 0, 'q'}, /* quiet mode */
        -: 4504:    {"recurse",    0, 0, 'r'}, /* recurse through directories */
        -: 4505:    {"test",       0, 0, 't'}, /* test compressed file integrity */
        -: 4506:    {"verbose",    0, 0, 'v'}, /* verbose mode */
        -: 4507:    {"version",    0, 0, 'V'}, /* display version number */
        -: 4508:    {"fast",       0, 0, '1'}, /* compress faster */
        -: 4509:    {"best",       0, 0, '9'}, /* compress better */
        -: 4510:    {"lzw",        0, 0, 'Z'}, /* make output compatible with old compress */
        -: 4511:    {"bits",       1, 0, 'b'}, /* max number of bits per code (implies -Z) */
        -: 4512:    { 0, 0, 0, 0 }
        -: 4513:};
        -: 4514:
        -: 4515:/* local functions */
        -: 4516:
        -: 4517:local void usage        OF((void));
        -: 4518:local void help         OF((void));
        -: 4519:local void license      OF((void));
        -: 4520:local void version      OF((void));
        -: 4521:local void treat_stdin  OF((void));
        -: 4522:local void treat_file   OF((char *iname));
        -: 4523:local int create_outfile OF((void));
        -: 4524:local int  do_stat      OF((char *name, struct stat *sbuf));
        -: 4525:local char *get_suffix  OF((char *name));
        -: 4526:local int  get_istat    OF((char *iname, struct stat *sbuf));
        -: 4527:local int  make_ofname  OF((void));
        -: 4528:local int  same_file    OF((struct stat *stat1, struct stat *stat2));
        -: 4529:local int name_too_long OF((char *name, struct stat *statb));
        -: 4530:local int  get_method   OF((int in));
        -: 4531:local int  check_ofname OF((void));
        -: 4532:local void reset_times  OF((char *name, struct stat *statb));
        -: 4533:local void copy_stat    OF((struct stat *ifstat));
        -: 4534:local void treat_dir    OF((char *dir));
        -: 4535:local void do_exit      OF((int exitcode));
        -: 4536:      int main          OF((int argc, char **argv));
        -: 4537:
        -: 4538:void (*work) OF((int infile, int outfile)) = zip; /* function to call */
        -: 4539:
        -: 4540:#define strequ(s1, s2) (strcmp((s1),(s2)) == 0)
        -: 4541:
        -: 4542:/* ======================================================================== */
function usage called 2 returned 100% blocks executed 100%
        2: 4543:local void usage()
        -: 4544:{
        2: 4545:    fprintf(stderr,
call    0 returned 2
        -: 4546:#ifdef LZW
        -: 4547:#  ifdef NO_DIR
        -: 4548:            "usage: %s [-cdfhLtvVZ19] [-b maxbits] [file ...]\n",
        -: 4549:#  else
        -: 4550:            "usage: %s [-cdfhLrtvVZ19] [-b maxbits] [file ...]\n",
        -: 4551:#  endif
        -: 4552:#else /* !LZW */
        -: 4553:#  ifdef NO_DIR
        -: 4554:            "usage: %s [-cdfhLtvV19] [file ...]\n",
        -: 4555:#  else
        -: 4556:            "usage: %s [-cdfhLrtvV19] [file ...]\n",
        -: 4557:#  endif
        -: 4558:#endif /* LZW */
        -: 4559:             progname);
        2: 4560:}
        -: 4561:/* ======================================================================== */
function help called 2 returned 100% blocks executed 100%
        2: 4562:local void help()
        -: 4563:{
        -: 4564:    static char  *help_msg[] = {
        -: 4565:/* -a --ascii       ascii text; convert end-of-lines to local OS conventions */
        -: 4566: " -c --stdout      write on standard output, keep original files unchanged",
        -: 4567: " -d --decompress  decompress",
        -: 4568:/* -e --encrypt     encrypt */
        -: 4569: " -f --force       force overwrite of output file and compress links",
        -: 4570: " -h --help        give this help",
        -: 4571:/* -k --pkzip       force output in pkzip format */
        -: 4572:/* -l --list        list .z file contents */
        -: 4573: " -L --license     display software license",
        -: 4574: " -q --quiet       suppress all warnings",
        -: 4575:#ifndef NO_DIR
        -: 4576: " -r --recurse     recurse through directories",
        -: 4577:#endif
        -: 4578: " -t --test        test compressed file integrity",
        -: 4579: " -v --verbose     verbose mode",
        -: 4580: " -V --version     display version number",
        -: 4581: " -1 --fast        compress faster",
        -: 4582: " -9 --best        compress better",
        -: 4583:#ifdef LZW
        -: 4584: " -Z --lzw         produce output compatible with old compress",
        -: 4585: " -b --bits maxbits   max number of bits per code (implies -Z)",
        -: 4586:#endif
        -: 4587: " file...          files to (de)compress. If none given, use standard input.",
        -: 4588:  0};
        2: 4589:    char **p = help_msg;
        -: 4590:
        2: 4591:    fprintf(stderr,"%s %s (%s)\n", progname, VERSION, REVDATE);
call    0 returned 2
        2: 4592:    usage();
call    0 returned 2
       28: 4593:    while (*p) fprintf(stderr, "%s\n", *p++);
call    0 returned 26
branch  1 taken 26
branch  2 taken 2 (fallthrough)
        2: 4594:}
        -: 4595:
        -: 4596:/* ======================================================================== */
function license called 2 returned 100% blocks executed 100%
        2: 4597:local void license()
        -: 4598:{
        2: 4599:    char **p = license_msg;
        -: 4600:
        2: 4601:    fprintf(stderr,"%s %s (%s)\n", progname, VERSION, REVDATE);
call    0 returned 2
       30: 4602:    while (*p) fprintf(stderr, "%s\n", *p++);
call    0 returned 28
branch  1 taken 28
branch  2 taken 2 (fallthrough)
        2: 4603:}
        -: 4604:
        -: 4605:/* ======================================================================== */
function version called 2 returned 100% blocks executed 100%
        2: 4606:local void version()
        -: 4607:{
        2: 4608:    fprintf(stderr,"%s %s (%s)\n", progname, VERSION, REVDATE);
call    0 returned 2
        -: 4609:
        2: 4610:    fprintf(stderr, "Compilation options:\n%s %s ", DIR_OPT, TIME_OPT);
call    0 returned 2
        -: 4611:#ifdef STDC_HEADERS
        2: 4612:    fprintf(stderr, "STDC_HEADERS ");
call    0 returned 2
        -: 4613:#endif
        -: 4614:#ifdef HAVE_UNISTD_H
        2: 4615:    fprintf(stderr, "HAVE_UNISTD_H ");
call    0 returned 2
        -: 4616:#endif
        -: 4617:#ifdef NO_MEMORY_H
        -: 4618:    fprintf(stderr, "NO_MEMORY_H ");
        -: 4619:#endif
        -: 4620:#ifdef NO_STRING_H
        -: 4621:    fprintf(stderr, "NO_STRING_H ");
        -: 4622:#endif
        -: 4623:#ifdef NO_SYMLINK
        -: 4624:    fprintf(stderr, "NO_SYMLINK ");
        -: 4625:#endif
        -: 4626:#ifdef NO_MULTIPLE_DOTS
        -: 4627:    fprintf(stderr, "NO_MULTIPLE_DOTS ");
        -: 4628:#endif
        -: 4629:#ifdef NO_CHOWN
        -: 4630:    fprintf(stderr, "NO_CHOWN ");
        -: 4631:#endif
        -: 4632:#ifdef PROTO
        -: 4633:    fprintf(stderr, "PROTO ");
        -: 4634:#endif
        -: 4635:#ifdef ASMV
        -: 4636:    fprintf(stderr, "ASMV ");
        -: 4637:#endif
        -: 4638:#ifdef DEBUG
        -: 4639:    fprintf(stderr, "DEBUG ");
        -: 4640:#endif
        -: 4641:#ifdef DYN_ALLOC
        -: 4642:    fprintf(stderr, "DYN_ALLOC ");
        -: 4643:#endif
        -: 4644:#ifdef MAXSEG_64K
        -: 4645:    fprintf(stderr, "MAXSEG_64K");
        -: 4646:#endif
        2: 4647:    fprintf(stderr, "\n");
call    0 returned 2
        2: 4648:}
        -: 4649:
        -: 4650:/* ======================================================================== */
function main called 214 returned 0% blocks executed 78%
      214: 4651:int main (argc, argv)
        -: 4652:    int argc;
        -: 4653:    char **argv;
        -: 4654:{
      214: 4655:    int file_count = 0; /* number of files to precess */
        -: 4656:    int proglen;        /* length of progname */
        -: 4657:    int optc;           /* current option */
        -: 4658:
        -: 4659:    EXPAND(argc, argv); /* wild card expansion if necessary */
        -: 4660:
      214: 4661:    progname = basename(argv[0]);
call    0 returned 214
      214: 4662:    proglen = strlen(progname);
        -: 4663:
        -: 4664:    /* Suppress .exe for MSDOS, OS/2 and VMS: */
      214: 4665:    if (proglen > 4 && strequ(progname+proglen-4, ".exe")) {
branch  0 taken 214 (fallthrough)
branch  1 taken 0
branch  2 taken 214 (fallthrough)
branch  3 taken 0
      214: 4666:        progname[proglen-4] = '\0';
        -: 4667:    }
        -: 4668:
        -: 4669:    /* Add options in GZIP environment variable if there is one */
      214: 4670:    env = add_envopt(&argc, &argv, OPTIONS_VAR);
call    0 returned 214
     214*: 4671:    if (env != NULL) args = argv;
branch  0 taken 0 (fallthrough)
branch  1 taken 214
        -: 4672:
      214: 4673:    foreground = signal(SIGINT, SIG_IGN) != SIG_IGN;
call    0 returned 214
      214: 4674:    if (foreground) {
branch  0 taken 213 (fallthrough)
branch  1 taken 1
      213: 4675:        signal (SIGINT, (sig_type)abort_gzip);
call    0 returned 213
        -: 4676:    }
        -: 4677:#ifdef SIGTERM
      214: 4678:    signal(SIGTERM, (sig_type)abort_gzip);
call    0 returned 214
        -: 4679:#endif
        -: 4680:#ifdef SIGHUP
      214: 4681:    signal(SIGHUP,  (sig_type)abort_gzip);
call    0 returned 214
        -: 4682:#endif
        -: 4683:
        -: 4684:#ifndef GNU_STANDARD
        -: 4685:    /* For compatibility with old compress, use program name as an option.
        -: 4686:     * If you compile with -DGNU_STANDARD, this program will behave as
        -: 4687:     * gzip even if it is invoked under the name gunzip or zcat.
        -: 4688:     *
        -: 4689:     * Systems which do not support links can still use -d or -dc.
        -: 4690:     * Ignore an .exe extension for MSDOS, OS/2 and VMS.
        -: 4691:     */
      214: 4692:    if (  strncmp(progname, "un",  2) == 0     /* ungzip, uncompress */
branch  0 taken 214 (fallthrough)
branch  1 taken 0
      214: 4693:       || strncmp(progname, "gun", 3) == 0) {  /* gunzip */
branch  0 taken 0 (fallthrough)
branch  1 taken 214
    #####: 4694:        decompress = 1;
      214: 4695:    } else if (strequ(progname+1, "cat")       /* zcat, pcat */
branch  0 taken 214 (fallthrough)
branch  1 taken 0
      214: 4696:            || strequ(progname, "gzcat")) {    /* gzcat */
branch  0 taken 0 (fallthrough)
branch  1 taken 214
    #####: 4697:        decompress = to_stdout = 1;
        -: 4698:    }
        -: 4699:#endif
        -: 4700:
      718: 4701:    while ((optc = getopt_long (argc, argv, "b:cdfhLqrtvVZ123456789",
call    0 returned 718
      718: 4702:                                longopts, (int *)0)) != EOF) {
branch  0 taken 508
branch  1 taken 210 (fallthrough)
      508: 4703:        switch (optc) {
branch  0 taken 0
branch  1 taken 2
branch  2 taken 13
branch  3 taken 82
branch  4 taken 2
branch  5 taken 2
branch  6 taken 82
branch  7 taken 83
branch  8 taken 3
branch  9 taken 82
branch 10 taken 2
branch 11 taken 0
branch 12 taken 155
branch 13 taken 0
    #####: 4704:        case 'b':
    #####: 4705:            maxbits = atoi(optarg);
    #####: 4706:            break;
        2: 4707:        case 'c':
        2: 4708:            to_stdout = 1; break;
       13: 4709:        case 'd':
       13: 4710:            decompress = 1; break;
       82: 4711:        case 'f':
       82: 4712:            force++; break;
        2: 4713:        case 'h':
        2: 4714:            help(); do_exit(OK); break;
call    0 returned 2
call    1 returned 0
        2: 4715:        case 'L':
        2: 4716:            license(); do_exit(OK); break;
call    0 returned 2
call    1 returned 0
       82: 4717:        case 'q':
       82: 4718:            quiet = 1; verbose = 0; break;
       83: 4719:        case 'r':
        -: 4720:#ifdef NO_DIR
        -: 4721:            fprintf(stderr, "%s: -r not supported on this system\n", progname);
        -: 4722:            usage();
        -: 4723:            do_exit(ERROR); break;
        -: 4724:#else
       83: 4725:            recursive = 1; break;
        -: 4726:#endif
        3: 4727:        case 't':
        3: 4728:            test = decompress = to_stdout = 1;
        3: 4729:            break;
       82: 4730:        case 'v':
       82: 4731:            verbose++; quiet = 0; break;
        2: 4732:        case 'V':
        2: 4733:            version(); quit_on_tty = 1; break;
call    0 returned 2
    #####: 4734:        case 'Z':
        -: 4735:#ifdef LZW
        -: 4736:            do_lzw = 1; break;
        -: 4737:#else
    #####: 4738:            fprintf(stderr, "%s: -Z not supported in this version\n",
call    0 never executed
        -: 4739:                    progname);
    #####: 4740:            usage();
call    0 never executed
    #####: 4741:            do_exit(ERROR); break;
call    0 never executed
        -: 4742:#endif
      155: 4743:        case '1':  case '2':  case '3':  case '4':
        -: 4744:        case '5':  case '6':  case '7':  case '8':  case '9':
      155: 4745:            level = optc - '0';
      155: 4746:            break;
    #####: 4747:        default:
        -: 4748:            /* Error message already emitted by getopt_long. */
    #####: 4749:            usage();
call    0 never executed
    #####: 4750:            do_exit(ERROR);
call    0 never executed
        -: 4751:        }
        -: 4752:    } /* loop on all arguments */
        -: 4753:
      210: 4754:    file_count = argc - optind;
        -: 4755:
     210*: 4756:    if (do_lzw && !decompress) work = lzw;
branch  0 taken 0 (fallthrough)
branch  1 taken 210
branch  2 never executed
branch  3 never executed
        -: 4757:
        -: 4758:    /* Allocate all global buffers (for DYN_ALLOC option) */
        -: 4759:    ALLOC(uch, inbuf,  INBUFSIZ +INBUF_EXTRA);
        -: 4760:    ALLOC(uch, outbuf, OUTBUFSIZ+OUTBUF_EXTRA);
        -: 4761:    ALLOC(ush, d_buf,  DIST_BUFSIZE);
        -: 4762:    ALLOC(uch, window, 2L*WSIZE);
        -: 4763:#ifndef MAXSEG_64K
        -: 4764:    ALLOC(ush, tab_prefix, 1L<<BITS);
        -: 4765:#else
        -: 4766:    ALLOC(ush, tab_prefix0, 1L<<(BITS-1));
        -: 4767:    ALLOC(ush, tab_prefix1, 1L<<(BITS-1));
        -: 4768:#endif
        -: 4769:
        -: 4770:    /* And get to work */
      210: 4771:    if (file_count != 0) {
branch  0 taken 20 (fallthrough)
branch  1 taken 190
       20: 4772:        if (to_stdout && !test) {
branch  0 taken 2 (fallthrough)
branch  1 taken 18
        -: 4773:            SET_BINARY_MODE(fileno(stdout));
        -: 4774:        }
       40: 4775:        while (optind < argc) {
branch  0 taken 20
branch  1 taken 20
       20: 4776:            treat_file(argv[optind++]);
call    0 returned 20
        -: 4777:        }
        -: 4778:    } else {  /* Standard input */
      190: 4779:        treat_stdin();
call    0 returned 188
        -: 4780:    }
      208: 4781:    do_exit(exit_code);
call    0 returned 0
    #####: 4782:    return exit_code; /* just to avoid lint warning */
        -: 4783:}
        -: 4784:
        -: 4785:/* ========================================================================
        -: 4786: * Compress or decompress stdin
        -: 4787: */
function treat_stdin called 190 returned 99% blocks executed 83%
      190: 4788:local void treat_stdin()
        -: 4789:{
      190: 4790:    if (isatty(fileno((FILE *)(decompress ? stdin : stdout)))) {
branch  0 taken 14 (fallthrough)
branch  1 taken 176
call    2 returned 190
call    3 returned 190
branch  4 taken 0 (fallthrough)
branch  5 taken 190
        -: 4791:        /* Do not send compressed data to the terminal or read it from
        -: 4792:         * the terminal. We get here when user invoked the program
        -: 4793:         * without parameters, so be helpful. However, on systems supporting
        -: 4794:         * pseudo ttys, let the beginner stare at the 'hung' program
        -: 4795:         * (explicity request from Noah Friedman). Don't give an error message
        -: 4796:         * if the user only wanted the version number (gzip -V).
        -: 4797:         */
    #####: 4798:        if (quit_on_tty) do_exit(OK);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 4799:#ifdef NO_PTY
        -: 4800:        fprintf(stderr,
        -: 4801:          "%s: compressed data not %s a terminal. Redirect %s file or pipe.\n",
        -: 4802:                progname, decompress ? "read from" : "written to",
        -: 4803:                decompress ? "from" : "to");
        -: 4804:        fprintf(stderr,"For help, type: %s -h\n", progname);
        -: 4805:        do_exit(ERROR);
        -: 4806:#endif
        -: 4807:    }
        -: 4808:
        -: 4809:    SET_BINARY_MODE(fileno(stdin));
      190: 4810:    if (!test) SET_BINARY_MODE(fileno(stdout));
        -: 4811:
      190: 4812:    strcpy(ifname, "stdin");
      190: 4813:    strcpy(ofname, "stdout");
        -: 4814:
        -: 4815:    /* Get the time stamp on the input file */
        -: 4816:#ifdef NO_STDIN_FSTAT
        -: 4817:    time_stamp = 0; /* time unknown */
        -: 4818:#else
      190: 4819:    if (fstat(fileno(stdin), &istat) != 0) {
call    0 returned 190
call    1 returned 190
branch  2 taken 0 (fallthrough)
branch  3 taken 190
    #####: 4820:        error("fstat(stdin)");
call    0 never executed
        -: 4821:    }
      190: 4822:    time_stamp = istat.st_mtime;
        -: 4823:#endif
      190: 4824:    ifile_size = -1L; /* convention for unknown size */
        -: 4825:
      190: 4826:    clear_bufs(); /* clear input and output buffers */
call    0 returned 190
      190: 4827:    to_stdout = 1;
      190: 4828:    part_nb = 0;
        -: 4829:
      190: 4830:    if (decompress) {
branch  0 taken 14 (fallthrough)
branch  1 taken 176
       14: 4831:        method = get_method(ifd);
call    0 returned 13
       13: 4832:        if (method < 0) {
branch  0 taken 0 (fallthrough)
branch  1 taken 13
    #####: 4833:            do_exit(exit_code); /* error message already emitted */
call    0 never executed
        -: 4834:        }
        -: 4835:    }
        -: 4836:
        -: 4837:    /* Actually do the compression/decompression. Loop over zipped members.
        -: 4838:     */
        -: 4839:    for (;;) {
      190: 4840:        (*work)(fileno(stdin), fileno(stdout));
call    0 returned 190
call    1 returned 190
call    2 returned 189
        -: 4841:
      189: 4842:        if (!decompress || last_member || inptr == insize) break;
branch  0 taken 13 (fallthrough)
branch  1 taken 176
branch  2 taken 10 (fallthrough)
branch  3 taken 3
branch  4 taken 1 (fallthrough)
branch  5 taken 9
        -: 4843:        /* end of file */
        -: 4844:
        1: 4845:        method = get_method(ifd);
call    0 returned 1
       1*: 4846:        if (method == -1) return; /* error message already emitted */
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        1: 4847:        bytes_out = 0;            /* required for length check */
        -: 4848:    }
        -: 4849:
      188: 4850:    if (verbose) {
branch  0 taken 81 (fallthrough)
branch  1 taken 107
       81: 4851:        if (test) {
branch  0 taken 0 (fallthrough)
branch  1 taken 81
    #####: 4852:            fprintf(stderr, " OK");
call    0 never executed
        -: 4853:
       81: 4854:        } else if (!decompress) {
branch  0 taken 81 (fallthrough)
branch  1 taken 0
       81: 4855:            fprintf(stderr, "Compression: ");
call    0 returned 81
       81: 4856:            display_ratio(bytes_in-bytes_out-overhead, bytes_in);
call    0 returned 81
        -: 4857:        }
       81: 4858:        fprintf(stderr, "\n");
call    0 returned 81
        -: 4859:    }
        -: 4860:}
        -: 4861:
        -: 4862:/* ========================================================================
        -: 4863: * Compress or decompress the given file
        -: 4864: */
function treat_file called 23 returned 100% blocks executed 41%
       23: 4865:local void treat_file(iname)
        -: 4866:    char *iname;
        -: 4867:{
        -: 4868:    /* Check if the input file is present, set ifname and istat: */
       23: 4869:    if (get_istat(iname, &istat) != 0) return;
call    0 returned 23
branch  1 taken 15 (fallthrough)
branch  2 taken 8
        -: 4870:
        -: 4871:    /* If the input name is that of a directory, recurse or ignore: */
        8: 4872:    if (S_ISDIR(istat.st_mode)) {
branch  0 taken 3 (fallthrough)
branch  1 taken 5
        -: 4873:#ifndef NO_DIR
        3: 4874:        if (recursive) {
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        -: 4875:            struct stat st;
        3: 4876:            st = istat;
        3: 4877:            treat_dir(iname);
call    0 returned 3
        -: 4878:            /* Warning: ifname is now garbage */
        3: 4879:            reset_times (iname, &st);
call    0 returned 3
        -: 4880:        } else
        -: 4881:#endif
    #####: 4882:        WARN((stderr,"%s: %s is a directory -- ignored\n", progname, ifname));
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        3: 4883:        return;
        -: 4884:    }
        5: 4885:    if (!S_ISREG(istat.st_mode)) {
branch  0 taken 0 (fallthrough)
branch  1 taken 5
    #####: 4886:        WARN((stderr,
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 4887:              "%s: %s is not a directory or a regular file - ignored\n",
        -: 4888:              progname, ifname));
    #####: 4889:        return;
        -: 4890:    }
       5*: 4891:    if (istat.st_nlink > 1 && !to_stdout && !force) {
branch  0 taken 0 (fallthrough)
branch  1 taken 5
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 4892:        WARN((stderr, "%s: %s has %d other link%c -- unchanged\n",
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
        -: 4893:              progname, ifname,
        -: 4894:              (int)istat.st_nlink - 1, istat.st_nlink > 2 ? 's' : ' '));
    #####: 4895:        return;
        -: 4896:    }
        -: 4897:
        5: 4898:    ifile_size = istat.st_size;
        5: 4899:    time_stamp = istat.st_mtime;
        -: 4900:
        -: 4901:    /* Generate output file name */
        5: 4902:    if (to_stdout) {
branch  0 taken 2 (fallthrough)
branch  1 taken 3
        2: 4903:        strcpy(ofname, "stdout");
        -: 4904:
        3: 4905:    } else if (make_ofname() != 0) {
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0
        3: 4906:        return;
        -: 4907:    }
        -: 4908:
        -: 4909:    /* Open the input file and determine compression method. The mode
        -: 4910:     * parameter is ignored but required by some systems (VMS).
        -: 4911:     */
        2: 4912:    ifd = open(ifname, O_RDONLY | O_BINARY, RW_USER);
call    0 returned 2
        2: 4913:    if (ifd == -1) {
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####: 4914:        perror(ifname);
call    0 never executed
    #####: 4915:        exit_code = ERROR;
    #####: 4916:        return;
        -: 4917:    }
        2: 4918:    clear_bufs(); /* clear input and output buffers */
call    0 returned 2
        2: 4919:    part_nb = 0;
        -: 4920:
        2: 4921:    if (decompress) {
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        1: 4922:        method = get_method(ifd); /* updates ofname if original given */
call    0 returned 1
        1: 4923:        if (method < 0) {
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 4924:            close(ifd);
call    0 never executed
    #####: 4925:            return;               /* error message already emitted */
        -: 4926:        }
        -: 4927:    }
        -: 4928:
        -: 4929:    /* If compressing to a file, check if ofname is not ambiguous
        -: 4930:     * because the operating system truncates names. Otherwise, generate
        -: 4931:     * a new ofname and save the original name in the compressed file.
        -: 4932:     */
        2: 4933:    if (to_stdout) {
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2: 4934:        ofd = fileno(stdout);
call    0 returned 2
        -: 4935:        /* keep remove_ofname as zero */
        -: 4936:    } else {
    #####: 4937:        if (create_outfile() == -1) return;
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 4938:
    #####: 4939:        if (save_orig_name && !verbose && !quiet) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 4940:            fprintf(stderr, "%s: %s compressed to %s\n",
call    0 never executed
        -: 4941:                    progname, ifname, ofname);
        -: 4942:        }
        -: 4943:    }
        2: 4944:    if (verbose) {
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####: 4945:        fprintf(stderr, "%s:\t%s", ifname, (int)strlen(ifname) >= 15 ?
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 4946:                "" : ((int)strlen(ifname) >= 7 ? "\t" : "\t\t"));
branch  0 never executed
branch  1 never executed
        -: 4947:    }
        -: 4948:
        -: 4949:    /* Actually do the compression/decompression. Loop over zipped members.
        -: 4950:     */
        -: 4951:    for (;;) {
        2: 4952:        (*work)(ifd, ofd);
call    0 returned 2
        -: 4953:
        2: 4954:        if (!decompress || last_member || inptr == insize) break;
branch  0 taken 1 (fallthrough)
branch  1 taken 1
branch  2 taken 1 (fallthrough)
branch  3 taken 0
branch  4 taken 0 (fallthrough)
branch  5 taken 1
        -: 4955:        /* end of file */
        -: 4956:
    #####: 4957:        method = get_method(ifd);
call    0 never executed
    #####: 4958:        if (method < 0) break;    /* error message already emitted */
branch  0 never executed
branch  1 never executed
    #####: 4959:        bytes_out = 0;            /* required for length check */
        -: 4960:    }
        -: 4961:
        2: 4962:    close(ifd);
call    0 returned 2
       2*: 4963:    if (!to_stdout && close(ofd)) {
branch  0 taken 0 (fallthrough)
branch  1 taken 2
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 4964:        write_error();
call    0 never executed
        -: 4965:    }
       2*: 4966:    if (method == -1) return;     /* error, don't display success msg */
branch  0 taken 0 (fallthrough)
branch  1 taken 2
        -: 4967:
        -: 4968:    /* Display statistics */
        2: 4969:    if(verbose) {
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####: 4970:        if (!decompress) {
branch  0 never executed
branch  1 never executed
    #####: 4971:            display_ratio(bytes_in-bytes_out-overhead, bytes_in);
call    0 never executed
        -: 4972:        }
    #####: 4973:        if (test) {
branch  0 never executed
branch  1 never executed
    #####: 4974:            fprintf(stderr, " OK");
call    0 never executed
    #####: 4975:        } else if (!to_stdout) {
branch  0 never executed
branch  1 never executed
    #####: 4976:            fprintf(stderr, " -- replaced with %s", ofname);
call    0 never executed
        -: 4977:        }
    #####: 4978:        fprintf(stderr, "\n");
call    0 never executed
        -: 4979:    }
        -: 4980:    /* Copy modes, times, ownership */
        2: 4981:    if (!to_stdout) {
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####: 4982:        copy_stat(&istat);
call    0 never executed
        -: 4983:    }
        -: 4984:}
        -: 4985:
        -: 4986:/* ========================================================================
        -: 4987: * Create the output file. Return 0 for success, -1 for error.
        -: 4988: * Try twice if ofname is exactly one beyond the name limit, to avoid
        -: 4989: * creating a compressed file of name "1234567890123."
        -: 4990: * We could actually loop more than once if the user gives an extra long
        -: 4991: * name, but I prefer generating an error then. (Posix forbids the system
        -: 4992: * to truncate names.) The error message is generated by check_ofname()
        -: 4993: * in this case.
        -: 4994: * IN assertions: the input file has already been open (ifd is set) and
        -: 4995: *   ofname has already been updated if there was an original name.
        -: 4996: * OUT assertions: ifd and ofd are closed in case of error.
        -: 4997: */
function create_outfile called 0 returned 0% blocks executed 0%
    #####: 4998:local int create_outfile()
        -: 4999:{
        -: 5000:    struct stat ostat; /* stat for ofname */
        -: 5001:    int n;             /* loop counter */
        -: 5002:
    #####: 5003:    for (n = 1; n <= 2; n++) {
branch  0 never executed
branch  1 never executed
    #####: 5004:        if (check_ofname() == -1) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 5005:            close(ifd);
call    0 never executed
    #####: 5006:            return -1;
        -: 5007:        }
        -: 5008:        /* Create the output file */
    #####: 5009:        remove_ofname = 1;
    #####: 5010:        ofd = open(ofname, O_WRONLY|O_CREAT|O_EXCL|O_BINARY, RW_USER);
call    0 never executed
    #####: 5011:        if (ofd == -1) {
branch  0 never executed
branch  1 never executed
    #####: 5012:            perror(ofname);
call    0 never executed
    #####: 5013:            close(ifd);
call    0 never executed
    #####: 5014:            exit_code = ERROR;
    #####: 5015:            return -1;
        -: 5016:        }
        -: 5017:
        -: 5018:        /* Check for name truncation on new file (1234567890123.z) */
    #####: 5019:        if (fstat(ofd, &ostat) != 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 5020:            fprintf(stderr, "%s: ", progname);
call    0 never executed
    #####: 5021:            perror(ofname);
call    0 never executed
    #####: 5022:            close(ifd); close(ofd);
call    0 never executed
call    1 never executed
    #####: 5023:            unlink(ofname);
call    0 never executed
    #####: 5024:            exit_code = ERROR;
    #####: 5025:            return -1;
        -: 5026:        }
    #####: 5027:        if (!name_too_long(ofname, &ostat)) return 0;
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 5028:
    #####: 5029:        if (decompress) {
branch  0 never executed
branch  1 never executed
        -: 5030:            /* name might be too long if an original name was saved */
    #####: 5031:            WARN((stderr, "%s: %s: warning, name truncated\n",
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 5032:                  progname, ofname));
    #####: 5033:            return 0;
        -: 5034:        } else {
        -: 5035:#ifdef NO_MULTIPLE_DOTS
        -: 5036:            /* Should never happen, see check_ofname() */
        -: 5037:            fprintf(stderr, "%s: %s: name too long\n", progname, ofname);
        -: 5038:            do_exit(ERROR);
        -: 5039:#else
    #####: 5040:            close(ofd);
call    0 never executed
    #####: 5041:            unlink(ofname);
call    0 never executed
    #####: 5042:            save_orig_name = 1;
    #####: 5043:            strcpy(ofname+strlen(ofname)-Z_LEN-1, Z_SUFFIX);
        -: 5044:            /* 1234567890123.z -> 123456789012.z */
        -: 5045:#endif
        -: 5046:        } /* decompress ? */
        -: 5047:    } /* for (n) */
        -: 5048:
    #####: 5049:    close(ifd);
call    0 never executed
    #####: 5050:    fprintf(stderr, "%s: %s: name too long\n", progname, ofname);
call    0 never executed
    #####: 5051:    exit_code = ERROR;
    #####: 5052:    return -1;
        -: 5053:}
        -: 5054:
        -: 5055:/* ========================================================================
        -: 5056: * Use lstat if available, except for -c or -f. Use stat otherwise.
        -: 5057: * This allows links when not removing the original file.
        -: 5058: */
function do_stat called 23 returned 100% blocks executed 100%
       23: 5059:local int do_stat(name, sbuf)
        -: 5060:    char *name;
        -: 5061:    struct stat *sbuf;
        -: 5062:{
        -: 5063:#if (defined(S_IFLNK) || defined (S_ISLNK)) && !defined(NO_SYMLINK)
       23: 5064:    if (!to_stdout && !force) {
branch  0 taken 21 (fallthrough)
branch  1 taken 2
branch  2 taken 20 (fallthrough)
branch  3 taken 1
       20: 5065:        return lstat(name, sbuf);
call    0 returned 20
        -: 5066:    }
        -: 5067:#endif
        3: 5068:    return stat(name, sbuf);
call    0 returned 3
        -: 5069:}
        -: 5070:
        -: 5071:/* ========================================================================
        -: 5072: * Return a pointer to the 'z' suffix of a file name, or NULL.
        -: 5073: * For all systems, ".z", ".Z", ".taz", ".tgz", "-z" are accepted suffixes.
        -: 5074: * ".tgz" is a useful convention for tar.z files on systems limited
        -: 5075: * to 3 characters extensions. On such systems, ".?z" and ".??z" are
        -: 5076: * also accepted suffixes. For Unix, we do not want to accept any
        -: 5077: * .??z suffix as indicating a compressed file; some people use .xyz
        -: 5078: * to denote volume data.
        -: 5079: */
function get_suffix called 4 returned 100% blocks executed 47%
        4: 5080:local char *get_suffix(name)
        -: 5081:    char *name;
        -: 5082:{
        -: 5083:    int len;
        4: 5084:    char *p = strrchr(name, '.');
        -: 5085:    char suffix[10];       /* last few chars of name, forced to lower case */
        -: 5086:
       4*: 5087:    if (p == NULL || p == name || strchr(p-1, PATH_SEP) != NULL) return NULL;
branch  0 taken 4 (fallthrough)
branch  1 taken 0
branch  2 taken 4 (fallthrough)
branch  3 taken 0
branch  4 taken 0 (fallthrough)
branch  5 taken 4
        4: 5088:    strncpy(suffix, p, sizeof(suffix));
        4: 5089:    suffix[sizeof(suffix)-1] = '\0';    /* Force null termination */
        -: 5090:
        -: 5091:#ifdef SUFFIX_SEP
        -: 5092:    /* strip a version number from the file name */
        -: 5093:    {
        -: 5094:        char *v = strrchr(suffix, SUFFIX_SEP);
        -: 5095:        if (v != NULL) *v = '\0';
        -: 5096:    }
        -: 5097:#endif
        4: 5098:    strlwr(suffix);
call    0 returned 4
       4*: 5099:    if (strequ(suffix, ".z") || strequ(suffix, ".zip")
branch  0 taken 0 (fallthrough)
branch  1 taken 4
branch  2 never executed
branch  3 never executed
    #####: 5100:        || strequ(suffix, ".tgz") || strequ(suffix, ".taz")) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        4: 5101:        return p;
        -: 5102:    }
    #####: 5103:    len = strlen(suffix);
    #####: 5104:    if (len <= 2) return NULL;
branch  0 never executed
branch  1 never executed
        -: 5105:
    #####: 5106:    if (strequ(suffix+len-2, "-z")) return p+len-2;
branch  0 never executed
branch  1 never executed
        -: 5107:#ifdef MAX_EXT_CHARS
        -: 5108:    if (suffix[len-1] == 'z') return p+len-1;
        -: 5109:#endif
    #####: 5110:    return NULL;
        -: 5111:}
        -: 5112:
        -: 5113:
        -: 5114:/* ========================================================================
        -: 5115: * Set ifname to the input file name (with .z appended if necessary)
        -: 5116: * and istat to its stats. Return 0 if ok, -1 if error.
        -: 5117: */
function get_istat called 23 returned 100% blocks executed 41%
       23: 5118:local int get_istat(iname, sbuf)
        -: 5119:    char *iname;
        -: 5120:    struct stat *sbuf;
        -: 5121:{
        -: 5122:    int iexists; /* set if iname exists */
       23: 5123:    int ilen = strlen(iname);
        -: 5124:    char *suff;
        -: 5125:
       23: 5126:    strcpy(ifname, iname);
       23: 5127:    errno = 0;
        -: 5128:
        -: 5129:    /* If input file exists, return OK. */
       23: 5130:    if (do_stat(ifname, sbuf) == 0) return 0;
call    0 returned 23
branch  1 taken 8 (fallthrough)
branch  2 taken 15
        -: 5131:
       15: 5132:    if (!decompress || errno != ENOENT) {
branch  0 taken 1 (fallthrough)
branch  1 taken 14
branch  2 taken 0 (fallthrough)
branch  3 taken 1
       14: 5133:        perror(ifname);
call    0 returned 14
       14: 5134:        exit_code = ERROR;
       14: 5135:        return -1;
        -: 5136:    }
        -: 5137:    /* file.ext doesn't exist, try file.ext.z and file.ext.Z. For MSDOS
        -: 5138:     * try file.exz, for VMS try file.ext-z.
        -: 5139:     */
        1: 5140:    suff = get_suffix(ifname);
call    0 returned 1
        1: 5141:    if (suff != NULL) {
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 5142:        perror(ifname); /* ifname already has z suffix and does not exist */
call    0 returned 1
        1: 5143:        exit_code = ERROR;
        1: 5144:        return -1;
        -: 5145:    }
        -: 5146:#ifdef SUFFIX_SEP
        -: 5147:    /* strip a version number from the input file name */
        -: 5148:    if ((suff = strrchr(ifname, SUFFIX_SEP)) != NULL) *suff = '\0';
        -: 5149:#endif
    #####: 5150:    if (strrchr(ifname, '.') != NULL) {
branch  0 never executed
branch  1 never executed
    #####: 5151:       strcat(ifname, Z_SUFFIX);
    #####: 5152:       ilen += Z_LEN;
        -: 5153:    } else {
    #####: 5154:       strcat(ifname, ".z");
    #####: 5155:       ilen += 2;
        -: 5156:    }
    #####: 5157:    errno = 0;
    #####: 5158:    iexists = !do_stat(ifname, sbuf);
call    0 never executed
    #####: 5159:    if (!iexists) {
branch  0 never executed
branch  1 never executed
    #####: 5160:        errno = 0;
    #####: 5161:        ifname[ilen-1] = 'Z';
    #####: 5162:        iexists = !do_stat(ifname, sbuf);
call    0 never executed
        -: 5163:    }
        -: 5164:#ifdef NO_MULTIPLE_DOTS
        -: 5165:    /* One more try just to be nice to you */
        -: 5166:    if (!iexists) {
        -: 5167:        char c = ifname[ilen-2];
        -: 5168:        errno = 0;
        -: 5169:        strcpy(ifname+ilen-2, "z");
        -: 5170:        iexists = !do_stat(ifname, sbuf);
        -: 5171:        if (!iexists) {
        -: 5172:            ifname[ilen-2] = c;
        -: 5173:        }
        -: 5174:    }
        -: 5175:#endif
    #####: 5176:    if (!iexists) {
branch  0 never executed
branch  1 never executed
    #####: 5177:        ifname[ilen-1] = 'z';
    #####: 5178:        perror(ifname);
call    0 never executed
    #####: 5179:        exit_code = ERROR;
    #####: 5180:        return -1;
        -: 5181:    }
    #####: 5182:    if (!S_ISREG (sbuf->st_mode)) {
branch  0 never executed
branch  1 never executed
    #####: 5183:        WARN((stderr, "%s: %s: not a regular file -- ignored\n",
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 5184:              progname, ifname));
    #####: 5185:        return -1;
        -: 5186:    }
    #####: 5187:    return 0; /* ok */
        -: 5188:}
        -: 5189:
        -: 5190:/* ========================================================================
        -: 5191: * Generate ofname given ifname. Return 0 if ok, -1 if file must be skipped.
        -: 5192: * Initializes save_orig_name.
        -: 5193: * IN assertion: this function is not called if to_stdout is true.
        -: 5194: */
function make_ofname called 3 returned 100% blocks executed 32%
        3: 5195:local int make_ofname()
        -: 5196:{
        -: 5197:    char *suff;            /* ofname z suffix */
        -: 5198:
        3: 5199:    strcpy(ofname, ifname);
        3: 5200:    suff = get_suffix(ofname);
call    0 returned 3
        -: 5201:
        3: 5202:    if (decompress) {
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####: 5203:        if (suff == NULL) {
branch  0 never executed
branch  1 never executed
    #####: 5204:            WARN((stderr,"%s: %s: no z suffix -- ignored\n",
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 5205:                  progname, ifname));
    #####: 5206:            return -1;
        -: 5207:        }
        -: 5208:        /* Make a special case for .tgz and .taz: */
    #####: 5209:        strlwr(suff);
call    0 never executed
    #####: 5210:        if (strequ(suff, ".tgz") || strequ(suff, ".taz")) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 5211:            strcpy(suff, ".tar");
        -: 5212:        } else {
    #####: 5213:            *suff = '\0'; /* strip z suffix and optional version number */
        -: 5214:        }
        -: 5215:        /* ofname might be changed later if infile contains an original name */
        -: 5216:
        3: 5217:    } else if (suff != NULL) {
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        -: 5218:        /* Avoid annoying messages with -r (see treat_dir()) */
       3*: 5219:        if (verbose || (!recursive && !quiet)) {
branch  0 taken 3 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 3
branch  4 never executed
branch  5 never executed
    #####: 5220:            fprintf(stderr, "%s: %s already has %s suffix -- unchanged\n",
call    0 never executed
        -: 5221:                    progname, ifname, suff);
        -: 5222:        }
        3: 5223:        if (exit_code == OK) exit_code = WARNING;
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        3: 5224:        return -1;
        -: 5225:    } else {
    #####: 5226:        save_orig_name = 0;
        -: 5227:
        -: 5228:#ifdef SUFFIX_SEP
        -: 5229:        /* strip a version number from the file name */
        -: 5230:        if ((suff = strrchr(ofname, SUFFIX_SEP)) != NULL) *suff = '\0';
        -: 5231:#endif
        -: 5232:
        -: 5233:#ifdef NO_MULTIPLE_DOTS
        -: 5234:        suff = strrchr(ofname, '.');
        -: 5235:        if (suff != NULL) {
        -: 5236:#  ifdef MAX_EXT_CHARS
        -: 5237:            /* On the Atari and some versions of MSDOS, name_too_long()
        -: 5238:             * does not work correctly because of a bug in stat(). So we
        -: 5239:             * must truncate here.
        -: 5240:             */
        -: 5241:            if (strlen(suff) > MAX_EXT_CHARS) {
        -: 5242:                strcpy(suff + MAX_EXT_CHARS, do_lzw ? "Z" : "z");
        -: 5243:                save_orig_name = 1;
        -: 5244:                return 0;
        -: 5245:            }
        -: 5246:#  endif
        -: 5247:            strcat(ofname, Z_SUFFIX);
        -: 5248:            return 0;
        -: 5249:        }
        -: 5250:#endif
    #####: 5251:        strcat(ofname, do_lzw ? ".Z" : ".z");
branch  0 never executed
branch  1 never executed
        -: 5252:
        -: 5253:    } /* decompress ? */
    #####: 5254:    return 0;
        -: 5255:}
        -: 5256:
        -: 5257:
        -: 5258:/* ========================================================================
        -: 5259: * Check the magic number of the input file and update ofname if an
        -: 5260: * original name was given and to_stdout is not set.
        -: 5261: * Return the compression method, -1 for error, -2 for warning.
        -: 5262: * Set inptr to the offset of the next byte to be processed.
        -: 5263: * This function may be called repeatedly for an input file consisting
        -: 5264: * of several contiguous gzip'ed members.
        -: 5265: * IN assertions: there is at least one remaining compressed member.
        -: 5266: *   If the member is a zip file, it must be the only one.
        -: 5267: */
function get_method called 16 returned 94% blocks executed 46%
       16: 5268:local int get_method(in)
        -: 5269:    int in;        /* input file descriptor */
        -: 5270:{
        -: 5271:    uch flags;
        -: 5272:    char magic[2]; /* magic header */
        -: 5273:
       16: 5274:    magic[0] = (char)get_byte();
branch  0 taken 1 (fallthrough)
branch  1 taken 15
call    2 returned 15
      16*: 5275:    magic[1] = (char)get_byte();
branch  0 taken 16 (fallthrough)
branch  1 taken 0
call    2 never executed
        -: 5276:
       16: 5277:    time_stamp = istat.st_mtime; /* may be modified later for some methods */
       16: 5278:    method = -1;                 /* unknown yet */
       16: 5279:    part_nb++;                   /* number of parts in gzip file */
       16: 5280:    last_member = RECORD_IO;
        -: 5281:    /* assume multiple members in gzip file except for record oriented I/O */
        -: 5282:
       16: 5283:    if (memcmp(magic, GZIP_MAGIC, 2) == 0
branch  0 taken 5 (fallthrough)
branch  1 taken 11
        5: 5284:        || memcmp(magic, OLD_GZIP_MAGIC, 2) == 0) {
branch  0 taken 0 (fallthrough)
branch  1 taken 5
        -: 5285:
       11: 5286:        work = unzip;
      11*: 5287:        method = (int)get_byte();
branch  0 taken 11 (fallthrough)
branch  1 taken 0
call    2 never executed
      11*: 5288:        flags  = (uch)get_byte();
branch  0 taken 11 (fallthrough)
branch  1 taken 0
call    2 never executed
        -: 5289:
       11: 5290:        if ((flags & ENCRYPTED) != 0) {
branch  0 taken 0 (fallthrough)
branch  1 taken 11
    #####: 5291:            fprintf(stderr,
call    0 never executed
        -: 5292:                    "%s: %s is encrypted -- get newer version of gzip\n",
        -: 5293:                    progname, ifname);
    #####: 5294:            exit_code = ERROR;
    #####: 5295:            return -1;
        -: 5296:        }
       11: 5297:        if ((flags & CONTINUATION) != 0) {
branch  0 taken 0 (fallthrough)
branch  1 taken 11
    #####: 5298:            fprintf(stderr,
call    0 never executed
        -: 5299:           "%s: %s is a a multi-part gzip file -- get newer version of gzip\n",
        -: 5300:                    progname, ifname);
    #####: 5301:            exit_code = ERROR;
    #####: 5302:            if (force <= 1) return -1;
branch  0 never executed
branch  1 never executed
        -: 5303:        }
       11: 5304:        if ((flags & RESERVED) != 0) {
branch  0 taken 0 (fallthrough)
branch  1 taken 11
    #####: 5305:            fprintf(stderr,
call    0 never executed
        -: 5306:                    "%s: %s has flags 0x%x -- get newer version of gzip\n",
        -: 5307:                    progname, ifname, flags);
    #####: 5308:            exit_code = ERROR;
    #####: 5309:            if (force <= 1) return -1;
branch  0 never executed
branch  1 never executed
        -: 5310:        }
      11*: 5311:        time_stamp  = (ulg)get_byte();
branch  0 taken 11 (fallthrough)
branch  1 taken 0
call    2 never executed
      11*: 5312:        time_stamp |= ((ulg)get_byte()) << 8;
branch  0 taken 11 (fallthrough)
branch  1 taken 0
call    2 never executed
      11*: 5313:        time_stamp |= ((ulg)get_byte()) << 16;
branch  0 taken 11 (fallthrough)
branch  1 taken 0
call    2 never executed
      11*: 5314:        time_stamp |= ((ulg)get_byte()) << 24;
branch  0 taken 11 (fallthrough)
branch  1 taken 0
call    2 never executed
        -: 5315:
      11*: 5316:        (void)get_byte();  /* Ignore extra flags for the moment */
branch  0 taken 11 (fallthrough)
branch  1 taken 0
call    2 never executed
      11*: 5317:        (void)get_byte();  /* Ignore OS type for the moment */
branch  0 taken 11 (fallthrough)
branch  1 taken 0
call    2 never executed
        -: 5318:
       11: 5319:        if ((flags & CONTINUATION) != 0) {
branch  0 taken 0 (fallthrough)
branch  1 taken 11
    #####: 5320:            unsigned part = (unsigned)get_byte();
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 5321:            part |= ((unsigned)get_byte())<<8;
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 5322:            if (verbose) {
branch  0 never executed
branch  1 never executed
    #####: 5323:                fprintf(stderr,"%s: %s: part number %u\n",
call    0 never executed
        -: 5324:                        progname, ifname, part);
        -: 5325:            }
        -: 5326:        }
       11: 5327:        if ((flags & EXTRA_FIELD) != 0) {
branch  0 taken 0 (fallthrough)
branch  1 taken 11
    #####: 5328:            unsigned len = (unsigned)get_byte();
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 5329:            len |= ((unsigned)get_byte())<<8;
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 5330:            if (verbose) {
branch  0 never executed
branch  1 never executed
    #####: 5331:                fprintf(stderr,"%s: %s: extra field of %u bytes ignored\n",
call    0 never executed
        -: 5332:                        progname, ifname, len);
        -: 5333:            }
    #####: 5334:            while (len--) (void)get_byte();
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 5335:        }
        -: 5336:
        -: 5337:        /* Get original file name if it was truncated */
       11: 5338:        if ((flags & ORIG_NAME) != 0) {
branch  0 taken 3 (fallthrough)
branch  1 taken 8
       3*: 5339:            if (to_stdout || part_nb > 1) {
branch  0 taken 0 (fallthrough)
branch  1 taken 3
branch  2 never executed
branch  3 never executed
        -: 5340:                /* Discard the old name */
    1828*: 5341:                while (get_byte() != 0) /* null */ ;
branch  0 taken 1827 (fallthrough)
branch  1 taken 1
call    2 returned 0
branch  3 taken 1825
branch  4 taken 2 (fallthrough)
        -: 5342:            } else {
        -: 5343:                /* Copy the base name. Keep a directory prefix intact. */
    #####: 5344:                char *p = basename(ofname);
call    0 never executed
        -: 5345:                for (;;) {
    #####: 5346:                    *p = (char)get_byte();
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 5347:                    if (*p++ == '\0') break;
branch  0 never executed
branch  1 never executed
    #####: 5348:                    if (p >= ofname+sizeof(ofname)) {
branch  0 never executed
branch  1 never executed
    #####: 5349:                        error("corrupted input -- file name too large");
call    0 never executed
        -: 5350:                    }
        -: 5351:                }
        -: 5352:            } /* to_stdout */
        -: 5353:        } /* orig_name */
        -: 5354:
        -: 5355:        /* Discard file comment if any */
       10: 5356:        if ((flags & COMMENT) != 0) {
branch  0 taken 0 (fallthrough)
branch  1 taken 10
    #####: 5357:            while (get_byte() != 0) /* null */ ;
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 5358:        }
        -: 5359:
        5: 5360:    } else if (memcmp(magic, PKZIP_MAGIC, 2) == 0 && inptr == 2
branch  0 taken 2 (fallthrough)
branch  1 taken 3
branch  2 taken 2 (fallthrough)
branch  3 taken 0
        2: 5361:            && memcmp(inbuf, PKZIP_MAGIC, 4) == 0) {
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        -: 5362:        /* To simplify the code, we support a zip file when alone only.
        -: 5363:         * We are thus guaranteed that the entire local header fits in inbuf.
        -: 5364:         */
        2: 5365:        inptr = 0;
        2: 5366:        work = unzip;
       2*: 5367:        if (check_zipfile(in) == -1) return -1;
call    0 returned 2
branch  1 taken 0 (fallthrough)
branch  2 taken 2
        -: 5368:        /* check_zipfile may get ofname from the local header */
        2: 5369:        last_member = 1;
        -: 5370:
        3: 5371:    } else if (memcmp(magic, PACK_MAGIC, 2) == 0) {
branch  0 taken 1 (fallthrough)
branch  1 taken 2
        1: 5372:        work = unpack;
        1: 5373:        method = PACKED;
        2: 5374:    } else if (memcmp(magic, LZW_MAGIC, 2) == 0) {
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        1: 5375:        work = unlzw;
        1: 5376:        method = COMPRESSED;
        1: 5377:        last_member = 1;
        -: 5378:    }
       15: 5379:    if (method >= 0) return method;
branch  0 taken 14 (fallthrough)
branch  1 taken 1
        1: 5380:    if (part_nb == 1) {
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 5381:        fprintf(stderr, "%s: %s is not in gzip format\n", progname, ifname);
call    0 never executed
    #####: 5382:        exit_code = ERROR;
    #####: 5383:        return -1;
        -: 5384:    } else {
        1: 5385:        WARN((stderr, "%s: %s: trailing garbage ignored\n", progname, ifname));
branch  0 taken 1 (fallthrough)
branch  1 taken 0
call    2 returned 1
branch  3 taken 1 (fallthrough)
branch  4 taken 0
        1: 5386:        return -2;
        -: 5387:    }
        -: 5388:}
        -: 5389:
        -: 5390:/* ========================================================================
        -: 5391: * Return true if the two stat structures correspond to the same file.
        -: 5392: */
function same_file called 0 returned 0% blocks executed 0%
    #####: 5393:local int same_file(stat1, stat2)
        -: 5394:    struct stat *stat1;
        -: 5395:    struct stat *stat2;
        -: 5396:{
    #####: 5397:    return stat1->st_mode  == stat2->st_mode
    #####: 5398:        && stat1->st_ino   == stat2->st_ino
branch  0 never executed
branch  1 never executed
    #####: 5399:        && stat1->st_dev   == stat2->st_dev
branch  0 never executed
branch  1 never executed
    #####: 5400:        && stat1->st_uid   == stat2->st_uid
branch  0 never executed
branch  1 never executed
    #####: 5401:        && stat1->st_gid   == stat2->st_gid
branch  0 never executed
branch  1 never executed
    #####: 5402:        && stat1->st_size  == stat2->st_size
branch  0 never executed
branch  1 never executed
    #####: 5403:        && stat1->st_atime == stat2->st_atime
branch  0 never executed
branch  1 never executed
    #####: 5404:        && stat1->st_mtime == stat2->st_mtime
branch  0 never executed
branch  1 never executed
    #####: 5405:        && stat1->st_ctime == stat2->st_ctime;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 5406:}
        -: 5407:
        -: 5408:/* ========================================================================
        -: 5409: * Return true if a file name is ambiguous because the operating system
        -: 5410: * truncates file names.
        -: 5411: */
function name_too_long called 0 returned 0% blocks executed 0%
    #####: 5412:local int name_too_long(name, statb)
        -: 5413:    char *name;           /* file name to check */
        -: 5414:    struct stat *statb;   /* stat buf for this file name */
        -: 5415:{
    #####: 5416:    int s = strlen(name);
    #####: 5417:    char c = name[s-1];
        -: 5418:    struct stat tstat; /* stat for truncated name */
        -: 5419:    int res;
        -: 5420:
    #####: 5421:    tstat = *statb;      /* Just in case OS does not fill all fields */
    #####: 5422:    name[s-1] = '\0';
    #####: 5423:    res = stat(name, &tstat) == 0 && same_file(statb, &tstat);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 5424:    name[s-1] = c;
    #####: 5425:    return res;
        -: 5426:}
        -: 5427:
        -: 5428:/* ========================================================================
        -: 5429: * If compressing to a file, check if ofname is not ambigous
        -: 5430: * because the operating system truncates names. Otherwise, generate
        -: 5431: * a new ofname and save the original name in the compressed file.
        -: 5432: * If the compressed file already exists, ask for confirmation.
        -: 5433: *    The check for name truncation is made dynamically, because different
        -: 5434: * file systems on the same OS might use different truncation rules (on SVR4
        -: 5435: * s5 truncates to 14 chars and ufs does not truncate).
        -: 5436: *    This function returns -1 if the file must be skipped, and
        -: 5437: * updates save_orig_name if necessary.
        -: 5438: * IN assertions: save_orig_name is already set if ofname has been
        -: 5439: * already truncated because of NO_MULTIPLE_DOTS. The input file has
        -: 5440: * already been open and istat is set.
        -: 5441: */
function check_ofname called 0 returned 0% blocks executed 0%
    #####: 5442:local int check_ofname()
        -: 5443:{
    #####: 5444:    int s = strlen(ofname);
        -: 5445:    struct stat ostat; /* stat for ofname */
        -: 5446:
    #####: 5447:    if (stat(ofname, &ostat) != 0) return 0;
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 5448:
        -: 5449:    /* Check for name truncation on existing file: */
        -: 5450:#ifdef NO_MULTIPLE_DOTS
        -: 5451:    if (!decompress && name_too_long(ofname, &ostat)) {
        -: 5452:#else
    #####: 5453:    if (!decompress && s > 8 && name_too_long(ofname, &ostat)) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
        -: 5454:#endif
    #####: 5455:        save_orig_name = 1;
        -: 5456:#ifdef NO_MULTIPLE_DOTS
        -: 5457:        strcpy(ofname+s-Z_LEN-1, Z_SUFFIX);  /* f.extz -> f.exz  */
        -: 5458:#else
    #####: 5459:        strcpy(ofname+s-4, ".z"); /* 12345678901234.z -> 123456789012.z */
        -: 5460:#endif
    #####: 5461:        if (stat(ofname, &ostat) != 0) return 0;
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 5462:    } /* !decompress && name_too_long */
        -: 5463:
        -: 5464:    /* Check that the input and output files are different (could be
        -: 5465:     * the same by name truncation or links).
        -: 5466:     */
    #####: 5467:    if (same_file(&istat, &ostat)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 5468:        fprintf(stderr, "%s: %s and %s are the same file\n",
call    0 never executed
        -: 5469:                progname, ifname, ofname);
    #####: 5470:        exit_code = ERROR;
    #####: 5471:        return -1;
        -: 5472:    }
        -: 5473:    /* Ask permission to overwrite the existing file */
    #####: 5474:    if (!force) {
branch  0 never executed
branch  1 never executed
        -: 5475:        char response[80];
    #####: 5476:        strcpy(response,"n");
    #####: 5477:        fprintf(stderr, "%s: %s already exists;", progname, ofname);
call    0 never executed
    #####: 5478:        if (foreground && isatty(fileno(stdin))) {
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 5479:            fprintf(stderr, " do you wish to overwrite (y or n)? ");
call    0 never executed
    #####: 5480:            fflush(stderr);
call    0 never executed
    #####: 5481:            (void)read(fileno(stdin), response, sizeof(response));
call    0 never executed
call    1 never executed
        -: 5482:        }
    #####: 5483:        if (tolow(*response) != 'y') {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 5484:            fprintf(stderr, "\tnot overwritten\n");
call    0 never executed
    #####: 5485:            if (exit_code == OK) exit_code = WARNING;
branch  0 never executed
branch  1 never executed
    #####: 5486:            return -1;
        -: 5487:        }
        -: 5488:    }
    #####: 5489:    (void) chmod(ofname, 0777);
call    0 never executed
    #####: 5490:    if (unlink(ofname)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 5491:        fprintf(stderr, "%s: ", progname);
call    0 never executed
    #####: 5492:        perror(ofname);
call    0 never executed
    #####: 5493:        exit_code = ERROR;
    #####: 5494:        return -1;
        -: 5495:    }
    #####: 5496:    return 0;
        -: 5497:}
        -: 5498:
        -: 5499:
        -: 5500:/* ========================================================================
        -: 5501: * Set the access and modification times from the given stat buffer.
        -: 5502: */
function reset_times called 3 returned 100% blocks executed 33%
        3: 5503:local void reset_times (name, statb)
        -: 5504:    char *name;
        -: 5505:    struct stat *statb;
        -: 5506:{
        -: 5507:#ifndef NO_UTIME
        -: 5508:    struct utimbuf      timep;
        -: 5509:
        -: 5510:    /* Copy the time stamp */
        3: 5511:    timep.actime  = statb->st_atime;
        3: 5512:    timep.modtime = statb->st_mtime;
        -: 5513:
        3: 5514:    if (utime(name, &timep)) {
call    0 returned 3
branch  1 taken 0 (fallthrough)
branch  2 taken 3
    #####: 5515:        WARN((stderr, "%s: ", progname));
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 5516:        if (!quiet) perror(ofname);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 5517:    }
        -: 5518:#else
        -: 5519:    name = name; statb = statb; /* avoid warnings */
        -: 5520:#endif
        3: 5521:}
        -: 5522:
        -: 5523:
        -: 5524:/* ========================================================================
        -: 5525: * Copy modes, times, ownership from input file to output file.
        -: 5526: * IN assertion: to_stdout is false.
        -: 5527: */
function copy_stat called 0 returned 0% blocks executed 0%
    #####: 5528:local void copy_stat(ifstat)
        -: 5529:    struct stat *ifstat;
        -: 5530:{
        -: 5531:#ifndef NO_UTIME
    #####: 5532:    time_t diff = ifstat->st_mtime - time_stamp;
        -: 5533:
    #####: 5534:    if (diff < 0) diff = -diff;
branch  0 never executed
branch  1 never executed
    #####: 5535:    if (decompress && diff > 60 && time_stamp != 0) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 5536:        ifstat->st_mtime = time_stamp;
    #####: 5537:        if (verbose) {
branch  0 never executed
branch  1 never executed
    #####: 5538:            fprintf(stderr, "%s: time stamp restored\n", ofname);
call    0 never executed
        -: 5539:        }
        -: 5540:    }
    #####: 5541:    reset_times(ofname, ifstat);
call    0 never executed
        -: 5542:#endif
        -: 5543:    /* Copy the protection modes */
    #####: 5544:    if (chmod(ofname, ifstat->st_mode & 07777)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 5545:        WARN((stderr, "%s: ", progname));
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 5546:        if (!quiet) perror(ofname);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 5547:    }
        -: 5548:#ifndef NO_CHOWN
    #####: 5549:    chown(ofname, ifstat->st_uid, ifstat->st_gid);  /* Copy ownership */
call    0 never executed
        -: 5550:#endif
    #####: 5551:    remove_ofname = 0;
        -: 5552:    /* It's now safe to remove the input file: */
    #####: 5553:    (void) chmod(ifname, 0777);
call    0 never executed
    #####: 5554:    if (unlink(ifname)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 5555:        WARN((stderr, "%s: ", progname));
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 5556:        if (!quiet) perror(ifname);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 5557:    }
    #####: 5558:}
        -: 5559:
        -: 5560:#ifndef NO_DIR
        -: 5561:
        -: 5562:/* ========================================================================
        -: 5563: * Recurse through the given directory. This code is taken from ncompress.
        -: 5564: */
function treat_dir called 3 returned 100% blocks executed 79%
        3: 5565:local void treat_dir(dir)
        -: 5566:    char *dir;
        -: 5567:{
        -: 5568:    dir_type *dp;
        -: 5569:    DIR      *dirp;
        -: 5570:    char     nbuf[MAX_PATH_LEN];
        -: 5571:
        3: 5572:    dirp = opendir(dir);
call    0 returned 3
        -: 5573:
        3: 5574:    if (dirp == NULL) {
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####: 5575:        fprintf(stderr, "%s: %s unreadable\n", progname, dir);
call    0 never executed
    #####: 5576:        exit_code = ERROR;
    #####: 5577:        return ;
        -: 5578:    }
        -: 5579:    /*
        -: 5580:     ** WARNING: the following algorithm could occasionally cause
        -: 5581:     ** compress to produce error warnings of the form "<filename>.z
        -: 5582:     ** already has .z suffix - ignored". This occurs when the
        -: 5583:     ** .z output file is inserted into the directory below
        -: 5584:     ** readdir's current pointer.
        -: 5585:     ** These warnings are harmless but annoying, so they are suppressed
        -: 5586:     ** with option -r (except when -v is on). An alternative
        -: 5587:     ** to allowing this would be to store the entire directory
        -: 5588:     ** list in memory, then compress the entries in the stored
        -: 5589:     ** list. Given the depth-first recursive algorithm used here,
        -: 5590:     ** this could use up a tremendous amount of memory. I don't
        -: 5591:     ** think it's worth it. -- Dave Mack
        -: 5592:     ** (An other alternative might be two passes to avoid depth-first.)
        -: 5593:     */
        -: 5594:
       12: 5595:    while ((dp = readdir(dirp)) != NULL) {
call    0 returned 12
branch  1 taken 9
branch  2 taken 3 (fallthrough)
        -: 5596:
        9: 5597:        if (strequ(dp->d_name,".") || strequ(dp->d_name,"..")) {
branch  0 taken 6 (fallthrough)
branch  1 taken 3
branch  2 taken 3 (fallthrough)
branch  3 taken 3
        6: 5598:            continue;
        -: 5599:        }
        3: 5600:        if (((int)strlen(dir) + NLENGTH(dp) + 1) < (MAX_PATH_LEN - 1)) {
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        3: 5601:            strcpy(nbuf,dir);
        3: 5602:            if (strlen(dir) != 0) { /* dir = "" means current dir on Amiga */
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        -: 5603:#ifdef OTHER_PATH_SEP
        -: 5604:                if (dir[strlen(dir)-1] != OTHER_PATH_SEP)
        -: 5605:#endif
        3: 5606:                strcat(nbuf,"/");
        -: 5607:            }
        3: 5608:            strcat(nbuf,dp->d_name);
        3: 5609:            treat_file(nbuf);
call    0 returned 3
        -: 5610:        } else {
    #####: 5611:            fprintf(stderr,"%s: %s/%s: pathname too long\n",
    #####: 5612:                    progname, dir, dp->d_name);
call    0 never executed
    #####: 5613:            exit_code = ERROR;
        -: 5614:        }
        -: 5615:    }
        3: 5616:    closedir(dirp);
call    0 returned 3
        -: 5617:}
        -: 5618:#endif /* ? NO_DIR */
        -: 5619:
        -: 5620:/* ========================================================================
        -: 5621: * Free all dynamically allocated variables and exit with the given code.
        -: 5622: */
function do_exit called 214 returned 0% blocks executed 60%
      214: 5623:local void do_exit(exitcode)
        -: 5624:    int exitcode;
        -: 5625:{
     214*: 5626:    if (env != NULL)  free(env),  env  = NULL;
branch  0 taken 0 (fallthrough)
branch  1 taken 214
     214*: 5627:    if (args != NULL) free(args), args = NULL;
branch  0 taken 0 (fallthrough)
branch  1 taken 214
        -: 5628:    FREE(inbuf);
        -: 5629:    FREE(outbuf);
        -: 5630:    FREE(d_buf);
        -: 5631:    FREE(window);
        -: 5632:#ifndef MAXSEG_64K
        -: 5633:    FREE(tab_prefix);
        -: 5634:#else
        -: 5635:    FREE(tab_prefix0);
        -: 5636:    FREE(tab_prefix1);
        -: 5637:#endif
      214: 5638:    exit(exitcode);
        -: 5639:}
        -: 5640:
        -: 5641:/* ========================================================================
        -: 5642: * Signal and error handler.
        -: 5643: */
function abort_gzip called 2 returned 0% blocks executed 60%
        2: 5644:RETSIGTYPE abort_gzip()
        -: 5645:{
        2: 5646:   if (remove_ofname) {
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####: 5647:       close(ofd);
call    0 never executed
    #####: 5648:       unlink (ofname);
call    0 never executed
        -: 5649:   }
        2: 5650:   do_exit(ERROR);
call    0 returned 0
    #####: 5651:}
        -: 5652:/* Getopt for GNU.
        -: 5653:   NOTE: getopt is now part of the C library, so if you don't know what
        -: 5654:   "Keep this file name-space clean" means, talk to roland@gnu.ai.mit.edu
        -: 5655:   before changing it!
        -: 5656:
        -: 5657:   Copyright (C) 1987, 88, 89, 90, 91, 1992 Free Software Foundation, Inc.
        -: 5658:
        -: 5659:   This program is free software; you can redistribute it and/or modify it
        -: 5660:   under the terms of the GNU General Public License as published by the
        -: 5661:   Free Software Foundation; either version 2, or (at your option) any
        -: 5662:   later version.
        -: 5663:
        -: 5664:   This program is distributed in the hope that it will be useful,
        -: 5665:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 5666:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 5667:   GNU General Public License for more details.
        -: 5668:
        -: 5669:   You should have received a copy of the GNU General Public License
        -: 5670:   along with this program; if not, write to the Free Software
        -: 5671:   Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
        -: 5672:/* AIX requires this to be the first thing in the file.  */
        -: 5673:#if (defined( __GNUC__) && (!defined(LINUX)))
        -: 5674:#define alloca __builtin_alloca
        -: 5675:#else /* not __GNUC__ */
        -: 5676:#if defined (HAVE_ALLOCA_H) || (defined(sparc) && (defined(sun) || (!defined(USG) && !defined(SVR4) && !defined(__svr4__))))
        -: 5677:#include <alloca.h>
        -: 5678:#else
        -: 5679:#ifdef _AIX
        -: 5680: #pragma alloca
        -: 5681:#else
        -: 5682:char *alloca ();
        -: 5683:#endif
        -: 5684:#endif /* alloca.h */
        -: 5685:#endif /* not __GNUC__ */
        -: 5686:
        -: 5687:#if defined(USG) || defined(STDC_HEADERS) || defined(__GNU_LIBRARY__)
        -: 5688:#include <string.h>
        -: 5689:#endif
        -: 5690:
        -: 5691:/* This needs to come after some library #include
        -: 5692:   to get __GNU_LIBRARY__ defined.  */
        -: 5693:#ifdef  __GNU_LIBRARY__
        -: 5694:#undef  alloca
        -: 5695:/* Don't include stdlib.h for non-GNU C libraries because some of them
        -: 5696:   contain conflicting prototypes for getopt.  */
        -: 5697:#include <stdlib.h>
        -: 5698:#else   /* Not GNU C library.  */
        -: 5699:#define __alloca        alloca
        -: 5700:#endif  /* GNU C library.  */
        -: 5701:
        -: 5702:#ifdef LINUX
        -: 5703:#define __alloca alloca
        -: 5704:#endif
        -: 5705:
        -: 5706:#if !__STDC__
        -: 5707:#define const
        -: 5708:#endif
        -: 5709:
        -: 5710:/* If GETOPT_COMPAT is defined, `+' as well as `--' can introduce a
        -: 5711:   long-named option.  Because this is not POSIX.2 compliant, it is
        -: 5712:   being phased out.  */
        -: 5713:#define GETOPT_COMPAT
        -: 5714:
        -: 5715:/* This version of `getopt' appears to the caller like standard Unix `getopt'
        -: 5716:   but it behaves differently for the user, since it allows the user
        -: 5717:   to intersperse the options with the other arguments.
        -: 5718:
        -: 5719:   As `getopt' works, it permutes the elements of ARGV so that,
        -: 5720:   when it is done, all the options precede everything else.  Thus
        -: 5721:   all application programs are extended to handle flexible argument order.
        -: 5722:
        -: 5723:   Setting the environment variable POSIXLY_CORRECT disables permutation.
        -: 5724:   Then the behavior is completely standard.
        -: 5725:
        -: 5726:   GNU application programs can use a third alternative mode in which
        -: 5727:   they can distinguish the relative order of options and other arguments.  */
        -: 5728:
        -: 5729:/* For communication from `getopt' to the caller.
        -: 5730:   When `getopt' finds an option that takes an argument,
        -: 5731:   the argument value is returned here.
        -: 5732:   Also, when `ordering' is RETURN_IN_ORDER,
        -: 5733:   each non-option ARGV-element is returned here.  */
        -: 5734:
        -: 5735:char *optarg = 0;
        -: 5736:
        -: 5737:/* Index in ARGV of the next element to be scanned.
        -: 5738:   This is used for communication to and from the caller
        -: 5739:   and for communication between successive calls to `getopt'.
        -: 5740:
        -: 5741:   On entry to `getopt', zero means this is the first call; initialize.
        -: 5742:
        -: 5743:   When `getopt' returns EOF, this is the index of the first of the
        -: 5744:   non-option elements that the caller should itself scan.
        -: 5745:
        -: 5746:   Otherwise, `optind' communicates from one call to the next
        -: 5747:   how much of ARGV has been scanned so far.  */
        -: 5748:
        -: 5749:int optind = 0;
        -: 5750:
        -: 5751:/* The next char to be scanned in the option-element
        -: 5752:   in which the last option character we returned was found.
        -: 5753:   This allows us to pick up the scan where we left off.
        -: 5754:
        -: 5755:   If this is zero, or a null string, it means resume the scan
        -: 5756:   by advancing to the next ARGV-element.  */
        -: 5757:
        -: 5758:static char *nextchar;
        -: 5759:
        -: 5760:/* Callers store zero here to inhibit the error message
        -: 5761:   for unrecognized options.  */
        -: 5762:
        -: 5763:int opterr = 1;
        -: 5764:
        -: 5765:/* Describe how to deal with options that follow non-option ARGV-elements.
        -: 5766:
        -: 5767:   If the caller did not specify anything,
        -: 5768:   the default is REQUIRE_ORDER if the environment variable
        -: 5769:   POSIXLY_CORRECT is defined, PERMUTE otherwise.
        -: 5770:
        -: 5771:   REQUIRE_ORDER means don't recognize them as options;
        -: 5772:   stop option processing when the first non-option is seen.
        -: 5773:   This is what Unix does.
        -: 5774:   This mode of operation is selected by either setting the environment
        -: 5775:   variable POSIXLY_CORRECT, or using `+' as the first character
        -: 5776:   of the list of option characters.
        -: 5777:
        -: 5778:   PERMUTE is the default.  We permute the contents of ARGV as we scan,
        -: 5779:   so that eventually all the non-options are at the end.  This allows options
        -: 5780:   to be given in any order, even with programs that were not written to
        -: 5781:   expect this.
        -: 5782:
        -: 5783:   RETURN_IN_ORDER is an option available to programs that were written
        -: 5784:   to expect options and other ARGV-elements in any order and that care about
        -: 5785:   the ordering of the two.  We describe each non-option ARGV-element
        -: 5786:   as if it were the argument of an option with character code 1.
        -: 5787:   Using `-' as the first character of the list of option characters
        -: 5788:   selects this mode of operation.
        -: 5789:
        -: 5790:   The special argument `--' forces an end of option-scanning regardless
        -: 5791:   of the value of `ordering'.  In the case of RETURN_IN_ORDER, only
        -: 5792:   `--' can cause `getopt' to return EOF with `optind' != ARGC.  */
        -: 5793:
        -: 5794:static enum
        -: 5795:{
        -: 5796:  REQUIRE_ORDER, PERMUTE, RETURN_IN_ORDER
        -: 5797:} ordering;
        -: 5798:#ifdef  __GNU_LIBRARY__
        -: 5799:#include <string.h>
        -: 5800:#define my_index        strchr
        -: 5801:#define my_bcopy(src, dst, n)   memcpy ((dst), (src), (n))
        -: 5802:#else
        -: 5803:
        -: 5804:/* Avoid depending on library functions or files
        -: 5805:   whose names are inconsistent.  */
        -: 5806:
        -: 5807:char *getenv ();
        -: 5808:
        -: 5809:static char *
        -: 5810:my_index (string, chr)
        -: 5811:     char *string;
        -: 5812:     int chr;
        -: 5813:{
        -: 5814:  while (*string)
        -: 5815:    {
        -: 5816:      if (*string == chr)
        -: 5817:        return string;
        -: 5818:      string++;
        -: 5819:    }
        -: 5820:  return 0;
        -: 5821:}
        -: 5822:
        -: 5823:static void
        -: 5824:my_bcopy (from, to, size)
        -: 5825:     char *from, *to;
        -: 5826:     int size;
        -: 5827:{
        -: 5828:  int i;
        -: 5829:  for (i = 0; i < size; i++)
        -: 5830:    to[i] = from[i];
        -: 5831:}
        -: 5832:#endif                          /* GNU C library.  */
        -: 5833:/* Handle permutation of arguments.  */
        -: 5834:
        -: 5835:/* Describe the part of ARGV that contains non-options that have
        -: 5836:   been skipped.  `first_nonopt' is the index in ARGV of the first of them;
        -: 5837:   `last_nonopt' is the index after the last of them.  */
        -: 5838:
        -: 5839:static int first_nonopt;
        -: 5840:static int last_nonopt;
        -: 5841:
        -: 5842:/* Exchange two adjacent subsequences of ARGV.
        -: 5843:   One subsequence is elements [first_nonopt,last_nonopt)
        -: 5844:   which contains all the non-options that have been skipped so far.
        -: 5845:   The other is elements [last_nonopt,optind), which contains all
        -: 5846:   the options processed since those non-options were skipped.
        -: 5847:
        -: 5848:   `first_nonopt' and `last_nonopt' are relocated so that they describe
        -: 5849:   the new indices of the non-options in ARGV after they are moved.  */
        -: 5850:
        -: 5851:static void
function exchange called 16 returned 100% blocks executed 100%
       16: 5852:exchange (argv)
        -: 5853:     char **argv;
        -: 5854:{
       16: 5855:  int nonopts_size = (last_nonopt - first_nonopt) * sizeof (char *);
        -: 5856:#ifdef _CRAY
        -: 5857:  char *temp[last_nonopt - first_nonopt];
        -: 5858:#else
       16: 5859:  char **temp = (char **) __alloca (nonopts_size);
        -: 5860:#endif
        -: 5861:
        -: 5862:  /* Interchange the two blocks of data in ARGV.  */
        -: 5863:
       16: 5864:  my_bcopy ((char *) &argv[first_nonopt], (char *) temp, nonopts_size);
       16: 5865:  my_bcopy ((char *) &argv[last_nonopt], (char *) &argv[first_nonopt],
        -: 5866:            (optind - last_nonopt) * sizeof (char *));
       16: 5867:  my_bcopy ((char *) temp,
        -: 5868:            (char *) &argv[first_nonopt + optind - last_nonopt],
        -: 5869:            nonopts_size);
        -: 5870:
        -: 5871:  /* Update records for the slots the non-options now occupy.  */
        -: 5872:
       16: 5873:  first_nonopt += (optind - last_nonopt);
       16: 5874:  last_nonopt = optind;
       16: 5875:}
        -: 5876:/* Scan elements of ARGV (whose length is ARGC) for option characters
        -: 5877:   given in OPTSTRING.
        -: 5878:
        -: 5879:   If an element of ARGV starts with '-', and is not exactly "-" or "--",
        -: 5880:   then it is an option element.  The characters of this element
        -: 5881:   (aside from the initial '-') are option characters.  If `getopt'
        -: 5882:   is called repeatedly, it returns successively each of the option characters
        -: 5883:   from each of the option elements.
        -: 5884:
        -: 5885:   If `getopt' finds another option character, it returns that character,
        -: 5886:   updating `optind' and `nextchar' so that the next call to `getopt' can
        -: 5887:   resume the scan with the following option character or ARGV-element.
        -: 5888:
        -: 5889:   If there are no more option characters, `getopt' returns `EOF'.
        -: 5890:   Then `optind' is the index in ARGV of the first ARGV-element
        -: 5891:   that is not an option.  (The ARGV-elements have been permuted
        -: 5892:   so that those that are not options now come last.)
        -: 5893:
        -: 5894:   OPTSTRING is a string containing the legitimate option characters.
        -: 5895:   If an option character is seen that is not listed in OPTSTRING,
        -: 5896:   return '?' after printing an error message.  If you set `opterr' to
        -: 5897:   zero, the error message is suppressed but we still return '?'.
        -: 5898:
        -: 5899:   If a char in OPTSTRING is followed by a colon, that means it wants an arg,
        -: 5900:   so the following text in the same ARGV-element, or the text of the following
        -: 5901:   ARGV-element, is returned in `optarg'.  Two colons mean an option that
        -: 5902:   wants an optional arg; if there is text in the current ARGV-element,
        -: 5903:   it is returned in `optarg', otherwise `optarg' is set to zero.
        -: 5904:
        -: 5905:   If OPTSTRING starts with `-' or `+', it requests different methods of
        -: 5906:   handling the non-option ARGV-elements.
        -: 5907:   See the comments about RETURN_IN_ORDER and REQUIRE_ORDER, above.
        -: 5908:
        -: 5909:   Long-named options begin with `--' instead of `-'.
        -: 5910:   Their names may be abbreviated as long as the abbreviation is unique
        -: 5911:   or is an exact match for some defined option.  If they have an
        -: 5912:   argument, it follows the option name in the same ARGV-element, separated
        -: 5913:   from the option name by a `=', or else the in next ARGV-element.
        -: 5914:   When `getopt' finds a long-named option, it returns 0 if that option's
        -: 5915:   `flag' field is nonzero, the value of the option's `val' field
        -: 5916:   if the `flag' field is zero.
        -: 5917:
        -: 5918:   The elements of ARGV aren't really const, because we permute them.
        -: 5919:   But we pretend they're const in the prototype to be compatible
        -: 5920:   with other systems.
        -: 5921:
        -: 5922:   LONGOPTS is a vector of `struct option' terminated by an
        -: 5923:   element containing a name which is zero.
        -: 5924:
        -: 5925:   LONGIND returns the index in LONGOPT of the long-named option found.
        -: 5926:   It is only valid when a long-named option has been found by the most
        -: 5927:   recent call.
        -: 5928:
        -: 5929:   If LONG_ONLY is nonzero, '-' as well as '--' can introduce
        -: 5930:   long-named options.  */
        -: 5931:
        -: 5932:int
function _getopt_internal called 718 returned 100% blocks executed 50%
      718: 5933:_getopt_internal (argc, argv, optstring, longopts, longind, long_only)
        -: 5934:     int argc;
        -: 5935:     char *const *argv;
        -: 5936:     const char *optstring;
        -: 5937:     const struct option *longopts;
        -: 5938:     int *longind;
        -: 5939:     int long_only;
        -: 5940:{
        -: 5941:  int option_index;
        -: 5942:
      718: 5943:  optarg = 0;
        -: 5944:
        -: 5945:  /* Initialize the internal data when the first call is made.
        -: 5946:     Start processing options with ARGV-element 1 (since ARGV-element 0
        -: 5947:     is the program name); the sequence of previously skipped
        -: 5948:     non-option ARGV-elements is empty.  */
        -: 5949:
      718: 5950:  if (optind == 0)
branch  0 taken 214 (fallthrough)
branch  1 taken 504
        -: 5951:    {
      214: 5952:      first_nonopt = last_nonopt = optind = 1;
        -: 5953:
      214: 5954:      nextchar = NULL;
        -: 5955:
        -: 5956:      /* Determine how to handle the ordering of options and nonoptions.  */
        -: 5957:
      214: 5958:      if (optstring[0] == '-')
branch  0 taken 0 (fallthrough)
branch  1 taken 214
        -: 5959:        {
    #####: 5960:          ordering = RETURN_IN_ORDER;
    #####: 5961:          ++optstring;
        -: 5962:        }
      214: 5963:      else if (optstring[0] == '+')
branch  0 taken 0 (fallthrough)
branch  1 taken 214
        -: 5964:        {
    #####: 5965:          ordering = REQUIRE_ORDER;
    #####: 5966:          ++optstring;
        -: 5967:        }
      214: 5968:      else if (getenv ("POSIXLY_CORRECT") != NULL)
call    0 returned 214
branch  1 taken 0 (fallthrough)
branch  2 taken 214
    #####: 5969:        ordering = REQUIRE_ORDER;
        -: 5970:      else
      214: 5971:        ordering = PERMUTE;
        -: 5972:    }
        -: 5973:
      718: 5974:  if (nextchar == NULL || *nextchar == '\0')
branch  0 taken 504 (fallthrough)
branch  1 taken 214
branch  2 taken 199 (fallthrough)
branch  3 taken 305
        -: 5975:    {
      413: 5976:      if (ordering == PERMUTE)
branch  0 taken 413 (fallthrough)
branch  1 taken 0
        -: 5977:        {
        -: 5978:          /* If we have just processed some options following some non-options,
        -: 5979:             exchange them so that the options come first.  */
        -: 5980:
      413: 5981:          if (first_nonopt != last_nonopt && last_nonopt != optind)
branch  0 taken 16 (fallthrough)
branch  1 taken 397
branch  2 taken 16 (fallthrough)
branch  3 taken 0
       16: 5982:            exchange ((char **) argv);
call    0 returned 16
      397: 5983:          else if (last_nonopt != optind)
branch  0 taken 183 (fallthrough)
branch  1 taken 214
      183: 5984:            first_nonopt = optind;
        -: 5985:
        -: 5986:          /* Now skip any additional non-options
        -: 5987:             and extend the range of non-options previously skipped.  */
        -: 5988:
      413: 5989:          while (optind < argc
      223: 5990:                 && (argv[optind][0] != '-' || argv[optind][1] == '\0')
branch  0 taken 203 (fallthrough)
branch  1 taken 20
branch  2 taken 0 (fallthrough)
branch  3 taken 203
        -: 5991:#ifdef GETOPT_COMPAT
      453: 5992:                 && (longopts == NULL
branch  0 taken 223 (fallthrough)
branch  1 taken 210
branch  2 taken 0
branch  3 taken 20 (fallthrough)
      20*: 5993:                     || argv[optind][0] != '+' || argv[optind][1] == '\0')
branch  0 taken 20
branch  1 taken 0 (fallthrough)
branch  2 never executed
branch  3 never executed
        -: 5994:#endif                          /* GETOPT_COMPAT */
        -: 5995:                 )
       20: 5996:            optind++;
      413: 5997:          last_nonopt = optind;
        -: 5998:        }
        -: 5999:
        -: 6000:      /* Special ARGV-element `--' means premature end of options.
        -: 6001:         Skip it like a null option,
        -: 6002:         then exchange with previous non-options as if it were an option,
        -: 6003:         then skip everything else like a non-option.  */
        -: 6004:
      413: 6005:      if (optind != argc && !strcmp (argv[optind], "--"))
branch  0 taken 203 (fallthrough)
branch  1 taken 210
branch  2 taken 0 (fallthrough)
branch  3 taken 203
        -: 6006:        {
    #####: 6007:          optind++;
        -: 6008:
    #####: 6009:          if (first_nonopt != last_nonopt && last_nonopt != optind)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 6010:            exchange ((char **) argv);
call    0 never executed
    #####: 6011:          else if (first_nonopt == last_nonopt)
branch  0 never executed
branch  1 never executed
    #####: 6012:            first_nonopt = optind;
    #####: 6013:          last_nonopt = argc;
        -: 6014:
    #####: 6015:          optind = argc;
        -: 6016:        }
        -: 6017:
        -: 6018:      /* If we have done all the ARGV-elements, stop the scan
        -: 6019:         and back over any non-options that we skipped and permuted.  */
        -: 6020:
      413: 6021:      if (optind == argc)
branch  0 taken 210 (fallthrough)
branch  1 taken 203
        -: 6022:        {
        -: 6023:          /* Set the next-arg-index to point at the non-options
        -: 6024:             that we previously skipped, so the caller will digest them.  */
      210: 6025:          if (first_nonopt != last_nonopt)
branch  0 taken 20 (fallthrough)
branch  1 taken 190
       20: 6026:            optind = first_nonopt;
      210: 6027:          return EOF;
        -: 6028:        }
        -: 6029:
        -: 6030:      /* If we have come to a non-option and did not permute it,
        -: 6031:         either stop the scan or describe it to the caller and pass it by.  */
        -: 6032:
      203: 6033:      if ((argv[optind][0] != '-' || argv[optind][1] == '\0')
branch  0 taken 203 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 203
        -: 6034:#ifdef GETOPT_COMPAT
    #####: 6035:          && (longopts == NULL
branch  0 never executed
branch  1 never executed
    #####: 6036:              || argv[optind][0] != '+' || argv[optind][1] == '\0')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 6037:#endif                          /* GETOPT_COMPAT */
        -: 6038:          )
        -: 6039:        {
    #####: 6040:          if (ordering == REQUIRE_ORDER)
branch  0 never executed
branch  1 never executed
    #####: 6041:            return EOF;
    #####: 6042:          optarg = argv[optind++];
    #####: 6043:          return 1;
        -: 6044:        }
        -: 6045:
        -: 6046:      /* We have found another option-ARGV-element.
        -: 6047:         Start decoding its characters.  */
        -: 6048:
      406: 6049:      nextchar = (argv[optind] + 1
      203: 6050:                  + (longopts != NULL && argv[optind][1] == '-'));
branch  0 taken 203 (fallthrough)
branch  1 taken 0
branch  2 taken 13 (fallthrough)
branch  3 taken 190
        -: 6051:    }
        -: 6052:
      508: 6053:  if (longopts != NULL
branch  0 taken 508 (fallthrough)
branch  1 taken 0
      508: 6054:      && ((argv[optind][0] == '-'
branch  0 taken 508 (fallthrough)
branch  1 taken 0
      508: 6055:           && (argv[optind][1] == '-' || long_only))
branch  0 taken 495 (fallthrough)
branch  1 taken 13
branch  2 taken 495 (fallthrough)
branch  3 taken 0
        -: 6056:#ifdef GETOPT_COMPAT
      495: 6057:          || argv[optind][0] == '+'
branch  0 taken 0 (fallthrough)
branch  1 taken 495
        -: 6058:#endif                          /* GETOPT_COMPAT */
        -: 6059:          ))
        -: 6060:    {
        -: 6061:      const struct option *p;
       13: 6062:      char *s = nextchar;
       13: 6063:      int exact = 0;
       13: 6064:      int ambig = 0;
       13: 6065:      const struct option *pfound = NULL;
       13: 6066:      int indfound = 0;
        -: 6067:
       93: 6068:      while (*s && *s != '=')
branch  0 taken 80 (fallthrough)
branch  1 taken 13
branch  2 taken 80
branch  3 taken 0 (fallthrough)
       80: 6069:        s++;
        -: 6070:
        -: 6071:      /* Test all options for either exact match or abbreviated matches.  */
       91: 6072:      for (p = longopts, option_index = 0; p->name;
branch  0 taken 91
branch  1 taken 0 (fallthrough)
       78: 6073:           p++, option_index++)
       91: 6074:        if (!strncmp (p->name, nextchar, s - nextchar))
branch  0 taken 13 (fallthrough)
branch  1 taken 78
        -: 6075:          {
       13: 6076:            if (s - nextchar == strlen (p->name))
branch  0 taken 13 (fallthrough)
branch  1 taken 0
        -: 6077:              {
        -: 6078:                /* Exact match found.  */
       13: 6079:                pfound = p;
       13: 6080:                indfound = option_index;
       13: 6081:                exact = 1;
       13: 6082:                break;
        -: 6083:              }
    #####: 6084:            else if (pfound == NULL)
branch  0 never executed
branch  1 never executed
        -: 6085:              {
        -: 6086:                /* First nonexact match found.  */
    #####: 6087:                pfound = p;
    #####: 6088:                indfound = option_index;
        -: 6089:              }
        -: 6090:            else
        -: 6091:              /* Second nonexact match found.  */
    #####: 6092:              ambig = 1;
        -: 6093:          }
        -: 6094:
      13*: 6095:      if (ambig && !exact)
branch  0 taken 0 (fallthrough)
branch  1 taken 13
branch  2 never executed
branch  3 never executed
        -: 6096:        {
    #####: 6097:          if (opterr)
branch  0 never executed
branch  1 never executed
    #####: 6098:            fprintf (stderr, "%s: option `%s' is ambiguous\n",
    #####: 6099:                     argv[0], argv[optind]);
call    0 never executed
    #####: 6100:          nextchar += strlen (nextchar);
    #####: 6101:          optind++;
    #####: 6102:          return '?';
        -: 6103:        }
        -: 6104:
       13: 6105:      if (pfound != NULL)
branch  0 taken 13 (fallthrough)
branch  1 taken 0
        -: 6106:        {
       13: 6107:          option_index = indfound;
       13: 6108:          optind++;
       13: 6109:          if (*s)
branch  0 taken 0 (fallthrough)
branch  1 taken 13
        -: 6110:            {
        -: 6111:              /* Don't test has_arg with >, because some C compilers don't
        -: 6112:                 allow it to be used on enums.  */
    #####: 6113:              if (pfound->has_arg)
branch  0 never executed
branch  1 never executed
    #####: 6114:                optarg = s + 1;
        -: 6115:              else
        -: 6116:                {
    #####: 6117:                  if (opterr)
branch  0 never executed
branch  1 never executed
        -: 6118:                    {
    #####: 6119:                      if (argv[optind - 1][1] == '-')
branch  0 never executed
branch  1 never executed
        -: 6120:                        /* --option */
    #####: 6121:                        fprintf (stderr,
        -: 6122:                                 "%s: option `--%s' doesn't allow an argument\n",
    #####: 6123:                                 argv[0], pfound->name);
call    0 never executed
        -: 6124:                      else
        -: 6125:                        /* +option or -option */
    #####: 6126:                        fprintf (stderr,
        -: 6127:                             "%s: option `%c%s' doesn't allow an argument\n",
    #####: 6128:                             argv[0], argv[optind - 1][0], pfound->name);
call    0 never executed
        -: 6129:                    }
    #####: 6130:                  nextchar += strlen (nextchar);
    #####: 6131:                  return '?';
        -: 6132:                }
        -: 6133:            }
       13: 6134:          else if (pfound->has_arg == 1)
branch  0 taken 0 (fallthrough)
branch  1 taken 13
        -: 6135:            {
    #####: 6136:              if (optind < argc)
branch  0 never executed
branch  1 never executed
    #####: 6137:                optarg = argv[optind++];
        -: 6138:              else
        -: 6139:                {
    #####: 6140:                  if (opterr)
branch  0 never executed
branch  1 never executed
    #####: 6141:                    fprintf (stderr, "%s: option `%s' requires an argument\n",
    #####: 6142:                             argv[0], argv[optind - 1]);
call    0 never executed
    #####: 6143:                  nextchar += strlen (nextchar);
    #####: 6144:                  return '?';
        -: 6145:                }
        -: 6146:            }
       13: 6147:          nextchar += strlen (nextchar);
       13: 6148:          if (longind != NULL)
branch  0 taken 0 (fallthrough)
branch  1 taken 13
    #####: 6149:            *longind = option_index;
       13: 6150:          if (pfound->flag)
branch  0 taken 0 (fallthrough)
branch  1 taken 13
        -: 6151:            {
    #####: 6152:              *(pfound->flag) = pfound->val;
    #####: 6153:              return 0;
        -: 6154:            }
       13: 6155:          return pfound->val;
        -: 6156:        }
        -: 6157:      /* Can't find it as a long option.  If this is not getopt_long_only,
        -: 6158:         or the option starts with '--' or is not a valid short
        -: 6159:         option, then it's an error.
        -: 6160:         Otherwise interpret it as a short option.  */
    #####: 6161:      if (!long_only || argv[optind][1] == '-'
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 6162:#ifdef GETOPT_COMPAT
    #####: 6163:          || argv[optind][0] == '+'
branch  0 never executed
branch  1 never executed
        -: 6164:#endif                          /* GETOPT_COMPAT */
    #####: 6165:          || my_index (optstring, *nextchar) == NULL)
branch  0 never executed
branch  1 never executed
        -: 6166:        {
    #####: 6167:          if (opterr)
branch  0 never executed
branch  1 never executed
        -: 6168:            {
    #####: 6169:              if (argv[optind][1] == '-')
branch  0 never executed
branch  1 never executed
        -: 6170:                /* --option */
    #####: 6171:                fprintf (stderr, "%s: unrecognized option `--%s'\n",
call    0 never executed
        -: 6172:                         argv[0], nextchar);
        -: 6173:              else
        -: 6174:                /* +option or -option */
    #####: 6175:                fprintf (stderr, "%s: unrecognized option `%c%s'\n",
    #####: 6176:                         argv[0], argv[optind][0], nextchar);
call    0 never executed
        -: 6177:            }
    #####: 6178:          nextchar = (char *) "";
    #####: 6179:          optind++;
    #####: 6180:          return '?';
        -: 6181:        }
        -: 6182:    }
        -: 6183:
        -: 6184:  /* Look at and handle the next option-character.  */
        -: 6185:
        -: 6186:  {
      495: 6187:    char c = *nextchar++;
      495: 6188:    char *temp = my_index (optstring, c);
        -: 6189:
        -: 6190:    /* Increment `optind' when we start to process its last character.  */
      495: 6191:    if (*nextchar == '\0')
branch  0 taken 190 (fallthrough)
branch  1 taken 305
      190: 6192:      ++optind;
        -: 6193:
      495: 6194:    if (temp == NULL || c == ':')
branch  0 taken 495 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 495
        -: 6195:      {
    #####: 6196:        if (opterr)
branch  0 never executed
branch  1 never executed
        -: 6197:          {
    #####: 6198:            if (c < 040 || c >= 0177)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 6199:              fprintf (stderr, "%s: unrecognized option, character code 0%o\n",
call    0 never executed
        -: 6200:                       argv[0], c);
        -: 6201:            else
    #####: 6202:              fprintf (stderr, "%s: unrecognized option `-%c'\n", argv[0], c);
call    0 never executed
        -: 6203:          }
    #####: 6204:        return '?';
        -: 6205:      }
      495: 6206:    if (temp[1] == ':')
branch  0 taken 0 (fallthrough)
branch  1 taken 495
        -: 6207:      {
    #####: 6208:        if (temp[2] == ':')
branch  0 never executed
branch  1 never executed
        -: 6209:          {
        -: 6210:            /* This is an option that accepts an argument optionally.  */
    #####: 6211:            if (*nextchar != '\0')
branch  0 never executed
branch  1 never executed
        -: 6212:              {
    #####: 6213:                optarg = nextchar;
    #####: 6214:                optind++;
        -: 6215:              }
        -: 6216:            else
    #####: 6217:              optarg = 0;
    #####: 6218:            nextchar = NULL;
        -: 6219:          }
        -: 6220:        else
        -: 6221:          {
        -: 6222:            /* This is an option that requires an argument.  */
    #####: 6223:            if (*nextchar != '\0')
branch  0 never executed
branch  1 never executed
        -: 6224:              {
    #####: 6225:                optarg = nextchar;
        -: 6226:                /* If we end this ARGV-element by taking the rest as an arg,
        -: 6227:                   we must advance to the next element now.  */
    #####: 6228:                optind++;
        -: 6229:              }
    #####: 6230:            else if (optind == argc)
branch  0 never executed
branch  1 never executed
        -: 6231:              {
    #####: 6232:                if (opterr)
branch  0 never executed
branch  1 never executed
    #####: 6233:                  fprintf (stderr, "%s: option `-%c' requires an argument\n",
call    0 never executed
        -: 6234:                           argv[0], c);
    #####: 6235:                c = '?';
        -: 6236:              }
        -: 6237:            else
        -: 6238:              /* We already incremented `optind' once;
        -: 6239:                 increment it again when taking next ARGV-elt as argument.  */
    #####: 6240:              optarg = argv[optind++];
    #####: 6241:            nextchar = NULL;
        -: 6242:          }
        -: 6243:      }
      495: 6244:    return c;
        -: 6245:  }
        -: 6246:}
        -: 6247:
        -: 6248:int
        -: 6249:getopt (argc, argv, optstring)
        -: 6250:     int argc;
        -: 6251:     char *const *argv;
        -: 6252:     const char *optstring;
        -: 6253:{
    #####: 6254:  return _getopt_internal (argc, argv, optstring,
call    0 never executed
        -: 6255:                           (const struct option *) 0,
        -: 6256:                           (int *) 0,
        -: 6257:                           0);
        -: 6258:}
        -: 6259:
        -: 6260:int
function getopt_long called 718 returned 100% blocks executed 100%
      718: 6261:getopt_long (argc, argv, options, long_options, opt_index)
        -: 6262:     int argc;
        -: 6263:     char *const *argv;
        -: 6264:     const char *options;
        -: 6265:     const struct option *long_options;
        -: 6266:     int *opt_index;
        -: 6267:{
      718: 6268:  return _getopt_internal (argc, argv, options, long_options, opt_index, 0);
call    0 returned 718
        -: 6269:}
        -: 6270:
        -: 6271:/* Like getopt_long, but '-' as well as '--' can indicate a long option.
        -: 6272:   If an option that starts with '-' (not '--') doesn't match a long option,
        -: 6273:   but does match a short option, it is parsed as a short option
        -: 6274:   instead. */
        -: 6275:
        -: 6276:int
function getopt_long_only called 0 returned 0% blocks executed 0%
    #####: 6277:getopt_long_only (argc, argv, options, long_options, opt_index)
        -: 6278:     int argc;
        -: 6279:     char *const *argv;
        -: 6280:     const char *options;
        -: 6281:     const struct option *long_options;
        -: 6282:     int *opt_index;
        -: 6283:{
    #####: 6284:  return _getopt_internal (argc, argv, options, long_options, opt_index, 1);
call    0 never executed
        -: 6285:}
        -: 6286:
        -: 6287:#ifdef TEST
        -: 6288:
        -: 6289:/* Compile with -DTEST to make an executable for use in testing
        -: 6290:   the above definition of `getopt'.  */
        -: 6291:
        -: 6292:int
        -: 6293:main (argc, argv)
        -: 6294:     int argc;
        -: 6295:     char **argv;
        -: 6296:{
        -: 6297:  int c;
        -: 6298:  int digit_optind = 0;
        -: 6299:
        -: 6300:  while (1)
        -: 6301:    {
        -: 6302:      int this_option_optind = optind ? optind : 1;
        -: 6303:
        -: 6304:      c = getopt (argc, argv, "abc:d:0123456789");
        -: 6305:      if (c == EOF)
        -: 6306:        break;
        -: 6307:
        -: 6308:      switch (c)
        -: 6309:        {
        -: 6310:        case '0':
        -: 6311:        case '1':
        -: 6312:        case '2':
        -: 6313:        case '3':
        -: 6314:        case '4':
        -: 6315:        case '5':
        -: 6316:        case '6':
        -: 6317:        case '7':
        -: 6318:        case '8':
        -: 6319:        case '9':
        -: 6320:          if (digit_optind != 0 && digit_optind != this_option_optind)
        -: 6321:            printf ("digits occur in two different argv-elements.\n");
        -: 6322:          digit_optind = this_option_optind;
        -: 6323:          printf ("option %c\n", c);
        -: 6324:          break;
        -: 6325:
        -: 6326:        case 'a':
        -: 6327:          printf ("option a\n");
        -: 6328:          break;
        -: 6329:
        -: 6330:        case 'b':
        -: 6331:          printf ("option b\n");
        -: 6332:          break;
        -: 6333:
        -: 6334:        case 'c':
        -: 6335:          printf ("option c with value `%s'\n", optarg);
        -: 6336:          break;
        -: 6337:
        -: 6338:        case '?':
        -: 6339:          break;
        -: 6340:
        -: 6341:        default:
        -: 6342:          printf ("?? getopt returned character code 0%o ??\n", c);
        -: 6343:        }
        -: 6344:    }
        -: 6345:
        -: 6346:  if (optind < argc)
        -: 6347:    {
        -: 6348:      printf ("non-option ARGV-elements: ");
        -: 6349:      while (optind < argc)
        -: 6350:        printf ("%s ", argv[optind++]);
        -: 6351:      printf ("\n");
        -: 6352:    }
        -: 6353:
        -: 6354:  exit (0);
        -: 6355:}
        -: 6356:
        -: 6357:#endif /* TEST */
