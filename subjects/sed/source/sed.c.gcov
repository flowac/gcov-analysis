        -:    0:Source:sed.c
        -:    0:Graph:sed.gcno
        -:    0:Data:sed.gcda
        -:    0:Runs:1
        -:    1:#define COPYRIGHT_NOTICE "Copyright (C) 2003 Free Software Foundation, Inc."
        -:    2:#define BUG_ADDRESS "bonzini@gnu.org"
        -:    3:
        -:    4:/*  GNU SED, a batch stream editor.
        -:    5:    Copyright (C) 1989,90,91,92,93,94,95,98,99,2002,2003
        -:    6:    Free Software Foundation, Inc.
        -:    7:
        -:    8:    This program is free software; you can redistribute it and/or modify
        -:    9:    it under the terms of the GNU General Public License as published by
        -:   10:    the Free Software Foundation; either version 2, or (at your option)
        -:   11:    any later version.
        -:   12:
        -:   13:    This program is distributed in the hope that it will be useful,
        -:   14:    but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   15:    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   16:    GNU General Public License for more details.
        -:   17:
        -:   18:    You should have received a copy of the GNU General Public License
        -:   19:    along with this program; if not, write to the Free Software
        -:   20:    Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA. */
        -:   21:
        -:   22:/* 
        -:   23:   Non-determinism fix for SIR July 2006
        -:   24:   by Kyle R. Murphy
        -:   25:*/
        -:   26:#undef stderr
        -:   27:#define stderr stdout
        -:   28:
        -:   29:#include "FaultSeeds.h"
        -:   30:#include "sed.h"
        -:   31:#include "config.h"
        -:   32:
        -:   33:#include <stdio.h>
        -:   34:#ifdef HAVE_STRINGS_H
        -:   35:# include <strings.h>
        -:   36:#else
        -:   37:# include <string.h>
        -:   38:#endif /*HAVE_STRINGS_H*/
        -:   39:#ifdef HAVE_MEMORY_H
        -:   40:# include <memory.h>
        -:   41:#endif
        -:   42:
        -:   43:#ifndef HAVE_STRCHR
        -:   44:# define strchr index
        -:   45:# define strrchr rindex
        -:   46:#endif
        -:   47:
        -:   48:#ifdef HAVE_STDLIB_H
        -:   49:# include <stdlib.h>
        -:   50:#endif
        -:   51:
        -:   52:#ifdef HAVE_SYS_TYPES_H
        -:   53:# include <sys/types.h>
        -:   54:#endif
        -:   55:#include "getopt.h"
        -:   56:
        -:   57:#ifndef BOOTSTRAP
        -:   58:#ifndef HAVE_STDLIB_H
        -:   59: extern char *getenv P_((const char *));
        -:   60:#endif
        -:   61:#endif
        -:   62:
        -:   63:#ifndef HAVE_STRTOUL
        -:   64:# define ATOI(x)	atoi(x)
        -:   65:#else
        -:   66:# define ATOI(x)	strtoul(x, NULL, 0)
        -:   67:#endif
        -:   68:
        -:   69:int extended_regexp_flags = 0;
        -:   70:
        -:   71:/* If set, fflush(stdout) on every line output. */
        -:   72:bool unbuffered_output = false;
        -:   73:
        -:   74:/* If set, don't write out the line unless explicitly told to */
        -:   75:bool no_default_output = false;
        -:   76:
        -:   77:/* If set, reset line counts on every new file. */
        -:   78:bool separate_files = false;
        -:   79:
        -:   80:/* How do we edit files in-place? (we don't if NULL) */
        -:   81:char *in_place_extension = NULL;
        -:   82:
        -:   83:/* Do we need to be pedantically POSIX compliant? */
        -:   84:enum posixicity_types posixicity;
        -:   85:
        -:   86:/* How long should the `l' command's output line be? */
        -:   87:countT lcmd_out_line_len = 70;
        -:   88:
        -:   89:/* The complete compiled SED program that we are going to run: */
        -:   90:static struct vector *the_program = NULL;
        -:   91:
        -:   92:static void usage P_((int));
        -:   93:static void
function usage called 0 returned 0% blocks executed 0%
    #####:   94:usage(status)
        -:   95:  int status;
        -:   96:{
    #####:   97:  FILE *out = status ? stderr : stdout;
        -:   98:
        -:   99:#ifdef REG_PERL
        -:  100:#define PERL_HELP _("  -R, --regexp-perl\n                 use Perl 5's regular expressions syntax in the script.\n")
        -:  101:#else
        -:  102:#define PERL_HELP ""
        -:  103:#endif
        -:  104:
    #####:  105:  fprintf(out, _("\
call    0 never executed
        -:  106:Usage: %s [OPTION]... {script-only-if-no-other-script} [input-file]...\n\
        -:  107:\n"), myname);
        -:  108:
    #####:  109:  fprintf(out, _("  -n, --quiet, --silent\n\
call    0 never executed
        -:  110:                 suppress automatic printing of pattern space\n"));
    #####:  111:  fprintf(out, _("  -e script, --expression=script\n\
call    0 never executed
        -:  112:                 add the script to the commands to be executed\n"));
    #####:  113:  fprintf(out, _("  -f script-file, --file=script-file\n\
call    0 never executed
        -:  114:                 add the contents of script-file to the commands to be executed\n"));
    #####:  115:  fprintf(out, _("  -i[SUFFIX], --in-place[=SUFFIX]\n\
call    0 never executed
        -:  116:                 edit files in place (makes backup if extension supplied)\n"));
    #####:  117:  fprintf(out, _("  -l N, --line-length=N\n\
call    0 never executed
        -:  118:                 specify the desired line-wrap length for the `l' command\n"));
    #####:  119:  fprintf(out, _("  --posix\n\
call    0 never executed
        -:  120:                 disable all GNU extensions.\n"));
    #####:  121:  fprintf(out, _("  -r, --regexp-extended\n\
call    0 never executed
        -:  122:                 use extended regular expressions in the script.\n"));
    #####:  123:  fprintf(out, PERL_HELP);
    #####:  124:  fprintf(out, _("  -s, --separate\n\
call    0 never executed
        -:  125:                 consider files as separate rather than as a single continuous\n\
        -:  126:                 long stream.\n"));
    #####:  127:  fprintf(out, _("  -u, --unbuffered\n\
call    0 never executed
        -:  128:                 load minimal amounts of data from the input files and flush\n\
        -:  129:                 the output buffers more often\n"));
    #####:  130:  fprintf(out, _("      --help     display this help and exit\n"));
call    0 never executed
    #####:  131:  fprintf(out, _("      --version  output version information and exit\n"));
call    0 never executed
    #####:  132:  fprintf(out, _("\n\
call    0 never executed
        -:  133:If no -e, --expression, -f, or --file option is given, then the first\n\
        -:  134:non-option argument is taken as the sed script to interpret.  All\n\
        -:  135:remaining arguments are names of input files; if no input files are\n\
        -:  136:specified, then the standard input is read.\n\
        -:  137:\n"));
    #####:  138:  fprintf(out, _("E-mail bug reports to: %s .\n\
call    0 never executed
        -:  139:Be sure to include the word ``%s'' somewhere in the ``Subject:'' field.\n"),
        -:  140:	  BUG_ADDRESS, PACKAGE);
        -:  141:
    #####:  142:  ck_fclose (NULL);
call    0 never executed
    #####:  143:  exit (status);
        -:  144:}
        -:  145:
        -:  146:int
function main called 1 returned 0% blocks executed 45%
        1:  147:main(argc, argv)
        -:  148:  int argc;
        -:  149:  char **argv;
        -:  150:{
        -:  151:#ifdef REG_PERL
        -:  152:#define SHORTOPTS "snrRue:f:l:i::V:"
        -:  153:#else
        -:  154:#define SHORTOPTS "snrue:f:l:i::V:"
        -:  155:#endif
        -:  156:
        -:  157:  static struct option longopts[] = {
        -:  158:    {"regexp-extended", 0, NULL, 'r'},
        -:  159:#ifdef REG_PERL
        -:  160:    {"regexp-perl", 0, NULL, 'R'},
        -:  161:#endif
        -:  162:    {"expression", 1, NULL, 'e'},
        -:  163:    {"file", 1, NULL, 'f'},
        -:  164:    {"in-place", 2, NULL, 'i'},
        -:  165:    {"line-length", 1, NULL, 'l'},
        -:  166:    {"quiet", 0, NULL, 'n'},
        -:  167:    {"posix", 0, NULL, 'p'},
        -:  168:    {"silent", 0, NULL, 'n'},
        -:  169:    {"separate", 0, NULL, 's'},
        -:  170:    {"unbuffered", 0, NULL, 'u'},
        -:  171:    {"version", 0, NULL, 'v'},
        -:  172:    {"help", 0, NULL, 'h'},
        -:  173:    {NULL, 0, NULL, 0}
        -:  174:  };
        -:  175:
        -:  176:  int opt;
        -:  177:  int return_code;
        1:  178:  const char *cols = getenv("COLS");
call    0 returned 1
        -:  179:
        -:  180:  initialize_main (&argc, &argv);
        -:  181:#if HAVE_SETLOCALE
        -:  182:  /* Set locale according to user's wishes.  */
        -:  183:  setlocale (LC_ALL, "");
        -:  184:#endif
        1:  185:  initialize_mbcs ();
call    0 returned 1
        -:  186:
        -:  187:#if ENABLE_NLS
        -:  188:
        -:  189:  /* Tell program which translations to use and where to find.  */
        -:  190:  bindtextdomain (PACKAGE, LOCALEDIR);
        -:  191:  textdomain (PACKAGE);
        -:  192:#endif
        -:  193:
        1:  194:  if (getenv("POSIXLY_CORRECT") != NULL)
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
    #####:  195:    posixicity = POSIXLY_CORRECT;
        -:  196:  else
        1:  197:    posixicity = POSIXLY_EXTENDED;
        -:  198:
        -:  199:  /* If environment variable `COLS' is set, use its value for
        -:  200:     the baseline setting of `lcmd_out_line_len'.  The "-1"
        -:  201:     is to avoid gratuitous auto-line-wrap on ttys.
        -:  202:   */
        1:  203:  if (cols)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -:  204:    {
    #####:  205:      countT t = ATOI(cols);
    #####:  206:      if (t > 1)
branch  0 never executed
branch  1 never executed
    #####:  207:	lcmd_out_line_len = t-1;
        -:  208:    }
        -:  209:
        -:  210:/*
        -:  211:  More non-determinism -- SIR July 2006
        -:  212:  by Kyle R. Murphy
        -:  213:  myname = *argv;
        -:  214:*/
        1:  215:  myname = "Executable";
        -:  216:
        6:  217:  while ((opt = getopt_long(argc, argv, SHORTOPTS, longopts, NULL)) != EOF)
call    0 returned 6
branch  1 taken 5
branch  2 taken 1 (fallthrough)
        -:  218:    {
        5:  219:      switch (opt)
branch  0 taken 0
branch  1 taken 1
branch  2 taken 0
branch  3 taken 0
branch  4 taken 1
branch  5 taken 0
branch  6 taken 1
branch  7 taken 1
branch  8 taken 1
branch  9 taken 0
branch 10 taken 0
branch 11 taken 0
        -:  220:	{
    #####:  221:	case 'n':
    #####:  222:	  no_default_output = true;
    #####:  223:	  break;
        1:  224:	case 'e':
        1:  225:	  the_program = compile_string(the_program, optarg, strlen(optarg));
call    0 returned 1
        1:  226:	  break;
    #####:  227:	case 'f':
    #####:  228:	  the_program = compile_file(the_program, optarg);
call    0 never executed
    #####:  229:	  break;
        -:  230:
    #####:  231:	case 'i':
    #####:  232:	  separate_files = true;
    #####:  233:	  if (optarg == NULL)
branch  0 never executed
branch  1 never executed
        -:  234:	    /* use no backups */
    #####:  235:	    in_place_extension = ck_strdup ("*");
call    0 never executed
        -:  236:
    #####:  237:	  else if (strchr(optarg, '*') != NULL)
branch  0 never executed
branch  1 never executed
    #####:  238:	    in_place_extension = ck_strdup(optarg);
call    0 never executed
        -:  239:
        -:  240:	  else
        -:  241:	    {
    #####:  242:	      in_place_extension = MALLOC (strlen(optarg) + 2, char);
call    0 never executed
    #####:  243:	      in_place_extension[0] = '*';
    #####:  244:	      strcpy (in_place_extension + 1, optarg);
        -:  245:	    }
        -:  246:
    #####:  247:	  break;
        -:  248:
        1:  249:	case 'l':
        1:  250:	  lcmd_out_line_len = ATOI(optarg);
        1:  251:	  break;
        -:  252:
    #####:  253:	case 'p':
    #####:  254:	  posixicity = POSIXLY_BASIC;
    #####:  255:	  break;
        -:  256:
        1:  257:	case 'r':
        1:  258:	  if (extended_regexp_flags)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:  259:	    usage(4);
call    0 never executed
        1:  260:	  extended_regexp_flags = REG_EXTENDED;
        1:  261:	  break;
        -:  262:
        -:  263:#ifdef REG_PERL
        -:  264:	case 'R':
        -:  265:	  if (extended_regexp_flags)
        -:  266:	    usage(4);
        -:  267:	  extended_regexp_flags = REG_PERL;
        -:  268:	  break;
        -:  269:#endif
        -:  270:
        1:  271:	case 's':
        1:  272:	  separate_files = true;
        1:  273:	  break;
        -:  274:
        1:  275:	case 'u':
        1:  276:	  unbuffered_output = true;
        1:  277:	  break;
        -:  278:
    #####:  279:	case 'v':
        -:  280:#ifdef REG_PERL
        -:  281:	  fprintf(stdout, _("super-sed version %s\n"), VERSION);
        -:  282:	  fprintf(stdout, _("based on GNU sed version %s\n\n"), SED_FEATURE_VERSION);
        -:  283:#else
    #####:  284:	  fprintf(stdout, _("GNU sed version %s\n"), VERSION);
call    0 never executed
        -:  285:#endif
    #####:  286:	  fprintf(stdout, _("%s\n\
call    0 never executed
        -:  287:This is free software; see the source for copying conditions.  There is NO\n\
        -:  288:warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE,\n\
        -:  289:to the extent permitted by law.\n\
        -:  290:"), COPYRIGHT_NOTICE);
    #####:  291:	  ck_fclose (NULL);
call    0 never executed
    #####:  292:	  exit (0);
call    0 never executed
    #####:  293:	case 'h':
    #####:  294:	  usage(0);
call    0 never executed
    #####:  295:	default:
    #####:  296:	  usage(4);
call    0 never executed
        -:  297:	}
        -:  298:    }
        -:  299:
        1:  300:  if (!the_program)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -:  301:    {
    #####:  302:      if (optind < argc)
branch  0 never executed
branch  1 never executed
        -:  303:	{
    #####:  304:	  char *arg = argv[optind++];
    #####:  305:	  the_program = compile_string(the_program, arg, strlen(arg));
call    0 never executed
        -:  306:	}
        -:  307:      else
    #####:  308:	usage(4);
call    0 never executed
        -:  309:    }
        1:  310:  check_final_program(the_program);
call    0 returned 1
        -:  311:
        1:  312:  return_code = process_files(the_program, argv+optind);
call    0 returned 1
        -:  313:
        1:  314:  finish_program(the_program);
call    0 returned 1
        1:  315:  ck_fclose(NULL);
call    0 returned 0
        -:  316:
    #####:  317:  return return_code;
        -:  318:}
        -:  319:/*  GNU SED, a batch stream editor.
        -:  320:    Copyright (C) 1989,90,91,92,93,94,95,98,99,2002,2003,2004,2005,2006
        -:  321:    Free Software Foundation, Inc.
        -:  322:
        -:  323:    This program is free software; you can redistribute it and/or modify
        -:  324:    it under the terms of the GNU General Public License as published by
        -:  325:    the Free Software Foundation; either version 2, or (at your option)
        -:  326:    any later version.
        -:  327:
        -:  328:    This program is distributed in the hope that it will be useful,
        -:  329:    but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:  330:    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:  331:    GNU General Public License for more details.
        -:  332:
        -:  333:    You should have received a copy of the GNU General Public License
        -:  334:    along with this program; if not, write to the Free Software
        -:  335:    Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA. */
        -:  336:
        -:  337:/* compile.c: translate sed source into internal form */
        -:  338:
        -:  339:#include <stdio.h>
        -:  340:#include <ctype.h>
        -:  341:
        -:  342:#ifdef HAVE_STRINGS_H
        -:  343:# include <strings.h>
        -:  344:# ifdef HAVE_MEMORY_H
        -:  345:#  include <memory.h>
        -:  346:# endif
        -:  347:#else
        -:  348:# include <string.h>
        -:  349:#endif /* HAVE_STRINGS_H */
        -:  350:
        -:  351:#ifdef HAVE_STDLIB_H
        -:  352:# include <stdlib.h>
        -:  353:#endif
        -:  354:#ifndef EXIT_FAILURE
        -:  355:# define EXIT_FAILURE 1
        -:  356:#endif
        -:  357:
        -:  358:#ifdef HAVE_SYS_TYPES_H
        -:  359:# include <sys/types.h>
        -:  360:#endif
        -:  361:
        -:  362:#include "obstack.h"
        -:  363:
        -:  364:
        -:  365:#define YMAP_LENGTH		256 /*XXX shouldn't this be (UCHAR_MAX+1)?*/
        -:  366:#define VECTOR_ALLOC_INCREMENT	40
        -:  367:
        -:  368:/* let's not confuse text editors that have only dumb bracket-matching... */
        -:  369:#define OPEN_BRACKET	'['
        -:  370:#define CLOSE_BRACKET	']'
        -:  371:#define OPEN_BRACE	'{'
        -:  372:#define CLOSE_BRACE	'}'
        -:  373:
        -:  374:struct prog_info {
        -:  375:  /* When we're reading a script command from a string, `prog.base'
        -:  376:     points to the first character in the string, 'prog.cur' points
        -:  377:     to the current character in the string, and 'prog.end' points
        -:  378:     to the end of the string.  This allows us to compile script
        -:  379:     strings that contain nulls. */
        -:  380:  const unsigned char *base;
        -:  381:  const unsigned char *cur;
        -:  382:  const unsigned char *end;
        -:  383:
        -:  384:  /* This is the current script file.  If it is NULL, we are reading
        -:  385:     from a string stored at `prog.cur' instead.  If both `prog.file'
        -:  386:     and `prog.cur' are NULL, we're in trouble! */
        -:  387:  FILE *file;
        -:  388:};
        -:  389:
        -:  390:/* Information used to give out useful and informative error messages. */
        -:  391:struct error_info {
        -:  392:  /* This is the name of the current script file. */
        -:  393:  const char *name;
        -:  394:
        -:  395:  /* This is the number of the current script line that we're compiling. */
        -:  396:  countT line;
        -:  397:
        -:  398:  /* This is the index of the "-e" expressions on the command line. */
        -:  399:  countT string_expr_count;
        -:  400:};
        -:  401:
        -:  402:
        -:  403:/* Label structure used to resolve GOTO's, labels, and block beginnings. */
        -:  404:struct sed_label {
        -:  405:  countT v_index;		/* index of vector element being referenced */
        -:  406:  char *name;			/* NUL-terminated name of the label */
        -:  407:  struct error_info err_info;	/* track where `{}' blocks start */
        -:  408:  struct sed_label *next;	/* linked list (stack) */
        -:  409:};
        -:  410:
        -:  411:struct special_files {
        -:  412:  struct output outf;
        -:  413:  FILE **pfp;
        -:  414:};
        -:  415:
        -:  416:FILE *my_stdin, *my_stdout, *my_stderr;
        -:  417:struct special_files special_files[] = {
        -:  418:  { { "/dev/stdin", false, NULL, NULL }, &my_stdin },
        -:  419:  { { "/dev/stdout", false, NULL, NULL }, &my_stdout },
        -:  420:  { { "/dev/stdout", false, NULL, NULL }, &my_stderr },
        -:  421:  { { NULL, false, NULL, NULL }, NULL }
        -:  422:};
        -:  423:
        -:  424:
        -:  425:/* Where we are in the processing of the input. */
        -:  426:static struct prog_info prog;
        -:  427:static struct error_info cur_input;
        -:  428:
        -:  429:/* Information about labels and jumps-to-labels.  This is used to do
        -:  430:   the required backpatching after we have compiled all the scripts. */
        -:  431:static struct sed_label *jumps = NULL;
        -:  432:static struct sed_label *labels = NULL;
        -:  433:
        -:  434:/* We wish to detect #n magic only in the first input argument;
        -:  435:   this flag tracks when we have consumed the first file of input. */
        -:  436:static bool first_script = true;
        -:  437:
        -:  438:/* Allow for scripts like "sed -e 'i\' -e foo": */
        -:  439:static struct buffer *pending_text = NULL;
        -:  440:static struct text_buf *old_text_buf = NULL;
        -:  441:
        -:  442:/* Information about block start positions.  This is used to backpatch
        -:  443:   block end positions. */
        -:  444:static struct sed_label *blocks = NULL;
        -:  445:
        -:  446:/* Use an obstack for compilation. */
        -:  447:static struct obstack obs;
        -:  448:
        -:  449:/* Various error messages we may want to print */
        -:  450:static const char errors[] =
        -:  451:  "multiple `!'s\0"
        -:  452:  "unexpected `,'\0"
        -:  453:  "invalid usage of +N or ~N as first address\0"
        -:  454:  "unmatched `{'\0"
        -:  455:  "unexpected `}'\0"
        -:  456:  "extra characters after command\0"
        -:  457:  "expected \\ after `a', `c' or `i'\0"
        -:  458:  "`}' doesn't want any addresses\0"
        -:  459:  ": doesn't want any addresses\0"
        -:  460:  "comments don't accept any addresses\0"
        -:  461:  "missing command\0"
        -:  462:  "command only uses one address\0"
        -:  463:  "unterminated address regex\0"
        -:  464:  "unterminated `s' command\0"
        -:  465:  "unterminated `y' command\0"
        -:  466:  "unknown option to `s'\0"
        -:  467:  "multiple `p' options to `s' command\0"
        -:  468:  "multiple `g' options to `s' command\0"
        -:  469:  "multiple number options to `s' command\0"
        -:  470:  "number option to `s' command may not be zero\0"
        -:  471:  "strings for `y' command are different lengths\0"
        -:  472:  "delimiter character is not a single-byte character\0"
        -:  473:  "expected newer version of sed\0"
        -:  474:  "invalid usage of line address 0\0"
        -:  475:  "unknown command: `%c'";
        -:  476:
        -:  477:#define BAD_BANG (errors)
        -:  478:#define BAD_COMMA (BAD_BANG + sizeof(N_("multiple `!'s")))
        -:  479:#define BAD_STEP (BAD_COMMA + sizeof(N_("unexpected `,'")))
        -:  480:#define EXCESS_OPEN_BRACE (BAD_STEP + sizeof(N_("invalid usage of +N or ~N as first address")))
        -:  481:#define EXCESS_CLOSE_BRACE (EXCESS_OPEN_BRACE + sizeof(N_("unmatched `{'")))
        -:  482:#define EXCESS_JUNK (EXCESS_CLOSE_BRACE + sizeof(N_("unexpected `}'")))
        -:  483:#define EXPECTED_SLASH (EXCESS_JUNK + sizeof(N_("extra characters after command")))
        -:  484:#define NO_CLOSE_BRACE_ADDR (EXPECTED_SLASH + sizeof(N_("expected \\ after `a', `c' or `i'")))
        -:  485:#define NO_COLON_ADDR (NO_CLOSE_BRACE_ADDR + sizeof(N_("`}' doesn't want any addresses")))
        -:  486:#define NO_SHARP_ADDR (NO_COLON_ADDR + sizeof(N_(": doesn't want any addresses")))
        -:  487:#define NO_COMMAND (NO_SHARP_ADDR + sizeof(N_("comments don't accept any addresses")))
        -:  488:#define ONE_ADDR (NO_COMMAND + sizeof(N_("missing command")))
        -:  489:#define UNTERM_ADDR_RE (ONE_ADDR + sizeof(N_("command only uses one address")))
        -:  490:#define UNTERM_S_CMD (UNTERM_ADDR_RE + sizeof(N_("unterminated address regex")))
        -:  491:#define UNTERM_Y_CMD (UNTERM_S_CMD + sizeof(N_("unterminated `s' command")))
        -:  492:#define UNKNOWN_S_OPT (UNTERM_Y_CMD + sizeof(N_("unterminated `y' command")))
        -:  493:#define EXCESS_P_OPT (UNKNOWN_S_OPT + sizeof(N_("unknown option to `s'")))
        -:  494:#define EXCESS_G_OPT (EXCESS_P_OPT + sizeof(N_("multiple `p' options to `s' command")))
        -:  495:#define EXCESS_N_OPT (EXCESS_G_OPT + sizeof(N_("multiple `g' options to `s' command")))
        -:  496:#define ZERO_N_OPT (EXCESS_N_OPT + sizeof(N_("multiple number options to `s' command")))
        -:  497:#define Y_CMD_LEN (ZERO_N_OPT + sizeof(N_("number option to `s' command may not be zero")))
        -:  498:#define BAD_DELIM (Y_CMD_LEN + sizeof(N_("strings for `y' command are different lengths")))
        -:  499:#define ANCIENT_VERSION (BAD_DELIM + sizeof(N_("delimiter character is not a single-byte character")))
        -:  500:#define INVALID_LINE_0 (ANCIENT_VERSION + sizeof(N_("expected newer version of sed")))
        -:  501:#define UNKNOWN_CMD (INVALID_LINE_0 + sizeof(N_("invalid usage of line address 0")))
        -:  502:#define END_ERRORS (UNKNOWN_CMD + sizeof(N_("unknown command: `%c'")))
        -:  503:
        -:  504:static struct output *file_read = NULL;
        -:  505:static struct output *file_write = NULL;
        -:  506:
        -:  507:
        -:  508:/* Complain about an unknown command and exit. */
        -:  509:void
function bad_command called 0 returned 0% blocks executed 0%
    #####:  510:bad_command(ch)
        -:  511:  char ch;
        -:  512:{
    #####:  513:  const char *msg = _(UNKNOWN_CMD);
    #####:  514:  char *unknown_cmd = xmalloc(strlen(msg));
call    0 never executed
    #####:  515:  sprintf(unknown_cmd, msg, ch);
    #####:  516:  bad_prog(unknown_cmd);
call    0 never executed
    #####:  517:}
        -:  518:
        -:  519:/* Complain about a programming error and exit. */
        -:  520:void
function bad_prog called 0 returned 0% blocks executed 0%
    #####:  521:bad_prog(why)
        -:  522:  const char *why;
        -:  523:{
    #####:  524:  if (cur_input.name)
branch  0 never executed
branch  1 never executed
    #####:  525:    fprintf(stderr, _("%s: file %s line %lu: %s\n"),
    #####:  526:	    myname, cur_input.name, CAST(unsigned long)cur_input.line, why);
call    0 never executed
        -:  527:  else
    #####:  528:    fprintf(stderr, _("%s: -e expression #%lu, char %lu: %s\n"),
        -:  529:	    myname,
    #####:  530:	    CAST(unsigned long)cur_input.string_expr_count,
    #####:  531:	    CAST(unsigned long)(prog.cur-prog.base),
call    0 never executed
        -:  532:	    why);
    #####:  533:  exit(EXIT_FAILURE);
        -:  534:}
        -:  535:
        -:  536:
        -:  537:/* Read the next character from the program.  Return EOF if there isn't
        -:  538:   anything to read.  Keep cur_input.line up to date, so error messages
        -:  539:   can be meaningful. */
        -:  540:static int inchar P_((void));
        -:  541:static int
function inchar called 35 returned 100% blocks executed 55%
       35:  542:inchar()
        -:  543:{
       35:  544:  int ch = EOF;
        -:  545:
       35:  546:  if (prog.cur)
branch  0 taken 35 (fallthrough)
branch  1 taken 0
        -:  547:    {
       35:  548:      if (prog.cur < prog.end)
branch  0 taken 33 (fallthrough)
branch  1 taken 2
       33:  549:	ch = *prog.cur++;
        -:  550:    }
    #####:  551:  else if (prog.file)
branch  0 never executed
branch  1 never executed
        -:  552:    {
    #####:  553:      if (!feof(prog.file))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  554:	ch = getc(prog.file);
call    0 never executed
        -:  555:    }
       35:  556:  if (ch == '\n')
branch  0 taken 0 (fallthrough)
branch  1 taken 35
    #####:  557:    ++cur_input.line;
       35:  558:  return ch;
        -:  559:}
        -:  560:
        -:  561:/* unget `ch' so the next call to inchar will return it.   */
        -:  562:static void savchar P_((int ch));
        -:  563:static void
function savchar called 0 returned 0% blocks executed 0%
    #####:  564:savchar(ch)
        -:  565:  int ch;
        -:  566:{
    #####:  567:  if (ch == EOF)
branch  0 never executed
branch  1 never executed
    #####:  568:    return;
    #####:  569:  if (ch == '\n' && cur_input.line > 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  570:    --cur_input.line;
    #####:  571:  if (prog.cur)
branch  0 never executed
branch  1 never executed
        -:  572:    {
    #####:  573:      if (prog.cur <= prog.base || *--prog.cur != ch)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  574:	panic("Called savchar() with unexpected pushback (%x)",
    #####:  575:	      CAST(unsigned char)ch);
call    0 never executed
        -:  576:    }
        -:  577:  else
    #####:  578:    ungetc(ch, prog.file);
call    0 never executed
        -:  579:}
        -:  580:
        -:  581:/* Read the next non-blank character from the program.  */
        -:  582:static int in_nonblank P_((void));
        -:  583:static int
function in_nonblank called 3 returned 100% blocks executed 100%
        3:  584:in_nonblank()
        -:  585:{
        -:  586:  int ch;
        -:  587:  do
        3:  588:    ch = inchar();
call    0 returned 3
        3:  589:    while (ISBLANK(ch));
branch  0 taken 0
branch  1 taken 3 (fallthrough)
branch  2 taken 0
branch  3 taken 3 (fallthrough)
        3:  590:  return ch;
        -:  591:}
        -:  592:
        -:  593:/* Read an integer value from the program.  */
        -:  594:static countT in_integer P_((int ch));
        -:  595:static countT
function in_integer called 0 returned 0% blocks executed 0%
    #####:  596:in_integer(ch)
        -:  597:  int ch;
        -:  598:{
    #####:  599:  countT num = 0;
        -:  600:
    #####:  601:  while (ISDIGIT(ch))
branch  0 never executed
branch  1 never executed
        -:  602:    {
    #####:  603:      num = num * 10 + ch - '0';
    #####:  604:      ch = inchar();
call    0 never executed
        -:  605:    }
    #####:  606:  savchar(ch);
call    0 never executed
    #####:  607:  return num;
        -:  608:}
        -:  609:
        -:  610:static int add_then_next P_((struct buffer *b, int ch));
        -:  611:static int
function add_then_next called 4 returned 100% blocks executed 100%
        4:  612:add_then_next(b, ch)
        -:  613:  struct buffer *b;
        -:  614:  int ch;
        -:  615:{
        4:  616:  add1_buffer(b, ch);
call    0 returned 4
        4:  617:  return inchar();
call    0 returned 4
        -:  618:}
        -:  619:
        -:  620:static char * convert_number P_((char *, char *, const char *, int, int, int));
        -:  621:static char *
function convert_number called 0 returned 0% blocks executed 0%
    #####:  622:convert_number(result, buf, bufend, base, maxdigits, default_char)
        -:  623:  char *result;
        -:  624:  char *buf;
        -:  625:  const char *bufend;
        -:  626:  int base;
        -:  627:  int maxdigits;
        -:  628:  int default_char;
        -:  629:{
    #####:  630:  int n = 0;
        -:  631:  char *p;
        -:  632:
    #####:  633:  for (p=buf; p < bufend && maxdigits-- > 0; ++p)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  634:    {
    #####:  635:      int d = -1;
    #####:  636:      switch (*p)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
        -:  637:	{
    #####:  638:	case '0': d = 0x0; break;
    #####:  639:	case '1': d = 0x1; break;
    #####:  640:	case '2': d = 0x2; break;
    #####:  641:	case '3': d = 0x3; break;
    #####:  642:	case '4': d = 0x4; break;
    #####:  643:	case '5': d = 0x5; break;
    #####:  644:	case '6': d = 0x6; break;
    #####:  645:	case '7': d = 0x7; break;
    #####:  646:	case '8': d = 0x8; break;
    #####:  647:	case '9': d = 0x9; break;
    #####:  648:	case 'A': case 'a': d = 0xa; break;
    #####:  649:	case 'B': case 'b': d = 0xb; break;
    #####:  650:	case 'C': case 'c': d = 0xc; break;
    #####:  651:	case 'D': case 'd': d = 0xd; break;
    #####:  652:	case 'E': case 'e': d = 0xe; break;
    #####:  653:	case 'F': case 'f': d = 0xf; break;
        -:  654:	}
    #####:  655:      if (d < 0 || base <= d)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  656:	break;
    #####:  657:      n = n * base + d;
        -:  658:    }
    #####:  659:  if (p == buf)
branch  0 never executed
branch  1 never executed
    #####:  660:    *result = default_char;
        -:  661:  else
    #####:  662:    *result = n;
    #####:  663:  return p;
        -:  664:}
        -:  665:
        -:  666:
        -:  667:/* Read in a filename for a `r', `w', or `s///w' command. */
        -:  668:static struct buffer *read_filename P_((void));
        -:  669:static struct buffer *
function read_filename called 0 returned 0% blocks executed 0%
    #####:  670:read_filename()
        -:  671:{
        -:  672:  struct buffer *b;
        -:  673:  int ch;
        -:  674:
    #####:  675:  b = init_buffer();
call    0 never executed
    #####:  676:  ch = in_nonblank();
call    0 never executed
    #####:  677:  while (ch != EOF && ch != '\n')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  678:    {
        -:  679:#if 0 /*XXX ZZZ 1998-09-12 kpp: added, then had second thoughts*/
        -:  680:      if (posixicity == POSIXLY_EXTENDED)
        -:  681:	if (ch == ';' || ch == '#')
        -:  682:	  {
        -:  683:	    savchar(ch);
        -:  684:	    break;
        -:  685:	  }
        -:  686:#endif
    #####:  687:      ch = add_then_next(b, ch);
call    0 never executed
        -:  688:    }
    #####:  689:  add1_buffer(b, '\0');
call    0 never executed
    #####:  690:  return b;
        -:  691:}
        -:  692:
        -:  693:static struct output *get_openfile P_((struct output **file_ptrs, char *mode, bool fail));
        -:  694:static struct output *
function get_openfile called 0 returned 0% blocks executed 0%
    #####:  695:get_openfile(file_ptrs, mode, fail)
        -:  696:     struct output **file_ptrs;
        -:  697:     char *mode;
        -:  698:     bool fail;
        -:  699:{
        -:  700:  struct buffer *b;
        -:  701:  char *file_name;
        -:  702:  struct output *p;
        -:  703:  int is_stderr;
        -:  704:
    #####:  705:  b = read_filename();
call    0 never executed
    #####:  706:  file_name = get_buffer(b);
call    0 never executed
    #####:  707:  for (p=*file_ptrs; p; p=p->link)
branch  0 never executed
branch  1 never executed
    #####:  708:    if (strcmp(p->name, file_name) == 0)
branch  0 never executed
branch  1 never executed
    #####:  709:      break;
        -:  710:
    #####:  711:  if (posixicity == POSIXLY_EXTENDED)
branch  0 never executed
branch  1 never executed
        -:  712:    {
        -:  713:      /* Check whether it is a special file (stdin, stdout or stderr) */
    #####:  714:      struct special_files *special = special_files;
        -:  715:		  
        -:  716:      /* std* sometimes are not constants, so they
        -:  717:         cannot be used in the initializer for special_files */
    #####:  718:      my_stdin = stdin; my_stdout = stdout; my_stderr = stderr;
    #####:  719:      for (special = special_files; special->outf.name; special++)
branch  0 never executed
branch  1 never executed
    #####:  720:        if (strcmp(special->outf.name, file_name) == 0)
branch  0 never executed
branch  1 never executed
        -:  721:          {
    #####:  722:	    special->outf.fp = *special->pfp;
    #####:  723:	    free_buffer (b);
call    0 never executed
    #####:  724:	    return &special->outf;
        -:  725:          }
        -:  726:    }
        -:  727:
    #####:  728:  if (!p)
branch  0 never executed
branch  1 never executed
        -:  729:    {
    #####:  730:      p = OB_MALLOC(&obs, 1, struct output);
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:  731:      p->name = ck_strdup(file_name);
call    0 never executed
    #####:  732:      p->fp = ck_fopen(p->name, mode, fail);
call    0 never executed
    #####:  733:      p->missing_newline = false;
    #####:  734:      p->link = *file_ptrs;
    #####:  735:      *file_ptrs = p;
        -:  736:    }
    #####:  737:  free_buffer(b);
call    0 never executed
    #####:  738:  return p;
        -:  739:}
        -:  740:
        -:  741:
        -:  742:static struct sed_cmd *next_cmd_entry P_((struct vector **vectorp));
        -:  743:static struct sed_cmd *
function next_cmd_entry called 2 returned 100% blocks executed 100%
        2:  744:next_cmd_entry(vectorp)
        -:  745:  struct vector **vectorp;
        -:  746:{
        -:  747:  struct sed_cmd *cmd;
        -:  748:  struct vector *v;
        -:  749:
        2:  750:  v = *vectorp;
        2:  751:  if (v->v_length == v->v_allocated)
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        -:  752:    {
        1:  753:      v->v_allocated += VECTOR_ALLOC_INCREMENT;
        1:  754:      v->v = REALLOC(v->v, v->v_allocated, struct sed_cmd);
call    0 returned 1
        -:  755:    }
        -:  756:
        2:  757:  cmd = v->v + v->v_length;
        2:  758:  cmd->a1 = NULL;
        2:  759:  cmd->a2 = NULL;
        2:  760:  cmd->range_state = RANGE_INACTIVE;
        2:  761:  cmd->addr_bang = false;
        2:  762:  cmd->cmd = '\0';	/* something invalid, to catch bugs early */
        -:  763:
        2:  764:  *vectorp  = v;
        2:  765:  return cmd;
        -:  766:}
        -:  767:
        -:  768:static int snarf_char_class P_((struct buffer *b, mbstate_t *cur_stat));
        -:  769:static int
function snarf_char_class called 2 returned 100% blocks executed 39%
        2:  770:snarf_char_class(b, cur_stat)
        -:  771:  struct buffer *b;
        -:  772:  mbstate_t *cur_stat;
        -:  773:{
        -:  774:  int ch;
        2:  775:  int state = 0;
        -:  776:  int delim;
        2:  777:  bool pending_mb = 0;
        -:  778:  
        2:  779:  ch = inchar();
call    0 returned 2
        2:  780:  if (ch == '^')
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####:  781:    ch = add_then_next(b, ch);
call    0 never executed
        2:  782:  if (ch == CLOSE_BRACKET)
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####:  783:    ch = add_then_next(b, ch);
call    0 never executed
        -:  784:  
        -:  785:  /* States are:
        -:  786:	0 outside a collation element, character class or collation class
        -:  787:	1 after the bracket
        -:  788:	2 after the opening ./:/=
        -:  789:	3 after the closing ./:/= */
        -:  790:
        4:  791:  for (;; ch = add_then_next (b, ch))
call    0 returned 4
        -:  792:    {
        6:  793:      pending_mb = BRLEN (ch, cur_stat) != 1;
        -:  794:
       6*:  795:      switch (ch)
branch  0 taken 0
branch  1 taken 0
branch  2 taken 0
branch  3 taken 2
branch  4 taken 4
        -:  796:	{
    #####:  797:	case EOF:
        -:  798:	case '\n':
    #####:  799:	  return ch;
        -:  800:
    #####:  801:	case '.':
        -:  802:	case ':':
        -:  803:	case '=':
    #####:  804:	  if (pending_mb)
branch  0 never executed
branch  1 never executed
    #####:  805:	    continue;
        -:  806:
    #####:  807:	  if (state == 1)
branch  0 never executed
branch  1 never executed
        -:  808:	    {
    #####:  809:	      delim = ch;
    #####:  810:	      state++;
        -:  811:	    }
    #####:  812:	  else if (ch == delim && state == 2)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  813:	    state++;
        -:  814:	  else
        -:  815:	    break;
        -:  816:
    #####:  817:	  continue;
        -:  818:
    #####:  819:	case OPEN_BRACKET:
    #####:  820:	  if (pending_mb)
branch  0 never executed
branch  1 never executed
    #####:  821:	    continue;
        -:  822:
    #####:  823:	  state++;
    #####:  824:	  continue;
        -:  825:
        2:  826:	case CLOSE_BRACKET:
       2*:  827:	  if (pending_mb)
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####:  828:	    continue;
        -:  829:
       2*:  830:	  if (state == 0 || state == 1)
branch  0 taken 0 (fallthrough)
branch  1 taken 2
branch  2 never executed
branch  3 never executed
        2:  831:	    return ch;
    #####:  832:	  else if (state == 3)
branch  0 never executed
branch  1 never executed
    #####:  833:	    state = 0;
        -:  834:
    #####:  835:	  break;
        -:  836:
        4:  837:	default:
        4:  838:	  break;
        -:  839:	}
        -:  840:
        -:  841:      /* Getting a character different from .=: whilst in state 1
        -:  842:         goes back to state 0, getting a character different from ]
        -:  843:         whilst in state 3 goes back to state 2.  */
        4:  844:      state &= ~1;
        -:  845:    }
        -:  846:}
        -:  847:
        -:  848:static struct buffer *match_slash P_((int slash, bool regex));
        -:  849:static struct buffer *
function match_slash called 2 returned 100% blocks executed 55%
        2:  850:match_slash(slash, regex)
        -:  851:  int slash;
        -:  852:  bool regex;
        -:  853:{
        -:  854:  struct buffer *b;
        -:  855:  int ch;
        2:  856:  bool pending_mb = false;
        -:  857:  mbstate_t cur_stat;
        -:  858:
        2:  859:  memset (&cur_stat, 0, sizeof (mbstate_t));
        -:  860:
        -:  861:  if (BRLEN (slash, &cur_stat) == -2)
        -:  862:  if (BRLEN (slash, &cur_stat) == -2)
        -:  863:    bad_prog (BAD_DELIM);
        -:  864:
        2:  865:  memset (&cur_stat, 0, sizeof (mbstate_t));
        -:  866:
        2:  867:  b = init_buffer();
call    0 returned 2
       21:  868:  while ((ch = inchar()) != EOF && ch != '\n')
call    0 returned 21
branch  1 taken 21 (fallthrough)
branch  2 taken 0
branch  3 taken 21
branch  4 taken 0 (fallthrough)
        -:  869:    {
       21:  870:      pending_mb = BRLEN (ch, &cur_stat) != 1;
       21:  871:      pending_mb = BRLEN (ch, &cur_stat) != 1;
        -:  872:
       21:  873:      if (!pending_mb)
branch  0 taken 21 (fallthrough)
branch  1 taken 0
        -:  874:	{
       21:  875:	  if (ch == slash)
branch  0 taken 2 (fallthrough)
branch  1 taken 19
        2:  876:	    return b;
       19:  877:	  else if (ch == '\\')
branch  0 taken 0 (fallthrough)
branch  1 taken 19
        -:  878:	    {
    #####:  879:	      ch = inchar();
call    0 never executed
    #####:  880:	      if (ch == EOF)
branch  0 never executed
branch  1 never executed
    #####:  881:	        break;
        -:  882:#ifndef REG_PERL
    #####:  883:	      else if (ch == 'n' && regex)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  884:	        ch = '\n';
        -:  885:#endif
    #####:  886:	      else if (ch != '\n' && ch != slash)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  887:	        add1_buffer(b, '\\');
call    0 never executed
        -:  888:	    }
       19:  889:          else if (ch == OPEN_BRACKET && regex)
branch  0 taken 2 (fallthrough)
branch  1 taken 17
branch  2 taken 2 (fallthrough)
branch  3 taken 0
        -:  890:	    {
        2:  891:	      add1_buffer(b, ch);
call    0 returned 2
        2:  892:	      ch = snarf_char_class(b, &cur_stat);
call    0 returned 2
        2:  893:	      if (ch != CLOSE_BRACKET)
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####:  894:	        break;
        -:  895:	    }
        -:  896:	}
        -:  897:
       19:  898:      add1_buffer(b, ch);
call    0 returned 19
        -:  899:    }
        -:  900:
    #####:  901:  if (ch == '\n')
branch  0 never executed
branch  1 never executed
    #####:  902:    savchar(ch);	/* for proper line number in error report */
call    0 never executed
    #####:  903:  free_buffer(b);
call    0 never executed
    #####:  904:  return NULL;
        -:  905:}
        -:  906:
        -:  907:static int mark_subst_opts P_((struct subst *cmd));
        -:  908:static int
function mark_subst_opts called 1 returned 100% blocks executed 29%
        1:  909:mark_subst_opts(cmd)
        -:  910:  struct subst *cmd;
        -:  911:{
        1:  912:  int flags = 0;
        -:  913:  int ch;
        -:  914:
        1:  915:  cmd->global = false;
        1:  916:  cmd->print = false;
        1:  917:  cmd->eval = false;
        1:  918:  cmd->numb = 0;
        1:  919:  cmd->outf = NULL;
        -:  920:
        -:  921:  for (;;)
        2:  922:    switch ( (ch = in_nonblank()) )
call    0 returned 2
branch  1 taken 0
branch  2 taken 0
branch  3 taken 0
branch  4 taken 0
branch  5 taken 1
branch  6 taken 0
branch  7 taken 0
branch  8 taken 0
branch  9 taken 1
branch 10 taken 0
branch 11 taken 0
        -:  923:      {
    #####:  924:      case 'i':	/* GNU extension */
        -:  925:      case 'I':	/* GNU extension */
    #####:  926:	flags |= REG_ICASE;
    #####:  927:	break;
        -:  928:
        -:  929:#ifdef REG_PERL
        -:  930:      case 's':	/* GNU extension */
        -:  931:      case 'S':	/* GNU extension */
        -:  932:	if (extended_regexp_flags & REG_PERL)
        -:  933:	  flags |= REG_DOTALL;
        -:  934:	break;
        -:  935:
        -:  936:      case 'x':	/* GNU extension */
        -:  937:      case 'X':	/* GNU extension */
        -:  938:	if (extended_regexp_flags & REG_PERL)
        -:  939:	  flags |= REG_EXTENDED;
        -:  940:	break;
        -:  941:#endif
        -:  942:
    #####:  943:      case 'm':	/* GNU extension */
        -:  944:      case 'M':	/* GNU extension */
    #####:  945:	flags |= REG_NEWLINE;
    #####:  946:	break;
        -:  947:
    #####:  948:      case 'e':
    #####:  949:	cmd->eval = true;
    #####:  950:	break;
        -:  951:
    #####:  952:      case 'p':
    #####:  953:	if (cmd->print)
branch  0 never executed
branch  1 never executed
    #####:  954:	  bad_prog(_(EXCESS_P_OPT));
call    0 never executed
    #####:  955:	cmd->print |= (1 << cmd->eval); /* 1=before eval, 2=after */
    #####:  956:	break;
        -:  957:
        1:  958:      case 'g':
        1:  959:	if (cmd->global)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:  960:	  bad_prog(_(EXCESS_G_OPT));
call    0 never executed
        1:  961:	cmd->global = true;
        1:  962:	break;
        -:  963:
    #####:  964:      case 'w':
    #####:  965:	cmd->outf = get_openfile(&file_write, "w", true);
call    0 never executed
    #####:  966:	return flags;
        -:  967:
    #####:  968:      case '0': case '1': case '2': case '3': case '4':
        -:  969:      case '5': case '6': case '7': case '8': case '9':
    #####:  970:	if (cmd->numb)
branch  0 never executed
branch  1 never executed
    #####:  971:	  bad_prog(_(EXCESS_N_OPT));
call    0 never executed
    #####:  972:	cmd->numb = in_integer(ch);
call    0 never executed
    #####:  973:	if (!cmd->numb)
branch  0 never executed
branch  1 never executed
    #####:  974:	  bad_prog(_(ZERO_N_OPT));
call    0 never executed
    #####:  975:	break;
        -:  976:
    #####:  977:      case CLOSE_BRACE:
        -:  978:      case '#':
    #####:  979:	savchar(ch);
call    0 never executed
        -:  980:	/* Fall Through */
        1:  981:      case EOF:
        -:  982:      case '\n':
        -:  983:      case ';':
        1:  984:	return flags;
        -:  985:
    #####:  986:      case '\r':
    #####:  987:	if (inchar() == '\n')
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  988:	  return flags;
        -:  989:	/* FALLTHROUGH */
        -:  990:
        -:  991:      default:
    #####:  992:	bad_prog(_(UNKNOWN_S_OPT));
call    0 never executed
        -:  993:	/*NOTREACHED*/
        -:  994:      }
        -:  995:}
        -:  996:
        -:  997:
        -:  998:/* read in a label for a `:', `b', or `t' command */
        -:  999:static char *read_label P_((void));
        -: 1000:static char *
function read_label called 0 returned 0% blocks executed 0%
    #####: 1001:read_label()
        -: 1002:{
        -: 1003:  struct buffer *b;
        -: 1004:  int ch;
        -: 1005:  char *ret;
        -: 1006:
    #####: 1007:  b = init_buffer();
call    0 never executed
    #####: 1008:  ch = in_nonblank();
call    0 never executed
        -: 1009:
    #####: 1010:  while (ch != EOF && ch != '\n'
branch  0 never executed
branch  1 never executed
    #####: 1011:	 && !ISBLANK(ch) && ch != ';' && ch != CLOSE_BRACE && ch != '#')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
    #####: 1012:    ch = add_then_next (b, ch);
call    0 never executed
        -: 1013:
    #####: 1014:  savchar(ch);
call    0 never executed
    #####: 1015:  add1_buffer(b, '\0');
call    0 never executed
    #####: 1016:  ret = ck_strdup(get_buffer(b));
call    0 never executed
call    1 never executed
    #####: 1017:  free_buffer(b);
call    0 never executed
    #####: 1018:  return ret;
        -: 1019:}
        -: 1020:
        -: 1021:/* Store a label (or label reference) created by a `:', `b', or `t'
        -: 1022:   command so that the jump to/from the label can be backpatched after
        -: 1023:   compilation is complete, or a reference created by a `{' to be
        -: 1024:   backpatched when the corresponding `}' is found.  */
        -: 1025:static struct sed_label *setup_label
        -: 1026:  P_((struct sed_label *, countT, char *, const struct error_info *));
        -: 1027:static struct sed_label *
function setup_label called 0 returned 0% blocks executed 0%
    #####: 1028:setup_label(list, idx, name, err_info)
        -: 1029:  struct sed_label *list;
        -: 1030:  countT idx;
        -: 1031:  char *name;
        -: 1032:  const struct error_info *err_info;
        -: 1033:{
    #####: 1034:  struct sed_label *ret = OB_MALLOC(&obs, 1, struct sed_label);
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####: 1035:  ret->v_index = idx;
    #####: 1036:  ret->name = name;
    #####: 1037:  if (err_info)
branch  0 never executed
branch  1 never executed
    #####: 1038:    MEMCPY(&ret->err_info, err_info, sizeof (ret->err_info));
    #####: 1039:  ret->next = list;
    #####: 1040:  return ret;
        -: 1041:}
        -: 1042:
        -: 1043:static struct sed_label *release_label P_((struct sed_label *list_head));
        -: 1044:static struct sed_label *
function release_label called 0 returned 0% blocks executed 0%
    #####: 1045:release_label(list_head)
        -: 1046:  struct sed_label *list_head;
        -: 1047:{
        -: 1048:  struct sed_label *ret;
        -: 1049:
    #####: 1050:  if (!list_head)
branch  0 never executed
branch  1 never executed
    #####: 1051:    return NULL;
    #####: 1052:  ret = list_head->next;
        -: 1053:
    #####: 1054:  FREE(list_head->name);
call    0 never executed
        -: 1055:
        -: 1056:#if 0
        -: 1057:  /* We use obstacks */
        -: 1058:  FREE(list_head);
        -: 1059:#endif
    #####: 1060:  return ret;
        -: 1061:}
        -: 1062:
        -: 1063:static struct replacement *new_replacement P_((char *, size_t,
        -: 1064:					       enum replacement_types));
        -: 1065:static struct replacement *
function new_replacement called 1 returned 100% blocks executed 62%
        1: 1066:new_replacement(text, length, type)
        -: 1067:  char *text;
        -: 1068:  size_t length;
        -: 1069:  enum replacement_types type;
        -: 1070:{
       1*: 1071:  struct replacement *r = OB_MALLOC(&obs, 1, struct replacement);
branch  0 taken 0 (fallthrough)
branch  1 taken 1
call    2 never executed
branch  3 taken 0 (fallthrough)
branch  4 taken 1
branch  5 taken 0 (fallthrough)
branch  6 taken 1
        -: 1072:
        1: 1073:  r->prefix = text;
        1: 1074:  r->prefix_length = length;
        1: 1075:  r->subst_id = -1;
        1: 1076:  r->repl_type = type;
        -: 1077:
        -: 1078:  /* r-> next = NULL; */
        1: 1079:  return r;
        -: 1080:}
        -: 1081:
        -: 1082:static void setup_replacement P_((struct subst *, const char *, size_t));
        -: 1083:static void
function setup_replacement called 1 returned 100% blocks executed 39%
        1: 1084:setup_replacement(sub, text, length)
        -: 1085:     struct subst *sub;
        -: 1086:     const char *text;
        -: 1087:     size_t length;
        -: 1088:{
        -: 1089:  char *base;
        -: 1090:  char *p;
        -: 1091:  char *text_end;
        1: 1092:  enum replacement_types repl_type = REPL_ASIS, save_type = REPL_ASIS;
        -: 1093:  struct replacement root;
        -: 1094:  struct replacement *tail;
        -: 1095:
        1: 1096:  sub->max_id = 0;
        1: 1097:  base = MEMDUP(text, length, char);
call    0 returned 1
        1: 1098:  length = normalize_text(base, length, TEXT_REPLACEMENT);
call    0 returned 1
        -: 1099:
        1: 1100:  text_end = base + length;
        1: 1101:  tail = &root;
        -: 1102:
        9: 1103:  for (p=base; p<text_end; ++p)
branch  0 taken 8
branch  1 taken 1 (fallthrough)
        -: 1104:    {
        8: 1105:      if (*p == '\\')
branch  0 taken 0 (fallthrough)
branch  1 taken 8
        -: 1106:	{
        -: 1107:	  /* Preceding the backslash may be some literal text: */
    #####: 1108:	  tail = tail->next =
    #####: 1109:	    new_replacement(base, CAST(size_t)(p - base), repl_type);
call    0 never executed
        -: 1110:
    #####: 1111:	  repl_type = save_type;
        -: 1112:
        -: 1113:	  /* Skip the backslash and look for a numeric back-reference,
        -: 1114:	     or a case-munging escape if not in POSIX mode: */
    #####: 1115:	  ++p;
    #####: 1116:	  if (p < text_end && (posixicity != POSIXLY_BASIC || ISDIGIT (*p)))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1117:	    switch (*p)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
        -: 1118:	      {
    #####: 1119:	      case '0': case '1': case '2': case '3': case '4': 
        -: 1120:	      case '5': case '6': case '7': case '8': case '9': 
    #####: 1121:		tail->subst_id = *p - '0';
    #####: 1122:		if (sub->max_id < tail->subst_id)
branch  0 never executed
branch  1 never executed
    #####: 1123:		  sub->max_id = tail->subst_id;
    #####: 1124:		break;
        -: 1125:
    #####: 1126:	      case 'L':
    #####: 1127:		repl_type = REPL_LOWERCASE;
    #####: 1128:		save_type = REPL_LOWERCASE;
    #####: 1129:		break;
        -: 1130:
    #####: 1131:	      case 'U':
    #####: 1132:		repl_type = REPL_UPPERCASE;
    #####: 1133:		save_type = REPL_UPPERCASE;
    #####: 1134:		break;
        -: 1135:		
    #####: 1136:	      case 'E':
    #####: 1137:		repl_type = REPL_ASIS;
    #####: 1138:		save_type = REPL_ASIS;
    #####: 1139:		break;
        -: 1140:
    #####: 1141:	      case 'l':
    #####: 1142:		save_type = repl_type;
    #####: 1143:		repl_type |= REPL_LOWERCASE_FIRST;
    #####: 1144:		break;
        -: 1145:
    #####: 1146:	      case 'u':
    #####: 1147:		save_type = repl_type;
    #####: 1148:		repl_type |= REPL_UPPERCASE_FIRST;
    #####: 1149:		break;
        -: 1150:		
    #####: 1151:	      default:
    #####: 1152:		p[-1] = *p;
    #####: 1153:		++tail->prefix_length;
        -: 1154:	      }
        -: 1155:
    #####: 1156:	  base = p + 1;
        -: 1157:	}
        8: 1158:      else if (*p == '&')
branch  0 taken 0 (fallthrough)
branch  1 taken 8
        -: 1159:	{
        -: 1160:	  /* Preceding the ampersand may be some literal text: */
    #####: 1161:	  tail = tail->next =
    #####: 1162:	    new_replacement(base, CAST(size_t)(p - base), repl_type);
call    0 never executed
        -: 1163:
    #####: 1164:	  repl_type = save_type;
    #####: 1165:	  tail->subst_id = 0;
    #####: 1166:	  base = p + 1;
        -: 1167:	}
        -: 1168:  }
        -: 1169:  /* There may be some trailing literal text: */
        1: 1170:  if (base < text_end)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 1171:    tail = tail->next =
        1: 1172:      new_replacement(base, CAST(size_t)(text_end - base), repl_type);
call    0 returned 1
        -: 1173:
        1: 1174:  tail->next = NULL;
        1: 1175:  sub->replacement = root.next;
        1: 1176:}
        -: 1177:
        -: 1178:static void read_text P_((struct text_buf *buf, int leadin_ch));
        -: 1179:static void
function read_text called 0 returned 0% blocks executed 0%
    #####: 1180:read_text(buf, leadin_ch)
        -: 1181:  struct text_buf *buf;
        -: 1182:  int leadin_ch;
        -: 1183:{
        -: 1184:  int ch;
        -: 1185:
        -: 1186:  /* Should we start afresh (as opposed to continue a partial text)? */
    #####: 1187:  if (buf)
branch  0 never executed
branch  1 never executed
        -: 1188:    {
    #####: 1189:      if (pending_text)
branch  0 never executed
branch  1 never executed
    #####: 1190:	free_buffer(pending_text);
call    0 never executed
    #####: 1191:      pending_text = init_buffer();
call    0 never executed
    #####: 1192:      buf->text = NULL;
    #####: 1193:      buf->text_length = 0;
    #####: 1194:      old_text_buf = buf;
        -: 1195:    }
        -: 1196:  /* assert(old_text_buf != NULL); */
        -: 1197:
    #####: 1198:  if (leadin_ch == EOF)
branch  0 never executed
branch  1 never executed
    #####: 1199:    return;
        -: 1200:
    #####: 1201:  if (leadin_ch != '\n')
branch  0 never executed
branch  1 never executed
    #####: 1202:    add1_buffer(pending_text, leadin_ch);
call    0 never executed
        -: 1203:
    #####: 1204:  ch = inchar();
call    0 never executed
    #####: 1205:  while (ch != EOF && ch != '\n')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1206:    {
    #####: 1207:      if (ch == '\\')
branch  0 never executed
branch  1 never executed
        -: 1208:	{
    #####: 1209:	  ch = inchar();
call    0 never executed
    #####: 1210:	  if (ch != EOF)
branch  0 never executed
branch  1 never executed
    #####: 1211:	    add1_buffer (pending_text, '\\');
call    0 never executed
        -: 1212:	}
        -: 1213:
    #####: 1214:      if (ch == EOF)
branch  0 never executed
branch  1 never executed
        -: 1215:	{
    #####: 1216:	  add1_buffer (pending_text, '\n');
call    0 never executed
    #####: 1217:	  return;
        -: 1218:	}
        -: 1219:
    #####: 1220:      ch = add_then_next (pending_text, ch);
call    0 never executed
        -: 1221:    }
        -: 1222:
    #####: 1223:  add1_buffer(pending_text, '\n');
call    0 never executed
    #####: 1224:  if (!buf)
branch  0 never executed
branch  1 never executed
    #####: 1225:    buf = old_text_buf;
    #####: 1226:  buf->text_length = normalize_text (get_buffer (pending_text),
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1227:				     size_buffer (pending_text), TEXT_BUFFER);
    #####: 1228:  buf->text = MEMDUP(get_buffer(pending_text), buf->text_length, char);
call    0 never executed
call    1 never executed
    #####: 1229:  free_buffer(pending_text);
call    0 never executed
    #####: 1230:  pending_text = NULL;
        -: 1231:}
        -: 1232:
        -: 1233:
        -: 1234:/* Try to read an address for a sed command.  If it succeeds,
        -: 1235:   return non-zero and store the resulting address in `*addr'.
        -: 1236:   If the input doesn't look like an address read nothing
        -: 1237:   and return zero.  */
        -: 1238:static bool compile_address P_((struct addr *addr, int ch));
        -: 1239:static bool
function compile_address called 2 returned 100% blocks executed 20%
        2: 1240:compile_address(addr, ch)
        -: 1241:  struct addr *addr;
        -: 1242:  int ch;
        -: 1243:{
        2: 1244:  addr->addr_type = ADDR_IS_NULL;
        2: 1245:  addr->addr_step = 0;
        2: 1246:  addr->addr_number = ~(countT)0;  /* extremely unlikely to ever match */
        2: 1247:  addr->addr_regex = NULL;
        -: 1248:
        2: 1249:  if (ch == '/' || ch == '\\')
branch  0 taken 2 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 2
        -: 1250:    {
    #####: 1251:      int flags = 0;
        -: 1252:      struct buffer *b;
    #####: 1253:      addr->addr_type = ADDR_IS_REGEX;
    #####: 1254:      if (ch == '\\')
branch  0 never executed
branch  1 never executed
    #####: 1255:	ch = inchar();
call    0 never executed
    #####: 1256:      if ( !(b = match_slash(ch, true)) )
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1257:	bad_prog(_(UNTERM_ADDR_RE));
call    0 never executed
        -: 1258:
        -: 1259:      for(;;)
        -: 1260:	{
    #####: 1261:	  ch = in_nonblank();
call    0 never executed
    #####: 1262:          switch(ch)
branch  0 never executed
branch  1 never executed
branch  2 never executed
        -: 1263:	    {
    #####: 1264:	    case 'I':	/* GNU extension */
    #####: 1265:	      flags |= REG_ICASE;
    #####: 1266:	      break;
        -: 1267:
        -: 1268:#ifdef REG_PERL
        -: 1269:	    case 'S':	/* GNU extension */
        -: 1270:	      if (extended_regexp_flags & REG_PERL)
        -: 1271:		flags |= REG_DOTALL;
        -: 1272:	      break;
        -: 1273:
        -: 1274:	    case 'X':	/* GNU extension */
        -: 1275:	      if (extended_regexp_flags & REG_PERL)
        -: 1276:		flags |= REG_EXTENDED;
        -: 1277:	      break;
        -: 1278:#endif
        -: 1279:
    #####: 1280:	    case 'M':	/* GNU extension */
    #####: 1281:	      flags |= REG_NEWLINE;
    #####: 1282:	      break;
        -: 1283:
    #####: 1284:	    default:
    #####: 1285:	      savchar (ch);
call    0 never executed
    #####: 1286:	      addr->addr_regex = compile_regex (b, flags, 0);
call    0 never executed
    #####: 1287:	      free_buffer(b);
call    0 never executed
    #####: 1288:	      return true;
        -: 1289:	    }
        -: 1290:	}
        -: 1291:    }
        2: 1292:  else if (ISDIGIT(ch))
branch  0 taken 0 (fallthrough)
branch  1 taken 2
        -: 1293:    {
    #####: 1294:      addr->addr_number = in_integer(ch);
call    0 never executed
    #####: 1295:      addr->addr_type = ADDR_IS_NUM;
    #####: 1296:      ch = in_nonblank();
call    0 never executed
    #####: 1297:      if (ch != '~')
branch  0 never executed
branch  1 never executed
        -: 1298:	{
    #####: 1299:	  savchar(ch);
call    0 never executed
        -: 1300:	}
        -: 1301:      else
        -: 1302:	{
    #####: 1303:	  countT step = in_integer(in_nonblank());
call    0 never executed
call    1 never executed
    #####: 1304:	  if (step > 0)
branch  0 never executed
branch  1 never executed
        -: 1305:	    {
    #####: 1306:	      addr->addr_step = step;
    #####: 1307:	      addr->addr_type = ADDR_IS_NUM_MOD;
        -: 1308:	    }
        -: 1309:	}
        -: 1310:    }
        2: 1311:  else if (ch == '+' || ch == '~')
branch  0 taken 2 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 2
        -: 1312:    {
    #####: 1313:      addr->addr_step = in_integer(in_nonblank());
call    0 never executed
call    1 never executed
    #####: 1314:      if (addr->addr_step==0)
branch  0 never executed
branch  1 never executed
        -: 1315:	; /* default to ADDR_IS_NULL; forces matching to stop on next line */
    #####: 1316:      else if (ch == '+')
branch  0 never executed
branch  1 never executed
    #####: 1317:	addr->addr_type = ADDR_IS_STEP;
        -: 1318:      else
    #####: 1319:	addr->addr_type = ADDR_IS_STEP_MOD;
        -: 1320:    }
        2: 1321:  else if (ch == '$')
branch  0 taken 0 (fallthrough)
branch  1 taken 2
        -: 1322:    {
    #####: 1323:      addr->addr_type = ADDR_IS_LAST;
        -: 1324:    }
        -: 1325:  else
        2: 1326:    return false;
        -: 1327:
    #####: 1328:  return true;
        -: 1329:}
        -: 1330:
        -: 1331:/* Read a program (or a subprogram within `{' `}' pairs) in and store
        -: 1332:   the compiled form in `*vector'.  Return a pointer to the new vector.  */
        -: 1333:static struct vector *compile_program P_((struct vector *));
        -: 1334:static struct vector *
function compile_program called 1 returned 100% blocks executed 19%
        1: 1335:compile_program(vector)
        -: 1336:  struct vector *vector;
        -: 1337:{
        -: 1338:  struct sed_cmd *cur_cmd;
        -: 1339:  struct buffer *b;
        -: 1340:  int ch;
        -: 1341:
        1: 1342:  if (!vector)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -: 1343:    {
        1: 1344:      vector = MALLOC(1, struct vector);
call    0 returned 1
        1: 1345:      vector->v = NULL;
        1: 1346:      vector->v_allocated = 0;
        1: 1347:      vector->v_length = 0;
        -: 1348:
        1: 1349:      obstack_init (&obs);
call    0 returned 1
        -: 1350:    }
        1: 1351:  if (pending_text)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 1352:    read_text(NULL, '\n');
call    0 never executed
        -: 1353:
        -: 1354:  for (;;)
        2: 1355:    {
        -: 1356:      struct addr a;
        -: 1357:
        4: 1358:      while ((ch=inchar()) == ';' || ISSPACE(ch))
call    0 returned 4
branch  1 taken 0
branch  2 taken 4 (fallthrough)
branch  3 taken 1
branch  4 taken 3 (fallthrough)
        -: 1359:	;
        3: 1360:      if (ch == EOF)
branch  0 taken 1 (fallthrough)
branch  1 taken 2
        1: 1361:	break;
        -: 1362:
        2: 1363:      cur_cmd = next_cmd_entry(&vector);
call    0 returned 2
        2: 1364:      if (compile_address(&a, ch))
call    0 returned 2
branch  1 taken 0 (fallthrough)
branch  2 taken 2
        -: 1365:	{
    #####: 1366:	  if (a.addr_type == ADDR_IS_STEP
branch  0 never executed
branch  1 never executed
    #####: 1367:	      || a.addr_type == ADDR_IS_STEP_MOD)
branch  0 never executed
branch  1 never executed
    #####: 1368:	    bad_prog(_(BAD_STEP));
call    0 never executed
        -: 1369:
    #####: 1370:	  cur_cmd->a1 = MEMDUP(&a, 1, struct addr);
call    0 never executed
    #####: 1371:	  ch = in_nonblank();
call    0 never executed
    #####: 1372:	  if (ch == ',')
branch  0 never executed
branch  1 never executed
        -: 1373:	    {
    #####: 1374:	      if (!compile_address(&a, in_nonblank()))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1375:		bad_prog(_(BAD_COMMA));
call    0 never executed
        -: 1376:
    #####: 1377:	      cur_cmd->a2 = MEMDUP(&a, 1, struct addr);
call    0 never executed
    #####: 1378:	      ch = in_nonblank();
call    0 never executed
        -: 1379:	    }
        -: 1380:
    #####: 1381:	  if (cur_cmd->a1->addr_type == ADDR_IS_NUM
branch  0 never executed
branch  1 never executed
    #####: 1382:	      && cur_cmd->a1->addr_number == 0
branch  0 never executed
branch  1 never executed
    #####: 1383:	      && (!cur_cmd->a2 || cur_cmd->a2->addr_type != ADDR_IS_REGEX))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1384:	    bad_prog(_(INVALID_LINE_0));
call    0 never executed
        -: 1385:	}
        2: 1386:      if (ch == '!')
branch  0 taken 0 (fallthrough)
branch  1 taken 2
        -: 1387:	{
    #####: 1388:	  cur_cmd->addr_bang = true;
    #####: 1389:	  ch = in_nonblank();
call    0 never executed
    #####: 1390:	  if (ch == '!')
branch  0 never executed
branch  1 never executed
    #####: 1391:	    bad_prog(_(BAD_BANG));
call    0 never executed
        -: 1392:	}
        -: 1393:
        -: 1394:      /* Do not accept extended commands in --posix mode.  Also,
        -: 1395:	 a few commands only accept one address in that mode.  */
        2: 1396:      if (posixicity == POSIXLY_BASIC)
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####: 1397:	switch (ch)
branch  0 never executed
branch  1 never executed
branch  2 never executed
        -: 1398:	  {
    #####: 1399:	    case 'v': case 'L': case 'Q': case 'T':
        -: 1400:	    case 'R': case 'W':
    #####: 1401:	      bad_command(ch);
call    0 never executed
        -: 1402:
    #####: 1403:	    case 'a': case 'i': case 'l':
        -: 1404:	    case '=': case 'r':
    #####: 1405:	      if (cur_cmd->a2)
branch  0 never executed
branch  1 never executed
    #####: 1406:	        bad_prog(_(ONE_ADDR));
call    0 never executed
        -: 1407:	  }
        -: 1408:
        2: 1409:      cur_cmd->cmd = ch;
       2*: 1410:      switch (ch)
branch  0 taken 0
branch  1 taken 0
branch  2 taken 0
branch  3 taken 0
branch  4 taken 0
branch  5 taken 0
branch  6 taken 0
branch  7 taken 0
branch  8 taken 0
branch  9 taken 1
branch 10 taken 0
branch 11 taken 0
branch 12 taken 0
branch 13 taken 0
branch 14 taken 1
branch 15 taken 0
branch 16 taken 0
branch 17 taken 0
        -: 1411:	{
    #####: 1412:	case '#':
    #####: 1413:	  if (cur_cmd->a1)
branch  0 never executed
branch  1 never executed
    #####: 1414:	    bad_prog(_(NO_SHARP_ADDR));
call    0 never executed
    #####: 1415:	  ch = inchar();
call    0 never executed
    #####: 1416:	  if (ch=='n' && first_script && cur_input.line < 2)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1417:	    if (   (prog.base && prog.cur==2+prog.base)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1418:		|| (prog.file && !prog.base && 2==ftell(prog.file)))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
    #####: 1419:	      no_default_output = true;
    #####: 1420:	  while (ch != EOF && ch != '\n')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1421:	    ch = inchar();
call    0 never executed
    #####: 1422:	  continue;	/* restart the for (;;) loop */
        -: 1423:
    #####: 1424:	case 'v':
        -: 1425:	  /* This is an extension.  Programs needing GNU sed might start
        -: 1426:	   * with a `v' command so that other seds will stop.
        -: 1427:	   * We compare the version and ignore POSIXLY_CORRECT.
        -: 1428:	   */
        -: 1429:	  {
    #####: 1430:	    char *version = read_label ();
call    0 never executed
        -: 1431:	    char *compared_version;
    #####: 1432:	    compared_version = (*version == '\0') ? "4.0" : version;
branch  0 never executed
branch  1 never executed
        -: 1433:	    /*
        -: 1434:	      Removed by Kyle R. Murphy July 2006 to remove a source of
        -: 1435:	      non-determinism in this version of sed
        -: 1436:	    if (strverscmp (compared_version, SED_FEATURE_VERSION) > 0)
        -: 1437:	      bad_prog(_(ANCIENT_VERSION));
        -: 1438:	    */
    #####: 1439:	    free (version);
    #####: 1440:	    posixicity = POSIXLY_EXTENDED;
        -: 1441:	  }
    #####: 1442:	  continue;
        -: 1443:
    #####: 1444:	case '{':
    #####: 1445:	  blocks = setup_label(blocks, vector->v_length, NULL, &cur_input);
call    0 never executed
    #####: 1446:	  cur_cmd->addr_bang = !cur_cmd->addr_bang;
    #####: 1447:	  break;
        -: 1448:
    #####: 1449:	case '}':
    #####: 1450:	  if (!blocks)
branch  0 never executed
branch  1 never executed
    #####: 1451:	    bad_prog(_(EXCESS_CLOSE_BRACE));
call    0 never executed
    #####: 1452:	  if (cur_cmd->a1)
branch  0 never executed
branch  1 never executed
    #####: 1453:	    bad_prog(_(NO_CLOSE_BRACE_ADDR));
call    0 never executed
    #####: 1454:	  ch = in_nonblank();
call    0 never executed
    #####: 1455:	  if (ch == CLOSE_BRACE || ch == '#')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1456:	    savchar(ch);
call    0 never executed
    #####: 1457:	  else if (ch != EOF && ch != '\n' && ch != ';')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1458:	    bad_prog(_(EXCESS_JUNK));
call    0 never executed
        -: 1459:
    #####: 1460:	  vector->v[blocks->v_index].x.jump_index = vector->v_length;
    #####: 1461:	  blocks = release_label(blocks);	/* done with this entry */
call    0 never executed
    #####: 1462:	  break;
        -: 1463:
    #####: 1464:	case 'e':
    #####: 1465:	  ch = in_nonblank();
call    0 never executed
    #####: 1466:	  if (ch == EOF || ch == '\n')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1467:	    {
    #####: 1468:	      cur_cmd->x.cmd_txt.text_length = 0;
    #####: 1469:	      break;
        -: 1470:	    }
        -: 1471:	  else
    #####: 1472:	    goto read_text_to_slash;
        -: 1473:
    #####: 1474:	case 'a':
        -: 1475:	case 'i':
        -: 1476:	case 'c':
    #####: 1477:	  ch = in_nonblank();
call    0 never executed
        -: 1478:
    #####: 1479:	read_text_to_slash:
    #####: 1480:	  if (ch == EOF)
branch  0 never executed
branch  1 never executed
    #####: 1481:	    bad_prog(_(EXPECTED_SLASH));
call    0 never executed
        -: 1482:	      
    #####: 1483:	  if (ch == '\\')
branch  0 never executed
branch  1 never executed
    #####: 1484:	    ch = inchar();
call    0 never executed
        -: 1485:	  else
        -: 1486:	    {
    #####: 1487:	      savchar(ch);
call    0 never executed
    #####: 1488:	      ch = '\n';
        -: 1489:	    }
        -: 1490:
    #####: 1491:	  read_text(&cur_cmd->x.cmd_txt, ch);
call    0 never executed
    #####: 1492:	  break;
        -: 1493:
    #####: 1494:	case ':':
    #####: 1495:	  if (cur_cmd->a1)
branch  0 never executed
branch  1 never executed
    #####: 1496:	    bad_prog(_(NO_COLON_ADDR));
call    0 never executed
    #####: 1497:	  labels = setup_label(labels, vector->v_length, read_label(), NULL);
call    0 never executed
call    1 never executed
    #####: 1498:	  break;
        -: 1499:	
    #####: 1500:	case 'T':
        -: 1501:	case 'b':
        -: 1502:	case 't':
    #####: 1503:	  jumps = setup_label(jumps, vector->v_length, read_label(), NULL);
call    0 never executed
call    1 never executed
    #####: 1504:	  break;
        -: 1505:
    #####: 1506:	case 'Q':
        -: 1507:	case 'q':
    #####: 1508:	  if (cur_cmd->a2)
branch  0 never executed
branch  1 never executed
    #####: 1509:	    bad_prog(_(ONE_ADDR));
call    0 never executed
        -: 1510:	  /* Fall through */
        -: 1511:
        -: 1512:	case 'L':
        -: 1513:	case 'l':
        1: 1514:	  ch = in_nonblank();
call    0 returned 1
        1: 1515:	  if (ISDIGIT(ch)) 
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -: 1516:	    {
    #####: 1517:	      cur_cmd->x.int_arg = in_integer(ch);
call    0 never executed
    #####: 1518:	      ch = in_nonblank();
call    0 never executed
        -: 1519:	    }
        -: 1520:	  else
        1: 1521:	    cur_cmd->x.int_arg = -1;
        -: 1522:
        1: 1523:	  if (ch == CLOSE_BRACE || ch == '#')
branch  0 taken 1 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 1
    #####: 1524:	    savchar(ch);
call    0 never executed
       1*: 1525:	  else if (ch != EOF && ch != '\n' && ch != ';')
branch  0 taken 0 (fallthrough)
branch  1 taken 1
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1526:	    bad_prog(_(EXCESS_JUNK));
call    0 never executed
        -: 1527:
        1: 1528:	  break;
        -: 1529:
    #####: 1530:	case '=':
        -: 1531:	case 'd':
        -: 1532:	case 'D':
        -: 1533:	case 'g':
        -: 1534:	case 'G':
        -: 1535:	case 'h':
        -: 1536:	case 'H':
        -: 1537:	case 'n':
        -: 1538:	case 'N':
        -: 1539:	case 'p':
        -: 1540:	case 'P':
        -: 1541:	case 'x':
    #####: 1542:	  ch = in_nonblank();
call    0 never executed
    #####: 1543:	  if (ch == CLOSE_BRACE || ch == '#')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1544:	    savchar(ch);
call    0 never executed
    #####: 1545:	  else if (ch != EOF && ch != '\n' && ch != ';')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1546:	    bad_prog(_(EXCESS_JUNK));
call    0 never executed
    #####: 1547:	  break;
        -: 1548:
    #####: 1549:	case 'r':
    #####: 1550:	  b = read_filename();
call    0 never executed
    #####: 1551:	  cur_cmd->x.fname = ck_strdup(get_buffer(b));
call    0 never executed
call    1 never executed
    #####: 1552:	  free_buffer(b);
call    0 never executed
    #####: 1553:	  break;
        -: 1554:
    #####: 1555:        case 'R':
    #####: 1556:	  cur_cmd->x.fp = get_openfile(&file_read, "r", false)->fp;
call    0 never executed
    #####: 1557:	  break;
        -: 1558:
    #####: 1559:        case 'W':
        -: 1560:	case 'w':
    #####: 1561:	  cur_cmd->x.outf = get_openfile(&file_write, "w", true);
call    0 never executed
    #####: 1562:	  break;
        -: 1563:
        1: 1564:	case 's':
        -: 1565:	  {
        -: 1566:	    struct buffer *b2;
        -: 1567:	    int flags;
        -: 1568:	    int slash;
        -: 1569:
        1: 1570:	    slash = inchar();
call    0 returned 1
        1: 1571:	    if ( !(b  = match_slash(slash, true)) )
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
    #####: 1572:	      bad_prog(_(UNTERM_S_CMD));
call    0 never executed
        1: 1573:	    if ( !(b2 = match_slash(slash, false)) )
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
    #####: 1574:	      bad_prog(_(UNTERM_S_CMD));
call    0 never executed
        -: 1575:
       1*: 1576:	    cur_cmd->x.cmd_subst = OB_MALLOC(&obs, 1, struct subst);
branch  0 taken 0 (fallthrough)
branch  1 taken 1
call    2 never executed
branch  3 taken 0 (fallthrough)
branch  4 taken 1
branch  5 taken 0 (fallthrough)
branch  6 taken 1
        2: 1577:	    setup_replacement(cur_cmd->x.cmd_subst,
call    0 returned 1
call    1 returned 1
        1: 1578:			      get_buffer(b2), size_buffer(b2));
call    0 returned 1
        1: 1579:	    free_buffer(b2);
call    0 returned 1
        -: 1580:
        1: 1581:	    flags = mark_subst_opts(cur_cmd->x.cmd_subst);
call    0 returned 1
        2: 1582:	    cur_cmd->x.cmd_subst->regx =
        1: 1583:	      compile_regex(b, flags, cur_cmd->x.cmd_subst->max_id + 1);
call    0 returned 1
        1: 1584:	    free_buffer(b);
call    0 returned 1
        -: 1585:	  }
        1: 1586:	  break;
        -: 1587:
    #####: 1588:	case 'y':
        -: 1589:	  {
        -: 1590:	    size_t len, dest_len;
        -: 1591:	    int slash;
        -: 1592:	    struct buffer *b2;
        -: 1593:            char *src_buf, *dest_buf;
        -: 1594:  
    #####: 1595:	    slash = inchar();
call    0 never executed
    #####: 1596:	    if ( !(b = match_slash(slash, false)) )
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1597:	      bad_prog(_(UNTERM_Y_CMD));
call    0 never executed
    #####: 1598:            src_buf = get_buffer(b);
call    0 never executed
    #####: 1599:	    len = normalize_text(src_buf, size_buffer (b), TEXT_BUFFER);
call    0 never executed
call    1 never executed
        -: 1600:
    #####: 1601:            if ( !(b2 = match_slash(slash, false)) )
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1602: 	      bad_prog(_(UNTERM_Y_CMD));
call    0 never executed
    #####: 1603:            dest_buf = get_buffer(b2);
call    0 never executed
    #####: 1604:	    dest_len = normalize_text(dest_buf, size_buffer (b2), TEXT_BUFFER);
call    0 never executed
call    1 never executed
        -: 1605:
        -: 1606:#ifndef FAULTY_F_KRM_1
        -: 1607:            if (mb_cur_max > 1)
        -: 1608:#else
    #####: 1609:	    if (mb_cur_max > 0)
branch  0 never executed
branch  1 never executed
        -: 1610:#endif
        -: 1611:	      {
        -: 1612:                int i, j, idx, src_char_num;
    #####: 1613:                size_t *src_lens = MALLOC(len, size_t);
call    0 never executed
        -: 1614:                char **trans_pairs;
        -: 1615:                size_t mbclen;
        -: 1616:                mbstate_t cur_stat;
        -: 1617:
        -: 1618:                /* Enumerate how many character the source buffer has.  */
    #####: 1619:                memset(&cur_stat, 0, sizeof(mbstate_t));
    #####: 1620:                for (i = 0, j = 0; i < len;)
branch  0 never executed
branch  1 never executed
        -: 1621:                  {
    #####: 1622:                    mbclen = MBRLEN (src_buf + i, len - i, &cur_stat);
        -: 1623:                    /* An invalid sequence, or a truncated multibyte character.
        -: 1624:                       We treat it as a singlebyte character.  */
    #####: 1625:                    if (mbclen == (size_t) -1 || mbclen == (size_t) -2
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1626:                        || mbclen == 0)
branch  0 never executed
branch  1 never executed
    #####: 1627:                      mbclen = 1;
    #####: 1628:                    src_lens[j++] = mbclen;
    #####: 1629:                    i += mbclen;
        -: 1630:                  }
    #####: 1631:                src_char_num = j;
        -: 1632:
    #####: 1633:                memset(&cur_stat, 0, sizeof(mbstate_t));
    #####: 1634:                idx = 0;
        -: 1635:
        -: 1636:                /* trans_pairs = {src(0), dest(0), src(1), dest(1), ..., NULL}
        -: 1637:                     src(i) : pointer to i-th source character.
        -: 1638:                     dest(i) : pointer to i-th destination character.
        -: 1639:                     NULL : terminator */
    #####: 1640:                trans_pairs = MALLOC(2 * src_char_num + 1, char*);
call    0 never executed
    #####: 1641:                cur_cmd->x.translatemb = trans_pairs;
    #####: 1642:                for (i = 0; i < src_char_num; i++)
branch  0 never executed
branch  1 never executed
        -: 1643:                  {
    #####: 1644:                    if (idx >= dest_len)
branch  0 never executed
branch  1 never executed
    #####: 1645:                      bad_prog(_(Y_CMD_LEN));
call    0 never executed
        -: 1646:
        -: 1647:                    /* Set the i-th source character.  */
    #####: 1648:                    trans_pairs[2 * i] = MALLOC(src_lens[i] + 1, char);
call    0 never executed
    #####: 1649:                    strncpy(trans_pairs[2 * i], src_buf, src_lens[i]);
    #####: 1650:                    trans_pairs[2 * i][src_lens[i]] = '\0';
    #####: 1651:                    src_buf += src_lens[i]; /* Forward to next character.  */
        -: 1652:
        -: 1653:                    /* Fetch the i-th destination character.  */
    #####: 1654:                    mbclen = MBRLEN (dest_buf + idx, dest_len - idx, &cur_stat);
        -: 1655:                    /* An invalid sequence, or a truncated multibyte character.
        -: 1656:                       We treat it as a singlebyte character.  */
    #####: 1657:                    if (mbclen == (size_t) -1 || mbclen == (size_t) -2
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1658:                        || mbclen == 0)
branch  0 never executed
branch  1 never executed
    #####: 1659:                      mbclen = 1;
        -: 1660:
        -: 1661:                    /* Set the i-th destination character.  */
    #####: 1662:                    trans_pairs[2 * i + 1] = MALLOC(mbclen + 1, char);
call    0 never executed
        -: 1663:#ifndef FAULTY_F_KRM_7
    #####: 1664:                    strncpy(trans_pairs[2 * i + 1], dest_buf + idx, mbclen);
        -: 1665:#else
        -: 1666:		    strncpy(trans_pairs[2 * i + 1], dest_buf + idx, mbclen - 1);
        -: 1667:#endif
    #####: 1668:                    trans_pairs[2 * i + 1][mbclen] = '\0';
    #####: 1669:                    idx += mbclen; /* Forward to next character.  */
        -: 1670:                  }
    #####: 1671:                trans_pairs[2 * i] = NULL;
    #####: 1672:                if (idx != dest_len)
branch  0 never executed
branch  1 never executed
    #####: 1673:                  bad_prog(_(Y_CMD_LEN));
call    0 never executed
        -: 1674:              }
        -: 1675:            else
        -: 1676:              {
    #####: 1677:	        char *translate = OB_MALLOC(&obs, YMAP_LENGTH, char);
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####: 1678:                unsigned char *ustring = CAST(unsigned char *)src_buf;
        -: 1679:
    #####: 1680:		if (len != dest_len)
branch  0 never executed
branch  1 never executed
    #####: 1681:                  bad_prog(_(Y_CMD_LEN));
call    0 never executed
        -: 1682:
    #####: 1683:	        for (len = 0; len < YMAP_LENGTH; len++)
branch  0 never executed
branch  1 never executed
    #####: 1684:	          translate[len] = len;
        -: 1685:
    #####: 1686:		while (dest_len--)
branch  0 never executed
branch  1 never executed
        -: 1687:#ifndef FAULTY_F_KRM_8
        -: 1688:                
    #####: 1689:		  translate[(unsigned char)*ustring++] = *dest_buf++;
        -: 1690:#else
        -: 1691:		  translate[(char)*ustring++] = *dest_buf++;
        -: 1692:#endif
        -: 1693:                
        -: 1694:
    #####: 1695:	        cur_cmd->x.translate = translate;
        -: 1696:	      }
        -: 1697:
    #####: 1698:            if ((ch = in_nonblank()) != EOF && ch != '\n' && ch != ';')
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####: 1699:              bad_prog(_(EXCESS_JUNK));
call    0 never executed
        -: 1700:
    #####: 1701:            free_buffer(b);
call    0 never executed
    #####: 1702:            free_buffer(b2);
call    0 never executed
        -: 1703:	  }
    #####: 1704:	break;
        -: 1705:
    #####: 1706:	case EOF:
    #####: 1707:	  bad_prog(_(NO_COMMAND));
call    0 never executed
        -: 1708:	  /*NOTREACHED*/
        -: 1709:
    #####: 1710:	default:
    #####: 1711:	  bad_command (ch);
call    0 never executed
        -: 1712:	  /*NOTREACHED*/
        -: 1713:	}
        -: 1714:
        -: 1715:      /* this is buried down here so that "continue" statements will miss it */
        2: 1716:      ++vector->v_length;
        -: 1717:    }
        1: 1718:  return vector;
        -: 1719:}
        -: 1720:
        -: 1721:
        -: 1722:/* deal with \X escapes */
        -: 1723:size_t
function normalize_text called 2 returned 100% blocks executed 17%
        2: 1724:normalize_text(buf, len, buftype)
        -: 1725:  char *buf;
        -: 1726:  size_t len;
        -: 1727:  enum text_types buftype;
        -: 1728:{
        2: 1729:  const char *bufend = buf + len;
        2: 1730:  char *p = buf;
        2: 1731:  char *q = buf;
        -: 1732:
        -: 1733:  /* This variable prevents normalizing text within bracket
        -: 1734:     subexpressions when conforming to POSIX.  If 0, we
        -: 1735:     are not within a bracket expression.  If -1, we are within a
        -: 1736:     bracket expression but are not within [.FOO.], [=FOO=],
        -: 1737:     or [:FOO:].  Otherwise, this is the '.', '=', or ':'
        -: 1738:     respectively within these three types of subexpressions.  */
        2: 1739:  int bracket_state = 0;
        -: 1740:
        -: 1741:  int mbclen;
        -: 1742:  mbstate_t cur_stat;
        2: 1743:  memset(&cur_stat, 0, sizeof(mbstate_t));
        -: 1744:
       27: 1745:  while (p < bufend)
branch  0 taken 25
branch  1 taken 2 (fallthrough)
        -: 1746:    {
        -: 1747:      int c;
       25: 1748:      mbclen = MBRLEN (p, bufend - p, &cur_stat);
      25*: 1749:      if (mbclen != 1)
branch  0 taken 0 (fallthrough)
branch  1 taken 25
        -: 1750:	{
        -: 1751:          /* An invalid sequence, or a truncated multibyte character.
        -: 1752:             We treat it as a singlebyte character.  */
    #####: 1753:          if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1754:            mbclen = 1;
        -: 1755:
    #####: 1756:          memmove (q, p, mbclen);
    #####: 1757:          q += mbclen;
    #####: 1758:          p += mbclen;
    #####: 1759:	  continue;
        -: 1760:	}
        -: 1761:
      25*: 1762:      if (*p == '\\' && p+1 < bufend && bracket_state == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 25
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1763:	switch ( (c = *++p) )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
        -: 1764:	  {
        -: 1765:#if defined __STDC__ && __STDC__-0
    #####: 1766:	  case 'a': *q++ = '\a'; p++; continue;
        -: 1767:#else /* Not STDC; we'll just assume ASCII */
        -: 1768:	  case 'a': *q++ = '\007'; p++; continue;
        -: 1769:#endif
        -: 1770:	  /* case 'b': *q++ = '\b'; p++; continue; --- conflicts with \b RE */
    #####: 1771:	  case 'f': *q++ = '\f'; p++; continue;
    #####: 1772:	  case '\n': /*fall through */
    #####: 1773:	  case 'n': *q++ = '\n'; p++; continue;
    #####: 1774:	  case 'r': *q++ = '\r'; p++; continue;
    #####: 1775:	  case 't': *q++ = '\t'; p++; continue;
    #####: 1776:	  case 'v': *q++ = '\v'; p++; continue;
        -: 1777:
    #####: 1778:	  case 'd': /* decimal byte */
    #####: 1779:	    p = convert_number(q, p+1, bufend, 10, 3, 'd');
call    0 never executed
    #####: 1780:	    q++;
    #####: 1781:	    continue;
        -: 1782:
    #####: 1783:	  case 'x': /* hexadecimal byte */
    #####: 1784:	    p = convert_number(q, p+1, bufend, 16, 2, 'x');
call    0 never executed
    #####: 1785:	    q++;
    #####: 1786:	    continue;
        -: 1787:
        -: 1788:#ifdef REG_PERL
        -: 1789:	  case '0': case '1': case '2': case '3':
        -: 1790:	  case '4': case '5': case '6': case '7':
        -: 1791:	    if ((extended_regexp_flags & REG_PERL)
        -: 1792:		&& p+1 < bufend
        -: 1793:		&& p[1] >= '0' && p[1] <= '9')
        -: 1794:	      {
        -: 1795:		p = convert_number(q, p, bufend, 8, 3, *p);
        -: 1796:		q++;
        -: 1797:	      }
        -: 1798:	    else
        -: 1799:	      {
        -: 1800:		/* we just pass the \ up one level for interpretation */
        -: 1801:	        if (buftype != TEXT_BUFFER)
        -: 1802:		  *q++ = '\\';
        -: 1803:	      }
        -: 1804:
        -: 1805:	    continue;
        -: 1806:
        -: 1807:	  case 'o': /* octal byte */
        -: 1808:	    if (!(extended_regexp_flags & REG_PERL))
        -: 1809:	      {
        -: 1810:	        p = convert_number(q, p+1, bufend,  8, 3, 'o');
        -: 1811:		q++;
        -: 1812:	      }
        -: 1813:	    else
        -: 1814:	      {
        -: 1815:	        /* we just pass the \ up one level for interpretation */
        -: 1816:	        if (buftype != TEXT_BUFFER)
        -: 1817:		  *q++ = '\\';
        -: 1818:	      }
        -: 1819:	    
        -: 1820:	    continue;
        -: 1821:#else
    #####: 1822:	  case 'o': /* octal byte */
    #####: 1823:	    p = convert_number(q, p+1, bufend,  8, 3, 'o');
call    0 never executed
    #####: 1824:	    q++;
    #####: 1825:	    continue;
        -: 1826:#endif
        -: 1827:
    #####: 1828:	  case 'c':
    #####: 1829:	    if (++p < bufend)
branch  0 never executed
branch  1 never executed
        -: 1830:	      {
    #####: 1831:		*q++ = toupper(*p) ^ 0x40;
    #####: 1832:		p++;
    #####: 1833:		continue;
        -: 1834:	      }
        -: 1835:	    else
        -: 1836:	      {
        -: 1837:	        /* we just pass the \ up one level for interpretation */
    #####: 1838:	        if (buftype != TEXT_BUFFER)
branch  0 never executed
branch  1 never executed
    #####: 1839:		  *q++ = '\\';
    #####: 1840:	        continue;
        -: 1841:	      }
        -: 1842:
    #####: 1843:	  default:
        -: 1844:	    /* we just pass the \ up one level for interpretation */
    #####: 1845:	    if (buftype != TEXT_BUFFER)
branch  0 never executed
branch  1 never executed
    #####: 1846:	      *q++ = '\\';
    #####: 1847:	    break;
        -: 1848:	  }
       25: 1849:      else if (buftype == TEXT_REGEX && posixicity != POSIXLY_EXTENDED)
branch  0 taken 17 (fallthrough)
branch  1 taken 8
branch  2 taken 0 (fallthrough)
branch  3 taken 17
    #####: 1850:        switch (*p)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1851:          {
    #####: 1852:          case '[':
    #####: 1853:            if (!bracket_state)
branch  0 never executed
branch  1 never executed
    #####: 1854:              bracket_state = -1;
    #####: 1855:            break;
        -: 1856: 
    #####: 1857:	  case ':':
        -: 1858:	  case '.':
        -: 1859:	  case '=':
    #####: 1860:            if (bracket_state == -1 && p[-1] == '[')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1861:              bracket_state = *p;
    #####: 1862:            break;
        -: 1863:
    #####: 1864:          case ']':
    #####: 1865:            if (bracket_state == 0)
branch  0 never executed
branch  1 never executed
        -: 1866:	      ;
    #####: 1867:            else if (bracket_state == -1)
branch  0 never executed
branch  1 never executed
    #####: 1868:              bracket_state = 0;
    #####: 1869:            else if (p[-2] != bracket_state && p[-1] == bracket_state)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1870:              bracket_state = -1;
    #####: 1871:            break;
        -: 1872:          }
        -: 1873:
       25: 1874:      *q++ = *p++;
        -: 1875:    }
        2: 1876:    return (size_t)(q - buf);
        -: 1877:}
        -: 1878:
        -: 1879:
        -: 1880:/* `str' is a string (from the command line) that contains a sed command.
        -: 1881:   Compile the command, and add it to the end of `cur_program'. */
        -: 1882:struct vector *
function compile_string called 1 returned 100% blocks executed 100%
        1: 1883:compile_string(cur_program, str, len)
        -: 1884:  struct vector *cur_program;
        -: 1885:  char *str;
        -: 1886:  size_t len;
        -: 1887:{
        -: 1888:  static countT string_expr_count = 0;
        -: 1889:  struct vector *ret;
        -: 1890:
        1: 1891:  prog.file = NULL;
        1: 1892:  prog.base = CAST(unsigned char *)str;
        1: 1893:  prog.cur = prog.base;
        1: 1894:  prog.end = prog.cur + len;
        -: 1895:
        1: 1896:  cur_input.line = 0;
        1: 1897:  cur_input.name = NULL;
        1: 1898:  cur_input.string_expr_count = ++string_expr_count;
        -: 1899:
        1: 1900:  ret = compile_program(cur_program);
call    0 returned 1
        1: 1901:  prog.base = NULL;
        1: 1902:  prog.cur = NULL;
        1: 1903:  prog.end = NULL;
        -: 1904:
        1: 1905:  first_script = false;
        1: 1906:  return ret;
        -: 1907:}
        -: 1908:
        -: 1909:/* `cmdfile' is the name of a file containing sed commands.
        -: 1910:   Read them in and add them to the end of `cur_program'.
        -: 1911: */
        -: 1912:struct vector *
function compile_file called 0 returned 0% blocks executed 0%
    #####: 1913:compile_file(cur_program, cmdfile)
        -: 1914:  struct vector *cur_program;
        -: 1915:  const char *cmdfile;
        -: 1916:{
        -: 1917:  size_t len;
        -: 1918:  struct vector *ret;
        -: 1919:
    #####: 1920:  prog.file = stdin;
    #####: 1921:  if (cmdfile[0] != '-' || cmdfile[1] != '\0')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1922:    prog.file = ck_fopen(cmdfile, "rt", true);
call    0 never executed
        -: 1923:
    #####: 1924:  cur_input.line = 1;
    #####: 1925:  cur_input.name = cmdfile;
    #####: 1926:  cur_input.string_expr_count = 0;
        -: 1927:
    #####: 1928:  ret = compile_program(cur_program);
call    0 never executed
    #####: 1929:  if (prog.file != stdin)
branch  0 never executed
branch  1 never executed
    #####: 1930:    ck_fclose(prog.file);
call    0 never executed
    #####: 1931:  prog.file = NULL;
        -: 1932:
    #####: 1933:  first_script = false;
    #####: 1934:  return ret;
        -: 1935:}
        -: 1936:
        -: 1937:/* Make any checks which require the whole program to have been read.
        -: 1938:   In particular: this backpatches the jump targets.
        -: 1939:   Any cleanup which can be done after these checks is done here also.  */
        -: 1940:void
function check_final_program called 1 returned 100% blocks executed 30%
        1: 1941:check_final_program(program)
        -: 1942:  struct vector *program;
        -: 1943:{
        -: 1944:  struct sed_label *go;
        -: 1945:  struct sed_label *lbl;
        -: 1946:
        -: 1947:  /* do all "{"s have a corresponding "}"? */
        1: 1948:  if (blocks)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -: 1949:    {
        -: 1950:      /* update info for error reporting: */
    #####: 1951:      MEMCPY(&cur_input, &blocks->err_info, sizeof (cur_input));
    #####: 1952:      bad_prog(_(EXCESS_OPEN_BRACE));
call    0 never executed
        -: 1953:    }
        -: 1954:
        -: 1955:  /* was the final command an unterminated a/c/i command? */
        1: 1956:  if (pending_text)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -: 1957:    {
    #####: 1958:      old_text_buf->text_length = size_buffer(pending_text);
call    0 never executed
    #####: 1959:      old_text_buf->text = MEMDUP(get_buffer(pending_text),
call    0 never executed
call    1 never executed
        -: 1960:				  old_text_buf->text_length, char);
    #####: 1961:      free_buffer(pending_text);
call    0 never executed
    #####: 1962:      pending_text = NULL;
        -: 1963:    }
        -: 1964:
       1*: 1965:  for (go = jumps; go; go = release_label(go))
call    0 never executed
branch  1 taken 0
branch  2 taken 1 (fallthrough)
        -: 1966:    {
    #####: 1967:      for (lbl = labels; lbl; lbl = lbl->next)
branch  0 never executed
branch  1 never executed
    #####: 1968:	if (strcmp(lbl->name, go->name) == 0)
branch  0 never executed
branch  1 never executed
    #####: 1969:	  break;
    #####: 1970:      if (lbl)
branch  0 never executed
branch  1 never executed
        -: 1971:	{
    #####: 1972:	  program->v[go->v_index].x.jump_index = lbl->v_index;
        -: 1973:	}
        -: 1974:      else
        -: 1975:	{
    #####: 1976:	  if (*go->name)
branch  0 never executed
branch  1 never executed
    #####: 1977:	    panic(_("can't find label for jump to `%s'"), go->name);
call    0 never executed
    #####: 1978:	  program->v[go->v_index].x.jump_index = program->v_length;
        -: 1979:	}
        -: 1980:    }
        1: 1981:  jumps = NULL;
        -: 1982:
       1*: 1983:  for (lbl = labels; lbl; lbl = release_label(lbl))
call    0 never executed
branch  1 taken 0
branch  2 taken 1 (fallthrough)
        -: 1984:    ;
        1: 1985:  labels = NULL;
        -: 1986:
        -: 1987:  /* There is no longer a need to track file names: */
        -: 1988:  {
        -: 1989:    struct output *p;
        -: 1990:
       1*: 1991:    for (p=file_read; p; p=p->link)
branch  0 taken 0
branch  1 taken 1 (fallthrough)
    #####: 1992:      if (p->name)
branch  0 never executed
branch  1 never executed
        -: 1993:	{
    #####: 1994:	  FREE(p->name);
call    0 never executed
    #####: 1995:	  p->name = NULL;
        -: 1996:	}
        -: 1997:
       1*: 1998:    for (p=file_write; p; p=p->link)
branch  0 taken 0
branch  1 taken 1 (fallthrough)
    #####: 1999:      if (p->name)
branch  0 never executed
branch  1 never executed
        -: 2000:	{
    #####: 2001:	  FREE(p->name);
call    0 never executed
    #####: 2002:	  p->name = NULL;
        -: 2003:	}
        -: 2004:  }
        1: 2005:}
        -: 2006:
        -: 2007:/* Rewind all resources which were allocated in this module. */
        -: 2008:void
function rewind_read_files called 1 returned 100% blocks executed 50%
        1: 2009:rewind_read_files()
        -: 2010:{
        -: 2011:  struct output *p;
        -: 2012:
       1*: 2013:  for (p=file_read; p; p=p->link)
branch  0 taken 0
branch  1 taken 1 (fallthrough)
    #####: 2014:    if (p->fp)
branch  0 never executed
branch  1 never executed
    #####: 2015:      rewind(p->fp);
call    0 never executed
        1: 2016:}
        -: 2017:
        -: 2018:/* Release all resources which were allocated in this module. */
        -: 2019:void
function finish_program called 1 returned 100% blocks executed 45%
        1: 2020:finish_program(program)
        -: 2021:  struct vector *program;
        -: 2022:{
        -: 2023:  /* close all files... */
        -: 2024:  {
        -: 2025:    struct output *p, *q;
        -: 2026:
       1*: 2027:    for (p=file_read; p; p=q)
branch  0 taken 0
branch  1 taken 1 (fallthrough)
        -: 2028:      {
    #####: 2029:	if (p->fp)
branch  0 never executed
branch  1 never executed
    #####: 2030:	  ck_fclose(p->fp);
call    0 never executed
    #####: 2031:	q = p->link;
        -: 2032:#if 0
        -: 2033:	/* We use obstacks. */
        -: 2034:	FREE(p);
        -: 2035:#endif
        -: 2036:      }
        -: 2037:
       1*: 2038:    for (p=file_write; p; p=q)
branch  0 taken 0
branch  1 taken 1 (fallthrough)
        -: 2039:      {
    #####: 2040:	if (p->fp)
branch  0 never executed
branch  1 never executed
    #####: 2041:	  ck_fclose(p->fp);
call    0 never executed
    #####: 2042:	q = p->link;
        -: 2043:#if 0
        -: 2044:	/* We use obstacks. */
        -: 2045:	FREE(p);
        -: 2046:#endif
        -: 2047:      }
        1: 2048:    file_read = file_write = NULL;
        -: 2049:  }
        -: 2050:
        -: 2051:#ifdef DEBUG_LEAKS
        -: 2052:  obstack_free (&obs, NULL);
        -: 2053:#endif /*DEBUG_LEAKS*/
        1: 2054:}
        -: 2055:/*  GNU SED, a batch stream editor.
        -: 2056:    Copyright (C) 1989,90,91,92,93,94,95,98,99,2002,2003,2004,2005,2006
        -: 2057:    Free Software Foundation, Inc.
        -: 2058:
        -: 2059:    This program is free software; you can redistribute it and/or modify
        -: 2060:    it under the terms of the GNU General Public License as published by
        -: 2061:    the Free Software Foundation; either version 2, or (at your option)
        -: 2062:    any later version.
        -: 2063:
        -: 2064:    This program is distributed in the hope that it will be useful,
        -: 2065:    but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 2066:    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 2067:    GNU General Public License for more details.
        -: 2068:
        -: 2069:    You should have received a copy of the GNU General Public License
        -: 2070:    along with this program; if not, write to the Free Software
        -: 2071:    Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA. */
        -: 2072:
        -: 2073:#undef EXPERIMENTAL_DASH_N_OPTIMIZATION	/*don't use -- is very buggy*/
        -: 2074:#define INITIAL_BUFFER_SIZE	50
        -: 2075:#define FREAD_BUFFER_SIZE	8192
        -: 2076:
        -: 2077:
        -: 2078:#include <stdio.h>
        -: 2079:#include <ctype.h>
        -: 2080:
        -: 2081:#include <errno.h>
        -: 2082:#ifndef errno
        -: 2083:extern int errno;
        -: 2084:#endif
        -: 2085:
        -: 2086:#ifdef HAVE_UNISTD_H
        -: 2087:# include <unistd.h>
        -: 2088:#endif
        -: 2089:
        -: 2090:#ifdef __GNUC__
        -: 2091:# if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__-0 >= 7)
        -: 2092:   /* silence warning about unused parameter even for "gcc -W -Wunused" */
        -: 2093:#  define UNUSED	__attribute__((unused))
        -: 2094:# endif
        -: 2095:#endif
        -: 2096:#ifndef UNUSED
        -: 2097:# define UNUSED
        -: 2098:#endif
        -: 2099:
        -: 2100:#ifdef HAVE_STRINGS_H
        -: 2101:# include <strings.h>
        -: 2102:#else
        -: 2103:# include <string.h>
        -: 2104:#endif /*HAVE_STRINGS_H*/
        -: 2105:#ifdef HAVE_MEMORY_H
        -: 2106:# include <memory.h>
        -: 2107:#endif
        -: 2108:
        -: 2109:#ifndef HAVE_STRCHR
        -: 2110:# define strchr index
        -: 2111:# define strrchr rindex
        -: 2112:#endif
        -: 2113:
        -: 2114:#ifdef HAVE_STDLIB_H
        -: 2115:# include <stdlib.h>
        -: 2116:#endif
        -: 2117:#ifndef EXIT_SUCCESS
        -: 2118:# define EXIT_SUCCESS 0
        -: 2119:#endif
        -: 2120:
        -: 2121:#ifdef HAVE_SYS_TYPES_H
        -: 2122:# include <sys/types.h>
        -: 2123:#endif
        -: 2124:
        -: 2125:#include <sys/stat.h>
        -: 2126:
        -: 2127:
        -: 2128:/* Sed operates a line at a time. */
        -: 2129:struct line {
        -: 2130:  char *text;		/* Pointer to line allocated by malloc. */
        -: 2131:  char *active;		/* Pointer to non-consumed part of text. */
        -: 2132:  size_t length;	/* Length of text (or active, if used). */
        -: 2133:  size_t alloc;		/* Allocated space for active. */
        -: 2134:  bool chomped;		/* Was a trailing newline dropped? */
        -: 2135:#ifdef HAVE_MBRTOWC
        -: 2136:  mbstate_t mbstate;
        -: 2137:#endif
        -: 2138:};
        -: 2139:
        -: 2140:/* A queue of text to write out at the end of a cycle
        -: 2141:   (filled by the "a", "r" and "R" commands.) */
        -: 2142:struct append_queue {
        -: 2143:  const char *fname;
        -: 2144:  char *text;
        -: 2145:  size_t textlen;
        -: 2146:  struct append_queue *next;
        -: 2147:  bool free;
        -: 2148:};
        -: 2149:
        -: 2150:/* State information for the input stream. */
        -: 2151:struct input {
        -: 2152:  /* The list of yet-to-be-opened files.  It is invalid for file_list
        -: 2153:     to be NULL.  When *file_list is NULL we are currently processing
        -: 2154:     the last file.  */
        -: 2155:
        -: 2156:  char **file_list;
        -: 2157:
        -: 2158:  /* Count of files we failed to open. */
        -: 2159:  countT bad_count;	    
        -: 2160:
        -: 2161:  /* Current input line number (over all files).  */
        -: 2162:  countT line_number;	    
        -: 2163:
        -: 2164:  /* True if we'll reset line numbers and addresses before
        -: 2165:     starting to process the next (possibly the first) file.  */
        -: 2166:  bool reset_at_next_file;
        -: 2167:
        -: 2168:  /* Function to read one line.  If FP is NULL, read_fn better not
        -: 2169:     be one which uses fp; in particular, read_always_fail() is
        -: 2170:     recommended. */
        -: 2171:  bool (*read_fn) P_((struct input *));	/* read one line */
        -: 2172:
        -: 2173:  char *out_file_name;
        -: 2174:
        -: 2175:  const char *in_file_name;
        -: 2176:
        -: 2177:  /* if NULL, none of the following are valid */
        -: 2178:  FILE *fp;
        -: 2179:
        -: 2180:  bool no_buffering;
        -: 2181:};
        -: 2182:
        -: 2183:
        -: 2184:/* Have we done any replacements lately?  This is used by the `t' command. */
        -: 2185:static bool replaced = false;
        -: 2186:
        -: 2187:/* The current output file (stdout if -i is not being used. */
        -: 2188:static struct output output_file;
        -: 2189:
        -: 2190:/* The `current' input line. */
        -: 2191:static struct line line;
        -: 2192:
        -: 2193:/* An input line used to accumulate the result of the s and e commands. */
        -: 2194:static struct line s_accum;
        -: 2195:
        -: 2196:/* An input line that's been stored by later use by the program */
        -: 2197:static struct line hold;
        -: 2198:
        -: 2199:/* The buffered input look-ahead.  The only field that should be
        -: 2200:   used outside of read_mem_line() or line_init() is buffer.length. */
        -: 2201:static struct line buffer;
        -: 2202:
        -: 2203:static struct append_queue *append_head = NULL;
        -: 2204:static struct append_queue *append_tail = NULL;
        -: 2205:
        -: 2206:
        -: 2207:#ifdef BOOTSTRAP
        -: 2208:/* We can't be sure that the system we're boostrapping on has
        -: 2209:   memchr(), and ../lib/memchr.c requires configuration knowledge
        -: 2210:   about how many bits are in a `long'.  This implementation
        -: 2211:   is far from ideal, but it should get us up-and-limping well
        -: 2212:   enough to run the configure script, which is all that matters.
        -: 2213:*/
        -: 2214:# ifdef memchr
        -: 2215:#  undef memchr
        -: 2216:# endif
        -: 2217:# define memchr bootstrap_memchr
        -: 2218:
        -: 2219:static VOID *bootstrap_memchr P_((const VOID *s, int c, size_t n));
        -: 2220:static VOID *
        -: 2221:bootstrap_memchr(s, c, n)
        -: 2222:  const VOID *s;
        -: 2223:  int c;
        -: 2224:  size_t n;
        -: 2225:{
        -: 2226:  char *p;
        -: 2227:
        -: 2228:  for (p=(char *)s; n-- > 0; ++p)
        -: 2229:    if (*p == c)
        -: 2230:      return p;
        -: 2231:  return CAST(VOID *)0;
        -: 2232:}
        -: 2233:#endif /*BOOTSTRAP*/
        -: 2234:
        -: 2235:/* increase a struct line's length, making some attempt at
        -: 2236:   keeping realloc() calls under control by padding for future growth.  */
        -: 2237:static void resize_line P_((struct line *, size_t));
        -: 2238:static void
function resize_line called 1 returned 100% blocks executed 60%
        1: 2239:resize_line(lb, len)
        -: 2240:  struct line *lb;
        -: 2241:  size_t len;
        -: 2242:{
        -: 2243:  int inactive;
        1: 2244:  inactive = lb->active - lb->text;
        -: 2245:
        -: 2246:  /* If the inactive part has got to more than two thirds of the buffer,
        -: 2247:   * remove it. */
        1: 2248:  if (inactive > lb->alloc * 2)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -: 2249:    {
    #####: 2250:      MEMMOVE(lb->text, lb->active, lb->length);
    #####: 2251:      lb->alloc += lb->active - lb->text;
    #####: 2252:      lb->active = lb->text;
    #####: 2253:      inactive = 0;
        -: 2254:
    #####: 2255:      if (lb->alloc > len)
branch  0 never executed
branch  1 never executed
    #####: 2256:	return;
        -: 2257:    }
        -: 2258:
        1: 2259:  lb->alloc *= 2;
        1: 2260:  if (lb->alloc < len)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 2261:    lb->alloc = len;
        1: 2262:  if (lb->alloc < INITIAL_BUFFER_SIZE)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 2263:    lb->alloc = INITIAL_BUFFER_SIZE;
        -: 2264:    
        1: 2265:  lb->text = REALLOC(lb->text, inactive + lb->alloc, char);
call    0 returned 1
        1: 2266:  lb->active = lb->text + inactive;
        -: 2267:}
        -: 2268:
        -: 2269:/* Append `length' bytes from `string' to the line `to'. */
        -: 2270:static void str_append P_((struct line *, const char *, size_t));
        -: 2271:static void
function str_append called 142 returned 100% blocks executed 100%
      142: 2272:str_append(to, string, length)
        -: 2273:  struct line *to;
        -: 2274:  const char *string;
        -: 2275:  size_t length;
        -: 2276:{
      142: 2277:  size_t new_length = to->length + length;
        -: 2278:
      142: 2279:  if (to->alloc < new_length)
branch  0 taken 1 (fallthrough)
branch  1 taken 141
        1: 2280:    resize_line(to, new_length);
call    0 returned 1
      142: 2281:  MEMCPY(to->active + to->length, string, length);
      142: 2282:  to->length = new_length;
        -: 2283:
        -: 2284:#ifdef HAVE_MBRTOWC
        -: 2285:  if (mb_cur_max == 1)
        -: 2286:    return;
        -: 2287:
        -: 2288:  while (length)
        -: 2289:    {
        -: 2290:      int n = MBRLEN (string, length, &to->mbstate);
        -: 2291:
        -: 2292:      /* An invalid sequence is treated like a singlebyte character. */
        -: 2293:      if (n == -1)
        -: 2294:	{
        -: 2295:	  memset (&to->mbstate, 0, sizeof (to->mbstate));
        -: 2296:	  n = 1;
        -: 2297:	}
        -: 2298:
        -: 2299:      if (n > 0)
        -: 2300:	length -= n;
        -: 2301:      else
        -: 2302:	break;
        -: 2303:    }
        -: 2304:#endif
      142: 2305:}
        -: 2306:
        -: 2307:static void str_append_modified P_((struct line *, const char *, size_t,
        -: 2308:				    enum replacement_types));
        -: 2309:static void
function str_append_modified called 12 returned 100% blocks executed 41%
       12: 2310:str_append_modified(to, string, length, type)
        -: 2311:  struct line *to;
        -: 2312:  const char *string;
        -: 2313:  size_t length;
        -: 2314:  enum replacement_types type;
        -: 2315:{
       12: 2316:  size_t old_length = to->length;
        -: 2317:  char *start, *end;
        -: 2318:
       12: 2319:  if (length == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 12
    #####: 2320:    return;
        -: 2321:
        -: 2322:#ifdef HAVE_MBRTOWC
        -: 2323:  {
        -: 2324:    mbstate_t from_stat;
        -: 2325:
        -: 2326:    if (type == REPL_ASIS)
        -: 2327:      {
        -: 2328:	str_append(to, string, length);
        -: 2329:        return;
        -: 2330:      }
        -: 2331:
        -: 2332:    if (to->alloc - to->length < length * mb_cur_max)
        -: 2333:      resize_line(to, to->length + length * mb_cur_max);
        -: 2334:
        -: 2335:    MEMCPY (&from_stat, &to->mbstate, sizeof(mbstate_t));
        -: 2336:    while (length)
        -: 2337:      {
        -: 2338:	wchar_t wc;
        -: 2339:        int n = MBRTOWC (&wc, string, length, &from_stat);
        -: 2340:
        -: 2341:        /* An invalid sequence is treated like a singlebyte character. */
        -: 2342:        if (n == -1)
        -: 2343:          {
        -: 2344:            memset (&to->mbstate, 0, sizeof (from_stat));
        -: 2345:            n = 1;
        -: 2346:          }
        -: 2347:
        -: 2348:        if (n > 0)
        -: 2349:          string += n, length -= n;
        -: 2350:        else
        -: 2351:	  {
        -: 2352:	    /* Incomplete sequence, copy it manually.  */
        -: 2353:	    str_append(to, string, length);
        -: 2354:	    return;
        -: 2355:	  }
        -: 2356:
        -: 2357:	/* Convert the first character specially... */
        -: 2358:        if (type & (REPL_UPPERCASE_FIRST | REPL_LOWERCASE_FIRST))
        -: 2359:	  {
        -: 2360:            if (type & REPL_UPPERCASE_FIRST)
        -: 2361:              wc = towupper(wc);
        -: 2362:            else
        -: 2363:              wc = towlower(wc);
        -: 2364:
        -: 2365:            type &= ~(REPL_LOWERCASE_FIRST | REPL_UPPERCASE_FIRST);
        -: 2366:	    if (type == REPL_ASIS)
        -: 2367:	      {
        -: 2368:		n = WCRTOMB (to->active + to->length, wc, &to->mbstate);
        -: 2369:		to->length += n;
        -: 2370:		str_append(to, string, length);
        -: 2371:	        return;
        -: 2372:	      }
        -: 2373:          }
        -: 2374:
        -: 2375:        else if (type & REPL_UPPERCASE)
        -: 2376:          wc = towupper(wc);
        -: 2377:        else
        -: 2378:          wc = towlower(wc);
        -: 2379:
        -: 2380:	/* Copy the new wide character to the end of the string. */
        -: 2381:	n = WCRTOMB (to->active + to->length, wc, &to->mbstate);
        -: 2382:        to->length += n;
        -: 2383:	if (n == -1)
        -: 2384:	  {
        -: 2385:	    fprintf (stderr, "Case conversion produced an invalid character!");
        -: 2386:	    abort ();
        -: 2387:	  }
        -: 2388:      }
        -: 2389:  }
        -: 2390:#else
       12: 2391:  str_append(to, string, length);
call    0 returned 12
       12: 2392:  start = to->active + old_length;
       12: 2393:  end = start + length;
        -: 2394:
        -: 2395:  /* Now do the required modifications.  First \[lu]... */
       12: 2396:  if (type & REPL_UPPERCASE_FIRST)
branch  0 taken 0 (fallthrough)
branch  1 taken 12
        -: 2397:    {
    #####: 2398:      *start = toupper(*start);
    #####: 2399:      start++;
    #####: 2400:      type &= ~REPL_UPPERCASE_FIRST;
        -: 2401:    }
       12: 2402:  else if (type & REPL_LOWERCASE_FIRST)
branch  0 taken 0 (fallthrough)
branch  1 taken 12
        -: 2403:    {
    #####: 2404:      *start = tolower(*start);
    #####: 2405:      start++;
    #####: 2406:      type &= ~REPL_LOWERCASE_FIRST;
        -: 2407:    }
        -: 2408:
       12: 2409:  if (type == REPL_ASIS)
branch  0 taken 12 (fallthrough)
branch  1 taken 0
       12: 2410:    return;
        -: 2411:
        -: 2412:  /* ...and then \[LU] */
    #####: 2413:  if (type == REPL_UPPERCASE)
branch  0 never executed
branch  1 never executed
    #####: 2414:    for (; start != end; start++)
branch  0 never executed
branch  1 never executed
    #####: 2415:      *start = toupper(*start);
        -: 2416:  else
    #####: 2417:    for (; start != end; start++)
branch  0 never executed
branch  1 never executed
    #####: 2418:      *start = tolower(*start);
        -: 2419:#endif
        -: 2420:}
        -: 2421:
        -: 2422:/* initialize a "struct line" buffer */
        -: 2423:static void line_init P_((struct line *, size_t initial_size));
        -: 2424:static void
function line_init called 4 returned 100% blocks executed 100%
        4: 2425:line_init(buf, initial_size)
        -: 2426:  struct line *buf;
        -: 2427:  size_t initial_size;
        -: 2428:{
        4: 2429:  buf->text = MALLOC(initial_size, char);
call    0 returned 4
        4: 2430:  buf->active = buf->text;
        4: 2431:  buf->alloc = initial_size;
        4: 2432:  buf->length = 0;
        4: 2433:  buf->chomped = true;
        -: 2434:
        -: 2435:#ifdef HAVE_MBRTOWC
        -: 2436:  memset (&buf->mbstate, 0, sizeof (buf->mbstate));
        -: 2437:#endif
        -: 2438:
        4: 2439:}
        -: 2440:
        -: 2441:/* Copy the contents of the line `from' into the line `to'.
        -: 2442:   This destroys the old contents of `to'. */
        -: 2443:static void line_copy P_((struct line *from, struct line *to));
        -: 2444:static void
function line_copy called 0 returned 0% blocks executed 0%
    #####: 2445:line_copy(from, to)
        -: 2446:  struct line *from;
        -: 2447:  struct line *to;
        -: 2448:{
        -: 2449:  /* Remove the inactive portion in the destination buffer. */
    #####: 2450:  to->alloc += to->active - to->text;
        -: 2451:
    #####: 2452:  if (to->alloc < from->length)
branch  0 never executed
branch  1 never executed
        -: 2453:    {
    #####: 2454:      to->alloc *= 2;
    #####: 2455:      if (to->alloc < from->length)
branch  0 never executed
branch  1 never executed
    #####: 2456:	to->alloc = from->length;
    #####: 2457:      if (to->alloc < INITIAL_BUFFER_SIZE)
branch  0 never executed
branch  1 never executed
    #####: 2458:	to->alloc = INITIAL_BUFFER_SIZE;
        -: 2459:      /* Use FREE()+MALLOC() instead of REALLOC() to
        -: 2460:	 avoid unnecessary copying of old text. */
    #####: 2461:      FREE(to->text);
call    0 never executed
    #####: 2462:      to->text = MALLOC(to->alloc, char);
call    0 never executed
        -: 2463:    }
        -: 2464:
    #####: 2465:  to->active = to->text;
    #####: 2466:  to->length = from->length;
    #####: 2467:  to->chomped = from->chomped;
    #####: 2468:  MEMCPY(to->active, from->active, from->length);
        -: 2469:
        -: 2470:#ifdef HAVE_MBRTOWC
        -: 2471:  MEMCPY(&to->mbstate, &from->mbstate, sizeof (from->mbstate));
        -: 2472:#endif
    #####: 2473:}
        -: 2474:
        -: 2475:/* Append the contents of the line `from' to the line `to'. */
        -: 2476:static void line_append P_((struct line *from, struct line *to));
        -: 2477:static void
function line_append called 0 returned 0% blocks executed 0%
    #####: 2478:line_append(from, to)
        -: 2479:  struct line *from;
        -: 2480:  struct line *to;
        -: 2481:{
    #####: 2482:  str_append(to, "\n", 1);
call    0 never executed
    #####: 2483:  str_append(to, from->active, from->length);
call    0 never executed
    #####: 2484:  to->chomped = from->chomped;
        -: 2485:
        -: 2486:#ifdef HAVE_MBRTOWC
        -: 2487:  MEMCPY (&to->mbstate, &from->mbstate, sizeof (from->mbstate));
        -: 2488:#endif
    #####: 2489:}
        -: 2490:
        -: 2491:/* Exchange the contents of two "struct line" buffers. */
        -: 2492:static void line_exchange P_((struct line *, struct line *));
        -: 2493:static void
function line_exchange called 6 returned 100% blocks executed 100%
        6: 2494:line_exchange(a, b)
        -: 2495:  struct line *a;
        -: 2496:  struct line *b;
        -: 2497:{
        -: 2498:  struct line t;
        -: 2499:
        6: 2500:  MEMCPY(&t,  a, sizeof(struct line));
        6: 2501:  MEMCPY( a,  b, sizeof(struct line));
        6: 2502:  MEMCPY( b, &t, sizeof(struct line));
        6: 2503:}
        -: 2504:
        -: 2505:
        -: 2506:/* dummy function to simplify read_pattern_space() */
        -: 2507:static bool read_always_fail P_((struct input *));
        -: 2508:static bool
function read_always_fail called 1 returned 100% blocks executed 100%
        1: 2509:read_always_fail(input)
        -: 2510:  struct input *input UNUSED;
        -: 2511:{
        1: 2512:  return false;
        -: 2513:}
        -: 2514:
        -: 2515:static bool read_file_line P_((struct input *));
        -: 2516:static bool
function read_file_line called 115 returned 100% blocks executed 89%
      115: 2517:read_file_line(input)
        -: 2518:  struct input *input;
        -: 2519:{
        -: 2520:  static char *b;
        -: 2521:  static size_t blen;
        -: 2522:
      115: 2523:  long result = ck_getline (&b, &blen, input->fp);
call    0 returned 115
      115: 2524:  if (result <= 0)
branch  0 taken 1 (fallthrough)
branch  1 taken 114
        1: 2525:    return false;
        -: 2526:
        -: 2527:  /* Remove the trailing new-line that is left by getline. */
      114: 2528:  if (b[result - 1] == '\n')
branch  0 taken 114 (fallthrough)
branch  1 taken 0
      114: 2529:    --result;
        -: 2530:  else
    #####: 2531:    line.chomped = false;
        -: 2532:
      114: 2533:  str_append(&line, b, result);
call    0 returned 114
      114: 2534:  return true;
        -: 2535:}
        -: 2536:
        -: 2537:
        -: 2538:static inline void output_missing_newline P_((struct output *));
        -: 2539:static inline void
function output_missing_newline called 228 returned 100% blocks executed 50%
      228: 2540:output_missing_newline(outf)
        -: 2541:  struct output *outf;
        -: 2542:{
      228: 2543:  if (outf->missing_newline)
branch  0 taken 0 (fallthrough)
branch  1 taken 228
        -: 2544:    {
    #####: 2545:      ck_fwrite("\n", 1, 1, outf->fp);
call    0 never executed
    #####: 2546:      outf->missing_newline = false;
        -: 2547:    }
      228: 2548:}
        -: 2549:
        -: 2550:static inline void flush_output P_((FILE *));
        -: 2551:static inline void
function flush_output called 228 returned 100% blocks executed 100%
      228: 2552:flush_output(fp)
        -: 2553:  FILE *fp;
        -: 2554:{
      228: 2555:  if (fp != stdout || unbuffered_output)
branch  0 taken 228 (fallthrough)
branch  1 taken 0
branch  2 taken 228 (fallthrough)
branch  3 taken 0
      228: 2556:    ck_fflush(fp);
call    0 returned 228
      228: 2557:}
        -: 2558:
        -: 2559:static void output_line P_((const char *, size_t, bool, struct output *));
        -: 2560:static void
function output_line called 114 returned 100% blocks executed 88%
      114: 2561:output_line(text, length, nl, outf)
        -: 2562:  const char *text;
        -: 2563:  size_t length;
        -: 2564:  bool nl;
        -: 2565:  struct output *outf;
        -: 2566:{
      114: 2567:  output_missing_newline(outf);
call    0 returned 114
        -: 2568:
      114: 2569:  if (length)
branch  0 taken 77 (fallthrough)
branch  1 taken 37
       77: 2570:    ck_fwrite(text, 1, length, outf->fp);
call    0 returned 77
        -: 2571:
      114: 2572:  if (nl)
branch  0 taken 114 (fallthrough)
branch  1 taken 0
      114: 2573:    ck_fwrite("\n", 1, 1, outf->fp);
call    0 returned 114
        -: 2574:  else
    #####: 2575:    outf->missing_newline = true;
        -: 2576:
      114: 2577:  flush_output(outf->fp);
call    0 returned 114
      114: 2578:}
        -: 2579:
        -: 2580:static struct append_queue *next_append_slot P_((void));
        -: 2581:static struct append_queue *
function next_append_slot called 0 returned 0% blocks executed 0%
    #####: 2582:next_append_slot()
        -: 2583:{
    #####: 2584:  struct append_queue *n = MALLOC(1, struct append_queue);
call    0 never executed
        -: 2585:
    #####: 2586:  n->fname = NULL;
    #####: 2587:  n->text = NULL;
    #####: 2588:  n->textlen = 0;
    #####: 2589:  n->next = NULL;
    #####: 2590:  n->free = false;
        -: 2591:
    #####: 2592:  if (append_tail)
branch  0 never executed
branch  1 never executed
    #####: 2593:      append_tail->next = n;
        -: 2594:  else
    #####: 2595:      append_head = n;
    #####: 2596:  return append_tail = n;
        -: 2597:}
        -: 2598:
        -: 2599:static void release_append_queue P_((void));
        -: 2600:static void
function release_append_queue called 0 returned 0% blocks executed 0%
    #####: 2601:release_append_queue()
        -: 2602:{
        -: 2603:  struct append_queue *p, *q;
        -: 2604:
    #####: 2605:  for (p=append_head; p; p=q)
branch  0 never executed
branch  1 never executed
        -: 2606:    {
    #####: 2607:      if (p->free)
branch  0 never executed
branch  1 never executed
    #####: 2608:        FREE(p->text);
call    0 never executed
        -: 2609:
    #####: 2610:      q = p->next;
    #####: 2611:      FREE(p);
call    0 never executed
        -: 2612:    }
    #####: 2613:  append_head = append_tail = NULL;
    #####: 2614:}
        -: 2615:
        -: 2616:static void dump_append_queue P_((void));
        -: 2617:static void
function dump_append_queue called 0 returned 0% blocks executed 0%
    #####: 2618:dump_append_queue()
        -: 2619:{
        -: 2620:  struct append_queue *p;
        -: 2621:
    #####: 2622:  output_missing_newline(&output_file);
call    0 never executed
    #####: 2623:  for (p=append_head; p; p=p->next)
branch  0 never executed
branch  1 never executed
        -: 2624:    {
    #####: 2625:      if (p->text)
branch  0 never executed
branch  1 never executed
    #####: 2626:        ck_fwrite(p->text, 1, p->textlen, output_file.fp);
call    0 never executed
        -: 2627:
    #####: 2628:      if (p->fname)
branch  0 never executed
branch  1 never executed
        -: 2629:	{
        -: 2630:	  char buf[FREAD_BUFFER_SIZE];
        -: 2631:	  size_t cnt;
        -: 2632:	  FILE *fp;
        -: 2633:
        -: 2634:	  /* "If _fname_ does not exist or cannot be read, it shall
        -: 2635:	     be treated as if it were an empty file, causing no error
        -: 2636:	     condition."  IEEE Std 1003.2-1992
        -: 2637:	     So, don't fail. */
    #####: 2638:	  fp = ck_fopen(p->fname, "r", false);
call    0 never executed
    #####: 2639:	  if (fp)
branch  0 never executed
branch  1 never executed
        -: 2640:	    {
    #####: 2641:	      while ((cnt = ck_fread(buf, 1, sizeof buf, fp)) > 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2642:		ck_fwrite(buf, 1, cnt, output_file.fp);
call    0 never executed
    #####: 2643:	      ck_fclose(fp);
call    0 never executed
        -: 2644:	    }
        -: 2645:	}
        -: 2646:    }
        -: 2647:
    #####: 2648:  flush_output(output_file.fp);
call    0 never executed
    #####: 2649:  release_append_queue();
call    0 never executed
    #####: 2650:}
        -: 2651:
        -: 2652:
        -: 2653:/* Compute the name of the backup file for in-place editing */
        -: 2654:static char *get_backup_file_name P_((const char *));
        -: 2655:static char *
function get_backup_file_name called 0 returned 0% blocks executed 0%
    #####: 2656:get_backup_file_name(name)
        -: 2657:  const char *name;
        -: 2658:{
        -: 2659:  char *old_asterisk, *asterisk, *backup, *p;
    #####: 2660:  int name_length = strlen(name), backup_length = strlen(in_place_extension);
        -: 2661:
        -: 2662:  /* Compute the length of the backup file */
    #####: 2663:  for (asterisk = in_place_extension - 1, old_asterisk = asterisk + 1;
    #####: 2664:       asterisk = strchr(old_asterisk, '*');
branch  0 never executed
branch  1 never executed
    #####: 2665:       old_asterisk = asterisk + 1)
    #####: 2666:    backup_length += name_length - 1;
        -: 2667:
    #####: 2668:  p = backup = xmalloc(backup_length + 1);
call    0 never executed
        -: 2669:
        -: 2670:  /* Each iteration gobbles up to an asterisk */
    #####: 2671:  for (asterisk = in_place_extension - 1, old_asterisk = asterisk + 1;
    #####: 2672:       asterisk = strchr(old_asterisk, '*');
branch  0 never executed
branch  1 never executed
    #####: 2673:       old_asterisk = asterisk + 1)
        -: 2674:    {
    #####: 2675:      MEMCPY (p, old_asterisk, asterisk - old_asterisk);
    #####: 2676:      p += asterisk - old_asterisk;
    #####: 2677:      strcpy (p, name);
    #####: 2678:      p += name_length;
        -: 2679:    }
        -: 2680:
        -: 2681:  /* Tack on what's after the last asterisk */
    #####: 2682:  strcpy (p, old_asterisk);
    #####: 2683:  return backup;
        -: 2684:}
        -: 2685:
        -: 2686:/* Initialize a struct input for the named file. */
        -: 2687:static void open_next_file P_((const char *name, struct input *));
        -: 2688:static void
function open_next_file called 1 returned 100% blocks executed 19%
        1: 2689:open_next_file(name, input)
        -: 2690:  const char *name;
        -: 2691:  struct input *input;
        -: 2692:{
        1: 2693:  buffer.length = 0;
        -: 2694:
       1*: 2695:  if (name[0] == '-' && name[1] == '\0' && !in_place_extension)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 2696:    {
    #####: 2697:      clearerr(stdin);	/* clear any stale EOF indication */
call    0 never executed
    #####: 2698:      input->fp = stdin;
        -: 2699:    }
        1: 2700:  else if ( ! (input->fp = ck_fopen(name, "r", false)) )
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
        -: 2701:    {
    #####: 2702:      const char *ptr = strerror(errno);
call    0 never executed
    #####: 2703:      fprintf(stderr, _("%s: can't read %s: %s\n"), myname, name, ptr);
call    0 never executed
    #####: 2704:      input->read_fn = read_always_fail; /* a redundancy */
    #####: 2705:      ++input->bad_count;
    #####: 2706:      return;
        -: 2707:    }
        -: 2708:
        1: 2709:  input->read_fn = read_file_line;
        -: 2710:
        1: 2711:  if (in_place_extension)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -: 2712:    {
        -: 2713:      int output_fd;
    #####: 2714:      char *tmpdir = ck_strdup(name), *p;
call    0 never executed
        -: 2715:      struct stat st;
        -: 2716:
        -: 2717:      /* get the base name */
    #####: 2718:      if (p = strrchr(tmpdir, '/'))
branch  0 never executed
branch  1 never executed
    #####: 2719:	*(p + 1) = 0;
        -: 2720:      else
    #####: 2721:	strcpy(tmpdir, ".");
        -: 2722:      
    #####: 2723:      input->in_file_name = name;
        -: 2724:
    #####: 2725:      if (isatty (fileno (input->fp)))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2726:        panic(_("couldn't edit %s: is a terminal"), input->in_file_name);
call    0 never executed
        -: 2727:
    #####: 2728:      fstat (fileno (input->fp), &st);
call    0 never executed
call    1 never executed
    #####: 2729:      if (!S_ISREG (st.st_mode))
branch  0 never executed
branch  1 never executed
    #####: 2730:        panic(_("couldn't edit %s: not a regular file"), input->in_file_name);
call    0 never executed
        -: 2731:
    #####: 2732:      output_file.fp = ck_mkstemp (&input->out_file_name, tmpdir, "sed");
call    0 never executed
    #####: 2733:      output_file.missing_newline = false;
    #####: 2734:      free (tmpdir);
        -: 2735:
    #####: 2736:      if (!output_file.fp)
branch  0 never executed
branch  1 never executed
    #####: 2737:        panic(_("couldn't open temporary file %s: %s"), input->out_file_name, strerror(errno));
call    0 never executed
call    1 never executed
        -: 2738:
    #####: 2739:      output_fd = fileno (output_file.fp);
call    0 never executed
        -: 2740:#ifdef HAVE_FCHMOD
        -: 2741:      fchmod (output_fd, st.st_mode);
        -: 2742:#endif
        -: 2743:#ifdef HAVE_FCHOWN
        -: 2744:      if (fchown (output_fd, st.st_uid, st.st_gid) == -1)
        -: 2745:        fchown (output_fd, -1, st.st_gid);
        -: 2746:#endif
        -: 2747:    }
        -: 2748:  else
        1: 2749:    output_file.fp = stdout;
        -: 2750:}
        -: 2751:
        -: 2752:
        -: 2753:/* Clean up an input stream that we are done with. */
        -: 2754:static void closedown P_((struct input *));
        -: 2755:static void
function closedown called 3 returned 100% blocks executed 47%
        3: 2756:closedown(input)
        -: 2757:  struct input *input;
        -: 2758:{
        3: 2759:  input->read_fn = read_always_fail;
        3: 2760:  if (!input->fp)
branch  0 taken 2 (fallthrough)
branch  1 taken 1
        2: 2761:    return;
        1: 2762:  if (input->fp != stdin) /* stdin can be reused on tty and tape devices */
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 2763:    ck_fclose(input->fp);
call    0 returned 1
        -: 2764:
       1*: 2765:  if (in_place_extension && output_file.fp != NULL)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
branch  2 never executed
branch  3 never executed
        -: 2766:    {
    #####: 2767:      ck_fclose (output_file.fp);
call    0 never executed
    #####: 2768:      if (strcmp(in_place_extension, "*") != 0)
branch  0 never executed
branch  1 never executed
        -: 2769:        {
    #####: 2770:          char *backup_file_name = get_backup_file_name(input->in_file_name);
call    0 never executed
    #####: 2771:	  ck_rename (input->in_file_name, backup_file_name, input->out_file_name);
call    0 never executed
    #####: 2772:          free (backup_file_name);
        -: 2773:	}
        -: 2774:
    #####: 2775:      ck_rename (input->out_file_name, input->in_file_name, input->out_file_name);
call    0 never executed
    #####: 2776:      free (input->out_file_name);
        -: 2777:    }
        -: 2778:
        1: 2779:  input->fp = NULL;
        -: 2780:}
        -: 2781:
        -: 2782:/* Reset range commands so that they are marked as non-matching */
        -: 2783:static void reset_addresses P_((struct vector *));
        -: 2784:static void
function reset_addresses called 1 returned 100% blocks executed 67%
        1: 2785:reset_addresses(vec)
        -: 2786:     struct vector *vec;
        -: 2787:{
        -: 2788:  struct sed_cmd *cur_cmd;
        -: 2789:  int n;
        -: 2790:
        -: 2791:#ifndef FAULTY_F_KRM_2
        -: 2792:  for (cur_cmd = vec->v, n = vec->v_length; n--; cur_cmd++)
        -: 2793:#else
        2: 2794:  for (cur_cmd = vec->v, n = vec->v_length; --n; cur_cmd++)
branch  0 taken 1
branch  1 taken 1 (fallthrough)
        -: 2795:#endif    
        1: 2796:    if (cur_cmd->a1
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 2797:	&& cur_cmd->a1->addr_type == ADDR_IS_NUM
branch  0 never executed
branch  1 never executed
    #####: 2798:	&& cur_cmd->a1->addr_number == 0)
branch  0 never executed
branch  1 never executed
        -: 2799:
        -: 2800:#ifndef FAULT_F_KRM_3
    #####: 2801:      cur_cmd->range_state = RANGE_ACTIVE;
        -: 2802:    else
        1: 2803:      cur_cmd->range_state = RANGE_INACTIVE;
        -: 2804:#else
        -: 2805:      cur_cmd->range_state = RANGE_INACTIVE;
        -: 2806:    else
        -: 2807:      cur_cmd->range_state = RANGE_ACTIVE;
        -: 2808:#endif
        1: 2809:}
        -: 2810:
        -: 2811:/* Read in the next line of input, and store it in the pattern space.
        -: 2812:   Return zero if there is nothing left to input. */
        -: 2813:static bool read_pattern_space P_((struct input *, struct vector *, bool));
        -: 2814:static bool
function read_pattern_space called 115 returned 100% blocks executed 89%
      115: 2815:read_pattern_space(input, the_program, append)
        -: 2816:  struct input *input;
        -: 2817:  struct vector *the_program;
        -: 2818:  bool append;
        -: 2819:{
      115: 2820:  if (append_head) /* redundant test to optimize for common case */
branch  0 taken 0 (fallthrough)
branch  1 taken 115
    #####: 2821:    dump_append_queue();
call    0 never executed
      115: 2822:  replaced = false;
      115: 2823:  if (!append)
branch  0 taken 115 (fallthrough)
branch  1 taken 0
      115: 2824:    line.length = 0;
      115: 2825:  line.chomped = true;  /* default, until proved otherwise */
        -: 2826:
      116: 2827:  while ( ! (*input->read_fn)(input) )
call    0 returned 116
branch  1 taken 2
branch  2 taken 114 (fallthrough)
        -: 2828:    {
        2: 2829:      closedown(input);
call    0 returned 2
        -: 2830:
        2: 2831:      if (!*input->file_list)
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        1: 2832:	return false;
        -: 2833:
        1: 2834:      if (input->reset_at_next_file)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -: 2835:	{
        1: 2836:	  input->line_number = 0;
        1: 2837:	  reset_addresses (the_program);
call    0 returned 1
        1: 2838:	  rewind_read_files ();
call    0 returned 1
        -: 2839:
        -: 2840:	  /* If doing in-place editing, we will never append the
        -: 2841:	     new-line to this file; but if the output goes to stdout,
        -: 2842:	     we might still have to output the missing new-line.  */
        1: 2843:	  if (in_place_extension)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 2844:	    output_file.missing_newline = false;
        -: 2845:
        1: 2846:	  input->reset_at_next_file = separate_files;
        -: 2847:	}
        -: 2848:
        1: 2849:      open_next_file (*input->file_list++, input);
call    0 returned 1
        -: 2850:    }
        -: 2851:
      114: 2852:  ++input->line_number;
      114: 2853:  return true;
        -: 2854:}
        -: 2855:
        -: 2856:
        -: 2857:static bool last_file_with_data_p P_((struct input *));
        -: 2858:static bool
function last_file_with_data_p called 0 returned 0% blocks executed 0%
    #####: 2859:last_file_with_data_p(input)
        -: 2860:  struct input *input;
        -: 2861:{
        -: 2862:  for (;;)
    #####: 2863:    {
        -: 2864:      int ch;
        -: 2865:
    #####: 2866:      closedown(input);
call    0 never executed
    #####: 2867:      if (!*input->file_list)
branch  0 never executed
branch  1 never executed
    #####: 2868:	return true;
    #####: 2869:      open_next_file(*input->file_list++, input);
call    0 never executed
    #####: 2870:      if (input->fp)
branch  0 never executed
branch  1 never executed
        -: 2871:	{
    #####: 2872:	  if ((ch = getc(input->fp)) != EOF)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2873:	    {
    #####: 2874:	      ungetc(ch, input->fp);
call    0 never executed
    #####: 2875:	      return false;
        -: 2876:	    }
        -: 2877:	}
        -: 2878:    }
        -: 2879:}
        -: 2880:
        -: 2881:/* Determine if we match the `$' address. */
        -: 2882:static bool test_eof P_((struct input *));
        -: 2883:static bool
function test_eof called 0 returned 0% blocks executed 0%
    #####: 2884:test_eof(input)
        -: 2885:  struct input *input;
        -: 2886:{
        -: 2887:  int ch;
        -: 2888:
    #####: 2889:  if (buffer.length)
branch  0 never executed
branch  1 never executed
    #####: 2890:    return false;
    #####: 2891:  if (!input->fp)
branch  0 never executed
branch  1 never executed
    #####: 2892:    return separate_files || last_file_with_data_p(input);
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 2893:  if (feof(input->fp))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2894:    return separate_files || last_file_with_data_p(input);
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 2895:  if ((ch = getc(input->fp)) == EOF)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2896:    return separate_files || last_file_with_data_p(input);
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 2897:  ungetc(ch, input->fp);
call    0 never executed
    #####: 2898:  return false;
        -: 2899:}
        -: 2900:
        -: 2901:/* Return non-zero if the current line matches the address
        -: 2902:   pointed to by `addr'. */
        -: 2903:static bool match_an_address_p P_((struct addr *, struct input *));
        -: 2904:static bool
function match_an_address_p called 0 returned 0% blocks executed 0%
    #####: 2905:match_an_address_p(addr, input)
        -: 2906:  struct addr *addr;
        -: 2907:  struct input *input;
        -: 2908:{
    #####: 2909:  switch (addr->addr_type)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 2910:    {
    #####: 2911:    case ADDR_IS_NULL:
    #####: 2912:      return true;
        -: 2913:
    #####: 2914:    case ADDR_IS_REGEX:
    #####: 2915:      return match_regex(addr->addr_regex, line.active, line.length, 0, NULL, 0);
call    0 never executed
        -: 2916:
    #####: 2917:    case ADDR_IS_NUM_MOD:
    #####: 2918:      return (input->line_number >= addr->addr_number
    #####: 2919:	      && ((input->line_number - addr->addr_number) % addr->addr_step) == 0);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2920:
    #####: 2921:    case ADDR_IS_STEP:
        -: 2922:    case ADDR_IS_STEP_MOD:
        -: 2923:      /* reminder: these are only meaningful for a2 addresses */
        -: 2924:      /* a2->addr_number needs to be recomputed each time a1 address
        -: 2925:         matches for the step and step_mod types */
        -: 2926:#ifndef FAULTY_F_KRM_4
    #####: 2927:      return (addr->addr_number <= input->line_number);
        -: 2928:#else
        -: 2929:      return (addr->addr_number > input->line_number);
        -: 2930:#endif
    #####: 2931:    case ADDR_IS_LAST:
    #####: 2932:      return test_eof(input);
call    0 never executed
        -: 2933:
        -: 2934:      /* ADDR_IS_NUM is handled in match_address_p.  */
    #####: 2935:    case ADDR_IS_NUM:
        -: 2936:    default:
    #####: 2937:      panic("INTERNAL ERROR: bad address type");
call    0 never executed
        -: 2938:    }
        -: 2939:  /*NOTREACHED*/
    #####: 2940:  return false;
        -: 2941:}
        -: 2942:
        -: 2943:/* return non-zero if current address is valid for cmd */
        -: 2944:static bool match_address_p P_((struct sed_cmd *, struct input *));
        -: 2945:static bool
function match_address_p called 228 returned 100% blocks executed 9%
      228: 2946:match_address_p(cmd, input)
        -: 2947:  struct sed_cmd *cmd;
        -: 2948:  struct input *input;
        -: 2949:{
      228: 2950:  if (!cmd->a1)
branch  0 taken 228 (fallthrough)
branch  1 taken 0
      228: 2951:    return true;
        -: 2952:
    #####: 2953:  if (cmd->range_state != RANGE_ACTIVE)
branch  0 never executed
branch  1 never executed
        -: 2954:    {
        -: 2955:      /* Find if we are going to activate a range.  Handle ADDR_IS_NUM
        -: 2956:	 specially: it represent an "absolute" state, it should not
        -: 2957:	 be computed like regexes.  */
    #####: 2958:      if (cmd->a1->addr_type == ADDR_IS_NUM)
branch  0 never executed
branch  1 never executed
        -: 2959:	{
    #####: 2960:	  if (!cmd->a2)
branch  0 never executed
branch  1 never executed
    #####: 2961:	    return (input->line_number == cmd->a1->addr_number);
        -: 2962:
    #####: 2963:	  if (cmd->range_state == RANGE_CLOSED
branch  0 never executed
branch  1 never executed
    #####: 2964:	      || input->line_number < cmd->a1->addr_number)
branch  0 never executed
branch  1 never executed
    #####: 2965:	    return false;
        -: 2966:	}
        -: 2967:      else
        -: 2968:	{
    #####: 2969:          if (!cmd->a2)
branch  0 never executed
branch  1 never executed
    #####: 2970:	    return match_an_address_p(cmd->a1, input);
call    0 never executed
        -: 2971:
    #####: 2972:	  if (!match_an_address_p(cmd->a1, input))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2973:            return false;
        -: 2974:	}
        -: 2975:
        -: 2976:      /* Ok, start a new range.  */
    #####: 2977:      cmd->range_state = RANGE_ACTIVE;
    #####: 2978:      switch (cmd->a2->addr_type)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -: 2979:	{
    #####: 2980:	case ADDR_IS_REGEX:
        -: 2981:	  /* Always include at least two lines.  */
    #####: 2982:	  return true;
    #####: 2983:	case ADDR_IS_NUM:
        -: 2984:	  /* Same handling as below, but always include at least one line.  */
    #####: 2985:          if (input->line_number >= cmd->a2->addr_number)
branch  0 never executed
branch  1 never executed
    #####: 2986:	    cmd->range_state = RANGE_CLOSED;
    #####: 2987:          return true;
    #####: 2988:	case ADDR_IS_STEP:
    #####: 2989:	  cmd->a2->addr_number = input->line_number + cmd->a2->addr_step;
    #####: 2990:	  return true;
    #####: 2991:	case ADDR_IS_STEP_MOD:
    #####: 2992:	  cmd->a2->addr_number = input->line_number + cmd->a2->addr_step
    #####: 2993:				 - (input->line_number%cmd->a2->addr_step);
    #####: 2994:	  return true;
    #####: 2995:	default:
    #####: 2996:	  break;
        -: 2997:        }
        -: 2998:    }
        -: 2999:
        -: 3000:  /* cmd->range_state == RANGE_ACTIVE.  Check if the range is
        -: 3001:     ending; also handle ADDR_IS_NUM specially in this case.  */
        -: 3002:
    #####: 3003:  if (cmd->a2->addr_type == ADDR_IS_NUM)
branch  0 never executed
branch  1 never executed
        -: 3004:    {
        -: 3005:      /* If the second address is a line number, and if we got past
        -: 3006:         that line, fail to match (it can happen when you jump
        -: 3007:	 over such addresses with `b' and `t'.  Use RANGE_CLOSED
        -: 3008:         so that the range is not re-enabled anymore.  */
    #####: 3009:      if (input->line_number >= cmd->a2->addr_number)
branch  0 never executed
branch  1 never executed
    #####: 3010:	cmd->range_state = RANGE_CLOSED;
        -: 3011:
    #####: 3012:      return (input->line_number <= cmd->a2->addr_number);
        -: 3013:   }
        -: 3014:
        -: 3015:  /* Other addresses are treated as usual.  */
    #####: 3016:  if (match_an_address_p(cmd->a2, input))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3017:    cmd->range_state = RANGE_CLOSED;
        -: 3018:
    #####: 3019:  return true;
        -: 3020:}
        -: 3021:
        -: 3022:
        -: 3023:static void do_list P_((int line_len));
        -: 3024:static void
function do_list called 114 returned 100% blocks executed 73%
      114: 3025:do_list(line_len)
        -: 3026:     int line_len;
        -: 3027:{
      114: 3028:  unsigned char *p = CAST(unsigned char *)line.active;
      114: 3029:  countT len = line.length;
      114: 3030:  countT width = 0;
        -: 3031:  char obuf[180];	/* just in case we encounter a 512-bit char (;-) */
        -: 3032:  char *o;
        -: 3033:  size_t olen;
      114: 3034:  FILE *fp = output_file.fp;
        -: 3035:
      114: 3036:  output_missing_newline(&output_file);
call    0 returned 114
        -: 3037:
     1801: 3038:  for (; len--; ++p) {
branch  0 taken 1687
branch  1 taken 114 (fallthrough)
     1687: 3039:      o = obuf;
        -: 3040:      
        -: 3041:      /* Some locales define 8-bit characters as printable.  This makes the
        -: 3042:	 testsuite fail at 8to7.sed because the `l' command in fact will not
        -: 3043:	 convert the 8-bit characters. */
        -: 3044:#if defined isascii || defined HAVE_ISASCII
     1687: 3045:      if (isascii(*p) && ISPRINT(*p)) {
branch  0 taken 1687 (fallthrough)
branch  1 taken 0
branch  2 taken 1669 (fallthrough)
branch  3 taken 18
        -: 3046:#else
        -: 3047:      if (ISPRINT(*p)) {
        -: 3048:#endif
     1669: 3049:	  *o++ = *p;
     1669: 3050:	  if (*p == '\\')
branch  0 taken 0 (fallthrough)
branch  1 taken 1669
    #####: 3051:	    *o++ = '\\';
        -: 3052:      } else {
       18: 3053:	  *o++ = '\\';
       18: 3054:	  switch (*p) {
branch  0 taken 0
branch  1 taken 0
branch  2 taken 0
branch  3 taken 0
branch  4 taken 0
branch  5 taken 15
branch  6 taken 0
branch  7 taken 3
        -: 3055:#if defined __STDC__ && __STDC__-0
    #####: 3056:	    case '\a': *o++ = 'a'; break;
        -: 3057:#else /* Not STDC; we'll just assume ASCII */
        -: 3058:	    case 007:  *o++ = 'a'; break;
        -: 3059:#endif
    #####: 3060:	    case '\b': *o++ = 'b'; break;
    #####: 3061:	    case '\f': *o++ = 'f'; break;
    #####: 3062:	    case '\n': *o++ = 'n'; break;
    #####: 3063:	    case '\r': *o++ = 'r'; break;
       15: 3064:	    case '\t': *o++ = 't'; break;
    #####: 3065:	    case '\v': *o++ = 'v'; break;
        3: 3066:	    default:
        3: 3067:	      sprintf(o, "%03o", *p);
        3: 3068:	      o += strlen(o);
        3: 3069:	      break;
        -: 3070:	    }
        -: 3071:      }
     1687: 3072:      olen = o - obuf;
        -: 3073:
     1687: 3074:      if (width+olen >= line_len && line_len > 0) {
branch  0 taken 52 (fallthrough)
branch  1 taken 1635
branch  2 taken 52 (fallthrough)
branch  3 taken 0
       52: 3075:	  ck_fwrite("\\\n", 1, 2, fp);
call    0 returned 52
       52: 3076:	  width = 0;
        -: 3077:      }
     1687: 3078:      ck_fwrite(obuf, 1, olen, fp);
call    0 returned 1687
     1687: 3079:      width += olen;
        -: 3080:  }
      114: 3081:  ck_fwrite("$\n", 1, 2, fp);
call    0 returned 114
      114: 3082:  flush_output (fp);
call    0 returned 114
      114: 3083:}
        -: 3084:
        -: 3085:
        -: 3086:static enum replacement_types append_replacement P_((struct line *, struct replacement *,
        -: 3087:						     struct re_registers *,
        -: 3088:						     enum replacement_types));
        -: 3089:static enum replacement_types
function append_replacement called 12 returned 100% blocks executed 69%
       12: 3090:append_replacement (buf, p, regs, repl_mod)
        -: 3091:  struct line *buf;
        -: 3092:  struct replacement *p;
        -: 3093:  struct re_registers *regs;
        -: 3094:  enum replacement_types repl_mod;
        -: 3095:{
       24: 3096:  for (; p; p=p->next)
branch  0 taken 12
branch  1 taken 12 (fallthrough)
        -: 3097:    {
       12: 3098:      int i = p->subst_id;
        -: 3099:      enum replacement_types curr_type;
        -: 3100:
        -: 3101:      /* Apply a \[lu] modifier that was given earlier, but which we
        -: 3102:         have not had yet the occasion to apply.  But don't do it
        -: 3103:         if this replacement has a modifier of its own. */
       24: 3104:      curr_type = (p->repl_type & REPL_MODIFIERS)
        -: 3105:        ? p->repl_type
      12*: 3106:        : p->repl_type | repl_mod;
branch  0 taken 0 (fallthrough)
branch  1 taken 12
        -: 3107:
       12: 3108:      repl_mod = 0;
       12: 3109:      if (p->prefix_length)
branch  0 taken 12 (fallthrough)
branch  1 taken 0
        -: 3110:        {
       12: 3111:          str_append_modified(buf, p->prefix, p->prefix_length,
call    0 returned 12
        -: 3112:    			      curr_type);
       12: 3113:          curr_type &= ~REPL_MODIFIERS;
        -: 3114:        }
        -: 3115:
       12: 3116:      if (0 <= i)
branch  0 taken 0 (fallthrough)
branch  1 taken 12
    #####: 3117:        if (regs->end[i] == regs->start[i] && p->repl_type & REPL_MODIFIERS)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 3118:          /* Save this modifier, we shall apply it later.
        -: 3119:	     e.g. in s/()([a-z])/\u\1\2/
        -: 3120:	     the \u modifier is applied to \2, not \1 */
    #####: 3121:	  repl_mod = curr_type & REPL_MODIFIERS;
        -: 3122:
        -: 3123:	else
    #####: 3124:	  str_append_modified(buf, line.active + regs->start[i],
    #####: 3125:			      CAST(size_t)(regs->end[i] - regs->start[i]),
call    0 never executed
        -: 3126:			      curr_type);
        -: 3127:    }
        -: 3128:
       12: 3129:  return repl_mod;
        -: 3130:}
        -: 3131:
        -: 3132:static void do_subst P_((struct subst *));
        -: 3133:static void
function do_subst called 114 returned 100% blocks executed 59%
      114: 3134:do_subst(sub)
        -: 3135:  struct subst *sub;
        -: 3136:{
      114: 3137:  size_t start = 0;	/* where to start scan for (next) match in LINE */
      114: 3138:  size_t last_end = 0;  /* where did the last successful match end in LINE */
      114: 3139:  countT count = 0;	/* number of matches found */
      114: 3140:  bool again = true;
        -: 3141:
        -: 3142:  static struct re_registers regs;
        -: 3143:
      114: 3144:  if (s_accum.alloc == 0)
branch  0 taken 1 (fallthrough)
branch  1 taken 113
        1: 3145:    line_init(&s_accum, INITIAL_BUFFER_SIZE);
call    0 returned 1
      114: 3146:  s_accum.length = 0;
        -: 3147:
        -: 3148:  /* The first part of the loop optimizes s/xxx// when xxx is at the
        -: 3149:     start, and s/xxx$// */
      114: 3150:  if (!match_regex(sub->regx, line.active, line.length, start,
branch  0 taken 108 (fallthrough)
branch  1 taken 6
      114: 3151:		   &regs, sub->max_id + 1))
call    0 returned 114
      108: 3152:    return;
        -: 3153:  
       6*: 3154:  if (!sub->replacement && sub->numb <= 1)
branch  0 taken 0 (fallthrough)
branch  1 taken 6
branch  2 never executed
branch  3 never executed
    #####: 3155:    if (regs.start[0] == 0 && !sub->global)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 3156:      {
        -: 3157:	/* We found a match, set the `replaced' flag. */
    #####: 3158:	replaced = true;
        -: 3159:
    #####: 3160:	line.active += regs.end[0];
    #####: 3161:	line.length -= regs.end[0];
    #####: 3162:	line.alloc -= regs.end[0];
    #####: 3163:	goto post_subst;
        -: 3164:      }
    #####: 3165:    else if (regs.end[0] == line.length)
branch  0 never executed
branch  1 never executed
        -: 3166:      {
        -: 3167:	/* We found a match, set the `replaced' flag. */
    #####: 3168:	replaced = true;
        -: 3169:
    #####: 3170:	line.length = regs.start[0];
    #####: 3171:	goto post_subst;
        -: 3172:      }
        -: 3173:
        -: 3174:  do
        -: 3175:    {
       12: 3176:      enum replacement_types repl_mod = 0;
        -: 3177:
       12: 3178:      size_t offset = regs.start[0];
       12: 3179:      size_t matched = regs.end[0] - regs.start[0];
        -: 3180:
        -: 3181:      /* Copy stuff to the left of this match into the output string. */
       12: 3182:      if (start < offset)
branch  0 taken 12 (fallthrough)
branch  1 taken 0
       12: 3183:	str_append(&s_accum, line.active + start, offset - start);
call    0 returned 12
        -: 3184:
        -: 3185:      /* If we're counting up to the Nth match, are we there yet?
        -: 3186:         And even if we are there, there is another case we have to
        -: 3187:	 skip: are we matching an empty string immediately following
        -: 3188:         another match?
        -: 3189:
        -: 3190:         This latter case avoids that baaaac, when passed through
        -: 3191:         s,a*,x,g, gives `xbxxcx' instead of xbxcx.  This behavior is
        -: 3192:         unacceptable because it is not consistently applied (for
        -: 3193:         example, `baaaa' gives `xbx', not `xbxx'). */
      12*: 3194:      if ((matched > 0 || count == 0 || offset > last_end)
branch  0 taken 0 (fallthrough)
branch  1 taken 12
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
       12: 3195:	  && ++count >= sub->numb)
branch  0 taken 12 (fallthrough)
branch  1 taken 0
        -: 3196:        {
        -: 3197:          /* We found a match, set the `replaced' flag. */
       12: 3198:          replaced = true;
        -: 3199:
        -: 3200:          /* Now expand the replacement string into the output string. */
       12: 3201:          repl_mod = append_replacement (&s_accum, sub->replacement, &regs, repl_mod);
call    0 returned 12
       12: 3202:	  again = sub->global;
        -: 3203:        }
        -: 3204:      else
        -: 3205:	{
        -: 3206:          /* The match was not replaced.  Copy the text until its
        -: 3207:             end; if it was vacuous, skip over one character and
        -: 3208:	     add that character to the output.  */
    #####: 3209:	  if (matched == 0)
branch  0 never executed
branch  1 never executed
        -: 3210:	    {
    #####: 3211:	      if (start < line.length)
branch  0 never executed
branch  1 never executed
    #####: 3212:	        matched = 1;
        -: 3213:	      else
    #####: 3214:	        break;
        -: 3215:	    }
        -: 3216:
    #####: 3217:	  str_append(&s_accum, line.active + offset, matched);
call    0 never executed
        -: 3218:        }
        -: 3219:
        -: 3220:      /* Start after the match.  last_end is the real end of the matched
        -: 3221:	 substring, excluding characters that were skipped in case the RE
        -: 3222:	 matched the empty string.  */
       12: 3223:      start = offset + matched;
       12: 3224:      last_end = regs.end[0];
        -: 3225:    }
        -: 3226:  while (again
       12: 3227:	 && start <= line.length
branch  0 taken 12 (fallthrough)
branch  1 taken 0
       24: 3228:	 && match_regex(sub->regx, line.active, line.length, start,
branch  0 taken 12 (fallthrough)
branch  1 taken 0
branch  2 taken 6
branch  3 taken 6 (fallthrough)
       12: 3229:			&regs, sub->max_id + 1));
call    0 returned 12
        -: 3230:
        -: 3231:  /* Copy stuff to the right of the last match into the output string. */
        6: 3232:  if (start < line.length)
branch  0 taken 4 (fallthrough)
branch  1 taken 2
        4: 3233:    str_append(&s_accum, line.active + start, line.length-start);
call    0 returned 4
        6: 3234:  s_accum.chomped = line.chomped;
        -: 3235:
        -: 3236:  /* Exchange line and s_accum.  This can be much cheaper
        -: 3237:     than copying s_accum.active into line.text (for huge lines). */
        6: 3238:  line_exchange(&line, &s_accum);
call    0 returned 6
        -: 3239:  
        -: 3240:  /* Finish up. */
        6: 3241:  if (count < sub->numb)
branch  0 taken 0 (fallthrough)
branch  1 taken 6
    #####: 3242:    return;
        -: 3243:
        6: 3244: post_subst:
        6: 3245:  if (sub->print & 1)
branch  0 taken 0 (fallthrough)
branch  1 taken 6
    #####: 3246:    output_line(line.active, line.length, line.chomped, &output_file);
call    0 never executed
        -: 3247:  
        6: 3248:  if (sub->eval) 
branch  0 taken 0 (fallthrough)
branch  1 taken 6
        -: 3249:    {
        -: 3250:#ifdef HAVE_POPEN
        -: 3251:      FILE *pipe;
        -: 3252:      s_accum.length = 0;
        -: 3253:      
        -: 3254:      str_append (&line, "", 1);
        -: 3255:      pipe = popen(line.active, "r");
        -: 3256:      
        -: 3257:      if (pipe != NULL) 
        -: 3258:	{
        -: 3259:	  while (!feof (pipe)) 
        -: 3260:	    {
        -: 3261:	      char buf[4096];
        -: 3262:	      int n = fread (buf, sizeof(char), 4096, pipe);
        -: 3263:	      if (n > 0)
        -: 3264:		str_append(&s_accum, buf, n);
        -: 3265:	    }
        -: 3266:	  
        -: 3267:	  pclose (pipe);
        -: 3268:
        -: 3269:	  line_exchange(&line, &s_accum);
        -: 3270:	  if (line.length &&
        -: 3271:	      line.active[line.length - 1] == '\n')
        -: 3272:	    line.length--;
        -: 3273:	}
        -: 3274:      else
        -: 3275:	panic(_("error in subprocess"));
        -: 3276:#else
    #####: 3277:      panic(_("option `e' not supported"));
call    0 never executed
        -: 3278:#endif
        -: 3279:    } 
        -: 3280:  
        6: 3281:  if (sub->print & 2)
branch  0 taken 0 (fallthrough)
branch  1 taken 6
    #####: 3282:    output_line(line.active, line.length, line.chomped, &output_file);
call    0 never executed
        6: 3283:  if (sub->outf)
branch  0 taken 0 (fallthrough)
branch  1 taken 6
    #####: 3284:    output_line(line.active, line.length, line.chomped, sub->outf);
call    0 never executed
        -: 3285:}
        -: 3286:
        -: 3287:#ifdef EXPERIMENTAL_DASH_N_OPTIMIZATION
        -: 3288:/* Used to attempt a simple-minded optimization. */
        -: 3289:
        -: 3290:static countT branches;
        -: 3291:
        -: 3292:static countT count_branches P_((struct vector *));
        -: 3293:static countT
        -: 3294:count_branches(program)
        -: 3295:  struct vector *program;
        -: 3296:{
        -: 3297:  struct sed_cmd *cur_cmd = program->v;
        -: 3298:  countT isn_cnt = program->v_length;
        -: 3299:  countT cnt = 0;
        -: 3300:
        -: 3301:  while (isn_cnt-- > 0)
        -: 3302:    {
        -: 3303:      switch (cur_cmd->cmd)
        -: 3304:	{
        -: 3305:	case 'b':
        -: 3306:	case 't':
        -: 3307:	case 'T':
        -: 3308:	case '{':
        -: 3309:	  ++cnt;
        -: 3310:	}
        -: 3311:    }
        -: 3312:  return cnt;
        -: 3313:}
        -: 3314:
        -: 3315:static struct sed_cmd *shrink_program P_((struct vector *, struct sed_cmd *));
        -: 3316:static struct sed_cmd *
        -: 3317:shrink_program(vec, cur_cmd)
        -: 3318:  struct vector *vec;
        -: 3319:  struct sed_cmd *cur_cmd;
        -: 3320:{
        -: 3321:  struct sed_cmd *v = vec->v;
        -: 3322:  struct sed_cmd *last_cmd = v + vec->v_length;
        -: 3323:  struct sed_cmd *p;
        -: 3324:  countT cmd_cnt;
        -: 3325:
        -: 3326:  for (p=v; p < cur_cmd; ++p)
        -: 3327:    if (p->cmd != '#')
        -: 3328:      MEMCPY(v++, p, sizeof *v);
        -: 3329:  cmd_cnt = v - vec->v;
        -: 3330:
        -: 3331:  for (; p < last_cmd; ++p)
        -: 3332:    if (p->cmd != '#')
        -: 3333:      MEMCPY(v++, p, sizeof *v);
        -: 3334:  vec->v_length = v - vec->v;
        -: 3335:
        -: 3336:  return (0 < vec->v_length) ? (vec->v + cmd_cnt) : CAST(struct sed_cmd *)0;
        -: 3337:}
        -: 3338:#endif /*EXPERIMENTAL_DASH_N_OPTIMIZATION*/
        -: 3339:
        -: 3340:/* Execute the program `vec' on the current input line.
        -: 3341:   Return exit status if caller should quit, -1 otherwise. */
        -: 3342:static int execute_program P_((struct vector *, struct input *));
        -: 3343:static int
function execute_program called 114 returned 100% blocks executed 13%
      114: 3344:execute_program(vec, input)
        -: 3345:  struct vector *vec;
        -: 3346:  struct input *input;
        -: 3347:{
        -: 3348:  struct sed_cmd *cur_cmd;
        -: 3349:  struct sed_cmd *end_cmd;
        -: 3350:
      114: 3351:  cur_cmd = vec->v;
      114: 3352:  end_cmd = vec->v + vec->v_length;
        -: 3353:
      342: 3354:  while (cur_cmd < end_cmd)
branch  0 taken 228
branch  1 taken 114 (fallthrough)
        -: 3355:    {
      228: 3356:      if (match_address_p(cur_cmd, input) != cur_cmd->addr_bang)
call    0 returned 228
branch  1 taken 228 (fallthrough)
branch  2 taken 0
        -: 3357:	{
     228*: 3358:	  switch (cur_cmd->cmd)
branch  0 taken 0
branch  1 taken 0
branch  2 taken 0
branch  3 taken 0
branch  4 taken 0
branch  5 taken 0
branch  6 taken 0
branch  7 taken 0
branch  8 taken 0
branch  9 taken 0
branch 10 taken 0
branch 11 taken 0
branch 12 taken 114
branch 13 taken 0
branch 14 taken 0
branch 15 taken 0
branch 16 taken 0
branch 17 taken 0
branch 18 taken 0
branch 19 taken 0
branch 20 taken 0
branch 21 taken 0
branch 22 taken 114
branch 23 taken 0
branch 24 taken 0
branch 25 taken 0
branch 26 taken 0
branch 27 taken 0
branch 28 taken 0
branch 29 taken 0
branch 30 taken 0
        -: 3359:	    {
    #####: 3360:	    case 'a':
        -: 3361:	      {
    #####: 3362:		struct append_queue *aq = next_append_slot();
call    0 never executed
    #####: 3363:		aq->text = cur_cmd->x.cmd_txt.text;
    #####: 3364:		aq->textlen = cur_cmd->x.cmd_txt.text_length;
        -: 3365:	      }
    #####: 3366:	      break;
        -: 3367:
    #####: 3368:	    case '{':
        -: 3369:	    case 'b':
    #####: 3370:	      cur_cmd = vec->v + cur_cmd->x.jump_index;
    #####: 3371:	      continue;
        -: 3372:
    #####: 3373:	    case '}':
        -: 3374:	    case '#':
        -: 3375:	    case ':':
        -: 3376:	      /* Executing labels and block-ends are easy. */
    #####: 3377:	      break;
        -: 3378:
    #####: 3379:	    case 'c':
    #####: 3380:	      if (cur_cmd->range_state != RANGE_ACTIVE)
branch  0 never executed
branch  1 never executed
    #####: 3381:		output_line(cur_cmd->x.cmd_txt.text,
call    0 never executed
        -: 3382:#ifndef FAULTY_F_KRM_5
        -: 3383:			    cur_cmd->x.cmd_txt.text_length - 1, true,
        -: 3384:#else
        -: 3385:			    cur_cmd->x.cmd_txt.text_length, true,
        -: 3386:#endif
        -: 3387:			    &output_file);
        -: 3388:	      /* POSIX.2 is silent about c starting a new cycle,
        -: 3389:		 but it seems to be expected (and make sense). */
        -: 3390:	      /* Fall Through */
        -: 3391:	    case 'd':
    #####: 3392:	      return -1;
        -: 3393:
    #####: 3394:	    case 'D':
    #####: 3395:	      {
    #####: 3396:		char *p = memchr(line.active, '\n', line.length);
    #####: 3397:		if (!p)
branch  0 never executed
branch  1 never executed
    #####: 3398:		  return -1;
        -: 3399:
    #####: 3400:		++p;
    #####: 3401:		line.alloc -= p - line.active;
    #####: 3402:		line.length -= p - line.active;
    #####: 3403:		line.active += p - line.active;
        -: 3404:
        -: 3405:		/* reset to start next cycle without reading a new line: */
    #####: 3406:		cur_cmd = vec->v;
    #####: 3407:		continue;
        -: 3408:	      }
        -: 3409:
    #####: 3410:	    case 'e': {
        -: 3411:#ifdef HAVE_POPEN
        -: 3412:	      FILE *pipe;
        -: 3413:	      int cmd_length = cur_cmd->x.cmd_txt.text_length;
        -: 3414:	      if (s_accum.alloc == 0)
        -: 3415:		line_init(&s_accum, INITIAL_BUFFER_SIZE);
        -: 3416:	      s_accum.length = 0;
        -: 3417:
        -: 3418:	      if (!cmd_length)
        -: 3419:		{
        -: 3420:		  str_append (&line, "", 1);
        -: 3421:		  pipe = popen(line.active, "r");
        -: 3422:		} 
        -: 3423:	      else
        -: 3424:		{
        -: 3425:		  cur_cmd->x.cmd_txt.text[cmd_length - 1] = 0;
        -: 3426:		  pipe = popen(cur_cmd->x.cmd_txt.text, "r");
        -: 3427:                  output_missing_newline(&output_file);
        -: 3428:		}
        -: 3429:
        -: 3430:	      if (pipe != NULL) 
        -: 3431:		{
        -: 3432:		  while (!feof (pipe)) 
        -: 3433:		    {
        -: 3434:		      char buf[4096];
        -: 3435:		      int n = fread (buf, sizeof(char), 4096, pipe);
        -: 3436:		      if (n > 0)
        -: 3437:			if (!cmd_length)
        -: 3438:			  str_append(&s_accum, buf, n);
        -: 3439:			else
        -: 3440:			  ck_fwrite(buf, 1, n, output_file.fp);
        -: 3441:		    }
        -: 3442:		  
        -: 3443:		  pclose (pipe);
        -: 3444:		  if (!cmd_length)
        -: 3445:		    {
        -: 3446:		      /* Store into pattern space for plain `e' commands */
        -: 3447:		      if (s_accum.length &&
        -: 3448:			  s_accum.active[s_accum.length - 1] == '\n')
        -: 3449:			s_accum.length--;
        -: 3450:
        -: 3451:		      /* Exchange line and s_accum.  This can be much
        -: 3452:			 cheaper than copying s_accum.active into line.text
        -: 3453:			 (for huge lines). */
        -: 3454:		      line_exchange(&line, &s_accum);
        -: 3455:		    }
        -: 3456:                  else
        -: 3457:                    flush_output(output_file.fp);
        -: 3458:
        -: 3459:		}
        -: 3460:	      else
        -: 3461:		panic(_("error in subprocess"));
        -: 3462:#else
    #####: 3463:	      panic(_("`e' command not supported"));
call    0 never executed
        -: 3464:#endif
    #####: 3465:	      break;
        -: 3466:	    }
        -: 3467:
    #####: 3468:	    case 'g':
    #####: 3469:	      line_copy(&hold, &line);
call    0 never executed
    #####: 3470:	      break;
        -: 3471:
    #####: 3472:	    case 'G':
    #####: 3473:	      line_append(&hold, &line);
call    0 never executed
    #####: 3474:	      break;
        -: 3475:
    #####: 3476:	    case 'h':
    #####: 3477:	      line_copy(&line, &hold);
call    0 never executed
    #####: 3478:	      break;
        -: 3479:
    #####: 3480:	    case 'H':
    #####: 3481:	      line_append(&line, &hold);
call    0 never executed
    #####: 3482:	      break;
        -: 3483:
    #####: 3484:	    case 'i':
    #####: 3485:	      output_line(cur_cmd->x.cmd_txt.text,
    #####: 3486:			  cur_cmd->x.cmd_txt.text_length - 1,
call    0 never executed
        -: 3487:			  true, &output_file);
    #####: 3488:	      break;
        -: 3489:
      114: 3490:	    case 'l':
     114*: 3491:	      do_list(cur_cmd->x.int_arg == -1
branch  0 taken 0 (fallthrough)
branch  1 taken 114
call    2 returned 114
        -: 3492:		      ? lcmd_out_line_len
        -: 3493:		      : cur_cmd->x.int_arg);
      114: 3494:	      break;
        -: 3495:
    #####: 3496:	    case 'L':
    #####: 3497:              output_missing_newline(&output_file);
call    0 never executed
    #####: 3498:	      fmt(line.active, line.active + line.length,
call    0 never executed
    #####: 3499:		  cur_cmd->x.int_arg == -1
branch  0 never executed
branch  1 never executed
        -: 3500:		  ? lcmd_out_line_len
        -: 3501:		  : cur_cmd->x.int_arg,
        -: 3502:		  output_file.fp);
    #####: 3503:              flush_output(output_file.fp);
call    0 never executed
    #####: 3504:	      break;
        -: 3505:
    #####: 3506:	    case 'n':
    #####: 3507:	      if (!no_default_output)
branch  0 never executed
branch  1 never executed
    #####: 3508:		output_line(line.active, line.length, line.chomped, &output_file);
call    0 never executed
    #####: 3509:	      if (test_eof(input) || !read_pattern_space(input, vec, false))
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 3510:		return -1;
    #####: 3511:	      break;
        -: 3512:
    #####: 3513:	    case 'N':
        -: 3514:#ifndef FAULTY_F_KRM_6
        -: 3515:	      str_append(&line, "\n", 1);
        -: 3516:#else
    #####: 3517:	      str_append(&line, "\n", 0);
call    0 never executed
        -: 3518:#endif
    #####: 3519:              if (test_eof(input) || !read_pattern_space(input, vec, true))
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -: 3520:                {
    #####: 3521:                  line.length--;
    #####: 3522:                  if (posixicity == POSIXLY_EXTENDED && !no_default_output)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3523:                     output_line(line.active, line.length, line.chomped,
call    0 never executed
        -: 3524:                                 &output_file);
    #####: 3525:                  return -1;
        -: 3526:                }
    #####: 3527:	      break;
        -: 3528:
    #####: 3529:	    case 'p':
    #####: 3530:	      output_line(line.active, line.length, line.chomped, &output_file);
call    0 never executed
    #####: 3531:	      break;
        -: 3532:
    #####: 3533:	    case 'P':
        -: 3534:	      {
    #####: 3535:		char *p = memchr(line.active, '\n', line.length);
    #####: 3536:		output_line(line.active, p ? p - line.active : line.length,
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 3537:			    p ? true : line.chomped, &output_file);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 3538:	      }
    #####: 3539:	      break;
        -: 3540:
    #####: 3541:            case 'q':
    #####: 3542:              if (!no_default_output)
branch  0 never executed
branch  1 never executed
    #####: 3543:                output_line(line.active, line.length, line.chomped, &output_file);
call    0 never executed
    #####: 3544:	      dump_append_queue();
call    0 never executed
        -: 3545:
    #####: 3546:	    case 'Q':
    #####: 3547:	      return cur_cmd->x.int_arg == -1 ? 0 : cur_cmd->x.int_arg;
branch  0 never executed
branch  1 never executed
        -: 3548:
    #####: 3549:	    case 'r':
    #####: 3550:	      if (cur_cmd->x.fname)
branch  0 never executed
branch  1 never executed
        -: 3551:		{
    #####: 3552:		  struct append_queue *aq = next_append_slot();
call    0 never executed
    #####: 3553:		  aq->fname = cur_cmd->x.fname;
        -: 3554:		}
    #####: 3555:	      break;
        -: 3556:
    #####: 3557:	    case 'R':
    #####: 3558:	      if (cur_cmd->x.fp && !feof (cur_cmd->x.fp))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 3559:		{
        -: 3560:		  struct append_queue *aq;
        -: 3561:		  size_t buflen;
    #####: 3562:		  char *text = NULL;
        -: 3563:		  int result;
        -: 3564:
    #####: 3565:		  result = ck_getline (&text, &buflen, cur_cmd->x.fp);
call    0 never executed
    #####: 3566:		  if (result != EOF)
branch  0 never executed
branch  1 never executed
        -: 3567:		    {
    #####: 3568:		      aq = next_append_slot();
call    0 never executed
    #####: 3569:		      aq->free = true;
    #####: 3570:		      aq->text = text;
    #####: 3571:		      aq->textlen = result;
        -: 3572:		    }
        -: 3573:		}
    #####: 3574:	      break;
        -: 3575:
      114: 3576:	    case 's':
      114: 3577:	      do_subst(cur_cmd->x.cmd_subst);
call    0 returned 114
      114: 3578:	      break;
        -: 3579:
    #####: 3580:	    case 't':
    #####: 3581:	      if (replaced)
branch  0 never executed
branch  1 never executed
        -: 3582:		{
    #####: 3583:		  replaced = false;
    #####: 3584:		  cur_cmd = vec->v + cur_cmd->x.jump_index;
    #####: 3585:		  continue;
        -: 3586:		}
    #####: 3587:	      break;
        -: 3588:
    #####: 3589:	    case 'T':
    #####: 3590:	      if (!replaced)
branch  0 never executed
branch  1 never executed
        -: 3591:		{
    #####: 3592:		  cur_cmd = vec->v + cur_cmd->x.jump_index;
    #####: 3593:		  continue;
        -: 3594:		}
        -: 3595:	      else
    #####: 3596:		replaced = false;
    #####: 3597:	      break;
        -: 3598:
    #####: 3599:	    case 'w':
    #####: 3600:	      if (cur_cmd->x.fp)
branch  0 never executed
branch  1 never executed
    #####: 3601:		output_line(line.active, line.length,
    #####: 3602:			    line.chomped, cur_cmd->x.outf);
call    0 never executed
    #####: 3603:	      break;
        -: 3604:
    #####: 3605:	    case 'W':
    #####: 3606:	      if (cur_cmd->x.fp)
branch  0 never executed
branch  1 never executed
        -: 3607:	        {
    #####: 3608:		  char *p = memchr(line.active, '\n', line.length);
    #####: 3609:		  output_line(line.active, p ? p - line.active : line.length,
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 3610:			      p ? true : line.chomped, cur_cmd->x.outf);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 3611:	        }
    #####: 3612:	      break;
        -: 3613:
    #####: 3614:	    case 'x':
    #####: 3615:	      line_exchange(&line, &hold);
call    0 never executed
    #####: 3616:	      break;
        -: 3617:
    #####: 3618:	    case 'y':
        -: 3619:	      {
        -: 3620:#ifdef HAVE_MBRTOWC
        -: 3621:               if (mb_cur_max > 1)
        -: 3622:                 {
        -: 3623:                   int idx, prev_idx; /* index in the input line.  */
        -: 3624:                   char **trans;
        -: 3625:                   mbstate_t mbstate;
        -: 3626:                   memset(&mbstate, 0, sizeof(mbstate_t));
        -: 3627:                   for (idx = 0; idx < line.length;)
        -: 3628:                     {
        -: 3629:                       int mbclen, i;
        -: 3630:                       mbclen = MBRLEN (line.active + idx, line.length - idx,
        -: 3631:                                          &mbstate);
        -: 3632:                       /* An invalid sequence, or a truncated multibyte
        -: 3633:                          character.  We treat it as a singlebyte character.
        -: 3634:                       */
        -: 3635:                       if (mbclen == (size_t) -1 || mbclen == (size_t) -2
        -: 3636:                           || mbclen == 0)
        -: 3637:                         mbclen = 1;
        -: 3638:
        -: 3639:                       trans = cur_cmd->x.translatemb;
        -: 3640:                       /* `i' indicate i-th translate pair.  */
        -: 3641:                       for (i = 0; trans[2*i] != NULL; i++)
        -: 3642:                         {
        -: 3643:                           if (strncmp(line.active + idx, trans[2*i], mbclen) == 0)
        -: 3644:                             {
        -: 3645:                               bool move_remain_buffer = false;
        -: 3646:                               int trans_len = strlen(trans[2*i+1]);
        -: 3647:
        -: 3648:                               if (mbclen < trans_len)
        -: 3649:                                 {
        -: 3650:                                   int new_len;
        -: 3651:                                   new_len = line.length + 1 + trans_len - mbclen;
        -: 3652:                                   /* We must extend the line buffer.  */
        -: 3653:                                   if (line.alloc < new_len)
        -: 3654:                                     {
        -: 3655:                                       /* And we must resize the buffer.  */
        -: 3656:                                       resize_line(&line, new_len);
        -: 3657:                                     }
        -: 3658:                                   move_remain_buffer = true;
        -: 3659:                                 }
        -: 3660:                               else if (mbclen > trans_len)
        -: 3661:                                 {
        -: 3662:                                   /* We must truncate the line buffer.  */
        -: 3663:                                   move_remain_buffer = true;
        -: 3664:                                 }
        -: 3665:                               prev_idx = idx;
        -: 3666:                               if (move_remain_buffer)
        -: 3667:                                 {
        -: 3668:                                   int move_len, move_offset;
        -: 3669:                                   char *move_from, *move_to;
        -: 3670:                                   /* Move the remaining with \0.  */
        -: 3671:                                   move_from = line.active + idx + mbclen;
        -: 3672:                                   move_to = line.active + idx + trans_len;
        -: 3673:                                   move_len = line.length + 1 - idx - mbclen;
        -: 3674:                                   move_offset = trans_len - mbclen;
        -: 3675:                                   memmove(move_to, move_from, move_len);
        -: 3676:                                   line.length += move_offset;
        -: 3677:                                   idx += move_offset;
        -: 3678:                                 }
        -: 3679:                               strncpy(line.active + prev_idx, trans[2*i+1],
        -: 3680:                                       trans_len);
        -: 3681:                               break;
        -: 3682:                             }
        -: 3683:                         }
        -: 3684:                       idx += mbclen;
        -: 3685:                     }
        -: 3686:                 }
        -: 3687:               else
        -: 3688:#endif /* HAVE_MBRTOWC */
        -: 3689:                 {
        -: 3690:                   unsigned char *p, *e;
    #####: 3691:                   p = CAST(unsigned char *)line.active;
    #####: 3692:                   for (e=p+line.length; p<e; ++p)
branch  0 never executed
branch  1 never executed
    #####: 3693:                     *p = cur_cmd->x.translate[*p];
        -: 3694:                 }
        -: 3695:	      }
    #####: 3696:	      break;
        -: 3697:
    #####: 3698:	    case '=':
    #####: 3699:              output_missing_newline(&output_file);
call    0 never executed
    #####: 3700:              fprintf(output_file.fp, "%lu\n",
    #####: 3701:                      CAST(unsigned long)input->line_number);
call    0 never executed
    #####: 3702:              flush_output(output_file.fp);
call    0 never executed
    #####: 3703:	      break;
        -: 3704:
    #####: 3705:	    default:
    #####: 3706:	      panic("INTERNAL ERROR: Bad cmd %c", cur_cmd->cmd);
call    0 never executed
        -: 3707:	    }
        -: 3708:	}
        -: 3709:
        -: 3710:#ifdef EXPERIMENTAL_DASH_N_OPTIMIZATION
        -: 3711:      /* If our top-level program consists solely of commands with
        -: 3712:         ADDR_IS_NUM addresses then once we past the last mentioned
        -: 3713:         line we should be able to quit if no_default_output is true,
        -: 3714:         or otherwise quickly copy input to output.  Now whether this
        -: 3715:         optimization is a win or not depends on how cheaply we can
        -: 3716:         implement this for the cases where it doesn't help, as
        -: 3717:         compared against how much time is saved.  One semantic
        -: 3718:         difference (which I think is an improvement) is that *this*
        -: 3719:         version will terminate after printing line two in the script
        -: 3720:         "yes | sed -n 2p". 
        -: 3721:        
        -: 3722:         Don't use this when in-place editing is active, because line
        -: 3723:         numbers restart each time then. */
        -: 3724:      else if (!separate_files)
        -: 3725:	{
        -: 3726:	  if (cur_cmd->a1->addr_type == ADDR_IS_NUM
        -: 3727:	      && (cur_cmd->a2
        -: 3728:		  ? cur_cmd->range_state == RANGE_CLOSED
        -: 3729:		  : cur_cmd->a1->addr_number < input->line_number))
        -: 3730:	    {
        -: 3731:	      /* Skip this address next time */
        -: 3732:	      cur_cmd->addr_bang = !cur_cmd->addr_bang;
        -: 3733:	      cur_cmd->a1->addr_type = ADDR_IS_NULL;
        -: 3734:	      if (cur_cmd->a2)
        -: 3735:		cur_cmd->a2->addr_type = ADDR_IS_NULL;
        -: 3736:
        -: 3737:	      /* can we make an optimization? */
        -: 3738:	      if (cur_cmd->addr_bang)
        -: 3739:		{
        -: 3740:		  if (cur_cmd->cmd == 'b' || cur_cmd->cmd == 't'
        -: 3741:		      || cur_cmd->cmd == 'T' || cur_cmd->cmd == '}')
        -: 3742:		    branches--;
        -: 3743:
        -: 3744:		  cur_cmd->cmd = '#';	/* replace with no-op */
        -: 3745:	          if (branches == 0)
        -: 3746:		    cur_cmd = shrink_program(vec, cur_cmd);
        -: 3747:		  if (!cur_cmd && no_default_output)
        -: 3748:		    return 0;
        -: 3749:		  end_cmd = vec->v + vec->v_length;
        -: 3750:		  if (!cur_cmd)
        -: 3751:		    cur_cmd = end_cmd;
        -: 3752:		  continue;
        -: 3753:		}
        -: 3754:	    }
        -: 3755:	}
        -: 3756:#endif /*EXPERIMENTAL_DASH_N_OPTIMIZATION*/
        -: 3757:
        -: 3758:      /* this is buried down here so that a "continue" statement can skip it */
      228: 3759:      ++cur_cmd;
        -: 3760:    }
        -: 3761:
      114: 3762:    if (!no_default_output)
branch  0 taken 114 (fallthrough)
branch  1 taken 0
      114: 3763:      output_line(line.active, line.length, line.chomped, &output_file);
call    0 returned 114
      114: 3764:    return -1;
        -: 3765:}
        -: 3766:
        -: 3767:
        -: 3768:
        -: 3769:/* Apply the compiled script to all the named files. */
        -: 3770:int
function process_files called 1 returned 100% blocks executed 76%
        1: 3771:process_files(the_program, argv)
        -: 3772:  struct vector *the_program;
        -: 3773:  char **argv;
        -: 3774:{
        -: 3775:  static char dash[] = "-";
        -: 3776:  static char *stdin_argv[2] = { dash, NULL };
        -: 3777:  struct input input;
        -: 3778:  int status;
        -: 3779:
        1: 3780:  line_init(&line, INITIAL_BUFFER_SIZE);
call    0 returned 1
        1: 3781:  line_init(&hold, 0);
call    0 returned 1
        1: 3782:  line_init(&buffer, 0);
call    0 returned 1
        -: 3783:
        -: 3784:#ifdef EXPERIMENTAL_DASH_N_OPTIMIZATION
        -: 3785:  branches = count_branches(the_program);
        -: 3786:#endif /*EXPERIMENTAL_DASH_N_OPTIMIZATION*/
        1: 3787:  input.reset_at_next_file = true;
        1: 3788:  if (argv && *argv)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
branch  2 taken 1 (fallthrough)
branch  3 taken 0
        1: 3789:    input.file_list = argv;
    #####: 3790:  else if (in_place_extension)
branch  0 never executed
branch  1 never executed
    #####: 3791:    panic(_("no input files"));
call    0 never executed
        -: 3792:  else
    #####: 3793:    input.file_list = stdin_argv;
        -: 3794:
        1: 3795:  input.bad_count = 0;
        1: 3796:  input.line_number = 0;
        1: 3797:  input.read_fn = read_always_fail;
        1: 3798:  input.fp = NULL;
        -: 3799:
        1: 3800:  status = EXIT_SUCCESS;
      115: 3801:  while (read_pattern_space(&input, the_program, false))
call    0 returned 115
branch  1 taken 114
branch  2 taken 1 (fallthrough)
        -: 3802:    {
      114: 3803:      status = execute_program(the_program, &input);
call    0 returned 114
      114: 3804:      if (status == -1)
branch  0 taken 114 (fallthrough)
branch  1 taken 0
      114: 3805:	status = EXIT_SUCCESS;
        -: 3806:      else
    #####: 3807:	break;
        -: 3808:    }
        1: 3809:  closedown(&input);
call    0 returned 1
        -: 3810:
        -: 3811:#ifdef DEBUG_LEAKS
        -: 3812:  /* We're about to exit, so these free()s are redundant.
        -: 3813:     But if we're running under a memory-leak detecting
        -: 3814:     implementation of malloc(), we want to explicitly
        -: 3815:     deallocate in order to avoid extraneous noise from
        -: 3816:     the allocator. */
        -: 3817:  release_append_queue();
        -: 3818:  FREE(buffer.text);
        -: 3819:  FREE(hold.text);
        -: 3820:  FREE(line.text);
        -: 3821:  FREE(s_accum.text);
        -: 3822:#endif /*DEBUG_LEAKS*/
        -: 3823:
        1: 3824:  if (input.bad_count)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 3825:    status = 2;
        -: 3826:
        1: 3827:  return status;
        -: 3828:}
        -: 3829:/* `L' command implementation for GNU sed, based on GNU fmt 1.22.
        -: 3830:   Copyright (C) 1994, 1995, 1996, 2002, 2003 Free Software Foundation, Inc.
        -: 3831:
        -: 3832:   This program is free software; you can redistribute it and/or modify
        -: 3833:   it under the terms of the GNU General Public License as published by
        -: 3834:   the Free Software Foundation; either version 2, or (at your option)
        -: 3835:   any later version.
        -: 3836:
        -: 3837:   This program is distributed in the hope that it will be useful,
        -: 3838:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 3839:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 3840:   GNU General Public License for more details.
        -: 3841:
        -: 3842:   You should have received a copy of the GNU General Public License
        -: 3843:   along with this program; if not, write to the Free Software Foundation,
        -: 3844:   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
        -: 3845:
        -: 3846:/* GNU fmt was written by Ross Paterson <rap@doc.ic.ac.uk>.  */
        -: 3847:
        -: 3848:#include <stdio.h>
        -: 3849:#include <ctype.h>
        -: 3850:#include <sys/types.h>
        -: 3851:
        -: 3852:#if HAVE_LIMITS_H
        -: 3853:# include <limits.h>
        -: 3854:#endif
        -: 3855:
        -: 3856:#ifndef UINT_MAX
        -: 3857:# define UINT_MAX ((unsigned int) ~(unsigned int) 0)
        -: 3858:#endif
        -: 3859:
        -: 3860:#ifndef INT_MAX
        -: 3861:# define INT_MAX ((int) (UINT_MAX >> 1))
        -: 3862:#endif
        -: 3863:
        -: 3864:/* The following parameters represent the program's idea of what is
        -: 3865:   "best".  Adjust to taste, subject to the caveats given.  */
        -: 3866:
        -: 3867:/* Prefer lines to be LEEWAY % shorter than the maximum width, giving
        -: 3868:   room for optimization.  */
        -: 3869:#define	LEEWAY	7
        -: 3870:
        -: 3871:/* Costs and bonuses are expressed as the equivalent departure from the
        -: 3872:   optimal line length, multiplied by 10.  e.g. assigning something a
        -: 3873:   cost of 50 means that it is as bad as a line 5 characters too short
        -: 3874:   or too long.  The definition of SHORT_COST(n) should not be changed.
        -: 3875:   However, EQUIV(n) may need tuning.  */
        -: 3876:
        -: 3877:typedef long COST;
        -: 3878:
        -: 3879:#define	MAXCOST	(~(((unsigned long) 1) << (8 * sizeof (COST) -1)))
        -: 3880:
        -: 3881:#define	SQR(n)		((n) * (n))
        -: 3882:#define	EQUIV(n)	SQR ((COST) (n))
        -: 3883:
        -: 3884:/* Cost of a filled line n chars longer or shorter than best_width.  */
        -: 3885:#define	SHORT_COST(n)	EQUIV ((n) * 10)
        -: 3886:
        -: 3887:/* Cost of the difference between adjacent filled lines.  */
        -: 3888:#define	RAGGED_COST(n)	(SHORT_COST (n) / 2)
        -: 3889:
        -: 3890:/* Basic cost per line.  */
        -: 3891:#define	LINE_COST	EQUIV (70)
        -: 3892:
        -: 3893:/* Cost of breaking a line after the first word of a sentence, where
        -: 3894:   the length of the word is N.  */
        -: 3895:#define	WIDOW_COST(n)	(EQUIV (200) / ((n) + 2))
        -: 3896:
        -: 3897:/* Cost of breaking a line before the last word of a sentence, where
        -: 3898:   the length of the word is N.  */
        -: 3899:#define	ORPHAN_COST(n)	(EQUIV (150) / ((n) + 2))
        -: 3900:
        -: 3901:/* Bonus for breaking a line at the end of a sentence.  */
        -: 3902:#define	SENTENCE_BONUS	EQUIV (50)
        -: 3903:
        -: 3904:/* Cost of breaking a line after a period not marking end of a sentence.
        -: 3905:   With the definition of sentence we are using (borrowed from emacs, see
        -: 3906:   get_line()) such a break would then look like a sentence break.  Hence
        -: 3907:   we assign a very high cost -- it should be avoided unless things are
        -: 3908:   really bad.  */
        -: 3909:#define	NOBREAK_COST	EQUIV (600)
        -: 3910:
        -: 3911:/* Bonus for breaking a line before open parenthesis.  */
        -: 3912:#define	PAREN_BONUS	EQUIV (40)
        -: 3913:
        -: 3914:/* Bonus for breaking a line after other punctuation.  */
        -: 3915:#define	PUNCT_BONUS	EQUIV(40)
        -: 3916:
        -: 3917:/* Credit for breaking a long paragraph one line later.  */
        -: 3918:#define	LINE_CREDIT	EQUIV(3)
        -: 3919:
        -: 3920:/* Size of paragraph buffer in words.  Longer paragraphs are handled
        -: 3921:   neatly (cf. flush_paragraph()), so there's little to gain by making
        -: 3922:   these larger.  */
        -: 3923:#define	MAXWORDS	1000
        -: 3924:
        -: 3925:#define GETC()          (parabuf == end_of_parabuf ? EOF : *parabuf++)
        -: 3926:
        -: 3927:/* Extra ctype(3)-style macros.  */
        -: 3928:
        -: 3929:#define	isopen(c)	(strchr ("([`'\"", (c)) != NULL)
        -: 3930:#define	isclose(c)	(strchr (")]'\"", (c)) != NULL)
        -: 3931:#define	isperiod(c)	(strchr (".?!", (c)) != NULL)
        -: 3932:
        -: 3933:/* Size of a tab stop, for expansion on input and re-introduction on
        -: 3934:   output.  */
        -: 3935:#define	TABWIDTH	8
        -: 3936:
        -: 3937:/* Word descriptor structure.  */
        -: 3938:
        -: 3939:typedef struct Word WORD;
        -: 3940:
        -: 3941:struct Word
        -: 3942:  {
        -: 3943:
        -: 3944:    /* Static attributes determined during input.  */
        -: 3945:
        -: 3946:    const char *text;		/* the text of the word */
        -: 3947:    short length;		/* length of this word */
        -: 3948:    short space;		/* the size of the following space */
        -: 3949:    unsigned paren:1;		/* starts with open paren */
        -: 3950:    unsigned period:1;		/* ends in [.?!])* */
        -: 3951:    unsigned punct:1;		/* ends in punctuation */
        -: 3952:    unsigned final:1;		/* end of sentence */
        -: 3953:
        -: 3954:    /* The remaining fields are computed during the optimization.  */
        -: 3955:
        -: 3956:    short line_length;		/* length of the best line starting here */
        -: 3957:    COST best_cost;		/* cost of best paragraph starting here */
        -: 3958:    WORD *next_break;		/* break which achieves best_cost */
        -: 3959:  };
        -: 3960:
        -: 3961:/* Forward declarations.  */
        -: 3962:
        -: 3963:static bool get_paragraph P_ ((void));
        -: 3964:static int get_line P_ ((int c));
        -: 3965:static int get_space P_ ((int c));
        -: 3966:static int copy_rest P_ ((int c));
        -: 3967:static bool same_para P_ ((int c));
        -: 3968:static void flush_paragraph P_ ((void));
        -: 3969:static void fmt_paragraph P_ ((void));
        -: 3970:static void check_punctuation P_ ((WORD *w));
        -: 3971:static COST base_cost P_ ((WORD *this));
        -: 3972:static COST line_cost P_ ((WORD *next, int len));
        -: 3973:static void put_paragraph P_ ((WORD *finish));
        -: 3974:static void put_line P_ ((WORD *w, int indent));
        -: 3975:static void put_word P_ ((WORD *w));
        -: 3976:static void put_space P_ ((int space));
        -: 3977:
        -: 3978:/* Option values.  */
        -: 3979:
        -: 3980:/* User-supplied maximum line width (default WIDTH).  The only output
        -: 3981:   lines
        -: 3982:   longer than this will each comprise a single word.  */
        -: 3983:static int max_width;
        -: 3984:
        -: 3985:/* Space for the paragraph text.  */
        -: 3986:static const char *parabuf;
        -: 3987:
        -: 3988:/* End of space for the paragraph text.  */
        -: 3989:static const char *end_of_parabuf;
        -: 3990:
        -: 3991:/* The file on which we output */
        -: 3992:static FILE *outfile;
        -: 3993:
        -: 3994:/* Values derived from the option values.  */
        -: 3995:
        -: 3996:/* The preferred width of text lines, set to LEEWAY % less than max_width.  */
        -: 3997:static int best_width;
        -: 3998:
        -: 3999:/* Dynamic variables.  */
        -: 4000:
        -: 4001:/* Start column of the character most recently read from the input file.  */
        -: 4002:static int in_column;
        -: 4003:
        -: 4004:/* Start column of the next character to be written to stdout.  */
        -: 4005:static int out_column;
        -: 4006:
        -: 4007:/* The words of a paragraph -- longer paragraphs are handled neatly
        -: 4008:   (cf. flush_paragraph()).  */
        -: 4009:static WORD words[MAXWORDS];
        -: 4010:
        -: 4011:/* A pointer into the above word array, indicating the first position
        -: 4012:   after the last complete word.  Sometimes it will point at an incomplete
        -: 4013:   word.  */
        -: 4014:static WORD *word_limit;
        -: 4015:
        -: 4016:/* Indentation of the first line of the current paragraph.  */
        -: 4017:static int first_indent;
        -: 4018:
        -: 4019:/* Indentation of other lines of the current paragraph */
        -: 4020:static int other_indent;
        -: 4021:
        -: 4022:/* The last character read from the input file.  */
        -: 4023:static int next_char;
        -: 4024:
        -: 4025:/* If nonzero, the length of the last line output in the current
        -: 4026:   paragraph, used to charge for raggedness at the split point for long
        -: 4027:   paragraphs chosen by fmt_paragraph().  */
        -: 4028:static int last_line_length;
        -: 4029:
        -: 4030:/* read file F and send formatted output to stdout.  */
        -: 4031:
        -: 4032:void
function fmt called 0 returned 0% blocks executed 0%
    #####: 4033:fmt (const char *line, const char *line_end, int max_length, FILE *output_file)
        -: 4034:{
    #####: 4035:  parabuf = line;
    #####: 4036:  end_of_parabuf = line_end;
    #####: 4037:  outfile = output_file;
        -: 4038:
    #####: 4039:  max_width = max_length;
    #####: 4040:  best_width = max_width * (201 - 2 * LEEWAY) / 200;
        -: 4041:
    #####: 4042:  in_column = 0;
    #####: 4043:  other_indent = 0;
    #####: 4044:  next_char = GETC();
branch  0 never executed
branch  1 never executed
    #####: 4045:  while (get_paragraph ())
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 4046:    {
    #####: 4047:      fmt_paragraph ();
call    0 never executed
    #####: 4048:      put_paragraph (word_limit);
call    0 never executed
        -: 4049:    }
    #####: 4050:}
        -: 4051:
        -: 4052:/* Read a paragraph from input file F.  A paragraph consists of a
        -: 4053:   maximal number of non-blank (excluding any prefix) lines
        -: 4054:   with the same indent.
        -: 4055:
        -: 4056:   Return false if end-of-file was encountered before the start of a
        -: 4057:   paragraph, else true.  */
        -: 4058:
        -: 4059:static bool
function get_paragraph called 0 returned 0% blocks executed 0%
    #####: 4060:get_paragraph ()
        -: 4061:{
        -: 4062:  register int c;
        -: 4063:
    #####: 4064:  last_line_length = 0;
    #####: 4065:  c = next_char;
        -: 4066:
        -: 4067:  /* Scan (and copy) blank lines, and lines not introduced by the prefix.  */
        -: 4068:
    #####: 4069:  while (c == '\n' || c == EOF)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 4070:    {
    #####: 4071:      c = copy_rest (c);
call    0 never executed
    #####: 4072:      if (c == EOF)
branch  0 never executed
branch  1 never executed
        -: 4073:	{
    #####: 4074:	  next_char = EOF;
    #####: 4075:	  return false;
        -: 4076:	}
    #####: 4077:      putc ('\n', outfile);
call    0 never executed
    #####: 4078:      c = GETC();
branch  0 never executed
branch  1 never executed
        -: 4079:    }
        -: 4080:
        -: 4081:  /* Got a suitable first line for a paragraph.  */
        -: 4082:
    #####: 4083:  first_indent = in_column;
    #####: 4084:  word_limit = words;
    #####: 4085:  c = get_line (c);
call    0 never executed
        -: 4086:
        -: 4087:  /* Read rest of paragraph.  */
        -: 4088:
    #####: 4089:  other_indent = in_column;
    #####: 4090:  while (same_para (c) && in_column == other_indent)
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 4091:    c = get_line (c);
call    0 never executed
        -: 4092:
    #####: 4093:  (word_limit - 1)->period = (word_limit - 1)->final = true;
    #####: 4094:  next_char = c;
    #####: 4095:  return true;
        -: 4096:}
        -: 4097:
        -: 4098:/* Copy to the output a blank line.  In the latter, C is \n or EOF.
        -: 4099:   Return the character (\n or EOF) ending the line.  */
        -: 4100:
        -: 4101:static int
function copy_rest called 0 returned 0% blocks executed 0%
    #####: 4102:copy_rest (register int c)
        -: 4103:{
    #####: 4104:  out_column = 0;
    #####: 4105:  while (c != '\n' && c != EOF)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 4106:    {
    #####: 4107:      putc (c, outfile);
call    0 never executed
    #####: 4108:      c = GETC();
branch  0 never executed
branch  1 never executed
        -: 4109:    }
    #####: 4110:  return c;
        -: 4111:}
        -: 4112:
        -: 4113:/* Return true if a line whose first non-blank character after the
        -: 4114:   prefix (if any) is C could belong to the current paragraph,
        -: 4115:   otherwise false.  */
        -: 4116:
        -: 4117:static bool
function same_para called 0 returned 0% blocks executed 0%
    #####: 4118:same_para (register int c)
        -: 4119:{
    #####: 4120:  return (c != '\n' && c != EOF);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 4121:}
        -: 4122:
        -: 4123:/* Read a line from the input data given first non-blank character C
        -: 4124:   after the prefix, and the following indent, and break it into words.
        -: 4125:   A word is a maximal non-empty string of non-white characters.  A word
        -: 4126:   ending in [.?!]["')\]]* and followed by end-of-line or at least two
        -: 4127:   spaces ends a sentence, as in emacs.
        -: 4128:
        -: 4129:   Return the first non-blank character of the next line.  */
        -: 4130:
        -: 4131:static int
function get_line called 0 returned 0% blocks executed 0%
    #####: 4132:get_line (register int c)
        -: 4133:{
        -: 4134:  int start;
        -: 4135:  register WORD *end_of_word;
        -: 4136:
    #####: 4137:  end_of_word = &words[MAXWORDS - 2];
        -: 4138:
        -: 4139:  do
        -: 4140:    {				/* for each word in a line */
        -: 4141:
        -: 4142:      /* Scan word.  */
        -: 4143:
    #####: 4144:      word_limit->text = parabuf - 1;
        -: 4145:      do
    #####: 4146:	c = GETC();
branch  0 never executed
branch  1 never executed
    #####: 4147:      while (c != EOF && !ISSPACE (c));
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4148:      word_limit->length = parabuf - word_limit->text - (c != EOF);
    #####: 4149:      in_column += word_limit->length;
        -: 4150:
    #####: 4151:      check_punctuation (word_limit);
call    0 never executed
        -: 4152:
        -: 4153:      /* Scan inter-word space.  */
        -: 4154:
    #####: 4155:      start = in_column;
    #####: 4156:      c = get_space (c);
call    0 never executed
    #####: 4157:      word_limit->space = in_column - start;
    #####: 4158:      word_limit->final = (c == EOF
    #####: 4159:			   || (word_limit->period
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4160:			       && (c == '\n' || word_limit->space > 1)));
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4161:      if (c == '\n' || c == EOF)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4162:	word_limit->space = word_limit->final ? 2 : 1;
branch  0 never executed
branch  1 never executed
    #####: 4163:      if (word_limit == end_of_word)
branch  0 never executed
branch  1 never executed
    #####: 4164:	flush_paragraph ();
call    0 never executed
    #####: 4165:      word_limit++;
    #####: 4166:      if (c == EOF)
branch  0 never executed
branch  1 never executed
        -: 4167:	{
    #####: 4168:	  in_column = first_indent;
    #####: 4169:	  return EOF;
        -: 4170:	}
        -: 4171:    }
    #####: 4172:  while (c != '\n');
branch  0 never executed
branch  1 never executed
        -: 4173:
    #####: 4174:  in_column = 0;
    #####: 4175:  c = GETC();
branch  0 never executed
branch  1 never executed
    #####: 4176:  return get_space (c);
call    0 never executed
        -: 4177:}
        -: 4178:
        -: 4179:/* Read blank characters from the input data, starting with C, and keeping
        -: 4180:   in_column up-to-date.  Return first non-blank character.  */
        -: 4181:
        -: 4182:static int
function get_space called 0 returned 0% blocks executed 0%
    #####: 4183:get_space (register int c)
        -: 4184:{
        -: 4185:  for (;;)
        -: 4186:    {
    #####: 4187:      if (c == ' ')
branch  0 never executed
branch  1 never executed
    #####: 4188:	in_column++;
    #####: 4189:      else if (c == '\t')
branch  0 never executed
branch  1 never executed
    #####: 4190:	in_column = (in_column / TABWIDTH + 1) * TABWIDTH;
        -: 4191:      else
    #####: 4192:	return c;
    #####: 4193:      c = GETC();
branch  0 never executed
branch  1 never executed
        -: 4194:    }
        -: 4195:}
        -: 4196:
        -: 4197:/* Set extra fields in word W describing any attached punctuation.  */
        -: 4198:
        -: 4199:static void
function check_punctuation called 0 returned 0% blocks executed 0%
    #####: 4200:check_punctuation (register WORD *w)
        -: 4201:{
        -: 4202:  register const char *start, *finish;
        -: 4203:
    #####: 4204:  start = w->text;
    #####: 4205:  finish = start + (w->length - 1);
    #####: 4206:  w->paren = isopen (*start);
    #####: 4207:  w->punct = ISPUNCT (*finish);
    #####: 4208:  while (isclose (*finish) && finish > start)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4209:    finish--;
    #####: 4210:  w->period = isperiod (*finish);
    #####: 4211:}
        -: 4212:
        -: 4213:/* Flush part of the paragraph to make room.  This function is called on
        -: 4214:   hitting the limit on the number of words or characters.  */
        -: 4215:
        -: 4216:static void
function flush_paragraph called 0 returned 0% blocks executed 0%
    #####: 4217:flush_paragraph (void)
        -: 4218:{
        -: 4219:  WORD *split_point;
        -: 4220:  register WORD *w;
        -: 4221:  COST best_break;
        -: 4222:
        -: 4223:  /* - format what you have so far as a paragraph,
        -: 4224:     - find a low-cost line break near the end,
        -: 4225:     - output to there,
        -: 4226:     - make that the start of the paragraph.  */
        -: 4227:
    #####: 4228:  fmt_paragraph ();
call    0 never executed
        -: 4229:
        -: 4230:  /* Choose a good split point.  */
        -: 4231:
    #####: 4232:  split_point = word_limit;
    #####: 4233:  best_break = MAXCOST;
    #####: 4234:  for (w = words->next_break; w != word_limit; w = w->next_break)
branch  0 never executed
branch  1 never executed
        -: 4235:    {
    #####: 4236:      if (w->best_cost - w->next_break->best_cost < best_break)
branch  0 never executed
branch  1 never executed
        -: 4237:	{
    #####: 4238:	  split_point = w;
    #####: 4239:	  best_break = w->best_cost - w->next_break->best_cost;
        -: 4240:	}
    #####: 4241:      if (best_break <= MAXCOST - LINE_CREDIT)
branch  0 never executed
branch  1 never executed
    #####: 4242:	best_break += LINE_CREDIT;
        -: 4243:    }
    #####: 4244:  put_paragraph (split_point);
call    0 never executed
        -: 4245:
        -: 4246:  /* Copy words from split_point down to word -- we use memmove because
        -: 4247:     the source and target may overlap.  */
        -: 4248:
    #####: 4249:  memmove ((char *) words, (char *) split_point,
    #####: 4250:	 (word_limit - split_point + 1) * sizeof (WORD));
    #####: 4251:  word_limit -= split_point - words;
    #####: 4252:}
        -: 4253:
        -: 4254:/* Compute the optimal formatting for the whole paragraph by computing
        -: 4255:   and remembering the optimal formatting for each suffix from the empty
        -: 4256:   one to the whole paragraph.  */
        -: 4257:
        -: 4258:static void
function fmt_paragraph called 0 returned 0% blocks executed 0%
    #####: 4259:fmt_paragraph (void)
        -: 4260:{
        -: 4261:  register WORD *start, *w;
        -: 4262:  register int len;
        -: 4263:  register COST wcost, best;
        -: 4264:  int saved_length;
        -: 4265:
    #####: 4266:  word_limit->best_cost = 0;
    #####: 4267:  saved_length = word_limit->length;
    #####: 4268:  word_limit->length = max_width;	/* sentinel */
        -: 4269:
    #####: 4270:  for (start = word_limit - 1; start >= words; start--)
branch  0 never executed
branch  1 never executed
        -: 4271:    {
    #####: 4272:      best = MAXCOST;
    #####: 4273:      len = start == words ? first_indent : other_indent;
branch  0 never executed
branch  1 never executed
        -: 4274:
        -: 4275:      /* At least one word, however long, in the line.  */
        -: 4276:
    #####: 4277:      w = start;
    #####: 4278:      len += w->length;
        -: 4279:      do
        -: 4280:	{
    #####: 4281:	  w++;
        -: 4282:
        -: 4283:	  /* Consider breaking before w.  */
        -: 4284:
    #####: 4285:	  wcost = line_cost (w, len) + w->best_cost;
call    0 never executed
    #####: 4286:	  if (start == words && last_line_length > 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4287:	    wcost += RAGGED_COST (len - last_line_length);
    #####: 4288:	  if (wcost < best)
branch  0 never executed
branch  1 never executed
        -: 4289:	    {
    #####: 4290:	      best = wcost;
    #####: 4291:	      start->next_break = w;
    #####: 4292:	      start->line_length = len;
        -: 4293:	    }
    #####: 4294:	  len += (w - 1)->space + w->length;	/* w > start >= words */
        -: 4295:	}
    #####: 4296:      while (len < max_width);
branch  0 never executed
branch  1 never executed
    #####: 4297:      start->best_cost = best + base_cost (start);
call    0 never executed
        -: 4298:    }
        -: 4299:
    #####: 4300:  word_limit->length = saved_length;
    #####: 4301:}
        -: 4302:
        -: 4303:/* Return the constant component of the cost of breaking before the
        -: 4304:   word THIS.  */
        -: 4305:
        -: 4306:static COST
function base_cost called 0 returned 0% blocks executed 0%
    #####: 4307:base_cost (register WORD *this)
        -: 4308:{
        -: 4309:  register COST cost;
        -: 4310:
    #####: 4311:  cost = LINE_COST;
        -: 4312:
    #####: 4313:  if (this > words)
branch  0 never executed
branch  1 never executed
        -: 4314:    {
    #####: 4315:      if ((this - 1)->period)
branch  0 never executed
branch  1 never executed
        -: 4316:	{
    #####: 4317:	  if ((this - 1)->final)
branch  0 never executed
branch  1 never executed
    #####: 4318:	    cost -= SENTENCE_BONUS;
        -: 4319:	  else
    #####: 4320:	    cost += NOBREAK_COST;
        -: 4321:	}
    #####: 4322:      else if ((this - 1)->punct)
branch  0 never executed
branch  1 never executed
    #####: 4323:	cost -= PUNCT_BONUS;
    #####: 4324:      else if (this > words + 1 && (this - 2)->final)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4325:	cost += WIDOW_COST ((this - 1)->length);
        -: 4326:    }
        -: 4327:
    #####: 4328:  if (this->paren)
branch  0 never executed
branch  1 never executed
    #####: 4329:    cost -= PAREN_BONUS;
    #####: 4330:  else if (this->final)
branch  0 never executed
branch  1 never executed
    #####: 4331:    cost += ORPHAN_COST (this->length);
        -: 4332:
    #####: 4333:  return cost;
        -: 4334:}
        -: 4335:
        -: 4336:/* Return the component of the cost of breaking before word NEXT that
        -: 4337:   depends on LEN, the length of the line beginning there.  */
        -: 4338:
        -: 4339:static COST
function line_cost called 0 returned 0% blocks executed 0%
    #####: 4340:line_cost (register WORD *next, register int len)
        -: 4341:{
        -: 4342:  register int n;
        -: 4343:  register COST cost;
        -: 4344:
    #####: 4345:  if (next == word_limit)
branch  0 never executed
branch  1 never executed
    #####: 4346:    return 0;
    #####: 4347:  n = best_width - len;
    #####: 4348:  cost = SHORT_COST (n);
    #####: 4349:  if (next->next_break != word_limit)
branch  0 never executed
branch  1 never executed
        -: 4350:    {
    #####: 4351:      n = len - next->line_length;
    #####: 4352:      cost += RAGGED_COST (n);
        -: 4353:    }
    #####: 4354:  return cost;
        -: 4355:}
        -: 4356:
        -: 4357:/* Output to stdout a paragraph from word up to (but not including)
        -: 4358:   FINISH, which must be in the next_break chain from word.  */
        -: 4359:
        -: 4360:static void
function put_paragraph called 0 returned 0% blocks executed 0%
    #####: 4361:put_paragraph (register WORD *finish)
        -: 4362:{
        -: 4363:  register WORD *w;
        -: 4364:
    #####: 4365:  put_line (words, first_indent);
call    0 never executed
    #####: 4366:  for (w = words->next_break; w != finish; w = w->next_break)
branch  0 never executed
branch  1 never executed
    #####: 4367:    put_line (w, other_indent);
call    0 never executed
    #####: 4368:}
        -: 4369:
        -: 4370:/* Output to stdout the line beginning with word W, beginning in column
        -: 4371:   INDENT, including the prefix (if any).  */
        -: 4372:
        -: 4373:static void
function put_line called 0 returned 0% blocks executed 0%
    #####: 4374:put_line (register WORD *w, int indent)
        -: 4375:{
        -: 4376:  register WORD *endline;
    #####: 4377:  out_column = 0;
    #####: 4378:  put_space (indent);
call    0 never executed
        -: 4379:
    #####: 4380:  endline = w->next_break - 1;
    #####: 4381:  for (; w != endline; w++)
branch  0 never executed
branch  1 never executed
        -: 4382:    {
    #####: 4383:      put_word (w);
call    0 never executed
    #####: 4384:      put_space (w->space);
call    0 never executed
        -: 4385:    }
    #####: 4386:  put_word (w);
call    0 never executed
    #####: 4387:  last_line_length = out_column;
    #####: 4388:  putc ('\n', outfile);
call    0 never executed
    #####: 4389:}
        -: 4390:
        -: 4391:/* Output to stdout the word W.  */
        -: 4392:
        -: 4393:static void
function put_word called 0 returned 0% blocks executed 0%
    #####: 4394:put_word (register WORD *w)
        -: 4395:{
        -: 4396:  register const char *s;
        -: 4397:  register int n;
        -: 4398:
    #####: 4399:  s = w->text;
    #####: 4400:  for (n = w->length; n != 0; n--)
branch  0 never executed
branch  1 never executed
    #####: 4401:    putc (*s++, outfile);
call    0 never executed
    #####: 4402:  out_column += w->length;
    #####: 4403:}
        -: 4404:
        -: 4405:/* Output to stdout SPACE spaces, or equivalent tabs.  */
        -: 4406:
        -: 4407:static void
function put_space called 0 returned 0% blocks executed 0%
    #####: 4408:put_space (int space)
        -: 4409:{
    #####: 4410:  out_column += space;
    #####: 4411:  while (space--)
branch  0 never executed
branch  1 never executed
    #####: 4412:    putc (' ', outfile);
call    0 never executed
    #####: 4413:}
        -: 4414:/*  Functions from hack's utils library.
        -: 4415:    Copyright (C) 1989, 1990, 1991, 1998, 1999, 2003
        -: 4416:    Free Software Foundation, Inc.
        -: 4417:
        -: 4418:    This program is free software; you can redistribute it and/or modify
        -: 4419:    it under the terms of the GNU General Public License as published by
        -: 4420:    the Free Software Foundation; either version 2, or (at your option)
        -: 4421:    any later version.
        -: 4422:
        -: 4423:    This program is distributed in the hope that it will be useful,
        -: 4424:    but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 4425:    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 4426:    GNU General Public License for more details.
        -: 4427:
        -: 4428:    You should have received a copy of the GNU General Public License
        -: 4429:    along with this program; if not, write to the Free Software
        -: 4430:    Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA. */
        -: 4431:
        -: 4432:#include "config.h"
        -: 4433:
        -: 4434:#include <stdio.h>
        -: 4435:
        -: 4436:#include <errno.h>
        -: 4437:#ifndef errno
        -: 4438:  extern int errno;
        -: 4439:#endif
        -: 4440:
        -: 4441:#ifdef HAVE_STRINGS_H
        -: 4442:# include <strings.h>
        -: 4443:#else
        -: 4444:# include <string.h>
        -: 4445:#endif /* HAVE_STRINGS_H */
        -: 4446:
        -: 4447:#ifdef HAVE_STDLIB_H
        -: 4448:# include <stdlib.h>
        -: 4449:#endif /* HAVE_STDLIB_H */
        -: 4450:
        -: 4451:#include "utils.h"
        -: 4452:
        -: 4453:const char *myname;
        -: 4454:
        -: 4455:/* Store information about files opened with ck_fopen
        -: 4456:   so that error messages from ck_fread, ck_fwrite, etc. can print the
        -: 4457:   name of the file that had the error */
        -: 4458:
        -: 4459:struct open_file
        -: 4460:  {
        -: 4461:    FILE *fp;
        -: 4462:    char *name;
        -: 4463:    struct open_file *link;
        -: 4464:    unsigned temp : 1;
        -: 4465:  };
        -: 4466:
        -: 4467:static struct open_file *open_files = NULL;
        -: 4468:static void do_ck_fclose P_((FILE *fp));
        -: 4469:
        -: 4470:/* Print an error message and exit */
        -: 4471:#if !defined __STDC__ || !(__STDC__-0)
        -: 4472:# include <varargs.h>
        -: 4473:# define VSTART(l,a)	va_start(l)
        -: 4474:# define stderr stdout
        -: 4475:void
        -: 4476:panic(str, va_alist)
        -: 4477:  char *str;
        -: 4478:  va_dcl
        -: 4479:#else /*__STDC__*/
        -: 4480:# include <stdarg.h>
        -: 4481:# define VSTART(l,a)	va_start(l, a)
        -: 4482:
        -: 4483:/*
        -: 4484:  More non-determinism
        -: 4485:  SIR July 2006 Kyle R. Murphy
        -: 4486:*/
        -: 4487:# define stderr stdout
        -: 4488:void
function panic called 1 returned 0% blocks executed 43%
        1: 4489:panic(const char *str, ...)
        -: 4490:#endif /* __STDC__ */
        -: 4491:{
        -: 4492:  va_list iggy;
        -: 4493:
        1: 4494:  fprintf(stderr, "%s: ", myname);
call    0 returned 1
        1: 4495:  VSTART(iggy, str);
        -: 4496:#ifndef HAVE_VPRINTF
        -: 4497:# ifndef HAVE_DOPRNT
        -: 4498:  fputs(str, stderr);	/* not great, but perhaps better than nothing... */
        -: 4499:# else /* HAVE_DOPRNT */
        -: 4500:  _doprnt(str, &iggy, stderr);
        -: 4501:# endif /* HAVE_DOPRNT */
        -: 4502:#else /* HAVE_VFPRINTF */
        1: 4503:  vfprintf(stderr, str, iggy);
call    0 returned 1
        -: 4504:#endif /* HAVE_VFPRINTF */
        1: 4505:  va_end(iggy);
        1: 4506:  putc('\n', stderr);
call    0 returned 1
        -: 4507:
        -: 4508:  /* Unlink the temporary files.  */
        1: 4509:  while (open_files)
branch  0 taken 0
branch  1 taken 1 (fallthrough)
        -: 4510:    {
    #####: 4511:      if (open_files->temp)
branch  0 never executed
branch  1 never executed
        -: 4512:	{
    #####: 4513:	  int fd = fileno (open_files->fp);
call    0 never executed
    #####: 4514:	  fclose (open_files->fp);
call    0 never executed
    #####: 4515:	  errno = 0;
    #####: 4516:	  unlink (open_files->name);
call    0 never executed
    #####: 4517:          if (errno != 0)
branch  0 never executed
branch  1 never executed
    #####: 4518:            fprintf (stderr, _("cannot remove %s: %s"), open_files->name, strerror (errno));
call    0 never executed
call    1 never executed
        -: 4519:	}
        -: 4520:
    #####: 4521:      open_files = open_files->link;
        -: 4522:    }
        -: 4523:
        1: 4524:  exit(4);
        -: 4525:}
        -: 4526:
        -: 4527:
        -: 4528:/* Internal routine to get a filename from open_files */
        -: 4529:static const char *utils_fp_name P_((FILE *fp));
        -: 4530:static const char *
function utils_fp_name called 1 returned 100% blocks executed 46%
        1: 4531:utils_fp_name(fp)
        -: 4532:  FILE *fp;
        -: 4533:{
        -: 4534:  struct open_file *p;
        -: 4535:
       1*: 4536:  for (p=open_files; p; p=p->link)
branch  0 taken 0
branch  1 taken 1 (fallthrough)
    #####: 4537:    if (p->fp == fp)
branch  0 never executed
branch  1 never executed
    #####: 4538:      return p->name;
        1: 4539:  if (fp == stdin)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 4540:    return "stdin";
        1: 4541:  else if (fp == stdout)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 4542:    return "stdout";
    #####: 4543:  else if (fp == stderr)
branch  0 never executed
branch  1 never executed
    #####: 4544:    return "stderr";
        -: 4545:
    #####: 4546:  return "<unknown>";
        -: 4547:}
        -: 4548:
        -: 4549:/* Panic on failing fopen */
        -: 4550:FILE *
function ck_fopen called 1 returned 100% blocks executed 56%
        1: 4551:ck_fopen(name, mode, fail)
        -: 4552:  const char *name;
        -: 4553:  const char *mode;
        -: 4554:  bool fail;
        -: 4555:{
        -: 4556:  FILE *fp;
        -: 4557:  struct open_file *p;
        -: 4558:
        1: 4559:  fp = fopen (name, mode);
call    0 returned 1
        1: 4560:  if (!fp)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -: 4561:    {
    #####: 4562:      if (fail)
branch  0 never executed
branch  1 never executed
    #####: 4563:        panic(_("couldn't open file %s: %s"), name, strerror(errno));
call    0 never executed
call    1 never executed
        -: 4564:
    #####: 4565:      return NULL;
        -: 4566:    }
        -: 4567:
       1*: 4568:  for (p=open_files; p; p=p->link)
branch  0 taken 0
branch  1 taken 1 (fallthrough)
        -: 4569:    {
    #####: 4570:      if (fp == p->fp)
branch  0 never executed
branch  1 never executed
        -: 4571:	{
    #####: 4572:	  FREE(p->name);
call    0 never executed
    #####: 4573:	  break;
        -: 4574:	}
        -: 4575:    }
        1: 4576:  if (!p)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -: 4577:    {
        1: 4578:      p = MALLOC(1, struct open_file);
call    0 returned 1
        1: 4579:      p->link = open_files;
        1: 4580:      open_files = p;
        -: 4581:    }
        1: 4582:  p->name = ck_strdup(name);
call    0 returned 1
        1: 4583:  p->fp = fp;
        1: 4584:  p->temp = false;
        1: 4585:  return fp;
        -: 4586:}
        -: 4587:
        -: 4588:FILE *
function ck_mkstemp called 0 returned 0% blocks executed 0%
    #####: 4589:ck_mkstemp (p_filename, tmpdir, base)
        -: 4590:  char **p_filename;
        -: 4591:  char *base, *tmpdir;
        -: 4592:{
        -: 4593:  char *template;
        -: 4594:  FILE *fp;
        -: 4595:  int fd;
        -: 4596:  struct open_file *p;
        -: 4597:
    #####: 4598:  if (tmpdir == NULL)
branch  0 never executed
branch  1 never executed
    #####: 4599:    tmpdir = getenv("TMPDIR");
call    0 never executed
    #####: 4600:  if (tmpdir == NULL)
branch  0 never executed
branch  1 never executed
        -: 4601:    {
    #####: 4602:      tmpdir = getenv("TMP");
call    0 never executed
    #####: 4603:      if (tmpdir == NULL)
branch  0 never executed
branch  1 never executed
        -: 4604:#ifdef P_tmpdir
    #####: 4605:	tmpdir = P_tmpdir;
        -: 4606:#else
        -: 4607:	tmpdir = "/tmp";
        -: 4608:#endif
        -: 4609:    }
        -: 4610:
    #####: 4611:  template = xmalloc (strlen (tmpdir) + strlen (base) + 8);
call    0 never executed
    #####: 4612:  sprintf (template, "%s/%sXXXXXX", tmpdir, base);
        -: 4613:
    #####: 4614:  fd = mkstemp (template);
call    0 never executed
    #####: 4615:  if (fd == -1)
branch  0 never executed
branch  1 never executed
    #####: 4616:    panic(_("couldn't open temporary file %s: %s"), template, strerror(errno));
call    0 never executed
call    1 never executed
        -: 4617:
    #####: 4618:  *p_filename = template;
    #####: 4619:  fp = fdopen (fd, "w");
call    0 never executed
        -: 4620:
    #####: 4621:  p = MALLOC(1, struct open_file);
call    0 never executed
    #####: 4622:  p->name = ck_strdup (template);
call    0 never executed
    #####: 4623:  p->fp = fp;
    #####: 4624:  p->temp = true;
    #####: 4625:  p->link = open_files;
    #####: 4626:  open_files = p;
    #####: 4627:  return fp;
        -: 4628:}
        -: 4629:
        -: 4630:/* Panic on failing fwrite */
        -: 4631:void
function ck_fwrite called 2044 returned 100% blocks executed 45%
     2044: 4632:ck_fwrite(ptr, size, nmemb, stream)
        -: 4633:  const VOID *ptr;
        -: 4634:  size_t size;
        -: 4635:  size_t nmemb;
        -: 4636:  FILE *stream;
        -: 4637:{
     2044: 4638:  clearerr(stream);
call    0 returned 2044
     2044: 4639:  if (size && fwrite(ptr, size, nmemb, stream) != nmemb)
branch  0 taken 2044 (fallthrough)
branch  1 taken 0
call    2 returned 2044
branch  3 taken 0 (fallthrough)
branch  4 taken 2044
    #####: 4640:    panic(ngettext("couldn't write %d item to %s: %s",
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -: 4641:		   "couldn't write %d items to %s: %s", nmemb), 
    #####: 4642:		nmemb, utils_fp_name(stream), strerror(errno));
call    0 never executed
     2044: 4643:}
        -: 4644:
        -: 4645:/* Panic on failing fread */
        -: 4646:size_t
function ck_fread called 0 returned 0% blocks executed 0%
    #####: 4647:ck_fread(ptr, size, nmemb, stream)
        -: 4648:  VOID *ptr;
        -: 4649:  size_t size;
        -: 4650:  size_t nmemb;
        -: 4651:  FILE *stream;
        -: 4652:{
    #####: 4653:  clearerr(stream);
call    0 never executed
    #####: 4654:  if (size && (nmemb=fread(ptr, size, nmemb, stream)) <= 0 && ferror(stream))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
    #####: 4655:    panic(_("read error on %s: %s"), utils_fp_name(stream), strerror(errno));
call    0 never executed
call    1 never executed
call    2 never executed
        -: 4656:
    #####: 4657:  return nmemb;
        -: 4658:}
        -: 4659:
        -: 4660:#include "getline.c"
        -: 4661:size_t
function ck_getline called 115 returned 100% blocks executed 73%
      115: 4662:ck_getline(text, buflen, stream)
        -: 4663:  char **text;
        -: 4664:  size_t *buflen;
        -: 4665:  FILE *stream;
        -: 4666:{
        -: 4667:  int result;
      115: 4668:  if (!ferror (stream))
call    0 returned 115
branch  1 taken 115 (fallthrough)
branch  2 taken 0
      115: 4669:    result = getline (text, buflen, stream);
call    0 returned 115
        -: 4670:
      115: 4671:  if (ferror (stream))
call    0 returned 115
branch  1 taken 0 (fallthrough)
branch  2 taken 115
    #####: 4672:    panic (_("read error on %s: %s"), utils_fp_name(stream), strerror(errno));
call    0 never executed
call    1 never executed
call    2 never executed
        -: 4673:
      115: 4674:  return result;
        -: 4675:}
        -: 4676:
        -: 4677:/* Panic on failing fflush */
        -: 4678:void
function ck_fflush called 231 returned 100% blocks executed 50%
      231: 4679:ck_fflush(stream)
        -: 4680:  FILE *stream;
        -: 4681:{
      231: 4682:  clearerr(stream);
call    0 returned 231
     231*: 4683:  if (fflush(stream) == EOF && errno != EBADF)
call    0 returned 231
branch  1 taken 0 (fallthrough)
branch  2 taken 231
branch  3 never executed
branch  4 never executed
    #####: 4684:    panic("couldn't flush %s: %s", utils_fp_name(stream), strerror(errno));
call    0 never executed
call    1 never executed
call    2 never executed
      231: 4685:}
        -: 4686:
        -: 4687:/* Panic on failing fclose */
        -: 4688:void
function ck_fclose called 2 returned 50% blocks executed 92%
        2: 4689:ck_fclose(stream)
        -: 4690:  FILE *stream;
        -: 4691:{
        -: 4692:  struct open_file r;
        -: 4693:  struct open_file *prev;
        -: 4694:  struct open_file *cur;
        -: 4695:
        -: 4696:  /* a NULL stream means to close all files */
        2: 4697:  r.link = open_files;
        2: 4698:  prev = &r;
        3: 4699:  while ( (cur = prev->link) )
branch  0 taken 1
branch  1 taken 2 (fallthrough)
        -: 4700:    {
        1: 4701:      if (!stream || stream == cur->fp)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
branch  2 taken 1 (fallthrough)
branch  3 taken 0
        -: 4702:	{
        1: 4703:	  do_ck_fclose (cur->fp);
call    0 returned 1
        1: 4704:	  prev->link = cur->link;
        1: 4705:	  FREE(cur->name);
call    0 returned 1
        1: 4706:	  FREE(cur);
call    0 returned 1
        -: 4707:	}
        -: 4708:      else
    #####: 4709:	prev = cur;
        -: 4710:    }
        -: 4711:
        2: 4712:  open_files = r.link;
        -: 4713:
        -: 4714:  /* Also care about stdout, because if it is redirected the
        -: 4715:     last output operations might fail and it is important
        -: 4716:     to signal this as an error (perhaps to make). */
        2: 4717:  if (!stream)
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        -: 4718:    {
        1: 4719:      do_ck_fclose (stdout);
call    0 returned 1
        1: 4720:      do_ck_fclose (stderr);
call    0 returned 0
        -: 4721:    }
        1: 4722:}
        -: 4723:
        -: 4724:/* Close a single file. */
        -: 4725:void
function do_ck_fclose called 3 returned 67% blocks executed 100%
        3: 4726:do_ck_fclose(fp)
        -: 4727:  FILE *fp;
        -: 4728:{
        -: 4729:  int fd;
        3: 4730:  ck_fflush(fp);
call    0 returned 3
        3: 4731:  clearerr(fp);
call    0 returned 3
        -: 4732:
        -: 4733:  /* We want to execute both arms, so use | not ||.  */
        3: 4734:  if (fclose(fp) == EOF)
call    0 returned 3
branch  1 taken 1 (fallthrough)
branch  2 taken 2
        1: 4735:    panic("couldn't close %s: %s", utils_fp_name(fp), strerror(errno));
call    0 returned 1
call    1 returned 1
call    2 returned 0
        2: 4736:}
        -: 4737:
        -: 4738:
        -: 4739:/* Panic on failing rename */
        -: 4740:void
function ck_rename called 0 returned 0% blocks executed 0%
    #####: 4741:ck_rename (from, to, unlink_if_fail)
        -: 4742:  const char *from, *to;
        -: 4743:  const char *unlink_if_fail;
        -: 4744:{
    #####: 4745:  int rd = rename (from, to);
call    0 never executed
    #####: 4746:  if (rd != -1)
branch  0 never executed
branch  1 never executed
    #####: 4747:    return;
        -: 4748:
    #####: 4749:  if (unlink_if_fail)
branch  0 never executed
branch  1 never executed
        -: 4750:    {
    #####: 4751:      int save_errno = errno;
    #####: 4752:      errno = 0;
    #####: 4753:      unlink (unlink_if_fail);
call    0 never executed
        -: 4754:
        -: 4755:      /* Failure to remove the temporary file is more severe, so trigger it first.  */
    #####: 4756:      if (errno != 0)
branch  0 never executed
branch  1 never executed
    #####: 4757:        panic (_("cannot remove %s: %s"), unlink_if_fail, strerror (errno));
call    0 never executed
call    1 never executed
        -: 4758:
    #####: 4759:      errno = save_errno;
        -: 4760:    }
        -: 4761:
    #####: 4762:  panic (_("cannot rename %s: %s"), from, strerror (errno));
call    0 never executed
call    1 never executed
        -: 4763:}
        -: 4764:
        -: 4765:
        -: 4766:
        -: 4767:
        -: 4768:/* Panic on failing malloc */
        -: 4769:VOID *
function ck_malloc called 15 returned 100% blocks executed 86%
       15: 4770:ck_malloc(size)
        -: 4771:  size_t size;
        -: 4772:{
       15: 4773:  VOID *ret = calloc(1, size ? size : 1);
branch  0 taken 13 (fallthrough)
branch  1 taken 2
       15: 4774:  if (!ret)
branch  0 taken 0 (fallthrough)
branch  1 taken 15
    #####: 4775:    panic("couldn't allocate memory");
call    0 never executed
       15: 4776:  return ret;
        -: 4777:}
        -: 4778:
        -: 4779:/* Panic on failing malloc */
        -: 4780:VOID *
function xmalloc called 0 returned 0% blocks executed 0%
    #####: 4781:xmalloc(size)
        -: 4782:  size_t size;
        -: 4783:{
    #####: 4784:  return ck_malloc(size);
call    0 never executed
        -: 4785:}
        -: 4786:
        -: 4787:/* Panic on failing realloc */
        -: 4788:VOID *
function ck_realloc called 2 returned 100% blocks executed 70%
        2: 4789:ck_realloc(ptr, size)
        -: 4790:  VOID *ptr;
        -: 4791:  size_t size;
        -: 4792:{
        -: 4793:  VOID *ret;
        -: 4794:
        2: 4795:  if (size == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 2
        -: 4796:    {
    #####: 4797:      FREE(ptr);
call    0 never executed
    #####: 4798:      return NULL;
        -: 4799:    }
        2: 4800:  if (!ptr)
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        1: 4801:    return ck_malloc(size);
call    0 returned 1
        1: 4802:  ret = realloc(ptr, size);
        1: 4803:  if (!ret)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 4804:    panic("couldn't re-allocate memory");
call    0 never executed
        1: 4805:  return ret;
        -: 4806:}
        -: 4807:
        -: 4808:/* Return a malloc()'d copy of a string */
        -: 4809:char *
function ck_strdup called 1 returned 100% blocks executed 100%
        1: 4810:ck_strdup(str)
        -: 4811:  const char *str;
        -: 4812:{
        1: 4813:  char *ret = MALLOC(strlen(str)+1, char);
call    0 returned 1
        1: 4814:  return strcpy(ret, str);
        -: 4815:}
        -: 4816:
        -: 4817:/* Return a malloc()'d copy of a block of memory */
        -: 4818:VOID *
function ck_memdup called 1 returned 100% blocks executed 100%
        1: 4819:ck_memdup(buf, len)
        -: 4820:  const VOID *buf;
        -: 4821:  size_t len;
        -: 4822:{
        1: 4823:  VOID *ret = ck_malloc(len);
call    0 returned 1
        1: 4824:  return memcpy(ret, buf, len);
        -: 4825:}
        -: 4826:
        -: 4827:/* Release a malloc'd block of memory */
        -: 4828:void
function ck_free called 6 returned 100% blocks executed 100%
        6: 4829:ck_free(ptr)
        -: 4830:  VOID *ptr;
        -: 4831:{
        6: 4832:  if (ptr)
branch  0 taken 6 (fallthrough)
branch  1 taken 0
        6: 4833:    free(ptr);
        6: 4834:}
        -: 4835:
        -: 4836:
        -: 4837:/* Implement a variable sized buffer of `stuff'.  We don't know what it is,
        -: 4838:nor do we care, as long as it doesn't mind being aligned by malloc. */
        -: 4839:
        -: 4840:struct buffer
        -: 4841:  {
        -: 4842:    size_t allocated;
        -: 4843:    size_t length;
        -: 4844:    char *b;
        -: 4845:  };
        -: 4846:
        -: 4847:#define MIN_ALLOCATE 50
        -: 4848:
        -: 4849:struct buffer *
function init_buffer called 2 returned 100% blocks executed 100%
        2: 4850:init_buffer()
        -: 4851:{
        2: 4852:  struct buffer *b = MALLOC(1, struct buffer);
call    0 returned 2
        2: 4853:  b->b = MALLOC(MIN_ALLOCATE, char);
call    0 returned 2
        2: 4854:  b->allocated = MIN_ALLOCATE;
        2: 4855:  b->length = 0;
        2: 4856:  return b;
        -: 4857:}
        -: 4858:
        -: 4859:char *
function get_buffer called 2 returned 100% blocks executed 100%
        2: 4860:get_buffer(b)
        -: 4861:  struct buffer *b;
        -: 4862:{
        2: 4863:  return b->b;
        -: 4864:}
        -: 4865:
        -: 4866:size_t
function size_buffer called 3 returned 100% blocks executed 100%
        3: 4867:size_buffer(b)
        -: 4868:  struct buffer *b;
        -: 4869:{
        3: 4870:  return b->length;
        -: 4871:}
        -: 4872:
        -: 4873:static void resize_buffer P_((struct buffer *b, size_t newlen));
        -: 4874:static void
function resize_buffer called 0 returned 0% blocks executed 0%
    #####: 4875:resize_buffer(b, newlen)
        -: 4876:  struct buffer *b;
        -: 4877:  size_t newlen;
        -: 4878:{
    #####: 4879:  char *try = NULL;
    #####: 4880:  size_t alen = b->allocated;
        -: 4881:
    #####: 4882:  if (newlen <= alen)
branch  0 never executed
branch  1 never executed
    #####: 4883:    return;
    #####: 4884:  alen *= 2;
    #####: 4885:  if (newlen < alen)
branch  0 never executed
branch  1 never executed
    #####: 4886:    try = realloc(b->b, alen);	/* Note: *not* the REALLOC() macro! */
    #####: 4887:  if (!try)
branch  0 never executed
branch  1 never executed
        -: 4888:    {
    #####: 4889:      alen = newlen;
    #####: 4890:      try = REALLOC(b->b, alen, char);
call    0 never executed
        -: 4891:    }
    #####: 4892:  b->allocated = alen;
    #####: 4893:  b->b = try;
        -: 4894:}
        -: 4895:
        -: 4896:char *
function add_buffer called 0 returned 0% blocks executed 0%
    #####: 4897:add_buffer(b, p, n)
        -: 4898:  struct buffer *b;
        -: 4899:  const char *p;
        -: 4900:  size_t n;
        -: 4901:{
        -: 4902:  char *result;
    #####: 4903:  if (b->allocated - b->length < n)
branch  0 never executed
branch  1 never executed
    #####: 4904:    resize_buffer(b, b->length+n);
call    0 never executed
    #####: 4905:  result = memcpy(b->b + b->length, p, n);
    #####: 4906:  b->length += n;
    #####: 4907:  return result;
        -: 4908:}
        -: 4909:
        -: 4910:char *
function add1_buffer called 25 returned 100% blocks executed 67%
       25: 4911:add1_buffer(b, c)
        -: 4912:  struct buffer *b;
        -: 4913:  int c;
        -: 4914:{
        -: 4915:  /* This special case should be kept cheap;
        -: 4916:   *  don't make it just a mere convenience
        -: 4917:   *  wrapper for add_buffer() -- even "builtin"
        -: 4918:   *  versions of memcpy(a, b, 1) can become
        -: 4919:   *  expensive when called too often.
        -: 4920:   */
       25: 4921:  if (c != EOF)
branch  0 taken 25 (fallthrough)
branch  1 taken 0
        -: 4922:    {
        -: 4923:      char *result;
       25: 4924:      if (b->allocated - b->length < 1)
branch  0 taken 0 (fallthrough)
branch  1 taken 25
    #####: 4925:	resize_buffer(b, b->length+1);
call    0 never executed
       25: 4926:      result = b->b + b->length++;
       25: 4927:      *result = c;
       25: 4928:      return result;
        -: 4929:    }
        -: 4930:
    #####: 4931:  return NULL;
        -: 4932:}
        -: 4933:
        -: 4934:void
function free_buffer called 2 returned 100% blocks executed 100%
        2: 4935:free_buffer(b)
        -: 4936:  struct buffer *b;
        -: 4937:{
        2: 4938:  if (b)
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2: 4939:    FREE(b->b);
call    0 returned 2
        2: 4940:  FREE(b);
call    0 returned 2
        2: 4941:}
        -: 4942:/*  GNU SED, a batch stream editor.
        -: 4943:    Copyright (C) 2003 Free Software Foundation, Inc.
        -: 4944:
        -: 4945:    This program is free software; you can redistribute it and/or modify
        -: 4946:    it under the terms of the GNU General Public License as published by
        -: 4947:    the Free Software Foundation; either version 2, or (at your option)
        -: 4948:    any later version.
        -: 4949:
        -: 4950:    This program is distributed in the hope that it will be useful,
        -: 4951:    but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 4952:    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 4953:    GNU General Public License for more details.
        -: 4954:
        -: 4955:    You should have received a copy of the GNU General Public License
        -: 4956:    along with this program; if not, write to the Free Software
        -: 4957:    Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA. */
        -: 4958:
        -: 4959:#include <stdlib.h>
        -: 4960:
        -: 4961:int mb_cur_max;
        -: 4962:
        -: 4963:#ifdef HAVE_MBRTOWC
        -: 4964:/* Add a byte to the multibyte character represented by the state
        -: 4965:   CUR_STAT, and answer its length if a character is completed,
        -: 4966:   or -2 if it is yet to be completed.  */
        -: 4967:int brlen (ch, cur_stat)
        -: 4968:     int ch;
        -: 4969:     mbstate_t *cur_stat;
        -: 4970:{
        -: 4971:  char c = ch;
        -: 4972:
        -: 4973:  /* If we use the generic brlen, then MBRLEN == mbrlen.  */
        -: 4974:  int result = mbrtowc(NULL, &c, 1, cur_stat);
        -: 4975:
        -: 4976:  /* An invalid sequence is treated like a singlebyte character. */
        -: 4977:  if (result == -1)
        -: 4978:    {
        -: 4979:      memset (cur_stat, 0, sizeof (mbstate_t));
        -: 4980:      return 1;
        -: 4981:    }
        -: 4982:
        -: 4983:  return result;
        -: 4984:}
        -: 4985:#endif
        -: 4986:
        -: 4987:void
function initialize_mbcs called 1 returned 100% blocks executed 100%
        1: 4988:initialize_mbcs ()
        -: 4989:{
        -: 4990:#ifdef HAVE_MBRTOWC
        -: 4991:  mb_cur_max = MB_CUR_MAX;
        -: 4992:#else
        1: 4993:  mb_cur_max = 1;
        -: 4994:#endif
        1: 4995:}
        -: 4996:
        -: 4997:/* obstack.c - subroutines used implicitly by object stack macros -*- C -*-
        -: 4998:   Copyright (C) 1988,89,90,91,92,93,94,96,97 Free Software Foundation, Inc.
        -: 4999:
        -: 5000:   This file is part of the GNU C Library.  Its master source is NOT part of
        -: 5001:   the C library, however.  The master source lives in /gd/gnu/lib.
        -: 5002:
        -: 5003:   The GNU C Library is free software; you can redistribute it and/or
        -: 5004:   modify it under the terms of the GNU Library General Public License as
        -: 5005:   published by the Free Software Foundation; either version 2 of the
        -: 5006:   License, or (at your option) any later version.
        -: 5007:
        -: 5008:   The GNU C Library is distributed in the hope that it will be useful,
        -: 5009:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 5010:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
        -: 5011:   Library General Public License for more details.
        -: 5012:
        -: 5013:   You should have received a copy of the GNU Library General Public
        -: 5014:   License along with the GNU C Library; see the file COPYING.LIB.  If not,
        -: 5015:   write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
        -: 5016:   Boston, MA 02110-1301, USA.  */
        -: 5017:
        -: 5018:#ifdef HAVE_CONFIG_H
        -: 5019:#include "config.h"
        -: 5020:#endif
        -: 5021:
        -: 5022:#include "obstack.h"
        -: 5023:
        -: 5024:/* NOTE BEFORE MODIFYING THIS FILE: This version number must be
        -: 5025:   incremented whenever callers compiled using an old obstack.h can no
        -: 5026:   longer properly call the functions in this obstack.c.  */
        -: 5027:#define OBSTACK_INTERFACE_VERSION 1
        -: 5028:
        -: 5029:/* Comment out all this code if we are using the GNU C Library, and are not
        -: 5030:   actually compiling the library itself, and the installed library
        -: 5031:   supports the same library interface we do.  This code is part of the GNU
        -: 5032:   C Library, but also included in many other GNU distributions.  Compiling
        -: 5033:   and linking in this code is a waste when using the GNU C library
        -: 5034:   (especially if it is a shared library).  Rather than having every GNU
        -: 5035:   program understand `configure --with-gnu-libc' and omit the object
        -: 5036:   files, it is simpler to just do this in the source for each such file.  */
        -: 5037:
        -: 5038:#include <stdio.h>		/* Random thing to get __GNU_LIBRARY__.  */
        -: 5039:#if !defined (_LIBC) && defined (__GNU_LIBRARY__) && __GNU_LIBRARY__ > 1
        -: 5040:#include <gnu-versions.h>
        -: 5041:#if _GNU_OBSTACK_INTERFACE_VERSION == OBSTACK_INTERFACE_VERSION
        -: 5042:#define ELIDE_CODE
        -: 5043:#endif
        -: 5044:#endif
        -: 5045:
        -: 5046:
        -: 5047:#ifndef ELIDE_CODE
        -: 5048:
        -: 5049:
        -: 5050:#if defined (__STDC__) && __STDC__
        -: 5051:#define POINTER void *
        -: 5052:#else
        -: 5053:#define POINTER char *
        -: 5054:#endif
        -: 5055:
        -: 5056:/* Determine default alignment.  */
        -: 5057:struct fooalign {char x; double d;};
        -: 5058:#define DEFAULT_ALIGNMENT  \
        -: 5059:  ((PTR_INT_TYPE) ((char *) &((struct fooalign *) 0)->d - (char *) 0))
        -: 5060:/* If malloc were really smart, it would round addresses to DEFAULT_ALIGNMENT.
        -: 5061:   But in fact it might be less smart and round addresses to as much as
        -: 5062:   DEFAULT_ROUNDING.  So we prepare for it to do that.  */
        -: 5063:union fooround {long x; double d;};
        -: 5064:#define DEFAULT_ROUNDING (sizeof (union fooround))
        -: 5065:
        -: 5066:#ifdef original_glibc_code
        -: 5067:/**//* When we copy a long block of data, this is the unit to do it with. */
        -: 5068:/**//* On some machines, copying successive ints does not work; */
        -: 5069:/**//* in such a case, redefine COPYING_UNIT to `long' (if that works) */
        -: 5070:/**//* or `char' as a last resort.  */
        -: 5071:/**/#ifndef COPYING_UNIT
        -: 5072:/**/#define COPYING_UNIT int
        -: 5073:/**/#endif
        -: 5074:#endif
        -: 5075:
        -: 5076:/* The functions allocating more room by calling `obstack_chunk_alloc'
        -: 5077:   jump to the handler pointed to by `obstack_alloc_failed_handler'.
        -: 5078:   This variable by default points to the internal function
        -: 5079:   `print_and_abort'.  */
        -: 5080:#if defined (__STDC__) && __STDC__
        -: 5081:static void print_and_abort (void);
        -: 5082:void (*obstack_alloc_failed_handler) (void) = print_and_abort;
        -: 5083:#else
        -: 5084:static void print_and_abort ();
        -: 5085:void (*obstack_alloc_failed_handler) () = print_and_abort;
        -: 5086:#endif
        -: 5087:
        -: 5088:/* Exit value used when `print_and_abort' is used.  */
        -: 5089:#if defined __GNU_LIBRARY__ || defined HAVE_STDLIB_H
        -: 5090:#include <stdlib.h>
        -: 5091:#endif
        -: 5092:#ifndef EXIT_FAILURE
        -: 5093:#define EXIT_FAILURE 1
        -: 5094:#endif
        -: 5095:int obstack_exit_failure = EXIT_FAILURE;
        -: 5096:
        -: 5097:/* The non-GNU-C macros copy the obstack into this global variable
        -: 5098:   to avoid multiple evaluation.  */
        -: 5099:
        -: 5100:struct obstack *_obstack;
        -: 5101:
        -: 5102:/* Define a macro that either calls functions with the traditional malloc/free
        -: 5103:   calling interface, or calls functions with the mmalloc/mfree interface
        -: 5104:   (that adds an extra first argument), based on the state of use_extra_arg.
        -: 5105:   For free, do not use ?:, since some compilers, like the MIPS compilers,
        -: 5106:   do not allow (expr) ? void : void.  */
        -: 5107:
        -: 5108:#if defined (__STDC__) && __STDC__
        -: 5109:#define CALL_CHUNKFUN(h, size) \
        -: 5110:  (((h) -> use_extra_arg) \
        -: 5111:   ? (*(h)->chunkfun) ((h)->extra_arg, (size)) \
        -: 5112:   : (*(struct _obstack_chunk *(*) (long)) (h)->chunkfun) ((size)))
        -: 5113:
        -: 5114:#define CALL_FREEFUN(h, old_chunk) \
        -: 5115:  do { \
        -: 5116:    if ((h) -> use_extra_arg) \
        -: 5117:      (*(h)->freefun) ((h)->extra_arg, (old_chunk)); \
        -: 5118:    else \
        -: 5119:      (*(void (*) (void *)) (h)->freefun) ((old_chunk)); \
        -: 5120:  } while (0)
        -: 5121:#else
        -: 5122:#define CALL_CHUNKFUN(h, size) \
        -: 5123:  (((h) -> use_extra_arg) \
        -: 5124:   ? (*(h)->chunkfun) ((h)->extra_arg, (size)) \
        -: 5125:   : (*(struct _obstack_chunk *(*) ()) (h)->chunkfun) ((size)))
        -: 5126:
        -: 5127:#define CALL_FREEFUN(h, old_chunk) \
        -: 5128:  do { \
        -: 5129:    if ((h) -> use_extra_arg) \
        -: 5130:      (*(h)->freefun) ((h)->extra_arg, (old_chunk)); \
        -: 5131:    else \
        -: 5132:      (*(void (*) ()) (h)->freefun) ((old_chunk)); \
        -: 5133:  } while (0)
        -: 5134:#endif
        -: 5135:
        -: 5136:
        -: 5137:/* Initialize an obstack H for use.  Specify chunk size SIZE (0 means default).
        -: 5138:   Objects start on multiples of ALIGNMENT (0 means use default).
        -: 5139:   CHUNKFUN is the function to use to allocate chunks,
        -: 5140:   and FREEFUN the function to free them.
        -: 5141:
        -: 5142:   Return nonzero if successful, zero if out of memory.
        -: 5143:   To recover from an out of memory error,
        -: 5144:   free up some memory, then call this again.  */
        -: 5145:
        -: 5146:int
        -: 5147:_obstack_begin (h, size, alignment, chunkfun, freefun)
        -: 5148:     struct obstack *h;
        -: 5149:     int size;
        -: 5150:     int alignment;
        -: 5151:#if defined (__STDC__) && __STDC__
        -: 5152:     POINTER (*chunkfun) (long);
        -: 5153:     void (*freefun) (void *);
        -: 5154:#else
        -: 5155:     POINTER (*chunkfun) ();
        -: 5156:     void (*freefun) ();
        -: 5157:#endif
        -: 5158:{
        -: 5159:  register struct _obstack_chunk *chunk; /* points to new chunk */
        -: 5160:
        -: 5161:  if (alignment == 0)
        -: 5162:    alignment = DEFAULT_ALIGNMENT;
        -: 5163:  if (size == 0)
        -: 5164:    /* Default size is what GNU malloc can fit in a 4096-byte block.  */
        -: 5165:    {
        -: 5166:      /* 12 is sizeof (mhead) and 4 is EXTRA from GNU malloc.
        -: 5167:	 Use the values for range checking, because if range checking is off,
        -: 5168:	 the extra bytes won't be missed terribly, but if range checking is on
        -: 5169:	 and we used a larger request, a whole extra 4096 bytes would be
        -: 5170:	 allocated.
        -: 5171:
        -: 5172:	 These number are irrelevant to the new GNU malloc.  I suspect it is
        -: 5173:	 less sensitive to the size of the request.  */
        -: 5174:      int extra = ((((12 + DEFAULT_ROUNDING - 1) & ~(DEFAULT_ROUNDING - 1))
        -: 5175:		    + 4 + DEFAULT_ROUNDING - 1)
        -: 5176:		   & ~(DEFAULT_ROUNDING - 1));
        -: 5177:      size = 4096 - extra;
        -: 5178:    }
        -: 5179:
        -: 5180:#if defined (__STDC__) && __STDC__
        -: 5181:  h->chunkfun = (struct _obstack_chunk * (*)(void *, long)) chunkfun;
        -: 5182:  h->freefun = (void (*) (void *, struct _obstack_chunk *)) freefun;
        -: 5183:#else
        -: 5184:  h->chunkfun = (struct _obstack_chunk * (*)()) chunkfun;
        -: 5185:  h->freefun = freefun;
        -: 5186:#endif
        -: 5187:  h->chunk_size = size;
        -: 5188:  h->alignment_mask = alignment - 1;
        -: 5189:  h->use_extra_arg = 0;
        -: 5190:
        -: 5191:  chunk = h->chunk = CALL_CHUNKFUN (h, h -> chunk_size);
        -: 5192:  if (!chunk)
        -: 5193:    (*obstack_alloc_failed_handler) ();
        -: 5194:  h->next_free = h->object_base = chunk->contents;
        -: 5195:  h->chunk_limit = chunk->limit
        -: 5196:    = (char *) chunk + h->chunk_size;
        -: 5197:  chunk->prev = 0;
        -: 5198:  /* The initial chunk now contains no empty object.  */
        -: 5199:  h->maybe_empty_object = 0;
        -: 5200:  h->alloc_failed = 0;
        -: 5201:  return 1;
        -: 5202:}
        -: 5203:
        -: 5204:int
        -: 5205:_obstack_begin_1 (h, size, alignment, chunkfun, freefun, arg)
        -: 5206:     struct obstack *h;
        -: 5207:     int size;
        -: 5208:     int alignment;
        -: 5209:#if defined (__STDC__) && __STDC__
        -: 5210:     POINTER (*chunkfun) (POINTER, long);
        -: 5211:     void (*freefun) (POINTER, POINTER);
        -: 5212:#else
        -: 5213:     POINTER (*chunkfun) ();
        -: 5214:     void (*freefun) ();
        -: 5215:#endif
        -: 5216:     POINTER arg;
        -: 5217:{
        -: 5218:  register struct _obstack_chunk *chunk; /* points to new chunk */
        -: 5219:
        -: 5220:  if (alignment == 0)
        -: 5221:    alignment = DEFAULT_ALIGNMENT;
        -: 5222:  if (size == 0)
        -: 5223:    /* Default size is what GNU malloc can fit in a 4096-byte block.  */
        -: 5224:    {
        -: 5225:      /* 12 is sizeof (mhead) and 4 is EXTRA from GNU malloc.
        -: 5226:	 Use the values for range checking, because if range checking is off,
        -: 5227:	 the extra bytes won't be missed terribly, but if range checking is on
        -: 5228:	 and we used a larger request, a whole extra 4096 bytes would be
        -: 5229:	 allocated.
        -: 5230:
        -: 5231:	 These number are irrelevant to the new GNU malloc.  I suspect it is
        -: 5232:	 less sensitive to the size of the request.  */
        -: 5233:      int extra = ((((12 + DEFAULT_ROUNDING - 1) & ~(DEFAULT_ROUNDING - 1))
        -: 5234:		    + 4 + DEFAULT_ROUNDING - 1)
        -: 5235:		   & ~(DEFAULT_ROUNDING - 1));
        -: 5236:      size = 4096 - extra;
        -: 5237:    }
        -: 5238:
        -: 5239:#if defined(__STDC__) && __STDC__
        -: 5240:  h->chunkfun = (struct _obstack_chunk * (*)(void *,long)) chunkfun;
        -: 5241:  h->freefun = (void (*) (void *, struct _obstack_chunk *)) freefun;
        -: 5242:#else
        -: 5243:  h->chunkfun = (struct _obstack_chunk * (*)()) chunkfun;
        -: 5244:  h->freefun = freefun;
        -: 5245:#endif
        -: 5246:  h->chunk_size = size;
        -: 5247:  h->alignment_mask = alignment - 1;
        -: 5248:  h->extra_arg = arg;
        -: 5249:  h->use_extra_arg = 1;
        -: 5250:
        -: 5251:  chunk = h->chunk = CALL_CHUNKFUN (h, h -> chunk_size);
        -: 5252:  if (!chunk)
        -: 5253:    (*obstack_alloc_failed_handler) ();
        -: 5254:  h->next_free = h->object_base = chunk->contents;
        -: 5255:  h->chunk_limit = chunk->limit
        -: 5256:    = (char *) chunk + h->chunk_size;
        -: 5257:  chunk->prev = 0;
        -: 5258:  /* The initial chunk now contains no empty object.  */
        -: 5259:  h->maybe_empty_object = 0;
        -: 5260:  h->alloc_failed = 0;
        -: 5261:  return 1;
        -: 5262:}
        -: 5263:
        -: 5264:/* Allocate a new current chunk for the obstack *H
        -: 5265:   on the assumption that LENGTH bytes need to be added
        -: 5266:   to the current object, or a new object of length LENGTH allocated.
        -: 5267:   Copies any partial object from the end of the old chunk
        -: 5268:   to the beginning of the new one.  */
        -: 5269:
        -: 5270:void
        -: 5271:_obstack_newchunk (h, length)
        -: 5272:     struct obstack *h;
        -: 5273:     int length;
        -: 5274:{
        -: 5275:  register struct _obstack_chunk *old_chunk = h->chunk;
        -: 5276:  register struct _obstack_chunk *new_chunk;
        -: 5277:  register long	new_size;
        -: 5278:  register int obj_size = h->next_free - h->object_base;
        -: 5279:
        -: 5280:  /* Compute size for new chunk.  */
        -: 5281:  new_size = (obj_size + length) + (obj_size >> 3) + 100;
        -: 5282:  if (new_size < h->chunk_size)
        -: 5283:    new_size = h->chunk_size;
        -: 5284:
        -: 5285:  /* Allocate and initialize the new chunk.  */
        -: 5286:  new_chunk = CALL_CHUNKFUN (h, new_size);
        -: 5287:  if (!new_chunk)
        -: 5288:    (*obstack_alloc_failed_handler) ();
        -: 5289:  h->chunk = new_chunk;
        -: 5290:  new_chunk->prev = old_chunk;
        -: 5291:  new_chunk->limit = h->chunk_limit = (char *) new_chunk + new_size;
        -: 5292:
        -: 5293:  _obstack_memcpy(new_chunk->contents, h->object_base, obj_size);
        -: 5294:
        -: 5295:  /* If the object just copied was the only data in OLD_CHUNK, */
        -: 5296:  /* free that chunk and remove it from the chain. */
        -: 5297:  /* But not if that chunk might contain an empty object.  */
        -: 5298:  if (h->object_base == old_chunk->contents && ! h->maybe_empty_object)
        -: 5299:    {
        -: 5300:      new_chunk->prev = old_chunk->prev;
        -: 5301:      CALL_FREEFUN (h, old_chunk);
        -: 5302:    }
        -: 5303:
        -: 5304:  h->object_base = new_chunk->contents;
        -: 5305:  h->next_free = h->object_base + obj_size;
        -: 5306:  /* The new chunk certainly contains no empty object yet.  */
        -: 5307:  h->maybe_empty_object = 0;
        -: 5308:}
        -: 5309:
        -: 5310:/* Return nonzero if object OBJ has been allocated from obstack H.
        -: 5311:   This is here for debugging.
        -: 5312:   If you use it in a program, you are probably losing.  */
        -: 5313:
        -: 5314:#if defined (__STDC__) && __STDC__
        -: 5315:/* Suppress -Wmissing-prototypes warning.  We don't want to declare this in
        -: 5316:   obstack.h because it is just for debugging.  */
        -: 5317:int _obstack_allocated_p (struct obstack *h, POINTER obj);
        -: 5318:#endif
        -: 5319:
        -: 5320:int
        -: 5321:_obstack_allocated_p (h, obj)
        -: 5322:     struct obstack *h;
        -: 5323:     POINTER obj;
        -: 5324:{
        -: 5325:  register struct _obstack_chunk *lp;	/* below addr of any objects in this chunk */
        -: 5326:  register struct _obstack_chunk *plp;	/* point to previous chunk if any */
        -: 5327:
        -: 5328:  lp = (h)->chunk;
        -: 5329:  /* We use >= rather than > since the object cannot be exactly at
        -: 5330:     the beginning of the chunk but might be an empty object exactly
        -: 5331:     at the end of an adjacent chunk.  */
        -: 5332:  while (lp != 0 && ((POINTER) lp >= obj || (POINTER) (lp)->limit < obj))
        -: 5333:    {
        -: 5334:      plp = lp->prev;
        -: 5335:      lp = plp;
        -: 5336:    }
        -: 5337:  return lp != 0;
        -: 5338:}
        -: 5339:
        -: 5340:/* Free objects in obstack H, including OBJ and everything allocate
        -: 5341:   more recently than OBJ.  If OBJ is zero, free everything in H.  */
        -: 5342:
        -: 5343:#undef obstack_free
        -: 5344:
        -: 5345:/* This function has two names with identical definitions.
        -: 5346:   This is the first one, called from non-ANSI code.  */
        -: 5347:
        -: 5348:void
        -: 5349:_obstack_free (h, obj)
        -: 5350:     struct obstack *h;
        -: 5351:     POINTER obj;
        -: 5352:{
        -: 5353:  register struct _obstack_chunk *lp;	/* below addr of any objects in this chunk */
        -: 5354:  register struct _obstack_chunk *plp;	/* point to previous chunk if any */
        -: 5355:
        -: 5356:  lp = h->chunk;
        -: 5357:  /* We use >= because there cannot be an object at the beginning of a chunk.
        -: 5358:     But there can be an empty object at that address
        -: 5359:     at the end of another chunk.  */
        -: 5360:  while (lp != 0 && ((POINTER) lp >= obj || (POINTER) (lp)->limit < obj))
        -: 5361:    {
        -: 5362:      plp = lp->prev;
        -: 5363:      CALL_FREEFUN (h, lp);
        -: 5364:      lp = plp;
        -: 5365:      /* If we switch chunks, we can't tell whether the new current
        -: 5366:	 chunk contains an empty object, so assume that it may.  */
        -: 5367:      h->maybe_empty_object = 1;
        -: 5368:    }
        -: 5369:  if (lp)
        -: 5370:    {
        -: 5371:      h->object_base = h->next_free = (char *) (obj);
        -: 5372:      h->chunk_limit = lp->limit;
        -: 5373:      h->chunk = lp;
        -: 5374:    }
        -: 5375:  else if (obj != 0)
        -: 5376:    /* obj is not in any of the chunks! */
        -: 5377:    abort ();
        -: 5378:}
        -: 5379:
        -: 5380:/* This function is used from ANSI code.  */
        -: 5381:
        -: 5382:void
        -: 5383:obstack_free (h, obj)
        -: 5384:     struct obstack *h;
        -: 5385:     POINTER obj;
        -: 5386:{
        -: 5387:  register struct _obstack_chunk *lp;	/* below addr of any objects in this chunk */
        -: 5388:  register struct _obstack_chunk *plp;	/* point to previous chunk if any */
        -: 5389:
        -: 5390:  lp = h->chunk;
        -: 5391:  /* We use >= because there cannot be an object at the beginning of a chunk.
        -: 5392:     But there can be an empty object at that address
        -: 5393:     at the end of another chunk.  */
        -: 5394:  while (lp != 0 && ((POINTER) lp >= obj || (POINTER) (lp)->limit < obj))
        -: 5395:    {
        -: 5396:      plp = lp->prev;
        -: 5397:      CALL_FREEFUN (h, lp);
        -: 5398:      lp = plp;
        -: 5399:      /* If we switch chunks, we can't tell whether the new current
        -: 5400:	 chunk contains an empty object, so assume that it may.  */
        -: 5401:      h->maybe_empty_object = 1;
        -: 5402:    }
        -: 5403:  if (lp)
        -: 5404:    {
        -: 5405:      h->object_base = h->next_free = (char *) (obj);
        -: 5406:      h->chunk_limit = lp->limit;
        -: 5407:      h->chunk = lp;
        -: 5408:    }
        -: 5409:  else if (obj != 0)
        -: 5410:    /* obj is not in any of the chunks! */
        -: 5411:    abort ();
        -: 5412:}
        -: 5413:
        -: 5414:int
        -: 5415:_obstack_memory_used (h)
        -: 5416:     struct obstack *h;
        -: 5417:{
        -: 5418:  register struct _obstack_chunk* lp;
        -: 5419:  register int nbytes = 0;
        -: 5420:
        -: 5421:  for (lp = h->chunk; lp != 0; lp = lp->prev)
        -: 5422:    {
        -: 5423:      nbytes += lp->limit - (char *) lp;
        -: 5424:    }
        -: 5425:  return nbytes;
        -: 5426:}
        -: 5427:
        -: 5428:/* Define the error handler.  */
        -: 5429:#ifndef _
        -: 5430:# ifdef HAVE_LIBINTL_H
        -: 5431:#  include <libintl.h>
        -: 5432:#  ifndef _
        -: 5433:#   define _(Str) gettext (Str)
        -: 5434:#  endif
        -: 5435:# else
        -: 5436:#  define _(Str) (Str)
        -: 5437:# endif
        -: 5438:#endif
        -: 5439:
        -: 5440:static void
        -: 5441:print_and_abort ()
        -: 5442:{
        -: 5443:  fputs (_("memory exhausted\n"), stderr);
        -: 5444:  exit (obstack_exit_failure);
        -: 5445:}
        -: 5446:
        -: 5447:#if 0
        -: 5448:/* These are now turned off because the applications do not use it
        -: 5449:   and it uses bcopy via obstack_grow, which causes trouble on sysV.  */
        -: 5450:
        -: 5451:/* Now define the functional versions of the obstack macros.
        -: 5452:   Define them to simply use the corresponding macros to do the job.  */
        -: 5453:
        -: 5454:#if defined (__STDC__) && __STDC__
        -: 5455:/* These function definitions do not work with non-ANSI preprocessors;
        -: 5456:   they won't pass through the macro names in parentheses.  */
        -: 5457:
        -: 5458:/* The function names appear in parentheses in order to prevent
        -: 5459:   the macro-definitions of the names from being expanded there.  */
        -: 5460:
        -: 5461:POINTER (obstack_base) (obstack)
        -: 5462:     struct obstack *obstack;
        -: 5463:{
        -: 5464:  return obstack_base (obstack);
        -: 5465:}
        -: 5466:
        -: 5467:POINTER (obstack_next_free) (obstack)
        -: 5468:     struct obstack *obstack;
        -: 5469:{
        -: 5470:  return obstack_next_free (obstack);
        -: 5471:}
        -: 5472:
        -: 5473:int (obstack_object_size) (obstack)
        -: 5474:     struct obstack *obstack;
        -: 5475:{
        -: 5476:  return obstack_object_size (obstack);
        -: 5477:}
        -: 5478:
        -: 5479:int (obstack_room) (obstack)
        -: 5480:     struct obstack *obstack;
        -: 5481:{
        -: 5482:  return obstack_room (obstack);
        -: 5483:}
        -: 5484:
        -: 5485:int (obstack_make_room) (obstack, length)
        -: 5486:     struct obstack *obstack;
        -: 5487:     int length;
        -: 5488:{
        -: 5489:  return obstack_make_room (obstack, length);
        -: 5490:}
        -: 5491:
        -: 5492:void (obstack_grow) (obstack, pointer, length)
        -: 5493:     struct obstack *obstack;
        -: 5494:     POINTER pointer;
        -: 5495:     int length;
        -: 5496:{
        -: 5497:  obstack_grow (obstack, pointer, length);
        -: 5498:}
        -: 5499:
        -: 5500:void (obstack_grow0) (obstack, pointer, length)
        -: 5501:     struct obstack *obstack;
        -: 5502:     POINTER pointer;
        -: 5503:     int length;
        -: 5504:{
        -: 5505:  obstack_grow0 (obstack, pointer, length);
        -: 5506:}
        -: 5507:
        -: 5508:void (obstack_1grow) (obstack, character)
        -: 5509:     struct obstack *obstack;
        -: 5510:     int character;
        -: 5511:{
        -: 5512:  obstack_1grow (obstack, character);
        -: 5513:}
        -: 5514:
        -: 5515:void (obstack_blank) (obstack, length)
        -: 5516:     struct obstack *obstack;
        -: 5517:     int length;
        -: 5518:{
        -: 5519:  obstack_blank (obstack, length);
        -: 5520:}
        -: 5521:
        -: 5522:void (obstack_1grow_fast) (obstack, character)
        -: 5523:     struct obstack *obstack;
        -: 5524:     int character;
        -: 5525:{
        -: 5526:  obstack_1grow_fast (obstack, character);
        -: 5527:}
        -: 5528:
        -: 5529:void (obstack_blank_fast) (obstack, length)
        -: 5530:     struct obstack *obstack;
        -: 5531:     int length;
        -: 5532:{
        -: 5533:  obstack_blank_fast (obstack, length);
        -: 5534:}
        -: 5535:
        -: 5536:POINTER (obstack_finish) (obstack)
        -: 5537:     struct obstack *obstack;
        -: 5538:{
        -: 5539:  return obstack_finish (obstack);
        -: 5540:}
        -: 5541:
        -: 5542:POINTER (obstack_alloc) (obstack, length)
        -: 5543:     struct obstack *obstack;
        -: 5544:     int length;
        -: 5545:{
        -: 5546:  return obstack_alloc (obstack, length);
        -: 5547:}
        -: 5548:
        -: 5549:POINTER (obstack_copy) (obstack, pointer, length)
        -: 5550:     struct obstack *obstack;
        -: 5551:     POINTER pointer;
        -: 5552:     int length;
        -: 5553:{
        -: 5554:  return obstack_copy (obstack, pointer, length);
        -: 5555:}
        -: 5556:
        -: 5557:POINTER (obstack_copy0) (obstack, pointer, length)
        -: 5558:     struct obstack *obstack;
        -: 5559:     POINTER pointer;
        -: 5560:     int length;
        -: 5561:{
        -: 5562:  return obstack_copy0 (obstack, pointer, length);
        -: 5563:}
        -: 5564:
        -: 5565:#endif /* __STDC__ */
        -: 5566:
        -: 5567:#endif /* 0 */
        -: 5568:
        -: 5569:#endif	/* !ELIDE_CODE */
        -: 5570:#ifdef HAVE_CONFIG_H
        -: 5571:#include "config.h"
        -: 5572:#endif
        -: 5573:
        -: 5574:#undef _GNU_SOURCE
        -: 5575:
        -: 5576:#include <sys/types.h>
        -: 5577:#include <stdio.h>
        -: 5578:
        -: 5579:#ifdef HAVE_STRINGS_H
        -: 5580:# include <strings.h>
        -: 5581:#else
        -: 5582:# include <string.h>
        -: 5583:#endif /* HAVE_STRINGS_H */
        -: 5584:
        -: 5585:#ifdef HAVE_STDLIB_H
        -: 5586:# include <stdlib.h>
        -: 5587:#endif /* HAVE_STDLIB_H */
        -: 5588:
        -: 5589:#ifdef HAVE_UNISTD_H
        -: 5590:# include <unistd.h>
        -: 5591:#endif /* HAVE_UNISTD_H */
        -: 5592:
        -: 5593:#include <limits.h>
        -: 5594:#include <errno.h>
        -: 5595:
        -: 5596:
        -: 5597:/* getopt_long and getopt_long_only entry points for GNU getopt.
        -: 5598:   Copyright (C) 1987,88,89,90,91,92,93,94,96,97,98
        -: 5599:     Free Software Foundation, Inc.
        -: 5600:
        -: 5601:   NOTE: The canonical source of this file is maintained with the GNU C Library.
        -: 5602:   Bugs can be reported to bug-glibc@gnu.org.
        -: 5603:
        -: 5604:   This program is free software; you can redistribute it and/or modify it
        -: 5605:   under the terms of the GNU General Public License as published by the
        -: 5606:   Free Software Foundation; either version 2, or (at your option) any
        -: 5607:   later version.
        -: 5608:
        -: 5609:   This program is distributed in the hope that it will be useful,
        -: 5610:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 5611:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 5612:   GNU General Public License for more details.
        -: 5613:
        -: 5614:   You should have received a copy of the GNU General Public License
        -: 5615:   along with this program; if not, write to the Free Software
        -: 5616:   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
        -: 5617:   USA.  */
        -: 5618:
        -: 5619:#ifdef HAVE_CONFIG_H
        -: 5620:#include "config.h"
        -: 5621:#endif
        -: 5622:
        -: 5623:#include "getopt.h"
        -: 5624:
        -: 5625:#if !defined __STDC__ || !__STDC__
        -: 5626:/* This is a separate conditional since some stdc systems
        -: 5627:   reject `defined (const)'.  */
        -: 5628:#ifndef const
        -: 5629:#define const
        -: 5630:#endif
        -: 5631:#endif
        -: 5632:
        -: 5633:#include <stdio.h>
        -: 5634:
        -: 5635:/* Comment out all this code if we are using the GNU C Library, and are not
        -: 5636:   actually compiling the library itself.  This code is part of the GNU C
        -: 5637:   Library, but also included in many other GNU distributions.  Compiling
        -: 5638:   and linking in this code is a waste when using the GNU C library
        -: 5639:   (especially if it is a shared library).  Rather than having every GNU
        -: 5640:   program understand `configure --with-gnu-libc' and omit the object files,
        -: 5641:   it is simpler to just do this in the source for each such file.  */
        -: 5642:
        -: 5643:#define GETOPT_INTERFACE_VERSION 2
        -: 5644:#if !defined _LIBC && defined __GLIBC__ && __GLIBC__ >= 2
        -: 5645:#include <gnu-versions.h>
        -: 5646:#if _GNU_GETOPT_INTERFACE_VERSION == GETOPT_INTERFACE_VERSION
        -: 5647:#define ELIDE_CODE
        -: 5648:#endif
        -: 5649:#endif
        -: 5650:
        -: 5651:#ifndef ELIDE_CODE
        -: 5652:
        -: 5653:
        -: 5654:/* This needs to come after some library #include
        -: 5655:   to get __GNU_LIBRARY__ defined.  */
        -: 5656:#ifdef __GNU_LIBRARY__
        -: 5657:#include <stdlib.h>
        -: 5658:#endif
        -: 5659:
        -: 5660:#ifndef	NULL
        -: 5661:#define NULL 0
        -: 5662:#endif
        -: 5663:
        -: 5664:int
        -: 5665:getopt_long (argc, argv, options, long_options, opt_index)
        -: 5666:     int argc;
        -: 5667:     char *const *argv;
        -: 5668:     const char *options;
        -: 5669:     const struct option *long_options;
        -: 5670:     int *opt_index;
        -: 5671:{
        -: 5672:  return _getopt_internal (argc, argv, options, long_options, opt_index, 0);
        -: 5673:}
        -: 5674:
        -: 5675:/* Like getopt_long, but '-' as well as '--' can indicate a long option.
        -: 5676:   If an option that starts with '-' (not '--') doesn't match a long option,
        -: 5677:   but does match a short option, it is parsed as a short option
        -: 5678:   instead.  */
        -: 5679:
        -: 5680:int
        -: 5681:getopt_long_only (argc, argv, options, long_options, opt_index)
        -: 5682:     int argc;
        -: 5683:     char *const *argv;
        -: 5684:     const char *options;
        -: 5685:     const struct option *long_options;
        -: 5686:     int *opt_index;
        -: 5687:{
        -: 5688:  return _getopt_internal (argc, argv, options, long_options, opt_index, 1);
        -: 5689:}
        -: 5690:
        -: 5691:
        -: 5692:#endif	/* Not ELIDE_CODE.  */
        -: 5693:
        -: 5694:#ifdef TEST
        -: 5695:
        -: 5696:#include <stdio.h>
        -: 5697:
        -: 5698:int
        -: 5699:main (argc, argv)
        -: 5700:     int argc;
        -: 5701:     char **argv;
        -: 5702:{
        -: 5703:  int c;
        -: 5704:  int digit_optind = 0;
        -: 5705:
        -: 5706:  while (1)
        -: 5707:    {
        -: 5708:      int this_option_optind = optind ? optind : 1;
        -: 5709:      int option_index = 0;
        -: 5710:      static struct option long_options[] =
        -: 5711:      {
        -: 5712:	{"add", 1, 0, 0},
        -: 5713:	{"append", 0, 0, 0},
        -: 5714:	{"delete", 1, 0, 0},
        -: 5715:	{"verbose", 0, 0, 0},
        -: 5716:	{"create", 0, 0, 0},
        -: 5717:	{"file", 1, 0, 0},
        -: 5718:	{0, 0, 0, 0}
        -: 5719:      };
        -: 5720:
        -: 5721:      c = getopt_long (argc, argv, "abc:d:0123456789",
        -: 5722:		       long_options, &option_index);
        -: 5723:      if (c == -1)
        -: 5724:	break;
        -: 5725:
        -: 5726:      switch (c)
        -: 5727:	{
        -: 5728:	case 0:
        -: 5729:	  printf ("option %s", long_options[option_index].name);
        -: 5730:	  if (optarg)
        -: 5731:	    printf (" with arg %s", optarg);
        -: 5732:	  printf ("\n");
        -: 5733:	  break;
        -: 5734:
        -: 5735:	case '0':
        -: 5736:	case '1':
        -: 5737:	case '2':
        -: 5738:	case '3':
        -: 5739:	case '4':
        -: 5740:	case '5':
        -: 5741:	case '6':
        -: 5742:	case '7':
        -: 5743:	case '8':
        -: 5744:	case '9':
        -: 5745:	  if (digit_optind != 0 && digit_optind != this_option_optind)
        -: 5746:	    printf ("digits occur in two different argv-elements.\n");
        -: 5747:	  digit_optind = this_option_optind;
        -: 5748:	  printf ("option %c\n", c);
        -: 5749:	  break;
        -: 5750:
        -: 5751:	case 'a':
        -: 5752:	  printf ("option a\n");
        -: 5753:	  break;
        -: 5754:
        -: 5755:	case 'b':
        -: 5756:	  printf ("option b\n");
        -: 5757:	  break;
        -: 5758:
        -: 5759:	case 'c':
        -: 5760:	  printf ("option c with value `%s'\n", optarg);
        -: 5761:	  break;
        -: 5762:
        -: 5763:	case 'd':
        -: 5764:	  printf ("option d with value `%s'\n", optarg);
        -: 5765:	  break;
        -: 5766:
        -: 5767:	case '?':
        -: 5768:	  break;
        -: 5769:
        -: 5770:	default:
        -: 5771:	  printf ("?? getopt returned character code 0%o ??\n", c);
        -: 5772:	}
        -: 5773:    }
        -: 5774:
        -: 5775:  if (optind < argc)
        -: 5776:    {
        -: 5777:      printf ("non-option ARGV-elements: ");
        -: 5778:      while (optind < argc)
        -: 5779:	printf ("%s ", argv[optind++]);
        -: 5780:      printf ("\n");
        -: 5781:    }
        -: 5782:
        -: 5783:  exit (0);
        -: 5784:}
        -: 5785:
        -: 5786:#endif /* TEST */
        -: 5787:/* Getopt for GNU.
        -: 5788:   NOTE: getopt is now part of the C library, so if you don't know what
        -: 5789:   "Keep this file name-space clean" means, talk to drepper@gnu.org
        -: 5790:   before changing it!
        -: 5791:
        -: 5792:   Copyright (C) 1987, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98
        -: 5793:   	Free Software Foundation, Inc.
        -: 5794:
        -: 5795:   NOTE: The canonical source of this file is maintained with the GNU C Library.
        -: 5796:   Bugs can be reported to bug-glibc@gnu.org.
        -: 5797:
        -: 5798:   This program is free software; you can redistribute it and/or modify it
        -: 5799:   under the terms of the GNU General Public License as published by the
        -: 5800:   Free Software Foundation; either version 2, or (at your option) any
        -: 5801:   later version.
        -: 5802:
        -: 5803:   This program is distributed in the hope that it will be useful,
        -: 5804:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 5805:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 5806:   GNU General Public License for more details.
        -: 5807:
        -: 5808:   You should have received a copy of the GNU General Public License
        -: 5809:   along with this program; if not, write to the Free Software
        -: 5810:   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
        -: 5811:   USA.  */
        -: 5812:
        -: 5813:/* This tells Alpha OSF/1 not to define a getopt prototype in <stdio.h>.
        -: 5814:   Ditto for AIX 3.2 and <stdlib.h>.  */
        -: 5815:#ifndef _NO_PROTO
        -: 5816:# define _NO_PROTO
        -: 5817:#endif
        -: 5818:
        -: 5819:#ifdef HAVE_CONFIG_H
        -: 5820:# include <config.h>
        -: 5821:#endif
        -: 5822:
        -: 5823:#if !defined __STDC__ || !__STDC__
        -: 5824:/* This is a separate conditional since some stdc systems
        -: 5825:   reject `defined (const)'.  */
        -: 5826:# ifndef const
        -: 5827:#  define const
        -: 5828:# endif
        -: 5829:#endif
        -: 5830:
        -: 5831:#include <stdio.h>
        -: 5832:
        -: 5833:/* Comment out all this code if we are using the GNU C Library, and are not
        -: 5834:   actually compiling the library itself.  This code is part of the GNU C
        -: 5835:   Library, but also included in many other GNU distributions.  Compiling
        -: 5836:   and linking in this code is a waste when using the GNU C library
        -: 5837:   (especially if it is a shared library).  Rather than having every GNU
        -: 5838:   program understand `configure --with-gnu-libc' and omit the object files,
        -: 5839:   it is simpler to just do this in the source for each such file.  */
        -: 5840:
        -: 5841:#define GETOPT_INTERFACE_VERSION 2
        -: 5842:#if !defined _LIBC && defined __GLIBC__ && __GLIBC__ >= 2
        -: 5843:# include <gnu-versions.h>
        -: 5844:# if _GNU_GETOPT_INTERFACE_VERSION == GETOPT_INTERFACE_VERSION
        -: 5845:#  define ELIDE_CODE
        -: 5846:# endif
        -: 5847:#endif
        -: 5848:
        -: 5849:#ifndef ELIDE_CODE
        -: 5850:
        -: 5851:
        -: 5852:/* This needs to come after some library #include
        -: 5853:   to get __GNU_LIBRARY__ defined.  */
        -: 5854:#ifdef	__GNU_LIBRARY__
        -: 5855:/* Don't include stdlib.h for non-GNU C libraries because some of them
        -: 5856:   contain conflicting prototypes for getopt.  */
        -: 5857:# include <stdlib.h>
        -: 5858:# include <unistd.h>
        -: 5859:#endif	/* GNU C library.  */
        -: 5860:
        -: 5861:#ifdef VMS
        -: 5862:# include <unixlib.h>
        -: 5863:# if HAVE_STRING_H - 0
        -: 5864:#  include <string.h>
        -: 5865:# endif
        -: 5866:#endif
        -: 5867:
        -: 5868:#ifndef _
        -: 5869:/* This is for other GNU distributions with internationalized messages.
        -: 5870:   When compiling libc, the _ macro is predefined.  */
        -: 5871:# ifdef HAVE_LIBINTL_H
        -: 5872:#  include <libintl.h>
        -: 5873:#  define _(msgid)	gettext (msgid)
        -: 5874:# else
        -: 5875:#  define _(msgid)	(msgid)
        -: 5876:# endif
        -: 5877:#endif
        -: 5878:
        -: 5879:/* This version of `getopt' appears to the caller like standard Unix `getopt'
        -: 5880:   but it behaves differently for the user, since it allows the user
        -: 5881:   to intersperse the options with the other arguments.
        -: 5882:
        -: 5883:   As `getopt' works, it permutes the elements of ARGV so that,
        -: 5884:   when it is done, all the options precede everything else.  Thus
        -: 5885:   all application programs are extended to handle flexible argument order.
        -: 5886:
        -: 5887:   Setting the environment variable POSIXLY_CORRECT disables permutation.
        -: 5888:   Then the behavior is completely standard.
        -: 5889:
        -: 5890:   GNU application programs can use a third alternative mode in which
        -: 5891:   they can distinguish the relative order of options and other arguments.  */
        -: 5892:
        -: 5893:#include "getopt.h"
        -: 5894:
        -: 5895:/* For communication from `getopt' to the caller.
        -: 5896:   When `getopt' finds an option that takes an argument,
        -: 5897:   the argument value is returned here.
        -: 5898:   Also, when `ordering' is RETURN_IN_ORDER,
        -: 5899:   each non-option ARGV-element is returned here.  */
        -: 5900:
        -: 5901:char *optarg = NULL;
        -: 5902:
        -: 5903:/* Index in ARGV of the next element to be scanned.
        -: 5904:   This is used for communication to and from the caller
        -: 5905:   and for communication between successive calls to `getopt'.
        -: 5906:
        -: 5907:   On entry to `getopt', zero means this is the first call; initialize.
        -: 5908:
        -: 5909:   When `getopt' returns -1, this is the index of the first of the
        -: 5910:   non-option elements that the caller should itself scan.
        -: 5911:
        -: 5912:   Otherwise, `optind' communicates from one call to the next
        -: 5913:   how much of ARGV has been scanned so far.  */
        -: 5914:
        -: 5915:/* 1003.2 says this must be 1 before any call.  */
        -: 5916:int optind = 1;
        -: 5917:
        -: 5918:/* Formerly, initialization of getopt depended on optind==0, which
        -: 5919:   causes problems with re-calling getopt as programs generally don't
        -: 5920:   know that. */
        -: 5921:
        -: 5922:int __getopt_initialized = 0;
        -: 5923:
        -: 5924:/* The next char to be scanned in the option-element
        -: 5925:   in which the last option character we returned was found.
        -: 5926:   This allows us to pick up the scan where we left off.
        -: 5927:
        -: 5928:   If this is zero, or a null string, it means resume the scan
        -: 5929:   by advancing to the next ARGV-element.  */
        -: 5930:
        -: 5931:static char *nextchar;
        -: 5932:
        -: 5933:/* Callers store zero here to inhibit the error message
        -: 5934:   for unrecognized options.  */
        -: 5935:
        -: 5936:int opterr = 1;
        -: 5937:
        -: 5938:/* Set to an option character which was unrecognized.
        -: 5939:   This must be initialized on some systems to avoid linking in the
        -: 5940:   system's own getopt implementation.  */
        -: 5941:
        -: 5942:int optopt = '?';
        -: 5943:
        -: 5944:/* Describe how to deal with options that follow non-option ARGV-elements.
        -: 5945:
        -: 5946:   If the caller did not specify anything,
        -: 5947:   the default is REQUIRE_ORDER if the environment variable
        -: 5948:   POSIXLY_CORRECT is defined, PERMUTE otherwise.
        -: 5949:
        -: 5950:   REQUIRE_ORDER means don't recognize them as options;
        -: 5951:   stop option processing when the first non-option is seen.
        -: 5952:   This is what Unix does.
        -: 5953:   This mode of operation is selected by either setting the environment
        -: 5954:   variable POSIXLY_CORRECT, or using `+' as the first character
        -: 5955:   of the list of option characters.
        -: 5956:
        -: 5957:   PERMUTE is the default.  We permute the contents of ARGV as we scan,
        -: 5958:   so that eventually all the non-options are at the end.  This allows options
        -: 5959:   to be given in any order, even with programs that were not written to
        -: 5960:   expect this.
        -: 5961:
        -: 5962:   RETURN_IN_ORDER is an option available to programs that were written
        -: 5963:   to expect options and other ARGV-elements in any order and that care about
        -: 5964:   the ordering of the two.  We describe each non-option ARGV-element
        -: 5965:   as if it were the argument of an option with character code 1.
        -: 5966:   Using `-' as the first character of the list of option characters
        -: 5967:   selects this mode of operation.
        -: 5968:
        -: 5969:   The special argument `--' forces an end of option-scanning regardless
        -: 5970:   of the value of `ordering'.  In the case of RETURN_IN_ORDER, only
        -: 5971:   `--' can cause `getopt' to return -1 with `optind' != ARGC.  */
        -: 5972:
        -: 5973:static enum
        -: 5974:{
        -: 5975:  REQUIRE_ORDER, PERMUTE, RETURN_IN_ORDER
        -: 5976:} ordering;
        -: 5977:
        -: 5978:/* Value of POSIXLY_CORRECT environment variable.  */
        -: 5979:static char *posixly_correct;
        -: 5980:
        -: 5981:#ifdef	__GNU_LIBRARY__
        -: 5982:/* We want to avoid inclusion of string.h with non-GNU libraries
        -: 5983:   because there are many ways it can cause trouble.
        -: 5984:   On some systems, it contains special magic macros that don't work
        -: 5985:   in GCC.  */
        -: 5986:# include <string.h>
        -: 5987:# define my_index	strchr
        -: 5988:#else
        -: 5989:
        -: 5990:/* Avoid depending on library functions or files
        -: 5991:   whose names are inconsistent.  */
        -: 5992:
        -: 5993:#ifndef getenv
        -: 5994:extern char *getenv ();
        -: 5995:#endif
        -: 5996:#ifndef strncmp
        -: 5997:extern int strncmp ();
        -: 5998:#endif
        -: 5999:
        -: 6000:static char *
        -: 6001:my_index (str, chr)
        -: 6002:     const char *str;
        -: 6003:     int chr;
        -: 6004:{
        -: 6005:  while (*str)
        -: 6006:    {
        -: 6007:      if (*str == chr)
        -: 6008:	return (char *) str;
        -: 6009:      str++;
        -: 6010:    }
        -: 6011:  return 0;
        -: 6012:}
        -: 6013:
        -: 6014:/* If using GCC, we can safely declare strlen this way.
        -: 6015:   If not using GCC, it is ok not to declare it.  */
        -: 6016:#ifdef __GNUC__
        -: 6017:/* Note that Motorola Delta 68k R3V7 comes with GCC but not stddef.h.
        -: 6018:   That was relevant to code that was here before.  */
        -: 6019:# if (!defined __STDC__ || !__STDC__) && !defined strlen
        -: 6020:/* gcc with -traditional declares the built-in strlen to return int,
        -: 6021:   and has done so at least since version 2.4.5. -- rms.  */
        -: 6022:extern int strlen (const char *);
        -: 6023:# endif /* not __STDC__ */
        -: 6024:#endif /* __GNUC__ */
        -: 6025:
        -: 6026:#endif /* not __GNU_LIBRARY__ */
        -: 6027:
        -: 6028:/* Handle permutation of arguments.  */
        -: 6029:
        -: 6030:/* Describe the part of ARGV that contains non-options that have
        -: 6031:   been skipped.  `first_nonopt' is the index in ARGV of the first of them;
        -: 6032:   `last_nonopt' is the index after the last of them.  */
        -: 6033:
        -: 6034:static int first_nonopt;
        -: 6035:static int last_nonopt;
        -: 6036:
        -: 6037:#ifdef _LIBC
        -: 6038:/* Bash 2.0 gives us an environment variable containing flags
        -: 6039:   indicating ARGV elements that should not be considered arguments.  */
        -: 6040:
        -: 6041:/* Defined in getopt_init.c  */
        -: 6042:extern char *__getopt_nonoption_flags;
        -: 6043:
        -: 6044:static int nonoption_flags_max_len;
        -: 6045:static int nonoption_flags_len;
        -: 6046:
        -: 6047:static int original_argc;
        -: 6048:static char *const *original_argv;
        -: 6049:
        -: 6050:/* Make sure the environment variable bash 2.0 puts in the environment
        -: 6051:   is valid for the getopt call we must make sure that the ARGV passed
        -: 6052:   to getopt is that one passed to the process.  */
        -: 6053:static void
        -: 6054:__attribute__ ((unused))
        -: 6055:store_args_and_env (int argc, char *const *argv)
        -: 6056:{
        -: 6057:  /* XXX This is no good solution.  We should rather copy the args so
        -: 6058:     that we can compare them later.  But we must not use malloc(3).  */
        -: 6059:  original_argc = argc;
        -: 6060:  original_argv = argv;
        -: 6061:}
        -: 6062:# ifdef text_set_element
        -: 6063:text_set_element (__libc_subinit, store_args_and_env);
        -: 6064:# endif /* text_set_element */
        -: 6065:
        -: 6066:# define SWAP_FLAGS(ch1, ch2) \
        -: 6067:  if (nonoption_flags_len > 0)						      \
        -: 6068:    {									      \
        -: 6069:      char __tmp = __getopt_nonoption_flags[ch1];			      \
        -: 6070:      __getopt_nonoption_flags[ch1] = __getopt_nonoption_flags[ch2];	      \
        -: 6071:      __getopt_nonoption_flags[ch2] = __tmp;				      \
        -: 6072:    }
        -: 6073:#else	/* !_LIBC */
        -: 6074:# define SWAP_FLAGS(ch1, ch2)
        -: 6075:#endif	/* _LIBC */
        -: 6076:
        -: 6077:/* Exchange two adjacent subsequences of ARGV.
        -: 6078:   One subsequence is elements [first_nonopt,last_nonopt)
        -: 6079:   which contains all the non-options that have been skipped so far.
        -: 6080:   The other is elements [last_nonopt,optind), which contains all
        -: 6081:   the options processed since those non-options were skipped.
        -: 6082:
        -: 6083:   `first_nonopt' and `last_nonopt' are relocated so that they describe
        -: 6084:   the new indices of the non-options in ARGV after they are moved.  */
        -: 6085:
        -: 6086:#if defined __STDC__ && __STDC__
        -: 6087:static void exchange (char **);
        -: 6088:#endif
        -: 6089:
        -: 6090:static void
        -: 6091:exchange (argv)
        -: 6092:     char **argv;
        -: 6093:{
        -: 6094:  int bottom = first_nonopt;
        -: 6095:  int middle = last_nonopt;
        -: 6096:  int top = optind;
        -: 6097:  char *tem;
        -: 6098:
        -: 6099:  /* Exchange the shorter segment with the far end of the longer segment.
        -: 6100:     That puts the shorter segment into the right place.
        -: 6101:     It leaves the longer segment in the right place overall,
        -: 6102:     but it consists of two parts that need to be swapped next.  */
        -: 6103:
        -: 6104:#ifdef _LIBC
        -: 6105:  /* First make sure the handling of the `__getopt_nonoption_flags'
        -: 6106:     string can work normally.  Our top argument must be in the range
        -: 6107:     of the string.  */
        -: 6108:  if (nonoption_flags_len > 0 && top >= nonoption_flags_max_len)
        -: 6109:    {
        -: 6110:      /* We must extend the array.  The user plays games with us and
        -: 6111:	 presents new arguments.  */
        -: 6112:      char *new_str = malloc (top + 1);
        -: 6113:      if (new_str == NULL)
        -: 6114:	nonoption_flags_len = nonoption_flags_max_len = 0;
        -: 6115:      else
        -: 6116:	{
        -: 6117:	  memset (__mempcpy (new_str, __getopt_nonoption_flags,
        -: 6118:			     nonoption_flags_max_len),
        -: 6119:		  '\0', top + 1 - nonoption_flags_max_len);
        -: 6120:	  nonoption_flags_max_len = top + 1;
        -: 6121:	  __getopt_nonoption_flags = new_str;
        -: 6122:	}
        -: 6123:    }
        -: 6124:#endif
        -: 6125:
        -: 6126:  while (top > middle && middle > bottom)
        -: 6127:    {
        -: 6128:      if (top - middle > middle - bottom)
        -: 6129:	{
        -: 6130:	  /* Bottom segment is the short one.  */
        -: 6131:	  int len = middle - bottom;
        -: 6132:	  register int i;
        -: 6133:
        -: 6134:	  /* Swap it with the top part of the top segment.  */
        -: 6135:	  for (i = 0; i < len; i++)
        -: 6136:	    {
        -: 6137:	      tem = argv[bottom + i];
        -: 6138:	      argv[bottom + i] = argv[top - (middle - bottom) + i];
        -: 6139:	      argv[top - (middle - bottom) + i] = tem;
        -: 6140:	      SWAP_FLAGS (bottom + i, top - (middle - bottom) + i);
        -: 6141:	    }
        -: 6142:	  /* Exclude the moved bottom segment from further swapping.  */
        -: 6143:	  top -= len;
        -: 6144:	}
        -: 6145:      else
        -: 6146:	{
        -: 6147:	  /* Top segment is the short one.  */
        -: 6148:	  int len = top - middle;
        -: 6149:	  register int i;
        -: 6150:
        -: 6151:	  /* Swap it with the bottom part of the bottom segment.  */
        -: 6152:	  for (i = 0; i < len; i++)
        -: 6153:	    {
        -: 6154:	      tem = argv[bottom + i];
        -: 6155:	      argv[bottom + i] = argv[middle + i];
        -: 6156:	      argv[middle + i] = tem;
        -: 6157:	      SWAP_FLAGS (bottom + i, middle + i);
        -: 6158:	    }
        -: 6159:	  /* Exclude the moved top segment from further swapping.  */
        -: 6160:	  bottom += len;
        -: 6161:	}
        -: 6162:    }
        -: 6163:
        -: 6164:  /* Update records for the slots the non-options now occupy.  */
        -: 6165:
        -: 6166:  first_nonopt += (optind - last_nonopt);
        -: 6167:  last_nonopt = optind;
        -: 6168:}
        -: 6169:
        -: 6170:/* Initialize the internal data when the first call is made.  */
        -: 6171:
        -: 6172:#if defined __STDC__ && __STDC__
        -: 6173:static const char *_getopt_initialize (int, char *const *, const char *);
        -: 6174:#endif
        -: 6175:static const char *
        -: 6176:_getopt_initialize (argc, argv, optstring)
        -: 6177:     int argc;
        -: 6178:     char *const *argv;
        -: 6179:     const char *optstring;
        -: 6180:{
        -: 6181:  /* Start processing options with ARGV-element 1 (since ARGV-element 0
        -: 6182:     is the program name); the sequence of previously skipped
        -: 6183:     non-option ARGV-elements is empty.  */
        -: 6184:
        -: 6185:  first_nonopt = last_nonopt = optind;
        -: 6186:
        -: 6187:  nextchar = NULL;
        -: 6188:
        -: 6189:  posixly_correct = getenv ("POSIXLY_CORRECT");
        -: 6190:
        -: 6191:  /* Determine how to handle the ordering of options and nonoptions.  */
        -: 6192:
        -: 6193:  if (optstring[0] == '-')
        -: 6194:    {
        -: 6195:      ordering = RETURN_IN_ORDER;
        -: 6196:      ++optstring;
        -: 6197:    }
        -: 6198:  else if (optstring[0] == '+')
        -: 6199:    {
        -: 6200:      ordering = REQUIRE_ORDER;
        -: 6201:      ++optstring;
        -: 6202:    }
        -: 6203:  else if (posixly_correct != NULL)
        -: 6204:    ordering = REQUIRE_ORDER;
        -: 6205:  else
        -: 6206:    ordering = PERMUTE;
        -: 6207:
        -: 6208:#ifdef _LIBC
        -: 6209:  if (posixly_correct == NULL
        -: 6210:      && argc == original_argc && argv == original_argv)
        -: 6211:    {
        -: 6212:      if (nonoption_flags_max_len == 0)
        -: 6213:	{
        -: 6214:	  if (__getopt_nonoption_flags == NULL
        -: 6215:	      || __getopt_nonoption_flags[0] == '\0')
        -: 6216:	    nonoption_flags_max_len = -1;
        -: 6217:	  else
        -: 6218:	    {
        -: 6219:	      const char *orig_str = __getopt_nonoption_flags;
        -: 6220:	      int len = nonoption_flags_max_len = strlen (orig_str);
        -: 6221:	      if (nonoption_flags_max_len < argc)
        -: 6222:		nonoption_flags_max_len = argc;
        -: 6223:	      __getopt_nonoption_flags =
        -: 6224:		(char *) malloc (nonoption_flags_max_len);
        -: 6225:	      if (__getopt_nonoption_flags == NULL)
        -: 6226:		nonoption_flags_max_len = -1;
        -: 6227:	      else
        -: 6228:		memset (__mempcpy (__getopt_nonoption_flags, orig_str, len),
        -: 6229:			'\0', nonoption_flags_max_len - len);
        -: 6230:	    }
        -: 6231:	}
        -: 6232:      nonoption_flags_len = nonoption_flags_max_len;
        -: 6233:    }
        -: 6234:  else
        -: 6235:    nonoption_flags_len = 0;
        -: 6236:#endif
        -: 6237:
        -: 6238:  return optstring;
        -: 6239:}
        -: 6240:
        -: 6241:/* Scan elements of ARGV (whose length is ARGC) for option characters
        -: 6242:   given in OPTSTRING.
        -: 6243:
        -: 6244:   If an element of ARGV starts with '-', and is not exactly "-" or "--",
        -: 6245:   then it is an option element.  The characters of this element
        -: 6246:   (aside from the initial '-') are option characters.  If `getopt'
        -: 6247:   is called repeatedly, it returns successively each of the option characters
        -: 6248:   from each of the option elements.
        -: 6249:
        -: 6250:   If `getopt' finds another option character, it returns that character,
        -: 6251:   updating `optind' and `nextchar' so that the next call to `getopt' can
        -: 6252:   resume the scan with the following option character or ARGV-element.
        -: 6253:
        -: 6254:   If there are no more option characters, `getopt' returns -1.
        -: 6255:   Then `optind' is the index in ARGV of the first ARGV-element
        -: 6256:   that is not an option.  (The ARGV-elements have been permuted
        -: 6257:   so that those that are not options now come last.)
        -: 6258:
        -: 6259:   OPTSTRING is a string containing the legitimate option characters.
        -: 6260:   If an option character is seen that is not listed in OPTSTRING,
        -: 6261:   return '?' after printing an error message.  If you set `opterr' to
        -: 6262:   zero, the error message is suppressed but we still return '?'.
        -: 6263:
        -: 6264:   If a char in OPTSTRING is followed by a colon, that means it wants an arg,
        -: 6265:   so the following text in the same ARGV-element, or the text of the following
        -: 6266:   ARGV-element, is returned in `optarg'.  Two colons mean an option that
        -: 6267:   wants an optional arg; if there is text in the current ARGV-element,
        -: 6268:   it is returned in `optarg', otherwise `optarg' is set to zero.
        -: 6269:
        -: 6270:   If OPTSTRING starts with `-' or `+', it requests different methods of
        -: 6271:   handling the non-option ARGV-elements.
        -: 6272:   See the comments about RETURN_IN_ORDER and REQUIRE_ORDER, above.
        -: 6273:
        -: 6274:   Long-named options begin with `--' instead of `-'.
        -: 6275:   Their names may be abbreviated as long as the abbreviation is unique
        -: 6276:   or is an exact match for some defined option.  If they have an
        -: 6277:   argument, it follows the option name in the same ARGV-element, separated
        -: 6278:   from the option name by a `=', or else the in next ARGV-element.
        -: 6279:   When `getopt' finds a long-named option, it returns 0 if that option's
        -: 6280:   `flag' field is nonzero, the value of the option's `val' field
        -: 6281:   if the `flag' field is zero.
        -: 6282:
        -: 6283:   The elements of ARGV aren't really const, because we permute them.
        -: 6284:   But we pretend they're const in the prototype to be compatible
        -: 6285:   with other systems.
        -: 6286:
        -: 6287:   LONGOPTS is a vector of `struct option' terminated by an
        -: 6288:   element containing a name which is zero.
        -: 6289:
        -: 6290:   LONGIND returns the index in LONGOPT of the long-named option found.
        -: 6291:   It is only valid when a long-named option has been found by the most
        -: 6292:   recent call.
        -: 6293:
        -: 6294:   If LONG_ONLY is nonzero, '-' as well as '--' can introduce
        -: 6295:   long-named options.  */
        -: 6296:
        -: 6297:int
        -: 6298:_getopt_internal (argc, argv, optstring, longopts, longind, long_only)
        -: 6299:     int argc;
        -: 6300:     char *const *argv;
        -: 6301:     const char *optstring;
        -: 6302:     const struct option *longopts;
        -: 6303:     int *longind;
        -: 6304:     int long_only;
        -: 6305:{
        -: 6306:  optarg = NULL;
        -: 6307:
        -: 6308:  if (optind == 0 || !__getopt_initialized)
        -: 6309:    {
        -: 6310:      if (optind == 0)
        -: 6311:	optind = 1;	/* Don't scan ARGV[0], the program name.  */
        -: 6312:      optstring = _getopt_initialize (argc, argv, optstring);
        -: 6313:      __getopt_initialized = 1;
        -: 6314:    }
        -: 6315:
        -: 6316:  /* Test whether ARGV[optind] points to a non-option argument.
        -: 6317:     Either it does not have option syntax, or there is an environment flag
        -: 6318:     from the shell indicating it is not an option.  The later information
        -: 6319:     is only used when the used in the GNU libc.  */
        -: 6320:#ifdef _LIBC
        -: 6321:# define NONOPTION_P (argv[optind][0] != '-' || argv[optind][1] == '\0'	      \
        -: 6322:		      || (optind < nonoption_flags_len			      \
        -: 6323:			  && __getopt_nonoption_flags[optind] == '1'))
        -: 6324:#else
        -: 6325:# define NONOPTION_P (argv[optind][0] != '-' || argv[optind][1] == '\0')
        -: 6326:#endif
        -: 6327:
        -: 6328:  if (nextchar == NULL || *nextchar == '\0')
        -: 6329:    {
        -: 6330:      /* Advance to the next ARGV-element.  */
        -: 6331:
        -: 6332:      /* Give FIRST_NONOPT & LAST_NONOPT rational values if OPTIND has been
        -: 6333:	 moved back by the user (who may also have changed the arguments).  */
        -: 6334:      if (last_nonopt > optind)
        -: 6335:	last_nonopt = optind;
        -: 6336:      if (first_nonopt > optind)
        -: 6337:	first_nonopt = optind;
        -: 6338:
        -: 6339:      if (ordering == PERMUTE)
        -: 6340:	{
        -: 6341:	  /* If we have just processed some options following some non-options,
        -: 6342:	     exchange them so that the options come first.  */
        -: 6343:
        -: 6344:	  if (first_nonopt != last_nonopt && last_nonopt != optind)
        -: 6345:	    exchange ((char **) argv);
        -: 6346:	  else if (last_nonopt != optind)
        -: 6347:	    first_nonopt = optind;
        -: 6348:
        -: 6349:	  /* Skip any additional non-options
        -: 6350:	     and extend the range of non-options previously skipped.  */
        -: 6351:
        -: 6352:	  while (optind < argc && NONOPTION_P)
        -: 6353:	    optind++;
        -: 6354:	  last_nonopt = optind;
        -: 6355:	}
        -: 6356:
        -: 6357:      /* The special ARGV-element `--' means premature end of options.
        -: 6358:	 Skip it like a null option,
        -: 6359:	 then exchange with previous non-options as if it were an option,
        -: 6360:	 then skip everything else like a non-option.  */
        -: 6361:
        -: 6362:      if (optind != argc && !strcmp (argv[optind], "--"))
        -: 6363:	{
        -: 6364:	  optind++;
        -: 6365:
        -: 6366:	  if (first_nonopt != last_nonopt && last_nonopt != optind)
        -: 6367:	    exchange ((char **) argv);
        -: 6368:	  else if (first_nonopt == last_nonopt)
        -: 6369:	    first_nonopt = optind;
        -: 6370:	  last_nonopt = argc;
        -: 6371:
        -: 6372:	  optind = argc;
        -: 6373:	}
        -: 6374:
        -: 6375:      /* If we have done all the ARGV-elements, stop the scan
        -: 6376:	 and back over any non-options that we skipped and permuted.  */
        -: 6377:
        -: 6378:      if (optind == argc)
        -: 6379:	{
        -: 6380:	  /* Set the next-arg-index to point at the non-options
        -: 6381:	     that we previously skipped, so the caller will digest them.  */
        -: 6382:	  if (first_nonopt != last_nonopt)
        -: 6383:	    optind = first_nonopt;
        -: 6384:	  return -1;
        -: 6385:	}
        -: 6386:
        -: 6387:      /* If we have come to a non-option and did not permute it,
        -: 6388:	 either stop the scan or describe it to the caller and pass it by.  */
        -: 6389:
        -: 6390:      if (NONOPTION_P)
        -: 6391:	{
        -: 6392:	  if (ordering == REQUIRE_ORDER)
        -: 6393:	    return -1;
        -: 6394:	  optarg = argv[optind++];
        -: 6395:	  return 1;
        -: 6396:	}
        -: 6397:
        -: 6398:      /* We have found another option-ARGV-element.
        -: 6399:	 Skip the initial punctuation.  */
        -: 6400:
        -: 6401:      nextchar = (argv[optind] + 1
        -: 6402:		  + (longopts != NULL && argv[optind][1] == '-'));
        -: 6403:    }
        -: 6404:
        -: 6405:  /* Decode the current option-ARGV-element.  */
        -: 6406:
        -: 6407:  /* Check whether the ARGV-element is a long option.
        -: 6408:
        -: 6409:     If long_only and the ARGV-element has the form "-f", where f is
        -: 6410:     a valid short option, don't consider it an abbreviated form of
        -: 6411:     a long option that starts with f.  Otherwise there would be no
        -: 6412:     way to give the -f short option.
        -: 6413:
        -: 6414:     On the other hand, if there's a long option "fubar" and
        -: 6415:     the ARGV-element is "-fu", do consider that an abbreviation of
        -: 6416:     the long option, just like "--fu", and not "-f" with arg "u".
        -: 6417:
        -: 6418:     This distinction seems to be the most useful approach.  */
        -: 6419:
        -: 6420:  if (longopts != NULL
        -: 6421:      && (argv[optind][1] == '-'
        -: 6422:	  || (long_only && (argv[optind][2] || !my_index (optstring, argv[optind][1])))))
        -: 6423:    {
        -: 6424:      char *nameend;
        -: 6425:      const struct option *p;
        -: 6426:      const struct option *pfound = NULL;
        -: 6427:      int exact = 0;
        -: 6428:      int ambig = 0;
        -: 6429:      int indfound = -1;
        -: 6430:      int option_index;
        -: 6431:
        -: 6432:      for (nameend = nextchar; *nameend && *nameend != '='; nameend++)
        -: 6433:	/* Do nothing.  */ ;
        -: 6434:
        -: 6435:      /* Test all long options for either exact match
        -: 6436:	 or abbreviated matches.  */
        -: 6437:      for (p = longopts, option_index = 0; p->name; p++, option_index++)
        -: 6438:	if (!strncmp (p->name, nextchar, nameend - nextchar))
        -: 6439:	  {
        -: 6440:	    if ((unsigned int) (nameend - nextchar)
        -: 6441:		== (unsigned int) strlen (p->name))
        -: 6442:	      {
        -: 6443:		/* Exact match found.  */
        -: 6444:		pfound = p;
        -: 6445:		indfound = option_index;
        -: 6446:		exact = 1;
        -: 6447:		break;
        -: 6448:	      }
        -: 6449:	    else if (pfound == NULL)
        -: 6450:	      {
        -: 6451:		/* First nonexact match found.  */
        -: 6452:		pfound = p;
        -: 6453:		indfound = option_index;
        -: 6454:	      }
        -: 6455:	    else
        -: 6456:	      /* Second or later nonexact match found.  */
        -: 6457:	      ambig = 1;
        -: 6458:	  }
        -: 6459:
        -: 6460:      if (ambig && !exact)
        -: 6461:	{
        -: 6462:	  if (opterr)
        -: 6463:	    fprintf (stderr, _("%s: option `%s' is ambiguous\n"),
        -: 6464:		     argv[0], argv[optind]);
        -: 6465:	  nextchar += strlen (nextchar);
        -: 6466:	  optind++;
        -: 6467:	  optopt = 0;
        -: 6468:	  return '?';
        -: 6469:	}
        -: 6470:
        -: 6471:      if (pfound != NULL)
        -: 6472:	{
        -: 6473:	  option_index = indfound;
        -: 6474:	  optind++;
        -: 6475:	  if (*nameend)
        -: 6476:	    {
        -: 6477:	      /* Don't test has_arg with >, because some C compilers don't
        -: 6478:		 allow it to be used on enums.  */
        -: 6479:	      if (pfound->has_arg)
        -: 6480:		optarg = nameend + 1;
        -: 6481:	      else
        -: 6482:		{
        -: 6483:		  if (opterr)
        -: 6484:		   if (argv[optind - 1][1] == '-')
        -: 6485:		    /* --option */
        -: 6486:		    fprintf (stderr,
        -: 6487:		     _("%s: option `--%s' doesn't allow an argument\n"),
        -: 6488:		     argv[0], pfound->name);
        -: 6489:		   else
        -: 6490:		    /* +option or -option */
        -: 6491:		    fprintf (stderr,
        -: 6492:		     _("%s: option `%c%s' doesn't allow an argument\n"),
        -: 6493:		     argv[0], argv[optind - 1][0], pfound->name);
        -: 6494:
        -: 6495:		  nextchar += strlen (nextchar);
        -: 6496:
        -: 6497:		  optopt = pfound->val;
        -: 6498:		  return '?';
        -: 6499:		}
        -: 6500:	    }
        -: 6501:	  else if (pfound->has_arg == 1)
        -: 6502:	    {
        -: 6503:	      if (optind < argc)
        -: 6504:		optarg = argv[optind++];
        -: 6505:	      else
        -: 6506:		{
        -: 6507:		  if (opterr)
        -: 6508:		    fprintf (stderr,
        -: 6509:			   _("%s: option `%s' requires an argument\n"),
        -: 6510:			   argv[0], argv[optind - 1]);
        -: 6511:		  nextchar += strlen (nextchar);
        -: 6512:		  optopt = pfound->val;
        -: 6513:		  return optstring[0] == ':' ? ':' : '?';
        -: 6514:		}
        -: 6515:	    }
        -: 6516:	  nextchar += strlen (nextchar);
        -: 6517:	  if (longind != NULL)
        -: 6518:	    *longind = option_index;
        -: 6519:	  if (pfound->flag)
        -: 6520:	    {
        -: 6521:	      *(pfound->flag) = pfound->val;
        -: 6522:	      return 0;
        -: 6523:	    }
        -: 6524:	  return pfound->val;
        -: 6525:	}
        -: 6526:
        -: 6527:      /* Can't find it as a long option.  If this is not getopt_long_only,
        -: 6528:	 or the option starts with '--' or is not a valid short
        -: 6529:	 option, then it's an error.
        -: 6530:	 Otherwise interpret it as a short option.  */
        -: 6531:      if (!long_only || argv[optind][1] == '-'
        -: 6532:	  || my_index (optstring, *nextchar) == NULL)
        -: 6533:	{
        -: 6534:	  if (opterr)
        -: 6535:	    {
        -: 6536:	      if (argv[optind][1] == '-')
        -: 6537:		/* --option */
        -: 6538:		fprintf (stderr, _("%s: unrecognized option `--%s'\n"),
        -: 6539:			 argv[0], nextchar);
        -: 6540:	      else
        -: 6541:		/* +option or -option */
        -: 6542:		fprintf (stderr, _("%s: unrecognized option `%c%s'\n"),
        -: 6543:			 argv[0], argv[optind][0], nextchar);
        -: 6544:	    }
        -: 6545:	  nextchar = (char *) "";
        -: 6546:	  optind++;
        -: 6547:	  optopt = 0;
        -: 6548:	  return '?';
        -: 6549:	}
        -: 6550:    }
        -: 6551:
        -: 6552:  /* Look at and handle the next short option-character.  */
        -: 6553:
        -: 6554:  {
        -: 6555:    char c = *nextchar++;
        -: 6556:    char *temp = my_index (optstring, c);
        -: 6557:
        -: 6558:    /* Increment `optind' when we start to process its last character.  */
        -: 6559:    if (*nextchar == '\0')
        -: 6560:      ++optind;
        -: 6561:
        -: 6562:    if (temp == NULL || c == ':')
        -: 6563:      {
        -: 6564:	if (opterr)
        -: 6565:	  {
        -: 6566:	    if (posixly_correct)
        -: 6567:	      /* 1003.2 specifies the format of this message.  */
        -: 6568:	      fprintf (stderr, _("%s: illegal option -- %c\n"),
        -: 6569:		       argv[0], c);
        -: 6570:	    else
        -: 6571:	      fprintf (stderr, _("%s: invalid option -- %c\n"),
        -: 6572:		       argv[0], c);
        -: 6573:	  }
        -: 6574:	optopt = c;
        -: 6575:	return '?';
        -: 6576:      }
        -: 6577:    /* Convenience. Treat POSIX -W foo same as long option --foo */
        -: 6578:    if (temp[0] == 'W' && temp[1] == ';')
        -: 6579:      {
        -: 6580:	char *nameend;
        -: 6581:	const struct option *p;
        -: 6582:	const struct option *pfound = NULL;
        -: 6583:	int exact = 0;
        -: 6584:	int ambig = 0;
        -: 6585:	int indfound = 0;
        -: 6586:	int option_index;
        -: 6587:
        -: 6588:	/* This is an option that requires an argument.  */
        -: 6589:	if (*nextchar != '\0')
        -: 6590:	  {
        -: 6591:	    optarg = nextchar;
        -: 6592:	    /* If we end this ARGV-element by taking the rest as an arg,
        -: 6593:	       we must advance to the next element now.  */
        -: 6594:	    optind++;
        -: 6595:	  }
        -: 6596:	else if (optind == argc)
        -: 6597:	  {
        -: 6598:	    if (opterr)
        -: 6599:	      {
        -: 6600:		/* 1003.2 specifies the format of this message.  */
        -: 6601:		fprintf (stderr, _("%s: option requires an argument -- %c\n"),
        -: 6602:			 argv[0], c);
        -: 6603:	      }
        -: 6604:	    optopt = c;
        -: 6605:	    if (optstring[0] == ':')
        -: 6606:	      c = ':';
        -: 6607:	    else
        -: 6608:	      c = '?';
        -: 6609:	    return c;
        -: 6610:	  }
        -: 6611:	else
        -: 6612:	  /* We already incremented `optind' once;
        -: 6613:	     increment it again when taking next ARGV-elt as argument.  */
        -: 6614:	  optarg = argv[optind++];
        -: 6615:
        -: 6616:	/* optarg is now the argument, see if it's in the
        -: 6617:	   table of longopts.  */
        -: 6618:
        -: 6619:	for (nextchar = nameend = optarg; *nameend && *nameend != '='; nameend++)
        -: 6620:	  /* Do nothing.  */ ;
        -: 6621:
        -: 6622:	/* Test all long options for either exact match
        -: 6623:	   or abbreviated matches.  */
        -: 6624:	for (p = longopts, option_index = 0; p->name; p++, option_index++)
        -: 6625:	  if (!strncmp (p->name, nextchar, nameend - nextchar))
        -: 6626:	    {
        -: 6627:	      if ((unsigned int) (nameend - nextchar) == strlen (p->name))
        -: 6628:		{
        -: 6629:		  /* Exact match found.  */
        -: 6630:		  pfound = p;
        -: 6631:		  indfound = option_index;
        -: 6632:		  exact = 1;
        -: 6633:		  break;
        -: 6634:		}
        -: 6635:	      else if (pfound == NULL)
        -: 6636:		{
        -: 6637:		  /* First nonexact match found.  */
        -: 6638:		  pfound = p;
        -: 6639:		  indfound = option_index;
        -: 6640:		}
        -: 6641:	      else
        -: 6642:		/* Second or later nonexact match found.  */
        -: 6643:		ambig = 1;
        -: 6644:	    }
        -: 6645:	if (ambig && !exact)
        -: 6646:	  {
        -: 6647:	    if (opterr)
        -: 6648:	      fprintf (stderr, _("%s: option `-W %s' is ambiguous\n"),
        -: 6649:		       argv[0], argv[optind]);
        -: 6650:	    nextchar += strlen (nextchar);
        -: 6651:	    optind++;
        -: 6652:	    return '?';
        -: 6653:	  }
        -: 6654:	if (pfound != NULL)
        -: 6655:	  {
        -: 6656:	    option_index = indfound;
        -: 6657:	    if (*nameend)
        -: 6658:	      {
        -: 6659:		/* Don't test has_arg with >, because some C compilers don't
        -: 6660:		   allow it to be used on enums.  */
        -: 6661:		if (pfound->has_arg)
        -: 6662:		  optarg = nameend + 1;
        -: 6663:		else
        -: 6664:		  {
        -: 6665:		    if (opterr)
        -: 6666:		      fprintf (stderr, _("\
        -: 6667:%s: option `-W %s' doesn't allow an argument\n"),
        -: 6668:			       argv[0], pfound->name);
        -: 6669:
        -: 6670:		    nextchar += strlen (nextchar);
        -: 6671:		    return '?';
        -: 6672:		  }
        -: 6673:	      }
        -: 6674:	    else if (pfound->has_arg == 1)
        -: 6675:	      {
        -: 6676:		if (optind < argc)
        -: 6677:		  optarg = argv[optind++];
        -: 6678:		else
        -: 6679:		  {
        -: 6680:		    if (opterr)
        -: 6681:		      fprintf (stderr,
        -: 6682:			       _("%s: option `%s' requires an argument\n"),
        -: 6683:			       argv[0], argv[optind - 1]);
        -: 6684:		    nextchar += strlen (nextchar);
        -: 6685:		    return optstring[0] == ':' ? ':' : '?';
        -: 6686:		  }
        -: 6687:	      }
        -: 6688:	    nextchar += strlen (nextchar);
        -: 6689:	    if (longind != NULL)
        -: 6690:	      *longind = option_index;
        -: 6691:	    if (pfound->flag)
        -: 6692:	      {
        -: 6693:		*(pfound->flag) = pfound->val;
        -: 6694:		return 0;
        -: 6695:	      }
        -: 6696:	    return pfound->val;
        -: 6697:	  }
        -: 6698:	  nextchar = NULL;
        -: 6699:	  return 'W';	/* Let the application handle it.   */
        -: 6700:      }
        -: 6701:    if (temp[1] == ':')
        -: 6702:      {
        -: 6703:	if (temp[2] == ':')
        -: 6704:	  {
        -: 6705:	    /* This is an option that accepts an argument optionally.  */
        -: 6706:	    if (*nextchar != '\0')
        -: 6707:	      {
        -: 6708:		optarg = nextchar;
        -: 6709:		optind++;
        -: 6710:	      }
        -: 6711:	    else
        -: 6712:	      optarg = NULL;
        -: 6713:	    nextchar = NULL;
        -: 6714:	  }
        -: 6715:	else
        -: 6716:	  {
        -: 6717:	    /* This is an option that requires an argument.  */
        -: 6718:	    if (*nextchar != '\0')
        -: 6719:	      {
        -: 6720:		optarg = nextchar;
        -: 6721:		/* If we end this ARGV-element by taking the rest as an arg,
        -: 6722:		   we must advance to the next element now.  */
        -: 6723:		optind++;
        -: 6724:	      }
        -: 6725:	    else if (optind == argc)
        -: 6726:	      {
        -: 6727:		if (opterr)
        -: 6728:		  {
        -: 6729:		    /* 1003.2 specifies the format of this message.  */
        -: 6730:		    fprintf (stderr,
        -: 6731:			   _("%s: option requires an argument -- %c\n"),
        -: 6732:			   argv[0], c);
        -: 6733:		  }
        -: 6734:		optopt = c;
        -: 6735:		if (optstring[0] == ':')
        -: 6736:		  c = ':';
        -: 6737:		else
        -: 6738:		  c = '?';
        -: 6739:	      }
        -: 6740:	    else
        -: 6741:	      /* We already incremented `optind' once;
        -: 6742:		 increment it again when taking next ARGV-elt as argument.  */
        -: 6743:	      optarg = argv[optind++];
        -: 6744:	    nextchar = NULL;
        -: 6745:	  }
        -: 6746:      }
        -: 6747:    return c;
        -: 6748:  }
        -: 6749:}
        -: 6750:
        -: 6751:int
        -: 6752:getopt (argc, argv, optstring)
        -: 6753:     int argc;
        -: 6754:     char *const *argv;
        -: 6755:     const char *optstring;
        -: 6756:{
        -: 6757:  return _getopt_internal (argc, argv, optstring,
        -: 6758:			   (const struct option *) 0,
        -: 6759:			   (int *) 0,
        -: 6760:			   0);
        -: 6761:}
        -: 6762:
        -: 6763:#endif	/* Not ELIDE_CODE.  */
        -: 6764:
        -: 6765:#ifdef TEST
        -: 6766:
        -: 6767:/* Compile with -DTEST to make an executable for use in testing
        -: 6768:   the above definition of `getopt'.  */
        -: 6769:
        -: 6770:int
        -: 6771:main (argc, argv)
        -: 6772:     int argc;
        -: 6773:     char **argv;
        -: 6774:{
        -: 6775:  int c;
        -: 6776:  int digit_optind = 0;
        -: 6777:
        -: 6778:  while (1)
        -: 6779:    {
        -: 6780:      int this_option_optind = optind ? optind : 1;
        -: 6781:
        -: 6782:      c = getopt (argc, argv, "abc:d:0123456789");
        -: 6783:      if (c == -1)
        -: 6784:	break;
        -: 6785:
        -: 6786:      switch (c)
        -: 6787:	{
        -: 6788:	case '0':
        -: 6789:	case '1':
        -: 6790:	case '2':
        -: 6791:	case '3':
        -: 6792:	case '4':
        -: 6793:	case '5':
        -: 6794:	case '6':
        -: 6795:	case '7':
        -: 6796:	case '8':
        -: 6797:	case '9':
        -: 6798:	  if (digit_optind != 0 && digit_optind != this_option_optind)
        -: 6799:	    printf ("digits occur in two different argv-elements.\n");
        -: 6800:	  digit_optind = this_option_optind;
        -: 6801:	  printf ("option %c\n", c);
        -: 6802:	  break;
        -: 6803:
        -: 6804:	case 'a':
        -: 6805:	  printf ("option a\n");
        -: 6806:	  break;
        -: 6807:
        -: 6808:	case 'b':
        -: 6809:	  printf ("option b\n");
        -: 6810:	  break;
        -: 6811:
        -: 6812:	case 'c':
        -: 6813:	  printf ("option c with value `%s'\n", optarg);
        -: 6814:	  break;
        -: 6815:
        -: 6816:	case '?':
        -: 6817:	  break;
        -: 6818:
        -: 6819:	default:
        -: 6820:	  printf ("?? getopt returned character code 0%o ??\n", c);
        -: 6821:	}
        -: 6822:    }
        -: 6823:
        -: 6824:  if (optind < argc)
        -: 6825:    {
        -: 6826:      printf ("non-option ARGV-elements: ");
        -: 6827:      while (optind < argc)
        -: 6828:	printf ("%s ", argv[optind++]);
        -: 6829:      printf ("\n");
        -: 6830:    }
        -: 6831:
        -: 6832:  exit (0);
        -: 6833:}
        -: 6834:
        -: 6835:#endif /* TEST */
        -: 6836:/* Extended regular expression matching and search library.
        -: 6837:   Copyright (C) 2002, 2003, 2005 Free Software Foundation, Inc.
        -: 6838:   This file is part of the GNU C Library.
        -: 6839:   Contributed by Isamu Hasegawa <isamu@yamato.ibm.com>.
        -: 6840:
        -: 6841:   The GNU C Library is free software; you can redistribute it and/or
        -: 6842:   modify it under the terms of the GNU Lesser General Public
        -: 6843:   License as published by the Free Software Foundation; either
        -: 6844:   version 2.1 of the License, or (at your option) any later version.
        -: 6845:
        -: 6846:   The GNU C Library is distributed in the hope that it will be useful,
        -: 6847:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 6848:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
        -: 6849:   Lesser General Public License for more details.
        -: 6850:
        -: 6851:   You should have received a copy of the GNU Lesser General Public
        -: 6852:   License along with the GNU C Library; if not, write to the Free
        -: 6853:   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
        -: 6854:   02111-1307 USA.  */
        -: 6855:
        -: 6856:#ifdef HAVE_CONFIG_H
        -: 6857:#include "config.h"
        -: 6858:#endif
        -: 6859:
        -: 6860:/* Make sure noone compiles this code with a C++ compiler.  */
        -: 6861:#ifdef __cplusplus
        -: 6862:# error "This is C code, use a C compiler"
        -: 6863:#endif
        -: 6864:
        -: 6865:#ifdef _LIBC
        -: 6866:/* We have to keep the namespace clean.  */
        -: 6867:# define regfree(preg) __regfree (preg)
        -: 6868:# define regexec(pr, st, nm, pm, ef) __regexec (pr, st, nm, pm, ef)
        -: 6869:# define regcomp(preg, pattern, cflags) __regcomp (preg, pattern, cflags)
        -: 6870:# define regerror(errcode, preg, errbuf, errbuf_size) \
        -: 6871:	__regerror(errcode, preg, errbuf, errbuf_size)
        -: 6872:# define re_set_registers(bu, re, nu, st, en) \
        -: 6873:	__re_set_registers (bu, re, nu, st, en)
        -: 6874:# define re_match_2(bufp, string1, size1, string2, size2, pos, regs, stop) \
        -: 6875:	__re_match_2 (bufp, string1, size1, string2, size2, pos, regs, stop)
        -: 6876:# define re_match(bufp, string, size, pos, regs) \
        -: 6877:	__re_match (bufp, string, size, pos, regs)
        -: 6878:# define re_search(bufp, string, size, startpos, range, regs) \
        -: 6879:	__re_search (bufp, string, size, startpos, range, regs)
        -: 6880:# define re_compile_pattern(pattern, length, bufp) \
        -: 6881:	__re_compile_pattern (pattern, length, bufp)
        -: 6882:# define re_set_syntax(syntax) __re_set_syntax (syntax)
        -: 6883:# define re_search_2(bufp, st1, s1, st2, s2, startpos, range, regs, stop) \
        -: 6884:	__re_search_2 (bufp, st1, s1, st2, s2, startpos, range, regs, stop)
        -: 6885:# define re_compile_fastmap(bufp) __re_compile_fastmap (bufp)
        -: 6886:
        -: 6887:# include "../locale/localeinfo.h"
        -: 6888:#endif
        -: 6889:
        -: 6890:/* On some systems, limits.h sets RE_DUP_MAX to a lower value than
        -: 6891:   GNU regex allows.  Include it before <regex.h>, which correctly
        -: 6892:   #undefs RE_DUP_MAX and sets it to the right value.  */
        -: 6893:#include <limits.h>
        -: 6894:
        -: 6895:#include <regex.h>
        -: 6896:#include "regex_internal.h"
        -: 6897:
        -: 6898:#include "regex_internal.c"
        -: 6899:#include "regcomp.c"
        -: 6900:#include "regexec.c"
        -: 6901:
        -: 6902:/* Binary backward compatibility.  */
        -: 6903:#if _LIBC
        -: 6904:# include <shlib-compat.h>
        -: 6905:# if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_3)
        -: 6906:link_warning (re_max_failures, "the 're_max_failures' variable is obsolete and will go away.")
        -: 6907:int re_max_failures = 2000;
        -: 6908:# endif
        -: 6909:#endif
        -: 6910:/*  GNU SED, a batch stream editor.
        -: 6911:    Copyright (C) 1999, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
        -: 6912:
        -: 6913:    This program is free software; you can redistribute it and/or modify
        -: 6914:    it under the terms of the GNU General Public License as published by
        -: 6915:    the Free Software Foundation; either version 2, or (at your option)
        -: 6916:    any later version.
        -: 6917:
        -: 6918:    This program is distributed in the hope that it will be useful,
        -: 6919:    but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 6920:    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 6921:    GNU General Public License for more details.
        -: 6922:
        -: 6923:    You should have received a copy of the GNU General Public License
        -: 6924:    along with this program; if not, write to the Free Software
        -: 6925:    Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA. */
        -: 6926:
        -: 6927:#include <ctype.h>
        -: 6928:#include <stdio.h>
        -: 6929:#ifdef HAVE_STDLIB_H
        -: 6930:# include <stdlib.h>
        -: 6931:#endif
        -: 6932:
        -: 6933:extern bool use_extended_syntax_p;
        -: 6934:
        -: 6935:/* Modified to allow *.c file merger for SIR
        -: 6936:   July 2006 by Kyle R. Murphy
        -: 6937:*/
        -: 6938:static const char reg_errors[] =
        -: 6939:  "no previous regular expression\0"
        -: 6940:  "cannot specify modifiers on empty regexp";
        -: 6941:
        -: 6942:#define NO_REGEX (reg_errors)
        -: 6943:#define BAD_MODIF (NO_REGEX + sizeof(N_("no previous regular expression")))
        -: 6944:
        -: 6945:/*
        -: 6946:  Added pre-processor command to allow *.c file merger
        -: 6947:  for SIR -- July 2006 by Kyle R. Murphy
        -: 6948:*/
        -: 6949:
        -: 6950:#ifndef END_ERRORS
        -: 6951:#define END_ERRORS (BAD_MODIF + sizeof(N_("cannot specify modifiers on empty regexp")))
        -: 6952:#endif
        -: 6953:
        -: 6954:
        -: 6955:static void
function compile_regex_1 called 1 returned 100% blocks executed 61%
        1: 6956:compile_regex_1 (new_regex, needed_sub)
        -: 6957:  struct regex *new_regex;
        -: 6958:  int needed_sub;
        -: 6959:{
        -: 6960:#ifdef REG_PERL
        -: 6961:  int errcode;
        -: 6962:  errcode = regncomp(&new_regex->pattern, new_regex->re, new_regex->sz,
        -: 6963:		     (needed_sub ? 0 : REG_NOSUB)
        -: 6964:		     | new_regex->flags
        -: 6965:		     | extended_regexp_flags);
        -: 6966:
        -: 6967:  if (errcode)
        -: 6968:    {
        -: 6969:      char errorbuf[200];
        -: 6970:      regerror(errcode, NULL, errorbuf, 200);
        -: 6971:      bad_prog(gettext(errorbuf));
        -: 6972:    }
        -: 6973:#else
        -: 6974:  const char *error;
       1*: 6975:  int syntax = ((extended_regexp_flags & REG_EXTENDED)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -: 6976:		 ? RE_SYNTAX_POSIX_EXTENDED
        -: 6977:                 : RE_SYNTAX_POSIX_BASIC)
        -: 6978:		 & ~RE_UNMATCHED_RIGHT_PAREN_ORD;
        -: 6979:
        1: 6980:  syntax |= RE_NO_POSIX_BACKTRACKING;
        -: 6981:#ifdef RE_ICASE
        1: 6982:  syntax |= (new_regex->flags & REG_ICASE) ? RE_ICASE : 0;
        -: 6983:#endif
        -: 6984:#ifdef RE_NO_SUB
       1*: 6985:  syntax |= needed_sub ? 0 : RE_NO_SUB;
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -: 6986:#endif
        -: 6987:
        1: 6988:  new_regex->pattern.fastmap = malloc (1 << (sizeof (char) * 8));
        -: 6989:
        -: 6990:  /* If REG_NEWLINE is set, newlines are treated differently.  */
        1: 6991:  if (new_regex->flags & REG_NEWLINE)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -: 6992:    {
        -: 6993:      /* REG_NEWLINE implies neither . nor [^...] match newline.  */
    #####: 6994:      syntax &= ~RE_DOT_NEWLINE;
    #####: 6995:      syntax |= RE_HAT_LISTS_NOT_NEWLINE;
        -: 6996:    }
        -: 6997:
        1: 6998:  re_set_syntax (syntax);
call    0 returned 1
        1: 6999:  error = re_compile_pattern (new_regex->re, new_regex->sz,
        1: 7000:			      &new_regex->pattern);
call    0 returned 1
        1: 7001:  new_regex->pattern.newline_anchor = (new_regex->flags & REG_NEWLINE) != 0;
        -: 7002:
        1: 7003:  new_regex->pattern.translate = NULL;
        -: 7004:#ifndef RE_ICASE
        -: 7005:  if (new_regex->flags & REG_ICASE)
        -: 7006:    {
        -: 7007:      static char translate[1 << (sizeof(char) * 8)];
        -: 7008:      int i;
        -: 7009:      for (i = 0; i < sizeof(translate) / sizeof(char); i++)
        -: 7010:	translate[i] = tolower (i);
        -: 7011:
        -: 7012:      new_regex->pattern.translate = translate;
        -: 7013:    }
        -: 7014:#endif
        -: 7015:
        1: 7016:  if (error)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 7017:    bad_prog(error);
call    0 never executed
        -: 7018:#endif
        -: 7019:
        -: 7020:  /* Just to be sure, I mark this as not POSIXLY_CORRECT behavior */
        1: 7021:  if (needed_sub
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 7022:      && new_regex->pattern.re_nsub < needed_sub - 1
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 7023:      && posixicity == POSIXLY_EXTENDED)
branch  0 never executed
branch  1 never executed
        -: 7024:    {
        -: 7025:      char buf[200];
    #####: 7026:      sprintf(buf, _("invalid reference \\%d on `s' command's RHS"),
        -: 7027:	      needed_sub - 1);
    #####: 7028:      bad_prog(buf);
call    0 never executed
        -: 7029:    }
        1: 7030:}
        -: 7031:
        -: 7032:struct regex *
function compile_regex called 1 returned 100% blocks executed 75%
        1: 7033:compile_regex(b, flags, needed_sub)
        -: 7034:  struct buffer *b;
        -: 7035:  int flags;
        -: 7036:  int needed_sub;
        -: 7037:{
        -: 7038:  struct regex *new_regex;
        -: 7039:  size_t re_len;
        -: 7040:
        -: 7041:  /* // matches the last RE */
        1: 7042:  if (size_buffer(b) == 0)
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
        -: 7043:    {
    #####: 7044:      if (flags > 0)
branch  0 never executed
branch  1 never executed
    #####: 7045:	bad_prog(_(BAD_MODIF));
call    0 never executed
    #####: 7046:      return NULL;
        -: 7047:    }
        -: 7048:
        1: 7049:  re_len = size_buffer(b);
call    0 returned 1
        1: 7050:  new_regex = ck_malloc(sizeof (struct regex) + re_len - 1);
call    0 returned 1
        1: 7051:  new_regex->flags = flags;
        1: 7052:  memcpy (new_regex->re, get_buffer(b), re_len);
call    0 returned 1
        -: 7053:
        -: 7054:#ifdef REG_PERL
        -: 7055:  new_regex->sz = re_len;
        -: 7056:#else
        -: 7057:  /* GNU regex does not process \t & co. */
        1: 7058:  new_regex->sz = normalize_text(new_regex->re, re_len, TEXT_REGEX);
call    0 returned 1
        -: 7059:#endif
        -: 7060:
        1: 7061:  compile_regex_1 (new_regex, needed_sub);
call    0 returned 1
        1: 7062:  return new_regex;
        -: 7063:}
        -: 7064:
        -: 7065:#ifdef REG_PERL
        -: 7066:static void
        -: 7067:copy_regs (regs, pmatch, nregs)
        -: 7068:     struct re_registers *regs;
        -: 7069:     regmatch_t *pmatch;
        -: 7070:     int nregs;
        -: 7071:{
        -: 7072:  int i;
        -: 7073:  int need_regs = nregs + 1;
        -: 7074:  /* We need one extra element beyond `num_regs' for the `-1' marker GNU code
        -: 7075:     uses.  */
        -: 7076:
        -: 7077:  /* Have the register data arrays been allocated?  */
        -: 7078:  if (!regs->start)
        -: 7079:    { /* No.  So allocate them with malloc.  */
        -: 7080:      regs->start = MALLOC (need_regs, regoff_t);
        -: 7081:      regs->end = MALLOC (need_regs, regoff_t);
        -: 7082:      regs->num_regs = need_regs;
        -: 7083:    }
        -: 7084:  else if (need_regs > regs->num_regs)
        -: 7085:    { /* Yes.  We also need more elements than were already
        -: 7086:         allocated, so reallocate them.  */
        -: 7087:      regs->start = REALLOC (regs->start, need_regs, regoff_t);
        -: 7088:      regs->end = REALLOC (regs->end, need_regs, regoff_t);
        -: 7089:      regs->num_regs = need_regs;
        -: 7090:    }
        -: 7091:
        -: 7092:  /* Copy the regs.  */
        -: 7093:  for (i = 0; i < nregs; ++i)
        -: 7094:    {
        -: 7095:      regs->start[i] = pmatch[i].rm_so;
        -: 7096:      regs->end[i] = pmatch[i].rm_eo;
        -: 7097:    }
        -: 7098:  for ( ; i < regs->num_regs; ++i)
        -: 7099:    regs->start[i] = regs->end[i] = -1;
        -: 7100:}
        -: 7101:#endif
        -: 7102:
        -: 7103:int
function match_regex called 126 returned 100% blocks executed 62%
      126: 7104:match_regex(regex, buf, buflen, buf_start_offset, regarray, regsize)
        -: 7105:  struct regex *regex;
        -: 7106:  char *buf;
        -: 7107:  size_t buflen;
        -: 7108:  size_t buf_start_offset;
        -: 7109:  struct re_registers *regarray;
        -: 7110:  int regsize;
        -: 7111:{
        -: 7112:  int ret;
        -: 7113:  static struct regex *regex_last;
        -: 7114:#ifdef REG_PERL
        -: 7115:  regmatch_t rm[10], *regmatch = rm;
        -: 7116:  if (regsize > 10)
        -: 7117:    regmatch = (regmatch_t *) alloca (sizeof (regmatch_t) * regsize);
        -: 7118:#endif
        -: 7119:
        -: 7120:  /* printf ("Matching from %d/%d\n", buf_start_offset, buflen); */
        -: 7121:
        -: 7122:  /* Keep track of the last regexp matched. */
      126: 7123:  if (!regex)
branch  0 taken 0 (fallthrough)
branch  1 taken 126
        -: 7124:    {
    #####: 7125:      regex = regex_last;
    #####: 7126:      if (!regex_last)
branch  0 never executed
branch  1 never executed
    #####: 7127:	bad_prog(_(NO_REGEX));
call    0 never executed
        -: 7128:    }
        -: 7129:  else
      126: 7130:    regex_last = regex;
        -: 7131:
        -: 7132:#ifdef REG_PERL
        -: 7133:  regmatch[0].rm_so = CAST(int)buf_start_offset;
        -: 7134:  regmatch[0].rm_eo = CAST(int)buflen;
        -: 7135:  ret = regexec (&regex->pattern, buf, regsize, regmatch, REG_STARTEND);
        -: 7136:
        -: 7137:  if (regsize)
        -: 7138:    copy_regs (regarray, regmatch, regsize);
        -: 7139:
        -: 7140:  return (ret == 0);
        -: 7141:#else
     126*: 7142:  if (regex->pattern.no_sub && regsize)
branch  0 taken 0 (fallthrough)
branch  1 taken 126
branch  2 never executed
branch  3 never executed
    #####: 7143:    compile_regex_1 (regex, regsize);
call    0 never executed
        -: 7144:
      126: 7145:  regex->pattern.regs_allocated = REGS_REALLOCATE;
        -: 7146:
     126*: 7147:  ret = re_search (&regex->pattern, buf, buflen, buf_start_offset,
branch  0 taken 126 (fallthrough)
branch  1 taken 0
      126: 7148:		   buflen - buf_start_offset,
call    0 returned 126
        -: 7149:		   regsize ? regarray : NULL);
        -: 7150:
      126: 7151:  return (ret > -1);
        -: 7152:#endif
        -: 7153:}
        -: 7154:
        -: 7155:
        -: 7156:#ifdef DEBUG_LEAKS
        -: 7157:void
        -: 7158:release_regex(regex)
        -: 7159:  struct regex *regex;
        -: 7160:{
        -: 7161:  regfree(&regex->pattern);
        -: 7162:  FREE(regex);
        -: 7163:}
        -: 7164:#endif /*DEBUG_LEAKS*/
