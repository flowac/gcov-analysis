        -:    0:Source:regexec.c
        -:    0:Graph:sed.gcno
        -:    0:Data:sed.gcda
        -:    0:Runs:370
        -:    1:/* Extended regular expression matching and search library.
        -:    2:   Copyright (C) 2002 Free Software Foundation, Inc.
        -:    3:   This file is part of the GNU C Library.
        -:    4:   Contributed by Isamu Hasegawa <isamu@yamato.ibm.com>.
        -:    5:
        -:    6:   The GNU C Library is free software; you can redistribute it and/or
        -:    7:   modify it under the terms of the GNU Lesser General Public
        -:    8:   License as published by the Free Software Foundation; either
        -:    9:   version 2.1 of the License, or (at your option) any later version.
        -:   10:
        -:   11:   The GNU C Library is distributed in the hope that it will be useful,
        -:   12:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   13:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
        -:   14:   Lesser General Public License for more details.
        -:   15:
        -:   16:   You should have received a copy of the GNU Lesser General Public
        -:   17:   License along with the GNU C Library; if not, write to the Free
        -:   18:   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
        -:   19:   02111-1307 USA.  */
        -:   20:
        -:   21:/*
        -:   22:  Moved function prototypes to regexec.h file for *.c file
        -:   23:  merger required for SIR C-subjects -- July 2006 by 
        -:   24:  Kyle R. Murphy
        -:   25:*/
        -:   26:
        -:   27:#include "regexec.h"
        -:   28:
        -:   29:
        -:   30:/* Entry point for POSIX code.  */
        -:   31:
        -:   32:/* regexec searches for a given pattern, specified by PREG, in the
        -:   33:   string STRING.
        -:   34:
        -:   35:   If NMATCH is zero or REG_NOSUB was set in the cflags argument to
        -:   36:   `regcomp', we ignore PMATCH.  Otherwise, we assume PMATCH has at
        -:   37:   least NMATCH elements, and we set them to the offsets of the
        -:   38:   corresponding matched substrings.
        -:   39:
        -:   40:   EFLAGS specifies `execution flags' which affect matching: if
        -:   41:   REG_NOTBOL is set, then ^ does not match at the beginning of the
        -:   42:   string; if REG_NOTEOL is set, then $ does not match at the end.
        -:   43:
        -:   44:   We return 0 if we find a match and REG_NOMATCH if not.  */
        -:   45:
        -:   46:int
function regexec called 0 returned 0% blocks executed 0%
    #####:   47:regexec (preg, string, nmatch, pmatch, eflags)
        -:   48:    const regex_t *__restrict preg;
        -:   49:    const char *__restrict string;
        -:   50:    size_t nmatch;
        -:   51:    regmatch_t pmatch[];
        -:   52:    int eflags;
        -:   53:{
        -:   54:  reg_errcode_t err;
    #####:   55:  int length = strlen (string);
    #####:   56:  if (preg->no_sub)
branch  0 never executed
branch  1 never executed
    #####:   57:    err = re_search_internal (preg, string, length, 0, length, length, 0,
call    0 never executed
        -:   58:			      NULL, eflags);
        -:   59:  else
    #####:   60:    err = re_search_internal (preg, string, length, 0, length, length, nmatch,
call    0 never executed
        -:   61:			      pmatch, eflags);
    #####:   62:  return err != REG_NOERROR;
        -:   63:}
        -:   64:#ifdef _LIBC
        -:   65:weak_alias (__regexec, regexec)
        -:   66:#endif
        -:   67:
        -:   68:/* Entry points for GNU code.  */
        -:   69:
        -:   70:/* re_match, re_search, re_match_2, re_search_2
        -:   71:
        -:   72:   The former two functions operate on STRING with length LENGTH,
        -:   73:   while the later two operate on concatenation of STRING1 and STRING2
        -:   74:   with lengths LENGTH1 and LENGTH2, respectively.
        -:   75:
        -:   76:   re_match() matches the compiled pattern in BUFP against the string,
        -:   77:   starting at index START.
        -:   78:
        -:   79:   re_search() first tries matching at index START, then it tries to match
        -:   80:   starting from index START + 1, and so on.  The last start position tried
        -:   81:   is START + RANGE.  (Thus RANGE = 0 forces re_search to operate the same
        -:   82:   way as re_match().)
        -:   83:
        -:   84:   The parameter STOP of re_{match,search}_2 specifies that no match exceeding
        -:   85:   the first STOP characters of the concatenation of the strings should be
        -:   86:   concerned.
        -:   87:
        -:   88:   If REGS is not NULL, and BUFP->no_sub is not set, the offsets of the match
        -:   89:   and all groups is stroed in REGS.  (For the "_2" variants, the offsets are
        -:   90:   computed relative to the concatenation, not relative to the individual
        -:   91:   strings.)
        -:   92:
        -:   93:   On success, re_match* functions return the length of the match, re_search*
        -:   94:   return the position of the start of the match.  Return value -1 means no
        -:   95:   match was found and -2 indicates an internal error.  */
        -:   96:
        -:   97:int
function re_match called 0 returned 0% blocks executed 0%
    #####:   98:re_match (bufp, string, length, start, regs)
        -:   99:    struct re_pattern_buffer *bufp;
        -:  100:    const char *string;
        -:  101:    int length, start;
        -:  102:    struct re_registers *regs;
        -:  103:{
    #####:  104:  return re_search_stub (bufp, string, length, start, 0, length, regs, 1);
call    0 never executed
        -:  105:}
        -:  106:#ifdef _LIBC
        -:  107:weak_alias (__re_match, re_match)
        -:  108:#endif
        -:  109:
        -:  110:int
function re_search called 47141 returned 100% blocks executed 100%
    47141:  111:re_search (bufp, string, length, start, range, regs)
        -:  112:    struct re_pattern_buffer *bufp;
        -:  113:    const char *string;
        -:  114:    int length, start, range;
        -:  115:    struct re_registers *regs;
        -:  116:{
    47141:  117:  return re_search_stub (bufp, string, length, start, range, length, regs, 0);
call    0 returned 47141
        -:  118:}
        -:  119:#ifdef _LIBC
        -:  120:weak_alias (__re_search, re_search)
        -:  121:#endif
        -:  122:
        -:  123:int
function re_match_2 called 0 returned 0% blocks executed 0%
    #####:  124:re_match_2 (bufp, string1, length1, string2, length2, start, regs, stop)
        -:  125:    struct re_pattern_buffer *bufp;
        -:  126:    const char *string1, *string2;
        -:  127:    int length1, length2, start, stop;
        -:  128:    struct re_registers *regs;
        -:  129:{
    #####:  130:  return re_search_2_stub (bufp, string1, length1, string2, length2,
call    0 never executed
        -:  131:			   start, 0, regs, stop, 1);
        -:  132:}
        -:  133:#ifdef _LIBC
        -:  134:weak_alias (__re_match_2, re_match_2)
        -:  135:#endif
        -:  136:
        -:  137:int
function re_search_2 called 0 returned 0% blocks executed 0%
    #####:  138:re_search_2 (bufp, string1, length1, string2, length2, start, range, regs, stop)
        -:  139:    struct re_pattern_buffer *bufp;
        -:  140:    const char *string1, *string2;
        -:  141:    int length1, length2, start, range, stop;
        -:  142:    struct re_registers *regs;
        -:  143:{
    #####:  144:  return re_search_2_stub (bufp, string1, length1, string2, length2,
call    0 never executed
        -:  145:			   start, range, regs, stop, 0);
        -:  146:}
        -:  147:#ifdef _LIBC
        -:  148:weak_alias (__re_search_2, re_search_2)
        -:  149:#endif
        -:  150:
        -:  151:static int
function re_search_2_stub called 0 returned 0% blocks executed 0%
    #####:  152:re_search_2_stub (bufp, string1, length1, string2, length2, start, range, regs,
        -:  153:		  stop, ret_len)
        -:  154:    struct re_pattern_buffer *bufp;
        -:  155:    const char *string1, *string2;
        -:  156:    int length1, length2, start, range, stop, ret_len;
        -:  157:    struct re_registers *regs;
        -:  158:{
        -:  159:  const char *str;
        -:  160:  int rval;
    #####:  161:  int len = length1 + length2;
    #####:  162:  int free_str = 0;
        -:  163:
    #####:  164:  if (BE (length1 < 0 || length2 < 0 || stop < 0, 0))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:  165:    return -2;
        -:  166:
        -:  167:  /* Concatenate the strings.  */
    #####:  168:  if (length2 > 0)
branch  0 never executed
branch  1 never executed
    #####:  169:    if (length1 > 0)
branch  0 never executed
branch  1 never executed
        -:  170:      {
    #####:  171:	char *s = re_malloc (char, len);
        -:  172:
    #####:  173:	if (BE (s == NULL, 0))
branch  0 never executed
branch  1 never executed
    #####:  174:	  return -2;
    #####:  175:	memcpy (s, string1, length1);
    #####:  176:	memcpy (s + length1, string2, length2);
    #####:  177:	str = s;
    #####:  178:	free_str = 1;
        -:  179:      }
        -:  180:    else
    #####:  181:      str = string2;
        -:  182:  else
    #####:  183:    str = string1;
        -:  184:
    #####:  185:  rval = re_search_stub (bufp, str, len, start, range, stop, regs,
call    0 never executed
        -:  186:			 ret_len);
    #####:  187:  if (free_str)
branch  0 never executed
branch  1 never executed
    #####:  188:    re_free ((char *) str);
    #####:  189:  return rval;
        -:  190:}
        -:  191:
        -:  192:/* The parameters have the same meaning as those of re_search.
        -:  193:   Additional parameters:
        -:  194:   If RET_LEN is nonzero the length of the match is returned (re_match style);
        -:  195:   otherwise the position of the match is returned.  */
        -:  196:
        -:  197:static int
function re_search_stub called 47141 returned 100% blocks executed 61%
    47141:  198:re_search_stub (bufp, string, length, start, range, stop, regs, ret_len)
        -:  199:    struct re_pattern_buffer *bufp;
        -:  200:    const char *string;
        -:  201:    int length, start, range, stop, ret_len;
        -:  202:    struct re_registers *regs;
        -:  203:{
        -:  204:  reg_errcode_t result;
        -:  205:  regmatch_t *pmatch;
        -:  206:  int nregs, rval;
    47141:  207:  int eflags = 0;
        -:  208:
        -:  209:  /* Check for out-of-range.  */
    47141:  210:  if (BE (start < 0 || start > length, 0))
branch  0 taken 47141 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 47141
    #####:  211:    return -1;
    47141:  212:  if (BE (start + range > length, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 47141
    #####:  213:    range = length - start;
    47141:  214:  else if (BE (start + range < 0, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 47141
    #####:  215:    range = -start;
        -:  216:
    47141:  217:  eflags |= (bufp->not_bol) ? REG_NOTBOL : 0;
    47141:  218:  eflags |= (bufp->not_eol) ? REG_NOTEOL : 0;
        -:  219:
        -:  220:  /* Compile fastmap if we haven't yet.  */
   47141*:  221:  if (range > 0 && bufp->fastmap != NULL && !bufp->fastmap_accurate)
branch  0 taken 33003 (fallthrough)
branch  1 taken 14138
branch  2 taken 0 (fallthrough)
branch  3 taken 33003
branch  4 never executed
branch  5 never executed
    #####:  222:    re_compile_fastmap (bufp);
call    0 never executed
        -:  223:
    47141:  224:  if (BE (bufp->no_sub, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 47141
    #####:  225:    regs = NULL;
        -:  226:
        -:  227:  /* We need at least 1 register.  */
    47141:  228:  if (regs == NULL)
branch  0 taken 31918 (fallthrough)
branch  1 taken 15223
    31918:  229:    nregs = 1;
   15223*:  230:  else if (BE (bufp->regs_allocated == REGS_FIXED &&
branch  0 taken 0 (fallthrough)
branch  1 taken 15223
branch  2 never executed
branch  3 never executed
        -:  231:	       regs->num_regs < bufp->re_nsub + 1, 0))
        -:  232:    {
    #####:  233:      nregs = regs->num_regs;
    #####:  234:      if (BE (nregs < 1, 0))
branch  0 never executed
branch  1 never executed
        -:  235:	{
        -:  236:	  /* Nothing can be copied to regs.  */
    #####:  237:	  regs = NULL;
    #####:  238:	  nregs = 1;
        -:  239:	}
        -:  240:    }
        -:  241:  else
    15223:  242:    nregs = bufp->re_nsub + 1;
    47141:  243:  pmatch = re_malloc (regmatch_t, nregs);
    47141:  244:  if (BE (pmatch == NULL, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 47141
    #####:  245:    return -2;
        -:  246:
    47141:  247:  result = re_search_internal (bufp, string, length, start, range, stop,
call    0 returned 47141
        -:  248:			       nregs, pmatch, eflags);
        -:  249:
    47141:  250:  rval = 0;
        -:  251:
        -:  252:  /* I hope we needn't fill ther regs with -1's when no match was found.  */
    47141:  253:  if (result != REG_NOERROR)
branch  0 taken 41353 (fallthrough)
branch  1 taken 5788
    41353:  254:    rval = -1;
     5788:  255:  else if (regs != NULL)
branch  0 taken 3506 (fallthrough)
branch  1 taken 2282
        -:  256:    {
        -:  257:      /* If caller wants register contents data back, copy them.  */
     7012:  258:      bufp->regs_allocated = re_copy_regs (regs, pmatch, nregs,
     3506:  259:					   bufp->regs_allocated);
call    0 returned 3506
     3506:  260:      if (BE (bufp->regs_allocated == REGS_UNALLOCATED, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 3506
    #####:  261:	rval = -2;
        -:  262:    }
        -:  263:
    47141:  264:  if (BE (rval == 0, 1))
branch  0 taken 5788 (fallthrough)
branch  1 taken 41353
        -:  265:    {
     5788:  266:      if (ret_len)
branch  0 taken 0 (fallthrough)
branch  1 taken 5788
        -:  267:	{
    #####:  268:	  assert (pmatch[0].rm_so == start);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  269:	  rval = pmatch[0].rm_eo - start;
        -:  270:	}
        -:  271:      else
     5788:  272:	rval = pmatch[0].rm_so;
        -:  273:    }
    47141:  274:  re_free (pmatch);
    47141:  275:  return rval;
        -:  276:}
        -:  277:
        -:  278:static unsigned
function re_copy_regs called 3506 returned 100% blocks executed 50%
     3506:  279:re_copy_regs (regs, pmatch, nregs, regs_allocated)
        -:  280:    struct re_registers *regs;
        -:  281:    regmatch_t *pmatch;
        -:  282:    int nregs, regs_allocated;
        -:  283:{
     3506:  284:  int rval = REGS_REALLOCATE;
        -:  285:  int i;
     3506:  286:  int need_regs = nregs + 1;
        -:  287:  /* We need one extra element beyond `num_regs' for the `-1' marker GNU code
        -:  288:     uses.  */
        -:  289:
        -:  290:  /* Have the register data arrays been allocated?  */
     3506:  291:  if (regs_allocated == REGS_UNALLOCATED)
branch  0 taken 209 (fallthrough)
branch  1 taken 3297
        -:  292:    { /* No.  So allocate them with malloc.  */
      209:  293:      regs->start = re_malloc (regoff_t, need_regs);
      209:  294:      if (BE (regs->start == NULL, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 209
    #####:  295:	return REGS_UNALLOCATED;
      209:  296:      regs->end = re_malloc (regoff_t, need_regs);
      209:  297:      if (BE (regs->end == NULL, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 209
        -:  298:	{
    #####:  299:	  re_free (regs->start);
    #####:  300:	  return REGS_UNALLOCATED;
        -:  301:	}
      209:  302:      regs->num_regs = need_regs;
        -:  303:    }
     3297:  304:  else if (regs_allocated == REGS_REALLOCATE)
branch  0 taken 3297 (fallthrough)
branch  1 taken 0
        -:  305:    { /* Yes.  If we need more elements than were already
        -:  306:	 allocated, reallocate them.  If we need fewer, just
        -:  307:	 leave it alone.  */
     3297:  308:      if (need_regs > regs->num_regs)
branch  0 taken 0 (fallthrough)
branch  1 taken 3297
        -:  309:	{
    #####:  310:	  regs->start = re_realloc (regs->start, regoff_t, need_regs);
    #####:  311:	  if (BE (regs->start == NULL, 0))
branch  0 never executed
branch  1 never executed
        -:  312:	    {
    #####:  313:	      if (regs->end != NULL)
branch  0 never executed
branch  1 never executed
    #####:  314:		re_free (regs->end);
    #####:  315:	      return REGS_UNALLOCATED;
        -:  316:	    }
    #####:  317:	  regs->end = re_realloc (regs->end, regoff_t, need_regs);
    #####:  318:	  if (BE (regs->end == NULL, 0))
branch  0 never executed
branch  1 never executed
        -:  319:	    {
    #####:  320:	      re_free (regs->start);
    #####:  321:	      return REGS_UNALLOCATED;
        -:  322:	    }
    #####:  323:	  regs->num_regs = need_regs;
        -:  324:	}
        -:  325:    }
        -:  326:  else
        -:  327:    {
    #####:  328:      assert (regs_allocated == REGS_FIXED);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  329:      /* This function may not be called with REGS_FIXED and nregs too big.  */
    #####:  330:      assert (regs->num_regs >= nregs);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  331:      rval = REGS_FIXED;
        -:  332:    }
        -:  333:
        -:  334:  /* Copy the regs.  */
     7070:  335:  for (i = 0; i < nregs; ++i)
branch  0 taken 3564
branch  1 taken 3506 (fallthrough)
        -:  336:    {
     3564:  337:      regs->start[i] = pmatch[i].rm_so;
     3564:  338:      regs->end[i] = pmatch[i].rm_eo;
        -:  339:    }
     7012:  340:  for ( ; i < regs->num_regs; ++i)
branch  0 taken 3506
branch  1 taken 3506 (fallthrough)
     3506:  341:    regs->start[i] = regs->end[i] = -1;
        -:  342:
     3506:  343:  return rval;
        -:  344:}
        -:  345:
        -:  346:/* Set REGS to hold NUM_REGS registers, storing them in STARTS and
        -:  347:   ENDS.  Subsequent matches using PATTERN_BUFFER and REGS will use
        -:  348:   this memory for recording register information.  STARTS and ENDS
        -:  349:   must be allocated using the malloc library routine, and must each
        -:  350:   be at least NUM_REGS * sizeof (regoff_t) bytes long.
        -:  351:
        -:  352:   If NUM_REGS == 0, then subsequent matches should allocate their own
        -:  353:   register data.
        -:  354:
        -:  355:   Unless this function is called, the first search or match using
        -:  356:   PATTERN_BUFFER will allocate its own register data, without
        -:  357:   freeing the old data.  */
        -:  358:
        -:  359:void
function re_set_registers called 0 returned 0% blocks executed 0%
    #####:  360:re_set_registers (bufp, regs, num_regs, starts, ends)
        -:  361:    struct re_pattern_buffer *bufp;
        -:  362:    struct re_registers *regs;
        -:  363:    unsigned num_regs;
        -:  364:    regoff_t *starts, *ends;
        -:  365:{
    #####:  366:  if (num_regs)
branch  0 never executed
branch  1 never executed
        -:  367:    {
    #####:  368:      bufp->regs_allocated = REGS_REALLOCATE;
    #####:  369:      regs->num_regs = num_regs;
    #####:  370:      regs->start = starts;
    #####:  371:      regs->end = ends;
        -:  372:    }
        -:  373:  else
        -:  374:    {
    #####:  375:      bufp->regs_allocated = REGS_UNALLOCATED;
    #####:  376:      regs->num_regs = 0;
    #####:  377:      regs->start = regs->end = (regoff_t *) 0;
        -:  378:    }
    #####:  379:}
        -:  380:#ifdef _LIBC
        -:  381:weak_alias (__re_set_registers, re_set_registers)
        -:  382:#endif
        -:  383:
        -:  384:/* Entry points compatible with 4.2 BSD regex library.  We don't define
        -:  385:   them unless specifically requested.  */
        -:  386:
        -:  387:#if defined _REGEX_RE_COMP || defined _LIBC
        -:  388:int
        -:  389:# ifdef _LIBC
        -:  390:weak_function
        -:  391:# endif
        -:  392:re_exec (s)
        -:  393:     const char *s;
        -:  394:{
        -:  395:  return 0 == regexec (&re_comp_buf, s, 0, NULL, 0);
        -:  396:}
        -:  397:#endif /* _REGEX_RE_COMP */
        -:  398:
        -:  399:static re_node_set empty_set;
        -:  400:
        -:  401:/* Internal entry point.  */
        -:  402:
        -:  403:/* Searches for a compiled pattern PREG in the string STRING, whose
        -:  404:   length is LENGTH.  NMATCH, PMATCH, and EFLAGS have the same
        -:  405:   mingings with regexec.  START, and RANGE have the same meanings
        -:  406:   with re_search.
        -:  407:   Return REG_NOERROR if we find a match, and REG_NOMATCH if not,
        -:  408:   otherwise return the error code.
        -:  409:   Note: We assume front end functions already check ranges.
        -:  410:   (START + RANGE >= 0 && START + RANGE <= LENGTH)  */
        -:  411:
        -:  412:reg_errcode_t
function re_search_internal called 47141 returned 100% blocks executed 52%
    47141:  413:re_search_internal (preg, string, length, start, range, stop, nmatch, pmatch,
        -:  414:		    eflags)
        -:  415:    const regex_t *preg;
        -:  416:    const char *string;
        -:  417:    int length, start, range, stop, eflags;
        -:  418:    size_t nmatch;
        -:  419:    regmatch_t pmatch[];
        -:  420:{
        -:  421:  reg_errcode_t err;
    47141:  422:  re_dfa_t *dfa = (re_dfa_t *)preg->buffer;
        -:  423:  re_string_t input;
        -:  424:  int left_lim, right_lim, incr;
    47141:  425:  int fl_longest_match, match_first, match_last = -1;
        -:  426:  int fast_translate, sb;
        -:  427:  re_match_context_t mctx;
    #####:  428:  char *fastmap = ((preg->fastmap != NULL && preg->fastmap_accurate
branch  0 never executed
branch  1 never executed
   47141*:  429:		    && range && !preg->can_be_null) ? preg->fastmap : NULL);
branch  0 taken 0 (fallthrough)
branch  1 taken 47141
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:  430:
        -:  431:  /* Check if the DFA haven't been compiled.  */
   47141*:  432:  if (BE (preg->used == 0 || dfa->init_state == NULL
branch  0 taken 47141 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 47141
branch  4 taken 47141 (fallthrough)
branch  5 taken 0
branch  6 taken 0 (fallthrough)
branch  7 taken 47141
branch  8 taken 47141 (fallthrough)
branch  9 taken 0
branch 10 taken 0 (fallthrough)
branch 11 taken 47141
branch 12 taken 47141 (fallthrough)
branch 13 taken 0
branch 14 taken 0 (fallthrough)
branch 15 taken 47141
        -:  433:	  || dfa->init_state_word == NULL || dfa->init_state_nl == NULL
        -:  434:	  || dfa->init_state_begbuf == NULL, 0))
    #####:  435:    return REG_NOMATCH;
        -:  436:
    47141:  437:  re_node_set_init_empty (&empty_set);
    47141:  438:  memset (&mctx, '\0', sizeof (re_match_context_t));
        -:  439:
        -:  440:  /* We must check the longest matching, if nmatch > 0.  */
   47141*:  441:  fl_longest_match = (nmatch != 0 || dfa->nbackref);
branch  0 taken 0 (fallthrough)
branch  1 taken 47141
branch  2 never executed
branch  3 never executed
        -:  442:
    47141:  443:  err = re_string_allocate (&input, string, length, dfa->nodes_len + 1,
    47141:  444:			    preg->translate, preg->syntax & RE_ICASE);
call    0 returned 47141
    47141:  445:  if (BE (err != REG_NOERROR, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 47141
    #####:  446:    goto free_return;
    47141:  447:  input.stop = stop;
        -:  448:
    47141:  449:  err = match_ctx_init (&mctx, eflags, &input, dfa->nbackref * 2);
call    0 returned 47141
    47141:  450:  if (BE (err != REG_NOERROR, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 47141
    #####:  451:    goto free_return;
        -:  452:
        -:  453:  /* We will log all the DFA states through which the dfa pass,
        -:  454:     if nmatch > 1, or this dfa has "multibyte node", which is a
        -:  455:     back-reference or a node which can accept multibyte character or
        -:  456:     multi character collating element.  */
    47141:  457:  if (nmatch > 1 || dfa->has_mb_node)
branch  0 taken 46881 (fallthrough)
branch  1 taken 260
branch  2 taken 0 (fallthrough)
branch  3 taken 46881
        -:  458:    {
      260:  459:      mctx.state_log = re_malloc (re_dfastate_t *, dfa->nodes_len + 1);
      260:  460:      if (BE (mctx.state_log == NULL, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 260
        -:  461:	{
    #####:  462:	  err = REG_ESPACE;
    #####:  463:	  goto free_return;
        -:  464:	}
        -:  465:    }
        -:  466:  else
    46881:  467:    mctx.state_log = NULL;
        -:  468:
        -:  469:#ifdef DEBUG
        -:  470:  /* We assume front-end functions already check them.  */
        -:  471:  assert (start + range >= 0 && start + range <= length);
        -:  472:#endif
        -:  473:
    47141:  474:  match_first = start;
    94282:  475:  input.tip_context = ((eflags & REG_NOTBOL) ? CONTEXT_BEGBUF
   47141*:  476:		       : CONTEXT_NEWLINE | CONTEXT_BEGBUF);
branch  0 taken 0 (fallthrough)
branch  1 taken 47141
        -:  477:
        -:  478:  /* Check incrementally whether of not the input string match.  */
   47141*:  479:  incr = (range < 0) ? -1 : 1;
branch  0 taken 0 (fallthrough)
branch  1 taken 47141
   47141*:  480:  left_lim = (range < 0) ? start + range : start;
branch  0 taken 0 (fallthrough)
branch  1 taken 47141
   47141*:  481:  right_lim = (range < 0) ? start : start + range;
branch  0 taken 47141 (fallthrough)
branch  1 taken 0
    47141:  482:  sb = MB_CUR_MAX == 1;
call    0 returned 47141
   47141*:  483:  fast_translate = sb || !(preg->syntax & RE_ICASE || preg->translate);
branch  0 taken 0 (fallthrough)
branch  1 taken 47141
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:  484:
        -:  485:  for (;;)
        -:  486:    {
        -:  487:      /* At first get the current byte from input string.  */
   683752:  488:      if (fastmap)
branch  0 taken 0 (fallthrough)
branch  1 taken 683752
        -:  489:	{
    #####:  490:	  if (BE (fast_translate, 1))
branch  0 never executed
branch  1 never executed
        -:  491:	    {
    #####:  492:	      unsigned RE_TRANSLATE_TYPE t
        -:  493:		= (unsigned RE_TRANSLATE_TYPE) preg->translate;
    #####:  494:	      if (BE (range >= 0, 1))
branch  0 never executed
branch  1 never executed
        -:  495:		{
    #####:  496:		  if (BE (t != NULL, 0))
branch  0 never executed
branch  1 never executed
        -:  497:		    {
    #####:  498:		      while (BE (match_first < right_lim, 1)
    #####:  499:			     && !fastmap[t[(unsigned char) string[match_first]]])
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  500:			++match_first;
        -:  501:		    }
        -:  502:		  else
        -:  503:		    {
    #####:  504:		      while (BE (match_first < right_lim, 1)
    #####:  505:			     && !fastmap[(unsigned char) string[match_first]])
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  506:			++match_first;
        -:  507:		    }
    #####:  508:		  if (BE (match_first == right_lim, 0))
branch  0 never executed
branch  1 never executed
        -:  509:		    {
    #####:  510:		      int ch = match_first >= length
    #####:  511:			       ? 0 : (unsigned char) string[match_first];
branch  0 never executed
branch  1 never executed
    #####:  512:		      if (!fastmap[t ? t[ch] : ch])
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  513:			break;
        -:  514:		    }
        -:  515:		}
        -:  516:	      else
        -:  517:		{
    #####:  518:		  while (match_first >= left_lim)
branch  0 never executed
branch  1 never executed
        -:  519:		    {
    #####:  520:		      int ch = match_first >= length
    #####:  521:			       ? 0 : (unsigned char) string[match_first];
branch  0 never executed
branch  1 never executed
    #####:  522:		      if (fastmap[t ? t[ch] : ch])
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  523:			break;
    #####:  524:		      --match_first;
        -:  525:		    }
    #####:  526:		  if (match_first < left_lim)
branch  0 never executed
branch  1 never executed
    #####:  527:		    break;
        -:  528:		}
        -:  529:	    }
        -:  530:	  else
        -:  531:	    {
        -:  532:	      int ch;
        -:  533:
        -:  534:	      do
        -:  535:		{
        -:  536:		  /* In this case, we can't determine easily the current byte,
        -:  537:		     since it might be a component byte of a multibyte
        -:  538:		     character.  Then we use the constructed buffer
        -:  539:		     instead.  */
        -:  540:		  /* If MATCH_FIRST is out of the valid range, reconstruct the
        -:  541:		     buffers.  */
    #####:  542:		  if (input.raw_mbs_idx + input.valid_len <= match_first
branch  0 never executed
branch  1 never executed
    #####:  543:		      || match_first < input.raw_mbs_idx)
branch  0 never executed
branch  1 never executed
        -:  544:		    {
    #####:  545:		      err = re_string_reconstruct (&input, match_first, eflags,
    #####:  546:						   preg->newline_anchor);
call    0 never executed
    #####:  547:		      if (BE (err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####:  548:			goto free_return;
        -:  549:		    }
        -:  550:		  /* If MATCH_FIRST is out of the buffer, leave it as '\0'.
        -:  551:		     Note that MATCH_FIRST must not be smaller than 0.  */
    #####:  552:		  ch = ((match_first >= length) ? 0
    #####:  553:		       : re_string_byte_at (&input,
branch  0 never executed
branch  1 never executed
        -:  554:					    match_first - input.raw_mbs_idx));
    #####:  555:		  if (fastmap[ch])
branch  0 never executed
branch  1 never executed
    #####:  556:		    break;
    #####:  557:		  match_first += incr;
        -:  558:		}
    #####:  559:	      while (match_first >= left_lim && match_first <= right_lim);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  560:	      if (! fastmap[ch])
branch  0 never executed
branch  1 never executed
    #####:  561:		break;
        -:  562:	    }
        -:  563:	}
        -:  564:
        -:  565:      /* Reconstruct the buffers so that the matcher can assume that
        -:  566:	 the matching starts from the begining of the buffer.  */
   683752:  567:      err = re_string_reconstruct (&input, match_first, eflags,
   683752:  568:				   preg->newline_anchor);
call    0 returned 683752
   683752:  569:      if (BE (err != REG_NOERROR, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 683752
    #####:  570:	goto free_return;
        -:  571:#ifdef RE_ENABLE_I18N
        -:  572:     /* Eliminate it when it is a component of a multibyte character
        -:  573:	 and isn't the head of a multibyte character.  */
        -:  574:      if (sb || re_string_first_byte (&input, 0))
        -:  575:#endif
        -:  576:	{
        -:  577:	  /* It seems to be appropriate one, then use the matcher.  */
        -:  578:	  /* We assume that the matching starts from 0.  */
   683752:  579:	  mctx.state_log_top = mctx.nbkref_ents = mctx.max_mb_elem_len = 0;
   683752:  580:	  match_last = check_matching (preg, &mctx, 0, fl_longest_match);
call    0 returned 683752
   683752:  581:	  if (match_last != -1)
branch  0 taken 5788 (fallthrough)
branch  1 taken 677964
        -:  582:	    {
     5788:  583:	      if (BE (match_last == -2, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 5788
        -:  584:		{
    #####:  585:		  err = REG_ESPACE;
    #####:  586:		  goto free_return;
        -:  587:		}
        -:  588:	      else
        -:  589:		{
     5788:  590:		  mctx.match_last = match_last;
     5788:  591:		  if ((!preg->no_sub && nmatch > 1) || dfa->nbackref)
branch  0 taken 5788 (fallthrough)
branch  1 taken 0
branch  2 taken 5758 (fallthrough)
branch  3 taken 30
branch  4 taken 0 (fallthrough)
branch  5 taken 5758
        -:  592:		    {
       30:  593:		      re_dfastate_t *pstate = mctx.state_log[match_last];
       30:  594:		      mctx.last_node = check_halt_state_context (preg, pstate,
call    0 returned 30
        -:  595:								 &mctx, match_last);
        -:  596:		    }
     5788:  597:		  if ((!preg->no_sub && nmatch > 1 && dfa->has_plural_match)
branch  0 taken 5788 (fallthrough)
branch  1 taken 0
branch  2 taken 30 (fallthrough)
branch  3 taken 5758
branch  4 taken 0 (fallthrough)
branch  5 taken 30
     5758:  598:		      || dfa->nbackref)
branch  0 taken 0 (fallthrough)
branch  1 taken 5758
        -:  599:		    {
       30:  600:		      err = prune_impossible_nodes (preg, &mctx);
call    0 returned 30
       30:  601:		      if (err == REG_NOERROR)
branch  0 taken 30 (fallthrough)
branch  1 taken 0
       30:  602:			break;
    #####:  603:		      if (BE (err != REG_NOMATCH, 0))
branch  0 never executed
branch  1 never executed
    #####:  604:			goto free_return;
        -:  605:		    }
        -:  606:		  else
        -:  607:		    break; /* We found a matching.  */
        -:  608:		}
        -:  609:	    }
        -:  610:	}
        -:  611:      /* Update counter.  */
   677964:  612:      match_first += incr;
   677964:  613:      if (match_first < left_lim || right_lim < match_first)
branch  0 taken 677964 (fallthrough)
branch  1 taken 0
branch  2 taken 636611 (fallthrough)
branch  3 taken 41353
        -:  614:	break;
        -:  615:    }
        -:  616:
        -:  617:  /* Set pmatch[] if we need.  */
    47141:  618:  if (match_last != -1 && nmatch > 0)
branch  0 taken 5788 (fallthrough)
branch  1 taken 41353
branch  2 taken 5788 (fallthrough)
branch  3 taken 0
        -:  619:    {
        -:  620:      int reg_idx;
        -:  621:
        -:  622:      /* Initialize registers.  */
    11634:  623:      for (reg_idx = 0; reg_idx < nmatch; ++reg_idx)
branch  0 taken 5846
branch  1 taken 5788 (fallthrough)
     5846:  624:	pmatch[reg_idx].rm_so = pmatch[reg_idx].rm_eo = -1;
        -:  625:
        -:  626:      /* Set the points where matching start/end.  */
     5788:  627:      pmatch[0].rm_so = 0;
     5788:  628:      pmatch[0].rm_eo = mctx.match_last;
        -:  629:
     5788:  630:      if (!preg->no_sub && nmatch > 1)
branch  0 taken 5788 (fallthrough)
branch  1 taken 0
branch  2 taken 30 (fallthrough)
branch  3 taken 5758
        -:  631:	{
      30*:  632:	  err = set_regs (preg, &mctx, nmatch, pmatch,
call    0 returned 30
       30:  633:			  dfa->has_plural_match && dfa->nbackref > 0);
branch  0 taken 30 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 30
       30:  634:	  if (BE (err != REG_NOERROR, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 30
    #####:  635:	    goto free_return;
        -:  636:	}
        -:  637:
        -:  638:      /* At last, add the offset to the each registers, since we slided
        -:  639:	 the buffers so that We can assume that the matching starts from 0.  */
    11634:  640:      for (reg_idx = 0; reg_idx < nmatch; ++reg_idx)
branch  0 taken 5846
branch  1 taken 5788 (fallthrough)
     5846:  641:	if (pmatch[reg_idx].rm_so != -1)
branch  0 taken 5822 (fallthrough)
branch  1 taken 24
        -:  642:	  {
     5822:  643:	    pmatch[reg_idx].rm_so += match_first;
     5822:  644:	    pmatch[reg_idx].rm_eo += match_first;
        -:  645:	  }
        -:  646:    }
    47141:  647:  err = (match_last == -1) ? REG_NOMATCH : REG_NOERROR;
    47141:  648: free_return:
    47141:  649:  re_free (mctx.state_log);
    47141:  650:  if (dfa->nbackref)
branch  0 taken 0 (fallthrough)
branch  1 taken 47141
    #####:  651:    match_ctx_free (&mctx);
call    0 never executed
    47141:  652:  re_string_destruct (&input);
call    0 returned 47141
    47141:  653:  return err;
        -:  654:}
        -:  655:
        -:  656:static reg_errcode_t
function prune_impossible_nodes called 30 returned 100% blocks executed 30%
       30:  657:prune_impossible_nodes (preg, mctx)
        -:  658:     const regex_t *preg;
        -:  659:     re_match_context_t *mctx;
        -:  660:{
        -:  661:  int halt_node, match_last;
        -:  662:  reg_errcode_t ret;
       30:  663:  re_dfa_t *dfa = (re_dfa_t *)preg->buffer;
        -:  664:  re_dfastate_t **sifted_states;
       30:  665:  re_dfastate_t **lim_states = NULL;
        -:  666:  re_sift_context_t sctx;
        -:  667:#ifdef DEBUG
        -:  668:  assert (mctx->state_log != NULL);
        -:  669:#endif
       30:  670:  match_last = mctx->match_last;
       30:  671:  halt_node = mctx->last_node;
       30:  672:  sifted_states = re_malloc (re_dfastate_t *, match_last + 1);
       30:  673:  if (BE (sifted_states == NULL, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 30
        -:  674:    {
    #####:  675:      ret = REG_ESPACE;
    #####:  676:      goto free_return;
        -:  677:    }
       30:  678:  if (dfa->nbackref)
branch  0 taken 0 (fallthrough)
branch  1 taken 30
        -:  679:    {
    #####:  680:      lim_states = re_malloc (re_dfastate_t *, match_last + 1);
    #####:  681:      if (BE (lim_states == NULL, 0))
branch  0 never executed
branch  1 never executed
        -:  682:	{
    #####:  683:	  ret = REG_ESPACE;
    #####:  684:	  goto free_return;
        -:  685:	}
        -:  686:      while (1)
        -:  687:	{
    #####:  688:	  memset (lim_states, '\0',
    #####:  689:		  sizeof (re_dfastate_t *) * (match_last + 1));
    #####:  690:	  match_ctx_clear_flag (mctx);
call    0 never executed
    #####:  691:	  sift_ctx_init (&sctx, sifted_states, lim_states, halt_node,
call    0 never executed
        -:  692:			 match_last, 0);
    #####:  693:	  ret = sift_states_backward (preg, mctx, &sctx);
call    0 never executed
    #####:  694:	  re_node_set_free (&sctx.limits);
    #####:  695:	  if (BE (ret != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####:  696:	      goto free_return;
    #####:  697:	  if (sifted_states[0] != NULL || lim_states[0] != NULL)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  698:	    break;
        -:  699:	  do
        -:  700:	    {
    #####:  701:	      --match_last;
    #####:  702:	      if (match_last < 0)
branch  0 never executed
branch  1 never executed
        -:  703:		{
    #####:  704:		  ret = REG_NOMATCH;
    #####:  705:		  goto free_return;
        -:  706:		}
    #####:  707:	    } while (!mctx->state_log[match_last]->halt);
branch  0 never executed
branch  1 never executed
    #####:  708:	  halt_node = check_halt_state_context (preg,
    #####:  709:						mctx->state_log[match_last],
call    0 never executed
        -:  710:						mctx, match_last);
        -:  711:	}
    #####:  712:      ret = merge_state_array (dfa, sifted_states, lim_states,
call    0 never executed
        -:  713:			       match_last + 1);
    #####:  714:      re_free (lim_states);
    #####:  715:      lim_states = NULL;
    #####:  716:      if (BE (ret != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####:  717:	goto free_return;
        -:  718:    }
        -:  719:  else
        -:  720:    {
       30:  721:      sift_ctx_init (&sctx, sifted_states, lim_states, halt_node,
call    0 returned 30
        -:  722:		     match_last, 0);
       30:  723:      ret = sift_states_backward (preg, mctx, &sctx);
call    0 returned 30
       30:  724:      re_node_set_free (&sctx.limits);
       30:  725:      if (BE (ret != REG_NOERROR, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 30
    #####:  726:	goto free_return;
        -:  727:    }
       30:  728:  re_free (mctx->state_log);
       30:  729:  mctx->state_log = sifted_states;
       30:  730:  sifted_states = NULL;
       30:  731:  mctx->last_node = halt_node;
       30:  732:  mctx->match_last = match_last;
       30:  733:  ret = REG_NOERROR;
       30:  734: free_return:
       30:  735:  re_free (sifted_states);
       30:  736:  re_free (lim_states);
       30:  737:  return ret;
        -:  738:}
        -:  739:
        -:  740:/* Acquire an initial state and return it.
        -:  741:   We must select appropriate initial state depending on the context,
        -:  742:   since initial states may have constraints like "\<", "^", etc..  */
        -:  743:
        -:  744:static inline re_dfastate_t *
function acquire_init_state_context called 683752 returned 100% blocks executed 65%
   683752:  745:acquire_init_state_context (err, preg, mctx, idx)
        -:  746:     reg_errcode_t *err;
        -:  747:     const regex_t *preg;
        -:  748:     const re_match_context_t *mctx;
        -:  749:     int idx;
        -:  750:{
   683752:  751:  re_dfa_t *dfa = (re_dfa_t *) preg->buffer;
        -:  752:
   683752:  753:  *err = REG_NOERROR;
   683752:  754:  if (dfa->init_state->has_constraint)
branch  0 taken 170575 (fallthrough)
branch  1 taken 513177
        -:  755:    {
        -:  756:      unsigned int context;
   170575:  757:      context =  re_string_context_at (mctx->input, idx - 1, mctx->eflags,
   170575:  758:				       preg->newline_anchor);
call    0 returned 170575
   170575:  759:      if (IS_WORD_CONTEXT (context))
branch  0 taken 127340 (fallthrough)
branch  1 taken 43235
   127340:  760:	return dfa->init_state_word;
    43235:  761:      else if (IS_ORDINARY_CONTEXT (context))
branch  0 taken 32376 (fallthrough)
branch  1 taken 10859
    32376:  762:	return dfa->init_state;
    10859:  763:      else if (IS_BEGBUF_CONTEXT (context) && IS_NEWLINE_CONTEXT (context))
branch  0 taken 10859 (fallthrough)
branch  1 taken 0
branch  2 taken 10859 (fallthrough)
branch  3 taken 0
    10859:  764:	return dfa->init_state_begbuf;
    #####:  765:      else if (IS_NEWLINE_CONTEXT (context))
branch  0 never executed
branch  1 never executed
    #####:  766:	return dfa->init_state_nl;
    #####:  767:      else if (IS_BEGBUF_CONTEXT (context))
branch  0 never executed
branch  1 never executed
        -:  768:	{
        -:  769:	  /* It is relatively rare case, then calculate on demand.  */
    #####:  770:	  return  re_acquire_state_context (err, dfa,
    #####:  771:					    dfa->init_state->entrance_nodes,
call    0 never executed
        -:  772:					    context);
        -:  773:	}
        -:  774:      else
        -:  775:	/* Must not happen?  */
    #####:  776:	return dfa->init_state;
        -:  777:    }
        -:  778:  else
   513177:  779:    return dfa->init_state;
        -:  780:}
        -:  781:
        -:  782:/* Check whether the regular expression match input string INPUT or not,
        -:  783:   and return the index where the matching end, return -1 if not match,
        -:  784:   or return -2 in case of an error.
        -:  785:   FL_SEARCH means we must search where the matching starts,
        -:  786:   FL_LONGEST_MATCH means we want the POSIX longest matching.
        -:  787:   Note that the matcher assume that the maching starts from the current
        -:  788:   index of the buffer.  */
        -:  789:
        -:  790:static int
function check_matching called 683752 returned 100% blocks executed 63%
   683752:  791:check_matching (preg, mctx, fl_search, fl_longest_match)
        -:  792:    const regex_t *preg;
        -:  793:    re_match_context_t *mctx;
        -:  794:    int fl_search, fl_longest_match;
        -:  795:{
   683752:  796:  re_dfa_t *dfa = (re_dfa_t *) preg->buffer;
        -:  797:  reg_errcode_t err;
   683752:  798:  int match = 0;
   683752:  799:  int match_last = -1;
   683752:  800:  int cur_str_idx = re_string_cur_idx (mctx->input);
        -:  801:  re_dfastate_t *cur_state;
        -:  802:
   683752:  803:  cur_state = acquire_init_state_context (&err, preg, mctx, cur_str_idx);
call    0 returned 683752
        -:  804:  /* An initial state must not be NULL(invalid state).  */
   683752:  805:  if (BE (cur_state == NULL, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 683752
    #####:  806:    return -2;
   683752:  807:  if (mctx->state_log != NULL)
branch  0 taken 3604 (fallthrough)
branch  1 taken 680148
     3604:  808:    mctx->state_log[cur_str_idx] = cur_state;
        -:  809:
        -:  810:  /* Check OP_OPEN_SUBEXP in the initial state in case that we use them
        -:  811:     later.  E.g. Processing back references.  */
   683752:  812:  if (dfa->nbackref)
branch  0 taken 0 (fallthrough)
branch  1 taken 683752
        -:  813:    {
    #####:  814:      err = check_subexp_matching_top (dfa, mctx, &cur_state->nodes, 0);
call    0 never executed
    #####:  815:      if (BE (err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####:  816:	return err;
        -:  817:    }
        -:  818:
   683752:  819:  if (cur_state->has_backref)
branch  0 taken 0 (fallthrough)
branch  1 taken 683752
        -:  820:    {
    #####:  821:      err = transit_state_bkref (preg, cur_state, mctx);
call    0 never executed
    #####:  822:      if (BE (err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####:  823:	return err;
        -:  824:    }
        -:  825:
        -:  826:  /* If the RE accepts NULL string.  */
   683752:  827:  if (cur_state->halt)
branch  0 taken 71931 (fallthrough)
branch  1 taken 611821
        -:  828:    {
    71931:  829:      if (!cur_state->has_constraint
branch  0 taken 71717 (fallthrough)
branch  1 taken 214
    71717:  830:	  || check_halt_state_context (preg, cur_state, mctx, cur_str_idx))
call    0 returned 71717
branch  1 taken 1804 (fallthrough)
branch  2 taken 69913
        -:  831:	{
     2018:  832:	  if (!fl_longest_match)
branch  0 taken 0 (fallthrough)
branch  1 taken 2018
    #####:  833:	    return cur_str_idx;
        -:  834:	  else
        -:  835:	    {
     2018:  836:	      match_last = cur_str_idx;
     2018:  837:	      match = 1;
        -:  838:	    }
        -:  839:	}
        -:  840:    }
        -:  841:
  1069287:  842:  while (!re_string_eoi (mctx->input))
branch  0 taken 997910
branch  1 taken 71377 (fallthrough)
        -:  843:    {
  997910*:  844:      cur_state = transit_state (&err, preg, mctx, cur_state,
branch  0 taken 0 (fallthrough)
branch  1 taken 997910
branch  2 never executed
branch  3 never executed
call    4 returned 997910
        -:  845:				 fl_search && !match);
   997910:  846:      if (cur_state == NULL) /* Reached at the invalid state or an error.  */
branch  0 taken 612375 (fallthrough)
branch  1 taken 385535
        -:  847:	{
   612375:  848:	  cur_str_idx = re_string_cur_idx (mctx->input);
   612375:  849:	  if (BE (err != REG_NOERROR, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 612375
    #####:  850:	    return -2;
  612375*:  851:	  if (fl_search && !match)
branch  0 taken 0 (fallthrough)
branch  1 taken 612375
branch  2 never executed
branch  3 never executed
        -:  852:	    {
        -:  853:	      /* Restart from initial state, since we are searching
        -:  854:		 the point from where matching start.  */
        -:  855:#ifdef RE_ENABLE_I18N
        -:  856:	      if (MB_CUR_MAX == 1
        -:  857:		  || re_string_first_byte (mctx->input, cur_str_idx))
        -:  858:#endif /* RE_ENABLE_I18N */
    #####:  859:		cur_state = acquire_init_state_context (&err, preg, mctx,
call    0 never executed
        -:  860:							cur_str_idx);
    #####:  861:	      if (BE (cur_state == NULL && err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  862:		return -2;
    #####:  863:	      if (mctx->state_log != NULL)
branch  0 never executed
branch  1 never executed
    #####:  864:		mctx->state_log[cur_str_idx] = cur_state;
        -:  865:	    }
  612375*:  866:	  else if (!fl_longest_match && match)
branch  0 taken 0 (fallthrough)
branch  1 taken 612375
branch  2 never executed
branch  3 never executed
        -:  867:	    break;
        -:  868:	  else /* (fl_longest_match && match) || (!fl_search && !match)  */
        -:  869:	    {
   612375:  870:	      if (mctx->state_log == NULL)
branch  0 taken 609037 (fallthrough)
branch  1 taken 3338
   609037:  871:		break;
        -:  872:	      else
        -:  873:		{
     3338:  874:		  int max = mctx->state_log_top;
     6676:  875:		  for (; cur_str_idx <= max; ++cur_str_idx)
branch  0 taken 3338
branch  1 taken 3338 (fallthrough)
     3338:  876:		    if (mctx->state_log[cur_str_idx] != NULL)
branch  0 taken 0 (fallthrough)
branch  1 taken 3338
    #####:  877:		      break;
     3338:  878:		  if (cur_str_idx > max)
branch  0 taken 3338 (fallthrough)
branch  1 taken 0
     3338:  879:		    break;
        -:  880:		}
        -:  881:	    }
        -:  882:	}
        -:  883:
   385535:  884:      if (cur_state != NULL && cur_state->halt)
branch  0 taken 385535 (fallthrough)
branch  1 taken 0
branch  2 taken 23095 (fallthrough)
branch  3 taken 362440
        -:  885:	{
        -:  886:	  /* Reached at a halt state.
        -:  887:	     Check the halt state can satisfy the current context.  */
    23095:  888:	  if (!cur_state->has_constraint
branch  0 taken 3298 (fallthrough)
branch  1 taken 19797
     3298:  889:	      || check_halt_state_context (preg, cur_state, mctx,
branch  0 taken 135 (fallthrough)
branch  1 taken 3163
     3298:  890:					   re_string_cur_idx (mctx->input)))
call    0 returned 3298
        -:  891:	    {
        -:  892:	      /* We found an appropriate halt state.  */
    19932:  893:	      match_last = re_string_cur_idx (mctx->input);
    19932:  894:	      match = 1;
    19932:  895:	      if (!fl_longest_match)
branch  0 taken 0 (fallthrough)
branch  1 taken 19932
    #####:  896:		break;
        -:  897:	    }
        -:  898:	}
        -:  899:   }
   683752:  900:  return match_last;
        -:  901:}
        -:  902:
        -:  903:/* Check NODE match the current context.  */
        -:  904:
function check_halt_node_context called 85146 returned 100% blocks executed 80%
    85146:  905:static int check_halt_node_context (dfa, node, context)
        -:  906:    const re_dfa_t *dfa;
        -:  907:    int node;
        -:  908:    unsigned int context;
        -:  909:{
    85146:  910:  re_token_type_t type = dfa->nodes[node].type;
    85146:  911:  unsigned int constraint = dfa->nodes[node].constraint;
    85146:  912:  if (type != END_OF_RE)
branch  0 taken 77486 (fallthrough)
branch  1 taken 7660
    77486:  913:    return 0;
     7660:  914:  if (!constraint)
branch  0 taken 30 (fallthrough)
branch  1 taken 7630
       30:  915:    return 1;
    7630*:  916:  if (NOT_SATISFY_NEXT_CONSTRAINT (constraint, context))
branch  0 taken 0 (fallthrough)
branch  1 taken 7630
branch  2 never executed
branch  3 never executed
branch  4 taken 0 (fallthrough)
branch  5 taken 7630
branch  6 never executed
branch  7 never executed
branch  8 taken 6889 (fallthrough)
branch  9 taken 741
branch 10 taken 1198 (fallthrough)
branch 11 taken 5691
branch 12 taken 0 (fallthrough)
branch 13 taken 1939
branch 14 never executed
branch 15 never executed
     5691:  917:    return 0;
     1939:  918:  return 1;
        -:  919:}
        -:  920:
        -:  921:/* Check the halt state STATE match the current context.
        -:  922:   Return 0 if not match, if the node, STATE has, is a halt node and
        -:  923:   match the context, return the node.  */
        -:  924:
        -:  925:static int
function check_halt_state_context called 75045 returned 100% blocks executed 100%
    75045:  926:check_halt_state_context (preg, state, mctx, idx)
        -:  927:    const regex_t *preg;
        -:  928:    const re_dfastate_t *state;
        -:  929:    const re_match_context_t *mctx;
        -:  930:    int idx;
        -:  931:{
    75045:  932:  re_dfa_t *dfa = (re_dfa_t *) preg->buffer;
        -:  933:  int i;
        -:  934:  unsigned int context;
        -:  935:#ifdef DEBUG
        -:  936:  assert (state->halt);
        -:  937:#endif
    75045:  938:  context = re_string_context_at (mctx->input, idx, mctx->eflags,
    75045:  939:				  preg->newline_anchor);
call    0 returned 75045
   158222:  940:  for (i = 0; i < state->nodes.nelem; ++i)
branch  0 taken 85146
branch  1 taken 73076 (fallthrough)
    85146:  941:    if (check_halt_node_context (dfa, state->nodes.elems[i], context))
call    0 returned 85146
branch  1 taken 1969 (fallthrough)
branch  2 taken 83177
     1969:  942:      return state->nodes.elems[i];
    73076:  943:  return 0;
        -:  944:}
        -:  945:
        -:  946:/* Compute the next node to which "NFA" transit from NODE("NFA" is a NFA
        -:  947:   corresponding to the DFA).
        -:  948:   Return the destination node, and update EPS_VIA_NODES, return -1 in case
        -:  949:   of errors.  */
        -:  950:
        -:  951:static int
function proceed_next_node called 376 returned 100% blocks executed 52%
      376:  952:proceed_next_node (preg, nregs, regs, mctx, pidx, node, eps_via_nodes, fs)
        -:  953:    const regex_t *preg;
        -:  954:    regmatch_t *regs;
        -:  955:    const re_match_context_t *mctx;
        -:  956:    int nregs, *pidx, node;
        -:  957:    re_node_set *eps_via_nodes;
        -:  958:    struct re_fail_stack_t *fs;
        -:  959:{
      376:  960:  re_dfa_t *dfa = (re_dfa_t *)preg->buffer;
        -:  961:  int i, err, dest_node;
      376:  962:  dest_node = -1;
      376:  963:  if (IS_EPSILON_NODE (dfa->nodes[node].type))
branch  0 taken 352 (fallthrough)
branch  1 taken 24
branch  2 taken 253 (fallthrough)
branch  3 taken 99
branch  4 taken 253 (fallthrough)
branch  5 taken 0
branch  6 taken 253 (fallthrough)
branch  7 taken 0
branch  8 taken 253 (fallthrough)
branch  9 taken 0
branch 10 taken 219 (fallthrough)
branch 11 taken 34
branch 12 taken 34 (fallthrough)
branch 13 taken 185
        -:  964:    {
      191:  965:      re_node_set *cur_nodes = &mctx->state_log[*pidx]->nodes;
        -:  966:      int ndest, dest_nodes[2];
      191:  967:      err = re_node_set_insert (eps_via_nodes, node);
call    0 returned 191
      191:  968:      if (BE (err < 0, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 191
    #####:  969:	return -1;
        -:  970:      /* Pick up valid destinations.  */
      505:  971:      for (ndest = 0, i = 0; i < dfa->edests[node].nelem; ++i)
branch  0 taken 314
branch  1 taken 191 (fallthrough)
        -:  972:	{
      314:  973:	  int candidate = dfa->edests[node].elems[i];
      314:  974:	  if (!re_node_set_contains (cur_nodes, candidate))
call    0 returned 314
branch  1 taken 123 (fallthrough)
branch  2 taken 191
      123:  975:	    continue;
     191*:  976:	  dest_nodes[0] = (ndest == 0) ? candidate : dest_nodes[0];
branch  0 taken 0 (fallthrough)
branch  1 taken 191
     191*:  977:	  dest_nodes[1] = (ndest == 1) ? candidate : dest_nodes[1];
branch  0 taken 191 (fallthrough)
branch  1 taken 0
      191:  978:	  ++ndest;
        -:  979:	}
      191:  980:      if (ndest <= 1)
branch  0 taken 191 (fallthrough)
branch  1 taken 0
     191*:  981:	return ndest == 0 ? -1 : (ndest == 1 ? dest_nodes[0] : 0);
branch  0 taken 191 (fallthrough)
branch  1 taken 0
branch  2 taken 191 (fallthrough)
branch  3 taken 0
        -:  982:      /* In order to avoid infinite loop like "(a*)*".  */
    #####:  983:      if (re_node_set_contains (eps_via_nodes, dest_nodes[0]))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  984:	return dest_nodes[1];
    #####:  985:      if (fs != NULL)
branch  0 never executed
branch  1 never executed
    #####:  986:	push_fail_stack (fs, *pidx, dest_nodes, nregs, regs, eps_via_nodes);
call    0 never executed
    #####:  987:      return dest_nodes[0];
        -:  988:    }
        -:  989:  else
        -:  990:    {
      185:  991:      int naccepted = 0;
      185:  992:      re_token_type_t type = dfa->nodes[node].type;
        -:  993:
        -:  994:#ifdef RE_ENABLE_I18N
        -:  995:      if (ACCEPT_MB_NODE (type))
        -:  996:	naccepted = check_node_accept_bytes (preg, node, mctx->input, *pidx);
        -:  997:      else
        -:  998:#endif /* RE_ENABLE_I18N */
      185:  999:      if (type == OP_BACK_REF)
branch  0 taken 0 (fallthrough)
branch  1 taken 185
        -: 1000:	{
    #####: 1001:	  int subexp_idx = dfa->nodes[node].opr.idx;
    #####: 1002:	  naccepted = regs[subexp_idx].rm_eo - regs[subexp_idx].rm_so;
    #####: 1003:	  if (fs != NULL)
branch  0 never executed
branch  1 never executed
        -: 1004:	    {
    #####: 1005:	      if (regs[subexp_idx].rm_so == -1 || regs[subexp_idx].rm_eo == -1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1006:		return -1;
    #####: 1007:	      else if (naccepted)
branch  0 never executed
branch  1 never executed
        -: 1008:		{
    #####: 1009:		  char *buf = re_string_get_buffer (mctx->input);
    #####: 1010:		  if (my_memcmp (buf + regs[subexp_idx].rm_so, buf + *pidx,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1011:			         naccepted) != 0)
    #####: 1012:		    return -1;
        -: 1013:		}
        -: 1014:	    }
        -: 1015:
    #####: 1016:	  if (naccepted == 0)
branch  0 never executed
branch  1 never executed
        -: 1017:	    {
    #####: 1018:	      err = re_node_set_insert (eps_via_nodes, node);
call    0 never executed
    #####: 1019:	      if (BE (err < 0, 0))
branch  0 never executed
branch  1 never executed
    #####: 1020:		return -2;
    #####: 1021:	      dest_node = dfa->edests[node].elems[0];
    #####: 1022:	      if (re_node_set_contains (&mctx->state_log[*pidx]->nodes,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1023:					dest_node))
    #####: 1024:		return dest_node;
        -: 1025:	    }
        -: 1026:	}
        -: 1027:
      185: 1028:      if (naccepted != 0
branch  0 taken 185 (fallthrough)
branch  1 taken 0
      185: 1029:	  || check_node_accept (preg, dfa->nodes + node, mctx, *pidx))
call    0 returned 185
branch  1 taken 185 (fallthrough)
branch  2 taken 0
        -: 1030:	{
      185: 1031:	  dest_node = dfa->nexts[node];
     185*: 1032:	  *pidx = (naccepted == 0) ? *pidx + 1 : *pidx + naccepted;
branch  0 taken 185 (fallthrough)
branch  1 taken 0
     185*: 1033:	  if (fs && (*pidx > mctx->match_last || mctx->state_log[*pidx] == NULL
branch  0 taken 0 (fallthrough)
branch  1 taken 185
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1034:		     || !re_node_set_contains (&mctx->state_log[*pidx]->nodes,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1035:					       dest_node)))
    #####: 1036:	    return -1;
      185: 1037:	  re_node_set_empty (eps_via_nodes);
      185: 1038:	  return dest_node;
        -: 1039:	}
        -: 1040:    }
    #####: 1041:  return -1;
        -: 1042:}
        -: 1043:
        -: 1044:static reg_errcode_t
function push_fail_stack called 0 returned 0% blocks executed 0%
    #####: 1045:push_fail_stack (fs, str_idx, dests, nregs, regs, eps_via_nodes)
        -: 1046:     struct re_fail_stack_t *fs;
        -: 1047:     int str_idx, *dests, nregs;
        -: 1048:     regmatch_t *regs;
        -: 1049:     re_node_set *eps_via_nodes;
        -: 1050:{
        -: 1051:  reg_errcode_t err;
    #####: 1052:  int num = fs->num++;
    #####: 1053:  if (fs->num == fs->alloc)
branch  0 never executed
branch  1 never executed
        -: 1054:    {
        -: 1055:      struct re_fail_stack_ent_t *new_array;
    #####: 1056:      fs->alloc *= 2;
    #####: 1057:      new_array = realloc (fs->stack, (sizeof (struct re_fail_stack_ent_t)
    #####: 1058:				       * fs->alloc));
    #####: 1059:      if (new_array == NULL)
branch  0 never executed
branch  1 never executed
    #####: 1060:	return REG_ESPACE;
    #####: 1061:      fs->stack = new_array;
        -: 1062:    }
    #####: 1063:  fs->stack[num].idx = str_idx;
    #####: 1064:  fs->stack[num].node = dests[1];
    #####: 1065:  fs->stack[num].regs = re_malloc (regmatch_t, nregs);
    #####: 1066:  memcpy (fs->stack[num].regs, regs, sizeof (regmatch_t) * nregs);
    #####: 1067:  err = re_node_set_init_copy (&fs->stack[num].eps_via_nodes, eps_via_nodes);
call    0 never executed
    #####: 1068:  return err;
        -: 1069:}
        -: 1070:
        -: 1071:static int
function pop_fail_stack called 0 returned 0% blocks executed 0%
    #####: 1072:pop_fail_stack (fs, pidx, nregs, regs, eps_via_nodes)
        -: 1073:     struct re_fail_stack_t *fs;
        -: 1074:     int *pidx, nregs;
        -: 1075:     regmatch_t *regs;
        -: 1076:     re_node_set *eps_via_nodes;
        -: 1077:{
    #####: 1078:  int num = --fs->num;
    #####: 1079:  assert (num >= 0);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1080: *pidx = fs->stack[num].idx;
    #####: 1081:  memcpy (regs, fs->stack[num].regs, sizeof (regmatch_t) * nregs);
    #####: 1082:  re_node_set_free (eps_via_nodes);
    #####: 1083:  re_free (fs->stack[num].regs);
    #####: 1084:  *eps_via_nodes = fs->stack[num].eps_via_nodes;
    #####: 1085:  return fs->stack[num].node;
        -: 1086:}
        -: 1087:
        -: 1088:/* Set the positions where the subexpressions are starts/ends to registers
        -: 1089:   PMATCH.
        -: 1090:   Note: We assume that pmatch[0] is already set, and
        -: 1091:   pmatch[i].rm_so == pmatch[i].rm_eo == -1 (i > 1).  */
        -: 1092:
        -: 1093:static reg_errcode_t
function set_regs called 30 returned 100% blocks executed 45%
       30: 1094:set_regs (preg, mctx, nmatch, pmatch, fl_backtrack)
        -: 1095:     const regex_t *preg;
        -: 1096:     const re_match_context_t *mctx;
        -: 1097:     size_t nmatch;
        -: 1098:     regmatch_t *pmatch;
        -: 1099:     int fl_backtrack;
        -: 1100:{
       30: 1101:  re_dfa_t *dfa = (re_dfa_t *)preg->buffer;
        -: 1102:  int idx, cur_node, real_nmatch;
        -: 1103:  re_node_set eps_via_nodes;
        -: 1104:  struct re_fail_stack_t *fs;
       30: 1105:  struct re_fail_stack_t fs_body = {0, 2, NULL};
        -: 1106:#ifdef DEBUG
        -: 1107:  assert (nmatch > 1);
        -: 1108:  assert (mctx->state_log != NULL);
        -: 1109:#endif
       30: 1110:  if (fl_backtrack)
branch  0 taken 0 (fallthrough)
branch  1 taken 30
        -: 1111:    {
    #####: 1112:      fs = &fs_body;
    #####: 1113:      fs->stack = re_malloc (struct re_fail_stack_ent_t, fs->alloc);
        -: 1114:    }
        -: 1115:  else
       30: 1116:    fs = NULL;
       30: 1117:  cur_node = dfa->init_node;
      30*: 1118:  real_nmatch = (nmatch <= preg->re_nsub) ? nmatch : preg->re_nsub + 1;
branch  0 taken 30 (fallthrough)
branch  1 taken 0
       30: 1119:  re_node_set_init_empty (&eps_via_nodes);
      406: 1120:  for (idx = pmatch[0].rm_so; idx <= pmatch[0].rm_eo ;)
branch  0 taken 406
branch  1 taken 0 (fallthrough)
        -: 1121:    {
      406: 1122:      update_regs (dfa, pmatch, cur_node, idx, real_nmatch);
call    0 returned 406
      406: 1123:      if (idx == pmatch[0].rm_eo && cur_node == mctx->last_node)
branch  0 taken 54 (fallthrough)
branch  1 taken 352
branch  2 taken 30 (fallthrough)
branch  3 taken 24
        -: 1124:	{
        -: 1125:	  int reg_idx;
       30: 1126:	  if (fs)
branch  0 taken 0 (fallthrough)
branch  1 taken 30
        -: 1127:	    {
    #####: 1128:	      for (reg_idx = 0; reg_idx < nmatch; ++reg_idx)
branch  0 never executed
branch  1 never executed
    #####: 1129:		if (pmatch[reg_idx].rm_so > -1 && pmatch[reg_idx].rm_eo == -1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1130:		  break;
    #####: 1131:	      if (reg_idx == nmatch)
branch  0 never executed
branch  1 never executed
        -: 1132:		{
    #####: 1133:		  re_node_set_free (&eps_via_nodes);
    #####: 1134:		  return free_fail_stack_return (fs);
call    0 never executed
        -: 1135:		}
    #####: 1136:	      cur_node = pop_fail_stack (fs, &idx, nmatch, pmatch,
call    0 never executed
        -: 1137:					 &eps_via_nodes);
        -: 1138:	    }
        -: 1139:	  else
        -: 1140:	    {
       30: 1141:	      re_node_set_free (&eps_via_nodes);
       30: 1142:	      return REG_NOERROR;
        -: 1143:	    }
        -: 1144:	}
        -: 1145:
        -: 1146:      /* Proceed to next node.  */
      376: 1147:      cur_node = proceed_next_node (preg, nmatch, pmatch, mctx, &idx, cur_node,
call    0 returned 376
        -: 1148:				    &eps_via_nodes, fs);
        -: 1149:
      376: 1150:      if (BE (cur_node < 0, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 376
        -: 1151:	{
    #####: 1152:	  if (cur_node == -2)
branch  0 never executed
branch  1 never executed
    #####: 1153:	    return REG_ESPACE;
    #####: 1154:	  if (fs)
branch  0 never executed
branch  1 never executed
    #####: 1155:	    cur_node = pop_fail_stack (fs, &idx, nmatch, pmatch,
call    0 never executed
        -: 1156:				       &eps_via_nodes);
        -: 1157:	  else
        -: 1158:	    {
    #####: 1159:	      re_node_set_free (&eps_via_nodes);
    #####: 1160:	      return REG_NOMATCH;
        -: 1161:	    }
        -: 1162:	}
        -: 1163:    }
    #####: 1164:  re_node_set_free (&eps_via_nodes);
    #####: 1165:  return free_fail_stack_return (fs);
call    0 never executed
        -: 1166:}
        -: 1167:
        -: 1168:static reg_errcode_t
function free_fail_stack_return called 0 returned 0% blocks executed 0%
    #####: 1169:free_fail_stack_return (fs)
        -: 1170:     struct re_fail_stack_t *fs;
        -: 1171:{
    #####: 1172:  if (fs)
branch  0 never executed
branch  1 never executed
        -: 1173:    {
        -: 1174:      int fs_idx;
    #####: 1175:      for (fs_idx = 0; fs_idx < fs->num; ++fs_idx)
branch  0 never executed
branch  1 never executed
        -: 1176:	{
    #####: 1177:	  re_node_set_free (&fs->stack[fs_idx].eps_via_nodes);
    #####: 1178:	  re_free (fs->stack[fs_idx].regs);
        -: 1179:	}
    #####: 1180:      re_free (fs->stack);
        -: 1181:    }
    #####: 1182:  return REG_NOERROR;
        -: 1183:}
        -: 1184:
        -: 1185:static void
function update_regs called 406 returned 100% blocks executed 90%
      406: 1186:update_regs (dfa, pmatch, cur_node, cur_idx, nmatch)
        -: 1187:     re_dfa_t *dfa;
        -: 1188:     regmatch_t *pmatch;
        -: 1189:     int cur_node, cur_idx, nmatch;
        -: 1190:{
      406: 1191:  int type = dfa->nodes[cur_node].type;
        -: 1192:  int reg_num;
      406: 1193:  if (type != OP_OPEN_SUBEXP && type != OP_CLOSE_SUBEXP)
branch  0 taken 372 (fallthrough)
branch  1 taken 34
branch  2 taken 338 (fallthrough)
branch  3 taken 34
      338: 1194:    return;
       68: 1195:  reg_num = dfa->nodes[cur_node].opr.idx + 1;
       68: 1196:  if (reg_num >= nmatch)
branch  0 taken 0 (fallthrough)
branch  1 taken 68
    #####: 1197:    return;
       68: 1198:  if (type == OP_OPEN_SUBEXP)
branch  0 taken 34 (fallthrough)
branch  1 taken 34
        -: 1199:    {
        -: 1200:      /* We are at the first node of this sub expression.  */
       34: 1201:      pmatch[reg_num].rm_so = cur_idx;
       34: 1202:      pmatch[reg_num].rm_eo = -1;
        -: 1203:    }
       34: 1204:  else if (type == OP_CLOSE_SUBEXP)
branch  0 taken 34 (fallthrough)
branch  1 taken 0
        -: 1205:    /* We are at the first node of this sub expression.  */
       34: 1206:    pmatch[reg_num].rm_eo = cur_idx;
        -: 1207:}
        -: 1208:
        -: 1209:#define NUMBER_OF_STATE 1
        -: 1210:
        -: 1211:/* This function checks the STATE_LOG from the SCTX->last_str_idx to 0
        -: 1212:   and sift the nodes in each states according to the following rules.
        -: 1213:   Updated state_log will be wrote to STATE_LOG.
        -: 1214:
        -: 1215:   Rules: We throw away the Node `a' in the STATE_LOG[STR_IDX] if...
        -: 1216:     1. When STR_IDX == MATCH_LAST(the last index in the state_log):
        -: 1217:	If `a' isn't the LAST_NODE and `a' can't epsilon transit to
        -: 1218:	the LAST_NODE, we throw away the node `a'.
        -: 1219:     2. When 0 <= STR_IDX < MATCH_LAST and `a' accepts
        -: 1220:	string `s' and transit to `b':
        -: 1221:	i. If 'b' isn't in the STATE_LOG[STR_IDX+strlen('s')], we throw
        -: 1222:	   away the node `a'.
        -: 1223:	ii. If 'b' is in the STATE_LOG[STR_IDX+strlen('s')] but 'b' is
        -: 1224:	    throwed away, we throw away the node `a'.
        -: 1225:     3. When 0 <= STR_IDX < n and 'a' epsilon transit to 'b':
        -: 1226:	i. If 'b' isn't in the STATE_LOG[STR_IDX], we throw away the
        -: 1227:	   node `a'.
        -: 1228:	ii. If 'b' is in the STATE_LOG[STR_IDX] but 'b' is throwed away,
        -: 1229:	    we throw away the node `a'.  */
        -: 1230:
        -: 1231:#define STATE_NODE_CONTAINS(state,node) \
        -: 1232:  ((state) != NULL && re_node_set_contains (&(state)->nodes, node))
        -: 1233:
        -: 1234:static reg_errcode_t
function sift_states_backward called 30 returned 100% blocks executed 80%
       30: 1235:sift_states_backward (preg, mctx, sctx)
        -: 1236:     const regex_t *preg;
        -: 1237:     re_match_context_t *mctx;
        -: 1238:     re_sift_context_t *sctx;
        -: 1239:{
        -: 1240:  reg_errcode_t err;
       30: 1241:  re_dfa_t *dfa = (re_dfa_t *)preg->buffer;
       30: 1242:  int null_cnt = 0;
       30: 1243:  int str_idx = sctx->last_str_idx;
        -: 1244:  re_node_set cur_dest;
        -: 1245:  re_node_set *cur_src; /* Points the state_log[str_idx]->nodes  */
        -: 1246:
        -: 1247:#ifdef DEBUG
        -: 1248:  assert (mctx->state_log != NULL && mctx->state_log[str_idx] != NULL);
        -: 1249:#endif
       30: 1250:  cur_src = &mctx->state_log[str_idx]->nodes;
        -: 1251:
        -: 1252:  /* Build sifted state_log[str_idx].  It has the nodes which can epsilon
        -: 1253:     transit to the last_node and the last_node itself.  */
       30: 1254:  err = re_node_set_init_1 (&cur_dest, sctx->last_node);
call    0 returned 30
       30: 1255:  if (BE (err != REG_NOERROR, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 30
    #####: 1256:    return err;
       30: 1257:  err = update_cur_sifted_state (preg, mctx, sctx, str_idx, &cur_dest);
call    0 returned 30
       30: 1258:  if (BE (err != REG_NOERROR, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 30
    #####: 1259:    goto free_return;
        -: 1260:
        -: 1261:  /* Then check each states in the state_log.  */
      215: 1262:  while (str_idx > 0)
branch  0 taken 185
branch  1 taken 30 (fallthrough)
        -: 1263:    {
        -: 1264:      int i, ret;
        -: 1265:      /* Update counters.  */
     185*: 1266:      null_cnt = (sctx->sifted_states[str_idx] == NULL) ? null_cnt + 1 : 0;
branch  0 taken 0 (fallthrough)
branch  1 taken 185
      185: 1267:      if (null_cnt > mctx->max_mb_elem_len)
branch  0 taken 0 (fallthrough)
branch  1 taken 185
        -: 1268:	{
    #####: 1269:	  memset (sctx->sifted_states, '\0',
        -: 1270:		  sizeof (re_dfastate_t *) * str_idx);
    #####: 1271:	  re_node_set_free (&cur_dest);
    #####: 1272:	  return REG_NOERROR;
        -: 1273:	}
      185: 1274:      re_node_set_empty (&cur_dest);
      185: 1275:      --str_idx;
      370: 1276:      cur_src = ((mctx->state_log[str_idx] == NULL) ? &empty_set
     185*: 1277:		 : &mctx->state_log[str_idx]->nodes);
branch  0 taken 185 (fallthrough)
branch  1 taken 0
        -: 1278:
        -: 1279:      /* Then build the next sifted state.
        -: 1280:	 We build the next sifted state on `cur_dest', and update
        -: 1281:	 `sifted_states[str_idx]' with `cur_dest'.
        -: 1282:	 Note:
        -: 1283:	 `cur_dest' is the sifted state from `state_log[str_idx + 1]'.
        -: 1284:	 `cur_src' points the node_set of the old `state_log[str_idx]'.  */
     1041: 1285:      for (i = 0; i < cur_src->nelem; i++)
branch  0 taken 856
branch  1 taken 185 (fallthrough)
        -: 1286:	{
      856: 1287:	  int prev_node = cur_src->elems[i];
      856: 1288:	  int naccepted = 0;
      856: 1289:	  re_token_type_t type = dfa->nodes[prev_node].type;
        -: 1290:
      856: 1291:	  if (IS_EPSILON_NODE(type))
branch  0 taken 832 (fallthrough)
branch  1 taken 24
branch  2 taken 668 (fallthrough)
branch  3 taken 164
branch  4 taken 668 (fallthrough)
branch  5 taken 0
branch  6 taken 668 (fallthrough)
branch  7 taken 0
branch  8 taken 668 (fallthrough)
branch  9 taken 0
branch 10 taken 609 (fallthrough)
branch 11 taken 59
branch 12 taken 164 (fallthrough)
branch 13 taken 445
      411: 1292:	    continue;
        -: 1293:#ifdef RE_ENABLE_I18N
        -: 1294:	  /* If the node may accept `multi byte'.  */
        -: 1295:	  if (ACCEPT_MB_NODE (type))
        -: 1296:	    naccepted = sift_states_iter_mb (preg, mctx, sctx, prev_node,
        -: 1297:					     str_idx, sctx->last_str_idx);
        -: 1298:
        -: 1299:#endif /* RE_ENABLE_I18N */
        -: 1300:	  /* We don't check backreferences here.
        -: 1301:	     See update_cur_sifted_state().  */
        -: 1302:
      445: 1303:	  if (!naccepted
branch  0 taken 445 (fallthrough)
branch  1 taken 0
      445: 1304:	      && check_node_accept (preg, dfa->nodes + prev_node, mctx,
call    0 returned 445
branch  1 taken 272 (fallthrough)
branch  2 taken 173
        -: 1305:				    str_idx)
      272: 1306:	      && STATE_NODE_CONTAINS (sctx->sifted_states[str_idx + 1],
branch  0 taken 272 (fallthrough)
branch  1 taken 0
call    2 returned 272
branch  3 taken 185 (fallthrough)
branch  4 taken 87
        -: 1307:				      dfa->nexts[prev_node]))
      185: 1308:	    naccepted = 1;
        -: 1309:
      445: 1310:	  if (naccepted == 0)
branch  0 taken 260 (fallthrough)
branch  1 taken 185
      260: 1311:	    continue;
        -: 1312:
      185: 1313:	  if (sctx->limits.nelem)
branch  0 taken 0 (fallthrough)
branch  1 taken 185
        -: 1314:	    {
    #####: 1315:	      int to_idx = str_idx + naccepted;
    #####: 1316:	      if (check_dst_limits (dfa, &sctx->limits, mctx,
branch  0 never executed
branch  1 never executed
    #####: 1317:				    dfa->nexts[prev_node], to_idx,
call    0 never executed
        -: 1318:				    prev_node, str_idx))
    #####: 1319:		continue;
        -: 1320:	    }
      185: 1321:	  ret = re_node_set_insert (&cur_dest, prev_node);
call    0 returned 185
      185: 1322:	  if (BE (ret == -1, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 185
        -: 1323:	    {
    #####: 1324:	      err = REG_ESPACE;
    #####: 1325:	      goto free_return;
        -: 1326:	    }
        -: 1327:	}
        -: 1328:
        -: 1329:      /* Add all the nodes which satisfy the following conditions:
        -: 1330:	 - It can epsilon transit to a node in CUR_DEST.
        -: 1331:	 - It is in CUR_SRC.
        -: 1332:	 And update state_log.  */
      185: 1333:      err = update_cur_sifted_state (preg, mctx, sctx, str_idx, &cur_dest);
call    0 returned 185
      185: 1334:      if (BE (err != REG_NOERROR, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 185
    #####: 1335:	goto free_return;
        -: 1336:    }
       30: 1337:  err = REG_NOERROR;
       30: 1338: free_return:
       30: 1339:  re_node_set_free (&cur_dest);
       30: 1340:  return err;
        -: 1341:}
        -: 1342:
        -: 1343:/* Helper functions.  */
        -: 1344:
        -: 1345:static inline reg_errcode_t
function clean_state_log_if_need called 0 returned 0% blocks executed 0%
    #####: 1346:clean_state_log_if_need (mctx, next_state_log_idx)
        -: 1347:    re_match_context_t *mctx;
        -: 1348:    int next_state_log_idx;
        -: 1349:{
    #####: 1350:  int top = mctx->state_log_top;
        -: 1351:
    #####: 1352:  if (next_state_log_idx >= mctx->input->bufs_len
branch  0 never executed
branch  1 never executed
    #####: 1353:      || (next_state_log_idx >= mctx->input->valid_len
branch  0 never executed
branch  1 never executed
    #####: 1354:	  && mctx->input->valid_len < mctx->input->len))
branch  0 never executed
branch  1 never executed
        -: 1355:    {
        -: 1356:      reg_errcode_t err;
    #####: 1357:      err = extend_buffers (mctx);
call    0 never executed
    #####: 1358:      if (BE (err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 1359:	return err;
        -: 1360:    }
        -: 1361:
    #####: 1362:  if (top < next_state_log_idx)
branch  0 never executed
branch  1 never executed
        -: 1363:    {
    #####: 1364:      memset (mctx->state_log + top + 1, '\0',
    #####: 1365:	      sizeof (re_dfastate_t *) * (next_state_log_idx - top));
    #####: 1366:      mctx->state_log_top = next_state_log_idx;
        -: 1367:    }
    #####: 1368:  return REG_NOERROR;
        -: 1369:}
        -: 1370:
        -: 1371:static reg_errcode_t
function merge_state_array called 0 returned 0% blocks executed 0%
    #####: 1372:merge_state_array (dfa, dst, src, num)
        -: 1373:     re_dfa_t *dfa;
        -: 1374:     re_dfastate_t **dst;
        -: 1375:     re_dfastate_t **src;
        -: 1376:     int num;
        -: 1377:{
        -: 1378:  int st_idx;
        -: 1379:  reg_errcode_t err;
    #####: 1380:  for (st_idx = 0; st_idx < num; ++st_idx)
branch  0 never executed
branch  1 never executed
        -: 1381:    {
    #####: 1382:      if (dst[st_idx] == NULL)
branch  0 never executed
branch  1 never executed
    #####: 1383:	dst[st_idx] = src[st_idx];
    #####: 1384:      else if (src[st_idx] != NULL)
branch  0 never executed
branch  1 never executed
        -: 1385:	{
        -: 1386:	  re_node_set merged_set;
    #####: 1387:	  err = re_node_set_init_union (&merged_set, &dst[st_idx]->nodes,
    #####: 1388:					&src[st_idx]->nodes);
call    0 never executed
    #####: 1389:	  if (BE (err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 1390:	    return err;
    #####: 1391:	  dst[st_idx] = re_acquire_state (&err, dfa, &merged_set);
call    0 never executed
    #####: 1392:	  re_node_set_free (&merged_set);
    #####: 1393:	  if (BE (err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 1394:	    return err;
        -: 1395:	}
        -: 1396:    }
    #####: 1397:  return REG_NOERROR;
        -: 1398:}
        -: 1399:
        -: 1400:static reg_errcode_t
function update_cur_sifted_state called 215 returned 100% blocks executed 58%
      215: 1401:update_cur_sifted_state (preg, mctx, sctx, str_idx, dest_nodes)
        -: 1402:     const regex_t *preg;
        -: 1403:     re_match_context_t *mctx;
        -: 1404:     re_sift_context_t *sctx;
        -: 1405:     int str_idx;
        -: 1406:     re_node_set *dest_nodes;
        -: 1407:{
        -: 1408:  reg_errcode_t err;
      215: 1409:  re_dfa_t *dfa = (re_dfa_t *)preg->buffer;
        -: 1410:  const re_node_set *candidates;
     215*: 1411:  candidates = ((mctx->state_log[str_idx] == NULL) ? &empty_set
branch  0 taken 215 (fallthrough)
branch  1 taken 0
      215: 1412:		: &mctx->state_log[str_idx]->nodes);
        -: 1413:
        -: 1414:  /* At first, add the nodes which can epsilon transit to a node in
        -: 1415:     DEST_NODE.  */
      215: 1416:  if (dest_nodes->nelem)
branch  0 taken 215 (fallthrough)
branch  1 taken 0
        -: 1417:    {
      215: 1418:      err = add_epsilon_src_nodes (dfa, dest_nodes, candidates);
call    0 returned 215
      215: 1419:      if (BE (err != REG_NOERROR, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 215
    #####: 1420:	return err;
        -: 1421:    }
        -: 1422:
        -: 1423:  /* Then, check the limitations in the current sift_context.  */
      215: 1424:  if (dest_nodes->nelem && sctx->limits.nelem)
branch  0 taken 215 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 215
        -: 1425:    {
    #####: 1426:      err = check_subexp_limits (dfa, dest_nodes, candidates, &sctx->limits,
call    0 never executed
        -: 1427:				 mctx->bkref_ents, str_idx);
    #####: 1428:      if (BE (err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 1429:	return err;
        -: 1430:    }
        -: 1431:
        -: 1432:  /* Update state_log.  */
      215: 1433:  sctx->sifted_states[str_idx] = re_acquire_state (&err, dfa, dest_nodes);
call    0 returned 215
     215*: 1434:  if (BE (sctx->sifted_states[str_idx] == NULL && err != REG_NOERROR, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 215
branch  2 never executed
branch  3 never executed
    #####: 1435:    return err;
        -: 1436:
      215: 1437:  if ((mctx->state_log[str_idx] != NULL
branch  0 taken 215 (fallthrough)
branch  1 taken 0
      215: 1438:       && mctx->state_log[str_idx]->has_backref))
branch  0 taken 0 (fallthrough)
branch  1 taken 215
        -: 1439:    {
    #####: 1440:      err = sift_states_bkref (preg, mctx, sctx, str_idx, dest_nodes);
call    0 never executed
    #####: 1441:      if (BE (err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 1442:	return err;
        -: 1443:    }
      215: 1444:  return REG_NOERROR;
        -: 1445:}
        -: 1446:
        -: 1447:static reg_errcode_t
function add_epsilon_src_nodes called 215 returned 100% blocks executed 83%
      215: 1448:add_epsilon_src_nodes (dfa, dest_nodes, candidates)
        -: 1449:     re_dfa_t *dfa;
        -: 1450:     re_node_set *dest_nodes;
        -: 1451:     const re_node_set *candidates;
        -: 1452:{
        -: 1453:  reg_errcode_t err;
        -: 1454:  int src_idx;
        -: 1455:  re_node_set src_copy;
        -: 1456:
      215: 1457:  err = re_node_set_init_copy (&src_copy, dest_nodes);
call    0 returned 215
      215: 1458:  if (BE (err != REG_NOERROR, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 215
    #####: 1459:    return err;
      430: 1460:  for (src_idx = 0; src_idx < src_copy.nelem; ++src_idx)
branch  0 taken 215
branch  1 taken 215 (fallthrough)
        -: 1461:    {
      215: 1462:      err = re_node_set_add_intersect (dest_nodes, candidates,
      215: 1463:				       dfa->inveclosures
      215: 1464:				       + src_copy.elems[src_idx]);
call    0 returned 215
      215: 1465:      if (BE (err != REG_NOERROR, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 215
        -: 1466:	{
    #####: 1467:	  re_node_set_free (&src_copy);
    #####: 1468:	  return err;
        -: 1469:	}
        -: 1470:    }
      215: 1471:  re_node_set_free (&src_copy);
      215: 1472:  return REG_NOERROR;
        -: 1473:}
        -: 1474:
        -: 1475:static reg_errcode_t
function sub_epsilon_src_nodes called 0 returned 0% blocks executed 0%
    #####: 1476:sub_epsilon_src_nodes (dfa, node, dest_nodes, candidates)
        -: 1477:     re_dfa_t *dfa;
        -: 1478:     int node;
        -: 1479:     re_node_set *dest_nodes;
        -: 1480:     const re_node_set *candidates;
        -: 1481:{
        -: 1482:    int ecl_idx;
        -: 1483:    reg_errcode_t err;
    #####: 1484:    re_node_set *inv_eclosure = dfa->inveclosures + node;
        -: 1485:    re_node_set except_nodes;
    #####: 1486:    re_node_set_init_empty (&except_nodes);
    #####: 1487:    for (ecl_idx = 0; ecl_idx < inv_eclosure->nelem; ++ecl_idx)
branch  0 never executed
branch  1 never executed
        -: 1488:      {
    #####: 1489:	int cur_node = inv_eclosure->elems[ecl_idx];
    #####: 1490:	if (cur_node == node)
branch  0 never executed
branch  1 never executed
    #####: 1491:	  continue;
    #####: 1492:	if (IS_EPSILON_NODE (dfa->nodes[cur_node].type))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
        -: 1493:	  {
    #####: 1494:	    int edst1 = dfa->edests[cur_node].elems[0];
    #####: 1495:	    int edst2 = ((dfa->edests[cur_node].nelem > 1)
    #####: 1496:			 ? dfa->edests[cur_node].elems[1] : -1);
branch  0 never executed
branch  1 never executed
    #####: 1497:	    if ((!re_node_set_contains (inv_eclosure, edst1)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1498:		 && re_node_set_contains (dest_nodes, edst1))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1499:		|| (edst2 > 0
branch  0 never executed
branch  1 never executed
    #####: 1500:		    && !re_node_set_contains (inv_eclosure, edst2)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1501:		    && re_node_set_contains (dest_nodes, edst2)))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1502:	      {
    #####: 1503:		err = re_node_set_add_intersect (&except_nodes, candidates,
    #####: 1504:						 dfa->inveclosures + cur_node);
call    0 never executed
    #####: 1505:		if (BE (err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
        -: 1506:		  {
    #####: 1507:		    re_node_set_free (&except_nodes);
    #####: 1508:		    return err;
        -: 1509:		  }
        -: 1510:	      }
        -: 1511:	  }
        -: 1512:      }
    #####: 1513:    for (ecl_idx = 0; ecl_idx < inv_eclosure->nelem; ++ecl_idx)
branch  0 never executed
branch  1 never executed
        -: 1514:      {
    #####: 1515:	int cur_node = inv_eclosure->elems[ecl_idx];
    #####: 1516:	if (!re_node_set_contains (&except_nodes, cur_node))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1517:	  {
    #####: 1518:	    int idx = re_node_set_contains (dest_nodes, cur_node) - 1;
call    0 never executed
    #####: 1519:	    re_node_set_remove_at (dest_nodes, idx);
call    0 never executed
        -: 1520:	  }
        -: 1521:      }
    #####: 1522:    re_node_set_free (&except_nodes);
    #####: 1523:    return REG_NOERROR;
        -: 1524:}
        -: 1525:
        -: 1526:static int
function check_dst_limits called 0 returned 0% blocks executed 0%
    #####: 1527:check_dst_limits (dfa, limits, mctx, dst_node, dst_idx, src_node, src_idx)
        -: 1528:     re_dfa_t *dfa;
        -: 1529:     re_node_set *limits;
        -: 1530:     re_match_context_t *mctx;
        -: 1531:     int dst_node, dst_idx, src_node, src_idx;
        -: 1532:{
        -: 1533:  int lim_idx, src_pos, dst_pos;
        -: 1534:
    #####: 1535:  for (lim_idx = 0; lim_idx < limits->nelem; ++lim_idx)
branch  0 never executed
branch  1 never executed
        -: 1536:    {
        -: 1537:      int subexp_idx;
        -: 1538:      struct re_backref_cache_entry *ent;
    #####: 1539:      ent = mctx->bkref_ents + limits->elems[lim_idx];
    #####: 1540:      subexp_idx = dfa->nodes[ent->node].opr.idx - 1;
        -: 1541:
    #####: 1542:      dst_pos = check_dst_limits_calc_pos (dfa, mctx, limits->elems[lim_idx],
    #####: 1543:					   dfa->eclosures + dst_node,
call    0 never executed
        -: 1544:					   subexp_idx, dst_node, dst_idx);
    #####: 1545:      src_pos = check_dst_limits_calc_pos (dfa, mctx, limits->elems[lim_idx],
    #####: 1546:					   dfa->eclosures + src_node,
call    0 never executed
        -: 1547:					   subexp_idx, src_node, src_idx);
        -: 1548:
        -: 1549:      /* In case of:
        -: 1550:	 <src> <dst> ( <subexp> )
        -: 1551:	 ( <subexp> ) <src> <dst>
        -: 1552:	 ( <subexp1> <src> <subexp2> <dst> <subexp3> )  */
    #####: 1553:      if (src_pos == dst_pos)
branch  0 never executed
branch  1 never executed
    #####: 1554:	continue; /* This is unrelated limitation.  */
        -: 1555:      else
    #####: 1556:	return 1;
        -: 1557:    }
    #####: 1558:  return 0;
        -: 1559:}
        -: 1560:
        -: 1561:static int
function check_dst_limits_calc_pos called 0 returned 0% blocks executed 0%
    #####: 1562:check_dst_limits_calc_pos (dfa, mctx, limit, eclosures, subexp_idx, node,
        -: 1563:			   str_idx)
        -: 1564:     re_dfa_t *dfa;
        -: 1565:     re_match_context_t *mctx;
        -: 1566:     re_node_set *eclosures;
        -: 1567:     int limit, subexp_idx, node, str_idx;
        -: 1568:{
    #####: 1569:  struct re_backref_cache_entry *lim = mctx->bkref_ents + limit;
    #####: 1570:  int pos = (str_idx < lim->subexp_from ? -1
    #####: 1571:	     : (lim->subexp_to < str_idx ? 1 : 0));
branch  0 never executed
branch  1 never executed
    #####: 1572:  if (pos == 0
branch  0 never executed
branch  1 never executed
    #####: 1573:      && (str_idx == lim->subexp_from || str_idx == lim->subexp_to))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1574:    {
        -: 1575:      int node_idx;
    #####: 1576:      for (node_idx = 0; node_idx < eclosures->nelem; ++node_idx)
branch  0 never executed
branch  1 never executed
        -: 1577:	{
    #####: 1578:	  int node = eclosures->elems[node_idx];
    #####: 1579:	  re_token_type_t type= dfa->nodes[node].type;
    #####: 1580:	  if (type == OP_BACK_REF)
branch  0 never executed
branch  1 never executed
        -: 1581:	    {
    #####: 1582:	      int bi = search_cur_bkref_entry (mctx, str_idx);
call    0 never executed
    #####: 1583:	      for (; bi < mctx->nbkref_ents; ++bi)
branch  0 never executed
branch  1 never executed
        -: 1584:		{
    #####: 1585:		  struct re_backref_cache_entry *ent = mctx->bkref_ents + bi;
    #####: 1586:		  if (ent->str_idx > str_idx)
branch  0 never executed
branch  1 never executed
    #####: 1587:		    break;
    #####: 1588:		  if (ent->node == node && ent->subexp_from == ent->subexp_to)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1589:		    {
        -: 1590:		      int cpos, dst;
    #####: 1591:		      dst = dfa->edests[node].elems[0];
    #####: 1592:		      cpos = check_dst_limits_calc_pos (dfa, mctx, limit,
    #####: 1593:							dfa->eclosures + dst,
call    0 never executed
        -: 1594:							subexp_idx, dst,
        -: 1595:							str_idx);
    #####: 1596:		      if ((str_idx == lim->subexp_from && cpos == -1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1597:			  || (str_idx == lim->subexp_to && cpos == 0))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1598:			return cpos;
        -: 1599:		    }
        -: 1600:		}
        -: 1601:	    }
    #####: 1602:	  if (type == OP_OPEN_SUBEXP && subexp_idx == dfa->nodes[node].opr.idx
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1603:	      && str_idx == lim->subexp_from)
branch  0 never executed
branch  1 never executed
        -: 1604:	    {
    #####: 1605:	      pos = -1;
    #####: 1606:	      break;
        -: 1607:	    }
    #####: 1608:	  if (type == OP_CLOSE_SUBEXP && subexp_idx == dfa->nodes[node].opr.idx
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1609:	      && str_idx == lim->subexp_to)
branch  0 never executed
branch  1 never executed
    #####: 1610:	    break;
        -: 1611:	}
    #####: 1612:      if (node_idx == eclosures->nelem && str_idx == lim->subexp_to)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1613:	pos = 1;
        -: 1614:    }
    #####: 1615:  return pos;
        -: 1616:}
        -: 1617:
        -: 1618:/* Check the limitations of sub expressions LIMITS, and remove the nodes
        -: 1619:   which are against limitations from DEST_NODES. */
        -: 1620:
        -: 1621:static reg_errcode_t
function check_subexp_limits called 0 returned 0% blocks executed 0%
    #####: 1622:check_subexp_limits (dfa, dest_nodes, candidates, limits, bkref_ents, str_idx)
        -: 1623:     re_dfa_t *dfa;
        -: 1624:     re_node_set *dest_nodes;
        -: 1625:     const re_node_set *candidates;
        -: 1626:     re_node_set *limits;
        -: 1627:     struct re_backref_cache_entry *bkref_ents;
        -: 1628:     int str_idx;
        -: 1629:{
        -: 1630:  reg_errcode_t err;
        -: 1631:  int node_idx, lim_idx;
        -: 1632:
    #####: 1633:  for (lim_idx = 0; lim_idx < limits->nelem; ++lim_idx)
branch  0 never executed
branch  1 never executed
        -: 1634:    {
        -: 1635:      int subexp_idx;
        -: 1636:      struct re_backref_cache_entry *ent;
    #####: 1637:      ent = bkref_ents + limits->elems[lim_idx];
        -: 1638:
    #####: 1639:      if (str_idx <= ent->subexp_from || ent->str_idx < str_idx)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1640:	continue; /* This is unrelated limitation.  */
        -: 1641:
    #####: 1642:      subexp_idx = dfa->nodes[ent->node].opr.idx - 1;
    #####: 1643:      if (ent->subexp_to == str_idx)
branch  0 never executed
branch  1 never executed
        -: 1644:	{
    #####: 1645:	  int ops_node = -1;
    #####: 1646:	  int cls_node = -1;
    #####: 1647:	  for (node_idx = 0; node_idx < dest_nodes->nelem; ++node_idx)
branch  0 never executed
branch  1 never executed
        -: 1648:	    {
    #####: 1649:	      int node = dest_nodes->elems[node_idx];
    #####: 1650:	      re_token_type_t type= dfa->nodes[node].type;
    #####: 1651:	      if (type == OP_OPEN_SUBEXP
branch  0 never executed
branch  1 never executed
    #####: 1652:		  && subexp_idx == dfa->nodes[node].opr.idx)
branch  0 never executed
branch  1 never executed
    #####: 1653:		ops_node = node;
    #####: 1654:	      else if (type == OP_CLOSE_SUBEXP
branch  0 never executed
branch  1 never executed
    #####: 1655:		       && subexp_idx == dfa->nodes[node].opr.idx)
branch  0 never executed
branch  1 never executed
    #####: 1656:		cls_node = node;
        -: 1657:	    }
        -: 1658:
        -: 1659:	  /* Check the limitation of the open subexpression.  */
        -: 1660:	  /* Note that (ent->subexp_to = str_idx != ent->subexp_from).  */
    #####: 1661:	  if (ops_node >= 0)
branch  0 never executed
branch  1 never executed
        -: 1662:	    {
    #####: 1663:	      err = sub_epsilon_src_nodes(dfa, ops_node, dest_nodes,
call    0 never executed
        -: 1664:					  candidates);
    #####: 1665:	      if (BE (err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 1666:		return err;
        -: 1667:	    }
        -: 1668:	  /* Check the limitation of the close subexpression.  */
    #####: 1669:	  for (node_idx = 0; node_idx < dest_nodes->nelem; ++node_idx)
branch  0 never executed
branch  1 never executed
        -: 1670:	    {
    #####: 1671:	      int node = dest_nodes->elems[node_idx];
    #####: 1672:	      if (!re_node_set_contains (dfa->inveclosures + node, cls_node)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1673:		  && !re_node_set_contains (dfa->eclosures + node, cls_node))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1674:		{
        -: 1675:		  /* It is against this limitation.
        -: 1676:		     Remove it form the current sifted state.  */
    #####: 1677:		  err = sub_epsilon_src_nodes(dfa, node, dest_nodes,
call    0 never executed
        -: 1678:					      candidates);
    #####: 1679:		  if (BE (err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 1680:		    return err;
    #####: 1681:		  --node_idx;
        -: 1682:		}
        -: 1683:	    }
        -: 1684:	}
        -: 1685:      else /* (ent->subexp_to != str_idx)  */
        -: 1686:	{
    #####: 1687:	  for (node_idx = 0; node_idx < dest_nodes->nelem; ++node_idx)
branch  0 never executed
branch  1 never executed
        -: 1688:	    {
    #####: 1689:	      int node = dest_nodes->elems[node_idx];
    #####: 1690:	      re_token_type_t type= dfa->nodes[node].type;
    #####: 1691:	      if (type == OP_CLOSE_SUBEXP || type == OP_OPEN_SUBEXP)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1692:		{
    #####: 1693:		  if (subexp_idx != dfa->nodes[node].opr.idx)
branch  0 never executed
branch  1 never executed
    #####: 1694:		    continue;
    #####: 1695:		  if ((type == OP_CLOSE_SUBEXP && ent->subexp_to != str_idx)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1696:		      || (type == OP_OPEN_SUBEXP))
branch  0 never executed
branch  1 never executed
        -: 1697:		    {
        -: 1698:		      /* It is against this limitation.
        -: 1699:			 Remove it form the current sifted state.  */
    #####: 1700:		      err = sub_epsilon_src_nodes(dfa, node, dest_nodes,
call    0 never executed
        -: 1701:						  candidates);
    #####: 1702:		      if (BE (err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 1703:			return err;
        -: 1704:		    }
        -: 1705:		}
        -: 1706:	    }
        -: 1707:	}
        -: 1708:    }
    #####: 1709:  return REG_NOERROR;
        -: 1710:}
        -: 1711:
        -: 1712:static reg_errcode_t
function sift_states_bkref called 0 returned 0% blocks executed 0%
    #####: 1713:sift_states_bkref (preg, mctx, sctx, str_idx, dest_nodes)
        -: 1714:     const regex_t *preg;
        -: 1715:     re_match_context_t *mctx;
        -: 1716:     re_sift_context_t *sctx;
        -: 1717:     int str_idx;
        -: 1718:     re_node_set *dest_nodes;
        -: 1719:{
        -: 1720:  reg_errcode_t err;
    #####: 1721:  re_dfa_t *dfa = (re_dfa_t *)preg->buffer;
        -: 1722:  int node_idx, node;
        -: 1723:  re_sift_context_t local_sctx;
        -: 1724:  const re_node_set *candidates;
    #####: 1725:  candidates = ((mctx->state_log[str_idx] == NULL) ? &empty_set
branch  0 never executed
branch  1 never executed
    #####: 1726:		: &mctx->state_log[str_idx]->nodes);
    #####: 1727:  local_sctx.sifted_states = NULL; /* Mark that it hasn't been initialized.  */
        -: 1728:
    #####: 1729:  for (node_idx = 0; node_idx < candidates->nelem; ++node_idx)
branch  0 never executed
branch  1 never executed
        -: 1730:    {
    #####: 1731:      int cur_bkref_idx = re_string_cur_idx (mctx->input);
        -: 1732:      re_token_type_t type;
    #####: 1733:      node = candidates->elems[node_idx];
    #####: 1734:      type = dfa->nodes[node].type;
    #####: 1735:      if (node == sctx->cur_bkref && str_idx == cur_bkref_idx)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1736:	continue;
        -: 1737:      /* Avoid infinite loop for the REs like "()\1+".  */
    #####: 1738:      if (node == sctx->last_node && str_idx == sctx->last_str_idx)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1739:	continue;
    #####: 1740:      if (type == OP_BACK_REF)
branch  0 never executed
branch  1 never executed
        -: 1741:	{
    #####: 1742:	  int enabled_idx = search_cur_bkref_entry (mctx, str_idx);
call    0 never executed
    #####: 1743:	  for (; enabled_idx < mctx->nbkref_ents; ++enabled_idx)
branch  0 never executed
branch  1 never executed
        -: 1744:	    {
        -: 1745:	      int disabled_idx, subexp_len, to_idx, dst_node;
        -: 1746:	      struct re_backref_cache_entry *entry;
    #####: 1747:	      entry = mctx->bkref_ents + enabled_idx;
    #####: 1748:	      if (entry->str_idx > str_idx)
branch  0 never executed
branch  1 never executed
    #####: 1749:		break;
    #####: 1750:	      if (entry->node != node)
branch  0 never executed
branch  1 never executed
    #####: 1751:		  continue;
    #####: 1752:	      subexp_len = entry->subexp_to - entry->subexp_from;
    #####: 1753:	      to_idx = str_idx + subexp_len;
    #####: 1754:	      dst_node = (subexp_len ? dfa->nexts[node]
    #####: 1755:			  : dfa->edests[node].elems[0]);
branch  0 never executed
branch  1 never executed
        -: 1756:
    #####: 1757:	      if (to_idx > sctx->last_str_idx
branch  0 never executed
branch  1 never executed
    #####: 1758:		  || sctx->sifted_states[to_idx] == NULL
branch  0 never executed
branch  1 never executed
    #####: 1759:		  || !STATE_NODE_CONTAINS (sctx->sifted_states[to_idx],
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 1760:					   dst_node)
    #####: 1761:		  || check_dst_limits (dfa, &sctx->limits, mctx, node,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1762:				       str_idx, dst_node, to_idx))
    #####: 1763:		continue;
        -: 1764:		{
        -: 1765:		  re_dfastate_t *cur_state;
    #####: 1766:		  entry->flag = 0;
    #####: 1767:		  for (disabled_idx = enabled_idx + 1;
    #####: 1768:		       disabled_idx < mctx->nbkref_ents; ++disabled_idx)
branch  0 never executed
branch  1 never executed
        -: 1769:		    {
        -: 1770:		      struct re_backref_cache_entry *entry2;
    #####: 1771:		      entry2 = mctx->bkref_ents + disabled_idx;
    #####: 1772:		      if (entry2->str_idx > str_idx)
branch  0 never executed
branch  1 never executed
    #####: 1773:			break;
    #####: 1774:		      entry2->flag = (entry2->node == node) ? 1 : entry2->flag;
branch  0 never executed
branch  1 never executed
        -: 1775:		    }
        -: 1776:
    #####: 1777:		  if (local_sctx.sifted_states == NULL)
branch  0 never executed
branch  1 never executed
        -: 1778:		    {
    #####: 1779:		      local_sctx = *sctx;
    #####: 1780:		      err = re_node_set_init_copy (&local_sctx.limits,
    #####: 1781:						   &sctx->limits);
call    0 never executed
    #####: 1782:		      if (BE (err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 1783:			goto free_return;
        -: 1784:		    }
    #####: 1785:		  local_sctx.last_node = node;
    #####: 1786:		  local_sctx.last_str_idx = str_idx;
    #####: 1787:		  err = re_node_set_insert (&local_sctx.limits, enabled_idx);
call    0 never executed
        -: 1788:		  if (BE (err < 0, 0))
        -: 1789:		    {
        -: 1790:		      err = REG_ESPACE;
        -: 1791:		      goto free_return;
        -: 1792:		    }
    #####: 1793:		  cur_state = local_sctx.sifted_states[str_idx];
    #####: 1794:		  err = sift_states_backward (preg, mctx, &local_sctx);
call    0 never executed
    #####: 1795:		  if (BE (err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 1796:		    goto free_return;
    #####: 1797:		  if (sctx->limited_states != NULL)
branch  0 never executed
branch  1 never executed
        -: 1798:		    {
    #####: 1799:		      err = merge_state_array (dfa, sctx->limited_states,
call    0 never executed
        -: 1800:					       local_sctx.sifted_states,
        -: 1801:					       str_idx + 1);
    #####: 1802:		      if (BE (err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 1803:			goto free_return;
        -: 1804:		    }
    #####: 1805:		  local_sctx.sifted_states[str_idx] = cur_state;
    #####: 1806:		  re_node_set_remove (&local_sctx.limits, enabled_idx);
call    0 never executed
call    1 never executed
        -: 1807:		  /* We must not use the variable entry here, since
        -: 1808:		     mctx->bkref_ents might be realloced.  */
    #####: 1809:		  mctx->bkref_ents[enabled_idx].flag = 1;
        -: 1810:		}
        -: 1811:	    }
    #####: 1812:	  enabled_idx = search_cur_bkref_entry (mctx, str_idx);
call    0 never executed
    #####: 1813:	  for (; enabled_idx < mctx->nbkref_ents; ++enabled_idx)
branch  0 never executed
branch  1 never executed
        -: 1814:	    {
        -: 1815:	      struct re_backref_cache_entry *entry;
    #####: 1816:	      entry = mctx->bkref_ents + enabled_idx;
    #####: 1817:	      if (entry->str_idx > str_idx)
branch  0 never executed
branch  1 never executed
    #####: 1818:		break;
    #####: 1819:	      if (entry->node == node)
branch  0 never executed
branch  1 never executed
    #####: 1820:		entry->flag = 0;
        -: 1821:	    }
        -: 1822:	}
        -: 1823:    }
    #####: 1824:  err = REG_NOERROR;
    #####: 1825: free_return:
    #####: 1826:  if (local_sctx.sifted_states != NULL)
branch  0 never executed
branch  1 never executed
        -: 1827:    {
    #####: 1828:      re_node_set_free (&local_sctx.limits);
        -: 1829:    }
        -: 1830:
    #####: 1831:  return err;
        -: 1832:}
        -: 1833:
        -: 1834:
        -: 1835:#ifdef RE_ENABLE_I18N
        -: 1836:static int
        -: 1837:sift_states_iter_mb (preg, mctx, sctx, node_idx, str_idx, max_str_idx)
        -: 1838:    const regex_t *preg;
        -: 1839:    const re_match_context_t *mctx;
        -: 1840:    re_sift_context_t *sctx;
        -: 1841:    int node_idx, str_idx, max_str_idx;
        -: 1842:{
        -: 1843:  re_dfa_t *dfa = (re_dfa_t *) preg->buffer;
        -: 1844:  int naccepted;
        -: 1845:  /* Check the node can accept `multi byte'.  */
        -: 1846:  naccepted = check_node_accept_bytes (preg, node_idx, mctx->input, str_idx);
        -: 1847:  if (naccepted > 0 && str_idx + naccepted <= max_str_idx &&
        -: 1848:      !STATE_NODE_CONTAINS (sctx->sifted_states[str_idx + naccepted],
        -: 1849:			    dfa->nexts[node_idx]))
        -: 1850:    /* The node can't accept the `multi byte', or the
        -: 1851:       destination was already throwed away, then the node
        -: 1852:       could't accept the current input `multi byte'.   */
        -: 1853:    naccepted = 0;
        -: 1854:  /* Otherwise, it is sure that the node could accept
        -: 1855:     `naccepted' bytes input.  */
        -: 1856:  return naccepted;
        -: 1857:}
        -: 1858:#endif /* RE_ENABLE_I18N */
        -: 1859:
        -: 1860:
        -: 1861:/* Functions for state transition.  */
        -: 1862:
        -: 1863:/* Return the next state to which the current state STATE will transit by
        -: 1864:   accepting the current input byte, and update STATE_LOG if necessary.
        -: 1865:   If STATE can accept a multibyte char/collating element/back reference
        -: 1866:   update the destination of STATE_LOG.  */
        -: 1867:
        -: 1868:static re_dfastate_t *
function transit_state called 997910 returned 100% blocks executed 47%
   997910: 1869:transit_state (err, preg, mctx, state, fl_search)
        -: 1870:     reg_errcode_t *err;
        -: 1871:     const regex_t *preg;
        -: 1872:     re_match_context_t *mctx;
        -: 1873:     re_dfastate_t *state;
        -: 1874:     int fl_search;
        -: 1875:{
   997910: 1876:  re_dfa_t *dfa = (re_dfa_t *) preg->buffer;
        -: 1877:  re_dfastate_t **trtable, *next_state;
        -: 1878:  unsigned char ch;
        -: 1879:  int cur_idx;
        -: 1880:
   997910: 1881:  if (re_string_cur_idx (mctx->input) + 1 >= mctx->input->bufs_len
branch  0 taken 993463 (fallthrough)
branch  1 taken 4447
   993463: 1882:      || (re_string_cur_idx (mctx->input) + 1 >= mctx->input->valid_len
branch  0 taken 28792 (fallthrough)
branch  1 taken 964671
    28792: 1883:	  && mctx->input->valid_len < mctx->input->len))
branch  0 taken 0 (fallthrough)
branch  1 taken 28792
        -: 1884:    {
     4447: 1885:      *err = extend_buffers (mctx);
call    0 returned 4447
     4447: 1886:      if (BE (*err != REG_NOERROR, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 4447
    #####: 1887:	return NULL;
        -: 1888:    }
        -: 1889:
   997910: 1890:  *err = REG_NOERROR;
   997910: 1891:  if (state == NULL)
branch  0 taken 0 (fallthrough)
branch  1 taken 997910
        -: 1892:    {
    #####: 1893:      next_state = state;
    #####: 1894:      re_string_skip_bytes (mctx->input, 1);
        -: 1895:    }
        -: 1896:  else
        -: 1897:    {
        -: 1898:#ifdef RE_ENABLE_I18N
        -: 1899:      /* If the current state can accept multibyte.  */
        -: 1900:      if (state->accept_mb)
        -: 1901:	{
        -: 1902:	  *err = transit_state_mb (preg, state, mctx);
        -: 1903:	  if (BE (*err != REG_NOERROR, 0))
        -: 1904:	    return NULL;
        -: 1905:	}
        -: 1906:#endif /* RE_ENABLE_I18N */
        -: 1907:
        -: 1908:      /* Then decide the next state with the single byte.  */
        -: 1909:      if (1)
        -: 1910:	{
        -: 1911:	  /* Use transition table  */
   997910: 1912:	  ch = re_string_fetch_byte (mctx->input);
  997910*: 1913:	  trtable = fl_search ? state->trtable_search : state->trtable;
branch  0 taken 0 (fallthrough)
branch  1 taken 997910
   997910: 1914:	  if (trtable == NULL)
branch  0 taken 2827 (fallthrough)
branch  1 taken 995083
        -: 1915:	    {
     2827: 1916:	      trtable = build_trtable (preg, state, fl_search);
call    0 returned 2827
     2827: 1917:	      if (fl_search)
branch  0 taken 0 (fallthrough)
branch  1 taken 2827
    #####: 1918:		state->trtable_search = trtable;
        -: 1919:	      else
     2827: 1920:		state->trtable = trtable;
        -: 1921:	    }
   997910: 1922:	  next_state = trtable[ch];
        -: 1923:	}
        -: 1924:      else
        -: 1925:	{
        -: 1926:	  /* don't use transition table  */
        -: 1927:	  next_state = transit_state_sb (err, preg, state, fl_search, mctx);
        -: 1928:	  if (BE (next_state == NULL && err != REG_NOERROR, 0))
        -: 1929:	    return NULL;
        -: 1930:	}
        -: 1931:    }
        -: 1932:
   997910: 1933:  cur_idx = re_string_cur_idx (mctx->input);
        -: 1934:  /* Update the state_log if we need.  */
   997910: 1935:  if (mctx->state_log != NULL)
branch  0 taken 3827 (fallthrough)
branch  1 taken 994083
        -: 1936:    {
     3827: 1937:      if (cur_idx > mctx->state_log_top)
branch  0 taken 3827 (fallthrough)
branch  1 taken 0
        -: 1938:	{
     3827: 1939:	  mctx->state_log[cur_idx] = next_state;
     3827: 1940:	  mctx->state_log_top = cur_idx;
        -: 1941:	}
    #####: 1942:      else if (mctx->state_log[cur_idx] == 0)
branch  0 never executed
branch  1 never executed
        -: 1943:	{
    #####: 1944:	  mctx->state_log[cur_idx] = next_state;
        -: 1945:	}
        -: 1946:      else
        -: 1947:	{
        -: 1948:	  re_dfastate_t *pstate;
        -: 1949:	  unsigned int context;
    #####: 1950:	  re_node_set next_nodes, *log_nodes, *table_nodes = NULL;
        -: 1951:	  /* If (state_log[cur_idx] != 0), it implies that cur_idx is
        -: 1952:	     the destination of a multibyte char/collating element/
        -: 1953:	     back reference.  Then the next state is the union set of
        -: 1954:	     these destinations and the results of the transition table.  */
    #####: 1955:	  pstate = mctx->state_log[cur_idx];
    #####: 1956:	  log_nodes = pstate->entrance_nodes;
    #####: 1957:	  if (next_state != NULL)
branch  0 never executed
branch  1 never executed
        -: 1958:	    {
    #####: 1959:	      table_nodes = next_state->entrance_nodes;
    #####: 1960:	      *err = re_node_set_init_union (&next_nodes, table_nodes,
call    0 never executed
        -: 1961:					     log_nodes);
    #####: 1962:	      if (BE (*err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 1963:		return NULL;
        -: 1964:	    }
        -: 1965:	  else
    #####: 1966:	    next_nodes = *log_nodes;
        -: 1967:	  /* Note: We already add the nodes of the initial state,
        -: 1968:		   then we don't need to add them here.  */
        -: 1969:
    #####: 1970:	  context = re_string_context_at (mctx->input,
    #####: 1971:					  re_string_cur_idx (mctx->input) - 1,
    #####: 1972:					  mctx->eflags, preg->newline_anchor);
call    0 never executed
    #####: 1973:	  next_state = mctx->state_log[cur_idx]
    #####: 1974:	    = re_acquire_state_context (err, dfa, &next_nodes, context);
call    0 never executed
        -: 1975:	  /* We don't need to check errors here, since the return value of
        -: 1976:	     this function is next_state and ERR is already set.  */
        -: 1977:
    #####: 1978:	  if (table_nodes != NULL)
branch  0 never executed
branch  1 never executed
    #####: 1979:	    re_node_set_free (&next_nodes);
        -: 1980:	}
        -: 1981:    }
        -: 1982:
        -: 1983:  /* Check OP_OPEN_SUBEXP in the current state in case that we use them
        -: 1984:     later.  We must check them here, since the back references in the
        -: 1985:     next state might use them.  */
  997910*: 1986:  if (dfa->nbackref && next_state/* && fl_process_bkref */)
branch  0 taken 0 (fallthrough)
branch  1 taken 997910
branch  2 never executed
branch  3 never executed
        -: 1987:    {
    #####: 1988:      *err = check_subexp_matching_top (dfa, mctx, &next_state->nodes,
call    0 never executed
        -: 1989:					cur_idx);
    #####: 1990:      if (BE (*err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 1991:	return NULL;
        -: 1992:    }
        -: 1993:
        -: 1994:  /* If the next state has back references.  */
   997910: 1995:  if (next_state != NULL && next_state->has_backref)
branch  0 taken 385535 (fallthrough)
branch  1 taken 612375
branch  2 taken 0 (fallthrough)
branch  3 taken 385535
        -: 1996:    {
    #####: 1997:      *err = transit_state_bkref (preg, next_state, mctx);
call    0 never executed
    #####: 1998:      if (BE (*err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 1999:	return NULL;
    #####: 2000:      next_state = mctx->state_log[cur_idx];
        -: 2001:    }
   997910: 2002:  return next_state;
        -: 2003:}
        -: 2004:
        -: 2005:/* Helper functions for transit_state.  */
        -: 2006:
        -: 2007:static reg_errcode_t
function check_subexp_matching_top called 0 returned 0% blocks executed 0%
    #####: 2008:check_subexp_matching_top (dfa, mctx, cur_nodes, str_idx)
        -: 2009:     re_dfa_t *dfa;
        -: 2010:     re_match_context_t *mctx;
        -: 2011:     re_node_set *cur_nodes;
        -: 2012:     int str_idx;
        -: 2013:{
        -: 2014:  int node_idx;
        -: 2015:  reg_errcode_t err;
        -: 2016:
    #####: 2017:  for (node_idx = 0; node_idx < cur_nodes->nelem; ++node_idx)
branch  0 never executed
branch  1 never executed
        -: 2018:    {
    #####: 2019:      int node = cur_nodes->elems[node_idx];
    #####: 2020:      if (dfa->nodes[node].type == OP_OPEN_SUBEXP)
branch  0 never executed
branch  1 never executed
        -: 2021:	{
    #####: 2022:	  err = match_ctx_add_subtop (mctx, node, str_idx);
call    0 never executed
    #####: 2023:	  if (BE (err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 2024:	    return err;
        -: 2025:	}
        -: 2026:    }
    #####: 2027:  return REG_NOERROR;
        -: 2028:}
        -: 2029:
        -: 2030:/* Return the next state to which the current state STATE will transit by
        -: 2031:   accepting the current input byte.  */
        -: 2032:
        -: 2033:static re_dfastate_t *
function transit_state_sb called 0 returned 0% blocks executed 0%
    #####: 2034:transit_state_sb (err, preg, state, fl_search, mctx)
        -: 2035:     reg_errcode_t *err;
        -: 2036:     const regex_t *preg;
        -: 2037:     re_dfastate_t *state;
        -: 2038:     int fl_search;
        -: 2039:     re_match_context_t *mctx;
        -: 2040:{
    #####: 2041:  re_dfa_t *dfa = (re_dfa_t *) preg->buffer;
        -: 2042:  re_node_set next_nodes;
        -: 2043:  re_dfastate_t *next_state;
    #####: 2044:  int node_cnt, cur_str_idx = re_string_cur_idx (mctx->input);
        -: 2045:  unsigned int context;
        -: 2046:
    #####: 2047:  *err = re_node_set_alloc (&next_nodes, state->nodes.nelem + 1);
call    0 never executed
    #####: 2048:  if (BE (*err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 2049:    return NULL;
    #####: 2050:  for (node_cnt = 0; node_cnt < state->nodes.nelem; ++node_cnt)
branch  0 never executed
branch  1 never executed
        -: 2051:    {
    #####: 2052:      int cur_node = state->nodes.elems[node_cnt];
    #####: 2053:      if (check_node_accept (preg, dfa->nodes + cur_node, mctx, cur_str_idx))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2054:	{
    #####: 2055:	  *err = re_node_set_merge (&next_nodes,
    #####: 2056:				    dfa->eclosures + dfa->nexts[cur_node]);
call    0 never executed
    #####: 2057:	  if (BE (*err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
        -: 2058:	    {
    #####: 2059:	      re_node_set_free (&next_nodes);
    #####: 2060:	      return NULL;
        -: 2061:	    }
        -: 2062:	}
        -: 2063:    }
    #####: 2064:  if (fl_search)
branch  0 never executed
branch  1 never executed
        -: 2065:    {
        -: 2066:#ifdef RE_ENABLE_I18N
        -: 2067:      int not_initial = 0;
        -: 2068:      if (MB_CUR_MAX > 1)
        -: 2069:	for (node_cnt = 0; node_cnt < next_nodes.nelem; ++node_cnt)
        -: 2070:	  if (dfa->nodes[next_nodes.elems[node_cnt]].type == CHARACTER)
        -: 2071:	    {
        -: 2072:	      not_initial = dfa->nodes[next_nodes.elems[node_cnt]].mb_partial;
        -: 2073:	      break;
        -: 2074:	    }
        -: 2075:      if (!not_initial)
        -: 2076:#endif
        -: 2077:	{
    #####: 2078:	  *err = re_node_set_merge (&next_nodes,
    #####: 2079:				    dfa->init_state->entrance_nodes);
call    0 never executed
    #####: 2080:	  if (BE (*err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
        -: 2081:	    {
    #####: 2082:	      re_node_set_free (&next_nodes);
    #####: 2083:	      return NULL;
        -: 2084:	    }
        -: 2085:	}
        -: 2086:    }
    #####: 2087:  context = re_string_context_at (mctx->input, cur_str_idx, mctx->eflags,
    #####: 2088:				  preg->newline_anchor);
call    0 never executed
    #####: 2089:  next_state = re_acquire_state_context (err, dfa, &next_nodes, context);
call    0 never executed
        -: 2090:  /* We don't need to check errors here, since the return value of
        -: 2091:     this function is next_state and ERR is already set.  */
        -: 2092:
    #####: 2093:  re_node_set_free (&next_nodes);
    #####: 2094:  re_string_skip_bytes (mctx->input, 1);
    #####: 2095:  return next_state;
        -: 2096:}
        -: 2097:
        -: 2098:#ifdef RE_ENABLE_I18N
        -: 2099:static reg_errcode_t
        -: 2100:transit_state_mb (preg, pstate, mctx)
        -: 2101:    const regex_t *preg;
        -: 2102:    re_dfastate_t *pstate;
        -: 2103:    re_match_context_t *mctx;
        -: 2104:{
        -: 2105:  reg_errcode_t err;
        -: 2106:  re_dfa_t *dfa = (re_dfa_t *) preg->buffer;
        -: 2107:  int i;
        -: 2108:
        -: 2109:  for (i = 0; i < pstate->nodes.nelem; ++i)
        -: 2110:    {
        -: 2111:      re_node_set dest_nodes, *new_nodes;
        -: 2112:      int cur_node_idx = pstate->nodes.elems[i];
        -: 2113:      int naccepted = 0, dest_idx;
        -: 2114:      unsigned int context;
        -: 2115:      re_dfastate_t *dest_state;
        -: 2116:
        -: 2117:      if (dfa->nodes[cur_node_idx].constraint)
        -: 2118:	{
        -: 2119:	  context = re_string_context_at (mctx->input,
        -: 2120:					  re_string_cur_idx (mctx->input),
        -: 2121:					  mctx->eflags, preg->newline_anchor);
        -: 2122:	  if (NOT_SATISFY_NEXT_CONSTRAINT (dfa->nodes[cur_node_idx].constraint,
        -: 2123:					   context))
        -: 2124:	    continue;
        -: 2125:	}
        -: 2126:
        -: 2127:      /* How many bytes the node can accepts?  */
        -: 2128:      if (ACCEPT_MB_NODE (dfa->nodes[cur_node_idx].type))
        -: 2129:	naccepted = check_node_accept_bytes (preg, cur_node_idx, mctx->input,
        -: 2130:					     re_string_cur_idx (mctx->input));
        -: 2131:      if (naccepted == 0)
        -: 2132:	continue;
        -: 2133:
        -: 2134:      /* The node can accepts `naccepted' bytes.  */
        -: 2135:      dest_idx = re_string_cur_idx (mctx->input) + naccepted;
        -: 2136:      mctx->max_mb_elem_len = ((mctx->max_mb_elem_len < naccepted) ? naccepted
        -: 2137:			       : mctx->max_mb_elem_len);
        -: 2138:      err = clean_state_log_if_need (mctx, dest_idx);
        -: 2139:      if (BE (err != REG_NOERROR, 0))
        -: 2140:	return err;
        -: 2141:#ifdef DEBUG
        -: 2142:      assert (dfa->nexts[cur_node_idx] != -1);
        -: 2143:#endif
        -: 2144:      /* `cur_node_idx' may point the entity of the OP_CONTEXT_NODE,
        -: 2145:	 then we use pstate->nodes.elems[i] instead.  */
        -: 2146:      new_nodes = dfa->eclosures + dfa->nexts[pstate->nodes.elems[i]];
        -: 2147:
        -: 2148:      dest_state = mctx->state_log[dest_idx];
        -: 2149:      if (dest_state == NULL)
        -: 2150:	dest_nodes = *new_nodes;
        -: 2151:      else
        -: 2152:	{
        -: 2153:	  err = re_node_set_init_union (&dest_nodes,
        -: 2154:					dest_state->entrance_nodes, new_nodes);
        -: 2155:	  if (BE (err != REG_NOERROR, 0))
        -: 2156:	    return err;
        -: 2157:	}
        -: 2158:      context = re_string_context_at (mctx->input, dest_idx - 1, mctx->eflags,
        -: 2159:				      preg->newline_anchor);
        -: 2160:      mctx->state_log[dest_idx]
        -: 2161:	= re_acquire_state_context (&err, dfa, &dest_nodes, context);
        -: 2162:      if (dest_state != NULL)
        -: 2163:	re_node_set_free (&dest_nodes);
        -: 2164:      if (BE (mctx->state_log[dest_idx] == NULL && err != REG_NOERROR, 0))
        -: 2165:	return err;
        -: 2166:    }
        -: 2167:  return REG_NOERROR;
        -: 2168:}
        -: 2169:#endif /* RE_ENABLE_I18N */
        -: 2170:
        -: 2171:static reg_errcode_t
function transit_state_bkref called 0 returned 0% blocks executed 0%
    #####: 2172:transit_state_bkref (preg, pstate, mctx)
        -: 2173:    const regex_t *preg;
        -: 2174:    re_dfastate_t *pstate;
        -: 2175:    re_match_context_t *mctx;
        -: 2176:{
        -: 2177:  reg_errcode_t err;
    #####: 2178:  err = transit_state_bkref_loop (preg, &pstate->nodes, mctx);
call    0 never executed
    #####: 2179:  return err;
        -: 2180:}
        -: 2181:
        -: 2182:static reg_errcode_t
function transit_state_bkref_loop called 0 returned 0% blocks executed 0%
    #####: 2183:transit_state_bkref_loop (preg, nodes, mctx)
        -: 2184:    const regex_t *preg;
        -: 2185:    re_node_set *nodes;
        -: 2186:    re_match_context_t *mctx;
        -: 2187:{
        -: 2188:  reg_errcode_t err;
    #####: 2189:  re_dfa_t *dfa = (re_dfa_t *) preg->buffer;
        -: 2190:  int i;
    #####: 2191:  regmatch_t *cur_regs = re_malloc (regmatch_t, preg->re_nsub + 1);
    #####: 2192:  int cur_str_idx = re_string_cur_idx (mctx->input);
    #####: 2193:  if (BE (cur_regs == NULL, 0))
branch  0 never executed
branch  1 never executed
    #####: 2194:    return REG_ESPACE;
        -: 2195:
    #####: 2196:  for (i = 0; i < nodes->nelem; ++i)
branch  0 never executed
branch  1 never executed
        -: 2197:    {
        -: 2198:      int dest_str_idx, subexp_idx, prev_nelem, bkc_idx;
    #####: 2199:      int node_idx = nodes->elems[i];
        -: 2200:      unsigned int context;
    #####: 2201:      re_token_t *node = dfa->nodes + node_idx;
        -: 2202:      re_node_set *new_dest_nodes;
        -: 2203:
        -: 2204:      /* Check whether `node' is a backreference or not.  */
    #####: 2205:      if (node->type == OP_BACK_REF)
branch  0 never executed
branch  1 never executed
    #####: 2206:	subexp_idx = node->opr.idx;
        -: 2207:      else
    #####: 2208:	continue;
        -: 2209:
    #####: 2210:      if (node->constraint)
branch  0 never executed
branch  1 never executed
        -: 2211:	{
    #####: 2212:	  context = re_string_context_at (mctx->input, cur_str_idx,
    #####: 2213:					  mctx->eflags, preg->newline_anchor);
call    0 never executed
    #####: 2214:	  if (NOT_SATISFY_NEXT_CONSTRAINT (node->constraint, context))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
    #####: 2215:	    continue;
        -: 2216:	}
        -: 2217:
        -: 2218:      /* `node' is a backreference.
        -: 2219:	 Check the substring which the substring matched.  */
    #####: 2220:      err = get_subexp (preg, mctx, node_idx, cur_str_idx, subexp_idx - 1);
call    0 never executed
    #####: 2221:      if (BE (err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 2222:	goto free_return;
        -: 2223:
        -: 2224:      /* And add the epsilon closures (which is `new_dest_nodes') of
        -: 2225:	 the backreference to appropriate state_log.  */
        -: 2226:#ifdef DEBUG
        -: 2227:      assert (dfa->nexts[node_idx] != -1);
        -: 2228:#endif
    #####: 2229:      bkc_idx = search_cur_bkref_entry (mctx, cur_str_idx);
call    0 never executed
    #####: 2230:      for (; bkc_idx < mctx->nbkref_ents; ++bkc_idx)
branch  0 never executed
branch  1 never executed
        -: 2231:	{
        -: 2232:	  int subexp_len;
        -: 2233:	  re_dfastate_t *dest_state;
        -: 2234:	  struct re_backref_cache_entry *bkref_ent;
    #####: 2235:	  bkref_ent = mctx->bkref_ents + bkc_idx;
    #####: 2236:	  if (bkref_ent->node != node_idx || bkref_ent->str_idx != cur_str_idx)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2237:	    continue;
    #####: 2238:	  subexp_len = bkref_ent->subexp_to - bkref_ent->subexp_from;
    #####: 2239:	  new_dest_nodes = (subexp_len == 0
    #####: 2240:			    ? dfa->eclosures + dfa->edests[node_idx].elems[0]
    #####: 2241:			    : dfa->eclosures + dfa->nexts[node_idx]);
branch  0 never executed
branch  1 never executed
    #####: 2242:	  dest_str_idx = (cur_str_idx + bkref_ent->subexp_to
    #####: 2243:			  - bkref_ent->subexp_from);
    #####: 2244:	  context = re_string_context_at (mctx->input, dest_str_idx - 1,
    #####: 2245:					  mctx->eflags, preg->newline_anchor);
call    0 never executed
    #####: 2246:	  dest_state = mctx->state_log[dest_str_idx];
    #####: 2247:	  prev_nelem = ((mctx->state_log[cur_str_idx] == NULL) ? 0
    #####: 2248:			: mctx->state_log[cur_str_idx]->nodes.nelem);
branch  0 never executed
branch  1 never executed
        -: 2249:	  /* Add `new_dest_node' to state_log.  */
    #####: 2250:	  if (dest_state == NULL)
branch  0 never executed
branch  1 never executed
        -: 2251:	    {
    #####: 2252:	      mctx->state_log[dest_str_idx]
    #####: 2253:		= re_acquire_state_context (&err, dfa, new_dest_nodes,
call    0 never executed
        -: 2254:					    context);
    #####: 2255:	      if (BE (mctx->state_log[dest_str_idx] == NULL
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2256:		      && err != REG_NOERROR, 0))
    #####: 2257:		goto free_return;
        -: 2258:	    }
        -: 2259:	  else
        -: 2260:	    {
        -: 2261:	      re_node_set dest_nodes;
    #####: 2262:	      err = re_node_set_init_union (&dest_nodes,
    #####: 2263:					    dest_state->entrance_nodes,
call    0 never executed
        -: 2264:					    new_dest_nodes);
    #####: 2265:	      if (BE (err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
        -: 2266:		{
    #####: 2267:		  re_node_set_free (&dest_nodes);
    #####: 2268:		  goto free_return;
        -: 2269:		}
    #####: 2270:	      mctx->state_log[dest_str_idx]
    #####: 2271:		= re_acquire_state_context (&err, dfa, &dest_nodes, context);
call    0 never executed
    #####: 2272:	      re_node_set_free (&dest_nodes);
    #####: 2273:	      if (BE (mctx->state_log[dest_str_idx] == NULL
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2274:		      && err != REG_NOERROR, 0))
    #####: 2275:		goto free_return;
        -: 2276:	    }
        -: 2277:	  /* We need to check recursively if the backreference can epsilon
        -: 2278:	     transit.  */
    #####: 2279:	  if (subexp_len == 0
branch  0 never executed
branch  1 never executed
    #####: 2280:	      && mctx->state_log[cur_str_idx]->nodes.nelem > prev_nelem)
branch  0 never executed
branch  1 never executed
        -: 2281:	    {
    #####: 2282:	      err = check_subexp_matching_top (dfa, mctx, new_dest_nodes,
call    0 never executed
        -: 2283:					       cur_str_idx);
    #####: 2284:	      if (BE (err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 2285:		goto free_return;
    #####: 2286:	      err = transit_state_bkref_loop (preg, new_dest_nodes, mctx);
call    0 never executed
    #####: 2287:	      if (BE (err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 2288:		goto free_return;
        -: 2289:	    }
        -: 2290:	}
        -: 2291:    }
    #####: 2292:  err = REG_NOERROR;
    #####: 2293: free_return:
    #####: 2294:  re_free (cur_regs);
    #####: 2295:  return err;
        -: 2296:}
        -: 2297:
        -: 2298:static reg_errcode_t
function get_subexp called 0 returned 0% blocks executed 0%
    #####: 2299:get_subexp (preg, mctx, bkref_node, bkref_str_idx, subexp_idx)
        -: 2300:     const regex_t *preg;
        -: 2301:     re_match_context_t *mctx;
        -: 2302:     int bkref_node, bkref_str_idx, subexp_idx;
        -: 2303:{
        -: 2304:  int sub_top_idx;
    #####: 2305:  re_dfa_t *dfa = (re_dfa_t *) preg->buffer;
    #####: 2306:  char *buf = re_string_get_buffer (mctx->input);
        -: 2307:  /* For each sub expression...  */
    #####: 2308:  for (sub_top_idx = 0; sub_top_idx < mctx->nsub_tops; ++sub_top_idx)
branch  0 never executed
branch  1 never executed
        -: 2309:    {
        -: 2310:      reg_errcode_t err;
    #####: 2311:      re_sub_match_top_t *sub_top = mctx->sub_tops[sub_top_idx];
        -: 2312:      re_sub_match_last_t *sub_last;
        -: 2313:      int sub_last_idx, sl_str;
        -: 2314:      char *bkref_str;
        -: 2315:
    #####: 2316:      if (dfa->nodes[sub_top->node].opr.idx != subexp_idx)
branch  0 never executed
branch  1 never executed
    #####: 2317:	continue; /* It isn't related.  */
        -: 2318:
    #####: 2319:      sl_str = sub_top->str_idx;
    #####: 2320:      bkref_str = buf + bkref_str_idx;
        -: 2321:      /* At first, check the last node of sub expressions we already
        -: 2322:	 evaluated.  */
    #####: 2323:      for (sub_last_idx = 0; sub_last_idx < sub_top->nlasts; ++sub_last_idx)
branch  0 never executed
branch  1 never executed
        -: 2324:	{
        -: 2325:	  int sl_str_diff;
    #####: 2326:	  sub_last = sub_top->lasts[sub_last_idx];
    #####: 2327:	  sl_str_diff = sub_last->str_idx - sl_str;
        -: 2328:	  /* The matched string by the sub expression match with the substring
        -: 2329:	     at the back reference?  */
    #####: 2330:	  if (sl_str_diff > 0
branch  0 never executed
branch  1 never executed
    #####: 2331:	      && my_memcmp (bkref_str, buf + sl_str, sl_str_diff) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2332:	    break; /* We don't need to search this sub expression any more.  */
    #####: 2333:	  bkref_str += sl_str_diff;
    #####: 2334:	  sl_str += sl_str_diff;
    #####: 2335:	  err = get_subexp_sub (preg, mctx, sub_top, sub_last, bkref_node,
call    0 never executed
        -: 2336:				bkref_str_idx, subexp_idx);
    #####: 2337:	  if (err == REG_NOMATCH)
branch  0 never executed
branch  1 never executed
    #####: 2338:	    continue;
    #####: 2339:	  if (BE (err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 2340:	    return err;
        -: 2341:	}
    #####: 2342:      if (sub_last_idx < sub_top->nlasts)
branch  0 never executed
branch  1 never executed
    #####: 2343:	continue;
    #####: 2344:      if (sub_last_idx > 0)
branch  0 never executed
branch  1 never executed
    #####: 2345:	++sl_str;
        -: 2346:      /* Then, search for the other last nodes of the sub expression.  */
    #####: 2347:      for (; sl_str <= bkref_str_idx; ++sl_str)
branch  0 never executed
branch  1 never executed
        -: 2348:	{
        -: 2349:	  int cls_node, sl_str_off;
        -: 2350:	  re_sub_match_last_t cur_last;
        -: 2351:	  re_node_set *nodes;
    #####: 2352:	  sl_str_off = sl_str - sub_top->str_idx;
        -: 2353:	  /* The matched string by the sub expression match with the substring
        -: 2354:	     at the back reference?  */
    #####: 2355:	  if (sl_str_off > 0
branch  0 never executed
branch  1 never executed
    #####: 2356:	      && my_memcmp (bkref_str++, buf + sl_str - 1, 1) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2357:	    break; /* We don't need to search this sub expression any more.  */
    #####: 2358:	  if (mctx->state_log[sl_str] == NULL)
branch  0 never executed
branch  1 never executed
    #####: 2359:	    continue;
        -: 2360:	  /* Does this state have a ')' of the sub expression?  */
    #####: 2361:	  nodes = &mctx->state_log[sl_str]->nodes;
    #####: 2362:	  cls_node = find_subexp_node (dfa, nodes, subexp_idx, 0);
call    0 never executed
    #####: 2363:	  if (cls_node == -1)
branch  0 never executed
branch  1 never executed
    #####: 2364:	    continue; /* No.  */
    #####: 2365:	  if (sub_top->path == NULL)
branch  0 never executed
branch  1 never executed
        -: 2366:	    {
    #####: 2367:	      sub_top->path = calloc (sizeof (state_array_t), 1);
    #####: 2368:	      if (sub_top->path == NULL)
branch  0 never executed
branch  1 never executed
    #####: 2369:		return REG_ESPACE;
        -: 2370:	    }
        -: 2371:	  /* Can the OP_OPEN_SUBEXP node arrive the OP_CLOSE_SUBEXP node
        -: 2372:	     in the current context?  */
    #####: 2373:	  memset (&cur_last, '\0', sizeof (re_sub_match_last_t));
    #####: 2374:	  cur_last.node = cls_node;
    #####: 2375:	  cur_last.str_idx = sl_str;
    #####: 2376:	  err = check_arrival (preg, mctx, sub_top, &cur_last, -1, -1);
call    0 never executed
    #####: 2377:	  if (err == REG_NOMATCH)
branch  0 never executed
branch  1 never executed
    #####: 2378:	      continue;
    #####: 2379:	  if (BE (err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 2380:	      return err;
    #####: 2381:	  sub_last = match_ctx_add_sublast (sub_top, cls_node, sl_str);
call    0 never executed
    #####: 2382:	  if (BE (sub_last == NULL, 0))
branch  0 never executed
branch  1 never executed
    #####: 2383:	    return REG_ESPACE;
    #####: 2384:	  err = get_subexp_sub (preg, mctx, sub_top, sub_last, bkref_node,
call    0 never executed
        -: 2385:				bkref_str_idx, subexp_idx);
    #####: 2386:	  if (err == REG_NOMATCH)
branch  0 never executed
branch  1 never executed
    #####: 2387:	    continue;
        -: 2388:	}
        -: 2389:    }
    #####: 2390:  return REG_NOERROR;
        -: 2391:}
        -: 2392:
        -: 2393:static reg_errcode_t
function get_subexp_sub called 0 returned 0% blocks executed 0%
    #####: 2394:get_subexp_sub (preg, mctx, sub_top, sub_last, bkref_node, bkref_str,
        -: 2395:		subexp_idx)
        -: 2396:     const regex_t *preg;
        -: 2397:     re_match_context_t *mctx;
        -: 2398:     re_sub_match_top_t *sub_top;
        -: 2399:     re_sub_match_last_t *sub_last;
        -: 2400:     int bkref_node, bkref_str, subexp_idx;
        -: 2401:{
        -: 2402:  reg_errcode_t err;
        -: 2403:  int to_idx;
        -: 2404:  /* Can the subexpression arrive the back reference?  */
    #####: 2405:  err = check_arrival (preg, mctx, sub_top, sub_last, bkref_node, bkref_str);
call    0 never executed
    #####: 2406:  if (err != REG_NOERROR)
branch  0 never executed
branch  1 never executed
    #####: 2407:    return err;
    #####: 2408:  err = match_ctx_add_entry (mctx, bkref_node, bkref_str, sub_top->str_idx,
call    0 never executed
        -: 2409:			     sub_last->str_idx, sub_top, sub_last);
    #####: 2410:  if (BE (err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 2411:    return err;
    #####: 2412:  to_idx = bkref_str + sub_last->str_idx - sub_top->str_idx;
    #####: 2413:  clean_state_log_if_need (mctx, to_idx);
call    0 never executed
    #####: 2414:  return REG_NOERROR;
        -: 2415:}
        -: 2416:
        -: 2417:/* Find the first node which is '(' or ')', and whose index is SUBEXP_IDX.
        -: 2418:   Search '(' if FL_OPEN, or search ')' otherwise.  */
        -: 2419:
        -: 2420:static int
function find_subexp_node called 0 returned 0% blocks executed 0%
    #####: 2421:find_subexp_node (dfa, nodes, subexp_idx, fl_open)
        -: 2422:     re_dfa_t *dfa;
        -: 2423:     re_node_set *nodes;
        -: 2424:     int subexp_idx, fl_open;
        -: 2425:{
        -: 2426:  int cls_idx;
    #####: 2427:  for (cls_idx = 0; cls_idx < nodes->nelem; ++cls_idx)
branch  0 never executed
branch  1 never executed
        -: 2428:    {
    #####: 2429:      int cls_node = nodes->elems[cls_idx];
    #####: 2430:      re_token_t *node = dfa->nodes + cls_node;
    #####: 2431:      if (((fl_open && node->type == OP_OPEN_SUBEXP)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2432:	  || (!fl_open && node->type == OP_CLOSE_SUBEXP))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2433:	  && node->opr.idx == subexp_idx)
branch  0 never executed
branch  1 never executed
    #####: 2434:	return cls_node;
        -: 2435:    }
    #####: 2436:  return -1;
        -: 2437:}
        -: 2438:
        -: 2439:static reg_errcode_t
function check_arrival called 0 returned 0% blocks executed 0%
    #####: 2440:check_arrival (preg, mctx, sub_top, sub_last, bkref_node, bkref_str)
        -: 2441:     const regex_t *preg;
        -: 2442:     re_match_context_t *mctx;
        -: 2443:     re_sub_match_top_t *sub_top;
        -: 2444:     re_sub_match_last_t *sub_last;
        -: 2445:     int bkref_node, bkref_str;
        -: 2446:{
    #####: 2447:  re_dfa_t *dfa = (re_dfa_t *) preg->buffer;
        -: 2448:  reg_errcode_t err;
        -: 2449:  int backup_cur_idx, str_idx, null_cnt;
    #####: 2450:  re_dfastate_t *cur_state = NULL;
        -: 2451:  re_node_set *cur_nodes;
        -: 2452:  re_dfastate_t **backup_state_log;
        -: 2453:
        -: 2454:  state_array_t *path;
        -: 2455:  int top_node, top_str, ex_subexp, last_node, last_str, fl_open;
        -: 2456:
    #####: 2457:  path = bkref_node < 0 ? sub_top->path : &sub_last->path;
branch  0 never executed
branch  1 never executed
    #####: 2458:  top_node = bkref_node < 0 ? sub_top->node : sub_last->node;
branch  0 never executed
branch  1 never executed
    #####: 2459:  top_str = bkref_node < 0 ? sub_top->str_idx : sub_last->str_idx;
branch  0 never executed
branch  1 never executed
    #####: 2460:  last_node = bkref_node < 0 ? sub_last->node : bkref_node;
branch  0 never executed
branch  1 never executed
    #####: 2461:  last_str = bkref_node < 0 ? sub_last->str_idx : bkref_str;
branch  0 never executed
branch  1 never executed
        -: 2462:
    #####: 2463:  ex_subexp = dfa->nodes[sub_top->node].opr.idx;
    #####: 2464:  fl_open = (bkref_node >= 0);
        -: 2465:
        -: 2466:  /* Extend the buffer if we need.  */
    #####: 2467:  if (path->alloc < last_str + mctx->max_mb_elem_len + 1)
branch  0 never executed
branch  1 never executed
        -: 2468:    {
    #####: 2469:      int old_alloc = path->alloc;
    #####: 2470:      path->alloc = last_str + mctx->max_mb_elem_len + 1;
    #####: 2471:      path->array = re_realloc (path->array, re_dfastate_t *, path->alloc);
    #####: 2472:      if (path->array == NULL)
branch  0 never executed
branch  1 never executed
    #####: 2473:	return REG_ESPACE;
    #####: 2474:      memset (path->array + old_alloc, '\0',
    #####: 2475:	      sizeof (re_dfastate_t *) * (path->alloc - old_alloc));
        -: 2476:    }
        -: 2477:
    #####: 2478:  str_idx = path->next_idx == 0 ? top_str : path->next_idx;
branch  0 never executed
branch  1 never executed
        -: 2479:
        -: 2480:  /* Temporary modify MCTX.  */
    #####: 2481:  backup_state_log = mctx->state_log;
    #####: 2482:  backup_cur_idx = mctx->input->cur_idx;
    #####: 2483:  mctx->state_log = path->array;
    #####: 2484:  mctx->input->cur_idx = str_idx;
        -: 2485:
        -: 2486:  /* Setup initial node set.  */
    #####: 2487:  if (str_idx == top_str)
branch  0 never executed
branch  1 never executed
        -: 2488:    {
        -: 2489:      unsigned int context;
        -: 2490:      re_node_set init_nodes;
    #####: 2491:      context = re_string_context_at (mctx->input, str_idx - 1, mctx->eflags,
    #####: 2492:				      preg->newline_anchor);
call    0 never executed
    #####: 2493:      err = re_node_set_init_1 (&init_nodes, top_node);
call    0 never executed
    #####: 2494:      if (BE (err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 2495:	return err;
    #####: 2496:      err = expand_eclosures (dfa, &init_nodes, ex_subexp, fl_open);
call    0 never executed
    #####: 2497:      if (BE (err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 2498:	return err;
        -: 2499:
    #####: 2500:      if (init_nodes.nelem)
branch  0 never executed
branch  1 never executed
        -: 2501:	{
    #####: 2502:	  err = expand_bkref_cache (preg, mctx, sub_top, sub_last, &init_nodes,
call    0 never executed
        -: 2503:				    str_idx, last_str, ex_subexp, fl_open);
    #####: 2504:	  if (BE ( err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 2505:	    return err;
        -: 2506:	}
    #####: 2507:      cur_state = re_acquire_state_context (&err, dfa, &init_nodes, context);
call    0 never executed
    #####: 2508:      if (BE (cur_state == NULL && err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2509:	return err;
    #####: 2510:      mctx->state_log[str_idx] = cur_state;
    #####: 2511:      re_node_set_free (&init_nodes);
        -: 2512:    }
        -: 2513:  else
        -: 2514:    {
    #####: 2515:      cur_state = mctx->state_log[str_idx];
    #####: 2516:      if (cur_state && cur_state->has_backref)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2517:	{
        -: 2518:	  unsigned int context;
        -: 2519:	  re_node_set init_nodes;
    #####: 2520:	  context = re_string_context_at (mctx->input, str_idx - 1,
    #####: 2521:					  mctx->eflags, preg->newline_anchor);
call    0 never executed
    #####: 2522:	  err = re_node_set_init_copy (&init_nodes, &cur_state->nodes);
call    0 never executed
    #####: 2523:	  if (BE ( err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 2524:	    return err;
    #####: 2525:	  err = expand_bkref_cache (preg, mctx, sub_top, sub_last, &init_nodes,
call    0 never executed
        -: 2526:				    str_idx, last_str, ex_subexp, fl_open);
    #####: 2527:	  if (BE ( err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 2528:	    return err;
    #####: 2529:	  cur_state = re_acquire_state_context (&err, dfa, &init_nodes,
call    0 never executed
        -: 2530:						context);
    #####: 2531:	  if (BE (cur_state == NULL && err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2532:	    return err;
    #####: 2533:	  mctx->state_log[str_idx] = cur_state;
    #####: 2534:	  re_node_set_free (&init_nodes);
        -: 2535:	}
        -: 2536:    }
        -: 2537:
    #####: 2538:  for (null_cnt = 0; str_idx < last_str && null_cnt <= mctx->max_mb_elem_len;)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2539:    {
        -: 2540:      int cur_idx;
        -: 2541:      unsigned int context;
        -: 2542:      re_node_set next_nodes;
    #####: 2543:      if (mctx->state_log[str_idx + 1])
branch  0 never executed
branch  1 never executed
        -: 2544:	{
    #####: 2545:	  err = re_node_set_init_copy (&next_nodes,
    #####: 2546:				       &mctx->state_log[str_idx + 1]->nodes);
call    0 never executed
    #####: 2547:	  if (BE (cur_state == NULL && err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2548:	    return err;
        -: 2549:	}
        -: 2550:      else
    #####: 2551:	re_node_set_init_empty (&next_nodes);
        -: 2552:
    #####: 2553:      cur_nodes = cur_state? &cur_state->nodes : &empty_set;
branch  0 never executed
branch  1 never executed
    #####: 2554:      for (cur_idx = 0; cur_idx < cur_nodes->nelem; ++cur_idx)
branch  0 never executed
branch  1 never executed
        -: 2555:	{
    #####: 2556:	  int naccepted = 0;
    #####: 2557:	  int cur_node = cur_nodes->elems[cur_idx];
    #####: 2558:	  re_token_type_t type = dfa->nodes[cur_node].type;
    #####: 2559:	  if (IS_EPSILON_NODE(type))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
    #####: 2560:	    continue;
        -: 2561:#ifdef RE_ENABLE_I18N
        -: 2562:	  /* If the node may accept `multi byte'.  */
        -: 2563:	  if (ACCEPT_MB_NODE (type))
        -: 2564:	    {
        -: 2565:	      naccepted = check_node_accept_bytes (preg, cur_node, mctx->input,
        -: 2566:						   str_idx);
        -: 2567:	      if (naccepted > 1)
        -: 2568:		{
        -: 2569:		  re_node_set union_set;
        -: 2570:		  re_dfastate_t *dest_state;
        -: 2571:		  int next_node = dfa->nexts[cur_node];
        -: 2572:		  int next_idx = str_idx + naccepted;
        -: 2573:		  dest_state = mctx->state_log[next_idx];
        -: 2574:		  if (dest_state)
        -: 2575:		    {
        -: 2576:		      err = re_node_set_init_copy (&union_set,
        -: 2577:						   &dest_state->nodes);
        -: 2578:		      if (BE (err != REG_NOERROR, 0))
        -: 2579:			return err;
        -: 2580:		      err = re_node_set_insert (&union_set, next_node);
        -: 2581:		      if (BE (err < 0, 0))
        -: 2582:			return REG_ESPACE;
        -: 2583:		    }
        -: 2584:		  else
        -: 2585:		    {
        -: 2586:		      err = re_node_set_init_1 (&union_set, next_node);
        -: 2587:		      if (BE (err != REG_NOERROR, 0))
        -: 2588:			return err;
        -: 2589:		    }
        -: 2590:		  mctx->state_log[next_idx] = re_acquire_state (&err, dfa,
        -: 2591:								&union_set);
        -: 2592:		  re_node_set_free (&union_set);
        -: 2593:		  if (BE (mctx->state_log[next_idx] == NULL
        -: 2594:			  && err != REG_NOERROR, 0))
        -: 2595:		    return err;
        -: 2596:		}
        -: 2597:	    }
        -: 2598:#endif /* RE_ENABLE_I18N */
    #####: 2599:	  if (naccepted
branch  0 never executed
branch  1 never executed
    #####: 2600:	      || check_node_accept (preg, dfa->nodes + cur_node, mctx,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2601:				    str_idx))
        -: 2602:	    {
    #####: 2603:	      err = re_node_set_insert (&next_nodes, dfa->nexts[cur_node]);
call    0 never executed
        -: 2604:	      if (BE (err < 0, 0))
        -: 2605:		return REG_ESPACE;
        -: 2606:	    }
        -: 2607:	}
        -: 2608:
    #####: 2609:      ++str_idx;
    #####: 2610:      if (next_nodes.nelem)
branch  0 never executed
branch  1 never executed
        -: 2611:	{
    #####: 2612:	  err = expand_eclosures (dfa, &next_nodes, ex_subexp, fl_open);
call    0 never executed
    #####: 2613:	  if (BE (err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 2614:	    return err;
        -: 2615:	}
    #####: 2616:      if (next_nodes.nelem)
branch  0 never executed
branch  1 never executed
        -: 2617:	{
    #####: 2618:	  err = expand_bkref_cache (preg, mctx, sub_top, sub_last, &next_nodes,
call    0 never executed
        -: 2619:				    str_idx, last_str, ex_subexp, fl_open);
    #####: 2620:	  if (BE ( err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 2621:	    return err;
        -: 2622:	}
    #####: 2623:      context = re_string_context_at (mctx->input, str_idx - 1, mctx->eflags,
    #####: 2624:				      preg->newline_anchor);
call    0 never executed
    #####: 2625:      cur_state = re_acquire_state_context (&err, dfa, &next_nodes, context);
call    0 never executed
    #####: 2626:      if (BE (cur_state == NULL && err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2627:	return err;
    #####: 2628:      mctx->state_log[str_idx] = cur_state;
    #####: 2629:      re_node_set_free (&next_nodes);
    #####: 2630:      null_cnt = cur_state == NULL ? null_cnt + 1 : 0;
branch  0 never executed
branch  1 never executed
        -: 2631:    }
    #####: 2632:  cur_nodes = (mctx->state_log[last_str] == NULL ? NULL
    #####: 2633:	       : &mctx->state_log[last_str]->nodes);
branch  0 never executed
branch  1 never executed
    #####: 2634:  path->next_idx = str_idx;
        -: 2635:
        -: 2636:  /* Fix MCTX.  */
    #####: 2637:  mctx->state_log = backup_state_log;
    #####: 2638:  mctx->input->cur_idx = backup_cur_idx;
        -: 2639:
    #####: 2640:  if (cur_nodes == NULL)
branch  0 never executed
branch  1 never executed
    #####: 2641:    return REG_NOMATCH;
        -: 2642:  /* Then check the current node set has the node LAST_NODE.  */
    #####: 2643:  return (re_node_set_contains (cur_nodes, last_node)
call    0 never executed
    #####: 2644:	  || re_node_set_contains (cur_nodes, last_node) ? REG_NOERROR
call    0 never executed
    #####: 2645:	  : REG_NOMATCH);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2646:}
        -: 2647:
        -: 2648:/* Helper functions for check_arrival.  */
        -: 2649:
        -: 2650:static reg_errcode_t
function expand_eclosures called 0 returned 0% blocks executed 0%
    #####: 2651:expand_eclosures (dfa, cur_nodes, ex_subexp, fl_open)
        -: 2652:     re_dfa_t *dfa;
        -: 2653:     re_node_set *cur_nodes;
        -: 2654:     int ex_subexp, fl_open;
        -: 2655:{
        -: 2656:  reg_errcode_t err;
        -: 2657:  int idx, outside_node;
        -: 2658:  re_node_set new_nodes;
        -: 2659:#ifdef DEBUG
        -: 2660:  assert (cur_nodes->nelem);
        -: 2661:#endif
    #####: 2662:  re_node_set_alloc (&new_nodes, cur_nodes->nelem);
call    0 never executed
        -: 2663:  /* Create a new node set with the nodes which are epsilon closures of
        -: 2664:     a node in cur_nodes.  */
    #####: 2665:  for (idx = 0; idx < cur_nodes->nelem; ++idx)
branch  0 never executed
branch  1 never executed
        -: 2666:    {
    #####: 2667:      int cur_node = cur_nodes->elems[idx];
    #####: 2668:      err = re_node_set_merge (&new_nodes, dfa->eclosures + cur_node);
call    0 never executed
    #####: 2669:      if (BE (err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 2670:	return err;
        -: 2671:    }
    #####: 2672:  outside_node = find_subexp_node (dfa, &new_nodes, ex_subexp, fl_open);
call    0 never executed
    #####: 2673:  if (outside_node == -1)
branch  0 never executed
branch  1 never executed
        -: 2674:    {
    #####: 2675:      re_node_set_free (cur_nodes);
    #####: 2676:      *cur_nodes = new_nodes;
    #####: 2677:      return REG_NOERROR;
        -: 2678:    }
        -: 2679:  /* In this case, we have some nodes which are outside, remove them.  */
    #####: 2680:  re_node_set_empty (&new_nodes);
    #####: 2681:  for (idx = 0; idx < cur_nodes->nelem; ++idx)
branch  0 never executed
branch  1 never executed
        -: 2682:    {
    #####: 2683:      int cur_node = cur_nodes->elems[idx];
    #####: 2684:      re_node_set *eclosure = dfa->eclosures + cur_node;
    #####: 2685:      outside_node = find_subexp_node (dfa, eclosure, ex_subexp, fl_open);
call    0 never executed
    #####: 2686:      if (outside_node == -1)
branch  0 never executed
branch  1 never executed
        -: 2687:	{
    #####: 2688:	  err = re_node_set_merge (&new_nodes, eclosure);
call    0 never executed
    #####: 2689:	  if (BE (err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 2690:	    return err;
        -: 2691:	}
        -: 2692:      else
        -: 2693:	{
    #####: 2694:	  err = expand_eclosures_sub (dfa, &new_nodes, cur_node, ex_subexp,
call    0 never executed
        -: 2695:				      fl_open);
    #####: 2696:	  if (BE (err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 2697:	    return err;
        -: 2698:	}
        -: 2699:    }
    #####: 2700:  re_node_set_free (cur_nodes);
    #####: 2701:  *cur_nodes = new_nodes;
    #####: 2702:  return REG_NOERROR;
        -: 2703:}
        -: 2704:
        -: 2705:static reg_errcode_t
function expand_eclosures_sub called 0 returned 0% blocks executed 0%
    #####: 2706:expand_eclosures_sub (dfa, dst_nodes, target, ex_subexp, fl_open)
        -: 2707:     re_dfa_t *dfa;
        -: 2708:     int target, ex_subexp, fl_open;
        -: 2709:     re_node_set *dst_nodes;
        -: 2710:{
        -: 2711:  int cur_node, type;
    #####: 2712:  for (cur_node = target; !re_node_set_contains (dst_nodes, cur_node);)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2713:    {
        -: 2714:      int err;
    #####: 2715:      type = dfa->nodes[cur_node].type;
        -: 2716:
    #####: 2717:      if (((type == OP_OPEN_SUBEXP && fl_open)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2718:	   || (type == OP_CLOSE_SUBEXP && !fl_open))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2719:	  && dfa->nodes[cur_node].opr.idx == ex_subexp)
branch  0 never executed
branch  1 never executed
        -: 2720:	{
    #####: 2721:	  if (!fl_open)
branch  0 never executed
branch  1 never executed
        -: 2722:	    {
    #####: 2723:	      err = re_node_set_insert (dst_nodes, cur_node);
call    0 never executed
    #####: 2724:	      if (BE (err == -1, 0))
branch  0 never executed
branch  1 never executed
    #####: 2725:		return REG_ESPACE;
        -: 2726:	    }
    #####: 2727:	  break;
        -: 2728:	}
    #####: 2729:      err = re_node_set_insert (dst_nodes, cur_node);
call    0 never executed
    #####: 2730:      if (BE (err == -1, 0))
branch  0 never executed
branch  1 never executed
    #####: 2731:	return REG_ESPACE;
    #####: 2732:      if (dfa->edests[cur_node].nelem == 0)
branch  0 never executed
branch  1 never executed
    #####: 2733:	break;
    #####: 2734:      if (dfa->edests[cur_node].nelem == 2)
branch  0 never executed
branch  1 never executed
        -: 2735:	{
    #####: 2736:	  err = expand_eclosures_sub (dfa, dst_nodes,
    #####: 2737:				      dfa->edests[cur_node].elems[1],
call    0 never executed
        -: 2738:				      ex_subexp, fl_open);
    #####: 2739:	  if (BE (err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 2740:	    return err;
        -: 2741:	}
    #####: 2742:      cur_node = dfa->edests[cur_node].elems[0];
        -: 2743:    }
    #####: 2744:  return REG_NOERROR;
        -: 2745:}
        -: 2746:
        -: 2747:
        -: 2748:/* For all the back references in the current state, calculate the
        -: 2749:   destination of the back references by the appropriate entry
        -: 2750:   in MCTX->BKREF_ENTS.  */
        -: 2751:
        -: 2752:static reg_errcode_t
function expand_bkref_cache called 0 returned 0% blocks executed 0%
    #####: 2753:expand_bkref_cache (preg, mctx, sub_top, sub_last, cur_nodes, cur_str,
        -: 2754:		    last_str, ex_subexp, fl_open)
        -: 2755:     const regex_t *preg;
        -: 2756:     re_match_context_t *mctx;
        -: 2757:     re_sub_match_top_t *sub_top;
        -: 2758:     re_sub_match_last_t *sub_last;
        -: 2759:     int cur_str, last_str, ex_subexp, fl_open;
        -: 2760:     re_node_set *cur_nodes;
        -: 2761:{
        -: 2762:  reg_errcode_t err;
    #####: 2763:  re_dfa_t *dfa = (re_dfa_t *) preg->buffer;
        -: 2764:  re_node_set processed_nodes;
        -: 2765:  int node_idx, cache_idx, cur_subexp_idx;
        -: 2766:  /* The current state.  */
    #####: 2767:  cur_subexp_idx = dfa->nodes[sub_top->node].opr.idx;
    #####: 2768:  re_node_set_init_empty (&processed_nodes);
    #####: 2769:  for (node_idx = 0; node_idx < cur_nodes->nelem; ++node_idx)
branch  0 never executed
branch  1 never executed
        -: 2770:    {
    #####: 2771:      int bkref_node = cur_nodes->elems[node_idx];
    #####: 2772:      if (dfa->nodes[bkref_node].type != OP_BACK_REF
branch  0 never executed
branch  1 never executed
    #####: 2773:	  || re_node_set_contains (&processed_nodes, bkref_node))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2774:	continue;
        -: 2775:
    #####: 2776:      for (cache_idx = 0; cache_idx < mctx->nbkref_ents; ++cache_idx)
branch  0 never executed
branch  1 never executed
        -: 2777:	{
        -: 2778:	  int to_idx, next_node;
    #####: 2779:	  struct re_backref_cache_entry *ent = mctx->bkref_ents + cache_idx;
        -: 2780:	  /* Is this entry ENT is appropriate?  */
    #####: 2781:	  if (ent->str_idx != cur_str
branch  0 never executed
branch  1 never executed
    #####: 2782:	      || !re_node_set_contains (cur_nodes, ent->node))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2783:	    continue; /* No.  */
        -: 2784:
    #####: 2785:	  to_idx = cur_str + ent->subexp_to - ent->subexp_from;
        -: 2786:	  /* Calculate the destination of the back reference, and append it
        -: 2787:	     to MCTX->STATE_LOG.  */
    #####: 2788:	  if (to_idx == cur_str)
branch  0 never executed
branch  1 never executed
        -: 2789:	    {
        -: 2790:	      re_node_set new_dests;
    #####: 2791:	      next_node = dfa->edests[ent->node].elems[0];
    #####: 2792:	      if (re_node_set_contains (cur_nodes, next_node))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2793:		continue;
    #####: 2794:	      err = re_node_set_init_1 (&new_dests, next_node);
call    0 never executed
    #####: 2795:	      if (BE (err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 2796:		return err;
    #####: 2797:	      err = expand_eclosures (dfa, &new_dests, ex_subexp, fl_open);
call    0 never executed
    #####: 2798:	      if (BE (err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 2799:		return err;
    #####: 2800:	      err = re_node_set_merge (cur_nodes, &new_dests);
call    0 never executed
    #####: 2801:	      if (BE (err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 2802:		return err;
    #####: 2803:	      re_node_set_free (&new_dests);
        -: 2804:	      /* TODO: It is still inefficient...  */
    #####: 2805:	      node_idx = -1;
    #####: 2806:	      break;
        -: 2807:	    }
        -: 2808:	  else
        -: 2809:	    {
        -: 2810:	      re_node_set union_set;
    #####: 2811:	      next_node = dfa->nexts[ent->node];
    #####: 2812:	      if (mctx->state_log[to_idx])
branch  0 never executed
branch  1 never executed
        -: 2813:		{
        -: 2814:		  int ret;
    #####: 2815:		  if (re_node_set_contains (&mctx->state_log[to_idx]->nodes,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2816:					    next_node))
    #####: 2817:		    continue;
    #####: 2818:		  err = re_node_set_init_copy (&union_set,
    #####: 2819:					      &mctx->state_log[to_idx]->nodes);
call    0 never executed
    #####: 2820:		  if (BE (err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 2821:		    return err;
    #####: 2822:		  ret = re_node_set_insert (&union_set, next_node);
call    0 never executed
        -: 2823:		  if (BE (err < 0, 0))
        -: 2824:		    return REG_ESPACE;
        -: 2825:		}
        -: 2826:	      else
        -: 2827:		{
    #####: 2828:		  err = re_node_set_init_1 (&union_set, next_node);
call    0 never executed
    #####: 2829:		  if (BE (err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 2830:		    return err;
        -: 2831:		}
    #####: 2832:	      mctx->state_log[to_idx] = re_acquire_state (&err, dfa,
call    0 never executed
        -: 2833:							  &union_set);
    #####: 2834:	      re_node_set_free (&union_set);
    #####: 2835:	      if (BE (mctx->state_log[to_idx] == NULL
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2836:		      && err != REG_NOERROR, 0))
    #####: 2837:		return err;
        -: 2838:	    }
        -: 2839:	}
        -: 2840:    }
    #####: 2841:  re_node_set_free (&processed_nodes);
    #####: 2842:  return REG_NOERROR;
        -: 2843:}
        -: 2844:
        -: 2845:/* Build transition table for the state.
        -: 2846:   Return the new table if succeeded, otherwise return NULL.  */
        -: 2847:
        -: 2848:static re_dfastate_t **
function build_trtable called 2827 returned 100% blocks executed 73%
     2827: 2849:build_trtable (preg, state, fl_search)
        -: 2850:    const regex_t *preg;
        -: 2851:    const re_dfastate_t *state;
        -: 2852:    int fl_search;
        -: 2853:{
        -: 2854:  reg_errcode_t err;
     2827: 2855:  re_dfa_t *dfa = (re_dfa_t *) preg->buffer;
        -: 2856:  int i, j, k, ch;
     2827: 2857:  int dests_node_malloced = 0, dest_states_malloced = 0;
        -: 2858:  int ndests; /* Number of the destination states from `state'.  */
        -: 2859:  re_dfastate_t **trtable;
     2827: 2860:  re_dfastate_t **dest_states = NULL, **dest_states_word, **dest_states_nl;
        -: 2861:  re_node_set follows, *dests_node;
        -: 2862:  bitset *dests_ch;
        -: 2863:  bitset acceptable;
        -: 2864:
        -: 2865:  /* We build DFA states which corresponds to the destination nodes
        -: 2866:     from `state'.  `dests_node[i]' represents the nodes which i-th
        -: 2867:     destination state contains, and `dests_ch[i]' represents the
        -: 2868:     characters which i-th destination state accepts.  */
        -: 2869:#ifdef _LIBC
        -: 2870:  if (__libc_use_alloca ((sizeof (re_node_set) + sizeof (bitset)) * SBC_MAX))
        -: 2871:    dests_node = (re_node_set *)
        -: 2872:		 alloca ((sizeof (re_node_set) + sizeof (bitset)) * SBC_MAX);
        -: 2873:  else
        -: 2874:#endif
        -: 2875:    {
        -: 2876:      dests_node = (re_node_set *)
     2827: 2877:		   malloc ((sizeof (re_node_set) + sizeof (bitset)) * SBC_MAX);
     2827: 2878:      if (BE (dests_node == NULL, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 2827
    #####: 2879:	return NULL;
     2827: 2880:      dests_node_malloced = 1;
        -: 2881:    }
     2827: 2882:  dests_ch = (bitset *) (dests_node + SBC_MAX);
        -: 2883:
        -: 2884:  /* Initialize transiton table.  */
     2827: 2885:  trtable = (re_dfastate_t **) calloc (sizeof (re_dfastate_t *), SBC_MAX);
     2827: 2886:  if (BE (trtable == NULL, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 2827
        -: 2887:    {
    #####: 2888:      if (dests_node_malloced)
branch  0 never executed
branch  1 never executed
    #####: 2889:	free (dests_node);
    #####: 2890:      return NULL;
        -: 2891:    }
        -: 2892:
        -: 2893:  /* At first, group all nodes belonging to `state' into several
        -: 2894:     destinations.  */
     2827: 2895:  ndests = group_nodes_into_DFAstates (preg, state, dests_node, dests_ch);
call    0 returned 2827
     2827: 2896:  if (BE (ndests <= 0, 0))
branch  0 taken 692 (fallthrough)
branch  1 taken 2135
        -: 2897:    {
      692: 2898:      if (dests_node_malloced)
branch  0 taken 692 (fallthrough)
branch  1 taken 0
      692: 2899:	free (dests_node);
        -: 2900:      /* Return NULL in case of an error, trtable otherwise.  */
      692: 2901:      if (ndests == 0)
branch  0 taken 692 (fallthrough)
branch  1 taken 0
      692: 2902:	return trtable;
    #####: 2903:      free (trtable);
    #####: 2904:      return NULL;
        -: 2905:    }
        -: 2906:
     2135: 2907:  err = re_node_set_alloc (&follows, ndests + 1);
call    0 returned 2135
     2135: 2908:  if (BE (err != REG_NOERROR, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 2135
    #####: 2909:    goto out_free;
        -: 2910:
        -: 2911:#ifdef _LIBC
        -: 2912:  if (__libc_use_alloca ((sizeof (re_node_set) + sizeof (bitset)) * SBC_MAX
        -: 2913:			 + ndests * 3 * sizeof (re_dfastate_t *)))
        -: 2914:    dest_states = (re_dfastate_t **)
        -: 2915:		  alloca (ndests * 3 * sizeof (re_dfastate_t *));
        -: 2916:  else
        -: 2917:#endif
        -: 2918:    {
        -: 2919:      dest_states = (re_dfastate_t **)
     2135: 2920:		    malloc (ndests * 3 * sizeof (re_dfastate_t *));
     2135: 2921:      if (BE (dest_states == NULL, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 2135
        -: 2922:	{
    #####: 2923:out_free:
    #####: 2924:	  if (dest_states_malloced)
branch  0 never executed
branch  1 never executed
    #####: 2925:	    free (dest_states);
    #####: 2926:	  re_node_set_free (&follows);
    #####: 2927:	  for (i = 0; i < ndests; ++i)
branch  0 never executed
branch  1 never executed
    #####: 2928:	    re_node_set_free (dests_node + i);
    #####: 2929:	  free (trtable);
    #####: 2930:	  if (dests_node_malloced)
branch  0 never executed
branch  1 never executed
    #####: 2931:	    free (dests_node);
    #####: 2932:	  return NULL;
        -: 2933:	}
     2135: 2934:      dest_states_malloced = 1;
        -: 2935:    }
     2135: 2936:  dest_states_word = dest_states + ndests;
     2135: 2937:  dest_states_nl = dest_states_word + ndests;
     2135: 2938:  bitset_empty (acceptable);
        -: 2939:
        -: 2940:  /* Then build the states for all destinations.  */
     4402: 2941:  for (i = 0; i < ndests; ++i)
branch  0 taken 2267
branch  1 taken 2135 (fallthrough)
        -: 2942:    {
        -: 2943:      int next_node;
     2267: 2944:      re_node_set_empty (&follows);
        -: 2945:      /* Merge the follows of this destination states.  */
     4779: 2946:      for (j = 0; j < dests_node[i].nelem; ++j)
branch  0 taken 2512
branch  1 taken 2267 (fallthrough)
        -: 2947:	{
     2512: 2948:	  next_node = dfa->nexts[dests_node[i].elems[j]];
     2512: 2949:	  if (next_node != -1)
branch  0 taken 2512 (fallthrough)
branch  1 taken 0
        -: 2950:	    {
     2512: 2951:	      err = re_node_set_merge (&follows, dfa->eclosures + next_node);
call    0 returned 2512
     2512: 2952:	      if (BE (err != REG_NOERROR, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 2512
    #####: 2953:		goto out_free;
        -: 2954:	    }
        -: 2955:	}
        -: 2956:      /* If search flag is set, merge the initial state.  */
     2267: 2957:      if (fl_search)
branch  0 taken 0 (fallthrough)
branch  1 taken 2267
        -: 2958:	{
        -: 2959:#ifdef RE_ENABLE_I18N
        -: 2960:	  int not_initial = 0;
        -: 2961:	  for (j = 0; j < follows.nelem; ++j)
        -: 2962:	    if (dfa->nodes[follows.elems[j]].type == CHARACTER)
        -: 2963:	      {
        -: 2964:		not_initial = dfa->nodes[follows.elems[j]].mb_partial;
        -: 2965:		break;
        -: 2966:	      }
        -: 2967:	  if (!not_initial)
        -: 2968:#endif
        -: 2969:	    {
    #####: 2970:	      err = re_node_set_merge (&follows,
    #####: 2971:				       dfa->init_state->entrance_nodes);
call    0 never executed
    #####: 2972:	      if (BE (err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 2973:		goto out_free;
        -: 2974:	    }
        -: 2975:	}
     2267: 2976:      dest_states[i] = re_acquire_state_context (&err, dfa, &follows, 0);
call    0 returned 2267
    2267*: 2977:      if (BE (dest_states[i] == NULL && err != REG_NOERROR, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 2267
branch  2 never executed
branch  3 never executed
    #####: 2978:	goto out_free;
        -: 2979:      /* If the new state has context constraint,
        -: 2980:	 build appropriate states for these contexts.  */
     2267: 2981:      if (dest_states[i]->has_constraint)
branch  0 taken 53 (fallthrough)
branch  1 taken 2214
        -: 2982:	{
       53: 2983:	  dest_states_word[i] = re_acquire_state_context (&err, dfa, &follows,
call    0 returned 53
        -: 2984:							  CONTEXT_WORD);
      53*: 2985:	  if (BE (dest_states_word[i] == NULL && err != REG_NOERROR, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 53
branch  2 never executed
branch  3 never executed
    #####: 2986:	    goto out_free;
       53: 2987:	  dest_states_nl[i] = re_acquire_state_context (&err, dfa, &follows,
call    0 returned 53
        -: 2988:							CONTEXT_NEWLINE);
      53*: 2989:	  if (BE (dest_states_nl[i] == NULL && err != REG_NOERROR, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 53
branch  2 never executed
branch  3 never executed
    #####: 2990:	    goto out_free;
        -: 2991:	}
        -: 2992:      else
        -: 2993:	{
     2214: 2994:	  dest_states_word[i] = dest_states[i];
     2214: 2995:	  dest_states_nl[i] = dest_states[i];
        -: 2996:	}
     2267: 2997:      bitset_merge (acceptable, dests_ch[i]);
call    0 returned 2267
        -: 2998:    }
        -: 2999:
        -: 3000:  /* Update the transition table.  */
        -: 3001:  /* For all characters ch...:  */
    19215: 3002:  for (i = 0, ch = 0; i < BITSET_UINTS; ++i)
branch  0 taken 17080
branch  1 taken 2135 (fallthrough)
   563640: 3003:    for (j = 0; j < UINT_BITS; ++j, ++ch)
branch  0 taken 546560
branch  1 taken 17080 (fallthrough)
   546560: 3004:      if ((acceptable[i] >> j) & 1)
branch  0 taken 40996 (fallthrough)
branch  1 taken 505564
        -: 3005:	{
        -: 3006:	  /* The current state accepts the character ch.  */
    40996: 3007:	  if (IS_WORD_CHAR (ch))
branch  0 taken 30127 (fallthrough)
branch  1 taken 10869
branch  2 taken 153 (fallthrough)
branch  3 taken 29974
        -: 3008:	    {
    19148: 3009:	      for (k = 0; k < ndests; ++k)
branch  0 taken 19148
branch  1 taken 0 (fallthrough)
    19148: 3010:		if ((dests_ch[k][i] >> j) & 1)
branch  0 taken 11022 (fallthrough)
branch  1 taken 8126
        -: 3011:		  {
        -: 3012:		    /* k-th destination accepts the word character ch.  */
    11022: 3013:		    trtable[ch] = dest_states_word[k];
        -: 3014:		    /* There must be only one destination which accepts
        -: 3015:		       character ch.  See group_nodes_into_DFAstates.  */
    11022: 3016:		    break;
        -: 3017:		  }
        -: 3018:	    }
        -: 3019:	  else /* not WORD_CHAR */
        -: 3020:	    {
    54858: 3021:	      for (k = 0; k < ndests; ++k)
branch  0 taken 54858
branch  1 taken 0 (fallthrough)
    54858: 3022:		if ((dests_ch[k][i] >> j) & 1)
branch  0 taken 29974 (fallthrough)
branch  1 taken 24884
        -: 3023:		  {
        -: 3024:		    /* k-th destination accepts the non-word character ch.  */
    29974: 3025:		    trtable[ch] = dest_states[k];
        -: 3026:		    /* There must be only one destination which accepts
        -: 3027:		       character ch.  See group_nodes_into_DFAstates.  */
    29974: 3028:		    break;
        -: 3029:		  }
        -: 3030:	    }
        -: 3031:	}
        -: 3032:  /* new line */
     2135: 3033:  if (bitset_contain (acceptable, NEWLINE_CHAR))
branch  0 taken 165 (fallthrough)
branch  1 taken 1970
        -: 3034:    {
        -: 3035:      /* The current state accepts newline character.  */
      295: 3036:      for (k = 0; k < ndests; ++k)
branch  0 taken 295
branch  1 taken 0 (fallthrough)
      295: 3037:	if (bitset_contain (dests_ch[k], NEWLINE_CHAR))
branch  0 taken 165 (fallthrough)
branch  1 taken 130
        -: 3038:	  {
        -: 3039:	    /* k-th destination accepts newline character.  */
      165: 3040:	    trtable[NEWLINE_CHAR] = dest_states_nl[k];
        -: 3041:	    /* There must be only one destination which accepts
        -: 3042:	       newline.  See group_nodes_into_DFAstates.  */
      165: 3043:	    break;
        -: 3044:	  }
        -: 3045:    }
        -: 3046:
     2135: 3047:  if (dest_states_malloced)
branch  0 taken 2135 (fallthrough)
branch  1 taken 0
     2135: 3048:    free (dest_states);
        -: 3049:
     2135: 3050:  re_node_set_free (&follows);
     4402: 3051:  for (i = 0; i < ndests; ++i)
branch  0 taken 2267
branch  1 taken 2135 (fallthrough)
     2267: 3052:    re_node_set_free (dests_node + i);
        -: 3053:
     2135: 3054:  if (dests_node_malloced)
branch  0 taken 2135 (fallthrough)
branch  1 taken 0
     2135: 3055:    free (dests_node);
        -: 3056:
     2135: 3057:  return trtable;
        -: 3058:}
        -: 3059:
        -: 3060:/* Group all nodes belonging to STATE into several destinations.
        -: 3061:   Then for all destinations, set the nodes belonging to the destination
        -: 3062:   to DESTS_NODE[i] and set the characters accepted by the destination
        -: 3063:   to DEST_CH[i].  This function return the number of destinations.  */
        -: 3064:
        -: 3065:static int
function group_nodes_into_DFAstates called 2827 returned 100% blocks executed 75%
     2827: 3066:group_nodes_into_DFAstates (preg, state, dests_node, dests_ch)
        -: 3067:    const regex_t *preg;
        -: 3068:    const re_dfastate_t *state;
        -: 3069:    re_node_set *dests_node;
        -: 3070:    bitset *dests_ch;
        -: 3071:{
        -: 3072:  reg_errcode_t err;
     2827: 3073:  const re_dfa_t *dfa = (re_dfa_t *) preg->buffer;
        -: 3074:  int i, j, k;
        -: 3075:  int ndests; /* Number of the destinations from `state'.  */
        -: 3076:  bitset accepts; /* Characters a node can accept.  */
     2827: 3077:  const re_node_set *cur_nodes = &state->nodes;
     2827: 3078:  bitset_empty (accepts);
     2827: 3079:  ndests = 0;
        -: 3080:
        -: 3081:  /* For all the nodes belonging to `state',  */
     6216: 3082:  for (i = 0; i < cur_nodes->nelem; ++i)
branch  0 taken 3389
branch  1 taken 2827 (fallthrough)
        -: 3083:    {
     3389: 3084:      re_token_t *node = &dfa->nodes[cur_nodes->elems[i]];
     3389: 3085:      re_token_type_t type = node->type;
     3389: 3086:      unsigned int constraint = node->constraint;
        -: 3087:
        -: 3088:      /* Enumerate all single byte character this node can accept.  */
     3389: 3089:      if (type == CHARACTER)
branch  0 taken 2128 (fallthrough)
branch  1 taken 1261
     2128: 3090:	bitset_set (accepts, node->opr.c);
     1261: 3091:      else if (type == SIMPLE_BRACKET)
branch  0 taken 9 (fallthrough)
branch  1 taken 1252
        -: 3092:	{
        9: 3093:	  bitset_merge (accepts, node->opr.sbcset);
call    0 returned 9
        -: 3094:	}
     1252: 3095:      else if (type == OP_PERIOD)
branch  0 taken 195 (fallthrough)
branch  1 taken 1057
        -: 3096:	{
      195: 3097:	  bitset_set_all (accepts);
      195: 3098:	  if (!(preg->syntax & RE_DOT_NEWLINE))
branch  0 taken 0 (fallthrough)
branch  1 taken 195
    #####: 3099:	    bitset_clear (accepts, '\n');
      195: 3100:	  if (preg->syntax & RE_DOT_NOT_NULL)
branch  0 taken 195 (fallthrough)
branch  1 taken 0
      195: 3101:	    bitset_clear (accepts, '\0');
        -: 3102:	}
        -: 3103:      else
     1057: 3104:	continue;
        -: 3105:
        -: 3106:      /* Check the `accepts' and sift the characters which are not
        -: 3107:	 match it the context.  */
     2332: 3108:      if (constraint)
branch  0 taken 93 (fallthrough)
branch  1 taken 2239
        -: 3109:	{
       93: 3110:	  if (constraint & NEXT_WORD_CONSTRAINT)
branch  0 taken 0 (fallthrough)
branch  1 taken 93
    #####: 3111:	    for (j = 0; j < BITSET_UINTS; ++j)
branch  0 never executed
branch  1 never executed
    #####: 3112:	      accepts[j] &= dfa->word_char[j];
       93: 3113:	  if (constraint & NEXT_NOTWORD_CONSTRAINT)
branch  0 taken 0 (fallthrough)
branch  1 taken 93
    #####: 3114:	    for (j = 0; j < BITSET_UINTS; ++j)
branch  0 never executed
branch  1 never executed
    #####: 3115:	      accepts[j] &= ~dfa->word_char[j];
       93: 3116:	  if (constraint & NEXT_NEWLINE_CONSTRAINT)
branch  0 taken 0 (fallthrough)
branch  1 taken 93
        -: 3117:	    {
    #####: 3118:	      int accepts_newline = bitset_contain (accepts, NEWLINE_CHAR);
    #####: 3119:	      bitset_empty (accepts);
    #####: 3120:	      if (accepts_newline)
branch  0 never executed
branch  1 never executed
    #####: 3121:		bitset_set (accepts, NEWLINE_CHAR);
        -: 3122:	      else
    #####: 3123:		continue;
        -: 3124:	    }
        -: 3125:	}
        -: 3126:
        -: 3127:      /* Then divide `accepts' into DFA states, or create a new
        -: 3128:	 state.  */
     2397: 3129:      for (j = 0; j < ndests; ++j)
branch  0 taken 260
branch  1 taken 2137 (fallthrough)
        -: 3130:	{
        -: 3131:	  bitset intersec; /* Intersection sets, see below.  */
        -: 3132:	  bitset remains;
        -: 3133:	  /* Flags, see below.  */
        -: 3134:	  int has_intersec, not_subset, not_consumed;
        -: 3135:
        -: 3136:	  /* Optimization, skip if this state doesn't accept the character.  */
      260: 3137:	  if (type == CHARACTER && !bitset_contain (dests_ch[j], node->opr.c))
branch  0 taken 163 (fallthrough)
branch  1 taken 97
branch  2 taken 12 (fallthrough)
branch  3 taken 151
       15: 3138:	    continue;
        -: 3139:
        -: 3140:	  /* Enumerate the intersection set of this state and `accepts'.  */
      248: 3141:	  has_intersec = 0;
     2232: 3142:	  for (k = 0; k < BITSET_UINTS; ++k)
branch  0 taken 1984
branch  1 taken 248 (fallthrough)
     1984: 3143:	    has_intersec |= intersec[k] = accepts[k] & dests_ch[j][k];
        -: 3144:	  /* And skip if the intersection set is empty.  */
      248: 3145:	  if (!has_intersec)
branch  0 taken 3 (fallthrough)
branch  1 taken 245
        3: 3146:	    continue;
        -: 3147:
        -: 3148:	  /* Then check if this state is a subset of `accepts'.  */
      245: 3149:	  not_subset = not_consumed = 0;
     2205: 3150:	  for (k = 0; k < BITSET_UINTS; ++k)
branch  0 taken 1960
branch  1 taken 245 (fallthrough)
        -: 3151:	    {
     1960: 3152:	      not_subset |= remains[k] = ~accepts[k] & dests_ch[j][k];
     1960: 3153:	      not_consumed |= accepts[k] = accepts[k] & ~dests_ch[j][k];
        -: 3154:	    }
        -: 3155:
        -: 3156:	  /* If this state isn't a subset of `accepts', create a
        -: 3157:	     new group state, which has the `remains'. */
      245: 3158:	  if (not_subset)
branch  0 taken 130 (fallthrough)
branch  1 taken 115
        -: 3159:	    {
      130: 3160:	      bitset_copy (dests_ch[ndests], remains);
      130: 3161:	      bitset_copy (dests_ch[j], intersec);
      130: 3162:	      err = re_node_set_init_copy (dests_node + ndests, &dests_node[j]);
call    0 returned 130
      130: 3163:	      if (BE (err != REG_NOERROR, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 130
    #####: 3164:		goto error_return;
      130: 3165:	      ++ndests;
        -: 3166:	    }
        -: 3167:
        -: 3168:	  /* Put the position in the current group. */
      245: 3169:	  err = re_node_set_insert (&dests_node[j], cur_nodes->elems[i]);
call    0 returned 245
        -: 3170:	  if (BE (err < 0, 0))
        -: 3171:	    goto error_return;
        -: 3172:
        -: 3173:	  /* If all characters are consumed, go to next node. */
      245: 3174:	  if (!not_consumed)
branch  0 taken 195 (fallthrough)
branch  1 taken 50
      195: 3175:	    break;
        -: 3176:	}
        -: 3177:      /* Some characters remain, create a new group. */
     2332: 3178:      if (j == ndests)
branch  0 taken 2137 (fallthrough)
branch  1 taken 195
        -: 3179:	{
     2137: 3180:	  bitset_copy (dests_ch[ndests], accepts);
     2137: 3181:	  err = re_node_set_init_1 (dests_node + ndests, cur_nodes->elems[i]);
call    0 returned 2137
     2137: 3182:	  if (BE (err != REG_NOERROR, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 2137
    #####: 3183:	    goto error_return;
     2137: 3184:	  ++ndests;
     2137: 3185:	  bitset_empty (accepts);
        -: 3186:	}
        -: 3187:    }
     2827: 3188:  return ndests;
    #####: 3189: error_return:
    #####: 3190:  for (j = 0; j < ndests; ++j)
branch  0 never executed
branch  1 never executed
    #####: 3191:    re_node_set_free (dests_node + j);
    #####: 3192:  return -1;
        -: 3193:}
        -: 3194:
        -: 3195:#ifdef RE_ENABLE_I18N
        -: 3196:/* Check how many bytes the node `dfa->nodes[node_idx]' accepts.
        -: 3197:   Return the number of the bytes the node accepts.
        -: 3198:   STR_IDX is the current index of the input string.
        -: 3199:
        -: 3200:   This function handles the nodes which can accept one character, or
        -: 3201:   one collating element like '.', '[a-z]', opposite to the other nodes
        -: 3202:   can only accept one byte.  */
        -: 3203:
        -: 3204:static int
        -: 3205:check_node_accept_bytes (preg, node_idx, input, str_idx)
        -: 3206:    const regex_t *preg;
        -: 3207:    int node_idx, str_idx;
        -: 3208:    const re_string_t *input;
        -: 3209:{
        -: 3210:  const re_dfa_t *dfa = (re_dfa_t *) preg->buffer;
        -: 3211:  const re_token_t *node = dfa->nodes + node_idx;
        -: 3212:  int elem_len = re_string_elem_size_at (input, str_idx);
        -: 3213:  int char_len = re_string_char_size_at (input, str_idx);
        -: 3214:  int i;
        -: 3215:# ifdef _LIBC
        -: 3216:  int j;
        -: 3217:  uint32_t nrules = _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES);
        -: 3218:# endif /* _LIBC */
        -: 3219:  if (elem_len <= 1 && char_len <= 1)
        -: 3220:    return 0;
        -: 3221:  if (node->type == OP_PERIOD)
        -: 3222:    {
        -: 3223:      /* '.' accepts any one character except the following two cases.  */
        -: 3224:      if ((!(preg->syntax & RE_DOT_NEWLINE) &&
        -: 3225:	   re_string_byte_at (input, str_idx) == '\n') ||
        -: 3226:	  ((preg->syntax & RE_DOT_NOT_NULL) &&
        -: 3227:	   re_string_byte_at (input, str_idx) == '\0'))
        -: 3228:	return 0;
        -: 3229:      return char_len;
        -: 3230:    }
        -: 3231:  else if (node->type == COMPLEX_BRACKET)
        -: 3232:    {
        -: 3233:      const re_charset_t *cset = node->opr.mbcset;
        -: 3234:# ifdef _LIBC
        -: 3235:      const unsigned char *pin = re_string_get_buffer (input) + str_idx;
        -: 3236:# endif /* _LIBC */
        -: 3237:      int match_len = 0;
        -: 3238:      wchar_t wc = ((cset->nranges || cset->nchar_classes || cset->nmbchars)
        -: 3239:		    ? re_string_wchar_at (input, str_idx) : 0);
        -: 3240:
        -: 3241:      /* match with multibyte character?  */
        -: 3242:      for (i = 0; i < cset->nmbchars; ++i)
        -: 3243:	if (wc == cset->mbchars[i])
        -: 3244:	  {
        -: 3245:	    match_len = char_len;
        -: 3246:	    goto check_node_accept_bytes_match;
        -: 3247:	  }
        -: 3248:      /* match with character_class?  */
        -: 3249:      for (i = 0; i < cset->nchar_classes; ++i)
        -: 3250:	{
        -: 3251:	  wctype_t wt = cset->char_classes[i];
        -: 3252:	  if (__iswctype (wc, wt))
        -: 3253:	    {
        -: 3254:	      match_len = char_len;
        -: 3255:	      goto check_node_accept_bytes_match;
        -: 3256:	    }
        -: 3257:	}
        -: 3258:
        -: 3259:# ifdef _LIBC
        -: 3260:      if (nrules != 0)
        -: 3261:	{
        -: 3262:	  unsigned int in_collseq = 0;
        -: 3263:	  const int32_t *table, *indirect;
        -: 3264:	  const unsigned char *weights, *extra;
        -: 3265:	  const char *collseqwc;
        -: 3266:	  int32_t idx;
        -: 3267:	  /* This #include defines a local function!  */
        -: 3268:#  include <locale/weight.h>
        -: 3269:
        -: 3270:	  /* match with collating_symbol?  */
        -: 3271:	  if (cset->ncoll_syms)
        -: 3272:	    extra = (const unsigned char *)
        -: 3273:	      _NL_CURRENT (LC_COLLATE, _NL_COLLATE_SYMB_EXTRAMB);
        -: 3274:	  for (i = 0; i < cset->ncoll_syms; ++i)
        -: 3275:	    {
        -: 3276:	      const unsigned char *coll_sym = extra + cset->coll_syms[i];
        -: 3277:	      /* Compare the length of input collating element and
        -: 3278:		 the length of current collating element.  */
        -: 3279:	      if (*coll_sym != elem_len)
        -: 3280:		continue;
        -: 3281:	      /* Compare each bytes.  */
        -: 3282:	      for (j = 0; j < *coll_sym; j++)
        -: 3283:		if (pin[j] != coll_sym[1 + j])
        -: 3284:		  break;
        -: 3285:	      if (j == *coll_sym)
        -: 3286:		{
        -: 3287:		  /* Match if every bytes is equal.  */
        -: 3288:		  match_len = j;
        -: 3289:		  goto check_node_accept_bytes_match;
        -: 3290:		}
        -: 3291:	    }
        -: 3292:
        -: 3293:	  if (cset->nranges)
        -: 3294:	    {
        -: 3295:	      if (elem_len <= char_len)
        -: 3296:		{
        -: 3297:		  collseqwc = _NL_CURRENT (LC_COLLATE, _NL_COLLATE_COLLSEQWC);
        -: 3298:		  in_collseq = collseq_table_lookup (collseqwc, wc);
        -: 3299:		}
        -: 3300:	      else
        -: 3301:		in_collseq = find_collation_sequence_value (pin, elem_len);
        -: 3302:	    }
        -: 3303:	  /* match with range expression?  */
        -: 3304:	  for (i = 0; i < cset->nranges; ++i)
        -: 3305:	    if (cset->range_starts[i] <= in_collseq
        -: 3306:		&& in_collseq <= cset->range_ends[i])
        -: 3307:	      {
        -: 3308:		match_len = elem_len;
        -: 3309:		goto check_node_accept_bytes_match;
        -: 3310:	      }
        -: 3311:
        -: 3312:	  /* match with equivalence_class?  */
        -: 3313:	  if (cset->nequiv_classes)
        -: 3314:	    {
        -: 3315:	      const unsigned char *cp = pin;
        -: 3316:	      table = (const int32_t *)
        -: 3317:		_NL_CURRENT (LC_COLLATE, _NL_COLLATE_TABLEMB);
        -: 3318:	      weights = (const unsigned char *)
        -: 3319:		_NL_CURRENT (LC_COLLATE, _NL_COLLATE_WEIGHTMB);
        -: 3320:	      extra = (const unsigned char *)
        -: 3321:		_NL_CURRENT (LC_COLLATE, _NL_COLLATE_EXTRAMB);
        -: 3322:	      indirect = (const int32_t *)
        -: 3323:		_NL_CURRENT (LC_COLLATE, _NL_COLLATE_INDIRECTMB);
        -: 3324:	      idx = findidx (&cp);
        -: 3325:	      if (idx > 0)
        -: 3326:		for (i = 0; i < cset->nequiv_classes; ++i)
        -: 3327:		  {
        -: 3328:		    int32_t equiv_class_idx = cset->equiv_classes[i];
        -: 3329:		    size_t weight_len = weights[idx];
        -: 3330:		    if (weight_len == weights[equiv_class_idx])
        -: 3331:		      {
        -: 3332:			int cnt = 0;
        -: 3333:			while (cnt <= weight_len
        -: 3334:			       && (weights[equiv_class_idx + 1 + cnt]
        -: 3335:				   == weights[idx + 1 + cnt]))
        -: 3336:			  ++cnt;
        -: 3337:			if (cnt > weight_len)
        -: 3338:			  {
        -: 3339:			    match_len = elem_len;
        -: 3340:			    goto check_node_accept_bytes_match;
        -: 3341:			  }
        -: 3342:		      }
        -: 3343:		  }
        -: 3344:	    }
        -: 3345:	}
        -: 3346:      else
        -: 3347:# endif /* _LIBC */
        -: 3348:	{
        -: 3349:	  /* match with range expression?  */
        -: 3350:#if __GNUC__ >= 2
        -: 3351:	  wchar_t cmp_buf[] = {L'\0', L'\0', wc, L'\0', L'\0', L'\0'};
        -: 3352:#else
        -: 3353:	  wchar_t cmp_buf[] = {L'\0', L'\0', L'\0', L'\0', L'\0', L'\0'};
        -: 3354:	  cmp_buf[2] = wc;
        -: 3355:#endif
        -: 3356:	  for (i = 0; i < cset->nranges; ++i)
        -: 3357:	    {
        -: 3358:	      cmp_buf[0] = cset->range_starts[i];
        -: 3359:	      cmp_buf[4] = cset->range_ends[i];
        -: 3360:	      if (wcscoll (cmp_buf, cmp_buf + 2) <= 0
        -: 3361:		  && wcscoll (cmp_buf + 2, cmp_buf + 4) <= 0)
        -: 3362:		{
        -: 3363:		  match_len = char_len;
        -: 3364:		  goto check_node_accept_bytes_match;
        -: 3365:		}
        -: 3366:	    }
        -: 3367:	}
        -: 3368:    check_node_accept_bytes_match:
        -: 3369:      if (!cset->non_match)
        -: 3370:	return match_len;
        -: 3371:      else
        -: 3372:	{
        -: 3373:	  if (match_len > 0)
        -: 3374:	    return 0;
        -: 3375:	  else
        -: 3376:	    return (elem_len > char_len) ? elem_len : char_len;
        -: 3377:	}
        -: 3378:    }
        -: 3379:  return 0;
        -: 3380:}
        -: 3381:
        -: 3382:# ifdef _LIBC
        -: 3383:static unsigned int
        -: 3384:find_collation_sequence_value (mbs, mbs_len)
        -: 3385:    const unsigned char *mbs;
        -: 3386:    size_t mbs_len;
        -: 3387:{
        -: 3388:  uint32_t nrules = _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES);
        -: 3389:  if (nrules == 0)
        -: 3390:    {
        -: 3391:      if (mbs_len == 1)
        -: 3392:	{
        -: 3393:	  /* No valid character.  Match it as a single byte character.  */
        -: 3394:	  const unsigned char *collseq = (const unsigned char *)
        -: 3395:	    _NL_CURRENT (LC_COLLATE, _NL_COLLATE_COLLSEQMB);
        -: 3396:	  return collseq[mbs[0]];
        -: 3397:	}
        -: 3398:      return UINT_MAX;
        -: 3399:    }
        -: 3400:  else
        -: 3401:    {
        -: 3402:      int32_t idx;
        -: 3403:      const unsigned char *extra = (const unsigned char *)
        -: 3404:	_NL_CURRENT (LC_COLLATE, _NL_COLLATE_SYMB_EXTRAMB);
        -: 3405:
        -: 3406:      for (idx = 0; ;)
        -: 3407:	{
        -: 3408:	  int mbs_cnt, found = 0;
        -: 3409:	  int32_t elem_mbs_len;
        -: 3410:	  /* Skip the name of collating element name.  */
        -: 3411:	  idx = idx + extra[idx] + 1;
        -: 3412:	  elem_mbs_len = extra[idx++];
        -: 3413:	  if (mbs_len == elem_mbs_len)
        -: 3414:	    {
        -: 3415:	      for (mbs_cnt = 0; mbs_cnt < elem_mbs_len; ++mbs_cnt)
        -: 3416:		if (extra[idx + mbs_cnt] != mbs[mbs_cnt])
        -: 3417:		  break;
        -: 3418:	      if (mbs_cnt == elem_mbs_len)
        -: 3419:		/* Found the entry.  */
        -: 3420:		found = 1;
        -: 3421:	    }
        -: 3422:	  /* Skip the byte sequence of the collating element.  */
        -: 3423:	  idx += elem_mbs_len;
        -: 3424:	  /* Adjust for the alignment.  */
        -: 3425:	  idx = (idx + 3) & ~3;
        -: 3426:	  /* Skip the collation sequence value.  */
        -: 3427:	  idx += sizeof (uint32_t);
        -: 3428:	  /* Skip the wide char sequence of the collating element.  */
        -: 3429:	  idx = idx + sizeof (uint32_t) * (extra[idx] + 1);
        -: 3430:	  /* If we found the entry, return the sequence value.  */
        -: 3431:	  if (found)
        -: 3432:	    return *(uint32_t *) (extra + idx);
        -: 3433:	  /* Skip the collation sequence value.  */
        -: 3434:	  idx += sizeof (uint32_t);
        -: 3435:	}
        -: 3436:    }
        -: 3437:}
        -: 3438:# endif /* _LIBC */
        -: 3439:#endif /* RE_ENABLE_I18N */
        -: 3440:
        -: 3441:/* Check whether the node accepts the byte which is IDX-th
        -: 3442:   byte of the INPUT.  */
        -: 3443:
        -: 3444:static int
function check_node_accept called 630 returned 100% blocks executed 44%
      630: 3445:check_node_accept (preg, node, mctx, idx)
        -: 3446:    const regex_t *preg;
        -: 3447:    const re_token_t *node;
        -: 3448:    const re_match_context_t *mctx;
        -: 3449:    int idx;
        -: 3450:{
        -: 3451:  unsigned char ch;
      630: 3452:  if (node->constraint)
branch  0 taken 0 (fallthrough)
branch  1 taken 630
        -: 3453:    {
        -: 3454:      /* The node has constraints.  Check whether the current context
        -: 3455:	 satisfies the constraints.  */
    #####: 3456:      unsigned int context = re_string_context_at (mctx->input, idx,
    #####: 3457:						   mctx->eflags,
    #####: 3458:						   preg->newline_anchor);
call    0 never executed
    #####: 3459:      if (NOT_SATISFY_NEXT_CONSTRAINT (node->constraint, context))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
    #####: 3460:	return 0;
        -: 3461:    }
      630: 3462:  ch = re_string_byte_at (mctx->input, idx);
      630: 3463:  if (node->type == CHARACTER)
branch  0 taken 305 (fallthrough)
branch  1 taken 325
      305: 3464:    return node->opr.c == ch;
      325: 3465:  else if (node->type == SIMPLE_BRACKET)
branch  0 taken 72 (fallthrough)
branch  1 taken 253
       72: 3466:    return bitset_contain (node->opr.sbcset, ch);
      253: 3467:  else if (node->type == OP_PERIOD)
branch  0 taken 253 (fallthrough)
branch  1 taken 0
     253*: 3468:    return !((ch == '\n' && !(preg->syntax & RE_DOT_NEWLINE))
branch  0 taken 0 (fallthrough)
branch  1 taken 253
branch  2 never executed
branch  3 never executed
branch  4 taken 0 (fallthrough)
branch  5 taken 253
    #####: 3469:	     || (ch == '\0' && (preg->syntax & RE_DOT_NOT_NULL)));
branch  0 never executed
branch  1 never executed
        -: 3470:  else
    #####: 3471:    return 0;
        -: 3472:}
        -: 3473:
        -: 3474:/* Extend the buffers, if the buffers have run out.  */
        -: 3475:
        -: 3476:static reg_errcode_t
function extend_buffers called 4447 returned 100% blocks executed 71%
     4447: 3477:extend_buffers (mctx)
        -: 3478:     re_match_context_t *mctx;
        -: 3479:{
        -: 3480:  reg_errcode_t ret;
     4447: 3481:  re_string_t *pstr = mctx->input;
        -: 3482:
        -: 3483:  /* Double the lengthes of the buffers.  */
     4447: 3484:  ret = re_string_realloc_buffers (pstr, pstr->bufs_len * 2);
call    0 returned 4447
     4447: 3485:  if (BE (ret != REG_NOERROR, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 4447
    #####: 3486:    return ret;
        -: 3487:
     4447: 3488:  if (mctx->state_log != NULL)
branch  0 taken 8 (fallthrough)
branch  1 taken 4439
        -: 3489:    {
        -: 3490:      /* And double the length of state_log.  */
        -: 3491:      re_dfastate_t **new_array;
        8: 3492:      new_array = re_realloc (mctx->state_log, re_dfastate_t *,
        -: 3493:			      pstr->bufs_len * 2);
        8: 3494:      if (BE (new_array == NULL, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 8
    #####: 3495:	return REG_ESPACE;
        8: 3496:      mctx->state_log = new_array;
        -: 3497:    }
        -: 3498:
        -: 3499:  /* Then reconstruct the buffers.  */
     4447: 3500:  if (pstr->icase)
branch  0 taken 0 (fallthrough)
branch  1 taken 4447
        -: 3501:    {
        -: 3502:#ifdef RE_ENABLE_I18N
        -: 3503:      if (MB_CUR_MAX > 1)
        -: 3504:	build_wcs_upper_buffer (pstr);
        -: 3505:      else
        -: 3506:#endif /* RE_ENABLE_I18N  */
    #####: 3507:	build_upper_buffer (pstr);
call    0 never executed
        -: 3508:    }
        -: 3509:  else
        -: 3510:    {
        -: 3511:#ifdef RE_ENABLE_I18N
        -: 3512:      if (MB_CUR_MAX > 1)
        -: 3513:	build_wcs_buffer (pstr);
        -: 3514:      else
        -: 3515:#endif /* RE_ENABLE_I18N  */
        -: 3516:	{
     4447: 3517:	  if (pstr->trans != NULL)
branch  0 taken 0 (fallthrough)
branch  1 taken 4447
    #####: 3518:	    re_string_translate_buffer (pstr);
call    0 never executed
        -: 3519:	  else
     4447: 3520:	    pstr->valid_len = pstr->bufs_len;
        -: 3521:	}
        -: 3522:    }
     4447: 3523:  return REG_NOERROR;
        -: 3524:}
        -: 3525:
        -: 3526:
        -: 3527:/* Functions for matching context.  */
        -: 3528:
        -: 3529:static reg_errcode_t
function match_ctx_init called 47141 returned 100% blocks executed 57%
    47141: 3530:match_ctx_init (mctx, eflags, input, n)
        -: 3531:    re_match_context_t *mctx;
        -: 3532:    int eflags, n;
        -: 3533:    re_string_t *input;
        -: 3534:{
    47141: 3535:  mctx->eflags = eflags;
    47141: 3536:  mctx->input = input;
    47141: 3537:  mctx->match_last = -1;
    47141: 3538:  if (n > 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 47141
        -: 3539:    {
    #####: 3540:      mctx->bkref_ents = re_malloc (struct re_backref_cache_entry, n);
    #####: 3541:      mctx->sub_tops = re_malloc (re_sub_match_top_t *, n);
    #####: 3542:      if (BE (mctx->bkref_ents == NULL || mctx->sub_tops == NULL, 0))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3543:	return REG_ESPACE;
        -: 3544:    }
        -: 3545:  else
    47141: 3546:    mctx->bkref_ents = NULL;
    47141: 3547:  mctx->nbkref_ents = 0;
    47141: 3548:  mctx->abkref_ents = n;
    47141: 3549:  mctx->max_mb_elem_len = 1;
    47141: 3550:  mctx->nsub_tops = 0;
    47141: 3551:  mctx->asub_tops = n;
    47141: 3552:  return REG_NOERROR;
        -: 3553:}
        -: 3554:
        -: 3555:static void
function match_ctx_free called 0 returned 0% blocks executed 0%
    #####: 3556:match_ctx_free (mctx)
        -: 3557:    re_match_context_t *mctx;
        -: 3558:{
        -: 3559:  int st_idx;
    #####: 3560:  for (st_idx = 0; st_idx < mctx->nsub_tops; ++st_idx)
branch  0 never executed
branch  1 never executed
        -: 3561:    {
        -: 3562:      int sl_idx;
    #####: 3563:      re_sub_match_top_t *top = mctx->sub_tops[st_idx];
    #####: 3564:      for (sl_idx = 0; sl_idx < top->nlasts; ++sl_idx)
branch  0 never executed
branch  1 never executed
        -: 3565:	{
    #####: 3566:	  re_sub_match_last_t *last = top->lasts[sl_idx];
    #####: 3567:	  re_free (last->path.array);
    #####: 3568:	  if (last->limits)
branch  0 never executed
branch  1 never executed
    #####: 3569:	    re_node_set_free (last->limits);
    #####: 3570:	  re_free (last);
        -: 3571:	}
    #####: 3572:      re_free (top->lasts);
    #####: 3573:      if (top->path)
branch  0 never executed
branch  1 never executed
        -: 3574:	{
    #####: 3575:	  re_free (top->path->array);
    #####: 3576:	  re_free (top->path);
        -: 3577:	}
    #####: 3578:      if (top->limits)
branch  0 never executed
branch  1 never executed
    #####: 3579:	re_node_set_free (top->limits);
    #####: 3580:      free (top);
        -: 3581:    }
    #####: 3582:  re_free (mctx->sub_tops);
    #####: 3583:  re_free (mctx->bkref_ents);
    #####: 3584:}
        -: 3585:
        -: 3586:/* Add a new backreference entry to the cache.  */
        -: 3587:
        -: 3588:static reg_errcode_t
function match_ctx_add_entry called 0 returned 0% blocks executed 0%
    #####: 3589:match_ctx_add_entry (mctx, node, str_idx, from, to, top, last)
        -: 3590:     re_match_context_t *mctx;
        -: 3591:     int node, str_idx, from, to;
        -: 3592:     re_sub_match_top_t *top;
        -: 3593:     re_sub_match_last_t *last;
        -: 3594:{
        -: 3595:  /* TODO: It can be more efficient.  */
        -: 3596:  int i;
    #####: 3597:  for (i = 0; i < mctx->nbkref_ents; ++i)
branch  0 never executed
branch  1 never executed
        -: 3598:    {
    #####: 3599:      struct re_backref_cache_entry *entry = mctx->bkref_ents + i;
    #####: 3600:      if (entry->node == node && entry->str_idx == str_idx
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3601:	  &&  entry->subexp_from == from &&  entry->subexp_to == to)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3602:	return REG_NOERROR;
        -: 3603:    }
        -: 3604:
    #####: 3605:  if (mctx->nbkref_ents >= mctx->abkref_ents)
branch  0 never executed
branch  1 never executed
        -: 3606:    {
        -: 3607:      struct re_backref_cache_entry* new_entry;
    #####: 3608:      new_entry = re_realloc (mctx->bkref_ents, struct re_backref_cache_entry,
        -: 3609:			      mctx->abkref_ents * 2);
    #####: 3610:      if (BE (new_entry == NULL, 0))
branch  0 never executed
branch  1 never executed
        -: 3611:	{
    #####: 3612:	  re_free (mctx->bkref_ents);
    #####: 3613:	  return REG_ESPACE;
        -: 3614:	}
    #####: 3615:      mctx->bkref_ents = new_entry;
    #####: 3616:      memset (mctx->bkref_ents + mctx->nbkref_ents, '\0',
    #####: 3617:	      sizeof (struct re_backref_cache_entry) * mctx->abkref_ents);
    #####: 3618:      mctx->abkref_ents *= 2;
        -: 3619:    }
    #####: 3620:  mctx->bkref_ents[mctx->nbkref_ents].node = node;
    #####: 3621:  mctx->bkref_ents[mctx->nbkref_ents].str_idx = str_idx;
    #####: 3622:  mctx->bkref_ents[mctx->nbkref_ents].subexp_from = from;
    #####: 3623:  mctx->bkref_ents[mctx->nbkref_ents].subexp_to = to;
    #####: 3624:  mctx->bkref_ents[mctx->nbkref_ents].top = top;
    #####: 3625:  mctx->bkref_ents[mctx->nbkref_ents].last = last;
    #####: 3626:  mctx->bkref_ents[mctx->nbkref_ents++].flag = 0;
    #####: 3627:  if (mctx->max_mb_elem_len < to - from)
branch  0 never executed
branch  1 never executed
    #####: 3628:    mctx->max_mb_elem_len = to - from;
    #####: 3629:  return REG_NOERROR;
        -: 3630:}
        -: 3631:
        -: 3632:static int
function search_cur_bkref_entry called 0 returned 0% blocks executed 0%
    #####: 3633:search_cur_bkref_entry (mctx, str_idx)
        -: 3634:     re_match_context_t *mctx;
        -: 3635:     int str_idx;
        -: 3636:{
        -: 3637:  int left, right, mid;
    #####: 3638:  right = mctx->nbkref_ents;
    #####: 3639:  for (left = 0; left < right;)
branch  0 never executed
branch  1 never executed
        -: 3640:    {
    #####: 3641:      mid = (left + right) / 2;
    #####: 3642:      if (mctx->bkref_ents[mid].str_idx < str_idx)
branch  0 never executed
branch  1 never executed
    #####: 3643:	left = mid + 1;
        -: 3644:      else
    #####: 3645:	right = mid;
        -: 3646:    }
    #####: 3647:  return left;
        -: 3648:}
        -: 3649:
        -: 3650:static void
function match_ctx_clear_flag called 0 returned 0% blocks executed 0%
    #####: 3651:match_ctx_clear_flag (mctx)
        -: 3652:     re_match_context_t *mctx;
        -: 3653:{
        -: 3654:  int i;
    #####: 3655:  for (i = 0; i < mctx->nbkref_ents; ++i)
branch  0 never executed
branch  1 never executed
        -: 3656:    {
    #####: 3657:      mctx->bkref_ents[i].flag = 0;
        -: 3658:    }
    #####: 3659:}
        -: 3660:
        -: 3661:static reg_errcode_t
function match_ctx_add_subtop called 0 returned 0% blocks executed 0%
    #####: 3662:match_ctx_add_subtop (mctx, node, str_idx)
        -: 3663:     re_match_context_t *mctx;
        -: 3664:     int node, str_idx;
        -: 3665:{
        -: 3666:#ifdef DEBUG
        -: 3667:  assert (mctx->sub_tops != NULL);
        -: 3668:  assert (mctx->asub_tops > 0);
        -: 3669:#endif
    #####: 3670:  if (mctx->nsub_tops == mctx->asub_tops)
branch  0 never executed
branch  1 never executed
        -: 3671:    {
    #####: 3672:      mctx->asub_tops *= 2;
    #####: 3673:      mctx->sub_tops = re_realloc (mctx->sub_tops, re_sub_match_top_t *,
        -: 3674:				   mctx->asub_tops);
    #####: 3675:      if (BE (mctx->sub_tops == NULL, 0))
branch  0 never executed
branch  1 never executed
    #####: 3676:	return REG_ESPACE;
        -: 3677:    }
    #####: 3678:  mctx->sub_tops[mctx->nsub_tops] = calloc (1, sizeof (re_sub_match_top_t));
    #####: 3679:  if (mctx->sub_tops[mctx->nsub_tops] == NULL)
branch  0 never executed
branch  1 never executed
    #####: 3680:    return REG_ESPACE;
    #####: 3681:  mctx->sub_tops[mctx->nsub_tops]->node = node;
    #####: 3682:  mctx->sub_tops[mctx->nsub_tops++]->str_idx = str_idx;
    #####: 3683:  return REG_NOERROR;
        -: 3684:}
        -: 3685:
        -: 3686:static re_sub_match_last_t *
function match_ctx_add_sublast called 0 returned 0% blocks executed 0%
    #####: 3687:match_ctx_add_sublast (subtop, node, str_idx)
        -: 3688:     re_sub_match_top_t *subtop;
        -: 3689:     int node, str_idx;
        -: 3690:{
        -: 3691:  re_sub_match_last_t *new_entry;
    #####: 3692:  if (subtop->nlasts == subtop->alasts)
branch  0 never executed
branch  1 never executed
        -: 3693:    {
    #####: 3694:      subtop->alasts = 2 * subtop->alasts + 1;
    #####: 3695:      subtop->lasts = re_realloc (subtop->lasts, re_sub_match_last_t *,
        -: 3696:				  subtop->alasts);
    #####: 3697:      if (BE (subtop->lasts == NULL, 0))
branch  0 never executed
branch  1 never executed
    #####: 3698:	return NULL;
        -: 3699:    }
    #####: 3700:  new_entry = calloc (1, sizeof (re_sub_match_last_t));
    #####: 3701:  subtop->lasts[subtop->nlasts] = new_entry;
    #####: 3702:  new_entry->node = node;
    #####: 3703:  new_entry->str_idx = str_idx;
    #####: 3704:  new_entry->limits = NULL;
    #####: 3705:  ++subtop->nlasts;
    #####: 3706:  return new_entry;
        -: 3707:}
        -: 3708:
        -: 3709:static void
function sift_ctx_init called 30 returned 100% blocks executed 100%
       30: 3710:sift_ctx_init (sctx, sifted_sts, limited_sts, last_node, last_str_idx,
        -: 3711:	       check_subexp)
        -: 3712:    re_sift_context_t *sctx;
        -: 3713:    re_dfastate_t **sifted_sts, **limited_sts;
        -: 3714:    int last_node, last_str_idx, check_subexp;
        -: 3715:{
       30: 3716:  sctx->sifted_states = sifted_sts;
       30: 3717:  sctx->limited_states = limited_sts;
       30: 3718:  sctx->last_node = last_node;
       30: 3719:  sctx->last_str_idx = last_str_idx;
       30: 3720:  sctx->check_subexp = check_subexp;
       30: 3721:  sctx->cur_bkref = -1;
       30: 3722:  sctx->cls_subexp_idx = -1;
       30: 3723:  re_node_set_init_empty (&sctx->limits);
       30: 3724:}
        -: 3725:
        -: 3726:/* This function is optimized to compare for equality only.
        -: 3727:   It also tries to limit the startup time as much as possible.  */
function my_memcmp called 0 returned 0% blocks executed 0%
    #####: 3728:static int my_memcmp (char *s1, char *s2, unsigned int l)
        -: 3729:{
    #####: 3730:  if (BE(l, 1) != 0)
branch  0 never executed
branch  1 never executed
    #####: 3731:    while (BE(*s1 == *s2, 1) && BE(--l, 0) != 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3732:      s1++, s2++;
        -: 3733:
    #####: 3734:  return l;
        -: 3735:}
