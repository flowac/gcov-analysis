        -:    0:Source:sed.c
        -:    0:Graph:sed.gcno
        -:    0:Data:sed.gcda
        -:    0:Runs:370
        -:    1:#define COPYRIGHT_NOTICE "Copyright (C) 2003 Free Software Foundation, Inc."
        -:    2:#define BUG_ADDRESS "bonzini@gnu.org"
        -:    3:
        -:    4:/*  GNU SED, a batch stream editor.
        -:    5:    Copyright (C) 1989,90,91,92,93,94,95,98,99,2002,2003
        -:    6:    Free Software Foundation, Inc.
        -:    7:
        -:    8:    This program is free software; you can redistribute it and/or modify
        -:    9:    it under the terms of the GNU General Public License as published by
        -:   10:    the Free Software Foundation; either version 2, or (at your option)
        -:   11:    any later version.
        -:   12:
        -:   13:    This program is distributed in the hope that it will be useful,
        -:   14:    but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   15:    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   16:    GNU General Public License for more details.
        -:   17:
        -:   18:    You should have received a copy of the GNU General Public License
        -:   19:    along with this program; if not, write to the Free Software
        -:   20:    Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
        -:   21:
        -:   22:/*
        -:   23:  Fix a little non-determinism
        -:   24:  for SIR July 2006, Kyle R. Murphy
        -:   25:*/
        -:   26:#undef stderr
        -:   27:#define stderr stdout
        -:   28:#include "FaultSeeds.h"
        -:   29:
        -:   30:#include "config.h"
        -:   31:
        -:   32:#include <stdio.h>
        -:   33:#ifdef HAVE_STRINGS_H
        -:   34:# include <strings.h>
        -:   35:#else
        -:   36:# include <string.h>
        -:   37:#endif /*HAVE_STRINGS_H*/
        -:   38:#ifdef HAVE_MEMORY_H
        -:   39:# include <memory.h>
        -:   40:#endif
        -:   41:
        -:   42:#ifndef HAVE_STRCHR
        -:   43:# define strchr index
        -:   44:# define strrchr rindex
        -:   45:#endif
        -:   46:
        -:   47:#ifdef HAVE_STDLIB_H
        -:   48:# include <stdlib.h>
        -:   49:#endif
        -:   50:
        -:   51:#ifdef HAVE_SYS_TYPES_H
        -:   52:# include <sys/types.h>
        -:   53:#endif
        -:   54:#ifdef HAVE_LOCALE_H
        -:   55:# include <locale.h>
        -:   56:#endif
        -:   57:#include "getopt.h"
        -:   58:#include "basicdefs.h"
        -:   59:#include "utils.h"
        -:   60:#include "sed.h"
        -:   61:
        -:   62:#ifndef BOOTSTRAP
        -:   63:#ifndef HAVE_STDLIB_H
        -:   64: extern char *getenv P_((const char *));
        -:   65:#endif
        -:   66:#endif
        -:   67:
        -:   68:#ifndef HAVE_STRTOUL
        -:   69:# define ATOI(x)	atoi(x)
        -:   70:#else
        -:   71:# define ATOI(x)	strtoul(x, NULL, 0)
        -:   72:#endif
        -:   73:
        -:   74:int extended_regexp_flags = 0;
        -:   75:
        -:   76:/* If set, fflush(stdout) on every line output. */
        -:   77:flagT unbuffered_output = FALSE;
        -:   78:
        -:   79:/* If set, don't write out the line unless explicitly told to */
        -:   80:flagT no_default_output = FALSE;
        -:   81:
        -:   82:/* If set, reset line counts on every new file. */
        -:   83:flagT separate_files = FALSE;
        -:   84:
        -:   85:/* How do we edit files in-place? (we don't if NULL) */
        -:   86:char *in_place_extension = NULL;
        -:   87:
        -:   88:/* Do we need to be pedantically POSIX compliant? */
        -:   89:flagT POSIXLY_CORRECT;
        -:   90:
        -:   91:/* How long should the `l' command's output line be? */
        -:   92:countT lcmd_out_line_len = 70;
        -:   93:
        -:   94:/* The complete compiled SED program that we are going to run: */
        -:   95:static struct vector *the_program = NULL;
        -:   96:
        -:   97:static void usage P_((int));
        -:   98:static void
function usage called 0 returned 0% blocks executed 0%
    #####:   99:usage(status)
        -:  100:  int status;
        -:  101:{
    #####:  102:  FILE *out = status ? stderr : stdout;
        -:  103:
        -:  104:#ifdef REG_PERL
        -:  105:#define PERL_HELP _("  -R, --regexp-perl\n                 use Perl 5's regular expressions syntax in the script.\n")
        -:  106:#else
        -:  107:#define PERL_HELP ""
        -:  108:#endif
        -:  109:
    #####:  110:  fprintf(out, _("\
call    0 never executed
        -:  111:Usage: %s [OPTION]... {script-only-if-no-other-script} [input-file]...\n\
        -:  112:\n\
        -:  113:  -n, --quiet, --silent\n\
        -:  114:                 suppress automatic printing of pattern space\n\
        -:  115:  -e script, --expression=script\n\
        -:  116:                 add the script to the commands to be executed\n\
        -:  117:  -f script-file, --file=script-file\n\
        -:  118:                 add the contents of script-file to the commands to be executed\n\
        -:  119:  -i[suffix], --in-place[=suffix]\n\
        -:  120:                 edit files in place (makes backup if extension supplied)\n\
        -:  121:  -l N, --line-length=N\n\
        -:  122:                 specify the desired line-wrap length for the `l' command\n\
        -:  123:  -r, --regexp-extended\n\
        -:  124:                 use extended regular expressions in the script.\n%s\
        -:  125:  -s, --separate\n\
        -:  126:                 consider files as separate rather than as a single continuous\n\
        -:  127:                 long stream.\n\
        -:  128:  -u, --unbuffered\n\
        -:  129:                 load minimal amounts of data from the input files and flush\n\
        -:  130:                 the output buffers more often\n\
        -:  131:      --help     display this help and exit\n\
        -:  132:  -V, --version  output version information and exit\n\
        -:  133:\n\
        -:  134:If no -e, --expression, -f, or --file option is given, then the first\n\
        -:  135:non-option argument is taken as the sed script to interpret.  All\n\
        -:  136:remaining arguments are names of input files; if no input files are\n\
        -:  137:specified, then the standard input is read.\n\
        -:  138:\n"), myname, PERL_HELP);
    #####:  139:  fprintf(out, _("E-mail bug reports to: %s .\n\
call    0 never executed
        -:  140:Be sure to include the word ``%s'' somewhere in the ``Subject:'' field.\n"),
        -:  141:	  BUG_ADDRESS, PACKAGE);
        -:  142:
    #####:  143:  ck_fclose (NULL);
call    0 never executed
    #####:  144:  exit (status);
        -:  145:}
        -:  146:
        -:  147:int
function main called 370 returned 0% blocks executed 76%
      370:  148:main(argc, argv)
        -:  149:  int argc;
        -:  150:  char **argv;
        -:  151:{
        -:  152:#ifdef REG_PERL
        -:  153:#define SHORTOPTS "shnrRuVe:f:l:i::"
        -:  154:#else
        -:  155:#define SHORTOPTS "shnruVe:f:l:i::"
        -:  156:#endif
        -:  157:
        -:  158:  static struct option longopts[] = {
        -:  159:    {"regexp-extended", 0, NULL, 'r'},
        -:  160:#ifdef REG_PERL
        -:  161:    {"regexp-perl", 0, NULL, 'R'},
        -:  162:#endif
        -:  163:    {"expression", 1, NULL, 'e'},
        -:  164:    {"file", 1, NULL, 'f'},
        -:  165:    {"in-place", 2, NULL, 'i'},
        -:  166:    {"line-length", 1, NULL, 'l'},
        -:  167:    {"quiet", 0, NULL, 'n'},
        -:  168:    {"silent", 0, NULL, 'n'},
        -:  169:    {"separate", 0, NULL, 's'},
        -:  170:    {"unbuffered", 0, NULL, 'u'},
        -:  171:    {"version", 0, NULL, 'V'},
        -:  172:    {"help", 0, NULL, 'h'},
        -:  173:    {NULL, 0, NULL, 0}
        -:  174:  };
        -:  175:
        -:  176:  int opt;
        -:  177:  int return_code;
        -:  178:
        -:  179:  initialize_main(&argc, &argv);
        -:  180:
        -:  181:#if ENABLE_NLS
        -:  182:#if HAVE_SETLOCALE
        -:  183:  /* Set locale according to user's wishes.  */
        -:  184:  setlocale (LC_ALL, "");
        -:  185:#endif
        -:  186:
        -:  187:  /* Tell program which translations to use and where to find.  */
        -:  188:  bindtextdomain (PACKAGE, LOCALEDIR);
        -:  189:#endif
        -:  190:
      370:  191:  POSIXLY_CORRECT = (getenv("POSIXLY_CORRECT") != NULL);
call    0 returned 370
        -:  192:
        -:  193:  /* If environment variable `COLS' is set, use its value for
        -:  194:     the baseline setting of `lcmd_out_line_len'.  The "-1"
        -:  195:     is to avoid gratuitous auto-line-wrap on ttys.
        -:  196:   */
        -:  197:  {
      370:  198:    const char *p = getenv("COLS");
call    0 returned 370
      370:  199:    if (p)
branch  0 taken 0 (fallthrough)
branch  1 taken 370
        -:  200:      {
    #####:  201:	countT t = ATOI(p);
    #####:  202:	if (1 < t)
branch  0 never executed
branch  1 never executed
    #####:  203:	  lcmd_out_line_len = t-1;
        -:  204:      }
        -:  205:  }
        -:  206:/*
        -:  207:  More non-determinism -- SIR July 2006
        -:  208:  by Kyle R. Murphy
        -:  209:  myname = *argv;
        -:  210:*/
      370:  211:  myname = "Executable";
      751:  212:  while ((opt = getopt_long(argc, argv, SHORTOPTS, longopts, NULL)) != EOF)
call    0 returned 751
branch  1 taken 385
branch  2 taken 366 (fallthrough)
        -:  213:    {
      385:  214:      switch (opt)
branch  0 taken 7
branch  1 taken 27
branch  2 taken 339
branch  3 taken 2
branch  4 taken 2
branch  5 taken 2
branch  6 taken 2
branch  7 taken 2
branch  8 taken 2
branch  9 taken 0
branch 10 taken 0
        -:  215:	{
        7:  216:	case 'n':
        7:  217:	  no_default_output = TRUE;
        7:  218:	  break;
       27:  219:	case 'e':
       27:  220:	  the_program = compile_string(the_program, optarg, strlen(optarg));
call    0 returned 27
       27:  221:	  break;
      339:  222:	case 'f':
      339:  223:	  the_program = compile_file(the_program, optarg);
call    0 returned 337
      337:  224:	  break;
        -:  225:
        2:  226:	case 'i':
        2:  227:	  separate_files = TRUE;
        2:  228:	  if (optarg == NULL)
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        1:  229:	    in_place_extension = "*";
        1:  230:	  else if (strchr(optarg, '*') == NULL)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -:  231:	    {
        1:  232:	      in_place_extension = xmalloc (strlen(optarg) + 2);
call    0 returned 1
        1:  233:	      in_place_extension[0] = '*';
        1:  234:	      strcpy (in_place_extension + 1, optarg);
        -:  235:	    }
        -:  236:	  else
    #####:  237:	    in_place_extension = ck_strdup(optarg);
call    0 never executed
        2:  238:	  break;
        -:  239:
        2:  240:	case 'l':
        2:  241:	  lcmd_out_line_len = ATOI(optarg);
        2:  242:	  break;
        2:  243:	case 'r':
        2:  244:	  if (extended_regexp_flags)
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####:  245:	    usage(4);
call    0 never executed
        2:  246:	  extended_regexp_flags = REG_EXTENDED;
        2:  247:	  break;
        -:  248:
        -:  249:#ifdef REG_PERL
        -:  250:	case 'R':
        -:  251:	  if (extended_regexp_flags)
        -:  252:	    usage(4);
        -:  253:	  extended_regexp_flags = REG_PERL;
        -:  254:	  break;
        -:  255:#endif
        -:  256:
        2:  257:	case 's':
        2:  258:	  separate_files = TRUE;
        2:  259:	  break;
        -:  260:
        2:  261:	case 'u':
        2:  262:	  unbuffered_output = TRUE;
        2:  263:	  break;
        -:  264:
        2:  265:	case 'V':
        -:  266:#ifdef REG_PERL
        -:  267:	  fprintf(stdout, _("super-sed version %s\n"), VERSION);
        -:  268:	  fprintf(stdout, _("based on GNU sed version 3.02.80\n\n"));
        -:  269:#else
        2:  270:	  fprintf(stdout, _("GNU sed version %s\n"), VERSION);
call    0 returned 2
        -:  271:#endif
        2:  272:	  fprintf(stdout, _("%s\n\
call    0 returned 2
        -:  273:This is free software; see the source for copying conditions.  There is NO\n\
        -:  274:warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE,\n\
        -:  275:to the extent permitted by law.\n\
        -:  276:"), COPYRIGHT_NOTICE);
        2:  277:	  ck_fclose (NULL);
call    0 returned 0
    #####:  278:	  exit (0);
call    0 never executed
    #####:  279:	case 'h':
    #####:  280:	  usage(0);
call    0 never executed
    #####:  281:	default:
    #####:  282:	  usage(4);
call    0 never executed
        -:  283:	}
        -:  284:    }
        -:  285:
      366:  286:  if (!the_program)
branch  0 taken 5 (fallthrough)
branch  1 taken 361
        -:  287:    {
        5:  288:      if (optind < argc)
branch  0 taken 5 (fallthrough)
branch  1 taken 0
        -:  289:	{
        5:  290:	  char *arg = argv[optind++];
       5*:  291:	  the_program = compile_string(the_program, arg, strlen(arg));
call    0 returned 0
        -:  292:	}
        -:  293:      else
    #####:  294:	usage(4);
call    0 never executed
        -:  295:    }
      361:  296:  check_final_program(the_program);
call    0 returned 360
        -:  297:
      360:  298:  return_code = process_files(the_program, argv+optind);
call    0 returned 360
        -:  299:
      360:  300:  finish_program(the_program);
call    0 returned 360
      360:  301:  ck_fclose(NULL);
call    0 returned 0
        -:  302:
    #####:  303:  return return_code;
        -:  304:}
        -:  305:/*  GNU SED, a batch stream editor.
        -:  306:    Copyright (C) 1989,90,91,92,93,94,95,98,99,2002,2003
        -:  307:    Free Software Foundation, Inc.
        -:  308:
        -:  309:    This program is free software; you can redistribute it and/or modify
        -:  310:    it under the terms of the GNU General Public License as published by
        -:  311:    the Free Software Foundation; either version 2, or (at your option)
        -:  312:    any later version.
        -:  313:
        -:  314:    This program is distributed in the hope that it will be useful,
        -:  315:    but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:  316:    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:  317:    GNU General Public License for more details.
        -:  318:
        -:  319:    You should have received a copy of the GNU General Public License
        -:  320:    along with this program; if not, write to the Free Software
        -:  321:    Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
        -:  322:
        -:  323:/* compile.c: translate sed source into internal form */
        -:  324:
        -:  325:#include "config.h"
        -:  326:#include <stdio.h>
        -:  327:#include <ctype.h>
        -:  328:
        -:  329:#ifdef HAVE_STRINGS_H
        -:  330:# include <strings.h>
        -:  331:# ifdef HAVE_MEMORY_H
        -:  332:#  include <memory.h>
        -:  333:# endif
        -:  334:#else
        -:  335:# include <string.h>
        -:  336:#endif /* HAVE_STRINGS_H */
        -:  337:
        -:  338:#ifdef HAVE_STDLIB_H
        -:  339:# include <stdlib.h>
        -:  340:#endif
        -:  341:#ifndef EXIT_FAILURE
        -:  342:# define EXIT_FAILURE 1
        -:  343:#endif
        -:  344:
        -:  345:#if defined HAVE_WCTYPE_H && defined HAVE_WCHAR_H && defined HAVE_MBRTOWC
        -:  346:/* We can handle multibyte string.  */
        -:  347:# include <wchar.h>
        -:  348:# include <wctype.h>
        -:  349:# define MBS_SUPPORT
        -:  350:#endif
        -:  351:
        -:  352:#ifdef HAVE_SYS_TYPES_H
        -:  353:# include <sys/types.h>
        -:  354:#endif
        -:  355:#include "obstack.h"
        -:  356:#include "basicdefs.h"
        -:  357:#include "utils.h"
        -:  358:
        -:  359:extern flagT no_default_output;
        -:  360:extern flagT POSIXLY_CORRECT;
        -:  361:
        -:  362:
        -:  363:#define YMAP_LENGTH		256 /*XXX shouldn't this be (UCHAR_MAX+1)?*/
        -:  364:#define VECTOR_ALLOC_INCREMENT	40
        -:  365:
        -:  366:/* let's not confuse text editors that have only dumb bracket-matching... */
        -:  367:#define OPEN_BRACKET	'['
        -:  368:#define CLOSE_BRACKET	']'
        -:  369:#define OPEN_BRACE	'{'
        -:  370:#define CLOSE_BRACE	'}'
        -:  371:
        -:  372:struct prog_info {
        -:  373:  /* When we're reading a script command from a string, `prog.base'
        -:  374:     points to the first character in the string, 'prog.cur' points
        -:  375:     to the current character in the string, and 'prog.end' points
        -:  376:     to the end of the string.  This allows us to compile script
        -:  377:     strings that contain nulls. */
        -:  378:  const unsigned char *base;
        -:  379:  const unsigned char *cur;
        -:  380:  const unsigned char *end;
        -:  381:
        -:  382:  /* This is the current script file.  If it is NULL, we are reading
        -:  383:     from a string stored at `prog.cur' instead.  If both `prog.file'
        -:  384:     and `prog.cur' are NULL, we're in trouble! */
        -:  385:  FILE *file;
        -:  386:};
        -:  387:
        -:  388:/* Information used to give out useful and informative error messages. */
        -:  389:struct error_info {
        -:  390:  /* This is the name of the current script file. */
        -:  391:  const char *name;
        -:  392:
        -:  393:  /* This is the number of the current script line that we're compiling. */
        -:  394:  countT line;
        -:  395:
        -:  396:  /* This is the index of the "-e" expressions on the command line. */
        -:  397:  countT string_expr_count;
        -:  398:};
        -:  399:
        -:  400:
        -:  401:/* Label structure used to resolve GOTO's, labels, and block beginnings. */
        -:  402:struct sed_label {
        -:  403:  countT v_index;		/* index of vector element being referenced */
        -:  404:  char *name;			/* NUL-terminated name of the label */
        -:  405:  struct error_info err_info;	/* track where `{}' blocks start */
        -:  406:  struct sed_label *next;	/* linked list (stack) */
        -:  407:};
        -:  408:
        -:  409:struct special_files {
        -:  410:  char *name;
        -:  411:  FILE **pfp;
        -:  412:};
        -:  413:
        -:  414:FILE *my_stdin, *my_stdout, *my_stderr;
        -:  415:struct special_files special_files[] = {
        -:  416:  { "/dev/stdin", &my_stdin },
        -:  417:  { "/dev/stdout", &my_stdout },
        -:  418:  { "/dev/stdout", &my_stderr },
        -:  419:  { NULL, NULL }
        -:  420:};
        -:  421:
        -:  422:/* This structure tracks files opened by the `w' and `s///w' commands
        -:  423:   so that they may all be closed cleanly at normal program termination.
        -:  424:   Those marked as `special' are not closed. */
        -:  425:struct fp_list {
        -:  426:    char *name;
        -:  427:    int special;
        -:  428:    FILE *fp;
        -:  429:    struct fp_list *link;
        -:  430:  };
        -:  431:
        -:  432:
        -:  433:/* Where we are in the processing of the input. */
        -:  434:static struct prog_info prog;
        -:  435:static struct error_info cur_input;
        -:  436:
        -:  437:/* Information about labels and jumps-to-labels.  This is used to do
        -:  438:   the required backpatching after we have compiled all the scripts. */
        -:  439:static struct sed_label *jumps = NULL;
        -:  440:static struct sed_label *labels = NULL;
        -:  441:
        -:  442:/* We wish to detect #n magic only in the first input argument;
        -:  443:   this flag tracks when we have consumed the first file of input. */
        -:  444:static flagT first_script = TRUE;
        -:  445:
        -:  446:/* Allow for scripts like "sed -e 'i\' -e foo": */
        -:  447:static struct buffer *pending_text = NULL;
        -:  448:static struct text_buf *old_text_buf = NULL;
        -:  449:
        -:  450:/* Information about block start positions.  This is used to backpatch
        -:  451:   block end positions. */
        -:  452:static struct sed_label *blocks = NULL;
        -:  453:
        -:  454:/* Use an obstack for compilation. */
        -:  455:static struct obstack obs;
        -:  456:
        -:  457:/* Various error messages we may want to print */
        -:  458:static const char errors[] =
        -:  459:  "Multiple `!'s\0"
        -:  460:  "Unexpected `,'\0"
        -:  461:  "Cannot use +N or ~N as first address\0"
        -:  462:  "Unmatched `{'\0"
        -:  463:  "Unexpected `}'\0"
        -:  464:  "Extra characters after command\0"
        -:  465:  "Expected \\ after `a', `c' or `i'\0"
        -:  466:  "`}' doesn't want any addresses\0"
        -:  467:  ": doesn't want any addresses\0"
        -:  468:  "Comments don't accept any addresses\0"
        -:  469:  "Missing command\0"
        -:  470:  "Command only uses one address\0"
        -:  471:  "Unterminated address regex\0"
        -:  472:  "Unterminated `s' command\0"
        -:  473:  "Unterminated `y' command\0"
        -:  474:  "Unknown option to `s'\0"
        -:  475:  "multiple `p' options to `s' command\0"
        -:  476:  "multiple `g' options to `s' command\0"
        -:  477:  "multiple number options to `s' command\0"
        -:  478:  "number option to `s' command may not be zero\0"
        -:  479:  "strings for y command are different lengths\0"
        -:  480:  "expected newer version of sed";
        -:  481:
        -:  482:#define BAD_BANG (errors)
        -:  483:#define BAD_COMMA (BAD_BANG + sizeof(N_("Multiple `!'s")))
        -:  484:#define BAD_PLUS (BAD_COMMA + sizeof(N_("Unexpected `,'")))
        -:  485:#define EXCESS_OPEN_BRACE (BAD_PLUS + sizeof(N_("Cannot use +N or ~N as first address")))
        -:  486:#define EXCESS_CLOSE_BRACE (EXCESS_OPEN_BRACE + sizeof(N_("Unmatched `{'")))
        -:  487:#define EXCESS_JUNK (EXCESS_CLOSE_BRACE + sizeof(N_("Unexpected `}'")))
        -:  488:#define EXPECTED_SLASH (EXCESS_JUNK + sizeof(N_("Extra characters after command")))
        -:  489:#define NO_CLOSE_BRACE_ADDR (EXPECTED_SLASH + sizeof(N_("Expected \\ after `a', `c' or `i'")))
        -:  490:#define NO_COLON_ADDR (NO_CLOSE_BRACE_ADDR + sizeof(N_("`}' doesn't want any addresses")))
        -:  491:#define NO_SHARP_ADDR (NO_COLON_ADDR + sizeof(N_(": doesn't want any addresses")))
        -:  492:#define NO_COMMAND (NO_SHARP_ADDR + sizeof(N_("Comments don't accept any addresses")))
        -:  493:#define ONE_ADDR (NO_COMMAND + sizeof(N_("Missing command")))
        -:  494:#define UNTERM_ADDR_RE (ONE_ADDR + sizeof(N_("Command only uses one address")))
        -:  495:#define UNTERM_S_CMD (UNTERM_ADDR_RE + sizeof(N_("Unterminated address regex")))
        -:  496:#define UNTERM_Y_CMD (UNTERM_S_CMD + sizeof(N_("Unterminated `s' command")))
        -:  497:#define UNKNOWN_S_OPT (UNTERM_Y_CMD + sizeof(N_("Unterminated `y' command")))
        -:  498:#define EXCESS_P_OPT (UNKNOWN_S_OPT + sizeof(N_("Unknown option to `s'")))
        -:  499:#define EXCESS_G_OPT (EXCESS_P_OPT + sizeof(N_("multiple `p' options to `s' command")))
        -:  500:#define EXCESS_N_OPT (EXCESS_G_OPT + sizeof(N_("multiple `g' options to `s' command")))
        -:  501:#define ZERO_N_OPT (EXCESS_N_OPT + sizeof(N_("multiple number options to `s' command")))
        -:  502:#define Y_CMD_LEN (ZERO_N_OPT + sizeof(N_("number option to `s' command may not be zero")))
        -:  503:#define ANCIENT_VERSION (Y_CMD_LEN + sizeof(N_("strings for y command are different lengths")))
        -:  504:#define END_ERRORS (ANCIENT_VERSION + sizeof(N_("expected newer version of sed")))
        -:  505:
        -:  506:static struct fp_list *file_read = NULL;
        -:  507:static struct fp_list *file_write = NULL;
        -:  508:
        -:  509:
        -:  510:/* Read the next character from the program.  Return EOF if there isn't
        -:  511:   anything to read.  Keep cur_input.line up to date, so error messages
        -:  512:   can be meaningful. */
        -:  513:static int inchar P_((void));
        -:  514:static int
function inchar called 32614 returned 100% blocks executed 100%
    32614:  515:inchar()
        -:  516:{
    32614:  517:  int ch = EOF;
        -:  518:
    32614:  519:  if (prog.cur)
branch  0 taken 473 (fallthrough)
branch  1 taken 32141
        -:  520:    {
        -:  521:#ifndef FAULTY_F_KRM_1
      473:  522:      if (prog.cur < prog.end)
branch  0 taken 420 (fallthrough)
branch  1 taken 53
        -:  523:#else
        -:  524:      if (prog.cur <= prog.end)
        -:  525:#endif
        -:  526:#ifndef FAULTY_F_KRM_2
      420:  527:	ch = *prog.cur++;
        -:  528:#else
        -:  529:        ch = *(prog.cur+1);
        -:  530:#endif
        -:  531:    }
    32141:  532:  else if (prog.file)
branch  0 taken 32141 (fallthrough)
branch  1 taken 0
        -:  533:    {
    32141:  534:      if (!feof(prog.file))
call    0 returned 32141
branch  1 taken 32141 (fallthrough)
branch  2 taken 0
    32141:  535:	ch = getc(prog.file);
call    0 returned 32141
        -:  536:    }
    32614:  537:  if (ch == '\n')
branch  0 taken 3307 (fallthrough)
branch  1 taken 29307
     3307:  538:    ++cur_input.line;
    32614:  539:  return ch;
        -:  540:}
        -:  541:
        -:  542:/* unget `ch' so the next call to inchar will return it.   */
        -:  543:static void savchar P_((int ch));
        -:  544:static void
function savchar called 572 returned 100% blocks executed 82%
      572:  545:savchar(ch)
        -:  546:  int ch;
        -:  547:{
      572:  548:  if (ch == EOF)
branch  0 taken 0 (fallthrough)
branch  1 taken 572
    #####:  549:    return;
      572:  550:  if (ch == '\n' && cur_input.line > 0)
branch  0 taken 13 (fallthrough)
branch  1 taken 559
branch  2 taken 13 (fallthrough)
branch  3 taken 0
       13:  551:    --cur_input.line;
      572:  552:  if (prog.cur)
branch  0 taken 11 (fallthrough)
branch  1 taken 561
        -:  553:    {
       11:  554:      if (prog.cur <= prog.base || *--prog.cur != ch)
branch  0 taken 11 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 11
    #####:  555:	panic(_("Called savchar() with unexpected pushback (%x)"),
    #####:  556:	      CAST(unsigned char)ch);
call    0 never executed
        -:  557:    }
        -:  558:  else
      561:  559:    ungetc(ch, prog.file);
call    0 returned 561
        -:  560:}
        -:  561:
        -:  562:/* Read the next non-blank character from the program.  */
        -:  563:static int in_nonblank P_((void));
        -:  564:static int
function in_nonblank called 3191 returned 100% blocks executed 100%
     3455:  565:in_nonblank()
        -:  566:{
        -:  567:  int ch;
        -:  568:  do
     3455:  569:    ch = inchar();
call    0 returned 3455
     3455:  570:    while (ISBLANK(ch));
branch  0 taken 262
branch  1 taken 3193 (fallthrough)
branch  2 taken 2
branch  3 taken 3191 (fallthrough)
     3191:  571:  return ch;
        -:  572:}
        -:  573:
        -:  574:/* Read an integer value from the program.  */
        -:  575:static countT in_integer P_((int ch));
        -:  576:static countT
function in_integer called 88 returned 100% blocks executed 100%
       88:  577:in_integer(ch)
        -:  578:  int ch;
        -:  579:{
       88:  580:  countT num = 0;
        -:  581:
      246:  582:  while (ISDIGIT(ch))
branch  0 taken 158
branch  1 taken 88 (fallthrough)
        -:  583:    {
      158:  584:      num = num * 10 + ch - '0';
      158:  585:      ch = inchar();
call    0 returned 158
        -:  586:    }
       88:  587:  savchar(ch);
call    0 returned 88
       88:  588:  return num;
        -:  589:}
        -:  590:
        -:  591:static int add_then_next P_((struct buffer *b, int ch));
        -:  592:static int
function add_then_next called 40 returned 100% blocks executed 100%
       40:  593:add_then_next(b, ch)
        -:  594:  struct buffer *b;
        -:  595:  int ch;
        -:  596:{
       40:  597:  add1_buffer(b, ch);
call    0 returned 40
       40:  598:  return inchar();
call    0 returned 40
        -:  599:}
        -:  600:
        -:  601:static char * convert_number P_((char *, char *, const char *, int, int, int));
        -:  602:static char *
function convert_number called 0 returned 0% blocks executed 0%
    #####:  603:convert_number(result, buf, bufend, base, maxdigits, default_char)
        -:  604:  char *result;
        -:  605:  char *buf;
        -:  606:  const char *bufend;
        -:  607:  int base;
        -:  608:  int maxdigits;
        -:  609:  int default_char;
        -:  610:{
    #####:  611:  int n = 0;
        -:  612:  char *p;
        -:  613:
        -:  614:#ifndef FAULTY_F_KRM_3
    #####:  615:  for (p=buf; p < bufend && maxdigits-- > 0; ++p)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  616:#else
        -:  617:    for (p=buf; p < bufend && --maxdigits > 0; ++p)
        -:  618:#endif
        -:  619:    {
    #####:  620:      int d = -1;
    #####:  621:      switch (*p)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
        -:  622:	{
    #####:  623:	case '0': d = 0x0; break;
    #####:  624:	case '1': d = 0x1; break;
    #####:  625:	case '2': d = 0x2; break;
    #####:  626:	case '3': d = 0x3; break;
    #####:  627:	case '4': d = 0x4; break;
    #####:  628:	case '5': d = 0x5; break;
    #####:  629:	case '6': d = 0x6; break;
    #####:  630:	case '7': d = 0x7; break;
    #####:  631:	case '8': d = 0x8; break;
    #####:  632:	case '9': d = 0x9; break;
    #####:  633:	case 'A': case 'a': d = 0xa; break;
    #####:  634:	case 'B': case 'b': d = 0xb; break;
    #####:  635:	case 'C': case 'c': d = 0xc; break;
    #####:  636:	case 'D': case 'd': d = 0xd; break;
    #####:  637:	case 'E': case 'e': d = 0xe; break;
    #####:  638:	case 'F': case 'f': d = 0xf; break;
        -:  639:	}
    #####:  640:      if (d < 0 || base <= d)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  641:	break;
    #####:  642:      n = n * base + d;
        -:  643:    }
    #####:  644:  if (p == buf)
branch  0 never executed
branch  1 never executed
    #####:  645:    *result = default_char;
        -:  646:  else
    #####:  647:    *result = n;
    #####:  648:  return p;
        -:  649:}
        -:  650:
        -:  651:
        -:  652:/* Read in a filename for a `r', `w', or `s///w' command. */
        -:  653:static struct buffer *read_filename P_((void));
        -:  654:static struct buffer *
function read_filename called 231 returned 100% blocks executed 100%
      231:  655:read_filename()
        -:  656:{
        -:  657:  struct buffer *b;
        -:  658:  int ch;
        -:  659:
      231:  660:  b = init_buffer();
call    0 returned 231
      231:  661:  ch = in_nonblank();
call    0 returned 231
     3109:  662:  while (ch != EOF && ch != '\n')
branch  0 taken 3102 (fallthrough)
branch  1 taken 7
branch  2 taken 2878
branch  3 taken 224 (fallthrough)
        -:  663:    {
        -:  664:#if 0 /*XXX ZZZ 1998-09-12 kpp: added, then had second thoughts*/
        -:  665:      if (!POSIXLY_CORRECT)
        -:  666:	if (ch == ';' || ch == CLOSE_BRACE || ch == '#')
        -:  667:	  {
        -:  668:	    savchar(ch);
        -:  669:	    break;
        -:  670:	  }
        -:  671:#endif
     2878:  672:      add1_buffer(b, ch);
call    0 returned 2878
     2878:  673:      ch = inchar();
call    0 returned 2878
        -:  674:    }
      231:  675:  add1_buffer(b, '\0');
call    0 returned 231
      231:  676:  return b;
        -:  677:}
        -:  678:
        -:  679:static FILE *get_openfile P_((struct fp_list **file_ptrs, char *mode, flagT fail));
        -:  680:static FILE *
function get_openfile called 197 returned 100% blocks executed 81%
      197:  681:get_openfile(file_ptrs, mode, fail)
        -:  682:     struct fp_list **file_ptrs;
        -:  683:     char *mode;
        -:  684:     flagT fail;
        -:  685:{
        -:  686:  struct buffer *b;
        -:  687:  char *file_name;
        -:  688:  struct fp_list *p;
        -:  689:  int is_stderr;
        -:  690:
      197:  691:  b = read_filename();
call    0 returned 197
      197:  692:  file_name = get_buffer(b);
call    0 returned 197
      242:  693:  for (p=*file_ptrs; p; p=p->link)
branch  0 taken 45
branch  1 taken 197 (fallthrough)
       45:  694:    if (strcmp(p->name, file_name) == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 45
    #####:  695:      break;
        -:  696:
      197:  697:  if (!p)
branch  0 taken 197 (fallthrough)
branch  1 taken 0
        -:  698:    {
      197:  699:      FILE *fp = NULL;
      197:  700:      if (!POSIXLY_CORRECT)
branch  0 taken 197 (fallthrough)
branch  1 taken 0
        -:  701:	{
        -:  702:	  /* Check whether it is a special file (stdin, stdout or stderr) */
      197:  703:	  struct special_files *special = special_files;
        -:  704:		  
        -:  705:	  /* std* sometimes are not constants, so they
        -:  706:	     cannot be used in the initializer for special_files */
      197:  707:	  my_stdin = stdin; my_stdout = stdout; my_stderr = stderr;
      788:  708:	  for (special = special_files; special->name; special++)
branch  0 taken 591
branch  1 taken 197 (fallthrough)
      591:  709:	    if (strcmp(special->name, file_name) == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 591
        -:  710:	      {
    #####:  711:		fp = *special->pfp;
    #####:  712:		break;
        -:  713:	      }
        -:  714:	}
        -:  715:
     197*:  716:      p = OB_MALLOC(&obs, 1, struct fp_list);
branch  0 taken 0 (fallthrough)
branch  1 taken 197
call    2 never executed
branch  3 taken 0 (fallthrough)
branch  4 taken 197
branch  5 taken 0 (fallthrough)
branch  6 taken 197
      197:  717:      p->name = ck_strdup(file_name);
call    0 returned 197
      197:  718:      p->special = fp != NULL;
      197:  719:      if (!fp)
branch  0 taken 197 (fallthrough)
branch  1 taken 0
      197:  720:	fp = ck_fopen(p->name, mode, fail);
call    0 returned 197
      197:  721:      p->fp = fp;
      197:  722:      p->link = *file_ptrs;
      197:  723:      *file_ptrs = p;
        -:  724:    }
      197:  725:  free_buffer(b);
call    0 returned 197
      197:  726:  return p->fp;
        -:  727:}
        -:  728:
        -:  729:
        -:  730:static struct sed_cmd *next_cmd_entry P_((struct vector **vectorp));
        -:  731:static struct sed_cmd *
function next_cmd_entry called 2539 returned 100% blocks executed 100%
     2539:  732:next_cmd_entry(vectorp)
        -:  733:  struct vector **vectorp;
        -:  734:{
        -:  735:  struct sed_cmd *cmd;
        -:  736:  struct vector *v;
        -:  737:
     2539:  738:  v = *vectorp;
     2539:  739:  if (v->v_length == v->v_allocated)
branch  0 taken 365 (fallthrough)
branch  1 taken 2174
        -:  740:    {
      365:  741:      v->v_allocated += VECTOR_ALLOC_INCREMENT;
      365:  742:      v->v = REALLOC(v->v, v->v_allocated, struct sed_cmd);
call    0 returned 365
        -:  743:    }
        -:  744:
     2539:  745:  cmd = v->v + v->v_length;
     2539:  746:  cmd->a1 = NULL;
     2539:  747:  cmd->a2 = NULL;
     2539:  748:  cmd->a1_matched = FALSE;
     2539:  749:  cmd->addr_bang = FALSE;
     2539:  750:  cmd->cmd = '\0';	/* something invalid, to catch bugs early */
        -:  751:
     2539:  752:  *vectorp  = v;
     2539:  753:  return cmd;
        -:  754:}
        -:  755:
        -:  756:static int snarf_char_class P_((struct buffer *b));
        -:  757:static int
function snarf_char_class called 9 returned 100% blocks executed 37%
        9:  758:snarf_char_class(b)
        -:  759:  struct buffer *b;
        -:  760:{
        -:  761:  int ch;
        -:  762:
        9:  763:  ch = inchar();
call    0 returned 9
        9:  764:  if (ch == '^')
branch  0 taken 1 (fallthrough)
branch  1 taken 8
        1:  765:    ch = add_then_next(b, ch);
call    0 returned 1
        9:  766:  if (ch == CLOSE_BRACKET)
branch  0 taken 0 (fallthrough)
branch  1 taken 9
    #####:  767:    ch = add_then_next(b, ch);
call    0 never executed
       48:  768:  while (ch != EOF && ch != '\n' && ch != CLOSE_BRACKET)
branch  0 taken 48 (fallthrough)
branch  1 taken 0
branch  2 taken 48 (fallthrough)
branch  3 taken 0
branch  4 taken 39
branch  5 taken 9 (fallthrough)
        -:  769:    {
       39:  770:      if (ch == OPEN_BRACKET)
branch  0 taken 0 (fallthrough)
branch  1 taken 39
        -:  771:	{
        -:  772:	  int prev;
    #####:  773:	  int delim = ch = add_then_next(b, ch);
call    0 never executed
        -:  774:
    #####:  775:	  if (delim != '.'  &&  delim != ':'  &&  delim != '=')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  776:	    continue; /* bypass the add_then_next() call at bottom of loop */
    #####:  777:	  for (prev=ch=add_then_next(b, ch);
call    0 never executed
    #####:  778:		  !(ch==CLOSE_BRACKET && prev==delim); ch=add_then_next(b, ch))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  779:	    {
    #####:  780:	      if (ch == EOF || ch == '\n')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  781:		return ch;
    #####:  782:	      prev = ch;
call    0 never executed
        -:  783:	    }
        -:  784:	}
        -:  785:#ifndef REG_PERL
       39:  786:      else if (ch == '\\')
branch  0 taken 0 (fallthrough)
branch  1 taken 39
        -:  787:	{
    #####:  788:	  ch = inchar();
call    0 never executed
    #####:  789:	  if (ch == EOF)
branch  0 never executed
branch  1 never executed
    #####:  790:	    break;
    #####:  791:	  if (ch != 'n' && ch != '\n')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  792:	    {
    #####:  793:	      add1_buffer(b, '\\');
call    0 never executed
    #####:  794:	      continue; /* bypass the add_then_next() call at bottom of loop */
        -:  795:	    }
    #####:  796:	  ch = '\n';
        -:  797:	}
        -:  798:#endif
       39:  799:      ch = add_then_next(b, ch);
call    0 returned 39
        -:  800:    }
        -:  801:
        9:  802:  return ch;
        -:  803:}
        -:  804:
        -:  805:static struct buffer *match_slash P_((int slash, flagT regex, flagT keep_back));
        -:  806:static struct buffer *
function match_slash called 912 returned 100% blocks executed 81%
      912:  807:match_slash(slash, regex, keep_backwhack)
        -:  808:  int slash;
        -:  809:  flagT regex;
        -:  810:  flagT keep_backwhack;
        -:  811:{
        -:  812:  struct buffer *b;
        -:  813:  int ch;
        -:  814:
      912:  815:  b = init_buffer();
call    0 returned 912
        -:  816:#ifndef FAULTY_F_KRM_4
     5406:  817:  while ((ch = inchar()) != EOF && ch != '\n' && ch != slash)
call    0 returned 5406
branch  1 taken 5406 (fallthrough)
branch  2 taken 0
branch  3 taken 5406 (fallthrough)
branch  4 taken 0
branch  5 taken 4494
branch  6 taken 912 (fallthrough)
        -:  818:#else
        -:  819:    while ((ch = inchar()) != '\n' && ch != slash)
        -:  820:#endif
        -:  821:    {
     4494:  822:      if (ch == '\\')
branch  0 taken 393 (fallthrough)
branch  1 taken 4101
        -:  823:	{
      393:  824:	  ch = inchar();
call    0 returned 393
      393:  825:	  if (ch == EOF)
branch  0 taken 0 (fallthrough)
branch  1 taken 393
    #####:  826:	    break;
        -:  827:#ifndef REG_PERL
      393:  828:	  else if (ch == 'n' && regex)
branch  0 taken 12 (fallthrough)
branch  1 taken 381
branch  2 taken 12 (fallthrough)
branch  3 taken 0
       12:  829:	    ch = '\n';
        -:  830:#endif
      381:  831:	  else if (ch != '\n' && (ch != slash || keep_backwhack))
branch  0 taken 381 (fallthrough)
branch  1 taken 0
branch  2 taken 4 (fallthrough)
branch  3 taken 377
branch  4 taken 4 (fallthrough)
branch  5 taken 0
      381:  832:	    add1_buffer(b, '\\');
call    0 returned 381
        -:  833:	}
     4101:  834:      else if (ch == OPEN_BRACKET && regex)
branch  0 taken 29 (fallthrough)
branch  1 taken 4072
branch  2 taken 9 (fallthrough)
branch  3 taken 20
        -:  835:	{
        9:  836:	  add1_buffer(b, ch);
call    0 returned 9
        9:  837:	  ch = snarf_char_class(b);
call    0 returned 9
        9:  838:	  if (ch != CLOSE_BRACKET)
branch  0 taken 0 (fallthrough)
branch  1 taken 9
    #####:  839:	    break;
        -:  840:	}
     4494:  841:      add1_buffer(b, ch);
call    0 returned 4494
        -:  842:    }
      912:  843:  if (ch == slash)
branch  0 taken 912 (fallthrough)
branch  1 taken 0
      912:  844:    return b;
        -:  845:
    #####:  846:  if (ch == '\n')
branch  0 never executed
branch  1 never executed
    #####:  847:    savchar(ch);	/* for proper line number in error report */
call    0 never executed
    #####:  848:  free_buffer(b);
call    0 never executed
    #####:  849:  return NULL;
        -:  850:}
        -:  851:
        -:  852:static flagT mark_subst_opts P_((struct subst *cmd));
        -:  853:static flagT
function mark_subst_opts called 245 returned 100% blocks executed 43%
      245:  854:mark_subst_opts(cmd)
        -:  855:  struct subst *cmd;
        -:  856:{
      245:  857:  int flags = 0;
        -:  858:  int ch;
        -:  859:
      245:  860:  cmd->global = FALSE;
      245:  861:  cmd->print = FALSE;
      245:  862:  cmd->eval = FALSE;
      245:  863:  cmd->numb = FALSE;
      245:  864:  cmd->fp = NULL;
        -:  865:
        -:  866:  for (;;)
      567:  867:    switch ( (ch = in_nonblank()) )
call    0 returned 567
branch  1 taken 0
branch  2 taken 0
branch  3 taken 0
branch  4 taken 112
branch  5 taken 210
branch  6 taken 152
branch  7 taken 0
branch  8 taken 0
branch  9 taken 93
branch 10 taken 0
branch 11 taken 0
        -:  868:      {
    #####:  869:      case 'i':	/* GNU extension */
        -:  870:      case 'I':	/* GNU extension */
    #####:  871:	flags |= REG_ICASE;
    #####:  872:	break;
        -:  873:
        -:  874:#ifdef REG_PERL
        -:  875:      case 's':	/* GNU extension */
        -:  876:      case 'S':	/* GNU extension */
        -:  877:	if (extended_regexp_flags & REG_PERL)
        -:  878:	  flags |= REG_DOTALL;
        -:  879:	break;
        -:  880:
        -:  881:      case 'x':	/* GNU extension */
        -:  882:      case 'X':	/* GNU extension */
        -:  883:	if (extended_regexp_flags & REG_PERL)
        -:  884:	  flags |= REG_EXTENDED;
        -:  885:	break;
        -:  886:#endif
        -:  887:
    #####:  888:      case 'm':	/* GNU extension */
        -:  889:      case 'M':	/* GNU extension */
    #####:  890:	flags |= REG_NEWLINE;
    #####:  891:	break;
        -:  892:
    #####:  893:      case 'e':
    #####:  894:	cmd->eval = TRUE;
    #####:  895:	break;
        -:  896:
      112:  897:      case 'p':
      112:  898:	if (cmd->print)
branch  0 taken 0 (fallthrough)
branch  1 taken 112
    #####:  899:	  bad_prog(_(EXCESS_P_OPT));
call    0 never executed
      112:  900:	cmd->print |= (TRUE << cmd->eval); /* 1=before eval, 2=after */
      112:  901:	break;
        -:  902:
      210:  903:      case 'g':
      210:  904:	if (cmd->global)
branch  0 taken 0 (fallthrough)
branch  1 taken 210
    #####:  905:	  bad_prog(_(EXCESS_G_OPT));
call    0 never executed
      210:  906:	cmd->global = TRUE;
      210:  907:	break;
        -:  908:
      152:  909:      case 'w':
      152:  910:	cmd->fp = get_openfile(&file_write, "w", TRUE);
call    0 returned 152
      152:  911:	return flags;
        -:  912:
    #####:  913:      case '0': case '1': case '2': case '3': case '4':
        -:  914:      case '5': case '6': case '7': case '8': case '9':
    #####:  915:	if (cmd->numb)
branch  0 never executed
branch  1 never executed
    #####:  916:	  bad_prog(_(EXCESS_N_OPT));
call    0 never executed
    #####:  917:	cmd->numb = in_integer(ch);
call    0 never executed
    #####:  918:	if (!cmd->numb)
branch  0 never executed
branch  1 never executed
    #####:  919:	  bad_prog(_(ZERO_N_OPT));
call    0 never executed
    #####:  920:	break;
        -:  921:
    #####:  922:      case CLOSE_BRACE:
        -:  923:      case '#':
    #####:  924:	savchar(ch);
call    0 never executed
        -:  925:	/* Fall Through */
       93:  926:      case EOF:
        -:  927:      case '\n':
        -:  928:      case ';':
       93:  929:	return flags;
        -:  930:
    #####:  931:      case '\r':
    #####:  932:	if (inchar() == '\n')
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  933:	  return flags;
        -:  934:	/* FALLTHROUGH */
        -:  935:
        -:  936:      default:
    #####:  937:	bad_prog(_(UNKNOWN_S_OPT));
call    0 never executed
        -:  938:	/*NOTREACHED*/
        -:  939:      }
        -:  940:}
        -:  941:
        -:  942:
        -:  943:/* read in a label for a `:', `b', or `t' command */
        -:  944:static char *read_label P_((void));
        -:  945:static char *
function read_label called 13 returned 100% blocks executed 100%
       13:  946:read_label()
        -:  947:{
        -:  948:  struct buffer *b;
        -:  949:  int ch;
        -:  950:  char *ret;
        -:  951:
       13:  952:  b = init_buffer();
call    0 returned 13
       13:  953:  ch = in_nonblank();
call    0 returned 13
        -:  954:
       53:  955:  while (ch != EOF && ch != '\n'
branch  0 taken 27 (fallthrough)
branch  1 taken 13
       67:  956:	 && !ISBLANK(ch) && ch != ';' && ch != CLOSE_BRACE && ch != '#')
branch  0 taken 40 (fallthrough)
branch  1 taken 0
branch  2 taken 27 (fallthrough)
branch  3 taken 0
branch  4 taken 27 (fallthrough)
branch  5 taken 0
branch  6 taken 27 (fallthrough)
branch  7 taken 0
branch  8 taken 27 (fallthrough)
branch  9 taken 0
branch 10 taken 27
branch 11 taken 0 (fallthrough)
        -:  957:    {
       27:  958:      add1_buffer(b, ch);
call    0 returned 27
       27:  959:      ch = inchar();
call    0 returned 27
        -:  960:    }
       13:  961:  savchar(ch);
call    0 returned 13
       13:  962:  add1_buffer(b, '\0');
call    0 returned 13
       13:  963:  ret = ck_strdup(get_buffer(b));
call    0 returned 13
call    1 returned 13
       13:  964:  free_buffer(b);
call    0 returned 13
       13:  965:  return ret;
        -:  966:}
        -:  967:
        -:  968:/* Store a label (or label reference) created by a `:', `b', or `t'
        -:  969:   command so that the jump to/from the label can be backpatched after
        -:  970:   compilation is complete, or a reference created by a `{' to be
        -:  971:   backpatched when the corresponding `}' is found.  */
        -:  972:static struct sed_label *setup_label
        -:  973:  P_((struct sed_label *, countT, char *, const struct error_info *));
        -:  974:static struct sed_label *
function setup_label called 343 returned 100% blocks executed 70%
      343:  975:setup_label(list, idx, name, err_info)
        -:  976:  struct sed_label *list;
        -:  977:  countT idx;
        -:  978:  char *name;
        -:  979:  const struct error_info *err_info;
        -:  980:{
     343*:  981:  struct sed_label *ret = OB_MALLOC(&obs, 1, struct sed_label);
branch  0 taken 0 (fallthrough)
branch  1 taken 343
call    2 never executed
branch  3 taken 0 (fallthrough)
branch  4 taken 343
branch  5 taken 0 (fallthrough)
branch  6 taken 343
      343:  982:  ret->v_index = idx;
      343:  983:  ret->name = name;
      343:  984:  if (err_info)
branch  0 taken 330 (fallthrough)
branch  1 taken 13
      330:  985:    MEMCPY(&ret->err_info, err_info, sizeof ret->err_info);
      343:  986:  ret->next = list;
        -:  987:#ifndef FAULTY_F_KRM_5  
      343:  988:  return ret;
        -:  989:#else
        -:  990:  return ++ret;
        -:  991:#endif
        -:  992:}
        -:  993:
        -:  994:static struct sed_label *release_label P_((struct sed_label *list_head));
        -:  995:static struct sed_label *
function release_label called 342 returned 100% blocks executed 80%
      342:  996:release_label(list_head)
        -:  997:  struct sed_label *list_head;
        -:  998:{
        -:  999:  struct sed_label *ret;
      342: 1000:  if (!list_head)
branch  0 taken 0 (fallthrough)
branch  1 taken 342
    #####: 1001:    return NULL;
      342: 1002:  ret = list_head->next;
        -: 1003:
      342: 1004:  FREE(list_head->name);
call    0 returned 342
        -: 1005:
        -: 1006:#if 0
        -: 1007:  /* We use obstacks */
        -: 1008:  FREE(list_head);
        -: 1009:#endif
      342: 1010:  return ret;
        -: 1011:}
        -: 1012:
        -: 1013:static struct replacement *new_replacement P_((char *, size_t,
        -: 1014:					       enum replacement_types));
        -: 1015:static struct replacement *
function new_replacement called 253 returned 100% blocks executed 62%
      253: 1016:new_replacement(text, length, type)
        -: 1017:  char *text;
        -: 1018:  size_t length;
        -: 1019:  enum replacement_types type;
        -: 1020:{
     253*: 1021:  struct replacement *r = OB_MALLOC(&obs, 1, struct replacement);
branch  0 taken 0 (fallthrough)
branch  1 taken 253
call    2 never executed
branch  3 taken 0 (fallthrough)
branch  4 taken 253
branch  5 taken 0 (fallthrough)
branch  6 taken 253
        -: 1022:
      253: 1023:  r->prefix = text;
      253: 1024:  r->prefix_length = length;
      253: 1025:  r->subst_id = -1;
      253: 1026:  r->repl_type = type;
        -: 1027:  /* r-> next = NULL; */
      253: 1028:  return r;
        -: 1029:}
        -: 1030:
        -: 1031:static void setup_replacement P_((struct subst *, const char *, size_t));
        -: 1032:static void
function setup_replacement called 245 returned 100% blocks executed 69%
      245: 1033:setup_replacement(sub, text, length)
        -: 1034:     struct subst *sub;
        -: 1035:     const char *text;
        -: 1036:     size_t length;
        -: 1037:{
        -: 1038:  char *base;
        -: 1039:  char *p;
        -: 1040:  char *text_end;
      245: 1041:  enum replacement_types repl_type = repl_asis, save_type = repl_asis;
        -: 1042:  struct replacement root;
        -: 1043:  struct replacement *tail;
        -: 1044:
      245: 1045:  sub->max_id = 0;
      245: 1046:  base = MEMDUP(text, length, char);
call    0 returned 245
      245: 1047:  length = normalize_text(base, length);
call    0 returned 245
        -: 1048:
      245: 1049:  text_end = base + length;
      245: 1050:  tail = &root;
        -: 1051:#ifndef FAULTY_F_KRM_6
        -: 1052:  #ifndef FAULTY_F_KRM_7
     1770: 1053:  for (p=base; p<text_end; ++p)
branch  0 taken 1525
branch  1 taken 245 (fallthrough)
        -: 1054:  #else
        -: 1055:  for (p=base; p<text_end; p++)
        -: 1056:  #endif
        -: 1057:#else
        -: 1058:  for (p=base; p<=text_end; ++p)
        -: 1059:#endif
        -: 1060:    {
     1525: 1061:      if (*p == '\\')
branch  0 taken 42 (fallthrough)
branch  1 taken 1483
        -: 1062:	{
        -: 1063:	  /* Preceding the backslash may be some literal text: */
       42: 1064:	  tail = tail->next =
       42: 1065:	    new_replacement(base, CAST(size_t)(p - base), repl_type);
call    0 returned 42
        -: 1066:
       42: 1067:	  repl_type = save_type;
        -: 1068:
        -: 1069:	  /* Skip the backslash and look for a numeric back-reference: */
       42: 1070:	  ++p;
       42: 1071:	  if (p<text_end)
branch  0 taken 42 (fallthrough)
branch  1 taken 0
       42: 1072:	    switch (*p)
branch  0 taken 0
branch  1 taken 0
branch  2 taken 0
branch  3 taken 0
branch  4 taken 0
branch  5 taken 0
branch  6 taken 42
        -: 1073:	      {
    #####: 1074:	      case '0': case '1': case '2': case '3': case '4': 
        -: 1075:	      case '5': case '6': case '7': case '8': case '9': 
    #####: 1076:		tail->subst_id = *p - '0';
    #####: 1077:		if (sub->max_id < tail->subst_id)
branch  0 never executed
branch  1 never executed
    #####: 1078:		  sub->max_id = tail->subst_id;
    #####: 1079:		break;
        -: 1080:
    #####: 1081:	      case 'L':
    #####: 1082:		repl_type = repl_lowercase;
    #####: 1083:		save_type = repl_lowercase;
    #####: 1084:		break;
        -: 1085:
    #####: 1086:	      case 'U':
    #####: 1087:		repl_type = repl_uppercase;
    #####: 1088:		save_type = repl_uppercase;
    #####: 1089:		break;
        -: 1090:		
    #####: 1091:	      case 'E':
    #####: 1092:		repl_type = repl_asis;
    #####: 1093:		save_type = repl_asis;
    #####: 1094:		break;
        -: 1095:
    #####: 1096:	      case 'l':
    #####: 1097:		save_type = repl_type;
    #####: 1098:		repl_type |= repl_lowercase_first;
    #####: 1099:		break;
        -: 1100:
    #####: 1101:	      case 'u':
    #####: 1102:		save_type = repl_type;
    #####: 1103:		repl_type |= repl_uppercase_first;
    #####: 1104:		break;
        -: 1105:		
       42: 1106:	      default:
       42: 1107:		p[-1] = *p;
       42: 1108:		++tail->prefix_length;
        -: 1109:	      }
        -: 1110:
       42: 1111:	  base = p + 1;
        -: 1112:	}
     1483: 1113:      else if (*p == '&')
branch  0 taken 17 (fallthrough)
branch  1 taken 1466
        -: 1114:	{
        -: 1115:	  /* Preceding the ampersand may be some literal text: */
       17: 1116:	  tail = tail->next =
       17: 1117:	    new_replacement(base, CAST(size_t)(p - base), repl_type);
call    0 returned 17
        -: 1118:
       17: 1119:	  repl_type = save_type;
       17: 1120:	  tail->subst_id = 0;
       17: 1121:	  base = p + 1;
        -: 1122:	}
        -: 1123:  }
        -: 1124:  /* There may be some trailing literal text: */
      245: 1125:  if (base < text_end)
branch  0 taken 194 (fallthrough)
branch  1 taken 51
      194: 1126:    tail = tail->next =
      194: 1127:      new_replacement(base, CAST(size_t)(text_end - base), repl_type);
call    0 returned 194
        -: 1128:
      245: 1129:  tail->next = NULL;
      245: 1130:  sub->replacement = root.next;
      245: 1131:}
        -: 1132:
        -: 1133:static void read_text P_((struct text_buf *buf, int leadin_ch));
        -: 1134:static void
function read_text called 106 returned 100% blocks executed 79%
      106: 1135:read_text(buf, leadin_ch)
        -: 1136:  struct text_buf *buf;
        -: 1137:  int leadin_ch;
        -: 1138:{
        -: 1139:  int ch;
        -: 1140:
        -: 1141:  /* Should we start afresh (as opposed to continue a partial text)? */
      106: 1142:  if (buf)
branch  0 taken 106 (fallthrough)
branch  1 taken 0
        -: 1143:    {
      106: 1144:      if (pending_text)
branch  0 taken 0 (fallthrough)
branch  1 taken 106
    #####: 1145:	free_buffer(pending_text);
call    0 never executed
      106: 1146:      pending_text = init_buffer();
call    0 returned 106
      106: 1147:      buf->text = NULL;
      106: 1148:      buf->text_length = 0;
      106: 1149:      old_text_buf = buf;
        -: 1150:    }
        -: 1151:  /* assert(old_text_buf != NULL); */
        -: 1152:
      106: 1153:  if (leadin_ch == EOF)
branch  0 taken 0 (fallthrough)
branch  1 taken 106
    #####: 1154:    return;
        -: 1155:#ifndef NO_INPUT_INDENT
      106: 1156:  if (leadin_ch != '\n')
branch  0 taken 0 (fallthrough)
branch  1 taken 106
    #####: 1157:    add1_buffer(pending_text, leadin_ch);
call    0 never executed
      106: 1158:  ch = inchar();
call    0 returned 106
        -: 1159:#else /*NO_INPUT_INDENT*/
        -: 1160:  if (leadin_ch == '\n')
        -: 1161:    ch = in_nonblank();
        -: 1162:  else
        -: 1163:    {
        -: 1164:      add1_buffer(pending_text, leadin_ch);
        -: 1165:      ch = inchar();
        -: 1166:    }
        -: 1167:#endif /*NO_INPUT_INDENT*/
        -: 1168:
     2629: 1169:  while (ch!=EOF && ch!='\n')
branch  0 taken 2629 (fallthrough)
branch  1 taken 0
branch  2 taken 2523
branch  3 taken 106 (fallthrough)
        -: 1170:    {
     2523: 1171:      if (ch == '\\')
branch  0 taken 14 (fallthrough)
branch  1 taken 2509
       14: 1172:	ch = inchar();
call    0 returned 14
     2523: 1173:      if (ch == EOF)
branch  0 taken 0 (fallthrough)
branch  1 taken 2523
        -: 1174:	{
    #####: 1175:	  add1_buffer(pending_text, '\n');
call    0 never executed
    #####: 1176:	  return;
        -: 1177:	}
     2523: 1178:      add1_buffer(pending_text, ch);
call    0 returned 2523
        -: 1179:#ifdef NO_INPUT_INDENT
        -: 1180:      if (ch == '\n')
        -: 1181:	ch = in_nonblank();
        -: 1182:      else
        -: 1183:#endif /*NO_INPUT_INDENT*/
     2523: 1184:	ch = inchar();
call    0 returned 2523
        -: 1185:    }
      106: 1186:  add1_buffer(pending_text, '\n');
call    0 returned 106
        -: 1187:
      106: 1188:  if (!buf)
branch  0 taken 0 (fallthrough)
branch  1 taken 106
    #####: 1189:    buf = old_text_buf;
      106: 1190:  buf->text_length = size_buffer(pending_text);
call    0 returned 106
      106: 1191:  buf->text = MEMDUP(get_buffer(pending_text), buf->text_length, char);
call    0 returned 106
call    1 returned 106
      106: 1192:  free_buffer(pending_text);
call    0 returned 106
      106: 1193:  pending_text = NULL;
        -: 1194:}
        -: 1195:
        -: 1196:
        -: 1197:/* Try to read an address for a sed command.  If it succeeds,
        -: 1198:   return non-zero and store the resulting address in `*addr'.
        -: 1199:   If the input doesn't look like an address read nothing
        -: 1200:   and return zero.  */
        -: 1201:static flagT compile_address P_((struct addr *addr, int ch));
        -: 1202:static flagT
function compile_address called 2584 returned 100% blocks executed 60%
     2584: 1203:compile_address(addr, ch)
        -: 1204:  struct addr *addr;
        -: 1205:  int ch;
        -: 1206:{
     2584: 1207:  addr->addr_type = addr_is_null;
     2584: 1208:  addr->addr_step = 0;
     2584: 1209:  addr->addr_number = ~(countT)0;  /* extremely unlikely to ever match */
     2584: 1210:  addr->addr_regex = NULL;
        -: 1211:
     2584: 1212:  if (ch == '/' || ch == '\\')
branch  0 taken 2201 (fallthrough)
branch  1 taken 383
branch  2 taken 0 (fallthrough)
branch  3 taken 2201
        -: 1213:    {
      383: 1214:      int flags = 0;
        -: 1215:      struct buffer *b;
      383: 1216:      addr->addr_type = addr_is_regex;
      383: 1217:      if (ch == '\\')
branch  0 taken 0 (fallthrough)
branch  1 taken 383
    #####: 1218:	ch = inchar();
call    0 never executed
      383: 1219:      if ( !(b = match_slash(ch, TRUE, TRUE)) )
call    0 returned 383
branch  1 taken 0 (fallthrough)
branch  2 taken 383
    #####: 1220:	bad_prog(_(UNTERM_ADDR_RE));
call    0 never executed
        -: 1221:
        -: 1222:      for(;;)
        -: 1223:	{
     383*: 1224:	  ch = in_nonblank();
call    0 returned 383
      383: 1225:          switch(ch)
branch  0 taken 0
branch  1 taken 0
branch  2 taken 383
        -: 1226:	    {
    #####: 1227:	    case 'I':	/* GNU extension */
    #####: 1228:	      flags |= REG_ICASE;
    #####: 1229:	      break;
        -: 1230:
        -: 1231:#ifdef REG_PERL
        -: 1232:	    case 'S':	/* GNU extension */
        -: 1233:	      if (extended_regexp_flags & REG_PERL)
        -: 1234:		flags |= REG_DOTALL;
        -: 1235:	      break;
        -: 1236:
        -: 1237:	    case 'X':	/* GNU extension */
        -: 1238:	      if (extended_regexp_flags & REG_PERL)
        -: 1239:		flags |= REG_EXTENDED;
        -: 1240:	      break;
        -: 1241:#endif
        -: 1242:
    #####: 1243:	    case 'M':	/* GNU extension */
    #####: 1244:	      flags |= REG_NEWLINE;
    #####: 1245:	      break;
        -: 1246:
      383: 1247:	    default:
      383: 1248:	      savchar (ch);
call    0 returned 383
      383: 1249:	      addr->addr_regex = compile_regex (b, flags, 0);
call    0 returned 383
      383: 1250:	      free_buffer(b);
call    0 returned 383
      383: 1251:	      return TRUE;
        -: 1252:	    }
        -: 1253:	}
        -: 1254:    }
     2201: 1255:  else if (ISDIGIT(ch))
branch  0 taken 88 (fallthrough)
branch  1 taken 2113
        -: 1256:    {
        -: 1257:#ifndef FAULTY_F_KRM_8
       88: 1258:      addr->addr_number = in_integer(ch);
call    0 returned 88
        -: 1259:#else
        -: 1260:      addr->addr_number = inchar();
        -: 1261:#endif
       88: 1262:      addr->addr_type = addr_is_num;
       88: 1263:      ch = in_nonblank();
call    0 returned 88
        -: 1264:
       88: 1265:      if (ch != '~')
branch  0 taken 88 (fallthrough)
branch  1 taken 0
        -: 1266:	{
       88: 1267:	  savchar(ch);
call    0 returned 88
        -: 1268:	}
        -: 1269:      else
        -: 1270:	{
    #####: 1271:	  countT step = in_integer(in_nonblank()); 
call    0 never executed
call    1 never executed
    #####: 1272:	  if (step > 0)
branch  0 never executed
branch  1 never executed
        -: 1273:	    {
    #####: 1274:	      addr->addr_step = step;
    #####: 1275:	      addr->addr_type = addr_is_num_mod;
        -: 1276:	    }
        -: 1277:	}
        -: 1278:    }
     2113: 1279:  else if (ch == '+' || ch == '~')
branch  0 taken 2113 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 2113
        -: 1280:    {
    #####: 1281:      addr->addr_step = in_integer(in_nonblank());
call    0 never executed
call    1 never executed
    #####: 1282:      if (addr->addr_step==0)
branch  0 never executed
branch  1 never executed
        -: 1283:	; /* default to addr_is_null; forces matching to stop on next line */
    #####: 1284:      else if (ch == '+')
branch  0 never executed
branch  1 never executed
    #####: 1285:	addr->addr_type = addr_is_step;
        -: 1286:      else
    #####: 1287:	addr->addr_type = addr_is_step_mod;
        -: 1288:    }
     2113: 1289:  else if (ch == '$')
branch  0 taken 13 (fallthrough)
branch  1 taken 2100
        -: 1290:    {
       13: 1291:      addr->addr_type = addr_is_last;
        -: 1292:    }
        -: 1293:  else
     2100: 1294:    return FALSE;
        -: 1295:
      101: 1296:  return TRUE;
        -: 1297:}
        -: 1298:
        -: 1299:/* Read a program (or a subprogram within `{' `}' pairs) in and store
        -: 1300:   the compiled form in `*vector'.  Return a pointer to the new vector.  */
        -: 1301:static struct vector *compile_program P_((struct vector *));
        -: 1302:static struct vector *
function compile_program called 369 returned 99% blocks executed 72%
      369: 1303:compile_program(vector)
        -: 1304:  struct vector *vector;
        -: 1305:{
        -: 1306:  struct sed_cmd *cur_cmd;
        -: 1307:  struct buffer *b;
        -: 1308:  int ch;
        -: 1309:
      369: 1310:  if (!vector)
branch  0 taken 366 (fallthrough)
branch  1 taken 3
        -: 1311:    {
      366: 1312:      vector = MALLOC(1, struct vector);
call    0 returned 366
      366: 1313:      vector->v = NULL;
      366: 1314:      vector->v_allocated = 0;
      366: 1315:      vector->v_length = 0;
        -: 1316:
      366: 1317:      obstack_init (&obs);
call    0 returned 366
        -: 1318:    }
      369: 1319:  if (pending_text)
branch  0 taken 0 (fallthrough)
branch  1 taken 369
    #####: 1320:    read_text(NULL, '\n');
call    0 never executed
        -: 1321:
        -: 1322:  for (;;)
     2534: 1323:    {
        -: 1324:      struct addr a;
        -: 1325:
    10609: 1326:      while ((ch=inchar()) == ';' || ISSPACE(ch))
call    0 returned 10609
branch  1 taken 0
branch  2 taken 10609 (fallthrough)
branch  3 taken 7706
branch  4 taken 2903 (fallthrough)
        -: 1327:	;
     2903: 1328:      if (ch == EOF)
branch  0 taken 364 (fallthrough)
branch  1 taken 2539
      364: 1329:	break;
        -: 1330:
     2539: 1331:      cur_cmd = next_cmd_entry(&vector);
call    0 returned 2539
     2539: 1332:      if (compile_address(&a, ch))
call    0 returned 2539
branch  1 taken 439 (fallthrough)
branch  2 taken 2100
        -: 1333:	{
      439: 1334:	  if (a.addr_type == addr_is_step
branch  0 taken 439 (fallthrough)
branch  1 taken 0
      439: 1335:	      || a.addr_type == addr_is_step_mod)
branch  0 taken 0 (fallthrough)
branch  1 taken 439
    #####: 1336:	    bad_prog(_(BAD_PLUS));
call    0 never executed
        -: 1337:
      439: 1338:	  cur_cmd->a1 = MEMDUP(&a, 1, struct addr);
call    0 returned 439
      439: 1339:	  ch = in_nonblank();
call    0 returned 439
      439: 1340:	  if (ch == ',')
branch  0 taken 45 (fallthrough)
branch  1 taken 394
        -: 1341:	    {
       45: 1342:	      if (!compile_address(&a, in_nonblank()))
call    0 returned 45
call    1 returned 45
branch  2 taken 0 (fallthrough)
branch  3 taken 45
    #####: 1343:		bad_prog(_(BAD_COMMA));
call    0 never executed
       45: 1344:	      if (a.addr_type == addr_is_num)
branch  0 taken 21 (fallthrough)
branch  1 taken 24
       21: 1345:		a.addr_type = addr_is_num2;
       45: 1346:	      cur_cmd->a2 = MEMDUP(&a, 1, struct addr);
call    0 returned 45
       45: 1347:	      ch = in_nonblank();
call    0 returned 45
       45: 1348:	      if ((cur_cmd->a1->addr_type == addr_is_num
branch  0 taken 19 (fallthrough)
branch  1 taken 26
       19: 1349:		   || cur_cmd->a1->addr_type == addr_is_num_mod)
branch  0 taken 0 (fallthrough)
branch  1 taken 19
       26: 1350:	      	  && cur_cmd->a1->addr_number == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 26
    #####: 1351:		cur_cmd->a1_matched = TRUE;
        -: 1352:	    }
        -: 1353:	}
     2539: 1354:      if (ch == '!')
branch  0 taken 20 (fallthrough)
branch  1 taken 2519
        -: 1355:	{
       20: 1356:	  cur_cmd->addr_bang = TRUE;
       20: 1357:	  ch = in_nonblank();
call    0 returned 20
       20: 1358:	  if (ch == '!')
branch  0 taken 0 (fallthrough)
branch  1 taken 20
    #####: 1359:	    bad_prog(_(BAD_BANG));
call    0 never executed
        -: 1360:	}
        -: 1361:
     2539: 1362:      cur_cmd->cmd = ch;
    2539*: 1363:      switch (ch)
branch  0 taken 507
branch  1 taken 0
branch  2 taken 330
branch  3 taken 329
branch  4 taken 0
branch  5 taken 70
branch  6 taken 36
branch  7 taken 4
branch  8 taken 9
branch  9 taken 35
branch 10 taken 40
branch 11 taken 2
branch 12 taken 809
branch 13 taken 34
branch 14 taken 0
branch 15 taken 45
branch 16 taken 245
branch 17 taken 39
branch 18 taken 0
branch 19 taken 5
        -: 1364:	{
      507: 1365:	case '#':
      507: 1366:	  if (cur_cmd->a1)
branch  0 taken 0 (fallthrough)
branch  1 taken 507
    #####: 1367:	    bad_prog(_(NO_SHARP_ADDR));
call    0 never executed
      507: 1368:	  ch = inchar();
call    0 returned 507
      507: 1369:	  if (ch=='n' && first_script && cur_input.line < 2)
branch  0 taken 211 (fallthrough)
branch  1 taken 296
branch  2 taken 211 (fallthrough)
branch  3 taken 0
branch  4 taken 211 (fallthrough)
branch  5 taken 0
     211*: 1370:	    if (   (prog.base && prog.cur==2+prog.base)
branch  0 taken 0 (fallthrough)
branch  1 taken 211
branch  2 never executed
branch  3 never executed
      211: 1371:		|| (prog.file && !prog.base && 2==ftell(prog.file)))
branch  0 taken 211 (fallthrough)
branch  1 taken 0
branch  2 taken 211 (fallthrough)
branch  3 taken 0
call    4 returned 211
branch  5 taken 211 (fallthrough)
branch  6 taken 0
      211: 1372:	      no_default_output = TRUE;
     6278: 1373:	  while (ch != EOF && ch != '\n')
branch  0 taken 6278 (fallthrough)
branch  1 taken 0
branch  2 taken 5771
branch  3 taken 507 (fallthrough)
     5771: 1374:	    ch = inchar();
call    0 returned 5771
      507: 1375:	  continue;	/* restart the for (;;) loop */
        -: 1376:
    #####: 1377:	case 'v':
        -: 1378:          /* This is an extension.  Programs needing GNU sed might start
        -: 1379:           * with a `v' command so that other seds will stop.
        -: 1380:           * We compare the version ignore it.
        -: 1381:           */
        -: 1382:          {
    #####: 1383:            char *version = read_label ();
call    0 never executed
        -: 1384:            char *compared_version;
    #####: 1385:            compared_version = (*version == '\0') ? "4.0" : version;
branch  0 never executed
branch  1 never executed
        -: 1386:            
        -: 1387:	    /* Removed by Kyle R. Murphy - July 2006 */	    
        -: 1388:	    /* 
        -: 1389:	    if (strverscmp (compared_version, SED_FEATURE_VERSION) > 0)
        -: 1390:              bad_prog(_(ANCIENT_VERSION));
        -: 1391:	    */
        -: 1392:
    #####: 1393:            free (version);
    #####: 1394:	    POSIXLY_CORRECT = 0;
        -: 1395:          }
    #####: 1396:	  continue;
        -: 1397:
      330: 1398:	case '{':
      330: 1399:	  blocks = setup_label(blocks, vector->v_length, NULL, &cur_input);
call    0 returned 330
      330: 1400:	  cur_cmd->addr_bang = !cur_cmd->addr_bang;
      330: 1401:	  break;
        -: 1402:
      329: 1403:	case '}':
      329: 1404:	  if (!blocks)
branch  0 taken 0 (fallthrough)
branch  1 taken 329
    #####: 1405:	    bad_prog(_(EXCESS_CLOSE_BRACE));
call    0 never executed
        -: 1406:#ifndef FAULTY_F_KRM_9
      329: 1407:	  if (cur_cmd->a1)
branch  0 taken 0 (fallthrough)
branch  1 taken 329
    #####: 1408:	    bad_prog(_(NO_CLOSE_BRACE_ADDR));
call    0 never executed
        -: 1409:#else
        -: 1410:#endif
      329: 1411:	  ch = in_nonblank();
call    0 returned 329
      329: 1412:	  if (ch == CLOSE_BRACE || ch == '#')
branch  0 taken 329 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 329
    #####: 1413:	    savchar(ch);
call    0 never executed
     329*: 1414:	  else if (ch != EOF && ch != '\n' && ch != ';')
branch  0 taken 329 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 329
branch  4 never executed
branch  5 never executed
    #####: 1415:	    bad_prog(_(EXCESS_JUNK));
call    0 never executed
        -: 1416:
      329: 1417:	  vector->v[blocks->v_index].x.jump_index = vector->v_length;
      329: 1418:	  blocks = release_label(blocks);	/* done with this entry */
call    0 returned 329
      329: 1419:	  break;
        -: 1420:
    #####: 1421:	case 'e':
    #####: 1422:	  ch = in_nonblank();
call    0 never executed
    #####: 1423:	  if (ch == EOF || ch == '\n')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1424:	    {
    #####: 1425:	      cur_cmd->x.cmd_txt.text_length = 0;
    #####: 1426:	      break;
        -: 1427:	    }
        -: 1428:	  else
    #####: 1429:	    goto read_text_to_slash;
        -: 1430:
       70: 1431:	case 'a':
        -: 1432:	case 'i':
      70*: 1433:	  if (POSIXLY_CORRECT && cur_cmd->a2)
branch  0 taken 0 (fallthrough)
branch  1 taken 70
branch  2 never executed
branch  3 never executed
    #####: 1434:	    bad_prog(_(ONE_ADDR));
call    0 never executed
        -: 1435:	  /* Fall Through */
        -: 1436:
        -: 1437:	case 'c':
      106: 1438:	  ch = in_nonblank();
call    0 returned 106
        -: 1439:
      106: 1440:	read_text_to_slash:
      106: 1441:	  if (ch == EOF)
branch  0 taken 0 (fallthrough)
branch  1 taken 106
    #####: 1442:	    bad_prog(_(EXPECTED_SLASH));
call    0 never executed
        -: 1443:	      
      106: 1444:	  if (ch == '\\')
branch  0 taken 106 (fallthrough)
branch  1 taken 0
      106: 1445:	    ch = inchar();
call    0 returned 106
        -: 1446:	  else
        -: 1447:	    {
    #####: 1448:	      savchar(ch);
call    0 never executed
    #####: 1449:	      ch = '\n';
        -: 1450:	    }
        -: 1451:
      106: 1452:	  read_text(&cur_cmd->x.cmd_txt, ch);
call    0 returned 106
      106: 1453:	  break;
        -: 1454:
        4: 1455:	case ':':
        4: 1456:	  if (cur_cmd->a1)
branch  0 taken 0 (fallthrough)
branch  1 taken 4
    #####: 1457:	    bad_prog(_(NO_COLON_ADDR));
call    0 never executed
        4: 1458:	  labels = setup_label(labels, vector->v_length, read_label(), NULL);
call    0 returned 4
call    1 returned 4
        4: 1459:	  break;
        -: 1460:	
        9: 1461:	case 'b':
        -: 1462:	case 't':
        -: 1463:	case 'T':
        9: 1464:	  jumps = setup_label(jumps, vector->v_length, read_label(), NULL);
call    0 returned 9
call    1 returned 9
        9: 1465:	  break;
        -: 1466:
       35: 1467:	case 'q':
        -: 1468:	case 'Q':
       35: 1469:	  if (cur_cmd->a2)
branch  0 taken 0 (fallthrough)
branch  1 taken 35
    #####: 1470:	    bad_prog(_(ONE_ADDR));
call    0 never executed
        -: 1471:	  /* Fall through */
        -: 1472:
        -: 1473:	case 'l':
        -: 1474:	case 'L':
      75*: 1475:	  if (POSIXLY_CORRECT && cur_cmd->a2)
branch  0 taken 0 (fallthrough)
branch  1 taken 75
branch  2 never executed
branch  3 never executed
    #####: 1476:	    bad_prog(_(ONE_ADDR));
call    0 never executed
        -: 1477:
       75: 1478:	  ch = in_nonblank();
call    0 returned 75
       75: 1479:	  if (ISDIGIT(ch)) 
branch  0 taken 0 (fallthrough)
branch  1 taken 75
        -: 1480:	    {
    #####: 1481:	      cur_cmd->x.int_arg = in_integer(ch);
call    0 never executed
    #####: 1482:	      ch = in_nonblank();
call    0 never executed
        -: 1483:	    }
        -: 1484:	  else
       75: 1485:	    cur_cmd->x.int_arg = -1;
        -: 1486:
       75: 1487:	  if (ch == CLOSE_BRACE || ch == '#')
branch  0 taken 75 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 75
    #####: 1488:	    savchar(ch);
call    0 never executed
       75: 1489:	  else if (ch != EOF && ch != '\n' && ch != ';')
branch  0 taken 73 (fallthrough)
branch  1 taken 2
branch  2 taken 4 (fallthrough)
branch  3 taken 69
branch  4 taken 0 (fallthrough)
branch  5 taken 4
    #####: 1490:	    bad_prog(_(EXCESS_JUNK));
call    0 never executed
        -: 1491:
       75: 1492:	  break;
        -: 1493:
        2: 1494:	case '=':
       2*: 1495:	  if (POSIXLY_CORRECT && cur_cmd->a2)
branch  0 taken 0 (fallthrough)
branch  1 taken 2
branch  2 never executed
branch  3 never executed
    #####: 1496:	    bad_prog(_(ONE_ADDR));
call    0 never executed
        -: 1497:	  /* Fall Through */
        -: 1498:	case 'd':
        -: 1499:	case 'D':
        -: 1500:	case 'g':
        -: 1501:	case 'G':
        -: 1502:	case 'h':
        -: 1503:	case 'H':
        -: 1504:	case 'n':
        -: 1505:	case 'N':
        -: 1506:	case 'p':
        -: 1507:	case 'P':
        -: 1508:	case 'x':
      811: 1509:	  ch = in_nonblank();
call    0 returned 811
      811: 1510:	  if (ch == CLOSE_BRACE || ch == '#')
branch  0 taken 811 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 811
    #####: 1511:	    savchar(ch);
call    0 never executed
      811: 1512:	  else if (ch != EOF && ch != '\n' && ch != ';')
branch  0 taken 806 (fallthrough)
branch  1 taken 5
branch  2 taken 73 (fallthrough)
branch  3 taken 733
branch  4 taken 0 (fallthrough)
branch  5 taken 73
    #####: 1513:	    bad_prog(_(EXCESS_JUNK));
call    0 never executed
      811: 1514:	  break;
        -: 1515:
       34: 1516:	case 'r':
      34*: 1517:	  if (POSIXLY_CORRECT && cur_cmd->a2)
branch  0 taken 0 (fallthrough)
branch  1 taken 34
branch  2 never executed
branch  3 never executed
    #####: 1518:	    bad_prog(_(ONE_ADDR));
call    0 never executed
       34: 1519:	  b = read_filename();
call    0 returned 34
       34: 1520:	  cur_cmd->x.fname = ck_strdup(get_buffer(b));
call    0 returned 34
call    1 returned 34
       34: 1521:	  free_buffer(b);
call    0 returned 34
       34: 1522:	  break;
        -: 1523:
    #####: 1524:        case 'R':
    #####: 1525:	  cur_cmd->x.fp = get_openfile(&file_read, "r", FALSE);
call    0 never executed
    #####: 1526:	  break;
        -: 1527:
       45: 1528:	case 'w':
        -: 1529:        case 'W':
       45: 1530:	  cur_cmd->x.fp = get_openfile(&file_write, "w", TRUE);
call    0 returned 45
       45: 1531:	  break;
        -: 1532:
      245: 1533:	case 's':
        -: 1534:	  {
        -: 1535:	    struct buffer *b2;
        -: 1536:	    int flags;
        -: 1537:	    int slash;
        -: 1538:
      245: 1539:	    slash = inchar();
call    0 returned 245
      245: 1540:	    if ( !(b  = match_slash(slash, TRUE, TRUE)) )
call    0 returned 245
branch  1 taken 0 (fallthrough)
branch  2 taken 245
    #####: 1541:	      bad_prog(_(UNTERM_S_CMD));
call    0 never executed
      245: 1542:	    if ( !(b2 = match_slash(slash, FALSE, TRUE)) )
call    0 returned 245
branch  1 taken 0 (fallthrough)
branch  2 taken 245
    #####: 1543:	      bad_prog(_(UNTERM_S_CMD));
call    0 never executed
        -: 1544:
     245*: 1545:	    cur_cmd->x.cmd_subst = OB_MALLOC(&obs, 1, struct subst);
branch  0 taken 0 (fallthrough)
branch  1 taken 245
call    2 never executed
branch  3 taken 0 (fallthrough)
branch  4 taken 245
branch  5 taken 0 (fallthrough)
branch  6 taken 245
      490: 1546:	    setup_replacement(cur_cmd->x.cmd_subst,
call    0 returned 245
call    1 returned 245
      245: 1547:			      get_buffer(b2), size_buffer(b2));
call    0 returned 245
      245: 1548:	    free_buffer(b2);
call    0 returned 245
        -: 1549:
      245: 1550:	    flags = mark_subst_opts(cur_cmd->x.cmd_subst);
call    0 returned 245
      490: 1551:	    cur_cmd->x.cmd_subst->regx =
      245: 1552:	      compile_regex(b, flags, cur_cmd->x.cmd_subst->max_id);
call    0 returned 245
      245: 1553:	    free_buffer(b);
call    0 returned 245
        -: 1554:	  }
      245: 1555:	  break;
        -: 1556:
       39: 1557:	case 'y':
        -: 1558:	  {
        -: 1559:	    unsigned char *ustring;
        -: 1560:	    size_t len;
        -: 1561:	    int slash;
        -: 1562:
        -: 1563:#if defined MBS_SUPPORT && !defined (REG_PERL)
        -: 1564:	    if (MB_CUR_MAX == 1)
        -: 1565:#endif
        -: 1566:	      {
      39*: 1567:	        ustring = OB_MALLOC(&obs, YMAP_LENGTH, unsigned char);
branch  0 taken 0 (fallthrough)
branch  1 taken 39
call    2 never executed
branch  3 taken 0 (fallthrough)
branch  4 taken 39
branch  5 taken 0 (fallthrough)
branch  6 taken 39
    10023: 1568:	        for (len = 0; len < YMAP_LENGTH; len++)
branch  0 taken 9984
branch  1 taken 39 (fallthrough)
     9984: 1569:	          ustring[len] = len;
       39: 1570:	        cur_cmd->x.translate = ustring;
        -: 1571:	      }
        -: 1572:
       39: 1573:	    slash = inchar();
call    0 returned 39
       39: 1574:	    if ( !(b = match_slash(slash, FALSE, FALSE)) )
call    0 returned 39
branch  1 taken 0 (fallthrough)
branch  2 taken 39
    #####: 1575:	      bad_prog(_(UNTERM_Y_CMD));
call    0 never executed
        -: 1576:
        -: 1577:#if defined MBS_SUPPORT && !defined (REG_PERL)
        -: 1578:            if (MB_CUR_MAX > 1)
        -: 1579:	      {
        -: 1580:                int i, j, idx, src_char_num, len = size_buffer(b);
        -: 1581:                size_t *src_lens = MALLOC(len, size_t);
        -: 1582:                char *src_buf, *dest_buf, **trans_pairs;
        -: 1583:                size_t mbclen;
        -: 1584:                mbstate_t cur_stat;
        -: 1585:	        struct buffer *b2;
        -: 1586:
        -: 1587:                /* Enumerate how many character the source buffer has.  */
        -: 1588:                memset(&cur_stat, 0, sizeof(mbstate_t));
        -: 1589:                src_buf = get_buffer(b);
        -: 1590:                for (i = 0, j = 0; i < len;)
        -: 1591:                  {
        -: 1592:                    mbclen = mbrlen(src_buf + i, len - i, &cur_stat);
        -: 1593:                    /* An invalid sequence, or a truncated multibyte character.
        -: 1594:                       We treat it as a singlebyte character.  */
        -: 1595:                    if (mbclen == (size_t) -1 || mbclen == (size_t) -2
        -: 1596:                        || mbclen == 0)
        -: 1597:                      mbclen = 1;
        -: 1598:                    src_lens[j++] = mbclen;
        -: 1599:                    i += mbclen;
        -: 1600:                  }
        -: 1601:                src_char_num = j;
        -: 1602:
        -: 1603:                memset(&cur_stat, 0, sizeof(mbstate_t));
        -: 1604:                if ( !(b2 = match_slash(slash, FALSE, FALSE)) )
        -: 1605: 		  bad_prog(_(UNTERM_Y_CMD));
        -: 1606:                dest_buf = get_buffer(b2);
        -: 1607:                idx = 0;
        -: 1608:                len = size_buffer(b2);
        -: 1609:
        -: 1610:                /* trans_pairs = {src(0), dest(0), src(1), dest(1), ..., NULL}
        -: 1611:                     src(i) : pointer to i-th source character.
        -: 1612:                     dest(i) : pointer to i-th destination character.
        -: 1613:                     NULL : terminator */
        -: 1614:                trans_pairs = MALLOC(2 * src_char_num + 1, char*);
        -: 1615:                cur_cmd->x.translatemb = trans_pairs;
        -: 1616:                for (i = 0; i < src_char_num; i++)
        -: 1617:                  {
        -: 1618:                    if (idx >= len)
        -: 1619:                      bad_prog(_(Y_CMD_LEN));
        -: 1620:
        -: 1621:                    /* Set the i-th source character.  */
        -: 1622:                    trans_pairs[2 * i] = MALLOC(src_lens[i] + 1, char);
        -: 1623:                    strncpy(trans_pairs[2 * i], src_buf, src_lens[i]);
        -: 1624:                    trans_pairs[2 * i][src_lens[i]] = '\0';
        -: 1625:                    src_buf += src_lens[i]; /* Forward to next character.  */
        -: 1626:
        -: 1627:                    /* Fetch the i-th destination character.  */
        -: 1628:                    mbclen = mbrlen(dest_buf + idx, len - idx, &cur_stat);
        -: 1629:                    /* An invalid sequence, or a truncated multibyte character.
        -: 1630:                       We treat it as a singlebyte character.  */
        -: 1631:                    if (mbclen == (size_t) -1 || mbclen == (size_t) -2
        -: 1632:                        || mbclen == 0)
        -: 1633:                      mbclen = 1;
        -: 1634:
        -: 1635:                    /* Set the i-th destination character.  */
        -: 1636:                    trans_pairs[2 * i + 1] = MALLOC(mbclen + 1, char);
        -: 1637:                    strncpy(trans_pairs[2 * i + 1], dest_buf + idx, mbclen);
        -: 1638:                    trans_pairs[2 * i + 1][mbclen] = '\0';
        -: 1639:                    idx += mbclen; /* Forward to next character.  */
        -: 1640:                  }
        -: 1641:                trans_pairs[2 * i] = NULL;
        -: 1642:                if (idx != len)
        -: 1643:                  bad_prog(_(Y_CMD_LEN));
        -: 1644:                free_buffer(b);
        -: 1645:                free_buffer(b2);
        -: 1646:              }
        -: 1647:            else
        -: 1648:#endif
        -: 1649:              {
       39: 1650:                ustring = CAST(unsigned char *)get_buffer(b);
call    0 returned 39
      328: 1651:                for (len = size_buffer(b); len; --len)
call    0 returned 39
branch  1 taken 289
branch  2 taken 39 (fallthrough)
        -: 1652:                  {
      289: 1653:                    ch = inchar();
call    0 returned 289
      289: 1654:                    if (ch == slash)
branch  0 taken 0 (fallthrough)
branch  1 taken 289
    #####: 1655:                      bad_prog(_(Y_CMD_LEN));
call    0 never executed
      289: 1656:                    if (ch == '\n')
branch  0 taken 0 (fallthrough)
branch  1 taken 289
    #####: 1657:                      bad_prog(UNTERM_Y_CMD);
call    0 never executed
      289: 1658:                    if (ch == '\\')
branch  0 taken 0 (fallthrough)
branch  1 taken 289
    #####: 1659:                      ch = inchar();
call    0 never executed
      289: 1660:                    if (ch == EOF)
branch  0 taken 0 (fallthrough)
branch  1 taken 289
    #####: 1661:                      bad_prog(UNTERM_Y_CMD);
call    0 never executed
      289: 1662:                    cur_cmd->x.translate[*ustring++] = ch;
        -: 1663:                  }
       39: 1664:                free_buffer(b);
call    0 returned 39
        -: 1665:
       39: 1666:                if (inchar() != slash)
call    0 returned 39
branch  1 taken 0 (fallthrough)
branch  2 taken 39
    #####: 1667:		  bad_prog(_(Y_CMD_LEN));
call    0 never executed
       39: 1668:                else if ((ch = in_nonblank()) != EOF && ch != '\n' && ch != ';')
call    0 returned 39
branch  1 taken 39 (fallthrough)
branch  2 taken 0
branch  3 taken 2 (fallthrough)
branch  4 taken 37
branch  5 taken 0 (fallthrough)
branch  6 taken 2
    #####: 1669:                  bad_prog(_(EXCESS_JUNK));
call    0 never executed
        -: 1670:	      }
        -: 1671:	  }
       39: 1672:	break;
        -: 1673:
    #####: 1674:	case EOF:
    #####: 1675:	  bad_prog(_(NO_COMMAND));
call    0 never executed
        -: 1676:	  /*NOTREACHED*/
        5: 1677:	default:
        -: 1678:	  {
        5: 1679:	    const char *msg = _("Unknown command:");
        5: 1680:	    char *unknown_cmd = xmalloc(strlen(msg) + 5);
call    0 returned 5
        5: 1681:	    sprintf(unknown_cmd, "%s `%c'", msg, ch);
        5: 1682:	    bad_prog(unknown_cmd);
call    0 returned 0
        -: 1683:	    /*NOTREACHED*/
        -: 1684:	  }
        -: 1685:	}
        -: 1686:
        -: 1687:      /* this is buried down here so that "continue" statements will miss it */
     2027: 1688:      ++vector->v_length;
        -: 1689:    }
      364: 1690:  return vector;
        -: 1691:}
        -: 1692:
        -: 1693:
        -: 1694:/* Complain about a programming error and exit. */
        -: 1695:void
function bad_prog called 6 returned 0% blocks executed 100%
        6: 1696:bad_prog(why)
        -: 1697:  const char *why;
        -: 1698:{
        6: 1699:  if (cur_input.name)
branch  0 taken 1 (fallthrough)
branch  1 taken 5
        1: 1700:    fprintf(stderr, _("%s: file %s line %lu: %s\n"),
        1: 1701:	    myname, cur_input.name, CAST(unsigned long)cur_input.line, why);
call    0 returned 1
        -: 1702:  else
        5: 1703:    fprintf(stderr, _("%s: -e expression #%lu, char %lu: %s\n"),
        -: 1704:	    myname,
        5: 1705:	    CAST(unsigned long)cur_input.string_expr_count,
        5: 1706:	    CAST(unsigned long)(prog.cur-prog.base),
call    0 returned 5
        -: 1707:	    why);
        6: 1708:  exit(EXIT_FAILURE);
        -: 1709:}
        -: 1710:
        -: 1711:
        -: 1712:/* deal with \X escapes */
        -: 1713:size_t
function normalize_text called 855 returned 100% blocks executed 38%
      855: 1714:normalize_text(buf, len)
        -: 1715:  char *buf;
        -: 1716:  size_t len;
        -: 1717:{
      855: 1718:  const char *bufend = buf + len;
      855: 1719:  char *p = buf;
      855: 1720:  char *q = buf;
        -: 1721:
        -: 1722:  /* I'm not certain whether POSIX.2 allows these escapes.
        -: 1723:     Play it safe for now... */
     855*: 1724:  if (POSIXLY_CORRECT && !(extended_regexp_flags))
branch  0 taken 0 (fallthrough)
branch  1 taken 855
branch  2 never executed
branch  3 never executed
    #####: 1725:    return len;
        -: 1726:
     5109: 1727:  while (p < bufend)
branch  0 taken 4254
branch  1 taken 855 (fallthrough)
        -: 1728:    {
        -: 1729:      int c;
        -: 1730:
     4254: 1731:      *q = *p++;
     4254: 1732:      if (*q == '\\' && p < bufend)
branch  0 taken 381 (fallthrough)
branch  1 taken 3873
branch  2 taken 381 (fallthrough)
branch  3 taken 0
      381: 1733:	switch ( (c = *p++) )
branch  0 taken 0
branch  1 taken 0
branch  2 taken 0
branch  3 taken 0
branch  4 taken 0
branch  5 taken 0
branch  6 taken 0
branch  7 taken 0
branch  8 taken 0
branch  9 taken 0
branch 10 taken 381
        -: 1734:	  {
        -: 1735:#if defined __STDC__ && __STDC__-0
    #####: 1736:	  case 'a': *q = '\a'; break;
        -: 1737:#else /* Not STDC; we'll just assume ASCII */
        -: 1738:	  case 'a': *q = '\007'; break;
        -: 1739:#endif
        -: 1740:	  /* case 'b': *q = '\b'; break; --- conflicts with \b RE */
    #####: 1741:	  case 'f': *q = '\f'; break;
    #####: 1742:	  case '\n': /*fall through */
    #####: 1743:	  case 'n': *q = '\n'; break;
    #####: 1744:	  case 'r': *q = '\r'; break;
    #####: 1745:	  case 't': *q = '\t'; break;
    #####: 1746:	  case 'v': *q = '\v'; break;
        -: 1747:
    #####: 1748:	  case 'd': /* decimal byte */
    #####: 1749:	    p = convert_number(q, p, bufend, 10, 3, 'd');
call    0 never executed
    #####: 1750:	    break;
        -: 1751:
    #####: 1752:	  case 'x': /* hexadecimal byte */
    #####: 1753:	    p = convert_number(q, p, bufend, 16, 2, 'x');
call    0 never executed
    #####: 1754:	    break;
        -: 1755:
        -: 1756:#ifdef REG_PERL
        -: 1757:	  case '0': case '1': case '2': case '3':
        -: 1758:	  case '4': case '5': case '6': case '7':
        -: 1759:	    if ((extended_regexp_flags & REG_PERL) &&
        -: 1760:		p < bufend && isdigit(*p))
        -: 1761:	      {
        -: 1762:		p--;
        -: 1763:		p = convert_number(q, p, bufend, 8, 3, *p);
        -: 1764:	      }
        -: 1765:	    else
        -: 1766:	      /* we just pass the \ up one level for interpretation */
        -: 1767:	      *++q = p[-1];
        -: 1768:
        -: 1769:	    break;
        -: 1770:
        -: 1771:	  case 'o': /* octal byte */
        -: 1772:	    if (!(extended_regexp_flags & REG_PERL))
        -: 1773:	      p = convert_number(q, p, bufend,  8, 3, 'o');
        -: 1774:	    else
        -: 1775:	      /* we just pass the \ up one level for interpretation */
        -: 1776:	      *++q = p[-1];
        -: 1777:	    
        -: 1778:	    break;
        -: 1779:
        -: 1780:#else
    #####: 1781:	  case 'o': /* octal byte */
    #####: 1782:	    p = convert_number(q, p, bufend,  8, 3, 'o');
call    0 never executed
    #####: 1783:	    break;
        -: 1784:#endif
        -: 1785:
    #####: 1786:	  case 'c':
    #####: 1787:	    if (p < bufend)
branch  0 never executed
branch  1 never executed
        -: 1788:	      {
    #####: 1789:		*q = toupper(*p) ^ 0x40;
    #####: 1790:		p++;
    #####: 1791:		break;
        -: 1792:	      }
        -: 1793:	    /* else FALLTHROUGH */
        -: 1794:
        -: 1795:	  default:
        -: 1796:	    /* we just pass the \ up one level for interpretation */
      381: 1797:	    *++q = p[-1];
      381: 1798:	    break;
        -: 1799:	  }
     4254: 1800:      ++q;
        -: 1801:    }
      855: 1802:    return (size_t)(q - buf);
        -: 1803:}
        -: 1804:
        -: 1805:
        -: 1806:/* `str' is a string (from the command line) that contains a sed command.
        -: 1807:   Compile the command, and add it to the end of `cur_program'. */
        -: 1808:struct vector *
function compile_string called 32 returned 84% blocks executed 100%
       32: 1809:compile_string(cur_program, str, len)
        -: 1810:  struct vector *cur_program;
        -: 1811:  char *str;
        -: 1812:  size_t len;
        -: 1813:{
        -: 1814:  static countT string_expr_count = 0;
        -: 1815:  struct vector *ret;
        -: 1816:
       32: 1817:  prog.file = NULL;
       32: 1818:  prog.base = CAST(unsigned char *)str;
       32: 1819:  prog.cur = prog.base;
       32: 1820:  prog.end = prog.cur + len;
        -: 1821:
       32: 1822:  cur_input.line = 0;
       32: 1823:  cur_input.name = NULL;
        -: 1824:#ifndef FAULTY_F_KRM_10
       32: 1825:  cur_input.string_expr_count = ++string_expr_count;
        -: 1826:#else
        -: 1827:  cur_input.string_expr_count = string_expr_count;
        -: 1828:#endif
       32: 1829:  ret = compile_program(cur_program);
call    0 returned 27
       27: 1830:  prog.base = NULL;
       27: 1831:  prog.cur = NULL;
       27: 1832:  prog.end = NULL;
        -: 1833:
       27: 1834:  first_script = FALSE;
       27: 1835:  return ret;
        -: 1836:}
        -: 1837:
        -: 1838:/* `cmdfile' is the name of a file containing sed commands.
        -: 1839:   Read them in and add them to the end of `cur_program'.
        -: 1840: */
        -: 1841:struct vector *
function compile_file called 339 returned 99% blocks executed 89%
      339: 1842:compile_file(cur_program, cmdfile)
        -: 1843:  struct vector *cur_program;
        -: 1844:  const char *cmdfile;
        -: 1845:{
        -: 1846:  size_t len;
        -: 1847:  struct vector *ret;
        -: 1848:
      339: 1849:  prog.file = stdin;
     339*: 1850:  if (cmdfile[0] != '-' || cmdfile[1] != '\0')
branch  0 taken 0 (fallthrough)
branch  1 taken 339
branch  2 never executed
branch  3 never executed
      339: 1851:    prog.file = ck_fopen(cmdfile, "rt", TRUE);
call    0 returned 337
        -: 1852:
      337: 1853:  cur_input.line = 1;
      337: 1854:  cur_input.name = cmdfile;
      337: 1855:  cur_input.string_expr_count = 0;
        -: 1856:
      337: 1857:  ret = compile_program(cur_program);
call    0 returned 337
      337: 1858:  if (prog.file != stdin)
branch  0 taken 337 (fallthrough)
branch  1 taken 0
      337: 1859:    ck_fclose(prog.file);
call    0 returned 337
      337: 1860:  prog.file = NULL;
        -: 1861:
      337: 1862:  first_script = FALSE;
      337: 1863:  return ret;
        -: 1864:}
        -: 1865:
        -: 1866:#undef stderr
        -: 1867:#define stderr stdout
        -: 1868:/* Make any checks which require the whole program to have been read.
        -: 1869:   In particular: this backpatches the jump targets.
        -: 1870:   Any cleanup which can be done after these checks is done here also.  */
        -: 1871:void
function check_final_program called 361 returned 100% blocks executed 73%
      361: 1872:check_final_program(program)
        -: 1873:  struct vector *program;
        -: 1874:{
        -: 1875:  struct sed_label *go;
        -: 1876:  struct sed_label *lbl;
        -: 1877:
        -: 1878:  /* do all "{"s have a corresponding "}"? */
      361: 1879:  if (blocks)
branch  0 taken 1 (fallthrough)
branch  1 taken 360
        -: 1880:    {
        -: 1881:      /* update info for error reporting: */
        1: 1882:      MEMCPY(&cur_input, &blocks->err_info, sizeof cur_input);
        1: 1883:      bad_prog(_(EXCESS_OPEN_BRACE));
call    0 returned 0
        -: 1884:    }
        -: 1885:
        -: 1886:  /* was the final command an unterminated a/c/i command? */
      360: 1887:  if (pending_text)
branch  0 taken 0 (fallthrough)
branch  1 taken 360
        -: 1888:    {
    #####: 1889:      old_text_buf->text_length = size_buffer(pending_text);
call    0 never executed
    #####: 1890:      old_text_buf->text = MEMDUP(get_buffer(pending_text),
call    0 never executed
call    1 never executed
        -: 1891:				  old_text_buf->text_length, char);
    #####: 1892:      free_buffer(pending_text);
call    0 never executed
    #####: 1893:      pending_text = NULL;
        -: 1894:    }
        -: 1895:
      369: 1896:  for (go = jumps; go; go = release_label(go))
call    0 returned 9
branch  1 taken 9
branch  2 taken 360 (fallthrough)
        -: 1897:    {
       11: 1898:      for (lbl = labels; lbl; lbl = lbl->next)
branch  0 taken 7
branch  1 taken 4 (fallthrough)
        7: 1899:	if (strcmp(lbl->name, go->name) == 0)
branch  0 taken 5 (fallthrough)
branch  1 taken 2
        5: 1900:	  break;
        9: 1901:      if (lbl)
branch  0 taken 5 (fallthrough)
branch  1 taken 4
        -: 1902:	{
        5: 1903:	  program->v[go->v_index].x.jump_index = lbl->v_index;
        -: 1904:	}
        -: 1905:      else
        -: 1906:	{
        4: 1907:	  if (*go->name)
branch  0 taken 0 (fallthrough)
branch  1 taken 4
    #####: 1908:	    panic(_("Can't find label for jump to `%s'"), go->name);
call    0 never executed
        4: 1909:	  program->v[go->v_index].x.jump_index = program->v_length;
        -: 1910:	}
        -: 1911:    }
      360: 1912:  jumps = NULL;
        -: 1913:
      364: 1914:  for (lbl = labels; lbl; lbl = release_label(lbl))
call    0 returned 4
branch  1 taken 4
branch  2 taken 360 (fallthrough)
        -: 1915:    ;
      360: 1916:  labels = NULL;
        -: 1917:
        -: 1918:  /* There is no longer a need to track file names: */
        -: 1919:  {
        -: 1920:    struct fp_list *p;
        -: 1921:
     360*: 1922:    for (p=file_read; p; p=p->link)
branch  0 taken 0
branch  1 taken 360 (fallthrough)
    #####: 1923:      if (p->name)
branch  0 never executed
branch  1 never executed
        -: 1924:	{
    #####: 1925:	  FREE(p->name);
call    0 never executed
    #####: 1926:	  p->name = NULL;
        -: 1927:	}
        -: 1928:
      557: 1929:    for (p=file_write; p; p=p->link)
branch  0 taken 197
branch  1 taken 360 (fallthrough)
      197: 1930:      if (p->name)
branch  0 taken 197 (fallthrough)
branch  1 taken 0
        -: 1931:	{
      197: 1932:	  FREE(p->name);
call    0 returned 197
      197: 1933:	  p->name = NULL;
        -: 1934:	}
        -: 1935:  }
      360: 1936:}
        -: 1937:
        -: 1938:/* Release all resources which were allocated in this module. */
        -: 1939:void
function rewind_read_files called 5 returned 100% blocks executed 43%
        5: 1940:rewind_read_files()
        -: 1941:{
        -: 1942:  struct fp_list *p, *q;
        -: 1943:
       5*: 1944:  for (p=file_read; p; p=p->link)
branch  0 taken 0
branch  1 taken 5 (fallthrough)
    #####: 1945:    if (p->fp && !p->special)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1946:      rewind(p->fp);
call    0 never executed
        5: 1947:}
        -: 1948:
        -: 1949:/* Release all resources which were allocated in this module. */
        -: 1950:void
function finish_program called 360 returned 100% blocks executed 69%
      360: 1951:finish_program(program)
        -: 1952:  struct vector *program;
        -: 1953:{
        -: 1954:  /* close all files... */
        -: 1955:  {
        -: 1956:    struct fp_list *p, *q;
        -: 1957:
     360*: 1958:    for (p=file_read; p; p=q)
branch  0 taken 0
branch  1 taken 360 (fallthrough)
        -: 1959:      {
    #####: 1960:	if (p->fp && !p->special)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1961:	  ck_fclose(p->fp);
call    0 never executed
    #####: 1962:	q = p->link;
        -: 1963:#if 0
        -: 1964:	/* We use obstacks. */
        -: 1965:	FREE(p);
        -: 1966:#endif
        -: 1967:      }
        -: 1968:
      557: 1969:    for (p=file_write; p; p=q)
branch  0 taken 197
branch  1 taken 360 (fallthrough)
        -: 1970:      {
      197: 1971:	if (p->fp && !p->special)
branch  0 taken 197 (fallthrough)
branch  1 taken 0
branch  2 taken 197 (fallthrough)
branch  3 taken 0
      197: 1972:	  ck_fclose(p->fp);
call    0 returned 197
      197: 1973:	q = p->link;
        -: 1974:#if 0
        -: 1975:	/* We use obstacks. */
        -: 1976:	FREE(p);
        -: 1977:#endif
        -: 1978:      }
      360: 1979:    file_read = file_write = NULL;
        -: 1980:  }
        -: 1981:
        -: 1982:#ifdef DEBUG_LEAKS
        -: 1983:  obstack_free (&obs, NULL);
        -: 1984:#endif /*DEBUG_LEAKS*/
      360: 1985:}
        -: 1986:
        -: 1987:/*  GNU SED, a batch stream editor.
        -: 1988:    Copyright (C) 1989,90,91,92,93,94,95,98,99,2002,2003
        -: 1989:    Free Software Foundation, Inc.
        -: 1990:
        -: 1991:    This program is free software; you can redistribute it and/or modify
        -: 1992:    it under the terms of the GNU General Public License as published by
        -: 1993:    the Free Software Foundation; either version 2, or (at your option)
        -: 1994:    any later version.
        -: 1995:
        -: 1996:    This program is distributed in the hope that it will be useful,
        -: 1997:    but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 1998:    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 1999:    GNU General Public License for more details.
        -: 2000:
        -: 2001:    You should have received a copy of the GNU General Public License
        -: 2002:    along with this program; if not, write to the Free Software
        -: 2003:    Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
        -: 2004:
        -: 2005:#undef EXPERIMENTAL_DASH_N_OPTIMIZATION	/*don't use -- is very buggy*/
        -: 2006:#define INITIAL_BUFFER_SIZE	50
        -: 2007:#define FREAD_BUFFER_SIZE	8192
        -: 2008:
        -: 2009:#include "config.h"
        -: 2010:
        -: 2011:#include <stdio.h>
        -: 2012:#include <ctype.h>
        -: 2013:
        -: 2014:#include <errno.h>
        -: 2015:#ifndef errno
        -: 2016:extern int errno;
        -: 2017:#endif
        -: 2018:
        -: 2019:#ifdef HAVE_UNISTD_H
        -: 2020:# include <unistd.h>
        -: 2021:#endif
        -: 2022:
        -: 2023:#ifdef __GNUC__
        -: 2024:# if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__-0 >= 7)
        -: 2025:   /* silence warning about unused parameter even for "gcc -W -Wunused" */
        -: 2026:#  define UNUSED	__attribute__((unused))
        -: 2027:# endif
        -: 2028:#endif
        -: 2029:#ifndef UNUSED
        -: 2030:# define UNUSED
        -: 2031:#endif
        -: 2032:
        -: 2033:#ifdef HAVE_STRINGS_H
        -: 2034:# include <strings.h>
        -: 2035:#else
        -: 2036:# include <string.h>
        -: 2037:#endif /*HAVE_STRINGS_H*/
        -: 2038:#ifdef HAVE_MEMORY_H
        -: 2039:# include <memory.h>
        -: 2040:#endif
        -: 2041:
        -: 2042:
        -: 2043:#if defined HAVE_WCTYPE_H && defined HAVE_WCHAR_H && defined HAVE_MBRTOWC
        -: 2044:/* We can handle multibyte string.  */
        -: 2045:# include <wchar.h>
        -: 2046:# include <wctype.h>
        -: 2047:# define MBS_SUPPORT
        -: 2048:#endif
        -: 2049:
        -: 2050:#ifndef HAVE_STRCHR
        -: 2051:# define strchr index
        -: 2052:# define strrchr rindex
        -: 2053:#endif
        -: 2054:
        -: 2055:#ifdef HAVE_STDLIB_H
        -: 2056:# include <stdlib.h>
        -: 2057:#endif
        -: 2058:#ifndef EXIT_SUCCESS
        -: 2059:# define EXIT_SUCCESS 0
        -: 2060:#endif
        -: 2061:
        -: 2062:#ifdef HAVE_SYS_TYPES_H
        -: 2063:# include <sys/types.h>
        -: 2064:#endif
        -: 2065:
        -: 2066:#include <sys/stat.h>
        -: 2067:
        -: 2068:#include "basicdefs.h"
        -: 2069:#include "utils.h"
        -: 2070:
        -: 2071:
        -: 2072:/* Sed operates a line at a time. */
        -: 2073:struct line {
        -: 2074:  char *text;		/* Pointer to line allocated by malloc. */
        -: 2075:  char *active;		/* Pointer to non-consumed part of text. */
        -: 2076:  size_t length;	/* Length of text (or active, if used). */
        -: 2077:  size_t alloc;		/* Allocated space for active. */
        -: 2078:  flagT chomped;	/* Was a trailing newline dropped? */
        -: 2079:};
        -: 2080:
        -: 2081:/* A queue of text to write out at the end of a cycle
        -: 2082:   (filled by the "a", "r" and "R" commands.) */
        -: 2083:struct append_queue {
        -: 2084:  const char *fname;
        -: 2085:  char *text;
        -: 2086:  size_t textlen;
        -: 2087:  struct append_queue *next;
        -: 2088:  flagT free;
        -: 2089:};
        -: 2090:
        -: 2091:/* State information for the input stream. */
        -: 2092:struct input {
        -: 2093:  char **file_list;	/* The list of yet-to-be-opened files.
        -: 2094:			   It is invalid for file_list to be NULL.
        -: 2095:			   When *file_list is NULL we are
        -: 2096:			   currently processing the last file. */
        -: 2097:  countT bad_count;	/* count of files we failed to open */
        -: 2098:  countT line_number;	/* current input line number (over all files) */
        -: 2099:
        -: 2100:  flagT (*read_fn) P_((struct input *));	/* read one line */
        -: 2101:  /* If fp is NULL, read_fn better not be one which uses fp;
        -: 2102:     in particular, read_always_fail() is recommended. */
        -: 2103:
        -: 2104:  char *out_file_name;
        -: 2105:  const char *in_file_name;
        -: 2106:
        -: 2107:  FILE *fp;		/* if NULL, none of the following are valid */
        -: 2108:  flagT no_buffering;
        -: 2109:};
        -: 2110:
        -: 2111:
        -: 2112:/* Have we done any replacements lately?  This is used by the `t' command. */
        -: 2113:static flagT replaced = FALSE;
        -: 2114:
        -: 2115:/* The current output file (stdout if -i is not being used. */
        -: 2116:static FILE *output_file;
        -: 2117:
        -: 2118:/* The `current' input line. */
        -: 2119:static struct line line;
        -: 2120:
        -: 2121:/* An input line used to accumulate the result of the s and e commands. */
        -: 2122:static struct line s_accum;
        -: 2123:
        -: 2124:/* An input line that's been stored by later use by the program */
        -: 2125:static struct line hold;
        -: 2126:
        -: 2127:/* The buffered input look-ahead.  The only field that should be
        -: 2128:   used outside of read_mem_line() or line_init() is buffer.length. */
        -: 2129:static struct line buffer;
        -: 2130:
        -: 2131:static struct append_queue *append_head = NULL;
        -: 2132:static struct append_queue *append_tail = NULL;
        -: 2133:
        -: 2134:
        -: 2135:#ifdef BOOTSTRAP
        -: 2136:/* We can't be sure that the system we're boostrapping on has
        -: 2137:   memchr(), and ../lib/memchr.c requires configuration knowledge
        -: 2138:   about how many bits are in a `long'.  This implementation
        -: 2139:   is far from ideal, but it should get us up-and-limping well
        -: 2140:   enough to run the configure script, which is all that matters.
        -: 2141:*/
        -: 2142:# ifdef memchr
        -: 2143:#  undef memchr
        -: 2144:# endif
        -: 2145:# define memchr bootstrap_memchr
        -: 2146:
        -: 2147:static VOID *bootstrap_memchr P_((const VOID *s, int c, size_t n));
        -: 2148:static VOID *
        -: 2149:bootstrap_memchr(s, c, n)
        -: 2150:  const VOID *s;
        -: 2151:  int c;
        -: 2152:  size_t n;
        -: 2153:{
        -: 2154:  char *p;
        -: 2155:
        -: 2156:  for (p=(char *)s; n-- > 0; ++p)
        -: 2157:    if (*p == c)
        -: 2158:      return p;
        -: 2159:  return CAST(VOID *)0;
        -: 2160:}
        -: 2161:#endif /*BOOTSTRAP*/
        -: 2162:
        -: 2163:/* increase a struct line's length, making some attempt at
        -: 2164:   keeping realloc() calls under control by padding for future growth.  */
        -: 2165:static void resize_line P_((struct line *, size_t));
        -: 2166:static void
function resize_line called 499 returned 100% blocks executed 100%
      499: 2167:resize_line(lb, len)
        -: 2168:  struct line *lb;
        -: 2169:  size_t len;
        -: 2170:{
        -: 2171:  int inactive;
      499: 2172:  inactive = lb->active - lb->text;
        -: 2173:
        -: 2174:  /* If the inactive part has got to more than two thirds of the buffer,
        -: 2175:   * remove it. */
      499: 2176:  if (inactive > lb->alloc * 2)
branch  0 taken 88 (fallthrough)
branch  1 taken 411
        -: 2177:    {
       88: 2178:      MEMMOVE(lb->text, lb->active, lb->length);
       88: 2179:      lb->alloc += lb->active - lb->text;
       88: 2180:      lb->active = lb->text;
       88: 2181:      inactive = 0;
        -: 2182:
       88: 2183:      if (lb->alloc > len)
branch  0 taken 88 (fallthrough)
branch  1 taken 0
       88: 2184:	return;
        -: 2185:    }
        -: 2186:
      411: 2187:  lb->alloc *= 2;
      411: 2188:  if (lb->alloc < len)
branch  0 taken 8 (fallthrough)
branch  1 taken 403
        8: 2189:    lb->alloc = len;
      411: 2190:  if (lb->alloc < INITIAL_BUFFER_SIZE)
branch  0 taken 19 (fallthrough)
branch  1 taken 392
       19: 2191:    lb->alloc = INITIAL_BUFFER_SIZE;
        -: 2192:    
      411: 2193:  lb->text = REALLOC(lb->text, inactive + lb->alloc, char);
call    0 returned 411
      411: 2194:  lb->active = lb->text + inactive;
        -: 2195:}
        -: 2196:
        -: 2197:/* Append `length' bytes from `string' to the line `to'. */
        -: 2198:static void str_append P_((struct line *, const char *, size_t));
        -: 2199:static void
function str_append called 47138 returned 100% blocks executed 100%
    47138: 2200:str_append(to, string, length)
        -: 2201:  struct line *to;
        -: 2202:  const char *string;
        -: 2203:  size_t length;
        -: 2204:{
    47138: 2205:  size_t new_length = to->length + length;
        -: 2206:
    47138: 2207:  if (to->alloc < new_length)
branch  0 taken 499 (fallthrough)
branch  1 taken 46639
      499: 2208:    resize_line(to, new_length);
call    0 returned 499
    47138: 2209:  MEMCPY(to->active + to->length, string, length);
    47138: 2210:  to->length = new_length;
    47138: 2211:}
        -: 2212:
        -: 2213:static void str_append_modified P_((struct line *, const char *, size_t,
        -: 2214:				    enum replacement_types));
        -: 2215:static void
function str_append_modified called 3572 returned 100% blocks executed 41%
     3572: 2216:str_append_modified(to, string, length, type)
        -: 2217:  struct line *to;
        -: 2218:  const char *string;
        -: 2219:  size_t length;
        -: 2220:  enum replacement_types type;
        -: 2221:{
     3572: 2222:  size_t old_length = to->length;
        -: 2223:  char *start, *end;
        -: 2224:
     3572: 2225:  if (length == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 3572
    #####: 2226:    return;
        -: 2227:
     3572: 2228:  str_append(to, string, length);
call    0 returned 3572
     3572: 2229:  start = to->active + old_length;
     3572: 2230:  end = start + length;
        -: 2231:
        -: 2232:  /* Now do the required modifications.  First \[lu]... */
     3572: 2233:  if (type & repl_uppercase_first)
branch  0 taken 0 (fallthrough)
branch  1 taken 3572
        -: 2234:    {
    #####: 2235:      *start = toupper(*start);
    #####: 2236:      start++;
    #####: 2237:      type &= ~repl_uppercase_first;
        -: 2238:    }
     3572: 2239:  else if (type & repl_lowercase_first)
branch  0 taken 0 (fallthrough)
branch  1 taken 3572
        -: 2240:    {
    #####: 2241:      *start = tolower(*start);
    #####: 2242:      start++;
    #####: 2243:      type &= ~repl_lowercase_first;
        -: 2244:    }
        -: 2245:
     3572: 2246:  if (type == repl_asis)
branch  0 taken 3572 (fallthrough)
branch  1 taken 0
     3572: 2247:    return;
        -: 2248:
        -: 2249:  /* ...and then \[LU] */
    #####: 2250:  if (type == repl_uppercase)
branch  0 never executed
branch  1 never executed
    #####: 2251:    for (; start != end; start++)
branch  0 never executed
branch  1 never executed
    #####: 2252:      *start = toupper(*start);
        -: 2253:  else
    #####: 2254:    for (; start != end; start++)
branch  0 never executed
branch  1 never executed
    #####: 2255:      *start = tolower(*start);
        -: 2256:}
        -: 2257:
        -: 2258:/* initialize a "struct line" buffer */
        -: 2259:static void line_init P_((struct line *, size_t initial_size));
        -: 2260:static void
function line_init called 1266 returned 100% blocks executed 100%
     1266: 2261:line_init(buf, initial_size)
        -: 2262:  struct line *buf;
        -: 2263:  size_t initial_size;
        -: 2264:{
     1266: 2265:  buf->text = MALLOC(initial_size, char);
call    0 returned 1266
     1266: 2266:  buf->active = buf->text;
     1266: 2267:  buf->alloc = initial_size;
     1266: 2268:  buf->length = 0;
     1266: 2269:  buf->chomped = TRUE;
     1266: 2270:}
        -: 2271:
        -: 2272:/* Copy the contents of the line `from' into the line `to'.
        -: 2273:   This destroys the old contents of `to'. */
        -: 2274:static void line_copy P_((struct line *from, struct line *to));
        -: 2275:static void
function line_copy called 28 returned 100% blocks executed 100%
       28: 2276:line_copy(from, to)
        -: 2277:  struct line *from;
        -: 2278:  struct line *to;
        -: 2279:{
        -: 2280:  /* Remove the inactive portion in the destination buffer. */
       28: 2281:  to->alloc += to->active - to->text;
        -: 2282:
       28: 2283:  if (to->alloc < from->length)
branch  0 taken 4 (fallthrough)
branch  1 taken 24
        -: 2284:    {
        4: 2285:      to->alloc *= 2;
        4: 2286:      if (to->alloc < from->length)
branch  0 taken 3 (fallthrough)
branch  1 taken 1
        3: 2287:	to->alloc = from->length;
        4: 2288:      if (to->alloc < INITIAL_BUFFER_SIZE)
branch  0 taken 3 (fallthrough)
branch  1 taken 1
        3: 2289:	to->alloc = INITIAL_BUFFER_SIZE;
        -: 2290:      /* Use FREE()+MALLOC() instead of REALLOC() to
        -: 2291:	 avoid unnecessary copying of old text. */
        4: 2292:      FREE(to->text);
call    0 returned 4
        4: 2293:      to->text = MALLOC(to->alloc, char);
call    0 returned 4
        -: 2294:    }
        -: 2295:
       28: 2296:  to->active = to->text;
       28: 2297:  to->length = from->length;
       28: 2298:  to->chomped = from->chomped;
       28: 2299:  MEMCPY(to->active, from->active, from->length);
       28: 2300:}
        -: 2301:
        -: 2302:/* Append the contents of the line `from' to the line `to'. */
        -: 2303:static void line_append P_((struct line *from, struct line *to));
        -: 2304:static void
function line_append called 22 returned 100% blocks executed 100%
       22: 2305:line_append(from, to)
        -: 2306:  struct line *from;
        -: 2307:  struct line *to;
        -: 2308:{
       22: 2309:  str_append(to, "\n", 1);
call    0 returned 22
       22: 2310:  str_append(to, from->active, from->length);
call    0 returned 22
       22: 2311:  to->chomped = from->chomped;
       22: 2312:}
        -: 2313:
        -: 2314:/* Exchange the contents of two "struct line" buffers. */
        -: 2315:static void line_exchange P_((struct line *, struct line *));
        -: 2316:static void
function line_exchange called 2506 returned 100% blocks executed 100%
     2506: 2317:line_exchange(a, b)
        -: 2318:  struct line *a;
        -: 2319:  struct line *b;
        -: 2320:{
        -: 2321:  struct line t;
     2506: 2322:}
        -: 2323:
        -: 2324:
        -: 2325:/* dummy function to simplify read_pattern_space() */
        -: 2326:static flagT read_always_fail P_((struct input *));
        -: 2327:static flagT
function read_always_fail called 384 returned 100% blocks executed 100%
      384: 2328:read_always_fail(input)
        -: 2329:  struct input *input UNUSED;
        -: 2330:{
      384: 2331:  return FALSE;
        -: 2332:}
        -: 2333:
        -: 2334:#include "getline.c"
        -: 2335:static flagT read_file_line P_((struct input *));
        -: 2336:static flagT
function read_file_line called 38579 returned 100% blocks executed 100%
    38579: 2337:read_file_line(input)
        -: 2338:  struct input *input;
        -: 2339:{
        -: 2340:  static char *b;
        -: 2341:  static size_t blen;
        -: 2342:
    38579: 2343:  int result = getline (&b, &blen, input->fp);
call    0 returned 38579
        -: 2344:
        -: 2345:  /* Remove the trailing new-line that is left by getline. */
    38579: 2346:  if (result > 0 && b[result - 1] == '\n')
branch  0 taken 38270 (fallthrough)
branch  1 taken 309
branch  2 taken 38267 (fallthrough)
branch  3 taken 3
    38267: 2347:    --result;
        -: 2348:  else
        -: 2349:    {
        -: 2350:      /* No trailing new line found. */
      312: 2351:      if (!*input->file_list && !POSIXLY_CORRECT)
branch  0 taken 310 (fallthrough)
branch  1 taken 2
branch  2 taken 310 (fallthrough)
branch  3 taken 0
      310: 2352:	line.chomped = FALSE;
        -: 2353:
      312: 2354:      if (result <= 0)
branch  0 taken 309 (fallthrough)
branch  1 taken 3
      309: 2355:	return FALSE;
        -: 2356:    }
        -: 2357:
    38270: 2358:  str_append(&line, b, result);
call    0 returned 38270
    38270: 2359:  return TRUE;
        -: 2360:}
        -: 2361:
        -: 2362:
        -: 2363:static void output_line P_((const char *, size_t, flagT, FILE *));
        -: 2364:static void
function output_line called 25768 returned 100% blocks executed 100%
    25768: 2365:output_line(text, length, nl, fp)
        -: 2366:  const char *text;
        -: 2367:  size_t length;
        -: 2368:  flagT nl;
        -: 2369:  FILE *fp;
        -: 2370:{
    25768: 2371:  if (length)
branch  0 taken 17743 (fallthrough)
branch  1 taken 8025
    17743: 2372:    ck_fwrite(text, 1, length, fp);
call    0 returned 17743
    25768: 2373:  if (nl)
branch  0 taken 21171 (fallthrough)
branch  1 taken 4597
    21171: 2374:    ck_fwrite("\n", 1, 1, fp);
call    0 returned 21171
    25768: 2375:  if (fp != stdout || unbuffered_output)
branch  0 taken 22417 (fallthrough)
branch  1 taken 3351
branch  2 taken 232 (fallthrough)
branch  3 taken 22185
     3583: 2376:    ck_fflush(fp);
call    0 returned 3583
    25768: 2377:}
        -: 2378:
        -: 2379:static struct append_queue *next_append_slot P_((void));
        -: 2380:static struct append_queue *
function next_append_slot called 645 returned 100% blocks executed 83%
      645: 2381:next_append_slot()
        -: 2382:{
      645: 2383:  struct append_queue *n = MALLOC(1, struct append_queue);
call    0 returned 645
        -: 2384:
      645: 2385:  n->fname = NULL;
      645: 2386:  n->text = NULL;
      645: 2387:  n->textlen = 0;
      645: 2388:  n->next = NULL;
      645: 2389:  n->free = FALSE;
        -: 2390:
      645: 2391:  if (append_tail)
branch  0 taken 0 (fallthrough)
branch  1 taken 645
    #####: 2392:      append_tail->next = n;
        -: 2393:  else
      645: 2394:      append_head = n;
      645: 2395:  return append_tail = n;
        -: 2396:}
        -: 2397:
        -: 2398:static void release_append_queue P_((void));
        -: 2399:static void
function release_append_queue called 645 returned 100% blocks executed 86%
      645: 2400:release_append_queue()
        -: 2401:{
        -: 2402:  struct append_queue *p, *q;
        -: 2403:
     1290: 2404:  for (p=append_head; p; p=q)
branch  0 taken 645
branch  1 taken 645 (fallthrough)
        -: 2405:    {
      645: 2406:      if (p->free)
branch  0 taken 0 (fallthrough)
branch  1 taken 645
    #####: 2407:        FREE(p->text);
call    0 never executed
        -: 2408:
      645: 2409:      q = p->next;
      645: 2410:      FREE(p);
call    0 returned 645
        -: 2411:    }
      645: 2412:  append_head = append_tail = NULL;
      645: 2413:}
        -: 2414:
        -: 2415:static void dump_append_queue P_((void));
        -: 2416:static void
function dump_append_queue called 645 returned 100% blocks executed 100%
      645: 2417:dump_append_queue()
        -: 2418:{
        -: 2419:  struct append_queue *p;
        -: 2420:
     1290: 2421:  for (p=append_head; p; p=p->next)
branch  0 taken 645
branch  1 taken 645 (fallthrough)
        -: 2422:    {
      645: 2423:      if (p->text)
branch  0 taken 546 (fallthrough)
branch  1 taken 99
      546: 2424:	  output_line(p->text, p->textlen, FALSE, output_file);
call    0 returned 546
      645: 2425:      if (p->fname)
branch  0 taken 99 (fallthrough)
branch  1 taken 546
        -: 2426:	{
        -: 2427:	  char buf[FREAD_BUFFER_SIZE];
        -: 2428:	  size_t cnt;
        -: 2429:	  FILE *fp;
        -: 2430:
        -: 2431:	  /* "If _fname_ does not exist or cannot be read, it shall
        -: 2432:	     be treated as if it were an empty file, causing no error
        -: 2433:	     condition."  IEEE Std 1003.2-1992
        -: 2434:	     So, don't fail. */
       99: 2435:	  fp = ck_fopen(p->fname, "r", FALSE);
call    0 returned 99
       99: 2436:	  if (fp)
branch  0 taken 99 (fallthrough)
branch  1 taken 0
        -: 2437:	    {
      198: 2438:	      while ((cnt = ck_fread(buf, 1, sizeof buf, fp)) > 0)
call    0 returned 198
branch  1 taken 99
branch  2 taken 99 (fallthrough)
       99: 2439:		ck_fwrite(buf, 1, cnt, output_file);
call    0 returned 99
       99: 2440:	      ck_fclose(fp);
call    0 returned 99
        -: 2441:	    }
        -: 2442:	}
        -: 2443:    }
      645: 2444:  release_append_queue();
call    0 returned 645
      645: 2445:}
        -: 2446:
        -: 2447:
        -: 2448:/* Compute the name of the backup file for in-place editing */
        -: 2449:static char *get_backup_file_name P_((const char *));
        -: 2450:static char *
function get_backup_file_name called 1 returned 100% blocks executed 100%
        1: 2451:get_backup_file_name(name)
        -: 2452:  const char *name;
        -: 2453:{
        -: 2454:  char *old_asterisk, *asterisk, *backup, *p;
        1: 2455:  int name_length = strlen(name), backup_length = strlen(in_place_extension);
        -: 2456:
        -: 2457:  /* Compute the length of the backup file */
        1: 2458:  for (asterisk = in_place_extension - 1, old_asterisk = asterisk + 1;
        2: 2459:       asterisk = strchr(old_asterisk, '*');
branch  0 taken 1
branch  1 taken 1 (fallthrough)
        1: 2460:       old_asterisk = asterisk + 1)
        1: 2461:    backup_length += name_length - 1;
        -: 2462:
        1: 2463:  p = backup = xmalloc(backup_length + 1);
call    0 returned 1
        -: 2464:
        -: 2465:  /* Each iteration gobbles up to an asterisk */
        1: 2466:  for (asterisk = in_place_extension - 1, old_asterisk = asterisk + 1;
        2: 2467:       asterisk = strchr(old_asterisk, '*');
branch  0 taken 1
branch  1 taken 1 (fallthrough)
        1: 2468:       old_asterisk = asterisk + 1)
        -: 2469:    {
        1: 2470:      memcpy (p, old_asterisk, asterisk - old_asterisk);
        1: 2471:      p += asterisk - old_asterisk;
        1: 2472:      strcpy (p, name);
        1: 2473:      p += name_length;
        -: 2474:    }
        -: 2475:
        -: 2476:  /* Tack on what's after the last asterisk */
        1: 2477:  strcpy (p, old_asterisk);
        1: 2478:  return backup;
        -: 2479:}
        -: 2480:
        -: 2481:/* Initialize a struct input for the named file. */
        -: 2482:static void open_next_file P_((const char *name, struct input *));
        -: 2483:static void
function open_next_file called 362 returned 100% blocks executed 95%
      362: 2484:open_next_file(name, input)
        -: 2485:  const char *name;
        -: 2486:  struct input *input;
        -: 2487:{
      362: 2488:  buffer.length = 0;
        -: 2489:
      362: 2490:  if (name[0] == '-' && name[1] == '\0')
branch  0 taken 1 (fallthrough)
branch  1 taken 361
branch  2 taken 1 (fallthrough)
branch  3 taken 0
        -: 2491:    {
        1: 2492:      clearerr(stdin);	/* clear any stale EOF indication */
call    0 returned 1
        1: 2493:      input->fp = stdin;
        -: 2494:    }
      361: 2495:  else if ( ! (input->fp = ck_fopen(name, "r", FALSE)) )
call    0 returned 361
branch  1 taken 1 (fallthrough)
branch  2 taken 360
        -: 2496:    {
        1: 2497:      const char *ptr = strerror(errno);
call    0 returned 1
        1: 2498:      fprintf(stderr, _("%s: can't read %s: %s\n"), myname, name, ptr);
call    0 returned 1
        1: 2499:      input->read_fn = read_always_fail; /* a redundancy */
        1: 2500:      ++input->bad_count;
        1: 2501:      return;
        -: 2502:    }
        -: 2503:
      361: 2504:  input->read_fn = read_file_line;
        -: 2505:
      361: 2506:  if (in_place_extension)
branch  0 taken 2 (fallthrough)
branch  1 taken 359
        -: 2507:    {
        -: 2508:      int output_fd;
        2: 2509:      char *tmpdir = ck_strdup(name), *p;
call    0 returned 2
        -: 2510:
        -: 2511:      /* get the base name */
        2: 2512:      if (p = strrchr(tmpdir, '/'))
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2: 2513:	*(p + 1) = 0;
        -: 2514:      else
    #####: 2515:	strcpy(tmpdir, ".");
        -: 2516:      
        2: 2517:      input->in_file_name = name;
        2: 2518:      input->out_file_name = temp_file_template (tmpdir, "sed");
call    0 returned 2
        2: 2519:      output_fd = mkstemp (input->out_file_name);
call    0 returned 2
        2: 2520:      free (tmpdir);
        -: 2521:
        -: 2522:#ifdef HAVE_FCHMOD
        -: 2523:      {
        -: 2524:        struct stat st;
        -: 2525:        fstat (fileno (input->fp), &st);
        -: 2526:        fchmod (output_fd, st.st_mode);
        -: 2527:      }
        -: 2528:#endif
        -: 2529:
        2: 2530:      output_file = fdopen (output_fd, "w");
call    0 returned 2
        -: 2531:    }
        -: 2532:  else
      359: 2533:    output_file = stdout;
        -: 2534:}
        -: 2535:
        -: 2536:
        -: 2537:/* Clean up an input stream that we are done with. */
        -: 2538:static void closedown P_((struct input *));
        -: 2539:static void
function closedown called 1080 returned 100% blocks executed 100%
     1080: 2540:closedown(input)
        -: 2541:  struct input *input;
        -: 2542:{
     1080: 2543:  input->read_fn = read_always_fail;
     1080: 2544:  if (!input->fp)
branch  0 taken 719 (fallthrough)
branch  1 taken 361
      719: 2545:    return;
      361: 2546:  if (input->fp != stdin) /* stdin can be reused on tty and tape devices */
branch  0 taken 360 (fallthrough)
branch  1 taken 1
      360: 2547:    ck_fclose(input->fp);
call    0 returned 360
        -: 2548:
      361: 2549:      if (in_place_extension && output_file != NULL)
branch  0 taken 2 (fallthrough)
branch  1 taken 359
branch  2 taken 2 (fallthrough)
branch  3 taken 0
        -: 2550:	{
        2: 2551:	  if (strcmp(in_place_extension, "*") != 0)
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        -: 2552:	    {
        1: 2553:	      char *backup_file_name = get_backup_file_name(input->in_file_name);
call    0 returned 1
        1: 2554:	      rename (input->in_file_name, backup_file_name);
call    0 returned 1
        1: 2555:	      free (backup_file_name);
        -: 2556:	    }
        -: 2557:
        2: 2558:	  ck_fclose (output_file);
call    0 returned 2
        2: 2559:	  rename (input->out_file_name, input->in_file_name);
call    0 returned 2
        2: 2560:	  free (input->out_file_name);
        -: 2561:	}
        -: 2562:
      361: 2563:  input->fp = NULL;
        -: 2564:
      361: 2565:  if (separate_files)
branch  0 taken 5 (fallthrough)
branch  1 taken 356
        5: 2566:    rewind_read_files ();
call    0 returned 5
        -: 2567:}
        -: 2568:
        -: 2569:/* Reset range commands so that they are marked as non-matching */
        -: 2570:static void reset_addresses P_((struct vector *));
        -: 2571:static void
function reset_addresses called 5 returned 100% blocks executed 100%
        5: 2572:reset_addresses(vec)
        -: 2573:     struct vector *vec;
        -: 2574:{
        -: 2575:  struct sed_cmd *cur_cmd;
        -: 2576:  int n;
        -: 2577:
       11: 2578:  for (cur_cmd = vec->v, n = vec->v_length; n--; cur_cmd++)
branch  0 taken 6
branch  1 taken 5 (fallthrough)
        6: 2579:    cur_cmd->a1_matched = FALSE;
        5: 2580:}
        -: 2581:
        -: 2582:/* Read in the next line of input, and store it in the pattern space.
        -: 2583:   Return zero if there is nothing left to input. */
        -: 2584:static flagT read_pattern_space P_((struct input *, struct vector *, flagT));
        -: 2585:static flagT
function read_pattern_space called 38601 returned 100% blocks executed 100%
    38601: 2586:read_pattern_space(input, the_program, append)
        -: 2587:  struct input *input;
        -: 2588:  struct vector *the_program;
        -: 2589:  flagT append;
        -: 2590:{
    38601: 2591:  if (append_head) /* redundant test to optimize for common case */
branch  0 taken 645 (fallthrough)
branch  1 taken 37956
      645: 2592:    dump_append_queue();
call    0 returned 645
    38601: 2593:  replaced = FALSE;
    38601: 2594:  if (!append)
branch  0 taken 35712 (fallthrough)
branch  1 taken 2889
    35712: 2595:    line.length = 0;
    38601: 2596:  line.chomped = TRUE;  /* default, until proved otherwise */
        -: 2597:
    38963: 2598:  while ( ! (*input->read_fn)(input) )
call    0 returned 38963
branch  1 taken 693
branch  2 taken 38270 (fallthrough)
        -: 2599:    {
      693: 2600:      closedown(input);
call    0 returned 693
        -: 2601:
      693: 2602:      if (!*input->file_list)
branch  0 taken 331 (fallthrough)
branch  1 taken 362
        -: 2603:	{
      331: 2604:	  line.chomped = FALSE;
      331: 2605:	  return FALSE;
        -: 2606:	}
        -: 2607:
      362: 2608:      if (separate_files)
branch  0 taken 5 (fallthrough)
branch  1 taken 357
        -: 2609:	{
        5: 2610:	  input->line_number = 0;
        5: 2611:	  reset_addresses (the_program);
call    0 returned 5
        -: 2612:	}
        -: 2613:
      362: 2614:      open_next_file (*input->file_list++, input);
call    0 returned 362
        -: 2615:    }
        -: 2616:
    38270: 2617:  ++input->line_number;
    38270: 2618:  return TRUE;
        -: 2619:}
        -: 2620:
        -: 2621:
        -: 2622:static flagT last_file_with_data_p P_((struct input *));
        -: 2623:static flagT
function last_file_with_data_p called 27 returned 100% blocks executed 36%
       27: 2624:last_file_with_data_p(input)
        -: 2625:  struct input *input;
        -: 2626:{
        -: 2627:  for (;;)
    #####: 2628:    {
        -: 2629:      int ch;
        -: 2630:
       27: 2631:      closedown(input);
call    0 returned 27
       27: 2632:      if (!*input->file_list)
branch  0 taken 27 (fallthrough)
branch  1 taken 0
       27: 2633:	return TRUE;
    #####: 2634:      open_next_file(*input->file_list++, input);
call    0 never executed
    #####: 2635:      if (input->fp)
branch  0 never executed
branch  1 never executed
        -: 2636:	{
    #####: 2637:	  if ((ch = getc(input->fp)) != EOF)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2638:	    {
    #####: 2639:	      ungetc(ch, input->fp);
call    0 never executed
    #####: 2640:	      return FALSE;
        -: 2641:	    }
        -: 2642:	}
        -: 2643:    }
        -: 2644:}
        -: 2645:
        -: 2646:/* Determine if we match the `$' address. */
        -: 2647:static flagT test_eof P_((struct input *));
        -: 2648:static flagT
function test_eof called 6434 returned 100% blocks executed 68%
     6434: 2649:test_eof(input)
        -: 2650:  struct input *input;
        -: 2651:{
        -: 2652:  int ch;
        -: 2653:
     6434: 2654:  if (buffer.length)
branch  0 taken 0 (fallthrough)
branch  1 taken 6434
    #####: 2655:    return FALSE;
     6434: 2656:  if (!input->fp)
branch  0 taken 4 (fallthrough)
branch  1 taken 6430
       4*: 2657:    return separate_files || last_file_with_data_p(input);
branch  0 taken 4 (fallthrough)
branch  1 taken 0
call    2 returned 4
branch  3 taken 4 (fallthrough)
branch  4 taken 0
     6430: 2658:  if (feof(input->fp))
call    0 returned 6430
branch  1 taken 0 (fallthrough)
branch  2 taken 6430
    #####: 2659:    return separate_files || last_file_with_data_p(input);
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
     6430: 2660:  if ((ch = getc(input->fp)) == EOF)
call    0 returned 6430
branch  1 taken 23 (fallthrough)
branch  2 taken 6407
      23*: 2661:    return separate_files || last_file_with_data_p(input);
branch  0 taken 23 (fallthrough)
branch  1 taken 0
call    2 returned 23
branch  3 taken 23 (fallthrough)
branch  4 taken 0
     6407: 2662:  ungetc(ch, input->fp);
call    0 returned 6407
     6407: 2663:  return FALSE;
        -: 2664:}
        -: 2665:
        -: 2666:/* Return non-zero if the current line matches the address
        -: 2667:   pointed to by `addr'. */
        -: 2668:static flagT match_an_address_p P_((struct addr *, struct input *));
        -: 2669:static flagT
function match_an_address_p called 36134 returned 100% blocks executed 47%
    36134: 2670:match_an_address_p(addr, input)
        -: 2671:  struct addr *addr;
        -: 2672:  struct input *input;
        -: 2673:{
    36134: 2674:  switch (addr->addr_type)
branch  0 taken 0
branch  1 taken 31918
branch  2 taken 3174
branch  3 taken 0
branch  4 taken 305
branch  5 taken 737
branch  6 taken 0
        -: 2675:    {
    #####: 2676:    case addr_is_null:
    #####: 2677:      return TRUE;
        -: 2678:
    31918: 2679:    case addr_is_regex:
    31918: 2680:      return match_regex(addr->addr_regex, line.active, line.length, 0, NULL, 0);
call    0 returned 31918
        -: 2681:
     3174: 2682:    case addr_is_num:
     3174: 2683:      return (addr->addr_number == input->line_number);
        -: 2684:
    #####: 2685:    case addr_is_num_mod:
    #####: 2686:      if (addr->addr_number < addr->addr_step)
branch  0 never executed
branch  1 never executed
    #####: 2687:	return (addr->addr_number == input->line_number%addr->addr_step);
        -: 2688:      /* addr_number >= step implies we have an extra initial skip */
    #####: 2689:      if (input->line_number < addr->addr_number)
branch  0 never executed
branch  1 never executed
    #####: 2690:	return FALSE;
        -: 2691:      /* normalize */
    #####: 2692:      addr->addr_number %= addr->addr_step;
    #####: 2693:      return (addr->addr_number == 0);
        -: 2694:
      305: 2695:    case addr_is_num2:
        -: 2696:    case addr_is_step:
        -: 2697:    case addr_is_step_mod:
        -: 2698:      /* reminder: these are only meaningful for a2 addresses */
        -: 2699:      /* a2->addr_number needs to be recomputed each time a1 address
        -: 2700:         matches for the step and step_mod types */
      305: 2701:      return (addr->addr_number <= input->line_number);
        -: 2702:
      737: 2703:    case addr_is_last:
      737: 2704:      return test_eof(input);
call    0 returned 737
        -: 2705:
    #####: 2706:    default:
    #####: 2707:      panic(_("INTERNAL ERROR: bad address type"));
call    0 never executed
        -: 2708:    }
        -: 2709:  /*NOTREACHED*/
    #####: 2710:  return FALSE;
        -: 2711:}
        -: 2712:
        -: 2713:/* return non-zero if current address is valid for cmd */
        -: 2714:static flagT match_address_p P_((struct sed_cmd *, struct input *));
        -: 2715:static flagT
function match_address_p called 95907 returned 100% blocks executed 90%
    95907: 2716:match_address_p(cmd, input)
        -: 2717:  struct sed_cmd *cmd;
        -: 2718:  struct input *input;
        -: 2719:{
    95907: 2720:  flagT addr_matched = cmd->a1_matched;
        -: 2721:
    95907: 2722:  if (addr_matched)
branch  0 taken 1582 (fallthrough)
branch  1 taken 94325
        -: 2723:    {
     1582: 2724:      if (match_an_address_p(cmd->a2, input))
call    0 returned 1582
branch  1 taken 45 (fallthrough)
branch  2 taken 1537
       45: 2725:	cmd->a1_matched = FALSE;
        -: 2726:    }
    94325: 2727:  else if (!cmd->a1 || match_an_address_p(cmd->a1, input))
branch  0 taken 34532 (fallthrough)
branch  1 taken 59793
call    2 returned 34532
branch  3 taken 2309 (fallthrough)
branch  4 taken 32223
        -: 2728:    {
    62102: 2729:      addr_matched = TRUE;
    62102: 2730:      if (cmd->a2)
branch  0 taken 60 (fallthrough)
branch  1 taken 62042
        -: 2731:	{
       60: 2732:	  cmd->a1_matched = TRUE;
       60: 2733:	  switch (cmd->a2->addr_type)
branch  0 taken 40
branch  1 taken 0
branch  2 taken 0
branch  3 taken 20
        -: 2734:	    {
       40: 2735:	    case addr_is_regex:
       40: 2736:	      break;
    #####: 2737:	    case addr_is_step:
    #####: 2738:	      cmd->a2->addr_number = input->line_number + cmd->a2->addr_step;
    #####: 2739:	      break;
    #####: 2740:	    case addr_is_step_mod:
    #####: 2741:	      cmd->a2->addr_number = input->line_number + cmd->a2->addr_step
    #####: 2742:				     - (input->line_number%cmd->a2->addr_step);
    #####: 2743:	      break;
       20: 2744:	    default:
       20: 2745:	      if (match_an_address_p(cmd->a2, input))
call    0 returned 20
branch  1 taken 1 (fallthrough)
branch  2 taken 19
        1: 2746:		cmd->a1_matched = FALSE;
       20: 2747:	      break;
        -: 2748:	    }
        -: 2749:	}
        -: 2750:    }
    95907: 2751:  if (cmd->addr_bang)
branch  0 taken 26552 (fallthrough)
branch  1 taken 69355
    26552: 2752:    return !addr_matched;
    69355: 2753:  return addr_matched;
        -: 2754:}
        -: 2755:
        -: 2756:
        -: 2757:static void do_list P_((int line_len));
        -: 2758:static void
function do_list called 1066 returned 100% blocks executed 75%
     1066: 2759:do_list(line_len)
        -: 2760:     int line_len;
        -: 2761:{
     1066: 2762:  unsigned char *p = CAST(unsigned char *)line.active;
     1066: 2763:  countT len = line.length;
     1066: 2764:  countT width = 0;
        -: 2765:  char obuf[180];	/* just in case we encounter a 512-bit char (;-) */
        -: 2766:  char *o;
        -: 2767:  size_t olen;
        -: 2768:
    21498: 2769:  for (; len--; ++p) {
branch  0 taken 20432
branch  1 taken 1066 (fallthrough)
    20432: 2770:      o = obuf;
        -: 2771:      
        -: 2772:      /* Some locales define 8-bit characters as printable.  This makes the
        -: 2773:	 testsuite fail at 8to7.sed because the `l' command in fact will not
        -: 2774:	 convert the 8-bit characters. */
        -: 2775:#if defined isascii || defined HAVE_ISASCII
    20432: 2776:      if (isascii(*p) && ISPRINT(*p)) {
branch  0 taken 20432 (fallthrough)
branch  1 taken 0
branch  2 taken 19907 (fallthrough)
branch  3 taken 525
        -: 2777:#else
        -: 2778:      if (ISPRINT(*p)) {
        -: 2779:#endif
    19907: 2780:	  *o++ = *p;
    19907: 2781:	  if (*p == '\\')
branch  0 taken 0 (fallthrough)
branch  1 taken 19907
    #####: 2782:	    *o++ = '\\';
        -: 2783:      } else {
      525: 2784:	  *o++ = '\\';
      525: 2785:	  switch (*p) {
branch  0 taken 0
branch  1 taken 0
branch  2 taken 0
branch  3 taken 255
branch  4 taken 0
branch  5 taken 168
branch  6 taken 0
branch  7 taken 102
        -: 2786:#if defined __STDC__ && __STDC__-0
    #####: 2787:	    case '\a': *o++ = 'a'; break;
        -: 2788:#else /* Not STDC; we'll just assume ASCII */
        -: 2789:	    case 007:  *o++ = 'a'; break;
        -: 2790:#endif
    #####: 2791:	    case '\b': *o++ = 'b'; break;
    #####: 2792:	    case '\f': *o++ = 'f'; break;
      255: 2793:	    case '\n': *o++ = 'n'; break;
    #####: 2794:	    case '\r': *o++ = 'r'; break;
      168: 2795:	    case '\t': *o++ = 't'; break;
    #####: 2796:	    case '\v': *o++ = 'v'; break;
      102: 2797:	    default:
      102: 2798:	      sprintf(o, "%03o", *p);
      102: 2799:	      o += strlen(o);
      102: 2800:	      break;
        -: 2801:	    }
        -: 2802:      }
    20432: 2803:      olen = o - obuf;
    20432: 2804:      if (width+olen >= line_len && line_len > 0) {
branch  0 taken 122 (fallthrough)
branch  1 taken 20310
branch  2 taken 122 (fallthrough)
branch  3 taken 0
      122: 2805:	  ck_fwrite("\\\n", 1, 2, output_file);
call    0 returned 122
      122: 2806:	  width = 0;
        -: 2807:      }
    20432: 2808:      ck_fwrite(obuf, 1, olen, output_file);
call    0 returned 20432
    20432: 2809:      width += olen;
        -: 2810:  }
     1066: 2811:  ck_fwrite("$\n", 1, 2, output_file);
call    0 returned 1066
     1066: 2812:}
        -: 2813:
        -: 2814:static void do_subst P_((struct subst *));
        -: 2815:static void
function do_subst called 13362 returned 100% blocks executed 79%
    13362: 2816:do_subst(sub)
        -: 2817:  struct subst *sub;
        -: 2818:{
    13362: 2819:  size_t start = 0;	/* where to start scan for (next) match in LINE */
    13362: 2820:  size_t last_end = 0;  /* where did the last successful match end in LINE */
    13362: 2821:  countT count = 0;	/* number of matches found */
        -: 2822:
        -: 2823:#define MAX_BACKREFERENCES 10
        -: 2824:  static struct re_registers regs;
        -: 2825:
    13362: 2826:  if (s_accum.alloc == 0)
branch  0 taken 186 (fallthrough)
branch  1 taken 13176
      186: 2827:    line_init(&s_accum, INITIAL_BUFFER_SIZE);
call    0 returned 186
    13362: 2828:  s_accum.length = 0;
        -: 2829:
        -: 2830:  /* The first part of the loop optimizes s/xxx// when xxx is at the
        -: 2831:     start, and s/xxx$// */
    13362: 2832:  if (!match_regex(sub->regx, line.active, line.length, start,
call    0 returned 13362
branch  1 taken 10853 (fallthrough)
branch  2 taken 2509
        -: 2833:		   &regs, MAX_BACKREFERENCES))
    10853: 2834:    return;
        -: 2835:  
     2509: 2836:  if (!sub->replacement && sub->numb <= 1)
branch  0 taken 8 (fallthrough)
branch  1 taken 2501
branch  2 taken 8 (fallthrough)
branch  3 taken 0
       8*: 2837:    if (regs.start[0] == 0 && !sub->global)
branch  0 taken 0 (fallthrough)
branch  1 taken 8
branch  2 never executed
branch  3 never executed
        -: 2838:      {
        -: 2839:	/* We found a match, set the `replaced' flag. */
    #####: 2840:	replaced = TRUE;
        -: 2841:
    #####: 2842:	line.active += regs.end[0];
    #####: 2843:	line.length -= regs.end[0];
    #####: 2844:	line.alloc -= regs.end[0];
    #####: 2845:	goto did_subst;
        -: 2846:      }
        8: 2847:    else if (regs.end[0] == line.length)
branch  0 taken 8 (fallthrough)
branch  1 taken 0
        -: 2848:      {
        -: 2849:	/* We found a match, set the `replaced' flag. */
        8: 2850:	replaced = TRUE;
        -: 2851:
        8: 2852:	line.length = regs.start[0];
        8: 2853:	goto did_subst;
        -: 2854:      }
        -: 2855:
        -: 2856:  do
        -: 2857:    {
        -: 2858:      struct replacement *p;
     3498: 2859:      enum replacement_types repl_mod = 0;
        -: 2860:
     3498: 2861:      size_t offset = regs.start[0];
     3498: 2862:      size_t matched = regs.end[0] - regs.start[0];
        -: 2863:
        -: 2864:      /* Copy stuff to the left of this match into the output string. */
     3498: 2865:      if (start < offset)
branch  0 taken 972 (fallthrough)
branch  1 taken 2526
      972: 2866:	str_append(&s_accum, line.active + start, offset - start);
call    0 returned 972
        -: 2867:
        -: 2868:      /* If we're counting up to the Nth match, are we there yet?
        -: 2869:         And even if we are there, there is another case we have to
        -: 2870:	 skip: are we matching an empty string immediately following
        -: 2871:         another match?
        -: 2872:
        -: 2873:         This latter case avoids that baaaac, when passed through
        -: 2874:         s,a*,x,g, gives `xbxxcx' instead of xbxcx.  This behavior is
        -: 2875:         unacceptable because it is not consistently applied (for
        -: 2876:         example, `baaaa' gives `xbx', not `xbxx'). */
    3498*: 2877:      if ((count > 0 && offset == last_end && matched == 0) || ++count < sub->numb)
branch  0 taken 997 (fallthrough)
branch  1 taken 2501
branch  2 taken 504 (fallthrough)
branch  3 taken 493
branch  4 taken 504 (fallthrough)
branch  5 taken 0
branch  6 taken 0 (fallthrough)
branch  7 taken 3498
        -: 2878:	  {
        -: 2879:	  /* If the match was vacuous, skip ahead one character
        -: 2880:	   * anyway.
        -: 2881:	   */
    #####: 2882:	  if (matched == 0 && offset < line.length)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2883:	    matched = 1;
        -: 2884:
    #####: 2885:	  str_append(&s_accum, line.active + offset, matched);
call    0 never executed
    #####: 2886:	  start = offset + matched;
    #####: 2887:	  continue;
        -: 2888:	}
        -: 2889:
        -: 2890:      /* We found a match, set the `replaced' flag. */
     3498: 2891:      replaced = TRUE;
        -: 2892:
     3498: 2893:      last_end = regs.end[0];
        -: 2894:
        -: 2895:      /* Now expand the replacement string into the output string. */
     7060: 2896:      for (p=sub->replacement; p; p=p->next)
branch  0 taken 3562
branch  1 taken 3498 (fallthrough)
        -: 2897:	{
     3562: 2898:	  int i = p->subst_id;
        -: 2899:	  enum replacement_types curr_type;
        -: 2900:
        -: 2901:	  /* Apply a \[lu] modifier that was given earlier, but which we
        -: 2902:	     have not had yet the occasion to apply.  But don't do it
        -: 2903:	     if this replacement has a modifier of its own. */
     7124: 2904:	  curr_type = (p->repl_type & repl_modifiers)
        -: 2905:	    ? p->repl_type
    3562*: 2906:	    : p->repl_type | repl_mod;
branch  0 taken 0 (fallthrough)
branch  1 taken 3562
        -: 2907:
     3562: 2908:	  repl_mod = 0;
     3562: 2909:	  if (p->prefix_length)
branch  0 taken 3551 (fallthrough)
branch  1 taken 11
        -: 2910:	    {
     3551: 2911:	      str_append_modified(&s_accum, p->prefix, p->prefix_length,
call    0 returned 3551
        -: 2912:				  curr_type);
     3551: 2913:	      curr_type &= ~repl_modifiers;
        -: 2914:	    }
        -: 2915:
     3562: 2916:	  if (0 <= i)
branch  0 taken 21 (fallthrough)
branch  1 taken 3541
      21*: 2917:	    if (regs.end[i] == regs.start[i] && p->repl_type & repl_modifiers)
branch  0 taken 0 (fallthrough)
branch  1 taken 21
branch  2 never executed
branch  3 never executed
        -: 2918:	      /* Save this modifier, we shall apply it later.
        -: 2919:		 e.g. in s/()([a-z])/\u\1\2/
        -: 2920:		 the \u modifier is applied to \2, not \1 */
    #####: 2921:	      repl_mod = curr_type & repl_modifiers;
        -: 2922:
        -: 2923:	    else
       21: 2924:	      str_append_modified(&s_accum, line.active + regs.start[i],
       21: 2925:				  CAST(size_t)(regs.end[i] - regs.start[i]),
call    0 returned 21
        -: 2926:				  curr_type);
        -: 2927:	}
        -: 2928:
     3498: 2929:      start = regs.end[0];
     3498: 2930:      if (!sub->global || start == line.length)
branch  0 taken 3326 (fallthrough)
branch  1 taken 172
branch  2 taken 1861 (fallthrough)
branch  3 taken 1465
        -: 2931:	break;
        -: 2932:
        -: 2933:      /* If the match was vacuous, skip over one character
        -: 2934:       * and add that character to the output.
        -: 2935:       */
     1861: 2936:      if (regs.start[0] == regs.end[0])
branch  0 taken 484 (fallthrough)
branch  1 taken 1377
        -: 2937:	{
      484: 2938:	  str_append(&s_accum, line.active + offset, 1);
call    0 returned 484
      484: 2939:	  ++start;
        -: 2940:	}
        -: 2941:    }
     1861: 2942:  while (match_regex(sub->regx, line.active, line.length, start,
call    0 returned 1861
branch  1 taken 997
branch  2 taken 864 (fallthrough)
        -: 2943:		     &regs, MAX_BACKREFERENCES));
        -: 2944:
        -: 2945:  /* Copy stuff to the right of the last match into the output string. */
        -: 2946:#ifndef FAULTY_F_KRM_12
     2501: 2947:  if (start < line.length)
branch  0 taken 897 (fallthrough)
branch  1 taken 1604
        -: 2948:#else
        -: 2949:    if (start > line.length)
        -: 2950:#endif
      897: 2951:    str_append(&s_accum, line.active + start, line.length-start);
call    0 returned 897
     2501: 2952:  s_accum.chomped = line.chomped;
        -: 2953:
        -: 2954:  /* Exchange line and s_accum.  This can be much cheaper
        -: 2955:     than copying s_accum.active into line.text (for huge lines). */
     2501: 2956:  line_exchange(&line, &s_accum);
call    0 returned 2501
     2509: 2957: did_subst:
        -: 2958:  
        -: 2959:  /* Finish up. */
     2509: 2960:  if (sub->print & 1)
branch  0 taken 1297 (fallthrough)
branch  1 taken 1212
     1297: 2961:    output_line(line.active, line.length, line.chomped, output_file);
call    0 returned 1297
        -: 2962:  
     2509: 2963:  if (sub->eval) 
branch  0 taken 0 (fallthrough)
branch  1 taken 2509
        -: 2964:    {
        -: 2965:#ifdef HAVE_POPEN
        -: 2966:      FILE *pipe;
        -: 2967:      s_accum.length = 0;
        -: 2968:      
        -: 2969:      str_append (&line, "", 1);
        -: 2970:      pipe = popen(line.active, "r");
        -: 2971:      
        -: 2972:      if (pipe != NULL) 
        -: 2973:	{
        -: 2974:	  while (!feof (pipe)) 
        -: 2975:	    {
        -: 2976:	      char buf[4096];
        -: 2977:	      int n = fread (buf, sizeof(char), 4096, pipe);
        -: 2978:	      if (n > 0)
        -: 2979:		str_append(&s_accum, buf, n);
        -: 2980:	    }
        -: 2981:	  
        -: 2982:	  pclose (pipe);
        -: 2983:
        -: 2984:	  line_exchange(&line, &s_accum);
        -: 2985:	  if (line.length &&
        -: 2986:	      line.active[line.length - 1] == '\n')
        -: 2987:	    line.length--;
        -: 2988:	}
        -: 2989:      else
        -: 2990:	panic(_("error in subprocess"));
        -: 2991:#else
    #####: 2992:      panic(_("option `e' not supported"));
call    0 never executed
        -: 2993:#endif
        -: 2994:    } 
        -: 2995:  
     2509: 2996:  if (sub->print & 2)
branch  0 taken 0 (fallthrough)
branch  1 taken 2509
    #####: 2997:    output_line(line.active, line.length, line.chomped, output_file);
call    0 never executed
     2509: 2998:  if (sub->fp)
branch  0 taken 1440 (fallthrough)
branch  1 taken 1069
     1440: 2999:    output_line(line.active, line.length, line.chomped, sub->fp);
call    0 returned 1440
        -: 3000:}
        -: 3001:
        -: 3002:#ifdef EXPERIMENTAL_DASH_N_OPTIMIZATION
        -: 3003:/* Used to attempt a simple-minded optimization. */
        -: 3004:
        -: 3005:static countT branches;
        -: 3006:
        -: 3007:static countT count_branches P_((struct vector *));
        -: 3008:static countT
        -: 3009:count_branches(program)
        -: 3010:  struct vector *program;
        -: 3011:{
        -: 3012:  struct sed_cmd *cur_cmd = program->v;
        -: 3013:  countT isn_cnt = program->v_length;
        -: 3014:  countT cnt = 0;
        -: 3015:
        -: 3016:  while (isn_cnt-- > 0)
        -: 3017:    {
        -: 3018:      switch (cur_cmd->cmd)
        -: 3019:	{
        -: 3020:	case 'b':
        -: 3021:	case 't':
        -: 3022:	case 'T':
        -: 3023:	case '{':
        -: 3024:	  ++cnt;
        -: 3025:	}
        -: 3026:    }
        -: 3027:  return cnt;
        -: 3028:}
        -: 3029:
        -: 3030:static struct sed_cmd *shrink_program P_((struct vector *, struct sed_cmd *));
        -: 3031:static struct sed_cmd *
        -: 3032:shrink_program(vec, cur_cmd)
        -: 3033:  struct vector *vec;
        -: 3034:  struct sed_cmd *cur_cmd;
        -: 3035:{
        -: 3036:  struct sed_cmd *v = vec->v;
        -: 3037:  struct sed_cmd *last_cmd = v + vec->v_length;
        -: 3038:  struct sed_cmd *p;
        -: 3039:  countT cmd_cnt;
        -: 3040:
        -: 3041:  for (p=v; p < cur_cmd; ++p)
        -: 3042:    if (p->cmd != ':')
        -: 3043:      MEMCPY(v++, p, sizeof *v);
        -: 3044:  cmd_cnt = v - vec->v;
        -: 3045:
        -: 3046:  for (; p < last_cmd; ++p)
        -: 3047:    if (p->cmd != ':')
        -: 3048:      MEMCPY(v++, p, sizeof *v);
        -: 3049:  vec->v_length = v - vec->v;
        -: 3050:
        -: 3051:  return (0 < vec->v_length) ? (vec->v + cmd_cnt) : CAST(struct sed_cmd *)0;
        -: 3052:}
        -: 3053:#endif /*EXPERIMENTAL_DASH_N_OPTIMIZATION*/
        -: 3054:
        -: 3055:/* Execute the program `vec' on the current input line.
        -: 3056:   Return exit status if caller should quit, -1 otherwise. */
        -: 3057:static int execute_program P_((struct vector *, struct input *));
        -: 3058:static int
function execute_program called 32591 returned 100% blocks executed 71%
    32591: 3059:execute_program(vec, input)
        -: 3060:  struct vector *vec;
        -: 3061:  struct input *input;
        -: 3062:{
        -: 3063:  struct sed_cmd *cur_cmd;
        -: 3064:  struct sed_cmd *end_cmd;
        -: 3065:
    32591: 3066:  cur_cmd = vec->v;
    32591: 3067:  end_cmd = vec->v + vec->v_length;
   123690: 3068:  while (cur_cmd < end_cmd)
branch  0 taken 95907
branch  1 taken 27783 (fallthrough)
        -: 3069:    {
    95907: 3070:      if (match_address_p(cur_cmd, input))
call    0 returned 95907
branch  1 taken 85182 (fallthrough)
branch  2 taken 10725
        -: 3071:	{
    85182: 3072:	  switch (cur_cmd->cmd)
branch  0 taken 546
branch  1 taken 24112
branch  2 taken 25636
branch  3 taken 2495
branch  4 taken 1624
branch  5 taken 1381
branch  6 taken 0
branch  7 taken 10
branch  8 taken 10
branch  9 taken 18
branch 10 taken 12
branch 11 taken 391
branch 12 taken 1066
branch 13 taken 0
branch 14 taken 2798
branch 15 taken 2899
branch 16 taken 2054
branch 17 taken 2357
branch 18 taken 0
branch 19 taken 29
branch 20 taken 99
branch 21 taken 0
branch 22 taken 13362
branch 23 taken 13
branch 24 taken 0
branch 25 taken 1689
branch 26 taken 0
branch 27 taken 5
branch 28 taken 2348
branch 29 taken 228
branch 30 taken 0
        -: 3073:	    {
      546: 3074:	    case 'a':
        -: 3075:	      {
      546: 3076:		struct append_queue *aq = next_append_slot();
call    0 returned 546
      546: 3077:		aq->text = cur_cmd->x.cmd_txt.text;
      546: 3078:		aq->textlen = cur_cmd->x.cmd_txt.text_length;
        -: 3079:	      }
      546: 3080:	      break;
        -: 3081:
    24112: 3082:	    case '{':
        -: 3083:	    case 'b':
    24112: 3084:	      cur_cmd = vec->v + cur_cmd->x.jump_index;
    24112: 3085:	      continue;
        -: 3086:
    25636: 3087:	    case '}':
        -: 3088:	    case ':':
        -: 3089:	      /* Executing labels and block-ends are easy. */
    25636: 3090:	      break;
        -: 3091:
     2495: 3092:	    case 'c':
     2495: 3093:	      if (!cur_cmd->a1_matched)
branch  0 taken 1727 (fallthrough)
branch  1 taken 768
     1727: 3094:		output_line(cur_cmd->x.cmd_txt.text,
call    0 returned 1727
        -: 3095:			    cur_cmd->x.cmd_txt.text_length, FALSE, output_file);
        -: 3096:	      /* POSIX.2 is silent about c starting a new cycle,
        -: 3097:		 but it seems to be expected (and make sense). */
        -: 3098:	      /* Fall Through */
        -: 3099:	    case 'd':
     4119: 3100:	      line.length = 0;
     4119: 3101:	      line.chomped = FALSE;
     4119: 3102:	      return -1;
        -: 3103:
     1381: 3104:	    case 'D':
      739: 3105:	      {
     1381: 3106:		char *p = memchr(line.active, '\n', line.length);
     1381: 3107:		if (!p)
branch  0 taken 642 (fallthrough)
branch  1 taken 739
        -: 3108:		  {
      642: 3109:		    line.length = 0;
      642: 3110:		    line.chomped = FALSE;
      642: 3111:		    return -1;
        -: 3112:		  }
      739: 3113:		++p;
      739: 3114:		line.alloc -= p - line.active;
      739: 3115:		line.length -= p - line.active;
      739: 3116:		line.active += p - line.active;
        -: 3117:
        -: 3118:		/* reset to start next cycle without reading a new line: */
      739: 3119:		cur_cmd = vec->v;
      739: 3120:		continue;
        -: 3121:	      }
        -: 3122:
    #####: 3123:	    case 'e': {
        -: 3124:#ifdef HAVE_POPEN
        -: 3125:	      FILE *pipe;
        -: 3126:	      int cmd_length = cur_cmd->x.cmd_txt.text_length;
        -: 3127:	      if (s_accum.alloc == 0)
        -: 3128:		line_init(&s_accum, INITIAL_BUFFER_SIZE);
        -: 3129:	      s_accum.length = 0;
        -: 3130:
        -: 3131:	      if (!cmd_length)
        -: 3132:		{
        -: 3133:		  str_append (&line, "", 1);
        -: 3134:		  pipe = popen(line.active, "r");
        -: 3135:		} 
        -: 3136:	      else
        -: 3137:		{
        -: 3138:		  cur_cmd->x.cmd_txt.text[cmd_length - 1] = 0;
        -: 3139:		  pipe = popen(cur_cmd->x.cmd_txt.text, "r");
        -: 3140:		}
        -: 3141:
        -: 3142:	      if (pipe != NULL) 
        -: 3143:		{
        -: 3144:		  while (!feof (pipe)) 
        -: 3145:		    {
        -: 3146:		      char buf[4096];
        -: 3147:		      int n = fread (buf, sizeof(char), 4096, pipe);
        -: 3148:		      if (n > 0)
        -: 3149:			if (!cmd_length)
        -: 3150:			  str_append(&s_accum, buf, n);
        -: 3151:			else
        -: 3152:			  output_line(buf, n, FALSE, output_file);
        -: 3153:		    }
        -: 3154:		  
        -: 3155:		  pclose (pipe);
        -: 3156:		  if (!cmd_length)
        -: 3157:		    {
        -: 3158:		      /* Store into pattern space for plain `e' commands */
        -: 3159:		      if (s_accum.length &&
        -: 3160:			  s_accum.active[s_accum.length - 1] == '\n')
        -: 3161:			s_accum.length--;
        -: 3162:
        -: 3163:		      /* Exchange line and s_accum.  This can be much
        -: 3164:			 cheaper than copying s_accum.active into line.text
        -: 3165:			 (for huge lines). */
        -: 3166:		      line_exchange(&line, &s_accum);
        -: 3167:		    }
        -: 3168:		}
        -: 3169:	      else
        -: 3170:		panic(_("error in subprocess"));
        -: 3171:#else
    #####: 3172:	      panic(_("`e' command not supported"));
call    0 never executed
        -: 3173:#endif
    #####: 3174:	      break;
        -: 3175:	    }
        -: 3176:
       10: 3177:	    case 'g':
       10: 3178:	      line_copy(&hold, &line);
call    0 returned 10
       10: 3179:	      break;
        -: 3180:
       10: 3181:	    case 'G':
       10: 3182:	      line_append(&hold, &line);
call    0 returned 10
       10: 3183:	      break;
        -: 3184:
       18: 3185:	    case 'h':
       18: 3186:	      line_copy(&line, &hold);
call    0 returned 18
       18: 3187:	      break;
        -: 3188:
       12: 3189:	    case 'H':
       12: 3190:	      line_append(&line, &hold);
call    0 returned 12
       12: 3191:	      break;
        -: 3192:
      391: 3193:	    case 'i':
      391: 3194:	      output_line(cur_cmd->x.cmd_txt.text,
call    0 returned 391
        -: 3195:			  cur_cmd->x.cmd_txt.text_length, FALSE, output_file);
      391: 3196:	      break;
        -: 3197:
     1066: 3198:	    case 'l':
    1066*: 3199:	      do_list(cur_cmd->x.int_arg == -1
branch  0 taken 0 (fallthrough)
branch  1 taken 1066
call    2 returned 1066
        -: 3200:		      ? lcmd_out_line_len
        -: 3201:		      : cur_cmd->x.int_arg);
     1066: 3202:	      break;
        -: 3203:
    #####: 3204:	    case 'L':
    #####: 3205:	      fmt(line.active, line.active + line.length,
call    0 never executed
    #####: 3206:		  cur_cmd->x.int_arg == -1
branch  0 never executed
branch  1 never executed
        -: 3207:		  ? lcmd_out_line_len
        -: 3208:		  : cur_cmd->x.int_arg,
        -: 3209:		  output_file);
    #####: 3210:	      break;
        -: 3211:
     2798: 3212:	    case 'n':
     2798: 3213:	      if (!no_default_output)
branch  0 taken 783 (fallthrough)
branch  1 taken 2015
      783: 3214:		output_line(line.active, line.length, line.chomped, output_file);
call    0 returned 783
     2798: 3215:	      if (test_eof(input) || !read_pattern_space(input, vec, FALSE))
call    0 returned 2798
branch  1 taken 2790 (fallthrough)
branch  2 taken 8
call    3 returned 2790
branch  4 taken 0 (fallthrough)
branch  5 taken 2790
        8: 3216:		return -1;
     2790: 3217:	      break;
        -: 3218:
     2899: 3219:	    case 'N':
     2899: 3220:	      str_append(&line, "\n", 1);
call    0 returned 2899
     2899: 3221:	      if (test_eof(input) || !read_pattern_space(input, vec, TRUE))
call    0 returned 2899
branch  1 taken 2889 (fallthrough)
branch  2 taken 10
call    3 returned 2889
branch  4 taken 0 (fallthrough)
branch  5 taken 2889
       10: 3222:		return -1;
     2889: 3223:	      break;
        -: 3224:
     2054: 3225:	    case 'p':
     2054: 3226:	      output_line(line.active, line.length, line.chomped, output_file);
call    0 returned 2054
     2054: 3227:	      break;
        -: 3228:
     2357: 3229:	    case 'P':
        -: 3230:	      {
     2357: 3231:		char *p = memchr(line.active, '\n', line.length);
     2357: 3232:		output_line(line.active, p ? p - line.active : line.length,
branch  0 taken 1548 (fallthrough)
branch  1 taken 809
branch  2 taken 809 (fallthrough)
branch  3 taken 1548
call    4 returned 2357
        -: 3233:			    p ? 1 : line.chomped, output_file);
        -: 3234:	      }
     2357: 3235:	      break;
        -: 3236:
    #####: 3237:	    case 'Q':
    #####: 3238:	      line.length = 0;
    #####: 3239:	      line.chomped = FALSE;
        -: 3240:	      /* Fall through */
        -: 3241:
       29: 3242:	    case 'q':
      29*: 3243:	      return cur_cmd->x.int_arg == -1 ? 0 : cur_cmd->x.int_arg;
branch  0 taken 0 (fallthrough)
branch  1 taken 29
        -: 3244:
       99: 3245:	    case 'r':
       99: 3246:	      if (cur_cmd->x.fname)
branch  0 taken 99 (fallthrough)
branch  1 taken 0
        -: 3247:		{
       99: 3248:		  struct append_queue *aq = next_append_slot();
call    0 returned 99
       99: 3249:		  aq->fname = cur_cmd->x.fname;
        -: 3250:		}
       99: 3251:	      break;
        -: 3252:
    #####: 3253:	    case 'R':
    #####: 3254:	      if (cur_cmd->x.fp && !feof (cur_cmd->x.fp))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 3255:		{
        -: 3256:		  struct append_queue *aq;
        -: 3257:		  size_t buflen;
    #####: 3258:		  char *text = NULL;
        -: 3259:		  int result;
        -: 3260:
    #####: 3261:		  result = getline (&text, &buflen, cur_cmd->x.fp);
call    0 never executed
        -: 3262:
    #####: 3263:		  if (result != EOF)
branch  0 never executed
branch  1 never executed
        -: 3264:		    {
    #####: 3265:		      aq = next_append_slot();
call    0 never executed
    #####: 3266:		      aq->free = TRUE;
    #####: 3267:		      aq->text = text;
    #####: 3268:		      aq->textlen = result;
        -: 3269:		    }
        -: 3270:		}
    #####: 3271:	      break;
        -: 3272:
    13362: 3273:	    case 's':
    13362: 3274:	      do_subst(cur_cmd->x.cmd_subst);
call    0 returned 13362
    13362: 3275:	      break;
        -: 3276:
       13: 3277:	    case 't':
       13: 3278:	      if (replaced)
branch  0 taken 6 (fallthrough)
branch  1 taken 7
        -: 3279:		{
        6: 3280:		  replaced = FALSE;
        6: 3281:		  cur_cmd = vec->v + cur_cmd->x.jump_index;
        6: 3282:		  continue;
        -: 3283:		}
        7: 3284:	      break;
        -: 3285:
    #####: 3286:	    case 'T':
    #####: 3287:	      if (!replaced)
branch  0 never executed
branch  1 never executed
        -: 3288:		{
    #####: 3289:		  cur_cmd = vec->v + cur_cmd->x.jump_index;
    #####: 3290:		  continue;
        -: 3291:		}
        -: 3292:	      else
    #####: 3293:		replaced = FALSE;
    #####: 3294:	      break;
        -: 3295:
     1689: 3296:	    case 'w':
     1689: 3297:	      if (cur_cmd->x.fp)
branch  0 taken 1689 (fallthrough)
branch  1 taken 0
     1689: 3298:		output_line(line.active, line.length,
call    0 returned 1689
        -: 3299:			    line.chomped, cur_cmd->x.fp);
     1689: 3300:	      break;
        -: 3301:
    #####: 3302:	    case 'W':
    #####: 3303:	      if (cur_cmd->x.fp)
branch  0 never executed
branch  1 never executed
        -: 3304:	        {
    #####: 3305:		  char *p = memchr(line.active, '\n', line.length);
    #####: 3306:		  output_line(line.active, p ? p - line.active : line.length,
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -: 3307:			      p ? 1 : line.chomped, cur_cmd->x.fp);
        -: 3308:	        }
    #####: 3309:	      break;
        -: 3310:
        5: 3311:	    case 'x':
        5: 3312:	      line_exchange(&line, &hold);
call    0 returned 5
        5: 3313:	      break;
        -: 3314:
     2348: 3315:	    case 'y':
        -: 3316:	      {
        -: 3317:#if defined MBS_SUPPORT && !defined REG_PERL
        -: 3318:               if (MB_CUR_MAX > 1)
        -: 3319:                 {
        -: 3320:                   int idx, prev_idx; /* index in the input line.  */
        -: 3321:                   char **trans;
        -: 3322:                   mbstate_t cur_stat;
        -: 3323:                   memset(&cur_stat, 0, sizeof(mbstate_t));
        -: 3324:                   for (idx = 0; idx < line.length;)
        -: 3325:                     {
        -: 3326:                       int mbclen, i;
        -: 3327:                       mbclen = mbrlen(line.active + idx, line.length - idx,
        -: 3328:                                       &cur_stat);
        -: 3329:                       /* An invalid sequence, or a truncated multibyte
        -: 3330:                          character.  We treat it as a singlebyte character.
        -: 3331:                       */
        -: 3332:                       if (mbclen == (size_t) -1 || mbclen == (size_t) -2
        -: 3333:                           || mbclen == 0)
        -: 3334:                         mbclen = 1;
        -: 3335:
        -: 3336:                       trans = cur_cmd->x.translatemb;
        -: 3337:                       /* `i' indicate i-th translate pair.  */
        -: 3338:                       for (i = 0; trans[2*i] != NULL; i++)
        -: 3339:                         {
        -: 3340:                           if (strncmp(line.active + idx, trans[2*i], mbclen)
        -: 3341:                               == 0)
        -: 3342:                             {
        -: 3343:                               flagT move_remain_buffer = FALSE;
        -: 3344:                               int trans_len = strlen(trans[2*i+1]);
        -: 3345:
        -: 3346:                               if (mbclen < trans_len)
        -: 3347:                                 {
        -: 3348:                                   int new_len;
        -: 3349:                                   new_len = line.length + 1 + trans_len - mbclen;
        -: 3350:                                   /* We must extend the line buffer.  */
        -: 3351:                                   if (line.alloc < new_len)
        -: 3352:                                     {
        -: 3353:                                       /* And we must resize the buffer.  */
        -: 3354:                                       resize_line(&line, new_len);
        -: 3355:                                     }
        -: 3356:                                   move_remain_buffer = TRUE;
        -: 3357:                                 }
        -: 3358:                               else if (mbclen > trans_len)
        -: 3359:                                 {
        -: 3360:                                   /* We must truncate the line buffer.  */
        -: 3361:                                   move_remain_buffer = TRUE;
        -: 3362:                                 }
        -: 3363:                               prev_idx = idx;
        -: 3364:                               if (move_remain_buffer)
        -: 3365:                                 {
        -: 3366:                                   int move_len, move_offset;
        -: 3367:                                   char *move_from, *move_to;
        -: 3368:                                   /* Move the remaining with \0.  */
        -: 3369:                                   move_from = line.active + idx + mbclen;
        -: 3370:                                   move_to = line.active + idx + trans_len;
        -: 3371:                                   move_len = line.length + 1 - idx - mbclen;
        -: 3372:                                   move_offset = trans_len - mbclen;
        -: 3373:                                   memmove(move_to, move_from, move_len);
        -: 3374:                                   line.length += move_offset;
        -: 3375:                                   idx += move_offset;
        -: 3376:                                 }
        -: 3377:                               strncpy(line.active + prev_idx, trans[2*i+1],
        -: 3378:                                       trans_len);
        -: 3379:                               break;
        -: 3380:                             }
        -: 3381:                         }
        -: 3382:                       idx += mbclen;
        -: 3383:                     }
        -: 3384:                 }
        -: 3385:               else
        -: 3386:#endif /* MBS_SUPPORT */
        -: 3387:                 {
        -: 3388:                   unsigned char *p, *e;
     2348: 3389:                   p = CAST(unsigned char *)line.active;
    45006: 3390:                   for (e=p+line.length; p<e; ++p)
branch  0 taken 42658
branch  1 taken 2348 (fallthrough)
    42658: 3391:                     *p = cur_cmd->x.translate[*p];
        -: 3392:                 }
        -: 3393:	      }
     2348: 3394:	      break;
        -: 3395:
      228: 3396:	    case '=':
      228: 3397:	      fprintf(output_file, "%lu\n",
      228: 3398:		      CAST(unsigned long)input->line_number);
call    0 returned 228
      228: 3399:	      break;
        -: 3400:
    #####: 3401:	    default:
    #####: 3402:	      panic(_("INTERNAL ERROR: Bad cmd %c"), cur_cmd->cmd);
call    0 never executed
        -: 3403:	    }
        -: 3404:	}
        -: 3405:
        -: 3406:#ifdef EXPERIMENTAL_DASH_N_OPTIMIZATION
        -: 3407:      /* If our top-level program consists solely of commands with
        -: 3408:       * addr_is_num addresses then once we past the last mentioned
        -: 3409:       * line we should be able to quit if no_default_output is true,
        -: 3410:       * or otherwise quickly copy input to output.  Now whether this
        -: 3411:       * optimization is a win or not depends on how cheaply we can
        -: 3412:       * implement this for the cases where it doesn't help, as
        -: 3413:       * compared against how much time is saved.  One semantic
        -: 3414:       * difference (which I think is an improvement) is that *this*
        -: 3415:       * version will terminate after printing line two in the script
        -: 3416:       * "yes | sed -n 2p". 
        -: 3417:       *
        -: 3418:       * Don't use this when in-place editing is active, because line
        -: 3419:       * numbers restart each time then. */
        -: 3420:      else if (output_file == stdout)
        -: 3421:	{
        -: 3422:	  /* can we ever match again? */
        -: 3423:	  if (cur_cmd->a1->addr_type == addr_is_num &&
        -: 3424:	      ((input->line_number < cur_cmd->a1->addr_number)
        -: 3425:	       != !cur_cmd->addr_bang))
        -: 3426:	    {
        -: 3427:	      /* skip all this next time */
        -: 3428:	      cur_cmd->a1->addr_type = addr_is_null;
        -: 3429:	      cur_cmd->addr_bang = TRUE;
        -: 3430:
        -: 3431:	      /* can we make an optimization? */
        -: 3432:	      if (cur_cmd->cmd == 'b' || cur_cmd->cmd == 't'
        -: 3433:		  || cur_cmd->cmd == '{')
        -: 3434:		--branches;
        -: 3435:	      cur_cmd->cmd = ':';	/* replace with no-op */
        -: 3436:	      if (branches == 0)
        -: 3437:		{
        -: 3438:		  /* whew!  all that just so that we can get to here! */
        -: 3439:		  cur_cmd = shrink_program(vec, cur_cmd);
        -: 3440:		  if (!cur_cmd && no_default_output)
        -: 3441:		    return 0;
        -: 3442:		  end_cmd = vec->v + vec->v_length;
        -: 3443:		  if (!cur_cmd)
        -: 3444:		    cur_cmd = end_cmd;
        -: 3445:		  continue;
        -: 3446:		}
        -: 3447:	    }
        -: 3448:	}
        -: 3449:#endif /*EXPERIMENTAL_DASH_N_OPTIMIZATION*/
        -: 3450:
        -: 3451:      /* this is buried down here so that a "continue" statement can skip it */
    66242: 3452:      ++cur_cmd;
        -: 3453:    }
    27783: 3454:    return -1;
        -: 3455:}
        -: 3456:
        -: 3457:
        -: 3458:
        -: 3459:/* Apply the compiled script to all the named files. */
        -: 3460:int
function process_files called 360 returned 100% blocks executed 100%
      360: 3461:process_files(the_program, argv)
        -: 3462:  struct vector *the_program;
        -: 3463:  char **argv;
        -: 3464:{
        -: 3465:  static char dash[] = "-";
        -: 3466:  static char *stdin_argv[2] = { dash, NULL };
        -: 3467:  struct input input;
        -: 3468:  int status;
        -: 3469:
      360: 3470:  line_init(&line, INITIAL_BUFFER_SIZE);
call    0 returned 360
      360: 3471:  line_init(&hold, 0);
call    0 returned 360
      360: 3472:  line_init(&buffer, 0);
call    0 returned 360
        -: 3473:
        -: 3474:#ifdef EXPERIMENTAL_DASH_N_OPTIMIZATION
        -: 3475:  branches = count_branches(the_program);
        -: 3476:#endif /*EXPERIMENTAL_DASH_N_OPTIMIZATION*/
      360: 3477:  input.file_list = stdin_argv;
      360: 3478:  if (argv && *argv)
branch  0 taken 360 (fallthrough)
branch  1 taken 0
branch  2 taken 359 (fallthrough)
branch  3 taken 1
      359: 3479:    input.file_list = argv;
      360: 3480:  input.bad_count = 0;
      360: 3481:  input.line_number = 0;
      360: 3482:  input.read_fn = read_always_fail;
      360: 3483:  input.fp = NULL;
        -: 3484:
      360: 3485:  status = EXIT_SUCCESS;
    32922: 3486:  while (read_pattern_space(&input, the_program, FALSE))
call    0 returned 32922
branch  1 taken 32591
branch  2 taken 331 (fallthrough)
        -: 3487:    {
    32591: 3488:      status = execute_program(the_program, &input);
call    0 returned 32591
    32591: 3489:      if (!no_default_output)
branch  0 taken 13484 (fallthrough)
branch  1 taken 19107
    13484: 3490:	output_line(line.active, line.length, line.chomped, output_file);
call    0 returned 13484
    32591: 3491:      if (status == -1)
branch  0 taken 32562 (fallthrough)
branch  1 taken 29
    32562: 3492:	status = EXIT_SUCCESS;
        -: 3493:      else
       29: 3494:	break;
        -: 3495:    }
      360: 3496:  closedown(&input);
call    0 returned 360
        -: 3497:
        -: 3498:#ifdef DEBUG_LEAKS
        -: 3499:  /* We're about to exit, so these free()s are redundant.
        -: 3500:     But if we're running under a memory-leak detecting
        -: 3501:     implementation of malloc(), we want to explicitly
        -: 3502:     deallocate in order to avoid extraneous noise from
        -: 3503:     the allocator. */
        -: 3504:  release_append_queue();
        -: 3505:  FREE(buffer.text);
        -: 3506:  FREE(hold.text);
        -: 3507:  FREE(line.text);
        -: 3508:  FREE(s_accum.text);
        -: 3509:#endif /*DEBUG_LEAKS*/
        -: 3510:
      360: 3511:  if (input.bad_count)
branch  0 taken 1 (fallthrough)
branch  1 taken 359
        1: 3512:    status = 2;
        -: 3513:
      360: 3514:  return status;
        -: 3515:}
        -: 3516:/* `L' command implementation for GNU sed, based on GNU fmt 1.22.
        -: 3517:   Copyright (C) 1994, 1995, 1996, 2002, 2003 Free Software Foundation, Inc.
        -: 3518:
        -: 3519:   This program is free software; you can redistribute it and/or modify
        -: 3520:   it under the terms of the GNU General Public License as published by
        -: 3521:   the Free Software Foundation; either version 2, or (at your option)
        -: 3522:   any later version.
        -: 3523:
        -: 3524:   This program is distributed in the hope that it will be useful,
        -: 3525:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 3526:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 3527:   GNU General Public License for more details.
        -: 3528:
        -: 3529:   You should have received a copy of the GNU General Public License
        -: 3530:   along with this program; if not, write to the Free Software Foundation,
        -: 3531:   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
        -: 3532:
        -: 3533:/* GNU fmt was written by Ross Paterson <rap@doc.ic.ac.uk>.  */
        -: 3534:
        -: 3535:#include "config.h"
        -: 3536:#include "basicdefs.h"
        -: 3537:
        -: 3538:#include <stdio.h>
        -: 3539:#include <ctype.h>
        -: 3540:#include <sys/types.h>
        -: 3541:
        -: 3542:#if HAVE_LIMITS_H
        -: 3543:# include <limits.h>
        -: 3544:#endif
        -: 3545:
        -: 3546:#ifndef UINT_MAX
        -: 3547:# define UINT_MAX ((unsigned int) ~(unsigned int) 0)
        -: 3548:#endif
        -: 3549:
        -: 3550:#ifndef INT_MAX
        -: 3551:# define INT_MAX ((int) (UINT_MAX >> 1))
        -: 3552:#endif
        -: 3553:
        -: 3554:/* The following parameters represent the program's idea of what is
        -: 3555:   "best".  Adjust to taste, subject to the caveats given.  */
        -: 3556:
        -: 3557:/* Prefer lines to be LEEWAY % shorter than the maximum width, giving
        -: 3558:   room for optimization.  */
        -: 3559:#define	LEEWAY	7
        -: 3560:
        -: 3561:/* Costs and bonuses are expressed as the equivalent departure from the
        -: 3562:   optimal line length, multiplied by 10.  e.g. assigning something a
        -: 3563:   cost of 50 means that it is as bad as a line 5 characters too short
        -: 3564:   or too long.  The definition of SHORT_COST(n) should not be changed.
        -: 3565:   However, EQUIV(n) may need tuning.  */
        -: 3566:
        -: 3567:typedef long COST;
        -: 3568:
        -: 3569:#define	MAXCOST	(~(((unsigned long) 1) << (8 * sizeof (COST) -1)))
        -: 3570:
        -: 3571:#define	SQR(n)		((n) * (n))
        -: 3572:#define	EQUIV(n)	SQR ((COST) (n))
        -: 3573:
        -: 3574:/* Cost of a filled line n chars longer or shorter than best_width.  */
        -: 3575:#define	SHORT_COST(n)	EQUIV ((n) * 10)
        -: 3576:
        -: 3577:/* Cost of the difference between adjacent filled lines.  */
        -: 3578:#define	RAGGED_COST(n)	(SHORT_COST (n) / 2)
        -: 3579:
        -: 3580:/* Basic cost per line.  */
        -: 3581:#define	LINE_COST	EQUIV (70)
        -: 3582:
        -: 3583:/* Cost of breaking a line after the first word of a sentence, where
        -: 3584:   the length of the word is N.  */
        -: 3585:#define	WIDOW_COST(n)	(EQUIV (200) / ((n) + 2))
        -: 3586:
        -: 3587:/* Cost of breaking a line before the last word of a sentence, where
        -: 3588:   the length of the word is N.  */
        -: 3589:#define	ORPHAN_COST(n)	(EQUIV (150) / ((n) + 2))
        -: 3590:
        -: 3591:/* Bonus for breaking a line at the end of a sentence.  */
        -: 3592:#define	SENTENCE_BONUS	EQUIV (50)
        -: 3593:
        -: 3594:/* Cost of breaking a line after a period not marking end of a sentence.
        -: 3595:   With the definition of sentence we are using (borrowed from emacs, see
        -: 3596:   get_line()) such a break would then look like a sentence break.  Hence
        -: 3597:   we assign a very high cost -- it should be avoided unless things are
        -: 3598:   really bad.  */
        -: 3599:#define	NOBREAK_COST	EQUIV (600)
        -: 3600:
        -: 3601:/* Bonus for breaking a line before open parenthesis.  */
        -: 3602:#define	PAREN_BONUS	EQUIV (40)
        -: 3603:
        -: 3604:/* Bonus for breaking a line after other punctuation.  */
        -: 3605:#define	PUNCT_BONUS	EQUIV(40)
        -: 3606:
        -: 3607:/* Credit for breaking a long paragraph one line later.  */
        -: 3608:#define	LINE_CREDIT	EQUIV(3)
        -: 3609:
        -: 3610:/* Size of paragraph buffer in words.  Longer paragraphs are handled
        -: 3611:   neatly (cf. flush_paragraph()), so there's little to gain by making
        -: 3612:   these larger.  */
        -: 3613:#define	MAXWORDS	1000
        -: 3614:
        -: 3615:#define GETC()          (parabuf == end_of_parabuf ? EOF : *parabuf++)
        -: 3616:
        -: 3617:/* Extra ctype(3)-style macros.  */
        -: 3618:
        -: 3619:#define	isopen(c)	(strchr ("([`'\"", (c)) != NULL)
        -: 3620:#define	isclose(c)	(strchr (")]'\"", (c)) != NULL)
        -: 3621:#define	isperiod(c)	(strchr (".?!", (c)) != NULL)
        -: 3622:
        -: 3623:/* Size of a tab stop, for expansion on input and re-introduction on
        -: 3624:   output.  */
        -: 3625:#define	TABWIDTH	8
        -: 3626:
        -: 3627:/* Word descriptor structure.  */
        -: 3628:
        -: 3629:typedef struct Word WORD;
        -: 3630:
        -: 3631:struct Word
        -: 3632:  {
        -: 3633:
        -: 3634:    /* Static attributes determined during input.  */
        -: 3635:
        -: 3636:    const char *text;		/* the text of the word */
        -: 3637:    short length;		/* length of this word */
        -: 3638:    short space;		/* the size of the following space */
        -: 3639:    flagT paren:1;		/* starts with open paren */
        -: 3640:    flagT period:1;		/* ends in [.?!])* */
        -: 3641:    flagT punct:1;		/* ends in punctuation */
        -: 3642:    flagT final:1;		/* end of sentence */
        -: 3643:
        -: 3644:    /* The remaining fields are computed during the optimization.  */
        -: 3645:
        -: 3646:    short line_length;		/* length of the best line starting here */
        -: 3647:    COST best_cost;		/* cost of best paragraph starting here */
        -: 3648:    WORD *next_break;		/* break which achieves best_cost */
        -: 3649:  };
        -: 3650:
        -: 3651:/* Forward declarations.  */
        -: 3652:
        -: 3653:extern void fmt P_ ((char *line, char *line_end, int max_length, FILE *output_file));
        -: 3654:static flagT get_paragraph P_ ((void));
        -: 3655:static int get_line P_ ((int c));
        -: 3656:static int get_space P_ ((int c));
        -: 3657:static int copy_rest P_ ((int c));
        -: 3658:static flagT same_para P_ ((int c));
        -: 3659:static void flush_paragraph P_ ((void));
        -: 3660:static void fmt_paragraph P_ ((void));
        -: 3661:static void check_punctuation P_ ((WORD *w));
        -: 3662:static COST base_cost P_ ((WORD *this));
        -: 3663:static COST line_cost P_ ((WORD *next, int len));
        -: 3664:static void put_paragraph P_ ((WORD *finish));
        -: 3665:static void put_line P_ ((WORD *w, int indent));
        -: 3666:static void put_word P_ ((WORD *w));
        -: 3667:static void put_space P_ ((int space));
        -: 3668:
        -: 3669:/* Option values.  */
        -: 3670:
        -: 3671:/* User-supplied maximum line width (default WIDTH).  The only output
        -: 3672:   lines
        -: 3673:   longer than this will each comprise a single word.  */
        -: 3674:static int max_width;
        -: 3675:
        -: 3676:/* Space for the paragraph text.  */
        -: 3677:static char *parabuf;
        -: 3678:
        -: 3679:/* End of space for the paragraph text.  */
        -: 3680:static char *end_of_parabuf;
        -: 3681:
        -: 3682:/* The file on which we output */
        -: 3683:static FILE *outfile;
        -: 3684:
        -: 3685:/* Values derived from the option values.  */
        -: 3686:
        -: 3687:/* The preferred width of text lines, set to LEEWAY % less than max_width.  */
        -: 3688:static int best_width;
        -: 3689:
        -: 3690:/* Dynamic variables.  */
        -: 3691:
        -: 3692:/* Start column of the character most recently read from the input file.  */
        -: 3693:static int in_column;
        -: 3694:
        -: 3695:/* Start column of the next character to be written to stdout.  */
        -: 3696:static int out_column;
        -: 3697:
        -: 3698:/* The words of a paragraph -- longer paragraphs are handled neatly
        -: 3699:   (cf. flush_paragraph()).  */
        -: 3700:static WORD words[MAXWORDS];
        -: 3701:
        -: 3702:/* A pointer into the above word array, indicating the first position
        -: 3703:   after the last complete word.  Sometimes it will point at an incomplete
        -: 3704:   word.  */
        -: 3705:static WORD *word_limit;
        -: 3706:
        -: 3707:/* Indentation of the first line of the current paragraph.  */
        -: 3708:static int first_indent;
        -: 3709:
        -: 3710:/* Indentation of other lines of the current paragraph */
        -: 3711:static int other_indent;
        -: 3712:
        -: 3713:/* The last character read from the input file.  */
        -: 3714:static int next_char;
        -: 3715:
        -: 3716:/* If nonzero, the length of the last line output in the current
        -: 3717:   paragraph, used to charge for raggedness at the split point for long
        -: 3718:   paragraphs chosen by fmt_paragraph().  */
        -: 3719:static int last_line_length;
        -: 3720:
        -: 3721:/* read file F and send formatted output to stdout.  */
        -: 3722:
        -: 3723:void
function fmt called 0 returned 0% blocks executed 0%
    #####: 3724:fmt (char *line, char *line_end, int max_length, FILE *output_file)
        -: 3725:{
    #####: 3726:  parabuf = line;
    #####: 3727:  end_of_parabuf = line_end;
    #####: 3728:  outfile = output_file;
        -: 3729:
    #####: 3730:  max_width = max_length;
    #####: 3731:  best_width = max_width * (201 - 2 * LEEWAY) / 200;
        -: 3732:
    #####: 3733:  in_column = 0;
    #####: 3734:  other_indent = 0;
    #####: 3735:  next_char = GETC();
branch  0 never executed
branch  1 never executed
    #####: 3736:  while (get_paragraph ())
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 3737:    {
    #####: 3738:      fmt_paragraph ();
call    0 never executed
    #####: 3739:      put_paragraph (word_limit);
call    0 never executed
        -: 3740:    }
    #####: 3741:}
        -: 3742:
        -: 3743:/* Read a paragraph from input file F.  A paragraph consists of a
        -: 3744:   maximal number of non-blank (excluding any prefix) lines
        -: 3745:   with the same indent.
        -: 3746:
        -: 3747:   Return FALSE if end-of-file was encountered before the start of a
        -: 3748:   paragraph, else TRUE.  */
        -: 3749:
        -: 3750:static flagT
function get_paragraph called 0 returned 0% blocks executed 0%
    #####: 3751:get_paragraph ()
        -: 3752:{
        -: 3753:  register int c;
        -: 3754:
    #####: 3755:  last_line_length = 0;
    #####: 3756:  c = next_char;
        -: 3757:
        -: 3758:  /* Scan (and copy) blank lines, and lines not introduced by the prefix.  */
        -: 3759:
    #####: 3760:  while (c == '\n' || c == EOF)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 3761:    {
    #####: 3762:      c = copy_rest (c);
call    0 never executed
    #####: 3763:      if (c == EOF)
branch  0 never executed
branch  1 never executed
        -: 3764:	{
    #####: 3765:	  next_char = EOF;
    #####: 3766:	  return FALSE;
        -: 3767:	}
    #####: 3768:      putc ('\n', outfile);
call    0 never executed
    #####: 3769:      c = GETC();
branch  0 never executed
branch  1 never executed
        -: 3770:    }
        -: 3771:
        -: 3772:  /* Got a suitable first line for a paragraph.  */
        -: 3773:
    #####: 3774:  first_indent = in_column;
    #####: 3775:  word_limit = words;
    #####: 3776:  c = get_line (c);
call    0 never executed
        -: 3777:
        -: 3778:  /* Read rest of paragraph.  */
        -: 3779:
    #####: 3780:  other_indent = in_column;
    #####: 3781:  while (same_para (c) && in_column == other_indent)
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 3782:    c = get_line (c);
call    0 never executed
        -: 3783:
    #####: 3784:  (word_limit - 1)->period = (word_limit - 1)->final = TRUE;
    #####: 3785:  next_char = c;
    #####: 3786:  return TRUE;
        -: 3787:}
        -: 3788:
        -: 3789:/* Copy to the output a blank line.  In the latter, C is \n or EOF.
        -: 3790:   Return the character (\n or EOF) ending the line.  */
        -: 3791:
        -: 3792:static int
function copy_rest called 0 returned 0% blocks executed 0%
    #####: 3793:copy_rest (register int c)
        -: 3794:{
    #####: 3795:  out_column = 0;
    #####: 3796:  while (c != '\n' && c != EOF)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 3797:    {
    #####: 3798:      putc (c, outfile);
call    0 never executed
    #####: 3799:      c = GETC();
branch  0 never executed
branch  1 never executed
        -: 3800:    }
    #####: 3801:  return c;
        -: 3802:}
        -: 3803:
        -: 3804:/* Return TRUE if a line whose first non-blank character after the
        -: 3805:   prefix (if any) is C could belong to the current paragraph,
        -: 3806:   otherwise FALSE.  */
        -: 3807:
        -: 3808:static flagT
function same_para called 0 returned 0% blocks executed 0%
    #####: 3809:same_para (register int c)
        -: 3810:{
    #####: 3811:  return (c != '\n' && c != EOF);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 3812:}
        -: 3813:
        -: 3814:/* Read a line from the input data given first non-blank character C
        -: 3815:   after the prefix, and the following indent, and break it into words.
        -: 3816:   A word is a maximal non-empty string of non-white characters.  A word
        -: 3817:   ending in [.?!]["')\]]* and followed by end-of-line or at least two
        -: 3818:   spaces ends a sentence, as in emacs.
        -: 3819:
        -: 3820:   Return the first non-blank character of the next line.  */
        -: 3821:
        -: 3822:static int
function get_line called 0 returned 0% blocks executed 0%
    #####: 3823:get_line (register int c)
        -: 3824:{
        -: 3825:  int start;
        -: 3826:  register WORD *end_of_word;
        -: 3827:
    #####: 3828:  end_of_word = &words[MAXWORDS - 2];
        -: 3829:
        -: 3830:  do
        -: 3831:    {				/* for each word in a line */
        -: 3832:
        -: 3833:      /* Scan word.  */
        -: 3834:
    #####: 3835:      word_limit->text = parabuf - 1;
        -: 3836:      do
    #####: 3837:	c = GETC();
branch  0 never executed
branch  1 never executed
    #####: 3838:      while (c != EOF && !ISSPACE (c));
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3839:      word_limit->length = parabuf - word_limit->text - (c != EOF);
    #####: 3840:      in_column += word_limit->length;
        -: 3841:
    #####: 3842:      check_punctuation (word_limit);
call    0 never executed
        -: 3843:
        -: 3844:      /* Scan inter-word space.  */
        -: 3845:
    #####: 3846:      start = in_column;
    #####: 3847:      c = get_space (c);
call    0 never executed
    #####: 3848:      word_limit->space = in_column - start;
    #####: 3849:      word_limit->final = (c == EOF
    #####: 3850:			   || (word_limit->period
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3851:			       && (c == '\n' || word_limit->space > 1)));
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3852:      if (c == '\n' || c == EOF)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3853:	word_limit->space = word_limit->final ? 2 : 1;
branch  0 never executed
branch  1 never executed
    #####: 3854:      if (word_limit == end_of_word)
branch  0 never executed
branch  1 never executed
    #####: 3855:	flush_paragraph ();
call    0 never executed
    #####: 3856:      word_limit++;
    #####: 3857:      if (c == EOF)
branch  0 never executed
branch  1 never executed
        -: 3858:	{
    #####: 3859:	  in_column = first_indent;
    #####: 3860:	  return EOF;
        -: 3861:	}
        -: 3862:    }
    #####: 3863:  while (c != '\n');
branch  0 never executed
branch  1 never executed
        -: 3864:
    #####: 3865:  in_column = 0;
    #####: 3866:  c = GETC();
branch  0 never executed
branch  1 never executed
    #####: 3867:  return get_space (c);
call    0 never executed
        -: 3868:}
        -: 3869:
        -: 3870:/* Read blank characters from the input data, starting with C, and keeping
        -: 3871:   in_column up-to-date.  Return first non-blank character.  */
        -: 3872:
        -: 3873:static int
function get_space called 0 returned 0% blocks executed 0%
    #####: 3874:get_space (register int c)
        -: 3875:{
        -: 3876:  for (;;)
        -: 3877:    {
    #####: 3878:      if (c == ' ')
branch  0 never executed
branch  1 never executed
    #####: 3879:	in_column++;
    #####: 3880:      else if (c == '\t')
branch  0 never executed
branch  1 never executed
    #####: 3881:	in_column = (in_column / TABWIDTH + 1) * TABWIDTH;
        -: 3882:      else
    #####: 3883:	return c;
    #####: 3884:      c = GETC();
branch  0 never executed
branch  1 never executed
        -: 3885:    }
        -: 3886:}
        -: 3887:
        -: 3888:/* Set extra fields in word W describing any attached punctuation.  */
        -: 3889:
        -: 3890:static void
function check_punctuation called 0 returned 0% blocks executed 0%
    #####: 3891:check_punctuation (register WORD *w)
        -: 3892:{
        -: 3893:  register const char *start, *finish;
        -: 3894:
    #####: 3895:  start = w->text;
    #####: 3896:  finish = start + (w->length - 1);
    #####: 3897:  w->paren = isopen (*start);
    #####: 3898:  w->punct = ISPUNCT (*finish);
    #####: 3899:  while (isclose (*finish) && finish > start)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3900:    finish--;
    #####: 3901:  w->period = isperiod (*finish);
    #####: 3902:}
        -: 3903:
        -: 3904:/* Flush part of the paragraph to make room.  This function is called on
        -: 3905:   hitting the limit on the number of words or characters.  */
        -: 3906:
        -: 3907:static void
function flush_paragraph called 0 returned 0% blocks executed 0%
    #####: 3908:flush_paragraph (void)
        -: 3909:{
        -: 3910:  WORD *split_point;
        -: 3911:  register WORD *w;
        -: 3912:  COST best_break;
        -: 3913:
        -: 3914:  /* - format what you have so far as a paragraph,
        -: 3915:     - find a low-cost line break near the end,
        -: 3916:     - output to there,
        -: 3917:     - make that the start of the paragraph.  */
        -: 3918:
    #####: 3919:  fmt_paragraph ();
call    0 never executed
        -: 3920:
        -: 3921:  /* Choose a good split point.  */
        -: 3922:
    #####: 3923:  split_point = word_limit;
    #####: 3924:  best_break = MAXCOST;
    #####: 3925:  for (w = words->next_break; w != word_limit; w = w->next_break)
branch  0 never executed
branch  1 never executed
        -: 3926:    {
    #####: 3927:      if (w->best_cost - w->next_break->best_cost < best_break)
branch  0 never executed
branch  1 never executed
        -: 3928:	{
    #####: 3929:	  split_point = w;
    #####: 3930:	  best_break = w->best_cost - w->next_break->best_cost;
        -: 3931:	}
    #####: 3932:      if (best_break <= MAXCOST - LINE_CREDIT)
branch  0 never executed
branch  1 never executed
    #####: 3933:	best_break += LINE_CREDIT;
        -: 3934:    }
    #####: 3935:  put_paragraph (split_point);
call    0 never executed
        -: 3936:
        -: 3937:  /* Copy words from split_point down to word -- we use memmove because
        -: 3938:     the source and target may overlap.  */
        -: 3939:
    #####: 3940:  memmove ((char *) words, (char *) split_point,
    #####: 3941:	 (word_limit - split_point + 1) * sizeof (WORD));
    #####: 3942:  word_limit -= split_point - words;
    #####: 3943:}
        -: 3944:
        -: 3945:/* Compute the optimal formatting for the whole paragraph by computing
        -: 3946:   and remembering the optimal formatting for each suffix from the empty
        -: 3947:   one to the whole paragraph.  */
        -: 3948:
        -: 3949:static void
function fmt_paragraph called 0 returned 0% blocks executed 0%
    #####: 3950:fmt_paragraph (void)
        -: 3951:{
        -: 3952:  register WORD *start, *w;
        -: 3953:  register int len;
        -: 3954:  register COST wcost, best;
        -: 3955:  int saved_length;
        -: 3956:
    #####: 3957:  word_limit->best_cost = 0;
    #####: 3958:  saved_length = word_limit->length;
    #####: 3959:  word_limit->length = max_width;	/* sentinel */
        -: 3960:
    #####: 3961:  for (start = word_limit - 1; start >= words; start--)
branch  0 never executed
branch  1 never executed
        -: 3962:    {
    #####: 3963:      best = MAXCOST;
    #####: 3964:      len = start == words ? first_indent : other_indent;
branch  0 never executed
branch  1 never executed
        -: 3965:
        -: 3966:      /* At least one word, however long, in the line.  */
        -: 3967:
    #####: 3968:      w = start;
    #####: 3969:      len += w->length;
        -: 3970:      do
        -: 3971:	{
    #####: 3972:	  w++;
        -: 3973:
        -: 3974:	  /* Consider breaking before w.  */
        -: 3975:
    #####: 3976:	  wcost = line_cost (w, len) + w->best_cost;
call    0 never executed
    #####: 3977:	  if (start == words && last_line_length > 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3978:	    wcost += RAGGED_COST (len - last_line_length);
    #####: 3979:	  if (wcost < best)
branch  0 never executed
branch  1 never executed
        -: 3980:	    {
    #####: 3981:	      best = wcost;
    #####: 3982:	      start->next_break = w;
    #####: 3983:	      start->line_length = len;
        -: 3984:	    }
    #####: 3985:	  len += (w - 1)->space + w->length;	/* w > start >= words */
        -: 3986:	}
    #####: 3987:      while (len < max_width);
branch  0 never executed
branch  1 never executed
    #####: 3988:      start->best_cost = best + base_cost (start);
call    0 never executed
        -: 3989:    }
        -: 3990:
    #####: 3991:  word_limit->length = saved_length;
    #####: 3992:}
        -: 3993:
        -: 3994:/* Return the constant component of the cost of breaking before the
        -: 3995:   word THIS.  */
        -: 3996:
        -: 3997:static COST
function base_cost called 0 returned 0% blocks executed 0%
    #####: 3998:base_cost (register WORD *this)
        -: 3999:{
        -: 4000:  register COST cost;
        -: 4001:
    #####: 4002:  cost = LINE_COST;
        -: 4003:
    #####: 4004:  if (this > words)
branch  0 never executed
branch  1 never executed
        -: 4005:    {
    #####: 4006:      if ((this - 1)->period)
branch  0 never executed
branch  1 never executed
        -: 4007:	{
    #####: 4008:	  if ((this - 1)->final)
branch  0 never executed
branch  1 never executed
    #####: 4009:	    cost -= SENTENCE_BONUS;
        -: 4010:	  else
    #####: 4011:	    cost += NOBREAK_COST;
        -: 4012:	}
    #####: 4013:      else if ((this - 1)->punct)
branch  0 never executed
branch  1 never executed
    #####: 4014:	cost -= PUNCT_BONUS;
    #####: 4015:      else if (this > words + 1 && (this - 2)->final)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4016:	cost += WIDOW_COST ((this - 1)->length);
        -: 4017:    }
        -: 4018:
    #####: 4019:  if (this->paren)
branch  0 never executed
branch  1 never executed
    #####: 4020:    cost -= PAREN_BONUS;
    #####: 4021:  else if (this->final)
branch  0 never executed
branch  1 never executed
    #####: 4022:    cost += ORPHAN_COST (this->length);
        -: 4023:
    #####: 4024:  return cost;
        -: 4025:}
        -: 4026:
        -: 4027:/* Return the component of the cost of breaking before word NEXT that
        -: 4028:   depends on LEN, the length of the line beginning there.  */
        -: 4029:
        -: 4030:static COST
function line_cost called 0 returned 0% blocks executed 0%
    #####: 4031:line_cost (register WORD *next, register int len)
        -: 4032:{
        -: 4033:  register int n;
        -: 4034:  register COST cost;
        -: 4035:
    #####: 4036:  if (next == word_limit)
branch  0 never executed
branch  1 never executed
    #####: 4037:    return 0;
    #####: 4038:  n = best_width - len;
    #####: 4039:  cost = SHORT_COST (n);
    #####: 4040:  if (next->next_break != word_limit)
branch  0 never executed
branch  1 never executed
        -: 4041:    {
    #####: 4042:      n = len - next->line_length;
    #####: 4043:      cost += RAGGED_COST (n);
        -: 4044:    }
    #####: 4045:  return cost;
        -: 4046:}
        -: 4047:
        -: 4048:/* Output to stdout a paragraph from word up to (but not including)
        -: 4049:   FINISH, which must be in the next_break chain from word.  */
        -: 4050:
        -: 4051:static void
function put_paragraph called 0 returned 0% blocks executed 0%
    #####: 4052:put_paragraph (register WORD *finish)
        -: 4053:{
        -: 4054:  register WORD *w;
        -: 4055:
    #####: 4056:  put_line (words, first_indent);
call    0 never executed
    #####: 4057:  for (w = words->next_break; w != finish; w = w->next_break)
branch  0 never executed
branch  1 never executed
    #####: 4058:    put_line (w, other_indent);
call    0 never executed
    #####: 4059:}
        -: 4060:
        -: 4061:/* Output to stdout the line beginning with word W, beginning in column
        -: 4062:   INDENT, including the prefix (if any).  */
        -: 4063:
        -: 4064:static void
function put_line called 0 returned 0% blocks executed 0%
    #####: 4065:put_line (register WORD *w, int indent)
        -: 4066:{
        -: 4067:  register WORD *endline;
    #####: 4068:  out_column = 0;
    #####: 4069:  put_space (indent);
call    0 never executed
        -: 4070:
    #####: 4071:  endline = w->next_break - 1;
    #####: 4072:  for (; w != endline; w++)
branch  0 never executed
branch  1 never executed
        -: 4073:    {
    #####: 4074:      put_word (w);
call    0 never executed
    #####: 4075:      put_space (w->space);
call    0 never executed
        -: 4076:    }
    #####: 4077:  put_word (w);
call    0 never executed
    #####: 4078:  last_line_length = out_column;
    #####: 4079:  putc ('\n', outfile);
call    0 never executed
    #####: 4080:}
        -: 4081:
        -: 4082:/* Output to stdout the word W.  */
        -: 4083:
        -: 4084:static void
function put_word called 0 returned 0% blocks executed 0%
    #####: 4085:put_word (register WORD *w)
        -: 4086:{
        -: 4087:  register const char *s;
        -: 4088:  register int n;
        -: 4089:
    #####: 4090:  s = w->text;
    #####: 4091:  for (n = w->length; n != 0; n--)
branch  0 never executed
branch  1 never executed
    #####: 4092:    putc (*s++, outfile);
call    0 never executed
    #####: 4093:  out_column += w->length;
    #####: 4094:}
        -: 4095:
        -: 4096:/* Output to stdout SPACE spaces, or equivalent tabs.  */
        -: 4097:
        -: 4098:static void
function put_space called 0 returned 0% blocks executed 0%
    #####: 4099:put_space (int space)
        -: 4100:{
    #####: 4101:  out_column += space;
    #####: 4102:  while (space--)
branch  0 never executed
branch  1 never executed
    #####: 4103:    putc (' ', outfile);
call    0 never executed
    #####: 4104:}
        -: 4105:/*  Functions from hack's utils library.
        -: 4106:    Copyright (C) 1989, 1990, 1991, 1998, 1999, 2003
        -: 4107:    Free Software Foundation, Inc.
        -: 4108:
        -: 4109:    This program is free software; you can redistribute it and/or modify
        -: 4110:    it under the terms of the GNU General Public License as published by
        -: 4111:    the Free Software Foundation; either version 2, or (at your option)
        -: 4112:    any later version.
        -: 4113:
        -: 4114:    This program is distributed in the hope that it will be useful,
        -: 4115:    but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 4116:    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 4117:    GNU General Public License for more details.
        -: 4118:
        -: 4119:    You should have received a copy of the GNU General Public License
        -: 4120:    along with this program; if not, write to the Free Software
        -: 4121:    Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
        -: 4122:
        -: 4123:#include "config.h"
        -: 4124:
        -: 4125:#include <stdio.h>
        -: 4126:
        -: 4127:#include <errno.h>
        -: 4128:#ifndef errno
        -: 4129:  extern int errno;
        -: 4130:#endif
        -: 4131:
        -: 4132:#ifdef HAVE_STRINGS_H
        -: 4133:# include <strings.h>
        -: 4134:#else
        -: 4135:# include <string.h>
        -: 4136:#endif /* HAVE_STRINGS_H */
        -: 4137:
        -: 4138:#ifdef HAVE_STDLIB_H
        -: 4139:# include <stdlib.h>
        -: 4140:#endif /* HAVE_STDLIB_H */
        -: 4141:
        -: 4142:#include "basicdefs.h"
        -: 4143:#include "utils.h"
        -: 4144:
        -: 4145:const char *myname;
        -: 4146:
        -: 4147:void do_ck_fclose P_((FILE *stream));
        -: 4148:
        -: 4149:/* Print an error message and exit */
        -: 4150:#if !defined __STDC__ || !(__STDC__-0)
        -: 4151:# include <varargs.h>
        -: 4152:# define VSTART(l,a)	va_start(l)
        -: 4153:# undef stderr
        -: 4154:# define stderr stdout
        -: 4155:void
        -: 4156:panic(str, va_alist)
        -: 4157:  char *str;
        -: 4158:  va_dcl
        -: 4159:#else /*__STDC__*/
        -: 4160:# include <stdarg.h>
        -: 4161:# define VSTART(l,a)	va_start(l, a)
        -: 4162:
        -: 4163:/*
        -: 4164:  Non-determinism bug fix
        -: 4165:  SIR July 2006, Kyle R. Murphy
        -: 4166:*/
        -: 4167:#undef stderr
        -: 4168:#define stderr stdout
        -: 4169:void
function panic called 364 returned 0% blocks executed 100%
      364: 4170:panic(const char *str, ...)
        -: 4171:#endif /* __STDC__ */
        -: 4172:{
        -: 4173:  va_list iggy;
        -: 4174:#undef stderr
        -: 4175:#define stderr stdout
      364: 4176:  fprintf(stderr, "%s: ", myname);
call    0 returned 364
      364: 4177:  VSTART(iggy, str);
        -: 4178:#ifndef HAVE_VPRINTF
        -: 4179:# ifndef HAVE_DOPRNT
        -: 4180:  fputs(str, stderr);	/* not great, but perhaps better than nothing... */
        -: 4181:# else /* HAVE_DOPRNT */
        -: 4182:  _doprnt(str, &iggy, stderr);
        -: 4183:# endif /* HAVE_DOPRNT */
        -: 4184:#else /* HAVE_VFPRINTF */
      364: 4185:  vfprintf(stderr, str, iggy);
call    0 returned 364
        -: 4186:#endif /* HAVE_VFPRINTF */
      364: 4187:  va_end(iggy);
      364: 4188:  putc('\n', stderr);
call    0 returned 364
      364: 4189:  exit(4);
        -: 4190:}
        -: 4191:
        -: 4192:
        -: 4193:/* Store information about files opened with ck_fopen
        -: 4194:   so that error messages from ck_fread, ck_fwrite, etc. can print the
        -: 4195:   name of the file that had the error */
        -: 4196:
        -: 4197:struct id
        -: 4198:  {
        -: 4199:    FILE *fp;
        -: 4200:    char *name;
        -: 4201:    struct id *link;
        -: 4202:  };
        -: 4203:
        -: 4204:static struct id *utils_id_s = NULL;
        -: 4205:
        -: 4206:/* Internal routine to get a filename from utils_id_s */
        -: 4207:static const char *utils_fp_name P_((FILE *fp));
        -: 4208:static const char *
function utils_fp_name called 362 returned 100% blocks executed 46%
      362: 4209:utils_fp_name(fp)
        -: 4210:  FILE *fp;
        -: 4211:{
        -: 4212:  struct id *p;
        -: 4213:
     362*: 4214:  for (p=utils_id_s; p; p=p->link)
branch  0 taken 0
branch  1 taken 362 (fallthrough)
    #####: 4215:    if (p->fp == fp)
branch  0 never executed
branch  1 never executed
    #####: 4216:      return p->name;
      362: 4217:  if (fp == stdin)
branch  0 taken 0 (fallthrough)
branch  1 taken 362
    #####: 4218:    return "stdin";
      362: 4219:  else if (fp == stdout)
branch  0 taken 362 (fallthrough)
branch  1 taken 0
      362: 4220:    return "stdout";
    #####: 4221:  else if (fp == stderr)
branch  0 never executed
branch  1 never executed
    #####: 4222:    return "stderr";
        -: 4223:
    #####: 4224:  return "<unknown>";
        -: 4225:}
        -: 4226:
        -: 4227:/* Panic on failing fopen */
        -: 4228:FILE *
function ck_fopen called 996 returned 100% blocks executed 89%
      996: 4229:ck_fopen(name, mode, fail)
        -: 4230:  const char *name;
        -: 4231:  const char *mode;
        -: 4232:  flagT fail;
        -: 4233:{
        -: 4234:  FILE *fp;
        -: 4235:  struct id *p;
        -: 4236:
      996: 4237:  fp = fopen (name, mode);
call    0 returned 996
      996: 4238:  if (!fp)
branch  0 taken 3 (fallthrough)
branch  1 taken 993
        -: 4239:    {
        3: 4240:      if (fail)
branch  0 taken 2 (fallthrough)
branch  1 taken 1
        2: 4241:        panic(_("Couldn't open file %s: %s"), name, strerror(errno));
call    0 returned 2
call    1 returned 0
        -: 4242:
        1: 4243:      return NULL;
        -: 4244:    }
        -: 4245:
     1542: 4246:  for (p=utils_id_s; p; p=p->link)
branch  0 taken 549
branch  1 taken 993 (fallthrough)
        -: 4247:    {
      549: 4248:      if (fp == p->fp)
branch  0 taken 0 (fallthrough)
branch  1 taken 549
        -: 4249:	{
    #####: 4250:	  FREE(p->name);
call    0 never executed
    #####: 4251:	  break;
        -: 4252:	}
        -: 4253:    }
      993: 4254:  if (!p)
branch  0 taken 993 (fallthrough)
branch  1 taken 0
        -: 4255:    {
      993: 4256:      p = MALLOC(1, struct id);
call    0 returned 993
      993: 4257:      p->link = utils_id_s;
      993: 4258:      utils_id_s = p;
        -: 4259:    }
      993: 4260:  p->name = ck_strdup(name);
call    0 returned 993
      993: 4261:  p->fp = fp;
      993: 4262:  return fp;
        -: 4263:}
        -: 4264:
        -: 4265:/* Panic on failing fwrite */
        -: 4266:void
function ck_fwrite called 60633 returned 100% blocks executed 45%
    60633: 4267:ck_fwrite(ptr, size, nmemb, stream)
        -: 4268:  const VOID *ptr;
        -: 4269:  size_t size;
        -: 4270:  size_t nmemb;
        -: 4271:  FILE *stream;
        -: 4272:{
    60633: 4273:  clearerr(stream);
call    0 returned 60633
    60633: 4274:  if (size && fwrite(ptr, size, nmemb, stream) != nmemb)
branch  0 taken 60633 (fallthrough)
branch  1 taken 0
call    2 returned 60633
branch  3 taken 0 (fallthrough)
branch  4 taken 60633
    #####: 4275:    panic(ngettext("couldn't write %d item to %s: %s",
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -: 4276:		   "couldn't write %d items to %s: %s", nmemb), 
    #####: 4277:		nmemb, utils_fp_name(stream), strerror(errno));
call    0 never executed
    60633: 4278:}
        -: 4279:
        -: 4280:/* Panic on failing fread */
        -: 4281:size_t
function ck_fread called 198 returned 100% blocks executed 73%
      198: 4282:ck_fread(ptr, size, nmemb, stream)
        -: 4283:  VOID *ptr;
        -: 4284:  size_t size;
        -: 4285:  size_t nmemb;
        -: 4286:  FILE *stream;
        -: 4287:{
      198: 4288:  clearerr(stream);
call    0 returned 198
      198: 4289:  if (size && (nmemb=fread(ptr, size, nmemb, stream)) <= 0 && ferror(stream))
branch  0 taken 198 (fallthrough)
branch  1 taken 0
call    2 returned 198
branch  3 taken 99 (fallthrough)
branch  4 taken 99
call    5 returned 99
branch  6 taken 0 (fallthrough)
branch  7 taken 99
    #####: 4290:    panic(_("read error on %s: %s"), utils_fp_name(stream), strerror(errno));
call    0 never executed
call    1 never executed
call    2 never executed
        -: 4291:
      198: 4292:  return nmemb;
        -: 4293:}
        -: 4294:
        -: 4295:/* Panic on failing fflush */
        -: 4296:void
function ck_fflush called 5300 returned 100% blocks executed 50%
     5300: 4297:ck_fflush(stream)
        -: 4298:  FILE *stream;
        -: 4299:{
     5300: 4300:  clearerr(stream);
call    0 returned 5300
    5300*: 4301:  if (fflush(stream) == EOF && errno != EBADF)
call    0 returned 5300
branch  1 taken 0 (fallthrough)
branch  2 taken 5300
branch  3 never executed
branch  4 never executed
    #####: 4302:    panic("Couldn't flush %s: %s", utils_fp_name(stream), strerror(errno));
call    0 never executed
call    1 never executed
call    2 never executed
     5300: 4303:}
        -: 4304:
        -: 4305:/* Panic on failing fclose */
        -: 4306:void
function ck_fclose called 1357 returned 73% blocks executed 100%
     1357: 4307:ck_fclose(stream)
        -: 4308:  FILE *stream;
        -: 4309:{
        -: 4310:  struct id r;
        -: 4311:  struct id *prev;
        -: 4312:  struct id *cur;
        -: 4313:
        -: 4314:  /* a NULL stream means to close all files */
     1357: 4315:  r.link = utils_id_s;
     1357: 4316:  prev = &r;
     2899: 4317:  while ( (cur = prev->link) )
branch  0 taken 1542
branch  1 taken 1357 (fallthrough)
        -: 4318:    {
     1542: 4319:      if (!stream || stream == cur->fp)
branch  0 taken 1542 (fallthrough)
branch  1 taken 0
branch  2 taken 993 (fallthrough)
branch  3 taken 549
        -: 4320:	{
      993: 4321:	  do_ck_fclose (cur->fp);
call    0 returned 993
      993: 4322:	  prev->link = cur->link;
      993: 4323:	  FREE(cur->name);
call    0 returned 993
      993: 4324:	  FREE(cur);
call    0 returned 993
        -: 4325:	}
        -: 4326:      else
      549: 4327:	prev = cur;
        -: 4328:    }
        -: 4329:
     1357: 4330:  utils_id_s = r.link;
        -: 4331:
        -: 4332:  /* Also care about stdout, because if it is redirected the
        -: 4333:     last output operations might fail and it is important
        -: 4334:     to signal this as an error (perhaps to make). */
     1357: 4335:  if (!stream)
branch  0 taken 362 (fallthrough)
branch  1 taken 995
        -: 4336:    {
      362: 4337:      do_ck_fclose (stdout);
call    0 returned 362
      362: 4338:      do_ck_fclose (stderr);
call    0 returned 0
        -: 4339:    }
      995: 4340:}
        -: 4341:
        -: 4342:/* Close a single file and update a count of closed files. */
        -: 4343:void
function do_ck_fclose called 1717 returned 79% blocks executed 100%
     1717: 4344:do_ck_fclose(stream)
        -: 4345:  FILE *stream;
        -: 4346:{
     1717: 4347:  ck_fflush(stream);
call    0 returned 1717
     1717: 4348:  clearerr(stream);
call    0 returned 1717
     1717: 4349:  if (fclose(stream) == EOF)
call    0 returned 1717
branch  1 taken 362 (fallthrough)
branch  2 taken 1355
      362: 4350:    panic("Couldn't close %s: %s", utils_fp_name(stream), strerror(errno));
call    0 returned 362
call    1 returned 362
call    2 returned 0
     1355: 4351:}
        -: 4352:
        -: 4353:
        -: 4354:
        -: 4355:char *
function temp_file_template called 2 returned 100% blocks executed 56%
        2: 4356:temp_file_template(tmpdir, program)
        -: 4357:  const char *tmpdir;    
        -: 4358:  char *program;
        -: 4359:{
        -: 4360:  char *template;
        2: 4361:  if (tmpdir == NULL)
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####: 4362:    tmpdir = getenv("TMPDIR");
call    0 never executed
        2: 4363:  if (tmpdir == NULL)
branch  0 taken 0 (fallthrough)
branch  1 taken 2
        -: 4364:    {
    #####: 4365:      tmpdir = getenv("TMP");
call    0 never executed
    #####: 4366:      if (tmpdir == NULL)
branch  0 never executed
branch  1 never executed
        -: 4367:#ifdef P_tmpdir
    #####: 4368:	tmpdir = P_tmpdir;
        -: 4369:#else
        -: 4370:	tmpdir = "/tmp";
        -: 4371:#endif
        -: 4372:    }
        -: 4373:
        2: 4374:  template = xmalloc (strlen (tmpdir) + strlen (program) + 8);
call    0 returned 2
        2: 4375:  sprintf (template, "%s/%sXXXXXX", tmpdir, program);
        2: 4376:  return (template);
        -: 4377:}
        -: 4378:
        -: 4379:
        -: 4380:/* Panic on failing malloc */
        -: 4381:VOID *
function ck_malloc called 9832 returned 100% blocks executed 86%
     9832: 4382:ck_malloc(size)
        -: 4383:  size_t size;
        -: 4384:{
     9832: 4385:  VOID *ret = calloc(1, size ? size : 1);
branch  0 taken 9108 (fallthrough)
branch  1 taken 724
     9832: 4386:  if (!ret)
branch  0 taken 0 (fallthrough)
branch  1 taken 9832
    #####: 4387:    panic("Couldn't allocate memory");
call    0 never executed
     9832: 4388:  return ret;
        -: 4389:}
        -: 4390:
        -: 4391:/* Panic on failing malloc */
        -: 4392:VOID *
function xmalloc called 9 returned 100% blocks executed 100%
        9: 4393:xmalloc(size)
        -: 4394:  size_t size;
        -: 4395:{
        9: 4396:  return ck_malloc(size);
call    0 returned 9
        -: 4397:}
        -: 4398:
        -: 4399:/* Panic on failing realloc */
        -: 4400:VOID *
function ck_realloc called 776 returned 100% blocks executed 70%
      776: 4401:ck_realloc(ptr, size)
        -: 4402:  VOID *ptr;
        -: 4403:  size_t size;
        -: 4404:{
        -: 4405:  VOID *ret;
        -: 4406:
      776: 4407:  if (size == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 776
        -: 4408:    {
    #####: 4409:      FREE(ptr);
call    0 never executed
    #####: 4410:      return NULL;
        -: 4411:    }
      776: 4412:  if (!ptr)
branch  0 taken 365 (fallthrough)
branch  1 taken 411
      365: 4413:    return ck_malloc(size);
call    0 returned 365
      411: 4414:  ret = realloc(ptr, size);
      411: 4415:  if (!ret)
branch  0 taken 0 (fallthrough)
branch  1 taken 411
    #####: 4416:    panic("Couldn't re-allocate memory");
call    0 never executed
      411: 4417:  return ret;
        -: 4418:}
        -: 4419:
        -: 4420:/* Return a malloc()'d copy of a string */
        -: 4421:char *
function ck_strdup called 1239 returned 100% blocks executed 100%
     1239: 4422:ck_strdup(str)
        -: 4423:  const char *str;
        -: 4424:{
     1239: 4425:  char *ret = MALLOC(strlen(str)+1, char);
call    0 returned 1239
     1239: 4426:  return strcpy(ret, str);
        -: 4427:}
        -: 4428:
        -: 4429:/* Return a malloc()'d copy of a block of memory */
        -: 4430:VOID *
function ck_memdup called 1445 returned 100% blocks executed 100%
     1445: 4431:ck_memdup(buf, len)
        -: 4432:  const VOID *buf;
        -: 4433:  size_t len;
        -: 4434:{
     1445: 4435:  VOID *ret = ck_malloc(len);
call    0 returned 1445
     1445: 4436:  return memcpy(ret, buf, len);
        -: 4437:}
        -: 4438:
        -: 4439:/* Release a malloc'd block of memory */
        -: 4440:void
function ck_free called 6308 returned 100% blocks executed 100%
     6308: 4441:ck_free(ptr)
        -: 4442:  VOID *ptr;
        -: 4443:{
     6308: 4444:  if (ptr)
branch  0 taken 5979 (fallthrough)
branch  1 taken 329
     5979: 4445:    free(ptr);
     6308: 4446:}
        -: 4447:
        -: 4448:
        -: 4449:/* Implement a variable sized buffer of `stuff'.  We don't know what it is,
        -: 4450:nor do we care, as long as it doesn't mind being aligned by malloc. */
        -: 4451:
        -: 4452:struct buffer
        -: 4453:  {
        -: 4454:    size_t allocated;
        -: 4455:    size_t length;
        -: 4456:    char *b;
        -: 4457:  };
        -: 4458:
        -: 4459:#define MIN_ALLOCATE 50
        -: 4460:
        -: 4461:struct buffer *
function init_buffer called 1262 returned 100% blocks executed 100%
     1262: 4462:init_buffer()
        -: 4463:{
     1262: 4464:  struct buffer *b = MALLOC(1, struct buffer);
call    0 returned 1262
     1262: 4465:  b->b = MALLOC(MIN_ALLOCATE, char);
call    0 returned 1262
     1262: 4466:  b->allocated = MIN_ALLOCATE;
     1262: 4467:  b->length = 0;
     1262: 4468:  return b;
        -: 4469:}
        -: 4470:
        -: 4471:char *
function get_buffer called 1244 returned 100% blocks executed 100%
     1244: 4472:get_buffer(b)
        -: 4473:  struct buffer *b;
        -: 4474:{
     1244: 4475:  return b->b;
        -: 4476:}
        -: 4477:
        -: 4478:size_t
function size_buffer called 1628 returned 100% blocks executed 100%
     1628: 4479:size_buffer(b)
        -: 4480:  struct buffer *b;
        -: 4481:{
     1628: 4482:  return b->length;
        -: 4483:}
        -: 4484:
        -: 4485:static void resize_buffer P_((struct buffer *b, size_t newlen));
        -: 4486:static void
function resize_buffer called 0 returned 0% blocks executed 0%
    #####: 4487:resize_buffer(b, newlen)
        -: 4488:  struct buffer *b;
        -: 4489:  size_t newlen;
        -: 4490:{
    #####: 4491:  char *try = NULL;
    #####: 4492:  size_t alen = b->allocated;
        -: 4493:
    #####: 4494:  if (newlen <= alen)
branch  0 never executed
branch  1 never executed
    #####: 4495:    return;
    #####: 4496:  alen *= 2;
    #####: 4497:  if (newlen < alen)
branch  0 never executed
branch  1 never executed
    #####: 4498:    try = realloc(b->b, alen);	/* Note: *not* the REALLOC() macro! */
    #####: 4499:  if (!try)
branch  0 never executed
branch  1 never executed
        -: 4500:    {
    #####: 4501:      alen = newlen;
    #####: 4502:      try = REALLOC(b->b, alen, char);
call    0 never executed
        -: 4503:    }
    #####: 4504:  b->allocated = alen;
    #####: 4505:  b->b = try;
        -: 4506:}
        -: 4507:
        -: 4508:void
function add_buffer called 0 returned 0% blocks executed 0%
    #####: 4509:add_buffer(b, p, n)
        -: 4510:  struct buffer *b;
        -: 4511:  const char *p;
        -: 4512:  size_t n;
        -: 4513:{
    #####: 4514:  if (b->allocated - b->length < n)
branch  0 never executed
branch  1 never executed
    #####: 4515:    resize_buffer(b, b->length+n);
call    0 never executed
    #####: 4516:  memcpy(b->b + b->length, p, n);
    #####: 4517:  b->length += n;
    #####: 4518:}
        -: 4519:
        -: 4520:void
function add1_buffer called 10702 returned 100% blocks executed 80%
    10702: 4521:add1_buffer(b, c)
        -: 4522:  struct buffer *b;
        -: 4523:  int c;
        -: 4524:{
        -: 4525:  /* This special case should be kept cheap;
        -: 4526:   *  don't make it just a mere convenience
        -: 4527:   *  wrapper for add_buffer() -- even "builtin"
        -: 4528:   *  versions of memcpy(a, b, 1) can become
        -: 4529:   *  expensive when called too often.
        -: 4530:   */
    10702: 4531:  if (c != EOF)
branch  0 taken 10702 (fallthrough)
branch  1 taken 0
        -: 4532:    {
    10702: 4533:      if (b->allocated - b->length < 1)
branch  0 taken 0 (fallthrough)
branch  1 taken 10702
    #####: 4534:	resize_buffer(b, b->length+1);
call    0 never executed
    10702: 4535:      b->b[b->length++] = c;
        -: 4536:    }
    10702: 4537:}
        -: 4538:
        -: 4539:void
function free_buffer called 1262 returned 100% blocks executed 100%
     1262: 4540:free_buffer(b)
        -: 4541:  struct buffer *b;
        -: 4542:{
     1262: 4543:  if (b)
branch  0 taken 1262 (fallthrough)
branch  1 taken 0
     1262: 4544:    FREE(b->b);
call    0 returned 1262
     1262: 4545:  FREE(b);
call    0 returned 1262
     1262: 4546:}
        -: 4547:/* obstack.c - subroutines used implicitly by object stack macros -*- C -*-
        -: 4548:   Copyright (C) 1988,89,90,91,92,93,94,96,97 Free Software Foundation, Inc.
        -: 4549:
        -: 4550:   This file is part of the GNU C Library.  Its master source is NOT part of
        -: 4551:   the C library, however.  The master source lives in /gd/gnu/lib.
        -: 4552:
        -: 4553:   The GNU C Library is free software; you can redistribute it and/or
        -: 4554:   modify it under the terms of the GNU Library General Public License as
        -: 4555:   published by the Free Software Foundation; either version 2 of the
        -: 4556:   License, or (at your option) any later version.
        -: 4557:
        -: 4558:   The GNU C Library is distributed in the hope that it will be useful,
        -: 4559:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 4560:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
        -: 4561:   Library General Public License for more details.
        -: 4562:
        -: 4563:   You should have received a copy of the GNU Library General Public
        -: 4564:   License along with the GNU C Library; see the file COPYING.LIB.  If not,
        -: 4565:   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
        -: 4566:   Boston, MA 02111-1307, USA.  */
        -: 4567:
        -: 4568:#include "obstack.h"
        -: 4569:
        -: 4570:/* NOTE BEFORE MODIFYING THIS FILE: This version number must be
        -: 4571:   incremented whenever callers compiled using an old obstack.h can no
        -: 4572:   longer properly call the functions in this obstack.c.  */
        -: 4573:#define OBSTACK_INTERFACE_VERSION 1
        -: 4574:
        -: 4575:/* Comment out all this code if we are using the GNU C Library, and are not
        -: 4576:   actually compiling the library itself, and the installed library
        -: 4577:   supports the same library interface we do.  This code is part of the GNU
        -: 4578:   C Library, but also included in many other GNU distributions.  Compiling
        -: 4579:   and linking in this code is a waste when using the GNU C library
        -: 4580:   (especially if it is a shared library).  Rather than having every GNU
        -: 4581:   program understand `configure --with-gnu-libc' and omit the object
        -: 4582:   files, it is simpler to just do this in the source for each such file.  */
        -: 4583:
        -: 4584:#include <stdio.h>		/* Random thing to get __GNU_LIBRARY__.  */
        -: 4585:#if !defined (_LIBC) && defined (__GNU_LIBRARY__) && __GNU_LIBRARY__ > 1
        -: 4586:#include <gnu-versions.h>
        -: 4587:#if _GNU_OBSTACK_INTERFACE_VERSION == OBSTACK_INTERFACE_VERSION
        -: 4588:#define ELIDE_CODE
        -: 4589:#endif
        -: 4590:#endif
        -: 4591:
        -: 4592:
        -: 4593:#ifndef ELIDE_CODE
        -: 4594:
        -: 4595:
        -: 4596:#if defined (__STDC__) && __STDC__
        -: 4597:#define POINTER void *
        -: 4598:#else
        -: 4599:#define POINTER char *
        -: 4600:#endif
        -: 4601:
        -: 4602:/* Determine default alignment.  */
        -: 4603:struct fooalign {char x; double d;};
        -: 4604:#define DEFAULT_ALIGNMENT  \
        -: 4605:  ((PTR_INT_TYPE) ((char *) &((struct fooalign *) 0)->d - (char *) 0))
        -: 4606:/* If malloc were really smart, it would round addresses to DEFAULT_ALIGNMENT.
        -: 4607:   But in fact it might be less smart and round addresses to as much as
        -: 4608:   DEFAULT_ROUNDING.  So we prepare for it to do that.  */
        -: 4609:union fooround {long x; double d;};
        -: 4610:#define DEFAULT_ROUNDING (sizeof (union fooround))
        -: 4611:
        -: 4612:#ifdef original_glibc_code
        -: 4613:/**//* When we copy a long block of data, this is the unit to do it with. */
        -: 4614:/**//* On some machines, copying successive ints does not work; */
        -: 4615:/**//* in such a case, redefine COPYING_UNIT to `long' (if that works) */
        -: 4616:/**//* or `char' as a last resort.  */
        -: 4617:/**/#ifndef COPYING_UNIT
        -: 4618:/**/#define COPYING_UNIT int
        -: 4619:/**/#endif
        -: 4620:#endif
        -: 4621:
        -: 4622:/* The functions allocating more room by calling `obstack_chunk_alloc'
        -: 4623:   jump to the handler pointed to by `obstack_alloc_failed_handler'.
        -: 4624:   This variable by default points to the internal function
        -: 4625:   `print_and_abort'.  */
        -: 4626:#if defined (__STDC__) && __STDC__
        -: 4627:static void print_and_abort (void);
        -: 4628:void (*obstack_alloc_failed_handler) (void) = print_and_abort;
        -: 4629:#else
        -: 4630:static void print_and_abort ();
        -: 4631:void (*obstack_alloc_failed_handler) () = print_and_abort;
        -: 4632:#endif
        -: 4633:
        -: 4634:/* Exit value used when `print_and_abort' is used.  */
        -: 4635:#if defined __GNU_LIBRARY__ || defined HAVE_STDLIB_H
        -: 4636:#include <stdlib.h>
        -: 4637:#endif
        -: 4638:#ifndef EXIT_FAILURE
        -: 4639:#define EXIT_FAILURE 1
        -: 4640:#endif
        -: 4641:int obstack_exit_failure = EXIT_FAILURE;
        -: 4642:
        -: 4643:/* The non-GNU-C macros copy the obstack into this global variable
        -: 4644:   to avoid multiple evaluation.  */
        -: 4645:
        -: 4646:struct obstack *_obstack;
        -: 4647:
        -: 4648:/* Define a macro that either calls functions with the traditional malloc/free
        -: 4649:   calling interface, or calls functions with the mmalloc/mfree interface
        -: 4650:   (that adds an extra first argument), based on the state of use_extra_arg.
        -: 4651:   For free, do not use ?:, since some compilers, like the MIPS compilers,
        -: 4652:   do not allow (expr) ? void : void.  */
        -: 4653:
        -: 4654:#if defined (__STDC__) && __STDC__
        -: 4655:#define CALL_CHUNKFUN(h, size) \
        -: 4656:  (((h) -> use_extra_arg) \
        -: 4657:   ? (*(h)->chunkfun) ((h)->extra_arg, (size)) \
        -: 4658:   : (*(struct _obstack_chunk *(*) (long)) (h)->chunkfun) ((size)))
        -: 4659:
        -: 4660:#define CALL_FREEFUN(h, old_chunk) \
        -: 4661:  do { \
        -: 4662:    if ((h) -> use_extra_arg) \
        -: 4663:      (*(h)->freefun) ((h)->extra_arg, (old_chunk)); \
        -: 4664:    else \
        -: 4665:      (*(void (*) (void *)) (h)->freefun) ((old_chunk)); \
        -: 4666:  } while (0)
        -: 4667:#else
        -: 4668:#define CALL_CHUNKFUN(h, size) \
        -: 4669:  (((h) -> use_extra_arg) \
        -: 4670:   ? (*(h)->chunkfun) ((h)->extra_arg, (size)) \
        -: 4671:   : (*(struct _obstack_chunk *(*) ()) (h)->chunkfun) ((size)))
        -: 4672:
        -: 4673:#define CALL_FREEFUN(h, old_chunk) \
        -: 4674:  do { \
        -: 4675:    if ((h) -> use_extra_arg) \
        -: 4676:      (*(h)->freefun) ((h)->extra_arg, (old_chunk)); \
        -: 4677:    else \
        -: 4678:      (*(void (*) ()) (h)->freefun) ((old_chunk)); \
        -: 4679:  } while (0)
        -: 4680:#endif
        -: 4681:
        -: 4682:
        -: 4683:/* Initialize an obstack H for use.  Specify chunk size SIZE (0 means default).
        -: 4684:   Objects start on multiples of ALIGNMENT (0 means use default).
        -: 4685:   CHUNKFUN is the function to use to allocate chunks,
        -: 4686:   and FREEFUN the function to free them.
        -: 4687:
        -: 4688:   Return nonzero if successful, zero if out of memory.
        -: 4689:   To recover from an out of memory error,
        -: 4690:   free up some memory, then call this again.  */
        -: 4691:
        -: 4692:int
        -: 4693:_obstack_begin (h, size, alignment, chunkfun, freefun)
        -: 4694:     struct obstack *h;
        -: 4695:     int size;
        -: 4696:     int alignment;
        -: 4697:#if defined (__STDC__) && __STDC__
        -: 4698:     POINTER (*chunkfun) (long);
        -: 4699:     void (*freefun) (void *);
        -: 4700:#else
        -: 4701:     POINTER (*chunkfun) ();
        -: 4702:     void (*freefun) ();
        -: 4703:#endif
        -: 4704:{
        -: 4705:  register struct _obstack_chunk *chunk; /* points to new chunk */
        -: 4706:
        -: 4707:  if (alignment == 0)
        -: 4708:    alignment = DEFAULT_ALIGNMENT;
        -: 4709:  if (size == 0)
        -: 4710:    /* Default size is what GNU malloc can fit in a 4096-byte block.  */
        -: 4711:    {
        -: 4712:      /* 12 is sizeof (mhead) and 4 is EXTRA from GNU malloc.
        -: 4713:	 Use the values for range checking, because if range checking is off,
        -: 4714:	 the extra bytes won't be missed terribly, but if range checking is on
        -: 4715:	 and we used a larger request, a whole extra 4096 bytes would be
        -: 4716:	 allocated.
        -: 4717:
        -: 4718:	 These number are irrelevant to the new GNU malloc.  I suspect it is
        -: 4719:	 less sensitive to the size of the request.  */
        -: 4720:      int extra = ((((12 + DEFAULT_ROUNDING - 1) & ~(DEFAULT_ROUNDING - 1))
        -: 4721:		    + 4 + DEFAULT_ROUNDING - 1)
        -: 4722:		   & ~(DEFAULT_ROUNDING - 1));
        -: 4723:      size = 4096 - extra;
        -: 4724:    }
        -: 4725:
        -: 4726:#if defined (__STDC__) && __STDC__
        -: 4727:  h->chunkfun = (struct _obstack_chunk * (*)(void *, long)) chunkfun;
        -: 4728:  h->freefun = (void (*) (void *, struct _obstack_chunk *)) freefun;
        -: 4729:#else
        -: 4730:  h->chunkfun = (struct _obstack_chunk * (*)()) chunkfun;
        -: 4731:  h->freefun = freefun;
        -: 4732:#endif
        -: 4733:  h->chunk_size = size;
        -: 4734:  h->alignment_mask = alignment - 1;
        -: 4735:  h->use_extra_arg = 0;
        -: 4736:
        -: 4737:  chunk = h->chunk = CALL_CHUNKFUN (h, h -> chunk_size);
        -: 4738:  if (!chunk)
        -: 4739:    (*obstack_alloc_failed_handler) ();
        -: 4740:  h->next_free = h->object_base = chunk->contents;
        -: 4741:  h->chunk_limit = chunk->limit
        -: 4742:    = (char *) chunk + h->chunk_size;
        -: 4743:  chunk->prev = 0;
        -: 4744:  /* The initial chunk now contains no empty object.  */
        -: 4745:  h->maybe_empty_object = 0;
        -: 4746:  h->alloc_failed = 0;
        -: 4747:  return 1;
        -: 4748:}
        -: 4749:
        -: 4750:int
        -: 4751:_obstack_begin_1 (h, size, alignment, chunkfun, freefun, arg)
        -: 4752:     struct obstack *h;
        -: 4753:     int size;
        -: 4754:     int alignment;
        -: 4755:#if defined (__STDC__) && __STDC__
        -: 4756:     POINTER (*chunkfun) (POINTER, long);
        -: 4757:     void (*freefun) (POINTER, POINTER);
        -: 4758:#else
        -: 4759:     POINTER (*chunkfun) ();
        -: 4760:     void (*freefun) ();
        -: 4761:#endif
        -: 4762:     POINTER arg;
        -: 4763:{
        -: 4764:  register struct _obstack_chunk *chunk; /* points to new chunk */
        -: 4765:
        -: 4766:  if (alignment == 0)
        -: 4767:    alignment = DEFAULT_ALIGNMENT;
        -: 4768:  if (size == 0)
        -: 4769:    /* Default size is what GNU malloc can fit in a 4096-byte block.  */
        -: 4770:    {
        -: 4771:      /* 12 is sizeof (mhead) and 4 is EXTRA from GNU malloc.
        -: 4772:	 Use the values for range checking, because if range checking is off,
        -: 4773:	 the extra bytes won't be missed terribly, but if range checking is on
        -: 4774:	 and we used a larger request, a whole extra 4096 bytes would be
        -: 4775:	 allocated.
        -: 4776:
        -: 4777:	 These number are irrelevant to the new GNU malloc.  I suspect it is
        -: 4778:	 less sensitive to the size of the request.  */
        -: 4779:      int extra = ((((12 + DEFAULT_ROUNDING - 1) & ~(DEFAULT_ROUNDING - 1))
        -: 4780:		    + 4 + DEFAULT_ROUNDING - 1)
        -: 4781:		   & ~(DEFAULT_ROUNDING - 1));
        -: 4782:      size = 4096 - extra;
        -: 4783:    }
        -: 4784:
        -: 4785:#if defined(__STDC__) && __STDC__
        -: 4786:  h->chunkfun = (struct _obstack_chunk * (*)(void *,long)) chunkfun;
        -: 4787:  h->freefun = (void (*) (void *, struct _obstack_chunk *)) freefun;
        -: 4788:#else
        -: 4789:  h->chunkfun = (struct _obstack_chunk * (*)()) chunkfun;
        -: 4790:  h->freefun = freefun;
        -: 4791:#endif
        -: 4792:  h->chunk_size = size;
        -: 4793:  h->alignment_mask = alignment - 1;
        -: 4794:  h->extra_arg = arg;
        -: 4795:  h->use_extra_arg = 1;
        -: 4796:
        -: 4797:  chunk = h->chunk = CALL_CHUNKFUN (h, h -> chunk_size);
        -: 4798:  if (!chunk)
        -: 4799:    (*obstack_alloc_failed_handler) ();
        -: 4800:  h->next_free = h->object_base = chunk->contents;
        -: 4801:  h->chunk_limit = chunk->limit
        -: 4802:    = (char *) chunk + h->chunk_size;
        -: 4803:  chunk->prev = 0;
        -: 4804:  /* The initial chunk now contains no empty object.  */
        -: 4805:  h->maybe_empty_object = 0;
        -: 4806:  h->alloc_failed = 0;
        -: 4807:  return 1;
        -: 4808:}
        -: 4809:
        -: 4810:/* Allocate a new current chunk for the obstack *H
        -: 4811:   on the assumption that LENGTH bytes need to be added
        -: 4812:   to the current object, or a new object of length LENGTH allocated.
        -: 4813:   Copies any partial object from the end of the old chunk
        -: 4814:   to the beginning of the new one.  */
        -: 4815:
        -: 4816:void
        -: 4817:_obstack_newchunk (h, length)
        -: 4818:     struct obstack *h;
        -: 4819:     int length;
        -: 4820:{
        -: 4821:  register struct _obstack_chunk *old_chunk = h->chunk;
        -: 4822:  register struct _obstack_chunk *new_chunk;
        -: 4823:  register long	new_size;
        -: 4824:  register int obj_size = h->next_free - h->object_base;
        -: 4825:
        -: 4826:  /* Compute size for new chunk.  */
        -: 4827:  new_size = (obj_size + length) + (obj_size >> 3) + 100;
        -: 4828:  if (new_size < h->chunk_size)
        -: 4829:    new_size = h->chunk_size;
        -: 4830:
        -: 4831:  /* Allocate and initialize the new chunk.  */
        -: 4832:  new_chunk = CALL_CHUNKFUN (h, new_size);
        -: 4833:  if (!new_chunk)
        -: 4834:    (*obstack_alloc_failed_handler) ();
        -: 4835:  h->chunk = new_chunk;
        -: 4836:  new_chunk->prev = old_chunk;
        -: 4837:  new_chunk->limit = h->chunk_limit = (char *) new_chunk + new_size;
        -: 4838:
        -: 4839:  _obstack_memcpy(new_chunk->contents, h->object_base, obj_size);
        -: 4840:
        -: 4841:  /* If the object just copied was the only data in OLD_CHUNK, */
        -: 4842:  /* free that chunk and remove it from the chain. */
        -: 4843:  /* But not if that chunk might contain an empty object.  */
        -: 4844:  if (h->object_base == old_chunk->contents && ! h->maybe_empty_object)
        -: 4845:    {
        -: 4846:      new_chunk->prev = old_chunk->prev;
        -: 4847:      CALL_FREEFUN (h, old_chunk);
        -: 4848:    }
        -: 4849:
        -: 4850:  h->object_base = new_chunk->contents;
        -: 4851:  h->next_free = h->object_base + obj_size;
        -: 4852:  /* The new chunk certainly contains no empty object yet.  */
        -: 4853:  h->maybe_empty_object = 0;
        -: 4854:}
        -: 4855:
        -: 4856:/* Return nonzero if object OBJ has been allocated from obstack H.
        -: 4857:   This is here for debugging.
        -: 4858:   If you use it in a program, you are probably losing.  */
        -: 4859:
        -: 4860:#if defined (__STDC__) && __STDC__
        -: 4861:/* Suppress -Wmissing-prototypes warning.  We don't want to declare this in
        -: 4862:   obstack.h because it is just for debugging.  */
        -: 4863:int _obstack_allocated_p (struct obstack *h, POINTER obj);
        -: 4864:#endif
        -: 4865:
        -: 4866:int
        -: 4867:_obstack_allocated_p (h, obj)
        -: 4868:     struct obstack *h;
        -: 4869:     POINTER obj;
        -: 4870:{
        -: 4871:  register struct _obstack_chunk *lp;	/* below addr of any objects in this chunk */
        -: 4872:  register struct _obstack_chunk *plp;	/* point to previous chunk if any */
        -: 4873:
        -: 4874:  lp = (h)->chunk;
        -: 4875:  /* We use >= rather than > since the object cannot be exactly at
        -: 4876:     the beginning of the chunk but might be an empty object exactly
        -: 4877:     at the end of an adjacent chunk.  */
        -: 4878:  while (lp != 0 && ((POINTER) lp >= obj || (POINTER) (lp)->limit < obj))
        -: 4879:    {
        -: 4880:      plp = lp->prev;
        -: 4881:      lp = plp;
        -: 4882:    }
        -: 4883:  return lp != 0;
        -: 4884:}
        -: 4885:
        -: 4886:/* Free objects in obstack H, including OBJ and everything allocate
        -: 4887:   more recently than OBJ.  If OBJ is zero, free everything in H.  */
        -: 4888:
        -: 4889:#undef obstack_free
        -: 4890:
        -: 4891:/* This function has two names with identical definitions.
        -: 4892:   This is the first one, called from non-ANSI code.  */
        -: 4893:
        -: 4894:void
        -: 4895:_obstack_free (h, obj)
        -: 4896:     struct obstack *h;
        -: 4897:     POINTER obj;
        -: 4898:{
        -: 4899:  register struct _obstack_chunk *lp;	/* below addr of any objects in this chunk */
        -: 4900:  register struct _obstack_chunk *plp;	/* point to previous chunk if any */
        -: 4901:
        -: 4902:  lp = h->chunk;
        -: 4903:  /* We use >= because there cannot be an object at the beginning of a chunk.
        -: 4904:     But there can be an empty object at that address
        -: 4905:     at the end of another chunk.  */
        -: 4906:  while (lp != 0 && ((POINTER) lp >= obj || (POINTER) (lp)->limit < obj))
        -: 4907:    {
        -: 4908:      plp = lp->prev;
        -: 4909:      CALL_FREEFUN (h, lp);
        -: 4910:      lp = plp;
        -: 4911:      /* If we switch chunks, we can't tell whether the new current
        -: 4912:	 chunk contains an empty object, so assume that it may.  */
        -: 4913:      h->maybe_empty_object = 1;
        -: 4914:    }
        -: 4915:  if (lp)
        -: 4916:    {
        -: 4917:      h->object_base = h->next_free = (char *) (obj);
        -: 4918:      h->chunk_limit = lp->limit;
        -: 4919:      h->chunk = lp;
        -: 4920:    }
        -: 4921:  else if (obj != 0)
        -: 4922:    /* obj is not in any of the chunks! */
        -: 4923:    abort ();
        -: 4924:}
        -: 4925:
        -: 4926:/* This function is used from ANSI code.  */
        -: 4927:
        -: 4928:void
        -: 4929:obstack_free (h, obj)
        -: 4930:     struct obstack *h;
        -: 4931:     POINTER obj;
        -: 4932:{
        -: 4933:  register struct _obstack_chunk *lp;	/* below addr of any objects in this chunk */
        -: 4934:  register struct _obstack_chunk *plp;	/* point to previous chunk if any */
        -: 4935:
        -: 4936:  lp = h->chunk;
        -: 4937:  /* We use >= because there cannot be an object at the beginning of a chunk.
        -: 4938:     But there can be an empty object at that address
        -: 4939:     at the end of another chunk.  */
        -: 4940:  while (lp != 0 && ((POINTER) lp >= obj || (POINTER) (lp)->limit < obj))
        -: 4941:    {
        -: 4942:      plp = lp->prev;
        -: 4943:      CALL_FREEFUN (h, lp);
        -: 4944:      lp = plp;
        -: 4945:      /* If we switch chunks, we can't tell whether the new current
        -: 4946:	 chunk contains an empty object, so assume that it may.  */
        -: 4947:      h->maybe_empty_object = 1;
        -: 4948:    }
        -: 4949:  if (lp)
        -: 4950:    {
        -: 4951:      h->object_base = h->next_free = (char *) (obj);
        -: 4952:      h->chunk_limit = lp->limit;
        -: 4953:      h->chunk = lp;
        -: 4954:    }
        -: 4955:  else if (obj != 0)
        -: 4956:    /* obj is not in any of the chunks! */
        -: 4957:    abort ();
        -: 4958:}
        -: 4959:
        -: 4960:int
        -: 4961:_obstack_memory_used (h)
        -: 4962:     struct obstack *h;
        -: 4963:{
        -: 4964:  register struct _obstack_chunk* lp;
        -: 4965:  register int nbytes = 0;
        -: 4966:
        -: 4967:  for (lp = h->chunk; lp != 0; lp = lp->prev)
        -: 4968:    {
        -: 4969:      nbytes += lp->limit - (char *) lp;
        -: 4970:    }
        -: 4971:  return nbytes;
        -: 4972:}
        -: 4973:
        -: 4974:/* Define the error handler.  */
        -: 4975:#ifndef _
        -: 4976:# ifdef HAVE_LIBINTL_H
        -: 4977:#  include <libintl.h>
        -: 4978:#  ifndef _
        -: 4979:#   define _(Str) gettext (Str)
        -: 4980:#  endif
        -: 4981:# else
        -: 4982:#  define _(Str) (Str)
        -: 4983:# endif
        -: 4984:#endif
        -: 4985:
        -: 4986:static void
        -: 4987:print_and_abort ()
        -: 4988:{
        -: 4989:  fputs (_("memory exhausted\n"), stderr);
        -: 4990:  exit (obstack_exit_failure);
        -: 4991:}
        -: 4992:
        -: 4993:#if 0
        -: 4994:/* These are now turned off because the applications do not use it
        -: 4995:   and it uses bcopy via obstack_grow, which causes trouble on sysV.  */
        -: 4996:
        -: 4997:/* Now define the functional versions of the obstack macros.
        -: 4998:   Define them to simply use the corresponding macros to do the job.  */
        -: 4999:
        -: 5000:#if defined (__STDC__) && __STDC__
        -: 5001:/* These function definitions do not work with non-ANSI preprocessors;
        -: 5002:   they won't pass through the macro names in parentheses.  */
        -: 5003:
        -: 5004:/* The function names appear in parentheses in order to prevent
        -: 5005:   the macro-definitions of the names from being expanded there.  */
        -: 5006:
        -: 5007:POINTER (obstack_base) (obstack)
        -: 5008:     struct obstack *obstack;
        -: 5009:{
        -: 5010:  return obstack_base (obstack);
        -: 5011:}
        -: 5012:
        -: 5013:POINTER (obstack_next_free) (obstack)
        -: 5014:     struct obstack *obstack;
        -: 5015:{
        -: 5016:  return obstack_next_free (obstack);
        -: 5017:}
        -: 5018:
        -: 5019:int (obstack_object_size) (obstack)
        -: 5020:     struct obstack *obstack;
        -: 5021:{
        -: 5022:  return obstack_object_size (obstack);
        -: 5023:}
        -: 5024:
        -: 5025:int (obstack_room) (obstack)
        -: 5026:     struct obstack *obstack;
        -: 5027:{
        -: 5028:  return obstack_room (obstack);
        -: 5029:}
        -: 5030:
        -: 5031:int (obstack_make_room) (obstack, length)
        -: 5032:     struct obstack *obstack;
        -: 5033:     int length;
        -: 5034:{
        -: 5035:  return obstack_make_room (obstack, length);
        -: 5036:}
        -: 5037:
        -: 5038:void (obstack_grow) (obstack, pointer, length)
        -: 5039:     struct obstack *obstack;
        -: 5040:     POINTER pointer;
        -: 5041:     int length;
        -: 5042:{
        -: 5043:  obstack_grow (obstack, pointer, length);
        -: 5044:}
        -: 5045:
        -: 5046:void (obstack_grow0) (obstack, pointer, length)
        -: 5047:     struct obstack *obstack;
        -: 5048:     POINTER pointer;
        -: 5049:     int length;
        -: 5050:{
        -: 5051:  obstack_grow0 (obstack, pointer, length);
        -: 5052:}
        -: 5053:
        -: 5054:void (obstack_1grow) (obstack, character)
        -: 5055:     struct obstack *obstack;
        -: 5056:     int character;
        -: 5057:{
        -: 5058:  obstack_1grow (obstack, character);
        -: 5059:}
        -: 5060:
        -: 5061:void (obstack_blank) (obstack, length)
        -: 5062:     struct obstack *obstack;
        -: 5063:     int length;
        -: 5064:{
        -: 5065:  obstack_blank (obstack, length);
        -: 5066:}
        -: 5067:
        -: 5068:void (obstack_1grow_fast) (obstack, character)
        -: 5069:     struct obstack *obstack;
        -: 5070:     int character;
        -: 5071:{
        -: 5072:  obstack_1grow_fast (obstack, character);
        -: 5073:}
        -: 5074:
        -: 5075:void (obstack_blank_fast) (obstack, length)
        -: 5076:     struct obstack *obstack;
        -: 5077:     int length;
        -: 5078:{
        -: 5079:  obstack_blank_fast (obstack, length);
        -: 5080:}
        -: 5081:
        -: 5082:POINTER (obstack_finish) (obstack)
        -: 5083:     struct obstack *obstack;
        -: 5084:{
        -: 5085:  return obstack_finish (obstack);
        -: 5086:}
        -: 5087:
        -: 5088:POINTER (obstack_alloc) (obstack, length)
        -: 5089:     struct obstack *obstack;
        -: 5090:     int length;
        -: 5091:{
        -: 5092:  return obstack_alloc (obstack, length);
        -: 5093:}
        -: 5094:
        -: 5095:POINTER (obstack_copy) (obstack, pointer, length)
        -: 5096:     struct obstack *obstack;
        -: 5097:     POINTER pointer;
        -: 5098:     int length;
        -: 5099:{
        -: 5100:  return obstack_copy (obstack, pointer, length);
        -: 5101:}
        -: 5102:
        -: 5103:POINTER (obstack_copy0) (obstack, pointer, length)
        -: 5104:     struct obstack *obstack;
        -: 5105:     POINTER pointer;
        -: 5106:     int length;
        -: 5107:{
        -: 5108:  return obstack_copy0 (obstack, pointer, length);
        -: 5109:}
        -: 5110:
        -: 5111:#endif /* __STDC__ */
        -: 5112:
        -: 5113:#endif /* 0 */
        -: 5114:
        -: 5115:#endif	/* !ELIDE_CODE */
        -: 5116:/* Getopt for GNU.
        -: 5117:   NOTE: getopt is now part of the C library, so if you don't know what
        -: 5118:   "Keep this file name-space clean" means, talk to drepper@gnu.org
        -: 5119:   before changing it!
        -: 5120:
        -: 5121:   Copyright (C) 1987, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98
        -: 5122:   	Free Software Foundation, Inc.
        -: 5123:
        -: 5124:   NOTE: The canonical source of this file is maintained with the GNU C Library.
        -: 5125:   Bugs can be reported to bug-glibc@gnu.org.
        -: 5126:
        -: 5127:   This program is free software; you can redistribute it and/or modify it
        -: 5128:   under the terms of the GNU General Public License as published by the
        -: 5129:   Free Software Foundation; either version 2, or (at your option) any
        -: 5130:   later version.
        -: 5131:
        -: 5132:   This program is distributed in the hope that it will be useful,
        -: 5133:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 5134:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 5135:   GNU General Public License for more details.
        -: 5136:
        -: 5137:   You should have received a copy of the GNU General Public License
        -: 5138:   along with this program; if not, write to the Free Software
        -: 5139:   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
        -: 5140:   USA.  */
        -: 5141:
        -: 5142:/* This tells Alpha OSF/1 not to define a getopt prototype in <stdio.h>.
        -: 5143:   Ditto for AIX 3.2 and <stdlib.h>.  */
        -: 5144:#ifndef _NO_PROTO
        -: 5145:# define _NO_PROTO
        -: 5146:#endif
        -: 5147:
        -: 5148:#ifdef HAVE_CONFIG_H
        -: 5149:# include <config.h>
        -: 5150:#endif
        -: 5151:
        -: 5152:#if !defined __STDC__ || !__STDC__
        -: 5153:/* This is a separate conditional since some stdc systems
        -: 5154:   reject `defined (const)'.  */
        -: 5155:# ifndef const
        -: 5156:#  define const
        -: 5157:# endif
        -: 5158:#endif
        -: 5159:
        -: 5160:#include <stdio.h>
        -: 5161:
        -: 5162:/* Comment out all this code if we are using the GNU C Library, and are not
        -: 5163:   actually compiling the library itself.  This code is part of the GNU C
        -: 5164:   Library, but also included in many other GNU distributions.  Compiling
        -: 5165:   and linking in this code is a waste when using the GNU C library
        -: 5166:   (especially if it is a shared library).  Rather than having every GNU
        -: 5167:   program understand `configure --with-gnu-libc' and omit the object files,
        -: 5168:   it is simpler to just do this in the source for each such file.  */
        -: 5169:
        -: 5170:#define GETOPT_INTERFACE_VERSION 2
        -: 5171:#if !defined _LIBC && defined __GLIBC__ && __GLIBC__ >= 2
        -: 5172:# include <gnu-versions.h>
        -: 5173:# if _GNU_GETOPT_INTERFACE_VERSION == GETOPT_INTERFACE_VERSION
        -: 5174:#  define ELIDE_CODE
        -: 5175:# endif
        -: 5176:#endif
        -: 5177:
        -: 5178:#ifndef ELIDE_CODE
        -: 5179:
        -: 5180:
        -: 5181:/* This needs to come after some library #include
        -: 5182:   to get __GNU_LIBRARY__ defined.  */
        -: 5183:#ifdef	__GNU_LIBRARY__
        -: 5184:/* Don't include stdlib.h for non-GNU C libraries because some of them
        -: 5185:   contain conflicting prototypes for getopt.  */
        -: 5186:# include <stdlib.h>
        -: 5187:# include <unistd.h>
        -: 5188:#endif	/* GNU C library.  */
        -: 5189:
        -: 5190:#ifdef VMS
        -: 5191:# include <unixlib.h>
        -: 5192:# if HAVE_STRING_H - 0
        -: 5193:#  include <string.h>
        -: 5194:# endif
        -: 5195:#endif
        -: 5196:
        -: 5197:#ifndef _
        -: 5198:/* This is for other GNU distributions with internationalized messages.
        -: 5199:   When compiling libc, the _ macro is predefined.  */
        -: 5200:# ifdef HAVE_LIBINTL_H
        -: 5201:#  include <libintl.h>
        -: 5202:#  define _(msgid)	gettext (msgid)
        -: 5203:# else
        -: 5204:#  define _(msgid)	(msgid)
        -: 5205:# endif
        -: 5206:#endif
        -: 5207:
        -: 5208:/* This version of `getopt' appears to the caller like standard Unix `getopt'
        -: 5209:   but it behaves differently for the user, since it allows the user
        -: 5210:   to intersperse the options with the other arguments.
        -: 5211:
        -: 5212:   As `getopt' works, it permutes the elements of ARGV so that,
        -: 5213:   when it is done, all the options precede everything else.  Thus
        -: 5214:   all application programs are extended to handle flexible argument order.
        -: 5215:
        -: 5216:   Setting the environment variable POSIXLY_CORRECT disables permutation.
        -: 5217:   Then the behavior is completely standard.
        -: 5218:
        -: 5219:   GNU application programs can use a third alternative mode in which
        -: 5220:   they can distinguish the relative order of options and other arguments.  */
        -: 5221:
        -: 5222:#include "getopt.h"
        -: 5223:
        -: 5224:/* For communication from `getopt' to the caller.
        -: 5225:   When `getopt' finds an option that takes an argument,
        -: 5226:   the argument value is returned here.
        -: 5227:   Also, when `ordering' is RETURN_IN_ORDER,
        -: 5228:   each non-option ARGV-element is returned here.  */
        -: 5229:
        -: 5230:char *optarg = NULL;
        -: 5231:
        -: 5232:/* Index in ARGV of the next element to be scanned.
        -: 5233:   This is used for communication to and from the caller
        -: 5234:   and for communication between successive calls to `getopt'.
        -: 5235:
        -: 5236:   On entry to `getopt', zero means this is the first call; initialize.
        -: 5237:
        -: 5238:   When `getopt' returns -1, this is the index of the first of the
        -: 5239:   non-option elements that the caller should itself scan.
        -: 5240:
        -: 5241:   Otherwise, `optind' communicates from one call to the next
        -: 5242:   how much of ARGV has been scanned so far.  */
        -: 5243:
        -: 5244:/* 1003.2 says this must be 1 before any call.  */
        -: 5245:int optind = 1;
        -: 5246:
        -: 5247:/* Formerly, initialization of getopt depended on optind==0, which
        -: 5248:   causes problems with re-calling getopt as programs generally don't
        -: 5249:   know that. */
        -: 5250:
        -: 5251:int __getopt_initialized = 0;
        -: 5252:
        -: 5253:/* The next char to be scanned in the option-element
        -: 5254:   in which the last option character we returned was found.
        -: 5255:   This allows us to pick up the scan where we left off.
        -: 5256:
        -: 5257:   If this is zero, or a null string, it means resume the scan
        -: 5258:   by advancing to the next ARGV-element.  */
        -: 5259:
        -: 5260:static char *nextchar;
        -: 5261:
        -: 5262:/* Callers store zero here to inhibit the error message
        -: 5263:   for unrecognized options.  */
        -: 5264:
        -: 5265:int opterr = 1;
        -: 5266:
        -: 5267:/* Set to an option character which was unrecognized.
        -: 5268:   This must be initialized on some systems to avoid linking in the
        -: 5269:   system's own getopt implementation.  */
        -: 5270:
        -: 5271:int optopt = '?';
        -: 5272:
        -: 5273:/* Describe how to deal with options that follow non-option ARGV-elements.
        -: 5274:
        -: 5275:   If the caller did not specify anything,
        -: 5276:   the default is REQUIRE_ORDER if the environment variable
        -: 5277:   POSIXLY_CORRECT is defined, PERMUTE otherwise.
        -: 5278:
        -: 5279:   REQUIRE_ORDER means don't recognize them as options;
        -: 5280:   stop option processing when the first non-option is seen.
        -: 5281:   This is what Unix does.
        -: 5282:   This mode of operation is selected by either setting the environment
        -: 5283:   variable POSIXLY_CORRECT, or using `+' as the first character
        -: 5284:   of the list of option characters.
        -: 5285:
        -: 5286:   PERMUTE is the default.  We permute the contents of ARGV as we scan,
        -: 5287:   so that eventually all the non-options are at the end.  This allows options
        -: 5288:   to be given in any order, even with programs that were not written to
        -: 5289:   expect this.
        -: 5290:
        -: 5291:   RETURN_IN_ORDER is an option available to programs that were written
        -: 5292:   to expect options and other ARGV-elements in any order and that care about
        -: 5293:   the ordering of the two.  We describe each non-option ARGV-element
        -: 5294:   as if it were the argument of an option with character code 1.
        -: 5295:   Using `-' as the first character of the list of option characters
        -: 5296:   selects this mode of operation.
        -: 5297:
        -: 5298:   The special argument `--' forces an end of option-scanning regardless
        -: 5299:   of the value of `ordering'.  In the case of RETURN_IN_ORDER, only
        -: 5300:   `--' can cause `getopt' to return -1 with `optind' != ARGC.  */
        -: 5301:
        -: 5302:static enum
        -: 5303:{
        -: 5304:  REQUIRE_ORDER, PERMUTE, RETURN_IN_ORDER
        -: 5305:} ordering;
        -: 5306:
        -: 5307:/* Value of POSIXLY_CORRECT environment variable.  */
        -: 5308:static char *posixly_correct;
        -: 5309:
        -: 5310:#ifdef	__GNU_LIBRARY__
        -: 5311:/* We want to avoid inclusion of string.h with non-GNU libraries
        -: 5312:   because there are many ways it can cause trouble.
        -: 5313:   On some systems, it contains special magic macros that don't work
        -: 5314:   in GCC.  */
        -: 5315:# include <string.h>
        -: 5316:# define my_index	strchr
        -: 5317:#else
        -: 5318:
        -: 5319:/* Avoid depending on library functions or files
        -: 5320:   whose names are inconsistent.  */
        -: 5321:
        -: 5322:#ifndef getenv
        -: 5323:extern char *getenv ();
        -: 5324:#endif
        -: 5325:#ifndef strncmp
        -: 5326:extern int strncmp ();
        -: 5327:#endif
        -: 5328:
        -: 5329:static char *
        -: 5330:my_index (str, chr)
        -: 5331:     const char *str;
        -: 5332:     int chr;
        -: 5333:{
        -: 5334:  while (*str)
        -: 5335:    {
        -: 5336:      if (*str == chr)
        -: 5337:	return (char *) str;
        -: 5338:      str++;
        -: 5339:    }
        -: 5340:  return 0;
        -: 5341:}
        -: 5342:
        -: 5343:/* If using GCC, we can safely declare strlen this way.
        -: 5344:   If not using GCC, it is ok not to declare it.  */
        -: 5345:#ifdef __GNUC__
        -: 5346:/* Note that Motorola Delta 68k R3V7 comes with GCC but not stddef.h.
        -: 5347:   That was relevant to code that was here before.  */
        -: 5348:# if (!defined __STDC__ || !__STDC__) && !defined strlen
        -: 5349:/* gcc with -traditional declares the built-in strlen to return int,
        -: 5350:   and has done so at least since version 2.4.5. -- rms.  */
        -: 5351:extern int strlen (const char *);
        -: 5352:# endif /* not __STDC__ */
        -: 5353:#endif /* __GNUC__ */
        -: 5354:
        -: 5355:#endif /* not __GNU_LIBRARY__ */
        -: 5356:
        -: 5357:/* Handle permutation of arguments.  */
        -: 5358:
        -: 5359:/* Describe the part of ARGV that contains non-options that have
        -: 5360:   been skipped.  `first_nonopt' is the index in ARGV of the first of them;
        -: 5361:   `last_nonopt' is the index after the last of them.  */
        -: 5362:
        -: 5363:static int first_nonopt;
        -: 5364:static int last_nonopt;
        -: 5365:
        -: 5366:#ifdef _LIBC
        -: 5367:/* Bash 2.0 gives us an environment variable containing flags
        -: 5368:   indicating ARGV elements that should not be considered arguments.  */
        -: 5369:
        -: 5370:/* Defined in getopt_init.c  */
        -: 5371:extern char *__getopt_nonoption_flags;
        -: 5372:
        -: 5373:static int nonoption_flags_max_len;
        -: 5374:static int nonoption_flags_len;
        -: 5375:
        -: 5376:static int original_argc;
        -: 5377:static char *const *original_argv;
        -: 5378:
        -: 5379:/* Make sure the environment variable bash 2.0 puts in the environment
        -: 5380:   is valid for the getopt call we must make sure that the ARGV passed
        -: 5381:   to getopt is that one passed to the process.  */
        -: 5382:static void
        -: 5383:__attribute__ ((unused))
        -: 5384:store_args_and_env (int argc, char *const *argv)
        -: 5385:{
        -: 5386:  /* XXX This is no good solution.  We should rather copy the args so
        -: 5387:     that we can compare them later.  But we must not use malloc(3).  */
        -: 5388:  original_argc = argc;
        -: 5389:  original_argv = argv;
        -: 5390:}
        -: 5391:# ifdef text_set_element
        -: 5392:text_set_element (__libc_subinit, store_args_and_env);
        -: 5393:# endif /* text_set_element */
        -: 5394:
        -: 5395:# define SWAP_FLAGS(ch1, ch2) \
        -: 5396:  if (nonoption_flags_len > 0)						      \
        -: 5397:    {									      \
        -: 5398:      char __tmp = __getopt_nonoption_flags[ch1];			      \
        -: 5399:      __getopt_nonoption_flags[ch1] = __getopt_nonoption_flags[ch2];	      \
        -: 5400:      __getopt_nonoption_flags[ch2] = __tmp;				      \
        -: 5401:    }
        -: 5402:#else	/* !_LIBC */
        -: 5403:# define SWAP_FLAGS(ch1, ch2)
        -: 5404:#endif	/* _LIBC */
        -: 5405:
        -: 5406:/* Exchange two adjacent subsequences of ARGV.
        -: 5407:   One subsequence is elements [first_nonopt,last_nonopt)
        -: 5408:   which contains all the non-options that have been skipped so far.
        -: 5409:   The other is elements [last_nonopt,optind), which contains all
        -: 5410:   the options processed since those non-options were skipped.
        -: 5411:
        -: 5412:   `first_nonopt' and `last_nonopt' are relocated so that they describe
        -: 5413:   the new indices of the non-options in ARGV after they are moved.  */
        -: 5414:
        -: 5415:#if defined __STDC__ && __STDC__
        -: 5416:static void exchange (char **);
        -: 5417:#endif
        -: 5418:
        -: 5419:static void
        -: 5420:exchange (argv)
        -: 5421:     char **argv;
        -: 5422:{
        -: 5423:  int bottom = first_nonopt;
        -: 5424:  int middle = last_nonopt;
        -: 5425:  int top = optind;
        -: 5426:  char *tem;
        -: 5427:
        -: 5428:  /* Exchange the shorter segment with the far end of the longer segment.
        -: 5429:     That puts the shorter segment into the right place.
        -: 5430:     It leaves the longer segment in the right place overall,
        -: 5431:     but it consists of two parts that need to be swapped next.  */
        -: 5432:
        -: 5433:#ifdef _LIBC
        -: 5434:  /* First make sure the handling of the `__getopt_nonoption_flags'
        -: 5435:     string can work normally.  Our top argument must be in the range
        -: 5436:     of the string.  */
        -: 5437:  if (nonoption_flags_len > 0 && top >= nonoption_flags_max_len)
        -: 5438:    {
        -: 5439:      /* We must extend the array.  The user plays games with us and
        -: 5440:	 presents new arguments.  */
        -: 5441:      char *new_str = malloc (top + 1);
        -: 5442:      if (new_str == NULL)
        -: 5443:	nonoption_flags_len = nonoption_flags_max_len = 0;
        -: 5444:      else
        -: 5445:	{
        -: 5446:	  memset (__mempcpy (new_str, __getopt_nonoption_flags,
        -: 5447:			     nonoption_flags_max_len),
        -: 5448:		  '\0', top + 1 - nonoption_flags_max_len);
        -: 5449:	  nonoption_flags_max_len = top + 1;
        -: 5450:	  __getopt_nonoption_flags = new_str;
        -: 5451:	}
        -: 5452:    }
        -: 5453:#endif
        -: 5454:
        -: 5455:  while (top > middle && middle > bottom)
        -: 5456:    {
        -: 5457:      if (top - middle > middle - bottom)
        -: 5458:	{
        -: 5459:	  /* Bottom segment is the short one.  */
        -: 5460:	  int len = middle - bottom;
        -: 5461:	  register int i;
        -: 5462:
        -: 5463:	  /* Swap it with the top part of the top segment.  */
        -: 5464:	  for (i = 0; i < len; i++)
        -: 5465:	    {
        -: 5466:	      tem = argv[bottom + i];
        -: 5467:	      argv[bottom + i] = argv[top - (middle - bottom) + i];
        -: 5468:	      argv[top - (middle - bottom) + i] = tem;
        -: 5469:	      SWAP_FLAGS (bottom + i, top - (middle - bottom) + i);
        -: 5470:	    }
        -: 5471:	  /* Exclude the moved bottom segment from further swapping.  */
        -: 5472:	  top -= len;
        -: 5473:	}
        -: 5474:      else
        -: 5475:	{
        -: 5476:	  /* Top segment is the short one.  */
        -: 5477:	  int len = top - middle;
        -: 5478:	  register int i;
        -: 5479:
        -: 5480:	  /* Swap it with the bottom part of the bottom segment.  */
        -: 5481:	  for (i = 0; i < len; i++)
        -: 5482:	    {
        -: 5483:	      tem = argv[bottom + i];
        -: 5484:	      argv[bottom + i] = argv[middle + i];
        -: 5485:	      argv[middle + i] = tem;
        -: 5486:	      SWAP_FLAGS (bottom + i, middle + i);
        -: 5487:	    }
        -: 5488:	  /* Exclude the moved top segment from further swapping.  */
        -: 5489:	  bottom += len;
        -: 5490:	}
        -: 5491:    }
        -: 5492:
        -: 5493:  /* Update records for the slots the non-options now occupy.  */
        -: 5494:
        -: 5495:  first_nonopt += (optind - last_nonopt);
        -: 5496:  last_nonopt = optind;
        -: 5497:}
        -: 5498:
        -: 5499:/* Initialize the internal data when the first call is made.  */
        -: 5500:
        -: 5501:#if defined __STDC__ && __STDC__
        -: 5502:static const char *_getopt_initialize (int, char *const *, const char *);
        -: 5503:#endif
        -: 5504:static const char *
        -: 5505:_getopt_initialize (argc, argv, optstring)
        -: 5506:     int argc;
        -: 5507:     char *const *argv;
        -: 5508:     const char *optstring;
        -: 5509:{
        -: 5510:  /* Start processing options with ARGV-element 1 (since ARGV-element 0
        -: 5511:     is the program name); the sequence of previously skipped
        -: 5512:     non-option ARGV-elements is empty.  */
        -: 5513:
        -: 5514:  first_nonopt = last_nonopt = optind;
        -: 5515:
        -: 5516:  nextchar = NULL;
        -: 5517:
        -: 5518:  posixly_correct = getenv ("POSIXLY_CORRECT");
        -: 5519:
        -: 5520:  /* Determine how to handle the ordering of options and nonoptions.  */
        -: 5521:
        -: 5522:  if (optstring[0] == '-')
        -: 5523:    {
        -: 5524:      ordering = RETURN_IN_ORDER;
        -: 5525:      ++optstring;
        -: 5526:    }
        -: 5527:  else if (optstring[0] == '+')
        -: 5528:    {
        -: 5529:      ordering = REQUIRE_ORDER;
        -: 5530:      ++optstring;
        -: 5531:    }
        -: 5532:  else if (posixly_correct != NULL)
        -: 5533:    ordering = REQUIRE_ORDER;
        -: 5534:  else
        -: 5535:    ordering = PERMUTE;
        -: 5536:
        -: 5537:#ifdef _LIBC
        -: 5538:  if (posixly_correct == NULL
        -: 5539:      && argc == original_argc && argv == original_argv)
        -: 5540:    {
        -: 5541:      if (nonoption_flags_max_len == 0)
        -: 5542:	{
        -: 5543:	  if (__getopt_nonoption_flags == NULL
        -: 5544:	      || __getopt_nonoption_flags[0] == '\0')
        -: 5545:	    nonoption_flags_max_len = -1;
        -: 5546:	  else
        -: 5547:	    {
        -: 5548:	      const char *orig_str = __getopt_nonoption_flags;
        -: 5549:	      int len = nonoption_flags_max_len = strlen (orig_str);
        -: 5550:	      if (nonoption_flags_max_len < argc)
        -: 5551:		nonoption_flags_max_len = argc;
        -: 5552:	      __getopt_nonoption_flags =
        -: 5553:		(char *) malloc (nonoption_flags_max_len);
        -: 5554:	      if (__getopt_nonoption_flags == NULL)
        -: 5555:		nonoption_flags_max_len = -1;
        -: 5556:	      else
        -: 5557:		memset (__mempcpy (__getopt_nonoption_flags, orig_str, len),
        -: 5558:			'\0', nonoption_flags_max_len - len);
        -: 5559:	    }
        -: 5560:	}
        -: 5561:      nonoption_flags_len = nonoption_flags_max_len;
        -: 5562:    }
        -: 5563:  else
        -: 5564:    nonoption_flags_len = 0;
        -: 5565:#endif
        -: 5566:
        -: 5567:  return optstring;
        -: 5568:}
        -: 5569:
        -: 5570:/* Scan elements of ARGV (whose length is ARGC) for option characters
        -: 5571:   given in OPTSTRING.
        -: 5572:
        -: 5573:   If an element of ARGV starts with '-', and is not exactly "-" or "--",
        -: 5574:   then it is an option element.  The characters of this element
        -: 5575:   (aside from the initial '-') are option characters.  If `getopt'
        -: 5576:   is called repeatedly, it returns successively each of the option characters
        -: 5577:   from each of the option elements.
        -: 5578:
        -: 5579:   If `getopt' finds another option character, it returns that character,
        -: 5580:   updating `optind' and `nextchar' so that the next call to `getopt' can
        -: 5581:   resume the scan with the following option character or ARGV-element.
        -: 5582:
        -: 5583:   If there are no more option characters, `getopt' returns -1.
        -: 5584:   Then `optind' is the index in ARGV of the first ARGV-element
        -: 5585:   that is not an option.  (The ARGV-elements have been permuted
        -: 5586:   so that those that are not options now come last.)
        -: 5587:
        -: 5588:   OPTSTRING is a string containing the legitimate option characters.
        -: 5589:   If an option character is seen that is not listed in OPTSTRING,
        -: 5590:   return '?' after printing an error message.  If you set `opterr' to
        -: 5591:   zero, the error message is suppressed but we still return '?'.
        -: 5592:
        -: 5593:   If a char in OPTSTRING is followed by a colon, that means it wants an arg,
        -: 5594:   so the following text in the same ARGV-element, or the text of the following
        -: 5595:   ARGV-element, is returned in `optarg'.  Two colons mean an option that
        -: 5596:   wants an optional arg; if there is text in the current ARGV-element,
        -: 5597:   it is returned in `optarg', otherwise `optarg' is set to zero.
        -: 5598:
        -: 5599:   If OPTSTRING starts with `-' or `+', it requests different methods of
        -: 5600:   handling the non-option ARGV-elements.
        -: 5601:   See the comments about RETURN_IN_ORDER and REQUIRE_ORDER, above.
        -: 5602:
        -: 5603:   Long-named options begin with `--' instead of `-'.
        -: 5604:   Their names may be abbreviated as long as the abbreviation is unique
        -: 5605:   or is an exact match for some defined option.  If they have an
        -: 5606:   argument, it follows the option name in the same ARGV-element, separated
        -: 5607:   from the option name by a `=', or else the in next ARGV-element.
        -: 5608:   When `getopt' finds a long-named option, it returns 0 if that option's
        -: 5609:   `flag' field is nonzero, the value of the option's `val' field
        -: 5610:   if the `flag' field is zero.
        -: 5611:
        -: 5612:   The elements of ARGV aren't really const, because we permute them.
        -: 5613:   But we pretend they're const in the prototype to be compatible
        -: 5614:   with other systems.
        -: 5615:
        -: 5616:   LONGOPTS is a vector of `struct option' terminated by an
        -: 5617:   element containing a name which is zero.
        -: 5618:
        -: 5619:   LONGIND returns the index in LONGOPT of the long-named option found.
        -: 5620:   It is only valid when a long-named option has been found by the most
        -: 5621:   recent call.
        -: 5622:
        -: 5623:   If LONG_ONLY is nonzero, '-' as well as '--' can introduce
        -: 5624:   long-named options.  */
        -: 5625:
        -: 5626:#undef stderr
        -: 5627:#define stderr stdout
        -: 5628:int
        -: 5629:_getopt_internal (argc, argv, optstring, longopts, longind, long_only)
        -: 5630:     int argc;
        -: 5631:     char *const *argv;
        -: 5632:     const char *optstring;
        -: 5633:     const struct option *longopts;
        -: 5634:     int *longind;
        -: 5635:     int long_only;
        -: 5636:{
        -: 5637:  optarg = NULL;
        -: 5638:
        -: 5639:  if (optind == 0 || !__getopt_initialized)
        -: 5640:    {
        -: 5641:      if (optind == 0)
        -: 5642:	optind = 1;	/* Don't scan ARGV[0], the program name.  */
        -: 5643:      optstring = _getopt_initialize (argc, argv, optstring);
        -: 5644:      __getopt_initialized = 1;
        -: 5645:    }
        -: 5646:
        -: 5647:  /* Test whether ARGV[optind] points to a non-option argument.
        -: 5648:     Either it does not have option syntax, or there is an environment flag
        -: 5649:     from the shell indicating it is not an option.  The later information
        -: 5650:     is only used when the used in the GNU libc.  */
        -: 5651:#ifdef _LIBC
        -: 5652:# define NONOPTION_P (argv[optind][0] != '-' || argv[optind][1] == '\0'	      \
        -: 5653:		      || (optind < nonoption_flags_len			      \
        -: 5654:			  && __getopt_nonoption_flags[optind] == '1'))
        -: 5655:#else
        -: 5656:# define NONOPTION_P (argv[optind][0] != '-' || argv[optind][1] == '\0')
        -: 5657:#endif
        -: 5658:
        -: 5659:  if (nextchar == NULL || *nextchar == '\0')
        -: 5660:    {
        -: 5661:      /* Advance to the next ARGV-element.  */
        -: 5662:
        -: 5663:      /* Give FIRST_NONOPT & LAST_NONOPT rational values if OPTIND has been
        -: 5664:	 moved back by the user (who may also have changed the arguments).  */
        -: 5665:      if (last_nonopt > optind)
        -: 5666:	last_nonopt = optind;
        -: 5667:      if (first_nonopt > optind)
        -: 5668:	first_nonopt = optind;
        -: 5669:
        -: 5670:      if (ordering == PERMUTE)
        -: 5671:	{
        -: 5672:	  /* If we have just processed some options following some non-options,
        -: 5673:	     exchange them so that the options come first.  */
        -: 5674:
        -: 5675:	  if (first_nonopt != last_nonopt && last_nonopt != optind)
        -: 5676:	    exchange ((char **) argv);
        -: 5677:	  else if (last_nonopt != optind)
        -: 5678:	    first_nonopt = optind;
        -: 5679:
        -: 5680:	  /* Skip any additional non-options
        -: 5681:	     and extend the range of non-options previously skipped.  */
        -: 5682:
        -: 5683:	  while (optind < argc && NONOPTION_P)
        -: 5684:	    optind++;
        -: 5685:	  last_nonopt = optind;
        -: 5686:	}
        -: 5687:
        -: 5688:      /* The special ARGV-element `--' means premature end of options.
        -: 5689:	 Skip it like a null option,
        -: 5690:	 then exchange with previous non-options as if it were an option,
        -: 5691:	 then skip everything else like a non-option.  */
        -: 5692:
        -: 5693:      if (optind != argc && !strcmp (argv[optind], "--"))
        -: 5694:	{
        -: 5695:	  optind++;
        -: 5696:
        -: 5697:	  if (first_nonopt != last_nonopt && last_nonopt != optind)
        -: 5698:	    exchange ((char **) argv);
        -: 5699:	  else if (first_nonopt == last_nonopt)
        -: 5700:	    first_nonopt = optind;
        -: 5701:	  last_nonopt = argc;
        -: 5702:
        -: 5703:	  optind = argc;
        -: 5704:	}
        -: 5705:
        -: 5706:      /* If we have done all the ARGV-elements, stop the scan
        -: 5707:	 and back over any non-options that we skipped and permuted.  */
        -: 5708:
        -: 5709:      if (optind == argc)
        -: 5710:	{
        -: 5711:	  /* Set the next-arg-index to point at the non-options
        -: 5712:	     that we previously skipped, so the caller will digest them.  */
        -: 5713:	  if (first_nonopt != last_nonopt)
        -: 5714:	    optind = first_nonopt;
        -: 5715:	  return -1;
        -: 5716:	}
        -: 5717:
        -: 5718:      /* If we have come to a non-option and did not permute it,
        -: 5719:	 either stop the scan or describe it to the caller and pass it by.  */
        -: 5720:
        -: 5721:      if (NONOPTION_P)
        -: 5722:	{
        -: 5723:	  if (ordering == REQUIRE_ORDER)
        -: 5724:	    return -1;
        -: 5725:	  optarg = argv[optind++];
        -: 5726:	  return 1;
        -: 5727:	}
        -: 5728:
        -: 5729:      /* We have found another option-ARGV-element.
        -: 5730:	 Skip the initial punctuation.  */
        -: 5731:
        -: 5732:      nextchar = (argv[optind] + 1
        -: 5733:		  + (longopts != NULL && argv[optind][1] == '-'));
        -: 5734:    }
        -: 5735:
        -: 5736:  /* Decode the current option-ARGV-element.  */
        -: 5737:
        -: 5738:  /* Check whether the ARGV-element is a long option.
        -: 5739:
        -: 5740:     If long_only and the ARGV-element has the form "-f", where f is
        -: 5741:     a valid short option, don't consider it an abbreviated form of
        -: 5742:     a long option that starts with f.  Otherwise there would be no
        -: 5743:     way to give the -f short option.
        -: 5744:
        -: 5745:     On the other hand, if there's a long option "fubar" and
        -: 5746:     the ARGV-element is "-fu", do consider that an abbreviation of
        -: 5747:     the long option, just like "--fu", and not "-f" with arg "u".
        -: 5748:
        -: 5749:     This distinction seems to be the most useful approach.  */
        -: 5750:
        -: 5751:  if (longopts != NULL
        -: 5752:      && (argv[optind][1] == '-'
        -: 5753:	  || (long_only && (argv[optind][2] || !my_index (optstring, argv[optind][1])))))
        -: 5754:    {
        -: 5755:      char *nameend;
        -: 5756:      const struct option *p;
        -: 5757:      const struct option *pfound = NULL;
        -: 5758:      int exact = 0;
        -: 5759:      int ambig = 0;
        -: 5760:      int indfound = -1;
        -: 5761:      int option_index;
        -: 5762:
        -: 5763:      for (nameend = nextchar; *nameend && *nameend != '='; nameend++)
        -: 5764:	/* Do nothing.  */ ;
        -: 5765:
        -: 5766:      /* Test all long options for either exact match
        -: 5767:	 or abbreviated matches.  */
        -: 5768:      for (p = longopts, option_index = 0; p->name; p++, option_index++)
        -: 5769:	if (!strncmp (p->name, nextchar, nameend - nextchar))
        -: 5770:	  {
        -: 5771:	    if ((unsigned int) (nameend - nextchar)
        -: 5772:		== (unsigned int) strlen (p->name))
        -: 5773:	      {
        -: 5774:		/* Exact match found.  */
        -: 5775:		pfound = p;
        -: 5776:		indfound = option_index;
        -: 5777:		exact = 1;
        -: 5778:		break;
        -: 5779:	      }
        -: 5780:	    else if (pfound == NULL)
        -: 5781:	      {
        -: 5782:		/* First nonexact match found.  */
        -: 5783:		pfound = p;
        -: 5784:		indfound = option_index;
        -: 5785:	      }
        -: 5786:	    else
        -: 5787:	      /* Second or later nonexact match found.  */
        -: 5788:	      ambig = 1;
        -: 5789:	  }
        -: 5790:
        -: 5791:      if (ambig && !exact)
        -: 5792:	{
        -: 5793:	  if (opterr)
        -: 5794:	    fprintf (stderr, _("%s: option `%s' is ambiguous\n"),
        -: 5795:		     argv[0], argv[optind]);
        -: 5796:	  nextchar += strlen (nextchar);
        -: 5797:	  optind++;
        -: 5798:	  optopt = 0;
        -: 5799:	  return '?';
        -: 5800:	}
        -: 5801:
        -: 5802:      if (pfound != NULL)
        -: 5803:	{
        -: 5804:	  option_index = indfound;
        -: 5805:	  optind++;
        -: 5806:	  if (*nameend)
        -: 5807:	    {
        -: 5808:	      /* Don't test has_arg with >, because some C compilers don't
        -: 5809:		 allow it to be used on enums.  */
        -: 5810:	      if (pfound->has_arg)
        -: 5811:		optarg = nameend + 1;
        -: 5812:	      else
        -: 5813:		{
        -: 5814:		  if (opterr)
        -: 5815:		   if (argv[optind - 1][1] == '-')
        -: 5816:		    /* --option */
        -: 5817:		    fprintf (stderr,
        -: 5818:		     _("%s: option `--%s' doesn't allow an argument\n"),
        -: 5819:		     argv[0], pfound->name);
        -: 5820:		   else
        -: 5821:		    /* +option or -option */
        -: 5822:		    fprintf (stderr,
        -: 5823:		     _("%s: option `%c%s' doesn't allow an argument\n"),
        -: 5824:		     argv[0], argv[optind - 1][0], pfound->name);
        -: 5825:
        -: 5826:		  nextchar += strlen (nextchar);
        -: 5827:
        -: 5828:		  optopt = pfound->val;
        -: 5829:		  return '?';
        -: 5830:		}
        -: 5831:	    }
        -: 5832:	  else if (pfound->has_arg == 1)
        -: 5833:	    {
        -: 5834:	      if (optind < argc)
        -: 5835:		optarg = argv[optind++];
        -: 5836:	      else
        -: 5837:		{
        -: 5838:		  if (opterr)
        -: 5839:		    fprintf (stderr,
        -: 5840:			   _("%s: option `%s' requires an argument\n"),
        -: 5841:			   argv[0], argv[optind - 1]);
        -: 5842:		  nextchar += strlen (nextchar);
        -: 5843:		  optopt = pfound->val;
        -: 5844:		  return optstring[0] == ':' ? ':' : '?';
        -: 5845:		}
        -: 5846:	    }
        -: 5847:	  nextchar += strlen (nextchar);
        -: 5848:	  if (longind != NULL)
        -: 5849:	    *longind = option_index;
        -: 5850:	  if (pfound->flag)
        -: 5851:	    {
        -: 5852:	      *(pfound->flag) = pfound->val;
        -: 5853:	      return 0;
        -: 5854:	    }
        -: 5855:	  return pfound->val;
        -: 5856:	}
        -: 5857:
        -: 5858:      /* Can't find it as a long option.  If this is not getopt_long_only,
        -: 5859:	 or the option starts with '--' or is not a valid short
        -: 5860:	 option, then it's an error.
        -: 5861:	 Otherwise interpret it as a short option.  */
        -: 5862:      if (!long_only || argv[optind][1] == '-'
        -: 5863:	  || my_index (optstring, *nextchar) == NULL)
        -: 5864:	{
        -: 5865:	  if (opterr)
        -: 5866:	    {
        -: 5867:	      if (argv[optind][1] == '-')
        -: 5868:		/* --option */
        -: 5869:		fprintf (stderr, _("%s: unrecognized option `--%s'\n"),
        -: 5870:			 argv[0], nextchar);
        -: 5871:	      else
        -: 5872:		/* +option or -option */
        -: 5873:		fprintf (stderr, _("%s: unrecognized option `%c%s'\n"),
        -: 5874:			 argv[0], argv[optind][0], nextchar);
        -: 5875:	    }
        -: 5876:	  nextchar = (char *) "";
        -: 5877:	  optind++;
        -: 5878:	  optopt = 0;
        -: 5879:	  return '?';
        -: 5880:	}
        -: 5881:    }
        -: 5882:
        -: 5883:  /* Look at and handle the next short option-character.  */
        -: 5884:
        -: 5885:  {
        -: 5886:    char c = *nextchar++;
        -: 5887:    char *temp = my_index (optstring, c);
        -: 5888:
        -: 5889:    /* Increment `optind' when we start to process its last character.  */
        -: 5890:    if (*nextchar == '\0')
        -: 5891:      ++optind;
        -: 5892:
        -: 5893:    if (temp == NULL || c == ':')
        -: 5894:      {
        -: 5895:	if (opterr)
        -: 5896:	  {
        -: 5897:	    if (posixly_correct)
        -: 5898:	      /* 1003.2 specifies the format of this message.  */
        -: 5899:	      fprintf (stderr, _("%s: illegal option -- %c\n"),
        -: 5900:		       argv[0], c);
        -: 5901:	    else
        -: 5902:	      fprintf (stderr, _("%s: invalid option -- %c\n"),
        -: 5903:		       argv[0], c);
        -: 5904:	  }
        -: 5905:	optopt = c;
        -: 5906:	return '?';
        -: 5907:      }
        -: 5908:    /* Convenience. Treat POSIX -W foo same as long option --foo */
        -: 5909:    if (temp[0] == 'W' && temp[1] == ';')
        -: 5910:      {
        -: 5911:	char *nameend;
        -: 5912:	const struct option *p;
        -: 5913:	const struct option *pfound = NULL;
        -: 5914:	int exact = 0;
        -: 5915:	int ambig = 0;
        -: 5916:	int indfound = 0;
        -: 5917:	int option_index;
        -: 5918:
        -: 5919:	/* This is an option that requires an argument.  */
        -: 5920:	if (*nextchar != '\0')
        -: 5921:	  {
        -: 5922:	    optarg = nextchar;
        -: 5923:	    /* If we end this ARGV-element by taking the rest as an arg,
        -: 5924:	       we must advance to the next element now.  */
        -: 5925:	    optind++;
        -: 5926:	  }
        -: 5927:	else if (optind == argc)
        -: 5928:	  {
        -: 5929:	    if (opterr)
        -: 5930:	      {
        -: 5931:		/* 1003.2 specifies the format of this message.  */
        -: 5932:		fprintf (stderr, _("%s: option requires an argument -- %c\n"),
        -: 5933:			 argv[0], c);
        -: 5934:	      }
        -: 5935:	    optopt = c;
        -: 5936:	    if (optstring[0] == ':')
        -: 5937:	      c = ':';
        -: 5938:	    else
        -: 5939:	      c = '?';
        -: 5940:	    return c;
        -: 5941:	  }
        -: 5942:	else
        -: 5943:	  /* We already incremented `optind' once;
        -: 5944:	     increment it again when taking next ARGV-elt as argument.  */
        -: 5945:	  optarg = argv[optind++];
        -: 5946:
        -: 5947:	/* optarg is now the argument, see if it's in the
        -: 5948:	   table of longopts.  */
        -: 5949:
        -: 5950:	for (nextchar = nameend = optarg; *nameend && *nameend != '='; nameend++)
        -: 5951:	  /* Do nothing.  */ ;
        -: 5952:
        -: 5953:	/* Test all long options for either exact match
        -: 5954:	   or abbreviated matches.  */
        -: 5955:	for (p = longopts, option_index = 0; p->name; p++, option_index++)
        -: 5956:	  if (!strncmp (p->name, nextchar, nameend - nextchar))
        -: 5957:	    {
        -: 5958:	      if ((unsigned int) (nameend - nextchar) == strlen (p->name))
        -: 5959:		{
        -: 5960:		  /* Exact match found.  */
        -: 5961:		  pfound = p;
        -: 5962:		  indfound = option_index;
        -: 5963:		  exact = 1;
        -: 5964:		  break;
        -: 5965:		}
        -: 5966:	      else if (pfound == NULL)
        -: 5967:		{
        -: 5968:		  /* First nonexact match found.  */
        -: 5969:		  pfound = p;
        -: 5970:		  indfound = option_index;
        -: 5971:		}
        -: 5972:	      else
        -: 5973:		/* Second or later nonexact match found.  */
        -: 5974:		ambig = 1;
        -: 5975:	    }
        -: 5976:	if (ambig && !exact)
        -: 5977:	  {
        -: 5978:	    if (opterr)
        -: 5979:	      fprintf (stderr, _("%s: option `-W %s' is ambiguous\n"),
        -: 5980:		       argv[0], argv[optind]);
        -: 5981:	    nextchar += strlen (nextchar);
        -: 5982:	    optind++;
        -: 5983:	    return '?';
        -: 5984:	  }
        -: 5985:	if (pfound != NULL)
        -: 5986:	  {
        -: 5987:	    option_index = indfound;
        -: 5988:	    if (*nameend)
        -: 5989:	      {
        -: 5990:		/* Don't test has_arg with >, because some C compilers don't
        -: 5991:		   allow it to be used on enums.  */
        -: 5992:		if (pfound->has_arg)
        -: 5993:		  optarg = nameend + 1;
        -: 5994:		else
        -: 5995:		  {
        -: 5996:		    if (opterr)
        -: 5997:		      fprintf (stderr, _("\
        -: 5998:%s: option `-W %s' doesn't allow an argument\n"),
        -: 5999:			       argv[0], pfound->name);
        -: 6000:
        -: 6001:		    nextchar += strlen (nextchar);
        -: 6002:		    return '?';
        -: 6003:		  }
        -: 6004:	      }
        -: 6005:	    else if (pfound->has_arg == 1)
        -: 6006:	      {
        -: 6007:		if (optind < argc)
        -: 6008:		  optarg = argv[optind++];
        -: 6009:		else
        -: 6010:		  {
        -: 6011:		    if (opterr)
        -: 6012:		      fprintf (stderr,
        -: 6013:			       _("%s: option `%s' requires an argument\n"),
        -: 6014:			       argv[0], argv[optind - 1]);
        -: 6015:		    nextchar += strlen (nextchar);
        -: 6016:		    return optstring[0] == ':' ? ':' : '?';
        -: 6017:		  }
        -: 6018:	      }
        -: 6019:	    nextchar += strlen (nextchar);
        -: 6020:	    if (longind != NULL)
        -: 6021:	      *longind = option_index;
        -: 6022:	    if (pfound->flag)
        -: 6023:	      {
        -: 6024:		*(pfound->flag) = pfound->val;
        -: 6025:		return 0;
        -: 6026:	      }
        -: 6027:	    return pfound->val;
        -: 6028:	  }
        -: 6029:	  nextchar = NULL;
        -: 6030:	  return 'W';	/* Let the application handle it.   */
        -: 6031:      }
        -: 6032:    if (temp[1] == ':')
        -: 6033:      {
        -: 6034:	if (temp[2] == ':')
        -: 6035:	  {
        -: 6036:	    /* This is an option that accepts an argument optionally.  */
        -: 6037:	    if (*nextchar != '\0')
        -: 6038:	      {
        -: 6039:		optarg = nextchar;
        -: 6040:		optind++;
        -: 6041:	      }
        -: 6042:	    else
        -: 6043:	      optarg = NULL;
        -: 6044:	    nextchar = NULL;
        -: 6045:	  }
        -: 6046:	else
        -: 6047:	  {
        -: 6048:	    /* This is an option that requires an argument.  */
        -: 6049:	    if (*nextchar != '\0')
        -: 6050:	      {
        -: 6051:		optarg = nextchar;
        -: 6052:		/* If we end this ARGV-element by taking the rest as an arg,
        -: 6053:		   we must advance to the next element now.  */
        -: 6054:		optind++;
        -: 6055:	      }
        -: 6056:	    else if (optind == argc)
        -: 6057:	      {
        -: 6058:		if (opterr)
        -: 6059:		  {
        -: 6060:		    /* 1003.2 specifies the format of this message.  */
        -: 6061:		    fprintf (stderr,
        -: 6062:			   _("%s: option requires an argument -- %c\n"),
        -: 6063:			   argv[0], c);
        -: 6064:		  }
        -: 6065:		optopt = c;
        -: 6066:		if (optstring[0] == ':')
        -: 6067:		  c = ':';
        -: 6068:		else
        -: 6069:		  c = '?';
        -: 6070:	      }
        -: 6071:	    else
        -: 6072:	      /* We already incremented `optind' once;
        -: 6073:		 increment it again when taking next ARGV-elt as argument.  */
        -: 6074:	      optarg = argv[optind++];
        -: 6075:	    nextchar = NULL;
        -: 6076:	  }
        -: 6077:      }
        -: 6078:    return c;
        -: 6079:  }
        -: 6080:}
        -: 6081:
        -: 6082:int
        -: 6083:getopt (argc, argv, optstring)
        -: 6084:     int argc;
        -: 6085:     char *const *argv;
        -: 6086:     const char *optstring;
        -: 6087:{
        -: 6088:  return _getopt_internal (argc, argv, optstring,
        -: 6089:			   (const struct option *) 0,
        -: 6090:			   (int *) 0,
        -: 6091:			   0);
        -: 6092:}
        -: 6093:
        -: 6094:#endif	/* Not ELIDE_CODE.  */
        -: 6095:
        -: 6096:#ifdef TEST
        -: 6097:
        -: 6098:/* Compile with -DTEST to make an executable for use in testing
        -: 6099:   the above definition of `getopt'.  */
        -: 6100:
        -: 6101:int
        -: 6102:main (argc, argv)
        -: 6103:     int argc;
        -: 6104:     char **argv;
        -: 6105:{
        -: 6106:  int c;
        -: 6107:  int digit_optind = 0;
        -: 6108:
        -: 6109:  while (1)
        -: 6110:    {
        -: 6111:      int this_option_optind = optind ? optind : 1;
        -: 6112:
        -: 6113:      c = getopt (argc, argv, "abc:d:0123456789");
        -: 6114:      if (c == -1)
        -: 6115:	break;
        -: 6116:
        -: 6117:      switch (c)
        -: 6118:	{
        -: 6119:	case '0':
        -: 6120:	case '1':
        -: 6121:	case '2':
        -: 6122:	case '3':
        -: 6123:	case '4':
        -: 6124:	case '5':
        -: 6125:	case '6':
        -: 6126:	case '7':
        -: 6127:	case '8':
        -: 6128:	case '9':
        -: 6129:	  if (digit_optind != 0 && digit_optind != this_option_optind)
        -: 6130:	    printf ("digits occur in two different argv-elements.\n");
        -: 6131:	  digit_optind = this_option_optind;
        -: 6132:	  printf ("option %c\n", c);
        -: 6133:	  break;
        -: 6134:
        -: 6135:	case 'a':
        -: 6136:	  printf ("option a\n");
        -: 6137:	  break;
        -: 6138:
        -: 6139:	case 'b':
        -: 6140:	  printf ("option b\n");
        -: 6141:	  break;
        -: 6142:
        -: 6143:	case 'c':
        -: 6144:	  printf ("option c with value `%s'\n", optarg);
        -: 6145:	  break;
        -: 6146:
        -: 6147:	case '?':
        -: 6148:	  break;
        -: 6149:
        -: 6150:	default:
        -: 6151:	  printf ("?? getopt returned character code 0%o ??\n", c);
        -: 6152:	}
        -: 6153:    }
        -: 6154:
        -: 6155:  if (optind < argc)
        -: 6156:    {
        -: 6157:      printf ("non-option ARGV-elements: ");
        -: 6158:      while (optind < argc)
        -: 6159:	printf ("%s ", argv[optind++]);
        -: 6160:      printf ("\n");
        -: 6161:    }
        -: 6162:
        -: 6163:  exit (0);
        -: 6164:}
        -: 6165:
        -: 6166:#endif /* TEST */
        -: 6167:/* getopt_long and getopt_long_only entry points for GNU getopt.
        -: 6168:   Copyright (C) 1987,88,89,90,91,92,93,94,96,97,98
        -: 6169:     Free Software Foundation, Inc.
        -: 6170:
        -: 6171:   NOTE: The canonical source of this file is maintained with the GNU C Library.
        -: 6172:   Bugs can be reported to bug-glibc@gnu.org.
        -: 6173:
        -: 6174:   This program is free software; you can redistribute it and/or modify it
        -: 6175:   under the terms of the GNU General Public License as published by the
        -: 6176:   Free Software Foundation; either version 2, or (at your option) any
        -: 6177:   later version.
        -: 6178:
        -: 6179:   This program is distributed in the hope that it will be useful,
        -: 6180:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 6181:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 6182:   GNU General Public License for more details.
        -: 6183:
        -: 6184:   You should have received a copy of the GNU General Public License
        -: 6185:   along with this program; if not, write to the Free Software
        -: 6186:   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
        -: 6187:   USA.  */
        -: 6188:
        -: 6189:#ifdef HAVE_CONFIG_H
        -: 6190:#include <config.h>
        -: 6191:#endif
        -: 6192:
        -: 6193:#include "getopt.h"
        -: 6194:
        -: 6195:#if !defined __STDC__ || !__STDC__
        -: 6196:/* This is a separate conditional since some stdc systems
        -: 6197:   reject `defined (const)'.  */
        -: 6198:#ifndef const
        -: 6199:#define const
        -: 6200:#endif
        -: 6201:#endif
        -: 6202:
        -: 6203:#include <stdio.h>
        -: 6204:
        -: 6205:/* Comment out all this code if we are using the GNU C Library, and are not
        -: 6206:   actually compiling the library itself.  This code is part of the GNU C
        -: 6207:   Library, but also included in many other GNU distributions.  Compiling
        -: 6208:   and linking in this code is a waste when using the GNU C library
        -: 6209:   (especially if it is a shared library).  Rather than having every GNU
        -: 6210:   program understand `configure --with-gnu-libc' and omit the object files,
        -: 6211:   it is simpler to just do this in the source for each such file.  */
        -: 6212:
        -: 6213:#define GETOPT_INTERFACE_VERSION 2
        -: 6214:#if !defined _LIBC && defined __GLIBC__ && __GLIBC__ >= 2
        -: 6215:#include <gnu-versions.h>
        -: 6216:#if _GNU_GETOPT_INTERFACE_VERSION == GETOPT_INTERFACE_VERSION
        -: 6217:#define ELIDE_CODE
        -: 6218:#endif
        -: 6219:#endif
        -: 6220:
        -: 6221:#ifndef ELIDE_CODE
        -: 6222:
        -: 6223:
        -: 6224:/* This needs to come after some library #include
        -: 6225:   to get __GNU_LIBRARY__ defined.  */
        -: 6226:#ifdef __GNU_LIBRARY__
        -: 6227:#include <stdlib.h>
        -: 6228:#endif
        -: 6229:
        -: 6230:#ifndef	NULL
        -: 6231:#define NULL 0
        -: 6232:#endif
        -: 6233:
        -: 6234:int
        -: 6235:getopt_long (argc, argv, options, long_options, opt_index)
        -: 6236:     int argc;
        -: 6237:     char *const *argv;
        -: 6238:     const char *options;
        -: 6239:     const struct option *long_options;
        -: 6240:     int *opt_index;
        -: 6241:{
        -: 6242:  return _getopt_internal (argc, argv, options, long_options, opt_index, 0);
        -: 6243:}
        -: 6244:
        -: 6245:/* Like getopt_long, but '-' as well as '--' can indicate a long option.
        -: 6246:   If an option that starts with '-' (not '--') doesn't match a long option,
        -: 6247:   but does match a short option, it is parsed as a short option
        -: 6248:   instead.  */
        -: 6249:
        -: 6250:int
        -: 6251:getopt_long_only (argc, argv, options, long_options, opt_index)
        -: 6252:     int argc;
        -: 6253:     char *const *argv;
        -: 6254:     const char *options;
        -: 6255:     const struct option *long_options;
        -: 6256:     int *opt_index;
        -: 6257:{
        -: 6258:  return _getopt_internal (argc, argv, options, long_options, opt_index, 1);
        -: 6259:}
        -: 6260:
        -: 6261:
        -: 6262:#endif	/* Not ELIDE_CODE.  */
        -: 6263:
        -: 6264:#ifdef TEST
        -: 6265:
        -: 6266:#include <stdio.h>
        -: 6267:
        -: 6268:int
        -: 6269:main (argc, argv)
        -: 6270:     int argc;
        -: 6271:     char **argv;
        -: 6272:{
        -: 6273:  int c;
        -: 6274:  int digit_optind = 0;
        -: 6275:
        -: 6276:  while (1)
        -: 6277:    {
        -: 6278:      int this_option_optind = optind ? optind : 1;
        -: 6279:      int option_index = 0;
        -: 6280:      static struct option long_options[] =
        -: 6281:      {
        -: 6282:	{"add", 1, 0, 0},
        -: 6283:	{"append", 0, 0, 0},
        -: 6284:	{"delete", 1, 0, 0},
        -: 6285:	{"verbose", 0, 0, 0},
        -: 6286:	{"create", 0, 0, 0},
        -: 6287:	{"file", 1, 0, 0},
        -: 6288:	{0, 0, 0, 0}
        -: 6289:      };
        -: 6290:
        -: 6291:      c = getopt_long (argc, argv, "abc:d:0123456789",
        -: 6292:		       long_options, &option_index);
        -: 6293:      if (c == -1)
        -: 6294:	break;
        -: 6295:
        -: 6296:      switch (c)
        -: 6297:	{
        -: 6298:	case 0:
        -: 6299:	  printf ("option %s", long_options[option_index].name);
        -: 6300:	  if (optarg)
        -: 6301:	    printf (" with arg %s", optarg);
        -: 6302:	  printf ("\n");
        -: 6303:	  break;
        -: 6304:
        -: 6305:	case '0':
        -: 6306:	case '1':
        -: 6307:	case '2':
        -: 6308:	case '3':
        -: 6309:	case '4':
        -: 6310:	case '5':
        -: 6311:	case '6':
        -: 6312:	case '7':
        -: 6313:	case '8':
        -: 6314:	case '9':
        -: 6315:	  if (digit_optind != 0 && digit_optind != this_option_optind)
        -: 6316:	    printf ("digits occur in two different argv-elements.\n");
        -: 6317:	  digit_optind = this_option_optind;
        -: 6318:	  printf ("option %c\n", c);
        -: 6319:	  break;
        -: 6320:
        -: 6321:	case 'a':
        -: 6322:	  printf ("option a\n");
        -: 6323:	  break;
        -: 6324:
        -: 6325:	case 'b':
        -: 6326:	  printf ("option b\n");
        -: 6327:	  break;
        -: 6328:
        -: 6329:	case 'c':
        -: 6330:	  printf ("option c with value `%s'\n", optarg);
        -: 6331:	  break;
        -: 6332:
        -: 6333:	case 'd':
        -: 6334:	  printf ("option d with value `%s'\n", optarg);
        -: 6335:	  break;
        -: 6336:
        -: 6337:	case '?':
        -: 6338:	  break;
        -: 6339:
        -: 6340:	default:
        -: 6341:	  printf ("?? getopt returned character code 0%o ??\n", c);
        -: 6342:	}
        -: 6343:    }
        -: 6344:
        -: 6345:  if (optind < argc)
        -: 6346:    {
        -: 6347:      printf ("non-option ARGV-elements: ");
        -: 6348:      while (optind < argc)
        -: 6349:	printf ("%s ", argv[optind++]);
        -: 6350:      printf ("\n");
        -: 6351:    }
        -: 6352:
        -: 6353:  exit (0);
        -: 6354:}
        -: 6355:
        -: 6356:#endif /* TEST */
        -: 6357:
        -: 6358:
        -: 6359:/* Extended regular expression matching and search library.
        -: 6360:   Copyright (C) 2002 Free Software Foundation, Inc.
        -: 6361:   This file is part of the GNU C Library.
        -: 6362:   Contributed by Isamu Hasegawa <isamu@yamato.ibm.com>.
        -: 6363:
        -: 6364:   The GNU C Library is free software; you can redistribute it and/or
        -: 6365:   modify it under the terms of the GNU Lesser General Public
        -: 6366:   License as published by the Free Software Foundation; either
        -: 6367:   version 2.1 of the License, or (at your option) any later version.
        -: 6368:
        -: 6369:   The GNU C Library is distributed in the hope that it will be useful,
        -: 6370:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 6371:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
        -: 6372:   Lesser General Public License for more details.
        -: 6373:
        -: 6374:   You should have received a copy of the GNU Lesser General Public
        -: 6375:   License along with the GNU C Library; if not, write to the Free
        -: 6376:   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
        -: 6377:   02111-1307 USA.  */
        -: 6378:
        -: 6379:#ifdef _LIBC
        -: 6380:/* We have to keep the namespace clean.  */
        -: 6381:#  define regfree(preg) __regfree (preg)
        -: 6382:#  define regexec(pr, st, nm, pm, ef) __regexec (pr, st, nm, pm, ef)
        -: 6383:#  define regcomp(preg, pattern, cflags) __regcomp (preg, pattern, cflags)
        -: 6384:#  define regerror(errcode, preg, errbuf, errbuf_size) \
        -: 6385:	__regerror(errcode, preg, errbuf, errbuf_size)
        -: 6386:#  define re_set_registers(bu, re, nu, st, en) \
        -: 6387:	__re_set_registers (bu, re, nu, st, en)
        -: 6388:#  define re_match_2(bufp, string1, size1, string2, size2, pos, regs, stop) \
        -: 6389:	__re_match_2 (bufp, string1, size1, string2, size2, pos, regs, stop)
        -: 6390:#  define re_match(bufp, string, size, pos, regs) \
        -: 6391:	__re_match (bufp, string, size, pos, regs)
        -: 6392:#  define re_search(bufp, string, size, startpos, range, regs) \
        -: 6393:	__re_search (bufp, string, size, startpos, range, regs)
        -: 6394:#  define re_compile_pattern(pattern, length, bufp) \
        -: 6395:	__re_compile_pattern (pattern, length, bufp)
        -: 6396:#  define re_set_syntax(syntax) __re_set_syntax (syntax)
        -: 6397:#  define re_search_2(bufp, st1, s1, st2, s2, startpos, range, regs, stop) \
        -: 6398:	__re_search_2 (bufp, st1, s1, st2, s2, startpos, range, regs, stop)
        -: 6399:#  define re_compile_fastmap(bufp) __re_compile_fastmap (bufp)
        -: 6400:#endif
        -: 6401:
        -: 6402:/* POSIX says that <sys/types.h> must be included (by the caller) before
        -: 6403:   <regex.h>.  */
        -: 6404:#include <sys/types.h>
        -: 6405:#include <regex.h>
        -: 6406:#include "regex_internal.h"
        -: 6407:
        -: 6408:#include "regex_internal.c"
        -: 6409:#include "regcomp.c"
        -: 6410:#include "regexec.c"
        -: 6411:
        -: 6412:/* Binary backward compatibility.  */
        -: 6413:#if _LIBC
        -: 6414:# include <shlib-compat.h>
        -: 6415:# if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_3)
        -: 6416:link_warning (re_max_failures, "the 're_max_failures' variable is obsolete and will go away.")
        -: 6417:int re_max_failures = 2000;
        -: 6418:# endif
        -: 6419:#endif
        -: 6420:
        -: 6421:
        -: 6422:/*  GNU SED, a batch stream editor.
        -: 6423:    Copyright (C) 1999, 2002, 2003 Free Software Foundation, Inc.
        -: 6424:
        -: 6425:    This program is free software; you can redistribute it and/or modify
        -: 6426:    it under the terms of the GNU General Public License as published by
        -: 6427:    the Free Software Foundation; either version 2, or (at your option)
        -: 6428:    any later version.
        -: 6429:
        -: 6430:    This program is distributed in the hope that it will be useful,
        -: 6431:    but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 6432:    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 6433:    GNU General Public License for more details.
        -: 6434:
        -: 6435:    You should have received a copy of the GNU General Public License
        -: 6436:    along with this program; if not, write to the Free Software
        -: 6437:    Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
        -: 6438:
        -: 6439:#include "config.h"
        -: 6440:
        -: 6441:#include <ctype.h>
        -: 6442:#ifdef HAVE_STDLIB_H
        -: 6443:# include <stdlib.h>
        -: 6444:#endif
        -: 6445:#ifndef NULL
        -: 6446:# include <stdio.h>
        -: 6447:#endif
        -: 6448:
        -: 6449:#ifndef NULL
        -: 6450:# define NULL CAST(VOID *)0
        -: 6451:#endif
        -: 6452:
        -: 6453:extern flagT use_extended_syntax_p;
        -: 6454:
        -: 6455:/* 
        -: 6456:   Changed variable name: errors[] to regex_errors[]
        -: 6457:   to allow *.c file merging for SIR -- July, 2006
        -: 6458:   by Kyle R. Murphy
        -: 6459:*/
        -: 6460:static const char regex_errors[] =
        -: 6461:  "No previous regular expression\0"
        -: 6462:  "Cannot specify modifiers on empty regexp";
        -: 6463:
        -: 6464:#define NO_REGEX (regex_errors)
        -: 6465:#define BAD_MODIF (NO_REGEX + sizeof(N_("No previous regular expression")))
        -: 6466:
        -: 6467:/*
        -: 6468:  Added pre-proc. conditional to allow *.c file
        -: 6469:  merging for SIR -- July, 2006 by Kyle R. Murphy
        -: 6470:*/
        -: 6471:#ifndef END_ERRORS
        -: 6472:#define END_ERRORS (BAD_MODIF + sizeof(N_("Cannot specify modifiers on empty regexp")))
        -: 6473:#endif
        -: 6474:
        -: 6475:
        -: 6476:regex_t *
function compile_regex called 628 returned 100% blocks executed 78%
      628: 6477:compile_regex(b, flags, needed_sub)
        -: 6478:  struct buffer *b;
        -: 6479:  int flags;
        -: 6480:  int needed_sub;
        -: 6481:{
        -: 6482:  regex_t *new_regex;
        -: 6483:
      628: 6484:  char *last_re = NULL;
        -: 6485:  size_t last_re_len;
        -: 6486:
        -: 6487:  /* My reading of IEEE Std 1003.2-1992 is that // means the empty RE.
        -: 6488:     But historical and common practice is that // "matches the last RE";
        -: 6489:     thus this use of POSIXLY_CORRECT. */
      628: 6490:  if (size_buffer(b) == 0 && !POSIXLY_CORRECT)
call    0 returned 628
branch  1 taken 18 (fallthrough)
branch  2 taken 610
branch  3 taken 18 (fallthrough)
branch  4 taken 0
        -: 6491:    {
       18: 6492:      if (flags > 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 18
    #####: 6493:	bad_prog(_(BAD_MODIF));
call    0 never executed
       18: 6494:      return NULL;
        -: 6495:    }
        -: 6496:
      610: 6497:  last_re_len = size_buffer(b);
call    0 returned 610
      610: 6498:  last_re = ck_memdup(get_buffer(b), last_re_len);
call    0 returned 610
call    1 returned 610
        -: 6499:
      610: 6500:  new_regex = MALLOC(1, regex_t);
call    0 returned 610
        -: 6501:
        -: 6502:#ifdef REG_PERL
        -: 6503:  {
        -: 6504:    int errcode;
        -: 6505:    errcode = regncomp(new_regex, last_re, last_re_len,
        -: 6506:		       (needed_sub ? 0 : REG_NOSUB)
        -: 6507:		       | flags
        -: 6508:		       | extended_regexp_flags);
        -: 6509:
        -: 6510:    if (errcode)
        -: 6511:      {
        -: 6512:        char errorbuf[200];
        -: 6513:        regerror(errcode, NULL, errorbuf, 200);
        -: 6514:        bad_prog(gettext(errorbuf));
        -: 6515:      }
        -: 6516:  }
        -: 6517:#else
        -: 6518:  {
        -: 6519:    const char *error;
      610: 6520:    int syntax = ((extended_regexp_flags & REG_EXTENDED)
branch  0 taken 2 (fallthrough)
branch  1 taken 608
        -: 6521:		   ? RE_SYNTAX_POSIX_EXTENDED
        -: 6522:                   : RE_SYNTAX_POSIX_BASIC)
        -: 6523:		   & ~RE_UNMATCHED_RIGHT_PAREN_ORD;
        -: 6524:
      610: 6525:    syntax |= RE_NO_POSIX_BACKTRACKING;
        -: 6526:#ifdef RE_ICASE
      610: 6527:    syntax |= (flags & REG_ICASE) ? RE_ICASE : 0;
        -: 6528:#endif
        -: 6529:
        -: 6530:    /* If REG_NEWLINE is set, newlines are treated differently.  */
      610: 6531:    if (flags & REG_NEWLINE)
branch  0 taken 0 (fallthrough)
branch  1 taken 610
        -: 6532:      { /* REG_NEWLINE implies neither . nor [^...] match newline.  */
    #####: 6533:        syntax &= ~RE_DOT_NEWLINE;
    #####: 6534:        syntax |= RE_HAT_LISTS_NOT_NEWLINE;
        -: 6535:      }
        -: 6536:
        -: 6537:    /* Only PCRE processes \t & co. */
      610: 6538:    last_re_len = normalize_text(last_re, last_re_len);
call    0 returned 610
      610: 6539:    re_set_syntax (syntax);
call    0 returned 610
      610: 6540:    error = re_compile_pattern (last_re, last_re_len, new_regex);
call    0 returned 610
      610: 6541:    new_regex->newline_anchor = (flags & REG_NEWLINE) != 0;
        -: 6542:
      610: 6543:    new_regex->translate = NULL;
        -: 6544:#ifndef RE_ICASE
        -: 6545:    if (flags & REG_ICASE)
        -: 6546:      {
        -: 6547:        static char translate[1 << (sizeof(char) * 8)];
        -: 6548:	int i;
        -: 6549:	for (i = 0; i < sizeof(translate) / sizeof(char); i++)
        -: 6550:	  translate[i] = tolower (i);
        -: 6551:
        -: 6552:        new_regex->translate = translate;
        -: 6553:      }
        -: 6554:#endif
        -: 6555:
      610: 6556:    if (error)
branch  0 taken 0 (fallthrough)
branch  1 taken 610
    #####: 6557:      bad_prog(error);
call    0 never executed
        -: 6558:  }
        -: 6559:#endif
        -: 6560:
      610: 6561:  FREE(last_re);
call    0 returned 610
        -: 6562:
        -: 6563:  /* Just to be sure, I mark this as not POSIXLY_CORRECT behavior */
     610*: 6564:  if (new_regex->re_nsub < needed_sub && !POSIXLY_CORRECT)
branch  0 taken 0 (fallthrough)
branch  1 taken 610
branch  2 never executed
branch  3 never executed
        -: 6565:    {
        -: 6566:      char buf[200];
    #####: 6567:      sprintf(buf, _("Invalid reference \\%d on `s' command's RHS"),
        -: 6568:	      needed_sub);
    #####: 6569:      bad_prog(buf);
call    0 never executed
        -: 6570:    }
        -: 6571:
      610: 6572:  return new_regex;
        -: 6573:}
        -: 6574:
        -: 6575:#ifdef REG_PERL
        -: 6576:static void
        -: 6577:copy_regs (regs, pmatch, nregs)
        -: 6578:     struct re_registers *regs;
        -: 6579:     regmatch_t *pmatch;
        -: 6580:     int nregs;
        -: 6581:{
        -: 6582:  int i;
        -: 6583:  int need_regs = nregs + 1;
        -: 6584:  /* We need one extra element beyond `num_regs' for the `-1' marker GNU code
        -: 6585:     uses.  */
        -: 6586:
        -: 6587:  /* Have the register data arrays been allocated?  */
        -: 6588:  if (!regs->start)
        -: 6589:    { /* No.  So allocate them with malloc.  */
        -: 6590:      regs->start = MALLOC (need_regs, regoff_t);
        -: 6591:      regs->end = MALLOC (need_regs, regoff_t);
        -: 6592:      regs->num_regs = need_regs;
        -: 6593:    }
        -: 6594:  else if (need_regs > regs->num_regs)
        -: 6595:    { /* Yes.  We also need more elements than were already
        -: 6596:         allocated, so reallocate them.  */
        -: 6597:      regs->start = REALLOC (regs->start, need_regs, regoff_t);
        -: 6598:      regs->end = REALLOC (regs->end, need_regs, regoff_t);
        -: 6599:      regs->num_regs = need_regs;
        -: 6600:    }
        -: 6601:
        -: 6602:  /* Copy the regs.  */
        -: 6603:  for (i = 0; i < nregs; ++i)
        -: 6604:    {
        -: 6605:      regs->start[i] = pmatch[i].rm_so;
        -: 6606:      regs->end[i] = pmatch[i].rm_eo;
        -: 6607:    }
        -: 6608:  for ( ; i < regs->num_regs; ++i)
        -: 6609:    regs->start[i] = regs->end[i] = -1;
        -: 6610:}
        -: 6611:#endif
        -: 6612:
        -: 6613:int
function match_regex called 47141 returned 100% blocks executed 90%
    47141: 6614:match_regex(regex, buf, buflen, buf_start_offset, regarray, regsize)
        -: 6615:  regex_t *regex;
        -: 6616:  char *buf;
        -: 6617:  size_t buflen;
        -: 6618:  size_t buf_start_offset;
        -: 6619:  struct re_registers *regarray;
        -: 6620:  int regsize;
        -: 6621:{
        -: 6622:  static regex_t *regex_last;
        -: 6623:#ifdef REG_PERL
        -: 6624:  regmatch_t *regmatch;
        -: 6625:  if (regsize)
        -: 6626:    regmatch = (regmatch_t *) alloca (sizeof (regmatch_t) * regsize);
        -: 6627:  else
        -: 6628:    regmatch = NULL;
        -: 6629:#endif
        -: 6630:
        -: 6631:  int ret;
        -: 6632:
        -: 6633:  /* Keep track of the last regexp matched. */
    47141: 6634:  if (!regex)
branch  0 taken 178 (fallthrough)
branch  1 taken 46963
        -: 6635:    {
      178: 6636:      regex = regex_last;
      178: 6637:      if (!regex_last)
branch  0 taken 0 (fallthrough)
branch  1 taken 178
    #####: 6638:	bad_prog(_(NO_REGEX));
call    0 never executed
        -: 6639:    }
        -: 6640:  else
    46963: 6641:    regex_last = regex;
        -: 6642:
        -: 6643:#ifdef REG_PERL
        -: 6644:  ret = regexec2(regex, 
        -: 6645:		 buf, CAST(int)buflen, CAST(int)buf_start_offset,
        -: 6646:		 regsize, regmatch, 0);
        -: 6647:
        -: 6648:  if (regsize)
        -: 6649:    copy_regs (regarray, regmatch, regsize);
        -: 6650:
        -: 6651:  return (ret == 0);
        -: 6652:#else
    47141: 6653:  ret = re_search(regex, buf, buflen, buf_start_offset,
branch  0 taken 15223 (fallthrough)
branch  1 taken 31918
    47141: 6654:		  buflen - buf_start_offset,
call    0 returned 47141
        -: 6655:		  regsize ? regarray : NULL);
        -: 6656:
    47141: 6657:  return (ret > -1);
        -: 6658:#endif
        -: 6659:}
        -: 6660:
        -: 6661:
        -: 6662:#ifdef DEBUG_LEAKS
        -: 6663:void
        -: 6664:release_regex(regex)
        -: 6665:  regex_t *regex;
        -: 6666:{
        -: 6667:  regfree(regex);
        -: 6668:  FREE(regex);
        -: 6669:}
        -: 6670:#endif /*DEBUG_LEAKS*/
        -: 6671:
