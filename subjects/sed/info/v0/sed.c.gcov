        -:    0:Source:sed.c
        -:    0:Graph:sed.gcno
        -:    0:Data:sed.gcda
        -:    0:Runs:370
        -:    1:#define STDC_HEADERS 1
        -:    2:#define HAVE_STRING_H 1
        -:    3:#define HAVE_VPRINTF 1
        -:    4:#define HAVE_BCOPY 1
        -:    5:#define HAVE_MEMCPY 1
        -:    6:#define HAVE_ALLOCA_H 1
        -:    7:
        -:    8:/*  GNU SED, a batch stream editor.
        -:    9:    Copyright (C) 1989, 1990, 1991 Free Software Foundation, Inc.
        -:   10:
        -:   11:    This program is free software; you can redistribute it and/or modify
        -:   12:    it under the terms of the GNU General Public License as published by
        -:   13:    the Free Software Foundation; either version 2, or (at your option)
        -:   14:    any later version.
        -:   15:
        -:   16:    This program is distributed in the hope that it will be useful,
        -:   17:    but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   18:    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   19:    GNU General Public License for more details.
        -:   20:
        -:   21:    You should have received a copy of the GNU General Public License
        -:   22:    along with this program; if not, write to the Free Software
        -:   23:    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
        -:   24:    
        -:   25:/* The occurence of argv[0] is cahnged to myname to remove nondeterminism by 
        -:   26:Amit Goel on 30th August , 2001 */
        -:   27:
        -:   28:#ifdef __STDC__
        -:   29:#define VOID void
        -:   30:#else
        -:   31:#define VOID char
        -:   32:#endif
        -:   33:
        -:   34:
        -:   35:#define _GNU_SOURCE
        -:   36:#include <ctype.h>
        -:   37:#ifndef isblank
        -:   38:#define isblank(c) ((c) == ' ' || (c) == '\t')
        -:   39:#endif
        -:   40:#include <stdio.h>
        -:   41:
        -:   42:#undef stderr
        -:   43:#define stderr stdout
        -:   44:
        -:   45:#include <sys/types.h>
        -:   46:#include "regex.h"
        -:   47:#include "getopt.h"
        -:   48:#if defined(STDC_HEADERS)
        -:   49:#include <stdlib.h>
        -:   50:#endif
        -:   51:#if HAVE_STRING_H || defined(STDC_HEADERS)
        -:   52:#include <string.h>
        -:   53:#if !defined(STDC_HEADERS)
        -:   54:#include <memory.h>
        -:   55:#endif
        -:   56:#else
        -:   57:#include <strings.h>
        -:   58:#endif
        -:   59:
        -:   60:#include <errno.h>
        -:   61:
        -:   62:#ifndef HAVE_BCOPY
        -:   63:#ifdef HAVE_MEMCPY
        -:   64:#define bcopy(FROM,TO,LEN)  memcpy(TO,FROM,LEN)
        -:   65:#else
        -:   66:void
        -:   67:bcopy (from, to, len)
        -:   68:     char *from;
        -:   69:     char *to;
        -:   70:     int len;
        -:   71:{
        -:   72:  if (from < to)
        -:   73:    {
        -:   74:      from += len - 1;
        -:   75:      to += len - 1;
        -:   76:      while (len--)
        -:   77:    *to-- = *from--;
        -:   78:    }
        -:   79:  else
        -:   80:    while (len--)
        -:   81:      *to++ = *from++;
        -:   82:}
        -:   83:
        -:   84:#endif
        -:   85:#endif
        -:   86:
        -:   87:char *version_string = "GNU sed version 1.17";
        -:   88:
        -:   89:/* Struct vector is used to describe a chunk of a compiled sed program.  
        -:   90: * There is one vector for the main program, and one for each { } pair,
        -:   91: * and one for the entire program.  For {} blocks, RETURN_[VI] tells where
        -:   92: * to continue execution after this VECTOR.
        -:   93: */
        -:   94:
        -:   95:struct vector
        -:   96:{
        -:   97:  struct sed_cmd *v;
        -:   98:  int v_length;
        -:   99:  int v_allocated;
        -:  100:  struct vector *return_v;
        -:  101:  int return_i;
        -:  102:};
        -:  103:
        -:  104:
        -:  105:/* Goto structure is used to hold both GOTO's and labels.  There are two
        -:  106: * separate lists, one of goto's, called 'jumps', and one of labels, called
        -:  107: * 'labels'.
        -:  108: * the V element points to the descriptor for the program-chunk in which the
        -:  109: * goto was encountered.
        -:  110: * the v_index element counts which element of the vector actually IS the
        -:  111: * goto/label.  The first element of the vector is zero.
        -:  112: * the NAME element is the null-terminated name of the label.
        -:  113: * next is the next goto/label in the list. 
        -:  114: */
        -:  115:
        -:  116:struct sed_label
        -:  117:{
        -:  118:  struct vector *v;
        -:  119:  int v_index;
        -:  120:  char *name;
        -:  121:  struct sed_label *next;
        -:  122:};
        -:  123:
        -:  124:/* ADDR_TYPE is zero for a null address,
        -:  125: *  one if addr_number is valid, or
        -:  126: * two if addr_regex is valid,
        -:  127: * three, if the address is '$'
        -:  128: * Other values are undefined.
        -:  129: */
        -:  130:
        -:  131:enum addr_types
        -:  132:{
        -:  133:  addr_is_null = 0,
        -:  134:  addr_is_num = 1,
        -:  135:  addr_is_regex = 2,
        -:  136:  addr_is_last = 3
        -:  137:};
        -:  138:
        -:  139:struct addr
        -:  140:{
        -:  141:  int addr_type;
        -:  142:  struct re_pattern_buffer *addr_regex;
        -:  143:  int addr_number;
        -:  144:};
        -:  145:
        -:  146:
        -:  147:/* Aflags:  If the low order bit is set, a1 has been
        -:  148: * matched; apply this command until a2 matches.
        -:  149: * If the next bit is set, apply this command to all
        -:  150: * lines that DON'T match the address(es).
        -:  151: */
        -:  152:
        -:  153:#define A1_MATCHED_BIT  01
        -:  154:#define ADDR_BANG_BIT   02
        -:  155:
        -:  156:struct sed_cmd
        -:  157:{
        -:  158:  struct addr a1, a2;
        -:  159:  int aflags;
        -:  160:  
        -:  161:  char cmd;
        -:  162:  
        -:  163:  union
        -:  164:    {
        -:  165:      /* This structure is used for a, i, and c commands */
        -:  166:      struct
        -:  167:    {
        -:  168:      char *text;
        -:  169:      int text_len;
        -:  170:    }
        -:  171:      cmd_txt;
        -:  172:      
        -:  173:      /* This is used for b and t commands */
        -:  174:      struct sed_cmd *label;
        -:  175:      
        -:  176:      /* This for r and w commands */
        -:  177:      FILE *io_file;
        -:  178:      
        -:  179:      /* This for the hairy s command */
        -:  180:      /* For the flags var:
        -:  181:     low order bit means the 'g' option was given,
        -:  182:     next bit means the 'p' option was given,
        -:  183:     and the next bit means a 'w' option was given,
        -:  184:     and wio_file contains the file to write to. */
        -:  185:      
        -:  186:#define S_GLOBAL_BIT    01
        -:  187:#define S_PRINT_BIT 02
        -:  188:#define S_WRITE_BIT 04
        -:  189:#define S_NUM_BIT   010
        -:  190:      
        -:  191:      struct
        -:  192:    {
        -:  193:      struct re_pattern_buffer *regx;
        -:  194:      char *replacement;
        -:  195:      int replace_length;
        -:  196:      int flags;
        -:  197:      int numb;
        -:  198:      FILE *wio_file;
        -:  199:    }
        -:  200:      cmd_regex;
        -:  201:      
        -:  202:      /* This for the y command */
        -:  203:      unsigned char *translate;
        -:  204:      
        -:  205:      /* For { */
        -:  206:      struct vector *sub;
        -:  207:      
        -:  208:      /* for t and b */
        -:  209:      struct sed_label *jump;
        -:  210:    } x;
        -:  211:};
        -:  212:
        -:  213:/* Sed operates a line at a time. */
        -:  214:struct line
        -:  215:{
        -:  216:  char *text;           /* Pointer to line allocated by malloc. */
        -:  217:  int length;           /* Length of text. */
        -:  218:  int alloc;            /* Allocated space for text. */
        -:  219:};
        -:  220:
        -:  221:/* This structure holds information about files opend by the 'r', 'w',
        -:  222:   and 's///w' commands.  In paticular, it holds the FILE pointer to
        -:  223:   use, the file's name, a flag that is non-zero if the file is being
        -:  224:   read instead of written. */
        -:  225:
        -:  226:#define NUM_FPS 32
        -:  227:struct
        -:  228:  {
        -:  229:    FILE *phile;
        -:  230:    char *name;
        -:  231:    int readit;
        -:  232:  }
        -:  233:
        -:  234:file_ptrs[NUM_FPS];
        -:  235:
        -:  236:
        -:  237:#if defined(__STDC__)
        -:  238:# define P_(s) s
        -:  239:#else
        -:  240:# define P_(s) ()
        -:  241:#endif
        -:  242:
        -:  243:void close_files ();
        -:  244:void panic P_ ((char *str,...));
        -:  245:char *__fp_name P_ ((FILE * fp));
        -:  246:FILE *ck_fopen P_ ((char *name, char *mode));
        -:  247:void ck_fwrite P_ ((char *ptr, int size, int nmemb, FILE * stream));
        -:  248:void ck_fclose P_ ((FILE * stream));
        -:  249:VOID *ck_malloc P_ ((int size));
        -:  250:VOID *ck_realloc P_ ((VOID * ptr, int size));
        -:  251:char *ck_strdup P_ ((char *str));
        -:  252:VOID *init_buffer P_ ((void));
        -:  253:void flush_buffer P_ ((VOID * bb));
        -:  254:int size_buffer P_ ((VOID * b));
        -:  255:void add_buffer P_ ((VOID * bb, char *p, int n));
        -:  256:void add1_buffer P_ ((VOID * bb, int ch));
        -:  257:char *get_buffer P_ ((VOID * bb));
        -:  258:
        -:  259:void compile_string P_ ((char *str));
        -:  260:void compile_file P_ ((char *str));
        -:  261:struct vector *compile_program P_ ((struct vector * vector, int));
        -:  262:void bad_prog P_ ((char *why));
        -:  263:int inchar P_ ((void));
        -:  264:void savchar P_ ((int ch));
        -:  265:int compile_address P_ ((struct addr * addr));
        -:  266:void compile_regex P_ ((int slash));
        -:  267:struct sed_label *setup_jump P_ ((struct sed_label * list, struct sed_cmd * cmd, struct vector * vec));
        -:  268:FILE *compile_filename P_ ((int readit));
        -:  269:void read_file P_ ((char *name));
        -:  270:void execute_program P_ ((struct vector * vec));
        -:  271:int match_address P_ ((struct addr * addr));
        -:  272:int read_pattern_space P_ ((void));
        -:  273:void append_pattern_space P_ ((void));
        -:  274:void line_copy P_ ((struct line * from, struct line * to));
        -:  275:void line_append P_ ((struct line * from, struct line * to));
        -:  276:void str_append P_ ((struct line * to, char *string, int length));
        -:  277:void usage P_ ((int));
        -:  278:extern char *myname;
        -:  279:
        -:  280:/* If set, don't write out the line unless explictly told to */
        -:  281:int no_default_output = 0;
        -:  282:
        -:  283:/* Current input line # */
        -:  284:int input_line_number = 0;
        -:  285:
        -:  286:/* Are we on the last input file? */
        -:  287:int last_input_file = 0;
        -:  288:
        -:  289:/* Have we hit EOF on the last input file?  This is used to decide if we
        -:  290:   have hit the '$' address yet. */
        -:  291:int input_EOF = 0;
        -:  292:
        -:  293:/* non-zero if a quit command has been executed. */
        -:  294:int quit_cmd = 0;
        -:  295:
        -:  296:/* Have we done any replacements lately?  This is used by the 't' command. */
        -:  297:int replaced = 0;
        -:  298:
        -:  299:/* How many '{'s are we executing at the moment */
        -:  300:int program_depth = 0;
        -:  301:
        -:  302:/* The complete compiled SED program that we are going to run */
        -:  303:struct vector *the_program = 0;
        -:  304:
        -:  305:/* information about labels and jumps-to-labels.  This is used to do
        -:  306:   the required backpatching after we have compiled all the scripts. */
        -:  307:struct sed_label *jumps = 0;
        -:  308:struct sed_label *labels = 0;
        -:  309:
        -:  310:/* The 'current' input line. */
        -:  311:struct line line;
        -:  312:
        -:  313:/* An input line that's been stored by later use by the program */
        -:  314:struct line hold;
        -:  315:
        -:  316:/* A 'line' to append to the current line when it comes time to write it out */
        -:  317:struct line append;
        -:  318:
        -:  319:
        -:  320:/* When we're reading a script command from a string, 'prog_start' and
        -:  321:   'prog_end' point to the beginning and end of the string.  This
        -:  322:   would allow us to compile script strings that contain nulls, except
        -:  323:   that script strings are only read from the command line, which is
        -:  324:   null-terminated */
        -:  325:unsigned char *prog_start;
        -:  326:unsigned char *prog_end;
        -:  327:
        -:  328:/* When we're reading a script command from a string, 'prog_cur' points
        -:  329:   to the current character in the string */
        -:  330:unsigned char *prog_cur;
        -:  331:
        -:  332:/* This is the name of the current script file.
        -:  333:   It is used for error messages. */
        -:  334:char *prog_name;
        -:  335:
        -:  336:/* This is the current script file.  If it is zero, we are reading
        -:  337:   from a string stored in 'prog_start' instead.  If both 'prog_file'
        -:  338:   and 'prog_start' are zero, we're in trouble! */
        -:  339:FILE *prog_file;
        -:  340:
        -:  341:/* this is the number of the current script line that we're compiling.  It is
        -:  342:   used to give out useful and informative error messages. */
        -:  343:int prog_line = 1;
        -:  344:
        -:  345:/* This is the file pointer that we're currently reading data from.  It may
        -:  346:   be stdin */
        -:  347:FILE *input_file;
        -:  348:
        -:  349:/* If this variable is non-zero at exit, one or more of the input
        -:  350:   files couldn't be opened. */
        -:  351:
        -:  352:int bad_input = 0;
        -:  353:
        -:  354:/* 'an empty regular expression is equivalent to the last regular
        -:  355:   expression read' so we have to keep track of the last regex used.
        -:  356:   Here's where we store a pointer to it (it is only malloc()'d once) */
        -:  357:struct re_pattern_buffer *last_regex;
        -:  358:
        -:  359:/* Various error messages we may want to print */
        -:  360:static char ONE_ADDR[] = "Command only uses one address";
        -:  361:static char NO_ADDR[] = "Command doesn't take any addresses";
        -:  362:static char LINE_JUNK[] = "Extra characters after command";
        -:  363:static char BAD_EOF[] = "Unexpected End-of-file";
        -:  364:static char NO_REGEX[] = "No previous regular expression";
        -:  365:static char NO_COMMAND[] = "Missing command";
        -:  366:
        -:  367:static struct option longopts[] =
        -:  368:{
        -:  369:  {"expression", 1, NULL, 'e'},
        -:  370:  {"file", 1, NULL, 'f'},
        -:  371:  {"quiet", 0, NULL, 'n'},
        -:  372:  {"silent", 0, NULL, 'n'},
        -:  373:  {"version", 0, NULL, 'V'},
        -:  374:  {"help", 0, NULL, 'h'},
        -:  375:  {NULL, 0, NULL, 0}
        -:  376:};
        -:  377:
        -:  378:int
function main called 370 returned 0% blocks executed 91%
      370:  379:main (argc, argv)
        -:  380:     int argc;
        -:  381:     char **argv;
        -:  382:{
        -:  383:  int opt;
      370:  384:  char *e_strings = NULL;
      370:  385:  int compiled = 0;
        -:  386:  struct sed_label *go, *lbl;
        -:  387:
        -:  388:  /* see regex.h */
      370:  389:  re_set_syntax (RE_SYNTAX_POSIX_BASIC);
call    0 returned 370
        -:  390:
        -:  391: /* Commented By Amit Goel  on 30th August 2001to remove differences 
        -:  392: between instrumented and non instrumented versions output */
        -:  393: /* myname = argv[0]; */
      370:  394: myname = "Executable"; /* Added by Amit Goel on 30th August 2001 */
      733:  395:  while ((opt = getopt_long (argc, argv, "hne:f:V", longopts, (int *) 0))
call    0 returned 733
      733:  396:     != EOF)
branch  0 taken 375
branch  1 taken 358 (fallthrough)
        -:  397:    {
      375:  398:      switch (opt)
branch  0 taken 7
branch  1 taken 20
branch  2 taken 339
branch  3 taken 2
branch  4 taken 0
branch  5 taken 7
        -:  399:    {
        7:  400:    case 'n':
        7:  401:      no_default_output = 1;
        7:  402:      break;
       20:  403:    case 'e':
       20:  404:      if (e_strings == NULL)
branch  0 taken 19 (fallthrough)
branch  1 taken 1
        -:  405:        {
       19:  406:          e_strings = ck_malloc (strlen (optarg) + 2);
call    0 returned 19
       19:  407:          strcpy (e_strings, optarg);
        -:  408:        }
        -:  409:      else
        -:  410:        {
        1:  411:          e_strings = ck_realloc (e_strings, strlen (e_strings) + strlen (optarg) + 2);
call    0 returned 1
        1:  412:          strcat (e_strings, optarg);
        -:  413:        }
       20:  414:      strcat (e_strings, "\n");
       20:  415:      compiled = 1;
       20:  416:      break;
      339:  417:    case 'f':
      339:  418:      compile_file (optarg);
call    0 returned 336
      336:  419:      compiled = 1;
      336:  420:      break;
        2:  421:    case 'V':
        2:  422:      fprintf (stderr, "%s\n", version_string);
call    0 returned 2
        2:  423:      exit (0);
call    0 returned 0
        -:  424:      break;
    #####:  425:    case 'h':
    #####:  426:      usage (0);
call    0 never executed
    #####:  427:      break;
        7:  428:    default:
        7:  429:      usage (4);
call    0 returned 0
    #####:  430:      break;
        -:  431:    }
        -:  432:    }
      358:  433:  if (e_strings)
branch  0 taken 19 (fallthrough)
branch  1 taken 339
        -:  434:    {
       19:  435:      compile_string (e_strings);
call    0 returned 19
       19:  436:      free (e_strings);
        -:  437:    }
      358:  438:  if (!compiled)
branch  0 taken 5 (fallthrough)
branch  1 taken 353
        -:  439:    {
        5:  440:      if (optind == argc)
branch  0 taken 0 (fallthrough)
branch  1 taken 5
    #####:  441:    usage (4);
call    0 never executed
        5:  442:      compile_string (argv[optind++]);
call    0 returned 0
        -:  443:    }
        -:  444:
      362:  445:  for (go = jumps; go; go = go->next)
branch  0 taken 9
branch  1 taken 353 (fallthrough)
        -:  446:    {
       11:  447:      for (lbl = labels; lbl; lbl = lbl->next)
branch  0 taken 7
branch  1 taken 4 (fallthrough)
        7:  448:    if (!strcmp (lbl->name, go->name))
branch  0 taken 5 (fallthrough)
branch  1 taken 2
        5:  449:      break;
        9:  450:      if (*go->name && !lbl)
branch  0 taken 5 (fallthrough)
branch  1 taken 4
branch  2 taken 0 (fallthrough)
branch  3 taken 5
    #####:  451:    panic ("Can't find label for jump to '%s'", go->name);
call    0 never executed
        9:  452:      go->v->v[go->v_index].x.jump = lbl;
        -:  453:    }
        -:  454:
      353:  455:  line.length = 0;
      353:  456:  line.alloc = 50;
      353:  457:  line.text = ck_malloc (50);
call    0 returned 353
        -:  458:
      353:  459:  append.length = 0;
      353:  460:  append.alloc = 50;
      353:  461:  append.text = ck_malloc (50);
call    0 returned 353
        -:  462:
      353:  463:  hold.length = 1;
      353:  464:  hold.alloc = 50;
      353:  465:  hold.text = ck_malloc (50);
call    0 returned 353
      353:  466:  hold.text[0] = '\n';
        -:  467:
      353:  468:  if (argc <= optind)
branch  0 taken 1 (fallthrough)
branch  1 taken 352
        -:  469:    {
        1:  470:      last_input_file++;
        1:  471:      read_file ("-");
call    0 returned 1
        -:  472:    }
        -:  473:  else
      658:  474:    while (optind < argc)
branch  0 taken 353
branch  1 taken 305 (fallthrough)
        -:  475:      {
      353:  476:    if (optind == argc - 1)
branch  0 taken 352 (fallthrough)
branch  1 taken 1
      352:  477:      last_input_file++;
      353:  478:    read_file (argv[optind]);
call    0 returned 353
      353:  479:    optind++;
      353:  480:    if (quit_cmd)
branch  0 taken 47 (fallthrough)
branch  1 taken 306
       47:  481:      break;
        -:  482:      }
      353:  483:  close_files ();
call    0 returned 353
      353:  484:  if (bad_input)
branch  0 taken 1 (fallthrough)
branch  1 taken 352
        1:  485:    exit (2);
call    0 returned 0
      352:  486:  exit (0);
        -:  487:}
        -:  488:
        -:  489:void
function close_files called 353 returned 100% blocks executed 100%
      353:  490:close_files ()
        -:  491:{
        -:  492:  int nf;
        -:  493:
    11649:  494:  for (nf = 0; nf < NUM_FPS; nf++)
branch  0 taken 11296
branch  1 taken 353 (fallthrough)
        -:  495:    {
    11296:  496:      if (file_ptrs[nf].phile)
branch  0 taken 230 (fallthrough)
branch  1 taken 11066
      230:  497:    fclose (file_ptrs[nf].phile);
call    0 returned 230
        -:  498:    }
      353:  499:}
        -:  500:
        -:  501:/* 'str' is a string (from the command line) that contains a sed command.
        -:  502:   Compile the command, and add it to the end of 'the_program' */
        -:  503:void
function compile_string called 24 returned 79% blocks executed 100%
       24:  504:compile_string (str)
        -:  505:     char *str;
        -:  506:{
       24:  507:  prog_file = 0;
       24:  508:  prog_line = 0;
       24:  509:  prog_start = prog_cur = (unsigned char *)str;
       24:  510:  prog_end = (unsigned char *)str + strlen (str);
       24:  511:  the_program = compile_program (the_program, prog_line);
call    0 returned 19
       19:  512:}
        -:  513:
        -:  514:/* 'str' is the name of a file containing sed commands.  Read them in
        -:  515:   and add them to the end of 'the_program' */
        -:  516:void
function compile_file called 339 returned 99% blocks executed 89%
      339:  517:compile_file (str)
        -:  518:     char *str;
        -:  519:{
        -:  520:  int ch;
        -:  521:
      339:  522:  prog_start = prog_cur = prog_end = 0;
      339:  523:  prog_name = str;
      339:  524:  prog_line = 1;
     339*:  525:  if (str[0] == '-' && str[1] == '\0')
branch  0 taken 0 (fallthrough)
branch  1 taken 339
branch  2 never executed
branch  3 never executed
    #####:  526:    prog_file = stdin;
        -:  527:  else
      339:  528:    prog_file = ck_fopen (str, "r");
call    0 returned 337
      337:  529:  ch = getc (prog_file);
call    0 returned 337
      337:  530:  if (ch == '#')
branch  0 taken 326 (fallthrough)
branch  1 taken 11
        -:  531:    {
      326:  532:      ch = getc (prog_file);
call    0 returned 326
      326:  533:      if (ch == 'n')
branch  0 taken 211 (fallthrough)
branch  1 taken 115
      211:  534:    no_default_output++;
     2453:  535:      while (ch != EOF && ch != '\n')
branch  0 taken 2453 (fallthrough)
branch  1 taken 0
branch  2 taken 2127
branch  3 taken 326 (fallthrough)
     2127:  536:    ch = getc (prog_file);
call    0 returned 2127
      326:  537:      ++prog_line;
        -:  538:    }
       11:  539:  else if (ch != EOF)
branch  0 taken 11 (fallthrough)
branch  1 taken 0
       11:  540:    ungetc (ch, prog_file);
call    0 returned 11
      337:  541:  the_program = compile_program (the_program, prog_line);
call    0 returned 336
      336:  542:}
        -:  543:
        -:  544:#define MORE_CMDS 40
        -:  545:
        -:  546:/* Read a program (or a subprogram within '{' '}' pairs) in and store
        -:  547:   the compiled form in *'vector'  Return a pointer to the new vector.  */
        -:  548:struct vector *
function compile_program called 691 returned 99% blocks executed 79%
      691:  549:compile_program (vector, open_line)
        -:  550:     struct vector *vector;
        -:  551:     int open_line;
        -:  552:{
        -:  553:  struct sed_cmd *cur_cmd;
        -:  554:  int ch, pch;
        -:  555:  int slash;
        -:  556:  VOID *b;
        -:  557:  unsigned char *string;
        -:  558:  int num;
        -:  559:
      691:  560:  if (!vector)
branch  0 taken 2 (fallthrough)
branch  1 taken 689
        -:  561:    {
      689:  562:      vector = (struct vector *) ck_malloc (sizeof (struct vector));
call    0 returned 689
      689:  563:      vector->v = (struct sed_cmd *) ck_malloc (MORE_CMDS * sizeof (struct sed_cmd));
call    0 returned 689
      689:  564:      vector->v_allocated = MORE_CMDS;
      689:  565:      vector->v_length = 0;
      689:  566:      vector->return_v = 0;
      689:  567:      vector->return_i = 0;
        -:  568:    }
        -:  569:  for (;;)
        -:  570:    {
      691:  571:    skip_comment:
        -:  572:      do
        -:  573:    {
    10265:  574:      pch = ch;
    10265:  575:      ch = inchar ();
call    0 returned 10265
   10265*:  576:      if ((pch == '\\') && (ch == '\n'))
branch  0 taken 0 (fallthrough)
branch  1 taken 10265
branch  2 never executed
branch  3 never executed
    #####:  577:        ch = inchar ();
call    0 never executed
        -:  578:    }
    10265:  579:      while (ch != EOF && (isblank (ch) || ch == '\n' || ch == ';'));
branch  0 taken 9909 (fallthrough)
branch  1 taken 356
branch  2 taken 6599
branch  3 taken 3310 (fallthrough)
branch  4 taken 1106
branch  5 taken 2204 (fallthrough)
branch  6 taken 0
branch  7 taken 2204 (fallthrough)
     2560:  580:      if (ch == EOF)
branch  0 taken 356 (fallthrough)
branch  1 taken 2204
      356:  581:    break;
     2204:  582:      savchar (ch);
call    0 returned 2204
        -:  583:
     2204:  584:      if (vector->v_length == vector->v_allocated)
branch  0 taken 0 (fallthrough)
branch  1 taken 2204
        -:  585:    {
    #####:  586:      vector->v = ((struct sed_cmd *)
    #####:  587:               ck_realloc ((VOID *) vector->v,
    #####:  588:                   ((vector->v_length + MORE_CMDS)
call    0 never executed
        -:  589:                    * sizeof (struct sed_cmd))));
    #####:  590:      vector->v_allocated += MORE_CMDS;
        -:  591:    }
     2204:  592:      cur_cmd = vector->v + vector->v_length;
     2204:  593:      vector->v_length++;
        -:  594:
     2204:  595:      cur_cmd->a1.addr_type = 0;
     2204:  596:      cur_cmd->a2.addr_type = 0;
     2204:  597:      cur_cmd->aflags = 0;
     2204:  598:      cur_cmd->cmd = 0;
        -:  599:
     2204:  600:      if (compile_address (&(cur_cmd->a1)))
call    0 returned 2204
branch  1 taken 439 (fallthrough)
branch  2 taken 1765
        -:  601:    {
      439:  602:      ch = inchar ();
call    0 returned 439
      439:  603:      if (ch == ',')
branch  0 taken 45 (fallthrough)
branch  1 taken 394
        -:  604:        {
        -:  605:          do
       45:  606:        ch = inchar ();
call    0 returned 45
       45:  607:          while (ch != EOF && isblank (ch));
branch  0 taken 45 (fallthrough)
branch  1 taken 0
branch  2 taken 0
branch  3 taken 45 (fallthrough)
       45:  608:          savchar (ch);
call    0 returned 45
       45:  609:          if (compile_address (&(cur_cmd->a2)))
call    0 returned 45
branch  1 taken 0 (fallthrough)
branch  2 taken 45
        -:  610:        ;
        -:  611:          else
    #####:  612:        bad_prog ("Unexpected ','");
call    0 never executed
        -:  613:        }
        -:  614:      else
      394:  615:        savchar (ch);
call    0 returned 394
        -:  616:    }
     2204:  617:      if (cur_cmd->a1.addr_type == addr_is_num
branch  0 taken 67 (fallthrough)
branch  1 taken 2137
       67:  618:      && cur_cmd->a2.addr_type == addr_is_num
branch  0 taken 18 (fallthrough)
branch  1 taken 49
       18:  619:      && cur_cmd->a2.addr_number < cur_cmd->a1.addr_number)
branch  0 taken 0 (fallthrough)
branch  1 taken 18
    #####:  620:    cur_cmd->a2.addr_number = cur_cmd->a1.addr_number;
        -:  621:
     2204:  622:      ch = inchar ();
call    0 returned 2204
     2204:  623:      if (ch == EOF)
branch  0 taken 2204 (fallthrough)
branch  1 taken 0
    #####:  624:    bad_prog (NO_COMMAND);
call    0 never executed
     2204:  625:    new_cmd:
     2224:  626:      switch (ch)
branch  0 taken 181
branch  1 taken 20
branch  2 taken 70
branch  3 taken 36
branch  4 taken 330
branch  5 taken 329
branch  6 taken 4
branch  7 taken 9
branch  8 taken 37
branch  9 taken 847
branch 10 taken 34
branch 11 taken 45
branch 12 taken 238
branch 13 taken 39
branch 14 taken 5
        -:  627:    {
      181:  628:    case '#':
      181:  629:      if (cur_cmd->a1.addr_type != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 181
    #####:  630:        bad_prog (NO_ADDR);
call    0 never executed
        -:  631:      do
     3825:  632:        ch = inchar ();
call    0 returned 3825
     3825:  633:      while (ch != EOF && ch != '\n');
branch  0 taken 3825 (fallthrough)
branch  1 taken 0
branch  2 taken 3644
branch  3 taken 181 (fallthrough)
      181:  634:      vector->v_length--;
      181:  635:      goto skip_comment;
       20:  636:    case '!':
       20:  637:      if (cur_cmd->aflags & ADDR_BANG_BIT)
branch  0 taken 0 (fallthrough)
branch  1 taken 20
    #####:  638:        bad_prog ("Multiple '!'s");
call    0 never executed
       20:  639:      cur_cmd->aflags |= ADDR_BANG_BIT;
        -:  640:      do
       20:  641:        ch = inchar ();
call    0 returned 20
       20:  642:      while (ch != EOF && isblank (ch));
branch  0 taken 20 (fallthrough)
branch  1 taken 0
branch  2 taken 0
branch  3 taken 20 (fallthrough)
       20:  643:      if (ch == EOF)
branch  0 taken 0 (fallthrough)
branch  1 taken 20
    #####:  644:        bad_prog (NO_COMMAND);
call    0 never executed
        -:  645:#if 0
        -:  646:      savchar (ch);
        -:  647:#endif
       20:  648:      goto new_cmd;
       70:  649:    case 'a':
        -:  650:    case 'i':
       70:  651:      if (cur_cmd->a2.addr_type != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 70
    #####:  652:        bad_prog (ONE_ADDR);
call    0 never executed
        -:  653:      /* Fall Through */
        -:  654:    case 'c':
      106:  655:      cur_cmd->cmd = ch;
      106:  656:      if (inchar () != '\\' || inchar () != '\n')
call    0 returned 106
branch  1 taken 106 (fallthrough)
branch  2 taken 0
call    3 returned 106
branch  4 taken 0 (fallthrough)
branch  5 taken 106
    #####:  657:        bad_prog (LINE_JUNK);
call    0 never executed
      106:  658:      b = init_buffer ();
call    0 returned 106
     2629:  659:      while ((ch = inchar ()) != EOF && ch != '\n')
call    0 returned 2629
branch  1 taken 2629 (fallthrough)
branch  2 taken 0
branch  3 taken 2523
branch  4 taken 106 (fallthrough)
        -:  660:        {
     2523:  661:          if (ch == '\\')
branch  0 taken 14 (fallthrough)
branch  1 taken 2509
       14:  662:        ch = inchar ();
call    0 returned 14
     2523:  663:          add1_buffer (b, ch);
call    0 returned 2523
        -:  664:        }
      106:  665:      if (ch != EOF)
branch  0 taken 106 (fallthrough)
branch  1 taken 0
      106:  666:        add1_buffer (b, ch);
call    0 returned 106
      106:  667:      num = size_buffer (b);
call    0 returned 106
      106:  668:      string = (unsigned char *) ck_malloc (num);
call    0 returned 106
      106:  669:      bcopy (get_buffer (b), string, num);
call    0 returned 106
      106:  670:      flush_buffer (b);
call    0 returned 106
      106:  671:      cur_cmd->x.cmd_txt.text_len = num;
      106:  672:      cur_cmd->x.cmd_txt.text = (char *) string;
      106:  673:      break;
      330:  674:    case '{':
      330:  675:      cur_cmd->cmd = ch;
      330:  676:      program_depth++;
        -:  677:#if 0
        -:  678:      while ((ch = inchar ()) != EOF && ch != '\n')
        -:  679:        if (!isblank (ch))
        -:  680:          bad_prog (LINE_JUNK);
        -:  681:#endif
      330:  682:      cur_cmd->x.sub = compile_program ((struct vector *) 0, prog_line);
call    0 returned 329
        -:  683:      /* FOO JF is this the right thing to do?
        -:  684:               almost.  don't forget a return addr.  -t */
      329:  685:      cur_cmd->x.sub->return_v = vector;
      329:  686:      cur_cmd->x.sub->return_i = vector->v_length - 1;
      329:  687:      break;
      329:  688:    case '}':
      329:  689:      if (!program_depth)
branch  0 taken 0 (fallthrough)
branch  1 taken 329
    #####:  690:        bad_prog ("Unexpected '}'");
call    0 never executed
      329:  691:      --program_depth;
        -:  692:      /* a return insn for subprograms -t */
      329:  693:      cur_cmd->cmd = ch;
      329:  694:      if (cur_cmd->a1.addr_type != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 329
    #####:  695:        bad_prog ("} doesn't want any addresses");
call    0 never executed
      335:  696:      while ((ch = inchar ()) != EOF && ch != '\n' && ch != ';')
call    0 returned 335
branch  1 taken 335 (fallthrough)
branch  2 taken 0
branch  3 taken 6 (fallthrough)
branch  4 taken 329
branch  5 taken 6
branch  6 taken 0 (fallthrough)
        6:  697:        if (!isblank (ch))
branch  0 taken 0 (fallthrough)
branch  1 taken 6
    #####:  698:          bad_prog (LINE_JUNK);
call    0 never executed
      329:  699:      return vector;
        4:  700:    case ':':
        4:  701:      cur_cmd->cmd = ch;
        4:  702:      if (cur_cmd->a1.addr_type != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 4
    #####:  703:        bad_prog (": doesn't want any addresses");
call    0 never executed
        4:  704:      labels = setup_jump (labels, cur_cmd, vector);
call    0 returned 4
        4:  705:      break;
        9:  706:    case 'b':
        -:  707:    case 't':
        9:  708:      cur_cmd->cmd = ch;
        9:  709:      jumps = setup_jump (jumps, cur_cmd, vector);
call    0 returned 9
        9:  710:      break;
       37:  711:    case 'q':
        -:  712:    case '=':
       37:  713:      if (cur_cmd->a2.addr_type)
branch  0 taken 0 (fallthrough)
branch  1 taken 37
    #####:  714:        bad_prog (ONE_ADDR);
call    0 never executed
        -:  715:      /* Fall Through */
        -:  716:    case 'd':
        -:  717:    case 'D':
        -:  718:    case 'g':
        -:  719:    case 'G':
        -:  720:    case 'h':
        -:  721:    case 'H':
        -:  722:    case 'l':
        -:  723:    case 'n':
        -:  724:    case 'N':
        -:  725:    case 'p':
        -:  726:    case 'P':
        -:  727:    case 'x':
      884:  728:      cur_cmd->cmd = ch;
        -:  729:      do
      897:  730:        ch = inchar ();
call    0 returned 897
      897:  731:      while (ch != EOF && isblank (ch) && ch != '\n' && ch != ';');
branch  0 taken 897 (fallthrough)
branch  1 taken 0
branch  2 taken 13 (fallthrough)
branch  3 taken 884
branch  4 taken 13 (fallthrough)
branch  5 taken 0
branch  6 taken 13
branch  7 taken 0 (fallthrough)
     884*:  732:      if (ch != '\n' && ch != ';' && ch != EOF)
branch  0 taken 77 (fallthrough)
branch  1 taken 807
branch  2 taken 0 (fallthrough)
branch  3 taken 77
branch  4 never executed
branch  5 never executed
    #####:  733:        bad_prog (LINE_JUNK);
call    0 never executed
      884:  734:      break;
        -:  735:
       34:  736:    case 'r':
       34:  737:      if (cur_cmd->a2.addr_type != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 34
    #####:  738:        bad_prog (ONE_ADDR);
call    0 never executed
        -:  739:      /* FALL THROUGH */
        -:  740:    case 'w':
       79:  741:      cur_cmd->cmd = ch;
       79:  742:      cur_cmd->x.io_file = compile_filename (ch == 'r');
call    0 returned 79
       79:  743:      break;
        -:  744:
      238:  745:    case 's':
      238:  746:      cur_cmd->cmd = ch;
      238:  747:      slash = inchar ();
call    0 returned 238
      238:  748:      compile_regex (slash);
call    0 returned 238
        -:  749:
      238:  750:      cur_cmd->x.cmd_regex.regx = last_regex;
        -:  751:
      238:  752:      b = init_buffer ();
call    0 returned 238
     1736:  753:      while (((ch = inchar ()) != EOF) && (ch != slash) && (ch != '\n'))
call    0 returned 1736
branch  1 taken 1736 (fallthrough)
branch  2 taken 0
branch  3 taken 1498 (fallthrough)
branch  4 taken 238
branch  5 taken 1498
branch  6 taken 0 (fallthrough)
        -:  754:        {
     1498:  755:          if (ch == '\\')
branch  0 taken 41 (fallthrough)
branch  1 taken 1457
        -:  756:        {
        -:  757:          int ci;
        -:  758:
       41:  759:          ci = inchar ();
call    0 returned 41
       41:  760:          if (ci != EOF)
branch  0 taken 41 (fallthrough)
branch  1 taken 0
        -:  761:            {
       41:  762:              if (ci != '\n')
branch  0 taken 41 (fallthrough)
branch  1 taken 0
       41:  763:            add1_buffer (b, ch);
call    0 returned 41
       41:  764:              add1_buffer (b, ci);
call    0 returned 41
        -:  765:            }
        -:  766:        }
        -:  767:          else
     1457:  768:        add1_buffer (b, ch);
call    0 returned 1457
        -:  769:        }
      238:  770:      if (ch != slash)
branch  0 taken 0 (fallthrough)
branch  1 taken 238
        -:  771:        {
    #####:  772:          if (ch == '\n' && prog_line > 1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  773:        --prog_line;
    #####:  774:          bad_prog ("Unterminated `s' command");
call    0 never executed
        -:  775:        }
      238:  776:      cur_cmd->x.cmd_regex.replace_length = size_buffer (b);
call    0 returned 238
      238:  777:      cur_cmd->x.cmd_regex.replacement = ck_malloc (cur_cmd->x.cmd_regex.replace_length);
call    0 returned 238
      238:  778:      bcopy (get_buffer (b), cur_cmd->x.cmd_regex.replacement, cur_cmd->x.cmd_regex.replace_length);
call    0 returned 238
      238:  779:      flush_buffer (b);
call    0 returned 238
        -:  780:
      238:  781:      cur_cmd->x.cmd_regex.flags = 0;
      238:  782:      cur_cmd->x.cmd_regex.numb = 0;
        -:  783:
      238:  784:      if (ch == EOF)
branch  0 taken 0 (fallthrough)
branch  1 taken 238
    #####:  785:        break;
        -:  786:      do
        -:  787:        {
      551:  788:          ch = inchar ();
call    0 returned 551
        -:  789:          switch (ch)
        -:  790:        {
      110:  791:        case 'p':
      110:  792:          if (cur_cmd->x.cmd_regex.flags & S_PRINT_BIT)
branch  0 taken 0 (fallthrough)
branch  1 taken 110
    #####:  793:            bad_prog ("multiple 'p' options to 's' command");
call    0 never executed
      110:  794:          cur_cmd->x.cmd_regex.flags |= S_PRINT_BIT;
      110:  795:          break;
      203:  796:        case 'g':
      203:  797:          if (cur_cmd->x.cmd_regex.flags & S_NUM_BIT)
branch  0 taken 0 (fallthrough)
branch  1 taken 203
    #####:  798:            cur_cmd->x.cmd_regex.flags &= ~S_NUM_BIT;
      203:  799:          if (cur_cmd->x.cmd_regex.flags & S_GLOBAL_BIT)
branch  0 taken 0 (fallthrough)
branch  1 taken 203
    #####:  800:            bad_prog ("multiple 'g' options to 's' command");
call    0 never executed
      203:  801:          cur_cmd->x.cmd_regex.flags |= S_GLOBAL_BIT;
      203:  802:          break;
      151:  803:        case 'w':
      151:  804:          cur_cmd->x.cmd_regex.flags |= S_WRITE_BIT;
      151:  805:          cur_cmd->x.cmd_regex.wio_file = compile_filename (0);
call    0 returned 151
      151:  806:          ch = '\n';
      151:  807:          break;
    #####:  808:        case '0':
        -:  809:        case '1':
        -:  810:        case '2':
        -:  811:        case '3':
        -:  812:        case '4':
        -:  813:        case '5':
        -:  814:        case '6':
        -:  815:        case '7':
        -:  816:        case '8':
        -:  817:        case '9':
    #####:  818:          if (cur_cmd->x.cmd_regex.flags & S_NUM_BIT)
branch  0 never executed
branch  1 never executed
    #####:  819:            bad_prog ("multiple number options to 's' command");
call    0 never executed
    #####:  820:          if ((cur_cmd->x.cmd_regex.flags & S_GLOBAL_BIT) == 0)
branch  0 never executed
branch  1 never executed
    #####:  821:            cur_cmd->x.cmd_regex.flags |= S_NUM_BIT;
    #####:  822:          num = 0;
    #####:  823:          while (isdigit (ch))
branch  0 never executed
branch  1 never executed
        -:  824:            {
    #####:  825:              num = num * 10 + ch - '0';
    #####:  826:              ch = inchar ();
call    0 never executed
        -:  827:            }
    #####:  828:          savchar (ch);
call    0 never executed
    #####:  829:          cur_cmd->x.cmd_regex.numb = num;
    #####:  830:          break;
       87:  831:        case '\n':
        -:  832:        case ';':
        -:  833:        case EOF:
       87:  834:          break;
    #####:  835:        default:
    #####:  836:          bad_prog ("Unknown option to 's'");
call    0 never executed
    #####:  837:          break;
        -:  838:        }
        -:  839:        }
      551:  840:      while (ch != EOF && ch != '\n' && ch != ';');
branch  0 taken 551 (fallthrough)
branch  1 taken 0
branch  2 taken 314 (fallthrough)
branch  3 taken 237
branch  4 taken 313
branch  5 taken 1 (fallthrough)
      238:  841:      if (ch == EOF)
branch  0 taken 0 (fallthrough)
branch  1 taken 238
    #####:  842:        break;
      238:  843:      break;
        -:  844:
       39:  845:    case 'y':
       39:  846:      cur_cmd->cmd = ch;
       39:  847:      string = (unsigned char *) ck_malloc (256);
call    0 returned 39
    10023:  848:      for (num = 0; num < 256; num++)
branch  0 taken 9984
branch  1 taken 39 (fallthrough)
     9984:  849:        string[num] = num;
       39:  850:      b = init_buffer ();
call    0 returned 39
       39:  851:      slash = inchar ();
call    0 returned 39
      328:  852:      while ((ch = inchar ()) != EOF && ch != slash)
call    0 returned 328
branch  1 taken 328 (fallthrough)
branch  2 taken 0
branch  3 taken 289
branch  4 taken 39 (fallthrough)
      289:  853:        add1_buffer (b, ch);
call    0 returned 289
       39:  854:      cur_cmd->x.translate = string;
       39:  855:      string = (unsigned char *) get_buffer (b);
call    0 returned 39
      328:  856:      for (num = size_buffer (b); num; --num)
call    0 returned 39
branch  1 taken 289
branch  2 taken 39 (fallthrough)
        -:  857:        {
      289:  858:          ch = inchar ();
call    0 returned 289
      289:  859:          if (ch == EOF)
branch  0 taken 0 (fallthrough)
branch  1 taken 289
    #####:  860:        bad_prog (BAD_EOF);
call    0 never executed
      289:  861:          if (ch == slash)
branch  0 taken 0 (fallthrough)
branch  1 taken 289
    #####:  862:        bad_prog ("strings for y command are different lengths");
call    0 never executed
      289:  863:          cur_cmd->x.translate[*string++] = ch;
        -:  864:        }
       39:  865:      flush_buffer (b);
call    0 returned 39
       39:  866:      if (inchar () != slash || ((ch = inchar ()) != EOF && ch != '\n' && ch != ';'))
call    0 returned 39
branch  1 taken 39 (fallthrough)
branch  2 taken 0
call    3 returned 39
branch  4 taken 39 (fallthrough)
branch  5 taken 0
branch  6 taken 2 (fallthrough)
branch  7 taken 37
branch  8 taken 0 (fallthrough)
branch  9 taken 2
    #####:  867:        bad_prog (LINE_JUNK);
call    0 never executed
       39:  868:      break;
        -:  869:
        5:  870:    default:
        5:  871:      bad_prog ("Unknown command");
call    0 returned 0
        -:  872:    }
        -:  873:    }
      356:  874:  if (program_depth)
branch  0 taken 1 (fallthrough)
branch  1 taken 355
        -:  875:    {
        1:  876:      prog_line = open_line;
        1:  877:      bad_prog ("Unmatched `{'");
call    0 returned 0
        -:  878:    }
      355:  879:  return vector;
        -:  880:}
        -:  881:
        -:  882:/* Complain about a programming error and exit. */
        -:  883:void
function bad_prog called 6 returned 0% blocks executed 100%
        6:  884:bad_prog (why)
        -:  885:     char *why;
        -:  886:{
        6:  887:  if (prog_line > 0)
branch  0 taken 1 (fallthrough)
branch  1 taken 5
        1:  888:    fprintf (stderr, "%s: file %s line %d: %s\n",
call    0 returned 1
        -:  889:         myname, prog_name, prog_line, why);
        -:  890:  else
        5:  891:    fprintf (stderr, "%s: %s\n", myname, why);
call    0 returned 5
        6:  892:  exit (1);
        -:  893:}
        -:  894:
        -:  895:/* Read the next character from the program.  Return EOF if there isn't
        -:  896:   anything to read.  Keep prog_line up to date, so error messages can
        -:  897:   be meaningful. */
        -:  898:int
function inchar called 34126 returned 100% blocks executed 87%
    34126:  899:inchar ()
        -:  900:{
        -:  901:  int ch;
    34126:  902:  if (prog_file)
branch  0 taken 33742 (fallthrough)
branch  1 taken 384
        -:  903:    {
    33742:  904:      if (feof (prog_file))
call    0 returned 33742
branch  1 taken 0 (fallthrough)
branch  2 taken 33742
    #####:  905:    return EOF;
        -:  906:      else
    33742:  907:    ch = getc (prog_file);
call    0 returned 33742
        -:  908:    }
        -:  909:  else
        -:  910:    {
      384:  911:      if (!prog_cur)
branch  0 taken 0 (fallthrough)
branch  1 taken 384
    #####:  912:    return EOF;
      384:  913:      else if (prog_cur == prog_end)
branch  0 taken 19 (fallthrough)
branch  1 taken 365
        -:  914:    {
       19:  915:      ch = EOF;
       19:  916:      prog_cur = 0;
        -:  917:    }
        -:  918:      else
      365:  919:    ch = *prog_cur++;
        -:  920:    }
    34126:  921:  if ((ch == '\n') && prog_line)
branch  0 taken 3001 (fallthrough)
branch  1 taken 31125
branch  2 taken 2981 (fallthrough)
branch  3 taken 20
     2981:  922:    prog_line++;
    34126:  923:  return ch;
        -:  924:}
        -:  925:
        -:  926:/* unget 'ch' so the next call to inchar will return it.  'ch' must not be
        -:  927:   EOF or anything nasty like that. */
        -:  928:void
function savchar called 5007 returned 100% blocks executed 89%
     5007:  929:savchar (ch)
        -:  930:     int ch;
        -:  931:{
     5007:  932:  if (ch == EOF)
branch  0 taken 0 (fallthrough)
branch  1 taken 5007
    #####:  933:    return;
     5007:  934:  if (ch == '\n' && prog_line > 1)
branch  0 taken 13 (fallthrough)
branch  1 taken 4994
branch  2 taken 13 (fallthrough)
branch  3 taken 0
       13:  935:    --prog_line;
     5007:  936:  if (prog_file)
branch  0 taken 4941 (fallthrough)
branch  1 taken 66
     4941:  937:    ungetc (ch, prog_file);
call    0 returned 4941
        -:  938:  else
       66:  939:    *--prog_cur = ch;
        -:  940:}
        -:  941:
        -:  942:
        -:  943:/* Try to read an address for a sed command.  If it succeeeds,
        -:  944:   return non-zero and store the resulting address in *'addr'.
        -:  945:   If the input doesn't look like an address read nothing
        -:  946:   and return zero. */
        -:  947:int
function compile_address called 2249 returned 100% blocks executed 94%
     2249:  948:compile_address (addr)
        -:  949:     struct addr *addr;
        -:  950:{
        -:  951:  int ch;
        -:  952:  int num;
        -:  953:
     2249:  954:  ch = inchar ();
call    0 returned 2249
        -:  955:
     2249:  956:  if (isdigit (ch))
branch  0 taken 88 (fallthrough)
branch  1 taken 2161
        -:  957:    {
       88:  958:      num = ch - '0';
      158:  959:      while ((ch = inchar ()) != EOF && isdigit (ch))
call    0 returned 158
branch  1 taken 158 (fallthrough)
branch  2 taken 0
branch  3 taken 70
branch  4 taken 88 (fallthrough)
       70:  960:    num = num * 10 + ch - '0';
       88:  961:      while (ch != EOF && isblank (ch))
branch  0 taken 88 (fallthrough)
branch  1 taken 0
branch  2 taken 0
branch  3 taken 88 (fallthrough)
    #####:  962:    ch = inchar ();
call    0 never executed
       88:  963:      savchar (ch);
call    0 returned 88
       88:  964:      addr->addr_type = addr_is_num;
       88:  965:      addr->addr_number = num;
       88:  966:      return 1;
        -:  967:    }
     2161:  968:  else if (ch == '/' || ch == '\\')
branch  0 taken 1778 (fallthrough)
branch  1 taken 383
branch  2 taken 0 (fallthrough)
branch  3 taken 1778
        -:  969:    {
      383:  970:      addr->addr_type = addr_is_regex;
      383:  971:      if (ch == '\\')
branch  0 taken 0 (fallthrough)
branch  1 taken 383
    #####:  972:    ch = inchar ();
call    0 never executed
      383:  973:      compile_regex (ch);
call    0 returned 383
      383:  974:      addr->addr_regex = last_regex;
        -:  975:      do
      391:  976:    ch = inchar ();
call    0 returned 391
      391:  977:      while (ch != EOF && isblank (ch));
branch  0 taken 391 (fallthrough)
branch  1 taken 0
branch  2 taken 8
branch  3 taken 383 (fallthrough)
      383:  978:      savchar (ch);
call    0 returned 383
      383:  979:      return 1;
        -:  980:    }
     1778:  981:  else if (ch == '$')
branch  0 taken 13 (fallthrough)
branch  1 taken 1765
        -:  982:    {
       13:  983:      addr->addr_type = addr_is_last;
        -:  984:      do
       13:  985:    ch = inchar ();
call    0 returned 13
       13:  986:      while (ch != EOF && isblank (ch));
branch  0 taken 13 (fallthrough)
branch  1 taken 0
branch  2 taken 0
branch  3 taken 13 (fallthrough)
       13:  987:      savchar (ch);
call    0 returned 13
       13:  988:      return 1;
        -:  989:    }
        -:  990:  else
     1765:  991:    savchar (ch);
call    0 returned 1765
     1765:  992:  return 0;
        -:  993:}
        -:  994:
        -:  995:void
function compile_regex called 621 returned 100% blocks executed 92%
      621:  996:compile_regex (slash)
        -:  997:     int slash;
        -:  998:{
        -:  999:  VOID *b;
        -: 1000:  int ch;
      621: 1001:  int char_class_pos = -1;
        -: 1002:
      621: 1003:  b = init_buffer ();
call    0 returned 621
     3305: 1004:  while ((ch = inchar ()) != EOF && (ch != slash || (char_class_pos >= 0)))
call    0 returned 3305
branch  1 taken 3305 (fallthrough)
branch  2 taken 0
branch  3 taken 2684
branch  4 taken 621 (fallthrough)
branch  5 taken 0
branch  6 taken 621 (fallthrough)
        -: 1005:    {
     2684: 1006:      if (ch == '^')
branch  0 taken 153 (fallthrough)
branch  1 taken 2531
        -: 1007:    {
      153: 1008:      if (size_buffer (b) == 0)
call    0 returned 153
branch  1 taken 152 (fallthrough)
branch  2 taken 1
        -: 1009:        {
      152: 1010:          add1_buffer (b, '\\');
call    0 returned 152
      152: 1011:          add1_buffer (b, '`');
call    0 returned 152
        -: 1012:        }
        -: 1013:      else
        1: 1014:        add1_buffer (b, ch);
call    0 returned 1
      153: 1015:      continue;
        -: 1016:    }
     2531: 1017:      else if (ch == '$')
branch  0 taken 102 (fallthrough)
branch  1 taken 2429
        -: 1018:    {
      102: 1019:      ch = inchar ();
call    0 returned 102
      102: 1020:      savchar (ch);
call    0 returned 102
      102: 1021:      if (ch == slash)
branch  0 taken 102 (fallthrough)
branch  1 taken 0
        -: 1022:        {
      102: 1023:          add1_buffer (b, '\\');
call    0 returned 102
      102: 1024:          add1_buffer (b, '\'');
call    0 returned 102
        -: 1025:        }
        -: 1026:      else
    #####: 1027:        add1_buffer (b, '$');
call    0 never executed
      102: 1028:      continue;
        -: 1029:    }
     2429: 1030:      else if (ch == '[')
branch  0 taken 5 (fallthrough)
branch  1 taken 2424
        -: 1031:    {
        5: 1032:      if (char_class_pos < 0)
branch  0 taken 5 (fallthrough)
branch  1 taken 0
        5: 1033:        char_class_pos = size_buffer (b);
call    0 returned 5
        5: 1034:      add1_buffer (b, ch);
call    0 returned 5
        5: 1035:      continue;
        -: 1036:    }
     2424: 1037:      else if (ch == ']')
branch  0 taken 5 (fallthrough)
branch  1 taken 2419
        -: 1038:    {
        5: 1039:      add1_buffer (b, ch);
call    0 returned 5
        5: 1040:      {
        5: 1041:        char * regexp = get_buffer (b);
call    0 returned 5
        5: 1042:        int pos = size_buffer (b) - 1;
call    0 returned 5
        5: 1043:        if (!(   (char_class_pos >= 0)
branch  0 taken 5 (fallthrough)
branch  1 taken 0
        5: 1044:          && (   (pos == char_class_pos + 1)
branch  0 taken 5 (fallthrough)
branch  1 taken 0
        5: 1045:              || (   (pos == char_class_pos + 2)
branch  0 taken 0 (fallthrough)
branch  1 taken 5
    #####: 1046:              && (regexp[char_class_pos + 1] == '^')))))
branch  0 never executed
branch  1 never executed
        5: 1047:          char_class_pos = -1;
        5: 1048:        continue;
        -: 1049:      }
        -: 1050:    }
     2419: 1051:      else if (ch != '\\' || (char_class_pos >= 0))
branch  0 taken 350 (fallthrough)
branch  1 taken 2069
branch  2 taken 0 (fallthrough)
branch  3 taken 350
        -: 1052:    {
     2069: 1053:      add1_buffer (b, ch);
call    0 returned 2069
     2069: 1054:      continue;
        -: 1055:    }
      350: 1056:      ch = inchar ();
call    0 returned 350
      350: 1057:      switch (ch)
branch  0 taken 12
branch  1 taken 0
branch  2 taken 338
        -: 1058:    {
       12: 1059:    case 'n':
       12: 1060:      add1_buffer (b, '\n');
call    0 returned 12
       12: 1061:      break;
        -: 1062:#if 0
        -: 1063:    case 'b':
        -: 1064:      add1_buffer (b, '\b');
        -: 1065:      break;
        -: 1066:    case 'f':
        -: 1067:      add1_buffer (b, '\f');
        -: 1068:      break;
        -: 1069:    case 'r':
        -: 1070:      add1_buffer (b, '\r');
        -: 1071:      break;
        -: 1072:    case 't':
        -: 1073:      add1_buffer (b, '\t');
        -: 1074:      break;
        -: 1075:#endif /* 0 */
    #####: 1076:    case EOF:
    #####: 1077:      break;
      338: 1078:    default:
      338: 1079:      add1_buffer (b, '\\');
call    0 returned 338
      338: 1080:      add1_buffer (b, ch);
call    0 returned 338
      338: 1081:      break;
        -: 1082:    }
        -: 1083:    }
      621: 1084:  if (ch == EOF)
branch  0 taken 0 (fallthrough)
branch  1 taken 621
    #####: 1085:    bad_prog (BAD_EOF);
call    0 never executed
      621: 1086:  if (size_buffer (b))
call    0 returned 621
branch  1 taken 603 (fallthrough)
branch  2 taken 18
        -: 1087:    {
      603: 1088:      last_regex = (struct re_pattern_buffer *) ck_malloc (sizeof (struct re_pattern_buffer));
call    0 returned 603
      603: 1089:      last_regex->allocated = size_buffer (b) + 10;
call    0 returned 603
     1206: 1090:      last_regex->buffer =
      603: 1091:    (unsigned char *) ck_malloc (last_regex->allocated);
call    0 returned 603
      603: 1092:      last_regex->fastmap = ck_malloc (256);
call    0 returned 603
      603: 1093:      last_regex->translate = 0;
      603: 1094:      re_compile_pattern (get_buffer (b), size_buffer (b), last_regex);
call    0 returned 603
call    1 returned 603
call    2 returned 603
        -: 1095:    }
       18: 1096:  else if (!last_regex)
branch  0 taken 0 (fallthrough)
branch  1 taken 18
    #####: 1097:    bad_prog (NO_REGEX);
call    0 never executed
      621: 1098:  flush_buffer (b);
call    0 returned 621
      621: 1099:}
        -: 1100:
        -: 1101:/* Store a label (or label reference) created by a ':', 'b', or 't'
        -: 1102:   comand so that the jump to/from the lable can be backpatched after
        -: 1103:   compilation is complete */
        -: 1104:struct sed_label *
function setup_jump called 13 returned 100% blocks executed 100%
       13: 1105:setup_jump (list, cmd, vec)
        -: 1106:     struct sed_label *list;
        -: 1107:     struct sed_cmd *cmd;
        -: 1108:     struct vector *vec;
        -: 1109:{
        -: 1110:  struct sed_label *tmp;
        -: 1111:  VOID *b;
        -: 1112:  int ch;
        -: 1113:
       13: 1114:  b = init_buffer ();
call    0 returned 13
       19: 1115:  while ((ch = inchar ()) != EOF && isblank (ch))
call    0 returned 19
branch  1 taken 19 (fallthrough)
branch  2 taken 0
branch  3 taken 6
branch  4 taken 13 (fallthrough)
        -: 1116:    ;
        -: 1117:  /* Possible non posixicity. */
       40: 1118:  while (ch != EOF && ch != '\n' && (!isblank (ch)) && ch != ';' && ch != '}')
branch  0 taken 40 (fallthrough)
branch  1 taken 0
branch  2 taken 27 (fallthrough)
branch  3 taken 13
branch  4 taken 27 (fallthrough)
branch  5 taken 0
branch  6 taken 27 (fallthrough)
branch  7 taken 0
branch  8 taken 27
branch  9 taken 0 (fallthrough)
        -: 1119:    {
       27: 1120:      add1_buffer (b, ch);
call    0 returned 27
       27: 1121:      ch = inchar ();
call    0 returned 27
        -: 1122:    }
       13: 1123:  savchar (ch);
call    0 returned 13
       13: 1124:  add1_buffer (b, '\0');
call    0 returned 13
       13: 1125:  tmp = (struct sed_label *) ck_malloc (sizeof (struct sed_label));
call    0 returned 13
       13: 1126:  tmp->v = vec;
       13: 1127:  tmp->v_index = cmd - vec->v;
       13: 1128:  tmp->name = ck_strdup (get_buffer (b));
call    0 returned 13
call    1 returned 13
       13: 1129:  tmp->next = list;
       13: 1130:  flush_buffer (b);
call    0 returned 13
       13: 1131:  return tmp;
        -: 1132:}
        -: 1133:
        -: 1134:/* read in a filename for a 'r', 'w', or 's///w' command, and
        -: 1135:   update the internal structure about files.  The file is
        -: 1136:   opened if it isn't already open. */
        -: 1137:FILE *
function compile_filename called 230 returned 100% blocks executed 79%
      230: 1138:compile_filename (readit)
        -: 1139:     int readit;
        -: 1140:{
        -: 1141:  char *file_name;
        -: 1142:  int n;
        -: 1143:  VOID *b;
        -: 1144:  int ch;
        -: 1145:
      230: 1146:  if (inchar () != ' ')
call    0 returned 230
branch  1 taken 0 (fallthrough)
branch  2 taken 230
    #####: 1147:    bad_prog ("missing ' ' before filename");
call    0 never executed
      230: 1148:  b = init_buffer ();
call    0 returned 230
     3097: 1149:  while ((ch = inchar ()) != EOF && ch != '\n')
call    0 returned 3097
branch  1 taken 3097 (fallthrough)
branch  2 taken 0
branch  3 taken 2867
branch  4 taken 230 (fallthrough)
     2867: 1150:    add1_buffer (b, ch);
call    0 returned 2867
      230: 1151:  add1_buffer (b, '\0');
call    0 returned 230
      230: 1152:  file_name = get_buffer (b);
call    0 returned 230
      292: 1153:  for (n = 0; n < NUM_FPS; n++)
branch  0 taken 292
branch  1 taken 0 (fallthrough)
        -: 1154:    {
      292: 1155:      if (!file_ptrs[n].name)
branch  0 taken 230 (fallthrough)
branch  1 taken 62
      230: 1156:    break;
       62: 1157:      if (!strcmp (file_ptrs[n].name, file_name))
branch  0 taken 0 (fallthrough)
branch  1 taken 62
        -: 1158:    {
    #####: 1159:      if (file_ptrs[n].readit != readit)
branch  0 never executed
branch  1 never executed
    #####: 1160:        bad_prog ("Can't open file for both reading and writing");
call    0 never executed
    #####: 1161:      flush_buffer (b);
call    0 never executed
    #####: 1162:      return file_ptrs[n].phile;
        -: 1163:    }
        -: 1164:    }
      230: 1165:  if (n < NUM_FPS)
branch  0 taken 230 (fallthrough)
branch  1 taken 0
        -: 1166:    {
      230: 1167:      file_ptrs[n].name = ck_strdup (file_name);
call    0 returned 230
      230: 1168:      file_ptrs[n].readit = readit;
      230: 1169:      if (!readit)
branch  0 taken 196 (fallthrough)
branch  1 taken 34
      196: 1170:    file_ptrs[n].phile = ck_fopen (file_name, "w");
call    0 returned 196
        -: 1171:      else
        -: 1172:    {
       34: 1173:      file_ptrs[n].phile = ck_fopen (file_name, "r");
call    0 returned 34
        -: 1174:    }
      230: 1175:      flush_buffer (b);
call    0 returned 230
      230: 1176:      return file_ptrs[n].phile;
        -: 1177:    }
        -: 1178:  else
        -: 1179:    {
    #####: 1180:      bad_prog ("Hopelessely evil compiled in limit on number of open files.  re-compile sed");
call    0 never executed
    #####: 1181:      return 0;
        -: 1182:    }
        -: 1183:}
        -: 1184:
        -: 1185:/* Read a file and apply the compiled script to it. */
        -: 1186:void
function read_file called 354 returned 100% blocks executed 100%
      354: 1187:read_file (name)
        -: 1188:     char *name;
        -: 1189:{
      354: 1190:  if (*name == '-' && name[1] == '\0')
branch  0 taken 1 (fallthrough)
branch  1 taken 353
branch  2 taken 1 (fallthrough)
branch  3 taken 0
        1: 1191:    input_file = stdin;
        -: 1192:  else
        -: 1193:    {
      353: 1194:      input_file = fopen (name, "r");
call    0 returned 353
      353: 1195:      if (input_file == 0)
branch  0 taken 1 (fallthrough)
branch  1 taken 352
        -: 1196:    {
        1: 1197:      char *ptr = strerror(errno);
call    0 returned 1
        1: 1198:      bad_input++;
        1: 1199:      fprintf (stderr, "%s: can't read %s: %s\n", myname, name, ptr);
call    0 returned 1
        1: 1200:      return;
        -: 1201:    }
        -: 1202:    }
    31936: 1203:  while (read_pattern_space ())
call    0 returned 31936
branch  1 taken 31630
branch  2 taken 306 (fallthrough)
        -: 1204:    {
    31630: 1205:      execute_program (the_program);
call    0 returned 31630
    31630: 1206:      if (!no_default_output)
branch  0 taken 12523 (fallthrough)
branch  1 taken 19107
    12523: 1207:    ck_fwrite (line.text, 1, line.length, stdout);
call    0 returned 12523
    31630: 1208:      if (append.length)
branch  0 taken 607 (fallthrough)
branch  1 taken 31023
        -: 1209:    {
      607: 1210:      ck_fwrite (append.text, 1, append.length, stdout);
call    0 returned 607
      607: 1211:      append.length = 0;
        -: 1212:    }
    31630: 1213:      if (quit_cmd)
branch  0 taken 47 (fallthrough)
branch  1 taken 31583
       47: 1214:    break;
        -: 1215:    }
      353: 1216:  ck_fclose (input_file);
call    0 returned 353
        -: 1217:}
        -: 1218:
        -: 1219:static char *
function eol_pos called 3793 returned 100% blocks executed 83%
     3793: 1220:eol_pos (str, len)
        -: 1221:     char *str;
        -: 1222:     int len;
        -: 1223:{
    58987: 1224:  while (len--)
branch  0 taken 58987
branch  1 taken 0 (fallthrough)
    58987: 1225:    if (*str++ == '\n')
branch  0 taken 3793 (fallthrough)
branch  1 taken 55194
     3793: 1226:      return --str;
    #####: 1227:  return --str;
        -: 1228:}
        -: 1229:
        -: 1230:static void
function chr_copy called 717 returned 100% blocks executed 100%
      717: 1231:chr_copy (dest, src, len)
        -: 1232:     char *dest;
        -: 1233:     char *src;
        -: 1234:     int len;
        -: 1235:{
    13145: 1236:  while (len--)
branch  0 taken 12428
branch  1 taken 717 (fallthrough)
    12428: 1237:    *dest++ = *src++;
      717: 1238:}
        -: 1239:
        -: 1240:/* Execute the program 'vec' on the current input line. */
        -: 1241:static struct re_registers regs =
        -: 1242:{0, 0, 0};
        -: 1243:
        -: 1244:void
function execute_program called 31630 returned 100% blocks executed 87%
    31630: 1245:execute_program (vec)
        -: 1246:     struct vector *vec;
        -: 1247:{
        -: 1248:  struct sed_cmd *cur_cmd;
        -: 1249:  int n;
        -: 1250:  int addr_matched;
        -: 1251:  static int end_cycle;
        -: 1252:
        -: 1253:  int start;
        -: 1254:  int remain;
        -: 1255:  int offset;
        -: 1256:
        -: 1257:  static struct line tmp;
        -: 1258:  struct line t;
        -: 1259:  char *rep, *rep_end, *rep_next, *rep_cur;
        -: 1260:
        -: 1261:  int count;
    31630: 1262:  struct vector *restart_vec = vec;
        -: 1263:
    32347: 1264:restart:
    32347: 1265:  vec = restart_vec;
    32347: 1266:  count = 0;
        -: 1267:
    32347: 1268:  end_cycle = 0;
        -: 1269:
    92510: 1270:  for (cur_cmd = vec->v, n = vec->v_length; n; cur_cmd++, n--)
branch  0 taken 66051
branch  1 taken 26459 (fallthrough)
        -: 1271:    {
    66051: 1272:    exe_loop:
    70795: 1273:      addr_matched = 0;
    70795: 1274:      if (cur_cmd->aflags & A1_MATCHED_BIT)
branch  0 taken 1841 (fallthrough)
branch  1 taken 68954
        -: 1275:    {
     1841: 1276:      addr_matched = 1;
     1841: 1277:      if (match_address (&(cur_cmd->a2)))
call    0 returned 1841
branch  1 taken 42 (fallthrough)
branch  2 taken 1799
       42: 1278:        cur_cmd->aflags &= ~A1_MATCHED_BIT;
        -: 1279:    }
    68954: 1280:      else if (match_address (&(cur_cmd->a1)))
call    0 returned 68954
branch  1 taken 37176 (fallthrough)
branch  2 taken 31778
        -: 1281:    {
    37176: 1282:      addr_matched = 1;
    37176: 1283:      if (cur_cmd->a2.addr_type != addr_is_null)
branch  0 taken 60 (fallthrough)
branch  1 taken 37116
       60: 1284:        if (   (cur_cmd->a2.addr_type == addr_is_regex)
branch  0 taken 20 (fallthrough)
branch  1 taken 40
       20: 1285:        || !match_address (&(cur_cmd->a2)))
call    0 returned 20
branch  1 taken 20 (fallthrough)
branch  2 taken 0
       60: 1286:          cur_cmd->aflags |= A1_MATCHED_BIT;
        -: 1287:
        -: 1288:    }
    70795: 1289:      if (cur_cmd->aflags & ADDR_BANG_BIT)
branch  0 taken 2112 (fallthrough)
branch  1 taken 68683
     2112: 1290:    addr_matched = !addr_matched;
    70795: 1291:      if (!addr_matched)
branch  0 taken 29830 (fallthrough)
branch  1 taken 40965
    29830: 1292:    continue;
    40965: 1293:      switch (cur_cmd->cmd)
branch  0 taken 4701
branch  1 taken 1264
branch  2 taken 378
branch  3 taken 228
branch  4 taken 546
branch  5 taken 119
branch  6 taken 2589
branch  7 taken 1734
branch  8 taken 1436
branch  9 taken 10
branch 10 taken 10
branch 11 taken 18
branch 12 taken 12
branch 13 taken 391
branch 14 taken 838
branch 15 taken 2908
branch 16 taken 2954
branch 17 taken 2054
branch 18 taken 2357
branch 19 taken 29
branch 20 taken 98
branch 21 taken 12566
branch 22 taken 13
branch 23 taken 1689
branch 24 taken 5
branch 25 taken 2018
branch 26 taken 0
        -: 1294:    {
     4701: 1295:    case '{':       /* Execute sub-program */
     4701: 1296:      if (cur_cmd->x.sub->v_length)
branch  0 taken 4701 (fallthrough)
branch  1 taken 0
        -: 1297:        {
     4701: 1298:          vec = cur_cmd->x.sub;
     4701: 1299:          cur_cmd = vec->v;
     4701: 1300:          n = vec->v_length;
     4701: 1301:          goto exe_loop;
        -: 1302:        }
    #####: 1303:      break;
        -: 1304:
     1264: 1305:    case '}':
     1264: 1306:      cur_cmd = vec->return_v->v + vec->return_i;
     1264: 1307:      n = vec->return_v->v_length - vec->return_i;
     1264: 1308:      vec = vec->return_v;
     1264: 1309:      break;
        -: 1310:
      378: 1311:    case ':':       /* Executing labels is easy. */
      378: 1312:      break;
        -: 1313:
      228: 1314:    case '=':
      228: 1315:      printf ("%d\n", input_line_number);
call    0 returned 228
      228: 1316:      break;
        -: 1317:
      546: 1318:    case 'a':
      548: 1319:      while (append.alloc - append.length < cur_cmd->x.cmd_txt.text_len)
branch  0 taken 2
branch  1 taken 546 (fallthrough)
        -: 1320:        {
        2: 1321:          append.alloc *= 2;
        2: 1322:          append.text = ck_realloc (append.text, append.alloc);
call    0 returned 2
        -: 1323:        }
      546: 1324:      bcopy (cur_cmd->x.cmd_txt.text,
      546: 1325:         append.text + append.length, cur_cmd->x.cmd_txt.text_len);
      546: 1326:      append.length += cur_cmd->x.cmd_txt.text_len;
      546: 1327:      break;
        -: 1328:
      119: 1329:    case 'b':
      119: 1330:      if (!cur_cmd->x.jump)
branch  0 taken 77 (fallthrough)
branch  1 taken 42
       77: 1331:        end_cycle++;
        -: 1332:      else
        -: 1333:        {
       42: 1334:          struct sed_label *j = cur_cmd->x.jump;
        -: 1335:
       42: 1336:          n = j->v->v_length - j->v_index;
       42: 1337:          cur_cmd = j->v->v + j->v_index;
       42: 1338:          goto exe_loop;
        -: 1339:        }
       77: 1340:      break;
        -: 1341:
     2589: 1342:    case 'c':
     2589: 1343:      line.length = 0;
     2589: 1344:      if (!((cur_cmd->aflags & A1_MATCHED_BIT)))
branch  0 taken 1821 (fallthrough)
branch  1 taken 768
     1821: 1345:        ck_fwrite (cur_cmd->x.cmd_txt.text,
call    0 returned 1821
        -: 1346:               1, cur_cmd->x.cmd_txt.text_len, stdout);
     2589: 1347:      end_cycle++;
     2589: 1348:      break;
        -: 1349:
     1734: 1350:    case 'd':
     1734: 1351:      line.length = 0;
     1734: 1352:      end_cycle++;
     1734: 1353:      break;
        -: 1354:
     1436: 1355:    case 'D':
        -: 1356:      {
        -: 1357:        char *tmp;
        -: 1358:        int newlength;
        -: 1359:
     1436: 1360:        tmp = eol_pos (line.text, line.length);
call    0 returned 1436
     1436: 1361:        newlength = line.length - (tmp - line.text) - 1;
     1436: 1362:        if (newlength)
branch  0 taken 717 (fallthrough)
branch  1 taken 719
        -: 1363:          {
      717: 1364:        chr_copy (line.text, tmp + 1, newlength);
call    0 returned 717
      717: 1365:        line.length = newlength;
      717: 1366:        goto restart;
        -: 1367:          }
      719: 1368:        line.length = 0;
      719: 1369:        end_cycle++;
        -: 1370:      }
      719: 1371:      break;
        -: 1372:
       10: 1373:    case 'g':
       10: 1374:      line_copy (&hold, &line);
call    0 returned 10
       10: 1375:      break;
        -: 1376:
       10: 1377:    case 'G':
       10: 1378:      line_append (&hold, &line);
call    0 returned 10
       10: 1379:      break;
        -: 1380:
       18: 1381:    case 'h':
       18: 1382:      line_copy (&line, &hold);
call    0 returned 18
       18: 1383:      break;
        -: 1384:
       12: 1385:    case 'H':
       12: 1386:      line_append (&line, &hold);
call    0 returned 12
       12: 1387:      break;
        -: 1388:
      391: 1389:    case 'i':
      391: 1390:      ck_fwrite (cur_cmd->x.cmd_txt.text, 1,
call    0 returned 391
        -: 1391:             cur_cmd->x.cmd_txt.text_len, stdout);
      391: 1392:      break;
        -: 1393:
      838: 1394:    case 'l':
        -: 1395:      {
        -: 1396:        char *tmp;
        -: 1397:        int n;
      838: 1398:        int width = 0;
        -: 1399:
      838: 1400:        n = line.length;
      838: 1401:        tmp = line.text;
    17562: 1402:        while (n--)
branch  0 taken 17562
branch  1 taken 0 (fallthrough)
        -: 1403:          {
        -: 1404:        /* Skip the trailing newline, if there is one */
    17562: 1405:        if (!n && (*tmp == '\n'))
branch  0 taken 838 (fallthrough)
branch  1 taken 16724
branch  2 taken 838 (fallthrough)
branch  3 taken 0
      838: 1406:          break;
    16724: 1407:        if (width > 77)
branch  0 taken 2 (fallthrough)
branch  1 taken 16722
        -: 1408:          {
        2: 1409:            width = 0;
        2: 1410:            putchar ('\n');
call    0 returned 2
        -: 1411:          }
    16724: 1412:        if (*tmp == '\\')
branch  0 taken 0 (fallthrough)
branch  1 taken 16724
        -: 1413:          {
    #####: 1414:            printf ("\\\\");
call    0 never executed
    #####: 1415:            width += 2;
        -: 1416:          }
    16724: 1417:        else if (isprint (*tmp))
branch  0 taken 16265 (fallthrough)
branch  1 taken 459
        -: 1418:          {
    16265: 1419:            putchar (*tmp);
call    0 returned 16265
    16265: 1420:            width++;
        -: 1421:          }
        -: 1422:        else
      459: 1423:          switch (*tmp)
branch  0 taken 0
branch  1 taken 0
branch  2 taken 0
branch  3 taken 233
branch  4 taken 0
branch  5 taken 136
branch  6 taken 0
branch  7 taken 90
        -: 1424:            {
        -: 1425:#if 0
        -: 1426:              /* Should print \00 instead of \0 because (a) POSIX */
        -: 1427:              /* requires it, and (b) this way \01 is unambiguous.  */
        -: 1428:            case '\0':
        -: 1429:              printf ("\\0");
        -: 1430:              width += 2;
        -: 1431:              break;
        -: 1432:#endif
    #####: 1433:            case 007:
    #####: 1434:              printf ("\\a");
call    0 never executed
    #####: 1435:              width += 2;
    #####: 1436:              break;
    #####: 1437:            case '\b':
    #####: 1438:              printf ("\\b");
call    0 never executed
    #####: 1439:              width += 2;
    #####: 1440:              break;
    #####: 1441:            case '\f':
    #####: 1442:              printf ("\\f");
call    0 never executed
    #####: 1443:              width += 2;
    #####: 1444:              break;
      233: 1445:            case '\n':
      233: 1446:              printf ("\\n");
call    0 returned 233
      233: 1447:              width += 2;
      233: 1448:              break;
    #####: 1449:            case '\r':
    #####: 1450:              printf ("\\r");
call    0 never executed
    #####: 1451:              width += 2;
    #####: 1452:              break;
      136: 1453:            case '\t':
      136: 1454:              printf ("\\t");
call    0 returned 136
      136: 1455:              width += 2;
      136: 1456:              break;
    #####: 1457:            case '\v':
    #####: 1458:              printf ("\\v");
call    0 never executed
    #####: 1459:              width += 2;
    #####: 1460:              break;
       90: 1461:            default:
       90: 1462:              printf ("\\%02x", (*tmp) & 0xFF);
call    0 returned 90
       90: 1463:              width += 2;
       90: 1464:              break;
        -: 1465:            }
    16724: 1466:        tmp++;
        -: 1467:          }
      838: 1468:        putchar ('\n');
call    0 returned 838
        -: 1469:      }
      838: 1470:      break;
        -: 1471:
     2908: 1472:    case 'n':
     2908: 1473:      if (feof (input_file))
call    0 returned 2908
branch  1 taken 8 (fallthrough)
branch  2 taken 2900
        8: 1474:        goto quit;
     2900: 1475:      if (!no_default_output)
branch  0 taken 891 (fallthrough)
branch  1 taken 2009
      891: 1476:        ck_fwrite (line.text, 1, line.length, stdout);
call    0 returned 891
     2900: 1477:      read_pattern_space ();
call    0 returned 2900
     2900: 1478:      break;
        -: 1479:
     2954: 1480:    case 'N':
     2954: 1481:      if (feof (input_file))
call    0 returned 2954
branch  1 taken 10 (fallthrough)
branch  2 taken 2944
        -: 1482:        {
       10: 1483:          line.length = 0;
       10: 1484:          goto quit;
        -: 1485:        }
     2944: 1486:      append_pattern_space ();
call    0 returned 2944
     2944: 1487:      break;
        -: 1488:
     2054: 1489:    case 'p':
     2054: 1490:      ck_fwrite (line.text, 1, line.length, stdout);
call    0 returned 2054
     2054: 1491:      break;
        -: 1492:
     2357: 1493:    case 'P':
        -: 1494:      {
        -: 1495:        char *tmp;
        -: 1496:
     2357: 1497:        tmp = eol_pos (line.text, line.length);
call    0 returned 2357
    4714*: 1498:        ck_fwrite (line.text, 1,
branch  0 taken 2357 (fallthrough)
branch  1 taken 0
call    2 returned 2357
     2357: 1499:               tmp ? tmp - line.text + 1
        -: 1500:               : line.length, stdout);
        -: 1501:      }
     2357: 1502:      break;
        -: 1503:
        -: 1504:    case 'q':
       47: 1505:    quit:
       47: 1506:      quit_cmd++;
       47: 1507:      end_cycle++;
       47: 1508:      break;
        -: 1509:
       98: 1510:    case 'r':
        -: 1511:      {
       98: 1512:        int n = 0;
        -: 1513:
       98: 1514:        if (cur_cmd->x.io_file)
branch  0 taken 98 (fallthrough)
branch  1 taken 0
        -: 1515:          {
       98: 1516:        rewind (cur_cmd->x.io_file);
call    0 returned 98
        -: 1517:        do
        -: 1518:          {
      229: 1519:            append.length += n;
      229: 1520:            if (append.length == append.alloc)
branch  0 taken 33 (fallthrough)
branch  1 taken 196
        -: 1521:              {
       33: 1522:            append.alloc *= 2;
       33: 1523:            append.text = ck_realloc (append.text, append.alloc);
call    0 returned 33
        -: 1524:              }
      458: 1525:            n = fread (append.text + append.length, sizeof (char),
      229: 1526:                   append.alloc - append.length,
call    0 returned 229
        -: 1527:                   cur_cmd->x.io_file);
        -: 1528:          }
      229: 1529:        while (n > 0);
branch  0 taken 131
branch  1 taken 98 (fallthrough)
       98: 1530:        if (ferror (cur_cmd->x.io_file))
call    0 returned 98
branch  1 taken 0 (fallthrough)
branch  2 taken 98
    #####: 1531:          panic ("Read error on input file to 'r' command");
call    0 never executed
        -: 1532:          }
        -: 1533:      }
       98: 1534:      break;
        -: 1535:
    12566: 1536:    case 's':
        -: 1537:      {
    12566: 1538:        int trail_nl_p = line.text [line.length - 1] == '\n';
    12566: 1539:        if (!tmp.alloc)
branch  0 taken 179 (fallthrough)
branch  1 taken 12387
        -: 1540:          {
      179: 1541:        tmp.alloc = 50;
      179: 1542:        tmp.text = ck_malloc (50);
call    0 returned 179
        -: 1543:          }
    12566: 1544:        count = 0;
    12566: 1545:        start = 0;
    12566: 1546:        remain = line.length - trail_nl_p;
    12566: 1547:        tmp.length = 0;
    12566: 1548:        rep = cur_cmd->x.cmd_regex.replacement;
    12566: 1549:        rep_end = rep + cur_cmd->x.cmd_regex.replace_length;
        -: 1550:        
    12566: 1551:        while ((offset = re_search (cur_cmd->x.cmd_regex.regx,
    15140: 1552:                    line.text,
    15140: 1553:                    line.length - trail_nl_p,
call    0 returned 15140
        -: 1554:                    start,
        -: 1555:                    remain,
    15140: 1556:                    &regs)) >= 0)
branch  0 taken 3588
branch  1 taken 11552 (fallthrough)
        -: 1557:          {
     3588: 1558:        count++;
     3588: 1559:        if (offset - start)
branch  0 taken 948 (fallthrough)
branch  1 taken 2640
      948: 1560:          str_append (&tmp, line.text + start, offset - start);
call    0 returned 948
        -: 1561:        
     3588: 1562:        if (cur_cmd->x.cmd_regex.flags & S_NUM_BIT)
branch  0 taken 0 (fallthrough)
branch  1 taken 3588
        -: 1563:          {
    #####: 1564:            if (count != cur_cmd->x.cmd_regex.numb)
branch  0 never executed
branch  1 never executed
    #####: 1565:              {
    #####: 1566:            int matched = regs.end[0] - regs.start[0];
    #####: 1567:            if (!matched) matched = 1;
branch  0 never executed
branch  1 never executed
    #####: 1568:            str_append (&tmp, line.text + regs.start[0], matched);
call    0 never executed
    #####: 1569:            start = (offset == regs.end[0]
    #####: 1570:                 ? offset + 1 : regs.end[0]);
branch  0 never executed
branch  1 never executed
    #####: 1571:            remain = (line.length - trail_nl_p) - start;
    #####: 1572:            continue;
        -: 1573:              }
        -: 1574:          }
        -: 1575:        
    23225: 1576:        for (rep_next = rep_cur = rep; rep_next < rep_end; rep_next++)
branch  0 taken 19637
branch  1 taken 3588 (fallthrough)
        -: 1577:          {
    19637: 1578:            if (*rep_next == '&')
branch  0 taken 23 (fallthrough)
branch  1 taken 19614
        -: 1579:              {
       23: 1580:            if (rep_next - rep_cur)
branch  0 taken 10 (fallthrough)
branch  1 taken 13
       10: 1581:              str_append (&tmp, rep_cur, rep_next - rep_cur);
call    0 returned 10
       23: 1582:            str_append (&tmp, line.text + regs.start[0], regs.end[0] - regs.start[0]);
call    0 returned 23
       23: 1583:            rep_cur = rep_next + 1;
        -: 1584:              }
    19614: 1585:            else if (*rep_next == '\\')
branch  0 taken 1496 (fallthrough)
branch  1 taken 18118
        -: 1586:              {
     1496: 1587:            if (rep_next - rep_cur)
branch  0 taken 621 (fallthrough)
branch  1 taken 875
      621: 1588:              str_append (&tmp, rep_cur, rep_next - rep_cur);
call    0 returned 621
     1496: 1589:            rep_next++;
     1496: 1590:            if (rep_next != rep_end)
branch  0 taken 1496 (fallthrough)
branch  1 taken 0
        -: 1591:              {
        -: 1592:                int n;
        -: 1593:                
     1496: 1594:                if (*rep_next >= '0' && *rep_next <= '9')
branch  0 taken 2 (fallthrough)
branch  1 taken 1494
branch  2 taken 0 (fallthrough)
branch  3 taken 2
        -: 1595:                  {
    #####: 1596:                n = *rep_next - '0';
    #####: 1597:                str_append (&tmp, line.text + regs.start[n], regs.end[n] - regs.start[n]);
call    0 never executed
        -: 1598:                  }
        -: 1599:                else
     1496: 1600:                  str_append (&tmp, rep_next, 1);
call    0 returned 1496
        -: 1601:              }
     1496: 1602:            rep_cur = rep_next + 1;
        -: 1603:              }
        -: 1604:          }
     3588: 1605:        if (rep_next - rep_cur)
branch  0 taken 2141 (fallthrough)
branch  1 taken 1447
     2141: 1606:          str_append (&tmp, rep_cur, rep_next - rep_cur);
call    0 returned 2141
     3588: 1607:        if (offset == regs.end[0])
branch  0 taken 1360 (fallthrough)
branch  1 taken 2228
        -: 1608:          {
     1360: 1609:            str_append (&tmp, line.text + offset, 1);
call    0 returned 1360
     1360: 1610:            ++regs.end[0];
        -: 1611:          }
     3588: 1612:        start = regs.end[0];
        -: 1613:        
     3588: 1614:        remain = (line.length - trail_nl_p) - start;
     3588: 1615:        if (remain < 0)
branch  0 taken 876 (fallthrough)
branch  1 taken 2712
      876: 1616:          break;
     2712: 1617:        if (!(cur_cmd->x.cmd_regex.flags & S_GLOBAL_BIT))
branch  0 taken 138 (fallthrough)
branch  1 taken 2574
      138: 1618:          break;
        -: 1619:          }
    12566: 1620:        if (!count)
branch  0 taken 10080 (fallthrough)
branch  1 taken 2486
    10080: 1621:          break;
     2486: 1622:        replaced = 1;
     2486: 1623:        str_append (&tmp, line.text + start, remain + trail_nl_p);
call    0 returned 2486
     2486: 1624:        t.text = line.text;
     2486: 1625:        t.length = line.length;
     2486: 1626:        t.alloc = line.alloc;
     2486: 1627:        line.text = tmp.text;
     2486: 1628:        line.length = tmp.length;
     2486: 1629:        line.alloc = tmp.alloc;
     2486: 1630:        tmp.text = t.text;
     2486: 1631:        tmp.length = t.length;
     2486: 1632:        tmp.alloc = t.alloc;
     2486: 1633:        if ((cur_cmd->x.cmd_regex.flags & S_WRITE_BIT)
branch  0 taken 1436 (fallthrough)
branch  1 taken 1050
     1436: 1634:        && cur_cmd->x.cmd_regex.wio_file)
branch  0 taken 1436 (fallthrough)
branch  1 taken 0
     1436: 1635:          ck_fwrite (line.text, 1, line.length,
call    0 returned 1436
        -: 1636:             cur_cmd->x.cmd_regex.wio_file);
     2486: 1637:        if (cur_cmd->x.cmd_regex.flags & S_PRINT_BIT)
branch  0 taken 1287 (fallthrough)
branch  1 taken 1199
     1287: 1638:          ck_fwrite (line.text, 1, line.length, stdout);
call    0 returned 1287
     2486: 1639:        break;
        -: 1640:      }
        -: 1641:        
       13: 1642:    case 't':
       13: 1643:      if (replaced)
branch  0 taken 6 (fallthrough)
branch  1 taken 7
        -: 1644:        {
        6: 1645:          replaced = 0;
        6: 1646:          if (!cur_cmd->x.jump)
branch  0 taken 5 (fallthrough)
branch  1 taken 1
        5: 1647:        end_cycle++;
        -: 1648:          else
        -: 1649:        {
        1: 1650:          struct sed_label *j = cur_cmd->x.jump;
        -: 1651:
        1: 1652:          n = j->v->v_length - j->v_index;
        1: 1653:          cur_cmd = j->v->v + j->v_index;
        1: 1654:          goto exe_loop;
        -: 1655:        }
        -: 1656:        }
       12: 1657:      break;
        -: 1658:
     1689: 1659:    case 'w':
     1689: 1660:      if (cur_cmd->x.io_file)
branch  0 taken 1689 (fallthrough)
branch  1 taken 0
     1689: 1661:        ck_fwrite (line.text, 1, line.length, cur_cmd->x.io_file);
call    0 returned 1689
     1689: 1662:      break;
        -: 1663:
        5: 1664:    case 'x':
        -: 1665:      {
        -: 1666:        struct line tmp;
        -: 1667:
        5: 1668:        tmp = line;
        5: 1669:        line = hold;
        5: 1670:        hold = tmp;
        -: 1671:      }
        5: 1672:      break;
        -: 1673:
     2018: 1674:    case 'y':
        -: 1675:      {
        -: 1676:        unsigned char *p, *e;
        -: 1677:
    41277: 1678:        for (p = (unsigned char *) (line.text), e = p + line.length; p < e; p++)
branch  0 taken 39259
branch  1 taken 2018 (fallthrough)
    39259: 1679:          *p = cur_cmd->x.translate[*p];
        -: 1680:      }
     2018: 1681:      break;
        -: 1682:
    #####: 1683:    default:
    #####: 1684:      panic ("INTERNAL ERROR: Bad cmd %c", cur_cmd->cmd);
call    0 never executed
        -: 1685:    }
    35504: 1686:      if (end_cycle)
branch  0 taken 5171 (fallthrough)
branch  1 taken 30333
     5171: 1687:    break;
        -: 1688:    }
    31630: 1689:}
        -: 1690:
        -: 1691:
        -: 1692:/* Return non-zero if the current line matches the address
        -: 1693:   pointed to by 'addr'. */
        -: 1694:int
function match_address called 70815 returned 100% blocks executed 70%
    70815: 1695:match_address (addr)
        -: 1696:     struct addr *addr;
        -: 1697:{
    70815: 1698:  switch (addr->addr_type)
branch  0 taken 34868
branch  1 taken 3408
branch  2 taken 31802
branch  3 taken 737
branch  4 taken 0
        -: 1699:    {
    34868: 1700:    case addr_is_null:
    34868: 1701:      return 1;
     3408: 1702:    case addr_is_num:
     3408: 1703:      return (input_line_number == addr->addr_number);
        -: 1704:
    31802: 1705:    case addr_is_regex:
        -: 1706:      {
    31802: 1707:    int trail_nl_p = line.text [line.length - 1] == '\n';
    31802: 1708:    return (re_search (addr->addr_regex,
    31802: 1709:               line.text,
    31802: 1710:               line.length - trail_nl_p,
        -: 1711:               0,
    31802: 1712:               line.length - trail_nl_p,
call    0 returned 31802
    31802: 1713:               (struct re_registers *) 0) >= 0) ? 1 : 0;
        -: 1714:      }
      737: 1715:    case addr_is_last:
      737: 1716:      return (input_EOF) ? 1 : 0;
        -: 1717:
    #####: 1718:    default:
    #####: 1719:      panic ("INTERNAL ERROR: bad address type");
call    0 never executed
    #####: 1720:      break;
        -: 1721:    }
    #####: 1722:  return -1;
        -: 1723:}
        -: 1724:
        -: 1725:/* Read in the next line of input, and store it in the
        -: 1726:   pattern space.  Return non-zero if this is the last line of input */
        -: 1727:
        -: 1728:int
function read_pattern_space called 34836 returned 100% blocks executed 96%
    34836: 1729:read_pattern_space ()
        -: 1730:{
        -: 1731:  int n;
        -: 1732:  char *p;
        -: 1733:  int ch;
        -: 1734:
    34836: 1735:  p = line.text;
    34836: 1736:  n = line.alloc;
        -: 1737:
    34836: 1738:  if (feof (input_file))
call    0 returned 34836
branch  1 taken 306 (fallthrough)
branch  2 taken 34530
      306: 1739:    return 0;
    34530: 1740:  input_line_number++;
    34530: 1741:  replaced = 0;
        -: 1742:  for (;;)
        -: 1743:    {
   549729: 1744:      if (n == 0)
branch  0 taken 253 (fallthrough)
branch  1 taken 549476
        -: 1745:    {
      253: 1746:      line.text = ck_realloc (line.text, line.alloc * 2);
call    0 returned 253
      253: 1747:      p = line.text + line.alloc;
      253: 1748:      n = line.alloc;
      253: 1749:      line.alloc *= 2;
        -: 1750:    }
   549729: 1751:      ch = getc (input_file);
call    0 returned 549729
   549729: 1752:      if (ch == EOF)
branch  0 taken 2 (fallthrough)
branch  1 taken 549727
        -: 1753:    {
        2: 1754:      if (n == line.alloc)
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####: 1755:        return 0;
        -: 1756:      /* *p++ = '\n'; */
        -: 1757:      /* --n; */
        2: 1758:      line.length = line.alloc - n;
        2: 1759:      if (last_input_file)
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2: 1760:        input_EOF++;
        2: 1761:      return 1;
        -: 1762:    }
   549727: 1763:      *p++ = ch;
   549727: 1764:      --n;
   549727: 1765:      if (ch == '\n')
branch  0 taken 34528 (fallthrough)
branch  1 taken 515199
        -: 1766:    {
    34528: 1767:      line.length = line.alloc - n;
    34528: 1768:      break;
        -: 1769:    }
        -: 1770:    }
    34528: 1771:  ch = getc (input_file);
call    0 returned 34528
    34528: 1772:  if (ch != EOF)
branch  0 taken 34239 (fallthrough)
branch  1 taken 289
    34239: 1773:    ungetc (ch, input_file);
call    0 returned 34239
      289: 1774:  else if (last_input_file)
branch  0 taken 288 (fallthrough)
branch  1 taken 1
      288: 1775:    input_EOF++;
    34528: 1776:  return 1;
        -: 1777:}
        -: 1778:
        -: 1779:/* Inplement the 'N' command, which appends the next line of input to
        -: 1780:   the pattern space. */
        -: 1781:void
function append_pattern_space called 2944 returned 100% blocks executed 75%
     2944: 1782:append_pattern_space ()
        -: 1783:{
        -: 1784:  char *p;
        -: 1785:  int n;
        -: 1786:  int ch;
        -: 1787:
     2944: 1788:  p = line.text + line.length;
     2944: 1789:  n = line.alloc - line.length;
        -: 1790:
     2944: 1791:  input_line_number++;
     2944: 1792:  replaced = 0;
        -: 1793:  for (;;)
        -: 1794:    {
    45938: 1795:      ch = getc (input_file);
call    0 returned 45938
    45938: 1796:      if (ch == EOF)
branch  0 taken 0 (fallthrough)
branch  1 taken 45938
        -: 1797:    {
    #####: 1798:      if (n == line.alloc)
branch  0 never executed
branch  1 never executed
    #####: 1799:        return;
        -: 1800:      /* *p++ = '\n'; */
        -: 1801:      /* --n; */
    #####: 1802:      line.length = line.alloc - n;
    #####: 1803:      if (last_input_file)
branch  0 never executed
branch  1 never executed
    #####: 1804:        input_EOF++;
    #####: 1805:      return;
        -: 1806:    }
    45938: 1807:      if (n == 0)
branch  0 taken 123 (fallthrough)
branch  1 taken 45815
        -: 1808:    {
      123: 1809:      line.text = ck_realloc (line.text, line.alloc * 2);
call    0 returned 123
      123: 1810:      p = line.text + line.alloc;
      123: 1811:      n = line.alloc;
      123: 1812:      line.alloc *= 2;
        -: 1813:    }
    45938: 1814:      *p++ = ch;
    45938: 1815:      --n;
    45938: 1816:      if (ch == '\n')
branch  0 taken 2944 (fallthrough)
branch  1 taken 42994
        -: 1817:    {
     2944: 1818:      line.length = line.alloc - n;
     2944: 1819:      break;
        -: 1820:    }
        -: 1821:    }
     2944: 1822:  ch = getc (input_file);
call    0 returned 2944
     2944: 1823:  if (ch != EOF)
branch  0 taken 2911 (fallthrough)
branch  1 taken 33
     2911: 1824:    ungetc (ch, input_file);
call    0 returned 2911
       33: 1825:  else if (last_input_file)
branch  0 taken 33 (fallthrough)
branch  1 taken 0
       33: 1826:    input_EOF++;
        -: 1827:}
        -: 1828:
        -: 1829:/* Copy the contents of the line 'from' into the line 'to'.
        -: 1830:   This destroys the old contents of 'to'.  It will still work
        -: 1831:   if the line 'from' contains nulls. */
        -: 1832:void
function line_copy called 28 returned 100% blocks executed 100%
       28: 1833:line_copy (from, to)
        -: 1834:     struct line *from, *to;
        -: 1835:{
       28: 1836:  if (from->length > to->alloc)
branch  0 taken 1 (fallthrough)
branch  1 taken 27
        -: 1837:    {
        1: 1838:      to->alloc = from->length;
        1: 1839:      to->text = ck_realloc (to->text, to->alloc);
call    0 returned 1
        -: 1840:    }
       28: 1841:  bcopy (from->text, to->text, from->length);
       28: 1842:  to->length = from->length;
       28: 1843:}
        -: 1844:
        -: 1845:/* Append the contents of the line 'from' to the line 'to'.
        -: 1846:   This routine will work even if the line 'from' contains nulls */
        -: 1847:void
function line_append called 22 returned 100% blocks executed 100%
       22: 1848:line_append (from, to)
        -: 1849:     struct line *from, *to;
        -: 1850:{
       22: 1851:  if (from->length > (to->alloc - to->length))
branch  0 taken 6 (fallthrough)
branch  1 taken 16
        -: 1852:    {
        6: 1853:      to->alloc += from->length;
        6: 1854:      to->text = ck_realloc (to->text, to->alloc);
call    0 returned 6
        -: 1855:    }
       22: 1856:  bcopy (from->text, to->text + to->length, from->length);
       22: 1857:  to->length += from->length;
       22: 1858:}
        -: 1859:
        -: 1860:/* Append 'length' bytes from 'string' to the line 'to'
        -: 1861:   This routine *will* append bytes with nulls in them, without
        -: 1862:   failing. */
        -: 1863:void
function str_append called 9085 returned 100% blocks executed 100%
     9085: 1864:str_append (to, string, length)
        -: 1865:     struct line *to;
        -: 1866:     char *string;
        -: 1867:     int length;
        -: 1868:{
     9085: 1869:  if (length > to->alloc - to->length)
branch  0 taken 34 (fallthrough)
branch  1 taken 9051
        -: 1870:    {
       34: 1871:      to->alloc += length;
       34: 1872:      to->text = ck_realloc (to->text, to->alloc);
call    0 returned 34
        -: 1873:    }
     9085: 1874:  bcopy (string, to->text + to->length, length);
     9085: 1875:  to->length += length;
     9085: 1876:}
        -: 1877:
        -: 1878:void
function usage called 7 returned 0% blocks executed 100%
        7: 1879:usage (status)
        -: 1880:     int status;
        -: 1881:{
        7: 1882:  fprintf (status ? stderr : stdout, "\
call    0 returned 7
        -: 1883:Usage: %s [-nV] [--quiet] [--silent] [--version] [-e script]\n\
        -: 1884:        [-f script-file] [--expression=script] [--file=script-file] [file...]\n",
        -: 1885:       myname); 
        7: 1886:  exit (status);
        -: 1887:}
        -: 1888:/*  Functions from hack's utils library.
        -: 1889:    Copyright (C) 1989, 1990, 1991 Free Software Foundation, Inc.
        -: 1890:
        -: 1891:    This program is free software; you can redistribute it and/or modify
        -: 1892:    it under the terms of the GNU General Public License as published by
        -: 1893:    the Free Software Foundation; either version 2, or (at your option)
        -: 1894:    any later version.
        -: 1895:
        -: 1896:    This program is distributed in the hope that it will be useful,
        -: 1897:    but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 1898:    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 1899:    GNU General Public License for more details.
        -: 1900:
        -: 1901:    You should have received a copy of the GNU General Public License
        -: 1902:    along with this program; if not, write to the Free Software
        -: 1903:    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
        -: 1904:
        -: 1905:/* These routines were written as part of a library (by hack), but since most
        -: 1906:   people don't have the library, here they are.  */
        -: 1907:
        -: 1908:#ifdef __STDC__
        -: 1909:#define VOID void
        -: 1910:#else
        -: 1911:#define VOID char
        -: 1912:#endif
        -: 1913:
        -: 1914:#include <stdio.h>
        -: 1915:#if HAVE_STRING_H || defined(STDC_HEADERS)
        -: 1916:#include <string.h>
        -: 1917:#else
        -: 1918:#include <strings.h>
        -: 1919:#endif
        -: 1920:#if defined(STDC_HEADERS)
        -: 1921:#include <stdlib.h>
        -: 1922:#else
        -: 1923:VOID *malloc();
        -: 1924:VOID *realloc();
        -: 1925:#endif
        -: 1926:
        -: 1927:VOID *ck_malloc();
        -: 1928:
        -: 1929:char *myname;
        -: 1930:
        -: 1931:#ifdef __STDC__
        -: 1932:#include <stdarg.h>
        -: 1933:
        -: 1934:/* Print an error message and exit */
        -: 1935:void
function panic called 2 returned 0% blocks executed 100%
        2: 1936:panic(char *str, ...)
        -: 1937:{
        -: 1938:	va_list iggy;
        -: 1939:
        2: 1940:	fprintf(stderr,"%s: ",myname);
call    0 returned 2
        2: 1941:	va_start(iggy,str);
        -: 1942:#ifdef HAVE_VPRINTF
        2: 1943:	vfprintf(stderr,str,iggy);
call    0 returned 2
        -: 1944:#else
        -: 1945:#ifdef HAVE_DOPRNT
        -: 1946:	_doprnt(str,&iggy,stderr);
        -: 1947:#endif
        -: 1948:#endif
        2: 1949:	va_end(iggy);
        2: 1950:	putc('\n',stderr);
call    0 returned 2
        2: 1951:	exit(4);
        -: 1952:}
        -: 1953:
        -: 1954:#else
        -: 1955:#include <varargs.h>
        -: 1956:
        -: 1957:void
        -: 1958:panic(str,va_alist)
        -: 1959:char *str;
        -: 1960:va_dcl
        -: 1961:{
        -: 1962:	va_list iggy;
        -: 1963:
        -: 1964:	fprintf(stderr,"%s: ",myname);
        -: 1965:	va_start(iggy);
        -: 1966:#ifdef HAVE_VPRINTF
        -: 1967:	vfprintf(stderr,str,iggy);
        -: 1968:#else
        -: 1969:#ifdef HAVE_DOPRNT
        -: 1970:	_doprnt(str,&iggy,stderr);
        -: 1971:#endif
        -: 1972:#endif
        -: 1973:	va_end(iggy);
        -: 1974:	putc('\n',stderr);
        -: 1975:	exit(4);
        -: 1976:}
        -: 1977:
        -: 1978:#endif
        -: 1979:
        -: 1980:/* Store information about files opened with ck_fopen
        -: 1981:   so that error messages from ck_fread, etc can print the
        -: 1982:   name of the file that had the error */
        -: 1983:#define N_FILE 32
        -: 1984:
        -: 1985:struct id {
        -: 1986:	FILE *fp;
        -: 1987:	char *name;
        -: 1988:};
        -: 1989:
        -: 1990:static struct id __id_s[N_FILE];
        -: 1991:
        -: 1992:/* Internal routine to get a filename from __id_s */
        -: 1993:char *
function __fp_name called 0 returned 0% blocks executed 0%
    #####: 1994:__fp_name(fp)
        -: 1995:FILE *fp;
        -: 1996:{
        -: 1997:	int n;
        -: 1998:
    #####: 1999:	for(n=0;n<N_FILE;n++) {
branch  0 never executed
branch  1 never executed
    #####: 2000:		if(__id_s[n].fp==fp)
branch  0 never executed
branch  1 never executed
    #####: 2001:			return __id_s[n].name;
        -: 2002:	}
    #####: 2003:	return "{Unknown file pointer}";
        -: 2004:}
        -: 2005:
        -: 2006:/* Panic on failing fopen */
        -: 2007:FILE *
function ck_fopen called 569 returned 100% blocks executed 86%
      569: 2008:ck_fopen(name,mode)
        -: 2009:char *name;
        -: 2010:char *mode;
        -: 2011:{
        -: 2012:	FILE	*ret;
        -: 2013:	int	n;
        -: 2014:
      569: 2015:	ret=fopen(name,mode);
call    0 returned 569
      569: 2016:	if(ret==(FILE *)0)
branch  0 taken 2 (fallthrough)
branch  1 taken 567
        2: 2017:		panic("Couldn't open file %s",name);
call    0 returned 0
    18711: 2018:	for(n=0;n<N_FILE;n++) {
branch  0 taken 18144
branch  1 taken 567 (fallthrough)
    18144: 2019:		if(ret==__id_s[n].fp) {
branch  0 taken 0 (fallthrough)
branch  1 taken 18144
    #####: 2020:			free((VOID *)__id_s[n].name);
    #####: 2021:			__id_s[n].name=(char *)ck_malloc(strlen(name)+1);
call    0 never executed
    #####: 2022:			strcpy(__id_s[n].name,name);
    #####: 2023:			break;
        -: 2024:		}
        -: 2025:	}
      567: 2026:	if(n==N_FILE) {
branch  0 taken 567 (fallthrough)
branch  1 taken 0
      854: 2027:		for(n=0;n<N_FILE;n++)
branch  0 taken 854
branch  1 taken 0 (fallthrough)
      854: 2028:			if(__id_s[n].fp==(FILE *)0)
branch  0 taken 567 (fallthrough)
branch  1 taken 287
      567: 2029:				break;
      567: 2030:		if(n==N_FILE)
branch  0 taken 0 (fallthrough)
branch  1 taken 567
    #####: 2031:			panic("Internal error: too many files open");
call    0 never executed
      567: 2032:		__id_s[n].fp=ret;
      567: 2033:		__id_s[n].name=(char *)ck_malloc(strlen(name)+1);
call    0 returned 567
      567: 2034:		strcpy(__id_s[n].name,name);
        -: 2035:	}
      567: 2036:	return ret;
        -: 2037:}
        -: 2038:
        -: 2039:/* Panic on failing fwrite */
        -: 2040:void
function ck_fwrite called 25056 returned 100% blocks executed 60%
    25056: 2041:ck_fwrite(ptr,size,nmemb,stream)
        -: 2042:char *ptr;
        -: 2043:int size,nmemb;
        -: 2044:FILE *stream;
        -: 2045:{
    25056: 2046:	if(fwrite(ptr,size,nmemb,stream)!=nmemb)
call    0 returned 25056
branch  1 taken 0 (fallthrough)
branch  2 taken 25056
    #####: 2047:		panic("couldn't write %d items to %s",nmemb,__fp_name(stream));
call    0 never executed
call    1 never executed
    25056: 2048:}
        -: 2049:
        -: 2050:/* Panic on failing fclose */
        -: 2051:void
function ck_fclose called 353 returned 100% blocks executed 60%
      353: 2052:ck_fclose(stream)
        -: 2053:FILE *stream;
        -: 2054:{
      353: 2055:	if(fclose(stream)==EOF)
call    0 returned 353
branch  1 taken 0 (fallthrough)
branch  2 taken 353
    #####: 2056:		panic("Couldn't close %s",__fp_name(stream));
call    0 never executed
call    1 never executed
      353: 2057:}
        -: 2058:
        -: 2059:/* Panic on failing malloc */
        -: 2060:VOID *
function ck_malloc called 8144 returned 100% blocks executed 83%
     8144: 2061:ck_malloc(size)
        -: 2062:int size;
        -: 2063:{
        -: 2064:	VOID *ret;
        -: 2065:
     8144: 2066:	if(!size)
branch  0 taken 4 (fallthrough)
branch  1 taken 8140
        4: 2067:		size++;
     8144: 2068:	ret=malloc(size);
     8144: 2069:	if(ret==(VOID *)0)
branch  0 taken 0 (fallthrough)
branch  1 taken 8144
    #####: 2070:		panic("Couldn't allocate memory");
call    0 never executed
     8144: 2071:	return ret;
        -: 2072:}
        -: 2073:
        -: 2074:/* Panic on failing malloc */
        -: 2075:VOID *
function xmalloc called 0 returned 0% blocks executed 0%
    #####: 2076:xmalloc(size)
        -: 2077:int size;
        -: 2078:{
    #####: 2079:  return ck_malloc (size);
call    0 never executed
        -: 2080:}
        -: 2081:
        -: 2082:/* Panic on failing realloc */
        -: 2083:VOID *
function ck_realloc called 453 returned 100% blocks executed 75%
      453: 2084:ck_realloc(ptr,size)
        -: 2085:VOID *ptr;
        -: 2086:int size;
        -: 2087:{
        -: 2088:	VOID *ret;
        -: 2089:
      453: 2090:	ret=realloc(ptr,size);
      453: 2091:	if(ret==(VOID *)0)
branch  0 taken 0 (fallthrough)
branch  1 taken 453
    #####: 2092:		panic("Couldn't re-allocate memory");
call    0 never executed
      453: 2093:	return ret;
        -: 2094:}
        -: 2095:
        -: 2096:/* Return a malloc()'d copy of a string */
        -: 2097:char *
function ck_strdup called 243 returned 100% blocks executed 100%
      243: 2098:ck_strdup(str)
        -: 2099:char *str;
        -: 2100:{
        -: 2101:	char *ret;
        -: 2102:
      243: 2103:	ret=(char *)ck_malloc(strlen(str)+2);
call    0 returned 243
      243: 2104:	strcpy(ret,str);
      243: 2105:	return ret;
        -: 2106:}
        -: 2107:
        -: 2108:
        -: 2109:/* Implement a variable sized buffer of 'stuff'.  We don't know what it is,
        -: 2110:   nor do we care, as long as it doesn't mind being aligned by malloc. */
        -: 2111:
        -: 2112:struct buffer {
        -: 2113:	int	allocated;
        -: 2114:	int	length;
        -: 2115:	char	*b;
        -: 2116:};
        -: 2117:
        -: 2118:#define MIN_ALLOCATE 50
        -: 2119:
        -: 2120:VOID *
function init_buffer called 1247 returned 100% blocks executed 100%
     1247: 2121:init_buffer()
        -: 2122:{
        -: 2123:	struct buffer *b;
        -: 2124:
     1247: 2125:	b=(struct buffer *)ck_malloc(sizeof(struct buffer));
call    0 returned 1247
     1247: 2126:	b->allocated=MIN_ALLOCATE;
     1247: 2127:	b->b=(char *)ck_malloc(MIN_ALLOCATE);
call    0 returned 1247
     1247: 2128:	b->length=0;
     1247: 2129:	return (VOID *)b;
        -: 2130:}
        -: 2131:
        -: 2132:void
function flush_buffer called 1247 returned 100% blocks executed 100%
     1247: 2133:flush_buffer(bb)
        -: 2134:VOID *bb;
        -: 2135:{
        -: 2136:	struct buffer *b;
        -: 2137:
     1247: 2138:	b=(struct buffer *)bb;
     1247: 2139:	free(b->b);
     1247: 2140:	b->b=0;
     1247: 2141:	b->allocated=0;
     1247: 2142:	b->length=0;
     1247: 2143:	free(b);
     1247: 2144:}
        -: 2145:
        -: 2146:int
function size_buffer called 2373 returned 100% blocks executed 100%
     2373: 2147:size_buffer(b)
        -: 2148:VOID *b;
        -: 2149:{
        -: 2150:	struct buffer *bb;
        -: 2151:
     2373: 2152:	bb=(struct buffer *)b;
     2373: 2153:	return bb->length;
        -: 2154:}
        -: 2155:
        -: 2156:void
function add_buffer called 0 returned 0% blocks executed 0%
    #####: 2157:add_buffer(bb,p,n)
        -: 2158:VOID *bb;
        -: 2159:char *p;
        -: 2160:int n;
        -: 2161:{
        -: 2162:	struct buffer *b;
        -: 2163:	int x;
        -: 2164:	char * cp;
        -: 2165:
    #####: 2166:	b=(struct buffer *)bb;
    #####: 2167:	if(b->length+n>b->allocated) {
branch  0 never executed
branch  1 never executed
    #####: 2168:		b->allocated*=2;
    #####: 2169:		b->b=(char *)ck_realloc(b->b,b->allocated);
call    0 never executed
        -: 2170:	}
        -: 2171:	
    #####: 2172:	x = n;
    #####: 2173:	cp = b->b + b->length;
    #####: 2174:	while (x--)
branch  0 never executed
branch  1 never executed
    #####: 2175:	  *cp++ = *p++;
    #####: 2176:	b->length+=n;
    #####: 2177:}
        -: 2178:
        -: 2179:void
function add1_buffer called 10870 returned 100% blocks executed 50%
    10870: 2180:add1_buffer(bb,ch)
        -: 2181:VOID *bb;
        -: 2182:int ch;
        -: 2183:{
        -: 2184:	struct buffer *b;
        -: 2185:
    10870: 2186:	b=(struct buffer *)bb;
    10870: 2187:	if(b->length+1>b->allocated) {
branch  0 taken 0 (fallthrough)
branch  1 taken 10870
    #####: 2188:		b->allocated*=2;
    #####: 2189:		b->b=(char *)ck_realloc(b->b,b->allocated);
call    0 never executed
        -: 2190:	}
    10870: 2191:	b->b[b->length]=ch;
    10870: 2192:	b->length++;
    10870: 2193:}
        -: 2194:
        -: 2195:char *
function get_buffer called 1234 returned 100% blocks executed 100%
     1234: 2196:get_buffer(bb)
        -: 2197:VOID *bb;
        -: 2198:{
        -: 2199:	struct buffer *b;
        -: 2200:
     1234: 2201:	b=(struct buffer *)bb;
     1234: 2202:	return b->b;
        -: 2203:}
        -: 2204:/* Extended regular expression matching and search library,
        -: 2205:   version 0.12.
        -: 2206:   (Implements POSIX draft P10003.2/D11.2, except for
        -: 2207:   internationalization features.)
        -: 2208:
        -: 2209:   Copyright (C) 1993 Free Software Foundation, Inc.
        -: 2210:
        -: 2211:   This program is free software; you can redistribute it and/or modify
        -: 2212:   it under the terms of the GNU General Public License as published by
        -: 2213:   the Free Software Foundation; either version 2, or (at your option)
        -: 2214:   any later version.
        -: 2215:
        -: 2216:   This program is distributed in the hope that it will be useful,
        -: 2217:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 2218:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 2219:   GNU General Public License for more details.
        -: 2220:
        -: 2221:   You should have received a copy of the GNU General Public License
        -: 2222:   along with this program; if not, write to the Free Software
        -: 2223:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
        -: 2224:
        -: 2225:/* AIX requires this to be the first thing in the file. */
        -: 2226:#if defined (_AIX) && !defined (REGEX_MALLOC)
        -: 2227:  #pragma alloca
        -: 2228:#endif
        -: 2229:
        -: 2230:#define _GNU_SOURCE
        -: 2231:
        -: 2232:/* We need this for `regex.h', and perhaps for the Emacs include files.  */
        -: 2233:#include <sys/types.h>
        -: 2234:
        -: 2235:#ifdef HAVE_CONFIG_H
        -: 2236:#include "config.h"
        -: 2237:#endif
        -: 2238:
        -: 2239:/* The `emacs' switch turns on certain matching commands
        -: 2240:   that make sense only in Emacs. */
        -: 2241:#ifdef emacs
        -: 2242:
        -: 2243:#include "lisp.h"
        -: 2244:#include "buffer.h"
        -: 2245:#include "syntax.h"
        -: 2246:
        -: 2247:/* Emacs uses `NULL' as a predicate.  */
        -: 2248:#undef NULL
        -: 2249:
        -: 2250:#else  /* not emacs */
        -: 2251:
        -: 2252:/* We used to test for `BSTRING' here, but only GCC and Emacs define
        -: 2253:   `BSTRING', as far as I know, and neither of them use this code.  */
        -: 2254:#if HAVE_STRING_H || STDC_HEADERS
        -: 2255:#include <string.h>
        -: 2256:#ifndef bcmp
        -: 2257:#define bcmp(s1, s2, n)	memcmp ((s1), (s2), (n))
        -: 2258:#endif
        -: 2259:#ifndef bcopy
        -: 2260:#define bcopy(s, d, n)	memcpy ((d), (s), (n))
        -: 2261:#endif
        -: 2262:#ifndef bzero
        -: 2263:#define bzero(s, n)	memset ((s), 0, (n))
        -: 2264:#endif
        -: 2265:#else
        -: 2266:#include <strings.h>
        -: 2267:#endif
        -: 2268:
        -: 2269:#ifdef STDC_HEADERS
        -: 2270:#include <stdlib.h>
        -: 2271:#else
        -: 2272:char *malloc ();
        -: 2273:char *realloc ();
        -: 2274:#endif
        -: 2275:
        -: 2276:/* Define the syntax stuff for \<, \>, etc.  */
        -: 2277:
        -: 2278:/* This must be nonzero for the wordchar and notwordchar pattern
        -: 2279:   commands in re_match_2.  */
        -: 2280:#ifndef Sword 
        -: 2281:#define Sword 1
        -: 2282:#endif
        -: 2283:
        -: 2284:#ifdef SYNTAX_TABLE
        -: 2285:
        -: 2286:extern char *re_syntax_table;
        -: 2287:
        -: 2288:#else /* not SYNTAX_TABLE */
        -: 2289:
        -: 2290:/* How many characters in the character set.  */
        -: 2291:#define CHAR_SET_SIZE 256
        -: 2292:
        -: 2293:static char re_syntax_table[CHAR_SET_SIZE];
        -: 2294:
        -: 2295:static void
function init_syntax_once called 603 returned 100% blocks executed 100%
      603: 2296:init_syntax_once ()
        -: 2297:{
        -: 2298:   register int c;
        -: 2299:   static int done = 0;
        -: 2300:
      603: 2301:   if (done)
branch  0 taken 298 (fallthrough)
branch  1 taken 305
      298: 2302:     return;
        -: 2303:
      305: 2304:   bzero (re_syntax_table, sizeof re_syntax_table);
        -: 2305:
     8235: 2306:   for (c = 'a'; c <= 'z'; c++)
branch  0 taken 7930
branch  1 taken 305 (fallthrough)
     7930: 2307:     re_syntax_table[c] = Sword;
        -: 2308:
     8235: 2309:   for (c = 'A'; c <= 'Z'; c++)
branch  0 taken 7930
branch  1 taken 305 (fallthrough)
     7930: 2310:     re_syntax_table[c] = Sword;
        -: 2311:
     3355: 2312:   for (c = '0'; c <= '9'; c++)
branch  0 taken 3050
branch  1 taken 305 (fallthrough)
     3050: 2313:     re_syntax_table[c] = Sword;
        -: 2314:
      305: 2315:   re_syntax_table['_'] = Sword;
        -: 2316:
      305: 2317:   done = 1;
        -: 2318:}
        -: 2319:
        -: 2320:#endif /* not SYNTAX_TABLE */
        -: 2321:
        -: 2322:#define SYNTAX(c) re_syntax_table[c]
        -: 2323:
        -: 2324:#endif /* not emacs */
        -: 2325:
        -: 2326:/* Get the interface, including the syntax bits.  */
        -: 2327:#include "regex.h"
        -: 2328:
        -: 2329:/* isalpha etc. are used for the character classes.  */
        -: 2330:#include <ctype.h>
        -: 2331:
        -: 2332:#ifndef isascii
        -: 2333:#define isascii(c) 1
        -: 2334:#endif
        -: 2335:
        -: 2336:#ifdef isblank
        -: 2337:#define ISBLANK(c) (isascii (c) && isblank (c))
        -: 2338:#else
        -: 2339:#define ISBLANK(c) ((c) == ' ' || (c) == '\t')
        -: 2340:#endif
        -: 2341:#ifdef isgraph
        -: 2342:#define ISGRAPH(c) (isascii (c) && isgraph (c))
        -: 2343:#else
        -: 2344:#define ISGRAPH(c) (isascii (c) && isprint (c) && !isspace (c))
        -: 2345:#endif
        -: 2346:
        -: 2347:#define ISPRINT(c) (isascii (c) && isprint (c))
        -: 2348:#define ISDIGIT(c) (isascii (c) && isdigit (c))
        -: 2349:#define ISALNUM(c) (isascii (c) && isalnum (c))
        -: 2350:#define ISALPHA(c) (isascii (c) && isalpha (c))
        -: 2351:#define ISCNTRL(c) (isascii (c) && iscntrl (c))
        -: 2352:#define ISLOWER(c) (isascii (c) && islower (c))
        -: 2353:#define ISPUNCT(c) (isascii (c) && ispunct (c))
        -: 2354:#define ISSPACE(c) (isascii (c) && isspace (c))
        -: 2355:#define ISUPPER(c) (isascii (c) && isupper (c))
        -: 2356:#define ISXDIGIT(c) (isascii (c) && isxdigit (c))
        -: 2357:
        -: 2358:#ifndef NULL
        -: 2359:#define NULL 0
        -: 2360:#endif
        -: 2361:
        -: 2362:/* We remove any previous definition of `SIGN_EXTEND_CHAR',
        -: 2363:   since ours (we hope) works properly with all combinations of
        -: 2364:   machines, compilers, `char' and `unsigned char' argument types.
        -: 2365:   (Per Bothner suggested the basic approach.)  */
        -: 2366:#undef SIGN_EXTEND_CHAR
        -: 2367:#if __STDC__
        -: 2368:#define SIGN_EXTEND_CHAR(c) ((signed char) (c))
        -: 2369:#else  /* not __STDC__ */
        -: 2370:/* As in Harbison and Steele.  */
        -: 2371:#define SIGN_EXTEND_CHAR(c) ((((unsigned char) (c)) ^ 128) - 128)
        -: 2372:#endif
        -: 2373:
        -: 2374:/* Should we use malloc or alloca?  If REGEX_MALLOC is not defined, we
        -: 2375:   use `alloca' instead of `malloc'.  This is because using malloc in
        -: 2376:   re_search* or re_match* could cause memory leaks when C-g is used in
        -: 2377:   Emacs; also, malloc is slower and causes storage fragmentation.  On
        -: 2378:   the other hand, malloc is more portable, and easier to debug.  
        -: 2379:   
        -: 2380:   Because we sometimes use alloca, some routines have to be macros,
        -: 2381:   not functions -- `alloca'-allocated space disappears at the end of the
        -: 2382:   function it is called in.  */
        -: 2383:
        -: 2384:#ifdef REGEX_MALLOC
        -: 2385:
        -: 2386:#define REGEX_ALLOCATE malloc
        -: 2387:#define REGEX_REALLOCATE(source, osize, nsize) realloc (source, nsize)
        -: 2388:
        -: 2389:#else /* not REGEX_MALLOC  */
        -: 2390:
        -: 2391:/* Emacs already defines alloca, sometimes.  */
        -: 2392:#ifndef alloca
        -: 2393:
        -: 2394:/* Make alloca work the best possible way.  */
        -: 2395:#ifdef __GNUC__
        -: 2396:#define alloca __builtin_alloca
        -: 2397:#else /* not __GNUC__ */
        -: 2398:#if HAVE_ALLOCA_H
        -: 2399:#include <alloca.h>
        -: 2400:#else /* not __GNUC__ or HAVE_ALLOCA_H */
        -: 2401:#ifndef _AIX /* Already did AIX, up at the top.  */
        -: 2402:char *alloca ();
        -: 2403:#endif /* not _AIX */
        -: 2404:#endif /* not HAVE_ALLOCA_H */ 
        -: 2405:#endif /* not __GNUC__ */
        -: 2406:
        -: 2407:#endif /* not alloca */
        -: 2408:
        -: 2409:#define REGEX_ALLOCATE alloca
        -: 2410:
        -: 2411:/* Assumes a `char *destination' variable.  */
        -: 2412:#define REGEX_REALLOCATE(source, osize, nsize)				\
        -: 2413:  (destination = (char *) alloca (nsize),				\
        -: 2414:   bcopy (source, destination, osize),					\
        -: 2415:   destination)
        -: 2416:
        -: 2417:#endif /* not REGEX_MALLOC */
        -: 2418:
        -: 2419:
        -: 2420:/* True if `size1' is non-NULL and PTR is pointing anywhere inside
        -: 2421:   `string1' or just past its end.  This works if PTR is NULL, which is
        -: 2422:   a good thing.  */
        -: 2423:#define FIRST_STRING_P(ptr) 					\
        -: 2424:  (size1 && string1 <= (ptr) && (ptr) <= string1 + size1)
        -: 2425:
        -: 2426:/* (Re)Allocate N items of type T using malloc, or fail.  */
        -: 2427:#define TALLOC(n, t) ((t *) malloc ((n) * sizeof (t)))
        -: 2428:#define RETALLOC(addr, n, t) ((addr) = (t *) realloc (addr, (n) * sizeof (t)))
        -: 2429:#define REGEX_TALLOC(n, t) ((t *) REGEX_ALLOCATE ((n) * sizeof (t)))
        -: 2430:
        -: 2431:#define BYTEWIDTH 8 /* In bits.  */
        -: 2432:
        -: 2433:#define STREQ(s1, s2) ((strcmp (s1, s2) == 0))
        -: 2434:
        -: 2435:#define MAX(a, b) ((a) > (b) ? (a) : (b))
        -: 2436:#define MIN(a, b) ((a) < (b) ? (a) : (b))
        -: 2437:
        -: 2438:typedef char boolean;
        -: 2439:#define false 0
        -: 2440:#define true 1
        -: 2441:
        -: 2442:/* These are the command codes that appear in compiled regular
        -: 2443:   expressions.  Some opcodes are followed by argument bytes.  A
        -: 2444:   command code can specify any interpretation whatsoever for its
        -: 2445:   arguments.  Zero bytes may appear in the compiled regular expression.
        -: 2446:
        -: 2447:   The value of `exactn' is needed in search.c (search_buffer) in Emacs.
        -: 2448:   So regex.h defines a symbol `RE_EXACTN_VALUE' to be 1; the value of
        -: 2449:   `exactn' we use here must also be 1.  */
        -: 2450:
        -: 2451:typedef enum
        -: 2452:{
        -: 2453:  no_op = 0,
        -: 2454:
        -: 2455:        /* Followed by one byte giving n, then by n literal bytes.  */
        -: 2456:  exactn = 1,
        -: 2457:
        -: 2458:        /* Matches any (more or less) character.  */
        -: 2459:  anychar,
        -: 2460:
        -: 2461:        /* Matches any one char belonging to specified set.  First
        -: 2462:           following byte is number of bitmap bytes.  Then come bytes
        -: 2463:           for a bitmap saying which chars are in.  Bits in each byte
        -: 2464:           are ordered low-bit-first.  A character is in the set if its
        -: 2465:           bit is 1.  A character too large to have a bit in the map is
        -: 2466:           automatically not in the set.  */
        -: 2467:  charset,
        -: 2468:
        -: 2469:        /* Same parameters as charset, but match any character that is
        -: 2470:           not one of those specified.  */
        -: 2471:  charset_not,
        -: 2472:
        -: 2473:        /* Start remembering the text that is matched, for storing in a
        -: 2474:           register.  Followed by one byte with the register number, in
        -: 2475:           the range 0 to one less than the pattern buffer's re_nsub
        -: 2476:           field.  Then followed by one byte with the number of groups
        -: 2477:           inner to this one.  (This last has to be part of the
        -: 2478:           start_memory only because we need it in the on_failure_jump
        -: 2479:           of re_match_2.)  */
        -: 2480:  start_memory,
        -: 2481:
        -: 2482:        /* Stop remembering the text that is matched and store it in a
        -: 2483:           memory register.  Followed by one byte with the register
        -: 2484:           number, in the range 0 to one less than `re_nsub' in the
        -: 2485:           pattern buffer, and one byte with the number of inner groups,
        -: 2486:           just like `start_memory'.  (We need the number of inner
        -: 2487:           groups here because we don't have any easy way of finding the
        -: 2488:           corresponding start_memory when we're at a stop_memory.)  */
        -: 2489:  stop_memory,
        -: 2490:
        -: 2491:        /* Match a duplicate of something remembered. Followed by one
        -: 2492:           byte containing the register number.  */
        -: 2493:  duplicate,
        -: 2494:
        -: 2495:        /* Fail unless at beginning of line.  */
        -: 2496:  begline,
        -: 2497:
        -: 2498:        /* Fail unless at end of line.  */
        -: 2499:  endline,
        -: 2500:
        -: 2501:        /* Succeeds if at beginning of buffer (if emacs) or at beginning
        -: 2502:           of string to be matched (if not).  */
        -: 2503:  begbuf,
        -: 2504:
        -: 2505:        /* Analogously, for end of buffer/string.  */
        -: 2506:  endbuf,
        -: 2507: 
        -: 2508:        /* Followed by two byte relative address to which to jump.  */
        -: 2509:  jump, 
        -: 2510:
        -: 2511:	/* Same as jump, but marks the end of an alternative.  */
        -: 2512:  jump_past_alt,
        -: 2513:
        -: 2514:        /* Followed by two-byte relative address of place to resume at
        -: 2515:           in case of failure.  */
        -: 2516:  on_failure_jump,
        -: 2517:	
        -: 2518:        /* Like on_failure_jump, but pushes a placeholder instead of the
        -: 2519:           current string position when executed.  */
        -: 2520:  on_failure_keep_string_jump,
        -: 2521:  
        -: 2522:        /* Throw away latest failure point and then jump to following
        -: 2523:           two-byte relative address.  */
        -: 2524:  pop_failure_jump,
        -: 2525:
        -: 2526:        /* Change to pop_failure_jump if know won't have to backtrack to
        -: 2527:           match; otherwise change to jump.  This is used to jump
        -: 2528:           back to the beginning of a repeat.  If what follows this jump
        -: 2529:           clearly won't match what the repeat does, such that we can be
        -: 2530:           sure that there is no use backtracking out of repetitions
        -: 2531:           already matched, then we change it to a pop_failure_jump.
        -: 2532:           Followed by two-byte address.  */
        -: 2533:  maybe_pop_jump,
        -: 2534:
        -: 2535:        /* Jump to following two-byte address, and push a dummy failure
        -: 2536:           point. This failure point will be thrown away if an attempt
        -: 2537:           is made to use it for a failure.  A `+' construct makes this
        -: 2538:           before the first repeat.  Also used as an intermediary kind
        -: 2539:           of jump when compiling an alternative.  */
        -: 2540:  dummy_failure_jump,
        -: 2541:
        -: 2542:	/* Push a dummy failure point and continue.  Used at the end of
        -: 2543:	   alternatives.  */
        -: 2544:  push_dummy_failure,
        -: 2545:
        -: 2546:        /* Followed by two-byte relative address and two-byte number n.
        -: 2547:           After matching N times, jump to the address upon failure.  */
        -: 2548:  succeed_n,
        -: 2549:
        -: 2550:        /* Followed by two-byte relative address, and two-byte number n.
        -: 2551:           Jump to the address N times, then fail.  */
        -: 2552:  jump_n,
        -: 2553:
        -: 2554:        /* Set the following two-byte relative address to the
        -: 2555:           subsequent two-byte number.  The address *includes* the two
        -: 2556:           bytes of number.  */
        -: 2557:  set_number_at,
        -: 2558:
        -: 2559:  wordchar,	/* Matches any word-constituent character.  */
        -: 2560:  notwordchar,	/* Matches any char that is not a word-constituent.  */
        -: 2561:
        -: 2562:  wordbeg,	/* Succeeds if at word beginning.  */
        -: 2563:  wordend,	/* Succeeds if at word end.  */
        -: 2564:
        -: 2565:  wordbound,	/* Succeeds if at a word boundary.  */
        -: 2566:  notwordbound	/* Succeeds if not at a word boundary.  */
        -: 2567:
        -: 2568:#ifdef emacs
        -: 2569:  ,before_dot,	/* Succeeds if before point.  */
        -: 2570:  at_dot,	/* Succeeds if at point.  */
        -: 2571:  after_dot,	/* Succeeds if after point.  */
        -: 2572:
        -: 2573:	/* Matches any character whose syntax is specified.  Followed by
        -: 2574:           a byte which contains a syntax code, e.g., Sword.  */
        -: 2575:  syntaxspec,
        -: 2576:
        -: 2577:	/* Matches any character whose syntax is not that specified.  */
        -: 2578:  notsyntaxspec
        -: 2579:#endif /* emacs */
        -: 2580:} re_opcode_t;
        -: 2581:
        -: 2582:/* Common operations on the compiled pattern.  */
        -: 2583:
        -: 2584:/* Store NUMBER in two contiguous bytes starting at DESTINATION.  */
        -: 2585:
        -: 2586:#define STORE_NUMBER(destination, number)				\
        -: 2587:  do {									\
        -: 2588:    (destination)[0] = (number) & 0377;					\
        -: 2589:    (destination)[1] = (number) >> 8;					\
        -: 2590:  } while (0)
        -: 2591:
        -: 2592:/* Same as STORE_NUMBER, except increment DESTINATION to
        -: 2593:   the byte after where the number is stored.  Therefore, DESTINATION
        -: 2594:   must be an lvalue.  */
        -: 2595:
        -: 2596:#define STORE_NUMBER_AND_INCR(destination, number)			\
        -: 2597:  do {									\
        -: 2598:    STORE_NUMBER (destination, number);					\
        -: 2599:    (destination) += 2;							\
        -: 2600:  } while (0)
        -: 2601:
        -: 2602:/* Put into DESTINATION a number stored in two contiguous bytes starting
        -: 2603:   at SOURCE.  */
        -: 2604:
        -: 2605:#define EXTRACT_NUMBER(destination, source)				\
        -: 2606:  do {									\
        -: 2607:    (destination) = *(source) & 0377;					\
        -: 2608:    (destination) += SIGN_EXTEND_CHAR (*((source) + 1)) << 8;		\
        -: 2609:  } while (0)
        -: 2610:
        -: 2611:#ifdef DEBUG
        -: 2612:static void
        -: 2613:extract_number (dest, source)
        -: 2614:    int *dest;
        -: 2615:    unsigned char *source;
        -: 2616:{
        -: 2617:  int temp = SIGN_EXTEND_CHAR (*(source + 1)); 
        -: 2618:  *dest = *source & 0377;
        -: 2619:  *dest += temp << 8;
        -: 2620:}
        -: 2621:
        -: 2622:#ifndef EXTRACT_MACROS /* To debug the macros.  */
        -: 2623:#undef EXTRACT_NUMBER
        -: 2624:#define EXTRACT_NUMBER(dest, src) extract_number (&dest, src)
        -: 2625:#endif /* not EXTRACT_MACROS */
        -: 2626:
        -: 2627:#endif /* DEBUG */
        -: 2628:
        -: 2629:/* Same as EXTRACT_NUMBER, except increment SOURCE to after the number.
        -: 2630:   SOURCE must be an lvalue.  */
        -: 2631:
        -: 2632:#define EXTRACT_NUMBER_AND_INCR(destination, source)			\
        -: 2633:  do {									\
        -: 2634:    EXTRACT_NUMBER (destination, source);				\
        -: 2635:    (source) += 2; 							\
        -: 2636:  } while (0)
        -: 2637:
        -: 2638:#ifdef DEBUG
        -: 2639:static void
        -: 2640:extract_number_and_incr (destination, source)
        -: 2641:    int *destination;
        -: 2642:    unsigned char **source;
        -: 2643:{ 
        -: 2644:  extract_number (destination, *source);
        -: 2645:  *source += 2;
        -: 2646:}
        -: 2647:
        -: 2648:#ifndef EXTRACT_MACROS
        -: 2649:#undef EXTRACT_NUMBER_AND_INCR
        -: 2650:#define EXTRACT_NUMBER_AND_INCR(dest, src) \
        -: 2651:  extract_number_and_incr (&dest, &src)
        -: 2652:#endif /* not EXTRACT_MACROS */
        -: 2653:
        -: 2654:#endif /* DEBUG */
        -: 2655:
        -: 2656:/* If DEBUG is defined, Regex prints many voluminous messages about what
        -: 2657:   it is doing (if the variable `debug' is nonzero).  If linked with the
        -: 2658:   main program in `iregex.c', you can enter patterns and strings
        -: 2659:   interactively.  And if linked with the main program in `main.c' and
        -: 2660:   the other test files, you can run the already-written tests.  */
        -: 2661:
        -: 2662:#ifdef DEBUG
        -: 2663:
        -: 2664:/* We use standard I/O for debugging.  */
        -: 2665:#include <stdio.h>
        -: 2666:
        -: 2667:/* It is useful to test things that ``must'' be true when debugging.  */
        -: 2668:#include <assert.h>
        -: 2669:
        -: 2670:static int debug = 0;
        -: 2671:
        -: 2672:#define DEBUG_STATEMENT(e) e
        -: 2673:#define DEBUG_PRINT1(x) if (debug) printf (x)
        -: 2674:#define DEBUG_PRINT2(x1, x2) if (debug) printf (x1, x2)
        -: 2675:#define DEBUG_PRINT3(x1, x2, x3) if (debug) printf (x1, x2, x3)
        -: 2676:#define DEBUG_PRINT4(x1, x2, x3, x4) if (debug) printf (x1, x2, x3, x4)
        -: 2677:#define DEBUG_PRINT_COMPILED_PATTERN(p, s, e) 				\
        -: 2678:  if (debug) print_partial_compiled_pattern (s, e)
        -: 2679:#define DEBUG_PRINT_DOUBLE_STRING(w, s1, sz1, s2, sz2)			\
        -: 2680:  if (debug) print_double_string (w, s1, sz1, s2, sz2)
        -: 2681:
        -: 2682:
        -: 2683:extern void printchar ();
        -: 2684:
        -: 2685:/* Print the fastmap in human-readable form.  */
        -: 2686:
        -: 2687:void
        -: 2688:print_fastmap (fastmap)
        -: 2689:    char *fastmap;
        -: 2690:{
        -: 2691:  unsigned was_a_range = 0;
        -: 2692:  unsigned i = 0;  
        -: 2693:  
        -: 2694:  while (i < (1 << BYTEWIDTH))
        -: 2695:    {
        -: 2696:      if (fastmap[i++])
        -: 2697:	{
        -: 2698:	  was_a_range = 0;
        -: 2699:          printchar (i - 1);
        -: 2700:          while (i < (1 << BYTEWIDTH)  &&  fastmap[i])
        -: 2701:            {
        -: 2702:              was_a_range = 1;
        -: 2703:              i++;
        -: 2704:            }
        -: 2705:	  if (was_a_range)
        -: 2706:            {
        -: 2707:              printf ("-");
        -: 2708:              printchar (i - 1);
        -: 2709:            }
        -: 2710:        }
        -: 2711:    }
        -: 2712:  putchar ('\n'); 
        -: 2713:}
        -: 2714:
        -: 2715:
        -: 2716:/* Print a compiled pattern string in human-readable form, starting at
        -: 2717:   the START pointer into it and ending just before the pointer END.  */
        -: 2718:
        -: 2719:void
        -: 2720:print_partial_compiled_pattern (start, end)
        -: 2721:    unsigned char *start;
        -: 2722:    unsigned char *end;
        -: 2723:{
        -: 2724:  int mcnt, mcnt2;
        -: 2725:  unsigned char *p = start;
        -: 2726:  unsigned char *pend = end;
        -: 2727:
        -: 2728:  if (start == NULL)
        -: 2729:    {
        -: 2730:      printf ("(null)\n");
        -: 2731:      return;
        -: 2732:    }
        -: 2733:    
        -: 2734:  /* Loop over pattern commands.  */
        -: 2735:  while (p < pend)
        -: 2736:    {
        -: 2737:      switch ((re_opcode_t) *p++)
        -: 2738:	{
        -: 2739:        case no_op:
        -: 2740:          printf ("/no_op");
        -: 2741:          break;
        -: 2742:
        -: 2743:	case exactn:
        -: 2744:	  mcnt = *p++;
        -: 2745:          printf ("/exactn/%d", mcnt);
        -: 2746:          do
        -: 2747:	    {
        -: 2748:              putchar ('/');
        -: 2749:	      printchar (*p++);
        -: 2750:            }
        -: 2751:          while (--mcnt);
        -: 2752:          break;
        -: 2753:
        -: 2754:	case start_memory:
        -: 2755:          mcnt = *p++;
        -: 2756:          printf ("/start_memory/%d/%d", mcnt, *p++);
        -: 2757:          break;
        -: 2758:
        -: 2759:	case stop_memory:
        -: 2760:          mcnt = *p++;
        -: 2761:	  printf ("/stop_memory/%d/%d", mcnt, *p++);
        -: 2762:          break;
        -: 2763:
        -: 2764:	case duplicate:
        -: 2765:	  printf ("/duplicate/%d", *p++);
        -: 2766:	  break;
        -: 2767:
        -: 2768:	case anychar:
        -: 2769:	  printf ("/anychar");
        -: 2770:	  break;
        -: 2771:
        -: 2772:	case charset:
        -: 2773:        case charset_not:
        -: 2774:          {
        -: 2775:            register int c;
        -: 2776:
        -: 2777:            printf ("/charset%s",
        -: 2778:	            (re_opcode_t) *(p - 1) == charset_not ? "_not" : "");
        -: 2779:            
        -: 2780:            assert (p + *p < pend);
        -: 2781:
        -: 2782:            for (c = 0; c < *p; c++)
        -: 2783:              {
        -: 2784:                unsigned bit;
        -: 2785:                unsigned char map_byte = p[1 + c];
        -: 2786:                
        -: 2787:                putchar ('/');
        -: 2788:
        -: 2789:		for (bit = 0; bit < BYTEWIDTH; bit++)
        -: 2790:                  if (map_byte & (1 << bit))
        -: 2791:                    printchar (c * BYTEWIDTH + bit);
        -: 2792:              }
        -: 2793:	    p += 1 + *p;
        -: 2794:	    break;
        -: 2795:	  }
        -: 2796:
        -: 2797:	case begline:
        -: 2798:	  printf ("/begline");
        -: 2799:          break;
        -: 2800:
        -: 2801:	case endline:
        -: 2802:          printf ("/endline");
        -: 2803:          break;
        -: 2804:
        -: 2805:	case on_failure_jump:
        -: 2806:          extract_number_and_incr (&mcnt, &p);
        -: 2807:  	  printf ("/on_failure_jump/0/%d", mcnt);
        -: 2808:          break;
        -: 2809:
        -: 2810:	case on_failure_keep_string_jump:
        -: 2811:          extract_number_and_incr (&mcnt, &p);
        -: 2812:  	  printf ("/on_failure_keep_string_jump/0/%d", mcnt);
        -: 2813:          break;
        -: 2814:
        -: 2815:	case dummy_failure_jump:
        -: 2816:          extract_number_and_incr (&mcnt, &p);
        -: 2817:  	  printf ("/dummy_failure_jump/0/%d", mcnt);
        -: 2818:          break;
        -: 2819:
        -: 2820:	case push_dummy_failure:
        -: 2821:          printf ("/push_dummy_failure");
        -: 2822:          break;
        -: 2823:          
        -: 2824:        case maybe_pop_jump:
        -: 2825:          extract_number_and_incr (&mcnt, &p);
        -: 2826:  	  printf ("/maybe_pop_jump/0/%d", mcnt);
        -: 2827:	  break;
        -: 2828:
        -: 2829:        case pop_failure_jump:
        -: 2830:	  extract_number_and_incr (&mcnt, &p);
        -: 2831:  	  printf ("/pop_failure_jump/0/%d", mcnt);
        -: 2832:	  break;          
        -: 2833:          
        -: 2834:        case jump_past_alt:
        -: 2835:	  extract_number_and_incr (&mcnt, &p);
        -: 2836:  	  printf ("/jump_past_alt/0/%d", mcnt);
        -: 2837:	  break;          
        -: 2838:          
        -: 2839:        case jump:
        -: 2840:	  extract_number_and_incr (&mcnt, &p);
        -: 2841:  	  printf ("/jump/0/%d", mcnt);
        -: 2842:	  break;
        -: 2843:
        -: 2844:        case succeed_n: 
        -: 2845:          extract_number_and_incr (&mcnt, &p);
        -: 2846:          extract_number_and_incr (&mcnt2, &p);
        -: 2847: 	  printf ("/succeed_n/0/%d/0/%d", mcnt, mcnt2);
        -: 2848:          break;
        -: 2849:        
        -: 2850:        case jump_n: 
        -: 2851:          extract_number_and_incr (&mcnt, &p);
        -: 2852:          extract_number_and_incr (&mcnt2, &p);
        -: 2853: 	  printf ("/jump_n/0/%d/0/%d", mcnt, mcnt2);
        -: 2854:          break;
        -: 2855:        
        -: 2856:        case set_number_at: 
        -: 2857:          extract_number_and_incr (&mcnt, &p);
        -: 2858:          extract_number_and_incr (&mcnt2, &p);
        -: 2859: 	  printf ("/set_number_at/0/%d/0/%d", mcnt, mcnt2);
        -: 2860:          break;
        -: 2861:        
        -: 2862:        case wordbound:
        -: 2863:	  printf ("/wordbound");
        -: 2864:	  break;
        -: 2865:
        -: 2866:	case notwordbound:
        -: 2867:	  printf ("/notwordbound");
        -: 2868:          break;
        -: 2869:
        -: 2870:	case wordbeg:
        -: 2871:	  printf ("/wordbeg");
        -: 2872:	  break;
        -: 2873:          
        -: 2874:	case wordend:
        -: 2875:	  printf ("/wordend");
        -: 2876:          
        -: 2877:#ifdef emacs
        -: 2878:	case before_dot:
        -: 2879:	  printf ("/before_dot");
        -: 2880:          break;
        -: 2881:
        -: 2882:	case at_dot:
        -: 2883:	  printf ("/at_dot");
        -: 2884:          break;
        -: 2885:
        -: 2886:	case after_dot:
        -: 2887:	  printf ("/after_dot");
        -: 2888:          break;
        -: 2889:
        -: 2890:	case syntaxspec:
        -: 2891:          printf ("/syntaxspec");
        -: 2892:	  mcnt = *p++;
        -: 2893:	  printf ("/%d", mcnt);
        -: 2894:          break;
        -: 2895:	  
        -: 2896:	case notsyntaxspec:
        -: 2897:          printf ("/notsyntaxspec");
        -: 2898:	  mcnt = *p++;
        -: 2899:	  printf ("/%d", mcnt);
        -: 2900:	  break;
        -: 2901:#endif /* emacs */
        -: 2902:
        -: 2903:	case wordchar:
        -: 2904:	  printf ("/wordchar");
        -: 2905:          break;
        -: 2906:	  
        -: 2907:	case notwordchar:
        -: 2908:	  printf ("/notwordchar");
        -: 2909:          break;
        -: 2910:
        -: 2911:	case begbuf:
        -: 2912:	  printf ("/begbuf");
        -: 2913:          break;
        -: 2914:
        -: 2915:	case endbuf:
        -: 2916:	  printf ("/endbuf");
        -: 2917:          break;
        -: 2918:
        -: 2919:        default:
        -: 2920:          printf ("?%d", *(p-1));
        -: 2921:	}
        -: 2922:    }
        -: 2923:  printf ("/\n");
        -: 2924:}
        -: 2925:
        -: 2926:
        -: 2927:void
        -: 2928:print_compiled_pattern (bufp)
        -: 2929:    struct re_pattern_buffer *bufp;
        -: 2930:{
        -: 2931:  unsigned char *buffer = bufp->buffer;
        -: 2932:
        -: 2933:  print_partial_compiled_pattern (buffer, buffer + bufp->used);
        -: 2934:  printf ("%d bytes used/%d bytes allocated.\n", bufp->used, bufp->allocated);
        -: 2935:
        -: 2936:  if (bufp->fastmap_accurate && bufp->fastmap)
        -: 2937:    {
        -: 2938:      printf ("fastmap: ");
        -: 2939:      print_fastmap (bufp->fastmap);
        -: 2940:    }
        -: 2941:
        -: 2942:  printf ("re_nsub: %d\t", bufp->re_nsub);
        -: 2943:  printf ("regs_alloc: %d\t", bufp->regs_allocated);
        -: 2944:  printf ("can_be_null: %d\t", bufp->can_be_null);
        -: 2945:  printf ("newline_anchor: %d\n", bufp->newline_anchor);
        -: 2946:  printf ("no_sub: %d\t", bufp->no_sub);
        -: 2947:  printf ("not_bol: %d\t", bufp->not_bol);
        -: 2948:  printf ("not_eol: %d\t", bufp->not_eol);
        -: 2949:  printf ("syntax: %d\n", bufp->syntax);
        -: 2950:  /* Perhaps we should print the translate table?  */
        -: 2951:}
        -: 2952:
        -: 2953:
        -: 2954:void
        -: 2955:print_double_string (where, string1, size1, string2, size2)
        -: 2956:    const char *where;
        -: 2957:    const char *string1;
        -: 2958:    const char *string2;
        -: 2959:    int size1;
        -: 2960:    int size2;
        -: 2961:{
        -: 2962:  unsigned this_char;
        -: 2963:  
        -: 2964:  if (where == NULL)
        -: 2965:    printf ("(null)");
        -: 2966:  else
        -: 2967:    {
        -: 2968:      if (FIRST_STRING_P (where))
        -: 2969:        {
        -: 2970:          for (this_char = where - string1; this_char < size1; this_char++)
        -: 2971:            printchar (string1[this_char]);
        -: 2972:
        -: 2973:          where = string2;    
        -: 2974:        }
        -: 2975:
        -: 2976:      for (this_char = where - string2; this_char < size2; this_char++)
        -: 2977:        printchar (string2[this_char]);
        -: 2978:    }
        -: 2979:}
        -: 2980:
        -: 2981:#else /* not DEBUG */
        -: 2982:
        -: 2983:#undef assert
        -: 2984:#define assert(e)
        -: 2985:
        -: 2986:#define DEBUG_STATEMENT(e)
        -: 2987:#define DEBUG_PRINT1(x)
        -: 2988:#define DEBUG_PRINT2(x1, x2)
        -: 2989:#define DEBUG_PRINT3(x1, x2, x3)
        -: 2990:#define DEBUG_PRINT4(x1, x2, x3, x4)
        -: 2991:#define DEBUG_PRINT_COMPILED_PATTERN(p, s, e)
        -: 2992:#define DEBUG_PRINT_DOUBLE_STRING(w, s1, sz1, s2, sz2)
        -: 2993:
        -: 2994:#endif /* not DEBUG */
        -: 2995:
        -: 2996:/* Set by `re_set_syntax' to the current regexp syntax to recognize.  Can
        -: 2997:   also be assigned to arbitrarily: each pattern buffer stores its own
        -: 2998:   syntax, so it can be changed between regex compilations.  */
        -: 2999:reg_syntax_t re_syntax_options = RE_SYNTAX_EMACS;
        -: 3000:
        -: 3001:
        -: 3002:/* Specify the precise syntax of regexps for compilation.  This provides
        -: 3003:   for compatibility for various utilities which historically have
        -: 3004:   different, incompatible syntaxes.
        -: 3005:
        -: 3006:   The argument SYNTAX is a bit mask comprised of the various bits
        -: 3007:   defined in regex.h.  We return the old syntax.  */
        -: 3008:
        -: 3009:reg_syntax_t
function re_set_syntax called 370 returned 100% blocks executed 100%
      370: 3010:re_set_syntax (syntax)
        -: 3011:    reg_syntax_t syntax;
        -: 3012:{
      370: 3013:  reg_syntax_t ret = re_syntax_options;
        -: 3014:  
      370: 3015:  re_syntax_options = syntax;
      370: 3016:  return ret;
        -: 3017:}
        -: 3018:
        -: 3019:/* This table gives an error message for each of the error codes listed
        -: 3020:   in regex.h.  Obviously the order here has to be same as there.  */
        -: 3021:
        -: 3022:static const char *re_error_msg[] =
        -: 3023:  { NULL,					/* REG_NOERROR */
        -: 3024:    "No match",					/* REG_NOMATCH */
        -: 3025:    "Invalid regular expression",		/* REG_BADPAT */
        -: 3026:    "Invalid collation character",		/* REG_ECOLLATE */
        -: 3027:    "Invalid character class name",		/* REG_ECTYPE */
        -: 3028:    "Trailing backslash",			/* REG_EESCAPE */
        -: 3029:    "Invalid back reference",			/* REG_ESUBREG */
        -: 3030:    "Unmatched [ or [^",			/* REG_EBRACK */
        -: 3031:    "Unmatched ( or \\(",			/* REG_EPAREN */
        -: 3032:    "Unmatched \\{",				/* REG_EBRACE */
        -: 3033:    "Invalid content of \\{\\}",		/* REG_BADBR */
        -: 3034:    "Invalid range end",			/* REG_ERANGE */
        -: 3035:    "Memory exhausted",				/* REG_ESPACE */
        -: 3036:    "Invalid preceding regular expression",	/* REG_BADRPT */
        -: 3037:    "Premature end of regular expression",	/* REG_EEND */
        -: 3038:    "Regular expression too big",		/* REG_ESIZE */
        -: 3039:    "Unmatched ) or \\)",			/* REG_ERPAREN */
        -: 3040:  };
        -: 3041:
        -: 3042:/* Subroutine declarations and macros for regex_compile.  */
        -: 3043:
        -: 3044:static void store_op1 (), store_op2 ();
        -: 3045:static void insert_op1 (), insert_op2 ();
        -: 3046:static boolean at_begline_loc_p (), at_endline_loc_p ();
        -: 3047:static boolean group_in_compile_stack ();
        -: 3048:static reg_errcode_t compile_range ();
        -: 3049:
        -: 3050:/* Fetch the next character in the uncompiled pattern---translating it 
        -: 3051:   if necessary.  Also cast from a signed character in the constant
        -: 3052:   string passed to us by the user to an unsigned char that we can use
        -: 3053:   as an array index (in, e.g., `translate').  */
        -: 3054:#define PATFETCH(c)							\
        -: 3055:  do {if (p == pend) return REG_EEND;					\
        -: 3056:    c = (unsigned char) *p++;						\
        -: 3057:    if (translate) c = translate[c]; 					\
        -: 3058:  } while (0)
        -: 3059:
        -: 3060:/* Fetch the next character in the uncompiled pattern, with no
        -: 3061:   translation.  */
        -: 3062:#define PATFETCH_RAW(c)							\
        -: 3063:  do {if (p == pend) return REG_EEND;					\
        -: 3064:    c = (unsigned char) *p++; 						\
        -: 3065:  } while (0)
        -: 3066:
        -: 3067:/* Go backwards one character in the pattern.  */
        -: 3068:#define PATUNFETCH p--
        -: 3069:
        -: 3070:
        -: 3071:/* If `translate' is non-null, return translate[D], else just D.  We
        -: 3072:   cast the subscript to translate because some data is declared as
        -: 3073:   `char *', to avoid warnings when a string constant is passed.  But
        -: 3074:   when we use a character as a subscript we must make it unsigned.  */
        -: 3075:#define TRANSLATE(d) (translate ? translate[(unsigned char) (d)] : (d))
        -: 3076:
        -: 3077:
        -: 3078:/* Macros for outputting the compiled pattern into `buffer'.  */
        -: 3079:
        -: 3080:/* If the buffer isn't allocated when it comes in, use this.  */
        -: 3081:#define INIT_BUF_SIZE  32
        -: 3082:
        -: 3083:/* Make sure we have at least N more bytes of space in buffer.  */
        -: 3084:#define GET_BUFFER_SPACE(n)						\
        -: 3085:    while (b - bufp->buffer + (n) > bufp->allocated)			\
        -: 3086:      EXTEND_BUFFER ()
        -: 3087:
        -: 3088:/* Make sure we have one more byte of buffer space and then add C to it.  */
        -: 3089:#define BUF_PUSH(c)							\
        -: 3090:  do {									\
        -: 3091:    GET_BUFFER_SPACE (1);						\
        -: 3092:    *b++ = (unsigned char) (c);						\
        -: 3093:  } while (0)
        -: 3094:
        -: 3095:
        -: 3096:/* Ensure we have two more bytes of buffer space and then append C1 and C2.  */
        -: 3097:#define BUF_PUSH_2(c1, c2)						\
        -: 3098:  do {									\
        -: 3099:    GET_BUFFER_SPACE (2);						\
        -: 3100:    *b++ = (unsigned char) (c1);					\
        -: 3101:    *b++ = (unsigned char) (c2);					\
        -: 3102:  } while (0)
        -: 3103:
        -: 3104:
        -: 3105:/* As with BUF_PUSH_2, except for three bytes.  */
        -: 3106:#define BUF_PUSH_3(c1, c2, c3)						\
        -: 3107:  do {									\
        -: 3108:    GET_BUFFER_SPACE (3);						\
        -: 3109:    *b++ = (unsigned char) (c1);					\
        -: 3110:    *b++ = (unsigned char) (c2);					\
        -: 3111:    *b++ = (unsigned char) (c3);					\
        -: 3112:  } while (0)
        -: 3113:
        -: 3114:
        -: 3115:/* Store a jump with opcode OP at LOC to location TO.  We store a
        -: 3116:   relative address offset by the three bytes the jump itself occupies.  */
        -: 3117:#define STORE_JUMP(op, loc, to) \
        -: 3118:  store_op1 (op, loc, (to) - (loc) - 3)
        -: 3119:
        -: 3120:/* Likewise, for a two-argument jump.  */
        -: 3121:#define STORE_JUMP2(op, loc, to, arg) \
        -: 3122:  store_op2 (op, loc, (to) - (loc) - 3, arg)
        -: 3123:
        -: 3124:/* Like `STORE_JUMP', but for inserting.  Assume `b' is the buffer end.  */
        -: 3125:#define INSERT_JUMP(op, loc, to) \
        -: 3126:  insert_op1 (op, loc, (to) - (loc) - 3, b)
        -: 3127:
        -: 3128:/* Like `STORE_JUMP2', but for inserting.  Assume `b' is the buffer end.  */
        -: 3129:#define INSERT_JUMP2(op, loc, to, arg) \
        -: 3130:  insert_op2 (op, loc, (to) - (loc) - 3, arg, b)
        -: 3131:
        -: 3132:
        -: 3133:/* This is not an arbitrary limit: the arguments which represent offsets
        -: 3134:   into the pattern are two bytes long.  So if 2^16 bytes turns out to
        -: 3135:   be too small, many things would have to change.  */
        -: 3136:#define MAX_BUF_SIZE (1L << 16)
        -: 3137:
        -: 3138:
        -: 3139:/* Extend the buffer by twice its current size via realloc and
        -: 3140:   reset the pointers that pointed into the old block to point to the
        -: 3141:   correct places in the new one.  If extending the buffer results in it
        -: 3142:   being larger than MAX_BUF_SIZE, then flag memory exhausted.  */
        -: 3143:#define EXTEND_BUFFER()							\
        -: 3144:  do { 									\
        -: 3145:    unsigned char *old_buffer = bufp->buffer;				\
        -: 3146:    if (bufp->allocated == MAX_BUF_SIZE) 				\
        -: 3147:      return REG_ESIZE;							\
        -: 3148:    bufp->allocated <<= 1;						\
        -: 3149:    if (bufp->allocated > MAX_BUF_SIZE)					\
        -: 3150:      bufp->allocated = MAX_BUF_SIZE; 					\
        -: 3151:    bufp->buffer = (unsigned char *) realloc (bufp->buffer, bufp->allocated);\
        -: 3152:    if (bufp->buffer == NULL)						\
        -: 3153:      return REG_ESPACE;						\
        -: 3154:    /* If the buffer moved, move all the pointers into it.  */		\
        -: 3155:    if (old_buffer != bufp->buffer)					\
        -: 3156:      {									\
        -: 3157:        b = (b - old_buffer) + bufp->buffer;				\
        -: 3158:        begalt = (begalt - old_buffer) + bufp->buffer;			\
        -: 3159:        if (fixup_alt_jump)						\
        -: 3160:          fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;\
        -: 3161:        if (laststart)							\
        -: 3162:          laststart = (laststart - old_buffer) + bufp->buffer;		\
        -: 3163:        if (pending_exact)						\
        -: 3164:          pending_exact = (pending_exact - old_buffer) + bufp->buffer;	\
        -: 3165:      }									\
        -: 3166:  } while (0)
        -: 3167:
        -: 3168:
        -: 3169:/* Since we have one byte reserved for the register number argument to
        -: 3170:   {start,stop}_memory, the maximum number of groups we can report
        -: 3171:   things about is what fits in that byte.  */
        -: 3172:#define MAX_REGNUM 255
        -: 3173:
        -: 3174:/* But patterns can have more than `MAX_REGNUM' registers.  We just
        -: 3175:   ignore the excess.  */
        -: 3176:typedef unsigned regnum_t;
        -: 3177:
        -: 3178:
        -: 3179:/* Macros for the compile stack.  */
        -: 3180:
        -: 3181:/* Since offsets can go either forwards or backwards, this type needs to
        -: 3182:   be able to hold values from -(MAX_BUF_SIZE - 1) to MAX_BUF_SIZE - 1.  */
        -: 3183:typedef int pattern_offset_t;
        -: 3184:
        -: 3185:typedef struct
        -: 3186:{
        -: 3187:  pattern_offset_t begalt_offset;
        -: 3188:  pattern_offset_t fixup_alt_jump;
        -: 3189:  pattern_offset_t inner_group_offset;
        -: 3190:  pattern_offset_t laststart_offset;  
        -: 3191:  regnum_t regnum;
        -: 3192:} compile_stack_elt_t;
        -: 3193:
        -: 3194:
        -: 3195:typedef struct
        -: 3196:{
        -: 3197:  compile_stack_elt_t *stack;
        -: 3198:  unsigned size;
        -: 3199:  unsigned avail;			/* Offset of next open position.  */
        -: 3200:} compile_stack_type;
        -: 3201:
        -: 3202:
        -: 3203:#define INIT_COMPILE_STACK_SIZE 32
        -: 3204:
        -: 3205:#define COMPILE_STACK_EMPTY  (compile_stack.avail == 0)
        -: 3206:#define COMPILE_STACK_FULL  (compile_stack.avail == compile_stack.size)
        -: 3207:
        -: 3208:/* The next available element.  */
        -: 3209:#define COMPILE_STACK_TOP (compile_stack.stack[compile_stack.avail])
        -: 3210:
        -: 3211:
        -: 3212:/* Set the bit for character C in a list.  */
        -: 3213:#define SET_LIST_BIT(c)                               \
        -: 3214:  (b[((unsigned char) (c)) / BYTEWIDTH]               \
        -: 3215:   |= 1 << (((unsigned char) c) % BYTEWIDTH))
        -: 3216:
        -: 3217:
        -: 3218:/* Get the next unsigned number in the uncompiled pattern.  */
        -: 3219:#define GET_UNSIGNED_NUMBER(num) 					\
        -: 3220:  { if (p != pend)							\
        -: 3221:     {									\
        -: 3222:       PATFETCH (c); 							\
        -: 3223:       while (ISDIGIT (c)) 						\
        -: 3224:         { 								\
        -: 3225:           if (num < 0)							\
        -: 3226:              num = 0;							\
        -: 3227:           num = num * 10 + c - '0'; 					\
        -: 3228:           if (p == pend) 						\
        -: 3229:              break; 							\
        -: 3230:           PATFETCH (c);						\
        -: 3231:         } 								\
        -: 3232:       } 								\
        -: 3233:    }		
        -: 3234:
        -: 3235:#define CHAR_CLASS_MAX_LENGTH  6 /* Namely, `xdigit'.  */
        -: 3236:
        -: 3237:#define IS_CHAR_CLASS(string)						\
        -: 3238:   (STREQ (string, "alpha") || STREQ (string, "upper")			\
        -: 3239:    || STREQ (string, "lower") || STREQ (string, "digit")		\
        -: 3240:    || STREQ (string, "alnum") || STREQ (string, "xdigit")		\
        -: 3241:    || STREQ (string, "space") || STREQ (string, "print")		\
        -: 3242:    || STREQ (string, "punct") || STREQ (string, "graph")		\
        -: 3243:    || STREQ (string, "cntrl") || STREQ (string, "blank"))
        -: 3244:
        -: 3245:/* `regex_compile' compiles PATTERN (of length SIZE) according to SYNTAX.
        -: 3246:   Returns one of error codes defined in `regex.h', or zero for success.
        -: 3247:
        -: 3248:   Assumes the `allocated' (and perhaps `buffer') and `translate'
        -: 3249:   fields are set in BUFP on entry.
        -: 3250:
        -: 3251:   If it succeeds, results are put in BUFP (if it returns an error, the
        -: 3252:   contents of BUFP are undefined):
        -: 3253:     `buffer' is the compiled pattern;
        -: 3254:     `syntax' is set to SYNTAX;
        -: 3255:     `used' is set to the length of the compiled pattern;
        -: 3256:     `fastmap_accurate' is zero;
        -: 3257:     `re_nsub' is the number of subexpressions in PATTERN;
        -: 3258:     `not_bol' and `not_eol' are zero;
        -: 3259:   
        -: 3260:   The `fastmap' and `newline_anchor' fields are neither
        -: 3261:   examined nor set.  */
        -: 3262:
        -: 3263:static reg_errcode_t
function regex_compile called 603 returned 100% blocks executed 29%
      603: 3264:regex_compile (pattern, size, syntax, bufp)
        -: 3265:     const char *pattern;
        -: 3266:     int size;
        -: 3267:     reg_syntax_t syntax;
        -: 3268:     struct re_pattern_buffer *bufp;
        -: 3269:{
        -: 3270:  /* We fetch characters from PATTERN here.  Even though PATTERN is
        -: 3271:     `char *' (i.e., signed), we declare these variables as unsigned, so
        -: 3272:     they can be reliably used as array indices.  */
        -: 3273:  register unsigned char c, c1;
        -: 3274:  
        -: 3275:  /* A random tempory spot in PATTERN.  */
        -: 3276:  const char *p1;
        -: 3277:
        -: 3278:  /* Points to the end of the buffer, where we should append.  */
        -: 3279:  register unsigned char *b;
        -: 3280:  
        -: 3281:  /* Keeps track of unclosed groups.  */
        -: 3282:  compile_stack_type compile_stack;
        -: 3283:
        -: 3284:  /* Points to the current (ending) position in the pattern.  */
      603: 3285:  const char *p = pattern;
      603: 3286:  const char *pend = pattern + size;
        -: 3287:  
        -: 3288:  /* How to translate the characters in the pattern.  */
      603: 3289:  char *translate = bufp->translate;
        -: 3290:
        -: 3291:  /* Address of the count-byte of the most recently inserted `exactn'
        -: 3292:     command.  This makes it possible to tell if a new exact-match
        -: 3293:     character can be added to that command or if the character requires
        -: 3294:     a new `exactn' command.  */
      603: 3295:  unsigned char *pending_exact = 0;
        -: 3296:
        -: 3297:  /* Address of start of the most recently finished expression.
        -: 3298:     This tells, e.g., postfix * where to find the start of its
        -: 3299:     operand.  Reset at the beginning of groups and alternatives.  */
      603: 3300:  unsigned char *laststart = 0;
        -: 3301:
        -: 3302:  /* Address of beginning of regexp, or inside of last group.  */
        -: 3303:  unsigned char *begalt;
        -: 3304:
        -: 3305:  /* Place in the uncompiled pattern (i.e., the {) to
        -: 3306:     which to go back if the interval is invalid.  */
        -: 3307:  const char *beg_interval;
        -: 3308:                
        -: 3309:  /* Address of the place where a forward jump should go to the end of
        -: 3310:     the containing expression.  Each alternative of an `or' -- except the
        -: 3311:     last -- ends with a forward jump of this sort.  */
      603: 3312:  unsigned char *fixup_alt_jump = 0;
        -: 3313:
        -: 3314:  /* Counts open-groups as they are encountered.  Remembered for the
        -: 3315:     matching close-group on the compile stack, so the same register
        -: 3316:     number is put in the stop_memory as the start_memory.  */
      603: 3317:  regnum_t regnum = 0;
        -: 3318:
        -: 3319:#ifdef DEBUG
        -: 3320:  DEBUG_PRINT1 ("\nCompiling pattern: ");
        -: 3321:  if (debug)
        -: 3322:    {
        -: 3323:      unsigned debug_count;
        -: 3324:      
        -: 3325:      for (debug_count = 0; debug_count < size; debug_count++)
        -: 3326:        printchar (pattern[debug_count]);
        -: 3327:      putchar ('\n');
        -: 3328:    }
        -: 3329:#endif /* DEBUG */
        -: 3330:
        -: 3331:  /* Initialize the compile stack.  */
      603: 3332:  compile_stack.stack = TALLOC (INIT_COMPILE_STACK_SIZE, compile_stack_elt_t);
      603: 3333:  if (compile_stack.stack == NULL)
branch  0 taken 0 (fallthrough)
branch  1 taken 603
    #####: 3334:    return REG_ESPACE;
        -: 3335:
      603: 3336:  compile_stack.size = INIT_COMPILE_STACK_SIZE;
      603: 3337:  compile_stack.avail = 0;
        -: 3338:
        -: 3339:  /* Initialize the pattern buffer.  */
      603: 3340:  bufp->syntax = syntax;
      603: 3341:  bufp->fastmap_accurate = 0;
      603: 3342:  bufp->not_bol = bufp->not_eol = 0;
        -: 3343:
        -: 3344:  /* Set `used' to zero, so that if we return an error, the pattern
        -: 3345:     printer (for debugging) will think there's no pattern.  We reset it
        -: 3346:     at the end.  */
      603: 3347:  bufp->used = 0;
        -: 3348:  
        -: 3349:  /* Always count groups, whether or not bufp->no_sub is set.  */
      603: 3350:  bufp->re_nsub = 0;				
        -: 3351:
        -: 3352:#if !defined (emacs) && !defined (SYNTAX_TABLE)
        -: 3353:  /* Initialize the syntax table.  */
      603: 3354:   init_syntax_once ();
call    0 returned 603
        -: 3355:#endif
        -: 3356:
      603: 3357:  if (bufp->allocated == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 603
        -: 3358:    {
    #####: 3359:      if (bufp->buffer)
branch  0 never executed
branch  1 never executed
        -: 3360:	{ /* If zero allocated, but buffer is non-null, try to realloc
        -: 3361:             enough space.  This loses if buffer's address is bogus, but
        -: 3362:             that is the user's responsibility.  */
    #####: 3363:          RETALLOC (bufp->buffer, INIT_BUF_SIZE, unsigned char);
        -: 3364:        }
        -: 3365:      else
        -: 3366:        { /* Caller did not allocate a buffer.  Do it for them.  */
    #####: 3367:          bufp->buffer = TALLOC (INIT_BUF_SIZE, unsigned char);
        -: 3368:        }
    #####: 3369:      if (!bufp->buffer) return REG_ESPACE;
branch  0 never executed
branch  1 never executed
        -: 3370:
    #####: 3371:      bufp->allocated = INIT_BUF_SIZE;
        -: 3372:    }
        -: 3373:
      603: 3374:  begalt = b = bufp->buffer;
        -: 3375:
        -: 3376:  /* Loop through the uncompiled pattern until we're at the end.  */
     3246: 3377:  while (p != pend)
branch  0 taken 2643
branch  1 taken 603 (fallthrough)
        -: 3378:    {
    2643*: 3379:      PATFETCH (c);
branch  0 taken 0 (fallthrough)
branch  1 taken 2643
branch  2 taken 0 (fallthrough)
branch  3 taken 2643
        -: 3380:
     2643: 3381:      switch (c)
branch  0 taken 0
branch  1 taken 0
branch  2 taken 0
branch  3 taken 137
branch  4 taken 121
branch  5 taken 5
branch  6 taken 0
branch  7 taken 0
branch  8 taken 12
branch  9 taken 0
branch 10 taken 0
branch 11 taken 591
branch 12 taken 1777
        -: 3382:        {
    #####: 3383:        case '^':
        -: 3384:          {
    #####: 3385:            if (   /* If at start of pattern, it's an operator.  */
    #####: 3386:                   p == pattern + 1
branch  0 never executed
branch  1 never executed
        -: 3387:                   /* If context independent, it's an operator.  */
    #####: 3388:                || syntax & RE_CONTEXT_INDEP_ANCHORS
branch  0 never executed
branch  1 never executed
        -: 3389:                   /* Otherwise, depends on what's come before.  */
    #####: 3390:                || at_begline_loc_p (pattern, p, syntax))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3391:              BUF_PUSH (begline);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
        -: 3392:            else
    #####: 3393:              goto normal_char;
        -: 3394:          }
    #####: 3395:          break;
        -: 3396:
        -: 3397:
    #####: 3398:        case '$':
        -: 3399:          {
    #####: 3400:            if (   /* If at end of pattern, it's an operator.  */
    #####: 3401:                   p == pend 
branch  0 never executed
branch  1 never executed
        -: 3402:                   /* If context independent, it's an operator.  */
    #####: 3403:                || syntax & RE_CONTEXT_INDEP_ANCHORS
branch  0 never executed
branch  1 never executed
        -: 3404:                   /* Otherwise, depends on what's next.  */
    #####: 3405:                || at_endline_loc_p (p, pend, syntax))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3406:               BUF_PUSH (endline);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
        -: 3407:             else
    #####: 3408:               goto normal_char;
        -: 3409:           }
    #####: 3410:           break;
        -: 3411:
        -: 3412:
    #####: 3413:	case '+':
        -: 3414:        case '?':
    #####: 3415:          if ((syntax & RE_BK_PLUS_QM)
branch  0 never executed
branch  1 never executed
    #####: 3416:              || (syntax & RE_LIMITED_OPS))
branch  0 never executed
branch  1 never executed
    #####: 3417:            goto normal_char;
    #####: 3418:        handle_plus:
      137: 3419:        case '*':
        -: 3420:          /* If there is no previous pattern... */
      137: 3421:          if (!laststart)
branch  0 taken 8 (fallthrough)
branch  1 taken 129
        -: 3422:            {
        8: 3423:              if (syntax & RE_CONTEXT_INVALID_OPS)
branch  0 taken 0 (fallthrough)
branch  1 taken 8
    #####: 3424:                return REG_BADRPT;
        8: 3425:              else if (!(syntax & RE_CONTEXT_INDEP_OPS))
branch  0 taken 8 (fallthrough)
branch  1 taken 0
        8: 3426:                goto normal_char;
        -: 3427:            }
        -: 3428:
        -: 3429:          {
        -: 3430:            /* Are we optimizing this jump?  */
      129: 3431:            boolean keep_string_p = false;
        -: 3432:            
        -: 3433:            /* 1 means zero (many) matches is allowed.  */
      129: 3434:            char zero_times_ok = 0, many_times_ok = 0;
        -: 3435:
        -: 3436:            /* If there is a sequence of repetition chars, collapse it
        -: 3437:               down to just one (the right one).  We can't combine
        -: 3438:               interval operators with these because of, e.g., `a{2}*',
        -: 3439:               which should only match an even number of `a's.  */
        -: 3440:
        -: 3441:            for (;;)
        -: 3442:              {
      129: 3443:                zero_times_ok |= c != '+';
      129: 3444:                many_times_ok |= c != '?';
        -: 3445:
      129: 3446:                if (p == pend)
branch  0 taken 73 (fallthrough)
branch  1 taken 56
       73: 3447:                  break;
        -: 3448:
      56*: 3449:                PATFETCH (c);
branch  0 taken 0 (fallthrough)
branch  1 taken 56
branch  2 taken 0 (fallthrough)
branch  3 taken 56
        -: 3450:
       56: 3451:                if (c == '*'
branch  0 taken 56 (fallthrough)
branch  1 taken 0
      56*: 3452:                    || (!(syntax & RE_BK_PLUS_QM) && (c == '+' || c == '?')))
branch  0 taken 0 (fallthrough)
branch  1 taken 56
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 3453:                  ;
        -: 3454:
       56: 3455:                else if (syntax & RE_BK_PLUS_QM  &&  c == '\\')
branch  0 taken 56 (fallthrough)
branch  1 taken 0
branch  2 taken 13 (fallthrough)
branch  3 taken 43
        -: 3456:                  {
      13*: 3457:                    if (p == pend) return REG_EESCAPE;
branch  0 taken 0 (fallthrough)
branch  1 taken 13
        -: 3458:
      13*: 3459:                    PATFETCH (c1);
branch  0 taken 0 (fallthrough)
branch  1 taken 13
branch  2 taken 0 (fallthrough)
branch  3 taken 13
       13: 3460:                    if (!(c1 == '+' || c1 == '?'))
branch  0 taken 13 (fallthrough)
branch  1 taken 0
branch  2 taken 13 (fallthrough)
branch  3 taken 0
        -: 3461:                      {
       13: 3462:                        PATUNFETCH;
       13: 3463:                        PATUNFETCH;
       13: 3464:                        break;
        -: 3465:                      }
        -: 3466:
    #####: 3467:                    c = c1;
        -: 3468:                  }
        -: 3469:                else
        -: 3470:                  {
       43: 3471:                    PATUNFETCH;
       43: 3472:                    break;
        -: 3473:                  }
        -: 3474:
        -: 3475:                /* If we get here, we found another repeat character.  */
        -: 3476:               }
        -: 3477:
        -: 3478:            /* Star, etc. applied to an empty pattern is equivalent
        -: 3479:               to an empty pattern.  */
      129: 3480:            if (!laststart)  
branch  0 taken 0 (fallthrough)
branch  1 taken 129
    #####: 3481:              break;
        -: 3482:
        -: 3483:            /* Now we know whether or not zero matches is allowed
        -: 3484:               and also whether or not two or more matches is allowed.  */
      129: 3485:            if (many_times_ok)
branch  0 taken 129 (fallthrough)
branch  1 taken 0
        -: 3486:              { /* More than one repetition is allowed, so put in at the
        -: 3487:                   end a backward relative jump from `b' to before the next
        -: 3488:                   jump we're going to put in below (which jumps from
        -: 3489:                   laststart to after this jump).  
        -: 3490:
        -: 3491:                   But if we are at the `*' in the exact sequence `.*\n',
        -: 3492:                   insert an unconditional jump backwards to the .,
        -: 3493:                   instead of the beginning of the loop.  This way we only
        -: 3494:                   push a failure point once, instead of every time
        -: 3495:                   through the loop.  */
        -: 3496:                assert (p - 1 > pattern);
        -: 3497:
        -: 3498:                /* Allocate the space for the jump.  */
     131*: 3499:                GET_BUFFER_SPACE (3);
branch  0 taken 0 (fallthrough)
branch  1 taken 2
branch  2 taken 0 (fallthrough)
branch  3 taken 2
branch  4 taken 0 (fallthrough)
branch  5 taken 2
branch  6 taken 2 (fallthrough)
branch  7 taken 0
branch  8 taken 0 (fallthrough)
branch  9 taken 2
branch 10 taken 2 (fallthrough)
branch 11 taken 0
branch 12 taken 0 (fallthrough)
branch 13 taken 2
branch 14 taken 2
branch 15 taken 129 (fallthrough)
        -: 3500:
        -: 3501:                /* We know we are not at the first character of the pattern,
        -: 3502:                   because laststart was nonzero.  And we've already
        -: 3503:                   incremented `p', by the way, to be the character after
        -: 3504:                   the `*'.  Do we have to do something analogous here
        -: 3505:                   for null bytes, because of RE_DOT_NOT_NULL?  */
     129*: 3506:                if (TRANSLATE (*(p - 2)) == TRANSLATE ('.')
branch  0 taken 0 (fallthrough)
branch  1 taken 129
branch  2 taken 0 (fallthrough)
branch  3 taken 129
branch  4 taken 121 (fallthrough)
branch  5 taken 8
      121: 3507:		    && zero_times_ok
branch  0 taken 121 (fallthrough)
branch  1 taken 0
     121*: 3508:                    && p < pend && TRANSLATE (*p) == TRANSLATE ('\n')
branch  0 taken 56 (fallthrough)
branch  1 taken 65
branch  2 taken 0 (fallthrough)
branch  3 taken 56
branch  4 taken 0 (fallthrough)
branch  5 taken 56
branch  6 taken 0 (fallthrough)
branch  7 taken 56
    #####: 3509:                    && !(syntax & RE_DOT_NEWLINE))
branch  0 never executed
branch  1 never executed
        -: 3510:                  { /* We have .*\n.  */
    #####: 3511:                    STORE_JUMP (jump, b, laststart);
call    0 never executed
    #####: 3512:                    keep_string_p = true;
        -: 3513:                  }
        -: 3514:                else
        -: 3515:                  /* Anything else.  */
      129: 3516:                  STORE_JUMP (maybe_pop_jump, b, laststart - 3);
call    0 returned 129
        -: 3517:
        -: 3518:                /* We've added more stuff to the buffer.  */
      129: 3519:                b += 3;
        -: 3520:              }
        -: 3521:
        -: 3522:            /* On failure, jump from laststart to b + 3, which will be the
        -: 3523:               end of the buffer after this jump is inserted.  */
     158*: 3524:            GET_BUFFER_SPACE (3);
branch  0 taken 0 (fallthrough)
branch  1 taken 29
branch  2 taken 0 (fallthrough)
branch  3 taken 29
branch  4 taken 0 (fallthrough)
branch  5 taken 29
branch  6 taken 29 (fallthrough)
branch  7 taken 0
branch  8 taken 0 (fallthrough)
branch  9 taken 29
branch 10 taken 29 (fallthrough)
branch 11 taken 0
branch 12 taken 29 (fallthrough)
branch 13 taken 0
branch 14 taken 29
branch 15 taken 129 (fallthrough)
     129*: 3525:            INSERT_JUMP (keep_string_p ? on_failure_keep_string_jump
branch  0 taken 0 (fallthrough)
branch  1 taken 129
call    2 returned 129
        -: 3526:                                       : on_failure_jump,
        -: 3527:                         laststart, b + 3);
      129: 3528:            pending_exact = 0;
      129: 3529:            b += 3;
        -: 3530:
      129: 3531:            if (!zero_times_ok)
branch  0 taken 0 (fallthrough)
branch  1 taken 129
        -: 3532:              {
        -: 3533:                /* At least one repetition is required, so insert a
        -: 3534:                   `dummy_failure_jump' before the initial
        -: 3535:                   `on_failure_jump' instruction of the loop. This
        -: 3536:                   effects a skip over that instruction the first time
        -: 3537:                   we hit that loop.  */
    #####: 3538:                GET_BUFFER_SPACE (3);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
    #####: 3539:                INSERT_JUMP (dummy_failure_jump, laststart, laststart + 6);
call    0 never executed
    #####: 3540:                b += 3;
        -: 3541:              }
        -: 3542:            }
      129: 3543:	  break;
        -: 3544:
        -: 3545:
      121: 3546:	case '.':
      121: 3547:          laststart = b;
     121*: 3548:          BUF_PUSH (anychar);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 taken 0
branch 15 taken 121 (fallthrough)
      121: 3549:          break;
        -: 3550:
        -: 3551:
        5: 3552:        case '[':
        -: 3553:          {
        5: 3554:            boolean had_char_class = false;
        -: 3555:
       5*: 3556:            if (p == pend) return REG_EBRACK;
branch  0 taken 0 (fallthrough)
branch  1 taken 5
        -: 3557:
        -: 3558:            /* Ensure that we have enough space to push a charset: the
        -: 3559:               opcode, the length count, and the bitset; 34 bytes in all.  */
      11*: 3560:	    GET_BUFFER_SPACE (34);
branch  0 taken 0 (fallthrough)
branch  1 taken 6
branch  2 taken 0 (fallthrough)
branch  3 taken 6
branch  4 taken 0 (fallthrough)
branch  5 taken 6
branch  6 taken 5 (fallthrough)
branch  7 taken 1
branch  8 taken 0 (fallthrough)
branch  9 taken 5
branch 10 taken 2 (fallthrough)
branch 11 taken 3
branch 12 taken 2 (fallthrough)
branch 13 taken 3
branch 14 taken 6
branch 15 taken 5 (fallthrough)
        -: 3561:
        5: 3562:            laststart = b;
        -: 3563:
        -: 3564:            /* We test `*p == '^' twice, instead of using an if
        -: 3565:               statement, so we only need one BUF_PUSH.  */
       5*: 3566:            BUF_PUSH (*p == '^' ? charset_not : charset); 
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 taken 0
branch 15 taken 5 (fallthrough)
branch 16 taken 1 (fallthrough)
branch 17 taken 4
        5: 3567:            if (*p == '^')
branch  0 taken 1 (fallthrough)
branch  1 taken 4
        1: 3568:              p++;
        -: 3569:
        -: 3570:            /* Remember the first position in the bracket expression.  */
        5: 3571:            p1 = p;
        -: 3572:
        -: 3573:            /* Push the number of bytes in the bitmap.  */
       5*: 3574:            BUF_PUSH ((1 << BYTEWIDTH) / BYTEWIDTH);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 taken 0
branch 15 taken 5 (fallthrough)
        -: 3575:
        -: 3576:            /* Clear the whole map.  */
        5: 3577:            bzero (b, (1 << BYTEWIDTH) / BYTEWIDTH);
        -: 3578:
        -: 3579:            /* charset_not matches newline according to a syntax bit.  */
        5: 3580:            if ((re_opcode_t) b[-2] == charset_not
branch  0 taken 1 (fallthrough)
branch  1 taken 4
        1: 3581:                && (syntax & RE_HAT_LISTS_NOT_NEWLINE))
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 3582:              SET_LIST_BIT ('\n');
        -: 3583:
        -: 3584:            /* Read in characters and ranges, setting map bits.  */
        -: 3585:            for (;;)
        -: 3586:              {
      36*: 3587:                if (p == pend) return REG_EBRACK;
branch  0 taken 0 (fallthrough)
branch  1 taken 36
        -: 3588:
      36*: 3589:                PATFETCH (c);
branch  0 taken 0 (fallthrough)
branch  1 taken 36
branch  2 taken 0 (fallthrough)
branch  3 taken 36
        -: 3590:
        -: 3591:                /* \ might escape characters inside [...] and [^...].  */
      36*: 3592:                if ((syntax & RE_BACKSLASH_ESCAPE_IN_LISTS) && c == '\\')
branch  0 taken 0 (fallthrough)
branch  1 taken 36
branch  2 never executed
branch  3 never executed
        -: 3593:                  {
    #####: 3594:                    if (p == pend) return REG_EESCAPE;
branch  0 never executed
branch  1 never executed
        -: 3595:
    #####: 3596:                    PATFETCH (c1);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3597:                    SET_LIST_BIT (c1);
    #####: 3598:                    continue;
        -: 3599:                  }
        -: 3600:
        -: 3601:                /* Could be the end of the bracket expression.  If it's
        -: 3602:                   not (i.e., when the bracket expression is `[]' so
        -: 3603:                   far), the ']' character bit gets set way below.  */
       36: 3604:                if (c == ']' && p != p1 + 1)
branch  0 taken 5 (fallthrough)
branch  1 taken 31
branch  2 taken 5 (fallthrough)
branch  3 taken 0
        5: 3605:                  break;
        -: 3606:
        -: 3607:                /* Look ahead to see if it's a range when the last thing
        -: 3608:                   was a character class.  */
      31*: 3609:                if (had_char_class && c == '-' && *p != ']')
branch  0 taken 0 (fallthrough)
branch  1 taken 31
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 3610:                  return REG_ERANGE;
        -: 3611:
        -: 3612:                /* Look ahead to see if it's a range when the last thing
        -: 3613:                   was a character: if this is a hyphen not at the
        -: 3614:                   beginning or the end of a list, then it's the range
        -: 3615:                   operator.  */
       31: 3616:                if (c == '-' 
branch  0 taken 0 (fallthrough)
branch  1 taken 31
    #####: 3617:                    && !(p - 2 >= pattern && p[-2] == '[') 
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3618:                    && !(p - 3 >= pattern && p[-3] == '[' && p[-2] == '^')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 3619:                    && *p != ']')
branch  0 never executed
branch  1 never executed
    #####: 3620:                  {
        -: 3621:                    reg_errcode_t ret
    #####: 3622:                      = compile_range (&p, pend, translate, syntax, b);
call    0 never executed
    #####: 3623:                    if (ret != REG_NOERROR) return ret;
branch  0 never executed
branch  1 never executed
        -: 3624:                  }
        -: 3625:
      31*: 3626:                else if (p[0] == '-' && p[1] != ']')
branch  0 taken 0 (fallthrough)
branch  1 taken 31
branch  2 never executed
branch  3 never executed
    #####: 3627:                  { /* This handles ranges made up of characters only.  */
        -: 3628:                    reg_errcode_t ret;
        -: 3629:
        -: 3630:		    /* Move past the `-'.  */
    #####: 3631:                    PATFETCH (c1);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 3632:                    
    #####: 3633:                    ret = compile_range (&p, pend, translate, syntax, b);
call    0 never executed
    #####: 3634:                    if (ret != REG_NOERROR) return ret;
branch  0 never executed
branch  1 never executed
        -: 3635:                  }
        -: 3636:
        -: 3637:                /* See if we're at the beginning of a possible character
        -: 3638:                   class.  */
        -: 3639:
      31*: 3640:                else if (syntax & RE_CHAR_CLASSES && c == '[' && *p == ':')
branch  0 taken 31 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 31
branch  4 never executed
branch  5 never executed
    #####: 3641:                  { /* Leave room for the null.  */
        -: 3642:                    char str[CHAR_CLASS_MAX_LENGTH + 1];
        -: 3643:
    #####: 3644:                    PATFETCH (c);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3645:                    c1 = 0;
        -: 3646:
        -: 3647:                    /* If pattern is `[[:'.  */
    #####: 3648:                    if (p == pend) return REG_EBRACK;
branch  0 never executed
branch  1 never executed
        -: 3649:
        -: 3650:                    for (;;)
        -: 3651:                      {
    #####: 3652:                        PATFETCH (c);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3653:                        if (c == ':' || c == ']' || p == pend
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 3654:                            || c1 == CHAR_CLASS_MAX_LENGTH)
branch  0 never executed
branch  1 never executed
        -: 3655:                          break;
    #####: 3656:                        str[c1++] = c;
        -: 3657:                      }
    #####: 3658:                    str[c1] = '\0';
        -: 3659:
        -: 3660:                    /* If isn't a word bracketed by `[:' and:`]':
        -: 3661:                       undo the ending character, the letters, and leave 
        -: 3662:                       the leading `:' and `[' (but set bits for them).  */
    #####: 3663:                    if (c == ':' && *p == ']')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3664:                      {
        -: 3665:                        int ch;
    #####: 3666:                        boolean is_alnum = STREQ (str, "alnum");
    #####: 3667:                        boolean is_alpha = STREQ (str, "alpha");
    #####: 3668:                        boolean is_blank = STREQ (str, "blank");
    #####: 3669:                        boolean is_cntrl = STREQ (str, "cntrl");
    #####: 3670:                        boolean is_digit = STREQ (str, "digit");
    #####: 3671:                        boolean is_graph = STREQ (str, "graph");
    #####: 3672:                        boolean is_lower = STREQ (str, "lower");
    #####: 3673:                        boolean is_print = STREQ (str, "print");
    #####: 3674:                        boolean is_punct = STREQ (str, "punct");
    #####: 3675:                        boolean is_space = STREQ (str, "space");
    #####: 3676:                        boolean is_upper = STREQ (str, "upper");
    #####: 3677:                        boolean is_xdigit = STREQ (str, "xdigit");
        -: 3678:                        
    #####: 3679:                        if (!IS_CHAR_CLASS (str)) return REG_ECTYPE;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
branch 21 never executed
branch 22 never executed
branch 23 never executed
        -: 3680:
        -: 3681:                        /* Throw away the ] at the end of the character
        -: 3682:                           class.  */
    #####: 3683:                        PATFETCH (c);					
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 3684:
    #####: 3685:                        if (p == pend) return REG_EBRACK;
branch  0 never executed
branch  1 never executed
        -: 3686:
    #####: 3687:                        for (ch = 0; ch < 1 << BYTEWIDTH; ch++)
branch  0 never executed
branch  1 never executed
        -: 3688:                          {
    #####: 3689:                            if (   (is_alnum  && ISALNUM (ch))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 3690:                                || (is_alpha  && ISALPHA (ch))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 3691:                                || (is_blank  && ISBLANK (ch))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 3692:                                || (is_cntrl  && ISCNTRL (ch))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 3693:                                || (is_digit  && ISDIGIT (ch))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 3694:                                || (is_graph  && ISGRAPH (ch))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 3695:                                || (is_lower  && ISLOWER (ch))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 3696:                                || (is_print  && ISPRINT (ch))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 3697:                                || (is_punct  && ISPUNCT (ch))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 3698:                                || (is_space  && ISSPACE (ch))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 3699:                                || (is_upper  && ISUPPER (ch))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 3700:                                || (is_xdigit && ISXDIGIT (ch)))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 3701:                            SET_LIST_BIT (ch);
        -: 3702:                          }
    #####: 3703:                        had_char_class = true;
        -: 3704:                      }
        -: 3705:                    else
        -: 3706:                      {
    #####: 3707:                        c1++;
    #####: 3708:                        while (c1--)    
branch  0 never executed
branch  1 never executed
    #####: 3709:                          PATUNFETCH;
    #####: 3710:                        SET_LIST_BIT ('[');
    #####: 3711:                        SET_LIST_BIT (':');
    #####: 3712:                        had_char_class = false;
        -: 3713:                      }
        -: 3714:                  }
        -: 3715:                else
        -: 3716:                  {
       31: 3717:                    had_char_class = false;
       31: 3718:                    SET_LIST_BIT (c);
        -: 3719:                  }
        -: 3720:              }
        -: 3721:
        -: 3722:            /* Discard any (non)matching list bytes that are all 0 at the
        -: 3723:               end of the map.  Decrease the map-length byte too.  */
       89: 3724:            while ((int) b[-1] > 0 && b[b[-1] - 1] == 0) 
branch  0 taken 89 (fallthrough)
branch  1 taken 0
branch  2 taken 84
branch  3 taken 5 (fallthrough)
       84: 3725:              b[-1]--; 
        5: 3726:            b += b[-1];
        -: 3727:          }
        5: 3728:          break;
        -: 3729:
        -: 3730:
    #####: 3731:	case '(':
    #####: 3732:          if (syntax & RE_NO_BK_PARENS)
branch  0 never executed
branch  1 never executed
    #####: 3733:            goto handle_open;
        -: 3734:          else
    #####: 3735:            goto normal_char;
        -: 3736:
        -: 3737:
    #####: 3738:        case ')':
    #####: 3739:          if (syntax & RE_NO_BK_PARENS)
branch  0 never executed
branch  1 never executed
    #####: 3740:            goto handle_close;
        -: 3741:          else
    #####: 3742:            goto normal_char;
        -: 3743:
        -: 3744:
       12: 3745:        case '\n':
       12: 3746:          if (syntax & RE_NEWLINE_ALT)
branch  0 taken 0 (fallthrough)
branch  1 taken 12
    #####: 3747:            goto handle_alt;
        -: 3748:          else
       12: 3749:            goto normal_char;
        -: 3750:
        -: 3751:
    #####: 3752:	case '|':
    #####: 3753:          if (syntax & RE_NO_BK_VBAR)
branch  0 never executed
branch  1 never executed
    #####: 3754:            goto handle_alt;
        -: 3755:          else
    #####: 3756:            goto normal_char;
        -: 3757:
        -: 3758:
    #####: 3759:        case '{':
    #####: 3760:           if (syntax & RE_INTERVALS && syntax & RE_NO_BK_BRACES)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3761:             goto handle_interval;
        -: 3762:           else
    #####: 3763:             goto normal_char;
        -: 3764:
        -: 3765:
      591: 3766:        case '\\':
     591*: 3767:          if (p == pend) return REG_EESCAPE;
branch  0 taken 0 (fallthrough)
branch  1 taken 591
        -: 3768:
        -: 3769:          /* Do not translate the character after the \, so that we can
        -: 3770:             distinguish, e.g., \B from \b, even if we normally would
        -: 3771:             translate, e.g., B to b.  */
     591*: 3772:          PATFETCH_RAW (c);
branch  0 taken 0 (fallthrough)
branch  1 taken 591
        -: 3773:
      591: 3774:          switch (c)
branch  0 taken 12
branch  1 taken 12
branch  2 taken 0
branch  3 taken 1
branch  4 taken 0
branch  5 taken 0
branch  6 taken 0
branch  7 taken 0
branch  8 taken 0
branch  9 taken 0
branch 10 taken 152
branch 11 taken 102
branch 12 taken 0
branch 13 taken 0
branch 14 taken 312
        -: 3775:            {
       12: 3776:            case '(':
       12: 3777:              if (syntax & RE_NO_BK_PARENS)
branch  0 taken 0 (fallthrough)
branch  1 taken 12
    #####: 3778:                goto normal_backslash;
        -: 3779:
       12: 3780:            handle_open:
       12: 3781:              bufp->re_nsub++;
       12: 3782:              regnum++;
        -: 3783:
       12: 3784:              if (COMPILE_STACK_FULL)
branch  0 taken 0 (fallthrough)
branch  1 taken 12
        -: 3785:                { 
    #####: 3786:                  RETALLOC (compile_stack.stack, compile_stack.size << 1,
        -: 3787:                            compile_stack_elt_t);
    #####: 3788:                  if (compile_stack.stack == NULL) return REG_ESPACE;
branch  0 never executed
branch  1 never executed
        -: 3789:
    #####: 3790:                  compile_stack.size <<= 1;
        -: 3791:                }
        -: 3792:
        -: 3793:              /* These are the values to restore when we hit end of this
        -: 3794:                 group.  They are all relative offsets, so that if the
        -: 3795:                 whole pattern moves because of realloc, they will still
        -: 3796:                 be valid.  */
       12: 3797:              COMPILE_STACK_TOP.begalt_offset = begalt - bufp->buffer;
       12: 3798:              COMPILE_STACK_TOP.fixup_alt_jump 
      12*: 3799:                = fixup_alt_jump ? fixup_alt_jump - bufp->buffer + 1 : 0;
branch  0 taken 0 (fallthrough)
branch  1 taken 12
       12: 3800:              COMPILE_STACK_TOP.laststart_offset = b - bufp->buffer;
       12: 3801:              COMPILE_STACK_TOP.regnum = regnum;
        -: 3802:
        -: 3803:              /* We will eventually replace the 0 with the number of
        -: 3804:                 groups inner to this one.  But do not push a
        -: 3805:                 start_memory for groups beyond the last one we can
        -: 3806:                 represent in the compiled pattern.  */
       12: 3807:              if (regnum <= MAX_REGNUM)
branch  0 taken 12 (fallthrough)
branch  1 taken 0
        -: 3808:                {
       12: 3809:                  COMPILE_STACK_TOP.inner_group_offset = b - bufp->buffer + 2;
      12*: 3810:                  BUF_PUSH_3 (start_memory, regnum, 0);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 taken 0
branch 15 taken 12 (fallthrough)
        -: 3811:                }
        -: 3812:                
       12: 3813:              compile_stack.avail++;
        -: 3814:
       12: 3815:              fixup_alt_jump = 0;
       12: 3816:              laststart = 0;
       12: 3817:              begalt = b;
        -: 3818:	      /* If we've reached MAX_REGNUM groups, then this open
        -: 3819:		 won't actually generate any code, so we'll have to
        -: 3820:		 clear pending_exact explicitly.  */
       12: 3821:	      pending_exact = 0;
       12: 3822:              break;
        -: 3823:
        -: 3824:
       12: 3825:            case ')':
      12*: 3826:              if (syntax & RE_NO_BK_PARENS) goto normal_backslash;
branch  0 taken 0 (fallthrough)
branch  1 taken 12
        -: 3827:
       12: 3828:              if (COMPILE_STACK_EMPTY)
branch  0 taken 0 (fallthrough)
branch  1 taken 12
    #####: 3829:                if (syntax & RE_UNMATCHED_RIGHT_PAREN_ORD)
branch  0 never executed
branch  1 never executed
    #####: 3830:                  goto normal_backslash;
        -: 3831:                else
    #####: 3832:                  return REG_ERPAREN;
        -: 3833:
       12: 3834:            handle_close:
       12: 3835:              if (fixup_alt_jump)
branch  0 taken 0 (fallthrough)
branch  1 taken 12
        -: 3836:                { /* Push a dummy failure point at the end of the
        -: 3837:                     alternative for a possible future
        -: 3838:                     `pop_failure_jump' to pop.  See comments at
        -: 3839:                     `push_dummy_failure' in `re_match_2'.  */
    #####: 3840:                  BUF_PUSH (push_dummy_failure);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
        -: 3841:                  
        -: 3842:                  /* We allocated space for this jump when we assigned
        -: 3843:                     to `fixup_alt_jump', in the `handle_alt' case below.  */
    #####: 3844:                  STORE_JUMP (jump_past_alt, fixup_alt_jump, b - 1);
call    0 never executed
        -: 3845:                }
        -: 3846:
        -: 3847:              /* See similar code for backslashed left paren above.  */
       12: 3848:              if (COMPILE_STACK_EMPTY)
branch  0 taken 0 (fallthrough)
branch  1 taken 12
    #####: 3849:                if (syntax & RE_UNMATCHED_RIGHT_PAREN_ORD)
branch  0 never executed
branch  1 never executed
    #####: 3850:                  goto normal_char;
        -: 3851:                else
    #####: 3852:                  return REG_ERPAREN;
        -: 3853:
        -: 3854:              /* Since we just checked for an empty stack above, this
        -: 3855:                 ``can't happen''.  */
        -: 3856:              assert (compile_stack.avail != 0);
        -: 3857:              {
        -: 3858:                /* We don't just want to restore into `regnum', because
        -: 3859:                   later groups should continue to be numbered higher,
        -: 3860:                   as in `(ab)c(de)' -- the second group is #2.  */
        -: 3861:                regnum_t this_group_regnum;
        -: 3862:
       12: 3863:                compile_stack.avail--;		
       12: 3864:                begalt = bufp->buffer + COMPILE_STACK_TOP.begalt_offset;
        -: 3865:                fixup_alt_jump
       24: 3866:                  = COMPILE_STACK_TOP.fixup_alt_jump
    #####: 3867:                    ? bufp->buffer + COMPILE_STACK_TOP.fixup_alt_jump - 1 
      12*: 3868:                    : 0;
branch  0 taken 0 (fallthrough)
branch  1 taken 12
       12: 3869:                laststart = bufp->buffer + COMPILE_STACK_TOP.laststart_offset;
       12: 3870:                this_group_regnum = COMPILE_STACK_TOP.regnum;
        -: 3871:		/* If we've reached MAX_REGNUM groups, then this open
        -: 3872:		   won't actually generate any code, so we'll have to
        -: 3873:		   clear pending_exact explicitly.  */
       12: 3874:		pending_exact = 0;
        -: 3875:
        -: 3876:                /* We're at the end of the group, so now we know how many
        -: 3877:                   groups were inside this one.  */
       12: 3878:                if (this_group_regnum <= MAX_REGNUM)
branch  0 taken 12 (fallthrough)
branch  1 taken 0
        -: 3879:                  {
       12: 3880:                    unsigned char *inner_group_loc
       12: 3881:                      = bufp->buffer + COMPILE_STACK_TOP.inner_group_offset;
        -: 3882:                    
       12: 3883:                    *inner_group_loc = regnum - this_group_regnum;
      12*: 3884:                    BUF_PUSH_3 (stop_memory, this_group_regnum,
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 taken 0
branch 15 taken 12 (fallthrough)
        -: 3885:                                regnum - this_group_regnum);
        -: 3886:                  }
        -: 3887:              }
       12: 3888:              break;
        -: 3889:
        -: 3890:
    #####: 3891:            case '|':					/* `\|'.  */
    #####: 3892:              if (syntax & RE_LIMITED_OPS || syntax & RE_NO_BK_VBAR)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3893:                goto normal_backslash;
    #####: 3894:            handle_alt:
    #####: 3895:              if (syntax & RE_LIMITED_OPS)
branch  0 never executed
branch  1 never executed
    #####: 3896:                goto normal_char;
        -: 3897:
        -: 3898:              /* Insert before the previous alternative a jump which
        -: 3899:                 jumps to this alternative if the former fails.  */
    #####: 3900:              GET_BUFFER_SPACE (3);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
    #####: 3901:              INSERT_JUMP (on_failure_jump, begalt, b + 6);
call    0 never executed
    #####: 3902:              pending_exact = 0;
    #####: 3903:              b += 3;
        -: 3904:
        -: 3905:              /* The alternative before this one has a jump after it
        -: 3906:                 which gets executed if it gets matched.  Adjust that
        -: 3907:                 jump so it will jump to this alternative's analogous
        -: 3908:                 jump (put in below, which in turn will jump to the next
        -: 3909:                 (if any) alternative's such jump, etc.).  The last such
        -: 3910:                 jump jumps to the correct final destination.  A picture:
        -: 3911:                          _____ _____ 
        -: 3912:                          |   | |   |   
        -: 3913:                          |   v |   v 
        -: 3914:                         a | b   | c   
        -: 3915:
        -: 3916:                 If we are at `b', then fixup_alt_jump right now points to a
        -: 3917:                 three-byte space after `a'.  We'll put in the jump, set
        -: 3918:                 fixup_alt_jump to right after `b', and leave behind three
        -: 3919:                 bytes which we'll fill in when we get to after `c'.  */
        -: 3920:
    #####: 3921:              if (fixup_alt_jump)
branch  0 never executed
branch  1 never executed
    #####: 3922:                STORE_JUMP (jump_past_alt, fixup_alt_jump, b);
call    0 never executed
        -: 3923:
        -: 3924:              /* Mark and leave space for a jump after this alternative,
        -: 3925:                 to be filled in later either by next alternative or
        -: 3926:                 when know we're at the end of a series of alternatives.  */
    #####: 3927:              fixup_alt_jump = b;
    #####: 3928:              GET_BUFFER_SPACE (3);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
    #####: 3929:              b += 3;
        -: 3930:
    #####: 3931:              laststart = 0;
    #####: 3932:              begalt = b;
    #####: 3933:              break;
        -: 3934:
        -: 3935:
        1: 3936:            case '{': 
        -: 3937:              /* If \{ is a literal.  */
        1: 3938:              if (!(syntax & RE_INTERVALS)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -: 3939:                     /* If we're at `\{' and it's not the open-interval 
        -: 3940:                        operator.  */
        1: 3941:                  || ((syntax & RE_INTERVALS) && (syntax & RE_NO_BK_BRACES))
branch  0 taken 1 (fallthrough)
branch  1 taken 0
branch  2 taken 1 (fallthrough)
branch  3 taken 0
       1*: 3942:                  || (p - 2 == pattern  &&  p == pend))
branch  0 taken 0 (fallthrough)
branch  1 taken 1
branch  2 never executed
branch  3 never executed
    #####: 3943:                goto normal_backslash;
        -: 3944:
       1*: 3945:            handle_interval:
        -: 3946:              {
        -: 3947:                /* If got here, then the syntax allows intervals.  */
        -: 3948:
        -: 3949:                /* At least (most) this many matches must be made.  */
        1: 3950:                int lower_bound = -1, upper_bound = -1;
        -: 3951:
        1: 3952:                beg_interval = p - 1;
        -: 3953:
        1: 3954:                if (p == pend)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -: 3955:                  {
    #####: 3956:                    if (syntax & RE_NO_BK_BRACES)
branch  0 never executed
branch  1 never executed
    #####: 3957:                      goto unfetch_interval;
        -: 3958:                    else
    #####: 3959:                      return REG_EBRACE;
        -: 3960:                  }
        -: 3961:
       2*: 3962:                GET_UNSIGNED_NUMBER (lower_bound);
branch  0 taken 1 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 1
branch  4 taken 0 (fallthrough)
branch  5 taken 1
branch  6 taken 1 (fallthrough)
branch  7 taken 0
branch  8 taken 0 (fallthrough)
branch  9 taken 1
branch 10 taken 0 (fallthrough)
branch 11 taken 1
branch 12 taken 0 (fallthrough)
branch 13 taken 1
branch 14 taken 2 (fallthrough)
branch 15 taken 0
branch 16 taken 1
branch 17 taken 1 (fallthrough)
        -: 3963:
        1: 3964:                if (c == ',')
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -: 3965:                  {
       2*: 3966:                    GET_UNSIGNED_NUMBER (upper_bound);
branch  0 taken 1 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 1
branch  4 taken 0 (fallthrough)
branch  5 taken 1
branch  6 taken 1 (fallthrough)
branch  7 taken 0
branch  8 taken 0 (fallthrough)
branch  9 taken 1
branch 10 taken 0 (fallthrough)
branch 11 taken 1
branch 12 taken 0 (fallthrough)
branch 13 taken 1
branch 14 taken 2 (fallthrough)
branch 15 taken 0
branch 16 taken 1
branch 17 taken 1 (fallthrough)
       1*: 3967:                    if (upper_bound < 0) upper_bound = RE_DUP_MAX;
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -: 3968:                  }
        -: 3969:                else
        -: 3970:                  /* Interval such as `{1}' => match exactly once. */
    #####: 3971:                  upper_bound = lower_bound;
        -: 3972:
        1: 3973:                if (lower_bound < 0 || upper_bound > RE_DUP_MAX
branch  0 taken 1 (fallthrough)
branch  1 taken 0
branch  2 taken 1 (fallthrough)
branch  3 taken 0
        1: 3974:                    || lower_bound > upper_bound)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -: 3975:                  {
    #####: 3976:                    if (syntax & RE_NO_BK_BRACES)
branch  0 never executed
branch  1 never executed
    #####: 3977:                      goto unfetch_interval;
        -: 3978:                    else 
    #####: 3979:                      return REG_BADBR;
        -: 3980:                  }
        -: 3981:
        1: 3982:                if (!(syntax & RE_NO_BK_BRACES)) 
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -: 3983:                  {
       1*: 3984:                    if (c != '\\') return REG_EBRACE;
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -: 3985:
       1*: 3986:                    PATFETCH (c);
branch  0 taken 0 (fallthrough)
branch  1 taken 1
branch  2 taken 0 (fallthrough)
branch  3 taken 1
        -: 3987:                  }
        -: 3988:
        1: 3989:                if (c != '}')
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -: 3990:                  {
    #####: 3991:                    if (syntax & RE_NO_BK_BRACES)
branch  0 never executed
branch  1 never executed
    #####: 3992:                      goto unfetch_interval;
        -: 3993:                    else 
    #####: 3994:                      return REG_BADBR;
        -: 3995:                  }
        -: 3996:
        -: 3997:                /* We just parsed a valid interval.  */
        -: 3998:
        -: 3999:                /* If it's invalid to have no preceding re.  */
        1: 4000:                if (!laststart)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -: 4001:                  {
    #####: 4002:                    if (syntax & RE_CONTEXT_INVALID_OPS)
branch  0 never executed
branch  1 never executed
    #####: 4003:                      return REG_BADRPT;
    #####: 4004:                    else if (syntax & RE_CONTEXT_INDEP_OPS)
branch  0 never executed
branch  1 never executed
    #####: 4005:                      laststart = b;
        -: 4006:                    else
    #####: 4007:                      goto unfetch_interval;
        -: 4008:                  }
        -: 4009:
        -: 4010:                /* If the upper bound is zero, don't want to succeed at
        -: 4011:                   all; jump from `laststart' to `b + 3', which will be
        -: 4012:                   the end of the buffer after we insert the jump.  */
        1: 4013:                 if (upper_bound == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -: 4014:                   {
    #####: 4015:                     GET_BUFFER_SPACE (3);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
    #####: 4016:                     INSERT_JUMP (jump, laststart, b + 3);
call    0 never executed
    #####: 4017:                     b += 3;
        -: 4018:                   }
        -: 4019:
        -: 4020:                 /* Otherwise, we have a nontrivial interval.  When
        -: 4021:                    we're all done, the pattern will look like:
        -: 4022:                      set_number_at <jump count> <upper bound>
        -: 4023:                      set_number_at <succeed_n count> <lower bound>
        -: 4024:                      succeed_n <after jump addr> <succed_n count>
        -: 4025:                      <body of loop>
        -: 4026:                      jump_n <succeed_n addr> <jump count>
        -: 4027:                    (The upper bound and `jump_n' are omitted if
        -: 4028:                    `upper_bound' is 1, though.)  */
        -: 4029:                 else 
        -: 4030:                   { /* If the upper bound is > 1, we need to insert
        -: 4031:                        more at the end of the loop.  */
       1*: 4032:                     unsigned nbytes = 10 + (upper_bound > 1) * 10;
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -: 4033:
       2*: 4034:                     GET_BUFFER_SPACE (nbytes);
branch  0 taken 0 (fallthrough)
branch  1 taken 1
branch  2 taken 0 (fallthrough)
branch  3 taken 1
branch  4 taken 0 (fallthrough)
branch  5 taken 1
branch  6 taken 1 (fallthrough)
branch  7 taken 0
branch  8 taken 0 (fallthrough)
branch  9 taken 1
branch 10 taken 1 (fallthrough)
branch 11 taken 0
branch 12 taken 1 (fallthrough)
branch 13 taken 0
branch 14 taken 1
branch 15 taken 1 (fallthrough)
        -: 4035:
        -: 4036:                     /* Initialize lower bound of the `succeed_n', even
        -: 4037:                        though it will be set during matching by its
        -: 4038:                        attendant `set_number_at' (inserted next),
        -: 4039:                        because `re_compile_fastmap' needs to know.
        -: 4040:                        Jump to the `jump_n' we might insert below.  */
       1*: 4041:                     INSERT_JUMP2 (succeed_n, laststart,
branch  0 taken 1 (fallthrough)
branch  1 taken 0
call    2 returned 1
        -: 4042:                                   b + 5 + (upper_bound > 1) * 5,
        -: 4043:                                   lower_bound);
        1: 4044:                     b += 5;
        -: 4045:
        -: 4046:                     /* Code to initialize the lower bound.  Insert 
        -: 4047:                        before the `succeed_n'.  The `5' is the last two
        -: 4048:                        bytes of this `set_number_at', plus 3 bytes of
        -: 4049:                        the following `succeed_n'.  */
        1: 4050:                     insert_op2 (set_number_at, laststart, 5, lower_bound, b);
call    0 returned 1
        1: 4051:                     b += 5;
        -: 4052:
        1: 4053:                     if (upper_bound > 1)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -: 4054:                       { /* More than one repetition is allowed, so
        -: 4055:                            append a backward jump to the `succeed_n'
        -: 4056:                            that starts this interval.
        -: 4057:                            
        -: 4058:                            When we've reached this during matching,
        -: 4059:                            we'll have matched the interval once, so
        -: 4060:                            jump back only `upper_bound - 1' times.  */
        1: 4061:                         STORE_JUMP2 (jump_n, b, laststart + 5,
call    0 returned 1
        -: 4062:                                      upper_bound - 1);
        1: 4063:                         b += 5;
        -: 4064:
        -: 4065:                         /* The location we want to set is the second
        -: 4066:                            parameter of the `jump_n'; that is `b-2' as
        -: 4067:                            an absolute address.  `laststart' will be
        -: 4068:                            the `set_number_at' we're about to insert;
        -: 4069:                            `laststart+3' the number to set, the source
        -: 4070:                            for the relative address.  But we are
        -: 4071:                            inserting into the middle of the pattern --
        -: 4072:                            so everything is getting moved up by 5.
        -: 4073:                            Conclusion: (b - 2) - (laststart + 3) + 5,
        -: 4074:                            i.e., b - laststart.
        -: 4075:                            
        -: 4076:                            We insert this at the beginning of the loop
        -: 4077:                            so that if we fail during matching, we'll
        -: 4078:                            reinitialize the bounds.  */
        1: 4079:                         insert_op2 (set_number_at, laststart, b - laststart,
call    0 returned 1
        -: 4080:                                     upper_bound - 1, b);
        1: 4081:                         b += 5;
        -: 4082:                       }
        -: 4083:                   }
        1: 4084:                pending_exact = 0;
        1: 4085:                beg_interval = NULL;
        -: 4086:              }
        1: 4087:              break;
        -: 4088:
    #####: 4089:            unfetch_interval:
        -: 4090:              /* If an invalid interval, match the characters as literals.  */
        -: 4091:               assert (beg_interval);
    #####: 4092:               p = beg_interval;
    #####: 4093:               beg_interval = NULL;
        -: 4094:
        -: 4095:               /* normal_char and normal_backslash need `c'.  */
    #####: 4096:               PATFETCH (c);	
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 4097:
    #####: 4098:               if (!(syntax & RE_NO_BK_BRACES))
branch  0 never executed
branch  1 never executed
        -: 4099:                 {
    #####: 4100:                   if (p > pattern  &&  p[-1] == '\\')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4101:                     goto normal_backslash;
        -: 4102:                 }
    #####: 4103:               goto normal_char;
        -: 4104:
        -: 4105:#ifdef emacs
        -: 4106:            /* There is no way to specify the before_dot and after_dot
        -: 4107:               operators.  rms says this is ok.  --karl  */
        -: 4108:            case '=':
        -: 4109:              BUF_PUSH (at_dot);
        -: 4110:              break;
        -: 4111:
        -: 4112:            case 's':	
        -: 4113:              laststart = b;
        -: 4114:              PATFETCH (c);
        -: 4115:              BUF_PUSH_2 (syntaxspec, syntax_spec_code[c]);
        -: 4116:              break;
        -: 4117:
        -: 4118:            case 'S':
        -: 4119:              laststart = b;
        -: 4120:              PATFETCH (c);
        -: 4121:              BUF_PUSH_2 (notsyntaxspec, syntax_spec_code[c]);
        -: 4122:              break;
        -: 4123:#endif /* emacs */
        -: 4124:
        -: 4125:
    #####: 4126:            case 'w':
    #####: 4127:              laststart = b;
    #####: 4128:              BUF_PUSH (wordchar);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
    #####: 4129:              break;
        -: 4130:
        -: 4131:
    #####: 4132:            case 'W':
    #####: 4133:              laststart = b;
    #####: 4134:              BUF_PUSH (notwordchar);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
    #####: 4135:              break;
        -: 4136:
        -: 4137:
    #####: 4138:            case '<':
    #####: 4139:              BUF_PUSH (wordbeg);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
    #####: 4140:              break;
        -: 4141:
    #####: 4142:            case '>':
    #####: 4143:              BUF_PUSH (wordend);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
    #####: 4144:              break;
        -: 4145:
    #####: 4146:            case 'b':
    #####: 4147:              BUF_PUSH (wordbound);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
    #####: 4148:              break;
        -: 4149:
    #####: 4150:            case 'B':
    #####: 4151:              BUF_PUSH (notwordbound);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
    #####: 4152:              break;
        -: 4153:
      152: 4154:            case '`':
     152*: 4155:              BUF_PUSH (begbuf);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 taken 0
branch 15 taken 152 (fallthrough)
      152: 4156:              break;
        -: 4157:
      102: 4158:            case '\'':
     102*: 4159:              BUF_PUSH (endbuf);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 taken 0
branch 15 taken 102 (fallthrough)
      102: 4160:              break;
        -: 4161:
    #####: 4162:            case '1': case '2': case '3': case '4': case '5':
        -: 4163:            case '6': case '7': case '8': case '9':
    #####: 4164:              if (syntax & RE_NO_BK_REFS)
branch  0 never executed
branch  1 never executed
    #####: 4165:                goto normal_char;
        -: 4166:
    #####: 4167:              c1 = c - '0';
        -: 4168:
    #####: 4169:              if (c1 > regnum)
branch  0 never executed
branch  1 never executed
    #####: 4170:                return REG_ESUBREG;
        -: 4171:
        -: 4172:              /* Can't back reference to a subexpression if inside of it.  */
    #####: 4173:              if (group_in_compile_stack (compile_stack, c1))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 4174:                goto normal_char;
        -: 4175:
    #####: 4176:              laststart = b;
    #####: 4177:              BUF_PUSH_2 (duplicate, c1);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
    #####: 4178:              break;
        -: 4179:
        -: 4180:
    #####: 4181:            case '+':
        -: 4182:            case '?':
    #####: 4183:              if (syntax & RE_BK_PLUS_QM)
branch  0 never executed
branch  1 never executed
    #####: 4184:                goto handle_plus;
        -: 4185:              else
    #####: 4186:                goto normal_backslash;
        -: 4187:
        -: 4188:            default:
      312: 4189:            normal_backslash:
        -: 4190:              /* You might think it would be useful for \ to mean
        -: 4191:                 not to translate; but if we don't translate it
        -: 4192:                 it will never match anything.  */
     312*: 4193:              c = TRANSLATE (c);
branch  0 taken 0 (fallthrough)
branch  1 taken 312
      312: 4194:              goto normal_char;
        -: 4195:            }
      279: 4196:          break;
        -: 4197:
        -: 4198:
        -: 4199:	default:
        -: 4200:        /* Expects the character in `c'.  */
     2109: 4201:	normal_char:
        -: 4202:	      /* If no exactn currently being built.  */
     2109: 4203:          if (!pending_exact 
branch  0 taken 1558 (fallthrough)
branch  1 taken 551
        -: 4204:
        -: 4205:              /* If last exactn not at current position.  */
     1558: 4206:              || pending_exact + *pending_exact + 1 != b
branch  0 taken 1558 (fallthrough)
branch  1 taken 0
        -: 4207:              
        -: 4208:              /* We have only one byte following the exactn for the count.  */
     1558: 4209:	      || *pending_exact == (1 << BYTEWIDTH) - 1
branch  0 taken 1558 (fallthrough)
branch  1 taken 0
        -: 4210:
        -: 4211:              /* If followed by a repetition operator.  */
     1558: 4212:              || *p == '*' || *p == '^'
branch  0 taken 1550 (fallthrough)
branch  1 taken 8
branch  2 taken 1548 (fallthrough)
branch  3 taken 2
    3096*: 4213:	      || ((syntax & RE_BK_PLUS_QM)
branch  0 taken 1548 (fallthrough)
branch  1 taken 0
branch  2 taken 1548
branch  3 taken 0
branch  4 never executed
branch  5 never executed
    1548*: 4214:		  ? *p == '\\' && (p[1] == '+' || p[1] == '?')
branch  0 taken 52 (fallthrough)
branch  1 taken 1496
branch  2 taken 52 (fallthrough)
branch  3 taken 0
branch  4 taken 0 (fallthrough)
branch  5 taken 52
    #####: 4215:		  : (*p == '+' || *p == '?'))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
     1548: 4216:	      || ((syntax & RE_INTERVALS)
branch  0 taken 1548 (fallthrough)
branch  1 taken 0
    3096*: 4217:                  && ((syntax & RE_NO_BK_BRACES)
branch  0 taken 0 (fallthrough)
branch  1 taken 1548
branch  2 taken 0 (fallthrough)
branch  3 taken 1548
    #####: 4218:		      ? *p == '{'
branch  0 never executed
branch  1 never executed
    1548*: 4219:                      : (p[0] == '\\' && p[1] == '{'))))
branch  0 taken 52 (fallthrough)
branch  1 taken 1496
branch  2 taken 0 (fallthrough)
branch  3 taken 52
        -: 4220:	    {
        -: 4221:	      /* Start building a new exactn.  */
        -: 4222:              
      561: 4223:              laststart = b;
        -: 4224:
     561*: 4225:	      BUF_PUSH_2 (exactn, 0);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 taken 0
branch 15 taken 561 (fallthrough)
      561: 4226:	      pending_exact = b - 1;
        -: 4227:            }
        -: 4228:            
    2113*: 4229:	  BUF_PUSH (c);
branch  0 taken 0 (fallthrough)
branch  1 taken 4
branch  2 taken 0 (fallthrough)
branch  3 taken 4
branch  4 taken 0 (fallthrough)
branch  5 taken 4
branch  6 taken 4 (fallthrough)
branch  7 taken 0
branch  8 taken 0 (fallthrough)
branch  9 taken 4
branch 10 taken 4 (fallthrough)
branch 11 taken 0
branch 12 taken 4 (fallthrough)
branch 13 taken 0
branch 14 taken 4
branch 15 taken 2109 (fallthrough)
     2109: 4230:          (*pending_exact)++;
     2109: 4231:	  break;
        -: 4232:        } /* switch (c) */
        -: 4233:    } /* while p != pend */
        -: 4234:
        -: 4235:  
        -: 4236:  /* Through the pattern now.  */
        -: 4237:  
      603: 4238:  if (fixup_alt_jump)
branch  0 taken 0 (fallthrough)
branch  1 taken 603
    #####: 4239:    STORE_JUMP (jump_past_alt, fixup_alt_jump, b);
call    0 never executed
        -: 4240:
      603: 4241:  if (!COMPILE_STACK_EMPTY) 
branch  0 taken 0 (fallthrough)
branch  1 taken 603
    #####: 4242:    return REG_EPAREN;
        -: 4243:
      603: 4244:  free (compile_stack.stack);
        -: 4245:
        -: 4246:  /* We have succeeded; set the length of the buffer.  */
      603: 4247:  bufp->used = b - bufp->buffer;
        -: 4248:
        -: 4249:#ifdef DEBUG
        -: 4250:  if (debug)
        -: 4251:    {
        -: 4252:      DEBUG_PRINT1 ("\nCompiled pattern: ");
        -: 4253:      print_compiled_pattern (bufp);
        -: 4254:    }
        -: 4255:#endif /* DEBUG */
        -: 4256:
      603: 4257:  return REG_NOERROR;
        -: 4258:} /* regex_compile */
        -: 4259:
        -: 4260:/* Subroutines for `regex_compile'.  */
        -: 4261:
        -: 4262:/* Store OP at LOC followed by two-byte integer parameter ARG.  */
        -: 4263:
        -: 4264:static void
function store_op1 called 258 returned 100% blocks executed 100%
      258: 4265:store_op1 (op, loc, arg)
        -: 4266:    re_opcode_t op;
        -: 4267:    unsigned char *loc;
        -: 4268:    int arg;
        -: 4269:{
      258: 4270:  *loc = (unsigned char) op;
      258: 4271:  STORE_NUMBER (loc + 1, arg);
      258: 4272:}
        -: 4273:
        -: 4274:
        -: 4275:/* Like `store_op1', but for two two-byte parameters ARG1 and ARG2.  */
        -: 4276:
        -: 4277:static void
function store_op2 called 4 returned 100% blocks executed 100%
        4: 4278:store_op2 (op, loc, arg1, arg2)
        -: 4279:    re_opcode_t op;
        -: 4280:    unsigned char *loc;
        -: 4281:    int arg1, arg2;
        -: 4282:{
        4: 4283:  *loc = (unsigned char) op;
        4: 4284:  STORE_NUMBER (loc + 1, arg1);
        4: 4285:  STORE_NUMBER (loc + 3, arg2);
        4: 4286:}
        -: 4287:
        -: 4288:
        -: 4289:/* Copy the bytes from LOC to END to open up three bytes of space at LOC
        -: 4290:   for OP followed by two-byte integer parameter ARG.  */
        -: 4291:
        -: 4292:static void
function insert_op1 called 129 returned 100% blocks executed 100%
      129: 4293:insert_op1 (op, loc, arg, end)
        -: 4294:    re_opcode_t op;
        -: 4295:    unsigned char *loc;
        -: 4296:    int arg;
        -: 4297:    unsigned char *end;    
        -: 4298:{
      129: 4299:  register unsigned char *pfrom = end;
      129: 4300:  register unsigned char *pto = end + 3;
        -: 4301:
      661: 4302:  while (pfrom != loc)
branch  0 taken 532
branch  1 taken 129 (fallthrough)
      532: 4303:    *--pto = *--pfrom;
        -: 4304:    
      129: 4305:  store_op1 (op, loc, arg);
call    0 returned 129
      129: 4306:}
        -: 4307:
        -: 4308:
        -: 4309:/* Like `insert_op1', but for two two-byte parameters ARG1 and ARG2.  */
        -: 4310:
        -: 4311:static void
function insert_op2 called 3 returned 100% blocks executed 100%
        3: 4312:insert_op2 (op, loc, arg1, arg2, end)
        -: 4313:    re_opcode_t op;
        -: 4314:    unsigned char *loc;
        -: 4315:    int arg1, arg2;
        -: 4316:    unsigned char *end;    
        -: 4317:{
        3: 4318:  register unsigned char *pfrom = end;
        3: 4319:  register unsigned char *pto = end + 5;
        -: 4320:
       32: 4321:  while (pfrom != loc)
branch  0 taken 29
branch  1 taken 3 (fallthrough)
       29: 4322:    *--pto = *--pfrom;
        -: 4323:    
        3: 4324:  store_op2 (op, loc, arg1, arg2);
call    0 returned 3
        3: 4325:}
        -: 4326:
        -: 4327:
        -: 4328:/* P points to just after a ^ in PATTERN.  Return true if that ^ comes
        -: 4329:   after an alternative or a begin-subexpression.  We assume there is at
        -: 4330:   least one character before the ^.  */
        -: 4331:
        -: 4332:static boolean
function at_begline_loc_p called 0 returned 0% blocks executed 0%
    #####: 4333:at_begline_loc_p (pattern, p, syntax)
        -: 4334:    const char *pattern, *p;
        -: 4335:    reg_syntax_t syntax;
        -: 4336:{
    #####: 4337:  const char *prev = p - 2;
    #####: 4338:  boolean prev_prev_backslash = prev > pattern && prev[-1] == '\\';
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 4339:  
        -: 4340:  return
        -: 4341:       /* After a subexpression?  */
    #####: 4342:       (*prev == '(' && (syntax & RE_NO_BK_PARENS || prev_prev_backslash))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 4343:       /* After an alternative?  */
    #####: 4344:    || (*prev == '|' && (syntax & RE_NO_BK_VBAR || prev_prev_backslash));
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -: 4345:}
        -: 4346:
        -: 4347:
        -: 4348:/* The dual of at_begline_loc_p.  This one is for $.  We assume there is
        -: 4349:   at least one character after the $, i.e., `P < PEND'.  */
        -: 4350:
        -: 4351:static boolean
function at_endline_loc_p called 0 returned 0% blocks executed 0%
    #####: 4352:at_endline_loc_p (p, pend, syntax)
        -: 4353:    const char *p, *pend;
        -: 4354:    int syntax;
        -: 4355:{
    #####: 4356:  const char *next = p;
    #####: 4357:  boolean next_backslash = *next == '\\';
    #####: 4358:  const char *next_next = p + 1 < pend ? p + 1 : NULL;
branch  0 never executed
branch  1 never executed
        -: 4359:  
        -: 4360:  return
        -: 4361:       /* Before a subexpression?  */
    #####: 4362:       (syntax & RE_NO_BK_PARENS ? *next == ')'
    #####: 4363:        : next_backslash && next_next && *next_next == ')')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 4364:       /* Before an alternative?  */
    #####: 4365:    || (syntax & RE_NO_BK_VBAR ? *next == '|'
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
    #####: 4366:        : next_backslash && next_next && *next_next == '|');
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 4367:}
        -: 4368:
        -: 4369:
        -: 4370:/* Returns true if REGNUM is in one of COMPILE_STACK's elements and 
        -: 4371:   false if it's not.  */
        -: 4372:
        -: 4373:static boolean
function group_in_compile_stack called 0 returned 0% blocks executed 0%
    #####: 4374:group_in_compile_stack (compile_stack, regnum)
        -: 4375:    compile_stack_type compile_stack;
        -: 4376:    regnum_t regnum;
        -: 4377:{
        -: 4378:  int this_element;
        -: 4379:
    #####: 4380:  for (this_element = compile_stack.avail - 1;  
    #####: 4381:       this_element >= 0; 
branch  0 never executed
branch  1 never executed
    #####: 4382:       this_element--)
    #####: 4383:    if (compile_stack.stack[this_element].regnum == regnum)
branch  0 never executed
branch  1 never executed
    #####: 4384:      return true;
        -: 4385:
    #####: 4386:  return false;
        -: 4387:}
        -: 4388:
        -: 4389:
        -: 4390:/* Read the ending character of a range (in a bracket expression) from the
        -: 4391:   uncompiled pattern *P_PTR (which ends at PEND).  We assume the
        -: 4392:   starting character is in `P[-2]'.  (`P[-1]' is the character `-'.)
        -: 4393:   Then we set the translation of all bits between the starting and
        -: 4394:   ending characters (inclusive) in the compiled pattern B.
        -: 4395:   
        -: 4396:   Return an error code.
        -: 4397:   
        -: 4398:   We use these short variable names so we can use the same macros as
        -: 4399:   `regex_compile' itself.  */
        -: 4400:
        -: 4401:static reg_errcode_t
function compile_range called 0 returned 0% blocks executed 0%
    #####: 4402:compile_range (p_ptr, pend, translate, syntax, b)
        -: 4403:    const char **p_ptr, *pend;
        -: 4404:    char *translate;
        -: 4405:    reg_syntax_t syntax;
        -: 4406:    unsigned char *b;
        -: 4407:{
        -: 4408:  unsigned this_char;
        -: 4409:
    #####: 4410:  const char *p = *p_ptr;
        -: 4411:  int range_start, range_end;
        -: 4412:  
    #####: 4413:  if (p == pend)
branch  0 never executed
branch  1 never executed
    #####: 4414:    return REG_ERANGE;
        -: 4415:
        -: 4416:  /* Even though the pattern is a signed `char *', we need to fetch
        -: 4417:     with unsigned char *'s; if the high bit of the pattern character
        -: 4418:     is set, the range endpoints will be negative if we fetch using a
        -: 4419:     signed char *.
        -: 4420:
        -: 4421:     We also want to fetch the endpoints without translating them; the 
        -: 4422:     appropriate translation is done in the bit-setting loop below.  */
    #####: 4423:  range_start = ((unsigned char *) p)[-2];
    #####: 4424:  range_end   = ((unsigned char *) p)[0];
        -: 4425:
        -: 4426:  /* Have to increment the pointer into the pattern string, so the
        -: 4427:     caller isn't still at the ending character.  */
    #####: 4428:  (*p_ptr)++;
        -: 4429:
        -: 4430:  /* If the start is after the end, the range is empty.  */
    #####: 4431:  if (range_start > range_end)
branch  0 never executed
branch  1 never executed
    #####: 4432:    return syntax & RE_NO_EMPTY_RANGES ? REG_ERANGE : REG_NOERROR;
branch  0 never executed
branch  1 never executed
        -: 4433:
        -: 4434:  /* Here we see why `this_char' has to be larger than an `unsigned
        -: 4435:     char' -- the range is inclusive, so if `range_end' == 0xff
        -: 4436:     (assuming 8-bit characters), we would otherwise go into an infinite
        -: 4437:     loop, since all characters <= 0xff.  */
    #####: 4438:  for (this_char = range_start; this_char <= range_end; this_char++)
branch  0 never executed
branch  1 never executed
        -: 4439:    {
    #####: 4440:      SET_LIST_BIT (TRANSLATE (this_char));
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 4441:    }
        -: 4442:  
    #####: 4443:  return REG_NOERROR;
        -: 4444:}
        -: 4445:
        -: 4446:/* Failure stack declarations and macros; both re_compile_fastmap and
        -: 4447:   re_match_2 use a failure stack.  These have to be macros because of
        -: 4448:   REGEX_ALLOCATE.  */
        -: 4449:   
        -: 4450:
        -: 4451:/* Number of failure points for which to initially allocate space
        -: 4452:   when matching.  If this number is exceeded, we allocate more
        -: 4453:   space, so it is not a hard limit.  */
        -: 4454:#ifndef INIT_FAILURE_ALLOC
        -: 4455:#define INIT_FAILURE_ALLOC 5
        -: 4456:#endif
        -: 4457:
        -: 4458:/* Roughly the maximum number of failure points on the stack.  Would be
        -: 4459:   exactly that if always used MAX_FAILURE_SPACE each time we failed.
        -: 4460:   This is a variable only so users of regex can assign to it; we never
        -: 4461:   change it ourselves.  */
        -: 4462:int re_max_failures = 2000;
        -: 4463:
        -: 4464:typedef const unsigned char *fail_stack_elt_t;
        -: 4465:
        -: 4466:typedef struct
        -: 4467:{
        -: 4468:  fail_stack_elt_t *stack;
        -: 4469:  unsigned size;
        -: 4470:  unsigned avail;			/* Offset of next open position.  */
        -: 4471:} fail_stack_type;
        -: 4472:
        -: 4473:#define FAIL_STACK_EMPTY()     (fail_stack.avail == 0)
        -: 4474:#define FAIL_STACK_PTR_EMPTY() (fail_stack_ptr->avail == 0)
        -: 4475:#define FAIL_STACK_FULL()      (fail_stack.avail == fail_stack.size)
        -: 4476:#define FAIL_STACK_TOP()       (fail_stack.stack[fail_stack.avail])
        -: 4477:
        -: 4478:
        -: 4479:/* Initialize `fail_stack'.  Do `return -2' if the alloc fails.  */
        -: 4480:
        -: 4481:#define INIT_FAIL_STACK()						\
        -: 4482:  do {									\
        -: 4483:    fail_stack.stack = (fail_stack_elt_t *)				\
        -: 4484:      REGEX_ALLOCATE (INIT_FAILURE_ALLOC * sizeof (fail_stack_elt_t));	\
        -: 4485:									\
        -: 4486:    if (fail_stack.stack == NULL)					\
        -: 4487:      return -2;							\
        -: 4488:									\
        -: 4489:    fail_stack.size = INIT_FAILURE_ALLOC;				\
        -: 4490:    fail_stack.avail = 0;						\
        -: 4491:  } while (0)
        -: 4492:
        -: 4493:
        -: 4494:/* Double the size of FAIL_STACK, up to approximately `re_max_failures' items.
        -: 4495:
        -: 4496:   Return 1 if succeeds, and 0 if either ran out of memory
        -: 4497:   allocating space for it or it was already too large.  
        -: 4498:   
        -: 4499:   REGEX_REALLOCATE requires `destination' be declared.   */
        -: 4500:
        -: 4501:#define DOUBLE_FAIL_STACK(fail_stack)					\
        -: 4502:  ((fail_stack).size > re_max_failures * MAX_FAILURE_ITEMS		\
        -: 4503:   ? 0									\
        -: 4504:   : ((fail_stack).stack = (fail_stack_elt_t *)				\
        -: 4505:        REGEX_REALLOCATE ((fail_stack).stack, 				\
        -: 4506:          (fail_stack).size * sizeof (fail_stack_elt_t),		\
        -: 4507:          ((fail_stack).size << 1) * sizeof (fail_stack_elt_t)),	\
        -: 4508:									\
        -: 4509:      (fail_stack).stack == NULL					\
        -: 4510:      ? 0								\
        -: 4511:      : ((fail_stack).size <<= 1, 					\
        -: 4512:         1)))
        -: 4513:
        -: 4514:
        -: 4515:/* Push PATTERN_OP on FAIL_STACK. 
        -: 4516:
        -: 4517:   Return 1 if was able to do so and 0 if ran out of memory allocating
        -: 4518:   space to do so.  */
        -: 4519:#define PUSH_PATTERN_OP(pattern_op, fail_stack)				\
        -: 4520:  ((FAIL_STACK_FULL ()							\
        -: 4521:    && !DOUBLE_FAIL_STACK (fail_stack))					\
        -: 4522:    ? 0									\
        -: 4523:    : ((fail_stack).stack[(fail_stack).avail++] = pattern_op,		\
        -: 4524:       1))
        -: 4525:
        -: 4526:/* This pushes an item onto the failure stack.  Must be a four-byte
        -: 4527:   value.  Assumes the variable `fail_stack'.  Probably should only
        -: 4528:   be called from within `PUSH_FAILURE_POINT'.  */
        -: 4529:#define PUSH_FAILURE_ITEM(item)						\
        -: 4530:  fail_stack.stack[fail_stack.avail++] = (fail_stack_elt_t) item
        -: 4531:
        -: 4532:/* The complement operation.  Assumes `fail_stack' is nonempty.  */
        -: 4533:#define POP_FAILURE_ITEM() fail_stack.stack[--fail_stack.avail]
        -: 4534:
        -: 4535:/* Used to omit pushing failure point id's when we're not debugging.  */
        -: 4536:#ifdef DEBUG
        -: 4537:#define DEBUG_PUSH PUSH_FAILURE_ITEM
        -: 4538:#define DEBUG_POP(item_addr) *(item_addr) = POP_FAILURE_ITEM ()
        -: 4539:#else
        -: 4540:#define DEBUG_PUSH(item)
        -: 4541:#define DEBUG_POP(item_addr)
        -: 4542:#endif
        -: 4543:
        -: 4544:
        -: 4545:/* Push the information about the state we will need
        -: 4546:   if we ever fail back to it.  
        -: 4547:   
        -: 4548:   Requires variables fail_stack, regstart, regend, reg_info, and
        -: 4549:   num_regs be declared.  DOUBLE_FAIL_STACK requires `destination' be
        -: 4550:   declared.
        -: 4551:   
        -: 4552:   Does `return FAILURE_CODE' if runs out of memory.  */
        -: 4553:
        -: 4554:#define PUSH_FAILURE_POINT(pattern_place, string_place, failure_code)	\
        -: 4555:  do {									\
        -: 4556:    char *destination;							\
        -: 4557:    /* Must be int, so when we don't save any registers, the arithmetic	\
        -: 4558:       of 0 + -1 isn't done as unsigned.  */				\
        -: 4559:    int this_reg;							\
        -: 4560:    									\
        -: 4561:    DEBUG_STATEMENT (failure_id++);					\
        -: 4562:    DEBUG_STATEMENT (nfailure_points_pushed++);				\
        -: 4563:    DEBUG_PRINT2 ("\nPUSH_FAILURE_POINT #%u:\n", failure_id);		\
        -: 4564:    DEBUG_PRINT2 ("  Before push, next avail: %d\n", (fail_stack).avail);\
        -: 4565:    DEBUG_PRINT2 ("                     size: %d\n", (fail_stack).size);\
        -: 4566:									\
        -: 4567:    DEBUG_PRINT2 ("  slots needed: %d\n", NUM_FAILURE_ITEMS);		\
        -: 4568:    DEBUG_PRINT2 ("     available: %d\n", REMAINING_AVAIL_SLOTS);	\
        -: 4569:									\
        -: 4570:    /* Ensure we have enough space allocated for what we will push.  */	\
        -: 4571:    while (REMAINING_AVAIL_SLOTS < NUM_FAILURE_ITEMS)			\
        -: 4572:      {									\
        -: 4573:        if (!DOUBLE_FAIL_STACK (fail_stack))			\
        -: 4574:          return failure_code;						\
        -: 4575:									\
        -: 4576:        DEBUG_PRINT2 ("\n  Doubled stack; size now: %d\n",		\
        -: 4577:		       (fail_stack).size);				\
        -: 4578:        DEBUG_PRINT2 ("  slots available: %d\n", REMAINING_AVAIL_SLOTS);\
        -: 4579:      }									\
        -: 4580:									\
        -: 4581:    /* Push the info, starting with the registers.  */			\
        -: 4582:    DEBUG_PRINT1 ("\n");						\
        -: 4583:									\
        -: 4584:    for (this_reg = lowest_active_reg; this_reg <= highest_active_reg;	\
        -: 4585:         this_reg++)							\
        -: 4586:      {									\
        -: 4587:	DEBUG_PRINT2 ("  Pushing reg: %d\n", this_reg);			\
        -: 4588:        DEBUG_STATEMENT (num_regs_pushed++);				\
        -: 4589:									\
        -: 4590:	DEBUG_PRINT2 ("    start: 0x%x\n", regstart[this_reg]);		\
        -: 4591:        PUSH_FAILURE_ITEM (regstart[this_reg]);				\
        -: 4592:                                                                        \
        -: 4593:	DEBUG_PRINT2 ("    end: 0x%x\n", regend[this_reg]);		\
        -: 4594:        PUSH_FAILURE_ITEM (regend[this_reg]);				\
        -: 4595:									\
        -: 4596:	DEBUG_PRINT2 ("    info: 0x%x\n      ", reg_info[this_reg]);	\
        -: 4597:        DEBUG_PRINT2 (" match_null=%d",					\
        -: 4598:                      REG_MATCH_NULL_STRING_P (reg_info[this_reg]));	\
        -: 4599:        DEBUG_PRINT2 (" active=%d", IS_ACTIVE (reg_info[this_reg]));	\
        -: 4600:        DEBUG_PRINT2 (" matched_something=%d",				\
        -: 4601:                      MATCHED_SOMETHING (reg_info[this_reg]));		\
        -: 4602:        DEBUG_PRINT2 (" ever_matched=%d",				\
        -: 4603:                      EVER_MATCHED_SOMETHING (reg_info[this_reg]));	\
        -: 4604:	DEBUG_PRINT1 ("\n");						\
        -: 4605:        PUSH_FAILURE_ITEM (reg_info[this_reg].word);			\
        -: 4606:      }									\
        -: 4607:									\
        -: 4608:    DEBUG_PRINT2 ("  Pushing  low active reg: %d\n", lowest_active_reg);\
        -: 4609:    PUSH_FAILURE_ITEM (lowest_active_reg);				\
        -: 4610:									\
        -: 4611:    DEBUG_PRINT2 ("  Pushing high active reg: %d\n", highest_active_reg);\
        -: 4612:    PUSH_FAILURE_ITEM (highest_active_reg);				\
        -: 4613:									\
        -: 4614:    DEBUG_PRINT2 ("  Pushing pattern 0x%x: ", pattern_place);		\
        -: 4615:    DEBUG_PRINT_COMPILED_PATTERN (bufp, pattern_place, pend);		\
        -: 4616:    PUSH_FAILURE_ITEM (pattern_place);					\
        -: 4617:									\
        -: 4618:    DEBUG_PRINT2 ("  Pushing string 0x%x: `", string_place);		\
        -: 4619:    DEBUG_PRINT_DOUBLE_STRING (string_place, string1, size1, string2,   \
        -: 4620:				 size2);				\
        -: 4621:    DEBUG_PRINT1 ("'\n");						\
        -: 4622:    PUSH_FAILURE_ITEM (string_place);					\
        -: 4623:									\
        -: 4624:    DEBUG_PRINT2 ("  Pushing failure id: %u\n", failure_id);		\
        -: 4625:    DEBUG_PUSH (failure_id);						\
        -: 4626:  } while (0)
        -: 4627:
        -: 4628:/* This is the number of items that are pushed and popped on the stack
        -: 4629:   for each register.  */
        -: 4630:#define NUM_REG_ITEMS  3
        -: 4631:
        -: 4632:/* Individual items aside from the registers.  */
        -: 4633:#ifdef DEBUG
        -: 4634:#define NUM_NONREG_ITEMS 5 /* Includes failure point id.  */
        -: 4635:#else
        -: 4636:#define NUM_NONREG_ITEMS 4
        -: 4637:#endif
        -: 4638:
        -: 4639:/* We push at most this many items on the stack.  */
        -: 4640:#define MAX_FAILURE_ITEMS ((num_regs - 1) * NUM_REG_ITEMS + NUM_NONREG_ITEMS)
        -: 4641:
        -: 4642:/* We actually push this many items.  */
        -: 4643:#define NUM_FAILURE_ITEMS						\
        -: 4644:  ((highest_active_reg - lowest_active_reg + 1) * NUM_REG_ITEMS 	\
        -: 4645:    + NUM_NONREG_ITEMS)
        -: 4646:
        -: 4647:/* How many items can still be added to the stack without overflowing it.  */
        -: 4648:#define REMAINING_AVAIL_SLOTS ((fail_stack).size - (fail_stack).avail)
        -: 4649:
        -: 4650:
        -: 4651:/* Pops what PUSH_FAIL_STACK pushes.
        -: 4652:
        -: 4653:   We restore into the parameters, all of which should be lvalues:
        -: 4654:     STR -- the saved data position.
        -: 4655:     PAT -- the saved pattern position.
        -: 4656:     LOW_REG, HIGH_REG -- the highest and lowest active registers.
        -: 4657:     REGSTART, REGEND -- arrays of string positions.
        -: 4658:     REG_INFO -- array of information about each subexpression.
        -: 4659:   
        -: 4660:   Also assumes the variables `fail_stack' and (if debugging), `bufp',
        -: 4661:   `pend', `string1', `size1', `string2', and `size2'.  */
        -: 4662:
        -: 4663:#define POP_FAILURE_POINT(str, pat, low_reg, high_reg, regstart, regend, reg_info)\
        -: 4664:{									\
        -: 4665:  DEBUG_STATEMENT (fail_stack_elt_t failure_id;)			\
        -: 4666:  int this_reg;								\
        -: 4667:  const unsigned char *string_temp;					\
        -: 4668:									\
        -: 4669:  assert (!FAIL_STACK_EMPTY ());					\
        -: 4670:									\
        -: 4671:  /* Remove failure points and point to how many regs pushed.  */	\
        -: 4672:  DEBUG_PRINT1 ("POP_FAILURE_POINT:\n");				\
        -: 4673:  DEBUG_PRINT2 ("  Before pop, next avail: %d\n", fail_stack.avail);	\
        -: 4674:  DEBUG_PRINT2 ("                    size: %d\n", fail_stack.size);	\
        -: 4675:									\
        -: 4676:  assert (fail_stack.avail >= NUM_NONREG_ITEMS);			\
        -: 4677:									\
        -: 4678:  DEBUG_POP (&failure_id);						\
        -: 4679:  DEBUG_PRINT2 ("  Popping failure id: %u\n", failure_id);		\
        -: 4680:									\
        -: 4681:  /* If the saved string location is NULL, it came from an		\
        -: 4682:     on_failure_keep_string_jump opcode, and we want to throw away the	\
        -: 4683:     saved NULL, thus retaining our current position in the string.  */	\
        -: 4684:  string_temp = POP_FAILURE_ITEM ();					\
        -: 4685:  if (string_temp != NULL)						\
        -: 4686:    str = (const char *) string_temp;					\
        -: 4687:									\
        -: 4688:  DEBUG_PRINT2 ("  Popping string 0x%x: `", str);			\
        -: 4689:  DEBUG_PRINT_DOUBLE_STRING (str, string1, size1, string2, size2);	\
        -: 4690:  DEBUG_PRINT1 ("'\n");							\
        -: 4691:									\
        -: 4692:  pat = (unsigned char *) POP_FAILURE_ITEM ();				\
        -: 4693:  DEBUG_PRINT2 ("  Popping pattern 0x%x: ", pat);			\
        -: 4694:  DEBUG_PRINT_COMPILED_PATTERN (bufp, pat, pend);			\
        -: 4695:									\
        -: 4696:  /* Restore register info.  */						\
        -: 4697:  high_reg = (unsigned) POP_FAILURE_ITEM ();				\
        -: 4698:  DEBUG_PRINT2 ("  Popping high active reg: %d\n", high_reg);		\
        -: 4699:									\
        -: 4700:  low_reg = (unsigned) POP_FAILURE_ITEM ();				\
        -: 4701:  DEBUG_PRINT2 ("  Popping  low active reg: %d\n", low_reg);		\
        -: 4702:									\
        -: 4703:  for (this_reg = high_reg; this_reg >= low_reg; this_reg--)		\
        -: 4704:    {									\
        -: 4705:      DEBUG_PRINT2 ("    Popping reg: %d\n", this_reg);			\
        -: 4706:									\
        -: 4707:      reg_info[this_reg].word = POP_FAILURE_ITEM ();			\
        -: 4708:      DEBUG_PRINT2 ("      info: 0x%x\n", reg_info[this_reg]);		\
        -: 4709:									\
        -: 4710:      regend[this_reg] = (const char *) POP_FAILURE_ITEM ();		\
        -: 4711:      DEBUG_PRINT2 ("      end: 0x%x\n", regend[this_reg]);		\
        -: 4712:									\
        -: 4713:      regstart[this_reg] = (const char *) POP_FAILURE_ITEM ();		\
        -: 4714:      DEBUG_PRINT2 ("      start: 0x%x\n", regstart[this_reg]);		\
        -: 4715:    }									\
        -: 4716:									\
        -: 4717:  DEBUG_STATEMENT (nfailure_points_popped++);				\
        -: 4718:} /* POP_FAILURE_POINT */
        -: 4719:
        -: 4720:/* re_compile_fastmap computes a ``fastmap'' for the compiled pattern in
        -: 4721:   BUFP.  A fastmap records which of the (1 << BYTEWIDTH) possible
        -: 4722:   characters can start a string that matches the pattern.  This fastmap
        -: 4723:   is used by re_search to skip quickly over impossible starting points.
        -: 4724:
        -: 4725:   The caller must supply the address of a (1 << BYTEWIDTH)-byte data
        -: 4726:   area as BUFP->fastmap.
        -: 4727:   
        -: 4728:   We set the `fastmap', `fastmap_accurate', and `can_be_null' fields in
        -: 4729:   the pattern buffer.
        -: 4730:
        -: 4731:   Returns 0 if we succeed, -2 if an internal error.   */
        -: 4732:
        -: 4733:int
function re_compile_fastmap called 597 returned 100% blocks executed 56%
      597: 4734:re_compile_fastmap (bufp)
        -: 4735:     struct re_pattern_buffer *bufp;
        -: 4736:{
        -: 4737:  int j, k;
        -: 4738:  fail_stack_type fail_stack;
        -: 4739:#ifndef REGEX_MALLOC
        -: 4740:  char *destination;
        -: 4741:#endif
        -: 4742:  /* We don't push any register information onto the failure stack.  */
      597: 4743:  unsigned num_regs = 0;
        -: 4744:  
      597: 4745:  register char *fastmap = bufp->fastmap;
      597: 4746:  unsigned char *pattern = bufp->buffer;
      597: 4747:  unsigned long size = bufp->used;
      597: 4748:  const unsigned char *p = pattern;
      597: 4749:  register unsigned char *pend = pattern + size;
        -: 4750:
        -: 4751:  /* Assume that each path through the pattern can be null until
        -: 4752:     proven otherwise.  We set this false at the bottom of switch
        -: 4753:     statement, to which we get only if a particular path doesn't
        -: 4754:     match the empty string.  */
      597: 4755:  boolean path_can_be_null = true;
        -: 4756:
        -: 4757:  /* We aren't doing a `succeed_n' to begin with.  */
      597: 4758:  boolean succeed_n_p = false;
        -: 4759:
        -: 4760:  assert (fastmap != NULL && p != NULL);
        -: 4761:  
     597*: 4762:  INIT_FAIL_STACK ();
branch  0 taken 0 (fallthrough)
branch  1 taken 597
      597: 4763:  bzero (fastmap, 1 << BYTEWIDTH);  /* Assume nothing's valid.  */
      597: 4764:  bufp->fastmap_accurate = 1;	    /* It will be when we're done.  */
      597: 4765:  bufp->can_be_null = 0;
        -: 4766:      
     1398: 4767:  while (p != pend || !FAIL_STACK_EMPTY ())
branch  0 taken 786
branch  1 taken 612 (fallthrough)
branch  2 taken 31
branch  3 taken 581 (fallthrough)
        -: 4768:    {
      817: 4769:      if (p == pend)
branch  0 taken 31 (fallthrough)
branch  1 taken 786
        -: 4770:        {
       31: 4771:          bufp->can_be_null |= path_can_be_null;
        -: 4772:          
        -: 4773:          /* Reset for next path.  */
       31: 4774:          path_can_be_null = true;
        -: 4775:          
       31: 4776:          p = fail_stack.stack[--fail_stack.avail];
        -: 4777:	}
        -: 4778:
        -: 4779:      /* We should never be about to go beyond the end of the pattern.  */
        -: 4780:      assert (p < pend);
        -: 4781:      
        -: 4782:#ifdef SWITCH_ENUM_BUG
        -: 4783:      switch ((int) ((re_opcode_t) *p++))
        -: 4784:#else
     817*: 4785:      switch ((re_opcode_t) *p++)
branch  0 taken 0
branch  1 taken 520
branch  2 taken 2
branch  3 taken 1
branch  4 taken 0
branch  5 taken 0
branch  6 taken 47
branch  7 taken 197
branch  8 taken 0
branch  9 taken 47
branch 10 taken 1
branch 11 taken 2
branch 12 taken 0
branch 13 taken 0
        -: 4786:#endif
        -: 4787:	{
        -: 4788:
        -: 4789:        /* I guess the idea here is to simply not bother with a fastmap
        -: 4790:           if a backreference is used, since it's too hard to figure out
        -: 4791:           the fastmap for the corresponding group.  Setting
        -: 4792:           `can_be_null' stops `re_search_2' from using the fastmap, so
        -: 4793:           that is all we do.  */
    #####: 4794:	case duplicate:
    #####: 4795:	  bufp->can_be_null = 1;
    #####: 4796:          return 0;
        -: 4797:
        -: 4798:
        -: 4799:      /* Following are the cases which match a character.  These end
        -: 4800:         with `break'.  */
        -: 4801:
      520: 4802:	case exactn:
      520: 4803:          fastmap[p[1]] = 1;
      520: 4804:	  break;
        -: 4805:
        -: 4806:
        2: 4807:        case charset:
      242: 4808:          for (j = *p++ * BYTEWIDTH - 1; j >= 0; j--)
branch  0 taken 240
branch  1 taken 2 (fallthrough)
      240: 4809:	    if (p[j / BYTEWIDTH] & (1 << (j % BYTEWIDTH)))
branch  0 taken 4 (fallthrough)
branch  1 taken 236
        4: 4810:              fastmap[j] = 1;
        2: 4811:	  break;
        -: 4812:
        -: 4813:
        1: 4814:	case charset_not:
        -: 4815:	  /* Chars beyond end of map must be allowed.  */
      137: 4816:	  for (j = *p * BYTEWIDTH; j < (1 << BYTEWIDTH); j++)
branch  0 taken 136
branch  1 taken 1 (fallthrough)
      136: 4817:            fastmap[j] = 1;
        -: 4818:
      121: 4819:	  for (j = *p++ * BYTEWIDTH - 1; j >= 0; j--)
branch  0 taken 120
branch  1 taken 1 (fallthrough)
      120: 4820:	    if (!(p[j / BYTEWIDTH] & (1 << (j % BYTEWIDTH))))
branch  0 taken 104 (fallthrough)
branch  1 taken 16
      104: 4821:              fastmap[j] = 1;
        1: 4822:          break;
        -: 4823:
        -: 4824:
    #####: 4825:	case wordchar:
    #####: 4826:	  for (j = 0; j < (1 << BYTEWIDTH); j++)
branch  0 never executed
branch  1 never executed
    #####: 4827:	    if (SYNTAX (j) == Sword)
branch  0 never executed
branch  1 never executed
    #####: 4828:	      fastmap[j] = 1;
    #####: 4829:	  break;
        -: 4830:
        -: 4831:
    #####: 4832:	case notwordchar:
    #####: 4833:	  for (j = 0; j < (1 << BYTEWIDTH); j++)
branch  0 never executed
branch  1 never executed
    #####: 4834:	    if (SYNTAX (j) != Sword)
branch  0 never executed
branch  1 never executed
    #####: 4835:	      fastmap[j] = 1;
    #####: 4836:	  break;
        -: 4837:
        -: 4838:
       47: 4839:        case anychar:
        -: 4840:          /* `.' matches anything ...  */
    12079: 4841:	  for (j = 0; j < (1 << BYTEWIDTH); j++)
branch  0 taken 12032
branch  1 taken 47 (fallthrough)
    12032: 4842:            fastmap[j] = 1;
        -: 4843:
        -: 4844:          /* ... except perhaps newline.  */
       47: 4845:          if (!(bufp->syntax & RE_DOT_NEWLINE))
branch  0 taken 0 (fallthrough)
branch  1 taken 47
    #####: 4846:            fastmap['\n'] = 0;
        -: 4847:
        -: 4848:          /* Return if we have already set `can_be_null'; if we have,
        -: 4849:             then the fastmap is irrelevant.  Something's wrong here.  */
       47: 4850:	  else if (bufp->can_be_null)
branch  0 taken 16 (fallthrough)
branch  1 taken 31
       16: 4851:	    return 0;
        -: 4852:
        -: 4853:          /* Otherwise, have to check alternative paths.  */
       31: 4854:	  break;
        -: 4855:
        -: 4856:
        -: 4857:#ifdef emacs
        -: 4858:        case syntaxspec:
        -: 4859:	  k = *p++;
        -: 4860:	  for (j = 0; j < (1 << BYTEWIDTH); j++)
        -: 4861:	    if (SYNTAX (j) == (enum syntaxcode) k)
        -: 4862:	      fastmap[j] = 1;
        -: 4863:	  break;
        -: 4864:
        -: 4865:
        -: 4866:	case notsyntaxspec:
        -: 4867:	  k = *p++;
        -: 4868:	  for (j = 0; j < (1 << BYTEWIDTH); j++)
        -: 4869:	    if (SYNTAX (j) != (enum syntaxcode) k)
        -: 4870:	      fastmap[j] = 1;
        -: 4871:	  break;
        -: 4872:
        -: 4873:
        -: 4874:      /* All cases after this match the empty string.  These end with
        -: 4875:         `continue'.  */
        -: 4876:
        -: 4877:
        -: 4878:	case before_dot:
        -: 4879:	case at_dot:
        -: 4880:	case after_dot:
        -: 4881:          continue;
        -: 4882:#endif /* not emacs */
        -: 4883:
        -: 4884:
      197: 4885:        case no_op:
        -: 4886:        case begline:
        -: 4887:        case endline:
        -: 4888:	case begbuf:
        -: 4889:	case endbuf:
        -: 4890:	case wordbound:
        -: 4891:	case notwordbound:
        -: 4892:	case wordbeg:
        -: 4893:	case wordend:
        -: 4894:        case push_dummy_failure:
      197: 4895:          continue;
        -: 4896:
        -: 4897:
    #####: 4898:	case jump_n:
        -: 4899:        case pop_failure_jump:
        -: 4900:	case maybe_pop_jump:
        -: 4901:	case jump:
        -: 4902:        case jump_past_alt:
        -: 4903:	case dummy_failure_jump:
    #####: 4904:          EXTRACT_NUMBER_AND_INCR (j, p);
    #####: 4905:	  p += j;	
    #####: 4906:	  if (j > 0)
branch  0 never executed
branch  1 never executed
    #####: 4907:	    continue;
        -: 4908:            
        -: 4909:          /* Jump backward implies we just went through the body of a
        -: 4910:             loop and matched nothing.  Opcode jumped to should be
        -: 4911:             `on_failure_jump' or `succeed_n'.  Just treat it like an
        -: 4912:             ordinary jump.  For a * loop, it has pushed its failure
        -: 4913:             point already; if so, discard that as redundant.  */
    #####: 4914:          if ((re_opcode_t) *p != on_failure_jump
branch  0 never executed
branch  1 never executed
    #####: 4915:	      && (re_opcode_t) *p != succeed_n)
branch  0 never executed
branch  1 never executed
    #####: 4916:	    continue;
        -: 4917:
    #####: 4918:          p++;
    #####: 4919:          EXTRACT_NUMBER_AND_INCR (j, p);
    #####: 4920:          p += j;		
        -: 4921:	  
        -: 4922:          /* If what's on the stack is where we are now, pop it.  */
    #####: 4923:          if (!FAIL_STACK_EMPTY () 
branch  0 never executed
branch  1 never executed
    #####: 4924:	      && fail_stack.stack[fail_stack.avail - 1] == p)
branch  0 never executed
branch  1 never executed
    #####: 4925:            fail_stack.avail--;
        -: 4926:
    #####: 4927:          continue;
        -: 4928:
        -: 4929:
        -: 4930:        case on_failure_jump:
        -: 4931:        case on_failure_keep_string_jump:
       47: 4932:	handle_on_failure_jump:
       47: 4933:          EXTRACT_NUMBER_AND_INCR (j, p);
        -: 4934:
        -: 4935:          /* For some patterns, e.g., `(a?)?', `p+j' here points to the
        -: 4936:             end of the pattern.  We don't want to push such a point,
        -: 4937:             since when we restore it above, entering the switch will
        -: 4938:             increment `p' past the end of the pattern.  We don't need
        -: 4939:             to push such a point since we obviously won't find any more
        -: 4940:             fastmap entries beyond `pend'.  Such a pattern can match
        -: 4941:             the null string, though.  */
       47: 4942:          if (p + j < pend)
branch  0 taken 31 (fallthrough)
branch  1 taken 16
        -: 4943:            {
      31*: 4944:              if (!PUSH_PATTERN_OP (p + j, fail_stack))
branch  0 taken 0 (fallthrough)
branch  1 taken 31
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 taken 0 (fallthrough)
branch  9 taken 31
    #####: 4945:                return -2;
        -: 4946:            }
        -: 4947:          else
       16: 4948:            bufp->can_be_null = 1;
        -: 4949:
       47: 4950:          if (succeed_n_p)
branch  0 taken 0 (fallthrough)
branch  1 taken 47
        -: 4951:            {
    #####: 4952:              EXTRACT_NUMBER_AND_INCR (k, p);	/* Skip the n.  */
    #####: 4953:              succeed_n_p = false;
        -: 4954:	    }
        -: 4955:
       47: 4956:          continue;
        -: 4957:
        -: 4958:
        1: 4959:	case succeed_n:
        -: 4960:          /* Get to the number of times to succeed.  */
        1: 4961:          p += 2;		
        -: 4962:
        -: 4963:          /* Increment p past the n for when k != 0.  */
        1: 4964:          EXTRACT_NUMBER_AND_INCR (k, p);
        1: 4965:          if (k == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -: 4966:	    {
    #####: 4967:              p -= 4;
    #####: 4968:  	      succeed_n_p = true;  /* Spaghetti code alert.  */
    #####: 4969:              goto handle_on_failure_jump;
        -: 4970:            }
        1: 4971:          continue;
        -: 4972:
        -: 4973:
        2: 4974:	case set_number_at:
        2: 4975:          p += 4;
        2: 4976:          continue;
        -: 4977:
        -: 4978:
    #####: 4979:	case start_memory:
        -: 4980:        case stop_memory:
    #####: 4981:	  p += 2;
    #####: 4982:	  continue;
        -: 4983:
        -: 4984:
    #####: 4985:	default:
    #####: 4986:          abort (); /* We have listed all the cases.  */
call    0 never executed
        -: 4987:        } /* switch *p++ */
        -: 4988:
        -: 4989:      /* Getting here means we have found the possible starting
        -: 4990:         characters for one path of the pattern -- and that the empty
        -: 4991:         string does not match.  We need not follow this path further.
        -: 4992:         Instead, look at the next alternative (remembered on the
        -: 4993:         stack), or quit if no more.  The test at the top of the loop
        -: 4994:         does these things.  */
      554: 4995:      path_can_be_null = false;
      554: 4996:      p = pend;
        -: 4997:    } /* while p */
        -: 4998:
        -: 4999:  /* Set `can_be_null' for the last path (also the first path, if the
        -: 5000:     pattern is empty).  */
      581: 5001:  bufp->can_be_null |= path_can_be_null;
      581: 5002:  return 0;
        -: 5003:} /* re_compile_fastmap */
        -: 5004:
        -: 5005:/* Set REGS to hold NUM_REGS registers, storing them in STARTS and
        -: 5006:   ENDS.  Subsequent matches using PATTERN_BUFFER and REGS will use
        -: 5007:   this memory for recording register information.  STARTS and ENDS
        -: 5008:   must be allocated using the malloc library routine, and must each
        -: 5009:   be at least NUM_REGS * sizeof (regoff_t) bytes long.
        -: 5010:
        -: 5011:   If NUM_REGS == 0, then subsequent matches should allocate their own
        -: 5012:   register data.
        -: 5013:
        -: 5014:   Unless this function is called, the first search or match using
        -: 5015:   PATTERN_BUFFER will allocate its own register data, without
        -: 5016:   freeing the old data.  */
        -: 5017:
        -: 5018:void
function re_set_registers called 0 returned 0% blocks executed 0%
    #####: 5019:re_set_registers (bufp, regs, num_regs, starts, ends)
        -: 5020:    struct re_pattern_buffer *bufp;
        -: 5021:    struct re_registers *regs;
        -: 5022:    unsigned num_regs;
        -: 5023:    regoff_t *starts, *ends;
        -: 5024:{
    #####: 5025:  if (num_regs)
branch  0 never executed
branch  1 never executed
        -: 5026:    {
    #####: 5027:      bufp->regs_allocated = REGS_REALLOCATE;
    #####: 5028:      regs->num_regs = num_regs;
    #####: 5029:      regs->start = starts;
    #####: 5030:      regs->end = ends;
        -: 5031:    }
        -: 5032:  else
        -: 5033:    {
    #####: 5034:      bufp->regs_allocated = REGS_UNALLOCATED;
    #####: 5035:      regs->num_regs = 0;
    #####: 5036:      regs->start = regs->end = (regoff_t) 0;
        -: 5037:    }
    #####: 5038:}
        -: 5039:
        -: 5040:/* Searching routines.  */
        -: 5041:
        -: 5042:/* Like re_search_2, below, but only one string is specified, and
        -: 5043:   doesn't let you say where to stop matching. */
        -: 5044:
        -: 5045:int
function re_search called 46942 returned 100% blocks executed 100%
    46942: 5046:re_search (bufp, string, size, startpos, range, regs)
        -: 5047:     struct re_pattern_buffer *bufp;
        -: 5048:     const char *string;
        -: 5049:     int size, startpos, range;
        -: 5050:     struct re_registers *regs;
        -: 5051:{
    46942: 5052:  return re_search_2 (bufp, NULL, 0, string, size, startpos, range, 
call    0 returned 46942
        -: 5053:		      regs, size);
        -: 5054:}
        -: 5055:
        -: 5056:
        -: 5057:/* Using the compiled pattern in BUFP->buffer, first tries to match the
        -: 5058:   virtual concatenation of STRING1 and STRING2, starting first at index
        -: 5059:   STARTPOS, then at STARTPOS + 1, and so on.
        -: 5060:   
        -: 5061:   STRING1 and STRING2 have length SIZE1 and SIZE2, respectively.
        -: 5062:   
        -: 5063:   RANGE is how far to scan while trying to match.  RANGE = 0 means try
        -: 5064:   only at STARTPOS; in general, the last start tried is STARTPOS +
        -: 5065:   RANGE.
        -: 5066:   
        -: 5067:   In REGS, return the indices of the virtual concatenation of STRING1
        -: 5068:   and STRING2 that matched the entire BUFP->buffer and its contained
        -: 5069:   subexpressions.
        -: 5070:   
        -: 5071:   Do not consider matching one past the index STOP in the virtual
        -: 5072:   concatenation of STRING1 and STRING2.
        -: 5073:
        -: 5074:   We return either the position in the strings at which the match was
        -: 5075:   found, -1 if no match, or -2 if error (such as failure
        -: 5076:   stack overflow).  */
        -: 5077:
        -: 5078:int
function re_search_2 called 46942 returned 100% blocks executed 76%
    46942: 5079:re_search_2 (bufp, string1, size1, string2, size2, startpos, range, regs, stop)
        -: 5080:     struct re_pattern_buffer *bufp;
        -: 5081:     const char *string1, *string2;
        -: 5082:     int size1, size2;
        -: 5083:     int startpos;
        -: 5084:     int range;
        -: 5085:     struct re_registers *regs;
        -: 5086:     int stop;
        -: 5087:{
        -: 5088:  int val;
    46942: 5089:  register char *fastmap = bufp->fastmap;
    46942: 5090:  register char *translate = bufp->translate;
    46942: 5091:  int total_size = size1 + size2;
    46942: 5092:  int endpos = startpos + range;
        -: 5093:
        -: 5094:  /* Check for out-of-range STARTPOS.  */
    46942: 5095:  if (startpos < 0 || startpos > total_size)
branch  0 taken 46942 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 46942
    #####: 5096:    return -1;
        -: 5097:    
        -: 5098:  /* Fix up RANGE if it might eventually take us outside
        -: 5099:     the virtual concatenation of STRING1 and STRING2.  */
    46942: 5100:  if (endpos < -1)
branch  0 taken 0 (fallthrough)
branch  1 taken 46942
    #####: 5101:    range = -1 - startpos;
    46942: 5102:  else if (endpos > total_size)
branch  0 taken 0 (fallthrough)
branch  1 taken 46942
    #####: 5103:    range = total_size - startpos;
        -: 5104:
        -: 5105:  /* If the search isn't to be a backwards one, don't waste time in a
        -: 5106:     search for a pattern that must be anchored.  */
    46942: 5107:  if (bufp->used > 0 && (re_opcode_t) bufp->buffer[0] == begbuf && range > 0)
branch  0 taken 46942 (fallthrough)
branch  1 taken 0
branch  2 taken 11279 (fallthrough)
branch  3 taken 35663
branch  4 taken 7948 (fallthrough)
branch  5 taken 3331
        -: 5108:    {
     7948: 5109:      if (startpos > 0)
branch  0 taken 522 (fallthrough)
branch  1 taken 7426
      522: 5110:	return -1;
        -: 5111:      else
     7426: 5112:	range = 1;
        -: 5113:    }
        -: 5114:
        -: 5115:  /* Update the fastmap now if not correct already.  */
    46420: 5116:  if (fastmap && !bufp->fastmap_accurate)
branch  0 taken 46420 (fallthrough)
branch  1 taken 0
branch  2 taken 597 (fallthrough)
branch  3 taken 45823
      597: 5117:    if (re_compile_fastmap (bufp) == -2)
call    0 returned 597
branch  1 taken 0 (fallthrough)
branch  2 taken 597
    #####: 5118:      return -2;
        -: 5119:  
        -: 5120:  /* Loop through the string, looking for a place to start matching.  */
        -: 5121:  for (;;)
        -: 5122:    { 
        -: 5123:      /* If a fastmap is supplied, skip quickly over characters that
        -: 5124:         cannot be the start of a match.  If the pattern can match the
        -: 5125:         null string, however, we don't need to skip characters; we want
        -: 5126:         the first null string.  */
    81876: 5127:      if (fastmap && startpos < total_size && !bufp->can_be_null)
branch  0 taken 81876 (fallthrough)
branch  1 taken 0
branch  2 taken 64819 (fallthrough)
branch  3 taken 17057
branch  4 taken 59165 (fallthrough)
branch  5 taken 5654
        -: 5128:	{
    59165: 5129:	  if (range > 0)	/* Searching forwards.  */
branch  0 taken 58825 (fallthrough)
branch  1 taken 340
        -: 5130:	    {
        -: 5131:	      register const char *d;
    58825: 5132:	      register int lim = 0;
    58825: 5133:	      int irange = range;
        -: 5134:
   58825*: 5135:              if (startpos < size1 && startpos + range >= size1)
branch  0 taken 0 (fallthrough)
branch  1 taken 58825
branch  2 never executed
branch  3 never executed
    #####: 5136:                lim = range - (size1 - startpos);
        -: 5137:
   58825*: 5138:	      d = (startpos >= size1 ? string2 - size1 : string1) + startpos;
branch  0 taken 58825 (fallthrough)
branch  1 taken 0
        -: 5139:   
        -: 5140:              /* Written out as an if-else to avoid testing `translate'
        -: 5141:                 inside the loop.  */
    58825: 5142:	      if (translate)
branch  0 taken 0 (fallthrough)
branch  1 taken 58825
    #####: 5143:                while (range > lim
    #####: 5144:                       && !fastmap[(unsigned char)
branch  0 never executed
branch  1 never executed
    #####: 5145:				   translate[(unsigned char) *d++]])
branch  0 never executed
branch  1 never executed
    #####: 5146:                  range--;
        -: 5147:	      else
   489803: 5148:                while (range > lim && !fastmap[(unsigned char) *d++])
branch  0 taken 467644 (fallthrough)
branch  1 taken 22159
branch  2 taken 430978
branch  3 taken 36666 (fallthrough)
   430978: 5149:                  range--;
        -: 5150:
    58825: 5151:	      startpos += irange - range;
        -: 5152:	    }
        -: 5153:	  else				/* Searching backwards.  */
        -: 5154:	    {
     340*: 5155:	      register char c = (size1 == 0 || startpos >= size1
branch  0 taken 0 (fallthrough)
branch  1 taken 340
branch  2 never executed
branch  3 never executed
      340: 5156:                                 ? string2[startpos - size1] 
    #####: 5157:                                 : string1[startpos]);
        -: 5158:
     340*: 5159:	      if (!fastmap[(unsigned char) TRANSLATE (c)])
branch  0 taken 0 (fallthrough)
branch  1 taken 340
branch  2 taken 54 (fallthrough)
branch  3 taken 286
       54: 5160:		goto advance;
        -: 5161:	    }
        -: 5162:	}
        -: 5163:
        -: 5164:      /* If can't match the null string, and that's all we have left, fail.  */
    81822: 5165:      if (range >= 0 && startpos == total_size && fastmap
branch  0 taken 81822 (fallthrough)
branch  1 taken 0
branch  2 taken 35522 (fallthrough)
branch  3 taken 46300
branch  4 taken 35522 (fallthrough)
branch  5 taken 0
    35522: 5166:          && !bufp->can_be_null)
branch  0 taken 33976 (fallthrough)
branch  1 taken 1546
    33976: 5167:	return -1;
        -: 5168:
    47846: 5169:      val = re_match_2 (bufp, string1, size1, string2, size2,
call    0 returned 47846
        -: 5170:	                startpos, regs, stop);
    47846: 5171:      if (val >= 0)
branch  0 taken 5869 (fallthrough)
branch  1 taken 41977
     5869: 5172:	return startpos;
        -: 5173:        
    41977: 5174:      if (val == -2)
branch  0 taken 0 (fallthrough)
branch  1 taken 41977
    #####: 5175:	return -2;
        -: 5176:
    41977: 5177:    advance:
    42031: 5178:      if (!range) 
branch  0 taken 6575 (fallthrough)
branch  1 taken 35456
     6575: 5179:        break;
    35456: 5180:      else if (range > 0) 
branch  0 taken 35456 (fallthrough)
branch  1 taken 0
        -: 5181:        {
    35456: 5182:          range--; 
    35456: 5183:          startpos++;
        -: 5184:        }
        -: 5185:      else
        -: 5186:        {
    #####: 5187:          range++; 
    #####: 5188:          startpos--;
        -: 5189:        }
        -: 5190:    }
     6575: 5191:  return -1;
        -: 5192:} /* re_search_2 */
        -: 5193:
        -: 5194:/* Declarations and macros for re_match_2.  */
        -: 5195:
        -: 5196:static int bcmp_translate ();
        -: 5197:static boolean alt_match_null_string_p (),
        -: 5198:               common_op_match_null_string_p (),
        -: 5199:               group_match_null_string_p ();
        -: 5200:
        -: 5201:/* Structure for per-register (a.k.a. per-group) information.
        -: 5202:   This must not be longer than one word, because we push this value
        -: 5203:   onto the failure stack.  Other register information, such as the
        -: 5204:   starting and ending positions (which are addresses), and the list of
        -: 5205:   inner groups (which is a bits list) are maintained in separate
        -: 5206:   variables.  
        -: 5207:   
        -: 5208:   We are making a (strictly speaking) nonportable assumption here: that
        -: 5209:   the compiler will pack our bit fields into something that fits into
        -: 5210:   the type of `word', i.e., is something that fits into one item on the
        -: 5211:   failure stack.  */
        -: 5212:typedef union
        -: 5213:{
        -: 5214:  fail_stack_elt_t word;
        -: 5215:  struct
        -: 5216:  {
        -: 5217:      /* This field is one if this group can match the empty string,
        -: 5218:         zero if not.  If not yet determined,  `MATCH_NULL_UNSET_VALUE'.  */
        -: 5219:#define MATCH_NULL_UNSET_VALUE 3
        -: 5220:    unsigned match_null_string_p : 2;
        -: 5221:    unsigned is_active : 1;
        -: 5222:    unsigned matched_something : 1;
        -: 5223:    unsigned ever_matched_something : 1;
        -: 5224:  } bits;
        -: 5225:} register_info_type;
        -: 5226:
        -: 5227:#define REG_MATCH_NULL_STRING_P(R)  ((R).bits.match_null_string_p)
        -: 5228:#define IS_ACTIVE(R)  ((R).bits.is_active)
        -: 5229:#define MATCHED_SOMETHING(R)  ((R).bits.matched_something)
        -: 5230:#define EVER_MATCHED_SOMETHING(R)  ((R).bits.ever_matched_something)
        -: 5231:
        -: 5232:
        -: 5233:/* Call this when have matched a real character; it sets `matched' flags
        -: 5234:   for the subexpressions which we are currently inside.  Also records
        -: 5235:   that those subexprs have matched.  */
        -: 5236:#define SET_REGS_MATCHED()						\
        -: 5237:  do									\
        -: 5238:    {									\
        -: 5239:      unsigned r;							\
        -: 5240:      for (r = lowest_active_reg; r <= highest_active_reg; r++)		\
        -: 5241:        {								\
        -: 5242:          MATCHED_SOMETHING (reg_info[r])				\
        -: 5243:            = EVER_MATCHED_SOMETHING (reg_info[r])			\
        -: 5244:            = 1;							\
        -: 5245:        }								\
        -: 5246:    }									\
        -: 5247:  while (0)
        -: 5248:
        -: 5249:
        -: 5250:/* This converts PTR, a pointer into one of the search strings `string1'
        -: 5251:   and `string2' into an offset from the beginning of that string.  */
        -: 5252:#define POINTER_TO_OFFSET(ptr)						\
        -: 5253:  (FIRST_STRING_P (ptr) ? (ptr) - string1 : (ptr) - string2 + size1)
        -: 5254:
        -: 5255:/* Registers are set to a sentinel when they haven't yet matched.  */
        -: 5256:#define REG_UNSET_VALUE ((char *) -1)
        -: 5257:#define REG_UNSET(e) ((e) == REG_UNSET_VALUE)
        -: 5258:
        -: 5259:
        -: 5260:/* Macros for dealing with the split strings in re_match_2.  */
        -: 5261:
        -: 5262:#define MATCHING_IN_FIRST_STRING  (dend == end_match_1)
        -: 5263:
        -: 5264:/* Call before fetching a character with *d.  This switches over to
        -: 5265:   string2 if necessary.  */
        -: 5266:#define PREFETCH()							\
        -: 5267:  while (d == dend)						    	\
        -: 5268:    {									\
        -: 5269:      /* End of string2 => fail.  */					\
        -: 5270:      if (dend == end_match_2) 						\
        -: 5271:        goto fail;							\
        -: 5272:      /* End of string1 => advance to string2.  */ 			\
        -: 5273:      d = string2;						        \
        -: 5274:      dend = end_match_2;						\
        -: 5275:    }
        -: 5276:
        -: 5277:
        -: 5278:/* Test if at very beginning or at very end of the virtual concatenation
        -: 5279:   of `string1' and `string2'.  If only one string, it's `string2'.  */
        -: 5280:#define AT_STRINGS_BEG(d) ((d) == (size1 ? string1 : string2) || !size2)
        -: 5281:#define AT_STRINGS_END(d) ((d) == end2)	
        -: 5282:
        -: 5283:
        -: 5284:/* Test if D points to a character which is word-constituent.  We have
        -: 5285:   two special cases to check for: if past the end of string1, look at
        -: 5286:   the first character in string2; and if before the beginning of
        -: 5287:   string2, look at the last character in string1.  */
        -: 5288:#define WORDCHAR_P(d)							\
        -: 5289:  (SYNTAX ((d) == end1 ? *string2					\
        -: 5290:           : (d) == string2 - 1 ? *(end1 - 1) : *(d))			\
        -: 5291:   == Sword)
        -: 5292:
        -: 5293:/* Test if the character before D and the one at D differ with respect
        -: 5294:   to being word-constituent.  */
        -: 5295:#define AT_WORD_BOUNDARY(d)						\
        -: 5296:  (AT_STRINGS_BEG (d) || AT_STRINGS_END (d)				\
        -: 5297:   || WORDCHAR_P (d - 1) != WORDCHAR_P (d))
        -: 5298:
        -: 5299:
        -: 5300:/* Free everything we malloc.  */
        -: 5301:#ifdef REGEX_MALLOC
        -: 5302:#define FREE_VAR(var) if (var) free (var); var = NULL
        -: 5303:#define FREE_VARIABLES()						\
        -: 5304:  do {									\
        -: 5305:    FREE_VAR (fail_stack.stack);					\
        -: 5306:    FREE_VAR (regstart);						\
        -: 5307:    FREE_VAR (regend);							\
        -: 5308:    FREE_VAR (old_regstart);						\
        -: 5309:    FREE_VAR (old_regend);						\
        -: 5310:    FREE_VAR (best_regstart);						\
        -: 5311:    FREE_VAR (best_regend);						\
        -: 5312:    FREE_VAR (reg_info);						\
        -: 5313:    FREE_VAR (reg_dummy);						\
        -: 5314:    FREE_VAR (reg_info_dummy);						\
        -: 5315:  } while (0)
        -: 5316:#else /* not REGEX_MALLOC */
        -: 5317:/* Some MIPS systems (at least) want this to free alloca'd storage.  */
        -: 5318:#define FREE_VARIABLES() alloca (0)
        -: 5319:#endif /* not REGEX_MALLOC */
        -: 5320:
        -: 5321:
        -: 5322:/* These values must meet several constraints.  They must not be valid
        -: 5323:   register values; since we have a limit of 255 registers (because
        -: 5324:   we use only one byte in the pattern for the register number), we can
        -: 5325:   use numbers larger than 255.  They must differ by 1, because of
        -: 5326:   NUM_FAILURE_ITEMS above.  And the value for the lowest register must
        -: 5327:   be larger than the value for the highest register, so we do not try
        -: 5328:   to actually save any registers when none are active.  */
        -: 5329:#define NO_HIGHEST_ACTIVE_REG (1 << BYTEWIDTH)
        -: 5330:#define NO_LOWEST_ACTIVE_REG (NO_HIGHEST_ACTIVE_REG + 1)
        -: 5331:
        -: 5332:/* Matching routines.  */
        -: 5333:
        -: 5334:#ifndef emacs   /* Emacs never uses this.  */
        -: 5335:/* re_match is like re_match_2 except it takes only a single string.  */
        -: 5336:
        -: 5337:int
function re_match called 0 returned 0% blocks executed 0%
    #####: 5338:re_match (bufp, string, size, pos, regs)
        -: 5339:     struct re_pattern_buffer *bufp;
        -: 5340:     const char *string;
        -: 5341:     int size, pos;
        -: 5342:     struct re_registers *regs;
        -: 5343: {
    #####: 5344:  return re_match_2 (bufp, NULL, 0, string, size, pos, regs, size); 
call    0 never executed
        -: 5345:}
        -: 5346:#endif /* not emacs */
        -: 5347:
        -: 5348:
        -: 5349:/* re_match_2 matches the compiled pattern in BUFP against the
        -: 5350:   the (virtual) concatenation of STRING1 and STRING2 (of length SIZE1
        -: 5351:   and SIZE2, respectively).  We start matching at POS, and stop
        -: 5352:   matching at STOP.
        -: 5353:   
        -: 5354:   If REGS is non-null and the `no_sub' field of BUFP is nonzero, we
        -: 5355:   store offsets for the substring each group matched in REGS.  See the
        -: 5356:   documentation for exactly how many groups we fill.
        -: 5357:
        -: 5358:   We return -1 if no match, -2 if an internal error (such as the
        -: 5359:   failure stack overflowing).  Otherwise, we return the length of the
        -: 5360:   matched substring.  */
        -: 5361:
        -: 5362:int
function re_match_2 called 47846 returned 100% blocks executed 38%
    47846: 5363:re_match_2 (bufp, string1, size1, string2, size2, pos, regs, stop)
        -: 5364:     struct re_pattern_buffer *bufp;
        -: 5365:     const char *string1, *string2;
        -: 5366:     int size1, size2;
        -: 5367:     int pos;
        -: 5368:     struct re_registers *regs;
        -: 5369:     int stop;
  1188048: 5370:{
        -: 5371:  /* General temporaries.  */
        -: 5372:  int mcnt;
        -: 5373:  unsigned char *p1;
        -: 5374:
        -: 5375:  /* Just past the end of the corresponding string.  */
        -: 5376:  const char *end1, *end2;
        -: 5377:
        -: 5378:  /* Pointers into string1 and string2, just past the last characters in
        -: 5379:     each to consider matching.  */
        -: 5380:  const char *end_match_1, *end_match_2;
        -: 5381:
        -: 5382:  /* Where we are in the data, and the end of the current string.  */
        -: 5383:  const char *d, *dend;
        -: 5384:  
        -: 5385:  /* Where we are in the pattern, and the end of the pattern.  */
    47846: 5386:  unsigned char *p = bufp->buffer;
    47846: 5387:  register unsigned char *pend = p + bufp->used;
        -: 5388:
        -: 5389:  /* We use this to map every character in the string.  */
    47846: 5390:  char *translate = bufp->translate;
        -: 5391:
        -: 5392:  /* Failure point stack.  Each place that can handle a failure further
        -: 5393:     down the line pushes a failure point on this stack.  It consists of
        -: 5394:     restart, regend, and reg_info for all registers corresponding to
        -: 5395:     the subexpressions we're currently inside, plus the number of such
        -: 5396:     registers, and, finally, two char *'s.  The first char * is where
        -: 5397:     to resume scanning the pattern; the second one is where to resume
        -: 5398:     scanning the strings.  If the latter is zero, the failure point is
        -: 5399:     a ``dummy''; if a failure happens and the failure point is a dummy,
        -: 5400:     it gets discarded and the next next one is tried.  */
        -: 5401:  fail_stack_type fail_stack;
        -: 5402:#ifdef DEBUG
        -: 5403:  static unsigned failure_id = 0;
        -: 5404:  unsigned nfailure_points_pushed = 0, nfailure_points_popped = 0;
        -: 5405:#endif
        -: 5406:
        -: 5407:  /* We fill all the registers internally, independent of what we
        -: 5408:     return, for use in backreferences.  The number here includes
        -: 5409:     an element for register zero.  */
    47846: 5410:  unsigned num_regs = bufp->re_nsub + 1;
        -: 5411:  
        -: 5412:  /* The currently active registers.  */
    47846: 5413:  unsigned lowest_active_reg = NO_LOWEST_ACTIVE_REG;
    47846: 5414:  unsigned highest_active_reg = NO_HIGHEST_ACTIVE_REG;
        -: 5415:
        -: 5416:  /* Information on the contents of registers. These are pointers into
        -: 5417:     the input strings; they record just what was matched (on this
        -: 5418:     attempt) by a subexpression part of the pattern, that is, the
        -: 5419:     regnum-th regstart pointer points to where in the pattern we began
        -: 5420:     matching and the regnum-th regend points to right after where we
        -: 5421:     stopped matching the regnum-th subexpression.  (The zeroth register
        -: 5422:     keeps track of what the whole pattern matches.)  */
        -: 5423:  const char **regstart, **regend;
        -: 5424:
        -: 5425:  /* If a group that's operated upon by a repetition operator fails to
        -: 5426:     match anything, then the register for its start will need to be
        -: 5427:     restored because it will have been set to wherever in the string we
        -: 5428:     are when we last see its open-group operator.  Similarly for a
        -: 5429:     register's end.  */
        -: 5430:  const char **old_regstart, **old_regend;
        -: 5431:
        -: 5432:  /* The is_active field of reg_info helps us keep track of which (possibly
        -: 5433:     nested) subexpressions we are currently in. The matched_something
        -: 5434:     field of reg_info[reg_num] helps us tell whether or not we have
        -: 5435:     matched any of the pattern so far this time through the reg_num-th
        -: 5436:     subexpression.  These two fields get reset each time through any
        -: 5437:     loop their register is in.  */
        -: 5438:  register_info_type *reg_info; 
        -: 5439:
        -: 5440:  /* The following record the register info as found in the above
        -: 5441:     variables when we find a match better than any we've seen before. 
        -: 5442:     This happens as we backtrack through the failure points, which in
        -: 5443:     turn happens only if we have not yet matched the entire string. */
    47846: 5444:  unsigned best_regs_set = false;
        -: 5445:  const char **best_regstart, **best_regend;
        -: 5446:  
        -: 5447:  /* Logically, this is `best_regend[0]'.  But we don't want to have to
        -: 5448:     allocate space for that if we're not allocating space for anything
        -: 5449:     else (see below).  Also, we never need info about register 0 for
        -: 5450:     any of the other register vectors, and it seems rather a kludge to
        -: 5451:     treat `best_regend' differently than the rest.  So we keep track of
        -: 5452:     the end of the best match so far in a separate variable.  We
        -: 5453:     initialize this to NULL so that when we backtrack the first time
        -: 5454:     and need to test it, it's not garbage.  */
    47846: 5455:  const char *match_end = NULL;
        -: 5456:
        -: 5457:  /* Used when we pop values we don't care about.  */
        -: 5458:  const char **reg_dummy;
        -: 5459:  register_info_type *reg_info_dummy;
        -: 5460:
        -: 5461:#ifdef DEBUG
        -: 5462:  /* Counts the total number of registers pushed.  */
        -: 5463:  unsigned num_regs_pushed = 0; 	
        -: 5464:#endif
        -: 5465:
        -: 5466:  DEBUG_PRINT1 ("\n\nEntering re_match_2.\n");
        -: 5467:  
   47846*: 5468:  INIT_FAIL_STACK ();
branch  0 taken 0 (fallthrough)
branch  1 taken 47846
        -: 5469:  
        -: 5470:  /* Do not bother to initialize all the register variables if there are
        -: 5471:     no groups in the pattern, as it takes a fair amount of time.  If
        -: 5472:     there are groups, we include space for register 0 (the whole
        -: 5473:     pattern), even though we never use it, since it simplifies the
        -: 5474:     array indexing.  We should fix this.  */
    47846: 5475:  if (bufp->re_nsub)
branch  0 taken 24 (fallthrough)
branch  1 taken 47822
        -: 5476:    {
       24: 5477:      regstart = REGEX_TALLOC (num_regs, const char *);
       24: 5478:      regend = REGEX_TALLOC (num_regs, const char *);
       24: 5479:      old_regstart = REGEX_TALLOC (num_regs, const char *);
       24: 5480:      old_regend = REGEX_TALLOC (num_regs, const char *);
       24: 5481:      best_regstart = REGEX_TALLOC (num_regs, const char *);
       24: 5482:      best_regend = REGEX_TALLOC (num_regs, const char *);
       24: 5483:      reg_info = REGEX_TALLOC (num_regs, register_info_type);
       24: 5484:      reg_dummy = REGEX_TALLOC (num_regs, const char *);
       24: 5485:      reg_info_dummy = REGEX_TALLOC (num_regs, register_info_type);
        -: 5486:
       48: 5487:      if (!(regstart && regend && old_regstart && old_regend && reg_info 
branch  0 taken 24 (fallthrough)
branch  1 taken 0
branch  2 taken 24 (fallthrough)
branch  3 taken 0
branch  4 taken 24 (fallthrough)
branch  5 taken 0
branch  6 taken 24 (fallthrough)
branch  7 taken 0
branch  8 taken 24 (fallthrough)
branch  9 taken 0
branch 10 taken 0 (fallthrough)
branch 11 taken 24
       24: 5488:            && best_regstart && best_regend && reg_dummy && reg_info_dummy)) 
branch  0 taken 24 (fallthrough)
branch  1 taken 0
branch  2 taken 24 (fallthrough)
branch  3 taken 0
branch  4 taken 24 (fallthrough)
branch  5 taken 0
        -: 5489:        {
    #####: 5490:          FREE_VARIABLES ();
    #####: 5491:          return -2;
        -: 5492:        }
        -: 5493:    }
        -: 5494:#ifdef REGEX_MALLOC
        -: 5495:  else
        -: 5496:    {
        -: 5497:      /* We must initialize all our variables to NULL, so that
        -: 5498:         `FREE_VARIABLES' doesn't try to free them.  */
        -: 5499:      regstart = regend = old_regstart = old_regend = best_regstart
        -: 5500:        = best_regend = reg_dummy = NULL;
        -: 5501:      reg_info = reg_info_dummy = (register_info_type *) NULL;
        -: 5502:    }
        -: 5503:#endif /* REGEX_MALLOC */
        -: 5504:
        -: 5505:  /* The starting position is bogus.  */
    47846: 5506:  if (pos < 0 || pos > size1 + size2)
branch  0 taken 47846 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 47846
        -: 5507:    {
    #####: 5508:      FREE_VARIABLES ();
    #####: 5509:      return -1;
        -: 5510:    }
        -: 5511:    
        -: 5512:  /* Initialize subexpression text positions to -1 to mark ones that no
        -: 5513:     start_memory/stop_memory has been seen for. Also initialize the
        -: 5514:     register information struct.  */
    47902: 5515:  for (mcnt = 1; mcnt < num_regs; mcnt++)
branch  0 taken 56
branch  1 taken 47846 (fallthrough)
        -: 5516:    {
       56: 5517:      regstart[mcnt] = regend[mcnt] 
       56: 5518:        = old_regstart[mcnt] = old_regend[mcnt] = REG_UNSET_VALUE;
        -: 5519:        
       56: 5520:      REG_MATCH_NULL_STRING_P (reg_info[mcnt]) = MATCH_NULL_UNSET_VALUE;
       56: 5521:      IS_ACTIVE (reg_info[mcnt]) = 0;
       56: 5522:      MATCHED_SOMETHING (reg_info[mcnt]) = 0;
       56: 5523:      EVER_MATCHED_SOMETHING (reg_info[mcnt]) = 0;
        -: 5524:    }
        -: 5525:  
        -: 5526:  /* We move `string1' into `string2' if the latter's empty -- but not if
        -: 5527:     `string1' is null.  */
    47846: 5528:  if (size2 == 0 && string1 != NULL)
branch  0 taken 1344 (fallthrough)
branch  1 taken 46502
branch  2 taken 0 (fallthrough)
branch  3 taken 1344
        -: 5529:    {
    #####: 5530:      string2 = string1;
    #####: 5531:      size2 = size1;
    #####: 5532:      string1 = 0;
    #####: 5533:      size1 = 0;
        -: 5534:    }
    47846: 5535:  end1 = string1 + size1;
    47846: 5536:  end2 = string2 + size2;
        -: 5537:
        -: 5538:  /* Compute where to stop matching, within the two strings.  */
    47846: 5539:  if (stop <= size1)
branch  0 taken 1344 (fallthrough)
branch  1 taken 46502
        -: 5540:    {
     1344: 5541:      end_match_1 = string1 + stop;
     1344: 5542:      end_match_2 = string2;
        -: 5543:    }
        -: 5544:  else
        -: 5545:    {
    46502: 5546:      end_match_1 = end1;
    46502: 5547:      end_match_2 = string2 + stop - size1;
        -: 5548:    }
        -: 5549:
        -: 5550:  /* `p' scans through the pattern as `d' scans through the data. 
        -: 5551:     `dend' is the end of the input string that `d' points within.  `d'
        -: 5552:     is advanced into the following input string whenever necessary, but
        -: 5553:     this happens before fetching; therefore, at the beginning of the
        -: 5554:     loop, `d' can be pointing at the end of a string, but it cannot
        -: 5555:     equal `string2'.  */
   47846*: 5556:  if (size1 > 0 && pos <= size1)
branch  0 taken 0 (fallthrough)
branch  1 taken 47846
branch  2 never executed
branch  3 never executed
        -: 5557:    {
    #####: 5558:      d = string1 + pos;
    #####: 5559:      dend = end_match_1;
        -: 5560:    }
        -: 5561:  else
        -: 5562:    {
    47846: 5563:      d = string2 + pos - size1;
    47846: 5564:      dend = end_match_2;
        -: 5565:    }
        -: 5566:
        -: 5567:  DEBUG_PRINT1 ("The compiled pattern is: ");
        -: 5568:  DEBUG_PRINT_COMPILED_PATTERN (bufp, p, pend);
        -: 5569:  DEBUG_PRINT1 ("The string to match is: `");
        -: 5570:  DEBUG_PRINT_DOUBLE_STRING (d, string1, size1, string2, size2);
        -: 5571:  DEBUG_PRINT1 ("'\n");
        -: 5572:  
        -: 5573:  /* This loops over pattern commands.  It exits by returning from the
        -: 5574:     function if the match is complete, or it drops through if the match
        -: 5575:     fails at this starting point in the input data.  */
        -: 5576:  for (;;)
        -: 5577:    {
        -: 5578:      DEBUG_PRINT2 ("\n0x%x: ", p);
        -: 5579:
  1622976: 5580:      if (p == pend)
branch  0 taken 5950 (fallthrough)
branch  1 taken 1617026
        -: 5581:	{ /* End of pattern means we might have succeeded.  */
        -: 5582:          DEBUG_PRINT1 ("end of pattern ... ");
        -: 5583:          
        -: 5584:	  /* If we haven't matched the entire string, and we want the
        -: 5585:             longest match, try backtracking.  */
     5950: 5586:          if (d != end_match_2)
branch  0 taken 3224 (fallthrough)
branch  1 taken 2726
        -: 5587:	    {
        -: 5588:              DEBUG_PRINT1 ("backtracking.\n");
        -: 5589:              
     3224: 5590:              if (!FAIL_STACK_EMPTY ())
branch  0 taken 132 (fallthrough)
branch  1 taken 3092
        -: 5591:                { /* More failure points to try.  */
     132*: 5592:                  boolean same_str_p = (FIRST_STRING_P (match_end) 
branch  0 taken 0 (fallthrough)
branch  1 taken 132
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
      132: 5593:	        	                == MATCHING_IN_FIRST_STRING);
        -: 5594:
        -: 5595:                  /* If exceeds best match so far, save it.  */
      132: 5596:                  if (!best_regs_set
branch  0 taken 75 (fallthrough)
branch  1 taken 57
       75: 5597:                      || (same_str_p && d > match_end)
branch  0 taken 75 (fallthrough)
branch  1 taken 0
branch  2 taken 75 (fallthrough)
branch  3 taken 0
      75*: 5598:                      || (!same_str_p && !MATCHING_IN_FIRST_STRING))
branch  0 taken 0 (fallthrough)
branch  1 taken 75
branch  2 never executed
branch  3 never executed
        -: 5599:                    {
       57: 5600:                      best_regs_set = true;
       57: 5601:                      match_end = d;
        -: 5602:                      
        -: 5603:                      DEBUG_PRINT1 ("\nSAVING match as best so far.\n");
        -: 5604:                      
      57*: 5605:                      for (mcnt = 1; mcnt < num_regs; mcnt++)
branch  0 taken 0
branch  1 taken 57 (fallthrough)
        -: 5606:                        {
    #####: 5607:                          best_regstart[mcnt] = regstart[mcnt];
    #####: 5608:                          best_regend[mcnt] = regend[mcnt];
        -: 5609:                        }
        -: 5610:                    }
      132: 5611:                  goto fail;	       
        -: 5612:                }
        -: 5613:
        -: 5614:              /* If no failure points, don't restore garbage.  */
     3092: 5615:              else if (best_regs_set)   
branch  0 taken 6 (fallthrough)
branch  1 taken 3086
        -: 5616:                {
        6: 5617:  	        restore_best_regs:
        -: 5618:                  /* Restore best match.  It may happen that `dend ==
        -: 5619:                     end_match_1' while the restored d is in string2.
        -: 5620:                     For example, the pattern `x.*y.*z' against the
        -: 5621:                     strings `x-' and `y-z-', if the two strings are
        -: 5622:                     not consecutive in memory.  */
        -: 5623:                  DEBUG_PRINT1 ("Restoring best registers.\n");
        -: 5624:                  
       57: 5625:                  d = match_end;
       57: 5626:                  dend = ((d >= string1 && d <= end1)
branch  0 taken 0 (fallthrough)
branch  1 taken 57
     114*: 5627:		           ? end_match_1 : end_match_2);
branch  0 taken 57 (fallthrough)
branch  1 taken 0
        -: 5628:
      57*: 5629:		  for (mcnt = 1; mcnt < num_regs; mcnt++)
branch  0 taken 0
branch  1 taken 57 (fallthrough)
        -: 5630:		    {
    #####: 5631:		      regstart[mcnt] = best_regstart[mcnt];
    #####: 5632:		      regend[mcnt] = best_regend[mcnt];
        -: 5633:		    }
        -: 5634:                }
        -: 5635:            } /* d != end_match_2 */
        -: 5636:
        -: 5637:          DEBUG_PRINT1 ("Accepting match.\n");
        -: 5638:
        -: 5639:          /* If caller wants register contents data back, do it.  */
     5869: 5640:          if (regs && !bufp->no_sub)
branch  0 taken 3588 (fallthrough)
branch  1 taken 2281
branch  2 taken 3588 (fallthrough)
branch  3 taken 0
        -: 5641:	    {
        -: 5642:              /* Have the register data arrays been allocated?  */
     3588: 5643:              if (bufp->regs_allocated == REGS_UNALLOCATED)
branch  0 taken 204 (fallthrough)
branch  1 taken 3384
        -: 5644:                { /* No.  So allocate them with malloc.  We need one
        -: 5645:                     extra element beyond `num_regs' for the `-1' marker
        -: 5646:                     GNU code uses.  */
      204: 5647:                  regs->num_regs = MAX (RE_NREGS, num_regs + 1);
      204: 5648:                  regs->start = TALLOC (regs->num_regs, regoff_t);
      204: 5649:                  regs->end = TALLOC (regs->num_regs, regoff_t);
      204: 5650:                  if (regs->start == NULL || regs->end == NULL)
branch  0 taken 204 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 204
    #####: 5651:                    return -2;
      204: 5652:                  bufp->regs_allocated = REGS_REALLOCATE;
        -: 5653:                }
     3384: 5654:              else if (bufp->regs_allocated == REGS_REALLOCATE)
branch  0 taken 3384 (fallthrough)
branch  1 taken 0
        -: 5655:                { /* Yes.  If we need more elements than were already
        -: 5656:                     allocated, reallocate them.  If we need fewer, just
        -: 5657:                     leave it alone.  */
     3384: 5658:                  if (regs->num_regs < num_regs + 1)
branch  0 taken 0 (fallthrough)
branch  1 taken 3384
        -: 5659:                    {
    #####: 5660:                      regs->num_regs = num_regs + 1;
    #####: 5661:                      RETALLOC (regs->start, regs->num_regs, regoff_t);
    #####: 5662:                      RETALLOC (regs->end, regs->num_regs, regoff_t);
    #####: 5663:                      if (regs->start == NULL || regs->end == NULL)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 5664:                        return -2;
        -: 5665:                    }
        -: 5666:                }
        -: 5667:              else
        -: 5668:                assert (bufp->regs_allocated == REGS_FIXED);
        -: 5669:
        -: 5670:              /* Convert the pointer data in `regstart' and `regend' to
        -: 5671:                 indices.  Register zero has to be set differently,
        -: 5672:                 since we haven't kept track of any info for it.  */
     3588: 5673:              if (regs->num_regs > 0)
branch  0 taken 3588 (fallthrough)
branch  1 taken 0
        -: 5674:                {
     3588: 5675:                  regs->start[0] = pos;
    7176*: 5676:                  regs->end[0] = (MATCHING_IN_FIRST_STRING ? d - string1
branch  0 taken 0 (fallthrough)
branch  1 taken 3588
     3588: 5677:			          : d - string2 + size1);
        -: 5678:                }
        -: 5679:              
        -: 5680:              /* Go through the first `min (num_regs, regs->num_regs)'
        -: 5681:                 registers, since that is all we initialized.  */
     3600: 5682:	      for (mcnt = 1; mcnt < MIN (num_regs, regs->num_regs); mcnt++)
branch  0 taken 12
branch  1 taken 3588 (fallthrough)
        -: 5683:		{
       12: 5684:                  if (REG_UNSET (regstart[mcnt]) || REG_UNSET (regend[mcnt]))
branch  0 taken 12 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 12
    #####: 5685:                    regs->start[mcnt] = regs->end[mcnt] = -1;
        -: 5686:                  else
        -: 5687:                    {
      12*: 5688:		      regs->start[mcnt] = POINTER_TO_OFFSET (regstart[mcnt]);
branch  0 taken 0 (fallthrough)
branch  1 taken 12
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
      12*: 5689:                      regs->end[mcnt] = POINTER_TO_OFFSET (regend[mcnt]);
branch  0 taken 0 (fallthrough)
branch  1 taken 12
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 5690:                    }
        -: 5691:		}
        -: 5692:              
        -: 5693:              /* If the regs structure we return has more elements than
        -: 5694:                 were in the pattern, set the extra elements to -1.  If
        -: 5695:                 we (re)allocated the registers, this is the case,
        -: 5696:                 because we always allocate enough to have at least one
        -: 5697:                 -1 at the end.  */
   107628: 5698:              for (mcnt = num_regs; mcnt < regs->num_regs; mcnt++)
branch  0 taken 104040
branch  1 taken 3588 (fallthrough)
   104040: 5699:                regs->start[mcnt] = regs->end[mcnt] = -1;
        -: 5700:	    } /* regs && !bufp->no_sub */
        -: 5701:
     5869: 5702:          FREE_VARIABLES ();
        -: 5703:          DEBUG_PRINT4 ("%u failure points pushed, %u popped (%u remain).\n",
        -: 5704:                        nfailure_points_pushed, nfailure_points_popped,
        -: 5705:                        nfailure_points_pushed - nfailure_points_popped);
        -: 5706:          DEBUG_PRINT2 ("%u registers pushed.\n", num_regs_pushed);
        -: 5707:
    11738: 5708:          mcnt = d - pos - (MATCHING_IN_FIRST_STRING 
        -: 5709:			    ? string1 
    5869*: 5710:			    : string2 - size1);
branch  0 taken 5869 (fallthrough)
branch  1 taken 0
        -: 5711:
        -: 5712:          DEBUG_PRINT2 ("Returning %d from re_match_2.\n", mcnt);
        -: 5713:
     5869: 5714:          return mcnt;
        -: 5715:        }
        -: 5716:
        -: 5717:      /* Otherwise match next pattern command.  */
        -: 5718:#ifdef SWITCH_ENUM_BUG
        -: 5719:      switch ((int) ((re_opcode_t) *p++))
        -: 5720:#else
  1617026: 5721:      switch ((re_opcode_t) *p++)
branch  0 taken 144
branch  1 taken 394874
branch  2 taken 409489
branch  3 taken 2759
branch  4 taken 31
branch  5 taken 259
branch  6 taken 0
branch  7 taken 0
branch  8 taken 0
branch  9 taken 11418
branch 10 taken 6843
branch 11 taken 0
branch 12 taken 409489
branch 13 taken 116
branch 14 taken 13033
branch 15 taken 368205
branch 16 taken 0
branch 17 taken 0
branch 18 taken 0
branch 19 taken 144
branch 20 taken 78
branch 21 taken 144
branch 22 taken 0
branch 23 taken 0
branch 24 taken 0
branch 25 taken 0
branch 26 taken 0
branch 27 taken 0
branch 28 taken 0
        -: 5722:#endif
        -: 5723:	{
        -: 5724:        /* Ignore these.  Used to ignore the n of succeed_n's which
        -: 5725:           currently have n == 0.  */
      144: 5726:        case no_op:
        -: 5727:          DEBUG_PRINT1 ("EXECUTING no_op.\n");
      144: 5728:          break;
        -: 5729:
        -: 5730:
        -: 5731:        /* Match the next n pattern characters exactly.  The following
        -: 5732:           byte in the pattern defines n, and the n bytes after that
        -: 5733:           are the characters to match.  */
   394874: 5734:	case exactn:
   394874: 5735:	  mcnt = *p++;
        -: 5736:          DEBUG_PRINT2 ("EXECUTING exactn %d.\n", mcnt);
        -: 5737:
        -: 5738:          /* This is written out as an if-else so we don't waste time
        -: 5739:             testing `translate' inside the loop.  */
   394874: 5740:          if (translate)
branch  0 taken 0 (fallthrough)
branch  1 taken 394874
        -: 5741:	    {
        -: 5742:	      do
        -: 5743:		{
    #####: 5744:		  PREFETCH ();
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 5745:		  if (translate[(unsigned char) *d++] != (char) *p++)
branch  0 never executed
branch  1 never executed
    #####: 5746:                    goto fail;
        -: 5747:		}
    #####: 5748:	      while (--mcnt);
branch  0 never executed
branch  1 never executed
        -: 5749:	    }
        -: 5750:	  else
        -: 5751:	    {
        -: 5752:	      do
        -: 5753:		{
  407084*: 5754:		  PREFETCH ();
branch  0 taken 28157 (fallthrough)
branch  1 taken 0
branch  2 taken 28157
branch  3 taken 378927 (fallthrough)
   378927: 5755:		  if (*d++ != (char) *p++) goto fail;
branch  0 taken 359382 (fallthrough)
branch  1 taken 19545
        -: 5756:		}
    19545: 5757:	      while (--mcnt);
branch  0 taken 12210
branch  1 taken 7335 (fallthrough)
        -: 5758:	    }
    7335*: 5759:	  SET_REGS_MATCHED ();
branch  0 taken 0
branch  1 taken 7335 (fallthrough)
     7335: 5760:          break;
        -: 5761:
        -: 5762:
        -: 5763:        /* Match any character except possibly a newline or a null.  */
   409489: 5764:	case anychar:
        -: 5765:          DEBUG_PRINT1 ("EXECUTING anychar.\n");
        -: 5766:
  409489*: 5767:          PREFETCH ();
branch  0 taken 28135 (fallthrough)
branch  1 taken 0
branch  2 taken 28135
branch  3 taken 381354 (fallthrough)
        -: 5768:
  762708*: 5769:          if ((!(bufp->syntax & RE_DOT_NEWLINE) && TRANSLATE (*d) == '\n')
branch  0 taken 0 (fallthrough)
branch  1 taken 381354
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 taken 0 (fallthrough)
branch  9 taken 381354
  762708*: 5770:              || (bufp->syntax & RE_DOT_NOT_NULL && TRANSLATE (*d) == '\000'))
branch  0 taken 381354 (fallthrough)
branch  1 taken 0
branch  2 never executed
branch  3 never executed
branch  4 taken 0 (fallthrough)
branch  5 taken 381354
    #####: 5771:	    goto fail;
        -: 5772:
   381732: 5773:          SET_REGS_MATCHED ();
branch  0 taken 378
branch  1 taken 381354 (fallthrough)
        -: 5774:          DEBUG_PRINT2 ("  Matched `%d'.\n", *d);
   381354: 5775:          d++;
   381354: 5776:	  break;
        -: 5777:
        -: 5778:
     2759: 5779:	case charset:
        -: 5780:	case charset_not:
        -: 5781:	  {
        -: 5782:	    register unsigned char c;
     2759: 5783:	    boolean not = (re_opcode_t) *(p - 1) == charset_not;
        -: 5784:
        -: 5785:            DEBUG_PRINT2 ("EXECUTING charset%s.\n", not ? "_not" : "");
        -: 5786:
    2759*: 5787:	    PREFETCH ();
branch  0 taken 127 (fallthrough)
branch  1 taken 0
branch  2 taken 127
branch  3 taken 2632 (fallthrough)
    2632*: 5788:	    c = TRANSLATE (*d); /* The character to match.  */
branch  0 taken 0 (fallthrough)
branch  1 taken 2632
        -: 5789:
        -: 5790:            /* Cast to `unsigned' instead of `unsigned char' in case the
        -: 5791:               bit list is a full 32 bytes long.  */
     2632: 5792:	    if (c < (unsigned) (*p * BYTEWIDTH)
branch  0 taken 2566 (fallthrough)
branch  1 taken 66
     2566: 5793:		&& p[1 + c / BYTEWIDTH] & (1 << (c % BYTEWIDTH)))
branch  0 taken 835 (fallthrough)
branch  1 taken 1731
      835: 5794:	      not = !not;
        -: 5795:
     2632: 5796:	    p += 1 + *p;
        -: 5797:
     2632: 5798:	    if (!not) goto fail;
branch  0 taken 974 (fallthrough)
branch  1 taken 1658
        -: 5799:            
    1658*: 5800:	    SET_REGS_MATCHED ();
branch  0 taken 0
branch  1 taken 1658 (fallthrough)
     1658: 5801:            d++;
     1658: 5802:	    break;
        -: 5803:	  }
        -: 5804:
        -: 5805:
        -: 5806:        /* The beginning of a group is represented by start_memory.
        -: 5807:           The arguments are the register number in the next byte, and the
        -: 5808:           number of groups inner to this one in the next.  The text
        -: 5809:           matched within the group is recorded (in the internal
        -: 5810:           registers data structure) under the register number.  */
       31: 5811:        case start_memory:
        -: 5812:	  DEBUG_PRINT3 ("EXECUTING start_memory %d (%d):\n", *p, p[1]);
        -: 5813:
        -: 5814:          /* Find out if this group can match the empty string.  */
       31: 5815:	  p1 = p;		/* To send to group_match_null_string_p.  */
        -: 5816:          
       31: 5817:          if (REG_MATCH_NULL_STRING_P (reg_info[*p]) == MATCH_NULL_UNSET_VALUE)
branch  0 taken 30 (fallthrough)
branch  1 taken 1
       30: 5818:            REG_MATCH_NULL_STRING_P (reg_info[*p]) 
       30: 5819:              = group_match_null_string_p (&p1, pend, reg_info);
call    0 returned 30
        -: 5820:
        -: 5821:          /* Save the position in the string where we were the last time
        -: 5822:             we were at this open-group operator in case the group is
        -: 5823:             operated upon by a repetition operator, e.g., with `(a*)*b'
        -: 5824:             against `ab'; then we want to ignore where we are now in
        -: 5825:             the string in case this attempt to match fails.  */
       62: 5826:          old_regstart[*p] = REG_MATCH_NULL_STRING_P (reg_info[*p])
    #####: 5827:                             ? REG_UNSET (regstart[*p]) ? d : regstart[*p]
branch  0 never executed
branch  1 never executed
      31*: 5828:                             : regstart[*p];
branch  0 taken 0 (fallthrough)
branch  1 taken 31
        -: 5829:	  DEBUG_PRINT2 ("  old_regstart: %d\n", 
        -: 5830:			 POINTER_TO_OFFSET (old_regstart[*p]));
        -: 5831:
       31: 5832:          regstart[*p] = d;
        -: 5833:	  DEBUG_PRINT2 ("  regstart: %d\n", POINTER_TO_OFFSET (regstart[*p]));
        -: 5834:
       31: 5835:          IS_ACTIVE (reg_info[*p]) = 1;
       31: 5836:          MATCHED_SOMETHING (reg_info[*p]) = 0;
        -: 5837:          
        -: 5838:          /* This is the new highest active register.  */
       31: 5839:          highest_active_reg = *p;
        -: 5840:          
        -: 5841:          /* If nothing was active before, this is the new lowest active
        -: 5842:             register.  */
       31: 5843:          if (lowest_active_reg == NO_LOWEST_ACTIVE_REG)
branch  0 taken 31 (fallthrough)
branch  1 taken 0
       31: 5844:            lowest_active_reg = *p;
        -: 5845:
        -: 5846:          /* Move past the register number and inner group count.  */
       31: 5847:          p += 2;
       31: 5848:          break;
        -: 5849:
        -: 5850:
        -: 5851:        /* The stop_memory opcode represents the end of a group.  Its
        -: 5852:           arguments are the same as start_memory's: the register
        -: 5853:           number, and the number of inner groups.  */
      259: 5854:	case stop_memory:
        -: 5855:	  DEBUG_PRINT3 ("EXECUTING stop_memory %d (%d):\n", *p, p[1]);
        -: 5856:             
        -: 5857:          /* We need to save the string position the last time we were at
        -: 5858:             this close-group operator in case the group is operated
        -: 5859:             upon by a repetition operator, e.g., with `((a*)*(b*)*)*'
        -: 5860:             against `aba'; then we want to ignore where we are now in
        -: 5861:             the string in case this attempt to match fails.  */
      518: 5862:          old_regend[*p] = REG_MATCH_NULL_STRING_P (reg_info[*p])
    #####: 5863:                           ? REG_UNSET (regend[*p]) ? d : regend[*p]
branch  0 never executed
branch  1 never executed
     259*: 5864:			   : regend[*p];
branch  0 taken 0 (fallthrough)
branch  1 taken 259
        -: 5865:	  DEBUG_PRINT2 ("      old_regend: %d\n", 
        -: 5866:			 POINTER_TO_OFFSET (old_regend[*p]));
        -: 5867:
      259: 5868:          regend[*p] = d;
        -: 5869:	  DEBUG_PRINT2 ("      regend: %d\n", POINTER_TO_OFFSET (regend[*p]));
        -: 5870:
        -: 5871:          /* This register isn't active anymore.  */
      259: 5872:          IS_ACTIVE (reg_info[*p]) = 0;
        -: 5873:          
        -: 5874:          /* If this was the only register active, nothing is active
        -: 5875:             anymore.  */
      259: 5876:          if (lowest_active_reg == highest_active_reg)
branch  0 taken 259 (fallthrough)
branch  1 taken 0
        -: 5877:            {
      259: 5878:              lowest_active_reg = NO_LOWEST_ACTIVE_REG;
      259: 5879:              highest_active_reg = NO_HIGHEST_ACTIVE_REG;
        -: 5880:            }
        -: 5881:          else
        -: 5882:            { /* We must scan for the new highest active register, since
        -: 5883:                 it isn't necessarily one less than now: consider
        -: 5884:                 (a(b)c(d(e)f)g).  When group 3 ends, after the f), the
        -: 5885:                 new highest active register is 1.  */
    #####: 5886:              unsigned char r = *p - 1;
    #####: 5887:              while (r > 0 && !IS_ACTIVE (reg_info[r]))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 5888:                r--;
        -: 5889:              
        -: 5890:              /* If we end up at register zero, that means that we saved
        -: 5891:                 the registers as the result of an `on_failure_jump', not
        -: 5892:                 a `start_memory', and we jumped to past the innermost
        -: 5893:                 `stop_memory'.  For example, in ((.)*) we save
        -: 5894:                 registers 1 and 2 as a result of the *, but when we pop
        -: 5895:                 back to the second ), we are at the stop_memory 1.
        -: 5896:                 Thus, nothing is active.  */
    #####: 5897:	      if (r == 0)
branch  0 never executed
branch  1 never executed
        -: 5898:                {
    #####: 5899:                  lowest_active_reg = NO_LOWEST_ACTIVE_REG;
    #####: 5900:                  highest_active_reg = NO_HIGHEST_ACTIVE_REG;
        -: 5901:                }
        -: 5902:              else
    #####: 5903:                highest_active_reg = r;
        -: 5904:            }
        -: 5905:          
        -: 5906:          /* If just failed to match something this time around with a
        -: 5907:             group that's operated on by a repetition operator, try to
        -: 5908:             force exit from the ``loop'', and restore the register
        -: 5909:             information for this group that we had before trying this
        -: 5910:             last match.  */
      259: 5911:          if ((!MATCHED_SOMETHING (reg_info[*p])
branch  0 taken 240 (fallthrough)
branch  1 taken 19
      240: 5912:               || (re_opcode_t) p[-3] == start_memory)
branch  0 taken 0 (fallthrough)
branch  1 taken 240
       19: 5913:	      && (p + 2) < pend)              
branch  0 taken 19 (fallthrough)
branch  1 taken 0
        -: 5914:            {
       19: 5915:              boolean is_a_jump_n = false;
        -: 5916:              
       19: 5917:              p1 = p + 2;
       19: 5918:              mcnt = 0;
       19: 5919:              switch ((re_opcode_t) *p1++)
branch  0 taken 0
branch  1 taken 0
branch  2 taken 19
        -: 5920:                {
    #####: 5921:                  case jump_n:
    #####: 5922:		    is_a_jump_n = true;
    #####: 5923:                  case pop_failure_jump:
        -: 5924:		  case maybe_pop_jump:
        -: 5925:		  case jump:
        -: 5926:		  case dummy_failure_jump:
    #####: 5927:                    EXTRACT_NUMBER_AND_INCR (mcnt, p1);
    #####: 5928:		    if (is_a_jump_n)
branch  0 never executed
branch  1 never executed
    #####: 5929:		      p1 += 2;
    #####: 5930:                    break;
        -: 5931:                  
       19: 5932:                  default:
        -: 5933:                    /* do nothing */ ;
        -: 5934:                }
       19: 5935:	      p1 += mcnt;
        -: 5936:        
        -: 5937:              /* If the next operation is a jump backwards in the pattern
        -: 5938:	         to an on_failure_jump right before the start_memory
        -: 5939:                 corresponding to this stop_memory, exit from the loop
        -: 5940:                 by forcing a failure after pushing on the stack the
        -: 5941:                 on_failure_jump's jump in the pattern, and d.  */
      19*: 5942:              if (mcnt < 0 && (re_opcode_t) *p1 == on_failure_jump
branch  0 taken 0 (fallthrough)
branch  1 taken 19
branch  2 never executed
branch  3 never executed
    #####: 5943:                  && (re_opcode_t) p1[3] == start_memory && p1[4] == *p)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 5944:		{
        -: 5945:                  /* If this group ever matched anything, then restore
        -: 5946:                     what its registers were before trying this last
        -: 5947:                     failed match, e.g., with `(a*)*b' against `ab' for
        -: 5948:                     regstart[1], and, e.g., with `((a*)*(b*)*)*'
        -: 5949:                     against `aba' for regend[3].
        -: 5950:                     
        -: 5951:                     Also restore the registers for inner groups for,
        -: 5952:                     e.g., `((a*)(b*))*' against `aba' (register 3 would
        -: 5953:                     otherwise get trashed).  */
        -: 5954:                     
    #####: 5955:                  if (EVER_MATCHED_SOMETHING (reg_info[*p]))
branch  0 never executed
branch  1 never executed
        -: 5956:		    {
        -: 5957:		      unsigned r; 
        -: 5958:        
    #####: 5959:                      EVER_MATCHED_SOMETHING (reg_info[*p]) = 0;
        -: 5960:                      
        -: 5961:		      /* Restore this and inner groups' (if any) registers.  */
    #####: 5962:                      for (r = *p; r < *p + *(p + 1); r++)
branch  0 never executed
branch  1 never executed
        -: 5963:                        {
    #####: 5964:                          regstart[r] = old_regstart[r];
        -: 5965:
        -: 5966:                          /* xx why this test?  */
    #####: 5967:                          if ((int) old_regend[r] >= (int) regstart[r])
branch  0 never executed
branch  1 never executed
    #####: 5968:                            regend[r] = old_regend[r];
        -: 5969:                        }     
        -: 5970:                    }
    #####: 5971:		  p1++;
    #####: 5972:                  EXTRACT_NUMBER_AND_INCR (mcnt, p1);
    #####: 5973:                  PUSH_FAILURE_POINT (p1 + mcnt, d, -2);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
        -: 5974:
    #####: 5975:                  goto fail;
        -: 5976:                }
        -: 5977:            }
        -: 5978:          
        -: 5979:          /* Move past the register number and the inner group count.  */
      259: 5980:          p += 2;
      259: 5981:          break;
        -: 5982:
        -: 5983:
        -: 5984:	/* \<digit> has been turned into a `duplicate' command which is
        -: 5985:           followed by the numeric value of <digit> as the register number.  */
    #####: 5986:        case duplicate:
        -: 5987:	  {
        -: 5988:	    register const char *d2, *dend2;
    #####: 5989:	    int regno = *p++;   /* Get which register to match against.  */
        -: 5990:	    DEBUG_PRINT2 ("EXECUTING duplicate %d.\n", regno);
        -: 5991:
        -: 5992:	    /* Can't back reference a group which we've never matched.  */
    #####: 5993:            if (REG_UNSET (regstart[regno]) || REG_UNSET (regend[regno]))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 5994:              goto fail;
        -: 5995:              
        -: 5996:            /* Where in input to try to start matching.  */
    #####: 5997:            d2 = regstart[regno];
        -: 5998:            
        -: 5999:            /* Where to stop matching; if both the place to start and
        -: 6000:               the place to stop matching are in the same string, then
        -: 6001:               set to the place to stop, otherwise, for now have to use
        -: 6002:               the end of the first string.  */
        -: 6003:
    #####: 6004:            dend2 = ((FIRST_STRING_P (regstart[regno]) 
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 6005:		      == FIRST_STRING_P (regend[regno]))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 6006:		     ? regend[regno] : end_match_1);
branch  0 never executed
branch  1 never executed
        -: 6007:	    for (;;)
        -: 6008:	      {
        -: 6009:		/* If necessary, advance to next segment in register
        -: 6010:                   contents.  */
    #####: 6011:		while (d2 == dend2)
branch  0 never executed
branch  1 never executed
        -: 6012:		  {
    #####: 6013:		    if (dend2 == end_match_2) break;
branch  0 never executed
branch  1 never executed
    #####: 6014:		    if (dend2 == regend[regno]) break;
branch  0 never executed
branch  1 never executed
        -: 6015:
        -: 6016:                    /* End of string1 => advance to string2. */
    #####: 6017:                    d2 = string2;
    #####: 6018:                    dend2 = regend[regno];
        -: 6019:		  }
        -: 6020:		/* At end of register contents => success */
    #####: 6021:		if (d2 == dend2) break;
branch  0 never executed
branch  1 never executed
        -: 6022:
        -: 6023:		/* If necessary, advance to next segment in data.  */
    #####: 6024:		PREFETCH ();
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 6025:
        -: 6026:		/* How many characters left in this segment to match.  */
    #####: 6027:		mcnt = dend - d;
        -: 6028:                
        -: 6029:		/* Want how many consecutive characters we can match in
        -: 6030:                   one shot, so, if necessary, adjust the count.  */
    #####: 6031:                if (mcnt > dend2 - d2)
branch  0 never executed
branch  1 never executed
    #####: 6032:		  mcnt = dend2 - d2;
        -: 6033:                  
        -: 6034:		/* Compare that many; failure if mismatch, else move
        -: 6035:                   past them.  */
    #####: 6036:		if (translate 
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 6037:                    ? bcmp_translate (d, d2, mcnt, translate) 
call    0 never executed
    #####: 6038:                    : bcmp (d, d2, mcnt))
    #####: 6039:		  goto fail;
    #####: 6040:		d += mcnt, d2 += mcnt;
        -: 6041:	      }
        -: 6042:	  }
    #####: 6043:	  break;
        -: 6044:
        -: 6045:
        -: 6046:        /* begline matches the empty string at the beginning of the string
        -: 6047:           (unless `not_bol' is set in `bufp'), and, if
        -: 6048:           `newline_anchor' is set, after newlines.  */
    #####: 6049:	case begline:
        -: 6050:          DEBUG_PRINT1 ("EXECUTING begline.\n");
        -: 6051:          
    #####: 6052:          if (AT_STRINGS_BEG (d))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 6053:            {
    #####: 6054:              if (!bufp->not_bol) break;
branch  0 never executed
branch  1 never executed
        -: 6055:            }
    #####: 6056:          else if (d[-1] == '\n' && bufp->newline_anchor)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 6057:            {
    #####: 6058:              break;
        -: 6059:            }
        -: 6060:          /* In all other cases, we fail.  */
    #####: 6061:          goto fail;
        -: 6062:
        -: 6063:
        -: 6064:        /* endline is the dual of begline.  */
    #####: 6065:	case endline:
        -: 6066:          DEBUG_PRINT1 ("EXECUTING endline.\n");
        -: 6067:
    #####: 6068:          if (AT_STRINGS_END (d))
branch  0 never executed
branch  1 never executed
        -: 6069:            {
    #####: 6070:              if (!bufp->not_eol) break;
branch  0 never executed
branch  1 never executed
        -: 6071:            }
        -: 6072:          
        -: 6073:          /* We have to ``prefetch'' the next character.  */
    #####: 6074:          else if ((d == end1 ? *string2 : *d) == '\n'
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 6075:                   && bufp->newline_anchor)
branch  0 never executed
branch  1 never executed
        -: 6076:            {
    #####: 6077:              break;
        -: 6078:            }
    #####: 6079:          goto fail;
        -: 6080:
        -: 6081:
        -: 6082:	/* Match at the very beginning of the data.  */
    11418: 6083:        case begbuf:
        -: 6084:          DEBUG_PRINT1 ("EXECUTING begbuf.\n");
   11418*: 6085:          if (AT_STRINGS_BEG (d))
branch  0 taken 0 (fallthrough)
branch  1 taken 11418
branch  2 taken 6521 (fallthrough)
branch  3 taken 4897
branch  4 taken 6521 (fallthrough)
branch  5 taken 0
        -: 6086:            break;
     6521: 6087:          goto fail;
        -: 6088:
        -: 6089:
        -: 6090:	/* Match at the very end of the data.  */
     6843: 6091:        case endbuf:
        -: 6092:          DEBUG_PRINT1 ("EXECUTING endbuf.\n");
     6843: 6093:	  if (AT_STRINGS_END (d))
branch  0 taken 1161 (fallthrough)
branch  1 taken 5682
     1161: 6094:	    break;
     5682: 6095:          goto fail;
        -: 6096:
        -: 6097:
        -: 6098:        /* on_failure_keep_string_jump is used to optimize `.*\n'.  It
        -: 6099:           pushes NULL as the value for the string on the stack.  Then
        -: 6100:           `pop_failure_point' will keep the current value for the
        -: 6101:           string, instead of restoring it.  To see why, consider
        -: 6102:           matching `foo\nbar' against `.*\n'.  The .* matches the foo;
        -: 6103:           then the . fails against the \n.  But the next thing we want
        -: 6104:           to do is match the \n against the \n; if we restored the
        -: 6105:           string value, we would be back at the foo.
        -: 6106:           
        -: 6107:           Because this is used only in specific cases, we don't need to
        -: 6108:           check all the things that `on_failure_jump' does, to make
        -: 6109:           sure the right things get saved on the stack.  Hence we don't
        -: 6110:           share its code.  The only reason to push anything on the
        -: 6111:           stack at all is that otherwise we would have to change
        -: 6112:           `anychar's code to do something besides goto fail in this
        -: 6113:           case; that seems worse than this.  */
    #####: 6114:        case on_failure_keep_string_jump:
        -: 6115:          DEBUG_PRINT1 ("EXECUTING on_failure_keep_string_jump");
        -: 6116:          
    #####: 6117:          EXTRACT_NUMBER_AND_INCR (mcnt, p);
        -: 6118:          DEBUG_PRINT3 (" %d (to 0x%x):\n", mcnt, p + mcnt);
        -: 6119:
    #####: 6120:          PUSH_FAILURE_POINT (p + mcnt, NULL, -2);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####: 6121:          break;
        -: 6122:
        -: 6123:
        -: 6124:	/* Uses of on_failure_jump:
        -: 6125:        
        -: 6126:           Each alternative starts with an on_failure_jump that points
        -: 6127:           to the beginning of the next alternative.  Each alternative
        -: 6128:           except the last ends with a jump that in effect jumps past
        -: 6129:           the rest of the alternatives.  (They really jump to the
        -: 6130:           ending jump of the following alternative, because tensioning
        -: 6131:           these jumps is a hassle.)
        -: 6132:
        -: 6133:           Repeats start with an on_failure_jump that points past both
        -: 6134:           the repetition text and either the following jump or
        -: 6135:           pop_failure_jump back to this on_failure_jump.  */
        -: 6136:	case on_failure_jump:
   409561: 6137:        on_failure:
        -: 6138:          DEBUG_PRINT1 ("EXECUTING on_failure_jump");
        -: 6139:
   409561: 6140:          EXTRACT_NUMBER_AND_INCR (mcnt, p);
        -: 6141:          DEBUG_PRINT3 (" %d (to 0x%x)", mcnt, p + mcnt);
        -: 6142:
        -: 6143:          /* If this on_failure_jump comes right before a group (i.e.,
        -: 6144:             the original * applied to a group), save the information
        -: 6145:             for that group and all inner ones, so that if we fail back
        -: 6146:             to this point, the group's information will be correct.
        -: 6147:             For example, in \(a*\)*\1, we need the preceding group,
        -: 6148:             and in \(\(a*\)b*\)\2, we need the inner group.  */
        -: 6149:
        -: 6150:          /* We can't use `p' to check ahead because we push
        -: 6151:             a failure point to `p + mcnt' after we do this.  */
   409561: 6152:          p1 = p;
        -: 6153:
        -: 6154:          /* We need to skip no_op's before we look for the
        -: 6155:             start_memory in case this on_failure_jump is happening as
        -: 6156:             the result of a completed succeed_n, as in \(a\)\{1,3\}b\1
        -: 6157:             against aba.  */
   409705: 6158:          while (p1 < pend && (re_opcode_t) *p1 == no_op)
branch  0 taken 409705 (fallthrough)
branch  1 taken 0
branch  2 taken 144
branch  3 taken 409561 (fallthrough)
      144: 6159:            p1++;
        -: 6160:
   409561: 6161:          if (p1 < pend && (re_opcode_t) *p1 == start_memory)
branch  0 taken 409561 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 409561
        -: 6162:            {
        -: 6163:              /* We have a new highest active register now.  This will
        -: 6164:                 get reset at the start_memory we are about to get to,
        -: 6165:                 but we will have saved all the registers relevant to
        -: 6166:                 this repetition op, as described above.  */
    #####: 6167:              highest_active_reg = *(p1 + 1) + *(p1 + 2);
    #####: 6168:              if (lowest_active_reg == NO_LOWEST_ACTIVE_REG)
branch  0 never executed
branch  1 never executed
    #####: 6169:                lowest_active_reg = *(p1 + 1);
        -: 6170:            }
        -: 6171:
        -: 6172:          DEBUG_PRINT1 (":\n");
  507199*: 6173:          PUSH_FAILURE_POINT (p + mcnt, d, -2);
branch  0 taken 97229 (fallthrough)
branch  1 taken 0
branch  2 taken 97229 (fallthrough)
branch  3 taken 0
branch  4 taken 0 (fallthrough)
branch  5 taken 97229
branch  6 taken 97229
branch  7 taken 409561 (fallthrough)
branch  8 taken 409
branch  9 taken 409561 (fallthrough)
   409561: 6174:          break;
        -: 6175:
        -: 6176:
        -: 6177:        /* A smart repeat ends with `maybe_pop_jump'.
        -: 6178:	   We change it to either `pop_failure_jump' or `jump'.  */
      116: 6179:        case maybe_pop_jump:
      116: 6180:          EXTRACT_NUMBER_AND_INCR (mcnt, p);
        -: 6181:          DEBUG_PRINT2 ("EXECUTING maybe_pop_jump %d.\n", mcnt);
        -: 6182:          {
      116: 6183:	    register unsigned char *p2 = p;
        -: 6184:
        -: 6185:            /* Compare the beginning of the repeat with what in the
        -: 6186:               pattern follows its end. If we can establish that there
        -: 6187:               is nothing that they would both match, i.e., that we
        -: 6188:               would have to backtrack because of (as in, e.g., `a*a')
        -: 6189:               then we can change to pop_failure_jump, because we'll
        -: 6190:               never have to backtrack.
        -: 6191:               
        -: 6192:               This is not true in the case of alternatives: in
        -: 6193:               `(a|ab)*' we do need to backtrack to the `ab' alternative
        -: 6194:               (e.g., if the string was `ab').  But instead of trying to
        -: 6195:               detect that here, the alternative has put on a dummy
        -: 6196:               failure point which is what we will end up popping.  */
        -: 6197:
        -: 6198:	    /* Skip over open/close-group commands.  */
      116: 6199:	    while (p2 + 2 < pend
      127: 6200:		   && ((re_opcode_t) *p2 == stop_memory
branch  0 taken 65 (fallthrough)
branch  1 taken 62
branch  2 taken 11
branch  3 taken 54 (fallthrough)
       54: 6201:		       || (re_opcode_t) *p2 == start_memory))
branch  0 taken 0
branch  1 taken 54 (fallthrough)
       11: 6202:	      p2 += 3;			/* Skip over args, too.  */
        -: 6203:
        -: 6204:            /* If we're at the end of the pattern, we can change.  */
      116: 6205:            if (p2 == pend)
branch  0 taken 61 (fallthrough)
branch  1 taken 55
        -: 6206:	      {
        -: 6207:		/* Consider what happens when matching ":\(.*\)"
        -: 6208:		   against ":/".  I don't really understand this code
        -: 6209:		   yet.  */
       61: 6210:  	        p[-3] = (unsigned char) pop_failure_jump;
        -: 6211:                DEBUG_PRINT1
        -: 6212:                  ("  End of pattern: change to `pop_failure_jump'.\n");
        -: 6213:              }
        -: 6214:
       55: 6215:            else if ((re_opcode_t) *p2 == exactn
branch  0 taken 1 (fallthrough)
branch  1 taken 54
        1: 6216:		     || (bufp->newline_anchor && (re_opcode_t) *p2 == endline))
branch  0 taken 1 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 1
        -: 6217:	      {
      54*: 6218:		register unsigned char c
       54: 6219:                  = *p2 == (unsigned char) endline ? '\n' : p2[2];
branch  0 taken 54 (fallthrough)
branch  1 taken 0
       54: 6220:		p1 = p + mcnt;
        -: 6221:
        -: 6222:                /* p1[0] ... p1[2] are the `on_failure_jump' corresponding
        -: 6223:                   to the `maybe_finalize_jump' of this case.  Examine what 
        -: 6224:                   follows.  */
      54*: 6225:                if ((re_opcode_t) p1[3] == exactn && p1[5] != c)
branch  0 taken 0 (fallthrough)
branch  1 taken 54
branch  2 never executed
branch  3 never executed
        -: 6226:                  {
    #####: 6227:  		    p[-3] = (unsigned char) pop_failure_jump;
        -: 6228:                    DEBUG_PRINT3 ("  %c != %c => pop_failure_jump.\n",
        -: 6229:                                  c, p1[5]);
        -: 6230:                  }
        -: 6231:                  
       54: 6232:		else if ((re_opcode_t) p1[3] == charset
branch  0 taken 54 (fallthrough)
branch  1 taken 0
       54: 6233:			 || (re_opcode_t) p1[3] == charset_not)
branch  0 taken 0 (fallthrough)
branch  1 taken 54
        -: 6234:		  {
    #####: 6235:		    int not = (re_opcode_t) p1[3] == charset_not;
        -: 6236:                    
    #####: 6237:		    if (c < (unsigned char) (p1[4] * BYTEWIDTH)
branch  0 never executed
branch  1 never executed
    #####: 6238:			&& p1[5 + c / BYTEWIDTH] & (1 << (c % BYTEWIDTH)))
branch  0 never executed
branch  1 never executed
    #####: 6239:		      not = !not;
        -: 6240:
        -: 6241:                    /* `not' is equal to 1 if c would match, which means
        -: 6242:                        that we can't change to pop_failure_jump.  */
    #####: 6243:		    if (!not)
branch  0 never executed
branch  1 never executed
        -: 6244:                      {
    #####: 6245:  		        p[-3] = (unsigned char) pop_failure_jump;
        -: 6246:                        DEBUG_PRINT1 ("  No match => pop_failure_jump.\n");
        -: 6247:                      }
        -: 6248:		  }
        -: 6249:	      }
        -: 6250:	  }
      116: 6251:	  p -= 2;		/* Point at relative address again.  */
      116: 6252:	  if ((re_opcode_t) p[-1] != pop_failure_jump)
branch  0 taken 55 (fallthrough)
branch  1 taken 61
        -: 6253:	    {
       55: 6254:	      p[-1] = (unsigned char) jump;
        -: 6255:              DEBUG_PRINT1 ("  Match => jump.\n");
       55: 6256:	      goto unconditional_jump;
        -: 6257:	    }
        -: 6258:        /* Note fall through.  */
        -: 6259:
        -: 6260:
        -: 6261:	/* The end of a simple repeat has a pop_failure_jump back to
        -: 6262:           its matching on_failure_jump, where the latter will push a
        -: 6263:           failure point.  The pop_failure_jump takes off failure
        -: 6264:           points put on by this pop_failure_jump's matching
        -: 6265:           on_failure_jump; we got through the pattern to here from the
        -: 6266:           matching on_failure_jump, so didn't fail.  */
        -: 6267:        case pop_failure_jump:
        -: 6268:          {
        -: 6269:            /* We need to pass separate storage for the lowest and
        -: 6270:               highest registers, even though we don't care about the
        -: 6271:               actual values.  Otherwise, we will restore only one
        -: 6272:               register from the stack, since lowest will == highest in
        -: 6273:               `pop_failure_point'.  */
        -: 6274:            unsigned dummy_low_reg, dummy_high_reg;
        -: 6275:            unsigned char *pdummy;
        -: 6276:            const char *sdummy;
        -: 6277:
        -: 6278:            DEBUG_PRINT1 ("EXECUTING pop_failure_jump.\n");
   13094*: 6279:            POP_FAILURE_POINT (sdummy, pdummy,
branch  0 taken 13094 (fallthrough)
branch  1 taken 0
branch  2 taken 0
branch  3 taken 13094 (fallthrough)
        -: 6280:                               dummy_low_reg, dummy_high_reg,
        -: 6281:                               reg_dummy, reg_dummy, reg_info_dummy);
        -: 6282:          }
        -: 6283:          /* Note fall through.  */
        -: 6284:
        -: 6285:          
        -: 6286:        /* Unconditionally jump (without popping any failure points).  */
        -: 6287:        case jump:
    13094: 6288:	unconditional_jump:
   381426: 6289:	  EXTRACT_NUMBER_AND_INCR (mcnt, p);	/* Get the amount to jump.  */
        -: 6290:          DEBUG_PRINT2 ("EXECUTING jump %d ", mcnt);
   381426: 6291:	  p += mcnt;				/* Do the jump.  */
        -: 6292:          DEBUG_PRINT2 ("(to 0x%x).\n", p);
   381426: 6293:	  break;
        -: 6294:
        -: 6295:	
        -: 6296:        /* We need this opcode so we can detect where alternatives end
        -: 6297:           in `group_match_null_string_p' et al.  */
    #####: 6298:        case jump_past_alt:
        -: 6299:          DEBUG_PRINT1 ("EXECUTING jump_past_alt.\n");
    #####: 6300:          goto unconditional_jump;
        -: 6301:
        -: 6302:
        -: 6303:        /* Normally, the on_failure_jump pushes a failure point, which
        -: 6304:           then gets popped at pop_failure_jump.  We will end up at
        -: 6305:           pop_failure_jump, also, and with a pattern of, say, `a+', we
        -: 6306:           are skipping over the on_failure_jump, so we have to push
        -: 6307:           something meaningless for pop_failure_jump to pop.  */
    #####: 6308:        case dummy_failure_jump:
        -: 6309:          DEBUG_PRINT1 ("EXECUTING dummy_failure_jump.\n");
        -: 6310:          /* It doesn't matter what we push for the string here.  What
        -: 6311:             the code at `fail' tests is the value for the pattern.  */
    #####: 6312:          PUSH_FAILURE_POINT (0, 0, -2);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####: 6313:          goto unconditional_jump;
        -: 6314:
        -: 6315:
        -: 6316:        /* At the end of an alternative, we need to push a dummy failure
        -: 6317:           point in case we are followed by a `pop_failure_jump', because
        -: 6318:           we don't want the failure point for the alternative to be
        -: 6319:           popped.  For example, matching `(a|ab)*' against `aab'
        -: 6320:           requires that we match the `ab' alternative.  */
    #####: 6321:        case push_dummy_failure:
        -: 6322:          DEBUG_PRINT1 ("EXECUTING push_dummy_failure.\n");
        -: 6323:          /* See comments just above at `dummy_failure_jump' about the
        -: 6324:             two zeroes.  */
    #####: 6325:          PUSH_FAILURE_POINT (0, 0, -2);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####: 6326:          break;
        -: 6327:
        -: 6328:        /* Have to succeed matching what follows at least n times.
        -: 6329:           After that, handle like `on_failure_jump'.  */
      144: 6330:        case succeed_n: 
      144: 6331:          EXTRACT_NUMBER (mcnt, p + 2);
        -: 6332:          DEBUG_PRINT2 ("EXECUTING succeed_n %d.\n", mcnt);
        -: 6333:
        -: 6334:          assert (mcnt >= 0);
        -: 6335:          /* Originally, this is how many times we HAVE to succeed.  */
      144: 6336:          if (mcnt > 0)
branch  0 taken 72 (fallthrough)
branch  1 taken 72
        -: 6337:            {
       72: 6338:               mcnt--;
       72: 6339:	       p += 2;
       72: 6340:               STORE_NUMBER_AND_INCR (p, mcnt);
        -: 6341:               DEBUG_PRINT3 ("  Setting 0x%x to %d.\n", p, mcnt);
        -: 6342:            }
       72: 6343:	  else if (mcnt == 0)
branch  0 taken 72 (fallthrough)
branch  1 taken 0
        -: 6344:            {
        -: 6345:              DEBUG_PRINT2 ("  Setting two bytes from 0x%x to no_op.\n", p+2);
       72: 6346:	      p[2] = (unsigned char) no_op;
       72: 6347:              p[3] = (unsigned char) no_op;
       72: 6348:              goto on_failure;
        -: 6349:            }
       72: 6350:          break;
        -: 6351:        
       78: 6352:        case jump_n: 
       78: 6353:          EXTRACT_NUMBER (mcnt, p + 2);
        -: 6354:          DEBUG_PRINT2 ("EXECUTING jump_n %d.\n", mcnt);
        -: 6355:
        -: 6356:          /* Originally, this is how many times we CAN jump.  */
       78: 6357:          if (mcnt)
branch  0 taken 72 (fallthrough)
branch  1 taken 6
        -: 6358:            {
       72: 6359:               mcnt--;
       72: 6360:               STORE_NUMBER (p + 2, mcnt);
       72: 6361:	       goto unconditional_jump;	     
        -: 6362:            }
        -: 6363:          /* If don't have to jump any more, skip over the rest of command.  */
        -: 6364:	  else      
        6: 6365:	    p += 4;		     
        6: 6366:          break;
        -: 6367:        
      144: 6368:	case set_number_at:
        -: 6369:	  {
        -: 6370:            DEBUG_PRINT1 ("EXECUTING set_number_at.\n");
        -: 6371:
      144: 6372:            EXTRACT_NUMBER_AND_INCR (mcnt, p);
      144: 6373:            p1 = p + mcnt;
      144: 6374:            EXTRACT_NUMBER_AND_INCR (mcnt, p);
        -: 6375:            DEBUG_PRINT3 ("  Setting 0x%x to %d.\n", p1, mcnt);
      144: 6376:	    STORE_NUMBER (p1, mcnt);
      144: 6377:            break;
        -: 6378:          }
        -: 6379:
    #####: 6380:        case wordbound:
        -: 6381:          DEBUG_PRINT1 ("EXECUTING wordbound.\n");
    #####: 6382:          if (AT_WORD_BOUNDARY (d))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
        -: 6383:	    break;
    #####: 6384:          goto fail;
        -: 6385:
    #####: 6386:	case notwordbound:
        -: 6387:          DEBUG_PRINT1 ("EXECUTING notwordbound.\n");
    #####: 6388:	  if (AT_WORD_BOUNDARY (d))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
    #####: 6389:	    goto fail;
    #####: 6390:          break;
        -: 6391:
    #####: 6392:	case wordbeg:
        -: 6393:          DEBUG_PRINT1 ("EXECUTING wordbeg.\n");
    #####: 6394:	  if (WORDCHAR_P (d) && (AT_STRINGS_BEG (d) || !WORDCHAR_P (d - 1)))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
        -: 6395:	    break;
    #####: 6396:          goto fail;
        -: 6397:
    #####: 6398:	case wordend:
        -: 6399:          DEBUG_PRINT1 ("EXECUTING wordend.\n");
    #####: 6400:	  if (!AT_STRINGS_BEG (d) && WORDCHAR_P (d - 1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
    #####: 6401:              && (!WORDCHAR_P (d) || AT_STRINGS_END (d)))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -: 6402:	    break;
    #####: 6403:          goto fail;
        -: 6404:
        -: 6405:#ifdef emacs
        -: 6406:#ifdef emacs19
        -: 6407:  	case before_dot:
        -: 6408:          DEBUG_PRINT1 ("EXECUTING before_dot.\n");
        -: 6409: 	  if (PTR_CHAR_POS ((unsigned char *) d) >= point)
        -: 6410:  	    goto fail;
        -: 6411:  	  break;
        -: 6412:  
        -: 6413:  	case at_dot:
        -: 6414:          DEBUG_PRINT1 ("EXECUTING at_dot.\n");
        -: 6415: 	  if (PTR_CHAR_POS ((unsigned char *) d) != point)
        -: 6416:  	    goto fail;
        -: 6417:  	  break;
        -: 6418:  
        -: 6419:  	case after_dot:
        -: 6420:          DEBUG_PRINT1 ("EXECUTING after_dot.\n");
        -: 6421:          if (PTR_CHAR_POS ((unsigned char *) d) <= point)
        -: 6422:  	    goto fail;
        -: 6423:  	  break;
        -: 6424:#else /* not emacs19 */
        -: 6425:	case at_dot:
        -: 6426:          DEBUG_PRINT1 ("EXECUTING at_dot.\n");
        -: 6427:	  if (PTR_CHAR_POS ((unsigned char *) d) + 1 != point)
        -: 6428:	    goto fail;
        -: 6429:	  break;
        -: 6430:#endif /* not emacs19 */
        -: 6431:
        -: 6432:	case syntaxspec:
        -: 6433:          DEBUG_PRINT2 ("EXECUTING syntaxspec %d.\n", mcnt);
        -: 6434:	  mcnt = *p++;
        -: 6435:	  goto matchsyntax;
        -: 6436:
        -: 6437:        case wordchar:
        -: 6438:          DEBUG_PRINT1 ("EXECUTING Emacs wordchar.\n");
        -: 6439:	  mcnt = (int) Sword;
        -: 6440:        matchsyntax:
        -: 6441:	  PREFETCH ();
        -: 6442:	  if (SYNTAX (*d++) != (enum syntaxcode) mcnt)
        -: 6443:            goto fail;
        -: 6444:          SET_REGS_MATCHED ();
        -: 6445:	  break;
        -: 6446:
        -: 6447:	case notsyntaxspec:
        -: 6448:          DEBUG_PRINT2 ("EXECUTING notsyntaxspec %d.\n", mcnt);
        -: 6449:	  mcnt = *p++;
        -: 6450:	  goto matchnotsyntax;
        -: 6451:
        -: 6452:        case notwordchar:
        -: 6453:          DEBUG_PRINT1 ("EXECUTING Emacs notwordchar.\n");
        -: 6454:	  mcnt = (int) Sword;
        -: 6455:        matchnotsyntax:
        -: 6456:	  PREFETCH ();
        -: 6457:	  if (SYNTAX (*d++) == (enum syntaxcode) mcnt)
        -: 6458:            goto fail;
        -: 6459:	  SET_REGS_MATCHED ();
        -: 6460:          break;
        -: 6461:
        -: 6462:#else /* not emacs */
    #####: 6463:	case wordchar:
        -: 6464:          DEBUG_PRINT1 ("EXECUTING non-Emacs wordchar.\n");
    #####: 6465:	  PREFETCH ();
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 6466:          if (!WORDCHAR_P (d))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 6467:            goto fail;
    #####: 6468:	  SET_REGS_MATCHED ();
branch  0 never executed
branch  1 never executed
    #####: 6469:          d++;
    #####: 6470:	  break;
        -: 6471:	  
    #####: 6472:	case notwordchar:
        -: 6473:          DEBUG_PRINT1 ("EXECUTING non-Emacs notwordchar.\n");
    #####: 6474:	  PREFETCH ();
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 6475:	  if (WORDCHAR_P (d))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 6476:            goto fail;
    #####: 6477:          SET_REGS_MATCHED ();
branch  0 never executed
branch  1 never executed
    #####: 6478:          d++;
    #####: 6479:	  break;
        -: 6480:#endif /* not emacs */
        -: 6481:          
    #####: 6482:        default:
    #####: 6483:          abort ();
call    0 never executed
        -: 6484:	}
  1188048: 6485:      continue;  /* Successfully executed one pattern command; keep going.  */
        -: 6486:
        -: 6487:
        -: 6488:    /* We goto here if a matching operation fails. */
   429110: 6489:    fail:
   429110: 6490:      if (!FAIL_STACK_EMPTY ())
branch  0 taken 387082 (fallthrough)
branch  1 taken 42028
        -: 6491:	{ /* A restart point is known.  Restore to that state.  */
        -: 6492:          DEBUG_PRINT1 ("\nFAIL:\n");
   387341: 6493:          POP_FAILURE_POINT (d, p,
branch  0 taken 387082 (fallthrough)
branch  1 taken 0
branch  2 taken 259
branch  3 taken 387082 (fallthrough)
        -: 6494:                             lowest_active_reg, highest_active_reg,
        -: 6495:                             regstart, regend, reg_info);
        -: 6496:
        -: 6497:          /* If this failure point is a dummy, try the next one.  */
   387082: 6498:          if (!p)
branch  0 taken 0 (fallthrough)
branch  1 taken 387082
    #####: 6499:	    goto fail;
        -: 6500:
        -: 6501:          /* If we failed to the end of the pattern, don't examine *p.  */
        -: 6502:	  assert (p <= pend);
   387082: 6503:          if (p < pend)
branch  0 taken 1044 (fallthrough)
branch  1 taken 386038
        -: 6504:            {
   386038: 6505:              boolean is_a_jump_n = false;
        -: 6506:              
        -: 6507:              /* If failed to a backwards jump that's part of a repetition
        -: 6508:                 loop, need to pop this failure point and use the next one.  */
   386038: 6509:              switch ((re_opcode_t) *p)
branch  0 taken 0
branch  1 taken 0
branch  2 taken 386038
        -: 6510:                {
    #####: 6511:                case jump_n:
    #####: 6512:                  is_a_jump_n = true;
    #####: 6513:                case maybe_pop_jump:
        -: 6514:                case pop_failure_jump:
        -: 6515:                case jump:
    #####: 6516:                  p1 = p + 1;
    #####: 6517:                  EXTRACT_NUMBER_AND_INCR (mcnt, p1);
    #####: 6518:                  p1 += mcnt;	
        -: 6519:
    #####: 6520:                  if ((is_a_jump_n && (re_opcode_t) *p1 == succeed_n)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 6521:                      || (!is_a_jump_n
branch  0 never executed
branch  1 never executed
    #####: 6522:                          && (re_opcode_t) *p1 == on_failure_jump))
branch  0 never executed
branch  1 never executed
    #####: 6523:                    goto fail;
    #####: 6524:                  break;
     1044: 6525:                default:
        -: 6526:                  /* do nothing */ ;
        -: 6527:                }
        -: 6528:            }
        -: 6529:
   387082: 6530:          if (d >= string1 && d <= end1)
branch  0 taken 387082 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 387082
    #####: 6531:	    dend = end_match_1;
        -: 6532:        }
        -: 6533:      else
    42028: 6534:        break;   /* Matching at this starting point really fails.  */
        -: 6535:    } /* for (;;) */
        -: 6536:
    42028: 6537:  if (best_regs_set)
branch  0 taken 51 (fallthrough)
branch  1 taken 41977
       51: 6538:    goto restore_best_regs;
        -: 6539:
    41977: 6540:  FREE_VARIABLES ();
        -: 6541:
    41977: 6542:  return -1;         			/* Failure to match.  */
        -: 6543:} /* re_match_2 */
        -: 6544:
        -: 6545:/* Subroutine definitions for re_match_2.  */
        -: 6546:
        -: 6547:
        -: 6548:/* We are passed P pointing to a register number after a start_memory.
        -: 6549:   
        -: 6550:   Return true if the pattern up to the corresponding stop_memory can
        -: 6551:   match the empty string, and false otherwise.
        -: 6552:   
        -: 6553:   If we find the matching stop_memory, sets P to point to one past its number.
        -: 6554:   Otherwise, sets P to an undefined byte less than or equal to END.
        -: 6555:
        -: 6556:   We don't handle duplicates properly (yet).  */
        -: 6557:
        -: 6558:static boolean
function group_match_null_string_p called 30 returned 100% blocks executed 44%
       30: 6559:group_match_null_string_p (p, end, reg_info)
        -: 6560:    unsigned char **p, *end;
        -: 6561:    register_info_type *reg_info;
        -: 6562:{
        -: 6563:  int mcnt;
        -: 6564:  /* Point to after the args to the start_memory.  */
       30: 6565:  unsigned char *p1 = *p + 2;
        -: 6566:  
       30: 6567:  while (p1 < end)
branch  0 taken 30
branch  1 taken 0 (fallthrough)
        -: 6568:    {
        -: 6569:      /* Skip over opcodes that can match nothing, and return true or
        -: 6570:	 false, as appropriate, when we get to one that can't, or to the
        -: 6571:         matching stop_memory.  */
        -: 6572:      
       30: 6573:      switch ((re_opcode_t) *p1)
branch  0 taken 30
branch  1 taken 0
branch  2 taken 0
        -: 6574:        {
        -: 6575:        /* Could be either a loop or a series of alternatives.  */
       30: 6576:        case on_failure_jump:
       30: 6577:          p1++;
       30: 6578:          EXTRACT_NUMBER_AND_INCR (mcnt, p1);
        -: 6579:          
        -: 6580:          /* If the next operation is not a jump backwards in the
        -: 6581:	     pattern.  */
        -: 6582:
       30: 6583:	  if (mcnt >= 0)
branch  0 taken 30 (fallthrough)
branch  1 taken 0
        -: 6584:	    {
        -: 6585:              /* Go through the on_failure_jumps of the alternatives,
        -: 6586:                 seeing if any of the alternatives cannot match nothing.
        -: 6587:                 The last alternative starts with only a jump,
        -: 6588:                 whereas the rest start with on_failure_jump and end
        -: 6589:                 with a jump, e.g., here is the pattern for `a|b|c':
        -: 6590:
        -: 6591:                 /on_failure_jump/0/6/exactn/1/a/jump_past_alt/0/6
        -: 6592:                 /on_failure_jump/0/6/exactn/1/b/jump_past_alt/0/3
        -: 6593:                 /exactn/1/c						
        -: 6594:
        -: 6595:                 So, we have to first go through the first (n-1)
        -: 6596:                 alternatives and then deal with the last one separately.  */
        -: 6597:
        -: 6598:
        -: 6599:              /* Deal with the first (n-1) alternatives, which start
        -: 6600:                 with an on_failure_jump (see above) that jumps to right
        -: 6601:                 past a jump_past_alt.  */
        -: 6602:
       30: 6603:              while ((re_opcode_t) p1[mcnt-3] == jump_past_alt)
branch  0 taken 0
branch  1 taken 30 (fallthrough)
        -: 6604:                {
        -: 6605:                  /* `mcnt' holds how many bytes long the alternative
        -: 6606:                     is, including the ending `jump_past_alt' and
        -: 6607:                     its number.  */
        -: 6608:
    #####: 6609:                  if (!alt_match_null_string_p (p1, p1 + mcnt - 3, 
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 6610:				                      reg_info))
    #####: 6611:                    return false;
        -: 6612:
        -: 6613:                  /* Move to right after this alternative, including the
        -: 6614:		     jump_past_alt.  */
    #####: 6615:                  p1 += mcnt;	
        -: 6616:
        -: 6617:                  /* Break if it's the beginning of an n-th alternative
        -: 6618:                     that doesn't begin with an on_failure_jump.  */
    #####: 6619:                  if ((re_opcode_t) *p1 != on_failure_jump)
branch  0 never executed
branch  1 never executed
    #####: 6620:                    break;
        -: 6621:		
        -: 6622:		  /* Still have to check that it's not an n-th
        -: 6623:		     alternative that starts with an on_failure_jump.  */
    #####: 6624:		  p1++;
    #####: 6625:                  EXTRACT_NUMBER_AND_INCR (mcnt, p1);
    #####: 6626:                  if ((re_opcode_t) p1[mcnt-3] != jump_past_alt)
branch  0 never executed
branch  1 never executed
        -: 6627:                    {
        -: 6628:		      /* Get to the beginning of the n-th alternative.  */
    #####: 6629:                      p1 -= 3;
    #####: 6630:                      break;
        -: 6631:                    }
        -: 6632:                }
        -: 6633:
        -: 6634:              /* Deal with the last alternative: go back and get number
        -: 6635:                 of the `jump_past_alt' just before it.  `mcnt' contains
        -: 6636:                 the length of the alternative.  */
       30: 6637:              EXTRACT_NUMBER (mcnt, p1 - 2);
        -: 6638:
       30: 6639:              if (!alt_match_null_string_p (p1, p1 + mcnt, reg_info))
call    0 returned 30
branch  1 taken 30 (fallthrough)
branch  2 taken 0
       30: 6640:                return false;
        -: 6641:
    #####: 6642:              p1 += mcnt;	/* Get past the n-th alternative.  */
        -: 6643:            } /* if mcnt > 0 */
    #####: 6644:          break;
        -: 6645:
        -: 6646:          
    #####: 6647:        case stop_memory:
        -: 6648:	  assert (p1[1] == **p);
    #####: 6649:          *p = p1 + 2;
    #####: 6650:          return true;
        -: 6651:
        -: 6652:        
    #####: 6653:        default: 
    #####: 6654:          if (!common_op_match_null_string_p (&p1, end, reg_info))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 6655:            return false;
        -: 6656:        }
        -: 6657:    } /* while p1 < end */
        -: 6658:
    #####: 6659:  return false;
        -: 6660:} /* group_match_null_string_p */
        -: 6661:
        -: 6662:
        -: 6663:/* Similar to group_match_null_string_p, but doesn't deal with alternatives:
        -: 6664:   It expects P to be the first byte of a single alternative and END one
        -: 6665:   byte past the last. The alternative can contain groups.  */
        -: 6666:   
        -: 6667:static boolean
function alt_match_null_string_p called 30 returned 100% blocks executed 80%
       30: 6668:alt_match_null_string_p (p, end, reg_info)
        -: 6669:    unsigned char *p, *end;
        -: 6670:    register_info_type *reg_info;
        -: 6671:{
        -: 6672:  int mcnt;
       30: 6673:  unsigned char *p1 = p;
        -: 6674:  
       30: 6675:  while (p1 < end)
branch  0 taken 30
branch  1 taken 0 (fallthrough)
        -: 6676:    {
        -: 6677:      /* Skip over opcodes that can match nothing, and break when we get 
        -: 6678:         to one that can't.  */
        -: 6679:      
       30: 6680:      switch ((re_opcode_t) *p1)
branch  0 taken 0 (fallthrough)
branch  1 taken 30
        -: 6681:        {
        -: 6682:	/* It's a loop.  */
    #####: 6683:        case on_failure_jump:
    #####: 6684:          p1++;
    #####: 6685:          EXTRACT_NUMBER_AND_INCR (mcnt, p1);
    #####: 6686:          p1 += mcnt;
    #####: 6687:          break;
        -: 6688:          
       30: 6689:	default: 
       30: 6690:          if (!common_op_match_null_string_p (&p1, end, reg_info))
call    0 returned 30
branch  1 taken 30 (fallthrough)
branch  2 taken 0
       30: 6691:            return false;
        -: 6692:        }
        -: 6693:    }  /* while p1 < end */
        -: 6694:
    #####: 6695:  return true;
        -: 6696:} /* alt_match_null_string_p */
        -: 6697:
        -: 6698:
        -: 6699:/* Deals with the ops common to group_match_null_string_p and
        -: 6700:   alt_match_null_string_p.  
        -: 6701:   
        -: 6702:   Sets P to one after the op and its arguments, if any.  */
        -: 6703:
        -: 6704:static boolean
function common_op_match_null_string_p called 30 returned 100% blocks executed 17%
       30: 6705:common_op_match_null_string_p (p, end, reg_info)
        -: 6706:    unsigned char **p, *end;
        -: 6707:    register_info_type *reg_info;
        -: 6708:{
        -: 6709:  int mcnt;
        -: 6710:  boolean ret;
        -: 6711:  int reg_no;
       30: 6712:  unsigned char *p1 = *p;
        -: 6713:
       30: 6714:  switch ((re_opcode_t) *p1++)
branch  0 taken 0
branch  1 taken 0
branch  2 taken 0
branch  3 taken 0
branch  4 taken 0
branch  5 taken 0
branch  6 taken 30
        -: 6715:    {
    #####: 6716:    case no_op:
        -: 6717:    case begline:
        -: 6718:    case endline:
        -: 6719:    case begbuf:
        -: 6720:    case endbuf:
        -: 6721:    case wordbeg:
        -: 6722:    case wordend:
        -: 6723:    case wordbound:
        -: 6724:    case notwordbound:
        -: 6725:#ifdef emacs
        -: 6726:    case before_dot:
        -: 6727:    case at_dot:
        -: 6728:    case after_dot:
        -: 6729:#endif
    #####: 6730:      break;
        -: 6731:
    #####: 6732:    case start_memory:
    #####: 6733:      reg_no = *p1;
        -: 6734:      assert (reg_no > 0 && reg_no <= MAX_REGNUM);
    #####: 6735:      ret = group_match_null_string_p (&p1, end, reg_info);
call    0 never executed
        -: 6736:      
        -: 6737:      /* Have to set this here in case we're checking a group which
        -: 6738:         contains a group and a back reference to it.  */
        -: 6739:
    #####: 6740:      if (REG_MATCH_NULL_STRING_P (reg_info[reg_no]) == MATCH_NULL_UNSET_VALUE)
branch  0 never executed
branch  1 never executed
    #####: 6741:        REG_MATCH_NULL_STRING_P (reg_info[reg_no]) = ret;
        -: 6742:
    #####: 6743:      if (!ret)
branch  0 never executed
branch  1 never executed
    #####: 6744:        return false;
    #####: 6745:      break;
        -: 6746:          
        -: 6747:    /* If this is an optimized succeed_n for zero times, make the jump.  */
    #####: 6748:    case jump:
    #####: 6749:      EXTRACT_NUMBER_AND_INCR (mcnt, p1);
    #####: 6750:      if (mcnt >= 0)
branch  0 never executed
branch  1 never executed
    #####: 6751:        p1 += mcnt;
        -: 6752:      else
    #####: 6753:        return false;
    #####: 6754:      break;
        -: 6755:
    #####: 6756:    case succeed_n:
        -: 6757:      /* Get to the number of times to succeed.  */
    #####: 6758:      p1 += 2;		
    #####: 6759:      EXTRACT_NUMBER_AND_INCR (mcnt, p1);
        -: 6760:
    #####: 6761:      if (mcnt == 0)
branch  0 never executed
branch  1 never executed
        -: 6762:        {
    #####: 6763:          p1 -= 4;
    #####: 6764:          EXTRACT_NUMBER_AND_INCR (mcnt, p1);
    #####: 6765:          p1 += mcnt;
        -: 6766:        }
        -: 6767:      else
    #####: 6768:        return false;
    #####: 6769:      break;
        -: 6770:
    #####: 6771:    case duplicate: 
    #####: 6772:      if (!REG_MATCH_NULL_STRING_P (reg_info[*p1]))
branch  0 never executed
branch  1 never executed
    #####: 6773:        return false;
    #####: 6774:      break;
        -: 6775:
    #####: 6776:    case set_number_at:
    #####: 6777:      p1 += 4;
        -: 6778:
       30: 6779:    default:
        -: 6780:      /* All other opcodes mean we cannot match the empty string.  */
       30: 6781:      return false;
        -: 6782:  }
        -: 6783:
    #####: 6784:  *p = p1;
    #####: 6785:  return true;
        -: 6786:} /* common_op_match_null_string_p */
        -: 6787:
        -: 6788:
        -: 6789:/* Return zero if TRANSLATE[S1] and TRANSLATE[S2] are identical for LEN
        -: 6790:   bytes; nonzero otherwise.  */
        -: 6791:   
        -: 6792:static int
function bcmp_translate called 0 returned 0% blocks executed 0%
    #####: 6793:bcmp_translate (s1, s2, len, translate)
        -: 6794:     unsigned char *s1, *s2;
        -: 6795:     register int len;
        -: 6796:     char *translate;
        -: 6797:{
    #####: 6798:  register unsigned char *p1 = s1, *p2 = s2;
    #####: 6799:  while (len)
branch  0 never executed
branch  1 never executed
        -: 6800:    {
    #####: 6801:      if (translate[*p1++] != translate[*p2++]) return 1;
branch  0 never executed
branch  1 never executed
    #####: 6802:      len--;
        -: 6803:    }
    #####: 6804:  return 0;
        -: 6805:}
        -: 6806:
        -: 6807:/* Entry points for GNU code.  */
        -: 6808:
        -: 6809:/* re_compile_pattern is the GNU regular expression compiler: it
        -: 6810:   compiles PATTERN (of length SIZE) and puts the result in BUFP.
        -: 6811:   Returns 0 if the pattern was valid, otherwise an error string.
        -: 6812:   
        -: 6813:   Assumes the `allocated' (and perhaps `buffer') and `translate' fields
        -: 6814:   are set in BUFP on entry.
        -: 6815:   
        -: 6816:   We call regex_compile to do the actual compilation.  */
        -: 6817:
        -: 6818:const char *
function re_compile_pattern called 603 returned 100% blocks executed 100%
      603: 6819:re_compile_pattern (pattern, length, bufp)
        -: 6820:     const char *pattern;
        -: 6821:     int length;
        -: 6822:     struct re_pattern_buffer *bufp;
        -: 6823:{
        -: 6824:  reg_errcode_t ret;
        -: 6825:  
        -: 6826:  /* GNU code is written to assume at least RE_NREGS registers will be set
        -: 6827:     (and at least one extra will be -1).  */
      603: 6828:  bufp->regs_allocated = REGS_UNALLOCATED;
        -: 6829:  
        -: 6830:  /* And GNU code determines whether or not to get register information
        -: 6831:     by passing null for the REGS argument to re_match, etc., not by
        -: 6832:     setting no_sub.  */
      603: 6833:  bufp->no_sub = 0;
        -: 6834:  
        -: 6835:  /* Match anchors at newline.  */
      603: 6836:  bufp->newline_anchor = 1;
        -: 6837:  
      603: 6838:  ret = regex_compile (pattern, length, re_syntax_options, bufp);
call    0 returned 603
        -: 6839:
      603: 6840:  return re_error_msg[(int) ret];
        -: 6841:}     
        -: 6842:
        -: 6843:/* Entry points compatible with 4.2 BSD regex library.  We don't define
        -: 6844:   them if this is an Emacs or POSIX compilation.  */
        -: 6845:
        -: 6846:#if !defined (emacs) && !defined (_POSIX_SOURCE)
        -: 6847:
        -: 6848:/* BSD has one and only one pattern buffer.  */
        -: 6849:static struct re_pattern_buffer re_comp_buf;
        -: 6850:
        -: 6851:char *
        -: 6852:re_comp (s)
        -: 6853:    const char *s;
        -: 6854:{
        -: 6855:  reg_errcode_t ret;
        -: 6856:  
        -: 6857:  if (!s)
        -: 6858:    {
        -: 6859:      if (!re_comp_buf.buffer)
        -: 6860:	return "No previous regular expression";
        -: 6861:      return 0;
        -: 6862:    }
        -: 6863:
        -: 6864:  if (!re_comp_buf.buffer)
        -: 6865:    {
        -: 6866:      re_comp_buf.buffer = (unsigned char *) malloc (200);
        -: 6867:      if (re_comp_buf.buffer == NULL)
        -: 6868:        return "Memory exhausted";
        -: 6869:      re_comp_buf.allocated = 200;
        -: 6870:
        -: 6871:      re_comp_buf.fastmap = (char *) malloc (1 << BYTEWIDTH);
        -: 6872:      if (re_comp_buf.fastmap == NULL)
        -: 6873:	return "Memory exhausted";
        -: 6874:    }
        -: 6875:
        -: 6876:  /* Since `re_exec' always passes NULL for the `regs' argument, we
        -: 6877:     don't need to initialize the pattern buffer fields which affect it.  */
        -: 6878:
        -: 6879:  /* Match anchors at newlines.  */
        -: 6880:  re_comp_buf.newline_anchor = 1;
        -: 6881:
        -: 6882:  ret = regex_compile (s, strlen (s), re_syntax_options, &re_comp_buf);
        -: 6883:  
        -: 6884:  /* Yes, we're discarding `const' here.  */
        -: 6885:  return (char *) re_error_msg[(int) ret];
        -: 6886:}
        -: 6887:
        -: 6888:
        -: 6889:int
        -: 6890:re_exec (s)
        -: 6891:    const char *s;
        -: 6892:{
        -: 6893:  const int len = strlen (s);
        -: 6894:  return
        -: 6895:    0 <= re_search (&re_comp_buf, s, len, 0, len, (struct re_registers *) 0);
        -: 6896:}
        -: 6897:#endif /* not emacs and not _POSIX_SOURCE */
        -: 6898:
        -: 6899:/* POSIX.2 functions.  Don't define these for Emacs.  */
        -: 6900:
        -: 6901:#ifndef emacs
        -: 6902:
        -: 6903:/* regcomp takes a regular expression as a string and compiles it.
        -: 6904:
        -: 6905:   PREG is a regex_t *.  We do not expect any fields to be initialized,
        -: 6906:   since POSIX says we shouldn't.  Thus, we set
        -: 6907:
        -: 6908:     `buffer' to the compiled pattern;
        -: 6909:     `used' to the length of the compiled pattern;
        -: 6910:     `syntax' to RE_SYNTAX_POSIX_EXTENDED if the
        -: 6911:       REG_EXTENDED bit in CFLAGS is set; otherwise, to
        -: 6912:       RE_SYNTAX_POSIX_BASIC;
        -: 6913:     `newline_anchor' to REG_NEWLINE being set in CFLAGS;
        -: 6914:     `fastmap' and `fastmap_accurate' to zero;
        -: 6915:     `re_nsub' to the number of subexpressions in PATTERN.
        -: 6916:
        -: 6917:   PATTERN is the address of the pattern string.
        -: 6918:
        -: 6919:   CFLAGS is a series of bits which affect compilation.
        -: 6920:
        -: 6921:     If REG_EXTENDED is set, we use POSIX extended syntax; otherwise, we
        -: 6922:     use POSIX basic syntax.
        -: 6923:
        -: 6924:     If REG_NEWLINE is set, then . and [^...] don't match newline.
        -: 6925:     Also, regexec will try a match beginning after every newline.
        -: 6926:
        -: 6927:     If REG_ICASE is set, then we considers upper- and lowercase
        -: 6928:     versions of letters to be equivalent when matching.
        -: 6929:
        -: 6930:     If REG_NOSUB is set, then when PREG is passed to regexec, that
        -: 6931:     routine will report only success or failure, and nothing about the
        -: 6932:     registers.
        -: 6933:
        -: 6934:   It returns 0 if it succeeds, nonzero if it doesn't.  (See regex.h for
        -: 6935:   the return codes and their meanings.)  */
        -: 6936:
        -: 6937:int
function regcomp called 0 returned 0% blocks executed 0%
    #####: 6938:regcomp (preg, pattern, cflags)
        -: 6939:    regex_t *preg;
        -: 6940:    const char *pattern; 
        -: 6941:    int cflags;
        -: 6942:{
        -: 6943:  reg_errcode_t ret;
    #####: 6944:  unsigned syntax
    #####: 6945:    = (cflags & REG_EXTENDED) ?
    #####: 6946:      RE_SYNTAX_POSIX_EXTENDED : RE_SYNTAX_POSIX_BASIC;
branch  0 never executed
branch  1 never executed
        -: 6947:
        -: 6948:  /* regex_compile will allocate the space for the compiled pattern.  */
    #####: 6949:  preg->buffer = 0;
    #####: 6950:  preg->allocated = 0;
        -: 6951:  
        -: 6952:  /* Don't bother to use a fastmap when searching.  This simplifies the
        -: 6953:     REG_NEWLINE case: if we used a fastmap, we'd have to put all the
        -: 6954:     characters after newlines into the fastmap.  This way, we just try
        -: 6955:     every character.  */
    #####: 6956:  preg->fastmap = 0;
        -: 6957:  
    #####: 6958:  if (cflags & REG_ICASE)
branch  0 never executed
branch  1 never executed
        -: 6959:    {
        -: 6960:      unsigned i;
        -: 6961:      
    #####: 6962:      preg->translate = (char *) malloc (CHAR_SET_SIZE);
    #####: 6963:      if (preg->translate == NULL)
branch  0 never executed
branch  1 never executed
    #####: 6964:        return (int) REG_ESPACE;
        -: 6965:
        -: 6966:      /* Map uppercase characters to corresponding lowercase ones.  */
    #####: 6967:      for (i = 0; i < CHAR_SET_SIZE; i++)
branch  0 never executed
branch  1 never executed
    #####: 6968:        preg->translate[i] = ISUPPER (i) ? tolower (i) : i;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 6969:    }
        -: 6970:  else
    #####: 6971:    preg->translate = NULL;
        -: 6972:
        -: 6973:  /* If REG_NEWLINE is set, newlines are treated differently.  */
    #####: 6974:  if (cflags & REG_NEWLINE)
branch  0 never executed
branch  1 never executed
        -: 6975:    { /* REG_NEWLINE implies neither . nor [^...] match newline.  */
    #####: 6976:      syntax &= ~RE_DOT_NEWLINE;
    #####: 6977:      syntax |= RE_HAT_LISTS_NOT_NEWLINE;
        -: 6978:      /* It also changes the matching behavior.  */
    #####: 6979:      preg->newline_anchor = 1;
        -: 6980:    }
        -: 6981:  else
    #####: 6982:    preg->newline_anchor = 0;
        -: 6983:
    #####: 6984:  preg->no_sub = !!(cflags & REG_NOSUB);
        -: 6985:
        -: 6986:  /* POSIX says a null character in the pattern terminates it, so we 
        -: 6987:     can use strlen here in compiling the pattern.  */
    #####: 6988:  ret = regex_compile (pattern, strlen (pattern), syntax, preg);
call    0 never executed
        -: 6989:  
        -: 6990:  /* POSIX doesn't distinguish between an unmatched open-group and an
        -: 6991:     unmatched close-group: both are REG_EPAREN.  */
    #####: 6992:  if (ret == REG_ERPAREN) ret = REG_EPAREN;
branch  0 never executed
branch  1 never executed
        -: 6993:  
    #####: 6994:  return (int) ret;
        -: 6995:}
        -: 6996:
        -: 6997:
        -: 6998:/* regexec searches for a given pattern, specified by PREG, in the
        -: 6999:   string STRING.
        -: 7000:   
        -: 7001:   If NMATCH is zero or REG_NOSUB was set in the cflags argument to
        -: 7002:   `regcomp', we ignore PMATCH.  Otherwise, we assume PMATCH has at
        -: 7003:   least NMATCH elements, and we set them to the offsets of the
        -: 7004:   corresponding matched substrings.
        -: 7005:   
        -: 7006:   EFLAGS specifies `execution flags' which affect matching: if
        -: 7007:   REG_NOTBOL is set, then ^ does not match at the beginning of the
        -: 7008:   string; if REG_NOTEOL is set, then $ does not match at the end.
        -: 7009:   
        -: 7010:   We return 0 if we find a match and REG_NOMATCH if not.  */
        -: 7011:
        -: 7012:int
function regexec called 0 returned 0% blocks executed 0%
    #####: 7013:regexec (preg, string, nmatch, pmatch, eflags)
        -: 7014:    const regex_t *preg;
        -: 7015:    const char *string; 
        -: 7016:    size_t nmatch; 
        -: 7017:    regmatch_t pmatch[]; 
        -: 7018:    int eflags;
        -: 7019:{
        -: 7020:  int ret;
        -: 7021:  struct re_registers regs;
        -: 7022:  regex_t private_preg;
    #####: 7023:  int len = strlen (string);
    #####: 7024:  boolean want_reg_info = !preg->no_sub && nmatch > 0;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 7025:
    #####: 7026:  private_preg = *preg;
        -: 7027:  
    #####: 7028:  private_preg.not_bol = !!(eflags & REG_NOTBOL);
    #####: 7029:  private_preg.not_eol = !!(eflags & REG_NOTEOL);
        -: 7030:  
        -: 7031:  /* The user has told us exactly how many registers to return
        -: 7032:     information about, via `nmatch'.  We have to pass that on to the
        -: 7033:     matching routines.  */
    #####: 7034:  private_preg.regs_allocated = REGS_FIXED;
        -: 7035:  
    #####: 7036:  if (want_reg_info)
branch  0 never executed
branch  1 never executed
        -: 7037:    {
    #####: 7038:      regs.num_regs = nmatch;
    #####: 7039:      regs.start = TALLOC (nmatch, regoff_t);
    #####: 7040:      regs.end = TALLOC (nmatch, regoff_t);
    #####: 7041:      if (regs.start == NULL || regs.end == NULL)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 7042:        return (int) REG_NOMATCH;
        -: 7043:    }
        -: 7044:
        -: 7045:  /* Perform the searching operation.  */
    #####: 7046:  ret = re_search (&private_preg, string, len,
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 7047:                   /* start: */ 0, /* range: */ len,
        -: 7048:                   want_reg_info ? &regs : (struct re_registers *) 0);
        -: 7049:  
        -: 7050:  /* Copy the register information to the POSIX structure.  */
    #####: 7051:  if (want_reg_info)
branch  0 never executed
branch  1 never executed
        -: 7052:    {
    #####: 7053:      if (ret >= 0)
branch  0 never executed
branch  1 never executed
        -: 7054:        {
        -: 7055:          unsigned r;
        -: 7056:
    #####: 7057:          for (r = 0; r < nmatch; r++)
branch  0 never executed
branch  1 never executed
        -: 7058:            {
    #####: 7059:              pmatch[r].rm_so = regs.start[r];
    #####: 7060:              pmatch[r].rm_eo = regs.end[r];
        -: 7061:            }
        -: 7062:        }
        -: 7063:
        -: 7064:      /* If we needed the temporary register info, free the space now.  */
    #####: 7065:      free (regs.start);
    #####: 7066:      free (regs.end);
        -: 7067:    }
        -: 7068:
        -: 7069:  /* We want zero return to mean success, unlike `re_search'.  */
    #####: 7070:  return ret >= 0 ? (int) REG_NOERROR : (int) REG_NOMATCH;
        -: 7071:}
        -: 7072:
        -: 7073:
        -: 7074:/* Returns a message corresponding to an error code, ERRCODE, returned
        -: 7075:   from either regcomp or regexec.   We don't use PREG here.  */
        -: 7076:
        -: 7077:size_t
function regerror called 0 returned 0% blocks executed 0%
    #####: 7078:regerror (errcode, preg, errbuf, errbuf_size)
        -: 7079:    int errcode;
        -: 7080:    const regex_t *preg;
        -: 7081:    char *errbuf;
        -: 7082:    size_t errbuf_size;
        -: 7083:{
        -: 7084:  const char *msg;
        -: 7085:  size_t msg_size;
        -: 7086:
    #####: 7087:  if (errcode < 0
branch  0 never executed
branch  1 never executed
    #####: 7088:      || errcode >= (sizeof (re_error_msg) / sizeof (re_error_msg[0])))
branch  0 never executed
branch  1 never executed
        -: 7089:    /* Only error codes returned by the rest of the code should be passed 
        -: 7090:       to this routine.  If we are given anything else, or if other regex
        -: 7091:       code generates an invalid error code, then the program has a bug.
        -: 7092:       Dump core so we can fix it.  */
    #####: 7093:    abort ();
call    0 never executed
        -: 7094:
    #####: 7095:  msg = re_error_msg[errcode];
        -: 7096:
        -: 7097:  /* POSIX doesn't require that we do anything in this case, but why
        -: 7098:     not be nice.  */
    #####: 7099:  if (! msg)
branch  0 never executed
branch  1 never executed
    #####: 7100:    msg = "Success";
        -: 7101:
    #####: 7102:  msg_size = strlen (msg) + 1; /* Includes the null.  */
        -: 7103:  
    #####: 7104:  if (errbuf_size != 0)
branch  0 never executed
branch  1 never executed
        -: 7105:    {
    #####: 7106:      if (msg_size > errbuf_size)
branch  0 never executed
branch  1 never executed
        -: 7107:        {
    #####: 7108:          strncpy (errbuf, msg, errbuf_size - 1);
    #####: 7109:          errbuf[errbuf_size - 1] = 0;
        -: 7110:        }
        -: 7111:      else
    #####: 7112:        strcpy (errbuf, msg);
        -: 7113:    }
        -: 7114:
    #####: 7115:  return msg_size;
        -: 7116:}
        -: 7117:
        -: 7118:
        -: 7119:/* Free dynamically allocated space used by PREG.  */
        -: 7120:
        -: 7121:void
function regfree called 0 returned 0% blocks executed 0%
    #####: 7122:regfree (preg)
        -: 7123:    regex_t *preg;
        -: 7124:{
    #####: 7125:  if (preg->buffer != NULL)
branch  0 never executed
branch  1 never executed
    #####: 7126:    free (preg->buffer);
    #####: 7127:  preg->buffer = NULL;
        -: 7128:  
    #####: 7129:  preg->allocated = 0;
    #####: 7130:  preg->used = 0;
        -: 7131:
    #####: 7132:  if (preg->fastmap != NULL)
branch  0 never executed
branch  1 never executed
    #####: 7133:    free (preg->fastmap);
    #####: 7134:  preg->fastmap = NULL;
    #####: 7135:  preg->fastmap_accurate = 0;
        -: 7136:
    #####: 7137:  if (preg->translate != NULL)
branch  0 never executed
branch  1 never executed
    #####: 7138:    free (preg->translate);
    #####: 7139:  preg->translate = NULL;
    #####: 7140:}
        -: 7141:
        -: 7142:#endif /* not emacs  */
        -: 7143:
        -: 7144:/*
        -: 7145:Local variables:
        -: 7146:make-backup-files: t
        -: 7147:version-control: t
        -: 7148:trim-versions-without-asking: nil
        -: 7149:End:
        -: 7150:*/
        -: 7151:/* Getopt for GNU.
        -: 7152:   NOTE: getopt is now part of the C library, so if you don't know what
        -: 7153:   "Keep this file name-space clean" means, talk to roland@gnu.ai.mit.edu
        -: 7154:   before changing it!
        -: 7155:
        -: 7156:   Copyright (C) 1987, 88, 89, 90, 91, 92, 1993
        -: 7157:   	Free Software Foundation, Inc.
        -: 7158:
        -: 7159:   This program is free software; you can redistribute it and/or modify it
        -: 7160:   under the terms of the GNU General Public License as published by the
        -: 7161:   Free Software Foundation; either version 2, or (at your option) any
        -: 7162:   later version.
        -: 7163:
        -: 7164:   This program is distributed in the hope that it will be useful,
        -: 7165:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 7166:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 7167:   GNU General Public License for more details.
        -: 7168:
        -: 7169:   You should have received a copy of the GNU General Public License
        -: 7170:   along with this program; if not, write to the Free Software
        -: 7171:   Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
        -: 7172:
        -: 7173:/* NOTE!!!  AIX requires this to be the first thing in the file.
        -: 7174:   Do not put ANYTHING before it!  */
        -: 7175:#if !defined (__GNUC__) && defined (_AIX)
        -: 7176: #pragma alloca
        -: 7177:#endif
        -: 7178:
        -: 7179:#ifdef HAVE_CONFIG_H
        -: 7180:#include "config.h"
        -: 7181:#endif
        -: 7182:
        -: 7183:#ifdef __GNUC__
        -: 7184:#ifndef alloca
        -: 7185:#define alloca __builtin_alloca
        -: 7186:#endif /* not alloca */
        -: 7187:#else /* not __GNUC__ */
        -: 7188:#if defined (HAVE_ALLOCA_H) || (defined(sparc) && (defined(sun) || (!defined(USG) && !defined(SVR4) && !defined(__svr4__))))
        -: 7189:#include <alloca.h>
        -: 7190:#else
        -: 7191:#ifndef _AIX
        -: 7192:char *alloca ();
        -: 7193:#endif
        -: 7194:#endif /* alloca.h */
        -: 7195:#endif /* not __GNUC__ */
        -: 7196:
        -: 7197:#if !__STDC__ && !defined(const) && IN_GCC
        -: 7198:#define const
        -: 7199:#endif
        -: 7200:
        -: 7201:/* This tells Alpha OSF/1 not to define a getopt prototype in <stdio.h>.  */
        -: 7202:#ifndef _NO_PROTO
        -: 7203:#define _NO_PROTO
        -: 7204:#endif
        -: 7205:
        -: 7206:#include <stdio.h>
        -: 7207:
        -: 7208:/* Comment out all this code if we are using the GNU C Library, and are not
        -: 7209:   actually compiling the library itself.  This code is part of the GNU C
        -: 7210:   Library, but also included in many other GNU distributions.  Compiling
        -: 7211:   and linking in this code is a waste when using the GNU C library
        -: 7212:   (especially if it is a shared library).  Rather than having every GNU
        -: 7213:   program understand `configure --with-gnu-libc' and omit the object files,
        -: 7214:   it is simpler to just do this in the source for each such file.  */
        -: 7215:
        -: 7216:#if defined (_LIBC) || !defined (__GNU_LIBRARY__)
        -: 7217:
        -: 7218:
        -: 7219:/* This needs to come after some library #include
        -: 7220:   to get __GNU_LIBRARY__ defined.  */
        -: 7221:#ifdef	__GNU_LIBRARY__
        -: 7222:#undef	alloca
        -: 7223:/* Don't include stdlib.h for non-GNU C libraries because some of them
        -: 7224:   contain conflicting prototypes for getopt.  */
        -: 7225:#include <stdlib.h>
        -: 7226:#else	/* Not GNU C library.  */
        -: 7227:#define	__alloca	alloca
        -: 7228:#endif	/* GNU C library.  */
        -: 7229:
        -: 7230:/* If GETOPT_COMPAT is defined, `+' as well as `--' can introduce a
        -: 7231:   long-named option.  Because this is not POSIX.2 compliant, it is
        -: 7232:   being phased out.  */
        -: 7233:/* #define GETOPT_COMPAT */
        -: 7234:
        -: 7235:/* This version of `getopt' appears to the caller like standard Unix `getopt'
        -: 7236:   but it behaves differently for the user, since it allows the user
        -: 7237:   to intersperse the options with the other arguments.
        -: 7238:
        -: 7239:   As `getopt' works, it permutes the elements of ARGV so that,
        -: 7240:   when it is done, all the options precede everything else.  Thus
        -: 7241:   all application programs are extended to handle flexible argument order.
        -: 7242:
        -: 7243:   Setting the environment variable POSIXLY_CORRECT disables permutation.
        -: 7244:   Then the behavior is completely standard.
        -: 7245:
        -: 7246:   GNU application programs can use a third alternative mode in which
        -: 7247:   they can distinguish the relative order of options and other arguments.  */
        -: 7248:
        -: 7249:#include "getopt.h"
        -: 7250:
        -: 7251:/* For communication from `getopt' to the caller.
        -: 7252:   When `getopt' finds an option that takes an argument,
        -: 7253:   the argument value is returned here.
        -: 7254:   Also, when `ordering' is RETURN_IN_ORDER,
        -: 7255:   each non-option ARGV-element is returned here.  */
        -: 7256:
        -: 7257:char *optarg = 0;
        -: 7258:
        -: 7259:/* Index in ARGV of the next element to be scanned.
        -: 7260:   This is used for communication to and from the caller
        -: 7261:   and for communication between successive calls to `getopt'.
        -: 7262:
        -: 7263:   On entry to `getopt', zero means this is the first call; initialize.
        -: 7264:
        -: 7265:   When `getopt' returns EOF, this is the index of the first of the
        -: 7266:   non-option elements that the caller should itself scan.
        -: 7267:
        -: 7268:   Otherwise, `optind' communicates from one call to the next
        -: 7269:   how much of ARGV has been scanned so far.  */
        -: 7270:
        -: 7271:/* XXX 1003.2 says this must be 1 before any call.  */
        -: 7272:int optind = 0;
        -: 7273:
        -: 7274:/* The next char to be scanned in the option-element
        -: 7275:   in which the last option character we returned was found.
        -: 7276:   This allows us to pick up the scan where we left off.
        -: 7277:
        -: 7278:   If this is zero, or a null string, it means resume the scan
        -: 7279:   by advancing to the next ARGV-element.  */
        -: 7280:
        -: 7281:static char *nextchar;
        -: 7282:
        -: 7283:/* Callers store zero here to inhibit the error message
        -: 7284:   for unrecognized options.  */
        -: 7285:
        -: 7286:int opterr = 1;
        -: 7287:
        -: 7288:/* Set to an option character which was unrecognized.
        -: 7289:   This must be initialized on some systems to avoid linking in the
        -: 7290:   system's own getopt implementation.  */
        -: 7291:
        -: 7292:int optopt = '?';
        -: 7293:
        -: 7294:/* Describe how to deal with options that follow non-option ARGV-elements.
        -: 7295:
        -: 7296:   If the caller did not specify anything,
        -: 7297:   the default is REQUIRE_ORDER if the environment variable
        -: 7298:   POSIXLY_CORRECT is defined, PERMUTE otherwise.
        -: 7299:
        -: 7300:   REQUIRE_ORDER means don't recognize them as options;
        -: 7301:   stop option processing when the first non-option is seen.
        -: 7302:   This is what Unix does.
        -: 7303:   This mode of operation is selected by either setting the environment
        -: 7304:   variable POSIXLY_CORRECT, or using `+' as the first character
        -: 7305:   of the list of option characters.
        -: 7306:
        -: 7307:   PERMUTE is the default.  We permute the contents of ARGV as we scan,
        -: 7308:   so that eventually all the non-options are at the end.  This allows options
        -: 7309:   to be given in any order, even with programs that were not written to
        -: 7310:   expect this.
        -: 7311:
        -: 7312:   RETURN_IN_ORDER is an option available to programs that were written
        -: 7313:   to expect options and other ARGV-elements in any order and that care about
        -: 7314:   the ordering of the two.  We describe each non-option ARGV-element
        -: 7315:   as if it were the argument of an option with character code 1.
        -: 7316:   Using `-' as the first character of the list of option characters
        -: 7317:   selects this mode of operation.
        -: 7318:
        -: 7319:   The special argument `--' forces an end of option-scanning regardless
        -: 7320:   of the value of `ordering'.  In the case of RETURN_IN_ORDER, only
        -: 7321:   `--' can cause `getopt' to return EOF with `optind' != ARGC.  */
        -: 7322:
        -: 7323:static enum
        -: 7324:{
        -: 7325:  REQUIRE_ORDER, PERMUTE, RETURN_IN_ORDER
        -: 7326:} ordering;
        -: 7327:
        -: 7328:#ifdef	__GNU_LIBRARY__
        -: 7329:/* We want to avoid inclusion of string.h with non-GNU libraries
        -: 7330:   because there are many ways it can cause trouble.
        -: 7331:   On some systems, it contains special magic macros that don't work
        -: 7332:   in GCC.  */
        -: 7333:#include <string.h>
        -: 7334:#define	my_index	strchr
        -: 7335:#define	my_bcopy(src, dst, n)	memcpy ((dst), (src), (n))
        -: 7336:#else
        -: 7337:
        -: 7338:/* Avoid depending on library functions or files
        -: 7339:   whose names are inconsistent.  */
        -: 7340:
        -: 7341:char *getenv ();
        -: 7342:
        -: 7343:static char *
        -: 7344:my_index (str, chr)
        -: 7345:     const char *str;
        -: 7346:     int chr;
        -: 7347:{
        -: 7348:  while (*str)
        -: 7349:    {
        -: 7350:      if (*str == chr)
        -: 7351:	return (char *) str;
        -: 7352:      str++;
        -: 7353:    }
        -: 7354:  return 0;
        -: 7355:}
        -: 7356:
        -: 7357:static void
        -: 7358:my_bcopy (from, to, size)
        -: 7359:     const char *from;
        -: 7360:     char *to;
        -: 7361:     int size;
        -: 7362:{
        -: 7363:  int i;
        -: 7364:  for (i = 0; i < size; i++)
        -: 7365:    to[i] = from[i];
        -: 7366:}
        -: 7367:#endif				/* GNU C library.  */
        -: 7368:
        -: 7369:/* Handle permutation of arguments.  */
        -: 7370:
        -: 7371:/* Describe the part of ARGV that contains non-options that have
        -: 7372:   been skipped.  `first_nonopt' is the index in ARGV of the first of them;
        -: 7373:   `last_nonopt' is the index after the last of them.  */
        -: 7374:
        -: 7375:static int first_nonopt;
        -: 7376:static int last_nonopt;
        -: 7377:
        -: 7378:/* Exchange two adjacent subsequences of ARGV.
        -: 7379:   One subsequence is elements [first_nonopt,last_nonopt)
        -: 7380:   which contains all the non-options that have been skipped so far.
        -: 7381:   The other is elements [last_nonopt,optind), which contains all
        -: 7382:   the options processed since those non-options were skipped.
        -: 7383:
        -: 7384:   `first_nonopt' and `last_nonopt' are relocated so that they describe
        -: 7385:   the new indices of the non-options in ARGV after they are moved.  */
        -: 7386:
        -: 7387:static void
        -: 7388:exchange (argv)
        -: 7389:     char **argv;
        -: 7390:{
        -: 7391:  int nonopts_size = (last_nonopt - first_nonopt) * sizeof (char *);
        -: 7392:  char **temp = (char **) __alloca (nonopts_size);
        -: 7393:
        -: 7394:  /* Interchange the two blocks of data in ARGV.  */
        -: 7395:
        -: 7396:  my_bcopy ((char *) &argv[first_nonopt], (char *) temp, nonopts_size);
        -: 7397:  my_bcopy ((char *) &argv[last_nonopt], (char *) &argv[first_nonopt],
        -: 7398:	    (optind - last_nonopt) * sizeof (char *));
        -: 7399:  my_bcopy ((char *) temp,
        -: 7400:	    (char *) &argv[first_nonopt + optind - last_nonopt],
        -: 7401:	    nonopts_size);
        -: 7402:
        -: 7403:  /* Update records for the slots the non-options now occupy.  */
        -: 7404:
        -: 7405:  first_nonopt += (optind - last_nonopt);
        -: 7406:  last_nonopt = optind;
        -: 7407:}
        -: 7408:
        -: 7409:/* Scan elements of ARGV (whose length is ARGC) for option characters
        -: 7410:   given in OPTSTRING.
        -: 7411:
        -: 7412:   If an element of ARGV starts with '-', and is not exactly "-" or "--",
        -: 7413:   then it is an option element.  The characters of this element
        -: 7414:   (aside from the initial '-') are option characters.  If `getopt'
        -: 7415:   is called repeatedly, it returns successively each of the option characters
        -: 7416:   from each of the option elements.
        -: 7417:
        -: 7418:   If `getopt' finds another option character, it returns that character,
        -: 7419:   updating `optind' and `nextchar' so that the next call to `getopt' can
        -: 7420:   resume the scan with the following option character or ARGV-element.
        -: 7421:
        -: 7422:   If there are no more option characters, `getopt' returns `EOF'.
        -: 7423:   Then `optind' is the index in ARGV of the first ARGV-element
        -: 7424:   that is not an option.  (The ARGV-elements have been permuted
        -: 7425:   so that those that are not options now come last.)
        -: 7426:
        -: 7427:   OPTSTRING is a string containing the legitimate option characters.
        -: 7428:   If an option character is seen that is not listed in OPTSTRING,
        -: 7429:   return '?' after printing an error message.  If you set `opterr' to
        -: 7430:   zero, the error message is suppressed but we still return '?'.
        -: 7431:
        -: 7432:   If a char in OPTSTRING is followed by a colon, that means it wants an arg,
        -: 7433:   so the following text in the same ARGV-element, or the text of the following
        -: 7434:   ARGV-element, is returned in `optarg'.  Two colons mean an option that
        -: 7435:   wants an optional arg; if there is text in the current ARGV-element,
        -: 7436:   it is returned in `optarg', otherwise `optarg' is set to zero.
        -: 7437:
        -: 7438:   If OPTSTRING starts with `-' or `+', it requests different methods of
        -: 7439:   handling the non-option ARGV-elements.
        -: 7440:   See the comments about RETURN_IN_ORDER and REQUIRE_ORDER, above.
        -: 7441:
        -: 7442:   Long-named options begin with `--' instead of `-'.
        -: 7443:   Their names may be abbreviated as long as the abbreviation is unique
        -: 7444:   or is an exact match for some defined option.  If they have an
        -: 7445:   argument, it follows the option name in the same ARGV-element, separated
        -: 7446:   from the option name by a `=', or else the in next ARGV-element.
        -: 7447:   When `getopt' finds a long-named option, it returns 0 if that option's
        -: 7448:   `flag' field is nonzero, the value of the option's `val' field
        -: 7449:   if the `flag' field is zero.
        -: 7450:
        -: 7451:   The elements of ARGV aren't really const, because we permute them.
        -: 7452:   But we pretend they're const in the prototype to be compatible
        -: 7453:   with other systems.
        -: 7454:
        -: 7455:   LONGOPTS is a vector of `struct option' terminated by an
        -: 7456:   element containing a name which is zero.
        -: 7457:
        -: 7458:   LONGIND returns the index in LONGOPT of the long-named option found.
        -: 7459:   It is only valid when a long-named option has been found by the most
        -: 7460:   recent call.
        -: 7461:
        -: 7462:   If LONG_ONLY is nonzero, '-' as well as '--' can introduce
        -: 7463:   long-named options.  */
        -: 7464:
        -: 7465:int
        -: 7466:_getopt_internal (argc, argv, optstring, longopts, longind, long_only)
        -: 7467:     int argc;
        -: 7468:     char *const *argv;
        -: 7469:     const char *optstring;
        -: 7470:     const struct option *longopts;
        -: 7471:     int *longind;
        -: 7472:     int long_only;
        -: 7473:{
        -: 7474:  int option_index;
        -: 7475:
        -: 7476:  optarg = 0;
        -: 7477:
        -: 7478:  /* Initialize the internal data when the first call is made.
        -: 7479:     Start processing options with ARGV-element 1 (since ARGV-element 0
        -: 7480:     is the program name); the sequence of previously skipped
        -: 7481:     non-option ARGV-elements is empty.  */
        -: 7482:
        -: 7483:  if (optind == 0)
        -: 7484:    {
        -: 7485:      first_nonopt = last_nonopt = optind = 1;
        -: 7486:
        -: 7487:      nextchar = NULL;
        -: 7488:
        -: 7489:      /* Determine how to handle the ordering of options and nonoptions.  */
        -: 7490:
        -: 7491:      if (optstring[0] == '-')
        -: 7492:	{
        -: 7493:	  ordering = RETURN_IN_ORDER;
        -: 7494:	  ++optstring;
        -: 7495:	}
        -: 7496:      else if (optstring[0] == '+')
        -: 7497:	{
        -: 7498:	  ordering = REQUIRE_ORDER;
        -: 7499:	  ++optstring;
        -: 7500:	}
        -: 7501:      else if (getenv ("POSIXLY_CORRECT") != NULL)
        -: 7502:	ordering = REQUIRE_ORDER;
        -: 7503:      else
        -: 7504:	ordering = PERMUTE;
        -: 7505:    }
        -: 7506:
        -: 7507:  if (nextchar == NULL || *nextchar == '\0')
        -: 7508:    {
        -: 7509:      if (ordering == PERMUTE)
        -: 7510:	{
        -: 7511:	  /* If we have just processed some options following some non-options,
        -: 7512:	     exchange them so that the options come first.  */
        -: 7513:
        -: 7514:	  if (first_nonopt != last_nonopt && last_nonopt != optind)
        -: 7515:	    exchange ((char **) argv);
        -: 7516:	  else if (last_nonopt != optind)
        -: 7517:	    first_nonopt = optind;
        -: 7518:
        -: 7519:	  /* Now skip any additional non-options
        -: 7520:	     and extend the range of non-options previously skipped.  */
        -: 7521:
        -: 7522:	  while (optind < argc
        -: 7523:		 && (argv[optind][0] != '-' || argv[optind][1] == '\0')
        -: 7524:#ifdef GETOPT_COMPAT
        -: 7525:		 && (longopts == NULL
        -: 7526:		     || argv[optind][0] != '+' || argv[optind][1] == '\0')
        -: 7527:#endif				/* GETOPT_COMPAT */
        -: 7528:		 )
        -: 7529:	    optind++;
        -: 7530:	  last_nonopt = optind;
        -: 7531:	}
        -: 7532:
        -: 7533:      /* Special ARGV-element `--' means premature end of options.
        -: 7534:	 Skip it like a null option,
        -: 7535:	 then exchange with previous non-options as if it were an option,
        -: 7536:	 then skip everything else like a non-option.  */
        -: 7537:
        -: 7538:      if (optind != argc && !strcmp (argv[optind], "--"))
        -: 7539:	{
        -: 7540:	  optind++;
        -: 7541:
        -: 7542:	  if (first_nonopt != last_nonopt && last_nonopt != optind)
        -: 7543:	    exchange ((char **) argv);
        -: 7544:	  else if (first_nonopt == last_nonopt)
        -: 7545:	    first_nonopt = optind;
        -: 7546:	  last_nonopt = argc;
        -: 7547:
        -: 7548:	  optind = argc;
        -: 7549:	}
        -: 7550:
        -: 7551:      /* If we have done all the ARGV-elements, stop the scan
        -: 7552:	 and back over any non-options that we skipped and permuted.  */
        -: 7553:
        -: 7554:      if (optind == argc)
        -: 7555:	{
        -: 7556:	  /* Set the next-arg-index to point at the non-options
        -: 7557:	     that we previously skipped, so the caller will digest them.  */
        -: 7558:	  if (first_nonopt != last_nonopt)
        -: 7559:	    optind = first_nonopt;
        -: 7560:	  return EOF;
        -: 7561:	}
        -: 7562:
        -: 7563:      /* If we have come to a non-option and did not permute it,
        -: 7564:	 either stop the scan or describe it to the caller and pass it by.  */
        -: 7565:
        -: 7566:      if ((argv[optind][0] != '-' || argv[optind][1] == '\0')
        -: 7567:#ifdef GETOPT_COMPAT
        -: 7568:	  && (longopts == NULL
        -: 7569:	      || argv[optind][0] != '+' || argv[optind][1] == '\0')
        -: 7570:#endif				/* GETOPT_COMPAT */
        -: 7571:	  )
        -: 7572:	{
        -: 7573:	  if (ordering == REQUIRE_ORDER)
        -: 7574:	    return EOF;
        -: 7575:	  optarg = argv[optind++];
        -: 7576:	  return 1;
        -: 7577:	}
        -: 7578:
        -: 7579:      /* We have found another option-ARGV-element.
        -: 7580:	 Start decoding its characters.  */
        -: 7581:
        -: 7582:      nextchar = (argv[optind] + 1
        -: 7583:		  + (longopts != NULL && argv[optind][1] == '-'));
        -: 7584:    }
        -: 7585:
        -: 7586:  if (longopts != NULL
        -: 7587:      && ((argv[optind][0] == '-'
        -: 7588:	   && (argv[optind][1] == '-' || long_only))
        -: 7589:#ifdef GETOPT_COMPAT
        -: 7590:	  || argv[optind][0] == '+'
        -: 7591:#endif				/* GETOPT_COMPAT */
        -: 7592:	  ))
        -: 7593:    {
        -: 7594:      const struct option *p;
        -: 7595:      char *s = nextchar;
        -: 7596:      int exact = 0;
        -: 7597:      int ambig = 0;
        -: 7598:      const struct option *pfound = NULL;
        -: 7599:      int indfound;
        -: 7600:
        -: 7601:      while (*s && *s != '=')
        -: 7602:	s++;
        -: 7603:
        -: 7604:      /* Test all options for either exact match or abbreviated matches.  */
        -: 7605:      for (p = longopts, option_index = 0; p->name;
        -: 7606:	   p++, option_index++)
        -: 7607:	if (!strncmp (p->name, nextchar, s - nextchar))
        -: 7608:	  {
        -: 7609:	    if (s - nextchar == strlen (p->name))
        -: 7610:	      {
        -: 7611:		/* Exact match found.  */
        -: 7612:		pfound = p;
        -: 7613:		indfound = option_index;
        -: 7614:		exact = 1;
        -: 7615:		break;
        -: 7616:	      }
        -: 7617:	    else if (pfound == NULL)
        -: 7618:	      {
        -: 7619:		/* First nonexact match found.  */
        -: 7620:		pfound = p;
        -: 7621:		indfound = option_index;
        -: 7622:	      }
        -: 7623:	    else
        -: 7624:	      /* Second nonexact match found.  */
        -: 7625:	      ambig = 1;
        -: 7626:	  }
        -: 7627:
        -: 7628:      if (ambig && !exact)
        -: 7629:	{
        -: 7630:	  if (opterr)
        -: 7631:	    fprintf (stderr, "%s: option `%s' is ambiguous\n",
        -: 7632:		     myname, argv[optind]);
        -: 7633:	  nextchar += strlen (nextchar);
        -: 7634:	  optind++;
        -: 7635:	  return '?';
        -: 7636:	}
        -: 7637:
        -: 7638:      if (pfound != NULL)
        -: 7639:	{
        -: 7640:	  option_index = indfound;
        -: 7641:	  optind++;
        -: 7642:	  if (*s)
        -: 7643:	    {
        -: 7644:	      /* Don't test has_arg with >, because some C compilers don't
        -: 7645:		 allow it to be used on enums.  */
        -: 7646:	      if (pfound->has_arg)
        -: 7647:		optarg = s + 1;
        -: 7648:	      else
        -: 7649:		{
        -: 7650:		  if (opterr)
        -: 7651:		    {
        -: 7652:		      if (argv[optind - 1][1] == '-')
        -: 7653:			/* --option */
        -: 7654:			fprintf (stderr,
        -: 7655:				 "%s: option `--%s' doesn't allow an argument\n",
        -: 7656:				 myname, pfound->name);
        -: 7657:		      else
        -: 7658:			/* +option or -option */
        -: 7659:			fprintf (stderr,
        -: 7660:			     "%s: option `%c%s' doesn't allow an argument\n",
        -: 7661:			     myname, argv[optind - 1][0], pfound->name);
        -: 7662:		    }
        -: 7663:		  nextchar += strlen (nextchar);
        -: 7664:		  return '?';
        -: 7665:		}
        -: 7666:	    }
        -: 7667:	  else if (pfound->has_arg == 1)
        -: 7668:	    {
        -: 7669:	      if (optind < argc)
        -: 7670:		optarg = argv[optind++];
        -: 7671:	      else
        -: 7672:		{
        -: 7673:		  if (opterr)
        -: 7674:		    fprintf (stderr, "%s: option `%s' requires an argument\n",
        -: 7675:			     myname, argv[optind - 1]);
        -: 7676:		  nextchar += strlen (nextchar);
        -: 7677:		  return optstring[0] == ':' ? ':' : '?';
        -: 7678:		}
        -: 7679:	    }
        -: 7680:	  nextchar += strlen (nextchar);
        -: 7681:	  if (longind != NULL)
        -: 7682:	    *longind = option_index;
        -: 7683:	  if (pfound->flag)
        -: 7684:	    {
        -: 7685:	      *(pfound->flag) = pfound->val;
        -: 7686:	      return 0;
        -: 7687:	    }
        -: 7688:	  return pfound->val;
        -: 7689:	}
        -: 7690:      /* Can't find it as a long option.  If this is not getopt_long_only,
        -: 7691:	 or the option starts with '--' or is not a valid short
        -: 7692:	 option, then it's an error.
        -: 7693:	 Otherwise interpret it as a short option.  */
        -: 7694:      if (!long_only || argv[optind][1] == '-'
        -: 7695:#ifdef GETOPT_COMPAT
        -: 7696:	  || argv[optind][0] == '+'
        -: 7697:#endif				/* GETOPT_COMPAT */
        -: 7698:	  || my_index (optstring, *nextchar) == NULL)
        -: 7699:	{
        -: 7700:	  if (opterr)
        -: 7701:	    {
        -: 7702:	      if (argv[optind][1] == '-')
        -: 7703:		/* --option */
        -: 7704:		fprintf (stderr, "%s: unrecognized option `--%s'\n",
        -: 7705:			 myname, nextchar);
        -: 7706:	      else
        -: 7707:		/* +option or -option */
        -: 7708:		fprintf (stderr, "%s: unrecognized option `%c%s'\n",
        -: 7709:			 myname, argv[optind][0], nextchar);
        -: 7710:	    }
        -: 7711:	  nextchar = (char *) "";
        -: 7712:	  optind++;
        -: 7713:	  return '?';
        -: 7714:	}
        -: 7715:    }
        -: 7716:
        -: 7717:  /* Look at and handle the next option-character.  */
        -: 7718:
        -: 7719:  {
        -: 7720:    char c = *nextchar++;
        -: 7721:    char *temp = my_index (optstring, c);
        -: 7722:
        -: 7723:    /* Increment `optind' when we start to process its last character.  */
        -: 7724:    if (*nextchar == '\0')
        -: 7725:      ++optind;
        -: 7726:
        -: 7727:    if (temp == NULL || c == ':')
        -: 7728:      {
        -: 7729:	if (opterr)
        -: 7730:	  {
        -: 7731:#if 0
        -: 7732:	    if (c < 040 || c >= 0177)
        -: 7733:	      fprintf (stderr, "%s: unrecognized option, character code 0%o\n",
        -: 7734:		       myname, c);
        -: 7735:	    else
        -: 7736:	      fprintf (stderr, "%s: unrecognized option `-%c'\n", myname, c);
        -: 7737:#else
        -: 7738:	    /* 1003.2 specifies the format of this message.  */
        -: 7739:	    fprintf (stderr, "%s: illegal option -- %c\n", myname, c);
        -: 7740:#endif
        -: 7741:	  }
        -: 7742:	optopt = c;
        -: 7743:	return '?';
        -: 7744:      }
        -: 7745:    if (temp[1] == ':')
        -: 7746:      {
        -: 7747:	if (temp[2] == ':')
        -: 7748:	  {
        -: 7749:	    /* This is an option that accepts an argument optionally.  */
        -: 7750:	    if (*nextchar != '\0')
        -: 7751:	      {
        -: 7752:		optarg = nextchar;
        -: 7753:		optind++;
        -: 7754:	      }
        -: 7755:	    else
        -: 7756:	      optarg = 0;
        -: 7757:	    nextchar = NULL;
        -: 7758:	  }
        -: 7759:	else
        -: 7760:	  {
        -: 7761:	    /* This is an option that requires an argument.  */
        -: 7762:	    if (*nextchar != '\0')
        -: 7763:	      {
        -: 7764:		optarg = nextchar;
        -: 7765:		/* If we end this ARGV-element by taking the rest as an arg,
        -: 7766:		   we must advance to the next element now.  */
        -: 7767:		optind++;
        -: 7768:	      }
        -: 7769:	    else if (optind == argc)
        -: 7770:	      {
        -: 7771:		if (opterr)
        -: 7772:		  {
        -: 7773:#if 0
        -: 7774:		    fprintf (stderr, "%s: option `-%c' requires an argument\n",
        -: 7775:			     myname, c);
        -: 7776:#else
        -: 7777:		    /* 1003.2 specifies the format of this message.  */
        -: 7778:		    fprintf (stderr, "%s: option requires an argument -- %c\n",
        -: 7779:			     myname, c);
        -: 7780:#endif
        -: 7781:		  }
        -: 7782:		optopt = c;
        -: 7783:		if (optstring[0] == ':')
        -: 7784:		  c = ':';
        -: 7785:		else
        -: 7786:		  c = '?';
        -: 7787:	      }
        -: 7788:	    else
        -: 7789:	      /* We already incremented `optind' once;
        -: 7790:		 increment it again when taking next ARGV-elt as argument.  */
        -: 7791:	      optarg = argv[optind++];
        -: 7792:	    nextchar = NULL;
        -: 7793:	  }
        -: 7794:      }
        -: 7795:    return c;
        -: 7796:  }
        -: 7797:}
        -: 7798:
        -: 7799:int
        -: 7800:getopt (argc, argv, optstring)
        -: 7801:     int argc;
        -: 7802:     char *const *argv;
        -: 7803:     const char *optstring;
        -: 7804:{
        -: 7805:  return _getopt_internal (argc, argv, optstring,
        -: 7806:			   (const struct option *) 0,
        -: 7807:			   (int *) 0,
        -: 7808:			   0);
        -: 7809:}
        -: 7810:
        -: 7811:#endif	/* _LIBC or not __GNU_LIBRARY__.  */
        -: 7812:
        -: 7813:#ifdef TEST
        -: 7814:
        -: 7815:/* Compile with -DTEST to make an executable for use in testing
        -: 7816:   the above definition of `getopt'.  */
        -: 7817:
        -: 7818:int
        -: 7819:main (argc, argv)
        -: 7820:     int argc;
        -: 7821:     char **argv;
        -: 7822:{
        -: 7823:  int c;
        -: 7824:  int digit_optind = 0;
        -: 7825:
        -: 7826:  while (1)
        -: 7827:    {
        -: 7828:      int this_option_optind = optind ? optind : 1;
        -: 7829:
        -: 7830:      c = getopt (argc, argv, "abc:d:0123456789");
        -: 7831:      if (c == EOF)
        -: 7832:	break;
        -: 7833:
        -: 7834:      switch (c)
        -: 7835:	{
        -: 7836:	case '0':
        -: 7837:	case '1':
        -: 7838:	case '2':
        -: 7839:	case '3':
        -: 7840:	case '4':
        -: 7841:	case '5':
        -: 7842:	case '6':
        -: 7843:	case '7':
        -: 7844:	case '8':
        -: 7845:	case '9':
        -: 7846:	  if (digit_optind != 0 && digit_optind != this_option_optind)
        -: 7847:	    printf ("digits occur in two different argv-elements.\n");
        -: 7848:	  digit_optind = this_option_optind;
        -: 7849:	  printf ("option %c\n", c);
        -: 7850:	  break;
        -: 7851:
        -: 7852:	case 'a':
        -: 7853:	  printf ("option a\n");
        -: 7854:	  break;
        -: 7855:
        -: 7856:	case 'b':
        -: 7857:	  printf ("option b\n");
        -: 7858:	  break;
        -: 7859:
        -: 7860:	case 'c':
        -: 7861:	  printf ("option c with value `%s'\n", optarg);
        -: 7862:	  break;
        -: 7863:
        -: 7864:	case '?':
        -: 7865:	  break;
        -: 7866:
        -: 7867:	default:
        -: 7868:	  printf ("?? getopt returned character code 0%o ??\n", c);
        -: 7869:	}
        -: 7870:    }
        -: 7871:
        -: 7872:  if (optind < argc)
        -: 7873:    {
        -: 7874:      printf ("non-option ARGV-elements: ");
        -: 7875:      while (optind < argc)
        -: 7876:	printf ("%s ", argv[optind++]);
        -: 7877:      printf ("\n");
        -: 7878:    }
        -: 7879:
        -: 7880:  exit (0);
        -: 7881:}
        -: 7882:
        -: 7883:#endif /* TEST */
        -: 7884:/* getopt_long and getopt_long_only entry points for GNU getopt.
        -: 7885:   Copyright (C) 1987, 88, 89, 90, 91, 92, 1993
        -: 7886:	Free Software Foundation, Inc.
        -: 7887:
        -: 7888:   This program is free software; you can redistribute it and/or modify it
        -: 7889:   under the terms of the GNU General Public License as published by the
        -: 7890:   Free Software Foundation; either version 2, or (at your option) any
        -: 7891:   later version.
        -: 7892:
        -: 7893:   This program is distributed in the hope that it will be useful,
        -: 7894:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 7895:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 7896:   GNU General Public License for more details.
        -: 7897:
        -: 7898:   You should have received a copy of the GNU General Public License
        -: 7899:   along with this program; if not, write to the Free Software
        -: 7900:   Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
        -: 7901:
        -: 7902:#ifdef HAVE_CONFIG_H
        -: 7903:#include "config.h"
        -: 7904:#endif
        -: 7905:
        -: 7906:#include "getopt.h"
        -: 7907:
        -: 7908:#if !__STDC__ && !defined(const) && IN_GCC
        -: 7909:#define const
        -: 7910:#endif
        -: 7911:
        -: 7912:#include <stdio.h>
        -: 7913:
        -: 7914:/* Comment out all this code if we are using the GNU C Library, and are not
        -: 7915:   actually compiling the library itself.  This code is part of the GNU C
        -: 7916:   Library, but also included in many other GNU distributions.  Compiling
        -: 7917:   and linking in this code is a waste when using the GNU C library
        -: 7918:   (especially if it is a shared library).  Rather than having every GNU
        -: 7919:   program understand `configure --with-gnu-libc' and omit the object files,
        -: 7920:   it is simpler to just do this in the source for each such file.  */
        -: 7921:
        -: 7922:#if defined (_LIBC) || !defined (__GNU_LIBRARY__)
        -: 7923:
        -: 7924:
        -: 7925:/* This needs to come after some library #include
        -: 7926:   to get __GNU_LIBRARY__ defined.  */
        -: 7927:#ifdef __GNU_LIBRARY__
        -: 7928:#include <stdlib.h>
        -: 7929:#else
        -: 7930:char *getenv ();
        -: 7931:#endif
        -: 7932:
        -: 7933:#ifndef	NULL
        -: 7934:#define NULL 0
        -: 7935:#endif
        -: 7936:
        -: 7937:int
        -: 7938:getopt_long (argc, argv, options, long_options, opt_index)
        -: 7939:     int argc;
        -: 7940:     char *const *argv;
        -: 7941:     const char *options;
        -: 7942:     const struct option *long_options;
        -: 7943:     int *opt_index;
        -: 7944:{
        -: 7945:  return _getopt_internal (argc, argv, options, long_options, opt_index, 0);
        -: 7946:}
        -: 7947:
        -: 7948:/* Like getopt_long, but '-' as well as '--' can indicate a long option.
        -: 7949:   If an option that starts with '-' (not '--') doesn't match a long option,
        -: 7950:   but does match a short option, it is parsed as a short option
        -: 7951:   instead.  */
        -: 7952:
        -: 7953:int
        -: 7954:getopt_long_only (argc, argv, options, long_options, opt_index)
        -: 7955:     int argc;
        -: 7956:     char *const *argv;
        -: 7957:     const char *options;
        -: 7958:     const struct option *long_options;
        -: 7959:     int *opt_index;
        -: 7960:{
        -: 7961:  return _getopt_internal (argc, argv, options, long_options, opt_index, 1);
        -: 7962:}
        -: 7963:
        -: 7964:
        -: 7965:#endif	/* _LIBC or not __GNU_LIBRARY__.  */
        -: 7966:
        -: 7967:#ifdef TEST
        -: 7968:
        -: 7969:#include <stdio.h>
        -: 7970:
        -: 7971:int
        -: 7972:main (argc, argv)
        -: 7973:     int argc;
        -: 7974:     char **argv;
        -: 7975:{
        -: 7976:  int c;
        -: 7977:  int digit_optind = 0;
        -: 7978:
        -: 7979:  while (1)
        -: 7980:    {
        -: 7981:      int this_option_optind = optind ? optind : 1;
        -: 7982:      int option_index = 0;
        -: 7983:      static struct option long_options[] =
        -: 7984:      {
        -: 7985:	{"add", 1, 0, 0},
        -: 7986:	{"append", 0, 0, 0},
        -: 7987:	{"delete", 1, 0, 0},
        -: 7988:	{"verbose", 0, 0, 0},
        -: 7989:	{"create", 0, 0, 0},
        -: 7990:	{"file", 1, 0, 0},
        -: 7991:	{0, 0, 0, 0}
        -: 7992:      };
        -: 7993:
        -: 7994:      c = getopt_long (argc, argv, "abc:d:0123456789",
        -: 7995:		       long_options, &option_index);
        -: 7996:      if (c == EOF)
        -: 7997:	break;
        -: 7998:
        -: 7999:      switch (c)
        -: 8000:	{
        -: 8001:	case 0:
        -: 8002:	  printf ("option %s", long_options[option_index].name);
        -: 8003:	  if (optarg)
        -: 8004:	    printf (" with arg %s", optarg);
        -: 8005:	  printf ("\n");
        -: 8006:	  break;
        -: 8007:
        -: 8008:	case '0':
        -: 8009:	case '1':
        -: 8010:	case '2':
        -: 8011:	case '3':
        -: 8012:	case '4':
        -: 8013:	case '5':
        -: 8014:	case '6':
        -: 8015:	case '7':
        -: 8016:	case '8':
        -: 8017:	case '9':
        -: 8018:	  if (digit_optind != 0 && digit_optind != this_option_optind)
        -: 8019:	    printf ("digits occur in two different argv-elements.\n");
        -: 8020:	  digit_optind = this_option_optind;
        -: 8021:	  printf ("option %c\n", c);
        -: 8022:	  break;
        -: 8023:
        -: 8024:	case 'a':
        -: 8025:	  printf ("option a\n");
        -: 8026:	  break;
        -: 8027:
        -: 8028:	case 'b':
        -: 8029:	  printf ("option b\n");
        -: 8030:	  break;
        -: 8031:
        -: 8032:	case 'c':
        -: 8033:	  printf ("option c with value `%s'\n", optarg);
        -: 8034:	  break;
        -: 8035:
        -: 8036:	case 'd':
        -: 8037:	  printf ("option d with value `%s'\n", optarg);
        -: 8038:	  break;
        -: 8039:
        -: 8040:	case '?':
        -: 8041:	  break;
        -: 8042:
        -: 8043:	default:
        -: 8044:	  printf ("?? getopt returned character code 0%o ??\n", c);
        -: 8045:	}
        -: 8046:    }
        -: 8047:
        -: 8048:  if (optind < argc)
        -: 8049:    {
        -: 8050:      printf ("non-option ARGV-elements: ");
        -: 8051:      while (optind < argc)
        -: 8052:	printf ("%s ", argv[optind++]);
        -: 8053:      printf ("\n");
        -: 8054:    }
        -: 8055:
        -: 8056:  exit (0);
        -: 8057:}
        -: 8058:
        -: 8059:#endif /* TEST */
