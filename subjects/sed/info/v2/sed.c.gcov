        -:    0:Source:sed.c
        -:    0:Graph:sed.gcno
        -:    0:Data:sed.gcda
        -:    0:Runs:191
        -:    1:#define STDC_HEADERS 1
        -:    2:#define HAVE_STRING_H 1
        -:    3:#define HAVE_VPRINTF 1
        -:    4:#define HAVE_BCOPY 1
        -:    5:#define HAVE_MEMCPY 1
        -:    6:#define HAVE_ALLOCA_H 1
        -:    7:
        -:    8:/*  GNU SED, a batch stream editor.
        -:    9:    Copyright (C) 1989, 1990, 1991 Free Software Foundation, Inc.
        -:   10:
        -:   11:    This program is free software; you can redistribute it and/or modify
        -:   12:    it under the terms of the GNU General Public License as published by
        -:   13:    the Free Software Foundation; either version 2, or (at your option)
        -:   14:    any later version.
        -:   15:
        -:   16:    This program is distributed in the hope that it will be useful,
        -:   17:    but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   18:    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   19:    GNU General Public License for more details.
        -:   20:
        -:   21:    You should have received a copy of the GNU General Public License
        -:   22:    along with this program; if not, write to the Free Software
        -:   23:    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
        -:   24:    
        -:   25:/* All The occurences of argv[0] are changed to myname to remove nondeterminism
        -:   26:by Amit Goel on August 30 2001 */
        -:   27:
        -:   28:#ifdef __STDC__
        -:   29:#define VOID void
        -:   30:#else
        -:   31:#define VOID char
        -:   32:#endif
        -:   33:
        -:   34:
        -:   35:#define _GNU_SOURCE
        -:   36:#include <ctype.h>
        -:   37:#ifndef isblank
        -:   38:#define isblank(c) ((c) == ' ' || (c) == '\t')
        -:   39:#endif
        -:   40:#include <stdio.h>
        -:   41:
        -:   42:#undef stderr
        -:   43:#define stderr stdout
        -:   44:
        -:   45:#include <sys/types.h>
        -:   46:#include "rx.h"
        -:   47:#include "getopt.h"
        -:   48:#include "FaultSeeds.h"
        -:   49:#if defined(STDC_HEADERS)
        -:   50:#include <stdlib.h>
        -:   51:#endif
        -:   52:#if HAVE_STRING_H || defined(STDC_HEADERS)
        -:   53:#include <string.h>
        -:   54:#ifndef bzero
        -:   55:#define bzero(s, n)	memset ((s), 0, (n))
        -:   56:#endif
        -:   57:#if !defined(STDC_HEADERS)
        -:   58:#include <memory.h>
        -:   59:#endif
        -:   60:#else
        -:   61:#include <strings.h>
        -:   62:#endif
        -:   63:
        -:   64:#ifdef RX_MEMDBUG
        -:   65:#include <malloc.h>
        -:   66:#endif
        -:   67:
        -:   68:#include <errno.h>
        -:   69:
        -:   70:#ifndef HAVE_BCOPY
        -:   71:#ifdef HAVE_MEMCPY
        -:   72:#define bcopy(FROM,TO,LEN)  memcpy(TO,FROM,LEN)
        -:   73:#else
        -:   74:void
        -:   75:bcopy (from, to, len)
        -:   76:     char *from;
        -:   77:     char *to;
        -:   78:     int len;
        -:   79:{
        -:   80:  if (from < to)
        -:   81:    {
        -:   82:      from += len - 1;
        -:   83:      to += len - 1;
        -:   84:      while (len--)
        -:   85:	*to-- = *from--;
        -:   86:    }
        -:   87:  else
        -:   88:    while (len--)
        -:   89:      *to++ = *from++;
        -:   90:}
        -:   91:
        -:   92:#endif
        -:   93:#endif
        -:   94:
        -:   95:char *version_string = "GNU sed version 2.05";
        -:   96:
        -:   97:/* Struct vector is used to describe a chunk of a compiled sed program.  
        -:   98: * There is one vector for the main program, and one for each { } pair,
        -:   99: * and one for the entire program.  For {} blocks, RETURN_[VI] tells where
        -:  100: * to continue execution after this VECTOR.
        -:  101: */
        -:  102:
        -:  103:struct vector
        -:  104:{
        -:  105:  struct sed_cmd *v;
        -:  106:  int v_length;
        -:  107:  int v_allocated;
        -:  108:  struct vector *return_v;
        -:  109:  int return_i;
        -:  110:};
        -:  111:
        -:  112:
        -:  113:/* Goto structure is used to hold both GOTO's and labels.  There are two
        -:  114: * separate lists, one of goto's, called 'jumps', and one of labels, called
        -:  115: * 'labels'.
        -:  116: * the V element points to the descriptor for the program-chunk in which the
        -:  117: * goto was encountered.
        -:  118: * the v_index element counts which element of the vector actually IS the
        -:  119: * goto/label.  The first element of the vector is zero.
        -:  120: * the NAME element is the null-terminated name of the label.
        -:  121: * next is the next goto/label in the list. 
        -:  122: */
        -:  123:
        -:  124:struct sed_label
        -:  125:{
        -:  126:  struct vector *v;
        -:  127:  int v_index;
        -:  128:  char *name;
        -:  129:  struct sed_label *next;
        -:  130:};
        -:  131:
        -:  132:/* ADDR_TYPE is zero for a null address,
        -:  133: *  one if addr_number is valid, or
        -:  134: * two if addr_regex is valid,
        -:  135: * three, if the address is '$'
        -:  136: * Other values are undefined.
        -:  137: */
        -:  138:
        -:  139:enum addr_types
        -:  140:{
        -:  141:  addr_is_null = 0,
        -:  142:  addr_is_num = 1,
        -:  143:  addr_is_regex = 2,
        -:  144:  addr_is_last = 3,
        -:  145:  addr_is_mod = 4
        -:  146:};
        -:  147:
        -:  148:struct addr
        -:  149:{
        -:  150:  int addr_type;
        -:  151:  struct re_pattern_buffer *addr_regex;
        -:  152:  int addr_number;
        -:  153:  int modulo, offset;
        -:  154:};
        -:  155:
        -:  156:
        -:  157:/* Aflags:  If the low order bit is set, a1 has been
        -:  158: * matched; apply this command until a2 matches.
        -:  159: * If the next bit is set, apply this command to all
        -:  160: * lines that DON'T match the address(es).
        -:  161: */
        -:  162:
        -:  163:#define A1_MATCHED_BIT	01
        -:  164:#define ADDR_BANG_BIT	02
        -:  165:
        -:  166:struct sed_cmd
        -:  167:{
        -:  168:  struct addr a1, a2;
        -:  169:  int aflags;
        -:  170:  
        -:  171:  char cmd;
        -:  172:  
        -:  173:  union
        -:  174:    {
        -:  175:      /* This structure is used for a, i, and c commands */
        -:  176:      struct
        -:  177:	{
        -:  178:	  char *text;
        -:  179:	  int text_len;
        -:  180:	}
        -:  181:      cmd_txt;
        -:  182:      
        -:  183:      /* This is used for b and t commands */
        -:  184:      struct sed_cmd *label;
        -:  185:      
        -:  186:      /* This for r and w commands */
        -:  187:      FILE *io_file;
        -:  188:      
        -:  189:      /* This for the hairy s command */
        -:  190:      /* For the flags var:
        -:  191:	 low order bit means the 'g' option was given,
        -:  192:	 next bit means the 'p' option was given,
        -:  193:	 and the next bit means a 'w' option was given,
        -:  194:	 and wio_file contains the file to write to. */
        -:  195:      
        -:  196:#define S_GLOBAL_BIT	01
        -:  197:#define S_PRINT_BIT	02
        -:  198:#define S_WRITE_BIT	04
        -:  199:#define S_NUM_BIT	010
        -:  200:      
        -:  201:      struct
        -:  202:	{
        -:  203:	  struct re_pattern_buffer *regx;
        -:  204:	  char *replacement;
        -:  205:	  int replace_length;
        -:  206:	  int flags;
        -:  207:	  int numb;
        -:  208:	  FILE *wio_file;
        -:  209:	}
        -:  210:      cmd_regex;
        -:  211:      
        -:  212:      /* This for the y command */
        -:  213:      unsigned char *translate;
        -:  214:      
        -:  215:      /* For { */
        -:  216:      struct vector *sub;
        -:  217:      
        -:  218:      /* for t and b */
        -:  219:      struct sed_label *jump;
        -:  220:    } x;
        -:  221:};
        -:  222:
        -:  223:/* Sed operates a line at a time. */
        -:  224:struct line
        -:  225:{
        -:  226:  char *text;			/* Pointer to line allocated by malloc. */
        -:  227:  int length;			/* Length of text. */
        -:  228:  int alloc;			/* Allocated space for text. */
        -:  229:};
        -:  230:
        -:  231:/* This structure holds information about files opend by the 'r', 'w',
        -:  232:   and 's///w' commands.  In paticular, it holds the FILE pointers to
        -:  233:   use, the file's name. */
        -:  234:
        -:  235:#define NUM_FPS	32
        -:  236:struct
        -:  237:  {
        -:  238:    FILE *for_read;
        -:  239:    FILE *for_write;
        -:  240:    char *name;
        -:  241:  }
        -:  242:
        -:  243:file_ptrs[NUM_FPS];
        -:  244:
        -:  245:
        -:  246:#if defined(__STDC__)
        -:  247:# define P_(s) s
        -:  248:#else
        -:  249:# define P_(s) ()
        -:  250:#endif
        -:  251:
        -:  252:void close_files ();
        -:  253:void panic P_ ((char *str,...));
        -:  254:char *__fp_name P_ ((FILE * fp));
        -:  255:FILE *ck_fopen P_ ((char *name, char *mode));
        -:  256:void ck_fwrite P_ ((char *ptr, int size, int nmemb, FILE * stream));
        -:  257:void ck_fclose P_ ((FILE * stream));
        -:  258:VOID *ck_malloc P_ ((int size));
        -:  259:VOID *ck_realloc P_ ((VOID * ptr, int size));
        -:  260:char *ck_strdup P_ ((char *str));
        -:  261:VOID *init_buffer P_ ((void));
        -:  262:void flush_buffer P_ ((VOID * bb));
        -:  263:int size_buffer P_ ((VOID * b));
        -:  264:void add_buffer P_ ((VOID * bb, char *p, int n));
        -:  265:void add1_buffer P_ ((VOID * bb, int ch));
        -:  266:char *get_buffer P_ ((VOID * bb));
        -:  267:
        -:  268:void compile_string P_ ((char *str));
        -:  269:void compile_file P_ ((char *str));
        -:  270:struct vector *compile_program P_ ((struct vector * vector, int));
        -:  271:void bad_prog P_ ((char *why));
        -:  272:int inchar P_ ((void));
        -:  273:void savchar P_ ((int ch));
        -:  274:int compile_address P_ ((struct addr * addr));
        -:  275:char * last_regex_string = 0;
        -:  276:void buffer_regex  P_ ((int slash));
        -:  277:void compile_regex P_ ((void));
        -:  278:struct sed_label *setup_jump P_ ((struct sed_label * list, struct sed_cmd * cmd, struct vector * vec));
        -:  279:FILE *compile_filename P_ ((int readit));
        -:  280:void read_file P_ ((char *name));
        -:  281:void execute_program P_ ((struct vector * vec));
        -:  282:int match_address P_ ((struct addr * addr));
        -:  283:int read_pattern_space P_ ((void));
        -:  284:void append_pattern_space P_ ((void));
        -:  285:void line_copy P_ ((struct line * from, struct line * to));
        -:  286:void line_append P_ ((struct line * from, struct line * to));
        -:  287:void str_append P_ ((struct line * to, char *string, int length));
        -:  288:void usage P_ ((int));
        -:  289:
        -:  290:extern char *myname;
        -:  291:
        -:  292:/* If set, don't write out the line unless explictly told to */
        -:  293:int no_default_output = 0;
        -:  294:
        -:  295:/* Current input line # */
        -:  296:int input_line_number = 0;
        -:  297:
        -:  298:/* Are we on the last input file? */
        -:  299:int last_input_file = 0;
        -:  300:
        -:  301:/* Have we hit EOF on the last input file?  This is used to decide if we
        -:  302:   have hit the '$' address yet. */
        -:  303:int input_EOF = 0;
        -:  304:
        -:  305:/* non-zero if a quit command has been executed. */
        -:  306:int quit_cmd = 0;
        -:  307:
        -:  308:/* Have we done any replacements lately?  This is used by the 't' command. */
        -:  309:int replaced = 0;
        -:  310:
        -:  311:/* How many '{'s are we executing at the moment */
        -:  312:int program_depth = 0;
        -:  313:
        -:  314:/* The complete compiled SED program that we are going to run */
        -:  315:struct vector *the_program = 0;
        -:  316:
        -:  317:/* information about labels and jumps-to-labels.  This is used to do
        -:  318:   the required backpatching after we have compiled all the scripts. */
        -:  319:struct sed_label *jumps = 0;
        -:  320:struct sed_label *labels = 0;
        -:  321:
        -:  322:/* The 'current' input line. */
        -:  323:struct line line;
        -:  324:
        -:  325:/* An input line that's been stored by later use by the program */
        -:  326:struct line hold;
        -:  327:
        -:  328:/* A 'line' to append to the current line when it comes time to write it out */
        -:  329:struct line append;
        -:  330:
        -:  331:
        -:  332:/* When we're reading a script command from a string, 'prog_start' and
        -:  333:   'prog_end' point to the beginning and end of the string.  This
        -:  334:   would allow us to compile script strings that contain nulls, except
        -:  335:   that script strings are only read from the command line, which is
        -:  336:   null-terminated */
        -:  337:unsigned char *prog_start;
        -:  338:unsigned char *prog_end;
        -:  339:
        -:  340:/* When we're reading a script command from a string, 'prog_cur' points
        -:  341:   to the current character in the string */
        -:  342:unsigned char *prog_cur;
        -:  343:
        -:  344:/* This is the name of the current script file.
        -:  345:   It is used for error messages. */
        -:  346:char *prog_name;
        -:  347:
        -:  348:/* This is the current script file.  If it is zero, we are reading
        -:  349:   from a string stored in 'prog_start' instead.  If both 'prog_file'
        -:  350:   and 'prog_start' are zero, we're in trouble! */
        -:  351:FILE *prog_file;
        -:  352:
        -:  353:/* this is the number of the current script line that we're compiling.  It is
        -:  354:   used to give out useful and informative error messages. */
        -:  355:int prog_line = 1;
        -:  356:
        -:  357:/* This is the file pointer that we're currently reading data from.  It may
        -:  358:   be stdin */
        -:  359:FILE *input_file;
        -:  360:
        -:  361:/* If this variable is non-zero at exit, one or more of the input
        -:  362:   files couldn't be opened. */
        -:  363:
        -:  364:int bad_input = 0;
        -:  365:
        -:  366:/* 'an empty regular expression is equivalent to the last regular
        -:  367:   expression read' so we have to keep track of the last regex used.
        -:  368:   Here's where we store a pointer to it (it is only malloc()'d once) */
        -:  369:struct re_pattern_buffer *last_regex;
        -:  370:
        -:  371:/* Various error messages we may want to print */
        -:  372:static char ONE_ADDR[] = "Command only uses one address";
        -:  373:static char NO_ADDR[] = "Command doesn't take any addresses";
        -:  374:static char LINE_JUNK[] = "Extra characters after command";
        -:  375:static char BAD_EOF[] = "Unexpected End-of-file";
        -:  376:static char NO_REGEX[] = "No previous regular expression";
        -:  377:static char NO_COMMAND[] = "Missing command";
        -:  378:
        -:  379:static struct option longopts[] =
        -:  380:{
        -:  381:  {"expression", 1, NULL, 'e'},
        -:  382:  {"file", 1, NULL, 'f'},
        -:  383:  {"quiet", 0, NULL, 'n'},
        -:  384:  {"silent", 0, NULL, 'n'},
        -:  385:  {"version", 0, NULL, 'V'},
        -:  386:  {"help", 0, NULL, 'h'},
        -:  387:  {NULL, 0, NULL, 0}
        -:  388:};
        -:  389:
        -:  390:int
function main called 191 returned 0% blocks executed 88%
      191:  391:main (argc, argv)
        -:  392:     int argc;
        -:  393:     char **argv;
        -:  394:{
        -:  395:  int opt;
      191:  396:  char *e_strings = NULL;
      191:  397:  int compiled = 0;
        -:  398:  struct sed_label *go, *lbl;
        -:  399:
        -:  400:  /* see regex.h */
      191:  401:  re_set_syntax (RE_SYNTAX_POSIX_BASIC);
call    0 returned 191
      191:  402:  rx_cache_bound = 4096;	/* Consume memory rampantly. */
        -:  403: /* Commented by Amit Goel on 30th August 2001 to remove Nondeterminism */ 
        -:  404: /* myname = argv[0]; */
        -:  405: /* Added By Amit Goel 30th August 2001 */
      191:  406: myname = "Executable";
      372:  407:  while ((opt = getopt_long (argc, argv, "hne:f:V", longopts, (int *) 0))
call    0 returned 372
      372:  408:	 != EOF)
branch  0 taken 193
branch  1 taken 179 (fallthrough)
        -:  409:    {
      193:  410:      switch (opt)
branch  0 taken 6
branch  1 taken 16
branch  2 taken 162
branch  3 taken 2
branch  4 taken 0
branch  5 taken 7
        -:  411:	{
        6:  412:	case 'n':
        6:  413:	  no_default_output = 1;
        6:  414:	  break;
       16:  415:	case 'e':
       16:  416:	  if (e_strings == NULL)
branch  0 taken 15 (fallthrough)
branch  1 taken 1
        -:  417:	    {
       15:  418:	      e_strings = ck_malloc (strlen (optarg) + 2);
call    0 returned 15
       15:  419:	      strcpy (e_strings, optarg);
        -:  420:	    }
        -:  421:	  else
        -:  422:	    {
        1:  423:	      e_strings = ck_realloc (e_strings, strlen (e_strings) + strlen (optarg) + 2);
call    0 returned 1
        1:  424:	      strcat (e_strings, optarg);
        -:  425:	    }
       16:  426:	  strcat (e_strings, "\n");
       16:  427:	  compiled = 1;
       16:  428:	  break;
      162:  429:	case 'f':
      162:  430:	  if (e_strings)
branch  0 taken 0 (fallthrough)
branch  1 taken 162
        -:  431:	    {
    #####:  432:	      compile_string (e_strings);
call    0 never executed
        -:  433:	 #ifndef FAULTY_F_AG_1
    #####:  434:	      free (e_strings);
        -:  435:	 #endif
    #####:  436:	      e_strings = 0;
        -:  437:	    }
      162:  438:	  compile_file (optarg);
call    0 returned 159
      159:  439:	  compiled = 1;
      159:  440:	  break;
        2:  441:	case 'V':
        2:  442:	  fprintf (stderr, "%s\n", version_string);
call    0 returned 2
        2:  443:	  exit (0);
call    0 returned 0
        -:  444:	  break;
    #####:  445:	case 'h':
    #####:  446:	  usage (0);
call    0 never executed
    #####:  447:	  break;
        7:  448:	default:
        7:  449:	  usage (4);
call    0 returned 0
    #####:  450:	  break;
        -:  451:	}
        -:  452:    }
      179:  453:  if (e_strings)
branch  0 taken 15 (fallthrough)
branch  1 taken 164
        -:  454:    {
       15:  455:      compile_string (e_strings);
call    0 returned 15
       15:  456:      free (e_strings);
        -:  457:    }
      179:  458:  if (!compiled)
branch  0 taken 5 (fallthrough)
branch  1 taken 174
        -:  459:    {
        5:  460:      if (optind == argc)
branch  0 taken 0 (fallthrough)
branch  1 taken 5
    #####:  461:	usage (4);
call    0 never executed
        5:  462:      compile_string (argv[optind++]);
call    0 returned 0
        -:  463:    }
        -:  464:
      177:  465:  for (go = jumps; go; go = go->next)
branch  0 taken 3
branch  1 taken 174 (fallthrough)
        -:  466:    {
        4:  467:      for (lbl = labels; lbl; lbl = lbl->next)
branch  0 taken 3
branch  1 taken 1 (fallthrough)
        3:  468:	if (!strcmp (lbl->name, go->name))
branch  0 taken 2 (fallthrough)
branch  1 taken 1
        2:  469:	  break;
        3:  470:      if (*go->name && !lbl)
branch  0 taken 2 (fallthrough)
branch  1 taken 1
branch  2 taken 0 (fallthrough)
branch  3 taken 2
    #####:  471:	panic ("Can't find label for jump to '%s'", go->name);
call    0 never executed
        3:  472:      go->v->v[go->v_index].x.jump = lbl;
        -:  473:    }
        -:  474:
      174:  475:  line.length = 0;
      174:  476:  line.alloc = 50;
      174:  477:  line.text = ck_malloc (50);
call    0 returned 174
        -:  478:
      174:  479:  append.length = 0;
      174:  480:  append.alloc = 50;
      174:  481:  append.text = ck_malloc (50);
call    0 returned 174
        -:  482:
      174:  483:  hold.length = 1;
      174:  484:  hold.alloc = 50;
      174:  485:  hold.text = ck_malloc (50);
call    0 returned 174
      174:  486:  hold.text[0] = '\n';
        -:  487:
      174:  488:  if (argc <= optind)
branch  0 taken 1 (fallthrough)
branch  1 taken 173
        -:  489:    {
        1:  490:      last_input_file++;
        1:  491:      read_file ("-");
call    0 returned 1
        -:  492:    }
        -:  493:  else
      310:  494:    while (optind < argc)
branch  0 taken 174
branch  1 taken 136 (fallthrough)
        -:  495:      {
      174:  496:	if (optind == argc - 1)
branch  0 taken 173 (fallthrough)
branch  1 taken 1
      173:  497:	  last_input_file++;
      174:  498:	read_file (argv[optind]);
call    0 returned 174
      174:  499:	optind++;
      174:  500:	if (quit_cmd)
branch  0 taken 37 (fallthrough)
branch  1 taken 137
       37:  501:	  break;
        -:  502:      }
      174:  503:  close_files ();
call    0 returned 174
      174:  504:  if (bad_input)
branch  0 taken 1 (fallthrough)
branch  1 taken 173
        1:  505:    exit (2);
call    0 returned 0
      173:  506:  exit (0);
        -:  507:}
        -:  508:
        -:  509:void
function close_files called 174 returned 100% blocks executed 88%
      174:  510:close_files ()
        -:  511:{
        -:  512:  int nf;
        -:  513:
     5742:  514:  for (nf = 0; nf < NUM_FPS; nf++)
branch  0 taken 5568
branch  1 taken 174 (fallthrough)
        -:  515:    {
     5568:  516:      if (file_ptrs[nf].for_write)
branch  0 taken 70 (fallthrough)
branch  1 taken 5498
       70:  517:	fclose (file_ptrs[nf].for_write);
call    0 returned 70
     5568:  518:      if (file_ptrs[nf].for_read)
branch  0 taken 0 (fallthrough)
branch  1 taken 5568
    #####:  519:	fclose (file_ptrs[nf].for_read);
call    0 never executed
        -:  520:    }
      174:  521:}
        -:  522:
        -:  523:/* 'str' is a string (from the command line) that contains a sed command.
        -:  524:   Compile the command, and add it to the end of 'the_program' */
        -:  525:void
function compile_string called 20 returned 75% blocks executed 100%
       20:  526:compile_string (str)
        -:  527:     char *str;
        -:  528:{
       20:  529:  prog_file = 0;
       20:  530:  prog_line = 0;
       20:  531:  prog_start = prog_cur = (unsigned char *)str;
       20:  532:  prog_end = (unsigned char *)str + strlen (str);
       20:  533:  the_program = compile_program (the_program, prog_line);
call    0 returned 15
       15:  534:}
        -:  535:
        -:  536:/* 'str' is the name of a file containing sed commands.  Read them in
        -:  537:   and add them to the end of 'the_program' */
        -:  538:void
function compile_file called 162 returned 98% blocks executed 86%
      162:  539:compile_file (str)
        -:  540:     char *str;
        -:  541:{
        -:  542:  int ch;
        -:  543:
      162:  544:  prog_start = prog_cur = prog_end = 0;
      162:  545:  prog_name = str;
      162:  546:  prog_line = 1;
     162*:  547:  if (str[0] == '-' && str[1] == '\0')
branch  0 taken 0 (fallthrough)
branch  1 taken 162
branch  2 never executed
branch  3 never executed
    #####:  548:    prog_file = stdin;
        -:  549:  else
      162:  550:    prog_file = ck_fopen (str, "r");
call    0 returned 160
      160:  551:  ch = getc (prog_file);
call    0 returned 160
      160:  552:  if (ch == '#')
branch  0 taken 154 (fallthrough)
branch  1 taken 6
        -:  553:    {
      154:  554:      ch = getc (prog_file);
call    0 returned 154
      154:  555:      if (ch == 'n')
branch  0 taken 89 (fallthrough)
branch  1 taken 65
       89:  556:	no_default_output++;
     1240:  557:      while (ch != EOF && ch != '\n')
branch  0 taken 1240 (fallthrough)
branch  1 taken 0
branch  2 taken 1086
branch  3 taken 154 (fallthrough)
        -:  558:	{
     1086:  559:	  ch = getc (prog_file);
call    0 returned 1086
     1086:  560:	  if (ch == '\\')
branch  0 taken 0 (fallthrough)
branch  1 taken 1086
    #####:  561:	    ch = getc (prog_file);
call    0 never executed
        -:  562:	}
      154:  563:      ++prog_line;
        -:  564:    }
        6:  565:  else if (ch != EOF)
branch  0 taken 6 (fallthrough)
branch  1 taken 0
        6:  566:    ungetc (ch, prog_file);
call    0 returned 6
      160:  567:  the_program = compile_program (the_program, prog_line);
call    0 returned 159
      159:  568:}
        -:  569:
        -:  570:#define MORE_CMDS 40
        -:  571:
        -:  572:/* Read a program (or a subprogram within '{' '}' pairs) in and store
        -:  573:   the compiled form in *'vector'  Return a pointer to the new vector.  */
        -:  574:struct vector *
function compile_program called 322 returned 98% blocks executed 78%
      322:  575:compile_program (vector, open_line)
        -:  576:     struct vector *vector;
        -:  577:     int open_line;
        -:  578:{
        -:  579:  struct sed_cmd *cur_cmd;
      322:  580:  int ch = 0;
        -:  581:  int pch;
        -:  582:  int slash;
        -:  583:  VOID *b;
        -:  584:  unsigned char *string;
        -:  585:  int num;
        -:  586:
      322:  587:  if (!vector)
branch  0 taken 0 (fallthrough)
branch  1 taken 322
        -:  588:    {
      322:  589:      vector = (struct vector *) ck_malloc (sizeof (struct vector));
call    0 returned 322
      322:  590:      vector->v = (struct sed_cmd *) ck_malloc (MORE_CMDS * sizeof (struct sed_cmd));
call    0 returned 322
      322:  591:      vector->v_allocated = MORE_CMDS;
      322:  592:      vector->v_length = 0;
      322:  593:      vector->return_v = 0;
      322:  594:      vector->return_i = 0;
        -:  595:    }
        -:  596:  for (;;)
        -:  597:    {
     322*:  598:    skip_comment:
        -:  599:      do
        -:  600:	{
     3695:  601:	  pch = ch;
     3695:  602:	  ch = inchar ();
call    0 returned 3695
    3695*:  603:	  if ((pch == '\\') && (ch == '\n'))
branch  0 taken 0 (fallthrough)
branch  1 taken 3695
branch  2 never executed
branch  3 never executed
    #####:  604:	    ch = inchar ();
call    0 never executed
        -:  605:	}
     3695:  606:      while (ch != EOF && (isblank (ch) || ch == '\n' || ch == ';'));
branch  0 taken 3520 (fallthrough)
branch  1 taken 175
branch  2 taken 2049
branch  3 taken 1471 (fallthrough)
branch  4 taken 502
branch  5 taken 969 (fallthrough)
branch  6 taken 0
branch  7 taken 969 (fallthrough)
     1144:  607:      if (ch == EOF)
branch  0 taken 175 (fallthrough)
branch  1 taken 969
      175:  608:	break;
      969:  609:      savchar (ch);
call    0 returned 969
        -:  610:
      969:  611:      if (vector->v_length == vector->v_allocated)
branch  0 taken 0 (fallthrough)
branch  1 taken 969
        -:  612:	{
    #####:  613:	  vector->v = ((struct sed_cmd *)
    #####:  614:		       ck_realloc ((VOID *) vector->v,
    #####:  615:				   ((vector->v_length + MORE_CMDS)
call    0 never executed
        -:  616:				    * sizeof (struct sed_cmd))));
    #####:  617:	  vector->v_allocated += MORE_CMDS;
        -:  618:	}
      969:  619:      cur_cmd = vector->v + vector->v_length;
      969:  620:      vector->v_length++;
        -:  621:
      969:  622:      cur_cmd->a1.addr_type = 0;
      969:  623:      cur_cmd->a2.addr_type = 0;
      969:  624:      cur_cmd->aflags = 0;
      969:  625:      cur_cmd->cmd = 0;
        -:  626:
      969:  627:      if (compile_address (&(cur_cmd->a1)))
call    0 returned 969
branch  1 taken 202 (fallthrough)
branch  2 taken 767
        -:  628:	{
      202:  629:	  ch = inchar ();
call    0 returned 202
      202:  630:	  if (ch == ',')
branch  0 taken 37 (fallthrough)
branch  1 taken 165
        -:  631:	    {
        -:  632:	      do
       37:  633:		ch = inchar ();
call    0 returned 37
       37:  634:	      while (ch != EOF && isblank (ch));
branch  0 taken 37 (fallthrough)
branch  1 taken 0
branch  2 taken 0
branch  3 taken 37 (fallthrough)
       37:  635:	      savchar (ch);
call    0 returned 37
       37:  636:	      if (compile_address (&(cur_cmd->a2)))
call    0 returned 37
branch  1 taken 0 (fallthrough)
branch  2 taken 37
        -:  637:		;
        -:  638:	      else
    #####:  639:		bad_prog ("Unexpected ','");
call    0 never executed
        -:  640:	    }
        -:  641:	  else
      165:  642:	    savchar (ch);
call    0 returned 165
        -:  643:	}
      969:  644:      if (cur_cmd->a1.addr_type == addr_is_num
branch  0 taken 56 (fallthrough)
branch  1 taken 913
       56:  645:	  && cur_cmd->a2.addr_type == addr_is_num
branch  0 taken 16 (fallthrough)
branch  1 taken 40
       16:  646:	  && cur_cmd->a2.addr_number < cur_cmd->a1.addr_number)
branch  0 taken 0 (fallthrough)
branch  1 taken 16
    #####:  647:	cur_cmd->a2.addr_number = cur_cmd->a1.addr_number;
        -:  648:
      969:  649:      ch = inchar ();
call    0 returned 969
      969:  650:      if (ch == EOF)
branch  0 taken 969 (fallthrough)
branch  1 taken 0
    #####:  651:	bad_prog (NO_COMMAND);
call    0 never executed
      969:  652:    new_cmd:
      975:  653:      switch (ch)
branch  0 taken 78
branch  1 taken 6
branch  2 taken 36
branch  3 taken 14
branch  4 taken 142
branch  5 taken 141
branch  6 taken 2
branch  7 taken 3
branch  8 taken 26
branch  9 taken 405
branch 10 taken 0
branch 11 taken 22
branch 12 taken 78
branch 13 taken 17
branch 14 taken 5
        -:  654:	{
       78:  655:	case '#':
       78:  656:	  if (cur_cmd->a1.addr_type != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 78
    #####:  657:	    bad_prog (NO_ADDR);
call    0 never executed
        -:  658:	  do
        -:  659:	    {
     1654:  660:	      ch = inchar ();
call    0 returned 1654
        -:  661:	      #ifndef FAULTY_F_AG_17
     1654:  662:	      if (ch == '\\')
branch  0 taken 0 (fallthrough)
branch  1 taken 1654
        -:  663:	      #endif
    #####:  664:		ch = inchar ();
call    0 never executed
        -:  665:	    }
     1654:  666:	  while (ch != EOF && ch != '\n');
branch  0 taken 1654 (fallthrough)
branch  1 taken 0
branch  2 taken 1576
branch  3 taken 78 (fallthrough)
       78:  667:	  vector->v_length--;
       78:  668:	  goto skip_comment;
        6:  669:	case '!':
        6:  670:	  if (cur_cmd->aflags & ADDR_BANG_BIT)
branch  0 taken 0 (fallthrough)
branch  1 taken 6
    #####:  671:	    bad_prog ("Multiple '!'s");
call    0 never executed
        6:  672:	  cur_cmd->aflags |= ADDR_BANG_BIT;
        -:  673:	  do
        6:  674:	    ch = inchar ();
call    0 returned 6
        6:  675:	  while (ch != EOF && isblank (ch));
branch  0 taken 6 (fallthrough)
branch  1 taken 0
branch  2 taken 0
branch  3 taken 6 (fallthrough)
        6:  676:	  if (ch == EOF)
branch  0 taken 0 (fallthrough)
branch  1 taken 6
    #####:  677:	    bad_prog (NO_COMMAND);
call    0 never executed
        -:  678:#if 0
        -:  679:	  savchar (ch);
        -:  680:#endif
        6:  681:	  goto new_cmd;
       36:  682:	case 'a':
        -:  683:	case 'i':
       36:  684:	  if (cur_cmd->a2.addr_type != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 36
    #####:  685:	    bad_prog (ONE_ADDR);
call    0 never executed
        -:  686:	  /* Fall Through */
        -:  687:	case 'c':
       50:  688:	  cur_cmd->cmd = ch;
       50:  689:	  if (inchar () != '\\' || inchar () != '\n')
call    0 returned 50
branch  1 taken 50 (fallthrough)
branch  2 taken 0
call    3 returned 50
branch  4 taken 0 (fallthrough)
branch  5 taken 50
    #####:  690:	    bad_prog (LINE_JUNK);
call    0 never executed
       50:  691:	  b = init_buffer ();
call    0 returned 50
     1099:  692:	  while ((ch = inchar ()) != EOF && ch != '\n')
call    0 returned 1099
branch  1 taken 1099 (fallthrough)
branch  2 taken 0
branch  3 taken 1049
branch  4 taken 50 (fallthrough)
        -:  693:	    {
     1049:  694:	      if (ch == '\\')
branch  0 taken 7 (fallthrough)
branch  1 taken 1042
        7:  695:		ch = inchar ();
call    0 returned 7
     1049:  696:	      add1_buffer (b, ch);
call    0 returned 1049
        -:  697:	    }
       50:  698:	  if (ch != EOF)
branch  0 taken 50 (fallthrough)
branch  1 taken 0
       50:  699:	    add1_buffer (b, ch);
call    0 returned 50
       50:  700:	  num = size_buffer (b);
call    0 returned 50
       50:  701:	  string = (unsigned char *) ck_malloc (num);
call    0 returned 50
       50:  702:	  bcopy (get_buffer (b), string, num);
call    0 returned 50
       50:  703:	  flush_buffer (b);
call    0 returned 50
       50:  704:	  cur_cmd->x.cmd_txt.text_len = num;
       50:  705:	  cur_cmd->x.cmd_txt.text = (char *) string;
       50:  706:	  break;
      142:  707:	case '{':
      142:  708:	  cur_cmd->cmd = ch;
      142:  709:	  program_depth++;
        -:  710:#if 0
        -:  711:	  while ((ch = inchar ()) != EOF && ch != '\n')
        -:  712:	    if (!isblank (ch))
        -:  713:	      bad_prog (LINE_JUNK);
        -:  714:#endif
      142:  715:	  cur_cmd->x.sub = compile_program ((struct vector *) 0, prog_line);
call    0 returned 141
        -:  716:	  /* FOO JF is this the right thing to do?
        -:  717:			   almost.  don't forget a return addr.  -t */
      141:  718:	  cur_cmd->x.sub->return_v = vector;
      141:  719:	  cur_cmd->x.sub->return_i = vector->v_length - 1;
      141:  720:	  break;
      141:  721:	case '}':
      141:  722:	  if (!program_depth)
branch  0 taken 0 (fallthrough)
branch  1 taken 141
    #####:  723:	    bad_prog ("Unexpected '}'");
call    0 never executed
      141:  724:	  --program_depth;
        -:  725:	  /* a return insn for subprograms -t */
      141:  726:	  cur_cmd->cmd = ch;
      141:  727:	  if (cur_cmd->a1.addr_type != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 141
    #####:  728:	    bad_prog ("} doesn't want any addresses");
call    0 never executed
      146:  729:	  while ((ch = inchar ()) != EOF && ch != '\n' && ch != ';')
call    0 returned 146
branch  1 taken 146 (fallthrough)
branch  2 taken 0
branch  3 taken 5 (fallthrough)
branch  4 taken 141
branch  5 taken 5
branch  6 taken 0 (fallthrough)
        5:  730:	    if (!isblank (ch))
branch  0 taken 0 (fallthrough)
branch  1 taken 5
    #####:  731:	      bad_prog (LINE_JUNK);
call    0 never executed
      141:  732:	  return vector;
        2:  733:	case ':':
        2:  734:	  cur_cmd->cmd = ch;
        2:  735:	  if (cur_cmd->a1.addr_type != 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####:  736:	    bad_prog (": doesn't want any addresses");
call    0 never executed
        2:  737:	  labels = setup_jump (labels, cur_cmd, vector);
call    0 returned 2
        2:  738:	  break;
        3:  739:	case 'b':
        -:  740:	case 't':
        3:  741:	  cur_cmd->cmd = ch;
        3:  742:	  jumps = setup_jump (jumps, cur_cmd, vector);
call    0 returned 3
        3:  743:	  break;
       26:  744:	case 'q':
        -:  745:	case '=':
       26:  746:	  if (cur_cmd->a2.addr_type)
branch  0 taken 0 (fallthrough)
branch  1 taken 26
    #####:  747:	    bad_prog (ONE_ADDR);
call    0 never executed
        -:  748:	  /* Fall Through */
        -:  749:	case 'd':
        -:  750:	case 'D':
        -:  751:	case 'g':
        -:  752:	case 'G':
        -:  753:	case 'h':
        -:  754:	case 'H':
        -:  755:	case 'l':
        -:  756:	case 'n':
        -:  757:	case 'N':
        -:  758:	case 'p':
        -:  759:	case 'P':
        -:  760:	case 'x':
      431:  761:	  cur_cmd->cmd = ch;
        -:  762:	  do
      442:  763:	    ch = inchar ();
call    0 returned 442
      442:  764:	  while (ch != EOF && isblank (ch) && ch != '\n' && ch != ';');
branch  0 taken 442 (fallthrough)
branch  1 taken 0
branch  2 taken 11 (fallthrough)
branch  3 taken 431
branch  4 taken 11 (fallthrough)
branch  5 taken 0
branch  6 taken 11
branch  7 taken 0 (fallthrough)
     431*:  765:	  if (ch != '\n' && ch != ';' && ch != EOF)
branch  0 taken 50 (fallthrough)
branch  1 taken 381
branch  2 taken 0 (fallthrough)
branch  3 taken 50
branch  4 never executed
branch  5 never executed
    #####:  766:	    bad_prog (LINE_JUNK);
call    0 never executed
      431:  767:	  break;
        -:  768:
    #####:  769:	case 'r':
    #####:  770:	  if (cur_cmd->a2.addr_type != 0)
branch  0 never executed
branch  1 never executed
    #####:  771:	    bad_prog (ONE_ADDR);
call    0 never executed
        -:  772:	  /* FALL THROUGH */
        -:  773:	case 'w':
       22:  774:	  cur_cmd->cmd = ch;
       22:  775:	  cur_cmd->x.io_file = compile_filename (ch == 'r');
call    0 returned 22
       22:  776:	  break;
        -:  777:
       78:  778:	case 's':
       78:  779:	  cur_cmd->cmd = ch;
       78:  780:	  slash = inchar ();
call    0 returned 78
       78:  781:	  buffer_regex (slash);
call    0 returned 78
       78:  782:	  compile_regex ();
call    0 returned 78
        -:  783:
       78:  784:	  cur_cmd->x.cmd_regex.regx = last_regex;
        -:  785:
       78:  786:	  b = init_buffer ();
call    0 returned 78
      474:  787:	  while (((ch = inchar ()) != EOF) && (ch != slash) && (ch != '\n'))
call    0 returned 474
branch  1 taken 474 (fallthrough)
branch  2 taken 0
branch  3 taken 396 (fallthrough)
branch  4 taken 78
branch  5 taken 396
branch  6 taken 0 (fallthrough)
        -:  788:	    {
      396:  789:	      if (ch == '\\')
branch  0 taken 20 (fallthrough)
branch  1 taken 376
        -:  790:		{
        -:  791:		  int ci;
        -:  792:
       20:  793:		  ci = inchar ();
call    0 returned 20
       20:  794:		  if (ci != EOF)
branch  0 taken 20 (fallthrough)
branch  1 taken 0
        -:  795:		    {
       20:  796:		      if (ci != '\n')
branch  0 taken 20 (fallthrough)
branch  1 taken 0
       20:  797:			add1_buffer (b, ch);
call    0 returned 20
       20:  798:		      add1_buffer (b, ci);
call    0 returned 20
        -:  799:		    }
        -:  800:		}
        -:  801:	      else
      376:  802:		add1_buffer (b, ch);
call    0 returned 376
        -:  803:	    }
       78:  804:	  if (ch != slash)
branch  0 taken 0 (fallthrough)
branch  1 taken 78
        -:  805:	    {
    #####:  806:	      if (ch == '\n' && prog_line > 1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  807:		--prog_line;
    #####:  808:	      bad_prog ("Unterminated `s' command");
call    0 never executed
        -:  809:	    }
       78:  810:	  cur_cmd->x.cmd_regex.replace_length = size_buffer (b);
call    0 returned 78
       78:  811:	  cur_cmd->x.cmd_regex.replacement = ck_malloc (cur_cmd->x.cmd_regex.replace_length);
call    0 returned 78
       78:  812:	  bcopy (get_buffer (b), cur_cmd->x.cmd_regex.replacement, cur_cmd->x.cmd_regex.replace_length);
call    0 returned 78
       78:  813:	  flush_buffer (b);
call    0 returned 78
        -:  814:
       78:  815:	  cur_cmd->x.cmd_regex.flags = 0;
       78:  816:	  cur_cmd->x.cmd_regex.numb = 0;
        -:  817:
       78:  818:	  if (ch == EOF)
branch  0 taken 0 (fallthrough)
branch  1 taken 78
    #####:  819:	    break;
        -:  820:	  do
        -:  821:	    {
      169:  822:	      ch = inchar ();
call    0 returned 169
        -:  823:	      switch (ch)
        -:  824:		{
       28:  825:		case 'p':
       28:  826:		  if (cur_cmd->x.cmd_regex.flags & S_PRINT_BIT)
branch  0 taken 0 (fallthrough)
branch  1 taken 28
    #####:  827:		    bad_prog ("multiple 'p' options to 's' command");
call    0 never executed
       28:  828:		  cur_cmd->x.cmd_regex.flags |= S_PRINT_BIT;
       28:  829:		  break;
       63:  830:		case 'g':
       63:  831:		  if (cur_cmd->x.cmd_regex.flags & S_NUM_BIT)
branch  0 taken 0 (fallthrough)
branch  1 taken 63
    #####:  832:		    cur_cmd->x.cmd_regex.flags &= ~S_NUM_BIT;
       63:  833:		  if (cur_cmd->x.cmd_regex.flags & S_GLOBAL_BIT)
branch  0 taken 0 (fallthrough)
branch  1 taken 63
    #####:  834:		    bad_prog ("multiple 'g' options to 's' command");
call    0 never executed
       63:  835:		  cur_cmd->x.cmd_regex.flags |= S_GLOBAL_BIT;
       63:  836:		  break;
       48:  837:		case 'w':
       48:  838:		  cur_cmd->x.cmd_regex.flags |= S_WRITE_BIT;
       48:  839:		  cur_cmd->x.cmd_regex.wio_file = compile_filename (0);
call    0 returned 48
       48:  840:		  ch = '\n';
       48:  841:		  break;
    #####:  842:		case '0':
        -:  843:		case '1':
        -:  844:		case '2':
        -:  845:		case '3':
        -:  846:		case '4':
        -:  847:		case '5':
        -:  848:		case '6':
        -:  849:		case '7':
        -:  850:		case '8':
        -:  851:		case '9':
    #####:  852:		  if (cur_cmd->x.cmd_regex.flags & S_NUM_BIT)
branch  0 never executed
branch  1 never executed
    #####:  853:		    bad_prog ("multiple number options to 's' command");
call    0 never executed
    #####:  854:		  if ((cur_cmd->x.cmd_regex.flags & S_GLOBAL_BIT) == 0)
branch  0 never executed
branch  1 never executed
    #####:  855:		    cur_cmd->x.cmd_regex.flags |= S_NUM_BIT;
    #####:  856:		  num = 0;
    #####:  857:		  while (isdigit (ch))
branch  0 never executed
branch  1 never executed
        -:  858:		    {
    #####:  859:		      num = num * 10 + ch - '0';
    #####:  860:		      ch = inchar ();
call    0 never executed
        -:  861:		    }
    #####:  862:		  savchar (ch);
call    0 never executed
    #####:  863:		  cur_cmd->x.cmd_regex.numb = num;
    #####:  864:		  break;
       30:  865:		case '\n':
        -:  866:		case ';':
        -:  867:		case EOF:
       30:  868:		  break;
    #####:  869:		default:
    #####:  870:		  bad_prog ("Unknown option to 's'");
call    0 never executed
    #####:  871:		  break;
        -:  872:		}
        -:  873:	    }
      169:  874:	  while (ch != EOF && ch != '\n' && ch != ';');
branch  0 taken 169 (fallthrough)
branch  1 taken 0
branch  2 taken 92 (fallthrough)
branch  3 taken 77
branch  4 taken 91
branch  5 taken 1 (fallthrough)
       78:  875:	  if (ch == EOF)
branch  0 taken 0 (fallthrough)
branch  1 taken 78
    #####:  876:	    break;
       78:  877:	  break;
        -:  878:
       17:  879:	case 'y':
       17:  880:	  cur_cmd->cmd = ch;
       17:  881:	  string = (unsigned char *) ck_malloc (256);
call    0 returned 17
     4369:  882:	  for (num = 0; num < 256; num++)
branch  0 taken 4352
branch  1 taken 17 (fallthrough)
     4352:  883:	    string[num] = num;
       17:  884:	  b = init_buffer ();
call    0 returned 17
       17:  885:	  slash = inchar ();
call    0 returned 17
      149:  886:	  while ((ch = inchar ()) != EOF && ch != slash)
call    0 returned 149
branch  1 taken 149 (fallthrough)
branch  2 taken 0
branch  3 taken 132
branch  4 taken 17 (fallthrough)
      132:  887:	    add1_buffer (b, ch);
call    0 returned 132
       17:  888:	  cur_cmd->x.translate = string;
       17:  889:	  string = (unsigned char *) get_buffer (b);
call    0 returned 17
      149:  890:	  for (num = size_buffer (b); num; --num)
call    0 returned 17
branch  1 taken 132
branch  2 taken 17 (fallthrough)
        -:  891:	    {
      132:  892:	      ch = inchar ();
call    0 returned 132
      132:  893:	      if (ch == EOF)
branch  0 taken 0 (fallthrough)
branch  1 taken 132
    #####:  894:		bad_prog (BAD_EOF);
call    0 never executed
      132:  895:	      if (ch == slash)
branch  0 taken 0 (fallthrough)
branch  1 taken 132
    #####:  896:		bad_prog ("strings for y command are different lengths");
call    0 never executed
      132:  897:	      cur_cmd->x.translate[*string++] = ch;
        -:  898:	    }
       17:  899:	  flush_buffer (b);
call    0 returned 17
       17:  900:	  if (inchar () != slash || ((ch = inchar ()) != EOF && ch != '\n' && ch != ';'))
call    0 returned 17
branch  1 taken 17 (fallthrough)
branch  2 taken 0
call    3 returned 17
branch  4 taken 17 (fallthrough)
branch  5 taken 0
branch  6 taken 1 (fallthrough)
branch  7 taken 16
branch  8 taken 0 (fallthrough)
branch  9 taken 1
    #####:  901:	    bad_prog (LINE_JUNK);
call    0 never executed
       17:  902:	  break;
        -:  903:
        5:  904:	default:
        5:  905:	  bad_prog ("Unknown command");
call    0 returned 0
        -:  906:	}
        -:  907:    }
      175:  908:  if (program_depth)
branch  0 taken 1 (fallthrough)
branch  1 taken 174
        -:  909:    {
        1:  910:      prog_line = open_line;
        1:  911:      bad_prog ("Unmatched `{'");
call    0 returned 0
        -:  912:    }
      174:  913:  return vector;
        -:  914:}
        -:  915:
        -:  916:/* Complain about a programming error and exit. */
        -:  917:void
function bad_prog called 6 returned 0% blocks executed 100%
        6:  918:bad_prog (why)
        -:  919:     char *why;
        -:  920:{
        6:  921:  if (prog_line > 0)
branch  0 taken 1 (fallthrough)
branch  1 taken 5
        1:  922:    fprintf (stderr, "%s: file %s line %d: %s\n",
call    0 returned 1
        -:  923:	     myname, prog_name, prog_line, why);
        -:  924:  else
        5:  925:    fprintf (stderr, "%s: %s\n", myname, why);
call    0 returned 5
        6:  926:  exit (1);
        -:  927:}
        -:  928:
        -:  929:/* Read the next character from the program.  Return EOF if there isn't
        -:  930:   anything to read.  Keep prog_line up to date, so error messages can
        -:  931:   be meaningful. */
        -:  932:int
function inchar called 12565 returned 100% blocks executed 87%
    12565:  933:inchar ()
        -:  934:{
        -:  935:  int ch;
    12565:  936:  if (prog_file)
branch  0 taken 12253 (fallthrough)
branch  1 taken 312
        -:  937:    {
    12253:  938:      if (feof (prog_file))
call    0 returned 12253
branch  1 taken 0 (fallthrough)
branch  2 taken 12253
    #####:  939:	return EOF;
        -:  940:      else
    12253:  941:	ch = getc (prog_file);
call    0 returned 12253
        -:  942:    }
        -:  943:  else
        -:  944:    {
      312:  945:      if (!prog_cur)
branch  0 taken 0 (fallthrough)
branch  1 taken 312
    #####:  946:	return EOF;
      312:  947:      else if (prog_cur == prog_end)
branch  0 taken 15 (fallthrough)
branch  1 taken 297
        -:  948:	{
       15:  949:	  ch = EOF;
       15:  950:	  prog_cur = 0;
        -:  951:	}
        -:  952:      else
      297:  953:	ch = *prog_cur++;
        -:  954:    }
    12565:  955:  if ((ch == '\n') && prog_line)
branch  0 taken 1322 (fallthrough)
branch  1 taken 11243
branch  2 taken 1306 (fallthrough)
branch  3 taken 16
     1306:  956:    prog_line++;
    12565:  957:  return ch;
        -:  958:}
        -:  959:
        -:  960:/* unget 'ch' so the next call to inchar will return it.  'ch' must not be
        -:  961:   EOF or anything nasty like that. */
        -:  962:void
function savchar called 2226 returned 100% blocks executed 89%
     2226:  963:savchar (ch)
        -:  964:     int ch;
        -:  965:{
     2226:  966:  if (ch == EOF)
branch  0 taken 0 (fallthrough)
branch  1 taken 2226
    #####:  967:    return;
     2226:  968:  if (ch == '\n' && prog_line > 1)
branch  0 taken 5 (fallthrough)
branch  1 taken 2221
branch  2 taken 5 (fallthrough)
branch  3 taken 0
        5:  969:    --prog_line;
     2226:  970:  if (prog_file)
branch  0 taken 2174 (fallthrough)
branch  1 taken 52
     2174:  971:    ungetc (ch, prog_file);
call    0 returned 2174
        -:  972:  else
       52:  973:    *--prog_cur = ch;
        -:  974:}
        -:  975:
        -:  976:
        -:  977:/* Try to read an address for a sed command.  If it succeeeds,
        -:  978:   return non-zero and store the resulting address in *'addr'.
        -:  979:   If the input doesn't look like an address read nothing
        -:  980:   and return zero. */
        -:  981:int
function compile_address called 1006 returned 100% blocks executed 76%
     1006:  982:compile_address (addr)
        -:  983:     struct addr *addr;
        -:  984:{
        -:  985:  int ch;
        -:  986:  int num;
        -:  987:
     1006:  988:  ch = inchar ();
call    0 returned 1006
        -:  989:
     1006:  990:  if (isdigit (ch))
branch  0 taken 73 (fallthrough)
branch  1 taken 933
        -:  991:    {
       73:  992:      num = ch - '0';
      130:  993:      while ((ch = inchar ()) != EOF && isdigit (ch))
call    0 returned 130
branch  1 taken 130 (fallthrough)
branch  2 taken 0
branch  3 taken 57
branch  4 taken 73 (fallthrough)
       57:  994:	num = num * 10 + ch - '0';
        -:  995:  #ifndef FAULTY_F_AG_2	
       73:  996:      if (ch == '~')
branch  0 taken 0 (fallthrough)
branch  1 taken 73
        -:  997:  #else
        -:  998:      if (ch = '~')
        -:  999:  #endif
        -: 1000:	{
    #####: 1001:	  addr->addr_type = addr_is_mod;
    #####: 1002:	  addr->offset = num;
    #####: 1003:	  ch = inchar();
call    0 never executed
    #####: 1004:	  num=0;
        -: 1005:  #ifndef FAULTY_F_AG_3
    #####: 1006:	  if (isdigit(ch)) {
branch  0 never executed
branch  1 never executed
        -: 1007:  #else	
        -: 1008:          if (!isdigit(ch)) { 
        -: 1009:  #endif
        -: 1010:  #ifndef FAULTY_F_AG_18
    #####: 1011:	    num = ch - '0';
        -: 1012:  #else
        -: 1013:  	    num = ch + '0';
        -: 1014:  #endif
    #####: 1015:	    while ((ch = inchar ()) != EOF && isdigit (ch))
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1016:	      num = num * 10 + ch - '0';
    #####: 1017:	    addr->modulo = num;
        -: 1018:	  }
    #####: 1019:	  addr->modulo += (addr->modulo==0);
        -: 1020:	}
        -: 1021:      else
        -: 1022:	{
       73: 1023:	  addr->addr_type = addr_is_num;
       73: 1024:	  addr->addr_number = num;
        -: 1025:	}
       73: 1026:      while (ch != EOF && isblank (ch))
branch  0 taken 73 (fallthrough)
branch  1 taken 0
branch  2 taken 0
branch  3 taken 73 (fallthrough)
    #####: 1027:	ch = inchar ();
call    0 never executed
       73: 1028:      savchar (ch);
call    0 returned 73
       73: 1029:      return 1;
        -: 1030:    }
      933: 1031:  else if (ch == '/' || ch == '\\')
branch  0 taken 779 (fallthrough)
branch  1 taken 154
branch  2 taken 0 (fallthrough)
branch  3 taken 779
        -: 1032:    {
      154: 1033:      addr->addr_type = addr_is_regex;
      154: 1034:      if (ch == '\\')
branch  0 taken 0 (fallthrough)
branch  1 taken 154
    #####: 1035:	ch = inchar ();
call    0 never executed
      154: 1036:      buffer_regex (ch);
call    0 returned 154
        -: 1037:   #ifndef FAULTY_F_AG_19
      154: 1038:      compile_regex ();
call    0 returned 154
        -: 1039:   #endif
      154: 1040:      addr->addr_regex = last_regex;
        -: 1041:      do
      154: 1042:	ch = inchar ();
call    0 returned 154
      154: 1043:      while (ch != EOF && isblank (ch));
branch  0 taken 154 (fallthrough)
branch  1 taken 0
branch  2 taken 0
branch  3 taken 154 (fallthrough)
      154: 1044:      savchar (ch);
call    0 returned 154
      154: 1045:      return 1;
        -: 1046:    }
      779: 1047:  else if (ch == '$')
branch  0 taken 12 (fallthrough)
branch  1 taken 767
        -: 1048:    {
       12: 1049:      addr->addr_type = addr_is_last;
        -: 1050:      do
       12: 1051:	ch = inchar ();
call    0 returned 12
       12: 1052:      while (ch != EOF && isblank (ch));
branch  0 taken 12 (fallthrough)
branch  1 taken 0
branch  2 taken 0
branch  3 taken 12 (fallthrough)
       12: 1053:      savchar (ch);
call    0 returned 12
       12: 1054:      return 1;
        -: 1055:    }
        -: 1056:  else
      767: 1057:    savchar (ch);
call    0 returned 767
      767: 1058:  return 0;
        -: 1059:}
        -: 1060:
        -: 1061:void
function buffer_regex called 232 returned 100% blocks executed 93%
      232: 1062:buffer_regex (slash)
        -: 1063:     int slash;
        -: 1064:{
        -: 1065:  VOID *b;
        -: 1066:  int ch;
      232: 1067:  int char_class_pos = -1;
        -: 1068:
      232: 1069:  b = init_buffer ();
call    0 returned 232
      787: 1070:  while ((ch = inchar ()) != EOF && (ch != slash || (char_class_pos >= 0)))
call    0 returned 787
branch  1 taken 787 (fallthrough)
branch  2 taken 0
branch  3 taken 555
branch  4 taken 232 (fallthrough)
branch  5 taken 0
branch  6 taken 232 (fallthrough)
        -: 1071:    {
      555: 1072:      if (ch == '^')
branch  0 taken 73 (fallthrough)
branch  1 taken 482
        -: 1073:	{
       73: 1074:	  if (size_buffer (b) == 0)
call    0 returned 73
branch  1 taken 72 (fallthrough)
branch  2 taken 1
        -: 1075:	    {
       72: 1076:	      add1_buffer (b, '\\');
call    0 returned 72
       72: 1077:	      add1_buffer (b, '`');
call    0 returned 72
        -: 1078:	    }
        -: 1079:	  else
        1: 1080:	    add1_buffer (b, ch);
call    0 returned 1
       73: 1081:	  continue;
        -: 1082:	}
      482: 1083:      else if (ch == '$')
branch  0 taken 44 (fallthrough)
branch  1 taken 438
        -: 1084:	{
       44: 1085:	  ch = inchar ();
call    0 returned 44
       44: 1086:	  savchar (ch);
call    0 returned 44
       44: 1087:	  if (ch == slash)
branch  0 taken 44 (fallthrough)
branch  1 taken 0
        -: 1088:	    {
       44: 1089:	      add1_buffer (b, '\\');
call    0 returned 44
       44: 1090:	      add1_buffer (b, '\'');
call    0 returned 44
        -: 1091:	    }
        -: 1092:	  else
    #####: 1093:	    add1_buffer (b, '$');
call    0 never executed
       44: 1094:	  continue;
        -: 1095:	}
      438: 1096:      else if (ch == '[')
branch  0 taken 2 (fallthrough)
branch  1 taken 436
        -: 1097:	{
        2: 1098:	  if (char_class_pos < 0)
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2: 1099:	    char_class_pos = size_buffer (b);
call    0 returned 2
        2: 1100:	  add1_buffer (b, ch);
call    0 returned 2
        2: 1101:	  continue;
        -: 1102:	}
      436: 1103:      else if (ch == ']')
branch  0 taken 2 (fallthrough)
branch  1 taken 434
        -: 1104:	{
        2: 1105:	  add1_buffer (b, ch);
call    0 returned 2
        2: 1106:	  {
        2: 1107:	    char * regexp = get_buffer (b);
call    0 returned 2
        2: 1108:	    int pos = size_buffer (b) - 1;
call    0 returned 2
        2: 1109:	    if (!(   (char_class_pos >= 0)
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2: 1110:		  && (   (pos == char_class_pos + 1)
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2: 1111:		      || (   (pos == char_class_pos + 2)
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####: 1112:			  && (regexp[char_class_pos + 1] == '^')))))
branch  0 never executed
branch  1 never executed
        2: 1113:	      char_class_pos = -1;
        2: 1114:	    continue;
        -: 1115:	  }
        -: 1116:	}
      434: 1117:      else if (ch != '\\' || (char_class_pos >= 0))
branch  0 taken 106 (fallthrough)
branch  1 taken 328
branch  2 taken 0 (fallthrough)
branch  3 taken 106
        -: 1118:	{
      328: 1119:	  add1_buffer (b, ch);
call    0 returned 328
      328: 1120:	  continue;
        -: 1121:	}
      106: 1122:      ch = inchar ();
call    0 returned 106
      106: 1123:      switch (ch)
branch  0 taken 4
branch  1 taken 0
branch  2 taken 102
        -: 1124:	{
        4: 1125:	case 'n':
        4: 1126:	  add1_buffer (b, '\n');
call    0 returned 4
        4: 1127:	  break;
        -: 1128:#if 0
        -: 1129:	case 'b':
        -: 1130:	  add1_buffer (b, '\b');
        -: 1131:	  break;
        -: 1132:	case 'f':
        -: 1133:	  add1_buffer (b, '\f');
        -: 1134:	  break;
        -: 1135:	case 'r':
        -: 1136:	  add1_buffer (b, '\r');
        -: 1137:	  break;
        -: 1138:	case 't':
        -: 1139:	  add1_buffer (b, '\t');
        -: 1140:	  break;
        -: 1141:#endif /* 0 */
    #####: 1142:	case EOF:
    #####: 1143:	  break;
      102: 1144:	default:
      102: 1145:	  add1_buffer (b, '\\');
call    0 returned 102
      102: 1146:	  add1_buffer (b, ch);
call    0 returned 102
      102: 1147:	  break;
        -: 1148:	}
        -: 1149:    }
      232: 1150:  if (ch == EOF)
branch  0 taken 0 (fallthrough)
branch  1 taken 232
    #####: 1151:    bad_prog (BAD_EOF);
call    0 never executed
      232: 1152:  if (size_buffer (b))
call    0 returned 232
branch  1 taken 231 (fallthrough)
branch  2 taken 1
        -: 1153:    {
        -: 1154:  #ifndef FAULTY_F_AG_4   
      231: 1155:      if (last_regex_string)
branch  0 taken 105 (fallthrough)
branch  1 taken 126
        -: 1156:  #else
        -: 1157:      if (last_regex)
        -: 1158:  #endif
      105: 1159:	last_regex_string = (char *)ck_realloc (last_regex_string,
call    0 returned 105
      105: 1160:						size_buffer (b) + 1);
call    0 returned 105
        -: 1161:      else
      126: 1162:	last_regex_string = (char *)ck_malloc (size_buffer (b) + 1);
call    0 returned 126
call    1 returned 126
      231: 1163:      bcopy (get_buffer (b), last_regex_string, size_buffer (b));
call    0 returned 231
call    1 returned 231
      231: 1164:      last_regex_string [size_buffer (b)] = 0;
call    0 returned 231
        -: 1165:    }
        1: 1166:  else if (!last_regex)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 1167:    bad_prog (NO_REGEX);
call    0 never executed
      232: 1168:  flush_buffer (b);
call    0 returned 232
      232: 1169:}
        -: 1170:
        -: 1171:void
function compile_regex called 232 returned 100% blocks executed 83%
      232: 1172:compile_regex ()
        -: 1173:{
        -: 1174:  const char * error;
      232: 1175:  last_regex = ((struct re_pattern_buffer *)
      232: 1176:		ck_malloc (sizeof (struct re_pattern_buffer)));
call    0 returned 232
      232: 1177:  bzero (last_regex, sizeof (*last_regex));
        -: 1178:  #ifndef FAULTY_F_AG_20
      232: 1179:  last_regex->fastmap = ck_malloc (256);
call    0 returned 232
        -: 1180:  #else
        -: 1181:  last_regex->fastmap = ck_malloc (206);
        -: 1182:  #endif
      232: 1183:  error = re_compile_pattern (last_regex_string,
      232: 1184:			      strlen (last_regex_string), last_regex);
call    0 returned 232
      232: 1185:  if (error)
branch  0 taken 0 (fallthrough)
branch  1 taken 232
    #####: 1186:    bad_prog ((char *)error);
call    0 never executed
      232: 1187:}
        -: 1188:
        -: 1189:/* Store a label (or label reference) created by a ':', 'b', or 't'
        -: 1190:   comand so that the jump to/from the lable can be backpatched after
        -: 1191:   compilation is complete */
        -: 1192:struct sed_label *
function setup_jump called 5 returned 100% blocks executed 100%
        5: 1193:setup_jump (list, cmd, vec)
        -: 1194:     struct sed_label *list;
        -: 1195:     struct sed_cmd *cmd;
        -: 1196:     struct vector *vec;
        -: 1197:{
        -: 1198:  struct sed_label *tmp;
        -: 1199:  VOID *b;
        -: 1200:  int ch;
        -: 1201:
        5: 1202:  b = init_buffer ();
call    0 returned 5
        7: 1203:  while ((ch = inchar ()) != EOF && isblank (ch))
call    0 returned 7
branch  1 taken 7 (fallthrough)
branch  2 taken 0
branch  3 taken 2
branch  4 taken 5 (fallthrough)
        -: 1204:    ;
        -: 1205:  /* Possible non posixicity. */
       17: 1206:  while (ch != EOF && ch != '\n' && (!isblank (ch)) && ch != ';' && ch != '}')
branch  0 taken 17 (fallthrough)
branch  1 taken 0
branch  2 taken 12 (fallthrough)
branch  3 taken 5
branch  4 taken 12 (fallthrough)
branch  5 taken 0
branch  6 taken 12 (fallthrough)
branch  7 taken 0
branch  8 taken 12
branch  9 taken 0 (fallthrough)
        -: 1207:    {
       12: 1208:      add1_buffer (b, ch);
call    0 returned 12
       12: 1209:      ch = inchar ();
call    0 returned 12
        -: 1210:    }
        5: 1211:  savchar (ch);
call    0 returned 5
        5: 1212:  add1_buffer (b, '\0');
call    0 returned 5
        5: 1213:  tmp = (struct sed_label *) ck_malloc (sizeof (struct sed_label));
call    0 returned 5
        5: 1214:  tmp->v = vec;
        5: 1215:  tmp->v_index = cmd - vec->v;
        5: 1216:  tmp->name = ck_strdup (get_buffer (b));
call    0 returned 5
call    1 returned 5
        5: 1217:  tmp->next = list;
        5: 1218:  flush_buffer (b);
call    0 returned 5
        5: 1219:  return tmp;
        -: 1220:}
        -: 1221:
        -: 1222:/* read in a filename for a 'r', 'w', or 's///w' command, and
        -: 1223:   update the internal structure about files.  The file is
        -: 1224:   opened if it isn't already open. */
        -: 1225:FILE *
function compile_filename called 70 returned 100% blocks executed 79%
       70: 1226:compile_filename (readit)
        -: 1227:     int readit;
        -: 1228:{
        -: 1229:  char *file_name;
        -: 1230:  int n;
        -: 1231:  VOID *b;
        -: 1232:  int ch;
        -: 1233:
       70: 1234:  if (inchar () != ' ')
call    0 returned 70
branch  1 taken 0 (fallthrough)
branch  2 taken 70
    #####: 1235:    bad_prog ("missing ' ' before filename");
call    0 never executed
       70: 1236:  b = init_buffer ();
call    0 returned 70
      807: 1237:  while ((ch = inchar ()) != EOF && ch != '\n')
call    0 returned 807
branch  1 taken 807 (fallthrough)
branch  2 taken 0
branch  3 taken 737
branch  4 taken 70 (fallthrough)
      737: 1238:    add1_buffer (b, ch);
call    0 returned 737
       70: 1239:  add1_buffer (b, '\0');
call    0 returned 70
       70: 1240:  file_name = get_buffer (b);
call    0 returned 70
      115: 1241:  for (n = 0; n < NUM_FPS; n++)
branch  0 taken 115
branch  1 taken 0 (fallthrough)
        -: 1242:    {
      115: 1243:      if (!file_ptrs[n].name)
branch  0 taken 70 (fallthrough)
branch  1 taken 45
       70: 1244:	break;
        -: 1245:    }
       70: 1246:  if (n < NUM_FPS)
branch  0 taken 70 (fallthrough)
branch  1 taken 0
        -: 1247:    {
       70: 1248:      file_ptrs[n].name = ck_strdup (file_name);
call    0 returned 70
       70: 1249:      if (!readit)
branch  0 taken 70 (fallthrough)
branch  1 taken 0
        -: 1250:	{
        -: 1251:      #ifndef FAULTY_F_AG_5
       70: 1252:	  if (!file_ptrs[n].for_write)
branch  0 taken 70 (fallthrough)
branch  1 taken 0
        -: 1253:      #endif
       70: 1254:	    file_ptrs[n].for_write = ck_fopen (file_name, "w");
call    0 returned 70
        -: 1255:	}
        -: 1256:      else
        -: 1257:	{
    #####: 1258:	  if (!file_ptrs[n].for_read)
branch  0 never executed
branch  1 never executed
    #####: 1259:	    file_ptrs[n].for_read = fopen (file_name, "r");
call    0 never executed
        -: 1260:	}
       70: 1261:      flush_buffer (b);
call    0 returned 70
      70*: 1262:      return readit ? file_ptrs[n].for_read : file_ptrs[n].for_write;
branch  0 taken 0 (fallthrough)
branch  1 taken 70
        -: 1263:    }
        -: 1264:  else
        -: 1265:    {
    #####: 1266:      bad_prog ("Hopelessely evil compiled in limit on number of open files.  re-compile sed");
call    0 never executed
    #####: 1267:      return 0;
        -: 1268:    }
        -: 1269:}
        -: 1270:
        -: 1271:/* Read a file and apply the compiled script to it. */
        -: 1272:void
function read_file called 175 returned 100% blocks executed 100%
      175: 1273:read_file (name)
        -: 1274:     char *name;
        -: 1275:{
      175: 1276:  if (*name == '-' && name[1] == '\0')
branch  0 taken 1 (fallthrough)
branch  1 taken 174
branch  2 taken 1 (fallthrough)
branch  3 taken 0
        1: 1277:    input_file = stdin;
        -: 1278:  else
        -: 1279:    {
      174: 1280:      input_file = fopen (name, "r");
call    0 returned 174
      174: 1281:      if (input_file == 0)
branch  0 taken 1 (fallthrough)
branch  1 taken 173
        -: 1282:	{
        1: 1283:	  char *ptr = strerror(errno);
call    0 returned 1
        1: 1284:	  bad_input++;
        1: 1285:	  fprintf (stderr, "%s: can't read %s: %s\n", myname, name, ptr);
call    0 returned 1
        1: 1286:	  return;
        -: 1287:	}
        -: 1288:    }
        -: 1289:  
    13829: 1290:  while (read_pattern_space ())
call    0 returned 13829
branch  1 taken 13692
branch  2 taken 137 (fallthrough)
        -: 1291:    {
    13692: 1292:      execute_program (the_program);
call    0 returned 13692
    13692: 1293:      if (!no_default_output)
branch  0 taken 6812 (fallthrough)
branch  1 taken 6880
     6812: 1294:	ck_fwrite (line.text, 1, line.length, stdout);
call    0 returned 6812
    13692: 1295:      if (append.length)
branch  0 taken 383 (fallthrough)
branch  1 taken 13309
        -: 1296:	{
      383: 1297:	  ck_fwrite (append.text, 1, append.length, stdout);
call    0 returned 383
      383: 1298:	  append.length = 0;
        -: 1299:	}
    13692: 1300:      if (quit_cmd)
branch  0 taken 37 (fallthrough)
branch  1 taken 13655
       37: 1301:	break;
        -: 1302:    }
      174: 1303:  ck_fclose (input_file);
call    0 returned 174
        -: 1304:}
        -: 1305:
        -: 1306:static char *
function eol_pos called 2300 returned 100% blocks executed 83%
     2300: 1307:eol_pos (str, len)
        -: 1308:     char *str;
        -: 1309:     int len;
        -: 1310:{
    35301: 1311:  while (len--)
branch  0 taken 35301
branch  1 taken 0 (fallthrough)
    35301: 1312:    if (*str++ == '\n')
branch  0 taken 2300 (fallthrough)
branch  1 taken 33001
     2300: 1313:      return --str;
    #####: 1314:  return --str;
        -: 1315:}
        -: 1316:
        -: 1317:static void
function chr_copy called 607 returned 100% blocks executed 100%
      607: 1318:chr_copy (dest, src, len)
        -: 1319:     char *dest;
        -: 1320:     char *src;
        -: 1321:     int len;
        -: 1322:{
     9724: 1323:  while (len--)
branch  0 taken 9117
branch  1 taken 607 (fallthrough)
     9117: 1324:    *dest++ = *src++;
      607: 1325:}
        -: 1326:
        -: 1327:/* Execute the program 'vec' on the current input line. */
        -: 1328:static struct re_registers regs =
        -: 1329:{0, 0, 0};
        -: 1330:
        -: 1331:void
function execute_program called 13692 returned 100% blocks executed 76%
    13692: 1332:execute_program (vec)
        -: 1333:     struct vector *vec;
        -: 1334:{
        -: 1335:  struct sed_cmd *cur_cmd;
        -: 1336:  int n;
        -: 1337:  int addr_matched;
        -: 1338:  static int end_cycle;
        -: 1339:
        -: 1340:  int start;
        -: 1341:  int remain;
        -: 1342:  int offset;
        -: 1343:
        -: 1344:  static struct line tmp;
        -: 1345:  struct line t;
        -: 1346:  char *rep, *rep_end, *rep_next, *rep_cur;
        -: 1347:
        -: 1348:  int count;
    13692: 1349:  struct vector *restart_vec = vec;
        -: 1350:
    14299: 1351:restart:
    14299: 1352:  vec = restart_vec;
    14299: 1353:  count = 0;
        -: 1354:
    14299: 1355:  end_cycle = 0;
        -: 1356:
    40009: 1357:  for (cur_cmd = vec->v, n = vec->v_length; n; cur_cmd++, n--)
branch  0 taken 29420
branch  1 taken 10589 (fallthrough)
        -: 1358:    {
    29420: 1359:    exe_loop:
    31600: 1360:      addr_matched = 0;
    31600: 1361:      if (cur_cmd->aflags & A1_MATCHED_BIT)
branch  0 taken 1621 (fallthrough)
branch  1 taken 29979
        -: 1362:	{
     1621: 1363:	  addr_matched = 1;
     1621: 1364:	  if (match_address (&(cur_cmd->a2)))
call    0 returned 1621
branch  1 taken 37 (fallthrough)
branch  2 taken 1584
       37: 1365:	    cur_cmd->aflags &= ~A1_MATCHED_BIT;
        -: 1366:	}
    29979: 1367:      else if (match_address (&(cur_cmd->a1)))
call    0 returned 29979
branch  1 taken 19235 (fallthrough)
branch  2 taken 10744
        -: 1368:	{
    19235: 1369:	  addr_matched = 1;
    19235: 1370:	  if (cur_cmd->a2.addr_type != addr_is_null)
branch  0 taken 52 (fallthrough)
branch  1 taken 19183
       52: 1371:	    if (   (cur_cmd->a2.addr_type == addr_is_regex)
branch  0 taken 16 (fallthrough)
branch  1 taken 36
       16: 1372:		|| !match_address (&(cur_cmd->a2)))
call    0 returned 16
branch  1 taken 16 (fallthrough)
branch  2 taken 0
       52: 1373:	      cur_cmd->aflags |= A1_MATCHED_BIT;
        -: 1374:
        -: 1375:	}
    31600: 1376:      if (cur_cmd->aflags & ADDR_BANG_BIT)
branch  0 taken 516 (fallthrough)
branch  1 taken 31084
      516: 1377:	addr_matched = !addr_matched;
    31600: 1378:      if (!addr_matched)
branch  0 taken 10280 (fallthrough)
branch  1 taken 21320
    10280: 1379:	continue;
    21320: 1380:      switch (cur_cmd->cmd)
branch  0 taken 2139
branch  1 taken 658
branch  2 taken 151
branch  3 taken 228
branch  4 taken 420
branch  5 taken 118
branch  6 taken 1015
branch  7 taken 1400
branch  8 taken 1181
branch  9 taken 10
branch 10 taken 10
branch 11 taken 18
branch 12 taken 12
branch 13 taken 80
branch 14 taken 786
branch 15 taken 1845
branch 16 taken 1934
branch 17 taken 1242
branch 18 taken 1119
branch 19 taken 24
branch 20 taken 0
branch 21 taken 4260
branch 22 taken 0
branch 23 taken 1640
branch 24 taken 5
branch 25 taken 1025
branch 26 taken 0
        -: 1381:	{
     2139: 1382:	case '{':		/* Execute sub-program */
     2139: 1383:	  if (cur_cmd->x.sub->v_length)
branch  0 taken 2139 (fallthrough)
branch  1 taken 0
        -: 1384:	    {
     2139: 1385:	      vec = cur_cmd->x.sub;
     2139: 1386:	      cur_cmd = vec->v;
     2139: 1387:	      n = vec->v_length;
     2139: 1388:	      goto exe_loop;
        -: 1389:	    }
    #####: 1390:	  break;
        -: 1391:
      658: 1392:	case '}':
      658: 1393:	  cur_cmd = vec->return_v->v + vec->return_i;
      658: 1394:	  n = vec->return_v->v_length - vec->return_i;
      658: 1395:	  vec = vec->return_v;
      658: 1396:	  break;
        -: 1397:
      151: 1398:	case ':':		/* Executing labels is easy. */
      151: 1399:	  break;
        -: 1400:
      228: 1401:	case '=':
      228: 1402:	  printf ("%d\n", input_line_number);
call    0 returned 228
      228: 1403:	  break;
        -: 1404:
      420: 1405:	case 'a':
      422: 1406:	  while (append.alloc - append.length < cur_cmd->x.cmd_txt.text_len)
branch  0 taken 2
branch  1 taken 420 (fallthrough)
        -: 1407:	    {
        2: 1408:	      append.alloc *= 2;
        2: 1409:	      append.text = ck_realloc (append.text, append.alloc);
call    0 returned 2
        -: 1410:	    }
      420: 1411:	  bcopy (cur_cmd->x.cmd_txt.text,
      420: 1412:		 append.text + append.length, cur_cmd->x.cmd_txt.text_len);
      420: 1413:	  append.length += cur_cmd->x.cmd_txt.text_len;
      420: 1414:	  break;
        -: 1415:
      118: 1416:	case 'b':
      118: 1417:	  if (!cur_cmd->x.jump)
branch  0 taken 77 (fallthrough)
branch  1 taken 41
       77: 1418:	    end_cycle++;
        -: 1419:	  else
        -: 1420:	    {
       41: 1421:	      struct sed_label *j = cur_cmd->x.jump;
        -: 1422:
       41: 1423:	      n = j->v->v_length - j->v_index;
       41: 1424:	      cur_cmd = j->v->v + j->v_index;
       41: 1425:	      vec = j->v;
       41: 1426:	      goto exe_loop;
        -: 1427:	    }
       77: 1428:	  break;
        -: 1429:
     1015: 1430:	case 'c':
     1015: 1431:	  line.length = 0;
     1015: 1432:	  if (!((cur_cmd->aflags & A1_MATCHED_BIT)))
branch  0 taken 247 (fallthrough)
branch  1 taken 768
      247: 1433:	    ck_fwrite (cur_cmd->x.cmd_txt.text,
call    0 returned 247
        -: 1434:		       1, cur_cmd->x.cmd_txt.text_len, stdout);
     1015: 1435:	  end_cycle++;
     1015: 1436:	  break;
        -: 1437:
     1400: 1438:	case 'd':
     1400: 1439:	  line.length = 0;
     1400: 1440:	  end_cycle++;
     1400: 1441:	  break;
        -: 1442:
     1181: 1443:	case 'D':
        -: 1444:	  {
        -: 1445:	    char *tmp;
        -: 1446:	    int newlength;
        -: 1447:
     1181: 1448:	    tmp = eol_pos (line.text, line.length);
call    0 returned 1181
     1181: 1449:	    newlength = line.length - (tmp - line.text) - 1;
     1181: 1450:	    if (newlength)
branch  0 taken 607 (fallthrough)
branch  1 taken 574
        -: 1451:	      {
      607: 1452:		chr_copy (line.text, tmp + 1, newlength);
call    0 returned 607
      607: 1453:		line.length = newlength;
      607: 1454:		goto restart;
        -: 1455:	      }
      574: 1456:	    line.length = 0;
      574: 1457:	    end_cycle++;
        -: 1458:	  }
      574: 1459:	  break;
        -: 1460:
       10: 1461:	case 'g':
       10: 1462:	  line_copy (&hold, &line);
call    0 returned 10
       10: 1463:	  break;
        -: 1464:
       10: 1465:	case 'G':
       10: 1466:	  line_append (&hold, &line);
call    0 returned 10
       10: 1467:	  break;
        -: 1468:
       18: 1469:	case 'h':
       18: 1470:	  line_copy (&line, &hold);
call    0 returned 18
       18: 1471:	  break;
        -: 1472:
       12: 1473:	case 'H':
       12: 1474:	  line_append (&line, &hold);
call    0 returned 12
       12: 1475:	  break;
        -: 1476:
       80: 1477:	case 'i':
       80: 1478:	  ck_fwrite (cur_cmd->x.cmd_txt.text, 1,
call    0 returned 80
        -: 1479:		     cur_cmd->x.cmd_txt.text_len, stdout);
       80: 1480:	  break;
        -: 1481:
      786: 1482:	case 'l':
        -: 1483:	  {
        -: 1484:	    char *tmp;
        -: 1485:	    int n;
      786: 1486:	    int width = 0;
        -: 1487:
      786: 1488:	    n = line.length;
      786: 1489:	    tmp = line.text;
    16208: 1490:	    while (n--)
branch  0 taken 16208
branch  1 taken 0 (fallthrough)
        -: 1491:	      {
        -: 1492:		/* Skip the trailing newline, if there is one */
    16208: 1493:		if (!n && (*tmp == '\n'))
branch  0 taken 786 (fallthrough)
branch  1 taken 15422
branch  2 taken 786 (fallthrough)
branch  3 taken 0
      786: 1494:		  break;
    15422: 1495:		if (width > 77)
branch  0 taken 2 (fallthrough)
branch  1 taken 15420
        -: 1496:		  {
        2: 1497:		    width = 0;
        2: 1498:		    putchar ('\n');
call    0 returned 2
        -: 1499:		  }
    15422: 1500:		if (*tmp == '\\')
branch  0 taken 0 (fallthrough)
branch  1 taken 15422
        -: 1501:		  {
    #####: 1502:		    printf ("\\\\");
call    0 never executed
    #####: 1503:		    width += 2;
        -: 1504:		  }
    15422: 1505:		else if (isprint (*tmp))
branch  0 taken 15017 (fallthrough)
branch  1 taken 405
        -: 1506:		  {
    15017: 1507:		    putchar (*tmp);
call    0 returned 15017
    15017: 1508:		    width++;
        -: 1509:		  }
        -: 1510:		else
      405: 1511:		  switch (*tmp)
branch  0 taken 0
branch  1 taken 0
branch  2 taken 0
branch  3 taken 211
branch  4 taken 0
branch  5 taken 134
branch  6 taken 0
branch  7 taken 60
        -: 1512:		    {
        -: 1513:#if 0
        -: 1514:		      /* Should print \00 instead of \0 because (a) POSIX */
        -: 1515:		      /* requires it, and (b) this way \01 is unambiguous.  */
        -: 1516:		    case '\0':
        -: 1517:		      printf ("\\0");
        -: 1518:		      width += 2;
        -: 1519:		      break;
        -: 1520:#endif
    #####: 1521:		    case 007:
    #####: 1522:		      printf ("\\a");
call    0 never executed
    #####: 1523:		      width += 2;
    #####: 1524:		      break;
    #####: 1525:		    case '\b':
    #####: 1526:		      printf ("\\b");
call    0 never executed
    #####: 1527:		      width += 2;
    #####: 1528:		      break;
    #####: 1529:		    case '\f':
    #####: 1530:		      printf ("\\f");
call    0 never executed
    #####: 1531:		      width += 2;
    #####: 1532:		      break;
      211: 1533:		    case '\n':
      211: 1534:		      printf ("\\n");
call    0 returned 211
      211: 1535:		      width += 2;
      211: 1536:		      break;
    #####: 1537:		    case '\r':
    #####: 1538:		      printf ("\\r");
call    0 never executed
    #####: 1539:		      width += 2;
    #####: 1540:		      break;
      134: 1541:		    case '\t':
      134: 1542:		      printf ("\\t");
call    0 returned 134
      134: 1543:		      width += 2;
      134: 1544:		      break;
    #####: 1545:		    case '\v':
    #####: 1546:		      printf ("\\v");
call    0 never executed
    #####: 1547:		      width += 2;
    #####: 1548:		      break;
       60: 1549:		    default:
       60: 1550:		      printf ("\\%02x", (*tmp) & 0xFF);
call    0 returned 60
       60: 1551:		      width += 2;
       60: 1552:		      break;
        -: 1553:		    }
    15422: 1554:		tmp++;
        -: 1555:	      }
      786: 1556:	    putchar ('\n');
call    0 returned 786
        -: 1557:	  }
      786: 1558:	  break;
        -: 1559:
     1845: 1560:	case 'n':
     1845: 1561:	  if (feof (input_file))
call    0 returned 1845
branch  1 taken 5 (fallthrough)
branch  2 taken 1840
        5: 1562:	    goto quit;
     1840: 1563:	  if (!no_default_output)
branch  0 taken 595 (fallthrough)
branch  1 taken 1245
      595: 1564:	    ck_fwrite (line.text, 1, line.length, stdout);
call    0 returned 595
     1840: 1565:	  read_pattern_space ();
call    0 returned 1840
     1840: 1566:	  break;
        -: 1567:
     1934: 1568:	case 'N':
     1934: 1569:	  if (feof (input_file))
call    0 returned 1934
branch  1 taken 8 (fallthrough)
branch  2 taken 1926
        -: 1570:	    {
        8: 1571:	      line.length = 0;
        8: 1572:	      goto quit;
        -: 1573:	    }
     1926: 1574:	  append_pattern_space ();
call    0 returned 1926
     1926: 1575:	  break;
        -: 1576:
     1242: 1577:	case 'p':
     1242: 1578:	  ck_fwrite (line.text, 1, line.length, stdout);
call    0 returned 1242
     1242: 1579:	  break;
        -: 1580:
     1119: 1581:	case 'P':
        -: 1582:	  {
        -: 1583:	    char *tmp;
        -: 1584:
     1119: 1585:	    tmp = eol_pos (line.text, line.length);
call    0 returned 1119
    2238*: 1586:	    ck_fwrite (line.text, 1,
branch  0 taken 1119 (fallthrough)
branch  1 taken 0
call    2 returned 1119
     1119: 1587:		       tmp ? tmp - line.text + 1
        -: 1588:		       : line.length, stdout);
        -: 1589:	  }
     1119: 1590:	  break;
        -: 1591:
        -: 1592:	case 'q':
       37: 1593:	quit:
       37: 1594:	  quit_cmd++;
       37: 1595:	  end_cycle++;
       37: 1596:	  break;
        -: 1597:
    #####: 1598:	case 'r':
        -: 1599:	  {
    #####: 1600:	    int n = 0;
        -: 1601:
    #####: 1602:	    if (cur_cmd->x.io_file)
branch  0 never executed
branch  1 never executed
        -: 1603:	      {
    #####: 1604:		rewind (cur_cmd->x.io_file);
call    0 never executed
        -: 1605:		do
        -: 1606:		  {
    #####: 1607:		    append.length += n;
    #####: 1608:		    if (append.length == append.alloc)
branch  0 never executed
branch  1 never executed
        -: 1609:		      {
    #####: 1610:			append.alloc *= 2;
    #####: 1611:			append.text = ck_realloc (append.text, append.alloc);
call    0 never executed
        -: 1612:		      }
    #####: 1613:		    n = fread (append.text + append.length, sizeof (char),
    #####: 1614:			       append.alloc - append.length,
call    0 never executed
        -: 1615:			       cur_cmd->x.io_file);
        -: 1616:		  }
    #####: 1617:		while (n > 0);
branch  0 never executed
branch  1 never executed
    #####: 1618:		if (ferror (cur_cmd->x.io_file))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1619:		  panic ("Read error on input file to 'r' command");
call    0 never executed
        -: 1620:	      }
        -: 1621:	  }
    #####: 1622:	  break;
        -: 1623:
     4260: 1624:	case 's':
        -: 1625:	  {
     4260: 1626:	    int trail_nl_p = line.text [line.length - 1] == '\n';
     4260: 1627:	    if (!tmp.alloc)
branch  0 taken 68 (fallthrough)
branch  1 taken 4192
        -: 1628:	      {
       68: 1629:		tmp.alloc = 50;
       68: 1630:		tmp.text = ck_malloc (50);
call    0 returned 68
        -: 1631:	      }
     4260: 1632:	    count = 0;
     4260: 1633:	    start = 0;
     4260: 1634:	    remain = line.length - trail_nl_p;
     4260: 1635:	    tmp.length = 0;
     4260: 1636:	    rep = cur_cmd->x.cmd_regex.replacement;
     4260: 1637:	    rep_end = rep + cur_cmd->x.cmd_regex.replace_length;
        -: 1638:	    
     4260: 1639:	    while ((offset = re_search (cur_cmd->x.cmd_regex.regx,
     5808: 1640:					line.text,
     5808: 1641:					line.length - trail_nl_p,
call    0 returned 5808
        -: 1642:					start,
        -: 1643:					remain,
     5808: 1644:					&regs)) >= 0)
branch  0 taken 2181
branch  1 taken 3627 (fallthrough)
        -: 1645:	      {
     2181: 1646:		count++;
     2181: 1647:		if (offset - start)
branch  0 taken 415 (fallthrough)
branch  1 taken 1766
      415: 1648:		  str_append (&tmp, line.text + start, offset - start);
call    0 returned 415
        -: 1649:		
     2181: 1650:		if (cur_cmd->x.cmd_regex.flags & S_NUM_BIT)
branch  0 taken 0 (fallthrough)
branch  1 taken 2181
        -: 1651:		  {
    #####: 1652:		    if (count != cur_cmd->x.cmd_regex.numb)
branch  0 never executed
branch  1 never executed
    #####: 1653:		      {
    #####: 1654:			int matched = regs.end[0] - regs.start[0];
    #####: 1655:			if (!matched) matched = 1;
branch  0 never executed
branch  1 never executed
    #####: 1656:			str_append (&tmp, line.text + regs.start[0], matched);
call    0 never executed
    #####: 1657:			start = (offset == regs.end[0]
    #####: 1658:				 ? offset + 1 : regs.end[0]);
branch  0 never executed
branch  1 never executed
    #####: 1659:			remain = (line.length - trail_nl_p) - start;
    #####: 1660:			continue;
        -: 1661:		      }
        -: 1662:		  }
        -: 1663:		
    11765: 1664:		for (rep_next = rep_cur = rep; rep_next < rep_end; rep_next++)
branch  0 taken 9584
branch  1 taken 2181 (fallthrough)
        -: 1665:		  {
     9584: 1666:		    if (*rep_next == '&')
branch  0 taken 0 (fallthrough)
branch  1 taken 9584
        -: 1667:		      {
    #####: 1668:			if (rep_next - rep_cur)
branch  0 never executed
branch  1 never executed
    #####: 1669:			  str_append (&tmp, rep_cur, rep_next - rep_cur);
call    0 never executed
    #####: 1670:			str_append (&tmp, line.text + regs.start[0], regs.end[0] - regs.start[0]);
call    0 never executed
    #####: 1671:			rep_cur = rep_next + 1;
        -: 1672:		      }
     9584: 1673:		    else if (*rep_next == '\\')
branch  0 taken 1008 (fallthrough)
branch  1 taken 8576
        -: 1674:		      {
     1008: 1675:			if (rep_next - rep_cur)
branch  0 taken 177 (fallthrough)
branch  1 taken 831
      177: 1676:			  str_append (&tmp, rep_cur, rep_next - rep_cur);
call    0 returned 177
     1008: 1677:			rep_next++;
     1008: 1678:			if (rep_next != rep_end)
branch  0 taken 1008 (fallthrough)
branch  1 taken 0
        -: 1679:			  {
        -: 1680:			    int n;
        -: 1681:			    
    1008*: 1682:			    if (*rep_next >= '0' && *rep_next <= '9')
branch  0 taken 0 (fallthrough)
branch  1 taken 1008
branch  2 never executed
branch  3 never executed
        -: 1683:			      {
    #####: 1684:				n = *rep_next - '0';
    #####: 1685:				str_append (&tmp, line.text + regs.start[n], regs.end[n] - regs.start[n]);
call    0 never executed
        -: 1686:			      }
        -: 1687:			    else
     1008: 1688:			      str_append (&tmp, rep_next, 1);
call    0 returned 1008
        -: 1689:			  }
     1008: 1690:			rep_cur = rep_next + 1;
        -: 1691:		      }
        -: 1692:		  }
     2181: 1693:		if (rep_next - rep_cur)
branch  0 taken 1209 (fallthrough)
branch  1 taken 972
     1209: 1694:		  str_append (&tmp, rep_cur, rep_next - rep_cur);
call    0 returned 1209
     2181: 1695:		if (offset == regs.end[0])
branch  0 taken 1015 (fallthrough)
branch  1 taken 1166
        -: 1696:		  {
     1015: 1697:		    str_append (&tmp, line.text + offset, 1);
call    0 returned 1015
     1015: 1698:		    ++regs.end[0];
        -: 1699:		  }
     2181: 1700:		start = regs.end[0];
        -: 1701:		
     2181: 1702:		remain = (line.length - trail_nl_p) - start;
     2181: 1703:		if (remain < 0)
branch  0 taken 531 (fallthrough)
branch  1 taken 1650
      531: 1704:		  break;
     1650: 1705:		if (!(cur_cmd->x.cmd_regex.flags & S_GLOBAL_BIT))
branch  0 taken 102 (fallthrough)
branch  1 taken 1548
      102: 1706:		  break;
        -: 1707:	      }
     4260: 1708:	    if (!count)
branch  0 taken 2952 (fallthrough)
branch  1 taken 1308
     2952: 1709:	      break;
     1308: 1710:	    replaced = 1;
     1308: 1711:	    str_append (&tmp, line.text + start, remain + trail_nl_p);
call    0 returned 1308
     1308: 1712:	    t.text = line.text;
     1308: 1713:	    t.length = line.length;
     1308: 1714:	    t.alloc = line.alloc;
     1308: 1715:	    line.text = tmp.text;
     1308: 1716:	    line.length = tmp.length;
     1308: 1717:	    line.alloc = tmp.alloc;
     1308: 1718:	    tmp.text = t.text;
     1308: 1719:	    tmp.length = t.length;
     1308: 1720:	    tmp.alloc = t.alloc;
     1308: 1721:	    if ((cur_cmd->x.cmd_regex.flags & S_WRITE_BIT)
branch  0 taken 677 (fallthrough)
branch  1 taken 631
      677: 1722:		&& cur_cmd->x.cmd_regex.wio_file)
branch  0 taken 677 (fallthrough)
branch  1 taken 0
      677: 1723:	      ck_fwrite (line.text, 1, line.length,
call    0 returned 677
        -: 1724:			 cur_cmd->x.cmd_regex.wio_file);
     1308: 1725:	    if (cur_cmd->x.cmd_regex.flags & S_PRINT_BIT)
branch  0 taken 497 (fallthrough)
branch  1 taken 811
      497: 1726:	      ck_fwrite (line.text, 1, line.length, stdout);
call    0 returned 497
     1308: 1727:	    break;
        -: 1728:	  }
        -: 1729:	    
    #####: 1730:	case 't':
    #####: 1731:	  if (replaced)
branch  0 never executed
branch  1 never executed
        -: 1732:	    {
    #####: 1733:	      replaced = 0;
    #####: 1734:	      if (!cur_cmd->x.jump)
branch  0 never executed
branch  1 never executed
    #####: 1735:		end_cycle++;
        -: 1736:	      else
        -: 1737:		{
    #####: 1738:		  struct sed_label *j = cur_cmd->x.jump;
        -: 1739:
    #####: 1740:		  n = j->v->v_length - j->v_index;
    #####: 1741:		  cur_cmd = j->v->v + j->v_index;
    #####: 1742:		  vec = j->v;
    #####: 1743:		  goto exe_loop;
        -: 1744:		}
        -: 1745:	    }
    #####: 1746:	  break;
        -: 1747:
     1640: 1748:	case 'w':
     1640: 1749:	  if (cur_cmd->x.io_file)
branch  0 taken 1640 (fallthrough)
branch  1 taken 0
        -: 1750:	    {
     1640: 1751:	      ck_fwrite (line.text, 1, line.length, cur_cmd->x.io_file);
call    0 returned 1640
     1640: 1752:	      fflush (cur_cmd->x.io_file);
call    0 returned 1640
        -: 1753:	    }
     1640: 1754:	  break;
        -: 1755:
        5: 1756:	case 'x':
        -: 1757:	  {
        -: 1758:	    struct line tmp;
        -: 1759:
        5: 1760:	    tmp = line;
        5: 1761:	    line = hold;
        5: 1762:	    hold = tmp;
        -: 1763:	  }
        5: 1764:	  break;
        -: 1765:
     1025: 1766:	case 'y':
        -: 1767:	  {
        -: 1768:	    unsigned char *p, *e;
        -: 1769:
     1025: 1770:	    for (p = (unsigned char *) (line.text), e = p + line.length;
    19921: 1771:		 p < e;
branch  0 taken 18896
branch  1 taken 1025 (fallthrough)
    18896: 1772:		 p++)
    18896: 1773:	      *p = cur_cmd->x.translate[*p];
        -: 1774:	  }
     1025: 1775:	  break;
        -: 1776:
    #####: 1777:	default:
    #####: 1778:	  panic ("INTERNAL ERROR: Bad cmd %c", cur_cmd->cmd);
call    0 never executed
        -: 1779:	}
    18533: 1780:      if (end_cycle)
branch  0 taken 3103 (fallthrough)
branch  1 taken 15430
     3103: 1781:	break;
        -: 1782:    }
    13692: 1783:}
        -: 1784:
        -: 1785:
        -: 1786:/* Return non-zero if the current line matches the address
        -: 1787:   pointed to by 'addr'. */
        -: 1788:int
function match_address called 31616 returned 100% blocks executed 64%
    31616: 1789:match_address (addr)
        -: 1790:     struct addr *addr;
        -: 1791:{
    31616: 1792:  switch (addr->addr_type)
branch  0 taken 17918
branch  1 taken 2668
branch  2 taken 0
branch  3 taken 10385
branch  4 taken 645
branch  5 taken 0
        -: 1793:    {
    17918: 1794:    case addr_is_null:
    17918: 1795:      return 1;
     2668: 1796:    case addr_is_num:
     2668: 1797:      return (input_line_number == addr->addr_number);
    #####: 1798:    case addr_is_mod:
    #####: 1799:      return ((input_line_number%addr->modulo) == addr->offset);
        -: 1800:
        -: 1801:
    10385: 1802:    case addr_is_regex:
        -: 1803:      {
    10385: 1804:	int trail_nl_p = line.text [line.length - 1] == '\n';
    10385: 1805:	return (re_search (addr->addr_regex,
    10385: 1806:			   line.text,
    10385: 1807:			   line.length - trail_nl_p,
        -: 1808:			   0,
    10385: 1809:			   line.length - trail_nl_p,
call    0 returned 10385
    10385: 1810:			   (struct re_registers *) 0) >= 0) ? 1 : 0;
        -: 1811:      }
      645: 1812:    case addr_is_last:
      645: 1813:      return (input_EOF) ? 1 : 0;
        -: 1814:
    #####: 1815:    default:
    #####: 1816:      panic ("INTERNAL ERROR: bad address type");
call    0 never executed
    #####: 1817:      break;
        -: 1818:    }
    #####: 1819:  return -1;
        -: 1820:}
        -: 1821:
        -: 1822:/* Read in the next line of input, and store it in the
        -: 1823:   pattern space.  Return non-zero if this is the last line of input */
        -: 1824:
        -: 1825:int
function read_pattern_space called 15669 returned 100% blocks executed 96%
    15669: 1826:read_pattern_space ()
        -: 1827:{
        -: 1828:  int n;
        -: 1829:  char *p;
        -: 1830:  int ch;
        -: 1831:
    15669: 1832:  p = line.text;
    15669: 1833:  n = line.alloc;
        -: 1834:
    15669: 1835:  if (feof (input_file))
call    0 returned 15669
branch  1 taken 137 (fallthrough)
branch  2 taken 15532
      137: 1836:    return 0;
    15532: 1837:  input_line_number++;
    15532: 1838:  replaced = 0;
        -: 1839:  for (;;)
        -: 1840:    {
   260502: 1841:      if (n == 0)
branch  0 taken 123 (fallthrough)
branch  1 taken 260379
        -: 1842:	{
      123: 1843:	  line.text = ck_realloc (line.text, line.alloc * 2);
call    0 returned 123
      123: 1844:	  p = line.text + line.alloc;
      123: 1845:	  n = line.alloc;
      123: 1846:	  line.alloc *= 2;
        -: 1847:	}
   260502: 1848:      ch = getc (input_file);
call    0 returned 260502
   260502: 1849:      if (ch == EOF)
branch  0 taken 2 (fallthrough)
branch  1 taken 260500
        -: 1850:	{
        2: 1851:	  if (n == line.alloc)
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####: 1852:	    return 0;
        -: 1853:	  /* *p++ = '\n'; */
        -: 1854:	  /* --n; */
        2: 1855:	  line.length = line.alloc - n;
        2: 1856:	  if (last_input_file)
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2: 1857:	    input_EOF++;
        2: 1858:	  return 1;
        -: 1859:	}
   260500: 1860:      *p++ = ch;
   260500: 1861:      --n;
   260500: 1862:      if (ch == '\n')
branch  0 taken 15530 (fallthrough)
branch  1 taken 244970
        -: 1863:	{
    15530: 1864:	  line.length = line.alloc - n;
    15530: 1865:	  break;
        -: 1866:	}
        -: 1867:    }
    15530: 1868:  ch = getc (input_file);
call    0 returned 15530
    15530: 1869:  if (ch != EOF)
branch  0 taken 15402 (fallthrough)
branch  1 taken 128
    15402: 1870:    ungetc (ch, input_file);
call    0 returned 15402
      128: 1871:  else if (last_input_file)
branch  0 taken 127 (fallthrough)
branch  1 taken 1
      127: 1872:    input_EOF++;
    15530: 1873:  return 1;
        -: 1874:}
        -: 1875:
        -: 1876:/* Inplement the 'N' command, which appends the next line of input to
        -: 1877:   the pattern space. */
        -: 1878:void
function append_pattern_space called 1926 returned 100% blocks executed 75%
     1926: 1879:append_pattern_space ()
        -: 1880:{
        -: 1881:  char *p;
        -: 1882:  int n;
        -: 1883:  int ch;
        -: 1884:
     1926: 1885:  p = line.text + line.length;
     1926: 1886:  n = line.alloc - line.length;
        -: 1887:
     1926: 1888:  input_line_number++;
     1926: 1889:  replaced = 0;
        -: 1890:  for (;;)
        -: 1891:    {
    29947: 1892:      ch = getc (input_file);
call    0 returned 29947
    29947: 1893:      if (ch == EOF)
branch  0 taken 0 (fallthrough)
branch  1 taken 29947
        -: 1894:	{
    #####: 1895:	  if (n == line.alloc)
branch  0 never executed
branch  1 never executed
    #####: 1896:	    return;
        -: 1897:	  /* *p++ = '\n'; */
        -: 1898:	  /* --n; */
    #####: 1899:	  line.length = line.alloc - n;
    #####: 1900:	  if (last_input_file)
branch  0 never executed
branch  1 never executed
    #####: 1901:	    input_EOF++;
    #####: 1902:	  return;
        -: 1903:	}
    29947: 1904:      if (n == 0)
branch  0 taken 59 (fallthrough)
branch  1 taken 29888
        -: 1905:	{
       59: 1906:	  line.text = ck_realloc (line.text, line.alloc * 2);
call    0 returned 59
       59: 1907:	  p = line.text + line.alloc;
       59: 1908:	  n = line.alloc;
       59: 1909:	  line.alloc *= 2;
        -: 1910:	}
    29947: 1911:      *p++ = ch;
    29947: 1912:      --n;
    29947: 1913:      if (ch == '\n')
branch  0 taken 1926 (fallthrough)
branch  1 taken 28021
        -: 1914:	{
     1926: 1915:	  line.length = line.alloc - n;
     1926: 1916:	  break;
        -: 1917:	}
        -: 1918:    }
     1926: 1919:  ch = getc (input_file);
call    0 returned 1926
     1926: 1920:  if (ch != EOF)
branch  0 taken 1906 (fallthrough)
branch  1 taken 20
     1906: 1921:    ungetc (ch, input_file);
call    0 returned 1906
       20: 1922:  else if (last_input_file)
branch  0 taken 20 (fallthrough)
branch  1 taken 0
       20: 1923:    input_EOF++;
        -: 1924:}
        -: 1925:
        -: 1926:/* Copy the contents of the line 'from' into the line 'to'.
        -: 1927:   This destroys the old contents of 'to'.  It will still work
        -: 1928:   if the line 'from' contains nulls. */
        -: 1929:void
function line_copy called 28 returned 100% blocks executed 100%
       28: 1930:line_copy (from, to)
        -: 1931:     struct line *from, *to;
        -: 1932:{
       28: 1933:  if (from->length > to->alloc)
branch  0 taken 1 (fallthrough)
branch  1 taken 27
        -: 1934:    {
        1: 1935:      to->alloc = from->length;
        1: 1936:      to->text = ck_realloc (to->text, to->alloc);
call    0 returned 1
        -: 1937:    }
       28: 1938:  bcopy (from->text, to->text, from->length);
       28: 1939:  to->length = from->length;
       28: 1940:}
        -: 1941:
        -: 1942:/* Append the contents of the line 'from' to the line 'to'.
        -: 1943:   This routine will work even if the line 'from' contains nulls */
        -: 1944:void
function line_append called 22 returned 100% blocks executed 100%
       22: 1945:line_append (from, to)
        -: 1946:     struct line *from, *to;
        -: 1947:{
       22: 1948:  if (from->length > (to->alloc - to->length))
branch  0 taken 6 (fallthrough)
branch  1 taken 16
        -: 1949:    {
        6: 1950:      to->alloc += from->length;
        6: 1951:      to->text = ck_realloc (to->text, to->alloc);
call    0 returned 6
        -: 1952:    }
       22: 1953:  bcopy (from->text, to->text + to->length, from->length);
       22: 1954:  to->length += from->length;
       22: 1955:}
        -: 1956:
        -: 1957:/* Append 'length' bytes from 'string' to the line 'to'
        -: 1958:   This routine *will* append bytes with nulls in them, without
        -: 1959:   failing. */
        -: 1960:void
function str_append called 5132 returned 100% blocks executed 100%
     5132: 1961:str_append (to, string, length)
        -: 1962:     struct line *to;
        -: 1963:     char *string;
        -: 1964:     int length;
        -: 1965:{
     5132: 1966:  if (length > to->alloc - to->length)
branch  0 taken 18 (fallthrough)
branch  1 taken 5114
        -: 1967:    {
       18: 1968:      to->alloc += length;
       18: 1969:      to->text = ck_realloc (to->text, to->alloc);
call    0 returned 18
        -: 1970:    }
     5132: 1971:  bcopy (string, to->text + to->length, length);
     5132: 1972:  to->length += length;
     5132: 1973:}
        -: 1974:
        -: 1975:void
function usage called 7 returned 0% blocks executed 100%
        7: 1976:usage (status)
        -: 1977:     int status;
        -: 1978:{
        7: 1979:  fprintf (status ? stderr : stdout, "\
call    0 returned 7
        -: 1980:Usage: %s [-nV] [--quiet] [--silent] [--version] [-e script]\n\
        -: 1981:        [-f script-file] [--expression=script] [--file=script-file] [file...]\n",
        -: 1982:	   myname);
        7: 1983:  exit (status);
        -: 1984:}
        -: 1985:/*  Functions from hack's utils library.
        -: 1986:    Copyright (C) 1989, 1990, 1991 Free Software Foundation, Inc.
        -: 1987:
        -: 1988:    This program is free software; you can redistribute it and/or modify
        -: 1989:    it under the terms of the GNU General Public License as published by
        -: 1990:    the Free Software Foundation; either version 2, or (at your option)
        -: 1991:    any later version.
        -: 1992:
        -: 1993:    This program is distributed in the hope that it will be useful,
        -: 1994:    but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 1995:    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 1996:    GNU General Public License for more details.
        -: 1997:
        -: 1998:    You should have received a copy of the GNU General Public License
        -: 1999:    along with this program; if not, write to the Free Software
        -: 2000:    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
        -: 2001:
        -: 2002:/* These routines were written as part of a library (by hack), but since most
        -: 2003:   people don't have the library, here they are.  */
        -: 2004:
        -: 2005:#ifdef __STDC__
        -: 2006:#define VOID void
        -: 2007:#else
        -: 2008:#define VOID char
        -: 2009:#endif
        -: 2010:
        -: 2011:#include <stdio.h>
        -: 2012:#if HAVE_STRING_H || defined(STDC_HEADERS)
        -: 2013:#include <string.h>
        -: 2014:#else
        -: 2015:#include <strings.h>
        -: 2016:#endif
        -: 2017:#if defined(STDC_HEADERS)
        -: 2018:#include <stdlib.h>
        -: 2019:#else
        -: 2020:#ifdef RX_MEMDBUG
        -: 2021:#include <sys/types.h>
        -: 2022:#include <malloc.h>
        -: 2023:#else
        -: 2024:VOID *malloc();
        -: 2025:VOID *realloc();
        -: 2026:#endif /* ndef RX_MEMDBUG  */
        -: 2027:#endif
        -: 2028:
        -: 2029:VOID *ck_malloc();
        -: 2030:
        -: 2031:char *myname;
        -: 2032:
        -: 2033:
        -: 2034:#ifdef __STDC__
        -: 2035:#include <stdarg.h>
        -: 2036:
        -: 2037:/* Print an error message and exit */
        -: 2038:void
function panic called 2 returned 0% blocks executed 100%
        2: 2039:panic(char *str, ...)
        -: 2040:{
        -: 2041:	va_list iggy;
        -: 2042:
        2: 2043:	fprintf(stderr,"%s: ",myname);
call    0 returned 2
        2: 2044:	va_start(iggy,str);
        -: 2045:#ifdef HAVE_VPRINTF
        2: 2046:	vfprintf(stderr,str,iggy);
call    0 returned 2
        -: 2047:#else
        -: 2048:#ifdef HAVE_DOPRNT
        -: 2049:	_doprnt(str,&iggy,stderr);
        -: 2050:#endif
        -: 2051:#endif
        2: 2052:	va_end(iggy);
        2: 2053:	putc('\n',stderr);
call    0 returned 2
        2: 2054:	exit(4);
        -: 2055:}
        -: 2056:
        -: 2057:#else
        -: 2058:#include <varargs.h>
        -: 2059:
        -: 2060:void
        -: 2061:panic(str,va_alist)
        -: 2062:char *str;
        -: 2063:va_dcl
        -: 2064:{
        -: 2065:	va_list iggy;
        -: 2066:
        -: 2067:	fprintf(stderr,"%s: ",myname);
        -: 2068:	va_start(iggy);
        -: 2069:#ifdef HAVE_VPRINTF
        -: 2070:	vfprintf(stderr,str,iggy);
        -: 2071:#else
        -: 2072:#ifdef HAVE_DOPRNT
        -: 2073:	_doprnt(str,&iggy,stderr);
        -: 2074:#endif
        -: 2075:#endif
        -: 2076:	va_end(iggy);
        -: 2077:	putc('\n',stderr);
        -: 2078:	exit(4);
        -: 2079:}
        -: 2080:
        -: 2081:#endif
        -: 2082:
        -: 2083:/* Store information about files opened with ck_fopen
        -: 2084:   so that error messages from ck_fread, etc can print the
        -: 2085:   name of the file that had the error */
        -: 2086:#define N_FILE 32
        -: 2087:
        -: 2088:struct id {
        -: 2089:	FILE *fp;
        -: 2090:	char *name;
        -: 2091:};
        -: 2092:
        -: 2093:static struct id __id_s[N_FILE];
        -: 2094:
        -: 2095:/* Internal routine to get a filename from __id_s */
        -: 2096:char *
function __fp_name called 0 returned 0% blocks executed 0%
    #####: 2097:__fp_name(fp)
        -: 2098:FILE *fp;
        -: 2099:{
        -: 2100:	int n;
        -: 2101:
    #####: 2102:	for(n=0;n<N_FILE;n++) {
branch  0 never executed
branch  1 never executed
    #####: 2103:		if(__id_s[n].fp==fp)
branch  0 never executed
branch  1 never executed
    #####: 2104:			return __id_s[n].name;
        -: 2105:	}
    #####: 2106:	return "{Unknown file pointer}";
        -: 2107:}
        -: 2108:
        -: 2109:/* Panic on failing fopen */
        -: 2110:FILE *
function ck_fopen called 232 returned 99% blocks executed 86%
      232: 2111:ck_fopen(name,mode)
        -: 2112:char *name;
        -: 2113:char *mode;
        -: 2114:{
        -: 2115:	FILE	*ret;
        -: 2116:	int	n;
        -: 2117:
      232: 2118:	ret=fopen(name,mode);
call    0 returned 232
      232: 2119:	if(ret==(FILE *)0)
branch  0 taken 2 (fallthrough)
branch  1 taken 230
        2: 2120:		panic("Couldn't open file %s",name);
call    0 returned 0
     7590: 2121:	for(n=0;n<N_FILE;n++) {
branch  0 taken 7360
branch  1 taken 230 (fallthrough)
     7360: 2122:		if(ret==__id_s[n].fp) {
branch  0 taken 0 (fallthrough)
branch  1 taken 7360
    #####: 2123:			free((VOID *)__id_s[n].name);
    #####: 2124:			__id_s[n].name=(char *)ck_malloc(strlen(name)+1);
call    0 never executed
    #####: 2125:			strcpy(__id_s[n].name,name);
    #####: 2126:			break;
        -: 2127:		}
        -: 2128:	}
      230: 2129:	if(n==N_FILE) {
branch  0 taken 230 (fallthrough)
branch  1 taken 0
      340: 2130:		for(n=0;n<N_FILE;n++)
branch  0 taken 340
branch  1 taken 0 (fallthrough)
      340: 2131:			if(__id_s[n].fp==(FILE *)0)
branch  0 taken 230 (fallthrough)
branch  1 taken 110
      230: 2132:				break;
      230: 2133:		if(n==N_FILE)
branch  0 taken 0 (fallthrough)
branch  1 taken 230
    #####: 2134:			panic("Internal error: too many files open");
call    0 never executed
      230: 2135:		__id_s[n].fp=ret;
      230: 2136:		__id_s[n].name=(char *)ck_malloc(strlen(name)+1);
call    0 returned 230
      230: 2137:		strcpy(__id_s[n].name,name);
        -: 2138:	}
      230: 2139:	return ret;
        -: 2140:}
        -: 2141:
        -: 2142:/* Panic on failing fwrite */
        -: 2143:void
function ck_fwrite called 13292 returned 100% blocks executed 60%
    13292: 2144:ck_fwrite(ptr,size,nmemb,stream)
        -: 2145:char *ptr;
        -: 2146:int size,nmemb;
        -: 2147:FILE *stream;
        -: 2148:{
    13292: 2149:	if(fwrite(ptr,size,nmemb,stream)!=nmemb)
call    0 returned 13292
branch  1 taken 0 (fallthrough)
branch  2 taken 13292
    #####: 2150:		panic("couldn't write %d items to %s",nmemb,__fp_name(stream));
call    0 never executed
call    1 never executed
    13292: 2151:}
        -: 2152:
        -: 2153:/* Panic on failing fclose */
        -: 2154:void
function ck_fclose called 174 returned 100% blocks executed 60%
      174: 2155:ck_fclose(stream)
        -: 2156:FILE *stream;
        -: 2157:{
      174: 2158:	if(fclose(stream)==EOF)
call    0 returned 174
branch  1 taken 0 (fallthrough)
branch  2 taken 174
    #####: 2159:		panic("Couldn't close %s",__fp_name(stream));
call    0 never executed
call    1 never executed
      174: 2160:}
        -: 2161:
        -: 2162:/* Panic on failing malloc */
        -: 2163:VOID *
function ck_malloc called 3198 returned 100% blocks executed 67%
     3198: 2164:ck_malloc(size)
        -: 2165:int size;
        -: 2166:{
        -: 2167:	VOID *ret;
        -: 2168:
     3198: 2169:	if(!size)
branch  0 taken 0 (fallthrough)
branch  1 taken 3198
    #####: 2170:		size++;
     3198: 2171:	ret=malloc(size);
     3198: 2172:	if(ret==(VOID *)0)
branch  0 taken 0 (fallthrough)
branch  1 taken 3198
    #####: 2173:		panic("Couldn't allocate memory");
call    0 never executed
     3198: 2174:	return ret;
        -: 2175:}
        -: 2176:
        -: 2177:/* Panic on failing malloc */
        -: 2178:VOID *
function xmalloc called 0 returned 0% blocks executed 0%
    #####: 2179:xmalloc(size)
        -: 2180:int size;
        -: 2181:{
    #####: 2182:  return ck_malloc (size);
call    0 never executed
        -: 2183:}
        -: 2184:
        -: 2185:/* Panic on failing realloc */
        -: 2186:VOID *
function ck_realloc called 315 returned 100% blocks executed 57%
      315: 2187:ck_realloc(ptr,size)
        -: 2188:VOID *ptr;
        -: 2189:int size;
        -: 2190:{
        -: 2191:	VOID *ret;
        -: 2192:
      315: 2193:	if (!ptr)
branch  0 taken 0 (fallthrough)
branch  1 taken 315
    #####: 2194:	  return ck_malloc (size);
call    0 never executed
      315: 2195:	ret=realloc(ptr,size);
      315: 2196:	if(ret==(VOID *)0)
branch  0 taken 0 (fallthrough)
branch  1 taken 315
    #####: 2197:		panic("Couldn't re-allocate memory");
call    0 never executed
      315: 2198:	return ret;
        -: 2199:}
        -: 2200:
        -: 2201:/* Return a malloc()'d copy of a string */
        -: 2202:char *
function ck_strdup called 75 returned 100% blocks executed 100%
       75: 2203:ck_strdup(str)
        -: 2204:char *str;
        -: 2205:{
        -: 2206:	char *ret;
        -: 2207:
       75: 2208:	ret=(char *)ck_malloc(strlen(str)+2);
call    0 returned 75
       75: 2209:	strcpy(ret,str);
       75: 2210:	return ret;
        -: 2211:}
        -: 2212:
        -: 2213:
        -: 2214:/* Implement a variable sized buffer of 'stuff'.  We don't know what it is,
        -: 2215:   nor do we care, as long as it doesn't mind being aligned by malloc. */
        -: 2216:
        -: 2217:struct buffer {
        -: 2218:	int	allocated;
        -: 2219:	int	length;
        -: 2220:	char	*b;
        -: 2221:};
        -: 2222:
        -: 2223:#define MIN_ALLOCATE 50
        -: 2224:
        -: 2225:VOID *
function init_buffer called 452 returned 100% blocks executed 100%
      452: 2226:init_buffer()
        -: 2227:{
        -: 2228:	struct buffer *b;
        -: 2229:
      452: 2230:	b=(struct buffer *)ck_malloc(sizeof(struct buffer));
call    0 returned 452
      452: 2231:	b->allocated=MIN_ALLOCATE;
      452: 2232:	b->b=(char *)ck_malloc(MIN_ALLOCATE);
call    0 returned 452
      452: 2233:	b->length=0;
      452: 2234:	return (VOID *)b;
        -: 2235:}
        -: 2236:
        -: 2237:void
function flush_buffer called 452 returned 100% blocks executed 100%
      452: 2238:flush_buffer(bb)
        -: 2239:VOID *bb;
        -: 2240:{
        -: 2241:	struct buffer *b;
        -: 2242:
      452: 2243:	b=(struct buffer *)bb;
      452: 2244:	free(b->b);
      452: 2245:	b->b=0;
      452: 2246:	b->allocated=0;
      452: 2247:	b->length=0;
      452: 2248:	free(b);
      452: 2249:}
        -: 2250:
        -: 2251:int
function size_buffer called 1147 returned 100% blocks executed 100%
     1147: 2252:size_buffer(b)
        -: 2253:VOID *b;
        -: 2254:{
        -: 2255:	struct buffer *bb;
        -: 2256:
     1147: 2257:	bb=(struct buffer *)b;
     1147: 2258:	return bb->length;
        -: 2259:}
        -: 2260:
        -: 2261:void
function add_buffer called 0 returned 0% blocks executed 0%
    #####: 2262:add_buffer(bb,p,n)
        -: 2263:VOID *bb;
        -: 2264:char *p;
        -: 2265:int n;
        -: 2266:{
        -: 2267:	struct buffer *b;
        -: 2268:	int x;
        -: 2269:	char * cp;
        -: 2270:
    #####: 2271:	b=(struct buffer *)bb;
    #####: 2272:	if(b->length+n>b->allocated) {
branch  0 never executed
branch  1 never executed
        -: 2273:	#ifndef FAULTY_F_AG_6
    #####: 2274:		b->allocated = (b->length + n) * 2;
        -: 2275:	#else
        -: 2276:		b->allocated = (b->allocated + n) * 2;
        -: 2277:	#endif
    #####: 2278:		b->b=(char *)ck_realloc(b->b,b->allocated);
call    0 never executed
        -: 2279:	}
        -: 2280:	
    #####: 2281:	x = n;
    #####: 2282:	cp = b->b + b->length;
    #####: 2283:	while (x--)
branch  0 never executed
branch  1 never executed
    #####: 2284:	  *cp++ = *p++;
    #####: 2285:	b->length+=n;
    #####: 2286:}
        -: 2287:
        -: 2288:void
function add1_buffer called 3244 returned 100% blocks executed 50%
     3244: 2289:add1_buffer(bb,ch)
        -: 2290:VOID *bb;
        -: 2291:int ch;
        -: 2292:{
        -: 2293:	struct buffer *b;
        -: 2294:
     3244: 2295:	b=(struct buffer *)bb;
     3244: 2296:	if(b->length+1>b->allocated) {
branch  0 taken 0 (fallthrough)
branch  1 taken 3244
    #####: 2297:		b->allocated*=2;
    #####: 2298:		b->b=(char *)ck_realloc(b->b,b->allocated);
call    0 never executed
        -: 2299:	}
     3244: 2300:	b->b[b->length]=ch;
     3244: 2301:	b->length++;
     3244: 2302:}
        -: 2303:
        -: 2304:char *
function get_buffer called 453 returned 100% blocks executed 100%
      453: 2305:get_buffer(bb)
        -: 2306:VOID *bb;
        -: 2307:{
        -: 2308:	struct buffer *b;
        -: 2309:
      453: 2310:	b=(struct buffer *)bb;
      453: 2311:	return b->b;
        -: 2312:}
        -: 2313:/*	Copyright (C) 1992, 1993 Free Software Foundation, Inc.
        -: 2314:
        -: 2315:This program is free software; you can redistribute it and/or modify
        -: 2316:it under the terms of the GNU General Public License as published by
        -: 2317:the Free Software Foundation; either version 2, or (at your option)
        -: 2318:any later version.
        -: 2319:
        -: 2320:This program is distributed in the hope that it will be useful,
        -: 2321:but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 2322:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 2323:GNU General Public License for more details.
        -: 2324:
        -: 2325:You should have received a copy of the GNU General Public License
        -: 2326:along with this software; see the file COPYING.  If not, write to
        -: 2327:the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
        -: 2328:
        -: 2329:/* NOTE!!!  AIX requires this to be the first thing in the file.
        -: 2330: * Do not put ANYTHING before it!  
        -: 2331: */
        -: 2332:#if !defined (__GNUC__) && defined (_AIX)
        -: 2333: #pragma alloca
        -: 2334:#endif
        -: 2335:
        -: 2336:static char rx_version_string[] = "GNU Rx version 0.03";
        -: 2337:
        -: 2338:			/* ``Too hard!''
        -: 2339:			 *	    -- anon.
        -: 2340:			 */
        -: 2341:
        -: 2342:/* N.B.:
        -: 2343: *
        -: 2344: * I think Joe Keane thought of the clever name `superstate'.
        -: 2345: */
        -: 2346:
        -: 2347:
        -: 2348:#include <stdio.h>
        -: 2349:#include <ctype.h>
        -: 2350:#ifndef isgraph
        -: 2351:#define isgraph(c) (isprint (c) && !isspace (c))
        -: 2352:#endif
        -: 2353:#ifndef isblank
        -: 2354:#define isblank(c) ((c) == ' ' || (c) == '\t')
        -: 2355:#endif
        -: 2356:
        -: 2357:#include <sys/types.h>
        -: 2358:#include <stdio.h>
        -: 2359:#include "rx.h"
        -: 2360:
        -: 2361:#undef MAX
        -: 2362:#undef MIN
        -: 2363:#define MAX(a, b) ((a) > (b) ? (a) : (b))
        -: 2364:#define MIN(a, b) ((a) < (b) ? (a) : (b))
        -: 2365:
        -: 2366:typedef char boolean;
        -: 2367:#define false 0
        -: 2368:#define true 1
        -: 2369:
        -: 2370:
        -: 2371:/* This page is decls to the interesting subsystems and lower layers
        -: 2372: * of rx.  Everything which doesn't have a public counterpart in 
        -: 2373: * regex.c is declared here.
        -: 2374: * 
        -: 2375: * A useful (i hope) system is obtained by removing all or part of the regex.c
        -: 2376: * reimplementation and making these all extern.  I think this package
        -: 2377: * could be used to implement on-line lexers and parsers and who knows what 
        -: 2378: * else.
        -: 2379: */
        -: 2380:/* In the definitions, these functions are qualified by `RX_DECL' */
        -: 2381:#define RX_DECL static
        -: 2382:
        -: 2383:#ifdef __STDC__
        -: 2384:
        -: 2385:RX_DECL int rx_bitset_is_subset (int size, rx_Bitset a, rx_Bitset b);
        -: 2386:RX_DECL void rx_bitset_null (int size, rx_Bitset b);
        -: 2387:RX_DECL void rx_bitset_universe (int size, rx_Bitset b);
        -: 2388:RX_DECL void rx_bitset_complement (int size, rx_Bitset b);
        -: 2389:RX_DECL void rx_bitset_assign (int size, rx_Bitset a, rx_Bitset b);
        -: 2390:RX_DECL void rx_bitset_union (int size, rx_Bitset a, rx_Bitset b);
        -: 2391:RX_DECL void rx_bitset_intersection (int size,
        -: 2392:				     rx_Bitset a, rx_Bitset b);
        -: 2393:RX_DECL void rx_bitset_difference (int size, rx_Bitset a, rx_Bitset b);
        -: 2394:RX_DECL unsigned long rx_bitset_hash (int size, rx_Bitset b);
        -: 2395:RX_DECL struct rx_hash_item * rx_hash_find (struct rx_hash * table,
        -: 2396:					    unsigned long hash,
        -: 2397:					    void * value,
        -: 2398:					    struct rx_hash_rules * rules);
        -: 2399:RX_DECL struct rx_hash_item * rx_hash_store (struct rx_hash * table,
        -: 2400:					     unsigned long hash,
        -: 2401:					     void * value,
        -: 2402:					     struct rx_hash_rules * rules);
        -: 2403:RX_DECL void rx_hash_free (struct rx_hash_item * it,
        -: 2404:			   struct rx_hash_rules * rules);
        -: 2405:RX_DECL rx_Bitset rx_cset (struct rx *rx);
        -: 2406:RX_DECL rx_Bitset rx_copy_cset (struct rx *rx, rx_Bitset a);
        -: 2407:RX_DECL void rx_free_cset (struct rx * rx, rx_Bitset c);
        -: 2408:RX_DECL struct rexp_node * rexp_node (struct rx *rx,
        -: 2409:				      enum rexp_node_type type);
        -: 2410:RX_DECL struct rexp_node * rx_mk_r_cset (struct rx * rx,
        -: 2411:					 rx_Bitset b);
        -: 2412:RX_DECL struct rexp_node * rx_mk_r_concat (struct rx * rx,
        -: 2413:					   struct rexp_node * a,
        -: 2414:					   struct rexp_node * b);
        -: 2415:RX_DECL struct rexp_node * rx_mk_r_alternate (struct rx * rx,
        -: 2416:					      struct rexp_node * a,
        -: 2417:					      struct rexp_node * b);
        -: 2418:RX_DECL struct rexp_node * rx_mk_r_opt (struct rx * rx,
        -: 2419:					struct rexp_node * a);
        -: 2420:RX_DECL struct rexp_node * rx_mk_r_star (struct rx * rx,
        -: 2421:					 struct rexp_node * a);
        -: 2422:RX_DECL struct rexp_node * rx_mk_r_2phase_star (struct rx * rx,
        -: 2423:						struct rexp_node * a,
        -: 2424:						struct rexp_node * b);
        -: 2425:RX_DECL struct rexp_node * rx_mk_r_side_effect (struct rx * rx,
        -: 2426:						rx_side_effect a);
        -: 2427:RX_DECL struct rexp_node * rx_mk_r_data  (struct rx * rx,
        -: 2428:					  void * a);
        -: 2429:RX_DECL void rx_free_rexp (struct rx * rx, struct rexp_node * node);
        -: 2430:RX_DECL struct rexp_node * rx_copy_rexp (struct rx *rx,
        -: 2431:					 struct rexp_node *node);
        -: 2432:RX_DECL struct rx_nfa_state * rx_nfa_state (struct rx *rx);
        -: 2433:RX_DECL void rx_free_nfa_state (struct rx_nfa_state * n);
        -: 2434:RX_DECL struct rx_nfa_state * rx_id_to_nfa_state (struct rx * rx,
        -: 2435:						  int id);
        -: 2436:RX_DECL struct rx_nfa_edge * rx_nfa_edge (struct rx *rx,
        -: 2437:					  enum rx_nfa_etype type,
        -: 2438:					  struct rx_nfa_state *start,
        -: 2439:					  struct rx_nfa_state *dest);
        -: 2440:RX_DECL void rx_free_nfa_edge (struct rx_nfa_edge * e);
        -: 2441:RX_DECL void rx_free_nfa (struct rx *rx);
        -: 2442:RX_DECL int rx_build_nfa (struct rx *rx,
        -: 2443:			  struct rexp_node *rexp,
        -: 2444:			  struct rx_nfa_state **start,
        -: 2445:			  struct rx_nfa_state **end);
        -: 2446:RX_DECL void rx_name_nfa_states (struct rx *rx);
        -: 2447:RX_DECL int rx_eclose_nfa (struct rx *rx);
        -: 2448:RX_DECL void rx_delete_epsilon_transitions (struct rx *rx);
        -: 2449:RX_DECL int rx_compactify_nfa (struct rx *rx,
        -: 2450:			       void **mem, unsigned long *size);
        -: 2451:RX_DECL struct rx_superset * rx_superstate_eclosure_union
        -: 2452:  (struct rx * rx, struct rx_superset *set, struct rx_nfa_state_set *ecl) ;
        -: 2453:RX_DECL void rx_release_superset (struct rx *rx,
        -: 2454:				  struct rx_superset *set);
        -: 2455:RX_DECL struct rx_superstate * rx_superstate (struct rx *rx,
        -: 2456:					      struct rx_superset *set);
        -: 2457:RX_DECL struct rx_inx * rx_handle_cache_miss
        -: 2458:  (struct rx *rx, struct rx_superstate *super, unsigned char chr, void *data) ;
        -: 2459:
        -: 2460:#else /* ndef __STDC__ */
        -: 2461:RX_DECL int rx_bitset_is_subset ();
        -: 2462:RX_DECL void rx_bitset_null ();
        -: 2463:RX_DECL void rx_bitset_universe ();
        -: 2464:RX_DECL void rx_bitset_complement ();
        -: 2465:RX_DECL void rx_bitset_assign ();
        -: 2466:RX_DECL void rx_bitset_union ();
        -: 2467:RX_DECL void rx_bitset_intersection ();
        -: 2468:RX_DECL void rx_bitset_difference ();
        -: 2469:RX_DECL unsigned long rx_bitset_hash ();
        -: 2470:RX_DECL struct rx_hash_item * rx_hash_find ();
        -: 2471:RX_DECL struct rx_hash_item * rx_hash_store ();
        -: 2472:RX_DECL void rx_hash_free ();
        -: 2473:RX_DECL rx_Bitset rx_cset ();
        -: 2474:RX_DECL rx_Bitset rx_copy_cset ();
        -: 2475:RX_DECL void rx_free_cset ();
        -: 2476:RX_DECL struct rexp_node * rexp_node ();
        -: 2477:RX_DECL struct rexp_node * rx_mk_r_cset ();
        -: 2478:RX_DECL struct rexp_node * rx_mk_r_concat ();
        -: 2479:RX_DECL struct rexp_node * rx_mk_r_alternate ();
        -: 2480:RX_DECL struct rexp_node * rx_mk_r_opt ();
        -: 2481:RX_DECL struct rexp_node * rx_mk_r_star ();
        -: 2482:RX_DECL struct rexp_node * rx_mk_r_2phase_star ();
        -: 2483:RX_DECL struct rexp_node * rx_mk_r_side_effect ();
        -: 2484:RX_DECL struct rexp_node * rx_mk_r_data  ();
        -: 2485:RX_DECL void rx_free_rexp ();
        -: 2486:RX_DECL struct rexp_node * rx_copy_rexp ();
        -: 2487:RX_DECL struct rx_nfa_state * rx_nfa_state ();
        -: 2488:RX_DECL void rx_free_nfa_state ();
        -: 2489:RX_DECL struct rx_nfa_state * rx_id_to_nfa_state ();
        -: 2490:RX_DECL struct rx_nfa_edge * rx_nfa_edge ();
        -: 2491:RX_DECL void rx_free_nfa_edge ();
        -: 2492:RX_DECL void rx_free_nfa ();
        -: 2493:RX_DECL int rx_build_nfa ();
        -: 2494:RX_DECL void rx_name_nfa_states ();
        -: 2495:RX_DECL int rx_eclose_nfa ();
        -: 2496:RX_DECL void rx_delete_epsilon_transitions ();
        -: 2497:RX_DECL int rx_compactify_nfa ();
        -: 2498:RX_DECL struct rx_superset * rx_superstate_eclosure_union ();
        -: 2499:RX_DECL void rx_release_superset ();
        -: 2500:RX_DECL struct rx_superstate * rx_superstate ();
        -: 2501:RX_DECL struct rx_inx * rx_handle_cache_miss ();
        -: 2502:  
        -: 2503:#endif /* ndef __STDC__ */
        -: 2504:
        -: 2505:
        -: 2506:
        -: 2507:/* Emacs already defines alloca, sometimes.  */
        -: 2508:#ifndef alloca
        -: 2509:
        -: 2510:/* Make alloca work the best possible way.  */
        -: 2511:#ifdef __GNUC__
        -: 2512:#define alloca __builtin_alloca
        -: 2513:#else /* not __GNUC__ */
        -: 2514:#if HAVE_ALLOCA_H
        -: 2515:#include <alloca.h>
        -: 2516:#else /* not __GNUC__ or HAVE_ALLOCA_H */
        -: 2517:#ifndef _AIX /* Already did AIX, up at the top.  */
        -: 2518:char *alloca ();
        -: 2519:#endif /* not _AIX */
        -: 2520:#endif /* not HAVE_ALLOCA_H */ 
        -: 2521:#endif /* not __GNUC__ */
        -: 2522:
        -: 2523:#endif /* not alloca */
        -: 2524:
        -: 2525:
        -: 2526:/* Should we use malloc or alloca?  If REGEX_MALLOC is not defined, we
        -: 2527: * use `alloca' instead of `malloc' for the backtracking stack.
        -: 2528: *
        -: 2529: * Emacs will die miserably if we don't do this.
        -: 2530: */
        -: 2531:
        -: 2532:#ifdef REGEX_MALLOC
        -: 2533:
        -: 2534:#define REGEX_ALLOCATE malloc
        -: 2535:
        -: 2536:#else /* not REGEX_MALLOC  */
        -: 2537:
        -: 2538:#define REGEX_ALLOCATE alloca
        -: 2539:
        -: 2540:#endif /* not REGEX_MALLOC */
        -: 2541:
        -: 2542:
        -: 2543:
        -: 2544:
        -: 2545:/* Memory management and stuff for emacs. */
        -: 2546:
        -: 2547:#define BYTEWIDTH 8 /* In bits.  */
        -: 2548:
        -: 2549:/* (Re)Allocate N items of type T using malloc.  */
        -: 2550:#define TALLOC(n, t) ((t *) malloc ((n) * sizeof (t)))
        -: 2551:#define RETALLOC(addr, n, t) ((addr) = (t *) realloc (addr, (n) * sizeof (t)))
        -: 2552:
        -: 2553:#define remalloc(M, S) (M ? realloc (M, S) : malloc (S))
        -: 2554:
        -: 2555:#ifdef emacs
        -: 2556:/* The `emacs' switch turns on certain matching commands
        -: 2557: * that make sense only in Emacs. 
        -: 2558: */
        -: 2559:
        -: 2560:#include "config.h"
        -: 2561:#include "lisp.h"
        -: 2562:#include "buffer.h"
        -: 2563:#include "syntax.h"
        -: 2564:
        -: 2565:/* Emacs uses `NULL' as a predicate.  */
        -: 2566:#undef NULL
        -: 2567:#else  /* not emacs */
        -: 2568:
        -: 2569:/* Setting RX_MEMDBUG is useful if you have dbmalloc.  Maybe with similar
        -: 2570: * packages too.
        -: 2571: */
        -: 2572:#ifdef RX_MEMDBUG
        -: 2573:#include <malloc.h>
        -: 2574:#else /* not RX_RX_MEMDBUG */
        -: 2575:
        -: 2576:/* We used to test for `BSTRING' here, but only GCC and Emacs define
        -: 2577: * `BSTRING', as far as I know, and neither of them use this code.  
        -: 2578: */
        -: 2579:#if HAVE_STRING_H || STDC_HEADERS
        -: 2580:#include <string.h>
        -: 2581:#ifndef bcmp
        -: 2582:#define bcmp(s1, s2, n)	memcmp ((s1), (s2), (n))
        -: 2583:#endif
        -: 2584:#ifndef bcopy
        -: 2585:#define bcopy(s, d, n)	memcpy ((d), (s), (n))
        -: 2586:#endif
        -: 2587:#ifndef bzero
        -: 2588:#define bzero(s, n)	memset ((s), 0, (n))
        -: 2589:#endif
        -: 2590:#else
        -: 2591:#include <strings.h>
        -: 2592:#endif
        -: 2593:
        -: 2594:#ifdef STDC_HEADERS
        -: 2595:#include <stdlib.h>
        -: 2596:#else /* not STDC_HEADERS */
        -: 2597:
        -: 2598:char *malloc ();
        -: 2599:char *realloc ();
        -: 2600:#endif /* not STDC_HEADERS */
        -: 2601:
        -: 2602:#endif /* not RX_RX_MEMDBUG */
        -: 2603:
        -: 2604:
        -: 2605:
        -: 2606:/* Define the syntax basics for \<, \>, etc.
        -: 2607: * This must be nonzero for the wordchar and notwordchar pattern
        -: 2608: * commands in re_match_2.
        -: 2609: */
        -: 2610:#ifndef Sword 
        -: 2611:#define Sword 1
        -: 2612:#endif
        -: 2613:
        -: 2614:#ifdef SYNTAX_TABLE
        -: 2615:extern char *re_syntax_table;
        -: 2616:#else /* not SYNTAX_TABLE */
        -: 2617:
        -: 2618:/* How many characters in the character set.  */
        -: 2619:#define CHAR_SET_SIZE (1 << BYTEWIDTH)
        -: 2620:static char re_syntax_table[CHAR_SET_SIZE];
        -: 2621:
        -: 2622:#ifdef __STDC__
        -: 2623:static void
function init_syntax_once called 232 returned 100% blocks executed 100%
      232: 2624:init_syntax_once (void)
        -: 2625:#else
        -: 2626:static void
        -: 2627:init_syntax_once ()
        -: 2628:#endif
        -: 2629:{
        -: 2630:   register int c;
        -: 2631:   static int done = 0;
        -: 2632:
      232: 2633:   if (done)
branch  0 taken 106 (fallthrough)
branch  1 taken 126
      106: 2634:     return;
        -: 2635:
      126: 2636:   bzero (re_syntax_table, sizeof re_syntax_table);
        -: 2637:
     3402: 2638:   for (c = 'a'; c <= 'z'; c++)
branch  0 taken 3276
branch  1 taken 126 (fallthrough)
     3276: 2639:     re_syntax_table[c] = Sword;
        -: 2640:
     3402: 2641:   for (c = 'A'; c <= 'Z'; c++)
branch  0 taken 3276
branch  1 taken 126 (fallthrough)
     3276: 2642:     re_syntax_table[c] = Sword;
        -: 2643:
     1386: 2644:   for (c = '0'; c <= '9'; c++)
branch  0 taken 1260
branch  1 taken 126 (fallthrough)
     1260: 2645:     re_syntax_table[c] = Sword;
        -: 2646:
      126: 2647:   re_syntax_table['_'] = Sword;
        -: 2648:
      126: 2649:   done = 1;
        -: 2650:}
        -: 2651:#endif /* not SYNTAX_TABLE */
        -: 2652:
        -: 2653:#define SYNTAX(c) re_syntax_table[c]
        -: 2654:
        -: 2655:#endif /* not emacs */
        -: 2656:
        -: 2657:
        -: 2658:/* Compile with `-DRX_DEBUG' and use the following flags.
        -: 2659: *
        -: 2660: * Debugging flags:
        -: 2661: *   	rx_debug - print information as a regexp is compiled
        -: 2662: * 	rx_debug_trace - print information as a regexp is executed
        -: 2663: */
        -: 2664:
        -: 2665:#ifdef RX_DEBUG
        -: 2666:
        -: 2667:int rx_debug_compile = 0;
        -: 2668:int rx_debug_trace = 0;
        -: 2669:static struct re_pattern_buffer * dbug_rxb = 0;
        -: 2670:
        -: 2671:#ifdef __STDC__
        -: 2672:typedef void (*side_effect_printer) (struct rx *, void *, FILE *);
        -: 2673:#else
        -: 2674:typedef void (*side_effect_printer) ();
        -: 2675:#endif
        -: 2676:
        -: 2677:#ifdef __STDC__
        -: 2678:static void print_cset (struct rx *rx, rx_Bitset cset, FILE * fp);
        -: 2679:#else
        -: 2680:static void print_cset ();
        -: 2681:#endif
        -: 2682:
        -: 2683:#ifdef __STDC__
        -: 2684:static void
        -: 2685:print_rexp (struct rx *rx,
        -: 2686:	    struct rexp_node *node, int depth,
        -: 2687:	    side_effect_printer seprint, FILE * fp)
        -: 2688:#else
        -: 2689:static void
        -: 2690:print_rexp (rx, node, depth, seprint, fp)
        -: 2691:     struct rx *rx;
        -: 2692:     struct rexp_node *node;
        -: 2693:     int depth;
        -: 2694:     side_effect_printer seprint;
        -: 2695:     FILE * fp;
        -: 2696:#endif
        -: 2697:{
        -: 2698:#ifndef FAULTY_F_AG_7
        -: 2699:  if (!node)
        -: 2700:#else
        -: 2701:  if (node)
        -: 2702:#endif
        -: 2703:    return;
        -: 2704:  else
        -: 2705:    {
        -: 2706:      switch (node->type)
        -: 2707:	{
        -: 2708:	case r_cset:
        -: 2709:	  {
        -: 2710:	    fprintf (fp, "%*s", depth, "");
        -: 2711:	    print_cset (rx, node->params.cset, fp);
        -: 2712:	    fputc ('\n', fp);
        -: 2713:	    break;
        -: 2714:	  }
        -: 2715:
        -: 2716: 	case r_opt:
        -: 2717:	case r_star:
        -: 2718:	  fprintf (fp, "%*s%s\n", depth, "",
        -: 2719:		   node->type == r_opt ? "opt" : "star");
        -: 2720:	  print_rexp (rx, node->params.pair.left, depth + 3, seprint, fp);
        -: 2721:	  break;
        -: 2722:
        -: 2723:	case r_2phase_star:
        -: 2724:	  fprintf (fp, "%*s2phase star\n", depth, "");
        -: 2725:	  print_rexp (rx, node->params.pair.right, depth + 3, seprint, fp);
        -: 2726:	  print_rexp (rx, node->params.pair.left, depth + 3, seprint, fp);
        -: 2727:	  break;
        -: 2728:
        -: 2729:
        -: 2730:	case r_alternate:
        -: 2731:	case r_concat:
        -: 2732:	#ifndef FAULTY_F_AG_8
        -: 2733:	  fprintf (fp, "%*s%s\n", depth, "",
        -: 2734:		   node->type == r_alternate ? "alt" : "concat");
        -: 2735:	#else
        -: 2736:	   fprintf (fp, "%*s%s\n", depth, "",
        -: 2737:		   node->type = r_alternate ? "alt" : "concat");
        -: 2738:        #endif	   
        -: 2739:	  print_rexp (rx, node->params.pair.left, depth + 3, seprint, fp);
        -: 2740:	  print_rexp (rx, node->params.pair.right, depth + 3, seprint, fp);
        -: 2741:	  break;
        -: 2742:	case r_side_effect:
        -: 2743:	  fprintf (fp, "%*sSide effect: ", depth, "");
        -: 2744:	  seprint (rx, node->params.side_effect, fp);
        -: 2745:	  fputc ('\n', fp);
        -: 2746:	}
        -: 2747:    }
        -: 2748:}
        -: 2749:
        -: 2750:
        -: 2751:#ifdef __STDC__
        -: 2752:static void
        -: 2753:print_nfa (struct rx * rx,
        -: 2754:	   struct rx_nfa_state * n,
        -: 2755:	   side_effect_printer seprint, FILE * fp)
        -: 2756:#else
        -: 2757:static void
        -: 2758:print_nfa (rx, n, seprint, fp)
        -: 2759:     struct rx * rx;
        -: 2760:     struct rx_nfa_state * n;
        -: 2761:     side_effect_printer seprint;
        -: 2762:     FILE * fp;
        -: 2763:#endif
        -: 2764:{
        -: 2765:  while (n)
        -: 2766:    {
        -: 2767:      struct rx_nfa_edge *e = n->edges;
        -: 2768:      struct rx_possible_future *ec = n->futures;
        -: 2769:      fprintf (fp, "node %d %s\n", n->id,
        -: 2770:	       n->is_final ? "final" : (n->is_start ? "start" : ""));
        -: 2771:      while (e)
        -: 2772:	{
        -: 2773:	  fprintf (fp, "   edge to %d, ", e->dest->id);
        -: 2774:	  switch (e->type)
        -: 2775:	    {
        -: 2776:	    case ne_epsilon:
        -: 2777:	      fprintf (fp, "epsilon\n");
        -: 2778:	      break;
        -: 2779:	    case ne_side_effect:
        -: 2780:	      fprintf (fp, "side effect ");
        -: 2781:	      seprint (rx, e->params.side_effect, fp);
        -: 2782:	      fputc ('\n', fp);
        -: 2783:	      break;
        -: 2784:	    case ne_cset:
        -: 2785:	      fprintf (fp, "cset ");
        -: 2786:	      print_cset (rx, e->params.cset, fp);
        -: 2787:	      fputc ('\n', fp);
        -: 2788:	      break;
        -: 2789:	    }
        -: 2790:	  e = e->next;
        -: 2791:	}
        -: 2792:
        -: 2793:      while (ec)
        -: 2794:	{
        -: 2795:	  int x;
        -: 2796:	  struct rx_nfa_state_set * s;
        -: 2797:	  struct rx_se_list * l;
        -: 2798:	  fprintf (fp, "   eclosure to {");
        -: 2799:	  for (s = ec->destset; s; s = s->cdr)
        -: 2800:	    fprintf (fp, "%d ", s->car->id);
        -: 2801:	  fprintf (fp, "} (");
        -: 2802:	  for (l = ec->effects; l; l = l->cdr)
        -: 2803:	    {
        -: 2804:	      seprint (rx, l->car, fp);
        -: 2805:	      fputc (' ', fp);
        -: 2806:	    }
        -: 2807:	  fprintf (fp, ")\n");
        -: 2808:	  ec = ec->next;
        -: 2809:	}
        -: 2810:      n = n->next;
        -: 2811:    }
        -: 2812:}
        -: 2813:
        -: 2814:static char * efnames [] =
        -: 2815:{
        -: 2816:  "bogon",
        -: 2817:  "re_se_try",
        -: 2818:  "re_se_pushback",
        -: 2819:  "re_se_push0",
        -: 2820:  "re_se_pushpos",
        -: 2821:  "re_se_chkpos",
        -: 2822:  "re_se_poppos",
        -: 2823:  "re_se_at_dot",
        -: 2824:  "re_se_syntax",
        -: 2825:  "re_se_not_syntax",
        -: 2826:  "re_se_begbuf",
        -: 2827:  "re_se_hat",
        -: 2828:  "re_se_wordbeg",
        -: 2829:  "re_se_wordbound",
        -: 2830:  "re_se_notwordbound",
        -: 2831:  "re_se_wordend",
        -: 2832:  "re_se_endbuf",
        -: 2833:  "re_se_dollar",
        -: 2834:  "re_se_fail",
        -: 2835:};
        -: 2836:
        -: 2837:static char * efnames2[] =
        -: 2838:{
        -: 2839:  "re_se_win"
        -: 2840:  "re_se_lparen",
        -: 2841:  "re_se_rparen",
        -: 2842:  "re_se_backref",
        -: 2843:  "re_se_iter",
        -: 2844:  "re_se_end_iter",
        -: 2845:  "re_se_tv"
        -: 2846:};
        -: 2847:
        -: 2848:static char * inx_names[] = 
        -: 2849:{
        -: 2850:  "rx_backtrack_point",
        -: 2851:  "rx_do_side_effects",
        -: 2852:  "rx_cache_miss",
        -: 2853:  "rx_next_char",
        -: 2854:  "rx_backtrack",
        -: 2855:  "rx_error_inx",
        -: 2856:  "rx_num_instructions"
        -: 2857:};
        -: 2858:
        -: 2859:
        -: 2860:#ifdef __STDC__
        -: 2861:static void
        -: 2862:re_seprint (struct rx * rx, void * effect, FILE * fp)
        -: 2863:#else
        -: 2864:static void
        -: 2865:re_seprint (rx, effect, fp)
        -: 2866:     struct rx * rx;
        -: 2867:     void * effect;
        -: 2868:     FILE * fp;
        -: 2869:#endif
        -: 2870:{
        -: 2871:  if ((int)effect < 0)
        -: 2872:    fputs (efnames[-(int)effect], fp);
        -: 2873:  else if (dbug_rxb)
        -: 2874:    {
        -: 2875:      struct re_se_params * p = &dbug_rxb->se_params[(int)effect];
        -: 2876:      fprintf (fp, "%s(%d,%d)", efnames2[p->se], p->op1, p->op2);
        -: 2877:    }
        -: 2878:  else
        -: 2879:    fprintf (fp, "[complex op # %d]", (int)effect);
        -: 2880:}
        -: 2881:
        -: 2882:
        -: 2883:/* These are for so the regex.c regression tests will compile. */
        -: 2884:void
        -: 2885:print_compiled_pattern (rxb)
        -: 2886:     struct re_pattern_buffer * rxb;
        -: 2887:{
        -: 2888:}
        -: 2889:
        -: 2890:void
        -: 2891:print_fastmap (fm)
        -: 2892:     char * fm;
        -: 2893:{
        -: 2894:}
        -: 2895:
        -: 2896:
        -: 2897:
        -: 2898:#endif /* RX_DEBUG */
        -: 2899:
        -: 2900:
        -: 2901:
        -: 2902:/* This page: Bitsets.  Completely unintersting. */
        -: 2903:
        -: 2904:#if 0
        -: 2905:#ifdef __STDC__
        -: 2906:RX_DECL int
        -: 2907:rx_bitset_is_equal (int size, rx_Bitset a, rx_Bitset b)
        -: 2908:#else
        -: 2909:RX_DECL int
        -: 2910:rx_bitset_is_equal (size, a, b)
        -: 2911:     int size;
        -: 2912:     rx_Bitset a;
        -: 2913:     rx_Bitset b;
        -: 2914:#endif
        -: 2915:{
        -: 2916:  int x;
        -: 2917:  RX_subset s = b[0];
        -: 2918:  b[0] = ~a[0];
        -: 2919:
        -: 2920:  for (x = rx_bitset_numb_subsets(size) - 1; a[x] == b[x]; --x)
        -: 2921:    ;
        -: 2922:
        -: 2923:  b[0] = s;
        -: 2924:  return !x && s == a[0];
        -: 2925:}
        -: 2926:#endif
        -: 2927:
        -: 2928:#ifdef __STDC__
        -: 2929:RX_DECL int
function rx_bitset_is_subset called 750 returned 100% blocks executed 100%
      750: 2930:rx_bitset_is_subset (int size, rx_Bitset a, rx_Bitset b)
        -: 2931:#else
        -: 2932:RX_DECL int
        -: 2933:rx_bitset_is_subset (size, a, b)
        -: 2934:     int size;
        -: 2935:     rx_Bitset a;
        -: 2936:     rx_Bitset b;
        -: 2937:#endif
        -: 2938:{
      750: 2939:  int x = rx_bitset_numb_subsets(size) - 1;
     5668: 2940:  while (x-- && (a[x] & b[x]) == a[x]);
branch  0 taken 5154 (fallthrough)
branch  1 taken 514
branch  2 taken 4918
branch  3 taken 236 (fallthrough)
      750: 2941:  return x == -1;
        -: 2942:}
        -: 2943:
        -: 2944:
        -: 2945:#if 0
        -: 2946:#ifdef __STDC__
        -: 2947:RX_DECL int
        -: 2948:rx_bitset_empty (int size, rx_Bitset set)
        -: 2949:#else
        -: 2950:RX_DECL int
        -: 2951:rx_bitset_empty (size, set)
        -: 2952:     int size;
        -: 2953:     rx_Bitset set;
        -: 2954:#endif
        -: 2955:{
        -: 2956:  int x;
        -: 2957:  RX_subset s = set[0];
        -: 2958:  set[0] = 1;
        -: 2959:  for (x = rx_bitset_numb_subsets(size) - 1; !set[x]; --x)
        -: 2960:    ;
        -: 2961:  set[0] = s;
        -: 2962:  return !s;
        -: 2963:}
        -: 2964:#endif
        -: 2965:
        -: 2966:#ifdef __STDC__
        -: 2967:RX_DECL void
function rx_bitset_null called 4207 returned 100% blocks executed 100%
     4207: 2968:rx_bitset_null (int size, rx_Bitset b)
        -: 2969:#else
        -: 2970:RX_DECL void
        -: 2971:rx_bitset_null (size, b)
        -: 2972:     int size;
        -: 2973:     rx_Bitset b;
        -: 2974:#endif
        -: 2975:{
     4207: 2976:  bzero (b, rx_sizeof_bitset(size));
     4207: 2977:}
        -: 2978:
        -: 2979:
        -: 2980:#ifdef __STDC__
        -: 2981:RX_DECL void
function rx_bitset_universe called 769 returned 100% blocks executed 100%
      769: 2982:rx_bitset_universe (int size, rx_Bitset b)
        -: 2983:#else
        -: 2984:RX_DECL void
        -: 2985:rx_bitset_universe (size, b)
        -: 2986:     int size;
        -: 2987:     rx_Bitset b;
        -: 2988:#endif
        -: 2989:{
      769: 2990:  int x = rx_bitset_numb_subsets (size);
     6921: 2991:  while (x--)
branch  0 taken 6152
branch  1 taken 769 (fallthrough)
     6152: 2992:    *b++ = ~(RX_subset)0;
      769: 2993:}
        -: 2994:
        -: 2995:
        -: 2996:#ifdef __STDC__
        -: 2997:RX_DECL void
function rx_bitset_complement called 1 returned 100% blocks executed 100%
        1: 2998:rx_bitset_complement (int size, rx_Bitset b)
        -: 2999:#else
        -: 3000:RX_DECL void
        -: 3001:rx_bitset_complement (size, b)
        -: 3002:     int size;
        -: 3003:     rx_Bitset b;
        -: 3004:#endif
        -: 3005:{
        1: 3006:  int x = rx_bitset_numb_subsets (size);
        9: 3007:  while (x--)
branch  0 taken 8
branch  1 taken 1 (fallthrough)
        -: 3008:    {
        8: 3009:      *b = ~*b;
        8: 3010:      ++b;
        -: 3011:    }
        1: 3012:}
        -: 3013:
        -: 3014:
        -: 3015:#ifdef __STDC__
        -: 3016:RX_DECL void
function rx_bitset_assign called 583 returned 100% blocks executed 100%
      583: 3017:rx_bitset_assign (int size, rx_Bitset a, rx_Bitset b)
        -: 3018:#else
        -: 3019:RX_DECL void
        -: 3020:rx_bitset_assign (size, a, b)
        -: 3021:     int size;
        -: 3022:     rx_Bitset a;
        -: 3023:     rx_Bitset b;
        -: 3024:#endif
        -: 3025:{
        -: 3026:  int x;
     5247: 3027:  for (x = rx_bitset_numb_subsets(size) - 1; x >=0; --x)
branch  0 taken 4664
branch  1 taken 583 (fallthrough)
     4664: 3028:    a[x] = b[x];
      583: 3029:}
        -: 3030:
        -: 3031:
        -: 3032:#ifdef __STDC__
        -: 3033:RX_DECL void
function rx_bitset_union called 3379 returned 100% blocks executed 100%
     3379: 3034:rx_bitset_union (int size, rx_Bitset a, rx_Bitset b)
        -: 3035:#else
        -: 3036:RX_DECL void
        -: 3037:rx_bitset_union (size, a, b)
        -: 3038:     int size;
        -: 3039:     rx_Bitset a;
        -: 3040:     rx_Bitset b;
        -: 3041:#endif
        -: 3042:{
        -: 3043:  int x;
    30411: 3044:  for (x = rx_bitset_numb_subsets(size) - 1; x >=0; --x)
branch  0 taken 27032
branch  1 taken 3379 (fallthrough)
    27032: 3045:    a[x] |= b[x];
     3379: 3046:}
        -: 3047:
        -: 3048:
        -: 3049:#ifdef __STDC__
        -: 3050:RX_DECL void
function rx_bitset_intersection called 613 returned 100% blocks executed 100%
      613: 3051:rx_bitset_intersection (int size,
        -: 3052:			rx_Bitset a, rx_Bitset b)
        -: 3053:#else
        -: 3054:RX_DECL void
        -: 3055:rx_bitset_intersection (size, a, b)
        -: 3056:     int size;
        -: 3057:     rx_Bitset a;
        -: 3058:     rx_Bitset b;
        -: 3059:#endif
        -: 3060:{
        -: 3061:  int x;
     5517: 3062:  for (x = rx_bitset_numb_subsets(size) - 1; x >=0; --x)
branch  0 taken 4904
branch  1 taken 613 (fallthrough)
     4904: 3063:    a[x] &= b[x];
      613: 3064:}
        -: 3065:
        -: 3066:
        -: 3067:#ifdef __STDC__
        -: 3068:RX_DECL void
function rx_bitset_difference called 335 returned 100% blocks executed 100%
      335: 3069:rx_bitset_difference (int size, rx_Bitset a, rx_Bitset b)
        -: 3070:#else
        -: 3071:RX_DECL void
        -: 3072:rx_bitset_difference (size, a, b)
        -: 3073:     int size;
        -: 3074:     rx_Bitset a;
        -: 3075:     rx_Bitset b;
        -: 3076:#endif
        -: 3077:{
        -: 3078:  int x;
     3015: 3079:  for (x = rx_bitset_numb_subsets(size) - 1; x >=0; --x)
branch  0 taken 2680
branch  1 taken 335 (fallthrough)
     2680: 3080:    a[x] &=  ~ b[x];
      335: 3081:}
        -: 3082:
        -: 3083:
        -: 3084:#if 0
        -: 3085:#ifdef __STDC__
        -: 3086:RX_DECL void
        -: 3087:rx_bitset_revdifference (int size,
        -: 3088:			 rx_Bitset a, rx_Bitset b)
        -: 3089:#else
        -: 3090:RX_DECL void
        -: 3091:rx_bitset_revdifference (size, a, b)
        -: 3092:     int size;
        -: 3093:     rx_Bitset a;
        -: 3094:     rx_Bitset b;
        -: 3095:#endif
        -: 3096:{
        -: 3097:  int x;
        -: 3098:  for (x = rx_bitset_numb_subsets(size) - 1; x >=0; --x)
        -: 3099:    a[x] = ~a[x] & b[x];
        -: 3100:}
        -: 3101:
        -: 3102:#ifdef __STDC__
        -: 3103:RX_DECL void
        -: 3104:rx_bitset_xor (int size, rx_Bitset a, rx_Bitset b)
        -: 3105:#else
        -: 3106:RX_DECL void
        -: 3107:rx_bitset_xor (size, a, b)
        -: 3108:     int size;
        -: 3109:     rx_Bitset a;
        -: 3110:     rx_Bitset b;
        -: 3111:#endif
        -: 3112:{
        -: 3113:  int x;
        -: 3114:  for (x = rx_bitset_numb_subsets(size) - 1; x >=0; --x)
        -: 3115:    a[x] ^= b[x];
        -: 3116:}
        -: 3117:#endif
        -: 3118:
        -: 3119:
        -: 3120:#ifdef __STDC__
        -: 3121:RX_DECL unsigned long
function rx_bitset_hash called 0 returned 0% blocks executed 0%
    #####: 3122:rx_bitset_hash (int size, rx_Bitset b)
        -: 3123:#else
        -: 3124:RX_DECL unsigned long
        -: 3125:rx_bitset_hash (size, b)
        -: 3126:     int size;
        -: 3127:     rx_Bitset b;
        -: 3128:#endif
        -: 3129:{
        -: 3130:  int x;
    #####: 3131:  unsigned long hash = (unsigned long)rx_bitset_hash;
        -: 3132:
    #####: 3133:  for (x = rx_bitset_numb_subsets(size) - 1; x >= 0; --x)
branch  0 never executed
branch  1 never executed
    #####: 3134:    hash ^= rx_bitset_subset_val(b, x);
        -: 3135:
    #####: 3136:  return hash;
        -: 3137:}
        -: 3138:
        -: 3139:
        -: 3140:RX_DECL RX_subset rx_subset_singletons [RX_subset_bits] = 
        -: 3141:{
        -: 3142:  0x1,
        -: 3143:  0x2,
        -: 3144:  0x4,
        -: 3145:  0x8,
        -: 3146:  0x10,
        -: 3147:  0x20,
        -: 3148:  0x40,
        -: 3149:  0x80,
        -: 3150:  0x100,
        -: 3151:  0x200,
        -: 3152:  0x400,
        -: 3153:  0x800,
        -: 3154:  0x1000,
        -: 3155:  0x2000,
        -: 3156:  0x4000,
        -: 3157:  0x8000,
        -: 3158:  0x10000,
        -: 3159:  0x20000,
        -: 3160:  0x40000,
        -: 3161:  0x80000,
        -: 3162:  0x100000,
        -: 3163:  0x200000,
        -: 3164:  0x400000,
        -: 3165:  0x800000,
        -: 3166:  0x1000000,
        -: 3167:  0x2000000,
        -: 3168:  0x4000000,
        -: 3169:  0x8000000,
        -: 3170:  0x10000000,
        -: 3171:  0x20000000,
        -: 3172:  0x40000000,
        -: 3173:  0x80000000
        -: 3174:};
        -: 3175:
        -: 3176:#ifdef RX_DEBUG
        -: 3177:
        -: 3178:#ifdef __STDC__
        -: 3179:static void
        -: 3180:print_cset (struct rx *rx, rx_Bitset cset, FILE * fp)
        -: 3181:#else
        -: 3182:static void
        -: 3183:print_cset (rx, cset, fp)
        -: 3184:     struct rx *rx;
        -: 3185:     rx_Bitset cset;
        -: 3186:     FILE * fp;
        -: 3187:#endif
        -: 3188:{
        -: 3189:  int x;
        -: 3190:  fputc ('[', fp);
        -: 3191:  for (x = 0; x < rx->local_cset_size; ++x)
        -: 3192:    if (isprint(x) && RX_bitset_member (cset, x))
        -: 3193:      fputc (x, fp);
        -: 3194:  fputc (']', fp);
        -: 3195:}
        -: 3196:
        -: 3197:#endif /*  RX_DEBUG */
        -: 3198:
        -: 3199:
        -: 3200:
        -: 3201:static unsigned long rx_hash_masks[4] =
        -: 3202:{
        -: 3203:  0x12488421,
        -: 3204:  0x96699669,
        -: 3205:  0xbe7dd7eb,
        -: 3206:  0xffffffff
        -: 3207:};
        -: 3208:
        -: 3209:
        -: 3210:/* Hash tables */
        -: 3211:#ifdef __STDC__
        -: 3212:RX_DECL struct rx_hash_item * 
function rx_hash_find called 1963 returned 100% blocks executed 82%
     1963: 3213:rx_hash_find (struct rx_hash * table,
        -: 3214:	      unsigned long hash,
        -: 3215:	      void * value,
        -: 3216:	      struct rx_hash_rules * rules)
        -: 3217:#else
        -: 3218:RX_DECL struct rx_hash_item * 
        -: 3219:rx_hash_find (table, hash, value, rules)
        -: 3220:     struct rx_hash * table;
        -: 3221:     unsigned long hash;
        -: 3222:     void * value;
        -: 3223:     struct rx_hash_rules * rules;
        -: 3224:#endif
        -: 3225:{
     1963: 3226:  rx_hash_eq eq = rules->eq;
     1963: 3227:  int maskc = 0;
     1963: 3228:  int mask = rx_hash_masks [0];
     1963: 3229:  int bucket = (hash & mask) % 13;
        -: 3230:
     1963: 3231:  while (table->children [bucket])
branch  0 taken 0
branch  1 taken 1963 (fallthrough)
        -: 3232:    {
    #####: 3233:      table = table->children [bucket];
    #####: 3234:      ++maskc;
    #####: 3235:      mask = rx_hash_masks[maskc];
    #####: 3236:      bucket = (hash & mask) % 13;
        -: 3237:    }
        -: 3238:
        -: 3239:  {
     1963: 3240:    struct rx_hash_item * it = table->buckets[bucket];
     3354: 3241:    while (it)
branch  0 taken 3354
branch  1 taken 0 (fallthrough)
     3354: 3242:      if (eq (it->data, value))
call    0 returned 3354
branch  1 taken 1963 (fallthrough)
branch  2 taken 1391
     1963: 3243:	return it;
        -: 3244:      else
     1391: 3245:	it = it->next_same_hash;
        -: 3246:  }
        -: 3247:
    #####: 3248:  return 0;
        -: 3249:}
        -: 3250:
        -: 3251:#ifdef __STDC__
        -: 3252:RX_DECL struct rx_hash_item *
function rx_hash_store called 3296 returned 100% blocks executed 88%
     3296: 3253:rx_hash_store (struct rx_hash * table,
        -: 3254:	       unsigned long hash,
        -: 3255:	       void * value,
        -: 3256:	       struct rx_hash_rules * rules)
        -: 3257:#else
        -: 3258:RX_DECL struct rx_hash_item *
        -: 3259:rx_hash_store (table, hash, value, rules)
        -: 3260:     struct rx_hash * table;
        -: 3261:     unsigned long hash;
        -: 3262:     void * value;
        -: 3263:     struct rx_hash_rules * rules;
        -: 3264:#endif
        -: 3265:{
     3296: 3266:  rx_hash_eq eq = rules->eq;
     3296: 3267:  int maskc = 0;
     3296: 3268:  int mask = rx_hash_masks[0];
     3296: 3269:  int bucket = (hash & mask) % 13;
     3296: 3270:  int depth = 0;
        -: 3271:  
     3304: 3272:  while (table->children [bucket])
branch  0 taken 8
branch  1 taken 3296 (fallthrough)
        -: 3273:    {
        8: 3274:      table = table->children [bucket];
        8: 3275:      ++maskc;
        8: 3276:      mask = rx_hash_masks[maskc];
        8: 3277:      bucket = (hash & mask) % 13;
        8: 3278:      ++depth;
        -: 3279:    }
        -: 3280:  
        -: 3281:  {
     3296: 3282:    struct rx_hash_item * it = table->buckets[bucket];
     4956: 3283:    while (it)
branch  0 taken 2311
branch  1 taken 2645 (fallthrough)
     2311: 3284:      if (eq (it->data, value))
call    0 returned 2311
branch  1 taken 651 (fallthrough)
branch  2 taken 1660
      651: 3285:	return it;
        -: 3286:      else
     1660: 3287:	it = it->next_same_hash;
        -: 3288:  }
        -: 3289:  
        -: 3290:  {
     2645: 3291:    if (   (depth < 3)
branch  0 taken 0 (fallthrough)
branch  1 taken 2645
     2645: 3292:	&& (table->bucket_size [bucket] >= 4))
branch  0 taken 2643 (fallthrough)
branch  1 taken 2
        -: 3293:      {
        2: 3294:	struct rx_hash * newtab = ((struct rx_hash *)
        2: 3295:				   rules->hash_alloc (rules));
call    0 returned 2
        2: 3296:	if (!newtab)
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####: 3297:	  goto add_to_bucket;
        2: 3298:	bzero (newtab, sizeof (*newtab));
        2: 3299:	newtab->parent = table;
        -: 3300:	{
        2: 3301:	  struct rx_hash_item * them = table->buckets[bucket];
        2: 3302:	  unsigned long newmask = rx_hash_masks[maskc + 1];
       10: 3303:	  while (them)
branch  0 taken 8
branch  1 taken 2 (fallthrough)
        -: 3304:	    {
        8: 3305:	      struct rx_hash_item * save = them->next_same_hash;
        8: 3306:	      int new_buck = (them->hash & newmask) % 13;
        8: 3307:	      them->next_same_hash = newtab->buckets[new_buck];
        8: 3308:	      newtab->buckets[new_buck] = them;
        8: 3309:	      them->table = newtab;
        8: 3310:	      them = save;
        8: 3311:	      ++newtab->bucket_size[new_buck];
        8: 3312:	      ++newtab->refs;
        -: 3313:	    }
        2: 3314:	  table->refs = (table->refs - table->bucket_size[bucket] + 1);
        2: 3315:	  table->bucket_size[bucket] = 0;
        2: 3316:	  table->buckets[bucket] = 0;
        2: 3317:	  table->children[bucket] = newtab;
        2: 3318:	  table = newtab;
        2: 3319:	  bucket = (hash & newmask) % 13;
        -: 3320:	}
        -: 3321:      }
        -: 3322:  }
    2643*: 3323: add_to_bucket:
        -: 3324:  {
     2645: 3325:    struct rx_hash_item  * it = ((struct rx_hash_item *)
     2645: 3326:				 rules->hash_item_alloc (rules, value));
call    0 returned 2645
     2645: 3327:    if (!it)
branch  0 taken 0 (fallthrough)
branch  1 taken 2645
    #####: 3328:      return 0;
     2645: 3329:    it->hash = hash;
     2645: 3330:    it->table = table;
        -: 3331:    /* DATA and BINDING are to be set in hash_item_alloc */
     2645: 3332:    it->next_same_hash = table->buckets [bucket];
     2645: 3333:    table->buckets[bucket] = it;
     2645: 3334:    ++table->bucket_size [bucket];
     2645: 3335:    ++table->refs;
     2645: 3336:    return it;
        -: 3337:  }
        -: 3338:}
        -: 3339:
        -: 3340:#ifdef __STDC__
        -: 3341:RX_DECL void
function rx_hash_free called 0 returned 0% blocks executed 0%
    #####: 3342:rx_hash_free (struct rx_hash_item * it, struct rx_hash_rules * rules)
        -: 3343:#else
        -: 3344:RX_DECL void
        -: 3345:rx_hash_free (it, rules)
        -: 3346:     struct rx_hash_item * it;
        -: 3347:     struct rx_hash_rules * rules;
        -: 3348:#endif
        -: 3349:{
    #####: 3350:  if (it)
branch  0 never executed
branch  1 never executed
        -: 3351:    {
    #####: 3352:      struct rx_hash * table = it->table;
    #####: 3353:      unsigned long hash = it->hash;
    #####: 3354:      int depth = (table->parent
    #####: 3355:		   ? (table->parent->parent
    #####: 3356:		      ? (table->parent->parent->parent
        -: 3357:			 ? 3
    #####: 3358:			 : 2)
branch  0 never executed
branch  1 never executed
    #####: 3359:		      : 1)
branch  0 never executed
branch  1 never executed
    #####: 3360:		   : 0);
branch  0 never executed
branch  1 never executed
    #####: 3361:      int bucket = (hash & rx_hash_masks [depth]) % 13;
    #####: 3362:      struct rx_hash_item ** pos = &table->buckets [bucket];
        -: 3363:      
    #####: 3364:      while (*pos != it)
branch  0 never executed
branch  1 never executed
    #####: 3365:	pos = &(*pos)->next_same_hash;
    #####: 3366:      *pos = it->next_same_hash;
    #####: 3367:     /* rules->free_hash_item (it, rules); */ free(it);
    #####: 3368:      --table->bucket_size[bucket];
    #####: 3369:      --table->refs;
    #####: 3370:      while (!table->refs && depth)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 3371:	{
    #####: 3372:	  struct rx_hash * save = table;
    #####: 3373:	  table = table->parent;
    #####: 3374:	  --depth;
    #####: 3375:	  bucket = (hash & rx_hash_masks [depth]) % 13;
    #####: 3376:	  --table->refs;
    #####: 3377:	  table->children[bucket] = 0;
    #####: 3378:	 /*  rules->free_hash (save, rules); */ free(save);
        -: 3379:	}
        -: 3380:    }
    #####: 3381:}
        -: 3382:
        -: 3383:#ifdef __STDC__
        -: 3384:typedef void (*rx_hash_freefn) (struct rx_hash_item * it);
        -: 3385:#else /* ndef __STDC__ */
        -: 3386:typedef void (*rx_hash_freefn) ();
        -: 3387:#endif /* ndef __STDC__ */
        -: 3388:
        -: 3389:#ifdef __STDC__
        -: 3390:RX_DECL void
function rx_free_hash_table called 464 returned 100% blocks executed 82%
      464: 3391:rx_free_hash_table (struct rx_hash * tab, rx_hash_freefn freefn,
        -: 3392:		    struct rx_hash_rules * rules)
        -: 3393:#else
        -: 3394:RX_DECL void
        -: 3395:rx_free_hash_table (tab, freefn, rules)
        -: 3396:     struct rx_hash * tab;
        -: 3397:     rx_hash_freefn freefn;
        -: 3398:     struct rx_hash_rules * rules;
        -: 3399:#endif
        -: 3400:{
        -: 3401:  int x;
        -: 3402:
     6496: 3403:  for (x = 0; x < 13; ++x)
branch  0 taken 6032
branch  1 taken 464 (fallthrough)
     6032: 3404:    if (tab->children[x])
branch  0 taken 0 (fallthrough)
branch  1 taken 6032
        -: 3405:      {
    #####: 3406:	rx_free_hash_table (tab->children[x], freefn, rules);
call    0 never executed
    #####: 3407:/* 	rules->free_hash (tab->children[x], rules); */ free(tab->children[x]);
        -: 3408:      }
        -: 3409:    else
        -: 3410:      {
     6032: 3411:	struct rx_hash_item * them = tab->buckets[x];
     7848: 3412:	while (them)
branch  0 taken 1816
branch  1 taken 6032 (fallthrough)
        -: 3413:	  {
     1816: 3414:	    struct rx_hash_item * that = them;
     1816: 3415:	    them = that->next_same_hash;
     1816: 3416:	    freefn (that);
call    0 returned 1816
     1816: 3417:/* 	    rules->free_hash_item (that, rules); */ free(that);
        -: 3418:	  }
        -: 3419:      }
      464: 3420:}
        -: 3421:
        -: 3422:
        -: 3423:
        -: 3424:/* Utilities for manipulating bitset represntations of characters sets. */
        -: 3425:
        -: 3426:#ifdef __STDC__
        -: 3427:RX_DECL rx_Bitset
function rx_cset called 2440 returned 100% blocks executed 100%
     2440: 3428:rx_cset (struct rx *rx)
        -: 3429:#else
        -: 3430:RX_DECL rx_Bitset
        -: 3431:rx_cset (rx)
        -: 3432:     struct rx *rx;
        -: 3433:#endif
        -: 3434:{
     2440: 3435:  rx_Bitset b = (rx_Bitset) malloc (rx_sizeof_bitset (rx->local_cset_size));
     2440: 3436:  if (b)
branch  0 taken 2440 (fallthrough)
branch  1 taken 0
     2440: 3437:    rx_bitset_null (rx->local_cset_size, b);
call    0 returned 2440
     2440: 3438:  return b;
        -: 3439:}
        -: 3440:
        -: 3441:
        -: 3442:#ifdef __STDC__
        -: 3443:RX_DECL rx_Bitset
function rx_copy_cset called 1598 returned 100% blocks executed 100%
     1598: 3444:rx_copy_cset (struct rx *rx, rx_Bitset a)
        -: 3445:#else
        -: 3446:RX_DECL rx_Bitset
        -: 3447:rx_copy_cset (rx, a)
        -: 3448:     struct rx *rx;
        -: 3449:     rx_Bitset a;
        -: 3450:#endif
        -: 3451:{
     1598: 3452:  rx_Bitset cs = rx_cset (rx);
call    0 returned 1598
        -: 3453:
     1598: 3454:  if (cs)
branch  0 taken 1598 (fallthrough)
branch  1 taken 0
     1598: 3455:    rx_bitset_union (rx->local_cset_size, cs, a);
call    0 returned 1598
        -: 3456:
     1598: 3457:  return cs;
        -: 3458:}
        -: 3459:
        -: 3460:
        -: 3461:#ifdef __STDC__
        -: 3462:RX_DECL void
function rx_free_cset called 2440 returned 100% blocks executed 100%
     2440: 3463:rx_free_cset (struct rx * rx, rx_Bitset c)
        -: 3464:#else
        -: 3465:RX_DECL void
        -: 3466:rx_free_cset (rx, c)
        -: 3467:     struct rx * rx;
        -: 3468:     rx_Bitset c;
        -: 3469:#endif
        -: 3470:{
     2440: 3471:  if (c)
branch  0 taken 2440 (fallthrough)
branch  1 taken 0
     2440: 3472:    free ((char *)c);
     2440: 3473:}
        -: 3474:
        -: 3475:
        -: 3476:/* Hash table memory allocation policy for the regexp compiler */
        -: 3477:
        -: 3478:#ifdef __STDC__
        -: 3479:struct rx_hash *
function compiler_hash_alloc called 0 returned 0% blocks executed 0%
    #####: 3480:compiler_hash_alloc (struct rx_hash_rules * rules)
        -: 3481:#else
        -: 3482:struct rx_hash *
        -: 3483:compiler_hash_alloc (rules)
        -: 3484:     struct rx_hash_rules * rules;
        -: 3485:#endif
        -: 3486:{
    #####: 3487:  return (struct rx_hash *)malloc (sizeof (struct rx_hash));
        -: 3488:}
        -: 3489:
        -: 3490:#ifdef __STDC__
        -: 3491:struct rx_hash_item *
function compiler_hash_item_alloc called 1816 returned 100% blocks executed 100%
     1816: 3492:compiler_hash_item_alloc (struct rx_hash_rules * rules, void * value)
        -: 3493:#else
        -: 3494:struct rx_hash_item *
        -: 3495:compiler_hash_item_alloc (rules, value)
        -: 3496:     struct rx_hash_rules * rules;
        -: 3497:     void * value;
        -: 3498:#endif
        -: 3499:{
        -: 3500:  struct rx_hash_item * it;
     1816: 3501:  it = (struct rx_hash_item *)malloc (sizeof (*it));
     1816: 3502:  if (it)
branch  0 taken 1816 (fallthrough)
branch  1 taken 0
        -: 3503:    {
     1816: 3504:      it->data = value;
     1816: 3505:      it->binding = 0;
        -: 3506:    }
     1816: 3507:  return it;
        -: 3508:}
        -: 3509:
        -: 3510:#ifdef __STDC__
        -: 3511:void
function compiler_free_hash called 0 returned 0% blocks executed 0%
    #####: 3512:compiler_free_hash (struct rx_hash * tab,
        -: 3513:		    struct rx_hash_rules * rules)
        -: 3514:#else
        -: 3515:void
        -: 3516:compiler_free_hash (tab, rules)
        -: 3517:     struct rx_hash * tab;
        -: 3518:     struct rx_hash_rules * rules;
        -: 3519:#endif
        -: 3520:{
    #####: 3521:  free ((char *)tab);
    #####: 3522:}
        -: 3523:
        -: 3524:#ifdef __STDC__
        -: 3525:void
function compiler_free_hash_item called 0 returned 0% blocks executed 0%
    #####: 3526:compiler_free_hash_item (struct rx_hash_item * item,
        -: 3527:			 struct rx_hash_rules * rules)
        -: 3528:#else
        -: 3529:void
        -: 3530:compiler_free_hash_item (item, rules)
        -: 3531:     struct rx_hash_item * item;
        -: 3532:     struct rx_hash_rules * rules;
        -: 3533:#endif
        -: 3534:{
    #####: 3535:  free ((char *)item);
    #####: 3536:}
        -: 3537:
        -: 3538:
        -: 3539:/* This page: REXP_NODE (expression tree) structures. */
        -: 3540:
        -: 3541:#ifdef __STDC__
        -: 3542:RX_DECL struct rexp_node *
function rexp_node called 3674 returned 100% blocks executed 100%
     3674: 3543:rexp_node (struct rx *rx,
        -: 3544:	   enum rexp_node_type type)
        -: 3545:#else
        -: 3546:RX_DECL struct rexp_node *
        -: 3547:rexp_node (rx, type)
        -: 3548:     struct rx *rx;
        -: 3549:     enum rexp_node_type type;
        -: 3550:#endif
        -: 3551:{
        -: 3552:  struct rexp_node *n;
        -: 3553:
     3674: 3554:  n = (struct rexp_node *)malloc (sizeof (*n));
     3674: 3555:  bzero (n, sizeof (*n));
     3674: 3556:  if (n)
branch  0 taken 3674 (fallthrough)
branch  1 taken 0
     3674: 3557:    n->type = type;
     3674: 3558:  return n;
        -: 3559:}
        -: 3560:
        -: 3561:
        -: 3562:/* free_rexp_node assumes that the bitset passed to rx_mk_r_cset
        -: 3563: * can be freed using rx_free_cset.
        -: 3564: */
        -: 3565:#ifdef __STDC__
        -: 3566:RX_DECL struct rexp_node *
function rx_mk_r_cset called 842 returned 100% blocks executed 100%
      842: 3567:rx_mk_r_cset (struct rx * rx,
        -: 3568:	      rx_Bitset b)
        -: 3569:#else
        -: 3570:RX_DECL struct rexp_node *
        -: 3571:rx_mk_r_cset (rx, b)
        -: 3572:     struct rx * rx;
        -: 3573:     rx_Bitset b;
        -: 3574:#endif
        -: 3575:{
      842: 3576:  struct rexp_node * n = rexp_node (rx, r_cset);
call    0 returned 842
      842: 3577:  if (n)
branch  0 taken 842 (fallthrough)
branch  1 taken 0
      842: 3578:    n->params.cset = b;
      842: 3579:  return n;
        -: 3580:}
        -: 3581:
        -: 3582:
        -: 3583:#ifdef __STDC__
        -: 3584:RX_DECL struct rexp_node *
function rx_mk_r_concat called 958 returned 100% blocks executed 100%
      958: 3585:rx_mk_r_concat (struct rx * rx,
        -: 3586:		struct rexp_node * a,
        -: 3587:		struct rexp_node * b)
        -: 3588:#else
        -: 3589:RX_DECL struct rexp_node *
        -: 3590:rx_mk_r_concat (rx, a, b)
        -: 3591:     struct rx * rx;
        -: 3592:     struct rexp_node * a;
        -: 3593:     struct rexp_node * b;
        -: 3594:#endif
        -: 3595:{
      958: 3596:  struct rexp_node * n = rexp_node (rx, r_concat);
call    0 returned 958
      958: 3597:  if (n)
branch  0 taken 958 (fallthrough)
branch  1 taken 0
        -: 3598:    {
      958: 3599:      n->params.pair.left = a;
      958: 3600:      n->params.pair.right = b;
        -: 3601:    }
      958: 3602:  return n;
        -: 3603:}
        -: 3604:
        -: 3605:
        -: 3606:#ifdef __STDC__
        -: 3607:RX_DECL struct rexp_node *
function rx_mk_r_alternate called 232 returned 100% blocks executed 100%
      232: 3608:rx_mk_r_alternate (struct rx * rx,
        -: 3609:		   struct rexp_node * a,
        -: 3610:		   struct rexp_node * b)
        -: 3611:#else
        -: 3612:RX_DECL struct rexp_node *
        -: 3613:rx_mk_r_alternate (rx, a, b)
        -: 3614:     struct rx * rx;
        -: 3615:     struct rexp_node * a;
        -: 3616:     struct rexp_node * b;
        -: 3617:#endif
        -: 3618:{
      232: 3619:  struct rexp_node * n = rexp_node (rx, r_alternate);
call    0 returned 232
      232: 3620:  if (n)
branch  0 taken 232 (fallthrough)
branch  1 taken 0
        -: 3621:    {
      232: 3622:      n->params.pair.left = a;
      232: 3623:      n->params.pair.right = b;
        -: 3624:    }
      232: 3625:  return n;
        -: 3626:}
        -: 3627:
        -: 3628:
        -: 3629:#ifdef __STDC__
        -: 3630:RX_DECL struct rexp_node *
function rx_mk_r_opt called 0 returned 0% blocks executed 0%
    #####: 3631:rx_mk_r_opt (struct rx * rx,
        -: 3632:	     struct rexp_node * a)
        -: 3633:#else
        -: 3634:RX_DECL struct rexp_node *
        -: 3635:rx_mk_r_opt (rx, a)
        -: 3636:     struct rx * rx;
        -: 3637:     struct rexp_node * a;
        -: 3638:#endif
        -: 3639:{
    #####: 3640:  struct rexp_node * n = rexp_node (rx, r_opt);
call    0 never executed
    #####: 3641:  if (n)
branch  0 never executed
branch  1 never executed
        -: 3642:    {
    #####: 3643:      n->params.pair.left = a;
    #####: 3644:      n->params.pair.right = 0;
        -: 3645:    }
    #####: 3646:  return n;
        -: 3647:}
        -: 3648:
        -: 3649:
        -: 3650:#ifdef __STDC__
        -: 3651:RX_DECL struct rexp_node *
function rx_mk_r_star called 37 returned 100% blocks executed 100%
       37: 3652:rx_mk_r_star (struct rx * rx,
        -: 3653:	      struct rexp_node * a)
        -: 3654:#else
        -: 3655:RX_DECL struct rexp_node *
        -: 3656:rx_mk_r_star (rx, a)
        -: 3657:     struct rx * rx;
        -: 3658:     struct rexp_node * a;
        -: 3659:#endif
        -: 3660:{
       37: 3661:  struct rexp_node * n = rexp_node (rx, r_star);
call    0 returned 37
       37: 3662:  if (n)
branch  0 taken 37 (fallthrough)
branch  1 taken 0
        -: 3663:    {
       37: 3664:      n->params.pair.left = a;
       37: 3665:      n->params.pair.right = 0;
        -: 3666:    }
       37: 3667:  return n;
        -: 3668:}
        -: 3669:
        -: 3670:
        -: 3671:#ifdef __STDC__
        -: 3672:RX_DECL struct rexp_node *
function rx_mk_r_2phase_star called 0 returned 0% blocks executed 0%
    #####: 3673:rx_mk_r_2phase_star (struct rx * rx,
        -: 3674:		     struct rexp_node * a,
        -: 3675:		     struct rexp_node * b)
        -: 3676:#else
        -: 3677:RX_DECL struct rexp_node *
        -: 3678:rx_mk_r_2phase_star (rx, a, b)
        -: 3679:     struct rx * rx;
        -: 3680:     struct rexp_node * a;
        -: 3681:     struct rexp_node * b;
        -: 3682:#endif
        -: 3683:{
    #####: 3684:  struct rexp_node * n = rexp_node (rx, r_2phase_star);
call    0 never executed
    #####: 3685:  if (n)
branch  0 never executed
branch  1 never executed
        -: 3686:    {
    #####: 3687:      n->params.pair.left = a;
    #####: 3688:      n->params.pair.right = b;
        -: 3689:    }
    #####: 3690:  return n;
        -: 3691:}
        -: 3692:
        -: 3693:
        -: 3694:
        -: 3695:#ifdef __STDC__
        -: 3696:RX_DECL struct rexp_node *
function rx_mk_r_side_effect called 348 returned 100% blocks executed 100%
      348: 3697:rx_mk_r_side_effect (struct rx * rx,
        -: 3698:		     rx_side_effect a)
        -: 3699:#else
        -: 3700:RX_DECL struct rexp_node *
        -: 3701:rx_mk_r_side_effect (rx, a)
        -: 3702:     struct rx * rx;
        -: 3703:     rx_side_effect a;
        -: 3704:#endif
        -: 3705:{
      348: 3706:  struct rexp_node * n = rexp_node (rx, r_side_effect);
call    0 returned 348
      348: 3707:  if (n)
branch  0 taken 348 (fallthrough)
branch  1 taken 0
        -: 3708:    {
      348: 3709:      n->params.side_effect = a;
      348: 3710:      n->params.pair.right = 0;
        -: 3711:    }
      348: 3712:  return n;
        -: 3713:}
        -: 3714:
        -: 3715:
        -: 3716:#ifdef __STDC__
        -: 3717:RX_DECL struct rexp_node *
function rx_mk_r_data called 0 returned 0% blocks executed 0%
    #####: 3718:rx_mk_r_data  (struct rx * rx,
        -: 3719:	       void * a)
        -: 3720:#else
        -: 3721:RX_DECL struct rexp_node *
        -: 3722:rx_mk_r_data  (rx, a)
        -: 3723:     struct rx * rx;
        -: 3724:     void * a;
        -: 3725:#endif
        -: 3726:{
    #####: 3727:  struct rexp_node * n = rexp_node (rx, r_data);
call    0 never executed
    #####: 3728:  if (n)
branch  0 never executed
branch  1 never executed
        -: 3729:    {
    #####: 3730:      n->params.pair.left = a;
    #####: 3731:      n->params.pair.right = 0;
        -: 3732:    }
    #####: 3733:  return n;
        -: 3734:}
        -: 3735:
        -: 3736:
        -: 3737:#ifdef __STDC__
        -: 3738:RX_DECL void
function rx_free_rexp called 3748 returned 100% blocks executed 91%
     3748: 3739:rx_free_rexp (struct rx * rx, struct rexp_node * node)
        -: 3740:#else
        -: 3741:RX_DECL void
        -: 3742:rx_free_rexp (rx, node)
        -: 3743:     struct rx * rx;
        -: 3744:     struct rexp_node * node;
        -: 3745:#endif
        -: 3746:{
     3748: 3747:  if (node)
branch  0 taken 3674 (fallthrough)
branch  1 taken 74
        -: 3748:    {
     3674: 3749:      switch (node->type)
branch  0 taken 1220
branch  1 taken 696
branch  2 taken 1758
branch  3 taken 0
branch  4 taken 0
        -: 3750:	{
     1220: 3751:	case r_cset:
     1220: 3752:	  if (node->params.cset)
branch  0 taken 1220 (fallthrough)
branch  1 taken 0
     1220: 3753:	    rx_free_cset (rx, node->params.cset);
call    0 returned 1220
        -: 3754:
        -: 3755:	case r_side_effect:
     1916: 3756:	  break;
        -: 3757:	  
     1758: 3758:	case r_concat:
        -: 3759:	case r_alternate:
        -: 3760:	case r_2phase_star:
        -: 3761:	case r_opt:
        -: 3762:	case r_star:
     1758: 3763:	  rx_free_rexp (rx, node->params.pair.left);
call    0 returned 1758
     1758: 3764:	  rx_free_rexp (rx, node->params.pair.right);
call    0 returned 1758
     1758: 3765:	  break;
        -: 3766:
    #####: 3767:	case r_data:
        -: 3768:	  /* This shouldn't occur. */
    #####: 3769:	  break;
        -: 3770:	}
     3674: 3771:      free ((char *)node);
        -: 3772:    }
     3748: 3773:}
        -: 3774:
        -: 3775:
        -: 3776:#ifdef __STDC__
        -: 3777:RX_DECL struct rexp_node * 
function rx_copy_rexp called 1294 returned 100% blocks executed 75%
     1294: 3778:rx_copy_rexp (struct rx *rx,
        -: 3779:	   struct rexp_node *node)
        -: 3780:#else
        -: 3781:RX_DECL struct rexp_node * 
        -: 3782:rx_copy_rexp (rx, node)
        -: 3783:     struct rx *rx;
        -: 3784:     struct rexp_node *node;
        -: 3785:#endif
        -: 3786:{
     1294: 3787:  if (!node)
branch  0 taken 37 (fallthrough)
branch  1 taken 1257
       37: 3788:    return 0;
        -: 3789:  else
        -: 3790:    {
     1257: 3791:      struct rexp_node *n = rexp_node (rx, node->type);
call    0 returned 1257
     1257: 3792:      if (!n)
branch  0 taken 0 (fallthrough)
branch  1 taken 1257
    #####: 3793:	return 0;
     1257: 3794:      switch (node->type)
branch  0 taken 378
branch  1 taken 348
branch  2 taken 531
branch  3 taken 0
branch  4 taken 0
        -: 3795:	{
      378: 3796:	case r_cset:
      378: 3797:	  n->params.cset = rx_copy_cset (rx, node->params.cset);
call    0 returned 378
      378: 3798:	  if (!n->params.cset)
branch  0 taken 0 (fallthrough)
branch  1 taken 378
        -: 3799:	    {
    #####: 3800:	      rx_free_rexp (rx, n);
call    0 never executed
    #####: 3801:	      return 0;
        -: 3802:	    }
      378: 3803:	  break;
        -: 3804:
      348: 3805:	case r_side_effect:
      348: 3806:	  n->params.side_effect = node->params.side_effect;
      348: 3807:	  break;
        -: 3808:
      531: 3809:	case r_concat:
        -: 3810:	case r_alternate:
        -: 3811:	case r_opt:
        -: 3812:	case r_2phase_star:
        -: 3813:	case r_star:
      531: 3814:	  n->params.pair.left =
      531: 3815:	    rx_copy_rexp (rx, node->params.pair.left);
call    0 returned 531
      531: 3816:	  n->params.pair.right =
      531: 3817:	    rx_copy_rexp (rx, node->params.pair.right);
call    0 returned 531
      531: 3818:	  if (   (node->params.pair.left && !n->params.pair.left)
branch  0 taken 531 (fallthrough)
branch  1 taken 0
branch  2 taken 531 (fallthrough)
branch  3 taken 0
      531: 3819:	      || (node->params.pair.right && !n->params.pair.right))
branch  0 taken 494 (fallthrough)
branch  1 taken 37
branch  2 taken 0 (fallthrough)
branch  3 taken 494
        -: 3820:	    {
    #####: 3821:	      rx_free_rexp  (rx, n);
call    0 never executed
    #####: 3822:	      return 0;
        -: 3823:	    }
      531: 3824:	  break;
    #####: 3825:	case r_data:
        -: 3826:	  /* shouldn't happen */
    #####: 3827:	  break;
        -: 3828:	}
     1257: 3829:      return n;
        -: 3830:    }
        -: 3831:}
        -: 3832:
        -: 3833:
        -: 3834:
        -: 3835:/* This page: functions to build and destroy graphs that describe nfa's */
        -: 3836:
        -: 3837:/* Constructs a new nfa node. */
        -: 3838:#ifdef __STDC__
        -: 3839:RX_DECL struct rx_nfa_state *
function rx_nfa_state called 2992 returned 100% blocks executed 75%
     2992: 3840:rx_nfa_state (struct rx *rx)
        -: 3841:#else
        -: 3842:RX_DECL struct rx_nfa_state *
        -: 3843:rx_nfa_state (rx)
        -: 3844:     struct rx *rx;
        -: 3845:#endif
        -: 3846:{
     2992: 3847:  struct rx_nfa_state * n = (struct rx_nfa_state *)malloc (sizeof (*n));
     2992: 3848:  if (!n)
branch  0 taken 0 (fallthrough)
branch  1 taken 2992
    #####: 3849:    return 0;
     2992: 3850:  bzero (n, sizeof (*n));
     2992: 3851:  n->next = rx->nfa_states;
     2992: 3852:  rx->nfa_states = n;
     2992: 3853:  return n;
        -: 3854:}
        -: 3855:
        -: 3856:
        -: 3857:#ifdef __STDC__
        -: 3858:RX_DECL void
function rx_free_nfa_state called 2992 returned 100% blocks executed 100%
     2992: 3859:rx_free_nfa_state (struct rx_nfa_state * n)
        -: 3860:#else
        -: 3861:RX_DECL void
        -: 3862:rx_free_nfa_state (n)
        -: 3863:  struct rx_nfa_state * n;
        -: 3864:#endif
        -: 3865:{
     2992: 3866:  free ((char *)n);
     2992: 3867:}
        -: 3868:
        -: 3869:
        -: 3870:/* This looks up an nfa node, given a numeric id.  Numeric id's are
        -: 3871: * assigned after the nfa has been built.
        -: 3872: */
        -: 3873:#ifdef __STDC__
        -: 3874:RX_DECL struct rx_nfa_state * 
function rx_id_to_nfa_state called 232 returned 100% blocks executed 86%
      232: 3875:rx_id_to_nfa_state (struct rx * rx,
        -: 3876:		    int id)
        -: 3877:#else
        -: 3878:RX_DECL struct rx_nfa_state * 
        -: 3879:rx_id_to_nfa_state (rx, id)
        -: 3880:     struct rx * rx;
        -: 3881:     int id;
        -: 3882:#endif
        -: 3883:{
        -: 3884:  struct rx_nfa_state * n;
     1452: 3885:  for (n = rx->nfa_states; n; n = n->next)
branch  0 taken 1452
branch  1 taken 0 (fallthrough)
     1452: 3886:    if (n->id == id)
branch  0 taken 232 (fallthrough)
branch  1 taken 1220
      232: 3887:      return n;
    #####: 3888:  return 0;
        -: 3889:}
        -: 3890:
        -: 3891:
        -: 3892:/* This adds an edge between two nodes, but doesn't initialize the 
        -: 3893: * edge label.
        -: 3894: */
        -: 3895:
        -: 3896:#ifdef __STDC__
        -: 3897:RX_DECL struct rx_nfa_edge * 
function rx_nfa_edge called 3140 returned 100% blocks executed 75%
     3140: 3898:rx_nfa_edge (struct rx *rx,
        -: 3899:	     enum rx_nfa_etype type,
        -: 3900:	     struct rx_nfa_state *start,
        -: 3901:	     struct rx_nfa_state *dest)
        -: 3902:#else
        -: 3903:RX_DECL struct rx_nfa_edge * 
        -: 3904:rx_nfa_edge (rx, type, start, dest)
        -: 3905:     struct rx *rx;
        -: 3906:     enum rx_nfa_etype type;
        -: 3907:     struct rx_nfa_state *start;
        -: 3908:     struct rx_nfa_state *dest;
        -: 3909:#endif
        -: 3910:{
        -: 3911:  struct rx_nfa_edge *e;
     3140: 3912:  e = (struct rx_nfa_edge *)malloc (sizeof (*e));
     3140: 3913:  if (!e)
branch  0 taken 0 (fallthrough)
branch  1 taken 3140
    #####: 3914:    return 0;
     3140: 3915:  e->next = start->edges;
     3140: 3916:  start->edges = e;
     3140: 3917:  e->type = type;
     3140: 3918:  e->dest = dest;
     3140: 3919:  return e;
        -: 3920:}
        -: 3921:
        -: 3922:
        -: 3923:#ifdef __STDC__
        -: 3924:RX_DECL void
function rx_free_nfa_edge called 3140 returned 100% blocks executed 100%
     3140: 3925:rx_free_nfa_edge (struct rx_nfa_edge * e)
        -: 3926:#else
        -: 3927:RX_DECL void
        -: 3928:rx_free_nfa_edge (e)
        -: 3929:     struct rx_nfa_edge * e;
        -: 3930:#endif
        -: 3931:{
     3140: 3932:  free ((char *)e);
     3140: 3933:}
        -: 3934:
        -: 3935:
        -: 3936:/* This constructs a POSSIBLE_FUTURE, which is a kind epsilon-closure
        -: 3937: * of an NFA.  These are added to an nfa automaticly by eclose_nfa.
        -: 3938: */  
        -: 3939:
        -: 3940:#ifdef __STDC__
        -: 3941:static struct rx_possible_future * 
function rx_possible_future called 1568 returned 100% blocks executed 75%
     1568: 3942:rx_possible_future (struct rx * rx,
        -: 3943:		 struct rx_se_list * effects)
        -: 3944:#else
        -: 3945:static struct rx_possible_future * 
        -: 3946:rx_possible_future (rx, effects)
        -: 3947:     struct rx * rx;
        -: 3948:     struct rx_se_list * effects;
        -: 3949:#endif
        -: 3950:{
        -: 3951:  struct rx_possible_future *ec;
     1568: 3952:  ec = (struct rx_possible_future *) malloc (sizeof (*ec));
     1568: 3953:  if (!ec)
branch  0 taken 0 (fallthrough)
branch  1 taken 1568
    #####: 3954:    return 0;
     1568: 3955:  ec->destset = 0;
     1568: 3956:  ec->next = 0;
     1568: 3957:  ec->effects = effects;
     1568: 3958:  return ec;
        -: 3959:}
        -: 3960:
        -: 3961:
        -: 3962:#ifdef __STDC__
        -: 3963:static void
function rx_free_possible_future called 1568 returned 100% blocks executed 100%
     1568: 3964:rx_free_possible_future (struct rx_possible_future * pf)
        -: 3965:#else
        -: 3966:static void
        -: 3967:rx_free_possible_future (pf)
        -: 3968:     struct rx_possible_future * pf;
        -: 3969:#endif
        -: 3970:{
     1568: 3971:  free ((char *)pf);
     1568: 3972:}
        -: 3973:
        -: 3974:
        -: 3975:#ifdef __STDC__
        -: 3976:RX_DECL void
function rx_free_nfa called 232 returned 100% blocks executed 93%
      232: 3977:rx_free_nfa (struct rx *rx)
        -: 3978:#else
        -: 3979:RX_DECL void
        -: 3980:rx_free_nfa (rx)
        -: 3981:     struct rx *rx;
        -: 3982:#endif
        -: 3983:{
     3224: 3984:  while (rx->nfa_states)
branch  0 taken 2992
branch  1 taken 232 (fallthrough)
        -: 3985:    {
     4212: 3986:      while (rx->nfa_states->edges)
branch  0 taken 1220
branch  1 taken 2992 (fallthrough)
        -: 3987:	{
     1220: 3988:	  switch (rx->nfa_states->edges->type)
branch  0 taken 1220 (fallthrough)
branch  1 taken 0
        -: 3989:	    {
     1220: 3990:	    case ne_cset:
     1220: 3991:	      rx_free_cset (rx, rx->nfa_states->edges->params.cset);
call    0 returned 1220
     1220: 3992:	      break;
    #####: 3993:	    default:
    #####: 3994:	      break;
        -: 3995:	    }
        -: 3996:	  {
        -: 3997:	    struct rx_nfa_edge * e;
     1220: 3998:	    e = rx->nfa_states->edges;
     1220: 3999:	    rx->nfa_states->edges = rx->nfa_states->edges->next;
     1220: 4000:	    rx_free_nfa_edge (e);
call    0 returned 1220
        -: 4001:	  }
        -: 4002:	} /* while (rx->nfa_states->edges) */
        -: 4003:      {
        -: 4004:	/* Iterate over the partial epsilon closures of rx->nfa_states */
     2992: 4005:	struct rx_possible_future * pf = rx->nfa_states->futures;
     4560: 4006:	while (pf)
branch  0 taken 1568
branch  1 taken 2992 (fallthrough)
        -: 4007:	  {
     1568: 4008:	    struct rx_possible_future * pft = pf;
     1568: 4009:	    pf = pf->next;
     1568: 4010:	    rx_free_possible_future (pft);
call    0 returned 1568
        -: 4011:	  }
        -: 4012:      }
        -: 4013:      {
        -: 4014:	struct rx_nfa_state *n;
     2992: 4015:	n = rx->nfa_states;
     2992: 4016:	rx->nfa_states = rx->nfa_states->next;
     2992: 4017:	rx_free_nfa_state (n);
call    0 returned 2992
        -: 4018:      }
        -: 4019:    }
      232: 4020:}
        -: 4021:
        -: 4022:
        -: 4023:
        -: 4024:/* This page: translating a pattern expression in to an nfa and doing the 
        -: 4025: * static part of the nfa->super-nfa translation.
        -: 4026: */
        -: 4027:
        -: 4028:/* This is the thompson regexp->nfa algorithm. */
        -: 4029:#ifdef __STDC__
        -: 4030:RX_DECL int
function rx_build_nfa called 3674 returned 100% blocks executed 56%
     3674: 4031:rx_build_nfa (struct rx *rx,
        -: 4032:	      struct rexp_node *rexp,
        -: 4033:	      struct rx_nfa_state **start,
        -: 4034:	      struct rx_nfa_state **end)
        -: 4035:#else
        -: 4036:RX_DECL int
        -: 4037:rx_build_nfa (rx, rexp, start, end)
        -: 4038:     struct rx *rx;
        -: 4039:     struct rexp_node *rexp;
        -: 4040:     struct rx_nfa_state **start;
        -: 4041:     struct rx_nfa_state **end;
        -: 4042:#endif
        -: 4043:{
        -: 4044:  struct rx_nfa_edge *edge;
        -: 4045:
        -: 4046:  /* Start & end nodes may have been allocated by the caller. */
     3674: 4047:  *start = *start ? *start : rx_nfa_state (rx);
branch  0 taken 2904 (fallthrough)
branch  1 taken 770
call    2 returned 770
        -: 4048:
     3674: 4049:  if (!*start)
branch  0 taken 0 (fallthrough)
branch  1 taken 3674
    #####: 4050:    return 0;
        -: 4051:
     3674: 4052:  if (!rexp)
branch  0 taken 0 (fallthrough)
branch  1 taken 3674
        -: 4053:    {
    #####: 4054:      *end = *start;
    #####: 4055:      return 1;
        -: 4056:    }
        -: 4057:
     3674: 4058:  *end = *end ? *end : rx_nfa_state (rx);
branch  0 taken 1452 (fallthrough)
branch  1 taken 2222
call    2 returned 2222
        -: 4059:
     3674: 4060:  if (!*end)
branch  0 taken 0 (fallthrough)
branch  1 taken 3674
        -: 4061:    {
    #####: 4062:      rx_free_nfa_state (*start);
call    0 never executed
    #####: 4063:      return 0;
        -: 4064:    }
        -: 4065:
     3674: 4066:  switch (rexp->type)
branch  0 taken 0
branch  1 taken 1220
branch  2 taken 0
branch  3 taken 74
branch  4 taken 0
branch  5 taken 1452
branch  6 taken 232
branch  7 taken 696
branch  8 taken 0
        -: 4067:    {
    #####: 4068:    case r_data:
    #####: 4069:      return 0;
        -: 4070:
     1220: 4071:    case r_cset:
     1220: 4072:      edge = rx_nfa_edge (rx, ne_cset, *start, *end);
call    0 returned 1220
     1220: 4073:      if (!edge)
branch  0 taken 0 (fallthrough)
branch  1 taken 1220
    #####: 4074:	return 0;
     1220: 4075:      edge->params.cset = rx_copy_cset (rx, rexp->params.cset);
call    0 returned 1220
     1220: 4076:      if (!edge->params.cset)
branch  0 taken 0 (fallthrough)
branch  1 taken 1220
        -: 4077:	{
    #####: 4078:	  rx_free_nfa_edge (edge);
call    0 never executed
    #####: 4079:	  return 0;
        -: 4080:	}
     1220: 4081:      return 1;
        -: 4082: 
    #####: 4083:    case r_opt:
    #####: 4084:      return (rx_build_nfa (rx, rexp->params.pair.left, start, end)
call    0 never executed
    #####: 4085:	      && rx_nfa_edge (rx, ne_epsilon, *start, *end));
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 4086:
       74: 4087:    case r_star:
        -: 4088:      {
       74: 4089:	struct rx_nfa_state * star_start = 0;
       74: 4090:	struct rx_nfa_state * star_end = 0;
       74: 4091:	return (rx_build_nfa (rx, rexp->params.pair.left,
call    0 returned 74
        -: 4092:			      &star_start, &star_end)
       74: 4093:		&& star_start
branch  0 taken 74 (fallthrough)
branch  1 taken 0
       74: 4094:		&& star_end
branch  0 taken 74 (fallthrough)
branch  1 taken 0
       74: 4095:		&& rx_nfa_edge (rx, ne_epsilon, star_start, star_end)
call    0 returned 74
branch  1 taken 74 (fallthrough)
branch  2 taken 0
       74: 4096:		&& rx_nfa_edge (rx, ne_epsilon, *start, star_start)
call    0 returned 74
branch  1 taken 74 (fallthrough)
branch  2 taken 0
       74: 4097:		&& rx_nfa_edge (rx, ne_epsilon, star_end, *end)
call    0 returned 74
branch  1 taken 74 (fallthrough)
branch  2 taken 0
        -: 4098:
     148*: 4099:		&& rx_nfa_edge (rx, ne_epsilon, star_end, star_start));
branch  0 taken 74 (fallthrough)
branch  1 taken 0
call    2 returned 74
branch  3 taken 74 (fallthrough)
branch  4 taken 0
        -: 4100:      }
        -: 4101:
    #####: 4102:    case r_2phase_star:
        -: 4103:      {
    #####: 4104:	struct rx_nfa_state * star_start = 0;
    #####: 4105:	struct rx_nfa_state * star_end = 0;
    #####: 4106:	struct rx_nfa_state * loop_exp_start = 0;
    #####: 4107:	struct rx_nfa_state * loop_exp_end = 0;
        -: 4108:
    #####: 4109:	return (rx_build_nfa (rx, rexp->params.pair.left,
call    0 never executed
        -: 4110:			      &star_start, &star_end)
    #####: 4111:		&& rx_build_nfa (rx, rexp->params.pair.right,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 4112:				 &loop_exp_start, &loop_exp_end)
    #####: 4113:		&& star_start
branch  0 never executed
branch  1 never executed
    #####: 4114:		&& star_end
branch  0 never executed
branch  1 never executed
    #####: 4115:		&& loop_exp_end
branch  0 never executed
branch  1 never executed
    #####: 4116:		&& loop_exp_start
branch  0 never executed
branch  1 never executed
    #####: 4117:		&& rx_nfa_edge (rx, ne_epsilon, star_start, *end)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 4118:		&& rx_nfa_edge (rx, ne_epsilon, *start, star_start)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 4119:		&& rx_nfa_edge (rx, ne_epsilon, star_end, *end)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 4120:
    #####: 4121:		&& rx_nfa_edge (rx, ne_epsilon, star_end, loop_exp_start)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 4122:		&& rx_nfa_edge (rx, ne_epsilon, loop_exp_end, star_start));
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 4123:      }
        -: 4124:
        -: 4125:
     1452: 4126:    case r_concat:
        -: 4127:      {
     1452: 4128:	struct rx_nfa_state *shared = 0;
        -: 4129:	return
     1452: 4130:	  (rx_build_nfa (rx, rexp->params.pair.left, start, &shared)
call    0 returned 1452
    1452*: 4131:	   && rx_build_nfa (rx, rexp->params.pair.right, &shared, end));
branch  0 taken 1452 (fallthrough)
branch  1 taken 0
call    2 returned 1452
branch  3 taken 1452 (fallthrough)
branch  4 taken 0
        -: 4132:      }
        -: 4133:
      232: 4134:    case r_alternate:
        -: 4135:      {
      232: 4136:	struct rx_nfa_state *ls = 0;
      232: 4137:	struct rx_nfa_state *le = 0;
      232: 4138:	struct rx_nfa_state *rs = 0;
      232: 4139:	struct rx_nfa_state *re = 0;
      232: 4140:	return (rx_build_nfa (rx, rexp->params.pair.left, &ls, &le)
call    0 returned 232
      232: 4141:		&& rx_build_nfa (rx, rexp->params.pair.right, &rs, &re)
call    0 returned 232
branch  1 taken 232 (fallthrough)
branch  2 taken 0
      232: 4142:		&& rx_nfa_edge (rx, ne_epsilon, *start, ls)
call    0 returned 232
branch  1 taken 232 (fallthrough)
branch  2 taken 0
      232: 4143:		&& rx_nfa_edge (rx, ne_epsilon, *start, rs)
call    0 returned 232
branch  1 taken 232 (fallthrough)
branch  2 taken 0
      232: 4144:		&& rx_nfa_edge (rx, ne_epsilon, le, *end)
call    0 returned 232
branch  1 taken 232 (fallthrough)
branch  2 taken 0
     464*: 4145:		&& rx_nfa_edge (rx, ne_epsilon, re, *end));
branch  0 taken 232 (fallthrough)
branch  1 taken 0
call    2 returned 232
branch  3 taken 232 (fallthrough)
branch  4 taken 0
        -: 4146:      }
        -: 4147:
      696: 4148:    case r_side_effect:
      696: 4149:      edge = rx_nfa_edge (rx, ne_side_effect, *start, *end);
call    0 returned 696
      696: 4150:      if (!edge)
branch  0 taken 0 (fallthrough)
branch  1 taken 696
    #####: 4151:	return 0;
      696: 4152:      edge->params.side_effect = rexp->params.side_effect;
      696: 4153:      return 1;
        -: 4154:    }
        -: 4155:
        -: 4156:  /* this should never happen */
    #####: 4157:  return 0;
        -: 4158:}
        -: 4159:
        -: 4160:
        -: 4161:/* NAME_RX->NFA_STATES identifies all nodes with non-epsilon transitions.
        -: 4162: * These nodes can occur in super-states.  All nodes are given an integer id.
        -: 4163: * The id is non-negative if the node has non-epsilon out-transitions, negative
        -: 4164: * otherwise (this is because we want the non-negative ids to be used as 
        -: 4165: * array indexes in a few places).
        -: 4166: */
        -: 4167:
        -: 4168:#ifdef __STDC__
        -: 4169:RX_DECL void
function rx_name_nfa_states called 232 returned 100% blocks executed 100%
      232: 4170:rx_name_nfa_states (struct rx *rx)
        -: 4171:#else
        -: 4172:RX_DECL void
        -: 4173:rx_name_nfa_states (rx)
        -: 4174:     struct rx *rx;
        -: 4175:#endif
        -: 4176:{
      232: 4177:  struct rx_nfa_state *n = rx->nfa_states;
        -: 4178:
      232: 4179:  rx->nodec = 0;
      232: 4180:  rx->epsnodec = -1;
        -: 4181:
     3224: 4182:  while (n)
branch  0 taken 2992
branch  1 taken 232 (fallthrough)
        -: 4183:    {
     2992: 4184:      struct rx_nfa_edge *e = n->edges;
        -: 4185:
     2992: 4186:      if (n->is_start)
branch  0 taken 232 (fallthrough)
branch  1 taken 2760
      232: 4187:	n->eclosure_needed = 1;
        -: 4188:
     4912: 4189:      while (e)
branch  0 taken 3140
branch  1 taken 1772 (fallthrough)
        -: 4190:	{
     3140: 4191:	  switch (e->type)
branch  0 taken 1920
branch  1 taken 1220
branch  2 taken 0
        -: 4192:	    {
     1920: 4193:	    case ne_epsilon:
        -: 4194:	    case ne_side_effect:
     1920: 4195:	      break;
        -: 4196:
     1220: 4197:	    case ne_cset:
     1220: 4198:	      n->id = rx->nodec++;
        -: 4199:	      {
     1220: 4200:		struct rx_nfa_edge *from_n = n->edges;
     2514: 4201:		while (from_n)
branch  0 taken 1294
branch  1 taken 1220 (fallthrough)
        -: 4202:		  {
     1294: 4203:		    from_n->dest->eclosure_needed = 1;
     1294: 4204:		    from_n = from_n->next;
        -: 4205:		  }
        -: 4206:	      }
     1220: 4207:	      goto cont;
        -: 4208:	    }
     1920: 4209:	  e = e->next;
        -: 4210:	}
     1772: 4211:      n->id = rx->epsnodec--;
     2992: 4212:    cont:
     2992: 4213:      n = n->next;
        -: 4214:    }
      232: 4215:  rx->epsnodec = -rx->epsnodec;
      232: 4216:}
        -: 4217:
        -: 4218:
        -: 4219:/* This page: data structures for the static part of the nfa->supernfa
        -: 4220: * translation.
        -: 4221: */
        -: 4222:
        -: 4223:/* The next several functions compare, construct, etc. lists of side
        -: 4224: * effects.  See ECLOSE_NFA (below) for details.
        -: 4225: */
        -: 4226:
        -: 4227:/* Ordering of rx_se_list
        -: 4228: * (-1, 0, 1 return value convention).
        -: 4229: */
        -: 4230:
        -: 4231:#ifdef __STDC__
        -: 4232:static int 
function se_list_cmp called 1925 returned 100% blocks executed 94%
     1925: 4233:se_list_cmp (void * va, void * vb)
        -: 4234:#else
        -: 4235:static int 
        -: 4236:se_list_cmp (va, vb)
        -: 4237:     void * va;
        -: 4238:     void * vb;
        -: 4239:#endif
        -: 4240:{
     1925: 4241:  struct rx_se_list * a = (struct rx_se_list *)va;
     1925: 4242:  struct rx_se_list * b = (struct rx_se_list *)vb;
        -: 4243:
        -: 4244:  return ((va == vb)
        -: 4245:	  ? 0
     2509: 4246:	  : (!va
branch  0 taken 584 (fallthrough)
branch  1 taken 1341
        -: 4247:	     ? -1
     1052: 4248:	     : (!vb
branch  0 taken 468 (fallthrough)
branch  1 taken 116
        -: 4249:		? 1
     936*: 4250:		: ((long)a->car < (long)b->car
branch  0 taken 468 (fallthrough)
branch  1 taken 0
        -: 4251:		   ? 1
      908: 4252:		   : ((long)a->car > (long)b->car
branch  0 taken 440 (fallthrough)
branch  1 taken 28
        -: 4253:		      ? -1
      440: 4254:		      : se_list_cmp ((void *)a->cdr, (void *)b->cdr))))));
branch  0 taken 408 (fallthrough)
branch  1 taken 32
call    2 returned 408
        -: 4255:}
        -: 4256:
        -: 4257:
        -: 4258:#ifdef __STDC__
        -: 4259:static int 
function se_list_equal called 1137 returned 100% blocks executed 100%
     1137: 4260:se_list_equal (void * va, void * vb)
        -: 4261:#else
        -: 4262:static int 
        -: 4263:se_list_equal (va, vb)
        -: 4264:     void * va;
        -: 4265:     void * vb;
        -: 4266:#endif
        -: 4267:{
     1137: 4268:  return !(se_list_cmp (va, vb));
call    0 returned 1137
        -: 4269:}
        -: 4270:
        -: 4271:static struct rx_hash_rules se_list_hash_rules =
        -: 4272:{
        -: 4273:  se_list_equal,
        -: 4274:  compiler_hash_alloc,
        -: 4275:  compiler_free_hash,
        -: 4276:  compiler_hash_item_alloc,
        -: 4277:  compiler_free_hash_item
        -: 4278:};
        -: 4279:
        -: 4280:
        -: 4281:#ifdef __STDC__
        -: 4282:static struct rx_se_list * 
function side_effect_cons called 756 returned 100% blocks executed 75%
      756: 4283:side_effect_cons (struct rx * rx,
        -: 4284:		  void * se, struct rx_se_list * list)
        -: 4285:#else
        -: 4286:static struct rx_se_list * 
        -: 4287:side_effect_cons (rx, se, list)
        -: 4288:     struct rx * rx;
        -: 4289:     void * se;
        -: 4290:     struct rx_se_list * list;
        -: 4291:#endif
        -: 4292:{
        -: 4293:  struct rx_se_list * l;
      756: 4294:  l = ((struct rx_se_list *) malloc (sizeof (*l)));
      756: 4295:  if (!l)
branch  0 taken 0 (fallthrough)
branch  1 taken 756
    #####: 4296:    return 0;
      756: 4297:  l->car = se;
      756: 4298:  l->cdr = list;
      756: 4299:  return l;
        -: 4300:}
        -: 4301:
        -: 4302:
        -: 4303:#ifdef __STDC__
        -: 4304:static struct rx_se_list *
function hash_cons_se_prog called 756 returned 100% blocks executed 88%
      756: 4305:hash_cons_se_prog (struct rx * rx,
        -: 4306:		   struct rx_hash * memo,
        -: 4307:		   void * car, struct rx_se_list * cdr)
        -: 4308:#else
        -: 4309:static struct rx_se_list *
        -: 4310:hash_cons_se_prog (rx, memo, car, cdr)
        -: 4311:     struct rx * rx;
        -: 4312:     struct rx_hash * memo;
        -: 4313:     void * car;
        -: 4314:     struct rx_se_list * cdr;
        -: 4315:#endif
        -: 4316:{
      756: 4317:  long hash = (long)car ^ (long)cdr;
        -: 4318:  struct rx_se_list template;
        -: 4319:
      756: 4320:  template.car = car;
      756: 4321:  template.cdr = cdr;
        -: 4322:  {
      756: 4323:    struct rx_hash_item * it = rx_hash_store (memo, hash,
call    0 returned 756
        -: 4324:					      (void *)&template,
        -: 4325:					      &se_list_hash_rules);
      756: 4326:    if (!it)
branch  0 taken 0 (fallthrough)
branch  1 taken 756
    #####: 4327:      return 0;
      756: 4328:    if (it->data == (void *)&template)
branch  0 taken 348 (fallthrough)
branch  1 taken 408
        -: 4329:      {
        -: 4330:	struct rx_se_list * consed;
      348: 4331:	consed = (struct rx_se_list *) malloc (sizeof (*consed));
      348: 4332:	*consed = template;
      348: 4333:	it->data = (void *)consed;
        -: 4334:      }
      756: 4335:    return (struct rx_se_list *)it->data;
        -: 4336:  }
        -: 4337:}
        -: 4338:     
        -: 4339:
        -: 4340:#ifdef __STDC__
        -: 4341:static struct rx_se_list *
function hash_se_prog called 1832 returned 100% blocks executed 88%
     1832: 4342:hash_se_prog (struct rx * rx, struct rx_hash * memo, struct rx_se_list * prog)
        -: 4343:#else
        -: 4344:static struct rx_se_list *
        -: 4345:hash_se_prog (rx, memo, prog)
        -: 4346:     struct rx * rx;
        -: 4347:     struct rx_hash * memo;
        -: 4348:     struct rx_se_list * prog;
        -: 4349:#endif
        -: 4350:{
     1832: 4351:  struct rx_se_list * answer = 0;
     2588: 4352:  while (prog)
branch  0 taken 756
branch  1 taken 1832 (fallthrough)
        -: 4353:    {
      756: 4354:      answer = hash_cons_se_prog (rx, memo, prog->car, answer);
call    0 returned 756
      756: 4355:      if (!answer)
branch  0 taken 0 (fallthrough)
branch  1 taken 756
    #####: 4356:	return 0;
      756: 4357:      prog = prog->cdr;
        -: 4358:    }
     1832: 4359:  return answer;
        -: 4360:}
        -: 4361:
        -: 4362:
        -: 4363:/* This page: more data structures for nfa->supernfa.  Specificly,
        -: 4364: * sets of nfa states.
        -: 4365: */
        -: 4366:
        -: 4367:#ifdef __STDC__
        -: 4368:static int 
function nfa_set_cmp called 4270 returned 100% blocks executed 94%
     4270: 4369:nfa_set_cmp (void * va, void * vb)
        -: 4370:#else
        -: 4371:static int 
        -: 4372:nfa_set_cmp (va, vb)
        -: 4373:     void * va;
        -: 4374:     void * vb;
        -: 4375:#endif
        -: 4376:{
     4270: 4377:  struct rx_nfa_state_set * a = (struct rx_nfa_state_set *)va;
     4270: 4378:  struct rx_nfa_state_set * b = (struct rx_nfa_state_set *)vb;
        -: 4379:
        -: 4380:  return ((va == vb)
        -: 4381:	  ? 0
     7140: 4382:	  : (!va
branch  0 taken 2870 (fallthrough)
branch  1 taken 1400
        -: 4383:	     ? -1
     5733: 4384:	     : (!vb
branch  0 taken 2863 (fallthrough)
branch  1 taken 7
        -: 4385:		? 1
    5726*: 4386:		: (a->car->id < b->car->id
branch  0 taken 2863 (fallthrough)
branch  1 taken 0
        -: 4387:		   ? 1
     4349: 4388:		   : (a->car->id > b->car->id
branch  0 taken 1486 (fallthrough)
branch  1 taken 1377
        -: 4389:		      ? -1
     1486: 4390:		      : nfa_set_cmp ((void *)a->cdr, (void *)b->cdr))))));
branch  0 taken 113 (fallthrough)
branch  1 taken 1373
call    2 returned 113
        -: 4391:}
        -: 4392:
        -: 4393:#ifdef __STDC__
        -: 4394:static int 
function nfa_set_equal called 4157 returned 100% blocks executed 100%
     4157: 4395:nfa_set_equal (void * va, void * vb)
        -: 4396:#else
        -: 4397:static int 
        -: 4398:nfa_set_equal (va, vb)
        -: 4399:     void * va;
        -: 4400:     void * vb;
        -: 4401:#endif
        -: 4402:{
     4157: 4403:  return !nfa_set_cmp (va, vb);
call    0 returned 4157
        -: 4404:}
        -: 4405:
        -: 4406:static struct rx_hash_rules nfa_set_hash_rules =
        -: 4407:{
        -: 4408:  nfa_set_equal,
        -: 4409:  compiler_hash_alloc,
        -: 4410:  compiler_free_hash,
        -: 4411:  compiler_hash_item_alloc,
        -: 4412:  compiler_free_hash_item
        -: 4413:};
        -: 4414:
        -: 4415:
        -: 4416:/* CONS -- again, sets with == elements are ==. */
        -: 4417:
        -: 4418:#ifdef __STDC__
        -: 4419:static struct rx_nfa_state_set * 
function nfa_set_cons called 1574 returned 100% blocks executed 80%
     1574: 4420:nfa_set_cons (struct rx * rx,
        -: 4421:	      struct rx_hash * memo, struct rx_nfa_state * state,
        -: 4422:	      struct rx_nfa_state_set * set)
        -: 4423:#else
        -: 4424:static struct rx_nfa_state_set * 
        -: 4425:nfa_set_cons (rx, memo, state, set)
        -: 4426:     struct rx * rx;
        -: 4427:     struct rx_hash * memo;
        -: 4428:     struct rx_nfa_state * state;
        -: 4429:     struct rx_nfa_state_set * set;
        -: 4430:#endif
        -: 4431:{
        -: 4432:  struct rx_nfa_state_set template;
        -: 4433:  struct rx_hash_item * node;
     1574: 4434:  template.car = state;
     1574: 4435:  template.cdr = set;
     1574: 4436:  node = rx_hash_store (memo,
     1574: 4437:			(((long)state) >> 8) ^ (long)set,
call    0 returned 1574
        -: 4438:			&template, &nfa_set_hash_rules);
     1574: 4439:  if (!node)
branch  0 taken 0 (fallthrough)
branch  1 taken 1574
    #####: 4440:    return 0;
     1574: 4441:  if (node->data == &template)
branch  0 taken 1468 (fallthrough)
branch  1 taken 106
        -: 4442:    {
        -: 4443:      struct rx_nfa_state_set * l;
     1468: 4444:      l = (struct rx_nfa_state_set *) malloc (sizeof (*l));
     1468: 4445:      node->data = (void *) l;
     1468: 4446:      if (!l)
branch  0 taken 0 (fallthrough)
branch  1 taken 1468
    #####: 4447:	return 0;
     1468: 4448:      *l = template;
        -: 4449:    }
     1574: 4450:  return (struct rx_nfa_state_set *)node->data;
        -: 4451:}
        -: 4452:
        -: 4453:
        -: 4454:#ifdef __STDC__
        -: 4455:static struct rx_nfa_state_set * 
function nfa_set_enjoin called 1574 returned 100% blocks executed 91%
     1574: 4456:nfa_set_enjoin (struct rx * rx,
        -: 4457:		struct rx_hash * memo, struct rx_nfa_state * state,
        -: 4458:		struct rx_nfa_state_set * set)
        -: 4459:#else
        -: 4460:static struct rx_nfa_state_set * 
        -: 4461:nfa_set_enjoin (rx, memo, state, set)
        -: 4462:     struct rx * rx;
        -: 4463:     struct rx_hash * memo;
        -: 4464:     struct rx_nfa_state * state;
        -: 4465:     struct rx_nfa_state_set * set;
        -: 4466:#endif
        -: 4467:{
     1574: 4468:  if (!set || state->id < set->car->id)
branch  0 taken 264 (fallthrough)
branch  1 taken 1310
branch  2 taken 0 (fallthrough)
branch  3 taken 264
     1310: 4469:    return nfa_set_cons (rx, memo, state, set);
call    0 returned 1310
      264: 4470:  if (state->id == set->car->id)
branch  0 taken 0 (fallthrough)
branch  1 taken 264
    #####: 4471:    return set;
        -: 4472:  else
        -: 4473:    {
        -: 4474:      struct rx_nfa_state_set * newcdr
      264: 4475:	= nfa_set_enjoin (rx, memo, state, set->cdr);
call    0 returned 264
      264: 4476:      if (newcdr != set->cdr)
branch  0 taken 264 (fallthrough)
branch  1 taken 0
      264: 4477:	set = nfa_set_cons (rx, memo, set->car, newcdr);
call    0 returned 264
      264: 4478:      return set;
        -: 4479:    }
        -: 4480:}
        -: 4481:
        -: 4482:
        -: 4483:
        -: 4484:/* This page: computing epsilon closures.  The closures aren't total.
        -: 4485: * Each node's closures are partitioned according to the side effects entailed
        -: 4486: * along the epsilon edges.  Return true on success.
        -: 4487: */ 
        -: 4488:
        -: 4489:struct eclose_frame
        -: 4490:{
        -: 4491:  struct rx_se_list *prog_backwards;
        -: 4492:};
        -: 4493:
        -: 4494:
        -: 4495:#ifdef __STDC__
        -: 4496:static int 
function eclose_node called 3712 returned 100% blocks executed 84%
     3712: 4497:eclose_node (struct rx *rx, struct rx_nfa_state *outnode,
        -: 4498:	     struct rx_nfa_state *node, struct eclose_frame *frame)
        -: 4499:#else
        -: 4500:static int 
        -: 4501:eclose_node (rx, outnode, node, frame)
        -: 4502:     struct rx *rx;
        -: 4503:     struct rx_nfa_state *outnode;
        -: 4504:     struct rx_nfa_state *node;
        -: 4505:     struct eclose_frame *frame;
        -: 4506:#endif
        -: 4507:{
     3712: 4508:  struct rx_nfa_edge *e = node->edges;
        -: 4509:
        -: 4510:  /* For each node, we follow all epsilon paths to build the closure.
        -: 4511:   * The closure omits nodes that have only epsilon edges.
        -: 4512:   * The closure is split into partial closures -- all the states in
        -: 4513:   * a partial closure are reached by crossing the same list of
        -: 4514:   * of side effects (though not necessarily the same path).
        -: 4515:   */
     3712: 4516:  if (node->mark)
branch  0 taken 148 (fallthrough)
branch  1 taken 3564
      148: 4517:    return 1;
     3564: 4518:  node->mark = 1;
        -: 4519:
     3564: 4520:  if (node->id >= 0 || node->is_final)
branch  0 taken 2254 (fallthrough)
branch  1 taken 1310
branch  2 taken 522 (fallthrough)
branch  3 taken 1732
        -: 4521:    {
        -: 4522:      struct rx_possible_future **ec;
        -: 4523:      struct rx_se_list * prog_in_order
     1832: 4524:	= ((struct rx_se_list *)hash_se_prog (rx,
call    0 returned 1832
        -: 4525:					      &rx->se_list_memo,
        -: 4526:					      frame->prog_backwards));
        -: 4527:      int cmp;
        -: 4528:
     1832: 4529:      ec = &outnode->futures;
        -: 4530:
     1832: 4531:      while (*ec)
branch  0 taken 380
branch  1 taken 1452 (fallthrough)
        -: 4532:	{
      380: 4533:	  cmp = se_list_cmp ((void *)(*ec)->effects, (void *)prog_in_order);
call    0 returned 380
      380: 4534:	  if (cmp <= 0)
branch  0 taken 380 (fallthrough)
branch  1 taken 0
      380: 4535:	    break;
    #####: 4536:	  ec = &(*ec)->next;
        -: 4537:	}
     1832: 4538:      if (!*ec || (cmp < 0))
branch  0 taken 380 (fallthrough)
branch  1 taken 1452
branch  2 taken 116 (fallthrough)
branch  3 taken 264
        -: 4539:	{
     1568: 4540:	  struct rx_possible_future * saved = *ec;
     1568: 4541:	  *ec = rx_possible_future (rx, prog_in_order);
call    0 returned 1568
     1568: 4542:	  (*ec)->next = saved;
     1568: 4543:	  if (!*ec)
branch  0 taken 0 (fallthrough)
branch  1 taken 1568
    #####: 4544:	    return 0;
        -: 4545:	}
     1832: 4546:      if (node->id >= 0)
branch  0 taken 1310 (fallthrough)
branch  1 taken 522
        -: 4547:	{
     2620: 4548:	  (*ec)->destset = nfa_set_enjoin (rx, &rx->set_list_memo,
     1310: 4549:					   node, (*ec)->destset);
call    0 returned 1310
     1310: 4550:	  if (!(*ec)->destset)
branch  0 taken 0 (fallthrough)
branch  1 taken 1310
    #####: 4551:	    return 0;
        -: 4552:	}
        -: 4553:    }
        -: 4554:
     7134: 4555:  while (e)
branch  0 taken 3570
branch  1 taken 3564 (fallthrough)
        -: 4556:    {
     3570: 4557:      switch (e->type)
branch  0 taken 1504
branch  1 taken 756
branch  2 taken 1310
        -: 4558:	{
     1504: 4559:	case ne_epsilon:
     1504: 4560:	  if (!eclose_node (rx, outnode, e->dest, frame))
call    0 returned 1504
branch  1 taken 0 (fallthrough)
branch  2 taken 1504
    #####: 4561:	    return 0;
     1504: 4562:	  break;
      756: 4563:	case ne_side_effect:
        -: 4564:	  {
      756: 4565:	    frame->prog_backwards = side_effect_cons (rx, 
call    0 returned 756
        -: 4566:						      e->params.side_effect,
        -: 4567:						      frame->prog_backwards);
      756: 4568:	    if (!frame->prog_backwards)
branch  0 taken 0 (fallthrough)
branch  1 taken 756
    #####: 4569:	      return 0;
      756: 4570:	    if (!eclose_node (rx, outnode, e->dest, frame))
call    0 returned 756
branch  1 taken 0 (fallthrough)
branch  2 taken 756
    #####: 4571:	      return 0;
        -: 4572:	    {
      756: 4573:	      struct rx_se_list * dying = frame->prog_backwards;
      756: 4574:	      frame->prog_backwards = frame->prog_backwards->cdr;
      756: 4575:	      free ((char *)dying);
        -: 4576:	    }
      756: 4577:	    break;
        -: 4578:	  }
     1310: 4579:	default:
     1310: 4580:	  break;
        -: 4581:	}
     3570: 4582:      e = e->next;
        -: 4583:    }
     3564: 4584:  node->mark = 0;
     3564: 4585:  return 1;
        -: 4586:}
        -: 4587:
        -: 4588:
        -: 4589:#ifdef __STDC__
        -: 4590:RX_DECL int 
function rx_eclose_nfa called 232 returned 100% blocks executed 90%
      232: 4591:rx_eclose_nfa (struct rx *rx)
        -: 4592:#else
        -: 4593:RX_DECL int 
        -: 4594:rx_eclose_nfa (rx)
        -: 4595:     struct rx *rx;
        -: 4596:#endif
        -: 4597:{
      232: 4598:  struct rx_nfa_state *n = rx->nfa_states;
        -: 4599:  struct eclose_frame frame;
        -: 4600:  static int rx_id = 0;
        -: 4601:  
      232: 4602:  frame.prog_backwards = 0;
      232: 4603:  rx->rx_id = rx_id++;
      232: 4604:  bzero (&rx->se_list_memo, sizeof (rx->se_list_memo));
      232: 4605:  bzero (&rx->set_list_memo, sizeof (rx->set_list_memo));
     3224: 4606:  while (n)
branch  0 taken 2992
branch  1 taken 232 (fallthrough)
        -: 4607:    {
     2992: 4608:      n->futures = 0;
     2992: 4609:      if (n->eclosure_needed && !eclose_node (rx, n, n, &frame))
branch  0 taken 1452 (fallthrough)
branch  1 taken 1540
call    2 returned 1452
branch  3 taken 0 (fallthrough)
branch  4 taken 1452
    #####: 4610:	return 0;
        -: 4611:      /* clear_marks (rx); */
     2992: 4612:      n = n->next;
        -: 4613:    }
      232: 4614:  return 1;
        -: 4615:}
        -: 4616:
        -: 4617:
        -: 4618:/* This deletes epsilon edges from an NFA.  After running eclose_node,
        -: 4619: * we have no more need for these edges.  They are removed to simplify
        -: 4620: * further operations on the NFA.
        -: 4621: */
        -: 4622:
        -: 4623:#ifdef __STDC__
        -: 4624:RX_DECL void 
function rx_delete_epsilon_transitions called 232 returned 100% blocks executed 100%
      232: 4625:rx_delete_epsilon_transitions (struct rx *rx)
        -: 4626:#else
        -: 4627:RX_DECL void 
        -: 4628:rx_delete_epsilon_transitions (rx)
        -: 4629:     struct rx *rx;
        -: 4630:#endif
        -: 4631:{
      232: 4632:  struct rx_nfa_state *n = rx->nfa_states;
        -: 4633:  struct rx_nfa_edge **e;
        -: 4634:
     3224: 4635:  while (n)
branch  0 taken 2992
branch  1 taken 232 (fallthrough)
        -: 4636:    {
     2992: 4637:      e = &n->edges;
     6132: 4638:      while (*e)
branch  0 taken 3140
branch  1 taken 2992 (fallthrough)
        -: 4639:	{
        -: 4640:	  struct rx_nfa_edge *t;
     3140: 4641:	  switch ((*e)->type)
branch  0 taken 1920 (fallthrough)
branch  1 taken 1220
        -: 4642:	    {
     1920: 4643:	    case ne_epsilon:
        -: 4644:	    case ne_side_effect:
     1920: 4645:	      t = *e;
     1920: 4646:	      *e = t->next;
     1920: 4647:	      rx_free_nfa_edge (t);
call    0 returned 1920
     1920: 4648:	      break;
        -: 4649:
     1220: 4650:	    default:
     1220: 4651:	      e = &(*e)->next;
     1220: 4652:	      break;
        -: 4653:	    }
        -: 4654:	}
     2992: 4655:      n = n->next;
        -: 4656:    }
      232: 4657:}
        -: 4658:
        -: 4659:
        -: 4660:/* This page: storing the nfa in a contiguous region of memory for
        -: 4661: * subsequent conversion to a super-nfa.
        -: 4662: */
        -: 4663:
        -: 4664:
        -: 4665:/* This is for qsort on an array of nfa_states. The order
        -: 4666: * is based on state ids and goes 
        -: 4667: *		[0...MAX][MIN..-1] where (MAX>=0) and (MIN<0)
        -: 4668: * This way, positive ids double as array indices.
        -: 4669: */
        -: 4670:
        -: 4671:#ifdef __STDC__
        -: 4672:static int 
function nfacmp called 7301 returned 100% blocks executed 93%
     7301: 4673:nfacmp (void * va, void * vb)
        -: 4674:#else
        -: 4675:static int 
        -: 4676:nfacmp (va, vb)
        -: 4677:     void * va;
        -: 4678:     void * vb;
        -: 4679:#endif
        -: 4680:{
     7301: 4681:  struct rx_nfa_state **a = (struct rx_nfa_state **)va;
     7301: 4682:  struct rx_nfa_state **b = (struct rx_nfa_state **)vb;
     7301: 4683:  return (*a == *b		/* &&&& 3.18 */
        -: 4684:	  ? 0
   14602*: 4685:	  : (((*a)->id < 0) == ((*b)->id < 0)
branch  0 taken 7301 (fallthrough)
branch  1 taken 0
     4736: 4686:	     ? (((*a)->id  < (*b)->id) ? -1 : 1)
branch  0 taken 1672 (fallthrough)
branch  1 taken 3064
    14602: 4687:	     : (((*a)->id < 0)
branch  0 taken 4736 (fallthrough)
branch  1 taken 2565
     2565: 4688:		? 1 : -1)));
branch  0 taken 1899 (fallthrough)
branch  1 taken 666
        -: 4689:}
        -: 4690:
        -: 4691:#ifdef __STDC__
        -: 4692:static int 
function count_hash_nodes called 464 returned 100% blocks executed 88%
      464: 4693:count_hash_nodes (struct rx_hash * st)
        -: 4694:#else
        -: 4695:static int 
        -: 4696:count_hash_nodes (st)
        -: 4697:     struct rx_hash * st;
        -: 4698:#endif
        -: 4699:{
        -: 4700:  int x;
      464: 4701:  int count = 0;
     6496: 4702:  for (x = 0; x < 13; ++x)
branch  0 taken 6032
branch  1 taken 464 (fallthrough)
    12064: 4703:    count += ((st->children[x])
    #####: 4704:	      ? count_hash_nodes (st->children[x])
call    0 never executed
     6032: 4705:	      : st->bucket_size[x]);
branch  0 taken 0 (fallthrough)
branch  1 taken 6032
        -: 4706:  
      464: 4707:  return count;
        -: 4708:}
        -: 4709:
        -: 4710:
        -: 4711:#ifdef __STDC__
        -: 4712:static void 
function se_memo_freer called 348 returned 100% blocks executed 100%
      348: 4713:se_memo_freer (struct rx_hash_item * node)
        -: 4714:#else
        -: 4715:static void 
        -: 4716:se_memo_freer (node)
        -: 4717:     struct rx_hash_item * node;
        -: 4718:#endif
        -: 4719:{
      348: 4720:  free ((char *)node->data);
      348: 4721:}
        -: 4722:
        -: 4723:
        -: 4724:#ifdef __STDC__
        -: 4725:static void 
function nfa_set_freer called 1468 returned 100% blocks executed 100%
     1468: 4726:nfa_set_freer (struct rx_hash_item * node)
        -: 4727:#else
        -: 4728:static void 
        -: 4729:nfa_set_freer (node)
        -: 4730:     struct rx_hash_item * node;
        -: 4731:#endif
        -: 4732:{
     1468: 4733:  free ((char *)node->data);
     1468: 4734:}
        -: 4735:
        -: 4736:
        -: 4737:/* This copies an entire NFA into a single malloced block of memory.
        -: 4738: * Mostly this is for compatability with regex.c, though it is convenient
        -: 4739: * to have the nfa nodes in an array.
        -: 4740: */
        -: 4741:
        -: 4742:#ifdef __STDC__
        -: 4743:RX_DECL int 
function rx_compactify_nfa called 232 returned 100% blocks executed 95%
      232: 4744:rx_compactify_nfa (struct rx *rx,
        -: 4745:		   void **mem, unsigned long *size)
        -: 4746:#else
        -: 4747:RX_DECL int 
        -: 4748:rx_compactify_nfa (rx, mem, size)
        -: 4749:     struct rx *rx;
        -: 4750:     void **mem;
        -: 4751:     unsigned long *size;
        -: 4752:#endif
        -: 4753:{
        -: 4754:  int total_nodec;
        -: 4755:  struct rx_nfa_state *n;
      232: 4756:  int edgec = 0;
      232: 4757:  int eclosec = 0;
      232: 4758:  int se_list_consc = count_hash_nodes (&rx->se_list_memo);
call    0 returned 232
      232: 4759:  int nfa_setc = count_hash_nodes (&rx->set_list_memo);
call    0 returned 232
        -: 4760:  unsigned long total_size;
        -: 4761:
        -: 4762:  /* This takes place in two stages.   First, the total size of the
        -: 4763:   * nfa is computed, then structures are copied.  
        -: 4764:   */   
      232: 4765:  n = rx->nfa_states;
      232: 4766:  total_nodec = 0;
     3224: 4767:  while (n)
branch  0 taken 2992
branch  1 taken 232 (fallthrough)
        -: 4768:    {
     2992: 4769:      struct rx_nfa_edge *e = n->edges;
     2992: 4770:      struct rx_possible_future *ec = n->futures;
     2992: 4771:      ++total_nodec;
     4212: 4772:      while (e)
branch  0 taken 1220
branch  1 taken 2992 (fallthrough)
        -: 4773:	{
     1220: 4774:	  ++edgec;
     1220: 4775:	  e = e->next;
        -: 4776:	}
     4560: 4777:      while (ec)
branch  0 taken 1568
branch  1 taken 2992 (fallthrough)
        -: 4778:	{
     1568: 4779:	  ++eclosec;
     1568: 4780:	  ec = ec->next;
        -: 4781:	}
     2992: 4782:      n = n->next;
        -: 4783:    }
        -: 4784:
      232: 4785:  total_size = (total_nodec * sizeof (struct rx_nfa_state)
      232: 4786:		+ edgec * rx_sizeof_bitset (rx->local_cset_size)
        -: 4787:		+ edgec * sizeof (struct rx_nfa_edge)
      232: 4788:		+ nfa_setc * sizeof (struct rx_nfa_state_set)
      232: 4789:		+ eclosec * sizeof (struct rx_possible_future)
      232: 4790:		+ se_list_consc * sizeof (struct rx_se_list)
      232: 4791:		+ rx->reserved);
        -: 4792:
      232: 4793:  if (total_size > *size)
branch  0 taken 232 (fallthrough)
branch  1 taken 0
        -: 4794:    {
     232*: 4795:      *mem = remalloc (*mem, total_size);
branch  0 taken 0 (fallthrough)
branch  1 taken 232
      232: 4796:      if (*mem)
branch  0 taken 232 (fallthrough)
branch  1 taken 0
      232: 4797:	*size = total_size;
        -: 4798:      else
    #####: 4799:	return 0;
        -: 4800:    }
        -: 4801:  /* Now we've allocated the memory; this copies the NFA. */
        -: 4802:  {
        -: 4803:    static struct rx_nfa_state **scratch = 0;
        -: 4804:    static int scratch_alloc = 0;
      232: 4805:    struct rx_nfa_state *state_base = (struct rx_nfa_state *) * mem;
      232: 4806:    struct rx_nfa_state *new_state = state_base;
      232: 4807:    struct rx_nfa_edge *new_edge =
        -: 4808:      (struct rx_nfa_edge *)
      232: 4809:	((char *) state_base + total_nodec * sizeof (struct rx_nfa_state));
      232: 4810:    struct rx_se_list * new_se_list =
        -: 4811:      (struct rx_se_list *)
      232: 4812:	((char *)new_edge + edgec * sizeof (struct rx_nfa_edge));
      232: 4813:    struct rx_possible_future *new_close =
        -: 4814:      ((struct rx_possible_future *)
        -: 4815:       ((char *) new_se_list
      232: 4816:	+ se_list_consc * sizeof (struct rx_se_list)));
      232: 4817:    struct rx_nfa_state_set * new_nfa_set =
        -: 4818:      ((struct rx_nfa_state_set *)
      232: 4819:       ((char *)new_close + eclosec * sizeof (struct rx_possible_future)));
      232: 4820:    char *new_bitset =
      232: 4821:      ((char *) new_nfa_set + nfa_setc * sizeof (struct rx_nfa_state_set));
        -: 4822:    int x;
        -: 4823:    struct rx_nfa_state *n;
        -: 4824:
      232: 4825:    if (scratch_alloc < total_nodec)
branch  0 taken 165 (fallthrough)
branch  1 taken 67
        -: 4826:      {
      330: 4827:	scratch = ((struct rx_nfa_state **)
      165: 4828:		   remalloc (scratch, total_nodec * sizeof (*scratch)));
branch  0 taken 39 (fallthrough)
branch  1 taken 126
      165: 4829:	if (scratch)
branch  0 taken 165 (fallthrough)
branch  1 taken 0
      165: 4830:	  scratch_alloc = total_nodec;
        -: 4831:	else
        -: 4832:	  {
    #####: 4833:	    scratch_alloc = 0;
    #####: 4834:	    return 0;
        -: 4835:	  }
        -: 4836:      }
        -: 4837:
     3224: 4838:    for (x = 0, n = rx->nfa_states; n; n = n->next)
branch  0 taken 2992
branch  1 taken 232 (fallthrough)
     2992: 4839:      scratch[x++] = n;
        -: 4840:
      232: 4841:    qsort (scratch, total_nodec,
call    0 returned 232
        -: 4842:	   sizeof (struct rx_nfa_state *), (int (*)())nfacmp);
        -: 4843:
     3224: 4844:    for (x = 0; x < total_nodec; ++x)
branch  0 taken 2992
branch  1 taken 232 (fallthrough)
        -: 4845:      {
     2992: 4846:	struct rx_possible_future *eclose = scratch[x]->futures;
     2992: 4847:	struct rx_nfa_edge *edge = scratch[x]->edges;
     2992: 4848:	struct rx_nfa_state *cn = new_state++;
     2992: 4849:	cn->futures = 0;
     2992: 4850:	cn->edges = 0;
     2992: 4851:	cn->next = (x == total_nodec - 1) ? 0 : (cn + 1);
branch  0 taken 2760 (fallthrough)
branch  1 taken 232
     2992: 4852:	cn->id = scratch[x]->id;
     2992: 4853:	cn->is_final = scratch[x]->is_final;
     2992: 4854:	cn->is_start = scratch[x]->is_start;
     2992: 4855:	cn->mark = 0;
     4212: 4856:	while (edge)
branch  0 taken 1220
branch  1 taken 2992 (fallthrough)
        -: 4857:	  {
     2440: 4858:	    int indx = (edge->dest->id < 0
      616: 4859:			 ? (total_nodec + edge->dest->id)
     1220: 4860:			 : edge->dest->id);
branch  0 taken 616 (fallthrough)
branch  1 taken 604
     1220: 4861:	    struct rx_nfa_edge *e = new_edge++;
     1220: 4862:	    rx_Bitset cset = (rx_Bitset) new_bitset;
     1220: 4863:	    new_bitset += rx_sizeof_bitset (rx->local_cset_size);
     1220: 4864:	    rx_bitset_null (rx->local_cset_size, cset);
call    0 returned 1220
     1220: 4865:	    rx_bitset_union (rx->local_cset_size, cset, edge->params.cset);
call    0 returned 1220
     1220: 4866:	    e->next = cn->edges;
     1220: 4867:	    cn->edges = e;
     1220: 4868:	    e->type = edge->type;
     1220: 4869:	    e->dest = state_base + indx;
     1220: 4870:	    e->params.cset = cset;
     1220: 4871:	    edge = edge->next;
        -: 4872:	  }
     4560: 4873:	while (eclose)
branch  0 taken 1568
branch  1 taken 2992 (fallthrough)
        -: 4874:	  {
     1568: 4875:	    struct rx_possible_future *ec = new_close++;
        -: 4876:	    struct rx_hash_item * sp;
        -: 4877:	    struct rx_se_list ** sepos;
        -: 4878:	    struct rx_se_list * sesrc;
        -: 4879:	    struct rx_nfa_state_set * destlst;
        -: 4880:	    struct rx_nfa_state_set ** destpos;
     1568: 4881:	    ec->next = cn->futures;
     1568: 4882:	    cn->futures = ec;
     1568: 4883:	    for (sepos = &ec->effects, sesrc = eclose->effects;
     1916: 4884:		 sesrc;
branch  0 taken 669
branch  1 taken 1247 (fallthrough)
      348: 4885:		 sesrc = sesrc->cdr, sepos = &(*sepos)->cdr)
        -: 4886:	      {
      669: 4887:		sp = rx_hash_find (&rx->se_list_memo,
      669: 4888:				   (long)sesrc->car ^ (long)sesrc->cdr,
call    0 returned 669
        -: 4889:				   sesrc, &se_list_hash_rules);
      669: 4890:		if (sp->binding)
branch  0 taken 321 (fallthrough)
branch  1 taken 348
        -: 4891:		  {
      321: 4892:		    sesrc = (struct rx_se_list *)sp->binding;
      321: 4893:		    break;
        -: 4894:		  }
      348: 4895:		*new_se_list = *sesrc;
      348: 4896:		sp->binding = (void *)new_se_list;
      348: 4897:		*sepos = new_se_list;
      348: 4898:		++new_se_list;
        -: 4899:	      }
     1568: 4900:	    *sepos = sesrc;
     1568: 4901:	    for (destpos = &ec->destset, destlst = eclose->destset;
     2788: 4902:		 destlst;
branch  0 taken 1294
branch  1 taken 1494 (fallthrough)
     1220: 4903:		 destpos = &(*destpos)->cdr, destlst = destlst->cdr)
        -: 4904:	      {
     1294: 4905:		sp = rx_hash_find (&rx->set_list_memo,
     1294: 4906:				   ((((long)destlst->car) >> 8)
     1294: 4907:				    ^ (long)destlst->cdr),
call    0 returned 1294
        -: 4908:				   destlst, &nfa_set_hash_rules);
     1294: 4909:		if (sp->binding)
branch  0 taken 74 (fallthrough)
branch  1 taken 1220
        -: 4910:		  {
       74: 4911:		    destlst = (struct rx_nfa_state_set *)sp->binding;
       74: 4912:		    break;
        -: 4913:		  }
     1220: 4914:		*new_nfa_set = *destlst;
     1220: 4915:		new_nfa_set->car = state_base + destlst->car->id;
     1220: 4916:		sp->binding = (void *)new_nfa_set;
     1220: 4917:		*destpos = new_nfa_set;
     1220: 4918:		++new_nfa_set;
        -: 4919:	      }
     1568: 4920:	    *destpos = destlst;
     1568: 4921:	    eclose = eclose->next;
        -: 4922:	  }
        -: 4923:      }
        -: 4924:  }
      232: 4925:  rx_free_hash_table (&rx->se_list_memo, se_memo_freer, &se_list_hash_rules);
call    0 returned 232
      232: 4926:  bzero (&rx->se_list_memo, sizeof (rx->se_list_memo));
      232: 4927:  rx_free_hash_table (&rx->set_list_memo, nfa_set_freer, &nfa_set_hash_rules);
call    0 returned 232
      232: 4928:  bzero (&rx->set_list_memo, sizeof (rx->set_list_memo));
        -: 4929:
      232: 4930:  rx_free_nfa (rx);
call    0 returned 232
      232: 4931:  rx->nfa_states = (struct rx_nfa_state *)*mem;
      232: 4932:  return 1;
        -: 4933:}
        -: 4934:
        -: 4935:
        -: 4936:/* The functions in the next several pages define the lazy-NFA-conversion used
        -: 4937: * by matchers.  The input to this construction is an NFA such as 
        -: 4938: * is built by compactify_nfa (rx.c).  The output is the superNFA.
        -: 4939: */
        -: 4940:
        -: 4941:
        -: 4942:/* Match engines can use arbitrary values for opcodes.  So, the parse tree 
        -: 4943: * is built using instructions names (enum rx_opcode), but the superstate
        -: 4944: * nfa is populated with mystery opcodes (void *).
        -: 4945: *
        -: 4946: * For convenience, here is an id table.  The opcodes are == to their inxs
        -: 4947: *
        -: 4948: * The lables in re_search_2 would make good values for instructions.
        -: 4949: */
        -: 4950:
        -: 4951:void * rx_id_instruction_table[rx_num_instructions] =
        -: 4952:{
        -: 4953:  (void *) rx_backtrack_point,
        -: 4954:  (void *) rx_do_side_effects,
        -: 4955:  (void *) rx_cache_miss,
        -: 4956:  (void *) rx_next_char,
        -: 4957:  (void *) rx_backtrack,
        -: 4958:  (void *) rx_error_inx
        -: 4959:};
        -: 4960:
        -: 4961:
        -: 4962:
        -: 4963:#ifdef __STDC__ /* Added code begins */
        -: 4964:static void
        -: 4965:rx_morecore (struct rx_cache * cache);
        -: 4966:#else
        -: 4967:static void
        -: 4968:rx_morecore (cache);
        -: 4969:#endif /* Added code ends */     
        -: 4970:
        -: 4971:/* Memory mgt. for superstate graphs. */
        -: 4972:
        -: 4973:#ifdef __STDC__
        -: 4974:static char *
function rx_cache_malloc called 2760 returned 100% blocks executed 82%
     2760: 4975:rx_cache_malloc (struct rx_cache * cache, int bytes)
        -: 4976:#else
        -: 4977:static char *
        -: 4978:rx_cache_malloc (cache, bytes)
        -: 4979:     struct rx_cache * cache;
        -: 4980:     int bytes;
        -: 4981:#endif
        -: 4982:{
     2884: 4983:  while (cache->bytes_left < bytes)
branch  0 taken 124
branch  1 taken 2760 (fallthrough)
        -: 4984:    {
      124: 4985:      if (cache->memory_pos)
branch  0 taken 0 (fallthrough)
branch  1 taken 124
    #####: 4986:	cache->memory_pos = cache->memory_pos->next;
      124: 4987:      if (!cache->memory_pos)
branch  0 taken 124 (fallthrough)
branch  1 taken 0
        -: 4988:	{
      124: 4989:	  /* cache->morecore (cache); */ rx_morecore((struct rx_cache *) cache);
call    0 returned 124
      124: 4990:	  if (!cache->memory_pos)
branch  0 taken 0 (fallthrough)
branch  1 taken 124
    #####: 4991:	    return 0;
        -: 4992:	}
      124: 4993:      cache->bytes_left = cache->memory_pos->bytes;
      124: 4994:      cache->memory_addr = ((char *)cache->memory_pos
      124: 4995:			    + sizeof (struct rx_blocklist));
        -: 4996:    }
     2760: 4997:  cache->bytes_left -= bytes;
        -: 4998:  {
     2760: 4999:    char * addr = cache->memory_addr;
     2760: 5000:    cache->memory_addr += bytes;
     2760: 5001:    return addr;
        -: 5002:  }
        -: 5003:}
        -: 5004:
        -: 5005:#ifdef __STDC__
        -: 5006:static void
function rx_cache_free called 0 returned 0% blocks executed 0%
    #####: 5007:rx_cache_free (struct rx_cache * cache,
        -: 5008:	       struct rx_freelist ** freelist, char * mem)
        -: 5009:#else
        -: 5010:static void
        -: 5011:rx_cache_free (cache, freelist, mem)
        -: 5012:     struct rx_cache * cache;
        -: 5013:     struct rx_freelist ** freelist;
        -: 5014:     char * mem;
        -: 5015:#endif
        -: 5016:{
    #####: 5017:  struct rx_freelist * it = (struct rx_freelist *)mem;
    #####: 5018:  it->next = *freelist;
    #####: 5019:  *freelist = it;
    #####: 5020:}
        -: 5021:
        -: 5022:
        -: 5023:/* The partially instantiated superstate graph has a transition 
        -: 5024: * table at every node.  There is one entry for every character.
        -: 5025: * This fills in the transition for a set.
        -: 5026: */
        -: 5027:#ifdef __STDC__
        -: 5028:static void 
function install_transition called 0 returned 0% blocks executed 0%
    #####: 5029:install_transition (struct rx_superstate *super,
        -: 5030:		    struct rx_inx *answer, rx_Bitset trcset) 
        -: 5031:#else
        -: 5032:static void 
        -: 5033:install_transition (super, answer, trcset)
        -: 5034:     struct rx_superstate *super;
        -: 5035:     struct rx_inx *answer;
        -: 5036:     rx_Bitset trcset;
        -: 5037:#endif
        -: 5038:{
    #####: 5039:  struct rx_inx * transitions = super->transitions;
        -: 5040:  int chr;
    #####: 5041:  for (chr = 0; chr < 256; )
branch  0 never executed
branch  1 never executed
    #####: 5042:    if (!*trcset)
branch  0 never executed
branch  1 never executed
        -: 5043:      {
    #####: 5044:	++trcset;
    #####: 5045:	chr += 32;
        -: 5046:      }
        -: 5047:    else
        -: 5048:      {
    #####: 5049:	RX_subset sub = *trcset;
    #####: 5050:	RX_subset mask = 1;
    #####: 5051:	int bound = chr + 32;
    #####: 5052:	while (chr < bound)
branch  0 never executed
branch  1 never executed
        -: 5053:	  {
    #####: 5054:	    if (sub & mask)
branch  0 never executed
branch  1 never executed
    #####: 5055:	      transitions [chr] = *answer;
    #####: 5056:	    ++chr;
    #####: 5057:	    mask <<= 1;
        -: 5058:	  }
    #####: 5059:	++trcset;
        -: 5060:      }
    #####: 5061:}
        -: 5062:
        -: 5063:
        -: 5064:#if 1
        -: 5065:static int
function qlen called 0 returned 0% blocks executed 0%
    #####: 5066:qlen (q)
        -: 5067:     struct rx_superstate * q;
        -: 5068:{
    #####: 5069:  int count = 1;
        -: 5070:  struct rx_superstate * it;
    #####: 5071:  if (!q)
branch  0 never executed
branch  1 never executed
    #####: 5072:    return 0;
    #####: 5073:  for (it = q->next_recyclable; it != q; it = it->next_recyclable)
branch  0 never executed
branch  1 never executed
    #####: 5074:    ++count;
    #####: 5075:  return count;
        -: 5076:}
        -: 5077:
        -: 5078:static void
function check_cache called 0 returned 0% blocks executed 0%
    #####: 5079:check_cache (cache)
        -: 5080:     struct rx_cache * cache;
        -: 5081:{
    #####: 5082:  struct rx_cache * you_fucked_up = 0;
    #####: 5083:  int total = cache->superstates;
    #####: 5084:  int semi = cache->semifree_superstates;
    #####: 5085:  if (semi != qlen (cache->semifree_superstate))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 5086:    check_cache (you_fucked_up);
call    0 never executed
    #####: 5087:  if ((total - semi) != qlen (cache->lru_superstate))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 5088:    check_cache (you_fucked_up);
call    0 never executed
    #####: 5089:}
        -: 5090:#endif
        -: 5091:
        -: 5092:#ifdef __STDC__
        -: 5093:static void
function semifree_superstate called 0 returned 0% blocks executed 0%
    #####: 5094:semifree_superstate (struct rx_cache * cache)
        -: 5095:#else
        -: 5096:static void
        -: 5097:semifree_superstate (cache)
        -: 5098:     struct rx_cache * cache;
        -: 5099:#endif
        -: 5100:{
    #####: 5101:  int disqualified = cache->semifree_superstates;
    #####: 5102:  if (disqualified == cache->superstates)
branch  0 never executed
branch  1 never executed
    #####: 5103:    return;
    #####: 5104:  while (cache->lru_superstate->locks)
branch  0 never executed
branch  1 never executed
        -: 5105:    {
    #####: 5106:      cache->lru_superstate = cache->lru_superstate->next_recyclable;
    #####: 5107:      ++disqualified;
    #####: 5108:      if (disqualified == cache->superstates)
branch  0 never executed
branch  1 never executed
    #####: 5109:	return;
        -: 5110:    }
        -: 5111:  {
    #####: 5112:    struct rx_superstate * it = cache->lru_superstate;
    #####: 5113:    it->next_recyclable->prev_recyclable = it->prev_recyclable;
    #####: 5114:    it->prev_recyclable->next_recyclable = it->next_recyclable;
    #####: 5115:    cache->lru_superstate = (it == it->next_recyclable
        -: 5116:			     ? 0
    #####: 5117:			     : it->next_recyclable);
branch  0 never executed
branch  1 never executed
    #####: 5118:    if (!cache->semifree_superstate)
branch  0 never executed
branch  1 never executed
        -: 5119:      {
    #####: 5120:	cache->semifree_superstate = it;
    #####: 5121:	it->next_recyclable = it;
    #####: 5122:	it->prev_recyclable = it;
        -: 5123:      }
        -: 5124:    else
        -: 5125:      {
    #####: 5126:	it->prev_recyclable = cache->semifree_superstate->prev_recyclable;
    #####: 5127:	it->next_recyclable = cache->semifree_superstate;
    #####: 5128:	it->prev_recyclable->next_recyclable = it;
    #####: 5129:	it->next_recyclable->prev_recyclable = it;
        -: 5130:      }
        -: 5131:    {
        -: 5132:      struct rx_distinct_future *df;
    #####: 5133:      it->is_semifree = 1;
    #####: 5134:      ++cache->semifree_superstates;
    #####: 5135:      df = it->transition_refs;
    #####: 5136:      if (df)
branch  0 never executed
branch  1 never executed
        -: 5137:	{
    #####: 5138:	  df->prev_same_dest->next_same_dest = 0;
    #####: 5139:	  for (df = it->transition_refs; df; df = df->next_same_dest)
branch  0 never executed
branch  1 never executed
        -: 5140:	    {
    #####: 5141:	      df->future_frame.inx = cache->instruction_table[rx_cache_miss];
    #####: 5142:	      df->future_frame.data = 0;
    #####: 5143:	      df->future_frame.data_2 = (void *) df;
        -: 5144:	      /* If there are any NEXT-CHAR instruction frames that
        -: 5145:	       * refer to this state, we convert them to CACHE-MISS frames.
        -: 5146:	       */
    #####: 5147:	      if (!df->effects
branch  0 never executed
branch  1 never executed
    #####: 5148:		  && (df->edge->options->next_same_super_edge[0]
    #####: 5149:		      == df->edge->options))
branch  0 never executed
branch  1 never executed
    #####: 5150:		install_transition (df->present, &df->future_frame,
    #####: 5151:				    df->edge->cset);
call    0 never executed
        -: 5152:	    }
    #####: 5153:	  df = it->transition_refs;
    #####: 5154:	  df->prev_same_dest->next_same_dest = df;
        -: 5155:	}
        -: 5156:    }
        -: 5157:  }
        -: 5158:}
        -: 5159:
        -: 5160:
        -: 5161:#ifdef __STDC__
        -: 5162:static void 
function refresh_semifree_superstate called 0 returned 0% blocks executed 0%
    #####: 5163:refresh_semifree_superstate (struct rx_cache * cache,
        -: 5164:			     struct rx_superstate * super)
        -: 5165:#else
        -: 5166:static void 
        -: 5167:refresh_semifree_superstate (cache, super)
        -: 5168:     struct rx_cache * cache;
        -: 5169:     struct rx_superstate * super;
        -: 5170:#endif
        -: 5171:{
        -: 5172:  struct rx_distinct_future *df;
        -: 5173:
    #####: 5174:  if (super->transition_refs)
branch  0 never executed
branch  1 never executed
        -: 5175:    {
    #####: 5176:      super->transition_refs->prev_same_dest->next_same_dest = 0; 
    #####: 5177:      for (df = super->transition_refs; df; df = df->next_same_dest)
branch  0 never executed
branch  1 never executed
        -: 5178:	{
    #####: 5179:	  df->future_frame.inx = cache->instruction_table[rx_next_char];
    #####: 5180:	  df->future_frame.data = (void *) super->transitions;
        -: 5181:	  /* CACHE-MISS instruction frames that refer to this state,
        -: 5182:	   * must be converted to NEXT-CHAR frames.
        -: 5183:	   */
    #####: 5184:	  if (!df->effects
branch  0 never executed
branch  1 never executed
    #####: 5185:	      && (df->edge->options->next_same_super_edge[0]
    #####: 5186:		  == df->edge->options))
branch  0 never executed
branch  1 never executed
    #####: 5187:	    install_transition (df->present, &df->future_frame,
    #####: 5188:				df->edge->cset);
call    0 never executed
        -: 5189:	}
    #####: 5190:      super->transition_refs->prev_same_dest->next_same_dest
    #####: 5191:	= super->transition_refs;
        -: 5192:    }
    #####: 5193:  if (cache->semifree_superstate == super)
branch  0 never executed
branch  1 never executed
    #####: 5194:    cache->semifree_superstate = (super->prev_recyclable == super
        -: 5195:				  ? 0
    #####: 5196:				  : super->prev_recyclable);
branch  0 never executed
branch  1 never executed
    #####: 5197:  super->next_recyclable->prev_recyclable = super->prev_recyclable;
    #####: 5198:  super->prev_recyclable->next_recyclable = super->next_recyclable;
        -: 5199:
    #####: 5200:  if (!cache->lru_superstate)
branch  0 never executed
branch  1 never executed
        -: 5201:    (cache->lru_superstate
    #####: 5202:     = super->next_recyclable
    #####: 5203:     = super->prev_recyclable
    #####: 5204:     = super);
        -: 5205:  else
        -: 5206:    {
    #####: 5207:      super->next_recyclable = cache->lru_superstate;
    #####: 5208:      super->prev_recyclable = cache->lru_superstate->prev_recyclable;
    #####: 5209:      super->next_recyclable->prev_recyclable = super;
    #####: 5210:      super->prev_recyclable->next_recyclable = super;
        -: 5211:    }
    #####: 5212:  super->is_semifree = 0;
    #####: 5213:  --cache->semifree_superstates;
    #####: 5214:}
        -: 5215:
        -: 5216:#ifdef __STDC__
        -: 5217:static void
function rx_refresh_this_superstate called 40 returned 100% blocks executed 57%
       40: 5218:rx_refresh_this_superstate (struct rx_cache * cache, struct rx_superstate * superstate)
        -: 5219:#else
        -: 5220:static void
        -: 5221:rx_refresh_this_superstate (cache, superstate)
        -: 5222:     struct rx_cache * cache;
        -: 5223:     struct rx_superstate * superstate;
        -: 5224:#endif
        -: 5225:{
       40: 5226:  if (superstate->is_semifree)
branch  0 taken 0 (fallthrough)
branch  1 taken 40
    #####: 5227:    refresh_semifree_superstate (cache, superstate);
call    0 never executed
       40: 5228:  else if (cache->lru_superstate == superstate)
branch  0 taken 0 (fallthrough)
branch  1 taken 40
    #####: 5229:    cache->lru_superstate = superstate->next_recyclable;
       40: 5230:  else if (superstate != cache->lru_superstate->prev_recyclable)
branch  0 taken 0 (fallthrough)
branch  1 taken 40
        -: 5231:    {
    #####: 5232:      superstate->next_recyclable->prev_recyclable
    #####: 5233:	= superstate->prev_recyclable;
    #####: 5234:      superstate->prev_recyclable->next_recyclable
    #####: 5235:	= superstate->next_recyclable;
    #####: 5236:      superstate->next_recyclable = cache->lru_superstate;
    #####: 5237:      superstate->prev_recyclable = cache->lru_superstate->prev_recyclable;
    #####: 5238:      superstate->next_recyclable->prev_recyclable = superstate;
    #####: 5239:      superstate->prev_recyclable->next_recyclable = superstate;
        -: 5240:    }
       40: 5241:}
        -: 5242:
        -: 5243:#ifdef __STDC__
        -: 5244:static void 
function release_superset_low called 1134 returned 100% blocks executed 29%
     1134: 5245:release_superset_low (struct rx_cache * cache,
        -: 5246:		     struct rx_superset *set)
        -: 5247:#else
        -: 5248:static void 
        -: 5249:release_superset_low (cache, set)
        -: 5250:     struct rx_cache * cache;
        -: 5251:     struct rx_superset *set;
        -: 5252:#endif
        -: 5253:{
     1134: 5254:  if (!--set->refs)
branch  0 taken 0 (fallthrough)
branch  1 taken 1134
        -: 5255:    {
    #####: 5256:      if (set->cdr)
branch  0 never executed
branch  1 never executed
    #####: 5257:	release_superset_low (cache, set->cdr);
call    0 never executed
        -: 5258:
    #####: 5259:      set->starts_for = 0;
        -: 5260:
    #####: 5261:      rx_hash_free
call    0 never executed
        -: 5262:	(rx_hash_find
        -: 5263:	 (&cache->superset_table,
    #####: 5264:	  (unsigned long)set->car ^ set->id ^ (unsigned long)set->cdr,
call    0 never executed
        -: 5265:	  (void *)set,
        -: 5266:	  &cache->superset_hash_rules),
        -: 5267:	 &cache->superset_hash_rules);
    #####: 5268:      rx_cache_free (cache, &cache->free_supersets, (char *)set);
call    0 never executed
        -: 5269:    }
     1134: 5270:}
        -: 5271:
        -: 5272:#ifdef __STDC__
        -: 5273:RX_DECL void 
function rx_release_superset called 1134 returned 100% blocks executed 100%
     1134: 5274:rx_release_superset (struct rx *rx,
        -: 5275:		     struct rx_superset *set)
        -: 5276:#else
        -: 5277:RX_DECL void 
        -: 5278:rx_release_superset (rx, set)
        -: 5279:     struct rx *rx;
        -: 5280:     struct rx_superset *set;
        -: 5281:#endif
        -: 5282:{
     1134: 5283:  release_superset_low (rx->cache, set);
call    0 returned 1134
     1134: 5284:}
        -: 5285:
        -: 5286:/* This tries to add a new superstate to the superstate freelist.
        -: 5287: * It might, as a result, free some edge pieces or hash tables.
        -: 5288: * If nothing can be freed because too many locks are being held, fail.
        -: 5289: */
        -: 5290:
        -: 5291:#ifdef __STDC__
        -: 5292:static int
function rx_really_free_superstate called 0 returned 0% blocks executed 0%
    #####: 5293:rx_really_free_superstate (struct rx_cache * cache)
        -: 5294:#else
        -: 5295:static int
        -: 5296:rx_really_free_superstate (cache)
        -: 5297:     struct rx_cache * cache;
        -: 5298:#endif
        -: 5299:{
    #####: 5300:  int locked_superstates = 0;
        -: 5301:  struct rx_superstate * it;
        -: 5302:
    #####: 5303:  if (!cache->superstates)
branch  0 never executed
branch  1 never executed
    #####: 5304:    return 0;
        -: 5305:
        -: 5306:  {
        -: 5307:    /* This is a total guess.  The idea is that we should expect as
        -: 5308:     * many misses as we've recently experienced.  I.e., cache->misses
        -: 5309:     * should be the same as cache->semifree_superstates.
        -: 5310:     */
    #####: 5311:    while ((cache->hits + cache->misses) > cache->superstates_allowed)
branch  0 never executed
branch  1 never executed
        -: 5312:      {
    #####: 5313:	cache->hits >>= 1;
    #####: 5314:	cache->misses >>= 1;
        -: 5315:      }
    #####: 5316:    if (  ((cache->hits + cache->misses) * cache->semifree_superstates)
    #####: 5317:	< (cache->superstates		 * cache->misses))
branch  0 never executed
branch  1 never executed
        -: 5318:      {
    #####: 5319:	semifree_superstate (cache);
call    0 never executed
    #####: 5320:	semifree_superstate (cache);
call    0 never executed
        -: 5321:      }
        -: 5322:  }
        -: 5323:
    #####: 5324:  while (cache->semifree_superstate && cache->semifree_superstate->locks)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 5325:    {
    #####: 5326:      refresh_semifree_superstate (cache, cache->semifree_superstate);
call    0 never executed
    #####: 5327:      ++locked_superstates;
    #####: 5328:      if (locked_superstates == cache->superstates)
branch  0 never executed
branch  1 never executed
    #####: 5329:	return 0;
        -: 5330:    }
        -: 5331:
    #####: 5332:  if (cache->semifree_superstate)
branch  0 never executed
branch  1 never executed
        -: 5333:    {
    #####: 5334:      it = cache->semifree_superstate;
    #####: 5335:      it->next_recyclable->prev_recyclable = it->prev_recyclable;
    #####: 5336:      it->prev_recyclable->next_recyclable = it->next_recyclable;
    #####: 5337:      cache->semifree_superstate = ((it == it->next_recyclable)
        -: 5338:				    ? 0
    #####: 5339:				    : it->next_recyclable);
branch  0 never executed
branch  1 never executed
    #####: 5340:      --cache->semifree_superstates;
        -: 5341:    }
        -: 5342:  else
        -: 5343:    {
    #####: 5344:      while (cache->lru_superstate->locks)
branch  0 never executed
branch  1 never executed
        -: 5345:	{
    #####: 5346:	  cache->lru_superstate = cache->lru_superstate->next_recyclable;
    #####: 5347:	  ++locked_superstates;
    #####: 5348:	  if (locked_superstates == cache->superstates)
branch  0 never executed
branch  1 never executed
    #####: 5349:	    return 0;
        -: 5350:	}
    #####: 5351:      it = cache->lru_superstate;
    #####: 5352:      it->next_recyclable->prev_recyclable = it->prev_recyclable;
    #####: 5353:      it->prev_recyclable->next_recyclable = it->next_recyclable;
    #####: 5354:      cache->lru_superstate = ((it == it->next_recyclable)
        -: 5355:				    ? 0
    #####: 5356:				    : it->next_recyclable);
branch  0 never executed
branch  1 never executed
        -: 5357:    }
        -: 5358:
    #####: 5359:  if (it->transition_refs)
branch  0 never executed
branch  1 never executed
        -: 5360:    {
        -: 5361:      struct rx_distinct_future *df;
    #####: 5362:      for (df = it->transition_refs,
    #####: 5363:	   df->prev_same_dest->next_same_dest = 0;
    #####: 5364:	   df;
branch  0 never executed
branch  1 never executed
    #####: 5365:	   df = df->next_same_dest)
        -: 5366:	{
    #####: 5367:	  df->future_frame.inx = cache->instruction_table[rx_cache_miss];
    #####: 5368:	  df->future_frame.data = 0;
    #####: 5369:	  df->future_frame.data_2 = (void *) df;
    #####: 5370:	  df->future = 0;
        -: 5371:	}
    #####: 5372:      it->transition_refs->prev_same_dest->next_same_dest =
    #####: 5373:	it->transition_refs;
        -: 5374:    }
        -: 5375:  {
    #####: 5376:    struct rx_super_edge *tc = it->edges;
    #####: 5377:    while (tc)
branch  0 never executed
branch  1 never executed
        -: 5378:      {
        -: 5379:	struct rx_distinct_future * df;
    #####: 5380:	struct rx_super_edge *tct = tc->next;
    #####: 5381:	df = tc->options;
    #####: 5382:	df->next_same_super_edge[1]->next_same_super_edge[0] = 0;
    #####: 5383:	while (df)
branch  0 never executed
branch  1 never executed
        -: 5384:	  {
    #####: 5385:	    struct rx_distinct_future *dft = df;
    #####: 5386:	    df = df->next_same_super_edge[0];
        -: 5387:	    
        -: 5388:	    
    #####: 5389:	    if (dft->future && dft->future->transition_refs == dft)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 5390:	      {
    #####: 5391:		dft->future->transition_refs = dft->next_same_dest;
    #####: 5392:		if (dft->future->transition_refs == dft)
branch  0 never executed
branch  1 never executed
    #####: 5393:		  dft->future->transition_refs = 0;
        -: 5394:	      }
    #####: 5395:	    dft->next_same_dest->prev_same_dest = dft->prev_same_dest;
    #####: 5396:	    dft->prev_same_dest->next_same_dest = dft->next_same_dest;
    #####: 5397:	    rx_cache_free (cache, &cache->free_discernable_futures,
call    0 never executed
        -: 5398:			   (char *)dft);
        -: 5399:	  }
    #####: 5400:	rx_cache_free (cache, &cache->free_transition_classes, (char *)tc);
call    0 never executed
    #####: 5401:	tc = tct;
        -: 5402:      }
        -: 5403:  }
        -: 5404:  
    #####: 5405:  if (it->contents->superstate == it)
branch  0 never executed
branch  1 never executed
    #####: 5406:    it->contents->superstate = 0;
    #####: 5407:  release_superset_low (cache, it->contents);
call    0 never executed
    #####: 5408:  rx_cache_free (cache, &cache->free_superstates, (char *)it);
call    0 never executed
    #####: 5409:  --cache->superstates;
    #####: 5410:  return 1;
        -: 5411:}
        -: 5412:
        -: 5413:#ifdef __STDC__
        -: 5414:static char *
function rx_cache_get called 0 returned 0% blocks executed 0%
    #####: 5415:rx_cache_get (struct rx_cache * cache,
        -: 5416:	      struct rx_freelist ** freelist)
        -: 5417:#else
        -: 5418:static char *
        -: 5419:rx_cache_get (cache, freelist)
        -: 5420:     struct rx_cache * cache;
        -: 5421:     struct rx_freelist ** freelist;
        -: 5422:#endif
        -: 5423:{
    #####: 5424:  while (!*freelist && rx_really_free_superstate (cache))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 5425:    ;
    #####: 5426:  if (!*freelist)
branch  0 never executed
branch  1 never executed
    #####: 5427:    return 0;
        -: 5428:  {
    #####: 5429:    struct rx_freelist * it = *freelist;
    #####: 5430:    *freelist = it->next;
    #####: 5431:    return (char *)it;
        -: 5432:  }
        -: 5433:}
        -: 5434:
        -: 5435:#ifdef __STDC__
        -: 5436:static char *
function rx_cache_malloc_or_get called 2179 returned 100% blocks executed 83%
     2179: 5437:rx_cache_malloc_or_get (struct rx_cache * cache,
        -: 5438:			struct rx_freelist ** freelist, int bytes)
        -: 5439:#else
        -: 5440:static char *
        -: 5441:rx_cache_malloc_or_get (cache, freelist, bytes)
        -: 5442:     struct rx_cache * cache;
        -: 5443:     struct rx_freelist ** freelist;
        -: 5444:     int bytes;
        -: 5445:#endif
        -: 5446:{
     2179: 5447:  if (!*freelist)
branch  0 taken 2179 (fallthrough)
branch  1 taken 0
        -: 5448:    {
     2179: 5449:      char * answer = rx_cache_malloc (cache, bytes);
call    0 returned 2179
     2179: 5450:      if (answer)
branch  0 taken 2179 (fallthrough)
branch  1 taken 0
     2179: 5451:	return answer;
        -: 5452:    }
        -: 5453:
    #####: 5454:  return rx_cache_get (cache, freelist);
call    0 never executed
        -: 5455:}
        -: 5456:
        -: 5457:#ifdef __STDC__
        -: 5458:static char *
function rx_cache_get_superstate called 581 returned 100% blocks executed 50%
      581: 5459:rx_cache_get_superstate (struct rx_cache * cache)
        -: 5460:#else
        -: 5461:static char *
        -: 5462:rx_cache_get_superstate (cache)
        -: 5463:	  struct rx_cache * cache;
        -: 5464:#endif
        -: 5465:{
        -: 5466:  char * answer;
      581: 5467:  int bytes = (   sizeof (struct rx_superstate)
      581: 5468:	       +  cache->local_cset_size * sizeof (struct rx_inx));
      581: 5469:  if (!cache->free_superstates
branch  0 taken 581 (fallthrough)
branch  1 taken 0
      581: 5470:      && (cache->superstates < cache->superstates_allowed))
branch  0 taken 581 (fallthrough)
branch  1 taken 0
        -: 5471:    {
      581: 5472:      answer = rx_cache_malloc (cache, bytes);
call    0 returned 581
      581: 5473:      if (answer)
branch  0 taken 581 (fallthrough)
branch  1 taken 0
        -: 5474:	{
      581: 5475:	  ++cache->superstates;
      581: 5476:	  return answer;
        -: 5477:	}
        -: 5478:    }
    #####: 5479:  answer = rx_cache_get (cache, &cache->free_superstates);
call    0 never executed
    #####: 5480:  if (!answer)
branch  0 never executed
branch  1 never executed
        -: 5481:    {
    #####: 5482:      answer = rx_cache_malloc (cache, bytes);
call    0 never executed
    #####: 5483:      if (answer)
branch  0 never executed
branch  1 never executed
    #####: 5484:	++cache->superstates_allowed;
        -: 5485:    }
    #####: 5486:  ++cache->superstates;
    #####: 5487:  return answer;
        -: 5488:}
        -: 5489:
        -: 5490:
        -: 5491:
        -: 5492:static int
function supersetcmp called 371 returned 100% blocks executed 100%
      371: 5493:supersetcmp (va, vb)
        -: 5494:     void * va;
        -: 5495:     void * vb;
        -: 5496:{
      371: 5497:  struct rx_superset * a = (struct rx_superset *)va;
      371: 5498:  struct rx_superset * b = (struct rx_superset *)vb;
        -: 5499:  return (   (a == b)
      371: 5500:	  || (a && b && (a->car == b->car) && (a->cdr == b->cdr)));
branch  0 taken 371 (fallthrough)
branch  1 taken 0
branch  2 taken 371 (fallthrough)
branch  3 taken 0
branch  4 taken 371 (fallthrough)
branch  5 taken 0
branch  6 taken 137 (fallthrough)
branch  7 taken 234
branch  8 taken 137 (fallthrough)
branch  9 taken 0
        -: 5501:}
        -: 5502:
        -: 5503:
        -: 5504:#ifdef __STDC__
        -: 5505:static struct rx_hash_item *
function superset_allocator called 829 returned 100% blocks executed 80%
      829: 5506:superset_allocator (struct rx_hash_rules * rules, void * val)
        -: 5507:#else
        -: 5508:static struct rx_hash_item *
        -: 5509:superset_allocator (rules, val)
        -: 5510:     struct rx_hash_rules * rules;
        -: 5511:     void * val;
        -: 5512:#endif
        -: 5513:{
      829: 5514:  struct rx_cache * cache
        -: 5515:    = ((struct rx_cache *)
        -: 5516:       ((char *)rules
        -: 5517:	- (unsigned long)(&((struct rx_cache *)0)->superset_hash_rules)));
      829: 5518:  struct rx_superset * template = (struct rx_superset *)val;
        -: 5519:  struct rx_superset * newset
        -: 5520:    = ((struct rx_superset *)
      829: 5521:       rx_cache_malloc_or_get (cache,
call    0 returned 829
        -: 5522:			       &cache->free_supersets,
        -: 5523:			       sizeof (*template)));
      829: 5524:  if (!newset)
branch  0 taken 0 (fallthrough)
branch  1 taken 829
    #####: 5525:    return 0;
      829: 5526:  newset->refs = 0;
      829: 5527:  newset->car = template->car;
      829: 5528:  newset->id = template->car->id;
      829: 5529:  newset->cdr = template->cdr;
      829: 5530:  newset->superstate = 0;
      829: 5531:  rx_protect_superset (rx, template->cdr);
      829: 5532:  newset->hash_item.data = (void *)newset;
      829: 5533:  newset->hash_item.binding = 0;
      829: 5534:  return &newset->hash_item;
        -: 5535:}
        -: 5536:
        -: 5537:#ifdef __STDC__
        -: 5538:static struct rx_hash * 
function super_hash_allocator called 2 returned 100% blocks executed 100%
        2: 5539:super_hash_allocator (struct rx_hash_rules * rules)
        -: 5540:#else
        -: 5541:static struct rx_hash * 
        -: 5542:super_hash_allocator (rules)
        -: 5543:     struct rx_hash_rules * rules;
        -: 5544:#endif
        -: 5545:{
        2: 5546:  struct rx_cache * cache
        -: 5547:    = ((struct rx_cache *)
        -: 5548:       ((char *)rules
        -: 5549:	- (unsigned long)(&((struct rx_cache *)0)->superset_hash_rules)));
        2: 5550:  return ((struct rx_hash *)
        2: 5551:	  rx_cache_malloc_or_get (cache,
call    0 returned 2
        -: 5552:				  &cache->free_hash, sizeof (struct rx_hash)));
        -: 5553:}
        -: 5554:
        -: 5555:
        -: 5556:#ifdef __STDC__
        -: 5557:static void
function super_hash_liberator called 0 returned 0% blocks executed 0%
    #####: 5558:super_hash_liberator (struct rx_hash * hash, struct rx_hash_rules * rules)
        -: 5559:#else
        -: 5560:static void
        -: 5561:super_hash_liberator (hash, rules)
        -: 5562:     struct rx_hash * hash;
        -: 5563:     struct rx_hash_rules * rules;
        -: 5564:#endif
        -: 5565:{
    #####: 5566:  struct rx_cache * cache
        -: 5567:    = ((struct rx_cache *)
        -: 5568:       (char *)rules - (long)(&((struct rx_cache *)0)->superset_hash_rules));
    #####: 5569:  rx_cache_free (cache, &cache->free_hash, (char *)hash);
call    0 never executed
    #####: 5570:}
        -: 5571:
        -: 5572:#ifdef __STDC__
        -: 5573:static void
function superset_hash_item_liberator called 0 returned 0% blocks executed 0%
    #####: 5574:superset_hash_item_liberator (struct rx_hash_item * it,
        -: 5575:			      struct rx_hash_rules * rules)
        -: 5576:#else
        -: 5577:static void
        -: 5578:superset_hash_item_liberator (it, rules) /* Well, it does ya know. */
        -: 5579:     struct rx_hash_item * it;
        -: 5580:     struct rx_hash_rules * rules;
        -: 5581:#endif
        -: 5582:{
    #####: 5583:}
        -: 5584:
        -: 5585:int rx_cache_bound = 128;
        -: 5586:static int rx_default_cache_got = 0;
        -: 5587:
        -: 5588:#ifdef __STDC__
        -: 5589:static int
function bytes_for_cache_size called 124 returned 100% blocks executed 100%
      124: 5590:bytes_for_cache_size (int supers, int cset_size)
        -: 5591:#else
        -: 5592:static int
        -: 5593:bytes_for_cache_size (supers, cset_size)
        -: 5594:     int supers;
        -: 5595:     int cset_size;
        -: 5596:#endif
        -: 5597:{
      248: 5598:  return (int)
      124: 5599:    ((float)supers *
      124: 5600:     (  (1.03 * (float) (  rx_sizeof_bitset (cset_size)
      124: 5601:			 + sizeof (struct rx_super_edge)))
      124: 5602:      + (1.80 * (float) sizeof (struct rx_possible_future))
      124: 5603:      + (float) (  sizeof (struct rx_superstate)
      124: 5604:		 + cset_size * sizeof (struct rx_inx))));
        -: 5605:}
        -: 5606:
        -: 5607:#ifdef __STDC__
        -: 5608:static void
function rx_morecore called 124 returned 100% blocks executed 70%
      124: 5609:rx_morecore (struct rx_cache * cache)
        -: 5610:#else
        -: 5611:static void
        -: 5612:rx_morecore (cache)
        -: 5613:     struct rx_cache * cache;
        -: 5614:#endif
        -: 5615:{
      124: 5616:  if (rx_default_cache_got >= rx_cache_bound)
branch  0 taken 0 (fallthrough)
branch  1 taken 124
    #####: 5617:    return;
        -: 5618:
      124: 5619:  rx_default_cache_got += 16;
      124: 5620:  cache->superstates_allowed = rx_cache_bound;
        -: 5621:  {
      124: 5622:    struct rx_blocklist ** pos = &cache->memory;
      124: 5623:    int size = bytes_for_cache_size (16, cache->local_cset_size);
call    0 returned 124
      124: 5624:    while (*pos)
branch  0 taken 0
branch  1 taken 124 (fallthrough)
    #####: 5625:      pos = &(*pos)->next;
      124: 5626:    *pos = ((struct rx_blocklist *)
      124: 5627:	    malloc (size + sizeof (struct rx_blocklist))); 
      124: 5628:    if (!*pos)
branch  0 taken 0 (fallthrough)
branch  1 taken 124
    #####: 5629:      return;
        -: 5630:
      124: 5631:    (*pos)->next = 0;
      124: 5632:    (*pos)->bytes = size;
      124: 5633:    cache->memory_pos = *pos;
      124: 5634:    cache->memory_addr = (char *)*pos + sizeof (**pos);
      124: 5635:    cache->bytes_left = size;
        -: 5636:  }
        -: 5637:}
        -: 5638:
        -: 5639:static struct rx_cache default_cache = 
        -: 5640:{
        -: 5641:  {
        -: 5642:    supersetcmp,
        -: 5643:    super_hash_allocator,
        -: 5644:    super_hash_liberator,
        -: 5645:    superset_allocator,
        -: 5646:    superset_hash_item_liberator,
        -: 5647:  },
        -: 5648:  0,
        -: 5649:  0,
        -: 5650:  0,
        -: 5651:  0,
        -: 5652:  rx_morecore,
        -: 5653:
        -: 5654:  0,
        -: 5655:  0,
        -: 5656:  0,
        -: 5657:  0,
        -: 5658:  0,
        -: 5659:
        -: 5660:  0,
        -: 5661:  0,
        -: 5662:
        -: 5663:  0,
        -: 5664:
        -: 5665:  0,
        -: 5666:  0,
        -: 5667:  0,
        -: 5668:  0,
        -: 5669:  128,
        -: 5670:
        -: 5671:  256,
        -: 5672:  rx_id_instruction_table,
        -: 5673:
        -: 5674:  {
        -: 5675:    0,
        -: 5676:    0,
        -: 5677:    {0},
        -: 5678:    {0},
        -: 5679:    {0}
        -: 5680:  }
        -: 5681:};
        -: 5682:
        -: 5683:/* This adds an element to a superstate set.  These sets are lists, such
        -: 5684: * that lists with == elements are ==.  The empty set is returned by
        -: 5685: * superset_cons (rx, 0, 0) and is NOT equivelent to 
        -: 5686: * (struct rx_superset)0.
        -: 5687: */
        -: 5688:
        -: 5689:#ifdef __STDC__
        -: 5690:RX_DECL struct rx_superset *
function rx_superset_cons called 1676 returned 100% blocks executed 86%
     1676: 5691:rx_superset_cons (struct rx * rx,
        -: 5692:		  struct rx_nfa_state *car, struct rx_superset *cdr)
        -: 5693:#else
        -: 5694:RX_DECL struct rx_superset *
        -: 5695:rx_superset_cons (rx, car, cdr)
        -: 5696:     struct rx * rx;
        -: 5697:     struct rx_nfa_state *car;
        -: 5698:     struct rx_superset *cdr;
        -: 5699:#endif
        -: 5700:{
     1676: 5701:  struct rx_cache * cache = rx->cache;
     1676: 5702:  if (!car && !cdr)
branch  0 taken 710 (fallthrough)
branch  1 taken 966
branch  2 taken 710 (fallthrough)
branch  3 taken 0
        -: 5703:    {
      710: 5704:      if (!cache->empty_superset)
branch  0 taken 124 (fallthrough)
branch  1 taken 586
        -: 5705:	{
        -: 5706:	  cache->empty_superset
      124: 5707:	    = ((struct rx_superset *)
      124: 5708:	       rx_cache_malloc_or_get (cache, &cache->free_supersets,
call    0 returned 124
        -: 5709:				       sizeof (struct rx_superset)));
      124: 5710:	  if (!cache->empty_superset)
branch  0 taken 0 (fallthrough)
branch  1 taken 124
    #####: 5711:	    return 0;
      124: 5712:	  bzero (cache->empty_superset, sizeof (struct rx_superset));
      124: 5713:	  cache->empty_superset->refs = 1000;
        -: 5714:	}
      710: 5715:      return cache->empty_superset;
        -: 5716:    }
        -: 5717:  {
        -: 5718:    struct rx_superset template;
        -: 5719:    struct rx_hash_item * hit;
      966: 5720:    template.car = car;
      966: 5721:    template.cdr = cdr;
      966: 5722:    template.id = car->id;
      966: 5723:    hit = rx_hash_store (&cache->superset_table,
      966: 5724:			 (unsigned long)car ^ car->id ^ (unsigned long)cdr,
call    0 returned 966
        -: 5725:			 (void *)&template,
        -: 5726:			 &cache->superset_hash_rules);
        -: 5727:    return (hit
        -: 5728:	    ?  (struct rx_superset *)hit->data
     966*: 5729:	    : 0);
branch  0 taken 966 (fallthrough)
branch  1 taken 0
        -: 5730:  }
        -: 5731:}
        -: 5732:
        -: 5733:/* This computes a union of two NFA state sets.  The sets do not have the
        -: 5734: * same representation though.  One is a RX_SUPERSET structure (part
        -: 5735: * of the superstate NFA) and the other is an NFA_STATE_SET (part of the NFA).
        -: 5736: */
        -: 5737:
        -: 5738:#ifdef __STDC__
        -: 5739:RX_DECL struct rx_superset *
function rx_superstate_eclosure_union called 1712 returned 100% blocks executed 81%
     1712: 5740:rx_superstate_eclosure_union
        -: 5741:  (struct rx * rx, struct rx_superset *set, struct rx_nfa_state_set *ecl) 
        -: 5742:#else
        -: 5743:RX_DECL struct rx_superset *
        -: 5744:rx_superstate_eclosure_union (rx, set, ecl)
        -: 5745:     struct rx * rx;
        -: 5746:     struct rx_superset *set;
        -: 5747:     struct rx_nfa_state_set *ecl;
        -: 5748:#endif
        -: 5749:{
     1712: 5750:  if (!ecl)
branch  0 taken 739 (fallthrough)
branch  1 taken 973
      739: 5751:    return set;
        -: 5752:
      973: 5753:  if (!set->car)
branch  0 taken 908 (fallthrough)
branch  1 taken 65
      908: 5754:    return rx_superset_cons (rx, ecl->car,
call    0 returned 908
call    1 returned 908
        -: 5755:			     rx_superstate_eclosure_union (rx, set, ecl->cdr));
       65: 5756:  if (set->car == ecl->car)
branch  0 taken 7 (fallthrough)
branch  1 taken 58
        7: 5757:    return rx_superstate_eclosure_union (rx, set, ecl->cdr);
call    0 returned 7
        -: 5758:
        -: 5759:  {
        -: 5760:    struct rx_superset * tail;
        -: 5761:    struct rx_nfa_state * first;
        -: 5762:
       58: 5763:    if (set->car > ecl->car)
branch  0 taken 58 (fallthrough)
branch  1 taken 0
        -: 5764:      {
       58: 5765:	tail = rx_superstate_eclosure_union (rx, set->cdr, ecl);
call    0 returned 58
       58: 5766:	first = set->car;
        -: 5767:      }
        -: 5768:    else
        -: 5769:      {
    #####: 5770:	tail = rx_superstate_eclosure_union (rx, set, ecl->cdr);
call    0 never executed
    #####: 5771:	first = ecl->car;
        -: 5772:      }
       58: 5773:    if (!tail)
branch  0 taken 0 (fallthrough)
branch  1 taken 58
    #####: 5774:      return 0;
        -: 5775:    else
        -: 5776:      {
        -: 5777:	struct rx_superset * answer;
       58: 5778:	answer = rx_superset_cons (rx, first, tail);
call    0 returned 58
       58: 5779:	if (!answer)
branch  0 taken 0 (fallthrough)
branch  1 taken 58
        -: 5780:	  {
    #####: 5781:	    rx_protect_superset (rx, tail);
    #####: 5782:	    rx_release_superset (rx, tail);
call    0 never executed
        -: 5783:	  }
       58: 5784:	return answer;
        -: 5785:      }
        -: 5786:  }
        -: 5787:}
        -: 5788:
        -: 5789:
        -: 5790:
        -: 5791:
        -: 5792:/*
        -: 5793: * This makes sure that a list of rx_distinct_futures contains
        -: 5794: * a future for each possible set of side effects in the eclosure
        -: 5795: * of a given state.  This is some of the work of filling in a
        -: 5796: * superstate transition. 
        -: 5797: */
        -: 5798:
        -: 5799:#ifdef __STDC__
        -: 5800:static struct rx_distinct_future *
function include_futures called 613 returned 100% blocks executed 86%
      613: 5801:include_futures (struct rx *rx,
        -: 5802:		 struct rx_distinct_future *df, struct rx_nfa_state
        -: 5803:		 *state, struct rx_superstate *superstate) 
        -: 5804:#else
        -: 5805:static struct rx_distinct_future *
        -: 5806:include_futures (rx, df, state, superstate)
        -: 5807:     struct rx *rx;
        -: 5808:     struct rx_distinct_future *df;
        -: 5809:     struct rx_nfa_state *state;
        -: 5810:     struct rx_superstate *superstate;
        -: 5811:#endif
        -: 5812:{
        -: 5813:  struct rx_possible_future *future;
      613: 5814:  struct rx_cache * cache = rx->cache;
     1290: 5815:  for (future = state->futures; future; future = future->next)
branch  0 taken 677
branch  1 taken 613 (fallthrough)
        -: 5816:    {
        -: 5817:      struct rx_distinct_future *dfp;
      677: 5818:      struct rx_distinct_future *insert_before = 0;
      677: 5819:      if (df)
branch  0 taken 94 (fallthrough)
branch  1 taken 583
       94: 5820:	df->next_same_super_edge[1]->next_same_super_edge[0] = 0;
      742: 5821:      for (dfp = df; dfp; dfp = dfp->next_same_super_edge[0])
branch  0 taken 101
branch  1 taken 641 (fallthrough)
      101: 5822:	if (dfp->effects == future->effects)
branch  0 taken 36 (fallthrough)
branch  1 taken 65
       36: 5823:	  break;
        -: 5824:	else
        -: 5825:	  {
       65: 5826:	    int order = rx->se_list_cmp (rx, dfp->effects, future->effects);
call    0 returned 65
       65: 5827:	    if (order > 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 65
        -: 5828:	      {
    #####: 5829:		insert_before = dfp;
    #####: 5830:		dfp = 0;
    #####: 5831:		break;
        -: 5832:	      }
        -: 5833:	  }
      677: 5834:      if (df)
branch  0 taken 94 (fallthrough)
branch  1 taken 583
       94: 5835:	df->next_same_super_edge[1]->next_same_super_edge[0] = df;
      677: 5836:      if (!dfp)
branch  0 taken 641 (fallthrough)
branch  1 taken 36
        -: 5837:	{
        -: 5838:	  dfp
        -: 5839:	    = ((struct rx_distinct_future *)
      641: 5840:	       rx_cache_malloc_or_get (cache, &cache->free_discernable_futures,
call    0 returned 641
        -: 5841:				       sizeof (struct rx_distinct_future)));
      641: 5842:	  if (!dfp)
branch  0 taken 0 (fallthrough)
branch  1 taken 641
    #####: 5843:	    return 0;
      641: 5844:	  if (!df)
branch  0 taken 583 (fallthrough)
branch  1 taken 58
        -: 5845:	    {
      583: 5846:	      df = insert_before = dfp;
      583: 5847:	      df->next_same_super_edge[0] = df->next_same_super_edge[1] = df;
        -: 5848:	    }
       58: 5849:	  else if (!insert_before)
branch  0 taken 58 (fallthrough)
branch  1 taken 0
       58: 5850:	    insert_before = df;
    #####: 5851:	  else if (insert_before == df)
branch  0 never executed
branch  1 never executed
    #####: 5852:	    df = dfp;
        -: 5853:
      641: 5854:	  dfp->next_same_super_edge[0] = insert_before;
        -: 5855:	  dfp->next_same_super_edge[1]
      641: 5856:	    = insert_before->next_same_super_edge[1];
      641: 5857:	  dfp->next_same_super_edge[1]->next_same_super_edge[0] = dfp;
      641: 5858:	  dfp->next_same_super_edge[0]->next_same_super_edge[1] = dfp;
      641: 5859:	  dfp->next_same_dest = dfp->prev_same_dest = dfp;
      641: 5860:	  dfp->future = 0;
      641: 5861:	  dfp->present = superstate;
      641: 5862:	  dfp->future_frame.inx = rx->instruction_table[rx_cache_miss];
      641: 5863:	  dfp->future_frame.data = 0;
      641: 5864:	  dfp->future_frame.data_2 = (void *) dfp;
        -: 5865:	  dfp->side_effects_frame.inx
      641: 5866:	    = rx->instruction_table[rx_do_side_effects];
      641: 5867:	  dfp->side_effects_frame.data = 0;
      641: 5868:	  dfp->side_effects_frame.data_2 = (void *) dfp;
      641: 5869:	  dfp->effects = future->effects;
        -: 5870:	}
        -: 5871:    }
      613: 5872:  return df;
        -: 5873:}
        -: 5874:
        -: 5875:
        -: 5876:
        -: 5877:
        -: 5878:/* This constructs a new superstate from its state set.  The only 
        -: 5879: * complexity here is memory management.
        -: 5880: */
        -: 5881:#ifdef __STDC__
        -: 5882:RX_DECL struct rx_superstate *
function rx_superstate called 621 returned 100% blocks executed 60%
      621: 5883:rx_superstate (struct rx *rx,
        -: 5884:	       struct rx_superset *set)
        -: 5885:#else
        -: 5886:RX_DECL struct rx_superstate *
        -: 5887:rx_superstate (rx, set)
        -: 5888:     struct rx *rx;
        -: 5889:     struct rx_superset *set;
        -: 5890:#endif
        -: 5891:{
      621: 5892:  struct rx_cache * cache = rx->cache;
      621: 5893:  struct rx_superstate * superstate = 0;
        -: 5894:
        -: 5895:  /* Does the superstate already exist in the cache? */
      621: 5896:  if (set->superstate)
branch  0 taken 40 (fallthrough)
branch  1 taken 581
        -: 5897:    {
       40: 5898:      if (set->superstate->rx_id != rx->rx_id)
branch  0 taken 0 (fallthrough)
branch  1 taken 40
        -: 5899:	{
        -: 5900:	  /* Aha.  It is in the cache, but belongs to a superstate
        -: 5901:	   * that refers to an NFA that no longer exists.
        -: 5902:	   * (We know it no longer exists because it was evidently
        -: 5903:	   *  stored in the same region of memory as the current nfa
        -: 5904:	   *  yet it has a different id.)
        -: 5905:	   */
    #####: 5906:	  superstate = set->superstate;
    #####: 5907:	  if (!superstate->is_semifree)
branch  0 never executed
branch  1 never executed
        -: 5908:	    {
    #####: 5909:	      if (cache->lru_superstate == superstate)
branch  0 never executed
branch  1 never executed
        -: 5910:		{
    #####: 5911:		  cache->lru_superstate = superstate->next_recyclable;
    #####: 5912:		  if (cache->lru_superstate == superstate)
branch  0 never executed
branch  1 never executed
    #####: 5913:		    cache->lru_superstate = 0;
        -: 5914:		}
        -: 5915:	      {
    #####: 5916:		superstate->next_recyclable->prev_recyclable
    #####: 5917:		  = superstate->prev_recyclable;
    #####: 5918:		superstate->prev_recyclable->next_recyclable
    #####: 5919:		  = superstate->next_recyclable;
    #####: 5920:		if (!cache->semifree_superstate)
branch  0 never executed
branch  1 never executed
        -: 5921:		  {
        -: 5922:		    (cache->semifree_superstate
    #####: 5923:		     = superstate->next_recyclable
    #####: 5924:		     = superstate->prev_recyclable
    #####: 5925:		     = superstate);
        -: 5926:		  }
        -: 5927:		else
        -: 5928:		  {
    #####: 5929:		    superstate->next_recyclable = cache->semifree_superstate;
        -: 5930:		    superstate->prev_recyclable
    #####: 5931:		      = cache->semifree_superstate->prev_recyclable;
    #####: 5932:		    superstate->next_recyclable->prev_recyclable
    #####: 5933:		      = superstate;
    #####: 5934:		    superstate->prev_recyclable->next_recyclable
    #####: 5935:		      = superstate;
    #####: 5936:		    cache->semifree_superstate = superstate;
        -: 5937:		  }
    #####: 5938:		++cache->semifree_superstates;
        -: 5939:	      }
        -: 5940:	    }
    #####: 5941:	  set->superstate = 0;
    #####: 5942:	  goto handle_cache_miss;
        -: 5943:	}
       40: 5944:      ++cache->hits;
       40: 5945:      superstate = set->superstate;
        -: 5946:
       40: 5947:      rx_refresh_this_superstate (cache, superstate);
call    0 returned 40
       40: 5948:      return superstate;
        -: 5949:    }
        -: 5950:
      581: 5951: handle_cache_miss:
        -: 5952:
        -: 5953:  /* This point reached only for cache misses. */
      581: 5954:  ++cache->misses;
        -: 5955:#if RX_DEBUG
        -: 5956:  if (rx_debug_trace > 1)
        -: 5957:    {
        -: 5958:      struct rx_superset * setp = set;
        -: 5959:      fprintf (stderr, "Building a superstet %d(%d): ", rx->rx_id, set);
        -: 5960:      while (setp)
        -: 5961:	{
        -: 5962:	  fprintf (stderr, "%d ", setp->id);
        -: 5963:	  setp = setp->cdr;
        -: 5964:	}
        -: 5965:      fprintf (stderr, "(%d)\n", set);
        -: 5966:    }
        -: 5967:#endif
      581: 5968:  superstate = (struct rx_superstate *)rx_cache_get_superstate (cache);
call    0 returned 581
      581: 5969:  if (!superstate)
branch  0 taken 0 (fallthrough)
branch  1 taken 581
    #####: 5970:    return 0;
        -: 5971:
      581: 5972:  if (!cache->lru_superstate)
branch  0 taken 124 (fallthrough)
branch  1 taken 457
        -: 5973:    (cache->lru_superstate
      124: 5974:     = superstate->next_recyclable
      124: 5975:     = superstate->prev_recyclable
      124: 5976:     = superstate);
        -: 5977:  else
        -: 5978:    {
      457: 5979:      superstate->next_recyclable = cache->lru_superstate;
      457: 5980:      superstate->prev_recyclable = cache->lru_superstate->prev_recyclable;
      457: 5981:      (  superstate->prev_recyclable->next_recyclable
      457: 5982:       = superstate->next_recyclable->prev_recyclable
      457: 5983:       = superstate);
        -: 5984:    }
      581: 5985:  superstate->rx_id = rx->rx_id;
      581: 5986:  superstate->transition_refs = 0;
      581: 5987:  superstate->locks = 0;
      581: 5988:  superstate->is_semifree = 0;
      581: 5989:  set->superstate = superstate;
      581: 5990:  superstate->contents = set;
      581: 5991:  rx_protect_superset (rx, set);
      581: 5992:  superstate->edges = 0;
        -: 5993:  {
        -: 5994:    int x;
        -: 5995:    /* None of the transitions from this superstate are known yet. */
   149317: 5996:    for (x = 0; x < rx->local_cset_size; ++x) /* &&&&& 3.8 % */
branch  0 taken 148736
branch  1 taken 581 (fallthrough)
        -: 5997:      {
   148736: 5998:	struct rx_inx * ifr = &superstate->transitions[x];
   148736: 5999:	ifr->inx = rx->instruction_table [rx_cache_miss];
   148736: 6000:	ifr->data = ifr->data_2 = 0;
        -: 6001:      }
        -: 6002:  }
      581: 6003:  return superstate;
        -: 6004:}
        -: 6005:
        -: 6006:
        -: 6007:/* This computes the destination set of one edge of the superstate NFA.
        -: 6008: * Note that a RX_DISTINCT_FUTURE is a superstate edge.
        -: 6009: * Returns 0 on an allocation failure.
        -: 6010: */
        -: 6011:
        -: 6012:#ifdef __STDC__
        -: 6013:static int 
function solve_destination called 484 returned 100% blocks executed 94%
      484: 6014:solve_destination (struct rx *rx, struct rx_distinct_future *df)
        -: 6015:#else
        -: 6016:static int 
        -: 6017:solve_destination (rx, df)
        -: 6018:     struct rx *rx;
        -: 6019:     struct rx_distinct_future *df;
        -: 6020:#endif
        -: 6021:{
      484: 6022:  struct rx_super_edge *tc = df->edge;
        -: 6023:  struct rx_superset *nfa_state;
      484: 6024:  struct rx_superset *nil_set = rx_superset_cons (rx, 0, 0);
call    0 returned 484
      484: 6025:  struct rx_superset *solution = nil_set;
        -: 6026:  struct rx_superstate *dest;
        -: 6027:
      484: 6028:  rx_protect_superset (rx, solution);
        -: 6029:  /* Iterate over all NFA states in the state set of this superstate. */
      484: 6030:  for (nfa_state = df->present->contents;
     1234: 6031:       nfa_state->car;
branch  0 taken 750
branch  1 taken 484 (fallthrough)
      750: 6032:       nfa_state = nfa_state->cdr)
        -: 6033:    {
        -: 6034:      struct rx_nfa_edge *e;
        -: 6035:      /* Iterate over all edges of each NFA state. */
     1500: 6036:      for (e = nfa_state->car->edges; e; e = e->next)
branch  0 taken 750
branch  1 taken 750 (fallthrough)
        -: 6037:        /* If we find an edge that is labeled with 
        -: 6038:	 * the characters we are solving for.....
        -: 6039:	 */
      750: 6040:	if (rx_bitset_is_subset (rx->local_cset_size,
call    0 returned 750
branch  1 taken 514 (fallthrough)
branch  2 taken 236
        -: 6041:				 tc->cset, e->params.cset))
        -: 6042:	  {
      514: 6043:	    struct rx_nfa_state *n = e->dest;
        -: 6044:	    struct rx_possible_future *pf;
        -: 6045:	    /* ....search the partial epsilon closures of the destination
        -: 6046:	     * of that edge for a path that involves the same set of
        -: 6047:	     * side effects we are solving for.
        -: 6048:	     * If we find such a RX_POSSIBLE_FUTURE, we add members to the
        -: 6049:	     * stateset we are computing.
        -: 6050:	     */
     1125: 6051:	    for (pf = n->futures; pf; pf = pf->next)
branch  0 taken 611
branch  1 taken 514 (fallthrough)
      611: 6052:	      if (pf->effects == df->effects)
branch  0 taken 513 (fallthrough)
branch  1 taken 98
        -: 6053:		{
        -: 6054:		  struct rx_superset * old_sol;
      513: 6055:		  old_sol = solution;
      513: 6056:		  solution = rx_superstate_eclosure_union (rx, solution,
call    0 returned 513
        -: 6057:							   pf->destset);
      513: 6058:		  if (!solution)
branch  0 taken 0 (fallthrough)
branch  1 taken 513
    #####: 6059:		    return 0;
      513: 6060:		  rx_protect_superset (rx, solution);
      513: 6061:		  rx_release_superset (rx, old_sol);
call    0 returned 513
        -: 6062:		}
        -: 6063:	  }
        -: 6064:    }
        -: 6065:  /* It is possible that the RX_DISTINCT_FUTURE we are working on has 
        -: 6066:   * the empty set of NFA states as its definition.  In that case, this
        -: 6067:   * is a failure point.
        -: 6068:   */
      484: 6069:  if (solution == nil_set)
branch  0 taken 89 (fallthrough)
branch  1 taken 395
        -: 6070:    {
       89: 6071:      df->future_frame.inx = (void *) rx_backtrack;
       89: 6072:      df->future_frame.data = 0;
       89: 6073:      df->future_frame.data_2 = 0;
       89: 6074:      return 1;
        -: 6075:    }
      395: 6076:  dest = rx_superstate (rx, solution);
call    0 returned 395
      395: 6077:  rx_release_superset (rx, solution);
call    0 returned 395
      395: 6078:  if (!dest)
branch  0 taken 0 (fallthrough)
branch  1 taken 395
    #####: 6079:    return 0;
        -: 6080:
        -: 6081:  {
        -: 6082:    struct rx_distinct_future *dft;
      395: 6083:    dft = df;
      395: 6084:    df->prev_same_dest->next_same_dest = 0;
      790: 6085:    while (dft)
branch  0 taken 395
branch  1 taken 395 (fallthrough)
        -: 6086:      {
      395: 6087:	dft->future = dest;
      395: 6088:	dft->future_frame.inx = rx->instruction_table[rx_next_char];
      395: 6089:	dft->future_frame.data = (void *) dest->transitions;
      395: 6090:	dft = dft->next_same_dest;
        -: 6091:      }
      395: 6092:    df->prev_same_dest->next_same_dest = df;
        -: 6093:  }
      395: 6094:  if (!dest->transition_refs)
branch  0 taken 355 (fallthrough)
branch  1 taken 40
      355: 6095:    dest->transition_refs = df;
        -: 6096:  else
        -: 6097:    {
       40: 6098:      struct rx_distinct_future *dft = dest->transition_refs->next_same_dest;
       40: 6099:      dest->transition_refs->next_same_dest = df->next_same_dest;
       40: 6100:      df->next_same_dest->prev_same_dest = dest->transition_refs;
       40: 6101:      df->next_same_dest = dft;
       40: 6102:      dft->prev_same_dest = df;
        -: 6103:    }
      395: 6104:  return 1;
        -: 6105:}
        -: 6106:
        -: 6107:
        -: 6108:/* This takes a superstate and a character, and computes some edges
        -: 6109: * from the superstate NFA.  In particular, this computes all edges
        -: 6110: * that lead from SUPERSTATE given CHR.   This function also 
        -: 6111: * computes the set of characters that share this edge set.
        -: 6112: * This returns 0 on allocation error.
        -: 6113: * The character set and list of edges are returned through 
        -: 6114: * the paramters CSETOUT and DFOUT.
        -: 6115:} */
        -: 6116:
        -: 6117:#ifdef __STDC__
        -: 6118:static int 
function compute_super_edge called 676 returned 100% blocks executed 64%
      676: 6119:compute_super_edge (struct rx *rx, struct rx_distinct_future **dfout,
        -: 6120:			  rx_Bitset csetout, struct rx_superstate *superstate,
        -: 6121:			  unsigned char chr)  
        -: 6122:#else
        -: 6123:static int 
        -: 6124:compute_super_edge (rx, dfout, csetout, superstate, chr)
        -: 6125:     struct rx *rx;
        -: 6126:     struct rx_distinct_future **dfout;
        -: 6127:     rx_Bitset csetout;
        -: 6128:     struct rx_superstate *superstate;
        -: 6129:     unsigned char chr;
        -: 6130:#endif
        -: 6131:{
      676: 6132:  struct rx_superset *stateset = superstate->contents;
        -: 6133:
        -: 6134:  /* To compute the set of characters that share edges with CHR, 
        -: 6135:   * we start with the full character set, and subtract.
        -: 6136:   */
      676: 6137:  rx_bitset_universe (rx->local_cset_size, csetout);
call    0 returned 676
      676: 6138:  *dfout = 0;
        -: 6139:
        -: 6140:  /* Iterate over the NFA states in the superstate state-set. */
     1624: 6141:  while (stateset->car)
branch  0 taken 948
branch  1 taken 676 (fallthrough)
        -: 6142:    {
        -: 6143:      struct rx_nfa_edge *e;
     1896: 6144:      for (e = stateset->car->edges; e; e = e->next)
branch  0 taken 948
branch  1 taken 948 (fallthrough)
      948: 6145:	if (RX_bitset_member (e->params.cset, chr))
branch  0 taken 613 (fallthrough)
branch  1 taken 335
        -: 6146:	  {
        -: 6147:	    /* If we find an NFA edge that applies, we make sure there
        -: 6148:	     * are corresponding edges in the superstate NFA.
        -: 6149:	     */
        -: 6150:	    {
        -: 6151:	      struct rx_distinct_future * saved;
      613: 6152:	      saved = *dfout;
      613: 6153:	      *dfout = include_futures (rx, *dfout, e->dest, superstate);
call    0 returned 613
      613: 6154:	      if (!*dfout)
branch  0 taken 0 (fallthrough)
branch  1 taken 613
        -: 6155:		{
        -: 6156:		  struct rx_distinct_future * df;
    #####: 6157:		  df = saved;
    #####: 6158:		  df->next_same_super_edge[1]->next_same_super_edge[0] = 0;
    #####: 6159:		  while (df)
branch  0 never executed
branch  1 never executed
        -: 6160:		    {
        -: 6161:		      struct rx_distinct_future *dft;
    #####: 6162:		      dft = df;
    #####: 6163:		      df = df->next_same_super_edge[0];
        -: 6164:
    #####: 6165:		      if (dft->future && dft->future->transition_refs == dft)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 6166:			{
    #####: 6167:			  dft->future->transition_refs = dft->next_same_dest;
    #####: 6168:			  if (dft->future->transition_refs == dft)
branch  0 never executed
branch  1 never executed
    #####: 6169:			    dft->future->transition_refs = 0;
        -: 6170:			}
    #####: 6171:		      dft->next_same_dest->prev_same_dest = dft->prev_same_dest;
    #####: 6172:		      dft->prev_same_dest->next_same_dest = dft->next_same_dest;
    #####: 6173:		      rx_cache_free (rx->cache,
    #####: 6174:				     &rx->cache->free_discernable_futures,
call    0 never executed
        -: 6175:				     (char *)dft);
        -: 6176:		    }
    #####: 6177:		  return 0;
        -: 6178:		}
        -: 6179:	    }
        -: 6180:	    /* We also trim the character set a bit. */
      613: 6181:	    rx_bitset_intersection (rx->local_cset_size,
call    0 returned 613
        -: 6182:				    csetout, e->params.cset);
        -: 6183:	  }
        -: 6184:	else
        -: 6185:	  /* An edge that doesn't apply at least tells us some characters
        -: 6186:	   * that don't share the same edge set as CHR.
        -: 6187:	   */
      335: 6188:	  rx_bitset_difference (rx->local_cset_size, csetout, e->params.cset);
call    0 returned 335
      948: 6189:      stateset = stateset->cdr;
        -: 6190:    }
      676: 6191:  return 1;
        -: 6192:}
        -: 6193:
        -: 6194:
        -: 6195:/* This is a constructor for RX_SUPER_EDGE structures.  These are
        -: 6196: * wrappers for lists of superstate NFA edges that share character sets labels.
        -: 6197: * If a transition class contains more than one rx_distinct_future (superstate
        -: 6198: * edge), then it represents a non-determinism in the superstate NFA.
        -: 6199: */
        -: 6200:
        -: 6201:#ifdef __STDC__
        -: 6202:static struct rx_super_edge *
function rx_super_edge called 583 returned 100% blocks executed 91%
      583: 6203:rx_super_edge (struct rx *rx,
        -: 6204:	       struct rx_superstate *super, rx_Bitset cset,
        -: 6205:	       struct rx_distinct_future *df) 
        -: 6206:#else
        -: 6207:static struct rx_super_edge *
        -: 6208:rx_super_edge (rx, super, cset, df)
        -: 6209:     struct rx *rx;
        -: 6210:     struct rx_superstate *super;
        -: 6211:     rx_Bitset cset;
        -: 6212:     struct rx_distinct_future *df;
        -: 6213:#endif
        -: 6214:{
        -: 6215:  struct rx_super_edge *tc =
      583: 6216:    (struct rx_super_edge *)rx_cache_malloc_or_get
      583: 6217:      (rx->cache, &rx->cache->free_transition_classes,
      583: 6218:       sizeof (struct rx_super_edge) + rx_sizeof_bitset (rx->local_cset_size));
call    0 returned 583
        -: 6219:
      583: 6220:  if (!tc)
branch  0 taken 0 (fallthrough)
branch  1 taken 583
    #####: 6221:    return 0;
      583: 6222:  tc->next = super->edges;
      583: 6223:  super->edges = tc;
      583: 6224:  tc->rx_backtrack_frame.inx = rx->instruction_table[rx_backtrack_point];
      583: 6225:  tc->rx_backtrack_frame.data = 0;
      583: 6226:  tc->rx_backtrack_frame.data_2 = (void *) tc;
      583: 6227:  tc->options = df;
      583: 6228:  tc->cset = (rx_Bitset) ((char *) tc + sizeof (*tc));
      583: 6229:  rx_bitset_assign (rx->local_cset_size, tc->cset, cset);
call    0 returned 583
      583: 6230:  if (df)
branch  0 taken 583 (fallthrough)
branch  1 taken 0
        -: 6231:    {
      583: 6232:      struct rx_distinct_future * dfp = df;
      583: 6233:      df->next_same_super_edge[1]->next_same_super_edge[0] = 0;
     1224: 6234:      while (dfp)
branch  0 taken 641
branch  1 taken 583 (fallthrough)
        -: 6235:	{
      641: 6236:	  dfp->edge = tc;
      641: 6237:	  dfp = dfp->next_same_super_edge[0];
        -: 6238:	}
      583: 6239:      df->next_same_super_edge[1]->next_same_super_edge[0] = df;
        -: 6240:    }
      583: 6241:  return tc;
        -: 6242:}
        -: 6243:
        -: 6244:
        -: 6245:/* There are three kinds of cache miss.  The first occurs when a
        -: 6246: * transition is taken that has never been computed during the
        -: 6247: * lifetime of the source superstate.  That cache miss is handled by
        -: 6248: * calling COMPUTE_SUPER_EDGE.  The second kind of cache miss
        -: 6249: * occurs when the destination superstate of a transition doesn't
        -: 6250: * exist.  SOLVE_DESTINATION is used to construct the destination superstate.
        -: 6251: * Finally, the third kind of cache miss occurs when the destination
        -: 6252: * superstate of a transition is in a `semi-free state'.  That case is
        -: 6253: * handled by UNFREE_SUPERSTATE.
        -: 6254: *
        -: 6255: * The function of HANDLE_CACHE_MISS is to figure out which of these
        -: 6256: * cases applies.
        -: 6257: */
        -: 6258:
        -: 6259:#ifdef __STDC__
        -: 6260:static void
function install_partial_transition called 1059 returned 100% blocks executed 100%
     1059: 6261:install_partial_transition  (struct rx_superstate *super,
        -: 6262:			     struct rx_inx *answer,
        -: 6263:			     RX_subset set, int offset)
        -: 6264:#else
        -: 6265:static void
        -: 6266:install_partial_transition  (super, answer, set, offset)
        -: 6267:     struct rx_superstate *super;
        -: 6268:     struct rx_inx *answer;
        -: 6269:     RX_subset set;
        -: 6270:     int offset;
        -: 6271:#endif
        -: 6272:{
     1059: 6273:  int start = offset;
     1059: 6274:  int end = start + 32;
     1059: 6275:  RX_subset pos = 1;
     1059: 6276:  struct rx_inx * transitions = super->transitions;
        -: 6277:  
    34947: 6278:  while (start < end)
branch  0 taken 33888
branch  1 taken 1059 (fallthrough)
        -: 6279:    {
    33888: 6280:      if (set & pos)
branch  0 taken 7520 (fallthrough)
branch  1 taken 26368
     7520: 6281:	transitions[start] = *answer;
    33888: 6282:      pos <<= 1;
    33888: 6283:      ++start;
        -: 6284:    }
     1059: 6285:}
        -: 6286:
        -: 6287:
        -: 6288:#ifdef __STDC__
        -: 6289:RX_DECL struct rx_inx *
function rx_handle_cache_miss called 1237 returned 100% blocks executed 85%
     1237: 6290:rx_handle_cache_miss
        -: 6291:  (struct rx *rx, struct rx_superstate *super, unsigned char chr, void *data) 
        -: 6292:#else
        -: 6293:RX_DECL struct rx_inx *
        -: 6294:rx_handle_cache_miss (rx, super, chr, data)
        -: 6295:     struct rx *rx;
        -: 6296:     struct rx_superstate *super;
        -: 6297:     unsigned char chr;
        -: 6298:     void *data;
        -: 6299:#endif
        -: 6300:{
     1237: 6301:  int offset = chr / RX_subset_bits;
     1237: 6302:  struct rx_distinct_future *df = data;
        -: 6303:
     1237: 6304:  if (!df)			/* must be the shared_cache_miss_frame */
branch  0 taken 753 (fallthrough)
branch  1 taken 484
        -: 6305:    {
        -: 6306:      /* Perhaps this is just a transition waiting to be filled. */
        -: 6307:      struct rx_super_edge *tc;
      753: 6308:      RX_subset mask = rx_subset_singletons [chr % RX_subset_bits];
        -: 6309:
      826: 6310:      for (tc = super->edges; tc; tc = tc->next)
branch  0 taken 150
branch  1 taken 676 (fallthrough)
      150: 6311:	if (tc->cset[offset] & mask)
branch  0 taken 77 (fallthrough)
branch  1 taken 73
        -: 6312:	  {
        -: 6313:	    struct rx_inx * answer;
       77: 6314:	    df = tc->options;
      154: 6315:	    answer = ((tc->options->next_same_super_edge[0] != tc->options)
        -: 6316:		      ? &tc->rx_backtrack_frame
      104: 6317:		      : (df->effects
branch  0 taken 50 (fallthrough)
branch  1 taken 27
        3: 6318:			 ? &df->side_effects_frame
       27: 6319:			 : &df->future_frame));
branch  0 taken 3 (fallthrough)
branch  1 taken 24
       77: 6320:	    install_partial_transition (super, answer,
       77: 6321:					tc->cset [offset], offset * 32);
call    0 returned 77
       77: 6322:	    return answer;
        -: 6323:	  }
        -: 6324:      /* Otherwise, it's a flushed or  newly encountered edge. */
        -: 6325:      {
        -: 6326:	char cset_space[1024];	/* this limit is far from unreasonable */
        -: 6327:	rx_Bitset trcset;
        -: 6328:	struct rx_inx *answer;
        -: 6329:
      676: 6330:	if (rx_sizeof_bitset (rx->local_cset_size) > sizeof (cset_space))
branch  0 taken 0 (fallthrough)
branch  1 taken 676
    #####: 6331:	  return 0;		/* If the arbitrary limit is hit, always fail */
        -: 6332:				/* cleanly. */
      676: 6333:	trcset = (rx_Bitset)cset_space;
      676: 6334:	rx_lock_superstate (rx, super);
      676: 6335:	if (!compute_super_edge (rx, &df, trcset, super, chr))
call    0 returned 676
branch  1 taken 0 (fallthrough)
branch  2 taken 676
        -: 6336:	  {
    #####: 6337:	    rx_unlock_superstate (rx, super);
    #####: 6338:	    return 0;
        -: 6339:	  }
      676: 6340:	if (!df)		/* We just computed the fail transition. */
branch  0 taken 93 (fallthrough)
branch  1 taken 583
        -: 6341:	  {
        -: 6342:	    static struct rx_inx
        -: 6343:	      shared_fail_frame = { (void *)rx_backtrack, 0, 0 };
       93: 6344:	    answer = &shared_fail_frame;
        -: 6345:	  }
        -: 6346:	else
        -: 6347:	  {
      583: 6348:	    tc = rx_super_edge (rx, super, trcset, df);
call    0 returned 583
      583: 6349:	    if (!tc)
branch  0 taken 0 (fallthrough)
branch  1 taken 583
        -: 6350:	      {
    #####: 6351:		rx_unlock_superstate (rx, super);
    #####: 6352:		return 0;
        -: 6353:	      }
      583: 6354:	    answer = ((tc->options->next_same_super_edge[0] != tc->options)
        -: 6355:		      ? &tc->rx_backtrack_frame
     1108: 6356:		      : (df->effects
branch  0 taken 58 (fallthrough)
branch  1 taken 525
      219: 6357:			 ? &df->side_effects_frame
      525: 6358:			 : &df->future_frame));
branch  0 taken 219 (fallthrough)
branch  1 taken 306
        -: 6359:	  }
      676: 6360:	install_partial_transition (super, answer,
      676: 6361:				    trcset[offset], offset * 32);
call    0 returned 676
      676: 6362:	rx_unlock_superstate (rx, super);
      676: 6363:	return answer;
        -: 6364:      }
        -: 6365:    }
      484: 6366:  else if (df->future) /* A cache miss on an edge with a future? Must be
branch  0 taken 0 (fallthrough)
branch  1 taken 484
        -: 6367:			* a semi-free destination. */
        -: 6368:    {				
    #####: 6369:      if (df->future->is_semifree)
branch  0 never executed
branch  1 never executed
    #####: 6370:	refresh_semifree_superstate (rx->cache, df->future);
call    0 never executed
    #####: 6371:      return &df->future_frame;
        -: 6372:    }
        -: 6373:  else
        -: 6374:    /* no future superstate on an existing edge */
        -: 6375:    {
      484: 6376:      rx_lock_superstate (rx, super);
      484: 6377:      if (!solve_destination (rx, df))
call    0 returned 484
branch  1 taken 0 (fallthrough)
branch  2 taken 484
        -: 6378:	{
    #####: 6379:	  rx_unlock_superstate (rx, super);
    #####: 6380:	  return 0;
        -: 6381:	}
      484: 6382:      if (!df->effects
branch  0 taken 364 (fallthrough)
branch  1 taken 120
      364: 6383:	  && (df->edge->options->next_same_super_edge[0] == df->edge->options))
branch  0 taken 306 (fallthrough)
branch  1 taken 58
      306: 6384:	install_partial_transition (super, &df->future_frame,
      306: 6385:				    df->edge->cset[offset], offset * 32);
call    0 returned 306
      484: 6386:      rx_unlock_superstate (rx, super);
      484: 6387:      return &df->future_frame;
        -: 6388:    }
        -: 6389:}
        -: 6390:
        -: 6391:
        -: 6392:
        -: 6393:
        -: 6394:/* The rest of the code provides a regex.c compatable interface. */
        -: 6395:
        -: 6396:
        -: 6397:const char *re_error_msg[] =
        -: 6398:{
        -: 6399:  0,						/* REG_NOUT */
        -: 6400:  "No match",					/* REG_NOMATCH */
        -: 6401:  "Invalid regular expression",			/* REG_BADPAT */
        -: 6402:  "Invalid collation character",		/* REG_ECOLLATE */
        -: 6403:  "Invalid character class name",		/* REG_ECTYPE */
        -: 6404:  "Trailing backslash",				/* REG_EESCAPE */
        -: 6405:  "Invalid back reference",			/* REG_ESUBREG */
        -: 6406:  "Unmatched [ or [^",				/* REG_EBRACK */
        -: 6407:  "Unmatched ( or \\(",				/* REG_EPAREN */
        -: 6408:  "Unmatched \\{",				/* REG_EBRACE */
        -: 6409:  "Invalid content of \\{\\}",			/* REG_BADBR */
        -: 6410:  "Invalid range end",				/* REG_ERANGE */
        -: 6411:  "Memory exhausted",				/* REG_ESPACE */
        -: 6412:  "Invalid preceding regular expression",	/* REG_BADRPT */
        -: 6413:  "Premature end of regular expression",	/* REG_EEND */
        -: 6414:  "Regular expression too big",			/* REG_ESIZE */
        -: 6415:  "Unmatched ) or \\)",				/* REG_ERPAREN */
        -: 6416:};
        -: 6417:
        -: 6418:
        -: 6419:
        -: 6420:/* 
        -: 6421: * Macros used while compiling patterns.
        -: 6422: *
        -: 6423: * By convention, PEND points just past the end of the uncompiled pattern,
        -: 6424: * P points to the read position in the pattern.  `translate' is the name
        -: 6425: * of the translation table (`TRANSLATE' is the name of a macro that looks
        -: 6426: * things up in `translate').
        -: 6427: */
        -: 6428:
        -: 6429:
        -: 6430:/*
        -: 6431: * Fetch the next character in the uncompiled pattern---translating it 
        -: 6432: * if necessary. *Also cast from a signed character in the constant
        -: 6433: * string passed to us by the user to an unsigned char that we can use
        -: 6434: * as an array index (in, e.g., `translate').
        -: 6435: */
        -: 6436:#define PATFETCH(c)							\
        -: 6437: do {if (p == pend) return REG_EEND;					\
        -: 6438:    c = (unsigned char) *p++;						\
        -: 6439:    c = translate[c];		 					\
        -: 6440: } while (0)
        -: 6441:
        -: 6442:/* 
        -: 6443: * Fetch the next character in the uncompiled pattern, with no
        -: 6444: * translation.
        -: 6445: */
        -: 6446:#define PATFETCH_RAW(c)							\
        -: 6447:  do {if (p == pend) return REG_EEND;					\
        -: 6448:    c = (unsigned char) *p++; 						\
        -: 6449:  } while (0)
        -: 6450:
        -: 6451:/* Go backwards one character in the pattern.  */
        -: 6452:#define PATUNFETCH p--
        -: 6453:
        -: 6454:
        -: 6455:#define TRANSLATE(d) translate[(unsigned char) (d)]
        -: 6456:
        -: 6457:typedef unsigned regnum_t;
        -: 6458:
        -: 6459:/* Since offsets can go either forwards or backwards, this type needs to
        -: 6460: * be able to hold values from -(MAX_BUF_SIZE - 1) to MAX_BUF_SIZE - 1.
        -: 6461: */
        -: 6462:typedef int pattern_offset_t;
        -: 6463:
        -: 6464:typedef struct
        -: 6465:{
        -: 6466:  struct rexp_node ** top_expression; /* was begalt */
        -: 6467:  struct rexp_node ** last_expression; /* was laststart */
        -: 6468:  pattern_offset_t inner_group_offset;
        -: 6469:  regnum_t regnum;
        -: 6470:} compile_stack_elt_t;
        -: 6471:
        -: 6472:typedef struct
        -: 6473:{
        -: 6474:  compile_stack_elt_t *stack;
        -: 6475:  unsigned size;
        -: 6476:  unsigned avail;			/* Offset of next open position.  */
        -: 6477:} compile_stack_type;
        -: 6478:
        -: 6479:
        -: 6480:#define INIT_COMPILE_STACK_SIZE 32
        -: 6481:
        -: 6482:#define COMPILE_STACK_EMPTY  (compile_stack.avail == 0)
        -: 6483:#define COMPILE_STACK_FULL  (compile_stack.avail == compile_stack.size)
        -: 6484:
        -: 6485:/* The next available element.  */
        -: 6486:#define COMPILE_STACK_TOP (compile_stack.stack[compile_stack.avail])
        -: 6487:
        -: 6488:
        -: 6489:/* Set the bit for character C in a list.  */
        -: 6490:#define SET_LIST_BIT(c)                               \
        -: 6491:  (b[((unsigned char) (c)) / BYTEWIDTH]               \
        -: 6492:   |= 1 << (((unsigned char) c) % BYTEWIDTH))
        -: 6493:
        -: 6494:/* Get the next unsigned number in the uncompiled pattern.  */
        -: 6495:#define GET_UNSIGNED_NUMBER(num) 					\
        -: 6496:  { if (p != pend)							\
        -: 6497:     {									\
        -: 6498:       PATFETCH (c); 							\
        -: 6499:       while (isdigit (c)) 						\
        -: 6500:         { 								\
        -: 6501:           if (num < 0)							\
        -: 6502:              num = 0;							\
        -: 6503:           num = num * 10 + c - '0'; 					\
        -: 6504:           if (p == pend) 						\
        -: 6505:              break; 							\
        -: 6506:           PATFETCH (c);						\
        -: 6507:         } 								\
        -: 6508:       } 								\
        -: 6509:    }		
        -: 6510:
        -: 6511:#define CHAR_CLASS_MAX_LENGTH  6 /* Namely, `xdigit'.  */
        -: 6512:
        -: 6513:#define IS_CHAR_CLASS(string)						\
        -: 6514:   (!strcmp (string, "alpha") || !strcmp (string, "upper")		\
        -: 6515:    || !strcmp (string, "lower") || !strcmp (string, "digit")		\
        -: 6516:    || !strcmp (string, "alnum") || !strcmp (string, "xdigit")		\
        -: 6517:    || !strcmp (string, "space") || !strcmp (string, "print")		\
        -: 6518:    || !strcmp (string, "punct") || !strcmp (string, "graph")		\
        -: 6519:    || !strcmp (string, "cntrl") || !strcmp (string, "blank"))
        -: 6520:
        -: 6521:
        -: 6522:/* These predicates are used in regex_compile. */
        -: 6523:
        -: 6524:/* P points to just after a ^ in PATTERN.  Return true if that ^ comes
        -: 6525: * after an alternative or a begin-subexpression.  We assume there is at
        -: 6526: * least one character before the ^.  
        -: 6527: */
        -: 6528:
        -: 6529:#ifdef __STDC__
        -: 6530:static boolean
function at_begline_loc_p called 0 returned 0% blocks executed 0%
    #####: 6531:at_begline_loc_p (const char *pattern, const char * p, reg_syntax_t syntax)
        -: 6532:#else
        -: 6533:static boolean
        -: 6534:at_begline_loc_p (pattern, p, syntax)
        -: 6535:     const char *pattern;
        -: 6536:     const char * p;
        -: 6537:     reg_syntax_t syntax;
        -: 6538:#endif
        -: 6539:{
    #####: 6540:  const char *prev = p - 2;
    #####: 6541:  boolean prev_prev_backslash = ((prev > pattern) && (prev[-1] == '\\'));
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 6542:  
        -: 6543:    return
        -: 6544:      
        -: 6545:      (/* After a subexpression?  */
    #####: 6546:       ((*prev == '(') && ((syntax & RE_NO_BK_PARENS) || prev_prev_backslash))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 6547:       ||
branch  0 never executed
branch  1 never executed
        -: 6548:       /* After an alternative?  */
    #####: 6549:       ((*prev == '|') && ((syntax & RE_NO_BK_VBAR) || prev_prev_backslash))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 6550:       );
        -: 6551:}
        -: 6552:
        -: 6553:/* The dual of at_begline_loc_p.  This one is for $.  We assume there is
        -: 6554: * at least one character after the $, i.e., `P < PEND'.
        -: 6555: */
        -: 6556:
        -: 6557:#ifdef __STDC__
        -: 6558:static boolean
function at_endline_loc_p called 0 returned 0% blocks executed 0%
    #####: 6559:at_endline_loc_p (const char *p, const char *pend, int syntax)
        -: 6560:#else
        -: 6561:static boolean
        -: 6562:at_endline_loc_p (p, pend, syntax)
        -: 6563:     const char *p;
        -: 6564:     const char *pend;
        -: 6565:     int syntax;
        -: 6566:#endif
        -: 6567:{
    #####: 6568:  const char *next = p;
    #####: 6569:  boolean next_backslash = (*next == '\\');
    #####: 6570:  const char *next_next = (p + 1 < pend) ? (p + 1) : 0;
branch  0 never executed
branch  1 never executed
        -: 6571:  
        -: 6572:  return
        -: 6573:    (
        -: 6574:     /* Before a subexpression?  */
    #####: 6575:     ((syntax & RE_NO_BK_PARENS)
    #####: 6576:      ? (*next == ')')
    #####: 6577:      : (next_backslash && next_next && (*next_next == ')')))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 6578:    ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -: 6579:     /* Before an alternative?  */
    #####: 6580:     ((syntax & RE_NO_BK_VBAR)
branch  0 never executed
branch  1 never executed
    #####: 6581:      ? (*next == '|')
branch  0 never executed
branch  1 never executed
    #####: 6582:      : (next_backslash && next_next && (*next_next == '|')))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 6583:     );
        -: 6584:}
        -: 6585:
        -: 6586:
        -: 6587:static unsigned char id_translation[256] =
        -: 6588:{
        -: 6589:  0,  1,  2,  3,  4,  5,  6,  7,  8,  9,
        -: 6590: 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
        -: 6591: 20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
        -: 6592: 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,
        -: 6593: 40, 41, 42, 43, 44, 45, 46, 47, 48, 49,
        -: 6594: 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,
        -: 6595: 60, 61, 62, 63, 64, 65, 66, 67, 68, 69,
        -: 6596: 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
        -: 6597: 80, 81, 82, 83, 84, 85, 86, 87, 88, 89,
        -: 6598: 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,
        -: 6599:
        -: 6600: 100, 101, 102, 103, 104, 105, 106, 107, 108, 109,
        -: 6601: 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,
        -: 6602: 120, 121, 122, 123, 124, 125, 126, 127, 128, 129,
        -: 6603: 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,
        -: 6604: 140, 141, 142, 143, 144, 145, 146, 147, 148, 149,
        -: 6605: 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,
        -: 6606: 160, 161, 162, 163, 164, 165, 166, 167, 168, 169,
        -: 6607: 170, 171, 172, 173, 174, 175, 176, 177, 178, 179,
        -: 6608: 180, 181, 182, 183, 184, 185, 186, 187, 188, 189,
        -: 6609: 190, 191, 192, 193, 194, 195, 196, 197, 198, 199,
        -: 6610:
        -: 6611: 200, 201, 202, 203, 204, 205, 206, 207, 208, 209,
        -: 6612: 210, 211, 212, 213, 214, 215, 216, 217, 218, 219,
        -: 6613: 220, 221, 222, 223, 224, 225, 226, 227, 228, 229,
        -: 6614: 230, 231, 232, 233, 234, 235, 236, 237, 238, 239,
        -: 6615: 240, 241, 242, 243, 244, 245, 246, 247, 248, 249,
        -: 6616: 250, 251, 252, 253, 254, 255
        -: 6617:};
        -: 6618:
        -: 6619:/* The compiler keeps an inverted translation table.
        -: 6620: * This looks up/inititalize elements.
        -: 6621: * VALID is an array of booleans that validate CACHE.
        -: 6622: */
        -: 6623:
        -: 6624:#ifdef __STDC__
        -: 6625:static rx_Bitset
function inverse_translation called 362 returned 100% blocks executed 100%
      362: 6626:inverse_translation (struct re_pattern_buffer * rxb,
        -: 6627:		     char * valid, rx_Bitset cache,
        -: 6628:		     unsigned char * translate, int c)
        -: 6629:#else
        -: 6630:static rx_Bitset
        -: 6631:inverse_translation (rxb, valid, cache, translate, c)
        -: 6632:     struct re_pattern_buffer * rxb;
        -: 6633:     char * valid;
        -: 6634:     rx_Bitset cache;
        -: 6635:     unsigned char * translate;
        -: 6636:     int c;
        -: 6637:#endif
        -: 6638:{
      362: 6639:  rx_Bitset cs
      362: 6640:    = cache + c * rx_bitset_numb_subsets (rxb->rx.local_cset_size); 
        -: 6641:
      362: 6642:  if (!valid[c])
branch  0 taken 315 (fallthrough)
branch  1 taken 47
        -: 6643:    {
        -: 6644:      int x;
      315: 6645:      int c_tr = TRANSLATE(c);
      315: 6646:      rx_bitset_null (rxb->rx.local_cset_size, cs);
call    0 returned 315
    80955: 6647:      for (x = 0; x < 256; ++x)	/* &&&& 13.37 */
branch  0 taken 80640
branch  1 taken 315 (fallthrough)
    80640: 6648:	if (TRANSLATE(x) == c_tr)
branch  0 taken 315 (fallthrough)
branch  1 taken 80325
      315: 6649:	  RX_bitset_enjoin (cs, x);
      315: 6650:      valid[c] = 1;
        -: 6651:    }
      362: 6652:  return cs;
        -: 6653:}
        -: 6654:
        -: 6655:
        -: 6656:
        -: 6657:
        -: 6658:/* More subroutine declarations and macros for regex_compile.  */
        -: 6659:
        -: 6660:/* Returns true if REGNUM is in one of COMPILE_STACK's elements and 
        -: 6661:   false if it's not.  */
        -: 6662:
        -: 6663:#ifdef __STDC__
        -: 6664:static boolean
function group_in_compile_stack called 0 returned 0% blocks executed 0%
    #####: 6665:group_in_compile_stack (compile_stack_type compile_stack, regnum_t regnum)
        -: 6666:#else
        -: 6667:static boolean
        -: 6668:group_in_compile_stack (compile_stack, regnum)
        -: 6669:    compile_stack_type compile_stack;
        -: 6670:    regnum_t regnum;
        -: 6671:#endif
        -: 6672:{
        -: 6673:  int this_element;
        -: 6674:
    #####: 6675:  for (this_element = compile_stack.avail - 1;  
    #####: 6676:       this_element >= 0; 
branch  0 never executed
branch  1 never executed
    #####: 6677:       this_element--)
    #####: 6678:    if (compile_stack.stack[this_element].regnum == regnum)
branch  0 never executed
branch  1 never executed
    #####: 6679:      return true;
        -: 6680:
    #####: 6681:  return false;
        -: 6682:}
        -: 6683:
        -: 6684:
        -: 6685:/*
        -: 6686: * Read the ending character of a range (in a bracket expression) from the
        -: 6687: * uncompiled pattern *P_PTR (which ends at PEND).  We assume the
        -: 6688: * starting character is in `P[-2]'.  (`P[-1]' is the character `-'.)
        -: 6689: * Then we set the translation of all bits between the starting and
        -: 6690: * ending characters (inclusive) in the compiled pattern B.
        -: 6691: * 
        -: 6692: * Return an error code.
        -: 6693: * 
        -: 6694: * We use these short variable names so we can use the same macros as
        -: 6695: * `regex_compile' itself.  
        -: 6696: */
        -: 6697:
        -: 6698:#ifdef __STDC__
        -: 6699:static reg_errcode_t
function compile_range called 0 returned 0% blocks executed 0%
    #####: 6700:compile_range (struct re_pattern_buffer * rxb, rx_Bitset cs,
        -: 6701:	       const char ** p_ptr, const char * pend,
        -: 6702:	       unsigned char * translate, reg_syntax_t syntax,
        -: 6703:	       rx_Bitset inv_tr,  char * valid_inv_tr)
        -: 6704:#else
        -: 6705:static reg_errcode_t
        -: 6706:compile_range (rxb, cs, p_ptr, pend, translate, syntax, inv_tr, valid_inv_tr)
        -: 6707:     struct re_pattern_buffer * rxb;
        -: 6708:     rx_Bitset cs;
        -: 6709:     const char ** p_ptr;
        -: 6710:     const char * pend;
        -: 6711:     unsigned char * translate;
        -: 6712:     reg_syntax_t syntax;
        -: 6713:     rx_Bitset inv_tr;
        -: 6714:     char * valid_inv_tr;
        -: 6715:#endif
        -: 6716:{
        -: 6717:  unsigned this_char;
        -: 6718:
    #####: 6719:  const char *p = *p_ptr;
        -: 6720:
        -: 6721:  unsigned char range_end;
    #####: 6722:  unsigned char range_start = TRANSLATE(p[-2]);
        -: 6723:
    #####: 6724:  if (p == pend)
branch  0 never executed
branch  1 never executed
    #####: 6725:    return REG_ERANGE;
        -: 6726:
    #####: 6727:  PATFETCH (range_end);
branch  0 never executed
branch  1 never executed
        -: 6728:
    #####: 6729:  (*p_ptr)++;
        -: 6730:
    #####: 6731:  if (range_start > range_end)
branch  0 never executed
branch  1 never executed
    #####: 6732:    return syntax & RE_NO_EMPTY_RANGES ? REG_ERANGE : REG_NOERROR;
branch  0 never executed
branch  1 never executed
        -: 6733:
    #####: 6734:  for (this_char = range_start; this_char <= range_end; this_char++)
branch  0 never executed
branch  1 never executed
        -: 6735:    {
        -: 6736:      rx_Bitset it =
    #####: 6737:	inverse_translation (rxb, valid_inv_tr, inv_tr, translate, this_char);
call    0 never executed
    #####: 6738:      rx_bitset_union (rxb->rx.local_cset_size, cs, it);
call    0 never executed
        -: 6739:    }
        -: 6740:  
    #####: 6741:  return REG_NOERROR;
        -: 6742:}
        -: 6743:
        -: 6744:
        -: 6745:/* This searches a regexp for backreference side effects.
        -: 6746: * It fills in the array OUT with 1 at the index of every register pair
        -: 6747: * referenced by a backreference.
        -: 6748: *
        -: 6749: * This is used to help optimize patterns for searching.  The information is
        -: 6750: * useful because, if the caller doesn't want register values, backreferenced
        -: 6751: * registers are the only registers for which we need rx_backtrack.
        -: 6752: */
        -: 6753:
        -: 6754:#ifdef __STDC__
        -: 6755:static void
function find_backrefs called 1294 returned 100% blocks executed 91%
     1294: 6756:find_backrefs (char * out, struct rexp_node * rexp,
        -: 6757:	       struct re_se_params * params)
        -: 6758:#else
        -: 6759:static void
        -: 6760:find_backrefs (out, rexp, params)
        -: 6761:     char * out;
        -: 6762:     struct rexp_node * rexp;
        -: 6763:     struct re_se_params * params;
        -: 6764:#endif
        -: 6765:{
     1294: 6766:  if (rexp)
branch  0 taken 1257 (fallthrough)
branch  1 taken 37
     1257: 6767:    switch (rexp->type)
branch  0 taken 378
branch  1 taken 531
branch  2 taken 348
branch  3 taken 0
        -: 6768:      {
      378: 6769:      case r_cset:
        -: 6770:      case r_data:
      378: 6771:	return;
      531: 6772:      case r_alternate:
        -: 6773:      case r_concat:
        -: 6774:      case r_opt:
        -: 6775:      case r_star:
        -: 6776:      case r_2phase_star:
      531: 6777:	find_backrefs (out, rexp->params.pair.left, params);
call    0 returned 531
      531: 6778:	find_backrefs (out, rexp->params.pair.right, params);
call    0 returned 531
      531: 6779:	return;
      348: 6780:      case r_side_effect:
      348: 6781:	if (   ((int)rexp->params.side_effect >= 0)
branch  0 taken 232 (fallthrough)
branch  1 taken 116
      232: 6782:	    && (params [(int)rexp->params.side_effect].se == re_se_backref))
branch  0 taken 0 (fallthrough)
branch  1 taken 232
    #####: 6783:	  out[ params [(int)rexp->params.side_effect].op1] = 1;
      348: 6784:	return;
        -: 6785:      }
        -: 6786:}
        -: 6787:
        -: 6788:
        -: 6789:
        -: 6790:/* Returns 0 unless the pattern can match the empty string. */
        -: 6791:
        -: 6792:#ifdef __STDC__
        -: 6793:static int
function compute_fastset called 789 returned 100% blocks executed 65%
      789: 6794:compute_fastset (struct re_pattern_buffer * rxb, struct rexp_node * rexp)
        -: 6795:#else
        -: 6796:static int
        -: 6797:compute_fastset (rxb, rexp)
        -: 6798:     struct re_pattern_buffer * rxb;
        -: 6799:     struct rexp_node * rexp;
        -: 6800:#endif
        -: 6801:{
      789: 6802:  if (!rexp)
branch  0 taken 0 (fallthrough)
branch  1 taken 789
    #####: 6803:    return 1;
      789: 6804:  switch (rexp->type)
branch  0 taken 0
branch  1 taken 199
branch  2 taken 410
branch  3 taken 0
branch  4 taken 0
branch  5 taken 23
branch  6 taken 157
branch  7 taken 0
        -: 6805:    {
    #####: 6806:    case r_data:
    #####: 6807:      return 1;
      199: 6808:    case r_cset:
        -: 6809:      {
      199: 6810:	rx_bitset_union (rxb->rx.local_cset_size,
call    0 returned 199
        -: 6811:			 rxb->fastset, rexp->params.cset);
        -: 6812:      }
      199: 6813:      return 0;
      410: 6814:    case r_concat:
      410: 6815:      return (compute_fastset (rxb, rexp->params.pair.left)
call    0 returned 410
      410: 6816:	      && compute_fastset (rxb, rexp->params.pair.right));
branch  0 taken 124 (fallthrough)
branch  1 taken 286
call    2 returned 124
branch  3 taken 85 (fallthrough)
branch  4 taken 39
    #####: 6817:    case r_2phase_star:
    #####: 6818:      compute_fastset (rxb, rexp->params.pair.left);
call    0 never executed
        -: 6819:      /* compute_fastset (rxb, rexp->params.pair.right);  nope... */
    #####: 6820:      return 1;
    #####: 6821:    case r_alternate:
    #####: 6822:      return !!(compute_fastset (rxb, rexp->params.pair.left)
call    0 never executed
    #####: 6823:		+ compute_fastset (rxb, rexp->params.pair.right));
call    0 never executed
       23: 6824:    case r_opt:
        -: 6825:    case r_star:
       23: 6826:      compute_fastset (rxb, rexp->params.pair.left);
call    0 returned 23
       23: 6827:      return 1;
      157: 6828:    case r_side_effect:
      157: 6829:      return 1;
        -: 6830:    }
        -: 6831:
        -: 6832:  /* this should never happen */
    #####: 6833:  return 0;
        -: 6834:}
        -: 6835:
        -: 6836:
        -: 6837:/* returns
        -: 6838: *  1 -- yes, definately anchored by the given side effect.
        -: 6839: *  2 -- maybe anchored, maybe the empty string.
        -: 6840: *  0 -- definately not anchored
        -: 6841: *  There is simply no other possibility.
        -: 6842: */
        -: 6843:
        -: 6844:#ifdef __STDC__
        -: 6845:static int
function is_anchored called 1405 returned 100% blocks executed 68%
     1405: 6846:is_anchored (struct rexp_node * rexp, rx_side_effect se)
        -: 6847:#else
        -: 6848:static int
        -: 6849:is_anchored (rexp, se)
        -: 6850:     struct rexp_node * rexp;
        -: 6851:     rx_side_effect se;
        -: 6852:#endif
        -: 6853:{
     1405: 6854:  if (!rexp)
branch  0 taken 0 (fallthrough)
branch  1 taken 1405
    #####: 6855:    return 2;
     1405: 6856:  switch (rexp->type)
branch  0 taken 351
branch  1 taken 794
branch  2 taken 0
branch  3 taken 46
branch  4 taken 214
branch  5 taken 0
        -: 6857:    {
      351: 6858:    case r_cset:
        -: 6859:    case r_data:
      351: 6860:      return 0;
      794: 6861:    case r_concat:
        -: 6862:    case r_2phase_star:
        -: 6863:      {
      794: 6864:	int l = is_anchored (rexp->params.pair.left, se);
call    0 returned 794
      794: 6865:	return (l == 2 ? is_anchored (rexp->params.pair.right, se) : l);
branch  0 taken 101 (fallthrough)
branch  1 taken 693
call    2 returned 101
        -: 6866:      }
    #####: 6867:    case r_alternate:
        -: 6868:      {
    #####: 6869:	int l = is_anchored (rexp->params.pair.left, se);
call    0 never executed
    #####: 6870:	int r = l ? is_anchored (rexp->params.pair.right, se) : 0;
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 6871:	return MAX (l, r);
        -: 6872:      }
       46: 6873:    case r_opt:
        -: 6874:    case r_star:
      46*: 6875:      return is_anchored (rexp->params.pair.left, se) ? 2 : 0;
call    0 returned 46
branch  1 taken 0 (fallthrough)
branch  2 taken 46
        -: 6876:      
      214: 6877:    case r_side_effect:
      214: 6878:      return ((rexp->params.side_effect == se)
      214: 6879:	      ? 1 : 2);
branch  0 taken 72 (fallthrough)
branch  1 taken 142
        -: 6880:    }
        -: 6881:
        -: 6882:  /* this should never happen */
    #####: 6883:  return 0;
        -: 6884:}
        -: 6885:
        -: 6886:
        -: 6887:/* This removes register assignments that aren't required by backreferencing.
        -: 6888: * This can speed up explore_future, especially if it eliminates
        -: 6889: * non-determinism in the superstate NFA.
        -: 6890: * 
        -: 6891: * NEEDED is an array of characters, presumably filled in by FIND_BACKREFS.
        -: 6892: * The non-zero elements of the array indicate which register assignments
        -: 6893: * can NOT be removed from the expression.
        -: 6894: */
        -: 6895:
        -: 6896:#ifdef __STDC__
        -: 6897:static struct rexp_node *
function remove_unecessary_side_effects called 1257 returned 100% blocks executed 53%
     1257: 6898:remove_unecessary_side_effects (struct rx * rx, char * needed,
        -: 6899:				struct rexp_node * rexp,
        -: 6900:				struct re_se_params * params)
        -: 6901:#else
        -: 6902:static struct rexp_node *
        -: 6903:remove_unecessary_side_effects (rx, needed, rexp, params)
        -: 6904:     struct rx * rx;
        -: 6905:     char * needed;
        -: 6906:     struct rexp_node * rexp;
        -: 6907:     struct re_se_params * params;
        -: 6908:#endif
        -: 6909:{
        -: 6910:  struct rexp_node * l;
        -: 6911:  struct rexp_node * r;
     1257: 6912:  if (!rexp)
branch  0 taken 0 (fallthrough)
branch  1 taken 1257
    #####: 6913:    return 0;
        -: 6914:  else
     1257: 6915:    switch (rexp->type)
branch  0 taken 378
branch  1 taken 494
branch  2 taken 37
branch  3 taken 348
branch  4 taken 0
        -: 6916:      {
      378: 6917:      case r_cset:
        -: 6918:      case r_data:
      378: 6919:	return rexp;
      494: 6920:      case r_alternate:
        -: 6921:      case r_concat:
        -: 6922:      case r_2phase_star:
      494: 6923:	l = remove_unecessary_side_effects (rx, needed,
call    0 returned 494
        -: 6924:					    rexp->params.pair.left, params);
      494: 6925:	r = remove_unecessary_side_effects (rx, needed,
call    0 returned 494
        -: 6926:					    rexp->params.pair.right, params);
     494*: 6927:	if ((l && r) || (rexp->type != r_concat))
branch  0 taken 494 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 494
branch  4 never executed
branch  5 never executed
        -: 6928:	  {
      494: 6929:	    rexp->params.pair.left = l;
      494: 6930:	    rexp->params.pair.right = r;
      494: 6931:	    return rexp;
        -: 6932:	  }
        -: 6933:	else
        -: 6934:	  {
    #####: 6935:	    rexp->params.pair.left = rexp->params.pair.right = 0;
    #####: 6936:	    rx_free_rexp (rx, rexp);
call    0 never executed
    #####: 6937:	    return l ? l : r;
branch  0 never executed
branch  1 never executed
        -: 6938:	  }
       37: 6939:      case r_opt:
        -: 6940:      case r_star:
       37: 6941:	l = remove_unecessary_side_effects (rx, needed,
call    0 returned 37
        -: 6942:					    rexp->params.pair.left, params);
       37: 6943:	if (l)
branch  0 taken 37 (fallthrough)
branch  1 taken 0
        -: 6944:	  {
       37: 6945:	    rexp->params.pair.left = l;
       37: 6946:	    return rexp;
        -: 6947:	  }
        -: 6948:	else
        -: 6949:	  {
    #####: 6950:	    rexp->params.pair.left = 0;
    #####: 6951:	    rx_free_rexp (rx, rexp);
call    0 never executed
    #####: 6952:	    return 0;
        -: 6953:	  }
      348: 6954:      case r_side_effect:
        -: 6955:	{
      348: 6956:	  int se = (int)rexp->params.side_effect;
      348: 6957:	  if (   (se >= 0)
branch  0 taken 232 (fallthrough)
branch  1 taken 116
      232: 6958:	      && (   ((enum re_side_effects)params[se].se == re_se_lparen)
branch  0 taken 232 (fallthrough)
branch  1 taken 0
      232: 6959:		  || ((enum re_side_effects)params[se].se == re_se_rparen))
branch  0 taken 0 (fallthrough)
branch  1 taken 232
    #####: 6960:	      && (params [se].op1 > 0)
branch  0 never executed
branch  1 never executed
    #####: 6961:	      && (!needed [params [se].op1]))
branch  0 never executed
branch  1 never executed
        -: 6962:	    {
    #####: 6963:	      rx_free_rexp (rx, rexp);
call    0 never executed
    #####: 6964:	      return 0;
        -: 6965:	    }
        -: 6966:	  else
      348: 6967:	    return rexp;
        -: 6968:	}
        -: 6969:      }
        -: 6970:
        -: 6971:  /* this should never happen */
    #####: 6972:  return 0;
        -: 6973:}
        -: 6974:
        -: 6975:
        -: 6976:
        -: 6977:#ifdef __STDC__
        -: 6978:static int
function pointless_if_repeated called 37 returned 100% blocks executed 20%
       37: 6979:pointless_if_repeated (struct rexp_node * node, struct re_se_params * params)
        -: 6980:#else
        -: 6981:static int
        -: 6982:pointless_if_repeated (node, params)
        -: 6983:     struct rexp_node * node;
        -: 6984:     struct re_se_params * params;
        -: 6985:#endif
        -: 6986:{
       37: 6987:  if (!node)
branch  0 taken 0 (fallthrough)
branch  1 taken 37
    #####: 6988:    return 1;
       37: 6989:  switch (node->type)
branch  0 taken 37
branch  1 taken 0
branch  2 taken 0
branch  3 taken 0
branch  4 taken 0
        -: 6990:    {
       37: 6991:    case r_cset:
       37: 6992:      return 0;
    #####: 6993:    case r_alternate:
        -: 6994:    case r_concat:
        -: 6995:    case r_2phase_star:
    #####: 6996:      return (pointless_if_repeated (node->params.pair.left, params)
call    0 never executed
    #####: 6997:	      && pointless_if_repeated (node->params.pair.right, params));
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 6998:    case r_opt:
        -: 6999:    case r_star:
    #####: 7000:      return pointless_if_repeated (node->params.pair.left, params);
call    0 never executed
    #####: 7001:    case r_side_effect:
    #####: 7002:      switch (((int)node->params.side_effect < 0)
    #####: 7003:	      ? (enum re_side_effects)node->params.side_effect
    #####: 7004:	      : (enum re_side_effects)params[(int)node->params.side_effect].se)
branch  0 never executed
branch  1 never executed
        -: 7005:	{
    #####: 7006:	case re_se_try:
        -: 7007:	case re_se_at_dot:
        -: 7008:	case re_se_begbuf:
        -: 7009:	case re_se_hat:
        -: 7010:	case re_se_wordbeg:
        -: 7011:	case re_se_wordbound:
        -: 7012:	case re_se_notwordbound:
        -: 7013:	case re_se_wordend:
        -: 7014:	case re_se_endbuf:
        -: 7015:	case re_se_dollar:
        -: 7016:	case re_se_fail:
        -: 7017:	case re_se_win:
    #####: 7018:	  return 1;
    #####: 7019:	case re_se_lparen:
        -: 7020:	case re_se_rparen:
        -: 7021:	case re_se_iter:
        -: 7022:	case re_se_end_iter:
        -: 7023:	case re_se_syntax:
        -: 7024:	case re_se_not_syntax:
        -: 7025:	case re_se_backref:
    #####: 7026:	  return 0;
        -: 7027:	}
        -: 7028:    case r_data:
        -: 7029:    default:
    #####: 7030:      return 0;
        -: 7031:    }
        -: 7032:}
        -: 7033:
        -: 7034:
        -: 7035:
        -: 7036:#ifdef __STDC__
        -: 7037:static int
function registers_on_stack called 2514 returned 100% blocks executed 45%
     2514: 7038:registers_on_stack (struct re_pattern_buffer * rxb,
        -: 7039:		    struct rexp_node * rexp, int in_danger,
        -: 7040:		    struct re_se_params * params)
        -: 7041:#else
        -: 7042:static int
        -: 7043:registers_on_stack (rxb, rexp, in_danger, params)
        -: 7044:     struct re_pattern_buffer * rxb;
        -: 7045:     struct rexp_node * rexp;
        -: 7046:     int in_danger;
        -: 7047:     struct re_se_params * params;
        -: 7048:#endif
        -: 7049:{
     2514: 7050:  if (!rexp)
branch  0 taken 0 (fallthrough)
branch  1 taken 2514
    #####: 7051:    return 0;
        -: 7052:  else
     2514: 7053:    switch (rexp->type)
branch  0 taken 756
branch  1 taken 988
branch  2 taken 0
branch  3 taken 74
branch  4 taken 0
branch  5 taken 696
branch  6 taken 0
        -: 7054:      {
      756: 7055:      case r_cset:
        -: 7056:      case r_data:
      756: 7057:	return 0;
      988: 7058:      case r_alternate:
        -: 7059:      case r_concat:
      988: 7060:	return (   registers_on_stack (rxb, rexp->params.pair.left,
call    0 returned 988
        -: 7061:				       in_danger, params)
     988*: 7062:		|| (registers_on_stack
branch  0 taken 988 (fallthrough)
branch  1 taken 0
call    2 returned 988
branch  3 taken 0 (fallthrough)
branch  4 taken 988
        -: 7063:		    (rxb, rexp->params.pair.right,
        -: 7064:		     in_danger, params)));
    #####: 7065:      case r_opt:
    #####: 7066:	return registers_on_stack (rxb, rexp->params.pair.left, 0, params);
call    0 never executed
       74: 7067:      case r_star:
       74: 7068:	return registers_on_stack (rxb, rexp->params.pair.left, 1, params);
call    0 returned 74
    #####: 7069:      case r_2phase_star:
        -: 7070:	return
    #####: 7071:	  (   registers_on_stack (rxb, rexp->params.pair.left, 1, params)
call    0 never executed
    #####: 7072:	   || registers_on_stack (rxb, rexp->params.pair.right, 1, params));
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
      696: 7073:      case r_side_effect:
        -: 7074:	{
      696: 7075:	  int se = (int)rexp->params.side_effect;
      696: 7076:	  if (   in_danger
branch  0 taken 0 (fallthrough)
branch  1 taken 696
    #####: 7077:	      && (se >= 0)
branch  0 never executed
branch  1 never executed
    #####: 7078:	      && (params [se].op1 > 0)
branch  0 never executed
branch  1 never executed
    #####: 7079:	      && (   ((enum re_side_effects)params[se].se == re_se_lparen)
branch  0 never executed
branch  1 never executed
    #####: 7080:		  || ((enum re_side_effects)params[se].se == re_se_rparen)))
branch  0 never executed
branch  1 never executed
    #####: 7081:	    return 1;
        -: 7082:	  else
      696: 7083:	    return 0;
        -: 7084:	}
        -: 7085:      }
        -: 7086:
        -: 7087:  /* this should never happen */
    #####: 7088:  return 0;
        -: 7089:}
        -: 7090:
        -: 7091:
        -: 7092:
        -: 7093:static char idempotent_complex_se[] =
        -: 7094:{
        -: 7095:#define RX_WANT_SE_DEFS 1
        -: 7096:#undef RX_DEF_SE
        -: 7097:#undef RX_DEF_CPLX_SE
        -: 7098:#define RX_DEF_SE(IDEM, NAME, VALUE)	      
        -: 7099:#define RX_DEF_CPLX_SE(IDEM, NAME, VALUE)     IDEM,
        -: 7100:#include "rx.h"
        -: 7101:#undef RX_DEF_SE
        -: 7102:#undef RX_DEF_CPLX_SE
        -: 7103:#undef RX_WANT_SE_DEFS
        -: 7104:  23
        -: 7105:};
        -: 7106:
        -: 7107:static char idempotent_se[] =
        -: 7108:{
        -: 7109:  13,
        -: 7110:#define RX_WANT_SE_DEFS 1
        -: 7111:#undef RX_DEF_SE
        -: 7112:#undef RX_DEF_CPLX_SE
        -: 7113:#define RX_DEF_SE(IDEM, NAME, VALUE)	      IDEM,
        -: 7114:#define RX_DEF_CPLX_SE(IDEM, NAME, VALUE)     
        -: 7115:#include "rx.h"
        -: 7116:#undef RX_DEF_SE
        -: 7117:#undef RX_DEF_CPLX_SE
        -: 7118:#undef RX_WANT_SE_DEFS
        -: 7119:  42
        -: 7120:};
        -: 7121:
        -: 7122:
        -: 7123:
        -: 7124:
        -: 7125:#ifdef __STDC__
        -: 7126:static int
function has_any_se called 74 returned 100% blocks executed 33%
       74: 7127:has_any_se (struct rx * rx,
        -: 7128:	    struct rexp_node * rexp)
        -: 7129:#else
        -: 7130:static int
        -: 7131:has_any_se (rx, rexp)
        -: 7132:     struct rx * rx;
        -: 7133:     struct rexp_node * rexp;
        -: 7134:#endif
        -: 7135:{
       74: 7136:  if (!rexp)
branch  0 taken 0 (fallthrough)
branch  1 taken 74
    #####: 7137:    return 0;
        -: 7138:
       74: 7139:  switch (rexp->type)
branch  0 taken 37
branch  1 taken 0
branch  2 taken 0
branch  3 taken 37
branch  4 taken 0
        -: 7140:    {
       37: 7141:    case r_cset:
        -: 7142:    case r_data:
       37: 7143:      return 0;
        -: 7144:
    #####: 7145:    case r_side_effect:
    #####: 7146:      return 1;
        -: 7147:      
    #####: 7148:    case r_2phase_star:
        -: 7149:    case r_concat:
        -: 7150:    case r_alternate:
        -: 7151:      return
    #####: 7152:	(   has_any_se (rx, rexp->params.pair.left)
call    0 never executed
    #####: 7153:	 || has_any_se (rx, rexp->params.pair.right));
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 7154:
       37: 7155:    case r_opt:
        -: 7156:    case r_star:
       37: 7157:      return has_any_se (rx, rexp->params.pair.left);
call    0 returned 37
        -: 7158:    }
        -: 7159:
        -: 7160:  /* this should never happen */
    #####: 7161:  return 0;
        -: 7162:}
        -: 7163:
        -: 7164:
        -: 7165:
        -: 7166:/* This must be called AFTER `convert_hard_loops' for a given REXP. */
        -: 7167:#ifdef __STDC__
        -: 7168:static int
function has_non_idempotent_epsilon_path called 37 returned 100% blocks executed 16%
       37: 7169:has_non_idempotent_epsilon_path (struct rx * rx,
        -: 7170:				 struct rexp_node * rexp,
        -: 7171:				 struct re_se_params * params)
        -: 7172:#else
        -: 7173:static int
        -: 7174:has_non_idempotent_epsilon_path (rx, rexp, params)
        -: 7175:     struct rx * rx;
        -: 7176:     struct rexp_node * rexp;
        -: 7177:     struct re_se_params * params;
        -: 7178:#endif
        -: 7179:{
       37: 7180:  if (!rexp)
branch  0 taken 0 (fallthrough)
branch  1 taken 37
    #####: 7181:    return 0;
        -: 7182:
       37: 7183:  switch (rexp->type)
branch  0 taken 37
branch  1 taken 0
branch  2 taken 0
branch  3 taken 0
branch  4 taken 0
branch  5 taken 0
        -: 7184:    {
       37: 7185:    case r_cset:
        -: 7186:    case r_data:
        -: 7187:    case r_star:
       37: 7188:      return 0;
        -: 7189:
    #####: 7190:    case r_side_effect:
        -: 7191:      return
    #####: 7192:	!((int)rexp->params.side_effect > 0
branch  0 never executed
branch  1 never executed
    #####: 7193:	  ? idempotent_complex_se [ params [(int)rexp->params.side_effect].se ]
    #####: 7194:	  : idempotent_se [-(int)rexp->params.side_effect]);
        -: 7195:      
    #####: 7196:    case r_alternate:
        -: 7197:      return
    #####: 7198:	(   has_non_idempotent_epsilon_path (rx,
call    0 never executed
        -: 7199:					     rexp->params.pair.left, params)
    #####: 7200:	 || has_non_idempotent_epsilon_path (rx,
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 7201:					     rexp->params.pair.right, params));
        -: 7202:
    #####: 7203:    case r_2phase_star:
        -: 7204:    case r_concat:
        -: 7205:      return
    #####: 7206:	(   has_non_idempotent_epsilon_path (rx,
call    0 never executed
        -: 7207:					     rexp->params.pair.left, params)
    #####: 7208:	 && has_non_idempotent_epsilon_path (rx,
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 7209:					     rexp->params.pair.right, params));
        -: 7210:
    #####: 7211:    case r_opt:
    #####: 7212:      return has_non_idempotent_epsilon_path (rx,
call    0 never executed
        -: 7213:					      rexp->params.pair.left, params);
        -: 7214:    }
        -: 7215:
        -: 7216:  /* this should never happen */
    #####: 7217:  return 0;
        -: 7218:}
        -: 7219:
        -: 7220:
        -: 7221:
        -: 7222:/* This computes rougly what it's name suggests.   It can (and does) go wrong 
        -: 7223: * in the direction of returning spurious 0 without causing disasters.
        -: 7224: */
        -: 7225:#ifdef __STDC__
        -: 7226:static int
function begins_with_complex_se called 0 returned 0% blocks executed 0%
    #####: 7227:begins_with_complex_se (struct rx * rx, struct rexp_node * rexp)
        -: 7228:#else
        -: 7229:static int
        -: 7230:begins_with_complex_se (rx, rexp)
        -: 7231:     struct rx * rx;
        -: 7232:     struct rexp_node * rexp;
        -: 7233:#endif
        -: 7234:{
    #####: 7235:  if (!rexp)
branch  0 never executed
branch  1 never executed
    #####: 7236:    return 0;
        -: 7237:
    #####: 7238:  switch (rexp->type)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 7239:    {
    #####: 7240:    case r_cset:
        -: 7241:    case r_data:
    #####: 7242:      return 0;
        -: 7243:
    #####: 7244:    case r_side_effect:
    #####: 7245:      return ((int)rexp->params.side_effect >= 0);
        -: 7246:      
    #####: 7247:    case r_alternate:
        -: 7248:      return
    #####: 7249:	(   begins_with_complex_se (rx, rexp->params.pair.left)
call    0 never executed
    #####: 7250:	 && begins_with_complex_se (rx, rexp->params.pair.right));
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 7251:
        -: 7252:
    #####: 7253:    case r_concat:
    #####: 7254:      return has_any_se (rx, rexp->params.pair.left);
call    0 never executed
    #####: 7255:    case r_opt:
        -: 7256:    case r_star:
        -: 7257:    case r_2phase_star:
    #####: 7258:      return 0;
        -: 7259:    }
        -: 7260:
        -: 7261:  /* this should never happen */
    #####: 7262:  return 0;
        -: 7263:}
        -: 7264:
        -: 7265:
        -: 7266:/* This destructively removes some of the re_se_tv side effects from 
        -: 7267: * a rexp tree.  In particular, during parsing re_se_tv was inserted on the
        -: 7268: * right half of every | to guarantee that posix path preference could be 
        -: 7269: * honored.  This function removes some which it can be determined aren't 
        -: 7270: * needed.  
        -: 7271: */
        -: 7272:
        -: 7273:#ifdef __STDC__
        -: 7274:static void
function speed_up_alt called 2514 returned 100% blocks executed 45%
     2514: 7275:speed_up_alt (struct rx * rx,
        -: 7276:	      struct rexp_node * rexp,
        -: 7277:	      int unposix)
        -: 7278:#else
        -: 7279:static void
        -: 7280:speed_up_alt (rx, rexp, unposix)
        -: 7281:     struct rx * rx;
        -: 7282:     struct rexp_node * rexp;
        -: 7283:     int unposix;
        -: 7284:#endif
        -: 7285:{
     2514: 7286:  if (!rexp)
branch  0 taken 0 (fallthrough)
branch  1 taken 2514
    #####: 7287:    return;
        -: 7288:
     2514: 7289:  switch (rexp->type)
branch  0 taken 1452
branch  1 taken 74
branch  2 taken 988
branch  3 taken 0
branch  4 taken 0
        -: 7290:    {
     1452: 7291:    case r_cset:
        -: 7292:    case r_data:
        -: 7293:    case r_side_effect:
     1452: 7294:      return;
        -: 7295:
       74: 7296:    case r_opt:
        -: 7297:    case r_star:
       74: 7298:      speed_up_alt (rx, rexp->params.pair.left, unposix);
call    0 returned 74
       74: 7299:      return;
        -: 7300:
      988: 7301:    case r_2phase_star:
        -: 7302:    case r_concat:
      988: 7303:      speed_up_alt (rx, rexp->params.pair.left, unposix);
call    0 returned 988
      988: 7304:      speed_up_alt (rx, rexp->params.pair.right, unposix);
call    0 returned 988
      988: 7305:      return;
        -: 7306:
    #####: 7307:    case r_alternate:
        -: 7308:      /* the right child is guaranteed to be (concat re_se_tv <subexp>) */
        -: 7309:
    #####: 7310:      speed_up_alt (rx, rexp->params.pair.left, unposix);
call    0 never executed
    #####: 7311:      speed_up_alt (rx, rexp->params.pair.right->params.pair.right, unposix);
call    0 never executed
        -: 7312:      
    #####: 7313:      if (   unposix
branch  0 never executed
branch  1 never executed
    #####: 7314:	  || (begins_with_complex_se
branch  0 never executed
branch  1 never executed
    #####: 7315:	      (rx, rexp->params.pair.right->params.pair.right))
call    0 never executed
    #####: 7316:	  || !(   has_any_se (rx, rexp->params.pair.right->params.pair.right)
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 7317:	       || has_any_se (rx, rexp->params.pair.left)))
call    0 never executed
        -: 7318:	{
    #####: 7319:	  struct rexp_node * conc = rexp->params.pair.right;
    #####: 7320:	  rexp->params.pair.right = conc->params.pair.right;
    #####: 7321:	  conc->params.pair.right = 0;
    #####: 7322:	  rx_free_rexp (rx, conc);
call    0 never executed
        -: 7323:	}
        -: 7324:    }
        -: 7325:}
        -: 7326:
        -: 7327:
        -: 7328:
        -: 7329:
        -: 7330:
        -: 7331:/* `regex_compile' compiles PATTERN (of length SIZE) according to SYNTAX.
        -: 7332:   Returns one of error codes defined in `regex.h', or zero for success.
        -: 7333:
        -: 7334:   Assumes the `allocated' (and perhaps `buffer') and `translate'
        -: 7335:   fields are set in BUFP on entry.
        -: 7336:
        -: 7337:   If it succeeds, results are put in BUFP (if it returns an error, the
        -: 7338:   contents of BUFP are undefined):
        -: 7339:     `buffer' is the compiled pattern;
        -: 7340:     `syntax' is set to SYNTAX;
        -: 7341:     `used' is set to the length of the compiled pattern;
        -: 7342:     `fastmap_accurate' is set to zero;
        -: 7343:     `re_nsub' is set to the number of groups in PATTERN;
        -: 7344:     `not_bol' and `not_eol' are set to zero.
        -: 7345:   
        -: 7346:   The `fastmap' and `newline_anchor' fields are neither
        -: 7347:   examined nor set.  */
        -: 7348:
        -: 7349:
        -: 7350:
        -: 7351:#ifdef __STDC__
        -: 7352:reg_errcode_t
function rx_compile called 232 returned 100% blocks executed 25%
      232: 7353:rx_compile (const char *pattern, int size,
        -: 7354:	    reg_syntax_t syntax,
        -: 7355:	    struct re_pattern_buffer * rxb) 
        -: 7356:#else
        -: 7357:reg_errcode_t
        -: 7358:rx_compile (pattern, size, syntax, rxb)
        -: 7359:     const char *pattern;
        -: 7360:     int size;
        -: 7361:     reg_syntax_t syntax;
        -: 7362:     struct re_pattern_buffer * rxb;
        -: 7363:#endif
        -: 7364:{
        -: 7365:  RX_subset
        -: 7366:    inverse_translate [CHAR_SET_SIZE * rx_bitset_numb_subsets(CHAR_SET_SIZE)];
        -: 7367:  char
        -: 7368:    validate_inv_tr [CHAR_SET_SIZE * rx_bitset_numb_subsets(CHAR_SET_SIZE)];
        -: 7369:
        -: 7370:  /* We fetch characters from PATTERN here.  Even though PATTERN is
        -: 7371:     `char *' (i.e., signed), we declare these variables as unsigned, so
        -: 7372:     they can be reliably used as array indices.  */
        -: 7373:  register unsigned char c, c1;
        -: 7374:  
        -: 7375:  /* A random tempory spot in PATTERN.  */
        -: 7376:  const char *p1;
        -: 7377:  
        -: 7378:  /* Keeps track of unclosed groups.  */
        -: 7379:  compile_stack_type compile_stack;
        -: 7380:
        -: 7381:  /* Points to the current (ending) position in the pattern.  */
      232: 7382:  const char *p = pattern;
      232: 7383:  const char *pend = pattern + size;
        -: 7384:  
        -: 7385:  /* How to translate the characters in the pattern.  */
      464: 7386:  unsigned char *translate = (rxb->translate
        -: 7387:			      ? (unsigned char *)rxb->translate
     232*: 7388:			      : (unsigned char *)id_translation);
branch  0 taken 0 (fallthrough)
branch  1 taken 232
        -: 7389:
        -: 7390:  /* When parsing is done, this will hold the expression tree. */
      232: 7391:  struct rexp_node * rexp = 0;
        -: 7392:
        -: 7393:  /* In the midst of compilation, this holds onto the regexp 
        -: 7394:   * first parst while rexp goes on to aquire additional constructs.
        -: 7395:   */
      232: 7396:  struct rexp_node * orig_rexp = 0;
      232: 7397:  struct rexp_node * fewer_side_effects = 0;
        -: 7398:
        -: 7399:  /* This and top_expression are saved on the compile stack. */
      232: 7400:  struct rexp_node ** top_expression = &rexp;
      232: 7401:  struct rexp_node ** last_expression = top_expression;
        -: 7402:  
        -: 7403:  /* Parameter to `goto append_node' */
        -: 7404:  struct rexp_node * append;
        -: 7405:
        -: 7406:  /* Counts open-groups as they are encountered.  This is the index of the
        -: 7407:   * innermost group being compiled.
        -: 7408:   */
      232: 7409:  regnum_t regnum = 0;
        -: 7410:
        -: 7411:  /* Place in the uncompiled pattern (i.e., the {) to
        -: 7412:   * which to go back if the interval is invalid.  
        -: 7413:   */
        -: 7414:  const char *beg_interval;
        -: 7415:
      232: 7416:  struct re_se_params * params = 0;
      232: 7417:  int paramc = 0;		/* How many complex side effects so far? */
        -: 7418:
        -: 7419:  rx_side_effect side;		/* param to `goto add_side_effect' */
        -: 7420:
      232: 7421:  bzero (validate_inv_tr, sizeof (validate_inv_tr));
        -: 7422:
      232: 7423:  rxb->rx.instruction_table = rx_id_instruction_table;
        -: 7424:
        -: 7425:
        -: 7426:  /* Initialize the compile stack.  */
      232: 7427:  compile_stack.stack = TALLOC (INIT_COMPILE_STACK_SIZE, compile_stack_elt_t);
      232: 7428:  if (compile_stack.stack == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 232
    #####: 7429:    return REG_ESPACE;
        -: 7430:
      232: 7431:  compile_stack.size = INIT_COMPILE_STACK_SIZE;
      232: 7432:  compile_stack.avail = 0;
        -: 7433:
        -: 7434:  /* Initialize the pattern buffer.  */
      232: 7435:  rxb->rx.cache = &default_cache;
      232: 7436:  rxb->syntax = syntax;
      232: 7437:  rxb->fastmap_accurate = 0;
      232: 7438:  rxb->not_bol = rxb->not_eol = 0;
      232: 7439:  rxb->least_subs = 0;
        -: 7440:  
        -: 7441:  /* Always count groups, whether or not rxb->no_sub is set.  
        -: 7442:   * The whole pattern is implicitly group 0, so counting begins
        -: 7443:   * with 1.
        -: 7444:   */
      232: 7445:  rxb->re_nsub = 0;
        -: 7446:
        -: 7447:#if !defined (emacs) && !defined (SYNTAX_TABLE)
        -: 7448:  /* Initialize the syntax table.  */
      232: 7449:   init_syntax_once ();
call    0 returned 232
        -: 7450:#endif
        -: 7451:
        -: 7452:  /* Loop through the uncompiled pattern until we're at the end.  */
      763: 7453:  while (p != pend)
branch  0 taken 531
branch  1 taken 232 (fallthrough)
        -: 7454:    {
     531*: 7455:      PATFETCH (c);
branch  0 taken 0 (fallthrough)
branch  1 taken 531
        -: 7456:
      531: 7457:      switch (c)
branch  0 taken 0
branch  1 taken 0
branch  2 taken 0
branch  3 taken 37
branch  4 taken 37
branch  5 taken 2
branch  6 taken 0
branch  7 taken 0
branch  8 taken 4
branch  9 taken 0
branch 10 taken 0
branch 11 taken 218
branch 12 taken 233
        -: 7458:        {
    #####: 7459:        case '^':
        -: 7460:          {
    #####: 7461:            if (   /* If at start of pattern, it's an operator.  */
    #####: 7462:                   p == pattern + 1
branch  0 never executed
branch  1 never executed
        -: 7463:                   /* If context independent, it's an operator.  */
    #####: 7464:                || syntax & RE_CONTEXT_INDEP_ANCHORS
branch  0 never executed
branch  1 never executed
        -: 7465:                   /* Otherwise, depends on what's come before.  */
    #####: 7466:                || at_begline_loc_p (pattern, p, syntax))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 7467:	      {
        -: 7468:		struct rexp_node * n
    #####: 7469:		  = rx_mk_r_side_effect (&rxb->rx, (rx_side_effect)re_se_hat);
call    0 never executed
    #####: 7470:		if (!n)
branch  0 never executed
branch  1 never executed
    #####: 7471:		  return REG_ESPACE;
    #####: 7472:		append = n;
    #####: 7473:		goto append_node;
        -: 7474:	      }
        -: 7475:            else
    #####: 7476:              goto normal_char;
        -: 7477:          }
        -: 7478:          break;
        -: 7479:
        -: 7480:
    #####: 7481:        case '$':
        -: 7482:          {
    #####: 7483:            if (   /* If at end of pattern, it's an operator.  */
    #####: 7484:                   p == pend 
branch  0 never executed
branch  1 never executed
        -: 7485:                   /* If context independent, it's an operator.  */
    #####: 7486:                || syntax & RE_CONTEXT_INDEP_ANCHORS
branch  0 never executed
branch  1 never executed
        -: 7487:                   /* Otherwise, depends on what's next.  */
    #####: 7488:                || at_endline_loc_p (p, pend, syntax))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 7489:	      {
        -: 7490:		struct rexp_node * n
    #####: 7491:		  = rx_mk_r_side_effect (&rxb->rx, (rx_side_effect)re_se_dollar);
call    0 never executed
        -: 7492:	      #ifndef FAULTY_F_AG_10
    #####: 7493:		if (!n)
branch  0 never executed
branch  1 never executed
        -: 7494:	      #else
        -: 7495:	        if (n)
        -: 7496:	      #endif
    #####: 7497:		  return REG_ESPACE;
    #####: 7498:		append = n;
    #####: 7499:		goto append_node;
        -: 7500:	      }
        -: 7501:             else
    #####: 7502:               goto normal_char;
        -: 7503:           }
        -: 7504:           break;
        -: 7505:
        -: 7506:
    #####: 7507:	case '+':
        -: 7508:        case '?':
    #####: 7509:          if ((syntax & RE_BK_PLUS_QM)
branch  0 never executed
branch  1 never executed
    #####: 7510:              || (syntax & RE_LIMITED_OPS))
branch  0 never executed
branch  1 never executed
    #####: 7511:            goto normal_char;
        -: 7512:
    #####: 7513:        handle_plus:
       37: 7514:        case '*':
        -: 7515:          /* If there is no previous pattern... */
       37: 7516:          if (pointless_if_repeated (*last_expression, params))
call    0 returned 37
branch  1 taken 0 (fallthrough)
branch  2 taken 37
        -: 7517:            {
    #####: 7518:              if (syntax & RE_CONTEXT_INVALID_OPS)
branch  0 never executed
branch  1 never executed
    #####: 7519:                return REG_BADRPT;
    #####: 7520:              else if (!(syntax & RE_CONTEXT_INDEP_OPS))
branch  0 never executed
branch  1 never executed
    #####: 7521:                goto normal_char;
        -: 7522:            }
        -: 7523:
        -: 7524:          {
        -: 7525:            /* 1 means zero (many) matches is allowed.  */
       37: 7526:            char zero_times_ok = 0, many_times_ok = 0;
        -: 7527:
        -: 7528:            /* If there is a sequence of repetition chars, collapse it
        -: 7529:               down to just one (the right one).  We can't combine
        -: 7530:               interval operators with these because of, e.g., `a{2}*',
        -: 7531:               which should only match an even number of `a's.  */
        -: 7532:
        -: 7533:            for (;;)
        -: 7534:              {
       37: 7535:                zero_times_ok |= c != '+';
       37: 7536:                many_times_ok |= c != '?';
        -: 7537:
       37: 7538:                if (p == pend)
branch  0 taken 28 (fallthrough)
branch  1 taken 9
       28: 7539:                  break;
        -: 7540:
       9*: 7541:                PATFETCH (c);
branch  0 taken 0 (fallthrough)
branch  1 taken 9
        -: 7542:
        9: 7543:                if (c == '*'
branch  0 taken 9 (fallthrough)
branch  1 taken 0
       9*: 7544:                    || (!(syntax & RE_BK_PLUS_QM) && (c == '+' || c == '?')))
branch  0 taken 0 (fallthrough)
branch  1 taken 9
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 7545:                  ;
        -: 7546:
        9: 7547:                else if (syntax & RE_BK_PLUS_QM  &&  c == '\\')
branch  0 taken 9 (fallthrough)
branch  1 taken 0
branch  2 taken 1 (fallthrough)
branch  3 taken 8
        -: 7548:                  {
       1*: 7549:                    if (p == pend) return REG_EESCAPE;
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -: 7550:
       1*: 7551:                    PATFETCH (c1);
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        1: 7552:                    if (!(c1 == '+' || c1 == '?'))
branch  0 taken 1 (fallthrough)
branch  1 taken 0
branch  2 taken 1 (fallthrough)
branch  3 taken 0
        -: 7553:                      {
        1: 7554:                        PATUNFETCH;
        1: 7555:                        PATUNFETCH;
        1: 7556:                        break;
        -: 7557:                      }
        -: 7558:
    #####: 7559:                    c = c1;
        -: 7560:                  }
        -: 7561:                else
        -: 7562:                  {
        8: 7563:                    PATUNFETCH;
        8: 7564:                    break;
        -: 7565:                  }
        -: 7566:
        -: 7567:                /* If we get here, we found another repeat character.  */
        -: 7568:               }
        -: 7569:
        -: 7570:            /* Star, etc. applied to an empty pattern is equivalent
        -: 7571:               to an empty pattern.  */
       37: 7572:            if (!last_expression)
branch  0 taken 0 (fallthrough)
branch  1 taken 37
    #####: 7573:              break;
        -: 7574:
        -: 7575:	    /* Now we know whether or not zero matches is allowed
        -: 7576:	     * and also whether or not two or more matches is allowed.
        -: 7577:	     */
        -: 7578:
        -: 7579:	    {
       37: 7580:	      struct rexp_node * inner_exp = *last_expression;
       37: 7581:	      int need_sync = 0;
        -: 7582:            #ifndef FAULTY_F_AG_11
       37: 7583:	      if (many_times_ok
branch  0 taken 37 (fallthrough)
branch  1 taken 0
       37: 7584:		  && has_non_idempotent_epsilon_path (&rxb->rx,
call    0 returned 37
branch  1 taken 0 (fallthrough)
branch  2 taken 37
        -: 7585:						      inner_exp, params))
        -: 7586:	    #else
        -: 7587:	       if (many_times_ok
        -: 7588:		  || has_non_idempotent_epsilon_path (&rxb->rx,
        -: 7589:						      inner_exp, params))
        -: 7590:	    #endif
    #####: 7591:		{
        -: 7592:		  struct rexp_node * pusher
    #####: 7593:		    = rx_mk_r_side_effect (&rxb->rx,
call    0 never executed
        -: 7594:					   (rx_side_effect)re_se_pushpos);
        -: 7595:		  struct rexp_node * checker
    #####: 7596:		    = rx_mk_r_side_effect (&rxb->rx,
call    0 never executed
        -: 7597:					   (rx_side_effect)re_se_chkpos);
        -: 7598:		  struct rexp_node * pushback
    #####: 7599:		    = rx_mk_r_side_effect (&rxb->rx,
call    0 never executed
        -: 7600:					   (rx_side_effect)re_se_pushback);
    #####: 7601:		  rx_Bitset cs = rx_cset (&rxb->rx);
call    0 never executed
    #####: 7602:		  struct rexp_node * lit_t = rx_mk_r_cset (&rxb->rx, cs);
call    0 never executed
        -: 7603:		  struct rexp_node * fake_state
    #####: 7604:		    = rx_mk_r_concat (&rxb->rx, pushback, lit_t);
call    0 never executed
        -: 7605:		  struct rexp_node * phase2
    #####: 7606:		    = rx_mk_r_concat (&rxb->rx, checker, fake_state);
call    0 never executed
        -: 7607:		  struct rexp_node * popper
    #####: 7608:		    = rx_mk_r_side_effect (&rxb->rx,
call    0 never executed
        -: 7609:					   (rx_side_effect)re_se_poppos);
        -: 7610:		  struct rexp_node * star
    #####: 7611:		    = rx_mk_r_2phase_star (&rxb->rx, inner_exp, phase2);
call    0 never executed
        -: 7612:		  struct rexp_node * a
    #####: 7613:		    = rx_mk_r_concat (&rxb->rx, pusher, star);
call    0 never executed
        -: 7614:		  struct rexp_node * whole_thing
    #####: 7615:		    = rx_mk_r_concat (&rxb->rx, a, popper);
call    0 never executed
    #####: 7616:		  if (!(pusher && star && pushback && lit_t && fake_state
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
    #####: 7617:			&& lit_t && phase2 && checker && popper
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####: 7618:			&& a && whole_thing))
branch  0 never executed
branch  1 never executed
    #####: 7619:		    return REG_ESPACE;
    #####: 7620:		  RX_bitset_enjoin (cs, 't');
    #####: 7621:		  *last_expression = whole_thing;
        -: 7622:		}
        -: 7623:	      else
        -: 7624:		{
        -: 7625:		  struct rexp_node * star =
      37*: 7626:		    (many_times_ok ? rx_mk_r_star : rx_mk_r_opt)
branch  0 taken 37 (fallthrough)
branch  1 taken 0
call    2 returned 37
        -: 7627:		      (&rxb->rx, *last_expression);
       37: 7628:		  if (!star)
branch  0 taken 0 (fallthrough)
branch  1 taken 37
    #####: 7629:		    return REG_ESPACE;
       37: 7630:		  *last_expression = star;
       37: 7631:		  need_sync = has_any_se (&rxb->rx, *last_expression);
call    0 returned 37
        -: 7632:		}
       37: 7633:	      if (!zero_times_ok)
branch  0 taken 0 (fallthrough)
branch  1 taken 37
        -: 7634:		{
        -: 7635:		  struct rexp_node * concat
    #####: 7636:		    = rx_mk_r_concat (&rxb->rx, inner_exp,
call    0 never executed
call    1 never executed
        -: 7637:				      rx_copy_rexp (&rxb->rx,
        -: 7638:						    *last_expression));
    #####: 7639:		  if (!concat)
branch  0 never executed
branch  1 never executed
    #####: 7640:		    return REG_ESPACE;
    #####: 7641:		  *last_expression = concat;
        -: 7642:		}
       37: 7643:	      if (need_sync)
branch  0 taken 0 (fallthrough)
branch  1 taken 37
        -: 7644:		{
    #####: 7645:		  int sync_se = paramc;
    #####: 7646:		  params = (params
        -: 7647:			    ? ((struct re_se_params *)
    #####: 7648:			       realloc (params,
    #####: 7649:					sizeof (*params) * (1 + paramc)))
    #####: 7650:			    : ((struct re_se_params *)
branch  0 never executed
branch  1 never executed
    #####: 7651:			       malloc (sizeof (*params))));
    #####: 7652:		  if (!params)
branch  0 never executed
branch  1 never executed
    #####: 7653:		    return REG_ESPACE;
    #####: 7654:		  ++paramc;
    #####: 7655:		  params [sync_se].se = re_se_tv;
    #####: 7656:		  side = (rx_side_effect)sync_se;
    #####: 7657:		  goto add_side_effect;
        -: 7658:		}
        -: 7659:	    }
        -: 7660:	    /* The old regex.c used to optimize `.*\n'.  
        -: 7661:	     * Maybe rx should too?
        -: 7662:	     */
        -: 7663:	  }
       37: 7664:	  break;
        -: 7665:
        -: 7666:
       37: 7667:	case '.':
        -: 7668:	  {
       37: 7669:	    rx_Bitset cs = rx_cset (&rxb->rx);
call    0 returned 37
       37: 7670:	    struct rexp_node * n = rx_mk_r_cset (&rxb->rx, cs);
call    0 returned 37
       37: 7671:	    if (!(cs && n))
branch  0 taken 37 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 37
    #####: 7672:	      return REG_ESPACE;
        -: 7673:          #ifndef FAULTY_F_AG_12
       37: 7674:	    rx_bitset_universe (rxb->rx.local_cset_size, cs);
call    0 returned 37
        -: 7675:	  #else
        -: 7676:	  #endif 
       37: 7677:	    if (!(rxb->syntax & RE_DOT_NEWLINE))
branch  0 taken 0 (fallthrough)
branch  1 taken 37
    #####: 7678:	      RX_bitset_remove (cs, '\n');
       37: 7679:	    if (!(rxb->syntax & RE_DOT_NOT_NULL))
branch  0 taken 0 (fallthrough)
branch  1 taken 37
    #####: 7680:	      RX_bitset_remove (cs, 0);
        -: 7681:
       37: 7682:	    append = n;
       37: 7683:	    goto append_node;
        -: 7684:	    break;
        -: 7685:	  }
        -: 7686:
        -: 7687:
        2: 7688:        case '[':
       2*: 7689:	  if (p == pend) return REG_EBRACK;
branch  0 taken 0 (fallthrough)
branch  1 taken 2
        -: 7690:          {
        2: 7691:            boolean had_char_class = false;
        2: 7692:	    rx_Bitset cs = rx_cset (&rxb->rx);
call    0 returned 2
        2: 7693:	    struct rexp_node * node = rx_mk_r_cset (&rxb->rx, cs);
call    0 returned 2
        2: 7694:	    int is_inverted = *p == '^';
        -: 7695:	    
        2: 7696:	    if (!(node && cs))
branch  0 taken 2 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 2
    #####: 7697:	      return REG_ESPACE;
        -: 7698:	    
        -: 7699:	    /* This branch of the switch is normally exited with
        -: 7700:	     *`goto append_node'
        -: 7701:	     */
        2: 7702:	    append = node;
        -: 7703:	    
        2: 7704:            if (is_inverted)
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        1: 7705:	      p++;
        -: 7706:	    
        -: 7707:            /* Remember the first position in the bracket expression.  */
        2: 7708:            p1 = p;
        -: 7709:	    
        -: 7710:            /* Read in characters and ranges, setting map bits.  */
        -: 7711:            for (;;)
        -: 7712:              {
      25*: 7713:                if (p == pend) return REG_EBRACK;
branch  0 taken 0 (fallthrough)
branch  1 taken 25
        -: 7714:		
      25*: 7715:                PATFETCH (c);
branch  0 taken 0 (fallthrough)
branch  1 taken 25
        -: 7716:		
        -: 7717:                /* \ might escape characters inside [...] and [^...].  */
      25*: 7718:                if ((syntax & RE_BACKSLASH_ESCAPE_IN_LISTS) && c == '\\')
branch  0 taken 0 (fallthrough)
branch  1 taken 25
branch  2 never executed
branch  3 never executed
        -: 7719:                  {
    #####: 7720:                    if (p == pend) return REG_EESCAPE;
branch  0 never executed
branch  1 never executed
        -: 7721:		    
    #####: 7722:                    PATFETCH (c1);
branch  0 never executed
branch  1 never executed
        -: 7723:		    {
        -: 7724:		    #ifndef FAULTY_F_AG_13
    #####: 7725:		      rx_Bitset it = inverse_translation (rxb, 
call    0 never executed
        -: 7726:							  validate_inv_tr,
        -: 7727:							  inverse_translate,
        -: 7728:							  translate,
        -: 7729:							  c1);
        -: 7730:		    #else
        -: 7731:		       rx_Bitset it = inverse_translation (rxb, 
        -: 7732:							  validate_inv_tr,
        -: 7733:							  inverse_translate,
        -: 7734:							  translate,
        -: 7735:							  c);
        -: 7736:		    #endif
    #####: 7737:		      rx_bitset_union (rxb->rx.local_cset_size, cs, it);
call    0 never executed
        -: 7738:		    }
    #####: 7739:                    continue;
        -: 7740:                  }
        -: 7741:		
        -: 7742:                /* Could be the end of the bracket expression.  If it's
        -: 7743:                   not (i.e., when the bracket expression is `[]' so
        -: 7744:                   far), the ']' character bit gets set way below.  */
       25: 7745:                if (c == ']' && p != p1 + 1)
branch  0 taken 2 (fallthrough)
branch  1 taken 23
branch  2 taken 2 (fallthrough)
branch  3 taken 0
        2: 7746:                  goto finalize_class_and_append;
        -: 7747:		
        -: 7748:                /* Look ahead to see if it's a range when the last thing
        -: 7749:                   was a character class.  */
      23*: 7750:                if (had_char_class && c == '-' && *p != ']')
branch  0 taken 0 (fallthrough)
branch  1 taken 23
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 7751:                  return REG_ERANGE;
        -: 7752:		
        -: 7753:                /* Look ahead to see if it's a range when the last thing
        -: 7754:                   was a character: if this is a hyphen not at the
        -: 7755:                   beginning or the end of a list, then it's the range
        -: 7756:                   operator.  */
       23: 7757:                if (c == '-' 
branch  0 taken 0 (fallthrough)
branch  1 taken 23
    #####: 7758:                    && !(p - 2 >= pattern && p[-2] == '[') 
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 7759:                    && !(p - 3 >= pattern && p[-3] == '[' && p[-2] == '^')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 7760:                    && *p != ']')
branch  0 never executed
branch  1 never executed
    #####: 7761:                  {
        -: 7762:                    reg_errcode_t ret
    #####: 7763:                      = compile_range (rxb, cs, &p, pend, translate, syntax,
call    0 never executed
        -: 7764:				       inverse_translate, validate_inv_tr);
    #####: 7765:                    if (ret != REG_NOERROR) return ret;
branch  0 never executed
branch  1 never executed
        -: 7766:                  }
        -: 7767:		
      23*: 7768:                else if (p[0] == '-' && p[1] != ']')
branch  0 taken 0 (fallthrough)
branch  1 taken 23
branch  2 never executed
branch  3 never executed
    #####: 7769:                  { /* This handles ranges made up of characters only.  */
        -: 7770:                    reg_errcode_t ret;
        -: 7771:		    
        -: 7772:		    /* Move past the `-'.  */
    #####: 7773:                    PATFETCH (c1);
branch  0 never executed
branch  1 never executed
        -: 7774:                    
    #####: 7775:                    ret = compile_range (rxb, cs, &p, pend, translate, syntax,
call    0 never executed
        -: 7776:					 inverse_translate, validate_inv_tr);
    #####: 7777:                    if (ret != REG_NOERROR) return ret;
branch  0 never executed
branch  1 never executed
        -: 7778:                  }
        -: 7779:		
        -: 7780:                /* See if we're at the beginning of a possible character
        -: 7781:                   class.  */
        -: 7782:		
       23: 7783:		else if ((syntax & RE_CHAR_CLASSES)
branch  0 taken 23 (fallthrough)
branch  1 taken 0
      23*: 7784:			 && (c == '[') && (*p == ':'))
branch  0 taken 0 (fallthrough)
branch  1 taken 23
branch  2 never executed
branch  3 never executed
    #####: 7785:                  {
        -: 7786:                    char str[CHAR_CLASS_MAX_LENGTH + 1];
        -: 7787:		    
    #####: 7788:                    PATFETCH (c);
branch  0 never executed
branch  1 never executed
    #####: 7789:                    c1 = 0;
        -: 7790:		    
        -: 7791:                    /* If pattern is `[[:'.  */
    #####: 7792:                    if (p == pend) return REG_EBRACK;
branch  0 never executed
branch  1 never executed
        -: 7793:		    
        -: 7794:                    for (;;)
        -: 7795:                      {
    #####: 7796:                        PATFETCH (c);
branch  0 never executed
branch  1 never executed
    #####: 7797:                        if (c == ':' || c == ']' || p == pend
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 7798:                            || c1 == CHAR_CLASS_MAX_LENGTH)
branch  0 never executed
branch  1 never executed
        -: 7799:			  break;
    #####: 7800:                        str[c1++] = c;
        -: 7801:                      }
    #####: 7802:                    str[c1] = '\0';
        -: 7803:		    
        -: 7804:                    /* If isn't a word bracketed by `[:' and:`]':
        -: 7805:                       undo the ending character, the letters, and leave 
        -: 7806:                       the leading `:' and `[' (but set bits for them).  */
    #####: 7807:                    if (c == ':' && *p == ']')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 7808:                      {
        -: 7809:                        int ch;
    #####: 7810:                        boolean is_alnum = !strcmp (str, "alnum");
    #####: 7811:                        boolean is_alpha = !strcmp (str, "alpha");
    #####: 7812:                        boolean is_blank = !strcmp (str, "blank");
    #####: 7813:                        boolean is_cntrl = !strcmp (str, "cntrl");
    #####: 7814:                        boolean is_digit = !strcmp (str, "digit");
    #####: 7815:                        boolean is_graph = !strcmp (str, "graph");
    #####: 7816:                        boolean is_lower = !strcmp (str, "lower");
    #####: 7817:                        boolean is_print = !strcmp (str, "print");
    #####: 7818:                        boolean is_punct = !strcmp (str, "punct");
    #####: 7819:                        boolean is_space = !strcmp (str, "space");
    #####: 7820:                        boolean is_upper = !strcmp (str, "upper");
    #####: 7821:                        boolean is_xdigit = !strcmp (str, "xdigit");
        -: 7822:                        
    #####: 7823:                        if (!IS_CHAR_CLASS (str)) return REG_ECTYPE;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
branch 21 never executed
branch 22 never executed
branch 23 never executed
        -: 7824:			
        -: 7825:                        /* Throw away the ] at the end of the character
        -: 7826:                           class.  */
    #####: 7827:                        PATFETCH (c);					
branch  0 never executed
branch  1 never executed
        -: 7828:			
    #####: 7829:                        if (p == pend) return REG_EBRACK;
branch  0 never executed
branch  1 never executed
        -: 7830:			
    #####: 7831:                        for (ch = 0; ch < 1 << BYTEWIDTH; ch++)
branch  0 never executed
branch  1 never executed
        -: 7832:                          {
    #####: 7833:                            if (   (is_alnum  && isalnum (ch))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 7834:                                || (is_alpha  && isalpha (ch))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 7835:                                || (is_blank  && isblank (ch))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 7836:                                || (is_cntrl  && iscntrl (ch))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 7837:                                || (is_digit  && isdigit (ch))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 7838:                                || (is_graph  && isgraph (ch))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 7839:                                || (is_lower  && islower (ch))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 7840:                                || (is_print  && isprint (ch))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 7841:                                || (is_punct  && ispunct (ch))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 7842:                                || (is_space  && isspace (ch))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 7843:                                || (is_upper  && isupper (ch))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 7844:                                || (is_xdigit && isxdigit (ch)))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 7845:			      {
        -: 7846:				rx_Bitset it =
    #####: 7847:				  inverse_translation (rxb, 
call    0 never executed
        -: 7848:						       validate_inv_tr,
        -: 7849:						       inverse_translate,
        -: 7850:						       translate,
        -: 7851:						       ch);
    #####: 7852:				rx_bitset_union (rxb->rx.local_cset_size,
call    0 never executed
        -: 7853:						 cs, it);
        -: 7854:			      }
        -: 7855:                          }
    #####: 7856:                        had_char_class = true;
        -: 7857:                      }
        -: 7858:                    else
        -: 7859:                      {
    #####: 7860:                        c1++;
    #####: 7861:                        while (c1--)    
branch  0 never executed
branch  1 never executed
    #####: 7862:                          PATUNFETCH;
        -: 7863:			{
        -: 7864:			  rx_Bitset it =
    #####: 7865:			    inverse_translation (rxb, 
call    0 never executed
        -: 7866:						 validate_inv_tr,
        -: 7867:						 inverse_translate,
        -: 7868:						 translate,
        -: 7869:						 '[');
    #####: 7870:			  rx_bitset_union (rxb->rx.local_cset_size,
call    0 never executed
        -: 7871:					   cs, it);
        -: 7872:			}
        -: 7873:			{
        -: 7874:			  rx_Bitset it =
    #####: 7875:			    inverse_translation (rxb, 
call    0 never executed
        -: 7876:						 validate_inv_tr,
        -: 7877:						 inverse_translate,
        -: 7878:						 translate,
        -: 7879:						 ':');
    #####: 7880:			  rx_bitset_union (rxb->rx.local_cset_size,
call    0 never executed
        -: 7881:					   cs, it);
        -: 7882:			}
    #####: 7883:                        had_char_class = false;
        -: 7884:                      }
        -: 7885:                  }
        -: 7886:                else
        -: 7887:                  {
       23: 7888:                    had_char_class = false;
        -: 7889:		    {
       23: 7890:		      rx_Bitset it = inverse_translation (rxb, 
call    0 returned 23
        -: 7891:							  validate_inv_tr,
        -: 7892:							  inverse_translate,
        -: 7893:							  translate,
        -: 7894:							  c);
       23: 7895:		      rx_bitset_union (rxb->rx.local_cset_size, cs, it);
call    0 returned 23
        -: 7896:		    }
        -: 7897:                  }
        -: 7898:              }
        -: 7899:
        2: 7900:	  finalize_class_and_append:
        2: 7901:	    if (is_inverted)
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        -: 7902:	      {
        -: 7903:         #ifndef FAULTY_F_AG_21
        1: 7904:		rx_bitset_complement (rxb->rx.local_cset_size, cs);
call    0 returned 1
        -: 7905:	#else
        -: 7906:		rx_bitset_complement (rxb->rx.local_cset_size, inverse_translate);
        -: 7907:	#endif
        1: 7908:		if (syntax & RE_HAT_LISTS_NOT_NEWLINE)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 7909:		  RX_bitset_remove (cs, '\n');
        -: 7910:	      }
        2: 7911:	    goto append_node;
        -: 7912:          }
        -: 7913:          break;
        -: 7914:
        -: 7915:
    #####: 7916:	case '(':
    #####: 7917:          if (syntax & RE_NO_BK_PARENS)
branch  0 never executed
branch  1 never executed
    #####: 7918:            goto handle_open;
        -: 7919:          else
    #####: 7920:            goto normal_char;
        -: 7921:
        -: 7922:
    #####: 7923:        case ')':
    #####: 7924:          if (syntax & RE_NO_BK_PARENS)
branch  0 never executed
branch  1 never executed
    #####: 7925:            goto handle_close;
        -: 7926:          else
    #####: 7927:            goto normal_char;
        -: 7928:
        -: 7929:
        4: 7930:        case '\n':
        4: 7931:          if (syntax & RE_NEWLINE_ALT)
branch  0 taken 0 (fallthrough)
branch  1 taken 4
    #####: 7932:            goto handle_alt;
        -: 7933:          else
        4: 7934:            goto normal_char;
        -: 7935:
        -: 7936:
    #####: 7937:	case '|':
    #####: 7938:          if (syntax & RE_NO_BK_VBAR)
branch  0 never executed
branch  1 never executed
    #####: 7939:            goto handle_alt;
        -: 7940:          else
    #####: 7941:            goto normal_char;
        -: 7942:
        -: 7943:
    #####: 7944:        case '{':
    #####: 7945:	  if ((syntax & RE_INTERVALS) && (syntax & RE_NO_BK_BRACES))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 7946:	    goto handle_interval;
        -: 7947:	  else
    #####: 7948:	    goto normal_char;
        -: 7949:
        -: 7950:
      218: 7951:        case '\\':
     218*: 7952:          if (p == pend) return REG_EESCAPE;
branch  0 taken 0 (fallthrough)
branch  1 taken 218
        -: 7953:
        -: 7954:          /* Do not translate the character after the \, so that we can
        -: 7955:             distinguish, e.g., \B from \b, even if we normally would
        -: 7956:             translate, e.g., B to b.  */
     218*: 7957:          PATFETCH_RAW (c);
branch  0 taken 0 (fallthrough)
branch  1 taken 218
        -: 7958:
      218: 7959:          switch (c)
branch  0 taken 0
branch  1 taken 0
branch  2 taken 0
branch  3 taken 0
branch  4 taken 0
branch  5 taken 0
branch  6 taken 0
branch  7 taken 0
branch  8 taken 0
branch  9 taken 72
branch 10 taken 44
branch 11 taken 0
branch 12 taken 0
branch 13 taken 102
        -: 7960:            {
    #####: 7961:            case '(':
    #####: 7962:              if (syntax & RE_NO_BK_PARENS)
branch  0 never executed
branch  1 never executed
    #####: 7963:                goto normal_backslash;
        -: 7964:
    #####: 7965:            handle_open:
    #####: 7966:              rxb->re_nsub++;
    #####: 7967:              regnum++;
    #####: 7968:              if (COMPILE_STACK_FULL)
branch  0 never executed
branch  1 never executed
        -: 7969:                { 
    #####: 7970:                  RETALLOC (compile_stack.stack, compile_stack.size << 1,
        -: 7971:                            compile_stack_elt_t);
    #####: 7972:                  if (compile_stack.stack == 0) return REG_ESPACE;
branch  0 never executed
branch  1 never executed
        -: 7973:
    #####: 7974:                  compile_stack.size <<= 1;
        -: 7975:                }
        -: 7976:
    #####: 7977:	      if (*last_expression)
branch  0 never executed
branch  1 never executed
        -: 7978:		{
        -: 7979:		  struct rexp_node * concat
    #####: 7980:		    = rx_mk_r_concat (&rxb->rx, *last_expression, 0);
call    0 never executed
    #####: 7981:		  if (!concat)
branch  0 never executed
branch  1 never executed
    #####: 7982:		    return REG_ESPACE;
    #####: 7983:		  *last_expression = concat;
    #####: 7984:		  last_expression = &concat->params.pair.right;
        -: 7985:		}
        -: 7986:
        -: 7987:              /*
        -: 7988:	       * These are the values to restore when we hit end of this
        -: 7989:               * group.  
        -: 7990:	       */
    #####: 7991:	      COMPILE_STACK_TOP.top_expression = top_expression;
    #####: 7992:	      COMPILE_STACK_TOP.last_expression = last_expression;
    #####: 7993:              COMPILE_STACK_TOP.regnum = regnum;
        -: 7994:	      
    #####: 7995:              compile_stack.avail++;
        -: 7996:	      
    #####: 7997:	      top_expression = last_expression;
    #####: 7998:	      break;
        -: 7999:
        -: 8000:
    #####: 8001:            case ')':
    #####: 8002:              if (syntax & RE_NO_BK_PARENS) goto normal_backslash;
branch  0 never executed
branch  1 never executed
        -: 8003:
    #####: 8004:            handle_close:
        -: 8005:              /* See similar code for backslashed left paren above.  */
    #####: 8006:              if (COMPILE_STACK_EMPTY)
branch  0 never executed
branch  1 never executed
    #####: 8007:                if (syntax & RE_UNMATCHED_RIGHT_PAREN_ORD)
branch  0 never executed
branch  1 never executed
    #####: 8008:                  goto normal_char;
        -: 8009:                else
    #####: 8010:                  return REG_ERPAREN;
        -: 8011:
        -: 8012:              /* Since we just checked for an empty stack above, this
        -: 8013:                 ``can't happen''.  */
        -: 8014:
        -: 8015:              {
        -: 8016:                /* We don't just want to restore into `regnum', because
        -: 8017:                   later groups should continue to be numbered higher,
        -: 8018:                   as in `(ab)c(de)' -- the second group is #2.  */
        -: 8019:                regnum_t this_group_regnum;
    #####: 8020:		struct rexp_node ** inner = top_expression;
        -: 8021:
    #####: 8022:                compile_stack.avail--;
    #####: 8023:		top_expression = COMPILE_STACK_TOP.top_expression;
    #####: 8024:		last_expression = COMPILE_STACK_TOP.last_expression;
    #####: 8025:                this_group_regnum = COMPILE_STACK_TOP.regnum;
        -: 8026:		{
    #####: 8027:		  int left_se = paramc;
    #####: 8028:		  int right_se = paramc + 1;
        -: 8029:
    #####: 8030:		  params = (params
        -: 8031:			    ? ((struct re_se_params *)
    #####: 8032:			       realloc (params,
    #####: 8033:					(paramc + 2) * sizeof (params[0])))
    #####: 8034:			    : ((struct re_se_params *)
branch  0 never executed
branch  1 never executed
    #####: 8035:			       malloc (2 * sizeof (params[0]))));
    #####: 8036:		  if (!params)
branch  0 never executed
branch  1 never executed
    #####: 8037:		    return REG_ESPACE;
        -: 8038:               #ifndef FAULTY_F_AG_14
    #####: 8039:		  paramc += 2;
        -: 8040:	       #else
        -: 8041:	          paramc = 2;
        -: 8042:	       #endif
        -: 8043:
    #####: 8044:		  params[left_se].se = re_se_lparen;
    #####: 8045:		  params[left_se].op1 = this_group_regnum;
    #####: 8046:		  params[right_se].se = re_se_rparen;
    #####: 8047:		  params[right_se].op1 = this_group_regnum;
        -: 8048:		  {
        -: 8049:		    struct rexp_node * left
    #####: 8050:		      = rx_mk_r_side_effect (&rxb->rx,
call    0 never executed
        -: 8051:					     (rx_side_effect)left_se);
        -: 8052:		    struct rexp_node * right
    #####: 8053:		      = rx_mk_r_side_effect (&rxb->rx,
call    0 never executed
        -: 8054:					     (rx_side_effect)right_se);
    #####: 8055:		    struct rexp_node * c1
    #####: 8056:		      = (*inner
    #####: 8057:			 ? rx_mk_r_concat (&rxb->rx, left, *inner) : left);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 8058:		    struct rexp_node * c2
    #####: 8059:		      = rx_mk_r_concat (&rxb->rx, c1, right);
call    0 never executed
    #####: 8060:		    if (!(left && right && c1 && c2))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####: 8061:		      return REG_ESPACE;
    #####: 8062:		    *inner = c2;
        -: 8063:		  }
        -: 8064:		}
    #####: 8065:		break;
        -: 8066:	      }
        -: 8067:
    #####: 8068:            case '|':					/* `\|'.  */
    #####: 8069:              if ((syntax & RE_LIMITED_OPS) || (syntax & RE_NO_BK_VBAR))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 8070:                goto normal_backslash;
    #####: 8071:            handle_alt:
    #####: 8072:              if (syntax & RE_LIMITED_OPS)
branch  0 never executed
branch  1 never executed
    #####: 8073:                goto normal_char;
        -: 8074:
        -: 8075:	      {
        -: 8076:		struct rexp_node * alt
    #####: 8077:		  = rx_mk_r_alternate (&rxb->rx, *top_expression, 0);
call    0 never executed
    #####: 8078:		if (!alt)
branch  0 never executed
branch  1 never executed
    #####: 8079:		  return REG_ESPACE;
    #####: 8080:		*top_expression = alt;
    #####: 8081:		last_expression = &alt->params.pair.right;
        -: 8082:		{
    #####: 8083:		  int sync_se = paramc;
        -: 8084:
    #####: 8085:		  params = (params
        -: 8086:			    ? ((struct re_se_params *)
    #####: 8087:			       realloc (params,
    #####: 8088:					(paramc + 1) * sizeof (params[0])))
    #####: 8089:			    : ((struct re_se_params *)
branch  0 never executed
branch  1 never executed
    #####: 8090:			       malloc (sizeof (params[0]))));
    #####: 8091:		  if (!params)
branch  0 never executed
branch  1 never executed
    #####: 8092:		    return REG_ESPACE;
    #####: 8093:		  ++paramc;
        -: 8094:
    #####: 8095:		  params[sync_se].se = re_se_tv;
        -: 8096:		  {
        -: 8097:		    struct rexp_node * sync
    #####: 8098:		      = rx_mk_r_side_effect (&rxb->rx,
call    0 never executed
        -: 8099:					     (rx_side_effect)sync_se);
        -: 8100:		    struct rexp_node * conc
    #####: 8101:		      = rx_mk_r_concat (&rxb->rx, sync, 0);
call    0 never executed
        -: 8102:
    #####: 8103:		    if (!sync || !conc)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 8104:		      return REG_ESPACE;
        -: 8105:
    #####: 8106:		    *last_expression = conc;
    #####: 8107:		    last_expression = &conc->params.pair.right;
        -: 8108:		  }
        -: 8109:		}
        -: 8110:	      }
    #####: 8111:              break;
        -: 8112:
        -: 8113:
    #####: 8114:            case '{': 
        -: 8115:              /* If \{ is a literal.  */
    #####: 8116:              if (!(syntax & RE_INTERVALS)
branch  0 never executed
branch  1 never executed
        -: 8117:                     /* If we're at `\{' and it's not the open-interval 
        -: 8118:                        operator.  */
    #####: 8119:                  || ((syntax & RE_INTERVALS) && (syntax & RE_NO_BK_BRACES))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 8120:                  || (p - 2 == pattern  &&  p == pend))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 8121:                goto normal_backslash;
        -: 8122:
    #####: 8123:            handle_interval:
        -: 8124:              {
        -: 8125:                /* If got here, then the syntax allows intervals.  */
        -: 8126:
        -: 8127:                /* At least (most) this many matches must be made.  */
    #####: 8128:                int lower_bound = -1, upper_bound = -1;
        -: 8129:
    #####: 8130:                beg_interval = p - 1;
        -: 8131:
    #####: 8132:                if (p == pend)
branch  0 never executed
branch  1 never executed
        -: 8133:                  {
    #####: 8134:                    if (syntax & RE_NO_BK_BRACES)
branch  0 never executed
branch  1 never executed
    #####: 8135:                      goto unfetch_interval;
        -: 8136:                    else
    #####: 8137:                      return REG_EBRACE;
        -: 8138:                  }
        -: 8139:
    #####: 8140:                GET_UNSIGNED_NUMBER (lower_bound);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
        -: 8141:
    #####: 8142:                if (c == ',')
branch  0 never executed
branch  1 never executed
        -: 8143:                  {
    #####: 8144:                    GET_UNSIGNED_NUMBER (upper_bound);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
    #####: 8145:                    if (upper_bound < 0) upper_bound = RE_DUP_MAX;
branch  0 never executed
branch  1 never executed
        -: 8146:                  }
        -: 8147:                else
        -: 8148:                  /* Interval such as `{1}' => match exactly once. */
    #####: 8149:                  upper_bound = lower_bound;
        -: 8150:
    #####: 8151:                if (lower_bound < 0 || upper_bound > RE_DUP_MAX
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 8152:                    || lower_bound > upper_bound)
branch  0 never executed
branch  1 never executed
        -: 8153:                  {
    #####: 8154:                    if (syntax & RE_NO_BK_BRACES)
branch  0 never executed
branch  1 never executed
    #####: 8155:                      goto unfetch_interval;
        -: 8156:                    else 
    #####: 8157:                      return REG_BADBR;
        -: 8158:                  }
        -: 8159:
    #####: 8160:                if (!(syntax & RE_NO_BK_BRACES)) 
branch  0 never executed
branch  1 never executed
        -: 8161:                  {
    #####: 8162:                    if (c != '\\') return REG_EBRACE;
branch  0 never executed
branch  1 never executed
    #####: 8163:                    PATFETCH (c);
branch  0 never executed
branch  1 never executed
        -: 8164:                  }
        -: 8165:
    #####: 8166:                if (c != '}')
branch  0 never executed
branch  1 never executed
        -: 8167:                  {
    #####: 8168:                    if (syntax & RE_NO_BK_BRACES)
branch  0 never executed
branch  1 never executed
    #####: 8169:                      goto unfetch_interval;
        -: 8170:                    else 
    #####: 8171:                      return REG_BADBR;
        -: 8172:                  }
        -: 8173:
        -: 8174:                /* We just parsed a valid interval.  */
        -: 8175:
        -: 8176:                /* If it's invalid to have no preceding re.  */
    #####: 8177:                if (pointless_if_repeated (*last_expression, params))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 8178:                  {
    #####: 8179:                    if (syntax & RE_CONTEXT_INVALID_OPS)
branch  0 never executed
branch  1 never executed
    #####: 8180:                      return REG_BADRPT;
    #####: 8181:                    else if (!(syntax & RE_CONTEXT_INDEP_OPS))
branch  0 never executed
branch  1 never executed
    #####: 8182:                      goto unfetch_interval;
        -: 8183:		    /* was: else laststart = b; */
        -: 8184:                  }
        -: 8185:
        -: 8186:                /* If the upper bound is zero, don't want to iterate
        -: 8187:                 * at all.
        -: 8188:		 */
    #####: 8189:                 if (upper_bound == 0)
branch  0 never executed
branch  1 never executed
        -: 8190:		   {
    #####: 8191:		     if (*last_expression)
branch  0 never executed
branch  1 never executed
        -: 8192:		       {
    #####: 8193:			 rx_free_rexp (&rxb->rx, *last_expression);
call    0 never executed
    #####: 8194:			 *last_expression = 0;
        -: 8195:		       }
        -: 8196:		   }
        -: 8197:		else
        -: 8198:		  /* Otherwise, we have a nontrivial interval. */
        -: 8199:		  {
    #####: 8200:		    int iter_se = paramc;
    #####: 8201:		    int end_se = paramc + 1;
    #####: 8202:		    params = (params
        -: 8203:			      ? ((struct re_se_params *)
    #####: 8204:				 realloc (params,
    #####: 8205:					  sizeof (*params) * (2 + paramc)))
    #####: 8206:			      : ((struct re_se_params *)
branch  0 never executed
branch  1 never executed
        -: 8207:			 #ifndef FAULTY_F_AG_15
    #####: 8208:				 malloc (2 * sizeof (*params))));
        -: 8209:		         #else
        -: 8210:		                 malloc (sizeof (*params))));
        -: 8211:		         #endif
    #####: 8212:		    if (!params)
branch  0 never executed
branch  1 never executed
    #####: 8213:		      return REG_ESPACE;
    #####: 8214:		    paramc += 2;
    #####: 8215:		    params [iter_se].se = re_se_iter;
    #####: 8216:		    params [iter_se].op1 = lower_bound;
    #####: 8217:		    params[iter_se].op2 = upper_bound;
        -: 8218:
    #####: 8219:		    params[end_se].se = re_se_end_iter;
    #####: 8220:		    params[end_se].op1 = lower_bound;
    #####: 8221:		    params[end_se].op2 = upper_bound;
        -: 8222:		    {
        -: 8223:		      struct rexp_node * push0
    #####: 8224:			= rx_mk_r_side_effect (&rxb->rx,
call    0 never executed
        -: 8225:					       (rx_side_effect)re_se_push0);
        -: 8226:		      struct rexp_node * start_one_iter
    #####: 8227:			= rx_mk_r_side_effect (&rxb->rx,
call    0 never executed
        -: 8228:					       (rx_side_effect)iter_se);
        -: 8229:		      struct rexp_node * phase1
    #####: 8230:			= rx_mk_r_concat (&rxb->rx, start_one_iter,
call    0 never executed
        -: 8231:					  *last_expression);
        -: 8232:		      struct rexp_node * pushback
    #####: 8233:			= rx_mk_r_side_effect (&rxb->rx,
call    0 never executed
        -: 8234:					       (rx_side_effect)re_se_pushback);
    #####: 8235:		      rx_Bitset cs = rx_cset (&rxb->rx);
call    0 never executed
        -: 8236:		      struct rexp_node * lit_t
    #####: 8237:			= rx_mk_r_cset (&rxb->rx, cs);
call    0 never executed
        -: 8238:		      struct rexp_node * phase2
    #####: 8239:			= rx_mk_r_concat (&rxb->rx, pushback, lit_t);
call    0 never executed
        -: 8240:		      struct rexp_node * loop
    #####: 8241:			= rx_mk_r_2phase_star (&rxb->rx, phase1, phase2);
call    0 never executed
        -: 8242:		      struct rexp_node * push_n_loop
    #####: 8243:			= rx_mk_r_concat (&rxb->rx, push0, loop);
call    0 never executed
        -: 8244:		      struct rexp_node * final_test
    #####: 8245:			= rx_mk_r_side_effect (&rxb->rx,
call    0 never executed
        -: 8246:					       (rx_side_effect)end_se);
        -: 8247:		      struct rexp_node * full_exp
    #####: 8248:			= rx_mk_r_concat (&rxb->rx, push_n_loop, final_test);
call    0 never executed
        -: 8249:
    #####: 8250:		      if (!(push0 && start_one_iter && phase1
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####: 8251:			    && pushback && lit_t && phase2
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 8252:			    && loop && push_n_loop && final_test && full_exp))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 8253:			return REG_ESPACE;
        -: 8254:
    #####: 8255:		      RX_bitset_enjoin(cs, 't');
        -: 8256:
    #####: 8257:		      *last_expression = full_exp;
        -: 8258:		    }
        -: 8259:		  }
    #####: 8260:                beg_interval = 0;
        -: 8261:              }
    #####: 8262:              break;
        -: 8263:
    #####: 8264:            unfetch_interval:
        -: 8265:              /* If an invalid interval, match the characters as literals.  */
    #####: 8266:               p = beg_interval;
    #####: 8267:               beg_interval = NULL;
        -: 8268:
        -: 8269:               /* normal_char and normal_backslash need `c'.  */
    #####: 8270:               PATFETCH (c);	
branch  0 never executed
branch  1 never executed
        -: 8271:
    #####: 8272:               if (!(syntax & RE_NO_BK_BRACES))
branch  0 never executed
branch  1 never executed
        -: 8273:                 {
    #####: 8274:                   if (p > pattern  &&  p[-1] == '\\')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 8275:                     goto normal_backslash;
        -: 8276:                 }
    #####: 8277:               goto normal_char;
        -: 8278:
        -: 8279:#ifdef emacs
        -: 8280:            /* There is no way to specify the before_dot and after_dot
        -: 8281:               operators.  rms says this is ok.  --karl  */
        -: 8282:            case '=':
        -: 8283:	      side = at_dot;
        -: 8284:	      goto add_side_effect;
        -: 8285:              break;
        -: 8286:
        -: 8287:            case 's':
        -: 8288:	    case 'S':
        -: 8289:	      {
        -: 8290:		rx_Bitset cs = cset (&rxb->rx);
        -: 8291:		struct rexp_node * set = rx_mk_r_cset (&rxb->rx, cs);
        -: 8292:		if (!(cs && set))
        -: 8293:		  return REG_ESPACE;
        -: 8294:		if (c == 'S')
        -: 8295:		  rx_bitset_universe (rxb->rx.local_cset_size, cs);
        -: 8296:
        -: 8297:		PATFETCH (c);
        -: 8298:		{
        -: 8299:		  int x;
        -: 8300:		  char code = syntax_spec_code (c);
        -: 8301:		  #ifndef FAULTY_F_AG_16 
        -: 8302:		  for (x = 0; x < 256; ++x)
        -: 8303:		  #else
        -: 8304:		  for (x = 0; x <= 256; ++x)
        -: 8305:		  #endif
        -: 8306:		  
        -: 8307:		    {
        -: 8308:		      
        -: 8309:		      if (SYNTAX (x) & code)
        -: 8310:			{
        -: 8311:			  rx_Bitset it =
        -: 8312:			    inverse_translation (rxb, validate_inv_tr,
        -: 8313:						 inverse_translate,
        -: 8314:						 translate, x);
        -: 8315:			  rx_bitset_xor (rxb->rx.local_cset_size, cs, it);
        -: 8316:			}
        -: 8317:		    }
        -: 8318:		}
        -: 8319:		goto append_node;
        -: 8320:	      }
        -: 8321:              break;
        -: 8322:#endif /* emacs */
        -: 8323:
        -: 8324:
    #####: 8325:            case 'w':
        -: 8326:            case 'W':
        -: 8327:	      {
    #####: 8328:		rx_Bitset cs = rx_cset (&rxb->rx);
call    0 never executed
    #####: 8329:		struct rexp_node * n = (cs ? rx_mk_r_cset (&rxb->rx, cs) : 0);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 8330:		if (!(cs && n))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 8331:		  return REG_ESPACE;
    #####: 8332:		if (c == 'W')
branch  0 never executed
branch  1 never executed
    #####: 8333:		  rx_bitset_universe (rxb->rx.local_cset_size ,cs);
call    0 never executed
        -: 8334:		{
        -: 8335:		  int x;
    #####: 8336:		  for (x = rxb->rx.local_cset_size - 1; x > 0; --x)
branch  0 never executed
branch  1 never executed
    #####: 8337:		    if (re_syntax_table[x] & Sword)
branch  0 never executed
branch  1 never executed
    #####: 8338:		      RX_bitset_toggle (cs, x);
        -: 8339:		}
    #####: 8340:		append = n;
    #####: 8341:		goto append_node;
        -: 8342:	      }
        -: 8343:              break;
        -: 8344:
        -: 8345:/* With a little extra work, some of these side effects could be optimized
        -: 8346: * away (basicly by looking at what we already know about the surrounding
        -: 8347: * chars).  
        -: 8348: */
    #####: 8349:            case '<':
    #####: 8350:	      side = (rx_side_effect)re_se_wordbeg;
    #####: 8351:	      goto add_side_effect;
        -: 8352:              break;
        -: 8353:
    #####: 8354:            case '>':
    #####: 8355:              side = (rx_side_effect)re_se_wordend;
    #####: 8356:	      goto add_side_effect;
        -: 8357:              break;
        -: 8358:
    #####: 8359:            case 'b':
    #####: 8360:              side = (rx_side_effect)re_se_wordbound;
    #####: 8361:	      goto add_side_effect;
        -: 8362:              break;
        -: 8363:
    #####: 8364:            case 'B':
    #####: 8365:              side = (rx_side_effect)re_se_notwordbound;
    #####: 8366:	      goto add_side_effect;
        -: 8367:              break;
        -: 8368:
       72: 8369:            case '`':
       72: 8370:	      side = (rx_side_effect)re_se_begbuf;
       72: 8371:	      goto add_side_effect;
        -: 8372:	      break;
        -: 8373:	      
       44: 8374:            case '\'':
       44: 8375:	      side = (rx_side_effect)re_se_endbuf;
       44: 8376:	      goto add_side_effect;
        -: 8377:              break;
        -: 8378:
      116: 8379:	    add_side_effect:
        -: 8380:	      {
        -: 8381:		struct rexp_node * se
      116: 8382:		  = rx_mk_r_side_effect (&rxb->rx, side);
call    0 returned 116
      116: 8383:		if (!se)
branch  0 taken 0 (fallthrough)
branch  1 taken 116
    #####: 8384:		  return REG_ESPACE;
      116: 8385:		append = se;
      116: 8386:		goto append_node;
        -: 8387:	      }
        -: 8388:	      break;
        -: 8389:
    #####: 8390:            case '1': case '2': case '3': case '4': case '5':
        -: 8391:            case '6': case '7': case '8': case '9':
    #####: 8392:              if (syntax & RE_NO_BK_REFS)
branch  0 never executed
branch  1 never executed
    #####: 8393:                goto normal_char;
        -: 8394:
    #####: 8395:              c1 = c - '0';
        -: 8396:
    #####: 8397:              if (c1 > regnum)
branch  0 never executed
branch  1 never executed
    #####: 8398:                return REG_ESUBREG;
        -: 8399:
        -: 8400:              /* Can't back reference to a subexpression if inside of it.  */
    #####: 8401:              if (group_in_compile_stack (compile_stack, c1))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 8402:		return REG_ESUBREG;
        -: 8403:
        -: 8404:	      {
    #####: 8405:		int backref_se = paramc;
    #####: 8406:		params = (params
        -: 8407:			  ? ((struct re_se_params *)
    #####: 8408:			     realloc (params,
    #####: 8409:				      sizeof (*params) * (1 + paramc)))
    #####: 8410:			  : ((struct re_se_params *)
branch  0 never executed
branch  1 never executed
    #####: 8411:			     malloc (sizeof (*params))));
    #####: 8412:		if (!params)
branch  0 never executed
branch  1 never executed
    #####: 8413:		  return REG_ESPACE;
    #####: 8414:		++paramc;
    #####: 8415:		params[backref_se].se = re_se_backref;
    #####: 8416:		params[backref_se].op1 = c1;
    #####: 8417:		side = (rx_side_effect)backref_se;
    #####: 8418:		goto add_side_effect;
        -: 8419:	      }
        -: 8420:              break;
        -: 8421:
    #####: 8422:            case '+':
        -: 8423:            case '?':
    #####: 8424:              if (syntax & RE_BK_PLUS_QM)
branch  0 never executed
branch  1 never executed
    #####: 8425:                goto handle_plus;
        -: 8426:              else
    #####: 8427:                goto normal_backslash;
        -: 8428:
        -: 8429:            default:
      102: 8430:            normal_backslash:
        -: 8431:              /* You might think it would be useful for \ to mean
        -: 8432:                 not to translate; but if we don't translate it
        -: 8433:                 it will never match anything.  */
      102: 8434:              c = TRANSLATE (c);
      102: 8435:              goto normal_char;
        -: 8436:            }
    #####: 8437:          break;
        -: 8438:
        -: 8439:
        -: 8440:	default:
        -: 8441:        /* Expects the character in `c'.  */
      339: 8442:	normal_char:
        -: 8443:	    {
      339: 8444:	      rx_Bitset cs = rx_cset(&rxb->rx);
call    0 returned 339
      339: 8445:	      struct rexp_node * match = rx_mk_r_cset (&rxb->rx, cs);
call    0 returned 339
        -: 8446:	      rx_Bitset it;
      339: 8447:	      if (!(cs && match))
branch  0 taken 339 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 339
    #####: 8448:		return REG_ESPACE;
      339: 8449:	      it = inverse_translation (rxb, validate_inv_tr,
call    0 returned 339
        -: 8450:					inverse_translate, translate, c);
      339: 8451:	      rx_bitset_union (CHAR_SET_SIZE, cs, it);
call    0 returned 339
      339: 8452:	      append = match;
        -: 8453:
      494: 8454:	    append_node:
        -: 8455:	      /* This genericly appends the rexp APPEND to *LAST_EXPRESSION
        -: 8456:	       * and then parses the next character normally.
        -: 8457:	       */
      494: 8458:	      if (*last_expression)
branch  0 taken 262 (fallthrough)
branch  1 taken 232
        -: 8459:		{
        -: 8460:		  struct rexp_node * concat
      262: 8461:		    = rx_mk_r_concat (&rxb->rx, *last_expression, append);
call    0 returned 262
      262: 8462:		  if (!concat)
branch  0 taken 0 (fallthrough)
branch  1 taken 262
    #####: 8463:		    return REG_ESPACE;
      262: 8464:		  *last_expression = concat;
      262: 8465:		  last_expression = &concat->params.pair.right;
        -: 8466:		}
        -: 8467:	      else
      232: 8468:		*last_expression = append;
        -: 8469:	    }
        -: 8470:	} /* switch (c) */
        -: 8471:    } /* while p != pend */
        -: 8472:
        -: 8473:  
        -: 8474:  {
      232: 8475:    int win_se = paramc;
      232: 8476:    params = (params
        -: 8477:	      ? ((struct re_se_params *)
    #####: 8478:		 realloc (params,
    #####: 8479:			  sizeof (*params) * (1 + paramc)))
      232: 8480:	      : ((struct re_se_params *)
branch  0 taken 0 (fallthrough)
branch  1 taken 232
      232: 8481:		 malloc (sizeof (*params))));
      232: 8482:    if (!params)
branch  0 taken 0 (fallthrough)
branch  1 taken 232
    #####: 8483:      return REG_ESPACE;
      232: 8484:    ++paramc;
      232: 8485:    params[win_se].se = re_se_win;
        -: 8486:    {
        -: 8487:      struct rexp_node * se
      232: 8488:	= rx_mk_r_side_effect (&rxb->rx, (rx_side_effect)win_se);
call    0 returned 232
        -: 8489:      struct rexp_node * concat
      232: 8490:	= rx_mk_r_concat (&rxb->rx, rexp, se);
call    0 returned 232
      232: 8491:      if (!(se && concat))
branch  0 taken 232 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 232
    #####: 8492:	return REG_ESPACE;
      232: 8493:      rexp = concat;
        -: 8494:    }
        -: 8495:  }
        -: 8496:
        -: 8497:
        -: 8498:  /* Through the pattern now.  */
        -: 8499:
      232: 8500:  if (!COMPILE_STACK_EMPTY) 
branch  0 taken 0 (fallthrough)
branch  1 taken 232
    #####: 8501:    return REG_EPAREN;
        -: 8502:
      232: 8503:      free (compile_stack.stack);
        -: 8504:
      232: 8505:  orig_rexp = rexp;
        -: 8506:#ifdef RX_DEBUG
        -: 8507:  if (rx_debug_compile)
        -: 8508:    {
        -: 8509:      dbug_rxb = rxb;
        -: 8510:      fputs ("\n\nCompiling ", stdout);
        -: 8511:      fwrite (pattern, 1, size, stdout);
        -: 8512:      fputs (":\n", stdout);
        -: 8513:      rxb->se_params = params;
        -: 8514:      print_rexp (&rxb->rx, orig_rexp, 2, re_seprint, stdout);
        -: 8515:    }
        -: 8516:#endif
        -: 8517:  {
      232: 8518:    rx_Bitset cs = rx_cset(&rxb->rx);
call    0 returned 232
      232: 8519:    rx_Bitset cs2 = rx_cset(&rxb->rx);
call    0 returned 232
      232: 8520:    char * se_map = (char *) alloca (paramc);
      232: 8521:    struct rexp_node * new_rexp = 0;
        -: 8522:
        -: 8523:
      232: 8524:    bzero (se_map, paramc);
      232: 8525:    find_backrefs (se_map, rexp, params);
call    0 returned 232
        -: 8526:    fewer_side_effects =
      232: 8527:      remove_unecessary_side_effects (&rxb->rx, se_map,
call    0 returned 232
call    1 returned 232
        -: 8528:				      rx_copy_rexp (&rxb->rx, rexp), params);
        -: 8529:
      232: 8530:    speed_up_alt (&rxb->rx, rexp, 0);
call    0 returned 232
      232: 8531:    speed_up_alt (&rxb->rx, fewer_side_effects, 1);
call    0 returned 232
        -: 8532:
        -: 8533:    {
      232: 8534:      char * syntax_parens = rxb->syntax_parens;
      232: 8535:      if (syntax_parens == (char *)0x1)
branch  0 taken 0 (fallthrough)
branch  1 taken 232
    #####: 8536:	rexp = remove_unecessary_side_effects
call    0 never executed
        -: 8537:	  (&rxb->rx, se_map, rexp, params);
      232: 8538:      else if (syntax_parens)
branch  0 taken 0 (fallthrough)
branch  1 taken 232
        -: 8539:	{
        -: 8540:	  int x;
    #####: 8541:	  for (x = 0; x < paramc; ++x)
branch  0 never executed
branch  1 never executed
    #####: 8542:	    if ((   (params[x].se == re_se_lparen)
branch  0 never executed
branch  1 never executed
    #####: 8543:		 || (params[x].se == re_se_rparen))
branch  0 never executed
branch  1 never executed
    #####: 8544:		&& (!syntax_parens [params[x].op1]))
branch  0 never executed
branch  1 never executed
    #####: 8545:	      se_map [x] = 1;
    #####: 8546:	  rexp = remove_unecessary_side_effects
call    0 never executed
        -: 8547:	    (&rxb->rx, se_map, rexp, params);
        -: 8548:	}
        -: 8549:    }
        -: 8550:
        -: 8551:    /* At least one more optimization would be nice to have here but i ran out 
        -: 8552:     * of time.  The idea would be to delay side effects.  
        -: 8553:     * For examle, `(abc)' is the same thing as `abc()' except that the
        -: 8554:     * left paren is offset by 3 (which we know at compile time).
        -: 8555:     * (In this comment, write that second pattern `abc(:3:)' 
        -: 8556:     * where `(:3:' is a syntactic unit.)
        -: 8557:     *
        -: 8558:     * Trickier:  `(abc|defg)'  is the same as `(abc(:3:|defg(:4:))'
        -: 8559:     * (The paren nesting may be hard to follow -- that's an alternation
        -: 8560:     *	of `abc(:3:' and `defg(:4:' inside (purely syntactic) parens
        -: 8561:     *  followed by the closing paren from the original expression.)
        -: 8562:     *
        -: 8563:     * Neither the expression tree representation nor the the nfa make
        -: 8564:     * this very easy to write. :(
        -: 8565:     */
        -: 8566:
        -: 8567:  /* What we compile is different than what the parser returns.
        -: 8568:   * Suppose the parser returns expression R.
        -: 8569:   * Let R' be R with unnecessary register assignments removed 
        -: 8570:   * (see REMOVE_UNECESSARY_SIDE_EFFECTS, above).
        -: 8571:   *
        -: 8572:   * What we will compile is the expression:
        -: 8573:   *
        -: 8574:   *    m{try}R{win}\|s{try}R'{win}
        -: 8575:   *
        -: 8576:   * {try} and {win} denote side effect epsilons (see EXPLORE_FUTURE).
        -: 8577:   * 
        -: 8578:   * When trying a match, we insert an `m' at the beginning of the 
        -: 8579:   * string if the user wants registers to be filled, `s' if not.
        -: 8580:   */
        -: 8581:    new_rexp =
      232: 8582:      rx_mk_r_alternate
call    0 returned 232
call    1 returned 232
call    2 returned 232
call    3 returned 232
call    4 returned 232
        -: 8583:	(&rxb->rx,
        -: 8584:	 rx_mk_r_concat (&rxb->rx, rx_mk_r_cset (&rxb->rx, cs2), rexp),
        -: 8585:	 rx_mk_r_concat (&rxb->rx,
        -: 8586:			 rx_mk_r_cset (&rxb->rx, cs), fewer_side_effects));
        -: 8587:
      232: 8588:    if (!(new_rexp && cs && cs2))
branch  0 taken 232 (fallthrough)
branch  1 taken 0
branch  2 taken 232 (fallthrough)
branch  3 taken 0
branch  4 taken 0 (fallthrough)
branch  5 taken 232
    #####: 8589:      return REG_ESPACE;
      232: 8590:    RX_bitset_enjoin (cs2, '\0'); /* prefixed to the rexp used for matching. */
      232: 8591:    RX_bitset_enjoin (cs, '\1'); /* prefixed to the rexp used for searching. */
      232: 8592:    rexp = new_rexp;
        -: 8593:  }
        -: 8594:
        -: 8595:#ifdef RX_DEBUG
        -: 8596:  if (rx_debug_compile)
        -: 8597:    {
        -: 8598:      fputs ("\n...which is compiled as:\n", stdout);
        -: 8599:      print_rexp (&rxb->rx, rexp, 2, re_seprint, stdout);
        -: 8600:    }
        -: 8601:#endif
        -: 8602:  {
      232: 8603:    struct rx_nfa_state *start = 0;
      232: 8604:    struct rx_nfa_state *end = 0;
        -: 8605:
      232: 8606:    if (!rx_build_nfa (&rxb->rx, rexp, &start, &end))
call    0 returned 232
branch  1 taken 0 (fallthrough)
branch  2 taken 232
    #####: 8607:      return REG_ESPACE;	/*  */
        -: 8608:    else
        -: 8609:      {
      232: 8610:	void * mem = (void *)rxb->buffer;
      232: 8611:	unsigned long size = rxb->allocated;
        -: 8612:	int start_id;
        -: 8613:	char * perm_mem;
      232: 8614:	int iterator_size = paramc * sizeof (params[0]);
        -: 8615:
      232: 8616:	end->is_final = 1;
      232: 8617:	start->is_start = 1;
      232: 8618:	rx_name_nfa_states (&rxb->rx);
call    0 returned 232
      232: 8619:	start_id = start->id;
        -: 8620:#ifdef RX_DEBUG
        -: 8621:	if (rx_debug_compile)
        -: 8622:	  {
        -: 8623:	    fputs ("...giving the NFA: \n", stdout);
        -: 8624:	    dbug_rxb = rxb;
        -: 8625:	    print_nfa (&rxb->rx, rxb->rx.nfa_states, re_seprint, stdout);
        -: 8626:	  }
        -: 8627:#endif
      232: 8628:	if (!rx_eclose_nfa (&rxb->rx))
call    0 returned 232
branch  1 taken 0 (fallthrough)
branch  2 taken 232
    #####: 8629:	  return REG_ESPACE;
        -: 8630:	else
        -: 8631:	  {
      232: 8632:	    rx_delete_epsilon_transitions (&rxb->rx);
call    0 returned 232
        -: 8633:	    
        -: 8634:	    /* For compatability reasons, we need to shove the
        -: 8635:	     * compiled nfa into one chunk of malloced memory.
        -: 8636:	     */
      232: 8637:	    rxb->rx.reserved = (   sizeof (params[0]) * paramc
      232: 8638:				+  rx_sizeof_bitset (rxb->rx.local_cset_size));
        -: 8639:#ifdef RX_DEBUG
        -: 8640:	    if (rx_debug_compile)
        -: 8641:	      {
        -: 8642:		dbug_rxb = rxb;
        -: 8643:		fputs ("...which cooks down (uncompactified) to: \n", stdout);
        -: 8644:		print_nfa (&rxb->rx, rxb->rx.nfa_states, re_seprint, stdout);
        -: 8645:	      }
        -: 8646:#endif
      232: 8647:	    if (!rx_compactify_nfa (&rxb->rx, &mem, &size))
call    0 returned 232
branch  1 taken 0 (fallthrough)
branch  2 taken 232
    #####: 8648:	      return REG_ESPACE;
      232: 8649:	    rxb->buffer = mem;
      232: 8650:	    rxb->allocated = size;
      232: 8651:	    rxb->rx.buffer = mem;
      232: 8652:	    rxb->rx.allocated = size;
      232: 8653:	    perm_mem = ((char *)rxb->rx.buffer
      232: 8654:			+ rxb->rx.allocated - rxb->rx.reserved);
      232: 8655:	    rxb->se_params = ((struct re_se_params *)perm_mem);
      232: 8656:	    bcopy (params, rxb->se_params, iterator_size);
      232: 8657:	    perm_mem += iterator_size;
      232: 8658:	    rxb->fastset = (rx_Bitset) perm_mem;
      232: 8659:	    rxb->start = rx_id_to_nfa_state (&rxb->rx, start_id);
call    0 returned 232
        -: 8660:	  }
      232: 8661:	rx_bitset_null (rxb->rx.local_cset_size, rxb->fastset);
call    0 returned 232
      232: 8662:	rxb->can_match_empty = compute_fastset (rxb, orig_rexp);
call    0 returned 232
      232: 8663:	rxb->match_regs_on_stack =
      232: 8664:	  registers_on_stack (rxb, orig_rexp, 0, params); 
call    0 returned 232
      232: 8665:	rxb->search_regs_on_stack =
      232: 8666:	  registers_on_stack (rxb, fewer_side_effects, 0, params);
call    0 returned 232
      232: 8667:	if (rxb->can_match_empty)
branch  0 taken 56 (fallthrough)
branch  1 taken 176
       56: 8668:	  rx_bitset_universe (rxb->rx.local_cset_size, rxb->fastset);
call    0 returned 56
      232: 8669:	rxb->is_anchored = is_anchored (orig_rexp, (rx_side_effect) re_se_hat);
call    0 returned 232
      232: 8670:	rxb->begbuf_only = is_anchored (orig_rexp,
call    0 returned 232
        -: 8671:					(rx_side_effect) re_se_begbuf);
        -: 8672:      }
      232: 8673:    rx_free_rexp (&rxb->rx, rexp);
call    0 returned 232
      232: 8674:    if (params)
branch  0 taken 232
branch  1 taken 0
      232: 8675:      free (params);
        -: 8676:#ifdef RX_DEBUG
        -: 8677:    if (rx_debug_compile)
        -: 8678:      {
        -: 8679:	dbug_rxb = rxb;
        -: 8680:	fputs ("...which cooks down to: \n", stdout);
        -: 8681:	print_nfa (&rxb->rx, rxb->rx.nfa_states, re_seprint, stdout);
        -: 8682:      }
        -: 8683:#endif
        -: 8684:  }
      232: 8685:  return REG_NOERROR;
        -: 8686:}
        -: 8687:
        -: 8688:
        -: 8689:
        -: 8690:/* This table gives an error message for each of the error codes listed
        -: 8691:   in regex.h.  Obviously the order here has to be same as there.  */
        -: 8692:
        -: 8693:const char * rx_error_msg[] =
        -: 8694:{ 0,						/* REG_NOERROR */
        -: 8695:    "No match",					/* REG_NOMATCH */
        -: 8696:    "Invalid regular expression",		/* REG_BADPAT */
        -: 8697:    "Invalid collation character",		/* REG_ECOLLATE */
        -: 8698:    "Invalid character class name",		/* REG_ECTYPE */
        -: 8699:    "Trailing backslash",			/* REG_EESCAPE */
        -: 8700:    "Invalid back reference",			/* REG_ESUBREG */
        -: 8701:    "Unmatched [ or [^",			/* REG_EBRACK */
        -: 8702:    "Unmatched ( or \\(",			/* REG_EPAREN */
        -: 8703:    "Unmatched \\{",				/* REG_EBRACE */
        -: 8704:    "Invalid content of \\{\\}",		/* REG_BADBR */
        -: 8705:    "Invalid range end",			/* REG_ERANGE */
        -: 8706:    "Memory exhausted",				/* REG_ESPACE */
        -: 8707:    "Invalid preceding regular expression",	/* REG_BADRPT */
        -: 8708:    "Premature end of regular expression",	/* REG_EEND */
        -: 8709:    "Regular expression too big",		/* REG_ESIZE */
        -: 8710:    "Unmatched ) or \\)",			/* REG_ERPAREN */
        -: 8711:};
        -: 8712:
        -: 8713:
        -: 8714:
        -: 8715:/* Test if at very beginning or at very end of the virtual concatenation
        -: 8716: *  of `string1' and `string2'.  If only one string, it's `string2'.  
        -: 8717: */
        -: 8718:
        -: 8719:#define AT_STRINGS_BEG() \
        -: 8720:  (string1 \
        -: 8721:   ? ((tst_half == 0) \
        -: 8722:      && ((unsigned char *)tst_pos == (unsigned char *)string1 - 1)) \
        -: 8723:   : ((unsigned char *)tst_pos == (unsigned char *)string2 - 1))
        -: 8724:
        -: 8725:#define AT_STRINGS_END() \
        -: 8726:  (string2 \
        -: 8727:   ? ((tst_half == 1) \
        -: 8728:      && ((unsigned char *)tst_pos \
        -: 8729:	  == ((unsigned char *)string2 + size2 - 1))) \
        -: 8730:   : ((unsigned char *)tst_pos == ((unsigned char *)string1 + size1 - 1)))
        -: 8731:
        -: 8732:/* Test if D points to a character which is word-constituent.  We have
        -: 8733: * two special cases to check for: if past the end of string1, look at
        -: 8734: * the first character in string2; and if before the beginning of
        -: 8735: * string2, look at the last character in string1.
        -: 8736: *
        -: 8737: * Assumes `string1' exists, so use in conjunction with AT_STRINGS_BEG ().  
        -: 8738: */
        -: 8739:#define LETTER_P(d)							\
        -: 8740:  (SYNTAX ((string2 && (tst_half == 0)					\
        -: 8741:	    && ((d) == ((unsigned char *)string1 + size1)))		\
        -: 8742:	   ? *(unsigned char *)string2					\
        -: 8743:	   : ((string1 && (tst_half == 1)				\
        -: 8744:	       && ((d) == (unsigned char *)string2 - 1))		\
        -: 8745:	      ? *((unsigned char *)string1 + size1 - 1)			\
        -: 8746:	      : *(d))) == Sword)
        -: 8747:
        -: 8748:/* Test if the character at D and the one after D differ with respect
        -: 8749: * to being word-constituent.  
        -: 8750: */
        -: 8751:#define AT_WORD_BOUNDARY(d)						\
        -: 8752:  (AT_STRINGS_BEG () || AT_STRINGS_END () || LETTER_P (d) != LETTER_P (d + 1))
        -: 8753:
        -: 8754:
        -: 8755:static char slowmap [256] =
        -: 8756:{
        -: 8757:  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        -: 8758:  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        -: 8759:  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        -: 8760:  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        -: 8761:  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        -: 8762:  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        -: 8763:  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        -: 8764:  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        -: 8765:  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        -: 8766:  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        -: 8767:  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        -: 8768:  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        -: 8769:  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        -: 8770:  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        -: 8771:  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        -: 8772:  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        -: 8773:};
        -: 8774:
        -: 8775:#ifdef __STDC__
        -: 8776:static void
function rx_blow_up_fastmap called 226 returned 100% blocks executed 100%
      226: 8777:rx_blow_up_fastmap (struct re_pattern_buffer * rxb)
        -: 8778:#else
        -: 8779:static void
        -: 8780:rx_blow_up_fastmap (rxb)
        -: 8781:     struct re_pattern_buffer * rxb;
        -: 8782:#endif
        -: 8783:{
        -: 8784:  int x;
    58082: 8785:  for (x = 0; x < 256; ++x)	/* &&&& 3.6 % */
branch  0 taken 57856
branch  1 taken 226 (fallthrough)
    57856: 8786:    rxb->fastmap [x] = !!RX_bitset_member (rxb->fastset, x);
      226: 8787:  rxb->fastmap_accurate = 1;
      226: 8788:}
        -: 8789:
        -: 8790:
        -: 8791:
        -: 8792:
        -: 8793:struct stack_chunk
        -: 8794:{
        -: 8795:  struct stack_chunk * next_chunk;
        -: 8796:  int bytes_left;
        -: 8797:  char * sp;
        -: 8798:};
        -: 8799:
        -: 8800:#define PUSH(CHUNK_VAR,BYTES)   \
        -: 8801:  if (!CHUNK_VAR || (CHUNK_VAR->bytes_left < (BYTES)))  \
        -: 8802:    {					\
        -: 8803:      struct stack_chunk * new_chunk;	\
        -: 8804:      if (free_chunks)			\
        -: 8805:	{				\
        -: 8806:	  new_chunk = free_chunks;	\
        -: 8807:	  free_chunks = free_chunks->next_chunk; \
        -: 8808:	}				\
        -: 8809:      else				\
        -: 8810:	{				\
        -: 8811:	  new_chunk = (struct stack_chunk *)alloca (chunk_bytes); \
        -: 8812:	  if (!new_chunk)		\
        -: 8813:	    {				\
        -: 8814:	      ret_val = 0;		\
        -: 8815:	      goto test_do_return;	\
        -: 8816:	    }				\
        -: 8817:	}				\
        -: 8818:      new_chunk->sp = (char *)new_chunk + sizeof (struct stack_chunk); \
        -: 8819:      new_chunk->bytes_left = (chunk_bytes \
        -: 8820:			       - (BYTES) \
        -: 8821:			       - sizeof (struct stack_chunk)); \
        -: 8822:      new_chunk->next_chunk = CHUNK_VAR; \
        -: 8823:      CHUNK_VAR = new_chunk;		\
        -: 8824:    } \
        -: 8825:  else \
        -: 8826:    (CHUNK_VAR->sp += (BYTES)), (CHUNK_VAR->bytes_left -= (BYTES))
        -: 8827:
        -: 8828:#define POP(CHUNK_VAR,BYTES) \
        -: 8829:  if (CHUNK_VAR->sp == ((char *)CHUNK_VAR + sizeof(*CHUNK_VAR))) \
        -: 8830:    { \
        -: 8831:      struct stack_chunk * new_chunk = CHUNK_VAR->next_chunk; \
        -: 8832:      CHUNK_VAR->next_chunk = free_chunks; \
        -: 8833:      free_chunks = CHUNK_VAR; \
        -: 8834:      CHUNK_VAR = new_chunk; \
        -: 8835:    } \
        -: 8836:  else \
        -: 8837:    (CHUNK_VAR->sp -= BYTES), (CHUNK_VAR->bytes_left += BYTES)
        -: 8838:
        -: 8839:struct counter_frame
        -: 8840:{
        -: 8841:  int tag;
        -: 8842:  int val;
        -: 8843:  struct counter_frame * inherited_from; /* If this is a copy. */
        -: 8844:  struct counter_frame * cdr;
        -: 8845:};
        -: 8846:
        -: 8847:struct backtrack_frame
        -: 8848:{
        -: 8849:  char * counter_stack_sp;
        -: 8850:
        -: 8851:  /* A frame is used to save the matchers state when it crosses a 
        -: 8852:   * backtracking point.  The `stk_' fields correspond to variables
        -: 8853:   * in re_search_2 (just strip off thes `stk_').  They are documented
        -: 8854:   * tere.
        -: 8855:   */
        -: 8856:  struct rx_superstate * stk_super;
        -: 8857:  const unsigned char * stk_tst_pos;
        -: 8858:  int stk_tst_half;
        -: 8859:  unsigned int stk_c;
        -: 8860:  const unsigned char * stk_tst_str_half;
        -: 8861:  const unsigned char * stk_tst_end_half;
        -: 8862:  int stk_last_l;
        -: 8863:  int stk_last_r;
        -: 8864:  int stk_test_ret;
        -: 8865:
        -: 8866:  /* This is the list of options left to explore at the backtrack
        -: 8867:   * point for which this frame was created. 
        -: 8868:   */
        -: 8869:  struct rx_distinct_future * df;
        -: 8870:  struct rx_distinct_future * first_df;
        -: 8871:
        -: 8872:#ifdef RX_DEBUG
        -: 8873:   int stk_line_no;
        -: 8874:#endif
        -: 8875:};
        -: 8876:
        -: 8877:
        -: 8878:
        -: 8879:#if !defined(REGEX_MALLOC) && !defined(__GNUC__)
        -: 8880:#define RE_SEARCH_2_FN	inner_re_search_2
        -: 8881:#else
        -: 8882:#define RE_SEARCH_2_FN	re_search_2
        -: 8883:#endif
        -: 8884:
        -: 8885:#ifdef __STDC__
        -: 8886:int
function re_search_2 called 16193 returned 100% blocks executed 35%
    16193: 8887:RE_SEARCH_2_FN (struct re_pattern_buffer *rxb,
        -: 8888:		const char * string1, int size1,
        -: 8889:		const char * string2, int size2,
        -: 8890:		int startpos, int range,
        -: 8891:		struct re_registers *regs,
        -: 8892:		int stop)
        -: 8893:#else
        -: 8894:int
        -: 8895:RE_SEARCH_2_FN (rxb,
        -: 8896:		string1, size1, string2, size2, startpos, range, regs, stop)
        -: 8897:     struct re_pattern_buffer *rxb;
        -: 8898:     const char * string1;
        -: 8899:     int size1;
        -: 8900:     const char * string2;
        -: 8901:     int size2;
        -: 8902:     int startpos;
        -: 8903:     int range;
        -: 8904:     struct re_registers *regs;
        -: 8905:     int stop;
        -: 8906:#endif
        -: 8907:{
        -: 8908:  /* Two groups of registers are kept.  The group with the register state
        -: 8909:   * of the current test match, and the group that holds the state at the end
        -: 8910:   * of the best known match, if any.
        -: 8911:   *
        -: 8912:   * For some patterns, there may also be registers saved on the stack.
        -: 8913:   */
    16193: 8914:  regoff_t * lparen = 0; /* scratch space for register returns */
    16193: 8915:  regoff_t * rparen = 0;
    16193: 8916:  regoff_t * best_lpspace = 0; /* in case the user doesn't want these */
    16193: 8917:  regoff_t * best_rpspace = 0; /* values, we still need space to store
        -: 8918:				* them.  Normally, this memoryis unused
        -: 8919:				* and the space pointed to by REGS is 
        -: 8920:				* used instead.
        -: 8921:				*/
        -: 8922:  
        -: 8923:  int last_l;			/* Highest index of a valid lparen. */
        -: 8924:  int last_r;			/* It's dual. */
        -: 8925:
        -: 8926:  int * best_lparen;		/* This contains the best known register */
        -: 8927:  int * best_rparen;		/* assignments. 
        -: 8928:				 * This may point to the same mem as
        -: 8929:				 * best_lpspace, or it might point to memory
        -: 8930:				 * passed by the caller.
        -: 8931:				 */
        -: 8932:  int best_last_l;		/* best_last_l:best_lparen::last_l:lparen */
        -: 8933:  int best_last_r;
        -: 8934:  
        -: 8935:  
        -: 8936:
        -: 8937:  /* Figure the number of registers we may need for use in backreferences.
        -: 8938:   * The number here includes an element for register zero.  
        -: 8939:   */
    16193: 8940:  unsigned num_regs = rxb->re_nsub + 1;
        -: 8941:
    16193: 8942:  int total_size = size1 + size2;
        -: 8943:
        -: 8944:
        -: 8945:  /***** INIT re_search_2 */
        -: 8946:  
        -: 8947:  /* Check for out-of-range STARTPOS.  */
    16193: 8948:  if ((startpos < 0) || (startpos > total_size))
branch  0 taken 16193 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 16193
    #####: 8949:    return -1;
        -: 8950:
        -: 8951:  /* Fix up RANGE if it might eventually take us outside
        -: 8952:   * the virtual concatenation of STRING1 and STRING2.
        -: 8953:   */
        -: 8954:  {
    16193: 8955:    int endpos = startpos + range;
    16193: 8956:    if (endpos < -1)
branch  0 taken 0 (fallthrough)
branch  1 taken 16193
    #####: 8957:      range = (-1 - startpos);
    16193: 8958:    else if (endpos > total_size)
branch  0 taken 0 (fallthrough)
branch  1 taken 16193
    #####: 8959:      range = total_size - startpos;
        -: 8960:  }
        -: 8961:
        -: 8962:  /* If the search isn't to be a backwards one, don't waste time in a
        -: 8963:   * long search for a pattern that says it is anchored.
        -: 8964:   */
    16193: 8965:  if (rxb->begbuf_only && (range > 0))
branch  0 taken 4515 (fallthrough)
branch  1 taken 11678
branch  2 taken 3267 (fallthrough)
branch  3 taken 1248
        -: 8966:    {
     3267: 8967:      if (startpos > 0)
branch  0 taken 471 (fallthrough)
branch  1 taken 2796
      471: 8968:	return -1;
        -: 8969:      else
     2796: 8970:	range = 1;
        -: 8971:    }
        -: 8972:
        -: 8973:  /* Then, decide whether to use internal or user-provided reg buffers. */
    15722: 8974:  if (!regs || rxb->no_sub)
branch  0 taken 5337 (fallthrough)
branch  1 taken 10385
branch  2 taken 0 (fallthrough)
branch  3 taken 5337
        -: 8975:    {
    10385: 8976:      best_lpspace = (regoff_t *)REGEX_ALLOCATE (num_regs * sizeof(regoff_t));
    10385: 8977:      best_rpspace = (regoff_t *)REGEX_ALLOCATE (num_regs * sizeof(regoff_t));
    10385: 8978:      best_lparen = best_lpspace;
    10385: 8979:      best_rparen = best_rpspace;
        -: 8980:    }
        -: 8981:  else
        -: 8982:    {	
        -: 8983:      /* Have the register data arrays been allocated?  */
     5337: 8984:      if (rxb->regs_allocated == REGS_UNALLOCATED)
branch  0 taken 77 (fallthrough)
branch  1 taken 5260
        -: 8985:	{ /* No.  So allocate them with malloc.  We need one
        -: 8986:	     extra element beyond `num_regs' for the `-1' marker
        -: 8987:	     GNU code uses.  */
       77: 8988:	  regs->num_regs = MAX (RE_NREGS, rxb->re_nsub + 1);
       77: 8989:	  regs->start = TALLOC (regs->num_regs, regoff_t);
       77: 8990:	  regs->end = TALLOC (regs->num_regs, regoff_t);
       77: 8991:	  if (regs->start == 0 || regs->end == 0)
branch  0 taken 77 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 77
    #####: 8992:	    return -2;
       77: 8993:	  rxb->regs_allocated = REGS_REALLOCATE;
        -: 8994:	}
     5260: 8995:      else if (rxb->regs_allocated == REGS_REALLOCATE)
branch  0 taken 5260 (fallthrough)
branch  1 taken 0
        -: 8996:	{ /* Yes.  If we need more elements than were already
        -: 8997:	     allocated, reallocate them.  If we need fewer, just
        -: 8998:	     leave it alone.  */
     5260: 8999:	  if (regs->num_regs < num_regs + 1)
branch  0 taken 0 (fallthrough)
branch  1 taken 5260
        -: 9000:	    {
    #####: 9001:	      regs->num_regs = num_regs + 1;
    #####: 9002:	      RETALLOC (regs->start, regs->num_regs, regoff_t);
    #####: 9003:	      RETALLOC (regs->end, regs->num_regs, regoff_t);
    #####: 9004:	      if (regs->start == 0 || regs->end == 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 9005:		return -2;
        -: 9006:	    }
        -: 9007:	}
    #####: 9008:      else if (rxb->regs_allocated != REGS_FIXED)
branch  0 never executed
branch  1 never executed
    #####: 9009:	return -2;
        -: 9010:
     5337: 9011:      if (regs->num_regs < num_regs + 1)
branch  0 taken 0 (fallthrough)
branch  1 taken 5337
        -: 9012:	{
        -: 9013:	  best_lpspace = ((regoff_t *)
    #####: 9014:			  REGEX_ALLOCATE (num_regs * sizeof(regoff_t)));
        -: 9015:	  best_rpspace = ((regoff_t *)
    #####: 9016:			  REGEX_ALLOCATE (num_regs * sizeof(regoff_t)));
    #####: 9017:	  best_lparen = best_lpspace;
    #####: 9018:	  best_rparen = best_rpspace;
        -: 9019:	}
        -: 9020:      else
        -: 9021:	{
     5337: 9022:	  best_lparen = regs->start;
     5337: 9023:	  best_rparen = regs->end;
        -: 9024:	}
        -: 9025:    }
        -: 9026:  
    15722: 9027:  lparen = (regoff_t *) REGEX_ALLOCATE (num_regs * sizeof(regoff_t));
    15722: 9028:  rparen = (regoff_t *) REGEX_ALLOCATE (num_regs * sizeof(regoff_t)); 
        -: 9029:  
    15722: 9030:  if (!(best_rparen && best_lparen && lparen && rparen))
branch  0 taken 15722 (fallthrough)
branch  1 taken 0
branch  2 taken 15722 (fallthrough)
branch  3 taken 0
branch  4 taken 15722 (fallthrough)
branch  5 taken 0
branch  6 taken 0 (fallthrough)
branch  7 taken 15722
    #####: 9031:    return -2;
        -: 9032:  
    15722: 9033:  best_last_l = best_last_r = -1;
        -: 9034:
        -: 9035:
        -: 9036:
        -: 9037:  /***** fastmap/search loop, initialization */
        -: 9038:
        -: 9039:  /* This is the loop that scans using the fastmap, and sometimes tries to 
        -: 9040:   * match. From this point on, don't return.  Instead, assign to ret_val
        -: 9041:   * and goto fail.
        -: 9042:   */
        -: 9043:  {
    31444: 9044:    const unsigned char * translate = (rxb->translate
        -: 9045:				       ? (unsigned char *)rxb->translate
   15722*: 9046:				       : (unsigned char *)id_translation);
branch  0 taken 0 (fallthrough)
branch  1 taken 15722
        -: 9047:    
        -: 9048:    /** This is state associated with returning to the caller. */
        -: 9049:
    15722: 9050:    int ret_val = -1;
        -: 9051:
        -: 9052:    /*   A sentinal is sometimes installed in the fastmap.  This records
        -: 9053:     *   where so it can be removed before returning.
        -: 9054:     */
    15722: 9055:    int fastmap_chr = -1;
    15722: 9056:    int fastmap_val = 0;
        -: 9057:
        -: 9058:    /** End of state associated with returning to the caller. */
        -: 9059:
        -: 9060:    /** Start of variables associated with the fastmap based search: */
        -: 9061:
   15722*: 9062:    char * fastmap = rxb->fastmap ? (char *)rxb->fastmap : (char *)slowmap;
branch  0 taken 15722 (fallthrough)
branch  1 taken 0
        -: 9063:    int search_direction;	/* 1 or -1 */
        -: 9064:    int search_end;		/* first position to not try */
        -: 9065:    int offset;			/* either size1 or 0 as string == string2 */
        -: 9066:
        -: 9067:    /* The string-pair position of the fastmap/search loop: */
        -: 9068:    const unsigned char * pos;	/* The current pos. */
        -: 9069:    const unsigned char * string; /* The current string half. */
        -: 9070:    const unsigned char * end;	/* End of current string. */
        -: 9071:    int size;			/* Current string's size */
        -: 9072:    int half;			/* 0 means string1, 1 means string2 */
        -: 9073:
        -: 9074:    /** End of variables associated with the fastmap based search: */
        -: 9075:
        -: 9076:
        -: 9077:    /** Start of variables associated with trying a match
        -: 9078:     *  after the fastmap has found a plausible starting point.
        -: 9079:     */
        -: 9080:
    15722: 9081:    struct rx_superstate * start_super = 0; /* The superNFA start state. */
        -: 9082:
        -: 9083:    /*
        -: 9084:     * Two nfa's were compiled.  
        -: 9085:     * `0' is complete.
        -: 9086:     * `1' faster but gets registers wrong and ends too soon.
        -: 9087:     */
    15722: 9088:    int nfa_choice = ((regs && !rxb->least_subs) ? '\0' : '\1');
branch  0 taken 5337 (fallthrough)
branch  1 taken 10385
branch  2 taken 0 (fallthrough)
branch  3 taken 5337
        -: 9089:
        -: 9090:    const unsigned char * abs_end; /* Don't fetch a character from here. */
        -: 9091:    int first_found;		/* If true, return after finding any match. */
        -: 9092:
        -: 9093:    /** End of variables associated with trying a match. */
        -: 9094:
        -: 9095:    /* Update the fastmap now if not correct already. 
        -: 9096:     * When the regexp was compiled, the fastmap was computed
        -: 9097:     * and stored in a bitset.  This expands the bitset into a
        -: 9098:     * character array containing 1s and 0s.
        -: 9099:     */
    15722: 9100:    if ((fastmap == rxb->fastmap) && !rxb->fastmap_accurate)
branch  0 taken 15722 (fallthrough)
branch  1 taken 0
branch  2 taken 226 (fallthrough)
branch  3 taken 15496
      226: 9101:      rx_blow_up_fastmap (rxb);
call    0 returned 226
        -: 9102:
        -: 9103:    /* Now we build the starting state of the supernfa. */
        -: 9104:    {
        -: 9105:      struct rx_superset * start_contents;
        -: 9106:      struct rx_nfa_state_set * start_nfa_set;
        -: 9107:      
        -: 9108:      /* We presume here that the nfa start state has only one
        -: 9109:       * possible future with no side effects.  
        -: 9110:       */
    15722: 9111:      start_nfa_set = rxb->start->futures->destset;
    15722: 9112:      if (   rxb->rx.start_set
branch  0 taken 15496 (fallthrough)
branch  1 taken 226
    15496: 9113:	  && (rxb->rx.start_set->starts_for == &rxb->rx))
branch  0 taken 15496 (fallthrough)
branch  1 taken 0
    15496: 9114:	start_contents = rxb->rx.start_set;
        -: 9115:      else
        -: 9116:	{
        -: 9117:	  start_contents =
      226: 9118:	    rx_superstate_eclosure_union (&rxb->rx,
call    0 returned 226
call    1 returned 226
        -: 9119:					  rx_superset_cons (&rxb->rx, 0, 0),
        -: 9120:					  start_nfa_set);
        -: 9121:	  
      226: 9122:	  if (!start_contents)
branch  0 taken 0 (fallthrough)
branch  1 taken 226
    #####: 9123:	    return -1;
        -: 9124:
      226: 9125:	  start_contents->starts_for = &rxb->rx;
      226: 9126:	  rxb->rx.start_set = start_contents;
        -: 9127:	}
    15722: 9128:      if (   start_contents->superstate
branch  0 taken 15496 (fallthrough)
branch  1 taken 226
    15496: 9129:	  && (start_contents->superstate->rx_id == rxb->rx.rx_id))
branch  0 taken 15496 (fallthrough)
branch  1 taken 0
        -: 9130:	{
    15496: 9131:	  start_super = start_contents->superstate;
    15496: 9132:	  rx_lock_superstate (&rxb->rx, start_super);
        -: 9133:	}
        -: 9134:      else
        -: 9135:	{
      226: 9136:	  rx_protect_superset (&rxb->rx, start_contents);
        -: 9137:	  
      226: 9138:	  start_super = rx_superstate (&rxb->rx, start_contents);
call    0 returned 226
      226: 9139:	  if (!start_super)
branch  0 taken 0 (fallthrough)
branch  1 taken 226
    #####: 9140:	    return -1;
      226: 9141:	  rx_lock_superstate (&rxb->rx, start_super);
      226: 9142:	  rx_release_superset (&rxb->rx, start_contents);
call    0 returned 226
        -: 9143:	}
        -: 9144:    }
        -: 9145:    
        -: 9146:    /* This computes an upper bound on string addresses for use by
        -: 9147:     * the match-test.
        -: 9148:     */
    15722: 9149:    abs_end = ((const unsigned char *) ((stop <= size1)
branch  0 taken 4413 (fallthrough)
branch  1 taken 11309
     4413: 9150:					? string1 + stop
    11309: 9151:					: string2 + stop - size1));
        -: 9152:
        -: 9153:    /* We have the option to look for the best match or the first
        -: 9154:     * one we can find.  If the user isn't asking for register information,
        -: 9155:     * we don't need to find the best match.
        -: 9156:     */
    15722: 9157:    first_found = !regs;
        -: 9158:
        -: 9159:    /* Compute search_end & search_direction for the fastmap loop. */
    15722: 9160:    if (range >= 0)
branch  0 taken 15722 (fallthrough)
branch  1 taken 0
        -: 9161:      {
    15722: 9162:	search_end = MIN (size1 + size2, startpos + range) + 1;
    15722: 9163:	search_direction = 1;
        -: 9164:      }
        -: 9165:    else
        -: 9166:      {
    #####: 9167:	search_end = MAX(-1, startpos + range);
    #####: 9168:	search_direction = -1;
        -: 9169:      }
        -: 9170:
        -: 9171:    /* The vacuous search always turns up nothing. */
   15722*: 9172:    if ((search_direction == 1)
branch  0 taken 15722 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 15722
        -: 9173:	? (startpos > search_end)
        -: 9174:	: (startpos < search_end))
    #####: 9175:      return -1;
        -: 9176:
        -: 9177:    /* Set string/size/offset/end -- the state that tells the fastmap
        -: 9178:     * loop which half of the string we're in.  Also set pos, which
        -: 9179:     * is the addr of the current fastmap scan position.
        -: 9180:     */
    15722: 9181:    if (!string2 || (startpos < size1))
branch  0 taken 15722 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 15722
        -: 9182:      {
    #####: 9183:	string = (const unsigned char *)string1;
    #####: 9184:	size = size1;
    #####: 9185:	offset = 0;
    #####: 9186:	pos = (const unsigned char *)(string1 + startpos);
    #####: 9187:	half = 0;
    #####: 9188:	end = (const unsigned char *)MIN(string1 + size1, string1 + stop);
        -: 9189:      }
        -: 9190:    else
        -: 9191:      {
    15722: 9192:	string = (const unsigned char *)string2;
    15722: 9193:	size = size2;
    15722: 9194:	offset = size1;
    15722: 9195:	pos = (const unsigned char *)(string2 + startpos - size1);
    15722: 9196:	half = 1;
    15722: 9197:	end = (const unsigned char *)MIN(string2 + size2,
        -: 9198:					 string2 + stop - size1);
        -: 9199:      }
        -: 9200:
        -: 9201:
        -: 9202:
        -: 9203:
        -: 9204:    /***** fastmap/search loop,  body */
        -: 9205:
        -: 9206:
    15722: 9207:  init_fastmap_sentinal:
        -: 9208:
        -: 9209:    /* For the sake of fast fastmapping, set a sentinal in the fastmap.
        -: 9210:     * This sentinal will trap the fastmap loop when it reaches the last
        -: 9211:     * valid character in a string half.
        -: 9212:     *
        -: 9213:     * This must be reset when the fastmap/search loop crosses a string 
        -: 9214:     * boundry, and before returning to the caller.  So sometimes,
        -: 9215:     * the fastmap loop is restarted with `continue', othertimes by
        -: 9216:     * `goto init_fastmap_sentinal'.
        -: 9217:     */
    15722: 9218:    if (size)
branch  0 taken 11309 (fallthrough)
branch  1 taken 4413
        -: 9219:      {
    11309: 9220:	fastmap_chr = ((search_direction == 1)
    11309: 9221:		       ? *(end - 1)
   11309*: 9222:		       : *string);
branch  0 taken 11309 (fallthrough)
branch  1 taken 0
    11309: 9223:	fastmap_val = fastmap[fastmap_chr];
    11309: 9224:	fastmap[fastmap_chr] = 1;
        -: 9225:      }
        -: 9226:    else
        -: 9227:      {
     4413: 9228:	fastmap_chr = -1;
     4413: 9229:	fastmap_val = 0;
        -: 9230:      }
        -: 9231:
        -: 9232:    do
        -: 9233:      {
        -: 9234:	/* If we haven't reached the end of a string half, and if the
        -: 9235:	 * pattern can't match the empty string, then the fastmap 
        -: 9236:	 * optimization applies.  This conditional scans using the 
        -: 9237:	 * fastmap -- stoping when a string half ends, or when a 
        -: 9238:	 * plausible starting point for a match is found.
        -: 9239:	 * It updates HIT_BOUND to tell which case occured.
        -: 9240:	 */
    24656: 9241:	if (pos == end)
branch  0 taken 5339 (fallthrough)
branch  1 taken 19317
     5339: 9242:	  goto fastmap_hit_bound;
        -: 9243:	else
        -: 9244:	  {
    19317: 9245:	    if (search_direction == 1)
branch  0 taken 19317 (fallthrough)
branch  1 taken 0
        -: 9246:	      {
    19317: 9247:		if (fastmap_val)
branch  0 taken 10806 (fallthrough)
branch  1 taken 8511
        -: 9248:		  {
        -: 9249:		    for (;;)
        -: 9250:		      {
    24535: 9251:			while (!fastmap[*pos])
branch  0 taken 13729
branch  1 taken 10806 (fallthrough)
    13729: 9252:			  ++pos;
    10806: 9253:			goto commence_a_matchin;
        -: 9254:		      }
        -: 9255:		  }
        -: 9256:		else
        -: 9257:		  {
        -: 9258:		    for (;;)
        -: 9259:		      {
   150411: 9260:			while (!fastmap[*pos])
branch  0 taken 131101
branch  1 taken 19310 (fallthrough)
   131101: 9261:			  ++pos;
    19310: 9262:			if (*pos != fastmap_chr)
branch  0 taken 2285 (fallthrough)
branch  1 taken 17025
     2285: 9263:			  goto commence_a_matchin;
        -: 9264:			else 
        -: 9265:			  {
    17025: 9266:			    ++pos;
    17025: 9267:			    if (pos == end)
branch  0 taken 6226 (fallthrough)
branch  1 taken 10799
     6226: 9268:			      goto fastmap_hit_bound;
        -: 9269:			  }
        -: 9270:		      }
        -: 9271:		  }
        -: 9272:	      }
        -: 9273:	    else
        -: 9274:	      {
    #####: 9275:		const unsigned char * bound = string - 1;
    #####: 9276:		if (fastmap_val)
branch  0 never executed
branch  1 never executed
        -: 9277:		  {
        -: 9278:		    for (;;)
        -: 9279:		      {
    #####: 9280:			while (!fastmap[*pos])
branch  0 never executed
branch  1 never executed
    #####: 9281:			  --pos;
    #####: 9282:			goto commence_a_matchin;
        -: 9283:		      }
        -: 9284:		  }
        -: 9285:		else
        -: 9286:		  {
        -: 9287:		    for (;;)
        -: 9288:		      {
    #####: 9289:			while (!fastmap[*pos])
branch  0 never executed
branch  1 never executed
    #####: 9290:			  --pos;
    #####: 9291:			if ((*pos != fastmap_chr) || fastmap_val)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 9292:			  goto commence_a_matchin;
        -: 9293:			else 
        -: 9294:			  {
    #####: 9295:			    --pos;
    #####: 9296:			    if (pos == bound)
branch  0 never executed
branch  1 never executed
    #####: 9297:			      goto fastmap_hit_bound;
        -: 9298:			  }
        -: 9299:		      }
        -: 9300:		  }
        -: 9301:	      }
        -: 9302:	  }
        -: 9303:	
    11565: 9304:      fastmap_hit_bound:
        -: 9305:	{
        -: 9306:	  /* If we hit a bound, it may simply be time to switch sides
        -: 9307:	   * between strings.
        -: 9308:	   */
    11565: 9309:	  if ((search_direction == 1) && string2 && (half == 0))
branch  0 taken 11565 (fallthrough)
branch  1 taken 0
branch  2 taken 11565 (fallthrough)
branch  3 taken 0
branch  4 taken 0 (fallthrough)
branch  5 taken 11565
        -: 9310:	    {
    #####: 9311:	      string = (const unsigned char *)string2;
    #####: 9312:	      size = size2;
    #####: 9313:	      offset = size1;
    #####: 9314:	      half = 1;
    #####: 9315:	      end = (const unsigned char *)MIN(string2 + size2,
        -: 9316:					       string2 + stop - size1);
    #####: 9317:	      startpos = size1;
    #####: 9318:	      pos = (const unsigned char *)string2;
    #####: 9319:	      goto init_fastmap_sentinal;
        -: 9320:	    }
    11565: 9321:	  else if (   string1
branch  0 taken 0 (fallthrough)
branch  1 taken 11565
    #####: 9322:		   && (search_direction == -1)
branch  0 never executed
branch  1 never executed
    #####: 9323:		   && (half == 1))
branch  0 never executed
branch  1 never executed
        -: 9324:	    {
    #####: 9325:	      string = (const unsigned char *)string1;
    #####: 9326:	      size = size1;
    #####: 9327:	      offset = 0;
    #####: 9328:	      end = (const unsigned char *)string1 + size1;
    #####: 9329:	      half = 0;
    #####: 9330:	      startpos = size1 - 1;
    #####: 9331:	      pos = (const unsigned char *)string1 + size1 - 1;
    #####: 9332:	      goto init_fastmap_sentinal;
        -: 9333:	    }
        -: 9334:	  /* ...not a string split, simply no more string. 
        -: 9335:	   *
        -: 9336:	   * When searching backward, running out of string
        -: 9337:	   * is reason to quit.
        -: 9338:	   */
    11565: 9339:	  else if (search_direction == -1)
branch  0 taken 0 (fallthrough)
branch  1 taken 11565
    #####: 9340:	    goto finish;
        -: 9341:	  
        -: 9342:	  /* ...when searching forward, we allow the possibility
        -: 9343:	   * of an (empty) match after the last character in the
        -: 9344:	   * virtual string.  So, fall through to the matcher
        -: 9345:	   */
        -: 9346:	}
        -: 9347:
        -: 9348:
    11565: 9349:      commence_a_matchin:
        -: 9350:
        -: 9351:	/***** fastmap/search loop body
        -: 9352:	 *	      test for a match that begins at pos
        -: 9353:	 */
        -: 9354:
        -: 9355:	/* Now the fastmap loop has brought us to a plausible 
        -: 9356:	 * starting point for a match.  So, it's time to run the
        -: 9357:	 * NFA and see if a match occured.
        -: 9358:	 */
        -: 9359:
    24656: 9360:	startpos = pos - string + offset;
    24656: 9361:	if (startpos == search_end)
branch  0 taken 56 (fallthrough)
branch  1 taken 24600
       56: 9362:	  goto finish;
        -: 9363:	
    24600: 9364:	last_l = last_r = 0;
    24600: 9365:	lparen[0] = startpos;	/* We know match-begin for this test... */
        -: 9366:
        -: 9367:	/* The test matcher is essentially a recursive function
        -: 9368:	 * that does an exhaustive run of the superNFA at the 
        -: 9369:	 * test position.  For performance, that function has 
        -: 9370:	 * been in-lined by hand.
        -: 9371:	 */
        -: 9372:
        -: 9373:#undef OF
        -: 9374:#ifndef HAVE_GNUC_LABELS
        -: 9375:#define OF(A,B)	A
        -: 9376:#else
        -: 9377:#define OF(A,B)	A: B
        -: 9378:	  static void * rx_labels_instruction_table[] =
        -: 9379:	    {
        -: 9380:	      [rx_backtrack_point] &&backtrack_point,
        -: 9381:	      [rx_backtrack] &&backtrack,
        -: 9382:	      [rx_do_side_effects] &&do_side_effects,
        -: 9383:	      [rx_cache_miss] &&cache_miss,
        -: 9384:	      [rx_next_char] 0,
        -: 9385:	      [rx_error_inx] 0
        -: 9386:	    };
        -: 9387:#endif
        -: 9388:	{	  
        -: 9389:	  /* The current superNFA position of the matcher. */
    24600: 9390:	  struct rx_superstate * super = start_super;
        -: 9391:	  
        -: 9392:	  /* The matcher interprets a series of instruction frames.
        -: 9393:	   * This is the `instruction counter' for the interpretation.
        -: 9394:	   */
        -: 9395:	  struct rx_inx * ifr;
        -: 9396:	  
        -: 9397:	  /* We insert a ghost character in the string to prime
        -: 9398:	   * the nfa.  tst_pos, tst_str_half, and tst_end_half
        -: 9399:	   * keep track of the test-match position and string-half.
        -: 9400:	   */
    24600: 9401:	  const unsigned char * tst_pos = pos - 1;
    24600: 9402:	  int tst_half = half;
    24600: 9403:	  unsigned char c = nfa_choice;
        -: 9404:	  
    24600: 9405:	  const unsigned char * tst_str_half = string;
    24600: 9406:	  const unsigned char * tst_end_half = end;
        -: 9407:	  
    24600: 9408:	  struct stack_chunk * counter_stack = 0;
    24600: 9409:	  struct stack_chunk * backtrack_stack = 0;
   24600*: 9410:	  int backtrack_frame_bytes =
        -: 9411:	    (sizeof (struct backtrack_frame)
    #####: 9412:	     + (rxb->match_regs_on_stack
   24600*: 9413:		? sizeof (regoff_t) * (num_regs + 1) * 2
branch  0 taken 0 (fallthrough)
branch  1 taken 24600
        -: 9414:		: 0));
    24600: 9415:	  int chunk_bytes = backtrack_frame_bytes * 64;
    24600: 9416:	  struct stack_chunk * free_chunks = 0;
        -: 9417:
        -: 9418:#ifdef RX_DEBUG
        -: 9419:	  int backtrack_depth = 0;
        -: 9420:#endif
        -: 9421:
        -: 9422:	  /* To return from this function, set test_ret and 
        -: 9423:	   * `goto test_do_return'.
        -: 9424:	   *
        -: 9425:	   * Possible return values are:
        -: 9426:	   *     1   --- end of string while the superNFA is still going
        -: 9427:	   *     0   --- internal error (out of memory)
        -: 9428:	   *	-1   --- search completed by reaching the superNFA fail state
        -: 9429:	   *    -2   --- a match was found, maybe not the longest.
        -: 9430:	   *
        -: 9431:	   * When the search is complete (-1), best_last_r indicates whether
        -: 9432:	   * a match was found.
        -: 9433:	   *
        -: 9434:	   * -2 is return only if first_found is non-zero.
        -: 9435:	   *
        -: 9436:	   * if first_found is non-zero, a return of -1 indicates no match,
        -: 9437:	   * otherwise, best_last_r has to be checked.
        -: 9438:	   */
    24600: 9439:	  int test_ret = -1;
        -: 9440:	  
        -: 9441:	  while (1)
    #####: 9442:	    {
        -: 9443:	      int inx;
        -: 9444:#ifdef RX_DEBUG
        -: 9445:	      /* There is a search tree with every node as set of deterministic
        -: 9446:	       * transitions in the super nfa.  For every branch of a 
        -: 9447:	       * backtrack point is an edge in the tree.
        -: 9448:	       * This counts up a pre-order of nodes in that tree.
        -: 9449:	       * It's saved on the search stack and printed when debugging. 
        -: 9450:	       */
        -: 9451:	      int line_no = 0;
        -: 9452:	      int lines_found = 0;
        -: 9453:#endif
        -: 9454:
        -: 9455:
    24600: 9456:	    top_of_cycle:
        -: 9457:	      /* A superstate is basicly a transition table, indexed by 
        -: 9458:	       * characters from the string being tested, and containing 
        -: 9459:	       * RX_INX structures.
        -: 9460:	       */
    24600: 9461:	      ifr = &super->transitions [c];
        -: 9462:	      
    34466: 9463:	    recurse_test_match:
        -: 9464:	      /* This is the point to which control is sent when the
        -: 9465:	       * test matcher recurses.  Before jumping here, some variables
        -: 9466:	       * need to be saved on the stack and setup for the recursion.
        -: 9467:	       */
        -: 9468:
    50100: 9469:	    restart:
        -: 9470:	      /* Some instructions don't advance the matcher, but just
        -: 9471:	       * carry out some side effects and fetch a new instruction.
        -: 9472:	       * To dispatch that new instruction, `goto restart'.
        -: 9473:	       */
        -: 9474:	      
        -: 9475:	      {
    50100: 9476:		struct rx_inx * next_tr_table = (struct rx_inx *)ifr->data;
    50100: 9477:		struct rx_inx * this_tr_table = super->transitions;
        -: 9478:		/* The fastest route through the loop is when the instruction 
        -: 9479:		 * is RX_NEXT_CHAR.  This case is detected when IFR->DATA
        -: 9480:		 * is non-zero.  In that case, it points to the next
        -: 9481:		 * superstate. 
        -: 9482:		 *
        -: 9483:		 * This allows us to not bother fetching the bytecode.
        -: 9484:		 */
   157111: 9485:		while (next_tr_table)
branch  0 taken 123703
branch  1 taken 33408 (fallthrough)
        -: 9486:		  {
        -: 9487:#ifdef RX_DEBUG
        -: 9488:		    if (rx_debug_trace)
        -: 9489:		      {
        -: 9490:			struct rx_superset * setp;
        -: 9491:
        -: 9492:			fprintf (stderr, "%d %d>> re_next_char @ %d (%d)",
        -: 9493:				 line_no,
        -: 9494:				 backtrack_depth,
        -: 9495:				 (tst_pos - tst_str_half
        -: 9496:				  + (tst_half == 0
        -: 9497:				     ? 0 : size1)), c);
        -: 9498:			
        -: 9499:			super =
        -: 9500:			  ((struct rx_superstate *)
        -: 9501:			   ((char *)this_tr_table
        -: 9502:			    - ((unsigned long)
        -: 9503:			       ((struct rx_superstate *)0)->transitions)));
        -: 9504:
        -: 9505:			setp = super->contents;
        -: 9506:			fprintf (stderr, "   superstet (rx=%d, &=%x: ",
        -: 9507:				 rxb->rx.rx_id, setp);
        -: 9508:			while (setp)
        -: 9509:			  {
        -: 9510:			    fprintf (stderr, "%d ", setp->id);
        -: 9511:			    setp = setp->cdr;
        -: 9512:			  }
        -: 9513:			fprintf (stderr, "\n");
        -: 9514:		      }
        -: 9515:#endif
   123703: 9516:		    this_tr_table = next_tr_table;
   123703: 9517:		    ++tst_pos;
   123703: 9518:		    if (tst_pos == tst_end_half)
branch  0 taken 16692 (fallthrough)
branch  1 taken 107011
        -: 9519:		      {
    16692: 9520:			if (   (tst_pos != abs_end)
branch  0 taken 3521 (fallthrough)
branch  1 taken 13171
     3521: 9521:			    && string2
branch  0 taken 3521 (fallthrough)
branch  1 taken 0
     3521: 9522:			    && half == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 3521
        -: 9523:			  {
        -: 9524:			    /* Here we are crossing the break 
        -: 9525:			     * in a split string. 
        -: 9526:			     */
    #####: 9527:			    tst_str_half = (const unsigned char *)string2;
    #####: 9528:			    tst_end_half = abs_end;
    #####: 9529:			    tst_pos = (const unsigned char *)string2;
    #####: 9530:			    tst_half = 1;
        -: 9531:			  }
        -: 9532:			else
        -: 9533:			  {
    16692: 9534:			    test_ret = 1;
    16692: 9535:			    goto test_do_return;
        -: 9536:			  }
        -: 9537:		      }
   107011: 9538:		    c = *tst_pos;
   107011: 9539:		    ifr = this_tr_table + c;
   107011: 9540:		    next_tr_table = (struct rx_inx *)ifr->data;
        -: 9541:		  }
        -: 9542:		
        -: 9543:		/* Here when we ran out cached next-char transitions. 
        -: 9544:		 * So, it will be necessary to do a more expensive
        -: 9545:		 * dispatch on the current instruction.  The superstate
        -: 9546:		 * pointer is allowed to become invalid during next-char
        -: 9547:		 * transitions -- now we must bring it up to date.
        -: 9548:		 */
    33408: 9549:		super =
        -: 9550:		  ((struct rx_superstate *)
        -: 9551:		   ((char *)this_tr_table
        -: 9552:		    - ((unsigned long)
        -: 9553:		       ((struct rx_superstate *)0)->transitions)));
        -: 9554:	      }
        -: 9555:	      
        -: 9556:	      /* We've encountered an instruction other than next-char.
        -: 9557:	       * Dispatch that instruction:
        -: 9558:	       */
    33408: 9559:	      inx = (int)ifr->inx;
        -: 9560:#ifdef HAVE_GNUC_LABELS
        -: 9561:	      goto *rx_labels_instruction_table[inx];
        -: 9562:#endif
        -: 9563:#ifdef RX_DEBUG
        -: 9564:	      if (rx_debug_trace)
        -: 9565:		{
        -: 9566:		  struct rx_superset * setp = super->contents;
        -: 9567:		  
        -: 9568:		  fprintf (stderr, "%d %d>> %s @ %d (%d)", line_no,
        -: 9569:			   backtrack_depth,
        -: 9570:			   inx_names[inx],
        -: 9571:			   (tst_pos - tst_str_half
        -: 9572:			    + (tst_half == 0 ? 0 : size1)), c);
        -: 9573:		  
        -: 9574:		  fprintf (stderr, "   superstet (rx=%d, &=%x: ",
        -: 9575:			   rxb->rx.rx_id, setp);
        -: 9576:		  while (setp)
        -: 9577:		    {
        -: 9578:		      fprintf (stderr, "%d ", setp->id);
        -: 9579:		      setp = setp->cdr;
        -: 9580:		    }
        -: 9581:		  fprintf (stderr, "\n");
        -: 9582:		}
        -: 9583:#endif
    33408: 9584:	      switch ((enum rx_opcode)inx)
branch  0 taken 14534
branch  1 taken 9866
branch  2 taken 1237
branch  3 taken 7771
branch  4 taken 0
branch  5 taken 0
        -: 9585:		{
    14534: 9586:		case OF(rx_do_side_effects,do_side_effects):
        -: 9587:
        -: 9588:		  /*  RX_DO_SIDE_EFFECTS occurs when we cross epsilon 
        -: 9589:		   *  edges associated with parentheses, backreferencing, etc.
        -: 9590:		   */
        -: 9591:		  {
    14534: 9592:		    struct rx_distinct_future * df =
        -: 9593:		      (struct rx_distinct_future *)ifr->data_2;
    14534: 9594:		    struct rx_se_list * el = df->effects;
        -: 9595:		    /* Side effects come in lists.  This walks down
        -: 9596:		     * a list, dispatching.
        -: 9597:		     */
    25361: 9598:		    while (el)
branch  0 taken 18146
branch  1 taken 7215 (fallthrough)
        -: 9599:		      {
        -: 9600:#ifdef HAVE_GNUC_LABELS
        -: 9601:			static void * se_labels[] =
        -: 9602:			  {
        -: 9603:			    [-re_se_try] &&se_try,
        -: 9604:			    [-re_se_pushback] &&se_pushback,
        -: 9605:			    [-re_se_push0] &&se_push0,
        -: 9606:			    [-re_se_pushpos] &&se_pushpos,
        -: 9607:			    [-re_se_chkpos] &&se_chkpos,
        -: 9608:			    [-re_se_poppos] &&se_poppos,
        -: 9609:#ifdef emacs
        -: 9610:			    [-re_se_at_dot] &&se_at_dot,
        -: 9611:			    [-re_se_syntax] &&se_syntax,
        -: 9612:			    [-re_se_not_syntax] &&se_not_syntax,
        -: 9613:#endif
        -: 9614:			    [-re_se_begbuf] &&se_begbuf,
        -: 9615:			    [-re_se_hat] &&se_hat,
        -: 9616:			    [-re_se_wordbeg] &&se_wordbeg,
        -: 9617:			    [-re_se_wordbound] &&se_wordbound,
        -: 9618:			    [-re_se_notwordbound] &&se_notwordbound,
        -: 9619:			    [-re_se_wordend] &&se_wordend,
        -: 9620:			    [-re_se_endbuf] &&se_endbuf,
        -: 9621:			    [-re_se_dollar] &&se_dollar,
        -: 9622:			    [-re_se_fail] &&se_fail,
        -: 9623:			  };
        -: 9624:			static void * se_lables2[] =
        -: 9625:			  {
        -: 9626:			    [re_se_win] &&se_win
        -: 9627:			    [re_se_lparen] &&se_lparen,
        -: 9628:			    [re_se_rparen] &&se_rparen,
        -: 9629:			    [re_se_backref] &&se_backref,
        -: 9630:			    [re_se_iter] &&se_iter,
        -: 9631:			    [re_se_end_iter] &&se_end_iter,
        -: 9632:			    [re_se_tv] &&se_tv
        -: 9633:			  };
        -: 9634:#endif
    18146: 9635:			int effect = (int)el->car;
    18146: 9636:			if (effect < 0)
branch  0 taken 10106 (fallthrough)
branch  1 taken 8040
        -: 9637:			  {
        -: 9638:#ifdef HAVE_GNUC_LABELS
        -: 9639:			    goto *se_labels[-effect];
        -: 9640:#endif
        -: 9641:#ifdef RX_DEBUG
        -: 9642:			    if (rx_debug_trace)
        -: 9643:			      {
        -: 9644:				struct rx_superset * setp = super->contents;
        -: 9645:				
        -: 9646:				fprintf (stderr, "....%d %d>> %s\n", line_no,
        -: 9647:					 backtrack_depth,
        -: 9648:					 efnames[-effect]);
        -: 9649:			      }
        -: 9650:#endif
        -: 9651:			    switch ((enum re_side_effects) effect)
        -: 9652:			      {
    #####: 9653:			      case OF(re_se_pushback,se_pushback):
    #####: 9654:				ifr = &df->future_frame;
    #####: 9655:				if (!ifr->data)
branch  0 never executed
branch  1 never executed
        -: 9656:				  {
    #####: 9657:				    struct rx_superstate * sup = super;
    #####: 9658:				    rx_lock_superstate (rx, sup);
    #####: 9659:				    if (!rx_handle_cache_miss (&rxb->rx,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 9660:							       super, c,
        -: 9661:							       ifr->data_2))
        -: 9662:				      {
    #####: 9663:					rx_unlock_superstate (rx, sup);
    #####: 9664:					test_ret = 0;
    #####: 9665:					goto test_do_return;
        -: 9666:				      }
    #####: 9667:				    rx_unlock_superstate (rx, sup);
        -: 9668:				  }
        -: 9669:				/* --tst_pos; */
    #####: 9670:				c = 't';
        -: 9671:				super
    #####: 9672:				  = ((struct rx_superstate *)
    #####: 9673:				     ((char *)ifr->data
        -: 9674:				      - (long)(((struct rx_superstate *)0)
        -: 9675:					       ->transitions)));
    #####: 9676:				goto top_of_cycle;
        -: 9677:				break;
    #####: 9678:			      case OF(re_se_push0,se_push0):
        -: 9679:				{
    #####: 9680:				  struct counter_frame * old_cf
        -: 9681:				     = (counter_stack
        -: 9682:					? ((struct counter_frame *)
        -: 9683:					   counter_stack->sp)
    #####: 9684:					: 0);
branch  0 never executed
branch  1 never executed
        -: 9685:				  struct counter_frame * cf;
    #####: 9686:				  PUSH (counter_stack,
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -: 9687:					sizeof (struct counter_frame));
    #####: 9688:				  cf = ((struct counter_frame *)
        -: 9689:					counter_stack->sp);
    #####: 9690:				  cf->tag = re_se_iter;
    #####: 9691:				  cf->val = 0;
    #####: 9692:				  cf->inherited_from = 0;
    #####: 9693:				  cf->cdr = old_cf;
    #####: 9694:				  break;
        -: 9695:				}
    #####: 9696:			      case OF(re_se_fail,se_fail):
    #####: 9697:				goto test_do_return;
     5587: 9698:			      case OF(re_se_begbuf,se_begbuf):
    5587*: 9699:				if (!AT_STRINGS_BEG ())
branch  0 taken 0 (fallthrough)
branch  1 taken 5587
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 taken 2193 (fallthrough)
branch  7 taken 3394
     2193: 9700:				  goto test_do_return;
     3394: 9701:				break;
     4519: 9702:			      case OF(re_se_endbuf,se_endbuf):
    4519*: 9703:				if (!AT_STRINGS_END ())
branch  0 taken 4519 (fallthrough)
branch  1 taken 0
branch  2 taken 4519 (fallthrough)
branch  3 taken 0
branch  4 taken 3831 (fallthrough)
branch  5 taken 688
branch  6 taken 3831 (fallthrough)
branch  7 taken 688
     3831: 9704:				  goto test_do_return;
      688: 9705:				break;
    #####: 9706:			      case OF(re_se_wordbeg,se_wordbeg):
    #####: 9707:				if (   LETTER_P (tst_pos + 1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
    #####: 9708:				    && (   AT_STRINGS_BEG()
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 9709:					|| !LETTER_P (tst_pos)))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
        -: 9710:				  break;
        -: 9711:				else
    #####: 9712:				  goto test_do_return;
        -: 9713:			      case OF(re_se_wordend,se_wordend):
    #####: 9714:				if (   !AT_STRINGS_BEG ()
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####: 9715:				    && LETTER_P (tst_pos)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
    #####: 9716:				    && (AT_STRINGS_END ()
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 9717:					|| !LETTER_P (tst_pos + 1)))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
        -: 9718:				  break;
        -: 9719:				else
    #####: 9720:				  goto test_do_return;
        -: 9721:			      case OF(re_se_wordbound,se_wordbound):
    #####: 9722:				if (AT_WORD_BOUNDARY (tst_pos))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
branch 21 never executed
branch 22 never executed
branch 23 never executed
branch 24 never executed
branch 25 never executed
branch 26 never executed
branch 27 never executed
branch 28 never executed
branch 29 never executed
branch 30 never executed
branch 31 never executed
branch 32 never executed
branch 33 never executed
branch 34 never executed
branch 35 never executed
branch 36 never executed
branch 37 never executed
branch 38 never executed
branch 39 never executed
branch 40 never executed
branch 41 never executed
branch 42 never executed
branch 43 never executed
branch 44 never executed
branch 45 never executed
        -: 9723:				  break;
        -: 9724:				else
    #####: 9725:				  goto test_do_return;
        -: 9726:			      case OF(re_se_notwordbound,se_notwordbound):
    #####: 9727:				if (!AT_WORD_BOUNDARY (tst_pos))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
branch 21 never executed
branch 22 never executed
branch 23 never executed
branch 24 never executed
branch 25 never executed
branch 26 never executed
branch 27 never executed
branch 28 never executed
branch 29 never executed
branch 30 never executed
branch 31 never executed
branch 32 never executed
branch 33 never executed
branch 34 never executed
branch 35 never executed
branch 36 never executed
branch 37 never executed
branch 38 never executed
branch 39 never executed
branch 40 never executed
branch 41 never executed
branch 42 never executed
branch 43 never executed
branch 44 never executed
branch 45 never executed
        -: 9728:				  break;
        -: 9729:				else
    #####: 9730:				  goto test_do_return;
        -: 9731:			      case OF(re_se_hat,se_hat):
    #####: 9732:				if (AT_STRINGS_BEG ())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -: 9733:				  {
    #####: 9734:				    if (rxb->not_bol)
branch  0 never executed
branch  1 never executed
    #####: 9735:				      goto test_do_return;
        -: 9736:				    else
    #####: 9737:				      break;
        -: 9738:				  }
        -: 9739:				else
        -: 9740:				  {
    #####: 9741:				    char pos_c = *tst_pos;
    #####: 9742:				    if (   (TRANSLATE (pos_c)
    #####: 9743:					    == TRANSLATE('\n'))
branch  0 never executed
branch  1 never executed
    #####: 9744:					&& rxb->newline_anchor)
branch  0 never executed
branch  1 never executed
        -: 9745:				      break;
        -: 9746:				    else
    #####: 9747:				      goto test_do_return;
        -: 9748:				  }
        -: 9749:			      case OF(re_se_dollar,se_dollar):
    #####: 9750:				if (AT_STRINGS_END ())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -: 9751:				  {
    #####: 9752:				    if (rxb->not_eol)
branch  0 never executed
branch  1 never executed
    #####: 9753:				      goto test_do_return;
        -: 9754:				    else
    #####: 9755:				      break;
        -: 9756:				  }
        -: 9757:				else
        -: 9758:				  {
    #####: 9759:				    const unsigned char * next_pos
    #####: 9760:				      = ((string2 && (tst_half == 0) &&
branch  0 never executed
branch  1 never executed
        -: 9761:					  (tst_pos
        -: 9762:					   == ((unsigned char *)
    #####: 9763:					       string1 + size1 - 1)))
branch  0 never executed
branch  1 never executed
        -: 9764:					 ? (unsigned char *)string2
    #####: 9765:					 : tst_pos + 1);
branch  0 never executed
branch  1 never executed
        -: 9766:				    
    #####: 9767:				    if (   (TRANSLATE (*next_pos)
    #####: 9768:					    == TRANSLATE ('\n'))
branch  0 never executed
branch  1 never executed
    #####: 9769:					&& rxb->newline_anchor)
branch  0 never executed
branch  1 never executed
        -: 9770:				      break;
        -: 9771:				    else
    #####: 9772:				      goto test_do_return;
        -: 9773:				  }
        -: 9774:				
        -: 9775:			      case OF(re_se_try,se_try):
        -: 9776:				/* This is the first side effect in every
        -: 9777:				 * expression.
        -: 9778:				 *
        -: 9779:				 *  FOR NO GOOD REASON...get rid of it...
        -: 9780:				 */
    #####: 9781:				break;
        -: 9782:
    #####: 9783:			      case OF(re_se_pushpos,se_pushpos):
        -: 9784:				{
    #####: 9785:				  int urhere =
    #####: 9786:				    ((int)(tst_pos - tst_str_half)
    #####: 9787:				     + ((tst_half == 0) ? 0 : size1));
branch  0 never executed
branch  1 never executed
    #####: 9788:				  struct counter_frame * old_cf
        -: 9789:				    = (counter_stack
        -: 9790:				       ? ((struct counter_frame *)
        -: 9791:					  counter_stack->sp)
    #####: 9792:				       : 0);
branch  0 never executed
branch  1 never executed
        -: 9793:				  struct counter_frame * cf;
    #####: 9794:				  PUSH(counter_stack,
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -: 9795:				       sizeof (struct counter_frame));
    #####: 9796:				  cf = ((struct counter_frame *)
        -: 9797:					counter_stack->sp);
    #####: 9798:				  cf->tag = re_se_pushpos;
    #####: 9799:				  cf->val = urhere;
    #####: 9800:				  cf->inherited_from = 0;
    #####: 9801:				  cf->cdr = old_cf;
    #####: 9802:				  break;
        -: 9803:				}
        -: 9804:				
    #####: 9805:			      case OF(re_se_chkpos,se_chkpos):
        -: 9806:				{
    #####: 9807:				  int urhere =
    #####: 9808:				    ((int)(tst_pos - tst_str_half)
    #####: 9809:				     + ((tst_half == 0) ? 0 : size1));
branch  0 never executed
branch  1 never executed
    #####: 9810:				  struct counter_frame * cf
        -: 9811:				    = ((struct counter_frame *)
        -: 9812:				       counter_stack->sp);
    #####: 9813:				  if (cf->val == urhere)
branch  0 never executed
branch  1 never executed
    #####: 9814:				    goto test_do_return;
    #####: 9815:				  cf->val = urhere;
    #####: 9816:				  break;
        -: 9817:				}
        -: 9818:				break;
        -: 9819:
    #####: 9820:			      case OF(re_se_poppos,se_poppos):
    #####: 9821:				POP(counter_stack,
branch  0 never executed
branch  1 never executed
        -: 9822:				    sizeof (struct counter_frame));
    #####: 9823:				break;
        -: 9824:				
        -: 9825:				
    #####: 9826:			      case OF(re_se_at_dot,se_at_dot):
        -: 9827:			      case OF(re_se_syntax,se_syntax):
        -: 9828:			      case OF(re_se_not_syntax,se_not_syntax):
        -: 9829:#ifdef emacs
        -: 9830:				this release lacks emacs support;
        -: 9831:				(coming soon);
        -: 9832:#endif
    #####: 9833:				break;
    #####: 9834:			      case re_se_win:
        -: 9835:			      case re_se_lparen:
        -: 9836:			      case re_se_rparen:
        -: 9837:			      case re_se_backref:
        -: 9838:			      case re_se_iter:
        -: 9839:			      case re_se_end_iter:
        -: 9840:			      case re_se_tv:
        -: 9841:			      case re_floogle_flap:
    #####: 9842:				ret_val = 0;
    #####: 9843:				goto test_do_return;
        -: 9844:			      }
        -: 9845:			  }
        -: 9846:			else
        -: 9847:			  {
        -: 9848:#ifdef HAVE_GNUC_LABELS
        -: 9849:			    goto *se_lables2[(rxb->se_params [effect].se)];
        -: 9850:#endif
        -: 9851:#ifdef RX_DEBUG
        -: 9852:			  if (rx_debug_trace)
        -: 9853:			    fprintf (stderr, "....%d %d>> %s %d %d\n", line_no,
        -: 9854:				     backtrack_depth,
        -: 9855:				     efnames2[rxb->se_params [effect].se],
        -: 9856:				     rxb->se_params [effect].op1,
        -: 9857:				     rxb->se_params [effect].op2);
        -: 9858:#endif
     8040: 9859:			    switch (rxb->se_params [effect].se)
branch  0 taken 8040
branch  1 taken 0
branch  2 taken 0
branch  3 taken 0
branch  4 taken 0
branch  5 taken 0
branch  6 taken 0
branch  7 taken 0
branch  8 taken 0
        -: 9860:			      {
     8040: 9861:			      case OF(re_se_win,se_win):
        -: 9862:				/* This side effect indicates that we've 
        -: 9863:				 * found a match, though not necessarily the 
        -: 9864:				 * best match.  This is a fancy assignment to 
        -: 9865:				 * register 0 unless the caller didn't 
        -: 9866:				 * care about registers.  In which case,
        -: 9867:				 * this stops the match.
        -: 9868:				 */
        -: 9869:				{
     8040: 9870:				  int urhere =
     8040: 9871:				    ((int)(tst_pos - tst_str_half)
        -: 9872:				     + ((tst_half == 0)
    8040*: 9873:					? 0 : size1));
branch  0 taken 8040 (fallthrough)
branch  1 taken 0
        -: 9874:
     8040: 9875:				  if (   (best_last_r < 0)
branch  0 taken 4564 (fallthrough)
branch  1 taken 3476
     4564: 9876:				      || (urhere + 1 > best_rparen[0]))
branch  0 taken 0 (fallthrough)
branch  1 taken 4564
        -: 9877:				    {
        -: 9878:				      /* Record the best known and keep
        -: 9879:				       * looking.
        -: 9880:				       */
        -: 9881:				      int x;
     6952: 9882:				      for (x = 0; x <= last_l; ++x)
branch  0 taken 3476
branch  1 taken 3476 (fallthrough)
     3476: 9883:					best_lparen[x] = lparen[x];
     3476: 9884:				      best_last_l = last_l;
     6952: 9885:				      for (x = 0; x <= last_r; ++x)
branch  0 taken 3476
branch  1 taken 3476 (fallthrough)
     3476: 9886:					best_rparen[x] = rparen[x];
     3476: 9887:				      best_rparen[0] = urhere + 1;
     3476: 9888:				      best_last_r = last_r;
        -: 9889:				    }
        -: 9890:				  /* If we're not reporting the match-length 
        -: 9891:				   * or other register info, we need look no
        -: 9892:				   * further.
        -: 9893:				   */
     8040: 9894:				  if (first_found)
branch  0 taken 1295 (fallthrough)
branch  1 taken 6745
        -: 9895:				    {
     1295: 9896:				      test_ret = -2;
     1295: 9897:				      goto test_do_return;
        -: 9898:				    }
        -: 9899:				}
     6745: 9900:				break;
    #####: 9901:			      case OF(re_se_lparen,se_lparen):
        -: 9902:				{
    #####: 9903:				  int urhere =
    #####: 9904:				    ((int)(tst_pos - tst_str_half)
    #####: 9905:				     + ((tst_half == 0) ? 0 : size1));
branch  0 never executed
branch  1 never executed
        -: 9906:				  
    #####: 9907:				  int reg = rxb->se_params [effect].op1;
        -: 9908:#if 0
        -: 9909:				  if (reg > last_l)
        -: 9910:#endif
        -: 9911:				    {
    #####: 9912:				      lparen[reg] = urhere + 1;
        -: 9913:				      /* In addition to making this assignment,
        -: 9914:				       * we now know that lower numbered regs
        -: 9915:				       * that haven't already been assigned,
        -: 9916:				       * won't be.  We make sure they're
        -: 9917:				       * filled with -1, so they can be
        -: 9918:				       * recognized as unassigned.
        -: 9919:				       */
    #####: 9920:				      if (last_l < reg)
branch  0 never executed
branch  1 never executed
    #####: 9921:					while (++last_l < reg)
branch  0 never executed
branch  1 never executed
    #####: 9922:					  lparen[last_l] = -1;
        -: 9923:				    }
    #####: 9924:				  break;
        -: 9925:				}
        -: 9926:				
    #####: 9927:			      case OF(re_se_rparen,se_rparen):
        -: 9928:				{
    #####: 9929:				  int urhere =
    #####: 9930:				    ((int)(tst_pos - tst_str_half)
    #####: 9931:				     + ((tst_half == 0) ? 0 : size1));
branch  0 never executed
branch  1 never executed
    #####: 9932:				  int reg = rxb->se_params [effect].op1;
    #####: 9933:				  rparen[reg] = urhere + 1;
    #####: 9934:				  if (last_r < reg)
branch  0 never executed
branch  1 never executed
        -: 9935:				    {
    #####: 9936:				      while (++last_r < reg)
branch  0 never executed
branch  1 never executed
    #####: 9937:					rparen[last_r] = -1;
        -: 9938:				    }
    #####: 9939:				  break;
        -: 9940:				}
        -: 9941:				
    #####: 9942:			      case OF(re_se_backref,se_backref):
        -: 9943:				{
    #####: 9944:				  int reg = rxb->se_params [effect].op1;
    #####: 9945:				  if (reg > last_r || rparen[reg] < 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 9946:				    goto test_do_return;
        -: 9947:				  {
        -: 9948:				    /* fixme */
    #####: 9949:				    const unsigned char * there
    #####: 9950:				      = tst_str_half + lparen[reg];
    #####: 9951:				    const unsigned char * last
    #####: 9952:				      = tst_str_half + rparen[reg];
    #####: 9953:				    const unsigned char * here = tst_pos + 1;
        -: 9954:
    #####: 9955:				    if ((here == tst_end_half) && string2
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 9956:					&& (tst_str_half
branch  0 never executed
branch  1 never executed
        -: 9957:					    == (unsigned char *) string1)
    #####: 9958:					&& (tst_end_half != abs_end))
branch  0 never executed
branch  1 never executed
        -: 9959:				      {
    #####: 9960:					here = (unsigned char *)string2;
    #####: 9961:					tst_end_half = abs_end;
        -: 9962:				      }
        -: 9963:				    
    #####: 9964:				    while (there < last && here < tst_end_half)	/* 4% */
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 9965:				      if (TRANSLATE(*there) /* &&&& 6% */
    #####: 9966:					  != TRANSLATE(*here))
branch  0 never executed
branch  1 never executed
    #####: 9967:					goto test_do_return;
        -: 9968:				      else
        -: 9969:					{
    #####: 9970:					  ++there; ++here;
    #####: 9971:					  if ((here == tst_end_half) && string2
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 9972:					      && (tst_str_half
branch  0 never executed
branch  1 never executed
        -: 9973:						  == (unsigned char *)string1)
    #####: 9974:					      && (tst_end_half != abs_end))
branch  0 never executed
branch  1 never executed
        -: 9975:					    {
    #####: 9976:					      here = (unsigned char *)string2;
    #####: 9977:					      tst_end_half = abs_end;
    #####: 9978:					      tst_half = 1;
        -: 9979:					    }
        -: 9980:					}
    #####: 9981:				    if (there != last)
branch  0 never executed
branch  1 never executed
    #####: 9982:				      goto test_do_return;
    #####: 9983:				    tst_pos = here - 1;
    #####: 9984:				    if ((here == (unsigned char *)string2)
branch  0 never executed
branch  1 never executed
    #####: 9985:					&& (unsigned char *)string1)
branch  0 never executed
branch  1 never executed
        -: 9986:				      {
    #####: 9987:					tst_pos = ((unsigned char *)string1
    #####: 9988:						   + size1 - 1);
    #####: 9989:					tst_end_half = tst_pos + 1;
    #####: 9990:					tst_half = 0;
        -: 9991:				      }
        -: 9992:				  }
    #####: 9993:				  break;
        -: 9994:				}
    #####: 9995:			      case OF(re_se_iter,se_iter):
        -: 9996:				{
    #####: 9997:				  struct counter_frame * csp
        -: 9998:				    = ((struct counter_frame *)
        -: 9999:				       counter_stack->sp);
    #####:10000:				  if (csp->val == rxb->se_params[effect].op2)
branch  0 never executed
branch  1 never executed
    #####:10001:				    goto test_do_return;
        -:10002:				  else
    #####:10003:				    ++csp->val;
    #####:10004:				  break;
        -:10005:				}
    #####:10006:			      case OF(re_se_end_iter,se_end_iter):
        -:10007:				{
    #####:10008:				  struct counter_frame * csp
        -:10009:				    = ((struct counter_frame *)
        -:10010:				       counter_stack->sp);
    #####:10011:				  if (csp->val < rxb->se_params[effect].op1)
branch  0 never executed
branch  1 never executed
    #####:10012:				    goto test_do_return;
        -:10013:				  else
        -:10014:				    {
    #####:10015:				      struct counter_frame * source = csp;
    #####:10016:				      while (source->inherited_from)
branch  0 never executed
branch  1 never executed
    #####:10017:					source = source->inherited_from;
    #####:10018:				      if (!source || !source->cdr)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:10019:					{
    #####:10020:					  POP(counter_stack,
branch  0 never executed
branch  1 never executed
        -:10021:					      sizeof(struct counter_frame));
        -:10022:					}
        -:10023:				      else
        -:10024:					{
    #####:10025:					  source = source->cdr;
    #####:10026:					  csp->val = source->val;
    #####:10027:					  csp->tag = source->tag;
    #####:10028:					  csp->cdr = 0;
    #####:10029:					  csp->inherited_from = source;
        -:10030:					}
        -:10031:				    }
    #####:10032:				  break;
        -:10033:				}
    #####:10034:			      case OF(re_se_tv, se_tv):
        -:10035:				/* is a noop */
    #####:10036:				break;
    #####:10037:			      case re_se_try:
        -:10038:			      case re_se_pushback:
        -:10039:			      case re_se_push0:
        -:10040:			      case re_se_pushpos:
        -:10041:			      case re_se_chkpos:
        -:10042:			      case re_se_poppos:
        -:10043:			      case re_se_at_dot:
        -:10044:			      case re_se_syntax:
        -:10045:			      case re_se_not_syntax:
        -:10046:			      case re_se_begbuf:
        -:10047:			      case re_se_hat:
        -:10048:			      case re_se_wordbeg:
        -:10049:			      case re_se_wordbound:
        -:10050:			      case re_se_notwordbound:
        -:10051:			      case re_se_wordend:
        -:10052:			      case re_se_endbuf:
        -:10053:			      case re_se_dollar:
        -:10054:			      case re_se_fail:
        -:10055:			      case re_floogle_flap:
    #####:10056:				ret_val = 0;
    #####:10057:				goto test_do_return;
        -:10058:			      }
        -:10059:			  }
    10827:10060:			el = el->cdr;
        -:10061:		      }
        -:10062:		    /* Now the side effects are done,
        -:10063:		     * so get the next instruction.
        -:10064:		     * and move on.
        -:10065:		     */
     7215:10066:		    ifr = &df->future_frame;
     7215:10067:		    goto restart;
        -:10068:		  }
        -:10069:		  
     9866:10070:		case OF(rx_backtrack_point,backtrack_point):
        -:10071:		  {
        -:10072:		    /* A backtrack point indicates that we've reached a
        -:10073:		     * non-determinism in the superstate NFA.  This is a
        -:10074:		     * loop that exhaustively searches the possibilities.
        -:10075:		     *
        -:10076:		     * A backtracking strategy is used.  We keep track of what
        -:10077:		     * registers are valid so we can erase side effects.
        -:10078:		     *
        -:10079:		     * First, make sure there is some stack space to hold 
        -:10080:		     * our state.
        -:10081:		     */
        -:10082:
        -:10083:		    struct backtrack_frame * bf;
        -:10084:
    9866*:10085:		    PUSH(backtrack_stack, backtrack_frame_bytes);
branch  0 taken 8356 (fallthrough)
branch  1 taken 1510
branch  2 taken 2 (fallthrough)
branch  3 taken 8354
branch  4 taken 0 (fallthrough)
branch  5 taken 1512
branch  6 taken 0 (fallthrough)
branch  7 taken 1512
        -:10086:#ifdef RX_DEBUG
        -:10087:		    ++backtrack_depth;
        -:10088:#endif
        -:10089:
     9866:10090:		    bf = ((struct backtrack_frame *)
        -:10091:			  backtrack_stack->sp);
        -:10092:		    {
     9866:10093:		      bf->stk_super = super;
        -:10094:		      /* We prevent the current superstate from being
        -:10095:		       * deleted from the superstate cache.
        -:10096:		       */
     9866:10097:		      rx_lock_superstate (&rxb->rx, super);
     9866:10098:		      bf->stk_tst_pos = tst_pos;
        -:10099:#ifdef RX_DEBUG
        -:10100:		      bf->stk_line_no = line_no;
        -:10101:#endif
     9866:10102:		      bf->stk_tst_half = tst_half;
     9866:10103:		      bf->stk_c = c;
     9866:10104:		      bf->stk_tst_str_half = tst_str_half;
     9866:10105:		      bf->stk_tst_end_half = tst_end_half;
     9866:10106:		      bf->stk_last_l = last_l;
     9866:10107:		      bf->stk_last_r = last_r;
     9866:10108:		      bf->df = ((struct rx_super_edge *)ifr->data_2)->options;
     9866:10109:		      bf->first_df = bf->df;
     9866:10110:		      bf->counter_stack_sp = (counter_stack
        -:10111:					      ? counter_stack->sp
    9866*:10112:					      : 0);
branch  0 taken 0 (fallthrough)
branch  1 taken 9866
     9866:10113:		      bf->stk_test_ret = test_ret;
     9866:10114:		      if (rxb->match_regs_on_stack)
branch  0 taken 9866 (fallthrough)
branch  1 taken 0
        -:10115:			{
        -:10116:			  int x;
    #####:10117:			  regoff_t * stk =
        -:10118:			    (regoff_t *)((char *)bf + sizeof (*bf));
    #####:10119:			  for (x = 0; x <= last_l; ++x)
branch  0 never executed
branch  1 never executed
    #####:10120:			    stk[x] = lparen[x];
    #####:10121:			  stk += x;
    #####:10122:			  for (x = 0; x <= last_r; ++x)
branch  0 never executed
branch  1 never executed
    #####:10123:			    stk[x] = rparen[x];
        -:10124:			}
        -:10125:
        -:10126:		    }
        -:10127:
        -:10128:		    /* Here is a while loop whose body is mainly a function
        -:10129:		     * call and some code to handle a return from that
        -:10130:		     * function.
        -:10131:		     *
        -:10132:		     * From here on for the rest of `case backtrack_point' it
        -:10133:		     * is unsafe to assume that the variables saved on the
        -:10134:		     * stack are valid -- so reread their values from the stack
        -:10135:		     * as needed.
        -:10136:		     *
        -:10137:		     * This lets us re-use one generation fewer stack saves in
        -:10138:		     * the call-graph of a search.
        -:10139:		     */
        -:10140:		    
    9866*:10141:		  while_non_det_options:
        -:10142:#ifdef RX_DEBUG
        -:10143:		    ++lines_found;
        -:10144:		    if (rx_debug_trace)
        -:10145:		      fprintf (stderr, "@@@ %d calls %d @@@\n",
        -:10146:			       line_no, lines_found);
        -:10147:		    
        -:10148:		    line_no = lines_found;
        -:10149:#endif
        -:10150:		    
    17048:10151:		    if (bf->df->next_same_super_edge[0] == bf->first_df)
branch  0 taken 7182 (fallthrough)
branch  1 taken 9866
        -:10152:		      {
        -:10153:			/* This is a tail-call optimization -- we don't recurse
        -:10154:			 * for the last of the possible futures.
        -:10155:			 */
    14364:10156:			ifr = (bf->df->effects
     7182:10157:			       ? &bf->df->side_effects_frame
    7182*:10158:			       : &bf->df->future_frame);
branch  0 taken 7182 (fallthrough)
branch  1 taken 0
        -:10159:
     7182:10160:			rx_unlock_superstate (&rxb->rx, super);
     7182:10161:			POP(backtrack_stack, backtrack_frame_bytes);
branch  0 taken 1393 (fallthrough)
branch  1 taken 5789
        -:10162:#ifdef RX_DEBUG
        -:10163:			--backtrack_depth;
        -:10164:#endif
     7182:10165:			goto restart;
        -:10166:		      }
        -:10167:		    else
        -:10168:		      {
     9866:10169:			if (counter_stack)
branch  0 taken 0 (fallthrough)
branch  1 taken 9866
        -:10170:			  {
    #####:10171:			    struct counter_frame * old_cf
        -:10172:			      = ((struct counter_frame *)counter_stack->sp);
        -:10173:			    struct counter_frame * cf;
    #####:10174:			    PUSH(counter_stack, sizeof (struct counter_frame));
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:10175:			    cf = ((struct counter_frame *)counter_stack->sp);
    #####:10176:			    cf->tag = old_cf->tag;
    #####:10177:			    cf->val = old_cf->val;
    #####:10178:			    cf->inherited_from = old_cf;
    #####:10179:			    cf->cdr = 0;
        -:10180:			  }			
        -:10181:			/* `Call' this test-match block */
    19732:10182:			ifr = (bf->df->effects
    #####:10183:			       ? &bf->df->side_effects_frame
    9866*:10184:			       : &bf->df->future_frame);
branch  0 taken 0 (fallthrough)
branch  1 taken 9866
     9866:10185:			goto recurse_test_match;
        -:10186:		      }
        -:10187:
        -:10188:		    /* Returns in this block are accomplished by
        -:10189:		     * goto test_do_return.  There are two cases.
        -:10190:		     * If there is some search-stack left,
        -:10191:		     * then it is a return from a `recursive' call.
        -:10192:		     * If there is no search-stack left, then
        -:10193:		     * we should return to the fastmap/search loop.
        -:10194:		     */
        -:10195:		    
    34466:10196:		  test_do_return:
        -:10197:
    34466:10198:		    if (!backtrack_stack)
branch  0 taken 24600 (fallthrough)
branch  1 taken 9866
        -:10199:		      {
        -:10200:#ifdef RX_DEBUG
        -:10201:			if (rx_debug_trace)
        -:10202:			  fprintf (stderr, "!!! %d bails returning %d !!!\n",
        -:10203:				   line_no, test_ret);
        -:10204:#endif
        -:10205:
        -:10206:			/* No more search-stack -- this test is done. */
    24600:10207:			if (test_ret)
branch  0 taken 24600 (fallthrough)
branch  1 taken 0
    24600:10208:			  goto return_from_test_match;
        -:10209:			else
    #####:10210:			  goto error_in_testing_match;
        -:10211:		      }
        -:10212:
        -:10213:		    /* Ok..we're returning from a recursive call to 
        -:10214:		     * the test match block:
        -:10215:		     */
        -:10216:		    
     9866:10217:		    bf = ((struct backtrack_frame *)
        -:10218:			  backtrack_stack->sp);
        -:10219:#ifdef RX_DEBUG
        -:10220:		    if (rx_debug_trace)
        -:10221:		      fprintf (stderr, "+++ %d returns %d (to %d)+++\n",
        -:10222:			       line_no, test_ret, bf->stk_line_no);
        -:10223:#endif
        -:10224:
     9866:10225:		    while (counter_stack
    9866*:10226:			   && (!bf->counter_stack_sp
branch  0 taken 0 (fallthrough)
branch  1 taken 9866
branch  2 never executed
branch  3 never executed
    #####:10227:			       || (bf->counter_stack_sp != counter_stack->sp)))
branch  0 never executed
branch  1 never executed
        -:10228:		      {
    #####:10229:			POP(counter_stack, sizeof (struct counter_frame));
branch  0 never executed
branch  1 never executed
        -:10230:		      }
        -:10231:
     9866:10232:		    if (!test_ret)
branch  0 taken 0 (fallthrough)
branch  1 taken 9866
        -:10233:		      {
    #####:10234:			POP (backtrack_stack, backtrack_frame_bytes);
branch  0 never executed
branch  1 never executed
    #####:10235:			goto test_do_return;
        -:10236:		      }
        -:10237:
        -:10238:		    /* If any possible future reaches the end of the 
        -:10239:		     * string without failing, make sure we propogate 
        -:10240:		     * that information to the caller.
        -:10241:		     */
     9866:10242:		    if ((test_ret == -2) && first_found)
branch  0 taken 2684 (fallthrough)
branch  1 taken 7182
branch  2 taken 2684 (fallthrough)
branch  3 taken 0
        -:10243:		      {
     2684:10244:			rx_unlock_superstate (&rxb->rx, bf->stk_super);
     2684:10245:			POP (backtrack_stack, backtrack_frame_bytes);
branch  0 taken 119 (fallthrough)
branch  1 taken 2565
     2684:10246:			goto test_do_return;
        -:10247:		      }
        -:10248:
     7182:10249:		    if (bf->stk_test_ret < 0)
branch  0 taken 7182 (fallthrough)
branch  1 taken 0
     7182:10250:		      test_ret = bf->stk_test_ret;
        -:10251:
     7182:10252:		    last_l = bf->stk_last_l;
     7182:10253:		    last_r = bf->stk_last_r;
     7182:10254:		    bf->df = bf->df->next_same_super_edge[0];
     7182:10255:		    super = bf->stk_super;
     7182:10256:		    tst_pos = bf->stk_tst_pos;
     7182:10257:		    tst_half = bf->stk_tst_half;
     7182:10258:		    c = bf->stk_c;
     7182:10259:		    tst_str_half = bf->stk_tst_str_half;
     7182:10260:		    tst_end_half = bf->stk_tst_end_half;
        -:10261:#ifdef RX_DEBUG
        -:10262:		    line_no = bf->stk_line_no;
        -:10263:#endif
        -:10264:
     7182:10265:		    if (rxb->match_regs_on_stack)
branch  0 taken 0 (fallthrough)
branch  1 taken 7182
        -:10266:		      {
        -:10267:			int x;
    #####:10268:			regoff_t * stk =
        -:10269:			  (regoff_t *)((char *)bf + sizeof (*bf));
    #####:10270:			for (x = 0; x <= last_l; ++x)
branch  0 never executed
branch  1 never executed
    #####:10271:			  lparen[x] = stk[x];
    #####:10272:			stk += x;
    #####:10273:			for (x = 0; x <= last_r; ++x)
branch  0 never executed
branch  1 never executed
    #####:10274:			  rparen[x] = stk[x];
        -:10275:		      }
        -:10276:
     7182:10277:		    goto while_non_det_options;
        -:10278:		  }
        -:10279:
        -:10280:		  
     1237:10281:		case OF(rx_cache_miss,cache_miss):
        -:10282:		  /* Because the superstate NFA is lazily constructed,
        -:10283:		   * and in fact may erode from underneath us, we sometimes
        -:10284:		   * have to construct the next instruction from the hard way.
        -:10285:		   * This invokes one step in the lazy-conversion.
        -:10286:		   */
     1237:10287:		  ifr = rx_handle_cache_miss (&rxb->rx, super, c, ifr->data_2);
call    0 returned 1237
     1237:10288:		  if (!ifr)
branch  0 taken 0 (fallthrough)
branch  1 taken 1237
        -:10289:		    {
    #####:10290:		      test_ret = 0;
    #####:10291:		      goto test_do_return;
        -:10292:		    }
     1237:10293:		  goto restart;
        -:10294:		  
     7771:10295:		case OF(rx_backtrack,backtrack):
        -:10296:		  /* RX_BACKTRACK means that we've reached the empty
        -:10297:		   * superstate, indicating that match can't succeed
        -:10298:		   * from this point.
        -:10299:		   */
     7771:10300:		  goto test_do_return;
    #####:10301:		case rx_next_char:
        -:10302:		case rx_error_inx:
        -:10303:		case rx_num_instructions:
    #####:10304:		  ret_val = 0;
    #####:10305:		  goto test_do_return;
        -:10306:		}
        -:10307:	    }
        -:10308:	}
        -:10309:
        -:10310:
        -:10311:	/* Healthy exists from the test-match loop do a 
        -:10312:	 * `goto return_from_test_match'   On the other hand, 
        -:10313:	 * we might end up here.
        -:10314:	 */
    #####:10315:      error_in_testing_match:
    #####:10316:	ret_val = -2;
    #####:10317:	goto finish;
        -:10318:
        -:10319:
        -:10320:	/***** fastmap/search loop body
        -:10321:	 *	      considering the results testing for a match
        -:10322:	 */
        -:10323:
    24600:10324:      return_from_test_match:
        -:10325:
    24600:10326:	if (best_last_l >= 0)
branch  0 taken 3476 (fallthrough)
branch  1 taken 21124
        -:10327:	  {
     3476:10328:	    if (regs && (regs->start != best_lparen))
branch  0 taken 2181 (fallthrough)
branch  1 taken 1295
branch  2 taken 0 (fallthrough)
branch  3 taken 2181
        -:10329:	      {
    #####:10330:		bcopy (best_lparen, regs->start,
        -:10331:		       regs->num_regs * sizeof (int));
    #####:10332:		bcopy (best_rparen, regs->end,
        -:10333:		       regs->num_regs * sizeof (int));
        -:10334:	      }
     3476:10335:	    if (regs && !rxb->no_sub)
branch  0 taken 2181 (fallthrough)
branch  1 taken 1295
branch  2 taken 2181 (fallthrough)
branch  3 taken 0
        -:10336:	      {
        -:10337:		int q;
     2181:10338:		int bound = (regs->num_regs > num_regs
        -:10339:			     ? regs->num_regs
     2181:10340:			     : num_regs);
     2181:10341:		regoff_t * s = regs->start;
     2181:10342:		regoff_t * e = regs->end;
    65430:10343:		for (q = best_last_l + 1;  q < bound; ++q)
branch  0 taken 63249
branch  1 taken 2181 (fallthrough)
    63249:10344:		  s[q] = e[q] = -1;
        -:10345:	      }
     3476:10346:	    ret_val = best_lparen[0];
     3476:10347:	    goto finish;
        -:10348:	  }
        -:10349:
        -:10350:	/***** fastmap/search loop,  increment and loop-test */
        -:10351:
    21124:10352:	pos += search_direction;
    21124:10353:	startpos += search_direction;
        -:10354:
    21124:10355:      } while (startpos < search_end);
branch  0 taken 8934
branch  1 taken 12190 (fallthrough)
        -:10356:
        -:10357:
        -:10358:  /**** Exit code for fastmap/searchloop and the entire re_search_2 fn. */
        -:10359:
    12190:10360:  finish:
        -:10361:    /* Unset the fastmap sentinel */
    15722:10362:    if (fastmap_chr >= 0)
branch  0 taken 11309 (fallthrough)
branch  1 taken 4413
    11309:10363:      fastmap[fastmap_chr] = fastmap_val;
        -:10364:
    15722:10365:    if (start_super)
branch  0 taken 15722 (fallthrough)
branch  1 taken 0
    15722:10366:      rx_unlock_superstate (&rxb->rx, start_super);
        -:10367:
        -:10368:#ifdef REGEX_MALLOC
        -:10369:    if (lparen) free (lparen);
        -:10370:    if (rparen) free (rparen);
        -:10371:    if (best_lpspace) free (best_lpspace);
        -:10372:    if (best_rpspace) free (best_rpspace);
        -:10373:#endif
    15722:10374:    return ret_val;
        -:10375:  }
        -:10376:}
        -:10377:
        -:10378:#if !defined(REGEX_MALLOC) && !defined(__GNUC__)
        -:10379:#ifdef __STDC__
        -:10380:int
        -:10381:re_search_2 (struct re_pattern_buffer *rxb,
        -:10382:	     const char * string1, int size1,
        -:10383:	     const char * string2, int size2,
        -:10384:	     int startpos, int range,
        -:10385:	     struct re_registers *regs,
        -:10386:	     int stop)
        -:10387:#else
        -:10388:int
        -:10389:re_search_2 (rxb, string1, size1, string2, size2, startpos, range, regs, stop)
        -:10390:     struct re_pattern_buffer *rxb;
        -:10391:     const char * string1;
        -:10392:     int size1;
        -:10393:     const char * string2;
        -:10394:     int size2;
        -:10395:     int startpos;
        -:10396:     int range;
        -:10397:     struct re_registers *regs;
        -:10398:     int stop;
        -:10399:#endif
        -:10400:{
        -:10401:  int ret;
        -:10402:  ret = inner_re_search_2 (rxb, string1, size1, string2, size2, startpos,
        -:10403:			   range, regs, stop);
        -:10404:  alloca (0);
        -:10405:  return ret;
        -:10406:}
        -:10407:#endif
        -:10408:
        -:10409:
        -:10410:/* Like re_search_2, above, but only one string is specified, and
        -:10411: * doesn't let you say where to stop matching.
        -:10412: */
        -:10413:
        -:10414:#ifdef __STDC__
        -:10415:int
function re_search called 16193 returned 100% blocks executed 100%
    16193:10416:re_search (struct re_pattern_buffer * rxb, const char *string,
        -:10417:	   int size, int startpos, int range,
        -:10418:	   struct re_registers *regs)
        -:10419:#else
        -:10420:int
        -:10421:re_search (rxb, string, size, startpos, range, regs)
        -:10422:     struct re_pattern_buffer * rxb;
        -:10423:     const char * string;
        -:10424:     int size;
        -:10425:     int startpos;
        -:10426:     int range;
        -:10427:     struct re_registers *regs;
        -:10428:#endif
        -:10429:{
    16193:10430:  return re_search_2 (rxb, 0, 0, string, size, startpos, range, regs, size);
call    0 returned 16193
        -:10431:}
        -:10432:
        -:10433:#ifdef __STDC__
        -:10434:int
function re_match_2 called 0 returned 0% blocks executed 0%
    #####:10435:re_match_2 (struct re_pattern_buffer * rxb,
        -:10436:	    const char * string1, int size1,
        -:10437:	    const char * string2, int size2,
        -:10438:	    int pos, struct re_registers *regs, int stop)
        -:10439:#else
        -:10440:int
        -:10441:re_match_2 (rxb, string1, size1, string2, size2, pos, regs, stop)
        -:10442:     struct re_pattern_buffer * rxb;
        -:10443:     const char * string1;
        -:10444:     int size1;
        -:10445:     const char * string2;
        -:10446:     int size2;
        -:10447:     int pos;
        -:10448:     struct re_registers *regs;
        -:10449:     int stop;
        -:10450:#endif
        -:10451:{
        -:10452:  struct re_registers some_regs;
        -:10453:  regoff_t start;
        -:10454:  regoff_t end;
        -:10455:  int srch;
    #####:10456:  int save = rxb->regs_allocated;
    #####:10457:  struct re_registers * regs_to_pass = regs;
        -:10458:
    #####:10459:  if (!regs)
branch  0 never executed
branch  1 never executed
        -:10460:    {
    #####:10461:      some_regs.start = &start;
    #####:10462:      some_regs.end = &end;
    #####:10463:      some_regs.num_regs = 1;
    #####:10464:      regs_to_pass = &some_regs;
    #####:10465:      rxb->regs_allocated = REGS_FIXED;
        -:10466:    }
        -:10467:
    #####:10468:  srch = re_search_2 (rxb, string1, size1, string2, size2,
call    0 never executed
        -:10469:		      pos, 1, regs_to_pass, stop);
    #####:10470:  if (regs_to_pass != regs)
branch  0 never executed
branch  1 never executed
    #####:10471:    rxb->regs_allocated = save;
    #####:10472:  if (srch < 0)
branch  0 never executed
branch  1 never executed
    #####:10473:    return srch;
    #####:10474:  return regs_to_pass->end[0] - regs_to_pass->start[0];
        -:10475:}
        -:10476:
        -:10477:/* re_match is like re_match_2 except it takes only a single string.  */
        -:10478:
        -:10479:#ifdef __STDC__
        -:10480:int
function re_match called 0 returned 0% blocks executed 0%
    #####:10481:re_match (struct re_pattern_buffer * rxb,
        -:10482:	  const char * string,
        -:10483:	  int size, int pos,
        -:10484:	  struct re_registers *regs)
        -:10485:#else
        -:10486:int
        -:10487:re_match (rxb, string, size, pos, regs)
        -:10488:     struct re_pattern_buffer * rxb;
        -:10489:     const char *string;
        -:10490:     int size;
        -:10491:     int pos;
        -:10492:     struct re_registers *regs;
        -:10493:#endif
        -:10494:{
    #####:10495:  return re_match_2 (rxb, string, size, 0, 0, pos, regs, size);
call    0 never executed
        -:10496:}
        -:10497:
        -:10498:
        -:10499:
        -:10500:/* Set by `re_set_syntax' to the current regexp syntax to recognize.  Can
        -:10501:   also be assigned to arbitrarily: each pattern buffer stores its own
        -:10502:   syntax, so it can be changed between regex compilations.  */
        -:10503:reg_syntax_t re_syntax_options = RE_SYNTAX_EMACS;
        -:10504:
        -:10505:
        -:10506:/* Specify the precise syntax of regexps for compilation.  This provides
        -:10507:   for compatibility for various utilities which historically have
        -:10508:   different, incompatible syntaxes.
        -:10509:
        -:10510:   The argument SYNTAX is a bit mask comprised of the various bits
        -:10511:   defined in regex.h.  We return the old syntax.  */
        -:10512:
        -:10513:#ifdef __STDC__
        -:10514:reg_syntax_t
function re_set_syntax called 191 returned 100% blocks executed 100%
      191:10515:re_set_syntax (reg_syntax_t syntax)
        -:10516:#else
        -:10517:reg_syntax_t
        -:10518:re_set_syntax (syntax)
        -:10519:    reg_syntax_t syntax;
        -:10520:#endif
        -:10521:{
      191:10522:  reg_syntax_t ret = re_syntax_options;
        -:10523:
      191:10524:  re_syntax_options = syntax;
      191:10525:  return ret;
        -:10526:}
        -:10527:
        -:10528:
        -:10529:/* Set REGS to hold NUM_REGS registers, storing them in STARTS and
        -:10530:   ENDS.  Subsequent matches using PATTERN_BUFFER and REGS will use
        -:10531:   this memory for recording register information.  STARTS and ENDS
        -:10532:   must be allocated using the malloc library routine, and must each
        -:10533:   be at least NUM_REGS * sizeof (regoff_t) bytes long.
        -:10534:
        -:10535:   If NUM_REGS == 0, then subsequent matches should allocate their own
        -:10536:   register data.
        -:10537:
        -:10538:   Unless this function is called, the first search or match using
        -:10539:   PATTERN_BUFFER will allocate its own register data, without
        -:10540:   freeing the old data.  */
        -:10541:
        -:10542:#ifdef __STDC__
        -:10543:void
function re_set_registers called 0 returned 0% blocks executed 0%
    #####:10544:re_set_registers (struct re_pattern_buffer *bufp,
        -:10545:		  struct re_registers *regs,
        -:10546:		  unsigned num_regs,
        -:10547:		  regoff_t * starts, regoff_t * ends)
        -:10548:#else
        -:10549:void
        -:10550:re_set_registers (bufp, regs, num_regs, starts, ends)
        -:10551:     struct re_pattern_buffer *bufp;
        -:10552:     struct re_registers *regs;
        -:10553:     unsigned num_regs;
        -:10554:     regoff_t * starts;
        -:10555:     regoff_t * ends;
        -:10556:#endif
        -:10557:{
    #####:10558:  if (num_regs)
branch  0 never executed
branch  1 never executed
        -:10559:    {
    #####:10560:      bufp->regs_allocated = REGS_REALLOCATE;
    #####:10561:      regs->num_regs = num_regs;
    #####:10562:      regs->start = starts;
    #####:10563:      regs->end = ends;
        -:10564:    }
        -:10565:  else
        -:10566:    {
    #####:10567:      bufp->regs_allocated = REGS_UNALLOCATED;
    #####:10568:      regs->num_regs = 0;
    #####:10569:      regs->start = regs->end = (regoff_t) 0;
        -:10570:    }
    #####:10571:}
        -:10572:
        -:10573:
        -:10574:
        -:10575:
        -:10576:#ifdef __STDC__
        -:10577:static int 
function cplx_se_sublist_len called 130 returned 100% blocks executed 100%
      130:10578:cplx_se_sublist_len (struct rx_se_list * list)
        -:10579:#else
        -:10580:static int 
        -:10581:cplx_se_sublist_len (list)
        -:10582:     struct rx_se_list * list;
        -:10583:#endif
        -:10584:{
      130:10585:  int x = 0;
      198:10586:  while (list)
branch  0 taken 68
branch  1 taken 130 (fallthrough)
        -:10587:    {
       68:10588:      if ((int)list->car >= 0)
branch  0 taken 65 (fallthrough)
branch  1 taken 3
       65:10589:	++x;
       68:10590:      list = list->cdr;
        -:10591:    }
      130:10592:  return x;
        -:10593:}
        -:10594:
        -:10595:
        -:10596:/* For rx->se_list_cmp */
        -:10597:
        -:10598:#ifdef __STDC__
        -:10599:static int 
function posix_se_list_order called 65 returned 100% blocks executed 20%
       65:10600:posix_se_list_order (struct rx * rx,
        -:10601:		     struct rx_se_list * a, struct rx_se_list * b)
        -:10602:#else
        -:10603:static int 
        -:10604:posix_se_list_order (rx, a, b)
        -:10605:     struct rx * rx;
        -:10606:     struct rx_se_list * a;
        -:10607:     struct rx_se_list * b;
        -:10608:#endif
        -:10609:{
       65:10610:  int al = cplx_se_sublist_len (a);
call    0 returned 65
       65:10611:  int bl = cplx_se_sublist_len (b);
call    0 returned 65
        -:10612:
       65:10613:  if (!al && !bl)
branch  0 taken 65 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 65
        -:10614:    return ((a == b)
        -:10615:	    ? 0
    #####:10616:	    : ((a < b) ? -1 : 1));
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:10617:  
       65:10618:  else if (!al)
branch  0 taken 65 (fallthrough)
branch  1 taken 0
       65:10619:    return -1;
        -:10620:
    #####:10621:  else if (!bl)
branch  0 never executed
branch  1 never executed
    #####:10622:    return 1;
        -:10623:
        -:10624:  else
        -:10625:    {
        -:10626:      rx_side_effect * av = ((rx_side_effect *)
    #####:10627:			     alloca (sizeof (rx_side_effect) * (al + 1)));
        -:10628:      rx_side_effect * bv = ((rx_side_effect *)
    #####:10629:			     alloca (sizeof (rx_side_effect) * (bl + 1)));
    #####:10630:      struct rx_se_list * ap = a;
    #####:10631:      struct rx_se_list * bp = b;
        -:10632:      int ai, bi;
        -:10633:      
    #####:10634:      for (ai = al - 1; ai >= 0; --ai)
branch  0 never executed
branch  1 never executed
        -:10635:	{
    #####:10636:	  while ((int)ap->car < 0)
branch  0 never executed
branch  1 never executed
    #####:10637:	    ap = ap->cdr;
    #####:10638:	  av[ai] = ap->car;
    #####:10639:	  ap = ap->cdr;
        -:10640:	}
    #####:10641:      av[al] = (rx_side_effect)-2;
    #####:10642:      for (bi = bl - 1; bi >= 0; --bi)
branch  0 never executed
branch  1 never executed
        -:10643:	{
    #####:10644:	  while ((int)bp->car < 0)
branch  0 never executed
branch  1 never executed
    #####:10645:	    bp = bp->cdr;
    #####:10646:	  bv[bi] = bp->car;
    #####:10647:	  bp = bp->cdr;
        -:10648:	}
    #####:10649:      bv[bl] = (rx_side_effect)-1;
        -:10650:
        -:10651:      {
        -:10652:	int ret;
    #####:10653:	int x = 0;
    #####:10654:	while (av[x] == bv[x])
branch  0 never executed
branch  1 never executed
    #####:10655:	  ++x;
    #####:10656:	ret = ((av[x] < bv[x]) ? -1 : 1);
branch  0 never executed
branch  1 never executed
    #####:10657:	return ret;
        -:10658:      }
        -:10659:    }
        -:10660:}
        -:10661:
        -:10662:
        -:10663:
        -:10664:
        -:10665:/* re_compile_pattern is the GNU regular expression compiler: it
        -:10666:   compiles PATTERN (of length SIZE) and puts the result in RXB.
        -:10667:   Returns 0 if the pattern was valid, otherwise an error string.
        -:10668:
        -:10669:   Assumes the `allocated' (and perhaps `buffer') and `translate' fields
        -:10670:   are set in RXB on entry.
        -:10671:
        -:10672:   We call rx_compile to do the actual compilation.  */
        -:10673:
        -:10674:#ifdef __STDC__
        -:10675:const char *
function re_compile_pattern called 232 returned 100% blocks executed 100%
      232:10676:re_compile_pattern (const char *pattern,
        -:10677:		    int length,
        -:10678:		    struct re_pattern_buffer * rxb)
        -:10679:#else
        -:10680:const char *
        -:10681:re_compile_pattern (pattern, length, rxb)
        -:10682:     const char *pattern;
        -:10683:     int length;
        -:10684:     struct re_pattern_buffer * rxb;
        -:10685:#endif
        -:10686:{
        -:10687:  reg_errcode_t ret;
        -:10688:
        -:10689:  /* GNU code is written to assume at least RE_NREGS registers will be set
        -:10690:     (and at least one extra will be -1).  */
      232:10691:  rxb->regs_allocated = REGS_UNALLOCATED;
        -:10692:
        -:10693:  /* And GNU code determines whether or not to get register information
        -:10694:     by passing null for the REGS argument to re_match, etc., not by
        -:10695:     setting no_sub.  */
      232:10696:  rxb->no_sub = 0;
        -:10697:
      232:10698:  rxb->rx.local_cset_size = 256;
        -:10699:
        -:10700:  /* Match anchors at newline.  */
      232:10701:  rxb->newline_anchor = 1;
        -:10702: 
      232:10703:  rxb->re_nsub = 0;
      232:10704:  rxb->start = 0;
      232:10705:  rxb->se_params = 0;
      232:10706:  rxb->rx.nodec = 0;
      232:10707:  rxb->rx.epsnodec = 0;
      232:10708:  rxb->rx.instruction_table = 0;
      232:10709:  rxb->rx.nfa_states = 0;
      232:10710:  rxb->rx.se_list_cmp = posix_se_list_order;
      232:10711:  rxb->rx.start_set = 0;
        -:10712:
      232:10713:  ret = rx_compile (pattern, length, re_syntax_options, rxb);
call    0 returned 232
      232:10714:  alloca (0);
      232:10715:  return rx_error_msg[(int) ret];
        -:10716:}
        -:10717:
        -:10718:
        -:10719:
        -:10720:#ifdef __STDC__
        -:10721:int
function re_compile_fastmap called 0 returned 0% blocks executed 0%
    #####:10722:re_compile_fastmap (struct re_pattern_buffer * rxb)
        -:10723:#else
        -:10724:int
        -:10725:re_compile_fastmap (rxb)
        -:10726:     struct re_pattern_buffer * rxb;
        -:10727:#endif
        -:10728:{
    #####:10729:  rx_blow_up_fastmap (rxb);
call    0 never executed
    #####:10730:  return 0;
        -:10731:}
        -:10732:
        -:10733:
        -:10734:
        -:10735:
        -:10736:/* Entry points compatible with 4.2 BSD regex library.  We don't define
        -:10737:   them if this is an Emacs or POSIX compilation.  */
        -:10738:
        -:10739:#if !defined (emacs) && !defined (_POSIX_SOURCE) && 0
        -:10740:
        -:10741:/* BSD has one and only one pattern buffer.  */
        -:10742:static struct re_pattern_buffer rx_comp_buf;
        -:10743:
        -:10744:#ifdef __STDC__
        -:10745:char *
        -:10746:re_comp (const char *s)
        -:10747:#else
        -:10748:char *
        -:10749:re_comp (s)
        -:10750:    const char *s;
        -:10751:#endif
        -:10752:{
        -:10753:  reg_errcode_t ret;
        -:10754:
        -:10755:  if (!s)
        -:10756:    {
        -:10757:      if (!rx_comp_buf.buffer)
        -:10758:	return "No previous regular expression";
        -:10759:      return 0;
        -:10760:    }
        -:10761:
        -:10762:  if (!rx_comp_buf.fastmap)
        -:10763:    {
        -:10764:      rx_comp_buf.fastmap = (char *) malloc (1 << BYTEWIDTH);
        -:10765:      if (!rx_comp_buf.fastmap)
        -:10766:	return "Memory exhausted";
        -:10767:    }
        -:10768:
        -:10769:  /* Since `rx_exec' always passes NULL for the `regs' argument, we
        -:10770:     don't need to initialize the pattern buffer fields which affect it.  */
        -:10771:
        -:10772:  /* Match anchors at newlines.  */
        -:10773:  rx_comp_buf.newline_anchor = 1;
        -:10774:
        -:10775:  rx_comp_buf.re_nsub = 0;
        -:10776:  rx_comp_buf.start = 0;
        -:10777:  rx_comp_buf.se_params = 0;
        -:10778:  rx_comp_buf.rx.nodec = 0;
        -:10779:  rx_comp_buf.rx.epsnodec = 0;
        -:10780:  rx_comp_buf.rx.instruction_table = 0;
        -:10781:  rx_comp_buf.rx.nfa_states = 0;
        -:10782:  rx_comp_buf.rx.start = 0;
        -:10783:  rx_comp_buf.rx.se_list_cmp = posix_se_list_order;
        -:10784:
        -:10785:  ret = rx_compile (s, strlen (s), rx_syntax_options, &rx_comp_buf);
        -:10786:  alloca (0);
        -:10787:
        -:10788:  /* Yes, we're discarding `const' here.  */
        -:10789:  return (char *) rx_error_msg[(int) ret];
        -:10790:}
        -:10791:
        -:10792:
        -:10793:#ifdef __STDC__
        -:10794:int
        -:10795:rx_exec (const char *s)
        -:10796:#else
        -:10797:int
        -:10798:rx_exec (s)
        -:10799:    const char *s;
        -:10800:#endif
        -:10801:{
        -:10802:  const int len = strlen (s);
        -:10803:  return
        -:10804:    0 <= re_search (&rx_comp_buf, s, len, 0, len, (struct rx_registers *) 0);
        -:10805:}
        -:10806:#endif /* not emacs and not _POSIX_SOURCE */
        -:10807:
        -:10808:
        -:10809:
        -:10810:/* POSIX.2 functions.  Don't define these for Emacs.  */
        -:10811:
        -:10812:#if !defined(emacs)
        -:10813:
        -:10814:/* regcomp takes a regular expression as a string and compiles it.
        -:10815:
        -:10816:   PREG is a regex_t *.  We do not expect any fields to be initialized,
        -:10817:   since POSIX says we shouldn't.  Thus, we set
        -:10818:
        -:10819:     `buffer' to the compiled pattern;
        -:10820:     `used' to the length of the compiled pattern;
        -:10821:     `syntax' to RE_SYNTAX_POSIX_EXTENDED if the
        -:10822:       REG_EXTENDED bit in CFLAGS is set; otherwise, to
        -:10823:       RE_SYNTAX_POSIX_BASIC;
        -:10824:     `newline_anchor' to REG_NEWLINE being set in CFLAGS;
        -:10825:     `fastmap' and `fastmap_accurate' to zero;
        -:10826:     `re_nsub' to the number of subexpressions in PATTERN.
        -:10827:
        -:10828:   PATTERN is the address of the pattern string.
        -:10829:
        -:10830:   CFLAGS is a series of bits which affect compilation.
        -:10831:
        -:10832:     If REG_EXTENDED is set, we use POSIX extended syntax; otherwise, we
        -:10833:     use POSIX basic syntax.
        -:10834:
        -:10835:     If REG_NEWLINE is set, then . and [^...] don't match newline.
        -:10836:     Also, regexec will try a match beginning after every newline.
        -:10837:
        -:10838:     If REG_ICASE is set, then we considers upper- and lowercase
        -:10839:     versions of letters to be equivalent when matching.
        -:10840:
        -:10841:     If REG_NOSUB is set, then when PREG is passed to regexec, that
        -:10842:     routine will report only success or failure, and nothing about the
        -:10843:     registers.
        -:10844:
        -:10845:   It returns 0 if it succeeds, nonzero if it doesn't.  (See regex.h for
        -:10846:   the return codes and their meanings.)  */
        -:10847:
        -:10848:
        -:10849:#ifdef __STDC__
        -:10850:int
function regcomp called 0 returned 0% blocks executed 0%
    #####:10851:regcomp (regex_t * preg, const char * pattern, int cflags)
        -:10852:#else
        -:10853:int
        -:10854:regcomp (preg, pattern, cflags)
        -:10855:    regex_t * preg;
        -:10856:    const char * pattern;
        -:10857:    int cflags;
        -:10858:#endif
        -:10859:{
        -:10860:  reg_errcode_t ret;
    #####:10861:  unsigned syntax
    #####:10862:    = cflags & REG_EXTENDED ? RE_SYNTAX_POSIX_EXTENDED : RE_SYNTAX_POSIX_BASIC;
branch  0 never executed
branch  1 never executed
        -:10863:
        -:10864:  /* regex_compile will allocate the space for the compiled pattern.  */
    #####:10865:  preg->buffer = 0;
    #####:10866:  preg->allocated = 0;
        -:10867:
    #####:10868:  preg->fastmap = malloc (256);
    #####:10869:  if (!preg->fastmap)
branch  0 never executed
branch  1 never executed
    #####:10870:    return REG_ESPACE;
    #####:10871:  preg->fastmap_accurate = 0;
        -:10872:
    #####:10873:  if (cflags & REG_ICASE)
branch  0 never executed
branch  1 never executed
        -:10874:    {
        -:10875:      unsigned i;
        -:10876:
    #####:10877:      preg->translate = (char *) malloc (256);
    #####:10878:      if (!preg->translate)
branch  0 never executed
branch  1 never executed
    #####:10879:        return (int) REG_ESPACE;
        -:10880:
        -:10881:      /* Map uppercase characters to corresponding lowercase ones.  */
    #####:10882:      for (i = 0; i < CHAR_SET_SIZE; i++)
branch  0 never executed
branch  1 never executed
    #####:10883:        preg->translate[i] = isupper (i) ? tolower (i) : i;
branch  0 never executed
branch  1 never executed
        -:10884:    }
        -:10885:  else
    #####:10886:    preg->translate = 0;
        -:10887:
        -:10888:  /* If REG_NEWLINE is set, newlines are treated differently.  */
    #####:10889:  if (cflags & REG_NEWLINE)
branch  0 never executed
branch  1 never executed
        -:10890:    { /* REG_NEWLINE implies neither . nor [^...] match newline.  */
    #####:10891:      syntax &= ~RE_DOT_NEWLINE;
    #####:10892:      syntax |= RE_HAT_LISTS_NOT_NEWLINE;
        -:10893:      /* It also changes the matching behavior.  */
    #####:10894:      preg->newline_anchor = 1;
        -:10895:    }
        -:10896:  else
    #####:10897:    preg->newline_anchor = 0;
        -:10898:
    #####:10899:  preg->no_sub = !!(cflags & REG_NOSUB);
        -:10900:
        -:10901:  /* POSIX says a null character in the pattern terminates it, so we
        -:10902:     can use strlen here in compiling the pattern.  */
    #####:10903:  preg->re_nsub = 0;
    #####:10904:  preg->start = 0;
    #####:10905:  preg->se_params = 0;
    #####:10906:  preg->rx.nodec = 0;
    #####:10907:  preg->rx.epsnodec = 0;
    #####:10908:  preg->rx.instruction_table = 0;
    #####:10909:  preg->rx.nfa_states = 0;
    #####:10910:  preg->rx.local_cset_size = 256;
    #####:10911:  preg->rx.start = 0;
    #####:10912:  preg->rx.se_list_cmp = posix_se_list_order;
    #####:10913:  preg->rx.start_set = 0;
    #####:10914:  ret = rx_compile (pattern, strlen (pattern), syntax, preg);
call    0 never executed
    #####:10915:  alloca (0);
        -:10916:
        -:10917:  /* POSIX doesn't distinguish between an unmatched open-group and an
        -:10918:     unmatched close-group: both are REG_EPAREN.  */
    #####:10919:  if (ret == REG_ERPAREN) ret = REG_EPAREN;
branch  0 never executed
branch  1 never executed
        -:10920:
    #####:10921:  return (int) ret;
        -:10922:}
        -:10923:
        -:10924:
        -:10925:/* regexec searches for a given pattern, specified by PREG, in the
        -:10926:   string STRING.
        -:10927:
        -:10928:   If NMATCH is zero or REG_NOSUB was set in the cflags argument to
        -:10929:   `regcomp', we ignore PMATCH.  Otherwise, we assume PMATCH has at
        -:10930:   least NMATCH elements, and we set them to the offsets of the
        -:10931:   corresponding matched substrings.
        -:10932:
        -:10933:   EFLAGS specifies `execution flags' which affect matching: if
        -:10934:   REG_NOTBOL is set, then ^ does not match at the beginning of the
        -:10935:   string; if REG_NOTEOL is set, then $ does not match at the end.
        -:10936:
        -:10937:   We return 0 if we find a match and REG_NOMATCH if not.  */
        -:10938:
        -:10939:#ifdef __STDC__
        -:10940:int
function regexec called 0 returned 0% blocks executed 0%
    #####:10941:regexec (const regex_t *preg, const char *string,
        -:10942:	 size_t nmatch, regmatch_t pmatch[],
        -:10943:	 int eflags)
        -:10944:#else
        -:10945:int
        -:10946:regexec (preg, string, nmatch, pmatch, eflags)
        -:10947:    const regex_t *preg;
        -:10948:    const char *string;
        -:10949:    size_t nmatch;
        -:10950:    regmatch_t pmatch[];
        -:10951:    int eflags;
        -:10952:#endif
        -:10953:{
        -:10954:  int ret;
        -:10955:  struct re_registers regs;
        -:10956:  regex_t private_preg;
    #####:10957:  int len = strlen (string);
    #####:10958:  boolean want_reg_info = !preg->no_sub && nmatch > 0;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:10959:
    #####:10960:  private_preg = *preg;
        -:10961:
    #####:10962:  private_preg.not_bol = !!(eflags & REG_NOTBOL);
    #####:10963:  private_preg.not_eol = !!(eflags & REG_NOTEOL);
        -:10964:
        -:10965:  /* The user has told us exactly how many registers to return
        -:10966:   * information about, via `nmatch'.  We have to pass that on to the
        -:10967:   * matching routines.
        -:10968:   */
    #####:10969:  private_preg.regs_allocated = REGS_FIXED;
        -:10970:
    #####:10971:  if (want_reg_info)
branch  0 never executed
branch  1 never executed
        -:10972:    {
    #####:10973:      regs.num_regs = nmatch;
    #####:10974:      regs.start = TALLOC (nmatch, regoff_t);
    #####:10975:      regs.end = TALLOC (nmatch, regoff_t);
    #####:10976:      if (regs.start == 0 || regs.end == 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:10977:        return (int) REG_NOMATCH;
        -:10978:    }
        -:10979:
        -:10980:  /* Perform the searching operation.  */
    #####:10981:  ret = re_search (&private_preg,
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:10982:		   string, len,
        -:10983:                   /* start: */ 0,
        -:10984:		   /* range: */ len,
        -:10985:                   want_reg_info ? &regs : (struct re_registers *) 0);
        -:10986:
        -:10987:  /* Copy the register information to the POSIX structure.  */
    #####:10988:  if (want_reg_info)
branch  0 never executed
branch  1 never executed
        -:10989:    {
    #####:10990:      if (ret >= 0)
branch  0 never executed
branch  1 never executed
        -:10991:        {
        -:10992:          unsigned r;
        -:10993:
    #####:10994:          for (r = 0; r < nmatch; r++)
branch  0 never executed
branch  1 never executed
        -:10995:            {
    #####:10996:              pmatch[r].rm_so = regs.start[r];
    #####:10997:              pmatch[r].rm_eo = regs.end[r];
        -:10998:            }
        -:10999:        }
        -:11000:
        -:11001:      /* If we needed the temporary register info, free the space now.  */
    #####:11002:      free (regs.start);
    #####:11003:      free (regs.end);
        -:11004:    }
        -:11005:
        -:11006:  /* We want zero return to mean success, unlike `re_search'.  */
    #####:11007:  return ret >= 0 ? (int) REG_NOERROR : (int) REG_NOMATCH;
        -:11008:}
        -:11009:
        -:11010:
        -:11011:/* Returns a message corresponding to an error code, ERRCODE, returned
        -:11012:   from either regcomp or regexec.   */
        -:11013:
        -:11014:#ifdef __STDC__
        -:11015:size_t
function regerror called 0 returned 0% blocks executed 0%
    #####:11016:regerror (int errcode, const regex_t *preg,
        -:11017:	  char *errbuf, size_t errbuf_size)
        -:11018:#else
        -:11019:size_t
        -:11020:regerror (errcode, preg, errbuf, errbuf_size)
        -:11021:    int errcode;
        -:11022:    const regex_t *preg;
        -:11023:    char *errbuf;
        -:11024:    size_t errbuf_size;
        -:11025:#endif
        -:11026:{
    #####:11027:  const char *msg
    #####:11028:    = rx_error_msg[errcode] == 0 ? "Success" : rx_error_msg[errcode];
branch  0 never executed
branch  1 never executed
    #####:11029:  size_t msg_size = strlen (msg) + 1; /* Includes the 0.  */
        -:11030:
    #####:11031:  if (errbuf_size != 0)
branch  0 never executed
branch  1 never executed
        -:11032:    {
    #####:11033:      if (msg_size > errbuf_size)
branch  0 never executed
branch  1 never executed
        -:11034:        {
    #####:11035:          strncpy (errbuf, msg, errbuf_size - 1);
    #####:11036:          errbuf[errbuf_size - 1] = 0;
        -:11037:        }
        -:11038:      else
    #####:11039:        strcpy (errbuf, msg);
        -:11040:    }
        -:11041:
    #####:11042:  return msg_size;
        -:11043:}
        -:11044:
        -:11045:
        -:11046:/* Free dynamically allocated space used by PREG.  */
        -:11047:
        -:11048:#ifdef __STDC__
        -:11049:void
function regfree called 0 returned 0% blocks executed 0%
    #####:11050:regfree (regex_t *preg)
        -:11051:#else
        -:11052:void
        -:11053:regfree (preg)
        -:11054:    regex_t *preg;
        -:11055:#endif
        -:11056:{
    #####:11057:  if (preg->buffer != 0)
branch  0 never executed
branch  1 never executed
    #####:11058:    free (preg->buffer);
    #####:11059:  preg->buffer = 0;
    #####:11060:  preg->allocated = 0;
        -:11061:
    #####:11062:  if (preg->fastmap != 0)
branch  0 never executed
branch  1 never executed
    #####:11063:    free (preg->fastmap);
    #####:11064:  preg->fastmap = 0;
    #####:11065:  preg->fastmap_accurate = 0;
        -:11066:
        -:11067:  #ifndef FAULTY_F_AG_9
    #####:11068:   if (preg->translate != 0)
branch  0 never executed
branch  1 never executed
        -:11069:  #else
        -:11070:    if (preg->translate = 0)
        -:11071:  #endif
    #####:11072:    free (preg->translate);
    #####:11073:  preg->translate = 0;
    #####:11074:}
        -:11075:
        -:11076:#endif /* not emacs  */
        -:11077:
        -:11078:
        -:11079:
        -:11080:
        -:11081:
        -:11082:/* Getopt for GNU.
        -:11083:   NOTE: getopt is now part of the C library, so if you don't know what
        -:11084:   "Keep this file name-space clean" means, talk to roland@gnu.ai.mit.edu
        -:11085:   before changing it!
        -:11086:
        -:11087:   Copyright (C) 1987, 1988, 1989, 1990, 1991, 1992, 1993
        -:11088:   	Free Software Foundation, Inc.
        -:11089:
        -:11090:   This program is free software; you can redistribute it and/or modify it
        -:11091:   under the terms of the GNU General Public License as published by the
        -:11092:   Free Software Foundation; either version 2, or (at your option) any
        -:11093:   later version.
        -:11094:
        -:11095:   This program is distributed in the hope that it will be useful,
        -:11096:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:11097:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:11098:   GNU General Public License for more details.
        -:11099:
        -:11100:   You should have received a copy of the GNU General Public License
        -:11101:   along with this program; if not, write to the Free Software
        -:11102:   Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
        -:11103:
        -:11104:/* NOTE!!!  AIX requires this to be the first thing in the file.
        -:11105:   Do not put ANYTHING before it!  */
        -:11106:#if !defined (__GNUC__) && defined (_AIX)
        -:11107: #pragma alloca
        -:11108:#endif
        -:11109:
        -:11110:#ifdef HAVE_CONFIG_H
        -:11111:#include "config.h"
        -:11112:#endif
        -:11113:
        -:11114:#ifdef __GNUC__
        -:11115:#ifndef alloca
        -:11116:#define alloca __builtin_alloca
        -:11117:#endif /* not alloca */
        -:11118:#else /* not __GNUC__ */
        -:11119:#if defined (HAVE_ALLOCA_H) || (defined(sparc) && (defined(sun) || (!defined(USG) && !defined(SVR4) && !defined(__svr4__))))
        -:11120:#include <alloca.h>
        -:11121:#else
        -:11122:#ifndef _AIX
        -:11123:char *alloca ();
        -:11124:#endif
        -:11125:#endif /* alloca.h */
        -:11126:#endif /* not __GNUC__ */
        -:11127:
        -:11128:#if !__STDC__ && !defined(const) && IN_GCC
        -:11129:#define const
        -:11130:#endif
        -:11131:
        -:11132:/* This tells Alpha OSF/1 not to define a getopt prototype in <stdio.h>.  */
        -:11133:#ifndef _NO_PROTO
        -:11134:#define _NO_PROTO
        -:11135:#endif
        -:11136:
        -:11137:#include <stdio.h>
        -:11138:
        -:11139:/* Comment out all this code if we are using the GNU C Library, and are not
        -:11140:   actually compiling the library itself.  This code is part of the GNU C
        -:11141:   Library, but also included in many other GNU distributions.  Compiling
        -:11142:   and linking in this code is a waste when using the GNU C library
        -:11143:   (especially if it is a shared library).  Rather than having every GNU
        -:11144:   program understand `configure --with-gnu-libc' and omit the object files,
        -:11145:   it is simpler to just do this in the source for each such file.  */
        -:11146:
        -:11147:#if defined (_LIBC) || !defined (__GNU_LIBRARY__)
        -:11148:
        -:11149:
        -:11150:/* This needs to come after some library #include
        -:11151:   to get __GNU_LIBRARY__ defined.  */
        -:11152:#ifdef	__GNU_LIBRARY__
        -:11153:#undef	alloca
        -:11154:/* Don't include stdlib.h for non-GNU C libraries because some of them
        -:11155:   contain conflicting prototypes for getopt.  */
        -:11156:#include <stdlib.h>
        -:11157:#else	/* Not GNU C library.  */
        -:11158:#define	__alloca	alloca
        -:11159:#endif	/* GNU C library.  */
        -:11160:
        -:11161:/* If GETOPT_COMPAT is defined, `+' as well as `--' can introduce a
        -:11162:   long-named option.  Because this is not POSIX.2 compliant, it is
        -:11163:   being phased out.  */
        -:11164:/* #define GETOPT_COMPAT */
        -:11165:
        -:11166:/* This version of `getopt' appears to the caller like standard Unix `getopt'
        -:11167:   but it behaves differently for the user, since it allows the user
        -:11168:   to intersperse the options with the other arguments.
        -:11169:
        -:11170:   As `getopt' works, it permutes the elements of ARGV so that,
        -:11171:   when it is done, all the options precede everything else.  Thus
        -:11172:   all application programs are extended to handle flexible argument order.
        -:11173:
        -:11174:   Setting the environment variable POSIXLY_CORRECT disables permutation.
        -:11175:   Then the behavior is completely standard.
        -:11176:
        -:11177:   GNU application programs can use a third alternative mode in which
        -:11178:   they can distinguish the relative order of options and other arguments.  */
        -:11179:
        -:11180:#include "getopt.h"
        -:11181:
        -:11182:/* For communication from `getopt' to the caller.
        -:11183:   When `getopt' finds an option that takes an argument,
        -:11184:   the argument value is returned here.
        -:11185:   Also, when `ordering' is RETURN_IN_ORDER,
        -:11186:   each non-option ARGV-element is returned here.  */
        -:11187:
        -:11188:char *optarg = 0;
        -:11189:
        -:11190:/* Index in ARGV of the next element to be scanned.
        -:11191:   This is used for communication to and from the caller
        -:11192:   and for communication between successive calls to `getopt'.
        -:11193:
        -:11194:   On entry to `getopt', zero means this is the first call; initialize.
        -:11195:
        -:11196:   When `getopt' returns EOF, this is the index of the first of the
        -:11197:   non-option elements that the caller should itself scan.
        -:11198:
        -:11199:   Otherwise, `optind' communicates from one call to the next
        -:11200:   how much of ARGV has been scanned so far.  */
        -:11201:
        -:11202:/* XXX 1003.2 says this must be 1 before any call.  */
        -:11203:int optind = 0;
        -:11204:
        -:11205:/* The next char to be scanned in the option-element
        -:11206:   in which the last option character we returned was found.
        -:11207:   This allows us to pick up the scan where we left off.
        -:11208:
        -:11209:   If this is zero, or a null string, it means resume the scan
        -:11210:   by advancing to the next ARGV-element.  */
        -:11211:
        -:11212:static char *nextchar;
        -:11213:
        -:11214:/* Callers store zero here to inhibit the error message
        -:11215:   for unrecognized options.  */
        -:11216:
        -:11217:int opterr = 1;
        -:11218:
        -:11219:/* Set to an option character which was unrecognized.
        -:11220:   This must be initialized on some systems to avoid linking in the
        -:11221:   system's own getopt implementation.  */
        -:11222:
        -:11223:int optopt = '?';
        -:11224:
        -:11225:/* Describe how to deal with options that follow non-option ARGV-elements.
        -:11226:
        -:11227:   If the caller did not specify anything,
        -:11228:   the default is REQUIRE_ORDER if the environment variable
        -:11229:   POSIXLY_CORRECT is defined, PERMUTE otherwise.
        -:11230:
        -:11231:   REQUIRE_ORDER means don't recognize them as options;
        -:11232:   stop option processing when the first non-option is seen.
        -:11233:   This is what Unix does.
        -:11234:   This mode of operation is selected by either setting the environment
        -:11235:   variable POSIXLY_CORRECT, or using `+' as the first character
        -:11236:   of the list of option characters.
        -:11237:
        -:11238:   PERMUTE is the default.  We permute the contents of ARGV as we scan,
        -:11239:   so that eventually all the non-options are at the end.  This allows options
        -:11240:   to be given in any order, even with programs that were not written to
        -:11241:   expect this.
        -:11242:
        -:11243:   RETURN_IN_ORDER is an option available to programs that were written
        -:11244:   to expect options and other ARGV-elements in any order and that care about
        -:11245:   the ordering of the two.  We describe each non-option ARGV-element
        -:11246:   as if it were the argument of an option with character code 1.
        -:11247:   Using `-' as the first character of the list of option characters
        -:11248:   selects this mode of operation.
        -:11249:
        -:11250:   The special argument `--' forces an end of option-scanning regardless
        -:11251:   of the value of `ordering'.  In the case of RETURN_IN_ORDER, only
        -:11252:   `--' can cause `getopt' to return EOF with `optind' != ARGC.  */
        -:11253:
        -:11254:static enum
        -:11255:{
        -:11256:  REQUIRE_ORDER, PERMUTE, RETURN_IN_ORDER
        -:11257:} ordering;
        -:11258:
        -:11259:#ifdef	__GNU_LIBRARY__
        -:11260:/* We want to avoid inclusion of string.h with non-GNU libraries
        -:11261:   because there are many ways it can cause trouble.
        -:11262:   On some systems, it contains special magic macros that don't work
        -:11263:   in GCC.  */
        -:11264:#include <string.h>
        -:11265:#define	my_index	strchr
        -:11266:#define	my_bcopy(src, dst, n)	memcpy ((dst), (src), (n))
        -:11267:#else
        -:11268:
        -:11269:/* Avoid depending on library functions or files
        -:11270:   whose names are inconsistent.  */
        -:11271:
        -:11272:char *getenv ();
        -:11273:
        -:11274:static char *
        -:11275:my_index (str, chr)
        -:11276:     const char *str;
        -:11277:     int chr;
        -:11278:{
        -:11279:  while (*str)
        -:11280:    {
        -:11281:      if (*str == chr)
        -:11282:	return (char *) str;
        -:11283:      str++;
        -:11284:    }
        -:11285:  return 0;
        -:11286:}
        -:11287:
        -:11288:static void
        -:11289:my_bcopy (from, to, size)
        -:11290:     const char *from;
        -:11291:     char *to;
        -:11292:     int size;
        -:11293:{
        -:11294:  int i;
        -:11295:  for (i = 0; i < size; i++)
        -:11296:    to[i] = from[i];
        -:11297:}
        -:11298:#endif				/* GNU C library.  */
        -:11299:
        -:11300:/* Handle permutation of arguments.  */
        -:11301:
        -:11302:/* Describe the part of ARGV that contains non-options that have
        -:11303:   been skipped.  `first_nonopt' is the index in ARGV of the first of them;
        -:11304:   `last_nonopt' is the index after the last of them.  */
        -:11305:
        -:11306:static int first_nonopt;
        -:11307:static int last_nonopt;
        -:11308:
        -:11309:/* Exchange two adjacent subsequences of ARGV.
        -:11310:   One subsequence is elements [first_nonopt,last_nonopt)
        -:11311:   which contains all the non-options that have been skipped so far.
        -:11312:   The other is elements [last_nonopt,optind), which contains all
        -:11313:   the options processed since those non-options were skipped.
        -:11314:
        -:11315:   `first_nonopt' and `last_nonopt' are relocated so that they describe
        -:11316:   the new indices of the non-options in ARGV after they are moved.  */
        -:11317:
        -:11318:static void
        -:11319:exchange (argv)
        -:11320:     char **argv;
        -:11321:{
        -:11322:  int nonopts_size = (last_nonopt - first_nonopt) * sizeof (char *);
        -:11323:  char **temp = (char **) __alloca (nonopts_size);
        -:11324:
        -:11325:  /* Interchange the two blocks of data in ARGV.  */
        -:11326:
        -:11327:  my_bcopy ((char *) &argv[first_nonopt], (char *) temp, nonopts_size);
        -:11328:  my_bcopy ((char *) &argv[last_nonopt], (char *) &argv[first_nonopt],
        -:11329:	    (optind - last_nonopt) * sizeof (char *));
        -:11330:  my_bcopy ((char *) temp,
        -:11331:	    (char *) &argv[first_nonopt + optind - last_nonopt],
        -:11332:	    nonopts_size);
        -:11333:
        -:11334:  /* Update records for the slots the non-options now occupy.  */
        -:11335:
        -:11336:  first_nonopt += (optind - last_nonopt);
        -:11337:  last_nonopt = optind;
        -:11338:}
        -:11339:
        -:11340:/* Scan elements of ARGV (whose length is ARGC) for option characters
        -:11341:   given in OPTSTRING.
        -:11342:
        -:11343:   If an element of ARGV starts with '-', and is not exactly "-" or "--",
        -:11344:   then it is an option element.  The characters of this element
        -:11345:   (aside from the initial '-') are option characters.  If `getopt'
        -:11346:   is called repeatedly, it returns successively each of the option characters
        -:11347:   from each of the option elements.
        -:11348:
        -:11349:   If `getopt' finds another option character, it returns that character,
        -:11350:   updating `optind' and `nextchar' so that the next call to `getopt' can
        -:11351:   resume the scan with the following option character or ARGV-element.
        -:11352:
        -:11353:   If there are no more option characters, `getopt' returns `EOF'.
        -:11354:   Then `optind' is the index in ARGV of the first ARGV-element
        -:11355:   that is not an option.  (The ARGV-elements have been permuted
        -:11356:   so that those that are not options now come last.)
        -:11357:
        -:11358:   OPTSTRING is a string containing the legitimate option characters.
        -:11359:   If an option character is seen that is not listed in OPTSTRING,
        -:11360:   return '?' after printing an error message.  If you set `opterr' to
        -:11361:   zero, the error message is suppressed but we still return '?'.
        -:11362:
        -:11363:   If a char in OPTSTRING is followed by a colon, that means it wants an arg,
        -:11364:   so the following text in the same ARGV-element, or the text of the following
        -:11365:   ARGV-element, is returned in `optarg'.  Two colons mean an option that
        -:11366:   wants an optional arg; if there is text in the current ARGV-element,
        -:11367:   it is returned in `optarg', otherwise `optarg' is set to zero.
        -:11368:
        -:11369:   If OPTSTRING starts with `-' or `+', it requests different methods of
        -:11370:   handling the non-option ARGV-elements.
        -:11371:   See the comments about RETURN_IN_ORDER and REQUIRE_ORDER, above.
        -:11372:
        -:11373:   Long-named options begin with `--' instead of `-'.
        -:11374:   Their names may be abbreviated as long as the abbreviation is unique
        -:11375:   or is an exact match for some defined option.  If they have an
        -:11376:   argument, it follows the option name in the same ARGV-element, separated
        -:11377:   from the option name by a `=', or else the in next ARGV-element.
        -:11378:   When `getopt' finds a long-named option, it returns 0 if that option's
        -:11379:   `flag' field is nonzero, the value of the option's `val' field
        -:11380:   if the `flag' field is zero.
        -:11381:
        -:11382:   The elements of ARGV aren't really const, because we permute them.
        -:11383:   But we pretend they're const in the prototype to be compatible
        -:11384:   with other systems.
        -:11385:
        -:11386:   LONGOPTS is a vector of `struct option' terminated by an
        -:11387:   element containing a name which is zero.
        -:11388:
        -:11389:   LONGIND returns the index in LONGOPT of the long-named option found.
        -:11390:   It is only valid when a long-named option has been found by the most
        -:11391:   recent call.
        -:11392:
        -:11393:   If LONG_ONLY is nonzero, '-' as well as '--' can introduce
        -:11394:   long-named options.  */
        -:11395:
        -:11396:int
        -:11397:_getopt_internal (argc, argv, optstring, longopts, longind, long_only)
        -:11398:     int argc;
        -:11399:     char *const *argv;
        -:11400:     const char *optstring;
        -:11401:     const struct option *longopts;
        -:11402:     int *longind;
        -:11403:     int long_only;
        -:11404:{
        -:11405:  int option_index;
        -:11406:
        -:11407:  optarg = 0;
        -:11408:
        -:11409:  /* Initialize the internal data when the first call is made.
        -:11410:     Start processing options with ARGV-element 1 (since ARGV-element 0
        -:11411:     is the program name); the sequence of previously skipped
        -:11412:     non-option ARGV-elements is empty.  */
        -:11413:
        -:11414:  if (optind == 0)
        -:11415:    {
        -:11416:      first_nonopt = last_nonopt = optind = 1;
        -:11417:
        -:11418:      nextchar = NULL;
        -:11419:
        -:11420:      /* Determine how to handle the ordering of options and nonoptions.  */
        -:11421:
        -:11422:      if (optstring[0] == '-')
        -:11423:	{
        -:11424:	  ordering = RETURN_IN_ORDER;
        -:11425:	  ++optstring;
        -:11426:	}
        -:11427:      else if (optstring[0] == '+')
        -:11428:	{
        -:11429:	  ordering = REQUIRE_ORDER;
        -:11430:	  ++optstring;
        -:11431:	}
        -:11432:      else if (getenv ("POSIXLY_CORRECT") != NULL)
        -:11433:	ordering = REQUIRE_ORDER;
        -:11434:      else
        -:11435:	ordering = PERMUTE;
        -:11436:    }
        -:11437:
        -:11438:  if (nextchar == NULL || *nextchar == '\0')
        -:11439:    {
        -:11440:      if (ordering == PERMUTE)
        -:11441:	{
        -:11442:	  /* If we have just processed some options following some non-options,
        -:11443:	     exchange them so that the options come first.  */
        -:11444:
        -:11445:	  if (first_nonopt != last_nonopt && last_nonopt != optind)
        -:11446:	    exchange ((char **) argv);
        -:11447:	  else if (last_nonopt != optind)
        -:11448:	    first_nonopt = optind;
        -:11449:
        -:11450:	  /* Now skip any additional non-options
        -:11451:	     and extend the range of non-options previously skipped.  */
        -:11452:
        -:11453:	  while (optind < argc
        -:11454:		 && (argv[optind][0] != '-' || argv[optind][1] == '\0')
        -:11455:#ifdef GETOPT_COMPAT
        -:11456:		 && (longopts == NULL
        -:11457:		     || argv[optind][0] != '+' || argv[optind][1] == '\0')
        -:11458:#endif				/* GETOPT_COMPAT */
        -:11459:		 )
        -:11460:	    optind++;
        -:11461:	  last_nonopt = optind;
        -:11462:	}
        -:11463:
        -:11464:      /* Special ARGV-element `--' means premature end of options.
        -:11465:	 Skip it like a null option,
        -:11466:	 then exchange with previous non-options as if it were an option,
        -:11467:	 then skip everything else like a non-option.  */
        -:11468:
        -:11469:      if (optind != argc && !strcmp (argv[optind], "--"))
        -:11470:	{
        -:11471:	  optind++;
        -:11472:
        -:11473:	  if (first_nonopt != last_nonopt && last_nonopt != optind)
        -:11474:	    exchange ((char **) argv);
        -:11475:	  else if (first_nonopt == last_nonopt)
        -:11476:	    first_nonopt = optind;
        -:11477:	  last_nonopt = argc;
        -:11478:
        -:11479:	  optind = argc;
        -:11480:	}
        -:11481:
        -:11482:      /* If we have done all the ARGV-elements, stop the scan
        -:11483:	 and back over any non-options that we skipped and permuted.  */
        -:11484:
        -:11485:      if (optind == argc)
        -:11486:	{
        -:11487:	  /* Set the next-arg-index to point at the non-options
        -:11488:	     that we previously skipped, so the caller will digest them.  */
        -:11489:	  if (first_nonopt != last_nonopt)
        -:11490:	    optind = first_nonopt;
        -:11491:	  return EOF;
        -:11492:	}
        -:11493:
        -:11494:      /* If we have come to a non-option and did not permute it,
        -:11495:	 either stop the scan or describe it to the caller and pass it by.  */
        -:11496:
        -:11497:      if ((argv[optind][0] != '-' || argv[optind][1] == '\0')
        -:11498:#ifdef GETOPT_COMPAT
        -:11499:	  && (longopts == NULL
        -:11500:	      || argv[optind][0] != '+' || argv[optind][1] == '\0')
        -:11501:#endif				/* GETOPT_COMPAT */
        -:11502:	  )
        -:11503:	{
        -:11504:	  if (ordering == REQUIRE_ORDER)
        -:11505:	    return EOF;
        -:11506:	  optarg = argv[optind++];
        -:11507:	  return 1;
        -:11508:	}
        -:11509:
        -:11510:      /* We have found another option-ARGV-element.
        -:11511:	 Start decoding its characters.  */
        -:11512:
        -:11513:      nextchar = (argv[optind] + 1
        -:11514:		  + (longopts != NULL && argv[optind][1] == '-'));
        -:11515:    }
        -:11516:
        -:11517:  if (longopts != NULL
        -:11518:      && ((argv[optind][0] == '-'
        -:11519:	   && (argv[optind][1] == '-' || long_only))
        -:11520:#ifdef GETOPT_COMPAT
        -:11521:	  || argv[optind][0] == '+'
        -:11522:#endif				/* GETOPT_COMPAT */
        -:11523:	  ))
        -:11524:    {
        -:11525:      const struct option *p;
        -:11526:      char *s = nextchar;
        -:11527:      int exact = 0;
        -:11528:      int ambig = 0;
        -:11529:      const struct option *pfound = NULL;
        -:11530:      int indfound;
        -:11531:
        -:11532:      while (*s && *s != '=')
        -:11533:	s++;
        -:11534:
        -:11535:      /* Test all options for either exact match or abbreviated matches.  */
        -:11536:      for (p = longopts, option_index = 0; p->name;
        -:11537:	   p++, option_index++)
        -:11538:	if (!strncmp (p->name, nextchar, s - nextchar))
        -:11539:	  {
        -:11540:	    if (s - nextchar == strlen (p->name))
        -:11541:	      {
        -:11542:		/* Exact match found.  */
        -:11543:		pfound = p;
        -:11544:		indfound = option_index;
        -:11545:		exact = 1;
        -:11546:		break;
        -:11547:	      }
        -:11548:	    else if (pfound == NULL)
        -:11549:	      {
        -:11550:		/* First nonexact match found.  */
        -:11551:		pfound = p;
        -:11552:		indfound = option_index;
        -:11553:	      }
        -:11554:	    else
        -:11555:	      /* Second nonexact match found.  */
        -:11556:	      ambig = 1;
        -:11557:	  }
        -:11558:
        -:11559:      if (ambig && !exact)
        -:11560:	{
        -:11561:	  if (opterr)
        -:11562:	    fprintf (stderr, "%s: option `%s' is ambiguous\n",
        -:11563:		     myname, argv[optind]);
        -:11564:	  nextchar += strlen (nextchar);
        -:11565:	  optind++;
        -:11566:	  return '?';
        -:11567:	}
        -:11568:
        -:11569:      if (pfound != NULL)
        -:11570:	{
        -:11571:	  option_index = indfound;
        -:11572:	  optind++;
        -:11573:	  if (*s)
        -:11574:	    {
        -:11575:	      /* Don't test has_arg with >, because some C compilers don't
        -:11576:		 allow it to be used on enums.  */
        -:11577:	      if (pfound->has_arg)
        -:11578:		optarg = s + 1;
        -:11579:	      else
        -:11580:		{
        -:11581:		  if (opterr)
        -:11582:		    {
        -:11583:		      if (argv[optind - 1][1] == '-')
        -:11584:			/* --option */
        -:11585:			fprintf (stderr,
        -:11586:				 "%s: option `--%s' doesn't allow an argument\n",
        -:11587:				 myname, pfound->name);
        -:11588:		      else
        -:11589:			/* +option or -option */
        -:11590:			fprintf (stderr,
        -:11591:			     "%s: option `%c%s' doesn't allow an argument\n",
        -:11592:			     myname, argv[optind - 1][0], pfound->name);
        -:11593:		    }
        -:11594:		  nextchar += strlen (nextchar);
        -:11595:		  return '?';
        -:11596:		}
        -:11597:	    }
        -:11598:	  else if (pfound->has_arg == 1)
        -:11599:	    {
        -:11600:	      if (optind < argc)
        -:11601:		optarg = argv[optind++];
        -:11602:	      else
        -:11603:		{
        -:11604:		  if (opterr)
        -:11605:		    fprintf (stderr, "%s: option `%s' requires an argument\n",
        -:11606:			     myname, argv[optind - 1]);
        -:11607:		  nextchar += strlen (nextchar);
        -:11608:		  return optstring[0] == ':' ? ':' : '?';
        -:11609:		}
        -:11610:	    }
        -:11611:	  nextchar += strlen (nextchar);
        -:11612:	  if (longind != NULL)
        -:11613:	    *longind = option_index;
        -:11614:	  if (pfound->flag)
        -:11615:	    {
        -:11616:	      *(pfound->flag) = pfound->val;
        -:11617:	      return 0;
        -:11618:	    }
        -:11619:	  return pfound->val;
        -:11620:	}
        -:11621:      /* Can't find it as a long option.  If this is not getopt_long_only,
        -:11622:	 or the option starts with '--' or is not a valid short
        -:11623:	 option, then it's an error.
        -:11624:	 Otherwise interpret it as a short option.  */
        -:11625:      if (!long_only || argv[optind][1] == '-'
        -:11626:#ifdef GETOPT_COMPAT
        -:11627:	  || argv[optind][0] == '+'
        -:11628:#endif				/* GETOPT_COMPAT */
        -:11629:	  || my_index (optstring, *nextchar) == NULL)
        -:11630:	{
        -:11631:	  if (opterr)
        -:11632:	    {
        -:11633:	      if (argv[optind][1] == '-')
        -:11634:		/* --option */
        -:11635:		fprintf (stderr, "%s: unrecognized option `--%s'\n",
        -:11636:			 myname, nextchar);
        -:11637:	      else
        -:11638:		/* +option or -option */
        -:11639:		fprintf (stderr, "%s: unrecognized option `%c%s'\n",
        -:11640:			 myname, argv[optind][0], nextchar);
        -:11641:	    }
        -:11642:	  nextchar = (char *) "";
        -:11643:	  optind++;
        -:11644:	  return '?';
        -:11645:	}
        -:11646:    }
        -:11647:
        -:11648:  /* Look at and handle the next option-character.  */
        -:11649:
        -:11650:  {
        -:11651:    char c = *nextchar++;
        -:11652:    char *temp = my_index (optstring, c);
        -:11653:
        -:11654:    /* Increment `optind' when we start to process its last character.  */
        -:11655:    if (*nextchar == '\0')
        -:11656:      ++optind;
        -:11657:
        -:11658:    if (temp == NULL || c == ':')
        -:11659:      {
        -:11660:	if (opterr)
        -:11661:	  {
        -:11662:#if 0
        -:11663:	    if (c < 040 || c >= 0177)
        -:11664:	      fprintf (stderr, "%s: unrecognized option, character code 0%o\n",
        -:11665:		       myname, c);
        -:11666:	    else
        -:11667:	      fprintf (stderr, "%s: unrecognized option `-%c'\n", myname, c);
        -:11668:#else
        -:11669:	    /* 1003.2 specifies the format of this message.  */
        -:11670:	    fprintf (stderr, "%s: illegal option -- %c\n", myname, c);
        -:11671:#endif
        -:11672:	  }
        -:11673:	optopt = c;
        -:11674:	return '?';
        -:11675:      }
        -:11676:    if (temp[1] == ':')
        -:11677:      {
        -:11678:	if (temp[2] == ':')
        -:11679:	  {
        -:11680:	    /* This is an option that accepts an argument optionally.  */
        -:11681:	    if (*nextchar != '\0')
        -:11682:	      {
        -:11683:		optarg = nextchar;
        -:11684:		optind++;
        -:11685:	      }
        -:11686:	    else
        -:11687:	      optarg = 0;
        -:11688:	    nextchar = NULL;
        -:11689:	  }
        -:11690:	else
        -:11691:	  {
        -:11692:	    /* This is an option that requires an argument.  */
        -:11693:	    if (*nextchar != '\0')
        -:11694:	      {
        -:11695:		optarg = nextchar;
        -:11696:		/* If we end this ARGV-element by taking the rest as an arg,
        -:11697:		   we must advance to the next element now.  */
        -:11698:		optind++;
        -:11699:	      }
        -:11700:	    else if (optind == argc)
        -:11701:	      {
        -:11702:		if (opterr)
        -:11703:		  {
        -:11704:#if 0
        -:11705:		    fprintf (stderr, "%s: option `-%c' requires an argument\n",
        -:11706:			     myname, c);
        -:11707:#else
        -:11708:		    /* 1003.2 specifies the format of this message.  */
        -:11709:		    fprintf (stderr, "%s: option requires an argument -- %c\n",
        -:11710:			     myname, c);
        -:11711:#endif
        -:11712:		  }
        -:11713:		optopt = c;
        -:11714:		if (optstring[0] == ':')
        -:11715:		  c = ':';
        -:11716:		else
        -:11717:		  c = '?';
        -:11718:	      }
        -:11719:	    else
        -:11720:	      /* We already incremented `optind' once;
        -:11721:		 increment it again when taking next ARGV-elt as argument.  */
        -:11722:	      optarg = argv[optind++];
        -:11723:	    nextchar = NULL;
        -:11724:	  }
        -:11725:      }
        -:11726:    return c;
        -:11727:  }
        -:11728:}
        -:11729:
        -:11730:int
        -:11731:getopt (argc, argv, optstring)
        -:11732:     int argc;
        -:11733:     char *const *argv;
        -:11734:     const char *optstring;
        -:11735:{
        -:11736:  return _getopt_internal (argc, argv, optstring,
        -:11737:			   (const struct option *) 0,
        -:11738:			   (int *) 0,
        -:11739:			   0);
        -:11740:}
        -:11741:
        -:11742:#endif	/* _LIBC or not __GNU_LIBRARY__.  */
        -:11743:
        -:11744:#ifdef TEST
        -:11745:
        -:11746:/* Compile with -DTEST to make an executable for use in testing
        -:11747:   the above definition of `getopt'.  */
        -:11748:
        -:11749:int
        -:11750:main (argc, argv)
        -:11751:     int argc;
        -:11752:     char **argv;
        -:11753:{
        -:11754:  int c;
        -:11755:  int digit_optind = 0;
        -:11756:
        -:11757:  while (1)
        -:11758:    {
        -:11759:      int this_option_optind = optind ? optind : 1;
        -:11760:
        -:11761:      c = getopt (argc, argv, "abc:d:0123456789");
        -:11762:      if (c == EOF)
        -:11763:	break;
        -:11764:
        -:11765:      switch (c)
        -:11766:	{
        -:11767:	case '0':
        -:11768:	case '1':
        -:11769:	case '2':
        -:11770:	case '3':
        -:11771:	case '4':
        -:11772:	case '5':
        -:11773:	case '6':
        -:11774:	case '7':
        -:11775:	case '8':
        -:11776:	case '9':
        -:11777:	  if (digit_optind != 0 && digit_optind != this_option_optind)
        -:11778:	    printf ("digits occur in two different argv-elements.\n");
        -:11779:	  digit_optind = this_option_optind;
        -:11780:	  printf ("option %c\n", c);
        -:11781:	  break;
        -:11782:
        -:11783:	case 'a':
        -:11784:	  printf ("option a\n");
        -:11785:	  break;
        -:11786:
        -:11787:	case 'b':
        -:11788:	  printf ("option b\n");
        -:11789:	  break;
        -:11790:
        -:11791:	case 'c':
        -:11792:	  printf ("option c with value `%s'\n", optarg);
        -:11793:	  break;
        -:11794:
        -:11795:	case '?':
        -:11796:	  break;
        -:11797:
        -:11798:	default:
        -:11799:	  printf ("?? getopt returned character code 0%o ??\n", c);
        -:11800:	}
        -:11801:    }
        -:11802:
        -:11803:  if (optind < argc)
        -:11804:    {
        -:11805:      printf ("non-option ARGV-elements: ");
        -:11806:      while (optind < argc)
        -:11807:	printf ("%s ", argv[optind++]);
        -:11808:      printf ("\n");
        -:11809:    }
        -:11810:
        -:11811:  exit (0);
        -:11812:}
        -:11813:
        -:11814:#endif /* TEST */
        -:11815:/* getopt_long and getopt_long_only entry points for GNU getopt.
        -:11816:   Copyright (C) 1987, 88, 89, 90, 91, 92, 1993
        -:11817:	Free Software Foundation, Inc.
        -:11818:
        -:11819:   This program is free software; you can redistribute it and/or modify it
        -:11820:   under the terms of the GNU General Public License as published by the
        -:11821:   Free Software Foundation; either version 2, or (at your option) any
        -:11822:   later version.
        -:11823:
        -:11824:   This program is distributed in the hope that it will be useful,
        -:11825:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:11826:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:11827:   GNU General Public License for more details.
        -:11828:
        -:11829:   You should have received a copy of the GNU General Public License
        -:11830:   along with this program; if not, write to the Free Software
        -:11831:   Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
        -:11832:
        -:11833:#ifdef HAVE_CONFIG_H
        -:11834:#include "config.h"
        -:11835:#endif
        -:11836:
        -:11837:#include "getopt.h"
        -:11838:
        -:11839:#if !__STDC__ && !defined(const) && IN_GCC
        -:11840:#define const
        -:11841:#endif
        -:11842:
        -:11843:#include <stdio.h>
        -:11844:
        -:11845:/* Comment out all this code if we are using the GNU C Library, and are not
        -:11846:   actually compiling the library itself.  This code is part of the GNU C
        -:11847:   Library, but also included in many other GNU distributions.  Compiling
        -:11848:   and linking in this code is a waste when using the GNU C library
        -:11849:   (especially if it is a shared library).  Rather than having every GNU
        -:11850:   program understand `configure --with-gnu-libc' and omit the object files,
        -:11851:   it is simpler to just do this in the source for each such file.  */
        -:11852:
        -:11853:#if defined (_LIBC) || !defined (__GNU_LIBRARY__)
        -:11854:
        -:11855:
        -:11856:/* This needs to come after some library #include
        -:11857:   to get __GNU_LIBRARY__ defined.  */
        -:11858:#ifdef __GNU_LIBRARY__
        -:11859:#include <stdlib.h>
        -:11860:#else
        -:11861:char *getenv ();
        -:11862:#endif
        -:11863:
        -:11864:#ifndef	NULL
        -:11865:#define NULL 0
        -:11866:#endif
        -:11867:
        -:11868:int
        -:11869:getopt_long (argc, argv, options, long_options, opt_index)
        -:11870:     int argc;
        -:11871:     char *const *argv;
        -:11872:     const char *options;
        -:11873:     const struct option *long_options;
        -:11874:     int *opt_index;
        -:11875:{
        -:11876:  return _getopt_internal (argc, argv, options, long_options, opt_index, 0);
        -:11877:}
        -:11878:
        -:11879:/* Like getopt_long, but '-' as well as '--' can indicate a long option.
        -:11880:   If an option that starts with '-' (not '--') doesn't match a long option,
        -:11881:   but does match a short option, it is parsed as a short option
        -:11882:   instead.  */
        -:11883:
        -:11884:int
        -:11885:getopt_long_only (argc, argv, options, long_options, opt_index)
        -:11886:     int argc;
        -:11887:     char *const *argv;
        -:11888:     const char *options;
        -:11889:     const struct option *long_options;
        -:11890:     int *opt_index;
        -:11891:{
        -:11892:  return _getopt_internal (argc, argv, options, long_options, opt_index, 1);
        -:11893:}
        -:11894:
        -:11895:
        -:11896:#endif	/* _LIBC or not __GNU_LIBRARY__.  */
        -:11897:
        -:11898:#ifdef TEST
        -:11899:
        -:11900:#include <stdio.h>
        -:11901:
        -:11902:int
        -:11903:main (argc, argv)
        -:11904:     int argc;
        -:11905:     char **argv;
        -:11906:{
        -:11907:  int c;
        -:11908:  int digit_optind = 0;
        -:11909:
        -:11910:  while (1)
        -:11911:    {
        -:11912:      int this_option_optind = optind ? optind : 1;
        -:11913:      int option_index = 0;
        -:11914:      static struct option long_options[] =
        -:11915:      {
        -:11916:	{"add", 1, 0, 0},
        -:11917:	{"append", 0, 0, 0},
        -:11918:	{"delete", 1, 0, 0},
        -:11919:	{"verbose", 0, 0, 0},
        -:11920:	{"create", 0, 0, 0},
        -:11921:	{"file", 1, 0, 0},
        -:11922:	{0, 0, 0, 0}
        -:11923:      };
        -:11924:
        -:11925:      c = getopt_long (argc, argv, "abc:d:0123456789",
        -:11926:		       long_options, &option_index);
        -:11927:      if (c == EOF)
        -:11928:	break;
        -:11929:
        -:11930:      switch (c)
        -:11931:	{
        -:11932:	case 0:
        -:11933:	  printf ("option %s", long_options[option_index].name);
        -:11934:	  if (optarg)
        -:11935:	    printf (" with arg %s", optarg);
        -:11936:	  printf ("\n");
        -:11937:	  break;
        -:11938:
        -:11939:	case '0':
        -:11940:	case '1':
        -:11941:	case '2':
        -:11942:	case '3':
        -:11943:	case '4':
        -:11944:	case '5':
        -:11945:	case '6':
        -:11946:	case '7':
        -:11947:	case '8':
        -:11948:	case '9':
        -:11949:	  if (digit_optind != 0 && digit_optind != this_option_optind)
        -:11950:	    printf ("digits occur in two different argv-elements.\n");
        -:11951:	  digit_optind = this_option_optind;
        -:11952:	  printf ("option %c\n", c);
        -:11953:	  break;
        -:11954:
        -:11955:	case 'a':
        -:11956:	  printf ("option a\n");
        -:11957:	  break;
        -:11958:
        -:11959:	case 'b':
        -:11960:	  printf ("option b\n");
        -:11961:	  break;
        -:11962:
        -:11963:	case 'c':
        -:11964:	  printf ("option c with value `%s'\n", optarg);
        -:11965:	  break;
        -:11966:
        -:11967:	case 'd':
        -:11968:	  printf ("option d with value `%s'\n", optarg);
        -:11969:	  break;
        -:11970:
        -:11971:	case '?':
        -:11972:	  break;
        -:11973:
        -:11974:	default:
        -:11975:	  printf ("?? getopt returned character code 0%o ??\n", c);
        -:11976:	}
        -:11977:    }
        -:11978:
        -:11979:  if (optind < argc)
        -:11980:    {
        -:11981:      printf ("non-option ARGV-elements: ");
        -:11982:      while (optind < argc)
        -:11983:	printf ("%s ", argv[optind++]);
        -:11984:      printf ("\n");
        -:11985:    }
        -:11986:
        -:11987:  exit (0);
        -:11988:}
        -:11989:
        -:11990:#endif /* TEST */
