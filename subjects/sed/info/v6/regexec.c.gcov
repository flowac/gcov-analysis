        -:    0:Source:regexec.c
        -:    0:Graph:sed.gcno
        -:    0:Data:sed.gcda
        -:    0:Runs:370
        -:    1:/* Extended regular expression matching and search library.
        -:    2:   Copyright (C) 2002 Free Software Foundation, Inc.
        -:    3:   This file is part of the GNU C Library.
        -:    4:   Contributed by Isamu Hasegawa <isamu@yamato.ibm.com>.
        -:    5:
        -:    6:   The GNU C Library is free software; you can redistribute it and/or
        -:    7:   modify it under the terms of the GNU Lesser General Public
        -:    8:   License as published by the Free Software Foundation; either
        -:    9:   version 2.1 of the License, or (at your option) any later version.
        -:   10:
        -:   11:   The GNU C Library is distributed in the hope that it will be useful,
        -:   12:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   13:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
        -:   14:   Lesser General Public License for more details.
        -:   15:
        -:   16:   You should have received a copy of the GNU Lesser General Public
        -:   17:   License along with the GNU C Library; if not, write to the Free
        -:   18:   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
        -:   19:   02111-1307 USA.  */
        -:   20:
        -:   21:static reg_errcode_t match_ctx_init (re_match_context_t *cache, int eflags,
        -:   22:				     re_string_t *input, int n);
        -:   23:static void match_ctx_free (re_match_context_t *cache);
        -:   24:static reg_errcode_t match_ctx_add_entry (re_match_context_t *cache, int node,
        -:   25:					  int str_idx, int from, int to,
        -:   26:					  re_sub_match_top_t *top,
        -:   27:					  re_sub_match_last_t *last);
        -:   28:static int search_cur_bkref_entry (re_match_context_t *mctx, int str_idx);
        -:   29:static void match_ctx_clear_flag (re_match_context_t *mctx);
        -:   30:static reg_errcode_t match_ctx_add_subtop (re_match_context_t *mctx, int node,
        -:   31:					   int str_idx);
        -:   32:static re_sub_match_last_t * match_ctx_add_sublast (re_sub_match_top_t *subtop,
        -:   33:						   int node, int str_idx);
        -:   34:static void sift_ctx_init (re_sift_context_t *sctx, re_dfastate_t **sifted_sts,
        -:   35:			   re_dfastate_t **limited_sts, int last_node,
        -:   36:			   int last_str_idx, int check_subexp);
        -:   37:static int re_search_2_stub (struct re_pattern_buffer *bufp,
        -:   38:			     const char *string1, int length1,
        -:   39:			     const char *string2, int length2,
        -:   40:			     int start, int range, struct re_registers *regs,
        -:   41:			     int stop, int ret_len);
        -:   42:static int re_search_stub (struct re_pattern_buffer *bufp,
        -:   43:			   const char *string, int length, int start,
        -:   44:			   int range, int stop, struct re_registers *regs,
        -:   45:			   int ret_len);
        -:   46:static unsigned re_copy_regs (struct re_registers *regs, regmatch_t *pmatch,
        -:   47:			      int nregs, int regs_allocated);
        -:   48:static inline re_dfastate_t *acquire_init_state_context (reg_errcode_t *err,
        -:   49:							 const regex_t *preg,
        -:   50:							 const re_match_context_t *mctx,
        -:   51:							 int idx);
        -:   52:static reg_errcode_t prune_impossible_nodes (const regex_t *preg,
        -:   53:					     re_match_context_t *mctx);
        -:   54:static int check_matching (const regex_t *preg, re_match_context_t *mctx,
        -:   55:			   int fl_search, int fl_longest_match);
        -:   56:static int check_halt_node_context (const re_dfa_t *dfa, int node,
        -:   57:				    unsigned int context);
        -:   58:static int check_halt_state_context (const regex_t *preg,
        -:   59:				     const re_dfastate_t *state,
        -:   60:				     const re_match_context_t *mctx, int idx);
        -:   61:static void update_regs (re_dfa_t *dfa, regmatch_t *pmatch, int cur_node,
        -:   62:			 int cur_idx, int nmatch);
        -:   63:static int proceed_next_node (const regex_t *preg, int nregs, regmatch_t *regs,
        -:   64:			      const re_match_context_t *mctx,
        -:   65:			      int *pidx, int node, re_node_set *eps_via_nodes,
        -:   66:			      struct re_fail_stack_t *fs);
        -:   67:static reg_errcode_t push_fail_stack (struct re_fail_stack_t *fs,
        -:   68:				      int str_idx, int *dests, int nregs,
        -:   69:				      regmatch_t *regs,
        -:   70:				      re_node_set *eps_via_nodes);
        -:   71:static int pop_fail_stack (struct re_fail_stack_t *fs, int *pidx, int nregs,
        -:   72:			   regmatch_t *regs, re_node_set *eps_via_nodes);
        -:   73:static reg_errcode_t set_regs (const regex_t *preg,
        -:   74:			       const re_match_context_t *mctx,
        -:   75:			       size_t nmatch, regmatch_t *pmatch,
        -:   76:			       int fl_backtrack);
        -:   77:static reg_errcode_t free_fail_stack_return (struct re_fail_stack_t *fs);
        -:   78:
        -:   79:#ifdef RE_ENABLE_I18N
        -:   80:static int sift_states_iter_mb (const regex_t *preg,
        -:   81:				const re_match_context_t *mctx,
        -:   82:				re_sift_context_t *sctx,
        -:   83:				int node_idx, int str_idx, int max_str_idx);
        -:   84:#endif /* RE_ENABLE_I18N */
        -:   85:static reg_errcode_t sift_states_backward (const regex_t *preg,
        -:   86:					   re_match_context_t *mctx,
        -:   87:					   re_sift_context_t *sctx);
        -:   88:static reg_errcode_t update_cur_sifted_state (const regex_t *preg,
        -:   89:					      re_match_context_t *mctx,
        -:   90:					      re_sift_context_t *sctx,
        -:   91:					      int str_idx,
        -:   92:					      re_node_set *dest_nodes);
        -:   93:static reg_errcode_t add_epsilon_src_nodes (re_dfa_t *dfa,
        -:   94:					    re_node_set *dest_nodes,
        -:   95:					    const re_node_set *candidates);
        -:   96:static reg_errcode_t sub_epsilon_src_nodes (re_dfa_t *dfa, int node,
        -:   97:					    re_node_set *dest_nodes,
        -:   98:					    const re_node_set *and_nodes);
        -:   99:static int check_dst_limits (re_dfa_t *dfa, re_node_set *limits,
        -:  100:			     re_match_context_t *mctx, int dst_node,
        -:  101:			     int dst_idx, int src_node, int src_idx);
        -:  102:static int check_dst_limits_calc_pos (re_dfa_t *dfa, re_match_context_t *mctx,
        -:  103:				      int limit, re_node_set *eclosures,
        -:  104:				      int subexp_idx, int node, int str_idx);
        -:  105:static reg_errcode_t check_subexp_limits (re_dfa_t *dfa,
        -:  106:					  re_node_set *dest_nodes,
        -:  107:					  const re_node_set *candidates,
        -:  108:					  re_node_set *limits,
        -:  109:					  struct re_backref_cache_entry *bkref_ents,
        -:  110:					  int str_idx);
        -:  111:static reg_errcode_t sift_states_bkref (const regex_t *preg,
        -:  112:					re_match_context_t *mctx,
        -:  113:					re_sift_context_t *sctx,
        -:  114:					int str_idx, re_node_set *dest_nodes);
        -:  115:static reg_errcode_t clean_state_log_if_need (re_match_context_t *mctx,
        -:  116:					      int next_state_log_idx);
        -:  117:static reg_errcode_t merge_state_array (re_dfa_t *dfa, re_dfastate_t **dst,
        -:  118:					re_dfastate_t **src, int num);
        -:  119:static re_dfastate_t *transit_state (reg_errcode_t *err, const regex_t *preg,
        -:  120:				     re_match_context_t *mctx,
        -:  121:				     re_dfastate_t *state, int fl_search);
        -:  122:static reg_errcode_t check_subexp_matching_top (re_dfa_t *dfa,
        -:  123:						re_match_context_t *mctx,
        -:  124:						re_node_set *cur_nodes,
        -:  125:						int str_idx);
        -:  126:static re_dfastate_t *transit_state_sb (reg_errcode_t *err, const regex_t *preg,
        -:  127:					re_dfastate_t *pstate,
        -:  128:					int fl_search,
        -:  129:					re_match_context_t *mctx);
        -:  130:#ifdef RE_ENABLE_I18N
        -:  131:static reg_errcode_t transit_state_mb (const regex_t *preg,
        -:  132:				       re_dfastate_t *pstate,
        -:  133:				       re_match_context_t *mctx);
        -:  134:#endif /* RE_ENABLE_I18N */
        -:  135:static reg_errcode_t transit_state_bkref (const regex_t *preg,
        -:  136:					  re_dfastate_t *pstate,
        -:  137:					  re_match_context_t *mctx);
        -:  138:static reg_errcode_t transit_state_bkref_loop (const regex_t *preg,
        -:  139:					       re_node_set *nodes,
        -:  140:					       re_match_context_t *mctx);
        -:  141:static reg_errcode_t get_subexp (const regex_t *preg, re_match_context_t *mctx,
        -:  142:				 int bkref_node,
        -:  143:				 int bkref_str_idx, int subexp_idx);
        -:  144:static reg_errcode_t get_subexp_sub (const regex_t *preg,
        -:  145:				     re_match_context_t *mctx,
        -:  146:				     re_sub_match_top_t *sub_top,
        -:  147:				     re_sub_match_last_t *sub_last,
        -:  148:				     int bkref_node, int bkref_str,
        -:  149:				     int subexp_idx);
        -:  150:static int find_subexp_node (re_dfa_t *dfa, re_node_set *nodes,
        -:  151:			     int subexp_idx, int fl_open);
        -:  152:static reg_errcode_t check_arrival (const regex_t *preg,
        -:  153:				    re_match_context_t *mctx,
        -:  154:				    re_sub_match_top_t *sub_top,
        -:  155:				    re_sub_match_last_t *sub_last,
        -:  156:				    int bkref_node, int bkref_str);
        -:  157:static reg_errcode_t expand_eclosures (re_dfa_t *dfa, re_node_set *cur_nodes,
        -:  158:				       int ex_subexp, int fl_open);
        -:  159:static reg_errcode_t expand_eclosures_sub (re_dfa_t *dfa, re_node_set *dst_nodes,
        -:  160:					   int target, int ex_subexp, int fl_open);
        -:  161:static reg_errcode_t expand_bkref_cache (const regex_t *preg,
        -:  162:					 re_match_context_t *mctx,
        -:  163:					 re_sub_match_top_t *sub_top,
        -:  164:					 re_sub_match_last_t *sub_last,
        -:  165:					 re_node_set *cur_nodes, int cur_str,
        -:  166:					 int last_str, int ex_subexp,
        -:  167:					 int fl_open);
        -:  168:static re_dfastate_t **build_trtable (const regex_t *dfa,
        -:  169:				      const re_dfastate_t *state,
        -:  170:				      int fl_search);
        -:  171:#ifdef RE_ENABLE_I18N
        -:  172:static int check_node_accept_bytes (const regex_t *preg, int node_idx,
        -:  173:				    const re_string_t *input, int idx);
        -:  174:# ifdef _LIBC
        -:  175:static unsigned int find_collation_sequence_value (const unsigned char *mbs,
        -:  176:						   size_t name_len);
        -:  177:# endif /* _LIBC */
        -:  178:#endif /* RE_ENABLE_I18N */
        -:  179:static int group_nodes_into_DFAstates (const regex_t *dfa,
        -:  180:				       const re_dfastate_t *state,
        -:  181:				       re_node_set *states_node,
        -:  182:				       bitset *states_ch);
        -:  183:static int check_node_accept (const regex_t *preg, const re_token_t *node,
        -:  184:			      const re_match_context_t *mctx, int idx);
        -:  185:static reg_errcode_t extend_buffers (re_match_context_t *mctx);
        -:  186:static inline int my_memcmp (char *s1, char *s2, unsigned int l);
        -:  187:
        -:  188:/* Entry point for POSIX code.  */
        -:  189:
        -:  190:/* regexec searches for a given pattern, specified by PREG, in the
        -:  191:   string STRING.
        -:  192:
        -:  193:   If NMATCH is zero or REG_NOSUB was set in the cflags argument to
        -:  194:   `regcomp', we ignore PMATCH.  Otherwise, we assume PMATCH has at
        -:  195:   least NMATCH elements, and we set them to the offsets of the
        -:  196:   corresponding matched substrings.
        -:  197:
        -:  198:   EFLAGS specifies `execution flags' which affect matching: if
        -:  199:   REG_NOTBOL is set, then ^ does not match at the beginning of the
        -:  200:   string; if REG_NOTEOL is set, then $ does not match at the end.
        -:  201:
        -:  202:   We return 0 if we find a match and REG_NOMATCH if not.  */
        -:  203:
        -:  204:int
function regexec called 0 returned 0% blocks executed 0%
    #####:  205:regexec (preg, string, nmatch, pmatch, eflags)
        -:  206:    const regex_t *__restrict preg;
        -:  207:    const char *__restrict string;
        -:  208:    size_t nmatch;
        -:  209:    regmatch_t pmatch[];
        -:  210:    int eflags;
        -:  211:{
        -:  212:  reg_errcode_t err;
    #####:  213:  int length = strlen (string);
    #####:  214:  if (preg->no_sub)
branch  0 never executed
branch  1 never executed
    #####:  215:    err = re_search_internal (preg, string, length, 0, length, length, 0,
call    0 never executed
        -:  216:			      NULL, eflags);
        -:  217:  else
    #####:  218:    err = re_search_internal (preg, string, length, 0, length, length, nmatch,
call    0 never executed
        -:  219:			      pmatch, eflags);
    #####:  220:  return err != REG_NOERROR;
        -:  221:}
        -:  222:#ifdef _LIBC
        -:  223:weak_alias (__regexec, regexec)
        -:  224:#endif
        -:  225:
        -:  226:/* Entry points for GNU code.  */
        -:  227:
        -:  228:/* re_match, re_search, re_match_2, re_search_2
        -:  229:
        -:  230:   The former two functions operate on STRING with length LENGTH,
        -:  231:   while the later two operate on concatenation of STRING1 and STRING2
        -:  232:   with lengths LENGTH1 and LENGTH2, respectively.
        -:  233:
        -:  234:   re_match() matches the compiled pattern in BUFP against the string,
        -:  235:   starting at index START.
        -:  236:
        -:  237:   re_search() first tries matching at index START, then it tries to match
        -:  238:   starting from index START + 1, and so on.  The last start position tried
        -:  239:   is START + RANGE.  (Thus RANGE = 0 forces re_search to operate the same
        -:  240:   way as re_match().)
        -:  241:
        -:  242:   The parameter STOP of re_{match,search}_2 specifies that no match exceeding
        -:  243:   the first STOP characters of the concatenation of the strings should be
        -:  244:   concerned.
        -:  245:
        -:  246:   If REGS is not NULL, and BUFP->no_sub is not set, the offsets of the match
        -:  247:   and all groups is stroed in REGS.  (For the "_2" variants, the offsets are
        -:  248:   computed relative to the concatenation, not relative to the individual
        -:  249:   strings.)
        -:  250:
        -:  251:   On success, re_match* functions return the length of the match, re_search*
        -:  252:   return the position of the start of the match.  Return value -1 means no
        -:  253:   match was found and -2 indicates an internal error.  */
        -:  254:
        -:  255:int
function re_match called 0 returned 0% blocks executed 0%
    #####:  256:re_match (bufp, string, length, start, regs)
        -:  257:    struct re_pattern_buffer *bufp;
        -:  258:    const char *string;
        -:  259:    int length, start;
        -:  260:    struct re_registers *regs;
        -:  261:{
    #####:  262:  return re_search_stub (bufp, string, length, start, 0, length, regs, 1);
call    0 never executed
        -:  263:}
        -:  264:#ifdef _LIBC
        -:  265:weak_alias (__re_match, re_match)
        -:  266:#endif
        -:  267:
        -:  268:int
function re_search called 49072 returned 100% blocks executed 100%
    49072:  269:re_search (bufp, string, length, start, range, regs)
        -:  270:    struct re_pattern_buffer *bufp;
        -:  271:    const char *string;
        -:  272:    int length, start, range;
        -:  273:    struct re_registers *regs;
        -:  274:{
    49072:  275:  return re_search_stub (bufp, string, length, start, range, length, regs, 0);
call    0 returned 49072
        -:  276:}
        -:  277:#ifdef _LIBC
        -:  278:weak_alias (__re_search, re_search)
        -:  279:#endif
        -:  280:
        -:  281:int
function re_match_2 called 0 returned 0% blocks executed 0%
    #####:  282:re_match_2 (bufp, string1, length1, string2, length2, start, regs, stop)
        -:  283:    struct re_pattern_buffer *bufp;
        -:  284:    const char *string1, *string2;
        -:  285:    int length1, length2, start, stop;
        -:  286:    struct re_registers *regs;
        -:  287:{
    #####:  288:  return re_search_2_stub (bufp, string1, length1, string2, length2,
call    0 never executed
        -:  289:			   start, 0, regs, stop, 1);
        -:  290:}
        -:  291:#ifdef _LIBC
        -:  292:weak_alias (__re_match_2, re_match_2)
        -:  293:#endif
        -:  294:
        -:  295:int
function re_search_2 called 0 returned 0% blocks executed 0%
    #####:  296:re_search_2 (bufp, string1, length1, string2, length2, start, range, regs, stop)
        -:  297:    struct re_pattern_buffer *bufp;
        -:  298:    const char *string1, *string2;
        -:  299:    int length1, length2, start, range, stop;
        -:  300:    struct re_registers *regs;
        -:  301:{
    #####:  302:  return re_search_2_stub (bufp, string1, length1, string2, length2,
call    0 never executed
        -:  303:			   start, range, regs, stop, 0);
        -:  304:}
        -:  305:#ifdef _LIBC
        -:  306:weak_alias (__re_search_2, re_search_2)
        -:  307:#endif
        -:  308:
        -:  309:static int
function re_search_2_stub called 0 returned 0% blocks executed 0%
    #####:  310:re_search_2_stub (bufp, string1, length1, string2, length2, start, range, regs,
        -:  311:		  stop, ret_len)
        -:  312:    struct re_pattern_buffer *bufp;
        -:  313:    const char *string1, *string2;
        -:  314:    int length1, length2, start, range, stop, ret_len;
        -:  315:    struct re_registers *regs;
        -:  316:{
        -:  317:  const char *str;
        -:  318:  int rval;
    #####:  319:  int len = length1 + length2;
    #####:  320:  int free_str = 0;
        -:  321:
    #####:  322:  if (BE (length1 < 0 || length2 < 0 || stop < 0, 0))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:  323:    return -2;
        -:  324:
        -:  325:  /* Concatenate the strings.  */
    #####:  326:  if (length2 > 0)
branch  0 never executed
branch  1 never executed
    #####:  327:    if (length1 > 0)
branch  0 never executed
branch  1 never executed
        -:  328:      {
    #####:  329:	char *s = re_malloc (char, len);
        -:  330:
    #####:  331:	if (BE (s == NULL, 0))
branch  0 never executed
branch  1 never executed
    #####:  332:	  return -2;
    #####:  333:	memcpy (s, string1, length1);
    #####:  334:	memcpy (s + length1, string2, length2);
    #####:  335:	str = s;
    #####:  336:	free_str = 1;
        -:  337:      }
        -:  338:    else
    #####:  339:      str = string2;
        -:  340:  else
    #####:  341:    str = string1;
        -:  342:
    #####:  343:  rval = re_search_stub (bufp, str, len, start, range, stop, regs,
call    0 never executed
        -:  344:			 ret_len);
    #####:  345:  if (free_str)
branch  0 never executed
branch  1 never executed
    #####:  346:    re_free ((char *) str);
    #####:  347:  return rval;
        -:  348:}
        -:  349:
        -:  350:/* The parameters have the same meaning as those of re_search.
        -:  351:   Additional parameters:
        -:  352:   If RET_LEN is nonzero the length of the match is returned (re_match style);
        -:  353:   otherwise the position of the match is returned.  */
        -:  354:
        -:  355:static int
function re_search_stub called 49072 returned 100% blocks executed 61%
    49072:  356:re_search_stub (bufp, string, length, start, range, stop, regs, ret_len)
        -:  357:    struct re_pattern_buffer *bufp;
        -:  358:    const char *string;
        -:  359:    int length, start, range, stop, ret_len;
        -:  360:    struct re_registers *regs;
        -:  361:{
        -:  362:  reg_errcode_t result;
        -:  363:  regmatch_t *pmatch;
        -:  364:  int nregs, rval;
    49072:  365:  int eflags = 0;
        -:  366:
        -:  367:  /* Check for out-of-range.  */
    49072:  368:  if (BE (start < 0 || start > length, 0))
branch  0 taken 49072 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 49072
    #####:  369:    return -1;
    49072:  370:  if (BE (start + range > length, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 49072
    #####:  371:    range = length - start;
    49072:  372:  else if (BE (start + range < 0, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 49072
    #####:  373:    range = -start;
        -:  374:
    49072:  375:  eflags |= (bufp->not_bol) ? REG_NOTBOL : 0;
    49072:  376:  eflags |= (bufp->not_eol) ? REG_NOTEOL : 0;
        -:  377:
        -:  378:  /* Compile fastmap if we haven't yet.  */
   49072*:  379:  if (range > 0 && bufp->fastmap != NULL && !bufp->fastmap_accurate)
branch  0 taken 33477 (fallthrough)
branch  1 taken 15595
branch  2 taken 0 (fallthrough)
branch  3 taken 33477
branch  4 never executed
branch  5 never executed
    #####:  380:    re_compile_fastmap (bufp);
call    0 never executed
        -:  381:
    49072:  382:  if (BE (bufp->no_sub, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 49072
    #####:  383:    regs = NULL;
        -:  384:
        -:  385:  /* We need at least 1 register.  */
    49072:  386:  if (regs == NULL)
branch  0 taken 31896 (fallthrough)
branch  1 taken 17176
    31896:  387:    nregs = 1;
   17176*:  388:  else if (BE (bufp->regs_allocated == REGS_FIXED &&
branch  0 taken 0 (fallthrough)
branch  1 taken 17176
branch  2 never executed
branch  3 never executed
        -:  389:	       regs->num_regs < bufp->re_nsub + 1, 0))
        -:  390:    {
    #####:  391:      nregs = regs->num_regs;
    #####:  392:      if (BE (nregs < 1, 0))
branch  0 never executed
branch  1 never executed
        -:  393:	{
        -:  394:	  /* Nothing can be copied to regs.  */
    #####:  395:	  regs = NULL;
    #####:  396:	  nregs = 1;
        -:  397:	}
        -:  398:    }
        -:  399:  else
    17176:  400:    nregs = bufp->re_nsub + 1;
    49072:  401:  pmatch = re_malloc (regmatch_t, nregs);
    49072:  402:  if (BE (pmatch == NULL, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 49072
    #####:  403:    return -2;
        -:  404:
    49072:  405:  result = re_search_internal (bufp, string, length, start, range, stop,
call    0 returned 49072
        -:  406:			       nregs, pmatch, eflags);
        -:  407:
    49072:  408:  rval = 0;
        -:  409:
        -:  410:  /* I hope we needn't fill ther regs with -1's when no match was found.  */
    49072:  411:  if (result != REG_NOERROR)
branch  0 taken 41953 (fallthrough)
branch  1 taken 7119
    41953:  412:    rval = -1;
     7119:  413:  else if (regs != NULL)
branch  0 taken 4838 (fallthrough)
branch  1 taken 2281
        -:  414:    {
        -:  415:      /* If caller wants register contents data back, copy them.  */
     9676:  416:      bufp->regs_allocated = re_copy_regs (regs, pmatch, nregs,
     4838:  417:					   bufp->regs_allocated);
call    0 returned 4838
     4838:  418:      if (BE (bufp->regs_allocated == REGS_UNALLOCATED, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 4838
    #####:  419:	rval = -2;
        -:  420:    }
        -:  421:
    49072:  422:  if (BE (rval == 0, 1))
branch  0 taken 7119 (fallthrough)
branch  1 taken 41953
        -:  423:    {
     7119:  424:      if (ret_len)
branch  0 taken 0 (fallthrough)
branch  1 taken 7119
        -:  425:	{
    #####:  426:	  assert (pmatch[0].rm_so == start);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  427:	  rval = pmatch[0].rm_eo - start;
        -:  428:	}
        -:  429:      else
     7119:  430:	rval = pmatch[0].rm_so;
        -:  431:    }
    49072:  432:  re_free (pmatch);
    49072:  433:  return rval;
        -:  434:}
        -:  435:
        -:  436:static unsigned
function re_copy_regs called 4838 returned 100% blocks executed 50%
     4838:  437:re_copy_regs (regs, pmatch, nregs, regs_allocated)
        -:  438:    struct re_registers *regs;
        -:  439:    regmatch_t *pmatch;
        -:  440:    int nregs, regs_allocated;
        -:  441:{
     4838:  442:  int rval = REGS_REALLOCATE;
        -:  443:  int i;
     4838:  444:  int need_regs = nregs + 1;
        -:  445:  /* We need one extra element beyond `num_regs' for the `-1' marker GNU code
        -:  446:     uses.  */
        -:  447:
        -:  448:  /* Have the register data arrays been allocated?  */
     4838:  449:  if (regs_allocated == REGS_UNALLOCATED)
branch  0 taken 211 (fallthrough)
branch  1 taken 4627
        -:  450:    { /* No.  So allocate them with malloc.  */
      211:  451:      regs->start = re_malloc (regoff_t, need_regs);
      211:  452:      if (BE (regs->start == NULL, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 211
    #####:  453:	return REGS_UNALLOCATED;
      211:  454:      regs->end = re_malloc (regoff_t, need_regs);
      211:  455:      if (BE (regs->end == NULL, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 211
        -:  456:	{
    #####:  457:	  re_free (regs->start);
    #####:  458:	  return REGS_UNALLOCATED;
        -:  459:	}
      211:  460:      regs->num_regs = need_regs;
        -:  461:    }
     4627:  462:  else if (regs_allocated == REGS_REALLOCATE)
branch  0 taken 4627 (fallthrough)
branch  1 taken 0
        -:  463:    { /* Yes.  If we need more elements than were already
        -:  464:	 allocated, reallocate them.  If we need fewer, just
        -:  465:	 leave it alone.  */
     4627:  466:      if (need_regs > regs->num_regs)
branch  0 taken 0 (fallthrough)
branch  1 taken 4627
        -:  467:	{
    #####:  468:	  regs->start = re_realloc (regs->start, regoff_t, need_regs);
    #####:  469:	  if (BE (regs->start == NULL, 0))
branch  0 never executed
branch  1 never executed
        -:  470:	    {
    #####:  471:	      if (regs->end != NULL)
branch  0 never executed
branch  1 never executed
    #####:  472:		re_free (regs->end);
    #####:  473:	      return REGS_UNALLOCATED;
        -:  474:	    }
    #####:  475:	  regs->end = re_realloc (regs->end, regoff_t, need_regs);
    #####:  476:	  if (BE (regs->end == NULL, 0))
branch  0 never executed
branch  1 never executed
        -:  477:	    {
    #####:  478:	      re_free (regs->start);
    #####:  479:	      return REGS_UNALLOCATED;
        -:  480:	    }
    #####:  481:	  regs->num_regs = need_regs;
        -:  482:	}
        -:  483:    }
        -:  484:  else
        -:  485:    {
    #####:  486:      assert (regs_allocated == REGS_FIXED);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  487:      /* This function may not be called with REGS_FIXED and nregs too big.  */
    #####:  488:      assert (regs->num_regs >= nregs);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  489:      rval = REGS_FIXED;
        -:  490:    }
        -:  491:
        -:  492:  /* Copy the regs.  */
     9733:  493:  for (i = 0; i < nregs; ++i)
branch  0 taken 4895
branch  1 taken 4838 (fallthrough)
        -:  494:    {
     4895:  495:      regs->start[i] = pmatch[i].rm_so;
     4895:  496:      regs->end[i] = pmatch[i].rm_eo;
        -:  497:    }
     9676:  498:  for ( ; i < regs->num_regs; ++i)
branch  0 taken 4838
branch  1 taken 4838 (fallthrough)
     4838:  499:    regs->start[i] = regs->end[i] = -1;
        -:  500:
     4838:  501:  return rval;
        -:  502:}
        -:  503:
        -:  504:/* Set REGS to hold NUM_REGS registers, storing them in STARTS and
        -:  505:   ENDS.  Subsequent matches using PATTERN_BUFFER and REGS will use
        -:  506:   this memory for recording register information.  STARTS and ENDS
        -:  507:   must be allocated using the malloc library routine, and must each
        -:  508:   be at least NUM_REGS * sizeof (regoff_t) bytes long.
        -:  509:
        -:  510:   If NUM_REGS == 0, then subsequent matches should allocate their own
        -:  511:   register data.
        -:  512:
        -:  513:   Unless this function is called, the first search or match using
        -:  514:   PATTERN_BUFFER will allocate its own register data, without
        -:  515:   freeing the old data.  */
        -:  516:
        -:  517:void
function re_set_registers called 0 returned 0% blocks executed 0%
    #####:  518:re_set_registers (bufp, regs, num_regs, starts, ends)
        -:  519:    struct re_pattern_buffer *bufp;
        -:  520:    struct re_registers *regs;
        -:  521:    unsigned num_regs;
        -:  522:    regoff_t *starts, *ends;
        -:  523:{
    #####:  524:  if (num_regs)
branch  0 never executed
branch  1 never executed
        -:  525:    {
    #####:  526:      bufp->regs_allocated = REGS_REALLOCATE;
    #####:  527:      regs->num_regs = num_regs;
    #####:  528:      regs->start = starts;
    #####:  529:      regs->end = ends;
        -:  530:    }
        -:  531:  else
        -:  532:    {
    #####:  533:      bufp->regs_allocated = REGS_UNALLOCATED;
    #####:  534:      regs->num_regs = 0;
    #####:  535:      regs->start = regs->end = (regoff_t *) 0;
        -:  536:    }
    #####:  537:}
        -:  538:#ifdef _LIBC
        -:  539:weak_alias (__re_set_registers, re_set_registers)
        -:  540:#endif
        -:  541:
        -:  542:/* Entry points compatible with 4.2 BSD regex library.  We don't define
        -:  543:   them unless specifically requested.  */
        -:  544:
        -:  545:#if defined _REGEX_RE_COMP || defined _LIBC
        -:  546:int
        -:  547:# ifdef _LIBC
        -:  548:weak_function
        -:  549:# endif
        -:  550:re_exec (s)
        -:  551:     const char *s;
        -:  552:{
        -:  553:  return 0 == regexec (&re_comp_buf, s, 0, NULL, 0);
        -:  554:}
        -:  555:#endif /* _REGEX_RE_COMP */
        -:  556:
        -:  557:static re_node_set empty_set;
        -:  558:
        -:  559:/* Internal entry point.  */
        -:  560:
        -:  561:/* Searches for a compiled pattern PREG in the string STRING, whose
        -:  562:   length is LENGTH.  NMATCH, PMATCH, and EFLAGS have the same
        -:  563:   mingings with regexec.  START, and RANGE have the same meanings
        -:  564:   with re_search.
        -:  565:   Return REG_NOERROR if we find a match, and REG_NOMATCH if not,
        -:  566:   otherwise return the error code.
        -:  567:   Note: We assume front end functions already check ranges.
        -:  568:   (START + RANGE >= 0 && START + RANGE <= LENGTH)  */
        -:  569:
        -:  570:reg_errcode_t
function re_search_internal called 49072 returned 100% blocks executed 52%
    49072:  571:re_search_internal (preg, string, length, start, range, stop, nmatch, pmatch,
        -:  572:		    eflags)
        -:  573:    const regex_t *preg;
        -:  574:    const char *string;
        -:  575:    int length, start, range, stop, eflags;
        -:  576:    size_t nmatch;
        -:  577:    regmatch_t pmatch[];
        -:  578:{
        -:  579:  reg_errcode_t err;
    49072:  580:  re_dfa_t *dfa = (re_dfa_t *)preg->buffer;
        -:  581:  re_string_t input;
        -:  582:  int left_lim, right_lim, incr;
    49072:  583:  int fl_longest_match, match_first, match_last = -1;
        -:  584:  int fast_translate, sb;
        -:  585:  re_match_context_t mctx;
    #####:  586:  char *fastmap = ((preg->fastmap != NULL && preg->fastmap_accurate
branch  0 never executed
branch  1 never executed
   49072*:  587:		    && range && !preg->can_be_null) ? preg->fastmap : NULL);
branch  0 taken 0 (fallthrough)
branch  1 taken 49072
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:  588:
        -:  589:  /* Check if the DFA haven't been compiled.  */
   49072*:  590:  if (BE (preg->used == 0 || dfa->init_state == NULL
branch  0 taken 49072 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 49072
branch  4 taken 49072 (fallthrough)
branch  5 taken 0
branch  6 taken 0 (fallthrough)
branch  7 taken 49072
branch  8 taken 49072 (fallthrough)
branch  9 taken 0
branch 10 taken 0 (fallthrough)
branch 11 taken 49072
branch 12 taken 49072 (fallthrough)
branch 13 taken 0
branch 14 taken 0 (fallthrough)
branch 15 taken 49072
        -:  591:	  || dfa->init_state_word == NULL || dfa->init_state_nl == NULL
        -:  592:	  || dfa->init_state_begbuf == NULL, 0))
    #####:  593:    return REG_NOMATCH;
        -:  594:
    49072:  595:  re_node_set_init_empty (&empty_set);
    49072:  596:  memset (&mctx, '\0', sizeof (re_match_context_t));
        -:  597:
        -:  598:  /* We must check the longest matching, if nmatch > 0.  */
   49072*:  599:  fl_longest_match = (nmatch != 0 || dfa->nbackref);
branch  0 taken 0 (fallthrough)
branch  1 taken 49072
branch  2 never executed
branch  3 never executed
        -:  600:
    49072:  601:  err = re_string_allocate (&input, string, length, dfa->nodes_len + 1,
    49072:  602:			    preg->translate, preg->syntax & RE_ICASE);
call    0 returned 49072
    49072:  603:  if (BE (err != REG_NOERROR, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 49072
    #####:  604:    goto free_return;
    49072:  605:  input.stop = stop;
        -:  606:
    49072:  607:  err = match_ctx_init (&mctx, eflags, &input, dfa->nbackref * 2);
call    0 returned 49072
    49072:  608:  if (BE (err != REG_NOERROR, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 49072
    #####:  609:    goto free_return;
        -:  610:
        -:  611:  /* We will log all the DFA states through which the dfa pass,
        -:  612:     if nmatch > 1, or this dfa has "multibyte node", which is a
        -:  613:     back-reference or a node which can accept multibyte character or
        -:  614:     multi character collating element.  */
    49072:  615:  if (nmatch > 1 || dfa->has_mb_node)
branch  0 taken 48808 (fallthrough)
branch  1 taken 264
branch  2 taken 0 (fallthrough)
branch  3 taken 48808
        -:  616:    {
      264:  617:      mctx.state_log = re_malloc (re_dfastate_t *, dfa->nodes_len + 1);
      264:  618:      if (BE (mctx.state_log == NULL, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 264
        -:  619:	{
    #####:  620:	  err = REG_ESPACE;
    #####:  621:	  goto free_return;
        -:  622:	}
        -:  623:    }
        -:  624:  else
    48808:  625:    mctx.state_log = NULL;
        -:  626:
        -:  627:#ifdef DEBUG
        -:  628:  /* We assume front-end functions already check them.  */
        -:  629:  assert (start + range >= 0 && start + range <= length);
        -:  630:#endif
        -:  631:
    49072:  632:  match_first = start;
    98144:  633:  input.tip_context = ((eflags & REG_NOTBOL) ? CONTEXT_BEGBUF
   49072*:  634:		       : CONTEXT_NEWLINE | CONTEXT_BEGBUF);
branch  0 taken 0 (fallthrough)
branch  1 taken 49072
        -:  635:
        -:  636:  /* Check incrementally whether of not the input string match.  */
   49072*:  637:  incr = (range < 0) ? -1 : 1;
branch  0 taken 0 (fallthrough)
branch  1 taken 49072
   49072*:  638:  left_lim = (range < 0) ? start + range : start;
branch  0 taken 0 (fallthrough)
branch  1 taken 49072
   49072*:  639:  right_lim = (range < 0) ? start : start + range;
branch  0 taken 49072 (fallthrough)
branch  1 taken 0
    49072:  640:  sb = MB_CUR_MAX == 1;
call    0 returned 49072
   49072*:  641:  fast_translate = sb || !(preg->syntax & RE_ICASE || preg->translate);
branch  0 taken 0 (fallthrough)
branch  1 taken 49072
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:  642:
        -:  643:  for (;;)
        -:  644:    {
        -:  645:      /* At first get the current byte from input string.  */
   676465:  646:      if (fastmap)
branch  0 taken 0 (fallthrough)
branch  1 taken 676465
        -:  647:	{
    #####:  648:	  if (BE (fast_translate, 1))
branch  0 never executed
branch  1 never executed
        -:  649:	    {
    #####:  650:	      unsigned RE_TRANSLATE_TYPE t
        -:  651:		= (unsigned RE_TRANSLATE_TYPE) preg->translate;
    #####:  652:	      if (BE (range >= 0, 1))
branch  0 never executed
branch  1 never executed
        -:  653:		{
    #####:  654:		  if (BE (t != NULL, 0))
branch  0 never executed
branch  1 never executed
        -:  655:		    {
    #####:  656:		      while (BE (match_first < right_lim, 1)
    #####:  657:			     && !fastmap[t[(unsigned char) string[match_first]]])
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  658:			++match_first;
        -:  659:		    }
        -:  660:		  else
        -:  661:		    {
    #####:  662:		      while (BE (match_first < right_lim, 1)
    #####:  663:			     && !fastmap[(unsigned char) string[match_first]])
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  664:			++match_first;
        -:  665:		    }
    #####:  666:		  if (BE (match_first == right_lim, 0))
branch  0 never executed
branch  1 never executed
        -:  667:		    {
    #####:  668:		      int ch = match_first >= length
    #####:  669:			       ? 0 : (unsigned char) string[match_first];
branch  0 never executed
branch  1 never executed
    #####:  670:		      if (!fastmap[t ? t[ch] : ch])
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  671:			break;
        -:  672:		    }
        -:  673:		}
        -:  674:	      else
        -:  675:		{
    #####:  676:		  while (match_first >= left_lim)
branch  0 never executed
branch  1 never executed
        -:  677:		    {
    #####:  678:		      int ch = match_first >= length
    #####:  679:			       ? 0 : (unsigned char) string[match_first];
branch  0 never executed
branch  1 never executed
    #####:  680:		      if (fastmap[t ? t[ch] : ch])
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  681:			break;
    #####:  682:		      --match_first;
        -:  683:		    }
    #####:  684:		  if (match_first < left_lim)
branch  0 never executed
branch  1 never executed
    #####:  685:		    break;
        -:  686:		}
        -:  687:	    }
        -:  688:	  else
        -:  689:	    {
        -:  690:	      int ch;
        -:  691:
        -:  692:	      do
        -:  693:		{
        -:  694:		  /* In this case, we can't determine easily the current byte,
        -:  695:		     since it might be a component byte of a multibyte
        -:  696:		     character.  Then we use the constructed buffer
        -:  697:		     instead.  */
        -:  698:		  /* If MATCH_FIRST is out of the valid range, reconstruct the
        -:  699:		     buffers.  */
    #####:  700:		  if (input.raw_mbs_idx + input.valid_len <= match_first
branch  0 never executed
branch  1 never executed
    #####:  701:		      || match_first < input.raw_mbs_idx)
branch  0 never executed
branch  1 never executed
        -:  702:		    {
    #####:  703:		      err = re_string_reconstruct (&input, match_first, eflags,
    #####:  704:						   preg->newline_anchor);
call    0 never executed
    #####:  705:		      if (BE (err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####:  706:			goto free_return;
        -:  707:		    }
        -:  708:		  /* If MATCH_FIRST is out of the buffer, leave it as '\0'.
        -:  709:		     Note that MATCH_FIRST must not be smaller than 0.  */
    #####:  710:		  ch = ((match_first >= length) ? 0
    #####:  711:		       : re_string_byte_at (&input,
branch  0 never executed
branch  1 never executed
        -:  712:					    match_first - input.raw_mbs_idx));
    #####:  713:		  if (fastmap[ch])
branch  0 never executed
branch  1 never executed
    #####:  714:		    break;
    #####:  715:		  match_first += incr;
        -:  716:		}
    #####:  717:	      while (match_first >= left_lim && match_first <= right_lim);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  718:	      if (! fastmap[ch])
branch  0 never executed
branch  1 never executed
    #####:  719:		break;
        -:  720:	    }
        -:  721:	}
        -:  722:
        -:  723:      /* Reconstruct the buffers so that the matcher can assume that
        -:  724:	 the matching starts from the begining of the buffer.  */
   676465:  725:      err = re_string_reconstruct (&input, match_first, eflags,
   676465:  726:				   preg->newline_anchor);
call    0 returned 676465
   676465:  727:      if (BE (err != REG_NOERROR, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 676465
    #####:  728:	goto free_return;
        -:  729:#ifdef RE_ENABLE_I18N
        -:  730:     /* Eliminate it when it is a component of a multibyte character
        -:  731:	 and isn't the head of a multibyte character.  */
        -:  732:      if (sb || re_string_first_byte (&input, 0))
        -:  733:#endif
        -:  734:	{
        -:  735:	  /* It seems to be appropriate one, then use the matcher.  */
        -:  736:	  /* We assume that the matching starts from 0.  */
   676465:  737:	  mctx.state_log_top = mctx.nbkref_ents = mctx.max_mb_elem_len = 0;
   676465:  738:	  match_last = check_matching (preg, &mctx, 0, fl_longest_match);
call    0 returned 676465
   676465:  739:	  if (match_last != -1)
branch  0 taken 7119 (fallthrough)
branch  1 taken 669346
        -:  740:	    {
     7119:  741:	      if (BE (match_last == -2, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 7119
        -:  742:		{
    #####:  743:		  err = REG_ESPACE;
    #####:  744:		  goto free_return;
        -:  745:		}
        -:  746:	      else
        -:  747:		{
     7119:  748:		  mctx.match_last = match_last;
     7119:  749:		  if ((!preg->no_sub && nmatch > 1) || dfa->nbackref)
branch  0 taken 7119 (fallthrough)
branch  1 taken 0
branch  2 taken 7090 (fallthrough)
branch  3 taken 29
branch  4 taken 0 (fallthrough)
branch  5 taken 7090
        -:  750:		    {
       29:  751:		      re_dfastate_t *pstate = mctx.state_log[match_last];
       29:  752:		      mctx.last_node = check_halt_state_context (preg, pstate,
call    0 returned 29
        -:  753:								 &mctx, match_last);
        -:  754:		    }
     7119:  755:		  if ((!preg->no_sub && nmatch > 1 && dfa->has_plural_match)
branch  0 taken 7119 (fallthrough)
branch  1 taken 0
branch  2 taken 29 (fallthrough)
branch  3 taken 7090
branch  4 taken 0 (fallthrough)
branch  5 taken 29
     7090:  756:		      || dfa->nbackref)
branch  0 taken 0 (fallthrough)
branch  1 taken 7090
        -:  757:		    {
       29:  758:		      err = prune_impossible_nodes (preg, &mctx);
call    0 returned 29
       29:  759:		      if (err == REG_NOERROR)
branch  0 taken 29 (fallthrough)
branch  1 taken 0
       29:  760:			break;
    #####:  761:		      if (BE (err != REG_NOMATCH, 0))
branch  0 never executed
branch  1 never executed
    #####:  762:			goto free_return;
        -:  763:		    }
        -:  764:		  else
        -:  765:		    break; /* We found a matching.  */
        -:  766:		}
        -:  767:	    }
        -:  768:	}
        -:  769:      /* Update counter.  */
   669346:  770:      match_first += incr;
   669346:  771:      if (match_first < left_lim || right_lim < match_first)
branch  0 taken 669346 (fallthrough)
branch  1 taken 0
branch  2 taken 627393 (fallthrough)
branch  3 taken 41953
        -:  772:	break;
        -:  773:    }
        -:  774:
        -:  775:  /* Set pmatch[] if we need.  */
    49072:  776:  if (match_last != -1 && nmatch > 0)
branch  0 taken 7119 (fallthrough)
branch  1 taken 41953
branch  2 taken 7119 (fallthrough)
branch  3 taken 0
        -:  777:    {
        -:  778:      int reg_idx;
        -:  779:
        -:  780:      /* Initialize registers.  */
    14295:  781:      for (reg_idx = 0; reg_idx < nmatch; ++reg_idx)
branch  0 taken 7176
branch  1 taken 7119 (fallthrough)
     7176:  782:	pmatch[reg_idx].rm_so = pmatch[reg_idx].rm_eo = -1;
        -:  783:
        -:  784:      /* Set the points where matching start/end.  */
     7119:  785:      pmatch[0].rm_so = 0;
     7119:  786:      pmatch[0].rm_eo = mctx.match_last;
        -:  787:
     7119:  788:      if (!preg->no_sub && nmatch > 1)
branch  0 taken 7119 (fallthrough)
branch  1 taken 0
branch  2 taken 29 (fallthrough)
branch  3 taken 7090
        -:  789:	{
      29*:  790:	  err = set_regs (preg, &mctx, nmatch, pmatch,
call    0 returned 29
       29:  791:			  dfa->has_plural_match && dfa->nbackref > 0);
branch  0 taken 29 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 29
       29:  792:	  if (BE (err != REG_NOERROR, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 29
    #####:  793:	    goto free_return;
        -:  794:	}
        -:  795:
        -:  796:      /* At last, add the offset to the each registers, since we slided
        -:  797:	 the buffers so that We can assume that the matching starts from 0.  */
    14295:  798:      for (reg_idx = 0; reg_idx < nmatch; ++reg_idx)
branch  0 taken 7176
branch  1 taken 7119 (fallthrough)
     7176:  799:	if (pmatch[reg_idx].rm_so != -1)
branch  0 taken 7152 (fallthrough)
branch  1 taken 24
        -:  800:	  {
     7152:  801:	    pmatch[reg_idx].rm_so += match_first;
     7152:  802:	    pmatch[reg_idx].rm_eo += match_first;
        -:  803:	  }
        -:  804:    }
    49072:  805:  err = (match_last == -1) ? REG_NOMATCH : REG_NOERROR;
    49072:  806: free_return:
    49072:  807:  re_free (mctx.state_log);
    49072:  808:  if (dfa->nbackref)
branch  0 taken 0 (fallthrough)
branch  1 taken 49072
    #####:  809:    match_ctx_free (&mctx);
call    0 never executed
    49072:  810:  re_string_destruct (&input);
call    0 returned 49072
    49072:  811:  return err;
        -:  812:}
        -:  813:
        -:  814:static reg_errcode_t
function prune_impossible_nodes called 29 returned 100% blocks executed 30%
       29:  815:prune_impossible_nodes (preg, mctx)
        -:  816:     const regex_t *preg;
        -:  817:     re_match_context_t *mctx;
        -:  818:{
        -:  819:  int halt_node, match_last;
        -:  820:  reg_errcode_t ret;
       29:  821:  re_dfa_t *dfa = (re_dfa_t *)preg->buffer;
        -:  822:  re_dfastate_t **sifted_states;
       29:  823:  re_dfastate_t **lim_states = NULL;
        -:  824:  re_sift_context_t sctx;
        -:  825:#ifdef DEBUG
        -:  826:  assert (mctx->state_log != NULL);
        -:  827:#endif
       29:  828:  match_last = mctx->match_last;
       29:  829:  halt_node = mctx->last_node;
       29:  830:  sifted_states = re_malloc (re_dfastate_t *, match_last + 1);
       29:  831:  if (BE (sifted_states == NULL, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 29
        -:  832:    {
    #####:  833:      ret = REG_ESPACE;
    #####:  834:      goto free_return;
        -:  835:    }
       29:  836:  if (dfa->nbackref)
branch  0 taken 0 (fallthrough)
branch  1 taken 29
        -:  837:    {
    #####:  838:      lim_states = re_malloc (re_dfastate_t *, match_last + 1);
    #####:  839:      if (BE (lim_states == NULL, 0))
branch  0 never executed
branch  1 never executed
        -:  840:	{
    #####:  841:	  ret = REG_ESPACE;
    #####:  842:	  goto free_return;
        -:  843:	}
        -:  844:      while (1)
        -:  845:	{
    #####:  846:	  memset (lim_states, '\0',
    #####:  847:		  sizeof (re_dfastate_t *) * (match_last + 1));
    #####:  848:	  match_ctx_clear_flag (mctx);
call    0 never executed
    #####:  849:	  sift_ctx_init (&sctx, sifted_states, lim_states, halt_node,
call    0 never executed
        -:  850:			 match_last, 0);
    #####:  851:	  ret = sift_states_backward (preg, mctx, &sctx);
call    0 never executed
    #####:  852:	  re_node_set_free (&sctx.limits);
    #####:  853:	  if (BE (ret != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####:  854:	      goto free_return;
    #####:  855:	  if (sifted_states[0] != NULL || lim_states[0] != NULL)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  856:	    break;
        -:  857:	  do
        -:  858:	    {
    #####:  859:	      --match_last;
    #####:  860:	      if (match_last < 0)
branch  0 never executed
branch  1 never executed
        -:  861:		{
    #####:  862:		  ret = REG_NOMATCH;
    #####:  863:		  goto free_return;
        -:  864:		}
    #####:  865:	    } while (!mctx->state_log[match_last]->halt);
branch  0 never executed
branch  1 never executed
    #####:  866:	  halt_node = check_halt_state_context (preg,
    #####:  867:						mctx->state_log[match_last],
call    0 never executed
        -:  868:						mctx, match_last);
        -:  869:	}
    #####:  870:      ret = merge_state_array (dfa, sifted_states, lim_states,
call    0 never executed
        -:  871:			       match_last + 1);
    #####:  872:      re_free (lim_states);
    #####:  873:      lim_states = NULL;
    #####:  874:      if (BE (ret != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####:  875:	goto free_return;
        -:  876:    }
        -:  877:  else
        -:  878:    {
       29:  879:      sift_ctx_init (&sctx, sifted_states, lim_states, halt_node,
call    0 returned 29
        -:  880:		     match_last, 0);
       29:  881:      ret = sift_states_backward (preg, mctx, &sctx);
call    0 returned 29
       29:  882:      re_node_set_free (&sctx.limits);
       29:  883:      if (BE (ret != REG_NOERROR, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 29
    #####:  884:	goto free_return;
        -:  885:    }
       29:  886:  re_free (mctx->state_log);
       29:  887:  mctx->state_log = sifted_states;
       29:  888:  sifted_states = NULL;
       29:  889:  mctx->last_node = halt_node;
       29:  890:  mctx->match_last = match_last;
       29:  891:  ret = REG_NOERROR;
       29:  892: free_return:
       29:  893:  re_free (sifted_states);
       29:  894:  re_free (lim_states);
       29:  895:  return ret;
        -:  896:}
        -:  897:
        -:  898:/* Acquire an initial state and return it.
        -:  899:   We must select appropriate initial state depending on the context,
        -:  900:   since initial states may have constraints like "\<", "^", etc..  */
        -:  901:
        -:  902:static inline re_dfastate_t *
function acquire_init_state_context called 676465 returned 100% blocks executed 65%
   676465:  903:acquire_init_state_context (err, preg, mctx, idx)
        -:  904:     reg_errcode_t *err;
        -:  905:     const regex_t *preg;
        -:  906:     const re_match_context_t *mctx;
        -:  907:     int idx;
        -:  908:{
   676465:  909:  re_dfa_t *dfa = (re_dfa_t *) preg->buffer;
        -:  910:
   676465:  911:  *err = REG_NOERROR;
   676465:  912:  if (dfa->init_state->has_constraint)
branch  0 taken 169009 (fallthrough)
branch  1 taken 507456
        -:  913:    {
        -:  914:      unsigned int context;
   169009:  915:      context =  re_string_context_at (mctx->input, idx - 1, mctx->eflags,
   169009:  916:				       preg->newline_anchor);
call    0 returned 169009
   169009:  917:      if (IS_WORD_CONTEXT (context))
branch  0 taken 123613 (fallthrough)
branch  1 taken 45396
   123613:  918:	return dfa->init_state_word;
    45396:  919:      else if (IS_ORDINARY_CONTEXT (context))
branch  0 taken 33351 (fallthrough)
branch  1 taken 12045
    33351:  920:	return dfa->init_state;
    12045:  921:      else if (IS_BEGBUF_CONTEXT (context) && IS_NEWLINE_CONTEXT (context))
branch  0 taken 12045 (fallthrough)
branch  1 taken 0
branch  2 taken 12045 (fallthrough)
branch  3 taken 0
    12045:  922:	return dfa->init_state_begbuf;
    #####:  923:      else if (IS_NEWLINE_CONTEXT (context))
branch  0 never executed
branch  1 never executed
    #####:  924:	return dfa->init_state_nl;
    #####:  925:      else if (IS_BEGBUF_CONTEXT (context))
branch  0 never executed
branch  1 never executed
        -:  926:	{
        -:  927:	  /* It is relatively rare case, then calculate on demand.  */
    #####:  928:	  return  re_acquire_state_context (err, dfa,
    #####:  929:					    dfa->init_state->entrance_nodes,
call    0 never executed
        -:  930:					    context);
        -:  931:	}
        -:  932:      else
        -:  933:	/* Must not happen?  */
    #####:  934:	return dfa->init_state;
        -:  935:    }
        -:  936:  else
   507456:  937:    return dfa->init_state;
        -:  938:}
        -:  939:
        -:  940:/* Check whether the regular expression match input string INPUT or not,
        -:  941:   and return the index where the matching end, return -1 if not match,
        -:  942:   or return -2 in case of an error.
        -:  943:   FL_SEARCH means we must search where the matching starts,
        -:  944:   FL_LONGEST_MATCH means we want the POSIX longest matching.
        -:  945:   Note that the matcher assume that the maching starts from the current
        -:  946:   index of the buffer.  */
        -:  947:
        -:  948:static int
function check_matching called 676465 returned 100% blocks executed 63%
   676465:  949:check_matching (preg, mctx, fl_search, fl_longest_match)
        -:  950:    const regex_t *preg;
        -:  951:    re_match_context_t *mctx;
        -:  952:    int fl_search, fl_longest_match;
        -:  953:{
   676465:  954:  re_dfa_t *dfa = (re_dfa_t *) preg->buffer;
        -:  955:  reg_errcode_t err;
   676465:  956:  int match = 0;
   676465:  957:  int match_last = -1;
   676465:  958:  int cur_str_idx = re_string_cur_idx (mctx->input);
        -:  959:  re_dfastate_t *cur_state;
        -:  960:
   676465:  961:  cur_state = acquire_init_state_context (&err, preg, mctx, cur_str_idx);
call    0 returned 676465
        -:  962:  /* An initial state must not be NULL(invalid state).  */
   676465:  963:  if (BE (cur_state == NULL, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 676465
    #####:  964:    return -2;
   676465:  965:  if (mctx->state_log != NULL)
branch  0 taken 3609 (fallthrough)
branch  1 taken 672856
     3609:  966:    mctx->state_log[cur_str_idx] = cur_state;
        -:  967:
        -:  968:  /* Check OP_OPEN_SUBEXP in the initial state in case that we use them
        -:  969:     later.  E.g. Processing back references.  */
   676465:  970:  if (dfa->nbackref)
branch  0 taken 0 (fallthrough)
branch  1 taken 676465
        -:  971:    {
    #####:  972:      err = check_subexp_matching_top (dfa, mctx, &cur_state->nodes, 0);
call    0 never executed
    #####:  973:      if (BE (err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####:  974:	return err;
        -:  975:    }
        -:  976:
   676465:  977:  if (cur_state->has_backref)
branch  0 taken 0 (fallthrough)
branch  1 taken 676465
        -:  978:    {
    #####:  979:      err = transit_state_bkref (preg, cur_state, mctx);
call    0 never executed
    #####:  980:      if (BE (err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####:  981:	return err;
        -:  982:    }
        -:  983:
        -:  984:  /* If the RE accepts NULL string.  */
   676465:  985:  if (cur_state->halt)
branch  0 taken 71087 (fallthrough)
branch  1 taken 605378
        -:  986:    {
    71087:  987:      if (!cur_state->has_constraint
branch  0 taken 70736 (fallthrough)
branch  1 taken 351
    70736:  988:	  || check_halt_state_context (preg, cur_state, mctx, cur_str_idx))
call    0 returned 70736
branch  1 taken 2990 (fallthrough)
branch  2 taken 67746
        -:  989:	{
     3341:  990:	  if (!fl_longest_match)
branch  0 taken 0 (fallthrough)
branch  1 taken 3341
    #####:  991:	    return cur_str_idx;
        -:  992:	  else
        -:  993:	    {
     3341:  994:	      match_last = cur_str_idx;
     3341:  995:	      match = 1;
        -:  996:	    }
        -:  997:	}
        -:  998:    }
        -:  999:
  1066968: 1000:  while (!re_string_eoi (mctx->input))
branch  0 taken 993920
branch  1 taken 73048 (fallthrough)
        -: 1001:    {
  993920*: 1002:      cur_state = transit_state (&err, preg, mctx, cur_state,
branch  0 taken 0 (fallthrough)
branch  1 taken 993920
branch  2 never executed
branch  3 never executed
call    4 returned 993920
        -: 1003:				 fl_search && !match);
   993920: 1004:      if (cur_state == NULL) /* Reached at the invalid state or an error.  */
branch  0 taken 603417 (fallthrough)
branch  1 taken 390503
        -: 1005:	{
   603417: 1006:	  cur_str_idx = re_string_cur_idx (mctx->input);
   603417: 1007:	  if (BE (err != REG_NOERROR, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 603417
    #####: 1008:	    return -2;
  603417*: 1009:	  if (fl_search && !match)
branch  0 taken 0 (fallthrough)
branch  1 taken 603417
branch  2 never executed
branch  3 never executed
        -: 1010:	    {
        -: 1011:	      /* Restart from initial state, since we are searching
        -: 1012:		 the point from where matching start.  */
        -: 1013:#ifdef RE_ENABLE_I18N
        -: 1014:	      if (MB_CUR_MAX == 1
        -: 1015:		  || re_string_first_byte (mctx->input, cur_str_idx))
        -: 1016:#endif /* RE_ENABLE_I18N */
    #####: 1017:		cur_state = acquire_init_state_context (&err, preg, mctx,
call    0 never executed
        -: 1018:							cur_str_idx);
    #####: 1019:	      if (BE (cur_state == NULL && err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1020:		return -2;
    #####: 1021:	      if (mctx->state_log != NULL)
branch  0 never executed
branch  1 never executed
    #####: 1022:		mctx->state_log[cur_str_idx] = cur_state;
        -: 1023:	    }
  603417*: 1024:	  else if (!fl_longest_match && match)
branch  0 taken 0 (fallthrough)
branch  1 taken 603417
branch  2 never executed
branch  3 never executed
        -: 1025:	    break;
        -: 1026:	  else /* (fl_longest_match && match) || (!fl_search && !match)  */
        -: 1027:	    {
   603417: 1028:	      if (mctx->state_log == NULL)
branch  0 taken 600078 (fallthrough)
branch  1 taken 3339
   600078: 1029:		break;
        -: 1030:	      else
        -: 1031:		{
     3339: 1032:		  int max = mctx->state_log_top;
     6678: 1033:		  for (; cur_str_idx <= max; ++cur_str_idx)
branch  0 taken 3339
branch  1 taken 3339 (fallthrough)
     3339: 1034:		    if (mctx->state_log[cur_str_idx] != NULL)
branch  0 taken 0 (fallthrough)
branch  1 taken 3339
    #####: 1035:		      break;
     3339: 1036:		  if (cur_str_idx > max)
branch  0 taken 3339 (fallthrough)
branch  1 taken 0
     3339: 1037:		    break;
        -: 1038:		}
        -: 1039:	    }
        -: 1040:	}
        -: 1041:
   390503: 1042:      if (cur_state != NULL && cur_state->halt)
branch  0 taken 390503 (fallthrough)
branch  1 taken 0
branch  2 taken 23093 (fallthrough)
branch  3 taken 367410
        -: 1043:	{
        -: 1044:	  /* Reached at a halt state.
        -: 1045:	     Check the halt state can satisfy the current context.  */
    23093: 1046:	  if (!cur_state->has_constraint
branch  0 taken 3302 (fallthrough)
branch  1 taken 19791
     3302: 1047:	      || check_halt_state_context (preg, cur_state, mctx,
branch  0 taken 135 (fallthrough)
branch  1 taken 3167
     3302: 1048:					   re_string_cur_idx (mctx->input)))
call    0 returned 3302
        -: 1049:	    {
        -: 1050:	      /* We found an appropriate halt state.  */
    19926: 1051:	      match_last = re_string_cur_idx (mctx->input);
    19926: 1052:	      match = 1;
    19926: 1053:	      if (!fl_longest_match)
branch  0 taken 0 (fallthrough)
branch  1 taken 19926
    #####: 1054:		break;
        -: 1055:	    }
        -: 1056:	}
        -: 1057:   }
   676465: 1058:  return match_last;
        -: 1059:}
        -: 1060:
        -: 1061:/* Check NODE match the current context.  */
        -: 1062:
function check_halt_node_context called 85799 returned 100% blocks executed 80%
    85799: 1063:static int check_halt_node_context (dfa, node, context)
        -: 1064:    const re_dfa_t *dfa;
        -: 1065:    int node;
        -: 1066:    unsigned int context;
        -: 1067:{
    85799: 1068:  re_token_type_t type = dfa->nodes[node].type;
    85799: 1069:  unsigned int constraint = dfa->nodes[node].constraint;
    85799: 1070:  if (type != END_OF_RE)
branch  0 taken 76950 (fallthrough)
branch  1 taken 8849
    76950: 1071:    return 0;
     8849: 1072:  if (!constraint)
branch  0 taken 29 (fallthrough)
branch  1 taken 8820
       29: 1073:    return 1;
    8820*: 1074:  if (NOT_SATISFY_NEXT_CONSTRAINT (constraint, context))
branch  0 taken 0 (fallthrough)
branch  1 taken 8820
branch  2 never executed
branch  3 never executed
branch  4 taken 0 (fallthrough)
branch  5 taken 8820
branch  6 never executed
branch  7 never executed
branch  8 taken 7338 (fallthrough)
branch  9 taken 1482
branch 10 taken 1643 (fallthrough)
branch 11 taken 5695
branch 12 taken 0 (fallthrough)
branch 13 taken 3125
branch 14 never executed
branch 15 never executed
     5695: 1075:    return 0;
     3125: 1076:  return 1;
        -: 1077:}
        -: 1078:
        -: 1079:/* Check the halt state STATE match the current context.
        -: 1080:   Return 0 if not match, if the node, STATE has, is a halt node and
        -: 1081:   match the context, return the node.  */
        -: 1082:
        -: 1083:static int
function check_halt_state_context called 74067 returned 100% blocks executed 100%
    74067: 1084:check_halt_state_context (preg, state, mctx, idx)
        -: 1085:    const regex_t *preg;
        -: 1086:    const re_dfastate_t *state;
        -: 1087:    const re_match_context_t *mctx;
        -: 1088:    int idx;
        -: 1089:{
    74067: 1090:  re_dfa_t *dfa = (re_dfa_t *) preg->buffer;
        -: 1091:  int i;
        -: 1092:  unsigned int context;
        -: 1093:#ifdef DEBUG
        -: 1094:  assert (state->halt);
        -: 1095:#endif
    74067: 1096:  context = re_string_context_at (mctx->input, idx, mctx->eflags,
    74067: 1097:				  preg->newline_anchor);
call    0 returned 74067
   156712: 1098:  for (i = 0; i < state->nodes.nelem; ++i)
branch  0 taken 85799
branch  1 taken 70913 (fallthrough)
    85799: 1099:    if (check_halt_node_context (dfa, state->nodes.elems[i], context))
call    0 returned 85799
branch  1 taken 3154 (fallthrough)
branch  2 taken 82645
     3154: 1100:      return state->nodes.elems[i];
    70913: 1101:  return 0;
        -: 1102:}
        -: 1103:
        -: 1104:/* Compute the next node to which "NFA" transit from NODE("NFA" is a NFA
        -: 1105:   corresponding to the DFA).
        -: 1106:   Return the destination node, and update EPS_VIA_NODES, return -1 in case
        -: 1107:   of errors.  */
        -: 1108:
        -: 1109:static int
function proceed_next_node called 353 returned 100% blocks executed 52%
      353: 1110:proceed_next_node (preg, nregs, regs, mctx, pidx, node, eps_via_nodes, fs)
        -: 1111:    const regex_t *preg;
        -: 1112:    regmatch_t *regs;
        -: 1113:    const re_match_context_t *mctx;
        -: 1114:    int nregs, *pidx, node;
        -: 1115:    re_node_set *eps_via_nodes;
        -: 1116:    struct re_fail_stack_t *fs;
        -: 1117:{
      353: 1118:  re_dfa_t *dfa = (re_dfa_t *)preg->buffer;
        -: 1119:  int i, err, dest_node;
      353: 1120:  dest_node = -1;
      353: 1121:  if (IS_EPSILON_NODE (dfa->nodes[node].type))
branch  0 taken 329 (fallthrough)
branch  1 taken 24
branch  2 taken 240 (fallthrough)
branch  3 taken 89
branch  4 taken 240 (fallthrough)
branch  5 taken 0
branch  6 taken 240 (fallthrough)
branch  7 taken 0
branch  8 taken 240 (fallthrough)
branch  9 taken 0
branch 10 taken 207 (fallthrough)
branch 11 taken 33
branch 12 taken 33 (fallthrough)
branch 13 taken 174
        -: 1122:    {
      179: 1123:      re_node_set *cur_nodes = &mctx->state_log[*pidx]->nodes;
        -: 1124:      int ndest, dest_nodes[2];
      179: 1125:      err = re_node_set_insert (eps_via_nodes, node);
call    0 returned 179
      179: 1126:      if (BE (err < 0, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 179
    #####: 1127:	return -1;
        -: 1128:      /* Pick up valid destinations.  */
      471: 1129:      for (ndest = 0, i = 0; i < dfa->edests[node].nelem; ++i)
branch  0 taken 292
branch  1 taken 179 (fallthrough)
        -: 1130:	{
      292: 1131:	  int candidate = dfa->edests[node].elems[i];
      292: 1132:	  if (!re_node_set_contains (cur_nodes, candidate))
call    0 returned 292
branch  1 taken 113 (fallthrough)
branch  2 taken 179
      113: 1133:	    continue;
     179*: 1134:	  dest_nodes[0] = (ndest == 0) ? candidate : dest_nodes[0];
branch  0 taken 0 (fallthrough)
branch  1 taken 179
     179*: 1135:	  dest_nodes[1] = (ndest == 1) ? candidate : dest_nodes[1];
branch  0 taken 179 (fallthrough)
branch  1 taken 0
      179: 1136:	  ++ndest;
        -: 1137:	}
      179: 1138:      if (ndest <= 1)
branch  0 taken 179 (fallthrough)
branch  1 taken 0
     179*: 1139:	return ndest == 0 ? -1 : (ndest == 1 ? dest_nodes[0] : 0);
branch  0 taken 179 (fallthrough)
branch  1 taken 0
branch  2 taken 179 (fallthrough)
branch  3 taken 0
        -: 1140:      /* In order to avoid infinite loop like "(a*)*".  */
    #####: 1141:      if (re_node_set_contains (eps_via_nodes, dest_nodes[0]))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1142:	return dest_nodes[1];
    #####: 1143:      if (fs != NULL)
branch  0 never executed
branch  1 never executed
    #####: 1144:	push_fail_stack (fs, *pidx, dest_nodes, nregs, regs, eps_via_nodes);
call    0 never executed
    #####: 1145:      return dest_nodes[0];
        -: 1146:    }
        -: 1147:  else
        -: 1148:    {
      174: 1149:      int naccepted = 0;
      174: 1150:      re_token_type_t type = dfa->nodes[node].type;
        -: 1151:
        -: 1152:#ifdef RE_ENABLE_I18N
        -: 1153:      if (ACCEPT_MB_NODE (type))
        -: 1154:	naccepted = check_node_accept_bytes (preg, node, mctx->input, *pidx);
        -: 1155:      else
        -: 1156:#endif /* RE_ENABLE_I18N */
      174: 1157:      if (type == OP_BACK_REF)
branch  0 taken 0 (fallthrough)
branch  1 taken 174
        -: 1158:	{
    #####: 1159:	  int subexp_idx = dfa->nodes[node].opr.idx;
    #####: 1160:	  naccepted = regs[subexp_idx].rm_eo - regs[subexp_idx].rm_so;
    #####: 1161:	  if (fs != NULL)
branch  0 never executed
branch  1 never executed
        -: 1162:	    {
    #####: 1163:	      if (regs[subexp_idx].rm_so == -1 || regs[subexp_idx].rm_eo == -1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1164:		return -1;
    #####: 1165:	      else if (naccepted)
branch  0 never executed
branch  1 never executed
        -: 1166:		{
    #####: 1167:		  char *buf = re_string_get_buffer (mctx->input);
    #####: 1168:		  if (my_memcmp (buf + regs[subexp_idx].rm_so, buf + *pidx,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1169:			         naccepted) != 0)
    #####: 1170:		    return -1;
        -: 1171:		}
        -: 1172:	    }
        -: 1173:
    #####: 1174:	  if (naccepted == 0)
branch  0 never executed
branch  1 never executed
        -: 1175:	    {
    #####: 1176:	      err = re_node_set_insert (eps_via_nodes, node);
call    0 never executed
    #####: 1177:	      if (BE (err < 0, 0))
branch  0 never executed
branch  1 never executed
    #####: 1178:		return -2;
    #####: 1179:	      dest_node = dfa->edests[node].elems[0];
    #####: 1180:	      if (re_node_set_contains (&mctx->state_log[*pidx]->nodes,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1181:					dest_node))
    #####: 1182:		return dest_node;
        -: 1183:	    }
        -: 1184:	}
        -: 1185:
      174: 1186:      if (naccepted != 0
branch  0 taken 174 (fallthrough)
branch  1 taken 0
      174: 1187:	  || check_node_accept (preg, dfa->nodes + node, mctx, *pidx))
call    0 returned 174
branch  1 taken 174 (fallthrough)
branch  2 taken 0
        -: 1188:	{
      174: 1189:	  dest_node = dfa->nexts[node];
     174*: 1190:	  *pidx = (naccepted == 0) ? *pidx + 1 : *pidx + naccepted;
branch  0 taken 174 (fallthrough)
branch  1 taken 0
     174*: 1191:	  if (fs && (*pidx > mctx->match_last || mctx->state_log[*pidx] == NULL
branch  0 taken 0 (fallthrough)
branch  1 taken 174
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1192:		     || !re_node_set_contains (&mctx->state_log[*pidx]->nodes,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1193:					       dest_node)))
    #####: 1194:	    return -1;
      174: 1195:	  re_node_set_empty (eps_via_nodes);
      174: 1196:	  return dest_node;
        -: 1197:	}
        -: 1198:    }
    #####: 1199:  return -1;
        -: 1200:}
        -: 1201:
        -: 1202:static reg_errcode_t
function push_fail_stack called 0 returned 0% blocks executed 0%
    #####: 1203:push_fail_stack (fs, str_idx, dests, nregs, regs, eps_via_nodes)
        -: 1204:     struct re_fail_stack_t *fs;
        -: 1205:     int str_idx, *dests, nregs;
        -: 1206:     regmatch_t *regs;
        -: 1207:     re_node_set *eps_via_nodes;
        -: 1208:{
        -: 1209:  reg_errcode_t err;
    #####: 1210:  int num = fs->num++;
    #####: 1211:  if (fs->num == fs->alloc)
branch  0 never executed
branch  1 never executed
        -: 1212:    {
        -: 1213:      struct re_fail_stack_ent_t *new_array;
    #####: 1214:      fs->alloc *= 2;
    #####: 1215:      new_array = realloc (fs->stack, (sizeof (struct re_fail_stack_ent_t)
    #####: 1216:				       * fs->alloc));
    #####: 1217:      if (new_array == NULL)
branch  0 never executed
branch  1 never executed
    #####: 1218:	return REG_ESPACE;
    #####: 1219:      fs->stack = new_array;
        -: 1220:    }
    #####: 1221:  fs->stack[num].idx = str_idx;
    #####: 1222:  fs->stack[num].node = dests[1];
    #####: 1223:  fs->stack[num].regs = re_malloc (regmatch_t, nregs);
    #####: 1224:  memcpy (fs->stack[num].regs, regs, sizeof (regmatch_t) * nregs);
    #####: 1225:  err = re_node_set_init_copy (&fs->stack[num].eps_via_nodes, eps_via_nodes);
call    0 never executed
    #####: 1226:  return err;
        -: 1227:}
        -: 1228:
        -: 1229:static int
function pop_fail_stack called 0 returned 0% blocks executed 0%
    #####: 1230:pop_fail_stack (fs, pidx, nregs, regs, eps_via_nodes)
        -: 1231:     struct re_fail_stack_t *fs;
        -: 1232:     int *pidx, nregs;
        -: 1233:     regmatch_t *regs;
        -: 1234:     re_node_set *eps_via_nodes;
        -: 1235:{
    #####: 1236:  int num = --fs->num;
    #####: 1237:  assert (num >= 0);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1238: *pidx = fs->stack[num].idx;
    #####: 1239:  memcpy (regs, fs->stack[num].regs, sizeof (regmatch_t) * nregs);
    #####: 1240:  re_node_set_free (eps_via_nodes);
    #####: 1241:  re_free (fs->stack[num].regs);
    #####: 1242:  *eps_via_nodes = fs->stack[num].eps_via_nodes;
    #####: 1243:  return fs->stack[num].node;
        -: 1244:}
        -: 1245:
        -: 1246:/* Set the positions where the subexpressions are starts/ends to registers
        -: 1247:   PMATCH.
        -: 1248:   Note: We assume that pmatch[0] is already set, and
        -: 1249:   pmatch[i].rm_so == pmatch[i].rm_eo == -1 (i > 1).  */
        -: 1250:
        -: 1251:static reg_errcode_t
function set_regs called 29 returned 100% blocks executed 45%
       29: 1252:set_regs (preg, mctx, nmatch, pmatch, fl_backtrack)
        -: 1253:     const regex_t *preg;
        -: 1254:     const re_match_context_t *mctx;
        -: 1255:     size_t nmatch;
        -: 1256:     regmatch_t *pmatch;
        -: 1257:     int fl_backtrack;
        -: 1258:{
       29: 1259:  re_dfa_t *dfa = (re_dfa_t *)preg->buffer;
        -: 1260:  int idx, cur_node, real_nmatch;
        -: 1261:  re_node_set eps_via_nodes;
        -: 1262:  struct re_fail_stack_t *fs;
       29: 1263:  struct re_fail_stack_t fs_body = {0, 2, NULL};
        -: 1264:#ifdef DEBUG
        -: 1265:  assert (nmatch > 1);
        -: 1266:  assert (mctx->state_log != NULL);
        -: 1267:#endif
       29: 1268:  if (fl_backtrack)
branch  0 taken 0 (fallthrough)
branch  1 taken 29
        -: 1269:    {
    #####: 1270:      fs = &fs_body;
    #####: 1271:      fs->stack = re_malloc (struct re_fail_stack_ent_t, fs->alloc);
        -: 1272:    }
        -: 1273:  else
       29: 1274:    fs = NULL;
       29: 1275:  cur_node = dfa->init_node;
      29*: 1276:  real_nmatch = (nmatch <= preg->re_nsub) ? nmatch : preg->re_nsub + 1;
branch  0 taken 29 (fallthrough)
branch  1 taken 0
       29: 1277:  re_node_set_init_empty (&eps_via_nodes);
      382: 1278:  for (idx = pmatch[0].rm_so; idx <= pmatch[0].rm_eo ;)
branch  0 taken 382
branch  1 taken 0 (fallthrough)
        -: 1279:    {
      382: 1280:      update_regs (dfa, pmatch, cur_node, idx, real_nmatch);
call    0 returned 382
      382: 1281:      if (idx == pmatch[0].rm_eo && cur_node == mctx->last_node)
branch  0 taken 53 (fallthrough)
branch  1 taken 329
branch  2 taken 29 (fallthrough)
branch  3 taken 24
        -: 1282:	{
        -: 1283:	  int reg_idx;
       29: 1284:	  if (fs)
branch  0 taken 0 (fallthrough)
branch  1 taken 29
        -: 1285:	    {
    #####: 1286:	      for (reg_idx = 0; reg_idx < nmatch; ++reg_idx)
branch  0 never executed
branch  1 never executed
    #####: 1287:		if (pmatch[reg_idx].rm_so > -1 && pmatch[reg_idx].rm_eo == -1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1288:		  break;
    #####: 1289:	      if (reg_idx == nmatch)
branch  0 never executed
branch  1 never executed
        -: 1290:		{
    #####: 1291:		  re_node_set_free (&eps_via_nodes);
    #####: 1292:		  return free_fail_stack_return (fs);
call    0 never executed
        -: 1293:		}
    #####: 1294:	      cur_node = pop_fail_stack (fs, &idx, nmatch, pmatch,
call    0 never executed
        -: 1295:					 &eps_via_nodes);
        -: 1296:	    }
        -: 1297:	  else
        -: 1298:	    {
       29: 1299:	      re_node_set_free (&eps_via_nodes);
       29: 1300:	      return REG_NOERROR;
        -: 1301:	    }
        -: 1302:	}
        -: 1303:
        -: 1304:      /* Proceed to next node.  */
      353: 1305:      cur_node = proceed_next_node (preg, nmatch, pmatch, mctx, &idx, cur_node,
call    0 returned 353
        -: 1306:				    &eps_via_nodes, fs);
        -: 1307:
      353: 1308:      if (BE (cur_node < 0, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 353
        -: 1309:	{
    #####: 1310:	  if (cur_node == -2)
branch  0 never executed
branch  1 never executed
    #####: 1311:	    return REG_ESPACE;
    #####: 1312:	  if (fs)
branch  0 never executed
branch  1 never executed
    #####: 1313:	    cur_node = pop_fail_stack (fs, &idx, nmatch, pmatch,
call    0 never executed
        -: 1314:				       &eps_via_nodes);
        -: 1315:	  else
        -: 1316:	    {
    #####: 1317:	      re_node_set_free (&eps_via_nodes);
    #####: 1318:	      return REG_NOMATCH;
        -: 1319:	    }
        -: 1320:	}
        -: 1321:    }
    #####: 1322:  re_node_set_free (&eps_via_nodes);
    #####: 1323:  return free_fail_stack_return (fs);
call    0 never executed
        -: 1324:}
        -: 1325:
        -: 1326:static reg_errcode_t
function free_fail_stack_return called 0 returned 0% blocks executed 0%
    #####: 1327:free_fail_stack_return (fs)
        -: 1328:     struct re_fail_stack_t *fs;
        -: 1329:{
    #####: 1330:  if (fs)
branch  0 never executed
branch  1 never executed
        -: 1331:    {
        -: 1332:      int fs_idx;
    #####: 1333:      for (fs_idx = 0; fs_idx < fs->num; ++fs_idx)
branch  0 never executed
branch  1 never executed
        -: 1334:	{
    #####: 1335:	  re_node_set_free (&fs->stack[fs_idx].eps_via_nodes);
    #####: 1336:	  re_free (fs->stack[fs_idx].regs);
        -: 1337:	}
    #####: 1338:      re_free (fs->stack);
        -: 1339:    }
    #####: 1340:  return REG_NOERROR;
        -: 1341:}
        -: 1342:
        -: 1343:static void
function update_regs called 382 returned 100% blocks executed 90%
      382: 1344:update_regs (dfa, pmatch, cur_node, cur_idx, nmatch)
        -: 1345:     re_dfa_t *dfa;
        -: 1346:     regmatch_t *pmatch;
        -: 1347:     int cur_node, cur_idx, nmatch;
        -: 1348:{
      382: 1349:  int type = dfa->nodes[cur_node].type;
        -: 1350:  int reg_num;
      382: 1351:  if (type != OP_OPEN_SUBEXP && type != OP_CLOSE_SUBEXP)
branch  0 taken 349 (fallthrough)
branch  1 taken 33
branch  2 taken 316 (fallthrough)
branch  3 taken 33
      316: 1352:    return;
       66: 1353:  reg_num = dfa->nodes[cur_node].opr.idx + 1;
       66: 1354:  if (reg_num >= nmatch)
branch  0 taken 0 (fallthrough)
branch  1 taken 66
    #####: 1355:    return;
       66: 1356:  if (type == OP_OPEN_SUBEXP)
branch  0 taken 33 (fallthrough)
branch  1 taken 33
        -: 1357:    {
        -: 1358:      /* We are at the first node of this sub expression.  */
       33: 1359:      pmatch[reg_num].rm_so = cur_idx;
       33: 1360:      pmatch[reg_num].rm_eo = -1;
        -: 1361:    }
       33: 1362:  else if (type == OP_CLOSE_SUBEXP)
branch  0 taken 33 (fallthrough)
branch  1 taken 0
        -: 1363:    /* We are at the first node of this sub expression.  */
       33: 1364:    pmatch[reg_num].rm_eo = cur_idx;
        -: 1365:}
        -: 1366:
        -: 1367:#define NUMBER_OF_STATE 1
        -: 1368:
        -: 1369:/* This function checks the STATE_LOG from the SCTX->last_str_idx to 0
        -: 1370:   and sift the nodes in each states according to the following rules.
        -: 1371:   Updated state_log will be wrote to STATE_LOG.
        -: 1372:
        -: 1373:   Rules: We throw away the Node `a' in the STATE_LOG[STR_IDX] if...
        -: 1374:     1. When STR_IDX == MATCH_LAST(the last index in the state_log):
        -: 1375:	If `a' isn't the LAST_NODE and `a' can't epsilon transit to
        -: 1376:	the LAST_NODE, we throw away the node `a'.
        -: 1377:     2. When 0 <= STR_IDX < MATCH_LAST and `a' accepts
        -: 1378:	string `s' and transit to `b':
        -: 1379:	i. If 'b' isn't in the STATE_LOG[STR_IDX+strlen('s')], we throw
        -: 1380:	   away the node `a'.
        -: 1381:	ii. If 'b' is in the STATE_LOG[STR_IDX+strlen('s')] but 'b' is
        -: 1382:	    throwed away, we throw away the node `a'.
        -: 1383:     3. When 0 <= STR_IDX < n and 'a' epsilon transit to 'b':
        -: 1384:	i. If 'b' isn't in the STATE_LOG[STR_IDX], we throw away the
        -: 1385:	   node `a'.
        -: 1386:	ii. If 'b' is in the STATE_LOG[STR_IDX] but 'b' is throwed away,
        -: 1387:	    we throw away the node `a'.  */
        -: 1388:
        -: 1389:#define STATE_NODE_CONTAINS(state,node) \
        -: 1390:  ((state) != NULL && re_node_set_contains (&(state)->nodes, node))
        -: 1391:
        -: 1392:static reg_errcode_t
function sift_states_backward called 29 returned 100% blocks executed 80%
       29: 1393:sift_states_backward (preg, mctx, sctx)
        -: 1394:     const regex_t *preg;
        -: 1395:     re_match_context_t *mctx;
        -: 1396:     re_sift_context_t *sctx;
        -: 1397:{
        -: 1398:  reg_errcode_t err;
       29: 1399:  re_dfa_t *dfa = (re_dfa_t *)preg->buffer;
       29: 1400:  int null_cnt = 0;
       29: 1401:  int str_idx = sctx->last_str_idx;
        -: 1402:  re_node_set cur_dest;
        -: 1403:  re_node_set *cur_src; /* Points the state_log[str_idx]->nodes  */
        -: 1404:
        -: 1405:#ifdef DEBUG
        -: 1406:  assert (mctx->state_log != NULL && mctx->state_log[str_idx] != NULL);
        -: 1407:#endif
       29: 1408:  cur_src = &mctx->state_log[str_idx]->nodes;
        -: 1409:
        -: 1410:  /* Build sifted state_log[str_idx].  It has the nodes which can epsilon
        -: 1411:     transit to the last_node and the last_node itself.  */
       29: 1412:  err = re_node_set_init_1 (&cur_dest, sctx->last_node);
call    0 returned 29
       29: 1413:  if (BE (err != REG_NOERROR, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 29
    #####: 1414:    return err;
       29: 1415:  err = update_cur_sifted_state (preg, mctx, sctx, str_idx, &cur_dest);
call    0 returned 29
       29: 1416:  if (BE (err != REG_NOERROR, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 29
    #####: 1417:    goto free_return;
        -: 1418:
        -: 1419:  /* Then check each states in the state_log.  */
      203: 1420:  while (str_idx > 0)
branch  0 taken 174
branch  1 taken 29 (fallthrough)
        -: 1421:    {
        -: 1422:      int i, ret;
        -: 1423:      /* Update counters.  */
     174*: 1424:      null_cnt = (sctx->sifted_states[str_idx] == NULL) ? null_cnt + 1 : 0;
branch  0 taken 0 (fallthrough)
branch  1 taken 174
      174: 1425:      if (null_cnt > mctx->max_mb_elem_len)
branch  0 taken 0 (fallthrough)
branch  1 taken 174
        -: 1426:	{
    #####: 1427:	  memset (sctx->sifted_states, '\0',
        -: 1428:		  sizeof (re_dfastate_t *) * str_idx);
    #####: 1429:	  re_node_set_free (&cur_dest);
    #####: 1430:	  return REG_NOERROR;
        -: 1431:	}
      174: 1432:      re_node_set_empty (&cur_dest);
      174: 1433:      --str_idx;
      348: 1434:      cur_src = ((mctx->state_log[str_idx] == NULL) ? &empty_set
     174*: 1435:		 : &mctx->state_log[str_idx]->nodes);
branch  0 taken 174 (fallthrough)
branch  1 taken 0
        -: 1436:
        -: 1437:      /* Then build the next sifted state.
        -: 1438:	 We build the next sifted state on `cur_dest', and update
        -: 1439:	 `sifted_states[str_idx]' with `cur_dest'.
        -: 1440:	 Note:
        -: 1441:	 `cur_dest' is the sifted state from `state_log[str_idx + 1]'.
        -: 1442:	 `cur_src' points the node_set of the old `state_log[str_idx]'.  */
      988: 1443:      for (i = 0; i < cur_src->nelem; i++)
branch  0 taken 814
branch  1 taken 174 (fallthrough)
        -: 1444:	{
      814: 1445:	  int prev_node = cur_src->elems[i];
      814: 1446:	  int naccepted = 0;
      814: 1447:	  re_token_type_t type = dfa->nodes[prev_node].type;
        -: 1448:
      814: 1449:	  if (IS_EPSILON_NODE(type))
branch  0 taken 790 (fallthrough)
branch  1 taken 24
branch  2 taken 636 (fallthrough)
branch  3 taken 154
branch  4 taken 636 (fallthrough)
branch  5 taken 0
branch  6 taken 636 (fallthrough)
branch  7 taken 0
branch  8 taken 636 (fallthrough)
branch  9 taken 0
branch 10 taken 578 (fallthrough)
branch 11 taken 58
branch 12 taken 154 (fallthrough)
branch 13 taken 424
      390: 1450:	    continue;
        -: 1451:#ifdef RE_ENABLE_I18N
        -: 1452:	  /* If the node may accept `multi byte'.  */
        -: 1453:	  if (ACCEPT_MB_NODE (type))
        -: 1454:	    naccepted = sift_states_iter_mb (preg, mctx, sctx, prev_node,
        -: 1455:					     str_idx, sctx->last_str_idx);
        -: 1456:
        -: 1457:#endif /* RE_ENABLE_I18N */
        -: 1458:	  /* We don't check backreferences here.
        -: 1459:	     See update_cur_sifted_state().  */
        -: 1460:
      424: 1461:	  if (!naccepted
branch  0 taken 424 (fallthrough)
branch  1 taken 0
      424: 1462:	      && check_node_accept (preg, dfa->nodes + prev_node, mctx,
call    0 returned 424
branch  1 taken 260 (fallthrough)
branch  2 taken 164
        -: 1463:				    str_idx)
      260: 1464:	      && STATE_NODE_CONTAINS (sctx->sifted_states[str_idx + 1],
branch  0 taken 260 (fallthrough)
branch  1 taken 0
call    2 returned 260
branch  3 taken 174 (fallthrough)
branch  4 taken 86
        -: 1465:				      dfa->nexts[prev_node]))
      174: 1466:	    naccepted = 1;
        -: 1467:
      424: 1468:	  if (naccepted == 0)
branch  0 taken 250 (fallthrough)
branch  1 taken 174
      250: 1469:	    continue;
        -: 1470:
      174: 1471:	  if (sctx->limits.nelem)
branch  0 taken 0 (fallthrough)
branch  1 taken 174
        -: 1472:	    {
    #####: 1473:	      int to_idx = str_idx + naccepted;
    #####: 1474:	      if (check_dst_limits (dfa, &sctx->limits, mctx,
branch  0 never executed
branch  1 never executed
    #####: 1475:				    dfa->nexts[prev_node], to_idx,
call    0 never executed
        -: 1476:				    prev_node, str_idx))
    #####: 1477:		continue;
        -: 1478:	    }
      174: 1479:	  ret = re_node_set_insert (&cur_dest, prev_node);
call    0 returned 174
      174: 1480:	  if (BE (ret == -1, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 174
        -: 1481:	    {
    #####: 1482:	      err = REG_ESPACE;
    #####: 1483:	      goto free_return;
        -: 1484:	    }
        -: 1485:	}
        -: 1486:
        -: 1487:      /* Add all the nodes which satisfy the following conditions:
        -: 1488:	 - It can epsilon transit to a node in CUR_DEST.
        -: 1489:	 - It is in CUR_SRC.
        -: 1490:	 And update state_log.  */
      174: 1491:      err = update_cur_sifted_state (preg, mctx, sctx, str_idx, &cur_dest);
call    0 returned 174
      174: 1492:      if (BE (err != REG_NOERROR, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 174
    #####: 1493:	goto free_return;
        -: 1494:    }
       29: 1495:  err = REG_NOERROR;
       29: 1496: free_return:
       29: 1497:  re_node_set_free (&cur_dest);
       29: 1498:  return err;
        -: 1499:}
        -: 1500:
        -: 1501:/* Helper functions.  */
        -: 1502:
        -: 1503:static inline reg_errcode_t
function clean_state_log_if_need called 0 returned 0% blocks executed 0%
    #####: 1504:clean_state_log_if_need (mctx, next_state_log_idx)
        -: 1505:    re_match_context_t *mctx;
        -: 1506:    int next_state_log_idx;
        -: 1507:{
    #####: 1508:  int top = mctx->state_log_top;
        -: 1509:
    #####: 1510:  if (next_state_log_idx >= mctx->input->bufs_len
branch  0 never executed
branch  1 never executed
    #####: 1511:      || (next_state_log_idx >= mctx->input->valid_len
branch  0 never executed
branch  1 never executed
    #####: 1512:	  && mctx->input->valid_len < mctx->input->len))
branch  0 never executed
branch  1 never executed
        -: 1513:    {
        -: 1514:      reg_errcode_t err;
    #####: 1515:      err = extend_buffers (mctx);
call    0 never executed
    #####: 1516:      if (BE (err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 1517:	return err;
        -: 1518:    }
        -: 1519:
    #####: 1520:  if (top < next_state_log_idx)
branch  0 never executed
branch  1 never executed
        -: 1521:    {
    #####: 1522:      memset (mctx->state_log + top + 1, '\0',
    #####: 1523:	      sizeof (re_dfastate_t *) * (next_state_log_idx - top));
    #####: 1524:      mctx->state_log_top = next_state_log_idx;
        -: 1525:    }
    #####: 1526:  return REG_NOERROR;
        -: 1527:}
        -: 1528:
        -: 1529:static reg_errcode_t
function merge_state_array called 0 returned 0% blocks executed 0%
    #####: 1530:merge_state_array (dfa, dst, src, num)
        -: 1531:     re_dfa_t *dfa;
        -: 1532:     re_dfastate_t **dst;
        -: 1533:     re_dfastate_t **src;
        -: 1534:     int num;
        -: 1535:{
        -: 1536:  int st_idx;
        -: 1537:  reg_errcode_t err;
    #####: 1538:  for (st_idx = 0; st_idx < num; ++st_idx)
branch  0 never executed
branch  1 never executed
        -: 1539:    {
    #####: 1540:      if (dst[st_idx] == NULL)
branch  0 never executed
branch  1 never executed
    #####: 1541:	dst[st_idx] = src[st_idx];
    #####: 1542:      else if (src[st_idx] != NULL)
branch  0 never executed
branch  1 never executed
        -: 1543:	{
        -: 1544:	  re_node_set merged_set;
    #####: 1545:	  err = re_node_set_init_union (&merged_set, &dst[st_idx]->nodes,
    #####: 1546:					&src[st_idx]->nodes);
call    0 never executed
    #####: 1547:	  if (BE (err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 1548:	    return err;
    #####: 1549:	  dst[st_idx] = re_acquire_state (&err, dfa, &merged_set);
call    0 never executed
    #####: 1550:	  re_node_set_free (&merged_set);
    #####: 1551:	  if (BE (err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 1552:	    return err;
        -: 1553:	}
        -: 1554:    }
    #####: 1555:  return REG_NOERROR;
        -: 1556:}
        -: 1557:
        -: 1558:static reg_errcode_t
function update_cur_sifted_state called 203 returned 100% blocks executed 58%
      203: 1559:update_cur_sifted_state (preg, mctx, sctx, str_idx, dest_nodes)
        -: 1560:     const regex_t *preg;
        -: 1561:     re_match_context_t *mctx;
        -: 1562:     re_sift_context_t *sctx;
        -: 1563:     int str_idx;
        -: 1564:     re_node_set *dest_nodes;
        -: 1565:{
        -: 1566:  reg_errcode_t err;
      203: 1567:  re_dfa_t *dfa = (re_dfa_t *)preg->buffer;
        -: 1568:  const re_node_set *candidates;
     203*: 1569:  candidates = ((mctx->state_log[str_idx] == NULL) ? &empty_set
branch  0 taken 203 (fallthrough)
branch  1 taken 0
      203: 1570:		: &mctx->state_log[str_idx]->nodes);
        -: 1571:
        -: 1572:  /* At first, add the nodes which can epsilon transit to a node in
        -: 1573:     DEST_NODE.  */
      203: 1574:  if (dest_nodes->nelem)
branch  0 taken 203 (fallthrough)
branch  1 taken 0
        -: 1575:    {
      203: 1576:      err = add_epsilon_src_nodes (dfa, dest_nodes, candidates);
call    0 returned 203
      203: 1577:      if (BE (err != REG_NOERROR, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 203
    #####: 1578:	return err;
        -: 1579:    }
        -: 1580:
        -: 1581:  /* Then, check the limitations in the current sift_context.  */
      203: 1582:  if (dest_nodes->nelem && sctx->limits.nelem)
branch  0 taken 203 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 203
        -: 1583:    {
    #####: 1584:      err = check_subexp_limits (dfa, dest_nodes, candidates, &sctx->limits,
call    0 never executed
        -: 1585:				 mctx->bkref_ents, str_idx);
    #####: 1586:      if (BE (err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 1587:	return err;
        -: 1588:    }
        -: 1589:
        -: 1590:  /* Update state_log.  */
      203: 1591:  sctx->sifted_states[str_idx] = re_acquire_state (&err, dfa, dest_nodes);
call    0 returned 203
     203*: 1592:  if (BE (sctx->sifted_states[str_idx] == NULL && err != REG_NOERROR, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 203
branch  2 never executed
branch  3 never executed
    #####: 1593:    return err;
        -: 1594:
      203: 1595:  if ((mctx->state_log[str_idx] != NULL
branch  0 taken 203 (fallthrough)
branch  1 taken 0
      203: 1596:       && mctx->state_log[str_idx]->has_backref))
branch  0 taken 0 (fallthrough)
branch  1 taken 203
        -: 1597:    {
    #####: 1598:      err = sift_states_bkref (preg, mctx, sctx, str_idx, dest_nodes);
call    0 never executed
    #####: 1599:      if (BE (err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 1600:	return err;
        -: 1601:    }
      203: 1602:  return REG_NOERROR;
        -: 1603:}
        -: 1604:
        -: 1605:static reg_errcode_t
function add_epsilon_src_nodes called 203 returned 100% blocks executed 83%
      203: 1606:add_epsilon_src_nodes (dfa, dest_nodes, candidates)
        -: 1607:     re_dfa_t *dfa;
        -: 1608:     re_node_set *dest_nodes;
        -: 1609:     const re_node_set *candidates;
        -: 1610:{
        -: 1611:  reg_errcode_t err;
        -: 1612:  int src_idx;
        -: 1613:  re_node_set src_copy;
        -: 1614:
      203: 1615:  err = re_node_set_init_copy (&src_copy, dest_nodes);
call    0 returned 203
      203: 1616:  if (BE (err != REG_NOERROR, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 203
    #####: 1617:    return err;
      406: 1618:  for (src_idx = 0; src_idx < src_copy.nelem; ++src_idx)
branch  0 taken 203
branch  1 taken 203 (fallthrough)
        -: 1619:    {
      203: 1620:      err = re_node_set_add_intersect (dest_nodes, candidates,
      203: 1621:				       dfa->inveclosures
      203: 1622:				       + src_copy.elems[src_idx]);
call    0 returned 203
      203: 1623:      if (BE (err != REG_NOERROR, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 203
        -: 1624:	{
    #####: 1625:	  re_node_set_free (&src_copy);
    #####: 1626:	  return err;
        -: 1627:	}
        -: 1628:    }
      203: 1629:  re_node_set_free (&src_copy);
      203: 1630:  return REG_NOERROR;
        -: 1631:}
        -: 1632:
        -: 1633:static reg_errcode_t
function sub_epsilon_src_nodes called 0 returned 0% blocks executed 0%
    #####: 1634:sub_epsilon_src_nodes (dfa, node, dest_nodes, candidates)
        -: 1635:     re_dfa_t *dfa;
        -: 1636:     int node;
        -: 1637:     re_node_set *dest_nodes;
        -: 1638:     const re_node_set *candidates;
        -: 1639:{
        -: 1640:    int ecl_idx;
        -: 1641:    reg_errcode_t err;
    #####: 1642:    re_node_set *inv_eclosure = dfa->inveclosures + node;
        -: 1643:    re_node_set except_nodes;
    #####: 1644:    re_node_set_init_empty (&except_nodes);
    #####: 1645:    for (ecl_idx = 0; ecl_idx < inv_eclosure->nelem; ++ecl_idx)
branch  0 never executed
branch  1 never executed
        -: 1646:      {
    #####: 1647:	int cur_node = inv_eclosure->elems[ecl_idx];
    #####: 1648:	if (cur_node == node)
branch  0 never executed
branch  1 never executed
    #####: 1649:	  continue;
    #####: 1650:	if (IS_EPSILON_NODE (dfa->nodes[cur_node].type))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
        -: 1651:	  {
    #####: 1652:	    int edst1 = dfa->edests[cur_node].elems[0];
    #####: 1653:	    int edst2 = ((dfa->edests[cur_node].nelem > 1)
    #####: 1654:			 ? dfa->edests[cur_node].elems[1] : -1);
branch  0 never executed
branch  1 never executed
    #####: 1655:	    if ((!re_node_set_contains (inv_eclosure, edst1)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1656:		 && re_node_set_contains (dest_nodes, edst1))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1657:		|| (edst2 > 0
branch  0 never executed
branch  1 never executed
    #####: 1658:		    && !re_node_set_contains (inv_eclosure, edst2)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1659:		    && re_node_set_contains (dest_nodes, edst2)))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1660:	      {
    #####: 1661:		err = re_node_set_add_intersect (&except_nodes, candidates,
    #####: 1662:						 dfa->inveclosures + cur_node);
call    0 never executed
    #####: 1663:		if (BE (err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
        -: 1664:		  {
    #####: 1665:		    re_node_set_free (&except_nodes);
    #####: 1666:		    return err;
        -: 1667:		  }
        -: 1668:	      }
        -: 1669:	  }
        -: 1670:      }
    #####: 1671:    for (ecl_idx = 0; ecl_idx < inv_eclosure->nelem; ++ecl_idx)
branch  0 never executed
branch  1 never executed
        -: 1672:      {
    #####: 1673:	int cur_node = inv_eclosure->elems[ecl_idx];
    #####: 1674:	if (!re_node_set_contains (&except_nodes, cur_node))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1675:	  {
    #####: 1676:	    int idx = re_node_set_contains (dest_nodes, cur_node) - 1;
call    0 never executed
    #####: 1677:	    re_node_set_remove_at (dest_nodes, idx);
call    0 never executed
        -: 1678:	  }
        -: 1679:      }
    #####: 1680:    re_node_set_free (&except_nodes);
    #####: 1681:    return REG_NOERROR;
        -: 1682:}
        -: 1683:
        -: 1684:static int
function check_dst_limits called 0 returned 0% blocks executed 0%
    #####: 1685:check_dst_limits (dfa, limits, mctx, dst_node, dst_idx, src_node, src_idx)
        -: 1686:     re_dfa_t *dfa;
        -: 1687:     re_node_set *limits;
        -: 1688:     re_match_context_t *mctx;
        -: 1689:     int dst_node, dst_idx, src_node, src_idx;
        -: 1690:{
        -: 1691:  int lim_idx, src_pos, dst_pos;
        -: 1692:
    #####: 1693:  for (lim_idx = 0; lim_idx < limits->nelem; ++lim_idx)
branch  0 never executed
branch  1 never executed
        -: 1694:    {
        -: 1695:      int subexp_idx;
        -: 1696:      struct re_backref_cache_entry *ent;
    #####: 1697:      ent = mctx->bkref_ents + limits->elems[lim_idx];
    #####: 1698:      subexp_idx = dfa->nodes[ent->node].opr.idx - 1;
        -: 1699:
    #####: 1700:      dst_pos = check_dst_limits_calc_pos (dfa, mctx, limits->elems[lim_idx],
    #####: 1701:					   dfa->eclosures + dst_node,
call    0 never executed
        -: 1702:					   subexp_idx, dst_node, dst_idx);
    #####: 1703:      src_pos = check_dst_limits_calc_pos (dfa, mctx, limits->elems[lim_idx],
    #####: 1704:					   dfa->eclosures + src_node,
call    0 never executed
        -: 1705:					   subexp_idx, src_node, src_idx);
        -: 1706:
        -: 1707:      /* In case of:
        -: 1708:	 <src> <dst> ( <subexp> )
        -: 1709:	 ( <subexp> ) <src> <dst>
        -: 1710:	 ( <subexp1> <src> <subexp2> <dst> <subexp3> )  */
    #####: 1711:      if (src_pos == dst_pos)
branch  0 never executed
branch  1 never executed
    #####: 1712:	continue; /* This is unrelated limitation.  */
        -: 1713:      else
    #####: 1714:	return 1;
        -: 1715:    }
    #####: 1716:  return 0;
        -: 1717:}
        -: 1718:
        -: 1719:static int
function check_dst_limits_calc_pos called 0 returned 0% blocks executed 0%
    #####: 1720:check_dst_limits_calc_pos (dfa, mctx, limit, eclosures, subexp_idx, node,
        -: 1721:			   str_idx)
        -: 1722:     re_dfa_t *dfa;
        -: 1723:     re_match_context_t *mctx;
        -: 1724:     re_node_set *eclosures;
        -: 1725:     int limit, subexp_idx, node, str_idx;
        -: 1726:{
    #####: 1727:  struct re_backref_cache_entry *lim = mctx->bkref_ents + limit;
    #####: 1728:  int pos = (str_idx < lim->subexp_from ? -1
    #####: 1729:	     : (lim->subexp_to < str_idx ? 1 : 0));
branch  0 never executed
branch  1 never executed
    #####: 1730:  if (pos == 0
branch  0 never executed
branch  1 never executed
    #####: 1731:      && (str_idx == lim->subexp_from || str_idx == lim->subexp_to))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1732:    {
        -: 1733:      int node_idx;
    #####: 1734:      for (node_idx = 0; node_idx < eclosures->nelem; ++node_idx)
branch  0 never executed
branch  1 never executed
        -: 1735:	{
    #####: 1736:	  int node = eclosures->elems[node_idx];
    #####: 1737:	  re_token_type_t type= dfa->nodes[node].type;
    #####: 1738:	  if (type == OP_BACK_REF)
branch  0 never executed
branch  1 never executed
        -: 1739:	    {
    #####: 1740:	      int bi = search_cur_bkref_entry (mctx, str_idx);
call    0 never executed
    #####: 1741:	      for (; bi < mctx->nbkref_ents; ++bi)
branch  0 never executed
branch  1 never executed
        -: 1742:		{
    #####: 1743:		  struct re_backref_cache_entry *ent = mctx->bkref_ents + bi;
    #####: 1744:		  if (ent->str_idx > str_idx)
branch  0 never executed
branch  1 never executed
    #####: 1745:		    break;
    #####: 1746:		  if (ent->node == node && ent->subexp_from == ent->subexp_to)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1747:		    {
        -: 1748:		      int cpos, dst;
    #####: 1749:		      dst = dfa->edests[node].elems[0];
    #####: 1750:		      cpos = check_dst_limits_calc_pos (dfa, mctx, limit,
    #####: 1751:							dfa->eclosures + dst,
call    0 never executed
        -: 1752:							subexp_idx, dst,
        -: 1753:							str_idx);
    #####: 1754:		      if ((str_idx == lim->subexp_from && cpos == -1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1755:			  || (str_idx == lim->subexp_to && cpos == 0))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1756:			return cpos;
        -: 1757:		    }
        -: 1758:		}
        -: 1759:	    }
    #####: 1760:	  if (type == OP_OPEN_SUBEXP && subexp_idx == dfa->nodes[node].opr.idx
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1761:	      && str_idx == lim->subexp_from)
branch  0 never executed
branch  1 never executed
        -: 1762:	    {
    #####: 1763:	      pos = -1;
    #####: 1764:	      break;
        -: 1765:	    }
    #####: 1766:	  if (type == OP_CLOSE_SUBEXP && subexp_idx == dfa->nodes[node].opr.idx
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1767:	      && str_idx == lim->subexp_to)
branch  0 never executed
branch  1 never executed
    #####: 1768:	    break;
        -: 1769:	}
    #####: 1770:      if (node_idx == eclosures->nelem && str_idx == lim->subexp_to)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1771:	pos = 1;
        -: 1772:    }
    #####: 1773:  return pos;
        -: 1774:}
        -: 1775:
        -: 1776:/* Check the limitations of sub expressions LIMITS, and remove the nodes
        -: 1777:   which are against limitations from DEST_NODES. */
        -: 1778:
        -: 1779:static reg_errcode_t
function check_subexp_limits called 0 returned 0% blocks executed 0%
    #####: 1780:check_subexp_limits (dfa, dest_nodes, candidates, limits, bkref_ents, str_idx)
        -: 1781:     re_dfa_t *dfa;
        -: 1782:     re_node_set *dest_nodes;
        -: 1783:     const re_node_set *candidates;
        -: 1784:     re_node_set *limits;
        -: 1785:     struct re_backref_cache_entry *bkref_ents;
        -: 1786:     int str_idx;
        -: 1787:{
        -: 1788:  reg_errcode_t err;
        -: 1789:  int node_idx, lim_idx;
        -: 1790:
    #####: 1791:  for (lim_idx = 0; lim_idx < limits->nelem; ++lim_idx)
branch  0 never executed
branch  1 never executed
        -: 1792:    {
        -: 1793:      int subexp_idx;
        -: 1794:      struct re_backref_cache_entry *ent;
    #####: 1795:      ent = bkref_ents + limits->elems[lim_idx];
        -: 1796:
    #####: 1797:      if (str_idx <= ent->subexp_from || ent->str_idx < str_idx)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1798:	continue; /* This is unrelated limitation.  */
        -: 1799:
    #####: 1800:      subexp_idx = dfa->nodes[ent->node].opr.idx - 1;
    #####: 1801:      if (ent->subexp_to == str_idx)
branch  0 never executed
branch  1 never executed
        -: 1802:	{
    #####: 1803:	  int ops_node = -1;
    #####: 1804:	  int cls_node = -1;
    #####: 1805:	  for (node_idx = 0; node_idx < dest_nodes->nelem; ++node_idx)
branch  0 never executed
branch  1 never executed
        -: 1806:	    {
    #####: 1807:	      int node = dest_nodes->elems[node_idx];
    #####: 1808:	      re_token_type_t type= dfa->nodes[node].type;
    #####: 1809:	      if (type == OP_OPEN_SUBEXP
branch  0 never executed
branch  1 never executed
    #####: 1810:		  && subexp_idx == dfa->nodes[node].opr.idx)
branch  0 never executed
branch  1 never executed
    #####: 1811:		ops_node = node;
    #####: 1812:	      else if (type == OP_CLOSE_SUBEXP
branch  0 never executed
branch  1 never executed
    #####: 1813:		       && subexp_idx == dfa->nodes[node].opr.idx)
branch  0 never executed
branch  1 never executed
    #####: 1814:		cls_node = node;
        -: 1815:	    }
        -: 1816:
        -: 1817:	  /* Check the limitation of the open subexpression.  */
        -: 1818:	  /* Note that (ent->subexp_to = str_idx != ent->subexp_from).  */
    #####: 1819:	  if (ops_node >= 0)
branch  0 never executed
branch  1 never executed
        -: 1820:	    {
    #####: 1821:	      err = sub_epsilon_src_nodes(dfa, ops_node, dest_nodes,
call    0 never executed
        -: 1822:					  candidates);
    #####: 1823:	      if (BE (err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 1824:		return err;
        -: 1825:	    }
        -: 1826:	  /* Check the limitation of the close subexpression.  */
    #####: 1827:	  for (node_idx = 0; node_idx < dest_nodes->nelem; ++node_idx)
branch  0 never executed
branch  1 never executed
        -: 1828:	    {
    #####: 1829:	      int node = dest_nodes->elems[node_idx];
    #####: 1830:	      if (!re_node_set_contains (dfa->inveclosures + node, cls_node)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1831:		  && !re_node_set_contains (dfa->eclosures + node, cls_node))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1832:		{
        -: 1833:		  /* It is against this limitation.
        -: 1834:		     Remove it form the current sifted state.  */
    #####: 1835:		  err = sub_epsilon_src_nodes(dfa, node, dest_nodes,
call    0 never executed
        -: 1836:					      candidates);
    #####: 1837:		  if (BE (err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 1838:		    return err;
    #####: 1839:		  --node_idx;
        -: 1840:		}
        -: 1841:	    }
        -: 1842:	}
        -: 1843:      else /* (ent->subexp_to != str_idx)  */
        -: 1844:	{
    #####: 1845:	  for (node_idx = 0; node_idx < dest_nodes->nelem; ++node_idx)
branch  0 never executed
branch  1 never executed
        -: 1846:	    {
    #####: 1847:	      int node = dest_nodes->elems[node_idx];
    #####: 1848:	      re_token_type_t type= dfa->nodes[node].type;
    #####: 1849:	      if (type == OP_CLOSE_SUBEXP || type == OP_OPEN_SUBEXP)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1850:		{
    #####: 1851:		  if (subexp_idx != dfa->nodes[node].opr.idx)
branch  0 never executed
branch  1 never executed
    #####: 1852:		    continue;
    #####: 1853:		  if ((type == OP_CLOSE_SUBEXP && ent->subexp_to != str_idx)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1854:		      || (type == OP_OPEN_SUBEXP))
branch  0 never executed
branch  1 never executed
        -: 1855:		    {
        -: 1856:		      /* It is against this limitation.
        -: 1857:			 Remove it form the current sifted state.  */
    #####: 1858:		      err = sub_epsilon_src_nodes(dfa, node, dest_nodes,
call    0 never executed
        -: 1859:						  candidates);
    #####: 1860:		      if (BE (err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 1861:			return err;
        -: 1862:		    }
        -: 1863:		}
        -: 1864:	    }
        -: 1865:	}
        -: 1866:    }
    #####: 1867:  return REG_NOERROR;
        -: 1868:}
        -: 1869:
        -: 1870:static reg_errcode_t
function sift_states_bkref called 0 returned 0% blocks executed 0%
    #####: 1871:sift_states_bkref (preg, mctx, sctx, str_idx, dest_nodes)
        -: 1872:     const regex_t *preg;
        -: 1873:     re_match_context_t *mctx;
        -: 1874:     re_sift_context_t *sctx;
        -: 1875:     int str_idx;
        -: 1876:     re_node_set *dest_nodes;
        -: 1877:{
        -: 1878:  reg_errcode_t err;
    #####: 1879:  re_dfa_t *dfa = (re_dfa_t *)preg->buffer;
        -: 1880:  int node_idx, node;
        -: 1881:  re_sift_context_t local_sctx;
        -: 1882:  const re_node_set *candidates;
    #####: 1883:  candidates = ((mctx->state_log[str_idx] == NULL) ? &empty_set
branch  0 never executed
branch  1 never executed
    #####: 1884:		: &mctx->state_log[str_idx]->nodes);
    #####: 1885:  local_sctx.sifted_states = NULL; /* Mark that it hasn't been initialized.  */
        -: 1886:
    #####: 1887:  for (node_idx = 0; node_idx < candidates->nelem; ++node_idx)
branch  0 never executed
branch  1 never executed
        -: 1888:    {
    #####: 1889:      int cur_bkref_idx = re_string_cur_idx (mctx->input);
        -: 1890:      re_token_type_t type;
    #####: 1891:      node = candidates->elems[node_idx];
    #####: 1892:      type = dfa->nodes[node].type;
    #####: 1893:      if (node == sctx->cur_bkref && str_idx == cur_bkref_idx)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1894:	continue;
        -: 1895:      /* Avoid infinite loop for the REs like "()\1+".  */
    #####: 1896:      if (node == sctx->last_node && str_idx == sctx->last_str_idx)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1897:	continue;
    #####: 1898:      if (type == OP_BACK_REF)
branch  0 never executed
branch  1 never executed
        -: 1899:	{
    #####: 1900:	  int enabled_idx = search_cur_bkref_entry (mctx, str_idx);
call    0 never executed
    #####: 1901:	  for (; enabled_idx < mctx->nbkref_ents; ++enabled_idx)
branch  0 never executed
branch  1 never executed
        -: 1902:	    {
        -: 1903:	      int disabled_idx, subexp_len, to_idx, dst_node;
        -: 1904:	      struct re_backref_cache_entry *entry;
    #####: 1905:	      entry = mctx->bkref_ents + enabled_idx;
    #####: 1906:	      if (entry->str_idx > str_idx)
branch  0 never executed
branch  1 never executed
    #####: 1907:		break;
    #####: 1908:	      if (entry->node != node)
branch  0 never executed
branch  1 never executed
    #####: 1909:		  continue;
    #####: 1910:	      subexp_len = entry->subexp_to - entry->subexp_from;
    #####: 1911:	      to_idx = str_idx + subexp_len;
    #####: 1912:	      dst_node = (subexp_len ? dfa->nexts[node]
    #####: 1913:			  : dfa->edests[node].elems[0]);
branch  0 never executed
branch  1 never executed
        -: 1914:
    #####: 1915:	      if (to_idx > sctx->last_str_idx
branch  0 never executed
branch  1 never executed
    #####: 1916:		  || sctx->sifted_states[to_idx] == NULL
branch  0 never executed
branch  1 never executed
    #####: 1917:		  || !STATE_NODE_CONTAINS (sctx->sifted_states[to_idx],
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 1918:					   dst_node)
    #####: 1919:		  || check_dst_limits (dfa, &sctx->limits, mctx, node,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1920:				       str_idx, dst_node, to_idx))
    #####: 1921:		continue;
        -: 1922:		{
        -: 1923:		  re_dfastate_t *cur_state;
    #####: 1924:		  entry->flag = 0;
    #####: 1925:		  for (disabled_idx = enabled_idx + 1;
    #####: 1926:		       disabled_idx < mctx->nbkref_ents; ++disabled_idx)
branch  0 never executed
branch  1 never executed
        -: 1927:		    {
        -: 1928:		      struct re_backref_cache_entry *entry2;
    #####: 1929:		      entry2 = mctx->bkref_ents + disabled_idx;
    #####: 1930:		      if (entry2->str_idx > str_idx)
branch  0 never executed
branch  1 never executed
    #####: 1931:			break;
    #####: 1932:		      entry2->flag = (entry2->node == node) ? 1 : entry2->flag;
branch  0 never executed
branch  1 never executed
        -: 1933:		    }
        -: 1934:
    #####: 1935:		  if (local_sctx.sifted_states == NULL)
branch  0 never executed
branch  1 never executed
        -: 1936:		    {
    #####: 1937:		      local_sctx = *sctx;
    #####: 1938:		      err = re_node_set_init_copy (&local_sctx.limits,
    #####: 1939:						   &sctx->limits);
call    0 never executed
    #####: 1940:		      if (BE (err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 1941:			goto free_return;
        -: 1942:		    }
    #####: 1943:		  local_sctx.last_node = node;
    #####: 1944:		  local_sctx.last_str_idx = str_idx;
    #####: 1945:		  err = re_node_set_insert (&local_sctx.limits, enabled_idx);
call    0 never executed
        -: 1946:		  if (BE (err < 0, 0))
        -: 1947:		    {
        -: 1948:		      err = REG_ESPACE;
        -: 1949:		      goto free_return;
        -: 1950:		    }
    #####: 1951:		  cur_state = local_sctx.sifted_states[str_idx];
    #####: 1952:		  err = sift_states_backward (preg, mctx, &local_sctx);
call    0 never executed
    #####: 1953:		  if (BE (err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 1954:		    goto free_return;
    #####: 1955:		  if (sctx->limited_states != NULL)
branch  0 never executed
branch  1 never executed
        -: 1956:		    {
    #####: 1957:		      err = merge_state_array (dfa, sctx->limited_states,
call    0 never executed
        -: 1958:					       local_sctx.sifted_states,
        -: 1959:					       str_idx + 1);
    #####: 1960:		      if (BE (err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 1961:			goto free_return;
        -: 1962:		    }
    #####: 1963:		  local_sctx.sifted_states[str_idx] = cur_state;
    #####: 1964:		  re_node_set_remove (&local_sctx.limits, enabled_idx);
call    0 never executed
call    1 never executed
        -: 1965:		  /* We must not use the variable entry here, since
        -: 1966:		     mctx->bkref_ents might be realloced.  */
    #####: 1967:		  mctx->bkref_ents[enabled_idx].flag = 1;
        -: 1968:		}
        -: 1969:	    }
    #####: 1970:	  enabled_idx = search_cur_bkref_entry (mctx, str_idx);
call    0 never executed
    #####: 1971:	  for (; enabled_idx < mctx->nbkref_ents; ++enabled_idx)
branch  0 never executed
branch  1 never executed
        -: 1972:	    {
        -: 1973:	      struct re_backref_cache_entry *entry;
    #####: 1974:	      entry = mctx->bkref_ents + enabled_idx;
    #####: 1975:	      if (entry->str_idx > str_idx)
branch  0 never executed
branch  1 never executed
    #####: 1976:		break;
    #####: 1977:	      if (entry->node == node)
branch  0 never executed
branch  1 never executed
    #####: 1978:		entry->flag = 0;
        -: 1979:	    }
        -: 1980:	}
        -: 1981:    }
    #####: 1982:  err = REG_NOERROR;
    #####: 1983: free_return:
    #####: 1984:  if (local_sctx.sifted_states != NULL)
branch  0 never executed
branch  1 never executed
        -: 1985:    {
    #####: 1986:      re_node_set_free (&local_sctx.limits);
        -: 1987:    }
        -: 1988:
    #####: 1989:  return err;
        -: 1990:}
        -: 1991:
        -: 1992:
        -: 1993:#ifdef RE_ENABLE_I18N
        -: 1994:static int
        -: 1995:sift_states_iter_mb (preg, mctx, sctx, node_idx, str_idx, max_str_idx)
        -: 1996:    const regex_t *preg;
        -: 1997:    const re_match_context_t *mctx;
        -: 1998:    re_sift_context_t *sctx;
        -: 1999:    int node_idx, str_idx, max_str_idx;
        -: 2000:{
        -: 2001:  re_dfa_t *dfa = (re_dfa_t *) preg->buffer;
        -: 2002:  int naccepted;
        -: 2003:  /* Check the node can accept `multi byte'.  */
        -: 2004:  naccepted = check_node_accept_bytes (preg, node_idx, mctx->input, str_idx);
        -: 2005:  if (naccepted > 0 && str_idx + naccepted <= max_str_idx &&
        -: 2006:      !STATE_NODE_CONTAINS (sctx->sifted_states[str_idx + naccepted],
        -: 2007:			    dfa->nexts[node_idx]))
        -: 2008:    /* The node can't accept the `multi byte', or the
        -: 2009:       destination was already throwed away, then the node
        -: 2010:       could't accept the current input `multi byte'.   */
        -: 2011:    naccepted = 0;
        -: 2012:  /* Otherwise, it is sure that the node could accept
        -: 2013:     `naccepted' bytes input.  */
        -: 2014:  return naccepted;
        -: 2015:}
        -: 2016:#endif /* RE_ENABLE_I18N */
        -: 2017:
        -: 2018:
        -: 2019:/* Functions for state transition.  */
        -: 2020:
        -: 2021:/* Return the next state to which the current state STATE will transit by
        -: 2022:   accepting the current input byte, and update STATE_LOG if necessary.
        -: 2023:   If STATE can accept a multibyte char/collating element/back reference
        -: 2024:   update the destination of STATE_LOG.  */
        -: 2025:
        -: 2026:static re_dfastate_t *
function transit_state called 993920 returned 100% blocks executed 47%
   993920: 2027:transit_state (err, preg, mctx, state, fl_search)
        -: 2028:     reg_errcode_t *err;
        -: 2029:     const regex_t *preg;
        -: 2030:     re_match_context_t *mctx;
        -: 2031:     re_dfastate_t *state;
        -: 2032:     int fl_search;
        -: 2033:{
   993920: 2034:  re_dfa_t *dfa = (re_dfa_t *) preg->buffer;
        -: 2035:  re_dfastate_t **trtable, *next_state;
        -: 2036:  unsigned char ch;
        -: 2037:  int cur_idx;
        -: 2038:
   993920: 2039:  if (re_string_cur_idx (mctx->input) + 1 >= mctx->input->bufs_len
branch  0 taken 989435 (fallthrough)
branch  1 taken 4485
   989435: 2040:      || (re_string_cur_idx (mctx->input) + 1 >= mctx->input->valid_len
branch  0 taken 28762 (fallthrough)
branch  1 taken 960673
    28762: 2041:	  && mctx->input->valid_len < mctx->input->len))
branch  0 taken 0 (fallthrough)
branch  1 taken 28762
        -: 2042:    {
     4485: 2043:      *err = extend_buffers (mctx);
call    0 returned 4485
     4485: 2044:      if (BE (*err != REG_NOERROR, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 4485
    #####: 2045:	return NULL;
        -: 2046:    }
        -: 2047:
   993920: 2048:  *err = REG_NOERROR;
   993920: 2049:  if (state == NULL)
branch  0 taken 0 (fallthrough)
branch  1 taken 993920
        -: 2050:    {
    #####: 2051:      next_state = state;
    #####: 2052:      re_string_skip_bytes (mctx->input, 1);
        -: 2053:    }
        -: 2054:  else
        -: 2055:    {
        -: 2056:#ifdef RE_ENABLE_I18N
        -: 2057:      /* If the current state can accept multibyte.  */
        -: 2058:      if (state->accept_mb)
        -: 2059:	{
        -: 2060:	  *err = transit_state_mb (preg, state, mctx);
        -: 2061:	  if (BE (*err != REG_NOERROR, 0))
        -: 2062:	    return NULL;
        -: 2063:	}
        -: 2064:#endif /* RE_ENABLE_I18N */
        -: 2065:
        -: 2066:      /* Then decide the next state with the single byte.  */
        -: 2067:      if (1)
        -: 2068:	{
        -: 2069:	  /* Use transition table  */
   993920: 2070:	  ch = re_string_fetch_byte (mctx->input);
  993920*: 2071:	  trtable = fl_search ? state->trtable_search : state->trtable;
branch  0 taken 0 (fallthrough)
branch  1 taken 993920
   993920: 2072:	  if (trtable == NULL)
branch  0 taken 2814 (fallthrough)
branch  1 taken 991106
        -: 2073:	    {
     2814: 2074:	      trtable = build_trtable (preg, state, fl_search);
call    0 returned 2814
     2814: 2075:	      if (fl_search)
branch  0 taken 0 (fallthrough)
branch  1 taken 2814
    #####: 2076:		state->trtable_search = trtable;
        -: 2077:	      else
     2814: 2078:		state->trtable = trtable;
        -: 2079:	    }
   993920: 2080:	  next_state = trtable[ch];
        -: 2081:	}
        -: 2082:      else
        -: 2083:	{
        -: 2084:	  /* don't use transition table  */
        -: 2085:	  next_state = transit_state_sb (err, preg, state, fl_search, mctx);
        -: 2086:	  if (BE (next_state == NULL && err != REG_NOERROR, 0))
        -: 2087:	    return NULL;
        -: 2088:	}
        -: 2089:    }
        -: 2090:
   993920: 2091:  cur_idx = re_string_cur_idx (mctx->input);
        -: 2092:  /* Update the state_log if we need.  */
   993920: 2093:  if (mctx->state_log != NULL)
branch  0 taken 3817 (fallthrough)
branch  1 taken 990103
        -: 2094:    {
     3817: 2095:      if (cur_idx > mctx->state_log_top)
branch  0 taken 3817 (fallthrough)
branch  1 taken 0
        -: 2096:	{
     3817: 2097:	  mctx->state_log[cur_idx] = next_state;
     3817: 2098:	  mctx->state_log_top = cur_idx;
        -: 2099:	}
    #####: 2100:      else if (mctx->state_log[cur_idx] == 0)
branch  0 never executed
branch  1 never executed
        -: 2101:	{
    #####: 2102:	  mctx->state_log[cur_idx] = next_state;
        -: 2103:	}
        -: 2104:      else
        -: 2105:	{
        -: 2106:	  re_dfastate_t *pstate;
        -: 2107:	  unsigned int context;
    #####: 2108:	  re_node_set next_nodes, *log_nodes, *table_nodes = NULL;
        -: 2109:	  /* If (state_log[cur_idx] != 0), it implies that cur_idx is
        -: 2110:	     the destination of a multibyte char/collating element/
        -: 2111:	     back reference.  Then the next state is the union set of
        -: 2112:	     these destinations and the results of the transition table.  */
    #####: 2113:	  pstate = mctx->state_log[cur_idx];
    #####: 2114:	  log_nodes = pstate->entrance_nodes;
    #####: 2115:	  if (next_state != NULL)
branch  0 never executed
branch  1 never executed
        -: 2116:	    {
    #####: 2117:	      table_nodes = next_state->entrance_nodes;
    #####: 2118:	      *err = re_node_set_init_union (&next_nodes, table_nodes,
call    0 never executed
        -: 2119:					     log_nodes);
    #####: 2120:	      if (BE (*err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 2121:		return NULL;
        -: 2122:	    }
        -: 2123:	  else
    #####: 2124:	    next_nodes = *log_nodes;
        -: 2125:	  /* Note: We already add the nodes of the initial state,
        -: 2126:		   then we don't need to add them here.  */
        -: 2127:
    #####: 2128:	  context = re_string_context_at (mctx->input,
    #####: 2129:					  re_string_cur_idx (mctx->input) - 1,
    #####: 2130:					  mctx->eflags, preg->newline_anchor);
call    0 never executed
    #####: 2131:	  next_state = mctx->state_log[cur_idx]
    #####: 2132:	    = re_acquire_state_context (err, dfa, &next_nodes, context);
call    0 never executed
        -: 2133:	  /* We don't need to check errors here, since the return value of
        -: 2134:	     this function is next_state and ERR is already set.  */
        -: 2135:
    #####: 2136:	  if (table_nodes != NULL)
branch  0 never executed
branch  1 never executed
    #####: 2137:	    re_node_set_free (&next_nodes);
        -: 2138:	}
        -: 2139:    }
        -: 2140:
        -: 2141:  /* Check OP_OPEN_SUBEXP in the current state in case that we use them
        -: 2142:     later.  We must check them here, since the back references in the
        -: 2143:     next state might use them.  */
  993920*: 2144:  if (dfa->nbackref && next_state/* && fl_process_bkref */)
branch  0 taken 0 (fallthrough)
branch  1 taken 993920
branch  2 never executed
branch  3 never executed
        -: 2145:    {
    #####: 2146:      *err = check_subexp_matching_top (dfa, mctx, &next_state->nodes,
call    0 never executed
        -: 2147:					cur_idx);
    #####: 2148:      if (BE (*err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 2149:	return NULL;
        -: 2150:    }
        -: 2151:
        -: 2152:  /* If the next state has back references.  */
   993920: 2153:  if (next_state != NULL && next_state->has_backref)
branch  0 taken 390503 (fallthrough)
branch  1 taken 603417
branch  2 taken 0 (fallthrough)
branch  3 taken 390503
        -: 2154:    {
    #####: 2155:      *err = transit_state_bkref (preg, next_state, mctx);
call    0 never executed
    #####: 2156:      if (BE (*err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 2157:	return NULL;
    #####: 2158:      next_state = mctx->state_log[cur_idx];
        -: 2159:    }
   993920: 2160:  return next_state;
        -: 2161:}
        -: 2162:
        -: 2163:/* Helper functions for transit_state.  */
        -: 2164:
        -: 2165:static reg_errcode_t
function check_subexp_matching_top called 0 returned 0% blocks executed 0%
    #####: 2166:check_subexp_matching_top (dfa, mctx, cur_nodes, str_idx)
        -: 2167:     re_dfa_t *dfa;
        -: 2168:     re_match_context_t *mctx;
        -: 2169:     re_node_set *cur_nodes;
        -: 2170:     int str_idx;
        -: 2171:{
        -: 2172:  int node_idx;
        -: 2173:  reg_errcode_t err;
        -: 2174:
    #####: 2175:  for (node_idx = 0; node_idx < cur_nodes->nelem; ++node_idx)
branch  0 never executed
branch  1 never executed
        -: 2176:    {
    #####: 2177:      int node = cur_nodes->elems[node_idx];
    #####: 2178:      if (dfa->nodes[node].type == OP_OPEN_SUBEXP)
branch  0 never executed
branch  1 never executed
        -: 2179:	{
    #####: 2180:	  err = match_ctx_add_subtop (mctx, node, str_idx);
call    0 never executed
    #####: 2181:	  if (BE (err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 2182:	    return err;
        -: 2183:	}
        -: 2184:    }
    #####: 2185:  return REG_NOERROR;
        -: 2186:}
        -: 2187:
        -: 2188:/* Return the next state to which the current state STATE will transit by
        -: 2189:   accepting the current input byte.  */
        -: 2190:
        -: 2191:static re_dfastate_t *
function transit_state_sb called 0 returned 0% blocks executed 0%
    #####: 2192:transit_state_sb (err, preg, state, fl_search, mctx)
        -: 2193:     reg_errcode_t *err;
        -: 2194:     const regex_t *preg;
        -: 2195:     re_dfastate_t *state;
        -: 2196:     int fl_search;
        -: 2197:     re_match_context_t *mctx;
        -: 2198:{
    #####: 2199:  re_dfa_t *dfa = (re_dfa_t *) preg->buffer;
        -: 2200:  re_node_set next_nodes;
        -: 2201:  re_dfastate_t *next_state;
    #####: 2202:  int node_cnt, cur_str_idx = re_string_cur_idx (mctx->input);
        -: 2203:  unsigned int context;
        -: 2204:
    #####: 2205:  *err = re_node_set_alloc (&next_nodes, state->nodes.nelem + 1);
call    0 never executed
    #####: 2206:  if (BE (*err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 2207:    return NULL;
    #####: 2208:  for (node_cnt = 0; node_cnt < state->nodes.nelem; ++node_cnt)
branch  0 never executed
branch  1 never executed
        -: 2209:    {
    #####: 2210:      int cur_node = state->nodes.elems[node_cnt];
    #####: 2211:      if (check_node_accept (preg, dfa->nodes + cur_node, mctx, cur_str_idx))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2212:	{
    #####: 2213:	  *err = re_node_set_merge (&next_nodes,
    #####: 2214:				    dfa->eclosures + dfa->nexts[cur_node]);
call    0 never executed
    #####: 2215:	  if (BE (*err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
        -: 2216:	    {
    #####: 2217:	      re_node_set_free (&next_nodes);
    #####: 2218:	      return NULL;
        -: 2219:	    }
        -: 2220:	}
        -: 2221:    }
    #####: 2222:  if (fl_search)
branch  0 never executed
branch  1 never executed
        -: 2223:    {
        -: 2224:#ifdef RE_ENABLE_I18N
        -: 2225:      int not_initial = 0;
        -: 2226:      if (MB_CUR_MAX > 1)
        -: 2227:	for (node_cnt = 0; node_cnt < next_nodes.nelem; ++node_cnt)
        -: 2228:	  if (dfa->nodes[next_nodes.elems[node_cnt]].type == CHARACTER)
        -: 2229:	    {
        -: 2230:	      not_initial = dfa->nodes[next_nodes.elems[node_cnt]].mb_partial;
        -: 2231:	      break;
        -: 2232:	    }
        -: 2233:      if (!not_initial)
        -: 2234:#endif
        -: 2235:	{
    #####: 2236:	  *err = re_node_set_merge (&next_nodes,
    #####: 2237:				    dfa->init_state->entrance_nodes);
call    0 never executed
    #####: 2238:	  if (BE (*err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
        -: 2239:	    {
    #####: 2240:	      re_node_set_free (&next_nodes);
    #####: 2241:	      return NULL;
        -: 2242:	    }
        -: 2243:	}
        -: 2244:    }
    #####: 2245:  context = re_string_context_at (mctx->input, cur_str_idx, mctx->eflags,
    #####: 2246:				  preg->newline_anchor);
call    0 never executed
    #####: 2247:  next_state = re_acquire_state_context (err, dfa, &next_nodes, context);
call    0 never executed
        -: 2248:  /* We don't need to check errors here, since the return value of
        -: 2249:     this function is next_state and ERR is already set.  */
        -: 2250:
    #####: 2251:  re_node_set_free (&next_nodes);
    #####: 2252:  re_string_skip_bytes (mctx->input, 1);
    #####: 2253:  return next_state;
        -: 2254:}
        -: 2255:
        -: 2256:#ifdef RE_ENABLE_I18N
        -: 2257:static reg_errcode_t
        -: 2258:transit_state_mb (preg, pstate, mctx)
        -: 2259:    const regex_t *preg;
        -: 2260:    re_dfastate_t *pstate;
        -: 2261:    re_match_context_t *mctx;
        -: 2262:{
        -: 2263:  reg_errcode_t err;
        -: 2264:  re_dfa_t *dfa = (re_dfa_t *) preg->buffer;
        -: 2265:  int i;
        -: 2266:
        -: 2267:  for (i = 0; i < pstate->nodes.nelem; ++i)
        -: 2268:    {
        -: 2269:      re_node_set dest_nodes, *new_nodes;
        -: 2270:      int cur_node_idx = pstate->nodes.elems[i];
        -: 2271:      int naccepted = 0, dest_idx;
        -: 2272:      unsigned int context;
        -: 2273:      re_dfastate_t *dest_state;
        -: 2274:
        -: 2275:      if (dfa->nodes[cur_node_idx].constraint)
        -: 2276:	{
        -: 2277:	  context = re_string_context_at (mctx->input,
        -: 2278:					  re_string_cur_idx (mctx->input),
        -: 2279:					  mctx->eflags, preg->newline_anchor);
        -: 2280:	  if (NOT_SATISFY_NEXT_CONSTRAINT (dfa->nodes[cur_node_idx].constraint,
        -: 2281:					   context))
        -: 2282:	    continue;
        -: 2283:	}
        -: 2284:
        -: 2285:      /* How many bytes the node can accepts?  */
        -: 2286:      if (ACCEPT_MB_NODE (dfa->nodes[cur_node_idx].type))
        -: 2287:	naccepted = check_node_accept_bytes (preg, cur_node_idx, mctx->input,
        -: 2288:					     re_string_cur_idx (mctx->input));
        -: 2289:      if (naccepted == 0)
        -: 2290:	continue;
        -: 2291:
        -: 2292:      /* The node can accepts `naccepted' bytes.  */
        -: 2293:      dest_idx = re_string_cur_idx (mctx->input) + naccepted;
        -: 2294:      mctx->max_mb_elem_len = ((mctx->max_mb_elem_len < naccepted) ? naccepted
        -: 2295:			       : mctx->max_mb_elem_len);
        -: 2296:      err = clean_state_log_if_need (mctx, dest_idx);
        -: 2297:      if (BE (err != REG_NOERROR, 0))
        -: 2298:	return err;
        -: 2299:#ifdef DEBUG
        -: 2300:      assert (dfa->nexts[cur_node_idx] != -1);
        -: 2301:#endif
        -: 2302:      /* `cur_node_idx' may point the entity of the OP_CONTEXT_NODE,
        -: 2303:	 then we use pstate->nodes.elems[i] instead.  */
        -: 2304:      new_nodes = dfa->eclosures + dfa->nexts[pstate->nodes.elems[i]];
        -: 2305:
        -: 2306:      dest_state = mctx->state_log[dest_idx];
        -: 2307:      if (dest_state == NULL)
        -: 2308:	dest_nodes = *new_nodes;
        -: 2309:      else
        -: 2310:	{
        -: 2311:	  err = re_node_set_init_union (&dest_nodes,
        -: 2312:					dest_state->entrance_nodes, new_nodes);
        -: 2313:	  if (BE (err != REG_NOERROR, 0))
        -: 2314:	    return err;
        -: 2315:	}
        -: 2316:      context = re_string_context_at (mctx->input, dest_idx - 1, mctx->eflags,
        -: 2317:				      preg->newline_anchor);
        -: 2318:      mctx->state_log[dest_idx]
        -: 2319:	= re_acquire_state_context (&err, dfa, &dest_nodes, context);
        -: 2320:      if (dest_state != NULL)
        -: 2321:	re_node_set_free (&dest_nodes);
        -: 2322:      if (BE (mctx->state_log[dest_idx] == NULL && err != REG_NOERROR, 0))
        -: 2323:	return err;
        -: 2324:    }
        -: 2325:  return REG_NOERROR;
        -: 2326:}
        -: 2327:#endif /* RE_ENABLE_I18N */
        -: 2328:
        -: 2329:static reg_errcode_t
function transit_state_bkref called 0 returned 0% blocks executed 0%
    #####: 2330:transit_state_bkref (preg, pstate, mctx)
        -: 2331:    const regex_t *preg;
        -: 2332:    re_dfastate_t *pstate;
        -: 2333:    re_match_context_t *mctx;
        -: 2334:{
        -: 2335:  reg_errcode_t err;
    #####: 2336:  err = transit_state_bkref_loop (preg, &pstate->nodes, mctx);
call    0 never executed
    #####: 2337:  return err;
        -: 2338:}
        -: 2339:
        -: 2340:static reg_errcode_t
function transit_state_bkref_loop called 0 returned 0% blocks executed 0%
    #####: 2341:transit_state_bkref_loop (preg, nodes, mctx)
        -: 2342:    const regex_t *preg;
        -: 2343:    re_node_set *nodes;
        -: 2344:    re_match_context_t *mctx;
        -: 2345:{
        -: 2346:  reg_errcode_t err;
    #####: 2347:  re_dfa_t *dfa = (re_dfa_t *) preg->buffer;
        -: 2348:  int i;
    #####: 2349:  regmatch_t *cur_regs = re_malloc (regmatch_t, preg->re_nsub + 1);
    #####: 2350:  int cur_str_idx = re_string_cur_idx (mctx->input);
    #####: 2351:  if (BE (cur_regs == NULL, 0))
branch  0 never executed
branch  1 never executed
    #####: 2352:    return REG_ESPACE;
        -: 2353:
    #####: 2354:  for (i = 0; i < nodes->nelem; ++i)
branch  0 never executed
branch  1 never executed
        -: 2355:    {
        -: 2356:      int dest_str_idx, subexp_idx, prev_nelem, bkc_idx;
    #####: 2357:      int node_idx = nodes->elems[i];
        -: 2358:      unsigned int context;
    #####: 2359:      re_token_t *node = dfa->nodes + node_idx;
        -: 2360:      re_node_set *new_dest_nodes;
        -: 2361:
        -: 2362:      /* Check whether `node' is a backreference or not.  */
    #####: 2363:      if (node->type == OP_BACK_REF)
branch  0 never executed
branch  1 never executed
    #####: 2364:	subexp_idx = node->opr.idx;
        -: 2365:      else
    #####: 2366:	continue;
        -: 2367:
    #####: 2368:      if (node->constraint)
branch  0 never executed
branch  1 never executed
        -: 2369:	{
    #####: 2370:	  context = re_string_context_at (mctx->input, cur_str_idx,
    #####: 2371:					  mctx->eflags, preg->newline_anchor);
call    0 never executed
    #####: 2372:	  if (NOT_SATISFY_NEXT_CONSTRAINT (node->constraint, context))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
    #####: 2373:	    continue;
        -: 2374:	}
        -: 2375:
        -: 2376:      /* `node' is a backreference.
        -: 2377:	 Check the substring which the substring matched.  */
    #####: 2378:      err = get_subexp (preg, mctx, node_idx, cur_str_idx, subexp_idx - 1);
call    0 never executed
    #####: 2379:      if (BE (err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 2380:	goto free_return;
        -: 2381:
        -: 2382:      /* And add the epsilon closures (which is `new_dest_nodes') of
        -: 2383:	 the backreference to appropriate state_log.  */
        -: 2384:#ifdef DEBUG
        -: 2385:      assert (dfa->nexts[node_idx] != -1);
        -: 2386:#endif
    #####: 2387:      bkc_idx = search_cur_bkref_entry (mctx, cur_str_idx);
call    0 never executed
    #####: 2388:      for (; bkc_idx < mctx->nbkref_ents; ++bkc_idx)
branch  0 never executed
branch  1 never executed
        -: 2389:	{
        -: 2390:	  int subexp_len;
        -: 2391:	  re_dfastate_t *dest_state;
        -: 2392:	  struct re_backref_cache_entry *bkref_ent;
    #####: 2393:	  bkref_ent = mctx->bkref_ents + bkc_idx;
    #####: 2394:	  if (bkref_ent->node != node_idx || bkref_ent->str_idx != cur_str_idx)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2395:	    continue;
    #####: 2396:	  subexp_len = bkref_ent->subexp_to - bkref_ent->subexp_from;
    #####: 2397:	  new_dest_nodes = (subexp_len == 0
    #####: 2398:			    ? dfa->eclosures + dfa->edests[node_idx].elems[0]
    #####: 2399:			    : dfa->eclosures + dfa->nexts[node_idx]);
branch  0 never executed
branch  1 never executed
    #####: 2400:	  dest_str_idx = (cur_str_idx + bkref_ent->subexp_to
    #####: 2401:			  - bkref_ent->subexp_from);
    #####: 2402:	  context = re_string_context_at (mctx->input, dest_str_idx - 1,
    #####: 2403:					  mctx->eflags, preg->newline_anchor);
call    0 never executed
    #####: 2404:	  dest_state = mctx->state_log[dest_str_idx];
    #####: 2405:	  prev_nelem = ((mctx->state_log[cur_str_idx] == NULL) ? 0
    #####: 2406:			: mctx->state_log[cur_str_idx]->nodes.nelem);
branch  0 never executed
branch  1 never executed
        -: 2407:	  /* Add `new_dest_node' to state_log.  */
    #####: 2408:	  if (dest_state == NULL)
branch  0 never executed
branch  1 never executed
        -: 2409:	    {
    #####: 2410:	      mctx->state_log[dest_str_idx]
    #####: 2411:		= re_acquire_state_context (&err, dfa, new_dest_nodes,
call    0 never executed
        -: 2412:					    context);
    #####: 2413:	      if (BE (mctx->state_log[dest_str_idx] == NULL
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2414:		      && err != REG_NOERROR, 0))
    #####: 2415:		goto free_return;
        -: 2416:	    }
        -: 2417:	  else
        -: 2418:	    {
        -: 2419:	      re_node_set dest_nodes;
    #####: 2420:	      err = re_node_set_init_union (&dest_nodes,
    #####: 2421:					    dest_state->entrance_nodes,
call    0 never executed
        -: 2422:					    new_dest_nodes);
    #####: 2423:	      if (BE (err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
        -: 2424:		{
    #####: 2425:		  re_node_set_free (&dest_nodes);
    #####: 2426:		  goto free_return;
        -: 2427:		}
    #####: 2428:	      mctx->state_log[dest_str_idx]
    #####: 2429:		= re_acquire_state_context (&err, dfa, &dest_nodes, context);
call    0 never executed
    #####: 2430:	      re_node_set_free (&dest_nodes);
    #####: 2431:	      if (BE (mctx->state_log[dest_str_idx] == NULL
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2432:		      && err != REG_NOERROR, 0))
    #####: 2433:		goto free_return;
        -: 2434:	    }
        -: 2435:	  /* We need to check recursively if the backreference can epsilon
        -: 2436:	     transit.  */
    #####: 2437:	  if (subexp_len == 0
branch  0 never executed
branch  1 never executed
    #####: 2438:	      && mctx->state_log[cur_str_idx]->nodes.nelem > prev_nelem)
branch  0 never executed
branch  1 never executed
        -: 2439:	    {
    #####: 2440:	      err = check_subexp_matching_top (dfa, mctx, new_dest_nodes,
call    0 never executed
        -: 2441:					       cur_str_idx);
    #####: 2442:	      if (BE (err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 2443:		goto free_return;
    #####: 2444:	      err = transit_state_bkref_loop (preg, new_dest_nodes, mctx);
call    0 never executed
    #####: 2445:	      if (BE (err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 2446:		goto free_return;
        -: 2447:	    }
        -: 2448:	}
        -: 2449:    }
    #####: 2450:  err = REG_NOERROR;
    #####: 2451: free_return:
    #####: 2452:  re_free (cur_regs);
    #####: 2453:  return err;
        -: 2454:}
        -: 2455:
        -: 2456:static reg_errcode_t
function get_subexp called 0 returned 0% blocks executed 0%
    #####: 2457:get_subexp (preg, mctx, bkref_node, bkref_str_idx, subexp_idx)
        -: 2458:     const regex_t *preg;
        -: 2459:     re_match_context_t *mctx;
        -: 2460:     int bkref_node, bkref_str_idx, subexp_idx;
        -: 2461:{
        -: 2462:  int sub_top_idx;
    #####: 2463:  re_dfa_t *dfa = (re_dfa_t *) preg->buffer;
    #####: 2464:  char *buf = re_string_get_buffer (mctx->input);
        -: 2465:  /* For each sub expression...  */
    #####: 2466:  for (sub_top_idx = 0; sub_top_idx < mctx->nsub_tops; ++sub_top_idx)
branch  0 never executed
branch  1 never executed
        -: 2467:    {
        -: 2468:      reg_errcode_t err;
    #####: 2469:      re_sub_match_top_t *sub_top = mctx->sub_tops[sub_top_idx];
        -: 2470:      re_sub_match_last_t *sub_last;
        -: 2471:      int sub_last_idx, sl_str;
        -: 2472:      char *bkref_str;
        -: 2473:
    #####: 2474:      if (dfa->nodes[sub_top->node].opr.idx != subexp_idx)
branch  0 never executed
branch  1 never executed
    #####: 2475:	continue; /* It isn't related.  */
        -: 2476:
    #####: 2477:      sl_str = sub_top->str_idx;
    #####: 2478:      bkref_str = buf + bkref_str_idx;
        -: 2479:      /* At first, check the last node of sub expressions we already
        -: 2480:	 evaluated.  */
    #####: 2481:      for (sub_last_idx = 0; sub_last_idx < sub_top->nlasts; ++sub_last_idx)
branch  0 never executed
branch  1 never executed
        -: 2482:	{
        -: 2483:	  int sl_str_diff;
    #####: 2484:	  sub_last = sub_top->lasts[sub_last_idx];
    #####: 2485:	  sl_str_diff = sub_last->str_idx - sl_str;
        -: 2486:	  /* The matched string by the sub expression match with the substring
        -: 2487:	     at the back reference?  */
    #####: 2488:	  if (sl_str_diff > 0
branch  0 never executed
branch  1 never executed
    #####: 2489:	      && my_memcmp (bkref_str, buf + sl_str, sl_str_diff) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2490:	    break; /* We don't need to search this sub expression any more.  */
    #####: 2491:	  bkref_str += sl_str_diff;
    #####: 2492:	  sl_str += sl_str_diff;
    #####: 2493:	  err = get_subexp_sub (preg, mctx, sub_top, sub_last, bkref_node,
call    0 never executed
        -: 2494:				bkref_str_idx, subexp_idx);
    #####: 2495:	  if (err == REG_NOMATCH)
branch  0 never executed
branch  1 never executed
    #####: 2496:	    continue;
    #####: 2497:	  if (BE (err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 2498:	    return err;
        -: 2499:	}
    #####: 2500:      if (sub_last_idx < sub_top->nlasts)
branch  0 never executed
branch  1 never executed
    #####: 2501:	continue;
    #####: 2502:      if (sub_last_idx > 0)
branch  0 never executed
branch  1 never executed
    #####: 2503:	++sl_str;
        -: 2504:      /* Then, search for the other last nodes of the sub expression.  */
    #####: 2505:      for (; sl_str <= bkref_str_idx; ++sl_str)
branch  0 never executed
branch  1 never executed
        -: 2506:	{
        -: 2507:	  int cls_node, sl_str_off;
        -: 2508:	  re_sub_match_last_t cur_last;
        -: 2509:	  re_node_set *nodes;
    #####: 2510:	  sl_str_off = sl_str - sub_top->str_idx;
        -: 2511:	  /* The matched string by the sub expression match with the substring
        -: 2512:	     at the back reference?  */
    #####: 2513:	  if (sl_str_off > 0
branch  0 never executed
branch  1 never executed
    #####: 2514:	      && my_memcmp (bkref_str++, buf + sl_str - 1, 1) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2515:	    break; /* We don't need to search this sub expression any more.  */
    #####: 2516:	  if (mctx->state_log[sl_str] == NULL)
branch  0 never executed
branch  1 never executed
    #####: 2517:	    continue;
        -: 2518:	  /* Does this state have a ')' of the sub expression?  */
    #####: 2519:	  nodes = &mctx->state_log[sl_str]->nodes;
    #####: 2520:	  cls_node = find_subexp_node (dfa, nodes, subexp_idx, 0);
call    0 never executed
    #####: 2521:	  if (cls_node == -1)
branch  0 never executed
branch  1 never executed
    #####: 2522:	    continue; /* No.  */
    #####: 2523:	  if (sub_top->path == NULL)
branch  0 never executed
branch  1 never executed
        -: 2524:	    {
    #####: 2525:	      sub_top->path = calloc (sizeof (state_array_t), 1);
    #####: 2526:	      if (sub_top->path == NULL)
branch  0 never executed
branch  1 never executed
    #####: 2527:		return REG_ESPACE;
        -: 2528:	    }
        -: 2529:	  /* Can the OP_OPEN_SUBEXP node arrive the OP_CLOSE_SUBEXP node
        -: 2530:	     in the current context?  */
    #####: 2531:	  memset (&cur_last, '\0', sizeof (re_sub_match_last_t));
    #####: 2532:	  cur_last.node = cls_node;
    #####: 2533:	  cur_last.str_idx = sl_str;
    #####: 2534:	  err = check_arrival (preg, mctx, sub_top, &cur_last, -1, -1);
call    0 never executed
    #####: 2535:	  if (err == REG_NOMATCH)
branch  0 never executed
branch  1 never executed
    #####: 2536:	      continue;
    #####: 2537:	  if (BE (err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 2538:	      return err;
    #####: 2539:	  sub_last = match_ctx_add_sublast (sub_top, cls_node, sl_str);
call    0 never executed
    #####: 2540:	  if (BE (sub_last == NULL, 0))
branch  0 never executed
branch  1 never executed
    #####: 2541:	    return REG_ESPACE;
    #####: 2542:	  err = get_subexp_sub (preg, mctx, sub_top, sub_last, bkref_node,
call    0 never executed
        -: 2543:				bkref_str_idx, subexp_idx);
    #####: 2544:	  if (err == REG_NOMATCH)
branch  0 never executed
branch  1 never executed
    #####: 2545:	    continue;
        -: 2546:	}
        -: 2547:    }
    #####: 2548:  return REG_NOERROR;
        -: 2549:}
        -: 2550:
        -: 2551:static reg_errcode_t
function get_subexp_sub called 0 returned 0% blocks executed 0%
    #####: 2552:get_subexp_sub (preg, mctx, sub_top, sub_last, bkref_node, bkref_str,
        -: 2553:		subexp_idx)
        -: 2554:     const regex_t *preg;
        -: 2555:     re_match_context_t *mctx;
        -: 2556:     re_sub_match_top_t *sub_top;
        -: 2557:     re_sub_match_last_t *sub_last;
        -: 2558:     int bkref_node, bkref_str, subexp_idx;
        -: 2559:{
        -: 2560:  reg_errcode_t err;
        -: 2561:  int to_idx;
        -: 2562:  /* Can the subexpression arrive the back reference?  */
    #####: 2563:  err = check_arrival (preg, mctx, sub_top, sub_last, bkref_node, bkref_str);
call    0 never executed
    #####: 2564:  if (err != REG_NOERROR)
branch  0 never executed
branch  1 never executed
    #####: 2565:    return err;
    #####: 2566:  err = match_ctx_add_entry (mctx, bkref_node, bkref_str, sub_top->str_idx,
call    0 never executed
        -: 2567:			     sub_last->str_idx, sub_top, sub_last);
    #####: 2568:  if (BE (err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 2569:    return err;
    #####: 2570:  to_idx = bkref_str + sub_last->str_idx - sub_top->str_idx;
    #####: 2571:  clean_state_log_if_need (mctx, to_idx);
call    0 never executed
    #####: 2572:  return REG_NOERROR;
        -: 2573:}
        -: 2574:
        -: 2575:/* Find the first node which is '(' or ')', and whose index is SUBEXP_IDX.
        -: 2576:   Search '(' if FL_OPEN, or search ')' otherwise.  */
        -: 2577:
        -: 2578:static int
function find_subexp_node called 0 returned 0% blocks executed 0%
    #####: 2579:find_subexp_node (dfa, nodes, subexp_idx, fl_open)
        -: 2580:     re_dfa_t *dfa;
        -: 2581:     re_node_set *nodes;
        -: 2582:     int subexp_idx, fl_open;
        -: 2583:{
        -: 2584:  int cls_idx;
    #####: 2585:  for (cls_idx = 0; cls_idx < nodes->nelem; ++cls_idx)
branch  0 never executed
branch  1 never executed
        -: 2586:    {
    #####: 2587:      int cls_node = nodes->elems[cls_idx];
    #####: 2588:      re_token_t *node = dfa->nodes + cls_node;
    #####: 2589:      if (((fl_open && node->type == OP_OPEN_SUBEXP)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2590:	  || (!fl_open && node->type == OP_CLOSE_SUBEXP))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2591:	  && node->opr.idx == subexp_idx)
branch  0 never executed
branch  1 never executed
    #####: 2592:	return cls_node;
        -: 2593:    }
    #####: 2594:  return -1;
        -: 2595:}
        -: 2596:
        -: 2597:static reg_errcode_t
function check_arrival called 0 returned 0% blocks executed 0%
    #####: 2598:check_arrival (preg, mctx, sub_top, sub_last, bkref_node, bkref_str)
        -: 2599:     const regex_t *preg;
        -: 2600:     re_match_context_t *mctx;
        -: 2601:     re_sub_match_top_t *sub_top;
        -: 2602:     re_sub_match_last_t *sub_last;
        -: 2603:     int bkref_node, bkref_str;
        -: 2604:{
    #####: 2605:  re_dfa_t *dfa = (re_dfa_t *) preg->buffer;
        -: 2606:  reg_errcode_t err;
        -: 2607:  int backup_cur_idx, str_idx, null_cnt;
    #####: 2608:  re_dfastate_t *cur_state = NULL;
        -: 2609:  re_node_set *cur_nodes;
        -: 2610:  re_dfastate_t **backup_state_log;
        -: 2611:
        -: 2612:  state_array_t *path;
        -: 2613:  int top_node, top_str, ex_subexp, last_node, last_str, fl_open;
        -: 2614:
    #####: 2615:  path = bkref_node < 0 ? sub_top->path : &sub_last->path;
branch  0 never executed
branch  1 never executed
    #####: 2616:  top_node = bkref_node < 0 ? sub_top->node : sub_last->node;
branch  0 never executed
branch  1 never executed
    #####: 2617:  top_str = bkref_node < 0 ? sub_top->str_idx : sub_last->str_idx;
branch  0 never executed
branch  1 never executed
    #####: 2618:  last_node = bkref_node < 0 ? sub_last->node : bkref_node;
branch  0 never executed
branch  1 never executed
    #####: 2619:  last_str = bkref_node < 0 ? sub_last->str_idx : bkref_str;
branch  0 never executed
branch  1 never executed
        -: 2620:
    #####: 2621:  ex_subexp = dfa->nodes[sub_top->node].opr.idx;
    #####: 2622:  fl_open = (bkref_node >= 0);
        -: 2623:
        -: 2624:  /* Extend the buffer if we need.  */
    #####: 2625:  if (path->alloc < last_str + mctx->max_mb_elem_len + 1)
branch  0 never executed
branch  1 never executed
        -: 2626:    {
    #####: 2627:      int old_alloc = path->alloc;
    #####: 2628:      path->alloc = last_str + mctx->max_mb_elem_len + 1;
    #####: 2629:      path->array = re_realloc (path->array, re_dfastate_t *, path->alloc);
    #####: 2630:      if (path->array == NULL)
branch  0 never executed
branch  1 never executed
    #####: 2631:	return REG_ESPACE;
    #####: 2632:      memset (path->array + old_alloc, '\0',
    #####: 2633:	      sizeof (re_dfastate_t *) * (path->alloc - old_alloc));
        -: 2634:    }
        -: 2635:
    #####: 2636:  str_idx = path->next_idx == 0 ? top_str : path->next_idx;
branch  0 never executed
branch  1 never executed
        -: 2637:
        -: 2638:  /* Temporary modify MCTX.  */
    #####: 2639:  backup_state_log = mctx->state_log;
    #####: 2640:  backup_cur_idx = mctx->input->cur_idx;
    #####: 2641:  mctx->state_log = path->array;
    #####: 2642:  mctx->input->cur_idx = str_idx;
        -: 2643:
        -: 2644:  /* Setup initial node set.  */
    #####: 2645:  if (str_idx == top_str)
branch  0 never executed
branch  1 never executed
        -: 2646:    {
        -: 2647:      unsigned int context;
        -: 2648:      re_node_set init_nodes;
    #####: 2649:      context = re_string_context_at (mctx->input, str_idx - 1, mctx->eflags,
    #####: 2650:				      preg->newline_anchor);
call    0 never executed
    #####: 2651:      err = re_node_set_init_1 (&init_nodes, top_node);
call    0 never executed
    #####: 2652:      if (BE (err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 2653:	return err;
    #####: 2654:      err = expand_eclosures (dfa, &init_nodes, ex_subexp, fl_open);
call    0 never executed
    #####: 2655:      if (BE (err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 2656:	return err;
        -: 2657:
    #####: 2658:      if (init_nodes.nelem)
branch  0 never executed
branch  1 never executed
        -: 2659:	{
    #####: 2660:	  err = expand_bkref_cache (preg, mctx, sub_top, sub_last, &init_nodes,
call    0 never executed
        -: 2661:				    str_idx, last_str, ex_subexp, fl_open);
    #####: 2662:	  if (BE ( err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 2663:	    return err;
        -: 2664:	}
    #####: 2665:      cur_state = re_acquire_state_context (&err, dfa, &init_nodes, context);
call    0 never executed
    #####: 2666:      if (BE (cur_state == NULL && err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2667:	return err;
    #####: 2668:      mctx->state_log[str_idx] = cur_state;
    #####: 2669:      re_node_set_free (&init_nodes);
        -: 2670:    }
        -: 2671:  else
        -: 2672:    {
    #####: 2673:      cur_state = mctx->state_log[str_idx];
    #####: 2674:      if (cur_state && cur_state->has_backref)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2675:	{
        -: 2676:	  unsigned int context;
        -: 2677:	  re_node_set init_nodes;
    #####: 2678:	  context = re_string_context_at (mctx->input, str_idx - 1,
    #####: 2679:					  mctx->eflags, preg->newline_anchor);
call    0 never executed
    #####: 2680:	  err = re_node_set_init_copy (&init_nodes, &cur_state->nodes);
call    0 never executed
    #####: 2681:	  if (BE ( err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 2682:	    return err;
    #####: 2683:	  err = expand_bkref_cache (preg, mctx, sub_top, sub_last, &init_nodes,
call    0 never executed
        -: 2684:				    str_idx, last_str, ex_subexp, fl_open);
    #####: 2685:	  if (BE ( err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 2686:	    return err;
    #####: 2687:	  cur_state = re_acquire_state_context (&err, dfa, &init_nodes,
call    0 never executed
        -: 2688:						context);
    #####: 2689:	  if (BE (cur_state == NULL && err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2690:	    return err;
    #####: 2691:	  mctx->state_log[str_idx] = cur_state;
    #####: 2692:	  re_node_set_free (&init_nodes);
        -: 2693:	}
        -: 2694:    }
        -: 2695:
    #####: 2696:  for (null_cnt = 0; str_idx < last_str && null_cnt <= mctx->max_mb_elem_len;)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2697:    {
        -: 2698:      int cur_idx;
        -: 2699:      unsigned int context;
        -: 2700:      re_node_set next_nodes;
    #####: 2701:      if (mctx->state_log[str_idx + 1])
branch  0 never executed
branch  1 never executed
        -: 2702:	{
    #####: 2703:	  err = re_node_set_init_copy (&next_nodes,
    #####: 2704:				       &mctx->state_log[str_idx + 1]->nodes);
call    0 never executed
    #####: 2705:	  if (BE (cur_state == NULL && err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2706:	    return err;
        -: 2707:	}
        -: 2708:      else
    #####: 2709:	re_node_set_init_empty (&next_nodes);
        -: 2710:
    #####: 2711:      cur_nodes = cur_state? &cur_state->nodes : &empty_set;
branch  0 never executed
branch  1 never executed
    #####: 2712:      for (cur_idx = 0; cur_idx < cur_nodes->nelem; ++cur_idx)
branch  0 never executed
branch  1 never executed
        -: 2713:	{
    #####: 2714:	  int naccepted = 0;
    #####: 2715:	  int cur_node = cur_nodes->elems[cur_idx];
    #####: 2716:	  re_token_type_t type = dfa->nodes[cur_node].type;
    #####: 2717:	  if (IS_EPSILON_NODE(type))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
    #####: 2718:	    continue;
        -: 2719:#ifdef RE_ENABLE_I18N
        -: 2720:	  /* If the node may accept `multi byte'.  */
        -: 2721:	  if (ACCEPT_MB_NODE (type))
        -: 2722:	    {
        -: 2723:	      naccepted = check_node_accept_bytes (preg, cur_node, mctx->input,
        -: 2724:						   str_idx);
        -: 2725:	      if (naccepted > 1)
        -: 2726:		{
        -: 2727:		  re_node_set union_set;
        -: 2728:		  re_dfastate_t *dest_state;
        -: 2729:		  int next_node = dfa->nexts[cur_node];
        -: 2730:		  int next_idx = str_idx + naccepted;
        -: 2731:		  dest_state = mctx->state_log[next_idx];
        -: 2732:		  if (dest_state)
        -: 2733:		    {
        -: 2734:		      err = re_node_set_init_copy (&union_set,
        -: 2735:						   &dest_state->nodes);
        -: 2736:		      if (BE (err != REG_NOERROR, 0))
        -: 2737:			return err;
        -: 2738:		      err = re_node_set_insert (&union_set, next_node);
        -: 2739:		      if (BE (err < 0, 0))
        -: 2740:			return REG_ESPACE;
        -: 2741:		    }
        -: 2742:		  else
        -: 2743:		    {
        -: 2744:		      err = re_node_set_init_1 (&union_set, next_node);
        -: 2745:		      if (BE (err != REG_NOERROR, 0))
        -: 2746:			return err;
        -: 2747:		    }
        -: 2748:		  mctx->state_log[next_idx] = re_acquire_state (&err, dfa,
        -: 2749:								&union_set);
        -: 2750:		  re_node_set_free (&union_set);
        -: 2751:		  if (BE (mctx->state_log[next_idx] == NULL
        -: 2752:			  && err != REG_NOERROR, 0))
        -: 2753:		    return err;
        -: 2754:		}
        -: 2755:	    }
        -: 2756:#endif /* RE_ENABLE_I18N */
    #####: 2757:	  if (naccepted
branch  0 never executed
branch  1 never executed
    #####: 2758:	      || check_node_accept (preg, dfa->nodes + cur_node, mctx,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2759:				    str_idx))
        -: 2760:	    {
    #####: 2761:	      err = re_node_set_insert (&next_nodes, dfa->nexts[cur_node]);
call    0 never executed
        -: 2762:	      if (BE (err < 0, 0))
        -: 2763:		return REG_ESPACE;
        -: 2764:	    }
        -: 2765:	}
        -: 2766:
    #####: 2767:      ++str_idx;
    #####: 2768:      if (next_nodes.nelem)
branch  0 never executed
branch  1 never executed
        -: 2769:	{
    #####: 2770:	  err = expand_eclosures (dfa, &next_nodes, ex_subexp, fl_open);
call    0 never executed
    #####: 2771:	  if (BE (err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 2772:	    return err;
        -: 2773:	}
    #####: 2774:      if (next_nodes.nelem)
branch  0 never executed
branch  1 never executed
        -: 2775:	{
    #####: 2776:	  err = expand_bkref_cache (preg, mctx, sub_top, sub_last, &next_nodes,
call    0 never executed
        -: 2777:				    str_idx, last_str, ex_subexp, fl_open);
    #####: 2778:	  if (BE ( err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 2779:	    return err;
        -: 2780:	}
    #####: 2781:      context = re_string_context_at (mctx->input, str_idx - 1, mctx->eflags,
    #####: 2782:				      preg->newline_anchor);
call    0 never executed
    #####: 2783:      cur_state = re_acquire_state_context (&err, dfa, &next_nodes, context);
call    0 never executed
    #####: 2784:      if (BE (cur_state == NULL && err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2785:	return err;
    #####: 2786:      mctx->state_log[str_idx] = cur_state;
    #####: 2787:      re_node_set_free (&next_nodes);
    #####: 2788:      null_cnt = cur_state == NULL ? null_cnt + 1 : 0;
branch  0 never executed
branch  1 never executed
        -: 2789:    }
    #####: 2790:  cur_nodes = (mctx->state_log[last_str] == NULL ? NULL
    #####: 2791:	       : &mctx->state_log[last_str]->nodes);
branch  0 never executed
branch  1 never executed
    #####: 2792:  path->next_idx = str_idx;
        -: 2793:
        -: 2794:  /* Fix MCTX.  */
    #####: 2795:  mctx->state_log = backup_state_log;
    #####: 2796:  mctx->input->cur_idx = backup_cur_idx;
        -: 2797:
    #####: 2798:  if (cur_nodes == NULL)
branch  0 never executed
branch  1 never executed
    #####: 2799:    return REG_NOMATCH;
        -: 2800:  /* Then check the current node set has the node LAST_NODE.  */
    #####: 2801:  return (re_node_set_contains (cur_nodes, last_node)
call    0 never executed
    #####: 2802:	  || re_node_set_contains (cur_nodes, last_node) ? REG_NOERROR
call    0 never executed
    #####: 2803:	  : REG_NOMATCH);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2804:}
        -: 2805:
        -: 2806:/* Helper functions for check_arrival.  */
        -: 2807:
        -: 2808:static reg_errcode_t
function expand_eclosures called 0 returned 0% blocks executed 0%
    #####: 2809:expand_eclosures (dfa, cur_nodes, ex_subexp, fl_open)
        -: 2810:     re_dfa_t *dfa;
        -: 2811:     re_node_set *cur_nodes;
        -: 2812:     int ex_subexp, fl_open;
        -: 2813:{
        -: 2814:  reg_errcode_t err;
        -: 2815:  int idx, outside_node;
        -: 2816:  re_node_set new_nodes;
        -: 2817:#ifdef DEBUG
        -: 2818:  assert (cur_nodes->nelem);
        -: 2819:#endif
    #####: 2820:  re_node_set_alloc (&new_nodes, cur_nodes->nelem);
call    0 never executed
        -: 2821:  /* Create a new node set with the nodes which are epsilon closures of
        -: 2822:     a node in cur_nodes.  */
    #####: 2823:  for (idx = 0; idx < cur_nodes->nelem; ++idx)
branch  0 never executed
branch  1 never executed
        -: 2824:    {
    #####: 2825:      int cur_node = cur_nodes->elems[idx];
    #####: 2826:      err = re_node_set_merge (&new_nodes, dfa->eclosures + cur_node);
call    0 never executed
    #####: 2827:      if (BE (err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 2828:	return err;
        -: 2829:    }
    #####: 2830:  outside_node = find_subexp_node (dfa, &new_nodes, ex_subexp, fl_open);
call    0 never executed
    #####: 2831:  if (outside_node == -1)
branch  0 never executed
branch  1 never executed
        -: 2832:    {
    #####: 2833:      re_node_set_free (cur_nodes);
    #####: 2834:      *cur_nodes = new_nodes;
    #####: 2835:      return REG_NOERROR;
        -: 2836:    }
        -: 2837:  /* In this case, we have some nodes which are outside, remove them.  */
    #####: 2838:  re_node_set_empty (&new_nodes);
    #####: 2839:  for (idx = 0; idx < cur_nodes->nelem; ++idx)
branch  0 never executed
branch  1 never executed
        -: 2840:    {
    #####: 2841:      int cur_node = cur_nodes->elems[idx];
    #####: 2842:      re_node_set *eclosure = dfa->eclosures + cur_node;
    #####: 2843:      outside_node = find_subexp_node (dfa, eclosure, ex_subexp, fl_open);
call    0 never executed
    #####: 2844:      if (outside_node == -1)
branch  0 never executed
branch  1 never executed
        -: 2845:	{
    #####: 2846:	  err = re_node_set_merge (&new_nodes, eclosure);
call    0 never executed
    #####: 2847:	  if (BE (err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 2848:	    return err;
        -: 2849:	}
        -: 2850:      else
        -: 2851:	{
    #####: 2852:	  err = expand_eclosures_sub (dfa, &new_nodes, cur_node, ex_subexp,
call    0 never executed
        -: 2853:				      fl_open);
    #####: 2854:	  if (BE (err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 2855:	    return err;
        -: 2856:	}
        -: 2857:    }
    #####: 2858:  re_node_set_free (cur_nodes);
    #####: 2859:  *cur_nodes = new_nodes;
    #####: 2860:  return REG_NOERROR;
        -: 2861:}
        -: 2862:
        -: 2863:static reg_errcode_t
function expand_eclosures_sub called 0 returned 0% blocks executed 0%
    #####: 2864:expand_eclosures_sub (dfa, dst_nodes, target, ex_subexp, fl_open)
        -: 2865:     re_dfa_t *dfa;
        -: 2866:     int target, ex_subexp, fl_open;
        -: 2867:     re_node_set *dst_nodes;
        -: 2868:{
        -: 2869:  int cur_node, type;
    #####: 2870:  for (cur_node = target; !re_node_set_contains (dst_nodes, cur_node);)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2871:    {
        -: 2872:      int err;
    #####: 2873:      type = dfa->nodes[cur_node].type;
        -: 2874:
    #####: 2875:      if (((type == OP_OPEN_SUBEXP && fl_open)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2876:	   || (type == OP_CLOSE_SUBEXP && !fl_open))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2877:	  && dfa->nodes[cur_node].opr.idx == ex_subexp)
branch  0 never executed
branch  1 never executed
        -: 2878:	{
    #####: 2879:	  if (!fl_open)
branch  0 never executed
branch  1 never executed
        -: 2880:	    {
    #####: 2881:	      err = re_node_set_insert (dst_nodes, cur_node);
call    0 never executed
    #####: 2882:	      if (BE (err == -1, 0))
branch  0 never executed
branch  1 never executed
    #####: 2883:		return REG_ESPACE;
        -: 2884:	    }
    #####: 2885:	  break;
        -: 2886:	}
    #####: 2887:      err = re_node_set_insert (dst_nodes, cur_node);
call    0 never executed
    #####: 2888:      if (BE (err == -1, 0))
branch  0 never executed
branch  1 never executed
    #####: 2889:	return REG_ESPACE;
    #####: 2890:      if (dfa->edests[cur_node].nelem == 0)
branch  0 never executed
branch  1 never executed
    #####: 2891:	break;
    #####: 2892:      if (dfa->edests[cur_node].nelem == 2)
branch  0 never executed
branch  1 never executed
        -: 2893:	{
    #####: 2894:	  err = expand_eclosures_sub (dfa, dst_nodes,
    #####: 2895:				      dfa->edests[cur_node].elems[1],
call    0 never executed
        -: 2896:				      ex_subexp, fl_open);
    #####: 2897:	  if (BE (err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 2898:	    return err;
        -: 2899:	}
    #####: 2900:      cur_node = dfa->edests[cur_node].elems[0];
        -: 2901:    }
    #####: 2902:  return REG_NOERROR;
        -: 2903:}
        -: 2904:
        -: 2905:
        -: 2906:/* For all the back references in the current state, calculate the
        -: 2907:   destination of the back references by the appropriate entry
        -: 2908:   in MCTX->BKREF_ENTS.  */
        -: 2909:
        -: 2910:static reg_errcode_t
function expand_bkref_cache called 0 returned 0% blocks executed 0%
    #####: 2911:expand_bkref_cache (preg, mctx, sub_top, sub_last, cur_nodes, cur_str,
        -: 2912:		    last_str, ex_subexp, fl_open)
        -: 2913:     const regex_t *preg;
        -: 2914:     re_match_context_t *mctx;
        -: 2915:     re_sub_match_top_t *sub_top;
        -: 2916:     re_sub_match_last_t *sub_last;
        -: 2917:     int cur_str, last_str, ex_subexp, fl_open;
        -: 2918:     re_node_set *cur_nodes;
        -: 2919:{
        -: 2920:  reg_errcode_t err;
    #####: 2921:  re_dfa_t *dfa = (re_dfa_t *) preg->buffer;
        -: 2922:  re_node_set processed_nodes;
        -: 2923:  int node_idx, cache_idx, cur_subexp_idx;
        -: 2924:  /* The current state.  */
    #####: 2925:  cur_subexp_idx = dfa->nodes[sub_top->node].opr.idx;
    #####: 2926:  re_node_set_init_empty (&processed_nodes);
    #####: 2927:  for (node_idx = 0; node_idx < cur_nodes->nelem; ++node_idx)
branch  0 never executed
branch  1 never executed
        -: 2928:    {
    #####: 2929:      int bkref_node = cur_nodes->elems[node_idx];
    #####: 2930:      if (dfa->nodes[bkref_node].type != OP_BACK_REF
branch  0 never executed
branch  1 never executed
    #####: 2931:	  || re_node_set_contains (&processed_nodes, bkref_node))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2932:	continue;
        -: 2933:
    #####: 2934:      for (cache_idx = 0; cache_idx < mctx->nbkref_ents; ++cache_idx)
branch  0 never executed
branch  1 never executed
        -: 2935:	{
        -: 2936:	  int to_idx, next_node;
    #####: 2937:	  struct re_backref_cache_entry *ent = mctx->bkref_ents + cache_idx;
        -: 2938:	  /* Is this entry ENT is appropriate?  */
    #####: 2939:	  if (ent->str_idx != cur_str
branch  0 never executed
branch  1 never executed
    #####: 2940:	      || !re_node_set_contains (cur_nodes, ent->node))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2941:	    continue; /* No.  */
        -: 2942:
    #####: 2943:	  to_idx = cur_str + ent->subexp_to - ent->subexp_from;
        -: 2944:	  /* Calculate the destination of the back reference, and append it
        -: 2945:	     to MCTX->STATE_LOG.  */
    #####: 2946:	  if (to_idx == cur_str)
branch  0 never executed
branch  1 never executed
        -: 2947:	    {
        -: 2948:	      re_node_set new_dests;
    #####: 2949:	      next_node = dfa->edests[ent->node].elems[0];
    #####: 2950:	      if (re_node_set_contains (cur_nodes, next_node))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2951:		continue;
    #####: 2952:	      err = re_node_set_init_1 (&new_dests, next_node);
call    0 never executed
    #####: 2953:	      if (BE (err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 2954:		return err;
    #####: 2955:	      err = expand_eclosures (dfa, &new_dests, ex_subexp, fl_open);
call    0 never executed
    #####: 2956:	      if (BE (err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 2957:		return err;
    #####: 2958:	      err = re_node_set_merge (cur_nodes, &new_dests);
call    0 never executed
    #####: 2959:	      if (BE (err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 2960:		return err;
    #####: 2961:	      re_node_set_free (&new_dests);
        -: 2962:	      /* TODO: It is still inefficient...  */
    #####: 2963:	      node_idx = -1;
    #####: 2964:	      break;
        -: 2965:	    }
        -: 2966:	  else
        -: 2967:	    {
        -: 2968:	      re_node_set union_set;
    #####: 2969:	      next_node = dfa->nexts[ent->node];
    #####: 2970:	      if (mctx->state_log[to_idx])
branch  0 never executed
branch  1 never executed
        -: 2971:		{
        -: 2972:		  int ret;
    #####: 2973:		  if (re_node_set_contains (&mctx->state_log[to_idx]->nodes,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2974:					    next_node))
    #####: 2975:		    continue;
    #####: 2976:		  err = re_node_set_init_copy (&union_set,
    #####: 2977:					      &mctx->state_log[to_idx]->nodes);
call    0 never executed
    #####: 2978:		  if (BE (err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 2979:		    return err;
    #####: 2980:		  ret = re_node_set_insert (&union_set, next_node);
call    0 never executed
        -: 2981:		  if (BE (err < 0, 0))
        -: 2982:		    return REG_ESPACE;
        -: 2983:		}
        -: 2984:	      else
        -: 2985:		{
    #####: 2986:		  err = re_node_set_init_1 (&union_set, next_node);
call    0 never executed
    #####: 2987:		  if (BE (err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 2988:		    return err;
        -: 2989:		}
    #####: 2990:	      mctx->state_log[to_idx] = re_acquire_state (&err, dfa,
call    0 never executed
        -: 2991:							  &union_set);
    #####: 2992:	      re_node_set_free (&union_set);
    #####: 2993:	      if (BE (mctx->state_log[to_idx] == NULL
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2994:		      && err != REG_NOERROR, 0))
    #####: 2995:		return err;
        -: 2996:	    }
        -: 2997:	}
        -: 2998:    }
    #####: 2999:  re_node_set_free (&processed_nodes);
    #####: 3000:  return REG_NOERROR;
        -: 3001:}
        -: 3002:
        -: 3003:/* Build transition table for the state.
        -: 3004:   Return the new table if succeeded, otherwise return NULL.  */
        -: 3005:
        -: 3006:static re_dfastate_t **
function build_trtable called 2814 returned 100% blocks executed 73%
     2814: 3007:build_trtable (preg, state, fl_search)
        -: 3008:    const regex_t *preg;
        -: 3009:    const re_dfastate_t *state;
        -: 3010:    int fl_search;
        -: 3011:{
        -: 3012:  reg_errcode_t err;
     2814: 3013:  re_dfa_t *dfa = (re_dfa_t *) preg->buffer;
        -: 3014:  int i, j, k, ch;
     2814: 3015:  int dests_node_malloced = 0, dest_states_malloced = 0;
        -: 3016:  int ndests; /* Number of the destination states from `state'.  */
        -: 3017:  re_dfastate_t **trtable;
     2814: 3018:  re_dfastate_t **dest_states = NULL, **dest_states_word, **dest_states_nl;
        -: 3019:  re_node_set follows, *dests_node;
        -: 3020:  bitset *dests_ch;
        -: 3021:  bitset acceptable;
        -: 3022:
        -: 3023:  /* We build DFA states which corresponds to the destination nodes
        -: 3024:     from `state'.  `dests_node[i]' represents the nodes which i-th
        -: 3025:     destination state contains, and `dests_ch[i]' represents the
        -: 3026:     characters which i-th destination state accepts.  */
        -: 3027:#ifdef _LIBC
        -: 3028:  if (__libc_use_alloca ((sizeof (re_node_set) + sizeof (bitset)) * SBC_MAX))
        -: 3029:    dests_node = (re_node_set *)
        -: 3030:		 alloca ((sizeof (re_node_set) + sizeof (bitset)) * SBC_MAX);
        -: 3031:  else
        -: 3032:#endif
        -: 3033:    {
        -: 3034:      dests_node = (re_node_set *)
     2814: 3035:		   malloc ((sizeof (re_node_set) + sizeof (bitset)) * SBC_MAX);
     2814: 3036:      if (BE (dests_node == NULL, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 2814
    #####: 3037:	return NULL;
     2814: 3038:      dests_node_malloced = 1;
        -: 3039:    }
     2814: 3040:  dests_ch = (bitset *) (dests_node + SBC_MAX);
        -: 3041:
        -: 3042:  /* Initialize transiton table.  */
     2814: 3043:  trtable = (re_dfastate_t **) calloc (sizeof (re_dfastate_t *), SBC_MAX);
     2814: 3044:  if (BE (trtable == NULL, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 2814
        -: 3045:    {
    #####: 3046:      if (dests_node_malloced)
branch  0 never executed
branch  1 never executed
    #####: 3047:	free (dests_node);
    #####: 3048:      return NULL;
        -: 3049:    }
        -: 3050:
        -: 3051:  /* At first, group all nodes belonging to `state' into several
        -: 3052:     destinations.  */
     2814: 3053:  ndests = group_nodes_into_DFAstates (preg, state, dests_node, dests_ch);
call    0 returned 2814
     2814: 3054:  if (BE (ndests <= 0, 0))
branch  0 taken 693 (fallthrough)
branch  1 taken 2121
        -: 3055:    {
      693: 3056:      if (dests_node_malloced)
branch  0 taken 693 (fallthrough)
branch  1 taken 0
      693: 3057:	free (dests_node);
        -: 3058:      /* Return NULL in case of an error, trtable otherwise.  */
      693: 3059:      if (ndests == 0)
branch  0 taken 693 (fallthrough)
branch  1 taken 0
      693: 3060:	return trtable;
    #####: 3061:      free (trtable);
    #####: 3062:      return NULL;
        -: 3063:    }
        -: 3064:
     2121: 3065:  err = re_node_set_alloc (&follows, ndests + 1);
call    0 returned 2121
     2121: 3066:  if (BE (err != REG_NOERROR, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 2121
    #####: 3067:    goto out_free;
        -: 3068:
        -: 3069:#ifdef _LIBC
        -: 3070:  if (__libc_use_alloca ((sizeof (re_node_set) + sizeof (bitset)) * SBC_MAX
        -: 3071:			 + ndests * 3 * sizeof (re_dfastate_t *)))
        -: 3072:    dest_states = (re_dfastate_t **)
        -: 3073:		  alloca (ndests * 3 * sizeof (re_dfastate_t *));
        -: 3074:  else
        -: 3075:#endif
        -: 3076:    {
        -: 3077:      dest_states = (re_dfastate_t **)
     2121: 3078:		    malloc (ndests * 3 * sizeof (re_dfastate_t *));
     2121: 3079:      if (BE (dest_states == NULL, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 2121
        -: 3080:	{
    #####: 3081:out_free:
    #####: 3082:	  if (dest_states_malloced)
branch  0 never executed
branch  1 never executed
    #####: 3083:	    free (dest_states);
    #####: 3084:	  re_node_set_free (&follows);
    #####: 3085:	  for (i = 0; i < ndests; ++i)
branch  0 never executed
branch  1 never executed
    #####: 3086:	    re_node_set_free (dests_node + i);
    #####: 3087:	  free (trtable);
    #####: 3088:	  if (dests_node_malloced)
branch  0 never executed
branch  1 never executed
    #####: 3089:	    free (dests_node);
    #####: 3090:	  return NULL;
        -: 3091:	}
     2121: 3092:      dest_states_malloced = 1;
        -: 3093:    }
     2121: 3094:  dest_states_word = dest_states + ndests;
     2121: 3095:  dest_states_nl = dest_states_word + ndests;
     2121: 3096:  bitset_empty (acceptable);
        -: 3097:
        -: 3098:  /* Then build the states for all destinations.  */
     4374: 3099:  for (i = 0; i < ndests; ++i)
branch  0 taken 2253
branch  1 taken 2121 (fallthrough)
        -: 3100:    {
        -: 3101:      int next_node;
     2253: 3102:      re_node_set_empty (&follows);
        -: 3103:      /* Merge the follows of this destination states.  */
     4751: 3104:      for (j = 0; j < dests_node[i].nelem; ++j)
branch  0 taken 2498
branch  1 taken 2253 (fallthrough)
        -: 3105:	{
     2498: 3106:	  next_node = dfa->nexts[dests_node[i].elems[j]];
     2498: 3107:	  if (next_node != -1)
branch  0 taken 2498 (fallthrough)
branch  1 taken 0
        -: 3108:	    {
     2498: 3109:	      err = re_node_set_merge (&follows, dfa->eclosures + next_node);
call    0 returned 2498
     2498: 3110:	      if (BE (err != REG_NOERROR, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 2498
    #####: 3111:		goto out_free;
        -: 3112:	    }
        -: 3113:	}
        -: 3114:      /* If search flag is set, merge the initial state.  */
     2253: 3115:      if (fl_search)
branch  0 taken 0 (fallthrough)
branch  1 taken 2253
        -: 3116:	{
        -: 3117:#ifdef RE_ENABLE_I18N
        -: 3118:	  int not_initial = 0;
        -: 3119:	  for (j = 0; j < follows.nelem; ++j)
        -: 3120:	    if (dfa->nodes[follows.elems[j]].type == CHARACTER)
        -: 3121:	      {
        -: 3122:		not_initial = dfa->nodes[follows.elems[j]].mb_partial;
        -: 3123:		break;
        -: 3124:	      }
        -: 3125:	  if (!not_initial)
        -: 3126:#endif
        -: 3127:	    {
    #####: 3128:	      err = re_node_set_merge (&follows,
    #####: 3129:				       dfa->init_state->entrance_nodes);
call    0 never executed
    #####: 3130:	      if (BE (err != REG_NOERROR, 0))
branch  0 never executed
branch  1 never executed
    #####: 3131:		goto out_free;
        -: 3132:	    }
        -: 3133:	}
     2253: 3134:      dest_states[i] = re_acquire_state_context (&err, dfa, &follows, 0);
call    0 returned 2253
    2253*: 3135:      if (BE (dest_states[i] == NULL && err != REG_NOERROR, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 2253
branch  2 never executed
branch  3 never executed
    #####: 3136:	goto out_free;
        -: 3137:      /* If the new state has context constraint,
        -: 3138:	 build appropriate states for these contexts.  */
     2253: 3139:      if (dest_states[i]->has_constraint)
branch  0 taken 53 (fallthrough)
branch  1 taken 2200
        -: 3140:	{
       53: 3141:	  dest_states_word[i] = re_acquire_state_context (&err, dfa, &follows,
call    0 returned 53
        -: 3142:							  CONTEXT_WORD);
      53*: 3143:	  if (BE (dest_states_word[i] == NULL && err != REG_NOERROR, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 53
branch  2 never executed
branch  3 never executed
    #####: 3144:	    goto out_free;
       53: 3145:	  dest_states_nl[i] = re_acquire_state_context (&err, dfa, &follows,
call    0 returned 53
        -: 3146:							CONTEXT_NEWLINE);
      53*: 3147:	  if (BE (dest_states_nl[i] == NULL && err != REG_NOERROR, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 53
branch  2 never executed
branch  3 never executed
    #####: 3148:	    goto out_free;
        -: 3149:	}
        -: 3150:      else
        -: 3151:	{
     2200: 3152:	  dest_states_word[i] = dest_states[i];
     2200: 3153:	  dest_states_nl[i] = dest_states[i];
        -: 3154:	}
     2253: 3155:      bitset_merge (acceptable, dests_ch[i]);
call    0 returned 2253
        -: 3156:    }
        -: 3157:
        -: 3158:  /* Update the transition table.  */
        -: 3159:  /* For all characters ch...:  */
    19089: 3160:  for (i = 0, ch = 0; i < BITSET_UINTS; ++i)
branch  0 taken 16968
branch  1 taken 2121 (fallthrough)
   559944: 3161:    for (j = 0; j < UINT_BITS; ++j, ++ch)
branch  0 taken 542976
branch  1 taken 16968 (fallthrough)
   542976: 3162:      if ((acceptable[i] >> j) & 1)
branch  0 taken 40982 (fallthrough)
branch  1 taken 501994
        -: 3163:	{
        -: 3164:	  /* The current state accepts the character ch.  */
    40982: 3165:	  if (IS_WORD_CHAR (ch))
branch  0 taken 30127 (fallthrough)
branch  1 taken 10855
branch  2 taken 153 (fallthrough)
branch  3 taken 29974
        -: 3166:	    {
    19134: 3167:	      for (k = 0; k < ndests; ++k)
branch  0 taken 19134
branch  1 taken 0 (fallthrough)
    19134: 3168:		if ((dests_ch[k][i] >> j) & 1)
branch  0 taken 11008 (fallthrough)
branch  1 taken 8126
        -: 3169:		  {
        -: 3170:		    /* k-th destination accepts the word character ch.  */
    11008: 3171:		    trtable[ch] = dest_states_word[k];
        -: 3172:		    /* There must be only one destination which accepts
        -: 3173:		       character ch.  See group_nodes_into_DFAstates.  */
    11008: 3174:		    break;
        -: 3175:		  }
        -: 3176:	    }
        -: 3177:	  else /* not WORD_CHAR */
        -: 3178:	    {
    54858: 3179:	      for (k = 0; k < ndests; ++k)
branch  0 taken 54858
branch  1 taken 0 (fallthrough)
    54858: 3180:		if ((dests_ch[k][i] >> j) & 1)
branch  0 taken 29974 (fallthrough)
branch  1 taken 24884
        -: 3181:		  {
        -: 3182:		    /* k-th destination accepts the non-word character ch.  */
    29974: 3183:		    trtable[ch] = dest_states[k];
        -: 3184:		    /* There must be only one destination which accepts
        -: 3185:		       character ch.  See group_nodes_into_DFAstates.  */
    29974: 3186:		    break;
        -: 3187:		  }
        -: 3188:	    }
        -: 3189:	}
        -: 3190:  /* new line */
     2121: 3191:  if (bitset_contain (acceptable, NEWLINE_CHAR))
branch  0 taken 165 (fallthrough)
branch  1 taken 1956
        -: 3192:    {
        -: 3193:      /* The current state accepts newline character.  */
      295: 3194:      for (k = 0; k < ndests; ++k)
branch  0 taken 295
branch  1 taken 0 (fallthrough)
      295: 3195:	if (bitset_contain (dests_ch[k], NEWLINE_CHAR))
branch  0 taken 165 (fallthrough)
branch  1 taken 130
        -: 3196:	  {
        -: 3197:	    /* k-th destination accepts newline character.  */
      165: 3198:	    trtable[NEWLINE_CHAR] = dest_states_nl[k];
        -: 3199:	    /* There must be only one destination which accepts
        -: 3200:	       newline.  See group_nodes_into_DFAstates.  */
      165: 3201:	    break;
        -: 3202:	  }
        -: 3203:    }
        -: 3204:
     2121: 3205:  if (dest_states_malloced)
branch  0 taken 2121 (fallthrough)
branch  1 taken 0
     2121: 3206:    free (dest_states);
        -: 3207:
     2121: 3208:  re_node_set_free (&follows);
     4374: 3209:  for (i = 0; i < ndests; ++i)
branch  0 taken 2253
branch  1 taken 2121 (fallthrough)
     2253: 3210:    re_node_set_free (dests_node + i);
        -: 3211:
     2121: 3212:  if (dests_node_malloced)
branch  0 taken 2121 (fallthrough)
branch  1 taken 0
     2121: 3213:    free (dests_node);
        -: 3214:
     2121: 3215:  return trtable;
        -: 3216:}
        -: 3217:
        -: 3218:/* Group all nodes belonging to STATE into several destinations.
        -: 3219:   Then for all destinations, set the nodes belonging to the destination
        -: 3220:   to DESTS_NODE[i] and set the characters accepted by the destination
        -: 3221:   to DEST_CH[i].  This function return the number of destinations.  */
        -: 3222:
        -: 3223:static int
function group_nodes_into_DFAstates called 2814 returned 100% blocks executed 75%
     2814: 3224:group_nodes_into_DFAstates (preg, state, dests_node, dests_ch)
        -: 3225:    const regex_t *preg;
        -: 3226:    const re_dfastate_t *state;
        -: 3227:    re_node_set *dests_node;
        -: 3228:    bitset *dests_ch;
        -: 3229:{
        -: 3230:  reg_errcode_t err;
     2814: 3231:  const re_dfa_t *dfa = (re_dfa_t *) preg->buffer;
        -: 3232:  int i, j, k;
        -: 3233:  int ndests; /* Number of the destinations from `state'.  */
        -: 3234:  bitset accepts; /* Characters a node can accept.  */
     2814: 3235:  const re_node_set *cur_nodes = &state->nodes;
     2814: 3236:  bitset_empty (accepts);
     2814: 3237:  ndests = 0;
        -: 3238:
        -: 3239:  /* For all the nodes belonging to `state',  */
     6190: 3240:  for (i = 0; i < cur_nodes->nelem; ++i)
branch  0 taken 3376
branch  1 taken 2814 (fallthrough)
        -: 3241:    {
     3376: 3242:      re_token_t *node = &dfa->nodes[cur_nodes->elems[i]];
     3376: 3243:      re_token_type_t type = node->type;
     3376: 3244:      unsigned int constraint = node->constraint;
        -: 3245:
        -: 3246:      /* Enumerate all single byte character this node can accept.  */
     3376: 3247:      if (type == CHARACTER)
branch  0 taken 2114 (fallthrough)
branch  1 taken 1262
     2114: 3248:	bitset_set (accepts, node->opr.c);
     1262: 3249:      else if (type == SIMPLE_BRACKET)
branch  0 taken 9 (fallthrough)
branch  1 taken 1253
        -: 3250:	{
        9: 3251:	  bitset_merge (accepts, node->opr.sbcset);
call    0 returned 9
        -: 3252:	}
     1253: 3253:      else if (type == OP_PERIOD)
branch  0 taken 195 (fallthrough)
branch  1 taken 1058
        -: 3254:	{
      195: 3255:	  bitset_set_all (accepts);
      195: 3256:	  if (!(preg->syntax & RE_DOT_NEWLINE))
branch  0 taken 0 (fallthrough)
branch  1 taken 195
    #####: 3257:	    bitset_clear (accepts, '\n');
      195: 3258:	  if (preg->syntax & RE_DOT_NOT_NULL)
branch  0 taken 195 (fallthrough)
branch  1 taken 0
      195: 3259:	    bitset_clear (accepts, '\0');
        -: 3260:	}
        -: 3261:      else
     1058: 3262:	continue;
        -: 3263:
        -: 3264:      /* Check the `accepts' and sift the characters which are not
        -: 3265:	 match it the context.  */
     2318: 3266:      if (constraint)
branch  0 taken 93 (fallthrough)
branch  1 taken 2225
        -: 3267:	{
       93: 3268:	  if (constraint & NEXT_WORD_CONSTRAINT)
branch  0 taken 0 (fallthrough)
branch  1 taken 93
    #####: 3269:	    for (j = 0; j < BITSET_UINTS; ++j)
branch  0 never executed
branch  1 never executed
    #####: 3270:	      accepts[j] &= dfa->word_char[j];
       93: 3271:	  if (constraint & NEXT_NOTWORD_CONSTRAINT)
branch  0 taken 0 (fallthrough)
branch  1 taken 93
    #####: 3272:	    for (j = 0; j < BITSET_UINTS; ++j)
branch  0 never executed
branch  1 never executed
    #####: 3273:	      accepts[j] &= ~dfa->word_char[j];
       93: 3274:	  if (constraint & NEXT_NEWLINE_CONSTRAINT)
branch  0 taken 0 (fallthrough)
branch  1 taken 93
        -: 3275:	    {
    #####: 3276:	      int accepts_newline = bitset_contain (accepts, NEWLINE_CHAR);
    #####: 3277:	      bitset_empty (accepts);
    #####: 3278:	      if (accepts_newline)
branch  0 never executed
branch  1 never executed
    #####: 3279:		bitset_set (accepts, NEWLINE_CHAR);
        -: 3280:	      else
    #####: 3281:		continue;
        -: 3282:	    }
        -: 3283:	}
        -: 3284:
        -: 3285:      /* Then divide `accepts' into DFA states, or create a new
        -: 3286:	 state.  */
     2383: 3287:      for (j = 0; j < ndests; ++j)
branch  0 taken 260
branch  1 taken 2123 (fallthrough)
        -: 3288:	{
        -: 3289:	  bitset intersec; /* Intersection sets, see below.  */
        -: 3290:	  bitset remains;
        -: 3291:	  /* Flags, see below.  */
        -: 3292:	  int has_intersec, not_subset, not_consumed;
        -: 3293:
        -: 3294:	  /* Optimization, skip if this state doesn't accept the character.  */
      260: 3295:	  if (type == CHARACTER && !bitset_contain (dests_ch[j], node->opr.c))
branch  0 taken 163 (fallthrough)
branch  1 taken 97
branch  2 taken 12 (fallthrough)
branch  3 taken 151
       15: 3296:	    continue;
        -: 3297:
        -: 3298:	  /* Enumerate the intersection set of this state and `accepts'.  */
      248: 3299:	  has_intersec = 0;
     2232: 3300:	  for (k = 0; k < BITSET_UINTS; ++k)
branch  0 taken 1984
branch  1 taken 248 (fallthrough)
     1984: 3301:	    has_intersec |= intersec[k] = accepts[k] & dests_ch[j][k];
        -: 3302:	  /* And skip if the intersection set is empty.  */
      248: 3303:	  if (!has_intersec)
branch  0 taken 3 (fallthrough)
branch  1 taken 245
        3: 3304:	    continue;
        -: 3305:
        -: 3306:	  /* Then check if this state is a subset of `accepts'.  */
      245: 3307:	  not_subset = not_consumed = 0;
     2205: 3308:	  for (k = 0; k < BITSET_UINTS; ++k)
branch  0 taken 1960
branch  1 taken 245 (fallthrough)
        -: 3309:	    {
     1960: 3310:	      not_subset |= remains[k] = ~accepts[k] & dests_ch[j][k];
     1960: 3311:	      not_consumed |= accepts[k] = accepts[k] & ~dests_ch[j][k];
        -: 3312:	    }
        -: 3313:
        -: 3314:	  /* If this state isn't a subset of `accepts', create a
        -: 3315:	     new group state, which has the `remains'. */
      245: 3316:	  if (not_subset)
branch  0 taken 130 (fallthrough)
branch  1 taken 115
        -: 3317:	    {
      130: 3318:	      bitset_copy (dests_ch[ndests], remains);
      130: 3319:	      bitset_copy (dests_ch[j], intersec);
      130: 3320:	      err = re_node_set_init_copy (dests_node + ndests, &dests_node[j]);
call    0 returned 130
      130: 3321:	      if (BE (err != REG_NOERROR, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 130
    #####: 3322:		goto error_return;
      130: 3323:	      ++ndests;
        -: 3324:	    }
        -: 3325:
        -: 3326:	  /* Put the position in the current group. */
      245: 3327:	  err = re_node_set_insert (&dests_node[j], cur_nodes->elems[i]);
call    0 returned 245
        -: 3328:	  if (BE (err < 0, 0))
        -: 3329:	    goto error_return;
        -: 3330:
        -: 3331:	  /* If all characters are consumed, go to next node. */
      245: 3332:	  if (!not_consumed)
branch  0 taken 195 (fallthrough)
branch  1 taken 50
      195: 3333:	    break;
        -: 3334:	}
        -: 3335:      /* Some characters remain, create a new group. */
     2318: 3336:      if (j == ndests)
branch  0 taken 2123 (fallthrough)
branch  1 taken 195
        -: 3337:	{
     2123: 3338:	  bitset_copy (dests_ch[ndests], accepts);
     2123: 3339:	  err = re_node_set_init_1 (dests_node + ndests, cur_nodes->elems[i]);
call    0 returned 2123
     2123: 3340:	  if (BE (err != REG_NOERROR, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 2123
    #####: 3341:	    goto error_return;
     2123: 3342:	  ++ndests;
     2123: 3343:	  bitset_empty (accepts);
        -: 3344:	}
        -: 3345:    }
     2814: 3346:  return ndests;
    #####: 3347: error_return:
    #####: 3348:  for (j = 0; j < ndests; ++j)
branch  0 never executed
branch  1 never executed
    #####: 3349:    re_node_set_free (dests_node + j);
    #####: 3350:  return -1;
        -: 3351:}
        -: 3352:
        -: 3353:#ifdef RE_ENABLE_I18N
        -: 3354:/* Check how many bytes the node `dfa->nodes[node_idx]' accepts.
        -: 3355:   Return the number of the bytes the node accepts.
        -: 3356:   STR_IDX is the current index of the input string.
        -: 3357:
        -: 3358:   This function handles the nodes which can accept one character, or
        -: 3359:   one collating element like '.', '[a-z]', opposite to the other nodes
        -: 3360:   can only accept one byte.  */
        -: 3361:
        -: 3362:static int
        -: 3363:check_node_accept_bytes (preg, node_idx, input, str_idx)
        -: 3364:    const regex_t *preg;
        -: 3365:    int node_idx, str_idx;
        -: 3366:    const re_string_t *input;
        -: 3367:{
        -: 3368:  const re_dfa_t *dfa = (re_dfa_t *) preg->buffer;
        -: 3369:  const re_token_t *node = dfa->nodes + node_idx;
        -: 3370:  int elem_len = re_string_elem_size_at (input, str_idx);
        -: 3371:  int char_len = re_string_char_size_at (input, str_idx);
        -: 3372:  int i;
        -: 3373:# ifdef _LIBC
        -: 3374:  int j;
        -: 3375:  uint32_t nrules = _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES);
        -: 3376:# endif /* _LIBC */
        -: 3377:  if (elem_len <= 1 && char_len <= 1)
        -: 3378:    return 0;
        -: 3379:  if (node->type == OP_PERIOD)
        -: 3380:    {
        -: 3381:      /* '.' accepts any one character except the following two cases.  */
        -: 3382:      if ((!(preg->syntax & RE_DOT_NEWLINE) &&
        -: 3383:	   re_string_byte_at (input, str_idx) == '\n') ||
        -: 3384:	  ((preg->syntax & RE_DOT_NOT_NULL) &&
        -: 3385:	   re_string_byte_at (input, str_idx) == '\0'))
        -: 3386:	return 0;
        -: 3387:      return char_len;
        -: 3388:    }
        -: 3389:  else if (node->type == COMPLEX_BRACKET)
        -: 3390:    {
        -: 3391:      const re_charset_t *cset = node->opr.mbcset;
        -: 3392:# ifdef _LIBC
        -: 3393:      const unsigned char *pin = re_string_get_buffer (input) + str_idx;
        -: 3394:# endif /* _LIBC */
        -: 3395:      int match_len = 0;
        -: 3396:      wchar_t wc = ((cset->nranges || cset->nchar_classes || cset->nmbchars)
        -: 3397:		    ? re_string_wchar_at (input, str_idx) : 0);
        -: 3398:
        -: 3399:      /* match with multibyte character?  */
        -: 3400:      for (i = 0; i < cset->nmbchars; ++i)
        -: 3401:	if (wc == cset->mbchars[i])
        -: 3402:	  {
        -: 3403:	    match_len = char_len;
        -: 3404:	    goto check_node_accept_bytes_match;
        -: 3405:	  }
        -: 3406:      /* match with character_class?  */
        -: 3407:      for (i = 0; i < cset->nchar_classes; ++i)
        -: 3408:	{
        -: 3409:	  wctype_t wt = cset->char_classes[i];
        -: 3410:	  if (__iswctype (wc, wt))
        -: 3411:	    {
        -: 3412:	      match_len = char_len;
        -: 3413:	      goto check_node_accept_bytes_match;
        -: 3414:	    }
        -: 3415:	}
        -: 3416:
        -: 3417:# ifdef _LIBC
        -: 3418:      if (nrules != 0)
        -: 3419:	{
        -: 3420:	  unsigned int in_collseq = 0;
        -: 3421:	  const int32_t *table, *indirect;
        -: 3422:	  const unsigned char *weights, *extra;
        -: 3423:	  const char *collseqwc;
        -: 3424:	  int32_t idx;
        -: 3425:	  /* This #include defines a local function!  */
        -: 3426:#  include <locale/weight.h>
        -: 3427:
        -: 3428:	  /* match with collating_symbol?  */
        -: 3429:	  if (cset->ncoll_syms)
        -: 3430:	    extra = (const unsigned char *)
        -: 3431:	      _NL_CURRENT (LC_COLLATE, _NL_COLLATE_SYMB_EXTRAMB);
        -: 3432:	  for (i = 0; i < cset->ncoll_syms; ++i)
        -: 3433:	    {
        -: 3434:	      const unsigned char *coll_sym = extra + cset->coll_syms[i];
        -: 3435:	      /* Compare the length of input collating element and
        -: 3436:		 the length of current collating element.  */
        -: 3437:	      if (*coll_sym != elem_len)
        -: 3438:		continue;
        -: 3439:	      /* Compare each bytes.  */
        -: 3440:	      for (j = 0; j < *coll_sym; j++)
        -: 3441:		if (pin[j] != coll_sym[1 + j])
        -: 3442:		  break;
        -: 3443:	      if (j == *coll_sym)
        -: 3444:		{
        -: 3445:		  /* Match if every bytes is equal.  */
        -: 3446:		  match_len = j;
        -: 3447:		  goto check_node_accept_bytes_match;
        -: 3448:		}
        -: 3449:	    }
        -: 3450:
        -: 3451:	  if (cset->nranges)
        -: 3452:	    {
        -: 3453:	      if (elem_len <= char_len)
        -: 3454:		{
        -: 3455:		  collseqwc = _NL_CURRENT (LC_COLLATE, _NL_COLLATE_COLLSEQWC);
        -: 3456:		  in_collseq = collseq_table_lookup (collseqwc, wc);
        -: 3457:		}
        -: 3458:	      else
        -: 3459:		in_collseq = find_collation_sequence_value (pin, elem_len);
        -: 3460:	    }
        -: 3461:	  /* match with range expression?  */
        -: 3462:	  for (i = 0; i < cset->nranges; ++i)
        -: 3463:	    if (cset->range_starts[i] <= in_collseq
        -: 3464:		&& in_collseq <= cset->range_ends[i])
        -: 3465:	      {
        -: 3466:		match_len = elem_len;
        -: 3467:		goto check_node_accept_bytes_match;
        -: 3468:	      }
        -: 3469:
        -: 3470:	  /* match with equivalence_class?  */
        -: 3471:	  if (cset->nequiv_classes)
        -: 3472:	    {
        -: 3473:	      const unsigned char *cp = pin;
        -: 3474:	      table = (const int32_t *)
        -: 3475:		_NL_CURRENT (LC_COLLATE, _NL_COLLATE_TABLEMB);
        -: 3476:	      weights = (const unsigned char *)
        -: 3477:		_NL_CURRENT (LC_COLLATE, _NL_COLLATE_WEIGHTMB);
        -: 3478:	      extra = (const unsigned char *)
        -: 3479:		_NL_CURRENT (LC_COLLATE, _NL_COLLATE_EXTRAMB);
        -: 3480:	      indirect = (const int32_t *)
        -: 3481:		_NL_CURRENT (LC_COLLATE, _NL_COLLATE_INDIRECTMB);
        -: 3482:	      idx = findidx (&cp);
        -: 3483:	      if (idx > 0)
        -: 3484:		for (i = 0; i < cset->nequiv_classes; ++i)
        -: 3485:		  {
        -: 3486:		    int32_t equiv_class_idx = cset->equiv_classes[i];
        -: 3487:		    size_t weight_len = weights[idx];
        -: 3488:		    if (weight_len == weights[equiv_class_idx])
        -: 3489:		      {
        -: 3490:			int cnt = 0;
        -: 3491:			while (cnt <= weight_len
        -: 3492:			       && (weights[equiv_class_idx + 1 + cnt]
        -: 3493:				   == weights[idx + 1 + cnt]))
        -: 3494:			  ++cnt;
        -: 3495:			if (cnt > weight_len)
        -: 3496:			  {
        -: 3497:			    match_len = elem_len;
        -: 3498:			    goto check_node_accept_bytes_match;
        -: 3499:			  }
        -: 3500:		      }
        -: 3501:		  }
        -: 3502:	    }
        -: 3503:	}
        -: 3504:      else
        -: 3505:# endif /* _LIBC */
        -: 3506:	{
        -: 3507:	  /* match with range expression?  */
        -: 3508:#if __GNUC__ >= 2
        -: 3509:	  wchar_t cmp_buf[] = {L'\0', L'\0', wc, L'\0', L'\0', L'\0'};
        -: 3510:#else
        -: 3511:	  wchar_t cmp_buf[] = {L'\0', L'\0', L'\0', L'\0', L'\0', L'\0'};
        -: 3512:	  cmp_buf[2] = wc;
        -: 3513:#endif
        -: 3514:	  for (i = 0; i < cset->nranges; ++i)
        -: 3515:	    {
        -: 3516:	      cmp_buf[0] = cset->range_starts[i];
        -: 3517:	      cmp_buf[4] = cset->range_ends[i];
        -: 3518:	      if (wcscoll (cmp_buf, cmp_buf + 2) <= 0
        -: 3519:		  && wcscoll (cmp_buf + 2, cmp_buf + 4) <= 0)
        -: 3520:		{
        -: 3521:		  match_len = char_len;
        -: 3522:		  goto check_node_accept_bytes_match;
        -: 3523:		}
        -: 3524:	    }
        -: 3525:	}
        -: 3526:    check_node_accept_bytes_match:
        -: 3527:      if (!cset->non_match)
        -: 3528:	return match_len;
        -: 3529:      else
        -: 3530:	{
        -: 3531:	  if (match_len > 0)
        -: 3532:	    return 0;
        -: 3533:	  else
        -: 3534:	    return (elem_len > char_len) ? elem_len : char_len;
        -: 3535:	}
        -: 3536:    }
        -: 3537:  return 0;
        -: 3538:}
        -: 3539:
        -: 3540:# ifdef _LIBC
        -: 3541:static unsigned int
        -: 3542:find_collation_sequence_value (mbs, mbs_len)
        -: 3543:    const unsigned char *mbs;
        -: 3544:    size_t mbs_len;
        -: 3545:{
        -: 3546:  uint32_t nrules = _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES);
        -: 3547:  if (nrules == 0)
        -: 3548:    {
        -: 3549:      if (mbs_len == 1)
        -: 3550:	{
        -: 3551:	  /* No valid character.  Match it as a single byte character.  */
        -: 3552:	  const unsigned char *collseq = (const unsigned char *)
        -: 3553:	    _NL_CURRENT (LC_COLLATE, _NL_COLLATE_COLLSEQMB);
        -: 3554:	  return collseq[mbs[0]];
        -: 3555:	}
        -: 3556:      return UINT_MAX;
        -: 3557:    }
        -: 3558:  else
        -: 3559:    {
        -: 3560:      int32_t idx;
        -: 3561:      const unsigned char *extra = (const unsigned char *)
        -: 3562:	_NL_CURRENT (LC_COLLATE, _NL_COLLATE_SYMB_EXTRAMB);
        -: 3563:
        -: 3564:      for (idx = 0; ;)
        -: 3565:	{
        -: 3566:	  int mbs_cnt, found = 0;
        -: 3567:	  int32_t elem_mbs_len;
        -: 3568:	  /* Skip the name of collating element name.  */
        -: 3569:	  idx = idx + extra[idx] + 1;
        -: 3570:	  elem_mbs_len = extra[idx++];
        -: 3571:	  if (mbs_len == elem_mbs_len)
        -: 3572:	    {
        -: 3573:	      for (mbs_cnt = 0; mbs_cnt < elem_mbs_len; ++mbs_cnt)
        -: 3574:		if (extra[idx + mbs_cnt] != mbs[mbs_cnt])
        -: 3575:		  break;
        -: 3576:	      if (mbs_cnt == elem_mbs_len)
        -: 3577:		/* Found the entry.  */
        -: 3578:		found = 1;
        -: 3579:	    }
        -: 3580:	  /* Skip the byte sequence of the collating element.  */
        -: 3581:	  idx += elem_mbs_len;
        -: 3582:	  /* Adjust for the alignment.  */
        -: 3583:	  idx = (idx + 3) & ~3;
        -: 3584:	  /* Skip the collation sequence value.  */
        -: 3585:	  idx += sizeof (uint32_t);
        -: 3586:	  /* Skip the wide char sequence of the collating element.  */
        -: 3587:	  idx = idx + sizeof (uint32_t) * (extra[idx] + 1);
        -: 3588:	  /* If we found the entry, return the sequence value.  */
        -: 3589:	  if (found)
        -: 3590:	    return *(uint32_t *) (extra + idx);
        -: 3591:	  /* Skip the collation sequence value.  */
        -: 3592:	  idx += sizeof (uint32_t);
        -: 3593:	}
        -: 3594:    }
        -: 3595:}
        -: 3596:# endif /* _LIBC */
        -: 3597:#endif /* RE_ENABLE_I18N */
        -: 3598:
        -: 3599:/* Check whether the node accepts the byte which is IDX-th
        -: 3600:   byte of the INPUT.  */
        -: 3601:
        -: 3602:static int
function check_node_accept called 598 returned 100% blocks executed 44%
      598: 3603:check_node_accept (preg, node, mctx, idx)
        -: 3604:    const regex_t *preg;
        -: 3605:    const re_token_t *node;
        -: 3606:    const re_match_context_t *mctx;
        -: 3607:    int idx;
        -: 3608:{
        -: 3609:  unsigned char ch;
      598: 3610:  if (node->constraint)
branch  0 taken 0 (fallthrough)
branch  1 taken 598
        -: 3611:    {
        -: 3612:      /* The node has constraints.  Check whether the current context
        -: 3613:	 satisfies the constraints.  */
    #####: 3614:      unsigned int context = re_string_context_at (mctx->input, idx,
    #####: 3615:						   mctx->eflags,
    #####: 3616:						   preg->newline_anchor);
call    0 never executed
    #####: 3617:      if (NOT_SATISFY_NEXT_CONSTRAINT (node->constraint, context))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
    #####: 3618:	return 0;
        -: 3619:    }
      598: 3620:  ch = re_string_byte_at (mctx->input, idx);
      598: 3621:  if (node->type == CHARACTER)
branch  0 taken 292 (fallthrough)
branch  1 taken 306
      292: 3622:    return node->opr.c == ch;
      306: 3623:  else if (node->type == SIMPLE_BRACKET)
branch  0 taken 72 (fallthrough)
branch  1 taken 234
       72: 3624:    return bitset_contain (node->opr.sbcset, ch);
      234: 3625:  else if (node->type == OP_PERIOD)
branch  0 taken 234 (fallthrough)
branch  1 taken 0
     234*: 3626:    return !((ch == '\n' && !(preg->syntax & RE_DOT_NEWLINE))
branch  0 taken 0 (fallthrough)
branch  1 taken 234
branch  2 never executed
branch  3 never executed
branch  4 taken 0 (fallthrough)
branch  5 taken 234
    #####: 3627:	     || (ch == '\0' && (preg->syntax & RE_DOT_NOT_NULL)));
branch  0 never executed
branch  1 never executed
        -: 3628:  else
    #####: 3629:    return 0;
        -: 3630:}
        -: 3631:
        -: 3632:/* Extend the buffers, if the buffers have run out.  */
        -: 3633:
        -: 3634:static reg_errcode_t
function extend_buffers called 4485 returned 100% blocks executed 71%
     4485: 3635:extend_buffers (mctx)
        -: 3636:     re_match_context_t *mctx;
        -: 3637:{
        -: 3638:  reg_errcode_t ret;
     4485: 3639:  re_string_t *pstr = mctx->input;
        -: 3640:
        -: 3641:  /* Double the lengthes of the buffers.  */
     4485: 3642:  ret = re_string_realloc_buffers (pstr, pstr->bufs_len * 2);
call    0 returned 4485
     4485: 3643:  if (BE (ret != REG_NOERROR, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 4485
    #####: 3644:    return ret;
        -: 3645:
     4485: 3646:  if (mctx->state_log != NULL)
branch  0 taken 7 (fallthrough)
branch  1 taken 4478
        -: 3647:    {
        -: 3648:      /* And double the length of state_log.  */
        -: 3649:      re_dfastate_t **new_array;
        7: 3650:      new_array = re_realloc (mctx->state_log, re_dfastate_t *,
        -: 3651:			      pstr->bufs_len * 2);
        7: 3652:      if (BE (new_array == NULL, 0))
branch  0 taken 0 (fallthrough)
branch  1 taken 7
    #####: 3653:	return REG_ESPACE;
        7: 3654:      mctx->state_log = new_array;
        -: 3655:    }
        -: 3656:
        -: 3657:  /* Then reconstruct the buffers.  */
     4485: 3658:  if (pstr->icase)
branch  0 taken 0 (fallthrough)
branch  1 taken 4485
        -: 3659:    {
        -: 3660:#ifdef RE_ENABLE_I18N
        -: 3661:      if (MB_CUR_MAX > 1)
        -: 3662:	build_wcs_upper_buffer (pstr);
        -: 3663:      else
        -: 3664:#endif /* RE_ENABLE_I18N  */
    #####: 3665:	build_upper_buffer (pstr);
call    0 never executed
        -: 3666:    }
        -: 3667:  else
        -: 3668:    {
        -: 3669:#ifdef RE_ENABLE_I18N
        -: 3670:      if (MB_CUR_MAX > 1)
        -: 3671:	build_wcs_buffer (pstr);
        -: 3672:      else
        -: 3673:#endif /* RE_ENABLE_I18N  */
        -: 3674:	{
     4485: 3675:	  if (pstr->trans != NULL)
branch  0 taken 0 (fallthrough)
branch  1 taken 4485
    #####: 3676:	    re_string_translate_buffer (pstr);
call    0 never executed
        -: 3677:	  else
     4485: 3678:	    pstr->valid_len = pstr->bufs_len;
        -: 3679:	}
        -: 3680:    }
     4485: 3681:  return REG_NOERROR;
        -: 3682:}
        -: 3683:
        -: 3684:
        -: 3685:/* Functions for matching context.  */
        -: 3686:
        -: 3687:static reg_errcode_t
function match_ctx_init called 49072 returned 100% blocks executed 57%
    49072: 3688:match_ctx_init (mctx, eflags, input, n)
        -: 3689:    re_match_context_t *mctx;
        -: 3690:    int eflags, n;
        -: 3691:    re_string_t *input;
        -: 3692:{
    49072: 3693:  mctx->eflags = eflags;
    49072: 3694:  mctx->input = input;
    49072: 3695:  mctx->match_last = -1;
    49072: 3696:  if (n > 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 49072
        -: 3697:    {
    #####: 3698:      mctx->bkref_ents = re_malloc (struct re_backref_cache_entry, n);
    #####: 3699:      mctx->sub_tops = re_malloc (re_sub_match_top_t *, n);
    #####: 3700:      if (BE (mctx->bkref_ents == NULL || mctx->sub_tops == NULL, 0))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3701:	return REG_ESPACE;
        -: 3702:    }
        -: 3703:  else
    49072: 3704:    mctx->bkref_ents = NULL;
    49072: 3705:  mctx->nbkref_ents = 0;
    49072: 3706:  mctx->abkref_ents = n;
    49072: 3707:  mctx->max_mb_elem_len = 1;
    49072: 3708:  mctx->nsub_tops = 0;
    49072: 3709:  mctx->asub_tops = n;
    49072: 3710:  return REG_NOERROR;
        -: 3711:}
        -: 3712:
        -: 3713:static void
function match_ctx_free called 0 returned 0% blocks executed 0%
    #####: 3714:match_ctx_free (mctx)
        -: 3715:    re_match_context_t *mctx;
        -: 3716:{
        -: 3717:  int st_idx;
    #####: 3718:  for (st_idx = 0; st_idx < mctx->nsub_tops; ++st_idx)
branch  0 never executed
branch  1 never executed
        -: 3719:    {
        -: 3720:      int sl_idx;
    #####: 3721:      re_sub_match_top_t *top = mctx->sub_tops[st_idx];
    #####: 3722:      for (sl_idx = 0; sl_idx < top->nlasts; ++sl_idx)
branch  0 never executed
branch  1 never executed
        -: 3723:	{
    #####: 3724:	  re_sub_match_last_t *last = top->lasts[sl_idx];
    #####: 3725:	  re_free (last->path.array);
    #####: 3726:	  if (last->limits)
branch  0 never executed
branch  1 never executed
    #####: 3727:	    re_node_set_free (last->limits);
    #####: 3728:	  re_free (last);
        -: 3729:	}
    #####: 3730:      re_free (top->lasts);
    #####: 3731:      if (top->path)
branch  0 never executed
branch  1 never executed
        -: 3732:	{
    #####: 3733:	  re_free (top->path->array);
    #####: 3734:	  re_free (top->path);
        -: 3735:	}
    #####: 3736:      if (top->limits)
branch  0 never executed
branch  1 never executed
    #####: 3737:	re_node_set_free (top->limits);
    #####: 3738:      free (top);
        -: 3739:    }
    #####: 3740:  re_free (mctx->sub_tops);
    #####: 3741:  re_free (mctx->bkref_ents);
    #####: 3742:}
        -: 3743:
        -: 3744:/* Add a new backreference entry to the cache.  */
        -: 3745:
        -: 3746:static reg_errcode_t
function match_ctx_add_entry called 0 returned 0% blocks executed 0%
    #####: 3747:match_ctx_add_entry (mctx, node, str_idx, from, to, top, last)
        -: 3748:     re_match_context_t *mctx;
        -: 3749:     int node, str_idx, from, to;
        -: 3750:     re_sub_match_top_t *top;
        -: 3751:     re_sub_match_last_t *last;
        -: 3752:{
        -: 3753:  /* TODO: It can be more efficient.  */
        -: 3754:  int i;
    #####: 3755:  for (i = 0; i < mctx->nbkref_ents; ++i)
branch  0 never executed
branch  1 never executed
        -: 3756:    {
    #####: 3757:      struct re_backref_cache_entry *entry = mctx->bkref_ents + i;
    #####: 3758:      if (entry->node == node && entry->str_idx == str_idx
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3759:	  &&  entry->subexp_from == from &&  entry->subexp_to == to)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3760:	return REG_NOERROR;
        -: 3761:    }
        -: 3762:
    #####: 3763:  if (mctx->nbkref_ents >= mctx->abkref_ents)
branch  0 never executed
branch  1 never executed
        -: 3764:    {
        -: 3765:      struct re_backref_cache_entry* new_entry;
    #####: 3766:      new_entry = re_realloc (mctx->bkref_ents, struct re_backref_cache_entry,
        -: 3767:			      mctx->abkref_ents * 2);
    #####: 3768:      if (BE (new_entry == NULL, 0))
branch  0 never executed
branch  1 never executed
        -: 3769:	{
    #####: 3770:	  re_free (mctx->bkref_ents);
    #####: 3771:	  return REG_ESPACE;
        -: 3772:	}
    #####: 3773:      mctx->bkref_ents = new_entry;
    #####: 3774:      memset (mctx->bkref_ents + mctx->nbkref_ents, '\0',
    #####: 3775:	      sizeof (struct re_backref_cache_entry) * mctx->abkref_ents);
    #####: 3776:      mctx->abkref_ents *= 2;
        -: 3777:    }
    #####: 3778:  mctx->bkref_ents[mctx->nbkref_ents].node = node;
    #####: 3779:  mctx->bkref_ents[mctx->nbkref_ents].str_idx = str_idx;
    #####: 3780:  mctx->bkref_ents[mctx->nbkref_ents].subexp_from = from;
    #####: 3781:  mctx->bkref_ents[mctx->nbkref_ents].subexp_to = to;
    #####: 3782:  mctx->bkref_ents[mctx->nbkref_ents].top = top;
    #####: 3783:  mctx->bkref_ents[mctx->nbkref_ents].last = last;
    #####: 3784:  mctx->bkref_ents[mctx->nbkref_ents++].flag = 0;
    #####: 3785:  if (mctx->max_mb_elem_len < to - from)
branch  0 never executed
branch  1 never executed
    #####: 3786:    mctx->max_mb_elem_len = to - from;
    #####: 3787:  return REG_NOERROR;
        -: 3788:}
        -: 3789:
        -: 3790:static int
function search_cur_bkref_entry called 0 returned 0% blocks executed 0%
    #####: 3791:search_cur_bkref_entry (mctx, str_idx)
        -: 3792:     re_match_context_t *mctx;
        -: 3793:     int str_idx;
        -: 3794:{
        -: 3795:  int left, right, mid;
    #####: 3796:  right = mctx->nbkref_ents;
    #####: 3797:  for (left = 0; left < right;)
branch  0 never executed
branch  1 never executed
        -: 3798:    {
    #####: 3799:      mid = (left + right) / 2;
    #####: 3800:      if (mctx->bkref_ents[mid].str_idx < str_idx)
branch  0 never executed
branch  1 never executed
    #####: 3801:	left = mid + 1;
        -: 3802:      else
    #####: 3803:	right = mid;
        -: 3804:    }
    #####: 3805:  return left;
        -: 3806:}
        -: 3807:
        -: 3808:static void
function match_ctx_clear_flag called 0 returned 0% blocks executed 0%
    #####: 3809:match_ctx_clear_flag (mctx)
        -: 3810:     re_match_context_t *mctx;
        -: 3811:{
        -: 3812:  int i;
    #####: 3813:  for (i = 0; i < mctx->nbkref_ents; ++i)
branch  0 never executed
branch  1 never executed
        -: 3814:    {
    #####: 3815:      mctx->bkref_ents[i].flag = 0;
        -: 3816:    }
    #####: 3817:}
        -: 3818:
        -: 3819:static reg_errcode_t
function match_ctx_add_subtop called 0 returned 0% blocks executed 0%
    #####: 3820:match_ctx_add_subtop (mctx, node, str_idx)
        -: 3821:     re_match_context_t *mctx;
        -: 3822:     int node, str_idx;
        -: 3823:{
        -: 3824:#ifdef DEBUG
        -: 3825:  assert (mctx->sub_tops != NULL);
        -: 3826:  assert (mctx->asub_tops > 0);
        -: 3827:#endif
    #####: 3828:  if (mctx->nsub_tops == mctx->asub_tops)
branch  0 never executed
branch  1 never executed
        -: 3829:    {
    #####: 3830:      mctx->asub_tops *= 2;
    #####: 3831:      mctx->sub_tops = re_realloc (mctx->sub_tops, re_sub_match_top_t *,
        -: 3832:				   mctx->asub_tops);
    #####: 3833:      if (BE (mctx->sub_tops == NULL, 0))
branch  0 never executed
branch  1 never executed
    #####: 3834:	return REG_ESPACE;
        -: 3835:    }
    #####: 3836:  mctx->sub_tops[mctx->nsub_tops] = calloc (1, sizeof (re_sub_match_top_t));
    #####: 3837:  if (mctx->sub_tops[mctx->nsub_tops] == NULL)
branch  0 never executed
branch  1 never executed
    #####: 3838:    return REG_ESPACE;
    #####: 3839:  mctx->sub_tops[mctx->nsub_tops]->node = node;
    #####: 3840:  mctx->sub_tops[mctx->nsub_tops++]->str_idx = str_idx;
    #####: 3841:  return REG_NOERROR;
        -: 3842:}
        -: 3843:
        -: 3844:static re_sub_match_last_t *
function match_ctx_add_sublast called 0 returned 0% blocks executed 0%
    #####: 3845:match_ctx_add_sublast (subtop, node, str_idx)
        -: 3846:     re_sub_match_top_t *subtop;
        -: 3847:     int node, str_idx;
        -: 3848:{
        -: 3849:  re_sub_match_last_t *new_entry;
    #####: 3850:  if (subtop->nlasts == subtop->alasts)
branch  0 never executed
branch  1 never executed
        -: 3851:    {
    #####: 3852:      subtop->alasts = 2 * subtop->alasts + 1;
    #####: 3853:      subtop->lasts = re_realloc (subtop->lasts, re_sub_match_last_t *,
        -: 3854:				  subtop->alasts);
    #####: 3855:      if (BE (subtop->lasts == NULL, 0))
branch  0 never executed
branch  1 never executed
    #####: 3856:	return NULL;
        -: 3857:    }
    #####: 3858:  new_entry = calloc (1, sizeof (re_sub_match_last_t));
    #####: 3859:  subtop->lasts[subtop->nlasts] = new_entry;
    #####: 3860:  new_entry->node = node;
    #####: 3861:  new_entry->str_idx = str_idx;
    #####: 3862:  new_entry->limits = NULL;
    #####: 3863:  ++subtop->nlasts;
    #####: 3864:  return new_entry;
        -: 3865:}
        -: 3866:
        -: 3867:static void
function sift_ctx_init called 29 returned 100% blocks executed 100%
       29: 3868:sift_ctx_init (sctx, sifted_sts, limited_sts, last_node, last_str_idx,
        -: 3869:	       check_subexp)
        -: 3870:    re_sift_context_t *sctx;
        -: 3871:    re_dfastate_t **sifted_sts, **limited_sts;
        -: 3872:    int last_node, last_str_idx, check_subexp;
        -: 3873:{
       29: 3874:  sctx->sifted_states = sifted_sts;
       29: 3875:  sctx->limited_states = limited_sts;
       29: 3876:  sctx->last_node = last_node;
       29: 3877:  sctx->last_str_idx = last_str_idx;
       29: 3878:  sctx->check_subexp = check_subexp;
       29: 3879:  sctx->cur_bkref = -1;
       29: 3880:  sctx->cls_subexp_idx = -1;
       29: 3881:  re_node_set_init_empty (&sctx->limits);
       29: 3882:}
        -: 3883:
        -: 3884:/* This function is optimized to compare for equality only.
        -: 3885:   It also tries to limit the startup time as much as possible.  */
function my_memcmp called 0 returned 0% blocks executed 0%
    #####: 3886:static int my_memcmp (char *s1, char *s2, unsigned int l)
        -: 3887:{
    #####: 3888:  if (BE(l, 1) != 0)
branch  0 never executed
branch  1 never executed
    #####: 3889:    while (BE(*s1 == *s2, 1) && BE(--l, 0) != 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3890:      s1++, s2++;
        -: 3891:
    #####: 3892:  return l;
        -: 3893:}
