        -:    0:Source:sed.c
        -:    0:Graph:sed.gcno
        -:    0:Data:sed.gcda
        -:    0:Runs:370
        -:    1:#define COPYRIGHT_NOTICE "Copyright (C) 2003 Free Software Foundation, Inc."
        -:    2:#define BUG_ADDRESS "bonzini@gnu.org"
        -:    3:
        -:    4:/*  GNU SED, a batch stream editor.
        -:    5:    Copyright (C) 1989,90,91,92,93,94,95,98,99,2002,2003
        -:    6:    Free Software Foundation, Inc.
        -:    7:
        -:    8:    This program is free software; you can redistribute it and/or modify
        -:    9:    it under the terms of the GNU General Public License as published by
        -:   10:    the Free Software Foundation; either version 2, or (at your option)
        -:   11:    any later version.
        -:   12:
        -:   13:    This program is distributed in the hope that it will be useful,
        -:   14:    but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   15:    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   16:    GNU General Public License for more details.
        -:   17:
        -:   18:    You should have received a copy of the GNU General Public License
        -:   19:    along with this program; if not, write to the Free Software
        -:   20:    Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
        -:   21:
        -:   22:/*
        -:   23:  Fixing some non-determinism for SIR July 2006
        -:   24:  by Kyle R. Murphy
        -:   25:*/
        -:   26:#undef stderr
        -:   27:#define stderr stdout
        -:   28:
        -:   29:#include "FaultSeeds.h"
        -:   30:#include "config.h"
        -:   31:
        -:   32:#include <stdio.h>
        -:   33:#ifdef HAVE_STRINGS_H
        -:   34:# include <strings.h>
        -:   35:#else
        -:   36:# include <string.h>
        -:   37:#endif /*HAVE_STRINGS_H*/
        -:   38:#ifdef HAVE_MEMORY_H
        -:   39:# include <memory.h>
        -:   40:#endif
        -:   41:
        -:   42:#ifndef HAVE_STRCHR
        -:   43:# define strchr index
        -:   44:# define strrchr rindex
        -:   45:#endif
        -:   46:
        -:   47:#ifdef HAVE_STDLIB_H
        -:   48:# include <stdlib.h>
        -:   49:#endif
        -:   50:
        -:   51:#ifdef HAVE_SYS_TYPES_H
        -:   52:# include <sys/types.h>
        -:   53:#endif
        -:   54:#ifdef HAVE_LOCALE_H
        -:   55:# include <locale.h>
        -:   56:#endif
        -:   57:#include "getopt.h"
        -:   58:#include "basicdefs.h"
        -:   59:#include "utils.h"
        -:   60:#include "sed.h"
        -:   61:
        -:   62:#ifndef BOOTSTRAP
        -:   63:#ifndef HAVE_STDLIB_H
        -:   64: extern char *getenv P_((const char *));
        -:   65:#endif
        -:   66:#endif
        -:   67:
        -:   68:#ifndef HAVE_STRTOUL
        -:   69:# define ATOI(x)	atoi(x)
        -:   70:#else
        -:   71:# define ATOI(x)	strtoul(x, NULL, 0)
        -:   72:#endif
        -:   73:
        -:   74:int extended_regexp_flags = 0;
        -:   75:
        -:   76:/* If set, fflush(stdout) on every line output. */
        -:   77:flagT unbuffered_output = FALSE;
        -:   78:
        -:   79:/* If set, don't write out the line unless explicitly told to */
        -:   80:flagT no_default_output = FALSE;
        -:   81:
        -:   82:/* If set, reset line counts on every new file. */
        -:   83:flagT separate_files = FALSE;
        -:   84:
        -:   85:/* How do we edit files in-place? (we don't if NULL) */
        -:   86:char *in_place_extension = NULL;
        -:   87:
        -:   88:/* Do we need to be pedantically POSIX compliant? */
        -:   89:flagT POSIXLY_CORRECT;
        -:   90:
        -:   91:/* How long should the `l' command's output line be? */
        -:   92:countT lcmd_out_line_len = 70;
        -:   93:
        -:   94:/* The complete compiled SED program that we are going to run: */
        -:   95:static struct vector *the_program = NULL;
        -:   96:
        -:   97:static void usage P_((int));
        -:   98:static void
function usage called 0 returned 0% blocks executed 0%
    #####:   99:usage(status)
        -:  100:  int status;
        -:  101:{
    #####:  102:  FILE *out = status ? stderr : stdout;
        -:  103:
        -:  104:#ifdef REG_PERL
        -:  105:#define PERL_HELP _("  -R, --regexp-perl\n                 use Perl 5's regular expressions syntax in the script.\n")
        -:  106:#else
        -:  107:#define PERL_HELP ""
        -:  108:#endif
        -:  109:
    #####:  110:  fprintf(out, _("\
call    0 never executed
        -:  111:Usage: %s [OPTION]... {script-only-if-no-other-script} [input-file]...\n\
        -:  112:\n\
        -:  113:  -n, --quiet, --silent\n\
        -:  114:                 suppress automatic printing of pattern space\n\
        -:  115:  -e script, --expression=script\n\
        -:  116:                 add the script to the commands to be executed\n\
        -:  117:  -f script-file, --file=script-file\n\
        -:  118:                 add the contents of script-file to the commands to be executed\n\
        -:  119:  -i[suffix], --in-place[=suffix]\n\
        -:  120:                 edit files in place (makes backup if extension supplied)\n\
        -:  121:  -l N, --line-length=N\n\
        -:  122:                 specify the desired line-wrap length for the `l' command\n\
        -:  123:  -r, --regexp-extended\n\
        -:  124:                 use extended regular expressions in the script.\n%s\
        -:  125:  -s, --separate\n\
        -:  126:                 consider files as separate rather than as a single continuous\n\
        -:  127:                 long stream.\n\
        -:  128:  -u, --unbuffered\n\
        -:  129:                 load minimal amounts of data from the input files and flush\n\
        -:  130:                 the output buffers more often\n\
        -:  131:      --help     display this help and exit\n\
        -:  132:  -V, --version  output version information and exit\n\
        -:  133:\n\
        -:  134:If no -e, --expression, -f, or --file option is given, then the first\n\
        -:  135:non-option argument is taken as the sed script to interpret.  All\n\
        -:  136:remaining arguments are names of input files; if no input files are\n\
        -:  137:specified, then the standard input is read.\n\
        -:  138:\n"), myname, PERL_HELP);
    #####:  139:  fprintf(out, _("E-mail bug reports to: %s .\n\
call    0 never executed
        -:  140:Be sure to include the word ``%s'' somewhere in the ``Subject:'' field.\n"),
        -:  141:	  BUG_ADDRESS, PACKAGE);
        -:  142:
    #####:  143:  ck_fclose (NULL);
call    0 never executed
    #####:  144:  exit (status);
        -:  145:}
        -:  146:
        -:  147:int
function main called 370 returned 0% blocks executed 76%
      370:  148:main(argc, argv)
        -:  149:  int argc;
        -:  150:  char **argv;
        -:  151:{
        -:  152:#ifdef REG_PERL
        -:  153:#define SHORTOPTS "shnrRuVe:f:l:i::"
        -:  154:#else
        -:  155:#define SHORTOPTS "shnruVe:f:l:i::"
        -:  156:#endif
        -:  157:
        -:  158:  static struct option longopts[] = {
        -:  159:    {"regexp-extended", 0, NULL, 'r'},
        -:  160:#ifdef REG_PERL
        -:  161:    {"regexp-perl", 0, NULL, 'R'},
        -:  162:#endif
        -:  163:    {"expression", 1, NULL, 'e'},
        -:  164:    {"file", 1, NULL, 'f'},
        -:  165:    {"in-place", 2, NULL, 'i'},
        -:  166:    {"line-length", 1, NULL, 'l'},
        -:  167:    {"quiet", 0, NULL, 'n'},
        -:  168:    {"silent", 0, NULL, 'n'},
        -:  169:    {"separate", 0, NULL, 's'},
        -:  170:    {"unbuffered", 0, NULL, 'u'},
        -:  171:    {"version", 0, NULL, 'V'},
        -:  172:    {"help", 0, NULL, 'h'},
        -:  173:    {NULL, 0, NULL, 0}
        -:  174:  };
        -:  175:
        -:  176:  int opt;
        -:  177:  int return_code;
        -:  178:
        -:  179:  initialize_main(&argc, &argv);
        -:  180:
        -:  181:#if ENABLE_NLS
        -:  182:#if HAVE_SETLOCALE
        -:  183:  /* Set locale according to user's wishes.  */
        -:  184:  setlocale (LC_ALL, "");
        -:  185:#endif
        -:  186:
        -:  187:  /* Tell program which translations to use and where to find.  */
        -:  188:  bindtextdomain (PACKAGE, LOCALEDIR);
        -:  189:  textdomain (PACKAGE);
        -:  190:#endif
        -:  191:
      370:  192:  POSIXLY_CORRECT = (getenv("POSIXLY_CORRECT") != NULL);
call    0 returned 370
        -:  193:
        -:  194:  /* If environment variable `COLS' is set, use its value for
        -:  195:     the baseline setting of `lcmd_out_line_len'.  The "-1"
        -:  196:     is to avoid gratuitous auto-line-wrap on ttys.
        -:  197:   */
        -:  198:  {
      370:  199:    const char *p = getenv("COLS");
call    0 returned 370
      370:  200:    if (p)
branch  0 taken 0 (fallthrough)
branch  1 taken 370
        -:  201:      {
    #####:  202:	countT t = ATOI(p);
    #####:  203:	if (1 < t)
branch  0 never executed
branch  1 never executed
    #####:  204:	  lcmd_out_line_len = t-1;
        -:  205:      }
        -:  206:  }
        -:  207:
        -:  208:/*
        -:  209:  More non-determinism -- SIR July 2006
        -:  210:  by Kyle R. Murphy
        -:  211:  myname = *argv;
        -:  212:*/
      370:  213:  myname = "Executable";
        -:  214:
      751:  215:  while ((opt = getopt_long(argc, argv, SHORTOPTS, longopts, NULL)) != EOF)
call    0 returned 751
branch  1 taken 385
branch  2 taken 366 (fallthrough)
        -:  216:    {
      385:  217:      switch (opt)
branch  0 taken 7
branch  1 taken 27
branch  2 taken 339
branch  3 taken 2
branch  4 taken 2
branch  5 taken 2
branch  6 taken 2
branch  7 taken 2
branch  8 taken 2
branch  9 taken 0
branch 10 taken 0
        -:  218:	{
        7:  219:	case 'n':
        7:  220:	  no_default_output = TRUE;
        7:  221:	  break;
       27:  222:	case 'e':
       27:  223:	  the_program = compile_string(the_program, optarg, strlen(optarg));
call    0 returned 27
       27:  224:	  break;
      339:  225:	case 'f':
      339:  226:	  the_program = compile_file(the_program, optarg);
call    0 returned 337
      337:  227:	  break;
        -:  228:
        2:  229:	case 'i':
        2:  230:	  separate_files = TRUE;
        2:  231:	  if (optarg == NULL)
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        1:  232:	    in_place_extension = "*";
        1:  233:	  else if (strchr(optarg, '*') == NULL)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -:  234:	    {
        1:  235:	      in_place_extension = xmalloc (strlen(optarg) + 2);
call    0 returned 1
        1:  236:	      in_place_extension[0] = '*';
        1:  237:	      strcpy (in_place_extension + 1, optarg);
        -:  238:	    }
        -:  239:	  else
    #####:  240:	    in_place_extension = ck_strdup(optarg);
call    0 never executed
        2:  241:	  break;
        -:  242:
        2:  243:	case 'l':
        2:  244:	  lcmd_out_line_len = ATOI(optarg);
        2:  245:	  break;
        2:  246:	case 'r':
        2:  247:	  if (extended_regexp_flags)
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####:  248:	    usage(4);
call    0 never executed
        2:  249:	  extended_regexp_flags = REG_EXTENDED;
        2:  250:	  break;
        -:  251:
        -:  252:#ifdef REG_PERL
        -:  253:	case 'R':
        -:  254:	  if (extended_regexp_flags)
        -:  255:	    usage(4);
        -:  256:	  extended_regexp_flags = REG_PERL;
        -:  257:	  break;
        -:  258:#endif
        -:  259:
        2:  260:	case 's':
        2:  261:	  separate_files = TRUE;
        2:  262:	  break;
        -:  263:
        2:  264:	case 'u':
        2:  265:	  unbuffered_output = TRUE;
        2:  266:	  break;
        -:  267:
        2:  268:	case 'V':
        -:  269:#ifdef REG_PERL
        -:  270:	  fprintf(stdout, _("super-sed version %s\n"), VERSION);
        -:  271:	  fprintf(stdout, _("based on GNU sed version 3.02.80\n\n"));
        -:  272:#else
        2:  273:	  fprintf(stdout, _("GNU sed version %s\n"), VERSION);
call    0 returned 2
        -:  274:#endif
        2:  275:	  fprintf(stdout, _("%s\n\
call    0 returned 2
        -:  276:This is free software; see the source for copying conditions.  There is NO\n\
        -:  277:warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE,\n\
        -:  278:to the extent permitted by law.\n\
        -:  279:"), COPYRIGHT_NOTICE);
        2:  280:	  ck_fclose (NULL);
call    0 returned 0
    #####:  281:	  exit (0);
call    0 never executed
    #####:  282:	case 'h':
    #####:  283:	  usage(0);
call    0 never executed
    #####:  284:	default:
    #####:  285:	  usage(4);
call    0 never executed
        -:  286:	}
        -:  287:    }
        -:  288:
      366:  289:  if (!the_program)
branch  0 taken 5 (fallthrough)
branch  1 taken 361
        -:  290:    {
        5:  291:      if (optind < argc)
branch  0 taken 5 (fallthrough)
branch  1 taken 0
        -:  292:	{
        5:  293:	  char *arg = argv[optind++];
       5*:  294:	  the_program = compile_string(the_program, arg, strlen(arg));
call    0 returned 0
        -:  295:	}
        -:  296:      else
    #####:  297:	usage(4);
call    0 never executed
        -:  298:    }
      361:  299:  check_final_program(the_program);
call    0 returned 360
        -:  300:
      360:  301:  return_code = process_files(the_program, argv+optind);
call    0 returned 360
        -:  302:
      360:  303:  finish_program(the_program);
call    0 returned 360
      360:  304:  ck_fclose(NULL);
call    0 returned 0
        -:  305:
    #####:  306:  return return_code;
        -:  307:}
        -:  308:/*  GNU SED, a batch stream editor.
        -:  309:    Copyright (C) 1989,90,91,92,93,94,95,98,99,2002,2003
        -:  310:    Free Software Foundation, Inc.
        -:  311:
        -:  312:    This program is free software; you can redistribute it and/or modify
        -:  313:    it under the terms of the GNU General Public License as published by
        -:  314:    the Free Software Foundation; either version 2, or (at your option)
        -:  315:    any later version.
        -:  316:
        -:  317:    This program is distributed in the hope that it will be useful,
        -:  318:    but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:  319:    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:  320:    GNU General Public License for more details.
        -:  321:
        -:  322:    You should have received a copy of the GNU General Public License
        -:  323:    along with this program; if not, write to the Free Software
        -:  324:    Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
        -:  325:
        -:  326:/* compile.c: translate sed source into internal form */
        -:  327:
        -:  328:#include "config.h"
        -:  329:#include <stdio.h>
        -:  330:#include <ctype.h>
        -:  331:
        -:  332:#ifdef HAVE_STRINGS_H
        -:  333:# include <strings.h>
        -:  334:# ifdef HAVE_MEMORY_H
        -:  335:#  include <memory.h>
        -:  336:# endif
        -:  337:#else
        -:  338:# include <string.h>
        -:  339:#endif /* HAVE_STRINGS_H */
        -:  340:
        -:  341:#ifdef HAVE_STDLIB_H
        -:  342:# include <stdlib.h>
        -:  343:#endif
        -:  344:#ifndef EXIT_FAILURE
        -:  345:# define EXIT_FAILURE 1
        -:  346:#endif
        -:  347:
        -:  348:#if defined HAVE_WCTYPE_H && defined HAVE_WCHAR_H && defined HAVE_MBRTOWC
        -:  349:/* We can handle multibyte string.  */
        -:  350:# include <wchar.h>
        -:  351:# include <wctype.h>
        -:  352:# define MBS_SUPPORT
        -:  353:#endif
        -:  354:
        -:  355:#ifdef HAVE_SYS_TYPES_H
        -:  356:# include <sys/types.h>
        -:  357:#endif
        -:  358:#include "obstack.h"
        -:  359:#include "basicdefs.h"
        -:  360:#include "utils.h"
        -:  361:
        -:  362:extern flagT no_default_output;
        -:  363:extern flagT POSIXLY_CORRECT;
        -:  364:
        -:  365:
        -:  366:#define YMAP_LENGTH		256 /*XXX shouldn't this be (UCHAR_MAX+1)?*/
        -:  367:#define VECTOR_ALLOC_INCREMENT	40
        -:  368:
        -:  369:/* let's not confuse text editors that have only dumb bracket-matching... */
        -:  370:#define OPEN_BRACKET	'['
        -:  371:#define CLOSE_BRACKET	']'
        -:  372:#define OPEN_BRACE	'{'
        -:  373:#define CLOSE_BRACE	'}'
        -:  374:
        -:  375:struct prog_info {
        -:  376:  /* When we're reading a script command from a string, `prog.base'
        -:  377:     points to the first character in the string, 'prog.cur' points
        -:  378:     to the current character in the string, and 'prog.end' points
        -:  379:     to the end of the string.  This allows us to compile script
        -:  380:     strings that contain nulls. */
        -:  381:  const unsigned char *base;
        -:  382:  const unsigned char *cur;
        -:  383:  const unsigned char *end;
        -:  384:
        -:  385:  /* This is the current script file.  If it is NULL, we are reading
        -:  386:     from a string stored at `prog.cur' instead.  If both `prog.file'
        -:  387:     and `prog.cur' are NULL, we're in trouble! */
        -:  388:  FILE *file;
        -:  389:};
        -:  390:
        -:  391:/* Information used to give out useful and informative error messages. */
        -:  392:struct error_info {
        -:  393:  /* This is the name of the current script file. */
        -:  394:  const char *name;
        -:  395:
        -:  396:  /* This is the number of the current script line that we're compiling. */
        -:  397:  countT line;
        -:  398:
        -:  399:  /* This is the index of the "-e" expressions on the command line. */
        -:  400:  countT string_expr_count;
        -:  401:};
        -:  402:
        -:  403:
        -:  404:/* Label structure used to resolve GOTO's, labels, and block beginnings. */
        -:  405:struct sed_label {
        -:  406:  countT v_index;		/* index of vector element being referenced */
        -:  407:  char *name;			/* NUL-terminated name of the label */
        -:  408:  struct error_info err_info;	/* track where `{}' blocks start */
        -:  409:  struct sed_label *next;	/* linked list (stack) */
        -:  410:};
        -:  411:
        -:  412:struct special_files {
        -:  413:  char *name;
        -:  414:  FILE **pfp;
        -:  415:};
        -:  416:
        -:  417:FILE *my_stdin, *my_stdout, *my_stderr;
        -:  418:struct special_files special_files[] = {
        -:  419:  { "/dev/stdin", &my_stdin },
        -:  420:  { "/dev/stdout", &my_stdout },
        -:  421:  { "/dev/stdout", &my_stderr },
        -:  422:  { NULL, NULL }
        -:  423:};
        -:  424:
        -:  425:/* This structure tracks files opened by the `w' and `s///w' commands
        -:  426:   so that they may all be closed cleanly at normal program termination.
        -:  427:   Those marked as `special' are not closed. */
        -:  428:struct fp_list {
        -:  429:    char *name;
        -:  430:    int special;
        -:  431:    FILE *fp;
        -:  432:    struct fp_list *link;
        -:  433:  };
        -:  434:
        -:  435:
        -:  436:/* Where we are in the processing of the input. */
        -:  437:static struct prog_info prog;
        -:  438:static struct error_info cur_input;
        -:  439:
        -:  440:/* Information about labels and jumps-to-labels.  This is used to do
        -:  441:   the required backpatching after we have compiled all the scripts. */
        -:  442:static struct sed_label *jumps = NULL;
        -:  443:static struct sed_label *labels = NULL;
        -:  444:
        -:  445:/* We wish to detect #n magic only in the first input argument;
        -:  446:   this flag tracks when we have consumed the first file of input. */
        -:  447:static flagT first_script = TRUE;
        -:  448:
        -:  449:/* Allow for scripts like "sed -e 'i\' -e foo": */
        -:  450:static struct buffer *pending_text = NULL;
        -:  451:static struct text_buf *old_text_buf = NULL;
        -:  452:
        -:  453:/* Information about block start positions.  This is used to backpatch
        -:  454:   block end positions. */
        -:  455:static struct sed_label *blocks = NULL;
        -:  456:
        -:  457:/* Use an obstack for compilation. */
        -:  458:static struct obstack obs;
        -:  459:
        -:  460:/* Various error messages we may want to print */
        -:  461:static const char errors[] =
        -:  462:  "Multiple `!'s\0"
        -:  463:  "Unexpected `,'\0"
        -:  464:  "Cannot use +N or ~N as first address\0"
        -:  465:  "Unmatched `{'\0"
        -:  466:  "Unexpected `}'\0"
        -:  467:  "Extra characters after command\0"
        -:  468:  "Expected \\ after `a', `c' or `i'\0"
        -:  469:  "`}' doesn't want any addresses\0"
        -:  470:  ": doesn't want any addresses\0"
        -:  471:  "Comments don't accept any addresses\0"
        -:  472:  "Missing command\0"
        -:  473:  "Command only uses one address\0"
        -:  474:  "Unterminated address regex\0"
        -:  475:  "Unterminated `s' command\0"
        -:  476:  "Unterminated `y' command\0"
        -:  477:  "Unknown option to `s'\0"
        -:  478:  "multiple `p' options to `s' command\0"
        -:  479:  "multiple `g' options to `s' command\0"
        -:  480:  "multiple number options to `s' command\0"
        -:  481:  "number option to `s' command may not be zero\0"
        -:  482:  "strings for y command are different lengths\0"
        -:  483:  "expected newer version of sed";
        -:  484:
        -:  485:#define BAD_BANG (errors)
        -:  486:#define BAD_COMMA (BAD_BANG + sizeof(N_("Multiple `!'s")))
        -:  487:#define BAD_PLUS (BAD_COMMA + sizeof(N_("Unexpected `,'")))
        -:  488:#define EXCESS_OPEN_BRACE (BAD_PLUS + sizeof(N_("Cannot use +N or ~N as first address")))
        -:  489:#define EXCESS_CLOSE_BRACE (EXCESS_OPEN_BRACE + sizeof(N_("Unmatched `{'")))
        -:  490:#define EXCESS_JUNK (EXCESS_CLOSE_BRACE + sizeof(N_("Unexpected `}'")))
        -:  491:#define EXPECTED_SLASH (EXCESS_JUNK + sizeof(N_("Extra characters after command")))
        -:  492:#define NO_CLOSE_BRACE_ADDR (EXPECTED_SLASH + sizeof(N_("Expected \\ after `a', `c' or `i'")))
        -:  493:#define NO_COLON_ADDR (NO_CLOSE_BRACE_ADDR + sizeof(N_("`}' doesn't want any addresses")))
        -:  494:#define NO_SHARP_ADDR (NO_COLON_ADDR + sizeof(N_(": doesn't want any addresses")))
        -:  495:#define NO_COMMAND (NO_SHARP_ADDR + sizeof(N_("Comments don't accept any addresses")))
        -:  496:#define ONE_ADDR (NO_COMMAND + sizeof(N_("Missing command")))
        -:  497:#define UNTERM_ADDR_RE (ONE_ADDR + sizeof(N_("Command only uses one address")))
        -:  498:#define UNTERM_S_CMD (UNTERM_ADDR_RE + sizeof(N_("Unterminated address regex")))
        -:  499:#define UNTERM_Y_CMD (UNTERM_S_CMD + sizeof(N_("Unterminated `s' command")))
        -:  500:#define UNKNOWN_S_OPT (UNTERM_Y_CMD + sizeof(N_("Unterminated `y' command")))
        -:  501:#define EXCESS_P_OPT (UNKNOWN_S_OPT + sizeof(N_("Unknown option to `s'")))
        -:  502:#define EXCESS_G_OPT (EXCESS_P_OPT + sizeof(N_("multiple `p' options to `s' command")))
        -:  503:#define EXCESS_N_OPT (EXCESS_G_OPT + sizeof(N_("multiple `g' options to `s' command")))
        -:  504:#define ZERO_N_OPT (EXCESS_N_OPT + sizeof(N_("multiple number options to `s' command")))
        -:  505:#define Y_CMD_LEN (ZERO_N_OPT + sizeof(N_("number option to `s' command may not be zero")))
        -:  506:#define ANCIENT_VERSION (Y_CMD_LEN + sizeof(N_("strings for y command are different lengths")))
        -:  507:#define END_ERRORS (ANCIENT_VERSION + sizeof(N_("expected newer version of sed")))
        -:  508:
        -:  509:static struct fp_list *file_read = NULL;
        -:  510:static struct fp_list *file_write = NULL;
        -:  511:
        -:  512:
        -:  513:/* Read the next character from the program.  Return EOF if there isn't
        -:  514:   anything to read.  Keep cur_input.line up to date, so error messages
        -:  515:   can be meaningful. */
        -:  516:static int inchar P_((void));
        -:  517:static int
function inchar called 32614 returned 100% blocks executed 100%
    32614:  518:inchar()
        -:  519:{
    32614:  520:  int ch = EOF;
        -:  521:
    32614:  522:  if (prog.cur)
branch  0 taken 473 (fallthrough)
branch  1 taken 32141
        -:  523:    {
      473:  524:      if (prog.cur < prog.end)
branch  0 taken 420 (fallthrough)
branch  1 taken 53
      420:  525:	ch = *prog.cur++;
        -:  526:    }
    32141:  527:  else if (prog.file)
branch  0 taken 32141 (fallthrough)
branch  1 taken 0
        -:  528:    {
    32141:  529:      if (!feof(prog.file))
call    0 returned 32141
branch  1 taken 32141 (fallthrough)
branch  2 taken 0
    32141:  530:	ch = getc(prog.file);
call    0 returned 32141
        -:  531:    }
    32614:  532:  if (ch == '\n')
branch  0 taken 3307 (fallthrough)
branch  1 taken 29307
     3307:  533:    ++cur_input.line;
    32614:  534:  return ch;
        -:  535:}
        -:  536:
        -:  537:/* unget `ch' so the next call to inchar will return it.   */
        -:  538:static void savchar P_((int ch));
        -:  539:static void
function savchar called 572 returned 100% blocks executed 82%
      572:  540:savchar(ch)
        -:  541:  int ch;
        -:  542:{
      572:  543:  if (ch == EOF)
branch  0 taken 0 (fallthrough)
branch  1 taken 572
    #####:  544:    return;
      572:  545:  if (ch == '\n' && cur_input.line > 0)
branch  0 taken 13 (fallthrough)
branch  1 taken 559
branch  2 taken 13 (fallthrough)
branch  3 taken 0
       13:  546:    --cur_input.line;
      572:  547:  if (prog.cur)
branch  0 taken 11 (fallthrough)
branch  1 taken 561
        -:  548:    {
       11:  549:      if (prog.cur <= prog.base || *--prog.cur != ch)
branch  0 taken 11 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 11
    #####:  550:	panic(_("Called savchar() with unexpected pushback (%x)"),
    #####:  551:	      CAST(unsigned char)ch);
call    0 never executed
        -:  552:    }
        -:  553:  else
      561:  554:    ungetc(ch, prog.file);
call    0 returned 561
        -:  555:}
        -:  556:
        -:  557:/* Read the next non-blank character from the program.  */
        -:  558:static int in_nonblank P_((void));
        -:  559:static int
function in_nonblank called 3191 returned 100% blocks executed 100%
     3455:  560:in_nonblank()
        -:  561:{
        -:  562:  int ch;
        -:  563:  do
     3455:  564:    ch = inchar();
call    0 returned 3455
     3455:  565:    while (ISBLANK(ch));
branch  0 taken 262
branch  1 taken 3193 (fallthrough)
branch  2 taken 2
branch  3 taken 3191 (fallthrough)
     3191:  566:  return ch;
        -:  567:}
        -:  568:
        -:  569:/* Read an integer value from the program.  */
        -:  570:static countT in_integer P_((int ch));
        -:  571:static countT
function in_integer called 88 returned 100% blocks executed 100%
       88:  572:in_integer(ch)
        -:  573:  int ch;
        -:  574:{
       88:  575:  countT num = 0;
        -:  576:
      246:  577:  while (ISDIGIT(ch))
branch  0 taken 158
branch  1 taken 88 (fallthrough)
        -:  578:    {
      158:  579:      num = num * 10 + ch - '0';
      158:  580:      ch = inchar();
call    0 returned 158
        -:  581:    }
       88:  582:  savchar(ch);
call    0 returned 88
       88:  583:  return num;
        -:  584:}
        -:  585:
        -:  586:static int add_then_next P_((struct buffer *b, int ch));
        -:  587:static int
function add_then_next called 40 returned 100% blocks executed 100%
       40:  588:add_then_next(b, ch)
        -:  589:  struct buffer *b;
        -:  590:  int ch;
        -:  591:{
       40:  592:  add1_buffer(b, ch);
call    0 returned 40
       40:  593:  return inchar();
call    0 returned 40
        -:  594:}
        -:  595:
        -:  596:static char * convert_number P_((char *, char *, const char *, int, int, int));
        -:  597:static char *
function convert_number called 0 returned 0% blocks executed 0%
    #####:  598:convert_number(result, buf, bufend, base, maxdigits, default_char)
        -:  599:  char *result;
        -:  600:  char *buf;
        -:  601:  const char *bufend;
        -:  602:  int base;
        -:  603:  int maxdigits;
        -:  604:  int default_char;
        -:  605:{
    #####:  606:  int n = 0;
        -:  607:  char *p;
        -:  608:
    #####:  609:  for (p=buf; p < bufend && maxdigits-- > 0; ++p)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  610:    {
    #####:  611:      int d = -1;
    #####:  612:      switch (*p)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
        -:  613:	{
    #####:  614:	case '0': d = 0x0; break;
    #####:  615:	case '1': d = 0x1; break;
    #####:  616:	case '2': d = 0x2; break;
    #####:  617:	case '3': d = 0x3; break;
    #####:  618:	case '4': d = 0x4; break;
    #####:  619:	case '5': d = 0x5; break;
    #####:  620:	case '6': d = 0x6; break;
    #####:  621:	case '7': d = 0x7; break;
    #####:  622:	case '8': d = 0x8; break;
    #####:  623:	case '9': d = 0x9; break;
    #####:  624:	case 'A': case 'a': d = 0xa; break;
    #####:  625:	case 'B': case 'b': d = 0xb; break;
    #####:  626:	case 'C': case 'c': d = 0xc; break;
    #####:  627:	case 'D': case 'd': d = 0xd; break;
    #####:  628:	case 'E': case 'e': d = 0xe; break;
    #####:  629:	case 'F': case 'f': d = 0xf; break;
        -:  630:	}
    #####:  631:      if (d < 0 || base <= d)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  632:	break;
    #####:  633:      n = n * base + d;
        -:  634:    }
    #####:  635:  if (p == buf)
branch  0 never executed
branch  1 never executed
    #####:  636:    *result = default_char;
        -:  637:  else
    #####:  638:    *result = n;
    #####:  639:  return p;
        -:  640:}
        -:  641:
        -:  642:
        -:  643:/* Read in a filename for a `r', `w', or `s///w' command. */
        -:  644:static struct buffer *read_filename P_((void));
        -:  645:static struct buffer *
function read_filename called 231 returned 100% blocks executed 100%
      231:  646:read_filename()
        -:  647:{
        -:  648:  struct buffer *b;
        -:  649:  int ch;
        -:  650:
      231:  651:  b = init_buffer();
call    0 returned 231
      231:  652:  ch = in_nonblank();
call    0 returned 231
     3109:  653:  while (ch != EOF && ch != '\n')
branch  0 taken 3102 (fallthrough)
branch  1 taken 7
branch  2 taken 2878
branch  3 taken 224 (fallthrough)
        -:  654:    {
        -:  655:#if 0 /*XXX ZZZ 1998-09-12 kpp: added, then had second thoughts*/
        -:  656:      if (!POSIXLY_CORRECT)
        -:  657:	if (ch == ';' || ch == CLOSE_BRACE || ch == '#')
        -:  658:	  {
        -:  659:	    savchar(ch);
        -:  660:	    break;
        -:  661:	  }
        -:  662:#endif
     2878:  663:      add1_buffer(b, ch);
call    0 returned 2878
     2878:  664:      ch = inchar();
call    0 returned 2878
        -:  665:    }
      231:  666:  add1_buffer(b, '\0');
call    0 returned 231
      231:  667:  return b;
        -:  668:}
        -:  669:
        -:  670:static FILE *get_openfile P_((struct fp_list **file_ptrs, char *mode, flagT fail));
        -:  671:static FILE *
function get_openfile called 197 returned 100% blocks executed 81%
      197:  672:get_openfile(file_ptrs, mode, fail)
        -:  673:     struct fp_list **file_ptrs;
        -:  674:     char *mode;
        -:  675:     flagT fail;
        -:  676:{
        -:  677:  struct buffer *b;
        -:  678:  char *file_name;
        -:  679:  struct fp_list *p;
        -:  680:  int is_stderr;
        -:  681:
      197:  682:  b = read_filename();
call    0 returned 197
      197:  683:  file_name = get_buffer(b);
call    0 returned 197
      242:  684:  for (p=*file_ptrs; p; p=p->link)
branch  0 taken 45
branch  1 taken 197 (fallthrough)
       45:  685:    if (strcmp(p->name, file_name) == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 45
    #####:  686:      break;
        -:  687:
      197:  688:  if (!p)
branch  0 taken 197 (fallthrough)
branch  1 taken 0
        -:  689:    {
      197:  690:      FILE *fp = NULL;
      197:  691:      if (!POSIXLY_CORRECT)
branch  0 taken 197 (fallthrough)
branch  1 taken 0
        -:  692:	{
        -:  693:	  /* Check whether it is a special file (stdin, stdout or stderr) */
      197:  694:	  struct special_files *special = special_files;
        -:  695:		  
        -:  696:	  /* std* sometimes are not constants, so they
        -:  697:	     cannot be used in the initializer for special_files */
      197:  698:	  my_stdin = stdin; my_stdout = stdout; my_stderr = stderr;
      788:  699:	  for (special = special_files; special->name; special++)
branch  0 taken 591
branch  1 taken 197 (fallthrough)
      591:  700:	    if (strcmp(special->name, file_name) == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 591
        -:  701:	      {
    #####:  702:		fp = *special->pfp;
    #####:  703:		break;
        -:  704:	      }
        -:  705:	}
        -:  706:
     197*:  707:      p = OB_MALLOC(&obs, 1, struct fp_list);
branch  0 taken 0 (fallthrough)
branch  1 taken 197
call    2 never executed
branch  3 taken 0 (fallthrough)
branch  4 taken 197
branch  5 taken 0 (fallthrough)
branch  6 taken 197
      197:  708:      p->name = ck_strdup(file_name);
call    0 returned 197
      197:  709:      p->special = fp != NULL;
      197:  710:      if (!fp)
branch  0 taken 197 (fallthrough)
branch  1 taken 0
      197:  711:	fp = ck_fopen(p->name, mode, fail);
call    0 returned 197
      197:  712:      p->fp = fp;
      197:  713:      p->link = *file_ptrs;
      197:  714:      *file_ptrs = p;
        -:  715:    }
      197:  716:  free_buffer(b);
call    0 returned 197
      197:  717:  return p->fp;
        -:  718:}
        -:  719:
        -:  720:
        -:  721:static struct sed_cmd *next_cmd_entry P_((struct vector **vectorp));
        -:  722:static struct sed_cmd *
function next_cmd_entry called 2539 returned 100% blocks executed 100%
     2539:  723:next_cmd_entry(vectorp)
        -:  724:  struct vector **vectorp;
        -:  725:{
        -:  726:  struct sed_cmd *cmd;
        -:  727:  struct vector *v;
        -:  728:
     2539:  729:  v = *vectorp;
     2539:  730:  if (v->v_length == v->v_allocated)
branch  0 taken 365 (fallthrough)
branch  1 taken 2174
        -:  731:    {
      365:  732:      v->v_allocated += VECTOR_ALLOC_INCREMENT;
      365:  733:      v->v = REALLOC(v->v, v->v_allocated, struct sed_cmd);
call    0 returned 365
        -:  734:    }
        -:  735:
     2539:  736:  cmd = v->v + v->v_length;
     2539:  737:  cmd->a1 = NULL;
     2539:  738:  cmd->a2 = NULL;
     2539:  739:  cmd->a1_matched = FALSE;
     2539:  740:  cmd->addr_bang = FALSE;
     2539:  741:  cmd->cmd = '\0';	/* something invalid, to catch bugs early */
        -:  742:
     2539:  743:  *vectorp  = v;
     2539:  744:  return cmd;
        -:  745:}
        -:  746:
        -:  747:static int snarf_char_class P_((struct buffer *b));
        -:  748:static int
function snarf_char_class called 9 returned 100% blocks executed 37%
        9:  749:snarf_char_class(b)
        -:  750:  struct buffer *b;
        -:  751:{
        -:  752:  int ch;
        -:  753:
        9:  754:  ch = inchar();
call    0 returned 9
        9:  755:  if (ch == '^')
branch  0 taken 1 (fallthrough)
branch  1 taken 8
        1:  756:    ch = add_then_next(b, ch);
call    0 returned 1
        9:  757:  if (ch == CLOSE_BRACKET)
branch  0 taken 0 (fallthrough)
branch  1 taken 9
    #####:  758:    ch = add_then_next(b, ch);
call    0 never executed
       48:  759:  while (ch != EOF && ch != '\n' && ch != CLOSE_BRACKET)
branch  0 taken 48 (fallthrough)
branch  1 taken 0
branch  2 taken 48 (fallthrough)
branch  3 taken 0
branch  4 taken 39
branch  5 taken 9 (fallthrough)
        -:  760:    {
       39:  761:      if (ch == OPEN_BRACKET)
branch  0 taken 0 (fallthrough)
branch  1 taken 39
        -:  762:	{
        -:  763:	  int prev;
    #####:  764:	  int delim = ch = add_then_next(b, ch);
call    0 never executed
        -:  765:
    #####:  766:	  if (delim != '.'  &&  delim != ':'  &&  delim != '=')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  767:	    continue; /* bypass the add_then_next() call at bottom of loop */
    #####:  768:	  for (prev=ch=add_then_next(b, ch);
call    0 never executed
    #####:  769:		  !(ch==CLOSE_BRACKET && prev==delim); ch=add_then_next(b, ch))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  770:	    {
    #####:  771:	      if (ch == EOF || ch == '\n')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  772:		return ch;
    #####:  773:	      prev = ch;
call    0 never executed
        -:  774:	    }
        -:  775:	}
        -:  776:#ifndef REG_PERL
       39:  777:      else if (ch == '\\')
branch  0 taken 0 (fallthrough)
branch  1 taken 39
        -:  778:	{
    #####:  779:	  ch = inchar();
call    0 never executed
    #####:  780:	  if (ch == EOF)
branch  0 never executed
branch  1 never executed
    #####:  781:	    break;
    #####:  782:	  if (ch != 'n' && ch != '\n')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  783:	    {
    #####:  784:	      add1_buffer(b, '\\');
call    0 never executed
    #####:  785:	      continue; /* bypass the add_then_next() call at bottom of loop */
        -:  786:	    }
    #####:  787:	  ch = '\n';
        -:  788:	}
        -:  789:#endif
       39:  790:      ch = add_then_next(b, ch);
call    0 returned 39
        -:  791:    }
        -:  792:
        9:  793:  return ch;
        -:  794:}
        -:  795:
        -:  796:static struct buffer *match_slash P_((int slash, flagT regex, flagT keep_back));
        -:  797:static struct buffer *
function match_slash called 912 returned 100% blocks executed 81%
      912:  798:match_slash(slash, regex, keep_backwhack)
        -:  799:  int slash;
        -:  800:  flagT regex;
        -:  801:  flagT keep_backwhack;
        -:  802:{
        -:  803:  struct buffer *b;
        -:  804:  int ch;
        -:  805:
      912:  806:  b = init_buffer();
call    0 returned 912
     5406:  807:  while ((ch = inchar()) != EOF && ch != '\n' && ch != slash)
call    0 returned 5406
branch  1 taken 5406 (fallthrough)
branch  2 taken 0
branch  3 taken 5406 (fallthrough)
branch  4 taken 0
branch  5 taken 4494
branch  6 taken 912 (fallthrough)
        -:  808:    {
     4494:  809:      if (ch == '\\')
branch  0 taken 393 (fallthrough)
branch  1 taken 4101
        -:  810:	{
      393:  811:	  ch = inchar();
call    0 returned 393
      393:  812:	  if (ch == EOF)
branch  0 taken 0 (fallthrough)
branch  1 taken 393
    #####:  813:	    break;
        -:  814:#ifndef REG_PERL
      393:  815:	  else if (ch == 'n' && regex)
branch  0 taken 12 (fallthrough)
branch  1 taken 381
branch  2 taken 12 (fallthrough)
branch  3 taken 0
       12:  816:	    ch = '\n';
        -:  817:#endif
      381:  818:	  else if (ch != '\n' && (ch != slash || keep_backwhack))
branch  0 taken 381 (fallthrough)
branch  1 taken 0
branch  2 taken 4 (fallthrough)
branch  3 taken 377
branch  4 taken 4 (fallthrough)
branch  5 taken 0
      381:  819:	    add1_buffer(b, '\\');
call    0 returned 381
        -:  820:	}
     4101:  821:      else if (ch == OPEN_BRACKET && regex)
branch  0 taken 29 (fallthrough)
branch  1 taken 4072
branch  2 taken 9 (fallthrough)
branch  3 taken 20
        -:  822:	{
        9:  823:	  add1_buffer(b, ch);
call    0 returned 9
        9:  824:	  ch = snarf_char_class(b);
call    0 returned 9
        9:  825:	  if (ch != CLOSE_BRACKET)
branch  0 taken 0 (fallthrough)
branch  1 taken 9
    #####:  826:	    break;
        -:  827:	}
     4494:  828:      add1_buffer(b, ch);
call    0 returned 4494
        -:  829:    }
      912:  830:  if (ch == slash)
branch  0 taken 912 (fallthrough)
branch  1 taken 0
      912:  831:    return b;
        -:  832:
    #####:  833:  if (ch == '\n')
branch  0 never executed
branch  1 never executed
    #####:  834:    savchar(ch);	/* for proper line number in error report */
call    0 never executed
    #####:  835:  free_buffer(b);
call    0 never executed
    #####:  836:  return NULL;
        -:  837:}
        -:  838:
        -:  839:static flagT mark_subst_opts P_((struct subst *cmd));
        -:  840:static flagT
function mark_subst_opts called 245 returned 100% blocks executed 43%
      245:  841:mark_subst_opts(cmd)
        -:  842:  struct subst *cmd;
        -:  843:{
      245:  844:  int flags = 0;
        -:  845:  int ch;
        -:  846:
      245:  847:  cmd->global = FALSE;
      245:  848:  cmd->print = FALSE;
      245:  849:  cmd->eval = FALSE;
      245:  850:  cmd->numb = 0;
      245:  851:  cmd->fp = NULL;
        -:  852:
        -:  853:  for (;;)
      567:  854:    switch ( (ch = in_nonblank()) )
call    0 returned 567
branch  1 taken 0
branch  2 taken 0
branch  3 taken 0
branch  4 taken 112
branch  5 taken 210
branch  6 taken 152
branch  7 taken 0
branch  8 taken 0
branch  9 taken 93
branch 10 taken 0
branch 11 taken 0
        -:  855:      {
    #####:  856:      case 'i':	/* GNU extension */
        -:  857:      case 'I':	/* GNU extension */
    #####:  858:	flags |= REG_ICASE;
    #####:  859:	break;
        -:  860:
        -:  861:#ifdef REG_PERL
        -:  862:      case 's':	/* GNU extension */
        -:  863:      case 'S':	/* GNU extension */
        -:  864:	if (extended_regexp_flags & REG_PERL)
        -:  865:	  flags |= REG_DOTALL;
        -:  866:	break;
        -:  867:
        -:  868:      case 'x':	/* GNU extension */
        -:  869:      case 'X':	/* GNU extension */
        -:  870:	if (extended_regexp_flags & REG_PERL)
        -:  871:	  flags |= REG_EXTENDED;
        -:  872:	break;
        -:  873:#endif
        -:  874:
    #####:  875:      case 'm':	/* GNU extension */
        -:  876:      case 'M':	/* GNU extension */
    #####:  877:	flags |= REG_NEWLINE;
    #####:  878:	break;
        -:  879:
    #####:  880:      case 'e':
    #####:  881:	cmd->eval = TRUE;
    #####:  882:	break;
        -:  883:
      112:  884:      case 'p':
      112:  885:	if (cmd->print)
branch  0 taken 0 (fallthrough)
branch  1 taken 112
    #####:  886:	  bad_prog(_(EXCESS_P_OPT));
call    0 never executed
      112:  887:	cmd->print |= (TRUE << cmd->eval); /* 1=before eval, 2=after */
      112:  888:	break;
        -:  889:
      210:  890:      case 'g':
      210:  891:	if (cmd->global)
branch  0 taken 0 (fallthrough)
branch  1 taken 210
    #####:  892:	  bad_prog(_(EXCESS_G_OPT));
call    0 never executed
      210:  893:	cmd->global = TRUE;
      210:  894:	break;
        -:  895:
      152:  896:      case 'w':
      152:  897:	cmd->fp = get_openfile(&file_write, "w", TRUE);
call    0 returned 152
      152:  898:	return flags;
        -:  899:
    #####:  900:      case '0': case '1': case '2': case '3': case '4':
        -:  901:      case '5': case '6': case '7': case '8': case '9':
    #####:  902:	if (cmd->numb)
branch  0 never executed
branch  1 never executed
    #####:  903:	  bad_prog(_(EXCESS_N_OPT));
call    0 never executed
    #####:  904:	cmd->numb = in_integer(ch);
call    0 never executed
    #####:  905:	if (!cmd->numb)
branch  0 never executed
branch  1 never executed
    #####:  906:	  bad_prog(_(ZERO_N_OPT));
call    0 never executed
    #####:  907:	break;
        -:  908:
    #####:  909:      case CLOSE_BRACE:
        -:  910:      case '#':
    #####:  911:	savchar(ch);
call    0 never executed
        -:  912:	/* Fall Through */
       93:  913:      case EOF:
        -:  914:      case '\n':
        -:  915:      case ';':
       93:  916:	return flags;
        -:  917:
    #####:  918:      case '\r':
    #####:  919:	if (inchar() == '\n')
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  920:	  return flags;
        -:  921:	/* FALLTHROUGH */
        -:  922:
        -:  923:      default:
    #####:  924:	bad_prog(_(UNKNOWN_S_OPT));
call    0 never executed
        -:  925:	/*NOTREACHED*/
        -:  926:      }
        -:  927:}
        -:  928:
        -:  929:
        -:  930:/* read in a label for a `:', `b', or `t' command */
        -:  931:static char *read_label P_((void));
        -:  932:static char *
function read_label called 13 returned 100% blocks executed 100%
       13:  933:read_label()
        -:  934:{
        -:  935:  struct buffer *b;
        -:  936:  int ch;
        -:  937:  char *ret;
        -:  938:
       13:  939:  b = init_buffer();
call    0 returned 13
       13:  940:  ch = in_nonblank();
call    0 returned 13
        -:  941:
       53:  942:  while (ch != EOF && ch != '\n'
branch  0 taken 27 (fallthrough)
branch  1 taken 13
       67:  943:	 && !ISBLANK(ch) && ch != ';' && ch != CLOSE_BRACE && ch != '#')
branch  0 taken 40 (fallthrough)
branch  1 taken 0
branch  2 taken 27 (fallthrough)
branch  3 taken 0
branch  4 taken 27 (fallthrough)
branch  5 taken 0
branch  6 taken 27 (fallthrough)
branch  7 taken 0
branch  8 taken 27 (fallthrough)
branch  9 taken 0
branch 10 taken 27
branch 11 taken 0 (fallthrough)
        -:  944:    {
       27:  945:      add1_buffer(b, ch);
call    0 returned 27
       27:  946:      ch = inchar();
call    0 returned 27
        -:  947:    }
       13:  948:  savchar(ch);
call    0 returned 13
       13:  949:  add1_buffer(b, '\0');
call    0 returned 13
       13:  950:  ret = ck_strdup(get_buffer(b));
call    0 returned 13
call    1 returned 13
       13:  951:  free_buffer(b);
call    0 returned 13
       13:  952:  return ret;
        -:  953:}
        -:  954:
        -:  955:/* Store a label (or label reference) created by a `:', `b', or `t'
        -:  956:   command so that the jump to/from the label can be backpatched after
        -:  957:   compilation is complete, or a reference created by a `{' to be
        -:  958:   backpatched when the corresponding `}' is found.  */
        -:  959:static struct sed_label *setup_label
        -:  960:  P_((struct sed_label *, countT, char *, const struct error_info *));
        -:  961:static struct sed_label *
function setup_label called 343 returned 100% blocks executed 70%
      343:  962:setup_label(list, idx, name, err_info)
        -:  963:  struct sed_label *list;
        -:  964:  countT idx;
        -:  965:  char *name;
        -:  966:  const struct error_info *err_info;
        -:  967:{
     343*:  968:  struct sed_label *ret = OB_MALLOC(&obs, 1, struct sed_label);
branch  0 taken 0 (fallthrough)
branch  1 taken 343
call    2 never executed
branch  3 taken 0 (fallthrough)
branch  4 taken 343
branch  5 taken 0 (fallthrough)
branch  6 taken 343
      343:  969:  ret->v_index = idx;
      343:  970:  ret->name = name;
      343:  971:  if (err_info)
branch  0 taken 330 (fallthrough)
branch  1 taken 13
      330:  972:    MEMCPY(&ret->err_info, err_info, sizeof ret->err_info);
      343:  973:  ret->next = list;
      343:  974:  return ret;
        -:  975:}
        -:  976:
        -:  977:static struct sed_label *release_label P_((struct sed_label *list_head));
        -:  978:static struct sed_label *
function release_label called 342 returned 100% blocks executed 80%
      342:  979:release_label(list_head)
        -:  980:  struct sed_label *list_head;
        -:  981:{
        -:  982:  struct sed_label *ret;
        -:  983:
      342:  984:  if (!list_head)
branch  0 taken 0 (fallthrough)
branch  1 taken 342
    #####:  985:    return NULL;
      342:  986:  ret = list_head->next;
        -:  987:
      342:  988:  FREE(list_head->name);
call    0 returned 342
        -:  989:
        -:  990:#if 0
        -:  991:  /* We use obstacks */
        -:  992:  FREE(list_head);
        -:  993:#endif
      342:  994:  return ret;
        -:  995:}
        -:  996:
        -:  997:static struct replacement *new_replacement P_((char *, size_t,
        -:  998:					       enum replacement_types));
        -:  999:static struct replacement *
function new_replacement called 253 returned 100% blocks executed 62%
      253: 1000:new_replacement(text, length, type)
        -: 1001:  char *text;
        -: 1002:  size_t length;
        -: 1003:  enum replacement_types type;
        -: 1004:{
     253*: 1005:  struct replacement *r = OB_MALLOC(&obs, 1, struct replacement);
branch  0 taken 0 (fallthrough)
branch  1 taken 253
call    2 never executed
branch  3 taken 0 (fallthrough)
branch  4 taken 253
branch  5 taken 0 (fallthrough)
branch  6 taken 253
        -: 1006:
      253: 1007:  r->prefix = text;
      253: 1008:  r->prefix_length = length;
      253: 1009:  r->subst_id = -1;
      253: 1010:  r->repl_type = type;
        -: 1011:
        -: 1012:  /* r-> next = NULL; */
      253: 1013:  return r;
        -: 1014:}
        -: 1015:
        -: 1016:static void setup_replacement P_((struct subst *, const char *, size_t));
        -: 1017:static void
function setup_replacement called 245 returned 100% blocks executed 69%
      245: 1018:setup_replacement(sub, text, length)
        -: 1019:     struct subst *sub;
        -: 1020:     const char *text;
        -: 1021:     size_t length;
        -: 1022:{
        -: 1023:  char *base;
        -: 1024:  char *p;
        -: 1025:  char *text_end;
      245: 1026:  enum replacement_types repl_type = repl_asis, save_type = repl_asis;
        -: 1027:  struct replacement root;
        -: 1028:  struct replacement *tail;
        -: 1029:
      245: 1030:  sub->max_id = 0;
      245: 1031:  base = MEMDUP(text, length, char);
call    0 returned 245
      245: 1032:  length = normalize_text(base, length);
call    0 returned 245
        -: 1033:
      245: 1034:  text_end = base + length;
      245: 1035:  tail = &root;
        -: 1036:
     1770: 1037:  for (p=base; p<text_end; ++p)
branch  0 taken 1525
branch  1 taken 245 (fallthrough)
        -: 1038:    {
     1525: 1039:      if (*p == '\\')
branch  0 taken 42 (fallthrough)
branch  1 taken 1483
        -: 1040:	{
        -: 1041:	  /* Preceding the backslash may be some literal text: */
       42: 1042:	  tail = tail->next =
       42: 1043:	    new_replacement(base, CAST(size_t)(p - base), repl_type);
call    0 returned 42
        -: 1044:
       42: 1045:	  repl_type = save_type;
        -: 1046:
        -: 1047:	  /* Skip the backslash and look for a numeric back-reference: */
       42: 1048:	  ++p;
       42: 1049:	  if (p<text_end)
branch  0 taken 42 (fallthrough)
branch  1 taken 0
       42: 1050:	    switch (*p)
branch  0 taken 0
branch  1 taken 0
branch  2 taken 0
branch  3 taken 0
branch  4 taken 0
branch  5 taken 0
branch  6 taken 42
        -: 1051:	      {
    #####: 1052:	      case '0': case '1': case '2': case '3': case '4': 
        -: 1053:	      case '5': case '6': case '7': case '8': case '9': 
    #####: 1054:		tail->subst_id = *p - '0';
    #####: 1055:		if (sub->max_id < tail->subst_id)
branch  0 never executed
branch  1 never executed
    #####: 1056:		  sub->max_id = tail->subst_id;
    #####: 1057:		break;
        -: 1058:
    #####: 1059:	      case 'L':
    #####: 1060:		repl_type = repl_lowercase;
    #####: 1061:		save_type = repl_lowercase;
    #####: 1062:		break;
        -: 1063:
    #####: 1064:	      case 'U':
    #####: 1065:		repl_type = repl_uppercase;
    #####: 1066:		save_type = repl_uppercase;
    #####: 1067:		break;
        -: 1068:		
    #####: 1069:	      case 'E':
    #####: 1070:		repl_type = repl_asis;
    #####: 1071:		save_type = repl_asis;
    #####: 1072:		break;
        -: 1073:
    #####: 1074:	      case 'l':
    #####: 1075:		save_type = repl_type;
    #####: 1076:		repl_type |= repl_lowercase_first;
    #####: 1077:		break;
        -: 1078:
    #####: 1079:	      case 'u':
    #####: 1080:		save_type = repl_type;
    #####: 1081:		repl_type |= repl_uppercase_first;
    #####: 1082:		break;
        -: 1083:		
       42: 1084:	      default:
       42: 1085:		p[-1] = *p;
       42: 1086:		++tail->prefix_length;
        -: 1087:	      }
        -: 1088:
       42: 1089:	  base = p + 1;
        -: 1090:	}
     1483: 1091:      else if (*p == '&')
branch  0 taken 17 (fallthrough)
branch  1 taken 1466
        -: 1092:	{
        -: 1093:	  /* Preceding the ampersand may be some literal text: */
       17: 1094:	  tail = tail->next =
       17: 1095:	    new_replacement(base, CAST(size_t)(p - base), repl_type);
call    0 returned 17
        -: 1096:
       17: 1097:	  repl_type = save_type;
       17: 1098:	  tail->subst_id = 0;
       17: 1099:	  base = p + 1;
        -: 1100:	}
        -: 1101:  }
        -: 1102:  /* There may be some trailing literal text: */
      245: 1103:  if (base < text_end)
branch  0 taken 194 (fallthrough)
branch  1 taken 51
      194: 1104:    tail = tail->next =
      194: 1105:      new_replacement(base, CAST(size_t)(text_end - base), repl_type);
call    0 returned 194
        -: 1106:
      245: 1107:  tail->next = NULL;
      245: 1108:  sub->replacement = root.next;
      245: 1109:}
        -: 1110:
        -: 1111:static void read_text P_((struct text_buf *buf, int leadin_ch));
        -: 1112:static void
function read_text called 106 returned 100% blocks executed 79%
      106: 1113:read_text(buf, leadin_ch)
        -: 1114:  struct text_buf *buf;
        -: 1115:  int leadin_ch;
        -: 1116:{
        -: 1117:  int ch;
        -: 1118:
        -: 1119:  /* Should we start afresh (as opposed to continue a partial text)? */
      106: 1120:  if (buf)
branch  0 taken 106 (fallthrough)
branch  1 taken 0
        -: 1121:    {
      106: 1122:      if (pending_text)
branch  0 taken 0 (fallthrough)
branch  1 taken 106
    #####: 1123:	free_buffer(pending_text);
call    0 never executed
      106: 1124:      pending_text = init_buffer();
call    0 returned 106
      106: 1125:      buf->text = NULL;
      106: 1126:      buf->text_length = 0;
      106: 1127:      old_text_buf = buf;
        -: 1128:    }
        -: 1129:  /* assert(old_text_buf != NULL); */
        -: 1130:
      106: 1131:  if (leadin_ch == EOF)
branch  0 taken 0 (fallthrough)
branch  1 taken 106
    #####: 1132:    return;
        -: 1133:#ifndef NO_INPUT_INDENT
      106: 1134:  if (leadin_ch != '\n')
branch  0 taken 0 (fallthrough)
branch  1 taken 106
    #####: 1135:    add1_buffer(pending_text, leadin_ch);
call    0 never executed
      106: 1136:  ch = inchar();
call    0 returned 106
        -: 1137:#else /*NO_INPUT_INDENT*/
        -: 1138:  if (leadin_ch == '\n')
        -: 1139:    ch = in_nonblank();
        -: 1140:  else
        -: 1141:    {
        -: 1142:      add1_buffer(pending_text, leadin_ch);
        -: 1143:      ch = inchar();
        -: 1144:    }
        -: 1145:#endif /*NO_INPUT_INDENT*/
        -: 1146:
     2629: 1147:  while (ch!=EOF && ch!='\n')
branch  0 taken 2629 (fallthrough)
branch  1 taken 0
branch  2 taken 2523
branch  3 taken 106 (fallthrough)
        -: 1148:    {
     2523: 1149:      if (ch == '\\')
branch  0 taken 14 (fallthrough)
branch  1 taken 2509
       14: 1150:	ch = inchar();
call    0 returned 14
     2523: 1151:      if (ch == EOF)
branch  0 taken 0 (fallthrough)
branch  1 taken 2523
        -: 1152:	{
    #####: 1153:	  add1_buffer(pending_text, '\n');
call    0 never executed
    #####: 1154:	  return;
        -: 1155:	}
     2523: 1156:      add1_buffer(pending_text, ch);
call    0 returned 2523
        -: 1157:#ifdef NO_INPUT_INDENT
        -: 1158:      if (ch == '\n')
        -: 1159:	ch = in_nonblank();
        -: 1160:      else
        -: 1161:#endif /*NO_INPUT_INDENT*/
     2523: 1162:	ch = inchar();
call    0 returned 2523
        -: 1163:    }
      106: 1164:  add1_buffer(pending_text, '\n');
call    0 returned 106
        -: 1165:
      106: 1166:  if (!buf)
branch  0 taken 0 (fallthrough)
branch  1 taken 106
    #####: 1167:    buf = old_text_buf;
      106: 1168:  buf->text_length = size_buffer(pending_text);
call    0 returned 106
      106: 1169:  buf->text = MEMDUP(get_buffer(pending_text), buf->text_length, char);
call    0 returned 106
call    1 returned 106
      106: 1170:  free_buffer(pending_text);
call    0 returned 106
      106: 1171:  pending_text = NULL;
        -: 1172:}
        -: 1173:
        -: 1174:
        -: 1175:/* Try to read an address for a sed command.  If it succeeds,
        -: 1176:   return non-zero and store the resulting address in `*addr'.
        -: 1177:   If the input doesn't look like an address read nothing
        -: 1178:   and return zero.  */
        -: 1179:static flagT compile_address P_((struct addr *addr, int ch));
        -: 1180:static flagT
function compile_address called 2584 returned 100% blocks executed 60%
     2584: 1181:compile_address(addr, ch)
        -: 1182:  struct addr *addr;
        -: 1183:  int ch;
        -: 1184:{
     2584: 1185:  addr->addr_type = addr_is_null;
     2584: 1186:  addr->addr_step = 0;
     2584: 1187:  addr->addr_number = ~(countT)0;  /* extremely unlikely to ever match */
     2584: 1188:  addr->addr_regex = NULL;
        -: 1189:
     2584: 1190:  if (ch == '/' || ch == '\\')
branch  0 taken 2201 (fallthrough)
branch  1 taken 383
branch  2 taken 0 (fallthrough)
branch  3 taken 2201
        -: 1191:    {
      383: 1192:      int flags = 0;
        -: 1193:      struct buffer *b;
      383: 1194:      addr->addr_type = addr_is_regex;
      383: 1195:      if (ch == '\\')
branch  0 taken 0 (fallthrough)
branch  1 taken 383
    #####: 1196:	ch = inchar();
call    0 never executed
      383: 1197:      if ( !(b = match_slash(ch, TRUE, TRUE)) )
call    0 returned 383
branch  1 taken 0 (fallthrough)
branch  2 taken 383
    #####: 1198:	bad_prog(_(UNTERM_ADDR_RE));
call    0 never executed
        -: 1199:
        -: 1200:      for(;;)
        -: 1201:	{
     383*: 1202:	  ch = in_nonblank();
call    0 returned 383
      383: 1203:          switch(ch)
branch  0 taken 0
branch  1 taken 0
branch  2 taken 383
        -: 1204:	    {
    #####: 1205:	    case 'I':	/* GNU extension */
    #####: 1206:	      flags |= REG_ICASE;
    #####: 1207:	      break;
        -: 1208:
        -: 1209:#ifdef REG_PERL
        -: 1210:	    case 'S':	/* GNU extension */
        -: 1211:	      if (extended_regexp_flags & REG_PERL)
        -: 1212:		flags |= REG_DOTALL;
        -: 1213:	      break;
        -: 1214:
        -: 1215:	    case 'X':	/* GNU extension */
        -: 1216:	      if (extended_regexp_flags & REG_PERL)
        -: 1217:		flags |= REG_EXTENDED;
        -: 1218:	      break;
        -: 1219:#endif
        -: 1220:
    #####: 1221:	    case 'M':	/* GNU extension */
    #####: 1222:	      flags |= REG_NEWLINE;
    #####: 1223:	      break;
        -: 1224:
      383: 1225:	    default:
      383: 1226:	      savchar (ch);
call    0 returned 383
      383: 1227:	      addr->addr_regex = compile_regex (b, flags, 0);
call    0 returned 383
      383: 1228:	      free_buffer(b);
call    0 returned 383
      383: 1229:	      return TRUE;
        -: 1230:	    }
        -: 1231:	}
        -: 1232:    }
     2201: 1233:  else if (ISDIGIT(ch))
branch  0 taken 88 (fallthrough)
branch  1 taken 2113
        -: 1234:    {
       88: 1235:      addr->addr_number = in_integer(ch);
call    0 returned 88
       88: 1236:      addr->addr_type = addr_is_num;
       88: 1237:      ch = in_nonblank();
call    0 returned 88
       88: 1238:      if (ch != '~')
branch  0 taken 88 (fallthrough)
branch  1 taken 0
        -: 1239:	{
       88: 1240:	  savchar(ch);
call    0 returned 88
        -: 1241:	}
        -: 1242:      else
        -: 1243:	{
    #####: 1244:	  countT step = in_integer(in_nonblank());
call    0 never executed
call    1 never executed
    #####: 1245:	  if (step > 0)
branch  0 never executed
branch  1 never executed
        -: 1246:	    {
    #####: 1247:	      addr->addr_step = step;
    #####: 1248:	      addr->addr_type = addr_is_num_mod;
        -: 1249:	    }
        -: 1250:	}
        -: 1251:    }
     2113: 1252:  else if (ch == '+' || ch == '~')
branch  0 taken 2113 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 2113
        -: 1253:    {
    #####: 1254:      addr->addr_step = in_integer(in_nonblank());
call    0 never executed
call    1 never executed
    #####: 1255:      if (addr->addr_step==0)
branch  0 never executed
branch  1 never executed
        -: 1256:	; /* default to addr_is_null; forces matching to stop on next line */
    #####: 1257:      else if (ch == '+')
branch  0 never executed
branch  1 never executed
    #####: 1258:	addr->addr_type = addr_is_step;
        -: 1259:      else
    #####: 1260:	addr->addr_type = addr_is_step_mod;
        -: 1261:    }
     2113: 1262:  else if (ch == '$')
branch  0 taken 13 (fallthrough)
branch  1 taken 2100
        -: 1263:    {
       13: 1264:      addr->addr_type = addr_is_last;
        -: 1265:    }
        -: 1266:  else
     2100: 1267:    return FALSE;
        -: 1268:
      101: 1269:  return TRUE;
        -: 1270:}
        -: 1271:
        -: 1272:/* Read a program (or a subprogram within `{' `}' pairs) in and store
        -: 1273:   the compiled form in `*vector'.  Return a pointer to the new vector.  */
        -: 1274:static struct vector *compile_program P_((struct vector *));
        -: 1275:static struct vector *
function compile_program called 369 returned 99% blocks executed 72%
      369: 1276:compile_program(vector)
        -: 1277:  struct vector *vector;
        -: 1278:{
        -: 1279:  struct sed_cmd *cur_cmd;
        -: 1280:  struct buffer *b;
        -: 1281:  int ch;
        -: 1282:
      369: 1283:  if (!vector)
branch  0 taken 366 (fallthrough)
branch  1 taken 3
        -: 1284:    {
      366: 1285:      vector = MALLOC(1, struct vector);
call    0 returned 366
      366: 1286:      vector->v = NULL;
      366: 1287:      vector->v_allocated = 0;
      366: 1288:      vector->v_length = 0;
        -: 1289:
      366: 1290:      obstack_init (&obs);
call    0 returned 366
        -: 1291:    }
      369: 1292:  if (pending_text)
branch  0 taken 0 (fallthrough)
branch  1 taken 369
    #####: 1293:    read_text(NULL, '\n');
call    0 never executed
        -: 1294:
        -: 1295:  for (;;)
     2534: 1296:    {
        -: 1297:      struct addr a;
        -: 1298:
    10609: 1299:      while ((ch=inchar()) == ';' || ISSPACE(ch))
call    0 returned 10609
branch  1 taken 0
branch  2 taken 10609 (fallthrough)
branch  3 taken 7706
branch  4 taken 2903 (fallthrough)
        -: 1300:	;
     2903: 1301:      if (ch == EOF)
branch  0 taken 364 (fallthrough)
branch  1 taken 2539
      364: 1302:	break;
        -: 1303:
     2539: 1304:      cur_cmd = next_cmd_entry(&vector);
call    0 returned 2539
     2539: 1305:      if (compile_address(&a, ch))
call    0 returned 2539
branch  1 taken 439 (fallthrough)
branch  2 taken 2100
        -: 1306:	{
      439: 1307:	  if (a.addr_type == addr_is_step
branch  0 taken 439 (fallthrough)
branch  1 taken 0
      439: 1308:	      || a.addr_type == addr_is_step_mod)
branch  0 taken 0 (fallthrough)
branch  1 taken 439
    #####: 1309:	    bad_prog(_(BAD_PLUS));
call    0 never executed
        -: 1310:
      439: 1311:	  cur_cmd->a1 = MEMDUP(&a, 1, struct addr);
call    0 returned 439
      439: 1312:	  ch = in_nonblank();
call    0 returned 439
      439: 1313:	  if (ch == ',')
branch  0 taken 45 (fallthrough)
branch  1 taken 394
        -: 1314:	    {
       45: 1315:	      if (!compile_address(&a, in_nonblank()))
call    0 returned 45
call    1 returned 45
branch  2 taken 0 (fallthrough)
branch  3 taken 45
    #####: 1316:		bad_prog(_(BAD_COMMA));
call    0 never executed
       45: 1317:	      if (a.addr_type == addr_is_num)
branch  0 taken 21 (fallthrough)
branch  1 taken 24
       21: 1318:		a.addr_type = addr_is_num2;
       45: 1319:	      cur_cmd->a2 = MEMDUP(&a, 1, struct addr);
call    0 returned 45
       45: 1320:	      ch = in_nonblank();
call    0 returned 45
       45: 1321:	      if ((cur_cmd->a1->addr_type == addr_is_num
branch  0 taken 19 (fallthrough)
branch  1 taken 26
       19: 1322:		   || cur_cmd->a1->addr_type == addr_is_num_mod)
branch  0 taken 0 (fallthrough)
branch  1 taken 19
       26: 1323:	      	  && cur_cmd->a1->addr_number == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 26
    #####: 1324:		cur_cmd->a1_matched = TRUE;
        -: 1325:	    }
        -: 1326:	}
     2539: 1327:      if (ch == '!')
branch  0 taken 20 (fallthrough)
branch  1 taken 2519
        -: 1328:	{
       20: 1329:	  cur_cmd->addr_bang = TRUE;
       20: 1330:	  ch = in_nonblank();
call    0 returned 20
       20: 1331:	  if (ch == '!')
branch  0 taken 0 (fallthrough)
branch  1 taken 20
    #####: 1332:	    bad_prog(_(BAD_BANG));
call    0 never executed
        -: 1333:	}
        -: 1334:
     2539: 1335:      cur_cmd->cmd = ch;
    2539*: 1336:      switch (ch)
branch  0 taken 507
branch  1 taken 0
branch  2 taken 330
branch  3 taken 329
branch  4 taken 0
branch  5 taken 70
branch  6 taken 36
branch  7 taken 4
branch  8 taken 9
branch  9 taken 35
branch 10 taken 40
branch 11 taken 2
branch 12 taken 809
branch 13 taken 34
branch 14 taken 0
branch 15 taken 45
branch 16 taken 245
branch 17 taken 39
branch 18 taken 0
branch 19 taken 5
        -: 1337:	{
      507: 1338:	case '#':
      507: 1339:	  if (cur_cmd->a1)
branch  0 taken 0 (fallthrough)
branch  1 taken 507
    #####: 1340:	    bad_prog(_(NO_SHARP_ADDR));
call    0 never executed
      507: 1341:	  ch = inchar();
call    0 returned 507
      507: 1342:	  if (ch=='n' && first_script && cur_input.line < 2)
branch  0 taken 211 (fallthrough)
branch  1 taken 296
branch  2 taken 211 (fallthrough)
branch  3 taken 0
branch  4 taken 211 (fallthrough)
branch  5 taken 0
     211*: 1343:	    if (   (prog.base && prog.cur==2+prog.base)
branch  0 taken 0 (fallthrough)
branch  1 taken 211
branch  2 never executed
branch  3 never executed
      211: 1344:		|| (prog.file && !prog.base && 2==ftell(prog.file)))
branch  0 taken 211 (fallthrough)
branch  1 taken 0
branch  2 taken 211 (fallthrough)
branch  3 taken 0
call    4 returned 211
branch  5 taken 211 (fallthrough)
branch  6 taken 0
      211: 1345:	      no_default_output = TRUE;
     6278: 1346:	  while (ch != EOF && ch != '\n')
branch  0 taken 6278 (fallthrough)
branch  1 taken 0
branch  2 taken 5771
branch  3 taken 507 (fallthrough)
     5771: 1347:	    ch = inchar();
call    0 returned 5771
      507: 1348:	  continue;	/* restart the for (;;) loop */
        -: 1349:
    #####: 1350:	case 'v':
        -: 1351:          /* This is an extension.  Programs needing GNU sed might start
        -: 1352:           * with a `v' command so that other seds will stop.
        -: 1353:           * We compare the version ignore it.
        -: 1354:           */
        -: 1355:          {
    #####: 1356:            char *version = read_label ();
call    0 never executed
        -: 1357:            char *compared_version;
    #####: 1358:            compared_version = (*version == '\0') ? "4.0" : version;
branch  0 never executed
branch  1 never executed
        -: 1359:	    
        -: 1360:	    /*
        -: 1361:	      Removed by Kyle R. Murphy July 2006 for SIR compatability
        -: 1362:            if (strverscmp (compared_version, SED_FEATURE_VERSION) > 0)
        -: 1363:              bad_prog(_(ANCIENT_VERSION));
        -: 1364:	    */
    #####: 1365:            free (version);
    #####: 1366:	    POSIXLY_CORRECT = 0;
        -: 1367:          }
    #####: 1368:	  continue;
        -: 1369:
      330: 1370:	case '{':
      330: 1371:	  blocks = setup_label(blocks, vector->v_length, NULL, &cur_input);
call    0 returned 330
      330: 1372:	  cur_cmd->addr_bang = !cur_cmd->addr_bang;
      330: 1373:	  break;
        -: 1374:
      329: 1375:	case '}':
      329: 1376:	  if (!blocks)
branch  0 taken 0 (fallthrough)
branch  1 taken 329
    #####: 1377:	    bad_prog(_(EXCESS_CLOSE_BRACE));
call    0 never executed
      329: 1378:	  if (cur_cmd->a1)
branch  0 taken 0 (fallthrough)
branch  1 taken 329
    #####: 1379:	    bad_prog(_(NO_CLOSE_BRACE_ADDR));
call    0 never executed
      329: 1380:	  ch = in_nonblank();
call    0 returned 329
      329: 1381:	  if (ch == CLOSE_BRACE || ch == '#')
branch  0 taken 329 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 329
    #####: 1382:	    savchar(ch);
call    0 never executed
     329*: 1383:	  else if (ch != EOF && ch != '\n' && ch != ';')
branch  0 taken 329 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 329
branch  4 never executed
branch  5 never executed
    #####: 1384:	    bad_prog(_(EXCESS_JUNK));
call    0 never executed
        -: 1385:
      329: 1386:	  vector->v[blocks->v_index].x.jump_index = vector->v_length;
      329: 1387:	  blocks = release_label(blocks);	/* done with this entry */
call    0 returned 329
      329: 1388:	  break;
        -: 1389:
    #####: 1390:	case 'e':
    #####: 1391:	  ch = in_nonblank();
call    0 never executed
    #####: 1392:	  if (ch == EOF || ch == '\n')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1393:	    {
    #####: 1394:	      cur_cmd->x.cmd_txt.text_length = 0;
    #####: 1395:	      break;
        -: 1396:	    }
        -: 1397:	  else
    #####: 1398:	    goto read_text_to_slash;
        -: 1399:
       70: 1400:	case 'a':
        -: 1401:	case 'i':
      70*: 1402:	  if (POSIXLY_CORRECT && cur_cmd->a2)
branch  0 taken 0 (fallthrough)
branch  1 taken 70
branch  2 never executed
branch  3 never executed
    #####: 1403:	    bad_prog(_(ONE_ADDR));
call    0 never executed
        -: 1404:	  /* Fall Through */
        -: 1405:
        -: 1406:	case 'c':
      106: 1407:	  ch = in_nonblank();
call    0 returned 106
        -: 1408:
      106: 1409:	read_text_to_slash:
      106: 1410:	  if (ch == EOF)
branch  0 taken 0 (fallthrough)
branch  1 taken 106
    #####: 1411:	    bad_prog(_(EXPECTED_SLASH));
call    0 never executed
        -: 1412:	      
      106: 1413:	  if (ch == '\\')
branch  0 taken 106 (fallthrough)
branch  1 taken 0
      106: 1414:	    ch = inchar();
call    0 returned 106
        -: 1415:	  else
        -: 1416:	    {
    #####: 1417:	      savchar(ch);
call    0 never executed
    #####: 1418:	      ch = '\n';
        -: 1419:	    }
        -: 1420:
      106: 1421:	  read_text(&cur_cmd->x.cmd_txt, ch);
call    0 returned 106
      106: 1422:	  break;
        -: 1423:
        4: 1424:	case ':':
        4: 1425:	  if (cur_cmd->a1)
branch  0 taken 0 (fallthrough)
branch  1 taken 4
    #####: 1426:	    bad_prog(_(NO_COLON_ADDR));
call    0 never executed
        4: 1427:	  labels = setup_label(labels, vector->v_length, read_label(), NULL);
call    0 returned 4
call    1 returned 4
        4: 1428:	  break;
        -: 1429:	
        9: 1430:	case 'b':
        -: 1431:	case 't':
        -: 1432:	case 'T':
        9: 1433:	  jumps = setup_label(jumps, vector->v_length, read_label(), NULL);
call    0 returned 9
call    1 returned 9
        9: 1434:	  break;
        -: 1435:
       35: 1436:	case 'q':
        -: 1437:	case 'Q':
       35: 1438:	  if (cur_cmd->a2)
branch  0 taken 0 (fallthrough)
branch  1 taken 35
    #####: 1439:	    bad_prog(_(ONE_ADDR));
call    0 never executed
        -: 1440:	  /* Fall through */
        -: 1441:
        -: 1442:	case 'l':
        -: 1443:	case 'L':
      75*: 1444:	  if (POSIXLY_CORRECT && cur_cmd->a2)
branch  0 taken 0 (fallthrough)
branch  1 taken 75
branch  2 never executed
branch  3 never executed
    #####: 1445:	    bad_prog(_(ONE_ADDR));
call    0 never executed
        -: 1446:
       75: 1447:	  ch = in_nonblank();
call    0 returned 75
       75: 1448:	  if (ISDIGIT(ch)) 
branch  0 taken 0 (fallthrough)
branch  1 taken 75
        -: 1449:	    {
    #####: 1450:	      cur_cmd->x.int_arg = in_integer(ch);
call    0 never executed
    #####: 1451:	      ch = in_nonblank();
call    0 never executed
        -: 1452:	    }
        -: 1453:	  else
       75: 1454:	    cur_cmd->x.int_arg = -1;
        -: 1455:
       75: 1456:	  if (ch == CLOSE_BRACE || ch == '#')
branch  0 taken 75 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 75
    #####: 1457:	    savchar(ch);
call    0 never executed
       75: 1458:	  else if (ch != EOF && ch != '\n' && ch != ';')
branch  0 taken 73 (fallthrough)
branch  1 taken 2
branch  2 taken 4 (fallthrough)
branch  3 taken 69
branch  4 taken 0 (fallthrough)
branch  5 taken 4
    #####: 1459:	    bad_prog(_(EXCESS_JUNK));
call    0 never executed
        -: 1460:
       75: 1461:	  break;
        -: 1462:
        2: 1463:	case '=':
       2*: 1464:	  if (POSIXLY_CORRECT && cur_cmd->a2)
branch  0 taken 0 (fallthrough)
branch  1 taken 2
branch  2 never executed
branch  3 never executed
    #####: 1465:	    bad_prog(_(ONE_ADDR));
call    0 never executed
        -: 1466:	  /* Fall Through */
        -: 1467:	case 'd':
        -: 1468:	case 'D':
        -: 1469:	case 'g':
        -: 1470:	case 'G':
        -: 1471:	case 'h':
        -: 1472:	case 'H':
        -: 1473:	case 'n':
        -: 1474:	case 'N':
        -: 1475:	case 'p':
        -: 1476:	case 'P':
        -: 1477:	case 'x':
      811: 1478:	  ch = in_nonblank();
call    0 returned 811
      811: 1479:	  if (ch == CLOSE_BRACE || ch == '#')
branch  0 taken 811 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 811
    #####: 1480:	    savchar(ch);
call    0 never executed
      811: 1481:	  else if (ch != EOF && ch != '\n' && ch != ';')
branch  0 taken 806 (fallthrough)
branch  1 taken 5
branch  2 taken 73 (fallthrough)
branch  3 taken 733
branch  4 taken 0 (fallthrough)
branch  5 taken 73
    #####: 1482:	    bad_prog(_(EXCESS_JUNK));
call    0 never executed
      811: 1483:	  break;
        -: 1484:
       34: 1485:	case 'r':
      34*: 1486:	  if (POSIXLY_CORRECT && cur_cmd->a2)
branch  0 taken 0 (fallthrough)
branch  1 taken 34
branch  2 never executed
branch  3 never executed
    #####: 1487:	    bad_prog(_(ONE_ADDR));
call    0 never executed
       34: 1488:	  b = read_filename();
call    0 returned 34
       34: 1489:	  cur_cmd->x.fname = ck_strdup(get_buffer(b));
call    0 returned 34
call    1 returned 34
       34: 1490:	  free_buffer(b);
call    0 returned 34
       34: 1491:	  break;
        -: 1492:
    #####: 1493:        case 'R':
    #####: 1494:	  cur_cmd->x.fp = get_openfile(&file_read, "r", FALSE);
call    0 never executed
    #####: 1495:	  break;
        -: 1496:
       45: 1497:	case 'w':
        -: 1498:        case 'W':
       45: 1499:	  cur_cmd->x.fp = get_openfile(&file_write, "w", TRUE);
call    0 returned 45
       45: 1500:	  break;
        -: 1501:
      245: 1502:	case 's':
        -: 1503:	  {
        -: 1504:	    struct buffer *b2;
        -: 1505:	    int flags;
        -: 1506:	    int slash;
        -: 1507:
      245: 1508:	    slash = inchar();
call    0 returned 245
      245: 1509:	    if ( !(b  = match_slash(slash, TRUE, TRUE)) )
call    0 returned 245
branch  1 taken 0 (fallthrough)
branch  2 taken 245
    #####: 1510:	      bad_prog(_(UNTERM_S_CMD));
call    0 never executed
      245: 1511:	    if ( !(b2 = match_slash(slash, FALSE, TRUE)) )
call    0 returned 245
branch  1 taken 0 (fallthrough)
branch  2 taken 245
    #####: 1512:	      bad_prog(_(UNTERM_S_CMD));
call    0 never executed
        -: 1513:
     245*: 1514:	    cur_cmd->x.cmd_subst = OB_MALLOC(&obs, 1, struct subst);
branch  0 taken 0 (fallthrough)
branch  1 taken 245
call    2 never executed
branch  3 taken 0 (fallthrough)
branch  4 taken 245
branch  5 taken 0 (fallthrough)
branch  6 taken 245
      490: 1515:	    setup_replacement(cur_cmd->x.cmd_subst,
call    0 returned 245
call    1 returned 245
      245: 1516:			      get_buffer(b2), size_buffer(b2));
call    0 returned 245
      245: 1517:	    free_buffer(b2);
call    0 returned 245
        -: 1518:
      245: 1519:	    flags = mark_subst_opts(cur_cmd->x.cmd_subst);
call    0 returned 245
      490: 1520:	    cur_cmd->x.cmd_subst->regx =
      245: 1521:	      compile_regex(b, flags, cur_cmd->x.cmd_subst->max_id);
call    0 returned 245
      245: 1522:	    free_buffer(b);
call    0 returned 245
        -: 1523:	  }
      245: 1524:	  break;
        -: 1525:
       39: 1526:	case 'y':
        -: 1527:	  {
        -: 1528:	    unsigned char *ustring;
        -: 1529:	    size_t len;
        -: 1530:	    int slash;
        -: 1531:
        -: 1532:#if defined MBS_SUPPORT && !defined (REG_PERL)
        -: 1533:	    if (MB_CUR_MAX == 1)
        -: 1534:#endif
        -: 1535:	      {
      39*: 1536:	        ustring = OB_MALLOC(&obs, YMAP_LENGTH, unsigned char);
branch  0 taken 0 (fallthrough)
branch  1 taken 39
call    2 never executed
branch  3 taken 0 (fallthrough)
branch  4 taken 39
branch  5 taken 0 (fallthrough)
branch  6 taken 39
    10023: 1537:	        for (len = 0; len < YMAP_LENGTH; len++)
branch  0 taken 9984
branch  1 taken 39 (fallthrough)
     9984: 1538:	          ustring[len] = len;
       39: 1539:	        cur_cmd->x.translate = ustring;
        -: 1540:	      }
        -: 1541:
       39: 1542:	    slash = inchar();
call    0 returned 39
       39: 1543:	    if ( !(b = match_slash(slash, FALSE, FALSE)) )
call    0 returned 39
branch  1 taken 0 (fallthrough)
branch  2 taken 39
    #####: 1544:	      bad_prog(_(UNTERM_Y_CMD));
call    0 never executed
        -: 1545:
        -: 1546:#if defined MBS_SUPPORT && !defined (REG_PERL)
        -: 1547:            if (MB_CUR_MAX > 1)
        -: 1548:	      {
        -: 1549:                int i, j, idx, src_char_num, len = size_buffer(b);
        -: 1550:                size_t *src_lens = MALLOC(len, size_t);
        -: 1551:                char *src_buf, *dest_buf, **trans_pairs;
        -: 1552:                size_t mbclen;
        -: 1553:                mbstate_t cur_stat;
        -: 1554:	        struct buffer *b2;
        -: 1555:
        -: 1556:                /* Enumerate how many character the source buffer has.  */
        -: 1557:                memset(&cur_stat, 0, sizeof(mbstate_t));
        -: 1558:                src_buf = get_buffer(b);
        -: 1559:                for (i = 0, j = 0; i < len;)
        -: 1560:                  {
        -: 1561:                    mbclen = mbrlen(src_buf + i, len - i, &cur_stat);
        -: 1562:                    /* An invalid sequence, or a truncated multibyte character.
        -: 1563:                       We treat it as a singlebyte character.  */
        -: 1564:                    if (mbclen == (size_t) -1 || mbclen == (size_t) -2
        -: 1565:                        || mbclen == 0)
        -: 1566:                      mbclen = 1;
        -: 1567:                    src_lens[j++] = mbclen;
        -: 1568:                    i += mbclen;
        -: 1569:                  }
        -: 1570:                src_char_num = j;
        -: 1571:
        -: 1572:                memset(&cur_stat, 0, sizeof(mbstate_t));
        -: 1573:                if ( !(b2 = match_slash(slash, FALSE, FALSE)) )
        -: 1574: 		  bad_prog(_(UNTERM_Y_CMD));
        -: 1575:                dest_buf = get_buffer(b2);
        -: 1576:                idx = 0;
        -: 1577:                len = size_buffer(b2);
        -: 1578:
        -: 1579:                /* trans_pairs = {src(0), dest(0), src(1), dest(1), ..., NULL}
        -: 1580:                     src(i) : pointer to i-th source character.
        -: 1581:                     dest(i) : pointer to i-th destination character.
        -: 1582:                     NULL : terminator */
        -: 1583:                trans_pairs = MALLOC(2 * src_char_num + 1, char*);
        -: 1584:                cur_cmd->x.translatemb = trans_pairs;
        -: 1585:                for (i = 0; i < src_char_num; i++)
        -: 1586:                  {
        -: 1587:                    if (idx >= len)
        -: 1588:                      bad_prog(_(Y_CMD_LEN));
        -: 1589:
        -: 1590:                    /* Set the i-th source character.  */
        -: 1591:                    trans_pairs[2 * i] = MALLOC(src_lens[i] + 1, char);
        -: 1592:                    strncpy(trans_pairs[2 * i], src_buf, src_lens[i]);
        -: 1593:                    trans_pairs[2 * i][src_lens[i]] = '\0';
        -: 1594:                    src_buf += src_lens[i]; /* Forward to next character.  */
        -: 1595:
        -: 1596:                    /* Fetch the i-th destination character.  */
        -: 1597:                    mbclen = mbrlen(dest_buf + idx, len - idx, &cur_stat);
        -: 1598:                    /* An invalid sequence, or a truncated multibyte character.
        -: 1599:                       We treat it as a singlebyte character.  */
        -: 1600:                    if (mbclen == (size_t) -1 || mbclen == (size_t) -2
        -: 1601:                        || mbclen == 0)
        -: 1602:                      mbclen = 1;
        -: 1603:
        -: 1604:                    /* Set the i-th destination character.  */
        -: 1605:                    trans_pairs[2 * i + 1] = MALLOC(mbclen + 1, char);
        -: 1606:                    strncpy(trans_pairs[2 * i + 1], dest_buf + idx, mbclen);
        -: 1607:                    trans_pairs[2 * i + 1][mbclen] = '\0';
        -: 1608:                    idx += mbclen; /* Forward to next character.  */
        -: 1609:                  }
        -: 1610:                trans_pairs[2 * i] = NULL;
        -: 1611:                if (idx != len)
        -: 1612:                  bad_prog(_(Y_CMD_LEN));
        -: 1613:                free_buffer(b);
        -: 1614:                free_buffer(b2);
        -: 1615:              }
        -: 1616:            else
        -: 1617:#endif
        -: 1618:              {
       39: 1619:                ustring = CAST(unsigned char *)get_buffer(b);
call    0 returned 39
      328: 1620:                for (len = size_buffer(b); len; --len)
call    0 returned 39
branch  1 taken 289
branch  2 taken 39 (fallthrough)
        -: 1621:                  {
      289: 1622:                    ch = inchar();
call    0 returned 289
      289: 1623:                    if (ch == slash)
branch  0 taken 0 (fallthrough)
branch  1 taken 289
    #####: 1624:                      bad_prog(_(Y_CMD_LEN));
call    0 never executed
      289: 1625:                    if (ch == '\n')
branch  0 taken 0 (fallthrough)
branch  1 taken 289
    #####: 1626:                      bad_prog(UNTERM_Y_CMD);
call    0 never executed
      289: 1627:                    if (ch == '\\')
branch  0 taken 0 (fallthrough)
branch  1 taken 289
    #####: 1628:                      ch = inchar();
call    0 never executed
      289: 1629:                    if (ch == EOF)
branch  0 taken 0 (fallthrough)
branch  1 taken 289
    #####: 1630:                      bad_prog(UNTERM_Y_CMD);
call    0 never executed
      289: 1631:                    cur_cmd->x.translate[*ustring++] = ch;
        -: 1632:                  }
       39: 1633:                free_buffer(b);
call    0 returned 39
        -: 1634:
       39: 1635:                if (inchar() != slash)
call    0 returned 39
branch  1 taken 0 (fallthrough)
branch  2 taken 39
    #####: 1636:		  bad_prog(_(Y_CMD_LEN));
call    0 never executed
       39: 1637:                else if ((ch = in_nonblank()) != EOF && ch != '\n' && ch != ';')
call    0 returned 39
branch  1 taken 39 (fallthrough)
branch  2 taken 0
branch  3 taken 2 (fallthrough)
branch  4 taken 37
branch  5 taken 0 (fallthrough)
branch  6 taken 2
    #####: 1638:                  bad_prog(_(EXCESS_JUNK));
call    0 never executed
        -: 1639:	      }
        -: 1640:	  }
       39: 1641:	break;
        -: 1642:
    #####: 1643:	case EOF:
    #####: 1644:	  bad_prog(_(NO_COMMAND));
call    0 never executed
        -: 1645:	  /*NOTREACHED*/
        5: 1646:	default:
        -: 1647:	  {
        5: 1648:	    const char *msg = _("Unknown command:");
        5: 1649:	    char *unknown_cmd = xmalloc(strlen(msg) + 5);
call    0 returned 5
        5: 1650:	    sprintf(unknown_cmd, "%s `%c'", msg, ch);
        5: 1651:	    bad_prog(unknown_cmd);
call    0 returned 0
        -: 1652:	    /*NOTREACHED*/
        -: 1653:	  }
        -: 1654:	}
        -: 1655:
        -: 1656:      /* this is buried down here so that "continue" statements will miss it */
     2027: 1657:      ++vector->v_length;
        -: 1658:    }
      364: 1659:  return vector;
        -: 1660:}
        -: 1661:
        -: 1662:
        -: 1663:/* Complain about a programming error and exit. */
        -: 1664:void
function bad_prog called 6 returned 0% blocks executed 100%
        6: 1665:bad_prog(why)
        -: 1666:  const char *why;
        -: 1667:{
        6: 1668:  if (cur_input.name)
branch  0 taken 1 (fallthrough)
branch  1 taken 5
        1: 1669:    fprintf(stderr, _("%s: file %s line %lu: %s\n"),
        1: 1670:	    myname, cur_input.name, CAST(unsigned long)cur_input.line, why);
call    0 returned 1
        -: 1671:  else
        5: 1672:    fprintf(stderr, _("%s: -e expression #%lu, char %lu: %s\n"),
        -: 1673:	    myname,
        5: 1674:	    CAST(unsigned long)cur_input.string_expr_count,
        5: 1675:	    CAST(unsigned long)(prog.cur-prog.base),
call    0 returned 5
        -: 1676:	    why);
        6: 1677:  exit(EXIT_FAILURE);
        -: 1678:}
        -: 1679:
        -: 1680:
        -: 1681:/* deal with \X escapes */
        -: 1682:size_t
function normalize_text called 855 returned 100% blocks executed 38%
      855: 1683:normalize_text(buf, len)
        -: 1684:  char *buf;
        -: 1685:  size_t len;
        -: 1686:{
      855: 1687:  const char *bufend = buf + len;
      855: 1688:  char *p = buf;
      855: 1689:  char *q = buf;
        -: 1690:
        -: 1691:  /* I'm not certain whether POSIX.2 allows these escapes.
        -: 1692:     Play it safe for now... */
     855*: 1693:  if (POSIXLY_CORRECT && !(extended_regexp_flags))
branch  0 taken 0 (fallthrough)
branch  1 taken 855
branch  2 never executed
branch  3 never executed
    #####: 1694:    return len;
        -: 1695:
     5109: 1696:  while (p < bufend)
branch  0 taken 4254
branch  1 taken 855 (fallthrough)
        -: 1697:    {
        -: 1698:      int c;
        -: 1699:
     4254: 1700:      *q = *p++;
     4254: 1701:      if (*q == '\\' && p < bufend)
branch  0 taken 381 (fallthrough)
branch  1 taken 3873
branch  2 taken 381 (fallthrough)
branch  3 taken 0
      381: 1702:	switch ( (c = *p++) )
branch  0 taken 0
branch  1 taken 0
branch  2 taken 0
branch  3 taken 0
branch  4 taken 0
branch  5 taken 0
branch  6 taken 0
branch  7 taken 0
branch  8 taken 0
branch  9 taken 0
branch 10 taken 381
        -: 1703:	  {
        -: 1704:#if defined __STDC__ && __STDC__-0
    #####: 1705:	  case 'a': *q = '\a'; break;
        -: 1706:#else /* Not STDC; we'll just assume ASCII */
        -: 1707:	  case 'a': *q = '\007'; break;
        -: 1708:#endif
        -: 1709:	  /* case 'b': *q = '\b'; break; --- conflicts with \b RE */
    #####: 1710:	  case 'f': *q = '\f'; break;
    #####: 1711:	  case '\n': /*fall through */
    #####: 1712:	  case 'n': *q = '\n'; break;
    #####: 1713:	  case 'r': *q = '\r'; break;
    #####: 1714:	  case 't': *q = '\t'; break;
    #####: 1715:	  case 'v': *q = '\v'; break;
        -: 1716:
    #####: 1717:	  case 'd': /* decimal byte */
    #####: 1718:	    p = convert_number(q, p, bufend, 10, 3, 'd');
call    0 never executed
    #####: 1719:	    break;
        -: 1720:
    #####: 1721:	  case 'x': /* hexadecimal byte */
    #####: 1722:	    p = convert_number(q, p, bufend, 16, 2, 'x');
call    0 never executed
    #####: 1723:	    break;
        -: 1724:
        -: 1725:#ifdef REG_PERL
        -: 1726:	  case '0': case '1': case '2': case '3':
        -: 1727:	  case '4': case '5': case '6': case '7':
        -: 1728:	    if ((extended_regexp_flags & REG_PERL) &&
        -: 1729:		p < bufend && isdigit(*p))
        -: 1730:	      {
        -: 1731:		p--;
        -: 1732:		p = convert_number(q, p, bufend, 8, 3, *p);
        -: 1733:	      }
        -: 1734:	    else
        -: 1735:	      /* we just pass the \ up one level for interpretation */
        -: 1736:	      *++q = p[-1];
        -: 1737:
        -: 1738:	    break;
        -: 1739:
        -: 1740:	  case 'o': /* octal byte */
        -: 1741:	    if (!(extended_regexp_flags & REG_PERL))
        -: 1742:	      p = convert_number(q, p, bufend,  8, 3, 'o');
        -: 1743:	    else
        -: 1744:	      /* we just pass the \ up one level for interpretation */
        -: 1745:	      *++q = p[-1];
        -: 1746:	    
        -: 1747:	    break;
        -: 1748:
        -: 1749:#else
    #####: 1750:	  case 'o': /* octal byte */
    #####: 1751:	    p = convert_number(q, p, bufend,  8, 3, 'o');
call    0 never executed
    #####: 1752:	    break;
        -: 1753:#endif
        -: 1754:
    #####: 1755:	  case 'c':
    #####: 1756:	    if (p < bufend)
branch  0 never executed
branch  1 never executed
        -: 1757:	      {
    #####: 1758:		*q = toupper(*p) ^ 0x40;
    #####: 1759:		p++;
    #####: 1760:		break;
        -: 1761:	      }
        -: 1762:	    /* else FALLTHROUGH */
        -: 1763:
        -: 1764:	  default:
        -: 1765:	    /* we just pass the \ up one level for interpretation */
      381: 1766:	    *++q = p[-1];
      381: 1767:	    break;
        -: 1768:	  }
     4254: 1769:      ++q;
        -: 1770:    }
      855: 1771:    return (size_t)(q - buf);
        -: 1772:}
        -: 1773:
        -: 1774:
        -: 1775:/* `str' is a string (from the command line) that contains a sed command.
        -: 1776:   Compile the command, and add it to the end of `cur_program'. */
        -: 1777:struct vector *
function compile_string called 32 returned 84% blocks executed 100%
       32: 1778:compile_string(cur_program, str, len)
        -: 1779:  struct vector *cur_program;
        -: 1780:  char *str;
        -: 1781:  size_t len;
        -: 1782:{
        -: 1783:  static countT string_expr_count = 0;
        -: 1784:  struct vector *ret;
        -: 1785:
       32: 1786:  prog.file = NULL;
       32: 1787:  prog.base = CAST(unsigned char *)str;
       32: 1788:  prog.cur = prog.base;
       32: 1789:  prog.end = prog.cur + len;
        -: 1790:
       32: 1791:  cur_input.line = 0;
       32: 1792:  cur_input.name = NULL;
       32: 1793:  cur_input.string_expr_count = ++string_expr_count;
        -: 1794:
       32: 1795:  ret = compile_program(cur_program);
call    0 returned 27
       27: 1796:  prog.base = NULL;
       27: 1797:  prog.cur = NULL;
       27: 1798:  prog.end = NULL;
        -: 1799:
       27: 1800:  first_script = FALSE;
       27: 1801:  return ret;
        -: 1802:}
        -: 1803:
        -: 1804:/* `cmdfile' is the name of a file containing sed commands.
        -: 1805:   Read them in and add them to the end of `cur_program'.
        -: 1806: */
        -: 1807:struct vector *
function compile_file called 339 returned 99% blocks executed 89%
      339: 1808:compile_file(cur_program, cmdfile)
        -: 1809:  struct vector *cur_program;
        -: 1810:  const char *cmdfile;
        -: 1811:{
        -: 1812:  size_t len;
        -: 1813:  struct vector *ret;
        -: 1814:
      339: 1815:  prog.file = stdin;
     339*: 1816:  if (cmdfile[0] != '-' || cmdfile[1] != '\0')
branch  0 taken 0 (fallthrough)
branch  1 taken 339
branch  2 never executed
branch  3 never executed
      339: 1817:    prog.file = ck_fopen(cmdfile, "rt", TRUE);
call    0 returned 337
        -: 1818:
      337: 1819:  cur_input.line = 1;
      337: 1820:  cur_input.name = cmdfile;
      337: 1821:  cur_input.string_expr_count = 0;
        -: 1822:
      337: 1823:  ret = compile_program(cur_program);
call    0 returned 337
      337: 1824:  if (prog.file != stdin)
branch  0 taken 337 (fallthrough)
branch  1 taken 0
      337: 1825:    ck_fclose(prog.file);
call    0 returned 337
      337: 1826:  prog.file = NULL;
        -: 1827:
      337: 1828:  first_script = FALSE;
      337: 1829:  return ret;
        -: 1830:}
        -: 1831:
        -: 1832:/* Make any checks which require the whole program to have been read.
        -: 1833:   In particular: this backpatches the jump targets.
        -: 1834:   Any cleanup which can be done after these checks is done here also.  */
        -: 1835:void
function check_final_program called 361 returned 100% blocks executed 73%
      361: 1836:check_final_program(program)
        -: 1837:  struct vector *program;
        -: 1838:{
        -: 1839:  struct sed_label *go;
        -: 1840:  struct sed_label *lbl;
        -: 1841:
        -: 1842:  /* do all "{"s have a corresponding "}"? */
      361: 1843:  if (blocks)
branch  0 taken 1 (fallthrough)
branch  1 taken 360
        -: 1844:    {
        -: 1845:      /* update info for error reporting: */
        1: 1846:      MEMCPY(&cur_input, &blocks->err_info, sizeof cur_input);
        1: 1847:      bad_prog(_(EXCESS_OPEN_BRACE));
call    0 returned 0
        -: 1848:    }
        -: 1849:
        -: 1850:  /* was the final command an unterminated a/c/i command? */
      360: 1851:  if (pending_text)
branch  0 taken 0 (fallthrough)
branch  1 taken 360
        -: 1852:    {
    #####: 1853:      old_text_buf->text_length = size_buffer(pending_text);
call    0 never executed
    #####: 1854:      old_text_buf->text = MEMDUP(get_buffer(pending_text),
call    0 never executed
call    1 never executed
        -: 1855:				  old_text_buf->text_length, char);
    #####: 1856:      free_buffer(pending_text);
call    0 never executed
    #####: 1857:      pending_text = NULL;
        -: 1858:    }
        -: 1859:
      369: 1860:  for (go = jumps; go; go = release_label(go))
call    0 returned 9
branch  1 taken 9
branch  2 taken 360 (fallthrough)
        -: 1861:    {
       11: 1862:      for (lbl = labels; lbl; lbl = lbl->next)
branch  0 taken 7
branch  1 taken 4 (fallthrough)
        7: 1863:	if (strcmp(lbl->name, go->name) == 0)
branch  0 taken 5 (fallthrough)
branch  1 taken 2
        5: 1864:	  break;
        9: 1865:      if (lbl)
branch  0 taken 5 (fallthrough)
branch  1 taken 4
        -: 1866:	{
        5: 1867:	  program->v[go->v_index].x.jump_index = lbl->v_index;
        -: 1868:	}
        -: 1869:      else
        -: 1870:	{
        4: 1871:	  if (*go->name)
branch  0 taken 0 (fallthrough)
branch  1 taken 4
    #####: 1872:	    panic(_("Can't find label for jump to `%s'"), go->name);
call    0 never executed
        4: 1873:	  program->v[go->v_index].x.jump_index = program->v_length;
        -: 1874:	}
        -: 1875:    }
      360: 1876:  jumps = NULL;
        -: 1877:
      364: 1878:  for (lbl = labels; lbl; lbl = release_label(lbl))
call    0 returned 4
branch  1 taken 4
branch  2 taken 360 (fallthrough)
        -: 1879:    ;
      360: 1880:  labels = NULL;
        -: 1881:
        -: 1882:  /* There is no longer a need to track file names: */
        -: 1883:  {
        -: 1884:    struct fp_list *p;
        -: 1885:
     360*: 1886:    for (p=file_read; p; p=p->link)
branch  0 taken 0
branch  1 taken 360 (fallthrough)
    #####: 1887:      if (p->name)
branch  0 never executed
branch  1 never executed
        -: 1888:	{
    #####: 1889:	  FREE(p->name);
call    0 never executed
    #####: 1890:	  p->name = NULL;
        -: 1891:	}
        -: 1892:
      557: 1893:    for (p=file_write; p; p=p->link)
branch  0 taken 197
branch  1 taken 360 (fallthrough)
      197: 1894:      if (p->name)
branch  0 taken 197 (fallthrough)
branch  1 taken 0
        -: 1895:	{
      197: 1896:	  FREE(p->name);
call    0 returned 197
      197: 1897:	  p->name = NULL;
        -: 1898:	}
        -: 1899:  }
      360: 1900:}
        -: 1901:
        -: 1902:/* Release all resources which were allocated in this module. */
        -: 1903:void
function rewind_read_files called 5 returned 100% blocks executed 43%
        5: 1904:rewind_read_files()
        -: 1905:{
        -: 1906:  struct fp_list *p, *q;
        -: 1907:
       5*: 1908:  for (p=file_read; p; p=p->link)
branch  0 taken 0
branch  1 taken 5 (fallthrough)
    #####: 1909:    if (p->fp && !p->special)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1910:      rewind(p->fp);
call    0 never executed
        5: 1911:}
        -: 1912:
        -: 1913:/* Release all resources which were allocated in this module. */
        -: 1914:void
function finish_program called 360 returned 100% blocks executed 69%
      360: 1915:finish_program(program)
        -: 1916:  struct vector *program;
        -: 1917:{
        -: 1918:  /* close all files... */
        -: 1919:  {
        -: 1920:    struct fp_list *p, *q;
        -: 1921:
     360*: 1922:    for (p=file_read; p; p=q)
branch  0 taken 0
branch  1 taken 360 (fallthrough)
        -: 1923:      {
    #####: 1924:	if (p->fp && !p->special)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1925:	  ck_fclose(p->fp);
call    0 never executed
    #####: 1926:	q = p->link;
        -: 1927:#if 0
        -: 1928:	/* We use obstacks. */
        -: 1929:	FREE(p);
        -: 1930:#endif
        -: 1931:      }
        -: 1932:
      557: 1933:    for (p=file_write; p; p=q)
branch  0 taken 197
branch  1 taken 360 (fallthrough)
        -: 1934:      {
      197: 1935:	if (p->fp && !p->special)
branch  0 taken 197 (fallthrough)
branch  1 taken 0
branch  2 taken 197 (fallthrough)
branch  3 taken 0
      197: 1936:	  ck_fclose(p->fp);
call    0 returned 197
      197: 1937:	q = p->link;
        -: 1938:#if 0
        -: 1939:	/* We use obstacks. */
        -: 1940:	FREE(p);
        -: 1941:#endif
        -: 1942:      }
      360: 1943:    file_read = file_write = NULL;
        -: 1944:  }
        -: 1945:
        -: 1946:#ifdef DEBUG_LEAKS
        -: 1947:  obstack_free (&obs, NULL);
        -: 1948:#endif /*DEBUG_LEAKS*/
      360: 1949:}
        -: 1950:
        -: 1951:/*  GNU SED, a batch stream editor.
        -: 1952:    Copyright (C) 1989,90,91,92,93,94,95,98,99,2002,2003
        -: 1953:    Free Software Foundation, Inc.
        -: 1954:
        -: 1955:    This program is free software; you can redistribute it and/or modify
        -: 1956:    it under the terms of the GNU General Public License as published by
        -: 1957:    the Free Software Foundation; either version 2, or (at your option)
        -: 1958:    any later version.
        -: 1959:
        -: 1960:    This program is distributed in the hope that it will be useful,
        -: 1961:    but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 1962:    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 1963:    GNU General Public License for more details.
        -: 1964:
        -: 1965:    You should have received a copy of the GNU General Public License
        -: 1966:    along with this program; if not, write to the Free Software
        -: 1967:    Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
        -: 1968:
        -: 1969:#undef EXPERIMENTAL_DASH_N_OPTIMIZATION	/*don't use -- is very buggy*/
        -: 1970:#define INITIAL_BUFFER_SIZE	50
        -: 1971:#define FREAD_BUFFER_SIZE	8192
        -: 1972:
        -: 1973:#include "config.h"
        -: 1974:
        -: 1975:#include <stdio.h>
        -: 1976:#include <ctype.h>
        -: 1977:
        -: 1978:#include <errno.h>
        -: 1979:#ifndef errno
        -: 1980:extern int errno;
        -: 1981:#endif
        -: 1982:
        -: 1983:#ifdef HAVE_UNISTD_H
        -: 1984:# include <unistd.h>
        -: 1985:#endif
        -: 1986:
        -: 1987:#ifdef __GNUC__
        -: 1988:# if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__-0 >= 7)
        -: 1989:   /* silence warning about unused parameter even for "gcc -W -Wunused" */
        -: 1990:#  define UNUSED	__attribute__((unused))
        -: 1991:# endif
        -: 1992:#endif
        -: 1993:#ifndef UNUSED
        -: 1994:# define UNUSED
        -: 1995:#endif
        -: 1996:
        -: 1997:#ifdef HAVE_STRINGS_H
        -: 1998:# include <strings.h>
        -: 1999:#else
        -: 2000:# include <string.h>
        -: 2001:#endif /*HAVE_STRINGS_H*/
        -: 2002:#ifdef HAVE_MEMORY_H
        -: 2003:# include <memory.h>
        -: 2004:#endif
        -: 2005:
        -: 2006:
        -: 2007:#if defined HAVE_WCTYPE_H && defined HAVE_WCHAR_H && defined HAVE_MBRTOWC
        -: 2008:/* We can handle multibyte string.  */
        -: 2009:# include <wchar.h>
        -: 2010:# include <wctype.h>
        -: 2011:# define MBS_SUPPORT
        -: 2012:#endif
        -: 2013:
        -: 2014:#ifndef HAVE_STRCHR
        -: 2015:# define strchr index
        -: 2016:# define strrchr rindex
        -: 2017:#endif
        -: 2018:
        -: 2019:#ifdef HAVE_STDLIB_H
        -: 2020:# include <stdlib.h>
        -: 2021:#endif
        -: 2022:#ifndef EXIT_SUCCESS
        -: 2023:# define EXIT_SUCCESS 0
        -: 2024:#endif
        -: 2025:
        -: 2026:#ifdef HAVE_SYS_TYPES_H
        -: 2027:# include <sys/types.h>
        -: 2028:#endif
        -: 2029:
        -: 2030:#include <sys/stat.h>
        -: 2031:
        -: 2032:#include "basicdefs.h"
        -: 2033:#include "utils.h"
        -: 2034:
        -: 2035:
        -: 2036:/* Sed operates a line at a time. */
        -: 2037:struct line {
        -: 2038:  char *text;		/* Pointer to line allocated by malloc. */
        -: 2039:  char *active;		/* Pointer to non-consumed part of text. */
        -: 2040:  size_t length;	/* Length of text (or active, if used). */
        -: 2041:  size_t alloc;		/* Allocated space for active. */
        -: 2042:  flagT chomped;	/* Was a trailing newline dropped? */
        -: 2043:};
        -: 2044:
        -: 2045:/* A queue of text to write out at the end of a cycle
        -: 2046:   (filled by the "a", "r" and "R" commands.) */
        -: 2047:struct append_queue {
        -: 2048:  const char *fname;
        -: 2049:  char *text;
        -: 2050:  size_t textlen;
        -: 2051:  struct append_queue *next;
        -: 2052:  flagT free;
        -: 2053:};
        -: 2054:
        -: 2055:/* State information for the input stream. */
        -: 2056:struct input {
        -: 2057:  char **file_list;	/* The list of yet-to-be-opened files.
        -: 2058:			   It is invalid for file_list to be NULL.
        -: 2059:			   When *file_list is NULL we are
        -: 2060:			   currently processing the last file. */
        -: 2061:  countT bad_count;	/* count of files we failed to open */
        -: 2062:  countT line_number;	/* current input line number (over all files) */
        -: 2063:
        -: 2064:  flagT (*read_fn) P_((struct input *));	/* read one line */
        -: 2065:  /* If fp is NULL, read_fn better not be one which uses fp;
        -: 2066:     in particular, read_always_fail() is recommended. */
        -: 2067:
        -: 2068:  char *out_file_name;
        -: 2069:  const char *in_file_name;
        -: 2070:
        -: 2071:  FILE *fp;		/* if NULL, none of the following are valid */
        -: 2072:  flagT no_buffering;
        -: 2073:};
        -: 2074:
        -: 2075:
        -: 2076:/* Have we done any replacements lately?  This is used by the `t' command. */
        -: 2077:static flagT replaced = FALSE;
        -: 2078:
        -: 2079:/* The current output file (stdout if -i is not being used. */
        -: 2080:static FILE *output_file;
        -: 2081:
        -: 2082:/* The `current' input line. */
        -: 2083:static struct line line;
        -: 2084:
        -: 2085:/* An input line used to accumulate the result of the s and e commands. */
        -: 2086:static struct line s_accum;
        -: 2087:
        -: 2088:/* An input line that's been stored by later use by the program */
        -: 2089:static struct line hold;
        -: 2090:
        -: 2091:/* The buffered input look-ahead.  The only field that should be
        -: 2092:   used outside of read_mem_line() or line_init() is buffer.length. */
        -: 2093:static struct line buffer;
        -: 2094:
        -: 2095:static struct append_queue *append_head = NULL;
        -: 2096:static struct append_queue *append_tail = NULL;
        -: 2097:
        -: 2098:
        -: 2099:#ifdef BOOTSTRAP
        -: 2100:/* We can't be sure that the system we're boostrapping on has
        -: 2101:   memchr(), and ../lib/memchr.c requires configuration knowledge
        -: 2102:   about how many bits are in a `long'.  This implementation
        -: 2103:   is far from ideal, but it should get us up-and-limping well
        -: 2104:   enough to run the configure script, which is all that matters.
        -: 2105:*/
        -: 2106:# ifdef memchr
        -: 2107:#  undef memchr
        -: 2108:# endif
        -: 2109:# define memchr bootstrap_memchr
        -: 2110:
        -: 2111:static VOID *bootstrap_memchr P_((const VOID *s, int c, size_t n));
        -: 2112:static VOID *
        -: 2113:bootstrap_memchr(s, c, n)
        -: 2114:  const VOID *s;
        -: 2115:  int c;
        -: 2116:  size_t n;
        -: 2117:{
        -: 2118:  char *p;
        -: 2119:
        -: 2120:  for (p=(char *)s; n-- > 0; ++p)
        -: 2121:    if (*p == c)
        -: 2122:      return p;
        -: 2123:  return CAST(VOID *)0;
        -: 2124:}
        -: 2125:#endif /*BOOTSTRAP*/
        -: 2126:
        -: 2127:/* increase a struct line's length, making some attempt at
        -: 2128:   keeping realloc() calls under control by padding for future growth.  */
        -: 2129:static void resize_line P_((struct line *, size_t));
        -: 2130:static void
function resize_line called 525 returned 100% blocks executed 100%
      525: 2131:resize_line(lb, len)
        -: 2132:  struct line *lb;
        -: 2133:  size_t len;
        -: 2134:{
        -: 2135:  int inactive;
      525: 2136:  inactive = lb->active - lb->text;
        -: 2137:
        -: 2138:  /* If the inactive part has got to more than two thirds of the buffer,
        -: 2139:   * remove it. */
      525: 2140:  if (inactive > lb->alloc * 2)
branch  0 taken 85 (fallthrough)
branch  1 taken 440
        -: 2141:    {
       85: 2142:      MEMMOVE(lb->text, lb->active, lb->length);
       85: 2143:      lb->alloc += lb->active - lb->text;
       85: 2144:      lb->active = lb->text;
       85: 2145:      inactive = 0;
        -: 2146:
       85: 2147:      if (lb->alloc > len)
branch  0 taken 85 (fallthrough)
branch  1 taken 0
       85: 2148:	return;
        -: 2149:    }
        -: 2150:
      440: 2151:  lb->alloc *= 2;
      440: 2152:  if (lb->alloc < len)
branch  0 taken 9 (fallthrough)
branch  1 taken 431
        9: 2153:    lb->alloc = len;
      440: 2154:  if (lb->alloc < INITIAL_BUFFER_SIZE)
branch  0 taken 18 (fallthrough)
branch  1 taken 422
       18: 2155:    lb->alloc = INITIAL_BUFFER_SIZE;
        -: 2156:    
      440: 2157:  lb->text = REALLOC(lb->text, inactive + lb->alloc, char);
call    0 returned 440
      440: 2158:  lb->active = lb->text + inactive;
        -: 2159:}
        -: 2160:
        -: 2161:/* Append `length' bytes from `string' to the line `to'. */
        -: 2162:static void str_append P_((struct line *, const char *, size_t));
        -: 2163:static void
function str_append called 47162 returned 100% blocks executed 100%
    47162: 2164:str_append(to, string, length)
        -: 2165:  struct line *to;
        -: 2166:  const char *string;
        -: 2167:  size_t length;
        -: 2168:{
    47162: 2169:  size_t new_length = to->length + length;
        -: 2170:
    47162: 2171:  if (to->alloc < new_length)
branch  0 taken 525 (fallthrough)
branch  1 taken 46637
      525: 2172:    resize_line(to, new_length);
call    0 returned 525
    47162: 2173:  MEMCPY(to->active + to->length, string, length);
    47162: 2174:  to->length = new_length;
    47162: 2175:}
        -: 2176:
        -: 2177:static void str_append_modified P_((struct line *, const char *, size_t,
        -: 2178:				    enum replacement_types));
        -: 2179:static void
function str_append_modified called 3581 returned 100% blocks executed 41%
     3581: 2180:str_append_modified(to, string, length, type)
        -: 2181:  struct line *to;
        -: 2182:  const char *string;
        -: 2183:  size_t length;
        -: 2184:  enum replacement_types type;
        -: 2185:{
     3581: 2186:  size_t old_length = to->length;
        -: 2187:  char *start, *end;
        -: 2188:
     3581: 2189:  if (length == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 3581
    #####: 2190:    return;
        -: 2191:
     3581: 2192:  str_append(to, string, length);
call    0 returned 3581
     3581: 2193:  start = to->active + old_length;
     3581: 2194:  end = start + length;
        -: 2195:
        -: 2196:  /* Now do the required modifications.  First \[lu]... */
     3581: 2197:  if (type & repl_uppercase_first)
branch  0 taken 0 (fallthrough)
branch  1 taken 3581
        -: 2198:    {
    #####: 2199:      *start = toupper(*start);
    #####: 2200:      start++;
    #####: 2201:      type &= ~repl_uppercase_first;
        -: 2202:    }
     3581: 2203:  else if (type & repl_lowercase_first)
branch  0 taken 0 (fallthrough)
branch  1 taken 3581
        -: 2204:    {
    #####: 2205:      *start = tolower(*start);
    #####: 2206:      start++;
    #####: 2207:      type &= ~repl_lowercase_first;
        -: 2208:    }
        -: 2209:
     3581: 2210:  if (type == repl_asis)
branch  0 taken 3581 (fallthrough)
branch  1 taken 0
     3581: 2211:    return;
        -: 2212:
        -: 2213:  /* ...and then \[LU] */
    #####: 2214:  if (type == repl_uppercase)
branch  0 never executed
branch  1 never executed
    #####: 2215:    for (; start != end; start++)
branch  0 never executed
branch  1 never executed
    #####: 2216:      *start = toupper(*start);
        -: 2217:  else
    #####: 2218:    for (; start != end; start++)
branch  0 never executed
branch  1 never executed
    #####: 2219:      *start = tolower(*start);
        -: 2220:}
        -: 2221:
        -: 2222:/* initialize a "struct line" buffer */
        -: 2223:static void line_init P_((struct line *, size_t initial_size));
        -: 2224:static void
function line_init called 1266 returned 100% blocks executed 100%
     1266: 2225:line_init(buf, initial_size)
        -: 2226:  struct line *buf;
        -: 2227:  size_t initial_size;
        -: 2228:{
     1266: 2229:  buf->text = MALLOC(initial_size, char);
call    0 returned 1266
     1266: 2230:  buf->active = buf->text;
     1266: 2231:  buf->alloc = initial_size;
     1266: 2232:  buf->length = 0;
     1266: 2233:  buf->chomped = TRUE;
     1266: 2234:}
        -: 2235:
        -: 2236:/* Copy the contents of the line `from' into the line `to'.
        -: 2237:   This destroys the old contents of `to'. */
        -: 2238:static void line_copy P_((struct line *from, struct line *to));
        -: 2239:static void
function line_copy called 28 returned 100% blocks executed 100%
       28: 2240:line_copy(from, to)
        -: 2241:  struct line *from;
        -: 2242:  struct line *to;
        -: 2243:{
        -: 2244:  /* Remove the inactive portion in the destination buffer. */
       28: 2245:  to->alloc += to->active - to->text;
        -: 2246:
       28: 2247:  if (to->alloc < from->length)
branch  0 taken 4 (fallthrough)
branch  1 taken 24
        -: 2248:    {
        4: 2249:      to->alloc *= 2;
        4: 2250:      if (to->alloc < from->length)
branch  0 taken 3 (fallthrough)
branch  1 taken 1
        3: 2251:	to->alloc = from->length;
        4: 2252:      if (to->alloc < INITIAL_BUFFER_SIZE)
branch  0 taken 3 (fallthrough)
branch  1 taken 1
        3: 2253:	to->alloc = INITIAL_BUFFER_SIZE;
        -: 2254:      /* Use FREE()+MALLOC() instead of REALLOC() to
        -: 2255:	 avoid unnecessary copying of old text. */
        4: 2256:      FREE(to->text);
call    0 returned 4
        4: 2257:      to->text = MALLOC(to->alloc, char);
call    0 returned 4
        -: 2258:    }
        -: 2259:
       28: 2260:  to->active = to->text;
       28: 2261:  to->length = from->length;
       28: 2262:  to->chomped = from->chomped;
       28: 2263:  MEMCPY(to->active, from->active, from->length);
       28: 2264:}
        -: 2265:
        -: 2266:/* Append the contents of the line `from' to the line `to'. */
        -: 2267:static void line_append P_((struct line *from, struct line *to));
        -: 2268:static void
function line_append called 22 returned 100% blocks executed 100%
       22: 2269:line_append(from, to)
        -: 2270:  struct line *from;
        -: 2271:  struct line *to;
        -: 2272:{
       22: 2273:  str_append(to, "\n", 1);
call    0 returned 22
       22: 2274:  str_append(to, from->active, from->length);
call    0 returned 22
       22: 2275:  to->chomped = from->chomped;
       22: 2276:}
        -: 2277:
        -: 2278:/* Exchange the contents of two "struct line" buffers. */
        -: 2279:static void line_exchange P_((struct line *, struct line *));
        -: 2280:static void
function line_exchange called 2511 returned 100% blocks executed 100%
     2511: 2281:line_exchange(a, b)
        -: 2282:  struct line *a;
        -: 2283:  struct line *b;
        -: 2284:{
        -: 2285:  struct line t;
        -: 2286:
     2511: 2287:  MEMCPY(&t,  a, sizeof(struct line));
     2511: 2288:  MEMCPY( a,  b, sizeof(struct line));
     2511: 2289:  MEMCPY( b, &t, sizeof(struct line));
     2511: 2290:}
        -: 2291:
        -: 2292:
        -: 2293:/* dummy function to simplify read_pattern_space() */
        -: 2294:static flagT read_always_fail P_((struct input *));
        -: 2295:static flagT
function read_always_fail called 384 returned 100% blocks executed 100%
      384: 2296:read_always_fail(input)
        -: 2297:  struct input *input UNUSED;
        -: 2298:{
      384: 2299:  return FALSE;
        -: 2300:}
        -: 2301:
        -: 2302:#include "getline.c"
        -: 2303:static flagT read_file_line P_((struct input *));
        -: 2304:static flagT
function read_file_line called 38579 returned 100% blocks executed 100%
    38579: 2305:read_file_line(input)
        -: 2306:  struct input *input;
        -: 2307:{
        -: 2308:  static char *b;
        -: 2309:  static size_t blen;
        -: 2310:
    38579: 2311:  long result = getline (&b, &blen, input->fp);
call    0 returned 38579
        -: 2312:
        -: 2313:  /* Remove the trailing new-line that is left by getline. */
    38579: 2314:  if (result > 0 && b[result - 1] == '\n')
branch  0 taken 38270 (fallthrough)
branch  1 taken 309
branch  2 taken 38267 (fallthrough)
branch  3 taken 3
    38267: 2315:    --result;
        -: 2316:  else
        -: 2317:    {
        -: 2318:      /* No trailing new line found. */
      312: 2319:      if (!*input->file_list && !POSIXLY_CORRECT)
branch  0 taken 310 (fallthrough)
branch  1 taken 2
branch  2 taken 310 (fallthrough)
branch  3 taken 0
      310: 2320:	line.chomped = FALSE;
        -: 2321:
      312: 2322:      if (result <= 0)
branch  0 taken 309 (fallthrough)
branch  1 taken 3
      309: 2323:	return FALSE;
        -: 2324:    }
        -: 2325:
    38270: 2326:  str_append(&line, b, result);
call    0 returned 38270
    38270: 2327:  return TRUE;
        -: 2328:}
        -: 2329:
        -: 2330:
        -: 2331:static void output_line P_((const char *, size_t, flagT, FILE *));
        -: 2332:static void
function output_line called 25770 returned 100% blocks executed 100%
    25770: 2333:output_line(text, length, nl, fp)
        -: 2334:  const char *text;
        -: 2335:  size_t length;
        -: 2336:  flagT nl;
        -: 2337:  FILE *fp;
        -: 2338:{
    25770: 2339:  if (length)
branch  0 taken 18818 (fallthrough)
branch  1 taken 6952
    18818: 2340:    ck_fwrite(text, 1, length, fp);
call    0 returned 18818
    25770: 2341:  if (nl)
branch  0 taken 21162 (fallthrough)
branch  1 taken 4608
    21162: 2342:    ck_fwrite("\n", 1, 1, fp);
call    0 returned 21162
    25770: 2343:  if (fp != stdout || unbuffered_output)
branch  0 taken 22417 (fallthrough)
branch  1 taken 3353
branch  2 taken 232 (fallthrough)
branch  3 taken 22185
     3585: 2344:    ck_fflush(fp);
call    0 returned 3585
    25770: 2345:}
        -: 2346:
        -: 2347:static struct append_queue *next_append_slot P_((void));
        -: 2348:static struct append_queue *
function next_append_slot called 644 returned 100% blocks executed 83%
      644: 2349:next_append_slot()
        -: 2350:{
      644: 2351:  struct append_queue *n = MALLOC(1, struct append_queue);
call    0 returned 644
        -: 2352:
      644: 2353:  n->fname = NULL;
      644: 2354:  n->text = NULL;
      644: 2355:  n->textlen = 0;
      644: 2356:  n->next = NULL;
      644: 2357:  n->free = FALSE;
        -: 2358:
      644: 2359:  if (append_tail)
branch  0 taken 0 (fallthrough)
branch  1 taken 644
    #####: 2360:      append_tail->next = n;
        -: 2361:  else
      644: 2362:      append_head = n;
      644: 2363:  return append_tail = n;
        -: 2364:}
        -: 2365:
        -: 2366:static void release_append_queue P_((void));
        -: 2367:static void
function release_append_queue called 644 returned 100% blocks executed 86%
      644: 2368:release_append_queue()
        -: 2369:{
        -: 2370:  struct append_queue *p, *q;
        -: 2371:
     1288: 2372:  for (p=append_head; p; p=q)
branch  0 taken 644
branch  1 taken 644 (fallthrough)
        -: 2373:    {
      644: 2374:      if (p->free)
branch  0 taken 0 (fallthrough)
branch  1 taken 644
    #####: 2375:	FREE(p->text);
call    0 never executed
        -: 2376:
      644: 2377:      q = p->next;
      644: 2378:      FREE(p);
call    0 returned 644
        -: 2379:    }
      644: 2380:  append_head = append_tail = NULL;
      644: 2381:}
        -: 2382:
        -: 2383:static void dump_append_queue P_((void));
        -: 2384:static void
function dump_append_queue called 644 returned 100% blocks executed 100%
      644: 2385:dump_append_queue()
        -: 2386:{
        -: 2387:  struct append_queue *p;
        -: 2388:
     1288: 2389:  for (p=append_head; p; p=p->next)
branch  0 taken 644
branch  1 taken 644 (fallthrough)
        -: 2390:    {
      644: 2391:      if (p->text)
branch  0 taken 546 (fallthrough)
branch  1 taken 98
      546: 2392:	  output_line(p->text, p->textlen, FALSE, output_file);
call    0 returned 546
      644: 2393:      if (p->fname)
branch  0 taken 98 (fallthrough)
branch  1 taken 546
        -: 2394:	{
        -: 2395:	  char buf[FREAD_BUFFER_SIZE];
        -: 2396:	  size_t cnt;
        -: 2397:	  FILE *fp;
        -: 2398:
        -: 2399:	  /* "If _fname_ does not exist or cannot be read, it shall
        -: 2400:	     be treated as if it were an empty file, causing no error
        -: 2401:	     condition."  IEEE Std 1003.2-1992
        -: 2402:	     So, don't fail. */
       98: 2403:	  fp = ck_fopen(p->fname, "r", FALSE);
call    0 returned 98
       98: 2404:	  if (fp)
branch  0 taken 98 (fallthrough)
branch  1 taken 0
        -: 2405:	    {
      196: 2406:	      while ((cnt = ck_fread(buf, 1, sizeof buf, fp)) > 0)
call    0 returned 196
branch  1 taken 98
branch  2 taken 98 (fallthrough)
       98: 2407:		ck_fwrite(buf, 1, cnt, output_file);
call    0 returned 98
       98: 2408:	      ck_fclose(fp);
call    0 returned 98
        -: 2409:	    }
        -: 2410:	}
        -: 2411:    }
      644: 2412:  release_append_queue();
call    0 returned 644
      644: 2413:}
        -: 2414:
        -: 2415:
        -: 2416:/* Compute the name of the backup file for in-place editing */
        -: 2417:static char *get_backup_file_name P_((const char *));
        -: 2418:static char *
function get_backup_file_name called 1 returned 100% blocks executed 100%
        1: 2419:get_backup_file_name(name)
        -: 2420:  const char *name;
        -: 2421:{
        -: 2422:  char *old_asterisk, *asterisk, *backup, *p;
        1: 2423:  int name_length = strlen(name), backup_length = strlen(in_place_extension);
        -: 2424:
        -: 2425:  /* Compute the length of the backup file */
        1: 2426:  for (asterisk = in_place_extension - 1, old_asterisk = asterisk + 1;
        2: 2427:       asterisk = strchr(old_asterisk, '*');
branch  0 taken 1
branch  1 taken 1 (fallthrough)
        1: 2428:       old_asterisk = asterisk + 1)
        1: 2429:    backup_length += name_length - 1;
        -: 2430:
        1: 2431:  p = backup = xmalloc(backup_length + 1);
call    0 returned 1
        -: 2432:
        -: 2433:  /* Each iteration gobbles up to an asterisk */
        1: 2434:  for (asterisk = in_place_extension - 1, old_asterisk = asterisk + 1;
        2: 2435:       asterisk = strchr(old_asterisk, '*');
branch  0 taken 1
branch  1 taken 1 (fallthrough)
        1: 2436:       old_asterisk = asterisk + 1)
        -: 2437:    {
        1: 2438:      memcpy (p, old_asterisk, asterisk - old_asterisk);
        1: 2439:      p += asterisk - old_asterisk;
        1: 2440:      strcpy (p, name);
        1: 2441:      p += name_length;
        -: 2442:    }
        -: 2443:
        -: 2444:  /* Tack on what's after the last asterisk */
        1: 2445:  strcpy (p, old_asterisk);
        1: 2446:  return backup;
        -: 2447:}
        -: 2448:
        -: 2449:/* Initialize a struct input for the named file. */
        -: 2450:static void open_next_file P_((const char *name, struct input *));
        -: 2451:static void
function open_next_file called 362 returned 100% blocks executed 95%
      362: 2452:open_next_file(name, input)
        -: 2453:  const char *name;
        -: 2454:  struct input *input;
        -: 2455:{
      362: 2456:  buffer.length = 0;
        -: 2457:
      362: 2458:  if (name[0] == '-' && name[1] == '\0')
branch  0 taken 1 (fallthrough)
branch  1 taken 361
branch  2 taken 1 (fallthrough)
branch  3 taken 0
        -: 2459:    {
        1: 2460:      clearerr(stdin);	/* clear any stale EOF indication */
call    0 returned 1
        1: 2461:      input->fp = stdin;
        -: 2462:    }
      361: 2463:  else if ( ! (input->fp = ck_fopen(name, "r", FALSE)) )
call    0 returned 361
branch  1 taken 1 (fallthrough)
branch  2 taken 360
        -: 2464:    {
        1: 2465:      const char *ptr = strerror(errno);
call    0 returned 1
        1: 2466:      fprintf(stderr, _("%s: can't read %s: %s\n"), myname, name, ptr);
call    0 returned 1
        1: 2467:      input->read_fn = read_always_fail; /* a redundancy */
        1: 2468:      ++input->bad_count;
        1: 2469:      return;
        -: 2470:    }
        -: 2471:
      361: 2472:  input->read_fn = read_file_line;
        -: 2473:
      361: 2474:  if (in_place_extension)
branch  0 taken 2 (fallthrough)
branch  1 taken 359
        -: 2475:    {
        -: 2476:      int output_fd;
        2: 2477:      char *tmpdir = ck_strdup(name), *p;
call    0 returned 2
        -: 2478:
        -: 2479:      /* get the base name */
        2: 2480:      if (p = strrchr(tmpdir, '/'))
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2: 2481:	*(p + 1) = 0;
        -: 2482:      else
    #####: 2483:	strcpy(tmpdir, ".");
        -: 2484:      
        2: 2485:      input->in_file_name = name;
        2: 2486:      input->out_file_name = temp_file_template (tmpdir, "sed");
call    0 returned 2
        2: 2487:      output_fd = mkstemp (input->out_file_name);
call    0 returned 2
        2: 2488:      free (tmpdir);
        -: 2489:
        -: 2490:#ifdef HAVE_FCHMOD
        -: 2491:      {
        -: 2492:	struct stat st;
        -: 2493:	fstat (fileno (input->fp), &st);
        -: 2494:	fchmod (output_fd, st.st_mode);
        -: 2495:      }
        -: 2496:#endif
        -: 2497:
        2: 2498:      output_file = fdopen (output_fd, "w");
call    0 returned 2
        -: 2499:    }
        -: 2500:  else
      359: 2501:    output_file = stdout;
        -: 2502:}
        -: 2503:
        -: 2504:
        -: 2505:/* Clean up an input stream that we are done with. */
        -: 2506:static void closedown P_((struct input *));
        -: 2507:static void
function closedown called 1080 returned 100% blocks executed 100%
     1080: 2508:closedown(input)
        -: 2509:  struct input *input;
        -: 2510:{
     1080: 2511:  input->read_fn = read_always_fail;
     1080: 2512:  if (!input->fp)
branch  0 taken 719 (fallthrough)
branch  1 taken 361
      719: 2513:    return;
      361: 2514:  if (input->fp != stdin) /* stdin can be reused on tty and tape devices */
branch  0 taken 360 (fallthrough)
branch  1 taken 1
      360: 2515:    ck_fclose(input->fp);
call    0 returned 360
        -: 2516:
      361: 2517:      if (in_place_extension && output_file != NULL)
branch  0 taken 2 (fallthrough)
branch  1 taken 359
branch  2 taken 2 (fallthrough)
branch  3 taken 0
        -: 2518:	{
        2: 2519:	  if (strcmp(in_place_extension, "*") != 0)
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        -: 2520:	    {
        1: 2521:	      char *backup_file_name = get_backup_file_name(input->in_file_name);
call    0 returned 1
        1: 2522:	      rename (input->in_file_name, backup_file_name);
call    0 returned 1
        1: 2523:	      free (backup_file_name);
        -: 2524:	    }
        -: 2525:
        2: 2526:	  ck_fclose (output_file);
call    0 returned 2
        2: 2527:	  rename (input->out_file_name, input->in_file_name);
call    0 returned 2
        2: 2528:	  free (input->out_file_name);
        -: 2529:	}
        -: 2530:
      361: 2531:  input->fp = NULL;
        -: 2532:
      361: 2533:  if (separate_files)
branch  0 taken 5 (fallthrough)
branch  1 taken 356
        5: 2534:    rewind_read_files ();
call    0 returned 5
        -: 2535:}
        -: 2536:
        -: 2537:/* Reset range commands so that they are marked as non-matching */
        -: 2538:static void reset_addresses P_((struct vector *));
        -: 2539:static void
function reset_addresses called 5 returned 100% blocks executed 100%
        5: 2540:reset_addresses(vec)
        -: 2541:     struct vector *vec;
        -: 2542:{
        -: 2543:  struct sed_cmd *cur_cmd;
        -: 2544:  int n;
        -: 2545:
       11: 2546:  for (cur_cmd = vec->v, n = vec->v_length; n--; cur_cmd++)
branch  0 taken 6
branch  1 taken 5 (fallthrough)
        6: 2547:    cur_cmd->a1_matched = FALSE;
        5: 2548:}
        -: 2549:
        -: 2550:/* Read in the next line of input, and store it in the pattern space.
        -: 2551:   Return zero if there is nothing left to input. */
        -: 2552:static flagT read_pattern_space P_((struct input *, struct vector *, flagT));
        -: 2553:static flagT
function read_pattern_space called 38601 returned 100% blocks executed 100%
    38601: 2554:read_pattern_space(input, the_program, append)
        -: 2555:  struct input *input;
        -: 2556:  struct vector *the_program;
        -: 2557:  flagT append;
        -: 2558:{
    38601: 2559:  if (append_head) /* redundant test to optimize for common case */
branch  0 taken 644 (fallthrough)
branch  1 taken 37957
      644: 2560:    dump_append_queue();
call    0 returned 644
    38601: 2561:  replaced = FALSE;
    38601: 2562:  if (!append)
branch  0 taken 35712 (fallthrough)
branch  1 taken 2889
    35712: 2563:    line.length = 0;
    38601: 2564:  line.chomped = TRUE;  /* default, until proved otherwise */
        -: 2565:
    38963: 2566:  while ( ! (*input->read_fn)(input) )
call    0 returned 38963
branch  1 taken 693
branch  2 taken 38270 (fallthrough)
        -: 2567:    {
      693: 2568:      closedown(input);
call    0 returned 693
        -: 2569:
      693: 2570:      if (!*input->file_list)
branch  0 taken 331 (fallthrough)
branch  1 taken 362
        -: 2571:	{
      331: 2572:	  line.chomped = FALSE;
      331: 2573:	  return FALSE;
        -: 2574:	}
        -: 2575:
      362: 2576:      if (separate_files)
branch  0 taken 5 (fallthrough)
branch  1 taken 357
        -: 2577:	{
        5: 2578:	  input->line_number = 0;
        5: 2579:	  reset_addresses (the_program);
call    0 returned 5
        -: 2580:	}
        -: 2581:
      362: 2582:      open_next_file (*input->file_list++, input);
call    0 returned 362
        -: 2583:    }
        -: 2584:
    38270: 2585:  ++input->line_number;
    38270: 2586:  return TRUE;
        -: 2587:}
        -: 2588:
        -: 2589:
        -: 2590:static flagT last_file_with_data_p P_((struct input *));
        -: 2591:static flagT
function last_file_with_data_p called 27 returned 100% blocks executed 36%
       27: 2592:last_file_with_data_p(input)
        -: 2593:  struct input *input;
        -: 2594:{
        -: 2595:  for (;;)
    #####: 2596:    {
        -: 2597:      int ch;
        -: 2598:
       27: 2599:      closedown(input);
call    0 returned 27
       27: 2600:      if (!*input->file_list)
branch  0 taken 27 (fallthrough)
branch  1 taken 0
       27: 2601:	return TRUE;
    #####: 2602:      open_next_file(*input->file_list++, input);
call    0 never executed
    #####: 2603:      if (input->fp)
branch  0 never executed
branch  1 never executed
        -: 2604:	{
    #####: 2605:	  if ((ch = getc(input->fp)) != EOF)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2606:	    {
    #####: 2607:	      ungetc(ch, input->fp);
call    0 never executed
    #####: 2608:	      return FALSE;
        -: 2609:	    }
        -: 2610:	}
        -: 2611:    }
        -: 2612:}
        -: 2613:
        -: 2614:/* Determine if we match the `$' address. */
        -: 2615:static flagT test_eof P_((struct input *));
        -: 2616:static flagT
function test_eof called 6434 returned 100% blocks executed 68%
     6434: 2617:test_eof(input)
        -: 2618:  struct input *input;
        -: 2619:{
        -: 2620:  int ch;
        -: 2621:
     6434: 2622:  if (buffer.length)
branch  0 taken 0 (fallthrough)
branch  1 taken 6434
    #####: 2623:    return FALSE;
     6434: 2624:  if (!input->fp)
branch  0 taken 4 (fallthrough)
branch  1 taken 6430
       4*: 2625:    return separate_files || last_file_with_data_p(input);
branch  0 taken 4 (fallthrough)
branch  1 taken 0
call    2 returned 4
branch  3 taken 4 (fallthrough)
branch  4 taken 0
     6430: 2626:  if (feof(input->fp))
call    0 returned 6430
branch  1 taken 0 (fallthrough)
branch  2 taken 6430
    #####: 2627:    return separate_files || last_file_with_data_p(input);
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
     6430: 2628:  if ((ch = getc(input->fp)) == EOF)
call    0 returned 6430
branch  1 taken 23 (fallthrough)
branch  2 taken 6407
      23*: 2629:    return separate_files || last_file_with_data_p(input);
branch  0 taken 23 (fallthrough)
branch  1 taken 0
call    2 returned 23
branch  3 taken 23 (fallthrough)
branch  4 taken 0
     6407: 2630:  ungetc(ch, input->fp);
call    0 returned 6407
     6407: 2631:  return FALSE;
        -: 2632:}
        -: 2633:
        -: 2634:/* Return non-zero if the current line matches the address
        -: 2635:   pointed to by `addr'. */
        -: 2636:static flagT match_an_address_p P_((struct addr *, struct input *));
        -: 2637:static flagT
function match_an_address_p called 36112 returned 100% blocks executed 47%
    36112: 2638:match_an_address_p(addr, input)
        -: 2639:  struct addr *addr;
        -: 2640:  struct input *input;
        -: 2641:{
    36112: 2642:  switch (addr->addr_type)
branch  0 taken 0
branch  1 taken 31896
branch  2 taken 3174
branch  3 taken 0
branch  4 taken 305
branch  5 taken 737
branch  6 taken 0
        -: 2643:    {
    #####: 2644:    case addr_is_null:
    #####: 2645:      return TRUE;
        -: 2646:
    31896: 2647:    case addr_is_regex:
    31896: 2648:      return match_regex(addr->addr_regex, line.active, line.length, 0, NULL, 0);
call    0 returned 31896
        -: 2649:
     3174: 2650:    case addr_is_num:
     3174: 2651:      return (addr->addr_number == input->line_number);
        -: 2652:
    #####: 2653:    case addr_is_num_mod:
    #####: 2654:      if (addr->addr_number < addr->addr_step)
branch  0 never executed
branch  1 never executed
    #####: 2655:	return (addr->addr_number == input->line_number%addr->addr_step);
        -: 2656:      /* addr_number >= step implies we have an extra initial skip */
    #####: 2657:      if (input->line_number < addr->addr_number)
branch  0 never executed
branch  1 never executed
    #####: 2658:	return FALSE;
        -: 2659:      /* normalize */
    #####: 2660:      addr->addr_number %= addr->addr_step;
    #####: 2661:      return (addr->addr_number == 0);
        -: 2662:
      305: 2663:    case addr_is_num2:
        -: 2664:    case addr_is_step:
        -: 2665:    case addr_is_step_mod:
        -: 2666:      /* reminder: these are only meaningful for a2 addresses */
        -: 2667:      /* a2->addr_number needs to be recomputed each time a1 address
        -: 2668:	 matches for the step and step_mod types */
      305: 2669:      return (addr->addr_number <= input->line_number);
        -: 2670:
      737: 2671:    case addr_is_last:
      737: 2672:      return test_eof(input);
call    0 returned 737
        -: 2673:
    #####: 2674:    default:
    #####: 2675:      panic(_("INTERNAL ERROR: bad address type"));
call    0 never executed
        -: 2676:    }
        -: 2677:  /*NOTREACHED*/
    #####: 2678:  return FALSE;
        -: 2679:}
        -: 2680:
        -: 2681:/* return non-zero if current address is valid for cmd */
        -: 2682:static flagT match_address_p P_((struct sed_cmd *, struct input *));
        -: 2683:static flagT
function match_address_p called 95862 returned 100% blocks executed 90%
    95862: 2684:match_address_p(cmd, input)
        -: 2685:  struct sed_cmd *cmd;
        -: 2686:  struct input *input;
        -: 2687:{
    95862: 2688:  flagT addr_matched = cmd->a1_matched;
        -: 2689:
    95862: 2690:  if (addr_matched)
branch  0 taken 1582 (fallthrough)
branch  1 taken 94280
        -: 2691:    {
     1582: 2692:      if (match_an_address_p(cmd->a2, input))
call    0 returned 1582
branch  1 taken 45 (fallthrough)
branch  2 taken 1537
       45: 2693:	cmd->a1_matched = FALSE;
        -: 2694:    }
    94280: 2695:  else if (!cmd->a1 || match_an_address_p(cmd->a1, input))
branch  0 taken 34510 (fallthrough)
branch  1 taken 59770
call    2 returned 34510
branch  3 taken 2308 (fallthrough)
branch  4 taken 32202
        -: 2696:    {
    62078: 2697:      addr_matched = TRUE;
    62078: 2698:      if (cmd->a2)
branch  0 taken 60 (fallthrough)
branch  1 taken 62018
        -: 2699:	{
       60: 2700:	  cmd->a1_matched = TRUE;
       60: 2701:	  switch (cmd->a2->addr_type)
branch  0 taken 40
branch  1 taken 0
branch  2 taken 0
branch  3 taken 20
        -: 2702:	    {
       40: 2703:	    case addr_is_regex:
       40: 2704:	      break;
    #####: 2705:	    case addr_is_step:
    #####: 2706:	      cmd->a2->addr_number = input->line_number + cmd->a2->addr_step;
    #####: 2707:	      break;
    #####: 2708:	    case addr_is_step_mod:
    #####: 2709:	      cmd->a2->addr_number = input->line_number + cmd->a2->addr_step
    #####: 2710:				     - (input->line_number%cmd->a2->addr_step);
    #####: 2711:	      break;
       20: 2712:	    default:
       20: 2713:	      if (match_an_address_p(cmd->a2, input))
call    0 returned 20
branch  1 taken 1 (fallthrough)
branch  2 taken 19
        1: 2714:		cmd->a1_matched = FALSE;
       20: 2715:	      break;
        -: 2716:	    }
        -: 2717:	}
        -: 2718:    }
    95862: 2719:  if (cmd->addr_bang)
branch  0 taken 26530 (fallthrough)
branch  1 taken 69332
    26530: 2720:    return !addr_matched;
    69332: 2721:  return addr_matched;
        -: 2722:}
        -: 2723:
        -: 2724:
        -: 2725:static void do_list P_((int line_len));
        -: 2726:static void
function do_list called 1066 returned 100% blocks executed 75%
     1066: 2727:do_list(line_len)
        -: 2728:     int line_len;
        -: 2729:{
     1066: 2730:  unsigned char *p = CAST(unsigned char *)line.active;
     1066: 2731:  countT len = line.length;
     1066: 2732:  countT width = 0;
        -: 2733:  char obuf[180];	/* just in case we encounter a 512-bit char (;-) */
        -: 2734:  char *o;
        -: 2735:  size_t olen;
        -: 2736:
    20928: 2737:  for (; len--; ++p) {
branch  0 taken 19862
branch  1 taken 1066 (fallthrough)
    19862: 2738:      o = obuf;
        -: 2739:      
        -: 2740:      /* Some locales define 8-bit characters as printable.  This makes the
        -: 2741:	 testsuite fail at 8to7.sed because the `l' command in fact will not
        -: 2742:	 convert the 8-bit characters. */
        -: 2743:#if defined isascii || defined HAVE_ISASCII
    19862: 2744:      if (isascii(*p) && ISPRINT(*p)) {
branch  0 taken 19862 (fallthrough)
branch  1 taken 0
branch  2 taken 19367 (fallthrough)
branch  3 taken 495
        -: 2745:#else
        -: 2746:      if (ISPRINT(*p)) {
        -: 2747:#endif
    19367: 2748:	  *o++ = *p;
    19367: 2749:	  if (*p == '\\')
branch  0 taken 0 (fallthrough)
branch  1 taken 19367
    #####: 2750:	    *o++ = '\\';
        -: 2751:      } else {
      495: 2752:	  *o++ = '\\';
      495: 2753:	  switch (*p) {
branch  0 taken 0
branch  1 taken 0
branch  2 taken 0
branch  3 taken 233
branch  4 taken 0
branch  5 taken 166
branch  6 taken 0
branch  7 taken 96
        -: 2754:#if defined __STDC__ && __STDC__-0
    #####: 2755:	    case '\a': *o++ = 'a'; break;
        -: 2756:#else /* Not STDC; we'll just assume ASCII */
        -: 2757:	    case 007:  *o++ = 'a'; break;
        -: 2758:#endif
    #####: 2759:	    case '\b': *o++ = 'b'; break;
    #####: 2760:	    case '\f': *o++ = 'f'; break;
      233: 2761:	    case '\n': *o++ = 'n'; break;
    #####: 2762:	    case '\r': *o++ = 'r'; break;
      166: 2763:	    case '\t': *o++ = 't'; break;
    #####: 2764:	    case '\v': *o++ = 'v'; break;
       96: 2765:	    default:
       96: 2766:	      sprintf(o, "%03o", *p);
       96: 2767:	      o += strlen(o);
       96: 2768:	      break;
        -: 2769:	    }
        -: 2770:      }
    19862: 2771:      olen = o - obuf;
    19862: 2772:      if (width+olen >= line_len && line_len > 0) {
branch  0 taken 124 (fallthrough)
branch  1 taken 19738
branch  2 taken 124 (fallthrough)
branch  3 taken 0
      124: 2773:	  ck_fwrite("\\\n", 1, 2, output_file);
call    0 returned 124
      124: 2774:	  width = 0;
        -: 2775:      }
    19862: 2776:      ck_fwrite(obuf, 1, olen, output_file);
call    0 returned 19862
    19862: 2777:      width += olen;
        -: 2778:  }
     1066: 2779:  ck_fwrite("$\n", 1, 2, output_file);
call    0 returned 1066
     1066: 2780:}
        -: 2781:
        -: 2782:static enum replacement_types append_replacement P_((struct line *, struct replacement *,
        -: 2783:				                     struct re_registers *,
        -: 2784:				                     enum replacement_types));
        -: 2785:static enum replacement_types
function append_replacement called 3507 returned 100% blocks executed 81%
     3507: 2786:append_replacement (buf, p, regs, repl_mod)
        -: 2787:  struct line *buf;
        -: 2788:  struct replacement *p;
        -: 2789:  struct re_registers *regs;
        -: 2790:  enum replacement_types repl_mod;
        -: 2791:{
     7078: 2792:  for (; p; p=p->next)
branch  0 taken 3571
branch  1 taken 3507 (fallthrough)
        -: 2793:    {
     3571: 2794:      int i = p->subst_id;
        -: 2795:      enum replacement_types curr_type;
        -: 2796:
        -: 2797:      /* Apply a \[lu] modifier that was given earlier, but which we
        -: 2798:	 have not had yet the occasion to apply.  But don't do it
        -: 2799:	 if this replacement has a modifier of its own. */
     7142: 2800:      curr_type = (p->repl_type & repl_modifiers)
        -: 2801:	? p->repl_type
    3571*: 2802:	: p->repl_type | repl_mod;
branch  0 taken 0 (fallthrough)
branch  1 taken 3571
        -: 2803:
     3571: 2804:      repl_mod = 0;
     3571: 2805:      if (p->prefix_length)
branch  0 taken 3558 (fallthrough)
branch  1 taken 13
        -: 2806:	{
     3558: 2807:	  str_append_modified(buf, p->prefix, p->prefix_length,
call    0 returned 3558
        -: 2808:			      curr_type);
     3558: 2809:	  curr_type &= ~repl_modifiers;
        -: 2810:	}
        -: 2811:
     3571: 2812:      if (0 <= i)
branch  0 taken 23 (fallthrough)
branch  1 taken 3548
      23*: 2813:	if (regs->end[i] == regs->start[i] && p->repl_type & repl_modifiers)
branch  0 taken 0 (fallthrough)
branch  1 taken 23
branch  2 never executed
branch  3 never executed
        -: 2814:	  /* Save this modifier, we shall apply it later.
        -: 2815:	     e.g. in s/()([a-z])/\u\1\2/
        -: 2816:	     the \u modifier is applied to \2, not \1 */
    #####: 2817:	  repl_mod = curr_type & repl_modifiers;
        -: 2818:
        -: 2819:	else
       23: 2820:	  str_append_modified(buf, line.active + regs->start[i],
       23: 2821:			      CAST(size_t)(regs->end[i] - regs->start[i]),
call    0 returned 23
        -: 2822:			      curr_type);
        -: 2823:    }
        -: 2824:
     3507: 2825:  return repl_mod;
        -: 2826:}
        -: 2827:
        -: 2828:static void do_subst P_((struct subst *));
        -: 2829:static void
function do_subst called 13362 returned 100% blocks executed 89%
    13362: 2830:do_subst(sub)
        -: 2831:  struct subst *sub;
        -: 2832:{
    13362: 2833:  size_t start = 0;     /* where to start scan for (next) match in LINE */
    13362: 2834:  size_t last_end = 0;  /* where did the last successful match end in LINE */
    13362: 2835:  countT count = 0;     /* number of matches found */
    13362: 2836:  flagT again = TRUE;
        -: 2837:
        -: 2838:#define MAX_BACKREFERENCES 10
        -: 2839:  static struct re_registers regs;
        -: 2840:
    13362: 2841:  if (s_accum.alloc == 0)
branch  0 taken 186 (fallthrough)
branch  1 taken 13176
      186: 2842:    line_init(&s_accum, INITIAL_BUFFER_SIZE);
call    0 returned 186
    13362: 2843:  s_accum.length = 0;
        -: 2844:
        -: 2845:  /* The first part of the loop optimizes s/xxx// when xxx is at the
        -: 2846:     start, and s/xxx$// */
    13362: 2847:  if (!match_regex(sub->regx, line.active, line.length, start,
call    0 returned 13362
branch  1 taken 10848 (fallthrough)
branch  2 taken 2514
        -: 2848:		   &regs, MAX_BACKREFERENCES))
    10848: 2849:    return;
        -: 2850:
     2514: 2851:  if (!sub->replacement && sub->numb <= 1)
branch  0 taken 8 (fallthrough)
branch  1 taken 2506
branch  2 taken 8 (fallthrough)
branch  3 taken 0
       8*: 2852:    if (regs.start[0] == 0 && !sub->global)
branch  0 taken 0 (fallthrough)
branch  1 taken 8
branch  2 never executed
branch  3 never executed
        -: 2853:      {
        -: 2854:	/* We found a match, set the `replaced' flag. */
    #####: 2855:	replaced = TRUE;
        -: 2856:
    #####: 2857:	line.active += regs.end[0];
    #####: 2858:	line.length -= regs.end[0];
    #####: 2859:	line.alloc -= regs.end[0];
    #####: 2860:	goto post_subst;
        -: 2861:      }
        8: 2862:    else if (regs.end[0] == line.length)
branch  0 taken 8 (fallthrough)
branch  1 taken 0
        -: 2863:      {
        -: 2864:	/* We found a match, set the `replaced' flag. */
        8: 2865:	replaced = TRUE;
        -: 2866:
        8: 2867:	line.length = regs.start[0];
        8: 2868:	goto post_subst;
        -: 2869:      }
        -: 2870:
        -: 2871:  do
        -: 2872:    {
     4830: 2873:      enum replacement_types repl_mod = 0;
        -: 2874:
     4830: 2875:      size_t offset = regs.start[0];
     4830: 2876:      size_t matched = regs.end[0] - regs.start[0];
        -: 2877:
        -: 2878:      /* Copy stuff to the left of this match into the output string. */
     4830: 2879:      if (start < offset)
branch  0 taken 981 (fallthrough)
branch  1 taken 3849
      981: 2880:	str_append(&s_accum, line.active + start, offset - start);
call    0 returned 981
        -: 2881:
        -: 2882:      /* If we're counting up to the Nth match, are we there yet?
        -: 2883:	 And even if we are there, there is another case we have to
        -: 2884:	 skip: are we matching an empty string immediately following
        -: 2885:	 another match?
        -: 2886:
        -: 2887:	 This latter case avoids that baaaac, when passed through
        -: 2888:	 s,a*,x,g, gives `xbxxcx' instead of xbxcx.  This behavior is
        -: 2889:	 unacceptable because it is not consistently applied (for
        -: 2890:	 example, `baaaa' gives `xbx', not `xbxx'). */
        -: 2891:#ifdef FAULTY_F_KRM_1
        -: 2892:      if ((matched > 0 && count == 0 || offset > last_end)
        -: 2893:#else
        -: 2894:#ifdef FAULTY_F_KRM_2
        -: 2895:      if (( matched > 0 || count == 0 && offset < last_end)	
        -: 2896:#else
        -: 2897:#ifdef FAULTY_F_KRM_3
        -: 2898:      if (( matched >= 0 || count == 0 || offset < last_end)
        -: 2899:#else
        -: 2900:#ifdef FAULTY_F_KRM_4
        -: 2901:      if ((matched < 0)
        -: 2902:#else
     4830: 2903:      if(( matched > 0 || count == 0 || offset < last_end)
branch  0 taken 2570 (fallthrough)
branch  1 taken 2260
branch  2 taken 1323 (fallthrough)
branch  3 taken 1247
branch  4 taken 0 (fallthrough)
branch  5 taken 1323
        -: 2904:#endif
        -: 2905:#endif
        -: 2906:#endif
        -: 2907:#endif
        -: 2908:
        -: 2909:#ifndef FAULTY_F_KRM_5
     3507: 2910:	  && (last_end = regs.end[0], ++count >= sub->numb))
branch  0 taken 3507 (fallthrough)
branch  1 taken 0
        -: 2911:#else
        -: 2912:	  && (last_end = regs.end[0], count++ > sub->numb))
        -: 2913:#endif
        -: 2914:	{
        -: 2915:	  /* We found a match, set the `replaced' flag. */
     3507: 2916:	  replaced = TRUE;
        -: 2917:
        -: 2918:	  /* Now expand the replacement string into the output string. */
     3507: 2919:	  repl_mod = append_replacement (&s_accum, sub->replacement, &regs, repl_mod);
call    0 returned 3507
     3507: 2920:	  again = sub->global;
        -: 2921:	}
        -: 2922:      else
        -: 2923:	{
        -: 2924:	  /* The match was not replaced.  Copy the text until its
        -: 2925:	     end; if it was vacuous, skip over one character and
        -: 2926:	     add that character to the output.  */
     1323: 2927:	  if (matched == 0)
branch  0 taken 1323 (fallthrough)
branch  1 taken 0
        -: 2928:	    {
     1323: 2929:	      if (start < line.length)
branch  0 taken 484 (fallthrough)
branch  1 taken 839
      484: 2930:		matched = 1;
        -: 2931:#ifndef FAULTY_F_KRM_6
        -: 2932:	      else
      839: 2933:		break;
        -: 2934:#else
        -: 2935:              /* do nothing */
        -: 2936:#endif
        -: 2937:	    }
        -: 2938:
        -: 2939:#ifndef FAULTY_F_KRM_7
      484: 2940:	  str_append(&s_accum, line.active + offset, matched);
call    0 returned 484
        -: 2941:#else
        -: 2942:          str_append(&s_accum, line.active + offset + 1, matched);
        -: 2943:#endif
        -: 2944:	}
        -: 2945:
        -: 2946:      /* Start after the match.  */
        -: 2947:#ifndef FAULTY_F_KRM_8
     3991: 2948:      start = offset + matched;
        -: 2949:#else
        -: 2950:      start = offset + matched + 1;
        -: 2951:#endif
        -: 2952:    }
        -: 2953:
        -: 2954:#ifndef FAULTY_F_KRM_9
        -: 2955:  while (again
     3814: 2956:	 && start <= line.length
branch  0 taken 3814 (fallthrough)
branch  1 taken 0
        -: 2957:#else
        -: 2958:  while (1
        -: 2959:#endif
     7805: 2960:	 && match_regex(sub->regx, line.active, line.length, start,
branch  0 taken 3814 (fallthrough)
branch  1 taken 177
call    2 returned 3814
branch  3 taken 2324
branch  4 taken 1490 (fallthrough)
        -: 2961:			&regs, MAX_BACKREFERENCES));
        -: 2962:
        -: 2963:  /* Copy stuff to the right of the last match into the output string. */
     2506: 2964:  if (start < line.length)
branch  0 taken 903 (fallthrough)
branch  1 taken 1603
      903: 2965:    str_append(&s_accum, line.active + start, line.length-start);
call    0 returned 903
     2506: 2966:  s_accum.chomped = line.chomped;
        -: 2967:
        -: 2968:  /* Exchange line and s_accum.  This can be much cheaper
        -: 2969:     than copying s_accum.active into line.text (for huge lines). */
     2506: 2970:  line_exchange(&line, &s_accum);
call    0 returned 2506
        -: 2971:
        -: 2972:  /* Finish up. */
     2506: 2973:  if (count < sub->numb)
branch  0 taken 0 (fallthrough)
branch  1 taken 2506
    #####: 2974:    return;
        -: 2975:
     2506: 2976: post_subst:
     2514: 2977:  if (sub->print & 1)
branch  0 taken 1297 (fallthrough)
branch  1 taken 1217
     1297: 2978:    output_line(line.active, line.length, line.chomped, output_file);
call    0 returned 1297
        -: 2979:
     2514: 2980:  if (sub->eval)
branch  0 taken 0 (fallthrough)
branch  1 taken 2514
        -: 2981:    {
        -: 2982:#ifdef HAVE_POPEN
        -: 2983:      FILE *pipe;
        -: 2984:      s_accum.length = 0;
        -: 2985:
        -: 2986:      str_append (&line, "", 1);
        -: 2987:      pipe = popen(line.active, "r");
        -: 2988:      
        -: 2989:      if (pipe != NULL) 
        -: 2990:	{
        -: 2991:	  while (!feof (pipe)) 
        -: 2992:	    {
        -: 2993:	      char buf[4096];
        -: 2994:	      int n = fread (buf, sizeof(char), 4096, pipe);
        -: 2995:	      if (n > 0)
        -: 2996:		str_append(&s_accum, buf, n);
        -: 2997:	    }
        -: 2998:	  
        -: 2999:	  pclose (pipe);
        -: 3000:
        -: 3001:	  line_exchange(&line, &s_accum);
        -: 3002:	  if (line.length &&
        -: 3003:	      line.active[line.length - 1] == '\n')
        -: 3004:	    line.length--;
        -: 3005:	}
        -: 3006:      else
        -: 3007:	panic(_("error in subprocess"));
        -: 3008:#else
    #####: 3009:      panic(_("option `e' not supported"));
call    0 never executed
        -: 3010:#endif
        -: 3011:    } 
        -: 3012:  
     2514: 3013:  if (sub->print & 2)
branch  0 taken 0 (fallthrough)
branch  1 taken 2514
    #####: 3014:    output_line(line.active, line.length, line.chomped, output_file);
call    0 never executed
     2514: 3015:  if (sub->fp)
branch  0 taken 1442 (fallthrough)
branch  1 taken 1072
     1442: 3016:    output_line(line.active, line.length, line.chomped, sub->fp);
call    0 returned 1442
        -: 3017:}
        -: 3018:
        -: 3019:#ifdef EXPERIMENTAL_DASH_N_OPTIMIZATION
        -: 3020:/* Used to attempt a simple-minded optimization. */
        -: 3021:
        -: 3022:static countT branches;
        -: 3023:
        -: 3024:static countT count_branches P_((struct vector *));
        -: 3025:static countT
        -: 3026:count_branches(program)
        -: 3027:  struct vector *program;
        -: 3028:{
        -: 3029:  struct sed_cmd *cur_cmd = program->v;
        -: 3030:  countT isn_cnt = program->v_length;
        -: 3031:  countT cnt = 0;
        -: 3032:
        -: 3033:  while (isn_cnt-- > 0)
        -: 3034:    {
        -: 3035:      switch (cur_cmd->cmd)
        -: 3036:	{
        -: 3037:	case 'b':
        -: 3038:	case 't':
        -: 3039:	case 'T':
        -: 3040:	case '{':
        -: 3041:	  ++cnt;
        -: 3042:	}
        -: 3043:    }
        -: 3044:  return cnt;
        -: 3045:}
        -: 3046:
        -: 3047:static struct sed_cmd *shrink_program P_((struct vector *, struct sed_cmd *));
        -: 3048:static struct sed_cmd *
        -: 3049:shrink_program(vec, cur_cmd)
        -: 3050:  struct vector *vec;
        -: 3051:  struct sed_cmd *cur_cmd;
        -: 3052:{
        -: 3053:  struct sed_cmd *v = vec->v;
        -: 3054:  struct sed_cmd *last_cmd = v + vec->v_length;
        -: 3055:  struct sed_cmd *p;
        -: 3056:  countT cmd_cnt;
        -: 3057:
        -: 3058:  for (p=v; p < cur_cmd; ++p)
        -: 3059:    if (p->cmd != ':')
        -: 3060:      MEMCPY(v++, p, sizeof *v);
        -: 3061:  cmd_cnt = v - vec->v;
        -: 3062:
        -: 3063:  for (; p < last_cmd; ++p)
        -: 3064:    if (p->cmd != ':')
        -: 3065:      MEMCPY(v++, p, sizeof *v);
        -: 3066:  vec->v_length = v - vec->v;
        -: 3067:
        -: 3068:  return (0 < vec->v_length) ? (vec->v + cmd_cnt) : CAST(struct sed_cmd *)0;
        -: 3069:}
        -: 3070:#endif /*EXPERIMENTAL_DASH_N_OPTIMIZATION*/
        -: 3071:
        -: 3072:/* Execute the program `vec' on the current input line.
        -: 3073:   Return exit status if caller should quit, -1 otherwise. */
        -: 3074:static int execute_program P_((struct vector *, struct input *));
        -: 3075:static int
function execute_program called 32591 returned 100% blocks executed 71%
    32591: 3076:execute_program(vec, input)
        -: 3077:  struct vector *vec;
        -: 3078:  struct input *input;
        -: 3079:{
        -: 3080:  struct sed_cmd *cur_cmd;
        -: 3081:  struct sed_cmd *end_cmd;
        -: 3082:
    32591: 3083:  cur_cmd = vec->v;
    32591: 3084:  end_cmd = vec->v + vec->v_length;
   123623: 3085:  while (cur_cmd < end_cmd)
branch  0 taken 95862
branch  1 taken 27761 (fallthrough)
        -: 3086:    {
    95862: 3087:      if (match_address_p(cur_cmd, input))
call    0 returned 95862
branch  1 taken 85138 (fallthrough)
branch  2 taken 10724
        -: 3088:	{
    85138: 3089:	  switch (cur_cmd->cmd)
branch  0 taken 546
branch  1 taken 24091
branch  2 taken 25614
branch  3 taken 2495
branch  4 taken 1624
branch  5 taken 1381
branch  6 taken 0
branch  7 taken 10
branch  8 taken 10
branch  9 taken 18
branch 10 taken 12
branch 11 taken 391
branch 12 taken 1066
branch 13 taken 0
branch 14 taken 2798
branch 15 taken 2899
branch 16 taken 2054
branch 17 taken 2357
branch 18 taken 0
branch 19 taken 29
branch 20 taken 98
branch 21 taken 0
branch 22 taken 13362
branch 23 taken 13
branch 24 taken 0
branch 25 taken 1689
branch 26 taken 0
branch 27 taken 5
branch 28 taken 2348
branch 29 taken 228
branch 30 taken 0
        -: 3090:	    {
      546: 3091:	    case 'a':
        -: 3092:	      {
      546: 3093:		struct append_queue *aq = next_append_slot();
call    0 returned 546
      546: 3094:		aq->text = cur_cmd->x.cmd_txt.text;
      546: 3095:		aq->textlen = cur_cmd->x.cmd_txt.text_length;
        -: 3096:	      }
      546: 3097:	      break;
        -: 3098:
    24091: 3099:	    case '{':
        -: 3100:	    case 'b':
    24091: 3101:	      cur_cmd = vec->v + cur_cmd->x.jump_index;
    24091: 3102:	      continue;
        -: 3103:
    25614: 3104:	    case '}':
        -: 3105:	    case ':':
        -: 3106:	      /* Executing labels and block-ends are easy. */
    25614: 3107:	      break;
        -: 3108:
     2495: 3109:	    case 'c':
     2495: 3110:	      if (!cur_cmd->a1_matched)
branch  0 taken 1727 (fallthrough)
branch  1 taken 768
     1727: 3111:		output_line(cur_cmd->x.cmd_txt.text,
call    0 returned 1727
        -: 3112:			    cur_cmd->x.cmd_txt.text_length, FALSE, output_file);
        -: 3113:	      /* POSIX.2 is silent about c starting a new cycle,
        -: 3114:		 but it seems to be expected (and make sense). */
        -: 3115:	      /* Fall Through */
        -: 3116:	    case 'd':
     4119: 3117:	      line.length = 0;
     4119: 3118:	      line.chomped = FALSE;
     4119: 3119:	      return -1;
        -: 3120:
     1381: 3121:	    case 'D':
      717: 3122:	      {
     1381: 3123:		char *p = memchr(line.active, '\n', line.length);
     1381: 3124:		if (!p)
branch  0 taken 664 (fallthrough)
branch  1 taken 717
        -: 3125:		  {
      664: 3126:		    line.length = 0;
      664: 3127:		    line.chomped = FALSE;
      664: 3128:		    return -1;
        -: 3129:		  }
      717: 3130:		++p;
      717: 3131:		line.alloc -= p - line.active;
      717: 3132:		line.length -= p - line.active;
      717: 3133:		line.active += p - line.active;
        -: 3134:
        -: 3135:		/* reset to start next cycle without reading a new line: */
      717: 3136:		cur_cmd = vec->v;
      717: 3137:		continue;
        -: 3138:	      }
        -: 3139:
    #####: 3140:	    case 'e': {
        -: 3141:#ifdef HAVE_POPEN
        -: 3142:	      FILE *pipe;
        -: 3143:	      int cmd_length = cur_cmd->x.cmd_txt.text_length;
        -: 3144:	      if (s_accum.alloc == 0)
        -: 3145:		line_init(&s_accum, INITIAL_BUFFER_SIZE);
        -: 3146:	      s_accum.length = 0;
        -: 3147:
        -: 3148:	      if (!cmd_length)
        -: 3149:		{
        -: 3150:		  str_append (&line, "", 1);
        -: 3151:		  pipe = popen(line.active, "r");
        -: 3152:		} 
        -: 3153:	      else
        -: 3154:		{
        -: 3155:		  cur_cmd->x.cmd_txt.text[cmd_length - 1] = 0;
        -: 3156:		  pipe = popen(cur_cmd->x.cmd_txt.text, "r");
        -: 3157:		}
        -: 3158:
        -: 3159:	      if (pipe != NULL) 
        -: 3160:		{
        -: 3161:		  while (!feof (pipe)) 
        -: 3162:		    {
        -: 3163:		      char buf[4096];
        -: 3164:		      int n = fread (buf, sizeof(char), 4096, pipe);
        -: 3165:		      if (n > 0)
        -: 3166:			if (!cmd_length)
        -: 3167:			  str_append(&s_accum, buf, n);
        -: 3168:			else
        -: 3169:			  output_line(buf, n, FALSE, output_file);
        -: 3170:		    }
        -: 3171:		  
        -: 3172:		  pclose (pipe);
        -: 3173:		  if (!cmd_length)
        -: 3174:		    {
        -: 3175:		      /* Store into pattern space for plain `e' commands */
        -: 3176:		      if (s_accum.length &&
        -: 3177:			  s_accum.active[s_accum.length - 1] == '\n')
        -: 3178:			s_accum.length--;
        -: 3179:
        -: 3180:		      /* Exchange line and s_accum.  This can be much
        -: 3181:			 cheaper than copying s_accum.active into line.text
        -: 3182:			 (for huge lines). */
        -: 3183:		      line_exchange(&line, &s_accum);
        -: 3184:		    }
        -: 3185:		}
        -: 3186:	      else
        -: 3187:		panic(_("error in subprocess"));
        -: 3188:#else
    #####: 3189:	      panic(_("`e' command not supported"));
call    0 never executed
        -: 3190:#endif
    #####: 3191:	      break;
        -: 3192:	    }
        -: 3193:
       10: 3194:	    case 'g':
       10: 3195:	      line_copy(&hold, &line);
call    0 returned 10
       10: 3196:	      break;
        -: 3197:
       10: 3198:	    case 'G':
       10: 3199:	      line_append(&hold, &line);
call    0 returned 10
       10: 3200:	      break;
        -: 3201:
       18: 3202:	    case 'h':
       18: 3203:	      line_copy(&line, &hold);
call    0 returned 18
       18: 3204:	      break;
        -: 3205:
       12: 3206:	    case 'H':
       12: 3207:	      line_append(&line, &hold);
call    0 returned 12
       12: 3208:	      break;
        -: 3209:
      391: 3210:	    case 'i':
      391: 3211:	      output_line(cur_cmd->x.cmd_txt.text,
call    0 returned 391
        -: 3212:			  cur_cmd->x.cmd_txt.text_length, FALSE, output_file);
      391: 3213:	      break;
        -: 3214:
     1066: 3215:	    case 'l':
    1066*: 3216:	      do_list(cur_cmd->x.int_arg == -1
branch  0 taken 0 (fallthrough)
branch  1 taken 1066
call    2 returned 1066
        -: 3217:		      ? lcmd_out_line_len
        -: 3218:		      : cur_cmd->x.int_arg);
     1066: 3219:	      break;
        -: 3220:
    #####: 3221:	    case 'L':
    #####: 3222:	      fmt(line.active, line.active + line.length,
call    0 never executed
    #####: 3223:		  cur_cmd->x.int_arg == -1
branch  0 never executed
branch  1 never executed
        -: 3224:		  ? lcmd_out_line_len
        -: 3225:		  : cur_cmd->x.int_arg,
        -: 3226:		  output_file);
    #####: 3227:	      break;
        -: 3228:
     2798: 3229:	    case 'n':
     2798: 3230:	      if (!no_default_output)
branch  0 taken 783 (fallthrough)
branch  1 taken 2015
      783: 3231:		output_line(line.active, line.length, line.chomped, output_file);
call    0 returned 783
     2798: 3232:	      if (test_eof(input) || !read_pattern_space(input, vec, FALSE))
call    0 returned 2798
branch  1 taken 2790 (fallthrough)
branch  2 taken 8
call    3 returned 2790
branch  4 taken 0 (fallthrough)
branch  5 taken 2790
        8: 3233:		return -1;
     2790: 3234:	      break;
        -: 3235:
     2899: 3236:	    case 'N':
     2899: 3237:	      str_append(&line, "\n", 1);
call    0 returned 2899
     2899: 3238:	      if (test_eof(input) || !read_pattern_space(input, vec, TRUE))
call    0 returned 2899
branch  1 taken 2889 (fallthrough)
branch  2 taken 10
call    3 returned 2889
branch  4 taken 0 (fallthrough)
branch  5 taken 2889
       10: 3239:		return -1;
     2889: 3240:	      break;
        -: 3241:
     2054: 3242:	    case 'p':
     2054: 3243:	      output_line(line.active, line.length, line.chomped, output_file);
call    0 returned 2054
     2054: 3244:	      break;
        -: 3245:
     2357: 3246:	    case 'P':
        -: 3247:	      {
     2357: 3248:		char *p = memchr(line.active, '\n', line.length);
     2357: 3249:		output_line(line.active, p ? p - line.active : line.length,
branch  0 taken 1559 (fallthrough)
branch  1 taken 798
branch  2 taken 798 (fallthrough)
branch  3 taken 1559
call    4 returned 2357
        -: 3250:			    p ? 1 : line.chomped, output_file);
        -: 3251:	      }
     2357: 3252:	      break;
        -: 3253:
    #####: 3254:	    case 'Q':
    #####: 3255:	      line.length = 0;
    #####: 3256:	      line.chomped = FALSE;
        -: 3257:	      /* Fall through */
        -: 3258:
       29: 3259:	    case 'q':
      29*: 3260:	      return cur_cmd->x.int_arg == -1 ? 0 : cur_cmd->x.int_arg;
branch  0 taken 0 (fallthrough)
branch  1 taken 29
        -: 3261:
       98: 3262:	    case 'r':
       98: 3263:	      if (cur_cmd->x.fname)
branch  0 taken 98 (fallthrough)
branch  1 taken 0
        -: 3264:		{
       98: 3265:		  struct append_queue *aq = next_append_slot();
call    0 returned 98
       98: 3266:		  aq->fname = cur_cmd->x.fname;
        -: 3267:		}
       98: 3268:	      break;
        -: 3269:
    #####: 3270:	    case 'R':
    #####: 3271:	      if (cur_cmd->x.fp && !feof (cur_cmd->x.fp))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 3272:		{
        -: 3273:		  struct append_queue *aq;
        -: 3274:		  size_t buflen;
    #####: 3275:		  char *text = NULL;
        -: 3276:		  int result;
        -: 3277:
    #####: 3278:		  result = getline (&text, &buflen, cur_cmd->x.fp);
call    0 never executed
        -: 3279:
    #####: 3280:		  if (result != EOF)
branch  0 never executed
branch  1 never executed
        -: 3281:		    {
    #####: 3282:		      aq = next_append_slot();
call    0 never executed
    #####: 3283:		      aq->free = TRUE;
    #####: 3284:		      aq->text = text;
    #####: 3285:		      aq->textlen = result;
        -: 3286:		    }
        -: 3287:		}
    #####: 3288:	      break;
        -: 3289:
    13362: 3290:	    case 's':
    13362: 3291:	      do_subst(cur_cmd->x.cmd_subst);
call    0 returned 13362
    13362: 3292:	      break;
        -: 3293:
       13: 3294:	    case 't':
       13: 3295:	      if (replaced)
branch  0 taken 6 (fallthrough)
branch  1 taken 7
        -: 3296:		{
        6: 3297:		  replaced = FALSE;
        6: 3298:		  cur_cmd = vec->v + cur_cmd->x.jump_index;
        6: 3299:		  continue;
        -: 3300:		}
        7: 3301:	      break;
        -: 3302:
    #####: 3303:	    case 'T':
    #####: 3304:	      if (!replaced)
branch  0 never executed
branch  1 never executed
        -: 3305:		{
    #####: 3306:		  cur_cmd = vec->v + cur_cmd->x.jump_index;
    #####: 3307:		  continue;
        -: 3308:		}
        -: 3309:	      else
    #####: 3310:		replaced = FALSE;
    #####: 3311:	      break;
        -: 3312:
     1689: 3313:	    case 'w':
     1689: 3314:	      if (cur_cmd->x.fp)
branch  0 taken 1689 (fallthrough)
branch  1 taken 0
     1689: 3315:		output_line(line.active, line.length,
call    0 returned 1689
        -: 3316:			    line.chomped, cur_cmd->x.fp);
     1689: 3317:	      break;
        -: 3318:
    #####: 3319:	    case 'W':
    #####: 3320:	      if (cur_cmd->x.fp)
branch  0 never executed
branch  1 never executed
        -: 3321:		{
    #####: 3322:		  char *p = memchr(line.active, '\n', line.length);
    #####: 3323:		  output_line(line.active, p ? p - line.active : line.length,
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -: 3324:			      p ? 1 : line.chomped, cur_cmd->x.fp);
        -: 3325:		}
    #####: 3326:	      break;
        -: 3327:
        5: 3328:	    case 'x':
        5: 3329:	      line_exchange(&line, &hold);
call    0 returned 5
        5: 3330:	      break;
        -: 3331:
     2348: 3332:	    case 'y':
        -: 3333:	      {
        -: 3334:#if defined MBS_SUPPORT && !defined REG_PERL
        -: 3335:	       if (MB_CUR_MAX > 1)
        -: 3336:		 {
        -: 3337:		   int idx, prev_idx; /* index in the input line.  */
        -: 3338:		   char **trans;
        -: 3339:		   mbstate_t cur_stat;
        -: 3340:		   memset(&cur_stat, 0, sizeof(mbstate_t));
        -: 3341:		   for (idx = 0; idx < line.length;)
        -: 3342:		     {
        -: 3343:		       int mbclen, i;
        -: 3344:		       mbclen = mbrlen(line.active + idx, line.length - idx,
        -: 3345:				       &cur_stat);
        -: 3346:		       /* An invalid sequence, or a truncated multibyte
        -: 3347:			  character.  We treat it as a singlebyte character.
        -: 3348:		       */
        -: 3349:		       if (mbclen == (size_t) -1 || mbclen == (size_t) -2
        -: 3350:			   || mbclen == 0)
        -: 3351:			 mbclen = 1;
        -: 3352:
        -: 3353:		       trans = cur_cmd->x.translatemb;
        -: 3354:		       /* `i' indicate i-th translate pair.  */
        -: 3355:		       for (i = 0; trans[2*i] != NULL; i++)
        -: 3356:			 {
        -: 3357:			   if (strncmp(line.active + idx, trans[2*i], mbclen)
        -: 3358:			       == 0)
        -: 3359:			     {
        -: 3360:			       flagT move_remain_buffer = FALSE;
        -: 3361:			       int trans_len = strlen(trans[2*i+1]);
        -: 3362:
        -: 3363:			       if (mbclen < trans_len)
        -: 3364:				 {
        -: 3365:				   int new_len;
        -: 3366:				   new_len = line.length + 1 + trans_len - mbclen;
        -: 3367:				   /* We must extend the line buffer.  */
        -: 3368:				   if (line.alloc < new_len)
        -: 3369:				     {
        -: 3370:				       /* And we must resize the buffer.  */
        -: 3371:				       resize_line(&line, new_len);
        -: 3372:				     }
        -: 3373:				   move_remain_buffer = TRUE;
        -: 3374:				 }
        -: 3375:			       else if (mbclen > trans_len)
        -: 3376:				 {
        -: 3377:				   /* We must truncate the line buffer.  */
        -: 3378:				   move_remain_buffer = TRUE;
        -: 3379:				 }
        -: 3380:			       prev_idx = idx;
        -: 3381:			       if (move_remain_buffer)
        -: 3382:				 {
        -: 3383:				   int move_len, move_offset;
        -: 3384:				   char *move_from, *move_to;
        -: 3385:				   /* Move the remaining with \0.  */
        -: 3386:				   move_from = line.active + idx + mbclen;
        -: 3387:				   move_to = line.active + idx + trans_len;
        -: 3388:				   move_len = line.length + 1 - idx - mbclen;
        -: 3389:				   move_offset = trans_len - mbclen;
        -: 3390:				   memmove(move_to, move_from, move_len);
        -: 3391:				   line.length += move_offset;
        -: 3392:				   idx += move_offset;
        -: 3393:				 }
        -: 3394:			       strncpy(line.active + prev_idx, trans[2*i+1],
        -: 3395:				       trans_len);
        -: 3396:			       break;
        -: 3397:			     }
        -: 3398:			 }
        -: 3399:		       idx += mbclen;
        -: 3400:		     }
        -: 3401:		 }
        -: 3402:	       else
        -: 3403:#endif /* MBS_SUPPORT */
        -: 3404:		 {
        -: 3405:		   unsigned char *p, *e;
     2348: 3406:		   p = CAST(unsigned char *)line.active;
    44332: 3407:		   for (e=p+line.length; p<e; ++p)
branch  0 taken 41984
branch  1 taken 2348 (fallthrough)
    41984: 3408:		     *p = cur_cmd->x.translate[*p];
        -: 3409:		 }
        -: 3410:	      }
     2348: 3411:	      break;
        -: 3412:
      228: 3413:	    case '=':
      228: 3414:	      fprintf(output_file, "%lu\n",
      228: 3415:		      CAST(unsigned long)input->line_number);
call    0 returned 228
      228: 3416:	      break;
        -: 3417:
    #####: 3418:	    default:
    #####: 3419:	      panic(_("INTERNAL ERROR: Bad cmd %c"), cur_cmd->cmd);
call    0 never executed
        -: 3420:	    }
        -: 3421:	}
        -: 3422:
        -: 3423:#ifdef EXPERIMENTAL_DASH_N_OPTIMIZATION
        -: 3424:      /* If our top-level program consists solely of commands with
        -: 3425:       * addr_is_num addresses then once we past the last mentioned
        -: 3426:       * line we should be able to quit if no_default_output is true,
        -: 3427:       * or otherwise quickly copy input to output.  Now whether this
        -: 3428:       * optimization is a win or not depends on how cheaply we can
        -: 3429:       * implement this for the cases where it doesn't help, as
        -: 3430:       * compared against how much time is saved.  One semantic
        -: 3431:       * difference (which I think is an improvement) is that *this*
        -: 3432:       * version will terminate after printing line two in the script
        -: 3433:       * "yes | sed -n 2p". 
        -: 3434:       *
        -: 3435:       * Don't use this when in-place editing is active, because line
        -: 3436:       * numbers restart each time then. */
        -: 3437:      else if (output_file == stdout)
        -: 3438:	{
        -: 3439:	  /* can we ever match again? */
        -: 3440:	  if (cur_cmd->a1->addr_type == addr_is_num &&
        -: 3441:	      ((input->line_number < cur_cmd->a1->addr_number)
        -: 3442:	       != !cur_cmd->addr_bang))
        -: 3443:	    {
        -: 3444:	      /* skip all this next time */
        -: 3445:	      cur_cmd->a1->addr_type = addr_is_null;
        -: 3446:	      cur_cmd->addr_bang = TRUE;
        -: 3447:
        -: 3448:	      /* can we make an optimization? */
        -: 3449:	      if (cur_cmd->cmd == 'b' || cur_cmd->cmd == 't'
        -: 3450:		  || cur_cmd->cmd == '{')
        -: 3451:		--branches;
        -: 3452:	      cur_cmd->cmd = ':';	/* replace with no-op */
        -: 3453:	      if (branches == 0)
        -: 3454:		{
        -: 3455:		  /* whew!  all that just so that we can get to here! */
        -: 3456:		  cur_cmd = shrink_program(vec, cur_cmd);
        -: 3457:		  if (!cur_cmd && no_default_output)
        -: 3458:		    return 0;
        -: 3459:		  end_cmd = vec->v + vec->v_length;
        -: 3460:		  if (!cur_cmd)
        -: 3461:		    cur_cmd = end_cmd;
        -: 3462:		  continue;
        -: 3463:		}
        -: 3464:	    }
        -: 3465:	}
        -: 3466:#endif /*EXPERIMENTAL_DASH_N_OPTIMIZATION*/
        -: 3467:
        -: 3468:      /* this is buried down here so that a "continue" statement can skip it */
    66218: 3469:      ++cur_cmd;
        -: 3470:    }
    27761: 3471:    return -1;
        -: 3472:}
        -: 3473:
        -: 3474:
        -: 3475:
        -: 3476:/* Apply the compiled script to all the named files. */
        -: 3477:int
function process_files called 360 returned 100% blocks executed 100%
      360: 3478:process_files(the_program, argv)
        -: 3479:  struct vector *the_program;
        -: 3480:  char **argv;
        -: 3481:{
        -: 3482:  static char dash[] = "-";
        -: 3483:  static char *stdin_argv[2] = { dash, NULL };
        -: 3484:  struct input input;
        -: 3485:  int status;
        -: 3486:
      360: 3487:  line_init(&line, INITIAL_BUFFER_SIZE);
call    0 returned 360
      360: 3488:  line_init(&hold, 0);
call    0 returned 360
      360: 3489:  line_init(&buffer, 0);
call    0 returned 360
        -: 3490:
        -: 3491:#ifdef EXPERIMENTAL_DASH_N_OPTIMIZATION
        -: 3492:  branches = count_branches(the_program);
        -: 3493:#endif /*EXPERIMENTAL_DASH_N_OPTIMIZATION*/
      360: 3494:  input.file_list = stdin_argv;
      360: 3495:  if (argv && *argv)
branch  0 taken 360 (fallthrough)
branch  1 taken 0
branch  2 taken 359 (fallthrough)
branch  3 taken 1
      359: 3496:    input.file_list = argv;
      360: 3497:  input.bad_count = 0;
      360: 3498:  input.line_number = 0;
      360: 3499:  input.read_fn = read_always_fail;
      360: 3500:  input.fp = NULL;
        -: 3501:
      360: 3502:  status = EXIT_SUCCESS;
    32922: 3503:  while (read_pattern_space(&input, the_program, FALSE))
call    0 returned 32922
branch  1 taken 32591
branch  2 taken 331 (fallthrough)
        -: 3504:    {
    32591: 3505:      status = execute_program(the_program, &input);
call    0 returned 32591
    32591: 3506:      if (!no_default_output)
branch  0 taken 13484 (fallthrough)
branch  1 taken 19107
    13484: 3507:	output_line(line.active, line.length, line.chomped, output_file);
call    0 returned 13484
    32591: 3508:      if (status == -1)
branch  0 taken 32562 (fallthrough)
branch  1 taken 29
    32562: 3509:	status = EXIT_SUCCESS;
        -: 3510:      else
       29: 3511:	break;
        -: 3512:    }
      360: 3513:  closedown(&input);
call    0 returned 360
        -: 3514:
        -: 3515:#ifdef DEBUG_LEAKS
        -: 3516:  /* We're about to exit, so these free()s are redundant.
        -: 3517:     But if we're running under a memory-leak detecting
        -: 3518:     implementation of malloc(), we want to explicitly
        -: 3519:     deallocate in order to avoid extraneous noise from
        -: 3520:     the allocator. */
        -: 3521:  release_append_queue();
        -: 3522:  FREE(buffer.text);
        -: 3523:  FREE(hold.text);
        -: 3524:  FREE(line.text);
        -: 3525:  FREE(s_accum.text);
        -: 3526:#endif /*DEBUG_LEAKS*/
        -: 3527:
      360: 3528:  if (input.bad_count)
branch  0 taken 1 (fallthrough)
branch  1 taken 359
        1: 3529:    status = 2;
        -: 3530:
      360: 3531:  return status;
        -: 3532:}
        -: 3533:/* `L' command implementation for GNU sed, based on GNU fmt 1.22.
        -: 3534:   Copyright (C) 1994, 1995, 1996, 2002, 2003 Free Software Foundation, Inc.
        -: 3535:
        -: 3536:   This program is free software; you can redistribute it and/or modify
        -: 3537:   it under the terms of the GNU General Public License as published by
        -: 3538:   the Free Software Foundation; either version 2, or (at your option)
        -: 3539:   any later version.
        -: 3540:
        -: 3541:   This program is distributed in the hope that it will be useful,
        -: 3542:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 3543:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 3544:   GNU General Public License for more details.
        -: 3545:
        -: 3546:   You should have received a copy of the GNU General Public License
        -: 3547:   along with this program; if not, write to the Free Software Foundation,
        -: 3548:   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
        -: 3549:
        -: 3550:/* GNU fmt was written by Ross Paterson <rap@doc.ic.ac.uk>.  */
        -: 3551:
        -: 3552:#include "config.h"
        -: 3553:#include "basicdefs.h"
        -: 3554:
        -: 3555:#include <stdio.h>
        -: 3556:#include <ctype.h>
        -: 3557:#include <sys/types.h>
        -: 3558:
        -: 3559:#if HAVE_LIMITS_H
        -: 3560:# include <limits.h>
        -: 3561:#endif
        -: 3562:
        -: 3563:#ifndef UINT_MAX
        -: 3564:# define UINT_MAX ((unsigned int) ~(unsigned int) 0)
        -: 3565:#endif
        -: 3566:
        -: 3567:#ifndef INT_MAX
        -: 3568:# define INT_MAX ((int) (UINT_MAX >> 1))
        -: 3569:#endif
        -: 3570:
        -: 3571:/* The following parameters represent the program's idea of what is
        -: 3572:   "best".  Adjust to taste, subject to the caveats given.  */
        -: 3573:
        -: 3574:/* Prefer lines to be LEEWAY % shorter than the maximum width, giving
        -: 3575:   room for optimization.  */
        -: 3576:#define	LEEWAY	7
        -: 3577:
        -: 3578:/* Costs and bonuses are expressed as the equivalent departure from the
        -: 3579:   optimal line length, multiplied by 10.  e.g. assigning something a
        -: 3580:   cost of 50 means that it is as bad as a line 5 characters too short
        -: 3581:   or too long.  The definition of SHORT_COST(n) should not be changed.
        -: 3582:   However, EQUIV(n) may need tuning.  */
        -: 3583:
        -: 3584:typedef long COST;
        -: 3585:
        -: 3586:#define	MAXCOST	(~(((unsigned long) 1) << (8 * sizeof (COST) -1)))
        -: 3587:
        -: 3588:#define	SQR(n)		((n) * (n))
        -: 3589:#define	EQUIV(n)	SQR ((COST) (n))
        -: 3590:
        -: 3591:/* Cost of a filled line n chars longer or shorter than best_width.  */
        -: 3592:#define	SHORT_COST(n)	EQUIV ((n) * 10)
        -: 3593:
        -: 3594:/* Cost of the difference between adjacent filled lines.  */
        -: 3595:#define	RAGGED_COST(n)	(SHORT_COST (n) / 2)
        -: 3596:
        -: 3597:/* Basic cost per line.  */
        -: 3598:#define	LINE_COST	EQUIV (70)
        -: 3599:
        -: 3600:/* Cost of breaking a line after the first word of a sentence, where
        -: 3601:   the length of the word is N.  */
        -: 3602:#define	WIDOW_COST(n)	(EQUIV (200) / ((n) + 2))
        -: 3603:
        -: 3604:/* Cost of breaking a line before the last word of a sentence, where
        -: 3605:   the length of the word is N.  */
        -: 3606:#define	ORPHAN_COST(n)	(EQUIV (150) / ((n) + 2))
        -: 3607:
        -: 3608:/* Bonus for breaking a line at the end of a sentence.  */
        -: 3609:#define	SENTENCE_BONUS	EQUIV (50)
        -: 3610:
        -: 3611:/* Cost of breaking a line after a period not marking end of a sentence.
        -: 3612:   With the definition of sentence we are using (borrowed from emacs, see
        -: 3613:   get_line()) such a break would then look like a sentence break.  Hence
        -: 3614:   we assign a very high cost -- it should be avoided unless things are
        -: 3615:   really bad.  */
        -: 3616:#define	NOBREAK_COST	EQUIV (600)
        -: 3617:
        -: 3618:/* Bonus for breaking a line before open parenthesis.  */
        -: 3619:#define	PAREN_BONUS	EQUIV (40)
        -: 3620:
        -: 3621:/* Bonus for breaking a line after other punctuation.  */
        -: 3622:#define	PUNCT_BONUS	EQUIV(40)
        -: 3623:
        -: 3624:/* Credit for breaking a long paragraph one line later.  */
        -: 3625:#define	LINE_CREDIT	EQUIV(3)
        -: 3626:
        -: 3627:/* Size of paragraph buffer in words.  Longer paragraphs are handled
        -: 3628:   neatly (cf. flush_paragraph()), so there's little to gain by making
        -: 3629:   these larger.  */
        -: 3630:#define	MAXWORDS	1000
        -: 3631:
        -: 3632:#define GETC()          (parabuf == end_of_parabuf ? EOF : *parabuf++)
        -: 3633:
        -: 3634:/* Extra ctype(3)-style macros.  */
        -: 3635:
        -: 3636:#define	isopen(c)	(strchr ("([`'\"", (c)) != NULL)
        -: 3637:#define	isclose(c)	(strchr (")]'\"", (c)) != NULL)
        -: 3638:#define	isperiod(c)	(strchr (".?!", (c)) != NULL)
        -: 3639:
        -: 3640:/* Size of a tab stop, for expansion on input and re-introduction on
        -: 3641:   output.  */
        -: 3642:#define	TABWIDTH	8
        -: 3643:
        -: 3644:/* Word descriptor structure.  */
        -: 3645:
        -: 3646:typedef struct Word WORD;
        -: 3647:
        -: 3648:struct Word
        -: 3649:  {
        -: 3650:
        -: 3651:    /* Static attributes determined during input.  */
        -: 3652:
        -: 3653:    const char *text;		/* the text of the word */
        -: 3654:    short length;		/* length of this word */
        -: 3655:    short space;		/* the size of the following space */
        -: 3656:    flagT paren:1;		/* starts with open paren */
        -: 3657:    flagT period:1;		/* ends in [.?!])* */
        -: 3658:    flagT punct:1;		/* ends in punctuation */
        -: 3659:    flagT final:1;		/* end of sentence */
        -: 3660:
        -: 3661:    /* The remaining fields are computed during the optimization.  */
        -: 3662:
        -: 3663:    short line_length;		/* length of the best line starting here */
        -: 3664:    COST best_cost;		/* cost of best paragraph starting here */
        -: 3665:    WORD *next_break;		/* break which achieves best_cost */
        -: 3666:  };
        -: 3667:
        -: 3668:/* Forward declarations.  */
        -: 3669:
        -: 3670:extern void fmt P_ ((char *line, char *line_end, int max_length, FILE *output_file));
        -: 3671:static flagT get_paragraph P_ ((void));
        -: 3672:static int get_line P_ ((int c));
        -: 3673:static int get_space P_ ((int c));
        -: 3674:static int copy_rest P_ ((int c));
        -: 3675:static flagT same_para P_ ((int c));
        -: 3676:static void flush_paragraph P_ ((void));
        -: 3677:static void fmt_paragraph P_ ((void));
        -: 3678:static void check_punctuation P_ ((WORD *w));
        -: 3679:static COST base_cost P_ ((WORD *this));
        -: 3680:static COST line_cost P_ ((WORD *next, int len));
        -: 3681:static void put_paragraph P_ ((WORD *finish));
        -: 3682:static void put_line P_ ((WORD *w, int indent));
        -: 3683:static void put_word P_ ((WORD *w));
        -: 3684:static void put_space P_ ((int space));
        -: 3685:
        -: 3686:/* Option values.  */
        -: 3687:
        -: 3688:/* User-supplied maximum line width (default WIDTH).  The only output
        -: 3689:   lines
        -: 3690:   longer than this will each comprise a single word.  */
        -: 3691:static int max_width;
        -: 3692:
        -: 3693:/* Space for the paragraph text.  */
        -: 3694:static char *parabuf;
        -: 3695:
        -: 3696:/* End of space for the paragraph text.  */
        -: 3697:static char *end_of_parabuf;
        -: 3698:
        -: 3699:/* The file on which we output */
        -: 3700:static FILE *outfile;
        -: 3701:
        -: 3702:/* Values derived from the option values.  */
        -: 3703:
        -: 3704:/* The preferred width of text lines, set to LEEWAY % less than max_width.  */
        -: 3705:static int best_width;
        -: 3706:
        -: 3707:/* Dynamic variables.  */
        -: 3708:
        -: 3709:/* Start column of the character most recently read from the input file.  */
        -: 3710:static int in_column;
        -: 3711:
        -: 3712:/* Start column of the next character to be written to stdout.  */
        -: 3713:static int out_column;
        -: 3714:
        -: 3715:/* The words of a paragraph -- longer paragraphs are handled neatly
        -: 3716:   (cf. flush_paragraph()).  */
        -: 3717:static WORD words[MAXWORDS];
        -: 3718:
        -: 3719:/* A pointer into the above word array, indicating the first position
        -: 3720:   after the last complete word.  Sometimes it will point at an incomplete
        -: 3721:   word.  */
        -: 3722:static WORD *word_limit;
        -: 3723:
        -: 3724:/* Indentation of the first line of the current paragraph.  */
        -: 3725:static int first_indent;
        -: 3726:
        -: 3727:/* Indentation of other lines of the current paragraph */
        -: 3728:static int other_indent;
        -: 3729:
        -: 3730:/* The last character read from the input file.  */
        -: 3731:static int next_char;
        -: 3732:
        -: 3733:/* If nonzero, the length of the last line output in the current
        -: 3734:   paragraph, used to charge for raggedness at the split point for long
        -: 3735:   paragraphs chosen by fmt_paragraph().  */
        -: 3736:static int last_line_length;
        -: 3737:
        -: 3738:/* read file F and send formatted output to stdout.  */
        -: 3739:
        -: 3740:void
function fmt called 0 returned 0% blocks executed 0%
    #####: 3741:fmt (char *line, char *line_end, int max_length, FILE *output_file)
        -: 3742:{
    #####: 3743:  parabuf = line;
    #####: 3744:  end_of_parabuf = line_end;
    #####: 3745:  outfile = output_file;
        -: 3746:
    #####: 3747:  max_width = max_length;
    #####: 3748:  best_width = max_width * (201 - 2 * LEEWAY) / 200;
        -: 3749:
    #####: 3750:  in_column = 0;
    #####: 3751:  other_indent = 0;
    #####: 3752:  next_char = GETC();
branch  0 never executed
branch  1 never executed
    #####: 3753:  while (get_paragraph ())
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 3754:    {
    #####: 3755:      fmt_paragraph ();
call    0 never executed
    #####: 3756:      put_paragraph (word_limit);
call    0 never executed
        -: 3757:    }
    #####: 3758:}
        -: 3759:
        -: 3760:/* Read a paragraph from input file F.  A paragraph consists of a
        -: 3761:   maximal number of non-blank (excluding any prefix) lines
        -: 3762:   with the same indent.
        -: 3763:
        -: 3764:   Return FALSE if end-of-file was encountered before the start of a
        -: 3765:   paragraph, else TRUE.  */
        -: 3766:
        -: 3767:static flagT
function get_paragraph called 0 returned 0% blocks executed 0%
    #####: 3768:get_paragraph ()
        -: 3769:{
        -: 3770:  register int c;
        -: 3771:
    #####: 3772:  last_line_length = 0;
    #####: 3773:  c = next_char;
        -: 3774:
        -: 3775:  /* Scan (and copy) blank lines, and lines not introduced by the prefix.  */
        -: 3776:
    #####: 3777:  while (c == '\n' || c == EOF)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 3778:    {
    #####: 3779:      c = copy_rest (c);
call    0 never executed
    #####: 3780:      if (c == EOF)
branch  0 never executed
branch  1 never executed
        -: 3781:	{
    #####: 3782:	  next_char = EOF;
    #####: 3783:	  return FALSE;
        -: 3784:	}
    #####: 3785:      putc ('\n', outfile);
call    0 never executed
    #####: 3786:      c = GETC();
branch  0 never executed
branch  1 never executed
        -: 3787:    }
        -: 3788:
        -: 3789:  /* Got a suitable first line for a paragraph.  */
        -: 3790:
    #####: 3791:  first_indent = in_column;
    #####: 3792:  word_limit = words;
    #####: 3793:  c = get_line (c);
call    0 never executed
        -: 3794:
        -: 3795:  /* Read rest of paragraph.  */
        -: 3796:
    #####: 3797:  other_indent = in_column;
    #####: 3798:  while (same_para (c) && in_column == other_indent)
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 3799:    c = get_line (c);
call    0 never executed
        -: 3800:
    #####: 3801:  (word_limit - 1)->period = (word_limit - 1)->final = TRUE;
    #####: 3802:  next_char = c;
    #####: 3803:  return TRUE;
        -: 3804:}
        -: 3805:
        -: 3806:/* Copy to the output a blank line.  In the latter, C is \n or EOF.
        -: 3807:   Return the character (\n or EOF) ending the line.  */
        -: 3808:
        -: 3809:static int
function copy_rest called 0 returned 0% blocks executed 0%
    #####: 3810:copy_rest (register int c)
        -: 3811:{
    #####: 3812:  out_column = 0;
    #####: 3813:  while (c != '\n' && c != EOF)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 3814:    {
    #####: 3815:      putc (c, outfile);
call    0 never executed
    #####: 3816:      c = GETC();
branch  0 never executed
branch  1 never executed
        -: 3817:    }
    #####: 3818:  return c;
        -: 3819:}
        -: 3820:
        -: 3821:/* Return TRUE if a line whose first non-blank character after the
        -: 3822:   prefix (if any) is C could belong to the current paragraph,
        -: 3823:   otherwise FALSE.  */
        -: 3824:
        -: 3825:static flagT
function same_para called 0 returned 0% blocks executed 0%
    #####: 3826:same_para (register int c)
        -: 3827:{
    #####: 3828:  return (c != '\n' && c != EOF);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 3829:}
        -: 3830:
        -: 3831:/* Read a line from the input data given first non-blank character C
        -: 3832:   after the prefix, and the following indent, and break it into words.
        -: 3833:   A word is a maximal non-empty string of non-white characters.  A word
        -: 3834:   ending in [.?!]["')\]]* and followed by end-of-line or at least two
        -: 3835:   spaces ends a sentence, as in emacs.
        -: 3836:
        -: 3837:   Return the first non-blank character of the next line.  */
        -: 3838:
        -: 3839:static int
function get_line called 0 returned 0% blocks executed 0%
    #####: 3840:get_line (register int c)
        -: 3841:{
        -: 3842:  int start;
        -: 3843:  register WORD *end_of_word;
        -: 3844:
    #####: 3845:  end_of_word = &words[MAXWORDS - 2];
        -: 3846:
        -: 3847:  do
        -: 3848:    {				/* for each word in a line */
        -: 3849:
        -: 3850:      /* Scan word.  */
        -: 3851:
    #####: 3852:      word_limit->text = parabuf - 1;
        -: 3853:      do
    #####: 3854:	c = GETC();
branch  0 never executed
branch  1 never executed
    #####: 3855:      while (c != EOF && !ISSPACE (c));
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3856:      word_limit->length = parabuf - word_limit->text - (c != EOF);
    #####: 3857:      in_column += word_limit->length;
        -: 3858:
    #####: 3859:      check_punctuation (word_limit);
call    0 never executed
        -: 3860:
        -: 3861:      /* Scan inter-word space.  */
        -: 3862:
    #####: 3863:      start = in_column;
    #####: 3864:      c = get_space (c);
call    0 never executed
    #####: 3865:      word_limit->space = in_column - start;
    #####: 3866:      word_limit->final = (c == EOF
    #####: 3867:			   || (word_limit->period
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3868:			       && (c == '\n' || word_limit->space > 1)));
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3869:      if (c == '\n' || c == EOF)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3870:	word_limit->space = word_limit->final ? 2 : 1;
branch  0 never executed
branch  1 never executed
    #####: 3871:      if (word_limit == end_of_word)
branch  0 never executed
branch  1 never executed
    #####: 3872:	flush_paragraph ();
call    0 never executed
    #####: 3873:      word_limit++;
    #####: 3874:      if (c == EOF)
branch  0 never executed
branch  1 never executed
        -: 3875:	{
    #####: 3876:	  in_column = first_indent;
    #####: 3877:	  return EOF;
        -: 3878:	}
        -: 3879:    }
    #####: 3880:  while (c != '\n');
branch  0 never executed
branch  1 never executed
        -: 3881:
    #####: 3882:  in_column = 0;
    #####: 3883:  c = GETC();
branch  0 never executed
branch  1 never executed
    #####: 3884:  return get_space (c);
call    0 never executed
        -: 3885:}
        -: 3886:
        -: 3887:/* Read blank characters from the input data, starting with C, and keeping
        -: 3888:   in_column up-to-date.  Return first non-blank character.  */
        -: 3889:
        -: 3890:static int
function get_space called 0 returned 0% blocks executed 0%
    #####: 3891:get_space (register int c)
        -: 3892:{
        -: 3893:  for (;;)
        -: 3894:    {
    #####: 3895:      if (c == ' ')
branch  0 never executed
branch  1 never executed
    #####: 3896:	in_column++;
    #####: 3897:      else if (c == '\t')
branch  0 never executed
branch  1 never executed
    #####: 3898:	in_column = (in_column / TABWIDTH + 1) * TABWIDTH;
        -: 3899:      else
    #####: 3900:	return c;
    #####: 3901:      c = GETC();
branch  0 never executed
branch  1 never executed
        -: 3902:    }
        -: 3903:}
        -: 3904:
        -: 3905:/* Set extra fields in word W describing any attached punctuation.  */
        -: 3906:
        -: 3907:static void
function check_punctuation called 0 returned 0% blocks executed 0%
    #####: 3908:check_punctuation (register WORD *w)
        -: 3909:{
        -: 3910:  register const char *start, *finish;
        -: 3911:
    #####: 3912:  start = w->text;
    #####: 3913:  finish = start + (w->length - 1);
    #####: 3914:  w->paren = isopen (*start);
    #####: 3915:  w->punct = ISPUNCT (*finish);
    #####: 3916:  while (isclose (*finish) && finish > start)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3917:    finish--;
    #####: 3918:  w->period = isperiod (*finish);
    #####: 3919:}
        -: 3920:
        -: 3921:/* Flush part of the paragraph to make room.  This function is called on
        -: 3922:   hitting the limit on the number of words or characters.  */
        -: 3923:
        -: 3924:static void
function flush_paragraph called 0 returned 0% blocks executed 0%
    #####: 3925:flush_paragraph (void)
        -: 3926:{
        -: 3927:  WORD *split_point;
        -: 3928:  register WORD *w;
        -: 3929:  COST best_break;
        -: 3930:
        -: 3931:  /* - format what you have so far as a paragraph,
        -: 3932:     - find a low-cost line break near the end,
        -: 3933:     - output to there,
        -: 3934:     - make that the start of the paragraph.  */
        -: 3935:
    #####: 3936:  fmt_paragraph ();
call    0 never executed
        -: 3937:
        -: 3938:  /* Choose a good split point.  */
        -: 3939:
    #####: 3940:  split_point = word_limit;
    #####: 3941:  best_break = MAXCOST;
    #####: 3942:  for (w = words->next_break; w != word_limit; w = w->next_break)
branch  0 never executed
branch  1 never executed
        -: 3943:    {
    #####: 3944:      if (w->best_cost - w->next_break->best_cost < best_break)
branch  0 never executed
branch  1 never executed
        -: 3945:	{
    #####: 3946:	  split_point = w;
    #####: 3947:	  best_break = w->best_cost - w->next_break->best_cost;
        -: 3948:	}
    #####: 3949:      if (best_break <= MAXCOST - LINE_CREDIT)
branch  0 never executed
branch  1 never executed
    #####: 3950:	best_break += LINE_CREDIT;
        -: 3951:    }
    #####: 3952:  put_paragraph (split_point);
call    0 never executed
        -: 3953:
        -: 3954:  /* Copy words from split_point down to word -- we use memmove because
        -: 3955:     the source and target may overlap.  */
        -: 3956:
    #####: 3957:  memmove ((char *) words, (char *) split_point,
    #####: 3958:	 (word_limit - split_point + 1) * sizeof (WORD));
    #####: 3959:  word_limit -= split_point - words;
    #####: 3960:}
        -: 3961:
        -: 3962:/* Compute the optimal formatting for the whole paragraph by computing
        -: 3963:   and remembering the optimal formatting for each suffix from the empty
        -: 3964:   one to the whole paragraph.  */
        -: 3965:
        -: 3966:static void
function fmt_paragraph called 0 returned 0% blocks executed 0%
    #####: 3967:fmt_paragraph (void)
        -: 3968:{
        -: 3969:  register WORD *start, *w;
        -: 3970:  register int len;
        -: 3971:  register COST wcost, best;
        -: 3972:  int saved_length;
        -: 3973:
    #####: 3974:  word_limit->best_cost = 0;
    #####: 3975:  saved_length = word_limit->length;
    #####: 3976:  word_limit->length = max_width;	/* sentinel */
        -: 3977:
    #####: 3978:  for (start = word_limit - 1; start >= words; start--)
branch  0 never executed
branch  1 never executed
        -: 3979:    {
    #####: 3980:      best = MAXCOST;
    #####: 3981:      len = start == words ? first_indent : other_indent;
branch  0 never executed
branch  1 never executed
        -: 3982:
        -: 3983:      /* At least one word, however long, in the line.  */
        -: 3984:
    #####: 3985:      w = start;
    #####: 3986:      len += w->length;
        -: 3987:      do
        -: 3988:	{
    #####: 3989:	  w++;
        -: 3990:
        -: 3991:	  /* Consider breaking before w.  */
        -: 3992:
    #####: 3993:	  wcost = line_cost (w, len) + w->best_cost;
call    0 never executed
    #####: 3994:	  if (start == words && last_line_length > 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3995:	    wcost += RAGGED_COST (len - last_line_length);
    #####: 3996:	  if (wcost < best)
branch  0 never executed
branch  1 never executed
        -: 3997:	    {
    #####: 3998:	      best = wcost;
    #####: 3999:	      start->next_break = w;
    #####: 4000:	      start->line_length = len;
        -: 4001:	    }
    #####: 4002:	  len += (w - 1)->space + w->length;	/* w > start >= words */
        -: 4003:	}
    #####: 4004:      while (len < max_width);
branch  0 never executed
branch  1 never executed
    #####: 4005:      start->best_cost = best + base_cost (start);
call    0 never executed
        -: 4006:    }
        -: 4007:
    #####: 4008:  word_limit->length = saved_length;
    #####: 4009:}
        -: 4010:
        -: 4011:/* Return the constant component of the cost of breaking before the
        -: 4012:   word THIS.  */
        -: 4013:
        -: 4014:static COST
function base_cost called 0 returned 0% blocks executed 0%
    #####: 4015:base_cost (register WORD *this)
        -: 4016:{
        -: 4017:  register COST cost;
        -: 4018:
    #####: 4019:  cost = LINE_COST;
        -: 4020:
    #####: 4021:  if (this > words)
branch  0 never executed
branch  1 never executed
        -: 4022:    {
    #####: 4023:      if ((this - 1)->period)
branch  0 never executed
branch  1 never executed
        -: 4024:	{
    #####: 4025:	  if ((this - 1)->final)
branch  0 never executed
branch  1 never executed
    #####: 4026:	    cost -= SENTENCE_BONUS;
        -: 4027:	  else
    #####: 4028:	    cost += NOBREAK_COST;
        -: 4029:	}
    #####: 4030:      else if ((this - 1)->punct)
branch  0 never executed
branch  1 never executed
    #####: 4031:	cost -= PUNCT_BONUS;
    #####: 4032:      else if (this > words + 1 && (this - 2)->final)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4033:	cost += WIDOW_COST ((this - 1)->length);
        -: 4034:    }
        -: 4035:
    #####: 4036:  if (this->paren)
branch  0 never executed
branch  1 never executed
    #####: 4037:    cost -= PAREN_BONUS;
    #####: 4038:  else if (this->final)
branch  0 never executed
branch  1 never executed
    #####: 4039:    cost += ORPHAN_COST (this->length);
        -: 4040:
    #####: 4041:  return cost;
        -: 4042:}
        -: 4043:
        -: 4044:/* Return the component of the cost of breaking before word NEXT that
        -: 4045:   depends on LEN, the length of the line beginning there.  */
        -: 4046:
        -: 4047:static COST
function line_cost called 0 returned 0% blocks executed 0%
    #####: 4048:line_cost (register WORD *next, register int len)
        -: 4049:{
        -: 4050:  register int n;
        -: 4051:  register COST cost;
        -: 4052:
    #####: 4053:  if (next == word_limit)
branch  0 never executed
branch  1 never executed
    #####: 4054:    return 0;
    #####: 4055:  n = best_width - len;
    #####: 4056:  cost = SHORT_COST (n);
    #####: 4057:  if (next->next_break != word_limit)
branch  0 never executed
branch  1 never executed
        -: 4058:    {
    #####: 4059:      n = len - next->line_length;
    #####: 4060:      cost += RAGGED_COST (n);
        -: 4061:    }
    #####: 4062:  return cost;
        -: 4063:}
        -: 4064:
        -: 4065:/* Output to stdout a paragraph from word up to (but not including)
        -: 4066:   FINISH, which must be in the next_break chain from word.  */
        -: 4067:
        -: 4068:static void
function put_paragraph called 0 returned 0% blocks executed 0%
    #####: 4069:put_paragraph (register WORD *finish)
        -: 4070:{
        -: 4071:  register WORD *w;
        -: 4072:
    #####: 4073:  put_line (words, first_indent);
call    0 never executed
    #####: 4074:  for (w = words->next_break; w != finish; w = w->next_break)
branch  0 never executed
branch  1 never executed
    #####: 4075:    put_line (w, other_indent);
call    0 never executed
    #####: 4076:}
        -: 4077:
        -: 4078:/* Output to stdout the line beginning with word W, beginning in column
        -: 4079:   INDENT, including the prefix (if any).  */
        -: 4080:
        -: 4081:static void
function put_line called 0 returned 0% blocks executed 0%
    #####: 4082:put_line (register WORD *w, int indent)
        -: 4083:{
        -: 4084:  register WORD *endline;
    #####: 4085:  out_column = 0;
    #####: 4086:  put_space (indent);
call    0 never executed
        -: 4087:
    #####: 4088:  endline = w->next_break - 1;
    #####: 4089:  for (; w != endline; w++)
branch  0 never executed
branch  1 never executed
        -: 4090:    {
    #####: 4091:      put_word (w);
call    0 never executed
    #####: 4092:      put_space (w->space);
call    0 never executed
        -: 4093:    }
    #####: 4094:  put_word (w);
call    0 never executed
    #####: 4095:  last_line_length = out_column;
    #####: 4096:  putc ('\n', outfile);
call    0 never executed
    #####: 4097:}
        -: 4098:
        -: 4099:/* Output to stdout the word W.  */
        -: 4100:
        -: 4101:static void
function put_word called 0 returned 0% blocks executed 0%
    #####: 4102:put_word (register WORD *w)
        -: 4103:{
        -: 4104:  register const char *s;
        -: 4105:  register int n;
        -: 4106:
    #####: 4107:  s = w->text;
    #####: 4108:  for (n = w->length; n != 0; n--)
branch  0 never executed
branch  1 never executed
    #####: 4109:    putc (*s++, outfile);
call    0 never executed
    #####: 4110:  out_column += w->length;
    #####: 4111:}
        -: 4112:
        -: 4113:/* Output to stdout SPACE spaces, or equivalent tabs.  */
        -: 4114:
        -: 4115:static void
function put_space called 0 returned 0% blocks executed 0%
    #####: 4116:put_space (int space)
        -: 4117:{
    #####: 4118:  out_column += space;
    #####: 4119:  while (space--)
branch  0 never executed
branch  1 never executed
    #####: 4120:    putc (' ', outfile);
call    0 never executed
    #####: 4121:}
        -: 4122:/*  Functions from hack's utils library.
        -: 4123:    Copyright (C) 1989, 1990, 1991, 1998, 1999, 2003
        -: 4124:    Free Software Foundation, Inc.
        -: 4125:
        -: 4126:    This program is free software; you can redistribute it and/or modify
        -: 4127:    it under the terms of the GNU General Public License as published by
        -: 4128:    the Free Software Foundation; either version 2, or (at your option)
        -: 4129:    any later version.
        -: 4130:
        -: 4131:    This program is distributed in the hope that it will be useful,
        -: 4132:    but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 4133:    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 4134:    GNU General Public License for more details.
        -: 4135:
        -: 4136:    You should have received a copy of the GNU General Public License
        -: 4137:    along with this program; if not, write to the Free Software
        -: 4138:    Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
        -: 4139:
        -: 4140:#include "config.h"
        -: 4141:
        -: 4142:#include <stdio.h>
        -: 4143:
        -: 4144:#include <errno.h>
        -: 4145:#ifndef errno
        -: 4146:  extern int errno;
        -: 4147:#endif
        -: 4148:
        -: 4149:#ifdef HAVE_STRINGS_H
        -: 4150:# include <strings.h>
        -: 4151:#else
        -: 4152:# include <string.h>
        -: 4153:#endif /* HAVE_STRINGS_H */
        -: 4154:
        -: 4155:#ifdef HAVE_STDLIB_H
        -: 4156:# include <stdlib.h>
        -: 4157:#endif /* HAVE_STDLIB_H */
        -: 4158:
        -: 4159:#include "basicdefs.h"
        -: 4160:#include "utils.h"
        -: 4161:
        -: 4162:const char *myname;
        -: 4163:
        -: 4164:void do_ck_fclose P_((FILE *stream));
        -: 4165:
        -: 4166:/* Print an error message and exit */
        -: 4167:#if !defined __STDC__ || !(__STDC__-0)
        -: 4168:# include <varargs.h>
        -: 4169:# define VSTART(l,a)	va_start(l)
        -: 4170:# undef stderr
        -: 4171:# define stderr stdout
        -: 4172:void
        -: 4173:panic(str, va_alist)
        -: 4174:  char *str;
        -: 4175:  va_dcl
        -: 4176:#else /*__STDC__*/
        -: 4177:# include <stdarg.h>
        -: 4178:# define VSTART(l,a)	va_start(l, a)
        -: 4179:
        -: 4180:/*
        -: 4181:  Non-determinism bug fix
        -: 4182:  SIR July 2006, Kyle R. Murphy
        -: 4183:*/
        -: 4184:#undef stderr
        -: 4185:#define stderr stdout
        -: 4186:void
function panic called 364 returned 0% blocks executed 100%
      364: 4187:panic(const char *str, ...)
        -: 4188:#endif /* __STDC__ */
        -: 4189:{
        -: 4190:  va_list iggy;
        -: 4191:
      364: 4192:  fprintf(stderr, "%s: ", myname);
call    0 returned 364
      364: 4193:  VSTART(iggy, str);
        -: 4194:#ifndef HAVE_VPRINTF
        -: 4195:# ifndef HAVE_DOPRNT
        -: 4196:  fputs(str, stderr);	/* not great, but perhaps better than nothing... */
        -: 4197:# else /* HAVE_DOPRNT */
        -: 4198:  _doprnt(str, &iggy, stderr);
        -: 4199:# endif /* HAVE_DOPRNT */
        -: 4200:#else /* HAVE_VFPRINTF */
      364: 4201:  vfprintf(stderr, str, iggy);
call    0 returned 364
        -: 4202:#endif /* HAVE_VFPRINTF */
      364: 4203:  va_end(iggy);
      364: 4204:  putc('\n', stderr);
call    0 returned 364
      364: 4205:  exit(4);
        -: 4206:}
        -: 4207:
        -: 4208:
        -: 4209:/* Store information about files opened with ck_fopen
        -: 4210:   so that error messages from ck_fread, ck_fwrite, etc. can print the
        -: 4211:   name of the file that had the error */
        -: 4212:
        -: 4213:struct id
        -: 4214:  {
        -: 4215:    FILE *fp;
        -: 4216:    char *name;
        -: 4217:    struct id *link;
        -: 4218:  };
        -: 4219:
        -: 4220:static struct id *utils_id_s = NULL;
        -: 4221:
        -: 4222:/* Internal routine to get a filename from utils_id_s */
        -: 4223:static const char *utils_fp_name P_((FILE *fp));
        -: 4224:static const char *
function utils_fp_name called 362 returned 100% blocks executed 46%
      362: 4225:utils_fp_name(fp)
        -: 4226:  FILE *fp;
        -: 4227:{
        -: 4228:  struct id *p;
        -: 4229:
     362*: 4230:  for (p=utils_id_s; p; p=p->link)
branch  0 taken 0
branch  1 taken 362 (fallthrough)
    #####: 4231:    if (p->fp == fp)
branch  0 never executed
branch  1 never executed
    #####: 4232:      return p->name;
      362: 4233:  if (fp == stdin)
branch  0 taken 0 (fallthrough)
branch  1 taken 362
    #####: 4234:    return "stdin";
      362: 4235:  else if (fp == stdout)
branch  0 taken 362 (fallthrough)
branch  1 taken 0
      362: 4236:    return "stdout";
    #####: 4237:  else if (fp == stderr)
branch  0 never executed
branch  1 never executed
    #####: 4238:    return "stderr";
        -: 4239:
    #####: 4240:  return "<unknown>";
        -: 4241:}
        -: 4242:
        -: 4243:/* Panic on failing fopen */
        -: 4244:FILE *
function ck_fopen called 995 returned 100% blocks executed 89%
      995: 4245:ck_fopen(name, mode, fail)
        -: 4246:  const char *name;
        -: 4247:  const char *mode;
        -: 4248:  flagT fail;
        -: 4249:{
        -: 4250:  FILE *fp;
        -: 4251:  struct id *p;
        -: 4252:
      995: 4253:  fp = fopen (name, mode);
call    0 returned 995
      995: 4254:  if (!fp)
branch  0 taken 3 (fallthrough)
branch  1 taken 992
        -: 4255:    {
        3: 4256:      if (fail)
branch  0 taken 2 (fallthrough)
branch  1 taken 1
        2: 4257:        panic(_("Couldn't open file %s: %s"), name, strerror(errno));
call    0 returned 2
call    1 returned 0
        -: 4258:
        1: 4259:      return NULL;
        -: 4260:    }
        -: 4261:
     1539: 4262:  for (p=utils_id_s; p; p=p->link)
branch  0 taken 547
branch  1 taken 992 (fallthrough)
        -: 4263:    {
      547: 4264:      if (fp == p->fp)
branch  0 taken 0 (fallthrough)
branch  1 taken 547
        -: 4265:	{
    #####: 4266:	  FREE(p->name);
call    0 never executed
    #####: 4267:	  break;
        -: 4268:	}
        -: 4269:    }
      992: 4270:  if (!p)
branch  0 taken 992 (fallthrough)
branch  1 taken 0
        -: 4271:    {
      992: 4272:      p = MALLOC(1, struct id);
call    0 returned 992
      992: 4273:      p->link = utils_id_s;
      992: 4274:      utils_id_s = p;
        -: 4275:    }
      992: 4276:  p->name = ck_strdup(name);
call    0 returned 992
      992: 4277:  p->fp = fp;
      992: 4278:  return fp;
        -: 4279:}
        -: 4280:
        -: 4281:/* Panic on failing fwrite */
        -: 4282:void
function ck_fwrite called 61130 returned 100% blocks executed 45%
    61130: 4283:ck_fwrite(ptr, size, nmemb, stream)
        -: 4284:  const VOID *ptr;
        -: 4285:  size_t size;
        -: 4286:  size_t nmemb;
        -: 4287:  FILE *stream;
        -: 4288:{
    61130: 4289:  clearerr(stream);
call    0 returned 61130
    61130: 4290:  if (size && fwrite(ptr, size, nmemb, stream) != nmemb)
branch  0 taken 61130 (fallthrough)
branch  1 taken 0
call    2 returned 61130
branch  3 taken 0 (fallthrough)
branch  4 taken 61130
    #####: 4291:    panic(ngettext("couldn't write %d item to %s: %s",
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -: 4292:		   "couldn't write %d items to %s: %s", nmemb), 
    #####: 4293:		nmemb, utils_fp_name(stream), strerror(errno));
call    0 never executed
    61130: 4294:}
        -: 4295:
        -: 4296:/* Panic on failing fread */
        -: 4297:size_t
function ck_fread called 196 returned 100% blocks executed 73%
      196: 4298:ck_fread(ptr, size, nmemb, stream)
        -: 4299:  VOID *ptr;
        -: 4300:  size_t size;
        -: 4301:  size_t nmemb;
        -: 4302:  FILE *stream;
        -: 4303:{
      196: 4304:  clearerr(stream);
call    0 returned 196
      196: 4305:  if (size && (nmemb=fread(ptr, size, nmemb, stream)) <= 0 && ferror(stream))
branch  0 taken 196 (fallthrough)
branch  1 taken 0
call    2 returned 196
branch  3 taken 98 (fallthrough)
branch  4 taken 98
call    5 returned 98
branch  6 taken 0 (fallthrough)
branch  7 taken 98
    #####: 4306:    panic(_("read error on %s: %s"), utils_fp_name(stream), strerror(errno));
call    0 never executed
call    1 never executed
call    2 never executed
        -: 4307:
      196: 4308:  return nmemb;
        -: 4309:}
        -: 4310:
        -: 4311:/* Panic on failing fflush */
        -: 4312:void
function ck_fflush called 5301 returned 100% blocks executed 50%
     5301: 4313:ck_fflush(stream)
        -: 4314:  FILE *stream;
        -: 4315:{
     5301: 4316:  clearerr(stream);
call    0 returned 5301
    5301*: 4317:  if (fflush(stream) == EOF && errno != EBADF)
call    0 returned 5301
branch  1 taken 0 (fallthrough)
branch  2 taken 5301
branch  3 never executed
branch  4 never executed
    #####: 4318:    panic("Couldn't flush %s: %s", utils_fp_name(stream), strerror(errno));
call    0 never executed
call    1 never executed
call    2 never executed
     5301: 4319:}
        -: 4320:
        -: 4321:/* Panic on failing fclose */
        -: 4322:void
function ck_fclose called 1356 returned 73% blocks executed 100%
     1356: 4323:ck_fclose(stream)
        -: 4324:  FILE *stream;
        -: 4325:{
        -: 4326:  struct id r;
        -: 4327:  struct id *prev;
        -: 4328:  struct id *cur;
        -: 4329:
        -: 4330:  /* a NULL stream means to close all files */
     1356: 4331:  r.link = utils_id_s;
     1356: 4332:  prev = &r;
     2895: 4333:  while ( (cur = prev->link) )
branch  0 taken 1539
branch  1 taken 1356 (fallthrough)
        -: 4334:    {
     1539: 4335:      if (!stream || stream == cur->fp)
branch  0 taken 1539 (fallthrough)
branch  1 taken 0
branch  2 taken 992 (fallthrough)
branch  3 taken 547
        -: 4336:	{
      992: 4337:	  do_ck_fclose (cur->fp);
call    0 returned 992
      992: 4338:	  prev->link = cur->link;
      992: 4339:	  FREE(cur->name);
call    0 returned 992
      992: 4340:	  FREE(cur);
call    0 returned 992
        -: 4341:	}
        -: 4342:      else
      547: 4343:	prev = cur;
        -: 4344:    }
        -: 4345:
     1356: 4346:  utils_id_s = r.link;
        -: 4347:
        -: 4348:  /* Also care about stdout, because if it is redirected the
        -: 4349:     last output operations might fail and it is important
        -: 4350:     to signal this as an error (perhaps to make). */
     1356: 4351:  if (!stream)
branch  0 taken 362 (fallthrough)
branch  1 taken 994
        -: 4352:    {
      362: 4353:      do_ck_fclose (stdout);
call    0 returned 362
      362: 4354:      do_ck_fclose (stderr);
call    0 returned 0
        -: 4355:    }
      994: 4356:}
        -: 4357:
        -: 4358:/* Close a single file and update a count of closed files. */
        -: 4359:void
function do_ck_fclose called 1716 returned 79% blocks executed 100%
     1716: 4360:do_ck_fclose(stream)
        -: 4361:  FILE *stream;
        -: 4362:{
     1716: 4363:  ck_fflush(stream);
call    0 returned 1716
     1716: 4364:  clearerr(stream);
call    0 returned 1716
     1716: 4365:  if (fclose(stream) == EOF)
call    0 returned 1716
branch  1 taken 362 (fallthrough)
branch  2 taken 1354
      362: 4366:    panic("Couldn't close %s: %s", utils_fp_name(stream), strerror(errno));
call    0 returned 362
call    1 returned 362
call    2 returned 0
     1354: 4367:}
        -: 4368:
        -: 4369:
        -: 4370:
        -: 4371:char *
function temp_file_template called 2 returned 100% blocks executed 56%
        2: 4372:temp_file_template(tmpdir, program)
        -: 4373:  const char *tmpdir;    
        -: 4374:  char *program;
        -: 4375:{
        -: 4376:  char *template;
        2: 4377:  if (tmpdir == NULL)
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####: 4378:    tmpdir = getenv("TMPDIR");
call    0 never executed
        2: 4379:  if (tmpdir == NULL)
branch  0 taken 0 (fallthrough)
branch  1 taken 2
        -: 4380:    {
    #####: 4381:      tmpdir = getenv("TMP");
call    0 never executed
    #####: 4382:      if (tmpdir == NULL)
branch  0 never executed
branch  1 never executed
        -: 4383:#ifdef P_tmpdir
    #####: 4384:	tmpdir = P_tmpdir;
        -: 4385:#else
        -: 4386:	tmpdir = "/tmp";
        -: 4387:#endif
        -: 4388:    }
        -: 4389:
        2: 4390:  template = xmalloc (strlen (tmpdir) + strlen (program) + 8);
call    0 returned 2
        2: 4391:  sprintf (template, "%s/%sXXXXXX", tmpdir, program);
        2: 4392:  return (template);
        -: 4393:}
        -: 4394:
        -: 4395:
        -: 4396:/* Panic on failing malloc */
        -: 4397:VOID *
function ck_malloc called 9829 returned 100% blocks executed 86%
     9829: 4398:ck_malloc(size)
        -: 4399:  size_t size;
        -: 4400:{
     9829: 4401:  VOID *ret = calloc(1, size ? size : 1);
branch  0 taken 9105 (fallthrough)
branch  1 taken 724
     9829: 4402:  if (!ret)
branch  0 taken 0 (fallthrough)
branch  1 taken 9829
    #####: 4403:    panic("Couldn't allocate memory");
call    0 never executed
     9829: 4404:  return ret;
        -: 4405:}
        -: 4406:
        -: 4407:/* Panic on failing malloc */
        -: 4408:VOID *
function xmalloc called 9 returned 100% blocks executed 100%
        9: 4409:xmalloc(size)
        -: 4410:  size_t size;
        -: 4411:{
        9: 4412:  return ck_malloc(size);
call    0 returned 9
        -: 4413:}
        -: 4414:
        -: 4415:/* Panic on failing realloc */
        -: 4416:VOID *
function ck_realloc called 805 returned 100% blocks executed 70%
      805: 4417:ck_realloc(ptr, size)
        -: 4418:  VOID *ptr;
        -: 4419:  size_t size;
        -: 4420:{
        -: 4421:  VOID *ret;
        -: 4422:
      805: 4423:  if (size == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 805
        -: 4424:    {
    #####: 4425:      FREE(ptr);
call    0 never executed
    #####: 4426:      return NULL;
        -: 4427:    }
      805: 4428:  if (!ptr)
branch  0 taken 365 (fallthrough)
branch  1 taken 440
      365: 4429:    return ck_malloc(size);
call    0 returned 365
      440: 4430:  ret = realloc(ptr, size);
      440: 4431:  if (!ret)
branch  0 taken 0 (fallthrough)
branch  1 taken 440
    #####: 4432:    panic("Couldn't re-allocate memory");
call    0 never executed
      440: 4433:  return ret;
        -: 4434:}
        -: 4435:
        -: 4436:/* Return a malloc()'d copy of a string */
        -: 4437:char *
function ck_strdup called 1238 returned 100% blocks executed 100%
     1238: 4438:ck_strdup(str)
        -: 4439:  const char *str;
        -: 4440:{
     1238: 4441:  char *ret = MALLOC(strlen(str)+1, char);
call    0 returned 1238
     1238: 4442:  return strcpy(ret, str);
        -: 4443:}
        -: 4444:
        -: 4445:/* Return a malloc()'d copy of a block of memory */
        -: 4446:VOID *
function ck_memdup called 1445 returned 100% blocks executed 100%
     1445: 4447:ck_memdup(buf, len)
        -: 4448:  const VOID *buf;
        -: 4449:  size_t len;
        -: 4450:{
     1445: 4451:  VOID *ret = ck_malloc(len);
call    0 returned 1445
     1445: 4452:  return memcpy(ret, buf, len);
        -: 4453:}
        -: 4454:
        -: 4455:/* Release a malloc'd block of memory */
        -: 4456:void
function ck_free called 6305 returned 100% blocks executed 100%
     6305: 4457:ck_free(ptr)
        -: 4458:  VOID *ptr;
        -: 4459:{
     6305: 4460:  if (ptr)
branch  0 taken 5976 (fallthrough)
branch  1 taken 329
     5976: 4461:    free(ptr);
     6305: 4462:}
        -: 4463:
        -: 4464:
        -: 4465:/* Implement a variable sized buffer of `stuff'.  We don't know what it is,
        -: 4466:nor do we care, as long as it doesn't mind being aligned by malloc. */
        -: 4467:
        -: 4468:struct buffer
        -: 4469:  {
        -: 4470:    size_t allocated;
        -: 4471:    size_t length;
        -: 4472:    char *b;
        -: 4473:  };
        -: 4474:
        -: 4475:#define MIN_ALLOCATE 50
        -: 4476:
        -: 4477:struct buffer *
function init_buffer called 1262 returned 100% blocks executed 100%
     1262: 4478:init_buffer()
        -: 4479:{
     1262: 4480:  struct buffer *b = MALLOC(1, struct buffer);
call    0 returned 1262
     1262: 4481:  b->b = MALLOC(MIN_ALLOCATE, char);
call    0 returned 1262
     1262: 4482:  b->allocated = MIN_ALLOCATE;
     1262: 4483:  b->length = 0;
     1262: 4484:  return b;
        -: 4485:}
        -: 4486:
        -: 4487:char *
function get_buffer called 1244 returned 100% blocks executed 100%
     1244: 4488:get_buffer(b)
        -: 4489:  struct buffer *b;
        -: 4490:{
     1244: 4491:  return b->b;
        -: 4492:}
        -: 4493:
        -: 4494:size_t
function size_buffer called 1628 returned 100% blocks executed 100%
     1628: 4495:size_buffer(b)
        -: 4496:  struct buffer *b;
        -: 4497:{
     1628: 4498:  return b->length;
        -: 4499:}
        -: 4500:
        -: 4501:static void resize_buffer P_((struct buffer *b, size_t newlen));
        -: 4502:static void
function resize_buffer called 0 returned 0% blocks executed 0%
    #####: 4503:resize_buffer(b, newlen)
        -: 4504:  struct buffer *b;
        -: 4505:  size_t newlen;
        -: 4506:{
    #####: 4507:  char *try = NULL;
    #####: 4508:  size_t alen = b->allocated;
        -: 4509:
    #####: 4510:  if (newlen <= alen)
branch  0 never executed
branch  1 never executed
    #####: 4511:    return;
    #####: 4512:  alen *= 2;
    #####: 4513:  if (newlen < alen)
branch  0 never executed
branch  1 never executed
    #####: 4514:    try = realloc(b->b, alen);	/* Note: *not* the REALLOC() macro! */
    #####: 4515:  if (!try)
branch  0 never executed
branch  1 never executed
        -: 4516:    {
    #####: 4517:      alen = newlen;
    #####: 4518:      try = REALLOC(b->b, alen, char);
call    0 never executed
        -: 4519:    }
    #####: 4520:  b->allocated = alen;
    #####: 4521:  b->b = try;
        -: 4522:}
        -: 4523:
        -: 4524:void
function add_buffer called 0 returned 0% blocks executed 0%
    #####: 4525:add_buffer(b, p, n)
        -: 4526:  struct buffer *b;
        -: 4527:  const char *p;
        -: 4528:  size_t n;
        -: 4529:{
    #####: 4530:  if (b->allocated - b->length < n)
branch  0 never executed
branch  1 never executed
    #####: 4531:    resize_buffer(b, b->length+n);
call    0 never executed
    #####: 4532:  memcpy(b->b + b->length, p, n);
    #####: 4533:  b->length += n;
    #####: 4534:}
        -: 4535:
        -: 4536:void
function add1_buffer called 10702 returned 100% blocks executed 80%
    10702: 4537:add1_buffer(b, c)
        -: 4538:  struct buffer *b;
        -: 4539:  int c;
        -: 4540:{
        -: 4541:  /* This special case should be kept cheap;
        -: 4542:   *  don't make it just a mere convenience
        -: 4543:   *  wrapper for add_buffer() -- even "builtin"
        -: 4544:   *  versions of memcpy(a, b, 1) can become
        -: 4545:   *  expensive when called too often.
        -: 4546:   */
    10702: 4547:  if (c != EOF)
branch  0 taken 10702 (fallthrough)
branch  1 taken 0
        -: 4548:    {
    10702: 4549:      if (b->allocated - b->length < 1)
branch  0 taken 0 (fallthrough)
branch  1 taken 10702
    #####: 4550:	resize_buffer(b, b->length+1);
call    0 never executed
    10702: 4551:      b->b[b->length++] = c;
        -: 4552:    }
    10702: 4553:}
        -: 4554:
        -: 4555:void
function free_buffer called 1262 returned 100% blocks executed 100%
     1262: 4556:free_buffer(b)
        -: 4557:  struct buffer *b;
        -: 4558:{
     1262: 4559:  if (b)
branch  0 taken 1262 (fallthrough)
branch  1 taken 0
     1262: 4560:    FREE(b->b);
call    0 returned 1262
     1262: 4561:  FREE(b);
call    0 returned 1262
     1262: 4562:}
        -: 4563:/* obstack.c - subroutines used implicitly by object stack macros -*- C -*-
        -: 4564:   Copyright (C) 1988,89,90,91,92,93,94,96,97 Free Software Foundation, Inc.
        -: 4565:
        -: 4566:   This file is part of the GNU C Library.  Its master source is NOT part of
        -: 4567:   the C library, however.  The master source lives in /gd/gnu/lib.
        -: 4568:
        -: 4569:   The GNU C Library is free software; you can redistribute it and/or
        -: 4570:   modify it under the terms of the GNU Library General Public License as
        -: 4571:   published by the Free Software Foundation; either version 2 of the
        -: 4572:   License, or (at your option) any later version.
        -: 4573:
        -: 4574:   The GNU C Library is distributed in the hope that it will be useful,
        -: 4575:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 4576:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
        -: 4577:   Library General Public License for more details.
        -: 4578:
        -: 4579:   You should have received a copy of the GNU Library General Public
        -: 4580:   License along with the GNU C Library; see the file COPYING.LIB.  If not,
        -: 4581:   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
        -: 4582:   Boston, MA 02111-1307, USA.  */
        -: 4583:
        -: 4584:#include "obstack.h"
        -: 4585:
        -: 4586:/* NOTE BEFORE MODIFYING THIS FILE: This version number must be
        -: 4587:   incremented whenever callers compiled using an old obstack.h can no
        -: 4588:   longer properly call the functions in this obstack.c.  */
        -: 4589:#define OBSTACK_INTERFACE_VERSION 1
        -: 4590:
        -: 4591:/* Comment out all this code if we are using the GNU C Library, and are not
        -: 4592:   actually compiling the library itself, and the installed library
        -: 4593:   supports the same library interface we do.  This code is part of the GNU
        -: 4594:   C Library, but also included in many other GNU distributions.  Compiling
        -: 4595:   and linking in this code is a waste when using the GNU C library
        -: 4596:   (especially if it is a shared library).  Rather than having every GNU
        -: 4597:   program understand `configure --with-gnu-libc' and omit the object
        -: 4598:   files, it is simpler to just do this in the source for each such file.  */
        -: 4599:
        -: 4600:#include <stdio.h>		/* Random thing to get __GNU_LIBRARY__.  */
        -: 4601:#if !defined (_LIBC) && defined (__GNU_LIBRARY__) && __GNU_LIBRARY__ > 1
        -: 4602:#include <gnu-versions.h>
        -: 4603:#if _GNU_OBSTACK_INTERFACE_VERSION == OBSTACK_INTERFACE_VERSION
        -: 4604:#define ELIDE_CODE
        -: 4605:#endif
        -: 4606:#endif
        -: 4607:
        -: 4608:
        -: 4609:#ifndef ELIDE_CODE
        -: 4610:
        -: 4611:
        -: 4612:#if defined (__STDC__) && __STDC__
        -: 4613:#define POINTER void *
        -: 4614:#else
        -: 4615:#define POINTER char *
        -: 4616:#endif
        -: 4617:
        -: 4618:/* Determine default alignment.  */
        -: 4619:struct fooalign {char x; double d;};
        -: 4620:#define DEFAULT_ALIGNMENT  \
        -: 4621:  ((PTR_INT_TYPE) ((char *) &((struct fooalign *) 0)->d - (char *) 0))
        -: 4622:/* If malloc were really smart, it would round addresses to DEFAULT_ALIGNMENT.
        -: 4623:   But in fact it might be less smart and round addresses to as much as
        -: 4624:   DEFAULT_ROUNDING.  So we prepare for it to do that.  */
        -: 4625:union fooround {long x; double d;};
        -: 4626:#define DEFAULT_ROUNDING (sizeof (union fooround))
        -: 4627:
        -: 4628:#ifdef original_glibc_code
        -: 4629:/**//* When we copy a long block of data, this is the unit to do it with. */
        -: 4630:/**//* On some machines, copying successive ints does not work; */
        -: 4631:/**//* in such a case, redefine COPYING_UNIT to `long' (if that works) */
        -: 4632:/**//* or `char' as a last resort.  */
        -: 4633:/**/#ifndef COPYING_UNIT
        -: 4634:/**/#define COPYING_UNIT int
        -: 4635:/**/#endif
        -: 4636:#endif
        -: 4637:
        -: 4638:/* The functions allocating more room by calling `obstack_chunk_alloc'
        -: 4639:   jump to the handler pointed to by `obstack_alloc_failed_handler'.
        -: 4640:   This variable by default points to the internal function
        -: 4641:   `print_and_abort'.  */
        -: 4642:#if defined (__STDC__) && __STDC__
        -: 4643:static void print_and_abort (void);
        -: 4644:void (*obstack_alloc_failed_handler) (void) = print_and_abort;
        -: 4645:#else
        -: 4646:static void print_and_abort ();
        -: 4647:void (*obstack_alloc_failed_handler) () = print_and_abort;
        -: 4648:#endif
        -: 4649:
        -: 4650:/* Exit value used when `print_and_abort' is used.  */
        -: 4651:#if defined __GNU_LIBRARY__ || defined HAVE_STDLIB_H
        -: 4652:#include <stdlib.h>
        -: 4653:#endif
        -: 4654:#ifndef EXIT_FAILURE
        -: 4655:#define EXIT_FAILURE 1
        -: 4656:#endif
        -: 4657:int obstack_exit_failure = EXIT_FAILURE;
        -: 4658:
        -: 4659:/* The non-GNU-C macros copy the obstack into this global variable
        -: 4660:   to avoid multiple evaluation.  */
        -: 4661:
        -: 4662:struct obstack *_obstack;
        -: 4663:
        -: 4664:/* Define a macro that either calls functions with the traditional malloc/free
        -: 4665:   calling interface, or calls functions with the mmalloc/mfree interface
        -: 4666:   (that adds an extra first argument), based on the state of use_extra_arg.
        -: 4667:   For free, do not use ?:, since some compilers, like the MIPS compilers,
        -: 4668:   do not allow (expr) ? void : void.  */
        -: 4669:
        -: 4670:#if defined (__STDC__) && __STDC__
        -: 4671:#define CALL_CHUNKFUN(h, size) \
        -: 4672:  (((h) -> use_extra_arg) \
        -: 4673:   ? (*(h)->chunkfun) ((h)->extra_arg, (size)) \
        -: 4674:   : (*(struct _obstack_chunk *(*) (long)) (h)->chunkfun) ((size)))
        -: 4675:
        -: 4676:#define CALL_FREEFUN(h, old_chunk) \
        -: 4677:  do { \
        -: 4678:    if ((h) -> use_extra_arg) \
        -: 4679:      (*(h)->freefun) ((h)->extra_arg, (old_chunk)); \
        -: 4680:    else \
        -: 4681:      (*(void (*) (void *)) (h)->freefun) ((old_chunk)); \
        -: 4682:  } while (0)
        -: 4683:#else
        -: 4684:#define CALL_CHUNKFUN(h, size) \
        -: 4685:  (((h) -> use_extra_arg) \
        -: 4686:   ? (*(h)->chunkfun) ((h)->extra_arg, (size)) \
        -: 4687:   : (*(struct _obstack_chunk *(*) ()) (h)->chunkfun) ((size)))
        -: 4688:
        -: 4689:#define CALL_FREEFUN(h, old_chunk) \
        -: 4690:  do { \
        -: 4691:    if ((h) -> use_extra_arg) \
        -: 4692:      (*(h)->freefun) ((h)->extra_arg, (old_chunk)); \
        -: 4693:    else \
        -: 4694:      (*(void (*) ()) (h)->freefun) ((old_chunk)); \
        -: 4695:  } while (0)
        -: 4696:#endif
        -: 4697:
        -: 4698:
        -: 4699:/* Initialize an obstack H for use.  Specify chunk size SIZE (0 means default).
        -: 4700:   Objects start on multiples of ALIGNMENT (0 means use default).
        -: 4701:   CHUNKFUN is the function to use to allocate chunks,
        -: 4702:   and FREEFUN the function to free them.
        -: 4703:
        -: 4704:   Return nonzero if successful, zero if out of memory.
        -: 4705:   To recover from an out of memory error,
        -: 4706:   free up some memory, then call this again.  */
        -: 4707:
        -: 4708:int
        -: 4709:_obstack_begin (h, size, alignment, chunkfun, freefun)
        -: 4710:     struct obstack *h;
        -: 4711:     int size;
        -: 4712:     int alignment;
        -: 4713:#if defined (__STDC__) && __STDC__
        -: 4714:     POINTER (*chunkfun) (long);
        -: 4715:     void (*freefun) (void *);
        -: 4716:#else
        -: 4717:     POINTER (*chunkfun) ();
        -: 4718:     void (*freefun) ();
        -: 4719:#endif
        -: 4720:{
        -: 4721:  register struct _obstack_chunk *chunk; /* points to new chunk */
        -: 4722:
        -: 4723:  if (alignment == 0)
        -: 4724:    alignment = DEFAULT_ALIGNMENT;
        -: 4725:  if (size == 0)
        -: 4726:    /* Default size is what GNU malloc can fit in a 4096-byte block.  */
        -: 4727:    {
        -: 4728:      /* 12 is sizeof (mhead) and 4 is EXTRA from GNU malloc.
        -: 4729:	 Use the values for range checking, because if range checking is off,
        -: 4730:	 the extra bytes won't be missed terribly, but if range checking is on
        -: 4731:	 and we used a larger request, a whole extra 4096 bytes would be
        -: 4732:	 allocated.
        -: 4733:
        -: 4734:	 These number are irrelevant to the new GNU malloc.  I suspect it is
        -: 4735:	 less sensitive to the size of the request.  */
        -: 4736:      int extra = ((((12 + DEFAULT_ROUNDING - 1) & ~(DEFAULT_ROUNDING - 1))
        -: 4737:		    + 4 + DEFAULT_ROUNDING - 1)
        -: 4738:		   & ~(DEFAULT_ROUNDING - 1));
        -: 4739:      size = 4096 - extra;
        -: 4740:    }
        -: 4741:
        -: 4742:#if defined (__STDC__) && __STDC__
        -: 4743:  h->chunkfun = (struct _obstack_chunk * (*)(void *, long)) chunkfun;
        -: 4744:  h->freefun = (void (*) (void *, struct _obstack_chunk *)) freefun;
        -: 4745:#else
        -: 4746:  h->chunkfun = (struct _obstack_chunk * (*)()) chunkfun;
        -: 4747:  h->freefun = freefun;
        -: 4748:#endif
        -: 4749:  h->chunk_size = size;
        -: 4750:  h->alignment_mask = alignment - 1;
        -: 4751:  h->use_extra_arg = 0;
        -: 4752:
        -: 4753:  chunk = h->chunk = CALL_CHUNKFUN (h, h -> chunk_size);
        -: 4754:  if (!chunk)
        -: 4755:    (*obstack_alloc_failed_handler) ();
        -: 4756:  h->next_free = h->object_base = chunk->contents;
        -: 4757:  h->chunk_limit = chunk->limit
        -: 4758:    = (char *) chunk + h->chunk_size;
        -: 4759:  chunk->prev = 0;
        -: 4760:  /* The initial chunk now contains no empty object.  */
        -: 4761:  h->maybe_empty_object = 0;
        -: 4762:  h->alloc_failed = 0;
        -: 4763:  return 1;
        -: 4764:}
        -: 4765:
        -: 4766:int
        -: 4767:_obstack_begin_1 (h, size, alignment, chunkfun, freefun, arg)
        -: 4768:     struct obstack *h;
        -: 4769:     int size;
        -: 4770:     int alignment;
        -: 4771:#if defined (__STDC__) && __STDC__
        -: 4772:     POINTER (*chunkfun) (POINTER, long);
        -: 4773:     void (*freefun) (POINTER, POINTER);
        -: 4774:#else
        -: 4775:     POINTER (*chunkfun) ();
        -: 4776:     void (*freefun) ();
        -: 4777:#endif
        -: 4778:     POINTER arg;
        -: 4779:{
        -: 4780:  register struct _obstack_chunk *chunk; /* points to new chunk */
        -: 4781:
        -: 4782:  if (alignment == 0)
        -: 4783:    alignment = DEFAULT_ALIGNMENT;
        -: 4784:  if (size == 0)
        -: 4785:    /* Default size is what GNU malloc can fit in a 4096-byte block.  */
        -: 4786:    {
        -: 4787:      /* 12 is sizeof (mhead) and 4 is EXTRA from GNU malloc.
        -: 4788:	 Use the values for range checking, because if range checking is off,
        -: 4789:	 the extra bytes won't be missed terribly, but if range checking is on
        -: 4790:	 and we used a larger request, a whole extra 4096 bytes would be
        -: 4791:	 allocated.
        -: 4792:
        -: 4793:	 These number are irrelevant to the new GNU malloc.  I suspect it is
        -: 4794:	 less sensitive to the size of the request.  */
        -: 4795:      int extra = ((((12 + DEFAULT_ROUNDING - 1) & ~(DEFAULT_ROUNDING - 1))
        -: 4796:		    + 4 + DEFAULT_ROUNDING - 1)
        -: 4797:		   & ~(DEFAULT_ROUNDING - 1));
        -: 4798:      size = 4096 - extra;
        -: 4799:    }
        -: 4800:
        -: 4801:#if defined(__STDC__) && __STDC__
        -: 4802:  h->chunkfun = (struct _obstack_chunk * (*)(void *,long)) chunkfun;
        -: 4803:  h->freefun = (void (*) (void *, struct _obstack_chunk *)) freefun;
        -: 4804:#else
        -: 4805:  h->chunkfun = (struct _obstack_chunk * (*)()) chunkfun;
        -: 4806:  h->freefun = freefun;
        -: 4807:#endif
        -: 4808:  h->chunk_size = size;
        -: 4809:  h->alignment_mask = alignment - 1;
        -: 4810:  h->extra_arg = arg;
        -: 4811:  h->use_extra_arg = 1;
        -: 4812:
        -: 4813:  chunk = h->chunk = CALL_CHUNKFUN (h, h -> chunk_size);
        -: 4814:  if (!chunk)
        -: 4815:    (*obstack_alloc_failed_handler) ();
        -: 4816:  h->next_free = h->object_base = chunk->contents;
        -: 4817:  h->chunk_limit = chunk->limit
        -: 4818:    = (char *) chunk + h->chunk_size;
        -: 4819:  chunk->prev = 0;
        -: 4820:  /* The initial chunk now contains no empty object.  */
        -: 4821:  h->maybe_empty_object = 0;
        -: 4822:  h->alloc_failed = 0;
        -: 4823:  return 1;
        -: 4824:}
        -: 4825:
        -: 4826:/* Allocate a new current chunk for the obstack *H
        -: 4827:   on the assumption that LENGTH bytes need to be added
        -: 4828:   to the current object, or a new object of length LENGTH allocated.
        -: 4829:   Copies any partial object from the end of the old chunk
        -: 4830:   to the beginning of the new one.  */
        -: 4831:
        -: 4832:void
        -: 4833:_obstack_newchunk (h, length)
        -: 4834:     struct obstack *h;
        -: 4835:     int length;
        -: 4836:{
        -: 4837:  register struct _obstack_chunk *old_chunk = h->chunk;
        -: 4838:  register struct _obstack_chunk *new_chunk;
        -: 4839:  register long	new_size;
        -: 4840:  register int obj_size = h->next_free - h->object_base;
        -: 4841:
        -: 4842:  /* Compute size for new chunk.  */
        -: 4843:  new_size = (obj_size + length) + (obj_size >> 3) + 100;
        -: 4844:  if (new_size < h->chunk_size)
        -: 4845:    new_size = h->chunk_size;
        -: 4846:
        -: 4847:  /* Allocate and initialize the new chunk.  */
        -: 4848:  new_chunk = CALL_CHUNKFUN (h, new_size);
        -: 4849:  if (!new_chunk)
        -: 4850:    (*obstack_alloc_failed_handler) ();
        -: 4851:  h->chunk = new_chunk;
        -: 4852:  new_chunk->prev = old_chunk;
        -: 4853:  new_chunk->limit = h->chunk_limit = (char *) new_chunk + new_size;
        -: 4854:
        -: 4855:  _obstack_memcpy(new_chunk->contents, h->object_base, obj_size);
        -: 4856:
        -: 4857:  /* If the object just copied was the only data in OLD_CHUNK, */
        -: 4858:  /* free that chunk and remove it from the chain. */
        -: 4859:  /* But not if that chunk might contain an empty object.  */
        -: 4860:  if (h->object_base == old_chunk->contents && ! h->maybe_empty_object)
        -: 4861:    {
        -: 4862:      new_chunk->prev = old_chunk->prev;
        -: 4863:      CALL_FREEFUN (h, old_chunk);
        -: 4864:    }
        -: 4865:
        -: 4866:  h->object_base = new_chunk->contents;
        -: 4867:  h->next_free = h->object_base + obj_size;
        -: 4868:  /* The new chunk certainly contains no empty object yet.  */
        -: 4869:  h->maybe_empty_object = 0;
        -: 4870:}
        -: 4871:
        -: 4872:/* Return nonzero if object OBJ has been allocated from obstack H.
        -: 4873:   This is here for debugging.
        -: 4874:   If you use it in a program, you are probably losing.  */
        -: 4875:
        -: 4876:#if defined (__STDC__) && __STDC__
        -: 4877:/* Suppress -Wmissing-prototypes warning.  We don't want to declare this in
        -: 4878:   obstack.h because it is just for debugging.  */
        -: 4879:int _obstack_allocated_p (struct obstack *h, POINTER obj);
        -: 4880:#endif
        -: 4881:
        -: 4882:int
        -: 4883:_obstack_allocated_p (h, obj)
        -: 4884:     struct obstack *h;
        -: 4885:     POINTER obj;
        -: 4886:{
        -: 4887:  register struct _obstack_chunk *lp;	/* below addr of any objects in this chunk */
        -: 4888:  register struct _obstack_chunk *plp;	/* point to previous chunk if any */
        -: 4889:
        -: 4890:  lp = (h)->chunk;
        -: 4891:  /* We use >= rather than > since the object cannot be exactly at
        -: 4892:     the beginning of the chunk but might be an empty object exactly
        -: 4893:     at the end of an adjacent chunk.  */
        -: 4894:  while (lp != 0 && ((POINTER) lp >= obj || (POINTER) (lp)->limit < obj))
        -: 4895:    {
        -: 4896:      plp = lp->prev;
        -: 4897:      lp = plp;
        -: 4898:    }
        -: 4899:  return lp != 0;
        -: 4900:}
        -: 4901:
        -: 4902:/* Free objects in obstack H, including OBJ and everything allocate
        -: 4903:   more recently than OBJ.  If OBJ is zero, free everything in H.  */
        -: 4904:
        -: 4905:#undef obstack_free
        -: 4906:
        -: 4907:/* This function has two names with identical definitions.
        -: 4908:   This is the first one, called from non-ANSI code.  */
        -: 4909:
        -: 4910:void
        -: 4911:_obstack_free (h, obj)
        -: 4912:     struct obstack *h;
        -: 4913:     POINTER obj;
        -: 4914:{
        -: 4915:  register struct _obstack_chunk *lp;	/* below addr of any objects in this chunk */
        -: 4916:  register struct _obstack_chunk *plp;	/* point to previous chunk if any */
        -: 4917:
        -: 4918:  lp = h->chunk;
        -: 4919:  /* We use >= because there cannot be an object at the beginning of a chunk.
        -: 4920:     But there can be an empty object at that address
        -: 4921:     at the end of another chunk.  */
        -: 4922:  while (lp != 0 && ((POINTER) lp >= obj || (POINTER) (lp)->limit < obj))
        -: 4923:    {
        -: 4924:      plp = lp->prev;
        -: 4925:      CALL_FREEFUN (h, lp);
        -: 4926:      lp = plp;
        -: 4927:      /* If we switch chunks, we can't tell whether the new current
        -: 4928:	 chunk contains an empty object, so assume that it may.  */
        -: 4929:      h->maybe_empty_object = 1;
        -: 4930:    }
        -: 4931:  if (lp)
        -: 4932:    {
        -: 4933:      h->object_base = h->next_free = (char *) (obj);
        -: 4934:      h->chunk_limit = lp->limit;
        -: 4935:      h->chunk = lp;
        -: 4936:    }
        -: 4937:  else if (obj != 0)
        -: 4938:    /* obj is not in any of the chunks! */
        -: 4939:    abort ();
        -: 4940:}
        -: 4941:
        -: 4942:/* This function is used from ANSI code.  */
        -: 4943:
        -: 4944:void
        -: 4945:obstack_free (h, obj)
        -: 4946:     struct obstack *h;
        -: 4947:     POINTER obj;
        -: 4948:{
        -: 4949:  register struct _obstack_chunk *lp;	/* below addr of any objects in this chunk */
        -: 4950:  register struct _obstack_chunk *plp;	/* point to previous chunk if any */
        -: 4951:
        -: 4952:  lp = h->chunk;
        -: 4953:  /* We use >= because there cannot be an object at the beginning of a chunk.
        -: 4954:     But there can be an empty object at that address
        -: 4955:     at the end of another chunk.  */
        -: 4956:  while (lp != 0 && ((POINTER) lp >= obj || (POINTER) (lp)->limit < obj))
        -: 4957:    {
        -: 4958:      plp = lp->prev;
        -: 4959:      CALL_FREEFUN (h, lp);
        -: 4960:      lp = plp;
        -: 4961:      /* If we switch chunks, we can't tell whether the new current
        -: 4962:	 chunk contains an empty object, so assume that it may.  */
        -: 4963:      h->maybe_empty_object = 1;
        -: 4964:    }
        -: 4965:  if (lp)
        -: 4966:    {
        -: 4967:      h->object_base = h->next_free = (char *) (obj);
        -: 4968:      h->chunk_limit = lp->limit;
        -: 4969:      h->chunk = lp;
        -: 4970:    }
        -: 4971:  else if (obj != 0)
        -: 4972:    /* obj is not in any of the chunks! */
        -: 4973:    abort ();
        -: 4974:}
        -: 4975:
        -: 4976:int
        -: 4977:_obstack_memory_used (h)
        -: 4978:     struct obstack *h;
        -: 4979:{
        -: 4980:  register struct _obstack_chunk* lp;
        -: 4981:  register int nbytes = 0;
        -: 4982:
        -: 4983:  for (lp = h->chunk; lp != 0; lp = lp->prev)
        -: 4984:    {
        -: 4985:      nbytes += lp->limit - (char *) lp;
        -: 4986:    }
        -: 4987:  return nbytes;
        -: 4988:}
        -: 4989:
        -: 4990:/* Define the error handler.  */
        -: 4991:#ifndef _
        -: 4992:# ifdef HAVE_LIBINTL_H
        -: 4993:#  include <libintl.h>
        -: 4994:#  ifndef _
        -: 4995:#   define _(Str) gettext (Str)
        -: 4996:#  endif
        -: 4997:# else
        -: 4998:#  define _(Str) (Str)
        -: 4999:# endif
        -: 5000:#endif
        -: 5001:
        -: 5002:static void
        -: 5003:print_and_abort ()
        -: 5004:{
        -: 5005:  fputs (_("memory exhausted\n"), stderr);
        -: 5006:  exit (obstack_exit_failure);
        -: 5007:}
        -: 5008:
        -: 5009:#if 0
        -: 5010:/* These are now turned off because the applications do not use it
        -: 5011:   and it uses bcopy via obstack_grow, which causes trouble on sysV.  */
        -: 5012:
        -: 5013:/* Now define the functional versions of the obstack macros.
        -: 5014:   Define them to simply use the corresponding macros to do the job.  */
        -: 5015:
        -: 5016:#if defined (__STDC__) && __STDC__
        -: 5017:/* These function definitions do not work with non-ANSI preprocessors;
        -: 5018:   they won't pass through the macro names in parentheses.  */
        -: 5019:
        -: 5020:/* The function names appear in parentheses in order to prevent
        -: 5021:   the macro-definitions of the names from being expanded there.  */
        -: 5022:
        -: 5023:POINTER (obstack_base) (obstack)
        -: 5024:     struct obstack *obstack;
        -: 5025:{
        -: 5026:  return obstack_base (obstack);
        -: 5027:}
        -: 5028:
        -: 5029:POINTER (obstack_next_free) (obstack)
        -: 5030:     struct obstack *obstack;
        -: 5031:{
        -: 5032:  return obstack_next_free (obstack);
        -: 5033:}
        -: 5034:
        -: 5035:int (obstack_object_size) (obstack)
        -: 5036:     struct obstack *obstack;
        -: 5037:{
        -: 5038:  return obstack_object_size (obstack);
        -: 5039:}
        -: 5040:
        -: 5041:int (obstack_room) (obstack)
        -: 5042:     struct obstack *obstack;
        -: 5043:{
        -: 5044:  return obstack_room (obstack);
        -: 5045:}
        -: 5046:
        -: 5047:int (obstack_make_room) (obstack, length)
        -: 5048:     struct obstack *obstack;
        -: 5049:     int length;
        -: 5050:{
        -: 5051:  return obstack_make_room (obstack, length);
        -: 5052:}
        -: 5053:
        -: 5054:void (obstack_grow) (obstack, pointer, length)
        -: 5055:     struct obstack *obstack;
        -: 5056:     POINTER pointer;
        -: 5057:     int length;
        -: 5058:{
        -: 5059:  obstack_grow (obstack, pointer, length);
        -: 5060:}
        -: 5061:
        -: 5062:void (obstack_grow0) (obstack, pointer, length)
        -: 5063:     struct obstack *obstack;
        -: 5064:     POINTER pointer;
        -: 5065:     int length;
        -: 5066:{
        -: 5067:  obstack_grow0 (obstack, pointer, length);
        -: 5068:}
        -: 5069:
        -: 5070:void (obstack_1grow) (obstack, character)
        -: 5071:     struct obstack *obstack;
        -: 5072:     int character;
        -: 5073:{
        -: 5074:  obstack_1grow (obstack, character);
        -: 5075:}
        -: 5076:
        -: 5077:void (obstack_blank) (obstack, length)
        -: 5078:     struct obstack *obstack;
        -: 5079:     int length;
        -: 5080:{
        -: 5081:  obstack_blank (obstack, length);
        -: 5082:}
        -: 5083:
        -: 5084:void (obstack_1grow_fast) (obstack, character)
        -: 5085:     struct obstack *obstack;
        -: 5086:     int character;
        -: 5087:{
        -: 5088:  obstack_1grow_fast (obstack, character);
        -: 5089:}
        -: 5090:
        -: 5091:void (obstack_blank_fast) (obstack, length)
        -: 5092:     struct obstack *obstack;
        -: 5093:     int length;
        -: 5094:{
        -: 5095:  obstack_blank_fast (obstack, length);
        -: 5096:}
        -: 5097:
        -: 5098:POINTER (obstack_finish) (obstack)
        -: 5099:     struct obstack *obstack;
        -: 5100:{
        -: 5101:  return obstack_finish (obstack);
        -: 5102:}
        -: 5103:
        -: 5104:POINTER (obstack_alloc) (obstack, length)
        -: 5105:     struct obstack *obstack;
        -: 5106:     int length;
        -: 5107:{
        -: 5108:  return obstack_alloc (obstack, length);
        -: 5109:}
        -: 5110:
        -: 5111:POINTER (obstack_copy) (obstack, pointer, length)
        -: 5112:     struct obstack *obstack;
        -: 5113:     POINTER pointer;
        -: 5114:     int length;
        -: 5115:{
        -: 5116:  return obstack_copy (obstack, pointer, length);
        -: 5117:}
        -: 5118:
        -: 5119:POINTER (obstack_copy0) (obstack, pointer, length)
        -: 5120:     struct obstack *obstack;
        -: 5121:     POINTER pointer;
        -: 5122:     int length;
        -: 5123:{
        -: 5124:  return obstack_copy0 (obstack, pointer, length);
        -: 5125:}
        -: 5126:
        -: 5127:#endif /* __STDC__ */
        -: 5128:
        -: 5129:#endif /* 0 */
        -: 5130:
        -: 5131:#endif	/* !ELIDE_CODE */
        -: 5132:#ifdef HAVE_CONFIG_H
        -: 5133:#include "config.h"
        -: 5134:#endif
        -: 5135:
        -: 5136:#include <stdio.h>
        -: 5137:
        -: 5138:#ifdef HAVE_STRINGS_H
        -: 5139:# include <strings.h>
        -: 5140:#else
        -: 5141:# include <string.h>
        -: 5142:#endif /* HAVE_STRINGS_H */
        -: 5143:
        -: 5144:#ifdef HAVE_STDLIB_H
        -: 5145:# include <stdlib.h>
        -: 5146:#endif /* HAVE_STDLIB_H */
        -: 5147:
        -: 5148:#include <limits.h>
        -: 5149:#include <errno.h>
        -: 5150:
        -: 5151:
        -: 5152:/* Getopt for GNU.
        -: 5153:   NOTE: getopt is now part of the C library, so if you don't know what
        -: 5154:   "Keep this file name-space clean" means, talk to drepper@gnu.org
        -: 5155:   before changing it!
        -: 5156:
        -: 5157:   Copyright (C) 1987, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98
        -: 5158:   	Free Software Foundation, Inc.
        -: 5159:
        -: 5160:   NOTE: The canonical source of this file is maintained with the GNU C Library.
        -: 5161:   Bugs can be reported to bug-glibc@gnu.org.
        -: 5162:
        -: 5163:   This program is free software; you can redistribute it and/or modify it
        -: 5164:   under the terms of the GNU General Public License as published by the
        -: 5165:   Free Software Foundation; either version 2, or (at your option) any
        -: 5166:   later version.
        -: 5167:
        -: 5168:   This program is distributed in the hope that it will be useful,
        -: 5169:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 5170:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 5171:   GNU General Public License for more details.
        -: 5172:
        -: 5173:   You should have received a copy of the GNU General Public License
        -: 5174:   along with this program; if not, write to the Free Software
        -: 5175:   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
        -: 5176:   USA.  */
        -: 5177:
        -: 5178:/* This tells Alpha OSF/1 not to define a getopt prototype in <stdio.h>.
        -: 5179:   Ditto for AIX 3.2 and <stdlib.h>.  */
        -: 5180:#ifndef _NO_PROTO
        -: 5181:# define _NO_PROTO
        -: 5182:#endif
        -: 5183:
        -: 5184:#ifdef HAVE_CONFIG_H
        -: 5185:# include <config.h>
        -: 5186:#endif
        -: 5187:
        -: 5188:#if !defined __STDC__ || !__STDC__
        -: 5189:/* This is a separate conditional since some stdc systems
        -: 5190:   reject `defined (const)'.  */
        -: 5191:# ifndef const
        -: 5192:#  define const
        -: 5193:# endif
        -: 5194:#endif
        -: 5195:
        -: 5196:#include <stdio.h>
        -: 5197:
        -: 5198:/* Comment out all this code if we are using the GNU C Library, and are not
        -: 5199:   actually compiling the library itself.  This code is part of the GNU C
        -: 5200:   Library, but also included in many other GNU distributions.  Compiling
        -: 5201:   and linking in this code is a waste when using the GNU C library
        -: 5202:   (especially if it is a shared library).  Rather than having every GNU
        -: 5203:   program understand `configure --with-gnu-libc' and omit the object files,
        -: 5204:   it is simpler to just do this in the source for each such file.  */
        -: 5205:
        -: 5206:#define GETOPT_INTERFACE_VERSION 2
        -: 5207:#if !defined _LIBC && defined __GLIBC__ && __GLIBC__ >= 2
        -: 5208:# include <gnu-versions.h>
        -: 5209:# if _GNU_GETOPT_INTERFACE_VERSION == GETOPT_INTERFACE_VERSION
        -: 5210:#  define ELIDE_CODE
        -: 5211:# endif
        -: 5212:#endif
        -: 5213:
        -: 5214:#ifndef ELIDE_CODE
        -: 5215:
        -: 5216:
        -: 5217:/* This needs to come after some library #include
        -: 5218:   to get __GNU_LIBRARY__ defined.  */
        -: 5219:#ifdef	__GNU_LIBRARY__
        -: 5220:/* Don't include stdlib.h for non-GNU C libraries because some of them
        -: 5221:   contain conflicting prototypes for getopt.  */
        -: 5222:# include <stdlib.h>
        -: 5223:# include <unistd.h>
        -: 5224:#endif	/* GNU C library.  */
        -: 5225:
        -: 5226:#ifdef VMS
        -: 5227:# include <unixlib.h>
        -: 5228:# if HAVE_STRING_H - 0
        -: 5229:#  include <string.h>
        -: 5230:# endif
        -: 5231:#endif
        -: 5232:
        -: 5233:#ifndef _
        -: 5234:/* This is for other GNU distributions with internationalized messages.
        -: 5235:   When compiling libc, the _ macro is predefined.  */
        -: 5236:# ifdef HAVE_LIBINTL_H
        -: 5237:#  include <libintl.h>
        -: 5238:#  define _(msgid)	gettext (msgid)
        -: 5239:# else
        -: 5240:#  define _(msgid)	(msgid)
        -: 5241:# endif
        -: 5242:#endif
        -: 5243:
        -: 5244:/* This version of `getopt' appears to the caller like standard Unix `getopt'
        -: 5245:   but it behaves differently for the user, since it allows the user
        -: 5246:   to intersperse the options with the other arguments.
        -: 5247:
        -: 5248:   As `getopt' works, it permutes the elements of ARGV so that,
        -: 5249:   when it is done, all the options precede everything else.  Thus
        -: 5250:   all application programs are extended to handle flexible argument order.
        -: 5251:
        -: 5252:   Setting the environment variable POSIXLY_CORRECT disables permutation.
        -: 5253:   Then the behavior is completely standard.
        -: 5254:
        -: 5255:   GNU application programs can use a third alternative mode in which
        -: 5256:   they can distinguish the relative order of options and other arguments.  */
        -: 5257:
        -: 5258:#include "getopt.h"
        -: 5259:
        -: 5260:/* For communication from `getopt' to the caller.
        -: 5261:   When `getopt' finds an option that takes an argument,
        -: 5262:   the argument value is returned here.
        -: 5263:   Also, when `ordering' is RETURN_IN_ORDER,
        -: 5264:   each non-option ARGV-element is returned here.  */
        -: 5265:
        -: 5266:char *optarg = NULL;
        -: 5267:
        -: 5268:/* Index in ARGV of the next element to be scanned.
        -: 5269:   This is used for communication to and from the caller
        -: 5270:   and for communication between successive calls to `getopt'.
        -: 5271:
        -: 5272:   On entry to `getopt', zero means this is the first call; initialize.
        -: 5273:
        -: 5274:   When `getopt' returns -1, this is the index of the first of the
        -: 5275:   non-option elements that the caller should itself scan.
        -: 5276:
        -: 5277:   Otherwise, `optind' communicates from one call to the next
        -: 5278:   how much of ARGV has been scanned so far.  */
        -: 5279:
        -: 5280:/* 1003.2 says this must be 1 before any call.  */
        -: 5281:int optind = 1;
        -: 5282:
        -: 5283:/* Formerly, initialization of getopt depended on optind==0, which
        -: 5284:   causes problems with re-calling getopt as programs generally don't
        -: 5285:   know that. */
        -: 5286:
        -: 5287:int __getopt_initialized = 0;
        -: 5288:
        -: 5289:/* The next char to be scanned in the option-element
        -: 5290:   in which the last option character we returned was found.
        -: 5291:   This allows us to pick up the scan where we left off.
        -: 5292:
        -: 5293:   If this is zero, or a null string, it means resume the scan
        -: 5294:   by advancing to the next ARGV-element.  */
        -: 5295:
        -: 5296:static char *nextchar;
        -: 5297:
        -: 5298:/* Callers store zero here to inhibit the error message
        -: 5299:   for unrecognized options.  */
        -: 5300:
        -: 5301:int opterr = 1;
        -: 5302:
        -: 5303:/* Set to an option character which was unrecognized.
        -: 5304:   This must be initialized on some systems to avoid linking in the
        -: 5305:   system's own getopt implementation.  */
        -: 5306:
        -: 5307:int optopt = '?';
        -: 5308:
        -: 5309:/* Describe how to deal with options that follow non-option ARGV-elements.
        -: 5310:
        -: 5311:   If the caller did not specify anything,
        -: 5312:   the default is REQUIRE_ORDER if the environment variable
        -: 5313:   POSIXLY_CORRECT is defined, PERMUTE otherwise.
        -: 5314:
        -: 5315:   REQUIRE_ORDER means don't recognize them as options;
        -: 5316:   stop option processing when the first non-option is seen.
        -: 5317:   This is what Unix does.
        -: 5318:   This mode of operation is selected by either setting the environment
        -: 5319:   variable POSIXLY_CORRECT, or using `+' as the first character
        -: 5320:   of the list of option characters.
        -: 5321:
        -: 5322:   PERMUTE is the default.  We permute the contents of ARGV as we scan,
        -: 5323:   so that eventually all the non-options are at the end.  This allows options
        -: 5324:   to be given in any order, even with programs that were not written to
        -: 5325:   expect this.
        -: 5326:
        -: 5327:   RETURN_IN_ORDER is an option available to programs that were written
        -: 5328:   to expect options and other ARGV-elements in any order and that care about
        -: 5329:   the ordering of the two.  We describe each non-option ARGV-element
        -: 5330:   as if it were the argument of an option with character code 1.
        -: 5331:   Using `-' as the first character of the list of option characters
        -: 5332:   selects this mode of operation.
        -: 5333:
        -: 5334:   The special argument `--' forces an end of option-scanning regardless
        -: 5335:   of the value of `ordering'.  In the case of RETURN_IN_ORDER, only
        -: 5336:   `--' can cause `getopt' to return -1 with `optind' != ARGC.  */
        -: 5337:
        -: 5338:static enum
        -: 5339:{
        -: 5340:  REQUIRE_ORDER, PERMUTE, RETURN_IN_ORDER
        -: 5341:} ordering;
        -: 5342:
        -: 5343:/* Value of POSIXLY_CORRECT environment variable.  */
        -: 5344:static char *posixly_correct;
        -: 5345:
        -: 5346:#ifdef	__GNU_LIBRARY__
        -: 5347:/* We want to avoid inclusion of string.h with non-GNU libraries
        -: 5348:   because there are many ways it can cause trouble.
        -: 5349:   On some systems, it contains special magic macros that don't work
        -: 5350:   in GCC.  */
        -: 5351:# include <string.h>
        -: 5352:# define my_index	strchr
        -: 5353:#else
        -: 5354:
        -: 5355:/* Avoid depending on library functions or files
        -: 5356:   whose names are inconsistent.  */
        -: 5357:
        -: 5358:#ifndef getenv
        -: 5359:extern char *getenv ();
        -: 5360:#endif
        -: 5361:#ifndef strncmp
        -: 5362:extern int strncmp ();
        -: 5363:#endif
        -: 5364:
        -: 5365:static char *
        -: 5366:my_index (str, chr)
        -: 5367:     const char *str;
        -: 5368:     int chr;
        -: 5369:{
        -: 5370:  while (*str)
        -: 5371:    {
        -: 5372:      if (*str == chr)
        -: 5373:	return (char *) str;
        -: 5374:      str++;
        -: 5375:    }
        -: 5376:  return 0;
        -: 5377:}
        -: 5378:
        -: 5379:/* If using GCC, we can safely declare strlen this way.
        -: 5380:   If not using GCC, it is ok not to declare it.  */
        -: 5381:#ifdef __GNUC__
        -: 5382:/* Note that Motorola Delta 68k R3V7 comes with GCC but not stddef.h.
        -: 5383:   That was relevant to code that was here before.  */
        -: 5384:# if (!defined __STDC__ || !__STDC__) && !defined strlen
        -: 5385:/* gcc with -traditional declares the built-in strlen to return int,
        -: 5386:   and has done so at least since version 2.4.5. -- rms.  */
        -: 5387:extern int strlen (const char *);
        -: 5388:# endif /* not __STDC__ */
        -: 5389:#endif /* __GNUC__ */
        -: 5390:
        -: 5391:#endif /* not __GNU_LIBRARY__ */
        -: 5392:
        -: 5393:/* Handle permutation of arguments.  */
        -: 5394:
        -: 5395:/* Describe the part of ARGV that contains non-options that have
        -: 5396:   been skipped.  `first_nonopt' is the index in ARGV of the first of them;
        -: 5397:   `last_nonopt' is the index after the last of them.  */
        -: 5398:
        -: 5399:static int first_nonopt;
        -: 5400:static int last_nonopt;
        -: 5401:
        -: 5402:#ifdef _LIBC
        -: 5403:/* Bash 2.0 gives us an environment variable containing flags
        -: 5404:   indicating ARGV elements that should not be considered arguments.  */
        -: 5405:
        -: 5406:/* Defined in getopt_init.c  */
        -: 5407:extern char *__getopt_nonoption_flags;
        -: 5408:
        -: 5409:static int nonoption_flags_max_len;
        -: 5410:static int nonoption_flags_len;
        -: 5411:
        -: 5412:static int original_argc;
        -: 5413:static char *const *original_argv;
        -: 5414:
        -: 5415:/* Make sure the environment variable bash 2.0 puts in the environment
        -: 5416:   is valid for the getopt call we must make sure that the ARGV passed
        -: 5417:   to getopt is that one passed to the process.  */
        -: 5418:static void
        -: 5419:__attribute__ ((unused))
        -: 5420:store_args_and_env (int argc, char *const *argv)
        -: 5421:{
        -: 5422:  /* XXX This is no good solution.  We should rather copy the args so
        -: 5423:     that we can compare them later.  But we must not use malloc(3).  */
        -: 5424:  original_argc = argc;
        -: 5425:  original_argv = argv;
        -: 5426:}
        -: 5427:# ifdef text_set_element
        -: 5428:text_set_element (__libc_subinit, store_args_and_env);
        -: 5429:# endif /* text_set_element */
        -: 5430:
        -: 5431:# define SWAP_FLAGS(ch1, ch2) \
        -: 5432:  if (nonoption_flags_len > 0)						      \
        -: 5433:    {									      \
        -: 5434:      char __tmp = __getopt_nonoption_flags[ch1];			      \
        -: 5435:      __getopt_nonoption_flags[ch1] = __getopt_nonoption_flags[ch2];	      \
        -: 5436:      __getopt_nonoption_flags[ch2] = __tmp;				      \
        -: 5437:    }
        -: 5438:#else	/* !_LIBC */
        -: 5439:# define SWAP_FLAGS(ch1, ch2)
        -: 5440:#endif	/* _LIBC */
        -: 5441:
        -: 5442:/* Exchange two adjacent subsequences of ARGV.
        -: 5443:   One subsequence is elements [first_nonopt,last_nonopt)
        -: 5444:   which contains all the non-options that have been skipped so far.
        -: 5445:   The other is elements [last_nonopt,optind), which contains all
        -: 5446:   the options processed since those non-options were skipped.
        -: 5447:
        -: 5448:   `first_nonopt' and `last_nonopt' are relocated so that they describe
        -: 5449:   the new indices of the non-options in ARGV after they are moved.  */
        -: 5450:
        -: 5451:#if defined __STDC__ && __STDC__
        -: 5452:static void exchange (char **);
        -: 5453:#endif
        -: 5454:
        -: 5455:static void
        -: 5456:exchange (argv)
        -: 5457:     char **argv;
        -: 5458:{
        -: 5459:  int bottom = first_nonopt;
        -: 5460:  int middle = last_nonopt;
        -: 5461:  int top = optind;
        -: 5462:  char *tem;
        -: 5463:
        -: 5464:  /* Exchange the shorter segment with the far end of the longer segment.
        -: 5465:     That puts the shorter segment into the right place.
        -: 5466:     It leaves the longer segment in the right place overall,
        -: 5467:     but it consists of two parts that need to be swapped next.  */
        -: 5468:
        -: 5469:#ifdef _LIBC
        -: 5470:  /* First make sure the handling of the `__getopt_nonoption_flags'
        -: 5471:     string can work normally.  Our top argument must be in the range
        -: 5472:     of the string.  */
        -: 5473:  if (nonoption_flags_len > 0 && top >= nonoption_flags_max_len)
        -: 5474:    {
        -: 5475:      /* We must extend the array.  The user plays games with us and
        -: 5476:	 presents new arguments.  */
        -: 5477:      char *new_str = malloc (top + 1);
        -: 5478:      if (new_str == NULL)
        -: 5479:	nonoption_flags_len = nonoption_flags_max_len = 0;
        -: 5480:      else
        -: 5481:	{
        -: 5482:	  memset (__mempcpy (new_str, __getopt_nonoption_flags,
        -: 5483:			     nonoption_flags_max_len),
        -: 5484:		  '\0', top + 1 - nonoption_flags_max_len);
        -: 5485:	  nonoption_flags_max_len = top + 1;
        -: 5486:	  __getopt_nonoption_flags = new_str;
        -: 5487:	}
        -: 5488:    }
        -: 5489:#endif
        -: 5490:
        -: 5491:  while (top > middle && middle > bottom)
        -: 5492:    {
        -: 5493:      if (top - middle > middle - bottom)
        -: 5494:	{
        -: 5495:	  /* Bottom segment is the short one.  */
        -: 5496:	  int len = middle - bottom;
        -: 5497:	  register int i;
        -: 5498:
        -: 5499:	  /* Swap it with the top part of the top segment.  */
        -: 5500:	  for (i = 0; i < len; i++)
        -: 5501:	    {
        -: 5502:	      tem = argv[bottom + i];
        -: 5503:	      argv[bottom + i] = argv[top - (middle - bottom) + i];
        -: 5504:	      argv[top - (middle - bottom) + i] = tem;
        -: 5505:	      SWAP_FLAGS (bottom + i, top - (middle - bottom) + i);
        -: 5506:	    }
        -: 5507:	  /* Exclude the moved bottom segment from further swapping.  */
        -: 5508:	  top -= len;
        -: 5509:	}
        -: 5510:      else
        -: 5511:	{
        -: 5512:	  /* Top segment is the short one.  */
        -: 5513:	  int len = top - middle;
        -: 5514:	  register int i;
        -: 5515:
        -: 5516:	  /* Swap it with the bottom part of the bottom segment.  */
        -: 5517:	  for (i = 0; i < len; i++)
        -: 5518:	    {
        -: 5519:	      tem = argv[bottom + i];
        -: 5520:	      argv[bottom + i] = argv[middle + i];
        -: 5521:	      argv[middle + i] = tem;
        -: 5522:	      SWAP_FLAGS (bottom + i, middle + i);
        -: 5523:	    }
        -: 5524:	  /* Exclude the moved top segment from further swapping.  */
        -: 5525:	  bottom += len;
        -: 5526:	}
        -: 5527:    }
        -: 5528:
        -: 5529:  /* Update records for the slots the non-options now occupy.  */
        -: 5530:
        -: 5531:  first_nonopt += (optind - last_nonopt);
        -: 5532:  last_nonopt = optind;
        -: 5533:}
        -: 5534:
        -: 5535:/* Initialize the internal data when the first call is made.  */
        -: 5536:
        -: 5537:#if defined __STDC__ && __STDC__
        -: 5538:static const char *_getopt_initialize (int, char *const *, const char *);
        -: 5539:#endif
        -: 5540:static const char *
        -: 5541:_getopt_initialize (argc, argv, optstring)
        -: 5542:     int argc;
        -: 5543:     char *const *argv;
        -: 5544:     const char *optstring;
        -: 5545:{
        -: 5546:  /* Start processing options with ARGV-element 1 (since ARGV-element 0
        -: 5547:     is the program name); the sequence of previously skipped
        -: 5548:     non-option ARGV-elements is empty.  */
        -: 5549:
        -: 5550:  first_nonopt = last_nonopt = optind;
        -: 5551:
        -: 5552:  nextchar = NULL;
        -: 5553:
        -: 5554:  posixly_correct = getenv ("POSIXLY_CORRECT");
        -: 5555:
        -: 5556:  /* Determine how to handle the ordering of options and nonoptions.  */
        -: 5557:
        -: 5558:  if (optstring[0] == '-')
        -: 5559:    {
        -: 5560:      ordering = RETURN_IN_ORDER;
        -: 5561:      ++optstring;
        -: 5562:    }
        -: 5563:  else if (optstring[0] == '+')
        -: 5564:    {
        -: 5565:      ordering = REQUIRE_ORDER;
        -: 5566:      ++optstring;
        -: 5567:    }
        -: 5568:  else if (posixly_correct != NULL)
        -: 5569:    ordering = REQUIRE_ORDER;
        -: 5570:  else
        -: 5571:    ordering = PERMUTE;
        -: 5572:
        -: 5573:#ifdef _LIBC
        -: 5574:  if (posixly_correct == NULL
        -: 5575:      && argc == original_argc && argv == original_argv)
        -: 5576:    {
        -: 5577:      if (nonoption_flags_max_len == 0)
        -: 5578:	{
        -: 5579:	  if (__getopt_nonoption_flags == NULL
        -: 5580:	      || __getopt_nonoption_flags[0] == '\0')
        -: 5581:	    nonoption_flags_max_len = -1;
        -: 5582:	  else
        -: 5583:	    {
        -: 5584:	      const char *orig_str = __getopt_nonoption_flags;
        -: 5585:	      int len = nonoption_flags_max_len = strlen (orig_str);
        -: 5586:	      if (nonoption_flags_max_len < argc)
        -: 5587:		nonoption_flags_max_len = argc;
        -: 5588:	      __getopt_nonoption_flags =
        -: 5589:		(char *) malloc (nonoption_flags_max_len);
        -: 5590:	      if (__getopt_nonoption_flags == NULL)
        -: 5591:		nonoption_flags_max_len = -1;
        -: 5592:	      else
        -: 5593:		memset (__mempcpy (__getopt_nonoption_flags, orig_str, len),
        -: 5594:			'\0', nonoption_flags_max_len - len);
        -: 5595:	    }
        -: 5596:	}
        -: 5597:      nonoption_flags_len = nonoption_flags_max_len;
        -: 5598:    }
        -: 5599:  else
        -: 5600:    nonoption_flags_len = 0;
        -: 5601:#endif
        -: 5602:
        -: 5603:  return optstring;
        -: 5604:}
        -: 5605:
        -: 5606:/* Scan elements of ARGV (whose length is ARGC) for option characters
        -: 5607:   given in OPTSTRING.
        -: 5608:
        -: 5609:   If an element of ARGV starts with '-', and is not exactly "-" or "--",
        -: 5610:   then it is an option element.  The characters of this element
        -: 5611:   (aside from the initial '-') are option characters.  If `getopt'
        -: 5612:   is called repeatedly, it returns successively each of the option characters
        -: 5613:   from each of the option elements.
        -: 5614:
        -: 5615:   If `getopt' finds another option character, it returns that character,
        -: 5616:   updating `optind' and `nextchar' so that the next call to `getopt' can
        -: 5617:   resume the scan with the following option character or ARGV-element.
        -: 5618:
        -: 5619:   If there are no more option characters, `getopt' returns -1.
        -: 5620:   Then `optind' is the index in ARGV of the first ARGV-element
        -: 5621:   that is not an option.  (The ARGV-elements have been permuted
        -: 5622:   so that those that are not options now come last.)
        -: 5623:
        -: 5624:   OPTSTRING is a string containing the legitimate option characters.
        -: 5625:   If an option character is seen that is not listed in OPTSTRING,
        -: 5626:   return '?' after printing an error message.  If you set `opterr' to
        -: 5627:   zero, the error message is suppressed but we still return '?'.
        -: 5628:
        -: 5629:   If a char in OPTSTRING is followed by a colon, that means it wants an arg,
        -: 5630:   so the following text in the same ARGV-element, or the text of the following
        -: 5631:   ARGV-element, is returned in `optarg'.  Two colons mean an option that
        -: 5632:   wants an optional arg; if there is text in the current ARGV-element,
        -: 5633:   it is returned in `optarg', otherwise `optarg' is set to zero.
        -: 5634:
        -: 5635:   If OPTSTRING starts with `-' or `+', it requests different methods of
        -: 5636:   handling the non-option ARGV-elements.
        -: 5637:   See the comments about RETURN_IN_ORDER and REQUIRE_ORDER, above.
        -: 5638:
        -: 5639:   Long-named options begin with `--' instead of `-'.
        -: 5640:   Their names may be abbreviated as long as the abbreviation is unique
        -: 5641:   or is an exact match for some defined option.  If they have an
        -: 5642:   argument, it follows the option name in the same ARGV-element, separated
        -: 5643:   from the option name by a `=', or else the in next ARGV-element.
        -: 5644:   When `getopt' finds a long-named option, it returns 0 if that option's
        -: 5645:   `flag' field is nonzero, the value of the option's `val' field
        -: 5646:   if the `flag' field is zero.
        -: 5647:
        -: 5648:   The elements of ARGV aren't really const, because we permute them.
        -: 5649:   But we pretend they're const in the prototype to be compatible
        -: 5650:   with other systems.
        -: 5651:
        -: 5652:   LONGOPTS is a vector of `struct option' terminated by an
        -: 5653:   element containing a name which is zero.
        -: 5654:
        -: 5655:   LONGIND returns the index in LONGOPT of the long-named option found.
        -: 5656:   It is only valid when a long-named option has been found by the most
        -: 5657:   recent call.
        -: 5658:
        -: 5659:   If LONG_ONLY is nonzero, '-' as well as '--' can introduce
        -: 5660:   long-named options.  */
        -: 5661:
        -: 5662:int
        -: 5663:_getopt_internal (argc, argv, optstring, longopts, longind, long_only)
        -: 5664:     int argc;
        -: 5665:     char *const *argv;
        -: 5666:     const char *optstring;
        -: 5667:     const struct option *longopts;
        -: 5668:     int *longind;
        -: 5669:     int long_only;
        -: 5670:{
        -: 5671:  optarg = NULL;
        -: 5672:
        -: 5673:  if (optind == 0 || !__getopt_initialized)
        -: 5674:    {
        -: 5675:      if (optind == 0)
        -: 5676:	optind = 1;	/* Don't scan ARGV[0], the program name.  */
        -: 5677:      optstring = _getopt_initialize (argc, argv, optstring);
        -: 5678:      __getopt_initialized = 1;
        -: 5679:    }
        -: 5680:
        -: 5681:  /* Test whether ARGV[optind] points to a non-option argument.
        -: 5682:     Either it does not have option syntax, or there is an environment flag
        -: 5683:     from the shell indicating it is not an option.  The later information
        -: 5684:     is only used when the used in the GNU libc.  */
        -: 5685:#ifdef _LIBC
        -: 5686:# define NONOPTION_P (argv[optind][0] != '-' || argv[optind][1] == '\0'	      \
        -: 5687:		      || (optind < nonoption_flags_len			      \
        -: 5688:			  && __getopt_nonoption_flags[optind] == '1'))
        -: 5689:#else
        -: 5690:# define NONOPTION_P (argv[optind][0] != '-' || argv[optind][1] == '\0')
        -: 5691:#endif
        -: 5692:
        -: 5693:  if (nextchar == NULL || *nextchar == '\0')
        -: 5694:    {
        -: 5695:      /* Advance to the next ARGV-element.  */
        -: 5696:
        -: 5697:      /* Give FIRST_NONOPT & LAST_NONOPT rational values if OPTIND has been
        -: 5698:	 moved back by the user (who may also have changed the arguments).  */
        -: 5699:      if (last_nonopt > optind)
        -: 5700:	last_nonopt = optind;
        -: 5701:      if (first_nonopt > optind)
        -: 5702:	first_nonopt = optind;
        -: 5703:
        -: 5704:      if (ordering == PERMUTE)
        -: 5705:	{
        -: 5706:	  /* If we have just processed some options following some non-options,
        -: 5707:	     exchange them so that the options come first.  */
        -: 5708:
        -: 5709:	  if (first_nonopt != last_nonopt && last_nonopt != optind)
        -: 5710:	    exchange ((char **) argv);
        -: 5711:	  else if (last_nonopt != optind)
        -: 5712:	    first_nonopt = optind;
        -: 5713:
        -: 5714:	  /* Skip any additional non-options
        -: 5715:	     and extend the range of non-options previously skipped.  */
        -: 5716:
        -: 5717:	  while (optind < argc && NONOPTION_P)
        -: 5718:	    optind++;
        -: 5719:	  last_nonopt = optind;
        -: 5720:	}
        -: 5721:
        -: 5722:      /* The special ARGV-element `--' means premature end of options.
        -: 5723:	 Skip it like a null option,
        -: 5724:	 then exchange with previous non-options as if it were an option,
        -: 5725:	 then skip everything else like a non-option.  */
        -: 5726:
        -: 5727:      if (optind != argc && !strcmp (argv[optind], "--"))
        -: 5728:	{
        -: 5729:	  optind++;
        -: 5730:
        -: 5731:	  if (first_nonopt != last_nonopt && last_nonopt != optind)
        -: 5732:	    exchange ((char **) argv);
        -: 5733:	  else if (first_nonopt == last_nonopt)
        -: 5734:	    first_nonopt = optind;
        -: 5735:	  last_nonopt = argc;
        -: 5736:
        -: 5737:	  optind = argc;
        -: 5738:	}
        -: 5739:
        -: 5740:      /* If we have done all the ARGV-elements, stop the scan
        -: 5741:	 and back over any non-options that we skipped and permuted.  */
        -: 5742:
        -: 5743:      if (optind == argc)
        -: 5744:	{
        -: 5745:	  /* Set the next-arg-index to point at the non-options
        -: 5746:	     that we previously skipped, so the caller will digest them.  */
        -: 5747:	  if (first_nonopt != last_nonopt)
        -: 5748:	    optind = first_nonopt;
        -: 5749:	  return -1;
        -: 5750:	}
        -: 5751:
        -: 5752:      /* If we have come to a non-option and did not permute it,
        -: 5753:	 either stop the scan or describe it to the caller and pass it by.  */
        -: 5754:
        -: 5755:      if (NONOPTION_P)
        -: 5756:	{
        -: 5757:	  if (ordering == REQUIRE_ORDER)
        -: 5758:	    return -1;
        -: 5759:	  optarg = argv[optind++];
        -: 5760:	  return 1;
        -: 5761:	}
        -: 5762:
        -: 5763:      /* We have found another option-ARGV-element.
        -: 5764:	 Skip the initial punctuation.  */
        -: 5765:
        -: 5766:      nextchar = (argv[optind] + 1
        -: 5767:		  + (longopts != NULL && argv[optind][1] == '-'));
        -: 5768:    }
        -: 5769:
        -: 5770:  /* Decode the current option-ARGV-element.  */
        -: 5771:
        -: 5772:  /* Check whether the ARGV-element is a long option.
        -: 5773:
        -: 5774:     If long_only and the ARGV-element has the form "-f", where f is
        -: 5775:     a valid short option, don't consider it an abbreviated form of
        -: 5776:     a long option that starts with f.  Otherwise there would be no
        -: 5777:     way to give the -f short option.
        -: 5778:
        -: 5779:     On the other hand, if there's a long option "fubar" and
        -: 5780:     the ARGV-element is "-fu", do consider that an abbreviation of
        -: 5781:     the long option, just like "--fu", and not "-f" with arg "u".
        -: 5782:
        -: 5783:     This distinction seems to be the most useful approach.  */
        -: 5784:
        -: 5785:  if (longopts != NULL
        -: 5786:      && (argv[optind][1] == '-'
        -: 5787:	  || (long_only && (argv[optind][2] || !my_index (optstring, argv[optind][1])))))
        -: 5788:    {
        -: 5789:      char *nameend;
        -: 5790:      const struct option *p;
        -: 5791:      const struct option *pfound = NULL;
        -: 5792:      int exact = 0;
        -: 5793:      int ambig = 0;
        -: 5794:      int indfound = -1;
        -: 5795:      int option_index;
        -: 5796:
        -: 5797:      for (nameend = nextchar; *nameend && *nameend != '='; nameend++)
        -: 5798:	/* Do nothing.  */ ;
        -: 5799:
        -: 5800:      /* Test all long options for either exact match
        -: 5801:	 or abbreviated matches.  */
        -: 5802:      for (p = longopts, option_index = 0; p->name; p++, option_index++)
        -: 5803:	if (!strncmp (p->name, nextchar, nameend - nextchar))
        -: 5804:	  {
        -: 5805:	    if ((unsigned int) (nameend - nextchar)
        -: 5806:		== (unsigned int) strlen (p->name))
        -: 5807:	      {
        -: 5808:		/* Exact match found.  */
        -: 5809:		pfound = p;
        -: 5810:		indfound = option_index;
        -: 5811:		exact = 1;
        -: 5812:		break;
        -: 5813:	      }
        -: 5814:	    else if (pfound == NULL)
        -: 5815:	      {
        -: 5816:		/* First nonexact match found.  */
        -: 5817:		pfound = p;
        -: 5818:		indfound = option_index;
        -: 5819:	      }
        -: 5820:	    else
        -: 5821:	      /* Second or later nonexact match found.  */
        -: 5822:	      ambig = 1;
        -: 5823:	  }
        -: 5824:
        -: 5825:      if (ambig && !exact)
        -: 5826:	{
        -: 5827:	  if (opterr)
        -: 5828:	    fprintf (stderr, _("%s: option `%s' is ambiguous\n"),
        -: 5829:		     argv[0], argv[optind]);
        -: 5830:	  nextchar += strlen (nextchar);
        -: 5831:	  optind++;
        -: 5832:	  optopt = 0;
        -: 5833:	  return '?';
        -: 5834:	}
        -: 5835:
        -: 5836:      if (pfound != NULL)
        -: 5837:	{
        -: 5838:	  option_index = indfound;
        -: 5839:	  optind++;
        -: 5840:	  if (*nameend)
        -: 5841:	    {
        -: 5842:	      /* Don't test has_arg with >, because some C compilers don't
        -: 5843:		 allow it to be used on enums.  */
        -: 5844:	      if (pfound->has_arg)
        -: 5845:		optarg = nameend + 1;
        -: 5846:	      else
        -: 5847:		{
        -: 5848:		  if (opterr)
        -: 5849:		   if (argv[optind - 1][1] == '-')
        -: 5850:		    /* --option */
        -: 5851:		    fprintf (stderr,
        -: 5852:		     _("%s: option `--%s' doesn't allow an argument\n"),
        -: 5853:		     argv[0], pfound->name);
        -: 5854:		   else
        -: 5855:		    /* +option or -option */
        -: 5856:		    fprintf (stderr,
        -: 5857:		     _("%s: option `%c%s' doesn't allow an argument\n"),
        -: 5858:		     argv[0], argv[optind - 1][0], pfound->name);
        -: 5859:
        -: 5860:		  nextchar += strlen (nextchar);
        -: 5861:
        -: 5862:		  optopt = pfound->val;
        -: 5863:		  return '?';
        -: 5864:		}
        -: 5865:	    }
        -: 5866:	  else if (pfound->has_arg == 1)
        -: 5867:	    {
        -: 5868:	      if (optind < argc)
        -: 5869:		optarg = argv[optind++];
        -: 5870:	      else
        -: 5871:		{
        -: 5872:		  if (opterr)
        -: 5873:		    fprintf (stderr,
        -: 5874:			   _("%s: option `%s' requires an argument\n"),
        -: 5875:			   argv[0], argv[optind - 1]);
        -: 5876:		  nextchar += strlen (nextchar);
        -: 5877:		  optopt = pfound->val;
        -: 5878:		  return optstring[0] == ':' ? ':' : '?';
        -: 5879:		}
        -: 5880:	    }
        -: 5881:	  nextchar += strlen (nextchar);
        -: 5882:	  if (longind != NULL)
        -: 5883:	    *longind = option_index;
        -: 5884:	  if (pfound->flag)
        -: 5885:	    {
        -: 5886:	      *(pfound->flag) = pfound->val;
        -: 5887:	      return 0;
        -: 5888:	    }
        -: 5889:	  return pfound->val;
        -: 5890:	}
        -: 5891:
        -: 5892:      /* Can't find it as a long option.  If this is not getopt_long_only,
        -: 5893:	 or the option starts with '--' or is not a valid short
        -: 5894:	 option, then it's an error.
        -: 5895:	 Otherwise interpret it as a short option.  */
        -: 5896:      if (!long_only || argv[optind][1] == '-'
        -: 5897:	  || my_index (optstring, *nextchar) == NULL)
        -: 5898:	{
        -: 5899:	  if (opterr)
        -: 5900:	    {
        -: 5901:	      if (argv[optind][1] == '-')
        -: 5902:		/* --option */
        -: 5903:		fprintf (stderr, _("%s: unrecognized option `--%s'\n"),
        -: 5904:			 argv[0], nextchar);
        -: 5905:	      else
        -: 5906:		/* +option or -option */
        -: 5907:		fprintf (stderr, _("%s: unrecognized option `%c%s'\n"),
        -: 5908:			 argv[0], argv[optind][0], nextchar);
        -: 5909:	    }
        -: 5910:	  nextchar = (char *) "";
        -: 5911:	  optind++;
        -: 5912:	  optopt = 0;
        -: 5913:	  return '?';
        -: 5914:	}
        -: 5915:    }
        -: 5916:
        -: 5917:  /* Look at and handle the next short option-character.  */
        -: 5918:
        -: 5919:  {
        -: 5920:    char c = *nextchar++;
        -: 5921:    char *temp = my_index (optstring, c);
        -: 5922:
        -: 5923:    /* Increment `optind' when we start to process its last character.  */
        -: 5924:    if (*nextchar == '\0')
        -: 5925:      ++optind;
        -: 5926:
        -: 5927:    if (temp == NULL || c == ':')
        -: 5928:      {
        -: 5929:	if (opterr)
        -: 5930:	  {
        -: 5931:	    if (posixly_correct)
        -: 5932:	      /* 1003.2 specifies the format of this message.  */
        -: 5933:	      fprintf (stderr, _("%s: illegal option -- %c\n"),
        -: 5934:		       argv[0], c);
        -: 5935:	    else
        -: 5936:	      fprintf (stderr, _("%s: invalid option -- %c\n"),
        -: 5937:		       argv[0], c);
        -: 5938:	  }
        -: 5939:	optopt = c;
        -: 5940:	return '?';
        -: 5941:      }
        -: 5942:    /* Convenience. Treat POSIX -W foo same as long option --foo */
        -: 5943:    if (temp[0] == 'W' && temp[1] == ';')
        -: 5944:      {
        -: 5945:	char *nameend;
        -: 5946:	const struct option *p;
        -: 5947:	const struct option *pfound = NULL;
        -: 5948:	int exact = 0;
        -: 5949:	int ambig = 0;
        -: 5950:	int indfound = 0;
        -: 5951:	int option_index;
        -: 5952:
        -: 5953:	/* This is an option that requires an argument.  */
        -: 5954:	if (*nextchar != '\0')
        -: 5955:	  {
        -: 5956:	    optarg = nextchar;
        -: 5957:	    /* If we end this ARGV-element by taking the rest as an arg,
        -: 5958:	       we must advance to the next element now.  */
        -: 5959:	    optind++;
        -: 5960:	  }
        -: 5961:	else if (optind == argc)
        -: 5962:	  {
        -: 5963:	    if (opterr)
        -: 5964:	      {
        -: 5965:		/* 1003.2 specifies the format of this message.  */
        -: 5966:		fprintf (stderr, _("%s: option requires an argument -- %c\n"),
        -: 5967:			 argv[0], c);
        -: 5968:	      }
        -: 5969:	    optopt = c;
        -: 5970:	    if (optstring[0] == ':')
        -: 5971:	      c = ':';
        -: 5972:	    else
        -: 5973:	      c = '?';
        -: 5974:	    return c;
        -: 5975:	  }
        -: 5976:	else
        -: 5977:	  /* We already incremented `optind' once;
        -: 5978:	     increment it again when taking next ARGV-elt as argument.  */
        -: 5979:	  optarg = argv[optind++];
        -: 5980:
        -: 5981:	/* optarg is now the argument, see if it's in the
        -: 5982:	   table of longopts.  */
        -: 5983:
        -: 5984:	for (nextchar = nameend = optarg; *nameend && *nameend != '='; nameend++)
        -: 5985:	  /* Do nothing.  */ ;
        -: 5986:
        -: 5987:	/* Test all long options for either exact match
        -: 5988:	   or abbreviated matches.  */
        -: 5989:	for (p = longopts, option_index = 0; p->name; p++, option_index++)
        -: 5990:	  if (!strncmp (p->name, nextchar, nameend - nextchar))
        -: 5991:	    {
        -: 5992:	      if ((unsigned int) (nameend - nextchar) == strlen (p->name))
        -: 5993:		{
        -: 5994:		  /* Exact match found.  */
        -: 5995:		  pfound = p;
        -: 5996:		  indfound = option_index;
        -: 5997:		  exact = 1;
        -: 5998:		  break;
        -: 5999:		}
        -: 6000:	      else if (pfound == NULL)
        -: 6001:		{
        -: 6002:		  /* First nonexact match found.  */
        -: 6003:		  pfound = p;
        -: 6004:		  indfound = option_index;
        -: 6005:		}
        -: 6006:	      else
        -: 6007:		/* Second or later nonexact match found.  */
        -: 6008:		ambig = 1;
        -: 6009:	    }
        -: 6010:	if (ambig && !exact)
        -: 6011:	  {
        -: 6012:	    if (opterr)
        -: 6013:	      fprintf (stderr, _("%s: option `-W %s' is ambiguous\n"),
        -: 6014:		       argv[0], argv[optind]);
        -: 6015:	    nextchar += strlen (nextchar);
        -: 6016:	    optind++;
        -: 6017:	    return '?';
        -: 6018:	  }
        -: 6019:	if (pfound != NULL)
        -: 6020:	  {
        -: 6021:	    option_index = indfound;
        -: 6022:	    if (*nameend)
        -: 6023:	      {
        -: 6024:		/* Don't test has_arg with >, because some C compilers don't
        -: 6025:		   allow it to be used on enums.  */
        -: 6026:		if (pfound->has_arg)
        -: 6027:		  optarg = nameend + 1;
        -: 6028:		else
        -: 6029:		  {
        -: 6030:		    if (opterr)
        -: 6031:		      fprintf (stderr, _("\
        -: 6032:%s: option `-W %s' doesn't allow an argument\n"),
        -: 6033:			       argv[0], pfound->name);
        -: 6034:
        -: 6035:		    nextchar += strlen (nextchar);
        -: 6036:		    return '?';
        -: 6037:		  }
        -: 6038:	      }
        -: 6039:	    else if (pfound->has_arg == 1)
        -: 6040:	      {
        -: 6041:		if (optind < argc)
        -: 6042:		  optarg = argv[optind++];
        -: 6043:		else
        -: 6044:		  {
        -: 6045:		    if (opterr)
        -: 6046:		      fprintf (stderr,
        -: 6047:			       _("%s: option `%s' requires an argument\n"),
        -: 6048:			       argv[0], argv[optind - 1]);
        -: 6049:		    nextchar += strlen (nextchar);
        -: 6050:		    return optstring[0] == ':' ? ':' : '?';
        -: 6051:		  }
        -: 6052:	      }
        -: 6053:	    nextchar += strlen (nextchar);
        -: 6054:	    if (longind != NULL)
        -: 6055:	      *longind = option_index;
        -: 6056:	    if (pfound->flag)
        -: 6057:	      {
        -: 6058:		*(pfound->flag) = pfound->val;
        -: 6059:		return 0;
        -: 6060:	      }
        -: 6061:	    return pfound->val;
        -: 6062:	  }
        -: 6063:	  nextchar = NULL;
        -: 6064:	  return 'W';	/* Let the application handle it.   */
        -: 6065:      }
        -: 6066:    if (temp[1] == ':')
        -: 6067:      {
        -: 6068:	if (temp[2] == ':')
        -: 6069:	  {
        -: 6070:	    /* This is an option that accepts an argument optionally.  */
        -: 6071:	    if (*nextchar != '\0')
        -: 6072:	      {
        -: 6073:		optarg = nextchar;
        -: 6074:		optind++;
        -: 6075:	      }
        -: 6076:	    else
        -: 6077:	      optarg = NULL;
        -: 6078:	    nextchar = NULL;
        -: 6079:	  }
        -: 6080:	else
        -: 6081:	  {
        -: 6082:	    /* This is an option that requires an argument.  */
        -: 6083:	    if (*nextchar != '\0')
        -: 6084:	      {
        -: 6085:		optarg = nextchar;
        -: 6086:		/* If we end this ARGV-element by taking the rest as an arg,
        -: 6087:		   we must advance to the next element now.  */
        -: 6088:		optind++;
        -: 6089:	      }
        -: 6090:	    else if (optind == argc)
        -: 6091:	      {
        -: 6092:		if (opterr)
        -: 6093:		  {
        -: 6094:		    /* 1003.2 specifies the format of this message.  */
        -: 6095:		    fprintf (stderr,
        -: 6096:			   _("%s: option requires an argument -- %c\n"),
        -: 6097:			   argv[0], c);
        -: 6098:		  }
        -: 6099:		optopt = c;
        -: 6100:		if (optstring[0] == ':')
        -: 6101:		  c = ':';
        -: 6102:		else
        -: 6103:		  c = '?';
        -: 6104:	      }
        -: 6105:	    else
        -: 6106:	      /* We already incremented `optind' once;
        -: 6107:		 increment it again when taking next ARGV-elt as argument.  */
        -: 6108:	      optarg = argv[optind++];
        -: 6109:	    nextchar = NULL;
        -: 6110:	  }
        -: 6111:      }
        -: 6112:    return c;
        -: 6113:  }
        -: 6114:}
        -: 6115:
        -: 6116:int
        -: 6117:getopt (argc, argv, optstring)
        -: 6118:     int argc;
        -: 6119:     char *const *argv;
        -: 6120:     const char *optstring;
        -: 6121:{
        -: 6122:  return _getopt_internal (argc, argv, optstring,
        -: 6123:			   (const struct option *) 0,
        -: 6124:			   (int *) 0,
        -: 6125:			   0);
        -: 6126:}
        -: 6127:
        -: 6128:#endif	/* Not ELIDE_CODE.  */
        -: 6129:
        -: 6130:#ifdef TEST
        -: 6131:
        -: 6132:/* Compile with -DTEST to make an executable for use in testing
        -: 6133:   the above definition of `getopt'.  */
        -: 6134:
        -: 6135:int
        -: 6136:main (argc, argv)
        -: 6137:     int argc;
        -: 6138:     char **argv;
        -: 6139:{
        -: 6140:  int c;
        -: 6141:  int digit_optind = 0;
        -: 6142:
        -: 6143:  while (1)
        -: 6144:    {
        -: 6145:      int this_option_optind = optind ? optind : 1;
        -: 6146:
        -: 6147:      c = getopt (argc, argv, "abc:d:0123456789");
        -: 6148:      if (c == -1)
        -: 6149:	break;
        -: 6150:
        -: 6151:      switch (c)
        -: 6152:	{
        -: 6153:	case '0':
        -: 6154:	case '1':
        -: 6155:	case '2':
        -: 6156:	case '3':
        -: 6157:	case '4':
        -: 6158:	case '5':
        -: 6159:	case '6':
        -: 6160:	case '7':
        -: 6161:	case '8':
        -: 6162:	case '9':
        -: 6163:	  if (digit_optind != 0 && digit_optind != this_option_optind)
        -: 6164:	    printf ("digits occur in two different argv-elements.\n");
        -: 6165:	  digit_optind = this_option_optind;
        -: 6166:	  printf ("option %c\n", c);
        -: 6167:	  break;
        -: 6168:
        -: 6169:	case 'a':
        -: 6170:	  printf ("option a\n");
        -: 6171:	  break;
        -: 6172:
        -: 6173:	case 'b':
        -: 6174:	  printf ("option b\n");
        -: 6175:	  break;
        -: 6176:
        -: 6177:	case 'c':
        -: 6178:	  printf ("option c with value `%s'\n", optarg);
        -: 6179:	  break;
        -: 6180:
        -: 6181:	case '?':
        -: 6182:	  break;
        -: 6183:
        -: 6184:	default:
        -: 6185:	  printf ("?? getopt returned character code 0%o ??\n", c);
        -: 6186:	}
        -: 6187:    }
        -: 6188:
        -: 6189:  if (optind < argc)
        -: 6190:    {
        -: 6191:      printf ("non-option ARGV-elements: ");
        -: 6192:      while (optind < argc)
        -: 6193:	printf ("%s ", argv[optind++]);
        -: 6194:      printf ("\n");
        -: 6195:    }
        -: 6196:
        -: 6197:  exit (0);
        -: 6198:}
        -: 6199:
        -: 6200:#endif /* TEST */
        -: 6201:/* getopt_long and getopt_long_only entry points for GNU getopt.
        -: 6202:   Copyright (C) 1987,88,89,90,91,92,93,94,96,97,98
        -: 6203:     Free Software Foundation, Inc.
        -: 6204:
        -: 6205:   NOTE: The canonical source of this file is maintained with the GNU C Library.
        -: 6206:   Bugs can be reported to bug-glibc@gnu.org.
        -: 6207:
        -: 6208:   This program is free software; you can redistribute it and/or modify it
        -: 6209:   under the terms of the GNU General Public License as published by the
        -: 6210:   Free Software Foundation; either version 2, or (at your option) any
        -: 6211:   later version.
        -: 6212:
        -: 6213:   This program is distributed in the hope that it will be useful,
        -: 6214:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 6215:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 6216:   GNU General Public License for more details.
        -: 6217:
        -: 6218:   You should have received a copy of the GNU General Public License
        -: 6219:   along with this program; if not, write to the Free Software
        -: 6220:   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
        -: 6221:   USA.  */
        -: 6222:
        -: 6223:#ifdef HAVE_CONFIG_H
        -: 6224:#include <config.h>
        -: 6225:#endif
        -: 6226:
        -: 6227:#include "getopt.h"
        -: 6228:
        -: 6229:#if !defined __STDC__ || !__STDC__
        -: 6230:/* This is a separate conditional since some stdc systems
        -: 6231:   reject `defined (const)'.  */
        -: 6232:#ifndef const
        -: 6233:#define const
        -: 6234:#endif
        -: 6235:#endif
        -: 6236:
        -: 6237:#include <stdio.h>
        -: 6238:
        -: 6239:/* Comment out all this code if we are using the GNU C Library, and are not
        -: 6240:   actually compiling the library itself.  This code is part of the GNU C
        -: 6241:   Library, but also included in many other GNU distributions.  Compiling
        -: 6242:   and linking in this code is a waste when using the GNU C library
        -: 6243:   (especially if it is a shared library).  Rather than having every GNU
        -: 6244:   program understand `configure --with-gnu-libc' and omit the object files,
        -: 6245:   it is simpler to just do this in the source for each such file.  */
        -: 6246:
        -: 6247:#define GETOPT_INTERFACE_VERSION 2
        -: 6248:#if !defined _LIBC && defined __GLIBC__ && __GLIBC__ >= 2
        -: 6249:#include <gnu-versions.h>
        -: 6250:#if _GNU_GETOPT_INTERFACE_VERSION == GETOPT_INTERFACE_VERSION
        -: 6251:#define ELIDE_CODE
        -: 6252:#endif
        -: 6253:#endif
        -: 6254:
        -: 6255:#ifndef ELIDE_CODE
        -: 6256:
        -: 6257:
        -: 6258:/* This needs to come after some library #include
        -: 6259:   to get __GNU_LIBRARY__ defined.  */
        -: 6260:#ifdef __GNU_LIBRARY__
        -: 6261:#include <stdlib.h>
        -: 6262:#endif
        -: 6263:
        -: 6264:#ifndef	NULL
        -: 6265:#define NULL 0
        -: 6266:#endif
        -: 6267:
        -: 6268:int
        -: 6269:getopt_long (argc, argv, options, long_options, opt_index)
        -: 6270:     int argc;
        -: 6271:     char *const *argv;
        -: 6272:     const char *options;
        -: 6273:     const struct option *long_options;
        -: 6274:     int *opt_index;
        -: 6275:{
        -: 6276:  return _getopt_internal (argc, argv, options, long_options, opt_index, 0);
        -: 6277:}
        -: 6278:
        -: 6279:/* Like getopt_long, but '-' as well as '--' can indicate a long option.
        -: 6280:   If an option that starts with '-' (not '--') doesn't match a long option,
        -: 6281:   but does match a short option, it is parsed as a short option
        -: 6282:   instead.  */
        -: 6283:
        -: 6284:int
        -: 6285:getopt_long_only (argc, argv, options, long_options, opt_index)
        -: 6286:     int argc;
        -: 6287:     char *const *argv;
        -: 6288:     const char *options;
        -: 6289:     const struct option *long_options;
        -: 6290:     int *opt_index;
        -: 6291:{
        -: 6292:  return _getopt_internal (argc, argv, options, long_options, opt_index, 1);
        -: 6293:}
        -: 6294:
        -: 6295:
        -: 6296:#endif	/* Not ELIDE_CODE.  */
        -: 6297:
        -: 6298:#ifdef TEST
        -: 6299:
        -: 6300:#include <stdio.h>
        -: 6301:
        -: 6302:int
        -: 6303:main (argc, argv)
        -: 6304:     int argc;
        -: 6305:     char **argv;
        -: 6306:{
        -: 6307:  int c;
        -: 6308:  int digit_optind = 0;
        -: 6309:
        -: 6310:  while (1)
        -: 6311:    {
        -: 6312:      int this_option_optind = optind ? optind : 1;
        -: 6313:      int option_index = 0;
        -: 6314:      static struct option long_options[] =
        -: 6315:      {
        -: 6316:	{"add", 1, 0, 0},
        -: 6317:	{"append", 0, 0, 0},
        -: 6318:	{"delete", 1, 0, 0},
        -: 6319:	{"verbose", 0, 0, 0},
        -: 6320:	{"create", 0, 0, 0},
        -: 6321:	{"file", 1, 0, 0},
        -: 6322:	{0, 0, 0, 0}
        -: 6323:      };
        -: 6324:
        -: 6325:      c = getopt_long (argc, argv, "abc:d:0123456789",
        -: 6326:		       long_options, &option_index);
        -: 6327:      if (c == -1)
        -: 6328:	break;
        -: 6329:
        -: 6330:      switch (c)
        -: 6331:	{
        -: 6332:	case 0:
        -: 6333:	  printf ("option %s", long_options[option_index].name);
        -: 6334:	  if (optarg)
        -: 6335:	    printf (" with arg %s", optarg);
        -: 6336:	  printf ("\n");
        -: 6337:	  break;
        -: 6338:
        -: 6339:	case '0':
        -: 6340:	case '1':
        -: 6341:	case '2':
        -: 6342:	case '3':
        -: 6343:	case '4':
        -: 6344:	case '5':
        -: 6345:	case '6':
        -: 6346:	case '7':
        -: 6347:	case '8':
        -: 6348:	case '9':
        -: 6349:	  if (digit_optind != 0 && digit_optind != this_option_optind)
        -: 6350:	    printf ("digits occur in two different argv-elements.\n");
        -: 6351:	  digit_optind = this_option_optind;
        -: 6352:	  printf ("option %c\n", c);
        -: 6353:	  break;
        -: 6354:
        -: 6355:	case 'a':
        -: 6356:	  printf ("option a\n");
        -: 6357:	  break;
        -: 6358:
        -: 6359:	case 'b':
        -: 6360:	  printf ("option b\n");
        -: 6361:	  break;
        -: 6362:
        -: 6363:	case 'c':
        -: 6364:	  printf ("option c with value `%s'\n", optarg);
        -: 6365:	  break;
        -: 6366:
        -: 6367:	case 'd':
        -: 6368:	  printf ("option d with value `%s'\n", optarg);
        -: 6369:	  break;
        -: 6370:
        -: 6371:	case '?':
        -: 6372:	  break;
        -: 6373:
        -: 6374:	default:
        -: 6375:	  printf ("?? getopt returned character code 0%o ??\n", c);
        -: 6376:	}
        -: 6377:    }
        -: 6378:
        -: 6379:  if (optind < argc)
        -: 6380:    {
        -: 6381:      printf ("non-option ARGV-elements: ");
        -: 6382:      while (optind < argc)
        -: 6383:	printf ("%s ", argv[optind++]);
        -: 6384:      printf ("\n");
        -: 6385:    }
        -: 6386:
        -: 6387:  exit (0);
        -: 6388:}
        -: 6389:
        -: 6390:#endif /* TEST */
        -: 6391:/* Extended regular expression matching and search library.
        -: 6392:   Copyright (C) 2002 Free Software Foundation, Inc.
        -: 6393:   This file is part of the GNU C Library.
        -: 6394:   Contributed by Isamu Hasegawa <isamu@yamato.ibm.com>.
        -: 6395:
        -: 6396:   The GNU C Library is free software; you can redistribute it and/or
        -: 6397:   modify it under the terms of the GNU Lesser General Public
        -: 6398:   License as published by the Free Software Foundation; either
        -: 6399:   version 2.1 of the License, or (at your option) any later version.
        -: 6400:
        -: 6401:   The GNU C Library is distributed in the hope that it will be useful,
        -: 6402:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 6403:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
        -: 6404:   Lesser General Public License for more details.
        -: 6405:
        -: 6406:   You should have received a copy of the GNU Lesser General Public
        -: 6407:   License along with the GNU C Library; if not, write to the Free
        -: 6408:   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
        -: 6409:   02111-1307 USA.  */
        -: 6410:
        -: 6411:#ifdef _LIBC
        -: 6412:/* We have to keep the namespace clean.  */
        -: 6413:#  define regfree(preg) __regfree (preg)
        -: 6414:#  define regexec(pr, st, nm, pm, ef) __regexec (pr, st, nm, pm, ef)
        -: 6415:#  define regcomp(preg, pattern, cflags) __regcomp (preg, pattern, cflags)
        -: 6416:#  define regerror(errcode, preg, errbuf, errbuf_size) \
        -: 6417:	__regerror(errcode, preg, errbuf, errbuf_size)
        -: 6418:#  define re_set_registers(bu, re, nu, st, en) \
        -: 6419:	__re_set_registers (bu, re, nu, st, en)
        -: 6420:#  define re_match_2(bufp, string1, size1, string2, size2, pos, regs, stop) \
        -: 6421:	__re_match_2 (bufp, string1, size1, string2, size2, pos, regs, stop)
        -: 6422:#  define re_match(bufp, string, size, pos, regs) \
        -: 6423:	__re_match (bufp, string, size, pos, regs)
        -: 6424:#  define re_search(bufp, string, size, startpos, range, regs) \
        -: 6425:	__re_search (bufp, string, size, startpos, range, regs)
        -: 6426:#  define re_compile_pattern(pattern, length, bufp) \
        -: 6427:	__re_compile_pattern (pattern, length, bufp)
        -: 6428:#  define re_set_syntax(syntax) __re_set_syntax (syntax)
        -: 6429:#  define re_search_2(bufp, st1, s1, st2, s2, startpos, range, regs, stop) \
        -: 6430:	__re_search_2 (bufp, st1, s1, st2, s2, startpos, range, regs, stop)
        -: 6431:#  define re_compile_fastmap(bufp) __re_compile_fastmap (bufp)
        -: 6432:#endif
        -: 6433:
        -: 6434:/* POSIX says that <sys/types.h> must be included (by the caller) before
        -: 6435:   <regex.h>.  */
        -: 6436:#include <sys/types.h>
        -: 6437:#include <regex.h>
        -: 6438:#include "regex_internal.h"
        -: 6439:
        -: 6440:#include "regex_internal.c"
        -: 6441:#include "regcomp.c"
        -: 6442:#include "regexec.c"
        -: 6443:
        -: 6444:/* Binary backward compatibility.  */
        -: 6445:#if _LIBC
        -: 6446:# include <shlib-compat.h>
        -: 6447:# if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_3)
        -: 6448:link_warning (re_max_failures, "the 're_max_failures' variable is obsolete and will go away.")
        -: 6449:int re_max_failures = 2000;
        -: 6450:# endif
        -: 6451:#endif
        -: 6452:/*  GNU SED, a batch stream editor.
        -: 6453:    Copyright (C) 1999, 2002, 2003 Free Software Foundation, Inc.
        -: 6454:
        -: 6455:    This program is free software; you can redistribute it and/or modify
        -: 6456:    it under the terms of the GNU General Public License as published by
        -: 6457:    the Free Software Foundation; either version 2, or (at your option)
        -: 6458:    any later version.
        -: 6459:
        -: 6460:    This program is distributed in the hope that it will be useful,
        -: 6461:    but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 6462:    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 6463:    GNU General Public License for more details.
        -: 6464:
        -: 6465:    You should have received a copy of the GNU General Public License
        -: 6466:    along with this program; if not, write to the Free Software
        -: 6467:    Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
        -: 6468:
        -: 6469:#include "config.h"
        -: 6470:
        -: 6471:#include <ctype.h>
        -: 6472:#ifdef HAVE_STDLIB_H
        -: 6473:# include <stdlib.h>
        -: 6474:#endif
        -: 6475:#ifndef NULL
        -: 6476:# include <stdio.h>
        -: 6477:#endif
        -: 6478:
        -: 6479:#include "basicdefs.h"
        -: 6480:#include "utils.h"
        -: 6481:#include "regex.h"
        -: 6482:#ifndef NULL
        -: 6483:# define NULL CAST(VOID *)0
        -: 6484:#endif
        -: 6485:
        -: 6486:extern flagT use_extended_syntax_p;
        -: 6487:
        -: 6488:/*
        -: 6489:  Changed variable name: errors[] to regex_errors[]
        -: 6490:  to allow *.c file merging for SIR -- July, 2006
        -: 6491:  by Kyle R. Murphy
        -: 6492:*/
        -: 6493:static const char regex_errors[] =
        -: 6494:  "No previous regular expression\0"
        -: 6495:  "Cannot specify modifiers on empty regexp";
        -: 6496:
        -: 6497:#define NO_REGEX (regex_errors)
        -: 6498:#define BAD_MODIF (NO_REGEX + sizeof(N_("No previous regular expression")))
        -: 6499:
        -: 6500:/*
        -: 6501:  Added pre-proc. conditional to allow *.c file 
        -: 6502:  merging for SIR -- July, 2006 by Kyle R. Murphy
        -: 6503:*/
        -: 6504:#ifndef END_ERRORS
        -: 6505:#define END_ERRORS (BAD_MODIF + sizeof(N_("Cannot specify modifiers on empty regexp")))
        -: 6506:#endif
        -: 6507:
        -: 6508:
        -: 6509:regex_t *
function compile_regex called 628 returned 100% blocks executed 78%
      628: 6510:compile_regex(b, flags, needed_sub)
        -: 6511:  struct buffer *b;
        -: 6512:  int flags;
        -: 6513:  int needed_sub;
        -: 6514:{
        -: 6515:  regex_t *new_regex;
        -: 6516:
      628: 6517:  char *last_re = NULL;
        -: 6518:  size_t last_re_len;
        -: 6519:
        -: 6520:  /* My reading of IEEE Std 1003.2-1992 is that // means the empty RE.
        -: 6521:     But historical and common practice is that // "matches the last RE";
        -: 6522:     thus this use of POSIXLY_CORRECT. */
      628: 6523:  if (size_buffer(b) == 0 && !POSIXLY_CORRECT)
call    0 returned 628
branch  1 taken 18 (fallthrough)
branch  2 taken 610
branch  3 taken 18 (fallthrough)
branch  4 taken 0
        -: 6524:    {
       18: 6525:      if (flags > 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 18
    #####: 6526:	bad_prog(_(BAD_MODIF));
call    0 never executed
       18: 6527:      return NULL;
        -: 6528:    }
        -: 6529:
      610: 6530:  last_re_len = size_buffer(b);
call    0 returned 610
      610: 6531:  last_re = ck_memdup(get_buffer(b), last_re_len);
call    0 returned 610
call    1 returned 610
        -: 6532:
      610: 6533:  new_regex = MALLOC(1, regex_t);
call    0 returned 610
        -: 6534:
        -: 6535:#ifdef REG_PERL
        -: 6536:  {
        -: 6537:    int errcode;
        -: 6538:    errcode = regncomp(new_regex, last_re, last_re_len,
        -: 6539:		       (needed_sub ? 0 : REG_NOSUB)
        -: 6540:		       | flags
        -: 6541:		       | extended_regexp_flags);
        -: 6542:
        -: 6543:    if (errcode)
        -: 6544:      {
        -: 6545:        char errorbuf[200];
        -: 6546:        regerror(errcode, NULL, errorbuf, 200);
        -: 6547:        bad_prog(gettext(errorbuf));
        -: 6548:      }
        -: 6549:  }
        -: 6550:#else
        -: 6551:  {
        -: 6552:    const char *error;
      610: 6553:    int syntax = ((extended_regexp_flags & REG_EXTENDED)
branch  0 taken 2 (fallthrough)
branch  1 taken 608
        -: 6554:		   ? RE_SYNTAX_POSIX_EXTENDED
        -: 6555:                   : RE_SYNTAX_POSIX_BASIC)
        -: 6556:		   & ~RE_UNMATCHED_RIGHT_PAREN_ORD;
        -: 6557:
      610: 6558:    syntax |= RE_NO_POSIX_BACKTRACKING;
        -: 6559:#ifdef RE_ICASE
      610: 6560:    syntax |= (flags & REG_ICASE) ? RE_ICASE : 0;
        -: 6561:#endif
        -: 6562:
        -: 6563:    /* If REG_NEWLINE is set, newlines are treated differently.  */
      610: 6564:    if (flags & REG_NEWLINE)
branch  0 taken 0 (fallthrough)
branch  1 taken 610
        -: 6565:      { /* REG_NEWLINE implies neither . nor [^...] match newline.  */
    #####: 6566:        syntax &= ~RE_DOT_NEWLINE;
    #####: 6567:        syntax |= RE_HAT_LISTS_NOT_NEWLINE;
        -: 6568:      }
        -: 6569:
        -: 6570:    /* Only PCRE processes \t & co. */
      610: 6571:    last_re_len = normalize_text(last_re, last_re_len);
call    0 returned 610
      610: 6572:    re_set_syntax (syntax);
call    0 returned 610
      610: 6573:    error = re_compile_pattern (last_re, last_re_len, new_regex);
call    0 returned 610
      610: 6574:    new_regex->newline_anchor = (flags & REG_NEWLINE) != 0;
        -: 6575:
      610: 6576:    new_regex->translate = NULL;
        -: 6577:#ifndef RE_ICASE
        -: 6578:    if (flags & REG_ICASE)
        -: 6579:      {
        -: 6580:        static char translate[1 << (sizeof(char) * 8)];
        -: 6581:	int i;
        -: 6582:	for (i = 0; i < sizeof(translate) / sizeof(char); i++)
        -: 6583:	  translate[i] = tolower (i);
        -: 6584:
        -: 6585:        new_regex->translate = translate;
        -: 6586:      }
        -: 6587:#endif
        -: 6588:
      610: 6589:    if (error)
branch  0 taken 0 (fallthrough)
branch  1 taken 610
    #####: 6590:      bad_prog(error);
call    0 never executed
        -: 6591:  }
        -: 6592:#endif
        -: 6593:
      610: 6594:  FREE(last_re);
call    0 returned 610
        -: 6595:
        -: 6596:  /* Just to be sure, I mark this as not POSIXLY_CORRECT behavior */
     610*: 6597:  if (new_regex->re_nsub < needed_sub && !POSIXLY_CORRECT)
branch  0 taken 0 (fallthrough)
branch  1 taken 610
branch  2 never executed
branch  3 never executed
        -: 6598:    {
        -: 6599:      char buf[200];
    #####: 6600:      sprintf(buf, _("Invalid reference \\%d on `s' command's RHS"),
        -: 6601:	      needed_sub);
    #####: 6602:      bad_prog(buf);
call    0 never executed
        -: 6603:    }
        -: 6604:
      610: 6605:  return new_regex;
        -: 6606:}
        -: 6607:
        -: 6608:#ifdef REG_PERL
        -: 6609:static void
        -: 6610:copy_regs (regs, pmatch, nregs)
        -: 6611:     struct re_registers *regs;
        -: 6612:     regmatch_t *pmatch;
        -: 6613:     int nregs;
        -: 6614:{
        -: 6615:  int i;
        -: 6616:  int need_regs = nregs + 1;
        -: 6617:  /* We need one extra element beyond `num_regs' for the `-1' marker GNU code
        -: 6618:     uses.  */
        -: 6619:
        -: 6620:  /* Have the register data arrays been allocated?  */
        -: 6621:  if (!regs->start)
        -: 6622:    { /* No.  So allocate them with malloc.  */
        -: 6623:      regs->start = MALLOC (need_regs, regoff_t);
        -: 6624:      regs->end = MALLOC (need_regs, regoff_t);
        -: 6625:      regs->num_regs = need_regs;
        -: 6626:    }
        -: 6627:  else if (need_regs > regs->num_regs)
        -: 6628:    { /* Yes.  We also need more elements than were already
        -: 6629:         allocated, so reallocate them.  */
        -: 6630:      regs->start = REALLOC (regs->start, need_regs, regoff_t);
        -: 6631:      regs->end = REALLOC (regs->end, need_regs, regoff_t);
        -: 6632:      regs->num_regs = need_regs;
        -: 6633:    }
        -: 6634:
        -: 6635:  /* Copy the regs.  */
        -: 6636:  for (i = 0; i < nregs; ++i)
        -: 6637:    {
        -: 6638:      regs->start[i] = pmatch[i].rm_so;
        -: 6639:      regs->end[i] = pmatch[i].rm_eo;
        -: 6640:    }
        -: 6641:  for ( ; i < regs->num_regs; ++i)
        -: 6642:    regs->start[i] = regs->end[i] = -1;
        -: 6643:}
        -: 6644:#endif
        -: 6645:
        -: 6646:int
function match_regex called 49072 returned 100% blocks executed 90%
    49072: 6647:match_regex(regex, buf, buflen, buf_start_offset, regarray, regsize)
        -: 6648:  regex_t *regex;
        -: 6649:  char *buf;
        -: 6650:  size_t buflen;
        -: 6651:  size_t buf_start_offset;
        -: 6652:  struct re_registers *regarray;
        -: 6653:  int regsize;
        -: 6654:{
        -: 6655:  int ret;
        -: 6656:  static regex_t *regex_last;
        -: 6657:#ifdef REG_PERL
        -: 6658:  regmatch_t *regmatch;
        -: 6659:  if (regsize)
        -: 6660:    regmatch = (regmatch_t *) alloca (sizeof (regmatch_t) * regsize);
        -: 6661:  else
        -: 6662:    regmatch = NULL;
        -: 6663:#endif
        -: 6664:
        -: 6665:  /* printf ("Matching from %d/%d\n", buf_start_offset, buflen); */
        -: 6666:
        -: 6667:  /* Keep track of the last regexp matched. */
    49072: 6668:  if (!regex)
branch  0 taken 178 (fallthrough)
branch  1 taken 48894
        -: 6669:    {
      178: 6670:      regex = regex_last;
      178: 6671:      if (!regex_last)
branch  0 taken 0 (fallthrough)
branch  1 taken 178
    #####: 6672:	bad_prog(_(NO_REGEX));
call    0 never executed
        -: 6673:    }
        -: 6674:  else
    48894: 6675:    regex_last = regex;
        -: 6676:
        -: 6677:#ifdef REG_PERL
        -: 6678:  ret = regexec2(regex, 
        -: 6679:		 buf, CAST(int)buflen, CAST(int)buf_start_offset,
        -: 6680:		 regsize, regmatch, 0);
        -: 6681:
        -: 6682:  if (regsize)
        -: 6683:    copy_regs (regarray, regmatch, regsize);
        -: 6684:
        -: 6685:  return (ret == 0);
        -: 6686:#else
    49072: 6687:  ret = re_search(regex, buf, buflen, buf_start_offset,
branch  0 taken 17176 (fallthrough)
branch  1 taken 31896
    49072: 6688:		  buflen - buf_start_offset,
call    0 returned 49072
        -: 6689:		  regsize ? regarray : NULL);
        -: 6690:
    49072: 6691:  return (ret > -1);
        -: 6692:#endif
        -: 6693:}
        -: 6694:
        -: 6695:
        -: 6696:#ifdef DEBUG_LEAKS
        -: 6697:void
        -: 6698:release_regex(regex)
        -: 6699:  regex_t *regex;
        -: 6700:{
        -: 6701:  regfree(regex);
        -: 6702:  FREE(regex);
        -: 6703:}
        -: 6704:#endif /*DEBUG_LEAKS*/
