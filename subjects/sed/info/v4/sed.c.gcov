        -:    0:Source:sed.c
        -:    0:Graph:sed.gcno
        -:    0:Data:sed.gcda
        -:    0:Runs:370
        -:    1:#define COPYRIGHT_NOTICE "Copyright (C) 1998 Free Software Foundation, Inc."
        -:    2:#define BUG_ADDRESS "bug-gnu-utils@gnu.org"
        -:    3:
        -:    4:/*  GNU SED, a batch stream editor.
        -:    5:    Copyright (C) 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1998 \
        -:    6:    Free Software Foundation, Inc."
        -:    7:
        -:    8:    This program is free software; you can redistribute it and/or modify
        -:    9:    it under the terms of the GNU General Public License as published by
        -:   10:    the Free Software Foundation; either version 2, or (at your option)
        -:   11:    any later version.
        -:   12:
        -:   13:    This program is distributed in the hope that it will be useful,
        -:   14:    but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   15:    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   16:    GNU General Public License for more details.
        -:   17:
        -:   18:    You should have received a copy of the GNU General Public License
        -:   19:    along with this program; if not, write to the Free Software
        -:   20:    Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
        -:   21:
        -:   22:
        -:   23:#include "config.h"
        -:   24:#include <stdio.h>
        -:   25:
        -:   26:#undef stderr
        -:   27:#define stderr stdout
        -:   28:
        -:   29:#ifndef HAVE_STRING_H
        -:   30:# include <strings.h>
        -:   31:#else
        -:   32:# include <string.h>
        -:   33:#endif
        -:   34:
        -:   35:#ifdef HAVE_STDLIB_H
        -:   36:# include <stdlib.h>
        -:   37:#endif
        -:   38:
        -:   39:#ifdef HAVE_MMAP
        -:   40:# ifdef HAVE_UNISTD_H
        -:   41:#  include <unistd.h>
        -:   42:# endif
        -:   43:# include <sys/types.h>
        -:   44:# include <sys/mman.h>
        -:   45:# ifndef MAP_FAILED
        -:   46:#  define MAP_FAILED	((char *)-1)	/* what a stupid concept... */
        -:   47:# endif
        -:   48:# include <sys/stat.h>
        -:   49:# ifndef S_ISREG
        -:   50:#  define S_ISREG(m)	(((m)&S_IFMT) == S_IFMT)
        -:   51:# endif
        -:   52:#endif /* HAVE_MMAP */
        -:   53:
        -:   54:#ifdef HAVE_SYS_TYPES_H
        -:   55:# include <sys/types.h>
        -:   56:#endif
        -:   57:#include "regex-sed.h"
        -:   58:#include "getopt.h"
        -:   59:#include "basicdefs.h"
        -:   60:#include "utils.h"
        -:   61:#include "sed.h"
        -:   62:
        -:   63:/* 
        -:   64:   Included for SIR fault insertion
        -:   65:   July 2006 by Kyle R. Murphy
        -:   66:*/
        -:   67:#include "FaultSeeds.h"
        -:   68:
        -:   69:#ifndef HAVE_STDLIB_H
        -:   70: extern char *getenv P_((const char *));
        -:   71:#endif
        -:   72:
        -:   73:#ifdef STUB_FROM_RX_LIBRARY_USAGE
        -:   74:extern void print_rexp P_((void));
        -:   75:extern int rx_basic_unfaniverse_delay;
        -:   76:#endif /*STUB_FROM_RX_LIBRARY_USAGE*/
        -:   77:
        -:   78:static void usage P_((int));
        -:   79:
        -:   80:flagT use_extended_syntax_p = 0;
        -:   81:
        -:   82:flagT rx_testing = 0;
        -:   83:
        -:   84:/* If set, don't write out the line unless explicitly told to */
        -:   85:flagT no_default_output = 0;
        -:   86:
        -:   87:/* Do we need to be pedantically POSIX compliant? */
        -:   88:flagT POSIXLY_CORRECT;
        -:   89:
        -:   90:static void
function usage called 6 returned 0% blocks executed 100%
        6:   91:usage(status)
        -:   92:  int status;
        -:   93:{
        6:   94:  FILE *out = status ? stderr : stdout;
        -:   95:
        6:   96:  fprintf(out, "\
call    0 returned 6
        -:   97:Usage: %s [OPTION]... {script-only-if-no-other-script} [input-file]...\n\
        -:   98:\n\
        -:   99:  -n, --quiet, --silent\n\
        -:  100:                 suppress automatic printing of pattern space\n\
        -:  101:  -e script, --expression=script\n\
        -:  102:                 add the script to the commands to be executed\n\
        -:  103:  -f script-file, --file=script-file\n\
        -:  104:                 add the contents of script-file to the commands to be executed\n\
        -:  105:      --help     display this help and exit\n\
        -:  106:  -V, --version  output version information and exit\n\
        -:  107:\n\
        -:  108:If no -e, --expression, -f, or --file option is given, then the first\n\
        -:  109:non-option argument is taken as the sed script to interpret.  All\n\
        -:  110:remaining arguments are names of input files; if no input files are\n\
        -:  111:specified, then the standard input is read.\n\
        -:  112:\n", myname);
        6:  113:  fprintf(out, "E-mail bug reports to: %s .\n\
call    0 returned 6
        -:  114:Be sure to include the word ``%s'' somewhere in the ``Subject:'' field.\n",
        -:  115:	  BUG_ADDRESS, PACKAGE);
        6:  116:  exit(status);
        -:  117:}
        -:  118:
        -:  119:int
function main called 370 returned 95% blocks executed 93%
      370:  120:main(argc, argv)
        -:  121:  int argc;
        -:  122:  char **argv;
        -:  123:{
        -:  124:  static struct option longopts[] = {
        -:  125:    {"rxtest", 0, NULL, 'r'},
        -:  126:    {"expression", 1, NULL, 'e'},
        -:  127:    {"file", 1, NULL, 'f'},
        -:  128:    {"quiet", 0, NULL, 'n'},
        -:  129:    {"silent", 0, NULL, 'n'},
        -:  130:    {"version", 0, NULL, 'V'},
        -:  131:    {"help", 0, NULL, 'h'},
        -:  132:    {NULL, 0, NULL, 0}
        -:  133:  };
        -:  134:
        -:  135:  /* The complete compiled SED program that we are going to run: */
      370:  136:  struct vector *the_program = NULL;
        -:  137:  int opt;
        -:  138:  flagT bad_input;	/* If this variable is non-zero at exit, one or
        -:  139:			   more of the input files couldn't be opened. */
        -:  140:
      370:  141:  POSIXLY_CORRECT = (getenv("POSIXLY_CORRECT") != NULL);
call    0 returned 370
        -:  142:#ifdef STUB_FROM_RX_LIBRARY_USAGE
        -:  143:  if (!rx_default_cache)
        -:  144:    print_rexp();
        -:  145:  /* Allow roughly a megabyte of cache space. */
        -:  146:  rx_default_cache->bytes_allowed = 1<<20;
        -:  147:  rx_basic_unfaniverse_delay = 512 * 4;
        -:  148:#endif /*STUB_FROM_RX_LIBRARY_USAGE*/
        -:  149: /* Commented out by Amit Goel on 30th August 2001 to remove Nondeterminism */
        -:  150: /* myname = *argv; */
        -:  151: /* Added By Amit Goel on 30th August 2001 */
      370:  152: myname = "Executable";
      737:  153:  while ((opt = getopt_long(argc, argv, "hnrVe:f:", longopts, NULL)) != EOF)
call    0 returned 737
branch  1 taken 377
branch  2 taken 360 (fallthrough)
        -:  154:    {
      377:  155:      switch (opt)
branch  0 taken 7
branch  1 taken 21
branch  2 taken 339
branch  3 taken 2
branch  4 taken 2
branch  5 taken 0
branch  6 taken 6
        -:  156:	{
        7:  157:	case 'n':
        7:  158:	  no_default_output = 1;
        7:  159:	  break;
       21:  160:	case 'e':
       21:  161:	  the_program = compile_string(the_program, optarg);
call    0 returned 21
       21:  162:	  break;
      339:  163:	case 'f':
      339:  164:	  the_program = compile_file(the_program, optarg);
call    0 returned 337
      337:  165:	  break;
        -:  166:
        2:  167:	case 'r':
        2:  168:	  use_extended_syntax_p = 1;
        2:  169:	  rx_testing = 1;
        2:  170:	  break;
        2:  171:	case 'V':
        2:  172:	  fprintf(stdout, "GNU %s version %s\n\n", PACKAGE, VERSION);
call    0 returned 2
        2:  173:	  fprintf(stdout, "%s\n\
call    0 returned 2
        -:  174:This is free software; see the source for copying conditions.  There is NO\n\
        -:  175:warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE,\n\
        -:  176:to the extent permitted by law.\n\
        -:  177:", COPYRIGHT_NOTICE);
        2:  178:	  exit(0);
call    0 returned 0
    #####:  179:	case 'h':
    #####:  180:	  usage(0);
call    0 never executed
        6:  181:	default:
        6:  182:	  usage(4);
call    0 returned 0
        -:  183:	}
        -:  184:    }
        -:  185:
      360:  186:  if (!the_program)
branch  0 taken 5 (fallthrough)
branch  1 taken 355
        -:  187:    {
        5:  188:      if (optind < argc)
branch  0 taken 5 (fallthrough)
branch  1 taken 0
        5:  189:	the_program = compile_string(the_program, argv[optind++]);
call    0 returned 0
        -:  190:      else
    #####:  191:	usage(4);
call    0 never executed
        -:  192:    }
      355:  193:  check_final_program(the_program);
call    0 returned 354
        -:  194:
      354:  195:  bad_input = process_files(the_program, argv+optind);
call    0 returned 354
        -:  196:
      354:  197:  close_all_files();
call    0 returned 354
      354:  198:  ck_fclose(stdout);
call    0 returned 354
      354:  199:  if (bad_input)
branch  0 taken 1 (fallthrough)
branch  1 taken 353
        1:  200:    exit(2);
call    0 returned 0
      353:  201:  return 0;
        -:  202:}
        -:  203:
        -:  204:
        -:  205:/* Attempt to mmap() a file.  On failure, just return a zero,
        -:  206:   otherwise set *base and *len and return non-zero.  */
        -:  207:flagT
function map_file called 691 returned 100% blocks executed 91%
      691:  208:map_file(fp, base, len)
        -:  209:  FILE *fp;
        -:  210:  VOID **base;
        -:  211:  size_t *len;
        -:  212:{
        -:  213:#ifdef HAVE_MMAP
        -:  214:  struct stat s;
        -:  215:  VOID *nbase;
        -:  216:
      691:  217:  if (fstat(fileno(fp), &s) == 0
call    0 returned 691
call    1 returned 691
branch  2 taken 691 (fallthrough)
branch  3 taken 0
      691:  218:      && S_ISREG(s.st_mode)
branch  0 taken 691 (fallthrough)
branch  1 taken 0
        -:  219:      && s.st_size == CAST(size_t)s.st_size)
        -:  220:    {
        -:  221:      /* "As if" the whole file was read into memory at this moment... */
      691:  222:      nbase = VCAST(VOID *)mmap(NULL, CAST(size_t)s.st_size, PROT_READ,
call    0 returned 691
call    1 returned 691
        -:  223:				MAP_PRIVATE, fileno(fp), CAST(off_t)0);
      691:  224:      if (nbase != MAP_FAILED)
branch  0 taken 691 (fallthrough)
branch  1 taken 0
        -:  225:	{
      691:  226:	  *base = nbase;
      691:  227:	  *len =  s.st_size;
      691:  228:	  return 1;
        -:  229:	}
        -:  230:    }
        -:  231:#endif /* HAVE_MMAP */
        -:  232:
    #####:  233:  return 0;
        -:  234:}
        -:  235:
        -:  236:/* Attempt to munmap() a memory region. */
        -:  237:void
function unmap_file called 691 returned 100% blocks executed 100%
      691:  238:unmap_file(base, len)
        -:  239:  VOID *base;
        -:  240:  size_t len;
        -:  241:{
        -:  242:#ifdef HAVE_MMAP
      691:  243:  if (base)
branch  0 taken 691 (fallthrough)
branch  1 taken 0
      691:  244:    munmap(VCAST(caddr_t)base, len);
call    0 returned 691
        -:  245:#endif
      691:  246:}
        -:  247:/*  GNU SED, a batch stream editor.
        -:  248:    Copyright (C) 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1998
        -:  249:    Free Software Foundation, Inc.
        -:  250:
        -:  251:    This program is free software; you can redistribute it and/or modify
        -:  252:    it under the terms of the GNU General Public License as published by
        -:  253:    the Free Software Foundation; either version 2, or (at your option)
        -:  254:    any later version.
        -:  255:
        -:  256:    This program is distributed in the hope that it will be useful,
        -:  257:    but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:  258:    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:  259:    GNU General Public License for more details.
        -:  260:
        -:  261:    You should have received a copy of the GNU General Public License
        -:  262:    along with this program; if not, write to the Free Software
        -:  263:    Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
        -:  264:
        -:  265:/* compile.c: translate sed source into internal form */
        -:  266:
        -:  267:#include "config.h"
        -:  268:#include <stdio.h>
        -:  269:
        -:  270:#ifndef __STRICT_ANSI__
        -:  271:# define _GNU_SOURCE
        -:  272:#endif
        -:  273:#include <ctype.h>
        -:  274:
        -:  275:#ifndef HAVE_STRING_H
        -:  276:# include <strings.h>
        -:  277:# ifdef HAVE_MEMORY_H
        -:  278:#  include <memory.h>
        -:  279:# endif
        -:  280:#else
        -:  281:# include <string.h>
        -:  282:#endif /* HAVE_STRING_H */
        -:  283:
        -:  284:#ifdef HAVE_STDLIB_H
        -:  285:# include <stdlib.h>
        -:  286:#endif
        -:  287:
        -:  288:#ifdef HAVE_SYS_TYPES_H
        -:  289:# include <sys/types.h>
        -:  290:#endif
        -:  291:#include "regex-sed.h"
        -:  292:#include "basicdefs.h"
        -:  293:#include "utils.h"
        -:  294:#include "sed.h"
        -:  295:
        -:  296:
        -:  297:extern flagT rx_testing;
        -:  298:extern flagT no_default_output;
        -:  299:extern flagT use_extended_syntax_p;
        -:  300:
        -:  301:
        -:  302:#define YMAP_LENGTH		256 /*XXX shouldn't this be (UCHAR_MAX+1)?*/
        -:  303:#define VECTOR_ALLOC_INCREMENT	40
        -:  304:
        -:  305:struct prog_info {
        -:  306:  /* When we're reading a script command from a string, 'prog.base'
        -:  307:     points to the first character in the string, 'prog.cur' points
        -:  308:     to the current character in the string, and 'prog.end' points
        -:  309:     to the end of the string.  This allows us to compile script
        -:  310:     strings that contain nulls, which might happen if we're mmap'ing
        -:  311:     a file. */
        -:  312:  VOID *base;
        -:  313:  const unsigned char *cur;
        -:  314:  const unsigned char *end;
        -:  315:
        -:  316:  /* This is the current script file.  If it is NULL, we are reading
        -:  317:     from a string stored at 'prog.cur' instead.  If both 'prog.file'
        -:  318:     and 'prog.cur' are NULL, we're in trouble! */
        -:  319:  FILE *file;
        -:  320:};
        -:  321:
        -:  322:/* Information used to give out useful and informative error messages. */
        -:  323:struct error_info {
        -:  324:  /* This is the name of the current script file. */
        -:  325:  const char *name;
        -:  326:
        -:  327:  /* This is the number of the current script line that we're compiling. */
        -:  328:  countT line;
        -:  329:
        -:  330:  /* This is the index of the "-e" expressions on the command line. */
        -:  331:  countT string_expr_count;
        -:  332:};
        -:  333:
        -:  334:
        -:  335:static struct vector *compile_program P_((struct vector *));
        -:  336:static struct vector *new_vector
        -:  337:	P_((struct error_info *errinfo, struct vector *old_vector));
        -:  338:static void read_text P_((struct text_buf *buf, int leadin_ch));
        -:  339:static struct sed_cmd *next_cmd_entry P_((struct vector **vectorp));
        -:  340:static int add_then_next P_((struct buffer *b, int ch));
        -:  341:static int snarf_char_class P_((struct buffer *b));
        -:  342:static struct buffer *match_slash P_((int slash, flagT regex, flagT keep_back));
        -:  343:static regex_t *compile_regex P_((struct buffer *b, flagT icase, flagT nosub));
        -:  344:static flagT compile_address P_((struct addr *addr, int ch));
        -:  345:static void compile_filename P_((flagT readit, const char **name, FILE **fp));
        -:  346:static struct sed_label *setup_jump
        -:  347:	P_((struct sed_label *list, struct sed_cmd *cmd, struct vector *vec));
        -:  348:static flagT mark_subst_opts P_((struct subst *cmd));
        -:  349:static int inchar P_((void));
        -:  350:static int in_nonblank P_((void));
        -:  351:static countT in_integer P_((int ch));
        -:  352:static void savchar P_((int ch));
        -:  353:static void bad_prog P_((const char *why));
        -:  354:
        -:  355:
        -:  356:/* Where we are in the processing of the input. */
        -:  357:static struct prog_info prog;
        -:  358:static struct error_info cur_input;
        -:  359:
        -:  360:/* Information about labels and jumps-to-labels.  This is used to do
        -:  361:   the required backpatching after we have compiled all the scripts. */
        -:  362:static struct sed_label *jumps = NULL;
        -:  363:static struct sed_label *labels = NULL;
        -:  364:
        -:  365:/* We wish to detect #n magic only in the first input argument;
        -:  366:   this flag tracks when we have consumed the first file of input. */
        -:  367:static flagT first_script = 1;
        -:  368:
        -:  369:/* Allow for scripts like "sed -e 'i\' -e foo": */
        -:  370:static struct buffer *pending_text = NULL;
        -:  371:static struct text_buf *old_text_buf = NULL;
        -:  372:
        -:  373:/* Various error messages we may want to print */
        -:  374:static const char ONE_ADDR[] = "Command only uses one address";
        -:  375:static const char NO_ADDR[] = "Command doesn't take any addresses";
        -:  376:static const char LINE_JUNK[] = "Extra characters after command";
        -:  377:static const char BAD_EOF[] = "Unexpected End-of-file";
        -:  378:static const char BAD_REGEX_FMT[] = "bad regexp: %s\n";
        -:  379:static const char EXCESS_OPEN_BRACKET[] = "Unmatched `{'";
        -:  380:static const char EXCESS_CLOSE_BRACKET[] = "Unexpected `}'";
        -:  381:static const char NO_REGEX[] = "No previous regular expression";
        -:  382:static const char NO_COMMAND[] = "Missing command";
        -:  383:static const char UNTERM_S_CMD[] = "Unterminated `s' command";
        -:  384:static const char UNTERM_Y_CMD[] = "Unterminated `y' command";
        -:  385:
        -:  386:
        -:  387:/* This structure tracks files opened by the 'r', 'w', and 's///w' commands
        -:  388:   so that they may all be closed cleanly at normal program termination.  */
        -:  389:struct fp_list {
        -:  390:    char *name;
        -:  391:    FILE *fp;
        -:  392:    flagT readit_p;
        -:  393:    struct fp_list *link;
        -:  394:  };
        -:  395:static struct fp_list *file_ptrs = NULL;
        -:  396:
        -:  397:void
function close_all_files called 354 returned 100% blocks executed 100%
      354:  398:close_all_files()
        -:  399:{
        -:  400:  struct fp_list *p, *q;
        -:  401:
      584:  402:  for (p=file_ptrs; p; p=q)
branch  0 taken 230
branch  1 taken 354 (fallthrough)
        -:  403:    {
      230:  404:      if (p->fp)
branch  0 taken 196 (fallthrough)
branch  1 taken 34
      196:  405:	ck_fclose(p->fp);
call    0 returned 196
      230:  406:      FREE(p->name);
call    0 returned 230
      230:  407:      q = p->link;
      230:  408:      FREE(p);
call    0 returned 230
        -:  409:    }
      354:  410:  file_ptrs = NULL;
      354:  411:}
        -:  412:
        -:  413:/* 'str' is a string (from the command line) that contains a sed command.
        -:  414:   Compile the command, and add it to the end of 'cur_program'. */
        -:  415:struct vector *
function compile_string called 26 returned 81% blocks executed 100%
       26:  416:compile_string(cur_program, str)
        -:  417:  struct vector *cur_program;
        -:  418:  char *str;
        -:  419:{
        -:  420:  static countT string_expr_count = 0;
        -:  421:  struct vector *ret;
        -:  422:
       26:  423:  prog.file = NULL;
       26:  424:  prog.base = VCAST(VOID *)str;
       26:  425:  prog.cur = CAST(unsigned char *)str;
       26:  426:  prog.end = prog.cur + strlen(str);
        -:  427:
       26:  428:  cur_input.line = 0;
       26:  429:  cur_input.name = NULL;
       26:  430:  cur_input.string_expr_count = ++string_expr_count;
        -:  431:
       26:  432:  ret = compile_program(cur_program);
call    0 returned 21
       21:  433:  prog.base = NULL;
       21:  434:  prog.cur = NULL;
       21:  435:  prog.end = NULL;
        -:  436:
       21:  437:  first_script = 0;
       21:  438:  return ret;
        -:  439:}
        -:  440:
        -:  441:/* 'cmdfile' is the name of a file containing sed commands.
        -:  442:   Read them in and add them to the end of 'cur_program'.
        -:  443: */
        -:  444:struct vector *
function compile_file called 339 returned 99% blocks executed 93%
      339:  445:compile_file(cur_program, cmdfile)
        -:  446:  struct vector *cur_program;
        -:  447:  const char *cmdfile;
        -:  448:{
        -:  449:  size_t len;
        -:  450:  struct vector *ret;
        -:  451:
      339:  452:  prog.base = NULL;
      339:  453:  prog.cur = NULL;
      339:  454:  prog.end = NULL;
      339:  455:  prog.file = stdin;
     339*:  456:  if (cmdfile[0] != '-' || cmdfile[1] != '\0')
branch  0 taken 0 (fallthrough)
branch  1 taken 339
branch  2 never executed
branch  3 never executed
      339:  457:    prog.file = ck_fopen(cmdfile, "r");
call    0 returned 337
      337:  458:  if (map_file(prog.file, &prog.base, &len))
call    0 returned 337
branch  1 taken 337 (fallthrough)
branch  2 taken 0
        -:  459:    {
      337:  460:      prog.cur = VCAST(const unsigned char *)prog.base;
      337:  461:      prog.end = prog.cur + len;
        -:  462:    }
        -:  463:
      337:  464:  cur_input.line = 1;
      337:  465:  cur_input.name = cmdfile;
      337:  466:  cur_input.string_expr_count = 0;
        -:  467:
      337:  468:  ret = compile_program(cur_program);
call    0 returned 337
      337:  469:  if (prog.base)
branch  0 taken 337 (fallthrough)
branch  1 taken 0
        -:  470:    {
      337:  471:      unmap_file(prog.base, len);
call    0 returned 337
      337:  472:      prog.base = NULL;
      337:  473:      prog.cur = NULL;
      337:  474:      prog.end = NULL;
        -:  475:    }
      337:  476:  if (prog.file != stdin)
branch  0 taken 337 (fallthrough)
branch  1 taken 0
      337:  477:    ck_fclose(prog.file);
call    0 returned 337
      337:  478:  prog.file = NULL;
        -:  479:
      337:  480:  first_script = 0;
      337:  481:  return ret;
        -:  482:}
        -:  483:
        -:  484:/* Make any checks which require the whole program to have been read.
        -:  485:   In particular: this backpatches the jump targets.
        -:  486:   Any cleanup which can be done after these checks is done here also.  */
        -:  487:void
function check_final_program called 355 returned 100% blocks executed 78%
      355:  488:check_final_program(program)
        -:  489:  struct vector *program;
        -:  490:{
        -:  491:  struct sed_label *go;
        -:  492:  struct sed_label *lbl;
        -:  493:  struct sed_label *nxt;
        -:  494:
        -:  495:  /* do all "{"s have a corresponding "}"? */
      355:  496:  if (program->return_v)
branch  0 taken 1 (fallthrough)
branch  1 taken 354
        -:  497:    {
        1:  498:      cur_input = *program->return_v->err_info; /* for error reporting */
        1:  499:      bad_prog(EXCESS_OPEN_BRACKET);
call    0 returned 0
        -:  500:    }
      354:  501:  FREE(program->err_info);	/* no longer need this */
call    0 returned 354
      354:  502:  program->err_info = NULL;
        -:  503:
        -:  504:  /* was the final command an unterminated a/c/i command? */
      354:  505:  if (pending_text)
branch  0 taken 0 (fallthrough)
branch  1 taken 354
        -:  506:    {
    #####:  507:      old_text_buf->text_len = size_buffer(pending_text);
call    0 never executed
    #####:  508:      old_text_buf->text = MEMDUP(get_buffer(pending_text),
call    0 never executed
call    1 never executed
        -:  509:				  old_text_buf->text_len, char);
    #####:  510:      free_buffer(pending_text);
call    0 never executed
    #####:  511:      pending_text = NULL;
        -:  512:    }
        -:  513:
      363:  514:  for (go = jumps; go; go = nxt)
branch  0 taken 9
branch  1 taken 354 (fallthrough)
        -:  515:    {
       11:  516:      for (lbl = labels; lbl; lbl = lbl->next)
branch  0 taken 7
branch  1 taken 4 (fallthrough)
        7:  517:	if (strcmp(lbl->name, go->name) == 0)
branch  0 taken 5 (fallthrough)
branch  1 taken 2
        5:  518:	  break;
        9:  519:      if (*go->name && !lbl)
branch  0 taken 5 (fallthrough)
branch  1 taken 4
branch  2 taken 0 (fallthrough)
branch  3 taken 5
    #####:  520:	panic("Can't find label for jump to '%s'", go->name);
call    0 never executed
        9:  521:      go->v->v[go->v_index].x.jump = lbl;
        9:  522:      nxt = go->next;
        9:  523:      FREE(go->name);
call    0 returned 9
        9:  524:      FREE(go);
call    0 returned 9
        -:  525:    }
      354:  526:  jumps = NULL;
        -:  527:
      358:  528:  for (lbl = labels; lbl; lbl = lbl->next)
branch  0 taken 4
branch  1 taken 354 (fallthrough)
        -:  529:    {
        4:  530:      FREE(lbl->name);
call    0 returned 4
        4:  531:      lbl->name = NULL;
        -:  532:    }
      354:  533:}
        -:  534:
        -:  535:static struct vector *
function new_vector called 690 returned 100% blocks executed 100%
      690:  536:new_vector(errinfo, old_vector)
        -:  537:  struct error_info *errinfo;
        -:  538:  struct vector *old_vector;
        -:  539:{
      690:  540:  struct vector *vector = MALLOC(1, struct vector);
call    0 returned 690
      690:  541:  vector->v = NULL;
      690:  542:  vector->v_allocated = 0;
      690:  543:  vector->v_length = 0;
      690:  544:  vector->err_info = MEMDUP(errinfo, 1, struct error_info);
call    0 returned 690
      690:  545:  vector->return_v = old_vector;
      690:  546:  vector->return_i = old_vector ? old_vector->v_length : 0;
branch  0 taken 330 (fallthrough)
branch  1 taken 360
      690:  547:  return vector;
        -:  548:}
        -:  549:
        -:  550:static void
function read_text called 106 returned 100% blocks executed 81%
      106:  551:read_text(buf, leadin_ch)
        -:  552:  struct text_buf *buf;
        -:  553:  int leadin_ch;
        -:  554:{
        -:  555:  int ch;
        -:  556:
        -:  557:  /* Should we start afresh (as opposed to continue a partial text)? */
      106:  558:  if (buf)
branch  0 taken 106 (fallthrough)
branch  1 taken 0
        -:  559:    {
      106:  560:      if (pending_text)
branch  0 taken 0 (fallthrough)
branch  1 taken 106
    #####:  561:	free_buffer(pending_text);
call    0 never executed
      106:  562:      pending_text = init_buffer();
call    0 returned 106
      106:  563:      buf->text = NULL;
      106:  564:      buf->text_len = 0;
      106:  565:      old_text_buf = buf;
        -:  566:    }
        -:  567:  /* assert(old_text_buf != NULL); */
        -:  568:
      106:  569:  if (leadin_ch == EOF)
branch  0 taken 0 (fallthrough)
branch  1 taken 106
    #####:  570:    return;
     2629:  571:  while ((ch = inchar()) != EOF && ch != '\n')
call    0 returned 2629
branch  1 taken 2629 (fallthrough)
branch  2 taken 0
branch  3 taken 2523
branch  4 taken 106 (fallthrough)
        -:  572:    {
     2523:  573:      if (ch == '\\')
branch  0 taken 14 (fallthrough)
branch  1 taken 2509
        -:  574:	{
       14:  575:	  if ((ch = inchar()) == EOF)
call    0 returned 14
branch  1 taken 0 (fallthrough)
branch  2 taken 14
        -:  576:	    {
    #####:  577:	      add1_buffer(pending_text, '\n');
call    0 never executed
    #####:  578:	      return;
        -:  579:	    }
        -:  580:	}
     2523:  581:      add1_buffer(pending_text, ch);
call    0 returned 2523
        -:  582:    }
      106:  583:  add1_buffer(pending_text, '\n');
call    0 returned 106
        -:  584:
      106:  585:  if (!buf)
branch  0 taken 0 (fallthrough)
branch  1 taken 106
    #####:  586:    buf = old_text_buf;
      106:  587:  buf->text_len = size_buffer(pending_text);
call    0 returned 106
      106:  588:  buf->text = MEMDUP(get_buffer(pending_text), buf->text_len, char);
call    0 returned 106
call    1 returned 106
      106:  589:  free_buffer(pending_text);
call    0 returned 106
      106:  590:  pending_text = NULL;
        -:  591:}
        -:  592:
        -:  593:
        -:  594:/* Read a program (or a subprogram within '{' '}' pairs) in and store
        -:  595:   the compiled form in *'vector'.  Return a pointer to the new vector.  */
        -:  596:static struct vector *
function compile_program called 363 returned 99% blocks executed 79%
      363:  597:compile_program(vector)
        -:  598:  struct vector *vector;
        -:  599:{
        -:  600:  struct sed_cmd *cur_cmd;
        -:  601:  struct buffer *b;
        -:  602:  struct buffer *b2;
        -:  603:  unsigned char *ustring;
        -:  604:  size_t len;
        -:  605:  int slash;
        -:  606:  int ch;
        -:  607:
      363:  608:  if (!vector)
branch  0 taken 360 (fallthrough)
branch  1 taken 3
      360:  609:    vector = new_vector(&cur_input, NULL);
call    0 returned 360
      363:  610:  if (pending_text)
branch  0 taken 0 (fallthrough)
branch  1 taken 363
    #####:  611:    read_text(NULL, '\n');
call    0 never executed
        -:  612:
        -:  613:  for (;;)
        -:  614:    {
    10593:  615:      while ((ch=inchar()) == ';' || ISSPACE(ch))
call    0 returned 10593
branch  1 taken 0
branch  2 taken 10593 (fallthrough)
branch  3 taken 7704
branch  4 taken 2889 (fallthrough)
        -:  616:	;
     2889:  617:      if (ch == EOF)
branch  0 taken 358 (fallthrough)
branch  1 taken 2531
      358:  618:	break;
        -:  619:
     2531:  620:      cur_cmd = next_cmd_entry(&vector);
call    0 returned 2531
     2531:  621:      if (compile_address(&cur_cmd->a1, ch))
call    0 returned 2531
branch  1 taken 439 (fallthrough)
branch  2 taken 2092
        -:  622:	{
      439:  623:	  ch = in_nonblank();
call    0 returned 439
      439:  624:	  if (ch == ',')
branch  0 taken 45 (fallthrough)
branch  1 taken 394
        -:  625:	    {
       45:  626:	      if (!compile_address(&cur_cmd->a2, in_nonblank()))
call    0 returned 45
call    1 returned 45
branch  2 taken 0 (fallthrough)
branch  3 taken 45
    #####:  627:		bad_prog("Unexpected ','");
call    0 never executed
       45:  628:	      ch = in_nonblank();
call    0 returned 45
        -:  629:	    }
        -:  630:	}
     2531:  631:      if (cur_cmd->a2.addr_type == addr_is_num
branch  0 taken 21 (fallthrough)
branch  1 taken 2510
       21:  632:	  && cur_cmd->a1.addr_type == addr_is_num
branch  0 taken 18 (fallthrough)
branch  1 taken 3
       18:  633:	  && cur_cmd->a2.a.addr_number < cur_cmd->a1.a.addr_number)
branch  0 taken 0 (fallthrough)
branch  1 taken 18
    #####:  634:	cur_cmd->a2.a.addr_number = cur_cmd->a1.a.addr_number;
     2531:  635:      if (ch == '!')
branch  0 taken 20 (fallthrough)
branch  1 taken 2511
        -:  636:	{
       20:  637:	  cur_cmd->addr_bang = 1;
       20:  638:	  ch = in_nonblank();
call    0 returned 20
       20:  639:	  if (ch == '!')
branch  0 taken 0 (fallthrough)
branch  1 taken 20
    #####:  640:	    bad_prog("Multiple '!'s");
call    0 never executed
        -:  641:	}
        -:  642:
     2531:  643:      cur_cmd->cmd = ch;
     2531:  644:      switch (ch)
branch  0 taken 507
branch  1 taken 330
branch  2 taken 329
branch  3 taken 70
branch  4 taken 36
branch  5 taken 4
branch  6 taken 9
branch  7 taken 37
branch  8 taken 847
branch  9 taken 34
branch 10 taken 45
branch 11 taken 239
branch 12 taken 39
branch 13 taken 0
branch 14 taken 5
        -:  645:	{
      507:  646:	case '#':
      507:  647:	  if (cur_cmd->a1.addr_type != addr_is_null)
branch  0 taken 0 (fallthrough)
branch  1 taken 507
    #####:  648:	    bad_prog(NO_ADDR);
call    0 never executed
      507:  649:	  ch = inchar();
call    0 returned 507
      507:  650:	  if (ch=='n' && first_script && cur_input.line < 2)
branch  0 taken 211 (fallthrough)
branch  1 taken 296
branch  2 taken 211 (fallthrough)
branch  3 taken 0
branch  4 taken 211 (fallthrough)
branch  5 taken 0
      211:  651:	    if (   (prog.base && prog.cur==2+CAST(unsigned char *)prog.base)
branch  0 taken 211 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 211
    #####:  652:	        || (prog.file && !prog.base && 2==ftell(prog.file)))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
      211:  653:	      no_default_output = 1;
     6278:  654:	  while (ch != EOF && ch != '\n')
branch  0 taken 6278 (fallthrough)
branch  1 taken 0
branch  2 taken 5771
branch  3 taken 507 (fallthrough)
     5771:  655:	    ch = inchar();
call    0 returned 5771
      507:  656:	  continue;	/* restart the for (;;) loop */
        -:  657:
      330:  658:	case '{':
      330:  659:	  ++vector->v_length;	/* be sure to count this insn */
      330:  660:	  vector = cur_cmd->x.sub = new_vector(&cur_input, vector);
call    0 returned 330
      330:  661:	  continue;	/* restart the for (;;) loop */
        -:  662:
      329:  663:	case '}':
        -:  664:	  /* a return insn for subprograms -t */
      329:  665:	  if (!vector->return_v)
branch  0 taken 0 (fallthrough)
branch  1 taken 329
    #####:  666:	    bad_prog(EXCESS_CLOSE_BRACKET);
call    0 never executed
      329:  667:	  if (cur_cmd->a1.addr_type != addr_is_null)
branch  0 taken 0 (fallthrough)
branch  1 taken 329
    #####:  668:	    bad_prog(/*{*/ "} doesn't want any addresses");
call    0 never executed
      329:  669:	  ch = in_nonblank();
call    0 returned 329
     329*:  670:	  if (ch != EOF && ch != '\n' && ch != ';')
branch  0 taken 329 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 329
branch  4 never executed
branch  5 never executed
    #####:  671:	    bad_prog(LINE_JUNK);
call    0 never executed
      329:  672:	  ++vector->v_length;		/* we haven't counted this insn yet */
      329:  673:	  FREE(vector->err_info);	/* no longer need this */
call    0 returned 329
      329:  674:	  vector->err_info = NULL;
      329:  675:	  vector = vector->return_v;
      329:  676:	  continue;	/* restart the for (;;) loop */
        -:  677:
       70:  678:	case 'a':
        -:  679:	case 'i':
       70:  680:	  if (cur_cmd->a2.addr_type != addr_is_null)
branch  0 taken 0 (fallthrough)
branch  1 taken 70
    #####:  681:	    bad_prog(ONE_ADDR);
call    0 never executed
        -:  682:	  /* Fall Through */
        -:  683:	case 'c':
      106:  684:	  ch = in_nonblank();
call    0 returned 106
      106:  685:	  if (ch != '\\')
branch  0 taken 0 (fallthrough)
branch  1 taken 106
    #####:  686:	    bad_prog(LINE_JUNK);
call    0 never executed
      106:  687:	  ch = inchar();
call    0 returned 106
     106*:  688:	  if (ch != '\n' && ch != EOF)
branch  0 taken 0 (fallthrough)
branch  1 taken 106
branch  2 never executed
branch  3 never executed
    #####:  689:	    bad_prog(LINE_JUNK);
call    0 never executed
      106:  690:	  read_text(&cur_cmd->x.cmd_txt, ch);
call    0 returned 106
      106:  691:	  break;
        -:  692:
        4:  693:	case ':':
        4:  694:	  if (cur_cmd->a1.addr_type != addr_is_null)
branch  0 taken 0 (fallthrough)
branch  1 taken 4
    #####:  695:	    bad_prog(": doesn't want any addresses");
call    0 never executed
        4:  696:	  labels = setup_jump(labels, cur_cmd, vector);
call    0 returned 4
        4:  697:	  break;
        9:  698:	case 'b':
        -:  699:	case 't':
        9:  700:	  jumps = setup_jump(jumps, cur_cmd, vector);
call    0 returned 9
        9:  701:	  break;
        -:  702:
       37:  703:	case 'q':
        -:  704:	case '=':
       37:  705:	  if (cur_cmd->a2.addr_type != addr_is_null)
branch  0 taken 0 (fallthrough)
branch  1 taken 37
    #####:  706:	    bad_prog(ONE_ADDR);
call    0 never executed
        -:  707:	  /* Fall Through */
        -:  708:	case 'd':
        -:  709:	case 'D':
        -:  710:	case 'g':
        -:  711:	case 'G':
        -:  712:	case 'h':
        -:  713:	case 'H':
        -:  714:	case 'l':
        -:  715:	case 'n':
        -:  716:	case 'N':
        -:  717:	case 'p':
        -:  718:	case 'P':
        -:  719:	case 'x':
      884:  720:	  ch = in_nonblank();
call    0 returned 884
      884:  721:	  if (ch != EOF && ch != '\n' && ch != ';')
branch  0 taken 879 (fallthrough)
branch  1 taken 5
branch  2 taken 77 (fallthrough)
branch  3 taken 802
branch  4 taken 0 (fallthrough)
branch  5 taken 77
    #####:  722:	    bad_prog(LINE_JUNK);
call    0 never executed
      884:  723:	  break;
        -:  724:
       34:  725:	case 'r':
       34:  726:	  if (cur_cmd->a2.addr_type != addr_is_null)
branch  0 taken 0 (fallthrough)
branch  1 taken 34
    #####:  727:	    bad_prog(ONE_ADDR);
call    0 never executed
       34:  728:	  compile_filename(1, &cur_cmd->x.rfile, NULL);
call    0 returned 34
       34:  729:	  break;
       45:  730:	case 'w':
       45:  731:	  compile_filename(0, NULL, &cur_cmd->x.wfile);
call    0 returned 45
       45:  732:	  break;
        -:  733:
      239:  734:	case 's':
      239:  735:	  slash = inchar();
call    0 returned 239
      239:  736:	  if ( !(b  = match_slash(slash, 1, 1)) )
call    0 returned 239
branch  1 taken 0 (fallthrough)
branch  2 taken 239
    #####:  737:	    bad_prog(UNTERM_S_CMD);
call    0 never executed
      239:  738:	  if ( !(b2 = match_slash(slash, 0, 1)) )
call    0 returned 239
branch  1 taken 0 (fallthrough)
branch  2 taken 239
    #####:  739:	    bad_prog(UNTERM_S_CMD);
call    0 never executed
        -:  740:
      239:  741:	  cur_cmd->x.cmd_regex.replace_length = size_buffer(b2);
call    0 returned 239
      239:  742:	  cur_cmd->x.cmd_regex.replacement = MEMDUP(get_buffer(b2),
call    0 returned 239
call    1 returned 239
        -:  743:				    cur_cmd->x.cmd_regex.replace_length, char);
      239:  744:	  free_buffer(b2);
call    0 returned 239
        -:  745:
        -:  746:	  {
      239:  747:	    flagT caseless = mark_subst_opts(&cur_cmd->x.cmd_regex);
call    0 returned 239
      239:  748:	    cur_cmd->x.cmd_regex.regx = compile_regex(b, caseless, 0);
call    0 returned 239
        -:  749:	  }
      239:  750:	  free_buffer(b);
call    0 returned 239
      239:  751:	  break;
        -:  752:
       39:  753:	case 'y':
       39:  754:	  ustring = MALLOC(YMAP_LENGTH, unsigned char);
call    0 returned 39
    10023:  755:	  for (len = 0; len < YMAP_LENGTH; len++)
branch  0 taken 9984
branch  1 taken 39 (fallthrough)
     9984:  756:	    ustring[len] = len;
       39:  757:	  cur_cmd->x.translate = ustring;
        -:  758:
       39:  759:	  slash = inchar();
call    0 returned 39
       39:  760:	  if ( !(b = match_slash(slash, 0, 0)) )
call    0 returned 39
branch  1 taken 0 (fallthrough)
branch  2 taken 39
    #####:  761:	    bad_prog(UNTERM_Y_CMD);
call    0 never executed
       39:  762:	  ustring = CAST(unsigned char *)get_buffer(b);
call    0 returned 39
      328:  763:	  for (len = size_buffer(b); len; --len)
call    0 returned 39
branch  1 taken 289
branch  2 taken 39 (fallthrough)
        -:  764:	    {
      289:  765:	      ch = inchar();
call    0 returned 289
      289:  766:	      if (ch == slash)
branch  0 taken 0 (fallthrough)
branch  1 taken 289
    #####:  767:		bad_prog("strings for y command are different lengths");
call    0 never executed
      289:  768:	      if (ch == '\n')
branch  0 taken 0 (fallthrough)
branch  1 taken 289
    #####:  769:		bad_prog(UNTERM_Y_CMD);
call    0 never executed
      289:  770:	      if (ch == '\\')
branch  0 taken 0 (fallthrough)
branch  1 taken 289
    #####:  771:		ch = inchar();
call    0 never executed
      289:  772:	      if (ch == EOF)
branch  0 taken 0 (fallthrough)
branch  1 taken 289
    #####:  773:		bad_prog(BAD_EOF);
call    0 never executed
      289:  774:	      cur_cmd->x.translate[*ustring++] = ch;
        -:  775:	    }
       39:  776:	  free_buffer(b);
call    0 returned 39
        -:  777:
       78:  778:	  if (inchar() != slash ||
call    0 returned 39
branch  1 taken 39 (fallthrough)
branch  2 taken 0
branch  3 taken 39 (fallthrough)
branch  4 taken 0
       78:  779:	      ((ch = in_nonblank()) != EOF && ch != '\n' && ch != ';'))
call    0 returned 39
branch  1 taken 2 (fallthrough)
branch  2 taken 37
branch  3 taken 0 (fallthrough)
branch  4 taken 2
    #####:  780:	    bad_prog(LINE_JUNK);
call    0 never executed
       39:  781:	  break;
        -:  782:
    #####:  783:	case EOF:
    #####:  784:	  bad_prog(NO_COMMAND);
call    0 never executed
        -:  785:	  /*NOTREACHED*/
        5:  786:	default:
        -:  787:	  {
        -:  788:	    static char unknown_cmd[] = "Unknown command: ``_''";
        5:  789:	    unknown_cmd[sizeof(unknown_cmd)-4] = ch;
        5:  790:	    bad_prog(unknown_cmd);
call    0 returned 0
        -:  791:	  }
        -:  792:	  /*NOTREACHED*/
        -:  793:	}
        -:  794:
        -:  795:      /* this is buried down here so that "continue" statements will miss it */
     1360:  796:      ++vector->v_length;
        -:  797:    }
      358:  798:  return vector;
        -:  799:}
        -:  800:
        -:  801:static struct sed_cmd *
function next_cmd_entry called 2531 returned 100% blocks executed 100%
     2531:  802:next_cmd_entry(vectorp)
        -:  803:  struct vector **vectorp;
        -:  804:{
        -:  805:  struct sed_cmd *cmd;
        -:  806:  struct vector *v;
        -:  807:
     2531:  808:  v = *vectorp;
     2531:  809:  if (v->v_length == v->v_allocated)
branch  0 taken 689 (fallthrough)
branch  1 taken 1842
        -:  810:    {
      689:  811:      v->v_allocated += VECTOR_ALLOC_INCREMENT;
      689:  812:      v->v = REALLOC(v->v, v->v_allocated, struct sed_cmd);
call    0 returned 689
        -:  813:    }
        -:  814:
     2531:  815:  cmd = v->v + v->v_length;
     2531:  816:  cmd->a1.addr_type = addr_is_null;
     2531:  817:  cmd->a2.addr_type = addr_is_null;
     2531:  818:  cmd->a1_matched = 0;
     2531:  819:  cmd->addr_bang = 0;
        -:  820:
     2531:  821:  *vectorp  = v;
     2531:  822:  return cmd;
        -:  823:}
        -:  824:
        -:  825:
        -:  826:/* let's not confuse text editors that have only dumb bracket-matching... */
        -:  827:#define OPEN_BRACKET	'['
        -:  828:#define CLOSE_BRACKET	']'
        -:  829:
        -:  830:static int
function add_then_next called 36 returned 100% blocks executed 100%
       36:  831:add_then_next(b, ch)
        -:  832:  struct buffer *b;
        -:  833:  int ch;
        -:  834:{
       36:  835:  add1_buffer(b, ch);
call    0 returned 36
       36:  836:  return inchar();
call    0 returned 36
        -:  837:}
        -:  838:
        -:  839:/* 
        -:  840:   Because the differences between v3 and v4
        -:  841:   are so scarce, faults are injected outside
        -:  842:   change boundaries on this function
        -:  843:
        -:  844:   SIR, August 2006, Kyle R. Murphy
        -:  845:*/
        -:  846:
        -:  847:static int
function snarf_char_class called 7 returned 100% blocks executed 39%
        7:  848:snarf_char_class(b)
        -:  849:  struct buffer *b;
        -:  850:{
        -:  851:  int ch;
        -:  852:
        7:  853:  ch = inchar();
call    0 returned 7
        7:  854:  if (ch == '^')
branch  0 taken 1 (fallthrough)
branch  1 taken 6
        -:  855:  #ifndef FAULTY_F_KRM_2
        1:  856:    ch = add_then_next(b, ch);
call    0 returned 1
        -:  857:  #else
        -:  858:    ch = add_then_next(b, ch+1);
        -:  859:  #endif
        7:  860:  if (ch == CLOSE_BRACKET)
branch  0 taken 0 (fallthrough)
branch  1 taken 7
    #####:  861:    ch = add_then_next(b, ch);
call    0 never executed
       42:  862:  while (ch != EOF && ch != '\n' && ch != CLOSE_BRACKET)
branch  0 taken 42 (fallthrough)
branch  1 taken 0
branch  2 taken 42 (fallthrough)
branch  3 taken 0
branch  4 taken 35
branch  5 taken 7 (fallthrough)
        -:  863:    {
       35:  864:      if (ch == OPEN_BRACKET)
branch  0 taken 0 (fallthrough)
branch  1 taken 35
        -:  865:	{
        -:  866:	  int prev;
    #####:  867:	  int delim = ch = add_then_next(b, ch);
call    0 never executed
        -:  868:
    #####:  869:	  if (delim != '.'  &&  delim != ':'  &&  delim != '=')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  870:	    continue; /* bypass the add_then_next() call at bottom of loop */
        -:  871:	  #ifndef FAULTY_F_KRM_4
    #####:  872:	  for (prev=ch=add_then_next(b, ch);
call    0 never executed
        -:  873:	  #else
        -:  874:	  for (prev=ch;
        -:  875:	  #endif
    #####:  876:		  !(ch==CLOSE_BRACKET && prev==delim); ch=add_then_next(b, ch))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  877:	    {
    #####:  878:	      if (ch == EOF || ch == '\n')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  879:		return EOF;
        -:  880:	      #ifndef FAULTY_F_KRM_1
    #####:  881:	      prev = ch;
call    0 never executed
        -:  882:	      #else
        -:  883:	      prev = ch - 1;
        -:  884:	      #endif
        -:  885:	    }
        -:  886:	}
       35:  887:      else if (ch == '\\')
branch  0 taken 0 (fallthrough)
branch  1 taken 35
        -:  888:	{
    #####:  889:	  ch = inchar();
call    0 never executed
    #####:  890:	  if (ch == EOF)
branch  0 never executed
branch  1 never executed
    #####:  891:	    break;
    #####:  892:	  if (ch != 'n' && ch != '\n')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  893:	    {
    #####:  894:	      add1_buffer(b, '\\');
call    0 never executed
        -:  895:	      #ifndef FAULTY_F_KRM_3
    #####:  896:	      continue; /* bypass the add_then_next() call at bottom of loop */
        -:  897:	      #else
        -:  898:	      /* don't continue */
        -:  899:	      #endif
        -:  900:	    }
    #####:  901:	  ch = '\n';
        -:  902:	}
       35:  903:      ch = add_then_next(b, ch);
call    0 returned 35
        -:  904:    }
        -:  905:
        -:  906:  /* ensure that a newline here is an error, not a "slash" match: */
       7*:  907:  return ch == '\n' ? EOF : ch;
branch  0 taken 7 (fallthrough)
branch  1 taken 0
        -:  908:}
        -:  909:
        -:  910:static struct buffer *
function match_slash called 900 returned 100% blocks executed 62%
      900:  911:match_slash(slash, regex, keep_backwhack)
        -:  912:  int slash;
        -:  913:  flagT regex;
        -:  914:  flagT keep_backwhack;
        -:  915:{
        -:  916:  struct buffer *b;
        -:  917:  int ch;
        -:  918:
      900:  919:  b = init_buffer();
call    0 returned 900
     5353:  920:  while ((ch = inchar()) != EOF && ch != '\n' && ch != slash)
call    0 returned 5353
branch  1 taken 5353 (fallthrough)
branch  2 taken 0
branch  3 taken 5353 (fallthrough)
branch  4 taken 0
branch  5 taken 4453
branch  6 taken 900 (fallthrough)
        -:  921:    {
     4453:  922:      if (ch == '\\')
branch  0 taken 391 (fallthrough)
branch  1 taken 4062
        -:  923:	{
      391:  924:	  ch = inchar();
call    0 returned 391
      391:  925:	  if (ch == EOF)
branch  0 taken 0 (fallthrough)
branch  1 taken 391
    #####:  926:	    break;
      391:  927:	  else if (ch == 'n' && regex)
branch  0 taken 12 (fallthrough)
branch  1 taken 379
branch  2 taken 12 (fallthrough)
branch  3 taken 0
       12:  928:	    ch = '\n';
      379:  929:	  else if (ch != '\n' && (ch != slash || keep_backwhack))
branch  0 taken 379 (fallthrough)
branch  1 taken 0
branch  2 taken 4 (fallthrough)
branch  3 taken 375
branch  4 taken 4 (fallthrough)
branch  5 taken 0
      379:  930:	    add1_buffer(b, '\\');
call    0 returned 379
        -:  931:	}
     4062:  932:      else if (ch == OPEN_BRACKET && regex)
branch  0 taken 27 (fallthrough)
branch  1 taken 4035
branch  2 taken 7 (fallthrough)
branch  3 taken 20
        -:  933:	{
        7:  934:	  add1_buffer(b, ch);
call    0 returned 7
        7:  935:	  ch = snarf_char_class(b);
call    0 returned 7
        7:  936:	  if (ch != CLOSE_BRACKET)
branch  0 taken 0 (fallthrough)
branch  1 taken 7
    #####:  937:	    break;
        -:  938:	}
     4453:  939:      add1_buffer(b, ch);
call    0 returned 4453
        -:  940:    }
      900:  941:  if (ch == slash)
branch  0 taken 900 (fallthrough)
branch  1 taken 0
      900:  942:    return b;
        -:  943:
    #####:  944:  if (ch == '\n')
branch  0 never executed
branch  1 never executed
    #####:  945:    savchar(ch);	/* for proper line number in error report */
call    0 never executed
    #####:  946:  if (regex && rx_testing)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  947:    {
        -:  948:      /* This is slightly bogus.  Sed is noticing an ill-formed regexp,
        -:  949:       * but rx is getting the credit.  Fortunately, this only affects
        -:  950:       * a few spencer tests.
        -:  951:       */
    #####:  952:      size_t sz = size_buffer(b);
call    0 never executed
        -:  953:      char *re_txt;
    #####:  954:      add1_buffer(b, '\0');
call    0 never executed
    #####:  955:      re_txt = get_buffer(b);
call    0 never executed
    #####:  956:      if (sz > 0 && re_txt[sz] == '\n')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  957:	re_txt[sz] = '\0';
    #####:  958:      printf(BAD_REGEX_FMT, re_txt);
call    0 never executed
    #####:  959:      exit(1);
call    0 never executed
        -:  960:    }
    #####:  961:  free_buffer(b);
call    0 never executed
    #####:  962:  return NULL;
        -:  963:}
        -:  964:
        -:  965:static regex_t *
function compile_regex called 622 returned 100% blocks executed 69%
      622:  966:compile_regex(b, ignore_case, nosub)
        -:  967:  struct buffer *b;
        -:  968:  flagT ignore_case;
        -:  969:  flagT nosub;
        -:  970:{
        -:  971:  /* ``An empty regular expression is equivalent to the last regular
        -:  972:     expression read'' so we have to keep track of the last regexp read.
        -:  973:     We keep track the _source_ form of the regular expression because
        -:  974:     it is possible for different modifiers to be specified. */
        -:  975:  static char *last_re = NULL;
      622:  976:  regex_t *new_regex = MALLOC(1, regex_t);
call    0 returned 622
        -:  977:  size_t sz;
        -:  978:  int cflags;
        -:  979:  int error;
        -:  980:
      622:  981:  sz = size_buffer(b);
call    0 returned 622
      622:  982:  if (sz > 0)
branch  0 taken 604 (fallthrough)
branch  1 taken 18
        -:  983:    {
      604:  984:      add1_buffer(b, '\0');
call    0 returned 604
      604:  985:      FREE(last_re);
call    0 returned 604
      604:  986:      last_re = ck_strdup(get_buffer(b));
call    0 returned 604
call    1 returned 604
        -:  987:    }
       18:  988:  else if (!last_re)
branch  0 taken 0 (fallthrough)
branch  1 taken 18
    #####:  989:    bad_prog(NO_REGEX);
call    0 never executed
        -:  990:
      622:  991:  cflags = 0;
      622:  992:  if (ignore_case)
branch  0 taken 0 (fallthrough)
branch  1 taken 622
    #####:  993:    cflags |= REG_ICASE;
      622:  994:  if (nosub)
branch  0 taken 383 (fallthrough)
branch  1 taken 239
      383:  995:    cflags |= REG_NOSUB;
      622:  996:  if (use_extended_syntax_p)
branch  0 taken 1 (fallthrough)
branch  1 taken 621
        1:  997:    cflags |= REG_EXTENDED;
      622:  998:  if ( (error = regcomp(new_regex, last_re, cflags)) )
call    0 returned 622
branch  1 taken 0 (fallthrough)
branch  2 taken 622
        -:  999:    {
        -: 1000:      char msg[1000];
    #####: 1001:      if (rx_testing)
branch  0 never executed
branch  1 never executed
        -: 1002:	{
    #####: 1003:	  printf(BAD_REGEX_FMT, last_re);
call    0 never executed
    #####: 1004:	  exit(1);
call    0 never executed
        -: 1005:	}
    #####: 1006:      regerror(error, NULL, msg, sizeof msg);
call    0 never executed
    #####: 1007:      bad_prog(msg);
call    0 never executed
        -: 1008:  }
        -: 1009:
      622: 1010:  return new_regex;
        -: 1011:}
        -: 1012:
        -: 1013:/* Try to read an address for a sed command.  If it succeeds,
        -: 1014:   return non-zero and store the resulting address in *'addr'.
        -: 1015:   If the input doesn't look like an address read nothing
        -: 1016:   and return zero.  */
        -: 1017:static flagT
function compile_address called 2576 returned 100% blocks executed 75%
     2576: 1018:compile_address(addr, ch)
        -: 1019:  struct addr *addr;
        -: 1020:  int ch;
        -: 1021:{
     2576: 1022:  if (ISDIGIT(ch))
branch  0 taken 88 (fallthrough)
branch  1 taken 2488
        -: 1023:    {
       88: 1024:      countT num = in_integer(ch);
call    0 returned 88
       88: 1025:      ch = in_nonblank();
call    0 returned 88
        -: 1026:#if 1
       88: 1027:      if (ch != '~')
branch  0 taken 88 (fallthrough)
branch  1 taken 0
        -: 1028:	{
       88: 1029:	  savchar(ch);
call    0 returned 88
        -: 1030:	}
        -: 1031:      else
        -: 1032:	{
    #####: 1033:	  countT num2 = in_integer(in_nonblank());
call    0 never executed
call    1 never executed
    #####: 1034:	  if (num2 > 0)
branch  0 never executed
branch  1 never executed
        -: 1035:	    {
    #####: 1036:	      addr->addr_type = addr_is_mod;
    #####: 1037:	      addr->a.m.offset = num;
    #####: 1038:	      addr->a.m.modulo = num2;
    #####: 1039:	      return 1;
        -: 1040:	    }
        -: 1041:	}
       88: 1042:      addr->addr_type = addr_is_num;
       88: 1043:      addr->a.addr_number = num;
        -: 1044:#else
        -: 1045:      if (ch == '~')
        -: 1046:	{
        -: 1047:	  countT num2 = in_integer(in_nonblank());
        -: 1048:	  if (num2 == 0)
        -: 1049:	    bad_prog("Zero step size for ~ addressing is not valid");
        -: 1050:	  addr->addr_type = addr_is_mod;
        -: 1051:	  addr->a.m.offset = num;
        -: 1052:	  addr->a.m.modulo = num2;
        -: 1053:	}
        -: 1054:      else
        -: 1055:	{
        -: 1056:	  savchar(ch);
        -: 1057:	  addr->addr_type = addr_is_num;
        -: 1058:	  addr->a.addr_number = num;
        -: 1059:	}
        -: 1060:#endif
       88: 1061:      return 1;
        -: 1062:    }
     2488: 1063:  else if (ch == '/' || ch == '\\')
branch  0 taken 2105 (fallthrough)
branch  1 taken 383
branch  2 taken 0 (fallthrough)
branch  3 taken 2105
        -: 1064:    {
      383: 1065:      flagT caseless = 0;
        -: 1066:      struct buffer *b;
      383: 1067:      addr->addr_type = addr_is_regex;
      383: 1068:      if (ch == '\\')
branch  0 taken 0 (fallthrough)
branch  1 taken 383
    #####: 1069:	ch = inchar();
call    0 never executed
      383: 1070:      if ( !(b = match_slash(ch, 1, 1)) )
call    0 returned 383
branch  1 taken 0 (fallthrough)
branch  2 taken 383
    #####: 1071:	bad_prog("Unterminated address regex");
call    0 never executed
      383: 1072:      ch = in_nonblank();
call    0 returned 383
      383: 1073:      if (ch == 'I')	/* lower case i would break existing programs */
branch  0 taken 0 (fallthrough)
branch  1 taken 383
    #####: 1074:	caseless = 1;
        -: 1075:      else
      383: 1076:	savchar(ch);
call    0 returned 383
      383: 1077:      addr->a.addr_regex = compile_regex(b, caseless, 1);
call    0 returned 383
      383: 1078:      free_buffer(b);
call    0 returned 383
      383: 1079:      return 1;
        -: 1080:    }
     2105: 1081:  else if (ch == '$')
branch  0 taken 13 (fallthrough)
branch  1 taken 2092
        -: 1082:    {
       13: 1083:      addr->addr_type = addr_is_last;
       13: 1084:      return 1;
        -: 1085:    }
     2092: 1086:  return 0;
        -: 1087:}
        -: 1088:
        -: 1089:/* read in a filename for a 'r', 'w', or 's///w' command, and
        -: 1090:   update the internal structure about files.  The file is
        -: 1091:   opened if it isn't already open in the given mode.  */
        -: 1092:static void
function compile_filename called 230 returned 100% blocks executed 96%
      230: 1093:compile_filename(readit, name, fp)
        -: 1094:  flagT readit;
        -: 1095:  const char **name;
        -: 1096:  FILE **fp;
        -: 1097:{
        -: 1098:  struct buffer *b;
        -: 1099:  int ch;
        -: 1100:  char *file_name;
        -: 1101:  struct fp_list *p;
        -: 1102:
      230: 1103:  b = init_buffer();
call    0 returned 230
      230: 1104:  ch = in_nonblank();
call    0 returned 230
     3097: 1105:  while (ch != EOF && ch != '\n')
branch  0 taken 3091 (fallthrough)
branch  1 taken 6
branch  2 taken 2867
branch  3 taken 224 (fallthrough)
        -: 1106:    {
     2867: 1107:      add1_buffer(b, ch);
call    0 returned 2867
     2867: 1108:      ch = inchar();
call    0 returned 2867
        -: 1109:    }
      230: 1110:  add1_buffer(b, '\0');
call    0 returned 230
      230: 1111:  file_name = get_buffer(b);
call    0 returned 230
        -: 1112:
      292: 1113:  for (p=file_ptrs; p; p=p->link)
branch  0 taken 62
branch  1 taken 230 (fallthrough)
       62: 1114:    if (p->readit_p == readit && strcmp(p->name, file_name) == 0)
branch  0 taken 45 (fallthrough)
branch  1 taken 17
branch  2 taken 0 (fallthrough)
branch  3 taken 45
    #####: 1115:      break;
        -: 1116:
      230: 1117:  if (!p)
branch  0 taken 230 (fallthrough)
branch  1 taken 0
        -: 1118:    {
      230: 1119:      p = MALLOC(1, struct fp_list);
call    0 returned 230
      230: 1120:      p->name = ck_strdup(file_name);
call    0 returned 230
      230: 1121:      p->readit_p = readit;
      230: 1122:      p->fp = NULL;
      230: 1123:      if (!readit)
branch  0 taken 196 (fallthrough)
branch  1 taken 34
      196: 1124:	p->fp = ck_fopen(p->name, "w");
call    0 returned 196
      230: 1125:      p->link = file_ptrs;
      230: 1126:      file_ptrs = p;
        -: 1127:    }
        -: 1128:
      230: 1129:  free_buffer(b);
call    0 returned 230
      230: 1130:  if (name)
branch  0 taken 34 (fallthrough)
branch  1 taken 196
       34: 1131:    *name = p->name;
      230: 1132:  if (fp)
branch  0 taken 196 (fallthrough)
branch  1 taken 34
      196: 1133:    *fp = p->fp;
      230: 1134:}
        -: 1135:
        -: 1136:/* Store a label (or label reference) created by a ':', 'b', or 't'
        -: 1137:   command so that the jump to/from the label can be backpatched after
        -: 1138:   compilation is complete.  */
        -: 1139:static struct sed_label *
function setup_jump called 13 returned 100% blocks executed 100%
       13: 1140:setup_jump(list, cmd, vec)
        -: 1141:  struct sed_label *list;
        -: 1142:  struct sed_cmd *cmd;
        -: 1143:  struct vector *vec;
        -: 1144:{
        -: 1145:  struct sed_label *ret;
        -: 1146:  struct buffer *b;
        -: 1147:  int ch;
        -: 1148:
       13: 1149:  b = init_buffer();
call    0 returned 13
       13: 1150:  ch = in_nonblank();
call    0 returned 13
        -: 1151:
       53: 1152:  while (ch != EOF && ch != '\n'
branch  0 taken 27 (fallthrough)
branch  1 taken 13
       67: 1153:	 && !ISBLANK(ch) && ch != ';' && ch != /*{*/ '}')
branch  0 taken 40 (fallthrough)
branch  1 taken 0
branch  2 taken 27 (fallthrough)
branch  3 taken 0
branch  4 taken 27 (fallthrough)
branch  5 taken 0
branch  6 taken 27 (fallthrough)
branch  7 taken 0
branch  8 taken 27
branch  9 taken 0 (fallthrough)
        -: 1154:    {
       27: 1155:      add1_buffer(b, ch);
call    0 returned 27
       27: 1156:      ch = inchar();
call    0 returned 27
        -: 1157:    }
       13: 1158:  savchar(ch);
call    0 returned 13
       13: 1159:  add1_buffer(b, '\0');
call    0 returned 13
       13: 1160:  ret = MALLOC(1, struct sed_label);
call    0 returned 13
       13: 1161:  ret->name = ck_strdup(get_buffer(b));
call    0 returned 13
call    1 returned 13
       13: 1162:  ret->v = vec;
       13: 1163:  ret->v_index = cmd - vec->v;
       13: 1164:  ret->next = list;
       13: 1165:  free_buffer(b);
call    0 returned 13
       13: 1166:  return ret;
        -: 1167:}
        -: 1168:
        -: 1169:static flagT
function mark_subst_opts called 239 returned 100% blocks executed 56%
      239: 1170:mark_subst_opts(cmd)
        -: 1171:  struct subst *cmd;
        -: 1172:{
      239: 1173:  flagT caseless = 0;
        -: 1174:  int ch;
        -: 1175:
      239: 1176:  cmd->global = 0;
      239: 1177:  cmd->print = 0;
      239: 1178:  cmd->numb = 0;
      239: 1179:  cmd->wfile = NULL;
        -: 1180:
        -: 1181:  for (;;)
      553: 1182:    switch ( (ch = in_nonblank()) )
call    0 returned 553
branch  1 taken 0
branch  2 taken 110
branch  3 taken 204
branch  4 taken 151
branch  5 taken 0
branch  6 taken 88
branch  7 taken 0
        -: 1183:      {
    #####: 1184:      case 'i':	/* GNU extension */
        -: 1185:      case 'I':	/* GNU extension */
    #####: 1186:	caseless = 1;
    #####: 1187:	break;
        -: 1188:
      110: 1189:      case 'p':
      110: 1190:	cmd->print = 1;
      110: 1191:	break;
        -: 1192:
      204: 1193:      case 'g':
      204: 1194:	cmd->global = 1;
      204: 1195:	break;
        -: 1196:
      151: 1197:      case 'w':
      151: 1198:	compile_filename(0, NULL, &cmd->wfile);
call    0 returned 151
      151: 1199:	return caseless;
        -: 1200:
    #####: 1201:      case '0': case '1': case '2': case '3': case '4':
        -: 1202:      case '5': case '6': case '7': case '8': case '9':
    #####: 1203:	if (cmd->numb)
branch  0 never executed
branch  1 never executed
    #####: 1204:	  bad_prog("multiple number options to 's' command");
call    0 never executed
    #####: 1205:	cmd->numb = in_integer(ch);
call    0 never executed
    #####: 1206:	if (!cmd->numb)
branch  0 never executed
branch  1 never executed
    #####: 1207:	  bad_prog("number option to 's' command may not be zero");
call    0 never executed
    #####: 1208:	break;
        -: 1209:
       88: 1210:      case EOF:
        -: 1211:      case '\n':
        -: 1212:      case ';':
       88: 1213:	return caseless;
        -: 1214:
    #####: 1215:      default:
    #####: 1216:	bad_prog("Unknown option to 's'");
call    0 never executed
        -: 1217:	/*NOTREACHED*/
        -: 1218:      }
        -: 1219:}
        -: 1220:
        -: 1221:
        -: 1222:/* Read the next character from the program.  Return EOF if there isn't
        -: 1223:   anything to read.  Keep cur_input.line up to date, so error messages
        -: 1224:   can be meaningful. */
        -: 1225:static int
function inchar called 32502 returned 100% blocks executed 64%
    32502: 1226:inchar()
        -: 1227:{
    32502: 1228:  int ch = EOF;
        -: 1229:
    32502: 1230:  if (prog.cur)
branch  0 taken 32502 (fallthrough)
branch  1 taken 0
        -: 1231:    {
    32502: 1232:      if (prog.cur < prog.end)
branch  0 taken 32124 (fallthrough)
branch  1 taken 378
    32124: 1233:	ch = *prog.cur++;
        -: 1234:    }
    #####: 1235:  else if (prog.file)
branch  0 never executed
branch  1 never executed
        -: 1236:    {
    #####: 1237:      if (!feof(prog.file))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1238:	ch = getc(prog.file);
call    0 never executed
        -: 1239:    }
    32502: 1240:  if (ch == '\n')
branch  0 taken 3307 (fallthrough)
branch  1 taken 29195
     3307: 1241:    ++cur_input.line;
    32502: 1242:  return ch;
        -: 1243:}
        -: 1244:
        -: 1245:/* Read the next non-blank character from the program.  */
        -: 1246:static int
function in_nonblank called 3174 returned 100% blocks executed 100%
     3437: 1247:in_nonblank()
        -: 1248:{
        -: 1249:  int ch;
        -: 1250:  do
     3437: 1251:    ch = inchar();
call    0 returned 3437
     3437: 1252:    while (ISBLANK(ch));
branch  0 taken 261
branch  1 taken 3176 (fallthrough)
branch  2 taken 2
branch  3 taken 3174 (fallthrough)
     3174: 1253:  return ch;
        -: 1254:}
        -: 1255:
        -: 1256:/* Read an integer value from the program.  */
        -: 1257:static countT
function in_integer called 88 returned 100% blocks executed 100%
       88: 1258:in_integer(ch)
        -: 1259:  int ch;
        -: 1260:{
       88: 1261:  countT num = 0;
        -: 1262:
      246: 1263:  while (ISDIGIT(ch))
branch  0 taken 158
branch  1 taken 88 (fallthrough)
        -: 1264:    {
      158: 1265:      num = num * 10 + ch - '0';
      158: 1266:      ch = inchar();
call    0 returned 158
        -: 1267:    }
       88: 1268:  savchar(ch);
call    0 returned 88
       88: 1269:  return num;
        -: 1270:}
        -: 1271:
        -: 1272:/* unget 'ch' so the next call to inchar will return it.   */
        -: 1273:static void
function savchar called 572 returned 100% blocks executed 73%
      572: 1274:savchar(ch)
        -: 1275:  int ch;
        -: 1276:{
      572: 1277:  if (ch == EOF)
branch  0 taken 0 (fallthrough)
branch  1 taken 572
    #####: 1278:    return;
      572: 1279:  if (ch == '\n' && cur_input.line > 0)
branch  0 taken 13 (fallthrough)
branch  1 taken 559
branch  2 taken 13 (fallthrough)
branch  3 taken 0
       13: 1280:    --cur_input.line;
      572: 1281:  if (prog.cur)
branch  0 taken 572 (fallthrough)
branch  1 taken 0
        -: 1282:    {
      572: 1283:      if (prog.cur <= CAST(const unsigned char *)prog.base
branch  0 taken 572 (fallthrough)
branch  1 taken 0
      572: 1284:	  || *--prog.cur != ch)
branch  0 taken 0 (fallthrough)
branch  1 taken 572
    #####: 1285:	panic("Called savchar() with unexpected pushback (%x)",
    #####: 1286:	      CAST(unsigned char)ch);
call    0 never executed
        -: 1287:    }
        -: 1288:  else
    #####: 1289:    ungetc(ch, prog.file);
call    0 never executed
        -: 1290:}
        -: 1291:
        -: 1292:/* Complain about a programming error and exit. */
        -: 1293:static void
function bad_prog called 6 returned 0% blocks executed 100%
        6: 1294:bad_prog(why)
        -: 1295:  const char *why;
        -: 1296:{
        6: 1297:  if (cur_input.name)
branch  0 taken 1 (fallthrough)
branch  1 taken 5
        1: 1298:    fprintf(stderr, "%s: file %s line %lu: %s\n",
        1: 1299:	    myname, cur_input.name, CAST(unsigned long)cur_input.line, why);
call    0 returned 1
        -: 1300:  else
        5: 1301:    fprintf(stderr, "%s: -e expression #%lu, char %lu: %s\n",
        -: 1302:	    myname,
        5: 1303:	    CAST(unsigned long)cur_input.string_expr_count,
        5: 1304:	    CAST(unsigned long)(prog.cur-CAST(unsigned char *)prog.base),
call    0 returned 5
        -: 1305:	    why);
        6: 1306:  exit(1);
        -: 1307:}
        -: 1308:/*  GNU SED, a batch stream editor.
        -: 1309:    Copyright (C) 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1998
        -: 1310:    Free Software Foundation, Inc.
        -: 1311:
        -: 1312:    This program is free software; you can redistribute it and/or modify
        -: 1313:    it under the terms of the GNU General Public License as published by
        -: 1314:    the Free Software Foundation; either version 2, or (at your option)
        -: 1315:    any later version.
        -: 1316:
        -: 1317:    This program is distributed in the hope that it will be useful,
        -: 1318:    but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 1319:    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 1320:    GNU General Public License for more details.
        -: 1321:
        -: 1322:    You should have received a copy of the GNU General Public License
        -: 1323:    along with this program; if not, write to the Free Software
        -: 1324:    Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
        -: 1325:
        -: 1326:#undef EXPERIMENTAL_DASH_N_OPTIMIZATION	/*don't use -- is buggy*/
        -: 1327:#define INITIAL_BUFFER_SIZE	50
        -: 1328:#define LCMD_OUT_LINE_LEN	70
        -: 1329:#define FREAD_BUFFER_SIZE	8192
        -: 1330:
        -: 1331:#include "config.h"
        -: 1332:#include <stdio.h>
        -: 1333:#include <ctype.h>
        -: 1334:
        -: 1335:#include <errno.h>
        -: 1336:#ifndef errno
        -: 1337:extern int errno;
        -: 1338:#endif
        -: 1339:
        -: 1340:#ifdef HAVE_ISATTY
        -: 1341:# ifdef HAVE_UNISTD_H
        -: 1342:#  include <unistd.h>
        -: 1343:# endif
        -: 1344:#endif
        -: 1345:
        -: 1346:#ifdef __GNUC__
        -: 1347:# if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__-0 >= 7)
        -: 1348:  /* silence warning about unused parameter even for "gcc -W -Wunused" */
        -: 1349:#  define UNUSED	__attribute__((unused))
        -: 1350:# endif
        -: 1351:#endif
        -: 1352:#ifndef UNUSED
        -: 1353:# define UNUSED
        -: 1354:#endif
        -: 1355:
        -: 1356:#ifndef HAVE_STRING_H
        -: 1357:# include <strings.h>
        -: 1358:# ifdef HAVE_MEMORY_H
        -: 1359:#  include <memory.h>
        -: 1360:# endif
        -: 1361:#else
        -: 1362:# include <string.h>
        -: 1363:#endif /* HAVE_STRING_H */
        -: 1364:
        -: 1365:#ifdef HAVE_STDLIB_H
        -: 1366:# include <stdlib.h>
        -: 1367:#endif
        -: 1368:
        -: 1369:#ifdef HAVE_SYS_TYPES_H
        -: 1370:# include <sys/types.h>
        -: 1371:#endif
        -: 1372:#include "regex-sed.h"
        -: 1373:#include "basicdefs.h"
        -: 1374:#include "utils.h"
        -: 1375:#include "sed.h"
        -: 1376:
        -: 1377:#ifdef BOOTSTRAP
        -: 1378:# ifdef memchr
        -: 1379:#  undef memchr
        -: 1380:# endif
        -: 1381:# define memchr bootstrap_memchr
        -: 1382:static VOID *bootstrap_memchr P_((const VOID *s, int c, size_t n));
        -: 1383:#endif /*BOOTSTRAP*/
        -: 1384:
        -: 1385:#ifndef HAVE_REGNEXEC
        -: 1386:# define regnexec(x,t,l,r,n,f)	regexec(x,t,r,n,f)
        -: 1387:#endif
        -: 1388:
        -: 1389:/* If set, don't write out the line unless explicitly told to */
        -: 1390:extern flagT no_default_output;
        -: 1391:
        -: 1392:/* Do we need to be pedantically POSIX compliant? */
        -: 1393:extern flagT POSIXLY_CORRECT;
        -: 1394:
        -: 1395:
        -: 1396:/* Sed operates a line at a time. */
        -: 1397:struct line {
        -: 1398:  char *text;		/* Pointer to line allocated by malloc. */
        -: 1399:  char *active;		/* Pointer to non-consumed part of text. */
        -: 1400:  size_t length;	/* Length of text (or active, if used). */
        -: 1401:  size_t alloc;		/* Allocated space for text. */
        -: 1402:  flagT chomped;	/* Was a trailing newline dropped? */
        -: 1403:};
        -: 1404:
        -: 1405:/* A queue of text to write out at the end of a cycle
        -: 1406:   (filled by the "a" and "r" commands.) */
        -: 1407:struct append_queue {
        -: 1408:  const char *rfile;
        -: 1409:  const char *text;
        -: 1410:  size_t textlen;
        -: 1411:  struct append_queue *next;
        -: 1412:};
        -: 1413:
        -: 1414:/* State information for the input stream. */
        -: 1415:struct input {
        -: 1416:  char **file_list;	/* The list of yet-to-be-opened files.
        -: 1417:			   It is invalid for file_list to be NULL.
        -: 1418:			   When *file_list is NULL we are
        -: 1419:			   currently processing the last file. */
        -: 1420:  countT bad_count;	/* count of files we failed to open */
        -: 1421:  countT line_number;	/* Current input line number (over all files) */
        -: 1422:
        -: 1423:  flagT (*read_fn) P_((struct input *));	/* read one line */
        -: 1424:  /* If fp is NULL, read_fn better not be one which uses fp;
        -: 1425:     in particular, read_always_fail() is recommended. */
        -: 1426:
        -: 1427:  FILE *fp;		/* if NULL, none of the following are valid */
        -: 1428:  VOID *base;		/* if non-NULL, we are using mmap()ed input */
        -: 1429:  const char *cur;	/* only valid if base is non-NULL */
        -: 1430:  size_t length;	/* only valid if base is non-NULL */
        -: 1431:  size_t left;		/* only valid if base is non-NULL */
        -: 1432:#ifdef HAVE_ISATTY
        -: 1433:  flagT is_tty;		/* only valid if base is NULL */
        -: 1434:#endif
        -: 1435:};
        -: 1436:
        -: 1437:static void resize_line P_((struct line *lb, size_t len));
        -: 1438:static void open_next_file P_((const char *name, struct input *input));
        -: 1439:static void closedown P_((struct input *input));
        -: 1440:static flagT read_always_fail P_((struct input *input));
        -: 1441:static flagT read_mem_line P_((struct input *input));
        -: 1442:static size_t slow_getline P_((char *buf, size_t buflen, FILE *in));
        -: 1443:static flagT read_file_line P_((struct input *input));
        -: 1444:static flagT read_pattern_space P_((struct input *input, flagT append));
        -: 1445:static flagT last_file_with_data_p P_((struct input *input));
        -: 1446:static flagT test_dollar_EOF P_((struct input *input));
        -: 1447:static flagT match_an_address_p P_((struct addr *, struct input *, flagT));
        -: 1448:static flagT match_address_p P_((struct sed_cmd *cmd, struct input *input));
        -: 1449:static void do_list P_((void));
        -: 1450:static void do_subst P_((struct subst *subst));
        -: 1451:static flagT execute_program P_((struct vector *, struct input *input));
        -: 1452:static void output_line
        -: 1453:		P_((const char *text, size_t length, flagT nl, FILE *fp));
        -: 1454:static void line_init P_((struct line *buf, size_t initial_size));
        -: 1455:static void line_copy P_((struct line *from, struct line *to));
        -: 1456:static void str_append P_((struct line *to, const char *string, size_t length));
        -: 1457:static void nul_append P_((struct line *dest));
        -: 1458:static void line_append P_((struct line *from, struct line *to));
        -: 1459:static void dump_append_queue P_((void));
        -: 1460:static struct append_queue *next_append_slot P_((void));
        -: 1461:
        -: 1462:#ifdef EXPERIMENTAL_DASH_N_OPTIMIZATION
        -: 1463:static countT count_branches P_((struct vector *));
        -: 1464:static struct sed_cmd *shrink_program
        -: 1465:		P_((struct vector *vec, struct sed_cmd *cur_cmd, countT*n));
        -: 1466:
        -: 1467:/* Used to attempt a simple-minded optimization. */
        -: 1468:static countT branches_in_top_level;
        -: 1469:#endif /*EXPERIMENTAL_DASH_N_OPTIMIZATION*/
        -: 1470:
        -: 1471:
        -: 1472:/* Have we done any replacements lately?  This is used by the 't' command. */
        -: 1473:static flagT replaced = 0;
        -: 1474:
        -: 1475:/* The 'current' input line. */
        -: 1476:static struct line line;
        -: 1477:
        -: 1478:/* An input line that's been stored by later use by the program */
        -: 1479:static struct line hold;
        -: 1480:
        -: 1481:/* The buffered input look-ahead. */
        -: 1482:static struct line buffer;
        -: 1483:
        -: 1484:static struct append_queue *append_head = NULL;
        -: 1485:static struct append_queue *append_tail = NULL;
        -: 1486:
        -: 1487:
        -: 1488:/* Apply the compiled script to all the named files. */
        -: 1489:countT
function process_files called 354 returned 100% blocks executed 100%
      354: 1490:process_files(the_program, argv)
        -: 1491:  struct vector *the_program;
        -: 1492:  char **argv;
        -: 1493:{
        -: 1494:  static char dash[] = "-";
        -: 1495:  static char *stdin_argv[2] = { dash, NULL };
        -: 1496:  struct input input;
        -: 1497:
        -: 1498:#ifdef EXPERIMENTAL_DASH_N_OPTIMIZATION
        -: 1499:  branches_in_top_level = count_branches(the_program);
        -: 1500:#endif /*EXPERIMENTAL_DASH_N_OPTIMIZATION*/
      354: 1501:  input.file_list = stdin_argv;
      354: 1502:  if (argv && *argv)
branch  0 taken 354 (fallthrough)
branch  1 taken 0
branch  2 taken 353 (fallthrough)
branch  3 taken 1
      353: 1503:    input.file_list = argv;
      354: 1504:  input.bad_count = 0;
      354: 1505:  input.line_number = 0;
      354: 1506:  input.read_fn = read_always_fail;
      354: 1507:  input.fp = NULL;
        -: 1508:
      354: 1509:  line_init(&line, INITIAL_BUFFER_SIZE);
call    0 returned 354
      354: 1510:  line_init(&hold, INITIAL_BUFFER_SIZE);
call    0 returned 354
      354: 1511:  line_init(&buffer, FREAD_BUFFER_SIZE);
call    0 returned 354
        -: 1512:
    32216: 1513:  while (read_pattern_space(&input, 0))
call    0 returned 32216
branch  1 taken 31909
branch  2 taken 307 (fallthrough)
        -: 1514:    {
    31909: 1515:      flagT quit = execute_program(the_program, &input);
call    0 returned 31909
    31909: 1516:      if (!no_default_output)
branch  0 taken 12802 (fallthrough)
branch  1 taken 19107
    12802: 1517:	output_line(line.text, line.length, line.chomped, stdout);
call    0 returned 12802
    31909: 1518:      if (quit)
branch  0 taken 47 (fallthrough)
branch  1 taken 31862
       47: 1519:	break;
        -: 1520:    }
      354: 1521:  closedown(&input);
call    0 returned 354
      354: 1522:  return input.bad_count;
        -: 1523:}
        -: 1524:
        -: 1525:/* increase a struct line's length, making some attempt at
        -: 1526:   keeping realloc() calls under control by padding for future growth.  */
        -: 1527:static void
function resize_line called 391 returned 100% blocks executed 100%
      391: 1528:resize_line(lb, len)
        -: 1529:  struct line *lb;
        -: 1530:  size_t len;
        -: 1531:{
      391: 1532:  lb->alloc *= 2;
      391: 1533:  if (lb->alloc - lb->length < len)
branch  0 taken 4 (fallthrough)
branch  1 taken 387
        4: 1534:    lb->alloc = lb->length + len;
      391: 1535:  lb->text = REALLOC(lb->text, lb->alloc, char);
call    0 returned 391
      391: 1536:}
        -: 1537:
        -: 1538:/* Initialize a struct input for the named file. */
        -: 1539:static void
function open_next_file called 355 returned 100% blocks executed 81%
      355: 1540:open_next_file(name, input)
        -: 1541:  const char *name;
        -: 1542:  struct input *input;
        -: 1543:{
      355: 1544:  input->base = NULL;
      355: 1545:  buffer.length = 0;
        -: 1546:
      355: 1547:  if (name[0] == '-' && name[1] == '\0')
branch  0 taken 1 (fallthrough)
branch  1 taken 354
branch  2 taken 1 (fallthrough)
branch  3 taken 0
        -: 1548:    {
        1: 1549:      clearerr(stdin);	/* clear any stale EOF indication */
call    0 returned 1
        1: 1550:      input->fp = stdin;
        -: 1551:    }
      354: 1552:  else if ( ! (input->fp = fopen(name, "r")) )
call    0 returned 354
branch  1 taken 1 (fallthrough)
branch  2 taken 353
        -: 1553:    {
        1: 1554:      const char *ptr = strerror(errno);
call    0 returned 1
        1: 1555:      fprintf(stderr, "%s: can't read %s: %s\n", myname, name, ptr);
call    0 returned 1
        1: 1556:      input->read_fn = read_always_fail; /* a redundancy */
        1: 1557:      ++input->bad_count;
        1: 1558:      return;
        -: 1559:    }
        -: 1560:
      354: 1561:  input->read_fn = read_file_line;
      354: 1562:  if (map_file(input->fp, &input->base, &input->length))
call    0 returned 354
branch  1 taken 354 (fallthrough)
branch  2 taken 0
        -: 1563:    {
      354: 1564:      input->cur = VCAST(char *)input->base;
      354: 1565:      input->left = input->length;
      354: 1566:      input->read_fn = read_mem_line;
        -: 1567:    }
        -: 1568:#ifdef HAVE_ISATTY
        -: 1569:  else
    #####: 1570:    input->is_tty = isatty(fileno(input->fp));
call    0 never executed
call    1 never executed
        -: 1571:#endif
        -: 1572:}
        -: 1573:
        -: 1574:/* Clean up an input stream that we are done with. */
        -: 1575:static void
function closedown called 1043 returned 100% blocks executed 100%
     1043: 1576:closedown(input)
        -: 1577:  struct input *input;
        -: 1578:{
     1043: 1579:  input->read_fn = read_always_fail;
     1043: 1580:  if (!input->fp)
branch  0 taken 689 (fallthrough)
branch  1 taken 354
      689: 1581:    return;
      354: 1582:  if (input->base)
branch  0 taken 354 (fallthrough)
branch  1 taken 0
      354: 1583:    unmap_file(input->base, input->length);
call    0 returned 354
      354: 1584:  if (input->fp != stdin) /* stdin can be reused on tty and tape devices */
branch  0 taken 353 (fallthrough)
branch  1 taken 1
      353: 1585:    ck_fclose(input->fp);
call    0 returned 353
      354: 1586:  input->fp = NULL;
        -: 1587:}
        -: 1588:
        -: 1589:/* dummy function to simplify read_pattern_space() */
        -: 1590:static flagT
function read_always_fail called 364 returned 100% blocks executed 100%
      364: 1591:read_always_fail(input)
        -: 1592:  struct input *input UNUSED;
        -: 1593:{
      364: 1594:  return 0;
        -: 1595:}
        -: 1596:
        -: 1597:/* The quick-and-easy mmap()'d case... */
        -: 1598:static flagT
function read_mem_line called 37904 returned 100% blocks executed 91%
    37904: 1599:read_mem_line(input)
        -: 1600:  struct input *input;
        -: 1601:{
        -: 1602:  const char *e;
        -: 1603:  size_t l;
        -: 1604:
    37904: 1605:  if ( (e = memchr(input->cur, '\n', input->left)) )
branch  0 taken 37586 (fallthrough)
branch  1 taken 318
        -: 1606:    {
        -: 1607:      /* common case */
    37586: 1608:      l = e++ - input->cur;
    37586: 1609:      line.chomped = 1;
        -: 1610:    }
        -: 1611:  else
        -: 1612:    {
        -: 1613:      /* This test is placed _after_ the memchr() fails for performance
        -: 1614:	 reasons (because this branch is the uncommon case and the
        -: 1615:	 memchr() will safely fail if input->left == 0).  Okay, so the
        -: 1616:	 savings is trivial.  I'm doing it anyway. */
      318: 1617:      if (input->left == 0)
branch  0 taken 316 (fallthrough)
branch  1 taken 2
      316: 1618:	return 0;
        2: 1619:      e = input->cur + input->left;
        2: 1620:      l = input->left;
        2: 1621:      if (*input->file_list || POSIXLY_CORRECT)
branch  0 taken 2 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 2
    #####: 1622:	line.chomped = 1;
        -: 1623:    }
        -: 1624:
    37588: 1625:  if (line.alloc - line.length < l)
branch  0 taken 367 (fallthrough)
branch  1 taken 37221
      367: 1626:    resize_line(&line, l);
call    0 returned 367
    37588: 1627:  memcpy(line.text + line.length, input->cur, l);
    37588: 1628:  line.length += l;
    37588: 1629:  input->left -= e - input->cur;
    37588: 1630:  input->cur = e;
    37588: 1631:  return 1;
        -: 1632:}
        -: 1633:
        -: 1634:#ifdef HAVE_ISATTY
        -: 1635:/* fgets() doesn't let us handle NULs and fread() buffers too much
        -: 1636: * for interactive use.
        -: 1637: */
        -: 1638:static size_t
function slow_getline called 0 returned 0% blocks executed 0%
    #####: 1639:slow_getline(buf, buflen, in)
        -: 1640:  char *buf;
        -: 1641:  size_t buflen;
        -: 1642:  FILE *in;
        -: 1643:{
    #####: 1644:  size_t resultlen = 0;
        -: 1645:  int c;
        -: 1646:
    #####: 1647:  while (resultlen<buflen && (c=getc(in))!=EOF)
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 1648:    {
    #####: 1649:      ++resultlen;
    #####: 1650:      *buf++ = c;
    #####: 1651:      if (c == '\n')
branch  0 never executed
branch  1 never executed
    #####: 1652:	break;
        -: 1653:    }
    #####: 1654:  if (ferror(in))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1655:    panic("input read error: %s", strerror(errno));
call    0 never executed
call    1 never executed
    #####: 1656:  return resultlen;
        -: 1657:}
        -: 1658:#endif /*HAVE_ISATTY*/
        -: 1659:
        -: 1660:static flagT
function read_file_line called 0 returned 0% blocks executed 0%
    #####: 1661:read_file_line(input)
        -: 1662:  struct input *input;
        -: 1663:{
        -: 1664:  char *b;
        -: 1665:  size_t blen;
    #####: 1666:  size_t initial_length = line.length;
        -: 1667:
    #####: 1668:  if (!buffer.active)
branch  0 never executed
branch  1 never executed
    #####: 1669:    buffer.active = buffer.text;
    #####: 1670:  while (!(b = memchr(buffer.active, '\n', buffer.length)))
branch  0 never executed
branch  1 never executed
        -: 1671:    {
    #####: 1672:      if (line.alloc-line.length < buffer.length)
branch  0 never executed
branch  1 never executed
    #####: 1673:	resize_line(&line, buffer.length);
call    0 never executed
    #####: 1674:      memcpy(line.text+line.length, buffer.active, buffer.length);
    #####: 1675:      line.length += buffer.length;
    #####: 1676:      buffer.length = 0;
    #####: 1677:      if (!feof(input->fp))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1678:	{
        -: 1679:#ifdef HAVE_ISATTY
    #####: 1680:	  if (input->is_tty)
branch  0 never executed
branch  1 never executed
    #####: 1681:	    buffer.length = slow_getline(buffer.text, buffer.alloc, input->fp);
call    0 never executed
        -: 1682:	  else
        -: 1683:#endif
    #####: 1684:	    buffer.length = ck_fread(buffer.text, 1, buffer.alloc, input->fp);
call    0 never executed
        -: 1685:	}
        -: 1686:
    #####: 1687:      if (buffer.length == 0)
branch  0 never executed
branch  1 never executed
        -: 1688:	{
    #####: 1689:	  if (*input->file_list || POSIXLY_CORRECT)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1690:	    line.chomped = 1;
        -: 1691:	  /* Did we hit EOF without reading anything?  If so, try
        -: 1692:	     the next file; otherwise just go with what we did get. */
    #####: 1693:	  return (line.length > initial_length);
        -: 1694:	}
    #####: 1695:      buffer.active = buffer.text;
        -: 1696:    }
        -: 1697:
    #####: 1698:  blen = b - buffer.active;
    #####: 1699:  if (line.alloc-line.length < blen)
branch  0 never executed
branch  1 never executed
    #####: 1700:    resize_line(&line, blen);
call    0 never executed
    #####: 1701:  memcpy(line.text+line.length, buffer.active, blen);
    #####: 1702:  line.length += blen;
    #####: 1703:  ++blen;
    #####: 1704:  line.chomped = 1;
    #####: 1705:  buffer.active += blen;
    #####: 1706:  buffer.length -= blen;
    #####: 1707:  return 1;
        -: 1708:}
        -: 1709:
        -: 1710:/* Read in the next line of input, and store it in the pattern space.
        -: 1711:   Return zero if there is nothing left to input. */
        -: 1712:static flagT
function read_pattern_space called 37913 returned 100% blocks executed 100%
    37913: 1713:read_pattern_space(input, append)
        -: 1714:  struct input *input;
        -: 1715:  flagT append;
        -: 1716:{
    37913: 1717:  dump_append_queue();
call    0 returned 37913
    37913: 1718:  replaced = 0;
    37913: 1719:  line.chomped = 0;
    37913: 1720:  if (!append)
branch  0 taken 35014 (fallthrough)
branch  1 taken 2899
    35014: 1721:    line.length = 0;
        -: 1722:
    38268: 1723:  while ( ! (*input->read_fn)(input) )
call    0 returned 38268
branch  1 taken 680
branch  2 taken 37588 (fallthrough)
        -: 1724:    {
      680: 1725:      closedown(input);
call    0 returned 680
      680: 1726:      if (!*input->file_list)
branch  0 taken 325 (fallthrough)
branch  1 taken 355
      325: 1727:	return 0;
      355: 1728:      open_next_file(*input->file_list++, input);
call    0 returned 355
        -: 1729:    }
        -: 1730:
    37588: 1731:  ++input->line_number;
    37588: 1732:  return 1;
        -: 1733:}
        -: 1734:
        -: 1735:static flagT
function last_file_with_data_p called 9 returned 100% blocks executed 29%
        9: 1736:last_file_with_data_p(input)
        -: 1737:  struct input *input;
        -: 1738:{
        -: 1739:  /*XXX reference implementation is equivalent to:
        -: 1740:      return !*input->file_list;
        -: 1741:   */
        -: 1742:  for (;;)
    #####: 1743:    {
        -: 1744:      int ch;
        -: 1745:
        9: 1746:      closedown(input);
call    0 returned 9
        9: 1747:      if (!*input->file_list)
branch  0 taken 9 (fallthrough)
branch  1 taken 0
        9: 1748:	return 1;
    #####: 1749:      open_next_file(*input->file_list++, input);
call    0 never executed
    #####: 1750:      if (input->fp)
branch  0 never executed
branch  1 never executed
        -: 1751:	{
    #####: 1752:	  if (input->base)
branch  0 never executed
branch  1 never executed
        -: 1753:	    {
    #####: 1754:	      if (0 < input->left)
branch  0 never executed
branch  1 never executed
    #####: 1755:		return 0;
        -: 1756:	    }
    #####: 1757:	  else if ((ch = getc(input->fp)) != EOF)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1758:	    {
    #####: 1759:	      ungetc(ch, input->fp);
call    0 never executed
    #####: 1760:	      return 0;
        -: 1761:	    }
        -: 1762:	}
        -: 1763:    }
        -: 1764:}
        -: 1765:
        -: 1766:/* Determine if we match the '$' address.  */
        -: 1767:static flagT
function test_dollar_EOF called 737 returned 100% blocks executed 43%
      737: 1768:test_dollar_EOF(input)
        -: 1769:  struct input *input;
        -: 1770:{
        -: 1771:  int ch;
        -: 1772:
      737: 1773:  if (buffer.length)
branch  0 taken 0 (fallthrough)
branch  1 taken 737
    #####: 1774:    return 0;
      737: 1775:  if (!input->fp)
branch  0 taken 0 (fallthrough)
branch  1 taken 737
    #####: 1776:    return last_file_with_data_p(input);
call    0 never executed
      737: 1777:  if (input->base)
branch  0 taken 737 (fallthrough)
branch  1 taken 0
      737: 1778:    return (input->left==0 && last_file_with_data_p(input));
branch  0 taken 9 (fallthrough)
branch  1 taken 728
call    2 returned 9
branch  3 taken 9 (fallthrough)
branch  4 taken 0
    #####: 1779:  if (feof(input->fp))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1780:    return last_file_with_data_p(input);
call    0 never executed
    #####: 1781:  if ((ch = getc(input->fp)) == EOF)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1782:    return last_file_with_data_p(input);
call    0 never executed
    #####: 1783:  ungetc(ch, input->fp);
call    0 never executed
    #####: 1784:  return 0;
        -: 1785:}
        -: 1786:
        -: 1787:/* Append a NUL char after the end of DEST, without resizing DEST.
        -: 1788:   This is to permit the use of regexp routines which expect C strings
        -: 1789:   instead of counted strings.
        -: 1790: */
        -: 1791:static void
function nul_append called 44576 returned 100% blocks executed 100%
    44576: 1792:nul_append(dest)
        -: 1793:  struct line *dest;
        -: 1794:{
        -: 1795:#ifndef HAVE_REGNEXEC
        -: 1796:  if (dest->alloc - dest->length < 1)
        -: 1797:    resize_line(dest, 1);
        -: 1798:  dest->text[dest->length] = '\0';
        -: 1799:#endif
    44576: 1800:}
        -: 1801:
        -: 1802:/* Return non-zero if the current line matches the address
        -: 1803:   pointed to by 'addr'.  */
        -: 1804:static flagT
function match_an_address_p called 71000 returned 100% blocks executed 59%
    71000: 1805:match_an_address_p(addr, input, is_addr2_p)
        -: 1806:  struct addr *addr;
        -: 1807:  struct input *input;
        -: 1808:  flagT is_addr2_p;
        -: 1809:{
    71000: 1810:  switch (addr->addr_type)
branch  0 taken 34888
branch  1 taken 3479
branch  2 taken 0
branch  3 taken 737
branch  4 taken 31896
branch  5 taken 0
        -: 1811:    {
    34888: 1812:    case addr_is_null:
    34888: 1813:      return 1;
     3479: 1814:    case addr_is_num:
     3479: 1815:      if (is_addr2_p)
branch  0 taken 305 (fallthrough)
branch  1 taken 3174
      305: 1816:	return (input->line_number >= addr->a.addr_number);
     3174: 1817:      return (input->line_number == addr->a.addr_number);
    #####: 1818:    case addr_is_mod:
    #####: 1819:      if (addr->a.m.offset < addr->a.m.modulo)
branch  0 never executed
branch  1 never executed
    #####: 1820:	return (input->line_number%addr->a.m.modulo == addr->a.m.offset);
        -: 1821:      /* offset >= modulo implies we have an extra initial skip */
    #####: 1822:      if (input->line_number < addr->a.m.offset)
branch  0 never executed
branch  1 never executed
    #####: 1823:	return 0;
        -: 1824:      /* normalize */
    #####: 1825:      addr->a.m.offset %= addr->a.m.modulo;
    #####: 1826:      return 1;
      737: 1827:    case addr_is_last:
      737: 1828:      return test_dollar_EOF(input);
call    0 returned 737
    31896: 1829:    case addr_is_regex:
    31896: 1830:      nul_append(&line);
call    0 returned 31896
    31896: 1831:      return !regnexec(addr->a.addr_regex,
    31896: 1832:			line.text, line.length, 0, NULL, 0);
call    0 returned 31896
    #####: 1833:    default:
    #####: 1834:      panic("INTERNAL ERROR: bad address type");
call    0 never executed
        -: 1835:    }
        -: 1836:  /*NOTREACHED*/
    #####: 1837:  return 0;
        -: 1838:}
        -: 1839:
        -: 1840:/* return non-zero if current address is valid for cmd */
        -: 1841:static flagT
function match_address_p called 70980 returned 100% blocks executed 100%
    70980: 1842:match_address_p(cmd, input)
        -: 1843:  struct sed_cmd *cmd;
        -: 1844:  struct input *input;
        -: 1845:{
    70980: 1846:  flagT addr_matched = cmd->a1_matched;
        -: 1847:
    70980: 1848:  if (addr_matched)
branch  0 taken 1582 (fallthrough)
branch  1 taken 69398
        -: 1849:    {
     1582: 1850:      if (match_an_address_p(&cmd->a2, input, 1))
call    0 returned 1582
branch  1 taken 45 (fallthrough)
branch  2 taken 1537
       45: 1851:	cmd->a1_matched = 0;
        -: 1852:    }
    69398: 1853:  else if (match_an_address_p(&cmd->a1, input, 0))
call    0 returned 69398
branch  1 taken 37196 (fallthrough)
branch  2 taken 32202
        -: 1854:    {
    37196: 1855:      addr_matched = 1;
    37196: 1856:      if (cmd->a2.addr_type != addr_is_null)
branch  0 taken 60 (fallthrough)
branch  1 taken 37136
       60: 1857:	if (   (cmd->a2.addr_type == addr_is_regex)
branch  0 taken 20 (fallthrough)
branch  1 taken 40
       20: 1858:	    || !match_an_address_p(&cmd->a2, input, 1))
call    0 returned 20
branch  1 taken 19 (fallthrough)
branch  2 taken 1
       59: 1859:	  cmd->a1_matched = 1;
        -: 1860:    }
    70980: 1861:  if (cmd->addr_bang)
branch  0 taken 2112 (fallthrough)
branch  1 taken 68868
     2112: 1862:    addr_matched = !addr_matched;
    70980: 1863:  return addr_matched;
        -: 1864:}
        -: 1865:
        -: 1866:static void
function do_list called 838 returned 100% blocks executed 71%
      838: 1867:do_list()
        -: 1868:{
      838: 1869:  unsigned char *p = CAST(unsigned char *)line.text;
      838: 1870:  countT len = line.length;
      838: 1871:  countT width = 0;
        -: 1872:  char obuf[180];	/* just in case we encounter a 512-bit char ;-) */
        -: 1873:  char *o;
        -: 1874:  size_t olen;
        -: 1875:
    17386: 1876:  for (; len--; ++p) {
branch  0 taken 16548
branch  1 taken 838 (fallthrough)
    16548: 1877:      o = obuf;
    16548: 1878:      if (ISPRINT(*p)) {
branch  0 taken 16089 (fallthrough)
branch  1 taken 459
    16089: 1879:	  *o++ = *p;
    16089: 1880:	  if (*p == '\\')
branch  0 taken 0 (fallthrough)
branch  1 taken 16089
    #####: 1881:	    *o++ = '\\';
        -: 1882:      } else {
      459: 1883:	  *o++ = '\\';
      459: 1884:	  switch (*p) {
branch  0 taken 0
branch  1 taken 0
branch  2 taken 0
branch  3 taken 233
branch  4 taken 0
branch  5 taken 136
branch  6 taken 0
branch  7 taken 90
        -: 1885:#if defined __STDC__ && __STDC__
    #####: 1886:	    case '\a': *o++ = 'a'; break;
        -: 1887:#else
        -: 1888:	    /* If not STDC we'll just assume ASCII */
        -: 1889:	    case 007:  *o++ = 'a'; break;
        -: 1890:#endif
    #####: 1891:	    case '\b': *o++ = 'b'; break;
    #####: 1892:	    case '\f': *o++ = 'f'; break;
      233: 1893:	    case '\n': *o++ = 'n'; break;
    #####: 1894:	    case '\r': *o++ = 'r'; break;
      136: 1895:	    case '\t': *o++ = 't'; break;
    #####: 1896:	    case '\v': *o++ = 'v'; break;
       90: 1897:	    default:
       90: 1898:	      sprintf(o, "%03o", *p);
       90: 1899:	      o += strlen(o);
       90: 1900:	      break;
        -: 1901:	    }
        -: 1902:      }
    16548: 1903:      olen = o - obuf;
    16548: 1904:      if (width+olen >= LCMD_OUT_LINE_LEN) {
branch  0 taken 3 (fallthrough)
branch  1 taken 16545
        3: 1905:	  ck_fwrite("\\\n", 1, 2, stdout);
call    0 returned 3
        3: 1906:	  width = 0;
        -: 1907:      }
    16548: 1908:      ck_fwrite(obuf, 1, olen, stdout);
call    0 returned 16548
    16548: 1909:      width += olen;
        -: 1910:  }
      838: 1911:  ck_fwrite("$\n", 1, 2, stdout);
call    0 returned 838
      838: 1912:}
        -: 1913:
        -: 1914:static void
function do_subst called 12680 returned 100% blocks executed 85%
    12680: 1915:do_subst(sub)
        -: 1916:  struct subst *sub;
        -: 1917:{
        -: 1918:  /* s_accum will accumulate the result of the s command. */
        -: 1919:  /* static so as to keep malloc() calls down */
        -: 1920:  static struct line s_accum;
        -: 1921:
        -: 1922:  size_t start;		/* where to start scan for match in LINE */
        -: 1923:  size_t offset;	/* where in LINE a match was found */
        -: 1924:  size_t remain;	/* length after START, sans trailing newline */
        -: 1925:  countT count;		/* number of matches found */
        -: 1926:  char *rep;		/* the replacement string */
        -: 1927:  char *rep_end;	/* end of the replacement string */
        -: 1928:  flagT not_bol_p;
        -: 1929:  flagT did_subst;
        -: 1930:  regmatch_t regs[10];
        -: 1931:
    12680: 1932:  if (s_accum.alloc == 0)
branch  0 taken 180 (fallthrough)
branch  1 taken 12500
      180: 1933:    line_init(&s_accum, INITIAL_BUFFER_SIZE);
call    0 returned 180
    12680: 1934:  s_accum.length = 0;
        -: 1935:
    12680: 1936:  count = 0;
    12680: 1937:  did_subst = 0;
    12680: 1938:  not_bol_p = 0;
    12680: 1939:  start = 0;
    12680: 1940:  remain = line.length - start;
    12680: 1941:  rep = sub->replacement;
    12680: 1942:  rep_end = rep + sub->replace_length;
        -: 1943:
    12680: 1944:  nul_append(&line);
call    0 returned 12680
    27201: 1945:  while ( ! regnexec(sub->regx,
branch  0 taken 3491
branch  1 taken 11030 (fallthrough)
    14521: 1946:		     line.text + start, remain,
call    0 returned 14521
        -: 1947:		     sizeof(regs) / sizeof(regs[0]), regs, not_bol_p) )
        -: 1948:    {
     3491: 1949:      ++count;
     3491: 1950:      offset = regs[0].rm_so + start;
        -: 1951:
        -: 1952:      /*
        -: 1953:       *  +- line.text   +-[offset]
        -: 1954:       *  V              V
        -: 1955:       * "blah blah blah xyzzy blah blah blah blah"
        -: 1956:       *       ^             ^                    ^
        -: 1957:       *       +-[start]     +-[end]              +-[start + remain]
        -: 1958:       *
        -: 1959:       *
        -: 1960:       * regs[0].rm_so == offset - start
        -: 1961:       * regs[0].rm_eo == end - start
        -: 1962:       */
        -: 1963:
        -: 1964:      /* Copy stuff to the left of the next match into the output
        -: 1965:       * string.
        -: 1966:       */
     3491: 1967:      if (start < offset)
branch  0 taken 964 (fallthrough)
branch  1 taken 2527
      964: 1968:	str_append(&s_accum, line.text + start, offset - start);
call    0 returned 964
        -: 1969:
        -: 1970:      /* If we're counting up to the Nth match, are we there yet? */
     3491: 1971:      if (count < sub->numb)
branch  0 taken 0 (fallthrough)
branch  1 taken 3491
    #####: 1972:	{
        -: 1973:	  /* Not there yet...so skip this match. */
    #####: 1974:	  size_t matched = regs[0].rm_eo - regs[0].rm_so;
        -: 1975:
        -: 1976:	  /* If the match was vacuous, skip ahead one character
        -: 1977:	   * anyway.   It isn't at all obvious to me that this is
        -: 1978:	   * the right behavior for this case.    -t	XXX
        -: 1979:	   */
    #####: 1980:	  if (matched == 0 && offset < line.length)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1981:	    matched = 1;
    #####: 1982:	  str_append(&s_accum, line.text + offset, matched);
call    0 never executed
    #####: 1983:	  start = offset + matched;
    #####: 1984:	  remain = line.length - start;
    #####: 1985:	  not_bol_p = 1;
    #####: 1986:	  continue;
        -: 1987:	}
        -: 1988:
        -: 1989:      /* Expand the replacement string into the output string. */
        -: 1990:      {
        -: 1991:	char *rep_cur;	/* next burst being processed in replacement */
        -: 1992:	char *rep_next;	/* end of burst in replacement */
        -: 1993:
        -: 1994:	/* Replacement strings can be viewed as a sequence of variable
        -: 1995:	 * length commands.  A command can be a literal string or a
        -: 1996:	 * backreference (either numeric or "&").
        -: 1997:	 *
        -: 1998:	 * This loop measures off the next command between
        -: 1999:	 * REP_CUR and REP_NEXT, handles that command, and loops.
        -: 2000:	 */
     3491: 2001:	for (rep_next = rep_cur = rep;
    22252: 2002:	     rep_next < rep_end;
branch  0 taken 18761
branch  1 taken 3491 (fallthrough)
    18761: 2003:	     rep_next++)
        -: 2004:	  {
    18761: 2005:	    if (*rep_next == '\\')
branch  0 taken 1480 (fallthrough)
branch  1 taken 17281
        -: 2006:	      {
        -: 2007:		/* Preceding the backslash may be some literal
        -: 2008:		 * text:
        -: 2009:		 */
     1480: 2010:		if (rep_cur < rep_next)
branch  0 taken 605 (fallthrough)
branch  1 taken 875
      605: 2011:		  str_append(&s_accum, rep_cur,
      605: 2012:			     CAST(size_t)(rep_next - rep_cur));
call    0 returned 605
        -: 2013:
        -: 2014:		/* Skip the backslash itself and look for
        -: 2015:		 * a numeric back-reference:
        -: 2016:		 */
     1480: 2017:		rep_next++;
     1480: 2018:		if (rep_next < rep_end
branch  0 taken 1480 (fallthrough)
branch  1 taken 0
     1480: 2019:		    && '0' <= *rep_next && *rep_next <= '9')
branch  0 taken 2 (fallthrough)
branch  1 taken 1478
branch  2 taken 0 (fallthrough)
branch  3 taken 2
    #####: 2020:		  {
    #####: 2021:		    int i = *rep_next - '0';
    #####: 2022:		    str_append(&s_accum, line.text + start + regs[i].rm_so,
    #####: 2023:			       CAST(size_t)(regs[i].rm_eo-regs[i].rm_so));
call    0 never executed
        -: 2024:		  }
        -: 2025:		else
     1480: 2026:		  str_append(&s_accum, rep_next, 1);
call    0 returned 1480
     1480: 2027:		rep_cur = rep_next + 1;
        -: 2028:	      }
    17281: 2029:	    else if (*rep_next == '&')
branch  0 taken 23 (fallthrough)
branch  1 taken 17258
        -: 2030:	      {
        -: 2031:		/* Preceding the ampersand may be some literal
        -: 2032:		 * text:
        -: 2033:		 */
       23: 2034:		if (rep_cur < rep_next)
branch  0 taken 10 (fallthrough)
branch  1 taken 13
       10: 2035:		  str_append(&s_accum, rep_cur,
       10: 2036:			     CAST(size_t)(rep_next - rep_cur));
call    0 returned 10
       23: 2037:		str_append(&s_accum, line.text + start + regs[0].rm_so,
       23: 2038:			   CAST(size_t)(regs[0].rm_eo - regs[0].rm_so));
call    0 returned 23
       23: 2039:		rep_cur = rep_next + 1;
        -: 2040:	      }
        -: 2041:	  }
        -: 2042:
        -: 2043:	/* There may be a trailing literal in the replacement string. */
     3491: 2044:	if (rep_cur < rep_next)
branch  0 taken 2044 (fallthrough)
branch  1 taken 1447
     2044: 2045:	  str_append(&s_accum, rep_cur, CAST(size_t)(rep_next - rep_cur));
call    0 returned 2044
        -: 2046:      }
        -: 2047:
     3491: 2048:      did_subst = 1;
     3491: 2049:      not_bol_p = 1;
     3491: 2050:      start += regs[0].rm_eo;
     3491: 2051:      remain = line.length - start;
     3491: 2052:      if (!sub->global || remain == 0)
branch  0 taken 3312 (fallthrough)
branch  1 taken 179
branch  2 taken 1841 (fallthrough)
branch  3 taken 1471
        -: 2053:	break;
        -: 2054:
        -: 2055:      /* If the match was vacuous, skip over one character
        -: 2056:       * and add that character to the output.
        -: 2057:       */
     1841: 2058:      if (regs[0].rm_so == regs[0].rm_eo)
branch  0 taken 484 (fallthrough)
branch  1 taken 1357
        -: 2059:	{
      484: 2060:	  str_append(&s_accum, line.text + offset, 1);
call    0 returned 484
      484: 2061:	  ++start;
      484: 2062:	  --remain;
        -: 2063:	}
        -: 2064:    }
        -: 2065:
    12680: 2066:  if (did_subst)
branch  0 taken 2496 (fallthrough)
branch  1 taken 10184
        -: 2067:    {
        -: 2068:      struct line tmp;
     2496: 2069:      if (start < line.length)
branch  0 taken 884 (fallthrough)
branch  1 taken 1612
      884: 2070:	str_append(&s_accum, line.text + start, remain);
call    0 returned 884
     2496: 2071:      memcpy(VCAST(VOID *)&tmp, VCAST(VOID *)&line, sizeof line);
     2496: 2072:      memcpy(VCAST(VOID *)&line, VCAST(VOID *)&s_accum, sizeof line);
     2496: 2073:      line.chomped = tmp.chomped;
     2496: 2074:      memcpy(VCAST(VOID *)&s_accum, VCAST(VOID *)&tmp, sizeof line);
     2496: 2075:      if (sub->wfile)
branch  0 taken 1436 (fallthrough)
branch  1 taken 1060
     1436: 2076:	output_line(line.text, line.length, line.chomped, sub->wfile);
call    0 returned 1436
     2496: 2077:      if (sub->print)
branch  0 taken 1287 (fallthrough)
branch  1 taken 1209
     1287: 2078:	output_line(line.text, line.length, line.chomped, stdout);
call    0 returned 1287
     2496: 2079:      replaced = 1;
        -: 2080:    }
    12680: 2081:}
        -: 2082:
        -: 2083:/* Execute the program 'vec' on the current input line.
        -: 2084:   Return non-zero if caller should quit, 0 otherwise.  */
        -: 2085:static flagT
function execute_program called 31909 returned 100% blocks executed 98%
    31909: 2086:execute_program(vec, input)
        -: 2087:  struct vector *vec;
        -: 2088:  struct input *input;
        -: 2089:{
        -: 2090:  struct vector *cur_vec;
        -: 2091:  struct sed_cmd *cur_cmd;
        -: 2092:  size_t n;
        -: 2093:
    31909: 2094:  cur_vec = vec;
    31909: 2095:  cur_cmd = cur_vec->v;
    31909: 2096:  n = cur_vec->v_length;
    97977: 2097:  while (n)
branch  0 taken 70980
branch  1 taken 26997 (fallthrough)
        -: 2098:    {
    70980: 2099:      if (match_address_p(cur_cmd, input))
call    0 returned 70980
branch  1 taken 40726 (fallthrough)
branch  2 taken 30254
        -: 2100:	{
    40726: 2101:	  switch (cur_cmd->cmd)
branch  0 taken 4442
branch  1 taken 1264
branch  2 taken 546
branch  3 taken 119
branch  4 taken 2495
branch  5 taken 1624
branch  6 taken 1381
branch  7 taken 10
branch  8 taken 10
branch  9 taken 18
branch 10 taken 12
branch 11 taken 391
branch 12 taken 838
branch 13 taken 2798
branch 14 taken 2899
branch 15 taken 2054
branch 16 taken 2357
branch 17 taken 29
branch 18 taken 98
branch 19 taken 12680
branch 20 taken 13
branch 21 taken 1689
branch 22 taken 5
branch 23 taken 2348
branch 24 taken 378
branch 25 taken 228
branch 26 taken 0
        -: 2102:	    {
     4442: 2103:	    case '{':		/* Execute sub-program */
     4442: 2104:	      if (cur_cmd->x.sub->v_length)
branch  0 taken 4442 (fallthrough)
branch  1 taken 0
        -: 2105:		{
     4442: 2106:		  cur_vec = cur_cmd->x.sub;
     4442: 2107:		  cur_cmd = cur_vec->v;
     4442: 2108:		  n = cur_vec->v_length;
     4442: 2109:		  continue;
        -: 2110:		}
    #####: 2111:	      break;
        -: 2112:
     1264: 2113:	    case '}':
        -: 2114:	      {
     1264: 2115:		countT i = cur_vec->return_i;
     1264: 2116:		cur_vec = cur_vec->return_v;
     1264: 2117:		cur_cmd = cur_vec->v + i;
     1264: 2118:		n = cur_vec->v_length - i;
        -: 2119:	      }
     1264: 2120:	      continue;
        -: 2121:
      546: 2122:	    case 'a':
        -: 2123:	      {
      546: 2124:		struct append_queue *aq = next_append_slot();
call    0 returned 546
      546: 2125:		aq->text = cur_cmd->x.cmd_txt.text;
      546: 2126:		aq->textlen = cur_cmd->x.cmd_txt.text_len;
        -: 2127:	      }
      546: 2128:	      break;
        -: 2129:
      119: 2130:	    case 'b':
      119: 2131:	      if (cur_cmd->x.jump)
branch  0 taken 42 (fallthrough)
branch  1 taken 77
       42: 2132:		{
       42: 2133:		  struct sed_label *j = cur_cmd->x.jump;
       42: 2134:		  countT i = j->v_index;
       42: 2135:		  cur_vec = j->v;
       42: 2136:		  cur_cmd = cur_vec->v + i;
       42: 2137:		  n = cur_vec->v_length - i;
       42: 2138:		  continue;
        -: 2139:		}
       77: 2140:	      return 0;
        -: 2141:
     2495: 2142:	    case 'c':
     2495: 2143:	      line.length = 0;
     2495: 2144:	      line.chomped = 0;
     2495: 2145:	      if (!cur_cmd->a1_matched)
branch  0 taken 1727 (fallthrough)
branch  1 taken 768
     1727: 2146:		output_line(cur_cmd->x.cmd_txt.text,
call    0 returned 1727
        -: 2147:			    cur_cmd->x.cmd_txt.text_len, 0, stdout);
        -: 2148:	      /* POSIX.2 is silent about c starting a new cycle,
        -: 2149:		 but it seems to be expected (and make sense). */
     2495: 2150:	      return 0;
        -: 2151:
     1624: 2152:	    case 'd':
     1624: 2153:	      line.length = 0;
     1624: 2154:	      line.chomped = 0;
     1624: 2155:	      return 0;
        -: 2156:
     1381: 2157:	    case 'D':
      717: 2158:	      {
     1381: 2159:		char *p = memchr(line.text, '\n', line.length);
     1381: 2160:		if (!p)
branch  0 taken 664 (fallthrough)
branch  1 taken 717
        -: 2161:		  {
      664: 2162:		    line.length = 0;
      664: 2163:		    line.chomped = 0;
      664: 2164:		    return 0;
        -: 2165:		  }
      717: 2166:		++p;
      717: 2167:		memmove(line.text, p, line.length);
      717: 2168:		line.length -= p - line.text;
        -: 2169:
        -: 2170:		/* reset to start next cycle without reading a new line: */
      717: 2171:		cur_vec = vec;
      717: 2172:		cur_cmd = cur_vec->v;
      717: 2173:		n = cur_vec->v_length;
      717: 2174:		continue;
        -: 2175:	      }
        -: 2176:
       10: 2177:	    case 'g':
       10: 2178:	      line_copy(&hold, &line);
call    0 returned 10
       10: 2179:	      break;
        -: 2180:
       10: 2181:	    case 'G':
       10: 2182:	      line_append(&hold, &line);
call    0 returned 10
       10: 2183:	      break;
        -: 2184:
       18: 2185:	    case 'h':
       18: 2186:	      line_copy(&line, &hold);
call    0 returned 18
       18: 2187:	      break;
        -: 2188:
       12: 2189:	    case 'H':
       12: 2190:	      line_append(&line, &hold);
call    0 returned 12
       12: 2191:	      break;
        -: 2192:
      391: 2193:	    case 'i':
      391: 2194:	      output_line(cur_cmd->x.cmd_txt.text,
call    0 returned 391
        -: 2195:			  cur_cmd->x.cmd_txt.text_len, 0, stdout);
      391: 2196:	      break;
        -: 2197:
      838: 2198:	    case 'l':
      838: 2199:	      do_list();
call    0 returned 838
      838: 2200:	      break;
        -: 2201:
     2798: 2202:	    case 'n':
     2798: 2203:	      if (!no_default_output)
branch  0 taken 783 (fallthrough)
branch  1 taken 2015
      783: 2204:		output_line(line.text, line.length, line.chomped, stdout);
call    0 returned 783
     2798: 2205:	      if (!read_pattern_space(input, 0))
call    0 returned 2798
branch  1 taken 8 (fallthrough)
branch  2 taken 2790
        8: 2206:		return 1;
     2790: 2207:	      break;
        -: 2208:
     2899: 2209:	    case 'N':
     2899: 2210:	      str_append(&line, "\n", 1);
call    0 returned 2899
     2899: 2211:	      if (!read_pattern_space(input, 1))
call    0 returned 2899
branch  1 taken 10 (fallthrough)
branch  2 taken 2889
       10: 2212:		return 1;
     2889: 2213:	      break;
        -: 2214:
     2054: 2215:	    case 'p':
     2054: 2216:	      output_line(line.text, line.length, line.chomped, stdout);
call    0 returned 2054
     2054: 2217:	      break;
        -: 2218:
     2357: 2219:	    case 'P':
        -: 2220:	      {
     2357: 2221:		char *p = memchr(line.text, '\n', line.length);
     2357: 2222:		output_line(line.text, p ? p - line.text : line.length,
branch  0 taken 1559 (fallthrough)
branch  1 taken 798
branch  2 taken 798 (fallthrough)
branch  3 taken 1559
call    4 returned 2357
        -: 2223:			    p ? 1 : line.chomped, stdout);
        -: 2224:	      }
     2357: 2225:	      break;
        -: 2226:
       29: 2227:	    case 'q':
       29: 2228:	      return 1;
        -: 2229:
       98: 2230:	    case 'r':
       98: 2231:	      if (cur_cmd->x.rfile)
branch  0 taken 98 (fallthrough)
branch  1 taken 0
        -: 2232:		{
       98: 2233:		  struct append_queue *aq = next_append_slot();
call    0 returned 98
       98: 2234:		  aq->rfile = cur_cmd->x.rfile;
        -: 2235:		}
       98: 2236:	      break;
        -: 2237:
    12680: 2238:	    case 's':
    12680: 2239:	      do_subst(&cur_cmd->x.cmd_regex);
call    0 returned 12680
    12680: 2240:	      break;
        -: 2241:
       13: 2242:	    case 't':
       13: 2243:	      if (replaced)
branch  0 taken 6 (fallthrough)
branch  1 taken 7
        -: 2244:		{
        6: 2245:		  replaced = 0;
        6: 2246:		  if (cur_cmd->x.jump)
branch  0 taken 1 (fallthrough)
branch  1 taken 5
        1: 2247:		    {
        1: 2248:		      struct sed_label *j = cur_cmd->x.jump;
        1: 2249:		      countT i = j->v_index;
        1: 2250:		      cur_vec = j->v;
        1: 2251:		      cur_cmd = cur_vec->v + i;
        1: 2252:		      n = cur_vec->v_length - i;
        1: 2253:		      continue;
        -: 2254:		    }
        5: 2255:		  return 0;
        -: 2256:		}
        7: 2257:	      break;
        -: 2258:
     1689: 2259:	    case 'w':
     1689: 2260:	      if (cur_cmd->x.wfile)
branch  0 taken 1689 (fallthrough)
branch  1 taken 0
     1689: 2261:		output_line(line.text, line.length,
call    0 returned 1689
        -: 2262:			    line.chomped, cur_cmd->x.wfile);
     1689: 2263:	      break;
        -: 2264:
        5: 2265:	    case 'x':
        -: 2266:	      {
        -: 2267:		struct line temp;
        5: 2268:		memcpy(VCAST(VOID *)&temp, VCAST(VOID *)&line, sizeof line);
        5: 2269:		memcpy(VCAST(VOID *)&line, VCAST(VOID *)&hold, sizeof line);
        5: 2270:		memcpy(VCAST(VOID *)&hold, VCAST(VOID *)&temp, sizeof line);
        -: 2271:	      }
        5: 2272:	      break;
        -: 2273:
     2348: 2274:	    case 'y':
        -: 2275:	      {
        -: 2276:		unsigned char *p, *e;
     2348: 2277:		p = CAST(unsigned char *)line.text;
    44332: 2278:		for (e=p+line.length; p<e; ++p)
branch  0 taken 41984
branch  1 taken 2348 (fallthrough)
    41984: 2279:		  *p = cur_cmd->x.translate[*p];
        -: 2280:	      }
     2348: 2281:	      break;
        -: 2282:
      378: 2283:	    case ':':
        -: 2284:	      /* Executing labels is easy. */
      378: 2285:	      break;
        -: 2286:
      228: 2287:	    case '=':
      228: 2288:	      printf("%lu\n", CAST(unsigned long)input->line_number);
call    0 returned 228
      228: 2289:	      break;
        -: 2290:
    #####: 2291:	    default:
    #####: 2292:	      panic("INTERNAL ERROR: Bad cmd %c", cur_cmd->cmd);
call    0 never executed
        -: 2293:	    }
        -: 2294:	}
        -: 2295:#ifdef EXPERIMENTAL_DASH_N_OPTIMIZATION
        -: 2296:/* If our top-level program consists solely of commands with addr_is_num
        -: 2297: * address then once we past the last mentioned line we should be able
        -: 2298: * to quit if no_default_output is true, or otherwise quickly copy input
        -: 2299: * to output.  Now whether this optimization is a win or not depends
        -: 2300: * on how cheaply we can implement this for the cases where it doesn't
        -: 2301: * help, as compared against how much time is saved.
        -: 2302: * One semantic difference (which I think is an improvement) is
        -: 2303: * that *this* version will terminate after printing line two
        -: 2304: * in the script "yes | sed -n 2p".
        -: 2305: */
        -: 2306:      else
        -: 2307:	{
        -: 2308:	  /* can we ever match again? */
        -: 2309:	  if (cur_cmd->a1.addr_type == addr_is_num &&
        -: 2310:	      ((input->line_number < cur_cmd->a1.a.addr_number)
        -: 2311:		!= !cur_cmd->addr_bang))
        -: 2312:	    {
        -: 2313:	      /* skip all this next time */
        -: 2314:	      cur_cmd->a1.addr_type = addr_is_null;
        -: 2315:	      cur_cmd->addr_bang = 1;
        -: 2316:	      /* can we make an optimization? */
        -: 2317:	      if (cur_cmd->cmd == '{' || cur_cmd->cmd == '}'
        -: 2318:		    || cur_cmd->cmd == 'b' || cur_cmd->cmd == 't')
        -: 2319:		{
        -: 2320:		  if (cur_vec == vec)
        -: 2321:		    --branches_in_top_level;
        -: 2322:		  cur_cmd->cmd = ':';	/* replace with no-op */
        -: 2323:		}
        -: 2324:	      if (cur_vec == vec && branches_in_top_level == 0)
        -: 2325:		{
        -: 2326:		  /* whew!  all that just so that we can get to here! */
        -: 2327:		  countT new_n = n;
        -: 2328:		  cur_cmd = shrink_program(cur_vec, cur_cmd, &new_n);
        -: 2329:		  n = new_n;
        -: 2330:		  if (!cur_cmd && no_default_output)
        -: 2331:		    return 1;
        -: 2332:		  continue;
        -: 2333:		}
        -: 2334:	    }
        -: 2335:	}
        -: 2336:#endif /*EXPERIMENTAL_DASH_N_OPTIMIZATION*/
        -: 2337:
        -: 2338:      /* these are buried down here so that a "continue" statement
        -: 2339:	 can skip them */
    59602: 2340:      ++cur_cmd;
    59602: 2341:      --n;
        -: 2342:    }
    26997: 2343:    return 0;
        -: 2344:}
        -: 2345:
        -: 2346:static void
function output_line called 25072 returned 100% blocks executed 100%
    25072: 2347:output_line(text, length, nl, fp)
        -: 2348:  const char *text;
        -: 2349:  size_t length;
        -: 2350:  flagT nl;
        -: 2351:  FILE *fp;
        -: 2352:{
    25072: 2353:  ck_fwrite(text, 1, length, fp);
call    0 returned 25072
    25072: 2354:  if (nl)
branch  0 taken 20461 (fallthrough)
branch  1 taken 4611
    20461: 2355:    ck_fwrite("\n", 1, 1, fp);
call    0 returned 20461
    25072: 2356:  if (fp != stdout)
branch  0 taken 3125 (fallthrough)
branch  1 taken 21947
     3125: 2357:    ck_fflush(fp);
call    0 returned 3125
    25072: 2358:}
        -: 2359:
        -: 2360:
        -: 2361:/* initialize a "struct line" buffer */
        -: 2362:static void
function line_init called 1242 returned 100% blocks executed 100%
     1242: 2363:line_init(buf, initial_size)
        -: 2364:  struct line *buf;
        -: 2365:  size_t initial_size;
        -: 2366:{
     1242: 2367:  buf->text = MALLOC(initial_size, char);
call    0 returned 1242
     1242: 2368:  buf->active = NULL;
     1242: 2369:  buf->alloc = initial_size;
     1242: 2370:  buf->length = 0;
     1242: 2371:  buf->chomped = 1;
     1242: 2372:}
        -: 2373:
        -: 2374:/* Copy the contents of the line 'from' into the line 'to'.
        -: 2375:   This destroys the old contents of 'to'.  It will still work
        -: 2376:   if the line 'from' contains NULs. */
        -: 2377:static void
function line_copy called 28 returned 100% blocks executed 100%
       28: 2378:line_copy(from, to)
        -: 2379:  struct line *from;
        -: 2380:  struct line *to;
        -: 2381:{
       28: 2382:  if (to->alloc < from->length)
branch  0 taken 1 (fallthrough)
branch  1 taken 27
        -: 2383:    {
        1: 2384:      to->alloc = from->length;
        1: 2385:      to->text = REALLOC(to->text, to->alloc, char);
call    0 returned 1
        -: 2386:    }
       28: 2387:  memcpy(to->text, from->text, from->length);
       28: 2388:  to->length = from->length;
       28: 2389:  to->chomped = from->chomped;
       28: 2390:}
        -: 2391:
        -: 2392:/* Append 'length' bytes from 'string' to the line 'to'
        -: 2393:   This routine *will* append NUL bytes without failing.  */
        -: 2394:static void
function str_append called 9437 returned 100% blocks executed 100%
     9437: 2395:str_append(to, string, length)
        -: 2396:  struct line *to;
        -: 2397:  const char *string;
        -: 2398:  size_t length;
        -: 2399:{
     9437: 2400:  if (to->alloc - to->length < length)
branch  0 taken 24 (fallthrough)
branch  1 taken 9413
       24: 2401:    resize_line(to, length);
call    0 returned 24
     9437: 2402:  memcpy(to->text + to->length, string, length);
     9437: 2403:  to->length += length;
     9437: 2404:}
        -: 2405:
        -: 2406:/* Append the contents of the line 'from' to the line 'to'.
        -: 2407:   This routine will work even if the line 'from' contains nulls */
        -: 2408:static void
function line_append called 22 returned 100% blocks executed 100%
       22: 2409:line_append(from, to)
        -: 2410:  struct line *from;
        -: 2411:  struct line *to;
        -: 2412:{
       22: 2413:  str_append(to, "\n", 1);
call    0 returned 22
       22: 2414:  str_append(to, from->text, from->length);
call    0 returned 22
       22: 2415:  to->chomped = from->chomped;
       22: 2416:}
        -: 2417:
        -: 2418:
        -: 2419:
        -: 2420:static struct append_queue *
function next_append_slot called 644 returned 100% blocks executed 83%
      644: 2421:next_append_slot()
        -: 2422:{
      644: 2423:  struct append_queue *n = MALLOC(1, struct append_queue);
call    0 returned 644
        -: 2424:
      644: 2425:  n->rfile = NULL;
      644: 2426:  n->text = NULL;
      644: 2427:  n->textlen = 0;
      644: 2428:  n->next = NULL;
        -: 2429:
      644: 2430:  if (append_tail)
branch  0 taken 0 (fallthrough)
branch  1 taken 644
    #####: 2431:      append_tail->next = n;
        -: 2432:  else
      644: 2433:      append_head = n;
      644: 2434:  return append_tail = n;
        -: 2435:}
        -: 2436:
        -: 2437:static void
function dump_append_queue called 37913 returned 100% blocks executed 100%
    37913: 2438:dump_append_queue()
        -: 2439:{
        -: 2440:  struct append_queue *p, *q;
        -: 2441:
    38557: 2442:  for (p=append_head; p; p=q)
branch  0 taken 644
branch  1 taken 37913 (fallthrough)
        -: 2443:    {
      644: 2444:      if (p->text)
branch  0 taken 546 (fallthrough)
branch  1 taken 98
      546: 2445:	  output_line(p->text, p->textlen, 0, stdout);
call    0 returned 546
      644: 2446:      if (p->rfile)
branch  0 taken 98 (fallthrough)
branch  1 taken 546
        -: 2447:	{
        -: 2448:	  char buf[FREAD_BUFFER_SIZE];
        -: 2449:	  size_t cnt;
        -: 2450:	  FILE *fp;
        -: 2451:
       98: 2452:	  fp = fopen(p->rfile, "r");
call    0 returned 98
        -: 2453:	  /* Not ck_fopen() because: "If _rfile_ does not exist or cannot be
        -: 2454:	     read, it shall be treated as if it were an empty file, causing
        -: 2455:	     no error condition."  IEEE Std 1003.2-1992 */
       98: 2456:	  if (fp)
branch  0 taken 98 (fallthrough)
branch  1 taken 0
        -: 2457:	    {
      196: 2458:	      while ((cnt = ck_fread(buf, 1, sizeof buf, fp)) > 0)
call    0 returned 196
branch  1 taken 98
branch  2 taken 98 (fallthrough)
       98: 2459:		ck_fwrite(buf, 1, cnt, stdout);
call    0 returned 98
       98: 2460:	      fclose(fp);
call    0 returned 98
        -: 2461:	    }
        -: 2462:	}
      644: 2463:      q = p->next;
      644: 2464:      FREE(p);
call    0 returned 644
        -: 2465:    }
    37913: 2466:  append_head = append_tail = NULL;
    37913: 2467:}
        -: 2468:
        -: 2469:#ifdef EXPERIMENTAL_DASH_N_OPTIMIZATION
        -: 2470:static countT
        -: 2471:count_branches(program)
        -: 2472:  struct vector *program;
        -: 2473:{
        -: 2474:  struct sed_cmd *cur_cmd = program->v;
        -: 2475:  countT isn_cnt = program->v_length;
        -: 2476:  countT cnt = 0;
        -: 2477:
        -: 2478:  while (isn_cnt-- > 0)
        -: 2479:    {
        -: 2480:      switch (cur_cmd->cmd)
        -: 2481:	{
        -: 2482:	case '{':
        -: 2483:	case '}':
        -: 2484:	case 'b':
        -: 2485:	case 't':
        -: 2486:	  ++cnt;
        -: 2487:	}
        -: 2488:    }
        -: 2489:  return cnt;
        -: 2490:}
        -: 2491:
        -: 2492:static struct sed_cmd *
        -: 2493:shrink_program(vec, cur_cmd, n)
        -: 2494:  struct vector *vec;
        -: 2495:  struct sed_cmd *cur_cmd;
        -: 2496:  countT *n;
        -: 2497:{
        -: 2498:  struct sed_cmd *v = vec->v;
        -: 2499:  struct sed_cmd *last_cmd = v + vec->v_length;
        -: 2500:  struct sed_cmd *p;
        -: 2501:  countT cmd_cnt;
        -: 2502:
        -: 2503:  for (p=v; p < cur_cmd; ++p)
        -: 2504:    if (p->cmd != ':')
        -: 2505:      *v++ = *p;
        -: 2506:  cmd_cnt = v - vec->v;
        -: 2507:
        -: 2508:  for (++p; p < last_cmd; ++p)
        -: 2509:    if (p->cmd != ':')
        -: 2510:      *v++ = *p;
        -: 2511:  vec->v_length = v - vec->v;
        -: 2512:
        -: 2513:  *n = vec->v_length - cmd_cnt;
        -: 2514:  return 0 < vec->v_length ? cur_cmd-cmd_cnt : CAST(struct sed_cmd *)0;
        -: 2515:}
        -: 2516:#endif /*EXPERIMENTAL_DASH_N_OPTIMIZATION*/
        -: 2517:
        -: 2518:#ifdef BOOTSTRAP
        -: 2519:/* We can't be sure that the system we're boostrapping on has
        -: 2520:   memchr(), and ../lib/memchr.c requires configuration knowledge
        -: 2521:   about how many bits are in a `long'.  This implementation
        -: 2522:   is far from ideal, but it should get us up-and-limping well
        -: 2523:   enough to run the configure script, which is all that matters.
        -: 2524:*/
        -: 2525:static VOID *
        -: 2526:bootstrap_memchr(s, c, n)
        -: 2527:  const VOID *s;
        -: 2528:  int c;
        -: 2529:  size_t n;
        -: 2530:{
        -: 2531:  char *p;
        -: 2532:
        -: 2533:  for (p=(char *)s; n-- > 0; ++p)
        -: 2534:    if (*p == c)
        -: 2535:      return p;
        -: 2536:  return CAST(VOID *)0;
        -: 2537:}
        -: 2538:#endif /*BOOTSTRAP*/
        -: 2539:/*  Functions from hack's utils library.
        -: 2540:    Copyright (C) 1989, 1990, 1991, 1998
        -: 2541:    Free Software Foundation, Inc.
        -: 2542:
        -: 2543:    This program is free software; you can redistribute it and/or modify
        -: 2544:    it under the terms of the GNU General Public License as published by
        -: 2545:    the Free Software Foundation; either version 2, or (at your option)
        -: 2546:    any later version.
        -: 2547:
        -: 2548:    This program is distributed in the hope that it will be useful,
        -: 2549:    but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 2550:    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 2551:    GNU General Public License for more details.
        -: 2552:
        -: 2553:    You should have received a copy of the GNU General Public License
        -: 2554:    along with this program; if not, write to the Free Software
        -: 2555:    Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
        -: 2556:
        -: 2557:/* These routines were written as part of a library (by hack), but since most
        -: 2558:   people don't have the library, here they are.  */
        -: 2559:/* Tweaked by ken */
        -: 2560:
        -: 2561:#include "config.h"
        -: 2562:
        -: 2563:#include <stdio.h>
        -: 2564:
        -: 2565:#include <errno.h>
        -: 2566:#ifndef errno
        -: 2567:  extern int errno;
        -: 2568:#endif
        -: 2569:
        -: 2570:#ifndef HAVE_STRING_H
        -: 2571:# include <strings.h>
        -: 2572:#else
        -: 2573:# include <string.h>
        -: 2574:#endif /* HAVE_STRING_H */
        -: 2575:
        -: 2576:#ifndef HAVE_STDLIB_H
        -: 2577:# ifdef RX_MEMDBUG
        -: 2578:#  include <sys/types.h>
        -: 2579:#  include <malloc.h>
        -: 2580:# endif /* RX_MEMDBUG */
        -: 2581:#else /* HAVE_STDLIB_H */
        -: 2582:# include <stdlib.h>
        -: 2583:#endif /* HAVE_STDLIB_H */
        -: 2584:
        -: 2585:#include "basicdefs.h"
        -: 2586:#include "utils.h"
        -: 2587:
        -: 2588:#ifndef HAVE_STDLIB_H
        -: 2589:# ifndef RX_MEMDBUG
        -: 2590:   VOID *malloc();
        -: 2591:   VOID *realloc();
        -: 2592:# endif /* RX_MEMDBUG */
        -: 2593:#endif /* HAVE_STDLIB_H */
        -: 2594:
        -: 2595:const char *myname;
        -: 2596:
        -: 2597:
        -: 2598:/* Print an error message and exit */
        -: 2599:#if !defined __STDC__ || !__STDC__
        -: 2600:# include <varargs.h>
        -: 2601:# define VSTART(l,a)	va_start(l)
        -: 2602:void
        -: 2603:panic(str, va_alist)
        -: 2604:  char *str;
        -: 2605:  va_dcl
        -: 2606:#else /*__STDC__*/
        -: 2607:# include <stdarg.h>
        -: 2608:# define VSTART(l,a)	va_start(l, a)
        -: 2609:void
function panic called 2 returned 0% blocks executed 100%
        2: 2610:panic(const char *str, ...)
        -: 2611:#endif /* __STDC__ */
        -: 2612:{
        -: 2613:  va_list iggy;
        -: 2614:
        2: 2615:  fprintf(stderr, "%s: ", myname);
call    0 returned 2
        2: 2616:  VSTART(iggy, str);
        -: 2617:#ifndef HAVE_VPRINTF
        -: 2618:# ifndef HAVE_DOPRNT
        -: 2619:  fputs(str, stderr);	/* not great, but perhaps better than nothing... */
        -: 2620:# else /* HAVE_DOPRNT */
        -: 2621:  _doprnt(str, &iggy, stderr);
        -: 2622:# endif /* HAVE_DOPRNT */
        -: 2623:#else /* HAVE_VFPRINTF */
        2: 2624:  vfprintf(stderr, str, iggy);
call    0 returned 2
        -: 2625:#endif /* HAVE_VFPRINTF */
        2: 2626:  va_end(iggy);
        2: 2627:  putc('\n', stderr);
call    0 returned 2
        2: 2628:  exit(4);
        -: 2629:}
        -: 2630:
        -: 2631:
        -: 2632:/* Store information about files opened with ck_fopen
        -: 2633:   so that error messages from ck_fread, ck_fwrite, etc. can print the
        -: 2634:   name of the file that had the error */
        -: 2635:
        -: 2636:struct id
        -: 2637:  {
        -: 2638:    FILE *fp;
        -: 2639:    char *name;
        -: 2640:    struct id *link;
        -: 2641:  };
        -: 2642:
        -: 2643:static struct id *utils_id_s = NULL;
        -: 2644:static const char *utils_fp_name P_((FILE *fp));
        -: 2645:
        -: 2646:/* Internal routine to get a filename from utils_id_s */
        -: 2647:static const char *
function utils_fp_name called 0 returned 0% blocks executed 0%
    #####: 2648:utils_fp_name(fp)
        -: 2649:  FILE *fp;
        -: 2650:{
        -: 2651:  struct id *p;
        -: 2652:
    #####: 2653:  for (p=utils_id_s; p; p=p->link)
branch  0 never executed
branch  1 never executed
    #####: 2654:    if (p->fp == fp)
branch  0 never executed
branch  1 never executed
    #####: 2655:      return p->name;
    #####: 2656:  if (fp == stdin)
branch  0 never executed
branch  1 never executed
    #####: 2657:    return "{standard input}";
    #####: 2658:  else if (fp == stdout)
branch  0 never executed
branch  1 never executed
    #####: 2659:    return "{standard output}";
    #####: 2660:  else if (fp == stderr)
branch  0 never executed
branch  1 never executed
    #####: 2661:    return "{standard error}";
    #####: 2662:  return "{Unknown file pointer}";
        -: 2663:}
        -: 2664:
        -: 2665:/* Panic on failing fopen */
        -: 2666:FILE *
function ck_fopen called 535 returned 100% blocks executed 87%
      535: 2667:ck_fopen(name, mode)
        -: 2668:  const char *name;
        -: 2669:  const char *mode;
        -: 2670:{
        -: 2671:  FILE *fp;
        -: 2672:  struct id *p;
        -: 2673:
      535: 2674:  if ( ! (fp = fopen(name, mode)) )
call    0 returned 535
branch  1 taken 2 (fallthrough)
branch  2 taken 533
        2: 2675:    panic("Couldn't open file %s", name);
call    0 returned 0
      768: 2676:  for (p=utils_id_s; p; p=p->link)
branch  0 taken 235
branch  1 taken 533 (fallthrough)
        -: 2677:    {
      235: 2678:      if (fp == p->fp)
branch  0 taken 0 (fallthrough)
branch  1 taken 235
        -: 2679:	{
    #####: 2680:	  FREE(p->name);
call    0 never executed
    #####: 2681:	  break;
        -: 2682:	}
        -: 2683:    }
      533: 2684:  if (!p)
branch  0 taken 533 (fallthrough)
branch  1 taken 0
        -: 2685:    {
      533: 2686:      p = MALLOC(1, struct id);
call    0 returned 533
      533: 2687:      p->link = utils_id_s;
      533: 2688:      utils_id_s = p;
        -: 2689:    }
      533: 2690:  p->name = ck_strdup(name);
call    0 returned 533
      533: 2691:  p->fp = fp;
      533: 2692:  return fp;
        -: 2693:}
        -: 2694:
        -: 2695:/* Panic on failing fwrite */
        -: 2696:void
function ck_fwrite called 63020 returned 100% blocks executed 40%
    63020: 2697:ck_fwrite(ptr, size, nmemb, stream)
        -: 2698:  const VOID *ptr;
        -: 2699:  size_t size;
        -: 2700:  size_t nmemb;
        -: 2701:  FILE *stream;
        -: 2702:{
    63020: 2703:  if (size && fwrite(ptr, size, nmemb, stream) != nmemb)
branch  0 taken 63020 (fallthrough)
branch  1 taken 0
call    2 returned 63020
branch  3 taken 0 (fallthrough)
branch  4 taken 63020
    #####: 2704:    panic("couldn't write %d item%s to %s: %s",
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####: 2705:	  nmemb, nmemb==1 ? "" : "s", utils_fp_name(stream), strerror(errno));
call    0 never executed
    63020: 2706:}
        -: 2707:
        -: 2708:/* Panic on failing fread */
        -: 2709:size_t
function ck_fread called 196 returned 100% blocks executed 70%
      196: 2710:ck_fread(ptr, size, nmemb, stream)
        -: 2711:  VOID *ptr;
        -: 2712:  size_t size;
        -: 2713:  size_t nmemb;
        -: 2714:  FILE *stream;
        -: 2715:{
      196: 2716:  if (size && (nmemb=fread(ptr, size, nmemb, stream)) <= 0 && ferror(stream))
branch  0 taken 196 (fallthrough)
branch  1 taken 0
call    2 returned 196
branch  3 taken 98 (fallthrough)
branch  4 taken 98
call    5 returned 98
branch  6 taken 0 (fallthrough)
branch  7 taken 98
    #####: 2717:    panic("read error on %s: %s", utils_fp_name(stream), strerror(errno));
call    0 never executed
call    1 never executed
call    2 never executed
      196: 2718:  return nmemb;
        -: 2719:}
        -: 2720:
        -: 2721:/* Panic on failing fflush */
        -: 2722:void
function ck_fflush called 3125 returned 100% blocks executed 60%
     3125: 2723:ck_fflush(stream)
        -: 2724:  FILE *stream;
        -: 2725:{
     3125: 2726:  if (fflush(stream) == EOF)
call    0 returned 3125
branch  1 taken 0 (fallthrough)
branch  2 taken 3125
    #####: 2727:    panic("Couldn't flush %s", utils_fp_name(stream));
call    0 never executed
call    1 never executed
     3125: 2728:}
        -: 2729:
        -: 2730:/* Panic on failing fclose */
        -: 2731:void
function ck_fclose called 1240 returned 100% blocks executed 79%
     1240: 2732:ck_fclose(stream)
        -: 2733:  FILE *stream;
        -: 2734:{
        -: 2735:  struct id r;
        -: 2736:  struct id *prev;
        -: 2737:  struct id *cur;
        -: 2738:
     1240: 2739:  if (!stream)
branch  0 taken 0 (fallthrough)
branch  1 taken 1240
    #####: 2740:    return;
     1240: 2741:  if (fclose(stream) == EOF)
call    0 returned 1240
branch  1 taken 0 (fallthrough)
branch  2 taken 1240
    #####: 2742:    panic("Couldn't close %s", utils_fp_name(stream));
call    0 never executed
call    1 never executed
     1240: 2743:  r.link = utils_id_s;
     1240: 2744:  prev = &r;
     2204: 2745:  while ( (cur = prev->link) )
branch  0 taken 964
branch  1 taken 1240 (fallthrough)
        -: 2746:    {
      964: 2747:      if (stream == cur->fp)
branch  0 taken 533 (fallthrough)
branch  1 taken 431
        -: 2748:	{
      533: 2749:	  prev->link = cur->link;
      533: 2750:	  FREE(cur->name);
call    0 returned 533
      533: 2751:	  FREE(cur);
call    0 returned 533
        -: 2752:#ifdef TRUST_THAT_ID_CHAIN_IS_CLEAN
        -: 2753:	  break;
        -: 2754:#endif
        -: 2755:	}
        -: 2756:      else
        -: 2757:	{
      431: 2758:	  prev = cur;
        -: 2759:	}
        -: 2760:    }
     1240: 2761:  utils_id_s = r.link;
        -: 2762:}
        -: 2763:
        -: 2764:
        -: 2765:/* Panic on failing malloc */
        -: 2766:VOID *
function ck_malloc called 9615 returned 100% blocks executed 86%
     9615: 2767:ck_malloc(size)
        -: 2768:  size_t size;
        -: 2769:{
     9615: 2770:  VOID *ret = malloc(size ? size : 1);
branch  0 taken 9611 (fallthrough)
branch  1 taken 4
     9615: 2771:  if (!ret)
branch  0 taken 0 (fallthrough)
branch  1 taken 9615
    #####: 2772:    panic("Couldn't allocate memory");
call    0 never executed
     9615: 2773:  return ret;
        -: 2774:}
        -: 2775:
        -: 2776:/* Panic on failing malloc */
        -: 2777:VOID *
function xmalloc called 0 returned 0% blocks executed 0%
    #####: 2778:xmalloc(size)
        -: 2779:  size_t size;
        -: 2780:{
    #####: 2781:  return ck_malloc(size);
call    0 never executed
        -: 2782:}
        -: 2783:
        -: 2784:/* Panic on failing realloc */
        -: 2785:VOID *
function ck_realloc called 1081 returned 100% blocks executed 70%
     1081: 2786:ck_realloc(ptr, size)
        -: 2787:  VOID *ptr;
        -: 2788:  size_t size;
        -: 2789:{
        -: 2790:  VOID *ret;
        -: 2791:
     1081: 2792:  if (size == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 1081
        -: 2793:    {
    #####: 2794:      FREE(ptr);
call    0 never executed
    #####: 2795:      return NULL;
        -: 2796:    }
     1081: 2797:  if (!ptr)
branch  0 taken 689 (fallthrough)
branch  1 taken 392
      689: 2798:    return ck_malloc(size);
call    0 returned 689
      392: 2799:  ret = realloc(ptr, size);
      392: 2800:  if (!ret)
branch  0 taken 0 (fallthrough)
branch  1 taken 392
    #####: 2801:    panic("Couldn't re-allocate memory");
call    0 never executed
      392: 2802:  return ret;
        -: 2803:}
        -: 2804:
        -: 2805:/* Return a malloc()'d copy of a string */
        -: 2806:char *
function ck_strdup called 1380 returned 100% blocks executed 100%
     1380: 2807:ck_strdup(str)
        -: 2808:  const char *str;
        -: 2809:{
     1380: 2810:  char *ret = MALLOC(strlen(str)+1, char);
call    0 returned 1380
     1380: 2811:  return strcpy(ret, str);
        -: 2812:}
        -: 2813:
        -: 2814:/* Return a malloc()'d copy of a block of memory */
        -: 2815:VOID *
function ck_memdup called 1035 returned 100% blocks executed 100%
     1035: 2816:ck_memdup(buf, len)
        -: 2817:  const VOID *buf;
        -: 2818:  size_t len;
        -: 2819:{
     1035: 2820:  VOID *ret = ck_malloc(len);
call    0 returned 1035
     1035: 2821:  return memcpy(ret, buf, len);
        -: 2822:}
        -: 2823:
        -: 2824:/* Release a malloc'd block of memory */
        -: 2825:void
function ck_free called 5977 returned 100% blocks executed 100%
     5977: 2826:ck_free(ptr)
        -: 2827:  VOID *ptr;
        -: 2828:{
     5977: 2829:  if (ptr)
branch  0 taken 5671 (fallthrough)
branch  1 taken 306
     5671: 2830:    free(ptr);
     5977: 2831:}
        -: 2832:
        -: 2833:
        -: 2834:/* Implement a variable sized buffer of 'stuff'.  We don't know what it is,
        -: 2835:nor do we care, as long as it doesn't mind being aligned by malloc. */
        -: 2836:
        -: 2837:struct buffer
        -: 2838:  {
        -: 2839:    size_t allocated;
        -: 2840:    size_t length;
        -: 2841:    char *b;
        -: 2842:  };
        -: 2843:
        -: 2844:#define MIN_ALLOCATE 50
        -: 2845:
        -: 2846:struct buffer *
function init_buffer called 1249 returned 100% blocks executed 100%
     1249: 2847:init_buffer()
        -: 2848:{
     1249: 2849:  struct buffer *b = MALLOC(1, struct buffer);
call    0 returned 1249
     1249: 2850:  b->b = MALLOC(MIN_ALLOCATE, char);
call    0 returned 1249
     1249: 2851:  b->allocated = MIN_ALLOCATE;
     1249: 2852:  b->length = 0;
     1249: 2853:  return b;
        -: 2854:}
        -: 2855:
        -: 2856:char *
function get_buffer called 1231 returned 100% blocks executed 100%
     1231: 2857:get_buffer(b)
        -: 2858:  struct buffer *b;
        -: 2859:{
     1231: 2860:  return b->b;
        -: 2861:}
        -: 2862:
        -: 2863:size_t
function size_buffer called 1006 returned 100% blocks executed 100%
     1006: 2864:size_buffer(b)
        -: 2865:  struct buffer *b;
        -: 2866:{
     1006: 2867:  return b->length;
        -: 2868:}
        -: 2869:
        -: 2870:static void resize_buffer P_((struct buffer *b, size_t newlen));
        -: 2871:
        -: 2872:static void
function resize_buffer called 0 returned 0% blocks executed 0%
    #####: 2873:resize_buffer(b, newlen)
        -: 2874:  struct buffer *b;
        -: 2875:  size_t newlen;
        -: 2876:{
    #####: 2877:  char *try = NULL;
    #####: 2878:  size_t alen = b->allocated;
        -: 2879:
    #####: 2880:  if (newlen <= alen)
branch  0 never executed
branch  1 never executed
    #####: 2881:    return;
    #####: 2882:  alen *= 2;
    #####: 2883:  if (newlen < alen)
branch  0 never executed
branch  1 never executed
    #####: 2884:    try = realloc(b->b, alen);	/* Note: *not* the REALLOC() macro! */
    #####: 2885:  if (!try)
branch  0 never executed
branch  1 never executed
        -: 2886:    {
    #####: 2887:      alen = newlen;
    #####: 2888:      try = REALLOC(b->b, alen, char);
call    0 never executed
        -: 2889:    }
    #####: 2890:  b->allocated = alen;
    #####: 2891:  b->b = try;
        -: 2892:}
        -: 2893:
        -: 2894:void
function add_buffer called 0 returned 0% blocks executed 0%
    #####: 2895:add_buffer(b, p, n)
        -: 2896:  struct buffer *b;
        -: 2897:  const char *p;
        -: 2898:  size_t n;
        -: 2899:{
    #####: 2900:  if (b->allocated - b->length < n)
branch  0 never executed
branch  1 never executed
    #####: 2901:    resize_buffer(b, b->length+n);
call    0 never executed
    #####: 2902:  memcpy(b->b + b->length, p, n);
    #####: 2903:  b->length += n;
    #####: 2904:}
        -: 2905:
        -: 2906:void
function add1_buffer called 11245 returned 100% blocks executed 80%
    11245: 2907:add1_buffer(b, c)
        -: 2908:  struct buffer *b;
        -: 2909:  int c;
        -: 2910:{
        -: 2911:  /* This special case should be kept cheap;
        -: 2912:   *  don't make it just a mere convenience
        -: 2913:   *  wrapper for add_buffer() -- even "builtin"
        -: 2914:   *  versions of memcpy(a, b, 1) can become
        -: 2915:   *  expensive when called too often.
        -: 2916:   */
    11245: 2917:  if (c != EOF)
branch  0 taken 11245 (fallthrough)
branch  1 taken 0
        -: 2918:    {
    11245: 2919:      if (b->allocated - b->length < 1)
branch  0 taken 0 (fallthrough)
branch  1 taken 11245
    #####: 2920:	resize_buffer(b, b->length+1);
call    0 never executed
    11245: 2921:      b->b[b->length++] = c;
        -: 2922:    }
    11245: 2923:}
        -: 2924:
        -: 2925:void
function free_buffer called 1249 returned 100% blocks executed 100%
     1249: 2926:free_buffer(b)
        -: 2927:  struct buffer *b;
        -: 2928:{
     1249: 2929:  if (b)
branch  0 taken 1249 (fallthrough)
branch  1 taken 0
     1249: 2930:    FREE(b->b);
call    0 returned 1249
     1249: 2931:  FREE(b);
call    0 returned 1249
     1249: 2932:}
        -: 2933:/* getopt_long and getopt_long_only entry points for GNU getopt.
        -: 2934:   Copyright (C) 1987,88,89,90,91,92,93,94,96,97,98
        -: 2935:     Free Software Foundation, Inc.
        -: 2936:
        -: 2937:   NOTE: The canonical source of this file is maintained with the GNU C Library.
        -: 2938:   Bugs can be reported to bug-glibc@gnu.org.
        -: 2939:
        -: 2940:   This program is free software; you can redistribute it and/or modify it
        -: 2941:   under the terms of the GNU General Public License as published by the
        -: 2942:   Free Software Foundation; either version 2, or (at your option) any
        -: 2943:   later version.
        -: 2944:
        -: 2945:   This program is distributed in the hope that it will be useful,
        -: 2946:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 2947:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 2948:   GNU General Public License for more details.
        -: 2949:
        -: 2950:   You should have received a copy of the GNU General Public License
        -: 2951:   along with this program; if not, write to the Free Software
        -: 2952:   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
        -: 2953:   USA.  */
        -: 2954:
        -: 2955:#ifdef HAVE_CONFIG_H
        -: 2956:#include <config.h>
        -: 2957:#endif
        -: 2958:
        -: 2959:#include "getopt.h"
        -: 2960:
        -: 2961:#if !defined __STDC__ || !__STDC__
        -: 2962:/* This is a separate conditional since some stdc systems
        -: 2963:   reject `defined (const)'.  */
        -: 2964:#ifndef const
        -: 2965:#define const
        -: 2966:#endif
        -: 2967:#endif
        -: 2968:
        -: 2969:#include <stdio.h>
        -: 2970:
        -: 2971:/* Comment out all this code if we are using the GNU C Library, and are not
        -: 2972:   actually compiling the library itself.  This code is part of the GNU C
        -: 2973:   Library, but also included in many other GNU distributions.  Compiling
        -: 2974:   and linking in this code is a waste when using the GNU C library
        -: 2975:   (especially if it is a shared library).  Rather than having every GNU
        -: 2976:   program understand `configure --with-gnu-libc' and omit the object files,
        -: 2977:   it is simpler to just do this in the source for each such file.  */
        -: 2978:
        -: 2979:#define GETOPT_INTERFACE_VERSION 2
        -: 2980:#if !defined _LIBC && defined __GLIBC__ && __GLIBC__ >= 2
        -: 2981:#include <gnu-versions.h>
        -: 2982:#if _GNU_GETOPT_INTERFACE_VERSION == GETOPT_INTERFACE_VERSION
        -: 2983:#define ELIDE_CODE
        -: 2984:#endif
        -: 2985:#endif
        -: 2986:
        -: 2987:#ifndef ELIDE_CODE
        -: 2988:
        -: 2989:
        -: 2990:/* This needs to come after some library #include
        -: 2991:   to get __GNU_LIBRARY__ defined.  */
        -: 2992:#ifdef __GNU_LIBRARY__
        -: 2993:#include <stdlib.h>
        -: 2994:#endif
        -: 2995:
        -: 2996:#ifndef	NULL
        -: 2997:#define NULL 0
        -: 2998:#endif
        -: 2999:
        -: 3000:int
        -: 3001:getopt_long (argc, argv, options, long_options, opt_index)
        -: 3002:     int argc;
        -: 3003:     char *const *argv;
        -: 3004:     const char *options;
        -: 3005:     const struct option *long_options;
        -: 3006:     int *opt_index;
        -: 3007:{
        -: 3008:  return _getopt_internal (argc, argv, options, long_options, opt_index, 0);
        -: 3009:}
        -: 3010:
        -: 3011:/* Like getopt_long, but '-' as well as '--' can indicate a long option.
        -: 3012:   If an option that starts with '-' (not '--') doesn't match a long option,
        -: 3013:   but does match a short option, it is parsed as a short option
        -: 3014:   instead.  */
        -: 3015:
        -: 3016:int
        -: 3017:getopt_long_only (argc, argv, options, long_options, opt_index)
        -: 3018:     int argc;
        -: 3019:     char *const *argv;
        -: 3020:     const char *options;
        -: 3021:     const struct option *long_options;
        -: 3022:     int *opt_index;
        -: 3023:{
        -: 3024:  return _getopt_internal (argc, argv, options, long_options, opt_index, 1);
        -: 3025:}
        -: 3026:
        -: 3027:
        -: 3028:#endif	/* Not ELIDE_CODE.  */
        -: 3029:
        -: 3030:#ifdef TEST
        -: 3031:
        -: 3032:#include <stdio.h>
        -: 3033:
        -: 3034:int
        -: 3035:main (argc, argv)
        -: 3036:     int argc;
        -: 3037:     char **argv;
        -: 3038:{
        -: 3039:  int c;
        -: 3040:  int digit_optind = 0;
        -: 3041:
        -: 3042:  while (1)
        -: 3043:    {
        -: 3044:      int this_option_optind = optind ? optind : 1;
        -: 3045:      int option_index = 0;
        -: 3046:      static struct option long_options[] =
        -: 3047:      {
        -: 3048:	{"add", 1, 0, 0},
        -: 3049:	{"append", 0, 0, 0},
        -: 3050:	{"delete", 1, 0, 0},
        -: 3051:	{"verbose", 0, 0, 0},
        -: 3052:	{"create", 0, 0, 0},
        -: 3053:	{"file", 1, 0, 0},
        -: 3054:	{0, 0, 0, 0}
        -: 3055:      };
        -: 3056:
        -: 3057:      c = getopt_long (argc, argv, "abc:d:0123456789",
        -: 3058:		       long_options, &option_index);
        -: 3059:      if (c == -1)
        -: 3060:	break;
        -: 3061:
        -: 3062:      switch (c)
        -: 3063:	{
        -: 3064:	case 0:
        -: 3065:	  printf ("option %s", long_options[option_index].name);
        -: 3066:	  if (optarg)
        -: 3067:	    printf (" with arg %s", optarg);
        -: 3068:	  printf ("\n");
        -: 3069:	  break;
        -: 3070:
        -: 3071:	case '0':
        -: 3072:	case '1':
        -: 3073:	case '2':
        -: 3074:	case '3':
        -: 3075:	case '4':
        -: 3076:	case '5':
        -: 3077:	case '6':
        -: 3078:	case '7':
        -: 3079:	case '8':
        -: 3080:	case '9':
        -: 3081:	  if (digit_optind != 0 && digit_optind != this_option_optind)
        -: 3082:	    printf ("digits occur in two different argv-elements.\n");
        -: 3083:	  digit_optind = this_option_optind;
        -: 3084:	  printf ("option %c\n", c);
        -: 3085:	  break;
        -: 3086:
        -: 3087:	case 'a':
        -: 3088:	  printf ("option a\n");
        -: 3089:	  break;
        -: 3090:
        -: 3091:	case 'b':
        -: 3092:	  printf ("option b\n");
        -: 3093:	  break;
        -: 3094:
        -: 3095:	case 'c':
        -: 3096:	  printf ("option c with value `%s'\n", optarg);
        -: 3097:	  break;
        -: 3098:
        -: 3099:	case 'd':
        -: 3100:	  printf ("option d with value `%s'\n", optarg);
        -: 3101:	  break;
        -: 3102:
        -: 3103:	case '?':
        -: 3104:	  break;
        -: 3105:
        -: 3106:	default:
        -: 3107:	  printf ("?? getopt returned character code 0%o ??\n", c);
        -: 3108:	}
        -: 3109:    }
        -: 3110:
        -: 3111:  if (optind < argc)
        -: 3112:    {
        -: 3113:      printf ("non-option ARGV-elements: ");
        -: 3114:      while (optind < argc)
        -: 3115:	printf ("%s ", argv[optind++]);
        -: 3116:      printf ("\n");
        -: 3117:    }
        -: 3118:
        -: 3119:  exit (0);
        -: 3120:}
        -: 3121:
        -: 3122:#endif /* TEST */
        -: 3123:/* Getopt for GNU.
        -: 3124:   NOTE: getopt is now part of the C library, so if you don't know what
        -: 3125:   "Keep this file name-space clean" means, talk to drepper@gnu.org
        -: 3126:   before changing it!
        -: 3127:
        -: 3128:   Copyright (C) 1987, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98
        -: 3129:   	Free Software Foundation, Inc.
        -: 3130:
        -: 3131:   NOTE: The canonical source of this file is maintained with the GNU C Library.
        -: 3132:   Bugs can be reported to bug-glibc@gnu.org.
        -: 3133:
        -: 3134:   This program is free software; you can redistribute it and/or modify it
        -: 3135:   under the terms of the GNU General Public License as published by the
        -: 3136:   Free Software Foundation; either version 2, or (at your option) any
        -: 3137:   later version.
        -: 3138:
        -: 3139:   This program is distributed in the hope that it will be useful,
        -: 3140:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 3141:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 3142:   GNU General Public License for more details.
        -: 3143:
        -: 3144:   You should have received a copy of the GNU General Public License
        -: 3145:   along with this program; if not, write to the Free Software
        -: 3146:   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
        -: 3147:   USA.  */
        -: 3148:
        -: 3149:/* This tells Alpha OSF/1 not to define a getopt prototype in <stdio.h>.
        -: 3150:   Ditto for AIX 3.2 and <stdlib.h>.  */
        -: 3151:#ifndef _NO_PROTO
        -: 3152:# define _NO_PROTO
        -: 3153:#endif
        -: 3154:
        -: 3155:#ifdef HAVE_CONFIG_H
        -: 3156:# include <config.h>
        -: 3157:#endif
        -: 3158:
        -: 3159:#if !defined __STDC__ || !__STDC__
        -: 3160:/* This is a separate conditional since some stdc systems
        -: 3161:   reject `defined (const)'.  */
        -: 3162:# ifndef const
        -: 3163:#  define const
        -: 3164:# endif
        -: 3165:#endif
        -: 3166:
        -: 3167:#include <stdio.h>
        -: 3168:
        -: 3169:/* Comment out all this code if we are using the GNU C Library, and are not
        -: 3170:   actually compiling the library itself.  This code is part of the GNU C
        -: 3171:   Library, but also included in many other GNU distributions.  Compiling
        -: 3172:   and linking in this code is a waste when using the GNU C library
        -: 3173:   (especially if it is a shared library).  Rather than having every GNU
        -: 3174:   program understand `configure --with-gnu-libc' and omit the object files,
        -: 3175:   it is simpler to just do this in the source for each such file.  */
        -: 3176:
        -: 3177:#define GETOPT_INTERFACE_VERSION 2
        -: 3178:#if !defined _LIBC && defined __GLIBC__ && __GLIBC__ >= 2
        -: 3179:# include <gnu-versions.h>
        -: 3180:# if _GNU_GETOPT_INTERFACE_VERSION == GETOPT_INTERFACE_VERSION
        -: 3181:#  define ELIDE_CODE
        -: 3182:# endif
        -: 3183:#endif
        -: 3184:
        -: 3185:#ifndef ELIDE_CODE
        -: 3186:
        -: 3187:
        -: 3188:/* This needs to come after some library #include
        -: 3189:   to get __GNU_LIBRARY__ defined.  */
        -: 3190:#ifdef	__GNU_LIBRARY__
        -: 3191:/* Don't include stdlib.h for non-GNU C libraries because some of them
        -: 3192:   contain conflicting prototypes for getopt.  */
        -: 3193:# include <stdlib.h>
        -: 3194:# include <unistd.h>
        -: 3195:#endif	/* GNU C library.  */
        -: 3196:
        -: 3197:#ifdef VMS
        -: 3198:# include <unixlib.h>
        -: 3199:# if HAVE_STRING_H - 0
        -: 3200:#  include <string.h>
        -: 3201:# endif
        -: 3202:#endif
        -: 3203:
        -: 3204:#ifndef _
        -: 3205:/* This is for other GNU distributions with internationalized messages.
        -: 3206:   When compiling libc, the _ macro is predefined.  */
        -: 3207:# ifdef HAVE_LIBINTL_H
        -: 3208:#  include <libintl.h>
        -: 3209:#  define _(msgid)	gettext (msgid)
        -: 3210:# else
        -: 3211:#  define _(msgid)	(msgid)
        -: 3212:# endif
        -: 3213:#endif
        -: 3214:
        -: 3215:/* This version of `getopt' appears to the caller like standard Unix `getopt'
        -: 3216:   but it behaves differently for the user, since it allows the user
        -: 3217:   to intersperse the options with the other arguments.
        -: 3218:
        -: 3219:   As `getopt' works, it permutes the elements of ARGV so that,
        -: 3220:   when it is done, all the options precede everything else.  Thus
        -: 3221:   all application programs are extended to handle flexible argument order.
        -: 3222:
        -: 3223:   Setting the environment variable POSIXLY_CORRECT disables permutation.
        -: 3224:   Then the behavior is completely standard.
        -: 3225:
        -: 3226:   GNU application programs can use a third alternative mode in which
        -: 3227:   they can distinguish the relative order of options and other arguments.  */
        -: 3228:
        -: 3229:#include "getopt.h"
        -: 3230:
        -: 3231:/* For communication from `getopt' to the caller.
        -: 3232:   When `getopt' finds an option that takes an argument,
        -: 3233:   the argument value is returned here.
        -: 3234:   Also, when `ordering' is RETURN_IN_ORDER,
        -: 3235:   each non-option ARGV-element is returned here.  */
        -: 3236:
        -: 3237:char *optarg = NULL;
        -: 3238:
        -: 3239:/* Index in ARGV of the next element to be scanned.
        -: 3240:   This is used for communication to and from the caller
        -: 3241:   and for communication between successive calls to `getopt'.
        -: 3242:
        -: 3243:   On entry to `getopt', zero means this is the first call; initialize.
        -: 3244:
        -: 3245:   When `getopt' returns -1, this is the index of the first of the
        -: 3246:   non-option elements that the caller should itself scan.
        -: 3247:
        -: 3248:   Otherwise, `optind' communicates from one call to the next
        -: 3249:   how much of ARGV has been scanned so far.  */
        -: 3250:
        -: 3251:/* 1003.2 says this must be 1 before any call.  */
        -: 3252:int optind = 1;
        -: 3253:
        -: 3254:/* Formerly, initialization of getopt depended on optind==0, which
        -: 3255:   causes problems with re-calling getopt as programs generally don't
        -: 3256:   know that. */
        -: 3257:
        -: 3258:int __getopt_initialized = 0;
        -: 3259:
        -: 3260:/* The next char to be scanned in the option-element
        -: 3261:   in which the last option character we returned was found.
        -: 3262:   This allows us to pick up the scan where we left off.
        -: 3263:
        -: 3264:   If this is zero, or a null string, it means resume the scan
        -: 3265:   by advancing to the next ARGV-element.  */
        -: 3266:
        -: 3267:static char *nextchar;
        -: 3268:
        -: 3269:/* Callers store zero here to inhibit the error message
        -: 3270:   for unrecognized options.  */
        -: 3271:
        -: 3272:int opterr = 1;
        -: 3273:
        -: 3274:/* Set to an option character which was unrecognized.
        -: 3275:   This must be initialized on some systems to avoid linking in the
        -: 3276:   system's own getopt implementation.  */
        -: 3277:
        -: 3278:int optopt = '?';
        -: 3279:
        -: 3280:/* Describe how to deal with options that follow non-option ARGV-elements.
        -: 3281:
        -: 3282:   If the caller did not specify anything,
        -: 3283:   the default is REQUIRE_ORDER if the environment variable
        -: 3284:   POSIXLY_CORRECT is defined, PERMUTE otherwise.
        -: 3285:
        -: 3286:   REQUIRE_ORDER means don't recognize them as options;
        -: 3287:   stop option processing when the first non-option is seen.
        -: 3288:   This is what Unix does.
        -: 3289:   This mode of operation is selected by either setting the environment
        -: 3290:   variable POSIXLY_CORRECT, or using `+' as the first character
        -: 3291:   of the list of option characters.
        -: 3292:
        -: 3293:   PERMUTE is the default.  We permute the contents of ARGV as we scan,
        -: 3294:   so that eventually all the non-options are at the end.  This allows options
        -: 3295:   to be given in any order, even with programs that were not written to
        -: 3296:   expect this.
        -: 3297:
        -: 3298:   RETURN_IN_ORDER is an option available to programs that were written
        -: 3299:   to expect options and other ARGV-elements in any order and that care about
        -: 3300:   the ordering of the two.  We describe each non-option ARGV-element
        -: 3301:   as if it were the argument of an option with character code 1.
        -: 3302:   Using `-' as the first character of the list of option characters
        -: 3303:   selects this mode of operation.
        -: 3304:
        -: 3305:   The special argument `--' forces an end of option-scanning regardless
        -: 3306:   of the value of `ordering'.  In the case of RETURN_IN_ORDER, only
        -: 3307:   `--' can cause `getopt' to return -1 with `optind' != ARGC.  */
        -: 3308:
        -: 3309:static enum
        -: 3310:{
        -: 3311:  REQUIRE_ORDER, PERMUTE, RETURN_IN_ORDER
        -: 3312:} ordering;
        -: 3313:
        -: 3314:/* Value of POSIXLY_CORRECT environment variable.  */
        -: 3315:static char *posixly_correct;
        -: 3316:
        -: 3317:#ifdef	__GNU_LIBRARY__
        -: 3318:/* We want to avoid inclusion of string.h with non-GNU libraries
        -: 3319:   because there are many ways it can cause trouble.
        -: 3320:   On some systems, it contains special magic macros that don't work
        -: 3321:   in GCC.  */
        -: 3322:# include <string.h>
        -: 3323:# define my_index	strchr
        -: 3324:#else
        -: 3325:
        -: 3326:/* Avoid depending on library functions or files
        -: 3327:   whose names are inconsistent.  */
        -: 3328:
        -: 3329:#ifndef getenv
        -: 3330:extern char *getenv ();
        -: 3331:#endif
        -: 3332:#ifndef strncmp
        -: 3333:extern int strncmp ();
        -: 3334:#endif
        -: 3335:
        -: 3336:static char *
        -: 3337:my_index (str, chr)
        -: 3338:     const char *str;
        -: 3339:     int chr;
        -: 3340:{
        -: 3341:  while (*str)
        -: 3342:    {
        -: 3343:      if (*str == chr)
        -: 3344:	return (char *) str;
        -: 3345:      str++;
        -: 3346:    }
        -: 3347:  return 0;
        -: 3348:}
        -: 3349:
        -: 3350:/* If using GCC, we can safely declare strlen this way.
        -: 3351:   If not using GCC, it is ok not to declare it.  */
        -: 3352:#ifdef __GNUC__
        -: 3353:/* Note that Motorola Delta 68k R3V7 comes with GCC but not stddef.h.
        -: 3354:   That was relevant to code that was here before.  */
        -: 3355:# if (!defined __STDC__ || !__STDC__) && !defined strlen
        -: 3356:/* gcc with -traditional declares the built-in strlen to return int,
        -: 3357:   and has done so at least since version 2.4.5. -- rms.  */
        -: 3358:extern int strlen (const char *);
        -: 3359:# endif /* not __STDC__ */
        -: 3360:#endif /* __GNUC__ */
        -: 3361:
        -: 3362:#endif /* not __GNU_LIBRARY__ */
        -: 3363:
        -: 3364:/* Handle permutation of arguments.  */
        -: 3365:
        -: 3366:/* Describe the part of ARGV that contains non-options that have
        -: 3367:   been skipped.  `first_nonopt' is the index in ARGV of the first of them;
        -: 3368:   `last_nonopt' is the index after the last of them.  */
        -: 3369:
        -: 3370:static int first_nonopt;
        -: 3371:static int last_nonopt;
        -: 3372:
        -: 3373:#ifdef _LIBC
        -: 3374:/* Bash 2.0 gives us an environment variable containing flags
        -: 3375:   indicating ARGV elements that should not be considered arguments.  */
        -: 3376:
        -: 3377:/* Defined in getopt_init.c  */
        -: 3378:extern char *__getopt_nonoption_flags;
        -: 3379:
        -: 3380:static int nonoption_flags_max_len;
        -: 3381:static int nonoption_flags_len;
        -: 3382:
        -: 3383:static int original_argc;
        -: 3384:static char *const *original_argv;
        -: 3385:
        -: 3386:/* Make sure the environment variable bash 2.0 puts in the environment
        -: 3387:   is valid for the getopt call we must make sure that the ARGV passed
        -: 3388:   to getopt is that one passed to the process.  */
        -: 3389:static void
        -: 3390:__attribute__ ((unused))
        -: 3391:store_args_and_env (int argc, char *const *argv)
        -: 3392:{
        -: 3393:  /* XXX This is no good solution.  We should rather copy the args so
        -: 3394:     that we can compare them later.  But we must not use malloc(3).  */
        -: 3395:  original_argc = argc;
        -: 3396:  original_argv = argv;
        -: 3397:}
        -: 3398:# ifdef text_set_element
        -: 3399:text_set_element (__libc_subinit, store_args_and_env);
        -: 3400:# endif /* text_set_element */
        -: 3401:
        -: 3402:# define SWAP_FLAGS(ch1, ch2) \
        -: 3403:  if (nonoption_flags_len > 0)						      \
        -: 3404:    {									      \
        -: 3405:      char __tmp = __getopt_nonoption_flags[ch1];			      \
        -: 3406:      __getopt_nonoption_flags[ch1] = __getopt_nonoption_flags[ch2];	      \
        -: 3407:      __getopt_nonoption_flags[ch2] = __tmp;				      \
        -: 3408:    }
        -: 3409:#else	/* !_LIBC */
        -: 3410:# define SWAP_FLAGS(ch1, ch2)
        -: 3411:#endif	/* _LIBC */
        -: 3412:
        -: 3413:/* Exchange two adjacent subsequences of ARGV.
        -: 3414:   One subsequence is elements [first_nonopt,last_nonopt)
        -: 3415:   which contains all the non-options that have been skipped so far.
        -: 3416:   The other is elements [last_nonopt,optind), which contains all
        -: 3417:   the options processed since those non-options were skipped.
        -: 3418:
        -: 3419:   `first_nonopt' and `last_nonopt' are relocated so that they describe
        -: 3420:   the new indices of the non-options in ARGV after they are moved.  */
        -: 3421:
        -: 3422:#if defined __STDC__ && __STDC__
        -: 3423:static void exchange (char **);
        -: 3424:#endif
        -: 3425:
        -: 3426:static void
        -: 3427:exchange (argv)
        -: 3428:     char **argv;
        -: 3429:{
        -: 3430:  int bottom = first_nonopt;
        -: 3431:  int middle = last_nonopt;
        -: 3432:  int top = optind;
        -: 3433:  char *tem;
        -: 3434:
        -: 3435:  /* Exchange the shorter segment with the far end of the longer segment.
        -: 3436:     That puts the shorter segment into the right place.
        -: 3437:     It leaves the longer segment in the right place overall,
        -: 3438:     but it consists of two parts that need to be swapped next.  */
        -: 3439:
        -: 3440:#ifdef _LIBC
        -: 3441:  /* First make sure the handling of the `__getopt_nonoption_flags'
        -: 3442:     string can work normally.  Our top argument must be in the range
        -: 3443:     of the string.  */
        -: 3444:  if (nonoption_flags_len > 0 && top >= nonoption_flags_max_len)
        -: 3445:    {
        -: 3446:      /* We must extend the array.  The user plays games with us and
        -: 3447:	 presents new arguments.  */
        -: 3448:      char *new_str = malloc (top + 1);
        -: 3449:      if (new_str == NULL)
        -: 3450:	nonoption_flags_len = nonoption_flags_max_len = 0;
        -: 3451:      else
        -: 3452:	{
        -: 3453:	  memset (__mempcpy (new_str, __getopt_nonoption_flags,
        -: 3454:			     nonoption_flags_max_len),
        -: 3455:		  '\0', top + 1 - nonoption_flags_max_len);
        -: 3456:	  nonoption_flags_max_len = top + 1;
        -: 3457:	  __getopt_nonoption_flags = new_str;
        -: 3458:	}
        -: 3459:    }
        -: 3460:#endif
        -: 3461:
        -: 3462:  while (top > middle && middle > bottom)
        -: 3463:    {
        -: 3464:      if (top - middle > middle - bottom)
        -: 3465:	{
        -: 3466:	  /* Bottom segment is the short one.  */
        -: 3467:	  int len = middle - bottom;
        -: 3468:	  register int i;
        -: 3469:
        -: 3470:	  /* Swap it with the top part of the top segment.  */
        -: 3471:	  for (i = 0; i < len; i++)
        -: 3472:	    {
        -: 3473:	      tem = argv[bottom + i];
        -: 3474:	      argv[bottom + i] = argv[top - (middle - bottom) + i];
        -: 3475:	      argv[top - (middle - bottom) + i] = tem;
        -: 3476:	      SWAP_FLAGS (bottom + i, top - (middle - bottom) + i);
        -: 3477:	    }
        -: 3478:	  /* Exclude the moved bottom segment from further swapping.  */
        -: 3479:	  top -= len;
        -: 3480:	}
        -: 3481:      else
        -: 3482:	{
        -: 3483:	  /* Top segment is the short one.  */
        -: 3484:	  int len = top - middle;
        -: 3485:	  register int i;
        -: 3486:
        -: 3487:	  /* Swap it with the bottom part of the bottom segment.  */
        -: 3488:	  for (i = 0; i < len; i++)
        -: 3489:	    {
        -: 3490:	      tem = argv[bottom + i];
        -: 3491:	      argv[bottom + i] = argv[middle + i];
        -: 3492:	      argv[middle + i] = tem;
        -: 3493:	      SWAP_FLAGS (bottom + i, middle + i);
        -: 3494:	    }
        -: 3495:	  /* Exclude the moved top segment from further swapping.  */
        -: 3496:	  bottom += len;
        -: 3497:	}
        -: 3498:    }
        -: 3499:
        -: 3500:  /* Update records for the slots the non-options now occupy.  */
        -: 3501:
        -: 3502:  first_nonopt += (optind - last_nonopt);
        -: 3503:  last_nonopt = optind;
        -: 3504:}
        -: 3505:
        -: 3506:/* Initialize the internal data when the first call is made.  */
        -: 3507:
        -: 3508:#if defined __STDC__ && __STDC__
        -: 3509:static const char *_getopt_initialize (int, char *const *, const char *);
        -: 3510:#endif
        -: 3511:static const char *
        -: 3512:_getopt_initialize (argc, argv, optstring)
        -: 3513:     int argc;
        -: 3514:     char *const *argv;
        -: 3515:     const char *optstring;
        -: 3516:{
        -: 3517:  /* Start processing options with ARGV-element 1 (since ARGV-element 0
        -: 3518:     is the program name); the sequence of previously skipped
        -: 3519:     non-option ARGV-elements is empty.  */
        -: 3520:
        -: 3521:  first_nonopt = last_nonopt = optind;
        -: 3522:
        -: 3523:  nextchar = NULL;
        -: 3524:
        -: 3525:  posixly_correct = getenv ("POSIXLY_CORRECT");
        -: 3526:
        -: 3527:  /* Determine how to handle the ordering of options and nonoptions.  */
        -: 3528:
        -: 3529:  if (optstring[0] == '-')
        -: 3530:    {
        -: 3531:      ordering = RETURN_IN_ORDER;
        -: 3532:      ++optstring;
        -: 3533:    }
        -: 3534:  else if (optstring[0] == '+')
        -: 3535:    {
        -: 3536:      ordering = REQUIRE_ORDER;
        -: 3537:      ++optstring;
        -: 3538:    }
        -: 3539:  else if (posixly_correct != NULL)
        -: 3540:    ordering = REQUIRE_ORDER;
        -: 3541:  else
        -: 3542:    ordering = PERMUTE;
        -: 3543:
        -: 3544:#ifdef _LIBC
        -: 3545:  if (posixly_correct == NULL
        -: 3546:      && argc == original_argc && argv == original_argv)
        -: 3547:    {
        -: 3548:      if (nonoption_flags_max_len == 0)
        -: 3549:	{
        -: 3550:	  if (__getopt_nonoption_flags == NULL
        -: 3551:	      || __getopt_nonoption_flags[0] == '\0')
        -: 3552:	    nonoption_flags_max_len = -1;
        -: 3553:	  else
        -: 3554:	    {
        -: 3555:	      const char *orig_str = __getopt_nonoption_flags;
        -: 3556:	      int len = nonoption_flags_max_len = strlen (orig_str);
        -: 3557:	      if (nonoption_flags_max_len < argc)
        -: 3558:		nonoption_flags_max_len = argc;
        -: 3559:	      __getopt_nonoption_flags =
        -: 3560:		(char *) malloc (nonoption_flags_max_len);
        -: 3561:	      if (__getopt_nonoption_flags == NULL)
        -: 3562:		nonoption_flags_max_len = -1;
        -: 3563:	      else
        -: 3564:		memset (__mempcpy (__getopt_nonoption_flags, orig_str, len),
        -: 3565:			'\0', nonoption_flags_max_len - len);
        -: 3566:	    }
        -: 3567:	}
        -: 3568:      nonoption_flags_len = nonoption_flags_max_len;
        -: 3569:    }
        -: 3570:  else
        -: 3571:    nonoption_flags_len = 0;
        -: 3572:#endif
        -: 3573:
        -: 3574:  return optstring;
        -: 3575:}
        -: 3576:
        -: 3577:/* Scan elements of ARGV (whose length is ARGC) for option characters
        -: 3578:   given in OPTSTRING.
        -: 3579:
        -: 3580:   If an element of ARGV starts with '-', and is not exactly "-" or "--",
        -: 3581:   then it is an option element.  The characters of this element
        -: 3582:   (aside from the initial '-') are option characters.  If `getopt'
        -: 3583:   is called repeatedly, it returns successively each of the option characters
        -: 3584:   from each of the option elements.
        -: 3585:
        -: 3586:   If `getopt' finds another option character, it returns that character,
        -: 3587:   updating `optind' and `nextchar' so that the next call to `getopt' can
        -: 3588:   resume the scan with the following option character or ARGV-element.
        -: 3589:
        -: 3590:   If there are no more option characters, `getopt' returns -1.
        -: 3591:   Then `optind' is the index in ARGV of the first ARGV-element
        -: 3592:   that is not an option.  (The ARGV-elements have been permuted
        -: 3593:   so that those that are not options now come last.)
        -: 3594:
        -: 3595:   OPTSTRING is a string containing the legitimate option characters.
        -: 3596:   If an option character is seen that is not listed in OPTSTRING,
        -: 3597:   return '?' after printing an error message.  If you set `opterr' to
        -: 3598:   zero, the error message is suppressed but we still return '?'.
        -: 3599:
        -: 3600:   If a char in OPTSTRING is followed by a colon, that means it wants an arg,
        -: 3601:   so the following text in the same ARGV-element, or the text of the following
        -: 3602:   ARGV-element, is returned in `optarg'.  Two colons mean an option that
        -: 3603:   wants an optional arg; if there is text in the current ARGV-element,
        -: 3604:   it is returned in `optarg', otherwise `optarg' is set to zero.
        -: 3605:
        -: 3606:   If OPTSTRING starts with `-' or `+', it requests different methods of
        -: 3607:   handling the non-option ARGV-elements.
        -: 3608:   See the comments about RETURN_IN_ORDER and REQUIRE_ORDER, above.
        -: 3609:
        -: 3610:   Long-named options begin with `--' instead of `-'.
        -: 3611:   Their names may be abbreviated as long as the abbreviation is unique
        -: 3612:   or is an exact match for some defined option.  If they have an
        -: 3613:   argument, it follows the option name in the same ARGV-element, separated
        -: 3614:   from the option name by a `=', or else the in next ARGV-element.
        -: 3615:   When `getopt' finds a long-named option, it returns 0 if that option's
        -: 3616:   `flag' field is nonzero, the value of the option's `val' field
        -: 3617:   if the `flag' field is zero.
        -: 3618:
        -: 3619:   The elements of ARGV aren't really const, because we permute them.
        -: 3620:   But we pretend they're const in the prototype to be compatible
        -: 3621:   with other systems.
        -: 3622:
        -: 3623:   LONGOPTS is a vector of `struct option' terminated by an
        -: 3624:   element containing a name which is zero.
        -: 3625:
        -: 3626:   LONGIND returns the index in LONGOPT of the long-named option found.
        -: 3627:   It is only valid when a long-named option has been found by the most
        -: 3628:   recent call.
        -: 3629:
        -: 3630:   If LONG_ONLY is nonzero, '-' as well as '--' can introduce
        -: 3631:   long-named options.  */
        -: 3632:
        -: 3633:int
        -: 3634:_getopt_internal (argc, argv, optstring, longopts, longind, long_only)
        -: 3635:     int argc;
        -: 3636:     char *const *argv;
        -: 3637:     const char *optstring;
        -: 3638:     const struct option *longopts;
        -: 3639:     int *longind;
        -: 3640:     int long_only;
        -: 3641:{
        -: 3642:  optarg = NULL;
        -: 3643:
        -: 3644:  if (optind == 0 || !__getopt_initialized)
        -: 3645:    {
        -: 3646:      if (optind == 0)
        -: 3647:	optind = 1;	/* Don't scan ARGV[0], the program name.  */
        -: 3648:      optstring = _getopt_initialize (argc, argv, optstring);
        -: 3649:      __getopt_initialized = 1;
        -: 3650:    }
        -: 3651:
        -: 3652:  /* Test whether ARGV[optind] points to a non-option argument.
        -: 3653:     Either it does not have option syntax, or there is an environment flag
        -: 3654:     from the shell indicating it is not an option.  The later information
        -: 3655:     is only used when the used in the GNU libc.  */
        -: 3656:#ifdef _LIBC
        -: 3657:# define NONOPTION_P (argv[optind][0] != '-' || argv[optind][1] == '\0'	      \
        -: 3658:		      || (optind < nonoption_flags_len			      \
        -: 3659:			  && __getopt_nonoption_flags[optind] == '1'))
        -: 3660:#else
        -: 3661:# define NONOPTION_P (argv[optind][0] != '-' || argv[optind][1] == '\0')
        -: 3662:#endif
        -: 3663:
        -: 3664:  if (nextchar == NULL || *nextchar == '\0')
        -: 3665:    {
        -: 3666:      /* Advance to the next ARGV-element.  */
        -: 3667:
        -: 3668:      /* Give FIRST_NONOPT & LAST_NONOPT rational values if OPTIND has been
        -: 3669:	 moved back by the user (who may also have changed the arguments).  */
        -: 3670:      if (last_nonopt > optind)
        -: 3671:	last_nonopt = optind;
        -: 3672:      if (first_nonopt > optind)
        -: 3673:	first_nonopt = optind;
        -: 3674:
        -: 3675:      if (ordering == PERMUTE)
        -: 3676:	{
        -: 3677:	  /* If we have just processed some options following some non-options,
        -: 3678:	     exchange them so that the options come first.  */
        -: 3679:
        -: 3680:	  if (first_nonopt != last_nonopt && last_nonopt != optind)
        -: 3681:	    exchange ((char **) argv);
        -: 3682:	  else if (last_nonopt != optind)
        -: 3683:	    first_nonopt = optind;
        -: 3684:
        -: 3685:	  /* Skip any additional non-options
        -: 3686:	     and extend the range of non-options previously skipped.  */
        -: 3687:
        -: 3688:	  while (optind < argc && NONOPTION_P)
        -: 3689:	    optind++;
        -: 3690:	  last_nonopt = optind;
        -: 3691:	}
        -: 3692:
        -: 3693:      /* The special ARGV-element `--' means premature end of options.
        -: 3694:	 Skip it like a null option,
        -: 3695:	 then exchange with previous non-options as if it were an option,
        -: 3696:	 then skip everything else like a non-option.  */
        -: 3697:
        -: 3698:      if (optind != argc && !strcmp (argv[optind], "--"))
        -: 3699:	{
        -: 3700:	  optind++;
        -: 3701:
        -: 3702:	  if (first_nonopt != last_nonopt && last_nonopt != optind)
        -: 3703:	    exchange ((char **) argv);
        -: 3704:	  else if (first_nonopt == last_nonopt)
        -: 3705:	    first_nonopt = optind;
        -: 3706:	  last_nonopt = argc;
        -: 3707:
        -: 3708:	  optind = argc;
        -: 3709:	}
        -: 3710:
        -: 3711:      /* If we have done all the ARGV-elements, stop the scan
        -: 3712:	 and back over any non-options that we skipped and permuted.  */
        -: 3713:
        -: 3714:      if (optind == argc)
        -: 3715:	{
        -: 3716:	  /* Set the next-arg-index to point at the non-options
        -: 3717:	     that we previously skipped, so the caller will digest them.  */
        -: 3718:	  if (first_nonopt != last_nonopt)
        -: 3719:	    optind = first_nonopt;
        -: 3720:	  return -1;
        -: 3721:	}
        -: 3722:
        -: 3723:      /* If we have come to a non-option and did not permute it,
        -: 3724:	 either stop the scan or describe it to the caller and pass it by.  */
        -: 3725:
        -: 3726:      if (NONOPTION_P)
        -: 3727:	{
        -: 3728:	  if (ordering == REQUIRE_ORDER)
        -: 3729:	    return -1;
        -: 3730:	  optarg = argv[optind++];
        -: 3731:	  return 1;
        -: 3732:	}
        -: 3733:
        -: 3734:      /* We have found another option-ARGV-element.
        -: 3735:	 Skip the initial punctuation.  */
        -: 3736:
        -: 3737:      nextchar = (argv[optind] + 1
        -: 3738:		  + (longopts != NULL && argv[optind][1] == '-'));
        -: 3739:    }
        -: 3740:
        -: 3741:  /* Decode the current option-ARGV-element.  */
        -: 3742:
        -: 3743:  /* Check whether the ARGV-element is a long option.
        -: 3744:
        -: 3745:     If long_only and the ARGV-element has the form "-f", where f is
        -: 3746:     a valid short option, don't consider it an abbreviated form of
        -: 3747:     a long option that starts with f.  Otherwise there would be no
        -: 3748:     way to give the -f short option.
        -: 3749:
        -: 3750:     On the other hand, if there's a long option "fubar" and
        -: 3751:     the ARGV-element is "-fu", do consider that an abbreviation of
        -: 3752:     the long option, just like "--fu", and not "-f" with arg "u".
        -: 3753:
        -: 3754:     This distinction seems to be the most useful approach.  */
        -: 3755:
        -: 3756:  if (longopts != NULL
        -: 3757:      && (argv[optind][1] == '-'
        -: 3758:	  || (long_only && (argv[optind][2] || !my_index (optstring, argv[optind][1])))))
        -: 3759:    {
        -: 3760:      char *nameend;
        -: 3761:      const struct option *p;
        -: 3762:      const struct option *pfound = NULL;
        -: 3763:      int exact = 0;
        -: 3764:      int ambig = 0;
        -: 3765:      int indfound = -1;
        -: 3766:      int option_index;
        -: 3767:
        -: 3768:      for (nameend = nextchar; *nameend && *nameend != '='; nameend++)
        -: 3769:	/* Do nothing.  */ ;
        -: 3770:
        -: 3771:      /* Test all long options for either exact match
        -: 3772:	 or abbreviated matches.  */
        -: 3773:      for (p = longopts, option_index = 0; p->name; p++, option_index++)
        -: 3774:	if (!strncmp (p->name, nextchar, nameend - nextchar))
        -: 3775:	  {
        -: 3776:	    if ((unsigned int) (nameend - nextchar)
        -: 3777:		== (unsigned int) strlen (p->name))
        -: 3778:	      {
        -: 3779:		/* Exact match found.  */
        -: 3780:		pfound = p;
        -: 3781:		indfound = option_index;
        -: 3782:		exact = 1;
        -: 3783:		break;
        -: 3784:	      }
        -: 3785:	    else if (pfound == NULL)
        -: 3786:	      {
        -: 3787:		/* First nonexact match found.  */
        -: 3788:		pfound = p;
        -: 3789:		indfound = option_index;
        -: 3790:	      }
        -: 3791:	    else
        -: 3792:	      /* Second or later nonexact match found.  */
        -: 3793:	      ambig = 1;
        -: 3794:	  }
        -: 3795:
        -: 3796:      if (ambig && !exact)
        -: 3797:	{
        -: 3798:	  if (opterr)
        -: 3799:	    fprintf (stderr, _("%s: option `%s' is ambiguous\n"),
        -: 3800:		     argv[0], argv[optind]);
        -: 3801:	  nextchar += strlen (nextchar);
        -: 3802:	  optind++;
        -: 3803:	  optopt = 0;
        -: 3804:	  return '?';
        -: 3805:	}
        -: 3806:
        -: 3807:      if (pfound != NULL)
        -: 3808:	{
        -: 3809:	  option_index = indfound;
        -: 3810:	  optind++;
        -: 3811:	  if (*nameend)
        -: 3812:	    {
        -: 3813:	      /* Don't test has_arg with >, because some C compilers don't
        -: 3814:		 allow it to be used on enums.  */
        -: 3815:	      if (pfound->has_arg)
        -: 3816:		optarg = nameend + 1;
        -: 3817:	      else
        -: 3818:		{
        -: 3819:		  if (opterr)
        -: 3820:		   if (argv[optind - 1][1] == '-')
        -: 3821:		    /* --option */
        -: 3822:		    fprintf (stderr,
        -: 3823:		     _("%s: option `--%s' doesn't allow an argument\n"),
        -: 3824:		     argv[0], pfound->name);
        -: 3825:		   else
        -: 3826:		    /* +option or -option */
        -: 3827:		    fprintf (stderr,
        -: 3828:		     _("%s: option `%c%s' doesn't allow an argument\n"),
        -: 3829:		     argv[0], argv[optind - 1][0], pfound->name);
        -: 3830:
        -: 3831:		  nextchar += strlen (nextchar);
        -: 3832:
        -: 3833:		  optopt = pfound->val;
        -: 3834:		  return '?';
        -: 3835:		}
        -: 3836:	    }
        -: 3837:	  else if (pfound->has_arg == 1)
        -: 3838:	    {
        -: 3839:	      if (optind < argc)
        -: 3840:		optarg = argv[optind++];
        -: 3841:	      else
        -: 3842:		{
        -: 3843:		  if (opterr)
        -: 3844:		    fprintf (stderr,
        -: 3845:			   _("%s: option `%s' requires an argument\n"),
        -: 3846:			   argv[0], argv[optind - 1]);
        -: 3847:		  nextchar += strlen (nextchar);
        -: 3848:		  optopt = pfound->val;
        -: 3849:		  return optstring[0] == ':' ? ':' : '?';
        -: 3850:		}
        -: 3851:	    }
        -: 3852:	  nextchar += strlen (nextchar);
        -: 3853:	  if (longind != NULL)
        -: 3854:	    *longind = option_index;
        -: 3855:	  if (pfound->flag)
        -: 3856:	    {
        -: 3857:	      *(pfound->flag) = pfound->val;
        -: 3858:	      return 0;
        -: 3859:	    }
        -: 3860:	  return pfound->val;
        -: 3861:	}
        -: 3862:
        -: 3863:      /* Can't find it as a long option.  If this is not getopt_long_only,
        -: 3864:	 or the option starts with '--' or is not a valid short
        -: 3865:	 option, then it's an error.
        -: 3866:	 Otherwise interpret it as a short option.  */
        -: 3867:      if (!long_only || argv[optind][1] == '-'
        -: 3868:	  || my_index (optstring, *nextchar) == NULL)
        -: 3869:	{
        -: 3870:	  if (opterr)
        -: 3871:	    {
        -: 3872:	      if (argv[optind][1] == '-')
        -: 3873:		/* --option */
        -: 3874:		fprintf (stderr, _("%s: unrecognized option `--%s'\n"),
        -: 3875:			 argv[0], nextchar);
        -: 3876:	      else
        -: 3877:		/* +option or -option */
        -: 3878:		fprintf (stderr, _("%s: unrecognized option `%c%s'\n"),
        -: 3879:			 argv[0], argv[optind][0], nextchar);
        -: 3880:	    }
        -: 3881:	  nextchar = (char *) "";
        -: 3882:	  optind++;
        -: 3883:	  optopt = 0;
        -: 3884:	  return '?';
        -: 3885:	}
        -: 3886:    }
        -: 3887:
        -: 3888:  /* Look at and handle the next short option-character.  */
        -: 3889:
        -: 3890:  {
        -: 3891:    char c = *nextchar++;
        -: 3892:    char *temp = my_index (optstring, c);
        -: 3893:
        -: 3894:    /* Increment `optind' when we start to process its last character.  */
        -: 3895:    if (*nextchar == '\0')
        -: 3896:      ++optind;
        -: 3897:
        -: 3898:    if (temp == NULL || c == ':')
        -: 3899:      {
        -: 3900:	if (opterr)
        -: 3901:	  {
        -: 3902:	    if (posixly_correct)
        -: 3903:	      /* 1003.2 specifies the format of this message.  */
        -: 3904:	      fprintf (stderr, _("%s: illegal option -- %c\n"),
        -: 3905:		       argv[0], c);
        -: 3906:	    else
        -: 3907:	      fprintf (stderr, _("%s: invalid option -- %c\n"),
        -: 3908:		       argv[0], c);
        -: 3909:	  }
        -: 3910:	optopt = c;
        -: 3911:	return '?';
        -: 3912:      }
        -: 3913:    /* Convenience. Treat POSIX -W foo same as long option --foo */
        -: 3914:    if (temp[0] == 'W' && temp[1] == ';')
        -: 3915:      {
        -: 3916:	char *nameend;
        -: 3917:	const struct option *p;
        -: 3918:	const struct option *pfound = NULL;
        -: 3919:	int exact = 0;
        -: 3920:	int ambig = 0;
        -: 3921:	int indfound = 0;
        -: 3922:	int option_index;
        -: 3923:
        -: 3924:	/* This is an option that requires an argument.  */
        -: 3925:	if (*nextchar != '\0')
        -: 3926:	  {
        -: 3927:	    optarg = nextchar;
        -: 3928:	    /* If we end this ARGV-element by taking the rest as an arg,
        -: 3929:	       we must advance to the next element now.  */
        -: 3930:	    optind++;
        -: 3931:	  }
        -: 3932:	else if (optind == argc)
        -: 3933:	  {
        -: 3934:	    if (opterr)
        -: 3935:	      {
        -: 3936:		/* 1003.2 specifies the format of this message.  */
        -: 3937:		fprintf (stderr, _("%s: option requires an argument -- %c\n"),
        -: 3938:			 argv[0], c);
        -: 3939:	      }
        -: 3940:	    optopt = c;
        -: 3941:	    if (optstring[0] == ':')
        -: 3942:	      c = ':';
        -: 3943:	    else
        -: 3944:	      c = '?';
        -: 3945:	    return c;
        -: 3946:	  }
        -: 3947:	else
        -: 3948:	  /* We already incremented `optind' once;
        -: 3949:	     increment it again when taking next ARGV-elt as argument.  */
        -: 3950:	  optarg = argv[optind++];
        -: 3951:
        -: 3952:	/* optarg is now the argument, see if it's in the
        -: 3953:	   table of longopts.  */
        -: 3954:
        -: 3955:	for (nextchar = nameend = optarg; *nameend && *nameend != '='; nameend++)
        -: 3956:	  /* Do nothing.  */ ;
        -: 3957:
        -: 3958:	/* Test all long options for either exact match
        -: 3959:	   or abbreviated matches.  */
        -: 3960:	for (p = longopts, option_index = 0; p->name; p++, option_index++)
        -: 3961:	  if (!strncmp (p->name, nextchar, nameend - nextchar))
        -: 3962:	    {
        -: 3963:	      if ((unsigned int) (nameend - nextchar) == strlen (p->name))
        -: 3964:		{
        -: 3965:		  /* Exact match found.  */
        -: 3966:		  pfound = p;
        -: 3967:		  indfound = option_index;
        -: 3968:		  exact = 1;
        -: 3969:		  break;
        -: 3970:		}
        -: 3971:	      else if (pfound == NULL)
        -: 3972:		{
        -: 3973:		  /* First nonexact match found.  */
        -: 3974:		  pfound = p;
        -: 3975:		  indfound = option_index;
        -: 3976:		}
        -: 3977:	      else
        -: 3978:		/* Second or later nonexact match found.  */
        -: 3979:		ambig = 1;
        -: 3980:	    }
        -: 3981:	if (ambig && !exact)
        -: 3982:	  {
        -: 3983:	    if (opterr)
        -: 3984:	      fprintf (stderr, _("%s: option `-W %s' is ambiguous\n"),
        -: 3985:		       argv[0], argv[optind]);
        -: 3986:	    nextchar += strlen (nextchar);
        -: 3987:	    optind++;
        -: 3988:	    return '?';
        -: 3989:	  }
        -: 3990:	if (pfound != NULL)
        -: 3991:	  {
        -: 3992:	    option_index = indfound;
        -: 3993:	    if (*nameend)
        -: 3994:	      {
        -: 3995:		/* Don't test has_arg with >, because some C compilers don't
        -: 3996:		   allow it to be used on enums.  */
        -: 3997:		if (pfound->has_arg)
        -: 3998:		  optarg = nameend + 1;
        -: 3999:		else
        -: 4000:		  {
        -: 4001:		    if (opterr)
        -: 4002:		      fprintf (stderr, _("\
        -: 4003:%s: option `-W %s' doesn't allow an argument\n"),
        -: 4004:			       argv[0], pfound->name);
        -: 4005:
        -: 4006:		    nextchar += strlen (nextchar);
        -: 4007:		    return '?';
        -: 4008:		  }
        -: 4009:	      }
        -: 4010:	    else if (pfound->has_arg == 1)
        -: 4011:	      {
        -: 4012:		if (optind < argc)
        -: 4013:		  optarg = argv[optind++];
        -: 4014:		else
        -: 4015:		  {
        -: 4016:		    if (opterr)
        -: 4017:		      fprintf (stderr,
        -: 4018:			       _("%s: option `%s' requires an argument\n"),
        -: 4019:			       argv[0], argv[optind - 1]);
        -: 4020:		    nextchar += strlen (nextchar);
        -: 4021:		    return optstring[0] == ':' ? ':' : '?';
        -: 4022:		  }
        -: 4023:	      }
        -: 4024:	    nextchar += strlen (nextchar);
        -: 4025:	    if (longind != NULL)
        -: 4026:	      *longind = option_index;
        -: 4027:	    if (pfound->flag)
        -: 4028:	      {
        -: 4029:		*(pfound->flag) = pfound->val;
        -: 4030:		return 0;
        -: 4031:	      }
        -: 4032:	    return pfound->val;
        -: 4033:	  }
        -: 4034:	  nextchar = NULL;
        -: 4035:	  return 'W';	/* Let the application handle it.   */
        -: 4036:      }
        -: 4037:    if (temp[1] == ':')
        -: 4038:      {
        -: 4039:	if (temp[2] == ':')
        -: 4040:	  {
        -: 4041:	    /* This is an option that accepts an argument optionally.  */
        -: 4042:	    if (*nextchar != '\0')
        -: 4043:	      {
        -: 4044:		optarg = nextchar;
        -: 4045:		optind++;
        -: 4046:	      }
        -: 4047:	    else
        -: 4048:	      optarg = NULL;
        -: 4049:	    nextchar = NULL;
        -: 4050:	  }
        -: 4051:	else
        -: 4052:	  {
        -: 4053:	    /* This is an option that requires an argument.  */
        -: 4054:	    if (*nextchar != '\0')
        -: 4055:	      {
        -: 4056:		optarg = nextchar;
        -: 4057:		/* If we end this ARGV-element by taking the rest as an arg,
        -: 4058:		   we must advance to the next element now.  */
        -: 4059:		optind++;
        -: 4060:	      }
        -: 4061:	    else if (optind == argc)
        -: 4062:	      {
        -: 4063:		if (opterr)
        -: 4064:		  {
        -: 4065:		    /* 1003.2 specifies the format of this message.  */
        -: 4066:		    fprintf (stderr,
        -: 4067:			   _("%s: option requires an argument -- %c\n"),
        -: 4068:			   argv[0], c);
        -: 4069:		  }
        -: 4070:		optopt = c;
        -: 4071:		if (optstring[0] == ':')
        -: 4072:		  c = ':';
        -: 4073:		else
        -: 4074:		  c = '?';
        -: 4075:	      }
        -: 4076:	    else
        -: 4077:	      /* We already incremented `optind' once;
        -: 4078:		 increment it again when taking next ARGV-elt as argument.  */
        -: 4079:	      optarg = argv[optind++];
        -: 4080:	    nextchar = NULL;
        -: 4081:	  }
        -: 4082:      }
        -: 4083:    return c;
        -: 4084:  }
        -: 4085:}
        -: 4086:
        -: 4087:int
        -: 4088:getopt (argc, argv, optstring)
        -: 4089:     int argc;
        -: 4090:     char *const *argv;
        -: 4091:     const char *optstring;
        -: 4092:{
        -: 4093:  return _getopt_internal (argc, argv, optstring,
        -: 4094:			   (const struct option *) 0,
        -: 4095:			   (int *) 0,
        -: 4096:			   0);
        -: 4097:}
        -: 4098:
        -: 4099:#endif	/* Not ELIDE_CODE.  */
        -: 4100:
        -: 4101:#ifdef TEST
        -: 4102:
        -: 4103:/* Compile with -DTEST to make an executable for use in testing
        -: 4104:   the above definition of `getopt'.  */
        -: 4105:
        -: 4106:int
        -: 4107:main (argc, argv)
        -: 4108:     int argc;
        -: 4109:     char **argv;
        -: 4110:{
        -: 4111:  int c;
        -: 4112:  int digit_optind = 0;
        -: 4113:
        -: 4114:  while (1)
        -: 4115:    {
        -: 4116:      int this_option_optind = optind ? optind : 1;
        -: 4117:
        -: 4118:      c = getopt (argc, argv, "abc:d:0123456789");
        -: 4119:      if (c == -1)
        -: 4120:	break;
        -: 4121:
        -: 4122:      switch (c)
        -: 4123:	{
        -: 4124:	case '0':
        -: 4125:	case '1':
        -: 4126:	case '2':
        -: 4127:	case '3':
        -: 4128:	case '4':
        -: 4129:	case '5':
        -: 4130:	case '6':
        -: 4131:	case '7':
        -: 4132:	case '8':
        -: 4133:	case '9':
        -: 4134:	  if (digit_optind != 0 && digit_optind != this_option_optind)
        -: 4135:	    printf ("digits occur in two different argv-elements.\n");
        -: 4136:	  digit_optind = this_option_optind;
        -: 4137:	  printf ("option %c\n", c);
        -: 4138:	  break;
        -: 4139:
        -: 4140:	case 'a':
        -: 4141:	  printf ("option a\n");
        -: 4142:	  break;
        -: 4143:
        -: 4144:	case 'b':
        -: 4145:	  printf ("option b\n");
        -: 4146:	  break;
        -: 4147:
        -: 4148:	case 'c':
        -: 4149:	  printf ("option c with value `%s'\n", optarg);
        -: 4150:	  break;
        -: 4151:
        -: 4152:	case '?':
        -: 4153:	  break;
        -: 4154:
        -: 4155:	default:
        -: 4156:	  printf ("?? getopt returned character code 0%o ??\n", c);
        -: 4157:	}
        -: 4158:    }
        -: 4159:
        -: 4160:  if (optind < argc)
        -: 4161:    {
        -: 4162:      printf ("non-option ARGV-elements: ");
        -: 4163:      while (optind < argc)
        -: 4164:	printf ("%s ", argv[optind++]);
        -: 4165:      printf ("\n");
        -: 4166:    }
        -: 4167:
        -: 4168:  exit (0);
        -: 4169:}
        -: 4170:
        -: 4171:#endif /* TEST */
        -: 4172:/* Extended regular expression matching and search library,
        -: 4173:   version 0.12.
        -: 4174:   (Implements POSIX draft P1003.2/D11.2, except for some of the
        -: 4175:   internationalization features.)
        -: 4176:   Copyright (C) 1993, 94, 95, 96, 97, 98 Free Software Foundation, Inc.
        -: 4177:
        -: 4178:   NOTE: The canonical source of this file is maintained with the GNU C Library.
        -: 4179:   Bugs can be reported to bug-glibc@gnu.org.
        -: 4180:
        -: 4181:   This program is free software; you can redistribute it and/or modify it
        -: 4182:   under the terms of the GNU General Public License as published by the
        -: 4183:   Free Software Foundation; either version 2, or (at your option) any
        -: 4184:   later version.
        -: 4185:
        -: 4186:   This program is distributed in the hope that it will be useful,
        -: 4187:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 4188:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 4189:   GNU General Public License for more details.
        -: 4190:
        -: 4191:   You should have received a copy of the GNU General Public License
        -: 4192:   along with this program; if not, write to the Free Software
        -: 4193:   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
        -: 4194:   USA.  */
        -: 4195:
        -: 4196:/* AIX requires this to be the first thing in the file. */
        -: 4197:#if defined _AIX && !defined REGEX_MALLOC
        -: 4198:  #pragma alloca
        -: 4199:#endif
        -: 4200:
        -: 4201:#undef	_GNU_SOURCE
        -: 4202:#define _GNU_SOURCE
        -: 4203:
        -: 4204:#ifdef HAVE_CONFIG_H
        -: 4205:# include <config.h>
        -: 4206:#endif
        -: 4207:
        -: 4208:#ifndef PARAMS
        -: 4209:# if defined __GNUC__ || (defined __STDC__ && __STDC__)
        -: 4210:#  define PARAMS(args) args
        -: 4211:# else
        -: 4212:#  define PARAMS(args) ()
        -: 4213:# endif  /* GCC.  */
        -: 4214:#endif  /* Not PARAMS.  */
        -: 4215:
        -: 4216:#if defined STDC_HEADERS && !defined emacs
        -: 4217:# include <stddef.h>
        -: 4218:#else
        -: 4219:/* We need this for `regex-gnu.h', and perhaps for the Emacs include files.  */
        -: 4220:# include <sys/types.h>
        -: 4221:#endif
        -: 4222:
        -: 4223:/* For platform which support the ISO C amendement 1 functionality we
        -: 4224:   support user defined character classes.  */
        -: 4225:#if defined _LIBC || (defined HAVE_WCTYPE_H && defined HAVE_WCHAR_H)
        -: 4226:# include <wctype.h>
        -: 4227:# include <wchar.h>
        -: 4228:
        -: 4229:/* We have to keep the namespace clean.  */
        -: 4230:# define regfree(preg) __regfree (preg)
        -: 4231:# define regexec(pr, st, nm, pm, ef) __regexec (pr, st, nm, pm, ef)
        -: 4232:# define regnexec(pr, st, ln, nm, pm, ef) __regnexec (pr, st, ln, nm, pm, ef)
        -: 4233:# define regcomp(preg, pattern, cflags) __regcomp (preg, pattern, cflags)
        -: 4234:# define regerror(errcode, preg, errbuf, errbuf_size) \
        -: 4235:	__regerror(errcode, preg, errbuf, errbuf_size)
        -: 4236:# define re_set_registers(bu, re, nu, st, en) \
        -: 4237:	__re_set_registers (bu, re, nu, st, en)
        -: 4238:# define re_match_2(bufp, string1, size1, string2, size2, pos, regs, stop) \
        -: 4239:	__re_match_2 (bufp, string1, size1, string2, size2, pos, regs, stop)
        -: 4240:# define re_match(bufp, string, size, pos, regs) \
        -: 4241:	__re_match (bufp, string, size, pos, regs)
        -: 4242:# define re_search(bufp, string, size, startpos, range, regs) \
        -: 4243:	__re_search (bufp, string, size, startpos, range, regs)
        -: 4244:# define re_compile_pattern(pattern, length, bufp) \
        -: 4245:	__re_compile_pattern (pattern, length, bufp)
        -: 4246:# define re_set_syntax(syntax) __re_set_syntax (syntax)
        -: 4247:# define re_search_2(bufp, st1, s1, st2, s2, startpos, range, regs, stop) \
        -: 4248:	__re_search_2 (bufp, st1, s1, st2, s2, startpos, range, regs, stop)
        -: 4249:# define re_compile_fastmap(bufp) __re_compile_fastmap (bufp)
        -: 4250:
        -: 4251:#define btowc __btowc
        -: 4252:#endif
        -: 4253:
        -: 4254:/* This is for other GNU distributions with internationalized messages.  */
        -: 4255:#if HAVE_LIBINTL_H || defined _LIBC
        -: 4256:# include <libintl.h>
        -: 4257:#else
        -: 4258:# define gettext(msgid) (msgid)
        -: 4259:#endif
        -: 4260:
        -: 4261:#ifndef gettext_noop
        -: 4262:/* This define is so xgettext can find the internationalizable
        -: 4263:   strings.  */
        -: 4264:# define gettext_noop(String) String
        -: 4265:#endif
        -: 4266:
        -: 4267:/* The `emacs' switch turns on certain matching commands
        -: 4268:   that make sense only in Emacs. */
        -: 4269:#ifdef emacs
        -: 4270:
        -: 4271:# include "lisp.h"
        -: 4272:# include "buffer.h"
        -: 4273:# include "syntax.h"
        -: 4274:
        -: 4275:#else  /* not emacs */
        -: 4276:
        -: 4277:/* If we are not linking with Emacs proper,
        -: 4278:   we can't use the relocating allocator
        -: 4279:   even if config.h says that we can.  */
        -: 4280:# undef REL_ALLOC
        -: 4281:
        -: 4282:# if defined STDC_HEADERS || defined _LIBC
        -: 4283:#  include <stdlib.h>
        -: 4284:# else
        -: 4285:char *malloc ();
        -: 4286:char *realloc ();
        -: 4287:# endif
        -: 4288:
        -: 4289:/* When used in Emacs's lib-src, we need to get bzero and bcopy somehow.
        -: 4290:   If nothing else has been done, use the method below.  */
        -: 4291:# ifdef INHIBIT_STRING_HEADER
        -: 4292:#  if !(defined HAVE_BZERO && defined HAVE_BCOPY)
        -: 4293:#   if !defined bzero && !defined bcopy
        -: 4294:#    undef INHIBIT_STRING_HEADER
        -: 4295:#   endif
        -: 4296:#  endif
        -: 4297:# endif
        -: 4298:
        -: 4299:/* This is the normal way of making sure we have a bcopy and a bzero.
        -: 4300:   This is used in most programs--a few other programs avoid this
        -: 4301:   by defining INHIBIT_STRING_HEADER.  */
        -: 4302:# ifndef INHIBIT_STRING_HEADER
        -: 4303:#  if defined HAVE_STRING_H || defined STDC_HEADERS || defined _LIBC
        -: 4304:#   include <string.h>
        -: 4305:#   ifndef bzero
        -: 4306:#    ifndef _LIBC
        -: 4307:#     define bzero(s, n)	(memset (s, '\0', n), (s))
        -: 4308:#    else
        -: 4309:#     define bzero(s, n)	__bzero (s, n)
        -: 4310:#    endif
        -: 4311:#   endif
        -: 4312:#  else
        -: 4313:#   include <strings.h>
        -: 4314:#   ifndef memcmp
        -: 4315:#    define memcmp(s1, s2, n)	bcmp (s1, s2, n)
        -: 4316:#   endif
        -: 4317:#   ifndef memcpy
        -: 4318:#    define memcpy(d, s, n)	(bcopy (s, d, n), (d))
        -: 4319:#   endif
        -: 4320:#  endif
        -: 4321:# endif
        -: 4322:
        -: 4323:/* Define the syntax stuff for \<, \>, etc.  */
        -: 4324:
        -: 4325:/* This must be nonzero for the wordchar and notwordchar pattern
        -: 4326:   commands in re_match_2.  */
        -: 4327:# ifndef Sword
        -: 4328:#  define Sword 1
        -: 4329:# endif
        -: 4330:
        -: 4331:# ifdef SWITCH_ENUM_BUG
        -: 4332:#  define SWITCH_ENUM_CAST(x) ((int)(x))
        -: 4333:# else
        -: 4334:#  define SWITCH_ENUM_CAST(x) (x)
        -: 4335:# endif
        -: 4336:
        -: 4337:/* How many characters in the character set.  */
        -: 4338:# define CHAR_SET_SIZE 256
        -: 4339:
        -: 4340:# ifdef SYNTAX_TABLE
        -: 4341:
        -: 4342:extern char *re_syntax_table;
        -: 4343:
        -: 4344:# else /* not SYNTAX_TABLE */
        -: 4345:
        -: 4346:static char re_syntax_table[CHAR_SET_SIZE];
        -: 4347:
        -: 4348:static void
function init_syntax_once called 622 returned 100% blocks executed 100%
      622: 4349:init_syntax_once ()
        -: 4350:{
        -: 4351:   register int c;
        -: 4352:   static int done = 0;
        -: 4353:
      622: 4354:   if (done)
branch  0 taken 316 (fallthrough)
branch  1 taken 306
      316: 4355:     return;
        -: 4356:
      306: 4357:   bzero (re_syntax_table, sizeof re_syntax_table);
        -: 4358:
     8262: 4359:   for (c = 'a'; c <= 'z'; c++)
branch  0 taken 7956
branch  1 taken 306 (fallthrough)
     7956: 4360:     re_syntax_table[c] = Sword;
        -: 4361:
     8262: 4362:   for (c = 'A'; c <= 'Z'; c++)
branch  0 taken 7956
branch  1 taken 306 (fallthrough)
     7956: 4363:     re_syntax_table[c] = Sword;
        -: 4364:
     3366: 4365:   for (c = '0'; c <= '9'; c++)
branch  0 taken 3060
branch  1 taken 306 (fallthrough)
     3060: 4366:     re_syntax_table[c] = Sword;
        -: 4367:
      306: 4368:   re_syntax_table['_'] = Sword;
        -: 4369:
      306: 4370:   done = 1;
        -: 4371:}
        -: 4372:
        -: 4373:# endif /* not SYNTAX_TABLE */
        -: 4374:
        -: 4375:# define SYNTAX(c) re_syntax_table[c]
        -: 4376:
        -: 4377:#endif /* not emacs */
        -: 4378:
        -: 4379:/* Get the interface, including the syntax bits.  */
        -: 4380:#include "regex-gnu.h"
        -: 4381:
        -: 4382:/* isalpha etc. are used for the character classes.  */
        -: 4383:#include <ctype.h>
        -: 4384:
        -: 4385:/* Jim Meyering writes:
        -: 4386:
        -: 4387:   "... Some ctype macros are valid only for character codes that
        -: 4388:   isascii says are ASCII (SGI's IRIX-4.0.5 is one such system --when
        -: 4389:   using /bin/cc or gcc but without giving an ansi option).  So, all
        -: 4390:   ctype uses should be through macros like ISPRINT...  If
        -: 4391:   STDC_HEADERS is defined, then autoconf has verified that the ctype
        -: 4392:   macros don't need to be guarded with references to isascii. ...
        -: 4393:   Defining isascii to 1 should let any compiler worth its salt
        -: 4394:   eliminate the && through constant folding."
        -: 4395:   Solaris defines some of these symbols so we must undefine them first.  */
        -: 4396:
        -: 4397:#undef ISASCII
        -: 4398:#if defined STDC_HEADERS || (!defined isascii && !defined HAVE_ISASCII)
        -: 4399:# define ISASCII(c) 1
        -: 4400:#else
        -: 4401:# define ISASCII(c) isascii(c)
        -: 4402:#endif
        -: 4403:
        -: 4404:#ifdef isblank
        -: 4405:# define ISBLANK(c) (ISASCII (c) && isblank (c))
        -: 4406:#else
        -: 4407:# define ISBLANK(c) ((c) == ' ' || (c) == '\t')
        -: 4408:#endif
        -: 4409:#ifdef isgraph
        -: 4410:# define ISGRAPH(c) (ISASCII (c) && isgraph (c))
        -: 4411:#else
        -: 4412:# define ISGRAPH(c) (ISASCII (c) && isprint (c) && !isspace (c))
        -: 4413:#endif
        -: 4414:
        -: 4415:#undef ISPRINT
        -: 4416:#define ISPRINT(c) (ISASCII (c) && isprint (c))
        -: 4417:#define ISDIGIT(c) (ISASCII (c) && isdigit (c))
        -: 4418:#define ISALNUM(c) (ISASCII (c) && isalnum (c))
        -: 4419:#define ISALPHA(c) (ISASCII (c) && isalpha (c))
        -: 4420:#define ISCNTRL(c) (ISASCII (c) && iscntrl (c))
        -: 4421:#define ISLOWER(c) (ISASCII (c) && islower (c))
        -: 4422:#define ISPUNCT(c) (ISASCII (c) && ispunct (c))
        -: 4423:#define ISSPACE(c) (ISASCII (c) && isspace (c))
        -: 4424:#define ISUPPER(c) (ISASCII (c) && isupper (c))
        -: 4425:#define ISXDIGIT(c) (ISASCII (c) && isxdigit (c))
        -: 4426:
        -: 4427:#ifndef NULL
        -: 4428:# define NULL (void *)0
        -: 4429:#endif
        -: 4430:
        -: 4431:/* We remove any previous definition of `SIGN_EXTEND_CHAR',
        -: 4432:   since ours (we hope) works properly with all combinations of
        -: 4433:   machines, compilers, `char' and `unsigned char' argument types.
        -: 4434:   (Per Bothner suggested the basic approach.)  */
        -: 4435:#undef SIGN_EXTEND_CHAR
        -: 4436:#if __STDC__
        -: 4437:# define SIGN_EXTEND_CHAR(c) ((signed char) (c))
        -: 4438:#else  /* not __STDC__ */
        -: 4439:/* As in Harbison and Steele.  */
        -: 4440:# define SIGN_EXTEND_CHAR(c) ((((unsigned char) (c)) ^ 128) - 128)
        -: 4441:#endif
        -: 4442:
        -: 4443:/* Should we use malloc or alloca?  If REGEX_MALLOC is not defined, we
        -: 4444:   use `alloca' instead of `malloc'.  This is because using malloc in
        -: 4445:   re_search* or re_match* could cause memory leaks when C-g is used in
        -: 4446:   Emacs; also, malloc is slower and causes storage fragmentation.  On
        -: 4447:   the other hand, malloc is more portable, and easier to debug.
        -: 4448:
        -: 4449:   Because we sometimes use alloca, some routines have to be macros,
        -: 4450:   not functions -- `alloca'-allocated space disappears at the end of the
        -: 4451:   function it is called in.  */
        -: 4452:
        -: 4453:#ifdef REGEX_MALLOC
        -: 4454:
        -: 4455:# define REGEX_ALLOCATE malloc
        -: 4456:# define REGEX_REALLOCATE(source, osize, nsize) realloc (source, nsize)
        -: 4457:# define REGEX_FREE free
        -: 4458:
        -: 4459:#else /* not REGEX_MALLOC  */
        -: 4460:
        -: 4461:/* Emacs already defines alloca, sometimes.  */
        -: 4462:# ifndef alloca
        -: 4463:
        -: 4464:/* Make alloca work the best possible way.  */
        -: 4465:#  ifdef __GNUC__
        -: 4466:#   define alloca __builtin_alloca
        -: 4467:#  else /* not __GNUC__ */
        -: 4468:#   if HAVE_ALLOCA_H
        -: 4469:#    include <alloca.h>
        -: 4470:#   endif /* HAVE_ALLOCA_H */
        -: 4471:#  endif /* not __GNUC__ */
        -: 4472:
        -: 4473:# endif /* not alloca */
        -: 4474:
        -: 4475:# define REGEX_ALLOCATE alloca
        -: 4476:
        -: 4477:/* Assumes a `char *destination' variable.  */
        -: 4478:# define REGEX_REALLOCATE(source, osize, nsize)				\
        -: 4479:  (destination = (char *) alloca (nsize),				\
        -: 4480:   memcpy (destination, source, osize))
        -: 4481:
        -: 4482:/* No need to do anything to free, after alloca.  */
        -: 4483:# define REGEX_FREE(arg) ((void)0) /* Do nothing!  But inhibit gcc warning.  */
        -: 4484:
        -: 4485:#endif /* not REGEX_MALLOC */
        -: 4486:
        -: 4487:/* Define how to allocate the failure stack.  */
        -: 4488:
        -: 4489:#if defined REL_ALLOC && defined REGEX_MALLOC
        -: 4490:
        -: 4491:# define REGEX_ALLOCATE_STACK(size)				\
        -: 4492:  r_alloc (&failure_stack_ptr, (size))
        -: 4493:# define REGEX_REALLOCATE_STACK(source, osize, nsize)		\
        -: 4494:  r_re_alloc (&failure_stack_ptr, (nsize))
        -: 4495:# define REGEX_FREE_STACK(ptr)					\
        -: 4496:  r_alloc_free (&failure_stack_ptr)
        -: 4497:
        -: 4498:#else /* not using relocating allocator */
        -: 4499:
        -: 4500:# ifdef REGEX_MALLOC
        -: 4501:
        -: 4502:#  define REGEX_ALLOCATE_STACK malloc
        -: 4503:#  define REGEX_REALLOCATE_STACK(source, osize, nsize) realloc (source, nsize)
        -: 4504:#  define REGEX_FREE_STACK free
        -: 4505:
        -: 4506:# else /* not REGEX_MALLOC */
        -: 4507:
        -: 4508:#  define REGEX_ALLOCATE_STACK alloca
        -: 4509:
        -: 4510:#  define REGEX_REALLOCATE_STACK(source, osize, nsize)			\
        -: 4511:   REGEX_REALLOCATE (source, osize, nsize)
        -: 4512:/* No need to explicitly free anything.  */
        -: 4513:#  define REGEX_FREE_STACK(arg)
        -: 4514:
        -: 4515:# endif /* not REGEX_MALLOC */
        -: 4516:#endif /* not using relocating allocator */
        -: 4517:
        -: 4518:
        -: 4519:/* True if `size1' is non-NULL and PTR is pointing anywhere inside
        -: 4520:   `string1' or just past its end.  This works if PTR is NULL, which is
        -: 4521:   a good thing.  */
        -: 4522:#define FIRST_STRING_P(ptr) 					\
        -: 4523:  (size1 && string1 <= (ptr) && (ptr) <= string1 + size1)
        -: 4524:
        -: 4525:/* (Re)Allocate N items of type T using malloc, or fail.  */
        -: 4526:#define TALLOC(n, t) ((t *) malloc ((n) * sizeof (t)))
        -: 4527:#define RETALLOC(addr, n, t) ((addr) = (t *) realloc (addr, (n) * sizeof (t)))
        -: 4528:#define RETALLOC_IF(addr, n, t) \
        -: 4529:  if (addr) RETALLOC((addr), (n), t); else (addr) = TALLOC ((n), t)
        -: 4530:#define REGEX_TALLOC(n, t) ((t *) REGEX_ALLOCATE ((n) * sizeof (t)))
        -: 4531:
        -: 4532:#define BYTEWIDTH 8 /* In bits.  */
        -: 4533:
        -: 4534:#define STREQ(s1, s2) ((strcmp (s1, s2) == 0))
        -: 4535:
        -: 4536:#undef MAX
        -: 4537:#undef MIN
        -: 4538:#define MAX(a, b) ((a) > (b) ? (a) : (b))
        -: 4539:#define MIN(a, b) ((a) < (b) ? (a) : (b))
        -: 4540:
        -: 4541:typedef char boolean;
        -: 4542:#define false 0
        -: 4543:#define true 1
        -: 4544:
        -: 4545:static int re_match_2_internal PARAMS ((struct re_pattern_buffer *bufp,
        -: 4546:					const char *string1, int size1,
        -: 4547:					const char *string2, int size2,
        -: 4548:					int pos,
        -: 4549:					struct re_registers *regs,
        -: 4550:					int stop));
        -: 4551:
        -: 4552:/* These are the command codes that appear in compiled regular
        -: 4553:   expressions.  Some opcodes are followed by argument bytes.  A
        -: 4554:   command code can specify any interpretation whatsoever for its
        -: 4555:   arguments.  Zero bytes may appear in the compiled regular expression.  */
        -: 4556:
        -: 4557:typedef enum
        -: 4558:{
        -: 4559:  no_op = 0,
        -: 4560:
        -: 4561:  /* Succeed right away--no more backtracking.  */
        -: 4562:  succeed,
        -: 4563:
        -: 4564:        /* Followed by one byte giving n, then by n literal bytes.  */
        -: 4565:  exactn,
        -: 4566:
        -: 4567:        /* Matches any (more or less) character.  */
        -: 4568:  anychar,
        -: 4569:
        -: 4570:        /* Matches any one char belonging to specified set.  First
        -: 4571:           following byte is number of bitmap bytes.  Then come bytes
        -: 4572:           for a bitmap saying which chars are in.  Bits in each byte
        -: 4573:           are ordered low-bit-first.  A character is in the set if its
        -: 4574:           bit is 1.  A character too large to have a bit in the map is
        -: 4575:           automatically not in the set.  */
        -: 4576:  charset,
        -: 4577:
        -: 4578:        /* Same parameters as charset, but match any character that is
        -: 4579:           not one of those specified.  */
        -: 4580:  charset_not,
        -: 4581:
        -: 4582:        /* Start remembering the text that is matched, for storing in a
        -: 4583:           register.  Followed by one byte with the register number, in
        -: 4584:           the range 0 to one less than the pattern buffer's re_nsub
        -: 4585:           field.  Then followed by one byte with the number of groups
        -: 4586:           inner to this one.  (This last has to be part of the
        -: 4587:           start_memory only because we need it in the on_failure_jump
        -: 4588:           of re_match_2.)  */
        -: 4589:  start_memory,
        -: 4590:
        -: 4591:        /* Stop remembering the text that is matched and store it in a
        -: 4592:           memory register.  Followed by one byte with the register
        -: 4593:           number, in the range 0 to one less than `re_nsub' in the
        -: 4594:           pattern buffer, and one byte with the number of inner groups,
        -: 4595:           just like `start_memory'.  (We need the number of inner
        -: 4596:           groups here because we don't have any easy way of finding the
        -: 4597:           corresponding start_memory when we're at a stop_memory.)  */
        -: 4598:  stop_memory,
        -: 4599:
        -: 4600:        /* Match a duplicate of something remembered. Followed by one
        -: 4601:           byte containing the register number.  */
        -: 4602:  duplicate,
        -: 4603:
        -: 4604:        /* Fail unless at beginning of line.  */
        -: 4605:  begline,
        -: 4606:
        -: 4607:        /* Fail unless at end of line.  */
        -: 4608:  endline,
        -: 4609:
        -: 4610:        /* Succeeds if at beginning of buffer (if emacs) or at beginning
        -: 4611:           of string to be matched (if not).  */
        -: 4612:  begbuf,
        -: 4613:
        -: 4614:        /* Analogously, for end of buffer/string.  */
        -: 4615:  endbuf,
        -: 4616:
        -: 4617:        /* Followed by two byte relative address to which to jump.  */
        -: 4618:  jump,
        -: 4619:
        -: 4620:	/* Same as jump, but marks the end of an alternative.  */
        -: 4621:  jump_past_alt,
        -: 4622:
        -: 4623:        /* Followed by two-byte relative address of place to resume at
        -: 4624:           in case of failure.  */
        -: 4625:  on_failure_jump,
        -: 4626:
        -: 4627:        /* Like on_failure_jump, but pushes a placeholder instead of the
        -: 4628:           current string position when executed.  */
        -: 4629:  on_failure_keep_string_jump,
        -: 4630:
        -: 4631:        /* Throw away latest failure point and then jump to following
        -: 4632:           two-byte relative address.  */
        -: 4633:  pop_failure_jump,
        -: 4634:
        -: 4635:        /* Change to pop_failure_jump if know won't have to backtrack to
        -: 4636:           match; otherwise change to jump.  This is used to jump
        -: 4637:           back to the beginning of a repeat.  If what follows this jump
        -: 4638:           clearly won't match what the repeat does, such that we can be
        -: 4639:           sure that there is no use backtracking out of repetitions
        -: 4640:           already matched, then we change it to a pop_failure_jump.
        -: 4641:           Followed by two-byte address.  */
        -: 4642:  maybe_pop_jump,
        -: 4643:
        -: 4644:        /* Jump to following two-byte address, and push a dummy failure
        -: 4645:           point. This failure point will be thrown away if an attempt
        -: 4646:           is made to use it for a failure.  A `+' construct makes this
        -: 4647:           before the first repeat.  Also used as an intermediary kind
        -: 4648:           of jump when compiling an alternative.  */
        -: 4649:  dummy_failure_jump,
        -: 4650:
        -: 4651:	/* Push a dummy failure point and continue.  Used at the end of
        -: 4652:	   alternatives.  */
        -: 4653:  push_dummy_failure,
        -: 4654:
        -: 4655:        /* Followed by two-byte relative address and two-byte number n.
        -: 4656:           After matching N times, jump to the address upon failure.  */
        -: 4657:  succeed_n,
        -: 4658:
        -: 4659:        /* Followed by two-byte relative address, and two-byte number n.
        -: 4660:           Jump to the address N times, then fail.  */
        -: 4661:  jump_n,
        -: 4662:
        -: 4663:        /* Set the following two-byte relative address to the
        -: 4664:           subsequent two-byte number.  The address *includes* the two
        -: 4665:           bytes of number.  */
        -: 4666:  set_number_at,
        -: 4667:
        -: 4668:  wordchar,	/* Matches any word-constituent character.  */
        -: 4669:  notwordchar,	/* Matches any char that is not a word-constituent.  */
        -: 4670:
        -: 4671:  wordbeg,	/* Succeeds if at word beginning.  */
        -: 4672:  wordend,	/* Succeeds if at word end.  */
        -: 4673:
        -: 4674:  wordbound,	/* Succeeds if at a word boundary.  */
        -: 4675:  notwordbound	/* Succeeds if not at a word boundary.  */
        -: 4676:
        -: 4677:#ifdef emacs
        -: 4678:  ,before_dot,	/* Succeeds if before point.  */
        -: 4679:  at_dot,	/* Succeeds if at point.  */
        -: 4680:  after_dot,	/* Succeeds if after point.  */
        -: 4681:
        -: 4682:	/* Matches any character whose syntax is specified.  Followed by
        -: 4683:           a byte which contains a syntax code, e.g., Sword.  */
        -: 4684:  syntaxspec,
        -: 4685:
        -: 4686:	/* Matches any character whose syntax is not that specified.  */
        -: 4687:  notsyntaxspec
        -: 4688:#endif /* emacs */
        -: 4689:} re_opcode_t;
        -: 4690:
        -: 4691:/* Common operations on the compiled pattern.  */
        -: 4692:
        -: 4693:/* Store NUMBER in two contiguous bytes starting at DESTINATION.  */
        -: 4694:
        -: 4695:#define STORE_NUMBER(destination, number)				\
        -: 4696:  do {									\
        -: 4697:    (destination)[0] = (number) & 0377;					\
        -: 4698:    (destination)[1] = (number) >> 8;					\
        -: 4699:  } while (0)
        -: 4700:
        -: 4701:/* Same as STORE_NUMBER, except increment DESTINATION to
        -: 4702:   the byte after where the number is stored.  Therefore, DESTINATION
        -: 4703:   must be an lvalue.  */
        -: 4704:
        -: 4705:#define STORE_NUMBER_AND_INCR(destination, number)			\
        -: 4706:  do {									\
        -: 4707:    STORE_NUMBER (destination, number);					\
        -: 4708:    (destination) += 2;							\
        -: 4709:  } while (0)
        -: 4710:
        -: 4711:/* Put into DESTINATION a number stored in two contiguous bytes starting
        -: 4712:   at SOURCE.  */
        -: 4713:
        -: 4714:#define EXTRACT_NUMBER(destination, source)				\
        -: 4715:  do {									\
        -: 4716:    (destination) = *(source) & 0377;					\
        -: 4717:    (destination) += SIGN_EXTEND_CHAR (*((source) + 1)) << 8;		\
        -: 4718:  } while (0)
        -: 4719:
        -: 4720:#ifdef DEBUG
        -: 4721:static void extract_number _RE_ARGS ((int *dest, unsigned char *source));
        -: 4722:static void
        -: 4723:extract_number (dest, source)
        -: 4724:    int *dest;
        -: 4725:    unsigned char *source;
        -: 4726:{
        -: 4727:  int temp = SIGN_EXTEND_CHAR (*(source + 1));
        -: 4728:  *dest = *source & 0377;
        -: 4729:  *dest += temp << 8;
        -: 4730:}
        -: 4731:
        -: 4732:# ifndef EXTRACT_MACROS /* To debug the macros.  */
        -: 4733:#  undef EXTRACT_NUMBER
        -: 4734:#  define EXTRACT_NUMBER(dest, src) extract_number (&dest, src)
        -: 4735:# endif /* not EXTRACT_MACROS */
        -: 4736:
        -: 4737:#endif /* DEBUG */
        -: 4738:
        -: 4739:/* Same as EXTRACT_NUMBER, except increment SOURCE to after the number.
        -: 4740:   SOURCE must be an lvalue.  */
        -: 4741:
        -: 4742:#define EXTRACT_NUMBER_AND_INCR(destination, source)			\
        -: 4743:  do {									\
        -: 4744:    EXTRACT_NUMBER (destination, source);				\
        -: 4745:    (source) += 2; 							\
        -: 4746:  } while (0)
        -: 4747:
        -: 4748:#ifdef DEBUG
        -: 4749:static void extract_number_and_incr _RE_ARGS ((int *destination,
        -: 4750:					       unsigned char **source));
        -: 4751:static void
        -: 4752:extract_number_and_incr (destination, source)
        -: 4753:    int *destination;
        -: 4754:    unsigned char **source;
        -: 4755:{
        -: 4756:  extract_number (destination, *source);
        -: 4757:  *source += 2;
        -: 4758:}
        -: 4759:
        -: 4760:# ifndef EXTRACT_MACROS
        -: 4761:#  undef EXTRACT_NUMBER_AND_INCR
        -: 4762:#  define EXTRACT_NUMBER_AND_INCR(dest, src) \
        -: 4763:  extract_number_and_incr (&dest, &src)
        -: 4764:# endif /* not EXTRACT_MACROS */
        -: 4765:
        -: 4766:#endif /* DEBUG */
        -: 4767:
        -: 4768:/* If DEBUG is defined, Regex prints many voluminous messages about what
        -: 4769:   it is doing (if the variable `debug' is nonzero).  If linked with the
        -: 4770:   main program in `iregex.c', you can enter patterns and strings
        -: 4771:   interactively.  And if linked with the main program in `main.c' and
        -: 4772:   the other test files, you can run the already-written tests.  */
        -: 4773:
        -: 4774:#ifdef DEBUG
        -: 4775:
        -: 4776:/* We use standard I/O for debugging.  */
        -: 4777:# include <stdio.h>
        -: 4778:
        -: 4779:/* It is useful to test things that ``must'' be true when debugging.  */
        -: 4780:# include <assert.h>
        -: 4781:
        -: 4782:static int debug = 0;
        -: 4783:
        -: 4784:# define DEBUG_STATEMENT(e) e
        -: 4785:# define DEBUG_PRINT1(x) if (debug) printf (x)
        -: 4786:# define DEBUG_PRINT2(x1, x2) if (debug) printf (x1, x2)
        -: 4787:# define DEBUG_PRINT3(x1, x2, x3) if (debug) printf (x1, x2, x3)
        -: 4788:# define DEBUG_PRINT4(x1, x2, x3, x4) if (debug) printf (x1, x2, x3, x4)
        -: 4789:# define DEBUG_PRINT_COMPILED_PATTERN(p, s, e) 				\
        -: 4790:  if (debug) print_partial_compiled_pattern (s, e)
        -: 4791:# define DEBUG_PRINT_DOUBLE_STRING(w, s1, sz1, s2, sz2)			\
        -: 4792:  if (debug) print_double_string (w, s1, sz1, s2, sz2)
        -: 4793:
        -: 4794:
        -: 4795:/* Print the fastmap in human-readable form.  */
        -: 4796:
        -: 4797:void
        -: 4798:print_fastmap (fastmap)
        -: 4799:    char *fastmap;
        -: 4800:{
        -: 4801:  unsigned was_a_range = 0;
        -: 4802:  unsigned i = 0;
        -: 4803:
        -: 4804:  while (i < (1 << BYTEWIDTH))
        -: 4805:    {
        -: 4806:      if (fastmap[i++])
        -: 4807:	{
        -: 4808:	  was_a_range = 0;
        -: 4809:          putchar (i - 1);
        -: 4810:          while (i < (1 << BYTEWIDTH)  &&  fastmap[i])
        -: 4811:            {
        -: 4812:              was_a_range = 1;
        -: 4813:              i++;
        -: 4814:            }
        -: 4815:	  if (was_a_range)
        -: 4816:            {
        -: 4817:              printf ("-");
        -: 4818:              putchar (i - 1);
        -: 4819:            }
        -: 4820:        }
        -: 4821:    }
        -: 4822:  putchar ('\n');
        -: 4823:}
        -: 4824:
        -: 4825:
        -: 4826:/* Print a compiled pattern string in human-readable form, starting at
        -: 4827:   the START pointer into it and ending just before the pointer END.  */
        -: 4828:
        -: 4829:void
        -: 4830:print_partial_compiled_pattern (start, end)
        -: 4831:    unsigned char *start;
        -: 4832:    unsigned char *end;
        -: 4833:{
        -: 4834:  int mcnt, mcnt2;
        -: 4835:  unsigned char *p1;
        -: 4836:  unsigned char *p = start;
        -: 4837:  unsigned char *pend = end;
        -: 4838:
        -: 4839:  if (start == NULL)
        -: 4840:    {
        -: 4841:      printf ("(null)\n");
        -: 4842:      return;
        -: 4843:    }
        -: 4844:
        -: 4845:  /* Loop over pattern commands.  */
        -: 4846:  while (p < pend)
        -: 4847:    {
        -: 4848:      printf ("%d:\t", p - start);
        -: 4849:
        -: 4850:      switch ((re_opcode_t) *p++)
        -: 4851:	{
        -: 4852:        case no_op:
        -: 4853:          printf ("/no_op");
        -: 4854:          break;
        -: 4855:
        -: 4856:	case exactn:
        -: 4857:	  mcnt = *p++;
        -: 4858:          printf ("/exactn/%d", mcnt);
        -: 4859:          do
        -: 4860:	    {
        -: 4861:              putchar ('/');
        -: 4862:	      putchar (*p++);
        -: 4863:            }
        -: 4864:          while (--mcnt);
        -: 4865:          break;
        -: 4866:
        -: 4867:	case start_memory:
        -: 4868:          mcnt = *p++;
        -: 4869:          printf ("/start_memory/%d/%d", mcnt, *p++);
        -: 4870:          break;
        -: 4871:
        -: 4872:	case stop_memory:
        -: 4873:          mcnt = *p++;
        -: 4874:	  printf ("/stop_memory/%d/%d", mcnt, *p++);
        -: 4875:          break;
        -: 4876:
        -: 4877:	case duplicate:
        -: 4878:	  printf ("/duplicate/%d", *p++);
        -: 4879:	  break;
        -: 4880:
        -: 4881:	case anychar:
        -: 4882:	  printf ("/anychar");
        -: 4883:	  break;
        -: 4884:
        -: 4885:	case charset:
        -: 4886:        case charset_not:
        -: 4887:          {
        -: 4888:            register int c, last = -100;
        -: 4889:	    register int in_range = 0;
        -: 4890:
        -: 4891:	    printf ("/charset [%s",
        -: 4892:	            (re_opcode_t) *(p - 1) == charset_not ? "^" : "");
        -: 4893:
        -: 4894:            assert (p + *p < pend);
        -: 4895:
        -: 4896:            for (c = 0; c < 256; c++)
        -: 4897:	      if (c / 8 < *p
        -: 4898:		  && (p[1 + (c/8)] & (1 << (c % 8))))
        -: 4899:		{
        -: 4900:		  /* Are we starting a range?  */
        -: 4901:		  if (last + 1 == c && ! in_range)
        -: 4902:		    {
        -: 4903:		      putchar ('-');
        -: 4904:		      in_range = 1;
        -: 4905:		    }
        -: 4906:		  /* Have we broken a range?  */
        -: 4907:		  else if (last + 1 != c && in_range)
        -: 4908:              {
        -: 4909:		      putchar (last);
        -: 4910:		      in_range = 0;
        -: 4911:		    }
        -: 4912:
        -: 4913:		  if (! in_range)
        -: 4914:		    putchar (c);
        -: 4915:
        -: 4916:		  last = c;
        -: 4917:              }
        -: 4918:
        -: 4919:	    if (in_range)
        -: 4920:	      putchar (last);
        -: 4921:
        -: 4922:	    putchar (']');
        -: 4923:
        -: 4924:	    p += 1 + *p;
        -: 4925:	  }
        -: 4926:	  break;
        -: 4927:
        -: 4928:	case begline:
        -: 4929:	  printf ("/begline");
        -: 4930:          break;
        -: 4931:
        -: 4932:	case endline:
        -: 4933:          printf ("/endline");
        -: 4934:          break;
        -: 4935:
        -: 4936:	case on_failure_jump:
        -: 4937:          extract_number_and_incr (&mcnt, &p);
        -: 4938:  	  printf ("/on_failure_jump to %d", p + mcnt - start);
        -: 4939:          break;
        -: 4940:
        -: 4941:	case on_failure_keep_string_jump:
        -: 4942:          extract_number_and_incr (&mcnt, &p);
        -: 4943:  	  printf ("/on_failure_keep_string_jump to %d", p + mcnt - start);
        -: 4944:          break;
        -: 4945:
        -: 4946:	case dummy_failure_jump:
        -: 4947:          extract_number_and_incr (&mcnt, &p);
        -: 4948:  	  printf ("/dummy_failure_jump to %d", p + mcnt - start);
        -: 4949:          break;
        -: 4950:
        -: 4951:	case push_dummy_failure:
        -: 4952:          printf ("/push_dummy_failure");
        -: 4953:          break;
        -: 4954:
        -: 4955:        case maybe_pop_jump:
        -: 4956:          extract_number_and_incr (&mcnt, &p);
        -: 4957:  	  printf ("/maybe_pop_jump to %d", p + mcnt - start);
        -: 4958:	  break;
        -: 4959:
        -: 4960:        case pop_failure_jump:
        -: 4961:	  extract_number_and_incr (&mcnt, &p);
        -: 4962:  	  printf ("/pop_failure_jump to %d", p + mcnt - start);
        -: 4963:	  break;
        -: 4964:
        -: 4965:        case jump_past_alt:
        -: 4966:	  extract_number_and_incr (&mcnt, &p);
        -: 4967:  	  printf ("/jump_past_alt to %d", p + mcnt - start);
        -: 4968:	  break;
        -: 4969:
        -: 4970:        case jump:
        -: 4971:	  extract_number_and_incr (&mcnt, &p);
        -: 4972:  	  printf ("/jump to %d", p + mcnt - start);
        -: 4973:	  break;
        -: 4974:
        -: 4975:        case succeed_n:
        -: 4976:          extract_number_and_incr (&mcnt, &p);
        -: 4977:	  p1 = p + mcnt;
        -: 4978:          extract_number_and_incr (&mcnt2, &p);
        -: 4979:	  printf ("/succeed_n to %d, %d times", p1 - start, mcnt2);
        -: 4980:          break;
        -: 4981:
        -: 4982:        case jump_n:
        -: 4983:          extract_number_and_incr (&mcnt, &p);
        -: 4984:	  p1 = p + mcnt;
        -: 4985:          extract_number_and_incr (&mcnt2, &p);
        -: 4986:	  printf ("/jump_n to %d, %d times", p1 - start, mcnt2);
        -: 4987:          break;
        -: 4988:
        -: 4989:        case set_number_at:
        -: 4990:          extract_number_and_incr (&mcnt, &p);
        -: 4991:	  p1 = p + mcnt;
        -: 4992:          extract_number_and_incr (&mcnt2, &p);
        -: 4993:	  printf ("/set_number_at location %d to %d", p1 - start, mcnt2);
        -: 4994:          break;
        -: 4995:
        -: 4996:        case wordbound:
        -: 4997:	  printf ("/wordbound");
        -: 4998:	  break;
        -: 4999:
        -: 5000:	case notwordbound:
        -: 5001:	  printf ("/notwordbound");
        -: 5002:          break;
        -: 5003:
        -: 5004:	case wordbeg:
        -: 5005:	  printf ("/wordbeg");
        -: 5006:	  break;
        -: 5007:
        -: 5008:	case wordend:
        -: 5009:	  printf ("/wordend");
        -: 5010:
        -: 5011:# ifdef emacs
        -: 5012:	case before_dot:
        -: 5013:	  printf ("/before_dot");
        -: 5014:          break;
        -: 5015:
        -: 5016:	case at_dot:
        -: 5017:	  printf ("/at_dot");
        -: 5018:          break;
        -: 5019:
        -: 5020:	case after_dot:
        -: 5021:	  printf ("/after_dot");
        -: 5022:          break;
        -: 5023:
        -: 5024:	case syntaxspec:
        -: 5025:          printf ("/syntaxspec");
        -: 5026:	  mcnt = *p++;
        -: 5027:	  printf ("/%d", mcnt);
        -: 5028:          break;
        -: 5029:
        -: 5030:	case notsyntaxspec:
        -: 5031:          printf ("/notsyntaxspec");
        -: 5032:	  mcnt = *p++;
        -: 5033:	  printf ("/%d", mcnt);
        -: 5034:	  break;
        -: 5035:# endif /* emacs */
        -: 5036:
        -: 5037:	case wordchar:
        -: 5038:	  printf ("/wordchar");
        -: 5039:          break;
        -: 5040:
        -: 5041:	case notwordchar:
        -: 5042:	  printf ("/notwordchar");
        -: 5043:          break;
        -: 5044:
        -: 5045:	case begbuf:
        -: 5046:	  printf ("/begbuf");
        -: 5047:          break;
        -: 5048:
        -: 5049:	case endbuf:
        -: 5050:	  printf ("/endbuf");
        -: 5051:          break;
        -: 5052:
        -: 5053:        default:
        -: 5054:          printf ("?%d", *(p-1));
        -: 5055:	}
        -: 5056:
        -: 5057:      putchar ('\n');
        -: 5058:    }
        -: 5059:
        -: 5060:  printf ("%d:\tend of pattern.\n", p - start);
        -: 5061:}
        -: 5062:
        -: 5063:
        -: 5064:void
        -: 5065:print_compiled_pattern (bufp)
        -: 5066:    struct re_pattern_buffer *bufp;
        -: 5067:{
        -: 5068:  unsigned char *buffer = bufp->buffer;
        -: 5069:
        -: 5070:  print_partial_compiled_pattern (buffer, buffer + bufp->used);
        -: 5071:  printf ("%ld bytes used/%ld bytes allocated.\n",
        -: 5072:	  bufp->used, bufp->allocated);
        -: 5073:
        -: 5074:  if (bufp->fastmap_accurate && bufp->fastmap)
        -: 5075:    {
        -: 5076:      printf ("fastmap: ");
        -: 5077:      print_fastmap (bufp->fastmap);
        -: 5078:    }
        -: 5079:
        -: 5080:  printf ("re_nsub: %d\t", bufp->re_nsub);
        -: 5081:  printf ("regs_alloc: %d\t", bufp->regs_allocated);
        -: 5082:  printf ("can_be_null: %d\t", bufp->can_be_null);
        -: 5083:  printf ("newline_anchor: %d\n", bufp->newline_anchor);
        -: 5084:  printf ("no_sub: %d\t", bufp->no_sub);
        -: 5085:  printf ("not_bol: %d\t", bufp->not_bol);
        -: 5086:  printf ("not_eol: %d\t", bufp->not_eol);
        -: 5087:  printf ("syntax: %lx\n", bufp->syntax);
        -: 5088:  /* Perhaps we should print the translate table?  */
        -: 5089:}
        -: 5090:
        -: 5091:
        -: 5092:void
        -: 5093:print_double_string (where, string1, size1, string2, size2)
        -: 5094:    const char *where;
        -: 5095:    const char *string1;
        -: 5096:    const char *string2;
        -: 5097:    int size1;
        -: 5098:    int size2;
        -: 5099:{
        -: 5100:  int this_char;
        -: 5101:
        -: 5102:  if (where == NULL)
        -: 5103:    printf ("(null)");
        -: 5104:  else
        -: 5105:    {
        -: 5106:      if (FIRST_STRING_P (where))
        -: 5107:        {
        -: 5108:          for (this_char = where - string1; this_char < size1; this_char++)
        -: 5109:            putchar (string1[this_char]);
        -: 5110:
        -: 5111:          where = string2;
        -: 5112:        }
        -: 5113:
        -: 5114:      for (this_char = where - string2; this_char < size2; this_char++)
        -: 5115:        putchar (string2[this_char]);
        -: 5116:    }
        -: 5117:}
        -: 5118:
        -: 5119:void
        -: 5120:printchar (c)
        -: 5121:     int c;
        -: 5122:{
        -: 5123:  putc (c, stderr);
        -: 5124:}
        -: 5125:
        -: 5126:#else /* not DEBUG */
        -: 5127:
        -: 5128:# undef assert
        -: 5129:# define assert(e)
        -: 5130:
        -: 5131:# define DEBUG_STATEMENT(e)
        -: 5132:# define DEBUG_PRINT1(x)
        -: 5133:# define DEBUG_PRINT2(x1, x2)
        -: 5134:# define DEBUG_PRINT3(x1, x2, x3)
        -: 5135:# define DEBUG_PRINT4(x1, x2, x3, x4)
        -: 5136:# define DEBUG_PRINT_COMPILED_PATTERN(p, s, e)
        -: 5137:# define DEBUG_PRINT_DOUBLE_STRING(w, s1, sz1, s2, sz2)
        -: 5138:
        -: 5139:#endif /* not DEBUG */
        -: 5140:
        -: 5141:/* Set by `re_set_syntax' to the current regexp syntax to recognize.  Can
        -: 5142:   also be assigned to arbitrarily: each pattern buffer stores its own
        -: 5143:   syntax, so it can be changed between regex compilations.  */
        -: 5144:/* This has no initializer because initialized variables in Emacs
        -: 5145:   become read-only after dumping.  */
        -: 5146:reg_syntax_t re_syntax_options;
        -: 5147:
        -: 5148:
        -: 5149:/* Specify the precise syntax of regexps for compilation.  This provides
        -: 5150:   for compatibility for various utilities which historically have
        -: 5151:   different, incompatible syntaxes.
        -: 5152:
        -: 5153:   The argument SYNTAX is a bit mask comprised of the various bits
        -: 5154:   defined in regex-gnu.h.  We return the old syntax.  */
        -: 5155:
        -: 5156:reg_syntax_t
function re_set_syntax called 0 returned 0% blocks executed 0%
    #####: 5157:re_set_syntax (syntax)
        -: 5158:    reg_syntax_t syntax;
        -: 5159:{
    #####: 5160:  reg_syntax_t ret = re_syntax_options;
        -: 5161:
    #####: 5162:  re_syntax_options = syntax;
        -: 5163:#ifdef DEBUG
        -: 5164:  if (syntax & RE_DEBUG)
        -: 5165:    debug = 1;
        -: 5166:  else if (debug) /* was on but now is not */
        -: 5167:    debug = 0;
        -: 5168:#endif /* DEBUG */
    #####: 5169:  return ret;
        -: 5170:}
        -: 5171:#ifdef _LIBC
        -: 5172:weak_alias (__re_set_syntax, re_set_syntax)
        -: 5173:#endif
        -: 5174:
        -: 5175:/* This table gives an error message for each of the error codes listed
        -: 5176:   in regex-gnu.h.  Obviously the order here has to be same as there.
        -: 5177:   POSIX doesn't require that we do anything for REG_NOERROR,
        -: 5178:   but why not be nice?  */
        -: 5179:
        -: 5180:static const char *re_error_msgid[] =
        -: 5181:  {
        -: 5182:    gettext_noop ("Success"),	/* REG_NOERROR */
        -: 5183:    gettext_noop ("No match"),	/* REG_NOMATCH */
        -: 5184:    gettext_noop ("Invalid regular expression"), /* REG_BADPAT */
        -: 5185:    gettext_noop ("Invalid collation character"), /* REG_ECOLLATE */
        -: 5186:    gettext_noop ("Invalid character class name"), /* REG_ECTYPE */
        -: 5187:    gettext_noop ("Trailing backslash"), /* REG_EESCAPE */
        -: 5188:    gettext_noop ("Invalid back reference"), /* REG_ESUBREG */
        -: 5189:    gettext_noop ("Unmatched [ or [^"),	/* REG_EBRACK */
        -: 5190:    gettext_noop ("Unmatched ( or \\("), /* REG_EPAREN */
        -: 5191:    gettext_noop ("Unmatched \\{"), /* REG_EBRACE */
        -: 5192:    gettext_noop ("Invalid content of \\{\\}"), /* REG_BADBR */
        -: 5193:    gettext_noop ("Invalid range end"),	/* REG_ERANGE */
        -: 5194:    gettext_noop ("Memory exhausted"), /* REG_ESPACE */
        -: 5195:    gettext_noop ("Invalid preceding regular expression"), /* REG_BADRPT */
        -: 5196:    gettext_noop ("Premature end of regular expression"), /* REG_EEND */
        -: 5197:    gettext_noop ("Regular expression too big"), /* REG_ESIZE */
        -: 5198:    gettext_noop ("Unmatched ) or \\)"), /* REG_ERPAREN */
        -: 5199:  };
        -: 5200:
        -: 5201:/* Avoiding alloca during matching, to placate r_alloc.  */
        -: 5202:
        -: 5203:/* Define MATCH_MAY_ALLOCATE unless we need to make sure that the
        -: 5204:   searching and matching functions should not call alloca.  On some
        -: 5205:   systems, alloca is implemented in terms of malloc, and if we're
        -: 5206:   using the relocating allocator routines, then malloc could cause a
        -: 5207:   relocation, which might (if the strings being searched are in the
        -: 5208:   ralloc heap) shift the data out from underneath the regexp
        -: 5209:   routines.
        -: 5210:
        -: 5211:   Here's another reason to avoid allocation: Emacs
        -: 5212:   processes input from X in a signal handler; processing X input may
        -: 5213:   call malloc; if input arrives while a matching routine is calling
        -: 5214:   malloc, then we're scrod.  But Emacs can't just block input while
        -: 5215:   calling matching routines; then we don't notice interrupts when
        -: 5216:   they come in.  So, Emacs blocks input around all regexp calls
        -: 5217:   except the matching calls, which it leaves unprotected, in the
        -: 5218:   faith that they will not malloc.  */
        -: 5219:
        -: 5220:/* Normally, this is fine.  */
        -: 5221:#define MATCH_MAY_ALLOCATE
        -: 5222:
        -: 5223:/* When using GNU C, we are not REALLY using the C alloca, no matter
        -: 5224:   what config.h may say.  So don't take precautions for it.  */
        -: 5225:#ifdef __GNUC__
        -: 5226:# undef C_ALLOCA
        -: 5227:#endif
        -: 5228:
        -: 5229:/* The match routines may not allocate if (1) they would do it with malloc
        -: 5230:   and (2) it's not safe for them to use malloc.
        -: 5231:   Note that if REL_ALLOC is defined, matching would not use malloc for the
        -: 5232:   failure stack, but we would still use it for the register vectors;
        -: 5233:   so REL_ALLOC should not affect this.  */
        -: 5234:#if (defined C_ALLOCA || defined REGEX_MALLOC) && defined emacs
        -: 5235:# undef MATCH_MAY_ALLOCATE
        -: 5236:#endif
        -: 5237:
        -: 5238:
        -: 5239:/* Failure stack declarations and macros; both re_compile_fastmap and
        -: 5240:   re_match_2 use a failure stack.  These have to be macros because of
        -: 5241:   REGEX_ALLOCATE_STACK.  */
        -: 5242:
        -: 5243:
        -: 5244:/* Number of failure points for which to initially allocate space
        -: 5245:   when matching.  If this number is exceeded, we allocate more
        -: 5246:   space, so it is not a hard limit.  */
        -: 5247:#ifndef INIT_FAILURE_ALLOC
        -: 5248:# define INIT_FAILURE_ALLOC 5
        -: 5249:#endif
        -: 5250:
        -: 5251:/* Roughly the maximum number of failure points on the stack.  Would be
        -: 5252:   exactly that if always used MAX_FAILURE_ITEMS items each time we failed.
        -: 5253:   This is a variable only so users of regex can assign to it; we never
        -: 5254:   change it ourselves.  */
        -: 5255:
        -: 5256:#ifdef INT_IS_16BIT
        -: 5257:
        -: 5258:# if defined MATCH_MAY_ALLOCATE
        -: 5259:/* 4400 was enough to cause a crash on Alpha OSF/1,
        -: 5260:   whose default stack limit is 2mb.  */
        -: 5261:long int re_max_failures = 4000;
        -: 5262:# else
        -: 5263:long int re_max_failures = 2000;
        -: 5264:# endif
        -: 5265:
        -: 5266:union fail_stack_elt
        -: 5267:{
        -: 5268:  unsigned char *pointer;
        -: 5269:  long int integer;
        -: 5270:};
        -: 5271:
        -: 5272:typedef union fail_stack_elt fail_stack_elt_t;
        -: 5273:
        -: 5274:typedef struct
        -: 5275:{
        -: 5276:  fail_stack_elt_t *stack;
        -: 5277:  unsigned long int size;
        -: 5278:  unsigned long int avail;		/* Offset of next open position.  */
        -: 5279:} fail_stack_type;
        -: 5280:
        -: 5281:#else /* not INT_IS_16BIT */
        -: 5282:
        -: 5283:# if defined MATCH_MAY_ALLOCATE
        -: 5284:/* 4400 was enough to cause a crash on Alpha OSF/1,
        -: 5285:   whose default stack limit is 2mb.  */
        -: 5286:int re_max_failures = 20000;
        -: 5287:# else
        -: 5288:int re_max_failures = 2000;
        -: 5289:# endif
        -: 5290:
        -: 5291:union fail_stack_elt
        -: 5292:{
        -: 5293:  unsigned char *pointer;
        -: 5294:  int integer;
        -: 5295:};
        -: 5296:
        -: 5297:typedef union fail_stack_elt fail_stack_elt_t;
        -: 5298:
        -: 5299:typedef struct
        -: 5300:{
        -: 5301:  fail_stack_elt_t *stack;
        -: 5302:  unsigned size;
        -: 5303:  unsigned avail;			/* Offset of next open position.  */
        -: 5304:} fail_stack_type;
        -: 5305:
        -: 5306:#endif /* INT_IS_16BIT */
        -: 5307:
        -: 5308:#define FAIL_STACK_EMPTY()     (fail_stack.avail == 0)
        -: 5309:#define FAIL_STACK_PTR_EMPTY() (fail_stack_ptr->avail == 0)
        -: 5310:#define FAIL_STACK_FULL()      (fail_stack.avail == fail_stack.size)
        -: 5311:
        -: 5312:
        -: 5313:/* Define macros to initialize and free the failure stack.
        -: 5314:   Do `return -2' if the alloc fails.  */
        -: 5315:
        -: 5316:#ifdef MATCH_MAY_ALLOCATE
        -: 5317:# define INIT_FAIL_STACK()						\
        -: 5318:  do {									\
        -: 5319:    fail_stack.stack = (fail_stack_elt_t *)				\
        -: 5320:      REGEX_ALLOCATE_STACK (INIT_FAILURE_ALLOC * sizeof (fail_stack_elt_t)); \
        -: 5321:									\
        -: 5322:    if (fail_stack.stack == NULL)					\
        -: 5323:      return -2;							\
        -: 5324:									\
        -: 5325:    fail_stack.size = INIT_FAILURE_ALLOC;				\
        -: 5326:    fail_stack.avail = 0;						\
        -: 5327:  } while (0)
        -: 5328:
        -: 5329:# define RESET_FAIL_STACK()  REGEX_FREE_STACK (fail_stack.stack)
        -: 5330:#else
        -: 5331:# define INIT_FAIL_STACK()						\
        -: 5332:  do {									\
        -: 5333:    fail_stack.avail = 0;						\
        -: 5334:  } while (0)
        -: 5335:
        -: 5336:# define RESET_FAIL_STACK()
        -: 5337:#endif
        -: 5338:
        -: 5339:
        -: 5340:/* Double the size of FAIL_STACK, up to approximately `re_max_failures' items.
        -: 5341:
        -: 5342:   Return 1 if succeeds, and 0 if either ran out of memory
        -: 5343:   allocating space for it or it was already too large.
        -: 5344:
        -: 5345:   REGEX_REALLOCATE_STACK requires `destination' be declared.   */
        -: 5346:
        -: 5347:#define DOUBLE_FAIL_STACK(fail_stack)					\
        -: 5348:  ((fail_stack).size > (unsigned) (re_max_failures * MAX_FAILURE_ITEMS)	\
        -: 5349:   ? 0									\
        -: 5350:   : ((fail_stack).stack = (fail_stack_elt_t *)				\
        -: 5351:        REGEX_REALLOCATE_STACK ((fail_stack).stack, 			\
        -: 5352:          (fail_stack).size * sizeof (fail_stack_elt_t),		\
        -: 5353:          ((fail_stack).size << 1) * sizeof (fail_stack_elt_t)),	\
        -: 5354:									\
        -: 5355:      (fail_stack).stack == NULL					\
        -: 5356:      ? 0								\
        -: 5357:      : ((fail_stack).size <<= 1, 					\
        -: 5358:         1)))
        -: 5359:
        -: 5360:
        -: 5361:/* Push pointer POINTER on FAIL_STACK.
        -: 5362:   Return 1 if was able to do so and 0 if ran out of memory allocating
        -: 5363:   space to do so.  */
        -: 5364:#define PUSH_PATTERN_OP(POINTER, FAIL_STACK)				\
        -: 5365:  ((FAIL_STACK_FULL ()							\
        -: 5366:    && !DOUBLE_FAIL_STACK (FAIL_STACK))					\
        -: 5367:   ? 0									\
        -: 5368:   : ((FAIL_STACK).stack[(FAIL_STACK).avail++].pointer = POINTER,	\
        -: 5369:      1))
        -: 5370:
        -: 5371:/* Push a pointer value onto the failure stack.
        -: 5372:   Assumes the variable `fail_stack'.  Probably should only
        -: 5373:   be called from within `PUSH_FAILURE_POINT'.  */
        -: 5374:#define PUSH_FAILURE_POINTER(item)					\
        -: 5375:  fail_stack.stack[fail_stack.avail++].pointer = (unsigned char *) (item)
        -: 5376:
        -: 5377:/* This pushes an integer-valued item onto the failure stack.
        -: 5378:   Assumes the variable `fail_stack'.  Probably should only
        -: 5379:   be called from within `PUSH_FAILURE_POINT'.  */
        -: 5380:#define PUSH_FAILURE_INT(item)					\
        -: 5381:  fail_stack.stack[fail_stack.avail++].integer = (item)
        -: 5382:
        -: 5383:/* Push a fail_stack_elt_t value onto the failure stack.
        -: 5384:   Assumes the variable `fail_stack'.  Probably should only
        -: 5385:   be called from within `PUSH_FAILURE_POINT'.  */
        -: 5386:#define PUSH_FAILURE_ELT(item)					\
        -: 5387:  fail_stack.stack[fail_stack.avail++] =  (item)
        -: 5388:
        -: 5389:/* These three POP... operations complement the three PUSH... operations.
        -: 5390:   All assume that `fail_stack' is nonempty.  */
        -: 5391:#define POP_FAILURE_POINTER() fail_stack.stack[--fail_stack.avail].pointer
        -: 5392:#define POP_FAILURE_INT() fail_stack.stack[--fail_stack.avail].integer
        -: 5393:#define POP_FAILURE_ELT() fail_stack.stack[--fail_stack.avail]
        -: 5394:
        -: 5395:/* Used to omit pushing failure point id's when we're not debugging.  */
        -: 5396:#ifdef DEBUG
        -: 5397:# define DEBUG_PUSH PUSH_FAILURE_INT
        -: 5398:# define DEBUG_POP(item_addr) *(item_addr) = POP_FAILURE_INT ()
        -: 5399:#else
        -: 5400:# define DEBUG_PUSH(item)
        -: 5401:# define DEBUG_POP(item_addr)
        -: 5402:#endif
        -: 5403:
        -: 5404:
        -: 5405:/* Push the information about the state we will need
        -: 5406:   if we ever fail back to it.
        -: 5407:
        -: 5408:   Requires variables fail_stack, regstart, regend, reg_info, and
        -: 5409:   num_regs_pushed be declared.  DOUBLE_FAIL_STACK requires `destination'
        -: 5410:   be declared.
        -: 5411:
        -: 5412:   Does `return FAILURE_CODE' if runs out of memory.  */
        -: 5413:
        -: 5414:#define PUSH_FAILURE_POINT(pattern_place, string_place, failure_code)	\
        -: 5415:  do {									\
        -: 5416:    char *destination;							\
        -: 5417:    /* Must be int, so when we don't save any registers, the arithmetic	\
        -: 5418:       of 0 + -1 isn't done as unsigned.  */				\
        -: 5419:    /* Can't be int, since there is not a shred of a guarantee that int	\
        -: 5420:       is wide enough to hold a value of something to which pointer can	\
        -: 5421:       be assigned */							\
        -: 5422:    active_reg_t this_reg;						\
        -: 5423:    									\
        -: 5424:    DEBUG_STATEMENT (failure_id++);					\
        -: 5425:    DEBUG_STATEMENT (nfailure_points_pushed++);				\
        -: 5426:    DEBUG_PRINT2 ("\nPUSH_FAILURE_POINT #%u:\n", failure_id);		\
        -: 5427:    DEBUG_PRINT2 ("  Before push, next avail: %d\n", (fail_stack).avail);\
        -: 5428:    DEBUG_PRINT2 ("                     size: %d\n", (fail_stack).size);\
        -: 5429:									\
        -: 5430:    DEBUG_PRINT2 ("  slots needed: %ld\n", NUM_FAILURE_ITEMS);		\
        -: 5431:    DEBUG_PRINT2 ("     available: %d\n", REMAINING_AVAIL_SLOTS);	\
        -: 5432:									\
        -: 5433:    /* Ensure we have enough space allocated for what we will push.  */	\
        -: 5434:    while (REMAINING_AVAIL_SLOTS < NUM_FAILURE_ITEMS)			\
        -: 5435:      {									\
        -: 5436:        if (!DOUBLE_FAIL_STACK (fail_stack))				\
        -: 5437:          return failure_code;						\
        -: 5438:									\
        -: 5439:        DEBUG_PRINT2 ("\n  Doubled stack; size now: %d\n",		\
        -: 5440:		       (fail_stack).size);				\
        -: 5441:        DEBUG_PRINT2 ("  slots available: %d\n", REMAINING_AVAIL_SLOTS);\
        -: 5442:      }									\
        -: 5443:									\
        -: 5444:    /* Push the info, starting with the registers.  */			\
        -: 5445:    DEBUG_PRINT1 ("\n");						\
        -: 5446:									\
        -: 5447:    if (1)								\
        -: 5448:      for (this_reg = lowest_active_reg; this_reg <= highest_active_reg; \
        -: 5449:	   this_reg++)							\
        -: 5450:	{								\
        -: 5451:	  DEBUG_PRINT2 ("  Pushing reg: %lu\n", this_reg);		\
        -: 5452:	  DEBUG_STATEMENT (num_regs_pushed++);				\
        -: 5453:									\
        -: 5454:	  DEBUG_PRINT2 ("    start: %p\n", regstart[this_reg]);		\
        -: 5455:	  PUSH_FAILURE_POINTER (regstart[this_reg]);			\
        -: 5456:									\
        -: 5457:	  DEBUG_PRINT2 ("    end: %p\n", regend[this_reg]);		\
        -: 5458:	  PUSH_FAILURE_POINTER (regend[this_reg]);			\
        -: 5459:									\
        -: 5460:	  DEBUG_PRINT2 ("    info: %p\n      ",				\
        -: 5461:			reg_info[this_reg].word.pointer);		\
        -: 5462:	  DEBUG_PRINT2 (" match_null=%d",				\
        -: 5463:			REG_MATCH_NULL_STRING_P (reg_info[this_reg]));	\
        -: 5464:	  DEBUG_PRINT2 (" active=%d", IS_ACTIVE (reg_info[this_reg]));	\
        -: 5465:	  DEBUG_PRINT2 (" matched_something=%d",			\
        -: 5466:			MATCHED_SOMETHING (reg_info[this_reg]));	\
        -: 5467:	  DEBUG_PRINT2 (" ever_matched=%d",				\
        -: 5468:			EVER_MATCHED_SOMETHING (reg_info[this_reg]));	\
        -: 5469:	  DEBUG_PRINT1 ("\n");						\
        -: 5470:	  PUSH_FAILURE_ELT (reg_info[this_reg].word);			\
        -: 5471:	}								\
        -: 5472:									\
        -: 5473:    DEBUG_PRINT2 ("  Pushing  low active reg: %ld\n", lowest_active_reg);\
        -: 5474:    PUSH_FAILURE_INT (lowest_active_reg);				\
        -: 5475:									\
        -: 5476:    DEBUG_PRINT2 ("  Pushing high active reg: %ld\n", highest_active_reg);\
        -: 5477:    PUSH_FAILURE_INT (highest_active_reg);				\
        -: 5478:									\
        -: 5479:    DEBUG_PRINT2 ("  Pushing pattern %p:\n", pattern_place);		\
        -: 5480:    DEBUG_PRINT_COMPILED_PATTERN (bufp, pattern_place, pend);		\
        -: 5481:    PUSH_FAILURE_POINTER (pattern_place);				\
        -: 5482:									\
        -: 5483:    DEBUG_PRINT2 ("  Pushing string %p: `", string_place);		\
        -: 5484:    DEBUG_PRINT_DOUBLE_STRING (string_place, string1, size1, string2,   \
        -: 5485:				 size2);				\
        -: 5486:    DEBUG_PRINT1 ("'\n");						\
        -: 5487:    PUSH_FAILURE_POINTER (string_place);				\
        -: 5488:									\
        -: 5489:    DEBUG_PRINT2 ("  Pushing failure id: %u\n", failure_id);		\
        -: 5490:    DEBUG_PUSH (failure_id);						\
        -: 5491:  } while (0)
        -: 5492:
        -: 5493:/* This is the number of items that are pushed and popped on the stack
        -: 5494:   for each register.  */
        -: 5495:#define NUM_REG_ITEMS  3
        -: 5496:
        -: 5497:/* Individual items aside from the registers.  */
        -: 5498:#ifdef DEBUG
        -: 5499:# define NUM_NONREG_ITEMS 5 /* Includes failure point id.  */
        -: 5500:#else
        -: 5501:# define NUM_NONREG_ITEMS 4
        -: 5502:#endif
        -: 5503:
        -: 5504:/* We push at most this many items on the stack.  */
        -: 5505:/* We used to use (num_regs - 1), which is the number of registers
        -: 5506:   this regexp will save; but that was changed to 5
        -: 5507:   to avoid stack overflow for a regexp with lots of parens.  */
        -: 5508:#define MAX_FAILURE_ITEMS (5 * NUM_REG_ITEMS + NUM_NONREG_ITEMS)
        -: 5509:
        -: 5510:/* We actually push this many items.  */
        -: 5511:#define NUM_FAILURE_ITEMS				\
        -: 5512:  (((0							\
        -: 5513:     ? 0 : highest_active_reg - lowest_active_reg + 1)	\
        -: 5514:    * NUM_REG_ITEMS)					\
        -: 5515:   + NUM_NONREG_ITEMS)
        -: 5516:
        -: 5517:/* How many items can still be added to the stack without overflowing it.  */
        -: 5518:#define REMAINING_AVAIL_SLOTS ((fail_stack).size - (fail_stack).avail)
        -: 5519:
        -: 5520:
        -: 5521:/* Pops what PUSH_FAIL_STACK pushes.
        -: 5522:
        -: 5523:   We restore into the parameters, all of which should be lvalues:
        -: 5524:     STR -- the saved data position.
        -: 5525:     PAT -- the saved pattern position.
        -: 5526:     LOW_REG, HIGH_REG -- the highest and lowest active registers.
        -: 5527:     REGSTART, REGEND -- arrays of string positions.
        -: 5528:     REG_INFO -- array of information about each subexpression.
        -: 5529:
        -: 5530:   Also assumes the variables `fail_stack' and (if debugging), `bufp',
        -: 5531:   `pend', `string1', `size1', `string2', and `size2'.  */
        -: 5532:
        -: 5533:#define POP_FAILURE_POINT(str, pat, low_reg, high_reg, regstart, regend, reg_info)\
        -: 5534:{									\
        -: 5535:  DEBUG_STATEMENT (unsigned failure_id;)				\
        -: 5536:  active_reg_t this_reg;						\
        -: 5537:  const unsigned char *string_temp;					\
        -: 5538:									\
        -: 5539:  assert (!FAIL_STACK_EMPTY ());					\
        -: 5540:									\
        -: 5541:  /* Remove failure points and point to how many regs pushed.  */	\
        -: 5542:  DEBUG_PRINT1 ("POP_FAILURE_POINT:\n");				\
        -: 5543:  DEBUG_PRINT2 ("  Before pop, next avail: %d\n", fail_stack.avail);	\
        -: 5544:  DEBUG_PRINT2 ("                    size: %d\n", fail_stack.size);	\
        -: 5545:									\
        -: 5546:  assert (fail_stack.avail >= NUM_NONREG_ITEMS);			\
        -: 5547:									\
        -: 5548:  DEBUG_POP (&failure_id);						\
        -: 5549:  DEBUG_PRINT2 ("  Popping failure id: %u\n", failure_id);		\
        -: 5550:									\
        -: 5551:  /* If the saved string location is NULL, it came from an		\
        -: 5552:     on_failure_keep_string_jump opcode, and we want to throw away the	\
        -: 5553:     saved NULL, thus retaining our current position in the string.  */	\
        -: 5554:  string_temp = POP_FAILURE_POINTER ();					\
        -: 5555:  if (string_temp != NULL)						\
        -: 5556:    str = (const char *) string_temp;					\
        -: 5557:									\
        -: 5558:  DEBUG_PRINT2 ("  Popping string %p: `", str);				\
        -: 5559:  DEBUG_PRINT_DOUBLE_STRING (str, string1, size1, string2, size2);	\
        -: 5560:  DEBUG_PRINT1 ("'\n");							\
        -: 5561:									\
        -: 5562:  pat = (unsigned char *) POP_FAILURE_POINTER ();			\
        -: 5563:  DEBUG_PRINT2 ("  Popping pattern %p:\n", pat);			\
        -: 5564:  DEBUG_PRINT_COMPILED_PATTERN (bufp, pat, pend);			\
        -: 5565:									\
        -: 5566:  /* Restore register info.  */						\
        -: 5567:  high_reg = (active_reg_t) POP_FAILURE_INT ();				\
        -: 5568:  DEBUG_PRINT2 ("  Popping high active reg: %ld\n", high_reg);		\
        -: 5569:									\
        -: 5570:  low_reg = (active_reg_t) POP_FAILURE_INT ();				\
        -: 5571:  DEBUG_PRINT2 ("  Popping  low active reg: %ld\n", low_reg);		\
        -: 5572:									\
        -: 5573:  if (1)								\
        -: 5574:    for (this_reg = high_reg; this_reg >= low_reg; this_reg--)		\
        -: 5575:      {									\
        -: 5576:	DEBUG_PRINT2 ("    Popping reg: %ld\n", this_reg);		\
        -: 5577:									\
        -: 5578:	reg_info[this_reg].word = POP_FAILURE_ELT ();			\
        -: 5579:	DEBUG_PRINT2 ("      info: %p\n",				\
        -: 5580:		      reg_info[this_reg].word.pointer);			\
        -: 5581:									\
        -: 5582:	regend[this_reg] = (const char *) POP_FAILURE_POINTER ();	\
        -: 5583:	DEBUG_PRINT2 ("      end: %p\n", regend[this_reg]);		\
        -: 5584:									\
        -: 5585:	regstart[this_reg] = (const char *) POP_FAILURE_POINTER ();	\
        -: 5586:	DEBUG_PRINT2 ("      start: %p\n", regstart[this_reg]);		\
        -: 5587:      }									\
        -: 5588:  else									\
        -: 5589:    {									\
        -: 5590:      for (this_reg = highest_active_reg; this_reg > high_reg; this_reg--) \
        -: 5591:	{								\
        -: 5592:	  reg_info[this_reg].word.integer = 0;				\
        -: 5593:	  regend[this_reg] = 0;						\
        -: 5594:	  regstart[this_reg] = 0;					\
        -: 5595:	}								\
        -: 5596:      highest_active_reg = high_reg;					\
        -: 5597:    }									\
        -: 5598:									\
        -: 5599:  set_regs_matched_done = 0;						\
        -: 5600:  DEBUG_STATEMENT (nfailure_points_popped++);				\
        -: 5601:} /* POP_FAILURE_POINT */
        -: 5602:
        -: 5603:
        -: 5604:
        -: 5605:/* Structure for per-register (a.k.a. per-group) information.
        -: 5606:   Other register information, such as the
        -: 5607:   starting and ending positions (which are addresses), and the list of
        -: 5608:   inner groups (which is a bits list) are maintained in separate
        -: 5609:   variables.
        -: 5610:
        -: 5611:   We are making a (strictly speaking) nonportable assumption here: that
        -: 5612:   the compiler will pack our bit fields into something that fits into
        -: 5613:   the type of `word', i.e., is something that fits into one item on the
        -: 5614:   failure stack.  */
        -: 5615:
        -: 5616:
        -: 5617:/* Declarations and macros for re_match_2.  */
        -: 5618:
        -: 5619:typedef union
        -: 5620:{
        -: 5621:  fail_stack_elt_t word;
        -: 5622:  struct
        -: 5623:  {
        -: 5624:      /* This field is one if this group can match the empty string,
        -: 5625:         zero if not.  If not yet determined,  `MATCH_NULL_UNSET_VALUE'.  */
        -: 5626:#define MATCH_NULL_UNSET_VALUE 3
        -: 5627:    unsigned match_null_string_p : 2;
        -: 5628:    unsigned is_active : 1;
        -: 5629:    unsigned matched_something : 1;
        -: 5630:    unsigned ever_matched_something : 1;
        -: 5631:  } bits;
        -: 5632:} register_info_type;
        -: 5633:
        -: 5634:#define REG_MATCH_NULL_STRING_P(R)  ((R).bits.match_null_string_p)
        -: 5635:#define IS_ACTIVE(R)  ((R).bits.is_active)
        -: 5636:#define MATCHED_SOMETHING(R)  ((R).bits.matched_something)
        -: 5637:#define EVER_MATCHED_SOMETHING(R)  ((R).bits.ever_matched_something)
        -: 5638:
        -: 5639:
        -: 5640:/* Call this when have matched a real character; it sets `matched' flags
        -: 5641:   for the subexpressions which we are currently inside.  Also records
        -: 5642:   that those subexprs have matched.  */
        -: 5643:#define SET_REGS_MATCHED()						\
        -: 5644:  do									\
        -: 5645:    {									\
        -: 5646:      if (!set_regs_matched_done)					\
        -: 5647:	{								\
        -: 5648:	  active_reg_t r;						\
        -: 5649:	  set_regs_matched_done = 1;					\
        -: 5650:	  for (r = lowest_active_reg; r <= highest_active_reg; r++)	\
        -: 5651:	    {								\
        -: 5652:	      MATCHED_SOMETHING (reg_info[r])				\
        -: 5653:		= EVER_MATCHED_SOMETHING (reg_info[r])			\
        -: 5654:		= 1;							\
        -: 5655:	    }								\
        -: 5656:	}								\
        -: 5657:    }									\
        -: 5658:  while (0)
        -: 5659:
        -: 5660:/* Registers are set to a sentinel when they haven't yet matched.  */
        -: 5661:static char reg_unset_dummy;
        -: 5662:#define REG_UNSET_VALUE (&reg_unset_dummy)
        -: 5663:#define REG_UNSET(e) ((e) == REG_UNSET_VALUE)
        -: 5664:
        -: 5665:/* Subroutine declarations and macros for regex_compile.  */
        -: 5666:
        -: 5667:static reg_errcode_t regex_compile _RE_ARGS ((const char *pattern, size_t size,
        -: 5668:					      reg_syntax_t syntax,
        -: 5669:					      struct re_pattern_buffer *bufp));
        -: 5670:static void store_op1 _RE_ARGS ((re_opcode_t op, unsigned char *loc, int arg));
        -: 5671:static void store_op2 _RE_ARGS ((re_opcode_t op, unsigned char *loc,
        -: 5672:				 int arg1, int arg2));
        -: 5673:static void insert_op1 _RE_ARGS ((re_opcode_t op, unsigned char *loc,
        -: 5674:				  int arg, unsigned char *end));
        -: 5675:static void insert_op2 _RE_ARGS ((re_opcode_t op, unsigned char *loc,
        -: 5676:				  int arg1, int arg2, unsigned char *end));
        -: 5677:static boolean at_begline_loc_p _RE_ARGS ((const char *pattern, const char *p,
        -: 5678:					   reg_syntax_t syntax));
        -: 5679:static boolean at_endline_loc_p _RE_ARGS ((const char *p, const char *pend,
        -: 5680:					   reg_syntax_t syntax));
        -: 5681:static reg_errcode_t compile_range _RE_ARGS ((const char **p_ptr,
        -: 5682:					      const char *pend,
        -: 5683:					      char *translate,
        -: 5684:					      reg_syntax_t syntax,
        -: 5685:					      unsigned char *b));
        -: 5686:
        -: 5687:/* Fetch the next character in the uncompiled pattern---translating it
        -: 5688:   if necessary.  Also cast from a signed character in the constant
        -: 5689:   string passed to us by the user to an unsigned char that we can use
        -: 5690:   as an array index (in, e.g., `translate').  */
        -: 5691:#ifndef PATFETCH
        -: 5692:# define PATFETCH(c)							\
        -: 5693:  do {if (p == pend) return REG_EEND;					\
        -: 5694:    c = (unsigned char) *p++;						\
        -: 5695:    if (translate) c = (unsigned char) translate[c];			\
        -: 5696:  } while (0)
        -: 5697:#endif
        -: 5698:
        -: 5699:/* Fetch the next character in the uncompiled pattern, with no
        -: 5700:   translation.  */
        -: 5701:#define PATFETCH_RAW(c)							\
        -: 5702:  do {if (p == pend) return REG_EEND;					\
        -: 5703:    c = (unsigned char) *p++; 						\
        -: 5704:  } while (0)
        -: 5705:
        -: 5706:/* Go backwards one character in the pattern.  */
        -: 5707:#define PATUNFETCH p--
        -: 5708:
        -: 5709:
        -: 5710:/* If `translate' is non-null, return translate[D], else just D.  We
        -: 5711:   cast the subscript to translate because some data is declared as
        -: 5712:   `char *', to avoid warnings when a string constant is passed.  But
        -: 5713:   when we use a character as a subscript we must make it unsigned.  */
        -: 5714:#ifndef TRANSLATE
        -: 5715:# define TRANSLATE(d) \
        -: 5716:  (translate ? (char) translate[(unsigned char) (d)] : (d))
        -: 5717:#endif
        -: 5718:
        -: 5719:
        -: 5720:/* Macros for outputting the compiled pattern into `buffer'.  */
        -: 5721:
        -: 5722:/* If the buffer isn't allocated when it comes in, use this.  */
        -: 5723:#define INIT_BUF_SIZE  32
        -: 5724:
        -: 5725:/* Make sure we have at least N more bytes of space in buffer.  */
        -: 5726:#define GET_BUFFER_SPACE(n)						\
        -: 5727:    while ((unsigned long) (b - bufp->buffer + (n)) > bufp->allocated)	\
        -: 5728:      EXTEND_BUFFER ()
        -: 5729:
        -: 5730:/* Make sure we have one more byte of buffer space and then add C to it.  */
        -: 5731:#define BUF_PUSH(c)							\
        -: 5732:  do {									\
        -: 5733:    GET_BUFFER_SPACE (1);						\
        -: 5734:    *b++ = (unsigned char) (c);						\
        -: 5735:  } while (0)
        -: 5736:
        -: 5737:
        -: 5738:/* Ensure we have two more bytes of buffer space and then append C1 and C2.  */
        -: 5739:#define BUF_PUSH_2(c1, c2)						\
        -: 5740:  do {									\
        -: 5741:    GET_BUFFER_SPACE (2);						\
        -: 5742:    *b++ = (unsigned char) (c1);					\
        -: 5743:    *b++ = (unsigned char) (c2);					\
        -: 5744:  } while (0)
        -: 5745:
        -: 5746:
        -: 5747:/* As with BUF_PUSH_2, except for three bytes.  */
        -: 5748:#define BUF_PUSH_3(c1, c2, c3)						\
        -: 5749:  do {									\
        -: 5750:    GET_BUFFER_SPACE (3);						\
        -: 5751:    *b++ = (unsigned char) (c1);					\
        -: 5752:    *b++ = (unsigned char) (c2);					\
        -: 5753:    *b++ = (unsigned char) (c3);					\
        -: 5754:  } while (0)
        -: 5755:
        -: 5756:
        -: 5757:/* Store a jump with opcode OP at LOC to location TO.  We store a
        -: 5758:   relative address offset by the three bytes the jump itself occupies.  */
        -: 5759:#define STORE_JUMP(op, loc, to) \
        -: 5760:  store_op1 (op, loc, (int) ((to) - (loc) - 3))
        -: 5761:
        -: 5762:/* Likewise, for a two-argument jump.  */
        -: 5763:#define STORE_JUMP2(op, loc, to, arg) \
        -: 5764:  store_op2 (op, loc, (int) ((to) - (loc) - 3), arg)
        -: 5765:
        -: 5766:/* Like `STORE_JUMP', but for inserting.  Assume `b' is the buffer end.  */
        -: 5767:#define INSERT_JUMP(op, loc, to) \
        -: 5768:  insert_op1 (op, loc, (int) ((to) - (loc) - 3), b)
        -: 5769:
        -: 5770:/* Like `STORE_JUMP2', but for inserting.  Assume `b' is the buffer end.  */
        -: 5771:#define INSERT_JUMP2(op, loc, to, arg) \
        -: 5772:  insert_op2 (op, loc, (int) ((to) - (loc) - 3), arg, b)
        -: 5773:
        -: 5774:
        -: 5775:/* This is not an arbitrary limit: the arguments which represent offsets
        -: 5776:   into the pattern are two bytes long.  So if 2^16 bytes turns out to
        -: 5777:   be too small, many things would have to change.  */
        -: 5778:/* Any other compiler which, like MSC, has allocation limit below 2^16
        -: 5779:   bytes will have to use approach similar to what was done below for
        -: 5780:   MSC and drop MAX_BUF_SIZE a bit.  Otherwise you may end up
        -: 5781:   reallocating to 0 bytes.  Such thing is not going to work too well.
        -: 5782:   You have been warned!!  */
        -: 5783:#if defined _MSC_VER  && !defined WIN32
        -: 5784:/* Microsoft C 16-bit versions limit malloc to approx 65512 bytes.
        -: 5785:   The REALLOC define eliminates a flurry of conversion warnings,
        -: 5786:   but is not required. */
        -: 5787:# define MAX_BUF_SIZE  65500L
        -: 5788:# define EXTEND_BUFFER_REALLOC(p,s) realloc ((p), (size_t) (s))
        -: 5789:#else
        -: 5790:# define MAX_BUF_SIZE (1L << 16)
        -: 5791:# define EXTEND_BUFFER_REALLOC(p,s) realloc ((p), (s))
        -: 5792:#endif
        -: 5793:
        -: 5794:/* Extend the buffer by twice its current size via realloc and
        -: 5795:   reset the pointers that pointed into the old block to point to the
        -: 5796:   correct places in the new one.  If extending the buffer results in it
        -: 5797:   being larger than MAX_BUF_SIZE, then flag memory exhausted.  */
        -: 5798:#define EXTEND_BUFFER()							\
        -: 5799:  do { 									\
        -: 5800:    unsigned char *old_buffer = bufp->buffer;				\
        -: 5801:    if (bufp->allocated == MAX_BUF_SIZE) 				\
        -: 5802:      return REG_ESIZE;							\
        -: 5803:    bufp->allocated <<= 1;						\
        -: 5804:    if (bufp->allocated > MAX_BUF_SIZE)					\
        -: 5805:      bufp->allocated = MAX_BUF_SIZE; 					\
        -: 5806:    bufp->buffer = (unsigned char *) EXTEND_BUFFER_REALLOC (bufp->buffer, bufp->allocated);\
        -: 5807:    if (bufp->buffer == NULL)						\
        -: 5808:      return REG_ESPACE;						\
        -: 5809:    /* If the buffer moved, move all the pointers into it.  */		\
        -: 5810:    if (old_buffer != bufp->buffer)					\
        -: 5811:      {									\
        -: 5812:        b = (b - old_buffer) + bufp->buffer;				\
        -: 5813:        begalt = (begalt - old_buffer) + bufp->buffer;			\
        -: 5814:        if (fixup_alt_jump)						\
        -: 5815:          fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;\
        -: 5816:        if (laststart)							\
        -: 5817:          laststart = (laststart - old_buffer) + bufp->buffer;		\
        -: 5818:        if (pending_exact)						\
        -: 5819:          pending_exact = (pending_exact - old_buffer) + bufp->buffer;	\
        -: 5820:      }									\
        -: 5821:  } while (0)
        -: 5822:
        -: 5823:
        -: 5824:/* Since we have one byte reserved for the register number argument to
        -: 5825:   {start,stop}_memory, the maximum number of groups we can report
        -: 5826:   things about is what fits in that byte.  */
        -: 5827:#define MAX_REGNUM 255
        -: 5828:
        -: 5829:/* But patterns can have more than `MAX_REGNUM' registers.  We just
        -: 5830:   ignore the excess.  */
        -: 5831:typedef unsigned regnum_t;
        -: 5832:
        -: 5833:
        -: 5834:/* Macros for the compile stack.  */
        -: 5835:
        -: 5836:/* Since offsets can go either forwards or backwards, this type needs to
        -: 5837:   be able to hold values from -(MAX_BUF_SIZE - 1) to MAX_BUF_SIZE - 1.  */
        -: 5838:/* int may be not enough when sizeof(int) == 2.  */
        -: 5839:typedef long pattern_offset_t;
        -: 5840:
        -: 5841:typedef struct
        -: 5842:{
        -: 5843:  pattern_offset_t begalt_offset;
        -: 5844:  pattern_offset_t fixup_alt_jump;
        -: 5845:  pattern_offset_t inner_group_offset;
        -: 5846:  pattern_offset_t laststart_offset;
        -: 5847:  regnum_t regnum;
        -: 5848:} compile_stack_elt_t;
        -: 5849:
        -: 5850:
        -: 5851:typedef struct
        -: 5852:{
        -: 5853:  compile_stack_elt_t *stack;
        -: 5854:  unsigned size;
        -: 5855:  unsigned avail;			/* Offset of next open position.  */
        -: 5856:} compile_stack_type;
        -: 5857:
        -: 5858:
        -: 5859:#define INIT_COMPILE_STACK_SIZE 32
        -: 5860:
        -: 5861:#define COMPILE_STACK_EMPTY  (compile_stack.avail == 0)
        -: 5862:#define COMPILE_STACK_FULL  (compile_stack.avail == compile_stack.size)
        -: 5863:
        -: 5864:/* The next available element.  */
        -: 5865:#define COMPILE_STACK_TOP (compile_stack.stack[compile_stack.avail])
        -: 5866:
        -: 5867:
        -: 5868:/* Set the bit for character C in a list.  */
        -: 5869:#define SET_LIST_BIT(c)                               \
        -: 5870:  (b[((unsigned char) (c)) / BYTEWIDTH]               \
        -: 5871:   |= 1 << (((unsigned char) c) % BYTEWIDTH))
        -: 5872:
        -: 5873:
        -: 5874:/* Get the next unsigned number in the uncompiled pattern.  */
        -: 5875:#define GET_UNSIGNED_NUMBER(num) 					\
        -: 5876:  { if (p != pend)							\
        -: 5877:     {									\
        -: 5878:       PATFETCH (c); 							\
        -: 5879:       while (ISDIGIT (c)) 						\
        -: 5880:         { 								\
        -: 5881:           if (num < 0)							\
        -: 5882:              num = 0;							\
        -: 5883:           num = num * 10 + c - '0'; 					\
        -: 5884:           if (p == pend) 						\
        -: 5885:              break; 							\
        -: 5886:           PATFETCH (c);						\
        -: 5887:         } 								\
        -: 5888:       } 								\
        -: 5889:    }
        -: 5890:
        -: 5891:#if defined _LIBC || (defined HAVE_WCTYPE_H && defined HAVE_WCHAR_H)
        -: 5892:/* The GNU C library provides support for user-defined character classes
        -: 5893:   and the functions from ISO C amendement 1.  */
        -: 5894:# ifdef CHARCLASS_NAME_MAX
        -: 5895:#  define CHAR_CLASS_MAX_LENGTH CHARCLASS_NAME_MAX
        -: 5896:# else
        -: 5897:/* This shouldn't happen but some implementation might still have this
        -: 5898:   problem.  Use a reasonable default value.  */
        -: 5899:#  define CHAR_CLASS_MAX_LENGTH 256
        -: 5900:# endif
        -: 5901:
        -: 5902:# ifdef _LIBC
        -: 5903:#  define IS_CHAR_CLASS(string) __wctype (string)
        -: 5904:# else
        -: 5905:#  define IS_CHAR_CLASS(string) wctype (string)
        -: 5906:# endif
        -: 5907:#else
        -: 5908:# define CHAR_CLASS_MAX_LENGTH  6 /* Namely, `xdigit'.  */
        -: 5909:
        -: 5910:# define IS_CHAR_CLASS(string)						\
        -: 5911:   (STREQ (string, "alpha") || STREQ (string, "upper")			\
        -: 5912:    || STREQ (string, "lower") || STREQ (string, "digit")		\
        -: 5913:    || STREQ (string, "alnum") || STREQ (string, "xdigit")		\
        -: 5914:    || STREQ (string, "space") || STREQ (string, "print")		\
        -: 5915:    || STREQ (string, "punct") || STREQ (string, "graph")		\
        -: 5916:    || STREQ (string, "cntrl") || STREQ (string, "blank"))
        -: 5917:#endif
        -: 5918:
        -: 5919:#ifndef MATCH_MAY_ALLOCATE
        -: 5920:
        -: 5921:/* If we cannot allocate large objects within re_match_2_internal,
        -: 5922:   we make the fail stack and register vectors global.
        -: 5923:   The fail stack, we grow to the maximum size when a regexp
        -: 5924:   is compiled.
        -: 5925:   The register vectors, we adjust in size each time we
        -: 5926:   compile a regexp, according to the number of registers it needs.  */
        -: 5927:
        -: 5928:static fail_stack_type fail_stack;
        -: 5929:
        -: 5930:/* Size with which the following vectors are currently allocated.
        -: 5931:   That is so we can make them bigger as needed,
        -: 5932:   but never make them smaller.  */
        -: 5933:static int regs_allocated_size;
        -: 5934:
        -: 5935:static const char **     regstart, **     regend;
        -: 5936:static const char ** old_regstart, ** old_regend;
        -: 5937:static const char **best_regstart, **best_regend;
        -: 5938:static register_info_type *reg_info;
        -: 5939:static const char **reg_dummy;
        -: 5940:static register_info_type *reg_info_dummy;
        -: 5941:
        -: 5942:/* Make the register vectors big enough for NUM_REGS registers,
        -: 5943:   but don't make them smaller.  */
        -: 5944:
        -: 5945:static
        -: 5946:regex_grow_registers (num_regs)
        -: 5947:     int num_regs;
        -: 5948:{
        -: 5949:  if (num_regs > regs_allocated_size)
        -: 5950:    {
        -: 5951:      RETALLOC_IF (regstart,	 num_regs, const char *);
        -: 5952:      RETALLOC_IF (regend,	 num_regs, const char *);
        -: 5953:      RETALLOC_IF (old_regstart, num_regs, const char *);
        -: 5954:      RETALLOC_IF (old_regend,	 num_regs, const char *);
        -: 5955:      RETALLOC_IF (best_regstart, num_regs, const char *);
        -: 5956:      RETALLOC_IF (best_regend,	 num_regs, const char *);
        -: 5957:      RETALLOC_IF (reg_info,	 num_regs, register_info_type);
        -: 5958:      RETALLOC_IF (reg_dummy,	 num_regs, const char *);
        -: 5959:      RETALLOC_IF (reg_info_dummy, num_regs, register_info_type);
        -: 5960:
        -: 5961:      regs_allocated_size = num_regs;
        -: 5962:    }
        -: 5963:}
        -: 5964:
        -: 5965:#endif /* not MATCH_MAY_ALLOCATE */
        -: 5966:
        -: 5967:static boolean group_in_compile_stack _RE_ARGS ((compile_stack_type
        -: 5968:						 compile_stack,
        -: 5969:						 regnum_t regnum));
        -: 5970:
        -: 5971:/* `regex_compile' compiles PATTERN (of length SIZE) according to SYNTAX.
        -: 5972:   Returns one of error codes defined in `regex-gnu.h', or zero for success.
        -: 5973:
        -: 5974:   Assumes the `allocated' (and perhaps `buffer') and `translate'
        -: 5975:   fields are set in BUFP on entry.
        -: 5976:
        -: 5977:   If it succeeds, results are put in BUFP (if it returns an error, the
        -: 5978:   contents of BUFP are undefined):
        -: 5979:     `buffer' is the compiled pattern;
        -: 5980:     `syntax' is set to SYNTAX;
        -: 5981:     `used' is set to the length of the compiled pattern;
        -: 5982:     `fastmap_accurate' is zero;
        -: 5983:     `re_nsub' is the number of subexpressions in PATTERN;
        -: 5984:     `not_bol' and `not_eol' are zero;
        -: 5985:
        -: 5986:   The `fastmap' and `newline_anchor' fields are neither
        -: 5987:   examined nor set.  */
        -: 5988:
        -: 5989:/* Return, freeing storage we allocated.  */
        -: 5990:#define FREE_STACK_RETURN(value)		\
        -: 5991:  return (free (compile_stack.stack), value)
        -: 5992:
        -: 5993:static reg_errcode_t
function regex_compile called 622 returned 100% blocks executed 28%
      622: 5994:regex_compile (pattern, size, syntax, bufp)
        -: 5995:     const char *pattern;
        -: 5996:     size_t size;
        -: 5997:     reg_syntax_t syntax;
        -: 5998:     struct re_pattern_buffer *bufp;
        -: 5999:{
        -: 6000:  /* We fetch characters from PATTERN here.  Even though PATTERN is
        -: 6001:     `char *' (i.e., signed), we declare these variables as unsigned, so
        -: 6002:     they can be reliably used as array indices.  */
        -: 6003:  register unsigned char c, c1;
        -: 6004:
        -: 6005:  /* A random temporary spot in PATTERN.  */
        -: 6006:  const char *p1;
        -: 6007:
        -: 6008:  /* Points to the end of the buffer, where we should append.  */
        -: 6009:  register unsigned char *b;
        -: 6010:
        -: 6011:  /* Keeps track of unclosed groups.  */
        -: 6012:  compile_stack_type compile_stack;
        -: 6013:
        -: 6014:  /* Points to the current (ending) position in the pattern.  */
      622: 6015:  const char *p = pattern;
      622: 6016:  const char *pend = pattern + size;
        -: 6017:
        -: 6018:  /* How to translate the characters in the pattern.  */
      622: 6019:  RE_TRANSLATE_TYPE translate = bufp->translate;
        -: 6020:
        -: 6021:  /* Address of the count-byte of the most recently inserted `exactn'
        -: 6022:     command.  This makes it possible to tell if a new exact-match
        -: 6023:     character can be added to that command or if the character requires
        -: 6024:     a new `exactn' command.  */
      622: 6025:  unsigned char *pending_exact = 0;
        -: 6026:
        -: 6027:  /* Address of start of the most recently finished expression.
        -: 6028:     This tells, e.g., postfix * where to find the start of its
        -: 6029:     operand.  Reset at the beginning of groups and alternatives.  */
      622: 6030:  unsigned char *laststart = 0;
        -: 6031:
        -: 6032:  /* Address of beginning of regexp, or inside of last group.  */
        -: 6033:  unsigned char *begalt;
        -: 6034:
        -: 6035:  /* Place in the uncompiled pattern (i.e., the {) to
        -: 6036:     which to go back if the interval is invalid.  */
        -: 6037:  const char *beg_interval;
        -: 6038:
        -: 6039:  /* Address of the place where a forward jump should go to the end of
        -: 6040:     the containing expression.  Each alternative of an `or' -- except the
        -: 6041:     last -- ends with a forward jump of this sort.  */
      622: 6042:  unsigned char *fixup_alt_jump = 0;
        -: 6043:
        -: 6044:  /* Counts open-groups as they are encountered.  Remembered for the
        -: 6045:     matching close-group on the compile stack, so the same register
        -: 6046:     number is put in the stop_memory as the start_memory.  */
      622: 6047:  regnum_t regnum = 0;
        -: 6048:
        -: 6049:#ifdef DEBUG
        -: 6050:  DEBUG_PRINT1 ("\nCompiling pattern: ");
        -: 6051:  if (debug)
        -: 6052:    {
        -: 6053:      unsigned debug_count;
        -: 6054:
        -: 6055:      for (debug_count = 0; debug_count < size; debug_count++)
        -: 6056:        putchar (pattern[debug_count]);
        -: 6057:      putchar ('\n');
        -: 6058:    }
        -: 6059:#endif /* DEBUG */
        -: 6060:
        -: 6061:  /* Initialize the compile stack.  */
      622: 6062:  compile_stack.stack = TALLOC (INIT_COMPILE_STACK_SIZE, compile_stack_elt_t);
      622: 6063:  if (compile_stack.stack == NULL)
branch  0 taken 0 (fallthrough)
branch  1 taken 622
    #####: 6064:    return REG_ESPACE;
        -: 6065:
      622: 6066:  compile_stack.size = INIT_COMPILE_STACK_SIZE;
      622: 6067:  compile_stack.avail = 0;
        -: 6068:
        -: 6069:  /* Initialize the pattern buffer.  */
      622: 6070:  bufp->syntax = syntax;
      622: 6071:  bufp->fastmap_accurate = 0;
      622: 6072:  bufp->not_bol = bufp->not_eol = 0;
        -: 6073:
        -: 6074:  /* Set `used' to zero, so that if we return an error, the pattern
        -: 6075:     printer (for debugging) will think there's no pattern.  We reset it
        -: 6076:     at the end.  */
      622: 6077:  bufp->used = 0;
        -: 6078:
        -: 6079:  /* Always count groups, whether or not bufp->no_sub is set.  */
      622: 6080:  bufp->re_nsub = 0;
        -: 6081:
        -: 6082:#if !defined emacs && !defined SYNTAX_TABLE
        -: 6083:  /* Initialize the syntax table.  */
      622: 6084:   init_syntax_once ();
call    0 returned 622
        -: 6085:#endif
        -: 6086:
      622: 6087:  if (bufp->allocated == 0)
branch  0 taken 622 (fallthrough)
branch  1 taken 0
        -: 6088:    {
      622: 6089:      if (bufp->buffer)
branch  0 taken 0 (fallthrough)
branch  1 taken 622
        -: 6090:	{ /* If zero allocated, but buffer is non-null, try to realloc
        -: 6091:             enough space.  This loses if buffer's address is bogus, but
        -: 6092:             that is the user's responsibility.  */
    #####: 6093:          RETALLOC (bufp->buffer, INIT_BUF_SIZE, unsigned char);
        -: 6094:        }
        -: 6095:      else
        -: 6096:        { /* Caller did not allocate a buffer.  Do it for them.  */
      622: 6097:          bufp->buffer = TALLOC (INIT_BUF_SIZE, unsigned char);
        -: 6098:        }
     622*: 6099:      if (!bufp->buffer) FREE_STACK_RETURN (REG_ESPACE);
branch  0 taken 0 (fallthrough)
branch  1 taken 622
        -: 6100:
      622: 6101:      bufp->allocated = INIT_BUF_SIZE;
        -: 6102:    }
        -: 6103:
      622: 6104:  begalt = b = bufp->buffer;
        -: 6105:
        -: 6106:  /* Loop through the uncompiled pattern until we're at the end.  */
     3396: 6107:  while (p != pend)
branch  0 taken 2774
branch  1 taken 622 (fallthrough)
        -: 6108:    {
    2774*: 6109:      PATFETCH (c);
branch  0 taken 0 (fallthrough)
branch  1 taken 2774
branch  2 taken 0 (fallthrough)
branch  3 taken 2774
        -: 6110:
     2774: 6111:      switch (c)
branch  0 taken 153
branch  1 taken 106
branch  2 taken 0
branch  3 taken 139
branch  4 taken 123
branch  5 taken 9
branch  6 taken 2
branch  7 taken 2
branch  8 taken 20
branch  9 taken 1
branch 10 taken 0
branch 11 taken 339
branch 12 taken 1880
        -: 6112:        {
      153: 6113:        case '^':
        -: 6114:          {
      153: 6115:            if (   /* If at start of pattern, it's an operator.  */
      153: 6116:                   p == pattern + 1
branch  0 taken 0 (fallthrough)
branch  1 taken 153
        -: 6117:                   /* If context independent, it's an operator.  */
    #####: 6118:                || syntax & RE_CONTEXT_INDEP_ANCHORS
branch  0 never executed
branch  1 never executed
        -: 6119:                   /* Otherwise, depends on what's come before.  */
    #####: 6120:                || at_begline_loc_p (pattern, p, syntax))
call    0 never executed
branch  1 never executed
branch  2 never executed
     153*: 6121:              BUF_PUSH (begline);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 taken 0
branch 15 taken 153 (fallthrough)
        -: 6122:            else
    #####: 6123:              goto normal_char;
        -: 6124:          }
      153: 6125:          break;
        -: 6126:
        -: 6127:
      106: 6128:        case '$':
        -: 6129:          {
      106: 6130:            if (   /* If at end of pattern, it's an operator.  */
      106: 6131:                   p == pend
branch  0 taken 0 (fallthrough)
branch  1 taken 106
        -: 6132:                   /* If context independent, it's an operator.  */
    #####: 6133:                || syntax & RE_CONTEXT_INDEP_ANCHORS
branch  0 never executed
branch  1 never executed
        -: 6134:                   /* Otherwise, depends on what's next.  */
    #####: 6135:                || at_endline_loc_p (p, pend, syntax))
call    0 never executed
branch  1 never executed
branch  2 never executed
     106*: 6136:               BUF_PUSH (endline);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 taken 0
branch 15 taken 106 (fallthrough)
        -: 6137:             else
    #####: 6138:               goto normal_char;
        -: 6139:           }
      106: 6140:           break;
        -: 6141:
        -: 6142:
    #####: 6143:	case '+':
        -: 6144:        case '?':
    #####: 6145:          if ((syntax & RE_BK_PLUS_QM)
branch  0 never executed
branch  1 never executed
    #####: 6146:              || (syntax & RE_LIMITED_OPS))
branch  0 never executed
branch  1 never executed
    #####: 6147:            goto normal_char;
    #####: 6148:        handle_plus:
      139: 6149:        case '*':
        -: 6150:          /* If there is no previous pattern... */
      139: 6151:          if (!laststart)
branch  0 taken 8 (fallthrough)
branch  1 taken 131
        -: 6152:            {
        8: 6153:              if (syntax & RE_CONTEXT_INVALID_OPS)
branch  0 taken 0 (fallthrough)
branch  1 taken 8
    #####: 6154:                FREE_STACK_RETURN (REG_BADRPT);
        8: 6155:              else if (!(syntax & RE_CONTEXT_INDEP_OPS))
branch  0 taken 8 (fallthrough)
branch  1 taken 0
        8: 6156:                goto normal_char;
        -: 6157:            }
        -: 6158:
        -: 6159:          {
        -: 6160:            /* Are we optimizing this jump?  */
      131: 6161:            boolean keep_string_p = false;
        -: 6162:
        -: 6163:            /* 1 means zero (many) matches is allowed.  */
      131: 6164:            char zero_times_ok = 0, many_times_ok = 0;
        -: 6165:
        -: 6166:            /* If there is a sequence of repetition chars, collapse it
        -: 6167:               down to just one (the right one).  We can't combine
        -: 6168:               interval operators with these because of, e.g., `a{2}*',
        -: 6169:               which should only match an even number of `a's.  */
        -: 6170:
        -: 6171:            for (;;)
        -: 6172:              {
      131: 6173:                zero_times_ok |= c != '+';
      131: 6174:                many_times_ok |= c != '?';
        -: 6175:
      131: 6176:                if (p == pend)
branch  0 taken 74 (fallthrough)
branch  1 taken 57
       74: 6177:                  break;
        -: 6178:
      57*: 6179:                PATFETCH (c);
branch  0 taken 0 (fallthrough)
branch  1 taken 57
branch  2 taken 0 (fallthrough)
branch  3 taken 57
        -: 6180:
       57: 6181:                if (c == '*'
branch  0 taken 57 (fallthrough)
branch  1 taken 0
      57*: 6182:                    || (!(syntax & RE_BK_PLUS_QM) && (c == '+' || c == '?')))
branch  0 taken 0 (fallthrough)
branch  1 taken 57
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 6183:                  ;
        -: 6184:
       57: 6185:                else if (syntax & RE_BK_PLUS_QM  &&  c == '\\')
branch  0 taken 57 (fallthrough)
branch  1 taken 0
branch  2 taken 13 (fallthrough)
branch  3 taken 44
        -: 6186:                  {
      13*: 6187:                    if (p == pend) FREE_STACK_RETURN (REG_EESCAPE);
branch  0 taken 0 (fallthrough)
branch  1 taken 13
        -: 6188:
      13*: 6189:                    PATFETCH (c1);
branch  0 taken 0 (fallthrough)
branch  1 taken 13
branch  2 taken 0 (fallthrough)
branch  3 taken 13
       13: 6190:                    if (!(c1 == '+' || c1 == '?'))
branch  0 taken 13 (fallthrough)
branch  1 taken 0
branch  2 taken 13 (fallthrough)
branch  3 taken 0
        -: 6191:                      {
       13: 6192:                        PATUNFETCH;
       13: 6193:                        PATUNFETCH;
       13: 6194:                        break;
        -: 6195:                      }
        -: 6196:
    #####: 6197:                    c = c1;
        -: 6198:                  }
        -: 6199:                else
        -: 6200:                  {
       44: 6201:                    PATUNFETCH;
       44: 6202:                    break;
        -: 6203:                  }
        -: 6204:
        -: 6205:                /* If we get here, we found another repeat character.  */
        -: 6206:               }
        -: 6207:
        -: 6208:            /* Star, etc. applied to an empty pattern is equivalent
        -: 6209:               to an empty pattern.  */
      131: 6210:            if (!laststart)
branch  0 taken 0 (fallthrough)
branch  1 taken 131
    #####: 6211:              break;
        -: 6212:
        -: 6213:            /* Now we know whether or not zero matches is allowed
        -: 6214:               and also whether or not two or more matches is allowed.  */
      131: 6215:            if (many_times_ok)
branch  0 taken 131 (fallthrough)
branch  1 taken 0
        -: 6216:              { /* More than one repetition is allowed, so put in at the
        -: 6217:                   end a backward relative jump from `b' to before the next
        -: 6218:                   jump we're going to put in below (which jumps from
        -: 6219:                   laststart to after this jump).
        -: 6220:
        -: 6221:                   But if we are at the `*' in the exact sequence `.*\n',
        -: 6222:                   insert an unconditional jump backwards to the .,
        -: 6223:                   instead of the beginning of the loop.  This way we only
        -: 6224:                   push a failure point once, instead of every time
        -: 6225:                   through the loop.  */
        -: 6226:                assert (p - 1 > pattern);
        -: 6227:
        -: 6228:                /* Allocate the space for the jump.  */
     131*: 6229:                GET_BUFFER_SPACE (3);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 taken 0
branch 15 taken 131 (fallthrough)
        -: 6230:
        -: 6231:                /* We know we are not at the first character of the pattern,
        -: 6232:                   because laststart was nonzero.  And we've already
        -: 6233:                   incremented `p', by the way, to be the character after
        -: 6234:                   the `*'.  Do we have to do something analogous here
        -: 6235:                   for null bytes, because of RE_DOT_NOT_NULL?  */
     131*: 6236:                if (TRANSLATE (*(p - 2)) == TRANSLATE ('.')
branch  0 taken 0 (fallthrough)
branch  1 taken 131
branch  2 taken 0 (fallthrough)
branch  3 taken 131
branch  4 taken 123 (fallthrough)
branch  5 taken 8
      123: 6237:		    && zero_times_ok
branch  0 taken 123 (fallthrough)
branch  1 taken 0
     123*: 6238:                    && p < pend && TRANSLATE (*p) == TRANSLATE ('\n')
branch  0 taken 57 (fallthrough)
branch  1 taken 66
branch  2 taken 0 (fallthrough)
branch  3 taken 57
branch  4 taken 0 (fallthrough)
branch  5 taken 57
branch  6 taken 0 (fallthrough)
branch  7 taken 57
    #####: 6239:                    && !(syntax & RE_DOT_NEWLINE))
branch  0 never executed
branch  1 never executed
        -: 6240:                  { /* We have .*\n.  */
    #####: 6241:                    STORE_JUMP (jump, b, laststart);
call    0 never executed
    #####: 6242:                    keep_string_p = true;
        -: 6243:                  }
        -: 6244:                else
        -: 6245:                  /* Anything else.  */
      131: 6246:                  STORE_JUMP (maybe_pop_jump, b, laststart - 3);
call    0 returned 131
        -: 6247:
        -: 6248:                /* We've added more stuff to the buffer.  */
      131: 6249:                b += 3;
        -: 6250:              }
        -: 6251:
        -: 6252:            /* On failure, jump from laststart to b + 3, which will be the
        -: 6253:               end of the buffer after this jump is inserted.  */
     131*: 6254:            GET_BUFFER_SPACE (3);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 taken 0
branch 15 taken 131 (fallthrough)
     131*: 6255:            INSERT_JUMP (keep_string_p ? on_failure_keep_string_jump
branch  0 taken 0 (fallthrough)
branch  1 taken 131
call    2 returned 131
        -: 6256:                                       : on_failure_jump,
        -: 6257:                         laststart, b + 3);
      131: 6258:            pending_exact = 0;
      131: 6259:            b += 3;
        -: 6260:
      131: 6261:            if (!zero_times_ok)
branch  0 taken 0 (fallthrough)
branch  1 taken 131
        -: 6262:              {
        -: 6263:                /* At least one repetition is required, so insert a
        -: 6264:                   `dummy_failure_jump' before the initial
        -: 6265:                   `on_failure_jump' instruction of the loop. This
        -: 6266:                   effects a skip over that instruction the first time
        -: 6267:                   we hit that loop.  */
    #####: 6268:                GET_BUFFER_SPACE (3);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
    #####: 6269:                INSERT_JUMP (dummy_failure_jump, laststart, laststart + 6);
call    0 never executed
    #####: 6270:                b += 3;
        -: 6271:              }
        -: 6272:            }
      131: 6273:	  break;
        -: 6274:
        -: 6275:
      123: 6276:	case '.':
      123: 6277:          laststart = b;
     123*: 6278:          BUF_PUSH (anychar);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 taken 0
branch 15 taken 123 (fallthrough)
      123: 6279:          break;
        -: 6280:
        -: 6281:
        9: 6282:        case '[':
        -: 6283:          {
        9: 6284:            boolean had_char_class = false;
        -: 6285:
       9*: 6286:            if (p == pend) FREE_STACK_RETURN (REG_EBRACK);
branch  0 taken 0 (fallthrough)
branch  1 taken 9
        -: 6287:
        -: 6288:            /* Ensure that we have enough space to push a charset: the
        -: 6289:               opcode, the length count, and the bitset; 34 bytes in all.  */
      18*: 6290:	    GET_BUFFER_SPACE (34);
branch  0 taken 0 (fallthrough)
branch  1 taken 9
branch  2 taken 0 (fallthrough)
branch  3 taken 9
branch  4 taken 0 (fallthrough)
branch  5 taken 9
branch  6 taken 0 (fallthrough)
branch  7 taken 9
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 taken 9
branch 15 taken 9 (fallthrough)
        -: 6291:
        9: 6292:            laststart = b;
        -: 6293:
        -: 6294:            /* We test `*p == '^' twice, instead of using an if
        -: 6295:               statement, so we only need one BUF_PUSH.  */
       9*: 6296:            BUF_PUSH (*p == '^' ? charset_not : charset);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 taken 0
branch 15 taken 9 (fallthrough)
branch 16 taken 1 (fallthrough)
branch 17 taken 8
        9: 6297:            if (*p == '^')
branch  0 taken 1 (fallthrough)
branch  1 taken 8
        1: 6298:              p++;
        -: 6299:
        -: 6300:            /* Remember the first position in the bracket expression.  */
        9: 6301:            p1 = p;
        -: 6302:
        -: 6303:            /* Push the number of bytes in the bitmap.  */
       9*: 6304:            BUF_PUSH ((1 << BYTEWIDTH) / BYTEWIDTH);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 taken 0
branch 15 taken 9 (fallthrough)
        -: 6305:
        -: 6306:            /* Clear the whole map.  */
        9: 6307:            bzero (b, (1 << BYTEWIDTH) / BYTEWIDTH);
        -: 6308:
        -: 6309:            /* charset_not matches newline according to a syntax bit.  */
        9: 6310:            if ((re_opcode_t) b[-2] == charset_not
branch  0 taken 1 (fallthrough)
branch  1 taken 8
        1: 6311:                && (syntax & RE_HAT_LISTS_NOT_NEWLINE))
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 6312:              SET_LIST_BIT ('\n');
        -: 6313:
        -: 6314:            /* Read in characters and ranges, setting map bits.  */
        -: 6315:            for (;;)
        -: 6316:              {
      48*: 6317:                if (p == pend) FREE_STACK_RETURN (REG_EBRACK);
branch  0 taken 0 (fallthrough)
branch  1 taken 48
        -: 6318:
      48*: 6319:                PATFETCH (c);
branch  0 taken 0 (fallthrough)
branch  1 taken 48
branch  2 taken 0 (fallthrough)
branch  3 taken 48
        -: 6320:
        -: 6321:                /* \ might escape characters inside [...] and [^...].  */
      48*: 6322:                if ((syntax & RE_BACKSLASH_ESCAPE_IN_LISTS) && c == '\\')
branch  0 taken 0 (fallthrough)
branch  1 taken 48
branch  2 never executed
branch  3 never executed
        -: 6323:                  {
    #####: 6324:                    if (p == pend) FREE_STACK_RETURN (REG_EESCAPE);
branch  0 never executed
branch  1 never executed
        -: 6325:
    #####: 6326:                    PATFETCH (c1);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 6327:                    SET_LIST_BIT (c1);
    #####: 6328:                    continue;
        -: 6329:                  }
        -: 6330:
        -: 6331:                /* Could be the end of the bracket expression.  If it's
        -: 6332:                   not (i.e., when the bracket expression is `[]' so
        -: 6333:                   far), the ']' character bit gets set way below.  */
       48: 6334:                if (c == ']' && p != p1 + 1)
branch  0 taken 9 (fallthrough)
branch  1 taken 39
branch  2 taken 9 (fallthrough)
branch  3 taken 0
        9: 6335:                  break;
        -: 6336:
        -: 6337:                /* Look ahead to see if it's a range when the last thing
        -: 6338:                   was a character class.  */
      39*: 6339:                if (had_char_class && c == '-' && *p != ']')
branch  0 taken 0 (fallthrough)
branch  1 taken 39
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 6340:                  FREE_STACK_RETURN (REG_ERANGE);
        -: 6341:
        -: 6342:                /* Look ahead to see if it's a range when the last thing
        -: 6343:                   was a character: if this is a hyphen not at the
        -: 6344:                   beginning or the end of a list, then it's the range
        -: 6345:                   operator.  */
       39: 6346:                if (c == '-'
branch  0 taken 0 (fallthrough)
branch  1 taken 39
    #####: 6347:                    && !(p - 2 >= pattern && p[-2] == '[')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 6348:                    && !(p - 3 >= pattern && p[-3] == '[' && p[-2] == '^')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 6349:                    && *p != ']')
branch  0 never executed
branch  1 never executed
    #####: 6350:                  {
        -: 6351:                    reg_errcode_t ret
    #####: 6352:                      = compile_range (&p, pend, translate, syntax, b);
call    0 never executed
    #####: 6353:                    if (ret != REG_NOERROR) FREE_STACK_RETURN (ret);
branch  0 never executed
branch  1 never executed
        -: 6354:                  }
        -: 6355:
      39*: 6356:                else if (p[0] == '-' && p[1] != ']')
branch  0 taken 0 (fallthrough)
branch  1 taken 39
branch  2 never executed
branch  3 never executed
    #####: 6357:                  { /* This handles ranges made up of characters only.  */
        -: 6358:                    reg_errcode_t ret;
        -: 6359:
        -: 6360:		    /* Move past the `-'.  */
    #####: 6361:                    PATFETCH (c1);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 6362:
    #####: 6363:                    ret = compile_range (&p, pend, translate, syntax, b);
call    0 never executed
    #####: 6364:                    if (ret != REG_NOERROR) FREE_STACK_RETURN (ret);
branch  0 never executed
branch  1 never executed
        -: 6365:                  }
        -: 6366:
        -: 6367:                /* See if we're at the beginning of a possible character
        -: 6368:                   class.  */
        -: 6369:
      39*: 6370:                else if (syntax & RE_CHAR_CLASSES && c == '[' && *p == ':')
branch  0 taken 39 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 39
branch  4 never executed
branch  5 never executed
    #####: 6371:                  { /* Leave room for the null.  */
        -: 6372:                    char str[CHAR_CLASS_MAX_LENGTH + 1];
        -: 6373:
    #####: 6374:                    PATFETCH (c);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 6375:                    c1 = 0;
        -: 6376:
        -: 6377:                    /* If pattern is `[[:'.  */
    #####: 6378:                    if (p == pend) FREE_STACK_RETURN (REG_EBRACK);
branch  0 never executed
branch  1 never executed
        -: 6379:
        -: 6380:                    for (;;)
        -: 6381:                      {
    #####: 6382:                        PATFETCH (c);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 6383:                        if ((c == ':' && *p == ']') || p == pend
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 6384:                            || c1 == CHAR_CLASS_MAX_LENGTH)
branch  0 never executed
branch  1 never executed
        -: 6385:                          break;
    #####: 6386:                        str[c1++] = c;
        -: 6387:                      }
    #####: 6388:                    str[c1] = '\0';
        -: 6389:
        -: 6390:                    /* If isn't a word bracketed by `[:' and `:]':
        -: 6391:                       undo the ending character, the letters, and leave
        -: 6392:                       the leading `:' and `[' (but set bits for them).  */
    #####: 6393:                    if (c == ':' && *p == ']')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 6394:                      {
        -: 6395:#if defined _LIBC || (defined HAVE_WCTYPE_H && defined HAVE_WCHAR_H)
        -: 6396:                        boolean is_lower = STREQ (str, "lower");
        -: 6397:                        boolean is_upper = STREQ (str, "upper");
        -: 6398:			wctype_t wt;
        -: 6399:                        int ch;
        -: 6400:
        -: 6401:			wt = IS_CHAR_CLASS (str);
        -: 6402:			if (wt == 0)
        -: 6403:			  FREE_STACK_RETURN (REG_ECTYPE);
        -: 6404:
        -: 6405:                        /* Throw away the ] at the end of the character
        -: 6406:                           class.  */
        -: 6407:                        PATFETCH (c);
        -: 6408:
        -: 6409:                        if (p == pend) FREE_STACK_RETURN (REG_EBRACK);
        -: 6410:
        -: 6411:                        for (ch = 0; ch < 1 << BYTEWIDTH; ++ch)
        -: 6412:			  {
        -: 6413:# ifdef _LIBC
        -: 6414:			    if (__iswctype (__btowc (ch), wt))
        -: 6415:			      SET_LIST_BIT (ch);
        -: 6416:#else
        -: 6417:			    if (iswctype (btowc (ch), wt))
        -: 6418:			      SET_LIST_BIT (ch);
        -: 6419:#endif
        -: 6420:
        -: 6421:			    if (translate && (is_upper || is_lower)
        -: 6422:				&& (ISUPPER (ch) || ISLOWER (ch)))
        -: 6423:			      SET_LIST_BIT (ch);
        -: 6424:			  }
        -: 6425:
        -: 6426:                        had_char_class = true;
        -: 6427:#else
        -: 6428:                        int ch;
    #####: 6429:                        boolean is_alnum = STREQ (str, "alnum");
    #####: 6430:                        boolean is_alpha = STREQ (str, "alpha");
    #####: 6431:                        boolean is_blank = STREQ (str, "blank");
    #####: 6432:                        boolean is_cntrl = STREQ (str, "cntrl");
    #####: 6433:                        boolean is_digit = STREQ (str, "digit");
    #####: 6434:                        boolean is_graph = STREQ (str, "graph");
    #####: 6435:                        boolean is_lower = STREQ (str, "lower");
    #####: 6436:                        boolean is_print = STREQ (str, "print");
    #####: 6437:                        boolean is_punct = STREQ (str, "punct");
    #####: 6438:                        boolean is_space = STREQ (str, "space");
    #####: 6439:                        boolean is_upper = STREQ (str, "upper");
    #####: 6440:                        boolean is_xdigit = STREQ (str, "xdigit");
        -: 6441:
    #####: 6442:                        if (!IS_CHAR_CLASS (str))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
branch 21 never executed
branch 22 never executed
branch 23 never executed
    #####: 6443:			  FREE_STACK_RETURN (REG_ECTYPE);
        -: 6444:
        -: 6445:                        /* Throw away the ] at the end of the character
        -: 6446:                           class.  */
    #####: 6447:                        PATFETCH (c);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 6448:
    #####: 6449:                        if (p == pend) FREE_STACK_RETURN (REG_EBRACK);
branch  0 never executed
branch  1 never executed
        -: 6450:
    #####: 6451:                        for (ch = 0; ch < 1 << BYTEWIDTH; ch++)
branch  0 never executed
branch  1 never executed
        -: 6452:                          {
        -: 6453:			    /* This was split into 3 if's to
        -: 6454:			       avoid an arbitrary limit in some compiler.  */
    #####: 6455:                            if (   (is_alnum  && ISALNUM (ch))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 6456:                                || (is_alpha  && ISALPHA (ch))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 6457:                                || (is_blank  && ISBLANK (ch))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 6458:                                || (is_cntrl  && ISCNTRL (ch)))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 6459:			      SET_LIST_BIT (ch);
    #####: 6460:			    if (   (is_digit  && ISDIGIT (ch))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 6461:                                || (is_graph  && ISGRAPH (ch))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 6462:                                || (is_lower  && ISLOWER (ch))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 6463:                                || (is_print  && ISPRINT (ch)))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 6464:			      SET_LIST_BIT (ch);
    #####: 6465:			    if (   (is_punct  && ISPUNCT (ch))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 6466:                                || (is_space  && ISSPACE (ch))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 6467:                                || (is_upper  && ISUPPER (ch))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 6468:                                || (is_xdigit && ISXDIGIT (ch)))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 6469:			      SET_LIST_BIT (ch);
    #####: 6470:			    if (   translate && (is_upper || is_lower)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 6471:				&& (ISUPPER (ch) || ISLOWER (ch)))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 6472:			      SET_LIST_BIT (ch);
        -: 6473:                          }
    #####: 6474:                        had_char_class = true;
        -: 6475:#endif	/* libc || wctype.h */
        -: 6476:                      }
        -: 6477:                    else
        -: 6478:                      {
    #####: 6479:                        c1++;
    #####: 6480:                        while (c1--)
branch  0 never executed
branch  1 never executed
    #####: 6481:                          PATUNFETCH;
    #####: 6482:                        SET_LIST_BIT ('[');
    #####: 6483:                        SET_LIST_BIT (':');
    #####: 6484:                        had_char_class = false;
        -: 6485:                      }
        -: 6486:                  }
        -: 6487:                else
        -: 6488:                  {
       39: 6489:                    had_char_class = false;
       39: 6490:                    SET_LIST_BIT (c);
        -: 6491:                  }
        -: 6492:              }
        -: 6493:
        -: 6494:            /* Discard any (non)matching list bytes that are all 0 at the
        -: 6495:               end of the map.  Decrease the map-length byte too.  */
      165: 6496:            while ((int) b[-1] > 0 && b[b[-1] - 1] == 0)
branch  0 taken 165 (fallthrough)
branch  1 taken 0
branch  2 taken 156
branch  3 taken 9 (fallthrough)
      156: 6497:              b[-1]--;
        9: 6498:            b += b[-1];
        -: 6499:          }
        9: 6500:          break;
        -: 6501:
        -: 6502:
        2: 6503:	case '(':
        2: 6504:          if (syntax & RE_NO_BK_PARENS)
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2: 6505:            goto handle_open;
        -: 6506:          else
    #####: 6507:            goto normal_char;
        -: 6508:
        -: 6509:
        2: 6510:        case ')':
        2: 6511:          if (syntax & RE_NO_BK_PARENS)
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2: 6512:            goto handle_close;
        -: 6513:          else
    #####: 6514:            goto normal_char;
        -: 6515:
        -: 6516:
       20: 6517:        case '\n':
       20: 6518:          if (syntax & RE_NEWLINE_ALT)
branch  0 taken 0 (fallthrough)
branch  1 taken 20
    #####: 6519:            goto handle_alt;
        -: 6520:          else
       20: 6521:            goto normal_char;
        -: 6522:
        -: 6523:
        1: 6524:	case '|':
        1: 6525:          if (syntax & RE_NO_BK_VBAR)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 6526:            goto handle_alt;
        -: 6527:          else
    #####: 6528:            goto normal_char;
        -: 6529:
        -: 6530:
    #####: 6531:        case '{':
    #####: 6532:           if (syntax & RE_INTERVALS && syntax & RE_NO_BK_BRACES)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 6533:             goto handle_interval;
        -: 6534:           else
    #####: 6535:             goto normal_char;
        -: 6536:
        -: 6537:
      339: 6538:        case '\\':
     339*: 6539:          if (p == pend) FREE_STACK_RETURN (REG_EESCAPE);
branch  0 taken 0 (fallthrough)
branch  1 taken 339
        -: 6540:
        -: 6541:          /* Do not translate the character after the \, so that we can
        -: 6542:             distinguish, e.g., \B from \b, even if we normally would
        -: 6543:             translate, e.g., B to b.  */
     339*: 6544:          PATFETCH_RAW (c);
branch  0 taken 0 (fallthrough)
branch  1 taken 339
        -: 6545:
      339: 6546:          switch (c)
branch  0 taken 13
branch  1 taken 13
branch  2 taken 0
branch  3 taken 1
branch  4 taken 0
branch  5 taken 0
branch  6 taken 0
branch  7 taken 0
branch  8 taken 0
branch  9 taken 0
branch 10 taken 0
branch 11 taken 0
branch 12 taken 0
branch 13 taken 0
branch 14 taken 312
        -: 6547:            {
       13: 6548:            case '(':
       13: 6549:              if (syntax & RE_NO_BK_PARENS)
branch  0 taken 0 (fallthrough)
branch  1 taken 13
    #####: 6550:                goto normal_backslash;
        -: 6551:
       13: 6552:            handle_open:
       15: 6553:              bufp->re_nsub++;
       15: 6554:              regnum++;
        -: 6555:
       15: 6556:              if (COMPILE_STACK_FULL)
branch  0 taken 0 (fallthrough)
branch  1 taken 15
        -: 6557:                {
    #####: 6558:                  RETALLOC (compile_stack.stack, compile_stack.size << 1,
        -: 6559:                            compile_stack_elt_t);
    #####: 6560:                  if (compile_stack.stack == NULL) return REG_ESPACE;
branch  0 never executed
branch  1 never executed
        -: 6561:
    #####: 6562:                  compile_stack.size <<= 1;
        -: 6563:                }
        -: 6564:
        -: 6565:              /* These are the values to restore when we hit end of this
        -: 6566:                 group.  They are all relative offsets, so that if the
        -: 6567:                 whole pattern moves because of realloc, they will still
        -: 6568:                 be valid.  */
       15: 6569:              COMPILE_STACK_TOP.begalt_offset = begalt - bufp->buffer;
       15: 6570:              COMPILE_STACK_TOP.fixup_alt_jump
       15: 6571:                = fixup_alt_jump ? fixup_alt_jump - bufp->buffer + 1 : 0;
branch  0 taken 1 (fallthrough)
branch  1 taken 14
       15: 6572:              COMPILE_STACK_TOP.laststart_offset = b - bufp->buffer;
       15: 6573:              COMPILE_STACK_TOP.regnum = regnum;
        -: 6574:
        -: 6575:              /* We will eventually replace the 0 with the number of
        -: 6576:                 groups inner to this one.  But do not push a
        -: 6577:                 start_memory for groups beyond the last one we can
        -: 6578:                 represent in the compiled pattern.  */
       15: 6579:              if (regnum <= MAX_REGNUM)
branch  0 taken 15 (fallthrough)
branch  1 taken 0
        -: 6580:                {
       15: 6581:                  COMPILE_STACK_TOP.inner_group_offset = b - bufp->buffer + 2;
      15*: 6582:                  BUF_PUSH_3 (start_memory, regnum, 0);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 taken 0
branch 15 taken 15 (fallthrough)
        -: 6583:                }
        -: 6584:
       15: 6585:              compile_stack.avail++;
        -: 6586:
       15: 6587:              fixup_alt_jump = 0;
       15: 6588:              laststart = 0;
       15: 6589:              begalt = b;
        -: 6590:	      /* If we've reached MAX_REGNUM groups, then this open
        -: 6591:		 won't actually generate any code, so we'll have to
        -: 6592:		 clear pending_exact explicitly.  */
       15: 6593:	      pending_exact = 0;
       15: 6594:              break;
        -: 6595:
        -: 6596:
       13: 6597:            case ')':
      13*: 6598:              if (syntax & RE_NO_BK_PARENS) goto normal_backslash;
branch  0 taken 0 (fallthrough)
branch  1 taken 13
        -: 6599:
       13: 6600:              if (COMPILE_STACK_EMPTY)
branch  0 taken 0 (fallthrough)
branch  1 taken 13
        -: 6601:		{
    #####: 6602:		  if (syntax & RE_UNMATCHED_RIGHT_PAREN_ORD)
branch  0 never executed
branch  1 never executed
    #####: 6603:		    goto normal_backslash;
        -: 6604:		  else
    #####: 6605:		    FREE_STACK_RETURN (REG_ERPAREN);
        -: 6606:		}
        -: 6607:
       13: 6608:            handle_close:
       15: 6609:              if (fixup_alt_jump)
branch  0 taken 0 (fallthrough)
branch  1 taken 15
        -: 6610:                { /* Push a dummy failure point at the end of the
        -: 6611:                     alternative for a possible future
        -: 6612:                     `pop_failure_jump' to pop.  See comments at
        -: 6613:                     `push_dummy_failure' in `re_match_2'.  */
    #####: 6614:                  BUF_PUSH (push_dummy_failure);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
        -: 6615:
        -: 6616:                  /* We allocated space for this jump when we assigned
        -: 6617:                     to `fixup_alt_jump', in the `handle_alt' case below.  */
    #####: 6618:                  STORE_JUMP (jump_past_alt, fixup_alt_jump, b - 1);
call    0 never executed
        -: 6619:                }
        -: 6620:
        -: 6621:              /* See similar code for backslashed left paren above.  */
       15: 6622:              if (COMPILE_STACK_EMPTY)
branch  0 taken 0 (fallthrough)
branch  1 taken 15
        -: 6623:		{
    #####: 6624:		  if (syntax & RE_UNMATCHED_RIGHT_PAREN_ORD)
branch  0 never executed
branch  1 never executed
    #####: 6625:		    goto normal_char;
        -: 6626:		  else
    #####: 6627:		    FREE_STACK_RETURN (REG_ERPAREN);
        -: 6628:		}
        -: 6629:
        -: 6630:              /* Since we just checked for an empty stack above, this
        -: 6631:                 ``can't happen''.  */
        -: 6632:              assert (compile_stack.avail != 0);
        -: 6633:              {
        -: 6634:                /* We don't just want to restore into `regnum', because
        -: 6635:                   later groups should continue to be numbered higher,
        -: 6636:                   as in `(ab)c(de)' -- the second group is #2.  */
        -: 6637:                regnum_t this_group_regnum;
        -: 6638:
       15: 6639:                compile_stack.avail--;
       15: 6640:                begalt = bufp->buffer + COMPILE_STACK_TOP.begalt_offset;
        -: 6641:                fixup_alt_jump
       30: 6642:                  = COMPILE_STACK_TOP.fixup_alt_jump
        1: 6643:                    ? bufp->buffer + COMPILE_STACK_TOP.fixup_alt_jump - 1
       15: 6644:                    : 0;
branch  0 taken 1 (fallthrough)
branch  1 taken 14
       15: 6645:                laststart = bufp->buffer + COMPILE_STACK_TOP.laststart_offset;
       15: 6646:                this_group_regnum = COMPILE_STACK_TOP.regnum;
        -: 6647:		/* If we've reached MAX_REGNUM groups, then this open
        -: 6648:		   won't actually generate any code, so we'll have to
        -: 6649:		   clear pending_exact explicitly.  */
       15: 6650:		pending_exact = 0;
        -: 6651:
        -: 6652:                /* We're at the end of the group, so now we know how many
        -: 6653:                   groups were inside this one.  */
       15: 6654:                if (this_group_regnum <= MAX_REGNUM)
branch  0 taken 15 (fallthrough)
branch  1 taken 0
        -: 6655:                  {
       15: 6656:                    unsigned char *inner_group_loc
       15: 6657:                      = bufp->buffer + COMPILE_STACK_TOP.inner_group_offset;
        -: 6658:
       15: 6659:                    *inner_group_loc = regnum - this_group_regnum;
      19*: 6660:                    BUF_PUSH_3 (stop_memory, this_group_regnum,
branch  0 taken 0 (fallthrough)
branch  1 taken 4
branch  2 taken 0 (fallthrough)
branch  3 taken 4
branch  4 taken 0 (fallthrough)
branch  5 taken 4
branch  6 taken 2 (fallthrough)
branch  7 taken 2
branch  8 taken 0 (fallthrough)
branch  9 taken 2
branch 10 taken 2 (fallthrough)
branch 11 taken 0
branch 12 taken 0 (fallthrough)
branch 13 taken 2
branch 14 taken 4
branch 15 taken 15 (fallthrough)
        -: 6661:                                regnum - this_group_regnum);
        -: 6662:                  }
        -: 6663:              }
       15: 6664:              break;
        -: 6665:
        -: 6666:
    #####: 6667:            case '|':					/* `\|'.  */
    #####: 6668:              if (syntax & RE_LIMITED_OPS || syntax & RE_NO_BK_VBAR)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 6669:                goto normal_backslash;
    #####: 6670:            handle_alt:
        1: 6671:              if (syntax & RE_LIMITED_OPS)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 6672:                goto normal_char;
        -: 6673:
        -: 6674:              /* Insert before the previous alternative a jump which
        -: 6675:                 jumps to this alternative if the former fails.  */
       1*: 6676:              GET_BUFFER_SPACE (3);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 taken 0
branch 15 taken 1 (fallthrough)
        1: 6677:              INSERT_JUMP (on_failure_jump, begalt, b + 6);
call    0 returned 1
        1: 6678:              pending_exact = 0;
        1: 6679:              b += 3;
        -: 6680:
        -: 6681:              /* The alternative before this one has a jump after it
        -: 6682:                 which gets executed if it gets matched.  Adjust that
        -: 6683:                 jump so it will jump to this alternative's analogous
        -: 6684:                 jump (put in below, which in turn will jump to the next
        -: 6685:                 (if any) alternative's such jump, etc.).  The last such
        -: 6686:                 jump jumps to the correct final destination.  A picture:
        -: 6687:                          _____ _____
        -: 6688:                          |   | |   |
        -: 6689:                          |   v |   v
        -: 6690:                         a | b   | c
        -: 6691:
        -: 6692:                 If we are at `b', then fixup_alt_jump right now points to a
        -: 6693:                 three-byte space after `a'.  We'll put in the jump, set
        -: 6694:                 fixup_alt_jump to right after `b', and leave behind three
        -: 6695:                 bytes which we'll fill in when we get to after `c'.  */
        -: 6696:
        1: 6697:              if (fixup_alt_jump)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 6698:                STORE_JUMP (jump_past_alt, fixup_alt_jump, b);
call    0 never executed
        -: 6699:
        -: 6700:              /* Mark and leave space for a jump after this alternative,
        -: 6701:                 to be filled in later either by next alternative or
        -: 6702:                 when know we're at the end of a series of alternatives.  */
        1: 6703:              fixup_alt_jump = b;
       1*: 6704:              GET_BUFFER_SPACE (3);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 taken 0
branch 15 taken 1 (fallthrough)
        1: 6705:              b += 3;
        -: 6706:
        1: 6707:              laststart = 0;
        1: 6708:              begalt = b;
        1: 6709:              break;
        -: 6710:
        -: 6711:
        1: 6712:            case '{':
        -: 6713:              /* If \{ is a literal.  */
        1: 6714:              if (!(syntax & RE_INTERVALS)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -: 6715:                     /* If we're at `\{' and it's not the open-interval
        -: 6716:                        operator.  */
        1: 6717:                  || ((syntax & RE_INTERVALS) && (syntax & RE_NO_BK_BRACES))
branch  0 taken 1 (fallthrough)
branch  1 taken 0
branch  2 taken 1 (fallthrough)
branch  3 taken 0
       1*: 6718:                  || (p - 2 == pattern  &&  p == pend))
branch  0 taken 0 (fallthrough)
branch  1 taken 1
branch  2 never executed
branch  3 never executed
    #####: 6719:                goto normal_backslash;
        -: 6720:
       1*: 6721:            handle_interval:
        -: 6722:              {
        -: 6723:                /* If got here, then the syntax allows intervals.  */
        -: 6724:
        -: 6725:                /* At least (most) this many matches must be made.  */
        1: 6726:                int lower_bound = -1, upper_bound = -1;
        -: 6727:
        1: 6728:                beg_interval = p - 1;
        -: 6729:
        1: 6730:                if (p == pend)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -: 6731:                  {
    #####: 6732:                    if (syntax & RE_NO_BK_BRACES)
branch  0 never executed
branch  1 never executed
    #####: 6733:                      goto unfetch_interval;
        -: 6734:                    else
    #####: 6735:                      FREE_STACK_RETURN (REG_EBRACE);
        -: 6736:                  }
        -: 6737:
       2*: 6738:                GET_UNSIGNED_NUMBER (lower_bound);
branch  0 taken 1 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 1
branch  4 taken 0 (fallthrough)
branch  5 taken 1
branch  6 taken 1 (fallthrough)
branch  7 taken 0
branch  8 taken 0 (fallthrough)
branch  9 taken 1
branch 10 taken 0 (fallthrough)
branch 11 taken 1
branch 12 taken 0 (fallthrough)
branch 13 taken 1
branch 14 taken 1
branch 15 taken 1 (fallthrough)
        -: 6739:
        1: 6740:                if (c == ',')
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -: 6741:                  {
       2*: 6742:                    GET_UNSIGNED_NUMBER (upper_bound);
branch  0 taken 1 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 1
branch  4 taken 0 (fallthrough)
branch  5 taken 1
branch  6 taken 1 (fallthrough)
branch  7 taken 0
branch  8 taken 0 (fallthrough)
branch  9 taken 1
branch 10 taken 0 (fallthrough)
branch 11 taken 1
branch 12 taken 0 (fallthrough)
branch 13 taken 1
branch 14 taken 1
branch 15 taken 1 (fallthrough)
       1*: 6743:                    if (upper_bound < 0) upper_bound = RE_DUP_MAX;
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -: 6744:                  }
        -: 6745:                else
        -: 6746:                  /* Interval such as `{1}' => match exactly once. */
    #####: 6747:                  upper_bound = lower_bound;
        -: 6748:
        1: 6749:                if (lower_bound < 0 || upper_bound > RE_DUP_MAX
branch  0 taken 1 (fallthrough)
branch  1 taken 0
branch  2 taken 1 (fallthrough)
branch  3 taken 0
        1: 6750:                    || lower_bound > upper_bound)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -: 6751:                  {
    #####: 6752:                    if (syntax & RE_NO_BK_BRACES)
branch  0 never executed
branch  1 never executed
    #####: 6753:                      goto unfetch_interval;
        -: 6754:                    else
    #####: 6755:                      FREE_STACK_RETURN (REG_BADBR);
        -: 6756:                  }
        -: 6757:
        1: 6758:                if (!(syntax & RE_NO_BK_BRACES))
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -: 6759:                  {
       1*: 6760:                    if (c != '\\') FREE_STACK_RETURN (REG_EBRACE);
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -: 6761:
       1*: 6762:                    PATFETCH (c);
branch  0 taken 0 (fallthrough)
branch  1 taken 1
branch  2 taken 0 (fallthrough)
branch  3 taken 1
        -: 6763:                  }
        -: 6764:
        1: 6765:                if (c != '}')
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -: 6766:                  {
    #####: 6767:                    if (syntax & RE_NO_BK_BRACES)
branch  0 never executed
branch  1 never executed
    #####: 6768:                      goto unfetch_interval;
        -: 6769:                    else
    #####: 6770:                      FREE_STACK_RETURN (REG_BADBR);
        -: 6771:                  }
        -: 6772:
        -: 6773:                /* We just parsed a valid interval.  */
        -: 6774:
        -: 6775:                /* If it's invalid to have no preceding re.  */
        1: 6776:                if (!laststart)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -: 6777:                  {
    #####: 6778:                    if (syntax & RE_CONTEXT_INVALID_OPS)
branch  0 never executed
branch  1 never executed
    #####: 6779:                      FREE_STACK_RETURN (REG_BADRPT);
    #####: 6780:                    else if (syntax & RE_CONTEXT_INDEP_OPS)
branch  0 never executed
branch  1 never executed
    #####: 6781:                      laststart = b;
        -: 6782:                    else
    #####: 6783:                      goto unfetch_interval;
        -: 6784:                  }
        -: 6785:
        -: 6786:                /* If the upper bound is zero, don't want to succeed at
        -: 6787:                   all; jump from `laststart' to `b + 3', which will be
        -: 6788:                   the end of the buffer after we insert the jump.  */
        1: 6789:                 if (upper_bound == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -: 6790:                   {
    #####: 6791:                     GET_BUFFER_SPACE (3);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
    #####: 6792:                     INSERT_JUMP (jump, laststart, b + 3);
call    0 never executed
    #####: 6793:                     b += 3;
        -: 6794:                   }
        -: 6795:
        -: 6796:                 /* Otherwise, we have a nontrivial interval.  When
        -: 6797:                    we're all done, the pattern will look like:
        -: 6798:                      set_number_at <jump count> <upper bound>
        -: 6799:                      set_number_at <succeed_n count> <lower bound>
        -: 6800:                      succeed_n <after jump addr> <succeed_n count>
        -: 6801:                      <body of loop>
        -: 6802:                      jump_n <succeed_n addr> <jump count>
        -: 6803:                    (The upper bound and `jump_n' are omitted if
        -: 6804:                    `upper_bound' is 1, though.)  */
        -: 6805:                 else
        -: 6806:                   { /* If the upper bound is > 1, we need to insert
        -: 6807:                        more at the end of the loop.  */
       1*: 6808:                     unsigned nbytes = 10 + (upper_bound > 1) * 10;
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -: 6809:
       1*: 6810:                     GET_BUFFER_SPACE (nbytes);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 taken 0
branch 15 taken 1 (fallthrough)
        -: 6811:
        -: 6812:                     /* Initialize lower bound of the `succeed_n', even
        -: 6813:                        though it will be set during matching by its
        -: 6814:                        attendant `set_number_at' (inserted next),
        -: 6815:                        because `re_compile_fastmap' needs to know.
        -: 6816:                        Jump to the `jump_n' we might insert below.  */
       1*: 6817:                     INSERT_JUMP2 (succeed_n, laststart,
branch  0 taken 1 (fallthrough)
branch  1 taken 0
call    2 returned 1
        -: 6818:                                   b + 5 + (upper_bound > 1) * 5,
        -: 6819:                                   lower_bound);
        1: 6820:                     b += 5;
        -: 6821:
        -: 6822:                     /* Code to initialize the lower bound.  Insert
        -: 6823:                        before the `succeed_n'.  The `5' is the last two
        -: 6824:                        bytes of this `set_number_at', plus 3 bytes of
        -: 6825:                        the following `succeed_n'.  */
        1: 6826:                     insert_op2 (set_number_at, laststart, 5, lower_bound, b);
call    0 returned 1
        1: 6827:                     b += 5;
        -: 6828:
        1: 6829:                     if (upper_bound > 1)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -: 6830:                       { /* More than one repetition is allowed, so
        -: 6831:                            append a backward jump to the `succeed_n'
        -: 6832:                            that starts this interval.
        -: 6833:
        -: 6834:                            When we've reached this during matching,
        -: 6835:                            we'll have matched the interval once, so
        -: 6836:                            jump back only `upper_bound - 1' times.  */
        1: 6837:                         STORE_JUMP2 (jump_n, b, laststart + 5,
call    0 returned 1
        -: 6838:                                      upper_bound - 1);
        1: 6839:                         b += 5;
        -: 6840:
        -: 6841:                         /* The location we want to set is the second
        -: 6842:                            parameter of the `jump_n'; that is `b-2' as
        -: 6843:                            an absolute address.  `laststart' will be
        -: 6844:                            the `set_number_at' we're about to insert;
        -: 6845:                            `laststart+3' the number to set, the source
        -: 6846:                            for the relative address.  But we are
        -: 6847:                            inserting into the middle of the pattern --
        -: 6848:                            so everything is getting moved up by 5.
        -: 6849:                            Conclusion: (b - 2) - (laststart + 3) + 5,
        -: 6850:                            i.e., b - laststart.
        -: 6851:
        -: 6852:                            We insert this at the beginning of the loop
        -: 6853:                            so that if we fail during matching, we'll
        -: 6854:                            reinitialize the bounds.  */
        1: 6855:                         insert_op2 (set_number_at, laststart, b - laststart,
call    0 returned 1
        -: 6856:                                     upper_bound - 1, b);
        1: 6857:                         b += 5;
        -: 6858:                       }
        -: 6859:                   }
        1: 6860:                pending_exact = 0;
        1: 6861:                beg_interval = NULL;
        -: 6862:              }
        1: 6863:              break;
        -: 6864:
    #####: 6865:            unfetch_interval:
        -: 6866:              /* If an invalid interval, match the characters as literals.  */
        -: 6867:               assert (beg_interval);
    #####: 6868:               p = beg_interval;
    #####: 6869:               beg_interval = NULL;
        -: 6870:
        -: 6871:               /* normal_char and normal_backslash need `c'.  */
    #####: 6872:               PATFETCH (c);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 6873:
    #####: 6874:               if (!(syntax & RE_NO_BK_BRACES))
branch  0 never executed
branch  1 never executed
        -: 6875:                 {
    #####: 6876:                   if (p > pattern  &&  p[-1] == '\\')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 6877:                     goto normal_backslash;
        -: 6878:                 }
    #####: 6879:               goto normal_char;
        -: 6880:
        -: 6881:#ifdef emacs
        -: 6882:            /* There is no way to specify the before_dot and after_dot
        -: 6883:               operators.  rms says this is ok.  --karl  */
        -: 6884:            case '=':
        -: 6885:              BUF_PUSH (at_dot);
        -: 6886:              break;
        -: 6887:
        -: 6888:            case 's':
        -: 6889:              laststart = b;
        -: 6890:              PATFETCH (c);
        -: 6891:              BUF_PUSH_2 (syntaxspec, syntax_spec_code[c]);
        -: 6892:              break;
        -: 6893:
        -: 6894:            case 'S':
        -: 6895:              laststart = b;
        -: 6896:              PATFETCH (c);
        -: 6897:              BUF_PUSH_2 (notsyntaxspec, syntax_spec_code[c]);
        -: 6898:              break;
        -: 6899:#endif /* emacs */
        -: 6900:
        -: 6901:
    #####: 6902:            case 'w':
    #####: 6903:	      if (syntax & RE_NO_GNU_OPS)
branch  0 never executed
branch  1 never executed
    #####: 6904:		goto normal_char;
    #####: 6905:              laststart = b;
    #####: 6906:              BUF_PUSH (wordchar);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
    #####: 6907:              break;
        -: 6908:
        -: 6909:
    #####: 6910:            case 'W':
    #####: 6911:	      if (syntax & RE_NO_GNU_OPS)
branch  0 never executed
branch  1 never executed
    #####: 6912:		goto normal_char;
    #####: 6913:              laststart = b;
    #####: 6914:              BUF_PUSH (notwordchar);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
    #####: 6915:              break;
        -: 6916:
        -: 6917:
    #####: 6918:            case '<':
    #####: 6919:	      if (syntax & RE_NO_GNU_OPS)
branch  0 never executed
branch  1 never executed
    #####: 6920:		goto normal_char;
    #####: 6921:              BUF_PUSH (wordbeg);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
    #####: 6922:              break;
        -: 6923:
    #####: 6924:            case '>':
    #####: 6925:	      if (syntax & RE_NO_GNU_OPS)
branch  0 never executed
branch  1 never executed
    #####: 6926:		goto normal_char;
    #####: 6927:              BUF_PUSH (wordend);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
    #####: 6928:              break;
        -: 6929:
    #####: 6930:            case 'b':
    #####: 6931:	      if (syntax & RE_NO_GNU_OPS)
branch  0 never executed
branch  1 never executed
    #####: 6932:		goto normal_char;
    #####: 6933:              BUF_PUSH (wordbound);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
    #####: 6934:              break;
        -: 6935:
    #####: 6936:            case 'B':
    #####: 6937:	      if (syntax & RE_NO_GNU_OPS)
branch  0 never executed
branch  1 never executed
    #####: 6938:		goto normal_char;
    #####: 6939:              BUF_PUSH (notwordbound);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
    #####: 6940:              break;
        -: 6941:
    #####: 6942:            case '`':
    #####: 6943:	      if (syntax & RE_NO_GNU_OPS)
branch  0 never executed
branch  1 never executed
    #####: 6944:		goto normal_char;
    #####: 6945:              BUF_PUSH (begbuf);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
    #####: 6946:              break;
        -: 6947:
    #####: 6948:            case '\'':
    #####: 6949:	      if (syntax & RE_NO_GNU_OPS)
branch  0 never executed
branch  1 never executed
    #####: 6950:		goto normal_char;
    #####: 6951:              BUF_PUSH (endbuf);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
    #####: 6952:              break;
        -: 6953:
    #####: 6954:            case '1': case '2': case '3': case '4': case '5':
        -: 6955:            case '6': case '7': case '8': case '9':
    #####: 6956:              if (syntax & RE_NO_BK_REFS)
branch  0 never executed
branch  1 never executed
    #####: 6957:                goto normal_char;
        -: 6958:
    #####: 6959:              c1 = c - '0';
        -: 6960:
    #####: 6961:              if (c1 > regnum)
branch  0 never executed
branch  1 never executed
    #####: 6962:                FREE_STACK_RETURN (REG_ESUBREG);
        -: 6963:
        -: 6964:              /* Can't back reference to a subexpression if inside of it.  */
    #####: 6965:              if (group_in_compile_stack (compile_stack, (regnum_t) c1))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 6966:                goto normal_char;
        -: 6967:
    #####: 6968:              laststart = b;
    #####: 6969:              BUF_PUSH_2 (duplicate, c1);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
    #####: 6970:              break;
        -: 6971:
        -: 6972:
    #####: 6973:            case '+':
        -: 6974:            case '?':
    #####: 6975:              if (syntax & RE_BK_PLUS_QM)
branch  0 never executed
branch  1 never executed
    #####: 6976:                goto handle_plus;
        -: 6977:              else
    #####: 6978:                goto normal_backslash;
        -: 6979:
        -: 6980:            default:
      312: 6981:            normal_backslash:
        -: 6982:              /* You might think it would be useful for \ to mean
        -: 6983:                 not to translate; but if we don't translate it
        -: 6984:                 it will never match anything.  */
     312*: 6985:              c = TRANSLATE (c);
branch  0 taken 0 (fallthrough)
branch  1 taken 312
      312: 6986:              goto normal_char;
        -: 6987:            }
       32: 6988:          break;
        -: 6989:
        -: 6990:
        -: 6991:	default:
        -: 6992:        /* Expects the character in `c'.  */
     2220: 6993:	normal_char:
        -: 6994:	      /* If no exactn currently being built.  */
     2220: 6995:          if (!pending_exact
branch  0 taken 1649 (fallthrough)
branch  1 taken 571
        -: 6996:
        -: 6997:              /* If last exactn not at current position.  */
     1649: 6998:              || pending_exact + *pending_exact + 1 != b
branch  0 taken 1649 (fallthrough)
branch  1 taken 0
        -: 6999:
        -: 7000:              /* We have only one byte following the exactn for the count.  */
     1649: 7001:	      || *pending_exact == (1 << BYTEWIDTH) - 1
branch  0 taken 1649 (fallthrough)
branch  1 taken 0
        -: 7002:
        -: 7003:              /* If followed by a repetition operator.  */
     1649: 7004:              || *p == '*' || *p == '^'
branch  0 taken 1641 (fallthrough)
branch  1 taken 8
branch  2 taken 1641 (fallthrough)
branch  3 taken 0
     3282: 7005:	      || ((syntax & RE_BK_PLUS_QM)
branch  0 taken 1639 (fallthrough)
branch  1 taken 2
branch  2 taken 1639
branch  3 taken 0
branch  4 taken 2 (fallthrough)
branch  5 taken 0
    1639*: 7006:		  ? *p == '\\' && (p[1] == '+' || p[1] == '?')
branch  0 taken 12 (fallthrough)
branch  1 taken 1627
branch  2 taken 12 (fallthrough)
branch  3 taken 0
branch  4 taken 0 (fallthrough)
branch  5 taken 12
       2*: 7007:		  : (*p == '+' || *p == '?'))
branch  0 taken 2 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 2
     1641: 7008:	      || ((syntax & RE_INTERVALS)
branch  0 taken 1641 (fallthrough)
branch  1 taken 0
     3280: 7009:                  && ((syntax & RE_NO_BK_BRACES)
branch  0 taken 2 (fallthrough)
branch  1 taken 1639
branch  2 taken 0 (fallthrough)
branch  3 taken 1639
        2: 7010:		      ? *p == '{'
branch  0 taken 0
branch  1 taken 2
    1639*: 7011:                      : (p[0] == '\\' && p[1] == '{'))))
branch  0 taken 12 (fallthrough)
branch  1 taken 1627
branch  2 taken 0 (fallthrough)
branch  3 taken 12
        -: 7012:	    {
        -: 7013:	      /* Start building a new exactn.  */
        -: 7014:
      579: 7015:              laststart = b;
        -: 7016:
     579*: 7017:	      BUF_PUSH_2 (exactn, 0);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 taken 0
branch 15 taken 579 (fallthrough)
      579: 7018:	      pending_exact = b - 1;
        -: 7019:            }
        -: 7020:
    2220*: 7021:	  BUF_PUSH (c);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 taken 0
branch 15 taken 2220 (fallthrough)
     2220: 7022:          (*pending_exact)++;
     2220: 7023:	  break;
        -: 7024:        } /* switch (c) */
        -: 7025:    } /* while p != pend */
        -: 7026:
        -: 7027:
        -: 7028:  /* Through the pattern now.  */
        -: 7029:
      622: 7030:  if (fixup_alt_jump)
branch  0 taken 1 (fallthrough)
branch  1 taken 621
        1: 7031:    STORE_JUMP (jump_past_alt, fixup_alt_jump, b);
call    0 returned 1
        -: 7032:
      622: 7033:  if (!COMPILE_STACK_EMPTY)
branch  0 taken 0 (fallthrough)
branch  1 taken 622
    #####: 7034:    FREE_STACK_RETURN (REG_EPAREN);
        -: 7035:
        -: 7036:  /* If we don't want backtracking, force success
        -: 7037:     the first time we reach the end of the compiled pattern.  */
      622: 7038:  if (syntax & RE_NO_POSIX_BACKTRACKING)
branch  0 taken 0 (fallthrough)
branch  1 taken 622
    #####: 7039:    BUF_PUSH (succeed);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
        -: 7040:
      622: 7041:  free (compile_stack.stack);
        -: 7042:
        -: 7043:  /* We have succeeded; set the length of the buffer.  */
      622: 7044:  bufp->used = b - bufp->buffer;
        -: 7045:
        -: 7046:#ifdef DEBUG
        -: 7047:  if (debug)
        -: 7048:    {
        -: 7049:      DEBUG_PRINT1 ("\nCompiled pattern: \n");
        -: 7050:      print_compiled_pattern (bufp);
        -: 7051:    }
        -: 7052:#endif /* DEBUG */
        -: 7053:
        -: 7054:#ifndef MATCH_MAY_ALLOCATE
        -: 7055:  /* Initialize the failure stack to the largest possible stack.  This
        -: 7056:     isn't necessary unless we're trying to avoid calling alloca in
        -: 7057:     the search and match routines.  */
        -: 7058:  {
        -: 7059:    int num_regs = bufp->re_nsub + 1;
        -: 7060:
        -: 7061:    /* Since DOUBLE_FAIL_STACK refuses to double only if the current size
        -: 7062:       is strictly greater than re_max_failures, the largest possible stack
        -: 7063:       is 2 * re_max_failures failure points.  */
        -: 7064:    if (fail_stack.size < (2 * re_max_failures * MAX_FAILURE_ITEMS))
        -: 7065:      {
        -: 7066:	fail_stack.size = (2 * re_max_failures * MAX_FAILURE_ITEMS);
        -: 7067:
        -: 7068:# ifdef emacs
        -: 7069:	if (! fail_stack.stack)
        -: 7070:	  fail_stack.stack
        -: 7071:	    = (fail_stack_elt_t *) xmalloc (fail_stack.size
        -: 7072:					    * sizeof (fail_stack_elt_t));
        -: 7073:	else
        -: 7074:	  fail_stack.stack
        -: 7075:	    = (fail_stack_elt_t *) xrealloc (fail_stack.stack,
        -: 7076:					     (fail_stack.size
        -: 7077:					      * sizeof (fail_stack_elt_t)));
        -: 7078:# else /* not emacs */
        -: 7079:	if (! fail_stack.stack)
        -: 7080:	  fail_stack.stack
        -: 7081:	    = (fail_stack_elt_t *) malloc (fail_stack.size
        -: 7082:					   * sizeof (fail_stack_elt_t));
        -: 7083:	else
        -: 7084:	  fail_stack.stack
        -: 7085:	    = (fail_stack_elt_t *) realloc (fail_stack.stack,
        -: 7086:					    (fail_stack.size
        -: 7087:					     * sizeof (fail_stack_elt_t)));
        -: 7088:# endif /* not emacs */
        -: 7089:      }
        -: 7090:
        -: 7091:    regex_grow_registers (num_regs);
        -: 7092:  }
        -: 7093:#endif /* not MATCH_MAY_ALLOCATE */
        -: 7094:
      622: 7095:  return REG_NOERROR;
        -: 7096:} /* regex_compile */
        -: 7097:
        -: 7098:/* Subroutines for `regex_compile'.  */
        -: 7099:
        -: 7100:/* Store OP at LOC followed by two-byte integer parameter ARG.  */
        -: 7101:
        -: 7102:static void
function store_op1 called 264 returned 100% blocks executed 100%
      264: 7103:store_op1 (op, loc, arg)
        -: 7104:    re_opcode_t op;
        -: 7105:    unsigned char *loc;
        -: 7106:    int arg;
        -: 7107:{
      264: 7108:  *loc = (unsigned char) op;
      264: 7109:  STORE_NUMBER (loc + 1, arg);
      264: 7110:}
        -: 7111:
        -: 7112:
        -: 7113:/* Like `store_op1', but for two two-byte parameters ARG1 and ARG2.  */
        -: 7114:
        -: 7115:static void
function store_op2 called 4 returned 100% blocks executed 100%
        4: 7116:store_op2 (op, loc, arg1, arg2)
        -: 7117:    re_opcode_t op;
        -: 7118:    unsigned char *loc;
        -: 7119:    int arg1, arg2;
        -: 7120:{
        4: 7121:  *loc = (unsigned char) op;
        4: 7122:  STORE_NUMBER (loc + 1, arg1);
        4: 7123:  STORE_NUMBER (loc + 3, arg2);
        4: 7124:}
        -: 7125:
        -: 7126:
        -: 7127:/* Copy the bytes from LOC to END to open up three bytes of space at LOC
        -: 7128:   for OP followed by two-byte integer parameter ARG.  */
        -: 7129:
        -: 7130:static void
function insert_op1 called 132 returned 100% blocks executed 100%
      132: 7131:insert_op1 (op, loc, arg, end)
        -: 7132:    re_opcode_t op;
        -: 7133:    unsigned char *loc;
        -: 7134:    int arg;
        -: 7135:    unsigned char *end;
        -: 7136:{
      132: 7137:  register unsigned char *pfrom = end;
      132: 7138:  register unsigned char *pto = end + 3;
        -: 7139:
      697: 7140:  while (pfrom != loc)
branch  0 taken 565
branch  1 taken 132 (fallthrough)
      565: 7141:    *--pto = *--pfrom;
        -: 7142:
      132: 7143:  store_op1 (op, loc, arg);
call    0 returned 132
      132: 7144:}
        -: 7145:
        -: 7146:
        -: 7147:/* Like `insert_op1', but for two two-byte parameters ARG1 and ARG2.  */
        -: 7148:
        -: 7149:static void
function insert_op2 called 3 returned 100% blocks executed 100%
        3: 7150:insert_op2 (op, loc, arg1, arg2, end)
        -: 7151:    re_opcode_t op;
        -: 7152:    unsigned char *loc;
        -: 7153:    int arg1, arg2;
        -: 7154:    unsigned char *end;
        -: 7155:{
        3: 7156:  register unsigned char *pfrom = end;
        3: 7157:  register unsigned char *pto = end + 5;
        -: 7158:
       32: 7159:  while (pfrom != loc)
branch  0 taken 29
branch  1 taken 3 (fallthrough)
       29: 7160:    *--pto = *--pfrom;
        -: 7161:
        3: 7162:  store_op2 (op, loc, arg1, arg2);
call    0 returned 3
        3: 7163:}
        -: 7164:
        -: 7165:
        -: 7166:/* P points to just after a ^ in PATTERN.  Return true if that ^ comes
        -: 7167:   after an alternative or a begin-subexpression.  We assume there is at
        -: 7168:   least one character before the ^.  */
        -: 7169:
        -: 7170:static boolean
function at_begline_loc_p called 0 returned 0% blocks executed 0%
    #####: 7171:at_begline_loc_p (pattern, p, syntax)
        -: 7172:    const char *pattern, *p;
        -: 7173:    reg_syntax_t syntax;
        -: 7174:{
    #####: 7175:  const char *prev = p - 2;
    #####: 7176:  boolean prev_prev_backslash = prev > pattern && prev[-1] == '\\';
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 7177:
        -: 7178:  return
        -: 7179:       /* After a subexpression?  */
    #####: 7180:       (*prev == '(' && (syntax & RE_NO_BK_PARENS || prev_prev_backslash))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 7181:       /* After an alternative?  */
    #####: 7182:    || (*prev == '|' && (syntax & RE_NO_BK_VBAR || prev_prev_backslash));
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -: 7183:}
        -: 7184:
        -: 7185:
        -: 7186:/* The dual of at_begline_loc_p.  This one is for $.  We assume there is
        -: 7187:   at least one character after the $, i.e., `P < PEND'.  */
        -: 7188:
        -: 7189:static boolean
function at_endline_loc_p called 0 returned 0% blocks executed 0%
    #####: 7190:at_endline_loc_p (p, pend, syntax)
        -: 7191:    const char *p, *pend;
        -: 7192:    reg_syntax_t syntax;
        -: 7193:{
    #####: 7194:  const char *next = p;
    #####: 7195:  boolean next_backslash = *next == '\\';
    #####: 7196:  const char *next_next = p + 1 < pend ? p + 1 : 0;
branch  0 never executed
branch  1 never executed
        -: 7197:
        -: 7198:  return
        -: 7199:       /* Before a subexpression?  */
    #####: 7200:       (syntax & RE_NO_BK_PARENS ? *next == ')'
    #####: 7201:        : next_backslash && next_next && *next_next == ')')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 7202:       /* Before an alternative?  */
    #####: 7203:    || (syntax & RE_NO_BK_VBAR ? *next == '|'
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
    #####: 7204:        : next_backslash && next_next && *next_next == '|');
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 7205:}
        -: 7206:
        -: 7207:
        -: 7208:/* Returns true if REGNUM is in one of COMPILE_STACK's elements and
        -: 7209:   false if it's not.  */
        -: 7210:
        -: 7211:static boolean
function group_in_compile_stack called 0 returned 0% blocks executed 0%
    #####: 7212:group_in_compile_stack (compile_stack, regnum)
        -: 7213:    compile_stack_type compile_stack;
        -: 7214:    regnum_t regnum;
        -: 7215:{
        -: 7216:  int this_element;
        -: 7217:
    #####: 7218:  for (this_element = compile_stack.avail - 1;
    #####: 7219:       this_element >= 0;
branch  0 never executed
branch  1 never executed
    #####: 7220:       this_element--)
    #####: 7221:    if (compile_stack.stack[this_element].regnum == regnum)
branch  0 never executed
branch  1 never executed
    #####: 7222:      return true;
        -: 7223:
    #####: 7224:  return false;
        -: 7225:}
        -: 7226:
        -: 7227:
        -: 7228:/* Read the ending character of a range (in a bracket expression) from the
        -: 7229:   uncompiled pattern *P_PTR (which ends at PEND).  We assume the
        -: 7230:   starting character is in `P[-2]'.  (`P[-1]' is the character `-'.)
        -: 7231:   Then we set the translation of all bits between the starting and
        -: 7232:   ending characters (inclusive) in the compiled pattern B.
        -: 7233:
        -: 7234:   Return an error code.
        -: 7235:
        -: 7236:   We use these short variable names so we can use the same macros as
        -: 7237:   `regex_compile' itself.  */
        -: 7238:
        -: 7239:static reg_errcode_t
function compile_range called 0 returned 0% blocks executed 0%
    #####: 7240:compile_range (p_ptr, pend, translate, syntax, b)
        -: 7241:    const char **p_ptr, *pend;
        -: 7242:    RE_TRANSLATE_TYPE translate;
        -: 7243:    reg_syntax_t syntax;
        -: 7244:    unsigned char *b;
        -: 7245:{
        -: 7246:  unsigned this_char;
        -: 7247:
    #####: 7248:  const char *p = *p_ptr;
        -: 7249:  unsigned int range_start, range_end;
        -: 7250:
    #####: 7251:  if (p == pend)
branch  0 never executed
branch  1 never executed
    #####: 7252:    return REG_ERANGE;
        -: 7253:
        -: 7254:  /* Even though the pattern is a signed `char *', we need to fetch
        -: 7255:     with unsigned char *'s; if the high bit of the pattern character
        -: 7256:     is set, the range endpoints will be negative if we fetch using a
        -: 7257:     signed char *.
        -: 7258:
        -: 7259:     We also want to fetch the endpoints without translating them; the
        -: 7260:     appropriate translation is done in the bit-setting loop below.  */
        -: 7261:  /* The SVR4 compiler on the 3B2 had trouble with unsigned const char *.  */
    #####: 7262:  range_start = ((const unsigned char *) p)[-2];
    #####: 7263:  range_end   = ((const unsigned char *) p)[0];
        -: 7264:
        -: 7265:  /* Have to increment the pointer into the pattern string, so the
        -: 7266:     caller isn't still at the ending character.  */
    #####: 7267:  (*p_ptr)++;
        -: 7268:
        -: 7269:  /* If the start is after the end, the range is empty.  */
    #####: 7270:  if (range_start > range_end)
branch  0 never executed
branch  1 never executed
    #####: 7271:    return syntax & RE_NO_EMPTY_RANGES ? REG_ERANGE : REG_NOERROR;
branch  0 never executed
branch  1 never executed
        -: 7272:
        -: 7273:  /* Here we see why `this_char' has to be larger than an `unsigned
        -: 7274:     char' -- the range is inclusive, so if `range_end' == 0xff
        -: 7275:     (assuming 8-bit characters), we would otherwise go into an infinite
        -: 7276:     loop, since all characters <= 0xff.  */
    #####: 7277:  for (this_char = range_start; this_char <= range_end; this_char++)
branch  0 never executed
branch  1 never executed
        -: 7278:    {
    #####: 7279:      SET_LIST_BIT (TRANSLATE (this_char));
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 7280:    }
        -: 7281:
    #####: 7282:  return REG_NOERROR;
        -: 7283:}
        -: 7284:
        -: 7285:/* re_compile_fastmap computes a ``fastmap'' for the compiled pattern in
        -: 7286:   BUFP.  A fastmap records which of the (1 << BYTEWIDTH) possible
        -: 7287:   characters can start a string that matches the pattern.  This fastmap
        -: 7288:   is used by re_search to skip quickly over impossible starting points.
        -: 7289:
        -: 7290:   The caller must supply the address of a (1 << BYTEWIDTH)-byte data
        -: 7291:   area as BUFP->fastmap.
        -: 7292:
        -: 7293:   We set the `fastmap', `fastmap_accurate', and `can_be_null' fields in
        -: 7294:   the pattern buffer.
        -: 7295:
        -: 7296:   Returns 0 if we succeed, -2 if an internal error.   */
        -: 7297:
        -: 7298:int
function re_compile_fastmap called 0 returned 0% blocks executed 0%
    #####: 7299:re_compile_fastmap (bufp)
        -: 7300:     struct re_pattern_buffer *bufp;
        -: 7301:{
        -: 7302:  int j, k;
        -: 7303:#ifdef MATCH_MAY_ALLOCATE
        -: 7304:  fail_stack_type fail_stack;
        -: 7305:#endif
        -: 7306:#ifndef REGEX_MALLOC
        -: 7307:  char *destination;
        -: 7308:#endif
        -: 7309:
    #####: 7310:  register char *fastmap = bufp->fastmap;
    #####: 7311:  unsigned char *pattern = bufp->buffer;
    #####: 7312:  unsigned char *p = pattern;
    #####: 7313:  register unsigned char *pend = pattern + bufp->used;
        -: 7314:
        -: 7315:#ifdef REL_ALLOC
        -: 7316:  /* This holds the pointer to the failure stack, when
        -: 7317:     it is allocated relocatably.  */
        -: 7318:  fail_stack_elt_t *failure_stack_ptr;
        -: 7319:#endif
        -: 7320:
        -: 7321:  /* Assume that each path through the pattern can be null until
        -: 7322:     proven otherwise.  We set this false at the bottom of switch
        -: 7323:     statement, to which we get only if a particular path doesn't
        -: 7324:     match the empty string.  */
    #####: 7325:  boolean path_can_be_null = true;
        -: 7326:
        -: 7327:  /* We aren't doing a `succeed_n' to begin with.  */
    #####: 7328:  boolean succeed_n_p = false;
        -: 7329:
        -: 7330:  assert (fastmap != NULL && p != NULL);
        -: 7331:
    #####: 7332:  INIT_FAIL_STACK ();
branch  0 never executed
branch  1 never executed
    #####: 7333:  bzero (fastmap, 1 << BYTEWIDTH);  /* Assume nothing's valid.  */
    #####: 7334:  bufp->fastmap_accurate = 1;	    /* It will be when we're done.  */
    #####: 7335:  bufp->can_be_null = 0;
        -: 7336:
        -: 7337:  while (1)
        -: 7338:    {
    #####: 7339:      if (p == pend || *p == succeed)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 7340:	{
        -: 7341:	  /* We have reached the (effective) end of pattern.  */
    #####: 7342:	  if (!FAIL_STACK_EMPTY ())
branch  0 never executed
branch  1 never executed
        -: 7343:	    {
    #####: 7344:	      bufp->can_be_null |= path_can_be_null;
        -: 7345:
        -: 7346:	      /* Reset for next path.  */
    #####: 7347:	      path_can_be_null = true;
        -: 7348:
    #####: 7349:	      p = fail_stack.stack[--fail_stack.avail].pointer;
        -: 7350:
    #####: 7351:	      continue;
        -: 7352:	    }
        -: 7353:	  else
    #####: 7354:	    break;
        -: 7355:	}
        -: 7356:
        -: 7357:      /* We should never be about to go beyond the end of the pattern.  */
        -: 7358:      assert (p < pend);
        -: 7359:
    #####: 7360:      switch (SWITCH_ENUM_CAST ((re_opcode_t) *p++))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
        -: 7361:	{
        -: 7362:
        -: 7363:        /* I guess the idea here is to simply not bother with a fastmap
        -: 7364:           if a backreference is used, since it's too hard to figure out
        -: 7365:           the fastmap for the corresponding group.  Setting
        -: 7366:           `can_be_null' stops `re_search_2' from using the fastmap, so
        -: 7367:           that is all we do.  */
    #####: 7368:	case duplicate:
    #####: 7369:	  bufp->can_be_null = 1;
    #####: 7370:          goto done;
        -: 7371:
        -: 7372:
        -: 7373:      /* Following are the cases which match a character.  These end
        -: 7374:         with `break'.  */
        -: 7375:
    #####: 7376:	case exactn:
    #####: 7377:          fastmap[p[1]] = 1;
    #####: 7378:	  break;
        -: 7379:
        -: 7380:
    #####: 7381:        case charset:
    #####: 7382:          for (j = *p++ * BYTEWIDTH - 1; j >= 0; j--)
branch  0 never executed
branch  1 never executed
    #####: 7383:	    if (p[j / BYTEWIDTH] & (1 << (j % BYTEWIDTH)))
branch  0 never executed
branch  1 never executed
    #####: 7384:              fastmap[j] = 1;
    #####: 7385:	  break;
        -: 7386:
        -: 7387:
    #####: 7388:	case charset_not:
        -: 7389:	  /* Chars beyond end of map must be allowed.  */
    #####: 7390:	  for (j = *p * BYTEWIDTH; j < (1 << BYTEWIDTH); j++)
branch  0 never executed
branch  1 never executed
    #####: 7391:            fastmap[j] = 1;
        -: 7392:
    #####: 7393:	  for (j = *p++ * BYTEWIDTH - 1; j >= 0; j--)
branch  0 never executed
branch  1 never executed
    #####: 7394:	    if (!(p[j / BYTEWIDTH] & (1 << (j % BYTEWIDTH))))
branch  0 never executed
branch  1 never executed
    #####: 7395:              fastmap[j] = 1;
    #####: 7396:          break;
        -: 7397:
        -: 7398:
    #####: 7399:	case wordchar:
    #####: 7400:	  for (j = 0; j < (1 << BYTEWIDTH); j++)
branch  0 never executed
branch  1 never executed
    #####: 7401:	    if (SYNTAX (j) == Sword)
branch  0 never executed
branch  1 never executed
    #####: 7402:	      fastmap[j] = 1;
    #####: 7403:	  break;
        -: 7404:
        -: 7405:
    #####: 7406:	case notwordchar:
    #####: 7407:	  for (j = 0; j < (1 << BYTEWIDTH); j++)
branch  0 never executed
branch  1 never executed
    #####: 7408:	    if (SYNTAX (j) != Sword)
branch  0 never executed
branch  1 never executed
    #####: 7409:	      fastmap[j] = 1;
    #####: 7410:	  break;
        -: 7411:
        -: 7412:
    #####: 7413:        case anychar:
        -: 7414:	  {
    #####: 7415:	    int fastmap_newline = fastmap['\n'];
        -: 7416:
        -: 7417:	    /* `.' matches anything ...  */
    #####: 7418:	    for (j = 0; j < (1 << BYTEWIDTH); j++)
branch  0 never executed
branch  1 never executed
    #####: 7419:	      fastmap[j] = 1;
        -: 7420:
        -: 7421:	    /* ... except perhaps newline.  */
    #####: 7422:	    if (!(bufp->syntax & RE_DOT_NEWLINE))
branch  0 never executed
branch  1 never executed
    #####: 7423:	      fastmap['\n'] = fastmap_newline;
        -: 7424:
        -: 7425:	    /* Return if we have already set `can_be_null'; if we have,
        -: 7426:	       then the fastmap is irrelevant.  Something's wrong here.  */
    #####: 7427:	    else if (bufp->can_be_null)
branch  0 never executed
branch  1 never executed
    #####: 7428:	      goto done;
        -: 7429:
        -: 7430:	    /* Otherwise, have to check alternative paths.  */
    #####: 7431:	    break;
        -: 7432:	  }
        -: 7433:
        -: 7434:#ifdef emacs
        -: 7435:        case syntaxspec:
        -: 7436:	  k = *p++;
        -: 7437:	  for (j = 0; j < (1 << BYTEWIDTH); j++)
        -: 7438:	    if (SYNTAX (j) == (enum syntaxcode) k)
        -: 7439:	      fastmap[j] = 1;
        -: 7440:	  break;
        -: 7441:
        -: 7442:
        -: 7443:	case notsyntaxspec:
        -: 7444:	  k = *p++;
        -: 7445:	  for (j = 0; j < (1 << BYTEWIDTH); j++)
        -: 7446:	    if (SYNTAX (j) != (enum syntaxcode) k)
        -: 7447:	      fastmap[j] = 1;
        -: 7448:	  break;
        -: 7449:
        -: 7450:
        -: 7451:      /* All cases after this match the empty string.  These end with
        -: 7452:         `continue'.  */
        -: 7453:
        -: 7454:
        -: 7455:	case before_dot:
        -: 7456:	case at_dot:
        -: 7457:	case after_dot:
        -: 7458:          continue;
        -: 7459:#endif /* emacs */
        -: 7460:
        -: 7461:
    #####: 7462:        case no_op:
        -: 7463:        case begline:
        -: 7464:        case endline:
        -: 7465:	case begbuf:
        -: 7466:	case endbuf:
        -: 7467:	case wordbound:
        -: 7468:	case notwordbound:
        -: 7469:	case wordbeg:
        -: 7470:	case wordend:
        -: 7471:        case push_dummy_failure:
    #####: 7472:          continue;
        -: 7473:
        -: 7474:
    #####: 7475:	case jump_n:
        -: 7476:        case pop_failure_jump:
        -: 7477:	case maybe_pop_jump:
        -: 7478:	case jump:
        -: 7479:        case jump_past_alt:
        -: 7480:	case dummy_failure_jump:
    #####: 7481:          EXTRACT_NUMBER_AND_INCR (j, p);
    #####: 7482:	  p += j;
    #####: 7483:	  if (j > 0)
branch  0 never executed
branch  1 never executed
    #####: 7484:	    continue;
        -: 7485:
        -: 7486:          /* Jump backward implies we just went through the body of a
        -: 7487:             loop and matched nothing.  Opcode jumped to should be
        -: 7488:             `on_failure_jump' or `succeed_n'.  Just treat it like an
        -: 7489:             ordinary jump.  For a * loop, it has pushed its failure
        -: 7490:             point already; if so, discard that as redundant.  */
    #####: 7491:          if ((re_opcode_t) *p != on_failure_jump
branch  0 never executed
branch  1 never executed
    #####: 7492:	      && (re_opcode_t) *p != succeed_n)
branch  0 never executed
branch  1 never executed
    #####: 7493:	    continue;
        -: 7494:
    #####: 7495:          p++;
    #####: 7496:          EXTRACT_NUMBER_AND_INCR (j, p);
    #####: 7497:          p += j;
        -: 7498:
        -: 7499:          /* If what's on the stack is where we are now, pop it.  */
    #####: 7500:          if (!FAIL_STACK_EMPTY ()
branch  0 never executed
branch  1 never executed
    #####: 7501:	      && fail_stack.stack[fail_stack.avail - 1].pointer == p)
branch  0 never executed
branch  1 never executed
    #####: 7502:            fail_stack.avail--;
        -: 7503:
    #####: 7504:          continue;
        -: 7505:
        -: 7506:
        -: 7507:        case on_failure_jump:
        -: 7508:        case on_failure_keep_string_jump:
    #####: 7509:	handle_on_failure_jump:
    #####: 7510:          EXTRACT_NUMBER_AND_INCR (j, p);
        -: 7511:
        -: 7512:          /* For some patterns, e.g., `(a?)?', `p+j' here points to the
        -: 7513:             end of the pattern.  We don't want to push such a point,
        -: 7514:             since when we restore it above, entering the switch will
        -: 7515:             increment `p' past the end of the pattern.  We don't need
        -: 7516:             to push such a point since we obviously won't find any more
        -: 7517:             fastmap entries beyond `pend'.  Such a pattern can match
        -: 7518:             the null string, though.  */
    #####: 7519:          if (p + j < pend)
branch  0 never executed
branch  1 never executed
        -: 7520:            {
    #####: 7521:              if (!PUSH_PATTERN_OP (p + j, fail_stack))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
        -: 7522:		{
        -: 7523:		  RESET_FAIL_STACK ();
    #####: 7524:		  return -2;
        -: 7525:		}
        -: 7526:            }
        -: 7527:          else
    #####: 7528:            bufp->can_be_null = 1;
        -: 7529:
    #####: 7530:          if (succeed_n_p)
branch  0 never executed
branch  1 never executed
        -: 7531:            {
    #####: 7532:              EXTRACT_NUMBER_AND_INCR (k, p);	/* Skip the n.  */
    #####: 7533:              succeed_n_p = false;
        -: 7534:	    }
        -: 7535:
    #####: 7536:          continue;
        -: 7537:
        -: 7538:
    #####: 7539:	case succeed_n:
        -: 7540:          /* Get to the number of times to succeed.  */
    #####: 7541:          p += 2;
        -: 7542:
        -: 7543:          /* Increment p past the n for when k != 0.  */
    #####: 7544:          EXTRACT_NUMBER_AND_INCR (k, p);
    #####: 7545:          if (k == 0)
branch  0 never executed
branch  1 never executed
        -: 7546:	    {
    #####: 7547:              p -= 4;
    #####: 7548:  	      succeed_n_p = true;  /* Spaghetti code alert.  */
    #####: 7549:              goto handle_on_failure_jump;
        -: 7550:            }
    #####: 7551:          continue;
        -: 7552:
        -: 7553:
    #####: 7554:	case set_number_at:
    #####: 7555:          p += 4;
    #####: 7556:          continue;
        -: 7557:
        -: 7558:
    #####: 7559:	case start_memory:
        -: 7560:        case stop_memory:
    #####: 7561:	  p += 2;
    #####: 7562:	  continue;
        -: 7563:
        -: 7564:
    #####: 7565:	default:
    #####: 7566:          abort (); /* We have listed all the cases.  */
call    0 never executed
        -: 7567:        } /* switch *p++ */
        -: 7568:
        -: 7569:      /* Getting here means we have found the possible starting
        -: 7570:         characters for one path of the pattern -- and that the empty
        -: 7571:         string does not match.  We need not follow this path further.
        -: 7572:         Instead, look at the next alternative (remembered on the
        -: 7573:         stack), or quit if no more.  The test at the top of the loop
        -: 7574:         does these things.  */
    #####: 7575:      path_can_be_null = false;
    #####: 7576:      p = pend;
        -: 7577:    } /* while p */
        -: 7578:
        -: 7579:  /* Set `can_be_null' for the last path (also the first path, if the
        -: 7580:     pattern is empty).  */
    #####: 7581:  bufp->can_be_null |= path_can_be_null;
        -: 7582:
    #####: 7583: done:
        -: 7584:  RESET_FAIL_STACK ();
    #####: 7585:  return 0;
        -: 7586:} /* re_compile_fastmap */
        -: 7587:#ifdef _LIBC
        -: 7588:weak_alias (__re_compile_fastmap, re_compile_fastmap)
        -: 7589:#endif
        -: 7590:
        -: 7591:/* Set REGS to hold NUM_REGS registers, storing them in STARTS and
        -: 7592:   ENDS.  Subsequent matches using PATTERN_BUFFER and REGS will use
        -: 7593:   this memory for recording register information.  STARTS and ENDS
        -: 7594:   must be allocated using the malloc library routine, and must each
        -: 7595:   be at least NUM_REGS * sizeof (regoff_t) bytes long.
        -: 7596:
        -: 7597:   If NUM_REGS == 0, then subsequent matches should allocate their own
        -: 7598:   register data.
        -: 7599:
        -: 7600:   Unless this function is called, the first search or match using
        -: 7601:   PATTERN_BUFFER will allocate its own register data, without
        -: 7602:   freeing the old data.  */
        -: 7603:
        -: 7604:void
function re_set_registers called 0 returned 0% blocks executed 0%
    #####: 7605:re_set_registers (bufp, regs, num_regs, starts, ends)
        -: 7606:    struct re_pattern_buffer *bufp;
        -: 7607:    struct re_registers *regs;
        -: 7608:    unsigned num_regs;
        -: 7609:    regoff_t *starts, *ends;
        -: 7610:{
    #####: 7611:  if (num_regs)
branch  0 never executed
branch  1 never executed
        -: 7612:    {
    #####: 7613:      bufp->regs_allocated = REGS_REALLOCATE;
    #####: 7614:      regs->num_regs = num_regs;
    #####: 7615:      regs->start = starts;
    #####: 7616:      regs->end = ends;
        -: 7617:    }
        -: 7618:  else
        -: 7619:    {
    #####: 7620:      bufp->regs_allocated = REGS_UNALLOCATED;
    #####: 7621:      regs->num_regs = 0;
    #####: 7622:      regs->start = regs->end = (regoff_t *) 0;
        -: 7623:    }
    #####: 7624:}
        -: 7625:#ifdef _LIBC
        -: 7626:weak_alias (__re_set_registers, re_set_registers)
        -: 7627:#endif
        -: 7628:
        -: 7629:/* Searching routines.  */
        -: 7630:
        -: 7631:/* Like re_search_2, below, but only one string is specified, and
        -: 7632:   doesn't let you say where to stop matching. */
        -: 7633:
        -: 7634:int
function re_search called 46417 returned 100% blocks executed 100%
    46417: 7635:re_search (bufp, string, size, startpos, range, regs)
        -: 7636:     struct re_pattern_buffer *bufp;
        -: 7637:     const char *string;
        -: 7638:     int size, startpos, range;
        -: 7639:     struct re_registers *regs;
        -: 7640:{
    46417: 7641:  return re_search_2 (bufp, NULL, 0, string, size, startpos, range,
call    0 returned 46417
        -: 7642:		      regs, size);
        -: 7643:}
        -: 7644:#ifdef _LIBC
        -: 7645:weak_alias (__re_search, re_search)
        -: 7646:#endif
        -: 7647:
        -: 7648:
        -: 7649:/* Using the compiled pattern in BUFP->buffer, first tries to match the
        -: 7650:   virtual concatenation of STRING1 and STRING2, starting first at index
        -: 7651:   STARTPOS, then at STARTPOS + 1, and so on.
        -: 7652:
        -: 7653:   STRING1 and STRING2 have length SIZE1 and SIZE2, respectively.
        -: 7654:
        -: 7655:   RANGE is how far to scan while trying to match.  RANGE = 0 means try
        -: 7656:   only at STARTPOS; in general, the last start tried is STARTPOS +
        -: 7657:   RANGE.
        -: 7658:
        -: 7659:   In REGS, return the indices of the virtual concatenation of STRING1
        -: 7660:   and STRING2 that matched the entire BUFP->buffer and its contained
        -: 7661:   subexpressions.
        -: 7662:
        -: 7663:   Do not consider matching one past the index STOP in the virtual
        -: 7664:   concatenation of STRING1 and STRING2.
        -: 7665:
        -: 7666:   We return either the position in the strings at which the match was
        -: 7667:   found, -1 if no match, or -2 if error (such as failure
        -: 7668:   stack overflow).  */
        -: 7669:
        -: 7670:int
function re_search_2 called 46417 returned 100% blocks executed 35%
    46417: 7671:re_search_2 (bufp, string1, size1, string2, size2, startpos, range, regs, stop)
        -: 7672:     struct re_pattern_buffer *bufp;
        -: 7673:     const char *string1, *string2;
        -: 7674:     int size1, size2;
        -: 7675:     int startpos;
        -: 7676:     int range;
        -: 7677:     struct re_registers *regs;
        -: 7678:     int stop;
        -: 7679:{
        -: 7680:  int val;
    46417: 7681:  register char *fastmap = bufp->fastmap;
    46417: 7682:  register RE_TRANSLATE_TYPE translate = bufp->translate;
    46417: 7683:  int total_size = size1 + size2;
    46417: 7684:  int endpos = startpos + range;
        -: 7685:
        -: 7686:  /* Check for out-of-range STARTPOS.  */
    46417: 7687:  if (startpos < 0 || startpos > total_size)
branch  0 taken 46417 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 46417
    #####: 7688:    return -1;
        -: 7689:
        -: 7690:  /* Fix up RANGE if it might eventually take us outside
        -: 7691:     the virtual concatenation of STRING1 and STRING2.
        -: 7692:     Make sure we won't move STARTPOS below 0 or above TOTAL_SIZE.  */
    46417: 7693:  if (endpos < 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 46417
    #####: 7694:    range = 0 - startpos;
    46417: 7695:  else if (endpos > total_size)
branch  0 taken 0 (fallthrough)
branch  1 taken 46417
    #####: 7696:    range = total_size - startpos;
        -: 7697:
        -: 7698:  /* If the search isn't to be a backwards one, don't waste time in a
        -: 7699:     search for a pattern that must be anchored.  */
   46417*: 7700:  if (bufp->used > 0 && (re_opcode_t) bufp->buffer[0] == begbuf && range > 0)
branch  0 taken 46417 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 46417
branch  4 never executed
branch  5 never executed
        -: 7701:    {
    #####: 7702:      if (startpos > 0)
branch  0 never executed
branch  1 never executed
    #####: 7703:	return -1;
        -: 7704:      else
    #####: 7705:	range = 1;
        -: 7706:    }
        -: 7707:
        -: 7708:#ifdef emacs
        -: 7709:  /* In a forward search for something that starts with \=.
        -: 7710:     don't keep searching past point.  */
        -: 7711:  if (bufp->used > 0 && (re_opcode_t) bufp->buffer[0] == at_dot && range > 0)
        -: 7712:    {
        -: 7713:      range = PT - startpos;
        -: 7714:      if (range <= 0)
        -: 7715:	return -1;
        -: 7716:    }
        -: 7717:#endif /* emacs */
        -: 7718:
        -: 7719:  /* Update the fastmap now if not correct already.  */
   46417*: 7720:  if (fastmap && !bufp->fastmap_accurate)
branch  0 taken 0 (fallthrough)
branch  1 taken 46417
branch  2 never executed
branch  3 never executed
    #####: 7721:    if (re_compile_fastmap (bufp) == -2)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 7722:      return -2;
        -: 7723:
        -: 7724:  /* Loop through the string, looking for a place to start matching.  */
        -: 7725:  for (;;)
        -: 7726:    {
        -: 7727:      /* If a fastmap is supplied, skip quickly over characters that
        -: 7728:         cannot be the start of a match.  If the pattern can match the
        -: 7729:         null string, however, we don't need to skip characters; we want
        -: 7730:         the first null string.  */
  664112*: 7731:      if (fastmap && startpos < total_size && !bufp->can_be_null)
branch  0 taken 0 (fallthrough)
branch  1 taken 664112
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 7732:	{
    #####: 7733:	  if (range > 0)	/* Searching forwards.  */
branch  0 never executed
branch  1 never executed
        -: 7734:	    {
        -: 7735:	      register const char *d;
    #####: 7736:	      register int lim = 0;
    #####: 7737:	      int irange = range;
        -: 7738:
    #####: 7739:              if (startpos < size1 && startpos + range >= size1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 7740:                lim = range - (size1 - startpos);
        -: 7741:
    #####: 7742:	      d = (startpos >= size1 ? string2 - size1 : string1) + startpos;
branch  0 never executed
branch  1 never executed
        -: 7743:
        -: 7744:              /* Written out as an if-else to avoid testing `translate'
        -: 7745:                 inside the loop.  */
    #####: 7746:	      if (translate)
branch  0 never executed
branch  1 never executed
    #####: 7747:                while (range > lim
    #####: 7748:                       && !fastmap[(unsigned char)
branch  0 never executed
branch  1 never executed
    #####: 7749:				   translate[(unsigned char) *d++]])
branch  0 never executed
branch  1 never executed
    #####: 7750:                  range--;
        -: 7751:	      else
    #####: 7752:                while (range > lim && !fastmap[(unsigned char) *d++])
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 7753:                  range--;
        -: 7754:
    #####: 7755:	      startpos += irange - range;
        -: 7756:	    }
        -: 7757:	  else				/* Searching backwards.  */
        -: 7758:	    {
    #####: 7759:	      register char c = (size1 == 0 || startpos >= size1
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 7760:                                 ? string2[startpos - size1]
    #####: 7761:                                 : string1[startpos]);
        -: 7762:
    #####: 7763:	      if (!fastmap[(unsigned char) TRANSLATE (c)])
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 7764:		goto advance;
        -: 7765:	    }
        -: 7766:	}
        -: 7767:
        -: 7768:      /* If can't match the null string, and that's all we have left, fail.  */
   664112: 7769:      if (range >= 0 && startpos == total_size && fastmap
branch  0 taken 664112 (fallthrough)
branch  1 taken 0
branch  2 taken 41989 (fallthrough)
branch  3 taken 622123
branch  4 taken 0 (fallthrough)
branch  5 taken 41989
    #####: 7770:          && !bufp->can_be_null)
branch  0 never executed
branch  1 never executed
    #####: 7771:	return -1;
        -: 7772:
   664112: 7773:      val = re_match_2_internal (bufp, string1, size1, string2, size2,
call    0 returned 664112
        -: 7774:				 startpos, regs, stop);
        -: 7775:#ifndef REGEX_MALLOC
        -: 7776:# ifdef C_ALLOCA
        -: 7777:      alloca (0);
        -: 7778:# endif
        -: 7779:#endif
        -: 7780:
   664112: 7781:      if (val >= 0)
branch  0 taken 5772 (fallthrough)
branch  1 taken 658340
     5772: 7782:	return startpos;
        -: 7783:
   658340: 7784:      if (val == -2)
branch  0 taken 0 (fallthrough)
branch  1 taken 658340
    #####: 7785:	return -2;
        -: 7786:
   658340: 7787:    advance:
   658340: 7788:      if (!range)
branch  0 taken 40645 (fallthrough)
branch  1 taken 617695
    40645: 7789:        break;
   617695: 7790:      else if (range > 0)
branch  0 taken 617695 (fallthrough)
branch  1 taken 0
        -: 7791:        {
   617695: 7792:          range--;
   617695: 7793:          startpos++;
        -: 7794:        }
        -: 7795:      else
        -: 7796:        {
    #####: 7797:          range++;
    #####: 7798:          startpos--;
        -: 7799:        }
        -: 7800:    }
    40645: 7801:  return -1;
        -: 7802:} /* re_search_2 */
        -: 7803:#ifdef _LIBC
        -: 7804:weak_alias (__re_search_2, re_search_2)
        -: 7805:#endif
        -: 7806:
        -: 7807:/* This converts PTR, a pointer into one of the search strings `string1'
        -: 7808:   and `string2' into an offset from the beginning of that string.  */
        -: 7809:#define POINTER_TO_OFFSET(ptr)			\
        -: 7810:  (FIRST_STRING_P (ptr)				\
        -: 7811:   ? ((regoff_t) ((ptr) - string1))		\
        -: 7812:   : ((regoff_t) ((ptr) - string2 + size1)))
        -: 7813:
        -: 7814:/* Macros for dealing with the split strings in re_match_2.  */
        -: 7815:
        -: 7816:#define MATCHING_IN_FIRST_STRING  (dend == end_match_1)
        -: 7817:
        -: 7818:/* Call before fetching a character with *d.  This switches over to
        -: 7819:   string2 if necessary.  */
        -: 7820:#define PREFETCH()							\
        -: 7821:  while (d == dend)						    	\
        -: 7822:    {									\
        -: 7823:      /* End of string2 => fail.  */					\
        -: 7824:      if (dend == end_match_2) 						\
        -: 7825:        goto fail;							\
        -: 7826:      /* End of string1 => advance to string2.  */ 			\
        -: 7827:      d = string2;						        \
        -: 7828:      dend = end_match_2;						\
        -: 7829:    }
        -: 7830:
        -: 7831:
        -: 7832:/* Test if at very beginning or at very end of the virtual concatenation
        -: 7833:   of `string1' and `string2'.  If only one string, it's `string2'.  */
        -: 7834:#define AT_STRINGS_BEG(d) ((d) == (size1 ? string1 : string2) || !size2)
        -: 7835:#define AT_STRINGS_END(d) ((d) == end2)
        -: 7836:
        -: 7837:
        -: 7838:/* Test if D points to a character which is word-constituent.  We have
        -: 7839:   two special cases to check for: if past the end of string1, look at
        -: 7840:   the first character in string2; and if before the beginning of
        -: 7841:   string2, look at the last character in string1.  */
        -: 7842:#define WORDCHAR_P(d)							\
        -: 7843:  (SYNTAX ((d) == end1 ? *string2					\
        -: 7844:           : (d) == string2 - 1 ? *(end1 - 1) : *(d))			\
        -: 7845:   == Sword)
        -: 7846:
        -: 7847:/* Disabled due to a compiler bug -- see comment at case wordbound */
        -: 7848:#if 0
        -: 7849:/* Test if the character before D and the one at D differ with respect
        -: 7850:   to being word-constituent.  */
        -: 7851:#define AT_WORD_BOUNDARY(d)						\
        -: 7852:  (AT_STRINGS_BEG (d) || AT_STRINGS_END (d)				\
        -: 7853:   || WORDCHAR_P (d - 1) != WORDCHAR_P (d))
        -: 7854:#endif
        -: 7855:
        -: 7856:/* Free everything we malloc.  */
        -: 7857:#ifdef MATCH_MAY_ALLOCATE
        -: 7858:# define FREE_VAR(var) if (var) REGEX_FREE (var); var = NULL
        -: 7859:# define FREE_VARIABLES()						\
        -: 7860:  do {									\
        -: 7861:    REGEX_FREE_STACK (fail_stack.stack);				\
        -: 7862:    FREE_VAR (regstart);						\
        -: 7863:    FREE_VAR (regend);							\
        -: 7864:    FREE_VAR (old_regstart);						\
        -: 7865:    FREE_VAR (old_regend);						\
        -: 7866:    FREE_VAR (best_regstart);						\
        -: 7867:    FREE_VAR (best_regend);						\
        -: 7868:    FREE_VAR (reg_info);						\
        -: 7869:    FREE_VAR (reg_dummy);						\
        -: 7870:    FREE_VAR (reg_info_dummy);						\
        -: 7871:  } while (0)
        -: 7872:#else
        -: 7873:# define FREE_VARIABLES() ((void)0) /* Do nothing!  But inhibit gcc warning. */
        -: 7874:#endif /* not MATCH_MAY_ALLOCATE */
        -: 7875:
        -: 7876:/* These values must meet several constraints.  They must not be valid
        -: 7877:   register values; since we have a limit of 255 registers (because
        -: 7878:   we use only one byte in the pattern for the register number), we can
        -: 7879:   use numbers larger than 255.  They must differ by 1, because of
        -: 7880:   NUM_FAILURE_ITEMS above.  And the value for the lowest register must
        -: 7881:   be larger than the value for the highest register, so we do not try
        -: 7882:   to actually save any registers when none are active.  */
        -: 7883:#define NO_HIGHEST_ACTIVE_REG (1 << BYTEWIDTH)
        -: 7884:#define NO_LOWEST_ACTIVE_REG (NO_HIGHEST_ACTIVE_REG + 1)
        -: 7885:
        -: 7886:/* Matching routines.  */
        -: 7887:
        -: 7888:#ifndef emacs   /* Emacs never uses this.  */
        -: 7889:/* re_match is like re_match_2 except it takes only a single string.  */
        -: 7890:
        -: 7891:int
function re_match called 0 returned 0% blocks executed 0%
    #####: 7892:re_match (bufp, string, size, pos, regs)
        -: 7893:     struct re_pattern_buffer *bufp;
        -: 7894:     const char *string;
        -: 7895:     int size, pos;
        -: 7896:     struct re_registers *regs;
        -: 7897:{
    #####: 7898:  int result = re_match_2_internal (bufp, NULL, 0, string, size,
call    0 never executed
        -: 7899:				    pos, regs, size);
        -: 7900:# ifndef REGEX_MALLOC
        -: 7901:#  ifdef C_ALLOCA
        -: 7902:  alloca (0);
        -: 7903:#  endif
        -: 7904:# endif
    #####: 7905:  return result;
        -: 7906:}
        -: 7907:# ifdef _LIBC
        -: 7908:weak_alias (__re_match, re_match)
        -: 7909:# endif
        -: 7910:#endif /* not emacs */
        -: 7911:
        -: 7912:static boolean group_match_null_string_p _RE_ARGS ((unsigned char **p,
        -: 7913:						    unsigned char *end,
        -: 7914:						register_info_type *reg_info));
        -: 7915:static boolean alt_match_null_string_p _RE_ARGS ((unsigned char *p,
        -: 7916:						  unsigned char *end,
        -: 7917:						register_info_type *reg_info));
        -: 7918:static boolean common_op_match_null_string_p _RE_ARGS ((unsigned char **p,
        -: 7919:							unsigned char *end,
        -: 7920:						register_info_type *reg_info));
        -: 7921:static int bcmp_translate _RE_ARGS ((const char *s1, const char *s2,
        -: 7922:				     int len, char *translate));
        -: 7923:
        -: 7924:/* re_match_2 matches the compiled pattern in BUFP against the
        -: 7925:   the (virtual) concatenation of STRING1 and STRING2 (of length SIZE1
        -: 7926:   and SIZE2, respectively).  We start matching at POS, and stop
        -: 7927:   matching at STOP.
        -: 7928:
        -: 7929:   If REGS is non-null and the `no_sub' field of BUFP is nonzero, we
        -: 7930:   store offsets for the substring each group matched in REGS.  See the
        -: 7931:   documentation for exactly how many groups we fill.
        -: 7932:
        -: 7933:   We return -1 if no match, -2 if an internal error (such as the
        -: 7934:   failure stack overflowing).  Otherwise, we return the length of the
        -: 7935:   matched substring.  */
        -: 7936:
        -: 7937:int
function re_match_2 called 0 returned 0% blocks executed 0%
    #####: 7938:re_match_2 (bufp, string1, size1, string2, size2, pos, regs, stop)
        -: 7939:     struct re_pattern_buffer *bufp;
        -: 7940:     const char *string1, *string2;
        -: 7941:     int size1, size2;
        -: 7942:     int pos;
        -: 7943:     struct re_registers *regs;
        -: 7944:     int stop;
        -: 7945:{
    #####: 7946:  int result = re_match_2_internal (bufp, string1, size1, string2, size2,
call    0 never executed
        -: 7947:				    pos, regs, stop);
        -: 7948:#ifndef REGEX_MALLOC
        -: 7949:# ifdef C_ALLOCA
        -: 7950:  alloca (0);
        -: 7951:# endif
        -: 7952:#endif
    #####: 7953:  return result;
        -: 7954:}
        -: 7955:#ifdef _LIBC
        -: 7956:weak_alias (__re_match_2, re_match_2)
        -: 7957:#endif
        -: 7958:
        -: 7959:/* This is a separate function so that we can force an alloca cleanup
        -: 7960:   afterwards.  */
        -: 7961:static int
function re_match_2_internal called 664112 returned 100% blocks executed 40%
   664112: 7962:re_match_2_internal (bufp, string1, size1, string2, size2, pos, regs, stop)
        -: 7963:     struct re_pattern_buffer *bufp;
        -: 7964:     const char *string1, *string2;
        -: 7965:     int size1, size2;
        -: 7966:     int pos;
        -: 7967:     struct re_registers *regs;
        -: 7968:     int stop;
  1206370: 7969:{
        -: 7970:  /* General temporaries.  */
        -: 7971:  int mcnt;
        -: 7972:  unsigned char *p1;
        -: 7973:
        -: 7974:  /* Just past the end of the corresponding string.  */
        -: 7975:  const char *end1, *end2;
        -: 7976:
        -: 7977:  /* Pointers into string1 and string2, just past the last characters in
        -: 7978:     each to consider matching.  */
        -: 7979:  const char *end_match_1, *end_match_2;
        -: 7980:
        -: 7981:  /* Where we are in the data, and the end of the current string.  */
        -: 7982:  const char *d, *dend;
        -: 7983:
        -: 7984:  /* Where we are in the pattern, and the end of the pattern.  */
   664112: 7985:  unsigned char *p = bufp->buffer;
   664112: 7986:  register unsigned char *pend = p + bufp->used;
        -: 7987:
        -: 7988:  /* Mark the opcode just after a start_memory, so we can test for an
        -: 7989:     empty subpattern when we get to the stop_memory.  */
   664112: 7990:  unsigned char *just_past_start_mem = 0;
        -: 7991:
        -: 7992:  /* We use this to map every character in the string.  */
   664112: 7993:  RE_TRANSLATE_TYPE translate = bufp->translate;
        -: 7994:
        -: 7995:  /* Failure point stack.  Each place that can handle a failure further
        -: 7996:     down the line pushes a failure point on this stack.  It consists of
        -: 7997:     restart, regend, and reg_info for all registers corresponding to
        -: 7998:     the subexpressions we're currently inside, plus the number of such
        -: 7999:     registers, and, finally, two char *'s.  The first char * is where
        -: 8000:     to resume scanning the pattern; the second one is where to resume
        -: 8001:     scanning the strings.  If the latter is zero, the failure point is
        -: 8002:     a ``dummy''; if a failure happens and the failure point is a dummy,
        -: 8003:     it gets discarded and the next next one is tried.  */
        -: 8004:#ifdef MATCH_MAY_ALLOCATE /* otherwise, this is global.  */
        -: 8005:  fail_stack_type fail_stack;
        -: 8006:#endif
        -: 8007:#ifdef DEBUG
        -: 8008:  static unsigned failure_id = 0;
        -: 8009:  unsigned nfailure_points_pushed = 0, nfailure_points_popped = 0;
        -: 8010:#endif
        -: 8011:
        -: 8012:#ifdef REL_ALLOC
        -: 8013:  /* This holds the pointer to the failure stack, when
        -: 8014:     it is allocated relocatably.  */
        -: 8015:  fail_stack_elt_t *failure_stack_ptr;
        -: 8016:#endif
        -: 8017:
        -: 8018:  /* We fill all the registers internally, independent of what we
        -: 8019:     return, for use in backreferences.  The number here includes
        -: 8020:     an element for register zero.  */
   664112: 8021:  size_t num_regs = bufp->re_nsub + 1;
        -: 8022:
        -: 8023:  /* The currently active registers.  */
   664112: 8024:  active_reg_t lowest_active_reg = NO_LOWEST_ACTIVE_REG;
   664112: 8025:  active_reg_t highest_active_reg = NO_HIGHEST_ACTIVE_REG;
        -: 8026:
        -: 8027:  /* Information on the contents of registers. These are pointers into
        -: 8028:     the input strings; they record just what was matched (on this
        -: 8029:     attempt) by a subexpression part of the pattern, that is, the
        -: 8030:     regnum-th regstart pointer points to where in the pattern we began
        -: 8031:     matching and the regnum-th regend points to right after where we
        -: 8032:     stopped matching the regnum-th subexpression.  (The zeroth register
        -: 8033:     keeps track of what the whole pattern matches.)  */
        -: 8034:#ifdef MATCH_MAY_ALLOCATE /* otherwise, these are global.  */
        -: 8035:  const char **regstart, **regend;
        -: 8036:#endif
        -: 8037:
        -: 8038:  /* If a group that's operated upon by a repetition operator fails to
        -: 8039:     match anything, then the register for its start will need to be
        -: 8040:     restored because it will have been set to wherever in the string we
        -: 8041:     are when we last see its open-group operator.  Similarly for a
        -: 8042:     register's end.  */
        -: 8043:#ifdef MATCH_MAY_ALLOCATE /* otherwise, these are global.  */
        -: 8044:  const char **old_regstart, **old_regend;
        -: 8045:#endif
        -: 8046:
        -: 8047:  /* The is_active field of reg_info helps us keep track of which (possibly
        -: 8048:     nested) subexpressions we are currently in. The matched_something
        -: 8049:     field of reg_info[reg_num] helps us tell whether or not we have
        -: 8050:     matched any of the pattern so far this time through the reg_num-th
        -: 8051:     subexpression.  These two fields get reset each time through any
        -: 8052:     loop their register is in.  */
        -: 8053:#ifdef MATCH_MAY_ALLOCATE /* otherwise, this is global.  */
        -: 8054:  register_info_type *reg_info;
        -: 8055:#endif
        -: 8056:
        -: 8057:  /* The following record the register info as found in the above
        -: 8058:     variables when we find a match better than any we've seen before.
        -: 8059:     This happens as we backtrack through the failure points, which in
        -: 8060:     turn happens only if we have not yet matched the entire string. */
   664112: 8061:  unsigned best_regs_set = false;
        -: 8062:#ifdef MATCH_MAY_ALLOCATE /* otherwise, these are global.  */
        -: 8063:  const char **best_regstart, **best_regend;
        -: 8064:#endif
        -: 8065:
        -: 8066:  /* Logically, this is `best_regend[0]'.  But we don't want to have to
        -: 8067:     allocate space for that if we're not allocating space for anything
        -: 8068:     else (see below).  Also, we never need info about register 0 for
        -: 8069:     any of the other register vectors, and it seems rather a kludge to
        -: 8070:     treat `best_regend' differently than the rest.  So we keep track of
        -: 8071:     the end of the best match so far in a separate variable.  We
        -: 8072:     initialize this to NULL so that when we backtrack the first time
        -: 8073:     and need to test it, it's not garbage.  */
   664112: 8074:  const char *match_end = NULL;
        -: 8075:
        -: 8076:  /* This helps SET_REGS_MATCHED avoid doing redundant work.  */
   664112: 8077:  int set_regs_matched_done = 0;
        -: 8078:
        -: 8079:  /* Used when we pop values we don't care about.  */
        -: 8080:#ifdef MATCH_MAY_ALLOCATE /* otherwise, these are global.  */
        -: 8081:  const char **reg_dummy;
        -: 8082:  register_info_type *reg_info_dummy;
        -: 8083:#endif
        -: 8084:
        -: 8085:#ifdef DEBUG
        -: 8086:  /* Counts the total number of registers pushed.  */
        -: 8087:  unsigned num_regs_pushed = 0;
        -: 8088:#endif
        -: 8089:
        -: 8090:  DEBUG_PRINT1 ("\n\nEntering re_match_2.\n");
        -: 8091:
  664112*: 8092:  INIT_FAIL_STACK ();
branch  0 taken 0 (fallthrough)
branch  1 taken 664112
        -: 8093:
        -: 8094:#ifdef MATCH_MAY_ALLOCATE
        -: 8095:  /* Do not bother to initialize all the register variables if there are
        -: 8096:     no groups in the pattern, as it takes a fair amount of time.  If
        -: 8097:     there are groups, we include space for register 0 (the whole
        -: 8098:     pattern), even though we never use it, since it simplifies the
        -: 8099:     array indexing.  We should fix this.  */
   664112: 8100:  if (bufp->re_nsub)
branch  0 taken 3507 (fallthrough)
branch  1 taken 660605
        -: 8101:    {
     3507: 8102:      regstart = REGEX_TALLOC (num_regs, const char *);
     3507: 8103:      regend = REGEX_TALLOC (num_regs, const char *);
     3507: 8104:      old_regstart = REGEX_TALLOC (num_regs, const char *);
     3507: 8105:      old_regend = REGEX_TALLOC (num_regs, const char *);
     3507: 8106:      best_regstart = REGEX_TALLOC (num_regs, const char *);
     3507: 8107:      best_regend = REGEX_TALLOC (num_regs, const char *);
     3507: 8108:      reg_info = REGEX_TALLOC (num_regs, register_info_type);
     3507: 8109:      reg_dummy = REGEX_TALLOC (num_regs, const char *);
     3507: 8110:      reg_info_dummy = REGEX_TALLOC (num_regs, register_info_type);
        -: 8111:
     7014: 8112:      if (!(regstart && regend && old_regstart && old_regend && reg_info
branch  0 taken 3507 (fallthrough)
branch  1 taken 0
branch  2 taken 3507 (fallthrough)
branch  3 taken 0
branch  4 taken 3507 (fallthrough)
branch  5 taken 0
branch  6 taken 3507 (fallthrough)
branch  7 taken 0
branch  8 taken 3507 (fallthrough)
branch  9 taken 0
branch 10 taken 0 (fallthrough)
branch 11 taken 3507
     3507: 8113:            && best_regstart && best_regend && reg_dummy && reg_info_dummy))
branch  0 taken 3507 (fallthrough)
branch  1 taken 0
branch  2 taken 3507 (fallthrough)
branch  3 taken 0
branch  4 taken 3507 (fallthrough)
branch  5 taken 0
        -: 8114:        {
    #####: 8115:          FREE_VARIABLES ();
    #####: 8116:          return -2;
        -: 8117:        }
        -: 8118:    }
        -: 8119:  else
        -: 8120:    {
        -: 8121:      /* We must initialize all our variables to NULL, so that
        -: 8122:         `FREE_VARIABLES' doesn't try to free them.  */
   660605: 8123:      regstart = regend = old_regstart = old_regend = best_regstart
   660605: 8124:        = best_regend = reg_dummy = NULL;
   660605: 8125:      reg_info = reg_info_dummy = (register_info_type *) NULL;
        -: 8126:    }
        -: 8127:#endif /* MATCH_MAY_ALLOCATE */
        -: 8128:
        -: 8129:  /* The starting position is bogus.  */
   664112: 8130:  if (pos < 0 || pos > size1 + size2)
branch  0 taken 664112 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 664112
        -: 8131:    {
    #####: 8132:      FREE_VARIABLES ();
    #####: 8133:      return -1;
        -: 8134:    }
        -: 8135:
        -: 8136:  /* Initialize subexpression text positions to -1 to mark ones that no
        -: 8137:     start_memory/stop_memory has been seen for. Also initialize the
        -: 8138:     register information struct.  */
   669590: 8139:  for (mcnt = 1; (unsigned) mcnt < num_regs; mcnt++)
branch  0 taken 5478
branch  1 taken 664112 (fallthrough)
        -: 8140:    {
     5478: 8141:      regstart[mcnt] = regend[mcnt]
     5478: 8142:        = old_regstart[mcnt] = old_regend[mcnt] = REG_UNSET_VALUE;
        -: 8143:
     5478: 8144:      REG_MATCH_NULL_STRING_P (reg_info[mcnt]) = MATCH_NULL_UNSET_VALUE;
     5478: 8145:      IS_ACTIVE (reg_info[mcnt]) = 0;
     5478: 8146:      MATCHED_SOMETHING (reg_info[mcnt]) = 0;
     5478: 8147:      EVER_MATCHED_SOMETHING (reg_info[mcnt]) = 0;
        -: 8148:    }
        -: 8149:
        -: 8150:  /* We move `string1' into `string2' if the latter's empty -- but not if
        -: 8151:     `string1' is null.  */
   664112: 8152:  if (size2 == 0 && string1 != NULL)
branch  0 taken 13909 (fallthrough)
branch  1 taken 650203
branch  2 taken 0 (fallthrough)
branch  3 taken 13909
        -: 8153:    {
    #####: 8154:      string2 = string1;
    #####: 8155:      size2 = size1;
    #####: 8156:      string1 = 0;
    #####: 8157:      size1 = 0;
        -: 8158:    }
   664112: 8159:  end1 = string1 + size1;
   664112: 8160:  end2 = string2 + size2;
        -: 8161:
        -: 8162:  /* Compute where to stop matching, within the two strings.  */
   664112: 8163:  if (stop <= size1)
branch  0 taken 13909 (fallthrough)
branch  1 taken 650203
        -: 8164:    {
    13909: 8165:      end_match_1 = string1 + stop;
    13909: 8166:      end_match_2 = string2;
        -: 8167:    }
        -: 8168:  else
        -: 8169:    {
   650203: 8170:      end_match_1 = end1;
   650203: 8171:      end_match_2 = string2 + stop - size1;
        -: 8172:    }
        -: 8173:
        -: 8174:  /* `p' scans through the pattern as `d' scans through the data.
        -: 8175:     `dend' is the end of the input string that `d' points within.  `d'
        -: 8176:     is advanced into the following input string whenever necessary, but
        -: 8177:     this happens before fetching; therefore, at the beginning of the
        -: 8178:     loop, `d' can be pointing at the end of a string, but it cannot
        -: 8179:     equal `string2'.  */
  664112*: 8180:  if (size1 > 0 && pos <= size1)
branch  0 taken 0 (fallthrough)
branch  1 taken 664112
branch  2 never executed
branch  3 never executed
        -: 8181:    {
    #####: 8182:      d = string1 + pos;
    #####: 8183:      dend = end_match_1;
        -: 8184:    }
        -: 8185:  else
        -: 8186:    {
   664112: 8187:      d = string2 + pos - size1;
   664112: 8188:      dend = end_match_2;
        -: 8189:    }
        -: 8190:
        -: 8191:  DEBUG_PRINT1 ("The compiled pattern is:\n");
        -: 8192:  DEBUG_PRINT_COMPILED_PATTERN (bufp, p, pend);
        -: 8193:  DEBUG_PRINT1 ("The string to match is: `");
        -: 8194:  DEBUG_PRINT_DOUBLE_STRING (d, string1, size1, string2, size2);
        -: 8195:  DEBUG_PRINT1 ("'\n");
        -: 8196:
        -: 8197:  /* This loops over pattern commands.  It exits by returning from the
        -: 8198:     function if the match is complete, or it drops through if the match
        -: 8199:     fails at this starting point in the input data.  */
        -: 8200:  for (;;)
        -: 8201:    {
        -: 8202:#ifdef _LIBC
        -: 8203:      DEBUG_PRINT2 ("\n%p: ", p);
        -: 8204:#else
        -: 8205:      DEBUG_PRINT2 ("\n0x%x: ", p);
        -: 8206:#endif
        -: 8207:
  2261415: 8208:      if (p == pend)
branch  0 taken 5853 (fallthrough)
branch  1 taken 2255562
        -: 8209:	{ /* End of pattern means we might have succeeded.  */
        -: 8210:          DEBUG_PRINT1 ("end of pattern ... ");
        -: 8211:
        -: 8212:	  /* If we haven't matched the entire string, and we want the
        -: 8213:             longest match, try backtracking.  */
     5853: 8214:          if (d != end_match_2)
branch  0 taken 2615 (fallthrough)
branch  1 taken 3238
        -: 8215:	    {
        -: 8216:	      /* 1 if this match ends in the same string (string1 or string2)
        -: 8217:		 as the best previous match.  */
    3238*: 8218:	      boolean same_str_p = (FIRST_STRING_P (match_end)
branch  0 taken 0 (fallthrough)
branch  1 taken 3238
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
     3238: 8219:				    == MATCHING_IN_FIRST_STRING);
        -: 8220:	      /* 1 if this match is the best seen so far.  */
        -: 8221:	      boolean best_match_p;
        -: 8222:
        -: 8223:	      /* AIX compiler got confused when this was combined
        -: 8224:		 with the previous declaration.  */
     3238: 8225:	      if (same_str_p)
branch  0 taken 3238 (fallthrough)
branch  1 taken 0
     3238: 8226:		best_match_p = d > match_end;
        -: 8227:	      else
    #####: 8228:		best_match_p = !MATCHING_IN_FIRST_STRING;
        -: 8229:
        -: 8230:              DEBUG_PRINT1 ("backtracking.\n");
        -: 8231:
     3238: 8232:              if (!FAIL_STACK_EMPTY ())
branch  0 taken 136 (fallthrough)
branch  1 taken 3102
        -: 8233:                { /* More failure points to try.  */
        -: 8234:
        -: 8235:                  /* If exceeds best match so far, save it.  */
      136: 8236:                  if (!best_regs_set || best_match_p)
branch  0 taken 75 (fallthrough)
branch  1 taken 61
branch  2 taken 0 (fallthrough)
branch  3 taken 75
        -: 8237:                    {
       61: 8238:                      best_regs_set = true;
       61: 8239:                      match_end = d;
        -: 8240:
        -: 8241:                      DEBUG_PRINT1 ("\nSAVING match as best so far.\n");
        -: 8242:
       69: 8243:                      for (mcnt = 1; (unsigned) mcnt < num_regs; mcnt++)
branch  0 taken 8
branch  1 taken 61 (fallthrough)
        -: 8244:                        {
        8: 8245:                          best_regstart[mcnt] = regstart[mcnt];
        8: 8246:                          best_regend[mcnt] = regend[mcnt];
        -: 8247:                        }
        -: 8248:                    }
      136: 8249:                  goto fail;
        -: 8250:                }
        -: 8251:
        -: 8252:              /* If no failure points, don't restore garbage.  And if
        -: 8253:                 last match is real best match, don't restore second
        -: 8254:                 best one. */
     3102: 8255:              else if (best_regs_set && !best_match_p)
branch  0 taken 3096 (fallthrough)
branch  1 taken 6
branch  2 taken 0 (fallthrough)
branch  3 taken 6
        -: 8256:                {
        6: 8257:  	        restore_best_regs:
        -: 8258:                  /* Restore best match.  It may happen that `dend ==
        -: 8259:                     end_match_1' while the restored d is in string2.
        -: 8260:                     For example, the pattern `x.*y.*z' against the
        -: 8261:                     strings `x-' and `y-z-', if the two strings are
        -: 8262:                     not consecutive in memory.  */
        -: 8263:                  DEBUG_PRINT1 ("Restoring best registers.\n");
        -: 8264:
       61: 8265:                  d = match_end;
       61: 8266:                  dend = ((d >= string1 && d <= end1)
branch  0 taken 0 (fallthrough)
branch  1 taken 61
     122*: 8267:		           ? end_match_1 : end_match_2);
branch  0 taken 61 (fallthrough)
branch  1 taken 0
        -: 8268:
       69: 8269:		  for (mcnt = 1; (unsigned) mcnt < num_regs; mcnt++)
branch  0 taken 8
branch  1 taken 61 (fallthrough)
        -: 8270:		    {
        8: 8271:		      regstart[mcnt] = best_regstart[mcnt];
        8: 8272:		      regend[mcnt] = best_regend[mcnt];
        -: 8273:		    }
        -: 8274:                }
        -: 8275:            } /* d != end_match_2 */
        -: 8276:
    5772*: 8277:	succeed_label:
        -: 8278:          DEBUG_PRINT1 ("Accepting match.\n");
        -: 8279:
        -: 8280:          /* If caller wants register contents data back, do it.  */
     5772: 8281:          if (regs && !bufp->no_sub)
branch  0 taken 3491 (fallthrough)
branch  1 taken 2281
branch  2 taken 3491 (fallthrough)
branch  3 taken 0
        -: 8282:	    {
        -: 8283:              /* Have the register data arrays been allocated?  */
     3491: 8284:              if (bufp->regs_allocated == REGS_UNALLOCATED)
branch  0 taken 0 (fallthrough)
branch  1 taken 3491
        -: 8285:                { /* No.  So allocate them with malloc.  We need one
        -: 8286:                     extra element beyond `num_regs' for the `-1' marker
        -: 8287:                     GNU code uses.  */
    #####: 8288:                  regs->num_regs = MAX (RE_NREGS, num_regs + 1);
    #####: 8289:                  regs->start = TALLOC (regs->num_regs, regoff_t);
    #####: 8290:                  regs->end = TALLOC (regs->num_regs, regoff_t);
    #####: 8291:                  if (regs->start == NULL || regs->end == NULL)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 8292:		    {
    #####: 8293:		      FREE_VARIABLES ();
    #####: 8294:		      return -2;
        -: 8295:		    }
    #####: 8296:                  bufp->regs_allocated = REGS_REALLOCATE;
        -: 8297:                }
     3491: 8298:              else if (bufp->regs_allocated == REGS_REALLOCATE)
branch  0 taken 0 (fallthrough)
branch  1 taken 3491
        -: 8299:                { /* Yes.  If we need more elements than were already
        -: 8300:                     allocated, reallocate them.  If we need fewer, just
        -: 8301:                     leave it alone.  */
    #####: 8302:                  if (regs->num_regs < num_regs + 1)
branch  0 never executed
branch  1 never executed
        -: 8303:                    {
    #####: 8304:                      regs->num_regs = num_regs + 1;
    #####: 8305:                      RETALLOC (regs->start, regs->num_regs, regoff_t);
    #####: 8306:                      RETALLOC (regs->end, regs->num_regs, regoff_t);
    #####: 8307:                      if (regs->start == NULL || regs->end == NULL)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 8308:			{
    #####: 8309:			  FREE_VARIABLES ();
    #####: 8310:			  return -2;
        -: 8311:			}
        -: 8312:                    }
        -: 8313:                }
        -: 8314:              else
        -: 8315:		{
        -: 8316:		  /* These braces fend off a "empty body in an else-statement"
        -: 8317:		     warning under GCC when assert expands to nothing.  */
        -: 8318:		  assert (bufp->regs_allocated == REGS_FIXED);
        -: 8319:		}
        -: 8320:
        -: 8321:              /* Convert the pointer data in `regstart' and `regend' to
        -: 8322:                 indices.  Register zero has to be set differently,
        -: 8323:                 since we haven't kept track of any info for it.  */
     3491: 8324:              if (regs->num_regs > 0)
branch  0 taken 3491 (fallthrough)
branch  1 taken 0
        -: 8325:                {
     3491: 8326:                  regs->start[0] = pos;
     3491: 8327:                  regs->end[0] = (MATCHING_IN_FIRST_STRING
    #####: 8328:				  ? ((regoff_t) (d - string1))
    3491*: 8329:			          : ((regoff_t) (d - string2 + size1)));
branch  0 taken 0 (fallthrough)
branch  1 taken 3491
        -: 8330:                }
        -: 8331:
        -: 8332:              /* Go through the first `min (num_regs, regs->num_regs)'
        -: 8333:                 registers, since that is all we initialized.  */
     3527: 8334:	      for (mcnt = 1; (unsigned) mcnt < MIN (num_regs, regs->num_regs);
branch  0 taken 36
branch  1 taken 3491 (fallthrough)
       36: 8335:		   mcnt++)
        -: 8336:		{
       36: 8337:                  if (REG_UNSET (regstart[mcnt]) || REG_UNSET (regend[mcnt]))
branch  0 taken 24 (fallthrough)
branch  1 taken 12
branch  2 taken 0 (fallthrough)
branch  3 taken 24
       12: 8338:                    regs->start[mcnt] = regs->end[mcnt] = -1;
        -: 8339:                  else
        -: 8340:                    {
       24: 8341:		      regs->start[mcnt]
      24*: 8342:			= (regoff_t) POINTER_TO_OFFSET (regstart[mcnt]);
branch  0 taken 0 (fallthrough)
branch  1 taken 24
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
       24: 8343:                      regs->end[mcnt]
      24*: 8344:			= (regoff_t) POINTER_TO_OFFSET (regend[mcnt]);
branch  0 taken 0 (fallthrough)
branch  1 taken 24
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 8345:                    }
        -: 8346:		}
        -: 8347:
        -: 8348:              /* If the regs structure we return has more elements than
        -: 8349:                 were in the pattern, set the extra elements to -1.  If
        -: 8350:                 we (re)allocated the registers, this is the case,
        -: 8351:                 because we always allocate enough to have at least one
        -: 8352:                 -1 at the end.  */
    34874: 8353:              for (mcnt = num_regs; (unsigned) mcnt < regs->num_regs; mcnt++)
branch  0 taken 31383
branch  1 taken 3491 (fallthrough)
    31383: 8354:                regs->start[mcnt] = regs->end[mcnt] = -1;
        -: 8355:	    } /* regs && !bufp->no_sub */
        -: 8356:
        -: 8357:          DEBUG_PRINT4 ("%u failure points pushed, %u popped (%u remain).\n",
        -: 8358:                        nfailure_points_pushed, nfailure_points_popped,
        -: 8359:                        nfailure_points_pushed - nfailure_points_popped);
        -: 8360:          DEBUG_PRINT2 ("%u registers pushed.\n", num_regs_pushed);
        -: 8361:
     5772: 8362:          mcnt = d - pos - (MATCHING_IN_FIRST_STRING
        -: 8363:			    ? string1
    5772*: 8364:			    : string2 - size1);
branch  0 taken 5772 (fallthrough)
branch  1 taken 0
        -: 8365:
        -: 8366:          DEBUG_PRINT2 ("Returning %d from re_match_2.\n", mcnt);
        -: 8367:
     5772: 8368:          FREE_VARIABLES ();
     5772: 8369:          return mcnt;
        -: 8370:        }
        -: 8371:
        -: 8372:      /* Otherwise match next pattern command.  */
  2255562: 8373:      switch (SWITCH_ENUM_CAST ((re_opcode_t) *p++))
branch  0 taken 144
branch  1 taken 0
branch  2 taken 858256
branch  3 taken 411627
branch  4 taken 7135
branch  5 taken 3459
branch  6 taken 271
branch  7 taken 0
branch  8 taken 167770
branch  9 taken 6843
branch 10 taken 0
branch 11 taken 0
branch 12 taken 0
branch 13 taken 413342
branch 14 taken 117
branch 15 taken 13033
branch 16 taken 368204
branch 17 taken 6
branch 18 taken 0
branch 19 taken 0
branch 20 taken 1807
branch 21 taken 78
branch 22 taken 3470
branch 23 taken 0
branch 24 taken 0
branch 25 taken 0
branch 26 taken 0
branch 27 taken 0
branch 28 taken 0
branch 29 taken 0
        -: 8374:	{
        -: 8375:        /* Ignore these.  Used to ignore the n of succeed_n's which
        -: 8376:           currently have n == 0.  */
      144: 8377:        case no_op:
        -: 8378:          DEBUG_PRINT1 ("EXECUTING no_op.\n");
      144: 8379:          break;
        -: 8380:
    #####: 8381:	case succeed:
        -: 8382:          DEBUG_PRINT1 ("EXECUTING succeed.\n");
    #####: 8383:	  goto succeed_label;
        -: 8384:
        -: 8385:        /* Match the next n pattern characters exactly.  The following
        -: 8386:           byte in the pattern defines n, and the n bytes after that
        -: 8387:           are the characters to match.  */
   858256: 8388:	case exactn:
   858256: 8389:	  mcnt = *p++;
        -: 8390:          DEBUG_PRINT2 ("EXECUTING exactn %d.\n", mcnt);
        -: 8391:
        -: 8392:          /* This is written out as an if-else so we don't waste time
        -: 8393:             testing `translate' inside the loop.  */
   858256: 8394:          if (translate)
branch  0 taken 0 (fallthrough)
branch  1 taken 858256
        -: 8395:	    {
        -: 8396:	      do
        -: 8397:		{
    #####: 8398:		  PREFETCH ();
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 8399:		  if ((unsigned char) translate[(unsigned char) *d++]
    #####: 8400:		      != (unsigned char) *p++)
branch  0 never executed
branch  1 never executed
    #####: 8401:                    goto fail;
        -: 8402:		}
    #####: 8403:	      while (--mcnt);
branch  0 never executed
branch  1 never executed
        -: 8404:	    }
        -: 8405:	  else
        -: 8406:	    {
        -: 8407:	      do
        -: 8408:		{
  870491*: 8409:		  PREFETCH ();
branch  0 taken 61346 (fallthrough)
branch  1 taken 0
branch  2 taken 61346
branch  3 taken 809145 (fallthrough)
   809145: 8410:		  if (*d++ != (char) *p++) goto fail;
branch  0 taken 789561 (fallthrough)
branch  1 taken 19584
        -: 8411:		}
    19584: 8412:	      while (--mcnt);
branch  0 taken 12235
branch  1 taken 7349 (fallthrough)
        -: 8413:	    }
    7349*: 8414:	  SET_REGS_MATCHED ();
branch  0 taken 7323 (fallthrough)
branch  1 taken 26
branch  2 taken 0
branch  3 taken 7323 (fallthrough)
     7349: 8415:          break;
        -: 8416:
        -: 8417:
        -: 8418:        /* Match any character except possibly a newline or a null.  */
   411627: 8419:	case anychar:
        -: 8420:          DEBUG_PRINT1 ("EXECUTING anychar.\n");
        -: 8421:
  411627*: 8422:          PREFETCH ();
branch  0 taken 30273 (fallthrough)
branch  1 taken 0
branch  2 taken 30273
branch  3 taken 381354 (fallthrough)
        -: 8423:
  762708*: 8424:          if ((!(bufp->syntax & RE_DOT_NEWLINE) && TRANSLATE (*d) == '\n')
branch  0 taken 0 (fallthrough)
branch  1 taken 381354
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 taken 0 (fallthrough)
branch  9 taken 381354
  762708*: 8425:              || (bufp->syntax & RE_DOT_NOT_NULL && TRANSLATE (*d) == '\000'))
branch  0 taken 381354 (fallthrough)
branch  1 taken 0
branch  2 never executed
branch  3 never executed
branch  4 taken 0 (fallthrough)
branch  5 taken 381354
    #####: 8426:	    goto fail;
        -: 8427:
   381379: 8428:          SET_REGS_MATCHED ();
branch  0 taken 39588 (fallthrough)
branch  1 taken 341766
branch  2 taken 25
branch  3 taken 39588 (fallthrough)
        -: 8429:          DEBUG_PRINT2 ("  Matched `%d'.\n", *d);
   381354: 8430:          d++;
   381354: 8431:	  break;
        -: 8432:
        -: 8433:
     7135: 8434:	case charset:
        -: 8435:	case charset_not:
        -: 8436:	  {
        -: 8437:	    register unsigned char c;
     7135: 8438:	    boolean not = (re_opcode_t) *(p - 1) == charset_not;
        -: 8439:
        -: 8440:            DEBUG_PRINT2 ("EXECUTING charset%s.\n", not ? "_not" : "");
        -: 8441:
    7135*: 8442:	    PREFETCH ();
branch  0 taken 427 (fallthrough)
branch  1 taken 0
branch  2 taken 427
branch  3 taken 6708 (fallthrough)
    6708*: 8443:	    c = TRANSLATE (*d); /* The character to match.  */
branch  0 taken 0 (fallthrough)
branch  1 taken 6708
        -: 8444:
        -: 8445:            /* Cast to `unsigned' instead of `unsigned char' in case the
        -: 8446:               bit list is a full 32 bytes long.  */
     6708: 8447:	    if (c < (unsigned) (*p * BYTEWIDTH)
branch  0 taken 5298 (fallthrough)
branch  1 taken 1410
     5298: 8448:		&& p[1 + c / BYTEWIDTH] & (1 << (c % BYTEWIDTH)))
branch  0 taken 1734 (fallthrough)
branch  1 taken 3564
     1734: 8449:	      not = !not;
        -: 8450:
     6708: 8451:	    p += 1 + *p;
        -: 8452:
     6708: 8453:	    if (!not) goto fail;
branch  0 taken 4955 (fallthrough)
branch  1 taken 1753
        -: 8454:
     1911: 8455:	    SET_REGS_MATCHED ();
branch  0 taken 926 (fallthrough)
branch  1 taken 827
branch  2 taken 158
branch  3 taken 926 (fallthrough)
     1753: 8456:            d++;
     1753: 8457:	    break;
        -: 8458:	  }
        -: 8459:
        -: 8460:
        -: 8461:        /* The beginning of a group is represented by start_memory.
        -: 8462:           The arguments are the register number in the next byte, and the
        -: 8463:           number of groups inner to this one in the next.  The text
        -: 8464:           matched within the group is recorded (in the internal
        -: 8465:           registers data structure) under the register number.  */
     3459: 8466:        case start_memory:
        -: 8467:	  DEBUG_PRINT3 ("EXECUTING start_memory %d (%d):\n", *p, p[1]);
        -: 8468:
        -: 8469:          /* Find out if this group can match the empty string.  */
     3459: 8470:	  p1 = p;		/* To send to group_match_null_string_p.  */
        -: 8471:
     3459: 8472:          if (REG_MATCH_NULL_STRING_P (reg_info[*p]) == MATCH_NULL_UNSET_VALUE)
branch  0 taken 3458 (fallthrough)
branch  1 taken 1
     3458: 8473:            REG_MATCH_NULL_STRING_P (reg_info[*p])
     3458: 8474:              = group_match_null_string_p (&p1, pend, reg_info);
call    0 returned 3458
        -: 8475:
        -: 8476:          /* Save the position in the string where we were the last time
        -: 8477:             we were at this open-group operator in case the group is
        -: 8478:             operated upon by a repetition operator, e.g., with `(a*)*b'
        -: 8479:             against `ab'; then we want to ignore where we are now in
        -: 8480:             the string in case this attempt to match fails.  */
     6918: 8481:          old_regstart[*p] = REG_MATCH_NULL_STRING_P (reg_info[*p])
    #####: 8482:                             ? REG_UNSET (regstart[*p]) ? d : regstart[*p]
branch  0 never executed
branch  1 never executed
    3459*: 8483:                             : regstart[*p];
branch  0 taken 0 (fallthrough)
branch  1 taken 3459
        -: 8484:	  DEBUG_PRINT2 ("  old_regstart: %d\n",
        -: 8485:			 POINTER_TO_OFFSET (old_regstart[*p]));
        -: 8486:
     3459: 8487:          regstart[*p] = d;
        -: 8488:	  DEBUG_PRINT2 ("  regstart: %d\n", POINTER_TO_OFFSET (regstart[*p]));
        -: 8489:
     3459: 8490:          IS_ACTIVE (reg_info[*p]) = 1;
     3459: 8491:          MATCHED_SOMETHING (reg_info[*p]) = 0;
        -: 8492:
        -: 8493:	  /* Clear this whenever we change the register activity status.  */
     3459: 8494:	  set_regs_matched_done = 0;
        -: 8495:
        -: 8496:          /* This is the new highest active register.  */
     3459: 8497:          highest_active_reg = *p;
        -: 8498:
        -: 8499:          /* If nothing was active before, this is the new lowest active
        -: 8500:             register.  */
     3459: 8501:          if (lowest_active_reg == NO_LOWEST_ACTIVE_REG)
branch  0 taken 31 (fallthrough)
branch  1 taken 3428
       31: 8502:            lowest_active_reg = *p;
        -: 8503:
        -: 8504:          /* Move past the register number and inner group count.  */
     3459: 8505:          p += 2;
     3459: 8506:	  just_past_start_mem = p;
        -: 8507:
     3459: 8508:          break;
        -: 8509:
        -: 8510:
        -: 8511:        /* The stop_memory opcode represents the end of a group.  Its
        -: 8512:           arguments are the same as start_memory's: the register
        -: 8513:           number, and the number of inner groups.  */
      271: 8514:	case stop_memory:
        -: 8515:	  DEBUG_PRINT3 ("EXECUTING stop_memory %d (%d):\n", *p, p[1]);
        -: 8516:
        -: 8517:          /* We need to save the string position the last time we were at
        -: 8518:             this close-group operator in case the group is operated
        -: 8519:             upon by a repetition operator, e.g., with `((a*)*(b*)*)*'
        -: 8520:             against `aba'; then we want to ignore where we are now in
        -: 8521:             the string in case this attempt to match fails.  */
      542: 8522:          old_regend[*p] = REG_MATCH_NULL_STRING_P (reg_info[*p])
    #####: 8523:                           ? REG_UNSET (regend[*p]) ? d : regend[*p]
branch  0 never executed
branch  1 never executed
     271*: 8524:			   : regend[*p];
branch  0 taken 0 (fallthrough)
branch  1 taken 271
        -: 8525:	  DEBUG_PRINT2 ("      old_regend: %d\n",
        -: 8526:			 POINTER_TO_OFFSET (old_regend[*p]));
        -: 8527:
      271: 8528:          regend[*p] = d;
        -: 8529:	  DEBUG_PRINT2 ("      regend: %d\n", POINTER_TO_OFFSET (regend[*p]));
        -: 8530:
        -: 8531:          /* This register isn't active anymore.  */
      271: 8532:          IS_ACTIVE (reg_info[*p]) = 0;
        -: 8533:
        -: 8534:	  /* Clear this whenever we change the register activity status.  */
      271: 8535:	  set_regs_matched_done = 0;
        -: 8536:
        -: 8537:          /* If this was the only register active, nothing is active
        -: 8538:             anymore.  */
      271: 8539:          if (lowest_active_reg == highest_active_reg)
branch  0 taken 265 (fallthrough)
branch  1 taken 6
        -: 8540:            {
      265: 8541:              lowest_active_reg = NO_LOWEST_ACTIVE_REG;
      265: 8542:              highest_active_reg = NO_HIGHEST_ACTIVE_REG;
        -: 8543:            }
        -: 8544:          else
        -: 8545:            { /* We must scan for the new highest active register, since
        -: 8546:                 it isn't necessarily one less than now: consider
        -: 8547:                 (a(b)c(d(e)f)g).  When group 3 ends, after the f), the
        -: 8548:                 new highest active register is 1.  */
        6: 8549:              unsigned char r = *p - 1;
       12: 8550:              while (r > 0 && !IS_ACTIVE (reg_info[r]))
branch  0 taken 6 (fallthrough)
branch  1 taken 6
branch  2 taken 6
branch  3 taken 0 (fallthrough)
        6: 8551:                r--;
        -: 8552:
        -: 8553:              /* If we end up at register zero, that means that we saved
        -: 8554:                 the registers as the result of an `on_failure_jump', not
        -: 8555:                 a `start_memory', and we jumped to past the innermost
        -: 8556:                 `stop_memory'.  For example, in ((.)*) we save
        -: 8557:                 registers 1 and 2 as a result of the *, but when we pop
        -: 8558:                 back to the second ), we are at the stop_memory 1.
        -: 8559:                 Thus, nothing is active.  */
        6: 8560:	      if (r == 0)
branch  0 taken 6 (fallthrough)
branch  1 taken 0
        -: 8561:                {
        6: 8562:                  lowest_active_reg = NO_LOWEST_ACTIVE_REG;
        6: 8563:                  highest_active_reg = NO_HIGHEST_ACTIVE_REG;
        -: 8564:                }
        -: 8565:              else
    #####: 8566:                highest_active_reg = r;
        -: 8567:            }
        -: 8568:
        -: 8569:          /* If just failed to match something this time around with a
        -: 8570:             group that's operated on by a repetition operator, try to
        -: 8571:             force exit from the ``loop'', and restore the register
        -: 8572:             information for this group that we had before trying this
        -: 8573:             last match.  */
      271: 8574:          if ((!MATCHED_SOMETHING (reg_info[*p])
branch  0 taken 252 (fallthrough)
branch  1 taken 19
      252: 8575:               || just_past_start_mem == p - 1)
branch  0 taken 0 (fallthrough)
branch  1 taken 252
       19: 8576:	      && (p + 2) < pend)
branch  0 taken 19 (fallthrough)
branch  1 taken 0
        -: 8577:            {
       19: 8578:              boolean is_a_jump_n = false;
        -: 8579:
       19: 8580:              p1 = p + 2;
       19: 8581:              mcnt = 0;
       19: 8582:              switch ((re_opcode_t) *p1++)
branch  0 taken 0
branch  1 taken 0
branch  2 taken 19
        -: 8583:                {
    #####: 8584:                  case jump_n:
    #####: 8585:		    is_a_jump_n = true;
    #####: 8586:                  case pop_failure_jump:
        -: 8587:		  case maybe_pop_jump:
        -: 8588:		  case jump:
        -: 8589:		  case dummy_failure_jump:
    #####: 8590:                    EXTRACT_NUMBER_AND_INCR (mcnt, p1);
    #####: 8591:		    if (is_a_jump_n)
branch  0 never executed
branch  1 never executed
    #####: 8592:		      p1 += 2;
    #####: 8593:                    break;
        -: 8594:
       19: 8595:                  default:
        -: 8596:                    /* do nothing */ ;
        -: 8597:                }
       19: 8598:	      p1 += mcnt;
        -: 8599:
        -: 8600:              /* If the next operation is a jump backwards in the pattern
        -: 8601:	         to an on_failure_jump right before the start_memory
        -: 8602:                 corresponding to this stop_memory, exit from the loop
        -: 8603:                 by forcing a failure after pushing on the stack the
        -: 8604:                 on_failure_jump's jump in the pattern, and d.  */
      19*: 8605:              if (mcnt < 0 && (re_opcode_t) *p1 == on_failure_jump
branch  0 taken 0 (fallthrough)
branch  1 taken 19
branch  2 never executed
branch  3 never executed
    #####: 8606:                  && (re_opcode_t) p1[3] == start_memory && p1[4] == *p)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 8607:		{
        -: 8608:                  /* If this group ever matched anything, then restore
        -: 8609:                     what its registers were before trying this last
        -: 8610:                     failed match, e.g., with `(a*)*b' against `ab' for
        -: 8611:                     regstart[1], and, e.g., with `((a*)*(b*)*)*'
        -: 8612:                     against `aba' for regend[3].
        -: 8613:
        -: 8614:                     Also restore the registers for inner groups for,
        -: 8615:                     e.g., `((a*)(b*))*' against `aba' (register 3 would
        -: 8616:                     otherwise get trashed).  */
        -: 8617:
    #####: 8618:                  if (EVER_MATCHED_SOMETHING (reg_info[*p]))
branch  0 never executed
branch  1 never executed
        -: 8619:		    {
        -: 8620:		      unsigned r;
        -: 8621:
    #####: 8622:                      EVER_MATCHED_SOMETHING (reg_info[*p]) = 0;
        -: 8623:
        -: 8624:		      /* Restore this and inner groups' (if any) registers.  */
    #####: 8625:                      for (r = *p; r < (unsigned) *p + (unsigned) *(p + 1);
branch  0 never executed
branch  1 never executed
    #####: 8626:			   r++)
        -: 8627:                        {
    #####: 8628:                          regstart[r] = old_regstart[r];
        -: 8629:
        -: 8630:                          /* xx why this test?  */
    #####: 8631:                          if (old_regend[r] >= regstart[r])
branch  0 never executed
branch  1 never executed
    #####: 8632:                            regend[r] = old_regend[r];
        -: 8633:                        }
        -: 8634:                    }
    #####: 8635:		  p1++;
    #####: 8636:                  EXTRACT_NUMBER_AND_INCR (mcnt, p1);
    #####: 8637:                  PUSH_FAILURE_POINT (p1 + mcnt, d, -2);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
        -: 8638:
    #####: 8639:                  goto fail;
        -: 8640:                }
        -: 8641:            }
        -: 8642:
        -: 8643:          /* Move past the register number and the inner group count.  */
      271: 8644:          p += 2;
      271: 8645:          break;
        -: 8646:
        -: 8647:
        -: 8648:	/* \<digit> has been turned into a `duplicate' command which is
        -: 8649:           followed by the numeric value of <digit> as the register number.  */
    #####: 8650:        case duplicate:
        -: 8651:	  {
        -: 8652:	    register const char *d2, *dend2;
    #####: 8653:	    int regno = *p++;   /* Get which register to match against.  */
        -: 8654:	    DEBUG_PRINT2 ("EXECUTING duplicate %d.\n", regno);
        -: 8655:
        -: 8656:	    /* Can't back reference a group which we've never matched.  */
    #####: 8657:            if (REG_UNSET (regstart[regno]) || REG_UNSET (regend[regno]))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 8658:              goto fail;
        -: 8659:
        -: 8660:            /* Where in input to try to start matching.  */
    #####: 8661:            d2 = regstart[regno];
        -: 8662:
        -: 8663:            /* Where to stop matching; if both the place to start and
        -: 8664:               the place to stop matching are in the same string, then
        -: 8665:               set to the place to stop, otherwise, for now have to use
        -: 8666:               the end of the first string.  */
        -: 8667:
    #####: 8668:            dend2 = ((FIRST_STRING_P (regstart[regno])
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 8669:		      == FIRST_STRING_P (regend[regno]))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 8670:		     ? regend[regno] : end_match_1);
branch  0 never executed
branch  1 never executed
        -: 8671:	    for (;;)
        -: 8672:	      {
        -: 8673:		/* If necessary, advance to next segment in register
        -: 8674:                   contents.  */
    #####: 8675:		while (d2 == dend2)
branch  0 never executed
branch  1 never executed
        -: 8676:		  {
    #####: 8677:		    if (dend2 == end_match_2) break;
branch  0 never executed
branch  1 never executed
    #####: 8678:		    if (dend2 == regend[regno]) break;
branch  0 never executed
branch  1 never executed
        -: 8679:
        -: 8680:                    /* End of string1 => advance to string2. */
    #####: 8681:                    d2 = string2;
    #####: 8682:                    dend2 = regend[regno];
        -: 8683:		  }
        -: 8684:		/* At end of register contents => success */
    #####: 8685:		if (d2 == dend2) break;
branch  0 never executed
branch  1 never executed
        -: 8686:
        -: 8687:		/* If necessary, advance to next segment in data.  */
    #####: 8688:		PREFETCH ();
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 8689:
        -: 8690:		/* How many characters left in this segment to match.  */
    #####: 8691:		mcnt = dend - d;
        -: 8692:
        -: 8693:		/* Want how many consecutive characters we can match in
        -: 8694:                   one shot, so, if necessary, adjust the count.  */
    #####: 8695:                if (mcnt > dend2 - d2)
branch  0 never executed
branch  1 never executed
    #####: 8696:		  mcnt = dend2 - d2;
        -: 8697:
        -: 8698:		/* Compare that many; failure if mismatch, else move
        -: 8699:                   past them.  */
    #####: 8700:		if (translate
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 8701:                    ? bcmp_translate (d, d2, mcnt, translate)
call    0 never executed
    #####: 8702:                    : memcmp (d, d2, mcnt))
    #####: 8703:		  goto fail;
    #####: 8704:		d += mcnt, d2 += mcnt;
        -: 8705:
        -: 8706:		/* Do this because we've match some characters.  */
    #####: 8707:		SET_REGS_MATCHED ();
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 8708:	      }
        -: 8709:	  }
    #####: 8710:	  break;
        -: 8711:
        -: 8712:
        -: 8713:        /* begline matches the empty string at the beginning of the string
        -: 8714:           (unless `not_bol' is set in `bufp'), and, if
        -: 8715:           `newline_anchor' is set, after newlines.  */
   167770: 8716:	case begline:
        -: 8717:          DEBUG_PRINT1 ("EXECUTING begline.\n");
        -: 8718:
  167770*: 8719:          if (AT_STRINGS_BEG (d))
branch  0 taken 0 (fallthrough)
branch  1 taken 167770
branch  2 taken 156413 (fallthrough)
branch  3 taken 11357
branch  4 taken 0 (fallthrough)
branch  5 taken 156413
        -: 8720:            {
    11357: 8721:              if (!bufp->not_bol) break;
branch  0 taken 10822 (fallthrough)
branch  1 taken 535
        -: 8722:            }
   156413: 8723:          else if (d[-1] == '\n' && bufp->newline_anchor)
branch  0 taken 635 (fallthrough)
branch  1 taken 155778
branch  2 taken 0 (fallthrough)
branch  3 taken 635
        -: 8724:            {
    #####: 8725:              break;
        -: 8726:            }
        -: 8727:          /* In all other cases, we fail.  */
   156948: 8728:          goto fail;
        -: 8729:
        -: 8730:
        -: 8731:        /* endline is the dual of begline.  */
     6843: 8732:	case endline:
        -: 8733:          DEBUG_PRINT1 ("EXECUTING endline.\n");
        -: 8734:
     6843: 8735:          if (AT_STRINGS_END (d))
branch  0 taken 1161 (fallthrough)
branch  1 taken 5682
        -: 8736:            {
     1161: 8737:              if (!bufp->not_eol) break;
branch  0 taken 1161 (fallthrough)
branch  1 taken 0
        -: 8738:            }
        -: 8739:
        -: 8740:          /* We have to ``prefetch'' the next character.  */
    5682*: 8741:          else if ((d == end1 ? *string2 : *d) == '\n'
branch  0 taken 0 (fallthrough)
branch  1 taken 5682
branch  2 taken 81 (fallthrough)
branch  3 taken 5601
       81: 8742:                   && bufp->newline_anchor)
branch  0 taken 0 (fallthrough)
branch  1 taken 81
        -: 8743:            {
    #####: 8744:              break;
        -: 8745:            }
     5682: 8746:          goto fail;
        -: 8747:
        -: 8748:
        -: 8749:	/* Match at the very beginning of the data.  */
    #####: 8750:        case begbuf:
        -: 8751:          DEBUG_PRINT1 ("EXECUTING begbuf.\n");
    #####: 8752:          if (AT_STRINGS_BEG (d))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 8753:            break;
    #####: 8754:          goto fail;
        -: 8755:
        -: 8756:
        -: 8757:	/* Match at the very end of the data.  */
    #####: 8758:        case endbuf:
        -: 8759:          DEBUG_PRINT1 ("EXECUTING endbuf.\n");
    #####: 8760:	  if (AT_STRINGS_END (d))
branch  0 never executed
branch  1 never executed
    #####: 8761:	    break;
    #####: 8762:          goto fail;
        -: 8763:
        -: 8764:
        -: 8765:        /* on_failure_keep_string_jump is used to optimize `.*\n'.  It
        -: 8766:           pushes NULL as the value for the string on the stack.  Then
        -: 8767:           `pop_failure_point' will keep the current value for the
        -: 8768:           string, instead of restoring it.  To see why, consider
        -: 8769:           matching `foo\nbar' against `.*\n'.  The .* matches the foo;
        -: 8770:           then the . fails against the \n.  But the next thing we want
        -: 8771:           to do is match the \n against the \n; if we restored the
        -: 8772:           string value, we would be back at the foo.
        -: 8773:
        -: 8774:           Because this is used only in specific cases, we don't need to
        -: 8775:           check all the things that `on_failure_jump' does, to make
        -: 8776:           sure the right things get saved on the stack.  Hence we don't
        -: 8777:           share its code.  The only reason to push anything on the
        -: 8778:           stack at all is that otherwise we would have to change
        -: 8779:           `anychar's code to do something besides goto fail in this
        -: 8780:           case; that seems worse than this.  */
    #####: 8781:        case on_failure_keep_string_jump:
        -: 8782:          DEBUG_PRINT1 ("EXECUTING on_failure_keep_string_jump");
        -: 8783:
    #####: 8784:          EXTRACT_NUMBER_AND_INCR (mcnt, p);
        -: 8785:#ifdef _LIBC
        -: 8786:          DEBUG_PRINT3 (" %d (to %p):\n", mcnt, p + mcnt);
        -: 8787:#else
        -: 8788:          DEBUG_PRINT3 (" %d (to 0x%x):\n", mcnt, p + mcnt);
        -: 8789:#endif
        -: 8790:
    #####: 8791:          PUSH_FAILURE_POINT (p + mcnt, NULL, -2);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####: 8792:          break;
        -: 8793:
        -: 8794:
        -: 8795:	/* Uses of on_failure_jump:
        -: 8796:
        -: 8797:           Each alternative starts with an on_failure_jump that points
        -: 8798:           to the beginning of the next alternative.  Each alternative
        -: 8799:           except the last ends with a jump that in effect jumps past
        -: 8800:           the rest of the alternatives.  (They really jump to the
        -: 8801:           ending jump of the following alternative, because tensioning
        -: 8802:           these jumps is a hassle.)
        -: 8803:
        -: 8804:           Repeats start with an on_failure_jump that points past both
        -: 8805:           the repetition text and either the following jump or
        -: 8806:           pop_failure_jump back to this on_failure_jump.  */
        -: 8807:	case on_failure_jump:
   413414: 8808:        on_failure:
        -: 8809:          DEBUG_PRINT1 ("EXECUTING on_failure_jump");
        -: 8810:
   413414: 8811:          EXTRACT_NUMBER_AND_INCR (mcnt, p);
        -: 8812:#ifdef _LIBC
        -: 8813:          DEBUG_PRINT3 (" %d (to %p)", mcnt, p + mcnt);
        -: 8814:#else
        -: 8815:          DEBUG_PRINT3 (" %d (to 0x%x)", mcnt, p + mcnt);
        -: 8816:#endif
        -: 8817:
        -: 8818:          /* If this on_failure_jump comes right before a group (i.e.,
        -: 8819:             the original * applied to a group), save the information
        -: 8820:             for that group and all inner ones, so that if we fail back
        -: 8821:             to this point, the group's information will be correct.
        -: 8822:             For example, in \(a*\)*\1, we need the preceding group,
        -: 8823:             and in \(zz\(a*\)b*\)\2, we need the inner group.  */
        -: 8824:
        -: 8825:          /* We can't use `p' to check ahead because we push
        -: 8826:             a failure point to `p + mcnt' after we do this.  */
   413414: 8827:          p1 = p;
        -: 8828:
        -: 8829:          /* We need to skip no_op's before we look for the
        -: 8830:             start_memory in case this on_failure_jump is happening as
        -: 8831:             the result of a completed succeed_n, as in \(a\)\{1,3\}b\1
        -: 8832:             against aba.  */
   413558: 8833:          while (p1 < pend && (re_opcode_t) *p1 == no_op)
branch  0 taken 413558 (fallthrough)
branch  1 taken 0
branch  2 taken 144
branch  3 taken 413414 (fallthrough)
      144: 8834:            p1++;
        -: 8835:
   413414: 8836:          if (p1 < pend && (re_opcode_t) *p1 == start_memory)
branch  0 taken 413414 (fallthrough)
branch  1 taken 0
branch  2 taken 1715 (fallthrough)
branch  3 taken 411699
        -: 8837:            {
        -: 8838:              /* We have a new highest active register now.  This will
        -: 8839:                 get reset at the start_memory we are about to get to,
        -: 8840:                 but we will have saved all the registers relevant to
        -: 8841:                 this repetition op, as described above.  */
     1715: 8842:              highest_active_reg = *(p1 + 1) + *(p1 + 2);
     1715: 8843:              if (lowest_active_reg == NO_LOWEST_ACTIVE_REG)
branch  0 taken 1715 (fallthrough)
branch  1 taken 0
     1715: 8844:                lowest_active_reg = *(p1 + 1);
        -: 8845:            }
        -: 8846:
        -: 8847:          DEBUG_PRINT1 (":\n");
  514482*: 8848:          PUSH_FAILURE_POINT (p + mcnt, d, -2);
branch  0 taken 98944 (fallthrough)
branch  1 taken 0
branch  2 taken 98944 (fallthrough)
branch  3 taken 0
branch  4 taken 0 (fallthrough)
branch  5 taken 98944
branch  6 taken 98944
branch  7 taken 413414 (fallthrough)
branch  8 taken 2124
branch  9 taken 413414 (fallthrough)
   413414: 8849:          break;
        -: 8850:
        -: 8851:
        -: 8852:        /* A smart repeat ends with `maybe_pop_jump'.
        -: 8853:	   We change it to either `pop_failure_jump' or `jump'.  */
      117: 8854:        case maybe_pop_jump:
      117: 8855:          EXTRACT_NUMBER_AND_INCR (mcnt, p);
        -: 8856:          DEBUG_PRINT2 ("EXECUTING maybe_pop_jump %d.\n", mcnt);
        -: 8857:          {
      117: 8858:	    register unsigned char *p2 = p;
        -: 8859:
        -: 8860:            /* Compare the beginning of the repeat with what in the
        -: 8861:               pattern follows its end. If we can establish that there
        -: 8862:               is nothing that they would both match, i.e., that we
        -: 8863:               would have to backtrack because of (as in, e.g., `a*a')
        -: 8864:               then we can change to pop_failure_jump, because we'll
        -: 8865:               never have to backtrack.
        -: 8866:
        -: 8867:               This is not true in the case of alternatives: in
        -: 8868:               `(a|ab)*' we do need to backtrack to the `ab' alternative
        -: 8869:               (e.g., if the string was `ab').  But instead of trying to
        -: 8870:               detect that here, the alternative has put on a dummy
        -: 8871:               failure point which is what we will end up popping.  */
        -: 8872:
        -: 8873:	    /* Skip over open/close-group commands.
        -: 8874:	       If what follows this loop is a ...+ construct,
        -: 8875:	       look at what begins its body, since we will have to
        -: 8876:	       match at least one of that.  */
        -: 8877:	    while (1)
        -: 8878:	      {
      129: 8879:		if (p2 + 2 < pend
branch  0 taken 67 (fallthrough)
branch  1 taken 62
       67: 8880:		    && ((re_opcode_t) *p2 == stop_memory
branch  0 taken 55 (fallthrough)
branch  1 taken 12
       55: 8881:			|| (re_opcode_t) *p2 == start_memory))
branch  0 taken 0 (fallthrough)
branch  1 taken 55
       12: 8882:		  p2 += 3;
      117: 8883:		else if (p2 + 6 < pend
branch  0 taken 36 (fallthrough)
branch  1 taken 81
       36: 8884:			 && (re_opcode_t) *p2 == dummy_failure_jump)
branch  0 taken 0 (fallthrough)
branch  1 taken 36
    #####: 8885:		  p2 += 6;
        -: 8886:		else
        -: 8887:		  break;
        -: 8888:	      }
        -: 8889:
      117: 8890:	    p1 = p + mcnt;
        -: 8891:	    /* p1[0] ... p1[2] are the `on_failure_jump' corresponding
        -: 8892:	       to the `maybe_finalize_jump' of this case.  Examine what
        -: 8893:	       follows.  */
        -: 8894:
        -: 8895:            /* If we're at the end of the pattern, we can change.  */
      117: 8896:            if (p2 == pend)
branch  0 taken 61 (fallthrough)
branch  1 taken 56
        -: 8897:	      {
        -: 8898:		/* Consider what happens when matching ":\(.*\)"
        -: 8899:		   against ":/".  I don't really understand this code
        -: 8900:		   yet.  */
       61: 8901:  	        p[-3] = (unsigned char) pop_failure_jump;
        -: 8902:                DEBUG_PRINT1
        -: 8903:                  ("  End of pattern: change to `pop_failure_jump'.\n");
        -: 8904:              }
        -: 8905:
       56: 8906:            else if ((re_opcode_t) *p2 == exactn
branch  0 taken 1 (fallthrough)
branch  1 taken 55
       1*: 8907:		     || (bufp->newline_anchor && (re_opcode_t) *p2 == endline))
branch  0 taken 0 (fallthrough)
branch  1 taken 1
branch  2 never executed
branch  3 never executed
       55: 8908:	      {
      55*: 8909:		register unsigned char c
       55: 8910:                  = *p2 == (unsigned char) endline ? '\n' : p2[2];
branch  0 taken 55 (fallthrough)
branch  1 taken 0
        -: 8911:
      55*: 8912:                if ((re_opcode_t) p1[3] == exactn && p1[5] != c)
branch  0 taken 0 (fallthrough)
branch  1 taken 55
branch  2 never executed
branch  3 never executed
        -: 8913:                  {
    #####: 8914:  		    p[-3] = (unsigned char) pop_failure_jump;
        -: 8915:                    DEBUG_PRINT3 ("  %c != %c => pop_failure_jump.\n",
        -: 8916:                                  c, p1[5]);
        -: 8917:                  }
        -: 8918:
       55: 8919:		else if ((re_opcode_t) p1[3] == charset
branch  0 taken 55 (fallthrough)
branch  1 taken 0
       55: 8920:			 || (re_opcode_t) p1[3] == charset_not)
branch  0 taken 0 (fallthrough)
branch  1 taken 55
        -: 8921:		  {
    #####: 8922:		    int not = (re_opcode_t) p1[3] == charset_not;
        -: 8923:
    #####: 8924:		    if (c < (unsigned char) (p1[4] * BYTEWIDTH)
branch  0 never executed
branch  1 never executed
    #####: 8925:			&& p1[5 + c / BYTEWIDTH] & (1 << (c % BYTEWIDTH)))
branch  0 never executed
branch  1 never executed
    #####: 8926:		      not = !not;
        -: 8927:
        -: 8928:                    /* `not' is equal to 1 if c would match, which means
        -: 8929:                        that we can't change to pop_failure_jump.  */
    #####: 8930:		    if (!not)
branch  0 never executed
branch  1 never executed
        -: 8931:                      {
    #####: 8932:  		        p[-3] = (unsigned char) pop_failure_jump;
        -: 8933:                        DEBUG_PRINT1 ("  No match => pop_failure_jump.\n");
        -: 8934:                      }
        -: 8935:		  }
        -: 8936:	      }
        1: 8937:            else if ((re_opcode_t) *p2 == charset)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -: 8938:	      {
        -: 8939:#ifdef DEBUG
        -: 8940:		register unsigned char c
        -: 8941:                  = *p2 == (unsigned char) endline ? '\n' : p2[2];
        -: 8942:#endif
        -: 8943:
        -: 8944:#if 0
        -: 8945:                if ((re_opcode_t) p1[3] == exactn
        -: 8946:		    && ! ((int) p2[1] * BYTEWIDTH > (int) p1[5]
        -: 8947:			  && (p2[2 + p1[5] / BYTEWIDTH]
        -: 8948:			      & (1 << (p1[5] % BYTEWIDTH)))))
        -: 8949:#else
    #####: 8950:                if ((re_opcode_t) p1[3] == exactn
branch  0 never executed
branch  1 never executed
    #####: 8951:		    && ! ((int) p2[1] * BYTEWIDTH > (int) p1[4]
branch  0 never executed
branch  1 never executed
    #####: 8952:			  && (p2[2 + p1[4] / BYTEWIDTH]
    #####: 8953:			      & (1 << (p1[4] % BYTEWIDTH)))))
branch  0 never executed
branch  1 never executed
        -: 8954:#endif
        -: 8955:                  {
    #####: 8956:  		    p[-3] = (unsigned char) pop_failure_jump;
        -: 8957:                    DEBUG_PRINT3 ("  %c != %c => pop_failure_jump.\n",
        -: 8958:                                  c, p1[5]);
        -: 8959:                  }
        -: 8960:
    #####: 8961:		else if ((re_opcode_t) p1[3] == charset_not)
branch  0 never executed
branch  1 never executed
        -: 8962:		  {
        -: 8963:		    int idx;
        -: 8964:		    /* We win if the charset_not inside the loop
        -: 8965:		       lists every character listed in the charset after.  */
    #####: 8966:		    for (idx = 0; idx < (int) p2[1]; idx++)
branch  0 never executed
branch  1 never executed
    #####: 8967:		      if (! (p2[2 + idx] == 0
branch  0 never executed
branch  1 never executed
    #####: 8968:			     || (idx < (int) p1[4]
branch  0 never executed
branch  1 never executed
    #####: 8969:				 && ((p2[2 + idx] & ~ p1[5 + idx]) == 0))))
branch  0 never executed
branch  1 never executed
        -: 8970:			break;
        -: 8971:
    #####: 8972:		    if (idx == p2[1])
branch  0 never executed
branch  1 never executed
        -: 8973:                      {
    #####: 8974:  		        p[-3] = (unsigned char) pop_failure_jump;
        -: 8975:                        DEBUG_PRINT1 ("  No match => pop_failure_jump.\n");
        -: 8976:                      }
        -: 8977:		  }
    #####: 8978:		else if ((re_opcode_t) p1[3] == charset)
branch  0 never executed
branch  1 never executed
        -: 8979:		  {
        -: 8980:		    int idx;
        -: 8981:		    /* We win if the charset inside the loop
        -: 8982:		       has no overlap with the one after the loop.  */
    #####: 8983:		    for (idx = 0;
    #####: 8984:			 idx < (int) p2[1] && idx < (int) p1[4];
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 8985:			 idx++)
    #####: 8986:		      if ((p2[2 + idx] & p1[5 + idx]) != 0)
branch  0 never executed
branch  1 never executed
    #####: 8987:			break;
        -: 8988:
    #####: 8989:		    if (idx == p2[1] || idx == p1[4])
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 8990:                      {
    #####: 8991:  		        p[-3] = (unsigned char) pop_failure_jump;
        -: 8992:                        DEBUG_PRINT1 ("  No match => pop_failure_jump.\n");
        -: 8993:                      }
        -: 8994:		  }
        -: 8995:	      }
        -: 8996:	  }
      117: 8997:	  p -= 2;		/* Point at relative address again.  */
      117: 8998:	  if ((re_opcode_t) p[-1] != pop_failure_jump)
branch  0 taken 56 (fallthrough)
branch  1 taken 61
        -: 8999:	    {
       56: 9000:	      p[-1] = (unsigned char) jump;
        -: 9001:              DEBUG_PRINT1 ("  Match => jump.\n");
       56: 9002:	      goto unconditional_jump;
        -: 9003:	    }
        -: 9004:        /* Note fall through.  */
        -: 9005:
        -: 9006:
        -: 9007:	/* The end of a simple repeat has a pop_failure_jump back to
        -: 9008:           its matching on_failure_jump, where the latter will push a
        -: 9009:           failure point.  The pop_failure_jump takes off failure
        -: 9010:           points put on by this pop_failure_jump's matching
        -: 9011:           on_failure_jump; we got through the pattern to here from the
        -: 9012:           matching on_failure_jump, so didn't fail.  */
        -: 9013:        case pop_failure_jump:
        -: 9014:          {
        -: 9015:            /* We need to pass separate storage for the lowest and
        -: 9016:               highest registers, even though we don't care about the
        -: 9017:               actual values.  Otherwise, we will restore only one
        -: 9018:               register from the stack, since lowest will == highest in
        -: 9019:               `pop_failure_point'.  */
        -: 9020:            active_reg_t dummy_low_reg, dummy_high_reg;
        -: 9021:            unsigned char *pdummy;
        -: 9022:            const char *sdummy;
        -: 9023:
        -: 9024:            DEBUG_PRINT1 ("EXECUTING pop_failure_jump.\n");
   13094*: 9025:            POP_FAILURE_POINT (sdummy, pdummy,
branch  0 taken 13094 (fallthrough)
branch  1 taken 0
branch  2 taken 0
branch  3 taken 13094 (fallthrough)
        -: 9026:                               dummy_low_reg, dummy_high_reg,
        -: 9027:                               reg_dummy, reg_dummy, reg_info_dummy);
        -: 9028:          }
        -: 9029:	  /* Note fall through.  */
        -: 9030:
    13228: 9031:	unconditional_jump:
        -: 9032:#ifdef _LIBC
        -: 9033:	  DEBUG_PRINT2 ("\n%p: ", p);
        -: 9034:#else
        -: 9035:	  DEBUG_PRINT2 ("\n0x%x: ", p);
        -: 9036:#endif
        -: 9037:          /* Note fall through.  */
        -: 9038:
        -: 9039:        /* Unconditionally jump (without popping any failure points).  */
   381432: 9040:        case jump:
   381432: 9041:	  EXTRACT_NUMBER_AND_INCR (mcnt, p);	/* Get the amount to jump.  */
        -: 9042:          DEBUG_PRINT2 ("EXECUTING jump %d ", mcnt);
   381432: 9043:	  p += mcnt;				/* Do the jump.  */
        -: 9044:#ifdef _LIBC
        -: 9045:          DEBUG_PRINT2 ("(to %p).\n", p);
        -: 9046:#else
        -: 9047:          DEBUG_PRINT2 ("(to 0x%x).\n", p);
        -: 9048:#endif
   381432: 9049:	  break;
        -: 9050:
        -: 9051:
        -: 9052:        /* We need this opcode so we can detect where alternatives end
        -: 9053:           in `group_match_null_string_p' et al.  */
        6: 9054:        case jump_past_alt:
        -: 9055:          DEBUG_PRINT1 ("EXECUTING jump_past_alt.\n");
        6: 9056:          goto unconditional_jump;
        -: 9057:
        -: 9058:
        -: 9059:        /* Normally, the on_failure_jump pushes a failure point, which
        -: 9060:           then gets popped at pop_failure_jump.  We will end up at
        -: 9061:           pop_failure_jump, also, and with a pattern of, say, `a+', we
        -: 9062:           are skipping over the on_failure_jump, so we have to push
        -: 9063:           something meaningless for pop_failure_jump to pop.  */
    #####: 9064:        case dummy_failure_jump:
        -: 9065:          DEBUG_PRINT1 ("EXECUTING dummy_failure_jump.\n");
        -: 9066:          /* It doesn't matter what we push for the string here.  What
        -: 9067:             the code at `fail' tests is the value for the pattern.  */
    #####: 9068:          PUSH_FAILURE_POINT (NULL, NULL, -2);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####: 9069:          goto unconditional_jump;
        -: 9070:
        -: 9071:
        -: 9072:        /* At the end of an alternative, we need to push a dummy failure
        -: 9073:           point in case we are followed by a `pop_failure_jump', because
        -: 9074:           we don't want the failure point for the alternative to be
        -: 9075:           popped.  For example, matching `(a|ab)*' against `aab'
        -: 9076:           requires that we match the `ab' alternative.  */
    #####: 9077:        case push_dummy_failure:
        -: 9078:          DEBUG_PRINT1 ("EXECUTING push_dummy_failure.\n");
        -: 9079:          /* See comments just above at `dummy_failure_jump' about the
        -: 9080:             two zeroes.  */
    #####: 9081:          PUSH_FAILURE_POINT (NULL, NULL, -2);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####: 9082:          break;
        -: 9083:
        -: 9084:        /* Have to succeed matching what follows at least n times.
        -: 9085:           After that, handle like `on_failure_jump'.  */
     1807: 9086:        case succeed_n:
     1807: 9087:          EXTRACT_NUMBER (mcnt, p + 2);
        -: 9088:          DEBUG_PRINT2 ("EXECUTING succeed_n %d.\n", mcnt);
        -: 9089:
        -: 9090:          assert (mcnt >= 0);
        -: 9091:          /* Originally, this is how many times we HAVE to succeed.  */
     1807: 9092:          if (mcnt > 0)
branch  0 taken 1735 (fallthrough)
branch  1 taken 72
        -: 9093:            {
     1735: 9094:               mcnt--;
     1735: 9095:	       p += 2;
     1735: 9096:               STORE_NUMBER_AND_INCR (p, mcnt);
        -: 9097:#ifdef _LIBC
        -: 9098:               DEBUG_PRINT3 ("  Setting %p to %d.\n", p - 2, mcnt);
        -: 9099:#else
        -: 9100:               DEBUG_PRINT3 ("  Setting 0x%x to %d.\n", p - 2, mcnt);
        -: 9101:#endif
        -: 9102:            }
       72: 9103:	  else if (mcnt == 0)
branch  0 taken 72 (fallthrough)
branch  1 taken 0
        -: 9104:            {
        -: 9105:#ifdef _LIBC
        -: 9106:              DEBUG_PRINT2 ("  Setting two bytes from %p to no_op.\n", p+2);
        -: 9107:#else
        -: 9108:              DEBUG_PRINT2 ("  Setting two bytes from 0x%x to no_op.\n", p+2);
        -: 9109:#endif
       72: 9110:	      p[2] = (unsigned char) no_op;
       72: 9111:              p[3] = (unsigned char) no_op;
       72: 9112:              goto on_failure;
        -: 9113:            }
     1735: 9114:          break;
        -: 9115:
       78: 9116:        case jump_n:
       78: 9117:          EXTRACT_NUMBER (mcnt, p + 2);
        -: 9118:          DEBUG_PRINT2 ("EXECUTING jump_n %d.\n", mcnt);
        -: 9119:
        -: 9120:          /* Originally, this is how many times we CAN jump.  */
       78: 9121:          if (mcnt)
branch  0 taken 72 (fallthrough)
branch  1 taken 6
        -: 9122:            {
       72: 9123:               mcnt--;
       72: 9124:               STORE_NUMBER (p + 2, mcnt);
        -: 9125:#ifdef _LIBC
        -: 9126:               DEBUG_PRINT3 ("  Setting %p to %d.\n", p + 2, mcnt);
        -: 9127:#else
        -: 9128:               DEBUG_PRINT3 ("  Setting 0x%x to %d.\n", p + 2, mcnt);
        -: 9129:#endif
       72: 9130:	       goto unconditional_jump;
        -: 9131:            }
        -: 9132:          /* If don't have to jump any more, skip over the rest of command.  */
        -: 9133:	  else
        6: 9134:	    p += 4;
        6: 9135:          break;
        -: 9136:
     3470: 9137:	case set_number_at:
        -: 9138:	  {
        -: 9139:            DEBUG_PRINT1 ("EXECUTING set_number_at.\n");
        -: 9140:
     3470: 9141:            EXTRACT_NUMBER_AND_INCR (mcnt, p);
     3470: 9142:            p1 = p + mcnt;
     3470: 9143:            EXTRACT_NUMBER_AND_INCR (mcnt, p);
        -: 9144:#ifdef _LIBC
        -: 9145:            DEBUG_PRINT3 ("  Setting %p to %d.\n", p1, mcnt);
        -: 9146:#else
        -: 9147:            DEBUG_PRINT3 ("  Setting 0x%x to %d.\n", p1, mcnt);
        -: 9148:#endif
     3470: 9149:	    STORE_NUMBER (p1, mcnt);
     3470: 9150:            break;
        -: 9151:          }
        -: 9152:
        -: 9153:#if 0
        -: 9154:	/* The DEC Alpha C compiler 3.x generates incorrect code for the
        -: 9155:	   test  WORDCHAR_P (d - 1) != WORDCHAR_P (d)  in the expansion of
        -: 9156:	   AT_WORD_BOUNDARY, so this code is disabled.  Expanding the
        -: 9157:	   macro and introducing temporary variables works around the bug.  */
        -: 9158:
        -: 9159:	case wordbound:
        -: 9160:	  DEBUG_PRINT1 ("EXECUTING wordbound.\n");
        -: 9161:	  if (AT_WORD_BOUNDARY (d))
        -: 9162:	    break;
        -: 9163:	  goto fail;
        -: 9164:
        -: 9165:	case notwordbound:
        -: 9166:	  DEBUG_PRINT1 ("EXECUTING notwordbound.\n");
        -: 9167:	  if (AT_WORD_BOUNDARY (d))
        -: 9168:	    goto fail;
        -: 9169:	  break;
        -: 9170:#else
    #####: 9171:	case wordbound:
        -: 9172:	{
        -: 9173:	  boolean prevchar, thischar;
        -: 9174:
        -: 9175:	  DEBUG_PRINT1 ("EXECUTING wordbound.\n");
    #####: 9176:	  if (AT_STRINGS_BEG (d) || AT_STRINGS_END (d))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -: 9177:	    break;
        -: 9178:
    #####: 9179:	  prevchar = WORDCHAR_P (d - 1);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 9180:	  thischar = WORDCHAR_P (d);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 9181:	  if (prevchar != thischar)
branch  0 never executed
branch  1 never executed
    #####: 9182:	    break;
    #####: 9183:	  goto fail;
        -: 9184:	}
        -: 9185:
    #####: 9186:      case notwordbound:
        -: 9187:	{
        -: 9188:	  boolean prevchar, thischar;
        -: 9189:
        -: 9190:	  DEBUG_PRINT1 ("EXECUTING notwordbound.\n");
    #####: 9191:	  if (AT_STRINGS_BEG (d) || AT_STRINGS_END (d))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####: 9192:	    goto fail;
        -: 9193:
    #####: 9194:	  prevchar = WORDCHAR_P (d - 1);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 9195:	  thischar = WORDCHAR_P (d);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 9196:	  if (prevchar != thischar)
branch  0 never executed
branch  1 never executed
    #####: 9197:	    goto fail;
    #####: 9198:	  break;
        -: 9199:	}
        -: 9200:#endif
        -: 9201:
    #####: 9202:	case wordbeg:
        -: 9203:          DEBUG_PRINT1 ("EXECUTING wordbeg.\n");
    #####: 9204:	  if (WORDCHAR_P (d) && (AT_STRINGS_BEG (d) || !WORDCHAR_P (d - 1)))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
        -: 9205:	    break;
    #####: 9206:          goto fail;
        -: 9207:
    #####: 9208:	case wordend:
        -: 9209:          DEBUG_PRINT1 ("EXECUTING wordend.\n");
    #####: 9210:	  if (!AT_STRINGS_BEG (d) && WORDCHAR_P (d - 1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
    #####: 9211:              && (!WORDCHAR_P (d) || AT_STRINGS_END (d)))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -: 9212:	    break;
    #####: 9213:          goto fail;
        -: 9214:
        -: 9215:#ifdef emacs
        -: 9216:  	case before_dot:
        -: 9217:          DEBUG_PRINT1 ("EXECUTING before_dot.\n");
        -: 9218: 	  if (PTR_CHAR_POS ((unsigned char *) d) >= point)
        -: 9219:  	    goto fail;
        -: 9220:  	  break;
        -: 9221:
        -: 9222:  	case at_dot:
        -: 9223:          DEBUG_PRINT1 ("EXECUTING at_dot.\n");
        -: 9224: 	  if (PTR_CHAR_POS ((unsigned char *) d) != point)
        -: 9225:  	    goto fail;
        -: 9226:  	  break;
        -: 9227:
        -: 9228:  	case after_dot:
        -: 9229:          DEBUG_PRINT1 ("EXECUTING after_dot.\n");
        -: 9230:          if (PTR_CHAR_POS ((unsigned char *) d) <= point)
        -: 9231:  	    goto fail;
        -: 9232:  	  break;
        -: 9233:
        -: 9234:	case syntaxspec:
        -: 9235:          DEBUG_PRINT2 ("EXECUTING syntaxspec %d.\n", mcnt);
        -: 9236:	  mcnt = *p++;
        -: 9237:	  goto matchsyntax;
        -: 9238:
        -: 9239:        case wordchar:
        -: 9240:          DEBUG_PRINT1 ("EXECUTING Emacs wordchar.\n");
        -: 9241:	  mcnt = (int) Sword;
        -: 9242:        matchsyntax:
        -: 9243:	  PREFETCH ();
        -: 9244:	  /* Can't use *d++ here; SYNTAX may be an unsafe macro.  */
        -: 9245:	  d++;
        -: 9246:	  if (SYNTAX (d[-1]) != (enum syntaxcode) mcnt)
        -: 9247:	    goto fail;
        -: 9248:          SET_REGS_MATCHED ();
        -: 9249:	  break;
        -: 9250:
        -: 9251:	case notsyntaxspec:
        -: 9252:          DEBUG_PRINT2 ("EXECUTING notsyntaxspec %d.\n", mcnt);
        -: 9253:	  mcnt = *p++;
        -: 9254:	  goto matchnotsyntax;
        -: 9255:
        -: 9256:        case notwordchar:
        -: 9257:          DEBUG_PRINT1 ("EXECUTING Emacs notwordchar.\n");
        -: 9258:	  mcnt = (int) Sword;
        -: 9259:        matchnotsyntax:
        -: 9260:	  PREFETCH ();
        -: 9261:	  /* Can't use *d++ here; SYNTAX may be an unsafe macro.  */
        -: 9262:	  d++;
        -: 9263:	  if (SYNTAX (d[-1]) == (enum syntaxcode) mcnt)
        -: 9264:	    goto fail;
        -: 9265:	  SET_REGS_MATCHED ();
        -: 9266:          break;
        -: 9267:
        -: 9268:#else /* not emacs */
    #####: 9269:	case wordchar:
        -: 9270:          DEBUG_PRINT1 ("EXECUTING non-Emacs wordchar.\n");
    #####: 9271:	  PREFETCH ();
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 9272:          if (!WORDCHAR_P (d))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 9273:            goto fail;
    #####: 9274:	  SET_REGS_MATCHED ();
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 9275:          d++;
    #####: 9276:	  break;
        -: 9277:
    #####: 9278:	case notwordchar:
        -: 9279:          DEBUG_PRINT1 ("EXECUTING non-Emacs notwordchar.\n");
    #####: 9280:	  PREFETCH ();
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 9281:	  if (WORDCHAR_P (d))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 9282:            goto fail;
    #####: 9283:          SET_REGS_MATCHED ();
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 9284:          d++;
    #####: 9285:	  break;
        -: 9286:#endif /* not emacs */
        -: 9287:
    #####: 9288:        default:
    #####: 9289:          abort ();
call    0 never executed
        -: 9290:	}
  1206370: 9291:      continue;  /* Successfully executed one pattern command; keep going.  */
        -: 9292:
        -: 9293:
        -: 9294:    /* We goto here if a matching operation fails. */
  1049328: 9295:    fail:
  1049328: 9296:      if (!FAIL_STACK_EMPTY ())
branch  0 taken 390933 (fallthrough)
branch  1 taken 658395
        -: 9297:	{ /* A restart point is known.  Restore to that state.  */
        -: 9298:          DEBUG_PRINT1 ("\nFAIL:\n");
   392905: 9299:          POP_FAILURE_POINT (d, p,
branch  0 taken 390933 (fallthrough)
branch  1 taken 0
branch  2 taken 1972
branch  3 taken 390933 (fallthrough)
        -: 9300:                             lowest_active_reg, highest_active_reg,
        -: 9301:                             regstart, regend, reg_info);
        -: 9302:
        -: 9303:          /* If this failure point is a dummy, try the next one.  */
   390933: 9304:          if (!p)
branch  0 taken 0 (fallthrough)
branch  1 taken 390933
    #####: 9305:	    goto fail;
        -: 9306:
        -: 9307:          /* If we failed to the end of the pattern, don't examine *p.  */
        -: 9308:	  assert (p <= pend);
   390933: 9309:          if (p < pend)
branch  0 taken 931 (fallthrough)
branch  1 taken 390002
        -: 9310:            {
   390002: 9311:              boolean is_a_jump_n = false;
        -: 9312:
        -: 9313:              /* If failed to a backwards jump that's part of a repetition
        -: 9314:                 loop, need to pop this failure point and use the next one.  */
   390002: 9315:              switch ((re_opcode_t) *p)
branch  0 taken 0
branch  1 taken 0
branch  2 taken 390002
        -: 9316:                {
    #####: 9317:                case jump_n:
    #####: 9318:                  is_a_jump_n = true;
    #####: 9319:                case maybe_pop_jump:
        -: 9320:                case pop_failure_jump:
        -: 9321:                case jump:
    #####: 9322:                  p1 = p + 1;
    #####: 9323:                  EXTRACT_NUMBER_AND_INCR (mcnt, p1);
    #####: 9324:                  p1 += mcnt;
        -: 9325:
    #####: 9326:                  if ((is_a_jump_n && (re_opcode_t) *p1 == succeed_n)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 9327:                      || (!is_a_jump_n
branch  0 never executed
branch  1 never executed
    #####: 9328:                          && (re_opcode_t) *p1 == on_failure_jump))
branch  0 never executed
branch  1 never executed
    #####: 9329:                    goto fail;
    #####: 9330:                  break;
      931: 9331:                default:
        -: 9332:                  /* do nothing */ ;
        -: 9333:                }
        -: 9334:            }
        -: 9335:
   390933: 9336:          if (d >= string1 && d <= end1)
branch  0 taken 390933 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 390933
    #####: 9337:	    dend = end_match_1;
        -: 9338:        }
        -: 9339:      else
   658395: 9340:        break;   /* Matching at this starting point really fails.  */
        -: 9341:    } /* for (;;) */
        -: 9342:
   658395: 9343:  if (best_regs_set)
branch  0 taken 55 (fallthrough)
branch  1 taken 658340
       55: 9344:    goto restore_best_regs;
        -: 9345:
   658340: 9346:  FREE_VARIABLES ();
        -: 9347:
   658340: 9348:  return -1;         			/* Failure to match.  */
        -: 9349:} /* re_match_2 */
        -: 9350:
        -: 9351:/* Subroutine definitions for re_match_2.  */
        -: 9352:
        -: 9353:
        -: 9354:/* We are passed P pointing to a register number after a start_memory.
        -: 9355:
        -: 9356:   Return true if the pattern up to the corresponding stop_memory can
        -: 9357:   match the empty string, and false otherwise.
        -: 9358:
        -: 9359:   If we find the matching stop_memory, sets P to point to one past its number.
        -: 9360:   Otherwise, sets P to an undefined byte less than or equal to END.
        -: 9361:
        -: 9362:   We don't handle duplicates properly (yet).  */
        -: 9363:
        -: 9364:static boolean
function group_match_null_string_p called 3458 returned 100% blocks executed 56%
     3458: 9365:group_match_null_string_p (p, end, reg_info)
        -: 9366:    unsigned char **p, *end;
        -: 9367:    register_info_type *reg_info;
        -: 9368:{
        -: 9369:  int mcnt;
        -: 9370:  /* Point to after the args to the start_memory.  */
     3458: 9371:  unsigned char *p1 = *p + 2;
        -: 9372:
     3458: 9373:  while (p1 < end)
branch  0 taken 3458
branch  1 taken 0 (fallthrough)
        -: 9374:    {
        -: 9375:      /* Skip over opcodes that can match nothing, and return true or
        -: 9376:	 false, as appropriate, when we get to one that can't, or to the
        -: 9377:         matching stop_memory.  */
        -: 9378:
     3458: 9379:      switch ((re_opcode_t) *p1)
branch  0 taken 30
branch  1 taken 0
branch  2 taken 3428
        -: 9380:        {
        -: 9381:        /* Could be either a loop or a series of alternatives.  */
       30: 9382:        case on_failure_jump:
       30: 9383:          p1++;
       30: 9384:          EXTRACT_NUMBER_AND_INCR (mcnt, p1);
        -: 9385:
        -: 9386:          /* If the next operation is not a jump backwards in the
        -: 9387:	     pattern.  */
        -: 9388:
       30: 9389:	  if (mcnt >= 0)
branch  0 taken 30 (fallthrough)
branch  1 taken 0
        -: 9390:	    {
        -: 9391:              /* Go through the on_failure_jumps of the alternatives,
        -: 9392:                 seeing if any of the alternatives cannot match nothing.
        -: 9393:                 The last alternative starts with only a jump,
        -: 9394:                 whereas the rest start with on_failure_jump and end
        -: 9395:                 with a jump, e.g., here is the pattern for `a|b|c':
        -: 9396:
        -: 9397:                 /on_failure_jump/0/6/exactn/1/a/jump_past_alt/0/6
        -: 9398:                 /on_failure_jump/0/6/exactn/1/b/jump_past_alt/0/3
        -: 9399:                 /exactn/1/c
        -: 9400:
        -: 9401:                 So, we have to first go through the first (n-1)
        -: 9402:                 alternatives and then deal with the last one separately.  */
        -: 9403:
        -: 9404:
        -: 9405:              /* Deal with the first (n-1) alternatives, which start
        -: 9406:                 with an on_failure_jump (see above) that jumps to right
        -: 9407:                 past a jump_past_alt.  */
        -: 9408:
       30: 9409:              while ((re_opcode_t) p1[mcnt-3] == jump_past_alt)
branch  0 taken 0
branch  1 taken 30 (fallthrough)
        -: 9410:                {
        -: 9411:                  /* `mcnt' holds how many bytes long the alternative
        -: 9412:                     is, including the ending `jump_past_alt' and
        -: 9413:                     its number.  */
        -: 9414:
    #####: 9415:                  if (!alt_match_null_string_p (p1, p1 + mcnt - 3,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 9416:				                      reg_info))
    #####: 9417:                    return false;
        -: 9418:
        -: 9419:                  /* Move to right after this alternative, including the
        -: 9420:		     jump_past_alt.  */
    #####: 9421:                  p1 += mcnt;
        -: 9422:
        -: 9423:                  /* Break if it's the beginning of an n-th alternative
        -: 9424:                     that doesn't begin with an on_failure_jump.  */
    #####: 9425:                  if ((re_opcode_t) *p1 != on_failure_jump)
branch  0 never executed
branch  1 never executed
    #####: 9426:                    break;
        -: 9427:
        -: 9428:		  /* Still have to check that it's not an n-th
        -: 9429:		     alternative that starts with an on_failure_jump.  */
    #####: 9430:		  p1++;
    #####: 9431:                  EXTRACT_NUMBER_AND_INCR (mcnt, p1);
    #####: 9432:                  if ((re_opcode_t) p1[mcnt-3] != jump_past_alt)
branch  0 never executed
branch  1 never executed
        -: 9433:                    {
        -: 9434:		      /* Get to the beginning of the n-th alternative.  */
    #####: 9435:                      p1 -= 3;
    #####: 9436:                      break;
        -: 9437:                    }
        -: 9438:                }
        -: 9439:
        -: 9440:              /* Deal with the last alternative: go back and get number
        -: 9441:                 of the `jump_past_alt' just before it.  `mcnt' contains
        -: 9442:                 the length of the alternative.  */
       30: 9443:              EXTRACT_NUMBER (mcnt, p1 - 2);
        -: 9444:
       30: 9445:              if (!alt_match_null_string_p (p1, p1 + mcnt, reg_info))
call    0 returned 30
branch  1 taken 30 (fallthrough)
branch  2 taken 0
       30: 9446:                return false;
        -: 9447:
    #####: 9448:              p1 += mcnt;	/* Get past the n-th alternative.  */
        -: 9449:            } /* if mcnt > 0 */
    #####: 9450:          break;
        -: 9451:
        -: 9452:
    #####: 9453:        case stop_memory:
        -: 9454:	  assert (p1[1] == **p);
    #####: 9455:          *p = p1 + 2;
    #####: 9456:          return true;
        -: 9457:
        -: 9458:
     3428: 9459:        default:
     3428: 9460:          if (!common_op_match_null_string_p (&p1, end, reg_info))
call    0 returned 3428
branch  1 taken 3428 (fallthrough)
branch  2 taken 0
     3428: 9461:            return false;
        -: 9462:        }
        -: 9463:    } /* while p1 < end */
        -: 9464:
    #####: 9465:  return false;
        -: 9466:} /* group_match_null_string_p */
        -: 9467:
        -: 9468:
        -: 9469:/* Similar to group_match_null_string_p, but doesn't deal with alternatives:
        -: 9470:   It expects P to be the first byte of a single alternative and END one
        -: 9471:   byte past the last. The alternative can contain groups.  */
        -: 9472:
        -: 9473:static boolean
function alt_match_null_string_p called 30 returned 100% blocks executed 80%
       30: 9474:alt_match_null_string_p (p, end, reg_info)
        -: 9475:    unsigned char *p, *end;
        -: 9476:    register_info_type *reg_info;
        -: 9477:{
        -: 9478:  int mcnt;
       30: 9479:  unsigned char *p1 = p;
        -: 9480:
       30: 9481:  while (p1 < end)
branch  0 taken 30
branch  1 taken 0 (fallthrough)
        -: 9482:    {
        -: 9483:      /* Skip over opcodes that can match nothing, and break when we get
        -: 9484:         to one that can't.  */
        -: 9485:
       30: 9486:      switch ((re_opcode_t) *p1)
branch  0 taken 0 (fallthrough)
branch  1 taken 30
        -: 9487:        {
        -: 9488:	/* It's a loop.  */
    #####: 9489:        case on_failure_jump:
    #####: 9490:          p1++;
    #####: 9491:          EXTRACT_NUMBER_AND_INCR (mcnt, p1);
    #####: 9492:          p1 += mcnt;
    #####: 9493:          break;
        -: 9494:
       30: 9495:	default:
       30: 9496:          if (!common_op_match_null_string_p (&p1, end, reg_info))
call    0 returned 30
branch  1 taken 30 (fallthrough)
branch  2 taken 0
       30: 9497:            return false;
        -: 9498:        }
        -: 9499:    }  /* while p1 < end */
        -: 9500:
    #####: 9501:  return true;
        -: 9502:} /* alt_match_null_string_p */
        -: 9503:
        -: 9504:
        -: 9505:/* Deals with the ops common to group_match_null_string_p and
        -: 9506:   alt_match_null_string_p.
        -: 9507:
        -: 9508:   Sets P to one after the op and its arguments, if any.  */
        -: 9509:
        -: 9510:static boolean
function common_op_match_null_string_p called 3458 returned 100% blocks executed 17%
     3458: 9511:common_op_match_null_string_p (p, end, reg_info)
        -: 9512:    unsigned char **p, *end;
        -: 9513:    register_info_type *reg_info;
        -: 9514:{
        -: 9515:  int mcnt;
        -: 9516:  boolean ret;
        -: 9517:  int reg_no;
     3458: 9518:  unsigned char *p1 = *p;
        -: 9519:
     3458: 9520:  switch ((re_opcode_t) *p1++)
branch  0 taken 0
branch  1 taken 0
branch  2 taken 0
branch  3 taken 0
branch  4 taken 0
branch  5 taken 0
branch  6 taken 3458
        -: 9521:    {
    #####: 9522:    case no_op:
        -: 9523:    case begline:
        -: 9524:    case endline:
        -: 9525:    case begbuf:
        -: 9526:    case endbuf:
        -: 9527:    case wordbeg:
        -: 9528:    case wordend:
        -: 9529:    case wordbound:
        -: 9530:    case notwordbound:
        -: 9531:#ifdef emacs
        -: 9532:    case before_dot:
        -: 9533:    case at_dot:
        -: 9534:    case after_dot:
        -: 9535:#endif
    #####: 9536:      break;
        -: 9537:
    #####: 9538:    case start_memory:
    #####: 9539:      reg_no = *p1;
        -: 9540:      assert (reg_no > 0 && reg_no <= MAX_REGNUM);
    #####: 9541:      ret = group_match_null_string_p (&p1, end, reg_info);
call    0 never executed
        -: 9542:
        -: 9543:      /* Have to set this here in case we're checking a group which
        -: 9544:         contains a group and a back reference to it.  */
        -: 9545:
    #####: 9546:      if (REG_MATCH_NULL_STRING_P (reg_info[reg_no]) == MATCH_NULL_UNSET_VALUE)
branch  0 never executed
branch  1 never executed
    #####: 9547:        REG_MATCH_NULL_STRING_P (reg_info[reg_no]) = ret;
        -: 9548:
    #####: 9549:      if (!ret)
branch  0 never executed
branch  1 never executed
    #####: 9550:        return false;
    #####: 9551:      break;
        -: 9552:
        -: 9553:    /* If this is an optimized succeed_n for zero times, make the jump.  */
    #####: 9554:    case jump:
    #####: 9555:      EXTRACT_NUMBER_AND_INCR (mcnt, p1);
    #####: 9556:      if (mcnt >= 0)
branch  0 never executed
branch  1 never executed
    #####: 9557:        p1 += mcnt;
        -: 9558:      else
    #####: 9559:        return false;
    #####: 9560:      break;
        -: 9561:
    #####: 9562:    case succeed_n:
        -: 9563:      /* Get to the number of times to succeed.  */
    #####: 9564:      p1 += 2;
    #####: 9565:      EXTRACT_NUMBER_AND_INCR (mcnt, p1);
        -: 9566:
    #####: 9567:      if (mcnt == 0)
branch  0 never executed
branch  1 never executed
        -: 9568:        {
    #####: 9569:          p1 -= 4;
    #####: 9570:          EXTRACT_NUMBER_AND_INCR (mcnt, p1);
    #####: 9571:          p1 += mcnt;
        -: 9572:        }
        -: 9573:      else
    #####: 9574:        return false;
    #####: 9575:      break;
        -: 9576:
    #####: 9577:    case duplicate:
    #####: 9578:      if (!REG_MATCH_NULL_STRING_P (reg_info[*p1]))
branch  0 never executed
branch  1 never executed
    #####: 9579:        return false;
    #####: 9580:      break;
        -: 9581:
    #####: 9582:    case set_number_at:
    #####: 9583:      p1 += 4;
        -: 9584:
     3458: 9585:    default:
        -: 9586:      /* All other opcodes mean we cannot match the empty string.  */
     3458: 9587:      return false;
        -: 9588:  }
        -: 9589:
    #####: 9590:  *p = p1;
    #####: 9591:  return true;
        -: 9592:} /* common_op_match_null_string_p */
        -: 9593:
        -: 9594:
        -: 9595:/* Return zero if TRANSLATE[S1] and TRANSLATE[S2] are identical for LEN
        -: 9596:   bytes; nonzero otherwise.  */
        -: 9597:
        -: 9598:static int
function bcmp_translate called 0 returned 0% blocks executed 0%
    #####: 9599:bcmp_translate (s1, s2, len, translate)
        -: 9600:     const char *s1, *s2;
        -: 9601:     register int len;
        -: 9602:     RE_TRANSLATE_TYPE translate;
        -: 9603:{
    #####: 9604:  register const unsigned char *p1 = (const unsigned char *) s1;
    #####: 9605:  register const unsigned char *p2 = (const unsigned char *) s2;
    #####: 9606:  while (len)
branch  0 never executed
branch  1 never executed
        -: 9607:    {
    #####: 9608:      if (translate[*p1++] != translate[*p2++]) return 1;
branch  0 never executed
branch  1 never executed
    #####: 9609:      len--;
        -: 9610:    }
    #####: 9611:  return 0;
        -: 9612:}
        -: 9613:
        -: 9614:/* Entry points for GNU code.  */
        -: 9615:
        -: 9616:/* re_compile_pattern is the GNU regular expression compiler: it
        -: 9617:   compiles PATTERN (of length SIZE) and puts the result in BUFP.
        -: 9618:   Returns 0 if the pattern was valid, otherwise an error string.
        -: 9619:
        -: 9620:   Assumes the `allocated' (and perhaps `buffer') and `translate' fields
        -: 9621:   are set in BUFP on entry.
        -: 9622:
        -: 9623:   We call regex_compile to do the actual compilation.  */
        -: 9624:
        -: 9625:const char *
function re_compile_pattern called 0 returned 0% blocks executed 0%
    #####: 9626:re_compile_pattern (pattern, length, bufp)
        -: 9627:     const char *pattern;
        -: 9628:     size_t length;
        -: 9629:     struct re_pattern_buffer *bufp;
        -: 9630:{
        -: 9631:  reg_errcode_t ret;
        -: 9632:
        -: 9633:  /* GNU code is written to assume at least RE_NREGS registers will be set
        -: 9634:     (and at least one extra will be -1).  */
    #####: 9635:  bufp->regs_allocated = REGS_UNALLOCATED;
        -: 9636:
        -: 9637:  /* And GNU code determines whether or not to get register information
        -: 9638:     by passing null for the REGS argument to re_match, etc., not by
        -: 9639:     setting no_sub.  */
    #####: 9640:  bufp->no_sub = 0;
        -: 9641:
        -: 9642:  /* Match anchors at newline.  */
    #####: 9643:  bufp->newline_anchor = 1;
        -: 9644:
    #####: 9645:  ret = regex_compile (pattern, length, re_syntax_options, bufp);
call    0 never executed
        -: 9646:
    #####: 9647:  if (!ret)
branch  0 never executed
branch  1 never executed
    #####: 9648:    return NULL;
    #####: 9649:  return gettext (re_error_msgid[(int) ret]);
        -: 9650:}
        -: 9651:#ifdef _LIBC
        -: 9652:weak_alias (__re_compile_pattern, re_compile_pattern)
        -: 9653:#endif
        -: 9654:
        -: 9655:/* Entry points compatible with 4.2 BSD regex library.  We don't define
        -: 9656:   them unless specifically requested.  */
        -: 9657:
        -: 9658:#if defined _REGEX_RE_COMP || defined _LIBC
        -: 9659:
        -: 9660:/* BSD has one and only one pattern buffer.  */
        -: 9661:static struct re_pattern_buffer re_comp_buf;
        -: 9662:
        -: 9663:char *
        -: 9664:#ifdef _LIBC
        -: 9665:/* Make these definitions weak in libc, so POSIX programs can redefine
        -: 9666:   these names if they don't use our functions, and still use
        -: 9667:   regcomp/regexec below without link errors.  */
        -: 9668:weak_function
        -: 9669:#endif
        -: 9670:re_comp (s)
        -: 9671:    const char *s;
        -: 9672:{
        -: 9673:  reg_errcode_t ret;
        -: 9674:
        -: 9675:  if (!s)
        -: 9676:    {
        -: 9677:      if (!re_comp_buf.buffer)
        -: 9678:	return gettext ("No previous regular expression");
        -: 9679:      return 0;
        -: 9680:    }
        -: 9681:
        -: 9682:  if (!re_comp_buf.buffer)
        -: 9683:    {
        -: 9684:      re_comp_buf.buffer = (unsigned char *) malloc (200);
        -: 9685:      if (re_comp_buf.buffer == NULL)
        -: 9686:        return gettext (re_error_msgid[(int) REG_ESPACE]);
        -: 9687:      re_comp_buf.allocated = 200;
        -: 9688:
        -: 9689:      re_comp_buf.fastmap = (char *) malloc (1 << BYTEWIDTH);
        -: 9690:      if (re_comp_buf.fastmap == NULL)
        -: 9691:	return gettext (re_error_msgid[(int) REG_ESPACE]);
        -: 9692:    }
        -: 9693:
        -: 9694:  /* Since `re_exec' always passes NULL for the `regs' argument, we
        -: 9695:     don't need to initialize the pattern buffer fields which affect it.  */
        -: 9696:
        -: 9697:  /* Match anchors at newlines.  */
        -: 9698:  re_comp_buf.newline_anchor = 1;
        -: 9699:
        -: 9700:  ret = regex_compile (s, strlen (s), re_syntax_options, &re_comp_buf);
        -: 9701:
        -: 9702:  if (!ret)
        -: 9703:    return NULL;
        -: 9704:
        -: 9705:  /* Yes, we're discarding `const' here if !HAVE_LIBINTL.  */
        -: 9706:  return (char *) gettext (re_error_msgid[(int) ret]);
        -: 9707:}
        -: 9708:
        -: 9709:
        -: 9710:int
        -: 9711:#ifdef _LIBC
        -: 9712:weak_function
        -: 9713:#endif
        -: 9714:re_exec (s)
        -: 9715:    const char *s;
        -: 9716:{
        -: 9717:  const int len = strlen (s);
        -: 9718:  return
        -: 9719:    0 <= re_search (&re_comp_buf, s, len, 0, len, (struct re_registers *) 0);
        -: 9720:}
        -: 9721:
        -: 9722:#endif /* _REGEX_RE_COMP */
        -: 9723:
        -: 9724:/* POSIX.2 functions.  Don't define these for Emacs.  */
        -: 9725:
        -: 9726:#ifndef emacs
        -: 9727:
        -: 9728:/* regcomp takes a regular expression as a string and compiles it.
        -: 9729:
        -: 9730:   PREG is a regex_t *.  We do not expect any fields to be initialized,
        -: 9731:   since POSIX says we shouldn't.  Thus, we set
        -: 9732:
        -: 9733:     `buffer' to the compiled pattern;
        -: 9734:     `used' to the length of the compiled pattern;
        -: 9735:     `syntax' to RE_SYNTAX_POSIX_EXTENDED if the
        -: 9736:       REG_EXTENDED bit in CFLAGS is set; otherwise, to
        -: 9737:       RE_SYNTAX_POSIX_BASIC;
        -: 9738:     `newline_anchor' to REG_NEWLINE being set in CFLAGS;
        -: 9739:     `fastmap' and `fastmap_accurate' to zero;
        -: 9740:     `re_nsub' to the number of subexpressions in PATTERN.
        -: 9741:
        -: 9742:   PATTERN is the address of the pattern string.
        -: 9743:
        -: 9744:   CFLAGS is a series of bits which affect compilation.
        -: 9745:
        -: 9746:     If REG_EXTENDED is set, we use POSIX extended syntax; otherwise, we
        -: 9747:     use POSIX basic syntax.
        -: 9748:
        -: 9749:     If REG_NEWLINE is set, then . and [^...] don't match newline.
        -: 9750:     Also, regexec will try a match beginning after every newline.
        -: 9751:
        -: 9752:     If REG_ICASE is set, then we considers upper- and lowercase
        -: 9753:     versions of letters to be equivalent when matching.
        -: 9754:
        -: 9755:     If REG_NOSUB is set, then when PREG is passed to regexec, that
        -: 9756:     routine will report only success or failure, and nothing about the
        -: 9757:     registers.
        -: 9758:
        -: 9759:   It returns 0 if it succeeds, nonzero if it doesn't.  (See regex-gnu.h for
        -: 9760:   the return codes and their meanings.)  */
        -: 9761:
        -: 9762:int
function regcomp called 622 returned 100% blocks executed 52%
      622: 9763:regcomp (preg, pattern, cflags)
        -: 9764:    regex_t *preg;
        -: 9765:    const char *pattern;
        -: 9766:    int cflags;
        -: 9767:{
        -: 9768:  reg_errcode_t ret;
      622: 9769:  reg_syntax_t syntax
      622: 9770:    = (cflags & REG_EXTENDED) ?
      622: 9771:      RE_SYNTAX_POSIX_EXTENDED : RE_SYNTAX_POSIX_BASIC;
branch  0 taken 1 (fallthrough)
branch  1 taken 621
        -: 9772:
        -: 9773:  /* regex_compile will allocate the space for the compiled pattern.  */
      622: 9774:  preg->buffer = 0;
      622: 9775:  preg->allocated = 0;
      622: 9776:  preg->used = 0;
        -: 9777:
        -: 9778:  /* Don't bother to use a fastmap when searching.  This simplifies the
        -: 9779:     REG_NEWLINE case: if we used a fastmap, we'd have to put all the
        -: 9780:     characters after newlines into the fastmap.  This way, we just try
        -: 9781:     every character.  */
      622: 9782:  preg->fastmap = 0;
        -: 9783:
      622: 9784:  if (cflags & REG_ICASE)
branch  0 taken 0 (fallthrough)
branch  1 taken 622
        -: 9785:    {
        -: 9786:      unsigned i;
        -: 9787:
        -: 9788:      preg->translate
    #####: 9789:	= (RE_TRANSLATE_TYPE) malloc (CHAR_SET_SIZE
        -: 9790:				      * sizeof (*(RE_TRANSLATE_TYPE)0));
    #####: 9791:      if (preg->translate == NULL)
branch  0 never executed
branch  1 never executed
    #####: 9792:        return (int) REG_ESPACE;
        -: 9793:
        -: 9794:      /* Map uppercase characters to corresponding lowercase ones.  */
    #####: 9795:      for (i = 0; i < CHAR_SET_SIZE; i++)
branch  0 never executed
branch  1 never executed
    #####: 9796:        preg->translate[i] = ISUPPER (i) ? tolower (i) : i;
branch  0 never executed
branch  1 never executed
        -: 9797:    }
        -: 9798:  else
      622: 9799:    preg->translate = NULL;
        -: 9800:
        -: 9801:  /* If REG_NEWLINE is set, newlines are treated differently.  */
      622: 9802:  if (cflags & REG_NEWLINE)
branch  0 taken 0 (fallthrough)
branch  1 taken 622
        -: 9803:    { /* REG_NEWLINE implies neither . nor [^...] match newline.  */
    #####: 9804:      syntax &= ~RE_DOT_NEWLINE;
    #####: 9805:      syntax |= RE_HAT_LISTS_NOT_NEWLINE;
        -: 9806:      /* It also changes the matching behavior.  */
    #####: 9807:      preg->newline_anchor = 1;
        -: 9808:    }
        -: 9809:  else
      622: 9810:    preg->newline_anchor = 0;
        -: 9811:
      622: 9812:  preg->no_sub = !!(cflags & REG_NOSUB);
        -: 9813:
        -: 9814:  /* POSIX says a null character in the pattern terminates it, so we
        -: 9815:     can use strlen here in compiling the pattern.  */
      622: 9816:  ret = regex_compile (pattern, strlen (pattern), syntax, preg);
call    0 returned 622
        -: 9817:
        -: 9818:  /* POSIX doesn't distinguish between an unmatched open-group and an
        -: 9819:     unmatched close-group: both are REG_EPAREN.  */
     622*: 9820:  if (ret == REG_ERPAREN) ret = REG_EPAREN;
branch  0 taken 0 (fallthrough)
branch  1 taken 622
        -: 9821:
      622: 9822:  return (int) ret;
        -: 9823:}
        -: 9824:#ifdef _LIBC
        -: 9825:weak_alias (__regcomp, regcomp)
        -: 9826:#endif
        -: 9827:
        -: 9828:
        -: 9829:/* regnexec searches for a given pattern, specified by PREG, in the
        -: 9830:   memory buffer STRING of lengthe LEN.
        -: 9831:
        -: 9832:   If NMATCH is zero or REG_NOSUB was set in the cflags argument to
        -: 9833:   `regcomp', we ignore PMATCH.  Otherwise, we assume PMATCH has at
        -: 9834:   least NMATCH elements, and we set them to the offsets of the
        -: 9835:   corresponding matched substrings.
        -: 9836:
        -: 9837:   EFLAGS specifies `execution flags' which affect matching: if
        -: 9838:   REG_NOTBOL is set, then ^ does not match at the beginning of the
        -: 9839:   string; if REG_NOTEOL is set, then $ does not match at the end.
        -: 9840:
        -: 9841:   We return 0 if we find a match and REG_NOMATCH if not.  */
        -: 9842:
        -: 9843:int
function regnexec called 46417 returned 100% blocks executed 95%
    46417: 9844:regnexec (preg, string, len, nmatch, pmatch, eflags)
        -: 9845:    const regex_t *preg;
        -: 9846:    const char *string;
        -: 9847:    size_t len;
        -: 9848:    size_t nmatch;
        -: 9849:    regmatch_t pmatch[];
        -: 9850:    int eflags;
        -: 9851:{
        -: 9852:  int ret;
        -: 9853:  struct re_registers regs;
        -: 9854:  regex_t private_preg;
    46417: 9855:  boolean want_reg_info = !preg->no_sub && nmatch > 0;
branch  0 taken 14521 (fallthrough)
branch  1 taken 31896
branch  2 taken 14521 (fallthrough)
branch  3 taken 0
        -: 9856:
    46417: 9857:  private_preg = *preg;
        -: 9858:
    46417: 9859:  private_preg.not_bol = !!(eflags & REG_NOTBOL);
    46417: 9860:  private_preg.not_eol = !!(eflags & REG_NOTEOL);
        -: 9861:
        -: 9862:  /* The user has told us exactly how many registers to return
        -: 9863:     information about, via `nmatch'.  We have to pass that on to the
        -: 9864:     matching routines.  */
    46417: 9865:  private_preg.regs_allocated = REGS_FIXED;
        -: 9866:
    46417: 9867:  if (want_reg_info)
branch  0 taken 14521 (fallthrough)
branch  1 taken 31896
        -: 9868:    {
    14521: 9869:      regs.num_regs = nmatch;
    14521: 9870:      regs.start = TALLOC (nmatch, regoff_t);
    14521: 9871:      regs.end = TALLOC (nmatch, regoff_t);
    14521: 9872:      if (regs.start == NULL || regs.end == NULL)
branch  0 taken 14521 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 14521
    #####: 9873:        return (int) REG_NOMATCH;
        -: 9874:    }
        -: 9875:
        -: 9876:  /* Perform the searching operation.  */
    46417: 9877:  ret = re_search (&private_preg, string, len,
branch  0 taken 14521 (fallthrough)
branch  1 taken 31896
call    2 returned 46417
        -: 9878:                   /* start: */ 0, /* range: */ len,
        -: 9879:                   want_reg_info ? &regs : (struct re_registers *) 0);
        -: 9880:
        -: 9881:  /* Copy the register information to the POSIX structure.  */
    46417: 9882:  if (want_reg_info)
branch  0 taken 14521 (fallthrough)
branch  1 taken 31896
        -: 9883:    {
    14521: 9884:      if (ret >= 0)
branch  0 taken 3491 (fallthrough)
branch  1 taken 11030
        -: 9885:        {
        -: 9886:          unsigned r;
        -: 9887:
    38401: 9888:          for (r = 0; r < nmatch; r++)
branch  0 taken 34910
branch  1 taken 3491 (fallthrough)
        -: 9889:            {
    34910: 9890:              pmatch[r].rm_so = regs.start[r];
    34910: 9891:              pmatch[r].rm_eo = regs.end[r];
        -: 9892:            }
        -: 9893:        }
        -: 9894:
        -: 9895:      /* If we needed the temporary register info, free the space now.  */
    14521: 9896:      free (regs.start);
    14521: 9897:      free (regs.end);
        -: 9898:    }
        -: 9899:
        -: 9900:  /* We want zero return to mean success, unlike `re_search'.  */
    46417: 9901:  return ret >= 0 ? (int) REG_NOERROR : (int) REG_NOMATCH;
        -: 9902:}
        -: 9903:#ifdef _LIBC
        -: 9904:weak_alias (__regnexec, regnexec)
        -: 9905:#endif
        -: 9906:
        -: 9907:/* regexec searches for a given pattern, specified by PREG, in the
        -: 9908:   string STRING.
        -: 9909:
        -: 9910:   If NMATCH is zero or REG_NOSUB was set in the cflags argument to
        -: 9911:   `regcomp', we ignore PMATCH.  Otherwise, we assume PMATCH has at
        -: 9912:   least NMATCH elements, and we set them to the offsets of the
        -: 9913:   corresponding matched substrings.
        -: 9914:
        -: 9915:   EFLAGS specifies `execution flags' which affect matching: if
        -: 9916:   REG_NOTBOL is set, then ^ does not match at the beginning of the
        -: 9917:   string; if REG_NOTEOL is set, then $ does not match at the end.
        -: 9918:
        -: 9919:   We return 0 if we find a match and REG_NOMATCH if not.  */
        -: 9920:
        -: 9921:int
function regexec called 0 returned 0% blocks executed 0%
    #####: 9922:regexec (preg, string, nmatch, pmatch, eflags)
        -: 9923:    const regex_t *preg;
        -: 9924:    const char *string;
        -: 9925:    size_t nmatch;
        -: 9926:    regmatch_t pmatch[];
        -: 9927:    int eflags;
        -: 9928:{
    #####: 9929:  return regnexec(preg, string, strlen(string), nmatch, pmatch, eflags);
call    0 never executed
        -: 9930:}
        -: 9931:#ifdef _LIBC
        -: 9932:weak_alias (__regexec, regexec)
        -: 9933:#endif
        -: 9934:
        -: 9935:
        -: 9936:/* Returns a message corresponding to an error code, ERRCODE, returned
        -: 9937:   from either regcomp or regexec.   We don't use PREG here.  */
        -: 9938:
        -: 9939:size_t
function regerror called 0 returned 0% blocks executed 0%
    #####: 9940:regerror (errcode, preg, errbuf, errbuf_size)
        -: 9941:    int errcode;
        -: 9942:    const regex_t *preg;
        -: 9943:    char *errbuf;
        -: 9944:    size_t errbuf_size;
        -: 9945:{
        -: 9946:  const char *msg;
        -: 9947:  size_t msg_size;
        -: 9948:
    #####: 9949:  if (errcode < 0
branch  0 never executed
branch  1 never executed
    #####: 9950:      || errcode >= (int) (sizeof (re_error_msgid)
branch  0 never executed
branch  1 never executed
        -: 9951:			   / sizeof (re_error_msgid[0])))
        -: 9952:    /* Only error codes returned by the rest of the code should be passed
        -: 9953:       to this routine.  If we are given anything else, or if other regex
        -: 9954:       code generates an invalid error code, then the program has a bug.
        -: 9955:       Dump core so we can fix it.  */
    #####: 9956:    abort ();
call    0 never executed
        -: 9957:
    #####: 9958:  msg = gettext (re_error_msgid[errcode]);
        -: 9959:
    #####: 9960:  msg_size = strlen (msg) + 1; /* Includes the null.  */
        -: 9961:
    #####: 9962:  if (errbuf_size != 0)
branch  0 never executed
branch  1 never executed
        -: 9963:    {
    #####: 9964:      if (msg_size > errbuf_size)
branch  0 never executed
branch  1 never executed
        -: 9965:        {
        -: 9966:#if defined HAVE_MEMPCPY || defined _LIBC
        -: 9967:	  *((char *) __mempcpy (errbuf, msg, errbuf_size - 1)) = '\0';
        -: 9968:#else
    #####: 9969:          memcpy (errbuf, msg, errbuf_size - 1);
    #####: 9970:          errbuf[errbuf_size - 1] = 0;
        -: 9971:#endif
        -: 9972:        }
        -: 9973:      else
    #####: 9974:        memcpy (errbuf, msg, msg_size);
        -: 9975:    }
        -: 9976:
    #####: 9977:  return msg_size;
        -: 9978:}
        -: 9979:#ifdef _LIBC
        -: 9980:weak_alias (__regerror, regerror)
        -: 9981:#endif
        -: 9982:
        -: 9983:
        -: 9984:/* Free dynamically allocated space used by PREG.  */
        -: 9985:
        -: 9986:void
function regfree called 0 returned 0% blocks executed 0%
    #####: 9987:regfree (preg)
        -: 9988:    regex_t *preg;
        -: 9989:{
    #####: 9990:  if (preg->buffer != NULL)
branch  0 never executed
branch  1 never executed
    #####: 9991:    free (preg->buffer);
    #####: 9992:  preg->buffer = NULL;
        -: 9993:
    #####: 9994:  preg->allocated = 0;
    #####: 9995:  preg->used = 0;
        -: 9996:
    #####: 9997:  if (preg->fastmap != NULL)
branch  0 never executed
branch  1 never executed
    #####: 9998:    free (preg->fastmap);
    #####: 9999:  preg->fastmap = NULL;
    #####:10000:  preg->fastmap_accurate = 0;
        -:10001:
    #####:10002:  if (preg->translate != NULL)
branch  0 never executed
branch  1 never executed
    #####:10003:    free (preg->translate);
    #####:10004:  preg->translate = NULL;
    #####:10005:}
        -:10006:#ifdef _LIBC
        -:10007:weak_alias (__regfree, regfree)
        -:10008:#endif
        -:10009:
        -:10010:#endif /* not emacs  */
